###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.2.10312/W32 for ARM       15/Mar/2016  18:17:15
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Middlewares\ST\STM32_USB_Device_Library\Core\Src\usbd_core.c
#    Command line =  
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Middlewares\ST\STM32_USB_Device_Library\Core\Src\usbd_core.c
#        -D USE_HAL_DRIVER -D STM32F746xx -D USE_STM32746G_DISCO -D
#        USE_IOEXPANDER -D USE_USB_FS -lC
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
#        -lA
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
#        -o
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj
#        --no_unroll --debug --endian=little --cpu=Cortex-M7 -e --fpu=VFPv5_sp
#        --dlib_config "D:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Full.h" -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\CMSIS\Device\ST\STM32F7xx\Include\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\STM32F7xx_HAL_Driver\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\STM32746G-Discovery\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\Components\Common\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Log\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Fonts\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\CPU\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_Device_Library\Core\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Core\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Class\MSC\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\drivers\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_Audio\Addons\PDM\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_Device_Library\Class\AUDIO\Inc\
#        -Ohs --use_c++_inline --require_prototypes -I "D:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.3\arm\CMSIS\Include\" -D
#        ARM_MATH_CM7 --relaxed_fp
#    List file    =  
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List\usbd_core.lst
#    Object file  =  
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj\usbd_core.o
#
###############################################################################

D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Middlewares\ST\STM32_USB_Device_Library\Core\Src\usbd_core.c
      1          /**
      2            ******************************************************************************
      3            * @file    usbd_core.c
      4            * @author  MCD Application Team
      5            * @version V2.4.1
      6            * @date    19-June-2015
      7            * @brief   This file provides all the USBD core functions.
      8            ******************************************************************************
      9            * @attention
     10            *
     11            * <h2><center>&copy; COPYRIGHT 2015 STMicroelectronics</center></h2>
     12            *
     13            * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
     14            * You may not use this file except in compliance with the License.
     15            * You may obtain a copy of the License at:
     16            *
     17            *        http://www.st.com/software_license_agreement_liberty_v2
     18            *
     19            * Unless required by applicable law or agreed to in writing, software 
     20            * distributed under the License is distributed on an "AS IS" BASIS, 
     21            * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     22            * See the License for the specific language governing permissions and
     23            * limitations under the License.
     24            *
     25            ******************************************************************************
     26            */ 
     27          
     28          /* Includes ------------------------------------------------------------------*/
     29          #include "usbd_core.h"
     30          
     31          /** @addtogroup STM32_USBD_DEVICE_LIBRARY
     32          * @{
     33          */
     34          
     35          
     36          /** @defgroup USBD_CORE 
     37          * @brief usbd core module
     38          * @{
     39          */ 
     40          
     41          /** @defgroup USBD_CORE_Private_TypesDefinitions
     42          * @{
     43          */ 
     44          /**
     45          * @}
     46          */ 
     47          
     48          
     49          /** @defgroup USBD_CORE_Private_Defines
     50          * @{
     51          */ 
     52          
     53          /**
     54          * @}
     55          */ 
     56          
     57          
     58          /** @defgroup USBD_CORE_Private_Macros
     59          * @{
     60          */ 
     61          /**
     62          * @}
     63          */ 
     64          
     65          
     66          
     67          
     68          /** @defgroup USBD_CORE_Private_FunctionPrototypes
     69          * @{
     70          */ 
     71          
     72          /**
     73          * @}
     74          */ 
     75          
     76          /** @defgroup USBD_CORE_Private_Variables
     77          * @{
     78          */ 
     79          
     80          /**
     81          * @}
     82          */ 
     83          
     84          /** @defgroup USBD_CORE_Private_Functions
     85          * @{
     86          */ 
     87          
     88          /**
     89          * @brief  USBD_Init
     90          *         Initializes the device stack and load the class driver
     91          * @param  pdev: device instance
     92          * @param  pdesc: Descriptor structure address
     93          * @param  id: Low level core index
     94          * @retval None
     95          */

   \                                 In section .text, align 2, keep-with-next
     96          USBD_StatusTypeDef USBD_Init(USBD_HandleTypeDef *pdev, USBD_DescriptorsTypeDef *pdesc, uint8_t id)
     97          {
   \                     USBD_Init: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB081             SUB      SP,SP,#+4
     98            /* Check whether the USB Host handle is valid */
     99            if(pdev == NULL)
   \   00000004   0xB910             CBNZ.N   R0,??USBD_Init_0
    100            {
    101              USBD_ErrLog("Invalid Device handle");
    102              return USBD_FAIL; 
   \   00000006   0x2002             MOVS     R0,#+2
   \   00000008   0xB001             ADD      SP,SP,#+4
   \   0000000A   0xBD00             POP      {PC}
    103            }
    104            
    105            /* Unlink previous class*/
    106            if(pdev->pClass != NULL)
   \                     ??USBD_Init_0: (+1)
   \   0000000C   0xF8D0 0x3214      LDR      R3,[R0, #+532]
   \   00000010   0xB113             CBZ.N    R3,??USBD_Init_1
    107            {
    108              pdev->pClass = NULL;
   \   00000012   0x2300             MOVS     R3,#+0
   \   00000014   0xF8C0 0x3214      STR      R3,[R0, #+532]
    109            }
    110            
    111            /* Assign USBD Descriptors */
    112            if(pdesc != NULL)
   \                     ??USBD_Init_1: (+1)
   \   00000018   0xB109             CBZ.N    R1,??USBD_Init_2
    113            {
    114              pdev->pDesc = pdesc;
   \   0000001A   0xF8C0 0x1210      STR      R1,[R0, #+528]
    115            }
    116            
    117            /* Set Device initial State */
    118            pdev->dev_state  = USBD_STATE_DEFAULT;
   \                     ??USBD_Init_2: (+1)
   \   0000001E   0x2101             MOVS     R1,#+1
   \   00000020   0xF880 0x11FC      STRB     R1,[R0, #+508]
    119            pdev->id = id;
   \   00000024   0x7002             STRB     R2,[R0, #+0]
    120            /* Initialize low level driver */
    121            USBD_LL_Init(pdev);
   \   00000026   0x.... 0x....      BL       USBD_LL_Init
    122            
    123            return USBD_OK; 
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0xB001             ADD      SP,SP,#+4
   \   0000002E   0xBD00             POP      {PC}             ;; return
    124          }
    125          
    126          /**
    127          * @brief  USBD_DeInit 
    128          *         Re-Initialize th device library
    129          * @param  pdev: device instance
    130          * @retval status: status
    131          */

   \                                 In section .text, align 2, keep-with-next
    132          USBD_StatusTypeDef USBD_DeInit(USBD_HandleTypeDef *pdev)
    133          {
   \                     USBD_DeInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    134            /* Set Default State */
    135            pdev->dev_state  = USBD_STATE_DEFAULT;
   \   00000004   0x2001             MOVS     R0,#+1
   \   00000006   0xF884 0x01FC      STRB     R0,[R4, #+508]
    136            
    137            /* Free Class Resources */
    138            pdev->pClass->DeInit(pdev, pdev->dev_config);  
   \   0000000A   0x4620             MOV      R0,R4
   \   0000000C   0xF8D4 0x2214      LDR      R2,[R4, #+532]
   \   00000010   0x6861             LDR      R1,[R4, #+4]
   \   00000012   0x6852             LDR      R2,[R2, #+4]
   \   00000014   0xB2C9             UXTB     R1,R1
   \   00000016   0x4790             BLX      R2
    139            
    140              /* Stop the low level driver  */
    141            USBD_LL_Stop(pdev); 
   \   00000018   0x4620             MOV      R0,R4
   \   0000001A   0x.... 0x....      BL       USBD_LL_Stop
    142            
    143            /* Initialize low level driver */
    144            USBD_LL_DeInit(pdev);
   \   0000001E   0x4620             MOV      R0,R4
   \   00000020   0x.... 0x....      BL       USBD_LL_DeInit
    145            
    146            return USBD_OK;
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0xBD10             POP      {R4,PC}          ;; return
    147          }
    148          
    149          
    150          /**
    151            * @brief  USBD_RegisterClass 
    152            *         Link class driver to Device Core.
    153            * @param  pDevice : Device Handle
    154            * @param  pclass: Class handle
    155            * @retval USBD Status
    156            */

   \                                 In section .text, align 2, keep-with-next
    157          USBD_StatusTypeDef  USBD_RegisterClass(USBD_HandleTypeDef *pdev, USBD_ClassTypeDef *pclass)
    158          {
    159            USBD_StatusTypeDef   status = USBD_OK;
   \                     USBD_RegisterClass: (+1)
   \   00000000   0x2200             MOVS     R2,#+0
    160            if(pclass != 0)
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xBF14             ITE      NE 
   \   00000006   0xF8C0 0x1214      STRNE    R1,[R0, #+532]
   \   0000000A   0x2202             MOVEQ    R2,#+2
    161            {
    162              /* link the class to the USB Device handle */
    163              pdev->pClass = pclass;
    164              status = USBD_OK;
    165            }
    166            else
    167            {
    168              USBD_ErrLog("Invalid Class handle");
    169              status = USBD_FAIL; 
    170            }
    171            
    172            return status;
   \   0000000C   0x4610             MOV      R0,R2
   \   0000000E   0x4770             BX       LR               ;; return
    173          }
    174          
    175          /**
    176            * @brief  USBD_Start 
    177            *         Start the USB Device Core.
    178            * @param  pdev: Device Handle
    179            * @retval USBD Status
    180            */

   \                                 In section .text, align 2, keep-with-next
    181          USBD_StatusTypeDef  USBD_Start  (USBD_HandleTypeDef *pdev)
    182          {
   \                     USBD_Start: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB081             SUB      SP,SP,#+4
    183            
    184            /* Start the low level driver  */
    185            USBD_LL_Start(pdev); 
   \   00000004   0x.... 0x....      BL       USBD_LL_Start
    186            
    187            return USBD_OK;  
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0xB001             ADD      SP,SP,#+4
   \   0000000C   0xBD00             POP      {PC}             ;; return
    188          }
    189          
    190          /**
    191            * @brief  USBD_Stop 
    192            *         Stop the USB Device Core.
    193            * @param  pdev: Device Handle
    194            * @retval USBD Status
    195            */

   \                                 In section .text, align 2, keep-with-next
    196          USBD_StatusTypeDef  USBD_Stop   (USBD_HandleTypeDef *pdev)
    197          {
   \                     USBD_Stop: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    198            /* Free Class Resources */
    199            pdev->pClass->DeInit(pdev, pdev->dev_config);  
   \   00000004   0xF8D4 0x2214      LDR      R2,[R4, #+532]
   \   00000008   0x6861             LDR      R1,[R4, #+4]
   \   0000000A   0x6852             LDR      R2,[R2, #+4]
   \   0000000C   0xB2C9             UXTB     R1,R1
   \   0000000E   0x4790             BLX      R2
    200          
    201            /* Stop the low level driver  */
    202            USBD_LL_Stop(pdev); 
   \   00000010   0x4620             MOV      R0,R4
   \   00000012   0x.... 0x....      BL       USBD_LL_Stop
    203            
    204            return USBD_OK;  
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0xBD10             POP      {R4,PC}          ;; return
    205          }
    206          
    207          /**
    208          * @brief  USBD_RunTestMode 
    209          *         Launch test mode process
    210          * @param  pdev: device instance
    211          * @retval status
    212          */

   \                                 In section .text, align 2, keep-with-next
    213          USBD_StatusTypeDef  USBD_RunTestMode (USBD_HandleTypeDef  *pdev) 
    214          {
    215            return USBD_OK;
   \                     USBD_RunTestMode: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x4770             BX       LR               ;; return
    216          }
    217          
    218          
    219          /**
    220          * @brief  USBD_SetClassConfig 
    221          *        Configure device and start the interface
    222          * @param  pdev: device instance
    223          * @param  cfgidx: configuration index
    224          * @retval status
    225          */
    226          

   \                                 In section .text, align 2, keep-with-next
    227          USBD_StatusTypeDef USBD_SetClassConfig(USBD_HandleTypeDef  *pdev, uint8_t cfgidx)
    228          {
   \                     USBD_SetClassConfig: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    229            USBD_StatusTypeDef   ret = USBD_FAIL;
    230            
    231            if(pdev->pClass != NULL)
   \   00000002   0xF8D0 0x2214      LDR      R2,[R0, #+532]
   \   00000006   0x2402             MOVS     R4,#+2
   \   00000008   0xB11A             CBZ.N    R2,??USBD_SetClassConfig_0
    232            {
    233              /* Set configuration  and Start the Class*/
    234              if(pdev->pClass->Init(pdev, cfgidx) == 0)
   \   0000000A   0x6812             LDR      R2,[R2, #+0]
   \   0000000C   0x4790             BLX      R2
   \   0000000E   0xB900             CBNZ.N   R0,??USBD_SetClassConfig_0
    235              {
    236                ret = USBD_OK;
   \   00000010   0x2400             MOVS     R4,#+0
    237              }
    238            }
    239            return ret; 
   \                     ??USBD_SetClassConfig_0: (+1)
   \   00000012   0x4620             MOV      R0,R4
   \   00000014   0xBD10             POP      {R4,PC}          ;; return
    240          }
    241          
    242          /**
    243          * @brief  USBD_ClrClassConfig 
    244          *         Clear current configuration
    245          * @param  pdev: device instance
    246          * @param  cfgidx: configuration index
    247          * @retval status: USBD_StatusTypeDef
    248          */

   \                                 In section .text, align 2, keep-with-next
    249          USBD_StatusTypeDef USBD_ClrClassConfig(USBD_HandleTypeDef  *pdev, uint8_t cfgidx)
    250          {
   \                     USBD_ClrClassConfig: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB081             SUB      SP,SP,#+4
    251            /* Clear configuration  and De-initialize the Class process*/
    252            pdev->pClass->DeInit(pdev, cfgidx);  
   \   00000004   0xF8D0 0x2214      LDR      R2,[R0, #+532]
   \   00000008   0x6852             LDR      R2,[R2, #+4]
   \   0000000A   0x4790             BLX      R2
    253            return USBD_OK;
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0xB001             ADD      SP,SP,#+4
   \   00000010   0xBD00             POP      {PC}             ;; return
    254          }
    255          
    256          
    257          /**
    258          * @brief  USBD_SetupStage 
    259          *         Handle the setup stage
    260          * @param  pdev: device instance
    261          * @retval status
    262          */

   \                                 In section .text, align 2, keep-with-next
    263          USBD_StatusTypeDef USBD_LL_SetupStage(USBD_HandleTypeDef *pdev, uint8_t *psetup)
    264          {
   \                     USBD_LL_SetupStage: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    265          
    266            USBD_ParseSetupRequest(&pdev->request, psetup);
   \   00000004   0xF504 0x7002      ADD      R0,R4,#+520
   \   00000008   0x.... 0x....      BL       USBD_ParseSetupRequest
    267            
    268            pdev->ep0_state = USBD_EP0_SETUP;
   \   0000000C   0x2001             MOVS     R0,#+1
   \   0000000E   0xF8C4 0x01F4      STR      R0,[R4, #+500]
    269            pdev->ep0_data_len = pdev->request.wLength;
   \   00000012   0xF8B4 0x020E      LDRH     R0,[R4, #+526]
   \   00000016   0xF8C4 0x01F8      STR      R0,[R4, #+504]
    270            
    271            switch (pdev->request.bmRequest & 0x1F) 
   \   0000001A   0xF894 0x0208      LDRB     R0,[R4, #+520]
   \   0000001E   0xF010 0x011F      ANDS     R1,R0,#0x1F
   \   00000022   0xD003             BEQ.N    ??USBD_LL_SetupStage_0
   \   00000024   0x2902             CMP      R1,#+2
   \   00000026   0xD00F             BEQ.N    ??USBD_LL_SetupStage_1
   \   00000028   0xD307             BCC.N    ??USBD_LL_SetupStage_2
   \   0000002A   0xE014             B.N      ??USBD_LL_SetupStage_3
    272            {
    273            case USB_REQ_RECIPIENT_DEVICE:   
    274              USBD_StdDevReq (pdev, &pdev->request);
   \                     ??USBD_LL_SetupStage_0: (+1)
   \   0000002C   0xF504 0x7102      ADD      R1,R4,#+520
   \   00000030   0x4620             MOV      R0,R4
   \   00000032   0x.... 0x....      BL       USBD_StdDevReq
    275              break;
    276              
    277            case USB_REQ_RECIPIENT_INTERFACE:     
    278              USBD_StdItfReq(pdev, &pdev->request);
    279              break;
    280              
    281            case USB_REQ_RECIPIENT_ENDPOINT:        
    282              USBD_StdEPReq(pdev, &pdev->request);   
    283              break;
    284              
    285            default:           
    286              USBD_LL_StallEP(pdev , pdev->request.bmRequest & 0x80);
    287              break;
    288            }  
    289            return USBD_OK;  
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0xBD10             POP      {R4,PC}
   \                     ??USBD_LL_SetupStage_2: (+1)
   \   0000003A   0xF504 0x7102      ADD      R1,R4,#+520
   \   0000003E   0x4620             MOV      R0,R4
   \   00000040   0x.... 0x....      BL       USBD_StdItfReq
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0xBD10             POP      {R4,PC}
   \                     ??USBD_LL_SetupStage_1: (+1)
   \   00000048   0xF504 0x7102      ADD      R1,R4,#+520
   \   0000004C   0x4620             MOV      R0,R4
   \   0000004E   0x.... 0x....      BL       USBD_StdEPReq
   \   00000052   0x2000             MOVS     R0,#+0
   \   00000054   0xBD10             POP      {R4,PC}
   \                     ??USBD_LL_SetupStage_3: (+1)
   \   00000056   0xF000 0x0180      AND      R1,R0,#0x80
   \   0000005A   0x4620             MOV      R0,R4
   \   0000005C   0x.... 0x....      BL       USBD_LL_StallEP
   \   00000060   0x2000             MOVS     R0,#+0
   \   00000062   0xBD10             POP      {R4,PC}          ;; return
    290          }
    291          
    292          /**
    293          * @brief  USBD_DataOutStage 
    294          *         Handle data OUT stage
    295          * @param  pdev: device instance
    296          * @param  epnum: endpoint index
    297          * @retval status
    298          */

   \                                 In section .text, align 2, keep-with-next
    299          USBD_StatusTypeDef USBD_LL_DataOutStage(USBD_HandleTypeDef *pdev , uint8_t epnum, uint8_t *pdata)
    300          {
   \                     USBD_LL_DataOutStage: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x4610             MOV      R0,R2
    301            USBD_EndpointTypeDef    *pep;
    302            
    303            if(epnum == 0) 
   \   00000006   0xBB29             CBNZ.N   R1,??USBD_LL_DataOutStage_0
    304            {
    305              pep = &pdev->ep_out[0];
    306              
    307              if ( pdev->ep0_state == USBD_EP0_DATA_OUT)
   \   00000008   0xF8D4 0x21F4      LDR      R2,[R4, #+500]
   \   0000000C   0xF504 0x7182      ADD      R1,R4,#+260
   \   00000010   0x2A03             CMP      R2,#+3
   \   00000012   0xD12A             BNE.N    ??USBD_LL_DataOutStage_1
    308              {
    309                if(pep->rem_length > pep->maxpacket)
   \   00000014   0x688B             LDR      R3,[R1, #+8]
   \   00000016   0x68CA             LDR      R2,[R1, #+12]
   \   00000018   0x429A             CMP      R2,R3
   \   0000001A   0xD20B             BCS.N    ??USBD_LL_DataOutStage_2
    310                {
    311                  pep->rem_length -=  pep->maxpacket;
   \   0000001C   0x1A9B             SUBS     R3,R3,R2
    312                 
    313                  USBD_CtlContinueRx (pdev, 
    314                                      pdata,
    315                                      MIN(pep->rem_length ,pep->maxpacket));
   \   0000001E   0x4293             CMP      R3,R2
   \   00000020   0x608B             STR      R3,[R1, #+8]
   \   00000022   0x4601             MOV      R1,R0
   \   00000024   0x4620             MOV      R0,R4
   \   00000026   0xBF38             IT       CC 
   \   00000028   0x461A             MOVCC    R2,R3
   \   0000002A   0xB292             UXTH     R2,R2
   \   0000002C   0x.... 0x....      BL       USBD_CtlContinueRx
    316                }
    317                else
    318                {
    319                  if((pdev->pClass->EP0_RxReady != NULL)&&
    320                     (pdev->dev_state == USBD_STATE_CONFIGURED))
    321                  {
    322                    pdev->pClass->EP0_RxReady(pdev); 
    323                  }
    324                  USBD_CtlSendStatus(pdev);
    325                }
    326              }
    327            }
    328            else if((pdev->pClass->DataOut != NULL)&&
    329                    (pdev->dev_state == USBD_STATE_CONFIGURED))
    330            {
    331              pdev->pClass->DataOut(pdev, epnum); 
    332            }  
    333            return USBD_OK;
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0xBD10             POP      {R4,PC}
   \                     ??USBD_LL_DataOutStage_2: (+1)
   \   00000034   0xF8D4 0x0214      LDR      R0,[R4, #+532]
   \   00000038   0x6901             LDR      R1,[R0, #+16]
   \   0000003A   0x0008             MOVS     R0,R1
   \   0000003C   0xD005             BEQ.N    ??USBD_LL_DataOutStage_3
   \   0000003E   0xF894 0x01FC      LDRB     R0,[R4, #+508]
   \   00000042   0x2803             CMP      R0,#+3
   \   00000044   0xBF04             ITT      EQ 
   \   00000046   0x4620             MOVEQ    R0,R4
   \   00000048   0x4788             BLXEQ    R1
   \                     ??USBD_LL_DataOutStage_3: (+1)
   \   0000004A   0x4620             MOV      R0,R4
   \   0000004C   0x.... 0x....      BL       USBD_CtlSendStatus
   \   00000050   0x2000             MOVS     R0,#+0
   \   00000052   0xBD10             POP      {R4,PC}
   \                     ??USBD_LL_DataOutStage_0: (+1)
   \   00000054   0xF8D4 0x0214      LDR      R0,[R4, #+532]
   \   00000058   0x6982             LDR      R2,[R0, #+24]
   \   0000005A   0x0010             MOVS     R0,R2
   \   0000005C   0xD005             BEQ.N    ??USBD_LL_DataOutStage_1
   \   0000005E   0xF894 0x01FC      LDRB     R0,[R4, #+508]
   \   00000062   0x2803             CMP      R0,#+3
   \   00000064   0xBF04             ITT      EQ 
   \   00000066   0x4620             MOVEQ    R0,R4
   \   00000068   0x4790             BLXEQ    R2
   \                     ??USBD_LL_DataOutStage_1: (+1)
   \   0000006A   0x2000             MOVS     R0,#+0
   \   0000006C   0xBD10             POP      {R4,PC}          ;; return
    334          }
    335          
    336          /**
    337          * @brief  USBD_DataInStage 
    338          *         Handle data in stage
    339          * @param  pdev: device instance
    340          * @param  epnum: endpoint index
    341          * @retval status
    342          */

   \                                 In section .text, align 2, keep-with-next
    343          USBD_StatusTypeDef USBD_LL_DataInStage(USBD_HandleTypeDef *pdev ,uint8_t epnum, uint8_t *pdata)
    344          {
   \                     USBD_LL_DataInStage: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    345            USBD_EndpointTypeDef    *pep;
    346              
    347            if(epnum == 0) 
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x4610             MOV      R0,R2
   \   00000008   0xD146             BNE.N    ??USBD_LL_DataInStage_0
    348            {
    349              pep = &pdev->ep_in[0];
    350              
    351              if ( pdev->ep0_state == USBD_EP0_DATA_IN)
   \   0000000A   0xF8D4 0x21F4      LDR      R2,[R4, #+500]
   \   0000000E   0xF104 0x0114      ADD      R1,R4,#+20
   \   00000012   0x2A02             CMP      R2,#+2
   \   00000014   0xD137             BNE.N    ??USBD_LL_DataInStage_1
    352              {
    353                if(pep->rem_length > pep->maxpacket)
   \   00000016   0x688A             LDR      R2,[R1, #+8]
   \   00000018   0x68CB             LDR      R3,[R1, #+12]
   \   0000001A   0x4293             CMP      R3,R2
   \   0000001C   0xD20A             BCS.N    ??USBD_LL_DataInStage_2
    354                {
    355                  pep->rem_length -=  pep->maxpacket;
   \   0000001E   0x1AD2             SUBS     R2,R2,R3
   \   00000020   0x608A             STR      R2,[R1, #+8]
    356                  
    357                  USBD_CtlContinueSendData (pdev, 
    358                                            pdata, 
    359                                            pep->rem_length);
   \   00000022   0x4601             MOV      R1,R0
   \   00000024   0xB292             UXTH     R2,R2
   \   00000026   0x4620             MOV      R0,R4
   \   00000028   0x.... 0x....      BL       USBD_CtlContinueSendData
    360                  
    361                  /* Prepare endpoint for premature end of transfer */
    362                  USBD_LL_PrepareReceive (pdev,
    363                                          0,
    364                                          NULL,
    365                                          0);  
   \   0000002C   0x2300             MOVS     R3,#+0
   \   0000002E   0x2200             MOVS     R2,#+0
   \   00000030   0x2100             MOVS     R1,#+0
   \   00000032   0xE016             B.N      ??USBD_LL_DataInStage_3
    366                }
    367                else
    368                { /* last packet is MPS multiple, so send ZLP packet */
    369                  if((pep->total_length % pep->maxpacket == 0) &&
    370                     (pep->total_length >= pep->maxpacket) &&
    371                       (pep->total_length < pdev->ep0_data_len ))
   \                     ??USBD_LL_DataInStage_2: (+1)
   \   00000034   0x6848             LDR      R0,[R1, #+4]
   \   00000036   0xFBB0 0xF1F3      UDIV     R1,R0,R3
   \   0000003A   0xFB03 0x0111      MLS      R1,R3,R1,R0
   \   0000003E   0xB9A1             CBNZ.N   R1,??USBD_LL_DataInStage_4
   \   00000040   0x4298             CMP      R0,R3
   \   00000042   0xD312             BCC.N    ??USBD_LL_DataInStage_4
   \   00000044   0xF8D4 0x11F8      LDR      R1,[R4, #+504]
   \   00000048   0x4288             CMP      R0,R1
   \   0000004A   0xD20E             BCS.N    ??USBD_LL_DataInStage_4
    372                  {
    373                    
    374                    USBD_CtlContinueSendData(pdev , NULL, 0);
   \   0000004C   0x2200             MOVS     R2,#+0
   \   0000004E   0x2100             MOVS     R1,#+0
   \   00000050   0x4620             MOV      R0,R4
   \   00000052   0x.... 0x....      BL       USBD_CtlContinueSendData
    375                    pdev->ep0_data_len = 0;
   \   00000056   0x2000             MOVS     R0,#+0
    376                    
    377                  /* Prepare endpoint for premature end of transfer */
    378                  USBD_LL_PrepareReceive (pdev,
    379                                          0,
    380                                          NULL,
    381                                          0);
   \   00000058   0x2300             MOVS     R3,#+0
   \   0000005A   0xF8C4 0x01F8      STR      R0,[R4, #+504]
   \   0000005E   0x2200             MOVS     R2,#+0
   \   00000060   0x2100             MOVS     R1,#+0
   \                     ??USBD_LL_DataInStage_3: (+1)
   \   00000062   0x4620             MOV      R0,R4
   \   00000064   0x.... 0x....      BL       USBD_LL_PrepareReceive
   \   00000068   0xE00D             B.N      ??USBD_LL_DataInStage_1
    382                  }
    383                  else
    384                  {
    385                    if((pdev->pClass->EP0_TxSent != NULL)&&
    386                       (pdev->dev_state == USBD_STATE_CONFIGURED))
   \                     ??USBD_LL_DataInStage_4: (+1)
   \   0000006A   0xF8D4 0x0214      LDR      R0,[R4, #+532]
   \   0000006E   0x68C1             LDR      R1,[R0, #+12]
   \   00000070   0x0008             MOVS     R0,R1
   \   00000072   0xD005             BEQ.N    ??USBD_LL_DataInStage_5
   \   00000074   0xF894 0x01FC      LDRB     R0,[R4, #+508]
   \   00000078   0x2803             CMP      R0,#+3
   \   0000007A   0xBF04             ITT      EQ 
    387                    {
    388                      pdev->pClass->EP0_TxSent(pdev); 
   \   0000007C   0x4620             MOVEQ    R0,R4
   \   0000007E   0x4788             BLXEQ    R1
    389                    }          
    390                    USBD_CtlReceiveStatus(pdev);
   \                     ??USBD_LL_DataInStage_5: (+1)
   \   00000080   0x4620             MOV      R0,R4
   \   00000082   0x.... 0x....      BL       USBD_CtlReceiveStatus
    391                  }
    392                }
    393              }
    394              if (pdev->dev_test_mode == 1)
   \                     ??USBD_LL_DataInStage_1: (+1)
   \   00000086   0xF894 0x0200      LDRB     R0,[R4, #+512]
   \   0000008A   0x2801             CMP      R0,#+1
   \   0000008C   0xD10F             BNE.N    ??USBD_LL_DataInStage_6
    395              {
    396                USBD_RunTestMode(pdev); 
    397                pdev->dev_test_mode = 0;
   \   0000008E   0x2000             MOVS     R0,#+0
   \   00000090   0xF884 0x0200      STRB     R0,[R4, #+512]
    398              }
    399            }
    400            else if((pdev->pClass->DataIn != NULL)&& 
    401                    (pdev->dev_state == USBD_STATE_CONFIGURED))
    402            {
    403              pdev->pClass->DataIn(pdev, epnum); 
    404            }  
    405            return USBD_OK;
   \   00000094   0x2000             MOVS     R0,#+0
   \   00000096   0xBD10             POP      {R4,PC}
   \                     ??USBD_LL_DataInStage_0: (+1)
   \   00000098   0xF8D4 0x0214      LDR      R0,[R4, #+532]
   \   0000009C   0x6942             LDR      R2,[R0, #+20]
   \   0000009E   0x0010             MOVS     R0,R2
   \   000000A0   0xD005             BEQ.N    ??USBD_LL_DataInStage_6
   \   000000A2   0xF894 0x01FC      LDRB     R0,[R4, #+508]
   \   000000A6   0x2803             CMP      R0,#+3
   \   000000A8   0xBF04             ITT      EQ 
   \   000000AA   0x4620             MOVEQ    R0,R4
   \   000000AC   0x4790             BLXEQ    R2
   \                     ??USBD_LL_DataInStage_6: (+1)
   \   000000AE   0x2000             MOVS     R0,#+0
   \   000000B0   0xBD10             POP      {R4,PC}          ;; return
    406          }
    407          
    408          /**
    409          * @brief  USBD_LL_Reset 
    410          *         Handle Reset event
    411          * @param  pdev: device instance
    412          * @retval status
    413          */
    414          

   \                                 In section .text, align 2, keep-with-next
    415          USBD_StatusTypeDef USBD_LL_Reset(USBD_HandleTypeDef  *pdev)
    416          {
   \                     USBD_LL_Reset: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    417            /* Open EP0 OUT */
    418            USBD_LL_OpenEP(pdev,
    419                        0x00,
    420                        USBD_EP_TYPE_CTRL,
    421                        USB_MAX_EP0_SIZE);
   \   00000004   0x2340             MOVS     R3,#+64
   \   00000006   0x2200             MOVS     R2,#+0
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0x.... 0x....      BL       USBD_LL_OpenEP
    422            
    423            pdev->ep_out[0].maxpacket = USB_MAX_EP0_SIZE;
   \   0000000E   0x2040             MOVS     R0,#+64
    424            
    425            /* Open EP0 IN */
    426            USBD_LL_OpenEP(pdev,
    427                        0x80,
    428                        USBD_EP_TYPE_CTRL,
    429                        USB_MAX_EP0_SIZE);
   \   00000010   0x2340             MOVS     R3,#+64
   \   00000012   0xF8C4 0x0110      STR      R0,[R4, #+272]
   \   00000016   0x2200             MOVS     R2,#+0
   \   00000018   0x2180             MOVS     R1,#+128
   \   0000001A   0x4620             MOV      R0,R4
   \   0000001C   0x.... 0x....      BL       USBD_LL_OpenEP
    430            
    431            pdev->ep_in[0].maxpacket = USB_MAX_EP0_SIZE;
   \   00000020   0x2040             MOVS     R0,#+64
   \   00000022   0x6220             STR      R0,[R4, #+32]
    432            /* Upon Reset call user call back */
    433            pdev->dev_state = USBD_STATE_DEFAULT;
   \   00000024   0x2001             MOVS     R0,#+1
   \   00000026   0xF884 0x01FC      STRB     R0,[R4, #+508]
    434            
    435            if (pdev->pClassData) 
   \   0000002A   0xF8D4 0x0218      LDR      R0,[R4, #+536]
   \   0000002E   0xB130             CBZ.N    R0,??USBD_LL_Reset_0
    436              pdev->pClass->DeInit(pdev, pdev->dev_config);  
   \   00000030   0xF8D4 0x2214      LDR      R2,[R4, #+532]
   \   00000034   0x6861             LDR      R1,[R4, #+4]
   \   00000036   0x4620             MOV      R0,R4
   \   00000038   0xB2C9             UXTB     R1,R1
   \   0000003A   0x6852             LDR      R2,[R2, #+4]
   \   0000003C   0x4790             BLX      R2
    437           
    438            
    439            return USBD_OK;
   \                     ??USBD_LL_Reset_0: (+1)
   \   0000003E   0x2000             MOVS     R0,#+0
   \   00000040   0xBD10             POP      {R4,PC}          ;; return
    440          }
    441          
    442          
    443          
    444          
    445          /**
    446          * @brief  USBD_LL_Reset 
    447          *         Handle Reset event
    448          * @param  pdev: device instance
    449          * @retval status
    450          */

   \                                 In section .text, align 2, keep-with-next
    451          USBD_StatusTypeDef USBD_LL_SetSpeed(USBD_HandleTypeDef  *pdev, USBD_SpeedTypeDef speed)
    452          {
    453            pdev->dev_speed = speed;
   \                     USBD_LL_SetSpeed: (+1)
   \   00000000   0x7401             STRB     R1,[R0, #+16]
    454            return USBD_OK;
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0x4770             BX       LR               ;; return
    455          }
    456          
    457          /**
    458          * @brief  USBD_Suspend 
    459          *         Handle Suspend event
    460          * @param  pdev: device instance
    461          * @retval status
    462          */
    463          

   \                                 In section .text, align 2, keep-with-next
    464          USBD_StatusTypeDef USBD_LL_Suspend(USBD_HandleTypeDef  *pdev)
    465          {
    466            pdev->dev_old_state =  pdev->dev_state;
   \                     USBD_LL_Suspend: (+1)
   \   00000000   0xF890 0x11FC      LDRB     R1,[R0, #+508]
   \   00000004   0xF880 0x11FD      STRB     R1,[R0, #+509]
    467            pdev->dev_state  = USBD_STATE_SUSPENDED;
   \   00000008   0x2104             MOVS     R1,#+4
   \   0000000A   0xF880 0x11FC      STRB     R1,[R0, #+508]
    468            return USBD_OK;
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0x4770             BX       LR               ;; return
    469          }
    470          
    471          /**
    472          * @brief  USBD_Resume 
    473          *         Handle Resume event
    474          * @param  pdev: device instance
    475          * @retval status
    476          */
    477          

   \                                 In section .text, align 2, keep-with-next
    478          USBD_StatusTypeDef USBD_LL_Resume(USBD_HandleTypeDef  *pdev)
    479          {
    480            pdev->dev_state = pdev->dev_old_state;  
   \                     USBD_LL_Resume: (+1)
   \   00000000   0xF890 0x11FD      LDRB     R1,[R0, #+509]
   \   00000004   0xF880 0x11FC      STRB     R1,[R0, #+508]
    481            return USBD_OK;
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x4770             BX       LR               ;; return
    482          }
    483          
    484          /**
    485          * @brief  USBD_SOF 
    486          *         Handle SOF event
    487          * @param  pdev: device instance
    488          * @retval status
    489          */
    490          

   \                                 In section .text, align 2, keep-with-next
    491          USBD_StatusTypeDef USBD_LL_SOF(USBD_HandleTypeDef  *pdev)
    492          {
   \                     USBD_LL_SOF: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB081             SUB      SP,SP,#+4
    493            if(pdev->dev_state == USBD_STATE_CONFIGURED)
   \   00000004   0xF890 0x11FC      LDRB     R1,[R0, #+508]
   \   00000008   0x2903             CMP      R1,#+3
   \   0000000A   0xD105             BNE.N    ??USBD_LL_SOF_0
   \   0000000C   0xF8D0 0x1214      LDR      R1,[R0, #+532]
   \   00000010   0x69C9             LDR      R1,[R1, #+28]
   \   00000012   0x000A             MOVS     R2,R1
   \   00000014   0xBF18             IT       NE 
    494            {
    495              if(pdev->pClass->SOF != NULL)
    496              {
    497                pdev->pClass->SOF(pdev);
   \   00000016   0x4788             BLXNE    R1
    498              }
    499            }
    500            return USBD_OK;
   \                     ??USBD_LL_SOF_0: (+1)
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0xB001             ADD      SP,SP,#+4
   \   0000001C   0xBD00             POP      {PC}             ;; return
    501          }
    502          
    503          /**
    504          * @brief  USBD_IsoINIncomplete 
    505          *         Handle iso in incomplete event
    506          * @param  pdev: device instance
    507          * @retval status
    508          */

   \                                 In section .text, align 2, keep-with-next
    509          USBD_StatusTypeDef USBD_LL_IsoINIncomplete(USBD_HandleTypeDef  *pdev, uint8_t epnum)
    510          {
    511            return USBD_OK;
   \                     USBD_LL_IsoINIncomplete: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x4770             BX       LR               ;; return
    512          }
    513          
    514          /**
    515          * @brief  USBD_IsoOUTIncomplete 
    516          *         Handle iso out incomplete event
    517          * @param  pdev: device instance
    518          * @retval status
    519          */

   \                                 In section .text, align 2, keep-with-next
    520          USBD_StatusTypeDef USBD_LL_IsoOUTIncomplete(USBD_HandleTypeDef  *pdev, uint8_t epnum)
    521          {
    522            return USBD_OK;
   \                     USBD_LL_IsoOUTIncomplete: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x4770             BX       LR               ;; return
    523          }
    524          
    525          /**
    526          * @brief  USBD_DevConnected 
    527          *         Handle device connection event
    528          * @param  pdev: device instance
    529          * @retval status
    530          */

   \                                 In section .text, align 2, keep-with-next
    531          USBD_StatusTypeDef USBD_LL_DevConnected(USBD_HandleTypeDef  *pdev)
    532          {
    533            return USBD_OK;
   \                     USBD_LL_DevConnected: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x4770             BX       LR               ;; return
    534          }
    535          
    536          /**
    537          * @brief  USBD_DevDisconnected 
    538          *         Handle device disconnection event
    539          * @param  pdev: device instance
    540          * @retval status
    541          */

   \                                 In section .text, align 2, keep-with-next
    542          USBD_StatusTypeDef USBD_LL_DevDisconnected(USBD_HandleTypeDef  *pdev)
    543          {
   \                     USBD_LL_DevDisconnected: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB081             SUB      SP,SP,#+4
    544            /* Free Class Resources */
    545            pdev->dev_state = USBD_STATE_DEFAULT;
   \   00000004   0x2101             MOVS     R1,#+1
    546            pdev->pClass->DeInit(pdev, pdev->dev_config);  
   \   00000006   0xF8D0 0x2214      LDR      R2,[R0, #+532]
   \   0000000A   0xF880 0x11FC      STRB     R1,[R0, #+508]
   \   0000000E   0x6841             LDR      R1,[R0, #+4]
   \   00000010   0x6852             LDR      R2,[R2, #+4]
   \   00000012   0xB2C9             UXTB     R1,R1
   \   00000014   0x4790             BLX      R2
    547             
    548            return USBD_OK;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0xB001             ADD      SP,SP,#+4
   \   0000001A   0xBD00             POP      {PC}             ;; return
    549          }
    550          /**
    551          * @}
    552          */ 
    553          
    554          
    555          /**
    556          * @}
    557          */ 
    558          
    559          
    560          /**
    561          * @}
    562          */ 
    563          
    564          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
    565          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   USBD_ClrClassConfig
         8   -- Indirect call
       8   USBD_DeInit
         8   -- Indirect call
         8   -> USBD_LL_DeInit
         8   -> USBD_LL_Stop
       8   USBD_Init
         8   -> USBD_LL_Init
       8   USBD_LL_DataInStage
         8   -- Indirect call
         8   -> USBD_CtlContinueSendData
         8   -> USBD_CtlReceiveStatus
         8   -> USBD_LL_PrepareReceive
       8   USBD_LL_DataOutStage
         8   -- Indirect call
         8   -> USBD_CtlContinueRx
         8   -> USBD_CtlSendStatus
       0   USBD_LL_DevConnected
       8   USBD_LL_DevDisconnected
         8   -- Indirect call
       0   USBD_LL_IsoINIncomplete
       0   USBD_LL_IsoOUTIncomplete
       8   USBD_LL_Reset
         8   -- Indirect call
         8   -> USBD_LL_OpenEP
       0   USBD_LL_Resume
       8   USBD_LL_SOF
         8   -- Indirect call
       0   USBD_LL_SetSpeed
       8   USBD_LL_SetupStage
         8   -> USBD_LL_StallEP
         8   -> USBD_ParseSetupRequest
         8   -> USBD_StdDevReq
         8   -> USBD_StdEPReq
         8   -> USBD_StdItfReq
       0   USBD_LL_Suspend
       0   USBD_RegisterClass
       0   USBD_RunTestMode
       8   USBD_SetClassConfig
         8   -- Indirect call
       8   USBD_Start
         8   -> USBD_LL_Start
       8   USBD_Stop
         8   -- Indirect call
         8   -> USBD_LL_Stop


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      18  USBD_ClrClassConfig
      40  USBD_DeInit
      48  USBD_Init
     178  USBD_LL_DataInStage
     110  USBD_LL_DataOutStage
       4  USBD_LL_DevConnected
      28  USBD_LL_DevDisconnected
       4  USBD_LL_IsoINIncomplete
       4  USBD_LL_IsoOUTIncomplete
      66  USBD_LL_Reset
      12  USBD_LL_Resume
      30  USBD_LL_SOF
       6  USBD_LL_SetSpeed
     100  USBD_LL_SetupStage
      18  USBD_LL_Suspend
      16  USBD_RegisterClass
       4  USBD_RunTestMode
      22  USBD_SetClassConfig
      14  USBD_Start
      26  USBD_Stop

 
 748 bytes in section .text
 
 748 bytes of CODE memory

Errors: none
Warnings: none
