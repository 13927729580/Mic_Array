###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.2.10312/W32 for ARM       23/Feb/2016  17:00:05
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Middlewares\ST\STM32_USB_Host_Library\Class\MSC\Src\usbh_msc_bot.c
#    Command line =  
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Middlewares\ST\STM32_USB_Host_Library\Class\MSC\Src\usbh_msc_bot.c
#        -D USE_HAL_DRIVER -D STM32F746xx -D USE_STM32746G_DISCO -D
#        USE_IOEXPANDER -D USE_USB_FS -lC
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
#        -lA
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
#        -o
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M7 -e --fpu=VFPv5_sp --dlib_config "D:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.3\arm\INC\c\DLib_Config_Full.h"
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\CMSIS\Device\ST\STM32F7xx\Include\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\STM32F7xx_HAL_Driver\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\STM32746G-Discovery\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\Components\Common\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Log\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Fonts\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\CPU\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_Device_Library\Core\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Core\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Class\MSC\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\drivers\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_Audio\Addons\PDM\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_Device_Library\Class\AUDIO\Inc\
#        -On --use_c++_inline --require_prototypes -I "D:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.3\arm\CMSIS\Include\" -D
#        ARM_MATH_CM7
#    List file    =  
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List\usbh_msc_bot.lst
#    Object file  =  
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj\usbh_msc_bot.o
#
###############################################################################

D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Middlewares\ST\STM32_USB_Host_Library\Class\MSC\Src\usbh_msc_bot.c
      1          /**
                   ^
Warning[Pa050]: non-native end of line sequence detected (this diagnostic is
          only issued once)
      2            ******************************************************************************
      3            * @file    usbh_msc_bot.c 
      4            * @author  MCD Application Team
      5            * @version V3.2.1
      6            * @date    26-June-2015
      7            * @brief   This file includes the BOT protocol related functions
      8            ******************************************************************************
      9            * @attention
     10            *
     11            * <h2><center>&copy; COPYRIGHT 2015 STMicroelectronics</center></h2>
     12            *
     13            * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
     14            * You may not use this file except in compliance with the License.
     15            * You may obtain a copy of the License at:
     16            *
     17            *        http://www.st.com/software_license_agreement_liberty_v2
     18            *
     19            * Unless required by applicable law or agreed to in writing, software 
     20            * distributed under the License is distributed on an "AS IS" BASIS, 
     21            * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     22            * See the License for the specific language governing permissions and
     23            * limitations under the License.
     24            *
     25            ******************************************************************************
     26            */ 
     27          
     28          /* Includes ------------------------------------------------------------------*/
     29          #include "usbh_msc_bot.h"
     30          #include "usbh_msc.h"
     31          
     32          /** @addtogroup USBH_LIB
     33          * @{
     34          */
     35          
     36          /** @addtogroup USBH_CLASS
     37          * @{
     38          */
     39          
     40          /** @addtogroup USBH_MSC_CLASS
     41          * @{
     42          */
     43          
     44          /** @defgroup USBH_MSC_BOT 
     45          * @brief    This file includes the mass storage related functions
     46          * @{
     47          */ 
     48          
     49          
     50          /** @defgroup USBH_MSC_BOT_Private_TypesDefinitions
     51          * @{
     52          */ 
     53          /**
     54          * @}
     55          */ 
     56          
     57          /** @defgroup USBH_MSC_BOT_Private_Defines
     58          * @{
     59          */ 
     60          /**
     61          * @}
     62          */ 
     63          
     64          /** @defgroup USBH_MSC_BOT_Private_Macros
     65          * @{
     66          */ 
     67          /**
     68          * @}
     69          */ 
     70          
     71          
     72          /** @defgroup USBH_MSC_BOT_Private_Variables
     73          * @{
     74          */ 
     75          
     76          /**
     77          * @}
     78          */ 
     79          
     80          
     81          /** @defgroup USBH_MSC_BOT_Private_FunctionPrototypes
     82          * @{
     83          */ 
     84          static USBH_StatusTypeDef USBH_MSC_BOT_Abort(USBH_HandleTypeDef *phost, uint8_t lun, uint8_t dir);
     85          static BOT_CSWStatusTypeDef USBH_MSC_DecodeCSW(USBH_HandleTypeDef *phost);
     86          /**
     87          * @}
     88          */ 
     89          
     90          
     91          /** @defgroup USBH_MSC_BOT_Exported_Variables
     92          * @{
     93          */ 
     94          /**
     95          * @}
     96          */ 
     97          
     98          
     99          /** @defgroup USBH_MSC_BOT_Private_Functions
    100          * @{
    101          */ 
    102          
    103          /**
    104            * @brief  USBH_MSC_BOT_REQ_Reset 
    105            *         The function the MSC BOT Reset request.
    106            * @param  phost: Host handle
    107            * @retval USBH Status
    108            */

   \                                 In section .text, align 2, keep-with-next
    109          USBH_StatusTypeDef USBH_MSC_BOT_REQ_Reset(USBH_HandleTypeDef *phost)
    110          {
   \                     USBH_MSC_BOT_REQ_Reset: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    111            
    112            phost->Control.setup.b.bmRequestType = USB_H2D | USB_REQ_TYPE_CLASS | \
    113                                        USB_REQ_RECIPIENT_INTERFACE;
   \   00000004   0x2021             MOVS     R0,#+33
   \   00000006   0x7420             STRB     R0,[R4, #+16]
    114            
    115            phost->Control.setup.b.bRequest = USB_REQ_BOT_RESET;
   \   00000008   0x20FF             MOVS     R0,#+255
   \   0000000A   0x7460             STRB     R0,[R4, #+17]
    116            phost->Control.setup.b.wValue.w = 0;
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x8260             STRH     R0,[R4, #+18]
    117            phost->Control.setup.b.wIndex.w = 0;
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0x82A0             STRH     R0,[R4, #+20]
    118            phost->Control.setup.b.wLength.w = 0;           
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0x82E0             STRH     R0,[R4, #+22]
    119            
    120            return USBH_CtlReq(phost, 0 , 0 );  
   \   00000018   0x2200             MOVS     R2,#+0
   \   0000001A   0x2100             MOVS     R1,#+0
   \   0000001C   0x0020             MOVS     R0,R4
   \   0000001E   0x.... 0x....      BL       USBH_CtlReq
   \   00000022   0xBD10             POP      {R4,PC}          ;; return
    121          }
    122          
    123          /**
    124            * @brief  USBH_MSC_BOT_REQ_GetMaxLUN 
    125            *         The function the MSC BOT GetMaxLUN request.
    126            * @param  phost: Host handle
    127            * @param  Maxlun: pointer to Maxlun variable
    128            * @retval USBH Status
    129            */

   \                                 In section .text, align 2, keep-with-next
    130          USBH_StatusTypeDef USBH_MSC_BOT_REQ_GetMaxLUN(USBH_HandleTypeDef *phost, uint8_t *Maxlun)
    131          {
   \                     USBH_MSC_BOT_REQ_GetMaxLUN: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    132            phost->Control.setup.b.bmRequestType = USB_D2H | USB_REQ_TYPE_CLASS | \
    133                                        USB_REQ_RECIPIENT_INTERFACE;
   \   00000006   0x20A1             MOVS     R0,#+161
   \   00000008   0x7420             STRB     R0,[R4, #+16]
    134            
    135            phost->Control.setup.b.bRequest = USB_REQ_GET_MAX_LUN;
   \   0000000A   0x20FE             MOVS     R0,#+254
   \   0000000C   0x7460             STRB     R0,[R4, #+17]
    136            phost->Control.setup.b.wValue.w = 0;
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0x8260             STRH     R0,[R4, #+18]
    137            phost->Control.setup.b.wIndex.w = 0;
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0x82A0             STRH     R0,[R4, #+20]
    138            phost->Control.setup.b.wLength.w = 1;           
   \   00000016   0x2001             MOVS     R0,#+1
   \   00000018   0x82E0             STRH     R0,[R4, #+22]
    139            
    140            return USBH_CtlReq(phost, Maxlun , 1 ); 
   \   0000001A   0x2201             MOVS     R2,#+1
   \   0000001C   0x0029             MOVS     R1,R5
   \   0000001E   0x0020             MOVS     R0,R4
   \   00000020   0x.... 0x....      BL       USBH_CtlReq
   \   00000024   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    141          }
    142          
    143          
    144          
    145          /**
    146            * @brief  USBH_MSC_BOT_Init 
    147            *         The function Initializes the BOT protocol.
    148            * @param  phost: Host handle
    149            * @retval USBH Status
    150            */

   \                                 In section .text, align 2, keep-with-next
    151          USBH_StatusTypeDef USBH_MSC_BOT_Init(USBH_HandleTypeDef *phost)
    152          {
   \                     USBH_MSC_BOT_Init: (+1)
   \   00000000   0x0001             MOVS     R1,R0
    153            
    154            MSC_HandleTypeDef *MSC_Handle =  (MSC_HandleTypeDef *) phost->pActiveClass->pData;
   \   00000002   0xF8D1 0x0264      LDR      R0,[R1, #+612]
   \   00000006   0x69C2             LDR      R2,[R0, #+28]
    155            
    156            MSC_Handle->hbot.cbw.field.Signature = BOT_CBW_SIGNATURE;
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable1  ;; 0x43425355
   \   0000000C   0x6550             STR      R0,[R2, #+84]
    157            MSC_Handle->hbot.cbw.field.Tag = BOT_CBW_TAG;
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable1_1  ;; 0x20304050
   \   00000012   0x6590             STR      R0,[R2, #+88]
    158            MSC_Handle->hbot.state = BOT_SEND_CBW;    
   \   00000014   0x2001             MOVS     R0,#+1
   \   00000016   0xF882 0x0050      STRB     R0,[R2, #+80]
    159            MSC_Handle->hbot.cmd_state = BOT_CMD_SEND;   
   \   0000001A   0x2001             MOVS     R0,#+1
   \   0000001C   0xF882 0x0052      STRB     R0,[R2, #+82]
    160            
    161            return USBH_OK;
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0x4770             BX       LR               ;; return
    162          }
    163          
    164          
    165          
    166          /**
    167            * @brief  USBH_MSC_BOT_Process 
    168            *         The function handle the BOT protocol.
    169            * @param  phost: Host handle
    170            * @param  lun: Logical Unit Number
    171            * @retval USBH Status
    172            */

   \                                 In section .text, align 2, keep-with-next
    173          USBH_StatusTypeDef USBH_MSC_BOT_Process (USBH_HandleTypeDef *phost, uint8_t lun)
    174          {
   \                     USBH_MSC_BOT_Process: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
    175            USBH_StatusTypeDef   status = USBH_BUSY;
   \   00000008   0x2601             MOVS     R6,#+1
    176            USBH_StatusTypeDef   error  = USBH_BUSY;  
   \   0000000A   0x2701             MOVS     R7,#+1
    177            BOT_CSWStatusTypeDef CSW_Status = BOT_CSW_CMD_FAILED;
   \   0000000C   0xF05F 0x0801      MOVS     R8,#+1
    178            USBH_URBStateTypeDef URB_Status = USBH_URB_IDLE;
   \   00000010   0xF05F 0x0900      MOVS     R9,#+0
    179            MSC_HandleTypeDef *MSC_Handle =  (MSC_HandleTypeDef *) phost->pActiveClass->pData;
   \   00000014   0xF8D4 0x0264      LDR      R0,[R4, #+612]
   \   00000018   0xF8D0 0xA01C      LDR      R10,[R0, #+28]
    180            uint8_t toggle = 0;
   \   0000001C   0xF05F 0x0B00      MOVS     R11,#+0
    181            
    182            switch (MSC_Handle->hbot.state)
   \   00000020   0xF89A 0x0050      LDRB     R0,[R10, #+80]
   \   00000024   0x2801             CMP      R0,#+1
   \   00000026   0xD018             BEQ.N    ??USBH_MSC_BOT_Process_0
   \   00000028   0xF0C0 0x8179      BCC.W    ??USBH_MSC_BOT_Process_1
   \   0000002C   0x2803             CMP      R0,#+3
   \   0000002E   0xD055             BEQ.N    ??USBH_MSC_BOT_Process_2
   \   00000030   0xD323             BCC.N    ??USBH_MSC_BOT_Process_3
   \   00000032   0x2805             CMP      R0,#+5
   \   00000034   0xF000 0x809D      BEQ.W    ??USBH_MSC_BOT_Process_4
   \   00000038   0xD35D             BCC.N    ??USBH_MSC_BOT_Process_5
   \   0000003A   0x2807             CMP      R0,#+7
   \   0000003C   0xF000 0x80F1      BEQ.W    ??USBH_MSC_BOT_Process_6
   \   00000040   0xF0C0 0x80A6      BCC.W    ??USBH_MSC_BOT_Process_7
   \   00000044   0x2809             CMP      R0,#+9
   \   00000046   0xF000 0x8121      BEQ.W    ??USBH_MSC_BOT_Process_8
   \   0000004A   0xF0C0 0x80F6      BCC.W    ??USBH_MSC_BOT_Process_9
   \   0000004E   0x280B             CMP      R0,#+11
   \   00000050   0xF000 0x815A      BEQ.W    ??USBH_MSC_BOT_Process_10
   \   00000054   0xF0C0 0x812F      BCC.W    ??USBH_MSC_BOT_Process_11
   \   00000058   0xE161             B.N      ??USBH_MSC_BOT_Process_1
    183            {
    184            case BOT_SEND_CBW:
    185              MSC_Handle->hbot.cbw.field.LUN = lun;
   \                     ??USBH_MSC_BOT_Process_0: (+1)
   \   0000005A   0xF88A 0x5061      STRB     R5,[R10, #+97]
    186              MSC_Handle->hbot.state = BOT_SEND_CBW_WAIT;    
   \   0000005E   0x2002             MOVS     R0,#+2
   \   00000060   0xF88A 0x0050      STRB     R0,[R10, #+80]
    187              USBH_BulkSendData (phost,
    188                                 MSC_Handle->hbot.cbw.data, 
    189                                 BOT_CBW_LENGTH, 
    190                                 MSC_Handle->OutPipe,
    191                                 1);
   \   00000064   0x2001             MOVS     R0,#+1
   \   00000066   0x9000             STR      R0,[SP, #+0]
   \   00000068   0xF89A 0x3005      LDRB     R3,[R10, #+5]
   \   0000006C   0x221F             MOVS     R2,#+31
   \   0000006E   0xF11A 0x0154      ADDS     R1,R10,#+84
   \   00000072   0x0020             MOVS     R0,R4
   \   00000074   0x.... 0x....      BL       USBH_BulkSendData
    192              
    193              break;
   \   00000078   0xE151             B.N      ??USBH_MSC_BOT_Process_12
    194              
    195            case BOT_SEND_CBW_WAIT:
    196              
    197              URB_Status = USBH_LL_GetURBState(phost, MSC_Handle->OutPipe); 
   \                     ??USBH_MSC_BOT_Process_3: (+1)
   \   0000007A   0xF89A 0x1005      LDRB     R1,[R10, #+5]
   \   0000007E   0x0020             MOVS     R0,R4
   \   00000080   0x.... 0x....      BL       USBH_LL_GetURBState
   \   00000084   0x4681             MOV      R9,R0
    198              
    199              if(URB_Status == USBH_URB_DONE)
   \   00000086   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   0000008A   0xF1B9 0x0F01      CMP      R9,#+1
   \   0000008E   0xD113             BNE.N    ??USBH_MSC_BOT_Process_13
    200              { 
    201                if ( MSC_Handle->hbot.cbw.field.DataTransferLength != 0 )
   \   00000090   0xF8DA 0x005C      LDR      R0,[R10, #+92]
   \   00000094   0x2800             CMP      R0,#+0
   \   00000096   0xD00B             BEQ.N    ??USBH_MSC_BOT_Process_14
    202                {
    203                  /* If there is Data Transfer Stage */
    204                  if (((MSC_Handle->hbot.cbw.field.Flags) & USB_REQ_DIR_MASK) == USB_D2H)
   \   00000098   0xF89A 0x0060      LDRB     R0,[R10, #+96]
   \   0000009C   0x0600             LSLS     R0,R0,#+24
   \   0000009E   0xD503             BPL.N    ??USBH_MSC_BOT_Process_15
    205                  {
    206                    /* Data Direction is IN */
    207                    MSC_Handle->hbot.state = BOT_DATA_IN;
   \   000000A0   0x2003             MOVS     R0,#+3
   \   000000A2   0xF88A 0x0050      STRB     R0,[R10, #+80]
   \   000000A6   0xE018             B.N      ??USBH_MSC_BOT_Process_16
    208                  }
    209                  else
    210                  {
    211                    /* Data Direction is OUT */
    212                    MSC_Handle->hbot.state = BOT_DATA_OUT;
   \                     ??USBH_MSC_BOT_Process_15: (+1)
   \   000000A8   0x2005             MOVS     R0,#+5
   \   000000AA   0xF88A 0x0050      STRB     R0,[R10, #+80]
   \   000000AE   0xE014             B.N      ??USBH_MSC_BOT_Process_16
    213                  } 
    214                }
    215                
    216                else
    217                {/* If there is NO Data Transfer Stage */
    218                  MSC_Handle->hbot.state = BOT_RECEIVE_CSW;
   \                     ??USBH_MSC_BOT_Process_14: (+1)
   \   000000B0   0x2007             MOVS     R0,#+7
   \   000000B2   0xF88A 0x0050      STRB     R0,[R10, #+80]
   \   000000B6   0xE010             B.N      ??USBH_MSC_BOT_Process_16
    219                }
    220          #if (USBH_USE_OS == 1)
    221              osMessagePut ( phost->os_event, USBH_URB_EVENT, 0);
    222          #endif   
    223              
    224              }   
    225              else if(URB_Status == USBH_URB_NOTREADY)
   \                     ??USBH_MSC_BOT_Process_13: (+1)
   \   000000B8   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   000000BC   0xF1B9 0x0F02      CMP      R9,#+2
   \   000000C0   0xD103             BNE.N    ??USBH_MSC_BOT_Process_17
    226              {
    227                /* Re-send CBW */
    228                MSC_Handle->hbot.state = BOT_SEND_CBW;
   \   000000C2   0x2001             MOVS     R0,#+1
   \   000000C4   0xF88A 0x0050      STRB     R0,[R10, #+80]
   \   000000C8   0xE007             B.N      ??USBH_MSC_BOT_Process_16
    229          #if (USBH_USE_OS == 1)
    230              osMessagePut ( phost->os_event, USBH_URB_EVENT, 0);
    231          #endif       
    232              }     
    233              else if(URB_Status == USBH_URB_STALL)
   \                     ??USBH_MSC_BOT_Process_17: (+1)
   \   000000CA   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   000000CE   0xF1B9 0x0F05      CMP      R9,#+5
   \   000000D2   0xD102             BNE.N    ??USBH_MSC_BOT_Process_16
    234              {
    235                MSC_Handle->hbot.state  = BOT_ERROR_OUT;
   \   000000D4   0x200A             MOVS     R0,#+10
   \   000000D6   0xF88A 0x0050      STRB     R0,[R10, #+80]
    236          #if (USBH_USE_OS == 1)
    237              osMessagePut ( phost->os_event, USBH_URB_EVENT, 0);
    238          #endif       
    239              }
    240              break;
   \                     ??USBH_MSC_BOT_Process_16: (+1)
   \   000000DA   0xE120             B.N      ??USBH_MSC_BOT_Process_12
    241              
    242            case BOT_DATA_IN:   
    243              /* Send first packet */        
    244              USBH_BulkReceiveData (phost,
    245                                    MSC_Handle->hbot.pbuf, 
    246                                    MSC_Handle->InEpSize , 
    247                                    MSC_Handle->InPipe);
   \                     ??USBH_MSC_BOT_Process_2: (+1)
   \   000000DC   0xF89A 0x3004      LDRB     R3,[R10, #+4]
   \   000000E0   0xF8BA 0x200A      LDRH     R2,[R10, #+10]
   \   000000E4   0xF8DA 0x108C      LDR      R1,[R10, #+140]
   \   000000E8   0x0020             MOVS     R0,R4
   \   000000EA   0x.... 0x....      BL       USBH_BulkReceiveData
    248              
    249              MSC_Handle->hbot.state  = BOT_DATA_IN_WAIT;
   \   000000EE   0x2004             MOVS     R0,#+4
   \   000000F0   0xF88A 0x0050      STRB     R0,[R10, #+80]
    250              
    251              break;   
   \   000000F4   0xE113             B.N      ??USBH_MSC_BOT_Process_12
    252              
    253            case BOT_DATA_IN_WAIT:  
    254              
    255              URB_Status = USBH_LL_GetURBState(phost, MSC_Handle->InPipe); 
   \                     ??USBH_MSC_BOT_Process_5: (+1)
   \   000000F6   0xF89A 0x1004      LDRB     R1,[R10, #+4]
   \   000000FA   0x0020             MOVS     R0,R4
   \   000000FC   0x.... 0x....      BL       USBH_LL_GetURBState
   \   00000100   0x4681             MOV      R9,R0
    256              
    257              if(URB_Status == USBH_URB_DONE) 
   \   00000102   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   00000106   0xF1B9 0x0F01      CMP      R9,#+1
   \   0000010A   0xD129             BNE.N    ??USBH_MSC_BOT_Process_18
    258              {
    259                /* Adjust Data pointer and data length */
    260                if(MSC_Handle->hbot.cbw.field.DataTransferLength > MSC_Handle->InEpSize)
   \   0000010C   0xF8BA 0x000A      LDRH     R0,[R10, #+10]
   \   00000110   0xF8DA 0x105C      LDR      R1,[R10, #+92]
   \   00000114   0x4288             CMP      R0,R1
   \   00000116   0xD20E             BCS.N    ??USBH_MSC_BOT_Process_19
    261                {
    262                    MSC_Handle->hbot.pbuf += MSC_Handle->InEpSize;
   \   00000118   0xF8DA 0x008C      LDR      R0,[R10, #+140]
   \   0000011C   0xF8BA 0x100A      LDRH     R1,[R10, #+10]
   \   00000120   0x1808             ADDS     R0,R1,R0
   \   00000122   0xF8CA 0x008C      STR      R0,[R10, #+140]
    263                    MSC_Handle->hbot.cbw.field.DataTransferLength -= MSC_Handle->InEpSize;  
   \   00000126   0xF8DA 0x005C      LDR      R0,[R10, #+92]
   \   0000012A   0xF8BA 0x100A      LDRH     R1,[R10, #+10]
   \   0000012E   0x1A40             SUBS     R0,R0,R1
   \   00000130   0xF8CA 0x005C      STR      R0,[R10, #+92]
   \   00000134   0xE002             B.N      ??USBH_MSC_BOT_Process_20
    264                }
    265                else
    266                {
    267                  MSC_Handle->hbot.cbw.field.DataTransferLength = 0;
   \                     ??USBH_MSC_BOT_Process_19: (+1)
   \   00000136   0x2000             MOVS     R0,#+0
   \   00000138   0xF8CA 0x005C      STR      R0,[R10, #+92]
    268                }
    269                  
    270                /* More Data To be Received */
    271                if(MSC_Handle->hbot.cbw.field.DataTransferLength > 0)
   \                     ??USBH_MSC_BOT_Process_20: (+1)
   \   0000013C   0xF8DA 0x005C      LDR      R0,[R10, #+92]
   \   00000140   0x2800             CMP      R0,#+0
   \   00000142   0xD009             BEQ.N    ??USBH_MSC_BOT_Process_21
    272                {
    273                  /* Send next packet */        
    274                  USBH_BulkReceiveData (phost,
    275                                        MSC_Handle->hbot.pbuf, 
    276                                        MSC_Handle->InEpSize , 
    277                                        MSC_Handle->InPipe);
   \   00000144   0xF89A 0x3004      LDRB     R3,[R10, #+4]
   \   00000148   0xF8BA 0x200A      LDRH     R2,[R10, #+10]
   \   0000014C   0xF8DA 0x108C      LDR      R1,[R10, #+140]
   \   00000150   0x0020             MOVS     R0,R4
   \   00000152   0x.... 0x....      BL       USBH_BulkReceiveData
   \   00000156   0xE00B             B.N      ??USBH_MSC_BOT_Process_22
    278                  
    279                }
    280                else
    281                {
    282                  /* If value was 0, and successful transfer, then change the state */
    283                  MSC_Handle->hbot.state  = BOT_RECEIVE_CSW;
   \                     ??USBH_MSC_BOT_Process_21: (+1)
   \   00000158   0x2007             MOVS     R0,#+7
   \   0000015A   0xF88A 0x0050      STRB     R0,[R10, #+80]
   \   0000015E   0xE007             B.N      ??USBH_MSC_BOT_Process_22
    284          #if (USBH_USE_OS == 1)
    285                  osMessagePut ( phost->os_event, USBH_URB_EVENT, 0);
    286          #endif 
    287                }
    288              }
    289              else if(URB_Status == USBH_URB_STALL)
   \                     ??USBH_MSC_BOT_Process_18: (+1)
   \   00000160   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   00000164   0xF1B9 0x0F05      CMP      R9,#+5
   \   00000168   0xD102             BNE.N    ??USBH_MSC_BOT_Process_22
    290              {
    291                /* This is Data IN Stage STALL Condition */
    292                MSC_Handle->hbot.state  = BOT_ERROR_IN;
   \   0000016A   0x2009             MOVS     R0,#+9
   \   0000016C   0xF88A 0x0050      STRB     R0,[R10, #+80]
    293                
    294                /* Refer to USB Mass-Storage Class : BOT (www.usb.org) 
    295                6.7.2 Host expects to receive data from the device
    296                3. On a STALL condition receiving data, then:
    297                The host shall accept the data received.
    298                The host shall clear the Bulk-In pipe.
    299                4. The host shall attempt to receive a CSW.*/
    300                
    301          #if (USBH_USE_OS == 1)
    302              osMessagePut ( phost->os_event, USBH_URB_EVENT, 0);
    303          #endif       
    304              }     
    305              break;  
   \                     ??USBH_MSC_BOT_Process_22: (+1)
   \   00000170   0xE0D5             B.N      ??USBH_MSC_BOT_Process_12
    306              
    307            case BOT_DATA_OUT:
    308              
    309              USBH_BulkSendData (phost,
    310                                 MSC_Handle->hbot.pbuf, 
    311                                 MSC_Handle->OutEpSize , 
    312                                 MSC_Handle->OutPipe,
    313                                 1);
   \                     ??USBH_MSC_BOT_Process_4: (+1)
   \   00000172   0x2001             MOVS     R0,#+1
   \   00000174   0x9000             STR      R0,[SP, #+0]
   \   00000176   0xF89A 0x3005      LDRB     R3,[R10, #+5]
   \   0000017A   0xF8BA 0x2008      LDRH     R2,[R10, #+8]
   \   0000017E   0xF8DA 0x108C      LDR      R1,[R10, #+140]
   \   00000182   0x0020             MOVS     R0,R4
   \   00000184   0x.... 0x....      BL       USBH_BulkSendData
    314              
    315              
    316              MSC_Handle->hbot.state  = BOT_DATA_OUT_WAIT;
   \   00000188   0x2006             MOVS     R0,#+6
   \   0000018A   0xF88A 0x0050      STRB     R0,[R10, #+80]
    317              break;
   \   0000018E   0xE0C6             B.N      ??USBH_MSC_BOT_Process_12
    318              
    319            case BOT_DATA_OUT_WAIT:
    320              URB_Status = USBH_LL_GetURBState(phost, MSC_Handle->OutPipe);     
   \                     ??USBH_MSC_BOT_Process_7: (+1)
   \   00000190   0xF89A 0x1005      LDRB     R1,[R10, #+5]
   \   00000194   0x0020             MOVS     R0,R4
   \   00000196   0x.... 0x....      BL       USBH_LL_GetURBState
   \   0000019A   0x4681             MOV      R9,R0
    321              
    322              if(URB_Status == USBH_URB_DONE)
   \   0000019C   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   000001A0   0xF1B9 0x0F01      CMP      R9,#+1
   \   000001A4   0xD12B             BNE.N    ??USBH_MSC_BOT_Process_23
    323              {
    324                /* Adjust Data pointer and data length */
    325                if(MSC_Handle->hbot.cbw.field.DataTransferLength > MSC_Handle->OutEpSize)
   \   000001A6   0xF8BA 0x0008      LDRH     R0,[R10, #+8]
   \   000001AA   0xF8DA 0x105C      LDR      R1,[R10, #+92]
   \   000001AE   0x4288             CMP      R0,R1
   \   000001B0   0xD20E             BCS.N    ??USBH_MSC_BOT_Process_24
    326                {
    327                    MSC_Handle->hbot.pbuf += MSC_Handle->OutEpSize;
   \   000001B2   0xF8DA 0x008C      LDR      R0,[R10, #+140]
   \   000001B6   0xF8BA 0x1008      LDRH     R1,[R10, #+8]
   \   000001BA   0x1808             ADDS     R0,R1,R0
   \   000001BC   0xF8CA 0x008C      STR      R0,[R10, #+140]
    328                    MSC_Handle->hbot.cbw.field.DataTransferLength -= MSC_Handle->OutEpSize; 
   \   000001C0   0xF8DA 0x005C      LDR      R0,[R10, #+92]
   \   000001C4   0xF8BA 0x1008      LDRH     R1,[R10, #+8]
   \   000001C8   0x1A40             SUBS     R0,R0,R1
   \   000001CA   0xF8CA 0x005C      STR      R0,[R10, #+92]
   \   000001CE   0xE002             B.N      ??USBH_MSC_BOT_Process_25
    329                }
    330                else
    331                {
    332                  MSC_Handle->hbot.cbw.field.DataTransferLength = 0;
   \                     ??USBH_MSC_BOT_Process_24: (+1)
   \   000001D0   0x2000             MOVS     R0,#+0
   \   000001D2   0xF8CA 0x005C      STR      R0,[R10, #+92]
    333                } 
    334                
    335                /* More Data To be Sent */
    336                if(MSC_Handle->hbot.cbw.field.DataTransferLength > 0)
   \                     ??USBH_MSC_BOT_Process_25: (+1)
   \   000001D6   0xF8DA 0x005C      LDR      R0,[R10, #+92]
   \   000001DA   0x2800             CMP      R0,#+0
   \   000001DC   0xD00B             BEQ.N    ??USBH_MSC_BOT_Process_26
    337                {
    338                  USBH_BulkSendData (phost,
    339                                     MSC_Handle->hbot.pbuf, 
    340                                     MSC_Handle->OutEpSize , 
    341                                     MSC_Handle->OutPipe,
    342                                     1);
   \   000001DE   0x2001             MOVS     R0,#+1
   \   000001E0   0x9000             STR      R0,[SP, #+0]
   \   000001E2   0xF89A 0x3005      LDRB     R3,[R10, #+5]
   \   000001E6   0xF8BA 0x2008      LDRH     R2,[R10, #+8]
   \   000001EA   0xF8DA 0x108C      LDR      R1,[R10, #+140]
   \   000001EE   0x0020             MOVS     R0,R4
   \   000001F0   0x.... 0x....      BL       USBH_BulkSendData
   \   000001F4   0xE014             B.N      ??USBH_MSC_BOT_Process_27
    343                }
    344                else
    345                {
    346                  /* If value was 0, and successful transfer, then change the state */
    347                  MSC_Handle->hbot.state  = BOT_RECEIVE_CSW;
   \                     ??USBH_MSC_BOT_Process_26: (+1)
   \   000001F6   0x2007             MOVS     R0,#+7
   \   000001F8   0xF88A 0x0050      STRB     R0,[R10, #+80]
   \   000001FC   0xE010             B.N      ??USBH_MSC_BOT_Process_27
    348                }  
    349          #if (USBH_USE_OS == 1)
    350              osMessagePut ( phost->os_event, USBH_URB_EVENT, 0);
    351          #endif       
    352              }
    353              
    354              else if(URB_Status == USBH_URB_NOTREADY)
   \                     ??USBH_MSC_BOT_Process_23: (+1)
   \   000001FE   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   00000202   0xF1B9 0x0F02      CMP      R9,#+2
   \   00000206   0xD103             BNE.N    ??USBH_MSC_BOT_Process_28
    355              {
    356                /* Resend same data */      
    357                MSC_Handle->hbot.state  = BOT_DATA_OUT;
   \   00000208   0x2005             MOVS     R0,#+5
   \   0000020A   0xF88A 0x0050      STRB     R0,[R10, #+80]
   \   0000020E   0xE007             B.N      ??USBH_MSC_BOT_Process_27
    358          #if (USBH_USE_OS == 1)
    359              osMessagePut ( phost->os_event, USBH_URB_EVENT, 0);
    360          #endif       
    361              }
    362              
    363              else if(URB_Status == USBH_URB_STALL)
   \                     ??USBH_MSC_BOT_Process_28: (+1)
   \   00000210   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   00000214   0xF1B9 0x0F05      CMP      R9,#+5
   \   00000218   0xD102             BNE.N    ??USBH_MSC_BOT_Process_27
    364              {
    365                MSC_Handle->hbot.state  = BOT_ERROR_OUT;
   \   0000021A   0x200A             MOVS     R0,#+10
   \   0000021C   0xF88A 0x0050      STRB     R0,[R10, #+80]
    366                
    367                /* Refer to USB Mass-Storage Class : BOT (www.usb.org) 
    368                6.7.3 Ho - Host expects to send data to the device
    369                3. On a STALL condition sending data, then:
    370                " The host shall clear the Bulk-Out pipe.
    371                4. The host shall attempt to receive a CSW.
    372                */      
    373          #if (USBH_USE_OS == 1)
    374                osMessagePut ( phost->os_event, USBH_URB_EVENT, 0);
    375          #endif       
    376              }
    377              break;
   \                     ??USBH_MSC_BOT_Process_27: (+1)
   \   00000220   0xE07D             B.N      ??USBH_MSC_BOT_Process_12
    378              
    379            case BOT_RECEIVE_CSW:
    380              
    381              USBH_BulkReceiveData (phost,
    382                                    MSC_Handle->hbot.csw.data, 
    383                                    BOT_CSW_LENGTH , 
    384                                    MSC_Handle->InPipe);
   \                     ??USBH_MSC_BOT_Process_6: (+1)
   \   00000222   0xF89A 0x3004      LDRB     R3,[R10, #+4]
   \   00000226   0x220D             MOVS     R2,#+13
   \   00000228   0xF11A 0x0178      ADDS     R1,R10,#+120
   \   0000022C   0x0020             MOVS     R0,R4
   \   0000022E   0x.... 0x....      BL       USBH_BulkReceiveData
    385              
    386              MSC_Handle->hbot.state  = BOT_RECEIVE_CSW_WAIT;
   \   00000232   0x2008             MOVS     R0,#+8
   \   00000234   0xF88A 0x0050      STRB     R0,[R10, #+80]
    387              break;
   \   00000238   0xE071             B.N      ??USBH_MSC_BOT_Process_12
    388              
    389            case BOT_RECEIVE_CSW_WAIT:
    390              
    391              URB_Status = USBH_LL_GetURBState(phost, MSC_Handle->InPipe); 
   \                     ??USBH_MSC_BOT_Process_9: (+1)
   \   0000023A   0xF89A 0x1004      LDRB     R1,[R10, #+4]
   \   0000023E   0x0020             MOVS     R0,R4
   \   00000240   0x.... 0x....      BL       USBH_LL_GetURBState
   \   00000244   0x4681             MOV      R9,R0
    392              
    393              /* Decode CSW */
    394              if(URB_Status == USBH_URB_DONE)
   \   00000246   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   0000024A   0xF1B9 0x0F01      CMP      R9,#+1
   \   0000024E   0xD114             BNE.N    ??USBH_MSC_BOT_Process_29
    395              {
    396                MSC_Handle->hbot.state = BOT_SEND_CBW;    
   \   00000250   0x2001             MOVS     R0,#+1
   \   00000252   0xF88A 0x0050      STRB     R0,[R10, #+80]
    397                MSC_Handle->hbot.cmd_state = BOT_CMD_SEND;        
   \   00000256   0x2001             MOVS     R0,#+1
   \   00000258   0xF88A 0x0052      STRB     R0,[R10, #+82]
    398                CSW_Status = USBH_MSC_DecodeCSW(phost);
   \   0000025C   0x0020             MOVS     R0,R4
   \   0000025E   0x.... 0x....      BL       USBH_MSC_DecodeCSW
   \   00000262   0x4680             MOV      R8,R0
    399                
    400                if(CSW_Status == BOT_CSW_CMD_PASSED)
   \   00000264   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000268   0xF1B8 0x0F00      CMP      R8,#+0
   \   0000026C   0xD102             BNE.N    ??USBH_MSC_BOT_Process_30
    401                {
    402                  status = USBH_OK;
   \   0000026E   0x2000             MOVS     R0,#+0
   \   00000270   0x0006             MOVS     R6,R0
   \   00000272   0xE00A             B.N      ??USBH_MSC_BOT_Process_31
    403                }
    404                else
    405                {
    406                  status = USBH_FAIL;
   \                     ??USBH_MSC_BOT_Process_30: (+1)
   \   00000274   0x2002             MOVS     R0,#+2
   \   00000276   0x0006             MOVS     R6,R0
   \   00000278   0xE007             B.N      ??USBH_MSC_BOT_Process_31
    407                }
    408          #if (USBH_USE_OS == 1)
    409                osMessagePut ( phost->os_event, USBH_URB_EVENT, 0);
    410          #endif       
    411              }
    412              else if(URB_Status == USBH_URB_STALL)     
   \                     ??USBH_MSC_BOT_Process_29: (+1)
   \   0000027A   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   0000027E   0xF1B9 0x0F05      CMP      R9,#+5
   \   00000282   0xD102             BNE.N    ??USBH_MSC_BOT_Process_31
    413              {
    414                MSC_Handle->hbot.state  = BOT_ERROR_IN;
   \   00000284   0x2009             MOVS     R0,#+9
   \   00000286   0xF88A 0x0050      STRB     R0,[R10, #+80]
    415          #if (USBH_USE_OS == 1)
    416                osMessagePut ( phost->os_event, USBH_URB_EVENT, 0);
    417          #endif       
    418              }
    419              break;
   \                     ??USBH_MSC_BOT_Process_31: (+1)
   \   0000028A   0xE048             B.N      ??USBH_MSC_BOT_Process_12
    420              
    421            case BOT_ERROR_IN: 
    422              error = USBH_MSC_BOT_Abort(phost, lun, BOT_DIR_IN);
   \                     ??USBH_MSC_BOT_Process_8: (+1)
   \   0000028C   0x2200             MOVS     R2,#+0
   \   0000028E   0x0029             MOVS     R1,R5
   \   00000290   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000292   0x0020             MOVS     R0,R4
   \   00000294   0x.... 0x....      BL       USBH_MSC_BOT_Abort
   \   00000298   0x0007             MOVS     R7,R0
    423              
    424              if (error == USBH_OK)
   \   0000029A   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000029C   0x2F00             CMP      R7,#+0
   \   0000029E   0xD103             BNE.N    ??USBH_MSC_BOT_Process_32
    425              {
    426                MSC_Handle->hbot.state = BOT_RECEIVE_CSW;
   \   000002A0   0x2007             MOVS     R0,#+7
   \   000002A2   0xF88A 0x0050      STRB     R0,[R10, #+80]
   \   000002A6   0xE005             B.N      ??USBH_MSC_BOT_Process_33
    427              }
    428              else if (error == USBH_UNRECOVERED_ERROR)
   \                     ??USBH_MSC_BOT_Process_32: (+1)
   \   000002A8   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000002AA   0x2F04             CMP      R7,#+4
   \   000002AC   0xD102             BNE.N    ??USBH_MSC_BOT_Process_33
    429              {
    430                /* This means that there is a STALL Error limit, Do Reset Recovery */
    431                MSC_Handle->hbot.state = BOT_UNRECOVERED_ERROR;
   \   000002AE   0x200B             MOVS     R0,#+11
   \   000002B0   0xF88A 0x0050      STRB     R0,[R10, #+80]
    432              }
    433              break;
   \                     ??USBH_MSC_BOT_Process_33: (+1)
   \   000002B4   0xE033             B.N      ??USBH_MSC_BOT_Process_12
    434              
    435            case BOT_ERROR_OUT: 
    436              error = USBH_MSC_BOT_Abort(phost, lun, BOT_DIR_OUT);
   \                     ??USBH_MSC_BOT_Process_11: (+1)
   \   000002B6   0x2201             MOVS     R2,#+1
   \   000002B8   0x0029             MOVS     R1,R5
   \   000002BA   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000002BC   0x0020             MOVS     R0,R4
   \   000002BE   0x.... 0x....      BL       USBH_MSC_BOT_Abort
   \   000002C2   0x0007             MOVS     R7,R0
    437              
    438              if ( error == USBH_OK)
   \   000002C4   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000002C6   0x2F00             CMP      R7,#+0
   \   000002C8   0xD117             BNE.N    ??USBH_MSC_BOT_Process_34
    439              { 
    440                
    441                toggle = USBH_LL_GetToggle(phost, MSC_Handle->OutPipe); 
   \   000002CA   0xF89A 0x1005      LDRB     R1,[R10, #+5]
   \   000002CE   0x0020             MOVS     R0,R4
   \   000002D0   0x.... 0x....      BL       USBH_LL_GetToggle
   \   000002D4   0x4683             MOV      R11,R0
    442                USBH_LL_SetToggle(phost, MSC_Handle->OutPipe, 1- toggle);   
   \   000002D6   0xF1DB 0x0201      RSBS     R2,R11,#+1
   \   000002DA   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   000002DC   0xF89A 0x1005      LDRB     R1,[R10, #+5]
   \   000002E0   0x0020             MOVS     R0,R4
   \   000002E2   0x.... 0x....      BL       USBH_LL_SetToggle
    443                USBH_LL_SetToggle(phost, MSC_Handle->InPipe, 0);  
   \   000002E6   0x2200             MOVS     R2,#+0
   \   000002E8   0xF89A 0x1004      LDRB     R1,[R10, #+4]
   \   000002EC   0x0020             MOVS     R0,R4
   \   000002EE   0x.... 0x....      BL       USBH_LL_SetToggle
    444                MSC_Handle->hbot.state = BOT_ERROR_IN;        
   \   000002F2   0x2009             MOVS     R0,#+9
   \   000002F4   0xF88A 0x0050      STRB     R0,[R10, #+80]
   \   000002F8   0xE005             B.N      ??USBH_MSC_BOT_Process_35
    445              }
    446              else if (error == USBH_UNRECOVERED_ERROR)
   \                     ??USBH_MSC_BOT_Process_34: (+1)
   \   000002FA   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000002FC   0x2F04             CMP      R7,#+4
   \   000002FE   0xD102             BNE.N    ??USBH_MSC_BOT_Process_35
    447              {
    448                MSC_Handle->hbot.state = BOT_UNRECOVERED_ERROR;
   \   00000300   0x200B             MOVS     R0,#+11
   \   00000302   0xF88A 0x0050      STRB     R0,[R10, #+80]
    449              }
    450              break;
   \                     ??USBH_MSC_BOT_Process_35: (+1)
   \   00000306   0xE00A             B.N      ??USBH_MSC_BOT_Process_12
    451              
    452              
    453            case BOT_UNRECOVERED_ERROR: 
    454              status = USBH_MSC_BOT_REQ_Reset(phost);
   \                     ??USBH_MSC_BOT_Process_10: (+1)
   \   00000308   0x0020             MOVS     R0,R4
   \   0000030A   0x.... 0x....      BL       USBH_MSC_BOT_REQ_Reset
   \   0000030E   0x0006             MOVS     R6,R0
    455              if ( status == USBH_OK)
   \   00000310   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000312   0x2E00             CMP      R6,#+0
   \   00000314   0xD102             BNE.N    ??USBH_MSC_BOT_Process_36
    456              {
    457                MSC_Handle->hbot.state = BOT_SEND_CBW; 
   \   00000316   0x2001             MOVS     R0,#+1
   \   00000318   0xF88A 0x0050      STRB     R0,[R10, #+80]
    458              }
    459              break;
   \                     ??USBH_MSC_BOT_Process_36: (+1)
   \   0000031C   0xE7FF             B.N      ??USBH_MSC_BOT_Process_12
    460              
    461            default:      
    462              break;
    463            }
    464            return status;
   \                     ??USBH_MSC_BOT_Process_1: (+1)
   \                     ??USBH_MSC_BOT_Process_12: (+1)
   \   0000031E   0x0030             MOVS     R0,R6
   \   00000320   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000322   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
    465          }
    466          
    467          /**
    468            * @brief  USBH_MSC_BOT_Abort 
    469            *         The function handle the BOT Abort process.
    470            * @param  phost: Host handle
    471            * @param  lun: Logical Unit Number
    472            * @param  dir: direction (0: out / 1 : in)
    473            * @retval USBH Status
    474            */

   \                                 In section .text, align 2, keep-with-next
    475          static USBH_StatusTypeDef USBH_MSC_BOT_Abort(USBH_HandleTypeDef *phost, uint8_t lun, uint8_t dir)
    476          {
   \                     USBH_MSC_BOT_Abort: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
    477            USBH_StatusTypeDef status = USBH_FAIL;
   \   0000000A   0x2702             MOVS     R7,#+2
    478            MSC_HandleTypeDef *MSC_Handle =  (MSC_HandleTypeDef *) phost->pActiveClass->pData;
   \   0000000C   0xF8D4 0x0264      LDR      R0,[R4, #+612]
   \   00000010   0xF8D0 0x801C      LDR      R8,[R0, #+28]
    479            
    480            switch (dir)
   \   00000014   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000016   0x2E00             CMP      R6,#+0
   \   00000018   0xD002             BEQ.N    ??USBH_MSC_BOT_Abort_0
   \   0000001A   0x2E01             CMP      R6,#+1
   \   0000001C   0xD007             BEQ.N    ??USBH_MSC_BOT_Abort_1
   \   0000001E   0xE00D             B.N      ??USBH_MSC_BOT_Abort_2
    481            {
    482            case BOT_DIR_IN :
    483              /* send ClrFeture on Bulk IN endpoint */
    484              status = USBH_ClrFeature(phost, MSC_Handle->InEp);
   \                     ??USBH_MSC_BOT_Abort_0: (+1)
   \   00000020   0xF898 0x1007      LDRB     R1,[R8, #+7]
   \   00000024   0x0020             MOVS     R0,R4
   \   00000026   0x.... 0x....      BL       USBH_ClrFeature
   \   0000002A   0x0007             MOVS     R7,R0
    485              
    486              break;
   \   0000002C   0xE006             B.N      ??USBH_MSC_BOT_Abort_3
    487              
    488            case BOT_DIR_OUT :
    489              /*send ClrFeature on Bulk OUT endpoint */
    490              status = USBH_ClrFeature(phost, MSC_Handle->OutEp);
   \                     ??USBH_MSC_BOT_Abort_1: (+1)
   \   0000002E   0xF898 0x1006      LDRB     R1,[R8, #+6]
   \   00000032   0x0020             MOVS     R0,R4
   \   00000034   0x.... 0x....      BL       USBH_ClrFeature
   \   00000038   0x0007             MOVS     R7,R0
    491              break;
   \   0000003A   0xE7FF             B.N      ??USBH_MSC_BOT_Abort_3
    492              
    493            default:
    494              break;
    495            }
    496            return status;
   \                     ??USBH_MSC_BOT_Abort_2: (+1)
   \                     ??USBH_MSC_BOT_Abort_3: (+1)
   \   0000003C   0x0038             MOVS     R0,R7
   \   0000003E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000040   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    497          }
    498          
    499          /**
    500            * @brief  USBH_MSC_BOT_DecodeCSW
    501            *         This function decodes the CSW received by the device and updates the
    502            *         same to upper layer.
    503            * @param  phost: Host handle
    504            * @retval USBH Status
    505            * @notes
    506            *     Refer to USB Mass-Storage Class : BOT (www.usb.org)
    507            *    6.3.1 Valid CSW Conditions :
    508            *     The host shall consider the CSW valid when:
    509            *     1. dCSWSignature is equal to 53425355h
    510            *     2. the CSW is 13 (Dh) bytes in length,
    511            *     3. dCSWTag matches the dCBWTag from the corresponding CBW.
    512            */
    513          

   \                                 In section .text, align 2, keep-with-next
    514          static BOT_CSWStatusTypeDef USBH_MSC_DecodeCSW(USBH_HandleTypeDef *phost)
    515          {
   \                     USBH_MSC_DecodeCSW: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
    516            MSC_HandleTypeDef *MSC_Handle =  (MSC_HandleTypeDef *) phost->pActiveClass->pData;
   \   00000004   0xF8D4 0x0264      LDR      R0,[R4, #+612]
   \   00000008   0x69C5             LDR      R5,[R0, #+28]
    517            BOT_CSWStatusTypeDef status = BOT_CSW_CMD_FAILED;
   \   0000000A   0x2601             MOVS     R6,#+1
    518            
    519              /*Checking if the transfer length is different than 13*/    
    520              if(USBH_LL_GetLastXferSize(phost, MSC_Handle->InPipe) != BOT_CSW_LENGTH)
   \   0000000C   0x7929             LDRB     R1,[R5, #+4]
   \   0000000E   0x0020             MOVS     R0,R4
   \   00000010   0x.... 0x....      BL       USBH_LL_GetLastXferSize
   \   00000014   0x280D             CMP      R0,#+13
   \   00000016   0xD002             BEQ.N    ??USBH_MSC_DecodeCSW_0
    521              {
    522                /*(4) Hi > Dn (Host expects to receive data from the device,
    523                Device intends to transfer no data)
    524                (5) Hi > Di (Host expects to receive data from the device,
    525                Device intends to send data to the host)
    526                (9) Ho > Dn (Host expects to send data to the device,
    527                Device intends to transfer no data)
    528                (11) Ho > Do  (Host expects to send data to the device,
    529                Device intends to receive data from the host)*/
    530                
    531                
    532                status = BOT_CSW_PHASE_ERROR;
   \   00000018   0x2002             MOVS     R0,#+2
   \   0000001A   0x0006             MOVS     R6,R0
   \   0000001C   0xE01E             B.N      ??USBH_MSC_DecodeCSW_1
    533              }
    534              else
    535              { /* CSW length is Correct */
    536                
    537                /* Check validity of the CSW Signature and CSWStatus */
    538                if(MSC_Handle->hbot.csw.field.Signature == BOT_CSW_SIGNATURE)
   \                     ??USBH_MSC_DecodeCSW_0: (+1)
   \   0000001E   0x6FA8             LDR      R0,[R5, #+120]
   \   00000020   0x....             LDR.N    R1,??DataTable1_2  ;; 0x53425355
   \   00000022   0x4288             CMP      R0,R1
   \   00000024   0xD118             BNE.N    ??USBH_MSC_DecodeCSW_2
    539                {/* Check Condition 1. dCSWSignature is equal to 53425355h */
    540                  
    541                  if(MSC_Handle->hbot.csw.field.Tag == MSC_Handle->hbot.cbw.field.Tag)
   \   00000026   0x6FE8             LDR      R0,[R5, #+124]
   \   00000028   0x6DA9             LDR      R1,[R5, #+88]
   \   0000002A   0x4288             CMP      R0,R1
   \   0000002C   0xD116             BNE.N    ??USBH_MSC_DecodeCSW_1
    542                  {
    543                    /* Check Condition 3. dCSWTag matches the dCBWTag from the 
    544                    corresponding CBW */
    545          
    546                    if(MSC_Handle->hbot.csw.field.Status == 0) 
   \   0000002E   0xF895 0x0084      LDRB     R0,[R5, #+132]
   \   00000032   0x2800             CMP      R0,#+0
   \   00000034   0xD102             BNE.N    ??USBH_MSC_DecodeCSW_3
    547                    {
    548                      /* Refer to USB Mass-Storage Class : BOT (www.usb.org) 
    549                      
    550                      Hn Host expects no data transfers
    551                      Hi Host expects to receive data from the device
    552                      Ho Host expects to send data to the device
    553                      
    554                      Dn Device intends to transfer no data
    555                      Di Device intends to send data to the host
    556                      Do Device intends to receive data from the host
    557                      
    558                      Section 6.7 
    559                      (1) Hn = Dn (Host expects no data transfers,
    560                      Device intends to transfer no data)
    561                      (6) Hi = Di (Host expects to receive data from the device,
    562                      Device intends to send data to the host)
    563                      (12) Ho = Do (Host expects to send data to the device, 
    564                      Device intends to receive data from the host)
    565                      
    566                      */
    567                      
    568                      status = BOT_CSW_CMD_PASSED;
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0x0006             MOVS     R6,R0
   \   0000003A   0xE00F             B.N      ??USBH_MSC_DecodeCSW_1
    569                    }
    570                    else if(MSC_Handle->hbot.csw.field.Status == 1)
   \                     ??USBH_MSC_DecodeCSW_3: (+1)
   \   0000003C   0xF895 0x0084      LDRB     R0,[R5, #+132]
   \   00000040   0x2801             CMP      R0,#+1
   \   00000042   0xD102             BNE.N    ??USBH_MSC_DecodeCSW_4
    571                    {
    572                      status = BOT_CSW_CMD_FAILED;
   \   00000044   0x2001             MOVS     R0,#+1
   \   00000046   0x0006             MOVS     R6,R0
   \   00000048   0xE008             B.N      ??USBH_MSC_DecodeCSW_1
    573                    }
    574                    
    575                    else if(MSC_Handle->hbot.csw.field.Status == 2)
   \                     ??USBH_MSC_DecodeCSW_4: (+1)
   \   0000004A   0xF895 0x0084      LDRB     R0,[R5, #+132]
   \   0000004E   0x2802             CMP      R0,#+2
   \   00000050   0xD104             BNE.N    ??USBH_MSC_DecodeCSW_1
    576                    { 
    577                      /* Refer to USB Mass-Storage Class : BOT (www.usb.org) 
    578                      Section 6.7 
    579                      (2) Hn < Di ( Host expects no data transfers, 
    580                      Device intends to send data to the host)
    581                      (3) Hn < Do ( Host expects no data transfers, 
    582                      Device intends to receive data from the host)
    583                      (7) Hi < Di ( Host expects to receive data from the device, 
    584                      Device intends to send data to the host)
    585                      (8) Hi <> Do ( Host expects to receive data from the device, 
    586                      Device intends to receive data from the host)
    587                      (10) Ho <> Di (Host expects to send data to the device,
    588                      Di Device intends to send data to the host)
    589                      (13) Ho < Do (Host expects to send data to the device, 
    590                      Device intends to receive data from the host)
    591                      */
    592                      
    593                      status = BOT_CSW_PHASE_ERROR;
   \   00000052   0x2002             MOVS     R0,#+2
   \   00000054   0x0006             MOVS     R6,R0
   \   00000056   0xE001             B.N      ??USBH_MSC_DecodeCSW_1
    594                    }
    595                  } /* CSW Tag Matching is Checked  */
    596                } /* CSW Signature Correct Checking */
    597                else
    598                {
    599                  /* If the CSW Signature is not valid, We sall return the Phase Error to
    600                  Upper Layers for Reset Recovery */
    601                  
    602                  status = BOT_CSW_PHASE_ERROR;
   \                     ??USBH_MSC_DecodeCSW_2: (+1)
   \   00000058   0x2002             MOVS     R0,#+2
   \   0000005A   0x0006             MOVS     R6,R0
    603                }
    604              } /* CSW Length Check*/
    605              
    606            return status;
   \                     ??USBH_MSC_DecodeCSW_1: (+1)
   \   0000005C   0x0030             MOVS     R0,R6
   \   0000005E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000060   0xBD70             POP      {R4-R6,PC}       ;; return
    607          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1:
   \   00000000   0x43425355         DC32     0x43425355

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_1:
   \   00000000   0x20304050         DC32     0x20304050

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_2:
   \   00000000   0x53425355         DC32     0x53425355
    608          
    609          
    610          /**
    611          * @}
    612          */ 
    613          
    614          /**
    615          * @}
    616          */ 
    617          
    618          /**
    619          * @}
    620          */
    621          
    622          /**
    623          * @}
    624          */ 
    625          
    626          /**
    627          * @}
    628          */
    629          
    630          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
    631          
    632          
    633          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   USBH_MSC_BOT_Abort
        24   -> USBH_ClrFeature
       0   USBH_MSC_BOT_Init
      40   USBH_MSC_BOT_Process
        40   -> USBH_BulkReceiveData
        40   -> USBH_BulkSendData
        40   -> USBH_LL_GetToggle
        40   -> USBH_LL_GetURBState
        40   -> USBH_LL_SetToggle
        40   -> USBH_MSC_BOT_Abort
        40   -> USBH_MSC_BOT_REQ_Reset
        40   -> USBH_MSC_DecodeCSW
      16   USBH_MSC_BOT_REQ_GetMaxLUN
        16   -> USBH_CtlReq
       8   USBH_MSC_BOT_REQ_Reset
         8   -> USBH_CtlReq
      16   USBH_MSC_DecodeCSW
        16   -> USBH_LL_GetLastXferSize


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable1
       4  ??DataTable1_1
       4  ??DataTable1_2
      68  USBH_MSC_BOT_Abort
      36  USBH_MSC_BOT_Init
     806  USBH_MSC_BOT_Process
      38  USBH_MSC_BOT_REQ_GetMaxLUN
      36  USBH_MSC_BOT_REQ_Reset
      98  USBH_MSC_DecodeCSW

 
 1 094 bytes in section .text
 
 1 094 bytes of CODE memory

Errors: none
Warnings: 1
