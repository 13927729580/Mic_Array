###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.3.10732/W32 for ARM       15/May/2016  09:59:42
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\sop1hc\Mic\Mic_Array\Mic_Array\Middlewares\ST\STM32_USB_Host_Library\Class\MSC\Src\usbh_msc_bot.c
#    Command line =  
#        D:\sop1hc\Mic\Mic_Array\Mic_Array\Middlewares\ST\STM32_USB_Host_Library\Class\MSC\Src\usbh_msc_bot.c
#        -D USE_HAL_DRIVER -D STM32F746xx -D USE_STM32746G_DISCO -D
#        USE_IOEXPANDER -D USE_USB_FS -lC
#        D:\sop1hc\Mic\Mic_Array\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
#        -lA
#        D:\sop1hc\Mic\Mic_Array\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
#        -o
#        D:\sop1hc\Mic\Mic_Array\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj
#        --no_unroll --debug --endian=little --cpu=Cortex-M7 -e --fpu=VFPv5_sp
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Full.h" -I
#        D:\sop1hc\Mic\Mic_Array\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\Inc\
#        -I
#        D:\sop1hc\Mic\Mic_Array\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\CMSIS\Device\ST\STM32F7xx\Include\
#        -I
#        D:\sop1hc\Mic\Mic_Array\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\STM32F7xx_HAL_Driver\Inc\
#        -I
#        D:\sop1hc\Mic\Mic_Array\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\STM32746G-Discovery\
#        -I
#        D:\sop1hc\Mic\Mic_Array\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\Components\Common\
#        -I
#        D:\sop1hc\Mic\Mic_Array\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Log\
#        -I
#        D:\sop1hc\Mic\Mic_Array\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Fonts\
#        -I
#        D:\sop1hc\Mic\Mic_Array\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\CPU\
#        -I
#        D:\sop1hc\Mic\Mic_Array\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_Device_Library\Core\Inc\
#        -I
#        D:\sop1hc\Mic\Mic_Array\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Core\Inc\
#        -I
#        D:\sop1hc\Mic\Mic_Array\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Class\MSC\Inc\
#        -I
#        D:\sop1hc\Mic\Mic_Array\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\
#        -I
#        D:\sop1hc\Mic\Mic_Array\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\drivers\
#        -I
#        D:\sop1hc\Mic\Mic_Array\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_Audio\Addons\PDM\
#        -I
#        D:\sop1hc\Mic\Mic_Array\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_Device_Library\Class\AUDIO\Inc\
#        -Ohs --use_c++_inline --require_prototypes -I "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.3\arm\CMSIS\Include\" -D
#        ARM_MATH_CM7 --relaxed_fp
#    List file    =  
#        D:\sop1hc\Mic\Mic_Array\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List\usbh_msc_bot.lst
#    Object file  =  
#        D:\sop1hc\Mic\Mic_Array\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj\usbh_msc_bot.o
#
###############################################################################

D:\sop1hc\Mic\Mic_Array\Mic_Array\Middlewares\ST\STM32_USB_Host_Library\Class\MSC\Src\usbh_msc_bot.c
      1          /**
      2            ******************************************************************************
      3            * @file    usbh_msc_bot.c 
      4            * @author  MCD Application Team
      5            * @version V3.2.1
      6            * @date    26-June-2015
      7            * @brief   This file includes the BOT protocol related functions
      8            ******************************************************************************
      9            * @attention
     10            *
     11            * <h2><center>&copy; COPYRIGHT 2015 STMicroelectronics</center></h2>
     12            *
     13            * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
     14            * You may not use this file except in compliance with the License.
     15            * You may obtain a copy of the License at:
     16            *
     17            *        http://www.st.com/software_license_agreement_liberty_v2
     18            *
     19            * Unless required by applicable law or agreed to in writing, software 
     20            * distributed under the License is distributed on an "AS IS" BASIS, 
     21            * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     22            * See the License for the specific language governing permissions and
     23            * limitations under the License.
     24            *
     25            ******************************************************************************
     26            */ 
     27          
     28          /* Includes ------------------------------------------------------------------*/
     29          #include "usbh_msc_bot.h"
     30          #include "usbh_msc.h"
     31          
     32          /** @addtogroup USBH_LIB
     33          * @{
     34          */
     35          
     36          /** @addtogroup USBH_CLASS
     37          * @{
     38          */
     39          
     40          /** @addtogroup USBH_MSC_CLASS
     41          * @{
     42          */
     43          
     44          /** @defgroup USBH_MSC_BOT 
     45          * @brief    This file includes the mass storage related functions
     46          * @{
     47          */ 
     48          
     49          
     50          /** @defgroup USBH_MSC_BOT_Private_TypesDefinitions
     51          * @{
     52          */ 
     53          /**
     54          * @}
     55          */ 
     56          
     57          /** @defgroup USBH_MSC_BOT_Private_Defines
     58          * @{
     59          */ 
     60          /**
     61          * @}
     62          */ 
     63          
     64          /** @defgroup USBH_MSC_BOT_Private_Macros
     65          * @{
     66          */ 
     67          /**
     68          * @}
     69          */ 
     70          
     71          
     72          /** @defgroup USBH_MSC_BOT_Private_Variables
     73          * @{
     74          */ 
     75          
     76          /**
     77          * @}
     78          */ 
     79          
     80          
     81          /** @defgroup USBH_MSC_BOT_Private_FunctionPrototypes
     82          * @{
     83          */ 
     84          static USBH_StatusTypeDef USBH_MSC_BOT_Abort(USBH_HandleTypeDef *phost, uint8_t lun, uint8_t dir);
     85          static BOT_CSWStatusTypeDef USBH_MSC_DecodeCSW(USBH_HandleTypeDef *phost);
     86          /**
     87          * @}
     88          */ 
     89          
     90          
     91          /** @defgroup USBH_MSC_BOT_Exported_Variables
     92          * @{
     93          */ 
     94          /**
     95          * @}
     96          */ 
     97          
     98          
     99          /** @defgroup USBH_MSC_BOT_Private_Functions
    100          * @{
    101          */ 
    102          
    103          /**
    104            * @brief  USBH_MSC_BOT_REQ_Reset 
    105            *         The function the MSC BOT Reset request.
    106            * @param  phost: Host handle
    107            * @retval USBH Status
    108            */

   \                                 In section .text, align 2, keep-with-next
    109          USBH_StatusTypeDef USBH_MSC_BOT_REQ_Reset(USBH_HandleTypeDef *phost)
    110          {
    111            
    112            phost->Control.setup.b.bmRequestType = USB_H2D | USB_REQ_TYPE_CLASS | \
    113                                        USB_REQ_RECIPIENT_INTERFACE;
   \                     USBH_MSC_BOT_REQ_Reset: (+1)
   \   00000000   0x2121             MOVS     R1,#+33
    114            
    115            phost->Control.setup.b.bRequest = USB_REQ_BOT_RESET;
    116            phost->Control.setup.b.wValue.w = 0;
    117            phost->Control.setup.b.wIndex.w = 0;
    118            phost->Control.setup.b.wLength.w = 0;           
    119            
    120            return USBH_CtlReq(phost, 0 , 0 );  
   \   00000002   0x2200             MOVS     R2,#+0
   \   00000004   0x7401             STRB     R1,[R0, #+16]
   \   00000006   0x21FF             MOVS     R1,#+255
   \   00000008   0x7441             STRB     R1,[R0, #+17]
   \   0000000A   0x2100             MOVS     R1,#+0
   \   0000000C   0x8241             STRH     R1,[R0, #+18]
   \   0000000E   0x8281             STRH     R1,[R0, #+20]
   \   00000010   0x82C1             STRH     R1,[R0, #+22]
   \   00000012   0x.... 0x....      B.W      USBH_CtlReq
    121          }
    122          
    123          /**
    124            * @brief  USBH_MSC_BOT_REQ_GetMaxLUN 
    125            *         The function the MSC BOT GetMaxLUN request.
    126            * @param  phost: Host handle
    127            * @param  Maxlun: pointer to Maxlun variable
    128            * @retval USBH Status
    129            */

   \                                 In section .text, align 2, keep-with-next
    130          USBH_StatusTypeDef USBH_MSC_BOT_REQ_GetMaxLUN(USBH_HandleTypeDef *phost, uint8_t *Maxlun)
    131          {
    132            phost->Control.setup.b.bmRequestType = USB_D2H | USB_REQ_TYPE_CLASS | \
    133                                        USB_REQ_RECIPIENT_INTERFACE;
   \                     USBH_MSC_BOT_REQ_GetMaxLUN: (+1)
   \   00000000   0x22A1             MOVS     R2,#+161
   \   00000002   0x7402             STRB     R2,[R0, #+16]
    134            
    135            phost->Control.setup.b.bRequest = USB_REQ_GET_MAX_LUN;
   \   00000004   0x22FE             MOVS     R2,#+254
   \   00000006   0x7442             STRB     R2,[R0, #+17]
    136            phost->Control.setup.b.wValue.w = 0;
   \   00000008   0x2200             MOVS     R2,#+0
   \   0000000A   0x8242             STRH     R2,[R0, #+18]
    137            phost->Control.setup.b.wIndex.w = 0;
   \   0000000C   0x8282             STRH     R2,[R0, #+20]
    138            phost->Control.setup.b.wLength.w = 1;           
   \   0000000E   0x2201             MOVS     R2,#+1
   \   00000010   0x82C2             STRH     R2,[R0, #+22]
    139            
    140            return USBH_CtlReq(phost, Maxlun , 1 ); 
   \   00000012   0x.... 0x....      B.W      USBH_CtlReq
    141          }
    142          
    143          
    144          
    145          /**
    146            * @brief  USBH_MSC_BOT_Init 
    147            *         The function Initializes the BOT protocol.
    148            * @param  phost: Host handle
    149            * @retval USBH Status
    150            */

   \                                 In section .text, align 2, keep-with-next
    151          USBH_StatusTypeDef USBH_MSC_BOT_Init(USBH_HandleTypeDef *phost)
    152          {
    153            
    154            MSC_HandleTypeDef *MSC_Handle =  (MSC_HandleTypeDef *) phost->pActiveClass->pData;
   \                     USBH_MSC_BOT_Init: (+1)
   \   00000000   0xF8D0 0x0264      LDR      R0,[R0, #+612]
    155            
    156            MSC_Handle->hbot.cbw.field.Signature = BOT_CBW_SIGNATURE;
   \   00000004   0x....             LDR.N    R1,??DataTable1  ;; 0x43425355
   \   00000006   0x69C0             LDR      R0,[R0, #+28]
   \   00000008   0x6541             STR      R1,[R0, #+84]
    157            MSC_Handle->hbot.cbw.field.Tag = BOT_CBW_TAG;
   \   0000000A   0x....             LDR.N    R1,??DataTable1_1  ;; 0x20304050
   \   0000000C   0x6581             STR      R1,[R0, #+88]
    158            MSC_Handle->hbot.state = BOT_SEND_CBW;    
   \   0000000E   0x2101             MOVS     R1,#+1
   \   00000010   0xF880 0x1050      STRB     R1,[R0, #+80]
    159            MSC_Handle->hbot.cmd_state = BOT_CMD_SEND;   
   \   00000014   0xF880 0x1052      STRB     R1,[R0, #+82]
    160            
    161            return USBH_OK;
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x4770             BX       LR               ;; return
    162          }
    163          
    164          
    165          
    166          /**
    167            * @brief  USBH_MSC_BOT_Process 
    168            *         The function handle the BOT protocol.
    169            * @param  phost: Host handle
    170            * @param  lun: Logical Unit Number
    171            * @retval USBH Status
    172            */

   \                                 In section .text, align 4, keep-with-next
    173          USBH_StatusTypeDef USBH_MSC_BOT_Process (USBH_HandleTypeDef *phost, uint8_t lun)
    174          {
   \                     USBH_MSC_BOT_Process: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4605             MOV      R5,R0
   \   00000004   0xB082             SUB      SP,SP,#+8
    175            USBH_StatusTypeDef   status = USBH_BUSY;
   \   00000006   0x2401             MOVS     R4,#+1
   \   00000008   0xF8D5 0x0264      LDR      R0,[R5, #+612]
   \   0000000C   0x69C0             LDR      R0,[R0, #+28]
    176            USBH_StatusTypeDef   error  = USBH_BUSY;  
    177            BOT_CSWStatusTypeDef CSW_Status = BOT_CSW_CMD_FAILED;
    178            USBH_URBStateTypeDef URB_Status = USBH_URB_IDLE;
    179            MSC_HandleTypeDef *MSC_Handle =  (MSC_HandleTypeDef *) phost->pActiveClass->pData;
    180            uint8_t toggle = 0;
    181            
    182            switch (MSC_Handle->hbot.state)
   \   0000000E   0x1D06             ADDS     R6,R0,#+4
   \   00000010   0xF896 0x204C      LDRB     R2,[R6, #+76]
   \   00000014   0x1E52             SUBS     R2,R2,#+1
   \   00000016   0x2A0A             CMP      R2,#+10
   \   00000018   0xF200 0x80EF      BHI.W    ??USBH_MSC_BOT_Process_1
   \   0000001C   0xE8DF 0xF002      TBB      [PC, R2]
   \                     ??USBH_MSC_BOT_Process_0:
   \   00000020   0x06 0x11          DC8      0x6,0x11,0x2D,0x36
   \              0x2D 0x36    
   \   00000024   0x54 0x5E          DC8      0x54,0x5E,0x84,0x8D
   \              0x84 0x8D    
   \   00000028   0xB5 0xC0          DC8      0xB5,0xC0,0xDB,0x0
   \              0xDB 0x00    
    183            {
    184            case BOT_SEND_CBW:
    185              MSC_Handle->hbot.cbw.field.LUN = lun;
   \                     ??USBH_MSC_BOT_Process_2: (+1)
   \   0000002C   0xF886 0x105D      STRB     R1,[R6, #+93]
    186              MSC_Handle->hbot.state = BOT_SEND_CBW_WAIT;    
   \   00000030   0x2102             MOVS     R1,#+2
   \   00000032   0xF886 0x104C      STRB     R1,[R6, #+76]
    187              USBH_BulkSendData (phost,
    188                                 MSC_Handle->hbot.cbw.data, 
    189                                 BOT_CBW_LENGTH, 
    190                                 MSC_Handle->OutPipe,
    191                                 1);
   \   00000036   0x221F             MOVS     R2,#+31
   \   00000038   0x9400             STR      R4,[SP, #+0]
   \   0000003A   0x7873             LDRB     R3,[R6, #+1]
   \   0000003C   0xF100 0x0154      ADD      R1,R0,#+84
   \   00000040   0xE060             B.N      ??USBH_MSC_BOT_Process_3
    192              
    193              break;
    194              
    195            case BOT_SEND_CBW_WAIT:
    196              
    197              URB_Status = USBH_LL_GetURBState(phost, MSC_Handle->OutPipe); 
   \                     ??USBH_MSC_BOT_Process_4: (+1)
   \   00000042   0x7871             LDRB     R1,[R6, #+1]
   \   00000044   0x4628             MOV      R0,R5
   \   00000046   0x.... 0x....      BL       USBH_LL_GetURBState
    198              
    199              if(URB_Status == USBH_URB_DONE)
   \   0000004A   0x2801             CMP      R0,#+1
   \   0000004C   0xD10A             BNE.N    ??USBH_MSC_BOT_Process_5
    200              { 
    201                if ( MSC_Handle->hbot.cbw.field.DataTransferLength != 0 )
   \   0000004E   0x6DB0             LDR      R0,[R6, #+88]
   \   00000050   0x2800             CMP      R0,#+0
   \   00000052   0xF000 0x809F      BEQ.W    ??USBH_MSC_BOT_Process_6
    202                {
    203                  /* If there is Data Transfer Stage */
    204                  if (((MSC_Handle->hbot.cbw.field.Flags) & USB_REQ_DIR_MASK) == USB_D2H)
   \   00000056   0xF896 0x005C      LDRB     R0,[R6, #+92]
   \   0000005A   0x0600             LSLS     R0,R0,#+24
   \   0000005C   0xBF54             ITE      PL 
   \   0000005E   0x2005             MOVPL    R0,#+5
   \   00000060   0x2003             MOVMI    R0,#+3
    205                  {
    206                    /* Data Direction is IN */
    207                    MSC_Handle->hbot.state = BOT_DATA_IN;
    208                  }
    209                  else
    210                  {
    211                    /* Data Direction is OUT */
    212                    MSC_Handle->hbot.state = BOT_DATA_OUT;
   \   00000062   0xE0C8             B.N      ??USBH_MSC_BOT_Process_7
    213                  } 
    214                }
    215                
    216                else
    217                {/* If there is NO Data Transfer Stage */
    218                  MSC_Handle->hbot.state = BOT_RECEIVE_CSW;
    219                }
    220          #if (USBH_USE_OS == 1)
    221              osMessagePut ( phost->os_event, USBH_URB_EVENT, 0);
    222          #endif   
    223              
    224              }   
    225              else if(URB_Status == USBH_URB_NOTREADY)
   \                     ??USBH_MSC_BOT_Process_5: (+1)
   \   00000064   0x2802             CMP      R0,#+2
   \   00000066   0xBF08             IT       EQ 
   \   00000068   0xF886 0x404C      STRBEQ   R4,[R6, #+76]
    226              {
    227                /* Re-send CBW */
    228                MSC_Handle->hbot.state = BOT_SEND_CBW;
   \   0000006C   0xF000 0x80C5      BEQ.W    ??USBH_MSC_BOT_Process_1
    229          #if (USBH_USE_OS == 1)
    230              osMessagePut ( phost->os_event, USBH_URB_EVENT, 0);
    231          #endif       
    232              }     
    233              else if(URB_Status == USBH_URB_STALL)
   \   00000070   0x2805             CMP      R0,#+5
   \   00000072   0xF040 0x80C2      BNE.W    ??USBH_MSC_BOT_Process_1
    234              {
    235                MSC_Handle->hbot.state  = BOT_ERROR_OUT;
   \   00000076   0x200A             MOVS     R0,#+10
   \   00000078   0xE0BD             B.N      ??USBH_MSC_BOT_Process_7
    236          #if (USBH_USE_OS == 1)
    237              osMessagePut ( phost->os_event, USBH_URB_EVENT, 0);
    238          #endif       
    239              }
    240              break;
    241              
    242            case BOT_DATA_IN:   
    243              /* Send first packet */        
    244              USBH_BulkReceiveData (phost,
    245                                    MSC_Handle->hbot.pbuf, 
    246                                    MSC_Handle->InEpSize , 
    247                                    MSC_Handle->InPipe);
   \                     ??USBH_MSC_BOT_Process_8: (+1)
   \   0000007A   0x7833             LDRB     R3,[R6, #+0]
   \   0000007C   0x88F2             LDRH     R2,[R6, #+6]
   \   0000007E   0xF8D6 0x1088      LDR      R1,[R6, #+136]
   \   00000082   0x4628             MOV      R0,R5
   \   00000084   0x.... 0x....      BL       USBH_BulkReceiveData
    248              
    249              MSC_Handle->hbot.state  = BOT_DATA_IN_WAIT;
   \   00000088   0x2004             MOVS     R0,#+4
   \   0000008A   0xE0B4             B.N      ??USBH_MSC_BOT_Process_7
    250              
    251              break;   
    252              
    253            case BOT_DATA_IN_WAIT:  
    254              
    255              URB_Status = USBH_LL_GetURBState(phost, MSC_Handle->InPipe); 
   \                     ??USBH_MSC_BOT_Process_9: (+1)
   \   0000008C   0x7831             LDRB     R1,[R6, #+0]
   \   0000008E   0x4628             MOV      R0,R5
   \   00000090   0x.... 0x....      BL       USBH_LL_GetURBState
    256              
    257              if(URB_Status == USBH_URB_DONE) 
   \   00000094   0x2801             CMP      R0,#+1
   \   00000096   0xD112             BNE.N    ??USBH_MSC_BOT_Process_10
    258              {
    259                /* Adjust Data pointer and data length */
    260                if(MSC_Handle->hbot.cbw.field.DataTransferLength > MSC_Handle->InEpSize)
   \   00000098   0x88F2             LDRH     R2,[R6, #+6]
   \   0000009A   0x6DB3             LDR      R3,[R6, #+88]
   \   0000009C   0x429A             CMP      R2,R3
   \   0000009E   0xD237             BCS.N    ??USBH_MSC_BOT_Process_11
    261                {
    262                    MSC_Handle->hbot.pbuf += MSC_Handle->InEpSize;
   \   000000A0   0xF8D6 0x1088      LDR      R1,[R6, #+136]
   \   000000A4   0x1851             ADDS     R1,R2,R1
    263                    MSC_Handle->hbot.cbw.field.DataTransferLength -= MSC_Handle->InEpSize;  
   \   000000A6   0x1A98             SUBS     R0,R3,R2
   \   000000A8   0xF8C6 0x1088      STR      R1,[R6, #+136]
   \   000000AC   0x65B0             STR      R0,[R6, #+88]
    264                }
    265                else
    266                {
    267                  MSC_Handle->hbot.cbw.field.DataTransferLength = 0;
    268                }
    269                  
    270                /* More Data To be Received */
    271                if(MSC_Handle->hbot.cbw.field.DataTransferLength > 0)
   \   000000AE   0xD071             BEQ.N    ??USBH_MSC_BOT_Process_6
    272                {
    273                  /* Send next packet */        
    274                  USBH_BulkReceiveData (phost,
    275                                        MSC_Handle->hbot.pbuf, 
    276                                        MSC_Handle->InEpSize , 
    277                                        MSC_Handle->InPipe);
   \   000000B0   0x7833             LDRB     R3,[R6, #+0]
   \   000000B2   0x4628             MOV      R0,R5
   \   000000B4   0x.... 0x....      BL       USBH_BulkReceiveData
    278                  
    279                }
    280                else
    281                {
    282                  /* If value was 0, and successful transfer, then change the state */
    283                  MSC_Handle->hbot.state  = BOT_RECEIVE_CSW;
    284          #if (USBH_USE_OS == 1)
    285                  osMessagePut ( phost->os_event, USBH_URB_EVENT, 0);
    286          #endif 
    287                }
    288              }
    289              else if(URB_Status == USBH_URB_STALL)
    290              {
    291                /* This is Data IN Stage STALL Condition */
    292                MSC_Handle->hbot.state  = BOT_ERROR_IN;
    293                
    294                /* Refer to USB Mass-Storage Class : BOT (www.usb.org) 
    295                6.7.2 Host expects to receive data from the device
    296                3. On a STALL condition receiving data, then:
    297                The host shall accept the data received.
    298                The host shall clear the Bulk-In pipe.
    299                4. The host shall attempt to receive a CSW.*/
    300                
    301          #if (USBH_USE_OS == 1)
    302              osMessagePut ( phost->os_event, USBH_URB_EVENT, 0);
    303          #endif       
    304              }     
    305              break;  
    306              
    307            case BOT_DATA_OUT:
    308              
    309              USBH_BulkSendData (phost,
    310                                 MSC_Handle->hbot.pbuf, 
    311                                 MSC_Handle->OutEpSize , 
    312                                 MSC_Handle->OutPipe,
    313                                 1);
    314              
    315              
    316              MSC_Handle->hbot.state  = BOT_DATA_OUT_WAIT;
    317              break;
    318              
    319            case BOT_DATA_OUT_WAIT:
    320              URB_Status = USBH_LL_GetURBState(phost, MSC_Handle->OutPipe);     
    321              
    322              if(URB_Status == USBH_URB_DONE)
    323              {
    324                /* Adjust Data pointer and data length */
    325                if(MSC_Handle->hbot.cbw.field.DataTransferLength > MSC_Handle->OutEpSize)
    326                {
    327                    MSC_Handle->hbot.pbuf += MSC_Handle->OutEpSize;
    328                    MSC_Handle->hbot.cbw.field.DataTransferLength -= MSC_Handle->OutEpSize; 
    329                }
    330                else
    331                {
    332                  MSC_Handle->hbot.cbw.field.DataTransferLength = 0;
    333                } 
    334                
    335                /* More Data To be Sent */
    336                if(MSC_Handle->hbot.cbw.field.DataTransferLength > 0)
    337                {
    338                  USBH_BulkSendData (phost,
    339                                     MSC_Handle->hbot.pbuf, 
    340                                     MSC_Handle->OutEpSize , 
    341                                     MSC_Handle->OutPipe,
    342                                     1);
    343                }
    344                else
    345                {
    346                  /* If value was 0, and successful transfer, then change the state */
    347                  MSC_Handle->hbot.state  = BOT_RECEIVE_CSW;
    348                }  
    349          #if (USBH_USE_OS == 1)
    350              osMessagePut ( phost->os_event, USBH_URB_EVENT, 0);
    351          #endif       
    352              }
    353              
    354              else if(URB_Status == USBH_URB_NOTREADY)
    355              {
    356                /* Resend same data */      
    357                MSC_Handle->hbot.state  = BOT_DATA_OUT;
    358          #if (USBH_USE_OS == 1)
    359              osMessagePut ( phost->os_event, USBH_URB_EVENT, 0);
    360          #endif       
    361              }
    362              
    363              else if(URB_Status == USBH_URB_STALL)
    364              {
    365                MSC_Handle->hbot.state  = BOT_ERROR_OUT;
    366                
    367                /* Refer to USB Mass-Storage Class : BOT (www.usb.org) 
    368                6.7.3 Ho - Host expects to send data to the device
    369                3. On a STALL condition sending data, then:
    370                " The host shall clear the Bulk-Out pipe.
    371                4. The host shall attempt to receive a CSW.
    372                */      
    373          #if (USBH_USE_OS == 1)
    374                osMessagePut ( phost->os_event, USBH_URB_EVENT, 0);
    375          #endif       
    376              }
    377              break;
    378              
    379            case BOT_RECEIVE_CSW:
    380              
    381              USBH_BulkReceiveData (phost,
    382                                    MSC_Handle->hbot.csw.data, 
    383                                    BOT_CSW_LENGTH , 
    384                                    MSC_Handle->InPipe);
    385              
    386              MSC_Handle->hbot.state  = BOT_RECEIVE_CSW_WAIT;
    387              break;
    388              
    389            case BOT_RECEIVE_CSW_WAIT:
    390              
    391              URB_Status = USBH_LL_GetURBState(phost, MSC_Handle->InPipe); 
    392              
    393              /* Decode CSW */
    394              if(URB_Status == USBH_URB_DONE)
    395              {
    396                MSC_Handle->hbot.state = BOT_SEND_CBW;    
    397                MSC_Handle->hbot.cmd_state = BOT_CMD_SEND;        
    398                CSW_Status = USBH_MSC_DecodeCSW(phost);
    399                
    400                if(CSW_Status == BOT_CSW_CMD_PASSED)
    401                {
    402                  status = USBH_OK;
    403                }
    404                else
    405                {
    406                  status = USBH_FAIL;
    407                }
    408          #if (USBH_USE_OS == 1)
    409                osMessagePut ( phost->os_event, USBH_URB_EVENT, 0);
    410          #endif       
    411              }
    412              else if(URB_Status == USBH_URB_STALL)     
    413              {
    414                MSC_Handle->hbot.state  = BOT_ERROR_IN;
    415          #if (USBH_USE_OS == 1)
    416                osMessagePut ( phost->os_event, USBH_URB_EVENT, 0);
    417          #endif       
    418              }
    419              break;
    420              
    421            case BOT_ERROR_IN: 
    422              error = USBH_MSC_BOT_Abort(phost, lun, BOT_DIR_IN);
    423              
    424              if (error == USBH_OK)
    425              {
    426                MSC_Handle->hbot.state = BOT_RECEIVE_CSW;
    427              }
    428              else if (error == USBH_UNRECOVERED_ERROR)
    429              {
    430                /* This means that there is a STALL Error limit, Do Reset Recovery */
    431                MSC_Handle->hbot.state = BOT_UNRECOVERED_ERROR;
    432              }
    433              break;
    434              
    435            case BOT_ERROR_OUT: 
    436              error = USBH_MSC_BOT_Abort(phost, lun, BOT_DIR_OUT);
    437              
    438              if ( error == USBH_OK)
    439              { 
    440                
    441                toggle = USBH_LL_GetToggle(phost, MSC_Handle->OutPipe); 
    442                USBH_LL_SetToggle(phost, MSC_Handle->OutPipe, 1- toggle);   
    443                USBH_LL_SetToggle(phost, MSC_Handle->InPipe, 0);  
    444                MSC_Handle->hbot.state = BOT_ERROR_IN;        
    445              }
    446              else if (error == USBH_UNRECOVERED_ERROR)
    447              {
    448                MSC_Handle->hbot.state = BOT_UNRECOVERED_ERROR;
    449              }
    450              break;
    451              
    452              
    453            case BOT_UNRECOVERED_ERROR: 
    454              status = USBH_MSC_BOT_REQ_Reset(phost);
    455              if ( status == USBH_OK)
    456              {
    457                MSC_Handle->hbot.state = BOT_SEND_CBW; 
    458              }
    459              break;
    460              
    461            default:      
    462              break;
    463            }
    464            return status;
   \   000000B8   0x4620             MOV      R0,R4
   \   000000BA   0xB002             ADD      SP,SP,#+8
   \   000000BC   0xBD70             POP      {R4-R6,PC}
   \                     ??USBH_MSC_BOT_Process_10: (+1)
   \   000000BE   0x2805             CMP      R0,#+5
   \   000000C0   0xF040 0x809B      BNE.W    ??USBH_MSC_BOT_Process_1
   \   000000C4   0x2009             MOVS     R0,#+9
   \   000000C6   0xE096             B.N      ??USBH_MSC_BOT_Process_7
   \                     ??USBH_MSC_BOT_Process_12: (+1)
   \   000000C8   0x9400             STR      R4,[SP, #+0]
   \   000000CA   0x7873             LDRB     R3,[R6, #+1]
   \   000000CC   0x88B2             LDRH     R2,[R6, #+4]
   \   000000CE   0xF8D6 0x1088      LDR      R1,[R6, #+136]
   \   000000D2   0x4628             MOV      R0,R5
   \   000000D4   0x.... 0x....      BL       USBH_BulkSendData
   \   000000D8   0x2006             MOVS     R0,#+6
   \   000000DA   0xE08C             B.N      ??USBH_MSC_BOT_Process_7
   \                     ??USBH_MSC_BOT_Process_13: (+1)
   \   000000DC   0x7871             LDRB     R1,[R6, #+1]
   \   000000DE   0x4628             MOV      R0,R5
   \   000000E0   0x.... 0x....      BL       USBH_LL_GetURBState
   \   000000E4   0x2801             CMP      R0,#+1
   \   000000E6   0xD117             BNE.N    ??USBH_MSC_BOT_Process_14
   \   000000E8   0x88B2             LDRH     R2,[R6, #+4]
   \   000000EA   0x6DB3             LDR      R3,[R6, #+88]
   \   000000EC   0x429A             CMP      R2,R3
   \   000000EE   0xD20F             BCS.N    ??USBH_MSC_BOT_Process_11
   \   000000F0   0xF8D6 0x1088      LDR      R1,[R6, #+136]
   \   000000F4   0x1851             ADDS     R1,R2,R1
   \   000000F6   0x1A98             SUBS     R0,R3,R2
   \   000000F8   0xF8C6 0x1088      STR      R1,[R6, #+136]
   \   000000FC   0x65B0             STR      R0,[R6, #+88]
   \   000000FE   0xD049             BEQ.N    ??USBH_MSC_BOT_Process_6
   \   00000100   0x9400             STR      R4,[SP, #+0]
   \   00000102   0x7873             LDRB     R3,[R6, #+1]
   \                     ??USBH_MSC_BOT_Process_3: (+1)
   \   00000104   0x4628             MOV      R0,R5
   \   00000106   0x.... 0x....      BL       USBH_BulkSendData
   \   0000010A   0x4620             MOV      R0,R4
   \   0000010C   0xB002             ADD      SP,SP,#+8
   \   0000010E   0xBD70             POP      {R4-R6,PC}
   \                     ??USBH_MSC_BOT_Process_11: (+1)
   \   00000110   0x2000             MOVS     R0,#+0
   \   00000112   0x65B0             STR      R0,[R6, #+88]
   \   00000114   0x2007             MOVS     R0,#+7
   \   00000116   0xE06E             B.N      ??USBH_MSC_BOT_Process_7
   \                     ??USBH_MSC_BOT_Process_14: (+1)
   \   00000118   0x2802             CMP      R0,#+2
   \   0000011A   0xBF08             IT       EQ 
   \   0000011C   0x2005             MOVEQ    R0,#+5
   \   0000011E   0xD06A             BEQ.N    ??USBH_MSC_BOT_Process_7
   \   00000120   0x2805             CMP      R0,#+5
   \   00000122   0xD16A             BNE.N    ??USBH_MSC_BOT_Process_1
   \   00000124   0x200A             MOVS     R0,#+10
   \   00000126   0xE066             B.N      ??USBH_MSC_BOT_Process_7
   \                     ??USBH_MSC_BOT_Process_15: (+1)
   \   00000128   0x7833             LDRB     R3,[R6, #+0]
   \   0000012A   0xF100 0x0178      ADD      R1,R0,#+120
   \   0000012E   0x220D             MOVS     R2,#+13
   \   00000130   0x4628             MOV      R0,R5
   \   00000132   0x.... 0x....      BL       USBH_BulkReceiveData
   \   00000136   0x2008             MOVS     R0,#+8
   \   00000138   0xE05D             B.N      ??USBH_MSC_BOT_Process_7
   \                     ??USBH_MSC_BOT_Process_16: (+1)
   \   0000013A   0x7831             LDRB     R1,[R6, #+0]
   \   0000013C   0x4628             MOV      R0,R5
   \   0000013E   0x.... 0x....      BL       USBH_LL_GetURBState
   \   00000142   0x2801             CMP      R0,#+1
   \   00000144   0xD11D             BNE.N    ??USBH_MSC_BOT_Process_17
   \   00000146   0xF886 0x004C      STRB     R0,[R6, #+76]
   \   0000014A   0xF886 0x004E      STRB     R0,[R6, #+78]
   \   0000014E   0xF8D5 0x0264      LDR      R0,[R5, #+612]
   \   00000152   0x69C4             LDR      R4,[R0, #+28]
   \   00000154   0x4628             MOV      R0,R5
   \   00000156   0x7921             LDRB     R1,[R4, #+4]
   \   00000158   0x.... 0x....      BL       USBH_LL_GetLastXferSize
   \   0000015C   0x280D             CMP      R0,#+13
   \   0000015E   0xBF02             ITTT     EQ 
   \   00000160   0x6FA0             LDREQ    R0,[R4, #+120]
   \   00000162   0x....             LDREQ.N  R1,??DataTable1_2  ;; 0x53425355
   \   00000164   0x4288             CMPEQ    R0,R1
   \   00000166   0xD108             BNE.N    ??USBH_MSC_BOT_Process_18
   \   00000168   0x6FE0             LDR      R0,[R4, #+124]
   \   0000016A   0x6DA1             LDR      R1,[R4, #+88]
   \   0000016C   0x4288             CMP      R0,R1
   \   0000016E   0xBF02             ITTT     EQ 
   \   00000170   0xF894 0x0084      LDRBEQ   R0,[R4, #+132]
   \   00000174   0x2800             CMPEQ    R0,#+0
   \   00000176   0x2400             MOVEQ    R4,#+0
   \   00000178   0xD03F             BEQ.N    ??USBH_MSC_BOT_Process_1
   \                     ??USBH_MSC_BOT_Process_18: (+1)
   \   0000017A   0x2402             MOVS     R4,#+2
   \   0000017C   0x4620             MOV      R0,R4
   \   0000017E   0xB002             ADD      SP,SP,#+8
   \   00000180   0xBD70             POP      {R4-R6,PC}
   \                     ??USBH_MSC_BOT_Process_17: (+1)
   \   00000182   0x2805             CMP      R0,#+5
   \   00000184   0xD139             BNE.N    ??USBH_MSC_BOT_Process_1
   \   00000186   0x2009             MOVS     R0,#+9
   \   00000188   0xE035             B.N      ??USBH_MSC_BOT_Process_7
   \                     ??USBH_MSC_BOT_Process_19: (+1)
   \   0000018A   0x79C1             LDRB     R1,[R0, #+7]
   \   0000018C   0x4628             MOV      R0,R5
   \   0000018E   0x.... 0x....      BL       USBH_ClrFeature
   \   00000192   0xB908             CBNZ.N   R0,??USBH_MSC_BOT_Process_20
   \                     ??USBH_MSC_BOT_Process_6: (+1)
   \   00000194   0x2007             MOVS     R0,#+7
   \   00000196   0xE02E             B.N      ??USBH_MSC_BOT_Process_7
   \                     ??USBH_MSC_BOT_Process_20: (+1)
   \   00000198   0x2804             CMP      R0,#+4
   \   0000019A   0xD12E             BNE.N    ??USBH_MSC_BOT_Process_1
   \   0000019C   0x200B             MOVS     R0,#+11
   \   0000019E   0xE02A             B.N      ??USBH_MSC_BOT_Process_7
   \                     ??USBH_MSC_BOT_Process_21: (+1)
   \   000001A0   0x7981             LDRB     R1,[R0, #+6]
   \   000001A2   0x4628             MOV      R0,R5
   \   000001A4   0x.... 0x....      BL       USBH_ClrFeature
   \   000001A8   0xB988             CBNZ.N   R0,??USBH_MSC_BOT_Process_22
   \   000001AA   0x7871             LDRB     R1,[R6, #+1]
   \   000001AC   0x4628             MOV      R0,R5
   \   000001AE   0x.... 0x....      BL       USBH_LL_GetToggle
   \   000001B2   0x7871             LDRB     R1,[R6, #+1]
   \   000001B4   0xF1C0 0x0201      RSB      R2,R0,#+1
   \   000001B8   0xB2D2             UXTB     R2,R2
   \   000001BA   0x4628             MOV      R0,R5
   \   000001BC   0x.... 0x....      BL       USBH_LL_SetToggle
   \   000001C0   0x7831             LDRB     R1,[R6, #+0]
   \   000001C2   0x2200             MOVS     R2,#+0
   \   000001C4   0x4628             MOV      R0,R5
   \   000001C6   0x.... 0x....      BL       USBH_LL_SetToggle
   \   000001CA   0x2009             MOVS     R0,#+9
   \   000001CC   0xE013             B.N      ??USBH_MSC_BOT_Process_7
   \                     ??USBH_MSC_BOT_Process_22: (+1)
   \   000001CE   0x2804             CMP      R0,#+4
   \   000001D0   0xD113             BNE.N    ??USBH_MSC_BOT_Process_1
   \   000001D2   0x200B             MOVS     R0,#+11
   \   000001D4   0xE00F             B.N      ??USBH_MSC_BOT_Process_7
   \                     ??USBH_MSC_BOT_Process_23: (+1)
   \   000001D6   0x2021             MOVS     R0,#+33
   \   000001D8   0x2200             MOVS     R2,#+0
   \   000001DA   0x7428             STRB     R0,[R5, #+16]
   \   000001DC   0x20FF             MOVS     R0,#+255
   \   000001DE   0x7468             STRB     R0,[R5, #+17]
   \   000001E0   0x2000             MOVS     R0,#+0
   \   000001E2   0x8268             STRH     R0,[R5, #+18]
   \   000001E4   0x2100             MOVS     R1,#+0
   \   000001E6   0x82A8             STRH     R0,[R5, #+20]
   \   000001E8   0x82E8             STRH     R0,[R5, #+22]
   \   000001EA   0x4628             MOV      R0,R5
   \   000001EC   0x.... 0x....      BL       USBH_CtlReq
   \   000001F0   0x0004             MOVS     R4,R0
   \   000001F2   0xD102             BNE.N    ??USBH_MSC_BOT_Process_1
   \   000001F4   0x2001             MOVS     R0,#+1
   \                     ??USBH_MSC_BOT_Process_7: (+1)
   \   000001F6   0xF886 0x004C      STRB     R0,[R6, #+76]
   \                     ??USBH_MSC_BOT_Process_1: (+1)
   \   000001FA   0x4620             MOV      R0,R4
   \   000001FC   0xB002             ADD      SP,SP,#+8
   \   000001FE   0xBD70             POP      {R4-R6,PC}       ;; return
    465          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1:
   \   00000000   0x43425355         DC32     0x43425355

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_1:
   \   00000000   0x20304050         DC32     0x20304050

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_2:
   \   00000000   0x53425355         DC32     0x53425355
    466          
    467          /**
    468            * @brief  USBH_MSC_BOT_Abort 
    469            *         The function handle the BOT Abort process.
    470            * @param  phost: Host handle
    471            * @param  lun: Logical Unit Number
    472            * @param  dir: direction (0: out / 1 : in)
    473            * @retval USBH Status
    474            */
    475          static USBH_StatusTypeDef USBH_MSC_BOT_Abort(USBH_HandleTypeDef *phost, uint8_t lun, uint8_t dir)
    476          {
    477            USBH_StatusTypeDef status = USBH_FAIL;
    478            MSC_HandleTypeDef *MSC_Handle =  (MSC_HandleTypeDef *) phost->pActiveClass->pData;
    479            
    480            switch (dir)
    481            {
    482            case BOT_DIR_IN :
    483              /* send ClrFeture on Bulk IN endpoint */
    484              status = USBH_ClrFeature(phost, MSC_Handle->InEp);
    485              
    486              break;
    487              
    488            case BOT_DIR_OUT :
    489              /*send ClrFeature on Bulk OUT endpoint */
    490              status = USBH_ClrFeature(phost, MSC_Handle->OutEp);
    491              break;
    492              
    493            default:
    494              break;
    495            }
    496            return status;
    497          }
    498          
    499          /**
    500            * @brief  USBH_MSC_BOT_DecodeCSW
    501            *         This function decodes the CSW received by the device and updates the
    502            *         same to upper layer.
    503            * @param  phost: Host handle
    504            * @retval USBH Status
    505            * @notes
    506            *     Refer to USB Mass-Storage Class : BOT (www.usb.org)
    507            *    6.3.1 Valid CSW Conditions :
    508            *     The host shall consider the CSW valid when:
    509            *     1. dCSWSignature is equal to 53425355h
    510            *     2. the CSW is 13 (Dh) bytes in length,
    511            *     3. dCSWTag matches the dCBWTag from the corresponding CBW.
    512            */
    513          
    514          static BOT_CSWStatusTypeDef USBH_MSC_DecodeCSW(USBH_HandleTypeDef *phost)
    515          {
    516            MSC_HandleTypeDef *MSC_Handle =  (MSC_HandleTypeDef *) phost->pActiveClass->pData;
    517            BOT_CSWStatusTypeDef status = BOT_CSW_CMD_FAILED;
    518            
    519              /*Checking if the transfer length is different than 13*/    
    520              if(USBH_LL_GetLastXferSize(phost, MSC_Handle->InPipe) != BOT_CSW_LENGTH)
    521              {
    522                /*(4) Hi > Dn (Host expects to receive data from the device,
    523                Device intends to transfer no data)
    524                (5) Hi > Di (Host expects to receive data from the device,
    525                Device intends to send data to the host)
    526                (9) Ho > Dn (Host expects to send data to the device,
    527                Device intends to transfer no data)
    528                (11) Ho > Do  (Host expects to send data to the device,
    529                Device intends to receive data from the host)*/
    530                
    531                
    532                status = BOT_CSW_PHASE_ERROR;
    533              }
    534              else
    535              { /* CSW length is Correct */
    536                
    537                /* Check validity of the CSW Signature and CSWStatus */
    538                if(MSC_Handle->hbot.csw.field.Signature == BOT_CSW_SIGNATURE)
    539                {/* Check Condition 1. dCSWSignature is equal to 53425355h */
    540                  
    541                  if(MSC_Handle->hbot.csw.field.Tag == MSC_Handle->hbot.cbw.field.Tag)
    542                  {
    543                    /* Check Condition 3. dCSWTag matches the dCBWTag from the 
    544                    corresponding CBW */
    545          
    546                    if(MSC_Handle->hbot.csw.field.Status == 0) 
    547                    {
    548                      /* Refer to USB Mass-Storage Class : BOT (www.usb.org) 
    549                      
    550                      Hn Host expects no data transfers
    551                      Hi Host expects to receive data from the device
    552                      Ho Host expects to send data to the device
    553                      
    554                      Dn Device intends to transfer no data
    555                      Di Device intends to send data to the host
    556                      Do Device intends to receive data from the host
    557                      
    558                      Section 6.7 
    559                      (1) Hn = Dn (Host expects no data transfers,
    560                      Device intends to transfer no data)
    561                      (6) Hi = Di (Host expects to receive data from the device,
    562                      Device intends to send data to the host)
    563                      (12) Ho = Do (Host expects to send data to the device, 
    564                      Device intends to receive data from the host)
    565                      
    566                      */
    567                      
    568                      status = BOT_CSW_CMD_PASSED;
    569                    }
    570                    else if(MSC_Handle->hbot.csw.field.Status == 1)
    571                    {
    572                      status = BOT_CSW_CMD_FAILED;
    573                    }
    574                    
    575                    else if(MSC_Handle->hbot.csw.field.Status == 2)
    576                    { 
    577                      /* Refer to USB Mass-Storage Class : BOT (www.usb.org) 
    578                      Section 6.7 
    579                      (2) Hn < Di ( Host expects no data transfers, 
    580                      Device intends to send data to the host)
    581                      (3) Hn < Do ( Host expects no data transfers, 
    582                      Device intends to receive data from the host)
    583                      (7) Hi < Di ( Host expects to receive data from the device, 
    584                      Device intends to send data to the host)
    585                      (8) Hi <> Do ( Host expects to receive data from the device, 
    586                      Device intends to receive data from the host)
    587                      (10) Ho <> Di (Host expects to send data to the device,
    588                      Di Device intends to send data to the host)
    589                      (13) Ho < Do (Host expects to send data to the device, 
    590                      Device intends to receive data from the host)
    591                      */
    592                      
    593                      status = BOT_CSW_PHASE_ERROR;
    594                    }
    595                  } /* CSW Tag Matching is Checked  */
    596                } /* CSW Signature Correct Checking */
    597                else
    598                {
    599                  /* If the CSW Signature is not valid, We sall return the Phase Error to
    600                  Upper Layers for Reset Recovery */
    601                  
    602                  status = BOT_CSW_PHASE_ERROR;
    603                }
    604              } /* CSW Length Check*/
    605              
    606            return status;
    607          }
    608          
    609          
    610          /**
    611          * @}
    612          */ 
    613          
    614          /**
    615          * @}
    616          */ 
    617          
    618          /**
    619          * @}
    620          */
    621          
    622          /**
    623          * @}
    624          */ 
    625          
    626          /**
    627          * @}
    628          */
    629          
    630          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
    631          
    632          
    633          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   USBH_MSC_BOT_Init
      24   USBH_MSC_BOT_Process
        24   -> USBH_BulkReceiveData
        24   -> USBH_BulkSendData
        24   -> USBH_ClrFeature
        24   -> USBH_CtlReq
        24   -> USBH_LL_GetLastXferSize
        24   -> USBH_LL_GetToggle
        24   -> USBH_LL_GetURBState
        24   -> USBH_LL_SetToggle
       0   USBH_MSC_BOT_REQ_GetMaxLUN
         0   -> USBH_CtlReq
       0   USBH_MSC_BOT_REQ_Reset
         0   -> USBH_CtlReq


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable1
       4  ??DataTable1_1
       4  ??DataTable1_2
      28  USBH_MSC_BOT_Init
     512  USBH_MSC_BOT_Process
      22  USBH_MSC_BOT_REQ_GetMaxLUN
      22  USBH_MSC_BOT_REQ_Reset

 
 596 bytes in section .text
 
 596 bytes of CODE memory

Errors: none
Warnings: none
