###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.2.10312/W32 for ARM       13/Apr/2016  13:47:33
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_sai.c
#    Command line =  
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_sai.c
#        -D USE_HAL_DRIVER -D STM32F746xx -D USE_STM32746G_DISCO -D
#        USE_IOEXPANDER -D USE_USB_FS -lC
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
#        -lA
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
#        -o
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj
#        --no_unroll --debug --endian=little --cpu=Cortex-M7 -e --fpu=VFPv5_sp
#        --dlib_config "D:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Full.h" -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\CMSIS\Device\ST\STM32F7xx\Include\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\STM32F7xx_HAL_Driver\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\STM32746G-Discovery\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\Components\Common\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Log\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Fonts\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\CPU\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_Device_Library\Core\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Core\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Class\MSC\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\drivers\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_Audio\Addons\PDM\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_Device_Library\Class\AUDIO\Inc\
#        -Oh --use_c++_inline --require_prototypes -I "D:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.3\arm\CMSIS\Include\" -D
#        ARM_MATH_CM7 --relaxed_fp
#    List file    =  
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List\stm32f7xx_hal_sai.lst
#    Object file  =  
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj\stm32f7xx_hal_sai.o
#
###############################################################################

D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_sai.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f7xx_hal_sai.c
      4            * @author  MCD Application Team
      5            * @version V1.0.4
      6            * @date    09-December-2015
      7            * @brief   SAI HAL module driver.
      8            *          This file provides firmware functions to manage the following 
      9            *          functionalities of the Serial Audio Interface (SAI) peripheral:
     10            *           + Initialization/de-initialization functions
     11            *           + I/O operation functions
     12            *           + Peripheral Control functions 
     13            *           + Peripheral State functions
     14            *         
     15            @verbatim
     16           ==============================================================================
     17                            ##### How to use this driver #####
     18            ==============================================================================
     19                     
     20            [..]
     21              The SAI HAL driver can be used as follows:
     22              
     23              (#) Declare a SAI_HandleTypeDef handle structure.
     24              (#) Initialize the SAI low level resources by implementing the HAL_SAI_MspInit() API:
     25                  (##) Enable the SAI interface clock.                      
     26                  (##) SAI pins configuration:
     27                      (+++) Enable the clock for the SAI GPIOs.
     28                      (+++) Configure these SAI pins as alternate function pull-up.
     29                  (##) NVIC configuration if you need to use interrupt process (HAL_SAI_Transmit_IT()
     30                       and HAL_SAI_Receive_IT() APIs):
     31                      (+++) Configure the SAI interrupt priority.
     32                      (+++) Enable the NVIC SAI IRQ handle.
     33          
     34                  (##) DMA Configuration if you need to use DMA process (HAL_SAI_Transmit_DMA()
     35                       and HAL_SAI_Receive_DMA() APIs):
     36                      (+++) Declare a DMA handle structure for the Tx/Rx stream.
     37                      (+++) Enable the DMAx interface clock.
     38                      (+++) Configure the declared DMA handle structure with the required Tx/Rx parameters.                
     39                      (+++) Configure the DMA Tx/Rx Stream.
     40                      (+++) Associate the initialized DMA handle to the SAI DMA Tx/Rx handle.
     41                      (+++) Configure the priority and enable the NVIC for the transfer complete interrupt on the 
     42                          DMA Tx/Rx Stream.
     43            
     44             (#) Program the SAI Mode, Standard, Data Format, MCLK Output, Audio frequency and Polarity
     45                 using HAL_SAI_Init() function.
     46             
     47             -@- The specific SAI interrupts (FIFO request and Overrun underrun interrupt)
     48                 will be managed using the macros __SAI_ENABLE_IT() and __SAI_DISABLE_IT()
     49                 inside the transmit and receive process.   
     50          
     51            [..]           
     52             (@) SAI Clock Source, the configuration is managed through RCCEx_PeriphCLKConfig()
     53                      function in the HAL RCC drivers        
     54            [..]           
     55             (@) Make sure that either:
     56                 (+@) I2S PLL is configured or 
     57                 (+@) SAI PLL is configured or 
     58                 (+@) External clock source is configured after setting correctly 
     59                      the define constant EXTERNAL_CLOCK_VALUE in the stm32f7xx_hal_conf.h file. 
     60                                  
     61            [..]           
     62              (@) In master Tx mode: enabling the audio block immediately generates the bit clock 
     63                  for the external slaves even if there is no data in the FIFO, However FS signal 
     64                  generation is conditioned by the presence of data in the FIFO.
     65                           
     66            [..]           
     67              (@) In master Rx mode: enabling the audio block immediately generates the bit clock 
     68                  and FS signal for the external slaves. 
     69                          
     70            [..]           
     71              (@) It is mandatory to respect the following conditions in order to avoid bad SAI behavior: 
     72                  (+@)  First bit Offset <= (SLOT size - Data size)
     73                  (+@)  Data size <= SLOT size
     74                  (+@)  Number of SLOT x SLOT size = Frame length
     75                  (+@)  The number of slots should be even when SAI_FS_CHANNEL_IDENTIFICATION is selected.  
     76          
     77            [..]         
     78               Three operation modes are available within this driver :     
     79            
     80             *** Polling mode IO operation ***
     81             =================================
     82             [..]    
     83               (+) Send an amount of data in blocking mode using HAL_SAI_Transmit() 
     84               (+) Receive an amount of data in blocking mode using HAL_SAI_Receive()
     85             
     86             *** Interrupt mode IO operation ***    
     87             ===================================
     88             [..]    
     89               (+) Send an amount of data in non blocking mode using HAL_SAI_Transmit_IT() 
     90               (+) At transmission end of transfer HAL_SAI_TxCpltCallback is executed and user can 
     91                   add his own code by customization of function pointer HAL_SAI_TxCpltCallback
     92               (+) Receive an amount of data in non blocking mode using HAL_SAI_Receive_IT() 
     93               (+) At reception end of transfer HAL_SAI_RxCpltCallback is executed and user can 
     94                   add his own code by customization of function pointer HAL_SAI_RxCpltCallback                                      
     95               (+) In case of transfer Error, HAL_SAI_ErrorCallback() function is executed and user can 
     96                   add his own code by customization of function pointer HAL_SAI_ErrorCallback
     97          
     98             *** DMA mode IO operation ***    
     99             ==============================
    100             [..] 
    101               (+) Send an amount of data in non blocking mode (DMA) using HAL_SAI_Transmit_DMA() 
    102               (+) At transmission end of transfer HAL_SAI_TxCpltCallback is executed and user can 
    103                   add his own code by customization of function pointer HAL_SAI_TxCpltCallback
    104               (+) Receive an amount of data in non blocking mode (DMA) using HAL_SAI_Receive_DMA() 
    105               (+) At reception end of transfer HAL_SAI_RxCpltCallback is executed and user can 
    106                   add his own code by customization of function pointer HAL_SAI_RxCpltCallback                                  
    107               (+) In case of transfer Error, HAL_SAI_ErrorCallback() function is executed and user can 
    108                   add his own code by customization of function pointer HAL_SAI_ErrorCallback
    109               (+) Pause the DMA Transfer using HAL_SAI_DMAPause()      
    110               (+) Resume the DMA Transfer using HAL_SAI_DMAResume()  
    111               (+) Stop the DMA Transfer using HAL_SAI_DMAStop()      
    112             
    113             *** SAI HAL driver macros list ***
    114             ============================================= 
    115             [..]
    116               Below the list of most used macros in USART HAL driver :
    117                 
    118                (+) __HAL_SAI_ENABLE: Enable the SAI peripheral
    119                (+) __HAL_SAI_DISABLE: Disable the SAI peripheral
    120                (+) __HAL_SAI_ENABLE_IT : Enable the specified SAI interrupts
    121                (+) __HAL_SAI_DISABLE_IT : Disable the specified SAI interrupts
    122                (+) __HAL_SAI_GET_IT_SOURCE: Check if the specified SAI interrupt source is 
    123                    enabled or disabled
    124                (+) __HAL_SAI_GET_FLAG: Check whether the specified SAI flag is set or not
    125            
    126            @endverbatim
    127            ******************************************************************************
    128            * @attention
    129            *
    130            * <h2><center>&copy; COPYRIGHT(c) 2015 STMicroelectronics</center></h2>
    131            *
    132            * Redistribution and use in source and binary forms, with or without modification,
    133            * are permitted provided that the following conditions are met:
    134            *   1. Redistributions of source code must retain the above copyright notice,
    135            *      this list of conditions and the following disclaimer.
    136            *   2. Redistributions in binary form must reproduce the above copyright notice,
    137            *      this list of conditions and the following disclaimer in the documentation
    138            *      and/or other materials provided with the distribution.
    139            *   3. Neither the name of STMicroelectronics nor the names of its contributors
    140            *      may be used to endorse or promote products derived from this software
    141            *      without specific prior written permission.
    142            *
    143            * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
    144            * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
    145            * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
    146            * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
    147            * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
    148            * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
    149            * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
    150            * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
    151            * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
    152            * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
    153            *
    154            ******************************************************************************
    155            */ 
    156          
    157          /* Includes ------------------------------------------------------------------*/
    158          #include "stm32f7xx_hal.h"
    159          
    160          /** @addtogroup STM32F7xx_HAL_Driver
    161            * @{
    162            */
    163          
    164          /** @defgroup SAI SAI
    165            * @brief SAI HAL module driver
    166            * @{
    167            */
    168          
    169          #ifdef HAL_SAI_MODULE_ENABLED
    170          
    171          /* Private typedef -----------------------------------------------------------*/
    172          /** @defgroup SAI_Private_Typedefs  SAI Private Typedefs
    173            * @{
    174            */
    175          typedef enum {
    176            SAI_MODE_DMA,
    177            SAI_MODE_IT
    178          }SAI_ModeTypedef;
    179          /**
    180            * @}
    181            */
    182          /* Private define ------------------------------------------------------------*/
    183          /** @defgroup SAI_Private_Constants  SAI Private Constants
    184            * @{
    185            */
    186          #define SAI_FIFO_SIZE       8
    187          #define SAI_DEFAULT_TIMEOUT 4
    188          #define SAI_xCR2_MUTECNT_OFFSET POSITION_VAL(SAI_xCR2_MUTECNT)
    189          /**
    190            * @}
    191            */
    192          
    193          /* SAI registers Masks */
    194          #define CR1_CLEAR_MASK            ((uint32_t)0xFF04C010)
    195          #define FRCR_CLEAR_MASK           ((uint32_t)0xFFF88000)
    196          #define SLOTR_CLEAR_MASK          ((uint32_t)0x0000F020)
    197          
    198          #define SAI_TIMEOUT_VALUE         10
    199          /* Private macro -------------------------------------------------------------*/
    200          /* Private variables ---------------------------------------------------------*/
    201          /* Private function prototypes -----------------------------------------------*/
    202          static void SAI_FillFifo(SAI_HandleTypeDef *hsai);
    203          static uint32_t SAI_InterruptFlag(SAI_HandleTypeDef *hsai, uint32_t mode);
    204          static HAL_StatusTypeDef SAI_InitI2S(SAI_HandleTypeDef *hsai, uint32_t protocol, uint32_t datasize, uint32_t nbslot);
    205          static HAL_StatusTypeDef SAI_InitPCM(SAI_HandleTypeDef *hsai, uint32_t protocol, uint32_t datasize, uint32_t nbslot);
    206          
    207          static HAL_StatusTypeDef SAI_Disable(SAI_HandleTypeDef *hsai);
    208          static void SAI_Transmit_IT8Bit(SAI_HandleTypeDef *hsai);
    209          static void SAI_Transmit_IT16Bit(SAI_HandleTypeDef *hsai);
    210          static void SAI_Transmit_IT32Bit(SAI_HandleTypeDef *hsai);
    211          static void SAI_Receive_IT8Bit(SAI_HandleTypeDef *hsai);
    212          static void SAI_Receive_IT16Bit(SAI_HandleTypeDef *hsai);
    213          static void SAI_Receive_IT32Bit(SAI_HandleTypeDef *hsai);
    214          
    215          static void SAI_DMATxCplt(DMA_HandleTypeDef *hdma);
    216          static void SAI_DMATxHalfCplt(DMA_HandleTypeDef *hdma);
    217          static void SAI_DMARxCplt(DMA_HandleTypeDef *hdma);
    218          static void SAI_DMARxHalfCplt(DMA_HandleTypeDef *hdma);
    219          static void SAI_DMAError(DMA_HandleTypeDef *hdma);
    220          
    221          /* Exported functions ---------------------------------------------------------*/
    222          
    223          /** @defgroup SAI_Exported_Functions  SAI Exported Functions
    224            * @{
    225            */
    226          
    227          /** @defgroup SAI_Exported_Functions_Group1 Initialization and de-initialization functions 
    228           *  @brief    Initialization and Configuration functions 
    229           *
    230          @verbatim    
    231           ===============================================================================
    232                        ##### Initialization and de-initialization functions #####
    233           ===============================================================================
    234              [..]  This subsection provides a set of functions allowing to initialize and 
    235                    de-initialize the SAIx peripheral:
    236          
    237                (+) User must implement HAL_SAI_MspInit() function in which he configures 
    238                    all related peripherals resources (CLOCK, GPIO, DMA, IT and NVIC ).
    239          
    240                (+) Call the function HAL_SAI_Init() to configure the selected device with 
    241                    the selected configuration:
    242                  (++) Mode (Master/slave TX/RX)
    243                  (++) Protocol 
    244                  (++) Data Size
    245                  (++) MCLK Output
    246                  (++) Audio frequency
    247                  (++) FIFO Threshold
    248                  (++) Frame Config
    249                  (++) Slot Config
    250          
    251                (+) Call the function HAL_SAI_DeInit() to restore the default configuration 
    252                    of the selected SAI peripheral.     
    253          
    254          @endverbatim
    255            * @{
    256            */
    257          
    258          /**
    259            * @brief  Initializes the structure FrameInit, SlotInit and the low part of 
    260            *         Init according to the specified parameters and call the function
    261            *         HAL_SAI_Init to initialize the SAI block.
    262            * @param  hsai : pointer to a SAI_HandleTypeDef structure that contains 
    263            *               the configuration information for SAI module.
    264            * @param  protocol : one of the supported protocol @ref SAI_Protocol
    265            * @param  datasize : one of the supported datasize @ref SAI_Protocol_DataSize
    266            *                the configuration information for SAI module.
    267            * @param  nbslot   : Number of slot.
    268            * @retval HAL status
    269            */

   \                                 In section .text, align 4, keep-with-next
    270          HAL_StatusTypeDef HAL_SAI_InitProtocol(SAI_HandleTypeDef *hsai, uint32_t protocol, uint32_t datasize, uint32_t nbslot)
    271          {
    272            HAL_StatusTypeDef status = HAL_OK;
    273            
    274            /* Check the parameters */
    275            assert_param(IS_SAI_SUPPORTED_PROTOCOL(protocol));
    276            assert_param(IS_SAI_PROTOCOL_DATASIZE(datasize));
    277            
    278            switch(protocol)
   \                     HAL_SAI_InitProtocol: (+1)
   \   00000000   0x2902             CMP      R1,#+2
   \   00000002   0xB510             PUSH     {R4,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0xD904             BLS.N    ??HAL_SAI_InitProtocol_1
   \   00000008   0x1F08             SUBS     R0,R1,#+4
   \   0000000A   0xD00A             BEQ.N    ??HAL_SAI_InitProtocol_2
   \   0000000C   0x1F00             SUBS     R0,R0,#+4
   \   0000000E   0xD008             BEQ.N    ??HAL_SAI_InitProtocol_2
   \   00000010   0xE039             B.N      ??HAL_SAI_InitProtocol_3
    279            {
    280            case SAI_I2S_STANDARD :
    281            case SAI_I2S_MSBJUSTIFIED :
    282            case SAI_I2S_LSBJUSTIFIED :
    283              status = SAI_InitI2S(hsai, protocol, datasize, nbslot);
   \                     ??HAL_SAI_InitProtocol_1: (+1)
   \   00000012   0x.... 0x....      BL       SAI_InitI2S
    284              break;  
    285            case SAI_PCM_LONG :
    286            case SAI_PCM_SHORT :
    287              status = SAI_InitPCM(hsai, protocol, datasize, nbslot);
    288              break;
    289            default :
    290              status = HAL_ERROR;
    291              break;
    292            }
    293            
    294            if(status == HAL_OK)
   \   00000016   0xB918             CBNZ.N   R0,??HAL_SAI_InitProtocol_4
    295            {
    296              status = HAL_SAI_Init(hsai);
   \                     ??HAL_SAI_InitProtocol_5: (+1)
   \   00000018   0x4620             MOV      R0,R4
   \   0000001A   0xE8BD 0x4010      POP      {R4,LR}
   \   0000001E   0x....             B.N      HAL_SAI_Init
    297            }
    298          
    299            return status;
   \                     ??HAL_SAI_InitProtocol_4: (+1)
   \   00000020   0xBD10             POP      {R4,PC}          ;; return
   \                     ??HAL_SAI_InitProtocol_2: (+1)
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0x65E3             STR      R3,[R4, #+92]
   \   00000026   0x6320             STR      R0,[R4, #+48]
   \   00000028   0x63A0             STR      R0,[R4, #+56]
   \   0000002A   0x63E0             STR      R0,[R4, #+60]
   \   0000002C   0x64A0             STR      R0,[R4, #+72]
   \   0000002E   0xF44F 0x3000      MOV      R0,#+131072
   \   00000032   0x64E0             STR      R0,[R4, #+76]
   \   00000034   0xF44F 0x2080      MOV      R0,#+262144
   \   00000038   0x6520             STR      R0,[R4, #+80]
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0x6560             STR      R0,[R4, #+84]
   \   0000003E   0xF64F 0x70FF      MOVW     R0,#+65535
   \   00000042   0x2904             CMP      R1,#+4
   \   00000044   0x6620             STR      R0,[R4, #+96]
   \   00000046   0xD002             BEQ.N    ??HAL_SAI_InitProtocol_6
   \   00000048   0x2908             CMP      R1,#+8
   \   0000004A   0xD002             BEQ.N    ??HAL_SAI_InitProtocol_7
   \   0000004C   0xE01B             B.N      ??HAL_SAI_InitProtocol_3
   \                     ??HAL_SAI_InitProtocol_6: (+1)
   \   0000004E   0x200D             MOVS     R0,#+13
   \   00000050   0xE000             B.N      ??HAL_SAI_InitProtocol_8
   \                     ??HAL_SAI_InitProtocol_7: (+1)
   \   00000052   0x2001             MOVS     R0,#+1
   \                     ??HAL_SAI_InitProtocol_8: (+1)
   \   00000054   0x2A04             CMP      R2,#+4
   \   00000056   0x6460             STR      R0,[R4, #+68]
   \   00000058   0xD815             BHI.N    ??HAL_SAI_InitProtocol_3
   \   0000005A   0xE8DF 0xF002      TBB      [PC, R2]
   \                     ??HAL_SAI_InitProtocol_0:
   \   0000005E   0x0E 0x0C          DC8      0xE,0xC,0xA,0x14
   \              0x0A 0x14    
   \   00000062   0x03 0x00          DC8      0x3,0x0
   \                     ??HAL_SAI_InitProtocol_9: (+1)
   \   00000064   0x20E0             MOVS     R0,#+224
   \                     ??HAL_SAI_InitProtocol_10: (+1)
   \   00000066   0x6360             STR      R0,[R4, #+52]
   \   00000068   0x0158             LSLS     R0,R3,#+5
   \   0000006A   0x6420             STR      R0,[R4, #+64]
   \   0000006C   0x2080             MOVS     R0,#+128
   \                     ??HAL_SAI_InitProtocol_11: (+1)
   \   0000006E   0x65A0             STR      R0,[R4, #+88]
   \   00000070   0xE7D2             B.N      ??HAL_SAI_InitProtocol_5
   \                     ??HAL_SAI_InitProtocol_12: (+1)
   \   00000072   0x20C0             MOVS     R0,#+192
   \   00000074   0xE7F7             B.N      ??HAL_SAI_InitProtocol_10
   \                     ??HAL_SAI_InitProtocol_13: (+1)
   \   00000076   0x2080             MOVS     R0,#+128
   \   00000078   0xE7F5             B.N      ??HAL_SAI_InitProtocol_10
   \                     ??HAL_SAI_InitProtocol_14: (+1)
   \   0000007A   0x2080             MOVS     R0,#+128
   \   0000007C   0x6360             STR      R0,[R4, #+52]
   \   0000007E   0x0118             LSLS     R0,R3,#+4
   \   00000080   0x6420             STR      R0,[R4, #+64]
   \   00000082   0x2040             MOVS     R0,#+64
   \   00000084   0xE7F3             B.N      ??HAL_SAI_InitProtocol_11
   \                     ??HAL_SAI_InitProtocol_3: (+1)
   \   00000086   0x2001             MOVS     R0,#+1
   \   00000088   0xBD10             POP      {R4,PC}
    300          }
    301          
    302          /**
    303            * @brief  Initializes the SAI according to the specified parameters 
    304            *         in the SAI_InitTypeDef and create the associated handle.
    305            * @param  hsai: pointer to a SAI_HandleTypeDef structure that contains
    306            *                the configuration information for SAI module.
    307            * @retval HAL status
    308            */

   \                                 In section .text, align 2, keep-with-next
    309          HAL_StatusTypeDef HAL_SAI_Init(SAI_HandleTypeDef *hsai)
    310          { 
   \                     HAL_SAI_Init: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
    311            uint32_t tmpclock = 0;
    312          
    313            /* This variable used to store the SAI_CK_x (value in Hz) */
    314            uint32_t freq = 0;
    315            
    316            uint32_t syncen_bits = 0;
   \   00000004   0x2600             MOVS     R6,#+0
    317            
    318            /* Check the SAI handle allocation */
    319            if(hsai == NULL)
   \   00000006   0xB90C             CBNZ.N   R4,??HAL_SAI_Init_0
    320            {
    321              return HAL_ERROR;
   \   00000008   0x2001             MOVS     R0,#+1
   \   0000000A   0xBD70             POP      {R4-R6,PC}
    322            }
    323            
    324            /* Check the SAI Block parameters */
    325            assert_param(IS_SAI_AUDIO_FREQUENCY(hsai->Init.AudioFrequency));  
    326            assert_param(IS_SAI_BLOCK_PROTOCOL(hsai->Init.Protocol));
    327            assert_param(IS_SAI_BLOCK_MODE(hsai->Init.AudioMode));
    328            assert_param(IS_SAI_BLOCK_SYNCEXT(hsai->Init.SynchroExt));
    329            assert_param(IS_SAI_BLOCK_DATASIZE(hsai->Init.DataSize));
    330            assert_param(IS_SAI_BLOCK_FIRST_BIT(hsai->Init.FirstBit));
    331            assert_param(IS_SAI_BLOCK_CLOCK_STROBING(hsai->Init.ClockStrobing));
    332            assert_param(IS_SAI_BLOCK_SYNCHRO(hsai->Init.Synchro));
    333            assert_param(IS_SAI_BLOCK_OUTPUT_DRIVE(hsai->Init.OutputDrive));
    334            assert_param(IS_SAI_BLOCK_NODIVIDER(hsai->Init.NoDivider));
    335            assert_param(IS_SAI_BLOCK_FIFO_THRESHOLD(hsai->Init.FIFOThreshold));
    336            assert_param(IS_SAI_MONO_STEREO_MODE(hsai->Init.MonoStereoMode));
    337            assert_param(IS_SAI_BLOCK_COMPANDING_MODE(hsai->Init.CompandingMode));
    338            assert_param(IS_SAI_BLOCK_TRISTATE_MANAGEMENT(hsai->Init.TriState));
    339            
    340            /* Check the SAI Block Frame parameters */
    341            assert_param(IS_SAI_BLOCK_FRAME_LENGTH(hsai->FrameInit.FrameLength));
    342            assert_param(IS_SAI_BLOCK_ACTIVE_FRAME(hsai->FrameInit.ActiveFrameLength));
    343            assert_param(IS_SAI_BLOCK_FS_DEFINITION(hsai->FrameInit.FSDefinition));
    344            assert_param(IS_SAI_BLOCK_FS_POLARITY(hsai->FrameInit.FSPolarity));
    345            assert_param(IS_SAI_BLOCK_FS_OFFSET(hsai->FrameInit.FSOffset));
    346            
    347            /* Check the SAI Block Slot parameters */
    348            assert_param(IS_SAI_BLOCK_FIRSTBIT_OFFSET(hsai->SlotInit.FirstBitOffset));
    349            assert_param(IS_SAI_BLOCK_SLOT_SIZE(hsai->SlotInit.SlotSize));
    350            assert_param(IS_SAI_BLOCK_SLOT_NUMBER(hsai->SlotInit.SlotNumber));
    351            assert_param(IS_SAI_SLOT_ACTIVE(hsai->SlotInit.SlotActive));
    352            
    353            if(hsai->State == HAL_SAI_STATE_RESET)
   \                     ??HAL_SAI_Init_0: (+1)
   \   0000000C   0xF104 0x057C      ADD      R5,R4,#+124
   \   00000010   0x7868             LDRB     R0,[R5, #+1]
   \   00000012   0xB918             CBNZ.N   R0,??HAL_SAI_Init_1
    354            {
    355              /* Allocate lock resource and initialize it */
    356              hsai->Lock = HAL_UNLOCKED;
   \   00000014   0x7028             STRB     R0,[R5, #+0]
    357              
    358              /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
    359              HAL_SAI_MspInit(hsai);
   \   00000016   0x4620             MOV      R0,R4
   \   00000018   0x.... 0x....      BL       HAL_SAI_MspInit
    360            }
    361            
    362            hsai->State = HAL_SAI_STATE_BUSY;
   \                     ??HAL_SAI_Init_1: (+1)
   \   0000001C   0x2002             MOVS     R0,#+2
   \   0000001E   0x7068             STRB     R0,[R5, #+1]
    363            
    364            /* Disable the selected SAI peripheral */
    365            SAI_Disable(hsai);
   \   00000020   0x4620             MOV      R0,R4
   \   00000022   0x.... 0x....      BL       SAI_Disable
    366            
    367            /* SAI Block Synchro Configuration -----------------------------------------*/
    368            SAI_BlockSynchroConfig(hsai);
   \   00000026   0x4620             MOV      R0,R4
   \   00000028   0x.... 0x....      BL       SAI_BlockSynchroConfig
    369              
    370            /* Configure Master Clock using the following formula :
    371               MCLK_x = SAI_CK_x / (MCKDIV[3:0] * 2) with MCLK_x = 256 * FS
    372               FS = SAI_CK_x / (MCKDIV[3:0] * 2) * 256
    373               MCKDIV[3:0] = SAI_CK_x / FS * 512 */
    374            if(hsai->Init.AudioFrequency != SAI_AUDIO_FREQUENCY_MCKDIV)
   \   0000002C   0x69E0             LDR      R0,[R4, #+28]
   \   0000002E   0xB1A8             CBZ.N    R0,??HAL_SAI_Init_2
    375            { 
    376            /* Get SAI clock source based on Source clock selection from RCC */
    377            freq = SAI_GetInputClock(hsai);
   \   00000030   0x4620             MOV      R0,R4
   \   00000032   0x.... 0x....      BL       SAI_GetInputClock
    378            
    379              /* (saiclocksource x 10) to keep Significant digits */
    380              tmpclock = (((freq * 10) / ((hsai->Init.AudioFrequency) * 512)));
   \   00000036   0xEB00 0x0180      ADD      R1,R0,R0, LSL #+2
   \   0000003A   0x0048             LSLS     R0,R1,#+1
   \   0000003C   0x69E1             LDR      R1,[R4, #+28]
   \   0000003E   0x0249             LSLS     R1,R1,#+9
   \   00000040   0xFBB0 0xF0F1      UDIV     R0,R0,R1
    381              
    382              hsai->Init.Mckdiv = tmpclock / 10;
   \   00000044   0x210A             MOVS     R1,#+10
   \   00000046   0xFBB0 0xF1F1      UDIV     R1,R0,R1
    383              
    384                  /* Round result to the nearest integer */
    385              if((tmpclock % 10) > 8) 
   \   0000004A   0xEB01 0x0281      ADD      R2,R1,R1, LSL #+2
   \   0000004E   0x6221             STR      R1,[R4, #+32]
   \   00000050   0xEBA0 0x0042      SUB      R0,R0,R2, LSL #+1
   \   00000054   0x2809             CMP      R0,#+9
   \   00000056   0xBF24             ITT      CS 
   \   00000058   0x1C48             ADDCS    R0,R1,#+1
   \   0000005A   0x6220             STRCS    R0,[R4, #+32]
    386              {
    387                hsai->Init.Mckdiv+= 1;
    388              }
    389            }
    390            
    391            /* SAI Block Configuration ------------------------------------------------------------*/
    392            switch(hsai->Init.Synchro)
   \                     ??HAL_SAI_Init_2: (+1)
   \   0000005C   0x68A0             LDR      R0,[R4, #+8]
   \   0000005E   0x1E40             SUBS     R0,R0,#+1
   \   00000060   0xD005             BEQ.N    ??HAL_SAI_Init_3
   \   00000062   0x1E40             SUBS     R0,R0,#+1
   \   00000064   0x2801             CMP      R0,#+1
   \   00000066   0xBF98             IT       LS 
   \   00000068   0xF44F 0x6600      MOVLS    R6,#+2048
    393            {
    394              case SAI_ASYNCHRONOUS :
    395                {
    396                  syncen_bits = 0;
    397                }
    398                break;
    399              case SAI_SYNCHRONOUS :
    400                {
    401                  syncen_bits = SAI_xCR1_SYNCEN_0;
    402                }
    403                break;
    404              case SAI_SYNCHRONOUS_EXT_SAI1 :
    405              case SAI_SYNCHRONOUS_EXT_SAI2 :  
    406                {
    407                  syncen_bits = SAI_xCR1_SYNCEN_1;
   \   0000006C   0xE001             B.N      ??HAL_SAI_Init_4
    408                }
   \                     ??HAL_SAI_Init_3: (+1)
   \   0000006E   0xF44F 0x6680      MOV      R6,#+1024
    409                break;
    410            }  
    411            /* SAI CR1 Configuration */
    412            hsai->Instance->CR1&=~(SAI_xCR1_MODE | SAI_xCR1_PRTCFG |  SAI_xCR1_DS |      \
    413                                   SAI_xCR1_LSBFIRST | SAI_xCR1_CKSTR | SAI_xCR1_SYNCEN |\
    414                                   SAI_xCR1_MONO | SAI_xCR1_OUTDRIV  | SAI_xCR1_DMAEN |  \
    415                                   SAI_xCR1_NODIV | SAI_xCR1_MCKDIV);
   \                     ??HAL_SAI_Init_4: (+1)
   \   00000072   0x6820             LDR      R0,[R4, #+0]
   \   00000074   0x....             LDR.N    R2,??DataTable0  ;; 0xff05c010
   \   00000076   0x6801             LDR      R1,[R0, #+0]
   \   00000078   0x4011             ANDS     R1,R2,R1
   \   0000007A   0x6001             STR      R1,[R0, #+0]
    416          
    417            hsai->Instance->CR1|= (hsai->Init.AudioMode | hsai->Init.Protocol |           \
    418                                  hsai->Init.DataSize | hsai->Init.FirstBit  |           \
    419                                  hsai->Init.ClockStrobing | syncen_bits |        \
    420                                  hsai->Init.MonoStereoMode | hsai->Init.OutputDrive |   \
    421                                  hsai->Init.NoDivider | (hsai->Init.Mckdiv << 20));  
   \   0000007C   0x6820             LDR      R0,[R4, #+0]
   \   0000007E   0x6801             LDR      R1,[R0, #+0]
   \   00000080   0x6862             LDR      R2,[R4, #+4]
   \   00000082   0x6B23             LDR      R3,[R4, #+48]
   \   00000084   0x431A             ORRS     R2,R3,R2
   \   00000086   0x6B63             LDR      R3,[R4, #+52]
   \   00000088   0x431A             ORRS     R2,R3,R2
   \   0000008A   0x6BA3             LDR      R3,[R4, #+56]
   \   0000008C   0x431A             ORRS     R2,R3,R2
   \   0000008E   0x6BE3             LDR      R3,[R4, #+60]
   \   00000090   0x431A             ORRS     R2,R3,R2
   \   00000092   0x6A63             LDR      R3,[R4, #+36]
   \   00000094   0x4332             ORRS     R2,R6,R2
   \   00000096   0x431A             ORRS     R2,R3,R2
   \   00000098   0x6923             LDR      R3,[R4, #+16]
   \   0000009A   0x431A             ORRS     R2,R3,R2
   \   0000009C   0x6963             LDR      R3,[R4, #+20]
   \   0000009E   0x431A             ORRS     R2,R3,R2
   \   000000A0   0x6A23             LDR      R3,[R4, #+32]
   \   000000A2   0xEA42 0x5203      ORR      R2,R2,R3, LSL #+20
   \   000000A6   0x4311             ORRS     R1,R2,R1
    422            
    423            /* SAI CR2 Configuration */
    424            hsai->Instance->CR2&= ~(SAI_xCR2_FTH | SAI_xCR2_FFLUSH | SAI_xCR2_COMP | SAI_xCR2_CPL);
   \   000000A8   0x....             LDR.N    R2,??DataTable0_1  ;; 0xffff1ff0
   \   000000AA   0x6001             STR      R1,[R0, #+0]
   \   000000AC   0x6820             LDR      R0,[R4, #+0]
   \   000000AE   0x6841             LDR      R1,[R0, #+4]
   \   000000B0   0x4011             ANDS     R1,R2,R1
   \   000000B2   0x6041             STR      R1,[R0, #+4]
    425            hsai->Instance->CR2|=  (hsai->Init.FIFOThreshold | hsai->Init.CompandingMode | hsai->Init.TriState);
   \   000000B4   0x6820             LDR      R0,[R4, #+0]
   \   000000B6   0x6841             LDR      R1,[R0, #+4]
   \   000000B8   0x69A2             LDR      R2,[R4, #+24]
   \   000000BA   0x6AA3             LDR      R3,[R4, #+40]
   \   000000BC   0x431A             ORRS     R2,R3,R2
   \   000000BE   0x6AE3             LDR      R3,[R4, #+44]
   \   000000C0   0x431A             ORRS     R2,R3,R2
   \   000000C2   0x4311             ORRS     R1,R2,R1
   \   000000C4   0x6041             STR      R1,[R0, #+4]
    426          
    427            /* SAI Frame Configuration -----------------------------------------*/
    428            hsai->Instance->FRCR&=(~(SAI_xFRCR_FRL | SAI_xFRCR_FSALL | SAI_xFRCR_FSDEF | \
    429                                     SAI_xFRCR_FSPO | SAI_xFRCR_FSOFF));
   \   000000C6   0x6820             LDR      R0,[R4, #+0]
   \   000000C8   0x....             LDR.N    R2,??DataTable0_2  ;; 0xfff88000
   \   000000CA   0x6881             LDR      R1,[R0, #+8]
   \   000000CC   0x4011             ANDS     R1,R2,R1
   \   000000CE   0x6081             STR      R1,[R0, #+8]
    430            hsai->Instance->FRCR|=((hsai->FrameInit.FrameLength - 1)  | 
    431                                      hsai->FrameInit.FSOffset | 
    432                                      hsai->FrameInit.FSDefinition | 
    433                                      hsai->FrameInit.FSPolarity   | 
    434                                      ((hsai->FrameInit.ActiveFrameLength - 1) << 8));  
   \   000000D0   0x6820             LDR      R0,[R4, #+0]
   \   000000D2   0x6881             LDR      R1,[R0, #+8]
   \   000000D4   0x6C22             LDR      R2,[R4, #+64]
   \   000000D6   0x6D23             LDR      R3,[R4, #+80]
   \   000000D8   0x1E52             SUBS     R2,R2,#+1
   \   000000DA   0x431A             ORRS     R2,R3,R2
   \   000000DC   0x6CA3             LDR      R3,[R4, #+72]
   \   000000DE   0x431A             ORRS     R2,R3,R2
   \   000000E0   0x6CE3             LDR      R3,[R4, #+76]
   \   000000E2   0x431A             ORRS     R2,R3,R2
   \   000000E4   0x6C63             LDR      R3,[R4, #+68]
   \   000000E6   0x1E5B             SUBS     R3,R3,#+1
   \   000000E8   0xEA42 0x2203      ORR      R2,R2,R3, LSL #+8
   \   000000EC   0x4311             ORRS     R1,R2,R1
    435            
    436            /* SAI Block_x SLOT Configuration ------------------------------------------*/
    437            /* This register has no meaning in AC 97 and SPDIF audio protocol */
    438            hsai->Instance->SLOTR&= (~(SAI_xSLOTR_FBOFF | SAI_xSLOTR_SLOTSZ |            \
    439                                       SAI_xSLOTR_NBSLOT | SAI_xSLOTR_SLOTEN ));
   \   000000EE   0xF24F 0x0220      MOVW     R2,#+61472
   \   000000F2   0x6081             STR      R1,[R0, #+8]
   \   000000F4   0x6820             LDR      R0,[R4, #+0]
   \   000000F6   0x68C1             LDR      R1,[R0, #+12]
   \   000000F8   0x4011             ANDS     R1,R2,R1
   \   000000FA   0x60C1             STR      R1,[R0, #+12]
    440            
    441            hsai->Instance->SLOTR|=  hsai->SlotInit.FirstBitOffset |  hsai->SlotInit.SlotSize
    442                                    | (hsai->SlotInit.SlotActive << 16) | ((hsai->SlotInit.SlotNumber - 1) <<  8);           
   \   000000FC   0x6820             LDR      R0,[R4, #+0]
   \   000000FE   0x68C1             LDR      R1,[R0, #+12]
   \   00000100   0x6D62             LDR      R2,[R4, #+84]
   \   00000102   0x6DA3             LDR      R3,[R4, #+88]
   \   00000104   0x431A             ORRS     R2,R3,R2
   \   00000106   0x6E23             LDR      R3,[R4, #+96]
   \   00000108   0xEA42 0x4203      ORR      R2,R2,R3, LSL #+16
   \   0000010C   0x6DE3             LDR      R3,[R4, #+92]
   \   0000010E   0x1E5B             SUBS     R3,R3,#+1
   \   00000110   0xEA42 0x2203      ORR      R2,R2,R3, LSL #+8
   \   00000114   0x4311             ORRS     R1,R2,R1
   \   00000116   0x60C1             STR      R1,[R0, #+12]
    443            
    444            /* Initialize the error code */
    445            hsai->ErrorCode = HAL_SAI_ERROR_NONE;
   \   00000118   0x2000             MOVS     R0,#+0
   \   0000011A   0x6068             STR      R0,[R5, #+4]
    446            
    447            /* Initialize the SAI state */
    448            hsai->State= HAL_SAI_STATE_READY;
   \   0000011C   0x2001             MOVS     R0,#+1
   \   0000011E   0x7068             STRB     R0,[R5, #+1]
    449            
    450            /* Release Lock */
    451            __HAL_UNLOCK(hsai);
   \   00000120   0x2000             MOVS     R0,#+0
   \   00000122   0x7028             STRB     R0,[R5, #+0]
    452            
    453            return HAL_OK;
   \   00000124   0xBD70             POP      {R4-R6,PC}       ;; return
    454          }
    455          
    456          /**
    457            * @brief  DeInitializes the SAI peripheral. 
    458            * @param  hsai: pointer to a SAI_HandleTypeDef structure that contains
    459            *                the configuration information for SAI module.
    460            * @retval HAL status
    461            */

   \                                 In section .text, align 2, keep-with-next
    462          HAL_StatusTypeDef HAL_SAI_DeInit(SAI_HandleTypeDef *hsai)
    463          {
   \                     HAL_SAI_DeInit: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
    464            /* Check the SAI handle allocation */
    465            if(hsai == NULL)
   \   00000004   0xD101             BNE.N    ??HAL_SAI_DeInit_0
    466            {
    467              return HAL_ERROR;
   \   00000006   0x2001             MOVS     R0,#+1
   \   00000008   0xBD70             POP      {R4-R6,PC}
    468            }
    469          
    470            hsai->State = HAL_SAI_STATE_BUSY;
   \                     ??HAL_SAI_DeInit_0: (+1)
   \   0000000A   0xF104 0x057C      ADD      R5,R4,#+124
   \   0000000E   0x2002             MOVS     R0,#+2
   \   00000010   0x7068             STRB     R0,[R5, #+1]
    471          
    472            /* Disabled All interrupt and clear all the flag */
    473            hsai->Instance->IMR = 0;
   \   00000012   0x6821             LDR      R1,[R4, #+0]
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0x6108             STR      R0,[R1, #+16]
    474            hsai->Instance->CLRFR = 0xFFFFFFFF;
   \   00000018   0x6821             LDR      R1,[R4, #+0]
   \   0000001A   0xF04F 0x30FF      MOV      R0,#-1
   \   0000001E   0x6188             STR      R0,[R1, #+24]
    475            
    476            /* Disable the SAI */
    477            SAI_Disable(hsai);
   \   00000020   0x.... 0x....      BL       HAL_GetTick
   \   00000024   0x4606             MOV      R6,R0
   \   00000026   0x6820             LDR      R0,[R4, #+0]
   \   00000028   0x6801             LDR      R1,[R0, #+0]
   \   0000002A   0xF421 0x3180      BIC      R1,R1,#0x10000
   \   0000002E   0x6001             STR      R1,[R0, #+0]
   \                     ??HAL_SAI_DeInit_1: (+1)
   \   00000030   0x6820             LDR      R0,[R4, #+0]
   \   00000032   0x6800             LDR      R0,[R0, #+0]
   \   00000034   0x03C0             LSLS     R0,R0,#+15
   \   00000036   0xD508             BPL.N    ??HAL_SAI_DeInit_2
   \   00000038   0x.... 0x....      BL       HAL_GetTick
   \   0000003C   0x1B80             SUBS     R0,R0,R6
   \   0000003E   0x280B             CMP      R0,#+11
   \   00000040   0xD3F6             BCC.N    ??HAL_SAI_DeInit_1
   \   00000042   0x6868             LDR      R0,[R5, #+4]
   \   00000044   0xF040 0x0040      ORR      R0,R0,#0x40
   \   00000048   0x6068             STR      R0,[R5, #+4]
    478          
    479            /* Flush the fifo */
    480            SET_BIT(hsai->Instance->CR2, SAI_xCR2_FFLUSH);
   \                     ??HAL_SAI_DeInit_2: (+1)
   \   0000004A   0x6820             LDR      R0,[R4, #+0]
   \   0000004C   0x6841             LDR      R1,[R0, #+4]
   \   0000004E   0xF041 0x0108      ORR      R1,R1,#0x8
   \   00000052   0x6041             STR      R1,[R0, #+4]
    481            
    482            /* DeInit the low level hardware: GPIO, CLOCK, NVIC and DMA */
    483            HAL_SAI_MspDeInit(hsai);
   \   00000054   0x4620             MOV      R0,R4
   \   00000056   0x.... 0x....      BL       HAL_SAI_MspDeInit
    484          
    485            /* Initialize the error code */
    486            hsai->ErrorCode = HAL_SAI_ERROR_NONE;
   \   0000005A   0x2000             MOVS     R0,#+0
   \   0000005C   0x6068             STR      R0,[R5, #+4]
    487            
    488            /* Initialize the SAI state */
    489            hsai->State = HAL_SAI_STATE_RESET;
   \   0000005E   0x7068             STRB     R0,[R5, #+1]
    490          
    491            /* Release Lock */
    492            __HAL_UNLOCK(hsai);
   \   00000060   0x7028             STRB     R0,[R5, #+0]
    493          
    494            return HAL_OK;
   \   00000062   0xBD70             POP      {R4-R6,PC}       ;; return
    495          }
    496          
    497          /**
    498            * @brief SAI MSP Init.
    499            * @param  hsai: pointer to a SAI_HandleTypeDef structure that contains
    500            *                the configuration information for SAI module.
    501            * @retval None
    502            */

   \                                 In section .text, align 2, keep-with-next
    503          __weak void HAL_SAI_MspInit(SAI_HandleTypeDef *hsai)
    504          {
    505            /* Prevent unused argument(s) compilation warning */
    506            UNUSED(hsai);
    507            
    508            /* NOTE : This function should not be modified, when the callback is needed,
    509                      the HAL_SAI_MspInit could be implemented in the user file
    510             */ 
    511          }
   \                     HAL_SAI_MspInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    512          
    513          /**
    514            * @brief SAI MSP DeInit.
    515            * @param  hsai: pointer to a SAI_HandleTypeDef structure that contains
    516            *                the configuration information for SAI module.
    517            * @retval None
    518            */

   \                                 In section .text, align 2, keep-with-next
    519          __weak void HAL_SAI_MspDeInit(SAI_HandleTypeDef *hsai)
    520          {
    521            /* Prevent unused argument(s) compilation warning */
    522            UNUSED(hsai);
    523            
    524            /* NOTE : This function should not be modified, when the callback is needed,
    525                      the HAL_SAI_MspDeInit could be implemented in the user file
    526             */ 
    527          }
   \                     HAL_SAI_MspDeInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    528          
    529          /**
    530            * @}
    531            */
    532          
    533          /** @defgroup SAI_Exported_Functions_Group2 IO operation functions 
    534           *  @brief   Data transfers functions 
    535           *
    536          @verbatim   
    537            ===============================================================================
    538                                ##### IO operation functions #####
    539           ===============================================================================  
    540              [..]
    541              This subsection provides a set of functions allowing to manage the SAI data 
    542              transfers.
    543          
    544              (+) There are two modes of transfer:
    545                 (++) Blocking mode : The communication is performed in the polling mode. 
    546                      The status of all data processing is returned by the same function 
    547                      after finishing transfer.  
    548                 (++) No-Blocking mode : The communication is performed using Interrupts 
    549                      or DMA. These functions return the status of the transfer startup.
    550                      The end of the data processing will be indicated through the 
    551                      dedicated SAI IRQ when using Interrupt mode or the DMA IRQ when 
    552                      using DMA mode.
    553          
    554              (+) Blocking mode functions are :
    555                  (++) HAL_SAI_Transmit()
    556                  (++) HAL_SAI_Receive()
    557                  (++) HAL_SAI_TransmitReceive()
    558                  
    559              (+) Non Blocking mode functions with Interrupt are :
    560                  (++) HAL_SAI_Transmit_IT()
    561                  (++) HAL_SAI_Receive_IT()
    562                  (++) HAL_SAI_TransmitReceive_IT()
    563          
    564              (+) Non Blocking mode functions with DMA are :
    565                  (++) HAL_SAI_Transmit_DMA()
    566                  (++) HAL_SAI_Receive_DMA()
    567                  (++) HAL_SAI_TransmitReceive_DMA()
    568          
    569              (+) A set of Transfer Complete Callbacks are provided in non Blocking mode:
    570                  (++) HAL_SAI_TxCpltCallback()
    571                  (++) HAL_SAI_RxCpltCallback()
    572                  (++) HAL_SAI_ErrorCallback()
    573          
    574          @endverbatim
    575            * @{
    576            */
    577          
    578          /**
    579            * @brief  Transmits an amount of data in blocking mode.
    580            * @param  hsai: pointer to a SAI_HandleTypeDef structure that contains
    581            *                the configuration information for SAI module.
    582            * @param  pData: Pointer to data buffer
    583            * @param  Size: Amount of data to be sent
    584            * @param  Timeout: Timeout duration
    585            * @retval HAL status
    586            */

   \                                 In section .text, align 2, keep-with-next
    587          HAL_StatusTypeDef HAL_SAI_Transmit(SAI_HandleTypeDef *hsai, uint8_t* pData, uint16_t Size, uint32_t Timeout)
    588          {
   \                     HAL_SAI_Transmit: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
   \   00000008   0x4616             MOV      R6,R2
   \   0000000A   0x4698             MOV      R8,R3
    589            uint32_t tickstart = HAL_GetTick();
   \   0000000C   0x.... 0x....      BL       HAL_GetTick
    590            
    591            if((pData == NULL ) || (Size == 0)) 
   \   00000010   0x2D00             CMP      R5,#+0
   \   00000012   0x4681             MOV      R9,R0
   \   00000014   0xBF14             ITE      NE 
   \   00000016   0x2E00             CMPNE    R6,#+0
   \   00000018   0x2001             MOVEQ    R0,#+1
    592            {
    593              return  HAL_ERROR;
   \   0000001A   0xD051             BEQ.N    ??HAL_SAI_Transmit_0
    594            }
    595            
    596            if(hsai->State == HAL_SAI_STATE_READY)
   \   0000001C   0xF104 0x0768      ADD      R7,R4,#+104
   \   00000020   0x7D78             LDRB     R0,[R7, #+21]
   \   00000022   0x2801             CMP      R0,#+1
   \   00000024   0xD14B             BNE.N    ??HAL_SAI_Transmit_1
    597            {  
    598              /* Process Locked */
    599              __HAL_LOCK(hsai);
   \   00000026   0x7D38             LDRB     R0,[R7, #+20]
   \   00000028   0x2801             CMP      R0,#+1
   \   0000002A   0xD048             BEQ.N    ??HAL_SAI_Transmit_1
   \   0000002C   0x2001             MOVS     R0,#+1
   \   0000002E   0x7538             STRB     R0,[R7, #+20]
    600              
    601              hsai->XferSize = Size;
    602              hsai->XferCount = Size;
    603              hsai->pBuffPtr = pData;
    604              hsai->State = HAL_SAI_STATE_BUSY_TX;
   \   00000030   0x2012             MOVS     R0,#+18
   \   00000032   0x803E             STRH     R6,[R7, #+0]
   \   00000034   0x807E             STRH     R6,[R7, #+2]
   \   00000036   0x6665             STR      R5,[R4, #+100]
   \   00000038   0x7578             STRB     R0,[R7, #+21]
    605              hsai->ErrorCode = HAL_SAI_ERROR_NONE;
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0x61B8             STR      R0,[R7, #+24]
    606              
    607              /* Check if the SAI is already enabled */ 
    608              if((hsai->Instance->CR1 & SAI_xCR1_SAIEN) == RESET)
   \   0000003E   0x6820             LDR      R0,[R4, #+0]
   \   00000040   0x6800             LDR      R0,[R0, #+0]
   \   00000042   0x03C0             LSLS     R0,R0,#+15
   \   00000044   0xD411             BMI.N    ??HAL_SAI_Transmit_2
    609              {
    610                /* fill the fifo with data before to enabled the SAI */
    611                SAI_FillFifo(hsai);      
   \   00000046   0x4620             MOV      R0,R4
   \   00000048   0x.... 0x....      BL       SAI_FillFifo
    612                /* Enable SAI peripheral */    
    613                __HAL_SAI_ENABLE(hsai);
   \   0000004C   0x6820             LDR      R0,[R4, #+0]
   \   0000004E   0x6801             LDR      R1,[R0, #+0]
   \   00000050   0xF441 0x3180      ORR      R1,R1,#0x10000
   \   00000054   0x6001             STR      R1,[R0, #+0]
   \   00000056   0xE008             B.N      ??HAL_SAI_Transmit_2
    614              }
    615              
    616              while(hsai->XferCount > 0)
    617              { 
    618                /* Write data if the FIFO is not full */
    619                if((hsai->Instance->SR & SAI_xSR_FLVL) != SAI_FIFOSTATUS_FULL)
    620                {
    621                  if((hsai->Init.DataSize == SAI_DATASIZE_8) && (hsai->Init.CompandingMode == SAI_NOCOMPANDING))
    622                  {      
    623                    hsai->Instance->DR = (*hsai->pBuffPtr++);
    624                  }
    625                  else if(hsai->Init.DataSize <= SAI_DATASIZE_16)
    626                  {
    627                    hsai->Instance->DR = *((uint16_t *)hsai->pBuffPtr);
    628                    hsai->pBuffPtr+= 2;        
    629                  }
    630                  else
    631                  {
    632                    hsai->Instance->DR = *((uint32_t *)hsai->pBuffPtr);
   \                     ??HAL_SAI_Transmit_3: (+1)
   \   00000058   0x6E61             LDR      R1,[R4, #+100]
   \   0000005A   0x6809             LDR      R1,[R1, #+0]
   \   0000005C   0x61C1             STR      R1,[R0, #+28]
    633                    hsai->pBuffPtr+= 4;
   \   0000005E   0x6E60             LDR      R0,[R4, #+100]
   \   00000060   0x1D00             ADDS     R0,R0,#+4
   \                     ??HAL_SAI_Transmit_4: (+1)
   \   00000062   0x6660             STR      R0,[R4, #+100]
    634                  }       
    635                  hsai->XferCount--; 
   \                     ??HAL_SAI_Transmit_5: (+1)
   \   00000064   0x8878             LDRH     R0,[R7, #+2]
   \   00000066   0x1E40             SUBS     R0,R0,#+1
   \   00000068   0x8078             STRH     R0,[R7, #+2]
   \                     ??HAL_SAI_Transmit_2: (+1)
   \   0000006A   0x8878             LDRH     R0,[R7, #+2]
   \   0000006C   0xB330             CBZ.N    R0,??HAL_SAI_Transmit_6
   \                     ??HAL_SAI_Transmit_7: (+1)
   \   0000006E   0x6820             LDR      R0,[R4, #+0]
   \   00000070   0x6941             LDR      R1,[R0, #+20]
   \   00000072   0xF401 0x21E0      AND      R1,R1,#0x70000
   \   00000076   0xF5B1 0x2FA0      CMP      R1,#+327680
   \   0000007A   0xD012             BEQ.N    ??HAL_SAI_Transmit_8
   \   0000007C   0x6B61             LDR      R1,[R4, #+52]
   \   0000007E   0x2940             CMP      R1,#+64
   \   00000080   0xD107             BNE.N    ??HAL_SAI_Transmit_9
   \   00000082   0x6AA1             LDR      R1,[R4, #+40]
   \   00000084   0xB939             CBNZ.N   R1,??HAL_SAI_Transmit_10
   \   00000086   0x6E61             LDR      R1,[R4, #+100]
   \   00000088   0x1C4A             ADDS     R2,R1,#+1
   \   0000008A   0x6662             STR      R2,[R4, #+100]
   \   0000008C   0x7809             LDRB     R1,[R1, #+0]
   \   0000008E   0x61C1             STR      R1,[R0, #+28]
   \   00000090   0xE7E8             B.N      ??HAL_SAI_Transmit_5
   \                     ??HAL_SAI_Transmit_9: (+1)
   \   00000092   0x2981             CMP      R1,#+129
   \   00000094   0xD2E0             BCS.N    ??HAL_SAI_Transmit_3
   \                     ??HAL_SAI_Transmit_10: (+1)
   \   00000096   0x6E61             LDR      R1,[R4, #+100]
   \   00000098   0x8809             LDRH     R1,[R1, #+0]
   \   0000009A   0x61C1             STR      R1,[R0, #+28]
   \   0000009C   0x6E60             LDR      R0,[R4, #+100]
   \   0000009E   0x1C80             ADDS     R0,R0,#+2
   \   000000A0   0xE7DF             B.N      ??HAL_SAI_Transmit_4
    636                }
    637                else
    638                {
    639                  /* Check for the Timeout */
    640                  if((Timeout != HAL_MAX_DELAY) && ((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout)))
   \                     ??HAL_SAI_Transmit_8: (+1)
   \   000000A2   0xF118 0x0F01      CMN      R8,#+1
   \   000000A6   0xD0E2             BEQ.N    ??HAL_SAI_Transmit_7
   \   000000A8   0xF1B8 0x0F00      CMP      R8,#+0
   \   000000AC   0xD005             BEQ.N    ??HAL_SAI_Transmit_11
   \   000000AE   0x.... 0x....      BL       HAL_GetTick
   \   000000B2   0xEBA0 0x0009      SUB      R0,R0,R9
   \   000000B6   0x4580             CMP      R8,R0
   \   000000B8   0xD2D7             BCS.N    ??HAL_SAI_Transmit_2
    641                  {
    642                    /* Update error code */
    643                    hsai->ErrorCode |= HAL_SAI_ERROR_TIMEOUT;
   \                     ??HAL_SAI_Transmit_11: (+1)
   \   000000BA   0x....             B.N      ?Subroutine3
    644                    /* Change the SAI state */
    645                    hsai->State = HAL_SAI_STATE_TIMEOUT;
    646                    
    647                    return HAL_TIMEOUT;
    648                  }
    649                }
    650              }      
    651              
    652              hsai->State = HAL_SAI_STATE_READY; 
   \                     ??HAL_SAI_Transmit_6: (+1)
   \   000000BC   0x....             B.N      ?Subroutine4
    653              
    654              /* Process Unlocked */
    655              __HAL_UNLOCK(hsai);
    656              
    657              return HAL_OK;
    658            }
    659            else
    660            {
    661              return HAL_BUSY;
   \                     ??HAL_SAI_Transmit_1: (+1)
   \   000000BE   0x2002             MOVS     R0,#+2
   \                     ??HAL_SAI_Transmit_0: (+1)
   \   000000C0   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    662            }
    663          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine4: (+1)
   \   00000000   0x2001             MOVS     R0,#+1
   \   00000002   0x7578             STRB     R0,[R7, #+21]
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x7538             STRB     R0,[R7, #+20]
   \   00000008   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine3: (+1)
   \   00000000   0x69B8             LDR      R0,[R7, #+24]
   \   00000002   0xF040 0x0040      ORR      R0,R0,#0x40
   \   00000006   0x61B8             STR      R0,[R7, #+24]
   \   00000008   0x2003             MOVS     R0,#+3
   \   0000000A   0x7578             STRB     R0,[R7, #+21]
   \   0000000C   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}
    664          
    665          /**
    666            * @brief  Receives an amount of data in blocking mode. 
    667            * @param  hsai: pointer to a SAI_HandleTypeDef structure that contains
    668            *                the configuration information for SAI module.
    669            * @param  pData: Pointer to data buffer
    670            * @param  Size: Amount of data to be received
    671            * @param  Timeout: Timeout duration
    672            * @retval HAL status
    673            */

   \                                 In section .text, align 2, keep-with-next
    674          HAL_StatusTypeDef HAL_SAI_Receive(SAI_HandleTypeDef *hsai, uint8_t *pData, uint16_t Size, uint32_t Timeout)
    675          {
   \                     HAL_SAI_Receive: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
   \   00000008   0x4616             MOV      R6,R2
   \   0000000A   0x4698             MOV      R8,R3
    676            uint32_t tickstart = HAL_GetTick();
   \   0000000C   0x.... 0x....      BL       HAL_GetTick
    677            
    678            if((pData == NULL ) || (Size == 0)) 
   \   00000010   0x2D00             CMP      R5,#+0
   \   00000012   0x4681             MOV      R9,R0
   \   00000014   0xBF14             ITE      NE 
   \   00000016   0x2E00             CMPNE    R6,#+0
   \   00000018   0x2001             MOVEQ    R0,#+1
    679            {
    680              return  HAL_ERROR;
   \   0000001A   0xD04B             BEQ.N    ??HAL_SAI_Receive_0
    681            }
    682            
    683            if(hsai->State == HAL_SAI_STATE_READY)
   \   0000001C   0xF104 0x0768      ADD      R7,R4,#+104
   \   00000020   0x7D78             LDRB     R0,[R7, #+21]
   \   00000022   0x2801             CMP      R0,#+1
   \   00000024   0xD145             BNE.N    ??HAL_SAI_Receive_1
    684            { 
    685              /* Process Locked */
    686              __HAL_LOCK(hsai);
   \   00000026   0x7D38             LDRB     R0,[R7, #+20]
   \   00000028   0x2801             CMP      R0,#+1
   \   0000002A   0xD042             BEQ.N    ??HAL_SAI_Receive_1
   \   0000002C   0x2001             MOVS     R0,#+1
   \   0000002E   0x7538             STRB     R0,[R7, #+20]
    687              
    688              hsai->pBuffPtr = pData;
    689              hsai->XferSize = Size;
    690              hsai->XferCount = Size;
    691              hsai->State = HAL_SAI_STATE_BUSY_RX;
   \   00000030   0x2022             MOVS     R0,#+34
   \   00000032   0x6665             STR      R5,[R4, #+100]
   \   00000034   0x803E             STRH     R6,[R7, #+0]
   \   00000036   0x807E             STRH     R6,[R7, #+2]
   \   00000038   0x7578             STRB     R0,[R7, #+21]
    692              hsai->ErrorCode = HAL_SAI_ERROR_NONE;
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0x61B8             STR      R0,[R7, #+24]
    693              
    694              /* Check if the SAI is already enabled */ 
    695              if((hsai->Instance->CR1 & SAI_xCR1_SAIEN) == RESET)
   \   0000003E   0x6820             LDR      R0,[R4, #+0]
   \   00000040   0x6801             LDR      R1,[R0, #+0]
   \   00000042   0x03C9             LSLS     R1,R1,#+15
   \   00000044   0xD40D             BMI.N    ??HAL_SAI_Receive_2
    696              {
    697                /* Enable SAI peripheral */    
    698                __HAL_SAI_ENABLE(hsai);
   \   00000046   0x6801             LDR      R1,[R0, #+0]
   \   00000048   0xF441 0x3180      ORR      R1,R1,#0x10000
   \   0000004C   0x6001             STR      R1,[R0, #+0]
   \   0000004E   0xE008             B.N      ??HAL_SAI_Receive_2
    699              }
    700              
    701              /* Receive data */
    702              while(hsai->XferCount > 0)
    703              {      
    704                if((hsai->Instance->SR & SAI_xSR_FLVL) != SAI_FIFOSTATUS_EMPTY)
    705                {
    706                  if((hsai->Init.DataSize == SAI_DATASIZE_8) && (hsai->Init.CompandingMode == SAI_NOCOMPANDING))
    707                  {
    708                    (*hsai->pBuffPtr++) = hsai->Instance->DR;
    709                  }
    710                  else if(hsai->Init.DataSize <= SAI_DATASIZE_16)
    711                  {
    712                    *((uint16_t*)hsai->pBuffPtr) = hsai->Instance->DR;
    713                    hsai->pBuffPtr+= 2;
    714                  }
    715                  else
    716                  {
    717                    *((uint32_t*)hsai->pBuffPtr) = hsai->Instance->DR;
   \                     ??HAL_SAI_Receive_3: (+1)
   \   00000050   0x69C0             LDR      R0,[R0, #+28]
   \   00000052   0x6E61             LDR      R1,[R4, #+100]
   \   00000054   0x6008             STR      R0,[R1, #+0]
    718                    hsai->pBuffPtr+= 4;
   \   00000056   0x6E60             LDR      R0,[R4, #+100]
   \   00000058   0x1D00             ADDS     R0,R0,#+4
   \                     ??HAL_SAI_Receive_4: (+1)
   \   0000005A   0x6660             STR      R0,[R4, #+100]
    719                  }  
    720                  hsai->XferCount--; 
   \                     ??HAL_SAI_Receive_5: (+1)
   \   0000005C   0x8878             LDRH     R0,[R7, #+2]
   \   0000005E   0x1E40             SUBS     R0,R0,#+1
   \   00000060   0x8078             STRH     R0,[R7, #+2]
   \                     ??HAL_SAI_Receive_2: (+1)
   \   00000062   0x8878             LDRH     R0,[R7, #+2]
   \   00000064   0xB320             CBZ.N    R0,??HAL_SAI_Receive_6
   \                     ??HAL_SAI_Receive_7: (+1)
   \   00000066   0x6820             LDR      R0,[R4, #+0]
   \   00000068   0x6941             LDR      R1,[R0, #+20]
   \   0000006A   0xF411 0x2FE0      TST      R1,#0x70000
   \   0000006E   0xD012             BEQ.N    ??HAL_SAI_Receive_8
   \   00000070   0x6B61             LDR      R1,[R4, #+52]
   \   00000072   0x2940             CMP      R1,#+64
   \   00000074   0xD107             BNE.N    ??HAL_SAI_Receive_9
   \   00000076   0x6AA1             LDR      R1,[R4, #+40]
   \   00000078   0xB939             CBNZ.N   R1,??HAL_SAI_Receive_10
   \   0000007A   0x6E61             LDR      R1,[R4, #+100]
   \   0000007C   0x1C4A             ADDS     R2,R1,#+1
   \   0000007E   0x6662             STR      R2,[R4, #+100]
   \   00000080   0x69C0             LDR      R0,[R0, #+28]
   \   00000082   0x7008             STRB     R0,[R1, #+0]
   \   00000084   0xE7EA             B.N      ??HAL_SAI_Receive_5
   \                     ??HAL_SAI_Receive_9: (+1)
   \   00000086   0x2981             CMP      R1,#+129
   \   00000088   0xD2E2             BCS.N    ??HAL_SAI_Receive_3
   \                     ??HAL_SAI_Receive_10: (+1)
   \   0000008A   0x69C0             LDR      R0,[R0, #+28]
   \   0000008C   0x6E61             LDR      R1,[R4, #+100]
   \   0000008E   0x8008             STRH     R0,[R1, #+0]
   \   00000090   0x6E60             LDR      R0,[R4, #+100]
   \   00000092   0x1C80             ADDS     R0,R0,#+2
   \   00000094   0xE7E1             B.N      ??HAL_SAI_Receive_4
    721                }
    722                else
    723                {
    724                  /* Check for the Timeout */
    725                  if((Timeout != HAL_MAX_DELAY) && ((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout)))
   \                     ??HAL_SAI_Receive_8: (+1)
   \   00000096   0xF118 0x0F01      CMN      R8,#+1
   \   0000009A   0xD0E4             BEQ.N    ??HAL_SAI_Receive_7
   \   0000009C   0xF1B8 0x0F00      CMP      R8,#+0
   \   000000A0   0xD005             BEQ.N    ??HAL_SAI_Receive_11
   \   000000A2   0x.... 0x....      BL       HAL_GetTick
   \   000000A6   0xEBA0 0x0009      SUB      R0,R0,R9
   \   000000AA   0x4580             CMP      R8,R0
   \   000000AC   0xD2D9             BCS.N    ??HAL_SAI_Receive_2
    726                  {
    727                    /* Update error code */
    728                    hsai->ErrorCode |= HAL_SAI_ERROR_TIMEOUT;
   \                     ??HAL_SAI_Receive_11: (+1)
   \   000000AE   0x....             B.N      ?Subroutine3
    729                    /* Change the SAI state */
    730                    hsai->State = HAL_SAI_STATE_TIMEOUT;
    731                    
    732                    return HAL_TIMEOUT;
    733                  }
    734                }
    735              }      
    736              
    737              hsai->State = HAL_SAI_STATE_READY; 
   \                     ??HAL_SAI_Receive_6: (+1)
   \   000000B0   0x....             B.N      ?Subroutine4
    738              
    739              /* Process Unlocked */
    740              __HAL_UNLOCK(hsai);
    741              
    742              return HAL_OK;
    743            }
    744            else
    745            {
    746              return HAL_BUSY;
   \                     ??HAL_SAI_Receive_1: (+1)
   \   000000B2   0x2002             MOVS     R0,#+2
   \                     ??HAL_SAI_Receive_0: (+1)
   \   000000B4   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    747            }
    748          }
    749          
    750          /**
    751            * @brief  Transmits an amount of data in no-blocking mode with Interrupt.
    752            * @param  hsai: pointer to a SAI_HandleTypeDef structure that contains
    753            *                the configuration information for SAI module.
    754            * @param  pData: Pointer to data buffer
    755            * @param  Size: Amount of data to be sent
    756            * @retval HAL status
    757            */

   \                                 In section .text, align 2, keep-with-next
    758          HAL_StatusTypeDef HAL_SAI_Transmit_IT(SAI_HandleTypeDef *hsai, uint8_t *pData, uint16_t Size)
    759          {
    760              if((pData == NULL) || (Size == 0)) 
   \                     HAL_SAI_Transmit_IT: (+1)
   \   00000000   0x2900             CMP      R1,#+0
   \   00000002   0xB538             PUSH     {R3-R5,LR}
   \   00000004   0x4605             MOV      R5,R0
   \   00000006   0xBF18             IT       NE 
   \   00000008   0x2A00             CMPNE    R2,#+0
   \   0000000A   0xD101             BNE.N    ??HAL_SAI_Transmit_IT_0
    761              {
    762                return  HAL_ERROR;
   \   0000000C   0x2001             MOVS     R0,#+1
   \   0000000E   0xBD32             POP      {R1,R4,R5,PC}
    763              }
    764              
    765            if(hsai->State == HAL_SAI_STATE_READY)
   \                     ??HAL_SAI_Transmit_IT_0: (+1)
   \   00000010   0xF105 0x0468      ADD      R4,R5,#+104
   \   00000014   0x7D60             LDRB     R0,[R4, #+21]
   \   00000016   0x2801             CMP      R0,#+1
   \   00000018   0xD12F             BNE.N    ??HAL_SAI_Transmit_IT_1
    766            {    
    767              /* Process Locked */
    768              __HAL_LOCK(hsai);
   \   0000001A   0x7D20             LDRB     R0,[R4, #+20]
   \   0000001C   0x2801             CMP      R0,#+1
   \   0000001E   0xD02C             BEQ.N    ??HAL_SAI_Transmit_IT_1
   \   00000020   0x2001             MOVS     R0,#+1
   \   00000022   0x7520             STRB     R0,[R4, #+20]
    769              
    770              hsai->pBuffPtr = pData;
    771              hsai->XferSize = Size;
    772              hsai->XferCount = Size;
    773              hsai->ErrorCode = HAL_SAI_ERROR_NONE;    
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0x6669             STR      R1,[R5, #+100]
   \   00000028   0x8022             STRH     R2,[R4, #+0]
   \   0000002A   0x8062             STRH     R2,[R4, #+2]
   \   0000002C   0x61A0             STR      R0,[R4, #+24]
    774              hsai->State = HAL_SAI_STATE_BUSY_TX;
   \   0000002E   0x2012             MOVS     R0,#+18
   \   00000030   0x7560             STRB     R0,[R4, #+21]
    775              
    776              if((hsai->Init.DataSize == SAI_DATASIZE_8) && (hsai->Init.CompandingMode == SAI_NOCOMPANDING))
   \   00000032   0x6B68             LDR      R0,[R5, #+52]
   \   00000034   0x2840             CMP      R0,#+64
   \   00000036   0xD104             BNE.N    ??HAL_SAI_Transmit_IT_2
   \   00000038   0x6AA8             LDR      R0,[R5, #+40]
   \   0000003A   0xB920             CBNZ.N   R0,??HAL_SAI_Transmit_IT_3
    777              {
    778                hsai->InterruptServiceRoutine = SAI_Transmit_IT8Bit;
   \   0000003C   0x.... 0x....      ADR.W    R0,SAI_Transmit_IT8Bit
   \   00000040   0xE006             B.N      ??HAL_SAI_Transmit_IT_4
    779              }
    780              else if(hsai->Init.DataSize <= SAI_DATASIZE_16)
   \                     ??HAL_SAI_Transmit_IT_2: (+1)
   \   00000042   0x2881             CMP      R0,#+129
   \   00000044   0xD202             BCS.N    ??HAL_SAI_Transmit_IT_5
    781              {
    782                hsai->InterruptServiceRoutine = SAI_Transmit_IT16Bit;
   \                     ??HAL_SAI_Transmit_IT_3: (+1)
   \   00000046   0x.... 0x....      ADR.W    R0,SAI_Transmit_IT16Bit
   \   0000004A   0xE001             B.N      ??HAL_SAI_Transmit_IT_4
    783              }
    784              else
    785              {
    786                hsai->InterruptServiceRoutine = SAI_Transmit_IT32Bit;
   \                     ??HAL_SAI_Transmit_IT_5: (+1)
   \   0000004C   0x.... 0x....      ADR.W    R0,SAI_Transmit_IT32Bit
   \                     ??HAL_SAI_Transmit_IT_4: (+1)
   \   00000050   0x6120             STR      R0,[R4, #+16]
    787              }
    788              
    789              /* Fill the fifo before starting the communication */
    790              SAI_FillFifo(hsai);
   \   00000052   0x4628             MOV      R0,R5
   \   00000054   0x.... 0x....      BL       SAI_FillFifo
    791              
    792              /* Enable FRQ and OVRUDR interrupts */
    793              __HAL_SAI_ENABLE_IT(hsai, SAI_InterruptFlag(hsai, SAI_MODE_IT));
   \   00000058   0x2101             MOVS     R1,#+1
   \   0000005A   0x4628             MOV      R0,R5
   \   0000005C   0x.... 0x....      BL       SAI_InterruptFlag
   \   00000060   0x6829             LDR      R1,[R5, #+0]
   \   00000062   0x690A             LDR      R2,[R1, #+16]
   \   00000064   0x4310             ORRS     R0,R0,R2
   \   00000066   0x6108             STR      R0,[R1, #+16]
    794              
    795              /* Check if the SAI is already enabled */ 
    796              if((hsai->Instance->CR1 & SAI_xCR1_SAIEN) == RESET)
   \   00000068   0x6828             LDR      R0,[R5, #+0]
   \   0000006A   0x6801             LDR      R1,[R0, #+0]
   \   0000006C   0x03C9             LSLS     R1,R1,#+15
   \   0000006E   0xD403             BMI.N    ??HAL_SAI_Transmit_IT_6
    797              {      
    798                /* Enable SAI peripheral */    
    799                __HAL_SAI_ENABLE(hsai);
   \   00000070   0x6801             LDR      R1,[R0, #+0]
   \   00000072   0xF441 0x3180      ORR      R1,R1,#0x10000
   \   00000076   0x6001             STR      R1,[R0, #+0]
    800              }
    801              /* Process Unlocked */
    802              __HAL_UNLOCK(hsai);
   \                     ??HAL_SAI_Transmit_IT_6: (+1)
   \   00000078   0x....             B.N      ??Subroutine10_0
    803              
    804              return HAL_OK;
    805            }
    806            else
    807            {
    808              return HAL_BUSY;
   \                     ??HAL_SAI_Transmit_IT_1: (+1)
   \   0000007A   0x2002             MOVS     R0,#+2
   \   0000007C   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    809            }
    810          }

   \                                 In section .text, align 2, keep-with-next
   \                     ??Subroutine10_0: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x7520             STRB     R0,[R4, #+20]
   \   00000004   0xBD32             POP      {R1,R4,R5,PC}
    811          
    812          /**
    813            * @brief  Receives an amount of data in no-blocking mode with Interrupt.
    814            * @param  hsai: pointer to a SAI_HandleTypeDef structure that contains
    815            *                the configuration information for SAI module.
    816            * @param  pData: Pointer to data buffer
    817            * @param  Size: Amount of data to be received
    818            * @retval HAL status
    819            */

   \                                 In section .text, align 2, keep-with-next
    820          HAL_StatusTypeDef HAL_SAI_Receive_IT(SAI_HandleTypeDef *hsai, uint8_t *pData, uint16_t Size)
    821          {
    822              if((pData == NULL) || (Size == 0)) 
   \                     HAL_SAI_Receive_IT: (+1)
   \   00000000   0x2900             CMP      R1,#+0
   \   00000002   0xB410             PUSH     {R4}
   \   00000004   0xBF14             ITE      NE 
   \   00000006   0x2A00             CMPNE    R2,#+0
   \   00000008   0x2001             MOVEQ    R0,#+1
    823              {
    824                return  HAL_ERROR;
   \   0000000A   0xD047             BEQ.N    ??HAL_SAI_Receive_IT_0
    825              }
    826              
    827            if(hsai->State == HAL_SAI_STATE_READY)
   \   0000000C   0xF100 0x0368      ADD      R3,R0,#+104
   \   00000010   0x7D5C             LDRB     R4,[R3, #+21]
   \   00000012   0x2C01             CMP      R4,#+1
   \   00000014   0xD141             BNE.N    ??HAL_SAI_Receive_IT_1
    828            {   
    829              /* Process Locked */
    830              __HAL_LOCK(hsai);
   \   00000016   0x7D1C             LDRB     R4,[R3, #+20]
   \   00000018   0x2C01             CMP      R4,#+1
   \   0000001A   0xD03E             BEQ.N    ??HAL_SAI_Receive_IT_1
   \   0000001C   0x2401             MOVS     R4,#+1
   \   0000001E   0x751C             STRB     R4,[R3, #+20]
    831              
    832              hsai->pBuffPtr = pData;
   \   00000020   0x6641             STR      R1,[R0, #+100]
    833              hsai->XferSize = Size;
    834              hsai->XferCount = Size;
    835              hsai->ErrorCode = HAL_SAI_ERROR_NONE;    
   \   00000022   0x2100             MOVS     R1,#+0
   \   00000024   0x801A             STRH     R2,[R3, #+0]
   \   00000026   0x805A             STRH     R2,[R3, #+2]
   \   00000028   0x6199             STR      R1,[R3, #+24]
    836              hsai->State = HAL_SAI_STATE_BUSY_RX;
   \   0000002A   0x2122             MOVS     R1,#+34
   \   0000002C   0x7559             STRB     R1,[R3, #+21]
    837              
    838              if((hsai->Init.DataSize == SAI_DATASIZE_8) && (hsai->Init.CompandingMode == SAI_NOCOMPANDING))
   \   0000002E   0x6B41             LDR      R1,[R0, #+52]
   \   00000030   0x2940             CMP      R1,#+64
   \   00000032   0xD104             BNE.N    ??HAL_SAI_Receive_IT_2
   \   00000034   0x6A81             LDR      R1,[R0, #+40]
   \   00000036   0xB921             CBNZ.N   R1,??HAL_SAI_Receive_IT_3
    839              {
    840                hsai->InterruptServiceRoutine = SAI_Receive_IT8Bit;
   \   00000038   0x.... 0x....      ADR.W    R1,SAI_Receive_IT8Bit
   \   0000003C   0xE006             B.N      ??HAL_SAI_Receive_IT_4
    841              }
    842              else if(hsai->Init.DataSize <= SAI_DATASIZE_16)
   \                     ??HAL_SAI_Receive_IT_2: (+1)
   \   0000003E   0x2981             CMP      R1,#+129
   \   00000040   0xD202             BCS.N    ??HAL_SAI_Receive_IT_5
    843              {
    844                hsai->InterruptServiceRoutine = SAI_Receive_IT16Bit;
   \                     ??HAL_SAI_Receive_IT_3: (+1)
   \   00000042   0x.... 0x....      ADR.W    R1,SAI_Receive_IT16Bit
   \   00000046   0xE001             B.N      ??HAL_SAI_Receive_IT_4
    845              }
    846              else
    847              {
    848                hsai->InterruptServiceRoutine = SAI_Receive_IT32Bit;
   \                     ??HAL_SAI_Receive_IT_5: (+1)
   \   00000048   0x.... 0x....      ADR.W    R1,SAI_Receive_IT32Bit
   \                     ??HAL_SAI_Receive_IT_4: (+1)
   \   0000004C   0x6119             STR      R1,[R3, #+16]
    849              }
    850              
    851              /* Enable TXE and OVRUDR interrupts */
    852              __HAL_SAI_ENABLE_IT(hsai, SAI_InterruptFlag(hsai, SAI_MODE_IT));
   \   0000004E   0x6B02             LDR      R2,[R0, #+48]
   \   00000050   0x2109             MOVS     R1,#+9
   \   00000052   0x2A08             CMP      R2,#+8
   \   00000054   0xD119             BNE.N    ??HAL_SAI_Receive_IT_6
   \   00000056   0x6842             LDR      R2,[R0, #+4]
   \   00000058   0x2A03             CMP      R2,#+3
   \   0000005A   0xD112             BNE.N    ??HAL_SAI_Receive_IT_7
   \   0000005C   0x2119             MOVS     R1,#+25
   \                     ??HAL_SAI_Receive_IT_8: (+1)
   \   0000005E   0xF041 0x0160      ORR      R1,R1,#0x60
   \                     ??HAL_SAI_Receive_IT_9: (+1)
   \   00000062   0x6802             LDR      R2,[R0, #+0]
   \   00000064   0x6914             LDR      R4,[R2, #+16]
   \   00000066   0x4321             ORRS     R1,R1,R4
   \   00000068   0x6111             STR      R1,[R2, #+16]
    853              
    854              /* Check if the SAI is already enabled */ 
    855              if((hsai->Instance->CR1 & SAI_xCR1_SAIEN) == RESET)
   \   0000006A   0x6800             LDR      R0,[R0, #+0]
   \   0000006C   0x6801             LDR      R1,[R0, #+0]
   \   0000006E   0x03C9             LSLS     R1,R1,#+15
   \   00000070   0xD403             BMI.N    ??HAL_SAI_Receive_IT_10
    856              {
    857                /* Enable SAI peripheral */    
    858                __HAL_SAI_ENABLE(hsai);
   \   00000072   0x6801             LDR      R1,[R0, #+0]
   \   00000074   0xF441 0x3180      ORR      R1,R1,#0x10000
   \   00000078   0x6001             STR      R1,[R0, #+0]
    859              }
    860              
    861              /* Process Unlocked */
    862              __HAL_UNLOCK(hsai);
   \                     ??HAL_SAI_Receive_IT_10: (+1)
   \   0000007A   0x2000             MOVS     R0,#+0
   \   0000007C   0x7518             STRB     R0,[R3, #+20]
    863              
    864              return HAL_OK;
   \   0000007E   0xBC10             POP      {R4}
   \   00000080   0x4770             BX       LR
   \                     ??HAL_SAI_Receive_IT_7: (+1)
   \   00000082   0x2A01             CMP      R2,#+1
   \   00000084   0xBF08             IT       EQ 
   \   00000086   0x2119             MOVEQ    R1,#+25
   \   00000088   0xD004             BEQ.N    ??HAL_SAI_Receive_IT_11
   \                     ??HAL_SAI_Receive_IT_6: (+1)
   \   0000008A   0x6842             LDR      R2,[R0, #+4]
   \   0000008C   0x2A03             CMP      R2,#+3
   \   0000008E   0xBF18             IT       NE 
   \   00000090   0x2A02             CMPNE    R2,#+2
   \   00000092   0xD0E4             BEQ.N    ??HAL_SAI_Receive_IT_8
   \                     ??HAL_SAI_Receive_IT_11: (+1)
   \   00000094   0xF041 0x0104      ORR      R1,R1,#0x4
   \   00000098   0xE7E3             B.N      ??HAL_SAI_Receive_IT_9
    865            }
    866            else
    867            {
    868              return HAL_BUSY; 
   \                     ??HAL_SAI_Receive_IT_1: (+1)
   \   0000009A   0x2002             MOVS     R0,#+2
   \                     ??HAL_SAI_Receive_IT_0: (+1)
   \   0000009C   0xBC10             POP      {R4}
   \   0000009E   0x4770             BX       LR               ;; return
    869            } 
    870          }
    871          
    872          /**
    873            * @brief Pauses the audio stream playing from the Media.
    874            * @param  hsai: pointer to a SAI_HandleTypeDef structure that contains
    875            *                the configuration information for SAI module.
    876            * @retval HAL status
    877            */

   \                                 In section .text, align 2, keep-with-next
    878          HAL_StatusTypeDef HAL_SAI_DMAPause(SAI_HandleTypeDef *hsai)
    879          {
    880            /* Process Locked */
    881            __HAL_LOCK(hsai);
   \                     HAL_SAI_DMAPause: (+1)
   \   00000000   0xF890 0x107C      LDRB     R1,[R0, #+124]
   \   00000004   0x2901             CMP      R1,#+1
   \   00000006   0xD101             BNE.N    ??HAL_SAI_DMAPause_0
   \   00000008   0x2002             MOVS     R0,#+2
   \   0000000A   0x4770             BX       LR
   \                     ??HAL_SAI_DMAPause_0: (+1)
   \   0000000C   0x2101             MOVS     R1,#+1
   \   0000000E   0xF880 0x107C      STRB     R1,[R0, #+124]
    882            
    883            /* Pause the audio file playing by disabling the SAI DMA requests */
    884            hsai->Instance->CR1 &= ~SAI_xCR1_DMAEN;
   \   00000012   0x6801             LDR      R1,[R0, #+0]
   \   00000014   0x680A             LDR      R2,[R1, #+0]
   \   00000016   0xF422 0x3200      BIC      R2,R2,#0x20000
   \   0000001A   0x600A             STR      R2,[R1, #+0]
    885          
    886            /* Process Unlocked */
    887            __HAL_UNLOCK(hsai);
   \   0000001C   0x....             B.N      ?Subroutine6
    888            
    889            return HAL_OK; 
    890          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine6: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0xF880 0x107C      STRB     R1,[R0, #+124]
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x4770             BX       LR               ;; return
    891          
    892          /**
    893            * @brief Resumes the audio stream playing from the Media.
    894            * @param  hsai: pointer to a SAI_HandleTypeDef structure that contains
    895            *                the configuration information for SAI module.
    896            * @retval HAL status
    897            */

   \                                 In section .text, align 2, keep-with-next
    898          HAL_StatusTypeDef HAL_SAI_DMAResume(SAI_HandleTypeDef *hsai)
    899          {
    900            /* Process Locked */
    901            __HAL_LOCK(hsai);
   \                     HAL_SAI_DMAResume: (+1)
   \   00000000   0xF890 0x107C      LDRB     R1,[R0, #+124]
   \   00000004   0x2901             CMP      R1,#+1
   \   00000006   0xD101             BNE.N    ??HAL_SAI_DMAResume_0
   \   00000008   0x2002             MOVS     R0,#+2
   \   0000000A   0x4770             BX       LR
   \                     ??HAL_SAI_DMAResume_0: (+1)
   \   0000000C   0x2101             MOVS     R1,#+1
   \   0000000E   0xF880 0x107C      STRB     R1,[R0, #+124]
    902            
    903            /* Enable the SAI DMA requests */
    904            hsai->Instance->CR1 |= SAI_xCR1_DMAEN;
   \   00000012   0x6801             LDR      R1,[R0, #+0]
   \   00000014   0x680A             LDR      R2,[R1, #+0]
   \   00000016   0xF442 0x3200      ORR      R2,R2,#0x20000
   \   0000001A   0x600A             STR      R2,[R1, #+0]
    905          
    906            /* If the SAI peripheral is still not enabled, enable it */
    907            if ((hsai->Instance->CR1 & SAI_xCR1_SAIEN) == RESET)
   \   0000001C   0x680A             LDR      R2,[R1, #+0]
   \   0000001E   0x03D2             LSLS     R2,R2,#+15
   \   00000020   0xD403             BMI.N    ??HAL_SAI_DMAResume_1
    908            {
    909              /* Enable SAI peripheral */    
    910              __HAL_SAI_ENABLE(hsai);
   \   00000022   0x680A             LDR      R2,[R1, #+0]
   \   00000024   0xF442 0x3280      ORR      R2,R2,#0x10000
   \   00000028   0x600A             STR      R2,[R1, #+0]
    911            }
    912          
    913            /* Process Unlocked */
    914            __HAL_UNLOCK(hsai);
   \                     ??HAL_SAI_DMAResume_1: (+1)
   \   0000002A                      REQUIRE ?Subroutine6
   \   0000002A                      ;; // Fall through to label ?Subroutine6
    915            
    916            return HAL_OK;
    917          }
    918          
    919          /**
    920            * @brief Stops the audio stream playing from the Media.
    921            * @param  hsai : pointer to a SAI_HandleTypeDef structure that contains
    922            *                the configuration information for SAI module.
    923            * @retval HAL status
    924            */

   \                                 In section .text, align 2, keep-with-next
    925          HAL_StatusTypeDef HAL_SAI_DMAStop(SAI_HandleTypeDef *hsai)
    926          {
   \                     HAL_SAI_DMAStop: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4605             MOV      R5,R0
    927            /* Process Locked */
    928            __HAL_LOCK(hsai);
   \   00000004   0xF105 0x047C      ADD      R4,R5,#+124
   \   00000008   0x7820             LDRB     R0,[R4, #+0]
   \   0000000A   0x2801             CMP      R0,#+1
   \   0000000C   0xD101             BNE.N    ??HAL_SAI_DMAStop_0
   \   0000000E   0x2002             MOVS     R0,#+2
   \   00000010   0xBD32             POP      {R1,R4,R5,PC}
   \                     ??HAL_SAI_DMAStop_0: (+1)
   \   00000012   0x2001             MOVS     R0,#+1
   \   00000014   0x7020             STRB     R0,[R4, #+0]
    929            
    930            /* Disable the SAI DMA request */
    931            hsai->Instance->CR1 &= ~SAI_xCR1_DMAEN;
   \   00000016   0x6828             LDR      R0,[R5, #+0]
   \   00000018   0x6801             LDR      R1,[R0, #+0]
   \   0000001A   0xF421 0x3100      BIC      R1,R1,#0x20000
   \   0000001E   0x6001             STR      R1,[R0, #+0]
    932            
    933            /* Abort the SAI DMA Tx Stream */
    934            if(hsai->hdmatx != NULL)
   \   00000020   0x6EE8             LDR      R0,[R5, #+108]
   \   00000022   0xB110             CBZ.N    R0,??HAL_SAI_DMAStop_1
    935            {
    936              if(HAL_DMA_Abort(hsai->hdmatx) != HAL_OK)
   \   00000024   0x.... 0x....      BL       HAL_DMA_Abort
   \   00000028   0xB920             CBNZ.N   R0,??HAL_SAI_DMAStop_2
    937              {
    938                return HAL_ERROR;
    939              }
    940            }
    941            /* Abort the SAI DMA Rx Stream */
    942            if(hsai->hdmarx != NULL)
   \                     ??HAL_SAI_DMAStop_1: (+1)
   \   0000002A   0x6F28             LDR      R0,[R5, #+112]
   \   0000002C   0xB120             CBZ.N    R0,??HAL_SAI_DMAStop_3
    943            {  
    944              if(HAL_DMA_Abort(hsai->hdmarx) != HAL_OK)
   \   0000002E   0x.... 0x....      BL       HAL_DMA_Abort
   \   00000032   0xB108             CBZ.N    R0,??HAL_SAI_DMAStop_3
    945              {
    946                return HAL_ERROR;
   \                     ??HAL_SAI_DMAStop_2: (+1)
   \   00000034   0x2001             MOVS     R0,#+1
   \   00000036   0xBD32             POP      {R1,R4,R5,PC}
    947              }
    948            }
    949            
    950            /* Disable SAI peripheral */
    951            SAI_Disable(hsai);
   \                     ??HAL_SAI_DMAStop_3: (+1)
   \   00000038   0x4628             MOV      R0,R5
   \   0000003A   0x.... 0x....      BL       SAI_Disable
    952            
    953            hsai->State = HAL_SAI_STATE_READY;
   \   0000003E   0x2001             MOVS     R0,#+1
   \   00000040   0x7060             STRB     R0,[R4, #+1]
    954            
    955            /* Process Unlocked */
    956            __HAL_UNLOCK(hsai);
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0x7020             STRB     R0,[R4, #+0]
    957            
    958            return HAL_OK;
   \   00000046   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    959          }
    960          
    961          /**
    962            * @brief Abort the current transfer and disbaled the SAI.
    963            * @param  hsai : pointer to a SAI_HandleTypeDef structure that contains
    964            *                the configuration information for SAI module.
    965            * @retval HAL status
    966            */

   \                                 In section .text, align 2, keep-with-next
    967          HAL_StatusTypeDef HAL_SAI_Abort(SAI_HandleTypeDef *hsai)
    968          {
   \                     HAL_SAI_Abort: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    969            /* Disable the SAI DMA request */
    970            hsai->Instance->CR1 &= ~SAI_xCR1_DMAEN;
   \   00000004   0x6820             LDR      R0,[R4, #+0]
   \   00000006   0x6801             LDR      R1,[R0, #+0]
   \   00000008   0xF421 0x3100      BIC      R1,R1,#0x20000
   \   0000000C   0x6001             STR      R1,[R0, #+0]
    971            
    972            /* Abort the SAI DMA Tx Stream */
    973            if(hsai->hdmatx != NULL)
   \   0000000E   0x6EE0             LDR      R0,[R4, #+108]
   \   00000010   0xB110             CBZ.N    R0,??HAL_SAI_Abort_0
    974            {
    975              if(HAL_DMA_Abort(hsai->hdmatx) != HAL_OK)
   \   00000012   0x.... 0x....      BL       HAL_DMA_Abort
   \   00000016   0xB920             CBNZ.N   R0,??HAL_SAI_Abort_1
    976              {
    977                return HAL_ERROR;
    978              }
    979            }
    980            /* Abort the SAI DMA Rx Stream */
    981            if(hsai->hdmarx != NULL)
   \                     ??HAL_SAI_Abort_0: (+1)
   \   00000018   0x6F20             LDR      R0,[R4, #+112]
   \   0000001A   0xB120             CBZ.N    R0,??HAL_SAI_Abort_2
    982            {  
    983              if(HAL_DMA_Abort(hsai->hdmarx) != HAL_OK)
   \   0000001C   0x.... 0x....      BL       HAL_DMA_Abort
   \   00000020   0xB108             CBZ.N    R0,??HAL_SAI_Abort_2
    984              {
    985                return HAL_ERROR;
   \                     ??HAL_SAI_Abort_1: (+1)
   \   00000022   0x2001             MOVS     R0,#+1
   \   00000024   0xBD10             POP      {R4,PC}
    986              }
    987            }
    988          
    989            /* Disabled All interrupt and clear all the flag */
    990            hsai->Instance->IMR = 0;
   \                     ??HAL_SAI_Abort_2: (+1)
   \   00000026   0x6821             LDR      R1,[R4, #+0]
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0x6108             STR      R0,[R1, #+16]
    991            hsai->Instance->CLRFR = 0xFFFFFFFF;
   \   0000002C   0x6821             LDR      R1,[R4, #+0]
   \   0000002E   0xF04F 0x30FF      MOV      R0,#-1
   \   00000032   0x6188             STR      R0,[R1, #+24]
    992            
    993            /* Disable SAI peripheral */
    994            SAI_Disable(hsai);
   \   00000034   0x4620             MOV      R0,R4
   \   00000036   0x.... 0x....      BL       SAI_Disable
    995            
    996            /* Flush the fifo */
    997            SET_BIT(hsai->Instance->CR2, SAI_xCR2_FFLUSH);
   \   0000003A   0x6820             LDR      R0,[R4, #+0]
   \   0000003C   0x6841             LDR      R1,[R0, #+4]
   \   0000003E   0xF041 0x0108      ORR      R1,R1,#0x8
   \   00000042   0x6041             STR      R1,[R0, #+4]
    998            
    999            hsai->State = HAL_SAI_STATE_READY;
   \   00000044   0xF104 0x007C      ADD      R0,R4,#+124
   \   00000048   0x2101             MOVS     R1,#+1
   \   0000004A   0x7041             STRB     R1,[R0, #+1]
   1000            
   1001            /* Process Unlocked */
   1002            __HAL_UNLOCK(hsai);
   \   0000004C   0x2100             MOVS     R1,#+0
   \   0000004E   0x7001             STRB     R1,[R0, #+0]
   1003            
   1004            return HAL_OK;
   \   00000050   0x2000             MOVS     R0,#+0
   \   00000052   0xBD10             POP      {R4,PC}          ;; return
   1005          }
   1006          
   1007          /**
   1008            * @brief  Transmits an amount of data in no-blocking mode with DMA.
   1009            * @param  hsai: pointer to a SAI_HandleTypeDef structure that contains
   1010            *                the configuration information for SAI module.
   1011            * @param  pData: Pointer to data buffer
   1012            * @param  Size: Amount of data to be sent
   1013            * @retval HAL status
   1014            */

   \                                 In section .text, align 2, keep-with-next
   1015          HAL_StatusTypeDef HAL_SAI_Transmit_DMA(SAI_HandleTypeDef *hsai, uint8_t *pData, uint16_t Size)
   1016          {
   1017            uint32_t *tmp;
   1018            
   1019            if((pData == NULL) || (Size == 0)) 
   \                     HAL_SAI_Transmit_DMA: (+1)
   \   00000000   0x2900             CMP      R1,#+0
   \   00000002   0xB538             PUSH     {R3-R5,LR}
   \   00000004   0x4605             MOV      R5,R0
   \   00000006   0xBF18             IT       NE 
   \   00000008   0x2A00             CMPNE    R2,#+0
   \   0000000A   0xD101             BNE.N    ??HAL_SAI_Transmit_DMA_0
   1020            {
   1021              return  HAL_ERROR;
   \   0000000C   0x2001             MOVS     R0,#+1
   \   0000000E   0xBD32             POP      {R1,R4,R5,PC}
   1022            }
   1023            
   1024            if(hsai->State == HAL_SAI_STATE_READY)
   \                     ??HAL_SAI_Transmit_DMA_0: (+1)
   \   00000010   0xF105 0x0468      ADD      R4,R5,#+104
   \   00000014   0x7D60             LDRB     R0,[R4, #+21]
   \   00000016   0x2801             CMP      R0,#+1
   \   00000018   0xD13D             BNE.N    ??HAL_SAI_Transmit_DMA_1
   1025            {  
   1026              /* Process Locked */
   1027              __HAL_LOCK(hsai);
   \   0000001A   0x7D20             LDRB     R0,[R4, #+20]
   \   0000001C   0x2801             CMP      R0,#+1
   \   0000001E   0xD03A             BEQ.N    ??HAL_SAI_Transmit_DMA_1
   \   00000020   0x2001             MOVS     R0,#+1
   \   00000022   0x7520             STRB     R0,[R4, #+20]
   1028              
   1029              hsai->pBuffPtr = pData;
   1030              hsai->XferSize = Size;
   1031              hsai->XferCount = Size;
   1032              hsai->ErrorCode = HAL_SAI_ERROR_NONE;
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0x6669             STR      R1,[R5, #+100]
   \   00000028   0x8022             STRH     R2,[R4, #+0]
   \   0000002A   0x8062             STRH     R2,[R4, #+2]
   \   0000002C   0x61A0             STR      R0,[R4, #+24]
   1033              hsai->State = HAL_SAI_STATE_BUSY_TX;
   \   0000002E   0x2012             MOVS     R0,#+18
   \   00000030   0x7560             STRB     R0,[R4, #+21]
   1034              
   1035              /* Set the SAI Tx DMA Half transfer complete callback */
   1036              hsai->hdmatx->XferHalfCpltCallback = SAI_DMATxHalfCplt;
   \   00000032   0x6862             LDR      R2,[R4, #+4]
   \   00000034   0x.... 0x....      ADR.W    R0,SAI_DMATxHalfCplt
   \   00000038   0x6410             STR      R0,[R2, #+64]
   1037              
   1038              /* Set the SAI TxDMA transfer complete callback */
   1039              hsai->hdmatx->XferCpltCallback = SAI_DMATxCplt;
   \   0000003A   0x6862             LDR      R2,[R4, #+4]
   \   0000003C   0x.... 0x....      ADR.W    R0,SAI_DMATxCplt
   \   00000040   0x63D0             STR      R0,[R2, #+60]
   1040              
   1041              /* Set the DMA error callback */
   1042              hsai->hdmatx->XferErrorCallback = SAI_DMAError;
   \   00000042   0x6862             LDR      R2,[R4, #+4]
   \   00000044   0x.... 0x....      ADR.W    R0,SAI_DMAError
   \   00000048   0x6490             STR      R0,[R2, #+72]
   1043              
   1044              /* Enable the Tx DMA Stream */
   1045              tmp = (uint32_t*)&pData;
   1046              HAL_DMA_Start_IT(hsai->hdmatx, *(uint32_t*)tmp, (uint32_t)&hsai->Instance->DR, hsai->XferSize);
   \   0000004A   0x6828             LDR      R0,[R5, #+0]
   \   0000004C   0x8823             LDRH     R3,[R4, #+0]
   \   0000004E   0xF100 0x021C      ADD      R2,R0,#+28
   \   00000052   0x6860             LDR      R0,[R4, #+4]
   \   00000054   0x.... 0x....      BL       HAL_DMA_Start_IT
   1047              
   1048              /* Check if the SAI is already enabled */ 
   1049              if((hsai->Instance->CR1 & SAI_xCR1_SAIEN) == RESET)
   \   00000058   0x6828             LDR      R0,[R5, #+0]
   \   0000005A   0x6801             LDR      R1,[R0, #+0]
   \   0000005C   0x03C9             LSLS     R1,R1,#+15
   \   0000005E   0xD403             BMI.N    ??HAL_SAI_Transmit_DMA_2
   1050              {
   1051                /* Enable SAI peripheral */
   1052                __HAL_SAI_ENABLE(hsai);
   \   00000060   0x6801             LDR      R1,[R0, #+0]
   \   00000062   0xF441 0x3180      ORR      R1,R1,#0x10000
   \   00000066   0x6001             STR      R1,[R0, #+0]
   1053              }
   1054              
   1055              /* Enable the interrupts for error handling */
   1056              __HAL_SAI_ENABLE_IT(hsai, SAI_InterruptFlag(hsai, SAI_MODE_DMA));
   \                     ??HAL_SAI_Transmit_DMA_2: (+1)
   \   00000068   0x6B29             LDR      R1,[R5, #+48]
   \   0000006A   0x2001             MOVS     R0,#+1
   \   0000006C   0x2908             CMP      R1,#+8
   \   0000006E   0xD10A             BNE.N    ??HAL_SAI_Transmit_DMA_3
   \   00000070   0x6869             LDR      R1,[R5, #+4]
   \   00000072   0x2903             CMP      R1,#+3
   \   00000074   0xD103             BNE.N    ??HAL_SAI_Transmit_DMA_4
   \   00000076   0x2011             MOVS     R0,#+17
   \                     ??HAL_SAI_Transmit_DMA_5: (+1)
   \   00000078   0xF040 0x0060      ORR      R0,R0,#0x60
   \                     ??HAL_SAI_Transmit_DMA_6: (+1)
   \   0000007C   0x....             B.N      ?Subroutine5
   \                     ??HAL_SAI_Transmit_DMA_4: (+1)
   \   0000007E   0x2901             CMP      R1,#+1
   \   00000080   0xBF08             IT       EQ 
   \   00000082   0x2011             MOVEQ    R0,#+17
   \   00000084   0xD004             BEQ.N    ??HAL_SAI_Transmit_DMA_7
   \                     ??HAL_SAI_Transmit_DMA_3: (+1)
   \   00000086   0x6869             LDR      R1,[R5, #+4]
   \   00000088   0x2903             CMP      R1,#+3
   \   0000008A   0xBF18             IT       NE 
   \   0000008C   0x2902             CMPNE    R1,#+2
   \   0000008E   0xD0F3             BEQ.N    ??HAL_SAI_Transmit_DMA_5
   \                     ??HAL_SAI_Transmit_DMA_7: (+1)
   \   00000090   0xF040 0x0004      ORR      R0,R0,#0x4
   \   00000094   0xE7F2             B.N      ??HAL_SAI_Transmit_DMA_6
   1057              
   1058              /* Enable SAI Tx DMA Request */  
   1059              hsai->Instance->CR1 |= SAI_xCR1_DMAEN;
   1060              
   1061              /* Process Unlocked */
   1062              __HAL_UNLOCK(hsai);
   1063              
   1064              return HAL_OK;
   1065            }
   1066            else
   1067            {
   1068              return HAL_BUSY;
   \                     ??HAL_SAI_Transmit_DMA_1: (+1)
   \   00000096   0x2002             MOVS     R0,#+2
   \   00000098   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1069            }
   1070          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine5: (+1)
   \   00000000   0x6829             LDR      R1,[R5, #+0]
   \   00000002   0x690A             LDR      R2,[R1, #+16]
   \   00000004   0x4310             ORRS     R0,R0,R2
   \   00000006   0x6108             STR      R0,[R1, #+16]
   \   00000008   0x6828             LDR      R0,[R5, #+0]
   \   0000000A   0x6801             LDR      R1,[R0, #+0]
   \   0000000C   0xF441 0x3100      ORR      R1,R1,#0x20000
   \   00000010   0x6001             STR      R1,[R0, #+0]
   \   00000012                      REQUIRE ??Subroutine10_0
   \   00000012                      ;; // Fall through to label ??Subroutine10_0
   1071          
   1072          /**
   1073            * @brief  Receives an amount of data in no-blocking mode with DMA. 
   1074            * @param  hsai: pointer to a SAI_HandleTypeDef structure that contains
   1075            *                the configuration information for SAI module.
   1076            * @param  pData: Pointer to data buffer
   1077            * @param  Size: Amount of data to be received
   1078            * @retval HAL status
   1079            */

   \                                 In section .text, align 2, keep-with-next
   1080          HAL_StatusTypeDef HAL_SAI_Receive_DMA(SAI_HandleTypeDef *hsai, uint8_t *pData, uint16_t Size)
   1081          {
   1082            uint32_t *tmp;
   1083            
   1084            if((pData == NULL) || (Size == 0))
   \                     HAL_SAI_Receive_DMA: (+1)
   \   00000000   0x2900             CMP      R1,#+0
   \   00000002   0xB538             PUSH     {R3-R5,LR}
   \   00000004   0x4605             MOV      R5,R0
   \   00000006   0xBF18             IT       NE 
   \   00000008   0x2A00             CMPNE    R2,#+0
   \   0000000A   0xD101             BNE.N    ??HAL_SAI_Receive_DMA_0
   1085            {
   1086              return  HAL_ERROR;
   \   0000000C   0x2001             MOVS     R0,#+1
   \   0000000E   0xBD32             POP      {R1,R4,R5,PC}
   1087            } 
   1088            
   1089            if(hsai->State == HAL_SAI_STATE_READY)
   \                     ??HAL_SAI_Receive_DMA_0: (+1)
   \   00000010   0xF105 0x0468      ADD      R4,R5,#+104
   \   00000014   0x7D60             LDRB     R0,[R4, #+21]
   \   00000016   0x2801             CMP      R0,#+1
   \   00000018   0xD13E             BNE.N    ??HAL_SAI_Receive_DMA_1
   1090            {   
   1091              /* Process Locked */
   1092              __HAL_LOCK(hsai);
   \   0000001A   0x7D20             LDRB     R0,[R4, #+20]
   \   0000001C   0x2801             CMP      R0,#+1
   \   0000001E   0xD03B             BEQ.N    ??HAL_SAI_Receive_DMA_1
   \   00000020   0x2001             MOVS     R0,#+1
   \   00000022   0x7520             STRB     R0,[R4, #+20]
   1093              
   1094              hsai->pBuffPtr = pData;
   1095              hsai->XferSize = Size;
   1096              hsai->XferCount = Size;
   1097              hsai->ErrorCode = HAL_SAI_ERROR_NONE;    
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0x6669             STR      R1,[R5, #+100]
   \   00000028   0x8022             STRH     R2,[R4, #+0]
   \   0000002A   0x8062             STRH     R2,[R4, #+2]
   \   0000002C   0x61A0             STR      R0,[R4, #+24]
   1098              hsai->State = HAL_SAI_STATE_BUSY_RX;
   \   0000002E   0x2022             MOVS     R0,#+34
   \   00000030   0x7560             STRB     R0,[R4, #+21]
   1099              
   1100              /* Set the SAI Rx DMA Half transfer complete callback */
   1101              hsai->hdmarx->XferHalfCpltCallback = SAI_DMARxHalfCplt;
   \   00000032   0x68A2             LDR      R2,[R4, #+8]
   \   00000034   0x.... 0x....      ADR.W    R0,SAI_DMARxHalfCplt
   \   00000038   0x6410             STR      R0,[R2, #+64]
   1102              
   1103              /* Set the SAI Rx DMA transfer complete callback */
   1104              hsai->hdmarx->XferCpltCallback = SAI_DMARxCplt;
   \   0000003A   0x68A2             LDR      R2,[R4, #+8]
   \   0000003C   0x.... 0x....      ADR.W    R0,SAI_DMARxCplt
   \   00000040   0x63D0             STR      R0,[R2, #+60]
   1105              
   1106              /* Set the DMA error callback */
   1107              hsai->hdmarx->XferErrorCallback = SAI_DMAError;
   \   00000042   0x68A2             LDR      R2,[R4, #+8]
   \   00000044   0x.... 0x....      ADR.W    R0,SAI_DMAError
   \   00000048   0x6490             STR      R0,[R2, #+72]
   1108              
   1109              /* Enable the Rx DMA Stream */
   1110              tmp = (uint32_t*)&pData;
   1111              HAL_DMA_Start_IT(hsai->hdmarx, (uint32_t)&hsai->Instance->DR, *(uint32_t*)tmp, hsai->XferSize);
   \   0000004A   0x6828             LDR      R0,[R5, #+0]
   \   0000004C   0x460A             MOV      R2,R1
   \   0000004E   0x8823             LDRH     R3,[R4, #+0]
   \   00000050   0xF100 0x011C      ADD      R1,R0,#+28
   \   00000054   0x68A0             LDR      R0,[R4, #+8]
   \   00000056   0x.... 0x....      BL       HAL_DMA_Start_IT
   1112              
   1113              /* Check if the SAI is already enabled */
   1114              if((hsai->Instance->CR1 & SAI_xCR1_SAIEN) == RESET)
   \   0000005A   0x6828             LDR      R0,[R5, #+0]
   \   0000005C   0x6801             LDR      R1,[R0, #+0]
   \   0000005E   0x03C9             LSLS     R1,R1,#+15
   \   00000060   0xD403             BMI.N    ??HAL_SAI_Receive_DMA_2
   1115              {
   1116                /* Enable SAI peripheral */
   1117                __HAL_SAI_ENABLE(hsai);
   \   00000062   0x6801             LDR      R1,[R0, #+0]
   \   00000064   0xF441 0x3180      ORR      R1,R1,#0x10000
   \   00000068   0x6001             STR      R1,[R0, #+0]
   1118              }
   1119              
   1120              /* Enable the interrupts for error handling */
   1121              __HAL_SAI_ENABLE_IT(hsai, SAI_InterruptFlag(hsai, SAI_MODE_DMA));
   \                     ??HAL_SAI_Receive_DMA_2: (+1)
   \   0000006A   0x6B29             LDR      R1,[R5, #+48]
   \   0000006C   0x2001             MOVS     R0,#+1
   \   0000006E   0x2908             CMP      R1,#+8
   \   00000070   0xD10A             BNE.N    ??HAL_SAI_Receive_DMA_3
   \   00000072   0x6869             LDR      R1,[R5, #+4]
   \   00000074   0x2903             CMP      R1,#+3
   \   00000076   0xD103             BNE.N    ??HAL_SAI_Receive_DMA_4
   \   00000078   0x2011             MOVS     R0,#+17
   \                     ??HAL_SAI_Receive_DMA_5: (+1)
   \   0000007A   0xF040 0x0060      ORR      R0,R0,#0x60
   \                     ??HAL_SAI_Receive_DMA_6: (+1)
   \   0000007E   0x....             B.N      ?Subroutine5
   \                     ??HAL_SAI_Receive_DMA_4: (+1)
   \   00000080   0x2901             CMP      R1,#+1
   \   00000082   0xBF08             IT       EQ 
   \   00000084   0x2011             MOVEQ    R0,#+17
   \   00000086   0xD004             BEQ.N    ??HAL_SAI_Receive_DMA_7
   \                     ??HAL_SAI_Receive_DMA_3: (+1)
   \   00000088   0x6869             LDR      R1,[R5, #+4]
   \   0000008A   0x2903             CMP      R1,#+3
   \   0000008C   0xBF18             IT       NE 
   \   0000008E   0x2902             CMPNE    R1,#+2
   \   00000090   0xD0F3             BEQ.N    ??HAL_SAI_Receive_DMA_5
   \                     ??HAL_SAI_Receive_DMA_7: (+1)
   \   00000092   0xF040 0x0004      ORR      R0,R0,#0x4
   \   00000096   0xE7F2             B.N      ??HAL_SAI_Receive_DMA_6
   1122              
   1123              /* Enable SAI Rx DMA Request */
   1124              hsai->Instance->CR1 |= SAI_xCR1_DMAEN;
   1125              
   1126              /* Process Unlocked */
   1127              __HAL_UNLOCK(hsai);
   1128              
   1129              return HAL_OK;
   1130            }
   1131            else
   1132            {
   1133              return HAL_BUSY;
   \                     ??HAL_SAI_Receive_DMA_1: (+1)
   \   00000098   0x2002             MOVS     R0,#+2
   \   0000009A   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1134            }
   1135          }
   1136          
   1137          /**
   1138            * @brief  Enable the tx mute mode.
   1139            * @param  hsai : pointer to a SAI_HandleTypeDef structure that contains
   1140            *                the configuration information for SAI module.
   1141            * @param  val :  value sent during the mute @ref SAI_Block_Mute_Value
   1142            * @retval HAL status
   1143            */

   \                                 In section .text, align 2, keep-with-next
   1144          HAL_StatusTypeDef HAL_SAI_EnableTxMuteMode(SAI_HandleTypeDef *hsai, uint16_t val)
   1145          {
   1146            assert_param(IS_SAI_BLOCK_MUTE_VALUE(val));
   1147            
   1148            if(hsai->State != HAL_SAI_STATE_RESET)
   \                     HAL_SAI_EnableTxMuteMode: (+1)
   \   00000000   0xF890 0x207D      LDRB     R2,[R0, #+125]
   \   00000004   0xB152             CBZ.N    R2,??HAL_SAI_EnableTxMuteMode_0
   1149            {
   1150              CLEAR_BIT(hsai->Instance->CR2, SAI_xCR2_MUTEVAL | SAI_xCR2_MUTE);
   \   00000006   0x6802             LDR      R2,[R0, #+0]
   1151              SET_BIT(hsai->Instance->CR2, SAI_xCR2_MUTE | val);
   \   00000008   0xF041 0x0120      ORR      R1,R1,#0x20
   \   0000000C   0x6853             LDR      R3,[R2, #+4]
   \   0000000E   0xF023 0x0360      BIC      R3,R3,#0x60
   \   00000012   0x6053             STR      R3,[R2, #+4]
   \   00000014   0x6800             LDR      R0,[R0, #+0]
   \   00000016   0x6842             LDR      R2,[R0, #+4]
   \   00000018   0x4311             ORRS     R1,R1,R2
   \   0000001A   0x....             B.N      ?Subroutine7
   1152              return HAL_OK;
   1153            }
   1154            return HAL_ERROR;
   \                     ??HAL_SAI_EnableTxMuteMode_0: (+1)
   \   0000001C   0x2001             MOVS     R0,#+1
   \   0000001E   0x4770             BX       LR               ;; return
   1155          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine7: (+1)
   \   00000000   0x6041             STR      R1,[R0, #+4]
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0x4770             BX       LR
   1156          
   1157          /**
   1158            * @brief  Disable the tx mute mode.
   1159            * @param  hsai : pointer to a SAI_HandleTypeDef structure that contains
   1160            *                the configuration information for SAI module.
   1161            * @retval HAL status
   1162            */

   \                                 In section .text, align 2, keep-with-next
   1163          HAL_StatusTypeDef HAL_SAI_DisableTxMuteMode(SAI_HandleTypeDef *hsai)
   1164          {
   1165            if(hsai->State != HAL_SAI_STATE_RESET)
   \                     HAL_SAI_DisableTxMuteMode: (+1)
   \   00000000   0xF890 0x107D      LDRB     R1,[R0, #+125]
   \   00000004   0xB121             CBZ.N    R1,??HAL_SAI_DisableTxMuteMode_0
   1166            {
   1167              CLEAR_BIT(hsai->Instance->CR2, SAI_xCR2_MUTEVAL | SAI_xCR2_MUTE);
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0x6841             LDR      R1,[R0, #+4]
   \   0000000A   0xF021 0x0160      BIC      R1,R1,#0x60
   \   0000000E   0x....             B.N      ?Subroutine7
   1168              return HAL_OK;
   1169            }
   1170            return HAL_ERROR;
   \                     ??HAL_SAI_DisableTxMuteMode_0: (+1)
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0x4770             BX       LR               ;; return
   1171          }
   1172          
   1173          /**
   1174            * @brief  Enable the rx mute detection.
   1175            * @param  hsai : pointer to a SAI_HandleTypeDef structure that contains
   1176            *                the configuration information for SAI module.
   1177            * @param  callback : function called when the mute is detected
   1178            * @param  counter : number a data before mute detection max 63.
   1179            * @retval HAL status
   1180            */

   \                                 In section .text, align 2, keep-with-next
   1181          HAL_StatusTypeDef HAL_SAI_EnableRxMuteMode(SAI_HandleTypeDef *hsai, SAIcallback callback, uint16_t counter)
   1182          {
   \                     HAL_SAI_EnableRxMuteMode: (+1)
   \   00000000   0xB410             PUSH     {R4}
   1183            assert_param(IS_SAI_BLOCK_MUTE_COUNTER(counter));
   1184            
   1185            if(hsai->State != HAL_SAI_STATE_RESET)
   \   00000002   0xF890 0x307D      LDRB     R3,[R0, #+125]
   \   00000006   0xB183             CBZ.N    R3,??HAL_SAI_EnableRxMuteMode_0
   1186            {
   1187              /* set the mute counter */
   1188              CLEAR_BIT(hsai->Instance->CR2, SAI_xCR2_MUTECNT);
   \   00000008   0x6803             LDR      R3,[R0, #+0]
   \   0000000A   0x685C             LDR      R4,[R3, #+4]
   \   0000000C   0xF424 0x54FC      BIC      R4,R4,#0x1F80
   \   00000010   0x605C             STR      R4,[R3, #+4]
   1189              SET_BIT(hsai->Instance->CR2, (uint32_t)((uint32_t)counter << SAI_xCR2_MUTECNT_OFFSET));
   \   00000012   0x6803             LDR      R3,[R0, #+0]
   \   00000014   0x685C             LDR      R4,[R3, #+4]
   \   00000016   0xEA44 0x12C2      ORR      R2,R4,R2, LSL #+7
   \   0000001A   0x605A             STR      R2,[R3, #+4]
   1190              hsai->mutecallback = callback;
   \   0000001C   0x6741             STR      R1,[R0, #+116]
   1191              /* enable the IT interrupt */
   1192              __HAL_SAI_ENABLE_IT(hsai, SAI_IT_MUTEDET);
   \   0000001E   0x6800             LDR      R0,[R0, #+0]
   \   00000020   0x6901             LDR      R1,[R0, #+16]
   \   00000022   0xF041 0x0102      ORR      R1,R1,#0x2
   \   00000026   0x6101             STR      R1,[R0, #+16]
   1193              return HAL_OK;
   \   00000028   0x....             B.N      ?Subroutine9
   1194            }
   1195            return HAL_ERROR;
   \                     ??HAL_SAI_EnableRxMuteMode_0: (+1)
   \   0000002A                      REQUIRE ?Subroutine8
   \   0000002A                      ;; // Fall through to label ?Subroutine8
   1196          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine8: (+1)
   \   00000000   0x2001             MOVS     R0,#+1
   \   00000002   0xBC10             POP      {R4}
   \   00000004   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine9: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0xBC10             POP      {R4}
   \   00000004   0x4770             BX       LR
   1197          
   1198          /**
   1199            * @brief  Disable the rx mute detection.
   1200            * @param  hsai : pointer to a SAI_HandleTypeDef structure that contains
   1201            *                the configuration information for SAI module.
   1202            * @retval HAL status
   1203            */

   \                                 In section .text, align 2, keep-with-next
   1204          HAL_StatusTypeDef HAL_SAI_DisableRxMuteMode(SAI_HandleTypeDef *hsai)
   1205          {
   1206            if(hsai->State != HAL_SAI_STATE_RESET)
   \                     HAL_SAI_DisableRxMuteMode: (+1)
   \   00000000   0xF890 0x107D      LDRB     R1,[R0, #+125]
   \   00000004   0xB141             CBZ.N    R1,??HAL_SAI_DisableRxMuteMode_0
   1207            {
   1208              /* set the mutecallback to NULL */
   1209              hsai->mutecallback = (SAIcallback)NULL;
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x6741             STR      R1,[R0, #+116]
   1210              /* enable the IT interrupt */
   1211              __HAL_SAI_DISABLE_IT(hsai, SAI_IT_MUTEDET);
   \   0000000A   0x6800             LDR      R0,[R0, #+0]
   \   0000000C   0x6901             LDR      R1,[R0, #+16]
   \   0000000E   0xF021 0x0102      BIC      R1,R1,#0x2
   \   00000012   0x6101             STR      R1,[R0, #+16]
   1212              return HAL_OK;
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0x4770             BX       LR
   1213            }
   1214            return HAL_ERROR;
   \                     ??HAL_SAI_DisableRxMuteMode_0: (+1)
   \   00000018   0x2001             MOVS     R0,#+1
   \   0000001A   0x4770             BX       LR               ;; return
   1215          }
   1216          
   1217          /**
   1218            * @brief  This function handles SAI interrupt request.
   1219            * @param  hsai: pointer to a SAI_HandleTypeDef structure that contains
   1220            *                the configuration information for SAI module.
   1221            * @retval HAL status
   1222            */

   \                                 In section .text, align 2, keep-with-next
   1223          void HAL_SAI_IRQHandler(SAI_HandleTypeDef *hsai)
   1224          { 
   \                     HAL_SAI_IRQHandler: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   1225            if(hsai->State != HAL_SAI_STATE_RESET)
   \   00000004   0xF894 0x007D      LDRB     R0,[R4, #+125]
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD05D             BEQ.N    ??HAL_SAI_IRQHandler_0
   1226            {
   1227              uint32_t tmpFlag = hsai->Instance->SR;
   \   0000000C   0x6820             LDR      R0,[R4, #+0]
   \   0000000E   0x6945             LDR      R5,[R0, #+20]
   1228              uint32_t tmpItSource = hsai->Instance->IMR; 
   \   00000010   0x6906             LDR      R6,[R0, #+16]
   1229              
   1230              if(((tmpFlag & SAI_xSR_FREQ) == SAI_xSR_FREQ) && ((tmpItSource & SAI_IT_FREQ) == SAI_IT_FREQ))
   \   00000012   0x0728             LSLS     R0,R5,#+28
   \   00000014   0xD504             BPL.N    ??HAL_SAI_IRQHandler_1
   \   00000016   0x0730             LSLS     R0,R6,#+28
   \   00000018   0xD502             BPL.N    ??HAL_SAI_IRQHandler_1
   1231              {
   1232                hsai->InterruptServiceRoutine(hsai);
   \   0000001A   0x6FA1             LDR      R1,[R4, #+120]
   \   0000001C   0x4620             MOV      R0,R4
   \   0000001E   0x4788             BLX      R1
   1233              }
   1234              
   1235              /* check the flag only if one of them is set */
   1236              if(tmpFlag != 0x00000000)
   \                     ??HAL_SAI_IRQHandler_1: (+1)
   \   00000020   0x2D00             CMP      R5,#+0
   \   00000022   0xD051             BEQ.N    ??HAL_SAI_IRQHandler_0
   1237              {
   1238                /* SAI Overrun error interrupt occurred ----------------------------------*/
   1239                if(((tmpFlag & SAI_FLAG_OVRUDR) == SAI_FLAG_OVRUDR) && ((tmpItSource & SAI_IT_OVRUDR) == SAI_IT_OVRUDR))
   \   00000024   0xF005 0x0001      AND      R0,R5,#0x1
   \   00000028   0xF006 0x0101      AND      R1,R6,#0x1
   \   0000002C   0x4208             TST      R0,R1
   \   0000002E   0xD00D             BEQ.N    ??HAL_SAI_IRQHandler_2
   1240                {
   1241                  /* Clear the SAI Overrun flag */
   1242                  __HAL_SAI_CLEAR_FLAG(hsai, SAI_FLAG_OVRUDR);
   \   00000030   0x6821             LDR      R1,[R4, #+0]
   \   00000032   0x2001             MOVS     R0,#+1
   \   00000034   0x6188             STR      R0,[R1, #+24]
   1243                  /* Change the SAI error code */
   1244                  hsai->ErrorCode = ((hsai->State == HAL_SAI_STATE_BUSY_RX) ? HAL_SAI_ERROR_OVR : HAL_SAI_ERROR_UDR);
   \   00000036   0xF894 0x007D      LDRB     R0,[R4, #+125]
   \   0000003A   0x2822             CMP      R0,#+34
   \   0000003C   0xBF0C             ITE      EQ 
   \   0000003E   0x2001             MOVEQ    R0,#+1
   \   00000040   0x2002             MOVNE    R0,#+2
   \   00000042   0xF8C4 0x0080      STR      R0,[R4, #+128]
   1245                  /* the transfer is not stopped, we will forward the information to the user and we let the user decide what needs to be done */
   1246                  HAL_SAI_ErrorCallback(hsai);
   \   00000046   0x4620             MOV      R0,R4
   \   00000048   0x.... 0x....      BL       HAL_SAI_ErrorCallback
   1247                }
   1248                
   1249                /* SAI mutedet interrupt occurred ----------------------------------*/
   1250                if(((tmpFlag & SAI_FLAG_MUTEDET) == SAI_FLAG_MUTEDET) && ((tmpItSource & SAI_IT_MUTEDET) == SAI_IT_MUTEDET))
   \                     ??HAL_SAI_IRQHandler_2: (+1)
   \   0000004C   0x07A8             LSLS     R0,R5,#+30
   \   0000004E   0xD508             BPL.N    ??HAL_SAI_IRQHandler_3
   \   00000050   0x07B0             LSLS     R0,R6,#+30
   \   00000052   0xD506             BPL.N    ??HAL_SAI_IRQHandler_3
   1251                {
   1252                  /* Clear the SAI mutedet flag */
   1253                  __HAL_SAI_CLEAR_FLAG(hsai, SAI_FLAG_MUTEDET);
   \   00000054   0x6821             LDR      R1,[R4, #+0]
   \   00000056   0x2002             MOVS     R0,#+2
   \   00000058   0x6188             STR      R0,[R1, #+24]
   1254                  /* call the call back function */
   1255                  if(hsai->mutecallback != (SAIcallback)NULL)
   \   0000005A   0x6F60             LDR      R0,[R4, #+116]
   \   0000005C   0x0001             MOVS     R1,R0
   \   0000005E   0xBF18             IT       NE 
   1256                  {
   1257                    /* inform the user that an RX mute event has been detected */
   1258                    hsai->mutecallback();
   \   00000060   0x4780             BLXNE    R0
   1259                  }
   1260                }
   1261                
   1262                /* SAI AFSDET interrupt occurred ----------------------------------*/
   1263                if(((tmpFlag & SAI_FLAG_AFSDET) == SAI_FLAG_AFSDET) && ((tmpItSource & SAI_IT_AFSDET) == SAI_IT_AFSDET))
   \                     ??HAL_SAI_IRQHandler_3: (+1)
   \   00000062   0x06A8             LSLS     R0,R5,#+26
   \   00000064   0xD50A             BPL.N    ??HAL_SAI_IRQHandler_4
   \   00000066   0x06B0             LSLS     R0,R6,#+26
   \   00000068   0xD508             BPL.N    ??HAL_SAI_IRQHandler_4
   1264                {
   1265                  /* Change the SAI error code */
   1266                  hsai->ErrorCode = HAL_SAI_ERROR_AFSDET;
   \   0000006A   0x2004             MOVS     R0,#+4
   \   0000006C   0xF8C4 0x0080      STR      R0,[R4, #+128]
   1267                  HAL_SAI_Abort(hsai);
   \   00000070   0x4620             MOV      R0,R4
   \   00000072   0x.... 0x....      BL       HAL_SAI_Abort
   1268                  HAL_SAI_ErrorCallback(hsai);
   \   00000076   0x4620             MOV      R0,R4
   \   00000078   0x.... 0x....      BL       HAL_SAI_ErrorCallback
   1269                }
   1270                
   1271                /* SAI LFSDET interrupt occurred ----------------------------------*/
   1272                if(((tmpFlag & SAI_FLAG_LFSDET) == SAI_FLAG_LFSDET) && ((tmpItSource & SAI_IT_LFSDET) == SAI_IT_LFSDET))
   \                     ??HAL_SAI_IRQHandler_4: (+1)
   \   0000007C   0x0668             LSLS     R0,R5,#+25
   \   0000007E   0xD50A             BPL.N    ??HAL_SAI_IRQHandler_5
   \   00000080   0x0670             LSLS     R0,R6,#+25
   \   00000082   0xD508             BPL.N    ??HAL_SAI_IRQHandler_5
   1273                {
   1274                  /* Change the SAI error code */
   1275                  hsai->ErrorCode = HAL_SAI_ERROR_LFSDET;
   \   00000084   0x2008             MOVS     R0,#+8
   \   00000086   0xF8C4 0x0080      STR      R0,[R4, #+128]
   1276                  HAL_SAI_Abort(hsai);
   \   0000008A   0x4620             MOV      R0,R4
   \   0000008C   0x.... 0x....      BL       HAL_SAI_Abort
   1277                  HAL_SAI_ErrorCallback(hsai);
   \   00000090   0x4620             MOV      R0,R4
   \   00000092   0x.... 0x....      BL       HAL_SAI_ErrorCallback
   1278                }
   1279          
   1280                /* SAI WCKCFG interrupt occurred ----------------------------------*/
   1281                if(((tmpFlag & SAI_FLAG_WCKCFG) == SAI_FLAG_WCKCFG) && ((tmpItSource & SAI_IT_WCKCFG) == SAI_IT_WCKCFG))
   \                     ??HAL_SAI_IRQHandler_5: (+1)
   \   00000096   0x0768             LSLS     R0,R5,#+29
   \   00000098   0xD50A             BPL.N    ??HAL_SAI_IRQHandler_6
   \   0000009A   0x0770             LSLS     R0,R6,#+29
   \   0000009C   0xD508             BPL.N    ??HAL_SAI_IRQHandler_6
   1282                {
   1283                  /* Change the SAI error code */
   1284                  hsai->ErrorCode = HAL_SAI_ERROR_WCKCFG;
   \   0000009E   0x2020             MOVS     R0,#+32
   \   000000A0   0xF8C4 0x0080      STR      R0,[R4, #+128]
   1285                  HAL_SAI_Abort(hsai);
   \   000000A4   0x4620             MOV      R0,R4
   \   000000A6   0x.... 0x....      BL       HAL_SAI_Abort
   1286                  HAL_SAI_ErrorCallback(hsai);
   \   000000AA   0x4620             MOV      R0,R4
   \   000000AC   0x.... 0x....      BL       HAL_SAI_ErrorCallback
   1287                }
   1288                /* SAI CNRDY interrupt occurred ----------------------------------*/
   1289                if(((tmpFlag & SAI_FLAG_CNRDY) == SAI_FLAG_CNRDY) && ((tmpItSource & SAI_IT_CNRDY) == SAI_IT_CNRDY))
   \                     ??HAL_SAI_IRQHandler_6: (+1)
   \   000000B0   0x06E8             LSLS     R0,R5,#+27
   \   000000B2   0xD509             BPL.N    ??HAL_SAI_IRQHandler_0
   \   000000B4   0x06F0             LSLS     R0,R6,#+27
   \   000000B6   0xD507             BPL.N    ??HAL_SAI_IRQHandler_0
   1290                {
   1291                  /* Clear the SAI CNRDY flag */
   1292                  __HAL_SAI_CLEAR_FLAG(hsai, SAI_FLAG_CNRDY);
   \   000000B8   0x6821             LDR      R1,[R4, #+0]
   \   000000BA   0x2010             MOVS     R0,#+16
   \   000000BC   0x6188             STR      R0,[R1, #+24]
   1293                  /* Change the SAI error code */
   1294                  hsai->ErrorCode = HAL_SAI_ERROR_CNREADY;
   \   000000BE   0xF8C4 0x0080      STR      R0,[R4, #+128]
   1295                  /* the transfer is not stopped, we will forward the information to the user and we let the user decide what needs to be done */
   1296                  HAL_SAI_ErrorCallback(hsai);
   \   000000C2   0x4620             MOV      R0,R4
   \   000000C4   0x.... 0x....      BL       HAL_SAI_ErrorCallback
   1297                }      
   1298              }
   1299            }
   1300          }
   \                     ??HAL_SAI_IRQHandler_0: (+1)
   \   000000C8   0xBD70             POP      {R4-R6,PC}       ;; return
   1301          
   1302          /**
   1303            * @brief Tx Transfer completed callbacks.
   1304            * @param  hsai: pointer to a SAI_HandleTypeDef structure that contains
   1305            *                the configuration information for SAI module.
   1306            * @retval None
   1307            */

   \                                 In section .text, align 2, keep-with-next
   1308           __weak void HAL_SAI_TxCpltCallback(SAI_HandleTypeDef *hsai)
   1309          {
   1310            /* Prevent unused argument(s) compilation warning */
   1311            UNUSED(hsai);
   1312            
   1313            /* NOTE : This function Should not be modified, when the callback is needed,
   1314                      the HAL_SAI_TxCpltCallback could be implemented in the user file
   1315             */ 
   1316          }
   \                     HAL_SAI_TxCpltCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1317          
   1318          /**
   1319            * @brief Tx Transfer Half completed callbacks
   1320            * @param  hsai: pointer to a SAI_HandleTypeDef structure that contains
   1321            *                the configuration information for SAI module.
   1322            * @retval None
   1323            */

   \                                 In section .text, align 2, keep-with-next
   1324           __weak void HAL_SAI_TxHalfCpltCallback(SAI_HandleTypeDef *hsai)
   1325          {
   1326            /* Prevent unused argument(s) compilation warning */
   1327            UNUSED(hsai);
   1328            
   1329            /* NOTE : This function Should not be modified, when the callback is needed,
   1330                      the HAL_SAI_TxHalfCpltCallback could be implemented in the user file
   1331             */ 
   1332          }
   \                     HAL_SAI_TxHalfCpltCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1333          
   1334          /**
   1335            * @brief Rx Transfer completed callbacks.
   1336            * @param  hsai: pointer to a SAI_HandleTypeDef structure that contains
   1337            *                the configuration information for SAI module.
   1338            * @retval None
   1339            */

   \                                 In section .text, align 2, keep-with-next
   1340          __weak void HAL_SAI_RxCpltCallback(SAI_HandleTypeDef *hsai)
   1341          {
   1342            /* Prevent unused argument(s) compilation warning */
   1343            UNUSED(hsai);
   1344            
   1345            /* NOTE : This function Should not be modified, when the callback is needed,
   1346                      the HAL_SAI_RxCpltCallback could be implemented in the user file
   1347             */
   1348          }
   \                     HAL_SAI_RxCpltCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1349          
   1350          /**
   1351            * @brief Rx Transfer half completed callbacks
   1352            * @param  hsai: pointer to a SAI_HandleTypeDef structure that contains
   1353            *                the configuration information for SAI module.
   1354            * @retval None
   1355            */

   \                                 In section .text, align 2, keep-with-next
   1356          __weak void HAL_SAI_RxHalfCpltCallback(SAI_HandleTypeDef *hsai)
   1357          {
   1358            /* Prevent unused argument(s) compilation warning */
   1359            UNUSED(hsai);
   1360            
   1361            /* NOTE : This function Should not be modified, when the callback is needed,
   1362                      the HAL_SAI_RxCpltCallback could be implemented in the user file
   1363             */
   1364          }
   \                     HAL_SAI_RxHalfCpltCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1365          
   1366          /**
   1367            * @brief SAI error callbacks.
   1368            * @param  hsai: pointer to a SAI_HandleTypeDef structure that contains
   1369            *                the configuration information for SAI module.
   1370            * @retval None
   1371            */

   \                                 In section .text, align 2, keep-with-next
   1372          __weak void HAL_SAI_ErrorCallback(SAI_HandleTypeDef *hsai)
   1373          {
   1374            /* Prevent unused argument(s) compilation warning */
   1375            UNUSED(hsai);
   1376            
   1377            /* NOTE : This function Should not be modified, when the callback is needed,
   1378                      the HAL_SAI_ErrorCallback could be implemented in the user file
   1379             */ 
   1380          }
   \                     HAL_SAI_ErrorCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1381          
   1382          /**
   1383            * @}
   1384            */
   1385          
   1386          
   1387          /** @defgroup SAI_Exported_Functions_Group3 Peripheral State functions 
   1388           *  @brief   Peripheral State functions 
   1389           *
   1390          @verbatim   
   1391           ===============================================================================
   1392                          ##### Peripheral State and Errors functions #####
   1393           ===============================================================================  
   1394              [..]
   1395              This subsection permits to get in run-time the status of the peripheral 
   1396              and the data flow.
   1397          
   1398          @endverbatim
   1399            * @{
   1400            */
   1401          
   1402          /**
   1403            * @brief  Returns the SAI state.
   1404            * @param  hsai: pointer to a SAI_HandleTypeDef structure that contains
   1405            *                the configuration information for SAI module.
   1406            * @retval HAL state
   1407            */

   \                                 In section .text, align 2, keep-with-next
   1408          HAL_SAI_StateTypeDef HAL_SAI_GetState(SAI_HandleTypeDef *hsai)
   1409          {
   1410            return hsai->State;
   \                     HAL_SAI_GetState: (+1)
   \   00000000   0xF890 0x007D      LDRB     R0,[R0, #+125]
   \   00000004   0x4770             BX       LR               ;; return
   1411          }
   1412          
   1413          /**
   1414          * @brief  Return the SAI error code
   1415          * @param  hsai : pointer to a SAI_HandleTypeDef structure that contains
   1416            *              the configuration information for the specified SAI Block.
   1417          * @retval SAI Error Code
   1418          */

   \                                 In section .text, align 2, keep-with-next
   1419          uint32_t HAL_SAI_GetError(SAI_HandleTypeDef *hsai)
   1420          {
   1421            return hsai->ErrorCode;
   \                     HAL_SAI_GetError: (+1)
   \   00000000   0xF8D0 0x0080      LDR      R0,[R0, #+128]
   \   00000004   0x4770             BX       LR               ;; return
   1422          }
   1423          /**
   1424            * @}
   1425            */
   1426          
   1427          /**
   1428            * @brief  Initializes the SAI I2S protocol according to the specified parameters 
   1429            *         in the SAI_InitTypeDef and create the associated handle.
   1430            * @param  hsai : pointer to a SAI_HandleTypeDef structure that contains
   1431            *                the configuration information for SAI module.
   1432            * @param  protocol : one of the supported protocol
   1433            * @param  datasize : one of the supported datasize @ref SAI_Protocol_DataSize
   1434            *                the configuration information for SAI module.
   1435            * @param  nbslot : number of slot minimum value is 2 and max is 16. 
   1436            *                    the value must be a multiple of 2.
   1437            * @retval HAL status
   1438            */

   \                                 In section .text, align 4, keep-with-next
   1439          static HAL_StatusTypeDef SAI_InitI2S(SAI_HandleTypeDef *hsai, uint32_t protocol, uint32_t datasize, uint32_t nbslot)
   1440          {
   \                     SAI_InitI2S: (+1)
   \   00000000   0xB410             PUSH     {R4}
   1441            /* Check the parameters */
   1442            assert_param(IS_SAI_SUPPORTED_PROTOCOL(protocol));
   1443            assert_param(IS_SAI_PROTOCOL_DATASIZE(datasize));
   1444            
   1445            hsai->Init.Protocol            = SAI_FREE_PROTOCOL;
   \   00000002   0x2400             MOVS     R4,#+0
   1446            hsai->Init.FirstBit            = SAI_FIRSTBIT_MSB;
   1447            hsai->Init.ClockStrobing       = SAI_CLOCKSTROBING_FALLINGEDGE;
   1448            hsai->FrameInit.FSDefinition   = SAI_FS_CHANNEL_IDENTIFICATION;
   1449            hsai->SlotInit.SlotActive      = SAI_SLOTACTIVE_ALL;
   1450            hsai->SlotInit.FirstBitOffset  = 0;
   1451            hsai->SlotInit.SlotNumber      = nbslot;
   \   00000004   0x65C3             STR      R3,[R0, #+92]
   \   00000006   0x6304             STR      R4,[R0, #+48]
   \   00000008   0x6384             STR      R4,[R0, #+56]
   \   0000000A   0x63C4             STR      R4,[R0, #+60]
   \   0000000C   0xF44F 0x3480      MOV      R4,#+65536
   \   00000010   0x6484             STR      R4,[R0, #+72]
   \   00000012   0xF64F 0x74FF      MOVW     R4,#+65535
   \   00000016   0x6604             STR      R4,[R0, #+96]
   \   00000018   0x2400             MOVS     R4,#+0
   \   0000001A   0x6544             STR      R4,[R0, #+84]
   1452            
   1453            /* in IS2 the number of slot must be even */
   1454            if((nbslot & 0x1) != 0 )
   \   0000001C   0x07DC             LSLS     R4,R3,#+31
   \   0000001E   0xD43F             BMI.N    ??SAI_InitI2S_1
   1455            {
   1456              return HAL_ERROR;
   1457            }
   1458            
   1459            switch(protocol)
   \   00000020   0xB119             CBZ.N    R1,??SAI_InitI2S_2
   \   00000022   0x2902             CMP      R1,#+2
   \   00000024   0xD006             BEQ.N    ??SAI_InitI2S_3
   \   00000026   0xD305             BCC.N    ??SAI_InitI2S_3
   \   00000028   0xE03A             B.N      ??SAI_InitI2S_1
   1460            {
   1461            case SAI_I2S_STANDARD :
   1462              hsai->FrameInit.FSPolarity = SAI_FS_ACTIVE_LOW;
   \                     ??SAI_InitI2S_2: (+1)
   \   0000002A   0x2400             MOVS     R4,#+0
   \   0000002C   0x64C4             STR      R4,[R0, #+76]
   1463              hsai->FrameInit.FSOffset   = SAI_FS_BEFOREFIRSTBIT;
   \   0000002E   0xF44F 0x2480      MOV      R4,#+262144
   \   00000032   0xE003             B.N      ??SAI_InitI2S_4
   1464              break;
   1465            case SAI_I2S_MSBJUSTIFIED :
   1466            case SAI_I2S_LSBJUSTIFIED :
   1467              hsai->FrameInit.FSPolarity = SAI_FS_ACTIVE_HIGH;
   \                     ??SAI_InitI2S_3: (+1)
   \   00000034   0xF44F 0x3400      MOV      R4,#+131072
   \   00000038   0x64C4             STR      R4,[R0, #+76]
   1468              hsai->FrameInit.FSOffset   = SAI_FS_FIRSTBIT;
   \   0000003A   0x2400             MOVS     R4,#+0
   1469              break;
   1470            default :
   1471              return HAL_ERROR;
   1472            }
   1473            
   1474            /* Frame definition */
   1475            switch(datasize)
   \                     ??SAI_InitI2S_4: (+1)
   \   0000003C   0x2A04             CMP      R2,#+4
   \   0000003E   0x6504             STR      R4,[R0, #+80]
   \   00000040   0xD82E             BHI.N    ??SAI_InitI2S_1
   \   00000042   0xE8DF 0xF002      TBB      [PC, R2]
   \                     ??SAI_InitI2S_0:
   \   00000046   0x03 0x12          DC8      0x3,0x12,0x1B,0x2D
   \              0x1B 0x2D    
   \   0000004A   0x24 0x00          DC8      0x24,0x0
   1476            {
   1477            case SAI_PROTOCOL_DATASIZE_16BIT:
   1478              hsai->Init.DataSize = SAI_DATASIZE_16;
   \                     ??SAI_InitI2S_5: (+1)
   \   0000004C   0x2480             MOVS     R4,#+128
   1479              hsai->FrameInit.FrameLength = 32*(nbslot/2);
   \   0000004E   0x085B             LSRS     R3,R3,#+1
   \   00000050   0x6344             STR      R4,[R0, #+52]
   \   00000052   0x015C             LSLS     R4,R3,#+5
   1480              hsai->FrameInit.ActiveFrameLength = 16*(nbslot/2);
   \   00000054   0x011B             LSLS     R3,R3,#+4
   \   00000056   0x6404             STR      R4,[R0, #+64]
   \   00000058   0x6443             STR      R3,[R0, #+68]
   1481              hsai->SlotInit.SlotSize = SAI_SLOTSIZE_16B;
   \   0000005A   0x2340             MOVS     R3,#+64
   1482              break; 
   1483            case SAI_PROTOCOL_DATASIZE_16BITEXTENDED :
   1484              hsai->Init.DataSize = SAI_DATASIZE_16;
   1485              hsai->FrameInit.FrameLength = 64*(nbslot/2);
   1486              hsai->FrameInit.ActiveFrameLength = 32*(nbslot/2);
   1487              hsai->SlotInit.SlotSize = SAI_SLOTSIZE_32B;
   1488              break; 
   1489            case SAI_PROTOCOL_DATASIZE_24BIT:
   1490              hsai->Init.DataSize = SAI_DATASIZE_24;
   1491              hsai->FrameInit.FrameLength = 64*(nbslot/2);
   1492              hsai->FrameInit.ActiveFrameLength = 32*(nbslot/2);
   1493              hsai->SlotInit.SlotSize = SAI_SLOTSIZE_32B;
   1494              break;
   1495            case SAI_PROTOCOL_DATASIZE_32BIT: 
   1496              hsai->Init.DataSize = SAI_DATASIZE_32;
   1497              hsai->FrameInit.FrameLength = 64*(nbslot/2);
   1498              hsai->FrameInit.ActiveFrameLength = 32*(nbslot/2);
   1499              hsai->SlotInit.SlotSize = SAI_SLOTSIZE_32B;
   1500              break;
   1501            default :
   1502              return HAL_ERROR;  
   1503            }
   1504            if(protocol == SAI_I2S_LSBJUSTIFIED)
   \                     ??SAI_InitI2S_6: (+1)
   \   0000005C   0x2902             CMP      R1,#+2
   \   0000005E   0x6583             STR      R3,[R0, #+88]
   \   00000060   0xD123             BNE.N    ??SAI_InitI2S_7
   1505            {
   1506              if (datasize == SAI_PROTOCOL_DATASIZE_16BITEXTENDED)
   \   00000062   0x2A01             CMP      R2,#+1
   \   00000064   0xD11D             BNE.N    ??SAI_InitI2S_8
   \   00000066   0x2110             MOVS     R1,#+16
   \   00000068   0xE01E             B.N      ??SAI_InitI2S_9
   \                     ??SAI_InitI2S_10: (+1)
   \   0000006A   0x2480             MOVS     R4,#+128
   \   0000006C   0x085B             LSRS     R3,R3,#+1
   \   0000006E   0x6344             STR      R4,[R0, #+52]
   \   00000070   0x019C             LSLS     R4,R3,#+6
   \   00000072   0x015B             LSLS     R3,R3,#+5
   \   00000074   0x6404             STR      R4,[R0, #+64]
   \   00000076   0x6443             STR      R3,[R0, #+68]
   \   00000078   0x2380             MOVS     R3,#+128
   \   0000007A   0xE7EF             B.N      ??SAI_InitI2S_6
   \                     ??SAI_InitI2S_11: (+1)
   \   0000007C   0x24C0             MOVS     R4,#+192
   \   0000007E   0x085B             LSRS     R3,R3,#+1
   \   00000080   0x6344             STR      R4,[R0, #+52]
   \   00000082   0x019C             LSLS     R4,R3,#+6
   \   00000084   0x015B             LSLS     R3,R3,#+5
   \   00000086   0x6404             STR      R4,[R0, #+64]
   \   00000088   0x6443             STR      R3,[R0, #+68]
   \   0000008A   0x2380             MOVS     R3,#+128
   \   0000008C   0xE7E6             B.N      ??SAI_InitI2S_6
   \                     ??SAI_InitI2S_12: (+1)
   \   0000008E   0x24E0             MOVS     R4,#+224
   \   00000090   0x085B             LSRS     R3,R3,#+1
   \   00000092   0x6344             STR      R4,[R0, #+52]
   \   00000094   0x019C             LSLS     R4,R3,#+6
   \   00000096   0x015B             LSLS     R3,R3,#+5
   \   00000098   0x6404             STR      R4,[R0, #+64]
   \   0000009A   0x6443             STR      R3,[R0, #+68]
   \   0000009C   0x2380             MOVS     R3,#+128
   \   0000009E   0xE7DD             B.N      ??SAI_InitI2S_6
   \                     ??SAI_InitI2S_1: (+1)
   \   000000A0   0x....             B.N      ?Subroutine8
   1507              {
   1508                hsai->SlotInit.FirstBitOffset = 16;
   1509              }
   1510              if (datasize == SAI_PROTOCOL_DATASIZE_24BIT)
   \                     ??SAI_InitI2S_8: (+1)
   \   000000A2   0x2A02             CMP      R2,#+2
   \   000000A4   0xD101             BNE.N    ??SAI_InitI2S_7
   1511              {
   1512                hsai->SlotInit.FirstBitOffset = 8;
   \   000000A6   0x2108             MOVS     R1,#+8
   \                     ??SAI_InitI2S_9: (+1)
   \   000000A8   0x6541             STR      R1,[R0, #+84]
   1513              }
   1514            }
   1515            return HAL_OK;
   \                     ??SAI_InitI2S_7: (+1)
   \   000000AA                      REQUIRE ?Subroutine9
   \   000000AA                      ;; // Fall through to label ?Subroutine9
   1516          }
   1517          
   1518          /**
   1519            * @brief  Initializes the SAI PCM protocol according to the specified parameters 
   1520            *         in the SAI_InitTypeDef and create the associated handle.
   1521            * @param  hsai : pointer to a SAI_HandleTypeDef structure that contains
   1522            *                the configuration information for SAI module.
   1523            * @param  protocol : one of the supported protocol
   1524            * @param  datasize : one of the supported datasize @ref SAI_Protocol_DataSize
   1525            * @param  nbslot : number of slot minimum value is 1 and the max is 16.
   1526            * @retval HAL status
   1527            */
   1528          static HAL_StatusTypeDef SAI_InitPCM(SAI_HandleTypeDef *hsai, uint32_t protocol, uint32_t datasize, uint32_t nbslot)
   1529          {
   1530            /* Check the parameters */
   1531            assert_param(IS_SAI_SUPPORTED_PROTOCOL(protocol));
   1532            assert_param(IS_SAI_PROTOCOL_DATASIZE(datasize));
   1533          
   1534            hsai->Init.Protocol            = SAI_FREE_PROTOCOL;
   1535            hsai->Init.FirstBit            = SAI_FIRSTBIT_MSB;
   1536            hsai->Init.ClockStrobing       = SAI_CLOCKSTROBING_FALLINGEDGE;
   1537            hsai->FrameInit.FSDefinition   = SAI_FS_STARTFRAME;
   1538            hsai->FrameInit.FSPolarity     = SAI_FS_ACTIVE_HIGH;
   1539            hsai->FrameInit.FSOffset       = SAI_FS_BEFOREFIRSTBIT;
   1540            hsai->SlotInit.FirstBitOffset  = 0;
   1541            hsai->SlotInit.SlotNumber      = nbslot;
   1542            hsai->SlotInit.SlotActive      = SAI_SLOTACTIVE_ALL;
   1543            
   1544            switch(protocol)
   1545            {
   1546            case SAI_PCM_SHORT :
   1547              hsai->FrameInit.ActiveFrameLength = 1;
   1548              break;
   1549            case SAI_PCM_LONG :
   1550              hsai->FrameInit.ActiveFrameLength = 13;
   1551              break;
   1552            default :
   1553              return HAL_ERROR;
   1554            }
   1555           
   1556            switch(datasize)
   1557            {
   1558            case SAI_PROTOCOL_DATASIZE_16BIT:
   1559              hsai->Init.DataSize = SAI_DATASIZE_16;
   1560              hsai->FrameInit.FrameLength = 16 * nbslot;
   1561              hsai->SlotInit.SlotSize = SAI_SLOTSIZE_16B;
   1562              break; 
   1563            case SAI_PROTOCOL_DATASIZE_16BITEXTENDED :
   1564              hsai->Init.DataSize = SAI_DATASIZE_16;
   1565              hsai->FrameInit.FrameLength = 32 * nbslot;
   1566              hsai->SlotInit.SlotSize = SAI_SLOTSIZE_32B;
   1567              break;
   1568            case SAI_PROTOCOL_DATASIZE_24BIT :
   1569              hsai->Init.DataSize = SAI_DATASIZE_24;
   1570              hsai->FrameInit.FrameLength = 32 * nbslot;
   1571              hsai->SlotInit.SlotSize = SAI_SLOTSIZE_32B;
   1572              break;    
   1573            case SAI_PROTOCOL_DATASIZE_32BIT: 
   1574              hsai->Init.DataSize = SAI_DATASIZE_32;
   1575              hsai->FrameInit.FrameLength = 32 * nbslot;
   1576              hsai->SlotInit.SlotSize = SAI_SLOTSIZE_32B;
   1577              break;
   1578            default :
   1579              return HAL_ERROR;
   1580            }
   1581           
   1582            return HAL_OK;
   1583          }
   1584          
   1585          /**
   1586            * @brief  Fill the fifo 
   1587            * @param  hsai : pointer to a SAI_HandleTypeDef structure that contains
   1588            *                the configuration information for SAI module.
   1589            * @retval None.
   1590            */

   \                                 In section .text, align 2, keep-with-next
   1591          static void SAI_FillFifo(SAI_HandleTypeDef *hsai)
   1592          {
   \                     SAI_FillFifo: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
   \   00000002   0xF100 0x0164      ADD      R1,R0,#+100
   \   00000006   0xE006             B.N      ??SAI_FillFifo_0
   1593            /* fill the fifo with data before to enabled the SAI */
   1594            while(((hsai->Instance->SR & SAI_xSR_FLVL) != SAI_FIFOSTATUS_FULL) && (hsai->XferCount > 0))   
   1595            {
   1596              if((hsai->Init.DataSize == SAI_DATASIZE_8) && (hsai->Init.CompandingMode == SAI_NOCOMPANDING))
   1597              {
   1598                hsai->Instance->DR = (*hsai->pBuffPtr++);
   1599              }
   1600              else if(hsai->Init.DataSize <= SAI_DATASIZE_16)
   1601              {
   1602                hsai->Instance->DR = *((uint32_t *)hsai->pBuffPtr);
   1603                hsai->pBuffPtr+= 2;
   1604              }
   1605              else
   1606              {
   1607                hsai->Instance->DR = *((uint32_t *)hsai->pBuffPtr);
   \                     ??SAI_FillFifo_1: (+1)
   \   00000008   0x680A             LDR      R2,[R1, #+0]
   \   0000000A   0xF852 0x5B04      LDR      R5,[R2], #+4
   \   0000000E   0x61DD             STR      R5,[R3, #+28]
   1608                hsai->pBuffPtr+= 4;
   \                     ??SAI_FillFifo_2: (+1)
   \   00000010   0x600A             STR      R2,[R1, #+0]
   1609              }
   1610              hsai->XferCount--;
   \                     ??SAI_FillFifo_3: (+1)
   \   00000012   0x1E62             SUBS     R2,R4,#+1
   \   00000014   0x80CA             STRH     R2,[R1, #+6]
   \                     ??SAI_FillFifo_0: (+1)
   \   00000016   0x6803             LDR      R3,[R0, #+0]
   \   00000018   0x695A             LDR      R2,[R3, #+20]
   \   0000001A   0xF402 0x22E0      AND      R2,R2,#0x70000
   \   0000001E   0xF5B2 0x2FA0      CMP      R2,#+327680
   \   00000022   0xBF1C             ITT      NE 
   \   00000024   0x88CC             LDRHNE   R4,[R1, #+6]
   \   00000026   0x2C00             CMPNE    R4,#+0
   \   00000028   0xD012             BEQ.N    ??SAI_FillFifo_4
   \   0000002A   0x6B42             LDR      R2,[R0, #+52]
   \   0000002C   0x2A40             CMP      R2,#+64
   \   0000002E   0xD108             BNE.N    ??SAI_FillFifo_5
   \   00000030   0x6A82             LDR      R2,[R0, #+40]
   \   00000032   0xB942             CBNZ.N   R2,??SAI_FillFifo_6
   \   00000034   0x680A             LDR      R2,[R1, #+0]
   \   00000036   0x1C52             ADDS     R2,R2,#+1
   \   00000038   0x600A             STR      R2,[R1, #+0]
   \   0000003A   0x1E52             SUBS     R2,R2,#+1
   \   0000003C   0x7812             LDRB     R2,[R2, #+0]
   \   0000003E   0x61DA             STR      R2,[R3, #+28]
   \   00000040   0xE7E7             B.N      ??SAI_FillFifo_3
   \                     ??SAI_FillFifo_5: (+1)
   \   00000042   0x2A81             CMP      R2,#+129
   \   00000044   0xD2E0             BCS.N    ??SAI_FillFifo_1
   \                     ??SAI_FillFifo_6: (+1)
   \   00000046   0x680A             LDR      R2,[R1, #+0]
   \   00000048   0xF852 0x5B02      LDR      R5,[R2], #+2
   \   0000004C   0x61DD             STR      R5,[R3, #+28]
   \   0000004E   0xE7DF             B.N      ??SAI_FillFifo_2
   1611            }
   1612          }
   \                     ??SAI_FillFifo_4: (+1)
   \   00000050   0xBC30             POP      {R4,R5}
   \   00000052   0x4770             BX       LR               ;; return
   1613          
   1614          /**
   1615            * @brief  return the interrupt flag to set according the SAI setup 
   1616            * @param  hsai : pointer to a SAI_HandleTypeDef structure that contains
   1617            *                the configuration information for SAI module.
   1618            * @param  mode : SAI_MODE_DMA or SAI_MODE_IT
   1619            * @retval the list of the IT flag to enable
   1620           */

   \                                 In section .text, align 2, keep-with-next
   1621          static uint32_t SAI_InterruptFlag(SAI_HandleTypeDef *hsai, uint32_t mode)
   1622          {
   1623            uint32_t tmpIT = SAI_IT_OVRUDR; 
   \                     SAI_InterruptFlag: (+1)
   \   00000000   0x2201             MOVS     R2,#+1
   1624            
   1625            if(mode == SAI_MODE_IT)
   \   00000002   0x2901             CMP      R1,#+1
   \   00000004   0xBF08             IT       EQ 
   \   00000006   0x2209             MOVEQ    R2,#+9
   1626            {
   1627              tmpIT|= SAI_IT_FREQ;
   1628            }
   1629          
   1630            if((hsai->Init.Protocol == SAI_AC97_PROTOCOL) && 
   1631              ((hsai->Init.AudioMode == SAI_MODESLAVE_RX) || (hsai->Init.AudioMode == SAI_MODEMASTER_RX)))
   \   00000008   0x6841             LDR      R1,[R0, #+4]
   \   0000000A   0x6B00             LDR      R0,[R0, #+48]
   \   0000000C   0x2808             CMP      R0,#+8
   \   0000000E   0xD10B             BNE.N    ??SAI_InterruptFlag_0
   \   00000010   0x2903             CMP      R1,#+3
   \   00000012   0xBF08             IT       EQ 
   \   00000014   0xF042 0x0210      ORREQ    R2,R2,#0x10
   \   00000018   0xD00A             BEQ.N    ??SAI_InterruptFlag_1
   \   0000001A   0x2901             CMP      R1,#+1
   \   0000001C   0xD106             BNE.N    ??SAI_InterruptFlag_2
   \   0000001E   0xF042 0x0210      ORR      R2,R2,#0x10
   1632            {
   1633              tmpIT|= SAI_IT_CNRDY;
   1634            }
   1635            
   1636            if((hsai->Init.AudioMode == SAI_MODESLAVE_RX) || (hsai->Init.AudioMode == SAI_MODESLAVE_TX))
   1637            {
   1638              tmpIT|= SAI_IT_AFSDET | SAI_IT_LFSDET;
   1639            }
   1640            else
   1641            {
   1642              /* hsai has been configured in master mode */
   1643              tmpIT|= SAI_IT_WCKCFG;
   \                     ??SAI_InterruptFlag_3: (+1)
   \   00000022   0xF042 0x0004      ORR      R0,R2,#0x4
   1644            }
   1645            return tmpIT;
   \   00000026   0x4770             BX       LR               ;; return
   \                     ??SAI_InterruptFlag_0: (+1)
   \   00000028   0x2903             CMP      R1,#+3
   \   0000002A   0xD001             BEQ.N    ??SAI_InterruptFlag_1
   \                     ??SAI_InterruptFlag_2: (+1)
   \   0000002C   0x2902             CMP      R1,#+2
   \   0000002E   0xD1F8             BNE.N    ??SAI_InterruptFlag_3
   \                     ??SAI_InterruptFlag_1: (+1)
   \   00000030   0xF042 0x0060      ORR      R0,R2,#0x60
   \   00000034   0x4770             BX       LR
   1646          }
   1647          
   1648          /**
   1649            * @brief  disable the SAI and wait the disabling
   1650            * @param  hsai : pointer to a SAI_HandleTypeDef structure that contains
   1651            *                the configuration information for SAI module.
   1652            * @retval None.
   1653            */

   \                                 In section .text, align 2, keep-with-next
   1654          static HAL_StatusTypeDef SAI_Disable(SAI_HandleTypeDef *hsai)
   1655          {
   \                     SAI_Disable: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   1656            uint32_t tickstart = HAL_GetTick();
   \   00000004   0x.... 0x....      BL       HAL_GetTick
   \   00000008   0x4605             MOV      R5,R0
   1657            HAL_StatusTypeDef status = HAL_OK;
   1658            
   1659            __HAL_SAI_DISABLE(hsai);
   \   0000000A   0x6820             LDR      R0,[R4, #+0]
   \   0000000C   0x6801             LDR      R1,[R0, #+0]
   \   0000000E   0xF421 0x3180      BIC      R1,R1,#0x10000
   \   00000012   0x6001             STR      R1,[R0, #+0]
   1660            while((hsai->Instance->CR1 & SAI_xCR1_SAIEN) != RESET)
   \                     ??SAI_Disable_0: (+1)
   \   00000014   0x6820             LDR      R0,[R4, #+0]
   \   00000016   0x6800             LDR      R0,[R0, #+0]
   \   00000018   0x03C0             LSLS     R0,R0,#+15
   \   0000001A   0xD50C             BPL.N    ??SAI_Disable_1
   1661            {
   1662              /* Check for the Timeout */
   1663              if((HAL_GetTick() - tickstart ) > SAI_TIMEOUT_VALUE)
   \   0000001C   0x.... 0x....      BL       HAL_GetTick
   \   00000020   0x1B40             SUBS     R0,R0,R5
   \   00000022   0x280B             CMP      R0,#+11
   \   00000024   0xD3F6             BCC.N    ??SAI_Disable_0
   1664              {         
   1665                /* Update error code */
   1666                hsai->ErrorCode |= HAL_SAI_ERROR_TIMEOUT;
   \   00000026   0xF8D4 0x0080      LDR      R0,[R4, #+128]
   \   0000002A   0xF040 0x0040      ORR      R0,R0,#0x40
   \   0000002E   0xF8C4 0x0080      STR      R0,[R4, #+128]
   1667                
   1668                return HAL_TIMEOUT;
   \   00000032   0x2003             MOVS     R0,#+3
   \   00000034   0xBD32             POP      {R1,R4,R5,PC}
   1669              }
   1670            }
   1671            return status;
   \                     ??SAI_Disable_1: (+1)
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1672          }
   1673          
   1674          /**
   1675            * @brief  Tx Handler for Transmit in Interrupt mode 8Bit transfer
   1676            * @param  hsai : pointer to a SAI_HandleTypeDef structure that contains
   1677            *                the configuration information for SAI module.
   1678            * @retval None.
   1679            */

   \                                 In section .text, align 4, keep-with-next
   1680          static void SAI_Transmit_IT8Bit(SAI_HandleTypeDef *hsai)
   1681          {
   1682            if(hsai->XferCount == 0)
   \                     SAI_Transmit_IT8Bit: (+1)
   \   00000000   0xF100 0x016A      ADD      R1,R0,#+106
   \   00000004   0xB510             PUSH     {R4,LR}
   \   00000006   0x880A             LDRH     R2,[R1, #+0]
   \   00000008   0xB9B2             CBNZ.N   R2,??SAI_Transmit_IT8Bit_0
   1683            {
   1684              /* Handle the end of the transmission */
   1685              /* Disable FREQ and OVRUDR interrupts */
   1686              __HAL_SAI_DISABLE_IT(hsai, SAI_InterruptFlag(hsai, SAI_MODE_IT)); 
   \   0000000A   0x6B03             LDR      R3,[R0, #+48]
   \   0000000C   0x2209             MOVS     R2,#+9
   \   0000000E   0x2B08             CMP      R3,#+8
   \   00000010   0xD10A             BNE.N    ??SAI_Transmit_IT8Bit_1
   \   00000012   0x6843             LDR      R3,[R0, #+4]
   \   00000014   0x2B03             CMP      R3,#+3
   \   00000016   0xD103             BNE.N    ??SAI_Transmit_IT8Bit_2
   \   00000018   0x2219             MOVS     R2,#+25
   \                     ??SAI_Transmit_IT8Bit_3: (+1)
   \   0000001A   0xF042 0x0260      ORR      R2,R2,#0x60
   \                     ??SAI_Transmit_IT8Bit_4: (+1)
   \   0000001E   0x....             B.N      ?Subroutine1
   \                     ??SAI_Transmit_IT8Bit_2: (+1)
   \   00000020   0x2B01             CMP      R3,#+1
   \   00000022   0xBF08             IT       EQ 
   \   00000024   0x2219             MOVEQ    R2,#+25
   \   00000026   0xD004             BEQ.N    ??SAI_Transmit_IT8Bit_5
   \                     ??SAI_Transmit_IT8Bit_1: (+1)
   \   00000028   0x6843             LDR      R3,[R0, #+4]
   \   0000002A   0x2B03             CMP      R3,#+3
   \   0000002C   0xBF18             IT       NE 
   \   0000002E   0x2B02             CMPNE    R3,#+2
   \   00000030   0xD0F3             BEQ.N    ??SAI_Transmit_IT8Bit_3
   \                     ??SAI_Transmit_IT8Bit_5: (+1)
   \   00000032   0xF042 0x0204      ORR      R2,R2,#0x4
   \   00000036   0xE7F2             B.N      ??SAI_Transmit_IT8Bit_4
   1687              hsai->State = HAL_SAI_STATE_READY;
   1688              HAL_SAI_TxCpltCallback(hsai);
   1689            }
   1690            else
   1691            {
   1692              /* Write data on DR register */
   1693              hsai->Instance->DR = (*hsai->pBuffPtr++);
   \                     ??SAI_Transmit_IT8Bit_0: (+1)
   \   00000038   0x6E42             LDR      R2,[R0, #+100]
   \   0000003A   0x1C53             ADDS     R3,R2,#+1
   \   0000003C   0x6643             STR      R3,[R0, #+100]
   \   0000003E   0x7812             LDRB     R2,[R2, #+0]
   \   00000040   0x6800             LDR      R0,[R0, #+0]
   \   00000042   0x61C2             STR      R2,[R0, #+28]
   1694              hsai->XferCount--;
   \   00000044   0x....             B.N      ??Subroutine2_0
   1695            }  
   1696          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \   00000000   0x6803             LDR      R3,[R0, #+0]
   \   00000002   0x691C             LDR      R4,[R3, #+16]
   \   00000004   0xEA24 0x0202      BIC      R2,R4,R2
   \   00000008   0x611A             STR      R2,[R3, #+16]
   \   0000000A   0x2201             MOVS     R2,#+1
   \   0000000C   0x74CA             STRB     R2,[R1, #+19]
   \   0000000E                      REQUIRE ??Subroutine11_0
   \   0000000E                      ;; // Fall through to label ??Subroutine11_0

   \                                 In section .text, align 2, keep-with-next
   \                     ??Subroutine11_0: (+1)
   \   00000000   0x.... 0x....      BL       HAL_SAI_TxCpltCallback
   \   00000004   0xBD10             POP      {R4,PC}

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine2: (+1)
   \   00000000   0x6642             STR      R2,[R0, #+100]
   \                     ??Subroutine2_0: (+1)
   \   00000002   0x8808             LDRH     R0,[R1, #+0]
   \   00000004   0x1E40             SUBS     R0,R0,#+1
   \   00000006   0x8008             STRH     R0,[R1, #+0]
   \   00000008   0xBD10             POP      {R4,PC}          ;; return
   1697          
   1698          /**
   1699            * @brief  Tx Handler for Transmit in Interrupt mode for 16Bit transfer
   1700            * @param  hsai : pointer to a SAI_HandleTypeDef structure that contains
   1701            *                the configuration information for SAI module.
   1702            * @retval None.
   1703            */

   \                                 In section .text, align 4, keep-with-next
   1704          static void SAI_Transmit_IT16Bit(SAI_HandleTypeDef *hsai)
   1705          {
   1706            if(hsai->XferCount == 0)
   \                     SAI_Transmit_IT16Bit: (+1)
   \   00000000   0xF100 0x016A      ADD      R1,R0,#+106
   \   00000004   0xB510             PUSH     {R4,LR}
   \   00000006   0x880A             LDRH     R2,[R1, #+0]
   \   00000008   0xB9B2             CBNZ.N   R2,??SAI_Transmit_IT16Bit_0
   1707            {
   1708              /* Handle the end of the transmission */    
   1709              /* Disable FREQ and OVRUDR interrupts */
   1710              __HAL_SAI_DISABLE_IT(hsai, SAI_InterruptFlag(hsai, SAI_MODE_IT)); 
   \   0000000A   0x6B03             LDR      R3,[R0, #+48]
   \   0000000C   0x2209             MOVS     R2,#+9
   \   0000000E   0x2B08             CMP      R3,#+8
   \   00000010   0xD10A             BNE.N    ??SAI_Transmit_IT16Bit_1
   \   00000012   0x6843             LDR      R3,[R0, #+4]
   \   00000014   0x2B03             CMP      R3,#+3
   \   00000016   0xD103             BNE.N    ??SAI_Transmit_IT16Bit_2
   \   00000018   0x2219             MOVS     R2,#+25
   \                     ??SAI_Transmit_IT16Bit_3: (+1)
   \   0000001A   0xF042 0x0260      ORR      R2,R2,#0x60
   \                     ??SAI_Transmit_IT16Bit_4: (+1)
   \   0000001E   0x....             B.N      ?Subroutine1
   \                     ??SAI_Transmit_IT16Bit_2: (+1)
   \   00000020   0x2B01             CMP      R3,#+1
   \   00000022   0xBF08             IT       EQ 
   \   00000024   0x2219             MOVEQ    R2,#+25
   \   00000026   0xD004             BEQ.N    ??SAI_Transmit_IT16Bit_5
   \                     ??SAI_Transmit_IT16Bit_1: (+1)
   \   00000028   0x6843             LDR      R3,[R0, #+4]
   \   0000002A   0x2B03             CMP      R3,#+3
   \   0000002C   0xBF18             IT       NE 
   \   0000002E   0x2B02             CMPNE    R3,#+2
   \   00000030   0xD0F3             BEQ.N    ??SAI_Transmit_IT16Bit_3
   \                     ??SAI_Transmit_IT16Bit_5: (+1)
   \   00000032   0xF042 0x0204      ORR      R2,R2,#0x4
   \   00000036   0xE7F2             B.N      ??SAI_Transmit_IT16Bit_4
   1711              hsai->State = HAL_SAI_STATE_READY;
   1712              HAL_SAI_TxCpltCallback(hsai);
   1713            }
   1714            else
   1715            {
   1716              /* Write data on DR register */
   1717              hsai->Instance->DR = *(uint16_t *)hsai->pBuffPtr;
   \                     ??SAI_Transmit_IT16Bit_0: (+1)
   \   00000038   0x6E42             LDR      R2,[R0, #+100]
   \   0000003A   0x6803             LDR      R3,[R0, #+0]
   \   0000003C   0x8812             LDRH     R2,[R2, #+0]
   \   0000003E   0x61DA             STR      R2,[R3, #+28]
   1718              hsai->pBuffPtr+=2;
   \   00000040   0x6E42             LDR      R2,[R0, #+100]
   \   00000042   0x1C92             ADDS     R2,R2,#+2
   \   00000044   0x....             B.N      ?Subroutine2
   1719              hsai->XferCount--;
   1720            }  
   1721          }
   1722          
   1723          /**
   1724            * @brief  Tx Handler for Transmit in Interrupt mode for 32Bit transfer
   1725            * @param  hsai : pointer to a SAI_HandleTypeDef structure that contains
   1726            *                the configuration information for SAI module.
   1727            * @retval None.
   1728            */

   \                                 In section .text, align 4, keep-with-next
   1729          static void SAI_Transmit_IT32Bit(SAI_HandleTypeDef *hsai)
   1730          {
   1731            if(hsai->XferCount == 0)
   \                     SAI_Transmit_IT32Bit: (+1)
   \   00000000   0xF100 0x016A      ADD      R1,R0,#+106
   \   00000004   0xB510             PUSH     {R4,LR}
   \   00000006   0x880A             LDRH     R2,[R1, #+0]
   \   00000008   0xB9B2             CBNZ.N   R2,??SAI_Transmit_IT32Bit_0
   1732            {
   1733              /* Handle the end of the transmission */
   1734              /* Disable FREQ and OVRUDR interrupts */
   1735              __HAL_SAI_DISABLE_IT(hsai, SAI_InterruptFlag(hsai, SAI_MODE_IT)); 
   \   0000000A   0x6B03             LDR      R3,[R0, #+48]
   \   0000000C   0x2209             MOVS     R2,#+9
   \   0000000E   0x2B08             CMP      R3,#+8
   \   00000010   0xD10A             BNE.N    ??SAI_Transmit_IT32Bit_1
   \   00000012   0x6843             LDR      R3,[R0, #+4]
   \   00000014   0x2B03             CMP      R3,#+3
   \   00000016   0xD103             BNE.N    ??SAI_Transmit_IT32Bit_2
   \   00000018   0x2219             MOVS     R2,#+25
   \                     ??SAI_Transmit_IT32Bit_3: (+1)
   \   0000001A   0xF042 0x0260      ORR      R2,R2,#0x60
   \                     ??SAI_Transmit_IT32Bit_4: (+1)
   \   0000001E   0x....             B.N      ?Subroutine1
   \                     ??SAI_Transmit_IT32Bit_2: (+1)
   \   00000020   0x2B01             CMP      R3,#+1
   \   00000022   0xBF08             IT       EQ 
   \   00000024   0x2219             MOVEQ    R2,#+25
   \   00000026   0xD004             BEQ.N    ??SAI_Transmit_IT32Bit_5
   \                     ??SAI_Transmit_IT32Bit_1: (+1)
   \   00000028   0x6843             LDR      R3,[R0, #+4]
   \   0000002A   0x2B03             CMP      R3,#+3
   \   0000002C   0xBF18             IT       NE 
   \   0000002E   0x2B02             CMPNE    R3,#+2
   \   00000030   0xD0F3             BEQ.N    ??SAI_Transmit_IT32Bit_3
   \                     ??SAI_Transmit_IT32Bit_5: (+1)
   \   00000032   0xF042 0x0204      ORR      R2,R2,#0x4
   \   00000036   0xE7F2             B.N      ??SAI_Transmit_IT32Bit_4
   1736              hsai->State = HAL_SAI_STATE_READY;
   1737              HAL_SAI_TxCpltCallback(hsai);
   1738            }
   1739            else
   1740            {
   1741              /* Write data on DR register */
   1742              hsai->Instance->DR = *(uint32_t *)hsai->pBuffPtr;
   \                     ??SAI_Transmit_IT32Bit_0: (+1)
   \   00000038   0x6E42             LDR      R2,[R0, #+100]
   \   0000003A   0x6803             LDR      R3,[R0, #+0]
   \   0000003C   0x6812             LDR      R2,[R2, #+0]
   \   0000003E   0x61DA             STR      R2,[R3, #+28]
   1743              hsai->pBuffPtr+=4;
   \   00000040   0x6E42             LDR      R2,[R0, #+100]
   \   00000042   0x1D12             ADDS     R2,R2,#+4
   \   00000044                      REQUIRE ?Subroutine2
   \   00000044                      ;; // Fall through to label ?Subroutine2
   1744              hsai->XferCount--;
   1745            }
   1746          }
   1747          
   1748          /**
   1749            * @brief  Rx Handler for Receive in Interrupt mode 8Bit transfer
   1750            * @param  hsai : pointer to a SAI_HandleTypeDef structure that contains
   1751            *                the configuration information for SAI module.
   1752            * @retval None.
   1753            */

   \                                 In section .text, align 4, keep-with-next
   1754          static void SAI_Receive_IT8Bit(SAI_HandleTypeDef *hsai)
   1755          {
   1756            /* Receive data */    
   1757            (*hsai->pBuffPtr++) = hsai->Instance->DR;
   \                     SAI_Receive_IT8Bit: (+1)
   \   00000000   0x6E41             LDR      R1,[R0, #+100]
   \   00000002   0x1C4A             ADDS     R2,R1,#+1
   \   00000004   0x6642             STR      R2,[R0, #+100]
   \   00000006   0x6802             LDR      R2,[R0, #+0]
   \   00000008   0x69D2             LDR      R2,[R2, #+28]
   \   0000000A   0x700A             STRB     R2,[R1, #+0]
   1758            hsai->XferCount--;
   \   0000000C   0xF100 0x016A      ADD      R1,R0,#+106
   \   00000010   0x880A             LDRH     R2,[R1, #+0]
   \   00000012   0x1E52             SUBS     R2,R2,#+1
   \   00000014   0x800A             STRH     R2,[R1, #+0]
   1759            
   1760            /* Check end of the transfer */  
   1761            if(hsai->XferCount == 0)
   \   00000016   0xB292             UXTH     R2,R2
   \   00000018   0xB102             CBZ.N    R2,??SAI_Receive_IT8Bit_0
   \   0000001A   0x4770             BX       LR
   1762            {    
   1763              /* Disable TXE and OVRUDR interrupts */
   1764              __HAL_SAI_DISABLE_IT(hsai, SAI_InterruptFlag(hsai, SAI_MODE_IT));
   \                     ??SAI_Receive_IT8Bit_0: (+1)
   \   0000001C   0xB510             PUSH     {R4,LR}
   \   0000001E   0x6B03             LDR      R3,[R0, #+48]
   \   00000020   0x2209             MOVS     R2,#+9
   \   00000022   0x2B08             CMP      R3,#+8
   \   00000024   0xD10A             BNE.N    ??SAI_Receive_IT8Bit_1
   \   00000026   0x6843             LDR      R3,[R0, #+4]
   \   00000028   0x2B03             CMP      R3,#+3
   \   0000002A   0xD103             BNE.N    ??SAI_Receive_IT8Bit_2
   \   0000002C   0x2219             MOVS     R2,#+25
   \                     ??SAI_Receive_IT8Bit_3: (+1)
   \   0000002E   0xF042 0x0260      ORR      R2,R2,#0x60
   \                     ??SAI_Receive_IT8Bit_4: (+1)
   \   00000032   0x....             B.N      ?Subroutine0
   \                     ??SAI_Receive_IT8Bit_2: (+1)
   \   00000034   0x2B01             CMP      R3,#+1
   \   00000036   0xBF08             IT       EQ 
   \   00000038   0x2219             MOVEQ    R2,#+25
   \   0000003A   0xD004             BEQ.N    ??SAI_Receive_IT8Bit_5
   \                     ??SAI_Receive_IT8Bit_1: (+1)
   \   0000003C   0x6843             LDR      R3,[R0, #+4]
   \   0000003E   0x2B03             CMP      R3,#+3
   \   00000040   0xBF18             IT       NE 
   \   00000042   0x2B02             CMPNE    R3,#+2
   \   00000044   0xD0F3             BEQ.N    ??SAI_Receive_IT8Bit_3
   \                     ??SAI_Receive_IT8Bit_5: (+1)
   \   00000046   0xF042 0x0204      ORR      R2,R2,#0x4
   \   0000004A   0xE7F2             B.N      ??SAI_Receive_IT8Bit_4
   1765              
   1766              /* Clear the SAI Overrun flag */
   1767              __HAL_SAI_CLEAR_FLAG(hsai, SAI_FLAG_OVRUDR);
   1768              
   1769              hsai->State = HAL_SAI_STATE_READY;
   1770              HAL_SAI_RxCpltCallback(hsai); 
   1771            }
   1772          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \   00000000   0x6803             LDR      R3,[R0, #+0]
   \   00000002   0x691C             LDR      R4,[R3, #+16]
   \   00000004   0xEA24 0x0202      BIC      R2,R4,R2
   \   00000008   0x611A             STR      R2,[R3, #+16]
   \   0000000A   0x6803             LDR      R3,[R0, #+0]
   \   0000000C   0x2201             MOVS     R2,#+1
   \   0000000E   0x619A             STR      R2,[R3, #+24]
   \   00000010   0x74CA             STRB     R2,[R1, #+19]
   \   00000012                      REQUIRE ??Subroutine12_0
   \   00000012                      ;; // Fall through to label ??Subroutine12_0

   \                                 In section .text, align 2, keep-with-next
   \                     ??Subroutine12_0: (+1)
   \   00000000   0x.... 0x....      BL       HAL_SAI_RxCpltCallback
   \   00000004   0xBD10             POP      {R4,PC}          ;; return
   1773          
   1774          /**
   1775            * @brief  Rx Handler for Receive in Interrupt mode for 16Bit transfer
   1776            * @param  hsai : pointer to a SAI_HandleTypeDef structure that contains
   1777            *                the configuration information for SAI module.
   1778            * @retval None.
   1779            */

   \                                 In section .text, align 4, keep-with-next
   1780          static void SAI_Receive_IT16Bit(SAI_HandleTypeDef *hsai)
   1781          {
   1782            /* Receive data */    
   1783            *(uint16_t*)hsai->pBuffPtr = hsai->Instance->DR;
   \                     SAI_Receive_IT16Bit: (+1)
   \   00000000   0x6801             LDR      R1,[R0, #+0]
   \   00000002   0x69C9             LDR      R1,[R1, #+28]
   \   00000004   0x6E42             LDR      R2,[R0, #+100]
   \   00000006   0x8011             STRH     R1,[R2, #+0]
   1784            hsai->pBuffPtr+=2;
   \   00000008   0x6E41             LDR      R1,[R0, #+100]
   \   0000000A   0x1C89             ADDS     R1,R1,#+2
   \   0000000C   0x6641             STR      R1,[R0, #+100]
   1785            hsai->XferCount--;
   \   0000000E   0xF100 0x016A      ADD      R1,R0,#+106
   \   00000012   0x880A             LDRH     R2,[R1, #+0]
   \   00000014   0x1E52             SUBS     R2,R2,#+1
   \   00000016   0x800A             STRH     R2,[R1, #+0]
   1786            
   1787            /* Check end of the transfer */  
   1788            if(hsai->XferCount == 0)
   \   00000018   0xB292             UXTH     R2,R2
   \   0000001A   0xB102             CBZ.N    R2,??SAI_Receive_IT16Bit_0
   \   0000001C   0x4770             BX       LR
   1789            {    
   1790              /* Disable TXE and OVRUDR interrupts */
   1791              __HAL_SAI_DISABLE_IT(hsai, SAI_InterruptFlag(hsai, SAI_MODE_IT));
   \                     ??SAI_Receive_IT16Bit_0: (+1)
   \   0000001E   0xB510             PUSH     {R4,LR}
   \   00000020   0x6B03             LDR      R3,[R0, #+48]
   \   00000022   0x2209             MOVS     R2,#+9
   \   00000024   0x2B08             CMP      R3,#+8
   \   00000026   0xD10A             BNE.N    ??SAI_Receive_IT16Bit_1
   \   00000028   0x6843             LDR      R3,[R0, #+4]
   \   0000002A   0x2B03             CMP      R3,#+3
   \   0000002C   0xD103             BNE.N    ??SAI_Receive_IT16Bit_2
   \   0000002E   0x2219             MOVS     R2,#+25
   \                     ??SAI_Receive_IT16Bit_3: (+1)
   \   00000030   0xF042 0x0260      ORR      R2,R2,#0x60
   \                     ??SAI_Receive_IT16Bit_4: (+1)
   \   00000034   0x....             B.N      ?Subroutine0
   \                     ??SAI_Receive_IT16Bit_2: (+1)
   \   00000036   0x2B01             CMP      R3,#+1
   \   00000038   0xBF08             IT       EQ 
   \   0000003A   0x2219             MOVEQ    R2,#+25
   \   0000003C   0xD004             BEQ.N    ??SAI_Receive_IT16Bit_5
   \                     ??SAI_Receive_IT16Bit_1: (+1)
   \   0000003E   0x6843             LDR      R3,[R0, #+4]
   \   00000040   0x2B03             CMP      R3,#+3
   \   00000042   0xBF18             IT       NE 
   \   00000044   0x2B02             CMPNE    R3,#+2
   \   00000046   0xD0F3             BEQ.N    ??SAI_Receive_IT16Bit_3
   \                     ??SAI_Receive_IT16Bit_5: (+1)
   \   00000048   0xF042 0x0204      ORR      R2,R2,#0x4
   \   0000004C   0xE7F2             B.N      ??SAI_Receive_IT16Bit_4
   1792              
   1793              /* Clear the SAI Overrun flag */
   1794              __HAL_SAI_CLEAR_FLAG(hsai, SAI_FLAG_OVRUDR);
   1795              
   1796              hsai->State = HAL_SAI_STATE_READY;
   1797              HAL_SAI_RxCpltCallback(hsai); 
   1798            }
   1799          }
   1800          /**
   1801            * @brief  Rx Handler for Receive in Interrupt mode for 32Bit transfer
   1802            * @param  hsai : pointer to a SAI_HandleTypeDef structure that contains
   1803            *                the configuration information for SAI module.
   1804            * @retval None.
   1805            */

   \                                 In section .text, align 4, keep-with-next
   1806          static void SAI_Receive_IT32Bit(SAI_HandleTypeDef *hsai)
   1807          {
   1808            /* Receive data */    
   1809            *(uint32_t*)hsai->pBuffPtr = hsai->Instance->DR;
   \                     SAI_Receive_IT32Bit: (+1)
   \   00000000   0x6801             LDR      R1,[R0, #+0]
   \   00000002   0x69C9             LDR      R1,[R1, #+28]
   \   00000004   0x6E42             LDR      R2,[R0, #+100]
   \   00000006   0x6011             STR      R1,[R2, #+0]
   1810            hsai->pBuffPtr+=4;
   \   00000008   0x6E41             LDR      R1,[R0, #+100]
   \   0000000A   0x1D09             ADDS     R1,R1,#+4
   \   0000000C   0x6641             STR      R1,[R0, #+100]
   1811            hsai->XferCount--;
   \   0000000E   0xF100 0x016A      ADD      R1,R0,#+106
   \   00000012   0x880A             LDRH     R2,[R1, #+0]
   \   00000014   0x1E52             SUBS     R2,R2,#+1
   \   00000016   0x800A             STRH     R2,[R1, #+0]
   1812            
   1813            /* Check end of the transfer */  
   1814            if(hsai->XferCount == 0)
   \   00000018   0xB292             UXTH     R2,R2
   \   0000001A   0xB102             CBZ.N    R2,??SAI_Receive_IT32Bit_0
   \   0000001C   0x4770             BX       LR
   1815            {    
   1816              /* Disable TXE and OVRUDR interrupts */
   1817              __HAL_SAI_DISABLE_IT(hsai, SAI_InterruptFlag(hsai, SAI_MODE_IT));
   \                     ??SAI_Receive_IT32Bit_0: (+1)
   \   0000001E   0xB510             PUSH     {R4,LR}
   \   00000020   0x6B03             LDR      R3,[R0, #+48]
   \   00000022   0x2209             MOVS     R2,#+9
   \   00000024   0x2B08             CMP      R3,#+8
   \   00000026   0xD10A             BNE.N    ??SAI_Receive_IT32Bit_1
   \   00000028   0x6843             LDR      R3,[R0, #+4]
   \   0000002A   0x2B03             CMP      R3,#+3
   \   0000002C   0xD103             BNE.N    ??SAI_Receive_IT32Bit_2
   \   0000002E   0x2219             MOVS     R2,#+25
   \                     ??SAI_Receive_IT32Bit_3: (+1)
   \   00000030   0xF042 0x0260      ORR      R2,R2,#0x60
   \                     ??SAI_Receive_IT32Bit_4: (+1)
   \   00000034   0x....             B.N      ?Subroutine0
   \                     ??SAI_Receive_IT32Bit_2: (+1)
   \   00000036   0x2B01             CMP      R3,#+1
   \   00000038   0xBF08             IT       EQ 
   \   0000003A   0x2219             MOVEQ    R2,#+25
   \   0000003C   0xD004             BEQ.N    ??SAI_Receive_IT32Bit_5
   \                     ??SAI_Receive_IT32Bit_1: (+1)
   \   0000003E   0x6843             LDR      R3,[R0, #+4]
   \   00000040   0x2B03             CMP      R3,#+3
   \   00000042   0xBF18             IT       NE 
   \   00000044   0x2B02             CMPNE    R3,#+2
   \   00000046   0xD0F3             BEQ.N    ??SAI_Receive_IT32Bit_3
   \                     ??SAI_Receive_IT32Bit_5: (+1)
   \   00000048   0xF042 0x0204      ORR      R2,R2,#0x4
   \   0000004C   0xE7F2             B.N      ??SAI_Receive_IT32Bit_4
   1818              
   1819              /* Clear the SAI Overrun flag */
   1820              __HAL_SAI_CLEAR_FLAG(hsai, SAI_FLAG_OVRUDR);
   1821              
   1822              hsai->State = HAL_SAI_STATE_READY;
   1823              HAL_SAI_RxCpltCallback(hsai); 
   1824            }
   1825          }
   1826          
   1827          /**
   1828            * @brief DMA SAI transmit process complete callback.
   1829            * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
   1830            *                the configuration information for the specified DMA module.
   1831            * @retval None
   1832            */

   \                                 In section .text, align 4, keep-with-next
   1833          static void SAI_DMATxCplt(DMA_HandleTypeDef *hdma)   
   1834          {
   \                     SAI_DMATxCplt: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   1835            SAI_HandleTypeDef* hsai = (SAI_HandleTypeDef*)((DMA_HandleTypeDef* )hdma)->Parent;
   \   00000002   0x6B81             LDR      R1,[R0, #+56]
   1836            
   1837            if((hdma->Instance->CR & DMA_SxCR_CIRC) == 0)
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0x05C0             LSLS     R0,R0,#+23
   \   0000000A   0xD419             BMI.N    ??SAI_DMATxCplt_0
   1838            { 
   1839              hsai->XferCount = 0;
   \   0000000C   0xF101 0x006A      ADD      R0,R1,#+106
   \   00000010   0x2200             MOVS     R2,#+0
   \   00000012   0x8002             STRH     R2,[R0, #+0]
   1840              
   1841              /* Disable SAI Tx DMA Request */  
   1842              hsai->Instance->CR1 &= (uint32_t)(~SAI_xCR1_DMAEN);
   \   00000014   0x680A             LDR      R2,[R1, #+0]
   \   00000016   0x6813             LDR      R3,[R2, #+0]
   \   00000018   0xF423 0x3300      BIC      R3,R3,#0x20000
   \   0000001C   0x6013             STR      R3,[R2, #+0]
   1843          
   1844              /* Stop the interrupts error handling */
   1845              __HAL_SAI_DISABLE_IT(hsai, SAI_InterruptFlag(hsai, SAI_MODE_DMA));
   \   0000001E   0x6B0B             LDR      R3,[R1, #+48]
   \   00000020   0x2201             MOVS     R2,#+1
   \   00000022   0x2B08             CMP      R3,#+8
   \   00000024   0xD112             BNE.N    ??SAI_DMATxCplt_1
   \   00000026   0x684B             LDR      R3,[R1, #+4]
   \   00000028   0x2B03             CMP      R3,#+3
   \   0000002A   0xD10B             BNE.N    ??SAI_DMATxCplt_2
   \   0000002C   0x2211             MOVS     R2,#+17
   \                     ??SAI_DMATxCplt_3: (+1)
   \   0000002E   0xF042 0x0260      ORR      R2,R2,#0x60
   \                     ??SAI_DMATxCplt_4: (+1)
   \   00000032   0x680B             LDR      R3,[R1, #+0]
   \   00000034   0x691C             LDR      R4,[R3, #+16]
   \   00000036   0xEA24 0x0202      BIC      R2,R4,R2
   \   0000003A   0x611A             STR      R2,[R3, #+16]
   1846              
   1847              hsai->State= HAL_SAI_STATE_READY;
   \   0000003C   0x2201             MOVS     R2,#+1
   \   0000003E   0x74C2             STRB     R2,[R0, #+19]
   1848            }
   1849            HAL_SAI_TxCpltCallback(hsai);
   \                     ??SAI_DMATxCplt_0: (+1)
   \   00000040   0x4608             MOV      R0,R1
   \   00000042   0x....             B.N      ??Subroutine11_0
   \                     ??SAI_DMATxCplt_2: (+1)
   \   00000044   0x2B01             CMP      R3,#+1
   \   00000046   0xBF08             IT       EQ 
   \   00000048   0x2211             MOVEQ    R2,#+17
   \   0000004A   0xD004             BEQ.N    ??SAI_DMATxCplt_5
   \                     ??SAI_DMATxCplt_1: (+1)
   \   0000004C   0x684B             LDR      R3,[R1, #+4]
   \   0000004E   0x2B03             CMP      R3,#+3
   \   00000050   0xBF18             IT       NE 
   \   00000052   0x2B02             CMPNE    R3,#+2
   \   00000054   0xD0EB             BEQ.N    ??SAI_DMATxCplt_3
   \                     ??SAI_DMATxCplt_5: (+1)
   \   00000056   0xF042 0x0204      ORR      R2,R2,#0x4
   \   0000005A   0xE7EA             B.N      ??SAI_DMATxCplt_4
   1850          }
   1851          
   1852          /**
   1853            * @brief DMA SAI transmit process half complete callback 
   1854            * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
   1855            *                the configuration information for the specified DMA module.
   1856            * @retval None
   1857            */

   \                                 In section .text, align 4, keep-with-next
   1858          static void SAI_DMATxHalfCplt(DMA_HandleTypeDef *hdma)
   1859          {
   \                     SAI_DMATxHalfCplt: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1860            SAI_HandleTypeDef* hsai = (SAI_HandleTypeDef*)((DMA_HandleTypeDef*)hdma)->Parent;
   1861          
   1862            HAL_SAI_TxHalfCpltCallback(hsai);
   \   00000002   0x6B80             LDR      R0,[R0, #+56]
   \   00000004   0x.... 0x....      BL       HAL_SAI_TxHalfCpltCallback
   1863          }
   \   00000008   0xBD01             POP      {R0,PC}          ;; return
   1864          
   1865          /**
   1866            * @brief DMA SAI receive process complete callback. 
   1867            * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
   1868            *                the configuration information for the specified DMA module.
   1869            * @retval None
   1870            */

   \                                 In section .text, align 4, keep-with-next
   1871          static void SAI_DMARxCplt(DMA_HandleTypeDef *hdma)   
   1872          {
   \                     SAI_DMARxCplt: (+1)
   \   00000000   0x4601             MOV      R1,R0
   \   00000002   0xB510             PUSH     {R4,LR}
   1873            SAI_HandleTypeDef* hsai = ( SAI_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   \   00000004   0x6B88             LDR      R0,[R1, #+56]
   1874            if((hdma->Instance->CR & DMA_SxCR_CIRC) == 0)
   \   00000006   0x6809             LDR      R1,[R1, #+0]
   \   00000008   0x6809             LDR      R1,[R1, #+0]
   \   0000000A   0x05C9             LSLS     R1,R1,#+23
   \   0000000C   0xD419             BMI.N    ??SAI_DMARxCplt_0
   1875            {
   1876              /* Disable Rx DMA Request */
   1877              hsai->Instance->CR1 &= (uint32_t)(~SAI_xCR1_DMAEN);
   \   0000000E   0x6801             LDR      R1,[R0, #+0]
   \   00000010   0x680A             LDR      R2,[R1, #+0]
   \   00000012   0xF422 0x3200      BIC      R2,R2,#0x20000
   \   00000016   0x600A             STR      R2,[R1, #+0]
   1878              hsai->XferCount = 0;
   \   00000018   0xF100 0x016A      ADD      R1,R0,#+106
   \   0000001C   0x2200             MOVS     R2,#+0
   \   0000001E   0x800A             STRH     R2,[R1, #+0]
   1879              
   1880              /* Stop the interrupts error handling */
   1881              __HAL_SAI_DISABLE_IT(hsai, SAI_InterruptFlag(hsai, SAI_MODE_DMA));
   \   00000020   0x6B03             LDR      R3,[R0, #+48]
   \   00000022   0x2201             MOVS     R2,#+1
   \   00000024   0x2B08             CMP      R3,#+8
   \   00000026   0xD111             BNE.N    ??SAI_DMARxCplt_1
   \   00000028   0x6843             LDR      R3,[R0, #+4]
   \   0000002A   0x2B03             CMP      R3,#+3
   \   0000002C   0xD10A             BNE.N    ??SAI_DMARxCplt_2
   \   0000002E   0x2211             MOVS     R2,#+17
   \                     ??SAI_DMARxCplt_3: (+1)
   \   00000030   0xF042 0x0260      ORR      R2,R2,#0x60
   \                     ??SAI_DMARxCplt_4: (+1)
   \   00000034   0x6803             LDR      R3,[R0, #+0]
   \   00000036   0x691C             LDR      R4,[R3, #+16]
   \   00000038   0xEA24 0x0202      BIC      R2,R4,R2
   \   0000003C   0x611A             STR      R2,[R3, #+16]
   1882              
   1883              hsai->State = HAL_SAI_STATE_READY;
   \   0000003E   0x2201             MOVS     R2,#+1
   \   00000040   0x74CA             STRB     R2,[R1, #+19]
   1884            }
   1885            HAL_SAI_RxCpltCallback(hsai); 
   \                     ??SAI_DMARxCplt_0: (+1)
   \   00000042   0x....             B.N      ??Subroutine12_0
   \                     ??SAI_DMARxCplt_2: (+1)
   \   00000044   0x2B01             CMP      R3,#+1
   \   00000046   0xBF08             IT       EQ 
   \   00000048   0x2211             MOVEQ    R2,#+17
   \   0000004A   0xD004             BEQ.N    ??SAI_DMARxCplt_5
   \                     ??SAI_DMARxCplt_1: (+1)
   \   0000004C   0x6843             LDR      R3,[R0, #+4]
   \   0000004E   0x2B03             CMP      R3,#+3
   \   00000050   0xBF18             IT       NE 
   \   00000052   0x2B02             CMPNE    R3,#+2
   \   00000054   0xD0EC             BEQ.N    ??SAI_DMARxCplt_3
   \                     ??SAI_DMARxCplt_5: (+1)
   \   00000056   0xF042 0x0204      ORR      R2,R2,#0x4
   \   0000005A   0xE7EB             B.N      ??SAI_DMARxCplt_4
   1886          }
   1887          
   1888          /**
   1889            * @brief DMA SAI receive process half complete callback 
   1890            * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
   1891            *                the configuration information for the specified DMA module.
   1892            * @retval None
   1893            */

   \                                 In section .text, align 4, keep-with-next
   1894          static void SAI_DMARxHalfCplt(DMA_HandleTypeDef *hdma)
   1895          {
   \                     SAI_DMARxHalfCplt: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1896            SAI_HandleTypeDef* hsai = (SAI_HandleTypeDef*)((DMA_HandleTypeDef*)hdma)->Parent;
   1897          
   1898            HAL_SAI_RxHalfCpltCallback(hsai); 
   \   00000002   0x6B80             LDR      R0,[R0, #+56]
   \   00000004   0x.... 0x....      BL       HAL_SAI_RxHalfCpltCallback
   1899          }
   \   00000008   0xBD01             POP      {R0,PC}          ;; return
   1900          /**
   1901            * @brief DMA SAI communication error callback. 
   1902            * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
   1903            *                the configuration information for the specified DMA module.
   1904            * @retval None
   1905            */

   \                                 In section .text, align 4, keep-with-next
   1906          static void SAI_DMAError(DMA_HandleTypeDef *hdma)   
   1907          {
   \                     SAI_DMAError: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   1908            SAI_HandleTypeDef* hsai = ( SAI_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   \   00000002   0x6B84             LDR      R4,[R0, #+56]
   1909            
   1910            /* Stop the DMA transfer */
   1911            HAL_SAI_DMAStop(hsai);
   \   00000004   0x4620             MOV      R0,R4
   \   00000006   0x.... 0x....      BL       HAL_SAI_DMAStop
   1912            
   1913            /* Set the SAI state ready to be able to start again the process */
   1914            hsai->State= HAL_SAI_STATE_READY;
   \   0000000A   0xF104 0x056A      ADD      R5,R4,#+106
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0x74E8             STRB     R0,[R5, #+19]
   1915            HAL_SAI_ErrorCallback(hsai);
   \   00000012   0x4620             MOV      R0,R4
   \   00000014   0x.... 0x....      BL       HAL_SAI_ErrorCallback
   1916            
   1917            hsai->XferCount = 0;
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x8028             STRH     R0,[R5, #+0]
   1918          }
   \   0000001C   0xBD31             POP      {R0,R4,R5,PC}    ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0:
   \   00000000   0xFF05C010         DC32     0xff05c010

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_1:
   \   00000000   0xFFFF1FF0         DC32     0xffff1ff0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_2:
   \   00000000   0xFFF88000         DC32     0xfff88000
   1919          
   1920          /**
   1921            * @}
   1922            */
   1923          
   1924          #endif /* HAL_SAI_MODULE_ENABLED */
   1925          /**
   1926            * @}
   1927            */
   1928          
   1929          /**
   1930            * @}
   1931            */
   1932          
   1933          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   HAL_SAI_Abort
         8   -> HAL_DMA_Abort
         8   -> SAI_Disable
       0   HAL_SAI_DMAPause
       0   HAL_SAI_DMAResume
      16   HAL_SAI_DMAStop
        16   -> HAL_DMA_Abort
        16   -> SAI_Disable
      16   HAL_SAI_DeInit
        16   -> HAL_GetTick
        16   -> HAL_SAI_MspDeInit
       0   HAL_SAI_DisableRxMuteMode
       0   HAL_SAI_DisableTxMuteMode
       4   HAL_SAI_EnableRxMuteMode
       0   HAL_SAI_EnableTxMuteMode
       0   HAL_SAI_ErrorCallback
       0   HAL_SAI_GetError
       0   HAL_SAI_GetState
      16   HAL_SAI_IRQHandler
        16   -- Indirect call
        16   -> HAL_SAI_Abort
        16   -> HAL_SAI_ErrorCallback
      16   HAL_SAI_Init
        16   -> HAL_SAI_MspInit
        16   -> SAI_BlockSynchroConfig
        16   -> SAI_Disable
        16   -> SAI_GetInputClock
       8   HAL_SAI_InitProtocol
         0   -> HAL_SAI_Init
         8   -> SAI_InitI2S
       0   HAL_SAI_MspDeInit
       0   HAL_SAI_MspInit
      32   HAL_SAI_Receive
        32   -> HAL_GetTick
      16   HAL_SAI_Receive_DMA
        16   -> HAL_DMA_Start_IT
       4   HAL_SAI_Receive_IT
       0   HAL_SAI_RxCpltCallback
       0   HAL_SAI_RxHalfCpltCallback
      32   HAL_SAI_Transmit
        32   -> HAL_GetTick
        32   -> SAI_FillFifo
      16   HAL_SAI_Transmit_DMA
        16   -> HAL_DMA_Start_IT
      16   HAL_SAI_Transmit_IT
        16   -> SAI_FillFifo
        16   -> SAI_InterruptFlag
       0   HAL_SAI_TxCpltCallback
       0   HAL_SAI_TxHalfCpltCallback
      16   SAI_DMAError
        16   -> HAL_SAI_DMAStop
        16   -> HAL_SAI_ErrorCallback
       8   SAI_DMARxCplt
         8   -> HAL_SAI_RxCpltCallback
       8   SAI_DMARxHalfCplt
         8   -> HAL_SAI_RxHalfCpltCallback
       8   SAI_DMATxCplt
         8   -> HAL_SAI_TxCpltCallback
       8   SAI_DMATxHalfCplt
         8   -> HAL_SAI_TxHalfCpltCallback
      16   SAI_Disable
        16   -> HAL_GetTick
       8   SAI_FillFifo
       4   SAI_InitI2S
       0   SAI_InterruptFlag
       8   SAI_Receive_IT16Bit
         8   -> HAL_SAI_RxCpltCallback
       8   SAI_Receive_IT32Bit
         8   -> HAL_SAI_RxCpltCallback
       8   SAI_Receive_IT8Bit
         8   -> HAL_SAI_RxCpltCallback
       8   SAI_Transmit_IT16Bit
         8   -> HAL_SAI_TxCpltCallback
       8   SAI_Transmit_IT32Bit
         8   -> HAL_SAI_TxCpltCallback
       8   SAI_Transmit_IT8Bit
         8   -> HAL_SAI_TxCpltCallback


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable0
       4  ??DataTable0_1
       4  ??DataTable0_2
       6  ??Subroutine10_0
       6  ??Subroutine11_0
       6  ??Subroutine12_0
      18  ?Subroutine0
      14  ?Subroutine1
      10  ?Subroutine2
      16  ?Subroutine3
      12  ?Subroutine4
      18  ?Subroutine5
      10  ?Subroutine6
       6  ?Subroutine7
       6  ?Subroutine8
       6  ?Subroutine9
      84  HAL_SAI_Abort
      30  HAL_SAI_DMAPause
      42  HAL_SAI_DMAResume
      72  HAL_SAI_DMAStop
     100  HAL_SAI_DeInit
      28  HAL_SAI_DisableRxMuteMode
      20  HAL_SAI_DisableTxMuteMode
      42  HAL_SAI_EnableRxMuteMode
      32  HAL_SAI_EnableTxMuteMode
       2  HAL_SAI_ErrorCallback
       6  HAL_SAI_GetError
       6  HAL_SAI_GetState
     202  HAL_SAI_IRQHandler
     294  HAL_SAI_Init
     138  HAL_SAI_InitProtocol
       2  HAL_SAI_MspDeInit
       2  HAL_SAI_MspInit
     184  HAL_SAI_Receive
     156  HAL_SAI_Receive_DMA
     160  HAL_SAI_Receive_IT
       2  HAL_SAI_RxCpltCallback
       2  HAL_SAI_RxHalfCpltCallback
     196  HAL_SAI_Transmit
     154  HAL_SAI_Transmit_DMA
     126  HAL_SAI_Transmit_IT
       2  HAL_SAI_TxCpltCallback
       2  HAL_SAI_TxHalfCpltCallback
      30  SAI_DMAError
      92  SAI_DMARxCplt
      10  SAI_DMARxHalfCplt
      92  SAI_DMATxCplt
      10  SAI_DMATxHalfCplt
      58  SAI_Disable
      84  SAI_FillFifo
     170  SAI_InitI2S
      54  SAI_InterruptFlag
      78  SAI_Receive_IT16Bit
      78  SAI_Receive_IT32Bit
      76  SAI_Receive_IT8Bit
      70  SAI_Transmit_IT16Bit
      68  SAI_Transmit_IT32Bit
      70  SAI_Transmit_IT8Bit

 
 3 272 bytes in section .text
 
 3 272 bytes of CODE memory

Errors: none
Warnings: none
