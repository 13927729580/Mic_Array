###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.2.10312/W32 for ARM       16/Apr/2016  18:31:01
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_rcc_ex.c
#    Command line =  
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_rcc_ex.c
#        -D USE_HAL_DRIVER -D STM32F746xx -D USE_STM32746G_DISCO -D
#        USE_IOEXPANDER -D USE_USB_FS -lC
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
#        -lA
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
#        -o
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj
#        --no_unroll --debug --endian=little --cpu=Cortex-M7 -e --fpu=VFPv5_sp
#        --dlib_config "D:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Full.h" -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\CMSIS\Device\ST\STM32F7xx\Include\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\STM32F7xx_HAL_Driver\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\STM32746G-Discovery\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\Components\Common\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Log\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Fonts\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\CPU\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_Device_Library\Core\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Core\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Class\MSC\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\drivers\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_Audio\Addons\PDM\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_Device_Library\Class\AUDIO\Inc\
#        -Oh --use_c++_inline --require_prototypes -I "D:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.3\arm\CMSIS\Include\" -D
#        ARM_MATH_CM7 --relaxed_fp
#    List file    =  
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List\stm32f7xx_hal_rcc_ex.lst
#    Object file  =  
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj\stm32f7xx_hal_rcc_ex.o
#
###############################################################################

D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_rcc_ex.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f7xx_hal_rcc_ex.c
      4            * @author  MCD Application Team
      5            * @version V1.0.4
      6            * @date    09-December-2015
      7            * @brief   Extension RCC HAL module driver.
      8            *          This file provides firmware functions to manage the following 
      9            *          functionalities RCC extension peripheral:
     10            *           + Extended Peripheral Control functions
     11            *  
     12            ******************************************************************************
     13            * @attention
     14            *
     15            * <h2><center>&copy; COPYRIGHT(c) 2015 STMicroelectronics</center></h2>
     16            *
     17            * Redistribution and use in source and binary forms, with or without modification,
     18            * are permitted provided that the following conditions are met:
     19            *   1. Redistributions of source code must retain the above copyright notice,
     20            *      this list of conditions and the following disclaimer.
     21            *   2. Redistributions in binary form must reproduce the above copyright notice,
     22            *      this list of conditions and the following disclaimer in the documentation
     23            *      and/or other materials provided with the distribution.
     24            *   3. Neither the name of STMicroelectronics nor the names of its contributors
     25            *      may be used to endorse or promote products derived from this software
     26            *      without specific prior written permission.
     27            *
     28            * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
     29            * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     30            * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     31            * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
     32            * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
     33            * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
     34            * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
     35            * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
     36            * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
     37            * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     38            *
     39            ******************************************************************************
     40            */ 
     41          
     42          /* Includes ------------------------------------------------------------------*/
     43          #include "stm32f7xx_hal.h"
     44          
     45          /** @addtogroup STM32F7xx_HAL_Driver
     46            * @{
     47            */
     48          
     49          /** @defgroup RCCEx RCCEx
     50            * @brief RCCEx HAL module driver
     51            * @{
     52            */
     53          
     54          #ifdef HAL_RCC_MODULE_ENABLED
     55          
     56          /* Private typedef -----------------------------------------------------------*/
     57          /* Private define ------------------------------------------------------------*/
     58          /** @defgroup RCCEx_Private_Defines RCCEx Private Defines
     59            * @{
     60            */
     61            
     62          #define PLLI2S_TIMEOUT_VALUE    100 /* Timeout value fixed to 100 ms  */
     63          #define PLLSAI_TIMEOUT_VALUE    100 /* Timeout value fixed to 100 ms  */
     64          
     65          /**
     66            * @}
     67            */
     68          /* Private macro -------------------------------------------------------------*/
     69          /** @defgroup RCCEx_Private_Macros RCCEx Private Macros
     70           * @{
     71           */
     72          /**
     73            * @}
     74            */
     75          
     76          /** @defgroup RCCEx_Private_Macros RCCEx Private Macros
     77           * @{
     78           */
     79          
     80          /**
     81            * @}
     82            */
     83          
     84          
     85          /* Private variables ---------------------------------------------------------*/
     86          /* Private function prototypes -----------------------------------------------*/
     87          /* Private functions ---------------------------------------------------------*/
     88          
     89          /** @defgroup RCCEx_Exported_Functions RCCEx Exported Functions
     90            * @{
     91            */
     92          
     93          /** @defgroup RCCEx_Exported_Functions_Group1 Extended Peripheral Control functions 
     94           *  @brief  Extended Peripheral Control functions  
     95           *
     96          @verbatim   
     97           ===============================================================================
     98                          ##### Extended Peripheral Control functions  #####
     99           ===============================================================================  
    100              [..]
    101              This subsection provides a set of functions allowing to control the RCC Clocks 
    102              frequencies.
    103              [..] 
    104              (@) Important note: Care must be taken when HAL_RCCEx_PeriphCLKConfig() is used to
    105                  select the RTC clock source; in this case the Backup domain will be reset in  
    106                  order to modify the RTC Clock source, as consequence RTC registers (including 
    107                  the backup registers) and RCC_BDCR register will be set to their reset values.
    108                
    109          @endverbatim
    110            * @{
    111            */
    112          /**
    113            * @brief  Initializes the RCC extended peripherals clocks according to the specified
    114            *         parameters in the RCC_PeriphCLKInitTypeDef.
    115            * @param  PeriphClkInit: pointer to an RCC_PeriphCLKInitTypeDef structure that
    116            *         contains the configuration information for the Extended Peripherals
    117            *         clocks(I2S, SAI, LTDC RTC, TIM, UARTs, USARTs, LTPIM, SDMMC...).
    118            *         
    119            * @note   Care must be taken when HAL_RCCEx_PeriphCLKConfig() is used to select 
    120            *         the RTC clock source; in this case the Backup domain will be reset in  
    121            *         order to modify the RTC Clock source, as consequence RTC registers (including 
    122            *         the backup registers) and RCC_BDCR register are set to their reset values.
    123            *
    124            * @retval HAL status
    125            */

   \                                 In section .text, align 2, keep-with-next
    126          HAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
    127          {
   \                     HAL_RCCEx_PeriphCLKConfig: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0xB082             SUB      SP,SP,#+8
    128            uint32_t tickstart = 0;
    129            uint32_t tmpreg0 = 0;
    130            uint32_t tmpreg1 = 0;
    131            uint32_t plli2sused = 0;
   \   00000008   0x2700             MOVS     R7,#+0
    132            uint32_t pllsaiused = 0;
   \   0000000A   0x46B8             MOV      R8,R7
    133              
    134            /* Check the parameters */
    135            assert_param(IS_RCC_PERIPHCLOCK(PeriphClkInit->PeriphClockSelection));
    136            
    137            /*----------------------------------- I2S configuration ----------------------------------*/
    138            if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S) == (RCC_PERIPHCLK_I2S))
   \   0000000C   0x7820             LDRB     R0,[R4, #+0]
   \   0000000E   0x.... 0x....      LDR.W    R5,??DataTable2  ;; 0x40023800
   \   00000012   0x07C0             LSLS     R0,R0,#+31
   \   00000014   0xD50A             BPL.N    ??HAL_RCCEx_PeriphCLKConfig_0
    139            {
    140              /* Check the parameters */
    141              assert_param(IS_RCC_I2SCLKSOURCE(PeriphClkInit->I2sClockSelection));
    142              
    143              /* Configure I2S Clock source */
    144              __HAL_RCC_I2S_CONFIG(PeriphClkInit->I2sClockSelection);
   \   00000016   0x68A8             LDR      R0,[R5, #+8]
   \   00000018   0xF420 0x0000      BIC      R0,R0,#0x800000
   \   0000001C   0x60A8             STR      R0,[R5, #+8]
   \   0000001E   0x68A8             LDR      R0,[R5, #+8]
   \   00000020   0x6B61             LDR      R1,[R4, #+52]
   \   00000022   0x4308             ORRS     R0,R1,R0
   \   00000024   0x60A8             STR      R0,[R5, #+8]
    145              
    146              /* Enable the PLLI2S when it's used as clock source for I2S */
    147              if(PeriphClkInit->I2sClockSelection == RCC_I2SCLKSOURCE_PLLI2S)
   \   00000026   0x6B60             LDR      R0,[R4, #+52]
   \   00000028   0xB900             CBNZ.N   R0,??HAL_RCCEx_PeriphCLKConfig_0
    148              {
    149                plli2sused = 1; 
   \   0000002A   0x2701             MOVS     R7,#+1
    150              }
    151            }
    152            
    153            /*------------------------------------ SAI1 configuration --------------------------------------*/
    154            if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == (RCC_PERIPHCLK_SAI1))
   \                     ??HAL_RCCEx_PeriphCLKConfig_0: (+1)
   \   0000002C   0x6820             LDR      R0,[R4, #+0]
   \   0000002E   0x.... 0x....      LDR.W    R6,??DataTable2_1  ;; 0x40023884
   \   00000032   0x0300             LSLS     R0,R0,#+12
   \   00000034   0xD50E             BPL.N    ??HAL_RCCEx_PeriphCLKConfig_1
    155            {
    156              /* Check the parameters */
    157              assert_param(IS_RCC_SAI1CLKSOURCE(PeriphClkInit->Sai1ClockSelection));
    158              
    159              /* Configure SAI1 Clock source */
    160              __HAL_RCC_SAI1_CONFIG(PeriphClkInit->Sai1ClockSelection);
   \   00000036   0x68B0             LDR      R0,[R6, #+8]
   \   00000038   0x6BE1             LDR      R1,[R4, #+60]
   \   0000003A   0xF420 0x1040      BIC      R0,R0,#0x300000
   \   0000003E   0x4308             ORRS     R0,R1,R0
   \   00000040   0x60B0             STR      R0,[R6, #+8]
    161              /* Enable the PLLI2S when it's used as clock source for SAI */
    162              if(PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_PLLI2S)
   \   00000042   0x6BE0             LDR      R0,[R4, #+60]
   \   00000044   0xF5B0 0x1F80      CMP      R0,#+1048576
   \   00000048   0xBF08             IT       EQ 
   \   0000004A   0x2701             MOVEQ    R7,#+1
   \   0000004C   0xD002             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_1
    163              {
    164                plli2sused = 1; 
    165              }
    166              /* Enable the PLLSAI when it's used as clock source for SAI */
    167              if(PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_PLLSAI)
   \   0000004E   0xB908             CBNZ.N   R0,??HAL_RCCEx_PeriphCLKConfig_1
    168              {
    169                pllsaiused = 1; 
   \   00000050   0xF04F 0x0801      MOV      R8,#+1
    170              }
    171            }
    172            
    173            /*------------------------------------ SAI2 configuration --------------------------------------*/
    174            if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI2) == (RCC_PERIPHCLK_SAI2))
   \                     ??HAL_RCCEx_PeriphCLKConfig_1: (+1)
   \   00000054   0x6820             LDR      R0,[R4, #+0]
   \   00000056   0x02C0             LSLS     R0,R0,#+11
   \   00000058   0xD50E             BPL.N    ??HAL_RCCEx_PeriphCLKConfig_2
    175            {
    176              /* Check the parameters */
    177              assert_param(IS_RCC_SAI2CLKSOURCE(PeriphClkInit->Sai2ClockSelection));
    178              
    179              /* Configure SAI2 Clock source */
    180              __HAL_RCC_SAI2_CONFIG(PeriphClkInit->Sai2ClockSelection);
   \   0000005A   0x68B0             LDR      R0,[R6, #+8]
   \   0000005C   0x6C21             LDR      R1,[R4, #+64]
   \   0000005E   0xF420 0x0040      BIC      R0,R0,#0xC00000
   \   00000062   0x4308             ORRS     R0,R1,R0
   \   00000064   0x60B0             STR      R0,[R6, #+8]
    181              
    182              /* Enable the PLLI2S when it's used as clock source for SAI */
    183              if(PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_PLLI2S)
   \   00000066   0x6C20             LDR      R0,[R4, #+64]
   \   00000068   0xF5B0 0x0F80      CMP      R0,#+4194304
   \   0000006C   0xBF08             IT       EQ 
   \   0000006E   0x2701             MOVEQ    R7,#+1
   \   00000070   0xD002             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_2
    184              {
    185                plli2sused = 1; 
    186              }
    187              /* Enable the PLLSAI when it's used as clock source for SAI */
    188              if(PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_PLLSAI)
   \   00000072   0xB908             CBNZ.N   R0,??HAL_RCCEx_PeriphCLKConfig_2
    189              {
    190                pllsaiused = 1; 
   \   00000074   0xF04F 0x0801      MOV      R8,#+1
    191              }
    192            }
    193            
    194            /*-------------------------------------- SPDIF-RX Configuration -----------------------------------*/
    195            if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPDIFRX) == RCC_PERIPHCLK_SPDIFRX)
   \                     ??HAL_RCCEx_PeriphCLKConfig_2: (+1)
   \   00000078   0x6820             LDR      R0,[R4, #+0]
   \   0000007A   0x01C1             LSLS     R1,R0,#+7
   \   0000007C   0xBF48             IT       MI 
   \   0000007E   0x2701             MOVMI    R7,#+1
    196            {    
    197                plli2sused = 1; 
    198            }  
    199            
    200            /*------------------------------------ RTC configuration --------------------------------------*/
    201            if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RTC) == (RCC_PERIPHCLK_RTC))
   \   00000080   0x0680             LSLS     R0,R0,#+26
   \   00000082   0xD55D             BPL.N    ??HAL_RCCEx_PeriphCLKConfig_3
    202            {
    203              /* Enable Power Clock*/
    204              __HAL_RCC_PWR_CLK_ENABLE();
   \   00000084   0x2000             MOVS     R0,#+0
    205                
    206              /* Enable write access to Backup domain */
    207              PWR->CR1 |= PWR_CR1_DBP;
   \   00000086   0x.... 0x....      LDR.W    R9,??DataTable2_2  ;; 0x40007000
   \   0000008A   0x9000             STR      R0,[SP, #+0]
   \   0000008C   0x6C28             LDR      R0,[R5, #+64]
   \   0000008E   0xF040 0x5080      ORR      R0,R0,#0x10000000
   \   00000092   0x6428             STR      R0,[R5, #+64]
   \   00000094   0x6C28             LDR      R0,[R5, #+64]
   \   00000096   0xF000 0x5080      AND      R0,R0,#0x10000000
   \   0000009A   0x9000             STR      R0,[SP, #+0]
   \   0000009C   0x9800             LDR      R0,[SP, #+0]
   \   0000009E   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \   000000A2   0xF440 0x7080      ORR      R0,R0,#0x100
   \   000000A6   0xF8C9 0x0000      STR      R0,[R9, #+0]
    208                
    209              /* Get Start Tick*/
    210              tickstart = HAL_GetTick();
   \   000000AA   0x.... 0x....      BL       HAL_GetTick
   \   000000AE   0x4682             MOV      R10,R0
    211                
    212              /* Wait for Backup domain Write protection disable */
    213              while((PWR->CR1 & PWR_CR1_DBP) == RESET)
   \                     ??HAL_RCCEx_PeriphCLKConfig_4: (+1)
   \   000000B0   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \   000000B4   0x05C0             LSLS     R0,R0,#+23
   \   000000B6   0xD406             BMI.N    ??HAL_RCCEx_PeriphCLKConfig_5
    214              {
    215                if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
   \   000000B8   0x.... 0x....      BL       HAL_GetTick
   \   000000BC   0xEBA0 0x000A      SUB      R0,R0,R10
   \   000000C0   0x2865             CMP      R0,#+101
   \   000000C2   0xD3F5             BCC.N    ??HAL_RCCEx_PeriphCLKConfig_4
   \   000000C4   0xE1CD             B.N      ??HAL_RCCEx_PeriphCLKConfig_6
    216                {
    217                  return HAL_TIMEOUT;
    218                }      
    219              }
    220              /* Reset the Backup domain only if the RTC Clock source selection is modified */ 
    221              if((RCC->BDCR & RCC_BDCR_RTCSEL) != (PeriphClkInit->RTCClockSelection & RCC_BDCR_RTCSEL))
   \                     ??HAL_RCCEx_PeriphCLKConfig_5: (+1)
   \   000000C6   0x6F28             LDR      R0,[R5, #+112]
   \   000000C8   0x6B21             LDR      R1,[R4, #+48]
   \   000000CA   0xF400 0x7040      AND      R0,R0,#0x300
   \   000000CE   0xF401 0x7140      AND      R1,R1,#0x300
   \   000000D2   0x4288             CMP      R0,R1
   \   000000D4   0xD034             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_3
    222              {
    223                /* Store the content of BDCR register before the reset of Backup Domain */
    224                tmpreg0 = (RCC->BDCR & ~(RCC_BDCR_RTCSEL));
   \   000000D6   0x6F28             LDR      R0,[R5, #+112]
    225                
    226                /* RTC Clock selection can be changed only if the Backup Domain is reset */
    227                __HAL_RCC_BACKUPRESET_FORCE();
   \   000000D8   0x6F29             LDR      R1,[R5, #+112]
   \   000000DA   0xF441 0x3180      ORR      R1,R1,#0x10000
   \   000000DE   0x6729             STR      R1,[R5, #+112]
    228                __HAL_RCC_BACKUPRESET_RELEASE();
   \   000000E0   0x6F29             LDR      R1,[R5, #+112]
   \   000000E2   0xF420 0x7040      BIC      R0,R0,#0x300
   \   000000E6   0xF421 0x3180      BIC      R1,R1,#0x10000
   \   000000EA   0x6729             STR      R1,[R5, #+112]
    229                
    230                /* Restore the Content of BDCR register */
    231                RCC->BDCR = tmpreg0;
   \   000000EC   0x6728             STR      R0,[R5, #+112]
    232                
    233                /* If LSE is selected as RTC clock source, wait for LSE reactivation */
    234                if (HAL_IS_BIT_SET(tmpreg0, RCC_BDCR_LSERDY))
   \   000000EE   0x0780             LSLS     R0,R0,#+30
   \   000000F0   0xD50E             BPL.N    ??HAL_RCCEx_PeriphCLKConfig_7
    235                {
    236                  /* Get Start Tick*/
    237                  tickstart = HAL_GetTick();
   \   000000F2   0x.... 0x....      BL       HAL_GetTick
   \   000000F6   0x4682             MOV      R10,R0
   \   000000F8   0xF241 0x3989      MOVW     R9,#+5001
    238                  
    239                  /* Wait till LSE is ready */  
    240                  while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
   \                     ??HAL_RCCEx_PeriphCLKConfig_8: (+1)
   \   000000FC   0x6F28             LDR      R0,[R5, #+112]
   \   000000FE   0x0780             LSLS     R0,R0,#+30
   \   00000100   0xD406             BMI.N    ??HAL_RCCEx_PeriphCLKConfig_7
    241                  {
    242                    if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
   \   00000102   0x.... 0x....      BL       HAL_GetTick
   \   00000106   0xEBA0 0x000A      SUB      R0,R0,R10
   \   0000010A   0x4548             CMP      R0,R9
   \   0000010C   0xD3F6             BCC.N    ??HAL_RCCEx_PeriphCLKConfig_8
   \   0000010E   0xE1A8             B.N      ??HAL_RCCEx_PeriphCLKConfig_6
    243                    {
    244                      return HAL_TIMEOUT;
    245                    }
    246                  }
    247                }
    248                __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection); 			
   \                     ??HAL_RCCEx_PeriphCLKConfig_7: (+1)
   \   00000110   0x6B20             LDR      R0,[R4, #+48]
   \   00000112   0xF400 0x7140      AND      R1,R0,#0x300
   \   00000116   0xF5B1 0x7F40      CMP      R1,#+768
   \   0000011A   0xD107             BNE.N    ??HAL_RCCEx_PeriphCLKConfig_9
   \   0000011C   0x68A9             LDR      R1,[R5, #+8]
   \   0000011E   0x.... 0x....      LDR.W    R2,??DataTable2_3  ;; 0xffffcff
   \   00000122   0x4010             ANDS     R0,R2,R0
   \   00000124   0xF421 0x11F8      BIC      R1,R1,#0x1F0000
   \   00000128   0x4308             ORRS     R0,R0,R1
   \   0000012A   0xE002             B.N      ??HAL_RCCEx_PeriphCLKConfig_10
   \                     ??HAL_RCCEx_PeriphCLKConfig_9: (+1)
   \   0000012C   0x68A8             LDR      R0,[R5, #+8]
   \   0000012E   0xF420 0x10F8      BIC      R0,R0,#0x1F0000
   \                     ??HAL_RCCEx_PeriphCLKConfig_10: (+1)
   \   00000132   0x60A8             STR      R0,[R5, #+8]
   \   00000134   0x6F28             LDR      R0,[R5, #+112]
   \   00000136   0x6B21             LDR      R1,[R4, #+48]
   \   00000138   0x0509             LSLS     R1,R1,#+20
   \   0000013A   0xEA50 0x5011      ORRS     R0,R0,R1, LSR #+20
   \   0000013E   0x6728             STR      R0,[R5, #+112]
    249              }
    250            }
    251          
    252            /*------------------------------------ TIM configuration --------------------------------------*/
    253            if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_TIM) == (RCC_PERIPHCLK_TIM))
   \                     ??HAL_RCCEx_PeriphCLKConfig_3: (+1)
   \   00000140   0x7820             LDRB     R0,[R4, #+0]
   \   00000142   0x06C0             LSLS     R0,R0,#+27
   \   00000144   0xD507             BPL.N    ??HAL_RCCEx_PeriphCLKConfig_11
    254            {
    255              /* Check the parameters */
    256              assert_param(IS_RCC_TIMPRES(PeriphClkInit->TIMPresSelection));
    257              
    258              /* Configure Timer Prescaler */
    259              __HAL_RCC_TIMCLKPRESCALER(PeriphClkInit->TIMPresSelection);
   \   00000146   0x68B0             LDR      R0,[R6, #+8]
   \   00000148   0xF020 0x7080      BIC      R0,R0,#0x1000000
   \   0000014C   0x60B0             STR      R0,[R6, #+8]
   \   0000014E   0x68B0             LDR      R0,[R6, #+8]
   \   00000150   0x6BA1             LDR      R1,[R4, #+56]
   \   00000152   0x4308             ORRS     R0,R1,R0
   \   00000154   0x60B0             STR      R0,[R6, #+8]
    260            }
    261            
    262            /*-------------------------------------- I2C1 Configuration -----------------------------------*/
    263            if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C1) == RCC_PERIPHCLK_I2C1)
   \                     ??HAL_RCCEx_PeriphCLKConfig_11: (+1)
   \   00000156   0x6820             LDR      R0,[R4, #+0]
   \   00000158   0x0440             LSLS     R0,R0,#+17
   \   0000015A   0xD505             BPL.N    ??HAL_RCCEx_PeriphCLKConfig_12
    264            {
    265              /* Check the parameters */
    266              assert_param(IS_RCC_I2C1CLKSOURCE(PeriphClkInit->I2c1ClockSelection));
    267              
    268              /* Configure the I2C1 clock source */
    269              __HAL_RCC_I2C1_CONFIG(PeriphClkInit->I2c1ClockSelection);
   \   0000015C   0x68F0             LDR      R0,[R6, #+12]
   \   0000015E   0x6E61             LDR      R1,[R4, #+100]
   \   00000160   0xF420 0x3040      BIC      R0,R0,#0x30000
   \   00000164   0x4308             ORRS     R0,R1,R0
   \   00000166   0x60F0             STR      R0,[R6, #+12]
    270            }
    271            
    272            /*-------------------------------------- I2C2 Configuration -----------------------------------*/
    273            if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C2) == RCC_PERIPHCLK_I2C2)
   \                     ??HAL_RCCEx_PeriphCLKConfig_12: (+1)
   \   00000168   0x6820             LDR      R0,[R4, #+0]
   \   0000016A   0x0400             LSLS     R0,R0,#+16
   \   0000016C   0xD505             BPL.N    ??HAL_RCCEx_PeriphCLKConfig_13
    274            {
    275              /* Check the parameters */
    276              assert_param(IS_RCC_I2C2CLKSOURCE(PeriphClkInit->I2c2ClockSelection));
    277              
    278              /* Configure the I2C2 clock source */
    279              __HAL_RCC_I2C2_CONFIG(PeriphClkInit->I2c2ClockSelection);
   \   0000016E   0x68F0             LDR      R0,[R6, #+12]
   \   00000170   0x6EA1             LDR      R1,[R4, #+104]
   \   00000172   0xF420 0x2040      BIC      R0,R0,#0xC0000
   \   00000176   0x4308             ORRS     R0,R1,R0
   \   00000178   0x60F0             STR      R0,[R6, #+12]
    280            }
    281            
    282            /*-------------------------------------- I2C3 Configuration -----------------------------------*/
    283            if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C3) == RCC_PERIPHCLK_I2C3)
   \                     ??HAL_RCCEx_PeriphCLKConfig_13: (+1)
   \   0000017A   0x6820             LDR      R0,[R4, #+0]
   \   0000017C   0x03C0             LSLS     R0,R0,#+15
   \   0000017E   0xD505             BPL.N    ??HAL_RCCEx_PeriphCLKConfig_14
    284            {
    285              /* Check the parameters */
    286              assert_param(IS_RCC_I2C3CLKSOURCE(PeriphClkInit->I2c3ClockSelection));
    287              
    288              /* Configure the I2C3 clock source */
    289              __HAL_RCC_I2C3_CONFIG(PeriphClkInit->I2c3ClockSelection);
   \   00000180   0x68F0             LDR      R0,[R6, #+12]
   \   00000182   0x6EE1             LDR      R1,[R4, #+108]
   \   00000184   0xF420 0x1040      BIC      R0,R0,#0x300000
   \   00000188   0x4308             ORRS     R0,R1,R0
   \   0000018A   0x60F0             STR      R0,[R6, #+12]
    290            }
    291              
    292            /*-------------------------------------- I2C4 Configuration -----------------------------------*/
    293            if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C4) == RCC_PERIPHCLK_I2C4)
   \                     ??HAL_RCCEx_PeriphCLKConfig_14: (+1)
   \   0000018C   0x6820             LDR      R0,[R4, #+0]
   \   0000018E   0x0380             LSLS     R0,R0,#+14
   \   00000190   0xD505             BPL.N    ??HAL_RCCEx_PeriphCLKConfig_15
    294            {
    295              /* Check the parameters */
    296              assert_param(IS_RCC_I2C4CLKSOURCE(PeriphClkInit->I2c4ClockSelection));
    297              
    298              /* Configure the I2C4 clock source */
    299              __HAL_RCC_I2C4_CONFIG(PeriphClkInit->I2c4ClockSelection);
   \   00000192   0x68F0             LDR      R0,[R6, #+12]
   \   00000194   0x6F21             LDR      R1,[R4, #+112]
   \   00000196   0xF420 0x0040      BIC      R0,R0,#0xC00000
   \   0000019A   0x4308             ORRS     R0,R1,R0
   \   0000019C   0x60F0             STR      R0,[R6, #+12]
    300            }
    301          
    302            /*-------------------------------------- USART1 Configuration -----------------------------------*/
    303            if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART1) == RCC_PERIPHCLK_USART1)
   \                     ??HAL_RCCEx_PeriphCLKConfig_15: (+1)
   \   0000019E   0x7820             LDRB     R0,[R4, #+0]
   \   000001A0   0x0640             LSLS     R0,R0,#+25
   \   000001A2   0xD505             BPL.N    ??HAL_RCCEx_PeriphCLKConfig_16
    304            {
    305              /* Check the parameters */
    306              assert_param(IS_RCC_USART1CLKSOURCE(PeriphClkInit->Usart1ClockSelection));
    307              
    308              /* Configure the USART1 clock source */
    309              __HAL_RCC_USART1_CONFIG(PeriphClkInit->Usart1ClockSelection);
   \   000001A4   0x68F0             LDR      R0,[R6, #+12]
   \   000001A6   0x6C61             LDR      R1,[R4, #+68]
   \   000001A8   0x0880             LSRS     R0,R0,#+2
   \   000001AA   0xEA41 0x0080      ORR      R0,R1,R0, LSL #+2
   \   000001AE   0x60F0             STR      R0,[R6, #+12]
    310            }
    311          
    312            /*-------------------------------------- USART2 Configuration -----------------------------------*/
    313            if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART2) == RCC_PERIPHCLK_USART2)
   \                     ??HAL_RCCEx_PeriphCLKConfig_16: (+1)
   \   000001B0   0x7820             LDRB     R0,[R4, #+0]
   \   000001B2   0x0600             LSLS     R0,R0,#+24
   \   000001B4   0xD505             BPL.N    ??HAL_RCCEx_PeriphCLKConfig_17
    314            {
    315              /* Check the parameters */
    316              assert_param(IS_RCC_USART2CLKSOURCE(PeriphClkInit->Usart2ClockSelection));
    317              
    318              /* Configure the USART2 clock source */
    319              __HAL_RCC_USART2_CONFIG(PeriphClkInit->Usart2ClockSelection);
   \   000001B6   0x68F0             LDR      R0,[R6, #+12]
   \   000001B8   0x6CA1             LDR      R1,[R4, #+72]
   \   000001BA   0xF020 0x000C      BIC      R0,R0,#0xC
   \   000001BE   0x4308             ORRS     R0,R1,R0
   \   000001C0   0x60F0             STR      R0,[R6, #+12]
    320            }
    321          
    322            /*-------------------------------------- USART3 Configuration -----------------------------------*/
    323            if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART3) == RCC_PERIPHCLK_USART3)
   \                     ??HAL_RCCEx_PeriphCLKConfig_17: (+1)
   \   000001C2   0x6820             LDR      R0,[R4, #+0]
   \   000001C4   0x05C0             LSLS     R0,R0,#+23
   \   000001C6   0xD505             BPL.N    ??HAL_RCCEx_PeriphCLKConfig_18
    324            {
    325              /* Check the parameters */
    326              assert_param(IS_RCC_USART3CLKSOURCE(PeriphClkInit->Usart3ClockSelection));
    327              
    328              /* Configure the USART3 clock source */
    329              __HAL_RCC_USART3_CONFIG(PeriphClkInit->Usart3ClockSelection);
   \   000001C8   0x68F0             LDR      R0,[R6, #+12]
   \   000001CA   0x6CE1             LDR      R1,[R4, #+76]
   \   000001CC   0xF020 0x0030      BIC      R0,R0,#0x30
   \   000001D0   0x4308             ORRS     R0,R1,R0
   \   000001D2   0x60F0             STR      R0,[R6, #+12]
    330            }
    331          
    332            /*-------------------------------------- UART4 Configuration -----------------------------------*/
    333            if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART4) == RCC_PERIPHCLK_UART4)
   \                     ??HAL_RCCEx_PeriphCLKConfig_18: (+1)
   \   000001D4   0x6820             LDR      R0,[R4, #+0]
   \   000001D6   0x0580             LSLS     R0,R0,#+22
   \   000001D8   0xD505             BPL.N    ??HAL_RCCEx_PeriphCLKConfig_19
    334            {
    335              /* Check the parameters */
    336              assert_param(IS_RCC_UART4CLKSOURCE(PeriphClkInit->Uart4ClockSelection));
    337              
    338              /* Configure the UART4 clock source */
    339              __HAL_RCC_UART4_CONFIG(PeriphClkInit->Uart4ClockSelection);
   \   000001DA   0x68F0             LDR      R0,[R6, #+12]
   \   000001DC   0x6D21             LDR      R1,[R4, #+80]
   \   000001DE   0xF020 0x00C0      BIC      R0,R0,#0xC0
   \   000001E2   0x4308             ORRS     R0,R1,R0
   \   000001E4   0x60F0             STR      R0,[R6, #+12]
    340            }
    341          
    342            /*-------------------------------------- UART5 Configuration -----------------------------------*/
    343            if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART5) == RCC_PERIPHCLK_UART5)
   \                     ??HAL_RCCEx_PeriphCLKConfig_19: (+1)
   \   000001E6   0x6820             LDR      R0,[R4, #+0]
   \   000001E8   0x0540             LSLS     R0,R0,#+21
   \   000001EA   0xD505             BPL.N    ??HAL_RCCEx_PeriphCLKConfig_20
    344            {
    345              /* Check the parameters */
    346              assert_param(IS_RCC_UART5CLKSOURCE(PeriphClkInit->Uart5ClockSelection));
    347              
    348              /* Configure the UART5 clock source */
    349              __HAL_RCC_UART5_CONFIG(PeriphClkInit->Uart5ClockSelection);
   \   000001EC   0x68F0             LDR      R0,[R6, #+12]
   \   000001EE   0x6D61             LDR      R1,[R4, #+84]
   \   000001F0   0xF420 0x7040      BIC      R0,R0,#0x300
   \   000001F4   0x4308             ORRS     R0,R1,R0
   \   000001F6   0x60F0             STR      R0,[R6, #+12]
    350            }
    351          
    352            /*-------------------------------------- USART6 Configuration -----------------------------------*/
    353            if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART6) == RCC_PERIPHCLK_USART6)
   \                     ??HAL_RCCEx_PeriphCLKConfig_20: (+1)
   \   000001F8   0x6820             LDR      R0,[R4, #+0]
   \   000001FA   0x0500             LSLS     R0,R0,#+20
   \   000001FC   0xD505             BPL.N    ??HAL_RCCEx_PeriphCLKConfig_21
    354            {
    355              /* Check the parameters */
    356              assert_param(IS_RCC_USART6CLKSOURCE(PeriphClkInit->Usart6ClockSelection));
    357              
    358              /* Configure the USART6 clock source */
    359              __HAL_RCC_USART6_CONFIG(PeriphClkInit->Usart6ClockSelection);
   \   000001FE   0x68F0             LDR      R0,[R6, #+12]
   \   00000200   0x6DA1             LDR      R1,[R4, #+88]
   \   00000202   0xF420 0x6040      BIC      R0,R0,#0xC00
   \   00000206   0x4308             ORRS     R0,R1,R0
   \   00000208   0x60F0             STR      R0,[R6, #+12]
    360            }
    361          
    362            /*-------------------------------------- UART7 Configuration -----------------------------------*/
    363            if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART7) == RCC_PERIPHCLK_UART7)
   \                     ??HAL_RCCEx_PeriphCLKConfig_21: (+1)
   \   0000020A   0x6820             LDR      R0,[R4, #+0]
   \   0000020C   0x04C0             LSLS     R0,R0,#+19
   \   0000020E   0xD505             BPL.N    ??HAL_RCCEx_PeriphCLKConfig_22
    364            {
    365              /* Check the parameters */
    366              assert_param(IS_RCC_UART7CLKSOURCE(PeriphClkInit->Uart7ClockSelection));
    367              
    368              /* Configure the UART7 clock source */
    369              __HAL_RCC_UART7_CONFIG(PeriphClkInit->Uart7ClockSelection);
   \   00000210   0x68F0             LDR      R0,[R6, #+12]
   \   00000212   0x6DE1             LDR      R1,[R4, #+92]
   \   00000214   0xF420 0x5040      BIC      R0,R0,#0x3000
   \   00000218   0x4308             ORRS     R0,R1,R0
   \   0000021A   0x60F0             STR      R0,[R6, #+12]
    370            }
    371          
    372            /*-------------------------------------- UART8 Configuration -----------------------------------*/
    373            if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART8) == RCC_PERIPHCLK_UART8)
   \                     ??HAL_RCCEx_PeriphCLKConfig_22: (+1)
   \   0000021C   0x6820             LDR      R0,[R4, #+0]
   \   0000021E   0x0480             LSLS     R0,R0,#+18
   \   00000220   0xD505             BPL.N    ??HAL_RCCEx_PeriphCLKConfig_23
    374            {
    375              /* Check the parameters */
    376              assert_param(IS_RCC_UART8CLKSOURCE(PeriphClkInit->Uart8ClockSelection));
    377              
    378              /* Configure the UART8 clock source */
    379              __HAL_RCC_UART8_CONFIG(PeriphClkInit->Uart8ClockSelection);
   \   00000222   0x68F0             LDR      R0,[R6, #+12]
   \   00000224   0x6E21             LDR      R1,[R4, #+96]
   \   00000226   0xF420 0x4040      BIC      R0,R0,#0xC000
   \   0000022A   0x4308             ORRS     R0,R1,R0
   \   0000022C   0x60F0             STR      R0,[R6, #+12]
    380            }
    381            
    382            /*--------------------------------------- CEC Configuration -----------------------------------*/
    383            if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_CEC) == RCC_PERIPHCLK_CEC)
   \                     ??HAL_RCCEx_PeriphCLKConfig_23: (+1)
   \   0000022E   0x6820             LDR      R0,[R4, #+0]
   \   00000230   0x0240             LSLS     R0,R0,#+9
   \   00000232   0xD505             BPL.N    ??HAL_RCCEx_PeriphCLKConfig_24
    384            {
    385              /* Check the parameters */
    386              assert_param(IS_RCC_CECCLKSOURCE(PeriphClkInit->CecClockSelection));
    387              
    388              /* Configure the CEC clock source */
    389              __HAL_RCC_CEC_CONFIG(PeriphClkInit->CecClockSelection);
   \   00000234   0x68F0             LDR      R0,[R6, #+12]
   \   00000236   0x6FA1             LDR      R1,[R4, #+120]
   \   00000238   0xF020 0x6080      BIC      R0,R0,#0x4000000
   \   0000023C   0x4308             ORRS     R0,R1,R0
   \   0000023E   0x60F0             STR      R0,[R6, #+12]
    390            }
    391            
    392            /*-------------------------------------- CK48 Configuration -----------------------------------*/
    393            if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_CLK48) == RCC_PERIPHCLK_CLK48)
   \                     ??HAL_RCCEx_PeriphCLKConfig_24: (+1)
   \   00000240   0x6820             LDR      R0,[R4, #+0]
   \   00000242   0x0280             LSLS     R0,R0,#+10
   \   00000244   0xD50B             BPL.N    ??HAL_RCCEx_PeriphCLKConfig_25
    394            {
    395              /* Check the parameters */
    396              assert_param(IS_RCC_CLK48SOURCE(PeriphClkInit->Clk48ClockSelection));
    397              
    398              /* Configure the CLK48 source */
    399              __HAL_RCC_CLK48_CONFIG(PeriphClkInit->Clk48ClockSelection);
   \   00000246   0x68F0             LDR      R0,[R6, #+12]
   \   00000248   0x6FE1             LDR      R1,[R4, #+124]
   \   0000024A   0xF020 0x6000      BIC      R0,R0,#0x8000000
   \   0000024E   0x4308             ORRS     R0,R1,R0
   \   00000250   0x60F0             STR      R0,[R6, #+12]
    400          
    401              /* Enable the PLLSAI when it's used as clock source for CK48 */
    402              if(PeriphClkInit->Clk48ClockSelection == RCC_CLK48SOURCE_PLLSAIP)
   \   00000252   0x6FE0             LDR      R0,[R4, #+124]
   \   00000254   0xF1B0 0x6F00      CMP      R0,#+134217728
   \   00000258   0xBF08             IT       EQ 
   \   0000025A   0xF04F 0x0801      MOVEQ    R8,#+1
    403              {
    404                pllsaiused = 1; 
    405              }
    406            }
    407          
    408            /*-------------------------------------- LTDC Configuration -----------------------------------*/
    409          #if defined(STM32F756xx) || defined(STM32F746xx)
    410            if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LTDC) == RCC_PERIPHCLK_LTDC)
   \                     ??HAL_RCCEx_PeriphCLKConfig_25: (+1)
   \   0000025E   0x6820             LDR      R0,[R4, #+0]
   \   00000260   0x0701             LSLS     R1,R0,#+28
   \   00000262   0xBF48             IT       MI 
   \   00000264   0xF04F 0x0801      MOVMI    R8,#+1
    411            {
    412              pllsaiused = 1; 
    413            }
    414          #endif /* STM32F756xx || STM32F746xx */
    415            /*-------------------------------------- LPTIM1 Configuration -----------------------------------*/
    416            if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM1) == RCC_PERIPHCLK_LPTIM1)
   \   00000268   0x0340             LSLS     R0,R0,#+13
   \   0000026A   0xD505             BPL.N    ??HAL_RCCEx_PeriphCLKConfig_26
    417            {
    418              /* Check the parameters */
    419              assert_param(IS_RCC_LPTIM1CLK(PeriphClkInit->Lptim1ClockSelection));
    420              
    421              /* Configure the LTPIM1 clock source */
    422              __HAL_RCC_LPTIM1_CONFIG(PeriphClkInit->Lptim1ClockSelection);
   \   0000026C   0x68F0             LDR      R0,[R6, #+12]
   \   0000026E   0x6F61             LDR      R1,[R4, #+116]
   \   00000270   0xF020 0x7040      BIC      R0,R0,#0x3000000
   \   00000274   0x4308             ORRS     R0,R1,R0
   \   00000276   0x60F0             STR      R0,[R6, #+12]
    423             }
    424            
    425            /*------------------------------------- SDMMC1 Configuration ------------------------------------*/
    426            if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SDMMC1) == RCC_PERIPHCLK_SDMMC1)
   \                     ??HAL_RCCEx_PeriphCLKConfig_26: (+1)
   \   00000278   0x6820             LDR      R0,[R4, #+0]
   \   0000027A   0x0200             LSLS     R0,R0,#+8
   \   0000027C   0xD506             BPL.N    ??HAL_RCCEx_PeriphCLKConfig_27
    427            {
    428              /* Check the parameters */
    429              assert_param(IS_RCC_SDMMC1CLKSOURCE(PeriphClkInit->Sdmmc1ClockSelection));
    430              
    431              /* Configure the SDMMC1 clock source */
    432              __HAL_RCC_SDMMC1_CONFIG(PeriphClkInit->Sdmmc1ClockSelection);
   \   0000027E   0x68F0             LDR      R0,[R6, #+12]
   \   00000280   0xF8D4 0x1080      LDR      R1,[R4, #+128]
   \   00000284   0xF020 0x5080      BIC      R0,R0,#0x10000000
   \   00000288   0x4308             ORRS     R0,R1,R0
   \   0000028A   0x60F0             STR      R0,[R6, #+12]
    433            }
    434          
    435            /*-------------------------------------- PLLI2S Configuration ---------------------------------*/
    436            /* PLLI2S is configured when a peripheral will use it as source clock : SAI1, SAI2, I2S or SPDIF-RX */
    437            if((plli2sused == 1) || (PeriphClkInit->PeriphClockSelection == RCC_PERIPHCLK_PLLI2S))
   \                     ??HAL_RCCEx_PeriphCLKConfig_27: (+1)
   \   0000028C   0xB91F             CBNZ.N   R7,??HAL_RCCEx_PeriphCLKConfig_28
   \   0000028E   0x6820             LDR      R0,[R4, #+0]
   \   00000290   0xF1B0 0x7F00      CMP      R0,#+33554432
   \   00000294   0xD176             BNE.N    ??HAL_RCCEx_PeriphCLKConfig_29
    438            {
    439              /* Disable the PLLI2S */
    440              __HAL_RCC_PLLI2S_DISABLE();  
   \                     ??HAL_RCCEx_PeriphCLKConfig_28: (+1)
   \   00000296   0x6828             LDR      R0,[R5, #+0]
   \   00000298   0xF020 0x6080      BIC      R0,R0,#0x4000000
   \   0000029C   0x6028             STR      R0,[R5, #+0]
    441              
    442              /* Get Start Tick*/
    443              tickstart = HAL_GetTick();
   \   0000029E   0x.... 0x....      BL       HAL_GetTick
   \   000002A2   0x4682             MOV      R10,R0
    444              
    445              /* Wait till PLLI2S is disabled */
    446              while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  != RESET)
   \                     ??HAL_RCCEx_PeriphCLKConfig_30: (+1)
   \   000002A4   0x6828             LDR      R0,[R5, #+0]
   \   000002A6   0x0100             LSLS     R0,R0,#+4
   \   000002A8   0xD506             BPL.N    ??HAL_RCCEx_PeriphCLKConfig_31
    447              {
    448                if((HAL_GetTick() - tickstart) > PLLI2S_TIMEOUT_VALUE)
   \   000002AA   0x.... 0x....      BL       HAL_GetTick
   \   000002AE   0xEBA0 0x000A      SUB      R0,R0,R10
   \   000002B2   0x2865             CMP      R0,#+101
   \   000002B4   0xD3F6             BCC.N    ??HAL_RCCEx_PeriphCLKConfig_30
   \   000002B6   0xE0D4             B.N      ??HAL_RCCEx_PeriphCLKConfig_6
    449                {
    450                  /* return in case of Timeout detected */         
    451                  return HAL_TIMEOUT;
    452                }
    453              }
    454              
    455              /* check for common PLLI2S Parameters */
    456              assert_param(IS_RCC_PLLI2SN_VALUE(PeriphClkInit->PLLI2S.PLLI2SN));
    457                
    458              /*----------------- In Case of PLLI2S is selected as source clock for I2S -------------------*/ 
    459              if(((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S) == RCC_PERIPHCLK_I2S) && (PeriphClkInit->I2sClockSelection == RCC_I2SCLKSOURCE_PLLI2S)))
   \                     ??HAL_RCCEx_PeriphCLKConfig_31: (+1)
   \   000002B8   0x7820             LDRB     R0,[R4, #+0]
   \   000002BA   0x07C0             LSLS     R0,R0,#+31
   \   000002BC   0xD50F             BPL.N    ??HAL_RCCEx_PeriphCLKConfig_32
   \   000002BE   0x6B60             LDR      R0,[R4, #+52]
   \   000002C0   0xB968             CBNZ.N   R0,??HAL_RCCEx_PeriphCLKConfig_32
    460              {
    461                /* check for Parameters */
    462                assert_param(IS_RCC_PLLI2SR_VALUE(PeriphClkInit->PLLI2S.PLLI2SR));
    463              
    464                /* Read PLLI2SP and PLLI2SQ value from PLLI2SCFGR register (this value is not needed for I2S configuration) */
    465                tmpreg0 = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SP) >> POSITION_VAL(RCC_PLLI2SCFGR_PLLI2SP));
   \   000002C2   0x6830             LDR      R0,[R6, #+0]
    466                tmpreg1 = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SQ) >> POSITION_VAL(RCC_PLLI2SCFGR_PLLI2SQ));
   \   000002C4   0x6831             LDR      R1,[R6, #+0]
    467                /* Configure the PLLI2S division factors */
    468                /* PLLI2S_VCO = f(VCO clock) = f(PLLI2S clock input) x (PLLI2SN/PLLM) */
    469                /* I2SCLK = f(PLLI2S clock output) = f(VCO clock) / PLLI2SR */
    470                __HAL_RCC_PLLI2S_CONFIG(PeriphClkInit->PLLI2S.PLLI2SN , tmpreg0, tmpreg1, PeriphClkInit->PLLI2S.PLLI2SR);
   \   000002C6   0x6862             LDR      R2,[R4, #+4]
   \   000002C8   0xF400 0x3040      AND      R0,R0,#0x30000
   \   000002CC   0xF001 0x6170      AND      R1,R1,#0xF000000
   \   000002D0   0xEA40 0x1082      ORR      R0,R0,R2, LSL #+6
   \   000002D4   0x4308             ORRS     R0,R1,R0
   \   000002D6   0x68A1             LDR      R1,[R4, #+8]
   \   000002D8   0xEA40 0x7001      ORR      R0,R0,R1, LSL #+28
   \   000002DC   0x6030             STR      R0,[R6, #+0]
    471              }
    472                  
    473              /*----------------- In Case of PLLI2S is selected as source clock for SAI -------------------*/  
    474              if(((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1) && (PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_PLLI2S)) ||
    475                 ((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI2) == RCC_PERIPHCLK_SAI2) && (PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_PLLI2S))) 
   \                     ??HAL_RCCEx_PeriphCLKConfig_32: (+1)
   \   000002DE   0x6820             LDR      R0,[R4, #+0]
   \   000002E0   0x0301             LSLS     R1,R0,#+12
   \   000002E2   0xD503             BPL.N    ??HAL_RCCEx_PeriphCLKConfig_33
   \   000002E4   0x6BE1             LDR      R1,[R4, #+60]
   \   000002E6   0xF5B1 0x1F80      CMP      R1,#+1048576
   \   000002EA   0xD005             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_34
   \                     ??HAL_RCCEx_PeriphCLKConfig_33: (+1)
   \   000002EC   0x02C0             LSLS     R0,R0,#+11
   \   000002EE   0xD518             BPL.N    ??HAL_RCCEx_PeriphCLKConfig_35
   \   000002F0   0x6C20             LDR      R0,[R4, #+64]
   \   000002F2   0xF5B0 0x0F80      CMP      R0,#+4194304
   \   000002F6   0xD114             BNE.N    ??HAL_RCCEx_PeriphCLKConfig_35
    476              {
    477                /* Check for PLLI2S Parameters */
    478                assert_param(IS_RCC_PLLI2SQ_VALUE(PeriphClkInit->PLLI2S.PLLI2SQ));
    479                /* Check for PLLI2S/DIVQ parameters */
    480                assert_param(IS_RCC_PLLI2S_DIVQ_VALUE(PeriphClkInit->PLLI2SDivQ));
    481                      
    482                /* Read PLLI2SP and PLLI2SR values from PLLI2SCFGR register (this value is not needed for SAI configuration) */
    483                tmpreg0 = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SP) >> POSITION_VAL(RCC_PLLI2SCFGR_PLLI2SP));
   \                     ??HAL_RCCEx_PeriphCLKConfig_34: (+1)
   \   000002F8   0x6830             LDR      R0,[R6, #+0]
    484                tmpreg1 = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SR) >> POSITION_VAL(RCC_PLLI2SCFGR_PLLI2SR));
   \   000002FA   0x6831             LDR      R1,[R6, #+0]
    485                /* Configure the PLLI2S division factors */      
    486                /* PLLI2S_VCO Input  = PLL_SOURCE/PLLM */
    487                /* PLLI2S_VCO Output = PLLI2S_VCO Input * PLLI2SN */
    488                /* SAI_CLK(first level) = PLLI2S_VCO Output/PLLI2SQ */
    489                __HAL_RCC_PLLI2S_CONFIG(PeriphClkInit->PLLI2S.PLLI2SN, tmpreg0, PeriphClkInit->PLLI2S.PLLI2SQ, tmpreg1);
   \   000002FC   0x6862             LDR      R2,[R4, #+4]
   \   000002FE   0xF400 0x3040      AND      R0,R0,#0x30000
   \   00000302   0xF001 0x41E0      AND      R1,R1,#0x70000000
   \   00000306   0xEA40 0x1082      ORR      R0,R0,R2, LSL #+6
   \   0000030A   0x68E2             LDR      R2,[R4, #+12]
   \   0000030C   0xEA40 0x6002      ORR      R0,R0,R2, LSL #+24
   \   00000310   0x4308             ORRS     R0,R1,R0
   \   00000312   0x6030             STR      R0,[R6, #+0]
    490             
    491                /* SAI_CLK_x = SAI_CLK(first level)/PLLI2SDIVQ */ 
    492                __HAL_RCC_PLLI2S_PLLSAICLKDIVQ_CONFIG(PeriphClkInit->PLLI2SDivQ);   
   \   00000314   0x68B0             LDR      R0,[R6, #+8]
   \   00000316   0x6A61             LDR      R1,[R4, #+36]
   \   00000318   0x0940             LSRS     R0,R0,#+5
   \   0000031A   0x1E49             SUBS     R1,R1,#+1
   \   0000031C   0xEA41 0x1040      ORR      R0,R1,R0, LSL #+5
   \   00000320   0x60B0             STR      R0,[R6, #+8]
    493              }          
    494          
    495              /*----------------- In Case of PLLI2S is selected as source clock for SPDIF-RX -------------------*/  
    496              if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPDIFRX) == RCC_PERIPHCLK_SPDIFRX)
   \                     ??HAL_RCCEx_PeriphCLKConfig_35: (+1)
   \   00000322   0x6820             LDR      R0,[R4, #+0]
   \   00000324   0x01C0             LSLS     R0,R0,#+7
   \   00000326   0xD50D             BPL.N    ??HAL_RCCEx_PeriphCLKConfig_36
    497              {
    498                /* check for Parameters */
    499                assert_param(IS_RCC_PLLI2SP_VALUE(PeriphClkInit->PLLI2S.PLLI2SP));
    500               
    501               /* Read PLLI2SR value from PLLI2SCFGR register (this value is not needed for SPDIF-RX configuration) */
    502                tmpreg0 = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SQ) >> POSITION_VAL(RCC_PLLI2SCFGR_PLLI2SQ));
   \   00000328   0x6830             LDR      R0,[R6, #+0]
    503                tmpreg1 = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SR) >> POSITION_VAL(RCC_PLLI2SCFGR_PLLI2SR));
   \   0000032A   0x6831             LDR      R1,[R6, #+0]
    504                /* Configure the PLLI2S division factors */
    505                /* PLLI2S_VCO = f(VCO clock) = f(PLLI2S clock input) x (PLLI2SN/PLLM) */
    506                /* SPDIFCLK = f(PLLI2S clock output) = f(VCO clock) / PLLI2SP */
    507                __HAL_RCC_PLLI2S_CONFIG(PeriphClkInit->PLLI2S.PLLI2SN , PeriphClkInit->PLLI2S.PLLI2SP, tmpreg0, tmpreg1);
   \   0000032C   0x6923             LDR      R3,[R4, #+16]
   \   0000032E   0x6862             LDR      R2,[R4, #+4]
   \   00000330   0xF000 0x6070      AND      R0,R0,#0xF000000
   \   00000334   0xF001 0x41E0      AND      R1,R1,#0x70000000
   \   00000338   0x041B             LSLS     R3,R3,#+16
   \   0000033A   0xEA43 0x1282      ORR      R2,R3,R2, LSL #+6
   \   0000033E   0x4310             ORRS     R0,R0,R2
   \   00000340   0x4308             ORRS     R0,R1,R0
   \   00000342   0x6030             STR      R0,[R6, #+0]
    508              }  
    509                   
    510              /*----------------- In Case of PLLI2S is just selected  -----------------*/  
    511              if((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_PLLI2S) == RCC_PERIPHCLK_PLLI2S)
   \                     ??HAL_RCCEx_PeriphCLKConfig_36: (+1)
   \   00000344   0x6820             LDR      R0,[R4, #+0]
   \   00000346   0x0180             LSLS     R0,R0,#+6
   \   00000348   0xD50B             BPL.N    ??HAL_RCCEx_PeriphCLKConfig_37
    512              {
    513                /* Check for Parameters */
    514                assert_param(IS_RCC_PLLI2SP_VALUE(PeriphClkInit->PLLI2S.PLLI2SP));
    515                assert_param(IS_RCC_PLLI2SR_VALUE(PeriphClkInit->PLLI2S.PLLI2SR));
    516                assert_param(IS_RCC_PLLI2SQ_VALUE(PeriphClkInit->PLLI2S.PLLI2SQ));
    517          
    518                /* Configure the PLLI2S division factors */
    519                /* PLLI2S_VCO = f(VCO clock) = f(PLLI2S clock input) x (PLLI2SN/PLLI2SM) */
    520                /* SPDIFRXCLK = f(PLLI2S clock output) = f(VCO clock) / PLLI2SP */
    521                __HAL_RCC_PLLI2S_CONFIG(PeriphClkInit->PLLI2S.PLLI2SN , PeriphClkInit->PLLI2S.PLLI2SP, PeriphClkInit->PLLI2S.PLLI2SQ, PeriphClkInit->PLLI2S.PLLI2SR);
   \   0000034A   0x6921             LDR      R1,[R4, #+16]
   \   0000034C   0x6860             LDR      R0,[R4, #+4]
   \   0000034E   0x0409             LSLS     R1,R1,#+16
   \   00000350   0xEA41 0x1080      ORR      R0,R1,R0, LSL #+6
   \   00000354   0x68E1             LDR      R1,[R4, #+12]
   \   00000356   0xEA40 0x6001      ORR      R0,R0,R1, LSL #+24
   \   0000035A   0x68A1             LDR      R1,[R4, #+8]
   \   0000035C   0xEA40 0x7001      ORR      R0,R0,R1, LSL #+28
   \   00000360   0x6030             STR      R0,[R6, #+0]
    522              } 
    523              
    524              /* Enable the PLLI2S */
    525              __HAL_RCC_PLLI2S_ENABLE();
   \                     ??HAL_RCCEx_PeriphCLKConfig_37: (+1)
   \   00000362   0x6828             LDR      R0,[R5, #+0]
   \   00000364   0xF040 0x6080      ORR      R0,R0,#0x4000000
   \   00000368   0x6028             STR      R0,[R5, #+0]
    526              
    527              /* Get Start Tick*/
    528              tickstart = HAL_GetTick();
   \   0000036A   0x.... 0x....      BL       HAL_GetTick
   \   0000036E   0x4682             MOV      R10,R0
    529          
    530              /* Wait till PLLI2S is ready */
    531              while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  == RESET)
   \                     ??HAL_RCCEx_PeriphCLKConfig_38: (+1)
   \   00000370   0x6828             LDR      R0,[R5, #+0]
   \   00000372   0x0100             LSLS     R0,R0,#+4
   \   00000374   0xD406             BMI.N    ??HAL_RCCEx_PeriphCLKConfig_29
    532              {
    533                if((HAL_GetTick() - tickstart) > PLLI2S_TIMEOUT_VALUE)
   \   00000376   0x.... 0x....      BL       HAL_GetTick
   \   0000037A   0xEBA0 0x000A      SUB      R0,R0,R10
   \   0000037E   0x2865             CMP      R0,#+101
   \   00000380   0xD3F6             BCC.N    ??HAL_RCCEx_PeriphCLKConfig_38
   \   00000382   0xE06E             B.N      ??HAL_RCCEx_PeriphCLKConfig_6
    534                {
    535                  /* return in case of Timeout detected */                
    536                  return HAL_TIMEOUT;
    537                }
    538              }
    539            } 
    540            
    541            /*-------------------------------------- PLLSAI Configuration ---------------------------------*/
    542            /* PLLSAI is configured when a peripheral will use it as source clock : SAI1, SAI2, LTDC or CK48 */
    543            if(pllsaiused == 1)
   \                     ??HAL_RCCEx_PeriphCLKConfig_29: (+1)
   \   00000384   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000388   0xD06E             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_39
    544            {
    545              /* Disable PLLSAI Clock */
    546              __HAL_RCC_PLLSAI_DISABLE(); 
   \   0000038A   0x6828             LDR      R0,[R5, #+0]
   \   0000038C   0xF020 0x5080      BIC      R0,R0,#0x10000000
   \   00000390   0x6028             STR      R0,[R5, #+0]
    547              
    548              /* Get Start Tick*/
    549              tickstart = HAL_GetTick();
   \   00000392   0x.... 0x....      BL       HAL_GetTick
   \   00000396   0x4682             MOV      R10,R0
    550          
    551              /* Wait till PLLSAI is disabled */
    552              while(__HAL_RCC_PLLSAI_GET_FLAG() != RESET)
   \                     ??HAL_RCCEx_PeriphCLKConfig_40: (+1)
   \   00000398   0x6828             LDR      R0,[R5, #+0]
   \   0000039A   0x0080             LSLS     R0,R0,#+2
   \   0000039C   0xD506             BPL.N    ??HAL_RCCEx_PeriphCLKConfig_41
    553              {
    554                if((HAL_GetTick() - tickstart) > PLLSAI_TIMEOUT_VALUE)
   \   0000039E   0x.... 0x....      BL       HAL_GetTick
   \   000003A2   0xEBA0 0x000A      SUB      R0,R0,R10
   \   000003A6   0x2865             CMP      R0,#+101
   \   000003A8   0xD3F6             BCC.N    ??HAL_RCCEx_PeriphCLKConfig_40
   \   000003AA   0xE05A             B.N      ??HAL_RCCEx_PeriphCLKConfig_6
    555                { 
    556                  /* return in case of Timeout detected */        
    557                  return HAL_TIMEOUT;
    558                }
    559              } 
    560              
    561              /* Check the PLLSAI division factors */
    562              assert_param(IS_RCC_PLLSAIN_VALUE(PeriphClkInit->PLLSAI.PLLSAIN));
    563              
    564              /*----------------- In Case of PLLSAI is selected as source clock for SAI -------------------*/  
    565              if(((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1) && (PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_PLLSAI)) ||\
    566                 ((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI2) == RCC_PERIPHCLK_SAI2) && (PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_PLLSAI)))
   \                     ??HAL_RCCEx_PeriphCLKConfig_41: (+1)
   \   000003AC   0x6820             LDR      R0,[R4, #+0]
   \   000003AE   0x0301             LSLS     R1,R0,#+12
   \   000003B0   0xD501             BPL.N    ??HAL_RCCEx_PeriphCLKConfig_42
   \   000003B2   0x6BE1             LDR      R1,[R4, #+60]
   \   000003B4   0xB119             CBZ.N    R1,??HAL_RCCEx_PeriphCLKConfig_43
   \                     ??HAL_RCCEx_PeriphCLKConfig_42: (+1)
   \   000003B6   0x02C0             LSLS     R0,R0,#+11
   \   000003B8   0xD517             BPL.N    ??HAL_RCCEx_PeriphCLKConfig_44
   \   000003BA   0x6C20             LDR      R0,[R4, #+64]
   \   000003BC   0xB9A8             CBNZ.N   R0,??HAL_RCCEx_PeriphCLKConfig_44
    567              {
    568                /* check for PLLSAIQ Parameter */
    569                assert_param(IS_RCC_PLLSAIQ_VALUE(PeriphClkInit->PLLSAI.PLLSAIQ));
    570                /* check for PLLSAI/DIVQ Parameter */
    571                assert_param(IS_RCC_PLLSAI_DIVQ_VALUE(PeriphClkInit->PLLSAIDivQ));
    572              
    573                /* Read PLLSAIP value from PLLSAICFGR register (this value is not needed for SAI configuration) */
    574                tmpreg0 = ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIP) >> POSITION_VAL(RCC_PLLSAICFGR_PLLSAIP));
   \                     ??HAL_RCCEx_PeriphCLKConfig_43: (+1)
   \   000003BE   0x6870             LDR      R0,[R6, #+4]
    575                tmpreg1 = ((RCC->PLLSAICFGR & RCC_PLLI2SCFGR_PLLI2SR) >> POSITION_VAL(RCC_PLLSAICFGR_PLLSAIR));
   \   000003C0   0x6871             LDR      R1,[R6, #+4]
    576                /* PLLSAI_VCO Input  = PLL_SOURCE/PLLM */
    577                /* PLLSAI_VCO Output = PLLSAI_VCO Input * PLLSAIN */
    578                /* SAI_CLK(first level) = PLLSAI_VCO Output/PLLSAIQ */
    579                __HAL_RCC_PLLSAI_CONFIG(PeriphClkInit->PLLSAI.PLLSAIN , tmpreg0, PeriphClkInit->PLLSAI.PLLSAIQ, tmpreg1);
   \   000003C2   0x6962             LDR      R2,[R4, #+20]
   \   000003C4   0xF400 0x3040      AND      R0,R0,#0x30000
   \   000003C8   0xF001 0x41E0      AND      R1,R1,#0x70000000
   \   000003CC   0xEA40 0x1082      ORR      R0,R0,R2, LSL #+6
   \   000003D0   0x69A2             LDR      R2,[R4, #+24]
   \   000003D2   0xEA40 0x6002      ORR      R0,R0,R2, LSL #+24
   \   000003D6   0x4308             ORRS     R0,R1,R0
   \   000003D8   0x6070             STR      R0,[R6, #+4]
    580                
    581                /* SAI_CLK_x = SAI_CLK(first level)/PLLSAIDIVQ */ 
    582                __HAL_RCC_PLLSAI_PLLSAICLKDIVQ_CONFIG(PeriphClkInit->PLLSAIDivQ);
   \   000003DA   0x68B0             LDR      R0,[R6, #+8]
   \   000003DC   0x6AA1             LDR      R1,[R4, #+40]
   \   000003DE   0xF420 0x50F8      BIC      R0,R0,#0x1F00
   \   000003E2   0x1E49             SUBS     R1,R1,#+1
   \   000003E4   0xEA40 0x2001      ORR      R0,R0,R1, LSL #+8
   \   000003E8   0x60B0             STR      R0,[R6, #+8]
    583              }           
    584          
    585              /*----------------- In Case of PLLSAI is selected as source clock for CLK48 -------------------*/   
    586              /* In Case of PLLI2S is selected as source clock for CK48 */ 
    587              if((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_CLK48) == RCC_PERIPHCLK_CLK48) && (PeriphClkInit->Clk48ClockSelection == RCC_CLK48SOURCE_PLLSAIP))
   \                     ??HAL_RCCEx_PeriphCLKConfig_44: (+1)
   \   000003EA   0x6820             LDR      R0,[R4, #+0]
   \   000003EC   0x0280             LSLS     R0,R0,#+10
   \   000003EE   0xD511             BPL.N    ??HAL_RCCEx_PeriphCLKConfig_45
   \   000003F0   0x6FE0             LDR      R0,[R4, #+124]
   \   000003F2   0xF1B0 0x6F00      CMP      R0,#+134217728
   \   000003F6   0xD10D             BNE.N    ??HAL_RCCEx_PeriphCLKConfig_45
    588              {
    589                /* check for Parameters */
    590                assert_param(IS_RCC_PLLSAIP_VALUE(PeriphClkInit->PLLSAI.PLLSAIP));
    591                /* Read PLLSAIQ and PLLSAIR value from PLLSAICFGR register (this value is not needed for CK48 configuration) */
    592                tmpreg0 = ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIQ) >> POSITION_VAL(RCC_PLLSAICFGR_PLLSAIQ));
   \   000003F8   0x6870             LDR      R0,[R6, #+4]
    593                tmpreg1 = ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIR) >> POSITION_VAL(RCC_PLLSAICFGR_PLLSAIR));
   \   000003FA   0x6871             LDR      R1,[R6, #+4]
    594                
    595                /* Configure the PLLSAI division factors */
    596                /* PLLSAI_VCO = f(VCO clock) = f(PLLSAI clock input) x (PLLI2SN/PLLM) */
    597                /* 48CLK = f(PLLSAI clock output) = f(VCO clock) / PLLSAIP */
    598                __HAL_RCC_PLLSAI_CONFIG(PeriphClkInit->PLLSAI.PLLSAIN , PeriphClkInit->PLLSAI.PLLSAIP, tmpreg0, tmpreg1);
   \   000003FC   0x6A23             LDR      R3,[R4, #+32]
   \   000003FE   0x6962             LDR      R2,[R4, #+20]
   \   00000400   0xF000 0x6070      AND      R0,R0,#0xF000000
   \   00000404   0xF001 0x41E0      AND      R1,R1,#0x70000000
   \   00000408   0x041B             LSLS     R3,R3,#+16
   \   0000040A   0xEA43 0x1282      ORR      R2,R3,R2, LSL #+6
   \   0000040E   0x4310             ORRS     R0,R0,R2
   \   00000410   0x4308             ORRS     R0,R1,R0
   \   00000412   0x6070             STR      R0,[R6, #+4]
    599              }        
    600          
    601          #if defined(STM32F756xx) || defined(STM32F746xx)
    602              /*---------------------------- LTDC configuration -------------------------------*/
    603              if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LTDC) == (RCC_PERIPHCLK_LTDC))
   \                     ??HAL_RCCEx_PeriphCLKConfig_45: (+1)
   \   00000414   0x7820             LDRB     R0,[R4, #+0]
   \   00000416   0x0700             LSLS     R0,R0,#+28
   \   00000418   0xD513             BPL.N    ??HAL_RCCEx_PeriphCLKConfig_46
    604              {
    605                assert_param(IS_RCC_PLLSAIR_VALUE(PeriphClkInit->PLLSAI.PLLSAIR));
    606                assert_param(IS_RCC_PLLSAI_DIVR_VALUE(PeriphClkInit->PLLSAIDivR));
    607                
    608                /* Read PLLSAIP and PLLSAIQ value from PLLSAICFGR register (these value are not needed for LTDC configuration) */
    609                tmpreg0 = ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIQ) >> POSITION_VAL(RCC_PLLSAICFGR_PLLSAIQ));
   \   0000041A   0x6870             LDR      R0,[R6, #+4]
    610                tmpreg1 = ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIP) >> POSITION_VAL(RCC_PLLSAICFGR_PLLSAIP));
   \   0000041C   0x6871             LDR      R1,[R6, #+4]
    611                
    612                /* PLLSAI_VCO Input  = PLL_SOURCE/PLLM */
    613                /* PLLSAI_VCO Output = PLLSAI_VCO Input * PLLSAIN */
    614                /* LTDC_CLK(first level) = PLLSAI_VCO Output/PLLSAIR */
    615                __HAL_RCC_PLLSAI_CONFIG(PeriphClkInit->PLLSAI.PLLSAIN , tmpreg1, tmpreg0, PeriphClkInit->PLLSAI.PLLSAIR);
   \   0000041E   0x6962             LDR      R2,[R4, #+20]
   \   00000420   0xF401 0x3140      AND      R1,R1,#0x30000
   \   00000424   0xF000 0x6070      AND      R0,R0,#0xF000000
   \   00000428   0xEA41 0x1182      ORR      R1,R1,R2, LSL #+6
   \   0000042C   0x4308             ORRS     R0,R0,R1
   \   0000042E   0x69E1             LDR      R1,[R4, #+28]
   \   00000430   0xEA40 0x7001      ORR      R0,R0,R1, LSL #+28
   \   00000434   0x6070             STR      R0,[R6, #+4]
    616                
    617                /* LTDC_CLK = LTDC_CLK(first level)/PLLSAIDIVR */ 
    618                __HAL_RCC_PLLSAI_PLLSAICLKDIVR_CONFIG(PeriphClkInit->PLLSAIDivR);
   \   00000436   0x68B0             LDR      R0,[R6, #+8]
   \   00000438   0x6AE1             LDR      R1,[R4, #+44]
   \   0000043A   0xF420 0x3040      BIC      R0,R0,#0x30000
   \   0000043E   0x4308             ORRS     R0,R1,R0
   \   00000440   0x60B0             STR      R0,[R6, #+8]
    619              }    
    620          #endif /* STM32F756xx || STM32F746xx */  
    621          
    622              /* Enable PLLSAI Clock */
    623              __HAL_RCC_PLLSAI_ENABLE();
   \                     ??HAL_RCCEx_PeriphCLKConfig_46: (+1)
   \   00000442   0x6828             LDR      R0,[R5, #+0]
   \   00000444   0xF040 0x5080      ORR      R0,R0,#0x10000000
   \   00000448   0x6028             STR      R0,[R5, #+0]
    624              
    625              /* Get Start Tick*/
    626              tickstart = HAL_GetTick();
   \   0000044A   0x.... 0x....      BL       HAL_GetTick
   \   0000044E   0x4682             MOV      R10,R0
    627          
    628              /* Wait till PLLSAI is ready */
    629              while(__HAL_RCC_PLLSAI_GET_FLAG() == RESET)
   \                     ??HAL_RCCEx_PeriphCLKConfig_47: (+1)
   \   00000450   0x6828             LDR      R0,[R5, #+0]
   \   00000452   0x0080             LSLS     R0,R0,#+2
   \   00000454   0xD408             BMI.N    ??HAL_RCCEx_PeriphCLKConfig_39
    630              {
    631                if((HAL_GetTick() - tickstart) > PLLSAI_TIMEOUT_VALUE)
   \   00000456   0x.... 0x....      BL       HAL_GetTick
   \   0000045A   0xEBA0 0x000A      SUB      R0,R0,R10
   \   0000045E   0x2865             CMP      R0,#+101
   \   00000460   0xD3F6             BCC.N    ??HAL_RCCEx_PeriphCLKConfig_47
    632                { 
    633                  /* return in case of Timeout detected */        
    634                  return HAL_TIMEOUT;
   \                     ??HAL_RCCEx_PeriphCLKConfig_6: (+1)
   \   00000462   0x2003             MOVS     R0,#+3
   \   00000464   0xE8BD 0x87F6      POP      {R1,R2,R4-R10,PC}
    635                }
    636              }
    637            }
    638            return HAL_OK;
   \                     ??HAL_RCCEx_PeriphCLKConfig_39: (+1)
   \   00000468   0x2000             MOVS     R0,#+0
   \   0000046A   0xE8BD 0x87F6      POP      {R1,R2,R4-R10,PC}  ;; return
    639          }
    640          
    641          /**
    642            * @brief  Get the RCC_PeriphCLKInitTypeDef according to the internal
    643            *         RCC configuration registers.
    644            * @param  PeriphClkInit: pointer to the configured RCC_PeriphCLKInitTypeDef structure
    645            * @retval None
    646            */

   \                                 In section .text, align 2, keep-with-next
    647          void HAL_RCCEx_GetPeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
    648          {
    649            uint32_t tempreg = 0;
    650            
    651            /* Set all possible values for the extended clock type parameter------------*/ 
    652            PeriphClkInit->PeriphClockSelection = RCC_PERIPHCLK_I2S      | RCC_PERIPHCLK_LPTIM1   |\
    653                                                  RCC_PERIPHCLK_SAI1     | RCC_PERIPHCLK_SAI2     |\
    654                                                  RCC_PERIPHCLK_TIM      | RCC_PERIPHCLK_RTC      |\
    655                                                  RCC_PERIPHCLK_CEC      | RCC_PERIPHCLK_I2C4     |\
    656                                                  RCC_PERIPHCLK_I2C1     | RCC_PERIPHCLK_I2C2     |\
    657                                                  RCC_PERIPHCLK_I2C3     | RCC_PERIPHCLK_USART1   |\
    658                                                  RCC_PERIPHCLK_USART2   | RCC_PERIPHCLK_USART3   |\
    659                                                  RCC_PERIPHCLK_UART4    | RCC_PERIPHCLK_UART5    |\
    660                                                  RCC_PERIPHCLK_USART6   | RCC_PERIPHCLK_UART7    |\
    661                                                  RCC_PERIPHCLK_UART8    | RCC_PERIPHCLK_SDMMC1   |\
    662                                                  RCC_PERIPHCLK_CLK48;
   \                     HAL_RCCEx_GetPeriphCLKConfig: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable2_4  ;; 0xfffff1
   \   00000002   0x6001             STR      R1,[R0, #+0]
    663          
    664            
    665            /* Get the PLLI2S Clock configuration -----------------------------------------------*/
    666            PeriphClkInit->PLLI2S.PLLI2SN = (uint32_t)((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SN) >> POSITION_VAL(RCC_PLLI2SCFGR_PLLI2SN));
   \   00000004   0x....             LDR.N    R1,??DataTable2_5  ;; 0x40023808
   \   00000006   0x6FCA             LDR      R2,[R1, #+124]
   \   00000008   0xF3C2 0x1288      UBFX     R2,R2,#+6,#+9
   \   0000000C   0x6042             STR      R2,[R0, #+4]
    667            PeriphClkInit->PLLI2S.PLLI2SP = (uint32_t)((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SP) >> POSITION_VAL(RCC_PLLI2SCFGR_PLLI2SP));
   \   0000000E   0x6FCA             LDR      R2,[R1, #+124]
   \   00000010   0xF3C2 0x4201      UBFX     R2,R2,#+16,#+2
   \   00000014   0x6102             STR      R2,[R0, #+16]
    668            PeriphClkInit->PLLI2S.PLLI2SQ = (uint32_t)((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SQ) >> POSITION_VAL(RCC_PLLI2SCFGR_PLLI2SQ));
   \   00000016   0x6FCA             LDR      R2,[R1, #+124]
   \   00000018   0xF3C2 0x6203      UBFX     R2,R2,#+24,#+4
   \   0000001C   0x60C2             STR      R2,[R0, #+12]
    669            PeriphClkInit->PLLI2S.PLLI2SR = (uint32_t)((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SR) >> POSITION_VAL(RCC_PLLI2SCFGR_PLLI2SR));
   \   0000001E   0x6FCA             LDR      R2,[R1, #+124]
   \   00000020   0xF3C2 0x7202      UBFX     R2,R2,#+28,#+3
   \   00000024   0x6082             STR      R2,[R0, #+8]
    670            
    671            /* Get the PLLSAI Clock configuration -----------------------------------------------*/
    672            PeriphClkInit->PLLSAI.PLLSAIN = (uint32_t)((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIN) >> POSITION_VAL(RCC_PLLSAICFGR_PLLSAIN));
   \   00000026   0x....             LDR.N    R2,??DataTable2_6  ;; 0x40023888
   \   00000028   0x6813             LDR      R3,[R2, #+0]
   \   0000002A   0xF3C3 0x1388      UBFX     R3,R3,#+6,#+9
   \   0000002E   0x6143             STR      R3,[R0, #+20]
    673            PeriphClkInit->PLLSAI.PLLSAIP = (uint32_t)((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIP) >> POSITION_VAL(RCC_PLLSAICFGR_PLLSAIP));
   \   00000030   0x6813             LDR      R3,[R2, #+0]
   \   00000032   0xF3C3 0x4301      UBFX     R3,R3,#+16,#+2
   \   00000036   0x6203             STR      R3,[R0, #+32]
    674            PeriphClkInit->PLLSAI.PLLSAIQ = (uint32_t)((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIQ) >> POSITION_VAL(RCC_PLLSAICFGR_PLLSAIQ)); 
   \   00000038   0x6813             LDR      R3,[R2, #+0]
   \   0000003A   0xF3C3 0x6303      UBFX     R3,R3,#+24,#+4
   \   0000003E   0x6183             STR      R3,[R0, #+24]
    675            PeriphClkInit->PLLSAI.PLLSAIR = (uint32_t)((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIR) >> POSITION_VAL(RCC_PLLSAICFGR_PLLSAIR)); 
   \   00000040   0x6813             LDR      R3,[R2, #+0]
   \   00000042   0xF3C3 0x7302      UBFX     R3,R3,#+28,#+3
   \   00000046   0x61C3             STR      R3,[R0, #+28]
    676            
    677            /* Get the PLLSAI/PLLI2S division factors -------------------------------------------*/
    678            PeriphClkInit->PLLI2SDivQ = (uint32_t)((RCC->DCKCFGR1 & RCC_DCKCFGR1_PLLI2SDIVQ) >> POSITION_VAL(RCC_DCKCFGR1_PLLI2SDIVQ));
   \   00000048   0x6853             LDR      R3,[R2, #+4]
   \   0000004A   0xF003 0x031F      AND      R3,R3,#0x1F
   \   0000004E   0x6243             STR      R3,[R0, #+36]
    679            PeriphClkInit->PLLSAIDivQ = (uint32_t)((RCC->DCKCFGR1 & RCC_DCKCFGR1_PLLSAIDIVQ) >> POSITION_VAL(RCC_DCKCFGR1_PLLSAIDIVQ));
   \   00000050   0x6853             LDR      R3,[R2, #+4]
   \   00000052   0xF3C3 0x2304      UBFX     R3,R3,#+8,#+5
   \   00000056   0x6283             STR      R3,[R0, #+40]
    680            PeriphClkInit->PLLSAIDivR = (uint32_t)((RCC->DCKCFGR1 & RCC_DCKCFGR1_PLLSAIDIVR) >> POSITION_VAL(RCC_DCKCFGR1_PLLSAIDIVR));
   \   00000058   0x6853             LDR      R3,[R2, #+4]
   \   0000005A   0xF3C3 0x4301      UBFX     R3,R3,#+16,#+2
   \   0000005E   0x62C3             STR      R3,[R0, #+44]
    681          
    682            /* Get the SAI1 clock configuration ----------------------------------------------*/
    683            PeriphClkInit->Sai1ClockSelection = __HAL_RCC_GET_SAI1_SOURCE();
   \   00000060   0x6853             LDR      R3,[R2, #+4]
   \   00000062   0xF403 0x1340      AND      R3,R3,#0x300000
   \   00000066   0x63C3             STR      R3,[R0, #+60]
    684            
    685            /* Get the SAI2 clock configuration ----------------------------------------------*/
    686            PeriphClkInit->Sai2ClockSelection = __HAL_RCC_GET_SAI2_SOURCE();
   \   00000068   0x6853             LDR      R3,[R2, #+4]
   \   0000006A   0xF403 0x0340      AND      R3,R3,#0xC00000
   \   0000006E   0x6403             STR      R3,[R0, #+64]
    687            
    688            /* Get the I2S clock configuration ------------------------------------------*/
    689            PeriphClkInit->I2sClockSelection = __HAL_RCC_GET_I2SCLKSOURCE();
   \   00000070   0x680B             LDR      R3,[R1, #+0]
   \   00000072   0xF403 0x0300      AND      R3,R3,#0x800000
   \   00000076   0x6343             STR      R3,[R0, #+52]
    690            
    691            /* Get the I2C1 clock configuration ------------------------------------------*/
    692            PeriphClkInit->I2c1ClockSelection = __HAL_RCC_GET_I2C1_SOURCE();
   \   00000078   0x6893             LDR      R3,[R2, #+8]
   \   0000007A   0xF403 0x3340      AND      R3,R3,#0x30000
   \   0000007E   0x6643             STR      R3,[R0, #+100]
    693            
    694            /* Get the I2C2 clock configuration ------------------------------------------*/
    695            PeriphClkInit->I2c2ClockSelection = __HAL_RCC_GET_I2C2_SOURCE();
   \   00000080   0x6893             LDR      R3,[R2, #+8]
   \   00000082   0xF403 0x2340      AND      R3,R3,#0xC0000
   \   00000086   0x6683             STR      R3,[R0, #+104]
    696            
    697            /* Get the I2C3 clock configuration ------------------------------------------*/
    698            PeriphClkInit->I2c3ClockSelection = __HAL_RCC_GET_I2C3_SOURCE();
   \   00000088   0x6893             LDR      R3,[R2, #+8]
   \   0000008A   0xF403 0x1340      AND      R3,R3,#0x300000
   \   0000008E   0x66C3             STR      R3,[R0, #+108]
    699            
    700            /* Get the I2C4 clock configuration ------------------------------------------*/
    701            PeriphClkInit->I2c4ClockSelection = __HAL_RCC_GET_I2C4_SOURCE();
   \   00000090   0x6893             LDR      R3,[R2, #+8]
   \   00000092   0xF403 0x0340      AND      R3,R3,#0xC00000
   \   00000096   0x6703             STR      R3,[R0, #+112]
    702            
    703            /* Get the USART1 clock configuration ------------------------------------------*/
    704            PeriphClkInit->Usart1ClockSelection = __HAL_RCC_GET_USART1_SOURCE();
   \   00000098   0x6893             LDR      R3,[R2, #+8]
   \   0000009A   0xF003 0x0303      AND      R3,R3,#0x3
   \   0000009E   0x6443             STR      R3,[R0, #+68]
    705            
    706            /* Get the USART2 clock configuration ------------------------------------------*/
    707            PeriphClkInit->Usart2ClockSelection = __HAL_RCC_GET_USART2_SOURCE();
   \   000000A0   0x6893             LDR      R3,[R2, #+8]
   \   000000A2   0xF003 0x030C      AND      R3,R3,#0xC
   \   000000A6   0x6483             STR      R3,[R0, #+72]
    708            
    709            /* Get the USART3 clock configuration ------------------------------------------*/
    710            PeriphClkInit->Usart3ClockSelection = __HAL_RCC_GET_USART3_SOURCE();
   \   000000A8   0x6893             LDR      R3,[R2, #+8]
   \   000000AA   0xF003 0x0330      AND      R3,R3,#0x30
   \   000000AE   0x64C3             STR      R3,[R0, #+76]
    711            
    712            /* Get the UART4 clock configuration ------------------------------------------*/
    713            PeriphClkInit->Uart4ClockSelection = __HAL_RCC_GET_UART4_SOURCE();
   \   000000B0   0x6893             LDR      R3,[R2, #+8]
   \   000000B2   0xF003 0x03C0      AND      R3,R3,#0xC0
   \   000000B6   0x6503             STR      R3,[R0, #+80]
    714            
    715            /* Get the UART5 clock configuration ------------------------------------------*/
    716            PeriphClkInit->Uart5ClockSelection = __HAL_RCC_GET_UART5_SOURCE();
   \   000000B8   0x6893             LDR      R3,[R2, #+8]
   \   000000BA   0xF403 0x7340      AND      R3,R3,#0x300
   \   000000BE   0x6543             STR      R3,[R0, #+84]
    717            
    718            /* Get the USART6 clock configuration ------------------------------------------*/
    719            PeriphClkInit->Usart6ClockSelection = __HAL_RCC_GET_USART6_SOURCE();
   \   000000C0   0x6893             LDR      R3,[R2, #+8]
   \   000000C2   0xF403 0x6340      AND      R3,R3,#0xC00
   \   000000C6   0x6583             STR      R3,[R0, #+88]
    720            
    721            /* Get the UART7 clock configuration ------------------------------------------*/
    722            PeriphClkInit->Uart7ClockSelection = __HAL_RCC_GET_UART7_SOURCE();
   \   000000C8   0x6893             LDR      R3,[R2, #+8]
   \   000000CA   0xF403 0x5340      AND      R3,R3,#0x3000
   \   000000CE   0x65C3             STR      R3,[R0, #+92]
    723            
    724            /* Get the UART8 clock configuration ------------------------------------------*/
    725            PeriphClkInit->Uart8ClockSelection = __HAL_RCC_GET_UART8_SOURCE();
   \   000000D0   0x6893             LDR      R3,[R2, #+8]
   \   000000D2   0xF403 0x4340      AND      R3,R3,#0xC000
   \   000000D6   0x6603             STR      R3,[R0, #+96]
    726            
    727            /* Get the LPTIM1 clock configuration ------------------------------------------*/
    728            PeriphClkInit->Lptim1ClockSelection = __HAL_RCC_GET_LPTIM1_SOURCE();
   \   000000D8   0x6893             LDR      R3,[R2, #+8]
   \   000000DA   0xF003 0x7340      AND      R3,R3,#0x3000000
   \   000000DE   0x6743             STR      R3,[R0, #+116]
    729            
    730            /* Get the CEC clock configuration -----------------------------------------------*/
    731            PeriphClkInit->CecClockSelection = __HAL_RCC_GET_CEC_SOURCE();
   \   000000E0   0x6893             LDR      R3,[R2, #+8]
   \   000000E2   0xF003 0x6380      AND      R3,R3,#0x4000000
   \   000000E6   0x6783             STR      R3,[R0, #+120]
    732            
    733            /* Get the CK48 clock configuration -----------------------------------------------*/
    734            PeriphClkInit->Clk48ClockSelection = __HAL_RCC_GET_CLK48_SOURCE();
   \   000000E8   0x6893             LDR      R3,[R2, #+8]
   \   000000EA   0xF003 0x6300      AND      R3,R3,#0x8000000
   \   000000EE   0x67C3             STR      R3,[R0, #+124]
    735          
    736            /* Get the SDMMC clock configuration -----------------------------------------------*/
    737            PeriphClkInit->Sdmmc1ClockSelection = __HAL_RCC_GET_SDMMC1_SOURCE();
   \   000000F0   0x6893             LDR      R3,[R2, #+8]
   \   000000F2   0xF003 0x5380      AND      R3,R3,#0x10000000
   \   000000F6   0xF8C0 0x3080      STR      R3,[R0, #+128]
    738            
    739            /* Get the RTC Clock configuration -----------------------------------------------*/
    740            tempreg = (RCC->CFGR & RCC_CFGR_RTCPRE);
   \   000000FA   0x680B             LDR      R3,[R1, #+0]
    741            PeriphClkInit->RTCClockSelection = (uint32_t)((tempreg) | (RCC->BDCR & RCC_BDCR_RTCSEL));
   \   000000FC   0x6E89             LDR      R1,[R1, #+104]
   \   000000FE   0xF403 0x13F8      AND      R3,R3,#0x1F0000
   \   00000102   0xF401 0x7140      AND      R1,R1,#0x300
   \   00000106   0x4319             ORRS     R1,R1,R3
   \   00000108   0x6301             STR      R1,[R0, #+48]
    742            
    743            /* Get the TIM Prescaler configuration --------------------------------------------*/
    744            if ((RCC->DCKCFGR1 & RCC_DCKCFGR1_TIMPRE) == RESET)
   \   0000010A   0x6851             LDR      R1,[R2, #+4]
   \   0000010C   0x01C9             LSLS     R1,R1,#+7
   \   0000010E   0xBF54             ITE      PL 
   \   00000110   0x2100             MOVPL    R1,#+0
   \   00000112   0xF04F 0x7180      MOVMI    R1,#+16777216
    745            {
    746              PeriphClkInit->TIMPresSelection = RCC_TIMPRES_DESACTIVATED;
    747            }
    748            else
    749            {
    750              PeriphClkInit->TIMPresSelection = RCC_TIMPRES_ACTIVATED;
   \   00000116   0x6381             STR      R1,[R0, #+56]
    751            }
    752          }
   \   00000118   0x4770             BX       LR               ;; return
    753          
    754          /**
    755            * @brief  Return the peripheral clock frequency for a given peripheral(SAI..) 
    756            * @note   Return 0 if peripheral clock identifier not managed by this API
    757            * @param  PeriphClk: Peripheral clock identifier
    758            *         This parameter can be one of the following values:
    759            *            @arg RCC_PERIPHCLK_SAI1: SAI1 peripheral clock
    760            *            @arg RCC_PERIPHCLK_SAI2: SAI2 peripheral clock
    761            * @retval Frequency in KHz
    762            */

   \                                 In section .text, align 2, keep-with-next
    763          uint32_t HAL_RCCEx_GetPeriphCLKFreq(uint32_t PeriphClk)
    764          {
   \                     HAL_RCCEx_GetPeriphCLKFreq: (+1)
   \   00000000   0x4601             MOV      R1,R0
    765            uint32_t tmpreg = 0;
    766            /* This variable is used to store the SAI clock frequency (value in Hz) */
    767            uint32_t frequency = 0;
   \   00000002   0x2000             MOVS     R0,#+0
    768            /* This variable is used to store the VCO Input (value in Hz) */
    769            uint32_t vcoinput = 0;
    770            /* This variable is used to store the SAI clock source */
    771            uint32_t saiclocksource = 0;
    772            
    773            if (PeriphClk == RCC_PERIPHCLK_SAI1)
   \   00000004   0xF5B1 0x2F00      CMP      R1,#+524288
   \   00000008   0xD12F             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_0
    774            {
    775              saiclocksource = RCC->DCKCFGR1;   
   \   0000000A   0x....             LDR.N    R2,??DataTable2_1  ;; 0x40023884
   \   0000000C   0x6893             LDR      R3,[R2, #+8]
    776              saiclocksource &= RCC_DCKCFGR1_SAI1SEL;
    777              switch (saiclocksource)
   \   0000000E   0xF413 0x1340      ANDS     R3,R3,#0x300000
   \   00000012   0xD006             BEQ.N    ??HAL_RCCEx_GetPeriphCLKFreq_1
   \   00000014   0xF5B3 0x1F80      CMP      R3,#+1048576
   \   00000018   0xD01B             BEQ.N    ??HAL_RCCEx_GetPeriphCLKFreq_2
   \   0000001A   0xF5B3 0x1F00      CMP      R3,#+2097152
   \   0000001E   0xD066             BEQ.N    ??HAL_RCCEx_GetPeriphCLKFreq_3
   \   00000020   0xE023             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_0
    778              {
    779              case 0: /* PLLSAI is the clock source for SAI1 */ 
    780                {
    781                  /* Configure the PLLSAI division factor */
    782                  /* PLLSAI_VCO Input  = PLL_SOURCE/PLLM */ 
    783                  if((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLSOURCE_HSI)
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_1: (+1)
   \   00000022   0x....             LDR.N    R0,??DataTable2_7  ;; 0x40023804
   \   00000024   0x6801             LDR      R1,[R0, #+0]
   \   00000026   0x0249             LSLS     R1,R1,#+9
   \   00000028   0xBF54             ITE      PL 
   \   0000002A   0x....             LDRPL.N  R1,??DataTable2_8  ;; 0xf42400
   \   0000002C   0x....             LDRMI.N  R1,??DataTable2_9  ;; 0x17d7840
    784                  {
    785                    /* In Case the PLL Source is HSI (Internal Clock) */
    786                    vcoinput = (HSI_VALUE / (uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLM));
    787                  }
    788                  else
    789                  {
    790                    /* In Case the PLL Source is HSE (External Clock) */
    791                    vcoinput = ((HSE_VALUE / (uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLM)));
   \   0000002E   0x6800             LDR      R0,[R0, #+0]
   \   00000030   0xF000 0x003F      AND      R0,R0,#0x3F
   \   00000034   0xFBB1 0xF0F0      UDIV     R0,R1,R0
    792                  }   
    793                  /* PLLSAI_VCO Output = PLLSAI_VCO Input * PLLSAIN */
    794                  /* SAI_CLK(first level) = PLLSAI_VCO Output/PLLSAIQ */
    795                  tmpreg = (RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIQ) >> 24;
   \   00000038   0x6851             LDR      R1,[R2, #+4]
    796                  frequency = (vcoinput * ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIN) >> 6))/(tmpreg);
   \   0000003A   0x6853             LDR      R3,[R2, #+4]
    797                  
    798                  /* SAI_CLK_x = SAI_CLK(first level)/PLLSAIDIVQ */
    799                  tmpreg = (((RCC->DCKCFGR1 & RCC_DCKCFGR1_PLLSAIDIVQ) >> 8) + 1);
   \   0000003C   0x6892             LDR      R2,[R2, #+8]
    800                  frequency = frequency/(tmpreg); 
   \   0000003E   0xF3C3 0x1388      UBFX     R3,R3,#+6,#+9
   \   00000042   0xF3C1 0x6103      UBFX     R1,R1,#+24,#+4
   \   00000046   0x4358             MULS     R0,R3,R0
   \   00000048   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   0000004C   0xF3C2 0x2104      UBFX     R1,R2,#+8,#+5
   \   00000050   0xE049             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_4
    801                  break;       
    802                }
    803              case RCC_DCKCFGR1_SAI1SEL_0: /* PLLI2S is the clock source for SAI1 */
    804                {  
    805                  /* Configure the PLLI2S division factor */
    806                  /* PLLI2S_VCO Input  = PLL_SOURCE/PLLM */ 
    807                  if((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLSOURCE_HSI)
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_2: (+1)
   \   00000052   0x....             LDR.N    R0,??DataTable2_7  ;; 0x40023804
   \   00000054   0x6801             LDR      R1,[R0, #+0]
   \   00000056   0x0249             LSLS     R1,R1,#+9
   \   00000058   0xBF54             ITE      PL 
   \   0000005A   0x....             LDRPL.N  R1,??DataTable2_8  ;; 0xf42400
   \   0000005C   0x....             LDRMI.N  R1,??DataTable2_9  ;; 0x17d7840
    808                  {
    809                    /* In Case the PLL Source is HSI (Internal Clock) */
    810                    vcoinput = (HSI_VALUE / (uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLM));
    811                  }
    812                  else
    813                  {
    814                    /* In Case the PLL Source is HSE (External Clock) */
    815                    vcoinput = ((HSE_VALUE / (uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLM)));
   \   0000005E   0x6800             LDR      R0,[R0, #+0]
   \   00000060   0xF000 0x003F      AND      R0,R0,#0x3F
   \   00000064   0xFBB1 0xF0F0      UDIV     R0,R1,R0
    816                  }
    817                  
    818                  /* PLLI2S_VCO Output = PLLI2S_VCO Input * PLLI2SN */
    819                  /* SAI_CLK(first level) = PLLI2S_VCO Output/PLLI2SQ */
    820                  tmpreg = (RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SQ) >> 24;
   \   00000068   0xE031             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_5
    821                  frequency = (vcoinput * ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SN) >> 6))/(tmpreg);
    822                  
    823                  /* SAI_CLK_x = SAI_CLK(first level)/PLLI2SDIVQ */
    824                  tmpreg = ((RCC->DCKCFGR1 & RCC_DCKCFGR1_PLLI2SDIVQ) + 1); 
    825                  frequency = frequency/(tmpreg);
    826                  break;
    827                }
    828              case RCC_DCKCFGR1_SAI1SEL_1: /* External clock is the clock source for SAI1 */
    829                {
    830                  frequency = EXTERNAL_CLOCK_VALUE;
    831                  break;       
    832                }
    833              default :
    834                {
    835                  break;
    836                }
    837              }
    838            }
    839            
    840            if (PeriphClk == RCC_PERIPHCLK_SAI2)
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_0: (+1)
   \   0000006A   0xF5B1 0x1F80      CMP      R1,#+1048576
   \   0000006E   0xD13F             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_6
    841            {
    842              saiclocksource = RCC->DCKCFGR1;   
   \   00000070   0x....             LDR.N    R2,??DataTable2_1  ;; 0x40023884
   \   00000072   0x6891             LDR      R1,[R2, #+8]
    843              saiclocksource &= RCC_DCKCFGR1_SAI2SEL;
    844              switch (saiclocksource)
   \   00000074   0xF411 0x0140      ANDS     R1,R1,#0xC00000
   \   00000078   0xD006             BEQ.N    ??HAL_RCCEx_GetPeriphCLKFreq_7
   \   0000007A   0xF5B1 0x0F80      CMP      R1,#+4194304
   \   0000007E   0xD01B             BEQ.N    ??HAL_RCCEx_GetPeriphCLKFreq_8
   \   00000080   0xF5B1 0x0F00      CMP      R1,#+8388608
   \   00000084   0xD033             BEQ.N    ??HAL_RCCEx_GetPeriphCLKFreq_3
   \   00000086   0x4770             BX       LR
    845              {
    846              case 0: /* PLLSAI is the clock source for SAI*/ 
    847                {
    848                  /* Configure the PLLSAI division factor */
    849                  /* PLLSAI_VCO Input  = PLL_SOURCE/PLLM */ 
    850                  if((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLSOURCE_HSI)
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_7: (+1)
   \   00000088   0x....             LDR.N    R0,??DataTable2_7  ;; 0x40023804
   \   0000008A   0x6801             LDR      R1,[R0, #+0]
   \   0000008C   0x0249             LSLS     R1,R1,#+9
   \   0000008E   0xBF54             ITE      PL 
   \   00000090   0x....             LDRPL.N  R1,??DataTable2_8  ;; 0xf42400
   \   00000092   0x....             LDRMI.N  R1,??DataTable2_9  ;; 0x17d7840
    851                  {
    852                    /* In Case the PLL Source is HSI (Internal Clock) */
    853                    vcoinput = (HSI_VALUE / (uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLM));
    854                  }
    855                  else
    856                  {
    857                    /* In Case the PLL Source is HSE (External Clock) */
    858                    vcoinput = ((HSE_VALUE / (uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLM)));
   \   00000094   0x6800             LDR      R0,[R0, #+0]
   \   00000096   0xF000 0x003F      AND      R0,R0,#0x3F
   \   0000009A   0xFBB1 0xF0F0      UDIV     R0,R1,R0
    859                  }   
    860                  /* PLLSAI_VCO Output = PLLSAI_VCO Input * PLLSAIN */
    861                  /* SAI_CLK(first level) = PLLSAI_VCO Output/PLLSAIQ */
    862                  tmpreg = (RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIQ) >> 24;
   \   0000009E   0x6851             LDR      R1,[R2, #+4]
    863                  frequency = (vcoinput * ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIN) >> 6))/(tmpreg);
   \   000000A0   0x6853             LDR      R3,[R2, #+4]
    864                  
    865                  /* SAI_CLK_x = SAI_CLK(first level)/PLLSAIDIVQ */
    866                  tmpreg = (((RCC->DCKCFGR1 & RCC_DCKCFGR1_PLLSAIDIVQ) >> 8) + 1);
   \   000000A2   0x6892             LDR      R2,[R2, #+8]
    867                  frequency = frequency/(tmpreg); 
   \   000000A4   0xF3C3 0x1388      UBFX     R3,R3,#+6,#+9
   \   000000A8   0xF3C1 0x6103      UBFX     R1,R1,#+24,#+4
   \   000000AC   0x4358             MULS     R0,R3,R0
   \   000000AE   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   000000B2   0xF3C2 0x2104      UBFX     R1,R2,#+8,#+5
   \   000000B6   0xE016             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_4
    868                  break;       
    869                }
    870              case RCC_DCKCFGR1_SAI2SEL_0: /* PLLI2S is the clock source for SAI2 */
    871                {  
    872                  /* Configure the PLLI2S division factor */
    873                  /* PLLI2S_VCO Input  = PLL_SOURCE/PLLM */ 
    874                  if((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLSOURCE_HSI)
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_8: (+1)
   \   000000B8   0x....             LDR.N    R0,??DataTable2_7  ;; 0x40023804
   \   000000BA   0x6801             LDR      R1,[R0, #+0]
   \   000000BC   0x0249             LSLS     R1,R1,#+9
   \   000000BE   0xBF54             ITE      PL 
   \   000000C0   0x....             LDRPL.N  R1,??DataTable2_8  ;; 0xf42400
   \   000000C2   0x....             LDRMI.N  R1,??DataTable2_9  ;; 0x17d7840
    875                  {
    876                    /* In Case the PLL Source is HSI (Internal Clock) */
    877                    vcoinput = (HSI_VALUE / (uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLM));
    878                  }
    879                  else
    880                  {
    881                    /* In Case the PLL Source is HSE (External Clock) */
    882                    vcoinput = ((HSE_VALUE / (uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLM)));
   \   000000C4   0x6800             LDR      R0,[R0, #+0]
   \   000000C6   0xF000 0x003F      AND      R0,R0,#0x3F
   \   000000CA   0xFBB1 0xF0F0      UDIV     R0,R1,R0
    883                  }
    884                  
    885                  /* PLLI2S_VCO Output = PLLI2S_VCO Input * PLLI2SN */
    886                  /* SAI_CLK(first level) = PLLI2S_VCO Output/PLLI2SQ */
    887                  tmpreg = (RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SQ) >> 24;
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_5: (+1)
   \   000000CE   0x6811             LDR      R1,[R2, #+0]
    888                  frequency = (vcoinput * ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SN) >> 6))/(tmpreg);
   \   000000D0   0x6813             LDR      R3,[R2, #+0]
    889                  
    890                  /* SAI_CLK_x = SAI_CLK(first level)/PLLI2SDIVQ */
    891                  tmpreg = ((RCC->DCKCFGR1 & RCC_DCKCFGR1_PLLI2SDIVQ) + 1); 
   \   000000D2   0x6892             LDR      R2,[R2, #+8]
    892                  frequency = frequency/(tmpreg);
   \   000000D4   0xF3C3 0x1388      UBFX     R3,R3,#+6,#+9
   \   000000D8   0xF3C1 0x6103      UBFX     R1,R1,#+24,#+4
   \   000000DC   0x4358             MULS     R0,R3,R0
   \   000000DE   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   000000E2   0xF002 0x011F      AND      R1,R2,#0x1F
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_4: (+1)
   \   000000E6   0x1C49             ADDS     R1,R1,#+1
   \   000000E8   0xFBB0 0xF0F1      UDIV     R0,R0,R1
    893                  break;
   \   000000EC   0x4770             BX       LR
    894                }
    895              case RCC_DCKCFGR1_SAI2SEL_1: /* External clock is the clock source for SAI2 */
    896                {
    897                  frequency = EXTERNAL_CLOCK_VALUE;
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_3: (+1)
   \   000000EE   0x....             LDR.N    R0,??DataTable2_10  ;; 0xbb8000
    898                  break;       
    899                }
    900              default :
    901                {
    902                  break;
    903                }
    904              }
    905            }
    906            
    907            return frequency;
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_6: (+1)
   \   000000F0   0x4770             BX       LR               ;; return
    908          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2:
   \   00000000   0x40023800         DC32     0x40023800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_1:
   \   00000000   0x40023884         DC32     0x40023884

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_2:
   \   00000000   0x40007000         DC32     0x40007000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_3:
   \   00000000   0x0FFFFCFF         DC32     0xffffcff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_4:
   \   00000000   0x00FFFFF1         DC32     0xfffff1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_5:
   \   00000000   0x40023808         DC32     0x40023808

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_6:
   \   00000000   0x40023888         DC32     0x40023888

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_7:
   \   00000000   0x40023804         DC32     0x40023804

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_8:
   \   00000000   0x00F42400         DC32     0xf42400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_9:
   \   00000000   0x017D7840         DC32     0x17d7840

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_10:
   \   00000000   0x00BB8000         DC32     0xbb8000
    909          /**
    910            * @}
    911            */
    912          
    913          /**
    914            * @}
    915            */
    916          
    917          #endif /* HAL_RCC_MODULE_ENABLED */
    918          /**
    919            * @}
    920            */
    921          
    922          /**
    923            * @}
    924            */
    925          
    926          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   HAL_RCCEx_GetPeriphCLKConfig
       0   HAL_RCCEx_GetPeriphCLKFreq
      40   HAL_RCCEx_PeriphCLKConfig
        40   -> HAL_GetTick


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable2
       4  ??DataTable2_1
       4  ??DataTable2_10
       4  ??DataTable2_2
       4  ??DataTable2_3
       4  ??DataTable2_4
       4  ??DataTable2_5
       4  ??DataTable2_6
       4  ??DataTable2_7
       4  ??DataTable2_8
       4  ??DataTable2_9
     282  HAL_RCCEx_GetPeriphCLKConfig
     242  HAL_RCCEx_GetPeriphCLKFreq
    1134  HAL_RCCEx_PeriphCLKConfig

 
 1 702 bytes in section .text
 
 1 702 bytes of CODE memory

Errors: none
Warnings: none
