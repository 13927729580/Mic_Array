###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.2.10312/W32 for ARM       21/Dec/2015  01:05:06
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\Src\audio_codec.c
#    Command line =  
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\Src\audio_codec.c
#        -D USE_HAL_DRIVER -D STM32F746xx -D USE_STM32746G_DISCO -D
#        USE_IOEXPANDER -D USE_USB_FS -lC
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
#        -lA
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
#        -o
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M7 -e --fpu=VFPv5_sp --dlib_config "D:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.3\arm\INC\c\DLib_Config_Full.h"
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\Inc\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\CMSIS\Device\ST\STM32F7xx\Include\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\STM32F7xx_HAL_Driver\Inc\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\STM32746G-Discovery\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\Components\Common\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Log\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Fonts\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\CPU\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_Device_Library\Core\Inc\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Core\Inc\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Class\MSC\Inc\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\drivers\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_Audio\Addons\PDM\
#        -On --use_c++_inline --require_prototypes -I "D:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.3\arm\CMSIS\Include\" -D
#        ARM_MATH_CM7
#    List file    =  
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List\audio_codec.lst
#    Object file  =  
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj\audio_codec.o
#
###############################################################################

H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\Src\audio_codec.c
      1          /**
      2            ******************************************************************************
      3            * @file    audio_codec.c
      4            * @author  Phan Le Son ( porting from "MCD Application Team")
      5            * @version V1.0.0
      6            * @date    12-December-2015
      7            * @brief   This file includes the low layer driver for CS43L22 Audio Codec 
      8            ******************************************************************************
      9                                                       User NOTES
     10          1. How To use this driver:
     11          --------------------------
     12             - Call the function AUDIO_Init(
     13                                              OutputDevice: physical output mode (OUTPUT_DEVICE_SPEAKER, 
     14                                                           OUTPUT_DEVICE_HEADPHONE, OUTPUT_DEVICE_AUTO or 
     15                                                           OUTPUT_DEVICE_BOTH)
     16                                              Volume: initial volume to be set (0 is min (mute), 100 is max (100%)
     17                                              AudioFreq: Audio frequency in Hz (8000, 16000, 22500, 32000 ...)
     18                                              this parameter is relative to the audio file/stream type.
     19                                             )
     20                This function configures all the hardware required for the audio application (codec, I2C, I2S, 
     21                GPIOs, DMA and interrupt if needed). This function returns 0 if configuration is OK.
     22                if the returned value is different from 0 or the function is stuck then the communication with
     23                the codec (try to un-plug the power or reset device in this case).
     24                + OUTPUT_DEVICE_SPEAKER: only speaker will be set as output for the audio stream.
     25                + OUTPUT_DEVICE_HEADPHONE: only headphones will be set as output for the audio stream.
     26                + OUTPUT_DEVICE_AUTO: Selection of output device is made through external switch (implemented 
     27                   into the audio jack on the board). When the Headphone is connected it is used
     28                   as output. When the headphone is disconnected from the audio jack, the output is
     29                   automatically switched to Speaker.
     30                + OUTPUT_DEVICE_BOTH: both Speaker and Headphone are used as outputs for the audio stream
     31                   at the same time.
     32             - Call the function AUDIO_Play(
     33                                            pBuffer: pointer to the audio data file address
     34                                            Size: size of the buffer to be sent in Bytes
     35                                           )
     36                to start playing (for the first time) from the audio file/stream.
     37             - Call the function AUDIO_PauseResume(
     38                                                   Cmd: AUDIO_PAUSE (or 0) to pause playing or AUDIO_RESUME (or 
     39                                                         any value different from 0) to resume playing.
     40                                                   )
     41                 Note. After calling AUDIO_PauseResume() function for pause, only AUDIO_PauseResume() should be called
     42                    for resume (it is not allowed to call AUDIO_Play() in this case).
     43                 Note. This function should be called only when the audio file is played or paused (not stopped).
     44             - For each mode, you may need to implement the relative callback functions into your code.
     45                The Callback functions are named AUDIO_XXX_CallBack() and only their prototypes are declared in 
     46                the stm32f4_discovery_audio_codec.h file. (refer to the example for more details on the callbacks implementations)
     47             - To Stop playing, to modify the volume level or to mute, use the functions
     48                 AUDIO_Stop(), AUDIO_VolumeCtl() and AUDIO_Mute().
     49           
     50           Driver architecture:
     51           --------------------
     52           This driver is composed of three main layers:
     53             o High Audio Layer: consists of the function API exported in the audio_codec.h file
     54               (AUDIO_Init(), AUDIO_Play() ...)
     55             o Codec Control layer: consists of the functions API controlling the audio codec (CS43L22) and 
     56               included as local functions in file stm32f4_discovery_audio_codec.c (Codec_Init(), Codec_Play() ...)
     57             o Media Access Layer (MAL): which consists of functions allowing to access the media containing/
     58               providing the audio file/stream. These functions are also included as local functions into
     59               the stm32f4_discovery_audio_codec.c file (Audio_MAL_Init(), Audio_MAL_Play() ...)
     60            Each set of functions (layer) may be implemented independently of the others and customized when 
     61            needed.    
     62          2. Modes description:
     63          ---------------------
     64               + AUDIO_MAL_MODE_NORMAL : is suitable when the audio file is in a memory location.
     65               + AUDIO_MAL_MODE_CIRCULAR: is suitable when the audio data are read either from a 
     66                  memory location or from a device at real time (double buffer could be used).
     67          3. DMA interrupts description:
     68          ------------------------------
     69               + AUDIO_IT_TC_ENABLE: Enable this define to use the DMA end of transfer interrupt.
     70                  then, a callback should be implemented by user to perform specific actions
     71                  when the DMA has finished the transfer.
     72               + AUDIO_IT_HT_ENABLE: Enable this define to use the DMA end of half transfer interrupt.
     73                  then, a callback should be implemented by user to perform specific actions
     74                  when the DMA has reached the half of the buffer transfer (generally, it is useful 
     75                  to load the first half of buffer while DMA is loading from the second half).
     76               + AUDIO_IT_ER_ENABLE: Enable this define to manage the cases of error on DMA transfer.
     77          4. Known Limitations:
     78          ---------------------
     79             1- When using the Speaker, if the audio file quality is not high enough, the speaker output
     80                may produce high and uncomfortable noise level. To avoid this issue, to use speaker
     81                output properly, try to increase audio file sampling rate (typically higher than 48KHz).
     82                This operation will lead to larger file size.
     83             2- Communication with the audio codec (through I2C) may be corrupted if it is interrupted by some
     84                user interrupt routines (in this case, interrupts could be disabled just before the start of 
     85                communication then re-enabled when it is over). Note that this communication is only done at
     86                the configuration phase (AUDIO_Init() or AUDIO_Stop()) and when Volume control modification is 
     87                performed (AUDIO_VolumeCtl() or AUDIO_Mute()). When the audio data is played, no communication is 
     88                required with the audio codec.
     89            3- Parsing of audio file is not implemented (in order to determine audio file properties: Mono/Stereo, Data size, 
     90               File size, Audio Frequency, Audio Data header size ...). The configuration is fixed for the given audio file.
     91            4- Mono audio streaming is not supported (in order to play mono audio streams, each data should be sent twice 
     92               on the I2S or should be duplicated on the source buffer. Or convert the stream in stereo before playing).
     93            5- Supports only 16-bit audio data size.
     94          */
     95          
     96          
     97          /* Includes ------------------------------------------------------------------*/
     98          #include "audio_codec.h"
     99          #include "stm32746g_discovery.h"
    100          #include "stm32f7xx_hal_i2s.h"
    101          #include "audio.h"
    102          #include "main.h"
    103          
    104           /* This is an audio file stored in the Flash memory as a constant table of 16-bit data.
    105              The audio format should be WAV (raw / PCM) 16-bits, Stereo (sampling rate may be modified) */
    106          extern const uint16_t AUDIO_SAMPLE[];
    107          /* Audio file size and start address are defined here since the audio file is 
    108              stored in Flash memory as a constant table of 16-bit data */
    109          #define AUDIO_FILE_SZE          990000
    110          #define AUIDO_START_ADDRESS     58 /* Offset relative to audio file header size */
    111          
    112          #define  I2C_CR1_SMBUS                       ((uint16_t)0x0002)            /*!<SMBus Mode */
    113          #define  I2C_CR1_SMBTYPE                     ((uint16_t)0x0008)            /*!<SMBus Type */
    114          #define  I2C_CR1_ENARP                       ((uint16_t)0x0010)            /*!<ARP Enable */
    115          #define  I2C_CR1_ENPEC                       ((uint16_t)0x0020)            /*!<PEC Enable */
    116          #define  I2C_CR1_ENGC                        ((uint16_t)0x0040)            /*!<General Call Enable */
    117          
    118          #define  I2C_CR1_START                       ((uint16_t)0x0100)            /*!<Start Generation */
    119          #define  I2C_CR1_STOP                        ((uint16_t)0x0200)            /*!<Stop Generation */
    120          #define  I2C_CR1_ACK                         ((uint16_t)0x0400)            /*!<Acknowledge Enable */
    121          #define  I2C_CR1_POS                         ((uint16_t)0x0800)            /*!<Acknowledge/PEC Position (for data reception) */
    122          #define  I2C_CR1_PEC                         ((uint16_t)0x1000)            /*!<Packet Error Checking */
    123          #define  I2C_CR1_ALERT                       ((uint16_t)0x2000)            /*!<SMBus Alert */
    124          
    125          #define  I2C_Direction_Transmitter      ((uint8_t)0x00)
    126          #define  I2C_Direction_Receiver         ((uint8_t)0x01)
    127          #define IS_I2C_DIRECTION(DIRECTION) (((DIRECTION) == I2C_Direction_Transmitter) || \
    128                                               ((DIRECTION) == I2C_Direction_Receiver))
    129          /*******************  Bit definition for I2C_OAR1 register  *******************/
    130          #define  I2C_OAR1_ADD1_7                     ((uint16_t)0x00FE)            /*!<Interface Address */
    131          #define  I2C_OAR1_ADD8_9                     ((uint16_t)0x0300)            /*!<Interface Address */
    132          									 
    133          #define  I2C_OAR1_ADD0                       ((uint16_t)0x0001)            /*!<Bit 0 */
    134          #define  I2C_OAR1_ADD1                       ((uint16_t)0x0002)            /*!<Bit 1 */
    135          #define  I2C_OAR1_ADD2                       ((uint16_t)0x0004)            /*!<Bit 2 */
    136          #define  I2C_OAR1_ADD3                       ((uint16_t)0x0008)            /*!<Bit 3 */
    137          #define  I2C_OAR1_ADD4                       ((uint16_t)0x0010)            /*!<Bit 4 */
    138          #define  I2C_OAR1_ADD5                       ((uint16_t)0x0020)            /*!<Bit 5 */
    139          #define  I2C_OAR1_ADD6                       ((uint16_t)0x0040)            /*!<Bit 6 */
    140          #define  I2C_OAR1_ADD7                       ((uint16_t)0x0080)            /*!<Bit 7 */
    141          #define  I2C_OAR1_ADD8                       ((uint16_t)0x0100)            /*!<Bit 8 */
    142          #define  I2C_OAR1_ADD9                       ((uint16_t)0x0200)            /*!<Bit 9 */
    143          									 
    144          #define  I2C_OAR1_ADDMODE                    ((uint16_t)0x8000)            /*!<Addressing Mode (Slave mode) */
    145          
    146          #define CR1_CLEAR_MASK    ((uint16_t)0xFBF5)      /*<! I2C registers Masks */
    147          #define FLAG_MASK         ((uint32_t)0x00FFFFFF)  /*<! I2C FLAG mask */
    148          #define ITEN_MASK         ((uint32_t)0x07000000)  /*<! I2C Interrupt Enable mask */
    149          
    150          #define  I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED        ((uint32_t)0x00070082)  /* BUSY, MSL, ADDR, TXE and TRA flags */
    151          #define  I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED           ((uint32_t)0x00030002)  /* BUSY, MSL and ADDR flags */
    152          /* --EV9 */
    153          #define  I2C_EVENT_MASTER_MODE_ADDRESS10                   ((uint32_t)0x00030008)  /* BUSY, MSL and ADD10 flags */
    154          
    155          /* Master RECEIVER mode -----------------------------*/ 
    156          /* --EV7 */
    157          #define  I2C_EVENT_MASTER_BYTE_RECEIVED                    ((uint32_t)0x00030040)  /* BUSY, MSL and RXNE flags */
    158          
    159          /* Master TRANSMITTER mode --------------------------*/
    160          /* --EV8 */
    161          #define I2C_EVENT_MASTER_BYTE_TRANSMITTING                 ((uint32_t)0x00070080) /* TRA, BUSY, MSL, TXE flags */
    162          /* --EV8_2 */
    163          #define  I2C_EVENT_MASTER_BYTE_TRANSMITTED                 ((uint32_t)0x00070084)  /* TRA, BUSY, MSL, TXE and BTF flags */
    164          
    165          #define I2C_FLAG_SMBALERT               ((uint32_t)0x00018000)
    166          
    167          #define I2C_FLAG_ADD10                  ((uint32_t)0x00010008)
    168          #define I2C_FLAG_BTF                    ((uint32_t)0x00010004)
    169          
    170          #define I2C_FLAG_SB                     ((uint32_t)0x00010001)
    171          #define I2C_FLAG_DUALF                  ((uint32_t)0x00100080)
    172          #define I2C_FLAG_SMBHOST                ((uint32_t)0x00100040)
    173          #define I2C_FLAG_SMBDEFAULT             ((uint32_t)0x00100020)
    174          #define I2C_FLAG_GENCALL                ((uint32_t)0x00100010)
    175          #define I2C_FLAG_TRA                    ((uint32_t)0x00100004)
    176          
    177          #define I2C_FLAG_MSL                    ((uint32_t)0x00100001)
    178          #define  I2C_EVENT_MASTER_MODE_SELECT                      ((uint32_t)0x00030001)  /* BUSY, MSL and SB flag */
    179          
    180          
    181          #define SPI_I2S_DMAReq_Tx               ((uint16_t)0x0002)
    182          #define SPI_I2S_DMAReq_Rx               ((uint16_t)0x0001)
    183          //#define IS_SPI_I2S_DMAREQ(DMAREQ) ((((DMAREQ) & (uint16_t)0xFFFC) == 0x00) && ((DMAREQ) != 0x00))
    184          
    185          
    186          /** 
    187            *      This file includes the low layer driver for CS43L22 Audio Codec
    188            *              available on STM32F4-Discovery Kit.
    189            *
    190            */ 
    191          
    192          
    193          
    194          /* Mask for the bit EN of the I2S CFGR register */
    195          #define I2S_ENABLE_MASK                 0x0400
    196          
    197          /* Delay for the Codec to be correctly reset */
    198          #define CODEC_RESET_DELAY               0x4FFF
    199          
    200          
    201          /* The 7 bits Codec address (sent through I2C interface) */
    202          #define CODEC_ADDRESS                   0x94  /* b00100111 */
    203          
    204          
    205          /* This structure is declared global because it is handled by two different functions */

   \                                 In section .bss, align 4
    206          DMA_InitTypeDef DMA_InitStructure; 
   \                     DMA_InitStructure:
   \   00000000                      DS8 48

   \                                 In section .bss, align 4
    207          DMA_InitTypeDef AUDIO_MAL_DMA_InitStructure;
   \                     AUDIO_MAL_DMA_InitStructure:
   \   00000000                      DS8 48
    208          

   \                                 In section .data, align 4
    209          uint32_t AudioTotalSize = 0xFFFF; /* This variable holds the total size of the audio file */
   \                     AudioTotalSize:
   \   00000000   0x0000FFFF         DC32 65535

   \                                 In section .data, align 4
    210          uint32_t AudioRemSize   = 0xFFFF; /* This variable holds the remaining data in audio file */
   \                     AudioRemSize:
   \   00000000   0x0000FFFF         DC32 65535

   \                                 In section .bss, align 4
    211          uint16_t *CurrentPos ;             /* This variable holds the current position of audio pointer */
   \                     CurrentPos:
   \   00000000                      DS8 4
    212          

   \                                 In section .data, align 4
    213          __IO uint32_t  CODECTimeout = CODEC_LONG_TIMEOUT;   
   \                     CODECTimeout:
   \   00000000   0x0012C000         DC32 1228800

   \                                 In section .bss, align 1
    214          __IO uint8_t OutputDev = 0;
   \                     OutputDev:
   \   00000000                      DS8 1
    215          
    216          

   \                                 In section .data, align 4
    217          __IO uint32_t CurrAudioInterface = AUDIO_INTERFACE_I2S; //AUDIO_INTERFACE_DAC
   \                     CurrAudioInterface:
   \   00000000   0x00000001         DC32 1
    218          

   \                                 In section .bss, align 4
    219          DMA_HandleTypeDef     DmaHandle;
   \                     DmaHandle:
   \   00000000                      DS8 80

   \                                 In section .bss, align 4
    220          I2S_HandleTypeDef     hi2s3;
   \                     hi2s3:
   \   00000000                      DS8 64

   \                                 In section .bss, align 4
    221          I2C_HandleTypeDef     hi2c1;
   \                     hi2c1:
   \   00000000                      DS8 60

   \                                 In section .data, align 1
    222          uint8_t Volume=80;
   \                     Volume:
   \   00000000   0x50               DC8 80
    223          static void Audio_MAL_IRQHandler(void);
    224          /*-----------------------------------
    225                                     Audio Codec functions 
    226                                              ------------------------------------------*/
    227          /* High Layer codec functions */
    228          static uint32_t Codec_Init(uint16_t OutputDevice, uint8_t Volume, uint32_t AudioFreq);
    229          static uint32_t Codec_DeInit(void);
    230          static uint32_t Codec_Play(void);
    231          static uint32_t Codec_PauseResume(uint32_t Cmd);
    232          static uint32_t Codec_Stop(uint32_t Cmd);
    233          static uint32_t Codec_VolumeCtrl(uint8_t Volume);
    234          static uint32_t Codec_Mute(uint32_t Cmd);
    235          /* Low layer codec functions */
    236          static void     Codec_CtrlInterface_Init(void);
    237          static void     Codec_CtrlInterface_DeInit(void);
    238          static void     Codec_AudioInterface_Init(uint32_t AudioFreq);
    239          static void     Codec_AudioInterface_DeInit(void);
    240          static void     Codec_Reset(void);
    241          static uint32_t Codec_WriteRegister(uint8_t RegisterAddr, uint8_t RegisterValue);
    242          static uint32_t Codec_ReadRegister(uint8_t RegisterAddr);
    243          static void     Codec_GPIO_Init(void);
    244          static void     Codec_GPIO_DeInit(void);
    245          static void     Delay(__IO uint32_t nCount);
    246          static void SPI_I2S_SendData(SPI_TypeDef* SPIx, uint16_t Data);
    247          static void I2C_GenerateSTART(I2C_TypeDef* I2Cx, FunctionalState NewState);
    248          static void I2C_Send7bitAddress(I2C_TypeDef* I2Cx, uint8_t Address, uint8_t I2C_Direction);
    249          static ErrorStatus I2C_CheckEvent(I2C_TypeDef* I2Cx, uint32_t I2C_EVENT);
    250          static void I2C_SendData(I2C_TypeDef* I2Cx, uint8_t Data);
    251          static void I2C_GenerateSTOP(I2C_TypeDef* I2Cx, FunctionalState NewState);
    252          static FlagStatus I2C_GetFlagStatus(I2C_TypeDef* I2Cx, uint32_t I2C_FLAG);
    253          static void I2C_AcknowledgeConfig(I2C_TypeDef* I2Cx, FunctionalState NewState);
    254          static uint8_t I2C_ReceiveData(I2C_TypeDef* I2Cx);
    255          static void I2C_ClearFlag(I2C_TypeDef* I2Cx, uint32_t I2C_FLAG);
    256          
    257          static void I2S_Cmd(SPI_TypeDef* SPIx, FunctionalState NewState);
    258          static void SPI_I2S_DeInit(SPI_TypeDef* SPIx);
    259          static void DMA_Cmd(DMA_Stream_TypeDef* DMAy_Streamx, FunctionalState NewState);
    260          static void DMA_DeInit(DMA_Stream_TypeDef* DMAy_Streamx);
    261          static void SPI_I2S_DMACmd(SPI_TypeDef* SPIx, uint16_t SPI_I2S_DMAReq, FunctionalState NewState);
    262          static void DMA_ClearFlag(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t DMA_FLAG);
    263          
    264          /*----------------------------------------------------------------------------*/
    265          
    266          /*-----------------------------------
    267                             MAL (Media Access Layer) functions 
    268                                              ------------------------------------------*/
    269          /* Peripherals configuration functions */
    270          static void     Audio_MAL_Init(void);
    271          static void     Audio_MAL_DeInit(void);
    272          static void     Audio_MAL_PauseResume(uint32_t Cmd, uint32_t Addr);
    273          static void     Audio_MAL_Stop(void);
    274          /*----------------------------------------------------------------------------*/
    275          
    276          /**
    277            * @brief  Configure the audio peripherals.
    278            * @param  OutputDevice: OUTPUT_DEVICE_SPEAKER, OUTPUT_DEVICE_HEADPHONE,
    279            *                       OUTPUT_DEVICE_BOTH or OUTPUT_DEVICE_AUTO .
    280            * @param  Volume: Initial volume level (from 0 (Mute) to 100 (Max))
    281            * @param  AudioFreq: Audio frequency used to play the audio stream.
    282            * @retval 0 if correct communication, else wrong communication
    283            */

   \                                 In section .text, align 2, keep-with-next
    284          uint32_t AUDIO_Init(uint16_t OutputDevice, uint8_t Volume, uint32_t AudioFreq)
    285          {    
   \                     AUDIO_Init: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    286          	/* Perform low layer Codec initialization */
    287          	if (Codec_Init(OutputDevice, VOLUME_CONVERT(Volume), AudioFreq)!=HAL_OK)
   \   00000008   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000000A   0x2D65             CMP      R5,#+101
   \   0000000C   0xDB01             BLT.N    ??AUDIO_Init_0
   \   0000000E   0x2164             MOVS     R1,#+100
   \   00000010   0xE006             B.N      ??AUDIO_Init_1
   \                     ??AUDIO_Init_0: (+1)
   \   00000012   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000014   0x20FF             MOVS     R0,#+255
   \   00000016   0xFB00 0xF005      MUL      R0,R0,R5
   \   0000001A   0x2164             MOVS     R1,#+100
   \   0000001C   0xFB90 0xF1F1      SDIV     R1,R0,R1
   \                     ??AUDIO_Init_1: (+1)
   \   00000020   0x0032             MOVS     R2,R6
   \   00000022   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000024   0x0020             MOVS     R0,R4
   \   00000026   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000028   0x.... 0x....      BL       Codec_Init
   \   0000002C   0x2800             CMP      R0,#+0
   \   0000002E   0xD002             BEQ.N    ??AUDIO_Init_2
    288          	{
    289                  BSP_LED_Toggle(LED2);
   \   00000030   0x2001             MOVS     R0,#+1
   \   00000032   0x.... 0x....      BL       BSP_LED_Toggle
    290          	}
    291          	
    292          	return 0;
   \                     ??AUDIO_Init_2: (+1)
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0xBD70             POP      {R4-R6,PC}       ;; return
    293          }
    294          
    295          /**
    296            * @brief  Deinitializes all the resources used by the codec (those initialized
    297            *         by AUDIO_Init() function). 
    298            * @param  None
    299            * @retval 0 if correct communication, else wrong communication
    300            */

   \                                 In section .text, align 2, keep-with-next
    301          uint32_t AUDIO_DeInit(void)
    302          { 
   \                     AUDIO_DeInit: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    303            /* DeInitialize the Media layer */
    304            Audio_MAL_DeInit();
   \   00000002   0x.... 0x....      BL       Audio_MAL_DeInit
    305            
    306            /* DeInitialize Codec */  
    307            Codec_DeInit();  
   \   00000006   0x.... 0x....      BL       Codec_DeInit
    308            
    309            return 0;
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0xBD02             POP      {R1,PC}          ;; return
    310          }
    311          
    312          /**
    313            * @brief  Starts playing audio stream from a data buffer for a determined size. 
    314            * @param  pBuffer: Pointer to the buffer 
    315            * @param  Size: Number of audio data BYTES.
    316            * @retval 0 if correct communication, else wrong communication
    317            */

   \                                 In section .text, align 2, keep-with-next
    318          uint32_t AUDIO_Play(uint16_t* pBuffer, uint32_t Size)
    319          {
   \                     AUDIO_Play: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    320            /* Set the total number of data to be played (count in half-word) */
    321            AudioTotalSize = Size;
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable22
   \   0000000A   0x6005             STR      R5,[R0, #+0]
    322          
    323            /* Call the audio Codec Play function */
    324            Codec_Play();
   \   0000000C   0x.... 0x....      BL       Codec_Play
    325            
    326            /* Update the Media layer and enable it for play */  
    327            Audio_MAL_Play(pBuffer, (uint16_t)(DMA_MAX(Size/4)));
   \   00000010   0x08A8             LSRS     R0,R5,#+2
   \   00000012   0xF5B0 0x3F80      CMP      R0,#+65536
   \   00000016   0xD201             BCS.N    ??AUDIO_Play_0
   \   00000018   0x08A9             LSRS     R1,R5,#+2
   \   0000001A   0xE001             B.N      ??AUDIO_Play_1
   \                     ??AUDIO_Play_0: (+1)
   \   0000001C   0xF64F 0x71FF      MOVW     R1,#+65535
   \                     ??AUDIO_Play_1: (+1)
   \   00000020   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000022   0x0020             MOVS     R0,R4
   \   00000024   0x.... 0x....      BL       Audio_MAL_Play
    328            
    329            /* Update the remaining number of data to be played */
    330            AudioRemSize = (Size/2) - DMA_MAX(AudioTotalSize)/2;//1 sop1hc: change "DMA_MAX(AudioTotalSize)" to "DMA_MAX(AudioTotalSize)/2"
   \   00000028   0x.... 0x....      LDR.W    R0,??DataTable22
   \   0000002C   0x6800             LDR      R0,[R0, #+0]
   \   0000002E   0xF5B0 0x3F80      CMP      R0,#+65536
   \   00000032   0xD203             BCS.N    ??AUDIO_Play_2
   \   00000034   0x.... 0x....      LDR.W    R0,??DataTable22
   \   00000038   0x6800             LDR      R0,[R0, #+0]
   \   0000003A   0xE001             B.N      ??AUDIO_Play_3
   \                     ??AUDIO_Play_2: (+1)
   \   0000003C   0xF64F 0x70FF      MOVW     R0,#+65535
   \                     ??AUDIO_Play_3: (+1)
   \   00000040   0x0869             LSRS     R1,R5,#+1
   \   00000042   0xEBB1 0x0050      SUBS     R0,R1,R0, LSR #+1
   \   00000046   0x.... 0x....      LDR.W    R1,??DataTable23
   \   0000004A   0x6008             STR      R0,[R1, #+0]
    331            
    332            /* Update the current audio pointer position */
    333            CurrentPos = pBuffer + DMA_MAX(AudioTotalSize);
   \   0000004C   0x.... 0x....      LDR.W    R0,??DataTable22
   \   00000050   0x6800             LDR      R0,[R0, #+0]
   \   00000052   0xF5B0 0x3F80      CMP      R0,#+65536
   \   00000056   0xD203             BCS.N    ??AUDIO_Play_4
   \   00000058   0x.... 0x....      LDR.W    R0,??DataTable22
   \   0000005C   0x6800             LDR      R0,[R0, #+0]
   \   0000005E   0xE001             B.N      ??AUDIO_Play_5
   \                     ??AUDIO_Play_4: (+1)
   \   00000060   0xF64F 0x70FF      MOVW     R0,#+65535
   \                     ??AUDIO_Play_5: (+1)
   \   00000064   0xEB14 0x0040      ADDS     R0,R4,R0, LSL #+1
   \   00000068   0x.... 0x....      LDR.W    R1,??DataTable23_1
   \   0000006C   0x6008             STR      R0,[R1, #+0]
    334            
    335            return 0;
   \   0000006E   0x2000             MOVS     R0,#+0
   \   00000070   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    336          }
    337          
    338          /**
    339            * @brief  This function Pauses or Resumes the audio file stream. In case
    340            *         of using DMA, the DMA Pause feature is used. In all cases the I2S 
    341            *         peripheral is disabled. 
    342            * 
    343            * @WARNING When calling AUDIO_PauseResume() function for pause, only
    344            *          this function should be called for resume (use of AUDIO_Play() 
    345            *          function for resume could lead to unexpected behavior).
    346            * 
    347            * @param  Cmd: AUDIO_PAUSE (or 0) to pause, AUDIO_RESUME (or any value different
    348            *         from 0) to resume. 
    349            * @retval 0 if correct communication, else wrong communication
    350            */

   \                                 In section .text, align 2, keep-with-next
    351          uint32_t AUDIO_PauseResume(uint32_t Cmd)
    352          {    
   \                     AUDIO_PauseResume: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    353            /* Call the Audio Codec Pause/Resume function */
    354            if (Codec_PauseResume(Cmd) != 0)
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0x.... 0x....      BL       Codec_PauseResume
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD001             BEQ.N    ??AUDIO_PauseResume_0
    355            {
    356              return 1;
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0xE004             B.N      ??AUDIO_PauseResume_1
    357            }
    358            else
    359            {
    360              /* Call the Media layer pause/resume function */
    361              Audio_MAL_PauseResume(Cmd, 0);
   \                     ??AUDIO_PauseResume_0: (+1)
   \   00000012   0x2100             MOVS     R1,#+0
   \   00000014   0x0020             MOVS     R0,R4
   \   00000016   0x.... 0x....      BL       Audio_MAL_PauseResume
    362              
    363              /* Return 0 if all operations are OK */
    364              return 0;
   \   0000001A   0x2000             MOVS     R0,#+0
   \                     ??AUDIO_PauseResume_1: (+1)
   \   0000001C   0xBD10             POP      {R4,PC}          ;; return
    365            }
    366          }
    367          
    368          /**
    369            * @brief  Stops audio playing and Power down the Audio Codec. 
    370            * @param  Option: could be one of the following parameters 
    371            *           - CODEC_PDWN_SW: for software power off (by writing registers). 
    372            *                            Then no need to reconfigure the Codec after power on.
    373            *           - CODEC_PDWN_HW: completely shut down the codec (physically). 
    374            *                            Then need to reconfigure the Codec after power on.  
    375            * @retval 0 if correct communication, else wrong communication
    376            */

   \                                 In section .text, align 2, keep-with-next
    377          uint32_t AUDIO_Stop(uint32_t Option)
    378          {
   \                     AUDIO_Stop: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    379            /* Call Audio Codec Stop function */
    380            if (Codec_Stop(Option) != 0)
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0x.... 0x....      BL       Codec_Stop
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD001             BEQ.N    ??AUDIO_Stop_0
    381            {
    382              return 1;
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0xE008             B.N      ??AUDIO_Stop_1
    383            }
    384            else
    385            {
    386              /* Call Media layer Stop function */
    387              Audio_MAL_Stop();
   \                     ??AUDIO_Stop_0: (+1)
   \   00000012   0x.... 0x....      BL       Audio_MAL_Stop
    388              
    389              /* Update the remaining data number */
    390              AudioRemSize = AudioTotalSize;    
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable22
   \   0000001A   0x6800             LDR      R0,[R0, #+0]
   \   0000001C   0x.... 0x....      LDR.W    R1,??DataTable23
   \   00000020   0x6008             STR      R0,[R1, #+0]
    391              
    392              /* Return 0 when all operations are correctly done */
    393              return 0;
   \   00000022   0x2000             MOVS     R0,#+0
   \                     ??AUDIO_Stop_1: (+1)
   \   00000024   0xBD10             POP      {R4,PC}          ;; return
    394            }
    395          }
    396          
    397          /**
    398            * @brief  Controls the current audio volume level. 
    399            * @param  Volume: Volume level to be set in percentage from 0% to 100% (0 for 
    400            *         Mute and 100 for Max volume level).
    401            * @retval 0 if correct communication, else wrong communication
    402            */

   \                                 In section .text, align 2, keep-with-next
    403          uint32_t AUDIO_VolumeCtl(uint8_t Volume)
    404          {
   \                     AUDIO_VolumeCtl: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    405            /* Call the codec volume control function with converted volume value */
    406            return (Codec_VolumeCtrl(VOLUME_CONVERT(Volume)));
   \   00000004   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000006   0x2C65             CMP      R4,#+101
   \   00000008   0xDB01             BLT.N    ??AUDIO_VolumeCtl_0
   \   0000000A   0x2064             MOVS     R0,#+100
   \   0000000C   0xE006             B.N      ??AUDIO_VolumeCtl_1
   \                     ??AUDIO_VolumeCtl_0: (+1)
   \   0000000E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000010   0x20FF             MOVS     R0,#+255
   \   00000012   0xFB00 0xF004      MUL      R0,R0,R4
   \   00000016   0x2164             MOVS     R1,#+100
   \   00000018   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \                     ??AUDIO_VolumeCtl_1: (+1)
   \   0000001C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001E   0x.... 0x....      BL       Codec_VolumeCtrl
   \   00000022   0xBD10             POP      {R4,PC}          ;; return
    407          }
    408          
    409          /**
    410            * @brief  Enables or disables the MUTE mode by software 
    411            * @param  Command: could be AUDIO_MUTE_ON to mute sound or AUDIO_MUTE_OFF to 
    412            *         unmute the codec and restore previous volume level.
    413            * @retval 0 if correct communication, else wrong communication
    414            */

   \                                 In section .text, align 2, keep-with-next
    415          uint32_t AUDIO_Mute(uint32_t Cmd)
    416          { 
   \                     AUDIO_Mute: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    417            /* Call the Codec Mute function */
    418            return (Codec_Mute(Cmd));
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0x.... 0x....      BL       Codec_Mute
   \   0000000A   0xBD10             POP      {R4,PC}          ;; return
    419          }
    420          
    421          /**
    422            * @brief  This function handles main Media layer interrupt. 
    423            * @param  None
    424            * @retval 0 if correct communication, else wrong communication
    425            */

   \                                 In section .text, align 2, keep-with-next
    426          static void Audio_MAL_IRQHandler(void)
    427          {    
   \                     Audio_MAL_IRQHandler: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    428            uint16_t *pAddr = (uint16_t *)CurrentPos;
                             ^
Warning[Pe177]: variable "pAddr" was declared but never referenced
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable23_1
   \   00000006   0x6804             LDR      R4,[R0, #+0]
    429            uint32_t Size = AudioRemSize;
                            ^
Warning[Pe177]: variable "Size" was declared but never referenced
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable23
   \   0000000C   0x6805             LDR      R5,[R0, #+0]
    430            
    431          #ifdef AUDIO_MAL_DMA_IT_TC_EN
    432            /* Transfer complete interrupt */
    433            if (__HAL_DMA_GET_FLAG(&DmaHandle,AUDIO_I2S_DMA_FLAG_TC)!=RESET)
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable23_2
   \   00000012   0x6800             LDR      R0,[R0, #+0]
   \   00000014   0x.... 0x....      LDR.W    R1,??DataTable23_3  ;; 0x40026459
   \   00000018   0x4288             CMP      R0,R1
   \   0000001A   0xD305             BCC.N    ??Audio_MAL_IRQHandler_0
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable23_4  ;; 0x40026404
   \   00000020   0x6800             LDR      R0,[R0, #+0]
   \   00000022   0xF010 0x6000      ANDS     R0,R0,#0x8000000
   \   00000026   0xE01E             B.N      ??Audio_MAL_IRQHandler_1
   \                     ??Audio_MAL_IRQHandler_0: (+1)
   \   00000028   0x.... 0x....      LDR.W    R0,??DataTable23_2
   \   0000002C   0x6800             LDR      R0,[R0, #+0]
   \   0000002E   0x.... 0x....      LDR.W    R1,??DataTable23_5  ;; 0x400260b9
   \   00000032   0x4288             CMP      R0,R1
   \   00000034   0xD305             BCC.N    ??Audio_MAL_IRQHandler_2
   \   00000036   0x.... 0x....      LDR.W    R0,??DataTable23_6  ;; 0x40026400
   \   0000003A   0x6800             LDR      R0,[R0, #+0]
   \   0000003C   0xF010 0x6000      ANDS     R0,R0,#0x8000000
   \   00000040   0xE011             B.N      ??Audio_MAL_IRQHandler_1
   \                     ??Audio_MAL_IRQHandler_2: (+1)
   \   00000042   0x.... 0x....      LDR.W    R0,??DataTable23_2
   \   00000046   0x6800             LDR      R0,[R0, #+0]
   \   00000048   0x.... 0x....      LDR.W    R1,??DataTable23_7  ;; 0x40026059
   \   0000004C   0x4288             CMP      R0,R1
   \   0000004E   0xD305             BCC.N    ??Audio_MAL_IRQHandler_3
   \   00000050   0x.... 0x....      LDR.W    R0,??DataTable23_8  ;; 0x40026004
   \   00000054   0x6800             LDR      R0,[R0, #+0]
   \   00000056   0xF010 0x6000      ANDS     R0,R0,#0x8000000
   \   0000005A   0xE004             B.N      ??Audio_MAL_IRQHandler_1
   \                     ??Audio_MAL_IRQHandler_3: (+1)
   \   0000005C   0x.... 0x....      LDR.W    R0,??DataTable23_9  ;; 0x40026000
   \   00000060   0x6800             LDR      R0,[R0, #+0]
   \   00000062   0xF010 0x6000      ANDS     R0,R0,#0x8000000
   \                     ??Audio_MAL_IRQHandler_1: (+1)
   \   00000066   0x2800             CMP      R0,#+0
   \   00000068   0xF000 0x80C5      BEQ.W    ??Audio_MAL_IRQHandler_4
    434            {         
    435              /* Check if the end of file has been reached */
    436              if (AudioRemSize > 0)
   \   0000006C   0x.... 0x....      LDR.W    R0,??DataTable23
   \   00000070   0x6800             LDR      R0,[R0, #+0]
   \   00000072   0x2800             CMP      R0,#+0
   \   00000074   0xF000 0x8083      BEQ.W    ??Audio_MAL_IRQHandler_5
    437              {      
    438                /* Wait the DMA Stream to be effectively disabled */
    439                //while (HAL_DMA_GetState(&DmaHandle) != DISABLE)
    440                //{}
    441                
    442                /* Clear the Interrupt flag */
    443                __HAL_DMA_CLEAR_FLAG(&DmaHandle, AUDIO_I2S_DMA_FLAG_TC);
   \   00000078   0x.... 0x....      LDR.W    R0,??DataTable23_2
   \   0000007C   0x6800             LDR      R0,[R0, #+0]
   \   0000007E   0x.... 0x....      LDR.W    R1,??DataTable23_3  ;; 0x40026459
   \   00000082   0x4288             CMP      R0,R1
   \   00000084   0xD305             BCC.N    ??Audio_MAL_IRQHandler_6
   \   00000086   0xF05F 0x6000      MOVS     R0,#+134217728
   \   0000008A   0x.... 0x....      LDR.W    R1,??DataTable23_10  ;; 0x4002640c
   \   0000008E   0x6008             STR      R0,[R1, #+0]
   \   00000090   0xE01E             B.N      ??Audio_MAL_IRQHandler_7
   \                     ??Audio_MAL_IRQHandler_6: (+1)
   \   00000092   0x.... 0x....      LDR.W    R0,??DataTable23_2
   \   00000096   0x6800             LDR      R0,[R0, #+0]
   \   00000098   0x.... 0x....      LDR.W    R1,??DataTable23_5  ;; 0x400260b9
   \   0000009C   0x4288             CMP      R0,R1
   \   0000009E   0xD305             BCC.N    ??Audio_MAL_IRQHandler_8
   \   000000A0   0xF05F 0x6000      MOVS     R0,#+134217728
   \   000000A4   0x.... 0x....      LDR.W    R1,??DataTable23_11  ;; 0x40026408
   \   000000A8   0x6008             STR      R0,[R1, #+0]
   \   000000AA   0xE011             B.N      ??Audio_MAL_IRQHandler_7
   \                     ??Audio_MAL_IRQHandler_8: (+1)
   \   000000AC   0x.... 0x....      LDR.W    R0,??DataTable23_2
   \   000000B0   0x6800             LDR      R0,[R0, #+0]
   \   000000B2   0x.... 0x....      LDR.W    R1,??DataTable23_7  ;; 0x40026059
   \   000000B6   0x4288             CMP      R0,R1
   \   000000B8   0xD305             BCC.N    ??Audio_MAL_IRQHandler_9
   \   000000BA   0xF05F 0x6000      MOVS     R0,#+134217728
   \   000000BE   0x.... 0x....      LDR.W    R1,??DataTable23_12  ;; 0x4002600c
   \   000000C2   0x6008             STR      R0,[R1, #+0]
   \   000000C4   0xE004             B.N      ??Audio_MAL_IRQHandler_7
   \                     ??Audio_MAL_IRQHandler_9: (+1)
   \   000000C6   0xF05F 0x6000      MOVS     R0,#+134217728
   \   000000CA   0x.... 0x....      LDR.W    R1,??DataTable23_13  ;; 0x40026008
   \   000000CE   0x6008             STR      R0,[R1, #+0]
    444                    
    445                /* Re-Configure the buffer address and size */
    446                 DmaHandle.Instance->M0AR = (uint32_t) CurrentPos;
   \                     ??Audio_MAL_IRQHandler_7: (+1)
   \   000000D0   0x.... 0x....      LDR.W    R0,??DataTable23_1
   \   000000D4   0x6800             LDR      R0,[R0, #+0]
   \   000000D6   0x.... 0x....      LDR.W    R1,??DataTable23_2
   \   000000DA   0x6809             LDR      R1,[R1, #+0]
   \   000000DC   0x60C8             STR      R0,[R1, #+12]
    447                 DmaHandle.Instance->NDTR = (uint32_t) (DMA_MAX(AudioRemSize));    
   \   000000DE   0x.... 0x....      LDR.W    R0,??DataTable23
   \   000000E2   0x6800             LDR      R0,[R0, #+0]
   \   000000E4   0xF5B0 0x3F80      CMP      R0,#+65536
   \   000000E8   0xD203             BCS.N    ??Audio_MAL_IRQHandler_10
   \   000000EA   0x.... 0x....      LDR.W    R0,??DataTable23
   \   000000EE   0x6800             LDR      R0,[R0, #+0]
   \   000000F0   0xE001             B.N      ??Audio_MAL_IRQHandler_11
   \                     ??Audio_MAL_IRQHandler_10: (+1)
   \   000000F2   0xF64F 0x70FF      MOVW     R0,#+65535
   \                     ??Audio_MAL_IRQHandler_11: (+1)
   \   000000F6   0x.... 0x....      LDR.W    R1,??DataTable23_2
   \   000000FA   0x6809             LDR      R1,[R1, #+0]
   \   000000FC   0x6048             STR      R0,[R1, #+4]
    448                /* Configure the DMA Stream with the new parameters */
    449                HAL_DMA_Init(&DmaHandle);
   \   000000FE   0x.... 0x....      LDR.W    R0,??DataTable23_2
   \   00000102   0x.... 0x....      BL       HAL_DMA_Init
    450                
    451                /* Enable the I2S DMA Stream*/
    452          	  __HAL_DMA_ENABLE(&DmaHandle);
   \   00000106   0x.... 0x....      LDR.W    R0,??DataTable23_2
   \   0000010A   0x6800             LDR      R0,[R0, #+0]
   \   0000010C   0x6800             LDR      R0,[R0, #+0]
   \   0000010E   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000112   0x.... 0x....      LDR.W    R1,??DataTable23_2
   \   00000116   0x6809             LDR      R1,[R1, #+0]
   \   00000118   0x6008             STR      R0,[R1, #+0]
    453                
    454                /* Update the current pointer position */
    455                CurrentPos += DMA_MAX(AudioRemSize);        
   \   0000011A   0x.... 0x....      LDR.W    R0,??DataTable23
   \   0000011E   0x6800             LDR      R0,[R0, #+0]
   \   00000120   0xF5B0 0x3F80      CMP      R0,#+65536
   \   00000124   0xD203             BCS.N    ??Audio_MAL_IRQHandler_12
   \   00000126   0x.... 0x....      LDR.W    R0,??DataTable23
   \   0000012A   0x6800             LDR      R0,[R0, #+0]
   \   0000012C   0xE001             B.N      ??Audio_MAL_IRQHandler_13
   \                     ??Audio_MAL_IRQHandler_12: (+1)
   \   0000012E   0xF64F 0x70FF      MOVW     R0,#+65535
   \                     ??Audio_MAL_IRQHandler_13: (+1)
   \   00000132   0x.... 0x....      LDR.W    R1,??DataTable23_1
   \   00000136   0x6809             LDR      R1,[R1, #+0]
   \   00000138   0xEB11 0x0040      ADDS     R0,R1,R0, LSL #+1
   \   0000013C   0x.... 0x....      LDR.W    R1,??DataTable23_1
   \   00000140   0x6008             STR      R0,[R1, #+0]
    456                
    457                /* Update the remaining number of data to be played */
    458                AudioRemSize -= DMA_MAX(AudioRemSize);   
   \   00000142   0x.... 0x....      LDR.W    R0,??DataTable23
   \   00000146   0x6800             LDR      R0,[R0, #+0]
   \   00000148   0xF5B0 0x3F80      CMP      R0,#+65536
   \   0000014C   0xD203             BCS.N    ??Audio_MAL_IRQHandler_14
   \   0000014E   0x.... 0x....      LDR.W    R0,??DataTable23
   \   00000152   0x6800             LDR      R0,[R0, #+0]
   \   00000154   0xE001             B.N      ??Audio_MAL_IRQHandler_15
   \                     ??Audio_MAL_IRQHandler_14: (+1)
   \   00000156   0xF64F 0x70FF      MOVW     R0,#+65535
   \                     ??Audio_MAL_IRQHandler_15: (+1)
   \   0000015A   0x.... 0x....      LDR.W    R1,??DataTable23
   \   0000015E   0x6809             LDR      R1,[R1, #+0]
   \   00000160   0x1A08             SUBS     R0,R1,R0
   \   00000162   0x.... 0x....      LDR.W    R1,??DataTable23
   \   00000166   0x6008             STR      R0,[R1, #+0]
    459          
    460          	  /* Enable the I2S DMA Stream*/
    461                __HAL_DMA_ENABLE(&DmaHandle);
   \   00000168   0x.... 0x....      LDR.W    R0,??DataTable23_2
   \   0000016C   0x6800             LDR      R0,[R0, #+0]
   \   0000016E   0x6800             LDR      R0,[R0, #+0]
   \   00000170   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000174   0x.... 0x....      LDR.W    R1,??DataTable23_2
   \   00000178   0x6809             LDR      R1,[R1, #+0]
   \   0000017A   0x6008             STR      R0,[R1, #+0]
   \   0000017C   0xE03B             B.N      ??Audio_MAL_IRQHandler_4
    462              }
    463              else
    464              {
    465                /* Disable the I2S DMA Stream*/
    466                __HAL_DMA_DISABLE(&DmaHandle);   
   \                     ??Audio_MAL_IRQHandler_5: (+1)
   \   0000017E   0x.... 0x....      LDR.W    R0,??DataTable23_2
   \   00000182   0x6800             LDR      R0,[R0, #+0]
   \   00000184   0x6800             LDR      R0,[R0, #+0]
   \   00000186   0x0840             LSRS     R0,R0,#+1
   \   00000188   0x0040             LSLS     R0,R0,#+1
   \   0000018A   0x.... 0x....      LDR.W    R1,??DataTable23_2
   \   0000018E   0x6809             LDR      R1,[R1, #+0]
   \   00000190   0x6008             STR      R0,[R1, #+0]
    467                
    468                /* Clear the Interrupt flag */
    469                 __HAL_DMA_CLEAR_FLAG(&DmaHandle, AUDIO_I2S_DMA_FLAG_TC);       
   \   00000192   0x.... 0x....      LDR.W    R0,??DataTable23_2
   \   00000196   0x6800             LDR      R0,[R0, #+0]
   \   00000198   0x.... 0x....      LDR.W    R1,??DataTable23_3  ;; 0x40026459
   \   0000019C   0x4288             CMP      R0,R1
   \   0000019E   0xD305             BCC.N    ??Audio_MAL_IRQHandler_16
   \   000001A0   0xF05F 0x6000      MOVS     R0,#+134217728
   \   000001A4   0x.... 0x....      LDR.W    R1,??DataTable23_10  ;; 0x4002640c
   \   000001A8   0x6008             STR      R0,[R1, #+0]
   \   000001AA   0xE01E             B.N      ??Audio_MAL_IRQHandler_17
   \                     ??Audio_MAL_IRQHandler_16: (+1)
   \   000001AC   0x.... 0x....      LDR.W    R0,??DataTable23_2
   \   000001B0   0x6800             LDR      R0,[R0, #+0]
   \   000001B2   0x.... 0x....      LDR.W    R1,??DataTable23_5  ;; 0x400260b9
   \   000001B6   0x4288             CMP      R0,R1
   \   000001B8   0xD305             BCC.N    ??Audio_MAL_IRQHandler_18
   \   000001BA   0xF05F 0x6000      MOVS     R0,#+134217728
   \   000001BE   0x.... 0x....      LDR.W    R1,??DataTable23_11  ;; 0x40026408
   \   000001C2   0x6008             STR      R0,[R1, #+0]
   \   000001C4   0xE011             B.N      ??Audio_MAL_IRQHandler_17
   \                     ??Audio_MAL_IRQHandler_18: (+1)
   \   000001C6   0x.... 0x....      LDR.W    R0,??DataTable23_2
   \   000001CA   0x6800             LDR      R0,[R0, #+0]
   \   000001CC   0x.... 0x....      LDR.W    R1,??DataTable23_7  ;; 0x40026059
   \   000001D0   0x4288             CMP      R0,R1
   \   000001D2   0xD305             BCC.N    ??Audio_MAL_IRQHandler_19
   \   000001D4   0xF05F 0x6000      MOVS     R0,#+134217728
   \   000001D8   0x.... 0x....      LDR.W    R1,??DataTable23_12  ;; 0x4002600c
   \   000001DC   0x6008             STR      R0,[R1, #+0]
   \   000001DE   0xE004             B.N      ??Audio_MAL_IRQHandler_17
   \                     ??Audio_MAL_IRQHandler_19: (+1)
   \   000001E0   0xF05F 0x6000      MOVS     R0,#+134217728
   \   000001E4   0x.... 0x....      LDR.W    R1,??DataTable23_13  ;; 0x40026008
   \   000001E8   0x6008             STR      R0,[R1, #+0]
    470                
    471                /* Manage the remaining file size and new address offset: This function 
    472                should be coded by user (its prototype is already declared in stm32f4_discovery_audio_codec.h) */  
    473                AUDIO_TransferComplete_CallBack((uint32_t)CurrentPos, 0);       
   \                     ??Audio_MAL_IRQHandler_17: (+1)
   \   000001EA   0x2100             MOVS     R1,#+0
   \   000001EC   0x.... 0x....      LDR.W    R0,??DataTable23_1
   \   000001F0   0x6800             LDR      R0,[R0, #+0]
   \   000001F2   0x.... 0x....      BL       AUDIO_TransferComplete_CallBack
    474              }
    475              
    476           
    477            }
    478          #endif /* AUDIO_MAL_DMA_IT_TC_EN */
    479          
    480          #ifdef AUDIO_MAL_DMA_IT_HT_EN  
    481            /* Half Transfer complete interrupt */
    482            //if (DMA_GetFlagStatus(AUDIO_I2S_DMA_STREAM, AUDIO_I2S_DMA_FLAG_HT) != RESET)
    483            if (__HAL_DMA_GET_FLAG(&DmaHandle, AUDIO_I2S_DMA_FLAG_HT) != RESET)
    484            {
    485              /* Manage the remaining file size and new address offset: This function 
    486                 should be coded by user (its prototype is already declared in stm32f4_discovery_audio_codec.h) */  
    487              AUDIO_HalfTransfer_CallBack((uint32_t)pAddr, Size);    
    488             
    489              /* Clear the Interrupt flag */
    490          	__HAL_DMA_CLEAR_FLAG(&DmaHandle, AUDIO_I2S_DMA_FLAG_HT); 
    491          
    492            }
    493          #endif /* AUDIO_MAL_DMA_IT_HT_EN */
    494            
    495          #ifdef AUDIO_MAL_DMA_IT_TE_EN  
    496            /* FIFO Error interrupt */
    497            if ((__HAL_DMA_GET_FLAG(&DmaHandle, AUDIO_I2S_DMA_FLAG_TE) != RESET) || \
    498               (__HAL_DMA_GET_FLAG(&DmaHandle, AUDIO_I2S_DMA_FLAG_FE) != RESET) || \
    499               (__HAL_DMA_GET_FLAG(&DmaHandle, AUDIO_I2S_DMA_FLAG_DME) != RESET))
    500              
    501            {
    502              /* Manage the error generated on DMA FIFO: This function 
    503                 should be coded by user (its prototype is already declared in stm32f4_discovery_audio_codec.h) */  
    504              AUDIO_Error_CallBack((uint32_t*)&pAddr);    
    505              
    506              /* Clear the Interrupt flag */
    507              __HAL_DMA_CLEAR_FLAG(&DmaHandle, AUDIO_I2S_DMA_FLAG_TE | AUDIO_I2S_DMA_FLAG_FE | \
    508                                                  AUDIO_I2S_DMA_FLAG_DME);
    509            }  
    510          #endif /* AUDIO_MAL_DMA_IT_TE_EN */
    511          }
   \                     ??Audio_MAL_IRQHandler_4: (+1)
   \   000001F6   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    512          
    513          /**
    514            * @brief  This function handles main I2S interrupt. 
    515            * @param  None
    516            * @retval 0 if correct communication, else wrong communication
    517            */

   \                                 In section .text, align 2, keep-with-next
    518          void DMA1_Stream7_IRQHandler(void)
    519          { 
   \                     DMA1_Stream7_IRQHandler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    520              //Audio_MAL_IRQHandler();
    521          	HAL_DMA_IRQHandler(hi2s3.hdmatx);
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable23_14
   \   00000006   0x6B00             LDR      R0,[R0, #+48]
   \   00000008   0x.... 0x....      BL       HAL_DMA_IRQHandler
    522          }
   \   0000000C   0xBD01             POP      {R0,PC}          ;; return
    523          
    524          /**
    525            * @brief  This function handles main DAC interrupt. 
    526            * @param  None
    527             * @retval None
    528            */

   \                                 In section .text, align 2, keep-with-next
    529          void DMA1_Stream0_IRQHandler(void)
    530          { 
   \                     DMA1_Stream0_IRQHandler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    531            Audio_MAL_IRQHandler();
   \   00000002   0x.... 0x....      BL       Audio_MAL_IRQHandler
    532          }
   \   00000006   0xBD01             POP      {R0,PC}          ;; return
    533          
    534          /**
    535            * @brief  I2S interrupt management
    536            * @param  None
    537            * @retval None
    538            */

   \                                 In section .text, align 2, keep-with-next
    539          void SPI3_IRQHandler(void)
    540          {
   \                     SPI3_IRQHandler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    541            /* Check on the I2S TXE flag */  
    542            if (__HAL_SPI_GET_FLAG(&hi2s3, SPI_IT_TXE) != RESET)
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable23_14
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0x6880             LDR      R0,[R0, #+8]
   \   0000000A   0x0600             LSLS     R0,R0,#+24
   \   0000000C   0xD507             BPL.N    ??SPI3_IRQHandler_0
    543            { 
    544             
    545              /* Send dummy data on I2S to avoid the underrun condition */
    546               SPI_I2S_SendData(CODEC_I2S, AUDIO_GetSampleCallBack()); 
   \   0000000E   0x.... 0x....      BL       AUDIO_GetSampleCallBack
   \   00000012   0x0001             MOVS     R1,R0
   \   00000014   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable23_15  ;; 0x40003c00
   \   0000001A   0x.... 0x....      BL       SPI_I2S_SendData
    547            }
    548          }
   \                     ??SPI3_IRQHandler_0: (+1)
   \   0000001E   0xBD01             POP      {R0,PC}          ;; return
    549          /*========================
    550                          CS43L22 Audio Codec Control Functions
    551                                                          ==============================*/
    552          /**
    553            * @brief  Initializes the audio codec and all related interfaces (control 
    554            *         interface: I2C and audio interface: I2S)
    555            * @param  OutputDevice: can be OUTPUT_DEVICE_SPEAKER, OUTPUT_DEVICE_HEADPHONE,
    556            *                       OUTPUT_DEVICE_BOTH or OUTPUT_DEVICE_AUTO .
    557            * @param  Volume: Initial volume level (from 0 (Mute) to 100 (Max))
    558            * @param  AudioFreq: Audio frequency used to play the audio stream.
    559            * @retval 0 if correct communication, else wrong communication
    560            */

   \                                 In section .text, align 2, keep-with-next
    561          static uint32_t Codec_Init(uint16_t OutputDevice, uint8_t Volume, uint32_t AudioFreq)
    562          {
   \                     Codec_Init: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    563            uint32_t counter = 0; 
   \   00000008   0x2700             MOVS     R7,#+0
    564          
    565            /* Configure the Codec related IOs */
    566            Codec_GPIO_Init();   
   \   0000000A   0x.... 0x....      BL       Codec_GPIO_Init
    567            
    568            /* Reset the Codec Registers */
    569            Codec_Reset();
   \   0000000E   0x.... 0x....      BL       Codec_Reset
    570          
    571            /* Initialize the Control interface of the Audio Codec */
    572            Codec_CtrlInterface_Init();     
   \   00000012   0x.... 0x....      BL       Codec_CtrlInterface_Init
    573            
    574            /* Keep Codec powered OFF */
    575            counter += Codec_WriteRegister(0x02, 0x01);  
   \   00000016   0x2101             MOVS     R1,#+1
   \   00000018   0x2002             MOVS     R0,#+2
   \   0000001A   0x.... 0x....      BL       Codec_WriteRegister
   \   0000001E   0x19C0             ADDS     R0,R0,R7
   \   00000020   0x0007             MOVS     R7,R0
    576                
    577            counter += Codec_WriteRegister(0x04, 0xAF); /* SPK always OFF & HP always ON */
   \   00000022   0x21AF             MOVS     R1,#+175
   \   00000024   0x2004             MOVS     R0,#+4
   \   00000026   0x.... 0x....      BL       Codec_WriteRegister
   \   0000002A   0x19C0             ADDS     R0,R0,R7
   \   0000002C   0x0007             MOVS     R7,R0
    578            OutputDev = 0xAF;
   \   0000002E   0x20AF             MOVS     R0,#+175
   \   00000030   0x.... 0x....      LDR.W    R1,??DataTable23_16
   \   00000034   0x7008             STRB     R0,[R1, #+0]
    579            
    580            /* Clock configuration: Auto detection */  
    581            counter += Codec_WriteRegister(0x05, 0x81);
   \   00000036   0x2181             MOVS     R1,#+129
   \   00000038   0x2005             MOVS     R0,#+5
   \   0000003A   0x.... 0x....      BL       Codec_WriteRegister
   \   0000003E   0x19C0             ADDS     R0,R0,R7
   \   00000040   0x0007             MOVS     R7,R0
    582            
    583            /* Set the Slave Mode and the audio Standard */  
    584            counter += Codec_WriteRegister(0x06, CODEC_STANDARD);
   \   00000042   0x2104             MOVS     R1,#+4
   \   00000044   0x2006             MOVS     R0,#+6
   \   00000046   0x.... 0x....      BL       Codec_WriteRegister
   \   0000004A   0x19C0             ADDS     R0,R0,R7
   \   0000004C   0x0007             MOVS     R7,R0
    585                
    586            /* Set the Master volume */
    587            Codec_VolumeCtrl(Volume);
   \   0000004E   0x0028             MOVS     R0,R5
   \   00000050   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000052   0x.... 0x....      BL       Codec_VolumeCtrl
    588            
    589          
    590            /* Power on the Codec */
    591            counter += Codec_WriteRegister(0x02, 0x9E);  
   \   00000056   0x219E             MOVS     R1,#+158
   \   00000058   0x2002             MOVS     R0,#+2
   \   0000005A   0x.... 0x....      BL       Codec_WriteRegister
   \   0000005E   0x19C0             ADDS     R0,R0,R7
   \   00000060   0x0007             MOVS     R7,R0
    592            
    593            /* Additional configuration for the CODEC. These configurations are done to reduce
    594                the time needed for the Codec to power off. If these configurations are removed, 
    595                then a long delay should be added between powering off the Codec and switching 
    596                off the I2S peripheral MCLK clock (which is the operating clock for Codec).
    597                If this delay is not inserted, then the codec will not shut down properly and
    598                it results in high noise after shut down. */
    599            
    600            /* Disable the analog soft ramp */
    601            counter += Codec_WriteRegister(0x0A, 0x00);
   \   00000062   0x2100             MOVS     R1,#+0
   \   00000064   0x200A             MOVS     R0,#+10
   \   00000066   0x.... 0x....      BL       Codec_WriteRegister
   \   0000006A   0x19C0             ADDS     R0,R0,R7
   \   0000006C   0x0007             MOVS     R7,R0
    602          
    603          	/* Disable the digital soft ramp */
    604          	counter += Codec_WriteRegister(0x0E, 0x04);
   \   0000006E   0x2104             MOVS     R1,#+4
   \   00000070   0x200E             MOVS     R0,#+14
   \   00000072   0x.... 0x....      BL       Codec_WriteRegister
   \   00000076   0x19C0             ADDS     R0,R0,R7
   \   00000078   0x0007             MOVS     R7,R0
    605          
    606            /* Disable the limiter attack level */
    607            counter += Codec_WriteRegister(0x27, 0x00);
   \   0000007A   0x2100             MOVS     R1,#+0
   \   0000007C   0x2027             MOVS     R0,#+39
   \   0000007E   0x.... 0x....      BL       Codec_WriteRegister
   \   00000082   0x19C0             ADDS     R0,R0,R7
   \   00000084   0x0007             MOVS     R7,R0
    608            /* Adjust Bass and Treble levels */
    609            counter += Codec_WriteRegister(0x1F, 0x0F);
   \   00000086   0x210F             MOVS     R1,#+15
   \   00000088   0x201F             MOVS     R0,#+31
   \   0000008A   0x.... 0x....      BL       Codec_WriteRegister
   \   0000008E   0x19C0             ADDS     R0,R0,R7
   \   00000090   0x0007             MOVS     R7,R0
    610            /* Adjust PCM volume level */
    611            counter += Codec_WriteRegister(0x1A, 0x0A);
   \   00000092   0x210A             MOVS     R1,#+10
   \   00000094   0x201A             MOVS     R0,#+26
   \   00000096   0x.... 0x....      BL       Codec_WriteRegister
   \   0000009A   0x19C0             ADDS     R0,R0,R7
   \   0000009C   0x0007             MOVS     R7,R0
    612            counter += Codec_WriteRegister(0x1B, 0x0A);
   \   0000009E   0x210A             MOVS     R1,#+10
   \   000000A0   0x201B             MOVS     R0,#+27
   \   000000A2   0x.... 0x....      BL       Codec_WriteRegister
   \   000000A6   0x19C0             ADDS     R0,R0,R7
   \   000000A8   0x0007             MOVS     R7,R0
    613          
    614            /* Configure the I2S peripheral */
    615            Codec_AudioInterface_Init(AudioFreq);  
   \   000000AA   0x0030             MOVS     R0,R6
   \   000000AC   0x.... 0x....      BL       Codec_AudioInterface_Init
    616            
    617            /* Return communication control value */
    618            return counter;  
   \   000000B0   0x0038             MOVS     R0,R7
   \   000000B2   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    619          }
    620          
    621          /**
    622            * @brief  Restore the audio codec state to default state and free all used 
    623            *         resources.
    624            * @param  None
    625            * @retval 0 if correct communication, else wrong communication
    626            */

   \                                 In section .text, align 2, keep-with-next
    627          static uint32_t Codec_DeInit(void)
    628          {
   \                     Codec_DeInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    629            uint32_t counter = 0; 
   \   00000002   0x2400             MOVS     R4,#+0
    630          
    631            /* Reset the Codec Registers */
    632            Codec_Reset();  
   \   00000004   0x.... 0x....      BL       Codec_Reset
    633            
    634            /* Keep Codec powered OFF */
    635            counter += Codec_WriteRegister(0x02, 0x01);    
   \   00000008   0x2101             MOVS     R1,#+1
   \   0000000A   0x2002             MOVS     R0,#+2
   \   0000000C   0x.... 0x....      BL       Codec_WriteRegister
   \   00000010   0x1900             ADDS     R0,R0,R4
   \   00000012   0x0004             MOVS     R4,R0
    636            
    637            /* Deinitialize all use GPIOs */
    638            Codec_GPIO_DeInit();
   \   00000014   0x.... 0x....      BL       Codec_GPIO_DeInit
    639          
    640            /* Disable the Codec control interface */
    641            Codec_CtrlInterface_DeInit();
   \   00000018   0x.... 0x....      BL       Codec_CtrlInterface_DeInit
    642            
    643            /* Deinitialize the Codec audio interface (I2S) */
    644            Codec_AudioInterface_DeInit(); 
   \   0000001C   0x.... 0x....      BL       Codec_AudioInterface_DeInit
    645            
    646            /* Return communication control value */
    647            return counter;  
   \   00000020   0x0020             MOVS     R0,R4
   \   00000022   0xBD10             POP      {R4,PC}          ;; return
    648          }
    649          
    650          /**
    651            * @brief  Start the audio Codec play feature.
    652            * @note   For this codec no Play options are required.
    653            * @param  None
    654            * @retval 0 if correct communication, else wrong communication
    655            */

   \                                 In section .text, align 2, keep-with-next
    656          static uint32_t Codec_Play(void)
    657          {
    658            /* 
    659               No actions required on Codec level for play command
    660               */  
    661          
    662            /* Return communication control value */
    663            return 0;  
   \                     Codec_Play: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x4770             BX       LR               ;; return
    664          }
    665          
    666          /**
    667            * @brief  Pauses and resumes playing on the audio codec.
    668            * @param  Cmd: AUDIO_PAUSE (or 0) to pause, AUDIO_RESUME (or any value different
    669            *         from 0) to resume. 
    670            * @retval 0 if correct communication, else wrong communication
    671            */

   \                                 In section .text, align 2, keep-with-next
    672          static uint32_t Codec_PauseResume(uint32_t Cmd)
    673          {
   \                     Codec_PauseResume: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    674            uint32_t counter = 0;   
   \   00000004   0x2500             MOVS     R5,#+0
    675            
    676            /* Pause the audio file playing */
    677            if (Cmd == AUDIO_PAUSE)
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD10B             BNE.N    ??Codec_PauseResume_0
    678            { 
    679              /* Mute the output first */
    680              counter += Codec_Mute(AUDIO_MUTE_ON);
   \   0000000A   0x2001             MOVS     R0,#+1
   \   0000000C   0x.... 0x....      BL       Codec_Mute
   \   00000010   0x1940             ADDS     R0,R0,R5
   \   00000012   0x0005             MOVS     R5,R0
    681          
    682              /* Put the Codec in Power save mode */    
    683              counter += Codec_WriteRegister(0x02, 0x01);    
   \   00000014   0x2101             MOVS     R1,#+1
   \   00000016   0x2002             MOVS     R0,#+2
   \   00000018   0x.... 0x....      BL       Codec_WriteRegister
   \   0000001C   0x1940             ADDS     R0,R0,R5
   \   0000001E   0x0005             MOVS     R5,R0
   \   00000020   0xE012             B.N      ??Codec_PauseResume_1
    684            }
    685            else /* AUDIO_RESUME */
    686            {
    687              /* Unmute the output first */
    688              counter += Codec_Mute(AUDIO_MUTE_OFF);
   \                     ??Codec_PauseResume_0: (+1)
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0x.... 0x....      BL       Codec_Mute
   \   00000028   0x1940             ADDS     R0,R0,R5
   \   0000002A   0x0005             MOVS     R5,R0
    689              
    690              counter += Codec_WriteRegister(0x04, OutputDev);
   \   0000002C   0x.... 0x....      LDR.W    R0,??DataTable23_16
   \   00000030   0x7801             LDRB     R1,[R0, #+0]
   \   00000032   0x2004             MOVS     R0,#+4
   \   00000034   0x.... 0x....      BL       Codec_WriteRegister
   \   00000038   0x1940             ADDS     R0,R0,R5
   \   0000003A   0x0005             MOVS     R5,R0
    691              
    692              /* Exit the Power save mode */
    693              counter += Codec_WriteRegister(0x02, 0x9E); 
   \   0000003C   0x219E             MOVS     R1,#+158
   \   0000003E   0x2002             MOVS     R0,#+2
   \   00000040   0x.... 0x....      BL       Codec_WriteRegister
   \   00000044   0x1940             ADDS     R0,R0,R5
   \   00000046   0x0005             MOVS     R5,R0
    694            }
    695          
    696            return counter;
   \                     ??Codec_PauseResume_1: (+1)
   \   00000048   0x0028             MOVS     R0,R5
   \   0000004A   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    697          }
    698          
    699          /**
    700            * @brief  Stops audio Codec playing. It powers down the codec.
    701            * @param  CodecPdwnMode: selects the  power down mode.
    702            *          - CODEC_PDWN_SW: only mutes the audio codec. When resuming from this 
    703            *                           mode the codec keeps the previous initialization
    704            *                           (no need to re-Initialize the codec registers).
    705            *          - CODEC_PDWN_HW: Physically power down the codec. When resuming from this
    706            *                           mode, the codec is set to default configuration 
    707            *                           (user should re-Initialize the codec in order to 
    708            *                            play again the audio stream).
    709            * @retval 0 if correct communication, else wrong communication
    710            */

   \                                 In section .text, align 2, keep-with-next
    711          static uint32_t Codec_Stop(uint32_t CodecPdwnMode)
    712          {
   \                     Codec_Stop: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    713            uint32_t counter = 0;   
   \   00000004   0x2500             MOVS     R5,#+0
    714          
    715            /* Mute the output first */
    716            Codec_Mute(AUDIO_MUTE_ON);
   \   00000006   0x2001             MOVS     R0,#+1
   \   00000008   0x.... 0x....      BL       Codec_Mute
    717            
    718            if (CodecPdwnMode == CODEC_PDWN_SW)
   \   0000000C   0x2C02             CMP      R4,#+2
   \   0000000E   0xD106             BNE.N    ??Codec_Stop_0
    719            {    
    720              /* Power down the DAC and the speaker (PMDAC and PMSPK bits)*/
    721              counter += Codec_WriteRegister(0x02, 0x9F);
   \   00000010   0x219F             MOVS     R1,#+159
   \   00000012   0x2002             MOVS     R0,#+2
   \   00000014   0x.... 0x....      BL       Codec_WriteRegister
   \   00000018   0x1940             ADDS     R0,R0,R5
   \   0000001A   0x0005             MOVS     R5,R0
   \   0000001C   0xE00F             B.N      ??Codec_Stop_1
    722            }
    723            else /* CODEC_PDWN_HW */
    724            { 
    725              /* Power down the DAC components */
    726              counter += Codec_WriteRegister(0x02, 0x9F);
   \                     ??Codec_Stop_0: (+1)
   \   0000001E   0x219F             MOVS     R1,#+159
   \   00000020   0x2002             MOVS     R0,#+2
   \   00000022   0x.... 0x....      BL       Codec_WriteRegister
   \   00000026   0x1940             ADDS     R0,R0,R5
   \   00000028   0x0005             MOVS     R5,R0
    727              
    728              /* Wait at least 100us */
    729              Delay(0xFFF);
   \   0000002A   0xF640 0x70FF      MOVW     R0,#+4095
   \   0000002E   0x.... 0x....      BL       Delay
    730              
    731              /* Reset The pin */
    732              HAL_GPIO_WritePin(AUDIO_RESET_GPIO, AUDIO_RESET_PIN, GPIO_PIN_RESET);
   \   00000032   0x2200             MOVS     R2,#+0
   \   00000034   0x2110             MOVS     R1,#+16
   \   00000036   0x.... 0x....      LDR.W    R0,??DataTable23_17  ;; 0x40020c00
   \   0000003A   0x.... 0x....      BL       HAL_GPIO_WritePin
    733            }
    734            
    735            return counter;    
   \                     ??Codec_Stop_1: (+1)
   \   0000003E   0x0028             MOVS     R0,R5
   \   00000040   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    736          }
    737          
    738          /**
    739            * @brief  Sets higher or lower the codec volume level.
    740            * @param  Volume: a byte value from 0 to 255 (refer to codec registers 
    741            *         description for more details).
    742            * @retval 0 if correct communication, else wrong communication
    743            */

   \                                 In section .text, align 2, keep-with-next
    744          static uint32_t Codec_VolumeCtrl(uint8_t Volume)
    745          {
   \                     Codec_VolumeCtrl: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    746            uint32_t counter = 0;
   \   00000004   0x2500             MOVS     R5,#+0
    747            
    748            if (Volume > 0xE6)
   \   00000006   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000008   0x2CE7             CMP      R4,#+231
   \   0000000A   0xDB10             BLT.N    ??Codec_VolumeCtrl_0
    749            {
    750              /* Set the Master volume */
    751              counter += Codec_WriteRegister(0x20, Volume - 0xE7); 
   \   0000000C   0xF114 0x0119      ADDS     R1,R4,#+25
   \   00000010   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000012   0x2020             MOVS     R0,#+32
   \   00000014   0x.... 0x....      BL       Codec_WriteRegister
   \   00000018   0x1940             ADDS     R0,R0,R5
   \   0000001A   0x0005             MOVS     R5,R0
    752              counter += Codec_WriteRegister(0x21, Volume - 0xE7);     
   \   0000001C   0xF114 0x0119      ADDS     R1,R4,#+25
   \   00000020   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000022   0x2021             MOVS     R0,#+33
   \   00000024   0x.... 0x....      BL       Codec_WriteRegister
   \   00000028   0x1940             ADDS     R0,R0,R5
   \   0000002A   0x0005             MOVS     R5,R0
   \   0000002C   0xE00F             B.N      ??Codec_VolumeCtrl_1
    753            }
    754            else
    755            {
    756              /* Set the Master volume */
    757              counter += Codec_WriteRegister(0x20, Volume + 0x19); 
   \                     ??Codec_VolumeCtrl_0: (+1)
   \   0000002E   0xF114 0x0119      ADDS     R1,R4,#+25
   \   00000032   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000034   0x2020             MOVS     R0,#+32
   \   00000036   0x.... 0x....      BL       Codec_WriteRegister
   \   0000003A   0x1940             ADDS     R0,R0,R5
   \   0000003C   0x0005             MOVS     R5,R0
    758              counter += Codec_WriteRegister(0x21, Volume + 0x19); 
   \   0000003E   0xF114 0x0119      ADDS     R1,R4,#+25
   \   00000042   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000044   0x2021             MOVS     R0,#+33
   \   00000046   0x.... 0x....      BL       Codec_WriteRegister
   \   0000004A   0x1940             ADDS     R0,R0,R5
   \   0000004C   0x0005             MOVS     R5,R0
    759            }
    760          
    761            return counter;  
   \                     ??Codec_VolumeCtrl_1: (+1)
   \   0000004E   0x0028             MOVS     R0,R5
   \   00000050   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    762          }
    763          
    764          /**
    765            * @brief  Enables or disables the mute feature on the audio codec.
    766            * @param  Cmd: AUDIO_MUTE_ON to enable the mute or AUDIO_MUTE_OFF to disable the
    767            *             mute mode.
    768            * @retval 0 if correct communication, else wrong communication
    769            */

   \                                 In section .text, align 2, keep-with-next
    770          static uint32_t Codec_Mute(uint32_t Cmd)
    771          {
   \                     Codec_Mute: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    772            uint32_t counter = 0;  
   \   00000004   0x2500             MOVS     R5,#+0
    773            
    774            /* Set the Mute mode */
    775            if (Cmd == AUDIO_MUTE_ON)
   \   00000006   0x2C01             CMP      R4,#+1
   \   00000008   0xD106             BNE.N    ??Codec_Mute_0
    776            {
    777              counter += Codec_WriteRegister(0x04, 0xFF);
   \   0000000A   0x21FF             MOVS     R1,#+255
   \   0000000C   0x2004             MOVS     R0,#+4
   \   0000000E   0x.... 0x....      BL       Codec_WriteRegister
   \   00000012   0x1940             ADDS     R0,R0,R5
   \   00000014   0x0005             MOVS     R5,R0
   \   00000016   0xE007             B.N      ??Codec_Mute_1
    778            }
    779            else /* AUDIO_MUTE_OFF Disable the Mute */
    780            {
    781              counter += Codec_WriteRegister(0x04, OutputDev);
   \                     ??Codec_Mute_0: (+1)
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable23_16
   \   0000001C   0x7801             LDRB     R1,[R0, #+0]
   \   0000001E   0x2004             MOVS     R0,#+4
   \   00000020   0x.... 0x....      BL       Codec_WriteRegister
   \   00000024   0x1940             ADDS     R0,R0,R5
   \   00000026   0x0005             MOVS     R5,R0
    782            }
    783            
    784            return counter; 
   \                     ??Codec_Mute_1: (+1)
   \   00000028   0x0028             MOVS     R0,R5
   \   0000002A   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    785          }
    786          
    787          /**
    788            * @brief  Resets the audio codec. It restores the default configuration of the 
    789            *         codec (this function shall be called before initializing the codec).
    790            * @note   This function calls an external driver function: The IO Expander driver.
    791            * @param  None
    792            * @retval None
    793            */

   \                                 In section .text, align 2, keep-with-next
    794          static void Codec_Reset(void)
    795          {
   \                     Codec_Reset: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    796            /* Power Down the codec */
    797            HAL_GPIO_WritePin(AUDIO_RESET_GPIO, AUDIO_RESET_PIN, GPIO_PIN_RESET);
   \   00000002   0x2200             MOVS     R2,#+0
   \   00000004   0x2110             MOVS     R1,#+16
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable23_17  ;; 0x40020c00
   \   0000000A   0x.... 0x....      BL       HAL_GPIO_WritePin
    798          
    799            /* wait for a delay to insure registers erasing */
    800            Delay(CODEC_RESET_DELAY); 
   \   0000000E   0xF644 0x70FF      MOVW     R0,#+20479
   \   00000012   0x.... 0x....      BL       Delay
    801            
    802            /* Power on the codec */
    803            HAL_GPIO_WritePin(AUDIO_RESET_GPIO, AUDIO_RESET_PIN,GPIO_PIN_SET);
   \   00000016   0x2201             MOVS     R2,#+1
   \   00000018   0x2110             MOVS     R1,#+16
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable23_17  ;; 0x40020c00
   \   0000001E   0x.... 0x....      BL       HAL_GPIO_WritePin
    804          }
   \   00000022   0xBD01             POP      {R0,PC}          ;; return
    805          
    806          /**
    807            * @brief  Writes a Byte to a given register into the audio codec through the 
    808                      control interface (I2C)
    809            * @param  RegisterAddr: The address (location) of the register to be written.
    810            * @param  RegisterValue: the Byte value to be written into destination register.
    811            * @retval 0 if correct communication, else wrong communication
    812            */

   \                                 In section .text, align 2, keep-with-next
    813          static uint32_t Codec_WriteRegister(uint8_t RegisterAddr, uint8_t RegisterValue)
    814          {
   \                     Codec_WriteRegister: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
    815            uint32_t result = 0;
   \   00000008   0x2600             MOVS     R6,#+0
    816            uint8_t bufI2C[2];
    817            bufI2C[0] = RegisterAddr;
   \   0000000A   0xF88D 0x4004      STRB     R4,[SP, #+4]
    818            bufI2C[1] = RegisterValue;
   \   0000000E   0xF88D 0x5005      STRB     R5,[SP, #+5]
    819            /* Transmit the first address for write operation */
    820            while(HAL_I2C_Master_Transmit(&hi2c1, CODEC_ADDRESS, &bufI2C[0],2,CODEC_LONG_TIMEOUT)!= HAL_OK)//CODEC_LONG_TIMEOUT
   \                     ??Codec_WriteRegister_0: (+1)
   \   00000012   0xF45F 0x1096      MOVS     R0,#+1228800
   \   00000016   0x9000             STR      R0,[SP, #+0]
   \   00000018   0x2302             MOVS     R3,#+2
   \   0000001A   0xAA01             ADD      R2,SP,#+4
   \   0000001C   0x2194             MOVS     R1,#+148
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable23_18
   \   00000022   0x.... 0x....      BL       HAL_I2C_Master_Transmit
   \   00000026   0x2800             CMP      R0,#+0
   \   00000028   0xD008             BEQ.N    ??Codec_WriteRegister_1
    821            {
    822          	/* Error_Handler() function is called when Timeout error occurs.
    823          	When Acknowledge failure occurs (Slave don't acknowledge its address)
    824          	Master restarts communication */
    825              if (HAL_I2C_GetError(&hi2c1) != HAL_I2C_ERROR_AF)
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable23_18
   \   0000002E   0x.... 0x....      BL       HAL_I2C_GetError
   \   00000032   0x2804             CMP      R0,#+4
   \   00000034   0xD0ED             BEQ.N    ??Codec_WriteRegister_0
    826              {
    827                  return Codec_TIMEOUT_UserCallback();;
   \   00000036   0x.... 0x....      BL       Codec_TIMEOUT_UserCallback
   \   0000003A   0xE00C             B.N      ??Codec_WriteRegister_2
    828              }
    829          
    830            }
    831            
    832            // while(HAL_I2C_Master_Transmit(&hi2c1, CODEC_ADDRESS, &bufI2C[1],1,CODEC_LONG_TIMEOUT)!= HAL_OK)//CODEC_LONG_TIMEOUT
    833            //{
    834          	/* Error_Handler() function is called when Timeout error occurs.
    835          	When Acknowledge failure occurs (Slave don't acknowledge its address)
    836          	Master restarts communication */
    837            //  if (HAL_I2C_GetError(&hi2c1) != HAL_I2C_ERROR_AF)
    838            //  {
    839          
    840            //    return Codec_TIMEOUT_UserCallback();
    841            //  }  
    842          
    843            //}
    844            
    845          #ifdef VERIFY_WRITTENDATA
    846            /* Verify that the data has been correctly written */ 
    847            uint8_t test;
    848            test = Codec_ReadRegister(RegisterAddr);
   \                     ??Codec_WriteRegister_1: (+1)
   \   0000003C   0x0020             MOVS     R0,R4
   \   0000003E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000040   0x.... 0x....      BL       Codec_ReadRegister
   \   00000044   0x0007             MOVS     R7,R0
    849            result = (test == RegisterValue)? 0:1;
   \   00000046   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000048   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000004A   0x42AF             CMP      R7,R5
   \   0000004C   0xD101             BNE.N    ??Codec_WriteRegister_3
   \   0000004E   0x2600             MOVS     R6,#+0
   \   00000050   0xE000             B.N      ??Codec_WriteRegister_4
   \                     ??Codec_WriteRegister_3: (+1)
   \   00000052   0x2601             MOVS     R6,#+1
    850          #endif /* VERIFY_WRITTENDATA */
    851          
    852            /* Return the verifying value: 0 (Passed) or 1 (Failed) */
    853            return result;  
   \                     ??Codec_WriteRegister_4: (+1)
   \   00000054   0x0030             MOVS     R0,R6
   \                     ??Codec_WriteRegister_2: (+1)
   \   00000056   0xBDFE             POP      {R1-R7,PC}       ;; return
    854          }
    855          
    856          /**
    857            * @brief  Reads and returns the value of an audio codec register through the
    858            *         control interface (I2C).
    859            * @param  RegisterAddr: Address of the register to be read.
    860            * @retval Value of the register to be read or dummy value if the communication
    861            *         fails.
    862            */

   \                                 In section .text, align 2, keep-with-next
    863          static uint32_t Codec_ReadRegister(uint8_t RegisterAddr)
    864          {
   \                     Codec_ReadRegister: (+1)
   \   00000000   0xB501             PUSH     {R0,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
    865            uint8_t result = 0;
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0xF88D 0x0004      STRB     R0,[SP, #+4]
    866          
    867            /* Transmit the register address to be read */
    868            /* Transmit the first address for write operation */
    869            while(HAL_I2C_Master_Transmit(&hi2c1, CODEC_ADDRESS, &RegisterAddr,1,CODEC_LONG_TIMEOUT)!= HAL_OK)
   \                     ??Codec_ReadRegister_0: (+1)
   \   0000000A   0xF45F 0x1096      MOVS     R0,#+1228800
   \   0000000E   0x9000             STR      R0,[SP, #+0]
   \   00000010   0x2301             MOVS     R3,#+1
   \   00000012   0xAA02             ADD      R2,SP,#+8
   \   00000014   0x2194             MOVS     R1,#+148
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable23_18
   \   0000001A   0x.... 0x....      BL       HAL_I2C_Master_Transmit
   \   0000001E   0x2800             CMP      R0,#+0
   \   00000020   0xD008             BEQ.N    ??Codec_ReadRegister_1
    870            {
    871          	/* Error_Handler() function is called when Timeout error occurs.
    872          	When Acknowledge failure occurs (Slave don't acknowledge its address)
    873          	Master restarts communication */
    874              if (HAL_I2C_GetError(&hi2c1) != HAL_I2C_ERROR_AF)
   \   00000022   0x.... 0x....      LDR.W    R0,??DataTable23_18
   \   00000026   0x.... 0x....      BL       HAL_I2C_GetError
   \   0000002A   0x2804             CMP      R0,#+4
   \   0000002C   0xD0ED             BEQ.N    ??Codec_ReadRegister_0
    875              {
    876                return Codec_TIMEOUT_UserCallback();
   \   0000002E   0x.... 0x....      BL       Codec_TIMEOUT_UserCallback
   \   00000032   0xE016             B.N      ??Codec_ReadRegister_2
    877              }  
    878            }
    879            
    880            /*!< Read the byte received from the Codec */
    881            //result = I2C_ReceiveData(CODEC_I2C);
    882            while(HAL_I2C_Master_Receive(&hi2c1, (uint16_t)CODEC_ADDRESS, &result, 1, CODEC_LONG_TIMEOUT) != HAL_OK)
   \                     ??Codec_ReadRegister_1: (+1)
   \   00000034   0xF45F 0x1096      MOVS     R0,#+1228800
   \   00000038   0x9000             STR      R0,[SP, #+0]
   \   0000003A   0x2301             MOVS     R3,#+1
   \   0000003C   0xAA01             ADD      R2,SP,#+4
   \   0000003E   0x2194             MOVS     R1,#+148
   \   00000040   0x.... 0x....      LDR.W    R0,??DataTable23_18
   \   00000044   0x.... 0x....      BL       HAL_I2C_Master_Receive
   \   00000048   0x2800             CMP      R0,#+0
   \   0000004A   0xD008             BEQ.N    ??Codec_ReadRegister_3
    883            {
    884              /* Error_Handler() function is called when Timeout error occurs.
    885                 When Acknowledge failure occurs (Slave don't acknowledge it's address)
    886                 Master restarts communication */
    887              if (HAL_I2C_GetError(&hi2c1) != HAL_I2C_ERROR_AF)
   \   0000004C   0x.... 0x....      LDR.W    R0,??DataTable23_18
   \   00000050   0x.... 0x....      BL       HAL_I2C_GetError
   \   00000054   0x2804             CMP      R0,#+4
   \   00000056   0xD0ED             BEQ.N    ??Codec_ReadRegister_1
    888              {
    889                return Codec_TIMEOUT_UserCallback();
   \   00000058   0x.... 0x....      BL       Codec_TIMEOUT_UserCallback
   \   0000005C   0xE001             B.N      ??Codec_ReadRegister_2
    890              }
    891            }
    892            
    893            /* Return the byte read from Codec */
    894            return (uint32_t)result;
   \                     ??Codec_ReadRegister_3: (+1)
   \   0000005E   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \                     ??Codec_ReadRegister_2: (+1)
   \   00000062   0xBD0E             POP      {R1-R3,PC}       ;; return
    895          }
    896          
    897          /**
    898            * @brief  Initializes the Audio Codec control interface (I2C).
    899            * @param  None
    900            * @retval None
    901            */

   \                                 In section .text, align 2, keep-with-next
    902          static void Codec_CtrlInterface_Init(void)
    903          {
   \                     Codec_CtrlInterface_Init: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    904              MX_I2C1_Init();   
   \   00000002   0x.... 0x....      BL       MX_I2C1_Init
    905          }
   \   00000006   0xBD01             POP      {R0,PC}          ;; return
    906          
    907          /**
    908            * @brief  Restore the Audio Codec control interface to its default state.
    909            *         This function doesn't de-initialize the I2C because the I2C peripheral
    910            *         may be used by other modules.
    911            * @param  None
    912            * @retval None
    913            */

   \                                 In section .text, align 2, keep-with-next
    914          static void Codec_CtrlInterface_DeInit(void)
    915          {
   \                     Codec_CtrlInterface_DeInit: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    916            /* Disable the I2C peripheral */ /* This step is not done here because 
    917               the I2C interface can be used by other modules */
    918            /* I2C_DeInit(CODEC_I2C); */
    919            HAL_I2C_MspDeInit(&hi2c1);
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable23_18
   \   00000006   0x.... 0x....      BL       HAL_I2C_MspDeInit
    920          }
   \   0000000A   0xBD01             POP      {R0,PC}          ;; return
    921          
    922          /**
    923            * @brief  Initializes the Audio Codec audio interface (I2S)
    924            * @note   This function assumes that the I2S input clock (through PLL_R in 
    925            *         Devices RevA/Z and through dedicated PLLI2S_R in Devices RevB/Y)
    926            *         is already configured and ready to be used.    
    927            * @param  AudioFreq: Audio frequency to be configured for the I2S peripheral. 
    928            * @retval None
    929            */

   \                                 In section .text, align 2, keep-with-next
    930          static void Codec_AudioInterface_Init(uint32_t AudioFreq)
    931          {
   \                     Codec_AudioInterface_Init: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0004             MOVS     R4,R0
    932              
    933            static I2S_HandleTypeDef hi2s3;
    934            /* Enable the CODEC_I2S peripheral clock */
    935            __SPI3_CLK_ENABLE();
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable23_19  ;; 0x40023840
   \   0000000A   0x6800             LDR      R0,[R0, #+0]
   \   0000000C   0xF450 0x4000      ORRS     R0,R0,#0x8000
   \   00000010   0x.... 0x....      LDR.W    R1,??DataTable23_19  ;; 0x40023840
   \   00000014   0x6008             STR      R0,[R1, #+0]
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable23_19  ;; 0x40023840
   \   0000001A   0x6800             LDR      R0,[R0, #+0]
   \   0000001C   0xF410 0x4000      ANDS     R0,R0,#0x8000
   \   00000020   0x9000             STR      R0,[SP, #+0]
   \   00000022   0x9800             LDR      R0,[SP, #+0]
    936          
    937            hi2s3.Instance = SPI3;
   \   00000024   0x.... 0x....      LDR.W    R0,??DataTable23_15  ;; 0x40003c00
   \   00000028   0x.... 0x....      LDR.W    R1,??DataTable23_20
   \   0000002C   0x6008             STR      R0,[R1, #+0]
    938            /* Disable I2S3 peripheral to allow access to I2S internal registers */
    939            __HAL_I2S_DISABLE(&hi2s3);
   \   0000002E   0x.... 0x....      LDR.W    R0,??DataTable23_20
   \   00000032   0x6800             LDR      R0,[R0, #+0]
   \   00000034   0x69C0             LDR      R0,[R0, #+28]
   \   00000036   0xF430 0x6080      BICS     R0,R0,#0x400
   \   0000003A   0x.... 0x....      LDR.W    R1,??DataTable23_20
   \   0000003E   0x6809             LDR      R1,[R1, #+0]
   \   00000040   0x61C8             STR      R0,[R1, #+28]
    940            
    941            hi2s3.Init.Standard = I2S_STANDARD;
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0x.... 0x....      LDR.W    R1,??DataTable23_20
   \   00000048   0x6088             STR      R0,[R1, #+8]
    942            hi2s3.Init.DataFormat = I2S_DATAFORMAT_16B;
   \   0000004A   0x2000             MOVS     R0,#+0
   \   0000004C   0x.... 0x....      LDR.W    R1,??DataTable23_20
   \   00000050   0x60C8             STR      R0,[R1, #+12]
    943            hi2s3.Init.AudioFreq = AudioFreq;
   \   00000052   0x.... 0x....      LDR.W    R0,??DataTable23_20
   \   00000056   0x6144             STR      R4,[R0, #+20]
    944            hi2s3.Init.CPOL = I2S_CPOL_LOW;
   \   00000058   0x2000             MOVS     R0,#+0
   \   0000005A   0x.... 0x....      LDR.W    R1,??DataTable23_20
   \   0000005E   0x6188             STR      R0,[R1, #+24]
    945            hi2s3.Init.ClockSource = I2S_CLOCK_SYSCLK;
   \   00000060   0x2002             MOVS     R0,#+2
   \   00000062   0x.... 0x....      LDR.W    R1,??DataTable23_20
   \   00000066   0x61C8             STR      R0,[R1, #+28]
    946            hi2s3.Init.Mode = I2S_MODE_MASTER_TX;
   \   00000068   0xF44F 0x7000      MOV      R0,#+512
   \   0000006C   0x.... 0x....      LDR.W    R1,??DataTable23_20
   \   00000070   0x6048             STR      R0,[R1, #+4]
    947          
    948          #ifdef CODEC_MCLK_ENABLED
    949            hi2s3.Init.MCLKOutput = I2S_MCLKOUTPUT_ENABLE;
   \   00000072   0xF44F 0x7000      MOV      R0,#+512
   \   00000076   0x.... 0x....      LDR.W    R1,??DataTable23_20
   \   0000007A   0x6108             STR      R0,[R1, #+16]
    950          #elif defined(CODEC_MCLK_DISABLED)
    951            hi2s3.Init.MCLKOutput = I2S_MCLKOUTPUT_DISABLE;
    952          #else
    953          #error "No selection for the MCLK output has been defined !"
    954          #endif /* CODEC_MCLK_ENABLED */
    955            
    956            /* Initialize the I2S peripheral with the structure above */
    957            HAL_I2S_Init(&hi2s3);
   \   0000007C   0x.... 0x....      LDR.W    R0,??DataTable23_20
   \   00000080   0x.... 0x....      BL       HAL_I2S_Init
    958           
    959            __HAL_I2S_ENABLE(&hi2s3);
   \   00000084   0x.... 0x....      LDR.W    R0,??DataTable23_20
   \   00000088   0x6800             LDR      R0,[R0, #+0]
   \   0000008A   0x69C0             LDR      R0,[R0, #+28]
   \   0000008C   0xF450 0x6080      ORRS     R0,R0,#0x400
   \   00000090   0x.... 0x....      LDR.W    R1,??DataTable23_20
   \   00000094   0x6809             LDR      R1,[R1, #+0]
   \   00000096   0x61C8             STR      R0,[R1, #+28]
    960            
    961          
    962            /* The I2S peripheral will be enabled only in the AUDIO_Play() function 
    963                 or by user functions if DMA mode not enabled */  
    964          }
   \   00000098   0xBD13             POP      {R0,R1,R4,PC}    ;; return

   \                                 In section .bss, align 4
   \                     ??hi2s3:
   \   00000000                      DS8 64
    965          
    966          /**
    967            * @brief  Restores the Audio Codec audio interface to its default state.
    968            * @param  None
    969            * @retval None
    970            */

   \                                 In section .text, align 2, keep-with-next
    971          static void Codec_AudioInterface_DeInit(void)
    972          {
   \                     Codec_AudioInterface_DeInit: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    973            /* Disable the CODEC_I2S peripheral (in case it hasn't already been disabled) */
    974            //I2S_Cmd(CODEC_I2S, DISABLE);
    975            __HAL_I2S_DISABLE(&hi2s3);
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable23_14
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0x69C0             LDR      R0,[R0, #+28]
   \   0000000A   0xF430 0x6080      BICS     R0,R0,#0x400
   \   0000000E   0x.... 0x....      LDR.W    R1,??DataTable23_14
   \   00000012   0x6809             LDR      R1,[R1, #+0]
   \   00000014   0x61C8             STR      R0,[R1, #+28]
    976            /* Deinitialize the CODEC_I2S peripheral */
    977            SPI_I2S_DeInit(CODEC_I2S);
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable23_15  ;; 0x40003c00
   \   0000001A   0x.... 0x....      BL       SPI_I2S_DeInit
    978            
    979            /* Disable the CODEC_I2S peripheral clock */
    980            //RCC_APB1PeriphClockCmd(CODEC_I2S_CLK, DISABLE); 
    981            __HAL_RCC_SPI3_CLK_DISABLE();
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable23_19  ;; 0x40023840
   \   00000022   0x6800             LDR      R0,[R0, #+0]
   \   00000024   0xF430 0x4000      BICS     R0,R0,#0x8000
   \   00000028   0x.... 0x....      LDR.W    R1,??DataTable23_19  ;; 0x40023840
   \   0000002C   0x6008             STR      R0,[R1, #+0]
    982          }
   \   0000002E   0xBD01             POP      {R0,PC}          ;; return
    983          
    984          /**
    985            * @brief Initializes IOs used by the Audio Codec (on the control and audio 
    986            *        interfaces).
    987            * @param  None
    988            * @retval None
    989            */

   \                                 In section .text, align 2, keep-with-next
    990          static void Codec_GPIO_Init(void)
    991          {
   \                     Codec_GPIO_Init: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB087             SUB      SP,SP,#+28
    992            GPIO_InitTypeDef GPIO_InitStructure;
    993            
    994            __GPIOD_CLK_ENABLE();
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable23_21  ;; 0x40023830
   \   00000008   0x6800             LDR      R0,[R0, #+0]
   \   0000000A   0xF050 0x0008      ORRS     R0,R0,#0x8
   \   0000000E   0x.... 0x....      LDR.W    R1,??DataTable23_21  ;; 0x40023830
   \   00000012   0x6008             STR      R0,[R1, #+0]
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable23_21  ;; 0x40023830
   \   00000018   0x6800             LDR      R0,[R0, #+0]
   \   0000001A   0xF010 0x0008      ANDS     R0,R0,#0x8
   \   0000001E   0x9000             STR      R0,[SP, #+0]
   \   00000020   0x9800             LDR      R0,[SP, #+0]
    995            
    996            /* Audio reset pin configuration -------------------------------------------------*/
    997            GPIO_InitStructure.Pin = AUDIO_RESET_PIN; 
   \   00000022   0x2010             MOVS     R0,#+16
   \   00000024   0x9001             STR      R0,[SP, #+4]
    998            GPIO_InitStructure.Mode = GPIO_MODE_OUTPUT_PP;//GPIO_Mode_OUT;
   \   00000026   0x2001             MOVS     R0,#+1
   \   00000028   0x9002             STR      R0,[SP, #+8]
    999            GPIO_InitStructure.Speed = GPIO_SPEED_HIGH;//GPIO_Speed_50MHz;
   \   0000002A   0x2003             MOVS     R0,#+3
   \   0000002C   0x9004             STR      R0,[SP, #+16]
   1000            GPIO_InitStructure.Pull  = GPIO_NOPULL ;//GPIO_PuPd_NOPULL;
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0x9003             STR      R0,[SP, #+12]
   1001             
   1002            HAL_GPIO_Init(AUDIO_RESET_GPIO, &GPIO_InitStructure);    
   \   00000032   0xA901             ADD      R1,SP,#+4
   \   00000034   0x.... 0x....      LDR.W    R0,??DataTable23_17  ;; 0x40020c00
   \   00000038   0x.... 0x....      BL       HAL_GPIO_Init
   1003            
   1004          }
   \   0000003C   0xB007             ADD      SP,SP,#+28
   \   0000003E   0xBD00             POP      {PC}             ;; return
   1005          
   1006          /**
   1007            * @brief  Restores the IOs used by the Audio Codec interface to their default state.
   1008            * @param  None
   1009            * @retval None
   1010            */

   \                                 In section .text, align 2, keep-with-next
   1011          static void Codec_GPIO_DeInit(void)
   1012          {
   \                     Codec_GPIO_DeInit: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB085             SUB      SP,SP,#+20
   1013            GPIO_InitTypeDef GPIO_InitStructure;
   1014            
   1015            GPIO_InitStructure.Pin = CODEC_I2S_SCK_PIN | CODEC_I2S_SD_PIN; 
   \   00000004   0x200C             MOVS     R0,#+12
   \   00000006   0x9000             STR      R0,[SP, #+0]
   1016            GPIO_InitStructure.Mode = GPIO_MODE_INPUT;
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x9001             STR      R0,[SP, #+4]
   1017            GPIO_InitStructure.Speed = GPIO_SPEED_LOW;
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x9003             STR      R0,[SP, #+12]
   1018            GPIO_InitStructure.Pull = GPIO_NOPULL;
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0x9002             STR      R0,[SP, #+8]
   1019            HAL_GPIO_Init(CODEC_I2S_GPIO, &GPIO_InitStructure);
   \   00000014   0x4669             MOV      R1,SP
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable23_22  ;; 0x40020400
   \   0000001A   0x.... 0x....      BL       HAL_GPIO_Init
   1020                
   1021            GPIO_InitStructure.Pin = CODEC_I2S_WS_PIN ;
   \   0000001E   0xF44F 0x4000      MOV      R0,#+32768
   \   00000022   0x9000             STR      R0,[SP, #+0]
   1022            HAL_GPIO_Init(CODEC_I2S_WS_GPIO, &GPIO_InitStructure); 
   \   00000024   0x4669             MOV      R1,SP
   \   00000026   0x.... 0x....      LDR.W    R0,??DataTable23_23  ;; 0x40020000
   \   0000002A   0x.... 0x....      BL       HAL_GPIO_Init
   1023            
   1024          #ifdef CODEC_MCLK_ENABLED
   1025            GPIO_InitStructure.Pin = CODEC_I2S_MCK_PIN; 
   \   0000002E   0x2080             MOVS     R0,#+128
   \   00000030   0x9000             STR      R0,[SP, #+0]
   1026            HAL_GPIO_Init(CODEC_I2S_MCK_GPIO, &GPIO_InitStructure); 
   \   00000032   0x4669             MOV      R1,SP
   \   00000034   0x.... 0x....      LDR.W    R0,??DataTable23_24  ;; 0x40020800
   \   00000038   0x.... 0x....      BL       HAL_GPIO_Init
   1027          #endif /* CODEC_MCLK_ENABLED */    
   1028          }
   \   0000003C   0xB005             ADD      SP,SP,#+20
   \   0000003E   0xBD00             POP      {PC}             ;; return
   1029          
   1030          /**
   1031            * @brief  Inserts a delay time (not accurate timing).
   1032            * @param  nCount: specifies the delay time length.
   1033            * @retval None
   1034            */

   \                                 In section .text, align 2, keep-with-next
   1035          static void Delay( __IO uint32_t nCount)
   1036          {
   \                     Delay: (+1)
   \   00000000   0xB401             PUSH     {R0}
   1037            for (; nCount != 0; nCount--);
   \                     ??Delay_0: (+1)
   \   00000002   0x9800             LDR      R0,[SP, #+0]
   \   00000004   0x2800             CMP      R0,#+0
   \   00000006   0xD003             BEQ.N    ??Delay_1
   \   00000008   0x9800             LDR      R0,[SP, #+0]
   \   0000000A   0x1E40             SUBS     R0,R0,#+1
   \   0000000C   0x9000             STR      R0,[SP, #+0]
   \   0000000E   0xE7F8             B.N      ??Delay_0
   1038          }
   \                     ??Delay_1: (+1)
   \   00000010   0xB001             ADD      SP,SP,#+4
   \   00000012   0x4770             BX       LR               ;; return
   1039          
   1040          #ifdef USE_DEFAULT_TIMEOUT_CALLBACK
   1041          /**
   1042            * @brief  Basic management of the timeout situation.
   1043            * @param  None
   1044            * @retval None
   1045            */
   1046          uint32_t Codec_TIMEOUT_UserCallback(void)
   1047          {
   1048            /* Block communication and all processes */
   1049            
   1050          }
   1051          #endif /* USE_DEFAULT_TIMEOUT_CALLBACK */
   1052          /*========================
   1053                          Audio MAL Interface Control Functions
   1054                                                          ==============================*/
   1055          
   1056          
   1057          /**
   1058            * @brief  Restore default state of the used Media.
   1059            * @param  None
   1060            * @retval None
   1061            */

   \                                 In section .text, align 2, keep-with-next
   1062          static void Audio_MAL_DeInit(void)  
   1063          {   
   \                     Audio_MAL_DeInit: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1064          #if defined(AUDIO_MAL_DMA_IT_TC_EN) || defined(AUDIO_MAL_DMA_IT_HT_EN) || defined(AUDIO_MAL_DMA_IT_TE_EN)
   1065            //NVIC_InitTypeDef NVIC_InitStructure;  
   1066            
   1067            /* Deinitialize the NVIC interrupt for the I2S DMA Stream */
   1068            //NVIC_InitStructure.NVIC_IRQChannel = AUDIO_I2S_DMA_IRQ;
   1069            //NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = AUDIO_IRQ_PREPRIO;
   1070            //NVIC_InitStructure.NVIC_IRQChannelSubPriority = AUDIO_IRQ_SUBRIO;
   1071            //NVIC_InitStructure.NVIC_IRQChannelCmd = DISABLE;
   1072            //NVIC_Init(&NVIC_InitStructure);  
   1073             HAL_NVIC_DisableIRQ(SPI3_IRQn); 
   \   00000002   0x2033             MOVS     R0,#+51
   \   00000004   0x.... 0x....      BL       HAL_NVIC_DisableIRQ
   1074          #endif 
   1075            
   1076            /* Disable the DMA stream before the deinit */
   1077            HAL_NVIC_DisableIRQ(DMA1_Stream7_IRQn); 
   \   00000008   0x202F             MOVS     R0,#+47
   \   0000000A   0x.... 0x....      BL       HAL_NVIC_DisableIRQ
   1078            HAL_NVIC_DisableIRQ(SPI3_IRQn); 
   \   0000000E   0x2033             MOVS     R0,#+51
   \   00000010   0x.... 0x....      BL       HAL_NVIC_DisableIRQ
   1079            
   1080          }
   \   00000014   0xBD01             POP      {R0,PC}          ;; return
   1081          
   1082          /**
   1083            * @brief  Starts playing audio stream from the audio Media.
   1084            * @param  None
   1085            * @retval None
   1086            */

   \                                 In section .text, align 2, keep-with-next
   1087          void Audio_MAL_Play(uint16_t *Addr, uint16_t Size)
   1088          {
   \                     Audio_MAL_Play: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1089             uint16_t *bufAddrI2S;
   1090             bufAddrI2S = Addr;
   \   00000006   0x0026             MOVS     R6,R4
   1091             HAL_I2S_Transmit_DMA(&hi2s3,bufAddrI2S,(uint16_t)Size/2);  
   \   00000008   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000000A   0x2002             MOVS     R0,#+2
   \   0000000C   0xFB95 0xF0F0      SDIV     R0,R5,R0
   \   00000010   0x0002             MOVS     R2,R0
   \   00000012   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000014   0x0031             MOVS     R1,R6
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable23_14
   \   0000001A   0x.... 0x....      BL       HAL_I2S_Transmit_DMA
   1092          }
   \   0000001E   0xBD70             POP      {R4-R6,PC}       ;; return
   1093          
   1094          /**
   1095            * @brief  Pauses or Resumes the audio stream playing from the Media.
   1096            * @param  Cmd: AUDIO_PAUSE (or 0) to pause, AUDIO_RESUME (or any value different
   1097            *              from 0) to resume. 
   1098            * @param  Addr: Address from/at which the audio stream should resume/pause.
   1099            * @retval None
   1100            */

   \                                 In section .text, align 2, keep-with-next
   1101          static void Audio_MAL_PauseResume(uint32_t Cmd, uint32_t Addr)
   1102          {
   \                     Audio_MAL_PauseResume: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1103            /* Pause the audio file playing */
   1104            if (Cmd == AUDIO_PAUSE)
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD10B             BNE.N    ??Audio_MAL_PauseResume_0
   1105            {   
   1106              /* Disable the I2S DMA request */
   1107              SPI_I2S_DMACmd(CODEC_I2S, SPI_I2S_DMAReq_Tx, DISABLE);
   \   0000000A   0x2200             MOVS     R2,#+0
   \   0000000C   0x2102             MOVS     R1,#+2
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable23_15  ;; 0x40003c00
   \   00000012   0x.... 0x....      BL       SPI_I2S_DMACmd
   1108          
   1109              /* Pause the I2S DMA Stream 
   1110                  Note. For the STM32F40x devices, the DMA implements a pause feature, 
   1111                        by disabling the stream, all configuration is preserved and data 
   1112                        transfer is paused till the next enable of the stream.
   1113                        This feature is not available on STM32F40x devices. */
   1114              DMA_Cmd(AUDIO_I2S_DMA_STREAM, DISABLE);
   \   00000016   0x2100             MOVS     R1,#+0
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable23_25  ;; 0x400260b8
   \   0000001C   0x.... 0x....      BL       DMA_Cmd
   \   00000020   0xE014             B.N      ??Audio_MAL_PauseResume_1
   1115            }
   1116            else /* AUDIO_RESUME */
   1117            {
   1118              /* Enable the I2S DMA request */
   1119              SPI_I2S_DMACmd(CODEC_I2S, SPI_I2S_DMAReq_Tx, ENABLE);
   \                     ??Audio_MAL_PauseResume_0: (+1)
   \   00000022   0x2201             MOVS     R2,#+1
   \   00000024   0x2102             MOVS     R1,#+2
   \   00000026   0x.... 0x....      LDR.W    R0,??DataTable23_15  ;; 0x40003c00
   \   0000002A   0x.... 0x....      BL       SPI_I2S_DMACmd
   1120            
   1121              /* Resume the I2S DMA Stream 
   1122                  Note. For the STM32F40x devices, the DMA implements a pause feature, 
   1123                        by disabling the stream, all configuration is preserved and data 
   1124                        transfer is paused till the next enable of the stream.
   1125                        This feature is not available on STM32F40x devices. */
   1126              DMA_Cmd(AUDIO_I2S_DMA_STREAM, ENABLE);
   \   0000002E   0x2101             MOVS     R1,#+1
   \   00000030   0x.... 0x....      LDR.W    R0,??DataTable23_25  ;; 0x400260b8
   \   00000034   0x.... 0x....      BL       DMA_Cmd
   1127              
   1128              /* If the I2S peripheral is still not enabled, enable it */
   1129              if ((CODEC_I2S->I2SCFGR & I2S_ENABLE_MASK) == 0)
   \   00000038   0x.... 0x....      LDR.W    R0,??DataTable23_26  ;; 0x40003c1c
   \   0000003C   0x6800             LDR      R0,[R0, #+0]
   \   0000003E   0x0540             LSLS     R0,R0,#+21
   \   00000040   0xD404             BMI.N    ??Audio_MAL_PauseResume_1
   1130              {
   1131                I2S_Cmd(CODEC_I2S, ENABLE);
   \   00000042   0x2101             MOVS     R1,#+1
   \   00000044   0x.... 0x....      LDR.W    R0,??DataTable23_15  ;; 0x40003c00
   \   00000048   0x.... 0x....      BL       I2S_Cmd
   1132              }    
   1133            } 
   1134          }
   \                     ??Audio_MAL_PauseResume_1: (+1)
   \   0000004C   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1135          
   1136          /**
   1137            * @brief  Stops audio stream playing on the used Media.
   1138            * @param  None
   1139            * @retval None
   1140            */

   \                                 In section .text, align 2, keep-with-next
   1141          static void Audio_MAL_Stop(void)
   1142          {   
   \                     Audio_MAL_Stop: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1143            /* Stop the Transfer on the I2S side: Stop and disable the DMA stream */
   1144            DMA_Cmd(AUDIO_I2S_DMA_STREAM, DISABLE);
   \   00000002   0x2100             MOVS     R1,#+0
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable23_25  ;; 0x400260b8
   \   00000008   0x.... 0x....      BL       DMA_Cmd
   1145          
   1146            /* Clear all the DMA flags for the next transfer */
   1147            DMA_ClearFlag(AUDIO_I2S_DMA_STREAM, AUDIO_I2S_DMA_FLAG_TC |AUDIO_I2S_DMA_FLAG_HT | \
   1148                                            AUDIO_I2S_DMA_FLAG_FE | AUDIO_I2S_DMA_FLAG_TE);
   \   0000000C   0xF05F 0x6164      MOVS     R1,#+239075328
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable23_25  ;; 0x400260b8
   \   00000014   0x.... 0x....      BL       DMA_ClearFlag
   1149            
   1150            /*  
   1151                     The I2S DMA requests are not disabled here.
   1152                                                                      */
   1153            
   1154            /* In all modes, disable the I2S peripheral */
   1155            I2S_Cmd(CODEC_I2S, DISABLE);
   \   00000018   0x2100             MOVS     R1,#+0
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable23_15  ;; 0x40003c00
   \   0000001E   0x.... 0x....      BL       I2S_Cmd
   1156          }
   \   00000022   0xBD01             POP      {R0,PC}          ;; return
   1157          
   1158          /**
   1159            * @brief  DAC  Channel1 Configuration
   1160            * @param  None
   1161            * @retval None
   1162            */

   \                                 In section .text, align 2, keep-with-next
   1163          void DAC_Config(void)
   1164          {
   1165          
   1166          }
   \                     DAC_Config: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1167          

   \                                 In section .text, align 2, keep-with-next
   1168          static void SPI_I2S_SendData(SPI_TypeDef* SPIx, uint16_t Data)
   1169          {
   1170            /* Check the parameters */
   1171            assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
   1172            
   1173            /* Write in the DR register the data to be sent */
   1174            SPIx->DR = Data;
   \                     SPI_I2S_SendData: (+1)
   \   00000000   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000002   0x60C1             STR      R1,[R0, #+12]
   1175          }
   \   00000004   0x4770             BX       LR               ;; return
   1176          
   1177          
   1178          static void I2C_GenerateSTART(I2C_TypeDef* I2Cx, FunctionalState NewState)
                             ^
Warning[Pe177]: function "I2C_GenerateSTART" was declared but never referenced
   1179          {
   1180            /* Check the parameters */
   1181            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
   1182            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1183            if (NewState != DISABLE)
   1184            {
   1185              /* Generate a START condition */
   1186              I2Cx->CR1 |= I2C_CR1_START;
   1187            }
   1188            else
   1189            {
   1190              /* Disable the START condition generation */
   1191              I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_START);
   1192            }
   1193          }
   1194          
   1195          static void I2C_Send7bitAddress(I2C_TypeDef* I2Cx, uint8_t Address, uint8_t I2C_Direction)
                             ^
Warning[Pe177]: function "I2C_Send7bitAddress" was declared but never
          referenced
   1196          {
   1197          
   1198            /* Test on the direction to set/reset the read/write bit */
   1199            if (I2C_Direction != I2C_Direction_Transmitter)
   1200            {
   1201              /* Set the address bit0 for read */
   1202              Address |= I2C_OAR1_ADD0;
   1203            }
   1204            else
   1205            {
   1206              /* Reset the address bit0 for write */
   1207              Address &= (uint8_t)~((uint8_t)I2C_OAR1_ADD0);
   1208            }
   1209            /* Send the address */
   1210          
   1211            I2Cx->TXDR = Address;
   1212          
   1213          }
   1214          
   1215          
   1216          /*
   1217           ===============================================================================
   1218                                    1. Basic state monitoring                    
   1219           ===============================================================================  
   1220           */
   1221          
   1222          /**
   1223            * @brief  Checks whether the last I2Cx Event is equal to the one passed
   1224            *         as parameter.
   1225            * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
   1226            * @param  I2C_EVENT: specifies the event to be checked. 
   1227            *          This parameter can be one of the following values:
   1228            *            @arg I2C_EVENT_SLAVE_TRANSMITTER_ADDRESS_MATCHED: EV1
   1229            *            @arg I2C_EVENT_SLAVE_RECEIVER_ADDRESS_MATCHED: EV1
   1230            *            @arg I2C_EVENT_SLAVE_TRANSMITTER_SECONDADDRESS_MATCHED: EV1
   1231            *            @arg I2C_EVENT_SLAVE_RECEIVER_SECONDADDRESS_MATCHED: EV1
   1232            *            @arg I2C_EVENT_SLAVE_GENERALCALLADDRESS_MATCHED: EV1
   1233            *            @arg I2C_EVENT_SLAVE_BYTE_RECEIVED: EV2
   1234            *            @arg (I2C_EVENT_SLAVE_BYTE_RECEIVED | I2C_FLAG_DUALF): EV2
   1235            *            @arg (I2C_EVENT_SLAVE_BYTE_RECEIVED | I2C_FLAG_GENCALL): EV2
   1236            *            @arg I2C_EVENT_SLAVE_BYTE_TRANSMITTED: EV3
   1237            *            @arg (I2C_EVENT_SLAVE_BYTE_TRANSMITTED | I2C_FLAG_DUALF): EV3
   1238            *            @arg (I2C_EVENT_SLAVE_BYTE_TRANSMITTED | I2C_FLAG_GENCALL): EV3
   1239            *            @arg I2C_EVENT_SLAVE_ACK_FAILURE: EV3_2
   1240            *            @arg I2C_EVENT_SLAVE_STOP_DETECTED: EV4
   1241            *            @arg I2C_EVENT_MASTER_MODE_SELECT: EV5
   1242            *            @arg I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED: EV6     
   1243            *            @arg I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED: EV6
   1244            *            @arg I2C_EVENT_MASTER_BYTE_RECEIVED: EV7
   1245            *            @arg I2C_EVENT_MASTER_BYTE_TRANSMITTING: EV8
   1246            *            @arg I2C_EVENT_MASTER_BYTE_TRANSMITTED: EV8_2
   1247            *            @arg I2C_EVENT_MASTER_MODE_ADDRESS10: EV9
   1248            *     
   1249            * @note   For detailed description of Events, please refer to section I2C_Events
   1250            *         in stm32f4xx_i2c.h file.
   1251            *    
   1252            * @retval An ErrorStatus enumeration value:
   1253            *           - SUCCESS: Last event is equal to the I2C_EVENT
   1254            *           - ERROR: Last event is different from the I2C_EVENT
   1255            */
   1256          static ErrorStatus I2C_CheckEvent(I2C_TypeDef* I2Cx, uint32_t I2C_EVENT)
                                    ^
Warning[Pe177]: function "I2C_CheckEvent" was declared but never referenced
   1257          {
   1258            uint32_t lastevent = 0;
   1259            ErrorStatus status = ERROR;
   1260          
   1261            
   1262            /* Get the last event value from I2C status register */
   1263            lastevent = I2Cx->ISR;
   1264          
   1265            /* Check whether the last event contains the I2C_EVENT */
   1266            if ((lastevent & I2C_EVENT) == I2C_EVENT)
   1267            {
   1268              /* SUCCESS: last event is equal to I2C_EVENT */
   1269              status = SUCCESS;
   1270            }
   1271            else
   1272            {
   1273              /* ERROR: last event is different from I2C_EVENT */
   1274              status = ERROR;
   1275            }
   1276            /* Return status */
   1277            return status;
   1278          }
   1279          
   1280          
   1281          static void I2C_SendData(I2C_TypeDef* I2Cx, uint8_t Data)
                             ^
Warning[Pe177]: function "I2C_SendData" was declared but never referenced
   1282          {
   1283          
   1284            /* Write in the DR register the data to be sent */
   1285            I2Cx->TXDR = Data;
   1286          }
   1287          
   1288          static void I2C_GenerateSTOP(I2C_TypeDef* I2Cx, FunctionalState NewState)
                             ^
Warning[Pe177]: function "I2C_GenerateSTOP" was declared but never referenced
   1289          {
   1290          
   1291            if (NewState != DISABLE)
   1292            {
   1293              /* Generate a STOP condition */
   1294              I2Cx->CR1 |= I2C_CR1_STOP;
   1295            }
   1296            else
   1297            {
   1298              /* Disable the STOP condition generation */
   1299              I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_STOP);
   1300            }
   1301          }
   1302          
   1303          
   1304          
   1305          /*
   1306           ===============================================================================
   1307                                    3. Flag-based state monitoring                   
   1308           ===============================================================================  
   1309           */
   1310          
   1311          /**
   1312            * @brief  Checks whether the specified I2C flag is set or not.
   1313            * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
   1314            * @param  I2C_FLAG: specifies the flag to check. 
   1315            *          This parameter can be one of the following values:
   1316            *            @arg I2C_FLAG_DUALF: Dual flag (Slave mode)
   1317            *            @arg I2C_FLAG_SMBHOST: SMBus host header (Slave mode)
   1318            *            @arg I2C_FLAG_SMBDEFAULT: SMBus default header (Slave mode)
   1319            *            @arg I2C_FLAG_GENCALL: General call header flag (Slave mode)
   1320            *            @arg I2C_FLAG_TRA: Transmitter/Receiver flag
   1321            *            @arg I2C_FLAG_BUSY: Bus busy flag
   1322            *            @arg I2C_FLAG_MSL: Master/Slave flag
   1323            *            @arg I2C_FLAG_SMBALERT: SMBus Alert flag
   1324            *            @arg I2C_FLAG_TIMEOUT: Timeout or Tlow error flag
   1325            *            @arg I2C_FLAG_PECERR: PEC error in reception flag
   1326            *            @arg I2C_FLAG_OVR: Overrun/Underrun flag (Slave mode)
   1327            *            @arg I2C_FLAG_AF: Acknowledge failure flag
   1328            *            @arg I2C_FLAG_ARLO: Arbitration lost flag (Master mode)
   1329            *            @arg I2C_FLAG_BERR: Bus error flag
   1330            *            @arg I2C_FLAG_TXE: Data register empty flag (Transmitter)
   1331            *            @arg I2C_FLAG_RXNE: Data register not empty (Receiver) flag
   1332            *            @arg I2C_FLAG_STOPF: Stop detection flag (Slave mode)
   1333            *            @arg I2C_FLAG_ADD10: 10-bit header sent flag (Master mode)
   1334            *            @arg I2C_FLAG_BTF: Byte transfer finished flag
   1335            *            @arg I2C_FLAG_ADDR: Address sent flag (Master mode) "ADSL"
   1336            *                                Address matched flag (Slave mode)"ENDAD"
   1337            *            @arg I2C_FLAG_SB: Start bit flag (Master mode)
   1338            * @retval The new state of I2C_FLAG (SET or RESET).
   1339            */
   1340          static FlagStatus I2C_GetFlagStatus(I2C_TypeDef* I2Cx, uint32_t I2C_FLAG)
                                   ^
Warning[Pe177]: function "I2C_GetFlagStatus" was declared but never referenced
   1341          {
   1342            FlagStatus bitstatus = RESET;
   1343            __IO uint32_t i2creg = 0, i2cxbase = 0;
   1344          
   1345          
   1346            /* Get the I2Cx peripheral base address */
   1347            i2cxbase = (uint32_t)I2Cx;
   1348            
   1349            /* Read flag register index */
   1350            i2creg = I2C_FLAG >> 28;
   1351            
   1352            /* Get bit[23:0] of the flag */
   1353            I2C_FLAG &= FLAG_MASK;
   1354            
   1355            if(i2creg != 0)
   1356            {
   1357              /* Get the I2Cx SR1 register address */
   1358              i2cxbase += 0x14;
   1359            }
   1360            else
   1361            {
   1362              /* Flag in I2Cx SR2 Register */
   1363              I2C_FLAG = (uint32_t)(I2C_FLAG >> 16);
   1364              /* Get the I2Cx SR2 register address */
   1365              i2cxbase += 0x18;
   1366            }
   1367            
   1368            if(((*(__IO uint32_t *)i2cxbase) & I2C_FLAG) != (uint32_t)RESET)
   1369            {
   1370              /* I2C_FLAG is set */
   1371              bitstatus = SET;
   1372            }
   1373            else
   1374            {
   1375              /* I2C_FLAG is reset */
   1376              bitstatus = RESET;
   1377            }
   1378            
   1379            /* Return the I2C_FLAG status */
   1380            return  bitstatus;
   1381          }
   1382          
   1383          /**
   1384            * @brief  Enables or disables the specified I2C acknowledge feature.
   1385            * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
   1386            * @param  NewState: new state of the I2C Acknowledgement.
   1387            *          This parameter can be: ENABLE or DISABLE.
   1388            * @retval None.
   1389            */
   1390          static void I2C_AcknowledgeConfig(I2C_TypeDef* I2Cx, FunctionalState NewState)
                             ^
Warning[Pe177]: function "I2C_AcknowledgeConfig" was declared but never
          referenced
   1391          {
   1392            if (NewState != DISABLE)
   1393            {
   1394              /* Enable the acknowledgement */
   1395              I2Cx->CR1 |= I2C_CR1_ACK;
   1396            }
   1397            else
   1398            {
   1399              /* Disable the acknowledgement */
   1400              I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_ACK);
   1401            }
   1402          }
   1403          
   1404          /**
   1405            * @brief  Returns the most recent received data by the I2Cx peripheral.
   1406            * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
   1407            * @retval The value of the received data.
   1408            */
   1409          static uint8_t I2C_ReceiveData(I2C_TypeDef* I2Cx)
                                ^
Warning[Pe177]: function "I2C_ReceiveData" was declared but never referenced
   1410          {
   1411            /* Return the data in the DR register */
   1412            return (uint8_t)I2Cx->RXDR;
   1413          }
   1414          
   1415          /**
   1416            * @brief  Clears the I2Cx's pending flags.
   1417            * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
   1418            * @param  I2C_FLAG: specifies the flag to clear. 
   1419            *          This parameter can be any combination of the following values:
   1420            *            @arg I2C_FLAG_SMBALERT: SMBus Alert flag
   1421            *            @arg I2C_FLAG_TIMEOUT: Timeout or Tlow error flag
   1422            *            @arg I2C_FLAG_PECERR: PEC error in reception flag
   1423            *            @arg I2C_FLAG_OVR: Overrun/Underrun flag (Slave mode)
   1424            *            @arg I2C_FLAG_AF: Acknowledge failure flag
   1425            *            @arg I2C_FLAG_ARLO: Arbitration lost flag (Master mode)
   1426            *            @arg I2C_FLAG_BERR: Bus error flag
   1427            *   
   1428            * @note   STOPF (STOP detection) is cleared by software sequence: a read operation 
   1429            *          to I2C_SR1 register (I2C_GetFlagStatus()) followed by a write operation 
   1430            *          to I2C_CR1 register (I2C_Cmd() to re-enable the I2C peripheral).
   1431            * @note   ADD10 (10-bit header sent) is cleared by software sequence: a read 
   1432            *          operation to I2C_SR1 (I2C_GetFlagStatus()) followed by writing the 
   1433            *          second byte of the address in DR register.
   1434            * @note   BTF (Byte Transfer Finished) is cleared by software sequence: a read 
   1435            *          operation to I2C_SR1 register (I2C_GetFlagStatus()) followed by a 
   1436            *          read/write to I2C_DR register (I2C_SendData()).
   1437            * @note   ADDR (Address sent) is cleared by software sequence: a read operation to 
   1438            *          I2C_SR1 register (I2C_GetFlagStatus()) followed by a read operation to 
   1439            *          I2C_SR2 register ((void)(I2Cx->SR2)).
   1440            * @note   SB (Start Bit) is cleared software sequence: a read operation to I2C_SR1
   1441            *          register (I2C_GetFlagStatus()) followed by a write operation to I2C_DR
   1442            *          register (I2C_SendData()).
   1443            *  
   1444            * @retval None
   1445            */
   1446          static void I2C_ClearFlag(I2C_TypeDef* I2Cx, uint32_t I2C_FLAG)
                             ^
Warning[Pe177]: function "I2C_ClearFlag" was declared but never referenced
   1447          {
   1448            uint32_t flagpos = 0;
   1449          
   1450            /* Get the I2C flag position */
   1451            flagpos = I2C_FLAG & FLAG_MASK;
   1452            /* Clear the selected I2C flag */
   1453            I2Cx->ISR = (uint16_t)~flagpos;
   1454          }
   1455          
   1456          /**
   1457            * @brief  Enables or disables the specified SPI peripheral (in I2S mode).
   1458            * @param  SPIx: where x can be 2 or 3 to select the SPI peripheral (or I2Sxext 
   1459            *         for full duplex mode).
   1460            * @param  NewState: new state of the SPIx peripheral. 
   1461            *         This parameter can be: ENABLE or DISABLE.
   1462            * @retval None
   1463            */

   \                                 In section .text, align 2, keep-with-next
   1464          static void I2S_Cmd(SPI_TypeDef* SPIx, FunctionalState NewState)
   1465          {  
   1466            if (NewState != DISABLE)
   \                     I2S_Cmd: (+1)
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xD004             BEQ.N    ??I2S_Cmd_0
   1467            {
   1468              /* Enable the selected SPI peripheral (in I2S mode) */
   1469              SPIx->I2SCFGR |= SPI_I2SCFGR_I2SE;
   \   00000006   0x69C2             LDR      R2,[R0, #+28]
   \   00000008   0xF452 0x6280      ORRS     R2,R2,#0x400
   \   0000000C   0x61C2             STR      R2,[R0, #+28]
   \   0000000E   0xE004             B.N      ??I2S_Cmd_1
   1470            }
   1471            else
   1472            {
   1473              /* Disable the selected SPI peripheral in I2S mode */
   1474              SPIx->I2SCFGR &= (uint16_t)~((uint16_t)SPI_I2SCFGR_I2SE);
   \                     ??I2S_Cmd_0: (+1)
   \   00000010   0x69C2             LDR      R2,[R0, #+28]
   \   00000012   0xF64F 0x33FF      MOVW     R3,#+64511
   \   00000016   0x401A             ANDS     R2,R3,R2
   \   00000018   0x61C2             STR      R2,[R0, #+28]
   1475            }
   1476          }
   \                     ??I2S_Cmd_1: (+1)
   \   0000001A   0x4770             BX       LR               ;; return
   1477          
   1478          /**
   1479            * @brief  Deinitialize the SPIx peripheral registers to their default reset values.
   1480            * @param  SPIx: To select the SPIx/I2Sx peripheral, where x can be: 1, 2 or 3 
   1481            *         in SPI mode or 2 or 3 in I2S mode.   
   1482            *         
   1483            * @note   The extended I2S blocks (ie. I2S2ext and I2S3ext blocks) are deinitialized
   1484            *         when the relative I2S peripheral is deinitialized (the extended block's clock
   1485            *         is managed by the I2S peripheral clock).
   1486            *             
   1487            * @retval None
   1488            */

   \                                 In section .text, align 2, keep-with-next
   1489          static void SPI_I2S_DeInit(SPI_TypeDef* SPIx)
   1490          {
   \                     SPI_I2S_DeInit: (+1)
   \   00000000   0xB081             SUB      SP,SP,#+4
   1491          
   1492            if (SPIx == SPI1)
   \   00000002   0x.... 0x....      LDR.W    R1,??DataTable23_27  ;; 0x40013000
   \   00000006   0x4288             CMP      R0,R1
   \   00000008   0xD117             BNE.N    ??SPI_I2S_DeInit_0
   1493            {
   1494              /* Enable SPI1 reset state */
   1495              //RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI1, ENABLE);
   1496              __HAL_RCC_SPI1_CLK_ENABLE();
   \   0000000A   0x.... 0x....      LDR.W    R1,??DataTable23_28  ;; 0x40023844
   \   0000000E   0x6809             LDR      R1,[R1, #+0]
   \   00000010   0xF451 0x5180      ORRS     R1,R1,#0x1000
   \   00000014   0x.... 0x....      LDR.W    R2,??DataTable23_28  ;; 0x40023844
   \   00000018   0x6011             STR      R1,[R2, #+0]
   \   0000001A   0x.... 0x....      LDR.W    R1,??DataTable23_28  ;; 0x40023844
   \   0000001E   0x6809             LDR      R1,[R1, #+0]
   \   00000020   0xF411 0x5180      ANDS     R1,R1,#0x1000
   \   00000024   0x9100             STR      R1,[SP, #+0]
   \   00000026   0x9900             LDR      R1,[SP, #+0]
   1497              /* Release SPI1 from reset state */
   1498              //RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI1, DISABLE);
   1499              __HAL_RCC_SPI1_CLK_DISABLE();
   \   00000028   0x.... 0x....      LDR.W    R1,??DataTable23_28  ;; 0x40023844
   \   0000002C   0x6809             LDR      R1,[R1, #+0]
   \   0000002E   0xF431 0x5180      BICS     R1,R1,#0x1000
   \   00000032   0x.... 0x....      LDR.W    R2,??DataTable23_28  ;; 0x40023844
   \   00000036   0x6011             STR      R1,[R2, #+0]
   \   00000038   0xE036             B.N      ??SPI_I2S_DeInit_1
   1500            }
   1501            else if (SPIx == SPI2)
   \                     ??SPI_I2S_DeInit_0: (+1)
   \   0000003A   0x.... 0x....      LDR.W    R1,??DataTable23_29  ;; 0x40003800
   \   0000003E   0x4288             CMP      R0,R1
   \   00000040   0xD117             BNE.N    ??SPI_I2S_DeInit_2
   1502            {
   1503              /* Enable SPI2 reset state */
   1504              //RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI2, ENABLE);
   1505              __HAL_RCC_SPI2_CLK_ENABLE();
   \   00000042   0x.... 0x....      LDR.W    R1,??DataTable23_19  ;; 0x40023840
   \   00000046   0x6809             LDR      R1,[R1, #+0]
   \   00000048   0xF451 0x4180      ORRS     R1,R1,#0x4000
   \   0000004C   0x.... 0x....      LDR.W    R2,??DataTable23_19  ;; 0x40023840
   \   00000050   0x6011             STR      R1,[R2, #+0]
   \   00000052   0x.... 0x....      LDR.W    R1,??DataTable23_19  ;; 0x40023840
   \   00000056   0x6809             LDR      R1,[R1, #+0]
   \   00000058   0xF411 0x4180      ANDS     R1,R1,#0x4000
   \   0000005C   0x9100             STR      R1,[SP, #+0]
   \   0000005E   0x9900             LDR      R1,[SP, #+0]
   1506              /* Release SPI2 from reset state */
   1507              //RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI2, DISABLE);
   1508              __HAL_RCC_SPI2_CLK_DISABLE();
   \   00000060   0x.... 0x....      LDR.W    R1,??DataTable23_19  ;; 0x40023840
   \   00000064   0x6809             LDR      R1,[R1, #+0]
   \   00000066   0xF431 0x4180      BICS     R1,R1,#0x4000
   \   0000006A   0x.... 0x....      LDR.W    R2,??DataTable23_19  ;; 0x40023840
   \   0000006E   0x6011             STR      R1,[R2, #+0]
   \   00000070   0xE01A             B.N      ??SPI_I2S_DeInit_1
   1509            }
   1510            else
   1511            {
   1512              if (SPIx == SPI3)
   \                     ??SPI_I2S_DeInit_2: (+1)
   \   00000072   0x.... 0x....      LDR.W    R1,??DataTable23_15  ;; 0x40003c00
   \   00000076   0x4288             CMP      R0,R1
   \   00000078   0xD116             BNE.N    ??SPI_I2S_DeInit_1
   1513              {
   1514                /* Enable SPI3 reset state */
   1515                //RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI3, ENABLE);
   1516                __HAL_RCC_SPI3_CLK_ENABLE();
   \   0000007A   0x.... 0x....      LDR.W    R1,??DataTable23_19  ;; 0x40023840
   \   0000007E   0x6809             LDR      R1,[R1, #+0]
   \   00000080   0xF451 0x4100      ORRS     R1,R1,#0x8000
   \   00000084   0x.... 0x....      LDR.W    R2,??DataTable23_19  ;; 0x40023840
   \   00000088   0x6011             STR      R1,[R2, #+0]
   \   0000008A   0x.... 0x....      LDR.W    R1,??DataTable23_19  ;; 0x40023840
   \   0000008E   0x6809             LDR      R1,[R1, #+0]
   \   00000090   0xF411 0x4100      ANDS     R1,R1,#0x8000
   \   00000094   0x9100             STR      R1,[SP, #+0]
   \   00000096   0x9900             LDR      R1,[SP, #+0]
   1517                /* Release SPI3 from reset state */
   1518                //RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI3, DISABLE);
   1519                __HAL_RCC_SPI3_CLK_DISABLE();
   \   00000098   0x.... 0x....      LDR.W    R1,??DataTable23_19  ;; 0x40023840
   \   0000009C   0x6809             LDR      R1,[R1, #+0]
   \   0000009E   0xF431 0x4100      BICS     R1,R1,#0x8000
   \   000000A2   0x.... 0x....      LDR.W    R2,??DataTable23_19  ;; 0x40023840
   \   000000A6   0x6011             STR      R1,[R2, #+0]
   1520              }
   1521            }
   1522          }
   \                     ??SPI_I2S_DeInit_1: (+1)
   \   000000A8   0xB001             ADD      SP,SP,#+4
   \   000000AA   0x4770             BX       LR               ;; return
   1523          
   1524          /**
   1525            * @brief  Enables or disables the specified DMAy Streamx.
   1526            * @param  DMAy_Streamx: where y can be 1 or 2 to select the DMA and x can be 0
   1527            *         to 7 to select the DMA Stream.
   1528            * @param  NewState: new state of the DMAy Streamx. 
   1529            *          This parameter can be: ENABLE or DISABLE.
   1530            *
   1531            * @note  This function may be used to perform Pause-Resume operation. When a
   1532            *        transfer is ongoing, calling this function to disable the Stream will
   1533            *        cause the transfer to be paused. All configuration registers and the
   1534            *        number of remaining data will be preserved. When calling again this
   1535            *        function to re-enable the Stream, the transfer will be resumed from
   1536            *        the point where it was paused.          
   1537            *    
   1538            * @note  After configuring the DMA Stream (DMA_Init() function) and enabling the
   1539            *        stream, it is recommended to check (or wait until) the DMA Stream is
   1540            *        effectively enabled. A Stream may remain disabled if a configuration 
   1541            *        parameter is wrong.
   1542            *        After disabling a DMA Stream, it is also recommended to check (or wait
   1543            *        until) the DMA Stream is effectively disabled. If a Stream is disabled 
   1544            *        while a data transfer is ongoing, the current data will be transferred
   1545            *        and the Stream will be effectively disabled only after the transfer of
   1546            *        this single data is finished.            
   1547            *    
   1548            * @retval None
   1549            */

   \                                 In section .text, align 2, keep-with-next
   1550          static void DMA_Cmd(DMA_Stream_TypeDef* DMAy_Streamx, FunctionalState NewState)
   1551          {
   1552          
   1553          
   1554            if (NewState != DISABLE)
   \                     DMA_Cmd: (+1)
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xD004             BEQ.N    ??DMA_Cmd_0
   1555            {
   1556              /* Enable the selected DMAy Streamx by setting EN bit */
   1557              DMAy_Streamx->CR |= (uint32_t)DMA_SxCR_EN;
   \   00000006   0x6802             LDR      R2,[R0, #+0]
   \   00000008   0xF052 0x0201      ORRS     R2,R2,#0x1
   \   0000000C   0x6002             STR      R2,[R0, #+0]
   \   0000000E   0xE003             B.N      ??DMA_Cmd_1
   1558            }
   1559            else
   1560            {
   1561              /* Disable the selected DMAy Streamx by clearing EN bit */
   1562              DMAy_Streamx->CR &= ~(uint32_t)DMA_SxCR_EN;
   \                     ??DMA_Cmd_0: (+1)
   \   00000010   0x6802             LDR      R2,[R0, #+0]
   \   00000012   0x0852             LSRS     R2,R2,#+1
   \   00000014   0x0052             LSLS     R2,R2,#+1
   \   00000016   0x6002             STR      R2,[R0, #+0]
   1563            }
   1564          }
   \                     ??DMA_Cmd_1: (+1)
   \   00000018   0x4770             BX       LR               ;; return
   1565          
   1566          /**
   1567            * @brief  Deinitialize the DMAy Streamx registers to their default reset values.
   1568            * @param  DMAy_Streamx: where y can be 1 or 2 to select the DMA and x can be 0
   1569            *         to 7 to select the DMA Stream.
   1570            * @retval None
   1571            */
   1572          static void DMA_DeInit(DMA_Stream_TypeDef* DMAy_Streamx)
                             ^
Warning[Pe177]: function "DMA_DeInit" was declared but never referenced

  static void     Audio_MAL_Init(void);
                  ^
"H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\Src\audio_codec.c",270  Warning[Pe177]: 
          function "Audio_MAL_Init" was declared but never referenced
   1573          {
   1574          
   1575            /* Disable the selected DMAy Streamx */
   1576            DMAy_Streamx->CR &= ~((uint32_t)DMA_SxCR_EN);
   1577          
   1578            /* Reset DMAy Streamx control register */
   1579            DMAy_Streamx->CR  = 0;
   1580            
   1581            /* Reset DMAy Streamx Number of Data to Transfer register */
   1582            DMAy_Streamx->NDTR = 0;
   1583            
   1584            /* Reset DMAy Streamx peripheral address register */
   1585            DMAy_Streamx->PAR  = 0;
   1586            
   1587            /* Reset DMAy Streamx memory 0 address register */
   1588            DMAy_Streamx->M0AR = 0;
   1589          
   1590            /* Reset DMAy Streamx memory 1 address register */
   1591            DMAy_Streamx->M1AR = 0;
   1592          
   1593            /* Reset DMAy Streamx FIFO control register */
   1594            DMAy_Streamx->FCR = (uint32_t)0x00000021; 
   1595          
   1596           }
   1597          
   1598          /**
   1599            * @brief  Enables or disables the SPIx/I2Sx DMA interface.
   1600            * @param  SPIx: To select the SPIx/I2Sx peripheral, where x can be: 1, 2 or 3 
   1601            *         in SPI mode or 2 or 3 in I2S mode or I2Sxext for I2S full duplex mode. 
   1602            * @param  SPI_I2S_DMAReq: specifies the SPI DMA transfer request to be enabled or disabled. 
   1603            *          This parameter can be any combination of the following values:
   1604            *            @arg SPI_I2S_DMAReq_Tx: Tx buffer DMA transfer request
   1605            *            @arg SPI_I2S_DMAReq_Rx: Rx buffer DMA transfer request
   1606            * @param  NewState: new state of the selected SPI DMA transfer request.
   1607            *          This parameter can be: ENABLE or DISABLE.
   1608            * @retval None
   1609            */

   \                                 In section .text, align 2, keep-with-next
   1610          static void SPI_I2S_DMACmd(SPI_TypeDef* SPIx, uint16_t SPI_I2S_DMAReq, FunctionalState NewState)
   1611          {
   \                     SPI_I2S_DMACmd: (+1)
   \   00000000   0xB410             PUSH     {R4}
   1612            /* Check the parameters */
   1613            assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
   1614            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1615            assert_param(IS_SPI_I2S_DMAREQ(SPI_I2S_DMAReq));
   1616          
   1617            if (NewState != DISABLE)
   \   00000002   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000004   0x2A00             CMP      R2,#+0
   \   00000006   0xD004             BEQ.N    ??SPI_I2S_DMACmd_0
   1618            {
   1619              /* Enable the selected SPI DMA requests */
   1620              SPIx->CR2 |= SPI_I2S_DMAReq;
   \   00000008   0x6843             LDR      R3,[R0, #+4]
   \   0000000A   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000000C   0x430B             ORRS     R3,R1,R3
   \   0000000E   0x6043             STR      R3,[R0, #+4]
   \   00000010   0xE004             B.N      ??SPI_I2S_DMACmd_1
   1621            }
   1622            else
   1623            {
   1624              /* Disable the selected SPI DMA requests */
   1625              SPIx->CR2 &= (uint16_t)~SPI_I2S_DMAReq;
   \                     ??SPI_I2S_DMACmd_0: (+1)
   \   00000012   0x6843             LDR      R3,[R0, #+4]
   \   00000014   0x43CC             MVNS     R4,R1
   \   00000016   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000018   0x4023             ANDS     R3,R4,R3
   \   0000001A   0x6043             STR      R3,[R0, #+4]
   1626            }
   1627          }
   \                     ??SPI_I2S_DMACmd_1: (+1)
   \   0000001C   0xBC10             POP      {R4}
   \   0000001E   0x4770             BX       LR               ;; return
   1628          

   \                                 In section .text, align 2, keep-with-next
   1629          static void DMA_ClearFlag(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t DMA_FLAG)
   1630          {
   1631          
   1632            
   1633          }
   \                     DMA_ClearFlag: (+1)
   \   00000000   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   1634          void HAL_I2S_MspInit(I2S_HandleTypeDef *hi2s)
   1635          {
   \                     HAL_I2S_MspInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB08C             SUB      SP,SP,#+48
   \   00000004   0x0004             MOVS     R4,R0
   1636             GPIO_InitTypeDef GPIO_InitStructure;
   1637          	
   1638             
   1639             GPIO_InitTypeDef GPIO_InitStruct;
   1640            if(hi2s->Instance==SPI1)
   \   00000006   0x6820             LDR      R0,[R4, #+0]
   \   00000008   0x.... 0x....      LDR.W    R1,??DataTable23_27  ;; 0x40013000
   \   0000000C   0x4288             CMP      R0,R1
   \   0000000E   0xD125             BNE.N    ??HAL_I2S_MspInit_0
   1641            {
   1642            /* USER CODE BEGIN SPI1_MspInit 0 */
   1643          
   1644            /* USER CODE END SPI1_MspInit 0 */
   1645              /* Peripheral clock enable */
   1646              __SPI1_CLK_ENABLE();
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable23_28  ;; 0x40023844
   \   00000014   0x6800             LDR      R0,[R0, #+0]
   \   00000016   0xF450 0x5080      ORRS     R0,R0,#0x1000
   \   0000001A   0x.... 0x....      LDR.W    R1,??DataTable23_28  ;; 0x40023844
   \   0000001E   0x6008             STR      R0,[R1, #+0]
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable23_28  ;; 0x40023844
   \   00000024   0x6800             LDR      R0,[R0, #+0]
   \   00000026   0xF410 0x5080      ANDS     R0,R0,#0x1000
   \   0000002A   0x9000             STR      R0,[SP, #+0]
   \   0000002C   0x9800             LDR      R0,[SP, #+0]
   1647            
   1648              /**I2S1 GPIO Configuration    
   1649              PA4     ------> I2S1_WS
   1650              PA5     ------> I2S1_CK
   1651              PA7     ------> I2S1_SD 
   1652              */
   1653              GPIO_InitStruct.Pin = GPIO_PIN_4|GPIO_PIN_5|GPIO_PIN_7;
   \   0000002E   0x20B0             MOVS     R0,#+176
   \   00000030   0x9001             STR      R0,[SP, #+4]
   1654              GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
   \   00000032   0x2002             MOVS     R0,#+2
   \   00000034   0x9002             STR      R0,[SP, #+8]
   1655              GPIO_InitStruct.Pull = GPIO_NOPULL;
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0x9003             STR      R0,[SP, #+12]
   1656              GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
   \   0000003A   0x2003             MOVS     R0,#+3
   \   0000003C   0x9004             STR      R0,[SP, #+16]
   1657              GPIO_InitStruct.Alternate = GPIO_AF5_SPI1;
   \   0000003E   0x2005             MOVS     R0,#+5
   \   00000040   0x9005             STR      R0,[SP, #+20]
   1658              HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
   \   00000042   0xA901             ADD      R1,SP,#+4
   \   00000044   0x....             LDR.N    R0,??DataTable23_23  ;; 0x40020000
   \   00000046   0x.... 0x....      BL       HAL_GPIO_Init
   1659          
   1660            /* Peripheral interrupt init*/
   1661              HAL_NVIC_SetPriority(SPI1_IRQn, 1, 1);
   \   0000004A   0x2201             MOVS     R2,#+1
   \   0000004C   0x2101             MOVS     R1,#+1
   \   0000004E   0x2023             MOVS     R0,#+35
   \   00000050   0x.... 0x....      BL       HAL_NVIC_SetPriority
   1662              HAL_NVIC_EnableIRQ(SPI1_IRQn);
   \   00000054   0x2023             MOVS     R0,#+35
   \   00000056   0x.... 0x....      BL       HAL_NVIC_EnableIRQ
   \   0000005A   0xE122             B.N      ??HAL_I2S_MspInit_1
   1663            /* USER CODE BEGIN SPI1_MspInit 1 */
   1664          
   1665            /* USER CODE END SPI1_MspInit 1 */
   1666            }
   1667            else if(hi2s->Instance==SPI2)
   \                     ??HAL_I2S_MspInit_0: (+1)
   \   0000005C   0x6820             LDR      R0,[R4, #+0]
   \   0000005E   0x....             LDR.N    R1,??DataTable23_29  ;; 0x40003800
   \   00000060   0x4288             CMP      R0,R1
   \   00000062   0xD169             BNE.N    ??HAL_I2S_MspInit_2
   1668            {
   1669            /* USER CODE BEGIN SPI2_MspInit 0 */
   1670          
   1671            /* USER CODE END SPI2_MspInit 0 */
   1672              /* Peripheral clock enable */
   1673              __SPI2_CLK_ENABLE();
   \   00000064   0x....             LDR.N    R0,??DataTable23_19  ;; 0x40023840
   \   00000066   0x6800             LDR      R0,[R0, #+0]
   \   00000068   0xF450 0x4080      ORRS     R0,R0,#0x4000
   \   0000006C   0x....             LDR.N    R1,??DataTable23_19  ;; 0x40023840
   \   0000006E   0x6008             STR      R0,[R1, #+0]
   \   00000070   0x....             LDR.N    R0,??DataTable23_19  ;; 0x40023840
   \   00000072   0x6800             LDR      R0,[R0, #+0]
   \   00000074   0xF410 0x4080      ANDS     R0,R0,#0x4000
   \   00000078   0x9000             STR      R0,[SP, #+0]
   \   0000007A   0x9800             LDR      R0,[SP, #+0]
   1674              __GPIOI_CLK_ENABLE();
   \   0000007C   0x....             LDR.N    R0,??DataTable23_21  ;; 0x40023830
   \   0000007E   0x6800             LDR      R0,[R0, #+0]
   \   00000080   0xF450 0x7080      ORRS     R0,R0,#0x100
   \   00000084   0x....             LDR.N    R1,??DataTable23_21  ;; 0x40023830
   \   00000086   0x6008             STR      R0,[R1, #+0]
   \   00000088   0x....             LDR.N    R0,??DataTable23_21  ;; 0x40023830
   \   0000008A   0x6800             LDR      R0,[R0, #+0]
   \   0000008C   0xF410 0x7080      ANDS     R0,R0,#0x100
   \   00000090   0x9000             STR      R0,[SP, #+0]
   \   00000092   0x9800             LDR      R0,[SP, #+0]
   1675          	__GPIOB_CLK_ENABLE();
   \   00000094   0x....             LDR.N    R0,??DataTable23_21  ;; 0x40023830
   \   00000096   0x6800             LDR      R0,[R0, #+0]
   \   00000098   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   0000009C   0x....             LDR.N    R1,??DataTable23_21  ;; 0x40023830
   \   0000009E   0x6008             STR      R0,[R1, #+0]
   \   000000A0   0x....             LDR.N    R0,??DataTable23_21  ;; 0x40023830
   \   000000A2   0x6800             LDR      R0,[R0, #+0]
   \   000000A4   0xF010 0x0002      ANDS     R0,R0,#0x2
   \   000000A8   0x9000             STR      R0,[SP, #+0]
   \   000000AA   0x9800             LDR      R0,[SP, #+0]
   1676          	__GPIOC_CLK_ENABLE();
   \   000000AC   0x....             LDR.N    R0,??DataTable23_21  ;; 0x40023830
   \   000000AE   0x6800             LDR      R0,[R0, #+0]
   \   000000B0   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   000000B4   0x....             LDR.N    R1,??DataTable23_21  ;; 0x40023830
   \   000000B6   0x6008             STR      R0,[R1, #+0]
   \   000000B8   0x....             LDR.N    R0,??DataTable23_21  ;; 0x40023830
   \   000000BA   0x6800             LDR      R0,[R0, #+0]
   \   000000BC   0xF010 0x0004      ANDS     R0,R0,#0x4
   \   000000C0   0x9000             STR      R0,[SP, #+0]
   \   000000C2   0x9800             LDR      R0,[SP, #+0]
   1677            
   1678              /**I2S2 GPIO Configuration     
   1679              PC1     ------> I2S2_SD  : PI3 PC1 PC3 PB15      --> PB15
   1680              PB10     ------> I2S2_CK :PD3 PB10 PB13 PA9 PI1  --> PI1
   1681              PB12     ------> I2S2_WS : PB12 PI0 PB4 PB9      --> PB4
   1682          
   1683              */
   1684              GPIO_InitStruct.Pin = GPIO_PIN_15; //SD
   \   000000C4   0xF44F 0x4000      MOV      R0,#+32768
   \   000000C8   0x9001             STR      R0,[SP, #+4]
   1685              GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
   \   000000CA   0x2002             MOVS     R0,#+2
   \   000000CC   0x9002             STR      R0,[SP, #+8]
   1686              GPIO_InitStruct.Pull = GPIO_NOPULL;
   \   000000CE   0x2000             MOVS     R0,#+0
   \   000000D0   0x9003             STR      R0,[SP, #+12]
   1687              GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
   \   000000D2   0x2003             MOVS     R0,#+3
   \   000000D4   0x9004             STR      R0,[SP, #+16]
   1688              GPIO_InitStruct.Alternate = GPIO_AF5_SPI2;
   \   000000D6   0x2005             MOVS     R0,#+5
   \   000000D8   0x9005             STR      R0,[SP, #+20]
   1689              HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
   \   000000DA   0xA901             ADD      R1,SP,#+4
   \   000000DC   0x....             LDR.N    R0,??DataTable23_22  ;; 0x40020400
   \   000000DE   0x.... 0x....      BL       HAL_GPIO_Init
   1690          
   1691          	GPIO_InitStruct.Pin = GPIO_PIN_4;//WS
   \   000000E2   0x2010             MOVS     R0,#+16
   \   000000E4   0x9001             STR      R0,[SP, #+4]
   1692              GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
   \   000000E6   0x2002             MOVS     R0,#+2
   \   000000E8   0x9002             STR      R0,[SP, #+8]
   1693              GPIO_InitStruct.Pull = GPIO_NOPULL;
   \   000000EA   0x2000             MOVS     R0,#+0
   \   000000EC   0x9003             STR      R0,[SP, #+12]
   1694              GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
   \   000000EE   0x2003             MOVS     R0,#+3
   \   000000F0   0x9004             STR      R0,[SP, #+16]
   1695              GPIO_InitStruct.Alternate = GPIO_AF5_SPI2;
   \   000000F2   0x2005             MOVS     R0,#+5
   \   000000F4   0x9005             STR      R0,[SP, #+20]
   1696              HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
   \   000000F6   0xA901             ADD      R1,SP,#+4
   \   000000F8   0x....             LDR.N    R0,??DataTable23_22  ;; 0x40020400
   \   000000FA   0x.... 0x....      BL       HAL_GPIO_Init
   1697          
   1698              GPIO_InitStruct.Pin = GPIO_PIN_1;//CK
   \   000000FE   0x2002             MOVS     R0,#+2
   \   00000100   0x9001             STR      R0,[SP, #+4]
   1699              GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
   \   00000102   0x2002             MOVS     R0,#+2
   \   00000104   0x9002             STR      R0,[SP, #+8]
   1700              GPIO_InitStruct.Pull = GPIO_NOPULL;
   \   00000106   0x2000             MOVS     R0,#+0
   \   00000108   0x9003             STR      R0,[SP, #+12]
   1701              GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
   \   0000010A   0x2003             MOVS     R0,#+3
   \   0000010C   0x9004             STR      R0,[SP, #+16]
   1702              GPIO_InitStruct.Alternate = GPIO_AF5_SPI2;
   \   0000010E   0x2005             MOVS     R0,#+5
   \   00000110   0x9005             STR      R0,[SP, #+20]
   1703              HAL_GPIO_Init(GPIOI, &GPIO_InitStruct);
   \   00000112   0xA901             ADD      R1,SP,#+4
   \   00000114   0x....             LDR.N    R0,??DataTable23_30  ;; 0x40022000
   \   00000116   0x.... 0x....      BL       HAL_GPIO_Init
   1704          
   1705              GPIO_InitStruct.Pin = GPIO_PIN_6;//CK
   \   0000011A   0x2040             MOVS     R0,#+64
   \   0000011C   0x9001             STR      R0,[SP, #+4]
   1706              GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
   \   0000011E   0x2002             MOVS     R0,#+2
   \   00000120   0x9002             STR      R0,[SP, #+8]
   1707              GPIO_InitStruct.Pull = GPIO_NOPULL;
   \   00000122   0x2000             MOVS     R0,#+0
   \   00000124   0x9003             STR      R0,[SP, #+12]
   1708              GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
   \   00000126   0x2003             MOVS     R0,#+3
   \   00000128   0x9004             STR      R0,[SP, #+16]
   1709              GPIO_InitStruct.Alternate = GPIO_AF5_SPI2;
   \   0000012A   0x2005             MOVS     R0,#+5
   \   0000012C   0x9005             STR      R0,[SP, #+20]
   1710              HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
   \   0000012E   0xA901             ADD      R1,SP,#+4
   \   00000130   0x....             LDR.N    R0,??DataTable23_24  ;; 0x40020800
   \   00000132   0x.... 0x....      BL       HAL_GPIO_Init
   \   00000136   0xE0B4             B.N      ??HAL_I2S_MspInit_1
   1711          
   1712          
   1713          
   1714              /* Peripheral interrupt init*/
   1715              //HAL_NVIC_SetPriority(SPI2_IRQn, 6, 0);
   1716              //HAL_NVIC_EnableIRQ(SPI2_IRQn);
   1717              /* USER CODE BEGIN SPI2_MspInit 1 */
   1718          
   1719            /* USER CODE END SPI2_MspInit 1 */
   1720            }
   1721            else if(hi2s->Instance==SPI3)
   \                     ??HAL_I2S_MspInit_2: (+1)
   \   00000138   0x6820             LDR      R0,[R4, #+0]
   \   0000013A   0x....             LDR.N    R1,??DataTable23_15  ;; 0x40003c00
   \   0000013C   0x4288             CMP      R0,R1
   \   0000013E   0xF040 0x80B0      BNE.W    ??HAL_I2S_MspInit_1
   1722            {
   1723          
   1724          
   1725            
   1726              /**I2S3 GPIO Configuration    
   1727              PB2     ------> I2S3_SD
   1728              PA15     ------> I2S3_WS
   1729              PB3     ------> I2S3_CK 
   1730          	 PC7    ------> MCLK
   1731              */
   1732           
   1733            /* USER CODE BEGIN SPI3_MspInit 1 */
   1734            __SPI3_CLK_ENABLE();
   \   00000142   0x....             LDR.N    R0,??DataTable23_19  ;; 0x40023840
   \   00000144   0x6800             LDR      R0,[R0, #+0]
   \   00000146   0xF450 0x4000      ORRS     R0,R0,#0x8000
   \   0000014A   0x....             LDR.N    R1,??DataTable23_19  ;; 0x40023840
   \   0000014C   0x6008             STR      R0,[R1, #+0]
   \   0000014E   0x....             LDR.N    R0,??DataTable23_19  ;; 0x40023840
   \   00000150   0x6800             LDR      R0,[R0, #+0]
   \   00000152   0xF410 0x4000      ANDS     R0,R0,#0x8000
   \   00000156   0x9000             STR      R0,[SP, #+0]
   \   00000158   0x9800             LDR      R0,[SP, #+0]
   1735            __GPIOA_CLK_ENABLE();
   \   0000015A   0x....             LDR.N    R0,??DataTable23_21  ;; 0x40023830
   \   0000015C   0x6800             LDR      R0,[R0, #+0]
   \   0000015E   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000162   0x....             LDR.N    R1,??DataTable23_21  ;; 0x40023830
   \   00000164   0x6008             STR      R0,[R1, #+0]
   \   00000166   0x....             LDR.N    R0,??DataTable23_21  ;; 0x40023830
   \   00000168   0x6800             LDR      R0,[R0, #+0]
   \   0000016A   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   0000016E   0x9000             STR      R0,[SP, #+0]
   \   00000170   0x9800             LDR      R0,[SP, #+0]
   1736            __GPIOB_CLK_ENABLE();
   \   00000172   0x....             LDR.N    R0,??DataTable23_21  ;; 0x40023830
   \   00000174   0x6800             LDR      R0,[R0, #+0]
   \   00000176   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   0000017A   0x....             LDR.N    R1,??DataTable23_21  ;; 0x40023830
   \   0000017C   0x6008             STR      R0,[R1, #+0]
   \   0000017E   0x....             LDR.N    R0,??DataTable23_21  ;; 0x40023830
   \   00000180   0x6800             LDR      R0,[R0, #+0]
   \   00000182   0xF010 0x0002      ANDS     R0,R0,#0x2
   \   00000186   0x9000             STR      R0,[SP, #+0]
   \   00000188   0x9800             LDR      R0,[SP, #+0]
   1737            __GPIOC_CLK_ENABLE();
   \   0000018A   0x....             LDR.N    R0,??DataTable23_21  ;; 0x40023830
   \   0000018C   0x6800             LDR      R0,[R0, #+0]
   \   0000018E   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   00000192   0x....             LDR.N    R1,??DataTable23_21  ;; 0x40023830
   \   00000194   0x6008             STR      R0,[R1, #+0]
   \   00000196   0x....             LDR.N    R0,??DataTable23_21  ;; 0x40023830
   \   00000198   0x6800             LDR      R0,[R0, #+0]
   \   0000019A   0xF010 0x0004      ANDS     R0,R0,#0x4
   \   0000019E   0x9000             STR      R0,[SP, #+0]
   \   000001A0   0x9800             LDR      R0,[SP, #+0]
   1738            GPIO_InitStructure.Pin = GPIO_PIN_3 | GPIO_PIN_2; 
   \   000001A2   0x200C             MOVS     R0,#+12
   \   000001A4   0x9006             STR      R0,[SP, #+24]
   1739            GPIO_InitStructure.Mode = GPIO_MODE_AF_PP;
   \   000001A6   0x2002             MOVS     R0,#+2
   \   000001A8   0x9007             STR      R0,[SP, #+28]
   1740            GPIO_InitStructure.Speed = GPIO_SPEED_HIGH;
   \   000001AA   0x2003             MOVS     R0,#+3
   \   000001AC   0x9009             STR      R0,[SP, #+36]
   1741            GPIO_InitStructure.Pull = GPIO_NOPULL;
   \   000001AE   0x2000             MOVS     R0,#+0
   \   000001B0   0x9008             STR      R0,[SP, #+32]
   1742            GPIO_InitStructure.Alternate = GPIO_AF6_SPI3;
   \   000001B2   0x2006             MOVS     R0,#+6
   \   000001B4   0x900A             STR      R0,[SP, #+40]
   1743            HAL_GPIO_Init(GPIOB, &GPIO_InitStructure);
   \   000001B6   0xA906             ADD      R1,SP,#+24
   \   000001B8   0x....             LDR.N    R0,??DataTable23_22  ;; 0x40020400
   \   000001BA   0x.... 0x....      BL       HAL_GPIO_Init
   1744          
   1745          
   1746            GPIO_InitStructure.Pin = GPIO_PIN_15;
   \   000001BE   0xF44F 0x4000      MOV      R0,#+32768
   \   000001C2   0x9006             STR      R0,[SP, #+24]
   1747            GPIO_InitStructure.Mode = GPIO_MODE_AF_PP;
   \   000001C4   0x2002             MOVS     R0,#+2
   \   000001C6   0x9007             STR      R0,[SP, #+28]
   1748            GPIO_InitStructure.Alternate = GPIO_AF6_SPI3;
   \   000001C8   0x2006             MOVS     R0,#+6
   \   000001CA   0x900A             STR      R0,[SP, #+40]
   1749            HAL_GPIO_Init(GPIOA, &GPIO_InitStructure);
   \   000001CC   0xA906             ADD      R1,SP,#+24
   \   000001CE   0x....             LDR.N    R0,??DataTable23_23  ;; 0x40020000
   \   000001D0   0x.... 0x....      BL       HAL_GPIO_Init
   1750          
   1751          #ifdef CODEC_MCLK_ENABLED
   1752          
   1753            GPIO_InitStructure.Pin = GPIO_PIN_7; 
   \   000001D4   0x2080             MOVS     R0,#+128
   \   000001D6   0x9006             STR      R0,[SP, #+24]
   1754            GPIO_InitStructure.Mode = GPIO_MODE_AF_PP;
   \   000001D8   0x2002             MOVS     R0,#+2
   \   000001DA   0x9007             STR      R0,[SP, #+28]
   1755            GPIO_InitStructure.Speed = GPIO_SPEED_HIGH;
   \   000001DC   0x2003             MOVS     R0,#+3
   \   000001DE   0x9009             STR      R0,[SP, #+36]
   1756            GPIO_InitStructure.Pull = GPIO_NOPULL;
   \   000001E0   0x2000             MOVS     R0,#+0
   \   000001E2   0x9008             STR      R0,[SP, #+32]
   1757            GPIO_InitStructure.Alternate = GPIO_AF6_SPI3;
   \   000001E4   0x2006             MOVS     R0,#+6
   \   000001E6   0x900A             STR      R0,[SP, #+40]
   1758            HAL_GPIO_Init(GPIOC, &GPIO_InitStructure);
   \   000001E8   0xA906             ADD      R1,SP,#+24
   \   000001EA   0x....             LDR.N    R0,??DataTable23_24  ;; 0x40020800
   \   000001EC   0x.... 0x....      BL       HAL_GPIO_Init
   1759          
   1760          #endif /* CODEC_MCLK_ENABLED */ 
   1761          
   1762          #ifdef I2S_INTERRUPT   
   1763               /* Enable and set Button EXTI Interrupt to the lowest priority */
   1764               //HAL_NVIC_SetPriority((IRQn_Type)SPI3_IRQn, 0x00, 0x01);
   1765               //HAL_NVIC_EnableIRQ((IRQn_Type)SPI3_IRQn);
   1766          
   1767               /* Enable the I2S DMA request */
   1768               //__HAL_I2S_ENABLE_IT(&hi2s3, SPI_I2S_DMAReq_Tx);
   1769               //__HAL_I2S_ENABLE(&hi2s3);
   1770            	    /* Peripheral interrupt init*/
   1771          		HAL_NVIC_SetPriority(SPI3_IRQn, 2, 0);
   1772          		HAL_NVIC_EnableIRQ(SPI3_IRQn);
   1773          #endif
   1774          
   1775                /* Enable the DMA clock */ 
   1776          	  __HAL_RCC_DMA1_CLK_ENABLE();
   \   000001F0   0x....             LDR.N    R0,??DataTable23_21  ;; 0x40023830
   \   000001F2   0x6800             LDR      R0,[R0, #+0]
   \   000001F4   0xF450 0x1000      ORRS     R0,R0,#0x200000
   \   000001F8   0x....             LDR.N    R1,??DataTable23_21  ;; 0x40023830
   \   000001FA   0x6008             STR      R0,[R1, #+0]
   \   000001FC   0x....             LDR.N    R0,??DataTable23_21  ;; 0x40023830
   \   000001FE   0x6800             LDR      R0,[R0, #+0]
   \   00000200   0xF410 0x1000      ANDS     R0,R0,#0x200000
   \   00000204   0x9000             STR      R0,[SP, #+0]
   \   00000206   0x9800             LDR      R0,[SP, #+0]
   1777          
   1778                /* Configure the DMA Stream */
   1779                HAL_DMA_DeInit(&DmaHandle);
   \   00000208   0x....             LDR.N    R0,??DataTable23_2
   \   0000020A   0x.... 0x....      BL       HAL_DMA_DeInit
   1780          
   1781                /* Set the parameters to be configured */ 
   1782          	  DmaHandle.Instance = DMA1_Stream7;
   \   0000020E   0x....             LDR.N    R0,??DataTable23_25  ;; 0x400260b8
   \   00000210   0x....             LDR.N    R1,??DataTable23_2
   \   00000212   0x6008             STR      R0,[R1, #+0]
   1783                DmaHandle.Init.Channel = DMA_CHANNEL_0;
   \   00000214   0x2000             MOVS     R0,#+0
   \   00000216   0x....             LDR.N    R1,??DataTable23_2
   \   00000218   0x6048             STR      R0,[R1, #+4]
   1784          	  DmaHandle.Init.Direction = DMA_MEMORY_TO_PERIPH;
   \   0000021A   0x2040             MOVS     R0,#+64
   \   0000021C   0x....             LDR.N    R1,??DataTable23_2
   \   0000021E   0x6088             STR      R0,[R1, #+8]
   1785          	  DmaHandle.Init.PeriphInc = DMA_PINC_DISABLE;
   \   00000220   0x2000             MOVS     R0,#+0
   \   00000222   0x....             LDR.N    R1,??DataTable23_2
   \   00000224   0x60C8             STR      R0,[R1, #+12]
   1786          	  DmaHandle.Init.MemInc = DMA_MINC_ENABLE;
   \   00000226   0xF44F 0x6080      MOV      R0,#+1024
   \   0000022A   0x....             LDR.N    R1,??DataTable23_2
   \   0000022C   0x6108             STR      R0,[R1, #+16]
   1787          	  DmaHandle.Init.PeriphDataAlignment = DMA_PDATAALIGN_HALFWORD;
   \   0000022E   0xF44F 0x6000      MOV      R0,#+2048
   \   00000232   0x....             LDR.N    R1,??DataTable23_2
   \   00000234   0x6148             STR      R0,[R1, #+20]
   1788                DmaHandle.Init.MemDataAlignment = DMA_MDATAALIGN_HALFWORD; 
   \   00000236   0xF44F 0x5000      MOV      R0,#+8192
   \   0000023A   0x....             LDR.N    R1,??DataTable23_2
   \   0000023C   0x6188             STR      R0,[R1, #+24]
   1789          	  DmaHandle.Init.Mode = DMA_NORMAL;
   \   0000023E   0x2000             MOVS     R0,#+0
   \   00000240   0x....             LDR.N    R1,??DataTable23_2
   \   00000242   0x61C8             STR      R0,[R1, #+28]
   1790                DmaHandle.Init.Priority = DMA_PRIORITY_HIGH; 
   \   00000244   0xF45F 0x3000      MOVS     R0,#+131072
   \   00000248   0x....             LDR.N    R1,??DataTable23_2
   \   0000024A   0x6208             STR      R0,[R1, #+32]
   1791          	  DmaHandle.Init.FIFOMode = DMA_FIFOMODE_DISABLE;
   \   0000024C   0x2000             MOVS     R0,#+0
   \   0000024E   0x....             LDR.N    R1,??DataTable23_2
   \   00000250   0x6248             STR      R0,[R1, #+36]
   1792                DmaHandle.Init.FIFOThreshold = DMA_FIFO_THRESHOLD_1QUARTERFULL;
   \   00000252   0x2000             MOVS     R0,#+0
   \   00000254   0x....             LDR.N    R1,??DataTable23_2
   \   00000256   0x6288             STR      R0,[R1, #+40]
   1793                DmaHandle.Init.MemBurst = DMA_MBURST_SINGLE;
   \   00000258   0x2000             MOVS     R0,#+0
   \   0000025A   0x....             LDR.N    R1,??DataTable23_2
   \   0000025C   0x62C8             STR      R0,[R1, #+44]
   1794                DmaHandle.Init.PeriphBurst = DMA_PBURST_SINGLE;	  
   \   0000025E   0x2000             MOVS     R0,#+0
   \   00000260   0x....             LDR.N    R1,??DataTable23_2
   \   00000262   0x6308             STR      R0,[R1, #+48]
   1795                DmaHandle.Instance->PAR = CODEC_I2S_ADDRESS;
   \   00000264   0x....             LDR.N    R0,??DataTable23_31  ;; 0x40003c0c
   \   00000266   0x....             LDR.N    R1,??DataTable23_2
   \   00000268   0x6809             LDR      R1,[R1, #+0]
   \   0000026A   0x6088             STR      R0,[R1, #+8]
   1796                DmaHandle.Instance->M0AR = (uint32_t)0;
   \   0000026C   0x2000             MOVS     R0,#+0
   \   0000026E   0x....             LDR.N    R1,??DataTable23_2
   \   00000270   0x6809             LDR      R1,[R1, #+0]
   \   00000272   0x60C8             STR      R0,[R1, #+12]
   1797                DmaHandle.Instance->NDTR = (uint32_t)0xFFFE;
   \   00000274   0xF64F 0x70FE      MOVW     R0,#+65534
   \   00000278   0x....             LDR.N    R1,??DataTable23_2
   \   0000027A   0x6809             LDR      R1,[R1, #+0]
   \   0000027C   0x6048             STR      R0,[R1, #+4]
   1798                //DmaHandle.XferCpltCallback = &TC_Callback;
   1799           
   1800          
   1801                /* Associate the initialized DMA handle to the the SPI handle */
   1802                __HAL_LINKDMA(hi2s, hdmatx, DmaHandle);
   \   0000027E   0x....             LDR.N    R0,??DataTable23_2
   \   00000280   0x6320             STR      R0,[R4, #+48]
   \   00000282   0x....             LDR.N    R0,??DataTable23_2
   \   00000284   0x6384             STR      R4,[R0, #+56]
   1803                //__HAL_DMA_ENABLE_IT(&DmaHandle, DMA_IT_TC);
   1804          
   1805          	   /* Deinitialize the Stream for new transfer */
   1806                 HAL_DMA_DeInit(&DmaHandle);
   \   00000286   0x....             LDR.N    R0,??DataTable23_2
   \   00000288   0x.... 0x....      BL       HAL_DMA_DeInit
   1807                 /* Configure the DMA Stream */
   1808          	   HAL_DMA_Init(&DmaHandle);
   \   0000028C   0x....             LDR.N    R0,??DataTable23_2
   \   0000028E   0x.... 0x....      BL       HAL_DMA_Init
   1809          
   1810                /* Set Interrupt Group Priority */
   1811                HAL_NVIC_SetPriority(DMA1_Stream7_IRQn, 2, 1);
   \   00000292   0x2201             MOVS     R2,#+1
   \   00000294   0x2102             MOVS     R1,#+2
   \   00000296   0x202F             MOVS     R0,#+47
   \   00000298   0x.... 0x....      BL       HAL_NVIC_SetPriority
   1812                /* Enable the DMA STREAM global Interrupt */
   1813                HAL_NVIC_EnableIRQ(DMA1_Stream7_IRQn);    
   \   0000029C   0x202F             MOVS     R0,#+47
   \   0000029E   0x.... 0x....      BL       HAL_NVIC_EnableIRQ
   1814          	  
   1815           }
   1816          
   1817          }
   \                     ??HAL_I2S_MspInit_1: (+1)
   \   000002A2   0xB00C             ADD      SP,SP,#+48
   \   000002A4   0xBD10             POP      {R4,PC}          ;; return
   1818          

   \                                 In section .text, align 2, keep-with-next
   1819          void HAL_SPI_MspDeInit(SPI_HandleTypeDef *hspi)
   1820          {
   \                     HAL_SPI_MspDeInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1821            if(hspi->Instance == SPI3)
   \   00000004   0x6820             LDR      R0,[R4, #+0]
   \   00000006   0x....             LDR.N    R1,??DataTable23_15  ;; 0x40003c00
   \   00000008   0x4288             CMP      R0,R1
   \   0000000A   0xD122             BNE.N    ??HAL_SPI_MspDeInit_0
   1822            {   
   1823              /*##-1- Reset peripherals ##################################################*/
   1824              __HAL_RCC_SPI2_FORCE_RESET();
   \   0000000C   0x....             LDR.N    R0,??DataTable23_32  ;; 0x40023820
   \   0000000E   0x6800             LDR      R0,[R0, #+0]
   \   00000010   0xF450 0x4080      ORRS     R0,R0,#0x4000
   \   00000014   0x....             LDR.N    R1,??DataTable23_32  ;; 0x40023820
   \   00000016   0x6008             STR      R0,[R1, #+0]
   1825              __HAL_RCC_SPI2_RELEASE_RESET();
   \   00000018   0x....             LDR.N    R0,??DataTable23_32  ;; 0x40023820
   \   0000001A   0x6800             LDR      R0,[R0, #+0]
   \   0000001C   0xF430 0x4080      BICS     R0,R0,#0x4000
   \   00000020   0x....             LDR.N    R1,??DataTable23_32  ;; 0x40023820
   \   00000022   0x6008             STR      R0,[R1, #+0]
   1826          
   1827              /*##-2- Disable peripherals and GPIO Clocks ################################*/
   1828              HAL_GPIO_DeInit(CODEC_I2S_GPIO, CODEC_I2S_SCK_PIN);
   \   00000024   0x2108             MOVS     R1,#+8
   \   00000026   0x....             LDR.N    R0,??DataTable23_22  ;; 0x40020400
   \   00000028   0x.... 0x....      BL       HAL_GPIO_DeInit
   1829              HAL_GPIO_DeInit(CODEC_I2S_GPIO, CODEC_I2S_SD_PIN);
   \   0000002C   0x2104             MOVS     R1,#+4
   \   0000002E   0x....             LDR.N    R0,??DataTable23_22  ;; 0x40020400
   \   00000030   0x.... 0x....      BL       HAL_GPIO_DeInit
   1830              HAL_GPIO_DeInit(CODEC_I2S_WS_GPIO, CODEC_I2S_WS_PIN);
   \   00000034   0xF44F 0x4100      MOV      R1,#+32768
   \   00000038   0x....             LDR.N    R0,??DataTable23_23  ;; 0x40020000
   \   0000003A   0x.... 0x....      BL       HAL_GPIO_DeInit
   1831          	 HAL_GPIO_DeInit(CODEC_I2S_MCK_GPIO, CODEC_I2S_MCK_PIN);
   \   0000003E   0x2180             MOVS     R1,#+128
   \   00000040   0x....             LDR.N    R0,??DataTable23_24  ;; 0x40020800
   \   00000042   0x.... 0x....      BL       HAL_GPIO_DeInit
   1832          
   1833              /*##-3- Disable the DMA ####################################################*/
   1834              /* De-Initialize the DMA associated to transmission process */
   1835              HAL_DMA_DeInit(&DmaHandle);
   \   00000046   0x....             LDR.N    R0,??DataTable23_2
   \   00000048   0x.... 0x....      BL       HAL_DMA_DeInit
   1836          
   1837          
   1838              /*##-4- Disable the NVIC for DMA ###########################################*/
   1839              HAL_NVIC_DisableIRQ(DMA1_Stream7_IRQn);
   \   0000004C   0x202F             MOVS     R0,#+47
   \   0000004E   0x.... 0x....      BL       HAL_NVIC_DisableIRQ
   1840            }
   1841          }
   \                     ??HAL_SPI_MspDeInit_0: (+1)
   \   00000052   0xBD10             POP      {R4,PC}          ;; return
   1842          
   1843          

   \                                 In section .text, align 2, keep-with-next
   1844          void HAL_I2C_MspDeInit(I2C_HandleTypeDef *hi2c)
   1845          {
   \                     HAL_I2C_MspDeInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1846              /*##-1- Reset peripherals ##################################################*/
   1847              __HAL_RCC_I2C1_FORCE_RESET();
   \   00000004   0x....             LDR.N    R0,??DataTable23_32  ;; 0x40023820
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0xF450 0x1000      ORRS     R0,R0,#0x200000
   \   0000000C   0x....             LDR.N    R1,??DataTable23_32  ;; 0x40023820
   \   0000000E   0x6008             STR      R0,[R1, #+0]
   1848              __HAL_RCC_I2C1_RELEASE_RESET();
   \   00000010   0x....             LDR.N    R0,??DataTable23_32  ;; 0x40023820
   \   00000012   0x6800             LDR      R0,[R0, #+0]
   \   00000014   0xF430 0x1000      BICS     R0,R0,#0x200000
   \   00000018   0x....             LDR.N    R1,??DataTable23_32  ;; 0x40023820
   \   0000001A   0x6008             STR      R0,[R1, #+0]
   1849          
   1850          
   1851            /*##-2- Disable peripherals and GPIO Clocks #################################*/
   1852            /* Configure I2C Tx as alternate function  */
   1853            HAL_GPIO_DeInit(CODEC_I2C_GPIO, CODEC_I2C_SCL_PIN);
   \   0000001C   0x2140             MOVS     R1,#+64
   \   0000001E   0x....             LDR.N    R0,??DataTable23_22  ;; 0x40020400
   \   00000020   0x.... 0x....      BL       HAL_GPIO_DeInit
   1854            /* Configure I2C Rx as alternate function  */
   1855            HAL_GPIO_DeInit(CODEC_I2C_GPIO, CODEC_I2C_SDA_PIN);
   \   00000024   0x2180             MOVS     R1,#+128
   \   00000026   0x....             LDR.N    R0,??DataTable23_22  ;; 0x40020400
   \   00000028   0x.... 0x....      BL       HAL_GPIO_DeInit
   1856          }
   \   0000002C   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22:
   \   00000000   0x........         DC32     AudioTotalSize

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23:
   \   00000000   0x........         DC32     AudioRemSize

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_1:
   \   00000000   0x........         DC32     CurrentPos

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_2:
   \   00000000   0x........         DC32     DmaHandle

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_3:
   \   00000000   0x40026459         DC32     0x40026459

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_4:
   \   00000000   0x40026404         DC32     0x40026404

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_5:
   \   00000000   0x400260B9         DC32     0x400260b9

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_6:
   \   00000000   0x40026400         DC32     0x40026400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_7:
   \   00000000   0x40026059         DC32     0x40026059

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_8:
   \   00000000   0x40026004         DC32     0x40026004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_9:
   \   00000000   0x40026000         DC32     0x40026000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_10:
   \   00000000   0x4002640C         DC32     0x4002640c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_11:
   \   00000000   0x40026408         DC32     0x40026408

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_12:
   \   00000000   0x4002600C         DC32     0x4002600c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_13:
   \   00000000   0x40026008         DC32     0x40026008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_14:
   \   00000000   0x........         DC32     hi2s3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_15:
   \   00000000   0x40003C00         DC32     0x40003c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_16:
   \   00000000   0x........         DC32     OutputDev

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_17:
   \   00000000   0x40020C00         DC32     0x40020c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_18:
   \   00000000   0x........         DC32     hi2c1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_19:
   \   00000000   0x40023840         DC32     0x40023840

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_20:
   \   00000000   0x........         DC32     ??hi2s3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_21:
   \   00000000   0x40023830         DC32     0x40023830

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_22:
   \   00000000   0x40020400         DC32     0x40020400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_23:
   \   00000000   0x40020000         DC32     0x40020000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_24:
   \   00000000   0x40020800         DC32     0x40020800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_25:
   \   00000000   0x400260B8         DC32     0x400260b8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_26:
   \   00000000   0x40003C1C         DC32     0x40003c1c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_27:
   \   00000000   0x40013000         DC32     0x40013000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_28:
   \   00000000   0x40023844         DC32     0x40023844

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_29:
   \   00000000   0x40003800         DC32     0x40003800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_30:
   \   00000000   0x40022000         DC32     0x40022000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_31:
   \   00000000   0x40003C0C         DC32     0x40003c0c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_32:
   \   00000000   0x40023820         DC32     0x40023820
   1857          
   1858          // void HAL_I2S_TxCpltCallback(I2S_HandleTypeDef *hi2s)
   1859          // {
   1860          //	  AudioFlashPlay((uint16_t*)(AUDIO_SAMPLE + AUIDO_START_ADDRESS),AUDIO_FILE_SZE,AUIDO_START_ADDRESS);
   1861           //}

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   AUDIO_DeInit
         8   -> Audio_MAL_DeInit
         8   -> Codec_DeInit
      16   AUDIO_Init
        16   -> BSP_LED_Toggle
        16   -> Codec_Init
       8   AUDIO_Mute
         8   -> Codec_Mute
       8   AUDIO_PauseResume
         8   -> Audio_MAL_PauseResume
         8   -> Codec_PauseResume
      16   AUDIO_Play
        16   -> Audio_MAL_Play
        16   -> Codec_Play
       8   AUDIO_Stop
         8   -> Audio_MAL_Stop
         8   -> Codec_Stop
       8   AUDIO_VolumeCtl
         8   -> Codec_VolumeCtrl
       8   Audio_MAL_DeInit
         8   -> HAL_NVIC_DisableIRQ
      16   Audio_MAL_IRQHandler
        16   -> AUDIO_TransferComplete_CallBack
        16   -> HAL_DMA_Init
      16   Audio_MAL_PauseResume
        16   -> DMA_Cmd
        16   -> I2S_Cmd
        16   -> SPI_I2S_DMACmd
      16   Audio_MAL_Play
        16   -> HAL_I2S_Transmit_DMA
       8   Audio_MAL_Stop
         8   -> DMA_ClearFlag
         8   -> DMA_Cmd
         8   -> I2S_Cmd
       8   Codec_AudioInterface_DeInit
         8   -> SPI_I2S_DeInit
      16   Codec_AudioInterface_Init
        16   -> HAL_I2S_Init
       8   Codec_CtrlInterface_DeInit
         8   -> HAL_I2C_MspDeInit
       8   Codec_CtrlInterface_Init
         8   -> MX_I2C1_Init
       8   Codec_DeInit
         8   -> Codec_AudioInterface_DeInit
         8   -> Codec_CtrlInterface_DeInit
         8   -> Codec_GPIO_DeInit
         8   -> Codec_Reset
         8   -> Codec_WriteRegister
      24   Codec_GPIO_DeInit
        24   -> HAL_GPIO_Init
      32   Codec_GPIO_Init
        32   -> HAL_GPIO_Init
      24   Codec_Init
        24   -> Codec_AudioInterface_Init
        24   -> Codec_CtrlInterface_Init
        24   -> Codec_GPIO_Init
        24   -> Codec_Reset
        24   -> Codec_VolumeCtrl
        24   -> Codec_WriteRegister
      16   Codec_Mute
        16   -> Codec_WriteRegister
      16   Codec_PauseResume
        16   -> Codec_Mute
        16   -> Codec_WriteRegister
       0   Codec_Play
      16   Codec_ReadRegister
        16   -> Codec_TIMEOUT_UserCallback
        16   -> HAL_I2C_GetError
        16   -> HAL_I2C_Master_Receive
        16   -> HAL_I2C_Master_Transmit
       8   Codec_Reset
         8   -> Delay
         8   -> HAL_GPIO_WritePin
      16   Codec_Stop
        16   -> Codec_Mute
        16   -> Codec_WriteRegister
        16   -> Delay
        16   -> HAL_GPIO_WritePin
      16   Codec_VolumeCtrl
        16   -> Codec_WriteRegister
      32   Codec_WriteRegister
        32   -> Codec_ReadRegister
        32   -> Codec_TIMEOUT_UserCallback
        32   -> HAL_I2C_GetError
        32   -> HAL_I2C_Master_Transmit
       0   DAC_Config
       8   DMA1_Stream0_IRQHandler
         8   -> Audio_MAL_IRQHandler
       8   DMA1_Stream7_IRQHandler
         8   -> HAL_DMA_IRQHandler
       0   DMA_ClearFlag
       0   DMA_Cmd
       4   Delay
       8   HAL_I2C_MspDeInit
         8   -> HAL_GPIO_DeInit
      56   HAL_I2S_MspInit
        56   -> HAL_DMA_DeInit
        56   -> HAL_DMA_Init
        56   -> HAL_GPIO_Init
        56   -> HAL_NVIC_EnableIRQ
        56   -> HAL_NVIC_SetPriority
       8   HAL_SPI_MspDeInit
         8   -> HAL_DMA_DeInit
         8   -> HAL_GPIO_DeInit
         8   -> HAL_NVIC_DisableIRQ
       0   I2S_Cmd
       8   SPI3_IRQHandler
         8   -> AUDIO_GetSampleCallBack
         8   -> SPI_I2S_SendData
       4   SPI_I2S_DMACmd
       4   SPI_I2S_DeInit
       0   SPI_I2S_SendData


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable22
       4  ??DataTable23
       4  ??DataTable23_1
       4  ??DataTable23_10
       4  ??DataTable23_11
       4  ??DataTable23_12
       4  ??DataTable23_13
       4  ??DataTable23_14
       4  ??DataTable23_15
       4  ??DataTable23_16
       4  ??DataTable23_17
       4  ??DataTable23_18
       4  ??DataTable23_19
       4  ??DataTable23_2
       4  ??DataTable23_20
       4  ??DataTable23_21
       4  ??DataTable23_22
       4  ??DataTable23_23
       4  ??DataTable23_24
       4  ??DataTable23_25
       4  ??DataTable23_26
       4  ??DataTable23_27
       4  ??DataTable23_28
       4  ??DataTable23_29
       4  ??DataTable23_3
       4  ??DataTable23_30
       4  ??DataTable23_31
       4  ??DataTable23_32
       4  ??DataTable23_4
       4  ??DataTable23_5
       4  ??DataTable23_6
       4  ??DataTable23_7
       4  ??DataTable23_8
       4  ??DataTable23_9
      14  AUDIO_DeInit
      58  AUDIO_Init
      48  AUDIO_MAL_DMA_InitStructure
      12  AUDIO_Mute
      30  AUDIO_PauseResume
     114  AUDIO_Play
      38  AUDIO_Stop
      36  AUDIO_VolumeCtl
       4  AudioRemSize
       4  AudioTotalSize
      22  Audio_MAL_DeInit
     504  Audio_MAL_IRQHandler
      78  Audio_MAL_PauseResume
      32  Audio_MAL_Play
      36  Audio_MAL_Stop
       4  CODECTimeout
      48  Codec_AudioInterface_DeInit
     154  Codec_AudioInterface_Init
      12  Codec_CtrlInterface_DeInit
       8  Codec_CtrlInterface_Init
      36  Codec_DeInit
      64  Codec_GPIO_DeInit
      64  Codec_GPIO_Init
     180  Codec_Init
      44  Codec_Mute
      76  Codec_PauseResume
       4  Codec_Play
     100  Codec_ReadRegister
      36  Codec_Reset
      66  Codec_Stop
      82  Codec_VolumeCtrl
      88  Codec_WriteRegister
       4  CurrAudioInterface
       4  CurrentPos
       2  DAC_Config
       8  DMA1_Stream0_IRQHandler
      14  DMA1_Stream7_IRQHandler
       2  DMA_ClearFlag
      26  DMA_Cmd
      48  DMA_InitStructure
      20  Delay
      80  DmaHandle
      46  HAL_I2C_MspDeInit
     678  HAL_I2S_MspInit
      84  HAL_SPI_MspDeInit
      28  I2S_Cmd
       1  OutputDev
      32  SPI3_IRQHandler
      32  SPI_I2S_DMACmd
     172  SPI_I2S_DeInit
       6  SPI_I2S_SendData
       1  Volume
      60  hi2c1
      64  hi2s3
      64  hi2s3

 
   369 bytes in section .bss
    17 bytes in section .data
 3 322 bytes in section .text
 
 3 322 bytes of CODE memory
   386 bytes of DATA memory

Errors: none
Warnings: 13
