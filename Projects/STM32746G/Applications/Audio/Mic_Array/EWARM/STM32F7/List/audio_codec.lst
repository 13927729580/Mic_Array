###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.2.10312/W32 for ARM       20/Dec/2015  03:50:18
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\Src\audio_codec.c
#    Command line =  
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\Src\audio_codec.c
#        -D USE_HAL_DRIVER -D STM32F746xx -D USE_STM32746G_DISCO -D
#        USE_IOEXPANDER -D USE_USB_FS -lC
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
#        -lA
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
#        -o
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj
#        --debug --endian=little --cpu=Cortex-M7 -e --fpu=VFPv5_sp
#        --dlib_config "D:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Full.h" -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\Inc\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\CMSIS\Device\ST\STM32F7xx\Include\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\STM32F7xx_HAL_Driver\Inc\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\STM32746G-Discovery\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\Components\Common\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Log\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Fonts\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\CPU\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_Device_Library\Core\Inc\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Core\Inc\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Class\MSC\Inc\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\drivers\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_Audio\Addons\PDM\
#        -Ohz --use_c++_inline --require_prototypes -I "D:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.3\arm\CMSIS\Include\" -D
#        ARM_MATH_CM7
#    List file    =  
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List\audio_codec.lst
#    Object file  =  
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj\audio_codec.o
#
###############################################################################

H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\Src\audio_codec.c
      1          /**
      2            ******************************************************************************
      3            * @file    audio_codec.c
      4            * @author  Phan Le Son ( porting from "MCD Application Team")
      5            * @version V1.0.0
      6            * @date    12-December-2015
      7            * @brief   This file includes the low layer driver for CS43L22 Audio Codec 
      8            ******************************************************************************
      9                                                       User NOTES
     10          1. How To use this driver:
     11          --------------------------
     12             - Call the function AUDIO_Init(
     13                                              OutputDevice: physical output mode (OUTPUT_DEVICE_SPEAKER, 
     14                                                           OUTPUT_DEVICE_HEADPHONE, OUTPUT_DEVICE_AUTO or 
     15                                                           OUTPUT_DEVICE_BOTH)
     16                                              Volume: initial volume to be set (0 is min (mute), 100 is max (100%)
     17                                              AudioFreq: Audio frequency in Hz (8000, 16000, 22500, 32000 ...)
     18                                              this parameter is relative to the audio file/stream type.
     19                                             )
     20                This function configures all the hardware required for the audio application (codec, I2C, I2S, 
     21                GPIOs, DMA and interrupt if needed). This function returns 0 if configuration is OK.
     22                if the returned value is different from 0 or the function is stuck then the communication with
     23                the codec (try to un-plug the power or reset device in this case).
     24                + OUTPUT_DEVICE_SPEAKER: only speaker will be set as output for the audio stream.
     25                + OUTPUT_DEVICE_HEADPHONE: only headphones will be set as output for the audio stream.
     26                + OUTPUT_DEVICE_AUTO: Selection of output device is made through external switch (implemented 
     27                   into the audio jack on the board). When the Headphone is connected it is used
     28                   as output. When the headphone is disconnected from the audio jack, the output is
     29                   automatically switched to Speaker.
     30                + OUTPUT_DEVICE_BOTH: both Speaker and Headphone are used as outputs for the audio stream
     31                   at the same time.
     32             - Call the function AUDIO_Play(
     33                                            pBuffer: pointer to the audio data file address
     34                                            Size: size of the buffer to be sent in Bytes
     35                                           )
     36                to start playing (for the first time) from the audio file/stream.
     37             - Call the function AUDIO_PauseResume(
     38                                                   Cmd: AUDIO_PAUSE (or 0) to pause playing or AUDIO_RESUME (or 
     39                                                         any value different from 0) to resume playing.
     40                                                   )
     41                 Note. After calling AUDIO_PauseResume() function for pause, only AUDIO_PauseResume() should be called
     42                    for resume (it is not allowed to call AUDIO_Play() in this case).
     43                 Note. This function should be called only when the audio file is played or paused (not stopped).
     44             - For each mode, you may need to implement the relative callback functions into your code.
     45                The Callback functions are named AUDIO_XXX_CallBack() and only their prototypes are declared in 
     46                the stm32f4_discovery_audio_codec.h file. (refer to the example for more details on the callbacks implementations)
     47             - To Stop playing, to modify the volume level or to mute, use the functions
     48                 AUDIO_Stop(), AUDIO_VolumeCtl() and AUDIO_Mute().
     49           
     50           Driver architecture:
     51           --------------------
     52           This driver is composed of three main layers:
     53             o High Audio Layer: consists of the function API exported in the audio_codec.h file
     54               (AUDIO_Init(), AUDIO_Play() ...)
     55             o Codec Control layer: consists of the functions API controlling the audio codec (CS43L22) and 
     56               included as local functions in file stm32f4_discovery_audio_codec.c (Codec_Init(), Codec_Play() ...)
     57             o Media Access Layer (MAL): which consists of functions allowing to access the media containing/
     58               providing the audio file/stream. These functions are also included as local functions into
     59               the stm32f4_discovery_audio_codec.c file (Audio_MAL_Init(), Audio_MAL_Play() ...)
     60            Each set of functions (layer) may be implemented independently of the others and customized when 
     61            needed.    
     62          2. Modes description:
     63          ---------------------
     64               + AUDIO_MAL_MODE_NORMAL : is suitable when the audio file is in a memory location.
     65               + AUDIO_MAL_MODE_CIRCULAR: is suitable when the audio data are read either from a 
     66                  memory location or from a device at real time (double buffer could be used).
     67          3. DMA interrupts description:
     68          ------------------------------
     69               + AUDIO_IT_TC_ENABLE: Enable this define to use the DMA end of transfer interrupt.
     70                  then, a callback should be implemented by user to perform specific actions
     71                  when the DMA has finished the transfer.
     72               + AUDIO_IT_HT_ENABLE: Enable this define to use the DMA end of half transfer interrupt.
     73                  then, a callback should be implemented by user to perform specific actions
     74                  when the DMA has reached the half of the buffer transfer (generally, it is useful 
     75                  to load the first half of buffer while DMA is loading from the second half).
     76               + AUDIO_IT_ER_ENABLE: Enable this define to manage the cases of error on DMA transfer.
     77          4. Known Limitations:
     78          ---------------------
     79             1- When using the Speaker, if the audio file quality is not high enough, the speaker output
     80                may produce high and uncomfortable noise level. To avoid this issue, to use speaker
     81                output properly, try to increase audio file sampling rate (typically higher than 48KHz).
     82                This operation will lead to larger file size.
     83             2- Communication with the audio codec (through I2C) may be corrupted if it is interrupted by some
     84                user interrupt routines (in this case, interrupts could be disabled just before the start of 
     85                communication then re-enabled when it is over). Note that this communication is only done at
     86                the configuration phase (AUDIO_Init() or AUDIO_Stop()) and when Volume control modification is 
     87                performed (AUDIO_VolumeCtl() or AUDIO_Mute()). When the audio data is played, no communication is 
     88                required with the audio codec.
     89            3- Parsing of audio file is not implemented (in order to determine audio file properties: Mono/Stereo, Data size, 
     90               File size, Audio Frequency, Audio Data header size ...). The configuration is fixed for the given audio file.
     91            4- Mono audio streaming is not supported (in order to play mono audio streams, each data should be sent twice 
     92               on the I2S or should be duplicated on the source buffer. Or convert the stream in stereo before playing).
     93            5- Supports only 16-bit audio data size.
     94          */
     95          
     96          
     97          /* Includes ------------------------------------------------------------------*/
     98          #include "audio_codec.h"
     99          #include "stm32746g_discovery.h"
    100          #include "stm32f7xx_hal_i2s.h"
    101          #include "audio.h"
    102          #include "main.h"
    103          
    104          
    105          #define  I2C_CR1_SMBUS                       ((uint16_t)0x0002)            /*!<SMBus Mode */
    106          #define  I2C_CR1_SMBTYPE                     ((uint16_t)0x0008)            /*!<SMBus Type */
    107          #define  I2C_CR1_ENARP                       ((uint16_t)0x0010)            /*!<ARP Enable */
    108          #define  I2C_CR1_ENPEC                       ((uint16_t)0x0020)            /*!<PEC Enable */
    109          #define  I2C_CR1_ENGC                        ((uint16_t)0x0040)            /*!<General Call Enable */
    110          
    111          #define  I2C_CR1_START                       ((uint16_t)0x0100)            /*!<Start Generation */
    112          #define  I2C_CR1_STOP                        ((uint16_t)0x0200)            /*!<Stop Generation */
    113          #define  I2C_CR1_ACK                         ((uint16_t)0x0400)            /*!<Acknowledge Enable */
    114          #define  I2C_CR1_POS                         ((uint16_t)0x0800)            /*!<Acknowledge/PEC Position (for data reception) */
    115          #define  I2C_CR1_PEC                         ((uint16_t)0x1000)            /*!<Packet Error Checking */
    116          #define  I2C_CR1_ALERT                       ((uint16_t)0x2000)            /*!<SMBus Alert */
    117          
    118          #define  I2C_Direction_Transmitter      ((uint8_t)0x00)
    119          #define  I2C_Direction_Receiver         ((uint8_t)0x01)
    120          #define IS_I2C_DIRECTION(DIRECTION) (((DIRECTION) == I2C_Direction_Transmitter) || \
    121                                               ((DIRECTION) == I2C_Direction_Receiver))
    122          /*******************  Bit definition for I2C_OAR1 register  *******************/
    123          #define  I2C_OAR1_ADD1_7                     ((uint16_t)0x00FE)            /*!<Interface Address */
    124          #define  I2C_OAR1_ADD8_9                     ((uint16_t)0x0300)            /*!<Interface Address */
    125          									 
    126          #define  I2C_OAR1_ADD0                       ((uint16_t)0x0001)            /*!<Bit 0 */
    127          #define  I2C_OAR1_ADD1                       ((uint16_t)0x0002)            /*!<Bit 1 */
    128          #define  I2C_OAR1_ADD2                       ((uint16_t)0x0004)            /*!<Bit 2 */
    129          #define  I2C_OAR1_ADD3                       ((uint16_t)0x0008)            /*!<Bit 3 */
    130          #define  I2C_OAR1_ADD4                       ((uint16_t)0x0010)            /*!<Bit 4 */
    131          #define  I2C_OAR1_ADD5                       ((uint16_t)0x0020)            /*!<Bit 5 */
    132          #define  I2C_OAR1_ADD6                       ((uint16_t)0x0040)            /*!<Bit 6 */
    133          #define  I2C_OAR1_ADD7                       ((uint16_t)0x0080)            /*!<Bit 7 */
    134          #define  I2C_OAR1_ADD8                       ((uint16_t)0x0100)            /*!<Bit 8 */
    135          #define  I2C_OAR1_ADD9                       ((uint16_t)0x0200)            /*!<Bit 9 */
    136          									 
    137          #define  I2C_OAR1_ADDMODE                    ((uint16_t)0x8000)            /*!<Addressing Mode (Slave mode) */
    138          
    139          #define CR1_CLEAR_MASK    ((uint16_t)0xFBF5)      /*<! I2C registers Masks */
    140          #define FLAG_MASK         ((uint32_t)0x00FFFFFF)  /*<! I2C FLAG mask */
    141          #define ITEN_MASK         ((uint32_t)0x07000000)  /*<! I2C Interrupt Enable mask */
    142          
    143          #define  I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED        ((uint32_t)0x00070082)  /* BUSY, MSL, ADDR, TXE and TRA flags */
    144          #define  I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED           ((uint32_t)0x00030002)  /* BUSY, MSL and ADDR flags */
    145          /* --EV9 */
    146          #define  I2C_EVENT_MASTER_MODE_ADDRESS10                   ((uint32_t)0x00030008)  /* BUSY, MSL and ADD10 flags */
    147          
    148          /* Master RECEIVER mode -----------------------------*/ 
    149          /* --EV7 */
    150          #define  I2C_EVENT_MASTER_BYTE_RECEIVED                    ((uint32_t)0x00030040)  /* BUSY, MSL and RXNE flags */
    151          
    152          /* Master TRANSMITTER mode --------------------------*/
    153          /* --EV8 */
    154          #define I2C_EVENT_MASTER_BYTE_TRANSMITTING                 ((uint32_t)0x00070080) /* TRA, BUSY, MSL, TXE flags */
    155          /* --EV8_2 */
    156          #define  I2C_EVENT_MASTER_BYTE_TRANSMITTED                 ((uint32_t)0x00070084)  /* TRA, BUSY, MSL, TXE and BTF flags */
    157          
    158          #define I2C_FLAG_SMBALERT               ((uint32_t)0x00018000)
    159          
    160          #define I2C_FLAG_ADD10                  ((uint32_t)0x00010008)
    161          #define I2C_FLAG_BTF                    ((uint32_t)0x00010004)
    162          
    163          #define I2C_FLAG_SB                     ((uint32_t)0x00010001)
    164          #define I2C_FLAG_DUALF                  ((uint32_t)0x00100080)
    165          #define I2C_FLAG_SMBHOST                ((uint32_t)0x00100040)
    166          #define I2C_FLAG_SMBDEFAULT             ((uint32_t)0x00100020)
    167          #define I2C_FLAG_GENCALL                ((uint32_t)0x00100010)
    168          #define I2C_FLAG_TRA                    ((uint32_t)0x00100004)
    169          
    170          #define I2C_FLAG_MSL                    ((uint32_t)0x00100001)
    171          #define  I2C_EVENT_MASTER_MODE_SELECT                      ((uint32_t)0x00030001)  /* BUSY, MSL and SB flag */
    172          
    173          
    174          #define SPI_I2S_DMAReq_Tx               ((uint16_t)0x0002)
    175          #define SPI_I2S_DMAReq_Rx               ((uint16_t)0x0001)
    176          //#define IS_SPI_I2S_DMAREQ(DMAREQ) ((((DMAREQ) & (uint16_t)0xFFFC) == 0x00) && ((DMAREQ) != 0x00))
    177          
    178          
    179          /** 
    180            *      This file includes the low layer driver for CS43L22 Audio Codec
    181            *              available on STM32F4-Discovery Kit.
    182            *
    183            */ 
    184          
    185          
    186          
    187          /* Mask for the bit EN of the I2S CFGR register */
    188          #define I2S_ENABLE_MASK                 0x0400
    189          
    190          /* Delay for the Codec to be correctly reset */
    191          #define CODEC_RESET_DELAY               0x4FFF
    192          
    193          
    194          /* The 7 bits Codec address (sent through I2C interface) */
    195          #define CODEC_ADDRESS                   0x94  /* b00100111 */
    196          
    197          
    198          /* This structure is declared global because it is handled by two different functions */

   \                                 In section .bss, align 4
    199          DMA_InitTypeDef DMA_InitStructure; 
   \                     DMA_InitStructure:
   \   00000000                      DS8 48

   \                                 In section .bss, align 4
    200          DMA_InitTypeDef AUDIO_MAL_DMA_InitStructure;
   \                     AUDIO_MAL_DMA_InitStructure:
   \   00000000                      DS8 48
    201          

   \                                 In section .data, align 4
    202          uint32_t AudioTotalSize = 0xFFFF; /* This variable holds the total size of the audio file */
    203          uint32_t AudioRemSize   = 0xFFFF; /* This variable holds the remaining data in audio file */
    204          uint16_t *CurrentPos ;             /* This variable holds the current position of audio pointer */
    205          
    206          __IO uint32_t  CODECTimeout = CODEC_LONG_TIMEOUT;   
    207          __IO uint8_t OutputDev = 0;
    208          
    209          
    210          __IO uint32_t CurrAudioInterface = AUDIO_INTERFACE_I2S; //AUDIO_INTERFACE_DAC
    211          
    212          DMA_HandleTypeDef     DmaHandle;
   \                     DmaHandle:
   \   00000000   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000010   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000020   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000030   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000040   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \                     AudioTotalSize:
   \   00000050   0x0000FFFF         DC32 65535
   \                     AudioRemSize:
   \   00000054   0x0000FFFF         DC32 65535
   \                     CurrentPos:
   \   00000058   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    

   \                                 In section .data, align 4
   \                     CODECTimeout:
   \   00000000   0x0012C000         DC32 1228800

   \                                 In section .data, align 4
   \                     CurrAudioInterface:
   \   00000000   0x00000001         DC32 1
    213          I2S_HandleTypeDef     hi2s3;
    214          I2C_HandleTypeDef     hi2c1;

   \                                 In section .data, align 1
    215          uint8_t Volume=80;
   \                     Volume:
   \   00000000   0x50               DC8 80
    216          static void Audio_MAL_IRQHandler(void);
    217          /*-----------------------------------
    218                                     Audio Codec functions 
    219                                              ------------------------------------------*/
    220          /* High Layer codec functions */
    221          static uint32_t Codec_Init(uint16_t OutputDevice, uint8_t Volume, uint32_t AudioFreq);
    222          static uint32_t Codec_DeInit(void);
    223          static uint32_t Codec_Play(void);
    224          static uint32_t Codec_PauseResume(uint32_t Cmd);
    225          static uint32_t Codec_Stop(uint32_t Cmd);
    226          static uint32_t Codec_VolumeCtrl(uint8_t Volume);
    227          static uint32_t Codec_Mute(uint32_t Cmd);
    228          /* Low layer codec functions */
    229          static void     Codec_CtrlInterface_Init(void);
    230          static void     Codec_CtrlInterface_DeInit(void);
    231          static void     Codec_AudioInterface_Init(uint32_t AudioFreq);
    232          static void     Codec_AudioInterface_DeInit(void);
    233          static void     Codec_Reset(void);
    234          static uint32_t Codec_WriteRegister(uint8_t RegisterAddr, uint8_t RegisterValue);
    235          static uint32_t Codec_ReadRegister(uint8_t RegisterAddr);
    236          static void     Codec_GPIO_Init(void);
    237          static void     Codec_GPIO_DeInit(void);
    238          static void     Delay(__IO uint32_t nCount);
    239          static void SPI_I2S_SendData(SPI_TypeDef* SPIx, uint16_t Data);
    240          static void I2C_GenerateSTART(I2C_TypeDef* I2Cx, FunctionalState NewState);
    241          static void I2C_Send7bitAddress(I2C_TypeDef* I2Cx, uint8_t Address, uint8_t I2C_Direction);
    242          static ErrorStatus I2C_CheckEvent(I2C_TypeDef* I2Cx, uint32_t I2C_EVENT);
    243          static void I2C_SendData(I2C_TypeDef* I2Cx, uint8_t Data);
    244          static void I2C_GenerateSTOP(I2C_TypeDef* I2Cx, FunctionalState NewState);
    245          static FlagStatus I2C_GetFlagStatus(I2C_TypeDef* I2Cx, uint32_t I2C_FLAG);
    246          static void I2C_AcknowledgeConfig(I2C_TypeDef* I2Cx, FunctionalState NewState);
    247          static uint8_t I2C_ReceiveData(I2C_TypeDef* I2Cx);
    248          static void I2C_ClearFlag(I2C_TypeDef* I2Cx, uint32_t I2C_FLAG);
    249          
    250          static void I2S_Cmd(SPI_TypeDef* SPIx, FunctionalState NewState);
    251          static void SPI_I2S_DeInit(SPI_TypeDef* SPIx);
    252          static void DMA_Cmd(DMA_Stream_TypeDef* DMAy_Streamx, FunctionalState NewState);
    253          static void DMA_DeInit(DMA_Stream_TypeDef* DMAy_Streamx);
    254          static void SPI_I2S_DMACmd(SPI_TypeDef* SPIx, uint16_t SPI_I2S_DMAReq, FunctionalState NewState);
    255          static void DMA_ClearFlag(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t DMA_FLAG);
    256          
    257          /*----------------------------------------------------------------------------*/
    258          
    259          /*-----------------------------------
    260                             MAL (Media Access Layer) functions 
    261                                              ------------------------------------------*/
    262          /* Peripherals configuration functions */
    263          static void     Audio_MAL_Init(void);
    264          static void     Audio_MAL_DeInit(void);
    265          static void     Audio_MAL_PauseResume(uint32_t Cmd, uint32_t Addr);
    266          static void     Audio_MAL_Stop(void);
    267          /*----------------------------------------------------------------------------*/
    268          
    269          /**
    270            * @brief  Configure the audio peripherals.
    271            * @param  OutputDevice: OUTPUT_DEVICE_SPEAKER, OUTPUT_DEVICE_HEADPHONE,
    272            *                       OUTPUT_DEVICE_BOTH or OUTPUT_DEVICE_AUTO .
    273            * @param  Volume: Initial volume level (from 0 (Mute) to 100 (Max))
    274            * @param  AudioFreq: Audio frequency used to play the audio stream.
    275            * @retval 0 if correct communication, else wrong communication
    276            */

   \                                 In section .text, align 2, keep-with-next
    277          uint32_t AUDIO_Init(uint16_t OutputDevice, uint8_t Volume, uint32_t AudioFreq)
    278          {    
    279          	/* Perform low layer Codec initialization */
    280          	Codec_Init(OutputDevice, VOLUME_CONVERT(Volume), AudioFreq);
   \                     AUDIO_Init: (+1)
   \   00000000   0x2965             CMP      R1,#+101
   \   00000002   0xB580             PUSH     {R7,LR}
   \   00000004   0xBFAF             ITEEE    GE 
   \   00000006   0x2164             MOVGE    R1,#+100
   \   00000008   0xEBC1 0x2101      RSBLT    R1,R1,R1, LSL #+8
   \   0000000C   0x2364             MOVLT    R3,#+100
   \   0000000E   0xFB91 0xF1F3      SDIVLT   R1,R1,R3
   \   00000012   0xB2C9             UXTB     R1,R1
   \   00000014   0x.... 0x....      BL       Codec_Init
    281          	
    282          	return 0;
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0xBD02             POP      {R1,PC}          ;; return
    283          }
    284          
    285          /**
    286            * @brief  Deinitializes all the resources used by the codec (those initialized
    287            *         by AUDIO_Init() function). 
    288            * @param  None
    289            * @retval 0 if correct communication, else wrong communication
    290            */

   \                                 In section .text, align 2, keep-with-next
    291          uint32_t AUDIO_DeInit(void)
    292          { 
   \                     AUDIO_DeInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB086             SUB      SP,SP,#+24
    293            /* DeInitialize the Media layer */
    294            Audio_MAL_DeInit();
   \   00000004   0x2033             MOVS     R0,#+51
   \   00000006   0x.... 0x....      BL       HAL_NVIC_DisableIRQ
   \   0000000A   0x202F             MOVS     R0,#+47
   \   0000000C   0x.... 0x....      LDR.W    R4,??DataTable14
   \   00000010   0x.... 0x....      BL       HAL_NVIC_DisableIRQ
   \   00000014   0x2033             MOVS     R0,#+51
   \   00000016   0x.... 0x....      BL       HAL_NVIC_DisableIRQ
    295            
    296            /* DeInitialize Codec */  
    297            Codec_DeInit();  
   \   0000001A   0x.... 0x....      BL       Codec_Reset
   \   0000001E   0x.... 0x....      BL       ?Subroutine2
   \                     ??CrossCallReturnLabel_10: (+1)
   \   00000022   0x200C             MOVS     R0,#+12
   \   00000024   0xA901             ADD      R1,SP,#+4
   \   00000026   0x9001             STR      R0,[SP, #+4]
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0x9002             STR      R0,[SP, #+8]
   \   0000002C   0x9004             STR      R0,[SP, #+16]
   \   0000002E   0x9003             STR      R0,[SP, #+12]
   \   00000030   0x.... 0x....      LDR.W    R0,??DataTable14_1  ;; 0x40020400
   \   00000034   0x.... 0x....      BL       HAL_GPIO_Init
   \   00000038   0xF44F 0x4000      MOV      R0,#+32768
   \   0000003C   0xA901             ADD      R1,SP,#+4
   \   0000003E   0x9001             STR      R0,[SP, #+4]
   \   00000040   0x.... 0x....      LDR.W    R0,??DataTable14_2  ;; 0x40020000
   \   00000044   0x.... 0x....      BL       HAL_GPIO_Init
   \   00000048   0x2080             MOVS     R0,#+128
   \   0000004A   0xA901             ADD      R1,SP,#+4
   \   0000004C   0x9001             STR      R0,[SP, #+4]
   \   0000004E   0x.... 0x....      LDR.W    R0,??DataTable14_3  ;; 0x40020800
   \   00000052   0x.... 0x....      BL       HAL_GPIO_Init
   \   00000056   0xF104 0x0040      ADD      R0,R4,#+64
   \   0000005A   0x.... 0x....      BL       HAL_I2C_MspDeInit
   \   0000005E   0x6820             LDR      R0,[R4, #+0]
   \   00000060   0x69C1             LDR      R1,[R0, #+28]
   \   00000062   0xF421 0x6180      BIC      R1,R1,#0x400
   \   00000066   0x61C1             STR      R1,[R0, #+28]
   \   00000068   0x.... 0x....      LDR.W    R0,??DataTable14_4  ;; 0x40023840
   \   0000006C   0x6801             LDR      R1,[R0, #+0]
   \   0000006E   0xF441 0x4100      ORR      R1,R1,#0x8000
   \   00000072   0x6001             STR      R1,[R0, #+0]
   \   00000074   0x6801             LDR      R1,[R0, #+0]
   \   00000076   0xF401 0x4100      AND      R1,R1,#0x8000
   \   0000007A   0x9100             STR      R1,[SP, #+0]
   \   0000007C   0x9900             LDR      R1,[SP, #+0]
   \   0000007E   0x6801             LDR      R1,[R0, #+0]
   \   00000080   0xF421 0x4100      BIC      R1,R1,#0x8000
   \   00000084   0x6001             STR      R1,[R0, #+0]
   \   00000086   0x6801             LDR      R1,[R0, #+0]
   \   00000088   0xF421 0x4100      BIC      R1,R1,#0x8000
   \   0000008C   0x6001             STR      R1,[R0, #+0]
    298            
    299            return 0;
   \   0000008E   0x2000             MOVS     R0,#+0
   \   00000090   0xB006             ADD      SP,SP,#+24
   \   00000092   0xBD10             POP      {R4,PC}          ;; return
    300          }
    301          
    302          /**
    303            * @brief  Starts playing audio stream from a data buffer for a determined size. 
    304            * @param  pBuffer: Pointer to the buffer 
    305            * @param  Size: Number of audio data BYTES.
    306            * @retval 0 if correct communication, else wrong communication
    307            */

   \                                 In section .text, align 2, keep-with-next
    308          uint32_t AUDIO_Play(uint16_t* pBuffer, uint32_t Size)
    309          {
   \                     AUDIO_Play: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x460D             MOV      R5,R1
    310            /* Set the total number of data to be played (count in half-word) */
    311            AudioTotalSize = Size;
    312          
    313            /* Call the audio Codec Play function */
    314            Codec_Play();
    315            
    316            /* Update the Media layer and enable it for play */  
    317            Audio_MAL_Play(pBuffer, (uint16_t)(DMA_MAX(Size/4)));
   \   00000004   0x08A9             LSRS     R1,R5,#+2
   \   00000006   0xF5B1 0x3F80      CMP      R1,#+65536
   \   0000000A   0x.... 0x....      LDR.W    R6,??DataTable14_5
   \   0000000E   0x6535             STR      R5,[R6, #+80]
   \   00000010   0x4604             MOV      R4,R0
   \   00000012   0xBF28             IT       CS 
   \   00000014   0xF64F 0x71FF      MOVWCS   R1,#+65535
   \   00000018   0xB289             UXTH     R1,R1
   \   0000001A   0x.... 0x....      BL       Audio_MAL_Play
    318            
    319            /* Update the remaining number of data to be played */
    320            AudioRemSize = (Size/2) - DMA_MAX(AudioTotalSize)/2;//1 sop1hc: change "DMA_MAX(AudioTotalSize)" to "DMA_MAX(AudioTotalSize)/2"
   \   0000001E   0x6D30             LDR      R0,[R6, #+80]
   \   00000020   0xF5B0 0x3F80      CMP      R0,#+65536
   \   00000024   0xBF34             ITE      CC 
   \   00000026   0x0841             LSRCC    R1,R0,#+1
   \   00000028   0xF647 0x71FF      MOVWCS   R1,#+32767
   \   0000002C   0xEBC1 0x0155      RSB      R1,R1,R5, LSR #+1
    321            
    322            /* Update the current audio pointer position */
    323            CurrentPos = pBuffer + DMA_MAX(AudioTotalSize);
   \   00000030   0xF5B0 0x3F80      CMP      R0,#+65536
   \   00000034   0x6571             STR      R1,[R6, #+84]
   \   00000036   0xBF34             ITE      CC 
   \   00000038   0x0040             LSLCC    R0,R0,#+1
   \   0000003A   0x.... 0x....      LDRCS.W  R0,??DataTable14_6  ;; 0x1fffe
   \   0000003E   0x1900             ADDS     R0,R0,R4
   \   00000040   0x65B0             STR      R0,[R6, #+88]
    324            
    325            return 0;
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0xBD70             POP      {R4-R6,PC}       ;; return
    326          }
    327          
    328          /**
    329            * @brief  This function Pauses or Resumes the audio file stream. In case
    330            *         of using DMA, the DMA Pause feature is used. In all cases the I2S 
    331            *         peripheral is disabled. 
    332            * 
    333            * @WARNING When calling AUDIO_PauseResume() function for pause, only
    334            *          this function should be called for resume (use of AUDIO_Play() 
    335            *          function for resume could lead to unexpected behavior).
    336            * 
    337            * @param  Cmd: AUDIO_PAUSE (or 0) to pause, AUDIO_RESUME (or any value different
    338            *         from 0) to resume. 
    339            * @retval 0 if correct communication, else wrong communication
    340            */

   \                                 In section .text, align 2, keep-with-next
    341          uint32_t AUDIO_PauseResume(uint32_t Cmd)
    342          {    
   \                     AUDIO_PauseResume: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
    343            /* Call the Audio Codec Pause/Resume function */
    344            if (Codec_PauseResume(Cmd) != 0)
   \   00000004   0xD105             BNE.N    ??AUDIO_PauseResume_0
   \   00000006   0x2001             MOVS     R0,#+1
   \   00000008   0x.... 0x....      BL       Codec_Mute
   \   0000000C   0x4605             MOV      R5,R0
   \   0000000E   0x2101             MOVS     R1,#+1
   \   00000010   0xE00B             B.N      ??AUDIO_PauseResume_1
   \                     ??AUDIO_PauseResume_0: (+1)
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0x.... 0x....      BL       Codec_Mute
   \   00000018   0x4605             MOV      R5,R0
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable14_7
   \   0000001E   0x7801             LDRB     R1,[R0, #+0]
   \   00000020   0x2004             MOVS     R0,#+4
   \   00000022   0x.... 0x....      BL       Codec_WriteRegister
   \   00000026   0x1945             ADDS     R5,R0,R5
   \   00000028   0x219E             MOVS     R1,#+158
   \                     ??AUDIO_PauseResume_1: (+1)
   \   0000002A   0x.... 0x....      BL       ??Subroutine2_0
   \                     ??CrossCallReturnLabel_8: (+1)
   \   0000002E   0x1940             ADDS     R0,R0,R5
   \   00000030   0xD001             BEQ.N    ??AUDIO_PauseResume_2
    345            {
    346              return 1;
   \   00000032   0x2001             MOVS     R0,#+1
   \   00000034   0xBD70             POP      {R4-R6,PC}
    347            }
    348            else
    349            {
    350              /* Call the Media layer pause/resume function */
    351              Audio_MAL_PauseResume(Cmd, 0);
   \                     ??AUDIO_PauseResume_2: (+1)
   \   00000036   0x.... 0x....      LDR.W    R5,??DataTable14_8  ;; 0x400260b8
   \   0000003A   0x.... 0x....      LDR.W    R6,??DataTable14_9  ;; 0x40003c00
   \   0000003E   0xB94C             CBNZ.N   R4,??AUDIO_PauseResume_3
   \   00000040   0x2200             MOVS     R2,#+0
   \   00000042   0x2102             MOVS     R1,#+2
   \   00000044   0x4630             MOV      R0,R6
   \   00000046   0x.... 0x....      BL       SPI_I2S_DMACmd
   \   0000004A   0x2100             MOVS     R1,#+0
   \   0000004C   0x4628             MOV      R0,R5
   \   0000004E   0x.... 0x....      BL       DMA_Cmd
   \   00000052   0xE00F             B.N      ??AUDIO_PauseResume_4
   \                     ??AUDIO_PauseResume_3: (+1)
   \   00000054   0x2201             MOVS     R2,#+1
   \   00000056   0x2102             MOVS     R1,#+2
   \   00000058   0x4630             MOV      R0,R6
   \   0000005A   0x.... 0x....      BL       SPI_I2S_DMACmd
   \   0000005E   0x2101             MOVS     R1,#+1
   \   00000060   0x4628             MOV      R0,R5
   \   00000062   0x.... 0x....      BL       DMA_Cmd
   \   00000066   0x69F0             LDR      R0,[R6, #+28]
   \   00000068   0x0540             LSLS     R0,R0,#+21
   \   0000006A   0xD403             BMI.N    ??AUDIO_PauseResume_4
   \   0000006C   0x2101             MOVS     R1,#+1
   \   0000006E   0x4630             MOV      R0,R6
   \   00000070   0x.... 0x....      BL       I2S_Cmd
    352              
    353              /* Return 0 if all operations are OK */
    354              return 0;
   \                     ??AUDIO_PauseResume_4: (+1)
   \   00000074   0x2000             MOVS     R0,#+0
   \   00000076   0xBD70             POP      {R4-R6,PC}       ;; return
    355            }
    356          }
    357          
    358          /**
    359            * @brief  Stops audio playing and Power down the Audio Codec. 
    360            * @param  Option: could be one of the following parameters 
    361            *           - CODEC_PDWN_SW: for software power off (by writing registers). 
    362            *                            Then no need to reconfigure the Codec after power on.
    363            *           - CODEC_PDWN_HW: completely shut down the codec (physically). 
    364            *                            Then need to reconfigure the Codec after power on.  
    365            * @retval 0 if correct communication, else wrong communication
    366            */

   \                                 In section .text, align 2, keep-with-next
    367          uint32_t AUDIO_Stop(uint32_t Option)
    368          {
   \                     AUDIO_Stop: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    369            /* Call Audio Codec Stop function */
    370            if (Codec_Stop(Option) != 0)
   \   00000004   0x2001             MOVS     R0,#+1
   \   00000006   0x.... 0x....      BL       Codec_Mute
   \   0000000A   0x2C02             CMP      R4,#+2
   \   0000000C   0xD104             BNE.N    ??AUDIO_Stop_0
   \   0000000E   0x219F             MOVS     R1,#+159
   \   00000010   0x.... 0x....      BL       ??Subroutine2_0
   \                     ??CrossCallReturnLabel_7: (+1)
   \   00000014   0x4604             MOV      R4,R0
   \   00000016   0xE00D             B.N      ??AUDIO_Stop_1
   \                     ??AUDIO_Stop_0: (+1)
   \   00000018   0x219F             MOVS     R1,#+159
   \   0000001A   0x.... 0x....      BL       ??Subroutine2_0
   \                     ??CrossCallReturnLabel_6: (+1)
   \   0000001E   0x4604             MOV      R4,R0
   \   00000020   0xF640 0x70FF      MOVW     R0,#+4095
   \   00000024   0x.... 0x....      BL       Delay
   \   00000028   0x2200             MOVS     R2,#+0
   \   0000002A   0x2110             MOVS     R1,#+16
   \   0000002C   0x.... 0x....      LDR.W    R0,??DataTable14_10  ;; 0x40020c00
   \   00000030   0x.... 0x....      BL       HAL_GPIO_WritePin
   \                     ??AUDIO_Stop_1: (+1)
   \   00000034   0xB10C             CBZ.N    R4,??AUDIO_Stop_2
    371            {
    372              return 1;
   \   00000036   0x2001             MOVS     R0,#+1
   \   00000038   0xBD10             POP      {R4,PC}
    373            }
    374            else
    375            {
    376              /* Call Media layer Stop function */
    377              Audio_MAL_Stop();
   \                     ??AUDIO_Stop_2: (+1)
   \   0000003A   0x2100             MOVS     R1,#+0
   \   0000003C   0x.... 0x....      LDR.W    R0,??DataTable14_8  ;; 0x400260b8
   \   00000040   0x.... 0x....      BL       DMA_Cmd
   \   00000044   0x2100             MOVS     R1,#+0
   \   00000046   0x.... 0x....      LDR.W    R0,??DataTable14_9  ;; 0x40003c00
   \   0000004A   0x.... 0x....      BL       I2S_Cmd
    378              
    379              /* Update the remaining data number */
    380              AudioRemSize = AudioTotalSize;    
   \   0000004E   0x.... 0x....      LDR.W    R0,??DataTable14_5
   \   00000052   0x6D01             LDR      R1,[R0, #+80]
   \   00000054   0x6541             STR      R1,[R0, #+84]
    381              
    382              /* Return 0 when all operations are correctly done */
    383              return 0;
   \   00000056   0x2000             MOVS     R0,#+0
   \   00000058   0xBD10             POP      {R4,PC}          ;; return
    384            }
    385          }
    386          
    387          /**
    388            * @brief  Controls the current audio volume level. 
    389            * @param  Volume: Volume level to be set in percentage from 0% to 100% (0 for 
    390            *         Mute and 100 for Max volume level).
    391            * @retval 0 if correct communication, else wrong communication
    392            */

   \                                 In section .text, align 2, keep-with-next
    393          uint32_t AUDIO_VolumeCtl(uint8_t Volume)
    394          {
    395            /* Call the codec volume control function with converted volume value */
    396            return (Codec_VolumeCtrl(VOLUME_CONVERT(Volume)));
   \                     AUDIO_VolumeCtl: (+1)
   \   00000000   0x2865             CMP      R0,#+101
   \   00000002   0xBFAF             ITEEE    GE 
   \   00000004   0x2064             MOVGE    R0,#+100
   \   00000006   0xEBC0 0x2000      RSBLT    R0,R0,R0, LSL #+8
   \   0000000A   0x2164             MOVLT    R1,#+100
   \   0000000C   0xFB90 0xF0F1      SDIVLT   R0,R0,R1
   \   00000010   0xB2C0             UXTB     R0,R0
   \   00000012   0x....             B.N      Codec_VolumeCtrl
    397          }
    398          
    399          /**
    400            * @brief  Enables or disables the MUTE mode by software 
    401            * @param  Command: could be AUDIO_MUTE_ON to mute sound or AUDIO_MUTE_OFF to 
    402            *         unmute the codec and restore previous volume level.
    403            * @retval 0 if correct communication, else wrong communication
    404            */

   \                                 In section .text, align 2, keep-with-next
    405          uint32_t AUDIO_Mute(uint32_t Cmd)
    406          { 
    407            /* Call the Codec Mute function */
    408            return (Codec_Mute(Cmd));
   \                     AUDIO_Mute: (+1)
   \   00000000   0x....             B.N      Codec_Mute
    409          }
    410          
    411          /**
    412            * @brief  This function handles main Media layer interrupt. 
    413            * @param  None
    414            * @retval 0 if correct communication, else wrong communication
    415            */

   \                                 In section .text, align 2, keep-with-next
    416          static void Audio_MAL_IRQHandler(void)
    417          {    
   \                     Audio_MAL_IRQHandler: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
    418            uint16_t *pAddr = (uint16_t *)CurrentPos;
                             ^
Warning[Pe177]: variable "pAddr" was declared but never referenced
    419            uint32_t Size = AudioRemSize;
                            ^
Warning[Pe177]: variable "Size" was declared but never referenced
    420            
    421          #ifdef AUDIO_MAL_DMA_IT_TC_EN
    422            /* Transfer complete interrupt */
    423            if (__HAL_DMA_GET_FLAG(&DmaHandle,AUDIO_I2S_DMA_FLAG_TC)!=RESET)
   \   00000002   0x.... 0x....      LDR.W    R4,??DataTable14_5
   \   00000006   0x.... 0x....      LDR.W    R7,??DataTable14_11  ;; 0x40026459
   \   0000000A   0x.... 0x....      LDR.W    R5,??DataTable14_12  ;; 0x40026400
   \   0000000E   0x.... 0x....      LDR.W    R2,??DataTable14_13  ;; 0x40026000
   \   00000012   0x6820             LDR      R0,[R4, #+0]
   \   00000014   0x.... 0x....      LDR.W    R3,??DataTable14_14  ;; 0x40026059
   \   00000018   0x.... 0x....      LDR.W    R6,??DataTable14_15  ;; 0x400260b9
   \   0000001C   0x42B8             CMP      R0,R7
   \   0000001E   0xBF28             IT       CS 
   \   00000020   0x6869             LDRCS    R1,[R5, #+4]
   \   00000022   0xD207             BCS.N    ??Audio_MAL_IRQHandler_0
   \   00000024   0x42B0             CMP      R0,R6
   \   00000026   0xBF28             IT       CS 
   \   00000028   0x6829             LDRCS    R1,[R5, #+0]
   \   0000002A   0xD203             BCS.N    ??Audio_MAL_IRQHandler_0
   \   0000002C   0x4298             CMP      R0,R3
   \   0000002E   0xBF2C             ITE      CS 
   \   00000030   0x6851             LDRCS    R1,[R2, #+4]
   \   00000032   0x6811             LDRCC    R1,[R2, #+0]
   \                     ??Audio_MAL_IRQHandler_0: (+1)
   \   00000034   0xF011 0x6C00      ANDS     R12,R1,#0x8000000
   \   00000038   0xD051             BEQ.N    ??Audio_MAL_IRQHandler_1
    424            {         
    425              /* Check if the end of file has been reached */
    426              if (AudioRemSize > 0)
   \   0000003A   0xF8D4 0xE054      LDR      LR,[R4, #+84]
   \   0000003E   0xF04F 0x6100      MOV      R1,#+134217728
   \   00000042   0xF1BE 0x0F00      CMP      LR,#+0
   \   00000046   0xD030             BEQ.N    ??Audio_MAL_IRQHandler_2
    427              {      
    428                /* Wait the DMA Stream to be effectively disabled */
    429                //while (HAL_DMA_GetState(&DmaHandle) != DISABLE)
    430                //{}
    431                
    432                /* Clear the Interrupt flag */
    433                __HAL_DMA_CLEAR_FLAG(&DmaHandle, AUDIO_I2S_DMA_FLAG_TC);
   \   00000048   0x42B8             CMP      R0,R7
   \   0000004A   0xBF28             IT       CS 
   \   0000004C   0x60E9             STRCS    R1,[R5, #+12]
   \   0000004E   0xD207             BCS.N    ??Audio_MAL_IRQHandler_3
   \   00000050   0x42B0             CMP      R0,R6
   \   00000052   0xBF28             IT       CS 
   \   00000054   0x60A9             STRCS    R1,[R5, #+8]
   \   00000056   0xD203             BCS.N    ??Audio_MAL_IRQHandler_3
   \   00000058   0x4298             CMP      R0,R3
   \   0000005A   0xBF2C             ITE      CS 
   \   0000005C   0x60D1             STRCS    R1,[R2, #+12]
   \   0000005E   0x6091             STRCC    R1,[R2, #+8]
    434                    
    435                /* Re-Configure the buffer address and size */
    436                 DmaHandle.Instance->M0AR = (uint32_t) CurrentPos;
   \                     ??Audio_MAL_IRQHandler_3: (+1)
   \   00000060   0x6DA1             LDR      R1,[R4, #+88]
    437                 DmaHandle.Instance->NDTR = (uint32_t) (DMA_MAX(AudioRemSize));    
   \   00000062   0xF64F 0x75FF      MOVW     R5,#+65535
   \   00000066   0x60C1             STR      R1,[R0, #+12]
   \   00000068   0x6D61             LDR      R1,[R4, #+84]
   \   0000006A   0xF5B1 0x3F80      CMP      R1,#+65536
   \   0000006E   0xBF28             IT       CS 
   \   00000070   0x4629             MOVCS    R1,R5
   \   00000072   0x6041             STR      R1,[R0, #+4]
    438                /* Configure the DMA Stream with the new parameters */
    439                HAL_DMA_Init(&DmaHandle);
   \   00000074   0x4620             MOV      R0,R4
   \   00000076   0x.... 0x....      BL       HAL_DMA_Init
    440                
    441                /* Enable the I2S DMA Stream*/
    442          	  __HAL_DMA_ENABLE(&DmaHandle);
   \   0000007A   0x6820             LDR      R0,[R4, #+0]
   \   0000007C   0x6801             LDR      R1,[R0, #+0]
   \   0000007E   0xF041 0x0101      ORR      R1,R1,#0x1
   \   00000082   0x6001             STR      R1,[R0, #+0]
    443                
    444                /* Update the current pointer position */
    445                CurrentPos += DMA_MAX(AudioRemSize);        
   \   00000084   0x6D61             LDR      R1,[R4, #+84]
   \   00000086   0xF5B1 0x3F80      CMP      R1,#+65536
   \   0000008A   0xBF34             ITE      CC 
   \   0000008C   0x460A             MOVCC    R2,R1
   \   0000008E   0x462A             MOVCS    R2,R5
   \   00000090   0x6DA3             LDR      R3,[R4, #+88]
   \   00000092   0xEB03 0x0242      ADD      R2,R3,R2, LSL #+1
   \   00000096   0x65A2             STR      R2,[R4, #+88]
    446                
    447                /* Update the remaining number of data to be played */
    448                AudioRemSize -= DMA_MAX(AudioRemSize);   
   \   00000098   0xBF38             IT       CC 
   \   0000009A   0x460D             MOVCC    R5,R1
   \   0000009C   0x1B49             SUBS     R1,R1,R5
   \   0000009E   0x6561             STR      R1,[R4, #+84]
    449          
    450          	  /* Enable the I2S DMA Stream*/
    451                __HAL_DMA_ENABLE(&DmaHandle);
   \   000000A0   0x6801             LDR      R1,[R0, #+0]
   \   000000A2   0xF041 0x0101      ORR      R1,R1,#0x1
   \   000000A6   0x6001             STR      R1,[R0, #+0]
   \   000000A8   0xBDF1             POP      {R0,R4-R7,PC}
    452              }
    453              else
    454              {
    455                /* Disable the I2S DMA Stream*/
    456                __HAL_DMA_DISABLE(&DmaHandle);   
   \                     ??Audio_MAL_IRQHandler_2: (+1)
   \   000000AA   0xF8D0 0xE000      LDR      LR,[R0, #+0]
    457                
    458                /* Clear the Interrupt flag */
    459                 __HAL_DMA_CLEAR_FLAG(&DmaHandle, AUDIO_I2S_DMA_FLAG_TC);       
   \   000000AE   0x42B8             CMP      R0,R7
   \   000000B0   0xEA4F 0x0E5E      LSR      LR,LR,#+1
   \   000000B4   0xEA4F 0x0E4E      LSL      LR,LR,#+1
   \   000000B8   0xF8C0 0xE000      STR      LR,[R0, #+0]
   \   000000BC   0xBF28             IT       CS 
   \   000000BE   0x60E9             STRCS    R1,[R5, #+12]
   \   000000C0   0xD207             BCS.N    ??Audio_MAL_IRQHandler_4
   \   000000C2   0x42B0             CMP      R0,R6
   \   000000C4   0xBF28             IT       CS 
   \   000000C6   0x60A9             STRCS    R1,[R5, #+8]
   \   000000C8   0xD203             BCS.N    ??Audio_MAL_IRQHandler_4
   \   000000CA   0x4298             CMP      R0,R3
   \   000000CC   0xBF2C             ITE      CS 
   \   000000CE   0x60D1             STRCS    R1,[R2, #+12]
   \   000000D0   0x6091             STRCC    R1,[R2, #+8]
    460                
    461                /* Manage the remaining file size and new address offset: This function 
    462                should be coded by user (its prototype is already declared in stm32f4_discovery_audio_codec.h) */  
    463                AUDIO_TransferComplete_CallBack((uint32_t)CurrentPos, 0);       
   \                     ??Audio_MAL_IRQHandler_4: (+1)
   \   000000D2   0x6DA0             LDR      R0,[R4, #+88]
   \   000000D4   0x2100             MOVS     R1,#+0
   \   000000D6   0xE8BD 0x40F4      POP      {R2,R4-R7,LR}
   \   000000DA   0x.... 0x....      B.W      AUDIO_TransferComplete_CallBack
    464              }
    465              
    466           
    467            }
    468          #endif /* AUDIO_MAL_DMA_IT_TC_EN */
    469          
    470          #ifdef AUDIO_MAL_DMA_IT_HT_EN  
    471            /* Half Transfer complete interrupt */
    472            //if (DMA_GetFlagStatus(AUDIO_I2S_DMA_STREAM, AUDIO_I2S_DMA_FLAG_HT) != RESET)
    473            if (__HAL_DMA_GET_FLAG(&DmaHandle, AUDIO_I2S_DMA_FLAG_HT) != RESET)
    474            {
    475              /* Manage the remaining file size and new address offset: This function 
    476                 should be coded by user (its prototype is already declared in stm32f4_discovery_audio_codec.h) */  
    477              AUDIO_HalfTransfer_CallBack((uint32_t)pAddr, Size);    
    478             
    479              /* Clear the Interrupt flag */
    480          	__HAL_DMA_CLEAR_FLAG(&DmaHandle, AUDIO_I2S_DMA_FLAG_HT); 
    481          
    482            }
    483          #endif /* AUDIO_MAL_DMA_IT_HT_EN */
    484            
    485          #ifdef AUDIO_MAL_DMA_IT_TE_EN  
    486            /* FIFO Error interrupt */
    487            if ((__HAL_DMA_GET_FLAG(&DmaHandle, AUDIO_I2S_DMA_FLAG_TE) != RESET) || \
    488               (__HAL_DMA_GET_FLAG(&DmaHandle, AUDIO_I2S_DMA_FLAG_FE) != RESET) || \
    489               (__HAL_DMA_GET_FLAG(&DmaHandle, AUDIO_I2S_DMA_FLAG_DME) != RESET))
    490              
    491            {
    492              /* Manage the error generated on DMA FIFO: This function 
    493                 should be coded by user (its prototype is already declared in stm32f4_discovery_audio_codec.h) */  
    494              AUDIO_Error_CallBack((uint32_t*)&pAddr);    
    495              
    496              /* Clear the Interrupt flag */
    497              __HAL_DMA_CLEAR_FLAG(&DmaHandle, AUDIO_I2S_DMA_FLAG_TE | AUDIO_I2S_DMA_FLAG_FE | \
    498                                                  AUDIO_I2S_DMA_FLAG_DME);
    499            }  
    500          #endif /* AUDIO_MAL_DMA_IT_TE_EN */
    501          }
   \                     ??Audio_MAL_IRQHandler_1: (+1)
   \   000000DE   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    502          
    503          /**
    504            * @brief  This function handles main I2S interrupt. 
    505            * @param  None
    506            * @retval 0 if correct communication, else wrong communication
    507            */

   \                                 In section .text, align 2, keep-with-next
    508          void DMA1_Stream7_IRQHandler(void)
    509          { 
    510              //Audio_MAL_IRQHandler();
    511          	HAL_DMA_IRQHandler(hi2s3.hdmatx);
   \                     DMA1_Stream7_IRQHandler: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable14
   \   00000004   0x6B00             LDR      R0,[R0, #+48]
   \   00000006   0x.... 0x....      B.W      HAL_DMA_IRQHandler
    512          }
    513          
    514          /**
    515            * @brief  This function handles main DAC interrupt. 
    516            * @param  None
    517             * @retval None
    518            */

   \                                 In section .text, align 2, keep-with-next
    519          void DMA1_Stream0_IRQHandler(void)
    520          { 
    521            Audio_MAL_IRQHandler();
   \                     DMA1_Stream0_IRQHandler: (+1)
   \   00000000   0x....             B.N      Audio_MAL_IRQHandler
    522          }
    523          
    524          /**
    525            * @brief  I2S interrupt management
    526            * @param  None
    527            * @retval None
    528            */

   \                                 In section .text, align 2, keep-with-next
    529          void SPI3_IRQHandler(void)
    530          {
    531            /* Check on the I2S TXE flag */  
    532            if (__HAL_SPI_GET_FLAG(&hi2s3, SPI_IT_TXE) != RESET)
   \                     SPI3_IRQHandler: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable14
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x6880             LDR      R0,[R0, #+8]
   \   00000008   0x0600             LSLS     R0,R0,#+24
   \   0000000A   0xD400             BMI.N    ??SPI3_IRQHandler_0
   \   0000000C   0x4770             BX       LR
    533            { 
    534             
    535              /* Send dummy data on I2S to avoid the underrun condition */
    536               SPI_I2S_SendData(CODEC_I2S, AUDIO_GetSampleCallBack()); 
   \                     ??SPI3_IRQHandler_0: (+1)
   \   0000000E   0xB580             PUSH     {R7,LR}
   \   00000010   0x.... 0x....      BL       AUDIO_GetSampleCallBack
   \   00000014   0x.... 0x....      LDR.W    R1,??DataTable14_16  ;; 0x40003c0c
   \   00000018   0x6008             STR      R0,[R1, #+0]
    537            }
    538          }
   \   0000001A   0xBD01             POP      {R0,PC}          ;; return
    539          /*========================
    540                          CS43L22 Audio Codec Control Functions
    541                                                          ==============================*/
    542          /**
    543            * @brief  Initializes the audio codec and all related interfaces (control 
    544            *         interface: I2C and audio interface: I2S)
    545            * @param  OutputDevice: can be OUTPUT_DEVICE_SPEAKER, OUTPUT_DEVICE_HEADPHONE,
    546            *                       OUTPUT_DEVICE_BOTH or OUTPUT_DEVICE_AUTO .
    547            * @param  Volume: Initial volume level (from 0 (Mute) to 100 (Max))
    548            * @param  AudioFreq: Audio frequency used to play the audio stream.
    549            * @retval 0 if correct communication, else wrong communication
    550            */

   \                                 In section .text, align 2, keep-with-next
    551          static uint32_t Codec_Init(uint16_t OutputDevice, uint8_t Volume, uint32_t AudioFreq)
    552          {
   \                     Codec_Init: (+1)
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
    553            uint32_t counter = 0; 
    554          
    555            /* Configure the Codec related IOs */
    556            Codec_GPIO_Init();   
   \   00000004   0x.... 0x....      LDR.W    R7,??DataTable14_17  ;; 0x40023830
   \   00000008   0xB08D             SUB      SP,SP,#+52
   \   0000000A   0x468B             MOV      R11,R1
   \   0000000C   0x4614             MOV      R4,R2
   \   0000000E   0x6838             LDR      R0,[R7, #+0]
   \   00000010   0xA907             ADD      R1,SP,#+28
   \   00000012   0x.... 0x....      LDR.W    R6,??DataTable14_7
   \   00000016   0xF040 0x0008      ORR      R0,R0,#0x8
   \   0000001A   0x6038             STR      R0,[R7, #+0]
   \   0000001C   0x6838             LDR      R0,[R7, #+0]
   \   0000001E   0xF000 0x0008      AND      R0,R0,#0x8
   \   00000022   0x9000             STR      R0,[SP, #+0]
   \   00000024   0x9800             LDR      R0,[SP, #+0]
   \   00000026   0x2010             MOVS     R0,#+16
   \   00000028   0x9007             STR      R0,[SP, #+28]
   \   0000002A   0x2001             MOVS     R0,#+1
   \   0000002C   0x9008             STR      R0,[SP, #+32]
   \   0000002E   0x2003             MOVS     R0,#+3
   \   00000030   0x900A             STR      R0,[SP, #+40]
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0x9009             STR      R0,[SP, #+36]
   \   00000036   0x.... 0x....      LDR.W    R0,??DataTable14_10  ;; 0x40020c00
   \   0000003A   0x.... 0x....      BL       HAL_GPIO_Init
    557            
    558            /* Reset the Codec Registers */
    559            Codec_Reset();
   \   0000003E   0x.... 0x....      BL       Codec_Reset
    560          
    561            /* Initialize the Control interface of the Audio Codec */
    562            Codec_CtrlInterface_Init();     
   \   00000042   0x.... 0x....      BL       MX_I2C1_Init
    563            
    564            /* Keep Codec powered OFF */
    565            counter += Codec_WriteRegister(0x02, 0x01);  
   \   00000046   0x.... 0x....      BL       ?Subroutine2
   \                     ??CrossCallReturnLabel_9: (+1)
   \   0000004A   0x4605             MOV      R5,R0
    566                
    567            counter += Codec_WriteRegister(0x04, 0xAF); /* SPK always OFF & HP always ON */
   \   0000004C   0x21AF             MOVS     R1,#+175
   \   0000004E   0x2004             MOVS     R0,#+4
   \   00000050   0x.... 0x....      BL       Codec_WriteRegister
   \   00000054   0x9006             STR      R0,[SP, #+24]
    568            OutputDev = 0xAF;
   \   00000056   0x20AF             MOVS     R0,#+175
   \   00000058   0x7030             STRB     R0,[R6, #+0]
    569            
    570            /* Clock configuration: Auto detection */  
    571            counter += Codec_WriteRegister(0x05, 0x81);
   \   0000005A   0x2181             MOVS     R1,#+129
   \   0000005C   0x2005             MOVS     R0,#+5
   \   0000005E   0x.... 0x....      BL       Codec_WriteRegister
   \   00000062   0x9005             STR      R0,[SP, #+20]
    572            
    573            /* Set the Slave Mode and the audio Standard */  
    574            counter += Codec_WriteRegister(0x06, CODEC_STANDARD);
   \   00000064   0x2104             MOVS     R1,#+4
   \   00000066   0x2006             MOVS     R0,#+6
   \   00000068   0x.... 0x....      BL       Codec_WriteRegister
   \   0000006C   0x9004             STR      R0,[SP, #+16]
    575                
    576            /* Set the Master volume */
    577            Codec_VolumeCtrl(Volume);
   \   0000006E   0x4658             MOV      R0,R11
   \   00000070   0x.... 0x....      BL       Codec_VolumeCtrl
    578            
    579          
    580            /* Power on the Codec */
    581            counter += Codec_WriteRegister(0x02, 0x9E);  
   \   00000074   0x219E             MOVS     R1,#+158
   \   00000076   0x.... 0x....      BL       ??Subroutine2_0
   \                     ??CrossCallReturnLabel_5: (+1)
   \   0000007A   0x9003             STR      R0,[SP, #+12]
    582            
    583            /* Additional configuration for the CODEC. These configurations are done to reduce
    584                the time needed for the Codec to power off. If these configurations are removed, 
    585                then a long delay should be added between powering off the Codec and switching 
    586                off the I2S peripheral MCLK clock (which is the operating clock for Codec).
    587                If this delay is not inserted, then the codec will not shut down properly and
    588                it results in high noise after shut down. */
    589            
    590            /* Disable the analog soft ramp */
    591            counter += Codec_WriteRegister(0x0A, 0x00);
   \   0000007C   0x2100             MOVS     R1,#+0
   \   0000007E   0x200A             MOVS     R0,#+10
   \   00000080   0x.... 0x....      BL       Codec_WriteRegister
   \   00000084   0x9002             STR      R0,[SP, #+8]
    592          
    593          	/* Disable the digital soft ramp */
    594          	counter += Codec_WriteRegister(0x0E, 0x04);
   \   00000086   0x2104             MOVS     R1,#+4
   \   00000088   0x200E             MOVS     R0,#+14
   \   0000008A   0x.... 0x....      BL       Codec_WriteRegister
   \   0000008E   0x9001             STR      R0,[SP, #+4]
    595          
    596            /* Disable the limiter attack level */
    597            counter += Codec_WriteRegister(0x27, 0x00);
   \   00000090   0x2100             MOVS     R1,#+0
   \   00000092   0x2027             MOVS     R0,#+39
   \   00000094   0x.... 0x....      BL       Codec_WriteRegister
   \   00000098   0x4683             MOV      R11,R0
    598            /* Adjust Bass and Treble levels */
    599            counter += Codec_WriteRegister(0x1F, 0x0F);
   \   0000009A   0x210F             MOVS     R1,#+15
   \   0000009C   0x201F             MOVS     R0,#+31
   \   0000009E   0x.... 0x....      BL       Codec_WriteRegister
   \   000000A2   0x4680             MOV      R8,R0
    600            /* Adjust PCM volume level */
    601            counter += Codec_WriteRegister(0x1A, 0x0A);
   \   000000A4   0x210A             MOVS     R1,#+10
   \   000000A6   0x201A             MOVS     R0,#+26
   \   000000A8   0x.... 0x....      BL       Codec_WriteRegister
   \   000000AC   0x4681             MOV      R9,R0
    602            counter += Codec_WriteRegister(0x1B, 0x0A);
   \   000000AE   0x210A             MOVS     R1,#+10
   \   000000B0   0x201B             MOVS     R0,#+27
   \   000000B2   0x.... 0x....      BL       Codec_WriteRegister
   \   000000B6   0x4682             MOV      R10,R0
    603          
    604            /* Configure the I2S peripheral */
    605            Codec_AudioInterface_Init(AudioFreq);  
   \   000000B8   0x6938             LDR      R0,[R7, #+16]
   \   000000BA   0xF440 0x4000      ORR      R0,R0,#0x8000
   \   000000BE   0x6138             STR      R0,[R7, #+16]
   \   000000C0   0x6938             LDR      R0,[R7, #+16]
   \   000000C2   0xF400 0x4000      AND      R0,R0,#0x8000
   \   000000C6   0x9000             STR      R0,[SP, #+0]
   \   000000C8   0x9800             LDR      R0,[SP, #+0]
   \   000000CA   0x.... 0x....      LDR.W    R0,??DataTable14_9  ;; 0x40003c00
   \   000000CE   0x61B4             STR      R4,[R6, #+24]
   \   000000D0   0x6070             STR      R0,[R6, #+4]
   \   000000D2   0x2000             MOVS     R0,#+0
   \   000000D4   0x60F0             STR      R0,[R6, #+12]
   \   000000D6   0x6130             STR      R0,[R6, #+16]
   \   000000D8   0x61F0             STR      R0,[R6, #+28]
   \   000000DA   0x2002             MOVS     R0,#+2
   \   000000DC   0x6230             STR      R0,[R6, #+32]
   \   000000DE   0xF44F 0x7000      MOV      R0,#+512
   \   000000E2   0x60B0             STR      R0,[R6, #+8]
   \   000000E4   0x6170             STR      R0,[R6, #+20]
   \   000000E6   0x1D30             ADDS     R0,R6,#+4
   \   000000E8   0x.... 0x....      BL       HAL_I2S_Init
    606            
    607            /* Return communication control value */
    608            return counter;  
   \   000000EC   0x9806             LDR      R0,[SP, #+24]
   \   000000EE   0x9905             LDR      R1,[SP, #+20]
   \   000000F0   0x1940             ADDS     R0,R0,R5
   \   000000F2   0x1808             ADDS     R0,R1,R0
   \   000000F4   0x9904             LDR      R1,[SP, #+16]
   \   000000F6   0x1808             ADDS     R0,R1,R0
   \   000000F8   0x9903             LDR      R1,[SP, #+12]
   \   000000FA   0x1808             ADDS     R0,R1,R0
   \   000000FC   0x9902             LDR      R1,[SP, #+8]
   \   000000FE   0x1808             ADDS     R0,R1,R0
   \   00000100   0x9901             LDR      R1,[SP, #+4]
   \   00000102   0xB00D             ADD      SP,SP,#+52
   \   00000104   0x1808             ADDS     R0,R1,R0
   \   00000106   0x4458             ADD      R0,R11,R0
   \   00000108   0x4440             ADD      R0,R8,R0
   \   0000010A   0x4448             ADD      R0,R9,R0
   \   0000010C   0x4450             ADD      R0,R10,R0
   \   0000010E   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    609          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine2: (+1)
   \   00000000   0x2101             MOVS     R1,#+1
   \                     ??Subroutine2_0: (+1)
   \   00000002   0x2002             MOVS     R0,#+2
   \   00000004   0x....             B.N      Codec_WriteRegister
    610          
    611          /**
    612            * @brief  Restore the audio codec state to default state and free all used 
    613            *         resources.
    614            * @param  None
    615            * @retval 0 if correct communication, else wrong communication
    616            */
    617          static uint32_t Codec_DeInit(void)
    618          {
    619            uint32_t counter = 0; 
    620          
    621            /* Reset the Codec Registers */
    622            Codec_Reset();  
    623            
    624            /* Keep Codec powered OFF */
    625            counter += Codec_WriteRegister(0x02, 0x01);    
    626            
    627            /* Deinitialize all use GPIOs */
    628            Codec_GPIO_DeInit();
    629          
    630            /* Disable the Codec control interface */
    631            Codec_CtrlInterface_DeInit();
    632            
    633            /* Deinitialize the Codec audio interface (I2S) */
    634            Codec_AudioInterface_DeInit(); 
    635            
    636            /* Return communication control value */
    637            return counter;  
    638          }
    639          
    640          /**
    641            * @brief  Start the audio Codec play feature.
    642            * @note   For this codec no Play options are required.
    643            * @param  None
    644            * @retval 0 if correct communication, else wrong communication
    645            */
    646          static uint32_t Codec_Play(void)
    647          {
    648            /* 
    649               No actions required on Codec level for play command
    650               */  
    651          
    652            /* Return communication control value */
    653            return 0;  
    654          }
    655          
    656          /**
    657            * @brief  Pauses and resumes playing on the audio codec.
    658            * @param  Cmd: AUDIO_PAUSE (or 0) to pause, AUDIO_RESUME (or any value different
    659            *         from 0) to resume. 
    660            * @retval 0 if correct communication, else wrong communication
    661            */
    662          static uint32_t Codec_PauseResume(uint32_t Cmd)
    663          {
    664            uint32_t counter = 0;   
    665            
    666            /* Pause the audio file playing */
    667            if (Cmd == AUDIO_PAUSE)
    668            { 
    669              /* Mute the output first */
    670              counter += Codec_Mute(AUDIO_MUTE_ON);
    671          
    672              /* Put the Codec in Power save mode */    
    673              counter += Codec_WriteRegister(0x02, 0x01);    
    674            }
    675            else /* AUDIO_RESUME */
    676            {
    677              /* Unmute the output first */
    678              counter += Codec_Mute(AUDIO_MUTE_OFF);
    679              
    680              counter += Codec_WriteRegister(0x04, OutputDev);
    681              
    682              /* Exit the Power save mode */
    683              counter += Codec_WriteRegister(0x02, 0x9E); 
    684            }
    685          
    686            return counter;
    687          }
    688          
    689          /**
    690            * @brief  Stops audio Codec playing. It powers down the codec.
    691            * @param  CodecPdwnMode: selects the  power down mode.
    692            *          - CODEC_PDWN_SW: only mutes the audio codec. When resuming from this 
    693            *                           mode the codec keeps the previous initialization
    694            *                           (no need to re-Initialize the codec registers).
    695            *          - CODEC_PDWN_HW: Physically power down the codec. When resuming from this
    696            *                           mode, the codec is set to default configuration 
    697            *                           (user should re-Initialize the codec in order to 
    698            *                            play again the audio stream).
    699            * @retval 0 if correct communication, else wrong communication
    700            */
    701          static uint32_t Codec_Stop(uint32_t CodecPdwnMode)
    702          {
    703            uint32_t counter = 0;   
    704          
    705            /* Mute the output first */
    706            Codec_Mute(AUDIO_MUTE_ON);
    707            
    708            if (CodecPdwnMode == CODEC_PDWN_SW)
    709            {    
    710              /* Power down the DAC and the speaker (PMDAC and PMSPK bits)*/
    711              counter += Codec_WriteRegister(0x02, 0x9F);
    712            }
    713            else /* CODEC_PDWN_HW */
    714            { 
    715              /* Power down the DAC components */
    716              counter += Codec_WriteRegister(0x02, 0x9F);
    717              
    718              /* Wait at least 100us */
    719              Delay(0xFFF);
    720              
    721              /* Reset The pin */
    722              HAL_GPIO_WritePin(AUDIO_RESET_GPIO, AUDIO_RESET_PIN, GPIO_PIN_RESET);
    723            }
    724            
    725            return counter;    
    726          }
    727          
    728          /**
    729            * @brief  Sets higher or lower the codec volume level.
    730            * @param  Volume: a byte value from 0 to 255 (refer to codec registers 
    731            *         description for more details).
    732            * @retval 0 if correct communication, else wrong communication
    733            */

   \                                 In section .text, align 2, keep-with-next
    734          static uint32_t Codec_VolumeCtrl(uint8_t Volume)
    735          {
   \                     Codec_VolumeCtrl: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    736            uint32_t counter = 0;
    737            
    738            if (Volume > 0xE6)
   \   00000002   0xF100 0x0419      ADD      R4,R0,#+25
   \   00000006   0xB2E1             UXTB     R1,R4
    739            {
    740              /* Set the Master volume */
    741              counter += Codec_WriteRegister(0x20, Volume - 0xE7); 
    742              counter += Codec_WriteRegister(0x21, Volume - 0xE7);     
    743            }
    744            else
    745            {
    746              /* Set the Master volume */
    747              counter += Codec_WriteRegister(0x20, Volume + 0x19); 
   \   00000008   0x2020             MOVS     R0,#+32
   \   0000000A   0x.... 0x....      BL       Codec_WriteRegister
   \   0000000E   0x4605             MOV      R5,R0
    748              counter += Codec_WriteRegister(0x21, Volume + 0x19); 
   \   00000010   0xB2E1             UXTB     R1,R4
   \   00000012   0x2021             MOVS     R0,#+33
   \   00000014   0x.... 0x....      BL       Codec_WriteRegister
   \   00000018   0x1940             ADDS     R0,R0,R5
    749            }
    750          
    751            return counter;  
   \   0000001A   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    752          }
    753          
    754          /**
    755            * @brief  Enables or disables the mute feature on the audio codec.
    756            * @param  Cmd: AUDIO_MUTE_ON to enable the mute or AUDIO_MUTE_OFF to disable the
    757            *             mute mode.
    758            * @retval 0 if correct communication, else wrong communication
    759            */

   \                                 In section .text, align 2, keep-with-next
    760          static uint32_t Codec_Mute(uint32_t Cmd)
    761          {
    762            uint32_t counter = 0;  
    763            
    764            /* Set the Mute mode */
    765            if (Cmd == AUDIO_MUTE_ON)
   \                     Codec_Mute: (+1)
   \   00000000   0x2801             CMP      R0,#+1
   \   00000002   0xBF0E             ITEE     EQ 
   \   00000004   0x21FF             MOVEQ    R1,#+255
   \   00000006   0x.... 0x....      LDRNE.W  R0,??DataTable14_7
   \   0000000A   0x7801             LDRBNE   R1,[R0, #+0]
    766            {
    767              counter += Codec_WriteRegister(0x04, 0xFF);
    768            }
    769            else /* AUDIO_MUTE_OFF Disable the Mute */
    770            {
    771              counter += Codec_WriteRegister(0x04, OutputDev);
   \   0000000C   0x2004             MOVS     R0,#+4
   \   0000000E   0x....             B.N      Codec_WriteRegister
    772            }
    773            
    774            return counter; 
    775          }
    776          
    777          /**
    778            * @brief  Resets the audio codec. It restores the default configuration of the 
    779            *         codec (this function shall be called before initializing the codec).
    780            * @note   This function calls an external driver function: The IO Expander driver.
    781            * @param  None
    782            * @retval None
    783            */

   \                                 In section .text, align 2, keep-with-next
    784          static void Codec_Reset(void)
    785          {
   \                     Codec_Reset: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    786            /* Power Down the codec */
    787            HAL_GPIO_WritePin(AUDIO_RESET_GPIO, AUDIO_RESET_PIN, GPIO_PIN_RESET);
   \   00000002   0x.... 0x....      LDR.W    R4,??DataTable14_10  ;; 0x40020c00
   \   00000006   0x2200             MOVS     R2,#+0
   \   00000008   0x2110             MOVS     R1,#+16
   \   0000000A   0x4620             MOV      R0,R4
   \   0000000C   0x.... 0x....      BL       HAL_GPIO_WritePin
    788          
    789            /* wait for a delay to insure registers erasing */
    790            Delay(CODEC_RESET_DELAY); 
   \   00000010   0xF644 0x70FF      MOVW     R0,#+20479
   \   00000014   0x.... 0x....      BL       Delay
    791            
    792            /* Power on the codec */
    793            HAL_GPIO_WritePin(AUDIO_RESET_GPIO, AUDIO_RESET_PIN,GPIO_PIN_SET);
   \   00000018   0x4620             MOV      R0,R4
   \   0000001A   0x2201             MOVS     R2,#+1
   \   0000001C   0x2110             MOVS     R1,#+16
   \   0000001E   0xE8BD 0x4010      POP      {R4,LR}
   \   00000022   0x.... 0x....      B.W      HAL_GPIO_WritePin
    794          }
    795          
    796          /**
    797            * @brief  Writes a Byte to a given register into the audio codec through the 
    798                      control interface (I2C)
    799            * @param  RegisterAddr: The address (location) of the register to be written.
    800            * @param  RegisterValue: the Byte value to be written into destination register.
    801            * @retval 0 if correct communication, else wrong communication
    802            */

   \                                 In section .text, align 2, keep-with-next
    803          static uint32_t Codec_WriteRegister(uint8_t RegisterAddr, uint8_t RegisterValue)
    804          {
   \                     Codec_WriteRegister: (+1)
   \   00000000   0xB57C             PUSH     {R2-R6,LR}
   \   00000002   0x4606             MOV      R6,R0
   \   00000004   0x460C             MOV      R4,R1
    805            uint32_t result = 0;
    806            uint8_t bufI2C[2];
    807            bufI2C[0] = RegisterAddr;
   \   00000006   0xF88D 0x6006      STRB     R6,[SP, #+6]
    808            bufI2C[1] = RegisterValue;
   \   0000000A   0x....             LDR.N    R5,??DataTable14
   \   0000000C   0xF88D 0x4007      STRB     R4,[SP, #+7]
    809            /* Transmit the first address for write operation */
    810            while(HAL_I2C_Master_Transmit(&hi2c1, CODEC_ADDRESS, &bufI2C[0],1,1000))//CODEC_LONG_TIMEOUT
   \                     ??Codec_WriteRegister_0: (+1)
   \   00000010   0xF44F 0x707A      MOV      R0,#+1000
   \   00000014   0x2301             MOVS     R3,#+1
   \   00000016   0x9000             STR      R0,[SP, #+0]
   \   00000018   0xF10D 0x0206      ADD      R2,SP,#+6
   \   0000001C   0x.... 0x....      BL       ?Subroutine5
   \                     ??CrossCallReturnLabel_17: (+1)
   \   00000020   0x2800             CMP      R0,#+0
   \   00000022   0xD1F5             BNE.N    ??Codec_WriteRegister_0
    811            {
    812          	/* Error_Handler() function is called when Timeout error occurs.
    813          	When Acknowledge failure occurs (Slave don't acknowledge its address)
    814          	Master restarts communication */
    815              //if (HAL_I2C_GetError(&hi2c1) != HAL_I2C_ERROR_AF)
    816              //{
    817              //  return Codec_TIMEOUT_UserCallback();;
    818              //}  
    819            }
    820            
    821             while(HAL_I2C_Master_Transmit(&hi2c1, CODEC_ADDRESS, &bufI2C[1],1,1000))//CODEC_LONG_TIMEOUT
   \                     ??Codec_WriteRegister_1: (+1)
   \   00000024   0xF44F 0x707A      MOV      R0,#+1000
   \   00000028   0x2301             MOVS     R3,#+1
   \   0000002A   0x9000             STR      R0,[SP, #+0]
   \   0000002C   0xF10D 0x0207      ADD      R2,SP,#+7
   \   00000030   0x.... 0x....      BL       ?Subroutine5
   \                     ??CrossCallReturnLabel_16: (+1)
   \   00000034   0x2800             CMP      R0,#+0
   \   00000036   0xD1F5             BNE.N    ??Codec_WriteRegister_1
    822            {
    823          	/* Error_Handler() function is called when Timeout error occurs.
    824          	When Acknowledge failure occurs (Slave don't acknowledge its address)
    825          	Master restarts communication */
    826              //if (HAL_I2C_GetError(&hi2c1) != HAL_I2C_ERROR_AF)
    827              //{
    828              //  return Codec_TIMEOUT_UserCallback();;
    829              //}  
    830            }
    831            
    832          #ifdef VERIFY_WRITTENDATA
    833            /* Verify that the data has been correctly written */  
    834            result = (Codec_ReadRegister(RegisterAddr) == RegisterValue)? 0:1;
   \   00000038   0xF88D 0x6005      STRB     R6,[SP, #+5]
   \   0000003C   0xF88D 0x0004      STRB     R0,[SP, #+4]
   \                     ??Codec_WriteRegister_2: (+1)
   \   00000040   0xF44F 0x1096      MOV      R0,#+1228800
   \   00000044   0x2301             MOVS     R3,#+1
   \   00000046   0x9000             STR      R0,[SP, #+0]
   \   00000048   0xF10D 0x0205      ADD      R2,SP,#+5
   \   0000004C   0x.... 0x....      BL       ?Subroutine5
   \                     ??CrossCallReturnLabel_15: (+1)
   \   00000050   0xB130             CBZ.N    R0,??Codec_WriteRegister_3
   \   00000052   0xF105 0x0040      ADD      R0,R5,#+64
   \   00000056   0x.... 0x....      BL       HAL_I2C_GetError
   \   0000005A   0x2804             CMP      R0,#+4
   \   0000005C   0xD0F0             BEQ.N    ??Codec_WriteRegister_2
   \   0000005E   0xE010             B.N      ??Codec_WriteRegister_4
   \                     ??Codec_WriteRegister_3: (+1)
   \   00000060   0xF44F 0x1096      MOV      R0,#+1228800
   \   00000064   0x2301             MOVS     R3,#+1
   \   00000066   0x9000             STR      R0,[SP, #+0]
   \   00000068   0xAA01             ADD      R2,SP,#+4
   \   0000006A   0x2194             MOVS     R1,#+148
   \   0000006C   0xF105 0x0040      ADD      R0,R5,#+64
   \   00000070   0x.... 0x....      BL       HAL_I2C_Master_Receive
   \   00000074   0xB140             CBZ.N    R0,??Codec_WriteRegister_5
   \   00000076   0xF105 0x0040      ADD      R0,R5,#+64
   \   0000007A   0x.... 0x....      BL       HAL_I2C_GetError
   \   0000007E   0x2804             CMP      R0,#+4
   \   00000080   0xD0EE             BEQ.N    ??Codec_WriteRegister_3
   \                     ??Codec_WriteRegister_4: (+1)
   \   00000082   0x.... 0x....      BL       Codec_TIMEOUT_UserCallback
   \   00000086   0xE001             B.N      ??Codec_WriteRegister_6
   \                     ??Codec_WriteRegister_5: (+1)
   \   00000088   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \                     ??Codec_WriteRegister_6: (+1)
   \   0000008C   0x42A0             CMP      R0,R4
   \   0000008E   0xBF0C             ITE      EQ 
   \   00000090   0x2000             MOVEQ    R0,#+0
   \   00000092   0x2001             MOVNE    R0,#+1
   \   00000094   0xBD76             POP      {R1,R2,R4-R6,PC}
    835          #endif /* VERIFY_WRITTENDATA */
    836          
    837            /* Return the verifying value: 0 (Passed) or 1 (Failed) */
    838            return result;  
    839          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine5: (+1)
   \   00000000   0x2194             MOVS     R1,#+148
   \   00000002   0xF105 0x0040      ADD      R0,R5,#+64
   \   00000006   0x.... 0x....      B.W      HAL_I2C_Master_Transmit

   \                                 In section .bss, align 4
   \                     OutputDev:
   \   00000000                      DS8 1
   \   00000001                      DS8 3
   \   00000004                      DS8 64

   \                                 In section .bss, align 4
   \                     hi2s3:
   \   00000000                      DS8 64
   \                     hi2c1:
   \   00000040                      DS8 60
    840          
    841          /**
    842            * @brief  Reads and returns the value of an audio codec register through the
    843            *         control interface (I2C).
    844            * @param  RegisterAddr: Address of the register to be read.
    845            * @retval Value of the register to be read or dummy value if the communication
    846            *         fails.
    847            */
    848          static uint32_t Codec_ReadRegister(uint8_t RegisterAddr)
    849          {
    850            uint8_t result = 0;
    851          
    852            /* Transmit the register address to be read */
    853            /* Transmit the first address for write operation */
    854            while(HAL_I2C_Master_Transmit(&hi2c1, CODEC_ADDRESS, &RegisterAddr,1,CODEC_LONG_TIMEOUT))
    855            {
    856          	/* Error_Handler() function is called when Timeout error occurs.
    857          	When Acknowledge failure occurs (Slave don't acknowledge its address)
    858          	Master restarts communication */
    859              if (HAL_I2C_GetError(&hi2c1) != HAL_I2C_ERROR_AF)
    860              {
    861                return Codec_TIMEOUT_UserCallback();
    862              }  
    863            }
    864            
    865            /*!< Read the byte received from the Codec */
    866            //result = I2C_ReceiveData(CODEC_I2C);
    867            while(HAL_I2C_Master_Receive(&hi2c1, (uint16_t)CODEC_ADDRESS, &result, 1, CODEC_LONG_TIMEOUT) != HAL_OK)
    868            {
    869              /* Error_Handler() function is called when Timeout error occurs.
    870                 When Acknowledge failure occurs (Slave don't acknowledge it's address)
    871                 Master restarts communication */
    872              if (HAL_I2C_GetError(&hi2c1) != HAL_I2C_ERROR_AF)
    873              {
    874                return Codec_TIMEOUT_UserCallback();
    875              }
    876            }
    877            
    878            /* Return the byte read from Codec */
    879            return (uint32_t)result;
    880          }
    881          
    882          /**
    883            * @brief  Initializes the Audio Codec control interface (I2C).
    884            * @param  None
    885            * @retval None
    886            */
    887          static void Codec_CtrlInterface_Init(void)
    888          {
    889              MX_I2C1_Init();   
    890          }
    891          
    892          /**
    893            * @brief  Restore the Audio Codec control interface to its default state.
    894            *         This function doesn't de-initialize the I2C because the I2C peripheral
    895            *         may be used by other modules.
    896            * @param  None
    897            * @retval None
    898            */
    899          static void Codec_CtrlInterface_DeInit(void)
    900          {
    901            /* Disable the I2C peripheral */ /* This step is not done here because 
    902               the I2C interface can be used by other modules */
    903            /* I2C_DeInit(CODEC_I2C); */
    904            HAL_I2C_MspDeInit(&hi2c1);
    905          }
    906          
    907          /**
    908            * @brief  Initializes the Audio Codec audio interface (I2S)
    909            * @note   This function assumes that the I2S input clock (through PLL_R in 
    910            *         Devices RevA/Z and through dedicated PLLI2S_R in Devices RevB/Y)
    911            *         is already configured and ready to be used.    
    912            * @param  AudioFreq: Audio frequency to be configured for the I2S peripheral. 
    913            * @retval None
    914            */
    915          static void Codec_AudioInterface_Init(uint32_t AudioFreq)
    916          {
    917              
    918            static I2S_HandleTypeDef hi2s3;
    919            /* Enable the CODEC_I2S peripheral clock */
    920            __SPI3_CLK_ENABLE();
    921          
    922            hi2s3.Instance = SPI3;
    923            hi2s3.Init.Standard = I2S_STANDARD;
    924            hi2s3.Init.DataFormat = I2S_DATAFORMAT_16B;
    925            hi2s3.Init.AudioFreq = AudioFreq;
    926            hi2s3.Init.CPOL = I2S_CPOL_LOW;
    927            hi2s3.Init.ClockSource = I2S_CLOCK_SYSCLK;
    928            hi2s3.Init.Mode = I2S_MODE_MASTER_TX;
    929          
    930          #ifdef CODEC_MCLK_ENABLED
    931            hi2s3.Init.MCLKOutput = I2S_MCLKOUTPUT_ENABLE;
    932          #elif defined(CODEC_MCLK_DISABLED)
    933            hi2s3.Init.MCLKOutput = I2S_MCLKOUTPUT_DISABLE;
    934          #else
    935          #error "No selection for the MCLK output has been defined !"
    936          #endif /* CODEC_MCLK_ENABLED */
    937            
    938            /* Initialize the I2S peripheral with the structure above */
    939            HAL_I2S_Init(&hi2s3);
    940           
    941            //__HAL_I2S_ENABLE(&hi2s2);
    942            
    943          
    944            /* The I2S peripheral will be enabled only in the AUDIO_Play() function 
    945                 or by user functions if DMA mode not enabled */  
    946          }
    947          
    948          /**
    949            * @brief  Restores the Audio Codec audio interface to its default state.
    950            * @param  None
    951            * @retval None
    952            */
    953          static void Codec_AudioInterface_DeInit(void)
    954          {
    955            /* Disable the CODEC_I2S peripheral (in case it hasn't already been disabled) */
    956            //I2S_Cmd(CODEC_I2S, DISABLE);
    957            __HAL_I2S_DISABLE(&hi2s3);
    958            /* Deinitialize the CODEC_I2S peripheral */
    959            SPI_I2S_DeInit(CODEC_I2S);
    960            
    961            /* Disable the CODEC_I2S peripheral clock */
    962            //RCC_APB1PeriphClockCmd(CODEC_I2S_CLK, DISABLE); 
    963            __HAL_RCC_SPI3_CLK_DISABLE();
    964          }
    965          
    966          /**
    967            * @brief Initializes IOs used by the Audio Codec (on the control and audio 
    968            *        interfaces).
    969            * @param  None
    970            * @retval None
    971            */
    972          static void Codec_GPIO_Init(void)
    973          {
    974            GPIO_InitTypeDef GPIO_InitStructure;
    975            
    976            __GPIOD_CLK_ENABLE();
    977            
    978            /* Audio reset pin configuration -------------------------------------------------*/
    979            GPIO_InitStructure.Pin = AUDIO_RESET_PIN; 
    980            GPIO_InitStructure.Mode = GPIO_MODE_OUTPUT_PP;//GPIO_Mode_OUT;
    981            GPIO_InitStructure.Speed = GPIO_SPEED_HIGH;//GPIO_Speed_50MHz;
    982            GPIO_InitStructure.Pull  = GPIO_NOPULL ;//GPIO_PuPd_NOPULL;
    983             
    984            HAL_GPIO_Init(AUDIO_RESET_GPIO, &GPIO_InitStructure);    
    985            
    986          }
    987          
    988          /**
    989            * @brief  Restores the IOs used by the Audio Codec interface to their default state.
    990            * @param  None
    991            * @retval None
    992            */
    993          static void Codec_GPIO_DeInit(void)
    994          {
    995            GPIO_InitTypeDef GPIO_InitStructure;
    996            
    997            GPIO_InitStructure.Pin = CODEC_I2S_SCK_PIN | CODEC_I2S_SD_PIN; 
    998            GPIO_InitStructure.Mode = GPIO_MODE_INPUT;
    999            GPIO_InitStructure.Speed = GPIO_SPEED_LOW;
   1000            GPIO_InitStructure.Pull = GPIO_NOPULL;
   1001            HAL_GPIO_Init(CODEC_I2S_GPIO, &GPIO_InitStructure);
   1002                
   1003            GPIO_InitStructure.Pin = CODEC_I2S_WS_PIN ;
   1004            HAL_GPIO_Init(CODEC_I2S_WS_GPIO, &GPIO_InitStructure); 
   1005            
   1006          #ifdef CODEC_MCLK_ENABLED
   1007            GPIO_InitStructure.Pin = CODEC_I2S_MCK_PIN; 
   1008            HAL_GPIO_Init(CODEC_I2S_MCK_GPIO, &GPIO_InitStructure); 
   1009          #endif /* CODEC_MCLK_ENABLED */    
   1010          }
   1011          
   1012          /**
   1013            * @brief  Inserts a delay time (not accurate timing).
   1014            * @param  nCount: specifies the delay time length.
   1015            * @retval None
   1016            */

   \                                 In section .text, align 2, keep-with-next
   1017          static void Delay( __IO uint32_t nCount)
   1018          {
   \                     Delay: (+1)
   \   00000000   0xB401             PUSH     {R0}
   \   00000002   0xE002             B.N      ??Delay_0
   1019            for (; nCount != 0; nCount--);
   \                     ??Delay_1: (+1)
   \   00000004   0x9800             LDR      R0,[SP, #+0]
   \   00000006   0x1E40             SUBS     R0,R0,#+1
   \   00000008   0x9000             STR      R0,[SP, #+0]
   \                     ??Delay_0: (+1)
   \   0000000A   0x9800             LDR      R0,[SP, #+0]
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD1F9             BNE.N    ??Delay_1
   1020          }
   \   00000010   0xB001             ADD      SP,SP,#+4
   \   00000012   0x4770             BX       LR               ;; return
   1021          
   1022          #ifdef USE_DEFAULT_TIMEOUT_CALLBACK
   1023          /**
   1024            * @brief  Basic management of the timeout situation.
   1025            * @param  None
   1026            * @retval None
   1027            */
   1028          uint32_t Codec_TIMEOUT_UserCallback(void)
   1029          {
   1030            /* Block communication and all processes */
   1031            
   1032          }
   1033          #endif /* USE_DEFAULT_TIMEOUT_CALLBACK */
   1034          /*========================
   1035                          Audio MAL Interface Control Functions
   1036                                                          ==============================*/
   1037          
   1038          
   1039          /**
   1040            * @brief  Restore default state of the used Media.
   1041            * @param  None
   1042            * @retval None
   1043            */
   1044          static void Audio_MAL_DeInit(void)  
   1045          {   
   1046          #if defined(AUDIO_MAL_DMA_IT_TC_EN) || defined(AUDIO_MAL_DMA_IT_HT_EN) || defined(AUDIO_MAL_DMA_IT_TE_EN)
   1047            //NVIC_InitTypeDef NVIC_InitStructure;  
   1048            
   1049            /* Deinitialize the NVIC interrupt for the I2S DMA Stream */
   1050            //NVIC_InitStructure.NVIC_IRQChannel = AUDIO_I2S_DMA_IRQ;
   1051            //NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = AUDIO_IRQ_PREPRIO;
   1052            //NVIC_InitStructure.NVIC_IRQChannelSubPriority = AUDIO_IRQ_SUBRIO;
   1053            //NVIC_InitStructure.NVIC_IRQChannelCmd = DISABLE;
   1054            //NVIC_Init(&NVIC_InitStructure);  
   1055             HAL_NVIC_DisableIRQ(SPI3_IRQn); 
   1056          #endif 
   1057            
   1058            /* Disable the DMA stream before the deinit */
   1059            HAL_NVIC_DisableIRQ(DMA1_Stream7_IRQn); 
   1060            HAL_NVIC_DisableIRQ(SPI3_IRQn); 
   1061            
   1062          }
   1063          
   1064          /**
   1065            * @brief  Starts playing audio stream from the audio Media.
   1066            * @param  None
   1067            * @retval None
   1068            */

   \                                 In section .text, align 2, keep-with-next
   1069          void Audio_MAL_Play(uint16_t *Addr, uint16_t Size)
   1070          {
   1071             uint16_t *bufAddrI2S;
   1072             bufAddrI2S = Addr;
   1073             HAL_I2S_Transmit_DMA(&hi2s3,bufAddrI2S,(uint16_t)Size/2);  
   \                     Audio_MAL_Play: (+1)
   \   00000000   0x084A             LSRS     R2,R1,#+1
   \   00000002   0x4601             MOV      R1,R0
   \   00000004   0x....             LDR.N    R0,??DataTable14
   \   00000006   0x.... 0x....      B.W      HAL_I2S_Transmit_DMA
   1074          }
   1075          
   1076          /**
   1077            * @brief  Pauses or Resumes the audio stream playing from the Media.
   1078            * @param  Cmd: AUDIO_PAUSE (or 0) to pause, AUDIO_RESUME (or any value different
   1079            *              from 0) to resume. 
   1080            * @param  Addr: Address from/at which the audio stream should resume/pause.
   1081            * @retval None
   1082            */
   1083          static void Audio_MAL_PauseResume(uint32_t Cmd, uint32_t Addr)
   1084          {
   1085            /* Pause the audio file playing */
   1086            if (Cmd == AUDIO_PAUSE)
   1087            {   
   1088              /* Disable the I2S DMA request */
   1089              SPI_I2S_DMACmd(CODEC_I2S, SPI_I2S_DMAReq_Tx, DISABLE);
   1090          
   1091              /* Pause the I2S DMA Stream 
   1092                  Note. For the STM32F40x devices, the DMA implements a pause feature, 
   1093                        by disabling the stream, all configuration is preserved and data 
   1094                        transfer is paused till the next enable of the stream.
   1095                        This feature is not available on STM32F40x devices. */
   1096              DMA_Cmd(AUDIO_I2S_DMA_STREAM, DISABLE);
   1097            }
   1098            else /* AUDIO_RESUME */
   1099            {
   1100              /* Enable the I2S DMA request */
   1101              SPI_I2S_DMACmd(CODEC_I2S, SPI_I2S_DMAReq_Tx, ENABLE);
   1102            
   1103              /* Resume the I2S DMA Stream 
   1104                  Note. For the STM32F40x devices, the DMA implements a pause feature, 
   1105                        by disabling the stream, all configuration is preserved and data 
   1106                        transfer is paused till the next enable of the stream.
   1107                        This feature is not available on STM32F40x devices. */
   1108              DMA_Cmd(AUDIO_I2S_DMA_STREAM, ENABLE);
   1109              
   1110              /* If the I2S peripheral is still not enabled, enable it */
   1111              if ((CODEC_I2S->I2SCFGR & I2S_ENABLE_MASK) == 0)
   1112              {
   1113                I2S_Cmd(CODEC_I2S, ENABLE);
   1114              }    
   1115            } 
   1116          }
   1117          
   1118          /**
   1119            * @brief  Stops audio stream playing on the used Media.
   1120            * @param  None
   1121            * @retval None
   1122            */
   1123          static void Audio_MAL_Stop(void)
   1124          {   
   1125            /* Stop the Transfer on the I2S side: Stop and disable the DMA stream */
   1126            DMA_Cmd(AUDIO_I2S_DMA_STREAM, DISABLE);
   1127          
   1128            /* Clear all the DMA flags for the next transfer */
   1129            DMA_ClearFlag(AUDIO_I2S_DMA_STREAM, AUDIO_I2S_DMA_FLAG_TC |AUDIO_I2S_DMA_FLAG_HT | \
   1130                                            AUDIO_I2S_DMA_FLAG_FE | AUDIO_I2S_DMA_FLAG_TE);
   1131            
   1132            /*  
   1133                     The I2S DMA requests are not disabled here.
   1134                                                                      */
   1135            
   1136            /* In all modes, disable the I2S peripheral */
   1137            I2S_Cmd(CODEC_I2S, DISABLE);
   1138          }
   1139          
   1140          /**
   1141            * @brief  DAC  Channel1 Configuration
   1142            * @param  None
   1143            * @retval None
   1144            */

   \                                 In section .text, align 2, keep-with-next
   1145          void DAC_Config(void)
   1146          {
   1147          
   1148          }
   \                     DAC_Config: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1149          
   1150          static void SPI_I2S_SendData(SPI_TypeDef* SPIx, uint16_t Data)
   1151          {
   1152            /* Check the parameters */
   1153            assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
   1154            
   1155            /* Write in the DR register the data to be sent */
   1156            SPIx->DR = Data;
   1157          }
   1158          
   1159          
   1160          static void I2C_GenerateSTART(I2C_TypeDef* I2Cx, FunctionalState NewState)
                             ^
Warning[Pe177]: function "I2C_GenerateSTART" was declared but never referenced
   1161          {
   1162            /* Check the parameters */
   1163            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
   1164            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1165            if (NewState != DISABLE)
   1166            {
   1167              /* Generate a START condition */
   1168              I2Cx->CR1 |= I2C_CR1_START;
   1169            }
   1170            else
   1171            {
   1172              /* Disable the START condition generation */
   1173              I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_START);
   1174            }
   1175          }
   1176          
   1177          static void I2C_Send7bitAddress(I2C_TypeDef* I2Cx, uint8_t Address, uint8_t I2C_Direction)
                             ^
Warning[Pe177]: function "I2C_Send7bitAddress" was declared but never
          referenced
   1178          {
   1179          
   1180            /* Test on the direction to set/reset the read/write bit */
   1181            if (I2C_Direction != I2C_Direction_Transmitter)
   1182            {
   1183              /* Set the address bit0 for read */
   1184              Address |= I2C_OAR1_ADD0;
   1185            }
   1186            else
   1187            {
   1188              /* Reset the address bit0 for write */
   1189              Address &= (uint8_t)~((uint8_t)I2C_OAR1_ADD0);
   1190            }
   1191            /* Send the address */
   1192          
   1193            I2Cx->TXDR = Address;
   1194          
   1195          }
   1196          
   1197          
   1198          /*
   1199           ===============================================================================
   1200                                    1. Basic state monitoring                    
   1201           ===============================================================================  
   1202           */
   1203          
   1204          /**
   1205            * @brief  Checks whether the last I2Cx Event is equal to the one passed
   1206            *         as parameter.
   1207            * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
   1208            * @param  I2C_EVENT: specifies the event to be checked. 
   1209            *          This parameter can be one of the following values:
   1210            *            @arg I2C_EVENT_SLAVE_TRANSMITTER_ADDRESS_MATCHED: EV1
   1211            *            @arg I2C_EVENT_SLAVE_RECEIVER_ADDRESS_MATCHED: EV1
   1212            *            @arg I2C_EVENT_SLAVE_TRANSMITTER_SECONDADDRESS_MATCHED: EV1
   1213            *            @arg I2C_EVENT_SLAVE_RECEIVER_SECONDADDRESS_MATCHED: EV1
   1214            *            @arg I2C_EVENT_SLAVE_GENERALCALLADDRESS_MATCHED: EV1
   1215            *            @arg I2C_EVENT_SLAVE_BYTE_RECEIVED: EV2
   1216            *            @arg (I2C_EVENT_SLAVE_BYTE_RECEIVED | I2C_FLAG_DUALF): EV2
   1217            *            @arg (I2C_EVENT_SLAVE_BYTE_RECEIVED | I2C_FLAG_GENCALL): EV2
   1218            *            @arg I2C_EVENT_SLAVE_BYTE_TRANSMITTED: EV3
   1219            *            @arg (I2C_EVENT_SLAVE_BYTE_TRANSMITTED | I2C_FLAG_DUALF): EV3
   1220            *            @arg (I2C_EVENT_SLAVE_BYTE_TRANSMITTED | I2C_FLAG_GENCALL): EV3
   1221            *            @arg I2C_EVENT_SLAVE_ACK_FAILURE: EV3_2
   1222            *            @arg I2C_EVENT_SLAVE_STOP_DETECTED: EV4
   1223            *            @arg I2C_EVENT_MASTER_MODE_SELECT: EV5
   1224            *            @arg I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED: EV6     
   1225            *            @arg I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED: EV6
   1226            *            @arg I2C_EVENT_MASTER_BYTE_RECEIVED: EV7
   1227            *            @arg I2C_EVENT_MASTER_BYTE_TRANSMITTING: EV8
   1228            *            @arg I2C_EVENT_MASTER_BYTE_TRANSMITTED: EV8_2
   1229            *            @arg I2C_EVENT_MASTER_MODE_ADDRESS10: EV9
   1230            *     
   1231            * @note   For detailed description of Events, please refer to section I2C_Events
   1232            *         in stm32f4xx_i2c.h file.
   1233            *    
   1234            * @retval An ErrorStatus enumeration value:
   1235            *           - SUCCESS: Last event is equal to the I2C_EVENT
   1236            *           - ERROR: Last event is different from the I2C_EVENT
   1237            */
   1238          static ErrorStatus I2C_CheckEvent(I2C_TypeDef* I2Cx, uint32_t I2C_EVENT)
                                    ^
Warning[Pe177]: function "I2C_CheckEvent" was declared but never referenced
   1239          {
   1240            uint32_t lastevent = 0;
   1241            ErrorStatus status = ERROR;
   1242          
   1243            
   1244            /* Get the last event value from I2C status register */
   1245            lastevent = I2Cx->ISR;
   1246          
   1247            /* Check whether the last event contains the I2C_EVENT */
   1248            if ((lastevent & I2C_EVENT) == I2C_EVENT)
   1249            {
   1250              /* SUCCESS: last event is equal to I2C_EVENT */
   1251              status = SUCCESS;
   1252            }
   1253            else
   1254            {
   1255              /* ERROR: last event is different from I2C_EVENT */
   1256              status = ERROR;
   1257            }
   1258            /* Return status */
   1259            return status;
   1260          }
   1261          
   1262          
   1263          static void I2C_SendData(I2C_TypeDef* I2Cx, uint8_t Data)
                             ^
Warning[Pe177]: function "I2C_SendData" was declared but never referenced
   1264          {
   1265          
   1266            /* Write in the DR register the data to be sent */
   1267            I2Cx->TXDR = Data;
   1268          }
   1269          
   1270          static void I2C_GenerateSTOP(I2C_TypeDef* I2Cx, FunctionalState NewState)
                             ^
Warning[Pe177]: function "I2C_GenerateSTOP" was declared but never referenced
   1271          {
   1272          
   1273            if (NewState != DISABLE)
   1274            {
   1275              /* Generate a STOP condition */
   1276              I2Cx->CR1 |= I2C_CR1_STOP;
   1277            }
   1278            else
   1279            {
   1280              /* Disable the STOP condition generation */
   1281              I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_STOP);
   1282            }
   1283          }
   1284          
   1285          
   1286          
   1287          /*
   1288           ===============================================================================
   1289                                    3. Flag-based state monitoring                   
   1290           ===============================================================================  
   1291           */
   1292          
   1293          /**
   1294            * @brief  Checks whether the specified I2C flag is set or not.
   1295            * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
   1296            * @param  I2C_FLAG: specifies the flag to check. 
   1297            *          This parameter can be one of the following values:
   1298            *            @arg I2C_FLAG_DUALF: Dual flag (Slave mode)
   1299            *            @arg I2C_FLAG_SMBHOST: SMBus host header (Slave mode)
   1300            *            @arg I2C_FLAG_SMBDEFAULT: SMBus default header (Slave mode)
   1301            *            @arg I2C_FLAG_GENCALL: General call header flag (Slave mode)
   1302            *            @arg I2C_FLAG_TRA: Transmitter/Receiver flag
   1303            *            @arg I2C_FLAG_BUSY: Bus busy flag
   1304            *            @arg I2C_FLAG_MSL: Master/Slave flag
   1305            *            @arg I2C_FLAG_SMBALERT: SMBus Alert flag
   1306            *            @arg I2C_FLAG_TIMEOUT: Timeout or Tlow error flag
   1307            *            @arg I2C_FLAG_PECERR: PEC error in reception flag
   1308            *            @arg I2C_FLAG_OVR: Overrun/Underrun flag (Slave mode)
   1309            *            @arg I2C_FLAG_AF: Acknowledge failure flag
   1310            *            @arg I2C_FLAG_ARLO: Arbitration lost flag (Master mode)
   1311            *            @arg I2C_FLAG_BERR: Bus error flag
   1312            *            @arg I2C_FLAG_TXE: Data register empty flag (Transmitter)
   1313            *            @arg I2C_FLAG_RXNE: Data register not empty (Receiver) flag
   1314            *            @arg I2C_FLAG_STOPF: Stop detection flag (Slave mode)
   1315            *            @arg I2C_FLAG_ADD10: 10-bit header sent flag (Master mode)
   1316            *            @arg I2C_FLAG_BTF: Byte transfer finished flag
   1317            *            @arg I2C_FLAG_ADDR: Address sent flag (Master mode) "ADSL"
   1318            *                                Address matched flag (Slave mode)"ENDAD"
   1319            *            @arg I2C_FLAG_SB: Start bit flag (Master mode)
   1320            * @retval The new state of I2C_FLAG (SET or RESET).
   1321            */
   1322          static FlagStatus I2C_GetFlagStatus(I2C_TypeDef* I2Cx, uint32_t I2C_FLAG)
                                   ^
Warning[Pe177]: function "I2C_GetFlagStatus" was declared but never referenced
   1323          {
   1324            FlagStatus bitstatus = RESET;
   1325            __IO uint32_t i2creg = 0, i2cxbase = 0;
   1326          
   1327          
   1328            /* Get the I2Cx peripheral base address */
   1329            i2cxbase = (uint32_t)I2Cx;
   1330            
   1331            /* Read flag register index */
   1332            i2creg = I2C_FLAG >> 28;
   1333            
   1334            /* Get bit[23:0] of the flag */
   1335            I2C_FLAG &= FLAG_MASK;
   1336            
   1337            if(i2creg != 0)
   1338            {
   1339              /* Get the I2Cx SR1 register address */
   1340              i2cxbase += 0x14;
   1341            }
   1342            else
   1343            {
   1344              /* Flag in I2Cx SR2 Register */
   1345              I2C_FLAG = (uint32_t)(I2C_FLAG >> 16);
   1346              /* Get the I2Cx SR2 register address */
   1347              i2cxbase += 0x18;
   1348            }
   1349            
   1350            if(((*(__IO uint32_t *)i2cxbase) & I2C_FLAG) != (uint32_t)RESET)
   1351            {
   1352              /* I2C_FLAG is set */
   1353              bitstatus = SET;
   1354            }
   1355            else
   1356            {
   1357              /* I2C_FLAG is reset */
   1358              bitstatus = RESET;
   1359            }
   1360            
   1361            /* Return the I2C_FLAG status */
   1362            return  bitstatus;
   1363          }
   1364          
   1365          /**
   1366            * @brief  Enables or disables the specified I2C acknowledge feature.
   1367            * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
   1368            * @param  NewState: new state of the I2C Acknowledgement.
   1369            *          This parameter can be: ENABLE or DISABLE.
   1370            * @retval None.
   1371            */
   1372          static void I2C_AcknowledgeConfig(I2C_TypeDef* I2Cx, FunctionalState NewState)
                             ^
Warning[Pe177]: function "I2C_AcknowledgeConfig" was declared but never
          referenced
   1373          {
   1374            if (NewState != DISABLE)
   1375            {
   1376              /* Enable the acknowledgement */
   1377              I2Cx->CR1 |= I2C_CR1_ACK;
   1378            }
   1379            else
   1380            {
   1381              /* Disable the acknowledgement */
   1382              I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_ACK);
   1383            }
   1384          }
   1385          
   1386          /**
   1387            * @brief  Returns the most recent received data by the I2Cx peripheral.
   1388            * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
   1389            * @retval The value of the received data.
   1390            */
   1391          static uint8_t I2C_ReceiveData(I2C_TypeDef* I2Cx)
                                ^
Warning[Pe177]: function "I2C_ReceiveData" was declared but never referenced
   1392          {
   1393            /* Return the data in the DR register */
   1394            return (uint8_t)I2Cx->RXDR;
   1395          }
   1396          
   1397          /**
   1398            * @brief  Clears the I2Cx's pending flags.
   1399            * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
   1400            * @param  I2C_FLAG: specifies the flag to clear. 
   1401            *          This parameter can be any combination of the following values:
   1402            *            @arg I2C_FLAG_SMBALERT: SMBus Alert flag
   1403            *            @arg I2C_FLAG_TIMEOUT: Timeout or Tlow error flag
   1404            *            @arg I2C_FLAG_PECERR: PEC error in reception flag
   1405            *            @arg I2C_FLAG_OVR: Overrun/Underrun flag (Slave mode)
   1406            *            @arg I2C_FLAG_AF: Acknowledge failure flag
   1407            *            @arg I2C_FLAG_ARLO: Arbitration lost flag (Master mode)
   1408            *            @arg I2C_FLAG_BERR: Bus error flag
   1409            *   
   1410            * @note   STOPF (STOP detection) is cleared by software sequence: a read operation 
   1411            *          to I2C_SR1 register (I2C_GetFlagStatus()) followed by a write operation 
   1412            *          to I2C_CR1 register (I2C_Cmd() to re-enable the I2C peripheral).
   1413            * @note   ADD10 (10-bit header sent) is cleared by software sequence: a read 
   1414            *          operation to I2C_SR1 (I2C_GetFlagStatus()) followed by writing the 
   1415            *          second byte of the address in DR register.
   1416            * @note   BTF (Byte Transfer Finished) is cleared by software sequence: a read 
   1417            *          operation to I2C_SR1 register (I2C_GetFlagStatus()) followed by a 
   1418            *          read/write to I2C_DR register (I2C_SendData()).
   1419            * @note   ADDR (Address sent) is cleared by software sequence: a read operation to 
   1420            *          I2C_SR1 register (I2C_GetFlagStatus()) followed by a read operation to 
   1421            *          I2C_SR2 register ((void)(I2Cx->SR2)).
   1422            * @note   SB (Start Bit) is cleared software sequence: a read operation to I2C_SR1
   1423            *          register (I2C_GetFlagStatus()) followed by a write operation to I2C_DR
   1424            *          register (I2C_SendData()).
   1425            *  
   1426            * @retval None
   1427            */
   1428          static void I2C_ClearFlag(I2C_TypeDef* I2Cx, uint32_t I2C_FLAG)
                             ^
Warning[Pe177]: function "I2C_ClearFlag" was declared but never referenced
   1429          {
   1430            uint32_t flagpos = 0;
   1431          
   1432            /* Get the I2C flag position */
   1433            flagpos = I2C_FLAG & FLAG_MASK;
   1434            /* Clear the selected I2C flag */
   1435            I2Cx->ISR = (uint16_t)~flagpos;
   1436          }
   1437          
   1438          /**
   1439            * @brief  Enables or disables the specified SPI peripheral (in I2S mode).
   1440            * @param  SPIx: where x can be 2 or 3 to select the SPI peripheral (or I2Sxext 
   1441            *         for full duplex mode).
   1442            * @param  NewState: new state of the SPIx peripheral. 
   1443            *         This parameter can be: ENABLE or DISABLE.
   1444            * @retval None
   1445            */

   \                                 In section .text, align 2, keep-with-next
   1446          static void I2S_Cmd(SPI_TypeDef* SPIx, FunctionalState NewState)
   1447          {  
   1448            if (NewState != DISABLE)
   \                     I2S_Cmd: (+1)
   \   00000000   0x2900             CMP      R1,#+0
   \   00000002   0x69C1             LDR      R1,[R0, #+28]
   \   00000004   0xBF12             ITEE     NE 
   \   00000006   0xF441 0x6180      ORRNE    R1,R1,#0x400
   \   0000000A   0xF64F 0x32FF      MOVWEQ   R2,#+64511
   \   0000000E   0x4011             ANDEQ    R1,R2,R1
   1449            {
   1450              /* Enable the selected SPI peripheral (in I2S mode) */
   1451              SPIx->I2SCFGR |= SPI_I2SCFGR_I2SE;
   1452            }
   1453            else
   1454            {
   1455              /* Disable the selected SPI peripheral in I2S mode */
   1456              SPIx->I2SCFGR &= (uint16_t)~((uint16_t)SPI_I2SCFGR_I2SE);
   \   00000010   0x61C1             STR      R1,[R0, #+28]
   1457            }
   1458          }
   \   00000012   0x4770             BX       LR               ;; return
   1459          
   1460          /**
   1461            * @brief  Deinitialize the SPIx peripheral registers to their default reset values.
   1462            * @param  SPIx: To select the SPIx/I2Sx peripheral, where x can be: 1, 2 or 3 
   1463            *         in SPI mode or 2 or 3 in I2S mode.   
   1464            *         
   1465            * @note   The extended I2S blocks (ie. I2S2ext and I2S3ext blocks) are deinitialized
   1466            *         when the relative I2S peripheral is deinitialized (the extended block's clock
   1467            *         is managed by the I2S peripheral clock).
   1468            *             
   1469            * @retval None
   1470            */
   1471          static void SPI_I2S_DeInit(SPI_TypeDef* SPIx)
   1472          {
   1473          
   1474            if (SPIx == SPI1)
   1475            {
   1476              /* Enable SPI1 reset state */
   1477              //RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI1, ENABLE);
   1478              __HAL_RCC_SPI1_CLK_ENABLE();
   1479              /* Release SPI1 from reset state */
   1480              //RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI1, DISABLE);
   1481              __HAL_RCC_SPI1_CLK_DISABLE();
   1482            }
   1483            else if (SPIx == SPI2)
   1484            {
   1485              /* Enable SPI2 reset state */
   1486              //RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI2, ENABLE);
   1487              __HAL_RCC_SPI2_CLK_ENABLE();
   1488              /* Release SPI2 from reset state */
   1489              //RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI2, DISABLE);
   1490              __HAL_RCC_SPI2_CLK_DISABLE();
   1491            }
   1492            else
   1493            {
   1494              if (SPIx == SPI3)
   1495              {
   1496                /* Enable SPI3 reset state */
   1497                //RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI3, ENABLE);
   1498                __HAL_RCC_SPI3_CLK_ENABLE();
   1499                /* Release SPI3 from reset state */
   1500                //RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI3, DISABLE);
   1501                __HAL_RCC_SPI3_CLK_DISABLE();
   1502              }
   1503            }
   1504          }
   1505          
   1506          /**
   1507            * @brief  Enables or disables the specified DMAy Streamx.
   1508            * @param  DMAy_Streamx: where y can be 1 or 2 to select the DMA and x can be 0
   1509            *         to 7 to select the DMA Stream.
   1510            * @param  NewState: new state of the DMAy Streamx. 
   1511            *          This parameter can be: ENABLE or DISABLE.
   1512            *
   1513            * @note  This function may be used to perform Pause-Resume operation. When a
   1514            *        transfer is ongoing, calling this function to disable the Stream will
   1515            *        cause the transfer to be paused. All configuration registers and the
   1516            *        number of remaining data will be preserved. When calling again this
   1517            *        function to re-enable the Stream, the transfer will be resumed from
   1518            *        the point where it was paused.          
   1519            *    
   1520            * @note  After configuring the DMA Stream (DMA_Init() function) and enabling the
   1521            *        stream, it is recommended to check (or wait until) the DMA Stream is
   1522            *        effectively enabled. A Stream may remain disabled if a configuration 
   1523            *        parameter is wrong.
   1524            *        After disabling a DMA Stream, it is also recommended to check (or wait
   1525            *        until) the DMA Stream is effectively disabled. If a Stream is disabled 
   1526            *        while a data transfer is ongoing, the current data will be transferred
   1527            *        and the Stream will be effectively disabled only after the transfer of
   1528            *        this single data is finished.            
   1529            *    
   1530            * @retval None
   1531            */

   \                                 In section .text, align 2, keep-with-next
   1532          static void DMA_Cmd(DMA_Stream_TypeDef* DMAy_Streamx, FunctionalState NewState)
   1533          {
   1534          
   1535          
   1536            if (NewState != DISABLE)
   \                     DMA_Cmd: (+1)
   \   00000000   0x2900             CMP      R1,#+0
   \   00000002   0x6801             LDR      R1,[R0, #+0]
   \   00000004   0xBF12             ITEE     NE 
   \   00000006   0xF041 0x0101      ORRNE    R1,R1,#0x1
   \   0000000A   0x0849             LSREQ    R1,R1,#+1
   \   0000000C   0x0049             LSLEQ    R1,R1,#+1
   1537            {
   1538              /* Enable the selected DMAy Streamx by setting EN bit */
   1539              DMAy_Streamx->CR |= (uint32_t)DMA_SxCR_EN;
   1540            }
   1541            else
   1542            {
   1543              /* Disable the selected DMAy Streamx by clearing EN bit */
   1544              DMAy_Streamx->CR &= ~(uint32_t)DMA_SxCR_EN;
   \   0000000E   0x6001             STR      R1,[R0, #+0]
   1545            }
   1546          }
   \   00000010   0x4770             BX       LR               ;; return
   1547          
   1548          /**
   1549            * @brief  Deinitialize the DMAy Streamx registers to their default reset values.
   1550            * @param  DMAy_Streamx: where y can be 1 or 2 to select the DMA and x can be 0
   1551            *         to 7 to select the DMA Stream.
   1552            * @retval None
   1553            */
   1554          static void DMA_DeInit(DMA_Stream_TypeDef* DMAy_Streamx)
                             ^
Warning[Pe177]: function "DMA_DeInit" was declared but never referenced

  static void     Audio_MAL_Init(void);
                  ^
"H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\Src\audio_codec.c",263  Warning[Pe177]: 
          function "Audio_MAL_Init" was declared but never referenced
   1555          {
   1556          
   1557            /* Disable the selected DMAy Streamx */
   1558            DMAy_Streamx->CR &= ~((uint32_t)DMA_SxCR_EN);
   1559          
   1560            /* Reset DMAy Streamx control register */
   1561            DMAy_Streamx->CR  = 0;
   1562            
   1563            /* Reset DMAy Streamx Number of Data to Transfer register */
   1564            DMAy_Streamx->NDTR = 0;
   1565            
   1566            /* Reset DMAy Streamx peripheral address register */
   1567            DMAy_Streamx->PAR  = 0;
   1568            
   1569            /* Reset DMAy Streamx memory 0 address register */
   1570            DMAy_Streamx->M0AR = 0;
   1571          
   1572            /* Reset DMAy Streamx memory 1 address register */
   1573            DMAy_Streamx->M1AR = 0;
   1574          
   1575            /* Reset DMAy Streamx FIFO control register */
   1576            DMAy_Streamx->FCR = (uint32_t)0x00000021; 
   1577          
   1578           }
   1579          
   1580          /**
   1581            * @brief  Enables or disables the SPIx/I2Sx DMA interface.
   1582            * @param  SPIx: To select the SPIx/I2Sx peripheral, where x can be: 1, 2 or 3 
   1583            *         in SPI mode or 2 or 3 in I2S mode or I2Sxext for I2S full duplex mode. 
   1584            * @param  SPI_I2S_DMAReq: specifies the SPI DMA transfer request to be enabled or disabled. 
   1585            *          This parameter can be any combination of the following values:
   1586            *            @arg SPI_I2S_DMAReq_Tx: Tx buffer DMA transfer request
   1587            *            @arg SPI_I2S_DMAReq_Rx: Rx buffer DMA transfer request
   1588            * @param  NewState: new state of the selected SPI DMA transfer request.
   1589            *          This parameter can be: ENABLE or DISABLE.
   1590            * @retval None
   1591            */

   \                                 In section .text, align 2, keep-with-next
   1592          static void SPI_I2S_DMACmd(SPI_TypeDef* SPIx, uint16_t SPI_I2S_DMAReq, FunctionalState NewState)
   1593          {
   1594            /* Check the parameters */
   1595            assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
   1596            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1597            assert_param(IS_SPI_I2S_DMAREQ(SPI_I2S_DMAReq));
   1598          
   1599            if (NewState != DISABLE)
   \                     SPI_I2S_DMACmd: (+1)
   \   00000000   0x2A00             CMP      R2,#+0
   \   00000002   0x6842             LDR      R2,[R0, #+4]
   \   00000004   0xBF11             ITEEE    NE 
   \   00000006   0x4311             ORRNE    R1,R1,R2
   \   00000008   0x43C9             MVNEQ    R1,R1
   \   0000000A   0xB289             UXTHEQ   R1,R1
   \   0000000C   0x4011             ANDEQ    R1,R1,R2
   1600            {
   1601              /* Enable the selected SPI DMA requests */
   1602              SPIx->CR2 |= SPI_I2S_DMAReq;
   1603            }
   1604            else
   1605            {
   1606              /* Disable the selected SPI DMA requests */
   1607              SPIx->CR2 &= (uint16_t)~SPI_I2S_DMAReq;
   \   0000000E   0x6041             STR      R1,[R0, #+4]
   1608            }
   1609          }
   \   00000010   0x4770             BX       LR               ;; return
   1610          
   1611          static void DMA_ClearFlag(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t DMA_FLAG)
   1612          {
   1613          
   1614            
   1615          }

   \                                 In section .text, align 2, keep-with-next
   1616          void HAL_I2S_MspInit(I2S_HandleTypeDef *hi2s)
   1617          {
   \                     HAL_I2S_MspInit: (+1)
   \   00000000   0xE92D 0x43F0      PUSH     {R4-R9,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0xB08B             SUB      SP,SP,#+44
   1618             GPIO_InitTypeDef GPIO_InitStructure;
   1619          	
   1620             
   1621             GPIO_InitTypeDef GPIO_InitStruct;
   1622            if(hi2s->Instance==SPI1)
   \   00000008   0x....             LDR.N    R1,??DataTable14_18  ;; 0x40013000
   \   0000000A   0x....             LDR.N    R5,??DataTable14_17  ;; 0x40023830
   \   0000000C   0x6820             LDR      R0,[R4, #+0]
   \   0000000E   0x....             LDR.N    R6,??DataTable14_2  ;; 0x40020000
   \   00000010   0x4288             CMP      R0,R1
   \   00000012   0xD116             BNE.N    ??HAL_I2S_MspInit_0
   1623            {
   1624            /* USER CODE BEGIN SPI1_MspInit 0 */
   1625          
   1626            /* USER CODE END SPI1_MspInit 0 */
   1627              /* Peripheral clock enable */
   1628              __SPI1_CLK_ENABLE();
   \   00000014   0x6968             LDR      R0,[R5, #+20]
   1629            
   1630              /**I2S1 GPIO Configuration    
   1631              PA4     ------> I2S1_WS
   1632              PA5     ------> I2S1_CK
   1633              PA7     ------> I2S1_SD 
   1634              */
   1635              GPIO_InitStruct.Pin = GPIO_PIN_4|GPIO_PIN_5|GPIO_PIN_7;
   1636              GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
   1637              GPIO_InitStruct.Pull = GPIO_NOPULL;
   1638              GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
   1639              GPIO_InitStruct.Alternate = GPIO_AF5_SPI1;
   1640              HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
   \   00000016   0xA901             ADD      R1,SP,#+4
   \   00000018   0xF440 0x5080      ORR      R0,R0,#0x1000
   \   0000001C   0x6168             STR      R0,[R5, #+20]
   \   0000001E   0x6968             LDR      R0,[R5, #+20]
   \   00000020   0xF400 0x5080      AND      R0,R0,#0x1000
   \   00000024   0x9000             STR      R0,[SP, #+0]
   \   00000026   0x9800             LDR      R0,[SP, #+0]
   \   00000028   0x20B0             MOVS     R0,#+176
   \   0000002A   0x.... 0x....      BL       ??Subroutine0_0
   \                     ??CrossCallReturnLabel_0: (+1)
   \   0000002E   0x4630             MOV      R0,R6
   \   00000030   0x.... 0x....      BL       HAL_GPIO_Init
   1641          
   1642            /* Peripheral interrupt init*/
   1643              HAL_NVIC_SetPriority(SPI1_IRQn, 1, 1);
   \   00000034   0x2201             MOVS     R2,#+1
   \   00000036   0x2101             MOVS     R1,#+1
   \   00000038   0x2023             MOVS     R0,#+35
   \   0000003A   0x.... 0x....      BL       HAL_NVIC_SetPriority
   1644              HAL_NVIC_EnableIRQ(SPI1_IRQn);
   \   0000003E   0x2023             MOVS     R0,#+35
   \   00000040   0xE0A7             B.N      ??HAL_I2S_MspInit_1
   1645            /* USER CODE BEGIN SPI1_MspInit 1 */
   1646          
   1647            /* USER CODE END SPI1_MspInit 1 */
   1648            }
   1649            else if(hi2s->Instance==SPI2)
   \                     ??HAL_I2S_MspInit_0: (+1)
   \   00000042   0x....             LDR.N    R1,??DataTable14_19  ;; 0x40003800
   \   00000044   0x.... 0x....      LDR.W    R9,??DataTable14_3  ;; 0x40020800
   \   00000048   0x4288             CMP      R0,R1
   \   0000004A   0x.... 0x....      LDR.W    R8,??DataTable14_1  ;; 0x40020400
   \   0000004E   0xF44F 0x4700      MOV      R7,#+32768
   \   00000052   0xD12E             BNE.N    ??HAL_I2S_MspInit_2
   1650            {
   1651            /* USER CODE BEGIN SPI2_MspInit 0 */
   1652          
   1653            /* USER CODE END SPI2_MspInit 0 */
   1654              /* Peripheral clock enable */
   1655              __SPI2_CLK_ENABLE();
   \   00000054   0x6928             LDR      R0,[R5, #+16]
   1656              __GPIOI_CLK_ENABLE();
   1657          	__GPIOB_CLK_ENABLE();
   1658          	__GPIOC_CLK_ENABLE();
   1659            
   1660              /**I2S2 GPIO Configuration     
   1661              PC1     ------> I2S2_SD  : PI3 PC1 PC3 PB15      --> PB15
   1662              PB10     ------> I2S2_CK :PD3 PB10 PB13 PA9 PI1  --> PI1
   1663              PB12     ------> I2S2_WS : PB12 PI0 PB4 PB9      --> PB4
   1664          
   1665              */
   1666              GPIO_InitStruct.Pin = GPIO_PIN_15; //SD
   1667              GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
   1668              GPIO_InitStruct.Pull = GPIO_NOPULL;
   1669              GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
   1670              GPIO_InitStruct.Alternate = GPIO_AF5_SPI2;
   1671              HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
   \   00000056   0xA901             ADD      R1,SP,#+4
   \   00000058   0xF440 0x4080      ORR      R0,R0,#0x4000
   \   0000005C   0x6128             STR      R0,[R5, #+16]
   \   0000005E   0x6928             LDR      R0,[R5, #+16]
   \   00000060   0xF400 0x4080      AND      R0,R0,#0x4000
   \   00000064   0x9000             STR      R0,[SP, #+0]
   \   00000066   0x9800             LDR      R0,[SP, #+0]
   \   00000068   0x6828             LDR      R0,[R5, #+0]
   \   0000006A   0xF440 0x7080      ORR      R0,R0,#0x100
   \   0000006E   0x6028             STR      R0,[R5, #+0]
   \   00000070   0x6828             LDR      R0,[R5, #+0]
   \   00000072   0xF400 0x7080      AND      R0,R0,#0x100
   \   00000076   0x.... 0x....      BL       ?Subroutine4
   \                     ??CrossCallReturnLabel_13: (+1)
   \   0000007A   0x9701             STR      R7,[SP, #+4]
   \   0000007C   0x2002             MOVS     R0,#+2
   \   0000007E   0x.... 0x....      BL       ?Subroutine3
   \                     ??CrossCallReturnLabel_11: (+1)
   \   00000082   0x4640             MOV      R0,R8
   \   00000084   0x.... 0x....      BL       HAL_GPIO_Init
   1672          
   1673          	GPIO_InitStruct.Pin = GPIO_PIN_4;//WS
   \   00000088   0x2010             MOVS     R0,#+16
   1674              GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
   1675              GPIO_InitStruct.Pull = GPIO_NOPULL;
   1676              GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
   1677              GPIO_InitStruct.Alternate = GPIO_AF5_SPI2;
   1678              HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
   \   0000008A   0x.... 0x....      BL       ?Subroutine0
   \                     ??CrossCallReturnLabel_1: (+1)
   \   0000008E   0x4640             MOV      R0,R8
   \   00000090   0x.... 0x....      BL       HAL_GPIO_Init
   1679          
   1680              GPIO_InitStruct.Pin = GPIO_PIN_1;//CK
   \   00000094   0x2002             MOVS     R0,#+2
   1681              GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
   1682              GPIO_InitStruct.Pull = GPIO_NOPULL;
   1683              GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
   1684              GPIO_InitStruct.Alternate = GPIO_AF5_SPI2;
   1685              HAL_GPIO_Init(GPIOI, &GPIO_InitStruct);
   \   00000096   0xA901             ADD      R1,SP,#+4
   \   00000098   0x9001             STR      R0,[SP, #+4]
   \   0000009A   0x.... 0x....      BL       ?Subroutine3
   \                     ??CrossCallReturnLabel_12: (+1)
   \   0000009E   0x....             LDR.N    R0,??DataTable14_20  ;; 0x40022000
   \   000000A0   0x.... 0x....      BL       HAL_GPIO_Init
   1686          
   1687              GPIO_InitStruct.Pin = GPIO_PIN_6;//CK
   \   000000A4   0x2040             MOVS     R0,#+64
   1688              GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
   1689              GPIO_InitStruct.Pull = GPIO_NOPULL;
   1690              GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
   1691              GPIO_InitStruct.Alternate = GPIO_AF5_SPI2;
   1692              HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
   \   000000A6   0x.... 0x....      BL       ?Subroutine0
   1693          
   1694          
   1695          
   1696              /* Peripheral interrupt init*/
   1697              //HAL_NVIC_SetPriority(SPI2_IRQn, 6, 0);
   1698              //HAL_NVIC_EnableIRQ(SPI2_IRQn);
   1699              /* USER CODE BEGIN SPI2_MspInit 1 */
   1700          
   1701            /* USER CODE END SPI2_MspInit 1 */
   1702            }
   \                     ??CrossCallReturnLabel_2: (+1)
   \   000000AA   0x4648             MOV      R0,R9
   \   000000AC   0x.... 0x....      BL       HAL_GPIO_Init
   \   000000B0   0xE071             B.N      ??HAL_I2S_MspInit_3
   1703            else if(hi2s->Instance==SPI3)
   \                     ??HAL_I2S_MspInit_2: (+1)
   \   000000B2   0x....             LDR.N    R1,??DataTable14_9  ;; 0x40003c00
   \   000000B4   0x4288             CMP      R0,R1
   \   000000B6   0xD16E             BNE.N    ??HAL_I2S_MspInit_3
   1704            {
   1705          
   1706          
   1707            
   1708              /**I2S3 GPIO Configuration    
   1709              PB2     ------> I2S3_SD
   1710              PA15     ------> I2S3_WS
   1711              PB3     ------> I2S3_CK 
   1712          	 PC7    ------> MCLK
   1713              */
   1714           
   1715            /* USER CODE BEGIN SPI3_MspInit 1 */
   1716            __SPI3_CLK_ENABLE();
   \   000000B8   0x6928             LDR      R0,[R5, #+16]
   1717            __GPIOA_CLK_ENABLE();
   1718            __GPIOB_CLK_ENABLE();
   1719            __GPIOC_CLK_ENABLE();
   1720            GPIO_InitStructure.Pin = GPIO_PIN_3 | GPIO_PIN_2; 
   1721            GPIO_InitStructure.Mode = GPIO_MODE_AF_PP;
   1722            GPIO_InitStructure.Speed = GPIO_SPEED_HIGH;
   1723            GPIO_InitStructure.Pull = GPIO_NOPULL;
   1724            GPIO_InitStructure.Alternate = GPIO_AF6_SPI3;
   1725            HAL_GPIO_Init(GPIOB, &GPIO_InitStructure);
   \   000000BA   0xA906             ADD      R1,SP,#+24
   \   000000BC   0xF440 0x4000      ORR      R0,R0,#0x8000
   \   000000C0   0x6128             STR      R0,[R5, #+16]
   \   000000C2   0x6928             LDR      R0,[R5, #+16]
   \   000000C4   0xF400 0x4000      AND      R0,R0,#0x8000
   \   000000C8   0x9000             STR      R0,[SP, #+0]
   \   000000CA   0x9800             LDR      R0,[SP, #+0]
   \   000000CC   0x6828             LDR      R0,[R5, #+0]
   \   000000CE   0xF040 0x0001      ORR      R0,R0,#0x1
   \   000000D2   0x6028             STR      R0,[R5, #+0]
   \   000000D4   0x6828             LDR      R0,[R5, #+0]
   \   000000D6   0xF000 0x0001      AND      R0,R0,#0x1
   \   000000DA   0x.... 0x....      BL       ?Subroutine4
   \                     ??CrossCallReturnLabel_14: (+1)
   \   000000DE   0x200C             MOVS     R0,#+12
   \   000000E0   0x.... 0x....      BL       ?Subroutine1
   \                     ??CrossCallReturnLabel_3: (+1)
   \   000000E4   0x4640             MOV      R0,R8
   \   000000E6   0x.... 0x....      BL       HAL_GPIO_Init
   1726          
   1727          
   1728            GPIO_InitStructure.Pin = GPIO_PIN_15;
   \   000000EA   0x9706             STR      R7,[SP, #+24]
   1729            GPIO_InitStructure.Mode = GPIO_MODE_AF_PP;
   \   000000EC   0x2002             MOVS     R0,#+2
   \   000000EE   0x9007             STR      R0,[SP, #+28]
   1730            GPIO_InitStructure.Alternate = GPIO_AF6_SPI3;
   \   000000F0   0x2006             MOVS     R0,#+6
   \   000000F2   0x900A             STR      R0,[SP, #+40]
   1731            HAL_GPIO_Init(GPIOA, &GPIO_InitStructure);
   \   000000F4   0xA906             ADD      R1,SP,#+24
   \   000000F6   0x4630             MOV      R0,R6
   \   000000F8   0x.... 0x....      BL       HAL_GPIO_Init
   1732          
   1733          #ifdef CODEC_MCLK_ENABLED
   1734          
   1735            GPIO_InitStructure.Pin = GPIO_PIN_7; 
   \   000000FC   0x2080             MOVS     R0,#+128
   1736            GPIO_InitStructure.Mode = GPIO_MODE_AF_PP;
   1737            GPIO_InitStructure.Speed = GPIO_SPEED_HIGH;
   1738            GPIO_InitStructure.Pull = GPIO_NOPULL;
   1739            GPIO_InitStructure.Alternate = GPIO_AF6_SPI3;
   1740            HAL_GPIO_Init(GPIOC, &GPIO_InitStructure);
   \   000000FE   0xA906             ADD      R1,SP,#+24
   \   00000100   0x.... 0x....      BL       ?Subroutine1
   \                     ??CrossCallReturnLabel_4: (+1)
   \   00000104   0x4648             MOV      R0,R9
   \   00000106   0x.... 0x....      BL       HAL_GPIO_Init
   1741          
   1742          #endif /* CODEC_MCLK_ENABLED */ 
   1743          
   1744          #ifdef I2S_INTERRUPT   
   1745               /* Enable and set Button EXTI Interrupt to the lowest priority */
   1746               //HAL_NVIC_SetPriority((IRQn_Type)SPI3_IRQn, 0x00, 0x01);
   1747               //HAL_NVIC_EnableIRQ((IRQn_Type)SPI3_IRQn);
   1748          
   1749               /* Enable the I2S DMA request */
   1750               //__HAL_I2S_ENABLE_IT(&hi2s3, SPI_I2S_DMAReq_Tx);
   1751               //__HAL_I2S_ENABLE(&hi2s3);
   1752          #endif
   1753          
   1754                /* Enable the DMA clock */ 
   1755          	  __HAL_RCC_DMA1_CLK_ENABLE();
   \   0000010A   0x6828             LDR      R0,[R5, #+0]
   \   0000010C   0xF440 0x1000      ORR      R0,R0,#0x200000
   \   00000110   0x6028             STR      R0,[R5, #+0]
   \   00000112   0x6828             LDR      R0,[R5, #+0]
   1756          
   1757                /* Configure the DMA Stream */
   1758                HAL_DMA_DeInit(&DmaHandle);
   \   00000114   0x....             LDR.N    R5,??DataTable14_5
   \   00000116   0xF400 0x1000      AND      R0,R0,#0x200000
   \   0000011A   0x9000             STR      R0,[SP, #+0]
   \   0000011C   0x9800             LDR      R0,[SP, #+0]
   \   0000011E   0x4628             MOV      R0,R5
   \   00000120   0x.... 0x....      BL       HAL_DMA_DeInit
   1759          
   1760                /* Set the parameters to be configured */ 
   1761          	  DmaHandle.Instance = DMA1_Stream7;
   \   00000124   0x....             LDR.N    R0,??DataTable14_8  ;; 0x400260b8
   1762                DmaHandle.Init.Channel = DMA_CHANNEL_0;
   1763          	  DmaHandle.Init.Direction = DMA_MEMORY_TO_PERIPH;
   1764          	  DmaHandle.Init.PeriphInc = DMA_PINC_ENABLE;
   1765          	  DmaHandle.Init.MemInc = DMA_MINC_ENABLE;
   1766          	  DmaHandle.Init.PeriphDataAlignment = DMA_PDATAALIGN_HALFWORD;
   1767                DmaHandle.Init.MemDataAlignment = DMA_MDATAALIGN_HALFWORD; 
   1768          	  DmaHandle.Init.Mode = DMA_NORMAL;
   1769                DmaHandle.Init.Priority = DMA_PRIORITY_HIGH; 
   1770          	  DmaHandle.Init.FIFOMode = DMA_FIFOMODE_DISABLE;
   1771                DmaHandle.Init.FIFOThreshold = DMA_FIFO_THRESHOLD_1QUARTERFULL;
   1772                DmaHandle.Init.MemBurst = DMA_MBURST_SINGLE;
   1773                DmaHandle.Init.PeriphBurst = DMA_PBURST_SINGLE;	  
   1774                DmaHandle.Instance->PAR = CODEC_I2S_ADDRESS;
   \   00000126   0x....             LDR.N    R1,??DataTable14_16  ;; 0x40003c0c
   \   00000128   0x6028             STR      R0,[R5, #+0]
   \   0000012A   0x2000             MOVS     R0,#+0
   \   0000012C   0x6068             STR      R0,[R5, #+4]
   \   0000012E   0x2040             MOVS     R0,#+64
   \   00000130   0x60A8             STR      R0,[R5, #+8]
   \   00000132   0xF44F 0x7000      MOV      R0,#+512
   \   00000136   0x60E8             STR      R0,[R5, #+12]
   \   00000138   0xF44F 0x6080      MOV      R0,#+1024
   \   0000013C   0x6128             STR      R0,[R5, #+16]
   \   0000013E   0xF44F 0x6000      MOV      R0,#+2048
   \   00000142   0x6168             STR      R0,[R5, #+20]
   \   00000144   0xF44F 0x5000      MOV      R0,#+8192
   \   00000148   0x61A8             STR      R0,[R5, #+24]
   \   0000014A   0x2000             MOVS     R0,#+0
   \   0000014C   0x61E8             STR      R0,[R5, #+28]
   \   0000014E   0xF44F 0x3000      MOV      R0,#+131072
   \   00000152   0x6228             STR      R0,[R5, #+32]
   \   00000154   0x2000             MOVS     R0,#+0
   \   00000156   0x6268             STR      R0,[R5, #+36]
   \   00000158   0x62A8             STR      R0,[R5, #+40]
   \   0000015A   0x62E8             STR      R0,[R5, #+44]
   \   0000015C   0x6328             STR      R0,[R5, #+48]
   \   0000015E   0x6828             LDR      R0,[R5, #+0]
   \   00000160   0x6081             STR      R1,[R0, #+8]
   1775                DmaHandle.Instance->M0AR = (uint32_t)0;
   \   00000162   0x2100             MOVS     R1,#+0
   \   00000164   0x60C1             STR      R1,[R0, #+12]
   1776                DmaHandle.Instance->NDTR = (uint32_t)0xFFFE;
   \   00000166   0xF64F 0x71FE      MOVW     R1,#+65534
   \   0000016A   0x6041             STR      R1,[R0, #+4]
   1777                
   1778                HAL_DMA_Init(&DmaHandle);
   \   0000016C   0x4628             MOV      R0,R5
   \   0000016E   0x.... 0x....      BL       HAL_DMA_Init
   1779          
   1780                /* Associate the initialized DMA handle to the the SPI handle */
   1781                __HAL_LINKDMA(hi2s, hdmatx, DmaHandle);
   \   00000172   0x6325             STR      R5,[R4, #+48]
   1782                //__HAL_DMA_ENABLE_IT(&DmaHandle, DMA_IT_TC);
   1783          
   1784                /* Set Interrupt Group Priority */
   1785                HAL_NVIC_SetPriority(DMA1_Stream7_IRQn, 2, 1);
   \   00000174   0x2201             MOVS     R2,#+1
   \   00000176   0x63AC             STR      R4,[R5, #+56]
   \   00000178   0x2102             MOVS     R1,#+2
   \   0000017A   0x202F             MOVS     R0,#+47
   \   0000017C   0x.... 0x....      BL       HAL_NVIC_SetPriority
   1786                /* Enable the DMA STREAM global Interrupt */
   1787                HAL_NVIC_EnableIRQ(DMA1_Stream7_IRQn);    
   \   00000180   0x202F             MOVS     R0,#+47
   \   00000182   0x.... 0x....      BL       HAL_NVIC_EnableIRQ
   1788          	  
   1789          	    /* Peripheral interrupt init*/
   1790          		HAL_NVIC_SetPriority(SPI3_IRQn, 2, 0);
   \   00000186   0x2200             MOVS     R2,#+0
   \   00000188   0x2102             MOVS     R1,#+2
   \   0000018A   0x2033             MOVS     R0,#+51
   \   0000018C   0x.... 0x....      BL       HAL_NVIC_SetPriority
   1791          		HAL_NVIC_EnableIRQ(SPI3_IRQn);
   \   00000190   0x2033             MOVS     R0,#+51
   \                     ??HAL_I2S_MspInit_1: (+1)
   \   00000192   0x.... 0x....      BL       HAL_NVIC_EnableIRQ
   1792           }
   1793          
   1794          }
   \                     ??HAL_I2S_MspInit_3: (+1)
   \   00000196   0xB00B             ADD      SP,SP,#+44
   \   00000198   0xE8BD 0x83F0      POP      {R4-R9,PC}       ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine4: (+1)
   \   00000000   0x9000             STR      R0,[SP, #+0]
   \   00000002   0x9800             LDR      R0,[SP, #+0]
   \   00000004   0x6828             LDR      R0,[R5, #+0]
   \   00000006   0xF040 0x0002      ORR      R0,R0,#0x2
   \   0000000A   0x6028             STR      R0,[R5, #+0]
   \   0000000C   0x6828             LDR      R0,[R5, #+0]
   \   0000000E   0xF000 0x0002      AND      R0,R0,#0x2
   \   00000012   0x9000             STR      R0,[SP, #+0]
   \   00000014   0x9800             LDR      R0,[SP, #+0]
   \   00000016   0x6828             LDR      R0,[R5, #+0]
   \   00000018   0xF040 0x0004      ORR      R0,R0,#0x4
   \   0000001C   0x6028             STR      R0,[R5, #+0]
   \   0000001E   0x6828             LDR      R0,[R5, #+0]
   \   00000020   0xF000 0x0004      AND      R0,R0,#0x4
   \   00000024   0x9000             STR      R0,[SP, #+0]
   \   00000026   0x9800             LDR      R0,[SP, #+0]
   \   00000028   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine3: (+1)
   \   00000000   0x9002             STR      R0,[SP, #+8]
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0x9003             STR      R0,[SP, #+12]
   \   00000006   0x2003             MOVS     R0,#+3
   \   00000008   0x9004             STR      R0,[SP, #+16]
   \   0000000A   0x2005             MOVS     R0,#+5
   \   0000000C   0x9005             STR      R0,[SP, #+20]
   \   0000000E   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \   00000000   0x9006             STR      R0,[SP, #+24]
   \   00000002   0x2002             MOVS     R0,#+2
   \   00000004   0x9007             STR      R0,[SP, #+28]
   \   00000006   0x2003             MOVS     R0,#+3
   \   00000008   0x9009             STR      R0,[SP, #+36]
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x9008             STR      R0,[SP, #+32]
   \   0000000E   0x2006             MOVS     R0,#+6
   \   00000010   0x900A             STR      R0,[SP, #+40]
   \   00000012   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \   00000000   0xA901             ADD      R1,SP,#+4
   \                     ??Subroutine0_0: (+1)
   \   00000002   0x9001             STR      R0,[SP, #+4]
   \   00000004   0x2002             MOVS     R0,#+2
   \   00000006   0x9002             STR      R0,[SP, #+8]
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x9003             STR      R0,[SP, #+12]
   \   0000000C   0x2003             MOVS     R0,#+3
   \   0000000E   0x9004             STR      R0,[SP, #+16]
   \   00000010   0x2005             MOVS     R0,#+5
   \   00000012   0x9005             STR      R0,[SP, #+20]
   \   00000014   0x4770             BX       LR
   1795          

   \                                 In section .text, align 2, keep-with-next
   1796          void HAL_SPI_MspDeInit(SPI_HandleTypeDef *hspi)
   1797          {
   \                     HAL_SPI_MspDeInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   1798            if(hspi->Instance == SPI3)
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x....             LDR.N    R1,??DataTable14_9  ;; 0x40003c00
   \   00000006   0x4288             CMP      R0,R1
   \   00000008   0xD122             BNE.N    ??HAL_SPI_MspDeInit_0
   1799            {   
   1800              /*##-1- Reset peripherals ##################################################*/
   1801              __HAL_RCC_SPI2_FORCE_RESET();
   \   0000000A   0x....             LDR.N    R0,??DataTable14_21  ;; 0x40023820
   1802              __HAL_RCC_SPI2_RELEASE_RESET();
   1803          
   1804              /*##-2- Disable peripherals and GPIO Clocks ################################*/
   1805              HAL_GPIO_DeInit(CODEC_I2S_GPIO, CODEC_I2S_SCK_PIN);
   \   0000000C   0x....             LDR.N    R4,??DataTable14_1  ;; 0x40020400
   \   0000000E   0x6801             LDR      R1,[R0, #+0]
   \   00000010   0xF441 0x4180      ORR      R1,R1,#0x4000
   \   00000014   0x6001             STR      R1,[R0, #+0]
   \   00000016   0x6801             LDR      R1,[R0, #+0]
   \   00000018   0xF421 0x4180      BIC      R1,R1,#0x4000
   \   0000001C   0x6001             STR      R1,[R0, #+0]
   \   0000001E   0x2108             MOVS     R1,#+8
   \   00000020   0x4620             MOV      R0,R4
   \   00000022   0x.... 0x....      BL       HAL_GPIO_DeInit
   1806              HAL_GPIO_DeInit(CODEC_I2S_GPIO, CODEC_I2S_SD_PIN);
   \   00000026   0x2104             MOVS     R1,#+4
   \   00000028   0x4620             MOV      R0,R4
   \   0000002A   0x.... 0x....      BL       HAL_GPIO_DeInit
   1807              HAL_GPIO_DeInit(CODEC_I2S_WS_GPIO, CODEC_I2S_WS_PIN);
   \   0000002E   0xF44F 0x4100      MOV      R1,#+32768
   \   00000032   0x....             LDR.N    R0,??DataTable14_2  ;; 0x40020000
   \   00000034   0x.... 0x....      BL       HAL_GPIO_DeInit
   1808          	 HAL_GPIO_DeInit(CODEC_I2S_MCK_GPIO, CODEC_I2S_MCK_PIN);
   \   00000038   0x2180             MOVS     R1,#+128
   \   0000003A   0x....             LDR.N    R0,??DataTable14_3  ;; 0x40020800
   \   0000003C   0x.... 0x....      BL       HAL_GPIO_DeInit
   1809          
   1810              /*##-3- Disable the DMA ####################################################*/
   1811              /* De-Initialize the DMA associated to transmission process */
   1812              HAL_DMA_DeInit(&DmaHandle);
   \   00000040   0x....             LDR.N    R0,??DataTable14_5
   \   00000042   0x.... 0x....      BL       HAL_DMA_DeInit
   1813          
   1814          
   1815              /*##-4- Disable the NVIC for DMA ###########################################*/
   1816              HAL_NVIC_DisableIRQ(DMA1_Stream7_IRQn);
   \   00000046   0x202F             MOVS     R0,#+47
   \   00000048   0xE8BD 0x4010      POP      {R4,LR}
   \   0000004C   0x.... 0x....      B.W      HAL_NVIC_DisableIRQ
   1817            }
   1818          }
   \                     ??HAL_SPI_MspDeInit_0: (+1)
   \   00000050   0xBD10             POP      {R4,PC}          ;; return
   1819          
   1820          

   \                                 In section .text, align 2, keep-with-next
   1821          void HAL_I2C_MspDeInit(I2C_HandleTypeDef *hi2c)
   1822          {
   1823              /*##-1- Reset peripherals ##################################################*/
   1824              __HAL_RCC_I2C1_FORCE_RESET();
   \                     HAL_I2C_MspDeInit: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable14_21  ;; 0x40023820
   \   00000002   0xB510             PUSH     {R4,LR}
   \   00000004   0x6801             LDR      R1,[R0, #+0]
   1825              __HAL_RCC_I2C1_RELEASE_RESET();
   1826          
   1827          
   1828            /*##-2- Disable peripherals and GPIO Clocks #################################*/
   1829            /* Configure I2C Tx as alternate function  */
   1830            HAL_GPIO_DeInit(CODEC_I2C_GPIO, CODEC_I2C_SCL_PIN);
   \   00000006   0x....             LDR.N    R4,??DataTable14_1  ;; 0x40020400
   \   00000008   0xF441 0x1100      ORR      R1,R1,#0x200000
   \   0000000C   0x6001             STR      R1,[R0, #+0]
   \   0000000E   0x6801             LDR      R1,[R0, #+0]
   \   00000010   0xF421 0x1100      BIC      R1,R1,#0x200000
   \   00000014   0x6001             STR      R1,[R0, #+0]
   \   00000016   0x2140             MOVS     R1,#+64
   \   00000018   0x4620             MOV      R0,R4
   \   0000001A   0x.... 0x....      BL       HAL_GPIO_DeInit
   1831            /* Configure I2C Rx as alternate function  */
   1832            HAL_GPIO_DeInit(CODEC_I2C_GPIO, CODEC_I2C_SDA_PIN);
   \   0000001E   0x4620             MOV      R0,R4
   \   00000020   0x2180             MOVS     R1,#+128
   \   00000022   0xE8BD 0x4010      POP      {R4,LR}
   \   00000026   0x.... 0x....      B.W      HAL_GPIO_DeInit
   1833          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14:
   \   00000000   0x........         DC32     hi2s3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_1:
   \   00000000   0x40020400         DC32     0x40020400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_2:
   \   00000000   0x40020000         DC32     0x40020000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_3:
   \   00000000   0x40020800         DC32     0x40020800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_4:
   \   00000000   0x40023840         DC32     0x40023840

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_5:
   \   00000000   0x........         DC32     DmaHandle

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_6:
   \   00000000   0x0001FFFE         DC32     0x1fffe

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_7:
   \   00000000   0x........         DC32     OutputDev

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_8:
   \   00000000   0x400260B8         DC32     0x400260b8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_9:
   \   00000000   0x40003C00         DC32     0x40003c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_10:
   \   00000000   0x40020C00         DC32     0x40020c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_11:
   \   00000000   0x40026459         DC32     0x40026459

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_12:
   \   00000000   0x40026400         DC32     0x40026400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_13:
   \   00000000   0x40026000         DC32     0x40026000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_14:
   \   00000000   0x40026059         DC32     0x40026059

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_15:
   \   00000000   0x400260B9         DC32     0x400260b9

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_16:
   \   00000000   0x40003C0C         DC32     0x40003c0c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_17:
   \   00000000   0x40023830         DC32     0x40023830

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_18:
   \   00000000   0x40013000         DC32     0x40013000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_19:
   \   00000000   0x40003800         DC32     0x40003800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_20:
   \   00000000   0x40022000         DC32     0x40022000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_21:
   \   00000000   0x40023820         DC32     0x40023820
   1834          
   1835          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      32   AUDIO_DeInit
        32   -> Codec_Reset
        32   -> Codec_WriteRegister
        32   -> HAL_GPIO_Init
        32   -> HAL_I2C_MspDeInit
        32   -> HAL_NVIC_DisableIRQ
       8   AUDIO_Init
         8   -> Codec_Init
       0   AUDIO_Mute
         0   -> Codec_Mute
      16   AUDIO_PauseResume
        16   -> Codec_Mute
        16   -> Codec_WriteRegister
        16   -> DMA_Cmd
        16   -> I2S_Cmd
        16   -> SPI_I2S_DMACmd
      16   AUDIO_Play
        16   -> Audio_MAL_Play
       8   AUDIO_Stop
         8   -> Codec_Mute
         8   -> Codec_WriteRegister
         8   -> DMA_Cmd
         8   -> Delay
         8   -> HAL_GPIO_WritePin
         8   -> I2S_Cmd
       0   AUDIO_VolumeCtl
         0   -> Codec_VolumeCtrl
      24   Audio_MAL_IRQHandler
         0   -> AUDIO_TransferComplete_CallBack
        24   -> HAL_DMA_Init
       0   Audio_MAL_Play
         0   -> HAL_I2S_Transmit_DMA
      88   Codec_Init
        88   -> Codec_Reset
        88   -> Codec_VolumeCtrl
        88   -> Codec_WriteRegister
        88   -> HAL_GPIO_Init
        88   -> HAL_I2S_Init
        88   -> MX_I2C1_Init
       0   Codec_Mute
         0   -> Codec_WriteRegister
       8   Codec_Reset
         8   -> Delay
         0   -> HAL_GPIO_WritePin
         8   -> HAL_GPIO_WritePin
      16   Codec_VolumeCtrl
        16   -> Codec_WriteRegister
      24   Codec_WriteRegister
        24   -> Codec_TIMEOUT_UserCallback
        24   -> HAL_I2C_GetError
        24   -> HAL_I2C_Master_Receive
        24   -> HAL_I2C_Master_Transmit
       0   DAC_Config
       0   DMA1_Stream0_IRQHandler
         0   -> Audio_MAL_IRQHandler
       0   DMA1_Stream7_IRQHandler
         0   -> HAL_DMA_IRQHandler
       0   DMA_Cmd
       4   Delay
       8   HAL_I2C_MspDeInit
         0   -> HAL_GPIO_DeInit
         8   -> HAL_GPIO_DeInit
      72   HAL_I2S_MspInit
        72   -> HAL_DMA_DeInit
        72   -> HAL_DMA_Init
        72   -> HAL_GPIO_Init
        72   -> HAL_NVIC_EnableIRQ
        72   -> HAL_NVIC_SetPriority
       8   HAL_SPI_MspDeInit
         8   -> HAL_DMA_DeInit
         8   -> HAL_GPIO_DeInit
         0   -> HAL_NVIC_DisableIRQ
       0   I2S_Cmd
       8   SPI3_IRQHandler
         8   -> AUDIO_GetSampleCallBack
       0   SPI_I2S_DMACmd


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable14
       4  ??DataTable14_1
       4  ??DataTable14_10
       4  ??DataTable14_11
       4  ??DataTable14_12
       4  ??DataTable14_13
       4  ??DataTable14_14
       4  ??DataTable14_15
       4  ??DataTable14_16
       4  ??DataTable14_17
       4  ??DataTable14_18
       4  ??DataTable14_19
       4  ??DataTable14_2
       4  ??DataTable14_20
       4  ??DataTable14_21
       4  ??DataTable14_3
       4  ??DataTable14_4
       4  ??DataTable14_5
       4  ??DataTable14_6
       4  ??DataTable14_7
       4  ??DataTable14_8
       4  ??DataTable14_9
      22  ?Subroutine0
      20  ?Subroutine1
       6  ?Subroutine2
      16  ?Subroutine3
      42  ?Subroutine4
      10  ?Subroutine5
     148  AUDIO_DeInit
      28  AUDIO_Init
      48  AUDIO_MAL_DMA_InitStructure
       2  AUDIO_Mute
     120  AUDIO_PauseResume
      70  AUDIO_Play
      90  AUDIO_Stop
      20  AUDIO_VolumeCtl
     224  Audio_MAL_IRQHandler
      10  Audio_MAL_Play
       4  CODECTimeout
     274  Codec_Init
      16  Codec_Mute
      38  Codec_Reset
      28  Codec_VolumeCtrl
     150  Codec_WriteRegister
       4  CurrAudioInterface
       2  DAC_Config
       2  DMA1_Stream0_IRQHandler
      10  DMA1_Stream7_IRQHandler
      18  DMA_Cmd
      48  DMA_InitStructure
      20  Delay
      92  DmaHandle
          AudioTotalSize
          AudioRemSize
          CurrentPos
      42  HAL_I2C_MspDeInit
     412  HAL_I2S_MspInit
      82  HAL_SPI_MspDeInit
      20  I2S_Cmd
      68  OutputDev
          hi2s3
      28  SPI3_IRQHandler
      18  SPI_I2S_DMACmd
       1  Volume
     124  hi2s3
          hi2c1

 
   288 bytes in section .bss
   101 bytes in section .data
 2 076 bytes in section .text
 
 2 076 bytes of CODE memory
   389 bytes of DATA memory

Errors: none
Warnings: 13
