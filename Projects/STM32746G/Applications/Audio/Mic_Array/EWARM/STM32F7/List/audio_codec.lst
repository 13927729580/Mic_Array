###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.2.10312/W32 for ARM       21/Jan/2016  18:08:40
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\sop1hc\Github\data\Mic_Array_V00\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\Src\audio_codec.c
#    Command line =  
#        D:\sop1hc\Github\data\Mic_Array_V00\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\Src\audio_codec.c
#        -D USE_HAL_DRIVER -D STM32F746xx -D USE_STM32746G_DISCO -D
#        USE_IOEXPANDER -D USE_USB_FS -lC
#        D:\sop1hc\Github\data\Mic_Array_V00\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
#        -lA
#        D:\sop1hc\Github\data\Mic_Array_V00\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
#        -o
#        D:\sop1hc\Github\data\Mic_Array_V00\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj
#        --no_unroll --debug --endian=little --cpu=Cortex-M7 -e --fpu=VFPv5_sp
#        --dlib_config "D:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Full.h" -I
#        D:\sop1hc\Github\data\Mic_Array_V00\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\CMSIS\Device\ST\STM32F7xx\Include\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\STM32F7xx_HAL_Driver\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\STM32746G-Discovery\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\Components\Common\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Log\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Fonts\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\CPU\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_Device_Library\Core\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Core\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Class\MSC\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\drivers\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_Audio\Addons\PDM\
#        -Ohz --use_c++_inline --require_prototypes -I "D:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.3\arm\CMSIS\Include\" -D
#        ARM_MATH_CM7
#    List file    =  
#        D:\sop1hc\Github\data\Mic_Array_V00\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List\audio_codec.lst
#    Object file  =  
#        D:\sop1hc\Github\data\Mic_Array_V00\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj\audio_codec.o
#
###############################################################################

D:\sop1hc\Github\data\Mic_Array_V00\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\Src\audio_codec.c
      1          /**
      2            ******************************************************************************
      3            * @file    audio_codec.c
      4            * @author  Phan Le Son ( porting from "MCD Application Team")
      5            * @version V1.0.0
      6            * @date    12-December-2015
      7            * @brief   This file includes the low layer driver for CS43L22 Audio Codec 
      8            ******************************************************************************
      9                                                       User NOTES
     10          1. How To use this driver:
     11          --------------------------
     12             - Call the function AUDIO_Init(
     13                                              OutputDevice: physical output mode (OUTPUT_DEVICE_SPEAKER, 
     14                                                           OUTPUT_DEVICE_HEADPHONE, OUTPUT_DEVICE_AUTO or 
     15                                                           OUTPUT_DEVICE_BOTH)
     16                                              Volume: initial volume to be set (0 is min (mute), 100 is max (100%)
     17                                              AudioFreq: Audio frequency in Hz (8000, 16000, 22500, 32000 ...)
     18                                              this parameter is relative to the audio file/stream type.
     19                                             )
     20                This function configures all the hardware required for the audio application (codec, I2C, I2S, 
     21                GPIOs, DMA and interrupt if needed). This function returns 0 if configuration is OK.
     22                if the returned value is different from 0 or the function is stuck then the communication with
     23                the codec (try to un-plug the power or reset device in this case).
     24                + OUTPUT_DEVICE_SPEAKER: only speaker will be set as output for the audio stream.
     25                + OUTPUT_DEVICE_HEADPHONE: only headphones will be set as output for the audio stream.
     26                + OUTPUT_DEVICE_AUTO: Selection of output device is made through external switch (implemented 
     27                   into the audio jack on the board). When the Headphone is connected it is used
     28                   as output. When the headphone is disconnected from the audio jack, the output is
     29                   automatically switched to Speaker.
     30                + OUTPUT_DEVICE_BOTH: both Speaker and Headphone are used as outputs for the audio stream
     31                   at the same time.
     32             - Call the function AUDIO_Play(
     33                                            pBuffer: pointer to the audio data file address
     34                                            Size: size of the buffer to be sent in Bytes
     35                                           )
     36                to start playing (for the first time) from the audio file/stream.
     37             - Call the function AUDIO_PauseResume(
     38                                                   Cmd: AUDIO_PAUSE (or 0) to pause playing or AUDIO_RESUME (or 
     39                                                         any value different from 0) to resume playing.
     40                                                   )
     41                 Note. After calling AUDIO_PauseResume() function for pause, only AUDIO_PauseResume() should be called
     42                    for resume (it is not allowed to call AUDIO_Play() in this case).
     43                 Note. This function should be called only when the audio file is played or paused (not stopped).
     44             - For each mode, you may need to implement the relative callback functions into your code.
     45                The Callback functions are named AUDIO_XXX_CallBack() and only their prototypes are declared in 
     46                the stm32f4_discovery_audio_codec.h file. (refer to the example for more details on the callbacks implementations)
     47             - To Stop playing, to modify the volume level or to mute, use the functions
     48                 AUDIO_Stop(), AUDIO_VolumeCtl() and AUDIO_Mute().
     49           
     50           Driver architecture:
     51           --------------------
     52           This driver is composed of three main layers:
     53             o High Audio Layer: consists of the function API exported in the audio_codec.h file
     54               (AUDIO_Init(), AUDIO_Play() ...)
     55             o Codec Control layer: consists of the functions API controlling the audio codec (CS43L22) and 
     56               included as local functions in file stm32f4_discovery_audio_codec.c (Codec_Init(), Codec_Play() ...)
     57             o Media Access Layer (MAL): which consists of functions allowing to access the media containing/
     58               providing the audio file/stream. These functions are also included as local functions into
     59               the stm32f4_discovery_audio_codec.c file (Audio_MAL_Init(), Audio_MAL_Play() ...)
     60            Each set of functions (layer) may be implemented independently of the others and customized when 
     61            needed.    
     62          2. Modes description:
     63          ---------------------
     64               + AUDIO_MAL_MODE_NORMAL : is suitable when the audio file is in a memory location.
     65               + AUDIO_MAL_MODE_CIRCULAR: is suitable when the audio data are read either from a 
     66                  memory location or from a device at real time (double buffer could be used).
     67          3. DMA interrupts description:
     68          ------------------------------
     69               + AUDIO_IT_TC_ENABLE: Enable this define to use the DMA end of transfer interrupt.
     70                  then, a callback should be implemented by user to perform specific actions
     71                  when the DMA has finished the transfer.
     72               + AUDIO_IT_HT_ENABLE: Enable this define to use the DMA end of half transfer interrupt.
     73                  then, a callback should be implemented by user to perform specific actions
     74                  when the DMA has reached the half of the buffer transfer (generally, it is useful 
     75                  to load the first half of buffer while DMA is loading from the second half).
     76               + AUDIO_IT_ER_ENABLE: Enable this define to manage the cases of error on DMA transfer.
     77          4. Known Limitations:
     78          ---------------------
     79             1- When using the Speaker, if the audio file quality is not high enough, the speaker output
     80                may produce high and uncomfortable noise level. To avoid this issue, to use speaker
     81                output properly, try to increase audio file sampling rate (typically higher than 48KHz).
     82                This operation will lead to larger file size.
     83             2- Communication with the audio codec (through I2C) may be corrupted if it is interrupted by some
     84                user interrupt routines (in this case, interrupts could be disabled just before the start of 
     85                communication then re-enabled when it is over). Note that this communication is only done at
     86                the configuration phase (AUDIO_Init() or AUDIO_Stop()) and when Volume control modification is 
     87                performed (AUDIO_VolumeCtl() or AUDIO_Mute()). When the audio data is played, no communication is 
     88                required with the audio codec.
     89            3- Parsing of audio file is not implemented (in order to determine audio file properties: Mono/Stereo, Data size, 
     90               File size, Audio Frequency, Audio Data header size ...). The configuration is fixed for the given audio file.
     91            4- Mono audio streaming is not supported (in order to play mono audio streams, each data should be sent twice 
     92               on the I2S or should be duplicated on the source buffer. Or convert the stream in stereo before playing).
     93            5- Supports only 16-bit audio data size.
     94          */
     95          
     96          
     97          /* Includes ------------------------------------------------------------------*/
     98          #include "audio_codec.h"
     99          #include "stm32746g_discovery.h"
    100          #include "stm32f7xx_hal_i2s.h"
    101          #include "audio.h"
    102          #include "main.h"
    103          
    104          
    105          /** 
    106            *      This file includes the low layer driver for CS43L22 Audio Codec
    107            */ 
    108          
    109          #define SPI_I2S_DMAReq_Tx               ((uint16_t)0x0002)
    110          #define SPI_I2S_DMAReq_Rx               ((uint16_t)0x0001)
    111          /* Mask for the bit EN of the I2S CFGR register */
    112          #define I2S_ENABLE_MASK                 0x0400
    113          /* Delay for the Codec to be correctly reset */
    114          #define CODEC_RESET_DELAY               0x4FFF
    115          /* The 7 bits Codec address (sent through I2C interface) */
    116          #define CODEC_ADDRESS                   0x94  /* b00100111 */
    117          
    118          
    119          /* This is an audio file stored in the Flash memory as a constant table of 16-bit data.
    120              The audio format should be WAV (raw / PCM) 16-bits, Stereo (sampling rate may be modified) */
    121          extern const uint16_t AUDIO_SAMPLE[];
    122          extern __IO uint8_t XferCplt;
    123          extern I2S_HandleTypeDef     hi2s3;
    124          
    125          
    126          /* This structure is declared global because it is handled by two different functions */

   \                                 In section .bss, align 4
    127          DMA_InitTypeDef DMA_InitStructure; 
   \                     DMA_InitStructure:
   \   00000000                      DS8 48

   \                                 In section .bss, align 4
    128          DMA_InitTypeDef AUDIO_MAL_DMA_InitStructure;
   \                     AUDIO_MAL_DMA_InitStructure:
   \   00000000                      DS8 48

   \                                 In section .bss, align 4
    129          DMA_HandleTypeDef     DmaHandle;
   \                     DmaHandle:
   \   00000000                      DS8 80

   \                                 In section .bss, align 4
    130          I2C_HandleTypeDef     hi2c1,hi2c2;
   \                     hi2c1:
   \   00000000                      DS8 60

   \                                 In section .bss, align 4
   \                     hi2c2:
   \   00000000                      DS8 60
    131          

   \                                 In section .data, align 4
    132          uint32_t AudioTotalSize = 0xFFFF; /* This variable holds the total size of the audio file */
   \                     AudioTotalSize:
   \   00000000   0x0000FFFF         DC32 65535
    133          uint32_t AudioRemSize   = 0xFFFF; /* This variable holds the remaining data in audio file */
   \                     AudioRemSize:
   \   00000004   0x0000FFFF         DC32 65535
    134          __IO uint32_t  CODECTimeout = CODEC_LONG_TIMEOUT;   
    135          __IO uint32_t CurrAudioInterface = AUDIO_INTERFACE_I2S; //AUDIO_INTERFACE_DAC
    136          __IO uint8_t OutputDev = 0;
    137          uint16_t *CurrentPos ;             /* This variable holds the current position of audio pointer */
   \                     CurrentPos:
   \   00000008   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    

   \                                 In section .data, align 4
   \                     CODECTimeout:
   \   00000000   0x0012C000         DC32 1228800

   \                                 In section .data, align 4
   \                     CurrAudioInterface:
   \   00000000   0x00000001         DC32 1

   \                                 In section .data, align 1
   \                     OutputDev:
   \   00000000   0x00               DC8 0
    138          uint8_t Volume=80;
   \                     Volume:
   \   00000001   0x50               DC8 80
    139          
    140          
    141          /*-----------------------------------
    142                                     Audio Codec functions 
    143                                              ------------------------------------------*/
    144          static uint32_t Codec_Init(uint16_t OutputDevice, uint8_t Volume, uint32_t AudioFreq);
    145          static uint32_t Codec_DeInit(void);
    146          static uint32_t Codec_Play(void);
    147          static uint32_t Codec_PauseResume(uint32_t Cmd);
    148          static uint32_t Codec_Stop(uint32_t Cmd);
    149          static uint32_t Codec_VolumeCtrl(uint8_t Volume);
    150          static uint32_t Codec_Mute(uint32_t Cmd);
    151          static void     Codec_CtrlInterface_Init(void);
    152          static void     Codec_CtrlInterface_DeInit(void);
    153          static void     Codec_AudioInterface_Init(uint32_t AudioFreq);
    154          static void     Codec_AudioInterface_DeInit(void);
    155          static void     Codec_Reset(void);
    156          static uint32_t Codec_WriteRegister(uint8_t RegisterAddr, uint8_t RegisterValue);
    157          static uint32_t Codec_ReadRegister(uint8_t RegisterAddr);
    158          static void     Codec_GPIO_Init(void);
    159          static void     Codec_GPIO_DeInit(void);
    160          static void     Delay(__IO uint32_t nCount);
    161          static void     I2S_Cmd(SPI_TypeDef* SPIx, FunctionalState NewState);
    162          static void     SPI_I2S_DeInit(SPI_TypeDef* SPIx);
    163          static void     DMA_Cmd(DMA_Stream_TypeDef* DMAy_Streamx, FunctionalState NewState);
    164          static void     SPI_I2S_DMACmd(SPI_TypeDef* SPIx, uint16_t SPI_I2S_DMAReq, FunctionalState NewState);
    165          static void     Audio_MAL_DeInit(void);
    166          static void     Audio_MAL_PauseResume(uint32_t Cmd, uint32_t Addr);
    167          static void     Audio_MAL_Stop(void);
    168          /*----------------------------------------------------------------------------*/
    169          
    170          /**
    171            * @brief  Configure the audio peripherals.
    172            * @param  OutputDevice: OUTPUT_DEVICE_SPEAKER, OUTPUT_DEVICE_HEADPHONE,
    173            *                       OUTPUT_DEVICE_BOTH or OUTPUT_DEVICE_AUTO .
    174            * @param  Volume: Initial volume level (from 0 (Mute) to 100 (Max))
    175            * @param  AudioFreq: Audio frequency used to play the audio stream.
    176            * @retval 0 if correct communication, else wrong communication
    177            */

   \                                 In section .text, align 2, keep-with-next
    178          uint32_t AUDIO_Init(uint16_t OutputDevice, uint8_t Vol, uint32_t AudioFreq)
    179          {    
   \                     AUDIO_Init: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
    180          	/* Perform low layer Codec initialization */
    181          	if (Codec_Init(OutputDevice, VOLUME_CONVERT(Vol), AudioFreq)!=HAL_OK)
   \   00000002   0x.... 0x....      LDR.W    R5,??DataTable16
   \   00000006   0xB086             SUB      SP,SP,#+24
   \   00000008   0x4614             MOV      R4,R2
   \   0000000A   0x7868             LDRB     R0,[R5, #+1]
   \   0000000C   0x2865             CMP      R0,#+101
   \   0000000E   0xBFAF             ITEEE    GE 
   \   00000010   0x2664             MOVGE    R6,#+100
   \   00000012   0xEBC0 0x2000      RSBLT    R0,R0,R0, LSL #+8
   \   00000016   0x2164             MOVLT    R1,#+100
   \   00000018   0xFB90 0xF6F1      SDIVLT   R6,R0,R1
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable16_1  ;; 0x40023830
   \   00000020   0x6801             LDR      R1,[R0, #+0]
   \   00000022   0xF041 0x0108      ORR      R1,R1,#0x8
   \   00000026   0x6001             STR      R1,[R0, #+0]
   \   00000028   0x6800             LDR      R0,[R0, #+0]
   \   0000002A   0xA901             ADD      R1,SP,#+4
   \   0000002C   0xF000 0x0008      AND      R0,R0,#0x8
   \   00000030   0x9000             STR      R0,[SP, #+0]
   \   00000032   0x9800             LDR      R0,[SP, #+0]
   \   00000034   0x2010             MOVS     R0,#+16
   \   00000036   0x9001             STR      R0,[SP, #+4]
   \   00000038   0x2001             MOVS     R0,#+1
   \   0000003A   0x9002             STR      R0,[SP, #+8]
   \   0000003C   0x2003             MOVS     R0,#+3
   \   0000003E   0x9004             STR      R0,[SP, #+16]
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0x9003             STR      R0,[SP, #+12]
   \   00000044   0x.... 0x....      LDR.W    R0,??DataTable16_2  ;; 0x40020c00
   \   00000048   0x.... 0x....      BL       HAL_GPIO_Init
   \   0000004C   0x.... 0x....      BL       Codec_Reset
   \   00000050   0x.... 0x....      BL       MX_I2C1_Init
   \   00000054   0x.... 0x....      BL       ?Subroutine6
   \                     ??CrossCallReturnLabel_16: (+1)
   \   00000058   0x21AF             MOVS     R1,#+175
   \   0000005A   0x2004             MOVS     R0,#+4
   \   0000005C   0x.... 0x....      BL       Codec_WriteRegister
   \   00000060   0x20AF             MOVS     R0,#+175
   \   00000062   0x2181             MOVS     R1,#+129
   \   00000064   0x7028             STRB     R0,[R5, #+0]
   \   00000066   0x2005             MOVS     R0,#+5
   \   00000068   0x.... 0x....      BL       Codec_WriteRegister
   \   0000006C   0x2104             MOVS     R1,#+4
   \   0000006E   0x2006             MOVS     R0,#+6
   \   00000070   0x.... 0x....      BL       Codec_WriteRegister
   \   00000074   0xB2F0             UXTB     R0,R6
   \   00000076   0x.... 0x....      BL       Codec_VolumeCtrl
   \   0000007A   0x219E             MOVS     R1,#+158
   \   0000007C   0x.... 0x....      BL       ??Subroutine6_0
   \                     ??CrossCallReturnLabel_14: (+1)
   \   00000080   0x2100             MOVS     R1,#+0
   \   00000082   0x200A             MOVS     R0,#+10
   \   00000084   0x.... 0x....      BL       Codec_WriteRegister
   \   00000088   0x2104             MOVS     R1,#+4
   \   0000008A   0x200E             MOVS     R0,#+14
   \   0000008C   0x.... 0x....      BL       Codec_WriteRegister
   \   00000090   0x2100             MOVS     R1,#+0
   \   00000092   0x2027             MOVS     R0,#+39
   \   00000094   0x.... 0x....      BL       Codec_WriteRegister
   \   00000098   0x210F             MOVS     R1,#+15
   \   0000009A   0x201F             MOVS     R0,#+31
   \   0000009C   0x.... 0x....      BL       Codec_WriteRegister
   \   000000A0   0x210A             MOVS     R1,#+10
   \   000000A2   0x201A             MOVS     R0,#+26
   \   000000A4   0x.... 0x....      BL       Codec_WriteRegister
   \   000000A8   0x210A             MOVS     R1,#+10
   \   000000AA   0x201B             MOVS     R0,#+27
   \   000000AC   0x.... 0x....      BL       Codec_WriteRegister
   \   000000B0   0x4620             MOV      R0,R4
   \   000000B2   0x.... 0x....      BL       I2S3_Init
    182          	{
    183                      //BSP_LED_Toggle(LED2);
    184          	}
    185          	
    186          	return 0;
   \   000000B6   0x2000             MOVS     R0,#+0
   \   000000B8   0xB006             ADD      SP,SP,#+24
   \   000000BA   0xBD70             POP      {R4-R6,PC}       ;; return
    187          }
    188          
    189          /**
    190            * @brief  Deinitializes all the resources used by the codec (those initialized
    191            *         by AUDIO_Init() function). 
    192            * @param  None
    193            * @retval 0 if correct communication, else wrong communication
    194            */

   \                                 In section .text, align 2, keep-with-next
    195          uint32_t AUDIO_DeInit(void)
    196          { 
   \                     AUDIO_DeInit: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB087             SUB      SP,SP,#+28
    197            /* DeInitialize the Media layer */
    198            Audio_MAL_DeInit();
   \   00000004   0x2033             MOVS     R0,#+51
   \   00000006   0x.... 0x....      BL       HAL_NVIC_DisableIRQ
   \   0000000A   0x202F             MOVS     R0,#+47
   \   0000000C   0x.... 0x....      BL       HAL_NVIC_DisableIRQ
   \   00000010   0x2033             MOVS     R0,#+51
   \   00000012   0x.... 0x....      BL       HAL_NVIC_DisableIRQ
    199            
    200            /* DeInitialize Codec */  
    201            Codec_DeInit();  
   \   00000016   0x.... 0x....      BL       Codec_Reset
   \   0000001A   0x.... 0x....      BL       ?Subroutine6
   \                     ??CrossCallReturnLabel_15: (+1)
   \   0000001E   0x200C             MOVS     R0,#+12
   \   00000020   0xA901             ADD      R1,SP,#+4
   \   00000022   0x9001             STR      R0,[SP, #+4]
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0x9002             STR      R0,[SP, #+8]
   \   00000028   0x9004             STR      R0,[SP, #+16]
   \   0000002A   0x9003             STR      R0,[SP, #+12]
   \   0000002C   0x.... 0x....      LDR.W    R0,??DataTable16_3  ;; 0x40020400
   \   00000030   0x.... 0x....      BL       HAL_GPIO_Init
   \   00000034   0xF44F 0x4000      MOV      R0,#+32768
   \   00000038   0xA901             ADD      R1,SP,#+4
   \   0000003A   0x9001             STR      R0,[SP, #+4]
   \   0000003C   0x.... 0x....      LDR.W    R0,??DataTable16_4  ;; 0x40020000
   \   00000040   0x.... 0x....      BL       HAL_GPIO_Init
   \   00000044   0x2080             MOVS     R0,#+128
   \   00000046   0xA901             ADD      R1,SP,#+4
   \   00000048   0x9001             STR      R0,[SP, #+4]
   \   0000004A   0x.... 0x....      LDR.W    R0,??DataTable16_5  ;; 0x40020800
   \   0000004E   0x.... 0x....      BL       HAL_GPIO_Init
   \   00000052   0x.... 0x....      LDR.W    R0,??DataTable16_6
   \   00000056   0x.... 0x....      BL       HAL_I2C_MspDeInit
   \   0000005A   0x.... 0x....      LDR.W    R0,??DataTable16_7
   \   0000005E   0x6800             LDR      R0,[R0, #+0]
   \   00000060   0x69C1             LDR      R1,[R0, #+28]
   \   00000062   0xF421 0x6180      BIC      R1,R1,#0x400
   \   00000066   0x61C1             STR      R1,[R0, #+28]
   \   00000068   0x.... 0x....      LDR.W    R0,??DataTable16_8  ;; 0x40023840
   \   0000006C   0x6801             LDR      R1,[R0, #+0]
   \   0000006E   0xF441 0x4100      ORR      R1,R1,#0x8000
   \   00000072   0x6001             STR      R1,[R0, #+0]
   \   00000074   0x6801             LDR      R1,[R0, #+0]
   \   00000076   0xF401 0x4100      AND      R1,R1,#0x8000
   \   0000007A   0x9100             STR      R1,[SP, #+0]
   \   0000007C   0x9900             LDR      R1,[SP, #+0]
   \   0000007E   0x.... 0x....      BL       ?Subroutine4
   \                     ??CrossCallReturnLabel_6: (+1)
   \   00000082   0x.... 0x....      BL       ?Subroutine4
    202            
    203            return 0;
   \                     ??CrossCallReturnLabel_7: (+1)
   \   00000086   0x2000             MOVS     R0,#+0
   \   00000088   0xB007             ADD      SP,SP,#+28
   \   0000008A   0xBD00             POP      {PC}             ;; return
    204          }
    205          
    206          /**
    207            * @brief  Starts playing audio stream from a data buffer for a determined size. 
    208            * @param  pBuffer: Pointer to the buffer 
    209            * @param  Size: Number of audio data BYTES.
    210            * @retval 0 if correct communication, else wrong communication
    211            */

   \                                 In section .text, align 2, keep-with-next
    212          uint32_t AUDIO_Play(uint16_t* pBuffer, uint32_t Size)
    213          {
   \                     AUDIO_Play: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x460D             MOV      R5,R1
    214            /* Set the total number of data to be played (count in half-word) */
    215            AudioTotalSize = Size;
    216          
    217            /* Call the audio Codec Play function */
    218            Codec_Play();
    219            
    220            /* Update the Media layer and enable it for play */  
    221            Audio_MAL_Play(pBuffer, (uint16_t)(DMA_MAX(Size/4)));
   \   00000004   0x08A9             LSRS     R1,R5,#+2
   \   00000006   0xF5B1 0x3F80      CMP      R1,#+65536
   \   0000000A   0x.... 0x....      LDR.W    R6,??DataTable16_9
   \   0000000E   0x6035             STR      R5,[R6, #+0]
   \   00000010   0x4604             MOV      R4,R0
   \   00000012   0xBF28             IT       CS 
   \   00000014   0xF64F 0x71FF      MOVWCS   R1,#+65535
   \   00000018   0xB289             UXTH     R1,R1
   \   0000001A   0x.... 0x....      BL       Audio_MAL_Play
    222            
    223            /* Update the remaining number of data to be played */
    224            AudioRemSize = (Size/2) - DMA_MAX(AudioTotalSize)/2;//1 sop1hc: change "DMA_MAX(AudioTotalSize)" to "DMA_MAX(AudioTotalSize)/2"
   \   0000001E   0x6830             LDR      R0,[R6, #+0]
   \   00000020   0xF5B0 0x3F80      CMP      R0,#+65536
   \   00000024   0xBF34             ITE      CC 
   \   00000026   0x0841             LSRCC    R1,R0,#+1
   \   00000028   0xF647 0x71FF      MOVWCS   R1,#+32767
   \   0000002C   0xEBC1 0x0155      RSB      R1,R1,R5, LSR #+1
    225            
    226            /* Update the current audio pointer position */
    227            CurrentPos = pBuffer + DMA_MAX(AudioTotalSize);
   \   00000030   0xF5B0 0x3F80      CMP      R0,#+65536
   \   00000034   0x6071             STR      R1,[R6, #+4]
   \   00000036   0xBF34             ITE      CC 
   \   00000038   0x0040             LSLCC    R0,R0,#+1
   \   0000003A   0x.... 0x....      LDRCS.W  R0,??DataTable16_10  ;; 0x1fffe
   \   0000003E   0x1900             ADDS     R0,R0,R4
   \   00000040   0x60B0             STR      R0,[R6, #+8]
    228            
    229            return 0;
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0xBD70             POP      {R4-R6,PC}       ;; return
    230          }
    231          
    232          /**
    233            * @brief  This function Pauses or Resumes the audio file stream. In case
    234            *         of using DMA, the DMA Pause feature is used. In all cases the I2S 
    235            *         peripheral is disabled. 
    236            * 
    237            * @WARNING When calling AUDIO_PauseResume() function for pause, only
    238            *          this function should be called for resume (use of AUDIO_Play() 
    239            *          function for resume could lead to unexpected behavior).
    240            * 
    241            * @param  Cmd: AUDIO_PAUSE (or 0) to pause, AUDIO_RESUME (or any value different
    242            *         from 0) to resume. 
    243            * @retval 0 if correct communication, else wrong communication
    244            */

   \                                 In section .text, align 2, keep-with-next
    245          uint32_t AUDIO_PauseResume(uint32_t Cmd)
    246          {    
   \                     AUDIO_PauseResume: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
    247            /* Call the Audio Codec Pause/Resume function */
    248            if (Codec_PauseResume(Cmd) != 0)
   \   00000004   0xD105             BNE.N    ??AUDIO_PauseResume_0
   \   00000006   0x2001             MOVS     R0,#+1
   \   00000008   0x.... 0x....      BL       Codec_Mute
   \   0000000C   0x4605             MOV      R5,R0
   \   0000000E   0x2101             MOVS     R1,#+1
   \   00000010   0xE00B             B.N      ??AUDIO_PauseResume_1
   \                     ??AUDIO_PauseResume_0: (+1)
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0x.... 0x....      BL       Codec_Mute
   \   00000018   0x4605             MOV      R5,R0
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable16
   \   0000001E   0x7801             LDRB     R1,[R0, #+0]
   \   00000020   0x2004             MOVS     R0,#+4
   \   00000022   0x.... 0x....      BL       Codec_WriteRegister
   \   00000026   0x1945             ADDS     R5,R0,R5
   \   00000028   0x219E             MOVS     R1,#+158
   \                     ??AUDIO_PauseResume_1: (+1)
   \   0000002A   0x.... 0x....      BL       ??Subroutine6_0
   \                     ??CrossCallReturnLabel_13: (+1)
   \   0000002E   0x1940             ADDS     R0,R0,R5
   \   00000030   0xD001             BEQ.N    ??AUDIO_PauseResume_2
    249            {
    250              return 1;
   \   00000032   0x2001             MOVS     R0,#+1
   \   00000034   0xBD70             POP      {R4-R6,PC}
    251            }
    252            else
    253            {
    254              /* Call the Media layer pause/resume function */
    255              Audio_MAL_PauseResume(Cmd, 0);
   \                     ??AUDIO_PauseResume_2: (+1)
   \   00000036   0x.... 0x....      LDR.W    R5,??DataTable16_11  ;; 0x400260b8
   \   0000003A   0x.... 0x....      LDR.W    R6,??DataTable16_12  ;; 0x40003c00
   \   0000003E   0xB94C             CBNZ.N   R4,??AUDIO_PauseResume_3
   \   00000040   0x2200             MOVS     R2,#+0
   \   00000042   0x2102             MOVS     R1,#+2
   \   00000044   0x4630             MOV      R0,R6
   \   00000046   0x.... 0x....      BL       SPI_I2S_DMACmd
   \   0000004A   0x2100             MOVS     R1,#+0
   \   0000004C   0x4628             MOV      R0,R5
   \   0000004E   0x.... 0x....      BL       DMA_Cmd
   \   00000052   0xE00F             B.N      ??AUDIO_PauseResume_4
   \                     ??AUDIO_PauseResume_3: (+1)
   \   00000054   0x2201             MOVS     R2,#+1
   \   00000056   0x2102             MOVS     R1,#+2
   \   00000058   0x4630             MOV      R0,R6
   \   0000005A   0x.... 0x....      BL       SPI_I2S_DMACmd
   \   0000005E   0x2101             MOVS     R1,#+1
   \   00000060   0x4628             MOV      R0,R5
   \   00000062   0x.... 0x....      BL       DMA_Cmd
   \   00000066   0x69F0             LDR      R0,[R6, #+28]
   \   00000068   0x0540             LSLS     R0,R0,#+21
   \   0000006A   0xD403             BMI.N    ??AUDIO_PauseResume_4
   \   0000006C   0x69F0             LDR      R0,[R6, #+28]
   \   0000006E   0xF440 0x6080      ORR      R0,R0,#0x400
   \   00000072   0x61F0             STR      R0,[R6, #+28]
    256              
    257              /* Return 0 if all operations are OK */
    258              return 0;
   \                     ??AUDIO_PauseResume_4: (+1)
   \   00000074   0x2000             MOVS     R0,#+0
   \   00000076   0xBD70             POP      {R4-R6,PC}       ;; return
    259            }
    260          }
    261          
    262          /**
    263            * @brief  Stops audio playing and Power down the Audio Codec. 
    264            * @param  Option: could be one of the following parameters 
    265            *           - CODEC_PDWN_SW: for software power off (by writing registers). 
    266            *                            Then no need to reconfigure the Codec after power on.
    267            *           - CODEC_PDWN_HW: completely shut down the codec (physically). 
    268            *                            Then need to reconfigure the Codec after power on.  
    269            * @retval 0 if correct communication, else wrong communication
    270            */

   \                                 In section .text, align 2, keep-with-next
    271          uint32_t AUDIO_Stop(uint32_t Option)
    272          {
   \                     AUDIO_Stop: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    273            /* Call Audio Codec Stop function */
    274            if (Codec_Stop(Option) != 0)
   \   00000004   0x2001             MOVS     R0,#+1
   \   00000006   0x.... 0x....      BL       Codec_Mute
   \   0000000A   0x2C02             CMP      R4,#+2
   \   0000000C   0xD104             BNE.N    ??AUDIO_Stop_0
   \   0000000E   0x219F             MOVS     R1,#+159
   \   00000010   0x.... 0x....      BL       ??Subroutine6_0
   \                     ??CrossCallReturnLabel_12: (+1)
   \   00000014   0x4604             MOV      R4,R0
   \   00000016   0xE00D             B.N      ??AUDIO_Stop_1
   \                     ??AUDIO_Stop_0: (+1)
   \   00000018   0x219F             MOVS     R1,#+159
   \   0000001A   0x.... 0x....      BL       ??Subroutine6_0
   \                     ??CrossCallReturnLabel_11: (+1)
   \   0000001E   0x4604             MOV      R4,R0
   \   00000020   0xF640 0x70FF      MOVW     R0,#+4095
   \   00000024   0x.... 0x....      BL       Delay
   \   00000028   0x2200             MOVS     R2,#+0
   \   0000002A   0x2110             MOVS     R1,#+16
   \   0000002C   0x.... 0x....      LDR.W    R0,??DataTable16_2  ;; 0x40020c00
   \   00000030   0x.... 0x....      BL       HAL_GPIO_WritePin
   \                     ??AUDIO_Stop_1: (+1)
   \   00000034   0xB10C             CBZ.N    R4,??AUDIO_Stop_2
    275            {
    276              return 1;
   \   00000036   0x2001             MOVS     R0,#+1
   \   00000038   0xBD10             POP      {R4,PC}
    277            }
    278            else
    279            {
    280              /* Call Media layer Stop function */
    281              Audio_MAL_Stop();
   \                     ??AUDIO_Stop_2: (+1)
   \   0000003A   0x.... 0x....      LDR.W    R0,??DataTable16_7
   \   0000003E   0x.... 0x....      BL       HAL_I2S_DMAStop
    282              
    283              /* Update the remaining data number */
    284              AudioRemSize = AudioTotalSize;    
   \   00000042   0x.... 0x....      LDR.W    R0,??DataTable16_9
   \   00000046   0x6801             LDR      R1,[R0, #+0]
   \   00000048   0x6041             STR      R1,[R0, #+4]
    285              
    286              /* Return 0 when all operations are correctly done */
    287              return 0;
   \   0000004A   0x2000             MOVS     R0,#+0
   \   0000004C   0xBD10             POP      {R4,PC}          ;; return
    288            }
    289          }
    290          
    291          /**
    292            * @brief  Controls the current audio volume level. 
    293            * @param  Volume: Volume level to be set in percentage from 0% to 100% (0 for 
    294            *         Mute and 100 for Max volume level).
    295            * @retval 0 if correct communication, else wrong communication
    296            */

   \                                 In section .text, align 2, keep-with-next
    297          uint32_t AUDIO_VolumeCtl(uint8_t Vol)
   \                     AUDIO_VolumeCtl: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable16
   \   00000004   0x7840             LDRB     R0,[R0, #+1]
   \   00000006   0x2865             CMP      R0,#+101
   \   00000008   0xBFAF             ITEEE    GE 
   \   0000000A   0x2064             MOVGE    R0,#+100
   \   0000000C   0xEBC0 0x2000      RSBLT    R0,R0,R0, LSL #+8
   \   00000010   0x2164             MOVLT    R1,#+100
   \   00000012   0xFB90 0xF0F1      SDIVLT   R0,R0,R1
   \   00000016   0xB2C0             UXTB     R0,R0
   \   00000018   0x....             B.N      Codec_VolumeCtrl
    298          {
    299            /* Call the codec volume control function with converted volume value */
    300            return (Codec_VolumeCtrl(VOLUME_CONVERT(Vol)));
    301          }
    302          
    303          /**
    304            * @brief  Enables or disables the MUTE mode by software 
    305            * @param  Command: could be AUDIO_MUTE_ON to mute sound or AUDIO_MUTE_OFF to 
    306            *         unmute the codec and restore previous volume level.
    307            * @retval 0 if correct communication, else wrong communication
    308            */

   \                                 In section .text, align 2, keep-with-next
    309          uint32_t AUDIO_Mute(uint32_t Cmd)
    310          { 
    311            /* Call the Codec Mute function */
    312            return (Codec_Mute(Cmd));
   \                     AUDIO_Mute: (+1)
   \   00000000   0x....             B.N      Codec_Mute
    313          }
    314          
    315          
    316          /**
    317            * @brief  This function handles main I2S interrupt. 
    318            * @param  None
    319            * @retval 0 if correct communication, else wrong communication
    320            */

   \                                 In section .text, align 2, keep-with-next
    321          void DMA1_Stream7_IRQHandler(void)
    322          { 
    323          	HAL_DMA_IRQHandler(hi2s3.hdmatx);
   \                     DMA1_Stream7_IRQHandler: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable16_7
   \   00000004   0x6B00             LDR      R0,[R0, #+48]
   \   00000006   0x.... 0x....      B.W      HAL_DMA_IRQHandler
    324          }
    325          
    326          /**
    327            * @brief  This function handles main DAC interrupt. 
    328            * @param  None
    329            * @retval None
    330            */

   \                                 In section .text, align 2, keep-with-next
    331          void DMA1_Stream0_IRQHandler(void)
    332          {
    333            //DAC is not used any more
    334            //Audio_MAL_IRQHandler();
    335          }
   \                     DMA1_Stream0_IRQHandler: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    336          
    337          /**
    338            * @brief  I2S interrupt management
    339            * @param  None
    340            * @retval None
    341            */

   \                                 In section .text, align 2, keep-with-next
    342          void SPI3_IRQHandler(void)
    343          {
    344            /* Check on the I2S TXE flag */  
    345            if (__HAL_SPI_GET_FLAG(&hi2s3, SPI_IT_TXE) != RESET)
   \                     SPI3_IRQHandler: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable16_7
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x6880             LDR      R0,[R0, #+8]
    346            { 
    347             
    348              /* Send dummy data on I2S to avoid the underrun condition */
    349               //SPI_I2S_SendData(CODEC_I2S, AUDIO_GetSampleCallBack()); 
    350            }
    351          }
   \   00000008   0x4770             BX       LR               ;; return
    352          /*========================
    353                          CS43L22 Audio Codec Control Functions
    354                                                          ==============================*/
    355          /**
    356            * @brief  Initializes the audio codec and all related interfaces (control 
    357            *         interface: I2C and audio interface: I2S)
    358            * @param  OutputDevice: can be OUTPUT_DEVICE_SPEAKER, OUTPUT_DEVICE_HEADPHONE,
    359            *                       OUTPUT_DEVICE_BOTH or OUTPUT_DEVICE_AUTO .
    360            * @param  Volume: Initial volume level (from 0 (Mute) to 100 (Max))
    361            * @param  AudioFreq: Audio frequency used to play the audio stream.
    362            * @retval 0 if correct communication, else wrong communication
    363            */
    364          static uint32_t Codec_Init(uint16_t OutputDevice, uint8_t Vol, uint32_t AudioFreq)
    365          {
    366            uint32_t counter = 0; 
    367          
    368            /* Configure the Codec related IOs */
    369            Codec_GPIO_Init();   //only reset Pin configuration
    370            
    371            /* Reset the Codec Registers */
    372            Codec_Reset(); //  OFF ON the oin reset
    373          
    374            /* Initialize the Control interface of the Audio Codec */
    375            Codec_CtrlInterface_Init();     // I2C1 pin configuration
    376            
    377            /* Keep Codec powered OFF */
    378            counter += Codec_WriteRegister(0x02, 0x01);  
    379                
    380            counter += Codec_WriteRegister(0x04, 0xAF); /* SPK always OFF & HP always ON */
    381            OutputDev = 0xAF;
    382            
    383            /* Clock configuration: Auto detection */  
    384            counter += Codec_WriteRegister(0x05, 0x81);
    385            
    386            /* Set the Slave Mode and the audio Standard */  
    387            counter += Codec_WriteRegister(0x06, CODEC_STANDARD);
    388                
    389            /* Set the Master volume */
    390            Codec_VolumeCtrl(Vol);
    391            
    392          
    393            /* Power on the Codec */
    394            counter += Codec_WriteRegister(0x02, 0x9E);  
    395            
    396            /* Additional configuration for the CODEC. These configurations are done to reduce
    397                the time needed for the Codec to power off. If these configurations are removed, 
    398                then a long delay should be added between powering off the Codec and switching 
    399                off the I2S peripheral MCLK clock (which is the operating clock for Codec).
    400                If this delay is not inserted, then the codec will not shut down properly and
    401                it results in high noise after shut down. */
    402            
    403            /* Disable the analog soft ramp */
    404            counter += Codec_WriteRegister(0x0A, 0x00);
    405          
    406          	/* Disable the digital soft ramp */
    407          	counter += Codec_WriteRegister(0x0E, 0x04);
    408          
    409            /* Disable the limiter attack level */
    410            counter += Codec_WriteRegister(0x27, 0x00);
    411            /* Adjust Bass and Treble levels */
    412            counter += Codec_WriteRegister(0x1F, 0x0F);
    413            /* Adjust PCM volume level */
    414            counter += Codec_WriteRegister(0x1A, 0x0A);
    415            counter += Codec_WriteRegister(0x1B, 0x0A);
    416          
    417            /* Configure the I2S peripheral */
    418            Codec_AudioInterface_Init(AudioFreq);  //I2S3 is using
    419            
    420            /* Return communication control value */
    421            return counter;  
    422          }
    423          
    424          /**
    425            * @brief  Restore the audio codec state to default state and free all used 
    426            *         resources.
    427            * @param  None
    428            * @retval 0 if correct communication, else wrong communication
    429            */
    430          static uint32_t Codec_DeInit(void)
    431          {
    432            uint32_t counter = 0; 
    433          
    434            /* Reset the Codec Registers */
    435            Codec_Reset();  
    436            
    437            /* Keep Codec powered OFF */
    438            counter += Codec_WriteRegister(0x02, 0x01);    
    439            
    440            /* Deinitialize all use GPIOs */
    441            Codec_GPIO_DeInit();
    442          
    443            /* Disable the Codec control interface */
    444            Codec_CtrlInterface_DeInit();
    445            
    446            /* Deinitialize the Codec audio interface (I2S) */
    447            Codec_AudioInterface_DeInit(); 
    448            
    449            /* Return communication control value */
    450            return counter;  
    451          }
    452          
    453          /**
    454            * @brief  Start the audio Codec play feature.
    455            * @note   For this codec no Play options are required.
    456            * @param  None
    457            * @retval 0 if correct communication, else wrong communication
    458            */
    459          static uint32_t Codec_Play(void)
    460          {
    461            /* 
    462               No actions required on Codec level for play command
    463               */  
    464          
    465            /* Return communication control value */
    466            return 0;  
    467          }
    468          
    469          /**
    470            * @brief  Pauses and resumes playing on the audio codec.
    471            * @param  Cmd: AUDIO_PAUSE (or 0) to pause, AUDIO_RESUME (or any value different
    472            *         from 0) to resume. 
    473            * @retval 0 if correct communication, else wrong communication
    474            */
    475          static uint32_t Codec_PauseResume(uint32_t Cmd)
    476          {
    477            uint32_t counter = 0;   
    478            
    479            /* Pause the audio file playing */
    480            if (Cmd == AUDIO_PAUSE)
    481            { 
    482              /* Mute the output first */
    483              counter += Codec_Mute(AUDIO_MUTE_ON);
    484          
    485              /* Put the Codec in Power save mode */    
    486              counter += Codec_WriteRegister(0x02, 0x01);    
    487            }
    488            else /* AUDIO_RESUME */
    489            {
    490              /* Unmute the output first */
    491              counter += Codec_Mute(AUDIO_MUTE_OFF);
    492              
    493              counter += Codec_WriteRegister(0x04, OutputDev);
    494              
    495              /* Exit the Power save mode */
    496              counter += Codec_WriteRegister(0x02, 0x9E); 
    497            }
    498          
    499            return counter;
    500          }
    501          
    502          /**
    503            * @brief  Stops audio Codec playing. It powers down the codec.
    504            * @param  CodecPdwnMode: selects the  power down mode.
    505            *          - CODEC_PDWN_SW: only mutes the audio codec. When resuming from this 
    506            *                           mode the codec keeps the previous initialization
    507            *                           (no need to re-Initialize the codec registers).
    508            *          - CODEC_PDWN_HW: Physically power down the codec. When resuming from this
    509            *                           mode, the codec is set to default configuration 
    510            *                           (user should re-Initialize the codec in order to 
    511            *                            play again the audio stream).
    512            * @retval 0 if correct communication, else wrong communication
    513            */
    514          static uint32_t Codec_Stop(uint32_t CodecPdwnMode)
    515          {
    516            uint32_t counter = 0;   
    517          
    518            /* Mute the output first */
    519            Codec_Mute(AUDIO_MUTE_ON);
    520            
    521            if (CodecPdwnMode == CODEC_PDWN_SW)
    522            {    
    523              /* Power down the DAC and the speaker (PMDAC and PMSPK bits)*/
    524              counter += Codec_WriteRegister(0x02, 0x9F);
    525            }
    526            else /* CODEC_PDWN_HW */
    527            { 
    528              /* Power down the DAC components */
    529              counter += Codec_WriteRegister(0x02, 0x9F);
    530              
    531              /* Wait at least 100us */
    532              Delay(0xFFF);
    533              
    534              /* Reset The pin */
    535              HAL_GPIO_WritePin(AUDIO_RESET_GPIO, AUDIO_RESET_PIN, GPIO_PIN_RESET);
    536            }
    537            
    538            return counter;    
    539          }
    540          
    541          /**
    542            * @brief  Sets higher or lower the codec volume level.
    543            * @param  Volume: a byte value from 0 to 255 (refer to codec registers 
    544            *         description for more details).
    545            * @retval 0 if correct communication, else wrong communication
    546            */

   \                                 In section .text, align 2, keep-with-next
    547          static uint32_t Codec_VolumeCtrl(uint8_t Vol)
    548          {
   \                     Codec_VolumeCtrl: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    549            uint32_t counter = 0;
    550            
    551            if (Volume > 0xE6)
   \   00000002   0x.... 0x....      LDR.W    R4,??DataTable16
   \   00000006   0x7860             LDRB     R0,[R4, #+1]
   \   00000008   0xF100 0x0119      ADD      R1,R0,#+25
   \   0000000C   0xB2C9             UXTB     R1,R1
    552            {
    553              /* Set the Master volume */
    554              counter += Codec_WriteRegister(0x20, Volume - 0xE7); 
    555              counter += Codec_WriteRegister(0x21, Volume - 0xE7);     
    556            }
    557            else
    558            {
    559              /* Set the Master volume */
    560              counter += Codec_WriteRegister(0x20, Volume + 0x19); 
   \   0000000E   0x2020             MOVS     R0,#+32
   \   00000010   0x.... 0x....      BL       Codec_WriteRegister
   \   00000014   0x4605             MOV      R5,R0
    561              counter += Codec_WriteRegister(0x21, Volume + 0x19); 
   \   00000016   0x7860             LDRB     R0,[R4, #+1]
   \   00000018   0xF100 0x0119      ADD      R1,R0,#+25
   \   0000001C   0xB2C9             UXTB     R1,R1
   \   0000001E   0x2021             MOVS     R0,#+33
   \   00000020   0x.... 0x....      BL       Codec_WriteRegister
   \   00000024   0x1940             ADDS     R0,R0,R5
    562            }
    563          
    564            return counter;  
   \   00000026   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    565          }
    566          
    567          /**
    568            * @brief  Enables or disables the mute feature on the audio codec.
    569            * @param  Cmd: AUDIO_MUTE_ON to enable the mute or AUDIO_MUTE_OFF to disable the
    570            *             mute mode.
    571            * @retval 0 if correct communication, else wrong communication
    572            */

   \                                 In section .text, align 2, keep-with-next
    573          static uint32_t Codec_Mute(uint32_t Cmd)
    574          {
    575            uint32_t counter = 0;  
    576            
    577            /* Set the Mute mode */
    578            if (Cmd == AUDIO_MUTE_ON)
   \                     Codec_Mute: (+1)
   \   00000000   0x2801             CMP      R0,#+1
   \   00000002   0xBF0E             ITEE     EQ 
   \   00000004   0x21FF             MOVEQ    R1,#+255
   \   00000006   0x.... 0x....      LDRNE.W  R0,??DataTable16
   \   0000000A   0x7801             LDRBNE   R1,[R0, #+0]
    579            {
    580              counter += Codec_WriteRegister(0x04, 0xFF);
    581            }
    582            else /* AUDIO_MUTE_OFF Disable the Mute */
    583            {
    584              counter += Codec_WriteRegister(0x04, OutputDev);
   \   0000000C   0x2004             MOVS     R0,#+4
   \   0000000E   0x....             B.N      Codec_WriteRegister
    585            }
    586            
    587            return counter; 
    588          }
    589          
    590          /**
    591            * @brief  Resets the audio codec. It restores the default configuration of the 
    592            *         codec (this function shall be called before initializing the codec).
    593            * @note   This function calls an external driver function: The IO Expander driver.
    594            * @param  None
    595            * @retval None
    596            */

   \                                 In section .text, align 2, keep-with-next
    597          static void Codec_Reset(void)
    598          {
   \                     Codec_Reset: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    599            /* Power Down the codec */
    600            HAL_GPIO_WritePin(AUDIO_RESET_GPIO, AUDIO_RESET_PIN, GPIO_PIN_RESET);
   \   00000002   0x.... 0x....      LDR.W    R4,??DataTable16_2  ;; 0x40020c00
   \   00000006   0x2200             MOVS     R2,#+0
   \   00000008   0x2110             MOVS     R1,#+16
   \   0000000A   0x4620             MOV      R0,R4
   \   0000000C   0x.... 0x....      BL       HAL_GPIO_WritePin
    601          
    602            /* wait for a delay to insure registers erasing */
    603            Delay(CODEC_RESET_DELAY); 
   \   00000010   0xF644 0x70FF      MOVW     R0,#+20479
   \   00000014   0x.... 0x....      BL       Delay
    604            
    605            /* Power on the codec */
    606            HAL_GPIO_WritePin(AUDIO_RESET_GPIO, AUDIO_RESET_PIN,GPIO_PIN_SET);
   \   00000018   0x4620             MOV      R0,R4
   \   0000001A   0x2201             MOVS     R2,#+1
   \   0000001C   0x2110             MOVS     R1,#+16
   \   0000001E   0xE8BD 0x4010      POP      {R4,LR}
   \   00000022   0x.... 0x....      B.W      HAL_GPIO_WritePin
    607          }
    608          
    609          /**
    610            * @brief  Writes a Byte to a given register into the audio codec through the 
    611                      control interface (I2C)
    612            * @param  RegisterAddr: The address (location) of the register to be written.
    613            * @param  RegisterValue: the Byte value to be written into destination register.
    614            * @retval 0 if correct communication, else wrong communication
    615            */

   \                                 In section .text, align 2, keep-with-next
    616          static uint32_t Codec_WriteRegister(uint8_t RegisterAddr, uint8_t RegisterValue)
    617          {
   \                     Codec_WriteRegister: (+1)
   \   00000000   0xB57C             PUSH     {R2-R6,LR}
   \   00000002   0x4606             MOV      R6,R0
   \   00000004   0x460C             MOV      R4,R1
    618            uint32_t result = 0;
    619            uint8_t bufI2C[2];
    620            bufI2C[0] = RegisterAddr;
   \   00000006   0xF88D 0x6006      STRB     R6,[SP, #+6]
    621            bufI2C[1] = RegisterValue;
   \   0000000A   0x.... 0x....      LDR.W    R5,??DataTable16_6
   \   0000000E   0xF88D 0x4007      STRB     R4,[SP, #+7]
    622            /* Transmit the first address for write operation */
    623            while(HAL_I2C_Master_Transmit(&hi2c1, CODEC_ADDRESS, &bufI2C[0],2,CODEC_LONG_TIMEOUT)!= HAL_OK)//CODEC_LONG_TIMEOUT
   \                     ??Codec_WriteRegister_0: (+1)
   \   00000012   0xF44F 0x1096      MOV      R0,#+1228800
   \   00000016   0x2302             MOVS     R3,#+2
   \   00000018   0x9000             STR      R0,[SP, #+0]
   \   0000001A   0xF10D 0x0206      ADD      R2,SP,#+6
   \   0000001E   0x2194             MOVS     R1,#+148
   \   00000020   0x4628             MOV      R0,R5
   \   00000022   0x.... 0x....      BL       HAL_I2C_Master_Transmit
   \   00000026   0xB138             CBZ.N    R0,??Codec_WriteRegister_1
    624            {
    625          	/* Error_Handler() function is called when Timeout error occurs.
    626          	When Acknowledge failure occurs (Slave don't acknowledge its address)
    627          	Master restarts communication */
    628              if (HAL_I2C_GetError(&hi2c1) != HAL_I2C_ERROR_AF)
   \   00000028   0x4628             MOV      R0,R5
   \   0000002A   0x.... 0x....      BL       HAL_I2C_GetError
   \   0000002E   0x2804             CMP      R0,#+4
   \   00000030   0xD0EF             BEQ.N    ??Codec_WriteRegister_0
    629              {
    630                  return Codec_TIMEOUT_UserCallback();;
   \   00000032   0x.... 0x....      BL       Codec_TIMEOUT_UserCallback
   \   00000036   0xBD76             POP      {R1,R2,R4-R6,PC}
    631              }
    632          
    633            }
    634            
    635             
    636          #ifdef VERIFY_WRITTENDATA
    637            /* Verify that the data has been correctly written */ 
    638            uint8_t test;
    639            test = Codec_ReadRegister(RegisterAddr);
   \                     ??Codec_WriteRegister_1: (+1)
   \   00000038   0xF88D 0x6005      STRB     R6,[SP, #+5]
   \   0000003C   0xF88D 0x0004      STRB     R0,[SP, #+4]
   \                     ??Codec_WriteRegister_2: (+1)
   \   00000040   0xF44F 0x1096      MOV      R0,#+1228800
   \   00000044   0x2301             MOVS     R3,#+1
   \   00000046   0x9000             STR      R0,[SP, #+0]
   \   00000048   0xF10D 0x0205      ADD      R2,SP,#+5
   \   0000004C   0x2194             MOVS     R1,#+148
   \   0000004E   0x4628             MOV      R0,R5
   \   00000050   0x.... 0x....      BL       HAL_I2C_Master_Transmit
   \   00000054   0xB128             CBZ.N    R0,??Codec_WriteRegister_3
   \   00000056   0x4628             MOV      R0,R5
   \   00000058   0x.... 0x....      BL       HAL_I2C_GetError
   \   0000005C   0x2804             CMP      R0,#+4
   \   0000005E   0xD0EF             BEQ.N    ??Codec_WriteRegister_2
   \   00000060   0xE00E             B.N      ??Codec_WriteRegister_4
   \                     ??Codec_WriteRegister_3: (+1)
   \   00000062   0xF44F 0x1096      MOV      R0,#+1228800
   \   00000066   0x2301             MOVS     R3,#+1
   \   00000068   0x9000             STR      R0,[SP, #+0]
   \   0000006A   0xAA01             ADD      R2,SP,#+4
   \   0000006C   0x2194             MOVS     R1,#+148
   \   0000006E   0x4628             MOV      R0,R5
   \   00000070   0x.... 0x....      BL       HAL_I2C_Master_Receive
   \   00000074   0xB138             CBZ.N    R0,??Codec_WriteRegister_5
   \   00000076   0x4628             MOV      R0,R5
   \   00000078   0x.... 0x....      BL       HAL_I2C_GetError
   \   0000007C   0x2804             CMP      R0,#+4
   \   0000007E   0xD0F0             BEQ.N    ??Codec_WriteRegister_3
   \                     ??Codec_WriteRegister_4: (+1)
   \   00000080   0x.... 0x....      BL       Codec_TIMEOUT_UserCallback
   \   00000084   0xE001             B.N      ??Codec_WriteRegister_6
   \                     ??Codec_WriteRegister_5: (+1)
   \   00000086   0xF89D 0x0004      LDRB     R0,[SP, #+4]
    640            result = (test == RegisterValue)? 0:1;
   \                     ??Codec_WriteRegister_6: (+1)
   \   0000008A   0xB2C0             UXTB     R0,R0
   \   0000008C   0x42A0             CMP      R0,R4
   \   0000008E   0xBF0C             ITE      EQ 
   \   00000090   0x2000             MOVEQ    R0,#+0
   \   00000092   0x2001             MOVNE    R0,#+1
   \   00000094   0xBD76             POP      {R1,R2,R4-R6,PC}
    641          #endif /* VERIFY_WRITTENDATA */
    642          
    643            /* Return the verifying value: 0 (Passed) or 1 (Failed) */
    644            return result;  
    645          }
    646          
    647          /**
    648            * @brief  Reads and returns the value of an audio codec register through the
    649            *         control interface (I2C).
    650            * @param  RegisterAddr: Address of the register to be read.
    651            * @retval Value of the register to be read or dummy value if the communication
    652            *         fails.
    653            */
    654          static uint32_t Codec_ReadRegister(uint8_t RegisterAddr)
    655          {
    656            uint8_t result = 0;
    657          
    658            /* Transmit the register address to be read */
    659            /* Transmit the first address for write operation */
    660            while(HAL_I2C_Master_Transmit(&hi2c1, CODEC_ADDRESS, &RegisterAddr,1,CODEC_LONG_TIMEOUT)!= HAL_OK)
    661            {
    662          	/* Error_Handler() function is called when Timeout error occurs.
    663          	When Acknowledge failure occurs (Slave don't acknowledge its address)
    664          	Master restarts communication */
    665              if (HAL_I2C_GetError(&hi2c1) != HAL_I2C_ERROR_AF)
    666              {
    667                return Codec_TIMEOUT_UserCallback();
    668              }  
    669            }
    670            
    671            /*!< Read the byte received from the Codec */
    672            //result = I2C_ReceiveData(CODEC_I2C);
    673            while(HAL_I2C_Master_Receive(&hi2c1, (uint16_t)CODEC_ADDRESS, &result, 1, CODEC_LONG_TIMEOUT) != HAL_OK)
    674            {
    675              /* Error_Handler() function is called when Timeout error occurs.
    676                 When Acknowledge failure occurs (Slave don't acknowledge it's address)
    677                 Master restarts communication */
    678              if (HAL_I2C_GetError(&hi2c1) != HAL_I2C_ERROR_AF)
    679              {
    680                return Codec_TIMEOUT_UserCallback();
    681              }
    682            }
    683            
    684            /* Return the byte read from Codec */
    685            return (uint32_t)result;
    686          }
    687          
    688          /**
    689            * @brief  Initializes the Audio Codec control interface (I2C).
    690            * @param  None
    691            * @retval None
    692            */
    693          static void Codec_CtrlInterface_Init(void)
    694          {
    695              MX_I2C1_Init();   
    696          }
    697          
    698          /**
    699            * @brief  Restore the Audio Codec control interface to its default state.
    700            *         This function doesn't de-initialize the I2C because the I2C peripheral
    701            *         may be used by other modules.
    702            * @param  None
    703            * @retval None
    704            */
    705          static void Codec_CtrlInterface_DeInit(void)
    706          {
    707            /* Disable the I2C peripheral */ /* This step is not done here because 
    708               the I2C interface can be used by other modules */
    709            /* I2C_DeInit(CODEC_I2C); */
    710            HAL_I2C_MspDeInit(&hi2c1);
    711          }
    712          
    713          /**
    714            * @brief  Initializes the Audio Codec audio interface (I2S)
    715            * @note   This function assumes that the I2S input clock (through PLL_R in 
    716            *         Devices RevA/Z and through dedicated PLLI2S_R in Devices RevB/Y)
    717            *         is already configured and ready to be used.    
    718            * @param  AudioFreq: Audio frequency to be configured for the I2S peripheral. 
    719            * @retval None
    720            */
    721          static void Codec_AudioInterface_Init(uint32_t AudioFreq)
    722          {
    723            I2S3_Init(AudioFreq); 
    724          }
    725          
    726          /**
    727            * @brief  Restores the Audio Codec audio interface to its default state.
    728            * @param  None
    729            * @retval None
    730            */
    731          static void Codec_AudioInterface_DeInit(void)
    732          {
    733            /* Disable the CODEC_I2S peripheral (in case it hasn't already been disabled) */
    734            //I2S_Cmd(CODEC_I2S, DISABLE);
    735            __HAL_I2S_DISABLE(&hi2s3);
    736            /* Deinitialize the CODEC_I2S peripheral */
    737            SPI_I2S_DeInit(CODEC_I2S);
    738            
    739            /* Disable the CODEC_I2S peripheral clock */
    740            //RCC_APB1PeriphClockCmd(CODEC_I2S_CLK, DISABLE); 
    741            __HAL_RCC_SPI3_CLK_DISABLE();
    742          }
    743          
    744          /**
    745            * @brief Initializes IOs used by the Audio Codec (on the control and audio 
    746            *        interfaces).
    747            * @param  None
    748            * @retval None
    749            */
    750          static void Codec_GPIO_Init(void)
    751          {
    752            GPIO_InitTypeDef GPIO_InitStructure;
    753            
    754            __GPIOD_CLK_ENABLE();
    755            
    756            /* Audio reset pin configuration -------------------------------------------------*/
    757            GPIO_InitStructure.Pin = AUDIO_RESET_PIN; 
    758            GPIO_InitStructure.Mode = GPIO_MODE_OUTPUT_PP;//GPIO_Mode_OUT;
    759            GPIO_InitStructure.Speed = GPIO_SPEED_HIGH;//GPIO_Speed_50MHz;
    760            GPIO_InitStructure.Pull  = GPIO_NOPULL ;//GPIO_PuPd_NOPULL;
    761             
    762            HAL_GPIO_Init(AUDIO_RESET_GPIO, &GPIO_InitStructure);    
    763            
    764          }
    765          
    766          /**
    767            * @brief  Restores the IOs used by the Audio Codec interface to their default state.
    768            * @param  None
    769            * @retval None
    770            */
    771          static void Codec_GPIO_DeInit(void)
    772          {
    773            GPIO_InitTypeDef GPIO_InitStructure;
    774            
    775            GPIO_InitStructure.Pin = CODEC_I2S_SCK_PIN | CODEC_I2S_SD_PIN; 
    776            GPIO_InitStructure.Mode = GPIO_MODE_INPUT;
    777            GPIO_InitStructure.Speed = GPIO_SPEED_LOW;
    778            GPIO_InitStructure.Pull = GPIO_NOPULL;
    779            HAL_GPIO_Init(CODEC_I2S_GPIO, &GPIO_InitStructure);
    780                
    781            GPIO_InitStructure.Pin = CODEC_I2S_WS_PIN ;
    782            HAL_GPIO_Init(CODEC_I2S_WS_GPIO, &GPIO_InitStructure); 
    783            
    784          #ifdef CODEC_MCLK_ENABLED
    785            GPIO_InitStructure.Pin = CODEC_I2S_MCK_PIN; 
    786            HAL_GPIO_Init(CODEC_I2S_MCK_GPIO, &GPIO_InitStructure); 
    787          #endif /* CODEC_MCLK_ENABLED */    
    788          }
    789          
    790          /**
    791            * @brief  Inserts a delay time (not accurate timing).
    792            * @param  nCount: specifies the delay time length.
    793            * @retval None
    794            */

   \                                 In section .text, align 2, keep-with-next
    795          static void Delay( __IO uint32_t nCount)
    796          {
   \                     Delay: (+1)
   \   00000000   0xB401             PUSH     {R0}
   \   00000002   0xE002             B.N      ??Delay_0
    797            for (; nCount != 0; nCount--);
   \                     ??Delay_1: (+1)
   \   00000004   0x9800             LDR      R0,[SP, #+0]
   \   00000006   0x1E40             SUBS     R0,R0,#+1
   \   00000008   0x9000             STR      R0,[SP, #+0]
   \                     ??Delay_0: (+1)
   \   0000000A   0x9800             LDR      R0,[SP, #+0]
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD1F9             BNE.N    ??Delay_1
    798          }
   \   00000010   0xB001             ADD      SP,SP,#+4
   \   00000012   0x4770             BX       LR               ;; return
    799          
    800          #ifdef USE_DEFAULT_TIMEOUT_CALLBACK
    801          /**
    802            * @brief  Basic management of the timeout situation.
    803            * @param  None
    804            * @retval None
    805            */
    806          uint32_t Codec_TIMEOUT_UserCallback(void)
    807          {
    808            /* Block communication and all processes */
    809            
    810          }
    811          #endif /* USE_DEFAULT_TIMEOUT_CALLBACK */
    812          /*========================
    813                          Audio MAL Interface Control Functions
    814                                                          ==============================*/
    815          
    816          
    817          /**
    818            * @brief  Restore default state of the used Media.
    819            * @param  None
    820            * @retval None
    821            */
    822          static void Audio_MAL_DeInit(void)  
    823          {   
    824          #if defined(AUDIO_MAL_DMA_IT_TC_EN) || defined(AUDIO_MAL_DMA_IT_HT_EN) || defined(AUDIO_MAL_DMA_IT_TE_EN)
    825            //NVIC_InitTypeDef NVIC_InitStructure;  
    826            
    827            /* Deinitialize the NVIC interrupt for the I2S DMA Stream */
    828            //NVIC_InitStructure.NVIC_IRQChannel = AUDIO_I2S_DMA_IRQ;
    829            //NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = AUDIO_IRQ_PREPRIO;
    830            //NVIC_InitStructure.NVIC_IRQChannelSubPriority = AUDIO_IRQ_SUBRIO;
    831            //NVIC_InitStructure.NVIC_IRQChannelCmd = DISABLE;
    832            //NVIC_Init(&NVIC_InitStructure);  
    833             HAL_NVIC_DisableIRQ(SPI3_IRQn); 
    834          #endif 
    835            
    836            /* Disable the DMA stream before the deinit */
    837            HAL_NVIC_DisableIRQ(DMA1_Stream7_IRQn); 
    838            HAL_NVIC_DisableIRQ(SPI3_IRQn); 
    839            
    840          }
    841          
    842          /**
    843            * @brief  Starts playing audio stream from the audio Media.
    844            * @param  None
    845            * @retval None
    846            */

   \                                 In section .text, align 2, keep-with-next
    847          void Audio_MAL_Play(uint16_t *Addr, uint16_t Size)
    848          {
    849             uint16_t *bufAddrI2S;
    850             bufAddrI2S = Addr;
    851             HAL_I2S_Transmit_DMA(&hi2s3,bufAddrI2S,(uint16_t)Size/2);  
   \                     Audio_MAL_Play: (+1)
   \   00000000   0x084A             LSRS     R2,R1,#+1
   \   00000002   0x4601             MOV      R1,R0
   \   00000004   0x....             LDR.N    R0,??DataTable16_7
   \   00000006   0x.... 0x....      B.W      HAL_I2S_Transmit_DMA
    852          }
    853          
    854          /**
    855            * @brief  Pauses or Resumes the audio stream playing from the Media.
    856            * @param  Cmd: AUDIO_PAUSE (or 0) to pause, AUDIO_RESUME (or any value different
    857            *              from 0) to resume. 
    858            * @param  Addr: Address from/at which the audio stream should resume/pause.
    859            * @retval None
    860            */
    861          static void Audio_MAL_PauseResume(uint32_t Cmd, uint32_t Addr)
    862          {
    863            /* Pause the audio file playing */
    864            if (Cmd == AUDIO_PAUSE)
    865            {   
    866              /* Disable the I2S DMA request */
    867              SPI_I2S_DMACmd(CODEC_I2S, SPI_I2S_DMAReq_Tx, DISABLE);
    868          
    869              /* Pause the I2S DMA Stream 
    870                  Note. For the STM32F40x devices, the DMA implements a pause feature, 
    871                        by disabling the stream, all configuration is preserved and data 
    872                        transfer is paused till the next enable of the stream.
    873                        This feature is not available on STM32F40x devices. */
    874              DMA_Cmd(AUDIO_I2S_DMA_STREAM, DISABLE);
    875            }
    876            else /* AUDIO_RESUME */
    877            {
    878              /* Enable the I2S DMA request */
    879              SPI_I2S_DMACmd(CODEC_I2S, SPI_I2S_DMAReq_Tx, ENABLE);
    880            
    881              /* Resume the I2S DMA Stream 
    882                  Note. For the STM32F40x devices, the DMA implements a pause feature, 
    883                        by disabling the stream, all configuration is preserved and data 
    884                        transfer is paused till the next enable of the stream.
    885                        This feature is not available on STM32F40x devices. */
    886              DMA_Cmd(AUDIO_I2S_DMA_STREAM, ENABLE);
    887              
    888              /* If the I2S peripheral is still not enabled, enable it */
    889              if ((CODEC_I2S->I2SCFGR & I2S_ENABLE_MASK) == 0)
    890              {
    891                I2S_Cmd(CODEC_I2S, ENABLE);
    892              }    
    893            } 
    894          }
    895          
    896          /**
    897            * @brief  Stops audio stream playing on the used Media.
    898            * @param  None
    899            * @retval None
    900            */
    901          static void Audio_MAL_Stop(void)
    902          {   
    903            /* Stop the Transfer on the I2S side: Stop and disable the DMA stream */
    904            //DMA_Cmd(AUDIO_I2S_DMA_STREAM, DISABLE);
    905          
    906            /* Clear all the DMA flags for the next transfer */
    907            //DMA_ClearFlag(AUDIO_I2S_DMA_STREAM, AUDIO_I2S_DMA_FLAG_TC |AUDIO_I2S_DMA_FLAG_HT | \
    908             //                               AUDIO_I2S_DMA_FLAG_FE | AUDIO_I2S_DMA_FLAG_TE);
    909            
    910            /*  
    911                     The I2S DMA requests are not disabled here.
    912                                                                      */
    913            
    914            /* In all modes, disable the I2S peripheral */
    915            //I2S_Cmd(CODEC_I2S, DISABLE);
    916          
    917            //HAL_SPI_MspDeInit(&hi2s3);
    918            HAL_I2S_DMAStop(&hi2s3);
    919          }
    920          
    921          /**
    922            * @brief  DAC  Channel1 Configuration
    923            * @param  None
    924            * @retval None
    925            */

   \                                 In section .text, align 2, keep-with-next
    926          void DAC_Config(void)
    927          {
    928          
    929          }
   \                     DAC_Config: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    930          
    931          
    932          
    933          
    934          
    935          
    936          
    937          /**
    938            * @brief  Enables or disables the specified SPI peripheral (in I2S mode).
    939            * @param  SPIx: where x can be 2 or 3 to select the SPI peripheral (or I2Sxext 
    940            *         for full duplex mode).
    941            * @param  NewState: new state of the SPIx peripheral. 
    942            *         This parameter can be: ENABLE or DISABLE.
    943            * @retval None
    944            */
    945          static void I2S_Cmd(SPI_TypeDef* SPIx, FunctionalState NewState)
    946          {  
    947            if (NewState != DISABLE)
    948            {
    949              /* Enable the selected SPI peripheral (in I2S mode) */
    950              SPIx->I2SCFGR |= SPI_I2SCFGR_I2SE;
    951            }
    952            else
    953            {
    954              /* Disable the selected SPI peripheral in I2S mode */
    955              SPIx->I2SCFGR &= (uint16_t)~((uint16_t)SPI_I2SCFGR_I2SE);
    956            }
    957          }
    958          
    959          /**
    960            * @brief  Deinitialize the SPIx peripheral registers to their default reset values.
    961            * @param  SPIx: To select the SPIx/I2Sx peripheral, where x can be: 1, 2 or 3 
    962            *         in SPI mode or 2 or 3 in I2S mode.   
    963            *         
    964            * @note   The extended I2S blocks (ie. I2S2ext and I2S3ext blocks) are deinitialized
    965            *         when the relative I2S peripheral is deinitialized (the extended block's clock
    966            *         is managed by the I2S peripheral clock).
    967            *             
    968            * @retval None
    969            */
    970          static void SPI_I2S_DeInit(SPI_TypeDef* SPIx)
    971          {
    972          
    973            if (SPIx == SPI1)
    974            {
    975              /* Enable SPI1 reset state */
    976              //RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI1, ENABLE);
    977              __HAL_RCC_SPI1_CLK_ENABLE();
    978              /* Release SPI1 from reset state */
    979              //RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI1, DISABLE);
    980              __HAL_RCC_SPI1_CLK_DISABLE();
    981            }
    982            else if (SPIx == SPI2)
    983            {
    984              /* Enable SPI2 reset state */
    985              //RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI2, ENABLE);
    986              __HAL_RCC_SPI2_CLK_ENABLE();
    987              /* Release SPI2 from reset state */
    988              //RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI2, DISABLE);
    989              __HAL_RCC_SPI2_CLK_DISABLE();
    990            }
    991            else
    992            {
    993              if (SPIx == SPI3)
    994              {
    995                /* Enable SPI3 reset state */
    996                //RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI3, ENABLE);
    997                __HAL_RCC_SPI3_CLK_ENABLE();
    998                /* Release SPI3 from reset state */
    999                //RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI3, DISABLE);
   1000                __HAL_RCC_SPI3_CLK_DISABLE();
   1001              }
   1002            }
   1003          }
   1004          
   1005          /**
   1006            * @brief  Enables or disables the specified DMAy Streamx.
   1007            * @param  DMAy_Streamx: where y can be 1 or 2 to select the DMA and x can be 0
   1008            *         to 7 to select the DMA Stream.
   1009            * @param  NewState: new state of the DMAy Streamx. 
   1010            *          This parameter can be: ENABLE or DISABLE.
   1011            *
   1012            * @note  This function may be used to perform Pause-Resume operation. When a
   1013            *        transfer is ongoing, calling this function to disable the Stream will
   1014            *        cause the transfer to be paused. All configuration registers and the
   1015            *        number of remaining data will be preserved. When calling again this
   1016            *        function to re-enable the Stream, the transfer will be resumed from
   1017            *        the point where it was paused.          
   1018            *    
   1019            * @note  After configuring the DMA Stream (DMA_Init() function) and enabling the
   1020            *        stream, it is recommended to check (or wait until) the DMA Stream is
   1021            *        effectively enabled. A Stream may remain disabled if a configuration 
   1022            *        parameter is wrong.
   1023            *        After disabling a DMA Stream, it is also recommended to check (or wait
   1024            *        until) the DMA Stream is effectively disabled. If a Stream is disabled 
   1025            *        while a data transfer is ongoing, the current data will be transferred
   1026            *        and the Stream will be effectively disabled only after the transfer of
   1027            *        this single data is finished.            
   1028            *    
   1029            * @retval None
   1030            */

   \                                 In section .text, align 2, keep-with-next
   1031          static void DMA_Cmd(DMA_Stream_TypeDef* DMAy_Streamx, FunctionalState NewState)
   1032          {
   1033          
   1034          
   1035            if (NewState != DISABLE)
   \                     DMA_Cmd: (+1)
   \   00000000   0x2900             CMP      R1,#+0
   \   00000002   0x6801             LDR      R1,[R0, #+0]
   \   00000004   0xBF12             ITEE     NE 
   \   00000006   0xF041 0x0101      ORRNE    R1,R1,#0x1
   \   0000000A   0x0849             LSREQ    R1,R1,#+1
   \   0000000C   0x0049             LSLEQ    R1,R1,#+1
   1036            {
   1037              /* Enable the selected DMAy Streamx by setting EN bit */
   1038              DMAy_Streamx->CR |= (uint32_t)DMA_SxCR_EN;
   1039            }
   1040            else
   1041            {
   1042              /* Disable the selected DMAy Streamx by clearing EN bit */
   1043              DMAy_Streamx->CR &= ~(uint32_t)DMA_SxCR_EN;
   \   0000000E   0x6001             STR      R1,[R0, #+0]
   1044            }
   1045          }
   \   00000010   0x4770             BX       LR               ;; return
   1046          
   1047          
   1048          /**
   1049            * @brief  Enables or disables the SPIx/I2Sx DMA interface.
   1050            * @param  SPIx: To select the SPIx/I2Sx peripheral, where x can be: 1, 2 or 3 
   1051            *         in SPI mode or 2 or 3 in I2S mode or I2Sxext for I2S full duplex mode. 
   1052            * @param  SPI_I2S_DMAReq: specifies the SPI DMA transfer request to be enabled or disabled. 
   1053            *          This parameter can be any combination of the following values:
   1054            *            @arg SPI_I2S_DMAReq_Tx: Tx buffer DMA transfer request
   1055            *            @arg SPI_I2S_DMAReq_Rx: Rx buffer DMA transfer request
   1056            * @param  NewState: new state of the selected SPI DMA transfer request.
   1057            *          This parameter can be: ENABLE or DISABLE.
   1058            * @retval None
   1059            */

   \                                 In section .text, align 2, keep-with-next
   1060          static void SPI_I2S_DMACmd(SPI_TypeDef* SPIx, uint16_t SPI_I2S_DMAReq, FunctionalState NewState)
   1061          {
   1062            /* Check the parameters */
   1063            assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
   1064            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1065            assert_param(IS_SPI_I2S_DMAREQ(SPI_I2S_DMAReq));
   1066          
   1067            if (NewState != DISABLE)
   \                     SPI_I2S_DMACmd: (+1)
   \   00000000   0x2A00             CMP      R2,#+0
   \   00000002   0x6842             LDR      R2,[R0, #+4]
   \   00000004   0xBF11             ITEEE    NE 
   \   00000006   0x4311             ORRNE    R1,R1,R2
   \   00000008   0x43C9             MVNEQ    R1,R1
   \   0000000A   0xB289             UXTHEQ   R1,R1
   \   0000000C   0x4011             ANDEQ    R1,R1,R2
   1068            {
   1069              /* Enable the selected SPI DMA requests */
   1070              SPIx->CR2 |= SPI_I2S_DMAReq;
   1071            }
   1072            else
   1073            {
   1074              /* Disable the selected SPI DMA requests */
   1075              SPIx->CR2 &= (uint16_t)~SPI_I2S_DMAReq;
   \   0000000E   0x6041             STR      R1,[R0, #+4]
   1076            }
   1077          }
   \   00000010   0x4770             BX       LR               ;; return
   1078          

   \                                 In section .text, align 2, keep-with-next
   1079          void HAL_I2S_MspInit(I2S_HandleTypeDef *hi2s)
   1080          {
   \                     HAL_I2S_MspInit: (+1)
   \   00000000   0xE92D 0x43F0      PUSH     {R4-R9,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0xB08B             SUB      SP,SP,#+44
   1081             GPIO_InitTypeDef GPIO_InitStructure;
   1082          	
   1083             
   1084             GPIO_InitTypeDef GPIO_InitStruct;
   1085            if(hi2s->Instance==SPI1)
   \   00000008   0x....             LDR.N    R1,??DataTable16_13  ;; 0x40013000
   \   0000000A   0x....             LDR.N    R5,??DataTable16_5  ;; 0x40020800
   \   0000000C   0x6820             LDR      R0,[R4, #+0]
   \   0000000E   0x.... 0x....      LDR.W    R9,??DataTable16_4  ;; 0x40020000
   \   00000012   0x....             LDR.N    R7,??DataTable16_1  ;; 0x40023830
   \   00000014   0x4288             CMP      R0,R1
   \   00000016   0xD11F             BNE.N    ??HAL_I2S_MspInit_0
   1086            {
   1087            /* USER CODE BEGIN SPI1_MspInit 0 */
   1088          
   1089            /* USER CODE END SPI1_MspInit 0 */
   1090            /* Peripheral clock enable */
   1091            __SPI1_CLK_ENABLE();
   \   00000018   0x6978             LDR      R0,[R7, #+20]
   1092            __GPIOA_CLK_ENABLE();
   1093            __GPIOC_CLK_ENABLE();
   1094          
   1095            /**I2S1 GPIO Configuration    
   1096              PA4     ------> I2S1_WS --> LRCKO
   1097              PA5     ------> I2S1_CK --> BICKO
   1098              PA7     ------> I2S1_SD --> SDO12
   1099              PC4     ------> I2S1_MCK
   1100              */
   1101          	GPIO_InitStruct.Pin =  GPIO_PIN_5|GPIO_PIN_7;
   1102          	GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
   1103          	GPIO_InitStruct.Pull = GPIO_NOPULL;
   1104          	GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
   1105          	GPIO_InitStruct.Alternate = GPIO_AF5_SPI1;
   1106          	HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
   \   0000001A   0xA901             ADD      R1,SP,#+4
   \   0000001C   0xF440 0x5080      ORR      R0,R0,#0x1000
   \   00000020   0x6178             STR      R0,[R7, #+20]
   \   00000022   0x6978             LDR      R0,[R7, #+20]
   \   00000024   0xF400 0x5080      AND      R0,R0,#0x1000
   \   00000028   0x.... 0x....      BL       ?Subroutine2
   \                     ??CrossCallReturnLabel_2: (+1)
   \   0000002C   0x.... 0x....      BL       ??Subroutine7_0
   \                     ??CrossCallReturnLabel_17: (+1)
   \   00000030   0x20A0             MOVS     R0,#+160
   \   00000032   0x9001             STR      R0,[SP, #+4]
   \   00000034   0x.... 0x....      BL       ?Subroutine3
   \                     ??CrossCallReturnLabel_5: (+1)
   \   00000038   0x4648             MOV      R0,R9
   \   0000003A   0x.... 0x....      BL       HAL_GPIO_Init
   1107          
   1108              GPIO_InitStruct.Pin = GPIO_PIN_4;
   \   0000003E   0x2010             MOVS     R0,#+16
   1109              GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
   1110              GPIO_InitStruct.Pull = GPIO_NOPULL;
   1111              GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
   1112              GPIO_InitStruct.Alternate = GPIO_AF5_SPI1;
   1113          	
   1114              HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
   \   00000040   0xA901             ADD      R1,SP,#+4
   \   00000042   0x9001             STR      R0,[SP, #+4]
   \   00000044   0x2002             MOVS     R0,#+2
   \   00000046   0x.... 0x....      BL       ?Subroutine1
   1115            /* Peripheral interrupt init*/
   1116              HAL_NVIC_SetPriority(SPI1_IRQn, 4, 0);
   \                     ??CrossCallReturnLabel_1: (+1)
   \   0000004A   0x2200             MOVS     R2,#+0
   \   0000004C   0x2104             MOVS     R1,#+4
   \   0000004E   0x2023             MOVS     R0,#+35
   \   00000050   0x.... 0x....      BL       HAL_NVIC_SetPriority
   1117              HAL_NVIC_EnableIRQ(SPI1_IRQn);
   \   00000054   0x2023             MOVS     R0,#+35
   \   00000056   0xE08F             B.N      ??HAL_I2S_MspInit_1
   1118            /* USER CODE BEGIN SPI1_MspInit 1 */
   1119          
   1120            /* USER CODE END SPI1_MspInit 1 */
   1121            }
   1122            else if(hi2s->Instance==SPI2)
   \                     ??HAL_I2S_MspInit_0: (+1)
   \   00000058   0x....             LDR.N    R1,??DataTable16_14  ;; 0x40003800
   \   0000005A   0x.... 0x....      LDR.W    R8,??DataTable16_3  ;; 0x40020400
   \   0000005E   0x4288             CMP      R0,R1
   \   00000060   0xF44F 0x5600      MOV      R6,#+8192
   \   00000064   0xD124             BNE.N    ??HAL_I2S_MspInit_2
   1123            {
   1124            /* USER CODE BEGIN SPI2_MspInit 0 */
   1125          
   1126            /* USER CODE END SPI2_MspInit 0 */
   1127              /* Peripheral clock enable */
   1128              __SPI2_CLK_ENABLE();
   \   00000066   0x6938             LDR      R0,[R7, #+16]
   1129              __GPIOI_CLK_ENABLE();
   1130          	__GPIOB_CLK_ENABLE();
   1131          	__GPIOC_CLK_ENABLE();
   1132            
   1133              /**I2S2 GPIO Configuration     
   1134              PC1     ------> I2S2_SD  : PI3 PC1 PC3 PB15     
   1135              PB13     ------> I2S2_CK :PD3 PB10 PB13 PA9 PI1 
   1136              PB12     ------> I2S2_WS : PB12 PI0 PB4 PB9  
   1137          
   1138          
   1139              */
   1140              GPIO_InitStruct.Pin = GPIO_PIN_1; //SD
   1141              GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
   1142              GPIO_InitStruct.Pull = GPIO_NOPULL;
   1143              GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
   1144              GPIO_InitStruct.Alternate = GPIO_AF5_SPI2;
   1145              HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
   \   00000068   0xA901             ADD      R1,SP,#+4
   \   0000006A   0xF440 0x4080      ORR      R0,R0,#0x4000
   \   0000006E   0x6138             STR      R0,[R7, #+16]
   \   00000070   0x6938             LDR      R0,[R7, #+16]
   \   00000072   0xF400 0x4080      AND      R0,R0,#0x4000
   \   00000076   0x9000             STR      R0,[SP, #+0]
   \   00000078   0x9800             LDR      R0,[SP, #+0]
   \   0000007A   0x6838             LDR      R0,[R7, #+0]
   \   0000007C   0xF440 0x7080      ORR      R0,R0,#0x100
   \   00000080   0x6038             STR      R0,[R7, #+0]
   \   00000082   0x6838             LDR      R0,[R7, #+0]
   \   00000084   0xF400 0x7080      AND      R0,R0,#0x100
   \   00000088   0x.... 0x....      BL       ?Subroutine0
   \                     ??CrossCallReturnLabel_18: (+1)
   \   0000008C   0x2002             MOVS     R0,#+2
   \   0000008E   0x9001             STR      R0,[SP, #+4]
   \   00000090   0x.... 0x....      BL       ?Subroutine1
   1146          
   1147          	GPIO_InitStruct.Pin = GPIO_PIN_13;//WS --> GPIO_PIN_12
   \                     ??CrossCallReturnLabel_0: (+1)
   \   00000094   0x9601             STR      R6,[SP, #+4]
   1148              GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
   \   00000096   0x.... 0x....      BL       ?Subroutine3
   1149              GPIO_InitStruct.Pull = GPIO_NOPULL;
   1150              GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
   1151              GPIO_InitStruct.Alternate = GPIO_AF5_SPI2;
   1152              HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
   \                     ??CrossCallReturnLabel_4: (+1)
   \   0000009A   0xA901             ADD      R1,SP,#+4
   \   0000009C   0x4640             MOV      R0,R8
   \   0000009E   0x.... 0x....      BL       HAL_GPIO_Init
   1153          
   1154          
   1155              /* Peripheral interrupt init*/
   1156              HAL_NVIC_SetPriority(SPI2_IRQn, 4, 1);
   \   000000A2   0x2201             MOVS     R2,#+1
   \   000000A4   0x2104             MOVS     R1,#+4
   \   000000A6   0x2024             MOVS     R0,#+36
   \   000000A8   0x.... 0x....      BL       HAL_NVIC_SetPriority
   1157              HAL_NVIC_EnableIRQ(SPI2_IRQn);
   \   000000AC   0x2024             MOVS     R0,#+36
   \   000000AE   0xE063             B.N      ??HAL_I2S_MspInit_1
   1158              /* USER CODE BEGIN SPI2_MspInit 1 */
   1159          
   1160            /* USER CODE END SPI2_MspInit 1 */
   1161            }
   1162            else if(hi2s->Instance==SPI3)
   \                     ??HAL_I2S_MspInit_2: (+1)
   \   000000B0   0x....             LDR.N    R1,??DataTable16_12  ;; 0x40003c00
   \   000000B2   0x4288             CMP      R0,R1
   \   000000B4   0xD162             BNE.N    ??HAL_I2S_MspInit_3
   1163            {
   1164          
   1165          
   1166            
   1167              /**I2S3 GPIO Configuration    
   1168                 PB2     ------> I2S3_SD
   1169                 PA15     ------> I2S3_WS (LRCK)
   1170                 PB3     ------> I2S3_CK 
   1171          	 PC7    ------> MCLK
   1172              */
   1173           
   1174            /* USER CODE BEGIN SPI3_MspInit 1 */
   1175            __SPI3_CLK_ENABLE();
   \   000000B6   0x6938             LDR      R0,[R7, #+16]
   1176            __GPIOA_CLK_ENABLE();
   1177            __GPIOB_CLK_ENABLE();
   1178            __GPIOC_CLK_ENABLE();
   1179            GPIO_InitStructure.Pin = GPIO_PIN_3 | GPIO_PIN_2; 
   1180            GPIO_InitStructure.Mode = GPIO_MODE_AF_PP;
   1181            GPIO_InitStructure.Speed = GPIO_SPEED_HIGH;
   1182            GPIO_InitStructure.Pull = GPIO_NOPULL;
   1183            GPIO_InitStructure.Alternate = GPIO_AF6_SPI3;
   1184            HAL_GPIO_Init(GPIOB, &GPIO_InitStructure);
   \   000000B8   0xA906             ADD      R1,SP,#+24
   \   000000BA   0xF440 0x4000      ORR      R0,R0,#0x8000
   \   000000BE   0x6138             STR      R0,[R7, #+16]
   \   000000C0   0x6938             LDR      R0,[R7, #+16]
   \   000000C2   0xF400 0x4000      AND      R0,R0,#0x8000
   \   000000C6   0x.... 0x....      BL       ?Subroutine2
   \                     ??CrossCallReturnLabel_3: (+1)
   \   000000CA   0x.... 0x....      BL       ?Subroutine0
   \                     ??CrossCallReturnLabel_19: (+1)
   \   000000CE   0x200C             MOVS     R0,#+12
   \   000000D0   0x.... 0x....      BL       ?Subroutine5
   \                     ??CrossCallReturnLabel_9: (+1)
   \   000000D4   0x4640             MOV      R0,R8
   \   000000D6   0x.... 0x....      BL       HAL_GPIO_Init
   1185          
   1186          
   1187            GPIO_InitStructure.Pin = GPIO_PIN_15;
   \   000000DA   0xF44F 0x4000      MOV      R0,#+32768
   1188            GPIO_InitStructure.Mode = GPIO_MODE_AF_PP;
   1189            GPIO_InitStructure.Alternate = GPIO_AF6_SPI3;
   1190            HAL_GPIO_Init(GPIOA, &GPIO_InitStructure);
   \   000000DE   0xA906             ADD      R1,SP,#+24
   \   000000E0   0x9006             STR      R0,[SP, #+24]
   \   000000E2   0x2002             MOVS     R0,#+2
   \   000000E4   0x9007             STR      R0,[SP, #+28]
   \   000000E6   0x2006             MOVS     R0,#+6
   \   000000E8   0x900A             STR      R0,[SP, #+40]
   \   000000EA   0x4648             MOV      R0,R9
   \   000000EC   0x.... 0x....      BL       HAL_GPIO_Init
   1191          
   1192          #ifdef CODEC_MCLK_ENABLED
   1193          
   1194            GPIO_InitStructure.Pin = GPIO_PIN_7; 
   \   000000F0   0x2080             MOVS     R0,#+128
   1195            GPIO_InitStructure.Mode = GPIO_MODE_AF_PP;
   1196            GPIO_InitStructure.Speed = GPIO_SPEED_HIGH;
   1197            GPIO_InitStructure.Pull = GPIO_NOPULL;
   1198            GPIO_InitStructure.Alternate = GPIO_AF6_SPI3;
   1199            HAL_GPIO_Init(GPIOC, &GPIO_InitStructure);
   \   000000F2   0xA906             ADD      R1,SP,#+24
   \   000000F4   0x.... 0x....      BL       ?Subroutine5
   \                     ??CrossCallReturnLabel_10: (+1)
   \   000000F8   0x4628             MOV      R0,R5
   \   000000FA   0x.... 0x....      BL       HAL_GPIO_Init
   1200          
   1201          #endif /* CODEC_MCLK_ENABLED */ 
   1202          
   1203          #ifdef I2S_INTERRUPT   
   1204               /* Enable and set Button EXTI Interrupt to the lowest priority */
   1205               //HAL_NVIC_SetPriority((IRQn_Type)SPI3_IRQn, 0x00, 0x01);
   1206               //HAL_NVIC_EnableIRQ((IRQn_Type)SPI3_IRQn);
   1207          
   1208               /* Enable the I2S DMA request */
   1209               //__HAL_I2S_ENABLE_IT(&hi2s3, SPI_I2S_DMAReq_Tx);
   1210               //__HAL_I2S_ENABLE(&hi2s3);
   1211            	    /* Peripheral interrupt init*/
   1212          		HAL_NVIC_SetPriority(SPI3_IRQn, 3, 0);
   1213          		HAL_NVIC_EnableIRQ(SPI3_IRQn);
   1214          #endif
   1215          
   1216                /* Enable the DMA clock */ 
   1217          	  __HAL_RCC_DMA1_CLK_ENABLE();
   \   000000FE   0x6838             LDR      R0,[R7, #+0]
   1218          
   1219                /* Configure the DMA Stream */
   1220                HAL_DMA_DeInit(&DmaHandle);
   \   00000100   0x....             LDR.N    R5,??DataTable16_15
   \   00000102   0xF440 0x1000      ORR      R0,R0,#0x200000
   \   00000106   0x6038             STR      R0,[R7, #+0]
   \   00000108   0x6838             LDR      R0,[R7, #+0]
   \   0000010A   0xF400 0x1000      AND      R0,R0,#0x200000
   \   0000010E   0x9000             STR      R0,[SP, #+0]
   \   00000110   0x9800             LDR      R0,[SP, #+0]
   \   00000112   0x4628             MOV      R0,R5
   \   00000114   0x.... 0x....      BL       HAL_DMA_DeInit
   1221          
   1222                /* Set the parameters to be configured */ 
   1223          	  DmaHandle.Instance = DMA1_Stream7;
   \   00000118   0x....             LDR.N    R0,??DataTable16_11  ;; 0x400260b8
   1224                DmaHandle.Init.Channel = DMA_CHANNEL_0;
   1225          	  DmaHandle.Init.Direction = DMA_MEMORY_TO_PERIPH;
   1226          	  DmaHandle.Init.PeriphInc = DMA_PINC_DISABLE;
   1227          	  DmaHandle.Init.MemInc = DMA_MINC_ENABLE;
   1228          	  DmaHandle.Init.PeriphDataAlignment = DMA_PDATAALIGN_HALFWORD;
   1229                DmaHandle.Init.MemDataAlignment = DMA_MDATAALIGN_HALFWORD; 
   1230          	  DmaHandle.Init.Mode = DMA_NORMAL;
   1231                DmaHandle.Init.Priority = DMA_PRIORITY_HIGH; 
   1232          	  DmaHandle.Init.FIFOMode = DMA_FIFOMODE_ENABLE;//DMA_FIFOMODE_DISABLE
   1233                DmaHandle.Init.FIFOThreshold = DMA_FIFO_THRESHOLD_1QUARTERFULL;
   1234                DmaHandle.Init.MemBurst = DMA_MBURST_SINGLE;
   1235                DmaHandle.Init.PeriphBurst = DMA_PBURST_SINGLE;	  
   1236                DmaHandle.Instance->PAR = CODEC_I2S_ADDRESS;
   \   0000011A   0x....             LDR.N    R1,??DataTable16_16  ;; 0x40003c0c
   \   0000011C   0x6028             STR      R0,[R5, #+0]
   \   0000011E   0x2000             MOVS     R0,#+0
   \   00000120   0x6068             STR      R0,[R5, #+4]
   \   00000122   0x2040             MOVS     R0,#+64
   \   00000124   0x60A8             STR      R0,[R5, #+8]
   \   00000126   0x2000             MOVS     R0,#+0
   \   00000128   0x60E8             STR      R0,[R5, #+12]
   \   0000012A   0xF44F 0x6080      MOV      R0,#+1024
   \   0000012E   0x6128             STR      R0,[R5, #+16]
   \   00000130   0xF44F 0x6000      MOV      R0,#+2048
   \   00000134   0x6168             STR      R0,[R5, #+20]
   \   00000136   0x2000             MOVS     R0,#+0
   \   00000138   0x61AE             STR      R6,[R5, #+24]
   \   0000013A   0x61E8             STR      R0,[R5, #+28]
   \   0000013C   0xF44F 0x3000      MOV      R0,#+131072
   \   00000140   0x6228             STR      R0,[R5, #+32]
   \   00000142   0x2004             MOVS     R0,#+4
   \   00000144   0x6268             STR      R0,[R5, #+36]
   \   00000146   0x2000             MOVS     R0,#+0
   \   00000148   0x62A8             STR      R0,[R5, #+40]
   \   0000014A   0x62E8             STR      R0,[R5, #+44]
   \   0000014C   0x6328             STR      R0,[R5, #+48]
   \   0000014E   0x6828             LDR      R0,[R5, #+0]
   \   00000150   0x6081             STR      R1,[R0, #+8]
   1237                DmaHandle.Instance->M0AR = (uint32_t)0;
   \   00000152   0x2100             MOVS     R1,#+0
   \   00000154   0x60C1             STR      R1,[R0, #+12]
   1238                DmaHandle.Instance->NDTR = (uint32_t)0xFFFE;
   \   00000156   0xF64F 0x71FE      MOVW     R1,#+65534
   \   0000015A   0x6041             STR      R1,[R0, #+4]
   1239                //DmaHandle.XferCpltCallback = &TC_Callback;
   1240           
   1241          
   1242                /* Associate the initialized DMA handle to the the SPI handle */
   1243                __HAL_LINKDMA(hi2s, hdmatx, DmaHandle);
   1244                //__HAL_DMA_ENABLE_IT(&DmaHandle, DMA_IT_TC);
   1245          
   1246          	   /* Deinitialize the Stream for new transfer */
   1247                 HAL_DMA_DeInit(&DmaHandle);
   \   0000015C   0x4628             MOV      R0,R5
   \   0000015E   0x6325             STR      R5,[R4, #+48]
   \   00000160   0x63AC             STR      R4,[R5, #+56]
   \   00000162   0x.... 0x....      BL       HAL_DMA_DeInit
   1248                 /* Configure the DMA Stream */
   1249          	   HAL_DMA_Init(&DmaHandle);
   \   00000166   0x4628             MOV      R0,R5
   \   00000168   0x.... 0x....      BL       HAL_DMA_Init
   1250          
   1251                /* Set Interrupt Group Priority */
   1252                HAL_NVIC_SetPriority(DMA1_Stream7_IRQn, 2, 1);
   \   0000016C   0x2201             MOVS     R2,#+1
   \   0000016E   0x2102             MOVS     R1,#+2
   \   00000170   0x202F             MOVS     R0,#+47
   \   00000172   0x.... 0x....      BL       HAL_NVIC_SetPriority
   1253                /* Enable the DMA STREAM global Interrupt */
   1254                HAL_NVIC_EnableIRQ(DMA1_Stream7_IRQn);    
   \   00000176   0x202F             MOVS     R0,#+47
   \                     ??HAL_I2S_MspInit_1: (+1)
   \   00000178   0x.... 0x....      BL       HAL_NVIC_EnableIRQ
   1255          	  
   1256           }
   1257          
   1258          }
   \                     ??HAL_I2S_MspInit_3: (+1)
   \   0000017C   0xB00B             ADD      SP,SP,#+44
   \   0000017E   0xE8BD 0x83F0      POP      {R4-R9,PC}       ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine5: (+1)
   \   00000000   0x9006             STR      R0,[SP, #+24]
   \   00000002   0x2002             MOVS     R0,#+2
   \   00000004   0x9007             STR      R0,[SP, #+28]
   \   00000006   0x2003             MOVS     R0,#+3
   \   00000008   0x9009             STR      R0,[SP, #+36]
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x9008             STR      R0,[SP, #+32]
   \   0000000E   0x2006             MOVS     R0,#+6
   \   00000010   0x900A             STR      R0,[SP, #+40]
   \   00000012   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine3: (+1)
   \   00000000   0x2002             MOVS     R0,#+2
   \   00000002   0x9002             STR      R0,[SP, #+8]
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x9003             STR      R0,[SP, #+12]
   \   00000008   0x2003             MOVS     R0,#+3
   \   0000000A   0x9004             STR      R0,[SP, #+16]
   \   0000000C   0x2005             MOVS     R0,#+5
   \   0000000E   0x9005             STR      R0,[SP, #+20]
   \   00000010   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine2: (+1)
   \   00000000   0x9000             STR      R0,[SP, #+0]
   \   00000002   0x9800             LDR      R0,[SP, #+0]
   \   00000004   0x6838             LDR      R0,[R7, #+0]
   \   00000006   0xF040 0x0001      ORR      R0,R0,#0x1
   \   0000000A   0x6038             STR      R0,[R7, #+0]
   \   0000000C   0x6838             LDR      R0,[R7, #+0]
   \   0000000E   0xF000 0x0001      AND      R0,R0,#0x1
   \   00000012   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \   00000000   0x9002             STR      R0,[SP, #+8]
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0x9003             STR      R0,[SP, #+12]
   \   00000006   0x2003             MOVS     R0,#+3
   \   00000008   0x9004             STR      R0,[SP, #+16]
   \   0000000A   0x2005             MOVS     R0,#+5
   \   0000000C   0x9005             STR      R0,[SP, #+20]
   \   0000000E   0x4628             MOV      R0,R5
   \   00000010   0x.... 0x....      B.W      HAL_GPIO_Init

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \   00000000   0x9000             STR      R0,[SP, #+0]
   \   00000002   0x9800             LDR      R0,[SP, #+0]
   \   00000004   0x6838             LDR      R0,[R7, #+0]
   \   00000006   0xF040 0x0002      ORR      R0,R0,#0x2
   \   0000000A   0x6038             STR      R0,[R7, #+0]
   \   0000000C   0x6838             LDR      R0,[R7, #+0]
   \   0000000E   0xF000 0x0002      AND      R0,R0,#0x2
   \   00000012                      REQUIRE ??Subroutine7_0
   \   00000012                      ;; // Fall through to label ??Subroutine7_0

   \                                 In section .text, align 2, keep-with-next
   \                     ??Subroutine7_0: (+1)
   \   00000000   0x9000             STR      R0,[SP, #+0]
   \   00000002   0x9800             LDR      R0,[SP, #+0]
   \   00000004   0x6838             LDR      R0,[R7, #+0]
   \   00000006   0xF040 0x0004      ORR      R0,R0,#0x4
   \   0000000A   0x6038             STR      R0,[R7, #+0]
   \   0000000C   0x6838             LDR      R0,[R7, #+0]
   \   0000000E   0xF000 0x0004      AND      R0,R0,#0x4
   \   00000012   0x9000             STR      R0,[SP, #+0]
   \   00000014   0x9800             LDR      R0,[SP, #+0]
   \   00000016   0x4770             BX       LR
   1259          

   \                                 In section .text, align 2, keep-with-next
   1260          void HAL_SPI_MspDeInit(SPI_HandleTypeDef *hspi)
   1261          {
   \                     HAL_SPI_MspDeInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   1262            if(hspi->Instance == SPI3)
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x....             LDR.N    R1,??DataTable16_12  ;; 0x40003c00
   \   00000006   0x4288             CMP      R0,R1
   \   00000008   0xD120             BNE.N    ??HAL_SPI_MspDeInit_0
   1263            {   
   1264              /*##-1- Reset peripherals ##################################################*/
   1265              __HAL_RCC_SPI3_FORCE_RESET();
   \   0000000A   0x....             LDR.N    R0,??DataTable16_17  ;; 0x40023820
   1266              __HAL_RCC_SPI3_RELEASE_RESET();
   1267          
   1268              /*##-2- Disable peripherals and GPIO Clocks ################################*/
   1269              HAL_GPIO_DeInit(CODEC_I2S_GPIO, CODEC_I2S_SCK_PIN);
   \   0000000C   0x....             LDR.N    R4,??DataTable16_3  ;; 0x40020400
   \   0000000E   0x6801             LDR      R1,[R0, #+0]
   \   00000010   0xF441 0x4100      ORR      R1,R1,#0x8000
   \   00000014   0x6001             STR      R1,[R0, #+0]
   \   00000016   0x.... 0x....      BL       ?Subroutine4
   \                     ??CrossCallReturnLabel_8: (+1)
   \   0000001A   0x2108             MOVS     R1,#+8
   \   0000001C   0x4620             MOV      R0,R4
   \   0000001E   0x.... 0x....      BL       HAL_GPIO_DeInit
   1270              HAL_GPIO_DeInit(CODEC_I2S_GPIO, CODEC_I2S_SD_PIN);
   \   00000022   0x2104             MOVS     R1,#+4
   \   00000024   0x4620             MOV      R0,R4
   \   00000026   0x.... 0x....      BL       HAL_GPIO_DeInit
   1271              HAL_GPIO_DeInit(CODEC_I2S_WS_GPIO, CODEC_I2S_WS_PIN);
   \   0000002A   0xF44F 0x4100      MOV      R1,#+32768
   \   0000002E   0x....             LDR.N    R0,??DataTable16_4  ;; 0x40020000
   \   00000030   0x.... 0x....      BL       HAL_GPIO_DeInit
   1272          	HAL_GPIO_DeInit(CODEC_I2S_MCK_GPIO, CODEC_I2S_MCK_PIN);
   \   00000034   0x2180             MOVS     R1,#+128
   \   00000036   0x....             LDR.N    R0,??DataTable16_5  ;; 0x40020800
   \   00000038   0x.... 0x....      BL       HAL_GPIO_DeInit
   1273          
   1274              /*##-3- Disable the DMA ####################################################*/
   1275              /* De-Initialize the DMA associated to transmission process */
   1276              HAL_DMA_DeInit(&DmaHandle);
   \   0000003C   0x....             LDR.N    R0,??DataTable16_15
   \   0000003E   0x.... 0x....      BL       HAL_DMA_DeInit
   1277          
   1278          
   1279              /*##-4- Disable the NVIC for DMA ###########################################*/
   1280              HAL_NVIC_DisableIRQ(DMA1_Stream7_IRQn);
   \   00000042   0x202F             MOVS     R0,#+47
   \   00000044   0xE8BD 0x4010      POP      {R4,LR}
   \   00000048   0x.... 0x....      B.W      HAL_NVIC_DisableIRQ
   1281            }
   1282          }
   \                     ??HAL_SPI_MspDeInit_0: (+1)
   \   0000004C   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine4: (+1)
   \   00000000   0x6801             LDR      R1,[R0, #+0]
   \   00000002   0xF421 0x4100      BIC      R1,R1,#0x8000
   \   00000006   0x6001             STR      R1,[R0, #+0]
   \   00000008   0x4770             BX       LR
   1283          
   1284          

   \                                 In section .text, align 2, keep-with-next
   1285          void HAL_I2C_MspDeInit(I2C_HandleTypeDef *hi2c)
   1286          {
   1287              /*##-1- Reset peripherals ##################################################*/
   1288              __HAL_RCC_I2C1_FORCE_RESET();
   \                     HAL_I2C_MspDeInit: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable16_17  ;; 0x40023820
   \   00000002   0xB510             PUSH     {R4,LR}
   \   00000004   0x6801             LDR      R1,[R0, #+0]
   1289              __HAL_RCC_I2C1_RELEASE_RESET();
   1290          
   1291          
   1292            /*##-2- Disable peripherals and GPIO Clocks #################################*/
   1293            /* Configure I2C Tx as alternate function  */
   1294            HAL_GPIO_DeInit(CODEC_I2C_GPIO, CODEC_I2C_SCL_PIN);
   \   00000006   0x....             LDR.N    R4,??DataTable16_3  ;; 0x40020400
   \   00000008   0xF441 0x1100      ORR      R1,R1,#0x200000
   \   0000000C   0x6001             STR      R1,[R0, #+0]
   \   0000000E   0x6801             LDR      R1,[R0, #+0]
   \   00000010   0xF421 0x1100      BIC      R1,R1,#0x200000
   \   00000014   0x6001             STR      R1,[R0, #+0]
   \   00000016   0x2140             MOVS     R1,#+64
   \   00000018   0x4620             MOV      R0,R4
   \   0000001A   0x.... 0x....      BL       HAL_GPIO_DeInit
   1295            /* Configure I2C Rx as alternate function  */
   1296            HAL_GPIO_DeInit(CODEC_I2C_GPIO, CODEC_I2C_SDA_PIN);
   \   0000001E   0x4620             MOV      R0,R4
   \   00000020   0x2180             MOVS     R1,#+128
   \   00000022   0xE8BD 0x4010      POP      {R4,LR}
   \   00000026   0x.... 0x....      B.W      HAL_GPIO_DeInit
   1297          }
   1298          
   1299          
   1300          
   1301           /* I2C1 init function */

   \                                 In section .text, align 2, keep-with-next
   1302          void MX_I2C1_Init(void)
   1303          {
   \                     MX_I2C1_Init: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   1304          
   1305          
   1306            hi2c1.Instance = I2C1;
   \   00000002   0x....             LDR.N    R4,??DataTable16_6
   \   00000004   0x....             LDR.N    R0,??DataTable16_18  ;; 0x40005400
   \   00000006   0x6020             STR      R0,[R4, #+0]
   1307            hi2c1.Init.Timing =0x00C0EFFF;           //I2C_SPEED DISCOVERY_I2Cx_TIMING;
   \   00000008   0x....             LDR.N    R0,??DataTable16_19  ;; 0xc0efff
   \   0000000A   0x6060             STR      R0,[R4, #+4]
   1308                                                     //I2C_TIMING ;//I2C_TIMING  0x00303D5D
   1309                                                     //DISCOVERY_I2Cx_TIMING
   1310            hi2c1.Init.OwnAddress1 = 0x33;
   \   0000000C   0x2033             MOVS     R0,#+51
   \   0000000E   0x60A0             STR      R0,[R4, #+8]
   1311            hi2c1.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0x60E0             STR      R0,[R4, #+12]
   1312            hi2c1.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0x6120             STR      R0,[R4, #+16]
   1313            hi2c1.Init.OwnAddress2 = 0;
   \   00000018   0x6160             STR      R0,[R4, #+20]
   1314            hi2c1.Init.OwnAddress2Masks = I2C_OA2_NOMASK;
   \   0000001A   0x61A0             STR      R0,[R4, #+24]
   1315            hi2c1.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
   \   0000001C   0x61E0             STR      R0,[R4, #+28]
   1316            hi2c1.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
   \   0000001E   0x6220             STR      R0,[R4, #+32]
   1317            HAL_I2C_Init(&hi2c1);
   \   00000020   0x4620             MOV      R0,R4
   \   00000022   0x.... 0x....      BL       HAL_I2C_Init
   1318          
   1319             /*Configure Analogue filter */
   1320            HAL_I2CEx_AnalogFilter_Config(&hi2c1, I2C_ANALOGFILTER_ENABLE);
   \   00000026   0x4620             MOV      R0,R4
   \   00000028   0x2100             MOVS     R1,#+0
   \   0000002A   0xE8BD 0x4010      POP      {R4,LR}
   \   0000002E   0x.... 0x....      B.W      HAL_I2CEx_ConfigAnalogFilter
   1321          
   1322          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine6: (+1)
   \   00000000   0x2101             MOVS     R1,#+1
   \                     ??Subroutine6_0: (+1)
   \   00000002   0x2002             MOVS     R0,#+2
   \   00000004   0x....             B.N      Codec_WriteRegister

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16:
   \   00000000   0x........         DC32     OutputDev

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_1:
   \   00000000   0x40023830         DC32     0x40023830

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_2:
   \   00000000   0x40020C00         DC32     0x40020c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_3:
   \   00000000   0x40020400         DC32     0x40020400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_4:
   \   00000000   0x40020000         DC32     0x40020000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_5:
   \   00000000   0x40020800         DC32     0x40020800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_6:
   \   00000000   0x........         DC32     hi2c1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_7:
   \   00000000   0x........         DC32     hi2s3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_8:
   \   00000000   0x40023840         DC32     0x40023840

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_9:
   \   00000000   0x........         DC32     AudioTotalSize

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_10:
   \   00000000   0x0001FFFE         DC32     0x1fffe

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_11:
   \   00000000   0x400260B8         DC32     0x400260b8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_12:
   \   00000000   0x40003C00         DC32     0x40003c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_13:
   \   00000000   0x40013000         DC32     0x40013000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_14:
   \   00000000   0x40003800         DC32     0x40003800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_15:
   \   00000000   0x........         DC32     DmaHandle

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_16:
   \   00000000   0x40003C0C         DC32     0x40003c0c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_17:
   \   00000000   0x40023820         DC32     0x40023820

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_18:
   \   00000000   0x40005400         DC32     0x40005400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_19:
   \   00000000   0x00C0EFFF         DC32     0xc0efff
   1323          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      32   AUDIO_DeInit
        32   -> Codec_Reset
        32   -> Codec_WriteRegister
        32   -> HAL_GPIO_Init
        32   -> HAL_I2C_MspDeInit
        32   -> HAL_NVIC_DisableIRQ
      40   AUDIO_Init
        40   -> Codec_Reset
        40   -> Codec_VolumeCtrl
        40   -> Codec_WriteRegister
        40   -> HAL_GPIO_Init
        40   -> I2S3_Init
        40   -> MX_I2C1_Init
       0   AUDIO_Mute
         0   -> Codec_Mute
      16   AUDIO_PauseResume
        16   -> Codec_Mute
        16   -> Codec_WriteRegister
        16   -> DMA_Cmd
        16   -> SPI_I2S_DMACmd
      16   AUDIO_Play
        16   -> Audio_MAL_Play
       8   AUDIO_Stop
         8   -> Codec_Mute
         8   -> Codec_WriteRegister
         8   -> Delay
         8   -> HAL_GPIO_WritePin
         8   -> HAL_I2S_DMAStop
       0   AUDIO_VolumeCtl
         0   -> Codec_VolumeCtrl
       0   Audio_MAL_Play
         0   -> HAL_I2S_Transmit_DMA
       0   Codec_Mute
         0   -> Codec_WriteRegister
       8   Codec_Reset
         8   -> Delay
         0   -> HAL_GPIO_WritePin
         8   -> HAL_GPIO_WritePin
      16   Codec_VolumeCtrl
        16   -> Codec_WriteRegister
      24   Codec_WriteRegister
        24   -> Codec_TIMEOUT_UserCallback
        24   -> HAL_I2C_GetError
        24   -> HAL_I2C_Master_Receive
        24   -> HAL_I2C_Master_Transmit
       0   DAC_Config
       0   DMA1_Stream0_IRQHandler
       0   DMA1_Stream7_IRQHandler
         0   -> HAL_DMA_IRQHandler
       0   DMA_Cmd
       4   Delay
       8   HAL_I2C_MspDeInit
         0   -> HAL_GPIO_DeInit
         8   -> HAL_GPIO_DeInit
      72   HAL_I2S_MspInit
        72   -> HAL_DMA_DeInit
        72   -> HAL_DMA_Init
        72   -> HAL_GPIO_Init
        72   -> HAL_NVIC_EnableIRQ
        72   -> HAL_NVIC_SetPriority
       8   HAL_SPI_MspDeInit
         8   -> HAL_DMA_DeInit
         8   -> HAL_GPIO_DeInit
         0   -> HAL_NVIC_DisableIRQ
       8   MX_I2C1_Init
         0   -> HAL_I2CEx_ConfigAnalogFilter
         8   -> HAL_I2C_Init
       0   SPI3_IRQHandler
       0   SPI_I2S_DMACmd


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable16
       4  ??DataTable16_1
       4  ??DataTable16_10
       4  ??DataTable16_11
       4  ??DataTable16_12
       4  ??DataTable16_13
       4  ??DataTable16_14
       4  ??DataTable16_15
       4  ??DataTable16_16
       4  ??DataTable16_17
       4  ??DataTable16_18
       4  ??DataTable16_19
       4  ??DataTable16_2
       4  ??DataTable16_3
       4  ??DataTable16_4
       4  ??DataTable16_5
       4  ??DataTable16_6
       4  ??DataTable16_7
       4  ??DataTable16_8
       4  ??DataTable16_9
      24  ??Subroutine7_0
      18  ?Subroutine0
      20  ?Subroutine1
      20  ?Subroutine2
      18  ?Subroutine3
      10  ?Subroutine4
      20  ?Subroutine5
       6  ?Subroutine6
     140  AUDIO_DeInit
     188  AUDIO_Init
      48  AUDIO_MAL_DMA_InitStructure
       2  AUDIO_Mute
     120  AUDIO_PauseResume
      70  AUDIO_Play
      78  AUDIO_Stop
      26  AUDIO_VolumeCtl
      12  AudioTotalSize
          AudioRemSize
          CurrentPos
      10  Audio_MAL_Play
       4  CODECTimeout
      16  Codec_Mute
      38  Codec_Reset
      40  Codec_VolumeCtrl
     150  Codec_WriteRegister
       4  CurrAudioInterface
       2  DAC_Config
       2  DMA1_Stream0_IRQHandler
      10  DMA1_Stream7_IRQHandler
      18  DMA_Cmd
      48  DMA_InitStructure
      20  Delay
      80  DmaHandle
      42  HAL_I2C_MspDeInit
     386  HAL_I2S_MspInit
      78  HAL_SPI_MspDeInit
      50  MX_I2C1_Init
       2  OutputDev
          Volume
      10  SPI3_IRQHandler
      18  SPI_I2S_DMACmd
      60  hi2c1
      60  hi2c2

 
   296 bytes in section .bss
    22 bytes in section .data
 1 730 bytes in section .text
 
 1 730 bytes of CODE memory
   318 bytes of DATA memory

Errors: none
Warnings: none
