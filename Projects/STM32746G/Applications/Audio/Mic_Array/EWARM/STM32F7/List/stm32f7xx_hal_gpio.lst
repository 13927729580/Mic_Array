###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.2.10312/W32 for ARM       27/Feb/2016  12:00:13
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_gpio.c
#    Command line =  
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_gpio.c
#        -D USE_HAL_DRIVER -D STM32F746xx -D USE_STM32746G_DISCO -D
#        USE_IOEXPANDER -D USE_USB_FS -lC
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
#        -lA
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
#        -o
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M7 -e --fpu=VFPv5_sp --dlib_config "D:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.3\arm\INC\c\DLib_Config_Full.h"
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\Inc\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\CMSIS\Device\ST\STM32F7xx\Include\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\STM32F7xx_HAL_Driver\Inc\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\STM32746G-Discovery\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\Components\Common\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Log\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Fonts\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\CPU\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_Device_Library\Core\Inc\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Core\Inc\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Class\MSC\Inc\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\drivers\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_Audio\Addons\PDM\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_Device_Library\Class\AUDIO\Inc\
#        -On --use_c++_inline --require_prototypes -I "D:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.3\arm\CMSIS\Include\" -D
#        ARM_MATH_CM7
#    List file    =  
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List\stm32f7xx_hal_gpio.lst
#    Object file  =  
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj\stm32f7xx_hal_gpio.o
#
###############################################################################

H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_gpio.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f7xx_hal_gpio.c
      4            * @author  MCD Application Team
      5            * @version V1.0.1
      6            * @date    25-June-2015
      7            * @brief   GPIO HAL module driver.
      8            *          This file provides firmware functions to manage the following 
      9            *          functionalities of the General Purpose Input/Output (GPIO) peripheral:
     10            *           + Initialization and de-initialization functions
     11            *           + IO operation functions
     12            *
     13            @verbatim
     14            ==============================================================================
     15                              ##### GPIO Peripheral features #####
     16            ==============================================================================
     17            [..] 
     18            Subject to the specific hardware characteristics of each I/O port listed in the datasheet, each
     19            port bit of the General Purpose IO (GPIO) Ports, can be individually configured by software
     20            in several modes:
     21            (+) Input mode 
     22            (+) Analog mode
     23            (+) Output mode
     24            (+) Alternate function mode
     25            (+) External interrupt/event lines
     26          
     27            [..]  
     28            During and just after reset, the alternate functions and external interrupt  
     29            lines are not active and the I/O ports are configured in input floating mode.
     30            
     31            [..]   
     32            All GPIO pins have weak internal pull-up and pull-down resistors, which can be 
     33            activated or not.
     34          
     35            [..]
     36            In Output or Alternate mode, each IO can be configured on open-drain or push-pull
     37            type and the IO speed can be selected depending on the VDD value.
     38          
     39            [..]  
     40            All ports have external interrupt/event capability. To use external interrupt 
     41            lines, the port must be configured in input mode. All available GPIO pins are 
     42            connected to the 16 external interrupt/event lines from EXTI0 to EXTI15.
     43            
     44            [..]
     45            The external interrupt/event controller consists of up to 23 edge detectors 
     46            (16 lines are connected to GPIO) for generating event/interrupt requests (each 
     47            input line can be independently configured to select the type (interrupt or event) 
     48            and the corresponding trigger event (rising or falling or both). Each line can 
     49            also be masked independently. 
     50          
     51                               ##### How to use this driver #####
     52            ==============================================================================  
     53            [..]
     54              (#) Enable the GPIO AHB clock using the following function: __HAL_RCC_GPIOx_CLK_ENABLE(). 
     55          
     56              (#) Configure the GPIO pin(s) using HAL_GPIO_Init().
     57                  (++) Configure the IO mode using "Mode" member from GPIO_InitTypeDef structure
     58                  (++) Activate Pull-up, Pull-down resistor using "Pull" member from GPIO_InitTypeDef 
     59                       structure.
     60                  (++) In case of Output or alternate function mode selection: the speed is 
     61                       configured through "Speed" member from GPIO_InitTypeDef structure.
     62                  (++) In alternate mode is selection, the alternate function connected to the IO
     63                       is configured through "Alternate" member from GPIO_InitTypeDef structure.
     64                  (++) Analog mode is required when a pin is to be used as ADC channel 
     65                       or DAC output.
     66                  (++) In case of external interrupt/event selection the "Mode" member from 
     67                       GPIO_InitTypeDef structure select the type (interrupt or event) and 
     68                       the corresponding trigger event (rising or falling or both).
     69          
     70              (#) In case of external interrupt/event mode selection, configure NVIC IRQ priority 
     71                  mapped to the EXTI line using HAL_NVIC_SetPriority() and enable it using
     72                  HAL_NVIC_EnableIRQ().
     73                   
     74              (#) To get the level of a pin configured in input mode use HAL_GPIO_ReadPin().
     75                      
     76              (#) To set/reset the level of a pin configured in output mode use 
     77                  HAL_GPIO_WritePin()/HAL_GPIO_TogglePin().
     78              
     79              (#) To lock pin configuration until next reset use HAL_GPIO_LockPin().
     80          
     81                           
     82              (#) During and just after reset, the alternate functions are not 
     83                  active and the GPIO pins are configured in input floating mode (except JTAG
     84                  pins).
     85            
     86              (#) The LSE oscillator pins OSC32_IN and OSC32_OUT can be used as general purpose 
     87                  (PC14 and PC15, respectively) when the LSE oscillator is off. The LSE has 
     88                  priority over the GPIO function.
     89            
     90              (#) The HSE oscillator pins OSC_IN/OSC_OUT can be used as 
     91                  general purpose PH0 and PH1, respectively, when the HSE oscillator is off. 
     92                  The HSE has priority over the GPIO function.
     93            
     94            @endverbatim
     95            ******************************************************************************
     96            * @attention
     97            *
     98            * <h2><center>&copy; COPYRIGHT(c) 2015 STMicroelectronics</center></h2>
     99            *
    100            * Redistribution and use in source and binary forms, with or without modification,
    101            * are permitted provided that the following conditions are met:
    102            *   1. Redistributions of source code must retain the above copyright notice,
    103            *      this list of conditions and the following disclaimer.
    104            *   2. Redistributions in binary form must reproduce the above copyright notice,
    105            *      this list of conditions and the following disclaimer in the documentation
    106            *      and/or other materials provided with the distribution.
    107            *   3. Neither the name of STMicroelectronics nor the names of its contributors
    108            *      may be used to endorse or promote products derived from this software
    109            *      without specific prior written permission.
    110            *
    111            * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
    112            * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
    113            * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
    114            * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
    115            * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
    116            * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
    117            * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
    118            * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
    119            * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
    120            * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
    121            *
    122            ******************************************************************************
    123            */ 
    124          
    125          /* Includes ------------------------------------------------------------------*/
    126          #include "stm32f7xx_hal.h"
    127          
    128          /** @addtogroup STM32F7xx_HAL_Driver
    129            * @{
    130            */
    131          
    132          /** @defgroup GPIO GPIO
    133            * @brief GPIO HAL module driver
    134            * @{
    135            */
    136          
    137          #ifdef HAL_GPIO_MODULE_ENABLED
    138          
    139          /* Private typedef -----------------------------------------------------------*/
    140          /* Private define ------------------------------------------------------------*/
    141          /** @addtogroup GPIO_Private_Constants GPIO Private Constants
    142            * @{
    143            */
    144          #define GPIO_MODE             ((uint32_t)0x00000003)
    145          #define EXTI_MODE             ((uint32_t)0x10000000)
    146          #define GPIO_MODE_IT          ((uint32_t)0x00010000)
    147          #define GPIO_MODE_EVT         ((uint32_t)0x00020000)
    148          #define RISING_EDGE           ((uint32_t)0x00100000)
    149          #define FALLING_EDGE          ((uint32_t)0x00200000)
    150          #define GPIO_OUTPUT_TYPE      ((uint32_t)0x00000010)
    151          
    152          #define GPIO_NUMBER           ((uint32_t)16)
    153          /**
    154            * @}
    155            */
    156          /* Private macro -------------------------------------------------------------*/
    157          /* Private variables ---------------------------------------------------------*/
    158          /* Private function prototypes -----------------------------------------------*/
    159          /* Private functions ---------------------------------------------------------*/
    160          /* Exported functions --------------------------------------------------------*/
    161          /** @defgroup GPIO_Exported_Functions GPIO Exported Functions
    162            * @{
    163            */
    164          
    165          /** @defgroup GPIO_Exported_Functions_Group1 Initialization and de-initialization functions
    166           *  @brief    Initialization and Configuration functions
    167           *
    168          @verbatim
    169           ===============================================================================
    170                        ##### Initialization and de-initialization functions #####
    171           ===============================================================================
    172            [..]
    173              This section provides functions allowing to initialize and de-initialize the GPIOs
    174              to be ready for use.
    175           
    176          @endverbatim
    177            * @{
    178            */
    179          
    180          /**
    181            * @brief  Initializes the GPIOx peripheral according to the specified parameters in the GPIO_Init.
    182            * @param  GPIOx: where x can be (A..K) to select the GPIO peripheral.
    183            * @param  GPIO_Init: pointer to a GPIO_InitTypeDef structure that contains
    184            *         the configuration information for the specified GPIO peripheral.
    185            * @retval None
    186            */

   \                                 In section .text, align 2, keep-with-next
    187          void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
    188          {
   \                     HAL_GPIO_Init: (+1)
   \   00000000   0xB4F8             PUSH     {R3-R7}
    189            uint32_t position = 0x00;
   \   00000002   0x2200             MOVS     R2,#+0
    190            uint32_t ioposition = 0x00;
   \   00000004   0x2300             MOVS     R3,#+0
    191            uint32_t iocurrent = 0x00;
   \   00000006   0x2400             MOVS     R4,#+0
    192            uint32_t temp = 0x00;
   \   00000008   0x2500             MOVS     R5,#+0
    193          
    194            /* Check the parameters */
    195            assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
    196            assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
    197            assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
    198            assert_param(IS_GPIO_PULL(GPIO_Init->Pull));
    199          
    200            /* Configure the port pins */
    201            for(position = 0; position < GPIO_NUMBER; position++)
   \   0000000A   0x2600             MOVS     R6,#+0
   \   0000000C   0x0032             MOVS     R2,R6
   \                     ??HAL_GPIO_Init_0: (+1)
   \   0000000E   0x2A10             CMP      R2,#+16
   \   00000010   0xF080 0x80EF      BCS.W    ??HAL_GPIO_Init_1
    202            {
    203              /* Get the IO position */
    204              ioposition = ((uint32_t)0x01) << position;
   \   00000014   0x2601             MOVS     R6,#+1
   \   00000016   0x4096             LSLS     R6,R6,R2
   \   00000018   0x0033             MOVS     R3,R6
    205              /* Get the current IO position */
    206              iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;
   \   0000001A   0x680E             LDR      R6,[R1, #+0]
   \   0000001C   0x401E             ANDS     R6,R3,R6
   \   0000001E   0x0034             MOVS     R4,R6
    207          
    208              if(iocurrent == ioposition)
   \   00000020   0x429C             CMP      R4,R3
   \   00000022   0xF040 0x80E4      BNE.W    ??HAL_GPIO_Init_2
    209              {
    210                /*--------------------- GPIO Mode Configuration ------------------------*/
    211                /* In case of Alternate function mode selection */
    212                if((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
   \   00000026   0x684E             LDR      R6,[R1, #+4]
   \   00000028   0x2E02             CMP      R6,#+2
   \   0000002A   0xD002             BEQ.N    ??HAL_GPIO_Init_3
   \   0000002C   0x684E             LDR      R6,[R1, #+4]
   \   0000002E   0x2E12             CMP      R6,#+18
   \   00000030   0xD116             BNE.N    ??HAL_GPIO_Init_4
    213                {
    214                  /* Check the Alternate function parameter */
    215                  assert_param(IS_GPIO_AF(GPIO_Init->Alternate));
    216                  
    217                  /* Configure Alternate function mapped with the current IO */
    218                  temp = GPIOx->AFR[position >> 3];
   \                     ??HAL_GPIO_Init_3: (+1)
   \   00000032   0x08D6             LSRS     R6,R2,#+3
   \   00000034   0xEB10 0x0686      ADDS     R6,R0,R6, LSL #+2
   \   00000038   0x6A36             LDR      R6,[R6, #+32]
   \   0000003A   0x0035             MOVS     R5,R6
    219                  temp &= ~((uint32_t)0xF << ((uint32_t)(position & (uint32_t)0x07) * 4)) ;
   \   0000003C   0x260F             MOVS     R6,#+15
   \   0000003E   0xF012 0x0707      ANDS     R7,R2,#0x7
   \   00000042   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000044   0x00BF             LSLS     R7,R7,#+2
   \   00000046   0x40BE             LSLS     R6,R6,R7
   \   00000048   0x43B5             BICS     R5,R5,R6
    220                  temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & (uint32_t)0x07) * 4));
   \   0000004A   0x690E             LDR      R6,[R1, #+16]
   \   0000004C   0xF012 0x0707      ANDS     R7,R2,#0x7
   \   00000050   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000052   0x00BF             LSLS     R7,R7,#+2
   \   00000054   0x40BE             LSLS     R6,R6,R7
   \   00000056   0x4335             ORRS     R5,R6,R5
    221                  GPIOx->AFR[position >> 3] = temp;
   \   00000058   0x08D6             LSRS     R6,R2,#+3
   \   0000005A   0xEB10 0x0686      ADDS     R6,R0,R6, LSL #+2
   \   0000005E   0x6235             STR      R5,[R6, #+32]
    222                }
    223          
    224                /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
    225                temp = GPIOx->MODER;
   \                     ??HAL_GPIO_Init_4: (+1)
   \   00000060   0x6806             LDR      R6,[R0, #+0]
   \   00000062   0x0035             MOVS     R5,R6
    226                temp &= ~(GPIO_MODER_MODER0 << (position * 2));
   \   00000064   0x2603             MOVS     R6,#+3
   \   00000066   0x0017             MOVS     R7,R2
   \   00000068   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000006A   0x007F             LSLS     R7,R7,#+1
   \   0000006C   0x40BE             LSLS     R6,R6,R7
   \   0000006E   0x43B5             BICS     R5,R5,R6
    227                temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2));
   \   00000070   0x790E             LDRB     R6,[R1, #+4]
   \   00000072   0xF016 0x0603      ANDS     R6,R6,#0x3
   \   00000076   0x0017             MOVS     R7,R2
   \   00000078   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000007A   0x007F             LSLS     R7,R7,#+1
   \   0000007C   0x40BE             LSLS     R6,R6,R7
   \   0000007E   0x4335             ORRS     R5,R6,R5
    228                GPIOx->MODER = temp;
   \   00000080   0x6005             STR      R5,[R0, #+0]
    229          
    230                /* In case of Output or Alternate function mode selection */
    231                if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
    232                   (GPIO_Init->Mode == GPIO_MODE_OUTPUT_OD) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
   \   00000082   0x684E             LDR      R6,[R1, #+4]
   \   00000084   0x2E01             CMP      R6,#+1
   \   00000086   0xD008             BEQ.N    ??HAL_GPIO_Init_5
   \   00000088   0x684E             LDR      R6,[R1, #+4]
   \   0000008A   0x2E02             CMP      R6,#+2
   \   0000008C   0xD005             BEQ.N    ??HAL_GPIO_Init_5
   \   0000008E   0x684E             LDR      R6,[R1, #+4]
   \   00000090   0x2E11             CMP      R6,#+17
   \   00000092   0xD002             BEQ.N    ??HAL_GPIO_Init_5
   \   00000094   0x684E             LDR      R6,[R1, #+4]
   \   00000096   0x2E12             CMP      R6,#+18
   \   00000098   0xD119             BNE.N    ??HAL_GPIO_Init_6
    233                {
    234                  /* Check the Speed parameter */
    235                  assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
    236                  /* Configure the IO Speed */
    237                  temp = GPIOx->OSPEEDR; 
   \                     ??HAL_GPIO_Init_5: (+1)
   \   0000009A   0x6886             LDR      R6,[R0, #+8]
   \   0000009C   0x0035             MOVS     R5,R6
    238                  temp &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2));
   \   0000009E   0x2603             MOVS     R6,#+3
   \   000000A0   0x0017             MOVS     R7,R2
   \   000000A2   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000000A4   0x007F             LSLS     R7,R7,#+1
   \   000000A6   0x40BE             LSLS     R6,R6,R7
   \   000000A8   0x43B5             BICS     R5,R5,R6
    239                  temp |= (GPIO_Init->Speed << (position * 2));
   \   000000AA   0x68CE             LDR      R6,[R1, #+12]
   \   000000AC   0x0017             MOVS     R7,R2
   \   000000AE   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000000B0   0x007F             LSLS     R7,R7,#+1
   \   000000B2   0x40BE             LSLS     R6,R6,R7
   \   000000B4   0x4335             ORRS     R5,R6,R5
    240                  GPIOx->OSPEEDR = temp;
   \   000000B6   0x6085             STR      R5,[R0, #+8]
    241          
    242                  /* Configure the IO Output Type */
    243                  temp = GPIOx->OTYPER;
   \   000000B8   0x6846             LDR      R6,[R0, #+4]
   \   000000BA   0x0035             MOVS     R5,R6
    244                  temp &= ~(GPIO_OTYPER_OT_0 << position) ;
   \   000000BC   0x2601             MOVS     R6,#+1
   \   000000BE   0x4096             LSLS     R6,R6,R2
   \   000000C0   0x43B5             BICS     R5,R5,R6
    245                  temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4) << position);
   \   000000C2   0x684E             LDR      R6,[R1, #+4]
   \   000000C4   0xF3C6 0x1600      UBFX     R6,R6,#+4,#+1
   \   000000C8   0x4096             LSLS     R6,R6,R2
   \   000000CA   0x4335             ORRS     R5,R6,R5
    246                  GPIOx->OTYPER = temp;
   \   000000CC   0x6045             STR      R5,[R0, #+4]
    247                }
    248          
    249                /* Activate the Pull-up or Pull down resistor for the current IO */
    250                temp = GPIOx->PUPDR;
   \                     ??HAL_GPIO_Init_6: (+1)
   \   000000CE   0x68C6             LDR      R6,[R0, #+12]
   \   000000D0   0x0035             MOVS     R5,R6
    251                temp &= ~(GPIO_PUPDR_PUPDR0 << (position * 2));
   \   000000D2   0x2603             MOVS     R6,#+3
   \   000000D4   0x0017             MOVS     R7,R2
   \   000000D6   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000000D8   0x007F             LSLS     R7,R7,#+1
   \   000000DA   0x40BE             LSLS     R6,R6,R7
   \   000000DC   0x43B5             BICS     R5,R5,R6
    252                temp |= ((GPIO_Init->Pull) << (position * 2));
   \   000000DE   0x688E             LDR      R6,[R1, #+8]
   \   000000E0   0x0017             MOVS     R7,R2
   \   000000E2   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000000E4   0x007F             LSLS     R7,R7,#+1
   \   000000E6   0x40BE             LSLS     R6,R6,R7
   \   000000E8   0x4335             ORRS     R5,R6,R5
    253                GPIOx->PUPDR = temp;
   \   000000EA   0x60C5             STR      R5,[R0, #+12]
    254          
    255                /*--------------------- EXTI Mode Configuration ------------------------*/
    256                /* Configure the External Interrupt or event for the current IO */
    257                if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
   \   000000EC   0x684E             LDR      R6,[R1, #+4]
   \   000000EE   0x00F6             LSLS     R6,R6,#+3
   \   000000F0   0xD57D             BPL.N    ??HAL_GPIO_Init_2
    258                {
    259                  /* Enable SYSCFG Clock */
    260                  __HAL_RCC_SYSCFG_CLK_ENABLE();
   \   000000F2   0x....             LDR.N    R6,??DataTable2  ;; 0x40023844
   \   000000F4   0x6836             LDR      R6,[R6, #+0]
   \   000000F6   0xF456 0x4680      ORRS     R6,R6,#0x4000
   \   000000FA   0x....             LDR.N    R7,??DataTable2  ;; 0x40023844
   \   000000FC   0x603E             STR      R6,[R7, #+0]
   \   000000FE   0x....             LDR.N    R6,??DataTable2  ;; 0x40023844
   \   00000100   0x6836             LDR      R6,[R6, #+0]
   \   00000102   0xF416 0x4680      ANDS     R6,R6,#0x4000
   \   00000106   0x9600             STR      R6,[SP, #+0]
   \   00000108   0x9E00             LDR      R6,[SP, #+0]
    261          
    262                  temp = SYSCFG->EXTICR[position >> 2];
   \   0000010A   0x....             LDR.N    R6,??DataTable2_1  ;; 0x40013808
   \   0000010C   0x0897             LSRS     R7,R2,#+2
   \   0000010E   0xF856 0x6027      LDR      R6,[R6, R7, LSL #+2]
   \   00000112   0x0035             MOVS     R5,R6
    263                  temp &= ~(((uint32_t)0x0F) << (4 * (position & 0x03)));
   \   00000114   0x260F             MOVS     R6,#+15
   \   00000116   0xF012 0x0703      ANDS     R7,R2,#0x3
   \   0000011A   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000011C   0x00BF             LSLS     R7,R7,#+2
   \   0000011E   0x40BE             LSLS     R6,R6,R7
   \   00000120   0x43B5             BICS     R5,R5,R6
    264                  temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4 * (position & 0x03)));
   \   00000122   0x....             LDR.N    R6,??DataTable2_2  ;; 0x40020000
   \   00000124   0x42B0             CMP      R0,R6
   \   00000126   0xD101             BNE.N    ??HAL_GPIO_Init_7
   \   00000128   0x2600             MOVS     R6,#+0
   \   0000012A   0xE02D             B.N      ??HAL_GPIO_Init_8
   \                     ??HAL_GPIO_Init_7: (+1)
   \   0000012C   0x....             LDR.N    R6,??DataTable2_3  ;; 0x40020400
   \   0000012E   0x42B0             CMP      R0,R6
   \   00000130   0xD101             BNE.N    ??HAL_GPIO_Init_9
   \   00000132   0x2601             MOVS     R6,#+1
   \   00000134   0xE028             B.N      ??HAL_GPIO_Init_8
   \                     ??HAL_GPIO_Init_9: (+1)
   \   00000136   0x....             LDR.N    R6,??DataTable2_4  ;; 0x40020800
   \   00000138   0x42B0             CMP      R0,R6
   \   0000013A   0xD101             BNE.N    ??HAL_GPIO_Init_10
   \   0000013C   0x2602             MOVS     R6,#+2
   \   0000013E   0xE023             B.N      ??HAL_GPIO_Init_11
   \                     ??HAL_GPIO_Init_10: (+1)
   \   00000140   0x....             LDR.N    R6,??DataTable2_5  ;; 0x40020c00
   \   00000142   0x42B0             CMP      R0,R6
   \   00000144   0xD101             BNE.N    ??HAL_GPIO_Init_12
   \   00000146   0x2603             MOVS     R6,#+3
   \   00000148   0xE01E             B.N      ??HAL_GPIO_Init_11
   \                     ??HAL_GPIO_Init_12: (+1)
   \   0000014A   0x....             LDR.N    R6,??DataTable2_6  ;; 0x40021000
   \   0000014C   0x42B0             CMP      R0,R6
   \   0000014E   0xD101             BNE.N    ??HAL_GPIO_Init_13
   \   00000150   0x2604             MOVS     R6,#+4
   \   00000152   0xE019             B.N      ??HAL_GPIO_Init_14
   \                     ??HAL_GPIO_Init_13: (+1)
   \   00000154   0x....             LDR.N    R6,??DataTable2_7  ;; 0x40021400
   \   00000156   0x42B0             CMP      R0,R6
   \   00000158   0xD101             BNE.N    ??HAL_GPIO_Init_15
   \   0000015A   0x2605             MOVS     R6,#+5
   \   0000015C   0xE014             B.N      ??HAL_GPIO_Init_14
   \                     ??HAL_GPIO_Init_15: (+1)
   \   0000015E   0x....             LDR.N    R6,??DataTable2_8  ;; 0x40021800
   \   00000160   0x42B0             CMP      R0,R6
   \   00000162   0xD101             BNE.N    ??HAL_GPIO_Init_16
   \   00000164   0x2606             MOVS     R6,#+6
   \   00000166   0xE00F             B.N      ??HAL_GPIO_Init_17
   \                     ??HAL_GPIO_Init_16: (+1)
   \   00000168   0x....             LDR.N    R6,??DataTable2_9  ;; 0x40021c00
   \   0000016A   0x42B0             CMP      R0,R6
   \   0000016C   0xD101             BNE.N    ??HAL_GPIO_Init_18
   \   0000016E   0x2607             MOVS     R6,#+7
   \   00000170   0xE00A             B.N      ??HAL_GPIO_Init_17
   \                     ??HAL_GPIO_Init_18: (+1)
   \   00000172   0x....             LDR.N    R6,??DataTable2_10  ;; 0x40022000
   \   00000174   0x42B0             CMP      R0,R6
   \   00000176   0xD101             BNE.N    ??HAL_GPIO_Init_19
   \   00000178   0x2608             MOVS     R6,#+8
   \   0000017A   0xE005             B.N      ??HAL_GPIO_Init_20
   \                     ??HAL_GPIO_Init_19: (+1)
   \   0000017C   0x....             LDR.N    R6,??DataTable2_11  ;; 0x40022400
   \   0000017E   0x42B0             CMP      R0,R6
   \   00000180   0xD101             BNE.N    ??HAL_GPIO_Init_21
   \   00000182   0x2609             MOVS     R6,#+9
   \   00000184   0xE000             B.N      ??HAL_GPIO_Init_20
   \                     ??HAL_GPIO_Init_21: (+1)
   \   00000186   0x260A             MOVS     R6,#+10
   \                     ??HAL_GPIO_Init_20: (+1)
   \                     ??HAL_GPIO_Init_17: (+1)
   \                     ??HAL_GPIO_Init_14: (+1)
   \                     ??HAL_GPIO_Init_11: (+1)
   \                     ??HAL_GPIO_Init_8: (+1)
   \   00000188   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000018A   0xF012 0x0703      ANDS     R7,R2,#0x3
   \   0000018E   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000190   0x00BF             LSLS     R7,R7,#+2
   \   00000192   0x40BE             LSLS     R6,R6,R7
   \   00000194   0x4335             ORRS     R5,R6,R5
    265                  SYSCFG->EXTICR[position >> 2] = temp;
   \   00000196   0x....             LDR.N    R6,??DataTable2_1  ;; 0x40013808
   \   00000198   0x0897             LSRS     R7,R2,#+2
   \   0000019A   0xF846 0x5027      STR      R5,[R6, R7, LSL #+2]
    266          
    267                  /* Clear EXTI line configuration */
    268                  temp = EXTI->IMR;
   \   0000019E   0x....             LDR.N    R6,??DataTable2_12  ;; 0x40013c00
   \   000001A0   0x6836             LDR      R6,[R6, #+0]
   \   000001A2   0x0035             MOVS     R5,R6
    269                  temp &= ~((uint32_t)iocurrent);
   \   000001A4   0x43A5             BICS     R5,R5,R4
    270                  if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
   \   000001A6   0x684E             LDR      R6,[R1, #+4]
   \   000001A8   0x03F6             LSLS     R6,R6,#+15
   \   000001AA   0xD500             BPL.N    ??HAL_GPIO_Init_22
    271                  {
    272                    temp |= iocurrent;
   \   000001AC   0x4325             ORRS     R5,R4,R5
    273                  }
    274                  EXTI->IMR = temp;
   \                     ??HAL_GPIO_Init_22: (+1)
   \   000001AE   0x....             LDR.N    R6,??DataTable2_12  ;; 0x40013c00
   \   000001B0   0x6035             STR      R5,[R6, #+0]
    275          
    276                  temp = EXTI->EMR;
   \   000001B2   0x....             LDR.N    R6,??DataTable2_13  ;; 0x40013c04
   \   000001B4   0x6836             LDR      R6,[R6, #+0]
   \   000001B6   0x0035             MOVS     R5,R6
    277                  temp &= ~((uint32_t)iocurrent);
   \   000001B8   0x43A5             BICS     R5,R5,R4
    278                  if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
   \   000001BA   0x684E             LDR      R6,[R1, #+4]
   \   000001BC   0x03B6             LSLS     R6,R6,#+14
   \   000001BE   0xD500             BPL.N    ??HAL_GPIO_Init_23
    279                  {
    280                    temp |= iocurrent;
   \   000001C0   0x4325             ORRS     R5,R4,R5
    281                  }
    282                  EXTI->EMR = temp;
   \                     ??HAL_GPIO_Init_23: (+1)
   \   000001C2   0x....             LDR.N    R6,??DataTable2_13  ;; 0x40013c04
   \   000001C4   0x6035             STR      R5,[R6, #+0]
    283          
    284                  /* Clear Rising Falling edge configuration */
    285                  temp = EXTI->RTSR;
   \   000001C6   0x....             LDR.N    R6,??DataTable2_14  ;; 0x40013c08
   \   000001C8   0x6836             LDR      R6,[R6, #+0]
   \   000001CA   0x0035             MOVS     R5,R6
    286                  temp &= ~((uint32_t)iocurrent);
   \   000001CC   0x43A5             BICS     R5,R5,R4
    287                  if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
   \   000001CE   0x684E             LDR      R6,[R1, #+4]
   \   000001D0   0x02F6             LSLS     R6,R6,#+11
   \   000001D2   0xD500             BPL.N    ??HAL_GPIO_Init_24
    288                  {
    289                    temp |= iocurrent;
   \   000001D4   0x4325             ORRS     R5,R4,R5
    290                  }
    291                  EXTI->RTSR = temp;
   \                     ??HAL_GPIO_Init_24: (+1)
   \   000001D6   0x....             LDR.N    R6,??DataTable2_14  ;; 0x40013c08
   \   000001D8   0x6035             STR      R5,[R6, #+0]
    292          
    293                  temp = EXTI->FTSR;
   \   000001DA   0x....             LDR.N    R6,??DataTable2_15  ;; 0x40013c0c
   \   000001DC   0x6836             LDR      R6,[R6, #+0]
   \   000001DE   0x0035             MOVS     R5,R6
    294                  temp &= ~((uint32_t)iocurrent);
   \   000001E0   0x43A5             BICS     R5,R5,R4
    295                  if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
   \   000001E2   0x684E             LDR      R6,[R1, #+4]
   \   000001E4   0x02B6             LSLS     R6,R6,#+10
   \   000001E6   0xD500             BPL.N    ??HAL_GPIO_Init_25
    296                  {
    297                    temp |= iocurrent;
   \   000001E8   0x4325             ORRS     R5,R4,R5
    298                  }
    299                  EXTI->FTSR = temp;
   \                     ??HAL_GPIO_Init_25: (+1)
   \   000001EA   0x....             LDR.N    R6,??DataTable2_15  ;; 0x40013c0c
   \   000001EC   0x6035             STR      R5,[R6, #+0]
    300                }
    301              }
    302            }
   \                     ??HAL_GPIO_Init_2: (+1)
   \   000001EE   0x1C52             ADDS     R2,R2,#+1
   \   000001F0   0xE70D             B.N      ??HAL_GPIO_Init_0
    303          }
   \                     ??HAL_GPIO_Init_1: (+1)
   \   000001F2   0xBCF1             POP      {R0,R4-R7}
   \   000001F4   0x4770             BX       LR               ;; return
    304          
    305          /**
    306            * @brief  De-initializes the GPIOx peripheral registers to their default reset values.
    307            * @param  GPIOx: where x can be (A..K) to select the GPIO peripheral.
    308            * @param  GPIO_Pin: specifies the port bit to be written.
    309            *          This parameter can be one of GPIO_PIN_x where x can be (0..15).
    310            * @retval None
    311            */

   \                                 In section .text, align 2, keep-with-next
    312          void HAL_GPIO_DeInit(GPIO_TypeDef  *GPIOx, uint32_t GPIO_Pin)
    313          {
   \                     HAL_GPIO_DeInit: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
    314            uint32_t position;
    315            uint32_t ioposition = 0x00;
   \   00000002   0x2200             MOVS     R2,#+0
    316            uint32_t iocurrent = 0x00;
   \   00000004   0x2300             MOVS     R3,#+0
    317            uint32_t tmp = 0x00;
   \   00000006   0x2400             MOVS     R4,#+0
    318          
    319            /* Check the parameters */
    320            assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
    321            
    322            /* Configure the port pins */
    323            for(position = 0; position < GPIO_NUMBER; position++)
   \   00000008   0x2600             MOVS     R6,#+0
   \   0000000A   0x0035             MOVS     R5,R6
   \                     ??HAL_GPIO_DeInit_0: (+1)
   \   0000000C   0x2D10             CMP      R5,#+16
   \   0000000E   0xF080 0x80B1      BCS.W    ??HAL_GPIO_DeInit_1
    324            {
    325              /* Get the IO position */
    326              ioposition = ((uint32_t)0x01) << position;
   \   00000012   0x2601             MOVS     R6,#+1
   \   00000014   0x40AE             LSLS     R6,R6,R5
   \   00000016   0x0032             MOVS     R2,R6
    327              /* Get the current IO position */
    328              iocurrent = (GPIO_Pin) & ioposition;
   \   00000018   0xEA12 0x0601      ANDS     R6,R2,R1
   \   0000001C   0x0033             MOVS     R3,R6
    329          
    330              if(iocurrent == ioposition)
   \   0000001E   0x4293             CMP      R3,R2
   \   00000020   0xF040 0x80A6      BNE.W    ??HAL_GPIO_DeInit_2
    331              {
    332                /*------------------------- GPIO Mode Configuration --------------------*/
    333                /* Configure IO Direction in Input Floating Mode */
    334                GPIOx->MODER &= ~(GPIO_MODER_MODER0 << (position * 2));
   \   00000024   0x6806             LDR      R6,[R0, #+0]
   \   00000026   0x2703             MOVS     R7,#+3
   \   00000028   0x46AC             MOV      R12,R5
   \   0000002A   0xFA5F 0xFC8C      UXTB     R12,R12          ;; ZeroExt  R12,R12,#+24,#+24
   \   0000002E   0xEA5F 0x0C4C      LSLS     R12,R12,#+1
   \   00000032   0xFA17 0xF70C      LSLS     R7,R7,R12
   \   00000036   0x43BE             BICS     R6,R6,R7
   \   00000038   0x6006             STR      R6,[R0, #+0]
    335          
    336                /* Configure the default Alternate Function in current IO */
    337                GPIOx->AFR[position >> 3] &= ~((uint32_t)0xF << ((uint32_t)(position & (uint32_t)0x07) * 4)) ;
   \   0000003A   0x08EE             LSRS     R6,R5,#+3
   \   0000003C   0xEB10 0x0686      ADDS     R6,R0,R6, LSL #+2
   \   00000040   0x08EF             LSRS     R7,R5,#+3
   \   00000042   0xEB10 0x0787      ADDS     R7,R0,R7, LSL #+2
   \   00000046   0x6A3F             LDR      R7,[R7, #+32]
   \   00000048   0xF05F 0x0C0F      MOVS     R12,#+15
   \   0000004C   0xF015 0x0E07      ANDS     LR,R5,#0x7
   \   00000050   0xFA5F 0xFE8E      UXTB     LR,LR            ;; ZeroExt  LR,LR,#+24,#+24
   \   00000054   0xEA5F 0x0E8E      LSLS     LR,LR,#+2
   \   00000058   0xFA1C 0xFC0E      LSLS     R12,R12,LR
   \   0000005C   0xEA37 0x070C      BICS     R7,R7,R12
   \   00000060   0x6237             STR      R7,[R6, #+32]
    338          
    339                /* Configure the default value for IO Speed */
    340                GPIOx->OSPEEDR &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2));
   \   00000062   0x6886             LDR      R6,[R0, #+8]
   \   00000064   0x2703             MOVS     R7,#+3
   \   00000066   0x46AC             MOV      R12,R5
   \   00000068   0xFA5F 0xFC8C      UXTB     R12,R12          ;; ZeroExt  R12,R12,#+24,#+24
   \   0000006C   0xEA5F 0x0C4C      LSLS     R12,R12,#+1
   \   00000070   0xFA17 0xF70C      LSLS     R7,R7,R12
   \   00000074   0x43BE             BICS     R6,R6,R7
   \   00000076   0x6086             STR      R6,[R0, #+8]
    341          
    342                /* Configure the default value IO Output Type */
    343                GPIOx->OTYPER  &= ~(GPIO_OTYPER_OT_0 << position) ;
   \   00000078   0x6846             LDR      R6,[R0, #+4]
   \   0000007A   0x2701             MOVS     R7,#+1
   \   0000007C   0x40AF             LSLS     R7,R7,R5
   \   0000007E   0x43BE             BICS     R6,R6,R7
   \   00000080   0x6046             STR      R6,[R0, #+4]
    344          
    345                /* Deactivate the Pull-up and Pull-down resistor for the current IO */
    346                GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPDR0 << (position * 2));
   \   00000082   0x68C6             LDR      R6,[R0, #+12]
   \   00000084   0x2703             MOVS     R7,#+3
   \   00000086   0x46AC             MOV      R12,R5
   \   00000088   0xFA5F 0xFC8C      UXTB     R12,R12          ;; ZeroExt  R12,R12,#+24,#+24
   \   0000008C   0xEA5F 0x0C4C      LSLS     R12,R12,#+1
   \   00000090   0xFA17 0xF70C      LSLS     R7,R7,R12
   \   00000094   0x43BE             BICS     R6,R6,R7
   \   00000096   0x60C6             STR      R6,[R0, #+12]
    347          
    348                /*------------------------- EXTI Mode Configuration --------------------*/
    349                tmp = SYSCFG->EXTICR[position >> 2];
   \   00000098   0x....             LDR.N    R6,??DataTable2_1  ;; 0x40013808
   \   0000009A   0x08AF             LSRS     R7,R5,#+2
   \   0000009C   0xF856 0x6027      LDR      R6,[R6, R7, LSL #+2]
   \   000000A0   0x0034             MOVS     R4,R6
    350                tmp &= (((uint32_t)0x0F) << (4 * (position & 0x03)));
   \   000000A2   0x260F             MOVS     R6,#+15
   \   000000A4   0xF015 0x0703      ANDS     R7,R5,#0x3
   \   000000A8   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000000AA   0x00BF             LSLS     R7,R7,#+2
   \   000000AC   0x40BE             LSLS     R6,R6,R7
   \   000000AE   0x4034             ANDS     R4,R6,R4
    351                if(tmp == ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4 * (position & 0x03))))
   \   000000B0   0x....             LDR.N    R6,??DataTable2_2  ;; 0x40020000
   \   000000B2   0x42B0             CMP      R0,R6
   \   000000B4   0xD101             BNE.N    ??HAL_GPIO_DeInit_3
   \   000000B6   0x2600             MOVS     R6,#+0
   \   000000B8   0xE02D             B.N      ??HAL_GPIO_DeInit_4
   \                     ??HAL_GPIO_DeInit_3: (+1)
   \   000000BA   0x....             LDR.N    R6,??DataTable2_3  ;; 0x40020400
   \   000000BC   0x42B0             CMP      R0,R6
   \   000000BE   0xD101             BNE.N    ??HAL_GPIO_DeInit_5
   \   000000C0   0x2601             MOVS     R6,#+1
   \   000000C2   0xE028             B.N      ??HAL_GPIO_DeInit_4
   \                     ??HAL_GPIO_DeInit_5: (+1)
   \   000000C4   0x....             LDR.N    R6,??DataTable2_4  ;; 0x40020800
   \   000000C6   0x42B0             CMP      R0,R6
   \   000000C8   0xD101             BNE.N    ??HAL_GPIO_DeInit_6
   \   000000CA   0x2602             MOVS     R6,#+2
   \   000000CC   0xE023             B.N      ??HAL_GPIO_DeInit_7
   \                     ??HAL_GPIO_DeInit_6: (+1)
   \   000000CE   0x....             LDR.N    R6,??DataTable2_5  ;; 0x40020c00
   \   000000D0   0x42B0             CMP      R0,R6
   \   000000D2   0xD101             BNE.N    ??HAL_GPIO_DeInit_8
   \   000000D4   0x2603             MOVS     R6,#+3
   \   000000D6   0xE01E             B.N      ??HAL_GPIO_DeInit_7
   \                     ??HAL_GPIO_DeInit_8: (+1)
   \   000000D8   0x....             LDR.N    R6,??DataTable2_6  ;; 0x40021000
   \   000000DA   0x42B0             CMP      R0,R6
   \   000000DC   0xD101             BNE.N    ??HAL_GPIO_DeInit_9
   \   000000DE   0x2604             MOVS     R6,#+4
   \   000000E0   0xE019             B.N      ??HAL_GPIO_DeInit_10
   \                     ??HAL_GPIO_DeInit_9: (+1)
   \   000000E2   0x....             LDR.N    R6,??DataTable2_7  ;; 0x40021400
   \   000000E4   0x42B0             CMP      R0,R6
   \   000000E6   0xD101             BNE.N    ??HAL_GPIO_DeInit_11
   \   000000E8   0x2605             MOVS     R6,#+5
   \   000000EA   0xE014             B.N      ??HAL_GPIO_DeInit_10
   \                     ??HAL_GPIO_DeInit_11: (+1)
   \   000000EC   0x....             LDR.N    R6,??DataTable2_8  ;; 0x40021800
   \   000000EE   0x42B0             CMP      R0,R6
   \   000000F0   0xD101             BNE.N    ??HAL_GPIO_DeInit_12
   \   000000F2   0x2606             MOVS     R6,#+6
   \   000000F4   0xE00F             B.N      ??HAL_GPIO_DeInit_13
   \                     ??HAL_GPIO_DeInit_12: (+1)
   \   000000F6   0x....             LDR.N    R6,??DataTable2_9  ;; 0x40021c00
   \   000000F8   0x42B0             CMP      R0,R6
   \   000000FA   0xD101             BNE.N    ??HAL_GPIO_DeInit_14
   \   000000FC   0x2607             MOVS     R6,#+7
   \   000000FE   0xE00A             B.N      ??HAL_GPIO_DeInit_13
   \                     ??HAL_GPIO_DeInit_14: (+1)
   \   00000100   0x....             LDR.N    R6,??DataTable2_10  ;; 0x40022000
   \   00000102   0x42B0             CMP      R0,R6
   \   00000104   0xD101             BNE.N    ??HAL_GPIO_DeInit_15
   \   00000106   0x2608             MOVS     R6,#+8
   \   00000108   0xE005             B.N      ??HAL_GPIO_DeInit_16
   \                     ??HAL_GPIO_DeInit_15: (+1)
   \   0000010A   0x....             LDR.N    R6,??DataTable2_11  ;; 0x40022400
   \   0000010C   0x42B0             CMP      R0,R6
   \   0000010E   0xD101             BNE.N    ??HAL_GPIO_DeInit_17
   \   00000110   0x2609             MOVS     R6,#+9
   \   00000112   0xE000             B.N      ??HAL_GPIO_DeInit_16
   \                     ??HAL_GPIO_DeInit_17: (+1)
   \   00000114   0x260A             MOVS     R6,#+10
   \                     ??HAL_GPIO_DeInit_16: (+1)
   \                     ??HAL_GPIO_DeInit_13: (+1)
   \                     ??HAL_GPIO_DeInit_10: (+1)
   \                     ??HAL_GPIO_DeInit_7: (+1)
   \                     ??HAL_GPIO_DeInit_4: (+1)
   \   00000116   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000118   0xF015 0x0703      ANDS     R7,R5,#0x3
   \   0000011C   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000011E   0x00BF             LSLS     R7,R7,#+2
   \   00000120   0x40BE             LSLS     R6,R6,R7
   \   00000122   0x42B4             CMP      R4,R6
   \   00000124   0xD124             BNE.N    ??HAL_GPIO_DeInit_2
    352                {
    353                  /* Configure the External Interrupt or event for the current IO */
    354                  tmp = ((uint32_t)0x0F) << (4 * (position & 0x03));
   \   00000126   0x260F             MOVS     R6,#+15
   \   00000128   0xF015 0x0703      ANDS     R7,R5,#0x3
   \   0000012C   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000012E   0x00BF             LSLS     R7,R7,#+2
   \   00000130   0x40BE             LSLS     R6,R6,R7
   \   00000132   0x0034             MOVS     R4,R6
    355                  SYSCFG->EXTICR[position >> 2] &= ~tmp;
   \   00000134   0x....             LDR.N    R6,??DataTable2_1  ;; 0x40013808
   \   00000136   0x08AF             LSRS     R7,R5,#+2
   \   00000138   0xF856 0x6027      LDR      R6,[R6, R7, LSL #+2]
   \   0000013C   0x43A6             BICS     R6,R6,R4
   \   0000013E   0x....             LDR.N    R7,??DataTable2_1  ;; 0x40013808
   \   00000140   0xEA5F 0x0C95      LSRS     R12,R5,#+2
   \   00000144   0xF847 0x602C      STR      R6,[R7, R12, LSL #+2]
    356          
    357                  /* Clear EXTI line configuration */
    358                  EXTI->IMR &= ~((uint32_t)iocurrent);
   \   00000148   0x....             LDR.N    R6,??DataTable2_12  ;; 0x40013c00
   \   0000014A   0x6836             LDR      R6,[R6, #+0]
   \   0000014C   0x439E             BICS     R6,R6,R3
   \   0000014E   0x....             LDR.N    R7,??DataTable2_12  ;; 0x40013c00
   \   00000150   0x603E             STR      R6,[R7, #+0]
    359                  EXTI->EMR &= ~((uint32_t)iocurrent);
   \   00000152   0x....             LDR.N    R6,??DataTable2_13  ;; 0x40013c04
   \   00000154   0x6836             LDR      R6,[R6, #+0]
   \   00000156   0x439E             BICS     R6,R6,R3
   \   00000158   0x....             LDR.N    R7,??DataTable2_13  ;; 0x40013c04
   \   0000015A   0x603E             STR      R6,[R7, #+0]
    360          
    361                  /* Clear Rising Falling edge configuration */
    362                  EXTI->RTSR &= ~((uint32_t)iocurrent);
   \   0000015C   0x....             LDR.N    R6,??DataTable2_14  ;; 0x40013c08
   \   0000015E   0x6836             LDR      R6,[R6, #+0]
   \   00000160   0x439E             BICS     R6,R6,R3
   \   00000162   0x....             LDR.N    R7,??DataTable2_14  ;; 0x40013c08
   \   00000164   0x603E             STR      R6,[R7, #+0]
    363                  EXTI->FTSR &= ~((uint32_t)iocurrent);
   \   00000166   0x....             LDR.N    R6,??DataTable2_15  ;; 0x40013c0c
   \   00000168   0x6836             LDR      R6,[R6, #+0]
   \   0000016A   0x439E             BICS     R6,R6,R3
   \   0000016C   0x....             LDR.N    R7,??DataTable2_15  ;; 0x40013c0c
   \   0000016E   0x603E             STR      R6,[R7, #+0]
    364          	  }
    365              }
    366            }
   \                     ??HAL_GPIO_DeInit_2: (+1)
   \   00000170   0x1C6D             ADDS     R5,R5,#+1
   \   00000172   0xE74B             B.N      ??HAL_GPIO_DeInit_0
    367          }
   \                     ??HAL_GPIO_DeInit_1: (+1)
   \   00000174   0xBDF0             POP      {R4-R7,PC}       ;; return
    368          
    369          /**
    370            * @}
    371            */
    372          
    373          /** @defgroup GPIO_Exported_Functions_Group2 IO operation functions 
    374           *  @brief   GPIO Read and Write
    375           *
    376          @verbatim
    377           ===============================================================================
    378                                 ##### IO operation functions #####
    379           ===============================================================================
    380          
    381          @endverbatim
    382            * @{
    383            */
    384          
    385          /**
    386            * @brief  Reads the specified input port pin.
    387            * @param  GPIOx: where x can be (A..K) to select the GPIO peripheral.
    388            * @param  GPIO_Pin: specifies the port bit to read.
    389            *         This parameter can be GPIO_PIN_x where x can be (0..15).
    390            * @retval The input port pin value.
    391            */

   \                                 In section .text, align 2, keep-with-next
    392          GPIO_PinState HAL_GPIO_ReadPin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
    393          {
   \                     HAL_GPIO_ReadPin: (+1)
   \   00000000   0x0002             MOVS     R2,R0
    394            GPIO_PinState bitstatus;
    395          
    396            /* Check the parameters */
    397            assert_param(IS_GPIO_PIN(GPIO_Pin));
    398          
    399            if((GPIOx->IDR & GPIO_Pin) != (uint32_t)GPIO_PIN_RESET)
   \   00000002   0x6913             LDR      R3,[R2, #+16]
   \   00000004   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000006   0x420B             TST      R3,R1
   \   00000008   0xD002             BEQ.N    ??HAL_GPIO_ReadPin_0
    400            {
    401              bitstatus = GPIO_PIN_SET;
   \   0000000A   0x2301             MOVS     R3,#+1
   \   0000000C   0x0018             MOVS     R0,R3
   \   0000000E   0xE001             B.N      ??HAL_GPIO_ReadPin_1
    402            }
    403            else
    404            {
    405              bitstatus = GPIO_PIN_RESET;
   \                     ??HAL_GPIO_ReadPin_0: (+1)
   \   00000010   0x2300             MOVS     R3,#+0
   \   00000012   0x0018             MOVS     R0,R3
    406            }
    407            return bitstatus;
   \                     ??HAL_GPIO_ReadPin_1: (+1)
   \   00000014   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000016   0x4770             BX       LR               ;; return
    408          }
    409          
    410          /**
    411            * @brief  Sets or clears the selected data port bit.
    412            *
    413            * @note   This function uses GPIOx_BSRR register to allow atomic read/modify
    414            *         accesses. In this way, there is no risk of an IRQ occurring between
    415            *         the read and the modify access.
    416            *
    417            * @param  GPIOx: where x can be (A..K) to select the GPIO peripheral.
    418            * @param  GPIO_Pin: specifies the port bit to be written.
    419            *          This parameter can be one of GPIO_PIN_x where x can be (0..15).
    420            * @param  PinState: specifies the value to be written to the selected bit.
    421            *          This parameter can be one of the GPIO_PinState enum values:
    422            *            @arg GPIO_PIN_RESET: to clear the port pin
    423            *            @arg GPIO_PIN_SET: to set the port pin
    424            * @retval None
    425            */

   \                                 In section .text, align 2, keep-with-next
    426          void HAL_GPIO_WritePin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin, GPIO_PinState PinState)
    427          {
    428            /* Check the parameters */
    429            assert_param(IS_GPIO_PIN(GPIO_Pin));
    430            assert_param(IS_GPIO_PIN_ACTION(PinState));
    431          
    432            if(PinState != GPIO_PIN_RESET)
   \                     HAL_GPIO_WritePin: (+1)
   \   00000000   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000002   0x2A00             CMP      R2,#+0
   \   00000004   0xD002             BEQ.N    ??HAL_GPIO_WritePin_0
    433            {
    434              GPIOx->BSRR = GPIO_Pin;
   \   00000006   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000008   0x6181             STR      R1,[R0, #+24]
   \   0000000A   0xE002             B.N      ??HAL_GPIO_WritePin_1
    435            }
    436            else
    437            {
    438              GPIOx->BSRR = (uint32_t)GPIO_Pin << 16;
   \                     ??HAL_GPIO_WritePin_0: (+1)
   \   0000000C   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000000E   0x040B             LSLS     R3,R1,#+16
   \   00000010   0x6183             STR      R3,[R0, #+24]
    439            }
    440          }
   \                     ??HAL_GPIO_WritePin_1: (+1)
   \   00000012   0x4770             BX       LR               ;; return
    441          
    442          /**
    443            * @brief  Toggles the specified GPIO pins.
    444            * @param  GPIOx: Where x can be (A..I) to select the GPIO peripheral.
    445            * @param  GPIO_Pin: Specifies the pins to be toggled.
    446            * @retval None
    447            */

   \                                 In section .text, align 2, keep-with-next
    448          void HAL_GPIO_TogglePin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
    449          {
    450            /* Check the parameters */
    451            assert_param(IS_GPIO_PIN(GPIO_Pin));
    452          
    453            GPIOx->ODR ^= GPIO_Pin;
   \                     HAL_GPIO_TogglePin: (+1)
   \   00000000   0x6942             LDR      R2,[R0, #+20]
   \   00000002   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000004   0x404A             EORS     R2,R1,R2
   \   00000006   0x6142             STR      R2,[R0, #+20]
    454          }
   \   00000008   0x4770             BX       LR               ;; return
    455          
    456          /**
    457            * @brief  Locks GPIO Pins configuration registers.
    458            * @note   The locked registers are GPIOx_MODER, GPIOx_OTYPER, GPIOx_OSPEEDR,
    459            *         GPIOx_PUPDR, GPIOx_AFRL and GPIOx_AFRH.
    460            * @note   The configuration of the locked GPIO pins can no longer be modified
    461            *         until the next reset.
    462            * @param  GPIOx: where x can be (A..F) to select the GPIO peripheral for STM32F7 family
    463            * @param  GPIO_Pin: specifies the port bit to be locked.
    464            *         This parameter can be any combination of GPIO_PIN_x where x can be (0..15).
    465            * @retval None
    466            */

   \                                 In section .text, align 2, keep-with-next
    467          HAL_StatusTypeDef HAL_GPIO_LockPin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
    468          {
   \                     HAL_GPIO_LockPin: (+1)
   \   00000000   0xB081             SUB      SP,SP,#+4
   \   00000002   0x0002             MOVS     R2,R0
    469            __IO uint32_t tmp = GPIO_LCKR_LCKK;
   \   00000004   0xF45F 0x3080      MOVS     R0,#+65536
   \   00000008   0x9000             STR      R0,[SP, #+0]
    470          
    471            /* Check the parameters */
    472            assert_param(IS_GPIO_PIN(GPIO_Pin));
    473          
    474            /* Apply lock key write sequence */
    475            tmp |= GPIO_Pin;
   \   0000000A   0x9800             LDR      R0,[SP, #+0]
   \   0000000C   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000000E   0x4308             ORRS     R0,R1,R0
   \   00000010   0x9000             STR      R0,[SP, #+0]
    476            /* Set LCKx bit(s): LCKK='1' + LCK[15-0] */
    477            GPIOx->LCKR = tmp;
   \   00000012   0x9800             LDR      R0,[SP, #+0]
   \   00000014   0x61D0             STR      R0,[R2, #+28]
    478            /* Reset LCKx bit(s): LCKK='0' + LCK[15-0] */
    479            GPIOx->LCKR = GPIO_Pin;
   \   00000016   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000018   0x61D1             STR      R1,[R2, #+28]
    480            /* Set LCKx bit(s): LCKK='1' + LCK[15-0] */
    481            GPIOx->LCKR = tmp;
   \   0000001A   0x9800             LDR      R0,[SP, #+0]
   \   0000001C   0x61D0             STR      R0,[R2, #+28]
    482            /* Read LCKK bit*/
    483            tmp = GPIOx->LCKR;
   \   0000001E   0x69D0             LDR      R0,[R2, #+28]
   \   00000020   0x9000             STR      R0,[SP, #+0]
    484          
    485           if((GPIOx->LCKR & GPIO_LCKR_LCKK) != RESET)
   \   00000022   0x69D0             LDR      R0,[R2, #+28]
   \   00000024   0x03C0             LSLS     R0,R0,#+15
   \   00000026   0xD501             BPL.N    ??HAL_GPIO_LockPin_0
    486            {
    487              return HAL_OK;
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0xE000             B.N      ??HAL_GPIO_LockPin_1
    488            }
    489            else
    490            {
    491              return HAL_ERROR;
   \                     ??HAL_GPIO_LockPin_0: (+1)
   \   0000002C   0x2001             MOVS     R0,#+1
   \                     ??HAL_GPIO_LockPin_1: (+1)
   \   0000002E   0xB001             ADD      SP,SP,#+4
   \   00000030   0x4770             BX       LR               ;; return
    492            }
    493          }
    494          
    495          /**
    496            * @brief  This function handles EXTI interrupt request.
    497            * @param  GPIO_Pin: Specifies the pins connected EXTI line
    498            * @retval None
    499            */

   \                                 In section .text, align 2, keep-with-next
    500          void HAL_GPIO_EXTI_IRQHandler(uint16_t GPIO_Pin)
    501          {
   \                     HAL_GPIO_EXTI_IRQHandler: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    502            /* EXTI line interrupt detected */
    503            if(__HAL_GPIO_EXTI_GET_IT(GPIO_Pin) != RESET)
   \   00000004   0x....             LDR.N    R0,??DataTable2_16  ;; 0x40013c14
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   0000000A   0x4220             TST      R0,R4
   \   0000000C   0xD006             BEQ.N    ??HAL_GPIO_EXTI_IRQHandler_0
    504            {
    505              __HAL_GPIO_EXTI_CLEAR_IT(GPIO_Pin);
   \   0000000E   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000010   0x....             LDR.N    R0,??DataTable2_16  ;; 0x40013c14
   \   00000012   0x6004             STR      R4,[R0, #+0]
    506              HAL_GPIO_EXTI_Callback(GPIO_Pin);
   \   00000014   0x0020             MOVS     R0,R4
   \   00000016   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000018   0x.... 0x....      BL       HAL_GPIO_EXTI_Callback
    507            }
    508          }
   \                     ??HAL_GPIO_EXTI_IRQHandler_0: (+1)
   \   0000001C   0xBD10             POP      {R4,PC}          ;; return
    509          
    510          /**
    511            * @brief  EXTI line detection callbacks.
    512            * @param  GPIO_Pin: Specifies the pins connected EXTI line
    513            * @retval None
    514            */

   \                                 In section .text, align 2, keep-with-next
    515          __weak void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)
    516          {
    517            /* NOTE: This function Should not be modified, when the callback is needed,
    518                     the HAL_GPIO_EXTI_Callback could be implemented in the user file
    519             */
    520          }
   \                     HAL_GPIO_EXTI_Callback: (+1)
   \   00000000   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2:
   \   00000000   0x40023844         DC32     0x40023844

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_1:
   \   00000000   0x40013808         DC32     0x40013808

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_2:
   \   00000000   0x40020000         DC32     0x40020000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_3:
   \   00000000   0x40020400         DC32     0x40020400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_4:
   \   00000000   0x40020800         DC32     0x40020800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_5:
   \   00000000   0x40020C00         DC32     0x40020c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_6:
   \   00000000   0x40021000         DC32     0x40021000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_7:
   \   00000000   0x40021400         DC32     0x40021400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_8:
   \   00000000   0x40021800         DC32     0x40021800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_9:
   \   00000000   0x40021C00         DC32     0x40021c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_10:
   \   00000000   0x40022000         DC32     0x40022000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_11:
   \   00000000   0x40022400         DC32     0x40022400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_12:
   \   00000000   0x40013C00         DC32     0x40013c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_13:
   \   00000000   0x40013C04         DC32     0x40013c04

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_14:
   \   00000000   0x40013C08         DC32     0x40013c08

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_15:
   \   00000000   0x40013C0C         DC32     0x40013c0c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_16:
   \   00000000   0x40013C14         DC32     0x40013c14
    521          
    522          /**
    523            * @}
    524            */
    525          
    526          
    527          /**
    528            * @}
    529            */
    530          
    531          #endif /* HAL_GPIO_MODULE_ENABLED */
    532          /**
    533            * @}
    534            */
    535          
    536          /**
    537            * @}
    538            */
    539          
    540          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      20   HAL_GPIO_DeInit
       0   HAL_GPIO_EXTI_Callback
       8   HAL_GPIO_EXTI_IRQHandler
         8   -> HAL_GPIO_EXTI_Callback
      20   HAL_GPIO_Init
       4   HAL_GPIO_LockPin
       0   HAL_GPIO_ReadPin
       0   HAL_GPIO_TogglePin
       0   HAL_GPIO_WritePin


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable2
       4  ??DataTable2_1
       4  ??DataTable2_10
       4  ??DataTable2_11
       4  ??DataTable2_12
       4  ??DataTable2_13
       4  ??DataTable2_14
       4  ??DataTable2_15
       4  ??DataTable2_16
       4  ??DataTable2_2
       4  ??DataTable2_3
       4  ??DataTable2_4
       4  ??DataTable2_5
       4  ??DataTable2_6
       4  ??DataTable2_7
       4  ??DataTable2_8
       4  ??DataTable2_9
     374  HAL_GPIO_DeInit
       2  HAL_GPIO_EXTI_Callback
      30  HAL_GPIO_EXTI_IRQHandler
     502  HAL_GPIO_Init
      50  HAL_GPIO_LockPin
      24  HAL_GPIO_ReadPin
      10  HAL_GPIO_TogglePin
      20  HAL_GPIO_WritePin

 
 1 080 bytes in section .text
 
 1 080 bytes of CODE memory

Errors: none
Warnings: none
