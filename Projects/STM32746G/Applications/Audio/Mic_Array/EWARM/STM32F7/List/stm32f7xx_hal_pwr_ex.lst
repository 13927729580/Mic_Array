###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.2.10312/W32 for ARM       04/Mar/2016  17:12:02
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_pwr_ex.c
#    Command line =  
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_pwr_ex.c
#        -D USE_HAL_DRIVER -D STM32F746xx -D USE_STM32746G_DISCO -D
#        USE_IOEXPANDER -D USE_USB_FS -lC
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
#        -lA
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
#        -o
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M7 -e --fpu=VFPv5_sp --dlib_config "D:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.3\arm\INC\c\DLib_Config_Full.h"
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\CMSIS\Device\ST\STM32F7xx\Include\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\STM32F7xx_HAL_Driver\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\STM32746G-Discovery\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\Components\Common\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Log\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Fonts\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\CPU\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_Device_Library\Core\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Core\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Class\MSC\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\drivers\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_Audio\Addons\PDM\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_Device_Library\Class\AUDIO\Inc\
#        -On --use_c++_inline --require_prototypes -I "D:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.3\arm\CMSIS\Include\" -D
#        ARM_MATH_CM7
#    List file    =  
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List\stm32f7xx_hal_pwr_ex.lst
#    Object file  =  
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj\stm32f7xx_hal_pwr_ex.o
#
###############################################################################

D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_pwr_ex.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f7xx_hal_pwr_ex.c
      4            * @author  MCD Application Team
      5            * @version V1.0.1
      6            * @date    25-June-2015
      7            * @brief   Extended PWR HAL module driver.
      8            *          This file provides firmware functions to manage the following 
      9            *          functionalities of PWR extension peripheral:           
     10            *           + Peripheral Extended features functions
     11            *         
     12            ******************************************************************************
     13            * @attention
     14            *
     15            * <h2><center>&copy; COPYRIGHT(c) 2015 STMicroelectronics</center></h2>
     16            *
     17            * Redistribution and use in source and binary forms, with or without modification,
     18            * are permitted provided that the following conditions are met:
     19            *   1. Redistributions of source code must retain the above copyright notice,
     20            *      this list of conditions and the following disclaimer.
     21            *   2. Redistributions in binary form must reproduce the above copyright notice,
     22            *      this list of conditions and the following disclaimer in the documentation
     23            *      and/or other materials provided with the distribution.
     24            *   3. Neither the name of STMicroelectronics nor the names of its contributors
     25            *      may be used to endorse or promote products derived from this software
     26            *      without specific prior written permission.
     27            *
     28            * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
     29            * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     30            * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     31            * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
     32            * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
     33            * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
     34            * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
     35            * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
     36            * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
     37            * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     38            *
     39            ******************************************************************************
     40            */ 
     41          
     42          /* Includes ------------------------------------------------------------------*/
     43          #include "stm32f7xx_hal.h"
     44          
     45          /** @addtogroup STM32F7xx_HAL_Driver
     46            * @{
     47            */
     48          
     49          /** @defgroup PWREx PWREx
     50            * @brief PWR HAL module driver
     51            * @{
     52            */
     53          
     54          #ifdef HAL_PWR_MODULE_ENABLED
     55          
     56          /* Private typedef -----------------------------------------------------------*/
     57          /* Private define ------------------------------------------------------------*/
     58          /** @addtogroup PWREx_Private_Constants
     59            * @{
     60            */    
     61          #define PWR_OVERDRIVE_TIMEOUT_VALUE  1000
     62          #define PWR_UDERDRIVE_TIMEOUT_VALUE  1000
     63          #define PWR_BKPREG_TIMEOUT_VALUE     1000
     64          #define PWR_VOSRDY_TIMEOUT_VALUE     1000
     65          /**
     66            * @}
     67            */
     68              
     69          /* Private macro -------------------------------------------------------------*/
     70          /* Private variables ---------------------------------------------------------*/
     71          /* Private function prototypes -----------------------------------------------*/
     72          /* Private functions ---------------------------------------------------------*/
     73          /** @defgroup PWREx_Exported_Functions PWREx Exported Functions
     74            *  @{
     75            */
     76          
     77          /** @defgroup PWREx_Exported_Functions_Group1 Peripheral Extended features functions 
     78            *  @brief Peripheral Extended features functions 
     79            *
     80          @verbatim   
     81          
     82           ===============================================================================
     83                           ##### Peripheral extended features functions #####
     84           ===============================================================================
     85          
     86              *** Main and Backup Regulators configuration ***
     87              ================================================
     88              [..] 
     89                (+) The backup domain includes 4 Kbytes of backup SRAM accessible only from 
     90                    the CPU, and address in 32-bit, 16-bit or 8-bit mode. Its content is 
     91                    retained even in Standby or VBAT mode when the low power backup regulator
     92                    is enabled. It can be considered as an internal EEPROM when VBAT is 
     93                    always present. You can use the HAL_PWREx_EnableBkUpReg() function to 
     94                    enable the low power backup regulator. 
     95          
     96                (+) When the backup domain is supplied by VDD (analog switch connected to VDD) 
     97                    the backup SRAM is powered from VDD which replaces the VBAT power supply to 
     98                    save battery life.
     99          
    100                (+) The backup SRAM is not mass erased by a tamper event. It is read 
    101                    protected to prevent confidential data, such as cryptographic private 
    102                    key, from being accessed. The backup SRAM can be erased only through 
    103                    the Flash interface when a protection level change from level 1 to 
    104                    level 0 is requested. 
    105                -@- Refer to the description of Read protection (RDP) in the Flash 
    106                    programming manual.
    107          
    108                (+) The main internal regulator can be configured to have a tradeoff between 
    109                    performance and power consumption when the device does not operate at 
    110                    the maximum frequency. This is done through __HAL_PWR_MAINREGULATORMODE_CONFIG() 
    111                    macro which configure VOS bit in PWR_CR register
    112                    
    113                  Refer to the product datasheets for more details.
    114          
    115              *** FLASH Power Down configuration ****
    116              =======================================
    117              [..] 
    118                (+) By setting the FPDS bit in the PWR_CR register by using the 
    119                    HAL_PWREx_EnableFlashPowerDown() function, the Flash memory also enters power 
    120                    down mode when the device enters Stop mode. When the Flash memory 
    121                    is in power down mode, an additional startup delay is incurred when 
    122                    waking up from Stop mode.
    123          
    124              *** Over-Drive and Under-Drive configuration ****
    125              =================================================
    126              [..]         
    127                 (+) In Run mode: the main regulator has 2 operating modes available:
    128                  (++) Normal mode: The CPU and core logic operate at maximum frequency at a given 
    129                       voltage scaling (scale 1, scale 2 or scale 3)
    130                  (++) Over-drive mode: This mode allows the CPU and the core logic to operate at a 
    131                      higher frequency than the normal mode for a given voltage scaling (scale 1,  
    132                      scale 2 or scale 3). This mode is enabled through HAL_PWREx_EnableOverDrive() function and
    133                      disabled by HAL_PWREx_DisableOverDrive() function, to enter or exit from Over-drive mode please follow 
    134                      the sequence described in Reference manual.
    135                       
    136                 (+) In Stop mode: the main regulator or low power regulator supplies a low power 
    137                     voltage to the 1.2V domain, thus preserving the content of registers 
    138                     and internal SRAM. 2 operating modes are available:
    139                   (++) Normal mode: the 1.2V domain is preserved in nominal leakage mode. This mode is only 
    140                        available when the main regulator or the low power regulator is used in Scale 3 or 
    141                        low voltage mode.
    142                   (++) Under-drive mode: the 1.2V domain is preserved in reduced leakage mode. This mode is only
    143                        available when the main regulator or the low power regulator is in low voltage mode.
    144          
    145          @endverbatim
    146            * @{
    147            */
    148          
    149          /**
    150            * @brief Enables the Backup Regulator.
    151            * @retval HAL status
    152            */

   \                                 In section .text, align 2, keep-with-next
    153          HAL_StatusTypeDef HAL_PWREx_EnableBkUpReg(void)
    154          {
   \                     HAL_PWREx_EnableBkUpReg: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    155            uint32_t tickstart = 0;
   \   00000002   0x2400             MOVS     R4,#+0
    156          
    157            /* Enable Backup regulator */
    158            PWR->CSR1 |= PWR_CSR1_BRE;
   \   00000004   0x....             LDR.N    R0,??DataTable12  ;; 0x40007004
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0xF450 0x7000      ORRS     R0,R0,#0x200
   \   0000000C   0x....             LDR.N    R1,??DataTable12  ;; 0x40007004
   \   0000000E   0x6008             STR      R0,[R1, #+0]
    159          
    160            /* Get tick */
    161            tickstart = HAL_GetTick();
   \   00000010   0x.... 0x....      BL       HAL_GetTick
   \   00000014   0x0004             MOVS     R4,R0
    162          
    163            /* Wait till Backup regulator ready flag is set */  
    164            while(__HAL_PWR_GET_FLAG(PWR_FLAG_BRR) == RESET)
   \                     ??HAL_PWREx_EnableBkUpReg_0: (+1)
   \   00000016   0x....             LDR.N    R0,??DataTable12  ;; 0x40007004
   \   00000018   0x6800             LDR      R0,[R0, #+0]
   \   0000001A   0x0700             LSLS     R0,R0,#+28
   \   0000001C   0xD407             BMI.N    ??HAL_PWREx_EnableBkUpReg_1
    165            {
    166              if((HAL_GetTick() - tickstart ) > PWR_BKPREG_TIMEOUT_VALUE)
   \   0000001E   0x.... 0x....      BL       HAL_GetTick
   \   00000022   0x1B00             SUBS     R0,R0,R4
   \   00000024   0xF5B0 0x7F7A      CMP      R0,#+1000
   \   00000028   0xD9F5             BLS.N    ??HAL_PWREx_EnableBkUpReg_0
    167              {
    168                return HAL_TIMEOUT;
   \   0000002A   0x2003             MOVS     R0,#+3
   \   0000002C   0xE000             B.N      ??HAL_PWREx_EnableBkUpReg_2
    169              } 
    170            }
    171            return HAL_OK;
   \                     ??HAL_PWREx_EnableBkUpReg_1: (+1)
   \   0000002E   0x2000             MOVS     R0,#+0
   \                     ??HAL_PWREx_EnableBkUpReg_2: (+1)
   \   00000030   0xBD10             POP      {R4,PC}          ;; return
    172          }
    173          
    174          /**
    175            * @brief Disables the Backup Regulator.
    176            * @retval HAL status
    177            */

   \                                 In section .text, align 2, keep-with-next
    178          HAL_StatusTypeDef HAL_PWREx_DisableBkUpReg(void)
    179          {
   \                     HAL_PWREx_DisableBkUpReg: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    180            uint32_t tickstart = 0;
   \   00000002   0x2400             MOVS     R4,#+0
    181            
    182            /* Disable Backup regulator */
    183            PWR->CSR1 &= (uint32_t)~((uint32_t)PWR_CSR1_BRE);
   \   00000004   0x....             LDR.N    R0,??DataTable12  ;; 0x40007004
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0xF430 0x7000      BICS     R0,R0,#0x200
   \   0000000C   0x....             LDR.N    R1,??DataTable12  ;; 0x40007004
   \   0000000E   0x6008             STR      R0,[R1, #+0]
    184          
    185            /* Get tick */
    186            tickstart = HAL_GetTick();
   \   00000010   0x.... 0x....      BL       HAL_GetTick
   \   00000014   0x0004             MOVS     R4,R0
    187          
    188            /* Wait till Backup regulator ready flag is set */  
    189            while(__HAL_PWR_GET_FLAG(PWR_FLAG_BRR) != RESET)
   \                     ??HAL_PWREx_DisableBkUpReg_0: (+1)
   \   00000016   0x....             LDR.N    R0,??DataTable12  ;; 0x40007004
   \   00000018   0x6800             LDR      R0,[R0, #+0]
   \   0000001A   0x0700             LSLS     R0,R0,#+28
   \   0000001C   0xD507             BPL.N    ??HAL_PWREx_DisableBkUpReg_1
    190            {
    191              if((HAL_GetTick() - tickstart ) > PWR_BKPREG_TIMEOUT_VALUE)
   \   0000001E   0x.... 0x....      BL       HAL_GetTick
   \   00000022   0x1B00             SUBS     R0,R0,R4
   \   00000024   0xF5B0 0x7F7A      CMP      R0,#+1000
   \   00000028   0xD9F5             BLS.N    ??HAL_PWREx_DisableBkUpReg_0
    192              {
    193                return HAL_TIMEOUT;
   \   0000002A   0x2003             MOVS     R0,#+3
   \   0000002C   0xE000             B.N      ??HAL_PWREx_DisableBkUpReg_2
    194              } 
    195            }
    196            return HAL_OK;
   \                     ??HAL_PWREx_DisableBkUpReg_1: (+1)
   \   0000002E   0x2000             MOVS     R0,#+0
   \                     ??HAL_PWREx_DisableBkUpReg_2: (+1)
   \   00000030   0xBD10             POP      {R4,PC}          ;; return
    197          }
    198          
    199          /**
    200            * @brief Enables the Flash Power Down in Stop mode.
    201            * @retval None
    202            */

   \                                 In section .text, align 2, keep-with-next
    203          void HAL_PWREx_EnableFlashPowerDown(void)
    204          {
    205            /* Enable the Flash Power Down */
    206            PWR->CR1 |= PWR_CR1_FPDS;
   \                     HAL_PWREx_EnableFlashPowerDown: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable12_1  ;; 0x40007000
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0xF450 0x7000      ORRS     R0,R0,#0x200
   \   00000008   0x....             LDR.N    R1,??DataTable12_1  ;; 0x40007000
   \   0000000A   0x6008             STR      R0,[R1, #+0]
    207          }
   \   0000000C   0x4770             BX       LR               ;; return
    208          
    209          /**
    210            * @brief Disables the Flash Power Down in Stop mode.
    211            * @retval None
    212            */

   \                                 In section .text, align 2, keep-with-next
    213          void HAL_PWREx_DisableFlashPowerDown(void)
    214          {
    215            /* Disable the Flash Power Down */
    216            PWR->CR1 &= (uint32_t)~((uint32_t)PWR_CR1_FPDS);
   \                     HAL_PWREx_DisableFlashPowerDown: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable12_1  ;; 0x40007000
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0xF430 0x7000      BICS     R0,R0,#0x200
   \   00000008   0x....             LDR.N    R1,??DataTable12_1  ;; 0x40007000
   \   0000000A   0x6008             STR      R0,[R1, #+0]
    217          }
   \   0000000C   0x4770             BX       LR               ;; return
    218          
    219          /**
    220            * @brief Enables Main Regulator low voltage mode.
    221            * @retval None
    222            */

   \                                 In section .text, align 2, keep-with-next
    223          void HAL_PWREx_EnableMainRegulatorLowVoltage(void)
    224          {
    225            /* Enable Main regulator low voltage */
    226            PWR->CR1 |= PWR_CR1_MRUDS;
   \                     HAL_PWREx_EnableMainRegulatorLowVoltage: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable12_1  ;; 0x40007000
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0xF450 0x6000      ORRS     R0,R0,#0x800
   \   00000008   0x....             LDR.N    R1,??DataTable12_1  ;; 0x40007000
   \   0000000A   0x6008             STR      R0,[R1, #+0]
    227          }
   \   0000000C   0x4770             BX       LR               ;; return
    228          
    229          /**
    230            * @brief Disables Main Regulator low voltage mode.
    231            * @retval None
    232            */

   \                                 In section .text, align 2, keep-with-next
    233          void HAL_PWREx_DisableMainRegulatorLowVoltage(void)
    234          {  
    235            /* Disable Main regulator low voltage */
    236            PWR->CR1 &= (uint32_t)~((uint32_t)PWR_CR1_MRUDS);
   \                     HAL_PWREx_DisableMainRegulatorLowVoltage: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable12_1  ;; 0x40007000
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0xF430 0x6000      BICS     R0,R0,#0x800
   \   00000008   0x....             LDR.N    R1,??DataTable12_1  ;; 0x40007000
   \   0000000A   0x6008             STR      R0,[R1, #+0]
    237          }
   \   0000000C   0x4770             BX       LR               ;; return
    238          
    239          /**
    240            * @brief Enables Low Power Regulator low voltage mode.
    241            * @retval None
    242            */

   \                                 In section .text, align 2, keep-with-next
    243          void HAL_PWREx_EnableLowRegulatorLowVoltage(void)
    244          {
    245            /* Enable low power regulator */
    246            PWR->CR1 |= PWR_CR1_LPUDS;
   \                     HAL_PWREx_EnableLowRegulatorLowVoltage: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable12_1  ;; 0x40007000
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0xF450 0x6080      ORRS     R0,R0,#0x400
   \   00000008   0x....             LDR.N    R1,??DataTable12_1  ;; 0x40007000
   \   0000000A   0x6008             STR      R0,[R1, #+0]
    247          }
   \   0000000C   0x4770             BX       LR               ;; return
    248          
    249          /**
    250            * @brief Disables Low Power Regulator low voltage mode.
    251            * @retval None
    252            */

   \                                 In section .text, align 2, keep-with-next
    253          void HAL_PWREx_DisableLowRegulatorLowVoltage(void)
    254          {
    255            /* Disable low power regulator */
    256            PWR->CR1 &= (uint32_t)~((uint32_t)PWR_CR1_LPUDS);
   \                     HAL_PWREx_DisableLowRegulatorLowVoltage: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable12_1  ;; 0x40007000
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0xF430 0x6080      BICS     R0,R0,#0x400
   \   00000008   0x....             LDR.N    R1,??DataTable12_1  ;; 0x40007000
   \   0000000A   0x6008             STR      R0,[R1, #+0]
    257          }
   \   0000000C   0x4770             BX       LR               ;; return
    258          
    259          /**
    260            * @brief  Activates the Over-Drive mode.
    261            * @note   This mode allows the CPU and the core logic to operate at a higher frequency
    262            *         than the normal mode for a given voltage scaling (scale 1, scale 2 or scale 3).   
    263            * @note   It is recommended to enter or exit Over-drive mode when the application is not running 
    264            *         critical tasks and when the system clock source is either HSI or HSE. 
    265            *         During the Over-drive switch activation, no peripheral clocks should be enabled.   
    266            *         The peripheral clocks must be enabled once the Over-drive mode is activated.   
    267            * @retval HAL status
    268            */

   \                                 In section .text, align 2, keep-with-next
    269          HAL_StatusTypeDef HAL_PWREx_EnableOverDrive(void)
    270          {
   \                     HAL_PWREx_EnableOverDrive: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
    271            uint32_t tickstart = 0;
   \   00000004   0x2400             MOVS     R4,#+0
    272          
    273            __HAL_RCC_PWR_CLK_ENABLE();
   \   00000006   0x....             LDR.N    R0,??DataTable12_2  ;; 0x40023840
   \   00000008   0x6800             LDR      R0,[R0, #+0]
   \   0000000A   0xF050 0x5080      ORRS     R0,R0,#0x10000000
   \   0000000E   0x....             LDR.N    R1,??DataTable12_2  ;; 0x40023840
   \   00000010   0x6008             STR      R0,[R1, #+0]
   \   00000012   0x....             LDR.N    R0,??DataTable12_2  ;; 0x40023840
   \   00000014   0x6800             LDR      R0,[R0, #+0]
   \   00000016   0xF010 0x5080      ANDS     R0,R0,#0x10000000
   \   0000001A   0x9000             STR      R0,[SP, #+0]
   \   0000001C   0x9800             LDR      R0,[SP, #+0]
    274            
    275            /* Enable the Over-drive to extend the clock frequency to 216 MHz */
    276            __HAL_PWR_OVERDRIVE_ENABLE();
   \   0000001E   0x....             LDR.N    R0,??DataTable12_1  ;; 0x40007000
   \   00000020   0x6800             LDR      R0,[R0, #+0]
   \   00000022   0xF450 0x3080      ORRS     R0,R0,#0x10000
   \   00000026   0x....             LDR.N    R1,??DataTable12_1  ;; 0x40007000
   \   00000028   0x6008             STR      R0,[R1, #+0]
    277          
    278            /* Get tick */
    279            tickstart = HAL_GetTick();
   \   0000002A   0x.... 0x....      BL       HAL_GetTick
   \   0000002E   0x0004             MOVS     R4,R0
    280          
    281            while(!__HAL_PWR_GET_FLAG(PWR_FLAG_ODRDY))
   \                     ??HAL_PWREx_EnableOverDrive_0: (+1)
   \   00000030   0x....             LDR.N    R0,??DataTable12  ;; 0x40007004
   \   00000032   0x6800             LDR      R0,[R0, #+0]
   \   00000034   0x03C0             LSLS     R0,R0,#+15
   \   00000036   0xD407             BMI.N    ??HAL_PWREx_EnableOverDrive_1
    282            {
    283              if((HAL_GetTick() - tickstart ) > PWR_OVERDRIVE_TIMEOUT_VALUE)
   \   00000038   0x.... 0x....      BL       HAL_GetTick
   \   0000003C   0x1B00             SUBS     R0,R0,R4
   \   0000003E   0xF5B0 0x7F7A      CMP      R0,#+1000
   \   00000042   0xD9F5             BLS.N    ??HAL_PWREx_EnableOverDrive_0
    284              {
    285                return HAL_TIMEOUT;
   \   00000044   0x2003             MOVS     R0,#+3
   \   00000046   0xE015             B.N      ??HAL_PWREx_EnableOverDrive_2
    286              }
    287            }
    288            
    289            /* Enable the Over-drive switch */
    290            __HAL_PWR_OVERDRIVESWITCHING_ENABLE();
   \                     ??HAL_PWREx_EnableOverDrive_1: (+1)
   \   00000048   0x....             LDR.N    R0,??DataTable12_1  ;; 0x40007000
   \   0000004A   0x6800             LDR      R0,[R0, #+0]
   \   0000004C   0xF450 0x3000      ORRS     R0,R0,#0x20000
   \   00000050   0x....             LDR.N    R1,??DataTable12_1  ;; 0x40007000
   \   00000052   0x6008             STR      R0,[R1, #+0]
    291          
    292            /* Get tick */
    293            tickstart = HAL_GetTick();
   \   00000054   0x.... 0x....      BL       HAL_GetTick
   \   00000058   0x0004             MOVS     R4,R0
    294          
    295            while(!__HAL_PWR_GET_FLAG(PWR_FLAG_ODSWRDY))
   \                     ??HAL_PWREx_EnableOverDrive_3: (+1)
   \   0000005A   0x....             LDR.N    R0,??DataTable12  ;; 0x40007004
   \   0000005C   0x6800             LDR      R0,[R0, #+0]
   \   0000005E   0x0380             LSLS     R0,R0,#+14
   \   00000060   0xD407             BMI.N    ??HAL_PWREx_EnableOverDrive_4
    296            {
    297              if((HAL_GetTick() - tickstart ) > PWR_OVERDRIVE_TIMEOUT_VALUE)
   \   00000062   0x.... 0x....      BL       HAL_GetTick
   \   00000066   0x1B00             SUBS     R0,R0,R4
   \   00000068   0xF5B0 0x7F7A      CMP      R0,#+1000
   \   0000006C   0xD9F5             BLS.N    ??HAL_PWREx_EnableOverDrive_3
    298              {
    299                return HAL_TIMEOUT;
   \   0000006E   0x2003             MOVS     R0,#+3
   \   00000070   0xE000             B.N      ??HAL_PWREx_EnableOverDrive_2
    300              }
    301            } 
    302            return HAL_OK;
   \                     ??HAL_PWREx_EnableOverDrive_4: (+1)
   \   00000072   0x2000             MOVS     R0,#+0
   \                     ??HAL_PWREx_EnableOverDrive_2: (+1)
   \   00000074   0xBD16             POP      {R1,R2,R4,PC}    ;; return
    303          }
    304          
    305          /**
    306            * @brief  Deactivates the Over-Drive mode.
    307            * @note   This mode allows the CPU and the core logic to operate at a higher frequency
    308            *         than the normal mode for a given voltage scaling (scale 1, scale 2 or scale 3).    
    309            * @note   It is recommended to enter or exit Over-drive mode when the application is not running 
    310            *         critical tasks and when the system clock source is either HSI or HSE. 
    311            *         During the Over-drive switch activation, no peripheral clocks should be enabled.   
    312            *         The peripheral clocks must be enabled once the Over-drive mode is activated.
    313            * @retval HAL status
    314            */

   \                                 In section .text, align 2, keep-with-next
    315          HAL_StatusTypeDef HAL_PWREx_DisableOverDrive(void)
    316          {
   \                     HAL_PWREx_DisableOverDrive: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
    317            uint32_t tickstart = 0;
   \   00000004   0x2400             MOVS     R4,#+0
    318            
    319            __HAL_RCC_PWR_CLK_ENABLE();
   \   00000006   0x....             LDR.N    R0,??DataTable12_2  ;; 0x40023840
   \   00000008   0x6800             LDR      R0,[R0, #+0]
   \   0000000A   0xF050 0x5080      ORRS     R0,R0,#0x10000000
   \   0000000E   0x....             LDR.N    R1,??DataTable12_2  ;; 0x40023840
   \   00000010   0x6008             STR      R0,[R1, #+0]
   \   00000012   0x....             LDR.N    R0,??DataTable12_2  ;; 0x40023840
   \   00000014   0x6800             LDR      R0,[R0, #+0]
   \   00000016   0xF010 0x5080      ANDS     R0,R0,#0x10000000
   \   0000001A   0x9000             STR      R0,[SP, #+0]
   \   0000001C   0x9800             LDR      R0,[SP, #+0]
    320              
    321            /* Disable the Over-drive switch */
    322            __HAL_PWR_OVERDRIVESWITCHING_DISABLE();
   \   0000001E   0x....             LDR.N    R0,??DataTable12_1  ;; 0x40007000
   \   00000020   0x6800             LDR      R0,[R0, #+0]
   \   00000022   0xF430 0x3000      BICS     R0,R0,#0x20000
   \   00000026   0x....             LDR.N    R1,??DataTable12_1  ;; 0x40007000
   \   00000028   0x6008             STR      R0,[R1, #+0]
    323            
    324            /* Get tick */
    325            tickstart = HAL_GetTick();
   \   0000002A   0x.... 0x....      BL       HAL_GetTick
   \   0000002E   0x0004             MOVS     R4,R0
    326           
    327            while(__HAL_PWR_GET_FLAG(PWR_FLAG_ODSWRDY))
   \                     ??HAL_PWREx_DisableOverDrive_0: (+1)
   \   00000030   0x....             LDR.N    R0,??DataTable12  ;; 0x40007004
   \   00000032   0x6800             LDR      R0,[R0, #+0]
   \   00000034   0x0380             LSLS     R0,R0,#+14
   \   00000036   0xD507             BPL.N    ??HAL_PWREx_DisableOverDrive_1
    328            {
    329              if((HAL_GetTick() - tickstart ) > PWR_OVERDRIVE_TIMEOUT_VALUE)
   \   00000038   0x.... 0x....      BL       HAL_GetTick
   \   0000003C   0x1B00             SUBS     R0,R0,R4
   \   0000003E   0xF5B0 0x7F7A      CMP      R0,#+1000
   \   00000042   0xD9F5             BLS.N    ??HAL_PWREx_DisableOverDrive_0
    330              {
    331                return HAL_TIMEOUT;
   \   00000044   0x2003             MOVS     R0,#+3
   \   00000046   0xE015             B.N      ??HAL_PWREx_DisableOverDrive_2
    332              }
    333            } 
    334            
    335            /* Disable the Over-drive */
    336            __HAL_PWR_OVERDRIVE_DISABLE();
   \                     ??HAL_PWREx_DisableOverDrive_1: (+1)
   \   00000048   0x....             LDR.N    R0,??DataTable12_1  ;; 0x40007000
   \   0000004A   0x6800             LDR      R0,[R0, #+0]
   \   0000004C   0xF430 0x3080      BICS     R0,R0,#0x10000
   \   00000050   0x....             LDR.N    R1,??DataTable12_1  ;; 0x40007000
   \   00000052   0x6008             STR      R0,[R1, #+0]
    337          
    338            /* Get tick */
    339            tickstart = HAL_GetTick();
   \   00000054   0x.... 0x....      BL       HAL_GetTick
   \   00000058   0x0004             MOVS     R4,R0
    340          
    341            while(__HAL_PWR_GET_FLAG(PWR_FLAG_ODRDY))
   \                     ??HAL_PWREx_DisableOverDrive_3: (+1)
   \   0000005A   0x....             LDR.N    R0,??DataTable12  ;; 0x40007004
   \   0000005C   0x6800             LDR      R0,[R0, #+0]
   \   0000005E   0x03C0             LSLS     R0,R0,#+15
   \   00000060   0xD507             BPL.N    ??HAL_PWREx_DisableOverDrive_4
    342            {
    343              if((HAL_GetTick() - tickstart ) > PWR_OVERDRIVE_TIMEOUT_VALUE)
   \   00000062   0x.... 0x....      BL       HAL_GetTick
   \   00000066   0x1B00             SUBS     R0,R0,R4
   \   00000068   0xF5B0 0x7F7A      CMP      R0,#+1000
   \   0000006C   0xD9F5             BLS.N    ??HAL_PWREx_DisableOverDrive_3
    344              {
    345                return HAL_TIMEOUT;
   \   0000006E   0x2003             MOVS     R0,#+3
   \   00000070   0xE000             B.N      ??HAL_PWREx_DisableOverDrive_2
    346              }
    347            }
    348            
    349            return HAL_OK;
   \                     ??HAL_PWREx_DisableOverDrive_4: (+1)
   \   00000072   0x2000             MOVS     R0,#+0
   \                     ??HAL_PWREx_DisableOverDrive_2: (+1)
   \   00000074   0xBD16             POP      {R1,R2,R4,PC}    ;; return
    350          }
    351          
    352          /**
    353            * @brief  Enters in Under-Drive STOP mode.
    354            * 
    355            * @note    This mode can be selected only when the Under-Drive is already active 
    356            *   
    357            * @note    This mode is enabled only with STOP low power mode.
    358            *          In this mode, the 1.2V domain is preserved in reduced leakage mode. This 
    359            *          mode is only available when the main regulator or the low power regulator 
    360            *          is in low voltage mode
    361            *        
    362            * @note   If the Under-drive mode was enabled, it is automatically disabled after 
    363            *         exiting Stop mode. 
    364            *         When the voltage regulator operates in Under-drive mode, an additional  
    365            *         startup delay is induced when waking up from Stop mode.
    366            *                    
    367            * @note   In Stop mode, all I/O pins keep the same state as in Run mode.
    368            *   
    369            * @note   When exiting Stop mode by issuing an interrupt or a wakeup event, 
    370            *         the HSI RC oscillator is selected as system clock.
    371            *           
    372            * @note   When the voltage regulator operates in low power mode, an additional 
    373            *         startup delay is incurred when waking up from Stop mode. 
    374            *         By keeping the internal regulator ON during Stop mode, the consumption 
    375            *         is higher although the startup time is reduced.
    376            *     
    377            * @param  Regulator: specifies the regulator state in STOP mode.
    378            *          This parameter can be one of the following values:
    379            *            @arg PWR_MAINREGULATOR_UNDERDRIVE_ON:  Main Regulator in under-drive mode 
    380            *                 and Flash memory in power-down when the device is in Stop under-drive mode
    381            *            @arg PWR_LOWPOWERREGULATOR_UNDERDRIVE_ON:  Low Power Regulator in under-drive mode 
    382            *                and Flash memory in power-down when the device is in Stop under-drive mode
    383            * @param  STOPEntry: specifies if STOP mode in entered with WFI or WFE instruction.
    384            *          This parameter can be one of the following values:
    385            *            @arg PWR_SLEEPENTRY_WFI: enter STOP mode with WFI instruction
    386            *            @arg PWR_SLEEPENTRY_WFE: enter STOP mode with WFE instruction
    387            * @retval None
    388            */

   \                                 In section .text, align 2, keep-with-next
    389          HAL_StatusTypeDef HAL_PWREx_EnterUnderDriveSTOPMode(uint32_t Regulator, uint8_t STOPEntry)
    390          {
   \                     HAL_PWREx_EnterUnderDriveSTOPMode: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    391            uint32_t tempreg = 0;
   \   00000006   0x2600             MOVS     R6,#+0
    392            uint32_t tickstart = 0;
   \   00000008   0x2700             MOVS     R7,#+0
    393            
    394            /* Check the parameters */
    395            assert_param(IS_PWR_REGULATOR_UNDERDRIVE(Regulator));
    396            assert_param(IS_PWR_STOP_ENTRY(STOPEntry));
    397            
    398            /* Enable Power ctrl clock */
    399            __HAL_RCC_PWR_CLK_ENABLE();
   \   0000000A   0x....             LDR.N    R0,??DataTable12_2  ;; 0x40023840
   \   0000000C   0x6800             LDR      R0,[R0, #+0]
   \   0000000E   0xF050 0x5080      ORRS     R0,R0,#0x10000000
   \   00000012   0x....             LDR.N    R1,??DataTable12_2  ;; 0x40023840
   \   00000014   0x6008             STR      R0,[R1, #+0]
   \   00000016   0x....             LDR.N    R0,??DataTable12_2  ;; 0x40023840
   \   00000018   0x6800             LDR      R0,[R0, #+0]
   \   0000001A   0xF010 0x5080      ANDS     R0,R0,#0x10000000
   \   0000001E   0x9000             STR      R0,[SP, #+0]
   \   00000020   0x9800             LDR      R0,[SP, #+0]
    400            /* Enable the Under-drive Mode ---------------------------------------------*/
    401            /* Clear Under-drive flag */
    402            __HAL_PWR_CLEAR_ODRUDR_FLAG();
   \   00000022   0x....             LDR.N    R0,??DataTable12  ;; 0x40007004
   \   00000024   0x6800             LDR      R0,[R0, #+0]
   \   00000026   0xF450 0x2040      ORRS     R0,R0,#0xC0000
   \   0000002A   0x....             LDR.N    R1,??DataTable12  ;; 0x40007004
   \   0000002C   0x6008             STR      R0,[R1, #+0]
    403            
    404            /* Enable the Under-drive */ 
    405            __HAL_PWR_UNDERDRIVE_ENABLE();
   \   0000002E   0x....             LDR.N    R0,??DataTable12_1  ;; 0x40007000
   \   00000030   0x6800             LDR      R0,[R0, #+0]
   \   00000032   0xF450 0x2040      ORRS     R0,R0,#0xC0000
   \   00000036   0x....             LDR.N    R1,??DataTable12_1  ;; 0x40007000
   \   00000038   0x6008             STR      R0,[R1, #+0]
    406          
    407            /* Get tick */
    408            tickstart = HAL_GetTick();
   \   0000003A   0x.... 0x....      BL       HAL_GetTick
   \   0000003E   0x0007             MOVS     R7,R0
    409          
    410            /* Wait for UnderDrive mode is ready */
    411            while(__HAL_PWR_GET_FLAG(PWR_FLAG_UDRDY))
   \                     ??HAL_PWREx_EnterUnderDriveSTOPMode_0: (+1)
   \   00000040   0x....             LDR.N    R0,??DataTable12  ;; 0x40007004
   \   00000042   0x6800             LDR      R0,[R0, #+0]
   \   00000044   0xF410 0x2040      ANDS     R0,R0,#0xC0000
   \   00000048   0xF5B0 0x2F40      CMP      R0,#+786432
   \   0000004C   0xD107             BNE.N    ??HAL_PWREx_EnterUnderDriveSTOPMode_1
    412            {
    413              if((HAL_GetTick() - tickstart ) > PWR_UDERDRIVE_TIMEOUT_VALUE)
   \   0000004E   0x.... 0x....      BL       HAL_GetTick
   \   00000052   0x1BC0             SUBS     R0,R0,R7
   \   00000054   0xF5B0 0x7F7A      CMP      R0,#+1000
   \   00000058   0xD9F2             BLS.N    ??HAL_PWREx_EnterUnderDriveSTOPMode_0
    414              {
    415                return HAL_TIMEOUT;
   \   0000005A   0x2003             MOVS     R0,#+3
   \   0000005C   0xE01A             B.N      ??HAL_PWREx_EnterUnderDriveSTOPMode_2
    416              }
    417            }
    418            
    419            /* Select the regulator state in STOP mode ---------------------------------*/
    420            tempreg = PWR->CR1;
   \                     ??HAL_PWREx_EnterUnderDriveSTOPMode_1: (+1)
   \   0000005E   0x....             LDR.N    R0,??DataTable12_1  ;; 0x40007000
   \   00000060   0x6800             LDR      R0,[R0, #+0]
   \   00000062   0x0006             MOVS     R6,R0
    421            /* Clear PDDS, LPDS, MRLUDS and LPLUDS bits */
    422            tempreg &= (uint32_t)~(PWR_CR1_PDDS | PWR_CR1_LPDS | PWR_CR1_LPUDS | PWR_CR1_MRUDS);
   \   00000064   0x....             LDR.N    R0,??DataTable12_3  ;; 0xfffff3fc
   \   00000066   0x4006             ANDS     R6,R0,R6
    423            
    424            /* Set LPDS, MRLUDS and LPLUDS bits according to PWR_Regulator value */
    425            tempreg |= Regulator;
   \   00000068   0x4326             ORRS     R6,R4,R6
    426            
    427            /* Store the new value */
    428            PWR->CR1 = tempreg;
   \   0000006A   0x....             LDR.N    R0,??DataTable12_1  ;; 0x40007000
   \   0000006C   0x6006             STR      R6,[R0, #+0]
    429            
    430            /* Set SLEEPDEEP bit of Cortex System Control Register */
    431            SCB->SCR |= SCB_SCR_SLEEPDEEP_Msk;
   \   0000006E   0x....             LDR.N    R0,??DataTable12_4  ;; 0xe000ed10
   \   00000070   0x6800             LDR      R0,[R0, #+0]
   \   00000072   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   00000076   0x....             LDR.N    R1,??DataTable12_4  ;; 0xe000ed10
   \   00000078   0x6008             STR      R0,[R1, #+0]
    432            
    433            /* Select STOP mode entry --------------------------------------------------*/
    434            if(STOPEntry == PWR_SLEEPENTRY_WFI)
   \   0000007A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000007C   0x2D01             CMP      R5,#+1
   \   0000007E   0xD101             BNE.N    ??HAL_PWREx_EnterUnderDriveSTOPMode_3
    435            {   
    436              /* Request Wait For Interrupt */
    437              __WFI();
   \   00000080   0xBF30             WFI      
   \   00000082   0xE000             B.N      ??HAL_PWREx_EnterUnderDriveSTOPMode_4
    438            }
    439            else
    440            {
    441              /* Request Wait For Event */
    442              __WFE();
   \                     ??HAL_PWREx_EnterUnderDriveSTOPMode_3: (+1)
   \   00000084   0xBF20             WFE      
    443            }
    444            /* Reset SLEEPDEEP bit of Cortex System Control Register */
    445            SCB->SCR &= (uint32_t)~((uint32_t)SCB_SCR_SLEEPDEEP_Msk);
   \                     ??HAL_PWREx_EnterUnderDriveSTOPMode_4: (+1)
   \   00000086   0x....             LDR.N    R0,??DataTable12_4  ;; 0xe000ed10
   \   00000088   0x6800             LDR      R0,[R0, #+0]
   \   0000008A   0xF030 0x0004      BICS     R0,R0,#0x4
   \   0000008E   0x....             LDR.N    R1,??DataTable12_4  ;; 0xe000ed10
   \   00000090   0x6008             STR      R0,[R1, #+0]
    446          
    447            return HAL_OK;  
   \   00000092   0x2000             MOVS     R0,#+0
   \                     ??HAL_PWREx_EnterUnderDriveSTOPMode_2: (+1)
   \   00000094   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    448          }
    449          
    450          /**
    451            * @brief Returns Voltage Scaling Range.
    452            * @retval VOS bit field (PWR_REGULATOR_VOLTAGE_SCALE1, PWR_REGULATOR_VOLTAGE_SCALE2 or 
    453            *            PWR_REGULATOR_VOLTAGE_SCALE3)PWR_REGULATOR_VOLTAGE_SCALE1
    454            */  

   \                                 In section .text, align 2, keep-with-next
    455          uint32_t HAL_PWREx_GetVoltageRange(void)
    456          {
    457            return  (PWR->CR1 & PWR_CR1_VOS);
   \                     HAL_PWREx_GetVoltageRange: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable12_1  ;; 0x40007000
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0xF410 0x4040      ANDS     R0,R0,#0xC000
   \   00000008   0x4770             BX       LR               ;; return
    458          }
    459          
    460          /**
    461            * @brief Configures the main internal regulator output voltage.
    462            * @param  VoltageScaling: specifies the regulator output voltage to achieve
    463            *         a tradeoff between performance and power consumption.
    464            *          This parameter can be one of the following values:
    465            *            @arg PWR_REGULATOR_VOLTAGE_SCALE1: Regulator voltage output range 1 mode,
    466            *                                                typical output voltage at 1.4 V,  
    467            *                                                system frequency up to 216 MHz.
    468            *            @arg PWR_REGULATOR_VOLTAGE_SCALE2: Regulator voltage output range 2 mode,
    469            *                                                typical output voltage at 1.2 V,                
    470            *                                                system frequency up to 180 MHz.
    471            *            @arg PWR_REGULATOR_VOLTAGE_SCALE3: Regulator voltage output range 2 mode,
    472            *                                                typical output voltage at 1.00 V,                
    473            *                                                system frequency up to 151 MHz.
    474            * @note To update the system clock frequency(SYSCLK):
    475            *        - Set the HSI or HSE as system clock frequency using the HAL_RCC_ClockConfig().
    476            *        - Call the HAL_RCC_OscConfig() to configure the PLL.
    477            *        - Call HAL_PWREx_ConfigVoltageScaling() API to adjust the voltage scale.
    478            *        - Set the new system clock frequency using the HAL_RCC_ClockConfig().
    479            * @note The scale can be modified only when the HSI or HSE clock source is selected 
    480            *        as system clock source, otherwise the API returns HAL_ERROR.  
    481            * @note When the PLL is OFF, the voltage scale 3 is automatically selected and the VOS bits
    482            *       value in the PWR_CR1 register are not taken in account.
    483            * @note This API forces the PLL state ON to allow the possibility to configure the voltage scale 1 or 2.
    484            * @note The new voltage scale is active only when the PLL is ON.  
    485            * @retval HAL Status
    486            */

   \                                 In section .text, align 2, keep-with-next
    487          HAL_StatusTypeDef HAL_PWREx_ControlVoltageScaling(uint32_t VoltageScaling)
    488          {
   \                     HAL_PWREx_ControlVoltageScaling: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    489            uint32_t tickstart = 0;
   \   00000004   0x2500             MOVS     R5,#+0
    490          
    491            assert_param(IS_PWR_REGULATOR_VOLTAGE(VoltageScaling));
    492          
    493            /* Enable Power ctrl clock */
    494            __HAL_RCC_PWR_CLK_ENABLE();
   \   00000006   0x....             LDR.N    R0,??DataTable12_2  ;; 0x40023840
   \   00000008   0x6800             LDR      R0,[R0, #+0]
   \   0000000A   0xF050 0x5080      ORRS     R0,R0,#0x10000000
   \   0000000E   0x....             LDR.N    R1,??DataTable12_2  ;; 0x40023840
   \   00000010   0x6008             STR      R0,[R1, #+0]
   \   00000012   0x....             LDR.N    R0,??DataTable12_2  ;; 0x40023840
   \   00000014   0x6800             LDR      R0,[R0, #+0]
   \   00000016   0xF010 0x5080      ANDS     R0,R0,#0x10000000
   \   0000001A   0x9000             STR      R0,[SP, #+0]
   \   0000001C   0x9800             LDR      R0,[SP, #+0]
    495          
    496            /* Check if the PLL is used as system clock or not */
    497            if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL)
   \   0000001E   0x....             LDR.N    R0,??DataTable12_5  ;; 0x40023808
   \   00000020   0x6800             LDR      R0,[R0, #+0]
   \   00000022   0xF010 0x000C      ANDS     R0,R0,#0xC
   \   00000026   0x2808             CMP      R0,#+8
   \   00000028   0xD045             BEQ.N    ??HAL_PWREx_ControlVoltageScaling_0
    498            {
    499              /* Disable the main PLL */
    500              __HAL_RCC_PLL_DISABLE();
   \   0000002A   0x....             LDR.N    R0,??DataTable12_6  ;; 0x40023800
   \   0000002C   0x6800             LDR      R0,[R0, #+0]
   \   0000002E   0xF030 0x7080      BICS     R0,R0,#0x1000000
   \   00000032   0x....             LDR.N    R1,??DataTable12_6  ;; 0x40023800
   \   00000034   0x6008             STR      R0,[R1, #+0]
    501              
    502              /* Get Start Tick */
    503              tickstart = HAL_GetTick();    
   \   00000036   0x.... 0x....      BL       HAL_GetTick
   \   0000003A   0x0005             MOVS     R5,R0
    504              /* Wait till PLL is disabled */  
    505              while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
   \                     ??HAL_PWREx_ControlVoltageScaling_1: (+1)
   \   0000003C   0x....             LDR.N    R0,??DataTable12_6  ;; 0x40023800
   \   0000003E   0x6800             LDR      R0,[R0, #+0]
   \   00000040   0x0180             LSLS     R0,R0,#+6
   \   00000042   0xD506             BPL.N    ??HAL_PWREx_ControlVoltageScaling_2
    506              {
    507                if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
   \   00000044   0x.... 0x....      BL       HAL_GetTick
   \   00000048   0x1B40             SUBS     R0,R0,R5
   \   0000004A   0x2865             CMP      R0,#+101
   \   0000004C   0xD3F6             BCC.N    ??HAL_PWREx_ControlVoltageScaling_1
    508                {
    509                  return HAL_TIMEOUT;
   \   0000004E   0x2003             MOVS     R0,#+3
   \   00000050   0xE032             B.N      ??HAL_PWREx_ControlVoltageScaling_3
    510                }
    511              }
    512              
    513              /* Set Range */
    514              __HAL_PWR_VOLTAGESCALING_CONFIG(VoltageScaling);
   \                     ??HAL_PWREx_ControlVoltageScaling_2: (+1)
   \   00000052   0x....             LDR.N    R0,??DataTable12_1  ;; 0x40007000
   \   00000054   0x6800             LDR      R0,[R0, #+0]
   \   00000056   0xF430 0x4040      BICS     R0,R0,#0xC000
   \   0000005A   0x4320             ORRS     R0,R4,R0
   \   0000005C   0x....             LDR.N    R1,??DataTable12_1  ;; 0x40007000
   \   0000005E   0x6008             STR      R0,[R1, #+0]
   \   00000060   0x....             LDR.N    R0,??DataTable12_1  ;; 0x40007000
   \   00000062   0x6800             LDR      R0,[R0, #+0]
   \   00000064   0xF410 0x4040      ANDS     R0,R0,#0xC000
   \   00000068   0x9000             STR      R0,[SP, #+0]
   \   0000006A   0x9800             LDR      R0,[SP, #+0]
    515              
    516              /* Enable the main PLL */
    517              __HAL_RCC_PLL_ENABLE();
   \   0000006C   0x....             LDR.N    R0,??DataTable12_6  ;; 0x40023800
   \   0000006E   0x6800             LDR      R0,[R0, #+0]
   \   00000070   0xF050 0x7080      ORRS     R0,R0,#0x1000000
   \   00000074   0x....             LDR.N    R1,??DataTable12_6  ;; 0x40023800
   \   00000076   0x6008             STR      R0,[R1, #+0]
    518              
    519              /* Get Start Tick */
    520              tickstart = HAL_GetTick();
   \   00000078   0x.... 0x....      BL       HAL_GetTick
   \   0000007C   0x0005             MOVS     R5,R0
    521              /* Wait till PLL is ready */  
    522              while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
   \                     ??HAL_PWREx_ControlVoltageScaling_4: (+1)
   \   0000007E   0x....             LDR.N    R0,??DataTable12_6  ;; 0x40023800
   \   00000080   0x6800             LDR      R0,[R0, #+0]
   \   00000082   0x0180             LSLS     R0,R0,#+6
   \   00000084   0xD406             BMI.N    ??HAL_PWREx_ControlVoltageScaling_5
    523              {
    524                if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
   \   00000086   0x.... 0x....      BL       HAL_GetTick
   \   0000008A   0x1B40             SUBS     R0,R0,R5
   \   0000008C   0x2865             CMP      R0,#+101
   \   0000008E   0xD3F6             BCC.N    ??HAL_PWREx_ControlVoltageScaling_4
    525                {
    526                  return HAL_TIMEOUT;
   \   00000090   0x2003             MOVS     R0,#+3
   \   00000092   0xE011             B.N      ??HAL_PWREx_ControlVoltageScaling_3
    527                } 
    528              }
    529              
    530              /* Get Start Tick */
    531              tickstart = HAL_GetTick();
   \                     ??HAL_PWREx_ControlVoltageScaling_5: (+1)
   \   00000094   0x.... 0x....      BL       HAL_GetTick
   \   00000098   0x0005             MOVS     R5,R0
    532              while((__HAL_PWR_GET_FLAG(PWR_FLAG_VOSRDY) == RESET))
   \                     ??HAL_PWREx_ControlVoltageScaling_6: (+1)
   \   0000009A   0x....             LDR.N    R0,??DataTable12  ;; 0x40007004
   \   0000009C   0x6800             LDR      R0,[R0, #+0]
   \   0000009E   0x0440             LSLS     R0,R0,#+17
   \   000000A0   0xD407             BMI.N    ??HAL_PWREx_ControlVoltageScaling_7
    533              {
    534                if((HAL_GetTick() - tickstart ) > PWR_VOSRDY_TIMEOUT_VALUE)
   \   000000A2   0x.... 0x....      BL       HAL_GetTick
   \   000000A6   0x1B40             SUBS     R0,R0,R5
   \   000000A8   0xF5B0 0x7F7A      CMP      R0,#+1000
   \   000000AC   0xD9F5             BLS.N    ??HAL_PWREx_ControlVoltageScaling_6
    535                {
    536                  return HAL_TIMEOUT;
   \   000000AE   0x2003             MOVS     R0,#+3
   \   000000B0   0xE002             B.N      ??HAL_PWREx_ControlVoltageScaling_3
    537                } 
    538              }
    539            }
    540            else
    541            {
    542              return HAL_ERROR;
    543            }
    544            return HAL_OK;
   \                     ??HAL_PWREx_ControlVoltageScaling_7: (+1)
   \   000000B2   0x2000             MOVS     R0,#+0
   \   000000B4   0xE000             B.N      ??HAL_PWREx_ControlVoltageScaling_3
   \                     ??HAL_PWREx_ControlVoltageScaling_0: (+1)
   \   000000B6   0x2001             MOVS     R0,#+1
   \                     ??HAL_PWREx_ControlVoltageScaling_3: (+1)
   \   000000B8   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    545          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12:
   \   00000000   0x40007004         DC32     0x40007004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_1:
   \   00000000   0x40007000         DC32     0x40007000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_2:
   \   00000000   0x40023840         DC32     0x40023840

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_3:
   \   00000000   0xFFFFF3FC         DC32     0xfffff3fc

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_4:
   \   00000000   0xE000ED10         DC32     0xe000ed10

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_5:
   \   00000000   0x40023808         DC32     0x40023808

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_6:
   \   00000000   0x40023800         DC32     0x40023800
    546          
    547          /**
    548            * @}
    549            */
    550          
    551          /**
    552            * @}
    553            */
    554          
    555          #endif /* HAL_PWR_MODULE_ENABLED */
    556          /**
    557            * @}
    558            */
    559          
    560          /**
    561            * @}
    562            */
    563          
    564          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   HAL_PWREx_ControlVoltageScaling
        16   -> HAL_GetTick
       8   HAL_PWREx_DisableBkUpReg
         8   -> HAL_GetTick
       0   HAL_PWREx_DisableFlashPowerDown
       0   HAL_PWREx_DisableLowRegulatorLowVoltage
       0   HAL_PWREx_DisableMainRegulatorLowVoltage
      16   HAL_PWREx_DisableOverDrive
        16   -> HAL_GetTick
       8   HAL_PWREx_EnableBkUpReg
         8   -> HAL_GetTick
       0   HAL_PWREx_EnableFlashPowerDown
       0   HAL_PWREx_EnableLowRegulatorLowVoltage
       0   HAL_PWREx_EnableMainRegulatorLowVoltage
      16   HAL_PWREx_EnableOverDrive
        16   -> HAL_GetTick
      24   HAL_PWREx_EnterUnderDriveSTOPMode
        24   -> HAL_GetTick
       0   HAL_PWREx_GetVoltageRange


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable12
       4  ??DataTable12_1
       4  ??DataTable12_2
       4  ??DataTable12_3
       4  ??DataTable12_4
       4  ??DataTable12_5
       4  ??DataTable12_6
     186  HAL_PWREx_ControlVoltageScaling
      50  HAL_PWREx_DisableBkUpReg
      14  HAL_PWREx_DisableFlashPowerDown
      14  HAL_PWREx_DisableLowRegulatorLowVoltage
      14  HAL_PWREx_DisableMainRegulatorLowVoltage
     118  HAL_PWREx_DisableOverDrive
      50  HAL_PWREx_EnableBkUpReg
      14  HAL_PWREx_EnableFlashPowerDown
      14  HAL_PWREx_EnableLowRegulatorLowVoltage
      14  HAL_PWREx_EnableMainRegulatorLowVoltage
     118  HAL_PWREx_EnableOverDrive
     150  HAL_PWREx_EnterUnderDriveSTOPMode
      10  HAL_PWREx_GetVoltageRange

 
 794 bytes in section .text
 
 794 bytes of CODE memory

Errors: none
Warnings: none
