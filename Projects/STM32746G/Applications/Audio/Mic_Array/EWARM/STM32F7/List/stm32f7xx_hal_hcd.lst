###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.2.10312/W32 for ARM       19/Feb/2016  17:44:14
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_hcd.c
#    Command line =  
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_hcd.c
#        -D USE_HAL_DRIVER -D STM32F746xx -D USE_STM32746G_DISCO -D
#        USE_IOEXPANDER -D USE_USB_FS -lC
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
#        -lA
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
#        -o
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M7 -e --fpu=VFPv5_sp --dlib_config "D:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.3\arm\INC\c\DLib_Config_Full.h"
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\CMSIS\Device\ST\STM32F7xx\Include\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\STM32F7xx_HAL_Driver\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\STM32746G-Discovery\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\Components\Common\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Log\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Fonts\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\CPU\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_Device_Library\Core\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Core\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Class\MSC\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\drivers\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_Audio\Addons\PDM\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_Device_Library\Class\AUDIO\Inc\
#        -On --use_c++_inline --require_prototypes -I "D:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.3\arm\CMSIS\Include\" -D
#        ARM_MATH_CM7
#    List file    =  
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List\stm32f7xx_hal_hcd.lst
#    Object file  =  
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj\stm32f7xx_hal_hcd.o
#
###############################################################################

D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_hcd.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f7xx_hal_hcd.c
      4            * @author  MCD Application Team
      5            * @version V1.0.1
      6            * @date    25-June-2015
      7            * @brief   HCD HAL module driver.
      8            *          This file provides firmware functions to manage the following 
      9            *          functionalities of the USB Peripheral Controller:
     10            *           + Initialization and de-initialization functions
     11            *           + IO operation functions
     12            *           + Peripheral Control functions 
     13            *           + Peripheral State functions
     14            *         
     15            @verbatim
     16            ==============================================================================
     17                              ##### How to use this driver #####
     18            ==============================================================================
     19            [..]
     20              (#)Declare a HCD_HandleTypeDef handle structure, for example:
     21                 HCD_HandleTypeDef  hhcd;
     22                  
     23              (#)Fill parameters of Init structure in HCD handle
     24            
     25              (#)Call HAL_HCD_Init() API to initialize the HCD peripheral (Core, Host core, ...) 
     26          
     27              (#)Initialize the HCD low level resources through the HAL_HCD_MspInit() API:
     28                  (##) Enable the HCD/USB Low Level interface clock using the following macros
     29                       (+++) __OTGFS-OTG_CLK_ENABLE() or __OTGHS-OTG_CLK_ENABLE()
     30                       (+++) __OTGHSULPI_CLK_ENABLE() For High Speed Mode
     31                     
     32                  (##) Initialize the related GPIO clocks
     33                  (##) Configure HCD pin-out
     34                  (##) Configure HCD NVIC interrupt
     35              
     36              (#)Associate the Upper USB Host stack to the HAL HCD Driver:
     37                  (##) hhcd.pData = phost;
     38          
     39              (#)Enable HCD transmission and reception:
     40                  (##) HAL_HCD_Start();
     41          
     42            @endverbatim
     43            ******************************************************************************
     44            * @attention
     45            *
     46            * <h2><center>&copy; COPYRIGHT(c) 2015 STMicroelectronics</center></h2>
     47            *
     48            * Redistribution and use in source and binary forms, with or without modification,
     49            * are permitted provided that the following conditions are met:
     50            *   1. Redistributions of source code must retain the above copyright notice,
     51            *      this list of conditions and the following disclaimer.
     52            *   2. Redistributions in binary form must reproduce the above copyright notice,
     53            *      this list of conditions and the following disclaimer in the documentation
     54            *      and/or other materials provided with the distribution.
     55            *   3. Neither the name of STMicroelectronics nor the names of its contributors
     56            *      may be used to endorse or promote products derived from this software
     57            *      without specific prior written permission.
     58            *
     59            * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
     60            * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     61            * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     62            * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
     63            * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
     64            * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
     65            * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
     66            * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
     67            * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
     68            * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     69            *
     70            ******************************************************************************
     71            */ 
     72          
     73          /* Includes ------------------------------------------------------------------*/
     74          #include "stm32f7xx_hal.h"
     75          
     76          /** @addtogroup STM32F7xx_HAL_Driver
     77            * @{
     78            */
     79          
     80          /** @addtogroup HCD
     81            * @{
     82            */
     83          
     84          #ifdef HAL_HCD_MODULE_ENABLED
     85          
     86          /* Private typedef -----------------------------------------------------------*/
     87          /* Private define ------------------------------------------------------------*/
     88          /* Private macro -------------------------------------------------------------*/
     89          /* Private variables ---------------------------------------------------------*/
     90          /* Private function ----------------------------------------------------------*/
     91          /** @addtogroup HCD_Private_Functions
     92            * @{
     93            */
     94          static void HCD_HC_IN_IRQHandler(HCD_HandleTypeDef *hhcd, uint8_t chnum);
     95          static void HCD_HC_OUT_IRQHandler(HCD_HandleTypeDef *hhcd, uint8_t chnum); 
     96          static void HCD_RXQLVL_IRQHandler(HCD_HandleTypeDef *hhcd);
     97          static void HCD_Port_IRQHandler(HCD_HandleTypeDef *hhcd);
     98          /**
     99            * @}
    100            */
    101          
    102          /* Exported functions --------------------------------------------------------*/
    103          /** @addtogroup HCD_Exported_Functions
    104            * @{
    105            */
    106          
    107          /** @addtogroup HCD_Exported_Functions_Group1
    108           *  @brief   Initialization and de-initialization functions
    109           *
    110          @verbatim    
    111           ===============================================================================
    112                    ##### Initialization and de-initialization functions #####
    113           ===============================================================================
    114              [..]  This section provides functions allowing to:
    115           
    116          @endverbatim
    117            * @{
    118            */
    119          
    120          /**
    121            * @brief  Initialize the host driver
    122            * @param  hhcd: HCD handle
    123            * @retval HAL status
    124            */

   \                                 In section .text, align 2, keep-with-next
    125          HAL_StatusTypeDef HAL_HCD_Init(HCD_HandleTypeDef *hhcd)
    126          { 
   \                     HAL_HCD_Init: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB08A             SUB      SP,SP,#+40
   \   00000004   0x0004             MOVS     R4,R0
    127            /* Check the HCD handle allocation */
    128            if(hhcd == NULL)
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD101             BNE.N    ??HAL_HCD_Init_0
    129            {
    130              return HAL_ERROR;
   \   0000000A   0x2001             MOVS     R0,#+1
   \   0000000C   0xE024             B.N      ??HAL_HCD_Init_1
    131            }
    132            
    133            /* Check the parameters */
    134            assert_param(IS_HCD_ALL_INSTANCE(hhcd->Instance));
    135          
    136            hhcd->State = HAL_HCD_STATE_BUSY;
   \                     ??HAL_HCD_Init_0: (+1)
   \   0000000E   0x2003             MOVS     R0,#+3
   \   00000010   0xF884 0x028D      STRB     R0,[R4, #+653]
    137            
    138            /* Init the low level hardware : GPIO, CLOCK, NVIC... */
    139            HAL_HCD_MspInit(hhcd);
   \   00000014   0x0020             MOVS     R0,R4
   \   00000016   0x.... 0x....      BL       HAL_HCD_MspInit
    140          
    141            /* Disable the Interrupts */
    142           __HAL_HCD_DISABLE(hhcd);
   \   0000001A   0x6820             LDR      R0,[R4, #+0]
   \   0000001C   0x.... 0x....      BL       USB_DisableGlobalInt
    143           
    144           /*Init the Core (common init.) */
    145           USB_CoreInit(hhcd->Instance, hhcd->Init);
   \   00000020   0x1D21             ADDS     R1,R4,#+4
   \   00000022   0xB083             SUB      SP,SP,#+12
   \   00000024   0x4668             MOV      R0,SP
   \   00000026   0x2230             MOVS     R2,#+48
   \   00000028   0x.... 0x....      BL       __aeabi_memcpy4
   \   0000002C   0xBC0E             POP      {R1-R3}
   \   0000002E   0x6820             LDR      R0,[R4, #+0]
   \   00000030   0x.... 0x....      BL       USB_CoreInit
    146           
    147           /* Force Host Mode*/
    148           USB_SetCurrentMode(hhcd->Instance , USB_OTG_HOST_MODE);
   \   00000034   0x2101             MOVS     R1,#+1
   \   00000036   0x6820             LDR      R0,[R4, #+0]
   \   00000038   0x.... 0x....      BL       USB_SetCurrentMode
    149           
    150           /* Init Host */
    151           USB_HostInit(hhcd->Instance, hhcd->Init);
   \   0000003C   0x1D21             ADDS     R1,R4,#+4
   \   0000003E   0xB083             SUB      SP,SP,#+12
   \   00000040   0x4668             MOV      R0,SP
   \   00000042   0x2230             MOVS     R2,#+48
   \   00000044   0x.... 0x....      BL       __aeabi_memcpy4
   \   00000048   0xBC0E             POP      {R1-R3}
   \   0000004A   0x6820             LDR      R0,[R4, #+0]
   \   0000004C   0x.... 0x....      BL       USB_HostInit
    152           
    153           hhcd->State= HAL_HCD_STATE_READY;
   \   00000050   0x2001             MOVS     R0,#+1
   \   00000052   0xF884 0x028D      STRB     R0,[R4, #+653]
    154           
    155           return HAL_OK;
   \   00000056   0x2000             MOVS     R0,#+0
   \                     ??HAL_HCD_Init_1: (+1)
   \   00000058   0xB00A             ADD      SP,SP,#+40
   \   0000005A   0xBD10             POP      {R4,PC}          ;; return
    156          }
    157          
    158          /**
    159            * @brief  Initialize a host channel
    160            * @param  hhcd: HCD handle
    161            * @param  ch_num: Channel number.
    162            *         This parameter can be a value from 1 to 15
    163            * @param  epnum: Endpoint number.
    164            *          This parameter can be a value from 1 to 15
    165            * @param  dev_address : Current device address
    166            *          This parameter can be a value from 0 to 255
    167            * @param  speed: Current device speed.
    168            *          This parameter can be one of these values:
    169            *            HCD_SPEED_HIGH: High speed mode,
    170            *            HCD_SPEED_FULL: Full speed mode,
    171            *            HCD_SPEED_LOW: Low speed mode
    172            * @param  ep_type: Endpoint Type.
    173            *          This parameter can be one of these values:
    174            *            EP_TYPE_CTRL: Control type,
    175            *            EP_TYPE_ISOC: Isochronous type,
    176            *            EP_TYPE_BULK: Bulk type,
    177            *            EP_TYPE_INTR: Interrupt type
    178            * @param  mps: Max Packet Size.
    179            *          This parameter can be a value from 0 to32K
    180            * @retval HAL status
    181            */

   \                                 In section .text, align 2, keep-with-next
    182          HAL_StatusTypeDef HAL_HCD_HC_Init(HCD_HandleTypeDef *hhcd,  
    183                                            uint8_t ch_num,
    184                                            uint8_t epnum,
    185                                            uint8_t dev_address,
    186                                            uint8_t speed,
    187                                            uint8_t ep_type,
    188                                            uint16_t mps)
    189          {
   \                     HAL_HCD_HC_Init: (+1)
   \   00000000   0xE92D 0x4FFE      PUSH     {R1-R11,LR}
   \   00000004   0x0007             MOVS     R7,R0
   \   00000006   0x4688             MOV      R8,R1
   \   00000008   0x4693             MOV      R11,R2
   \   0000000A   0x4699             MOV      R9,R3
   \   0000000C   0x9C0C             LDR      R4,[SP, #+48]
   \   0000000E   0x9D0D             LDR      R5,[SP, #+52]
   \   00000010   0x9E0E             LDR      R6,[SP, #+56]
    190            HAL_StatusTypeDef status = HAL_OK;
   \   00000012   0xF05F 0x0A00      MOVS     R10,#+0
    191            
    192            __HAL_LOCK(hhcd); 
   \   00000016   0xF897 0x028C      LDRB     R0,[R7, #+652]
   \   0000001A   0x2801             CMP      R0,#+1
   \   0000001C   0xD101             BNE.N    ??HAL_HCD_HC_Init_0
   \   0000001E   0x2002             MOVS     R0,#+2
   \   00000020   0xE04F             B.N      ??HAL_HCD_HC_Init_1
   \                     ??HAL_HCD_HC_Init_0: (+1)
   \   00000022   0x2001             MOVS     R0,#+1
   \   00000024   0xF887 0x028C      STRB     R0,[R7, #+652]
    193            
    194            hhcd->hc[ch_num].dev_addr = dev_address;
   \   00000028   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000002C   0x2028             MOVS     R0,#+40
   \   0000002E   0xFB00 0x7008      MLA      R0,R0,R8,R7
   \   00000032   0xF880 0x9034      STRB     R9,[R0, #+52]
    195            hhcd->hc[ch_num].max_packet = mps;
   \   00000036   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000003A   0x2028             MOVS     R0,#+40
   \   0000003C   0xFB00 0x7008      MLA      R0,R0,R8,R7
   \   00000040   0x8786             STRH     R6,[R0, #+60]
    196            hhcd->hc[ch_num].ch_num = ch_num;
   \   00000042   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000046   0x2028             MOVS     R0,#+40
   \   00000048   0xFB00 0x7008      MLA      R0,R0,R8,R7
   \   0000004C   0xF880 0x8035      STRB     R8,[R0, #+53]
    197            hhcd->hc[ch_num].ep_type = ep_type;
   \   00000050   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000054   0x2028             MOVS     R0,#+40
   \   00000056   0xFB00 0x7008      MLA      R0,R0,R8,R7
   \   0000005A   0xF880 0x503B      STRB     R5,[R0, #+59]
    198            hhcd->hc[ch_num].ep_num = epnum & 0x7F;
   \   0000005E   0xF01B 0x007F      ANDS     R0,R11,#0x7F
   \   00000062   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000066   0x2128             MOVS     R1,#+40
   \   00000068   0xFB01 0x7108      MLA      R1,R1,R8,R7
   \   0000006C   0xF881 0x0036      STRB     R0,[R1, #+54]
    199            hhcd->hc[ch_num].ep_is_in = ((epnum & 0x80) == 0x80);
   \   00000070   0x4658             MOV      R0,R11
   \   00000072   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000074   0x09C0             LSRS     R0,R0,#+7
   \   00000076   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000007A   0x2128             MOVS     R1,#+40
   \   0000007C   0xFB01 0x7108      MLA      R1,R1,R8,R7
   \   00000080   0xF881 0x0037      STRB     R0,[R1, #+55]
    200            hhcd->hc[ch_num].speed = speed;
   \   00000084   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000088   0x2028             MOVS     R0,#+40
   \   0000008A   0xFB00 0x7008      MLA      R0,R0,R8,R7
   \   0000008E   0xF880 0x4038      STRB     R4,[R0, #+56]
    201          
    202            status =  USB_HC_Init(hhcd->Instance, 
    203                                  ch_num,
    204                                  epnum,
    205                                  dev_address,
    206                                  speed,
    207                                  ep_type,
    208                                  mps);
   \   00000092   0x0030             MOVS     R0,R6
   \   00000094   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000096   0x9002             STR      R0,[SP, #+8]
   \   00000098   0x0028             MOVS     R0,R5
   \   0000009A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000009C   0x9001             STR      R0,[SP, #+4]
   \   0000009E   0x0020             MOVS     R0,R4
   \   000000A0   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000A2   0x9000             STR      R0,[SP, #+0]
   \   000000A4   0x464B             MOV      R3,R9
   \   000000A6   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   000000A8   0x465A             MOV      R2,R11
   \   000000AA   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   000000AC   0x4641             MOV      R1,R8
   \   000000AE   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000B0   0x6838             LDR      R0,[R7, #+0]
   \   000000B2   0x.... 0x....      BL       USB_HC_Init
   \   000000B6   0x4682             MOV      R10,R0
    209            __HAL_UNLOCK(hhcd); 
   \   000000B8   0x2000             MOVS     R0,#+0
   \   000000BA   0xF887 0x028C      STRB     R0,[R7, #+652]
    210            
    211            return status;
   \   000000BE   0x4650             MOV      R0,R10
   \   000000C0   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??HAL_HCD_HC_Init_1: (+1)
   \   000000C2   0xE8BD 0x8FFE      POP      {R1-R11,PC}      ;; return
    212          }
    213          
    214          /**
    215            * @brief  Halt a host channel
    216            * @param  hhcd: HCD handle
    217            * @param  ch_num: Channel number.
    218            *         This parameter can be a value from 1 to 15
    219            * @retval HAL status
    220            */

   \                                 In section .text, align 2, keep-with-next
    221          HAL_StatusTypeDef HAL_HCD_HC_Halt(HCD_HandleTypeDef *hhcd, uint8_t ch_num)
    222          {
   \                     HAL_HCD_HC_Halt: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    223            HAL_StatusTypeDef status = HAL_OK;
   \   00000006   0x2600             MOVS     R6,#+0
    224            
    225            __HAL_LOCK(hhcd);   
   \   00000008   0xF894 0x028C      LDRB     R0,[R4, #+652]
   \   0000000C   0x2801             CMP      R0,#+1
   \   0000000E   0xD101             BNE.N    ??HAL_HCD_HC_Halt_0
   \   00000010   0x2002             MOVS     R0,#+2
   \   00000012   0xE00C             B.N      ??HAL_HCD_HC_Halt_1
   \                     ??HAL_HCD_HC_Halt_0: (+1)
   \   00000014   0x2001             MOVS     R0,#+1
   \   00000016   0xF884 0x028C      STRB     R0,[R4, #+652]
    226            USB_HC_Halt(hhcd->Instance, ch_num);   
   \   0000001A   0x0029             MOVS     R1,R5
   \   0000001C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000001E   0x6820             LDR      R0,[R4, #+0]
   \   00000020   0x.... 0x....      BL       USB_HC_Halt
    227            __HAL_UNLOCK(hhcd);
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0xF884 0x028C      STRB     R0,[R4, #+652]
    228            
    229            return status;
   \   0000002A   0x0030             MOVS     R0,R6
   \   0000002C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??HAL_HCD_HC_Halt_1: (+1)
   \   0000002E   0xBD70             POP      {R4-R6,PC}       ;; return
    230          }
    231          
    232          /**
    233            * @brief  DeInitialize the host driver
    234            * @param  hhcd: HCD handle
    235            * @retval HAL status
    236            */

   \                                 In section .text, align 2, keep-with-next
    237          HAL_StatusTypeDef HAL_HCD_DeInit(HCD_HandleTypeDef *hhcd)
    238          {
   \                     HAL_HCD_DeInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    239            /* Check the HCD handle allocation */
    240            if(hhcd == NULL)
   \   00000004   0x2C00             CMP      R4,#+0
   \   00000006   0xD101             BNE.N    ??HAL_HCD_DeInit_0
    241            {
    242              return HAL_ERROR;
   \   00000008   0x2001             MOVS     R0,#+1
   \   0000000A   0xE00C             B.N      ??HAL_HCD_DeInit_1
    243            }
    244            
    245            hhcd->State = HAL_HCD_STATE_BUSY;
   \                     ??HAL_HCD_DeInit_0: (+1)
   \   0000000C   0x2003             MOVS     R0,#+3
   \   0000000E   0xF884 0x028D      STRB     R0,[R4, #+653]
    246            
    247            /* DeInit the low level hardware */
    248            HAL_HCD_MspDeInit(hhcd);
   \   00000012   0x0020             MOVS     R0,R4
   \   00000014   0x.... 0x....      BL       HAL_HCD_MspDeInit
    249            
    250             __HAL_HCD_DISABLE(hhcd);
   \   00000018   0x6820             LDR      R0,[R4, #+0]
   \   0000001A   0x.... 0x....      BL       USB_DisableGlobalInt
    251            
    252            hhcd->State = HAL_HCD_STATE_RESET; 
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0xF884 0x028D      STRB     R0,[R4, #+653]
    253            
    254            return HAL_OK;
   \   00000024   0x2000             MOVS     R0,#+0
   \                     ??HAL_HCD_DeInit_1: (+1)
   \   00000026   0xBD10             POP      {R4,PC}          ;; return
    255          }
    256          
    257          /**
    258            * @brief  Initializes the HCD MSP.
    259            * @param  hhcd: HCD handle
    260            * @retval None
    261            */

   \                                 In section .text, align 2, keep-with-next
    262          __weak void  HAL_HCD_MspInit(HCD_HandleTypeDef *hhcd)
    263          {
    264            /* NOTE : This function Should not be modified, when the callback is needed,
    265                      the HAL_HCD_MspInit could be implemented in the user file
    266             */
    267          }
   \                     HAL_HCD_MspInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    268          
    269          /**
    270            * @brief  DeInitializes HCD MSP.
    271            * @param  hhcd: HCD handle
    272            * @retval None
    273            */

   \                                 In section .text, align 2, keep-with-next
    274          __weak void  HAL_HCD_MspDeInit(HCD_HandleTypeDef *hhcd)
    275          {
    276            /* NOTE : This function Should not be modified, when the callback is needed,
    277                      the HAL_HCD_MspDeInit could be implemented in the user file
    278             */
    279          }
   \                     HAL_HCD_MspDeInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    280          
    281          /**
    282            * @}
    283            */
    284          
    285          /** @addtogroup HCD_Exported_Functions_Group2
    286            *  @brief   HCD IO operation functions
    287            *
    288          @verbatim
    289           ===============================================================================
    290                                ##### IO operation functions #####
    291           ===============================================================================
    292              This subsection provides a set of functions allowing to manage the USB Host Data 
    293              Transfer
    294                 
    295          @endverbatim
    296            * @{
    297            */
    298            
    299          /**                                
    300            * @brief  Submit a new URB for processing 
    301            * @param  hhcd: HCD handle
    302            * @param  ch_num: Channel number.
    303            *         This parameter can be a value from 1 to 15
    304            * @param  direction: Channel number.
    305            *          This parameter can be one of these values:
    306            *           0 : Output / 1 : Input
    307            * @param  ep_type: Endpoint Type.
    308            *          This parameter can be one of these values:
    309            *            EP_TYPE_CTRL: Control type/
    310            *            EP_TYPE_ISOC: Isochronous type/
    311            *            EP_TYPE_BULK: Bulk type/
    312            *            EP_TYPE_INTR: Interrupt type/
    313            * @param  token: Endpoint Type.
    314            *          This parameter can be one of these values:
    315            *            0: HC_PID_SETUP / 1: HC_PID_DATA1
    316            * @param  pbuff: pointer to URB data
    317            * @param  length: Length of URB data
    318            * @param  do_ping: activate do ping protocol (for high speed only).
    319            *          This parameter can be one of these values:
    320            *           0 : do ping inactive / 1 : do ping active 
    321            * @retval HAL status
    322            */

   \                                 In section .text, align 2, keep-with-next
    323          HAL_StatusTypeDef HAL_HCD_HC_SubmitRequest(HCD_HandleTypeDef *hhcd,
    324                                                      uint8_t ch_num, 
    325                                                      uint8_t direction ,
    326                                                      uint8_t ep_type,  
    327                                                      uint8_t token, 
    328                                                      uint8_t* pbuff, 
    329                                                      uint16_t length,
    330                                                      uint8_t do_ping) 
    331          {
   \                     HAL_HCD_HC_SubmitRequest: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x0007             MOVS     R7,R0
   \   00000006   0x4688             MOV      R8,R1
   \   00000008   0x4691             MOV      R9,R2
   \   0000000A   0x469A             MOV      R10,R3
   \   0000000C   0x9C0A             LDR      R4,[SP, #+40]
   \   0000000E   0xF8DD 0xB02C      LDR      R11,[SP, #+44]
   \   00000012   0x9D0C             LDR      R5,[SP, #+48]
   \   00000014   0x9E0D             LDR      R6,[SP, #+52]
    332            hhcd->hc[ch_num].ep_is_in = direction;
   \   00000016   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000001A   0x2028             MOVS     R0,#+40
   \   0000001C   0xFB00 0x7008      MLA      R0,R0,R8,R7
   \   00000020   0xF880 0x9037      STRB     R9,[R0, #+55]
    333            hhcd->hc[ch_num].ep_type  = ep_type; 
   \   00000024   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000028   0x2028             MOVS     R0,#+40
   \   0000002A   0xFB00 0x7008      MLA      R0,R0,R8,R7
   \   0000002E   0xF880 0xA03B      STRB     R10,[R0, #+59]
    334            
    335            if(token == 0)
   \   00000032   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000034   0x2C00             CMP      R4,#+0
   \   00000036   0xD108             BNE.N    ??HAL_HCD_HC_SubmitRequest_0
    336            {
    337              hhcd->hc[ch_num].data_pid = HC_PID_SETUP;
   \   00000038   0x2003             MOVS     R0,#+3
   \   0000003A   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000003E   0x2128             MOVS     R1,#+40
   \   00000040   0xFB01 0x7108      MLA      R1,R1,R8,R7
   \   00000044   0xF881 0x003E      STRB     R0,[R1, #+62]
   \   00000048   0xE007             B.N      ??HAL_HCD_HC_SubmitRequest_1
    338            }
    339            else
    340            {
    341              hhcd->hc[ch_num].data_pid = HC_PID_DATA1;
   \                     ??HAL_HCD_HC_SubmitRequest_0: (+1)
   \   0000004A   0x2002             MOVS     R0,#+2
   \   0000004C   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000050   0x2128             MOVS     R1,#+40
   \   00000052   0xFB01 0x7108      MLA      R1,R1,R8,R7
   \   00000056   0xF881 0x003E      STRB     R0,[R1, #+62]
    342            }
    343            
    344            /* Manage Data Toggle */
    345            switch(ep_type)
   \                     ??HAL_HCD_HC_SubmitRequest_1: (+1)
   \   0000005A   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   0000005E   0xF1BA 0x0F00      CMP      R10,#+0
   \   00000062   0xD009             BEQ.N    ??HAL_HCD_HC_SubmitRequest_2
   \   00000064   0xF1BA 0x0F02      CMP      R10,#+2
   \   00000068   0xD044             BEQ.N    ??HAL_HCD_HC_SubmitRequest_3
   \   0000006A   0xF0C0 0x80C9      BCC.W    ??HAL_HCD_HC_SubmitRequest_4
   \   0000006E   0xF1BA 0x0F03      CMP      R10,#+3
   \   00000072   0xF000 0x808A      BEQ.W    ??HAL_HCD_HC_SubmitRequest_5
   \   00000076   0xE0CB             B.N      ??HAL_HCD_HC_SubmitRequest_6
    346            {
    347            case EP_TYPE_CTRL:
    348              if((token == 1) && (direction == 0)) /*send data */
   \                     ??HAL_HCD_HC_SubmitRequest_2: (+1)
   \   00000078   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000007A   0x2C01             CMP      R4,#+1
   \   0000007C   0xD139             BNE.N    ??HAL_HCD_HC_SubmitRequest_7
   \   0000007E   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   00000082   0xF1B9 0x0F00      CMP      R9,#+0
   \   00000086   0xD134             BNE.N    ??HAL_HCD_HC_SubmitRequest_7
    349              {
    350                if ( length == 0 )
   \   00000088   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000008A   0x2D00             CMP      R5,#+0
   \   0000008C   0xD107             BNE.N    ??HAL_HCD_HC_SubmitRequest_8
    351                { /* For Status OUT stage, Length==0, Status Out PID = 1 */
    352                  hhcd->hc[ch_num].toggle_out = 1;
   \   0000008E   0x2001             MOVS     R0,#+1
   \   00000090   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000094   0x2128             MOVS     R1,#+40
   \   00000096   0xFB01 0x7108      MLA      R1,R1,R8,R7
   \   0000009A   0xF881 0x004D      STRB     R0,[R1, #+77]
    353                }
    354                
    355                /* Set the Data Toggle bit as per the Flag */
    356                if ( hhcd->hc[ch_num].toggle_out == 0)
   \                     ??HAL_HCD_HC_SubmitRequest_8: (+1)
   \   0000009E   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000000A2   0x2028             MOVS     R0,#+40
   \   000000A4   0xFB00 0x7008      MLA      R0,R0,R8,R7
   \   000000A8   0xF890 0x004D      LDRB     R0,[R0, #+77]
   \   000000AC   0x2800             CMP      R0,#+0
   \   000000AE   0xD108             BNE.N    ??HAL_HCD_HC_SubmitRequest_9
    357                { /* Put the PID 0 */
    358                  hhcd->hc[ch_num].data_pid = HC_PID_DATA0;    
   \   000000B0   0x2000             MOVS     R0,#+0
   \   000000B2   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000000B6   0x2128             MOVS     R1,#+40
   \   000000B8   0xFB01 0x7108      MLA      R1,R1,R8,R7
   \   000000BC   0xF881 0x003E      STRB     R0,[R1, #+62]
   \   000000C0   0xE007             B.N      ??HAL_HCD_HC_SubmitRequest_10
    359                }
    360                else
    361                { /* Put the PID 1 */
    362                  hhcd->hc[ch_num].data_pid = HC_PID_DATA1 ;
   \                     ??HAL_HCD_HC_SubmitRequest_9: (+1)
   \   000000C2   0x2002             MOVS     R0,#+2
   \   000000C4   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000000C8   0x2128             MOVS     R1,#+40
   \   000000CA   0xFB01 0x7108      MLA      R1,R1,R8,R7
   \   000000CE   0xF881 0x003E      STRB     R0,[R1, #+62]
    363                }
    364                if(hhcd->hc[ch_num].urb_state  != URB_NOTREADY)
   \                     ??HAL_HCD_HC_SubmitRequest_10: (+1)
   \   000000D2   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000000D6   0x2028             MOVS     R0,#+40
   \   000000D8   0xFB00 0x7008      MLA      R0,R0,R8,R7
   \   000000DC   0xF890 0x0058      LDRB     R0,[R0, #+88]
   \   000000E0   0x2802             CMP      R0,#+2
   \   000000E2   0xD006             BEQ.N    ??HAL_HCD_HC_SubmitRequest_7
    365                {
    366                  hhcd->hc[ch_num].do_ping = do_ping;
   \   000000E4   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000000E8   0x2028             MOVS     R0,#+40
   \   000000EA   0xFB00 0x7008      MLA      R0,R0,R8,R7
   \   000000EE   0xF880 0x6039      STRB     R6,[R0, #+57]
    367                }
    368              }
    369              break;
   \                     ??HAL_HCD_HC_SubmitRequest_7: (+1)
   \   000000F2   0xE08D             B.N      ??HAL_HCD_HC_SubmitRequest_6
    370            
    371            case EP_TYPE_BULK:
    372              if(direction == 0)
   \                     ??HAL_HCD_HC_SubmitRequest_3: (+1)
   \   000000F4   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   000000F8   0xF1B9 0x0F00      CMP      R9,#+0
   \   000000FC   0xD12A             BNE.N    ??HAL_HCD_HC_SubmitRequest_11
    373              {
    374                /* Set the Data Toggle bit as per the Flag */
    375                if ( hhcd->hc[ch_num].toggle_out == 0)
   \   000000FE   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000102   0x2028             MOVS     R0,#+40
   \   00000104   0xFB00 0x7008      MLA      R0,R0,R8,R7
   \   00000108   0xF890 0x004D      LDRB     R0,[R0, #+77]
   \   0000010C   0x2800             CMP      R0,#+0
   \   0000010E   0xD108             BNE.N    ??HAL_HCD_HC_SubmitRequest_12
    376                { /* Put the PID 0 */
    377                  hhcd->hc[ch_num].data_pid = HC_PID_DATA0;    
   \   00000110   0x2000             MOVS     R0,#+0
   \   00000112   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000116   0x2128             MOVS     R1,#+40
   \   00000118   0xFB01 0x7108      MLA      R1,R1,R8,R7
   \   0000011C   0xF881 0x003E      STRB     R0,[R1, #+62]
   \   00000120   0xE007             B.N      ??HAL_HCD_HC_SubmitRequest_13
    378                }
    379                else
    380                { /* Put the PID 1 */
    381                  hhcd->hc[ch_num].data_pid = HC_PID_DATA1 ;
   \                     ??HAL_HCD_HC_SubmitRequest_12: (+1)
   \   00000122   0x2002             MOVS     R0,#+2
   \   00000124   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000128   0x2128             MOVS     R1,#+40
   \   0000012A   0xFB01 0x7108      MLA      R1,R1,R8,R7
   \   0000012E   0xF881 0x003E      STRB     R0,[R1, #+62]
    382                }
    383                if(hhcd->hc[ch_num].urb_state  != URB_NOTREADY)
   \                     ??HAL_HCD_HC_SubmitRequest_13: (+1)
   \   00000132   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000136   0x2028             MOVS     R0,#+40
   \   00000138   0xFB00 0x7008      MLA      R0,R0,R8,R7
   \   0000013C   0xF890 0x0058      LDRB     R0,[R0, #+88]
   \   00000140   0x2802             CMP      R0,#+2
   \   00000142   0xD021             BEQ.N    ??HAL_HCD_HC_SubmitRequest_14
    384                {
    385                  hhcd->hc[ch_num].do_ping = do_ping;
   \   00000144   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000148   0x2028             MOVS     R0,#+40
   \   0000014A   0xFB00 0x7008      MLA      R0,R0,R8,R7
   \   0000014E   0xF880 0x6039      STRB     R6,[R0, #+57]
   \   00000152   0xE019             B.N      ??HAL_HCD_HC_SubmitRequest_14
    386                }
    387              }
    388              else
    389              {
    390                if( hhcd->hc[ch_num].toggle_in == 0)
   \                     ??HAL_HCD_HC_SubmitRequest_11: (+1)
   \   00000154   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000158   0x2028             MOVS     R0,#+40
   \   0000015A   0xFB00 0x7008      MLA      R0,R0,R8,R7
   \   0000015E   0xF890 0x004C      LDRB     R0,[R0, #+76]
   \   00000162   0x2800             CMP      R0,#+0
   \   00000164   0xD108             BNE.N    ??HAL_HCD_HC_SubmitRequest_15
    391                {
    392                  hhcd->hc[ch_num].data_pid = HC_PID_DATA0;
   \   00000166   0x2000             MOVS     R0,#+0
   \   00000168   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000016C   0x2128             MOVS     R1,#+40
   \   0000016E   0xFB01 0x7108      MLA      R1,R1,R8,R7
   \   00000172   0xF881 0x003E      STRB     R0,[R1, #+62]
   \   00000176   0xE007             B.N      ??HAL_HCD_HC_SubmitRequest_14
    393                }
    394                else
    395                {
    396                  hhcd->hc[ch_num].data_pid = HC_PID_DATA1;
   \                     ??HAL_HCD_HC_SubmitRequest_15: (+1)
   \   00000178   0x2002             MOVS     R0,#+2
   \   0000017A   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000017E   0x2128             MOVS     R1,#+40
   \   00000180   0xFB01 0x7108      MLA      R1,R1,R8,R7
   \   00000184   0xF881 0x003E      STRB     R0,[R1, #+62]
    397                }
    398              }
    399              
    400              break;
   \                     ??HAL_HCD_HC_SubmitRequest_14: (+1)
   \   00000188   0xE042             B.N      ??HAL_HCD_HC_SubmitRequest_6
    401            case EP_TYPE_INTR:
    402              if(direction == 0)
   \                     ??HAL_HCD_HC_SubmitRequest_5: (+1)
   \   0000018A   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   0000018E   0xF1B9 0x0F00      CMP      R9,#+0
   \   00000192   0xD11A             BNE.N    ??HAL_HCD_HC_SubmitRequest_16
    403              {
    404                /* Set the Data Toggle bit as per the Flag */
    405                if ( hhcd->hc[ch_num].toggle_out == 0)
   \   00000194   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000198   0x2028             MOVS     R0,#+40
   \   0000019A   0xFB00 0x7008      MLA      R0,R0,R8,R7
   \   0000019E   0xF890 0x004D      LDRB     R0,[R0, #+77]
   \   000001A2   0x2800             CMP      R0,#+0
   \   000001A4   0xD108             BNE.N    ??HAL_HCD_HC_SubmitRequest_17
    406                { /* Put the PID 0 */
    407                  hhcd->hc[ch_num].data_pid = HC_PID_DATA0;    
   \   000001A6   0x2000             MOVS     R0,#+0
   \   000001A8   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000001AC   0x2128             MOVS     R1,#+40
   \   000001AE   0xFB01 0x7108      MLA      R1,R1,R8,R7
   \   000001B2   0xF881 0x003E      STRB     R0,[R1, #+62]
   \   000001B6   0xE022             B.N      ??HAL_HCD_HC_SubmitRequest_18
    408                }
    409                else
    410                { /* Put the PID 1 */
    411                  hhcd->hc[ch_num].data_pid = HC_PID_DATA1 ;
   \                     ??HAL_HCD_HC_SubmitRequest_17: (+1)
   \   000001B8   0x2002             MOVS     R0,#+2
   \   000001BA   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000001BE   0x2128             MOVS     R1,#+40
   \   000001C0   0xFB01 0x7108      MLA      R1,R1,R8,R7
   \   000001C4   0xF881 0x003E      STRB     R0,[R1, #+62]
   \   000001C8   0xE019             B.N      ??HAL_HCD_HC_SubmitRequest_18
    412                }
    413              }
    414              else
    415              {
    416                if( hhcd->hc[ch_num].toggle_in == 0)
   \                     ??HAL_HCD_HC_SubmitRequest_16: (+1)
   \   000001CA   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000001CE   0x2028             MOVS     R0,#+40
   \   000001D0   0xFB00 0x7008      MLA      R0,R0,R8,R7
   \   000001D4   0xF890 0x004C      LDRB     R0,[R0, #+76]
   \   000001D8   0x2800             CMP      R0,#+0
   \   000001DA   0xD108             BNE.N    ??HAL_HCD_HC_SubmitRequest_19
    417                {
    418                  hhcd->hc[ch_num].data_pid = HC_PID_DATA0;
   \   000001DC   0x2000             MOVS     R0,#+0
   \   000001DE   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000001E2   0x2128             MOVS     R1,#+40
   \   000001E4   0xFB01 0x7108      MLA      R1,R1,R8,R7
   \   000001E8   0xF881 0x003E      STRB     R0,[R1, #+62]
   \   000001EC   0xE007             B.N      ??HAL_HCD_HC_SubmitRequest_18
    419                }
    420                else
    421                {
    422                  hhcd->hc[ch_num].data_pid = HC_PID_DATA1;
   \                     ??HAL_HCD_HC_SubmitRequest_19: (+1)
   \   000001EE   0x2002             MOVS     R0,#+2
   \   000001F0   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000001F4   0x2128             MOVS     R1,#+40
   \   000001F6   0xFB01 0x7108      MLA      R1,R1,R8,R7
   \   000001FA   0xF881 0x003E      STRB     R0,[R1, #+62]
    423                }
    424              }
    425              break;
   \                     ??HAL_HCD_HC_SubmitRequest_18: (+1)
   \   000001FE   0xE007             B.N      ??HAL_HCD_HC_SubmitRequest_6
    426              
    427            case EP_TYPE_ISOC: 
    428              hhcd->hc[ch_num].data_pid = HC_PID_DATA0;
   \                     ??HAL_HCD_HC_SubmitRequest_4: (+1)
   \   00000200   0x2000             MOVS     R0,#+0
   \   00000202   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000206   0x2128             MOVS     R1,#+40
   \   00000208   0xFB01 0x7108      MLA      R1,R1,R8,R7
   \   0000020C   0xF881 0x003E      STRB     R0,[R1, #+62]
    429              break;      
    430            }
    431            
    432            hhcd->hc[ch_num].xfer_buff = pbuff;
   \                     ??HAL_HCD_HC_SubmitRequest_6: (+1)
   \   00000210   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000214   0x2028             MOVS     R0,#+40
   \   00000216   0xFB00 0x7008      MLA      R0,R0,R8,R7
   \   0000021A   0xF8C0 0xB040      STR      R11,[R0, #+64]
    433            hhcd->hc[ch_num].xfer_len  = length;
   \   0000021E   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000220   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000224   0x2028             MOVS     R0,#+40
   \   00000226   0xFB00 0x7008      MLA      R0,R0,R8,R7
   \   0000022A   0x6445             STR      R5,[R0, #+68]
    434            hhcd->hc[ch_num].urb_state =   URB_IDLE;  
   \   0000022C   0x2000             MOVS     R0,#+0
   \   0000022E   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000232   0x2128             MOVS     R1,#+40
   \   00000234   0xFB01 0x7108      MLA      R1,R1,R8,R7
   \   00000238   0xF881 0x0058      STRB     R0,[R1, #+88]
    435            hhcd->hc[ch_num].xfer_count = 0 ;
   \   0000023C   0x2000             MOVS     R0,#+0
   \   0000023E   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000242   0x2128             MOVS     R1,#+40
   \   00000244   0xFB01 0x7108      MLA      R1,R1,R8,R7
   \   00000248   0x6488             STR      R0,[R1, #+72]
    436            hhcd->hc[ch_num].ch_num = ch_num;
   \   0000024A   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000024E   0x2028             MOVS     R0,#+40
   \   00000250   0xFB00 0x7008      MLA      R0,R0,R8,R7
   \   00000254   0xF880 0x8035      STRB     R8,[R0, #+53]
    437            hhcd->hc[ch_num].state = HC_IDLE;
   \   00000258   0x2000             MOVS     R0,#+0
   \   0000025A   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000025E   0x2128             MOVS     R1,#+40
   \   00000260   0xFB01 0x7108      MLA      R1,R1,R8,R7
   \   00000264   0xF881 0x0059      STRB     R0,[R1, #+89]
    438            
    439            return USB_HC_StartXfer(hhcd->Instance, &(hhcd->hc[ch_num]), hhcd->Init.dma_enable);
   \   00000268   0x693A             LDR      R2,[R7, #+16]
   \   0000026A   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000026C   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000270   0x2028             MOVS     R0,#+40
   \   00000272   0xFB00 0x7008      MLA      R0,R0,R8,R7
   \   00000276   0xF110 0x0134      ADDS     R1,R0,#+52
   \   0000027A   0x6838             LDR      R0,[R7, #+0]
   \   0000027C   0x.... 0x....      BL       USB_HC_StartXfer
   \   00000280   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
    440          }
    441          
    442          /**
    443            * @brief  This function handles HCD interrupt request.
    444            * @param  hhcd: HCD handle
    445            * @retval None
    446            */

   \                                 In section .text, align 2, keep-with-next
    447          void HAL_HCD_IRQHandler(HCD_HandleTypeDef *hhcd)
    448          {
   \                     HAL_HCD_IRQHandler: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
    449            USB_OTG_GlobalTypeDef *USBx = hhcd->Instance;
   \   00000004   0x6825             LDR      R5,[R4, #+0]
    450            uint32_t i = 0 , interrupt = 0;
   \   00000006   0x2600             MOVS     R6,#+0
   \   00000008   0x2700             MOVS     R7,#+0
    451            
    452            /* ensure that we are in device mode */
    453            if (USB_GetMode(hhcd->Instance) == USB_OTG_MODE_HOST)
   \   0000000A   0x6820             LDR      R0,[R4, #+0]
   \   0000000C   0x.... 0x....      BL       USB_GetMode
   \   00000010   0x2801             CMP      R0,#+1
   \   00000012   0xF040 0x8092      BNE.W    ??HAL_HCD_IRQHandler_0
    454            {
    455              /* avoid spurious interrupt */
    456              if(__HAL_HCD_IS_INVALID_INTERRUPT(hhcd)) 
   \   00000016   0x6820             LDR      R0,[R4, #+0]
   \   00000018   0x.... 0x....      BL       USB_ReadInterrupts
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xF000 0x808C      BEQ.W    ??HAL_HCD_IRQHandler_1
    457              {
    458                return;
    459              }
    460              
    461              if(__HAL_HCD_GET_FLAG(hhcd, USB_OTG_GINTSTS_PXFR_INCOMPISOOUT))
   \                     ??HAL_HCD_IRQHandler_2: (+1)
   \   00000022   0x6820             LDR      R0,[R4, #+0]
   \   00000024   0x.... 0x....      BL       USB_ReadInterrupts
   \   00000028   0x0280             LSLS     R0,R0,#+10
   \   0000002A   0xD503             BPL.N    ??HAL_HCD_IRQHandler_3
    462              {
    463               /* incorrect mode, acknowledge the interrupt */
    464                __HAL_HCD_CLEAR_FLAG(hhcd, USB_OTG_GINTSTS_PXFR_INCOMPISOOUT);
   \   0000002C   0xF45F 0x1000      MOVS     R0,#+2097152
   \   00000030   0x6821             LDR      R1,[R4, #+0]
   \   00000032   0x6148             STR      R0,[R1, #+20]
    465              }
    466              
    467              if(__HAL_HCD_GET_FLAG(hhcd, USB_OTG_GINTSTS_IISOIXFR))
   \                     ??HAL_HCD_IRQHandler_3: (+1)
   \   00000034   0x6820             LDR      R0,[R4, #+0]
   \   00000036   0x.... 0x....      BL       USB_ReadInterrupts
   \   0000003A   0x02C0             LSLS     R0,R0,#+11
   \   0000003C   0xD503             BPL.N    ??HAL_HCD_IRQHandler_4
    468              {
    469               /* incorrect mode, acknowledge the interrupt */
    470                __HAL_HCD_CLEAR_FLAG(hhcd, USB_OTG_GINTSTS_IISOIXFR);
   \   0000003E   0xF45F 0x1080      MOVS     R0,#+1048576
   \   00000042   0x6821             LDR      R1,[R4, #+0]
   \   00000044   0x6148             STR      R0,[R1, #+20]
    471              }
    472          
    473              if(__HAL_HCD_GET_FLAG(hhcd, USB_OTG_GINTSTS_PTXFE))
   \                     ??HAL_HCD_IRQHandler_4: (+1)
   \   00000046   0x6820             LDR      R0,[R4, #+0]
   \   00000048   0x.... 0x....      BL       USB_ReadInterrupts
   \   0000004C   0x0140             LSLS     R0,R0,#+5
   \   0000004E   0xD503             BPL.N    ??HAL_HCD_IRQHandler_5
    474              {
    475               /* incorrect mode, acknowledge the interrupt */
    476                __HAL_HCD_CLEAR_FLAG(hhcd, USB_OTG_GINTSTS_PTXFE);
   \   00000050   0xF05F 0x6080      MOVS     R0,#+67108864
   \   00000054   0x6821             LDR      R1,[R4, #+0]
   \   00000056   0x6148             STR      R0,[R1, #+20]
    477              }   
    478              
    479              if(__HAL_HCD_GET_FLAG(hhcd, USB_OTG_GINTSTS_MMIS))
   \                     ??HAL_HCD_IRQHandler_5: (+1)
   \   00000058   0x6820             LDR      R0,[R4, #+0]
   \   0000005A   0x.... 0x....      BL       USB_ReadInterrupts
   \   0000005E   0x0780             LSLS     R0,R0,#+30
   \   00000060   0xD502             BPL.N    ??HAL_HCD_IRQHandler_6
    480              {
    481               /* incorrect mode, acknowledge the interrupt */
    482                __HAL_HCD_CLEAR_FLAG(hhcd, USB_OTG_GINTSTS_MMIS);
   \   00000062   0x2002             MOVS     R0,#+2
   \   00000064   0x6821             LDR      R1,[R4, #+0]
   \   00000066   0x6148             STR      R0,[R1, #+20]
    483              }     
    484              
    485              /* Handle Host Disconnect Interrupts */
    486              if(__HAL_HCD_GET_FLAG(hhcd, USB_OTG_GINTSTS_DISCINT))
   \                     ??HAL_HCD_IRQHandler_6: (+1)
   \   00000068   0x6820             LDR      R0,[R4, #+0]
   \   0000006A   0x.... 0x....      BL       USB_ReadInterrupts
   \   0000006E   0x0080             LSLS     R0,R0,#+2
   \   00000070   0xD512             BPL.N    ??HAL_HCD_IRQHandler_7
    487              {
    488                
    489                /* Cleanup HPRT */
    490                USBx_HPRT0 &= ~(USB_OTG_HPRT_PENA | USB_OTG_HPRT_PCDET |\
    491                  USB_OTG_HPRT_PENCHNG | USB_OTG_HPRT_POCCHNG );
   \   00000072   0xF515 0x6088      ADDS     R0,R5,#+1088
   \   00000076   0x6800             LDR      R0,[R0, #+0]
   \   00000078   0xF030 0x002E      BICS     R0,R0,#0x2E
   \   0000007C   0xF515 0x6188      ADDS     R1,R5,#+1088
   \   00000080   0x6008             STR      R0,[R1, #+0]
    492                 
    493                /* Handle Host Port Interrupts */
    494                HAL_HCD_Disconnect_Callback(hhcd);
   \   00000082   0x0020             MOVS     R0,R4
   \   00000084   0x.... 0x....      BL       HAL_HCD_Disconnect_Callback
    495                 USB_InitFSLSPClkSel(hhcd->Instance ,HCFG_48_MHZ );
   \   00000088   0x2101             MOVS     R1,#+1
   \   0000008A   0x6820             LDR      R0,[R4, #+0]
   \   0000008C   0x.... 0x....      BL       USB_InitFSLSPClkSel
    496                __HAL_HCD_CLEAR_FLAG(hhcd, USB_OTG_GINTSTS_DISCINT);
   \   00000090   0xF05F 0x5000      MOVS     R0,#+536870912
   \   00000094   0x6821             LDR      R1,[R4, #+0]
   \   00000096   0x6148             STR      R0,[R1, #+20]
    497              }
    498              
    499              /* Handle Host Port Interrupts */
    500              if(__HAL_HCD_GET_FLAG(hhcd, USB_OTG_GINTSTS_HPRTINT))
   \                     ??HAL_HCD_IRQHandler_7: (+1)
   \   00000098   0x6820             LDR      R0,[R4, #+0]
   \   0000009A   0x.... 0x....      BL       USB_ReadInterrupts
   \   0000009E   0x01C0             LSLS     R0,R0,#+7
   \   000000A0   0xD502             BPL.N    ??HAL_HCD_IRQHandler_8
    501              {
    502                HCD_Port_IRQHandler (hhcd);
   \   000000A2   0x0020             MOVS     R0,R4
   \   000000A4   0x.... 0x....      BL       HCD_Port_IRQHandler
    503              }
    504              
    505              /* Handle Host SOF Interrupts */
    506              if(__HAL_HCD_GET_FLAG(hhcd, USB_OTG_GINTSTS_SOF))
   \                     ??HAL_HCD_IRQHandler_8: (+1)
   \   000000A8   0x6820             LDR      R0,[R4, #+0]
   \   000000AA   0x.... 0x....      BL       USB_ReadInterrupts
   \   000000AE   0x0700             LSLS     R0,R0,#+28
   \   000000B0   0xD505             BPL.N    ??HAL_HCD_IRQHandler_9
    507              {
    508                HAL_HCD_SOF_Callback(hhcd);
   \   000000B2   0x0020             MOVS     R0,R4
   \   000000B4   0x.... 0x....      BL       HAL_HCD_SOF_Callback
    509                __HAL_HCD_CLEAR_FLAG(hhcd, USB_OTG_GINTSTS_SOF);
   \   000000B8   0x2008             MOVS     R0,#+8
   \   000000BA   0x6821             LDR      R1,[R4, #+0]
   \   000000BC   0x6148             STR      R0,[R1, #+20]
    510              }
    511                    
    512              /* Handle Host channel Interrupts */
    513              if(__HAL_HCD_GET_FLAG(hhcd, USB_OTG_GINTSTS_HCINT))
   \                     ??HAL_HCD_IRQHandler_9: (+1)
   \   000000BE   0x6820             LDR      R0,[R4, #+0]
   \   000000C0   0x.... 0x....      BL       USB_ReadInterrupts
   \   000000C4   0x0180             LSLS     R0,R0,#+6
   \   000000C6   0xD524             BPL.N    ??HAL_HCD_IRQHandler_10
    514              {
    515                interrupt = USB_HC_ReadInterrupt(hhcd->Instance);
   \   000000C8   0x6820             LDR      R0,[R4, #+0]
   \   000000CA   0x.... 0x....      BL       USB_HC_ReadInterrupt
   \   000000CE   0x0007             MOVS     R7,R0
    516                for (i = 0; i < hhcd->Init.Host_channels ; i++)
   \   000000D0   0x2000             MOVS     R0,#+0
   \   000000D2   0x0006             MOVS     R6,R0
   \                     ??HAL_HCD_IRQHandler_11: (+1)
   \   000000D4   0x68A0             LDR      R0,[R4, #+8]
   \   000000D6   0x4286             CMP      R6,R0
   \   000000D8   0xD217             BCS.N    ??HAL_HCD_IRQHandler_12
    517                {
    518                  if (interrupt & (1 << i))
   \   000000DA   0x0038             MOVS     R0,R7
   \   000000DC   0x40F0             LSRS     R0,R0,R6
   \   000000DE   0x07C0             LSLS     R0,R0,#+31
   \   000000E0   0xD511             BPL.N    ??HAL_HCD_IRQHandler_13
    519                  {
    520                    if ((USBx_HC(i)->HCCHAR) &  USB_OTG_HCCHAR_EPDIR)
   \   000000E2   0xEB15 0x1046      ADDS     R0,R5,R6, LSL #+5
   \   000000E6   0xF510 0x60A0      ADDS     R0,R0,#+1280
   \   000000EA   0x6800             LDR      R0,[R0, #+0]
   \   000000EC   0x0400             LSLS     R0,R0,#+16
   \   000000EE   0xD505             BPL.N    ??HAL_HCD_IRQHandler_14
    521                    {
    522                      HCD_HC_IN_IRQHandler (hhcd, i);
   \   000000F0   0x0031             MOVS     R1,R6
   \   000000F2   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000F4   0x0020             MOVS     R0,R4
   \   000000F6   0x.... 0x....      BL       HCD_HC_IN_IRQHandler
   \   000000FA   0xE004             B.N      ??HAL_HCD_IRQHandler_13
    523                    }
    524                    else
    525                    {
    526                      HCD_HC_OUT_IRQHandler (hhcd, i);
   \                     ??HAL_HCD_IRQHandler_14: (+1)
   \   000000FC   0x0031             MOVS     R1,R6
   \   000000FE   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000100   0x0020             MOVS     R0,R4
   \   00000102   0x.... 0x....      BL       HCD_HC_OUT_IRQHandler
    527                    }
    528                  }
    529                }
   \                     ??HAL_HCD_IRQHandler_13: (+1)
   \   00000106   0x1C76             ADDS     R6,R6,#+1
   \   00000108   0xE7E4             B.N      ??HAL_HCD_IRQHandler_11
    530                __HAL_HCD_CLEAR_FLAG(hhcd, USB_OTG_GINTSTS_HCINT);
   \                     ??HAL_HCD_IRQHandler_12: (+1)
   \   0000010A   0xF05F 0x7000      MOVS     R0,#+33554432
   \   0000010E   0x6821             LDR      R1,[R4, #+0]
   \   00000110   0x6148             STR      R0,[R1, #+20]
    531              } 
    532              
    533                  /* Handle Rx Queue Level Interrupts */
    534              if(__HAL_HCD_GET_FLAG(hhcd, USB_OTG_GINTSTS_RXFLVL))
   \                     ??HAL_HCD_IRQHandler_10: (+1)
   \   00000112   0x6820             LDR      R0,[R4, #+0]
   \   00000114   0x.... 0x....      BL       USB_ReadInterrupts
   \   00000118   0x06C0             LSLS     R0,R0,#+27
   \   0000011A   0xD50E             BPL.N    ??HAL_HCD_IRQHandler_0
    535              {
    536                USB_MASK_INTERRUPT(hhcd->Instance, USB_OTG_GINTSTS_RXFLVL);
   \   0000011C   0x6820             LDR      R0,[R4, #+0]
   \   0000011E   0x6980             LDR      R0,[R0, #+24]
   \   00000120   0xF030 0x0010      BICS     R0,R0,#0x10
   \   00000124   0x6821             LDR      R1,[R4, #+0]
   \   00000126   0x6188             STR      R0,[R1, #+24]
    537                
    538                HCD_RXQLVL_IRQHandler (hhcd);
   \   00000128   0x0020             MOVS     R0,R4
   \   0000012A   0x.... 0x....      BL       HCD_RXQLVL_IRQHandler
    539                
    540                USB_UNMASK_INTERRUPT(hhcd->Instance, USB_OTG_GINTSTS_RXFLVL);
   \   0000012E   0x6820             LDR      R0,[R4, #+0]
   \   00000130   0x6980             LDR      R0,[R0, #+24]
   \   00000132   0xF050 0x0010      ORRS     R0,R0,#0x10
   \   00000136   0x6821             LDR      R1,[R4, #+0]
   \   00000138   0x6188             STR      R0,[R1, #+24]
    541              }
    542            }
    543          }
   \                     ??HAL_HCD_IRQHandler_0: (+1)
   \                     ??HAL_HCD_IRQHandler_1: (+1)
   \   0000013A   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    544          
    545          /**
    546            * @brief  SOF callback.
    547            * @param  hhcd: HCD handle
    548            * @retval None
    549            */

   \                                 In section .text, align 2, keep-with-next
    550          __weak void HAL_HCD_SOF_Callback(HCD_HandleTypeDef *hhcd)
    551          {
    552            /* NOTE : This function Should not be modified, when the callback is needed,
    553                      the HAL_HCD_SOF_Callback could be implemented in the user file
    554             */
    555          }
   \                     HAL_HCD_SOF_Callback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    556          
    557          /**
    558            * @brief Connexion Event callback.
    559            * @param  hhcd: HCD handle
    560            * @retval None
    561            */

   \                                 In section .text, align 2, keep-with-next
    562          __weak void HAL_HCD_Connect_Callback(HCD_HandleTypeDef *hhcd)
    563          {
    564            /* NOTE : This function Should not be modified, when the callback is needed,
    565                      the HAL_HCD_Connect_Callback could be implemented in the user file
    566             */
    567          }
   \                     HAL_HCD_Connect_Callback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    568          
    569          /**
    570            * @brief  Disconnexion Event callback.
    571            * @param  hhcd: HCD handle
    572            * @retval None
    573            */

   \                                 In section .text, align 2, keep-with-next
    574          __weak void HAL_HCD_Disconnect_Callback(HCD_HandleTypeDef *hhcd)
    575          {
    576            /* NOTE : This function Should not be modified, when the callback is needed,
    577                      the HAL_HCD_Disconnect_Callback could be implemented in the user file
    578             */
    579          } 
   \                     HAL_HCD_Disconnect_Callback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    580          
    581          /**
    582            * @brief  Notify URB state change callback.
    583            * @param  hhcd: HCD handle
    584            * @param  chnum: Channel number.
    585            *         This parameter can be a value from 1 to 15
    586            * @param  urb_state:
    587            *          This parameter can be one of these values:
    588            *            URB_IDLE/
    589            *            URB_DONE/
    590            *            URB_NOTREADY/
    591            *            URB_NYET/ 
    592            *            URB_ERROR/  
    593            *            URB_STALL/    
    594            * @retval None
    595            */

   \                                 In section .text, align 2, keep-with-next
    596          __weak void HAL_HCD_HC_NotifyURBChange_Callback(HCD_HandleTypeDef *hhcd, uint8_t chnum, HCD_URBStateTypeDef urb_state)
    597          {
    598            /* NOTE : This function Should not be modified, when the callback is needed,
    599                      the HAL_HCD_HC_NotifyURBChange_Callback could be implemented in the user file
    600             */
    601          }
   \                     HAL_HCD_HC_NotifyURBChange_Callback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    602          
    603          /**
    604            * @}
    605            */
    606          
    607          /** @addtogroup HCD_Exported_Functions_Group3
    608           *  @brief   Peripheral management functions 
    609           *
    610          @verbatim   
    611           ===============================================================================
    612                                ##### Peripheral Control functions #####
    613           ===============================================================================  
    614              [..]
    615              This subsection provides a set of functions allowing to control the HCD data 
    616              transfers.
    617          
    618          @endverbatim
    619            * @{
    620            */
    621          
    622          /**
    623            * @brief  Start the host driver
    624            * @param  hhcd: HCD handle
    625            * @retval HAL status
    626            */

   \                                 In section .text, align 2, keep-with-next
    627          HAL_StatusTypeDef HAL_HCD_Start(HCD_HandleTypeDef *hhcd)
    628          { 
   \                     HAL_HCD_Start: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    629            __HAL_LOCK(hhcd); 
   \   00000004   0xF894 0x028C      LDRB     R0,[R4, #+652]
   \   00000008   0x2801             CMP      R0,#+1
   \   0000000A   0xD101             BNE.N    ??HAL_HCD_Start_0
   \   0000000C   0x2002             MOVS     R0,#+2
   \   0000000E   0xE00D             B.N      ??HAL_HCD_Start_1
   \                     ??HAL_HCD_Start_0: (+1)
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0xF884 0x028C      STRB     R0,[R4, #+652]
    630            __HAL_HCD_ENABLE(hhcd);
   \   00000016   0x6820             LDR      R0,[R4, #+0]
   \   00000018   0x.... 0x....      BL       USB_EnableGlobalInt
    631            USB_DriveVbus(hhcd->Instance, 1);  
   \   0000001C   0x2101             MOVS     R1,#+1
   \   0000001E   0x6820             LDR      R0,[R4, #+0]
   \   00000020   0x.... 0x....      BL       USB_DriveVbus
    632            __HAL_UNLOCK(hhcd); 
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0xF884 0x028C      STRB     R0,[R4, #+652]
    633            return HAL_OK;
   \   0000002A   0x2000             MOVS     R0,#+0
   \                     ??HAL_HCD_Start_1: (+1)
   \   0000002C   0xBD10             POP      {R4,PC}          ;; return
    634          }
    635          
    636          /**
    637            * @brief  Stop the host driver
    638            * @param  hhcd: HCD handle
    639            * @retval HAL status
    640            */
    641          

   \                                 In section .text, align 2, keep-with-next
    642          HAL_StatusTypeDef HAL_HCD_Stop(HCD_HandleTypeDef *hhcd)
    643          { 
   \                     HAL_HCD_Stop: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    644            __HAL_LOCK(hhcd); 
   \   00000004   0xF894 0x028C      LDRB     R0,[R4, #+652]
   \   00000008   0x2801             CMP      R0,#+1
   \   0000000A   0xD101             BNE.N    ??HAL_HCD_Stop_0
   \   0000000C   0x2002             MOVS     R0,#+2
   \   0000000E   0xE009             B.N      ??HAL_HCD_Stop_1
   \                     ??HAL_HCD_Stop_0: (+1)
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0xF884 0x028C      STRB     R0,[R4, #+652]
    645            USB_StopHost(hhcd->Instance);
   \   00000016   0x6820             LDR      R0,[R4, #+0]
   \   00000018   0x.... 0x....      BL       USB_StopHost
    646            __HAL_UNLOCK(hhcd); 
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0xF884 0x028C      STRB     R0,[R4, #+652]
    647            return HAL_OK;
   \   00000022   0x2000             MOVS     R0,#+0
   \                     ??HAL_HCD_Stop_1: (+1)
   \   00000024   0xBD10             POP      {R4,PC}          ;; return
    648          }
    649          
    650          /**
    651            * @brief  Reset the host port
    652            * @param  hhcd: HCD handle
    653            * @retval HAL status
    654            */

   \                                 In section .text, align 2, keep-with-next
    655          HAL_StatusTypeDef HAL_HCD_ResetPort(HCD_HandleTypeDef *hhcd)
    656          {
   \                     HAL_HCD_ResetPort: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    657            return (USB_ResetPort(hhcd->Instance));
   \   00000004   0x6820             LDR      R0,[R4, #+0]
   \   00000006   0x.... 0x....      BL       USB_ResetPort
   \   0000000A   0xBD10             POP      {R4,PC}          ;; return
    658          }
    659          
    660          /**
    661            * @}
    662            */
    663          
    664          /** @addtogroup HCD_Exported_Functions_Group4
    665           *  @brief   Peripheral State functions 
    666           *
    667          @verbatim   
    668           ===============================================================================
    669                                ##### Peripheral State functions #####
    670           ===============================================================================  
    671              [..]
    672              This subsection permits to get in run-time the status of the peripheral 
    673              and the data flow.
    674          
    675          @endverbatim
    676            * @{
    677            */
    678          
    679          /**
    680            * @brief  Return the HCD state
    681            * @param  hhcd: HCD handle
    682            * @retval HAL state
    683            */

   \                                 In section .text, align 2, keep-with-next
    684          HCD_StateTypeDef HAL_HCD_GetState(HCD_HandleTypeDef *hhcd)
    685          {
    686            return hhcd->State;
   \                     HAL_HCD_GetState: (+1)
   \   00000000   0xF890 0x028D      LDRB     R0,[R0, #+653]
   \   00000004   0x4770             BX       LR               ;; return
    687          }
    688          
    689          /**
    690            * @brief  Return  URB state for a channel
    691            * @param  hhcd: HCD handle
    692            * @param  chnum: Channel number.
    693            *         This parameter can be a value from 1 to 15
    694            * @retval URB state.
    695            *          This parameter can be one of these values:
    696            *            URB_IDLE/
    697            *            URB_DONE/
    698            *            URB_NOTREADY/
    699            *            URB_NYET/ 
    700            *            URB_ERROR/  
    701            *            URB_STALL/
    702            */

   \                                 In section .text, align 2, keep-with-next
    703          HCD_URBStateTypeDef HAL_HCD_HC_GetURBState(HCD_HandleTypeDef *hhcd, uint8_t chnum)
    704          {
    705            return hhcd->hc[chnum].urb_state;
   \                     HAL_HCD_HC_GetURBState: (+1)
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0x2228             MOVS     R2,#+40
   \   00000004   0xFB02 0x0001      MLA      R0,R2,R1,R0
   \   00000008   0xF890 0x0058      LDRB     R0,[R0, #+88]
   \   0000000C   0x4770             BX       LR               ;; return
    706          }
    707          
    708          
    709          /**
    710            * @brief  Return the last host transfer size
    711            * @param  hhcd: HCD handle
    712            * @param  chnum: Channel number.
    713            *         This parameter can be a value from 1 to 15
    714            * @retval last transfer size in byte
    715            */

   \                                 In section .text, align 2, keep-with-next
    716          uint32_t HAL_HCD_HC_GetXferCount(HCD_HandleTypeDef *hhcd, uint8_t chnum)
    717          {
    718            return hhcd->hc[chnum].xfer_count; 
   \                     HAL_HCD_HC_GetXferCount: (+1)
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0x2228             MOVS     R2,#+40
   \   00000004   0xFB02 0x0001      MLA      R0,R2,R1,R0
   \   00000008   0x6C80             LDR      R0,[R0, #+72]
   \   0000000A   0x4770             BX       LR               ;; return
    719          }
    720            
    721          /**
    722            * @brief  Return the Host Channel state
    723            * @param  hhcd: HCD handle
    724            * @param  chnum: Channel number.
    725            *         This parameter can be a value from 1 to 15
    726            * @retval Host channel state
    727            *          This parameter can be one of the these values:
    728            *            HC_IDLE/
    729            *            HC_XFRC/
    730            *            HC_HALTED/
    731            *            HC_NYET/ 
    732            *            HC_NAK/  
    733            *            HC_STALL/ 
    734            *            HC_XACTERR/  
    735            *            HC_BBLERR/  
    736            *            HC_DATATGLERR/    
    737            */

   \                                 In section .text, align 2, keep-with-next
    738          HCD_HCStateTypeDef  HAL_HCD_HC_GetState(HCD_HandleTypeDef *hhcd, uint8_t chnum)
    739          {
    740            return hhcd->hc[chnum].state;
   \                     HAL_HCD_HC_GetState: (+1)
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0x2228             MOVS     R2,#+40
   \   00000004   0xFB02 0x0001      MLA      R0,R2,R1,R0
   \   00000008   0xF890 0x0059      LDRB     R0,[R0, #+89]
   \   0000000C   0x4770             BX       LR               ;; return
    741          }
    742          
    743          /**
    744            * @brief  Return the current Host frame number
    745            * @param  hhcd: HCD handle
    746            * @retval Current Host frame number
    747            */

   \                                 In section .text, align 2, keep-with-next
    748          uint32_t HAL_HCD_GetCurrentFrame(HCD_HandleTypeDef *hhcd)
    749          {
   \                     HAL_HCD_GetCurrentFrame: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    750            return (USB_GetCurrentFrame(hhcd->Instance));
   \   00000004   0x6820             LDR      R0,[R4, #+0]
   \   00000006   0x.... 0x....      BL       USB_GetCurrentFrame
   \   0000000A   0xBD10             POP      {R4,PC}          ;; return
    751          }
    752          
    753          /**
    754            * @brief  Return the Host enumeration speed
    755            * @param  hhcd: HCD handle
    756            * @retval Enumeration speed
    757            */

   \                                 In section .text, align 2, keep-with-next
    758          uint32_t HAL_HCD_GetCurrentSpeed(HCD_HandleTypeDef *hhcd)
    759          {
   \                     HAL_HCD_GetCurrentSpeed: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    760            return (USB_GetHostSpeed(hhcd->Instance));
   \   00000004   0x6820             LDR      R0,[R4, #+0]
   \   00000006   0x.... 0x....      BL       USB_GetHostSpeed
   \   0000000A   0xBD10             POP      {R4,PC}          ;; return
    761          }
    762          /**
    763            * @}
    764            */
    765          
    766          /**
    767            * @}
    768            */
    769          
    770          /** @addtogroup HCD_Private_Functions
    771            * @{
    772            */
    773          /**
    774            * @brief  This function handles Host Channel IN interrupt requests.
    775            * @param  hhcd: HCD handle
    776            * @param  chnum: Channel number.
    777            *         This parameter can be a value from 1 to 15
    778            * @retval none
    779            */

   \                                 In section .text, align 2, keep-with-next
    780          static void HCD_HC_IN_IRQHandler   (HCD_HandleTypeDef *hhcd, uint8_t chnum)
    781          {
   \                     HCD_HC_IN_IRQHandler: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    782            USB_OTG_GlobalTypeDef *USBx = hhcd->Instance;
   \   00000006   0x6826             LDR      R6,[R4, #+0]
    783              
    784            if ((USBx_HC(chnum)->HCINT) &  USB_OTG_HCINT_AHBERR)
   \   00000008   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000000A   0xEB16 0x1045      ADDS     R0,R6,R5, LSL #+5
   \   0000000E   0xF510 0x60A0      ADDS     R0,R0,#+1280
   \   00000012   0x6880             LDR      R0,[R0, #+8]
   \   00000014   0x0740             LSLS     R0,R0,#+29
   \   00000016   0xD515             BPL.N    ??HCD_HC_IN_IRQHandler_0
    785            {
    786              __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_AHBERR);
   \   00000018   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000001A   0xEB16 0x1045      ADDS     R0,R6,R5, LSL #+5
   \   0000001E   0xF510 0x60A0      ADDS     R0,R0,#+1280
   \   00000022   0x2104             MOVS     R1,#+4
   \   00000024   0x6081             STR      R1,[R0, #+8]
    787              __HAL_HCD_UNMASK_HALT_HC_INT(chnum);
   \   00000026   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000028   0xEB16 0x1045      ADDS     R0,R6,R5, LSL #+5
   \   0000002C   0xF510 0x60A0      ADDS     R0,R0,#+1280
   \   00000030   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000032   0xEB16 0x1145      ADDS     R1,R6,R5, LSL #+5
   \   00000036   0xF511 0x61A0      ADDS     R1,R1,#+1280
   \   0000003A   0x68C9             LDR      R1,[R1, #+12]
   \   0000003C   0xF051 0x0102      ORRS     R1,R1,#0x2
   \   00000040   0x60C1             STR      R1,[R0, #+12]
   \   00000042   0xE071             B.N      ??HCD_HC_IN_IRQHandler_1
    788            }  
    789            else if ((USBx_HC(chnum)->HCINT) &  USB_OTG_HCINT_ACK)
   \                     ??HCD_HC_IN_IRQHandler_0: (+1)
   \   00000044   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000046   0xEB16 0x1045      ADDS     R0,R6,R5, LSL #+5
   \   0000004A   0xF510 0x60A0      ADDS     R0,R0,#+1280
   \   0000004E   0x6880             LDR      R0,[R0, #+8]
   \   00000050   0x0680             LSLS     R0,R0,#+26
   \   00000052   0xD507             BPL.N    ??HCD_HC_IN_IRQHandler_2
    790            {
    791              __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_ACK);
   \   00000054   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000056   0xEB16 0x1045      ADDS     R0,R6,R5, LSL #+5
   \   0000005A   0xF510 0x60A0      ADDS     R0,R0,#+1280
   \   0000005E   0x2120             MOVS     R1,#+32
   \   00000060   0x6081             STR      R1,[R0, #+8]
   \   00000062   0xE061             B.N      ??HCD_HC_IN_IRQHandler_1
    792            }
    793            
    794            else if ((USBx_HC(chnum)->HCINT) &  USB_OTG_HCINT_STALL)  
   \                     ??HCD_HC_IN_IRQHandler_2: (+1)
   \   00000064   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000066   0xEB16 0x1045      ADDS     R0,R6,R5, LSL #+5
   \   0000006A   0xF510 0x60A0      ADDS     R0,R0,#+1280
   \   0000006E   0x6880             LDR      R0,[R0, #+8]
   \   00000070   0x0700             LSLS     R0,R0,#+28
   \   00000072   0xD528             BPL.N    ??HCD_HC_IN_IRQHandler_3
    795            {
    796              __HAL_HCD_UNMASK_HALT_HC_INT(chnum);
   \   00000074   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000076   0xEB16 0x1045      ADDS     R0,R6,R5, LSL #+5
   \   0000007A   0xF510 0x60A0      ADDS     R0,R0,#+1280
   \   0000007E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000080   0xEB16 0x1145      ADDS     R1,R6,R5, LSL #+5
   \   00000084   0xF511 0x61A0      ADDS     R1,R1,#+1280
   \   00000088   0x68C9             LDR      R1,[R1, #+12]
   \   0000008A   0xF051 0x0102      ORRS     R1,R1,#0x2
   \   0000008E   0x60C1             STR      R1,[R0, #+12]
    797              hhcd->hc[chnum].state = HC_STALL;
   \   00000090   0x2005             MOVS     R0,#+5
   \   00000092   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000094   0x2128             MOVS     R1,#+40
   \   00000096   0xFB01 0x4105      MLA      R1,R1,R5,R4
   \   0000009A   0xF881 0x0059      STRB     R0,[R1, #+89]
    798              __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_NAK);
   \   0000009E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000A0   0xEB16 0x1045      ADDS     R0,R6,R5, LSL #+5
   \   000000A4   0xF510 0x60A0      ADDS     R0,R0,#+1280
   \   000000A8   0x2110             MOVS     R1,#+16
   \   000000AA   0x6081             STR      R1,[R0, #+8]
    799              __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_STALL);    
   \   000000AC   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000AE   0xEB16 0x1045      ADDS     R0,R6,R5, LSL #+5
   \   000000B2   0xF510 0x60A0      ADDS     R0,R0,#+1280
   \   000000B6   0x2108             MOVS     R1,#+8
   \   000000B8   0x6081             STR      R1,[R0, #+8]
    800              USB_HC_Halt(hhcd->Instance, chnum);    
   \   000000BA   0x0029             MOVS     R1,R5
   \   000000BC   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000BE   0x6820             LDR      R0,[R4, #+0]
   \   000000C0   0x.... 0x....      BL       USB_HC_Halt
   \   000000C4   0xE030             B.N      ??HCD_HC_IN_IRQHandler_1
    801            }
    802            else if ((USBx_HC(chnum)->HCINT) &  USB_OTG_HCINT_DTERR)
   \                     ??HCD_HC_IN_IRQHandler_3: (+1)
   \   000000C6   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000C8   0xEB16 0x1045      ADDS     R0,R6,R5, LSL #+5
   \   000000CC   0xF510 0x60A0      ADDS     R0,R0,#+1280
   \   000000D0   0x6880             LDR      R0,[R0, #+8]
   \   000000D2   0x0540             LSLS     R0,R0,#+21
   \   000000D4   0xD528             BPL.N    ??HCD_HC_IN_IRQHandler_1
    803            {
    804              __HAL_HCD_UNMASK_HALT_HC_INT(chnum);
   \   000000D6   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000D8   0xEB16 0x1045      ADDS     R0,R6,R5, LSL #+5
   \   000000DC   0xF510 0x60A0      ADDS     R0,R0,#+1280
   \   000000E0   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000E2   0xEB16 0x1145      ADDS     R1,R6,R5, LSL #+5
   \   000000E6   0xF511 0x61A0      ADDS     R1,R1,#+1280
   \   000000EA   0x68C9             LDR      R1,[R1, #+12]
   \   000000EC   0xF051 0x0102      ORRS     R1,R1,#0x2
   \   000000F0   0x60C1             STR      R1,[R0, #+12]
    805              USB_HC_Halt(hhcd->Instance, chnum);  
   \   000000F2   0x0029             MOVS     R1,R5
   \   000000F4   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000F6   0x6820             LDR      R0,[R4, #+0]
   \   000000F8   0x.... 0x....      BL       USB_HC_Halt
    806              __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_NAK);    
   \   000000FC   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000FE   0xEB16 0x1045      ADDS     R0,R6,R5, LSL #+5
   \   00000102   0xF510 0x60A0      ADDS     R0,R0,#+1280
   \   00000106   0x2110             MOVS     R1,#+16
   \   00000108   0x6081             STR      R1,[R0, #+8]
    807              hhcd->hc[chnum].state = HC_DATATGLERR;
   \   0000010A   0x2008             MOVS     R0,#+8
   \   0000010C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000010E   0x2128             MOVS     R1,#+40
   \   00000110   0xFB01 0x4105      MLA      R1,R1,R5,R4
   \   00000114   0xF881 0x0059      STRB     R0,[R1, #+89]
    808              __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_DTERR);
   \   00000118   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000011A   0xEB16 0x1045      ADDS     R0,R6,R5, LSL #+5
   \   0000011E   0xF510 0x60A0      ADDS     R0,R0,#+1280
   \   00000122   0xF44F 0x6180      MOV      R1,#+1024
   \   00000126   0x6081             STR      R1,[R0, #+8]
    809            }    
    810            
    811            if ((USBx_HC(chnum)->HCINT) &  USB_OTG_HCINT_FRMOR)
   \                     ??HCD_HC_IN_IRQHandler_1: (+1)
   \   00000128   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000012A   0xEB16 0x1045      ADDS     R0,R6,R5, LSL #+5
   \   0000012E   0xF510 0x60A0      ADDS     R0,R0,#+1280
   \   00000132   0x6880             LDR      R0,[R0, #+8]
   \   00000134   0x0580             LSLS     R0,R0,#+22
   \   00000136   0xD51B             BPL.N    ??HCD_HC_IN_IRQHandler_4
    812            {
    813              __HAL_HCD_UNMASK_HALT_HC_INT(chnum); 
   \   00000138   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000013A   0xEB16 0x1045      ADDS     R0,R6,R5, LSL #+5
   \   0000013E   0xF510 0x60A0      ADDS     R0,R0,#+1280
   \   00000142   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000144   0xEB16 0x1145      ADDS     R1,R6,R5, LSL #+5
   \   00000148   0xF511 0x61A0      ADDS     R1,R1,#+1280
   \   0000014C   0x68C9             LDR      R1,[R1, #+12]
   \   0000014E   0xF051 0x0102      ORRS     R1,R1,#0x2
   \   00000152   0x60C1             STR      R1,[R0, #+12]
    814              USB_HC_Halt(hhcd->Instance, chnum);  
   \   00000154   0x0029             MOVS     R1,R5
   \   00000156   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000158   0x6820             LDR      R0,[R4, #+0]
   \   0000015A   0x.... 0x....      BL       USB_HC_Halt
    815              __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_FRMOR);
   \   0000015E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000160   0xEB16 0x1045      ADDS     R0,R6,R5, LSL #+5
   \   00000164   0xF510 0x60A0      ADDS     R0,R0,#+1280
   \   00000168   0xF44F 0x7100      MOV      R1,#+512
   \   0000016C   0x6081             STR      R1,[R0, #+8]
   \   0000016E   0xE1BE             B.N      ??HCD_HC_IN_IRQHandler_5
    816            }
    817            
    818            else if ((USBx_HC(chnum)->HCINT) &  USB_OTG_HCINT_XFRC)
   \                     ??HCD_HC_IN_IRQHandler_4: (+1)
   \   00000170   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000172   0xEB16 0x1045      ADDS     R0,R6,R5, LSL #+5
   \   00000176   0xF510 0x60A0      ADDS     R0,R0,#+1280
   \   0000017A   0x6880             LDR      R0,[R0, #+8]
   \   0000017C   0x07C0             LSLS     R0,R0,#+31
   \   0000017E   0xF140 0x808C      BPL.W    ??HCD_HC_IN_IRQHandler_6
    819            {
    820              
    821              if (hhcd->Init.dma_enable)
   \   00000182   0x6920             LDR      R0,[R4, #+16]
   \   00000184   0x2800             CMP      R0,#+0
   \   00000186   0xD012             BEQ.N    ??HCD_HC_IN_IRQHandler_7
    822              {
    823                hhcd->hc[chnum].xfer_count = hhcd->hc[chnum].xfer_len - \
    824                                         (USBx_HC(chnum)->HCTSIZ & USB_OTG_HCTSIZ_XFRSIZ);
   \   00000188   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000018A   0x2028             MOVS     R0,#+40
   \   0000018C   0xFB00 0x4005      MLA      R0,R0,R5,R4
   \   00000190   0x6C40             LDR      R0,[R0, #+68]
   \   00000192   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000194   0xEB16 0x1145      ADDS     R1,R6,R5, LSL #+5
   \   00000198   0xF511 0x61A0      ADDS     R1,R1,#+1280
   \   0000019C   0x6909             LDR      R1,[R1, #+16]
   \   0000019E   0x0349             LSLS     R1,R1,#+13       ;; ZeroExtS R1,R1,#+13,#+13
   \   000001A0   0x0B49             LSRS     R1,R1,#+13
   \   000001A2   0x1A40             SUBS     R0,R0,R1
   \   000001A4   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000001A6   0x2128             MOVS     R1,#+40
   \   000001A8   0xFB01 0x4105      MLA      R1,R1,R5,R4
   \   000001AC   0x6488             STR      R0,[R1, #+72]
    825              }
    826              
    827              hhcd->hc[chnum].state = HC_XFRC;
   \                     ??HCD_HC_IN_IRQHandler_7: (+1)
   \   000001AE   0x2001             MOVS     R0,#+1
   \   000001B0   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000001B2   0x2128             MOVS     R1,#+40
   \   000001B4   0xFB01 0x4105      MLA      R1,R1,R5,R4
   \   000001B8   0xF881 0x0059      STRB     R0,[R1, #+89]
    828              hhcd->hc[chnum].ErrCnt = 0;
   \   000001BC   0x2000             MOVS     R0,#+0
   \   000001BE   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000001C0   0x2128             MOVS     R1,#+40
   \   000001C2   0xFB01 0x4105      MLA      R1,R1,R5,R4
   \   000001C6   0x6548             STR      R0,[R1, #+84]
    829              __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_XFRC);
   \   000001C8   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000001CA   0xEB16 0x1045      ADDS     R0,R6,R5, LSL #+5
   \   000001CE   0xF510 0x60A0      ADDS     R0,R0,#+1280
   \   000001D2   0x2101             MOVS     R1,#+1
   \   000001D4   0x6081             STR      R1,[R0, #+8]
    830              
    831              
    832              if ((hhcd->hc[chnum].ep_type == EP_TYPE_CTRL)||
    833                  (hhcd->hc[chnum].ep_type == EP_TYPE_BULK))
   \   000001D6   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000001D8   0x2028             MOVS     R0,#+40
   \   000001DA   0xFB00 0x4005      MLA      R0,R0,R5,R4
   \   000001DE   0xF890 0x003B      LDRB     R0,[R0, #+59]
   \   000001E2   0x2800             CMP      R0,#+0
   \   000001E4   0xD007             BEQ.N    ??HCD_HC_IN_IRQHandler_8
   \   000001E6   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000001E8   0x2028             MOVS     R0,#+40
   \   000001EA   0xFB00 0x4005      MLA      R0,R0,R5,R4
   \   000001EE   0xF890 0x003B      LDRB     R0,[R0, #+59]
   \   000001F2   0x2802             CMP      R0,#+2
   \   000001F4   0xD11A             BNE.N    ??HCD_HC_IN_IRQHandler_9
    834              {
    835                __HAL_HCD_UNMASK_HALT_HC_INT(chnum); 
   \                     ??HCD_HC_IN_IRQHandler_8: (+1)
   \   000001F6   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000001F8   0xEB16 0x1045      ADDS     R0,R6,R5, LSL #+5
   \   000001FC   0xF510 0x60A0      ADDS     R0,R0,#+1280
   \   00000200   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000202   0xEB16 0x1145      ADDS     R1,R6,R5, LSL #+5
   \   00000206   0xF511 0x61A0      ADDS     R1,R1,#+1280
   \   0000020A   0x68C9             LDR      R1,[R1, #+12]
   \   0000020C   0xF051 0x0102      ORRS     R1,R1,#0x2
   \   00000210   0x60C1             STR      R1,[R0, #+12]
    836                USB_HC_Halt(hhcd->Instance, chnum); 
   \   00000212   0x0029             MOVS     R1,R5
   \   00000214   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000216   0x6820             LDR      R0,[R4, #+0]
   \   00000218   0x.... 0x....      BL       USB_HC_Halt
    837                __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_NAK);
   \   0000021C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000021E   0xEB16 0x1045      ADDS     R0,R6,R5, LSL #+5
   \   00000222   0xF510 0x60A0      ADDS     R0,R0,#+1280
   \   00000226   0x2110             MOVS     R1,#+16
   \   00000228   0x6081             STR      R1,[R0, #+8]
   \   0000022A   0xE027             B.N      ??HCD_HC_IN_IRQHandler_10
    838                
    839              }
    840              else if(hhcd->hc[chnum].ep_type == EP_TYPE_INTR)
   \                     ??HCD_HC_IN_IRQHandler_9: (+1)
   \   0000022C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000022E   0x2028             MOVS     R0,#+40
   \   00000230   0xFB00 0x4005      MLA      R0,R0,R5,R4
   \   00000234   0xF890 0x003B      LDRB     R0,[R0, #+59]
   \   00000238   0x2803             CMP      R0,#+3
   \   0000023A   0xD11F             BNE.N    ??HCD_HC_IN_IRQHandler_10
    841              {
    842                USBx_HC(chnum)->HCCHAR |= USB_OTG_HCCHAR_ODDFRM;
   \   0000023C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000023E   0xEB16 0x1045      ADDS     R0,R6,R5, LSL #+5
   \   00000242   0xF510 0x60A0      ADDS     R0,R0,#+1280
   \   00000246   0x6800             LDR      R0,[R0, #+0]
   \   00000248   0xF050 0x5000      ORRS     R0,R0,#0x20000000
   \   0000024C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000024E   0xEB16 0x1145      ADDS     R1,R6,R5, LSL #+5
   \   00000252   0xF511 0x61A0      ADDS     R1,R1,#+1280
   \   00000256   0x6008             STR      R0,[R1, #+0]
    843                hhcd->hc[chnum].urb_state = URB_DONE; 
   \   00000258   0x2001             MOVS     R0,#+1
   \   0000025A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000025C   0x2128             MOVS     R1,#+40
   \   0000025E   0xFB01 0x4105      MLA      R1,R1,R5,R4
   \   00000262   0xF881 0x0058      STRB     R0,[R1, #+88]
    844                HAL_HCD_HC_NotifyURBChange_Callback(hhcd, chnum, hhcd->hc[chnum].urb_state);
   \   00000266   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000268   0x2028             MOVS     R0,#+40
   \   0000026A   0xFB00 0x4005      MLA      R0,R0,R5,R4
   \   0000026E   0xF890 0x2058      LDRB     R2,[R0, #+88]
   \   00000272   0x0029             MOVS     R1,R5
   \   00000274   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000276   0x0020             MOVS     R0,R4
   \   00000278   0x.... 0x....      BL       HAL_HCD_HC_NotifyURBChange_Callback
    845              }
    846              hhcd->hc[chnum].toggle_in ^= 1;
   \                     ??HCD_HC_IN_IRQHandler_10: (+1)
   \   0000027C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000027E   0x2028             MOVS     R0,#+40
   \   00000280   0xFB00 0x4005      MLA      R0,R0,R5,R4
   \   00000284   0xF890 0x004C      LDRB     R0,[R0, #+76]
   \   00000288   0xF090 0x0001      EORS     R0,R0,#0x1
   \   0000028C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000028E   0x2128             MOVS     R1,#+40
   \   00000290   0xFB01 0x4105      MLA      R1,R1,R5,R4
   \   00000294   0xF881 0x004C      STRB     R0,[R1, #+76]
   \   00000298   0xE129             B.N      ??HCD_HC_IN_IRQHandler_5
    847              
    848            }
    849            else if ((USBx_HC(chnum)->HCINT) &  USB_OTG_HCINT_CHH)
   \                     ??HCD_HC_IN_IRQHandler_6: (+1)
   \   0000029A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000029C   0xEB16 0x1045      ADDS     R0,R6,R5, LSL #+5
   \   000002A0   0xF510 0x60A0      ADDS     R0,R0,#+1280
   \   000002A4   0x6880             LDR      R0,[R0, #+8]
   \   000002A6   0x0780             LSLS     R0,R0,#+30
   \   000002A8   0xF140 0x808F      BPL.W    ??HCD_HC_IN_IRQHandler_11
    850            {
    851              __HAL_HCD_MASK_HALT_HC_INT(chnum); 
   \   000002AC   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000002AE   0xEB16 0x1045      ADDS     R0,R6,R5, LSL #+5
   \   000002B2   0xF510 0x60A0      ADDS     R0,R0,#+1280
   \   000002B6   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000002B8   0xEB16 0x1145      ADDS     R1,R6,R5, LSL #+5
   \   000002BC   0xF511 0x61A0      ADDS     R1,R1,#+1280
   \   000002C0   0x68C9             LDR      R1,[R1, #+12]
   \   000002C2   0xF031 0x0102      BICS     R1,R1,#0x2
   \   000002C6   0x60C1             STR      R1,[R0, #+12]
    852              
    853              if(hhcd->hc[chnum].state == HC_XFRC)
   \   000002C8   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000002CA   0x2028             MOVS     R0,#+40
   \   000002CC   0xFB00 0x4005      MLA      R0,R0,R5,R4
   \   000002D0   0xF890 0x0059      LDRB     R0,[R0, #+89]
   \   000002D4   0x2801             CMP      R0,#+1
   \   000002D6   0xD107             BNE.N    ??HCD_HC_IN_IRQHandler_12
    854              {
    855                hhcd->hc[chnum].urb_state  = URB_DONE;      
   \   000002D8   0x2001             MOVS     R0,#+1
   \   000002DA   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000002DC   0x2128             MOVS     R1,#+40
   \   000002DE   0xFB01 0x4105      MLA      R1,R1,R5,R4
   \   000002E2   0xF881 0x0058      STRB     R0,[R1, #+88]
   \   000002E6   0xE05D             B.N      ??HCD_HC_IN_IRQHandler_13
    856              }
    857              
    858              else if (hhcd->hc[chnum].state == HC_STALL) 
   \                     ??HCD_HC_IN_IRQHandler_12: (+1)
   \   000002E8   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000002EA   0x2028             MOVS     R0,#+40
   \   000002EC   0xFB00 0x4005      MLA      R0,R0,R5,R4
   \   000002F0   0xF890 0x0059      LDRB     R0,[R0, #+89]
   \   000002F4   0x2805             CMP      R0,#+5
   \   000002F6   0xD107             BNE.N    ??HCD_HC_IN_IRQHandler_14
    859              {
    860                hhcd->hc[chnum].urb_state  = URB_STALL;
   \   000002F8   0x2005             MOVS     R0,#+5
   \   000002FA   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000002FC   0x2128             MOVS     R1,#+40
   \   000002FE   0xFB01 0x4105      MLA      R1,R1,R5,R4
   \   00000302   0xF881 0x0058      STRB     R0,[R1, #+88]
   \   00000306   0xE04D             B.N      ??HCD_HC_IN_IRQHandler_13
    861              }   
    862              
    863              else if((hhcd->hc[chnum].state == HC_XACTERR) ||
    864                      (hhcd->hc[chnum].state == HC_DATATGLERR))
   \                     ??HCD_HC_IN_IRQHandler_14: (+1)
   \   00000308   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000030A   0x2028             MOVS     R0,#+40
   \   0000030C   0xFB00 0x4005      MLA      R0,R0,R5,R4
   \   00000310   0xF890 0x0059      LDRB     R0,[R0, #+89]
   \   00000314   0x2806             CMP      R0,#+6
   \   00000316   0xD007             BEQ.N    ??HCD_HC_IN_IRQHandler_15
   \   00000318   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000031A   0x2028             MOVS     R0,#+40
   \   0000031C   0xFB00 0x4005      MLA      R0,R0,R5,R4
   \   00000320   0xF890 0x0059      LDRB     R0,[R0, #+89]
   \   00000324   0x2808             CMP      R0,#+8
   \   00000326   0xD13D             BNE.N    ??HCD_HC_IN_IRQHandler_13
    865              {
    866                if(hhcd->hc[chnum].ErrCnt++ > 3)
   \                     ??HCD_HC_IN_IRQHandler_15: (+1)
   \   00000328   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000032A   0x2028             MOVS     R0,#+40
   \   0000032C   0xFB00 0x4005      MLA      R0,R0,R5,R4
   \   00000330   0x6D40             LDR      R0,[R0, #+84]
   \   00000332   0x1C41             ADDS     R1,R0,#+1
   \   00000334   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000336   0x2228             MOVS     R2,#+40
   \   00000338   0xFB02 0x4205      MLA      R2,R2,R5,R4
   \   0000033C   0x6551             STR      R1,[R2, #+84]
   \   0000033E   0x2804             CMP      R0,#+4
   \   00000340   0xD30D             BCC.N    ??HCD_HC_IN_IRQHandler_16
    867                {      
    868                  hhcd->hc[chnum].ErrCnt = 0;
   \   00000342   0x2000             MOVS     R0,#+0
   \   00000344   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000346   0x2128             MOVS     R1,#+40
   \   00000348   0xFB01 0x4105      MLA      R1,R1,R5,R4
   \   0000034C   0x6548             STR      R0,[R1, #+84]
    869                  hhcd->hc[chnum].urb_state = URB_ERROR;
   \   0000034E   0x2004             MOVS     R0,#+4
   \   00000350   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000352   0x2128             MOVS     R1,#+40
   \   00000354   0xFB01 0x4105      MLA      R1,R1,R5,R4
   \   00000358   0xF881 0x0058      STRB     R0,[R1, #+88]
   \   0000035C   0xE006             B.N      ??HCD_HC_IN_IRQHandler_17
    870                }
    871                else
    872                {
    873                  hhcd->hc[chnum].urb_state = URB_NOTREADY;
   \                     ??HCD_HC_IN_IRQHandler_16: (+1)
   \   0000035E   0x2002             MOVS     R0,#+2
   \   00000360   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000362   0x2128             MOVS     R1,#+40
   \   00000364   0xFB01 0x4105      MLA      R1,R1,R5,R4
   \   00000368   0xF881 0x0058      STRB     R0,[R1, #+88]
    874                }
    875                
    876                /* re-activate the channel  */
    877                USBx_HC(chnum)->HCCHAR &= ~USB_OTG_HCCHAR_CHDIS;         
   \                     ??HCD_HC_IN_IRQHandler_17: (+1)
   \   0000036C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000036E   0xEB16 0x1045      ADDS     R0,R6,R5, LSL #+5
   \   00000372   0xF510 0x60A0      ADDS     R0,R0,#+1280
   \   00000376   0x6800             LDR      R0,[R0, #+0]
   \   00000378   0xF030 0x4080      BICS     R0,R0,#0x40000000
   \   0000037C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000037E   0xEB16 0x1145      ADDS     R1,R6,R5, LSL #+5
   \   00000382   0xF511 0x61A0      ADDS     R1,R1,#+1280
   \   00000386   0x6008             STR      R0,[R1, #+0]
    878                USBx_HC(chnum)->HCCHAR |= USB_OTG_HCCHAR_CHENA;      
   \   00000388   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000038A   0xEB16 0x1045      ADDS     R0,R6,R5, LSL #+5
   \   0000038E   0xF510 0x60A0      ADDS     R0,R0,#+1280
   \   00000392   0x6800             LDR      R0,[R0, #+0]
   \   00000394   0xF050 0x4000      ORRS     R0,R0,#0x80000000
   \   00000398   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000039A   0xEB16 0x1145      ADDS     R1,R6,R5, LSL #+5
   \   0000039E   0xF511 0x61A0      ADDS     R1,R1,#+1280
   \   000003A2   0x6008             STR      R0,[R1, #+0]
    879              }
    880              __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_CHH);
   \                     ??HCD_HC_IN_IRQHandler_13: (+1)
   \   000003A4   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000003A6   0xEB16 0x1045      ADDS     R0,R6,R5, LSL #+5
   \   000003AA   0xF510 0x60A0      ADDS     R0,R0,#+1280
   \   000003AE   0x2102             MOVS     R1,#+2
   \   000003B0   0x6081             STR      R1,[R0, #+8]
    881              HAL_HCD_HC_NotifyURBChange_Callback(hhcd, chnum, hhcd->hc[chnum].urb_state);
   \   000003B2   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000003B4   0x2028             MOVS     R0,#+40
   \   000003B6   0xFB00 0x4005      MLA      R0,R0,R5,R4
   \   000003BA   0xF890 0x2058      LDRB     R2,[R0, #+88]
   \   000003BE   0x0029             MOVS     R1,R5
   \   000003C0   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000003C2   0x0020             MOVS     R0,R4
   \   000003C4   0x.... 0x....      BL       HAL_HCD_HC_NotifyURBChange_Callback
   \   000003C8   0xE091             B.N      ??HCD_HC_IN_IRQHandler_5
    882            }  
    883            
    884            else if ((USBx_HC(chnum)->HCINT) &  USB_OTG_HCINT_TXERR)
   \                     ??HCD_HC_IN_IRQHandler_11: (+1)
   \   000003CA   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000003CC   0xEB16 0x1045      ADDS     R0,R6,R5, LSL #+5
   \   000003D0   0xF510 0x60A0      ADDS     R0,R0,#+1280
   \   000003D4   0x6880             LDR      R0,[R0, #+8]
   \   000003D6   0x0600             LSLS     R0,R0,#+24
   \   000003D8   0xD52C             BPL.N    ??HCD_HC_IN_IRQHandler_18
    885            {
    886              __HAL_HCD_UNMASK_HALT_HC_INT(chnum); 
   \   000003DA   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000003DC   0xEB16 0x1045      ADDS     R0,R6,R5, LSL #+5
   \   000003E0   0xF510 0x60A0      ADDS     R0,R0,#+1280
   \   000003E4   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000003E6   0xEB16 0x1145      ADDS     R1,R6,R5, LSL #+5
   \   000003EA   0xF511 0x61A0      ADDS     R1,R1,#+1280
   \   000003EE   0x68C9             LDR      R1,[R1, #+12]
   \   000003F0   0xF051 0x0102      ORRS     R1,R1,#0x2
   \   000003F4   0x60C1             STR      R1,[R0, #+12]
    887               hhcd->hc[chnum].ErrCnt++;
   \   000003F6   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000003F8   0x2028             MOVS     R0,#+40
   \   000003FA   0xFB00 0x4005      MLA      R0,R0,R5,R4
   \   000003FE   0x6D40             LDR      R0,[R0, #+84]
   \   00000400   0x1C40             ADDS     R0,R0,#+1
   \   00000402   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000404   0x2128             MOVS     R1,#+40
   \   00000406   0xFB01 0x4105      MLA      R1,R1,R5,R4
   \   0000040A   0x6548             STR      R0,[R1, #+84]
    888               hhcd->hc[chnum].state = HC_XACTERR;
   \   0000040C   0x2006             MOVS     R0,#+6
   \   0000040E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000410   0x2128             MOVS     R1,#+40
   \   00000412   0xFB01 0x4105      MLA      R1,R1,R5,R4
   \   00000416   0xF881 0x0059      STRB     R0,[R1, #+89]
    889               USB_HC_Halt(hhcd->Instance, chnum);     
   \   0000041A   0x0029             MOVS     R1,R5
   \   0000041C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000041E   0x6820             LDR      R0,[R4, #+0]
   \   00000420   0x.... 0x....      BL       USB_HC_Halt
    890               __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_TXERR);
   \   00000424   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000426   0xEB16 0x1045      ADDS     R0,R6,R5, LSL #+5
   \   0000042A   0xF510 0x60A0      ADDS     R0,R0,#+1280
   \   0000042E   0x2180             MOVS     R1,#+128
   \   00000430   0x6081             STR      R1,[R0, #+8]
   \   00000432   0xE05C             B.N      ??HCD_HC_IN_IRQHandler_5
    891            }
    892            else if ((USBx_HC(chnum)->HCINT) &  USB_OTG_HCINT_NAK)
   \                     ??HCD_HC_IN_IRQHandler_18: (+1)
   \   00000434   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000436   0xEB16 0x1045      ADDS     R0,R6,R5, LSL #+5
   \   0000043A   0xF510 0x60A0      ADDS     R0,R0,#+1280
   \   0000043E   0x6880             LDR      R0,[R0, #+8]
   \   00000440   0x06C0             LSLS     R0,R0,#+27
   \   00000442   0xD554             BPL.N    ??HCD_HC_IN_IRQHandler_5
    893            {  
    894              if(hhcd->hc[chnum].ep_type == EP_TYPE_INTR)
   \   00000444   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000446   0x2028             MOVS     R0,#+40
   \   00000448   0xFB00 0x4005      MLA      R0,R0,R5,R4
   \   0000044C   0xF890 0x003B      LDRB     R0,[R0, #+59]
   \   00000450   0x2803             CMP      R0,#+3
   \   00000452   0xD112             BNE.N    ??HCD_HC_IN_IRQHandler_19
    895              {
    896                __HAL_HCD_UNMASK_HALT_HC_INT(chnum); 
   \   00000454   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000456   0xEB16 0x1045      ADDS     R0,R6,R5, LSL #+5
   \   0000045A   0xF510 0x60A0      ADDS     R0,R0,#+1280
   \   0000045E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000460   0xEB16 0x1145      ADDS     R1,R6,R5, LSL #+5
   \   00000464   0xF511 0x61A0      ADDS     R1,R1,#+1280
   \   00000468   0x68C9             LDR      R1,[R1, #+12]
   \   0000046A   0xF051 0x0102      ORRS     R1,R1,#0x2
   \   0000046E   0x60C1             STR      R1,[R0, #+12]
    897                USB_HC_Halt(hhcd->Instance, chnum);  
   \   00000470   0x0029             MOVS     R1,R5
   \   00000472   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000474   0x6820             LDR      R0,[R4, #+0]
   \   00000476   0x.... 0x....      BL       USB_HC_Halt
    898              }
    899              
    900              hhcd->hc[chnum].state = HC_NAK;
   \                     ??HCD_HC_IN_IRQHandler_19: (+1)
   \   0000047A   0x2003             MOVS     R0,#+3
   \   0000047C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000047E   0x2128             MOVS     R1,#+40
   \   00000480   0xFB01 0x4105      MLA      R1,R1,R5,R4
   \   00000484   0xF881 0x0059      STRB     R0,[R1, #+89]
    901              __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_NAK);
   \   00000488   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000048A   0xEB16 0x1045      ADDS     R0,R6,R5, LSL #+5
   \   0000048E   0xF510 0x60A0      ADDS     R0,R0,#+1280
   \   00000492   0x2110             MOVS     R1,#+16
   \   00000494   0x6081             STR      R1,[R0, #+8]
    902               
    903              if  ((hhcd->hc[chnum].ep_type == EP_TYPE_CTRL)||
    904                   (hhcd->hc[chnum].ep_type == EP_TYPE_BULK))
   \   00000496   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000498   0x2028             MOVS     R0,#+40
   \   0000049A   0xFB00 0x4005      MLA      R0,R0,R5,R4
   \   0000049E   0xF890 0x003B      LDRB     R0,[R0, #+59]
   \   000004A2   0x2800             CMP      R0,#+0
   \   000004A4   0xD007             BEQ.N    ??HCD_HC_IN_IRQHandler_20
   \   000004A6   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000004A8   0x2028             MOVS     R0,#+40
   \   000004AA   0xFB00 0x4005      MLA      R0,R0,R5,R4
   \   000004AE   0xF890 0x003B      LDRB     R0,[R0, #+59]
   \   000004B2   0x2802             CMP      R0,#+2
   \   000004B4   0xD11B             BNE.N    ??HCD_HC_IN_IRQHandler_5
    905              {
    906                /* re-activate the channel  */
    907                USBx_HC(chnum)->HCCHAR &= ~USB_OTG_HCCHAR_CHDIS;         
   \                     ??HCD_HC_IN_IRQHandler_20: (+1)
   \   000004B6   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000004B8   0xEB16 0x1045      ADDS     R0,R6,R5, LSL #+5
   \   000004BC   0xF510 0x60A0      ADDS     R0,R0,#+1280
   \   000004C0   0x6800             LDR      R0,[R0, #+0]
   \   000004C2   0xF030 0x4080      BICS     R0,R0,#0x40000000
   \   000004C6   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000004C8   0xEB16 0x1145      ADDS     R1,R6,R5, LSL #+5
   \   000004CC   0xF511 0x61A0      ADDS     R1,R1,#+1280
   \   000004D0   0x6008             STR      R0,[R1, #+0]
    908                USBx_HC(chnum)->HCCHAR |= USB_OTG_HCCHAR_CHENA;
   \   000004D2   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000004D4   0xEB16 0x1045      ADDS     R0,R6,R5, LSL #+5
   \   000004D8   0xF510 0x60A0      ADDS     R0,R0,#+1280
   \   000004DC   0x6800             LDR      R0,[R0, #+0]
   \   000004DE   0xF050 0x4000      ORRS     R0,R0,#0x80000000
   \   000004E2   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000004E4   0xEB16 0x1145      ADDS     R1,R6,R5, LSL #+5
   \   000004E8   0xF511 0x61A0      ADDS     R1,R1,#+1280
   \   000004EC   0x6008             STR      R0,[R1, #+0]
    909              }
    910            }
    911          }
   \                     ??HCD_HC_IN_IRQHandler_5: (+1)
   \   000004EE   0xBD70             POP      {R4-R6,PC}       ;; return
    912          
    913          /**
    914            * @brief  This function handles Host Channel OUT interrupt requests.
    915            * @param  hhcd: HCD handle
    916            * @param  chnum: Channel number.
    917            *         This parameter can be a value from 1 to 15
    918            * @retval none
    919            */

   \                                 In section .text, align 2, keep-with-next
    920          static void HCD_HC_OUT_IRQHandler  (HCD_HandleTypeDef *hhcd, uint8_t chnum)
    921          {
   \                     HCD_HC_OUT_IRQHandler: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    922            USB_OTG_GlobalTypeDef *USBx = hhcd->Instance;
   \   00000006   0x6826             LDR      R6,[R4, #+0]
    923            
    924            if ((USBx_HC(chnum)->HCINT) &  USB_OTG_HCINT_AHBERR)
   \   00000008   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000000A   0xEB16 0x1045      ADDS     R0,R6,R5, LSL #+5
   \   0000000E   0xF510 0x60A0      ADDS     R0,R0,#+1280
   \   00000012   0x6880             LDR      R0,[R0, #+8]
   \   00000014   0x0740             LSLS     R0,R0,#+29
   \   00000016   0xD515             BPL.N    ??HCD_HC_OUT_IRQHandler_0
    925            {
    926              __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_AHBERR);
   \   00000018   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000001A   0xEB16 0x1045      ADDS     R0,R6,R5, LSL #+5
   \   0000001E   0xF510 0x60A0      ADDS     R0,R0,#+1280
   \   00000022   0x2104             MOVS     R1,#+4
   \   00000024   0x6081             STR      R1,[R0, #+8]
    927              __HAL_HCD_UNMASK_HALT_HC_INT(chnum);
   \   00000026   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000028   0xEB16 0x1045      ADDS     R0,R6,R5, LSL #+5
   \   0000002C   0xF510 0x60A0      ADDS     R0,R0,#+1280
   \   00000030   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000032   0xEB16 0x1145      ADDS     R1,R6,R5, LSL #+5
   \   00000036   0xF511 0x61A0      ADDS     R1,R1,#+1280
   \   0000003A   0x68C9             LDR      R1,[R1, #+12]
   \   0000003C   0xF051 0x0102      ORRS     R1,R1,#0x2
   \   00000040   0x60C1             STR      R1,[R0, #+12]
   \   00000042   0xE248             B.N      ??HCD_HC_OUT_IRQHandler_1
    928            }  
    929            else if ((USBx_HC(chnum)->HCINT) &  USB_OTG_HCINT_ACK)
   \                     ??HCD_HC_OUT_IRQHandler_0: (+1)
   \   00000044   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000046   0xEB16 0x1045      ADDS     R0,R6,R5, LSL #+5
   \   0000004A   0xF510 0x60A0      ADDS     R0,R0,#+1280
   \   0000004E   0x6880             LDR      R0,[R0, #+8]
   \   00000050   0x0680             LSLS     R0,R0,#+26
   \   00000052   0xD531             BPL.N    ??HCD_HC_OUT_IRQHandler_2
    930            {
    931              __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_ACK);
   \   00000054   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000056   0xEB16 0x1045      ADDS     R0,R6,R5, LSL #+5
   \   0000005A   0xF510 0x60A0      ADDS     R0,R0,#+1280
   \   0000005E   0x2120             MOVS     R1,#+32
   \   00000060   0x6081             STR      R1,[R0, #+8]
    932              
    933              if( hhcd->hc[chnum].do_ping == 1)
   \   00000062   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000064   0x2028             MOVS     R0,#+40
   \   00000066   0xFB00 0x4005      MLA      R0,R0,R5,R4
   \   0000006A   0xF890 0x0039      LDRB     R0,[R0, #+57]
   \   0000006E   0x2801             CMP      R0,#+1
   \   00000070   0xF040 0x8231      BNE.W    ??HCD_HC_OUT_IRQHandler_1
    934              {
    935                hhcd->hc[chnum].state = HC_NYET;     
   \   00000074   0x2004             MOVS     R0,#+4
   \   00000076   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000078   0x2128             MOVS     R1,#+40
   \   0000007A   0xFB01 0x4105      MLA      R1,R1,R5,R4
   \   0000007E   0xF881 0x0059      STRB     R0,[R1, #+89]
    936                __HAL_HCD_UNMASK_HALT_HC_INT(chnum); 
   \   00000082   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000084   0xEB16 0x1045      ADDS     R0,R6,R5, LSL #+5
   \   00000088   0xF510 0x60A0      ADDS     R0,R0,#+1280
   \   0000008C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000008E   0xEB16 0x1145      ADDS     R1,R6,R5, LSL #+5
   \   00000092   0xF511 0x61A0      ADDS     R1,R1,#+1280
   \   00000096   0x68C9             LDR      R1,[R1, #+12]
   \   00000098   0xF051 0x0102      ORRS     R1,R1,#0x2
   \   0000009C   0x60C1             STR      R1,[R0, #+12]
    937                USB_HC_Halt(hhcd->Instance, chnum); 
   \   0000009E   0x0029             MOVS     R1,R5
   \   000000A0   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000A2   0x6820             LDR      R0,[R4, #+0]
   \   000000A4   0x.... 0x....      BL       USB_HC_Halt
    938                hhcd->hc[chnum].urb_state  = URB_NOTREADY;
   \   000000A8   0x2002             MOVS     R0,#+2
   \   000000AA   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000AC   0x2128             MOVS     R1,#+40
   \   000000AE   0xFB01 0x4105      MLA      R1,R1,R5,R4
   \   000000B2   0xF881 0x0058      STRB     R0,[R1, #+88]
   \   000000B6   0xE20E             B.N      ??HCD_HC_OUT_IRQHandler_1
    939              }
    940            }
    941            
    942            else if ((USBx_HC(chnum)->HCINT) &  USB_OTG_HCINT_NYET)
   \                     ??HCD_HC_OUT_IRQHandler_2: (+1)
   \   000000B8   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000BA   0xEB16 0x1045      ADDS     R0,R6,R5, LSL #+5
   \   000000BE   0xF510 0x60A0      ADDS     R0,R0,#+1280
   \   000000C2   0x6880             LDR      R0,[R0, #+8]
   \   000000C4   0x0640             LSLS     R0,R0,#+25
   \   000000C6   0xD527             BPL.N    ??HCD_HC_OUT_IRQHandler_3
    943            {
    944              hhcd->hc[chnum].state = HC_NYET;
   \   000000C8   0x2004             MOVS     R0,#+4
   \   000000CA   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000CC   0x2128             MOVS     R1,#+40
   \   000000CE   0xFB01 0x4105      MLA      R1,R1,R5,R4
   \   000000D2   0xF881 0x0059      STRB     R0,[R1, #+89]
    945              hhcd->hc[chnum].ErrCnt= 0;    
   \   000000D6   0x2000             MOVS     R0,#+0
   \   000000D8   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000DA   0x2128             MOVS     R1,#+40
   \   000000DC   0xFB01 0x4105      MLA      R1,R1,R5,R4
   \   000000E0   0x6548             STR      R0,[R1, #+84]
    946              __HAL_HCD_UNMASK_HALT_HC_INT(chnum); 
   \   000000E2   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000E4   0xEB16 0x1045      ADDS     R0,R6,R5, LSL #+5
   \   000000E8   0xF510 0x60A0      ADDS     R0,R0,#+1280
   \   000000EC   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000EE   0xEB16 0x1145      ADDS     R1,R6,R5, LSL #+5
   \   000000F2   0xF511 0x61A0      ADDS     R1,R1,#+1280
   \   000000F6   0x68C9             LDR      R1,[R1, #+12]
   \   000000F8   0xF051 0x0102      ORRS     R1,R1,#0x2
   \   000000FC   0x60C1             STR      R1,[R0, #+12]
    947              USB_HC_Halt(hhcd->Instance, chnum);      
   \   000000FE   0x0029             MOVS     R1,R5
   \   00000100   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000102   0x6820             LDR      R0,[R4, #+0]
   \   00000104   0x.... 0x....      BL       USB_HC_Halt
    948              __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_NYET);
   \   00000108   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000010A   0xEB16 0x1045      ADDS     R0,R6,R5, LSL #+5
   \   0000010E   0xF510 0x60A0      ADDS     R0,R0,#+1280
   \   00000112   0x2140             MOVS     R1,#+64
   \   00000114   0x6081             STR      R1,[R0, #+8]
   \   00000116   0xE1DE             B.N      ??HCD_HC_OUT_IRQHandler_1
    949              
    950            }  
    951            
    952            else if ((USBx_HC(chnum)->HCINT) &  USB_OTG_HCINT_FRMOR)
   \                     ??HCD_HC_OUT_IRQHandler_3: (+1)
   \   00000118   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000011A   0xEB16 0x1045      ADDS     R0,R6,R5, LSL #+5
   \   0000011E   0xF510 0x60A0      ADDS     R0,R0,#+1280
   \   00000122   0x6880             LDR      R0,[R0, #+8]
   \   00000124   0x0580             LSLS     R0,R0,#+22
   \   00000126   0xD51B             BPL.N    ??HCD_HC_OUT_IRQHandler_4
    953            {
    954              __HAL_HCD_UNMASK_HALT_HC_INT(chnum); 
   \   00000128   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000012A   0xEB16 0x1045      ADDS     R0,R6,R5, LSL #+5
   \   0000012E   0xF510 0x60A0      ADDS     R0,R0,#+1280
   \   00000132   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000134   0xEB16 0x1145      ADDS     R1,R6,R5, LSL #+5
   \   00000138   0xF511 0x61A0      ADDS     R1,R1,#+1280
   \   0000013C   0x68C9             LDR      R1,[R1, #+12]
   \   0000013E   0xF051 0x0102      ORRS     R1,R1,#0x2
   \   00000142   0x60C1             STR      R1,[R0, #+12]
    955              USB_HC_Halt(hhcd->Instance, chnum);  
   \   00000144   0x0029             MOVS     R1,R5
   \   00000146   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000148   0x6820             LDR      R0,[R4, #+0]
   \   0000014A   0x.... 0x....      BL       USB_HC_Halt
    956              __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_FRMOR);
   \   0000014E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000150   0xEB16 0x1045      ADDS     R0,R6,R5, LSL #+5
   \   00000154   0xF510 0x60A0      ADDS     R0,R0,#+1280
   \   00000158   0xF44F 0x7100      MOV      R1,#+512
   \   0000015C   0x6081             STR      R1,[R0, #+8]
   \   0000015E   0xE1BA             B.N      ??HCD_HC_OUT_IRQHandler_1
    957            }
    958            
    959            else if ((USBx_HC(chnum)->HCINT) &  USB_OTG_HCINT_XFRC)
   \                     ??HCD_HC_OUT_IRQHandler_4: (+1)
   \   00000160   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000162   0xEB16 0x1045      ADDS     R0,R6,R5, LSL #+5
   \   00000166   0xF510 0x60A0      ADDS     R0,R0,#+1280
   \   0000016A   0x6880             LDR      R0,[R0, #+8]
   \   0000016C   0x07C0             LSLS     R0,R0,#+31
   \   0000016E   0xD527             BPL.N    ??HCD_HC_OUT_IRQHandler_5
    960            {
    961                hhcd->hc[chnum].ErrCnt = 0;  
   \   00000170   0x2000             MOVS     R0,#+0
   \   00000172   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000174   0x2128             MOVS     R1,#+40
   \   00000176   0xFB01 0x4105      MLA      R1,R1,R5,R4
   \   0000017A   0x6548             STR      R0,[R1, #+84]
    962              __HAL_HCD_UNMASK_HALT_HC_INT(chnum);
   \   0000017C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000017E   0xEB16 0x1045      ADDS     R0,R6,R5, LSL #+5
   \   00000182   0xF510 0x60A0      ADDS     R0,R0,#+1280
   \   00000186   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000188   0xEB16 0x1145      ADDS     R1,R6,R5, LSL #+5
   \   0000018C   0xF511 0x61A0      ADDS     R1,R1,#+1280
   \   00000190   0x68C9             LDR      R1,[R1, #+12]
   \   00000192   0xF051 0x0102      ORRS     R1,R1,#0x2
   \   00000196   0x60C1             STR      R1,[R0, #+12]
    963              USB_HC_Halt(hhcd->Instance, chnum);   
   \   00000198   0x0029             MOVS     R1,R5
   \   0000019A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000019C   0x6820             LDR      R0,[R4, #+0]
   \   0000019E   0x.... 0x....      BL       USB_HC_Halt
    964              __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_XFRC);
   \   000001A2   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000001A4   0xEB16 0x1045      ADDS     R0,R6,R5, LSL #+5
   \   000001A8   0xF510 0x60A0      ADDS     R0,R0,#+1280
   \   000001AC   0x2101             MOVS     R1,#+1
   \   000001AE   0x6081             STR      R1,[R0, #+8]
    965              hhcd->hc[chnum].state = HC_XFRC;
   \   000001B0   0x2001             MOVS     R0,#+1
   \   000001B2   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000001B4   0x2128             MOVS     R1,#+40
   \   000001B6   0xFB01 0x4105      MLA      R1,R1,R5,R4
   \   000001BA   0xF881 0x0059      STRB     R0,[R1, #+89]
   \   000001BE   0xE18A             B.N      ??HCD_HC_OUT_IRQHandler_1
    966          
    967            }  
    968          
    969            else if ((USBx_HC(chnum)->HCINT) &  USB_OTG_HCINT_STALL)  
   \                     ??HCD_HC_OUT_IRQHandler_5: (+1)
   \   000001C0   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000001C2   0xEB16 0x1045      ADDS     R0,R6,R5, LSL #+5
   \   000001C6   0xF510 0x60A0      ADDS     R0,R0,#+1280
   \   000001CA   0x6880             LDR      R0,[R0, #+8]
   \   000001CC   0x0700             LSLS     R0,R0,#+28
   \   000001CE   0xD521             BPL.N    ??HCD_HC_OUT_IRQHandler_6
    970            {
    971              __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_STALL);  
   \   000001D0   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000001D2   0xEB16 0x1045      ADDS     R0,R6,R5, LSL #+5
   \   000001D6   0xF510 0x60A0      ADDS     R0,R0,#+1280
   \   000001DA   0x2108             MOVS     R1,#+8
   \   000001DC   0x6081             STR      R1,[R0, #+8]
    972              __HAL_HCD_UNMASK_HALT_HC_INT(chnum);
   \   000001DE   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000001E0   0xEB16 0x1045      ADDS     R0,R6,R5, LSL #+5
   \   000001E4   0xF510 0x60A0      ADDS     R0,R0,#+1280
   \   000001E8   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000001EA   0xEB16 0x1145      ADDS     R1,R6,R5, LSL #+5
   \   000001EE   0xF511 0x61A0      ADDS     R1,R1,#+1280
   \   000001F2   0x68C9             LDR      R1,[R1, #+12]
   \   000001F4   0xF051 0x0102      ORRS     R1,R1,#0x2
   \   000001F8   0x60C1             STR      R1,[R0, #+12]
    973              USB_HC_Halt(hhcd->Instance, chnum);   
   \   000001FA   0x0029             MOVS     R1,R5
   \   000001FC   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000001FE   0x6820             LDR      R0,[R4, #+0]
   \   00000200   0x.... 0x....      BL       USB_HC_Halt
    974              hhcd->hc[chnum].state = HC_STALL;    
   \   00000204   0x2005             MOVS     R0,#+5
   \   00000206   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000208   0x2128             MOVS     R1,#+40
   \   0000020A   0xFB01 0x4105      MLA      R1,R1,R5,R4
   \   0000020E   0xF881 0x0059      STRB     R0,[R1, #+89]
   \   00000212   0xE160             B.N      ??HCD_HC_OUT_IRQHandler_1
    975            }
    976          
    977            else if ((USBx_HC(chnum)->HCINT) &  USB_OTG_HCINT_NAK)
   \                     ??HCD_HC_OUT_IRQHandler_6: (+1)
   \   00000214   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000216   0xEB16 0x1045      ADDS     R0,R6,R5, LSL #+5
   \   0000021A   0xF510 0x60A0      ADDS     R0,R0,#+1280
   \   0000021E   0x6880             LDR      R0,[R0, #+8]
   \   00000220   0x06C0             LSLS     R0,R0,#+27
   \   00000222   0xD527             BPL.N    ??HCD_HC_OUT_IRQHandler_7
    978            {  
    979              hhcd->hc[chnum].ErrCnt = 0;  
   \   00000224   0x2000             MOVS     R0,#+0
   \   00000226   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000228   0x2128             MOVS     R1,#+40
   \   0000022A   0xFB01 0x4105      MLA      R1,R1,R5,R4
   \   0000022E   0x6548             STR      R0,[R1, #+84]
    980              __HAL_HCD_UNMASK_HALT_HC_INT(chnum); 
   \   00000230   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000232   0xEB16 0x1045      ADDS     R0,R6,R5, LSL #+5
   \   00000236   0xF510 0x60A0      ADDS     R0,R0,#+1280
   \   0000023A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000023C   0xEB16 0x1145      ADDS     R1,R6,R5, LSL #+5
   \   00000240   0xF511 0x61A0      ADDS     R1,R1,#+1280
   \   00000244   0x68C9             LDR      R1,[R1, #+12]
   \   00000246   0xF051 0x0102      ORRS     R1,R1,#0x2
   \   0000024A   0x60C1             STR      R1,[R0, #+12]
    981              USB_HC_Halt(hhcd->Instance, chnum);   
   \   0000024C   0x0029             MOVS     R1,R5
   \   0000024E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000250   0x6820             LDR      R0,[R4, #+0]
   \   00000252   0x.... 0x....      BL       USB_HC_Halt
    982              hhcd->hc[chnum].state = HC_NAK;
   \   00000256   0x2003             MOVS     R0,#+3
   \   00000258   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000025A   0x2128             MOVS     R1,#+40
   \   0000025C   0xFB01 0x4105      MLA      R1,R1,R5,R4
   \   00000260   0xF881 0x0059      STRB     R0,[R1, #+89]
    983              __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_NAK);
   \   00000264   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000266   0xEB16 0x1045      ADDS     R0,R6,R5, LSL #+5
   \   0000026A   0xF510 0x60A0      ADDS     R0,R0,#+1280
   \   0000026E   0x2110             MOVS     R1,#+16
   \   00000270   0x6081             STR      R1,[R0, #+8]
   \   00000272   0xE130             B.N      ??HCD_HC_OUT_IRQHandler_1
    984            }
    985          
    986            else if ((USBx_HC(chnum)->HCINT) &  USB_OTG_HCINT_TXERR)
   \                     ??HCD_HC_OUT_IRQHandler_7: (+1)
   \   00000274   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000276   0xEB16 0x1045      ADDS     R0,R6,R5, LSL #+5
   \   0000027A   0xF510 0x60A0      ADDS     R0,R0,#+1280
   \   0000027E   0x6880             LDR      R0,[R0, #+8]
   \   00000280   0x0600             LSLS     R0,R0,#+24
   \   00000282   0xD521             BPL.N    ??HCD_HC_OUT_IRQHandler_8
    987            {
    988              __HAL_HCD_UNMASK_HALT_HC_INT(chnum); 
   \   00000284   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000286   0xEB16 0x1045      ADDS     R0,R6,R5, LSL #+5
   \   0000028A   0xF510 0x60A0      ADDS     R0,R0,#+1280
   \   0000028E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000290   0xEB16 0x1145      ADDS     R1,R6,R5, LSL #+5
   \   00000294   0xF511 0x61A0      ADDS     R1,R1,#+1280
   \   00000298   0x68C9             LDR      R1,[R1, #+12]
   \   0000029A   0xF051 0x0102      ORRS     R1,R1,#0x2
   \   0000029E   0x60C1             STR      R1,[R0, #+12]
    989              USB_HC_Halt(hhcd->Instance, chnum);      
   \   000002A0   0x0029             MOVS     R1,R5
   \   000002A2   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000002A4   0x6820             LDR      R0,[R4, #+0]
   \   000002A6   0x.... 0x....      BL       USB_HC_Halt
    990              hhcd->hc[chnum].state = HC_XACTERR;  
   \   000002AA   0x2006             MOVS     R0,#+6
   \   000002AC   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000002AE   0x2128             MOVS     R1,#+40
   \   000002B0   0xFB01 0x4105      MLA      R1,R1,R5,R4
   \   000002B4   0xF881 0x0059      STRB     R0,[R1, #+89]
    991               __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_TXERR);
   \   000002B8   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000002BA   0xEB16 0x1045      ADDS     R0,R6,R5, LSL #+5
   \   000002BE   0xF510 0x60A0      ADDS     R0,R0,#+1280
   \   000002C2   0x2180             MOVS     R1,#+128
   \   000002C4   0x6081             STR      R1,[R0, #+8]
   \   000002C6   0xE106             B.N      ??HCD_HC_OUT_IRQHandler_1
    992            }
    993            
    994            else if ((USBx_HC(chnum)->HCINT) &  USB_OTG_HCINT_DTERR)
   \                     ??HCD_HC_OUT_IRQHandler_8: (+1)
   \   000002C8   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000002CA   0xEB16 0x1045      ADDS     R0,R6,R5, LSL #+5
   \   000002CE   0xF510 0x60A0      ADDS     R0,R0,#+1280
   \   000002D2   0x6880             LDR      R0,[R0, #+8]
   \   000002D4   0x0540             LSLS     R0,R0,#+21
   \   000002D6   0xD529             BPL.N    ??HCD_HC_OUT_IRQHandler_9
    995            {
    996              __HAL_HCD_UNMASK_HALT_HC_INT(chnum); 
   \   000002D8   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000002DA   0xEB16 0x1045      ADDS     R0,R6,R5, LSL #+5
   \   000002DE   0xF510 0x60A0      ADDS     R0,R0,#+1280
   \   000002E2   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000002E4   0xEB16 0x1145      ADDS     R1,R6,R5, LSL #+5
   \   000002E8   0xF511 0x61A0      ADDS     R1,R1,#+1280
   \   000002EC   0x68C9             LDR      R1,[R1, #+12]
   \   000002EE   0xF051 0x0102      ORRS     R1,R1,#0x2
   \   000002F2   0x60C1             STR      R1,[R0, #+12]
    997              USB_HC_Halt(hhcd->Instance, chnum);      
   \   000002F4   0x0029             MOVS     R1,R5
   \   000002F6   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000002F8   0x6820             LDR      R0,[R4, #+0]
   \   000002FA   0x.... 0x....      BL       USB_HC_Halt
    998              __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_NAK);
   \   000002FE   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000300   0xEB16 0x1045      ADDS     R0,R6,R5, LSL #+5
   \   00000304   0xF510 0x60A0      ADDS     R0,R0,#+1280
   \   00000308   0x2110             MOVS     R1,#+16
   \   0000030A   0x6081             STR      R1,[R0, #+8]
    999              __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_DTERR);    
   \   0000030C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000030E   0xEB16 0x1045      ADDS     R0,R6,R5, LSL #+5
   \   00000312   0xF510 0x60A0      ADDS     R0,R0,#+1280
   \   00000316   0xF44F 0x6180      MOV      R1,#+1024
   \   0000031A   0x6081             STR      R1,[R0, #+8]
   1000              hhcd->hc[chnum].state = HC_DATATGLERR;
   \   0000031C   0x2008             MOVS     R0,#+8
   \   0000031E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000320   0x2128             MOVS     R1,#+40
   \   00000322   0xFB01 0x4105      MLA      R1,R1,R5,R4
   \   00000326   0xF881 0x0059      STRB     R0,[R1, #+89]
   \   0000032A   0xE0D4             B.N      ??HCD_HC_OUT_IRQHandler_1
   1001            }
   1002            
   1003            
   1004            else if ((USBx_HC(chnum)->HCINT) &  USB_OTG_HCINT_CHH)
   \                     ??HCD_HC_OUT_IRQHandler_9: (+1)
   \   0000032C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000032E   0xEB16 0x1045      ADDS     R0,R6,R5, LSL #+5
   \   00000332   0xF510 0x60A0      ADDS     R0,R0,#+1280
   \   00000336   0x6880             LDR      R0,[R0, #+8]
   \   00000338   0x0780             LSLS     R0,R0,#+30
   \   0000033A   0xF140 0x80CC      BPL.W    ??HCD_HC_OUT_IRQHandler_1
   1005            {
   1006              __HAL_HCD_MASK_HALT_HC_INT(chnum); 
   \   0000033E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000340   0xEB16 0x1045      ADDS     R0,R6,R5, LSL #+5
   \   00000344   0xF510 0x60A0      ADDS     R0,R0,#+1280
   \   00000348   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000034A   0xEB16 0x1145      ADDS     R1,R6,R5, LSL #+5
   \   0000034E   0xF511 0x61A0      ADDS     R1,R1,#+1280
   \   00000352   0x68C9             LDR      R1,[R1, #+12]
   \   00000354   0xF031 0x0102      BICS     R1,R1,#0x2
   \   00000358   0x60C1             STR      R1,[R0, #+12]
   1007              
   1008              if(hhcd->hc[chnum].state == HC_XFRC)
   \   0000035A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000035C   0x2028             MOVS     R0,#+40
   \   0000035E   0xFB00 0x4005      MLA      R0,R0,R5,R4
   \   00000362   0xF890 0x0059      LDRB     R0,[R0, #+89]
   \   00000366   0x2801             CMP      R0,#+1
   \   00000368   0xD11E             BNE.N    ??HCD_HC_OUT_IRQHandler_10
   1009              {
   1010                hhcd->hc[chnum].urb_state  = URB_DONE;
   \   0000036A   0x2001             MOVS     R0,#+1
   \   0000036C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000036E   0x2128             MOVS     R1,#+40
   \   00000370   0xFB01 0x4105      MLA      R1,R1,R5,R4
   \   00000374   0xF881 0x0058      STRB     R0,[R1, #+88]
   1011                if (hhcd->hc[chnum].ep_type == EP_TYPE_BULK)
   \   00000378   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000037A   0x2028             MOVS     R0,#+40
   \   0000037C   0xFB00 0x4005      MLA      R0,R0,R5,R4
   \   00000380   0xF890 0x003B      LDRB     R0,[R0, #+59]
   \   00000384   0x2802             CMP      R0,#+2
   \   00000386   0xF040 0x8094      BNE.W    ??HCD_HC_OUT_IRQHandler_11
   1012                {
   1013                  hhcd->hc[chnum].toggle_out ^= 1; 
   \   0000038A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000038C   0x2028             MOVS     R0,#+40
   \   0000038E   0xFB00 0x4005      MLA      R0,R0,R5,R4
   \   00000392   0xF890 0x004D      LDRB     R0,[R0, #+77]
   \   00000396   0xF090 0x0001      EORS     R0,R0,#0x1
   \   0000039A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000039C   0x2128             MOVS     R1,#+40
   \   0000039E   0xFB01 0x4105      MLA      R1,R1,R5,R4
   \   000003A2   0xF881 0x004D      STRB     R0,[R1, #+77]
   \   000003A6   0xE084             B.N      ??HCD_HC_OUT_IRQHandler_11
   1014                }      
   1015              }
   1016              else if (hhcd->hc[chnum].state == HC_NAK) 
   \                     ??HCD_HC_OUT_IRQHandler_10: (+1)
   \   000003A8   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000003AA   0x2028             MOVS     R0,#+40
   \   000003AC   0xFB00 0x4005      MLA      R0,R0,R5,R4
   \   000003B0   0xF890 0x0059      LDRB     R0,[R0, #+89]
   \   000003B4   0x2803             CMP      R0,#+3
   \   000003B6   0xD107             BNE.N    ??HCD_HC_OUT_IRQHandler_12
   1017              {
   1018                hhcd->hc[chnum].urb_state  = URB_NOTREADY;
   \   000003B8   0x2002             MOVS     R0,#+2
   \   000003BA   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000003BC   0x2128             MOVS     R1,#+40
   \   000003BE   0xFB01 0x4105      MLA      R1,R1,R5,R4
   \   000003C2   0xF881 0x0058      STRB     R0,[R1, #+88]
   \   000003C6   0xE074             B.N      ??HCD_HC_OUT_IRQHandler_11
   1019              }  
   1020              
   1021              else if (hhcd->hc[chnum].state == HC_NYET) 
   \                     ??HCD_HC_OUT_IRQHandler_12: (+1)
   \   000003C8   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000003CA   0x2028             MOVS     R0,#+40
   \   000003CC   0xFB00 0x4005      MLA      R0,R0,R5,R4
   \   000003D0   0xF890 0x0059      LDRB     R0,[R0, #+89]
   \   000003D4   0x2804             CMP      R0,#+4
   \   000003D6   0xD10E             BNE.N    ??HCD_HC_OUT_IRQHandler_13
   1022              {
   1023                hhcd->hc[chnum].urb_state  = URB_NOTREADY;
   \   000003D8   0x2002             MOVS     R0,#+2
   \   000003DA   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000003DC   0x2128             MOVS     R1,#+40
   \   000003DE   0xFB01 0x4105      MLA      R1,R1,R5,R4
   \   000003E2   0xF881 0x0058      STRB     R0,[R1, #+88]
   1024                hhcd->hc[chnum].do_ping = 0;
   \   000003E6   0x2000             MOVS     R0,#+0
   \   000003E8   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000003EA   0x2128             MOVS     R1,#+40
   \   000003EC   0xFB01 0x4105      MLA      R1,R1,R5,R4
   \   000003F0   0xF881 0x0039      STRB     R0,[R1, #+57]
   \   000003F4   0xE05D             B.N      ??HCD_HC_OUT_IRQHandler_11
   1025              }   
   1026              
   1027              else if (hhcd->hc[chnum].state == HC_STALL) 
   \                     ??HCD_HC_OUT_IRQHandler_13: (+1)
   \   000003F6   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000003F8   0x2028             MOVS     R0,#+40
   \   000003FA   0xFB00 0x4005      MLA      R0,R0,R5,R4
   \   000003FE   0xF890 0x0059      LDRB     R0,[R0, #+89]
   \   00000402   0x2805             CMP      R0,#+5
   \   00000404   0xD107             BNE.N    ??HCD_HC_OUT_IRQHandler_14
   1028              {
   1029                hhcd->hc[chnum].urb_state  = URB_STALL;
   \   00000406   0x2005             MOVS     R0,#+5
   \   00000408   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000040A   0x2128             MOVS     R1,#+40
   \   0000040C   0xFB01 0x4105      MLA      R1,R1,R5,R4
   \   00000410   0xF881 0x0058      STRB     R0,[R1, #+88]
   \   00000414   0xE04D             B.N      ??HCD_HC_OUT_IRQHandler_11
   1030              } 
   1031              
   1032              else if((hhcd->hc[chnum].state == HC_XACTERR) ||
   1033                      (hhcd->hc[chnum].state == HC_DATATGLERR))
   \                     ??HCD_HC_OUT_IRQHandler_14: (+1)
   \   00000416   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000418   0x2028             MOVS     R0,#+40
   \   0000041A   0xFB00 0x4005      MLA      R0,R0,R5,R4
   \   0000041E   0xF890 0x0059      LDRB     R0,[R0, #+89]
   \   00000422   0x2806             CMP      R0,#+6
   \   00000424   0xD007             BEQ.N    ??HCD_HC_OUT_IRQHandler_15
   \   00000426   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000428   0x2028             MOVS     R0,#+40
   \   0000042A   0xFB00 0x4005      MLA      R0,R0,R5,R4
   \   0000042E   0xF890 0x0059      LDRB     R0,[R0, #+89]
   \   00000432   0x2808             CMP      R0,#+8
   \   00000434   0xD13D             BNE.N    ??HCD_HC_OUT_IRQHandler_11
   1034              {
   1035                if(hhcd->hc[chnum].ErrCnt++ > 3)
   \                     ??HCD_HC_OUT_IRQHandler_15: (+1)
   \   00000436   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000438   0x2028             MOVS     R0,#+40
   \   0000043A   0xFB00 0x4005      MLA      R0,R0,R5,R4
   \   0000043E   0x6D40             LDR      R0,[R0, #+84]
   \   00000440   0x1C41             ADDS     R1,R0,#+1
   \   00000442   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000444   0x2228             MOVS     R2,#+40
   \   00000446   0xFB02 0x4205      MLA      R2,R2,R5,R4
   \   0000044A   0x6551             STR      R1,[R2, #+84]
   \   0000044C   0x2804             CMP      R0,#+4
   \   0000044E   0xD30D             BCC.N    ??HCD_HC_OUT_IRQHandler_16
   1036                {      
   1037                  hhcd->hc[chnum].ErrCnt = 0;
   \   00000450   0x2000             MOVS     R0,#+0
   \   00000452   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000454   0x2128             MOVS     R1,#+40
   \   00000456   0xFB01 0x4105      MLA      R1,R1,R5,R4
   \   0000045A   0x6548             STR      R0,[R1, #+84]
   1038                  hhcd->hc[chnum].urb_state = URB_ERROR;
   \   0000045C   0x2004             MOVS     R0,#+4
   \   0000045E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000460   0x2128             MOVS     R1,#+40
   \   00000462   0xFB01 0x4105      MLA      R1,R1,R5,R4
   \   00000466   0xF881 0x0058      STRB     R0,[R1, #+88]
   \   0000046A   0xE006             B.N      ??HCD_HC_OUT_IRQHandler_17
   1039                }
   1040                else
   1041                {
   1042                  hhcd->hc[chnum].urb_state = URB_NOTREADY;
   \                     ??HCD_HC_OUT_IRQHandler_16: (+1)
   \   0000046C   0x2002             MOVS     R0,#+2
   \   0000046E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000470   0x2128             MOVS     R1,#+40
   \   00000472   0xFB01 0x4105      MLA      R1,R1,R5,R4
   \   00000476   0xF881 0x0058      STRB     R0,[R1, #+88]
   1043                }
   1044                
   1045                /* re-activate the channel  */
   1046                USBx_HC(chnum)->HCCHAR &= ~USB_OTG_HCCHAR_CHDIS;         
   \                     ??HCD_HC_OUT_IRQHandler_17: (+1)
   \   0000047A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000047C   0xEB16 0x1045      ADDS     R0,R6,R5, LSL #+5
   \   00000480   0xF510 0x60A0      ADDS     R0,R0,#+1280
   \   00000484   0x6800             LDR      R0,[R0, #+0]
   \   00000486   0xF030 0x4080      BICS     R0,R0,#0x40000000
   \   0000048A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000048C   0xEB16 0x1145      ADDS     R1,R6,R5, LSL #+5
   \   00000490   0xF511 0x61A0      ADDS     R1,R1,#+1280
   \   00000494   0x6008             STR      R0,[R1, #+0]
   1047                USBx_HC(chnum)->HCCHAR |= USB_OTG_HCCHAR_CHENA;      
   \   00000496   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000498   0xEB16 0x1045      ADDS     R0,R6,R5, LSL #+5
   \   0000049C   0xF510 0x60A0      ADDS     R0,R0,#+1280
   \   000004A0   0x6800             LDR      R0,[R0, #+0]
   \   000004A2   0xF050 0x4000      ORRS     R0,R0,#0x80000000
   \   000004A6   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000004A8   0xEB16 0x1145      ADDS     R1,R6,R5, LSL #+5
   \   000004AC   0xF511 0x61A0      ADDS     R1,R1,#+1280
   \   000004B0   0x6008             STR      R0,[R1, #+0]
   1048              }
   1049              
   1050              __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_CHH);
   \                     ??HCD_HC_OUT_IRQHandler_11: (+1)
   \   000004B2   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000004B4   0xEB16 0x1045      ADDS     R0,R6,R5, LSL #+5
   \   000004B8   0xF510 0x60A0      ADDS     R0,R0,#+1280
   \   000004BC   0x2102             MOVS     R1,#+2
   \   000004BE   0x6081             STR      R1,[R0, #+8]
   1051              HAL_HCD_HC_NotifyURBChange_Callback(hhcd, chnum, hhcd->hc[chnum].urb_state);  
   \   000004C0   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000004C2   0x2028             MOVS     R0,#+40
   \   000004C4   0xFB00 0x4005      MLA      R0,R0,R5,R4
   \   000004C8   0xF890 0x2058      LDRB     R2,[R0, #+88]
   \   000004CC   0x0029             MOVS     R1,R5
   \   000004CE   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000004D0   0x0020             MOVS     R0,R4
   \   000004D2   0x.... 0x....      BL       HAL_HCD_HC_NotifyURBChange_Callback
   1052            }
   1053          } 
   \                     ??HCD_HC_OUT_IRQHandler_1: (+1)
   \   000004D6   0xBD70             POP      {R4-R6,PC}       ;; return
   1054          
   1055          /**
   1056            * @brief  This function handles Rx Queue Level interrupt requests.
   1057            * @param  hhcd: HCD handle
   1058            * @retval none
   1059            */

   \                                 In section .text, align 2, keep-with-next
   1060          static void HCD_RXQLVL_IRQHandler  (HCD_HandleTypeDef *hhcd)
   1061          {
   \                     HCD_RXQLVL_IRQHandler: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
   1062            USB_OTG_GlobalTypeDef *USBx = hhcd->Instance;  
   \   00000006   0x6825             LDR      R5,[R4, #+0]
   1063            uint8_t                       channelnum =0;  
   \   00000008   0x2600             MOVS     R6,#+0
   1064            uint32_t                      pktsts;
   1065            uint32_t                      pktcnt; 
   1066            uint32_t                      temp = 0;
   \   0000000A   0xF05F 0x0900      MOVS     R9,#+0
   1067            
   1068            temp = hhcd->Instance->GRXSTSP ;
   \   0000000E   0x6820             LDR      R0,[R4, #+0]
   \   00000010   0x6A00             LDR      R0,[R0, #+32]
   \   00000012   0x4681             MOV      R9,R0
   1069            channelnum = temp &  USB_OTG_GRXSTSP_EPNUM;  
   \   00000014   0xF019 0x000F      ANDS     R0,R9,#0xF
   \   00000018   0x0006             MOVS     R6,R0
   1070            pktsts = (temp &  USB_OTG_GRXSTSP_PKTSTS) >> 17;
   \   0000001A   0xF3C9 0x4043      UBFX     R0,R9,#+17,#+4
   \   0000001E   0x0007             MOVS     R7,R0
   1071            pktcnt = (temp &  USB_OTG_GRXSTSP_BCNT) >> 4;
   \   00000020   0xF3C9 0x100A      UBFX     R0,R9,#+4,#+11
   \   00000024   0x4680             MOV      R8,R0
   1072              
   1073            switch (pktsts)
   \   00000026   0x0038             MOVS     R0,R7
   \   00000028   0x2802             CMP      R0,#+2
   \   0000002A   0xD002             BEQ.N    ??HCD_RXQLVL_IRQHandler_0
   \   0000002C   0x2805             CMP      R0,#+5
   \   0000002E   0xD060             BEQ.N    ??HCD_RXQLVL_IRQHandler_1
   \   00000030   0xE060             B.N      ??HCD_RXQLVL_IRQHandler_2
   1074            {
   1075            case GRXSTS_PKTSTS_IN:
   1076              /* Read the data into the host buffer. */
   1077              if ((pktcnt > 0) && (hhcd->hc[channelnum].xfer_buff != (void  *)0))
   \                     ??HCD_RXQLVL_IRQHandler_0: (+1)
   \   00000032   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000036   0xD05B             BEQ.N    ??HCD_RXQLVL_IRQHandler_3
   \   00000038   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000003A   0x2028             MOVS     R0,#+40
   \   0000003C   0xFB00 0x4006      MLA      R0,R0,R6,R4
   \   00000040   0x6C00             LDR      R0,[R0, #+64]
   \   00000042   0x2800             CMP      R0,#+0
   \   00000044   0xD054             BEQ.N    ??HCD_RXQLVL_IRQHandler_3
   1078              {  
   1079                
   1080                USB_ReadPacket(hhcd->Instance, hhcd->hc[channelnum].xfer_buff, pktcnt);
   \   00000046   0x4642             MOV      R2,R8
   \   00000048   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   0000004A   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000004C   0x2028             MOVS     R0,#+40
   \   0000004E   0xFB00 0x4006      MLA      R0,R0,R6,R4
   \   00000052   0x6C01             LDR      R1,[R0, #+64]
   \   00000054   0x6820             LDR      R0,[R4, #+0]
   \   00000056   0x.... 0x....      BL       USB_ReadPacket
   1081               
   1082                /*manage multiple Xfer */
   1083                hhcd->hc[channelnum].xfer_buff += pktcnt;           
   \   0000005A   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000005C   0x2028             MOVS     R0,#+40
   \   0000005E   0xFB00 0x4006      MLA      R0,R0,R6,R4
   \   00000062   0x6C00             LDR      R0,[R0, #+64]
   \   00000064   0xEB18 0x0000      ADDS     R0,R8,R0
   \   00000068   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000006A   0x2128             MOVS     R1,#+40
   \   0000006C   0xFB01 0x4106      MLA      R1,R1,R6,R4
   \   00000070   0x6408             STR      R0,[R1, #+64]
   1084                hhcd->hc[channelnum].xfer_count  += pktcnt;
   \   00000072   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000074   0x2028             MOVS     R0,#+40
   \   00000076   0xFB00 0x4006      MLA      R0,R0,R6,R4
   \   0000007A   0x6C80             LDR      R0,[R0, #+72]
   \   0000007C   0xEB18 0x0000      ADDS     R0,R8,R0
   \   00000080   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000082   0x2128             MOVS     R1,#+40
   \   00000084   0xFB01 0x4106      MLA      R1,R1,R6,R4
   \   00000088   0x6488             STR      R0,[R1, #+72]
   1085                  
   1086                if((USBx_HC(channelnum)->HCTSIZ & USB_OTG_HCTSIZ_PKTCNT) > 0)
   \   0000008A   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000008C   0xEB15 0x1046      ADDS     R0,R5,R6, LSL #+5
   \   00000090   0xF510 0x60A0      ADDS     R0,R0,#+1280
   \   00000094   0x6900             LDR      R0,[R0, #+16]
   \   00000096   0x....             LDR.N    R1,??DataTable0  ;; 0x1ff80000
   \   00000098   0x4208             TST      R0,R1
   \   0000009A   0xD029             BEQ.N    ??HCD_RXQLVL_IRQHandler_3
   1087                {
   1088                  /* re-activate the channel when more packets are expected */
   1089                  USBx_HC(channelnum)->HCCHAR &= ~USB_OTG_HCCHAR_CHDIS; 
   \   0000009C   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000009E   0xEB15 0x1046      ADDS     R0,R5,R6, LSL #+5
   \   000000A2   0xF510 0x60A0      ADDS     R0,R0,#+1280
   \   000000A6   0x6800             LDR      R0,[R0, #+0]
   \   000000A8   0xF030 0x4080      BICS     R0,R0,#0x40000000
   \   000000AC   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000AE   0xEB15 0x1146      ADDS     R1,R5,R6, LSL #+5
   \   000000B2   0xF511 0x61A0      ADDS     R1,R1,#+1280
   \   000000B6   0x6008             STR      R0,[R1, #+0]
   1090                  USBx_HC(channelnum)->HCCHAR |= USB_OTG_HCCHAR_CHENA;
   \   000000B8   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000BA   0xEB15 0x1046      ADDS     R0,R5,R6, LSL #+5
   \   000000BE   0xF510 0x60A0      ADDS     R0,R0,#+1280
   \   000000C2   0x6800             LDR      R0,[R0, #+0]
   \   000000C4   0xF050 0x4000      ORRS     R0,R0,#0x80000000
   \   000000C8   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000CA   0xEB15 0x1146      ADDS     R1,R5,R6, LSL #+5
   \   000000CE   0xF511 0x61A0      ADDS     R1,R1,#+1280
   \   000000D2   0x6008             STR      R0,[R1, #+0]
   1091                  hhcd->hc[channelnum].toggle_in ^= 1;
   \   000000D4   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000D6   0x2028             MOVS     R0,#+40
   \   000000D8   0xFB00 0x4006      MLA      R0,R0,R6,R4
   \   000000DC   0xF890 0x004C      LDRB     R0,[R0, #+76]
   \   000000E0   0xF090 0x0001      EORS     R0,R0,#0x1
   \   000000E4   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000E6   0x2128             MOVS     R1,#+40
   \   000000E8   0xFB01 0x4106      MLA      R1,R1,R6,R4
   \   000000EC   0xF881 0x004C      STRB     R0,[R1, #+76]
   1092                }
   1093              }
   1094              break;
   \                     ??HCD_RXQLVL_IRQHandler_3: (+1)
   \   000000F0   0xE000             B.N      ??HCD_RXQLVL_IRQHandler_4
   1095          
   1096            case GRXSTS_PKTSTS_DATA_TOGGLE_ERR:
   1097              break;
   \                     ??HCD_RXQLVL_IRQHandler_1: (+1)
   \   000000F2   0xE7FF             B.N      ??HCD_RXQLVL_IRQHandler_4
   1098            case GRXSTS_PKTSTS_IN_XFER_COMP:
   1099            case GRXSTS_PKTSTS_CH_HALTED:
   1100            default:
   1101              break;
   1102            }
   1103          }
   \                     ??HCD_RXQLVL_IRQHandler_2: (+1)
   \                     ??HCD_RXQLVL_IRQHandler_4: (+1)
   \   000000F4   0xE8BD 0x83F1      POP      {R0,R4-R9,PC}    ;; return
   1104          
   1105          /**
   1106            * @brief  This function handles Host Port interrupt requests.
   1107            * @param  hhcd: HCD handle
   1108            * @retval None
   1109            */

   \                                 In section .text, align 2, keep-with-next
   1110          static void HCD_Port_IRQHandler  (HCD_HandleTypeDef *hhcd)
   1111          {
   \                     HCD_Port_IRQHandler: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   \   00000004   0x0004             MOVS     R4,R0
   1112            USB_OTG_GlobalTypeDef *USBx = hhcd->Instance;  
   \   00000006   0x6825             LDR      R5,[R4, #+0]
   1113            __IO uint32_t hprt0, hprt0_dup;
   1114            
   1115            /* Handle Host Port Interrupts */
   1116            hprt0 = USBx_HPRT0;
   \   00000008   0xF515 0x6088      ADDS     R0,R5,#+1088
   \   0000000C   0x6800             LDR      R0,[R0, #+0]
   \   0000000E   0x9001             STR      R0,[SP, #+4]
   1117            hprt0_dup = USBx_HPRT0;
   \   00000010   0xF515 0x6088      ADDS     R0,R5,#+1088
   \   00000014   0x6800             LDR      R0,[R0, #+0]
   \   00000016   0x9000             STR      R0,[SP, #+0]
   1118            
   1119            hprt0_dup &= ~(USB_OTG_HPRT_PENA | USB_OTG_HPRT_PCDET |\
   1120                           USB_OTG_HPRT_PENCHNG | USB_OTG_HPRT_POCCHNG );
   \   00000018   0x9800             LDR      R0,[SP, #+0]
   \   0000001A   0xF030 0x002E      BICS     R0,R0,#0x2E
   \   0000001E   0x9000             STR      R0,[SP, #+0]
   1121            
   1122            /* Check whether Port Connect detected */
   1123            if((hprt0 & USB_OTG_HPRT_PCDET) == USB_OTG_HPRT_PCDET)
   \   00000020   0x9801             LDR      R0,[SP, #+4]
   \   00000022   0x0780             LSLS     R0,R0,#+30
   \   00000024   0xD50F             BPL.N    ??HCD_Port_IRQHandler_0
   1124            {  
   1125              if((hprt0 & USB_OTG_HPRT_PCSTS) == USB_OTG_HPRT_PCSTS)
   \   00000026   0x9801             LDR      R0,[SP, #+4]
   \   00000028   0x07C0             LSLS     R0,R0,#+31
   \   0000002A   0xD508             BPL.N    ??HCD_Port_IRQHandler_1
   1126              {
   1127                USB_MASK_INTERRUPT(hhcd->Instance, USB_OTG_GINTSTS_DISCINT);
   \   0000002C   0x6820             LDR      R0,[R4, #+0]
   \   0000002E   0x6980             LDR      R0,[R0, #+24]
   \   00000030   0xF030 0x5000      BICS     R0,R0,#0x20000000
   \   00000034   0x6821             LDR      R1,[R4, #+0]
   \   00000036   0x6188             STR      R0,[R1, #+24]
   1128                HAL_HCD_Connect_Callback(hhcd);
   \   00000038   0x0020             MOVS     R0,R4
   \   0000003A   0x.... 0x....      BL       HAL_HCD_Connect_Callback
   1129              }
   1130              hprt0_dup  |= USB_OTG_HPRT_PCDET;
   \                     ??HCD_Port_IRQHandler_1: (+1)
   \   0000003E   0x9800             LDR      R0,[SP, #+0]
   \   00000040   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   00000044   0x9000             STR      R0,[SP, #+0]
   1131              
   1132            }
   1133            
   1134            /* Check whether Port Enable Changed */
   1135            if((hprt0 & USB_OTG_HPRT_PENCHNG) == USB_OTG_HPRT_PENCHNG)
   \                     ??HCD_Port_IRQHandler_0: (+1)
   \   00000046   0x9801             LDR      R0,[SP, #+4]
   \   00000048   0x0700             LSLS     R0,R0,#+28
   \   0000004A   0xD53C             BPL.N    ??HCD_Port_IRQHandler_2
   1136            {
   1137              hprt0_dup |= USB_OTG_HPRT_PENCHNG;
   \   0000004C   0x9800             LDR      R0,[SP, #+0]
   \   0000004E   0xF050 0x0008      ORRS     R0,R0,#0x8
   \   00000052   0x9000             STR      R0,[SP, #+0]
   1138              
   1139              if((hprt0 & USB_OTG_HPRT_PENA) == USB_OTG_HPRT_PENA)
   \   00000054   0x9801             LDR      R0,[SP, #+4]
   \   00000056   0x0740             LSLS     R0,R0,#+29
   \   00000058   0xD527             BPL.N    ??HCD_Port_IRQHandler_3
   1140              {    
   1141                if(hhcd->Init.phy_itface  == USB_OTG_EMBEDDED_PHY)
   \   0000005A   0x69A0             LDR      R0,[R4, #+24]
   \   0000005C   0x2802             CMP      R0,#+2
   \   0000005E   0xD10F             BNE.N    ??HCD_Port_IRQHandler_4
   1142                {
   1143                  if ((hprt0 & USB_OTG_HPRT_PSPD) == (HPRT0_PRTSPD_LOW_SPEED << 17))
   \   00000060   0x9801             LDR      R0,[SP, #+4]
   \   00000062   0xF410 0x20C0      ANDS     R0,R0,#0x60000
   \   00000066   0xF5B0 0x2F80      CMP      R0,#+262144
   \   0000006A   0xD104             BNE.N    ??HCD_Port_IRQHandler_5
   1144                  {
   1145                    USB_InitFSLSPClkSel(hhcd->Instance ,HCFG_6_MHZ );
   \   0000006C   0x2102             MOVS     R1,#+2
   \   0000006E   0x6820             LDR      R0,[R4, #+0]
   \   00000070   0x.... 0x....      BL       USB_InitFSLSPClkSel
   \   00000074   0xE00C             B.N      ??HCD_Port_IRQHandler_6
   1146                  }
   1147                  else
   1148                  {
   1149                    USB_InitFSLSPClkSel(hhcd->Instance ,HCFG_48_MHZ );
   \                     ??HCD_Port_IRQHandler_5: (+1)
   \   00000076   0x2101             MOVS     R1,#+1
   \   00000078   0x6820             LDR      R0,[R4, #+0]
   \   0000007A   0x.... 0x....      BL       USB_InitFSLSPClkSel
   \   0000007E   0xE007             B.N      ??HCD_Port_IRQHandler_6
   1150                  }
   1151                }
   1152                else
   1153                {
   1154                  if(hhcd->Init.speed == HCD_SPEED_FULL)
   \                     ??HCD_Port_IRQHandler_4: (+1)
   \   00000080   0x68E0             LDR      R0,[R4, #+12]
   \   00000082   0x2803             CMP      R0,#+3
   \   00000084   0xD104             BNE.N    ??HCD_Port_IRQHandler_6
   1155                  {
   1156                    USBx_HOST->HFIR = (uint32_t)60000;
   \   00000086   0xF64E 0x2060      MOVW     R0,#+60000
   \   0000008A   0xF515 0x6180      ADDS     R1,R5,#+1024
   \   0000008E   0x6048             STR      R0,[R1, #+4]
   1157                  }
   1158                }
   1159                HAL_HCD_Connect_Callback(hhcd);
   \                     ??HCD_Port_IRQHandler_6: (+1)
   \   00000090   0x0020             MOVS     R0,R4
   \   00000092   0x.... 0x....      BL       HAL_HCD_Connect_Callback
   1160                
   1161                if(hhcd->Init.speed == HCD_SPEED_HIGH)
   \   00000096   0x68E0             LDR      R0,[R4, #+12]
   \   00000098   0x2800             CMP      R0,#+0
   \   0000009A   0xD114             BNE.N    ??HCD_Port_IRQHandler_2
   1162                {
   1163                  USB_UNMASK_INTERRUPT(hhcd->Instance, USB_OTG_GINTSTS_DISCINT); 
   \   0000009C   0x6820             LDR      R0,[R4, #+0]
   \   0000009E   0x6980             LDR      R0,[R0, #+24]
   \   000000A0   0xF050 0x5000      ORRS     R0,R0,#0x20000000
   \   000000A4   0x6821             LDR      R1,[R4, #+0]
   \   000000A6   0x6188             STR      R0,[R1, #+24]
   \   000000A8   0xE00D             B.N      ??HCD_Port_IRQHandler_2
   1164                }
   1165              }
   1166              else
   1167              {
   1168                /* Cleanup HPRT */
   1169                USBx_HPRT0 &= ~(USB_OTG_HPRT_PENA | USB_OTG_HPRT_PCDET |\
   1170                  USB_OTG_HPRT_PENCHNG | USB_OTG_HPRT_POCCHNG );
   \                     ??HCD_Port_IRQHandler_3: (+1)
   \   000000AA   0xF515 0x6088      ADDS     R0,R5,#+1088
   \   000000AE   0x6800             LDR      R0,[R0, #+0]
   \   000000B0   0xF030 0x002E      BICS     R0,R0,#0x2E
   \   000000B4   0xF515 0x6188      ADDS     R1,R5,#+1088
   \   000000B8   0x6008             STR      R0,[R1, #+0]
   1171                
   1172                USB_UNMASK_INTERRUPT(hhcd->Instance, USB_OTG_GINTSTS_DISCINT); 
   \   000000BA   0x6820             LDR      R0,[R4, #+0]
   \   000000BC   0x6980             LDR      R0,[R0, #+24]
   \   000000BE   0xF050 0x5000      ORRS     R0,R0,#0x20000000
   \   000000C2   0x6821             LDR      R1,[R4, #+0]
   \   000000C4   0x6188             STR      R0,[R1, #+24]
   1173              }    
   1174            }
   1175            
   1176            /* Check For an overcurrent */
   1177            if((hprt0 & USB_OTG_HPRT_POCCHNG) == USB_OTG_HPRT_POCCHNG)
   \                     ??HCD_Port_IRQHandler_2: (+1)
   \   000000C6   0x9801             LDR      R0,[SP, #+4]
   \   000000C8   0x0680             LSLS     R0,R0,#+26
   \   000000CA   0xD503             BPL.N    ??HCD_Port_IRQHandler_7
   1178            {
   1179              hprt0_dup |= USB_OTG_HPRT_POCCHNG;
   \   000000CC   0x9800             LDR      R0,[SP, #+0]
   \   000000CE   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   000000D2   0x9000             STR      R0,[SP, #+0]
   1180            }
   1181          
   1182            /* Clear Port Interrupts */
   1183            USBx_HPRT0 = hprt0_dup;
   \                     ??HCD_Port_IRQHandler_7: (+1)
   \   000000D4   0x9800             LDR      R0,[SP, #+0]
   \   000000D6   0xF515 0x6188      ADDS     R1,R5,#+1088
   \   000000DA   0x6008             STR      R0,[R1, #+0]
   1184          }
   \   000000DC   0xBD37             POP      {R0-R2,R4,R5,PC}  ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0:
   \   00000000   0x1FF80000         DC32     0x1ff80000
   1185          
   1186          /**
   1187            * @}
   1188            */
   1189          
   1190          #endif /* HAL_HCD_MODULE_ENABLED */
   1191          /**
   1192            * @}
   1193            */
   1194          
   1195          /**
   1196            * @}
   1197            */
   1198          
   1199          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   HAL_HCD_Connect_Callback
       8   HAL_HCD_DeInit
         8   -> HAL_HCD_MspDeInit
         8   -> USB_DisableGlobalInt
       0   HAL_HCD_Disconnect_Callback
       8   HAL_HCD_GetCurrentFrame
         8   -> USB_GetCurrentFrame
       8   HAL_HCD_GetCurrentSpeed
         8   -> USB_GetHostSpeed
       0   HAL_HCD_GetState
       0   HAL_HCD_HC_GetState
       0   HAL_HCD_HC_GetURBState
       0   HAL_HCD_HC_GetXferCount
      16   HAL_HCD_HC_Halt
        16   -> USB_HC_Halt
      48   HAL_HCD_HC_Init
        48   -> USB_HC_Init
       0   HAL_HCD_HC_NotifyURBChange_Callback
      40   HAL_HCD_HC_SubmitRequest
        40   -> USB_HC_StartXfer
      24   HAL_HCD_IRQHandler
        24   -> HAL_HCD_Disconnect_Callback
        24   -> HAL_HCD_SOF_Callback
        24   -> HCD_HC_IN_IRQHandler
        24   -> HCD_HC_OUT_IRQHandler
        24   -> HCD_Port_IRQHandler
        24   -> HCD_RXQLVL_IRQHandler
        24   -> USB_GetMode
        24   -> USB_HC_ReadInterrupt
        24   -> USB_InitFSLSPClkSel
        24   -> USB_ReadInterrupts
      60   HAL_HCD_Init
        48   -> HAL_HCD_MspInit
        48   -> USB_CoreInit
        48   -> USB_DisableGlobalInt
        48   -> USB_HostInit
        48   -> USB_SetCurrentMode
        60   -> __aeabi_memcpy4
       0   HAL_HCD_MspDeInit
       0   HAL_HCD_MspInit
       8   HAL_HCD_ResetPort
         8   -> USB_ResetPort
       0   HAL_HCD_SOF_Callback
       8   HAL_HCD_Start
         8   -> USB_DriveVbus
         8   -> USB_EnableGlobalInt
       8   HAL_HCD_Stop
         8   -> USB_StopHost
      16   HCD_HC_IN_IRQHandler
        16   -> HAL_HCD_HC_NotifyURBChange_Callback
        16   -> USB_HC_Halt
      16   HCD_HC_OUT_IRQHandler
        16   -> HAL_HCD_HC_NotifyURBChange_Callback
        16   -> USB_HC_Halt
      24   HCD_Port_IRQHandler
        24   -> HAL_HCD_Connect_Callback
        24   -> USB_InitFSLSPClkSel
      32   HCD_RXQLVL_IRQHandler
        32   -> USB_ReadPacket


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable0
       2  HAL_HCD_Connect_Callback
      40  HAL_HCD_DeInit
       2  HAL_HCD_Disconnect_Callback
      12  HAL_HCD_GetCurrentFrame
      12  HAL_HCD_GetCurrentSpeed
       6  HAL_HCD_GetState
      14  HAL_HCD_HC_GetState
      14  HAL_HCD_HC_GetURBState
      12  HAL_HCD_HC_GetXferCount
      48  HAL_HCD_HC_Halt
     198  HAL_HCD_HC_Init
       2  HAL_HCD_HC_NotifyURBChange_Callback
     644  HAL_HCD_HC_SubmitRequest
     316  HAL_HCD_IRQHandler
      92  HAL_HCD_Init
       2  HAL_HCD_MspDeInit
       2  HAL_HCD_MspInit
      12  HAL_HCD_ResetPort
       2  HAL_HCD_SOF_Callback
      46  HAL_HCD_Start
      38  HAL_HCD_Stop
    1264  HCD_HC_IN_IRQHandler
    1240  HCD_HC_OUT_IRQHandler
     222  HCD_Port_IRQHandler
     248  HCD_RXQLVL_IRQHandler

 
 4 494 bytes in section .text
 
 4 494 bytes of CODE memory

Errors: none
Warnings: none
