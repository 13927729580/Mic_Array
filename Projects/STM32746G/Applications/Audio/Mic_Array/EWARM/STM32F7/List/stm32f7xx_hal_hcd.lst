###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.2.10312/W32 for ARM       27/Feb/2016  00:32:34
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_hcd.c
#    Command line =  
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_hcd.c
#        -D USE_HAL_DRIVER -D STM32F746xx -D USE_STM32746G_DISCO -D
#        USE_IOEXPANDER -D USE_USB_FS -lC
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
#        -lA
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
#        -o
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M7 -e --fpu=VFPv5_sp --dlib_config
#        "D:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Full.h" -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\Inc\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\CMSIS\Device\ST\STM32F7xx\Include\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\STM32F7xx_HAL_Driver\Inc\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\STM32746G-Discovery\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\Components\Common\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Log\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Fonts\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\CPU\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_Device_Library\Core\Inc\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Core\Inc\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Class\MSC\Inc\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\drivers\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_Audio\Addons\PDM\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_Device_Library\Class\AUDIO\Inc\
#        -Om --use_c++_inline --require_prototypes -I "D:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.3\arm\CMSIS\Include\" -D
#        ARM_MATH_CM7
#    List file    =  
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List\stm32f7xx_hal_hcd.lst
#    Object file  =  
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj\stm32f7xx_hal_hcd.o
#
###############################################################################

H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_hcd.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f7xx_hal_hcd.c
      4            * @author  MCD Application Team
      5            * @version V1.0.1
      6            * @date    25-June-2015
      7            * @brief   HCD HAL module driver.
      8            *          This file provides firmware functions to manage the following 
      9            *          functionalities of the USB Peripheral Controller:
     10            *           + Initialization and de-initialization functions
     11            *           + IO operation functions
     12            *           + Peripheral Control functions 
     13            *           + Peripheral State functions
     14            *         
     15            @verbatim
     16            ==============================================================================
     17                              ##### How to use this driver #####
     18            ==============================================================================
     19            [..]
     20              (#)Declare a HCD_HandleTypeDef handle structure, for example:
     21                 HCD_HandleTypeDef  hhcd;
     22                  
     23              (#)Fill parameters of Init structure in HCD handle
     24            
     25              (#)Call HAL_HCD_Init() API to initialize the HCD peripheral (Core, Host core, ...) 
     26          
     27              (#)Initialize the HCD low level resources through the HAL_HCD_MspInit() API:
     28                  (##) Enable the HCD/USB Low Level interface clock using the following macros
     29                       (+++) __OTGFS-OTG_CLK_ENABLE() or __OTGHS-OTG_CLK_ENABLE()
     30                       (+++) __OTGHSULPI_CLK_ENABLE() For High Speed Mode
     31                     
     32                  (##) Initialize the related GPIO clocks
     33                  (##) Configure HCD pin-out
     34                  (##) Configure HCD NVIC interrupt
     35              
     36              (#)Associate the Upper USB Host stack to the HAL HCD Driver:
     37                  (##) hhcd.pData = phost;
     38          
     39              (#)Enable HCD transmission and reception:
     40                  (##) HAL_HCD_Start();
     41          
     42            @endverbatim
     43            ******************************************************************************
     44            * @attention
     45            *
     46            * <h2><center>&copy; COPYRIGHT(c) 2015 STMicroelectronics</center></h2>
     47            *
     48            * Redistribution and use in source and binary forms, with or without modification,
     49            * are permitted provided that the following conditions are met:
     50            *   1. Redistributions of source code must retain the above copyright notice,
     51            *      this list of conditions and the following disclaimer.
     52            *   2. Redistributions in binary form must reproduce the above copyright notice,
     53            *      this list of conditions and the following disclaimer in the documentation
     54            *      and/or other materials provided with the distribution.
     55            *   3. Neither the name of STMicroelectronics nor the names of its contributors
     56            *      may be used to endorse or promote products derived from this software
     57            *      without specific prior written permission.
     58            *
     59            * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
     60            * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     61            * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     62            * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
     63            * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
     64            * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
     65            * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
     66            * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
     67            * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
     68            * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     69            *
     70            ******************************************************************************
     71            */ 
     72          
     73          /* Includes ------------------------------------------------------------------*/
     74          #include "stm32f7xx_hal.h"
     75          
     76          /** @addtogroup STM32F7xx_HAL_Driver
     77            * @{
     78            */
     79          
     80          /** @addtogroup HCD
     81            * @{
     82            */
     83          
     84          #ifdef HAL_HCD_MODULE_ENABLED
     85          
     86          /* Private typedef -----------------------------------------------------------*/
     87          /* Private define ------------------------------------------------------------*/
     88          /* Private macro -------------------------------------------------------------*/
     89          /* Private variables ---------------------------------------------------------*/
     90          /* Private function ----------------------------------------------------------*/
     91          /** @addtogroup HCD_Private_Functions
     92            * @{
     93            */
     94          static void HCD_HC_IN_IRQHandler(HCD_HandleTypeDef *hhcd, uint8_t chnum);
     95          static void HCD_HC_OUT_IRQHandler(HCD_HandleTypeDef *hhcd, uint8_t chnum); 
     96          static void HCD_RXQLVL_IRQHandler(HCD_HandleTypeDef *hhcd);
     97          static void HCD_Port_IRQHandler(HCD_HandleTypeDef *hhcd);
     98          /**
     99            * @}
    100            */
    101          
    102          /* Exported functions --------------------------------------------------------*/
    103          /** @addtogroup HCD_Exported_Functions
    104            * @{
    105            */
    106          
    107          /** @addtogroup HCD_Exported_Functions_Group1
    108           *  @brief   Initialization and de-initialization functions
    109           *
    110          @verbatim    
    111           ===============================================================================
    112                    ##### Initialization and de-initialization functions #####
    113           ===============================================================================
    114              [..]  This section provides functions allowing to:
    115           
    116          @endverbatim
    117            * @{
    118            */
    119          
    120          /**
    121            * @brief  Initialize the host driver
    122            * @param  hhcd: HCD handle
    123            * @retval HAL status
    124            */

   \                                 In section .text, align 2, keep-with-next
    125          HAL_StatusTypeDef HAL_HCD_Init(HCD_HandleTypeDef *hhcd)
    126          { 
   \                     HAL_HCD_Init: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB08A             SUB      SP,SP,#+40
   \   00000004   0x0004             MOVS     R4,R0
    127            /* Check the HCD handle allocation */
    128            if(hhcd == NULL)
   \   00000006   0xD101             BNE.N    ??HAL_HCD_Init_0
    129            {
    130              return HAL_ERROR;
   \   00000008   0x2001             MOVS     R0,#+1
   \   0000000A   0xE024             B.N      ??HAL_HCD_Init_1
    131            }
    132            
    133            /* Check the parameters */
    134            assert_param(IS_HCD_ALL_INSTANCE(hhcd->Instance));
    135          
    136            hhcd->State = HAL_HCD_STATE_BUSY;
   \                     ??HAL_HCD_Init_0: (+1)
   \   0000000C   0x2003             MOVS     R0,#+3
   \   0000000E   0xF884 0x028D      STRB     R0,[R4, #+653]
    137            
    138            /* Init the low level hardware : GPIO, CLOCK, NVIC... */
    139            HAL_HCD_MspInit(hhcd);
   \   00000012   0x4620             MOV      R0,R4
   \   00000014   0x.... 0x....      BL       HAL_HCD_MspInit
    140          
    141            /* Disable the Interrupts */
    142           __HAL_HCD_DISABLE(hhcd);
   \   00000018   0x6820             LDR      R0,[R4, #+0]
   \   0000001A   0x.... 0x....      BL       USB_DisableGlobalInt
    143           
    144           /*Init the Core (common init.) */
    145           USB_CoreInit(hhcd->Instance, hhcd->Init);
   \   0000001E   0x1D21             ADDS     R1,R4,#+4
   \   00000020   0xB083             SUB      SP,SP,#+12
   \   00000022   0x4668             MOV      R0,SP
   \   00000024   0x2230             MOVS     R2,#+48
   \   00000026   0x.... 0x....      BL       __aeabi_memcpy4
   \   0000002A   0xBC0E             POP      {R1-R3}
   \   0000002C   0x6820             LDR      R0,[R4, #+0]
   \   0000002E   0x.... 0x....      BL       USB_CoreInit
    146           
    147           /* Force Host Mode*/
    148           USB_SetCurrentMode(hhcd->Instance , USB_OTG_HOST_MODE);
   \   00000032   0x2101             MOVS     R1,#+1
   \   00000034   0x6820             LDR      R0,[R4, #+0]
   \   00000036   0x.... 0x....      BL       USB_SetCurrentMode
    149           
    150           /* Init Host */
    151           USB_HostInit(hhcd->Instance, hhcd->Init);
   \   0000003A   0x1D21             ADDS     R1,R4,#+4
   \   0000003C   0xB083             SUB      SP,SP,#+12
   \   0000003E   0x4668             MOV      R0,SP
   \   00000040   0x2230             MOVS     R2,#+48
   \   00000042   0x.... 0x....      BL       __aeabi_memcpy4
   \   00000046   0xBC0E             POP      {R1-R3}
   \   00000048   0x6820             LDR      R0,[R4, #+0]
   \   0000004A   0x.... 0x....      BL       USB_HostInit
    152           
    153           hhcd->State= HAL_HCD_STATE_READY;
   \   0000004E   0x2001             MOVS     R0,#+1
   \   00000050   0xF884 0x028D      STRB     R0,[R4, #+653]
    154           
    155           return HAL_OK;
   \   00000054   0x2000             MOVS     R0,#+0
   \                     ??HAL_HCD_Init_1: (+1)
   \   00000056   0xB00A             ADD      SP,SP,#+40
   \   00000058   0xBD10             POP      {R4,PC}          ;; return
    156          }
    157          
    158          /**
    159            * @brief  Initialize a host channel
    160            * @param  hhcd: HCD handle
    161            * @param  ch_num: Channel number.
    162            *         This parameter can be a value from 1 to 15
    163            * @param  epnum: Endpoint number.
    164            *          This parameter can be a value from 1 to 15
    165            * @param  dev_address : Current device address
    166            *          This parameter can be a value from 0 to 255
    167            * @param  speed: Current device speed.
    168            *          This parameter can be one of these values:
    169            *            HCD_SPEED_HIGH: High speed mode,
    170            *            HCD_SPEED_FULL: Full speed mode,
    171            *            HCD_SPEED_LOW: Low speed mode
    172            * @param  ep_type: Endpoint Type.
    173            *          This parameter can be one of these values:
    174            *            EP_TYPE_CTRL: Control type,
    175            *            EP_TYPE_ISOC: Isochronous type,
    176            *            EP_TYPE_BULK: Bulk type,
    177            *            EP_TYPE_INTR: Interrupt type
    178            * @param  mps: Max Packet Size.
    179            *          This parameter can be a value from 0 to32K
    180            * @retval HAL status
    181            */

   \                                 In section .text, align 2, keep-with-next
    182          HAL_StatusTypeDef HAL_HCD_HC_Init(HCD_HandleTypeDef *hhcd,  
    183                                            uint8_t ch_num,
    184                                            uint8_t epnum,
    185                                            uint8_t dev_address,
    186                                            uint8_t speed,
    187                                            uint8_t ep_type,
    188                                            uint16_t mps)
    189          {
   \                     HAL_HCD_HC_Init: (+1)
   \   00000000   0xB5FE             PUSH     {R1-R7,LR}
   \   00000002   0x4606             MOV      R6,R0
    190            HAL_StatusTypeDef status = HAL_OK;
    191            
    192            __HAL_LOCK(hhcd); 
   \   00000004   0xF896 0x028C      LDRB     R0,[R6, #+652]
   \   00000008   0x2801             CMP      R0,#+1
   \   0000000A   0xD101             BNE.N    ??HAL_HCD_HC_Init_0
   \   0000000C   0x2002             MOVS     R0,#+2
   \   0000000E   0xBDFE             POP      {R1-R7,PC}
   \                     ??HAL_HCD_HC_Init_0: (+1)
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0xF886 0x028C      STRB     R0,[R6, #+652]
    193            
    194            hhcd->hc[ch_num].dev_addr = dev_address;
   \   00000016   0xEB01 0x0081      ADD      R0,R1,R1, LSL #+2
   \   0000001A   0xEB06 0x00C0      ADD      R0,R6,R0, LSL #+3
   \   0000001E   0xF100 0x0734      ADD      R7,R0,#+52
   \   00000022   0x703B             STRB     R3,[R7, #+0]
   \   00000024   0x9C0A             LDR      R4,[SP, #+40]
    195            hhcd->hc[ch_num].max_packet = mps;
   \   00000026   0x813C             STRH     R4,[R7, #+8]
    196            hhcd->hc[ch_num].ch_num = ch_num;
   \   00000028   0x7079             STRB     R1,[R7, #+1]
   \   0000002A   0x9D09             LDR      R5,[SP, #+36]
    197            hhcd->hc[ch_num].ep_type = ep_type;
   \   0000002C   0x71FD             STRB     R5,[R7, #+7]
    198            hhcd->hc[ch_num].ep_num = epnum & 0x7F;
   \   0000002E   0xF002 0x007F      AND      R0,R2,#0x7F
   \   00000032   0x70B8             STRB     R0,[R7, #+2]
    199            hhcd->hc[ch_num].ep_is_in = ((epnum & 0x80) == 0x80);
   \   00000034   0x4610             MOV      R0,R2
   \   00000036   0x09C0             LSRS     R0,R0,#+7
   \   00000038   0x70F8             STRB     R0,[R7, #+3]
   \   0000003A   0x9808             LDR      R0,[SP, #+32]
    200            hhcd->hc[ch_num].speed = speed;
   \   0000003C   0x7138             STRB     R0,[R7, #+4]
    201          
    202            status =  USB_HC_Init(hhcd->Instance, 
    203                                  ch_num,
    204                                  epnum,
    205                                  dev_address,
    206                                  speed,
    207                                  ep_type,
    208                                  mps);
   \   0000003E   0x9402             STR      R4,[SP, #+8]
   \   00000040   0x9501             STR      R5,[SP, #+4]
   \   00000042   0x9000             STR      R0,[SP, #+0]
   \   00000044   0x6830             LDR      R0,[R6, #+0]
   \   00000046   0x.... 0x....      BL       USB_HC_Init
    209            __HAL_UNLOCK(hhcd); 
   \   0000004A   0x2100             MOVS     R1,#+0
   \   0000004C   0xF886 0x128C      STRB     R1,[R6, #+652]
    210            
    211            return status;
   \   00000050   0xBDFE             POP      {R1-R7,PC}       ;; return
    212          }
    213          
    214          /**
    215            * @brief  Halt a host channel
    216            * @param  hhcd: HCD handle
    217            * @param  ch_num: Channel number.
    218            *         This parameter can be a value from 1 to 15
    219            * @retval HAL status
    220            */

   \                                 In section .text, align 2, keep-with-next
    221          HAL_StatusTypeDef HAL_HCD_HC_Halt(HCD_HandleTypeDef *hhcd, uint8_t ch_num)
    222          {
   \                     HAL_HCD_HC_Halt: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    223            HAL_StatusTypeDef status = HAL_OK;
    224            
    225            __HAL_LOCK(hhcd);   
   \   00000004   0xF894 0x028C      LDRB     R0,[R4, #+652]
   \   00000008   0x2801             CMP      R0,#+1
   \   0000000A   0xD101             BNE.N    ??HAL_HCD_HC_Halt_0
   \   0000000C   0x2002             MOVS     R0,#+2
   \   0000000E   0xBD10             POP      {R4,PC}
   \                     ??HAL_HCD_HC_Halt_0: (+1)
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0xF884 0x028C      STRB     R0,[R4, #+652]
    226            USB_HC_Halt(hhcd->Instance, ch_num);   
   \   00000016   0x6820             LDR      R0,[R4, #+0]
   \   00000018   0x.... 0x....      BL       USB_HC_Halt
    227            __HAL_UNLOCK(hhcd);
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0xF884 0x028C      STRB     R0,[R4, #+652]
    228            
    229            return status;
   \   00000022   0xBD10             POP      {R4,PC}          ;; return
    230          }
    231          
    232          /**
    233            * @brief  DeInitialize the host driver
    234            * @param  hhcd: HCD handle
    235            * @retval HAL status
    236            */

   \                                 In section .text, align 2, keep-with-next
    237          HAL_StatusTypeDef HAL_HCD_DeInit(HCD_HandleTypeDef *hhcd)
    238          {
   \                     HAL_HCD_DeInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    239            /* Check the HCD handle allocation */
    240            if(hhcd == NULL)
   \   00000004   0xD101             BNE.N    ??HAL_HCD_DeInit_0
    241            {
    242              return HAL_ERROR;
   \   00000006   0x2001             MOVS     R0,#+1
   \   00000008   0xBD10             POP      {R4,PC}
    243            }
    244            
    245            hhcd->State = HAL_HCD_STATE_BUSY;
   \                     ??HAL_HCD_DeInit_0: (+1)
   \   0000000A   0x2003             MOVS     R0,#+3
   \   0000000C   0xF884 0x028D      STRB     R0,[R4, #+653]
    246            
    247            /* DeInit the low level hardware */
    248            HAL_HCD_MspDeInit(hhcd);
   \   00000010   0x4620             MOV      R0,R4
   \   00000012   0x.... 0x....      BL       HAL_HCD_MspDeInit
    249            
    250             __HAL_HCD_DISABLE(hhcd);
   \   00000016   0x6820             LDR      R0,[R4, #+0]
   \   00000018   0x.... 0x....      BL       USB_DisableGlobalInt
    251            
    252            hhcd->State = HAL_HCD_STATE_RESET; 
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0xF884 0x028D      STRB     R0,[R4, #+653]
    253            
    254            return HAL_OK;
   \   00000022   0xBD10             POP      {R4,PC}          ;; return
    255          }
    256          
    257          /**
    258            * @brief  Initializes the HCD MSP.
    259            * @param  hhcd: HCD handle
    260            * @retval None
    261            */

   \                                 In section .text, align 2, keep-with-next
    262          __weak void  HAL_HCD_MspInit(HCD_HandleTypeDef *hhcd)
    263          {
    264            /* NOTE : This function Should not be modified, when the callback is needed,
    265                      the HAL_HCD_MspInit could be implemented in the user file
    266             */
    267          }
   \                     HAL_HCD_MspInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    268          
    269          /**
    270            * @brief  DeInitializes HCD MSP.
    271            * @param  hhcd: HCD handle
    272            * @retval None
    273            */

   \                                 In section .text, align 2, keep-with-next
    274          __weak void  HAL_HCD_MspDeInit(HCD_HandleTypeDef *hhcd)
    275          {
    276            /* NOTE : This function Should not be modified, when the callback is needed,
    277                      the HAL_HCD_MspDeInit could be implemented in the user file
    278             */
    279          }
   \                     HAL_HCD_MspDeInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    280          
    281          /**
    282            * @}
    283            */
    284          
    285          /** @addtogroup HCD_Exported_Functions_Group2
    286            *  @brief   HCD IO operation functions
    287            *
    288          @verbatim
    289           ===============================================================================
    290                                ##### IO operation functions #####
    291           ===============================================================================
    292              This subsection provides a set of functions allowing to manage the USB Host Data 
    293              Transfer
    294                 
    295          @endverbatim
    296            * @{
    297            */
    298            
    299          /**                                
    300            * @brief  Submit a new URB for processing 
    301            * @param  hhcd: HCD handle
    302            * @param  ch_num: Channel number.
    303            *         This parameter can be a value from 1 to 15
    304            * @param  direction: Channel number.
    305            *          This parameter can be one of these values:
    306            *           0 : Output / 1 : Input
    307            * @param  ep_type: Endpoint Type.
    308            *          This parameter can be one of these values:
    309            *            EP_TYPE_CTRL: Control type/
    310            *            EP_TYPE_ISOC: Isochronous type/
    311            *            EP_TYPE_BULK: Bulk type/
    312            *            EP_TYPE_INTR: Interrupt type/
    313            * @param  token: Endpoint Type.
    314            *          This parameter can be one of these values:
    315            *            0: HC_PID_SETUP / 1: HC_PID_DATA1
    316            * @param  pbuff: pointer to URB data
    317            * @param  length: Length of URB data
    318            * @param  do_ping: activate do ping protocol (for high speed only).
    319            *          This parameter can be one of these values:
    320            *           0 : do ping inactive / 1 : do ping active 
    321            * @retval HAL status
    322            */

   \                                 In section .text, align 4, keep-with-next
    323          HAL_StatusTypeDef HAL_HCD_HC_SubmitRequest(HCD_HandleTypeDef *hhcd,
    324                                                      uint8_t ch_num, 
    325                                                      uint8_t direction ,
    326                                                      uint8_t ep_type,  
    327                                                      uint8_t token, 
    328                                                      uint8_t* pbuff, 
    329                                                      uint16_t length,
    330                                                      uint8_t do_ping) 
    331          {
   \                     HAL_HCD_HC_SubmitRequest: (+1)
   \   00000000   0xB4FC             PUSH     {R2-R7}
    332            hhcd->hc[ch_num].ep_is_in = direction;
   \   00000002   0xEB01 0x0481      ADD      R4,R1,R1, LSL #+2
   \   00000006   0xEB00 0x06C4      ADD      R6,R0,R4, LSL #+3
   \   0000000A   0xF106 0x0735      ADD      R7,R6,#+53
   \   0000000E   0x70BA             STRB     R2,[R7, #+2]
    333            hhcd->hc[ch_num].ep_type  = ep_type; 
   \   00000010   0x71BB             STRB     R3,[R7, #+6]
   \   00000012   0x9D06             LDR      R5,[SP, #+24]
    334            
    335            if(token == 0)
   \   00000014   0x2D00             CMP      R5,#+0
   \   00000016   0xD102             BNE.N    ??HAL_HCD_HC_SubmitRequest_1
    336            {
    337              hhcd->hc[ch_num].data_pid = HC_PID_SETUP;
   \   00000018   0x2403             MOVS     R4,#+3
   \   0000001A   0x727C             STRB     R4,[R7, #+9]
   \   0000001C   0xE001             B.N      ??HAL_HCD_HC_SubmitRequest_2
    338            }
    339            else
    340            {
    341              hhcd->hc[ch_num].data_pid = HC_PID_DATA1;
   \                     ??HAL_HCD_HC_SubmitRequest_1: (+1)
   \   0000001E   0x2402             MOVS     R4,#+2
   \   00000020   0x727C             STRB     R4,[R7, #+9]
   \                     ??HAL_HCD_HC_SubmitRequest_2: (+1)
   \   00000022   0x9C08             LDR      R4,[SP, #+32]
    342            }
    343            
    344            /* Manage Data Toggle */
    345            switch(ep_type)
   \   00000024   0x2B03             CMP      R3,#+3
   \   00000026   0xD829             BHI.N    ??HAL_HCD_HC_SubmitRequest_3
   \   00000028   0xE8DF 0xF003      TBB      [PC, R3]
   \                     ??HAL_HCD_HC_SubmitRequest_0:
   \   0000002C   0x02 0x26          DC8      0x2,0x26,0xD,0x1F
   \              0x0D 0x1F    
    346            {
    347            case EP_TYPE_CTRL:
    348              if((token == 1) && (direction == 0)) /*send data */
   \                     ??HAL_HCD_HC_SubmitRequest_4: (+1)
   \   00000030   0x2D01             CMP      R5,#+1
   \   00000032   0xD123             BNE.N    ??HAL_HCD_HC_SubmitRequest_3
   \   00000034   0x2A00             CMP      R2,#+0
   \   00000036   0xD121             BNE.N    ??HAL_HCD_HC_SubmitRequest_3
    349              {
    350                if ( length == 0 )
   \   00000038   0x2C00             CMP      R4,#+0
   \   0000003A   0xD106             BNE.N    ??HAL_HCD_HC_SubmitRequest_5
    351                { /* For Status OUT stage, Length==0, Status Out PID = 1 */
    352                  hhcd->hc[ch_num].toggle_out = 1;
   \   0000003C   0x2201             MOVS     R2,#+1
   \   0000003E   0xF106 0x0340      ADD      R3,R6,#+64
   \   00000042   0x735A             STRB     R2,[R3, #+13]
   \   00000044   0xE001             B.N      ??HAL_HCD_HC_SubmitRequest_5
    353                }
    354                
    355                /* Set the Data Toggle bit as per the Flag */
    356                if ( hhcd->hc[ch_num].toggle_out == 0)
    357                { /* Put the PID 0 */
    358                  hhcd->hc[ch_num].data_pid = HC_PID_DATA0;    
    359                }
    360                else
    361                { /* Put the PID 1 */
    362                  hhcd->hc[ch_num].data_pid = HC_PID_DATA1 ;
    363                }
    364                if(hhcd->hc[ch_num].urb_state  != URB_NOTREADY)
    365                {
    366                  hhcd->hc[ch_num].do_ping = do_ping;
    367                }
    368              }
    369              break;
    370            
    371            case EP_TYPE_BULK:
    372              if(direction == 0)
   \                     ??HAL_HCD_HC_SubmitRequest_6: (+1)
   \   00000046   0x2A00             CMP      R2,#+0
   \   00000048   0xD12C             BNE.N    ??HAL_HCD_HC_SubmitRequest_7
    373              {
    374                /* Set the Data Toggle bit as per the Flag */
    375                if ( hhcd->hc[ch_num].toggle_out == 0)
   \                     ??HAL_HCD_HC_SubmitRequest_5: (+1)
   \   0000004A   0xF106 0x0240      ADD      R2,R6,#+64
   \   0000004E   0x7B53             LDRB     R3,[R2, #+13]
   \   00000050   0x2B00             CMP      R3,#+0
   \   00000052   0xD102             BNE.N    ??HAL_HCD_HC_SubmitRequest_8
    376                { /* Put the PID 0 */
    377                  hhcd->hc[ch_num].data_pid = HC_PID_DATA0;    
   \   00000054   0x2300             MOVS     R3,#+0
   \   00000056   0x727B             STRB     R3,[R7, #+9]
   \   00000058   0xE001             B.N      ??HAL_HCD_HC_SubmitRequest_9
    378                }
    379                else
    380                { /* Put the PID 1 */
    381                  hhcd->hc[ch_num].data_pid = HC_PID_DATA1 ;
   \                     ??HAL_HCD_HC_SubmitRequest_8: (+1)
   \   0000005A   0x2302             MOVS     R3,#+2
   \   0000005C   0x727B             STRB     R3,[R7, #+9]
    382                }
    383                if(hhcd->hc[ch_num].urb_state  != URB_NOTREADY)
   \                     ??HAL_HCD_HC_SubmitRequest_9: (+1)
   \   0000005E   0x7E12             LDRB     R2,[R2, #+24]
   \   00000060   0x2A02             CMP      R2,#+2
   \   00000062   0xD00B             BEQ.N    ??HAL_HCD_HC_SubmitRequest_3
    384                {
    385                  hhcd->hc[ch_num].do_ping = do_ping;
   \   00000064   0x9A09             LDR      R2,[SP, #+36]
   \   00000066   0x713A             STRB     R2,[R7, #+4]
   \   00000068   0xE008             B.N      ??HAL_HCD_HC_SubmitRequest_3
    386                }
    387              }
    388              else
    389              {
    390                if( hhcd->hc[ch_num].toggle_in == 0)
    391                {
    392                  hhcd->hc[ch_num].data_pid = HC_PID_DATA0;
    393                }
    394                else
    395                {
    396                  hhcd->hc[ch_num].data_pid = HC_PID_DATA1;
    397                }
    398              }
    399              
    400              break;
    401            case EP_TYPE_INTR:
    402              if(direction == 0)
   \                     ??HAL_HCD_HC_SubmitRequest_10: (+1)
   \   0000006A   0x2A00             CMP      R2,#+0
   \   0000006C   0xD11A             BNE.N    ??HAL_HCD_HC_SubmitRequest_7
    403              {
    404                /* Set the Data Toggle bit as per the Flag */
    405                if ( hhcd->hc[ch_num].toggle_out == 0)
   \   0000006E   0xF106 0x0240      ADD      R2,R6,#+64
   \   00000072   0x7B52             LDRB     R2,[R2, #+13]
   \   00000074   0x2A00             CMP      R2,#+0
   \   00000076   0xD11A             BNE.N    ??HAL_HCD_HC_SubmitRequest_11
    406                { /* Put the PID 0 */
    407                  hhcd->hc[ch_num].data_pid = HC_PID_DATA0;    
    408                }
    409                else
    410                { /* Put the PID 1 */
    411                  hhcd->hc[ch_num].data_pid = HC_PID_DATA1 ;
    412                }
    413              }
    414              else
    415              {
    416                if( hhcd->hc[ch_num].toggle_in == 0)
    417                {
    418                  hhcd->hc[ch_num].data_pid = HC_PID_DATA0;
    419                }
    420                else
    421                {
    422                  hhcd->hc[ch_num].data_pid = HC_PID_DATA1;
    423                }
    424              }
    425              break;
    426              
    427            case EP_TYPE_ISOC: 
    428              hhcd->hc[ch_num].data_pid = HC_PID_DATA0;
   \                     ??HAL_HCD_HC_SubmitRequest_12: (+1)
   \   00000078   0x2200             MOVS     R2,#+0
   \   0000007A   0x727A             STRB     R2,[R7, #+9]
    429              break;      
    430            }
    431            
    432            hhcd->hc[ch_num].xfer_buff = pbuff;
   \                     ??HAL_HCD_HC_SubmitRequest_3: (+1)
   \   0000007C   0xF106 0x0240      ADD      R2,R6,#+64
   \   00000080   0x9B07             LDR      R3,[SP, #+28]
   \   00000082   0x6013             STR      R3,[R2, #+0]
    433            hhcd->hc[ch_num].xfer_len  = length;
   \   00000084   0x6054             STR      R4,[R2, #+4]
    434            hhcd->hc[ch_num].urb_state =   URB_IDLE;  
   \   00000086   0x2300             MOVS     R3,#+0
   \   00000088   0x7613             STRB     R3,[R2, #+24]
    435            hhcd->hc[ch_num].xfer_count = 0 ;
   \   0000008A   0x6093             STR      R3,[R2, #+8]
    436            hhcd->hc[ch_num].ch_num = ch_num;
   \   0000008C   0x7039             STRB     R1,[R7, #+0]
    437            hhcd->hc[ch_num].state = HC_IDLE;
   \   0000008E   0x4619             MOV      R1,R3
   \   00000090   0x7651             STRB     R1,[R2, #+25]
    438            
    439            return USB_HC_StartXfer(hhcd->Instance, &(hhcd->hc[ch_num]), hhcd->Init.dma_enable);
   \   00000092   0x6902             LDR      R2,[R0, #+16]
   \   00000094   0xB2D2             UXTB     R2,R2
   \   00000096   0xF106 0x0134      ADD      R1,R6,#+52
   \   0000009A   0x6800             LDR      R0,[R0, #+0]
   \   0000009C   0xB002             ADD      SP,SP,#+8
   \   0000009E   0xBCF0             POP      {R4-R7}
   \   000000A0   0x.... 0x....      B.W      USB_HC_StartXfer
   \                     ??HAL_HCD_HC_SubmitRequest_7: (+1)
   \   000000A4   0xF106 0x0240      ADD      R2,R6,#+64
   \   000000A8   0x7B12             LDRB     R2,[R2, #+12]
   \   000000AA   0x2A00             CMP      R2,#+0
   \   000000AC   0xD0E4             BEQ.N    ??HAL_HCD_HC_SubmitRequest_12
   \                     ??HAL_HCD_HC_SubmitRequest_11: (+1)
   \   000000AE   0x2202             MOVS     R2,#+2
   \   000000B0   0x727A             STRB     R2,[R7, #+9]
   \   000000B2   0xE7E3             B.N      ??HAL_HCD_HC_SubmitRequest_3
    440          }
    441          
    442          /**
    443            * @brief  This function handles HCD interrupt request.
    444            * @param  hhcd: HCD handle
    445            * @retval None
    446            */

   \                                 In section .text, align 2, keep-with-next
    447          void HAL_HCD_IRQHandler(HCD_HandleTypeDef *hhcd)
    448          {
   \                     HAL_HCD_IRQHandler: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
    449            USB_OTG_GlobalTypeDef *USBx = hhcd->Instance;
   \   00000004   0x6826             LDR      R6,[R4, #+0]
    450            uint32_t i = 0 , interrupt = 0;
   \   00000006   0x2500             MOVS     R5,#+0
    451            
    452            /* ensure that we are in device mode */
    453            if (USB_GetMode(hhcd->Instance) == USB_OTG_MODE_HOST)
   \   00000008   0x4630             MOV      R0,R6
   \   0000000A   0x.... 0x....      BL       USB_GetMode
   \   0000000E   0x2801             CMP      R0,#+1
   \   00000010   0xF040 0x8089      BNE.W    ??HAL_HCD_IRQHandler_0
    454            {
    455              /* avoid spurious interrupt */
    456              if(__HAL_HCD_IS_INVALID_INTERRUPT(hhcd)) 
   \   00000014   0x6820             LDR      R0,[R4, #+0]
   \   00000016   0x.... 0x....      BL       USB_ReadInterrupts
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xF000 0x8083      BEQ.W    ??HAL_HCD_IRQHandler_0
    457              {
    458                return;
    459              }
    460              
    461              if(__HAL_HCD_GET_FLAG(hhcd, USB_OTG_GINTSTS_PXFR_INCOMPISOOUT))
   \   00000020   0x6820             LDR      R0,[R4, #+0]
   \   00000022   0x.... 0x....      BL       USB_ReadInterrupts
   \   00000026   0x0280             LSLS     R0,R0,#+10
   \   00000028   0xD503             BPL.N    ??HAL_HCD_IRQHandler_1
    462              {
    463               /* incorrect mode, acknowledge the interrupt */
    464                __HAL_HCD_CLEAR_FLAG(hhcd, USB_OTG_GINTSTS_PXFR_INCOMPISOOUT);
   \   0000002A   0xF44F 0x1000      MOV      R0,#+2097152
   \   0000002E   0x6821             LDR      R1,[R4, #+0]
   \   00000030   0x6148             STR      R0,[R1, #+20]
    465              }
    466              
    467              if(__HAL_HCD_GET_FLAG(hhcd, USB_OTG_GINTSTS_IISOIXFR))
   \                     ??HAL_HCD_IRQHandler_1: (+1)
   \   00000032   0x6820             LDR      R0,[R4, #+0]
   \   00000034   0x.... 0x....      BL       USB_ReadInterrupts
   \   00000038   0x02C0             LSLS     R0,R0,#+11
   \   0000003A   0xD503             BPL.N    ??HAL_HCD_IRQHandler_2
    468              {
    469               /* incorrect mode, acknowledge the interrupt */
    470                __HAL_HCD_CLEAR_FLAG(hhcd, USB_OTG_GINTSTS_IISOIXFR);
   \   0000003C   0xF44F 0x1080      MOV      R0,#+1048576
   \   00000040   0x6821             LDR      R1,[R4, #+0]
   \   00000042   0x6148             STR      R0,[R1, #+20]
    471              }
    472          
    473              if(__HAL_HCD_GET_FLAG(hhcd, USB_OTG_GINTSTS_PTXFE))
   \                     ??HAL_HCD_IRQHandler_2: (+1)
   \   00000044   0x6820             LDR      R0,[R4, #+0]
   \   00000046   0x.... 0x....      BL       USB_ReadInterrupts
   \   0000004A   0x0140             LSLS     R0,R0,#+5
   \   0000004C   0xD503             BPL.N    ??HAL_HCD_IRQHandler_3
    474              {
    475               /* incorrect mode, acknowledge the interrupt */
    476                __HAL_HCD_CLEAR_FLAG(hhcd, USB_OTG_GINTSTS_PTXFE);
   \   0000004E   0xF04F 0x6080      MOV      R0,#+67108864
   \   00000052   0x6821             LDR      R1,[R4, #+0]
   \   00000054   0x6148             STR      R0,[R1, #+20]
    477              }   
    478              
    479              if(__HAL_HCD_GET_FLAG(hhcd, USB_OTG_GINTSTS_MMIS))
   \                     ??HAL_HCD_IRQHandler_3: (+1)
   \   00000056   0x6820             LDR      R0,[R4, #+0]
   \   00000058   0x.... 0x....      BL       USB_ReadInterrupts
   \   0000005C   0x0780             LSLS     R0,R0,#+30
   \   0000005E   0xD502             BPL.N    ??HAL_HCD_IRQHandler_4
    480              {
    481               /* incorrect mode, acknowledge the interrupt */
    482                __HAL_HCD_CLEAR_FLAG(hhcd, USB_OTG_GINTSTS_MMIS);
   \   00000060   0x2002             MOVS     R0,#+2
   \   00000062   0x6821             LDR      R1,[R4, #+0]
   \   00000064   0x6148             STR      R0,[R1, #+20]
    483              }     
    484              
    485              /* Handle Host Disconnect Interrupts */
    486              if(__HAL_HCD_GET_FLAG(hhcd, USB_OTG_GINTSTS_DISCINT))
   \                     ??HAL_HCD_IRQHandler_4: (+1)
   \   00000066   0x6820             LDR      R0,[R4, #+0]
   \   00000068   0x.... 0x....      BL       USB_ReadInterrupts
   \   0000006C   0x0080             LSLS     R0,R0,#+2
   \   0000006E   0xD510             BPL.N    ??HAL_HCD_IRQHandler_5
   \   00000070   0xF506 0x6088      ADD      R0,R6,#+1088
   \   00000074   0x6801             LDR      R1,[R0, #+0]
   \   00000076   0xF021 0x012E      BIC      R1,R1,#0x2E
   \   0000007A   0x6001             STR      R1,[R0, #+0]
    487              {
    488                
    489                /* Cleanup HPRT */
    490                USBx_HPRT0 &= ~(USB_OTG_HPRT_PENA | USB_OTG_HPRT_PCDET |\
    491                  USB_OTG_HPRT_PENCHNG | USB_OTG_HPRT_POCCHNG );
    492                 
    493                /* Handle Host Port Interrupts */
    494                HAL_HCD_Disconnect_Callback(hhcd);
   \   0000007C   0x4620             MOV      R0,R4
   \   0000007E   0x.... 0x....      BL       HAL_HCD_Disconnect_Callback
    495                 USB_InitFSLSPClkSel(hhcd->Instance ,HCFG_48_MHZ );
   \   00000082   0x2101             MOVS     R1,#+1
   \   00000084   0x6820             LDR      R0,[R4, #+0]
   \   00000086   0x.... 0x....      BL       USB_InitFSLSPClkSel
    496                __HAL_HCD_CLEAR_FLAG(hhcd, USB_OTG_GINTSTS_DISCINT);
   \   0000008A   0xF04F 0x5000      MOV      R0,#+536870912
   \   0000008E   0x6821             LDR      R1,[R4, #+0]
   \   00000090   0x6148             STR      R0,[R1, #+20]
    497              }
    498              
    499              /* Handle Host Port Interrupts */
    500              if(__HAL_HCD_GET_FLAG(hhcd, USB_OTG_GINTSTS_HPRTINT))
   \                     ??HAL_HCD_IRQHandler_5: (+1)
   \   00000092   0x6820             LDR      R0,[R4, #+0]
   \   00000094   0x.... 0x....      BL       USB_ReadInterrupts
   \   00000098   0x01C0             LSLS     R0,R0,#+7
   \   0000009A   0xD502             BPL.N    ??HAL_HCD_IRQHandler_6
    501              {
    502                HCD_Port_IRQHandler (hhcd);
   \   0000009C   0x4620             MOV      R0,R4
   \   0000009E   0x.... 0x....      BL       HCD_Port_IRQHandler
    503              }
    504              
    505              /* Handle Host SOF Interrupts */
    506              if(__HAL_HCD_GET_FLAG(hhcd, USB_OTG_GINTSTS_SOF))
   \                     ??HAL_HCD_IRQHandler_6: (+1)
   \   000000A2   0x6820             LDR      R0,[R4, #+0]
   \   000000A4   0x.... 0x....      BL       USB_ReadInterrupts
   \   000000A8   0x0700             LSLS     R0,R0,#+28
   \   000000AA   0xD505             BPL.N    ??HAL_HCD_IRQHandler_7
    507              {
    508                HAL_HCD_SOF_Callback(hhcd);
   \   000000AC   0x4620             MOV      R0,R4
   \   000000AE   0x.... 0x....      BL       HAL_HCD_SOF_Callback
    509                __HAL_HCD_CLEAR_FLAG(hhcd, USB_OTG_GINTSTS_SOF);
   \   000000B2   0x2008             MOVS     R0,#+8
   \   000000B4   0x6821             LDR      R1,[R4, #+0]
   \   000000B6   0x6148             STR      R0,[R1, #+20]
    510              }
    511                    
    512              /* Handle Host channel Interrupts */
    513              if(__HAL_HCD_GET_FLAG(hhcd, USB_OTG_GINTSTS_HCINT))
   \                     ??HAL_HCD_IRQHandler_7: (+1)
   \   000000B8   0x6820             LDR      R0,[R4, #+0]
   \   000000BA   0x.... 0x....      BL       USB_ReadInterrupts
   \   000000BE   0x0180             LSLS     R0,R0,#+6
   \   000000C0   0xD51F             BPL.N    ??HAL_HCD_IRQHandler_8
    514              {
    515                interrupt = USB_HC_ReadInterrupt(hhcd->Instance);
   \   000000C2   0x6820             LDR      R0,[R4, #+0]
   \   000000C4   0x.... 0x....      BL       USB_HC_ReadInterrupt
   \   000000C8   0x4607             MOV      R7,R0
    516                for (i = 0; i < hhcd->Init.Host_channels ; i++)
   \   000000CA   0xE002             B.N      ??HAL_HCD_IRQHandler_9
    517                {
    518                  if (interrupt & (1 << i))
    519                  {
    520                    if ((USBx_HC(i)->HCCHAR) &  USB_OTG_HCCHAR_EPDIR)
    521                    {
    522                      HCD_HC_IN_IRQHandler (hhcd, i);
    523                    }
    524                    else
    525                    {
    526                      HCD_HC_OUT_IRQHandler (hhcd, i);
   \                     ??HAL_HCD_IRQHandler_10: (+1)
   \   000000CC   0x.... 0x....      BL       HCD_HC_OUT_IRQHandler
    527                    }
   \                     ??HAL_HCD_IRQHandler_11: (+1)
   \   000000D0   0x1C6D             ADDS     R5,R5,#+1
   \                     ??HAL_HCD_IRQHandler_9: (+1)
   \   000000D2   0x68A0             LDR      R0,[R4, #+8]
   \   000000D4   0x4285             CMP      R5,R0
   \   000000D6   0xD210             BCS.N    ??HAL_HCD_IRQHandler_12
   \   000000D8   0x4638             MOV      R0,R7
   \   000000DA   0x40E8             LSRS     R0,R0,R5
   \   000000DC   0x07C0             LSLS     R0,R0,#+31
   \   000000DE   0xD5F7             BPL.N    ??HAL_HCD_IRQHandler_11
   \   000000E0   0xEB06 0x1045      ADD      R0,R6,R5, LSL #+5
   \   000000E4   0xF500 0x60A0      ADD      R0,R0,#+1280
   \   000000E8   0x6800             LDR      R0,[R0, #+0]
   \   000000EA   0x0400             LSLS     R0,R0,#+16
   \   000000EC   0x4629             MOV      R1,R5
   \   000000EE   0xB2C9             UXTB     R1,R1
   \   000000F0   0x4620             MOV      R0,R4
   \   000000F2   0xD5EB             BPL.N    ??HAL_HCD_IRQHandler_10
   \   000000F4   0x.... 0x....      BL       HCD_HC_IN_IRQHandler
   \   000000F8   0xE7EA             B.N      ??HAL_HCD_IRQHandler_11
    528                  }
    529                }
    530                __HAL_HCD_CLEAR_FLAG(hhcd, USB_OTG_GINTSTS_HCINT);
   \                     ??HAL_HCD_IRQHandler_12: (+1)
   \   000000FA   0xF04F 0x7000      MOV      R0,#+33554432
   \   000000FE   0x6821             LDR      R1,[R4, #+0]
   \   00000100   0x6148             STR      R0,[R1, #+20]
    531              } 
    532              
    533                  /* Handle Rx Queue Level Interrupts */
    534              if(__HAL_HCD_GET_FLAG(hhcd, USB_OTG_GINTSTS_RXFLVL))
   \                     ??HAL_HCD_IRQHandler_8: (+1)
   \   00000102   0x6820             LDR      R0,[R4, #+0]
   \   00000104   0x.... 0x....      BL       USB_ReadInterrupts
   \   00000108   0x06C0             LSLS     R0,R0,#+27
   \   0000010A   0xD50C             BPL.N    ??HAL_HCD_IRQHandler_0
    535              {
    536                USB_MASK_INTERRUPT(hhcd->Instance, USB_OTG_GINTSTS_RXFLVL);
   \   0000010C   0x6820             LDR      R0,[R4, #+0]
   \   0000010E   0x6981             LDR      R1,[R0, #+24]
   \   00000110   0xF021 0x0110      BIC      R1,R1,#0x10
   \   00000114   0x6181             STR      R1,[R0, #+24]
    537                
    538                HCD_RXQLVL_IRQHandler (hhcd);
   \   00000116   0x4620             MOV      R0,R4
   \   00000118   0x.... 0x....      BL       HCD_RXQLVL_IRQHandler
    539                
    540                USB_UNMASK_INTERRUPT(hhcd->Instance, USB_OTG_GINTSTS_RXFLVL);
   \   0000011C   0x6820             LDR      R0,[R4, #+0]
   \   0000011E   0x6981             LDR      R1,[R0, #+24]
   \   00000120   0xF041 0x0110      ORR      R1,R1,#0x10
   \   00000124   0x6181             STR      R1,[R0, #+24]
    541              }
    542            }
    543          }
   \                     ??HAL_HCD_IRQHandler_0: (+1)
   \   00000126   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    544          
    545          /**
    546            * @brief  SOF callback.
    547            * @param  hhcd: HCD handle
    548            * @retval None
    549            */

   \                                 In section .text, align 2, keep-with-next
    550          __weak void HAL_HCD_SOF_Callback(HCD_HandleTypeDef *hhcd)
    551          {
    552            /* NOTE : This function Should not be modified, when the callback is needed,
    553                      the HAL_HCD_SOF_Callback could be implemented in the user file
    554             */
    555          }
   \                     HAL_HCD_SOF_Callback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    556          
    557          /**
    558            * @brief Connexion Event callback.
    559            * @param  hhcd: HCD handle
    560            * @retval None
    561            */

   \                                 In section .text, align 2, keep-with-next
    562          __weak void HAL_HCD_Connect_Callback(HCD_HandleTypeDef *hhcd)
    563          {
    564            /* NOTE : This function Should not be modified, when the callback is needed,
    565                      the HAL_HCD_Connect_Callback could be implemented in the user file
    566             */
    567          }
   \                     HAL_HCD_Connect_Callback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    568          
    569          /**
    570            * @brief  Disconnexion Event callback.
    571            * @param  hhcd: HCD handle
    572            * @retval None
    573            */

   \                                 In section .text, align 2, keep-with-next
    574          __weak void HAL_HCD_Disconnect_Callback(HCD_HandleTypeDef *hhcd)
    575          {
    576            /* NOTE : This function Should not be modified, when the callback is needed,
    577                      the HAL_HCD_Disconnect_Callback could be implemented in the user file
    578             */
    579          } 
   \                     HAL_HCD_Disconnect_Callback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    580          
    581          /**
    582            * @brief  Notify URB state change callback.
    583            * @param  hhcd: HCD handle
    584            * @param  chnum: Channel number.
    585            *         This parameter can be a value from 1 to 15
    586            * @param  urb_state:
    587            *          This parameter can be one of these values:
    588            *            URB_IDLE/
    589            *            URB_DONE/
    590            *            URB_NOTREADY/
    591            *            URB_NYET/ 
    592            *            URB_ERROR/  
    593            *            URB_STALL/    
    594            * @retval None
    595            */

   \                                 In section .text, align 2, keep-with-next
    596          __weak void HAL_HCD_HC_NotifyURBChange_Callback(HCD_HandleTypeDef *hhcd, uint8_t chnum, HCD_URBStateTypeDef urb_state)
    597          {
    598            /* NOTE : This function Should not be modified, when the callback is needed,
    599                      the HAL_HCD_HC_NotifyURBChange_Callback could be implemented in the user file
    600             */
    601          }
   \                     HAL_HCD_HC_NotifyURBChange_Callback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    602          
    603          /**
    604            * @}
    605            */
    606          
    607          /** @addtogroup HCD_Exported_Functions_Group3
    608           *  @brief   Peripheral management functions 
    609           *
    610          @verbatim   
    611           ===============================================================================
    612                                ##### Peripheral Control functions #####
    613           ===============================================================================  
    614              [..]
    615              This subsection provides a set of functions allowing to control the HCD data 
    616              transfers.
    617          
    618          @endverbatim
    619            * @{
    620            */
    621          
    622          /**
    623            * @brief  Start the host driver
    624            * @param  hhcd: HCD handle
    625            * @retval HAL status
    626            */

   \                                 In section .text, align 2, keep-with-next
    627          HAL_StatusTypeDef HAL_HCD_Start(HCD_HandleTypeDef *hhcd)
    628          { 
   \                     HAL_HCD_Start: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    629            __HAL_LOCK(hhcd); 
   \   00000004   0xF894 0x028C      LDRB     R0,[R4, #+652]
   \   00000008   0x2801             CMP      R0,#+1
   \   0000000A   0xD101             BNE.N    ??HAL_HCD_Start_0
   \   0000000C   0x2002             MOVS     R0,#+2
   \   0000000E   0xBD10             POP      {R4,PC}
   \                     ??HAL_HCD_Start_0: (+1)
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0xF884 0x028C      STRB     R0,[R4, #+652]
    630            __HAL_HCD_ENABLE(hhcd);
   \   00000016   0x6820             LDR      R0,[R4, #+0]
   \   00000018   0x.... 0x....      BL       USB_EnableGlobalInt
    631            USB_DriveVbus(hhcd->Instance, 1);  
   \   0000001C   0x2101             MOVS     R1,#+1
   \   0000001E   0x6820             LDR      R0,[R4, #+0]
   \   00000020   0x.... 0x....      BL       USB_DriveVbus
    632            __HAL_UNLOCK(hhcd); 
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0xF884 0x028C      STRB     R0,[R4, #+652]
    633            return HAL_OK;
   \   0000002A   0xBD10             POP      {R4,PC}          ;; return
    634          }
    635          
    636          /**
    637            * @brief  Stop the host driver
    638            * @param  hhcd: HCD handle
    639            * @retval HAL status
    640            */
    641          

   \                                 In section .text, align 2, keep-with-next
    642          HAL_StatusTypeDef HAL_HCD_Stop(HCD_HandleTypeDef *hhcd)
    643          { 
   \                     HAL_HCD_Stop: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    644            __HAL_LOCK(hhcd); 
   \   00000004   0xF894 0x028C      LDRB     R0,[R4, #+652]
   \   00000008   0x2801             CMP      R0,#+1
   \   0000000A   0xD101             BNE.N    ??HAL_HCD_Stop_0
   \   0000000C   0x2002             MOVS     R0,#+2
   \   0000000E   0xBD10             POP      {R4,PC}
   \                     ??HAL_HCD_Stop_0: (+1)
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0xF884 0x028C      STRB     R0,[R4, #+652]
    645            USB_StopHost(hhcd->Instance);
   \   00000016   0x6820             LDR      R0,[R4, #+0]
   \   00000018   0x.... 0x....      BL       USB_StopHost
    646            __HAL_UNLOCK(hhcd); 
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0xF884 0x028C      STRB     R0,[R4, #+652]
    647            return HAL_OK;
   \   00000022   0xBD10             POP      {R4,PC}          ;; return
    648          }
    649          
    650          /**
    651            * @brief  Reset the host port
    652            * @param  hhcd: HCD handle
    653            * @retval HAL status
    654            */

   \                                 In section .text, align 2, keep-with-next
    655          HAL_StatusTypeDef HAL_HCD_ResetPort(HCD_HandleTypeDef *hhcd)
    656          {
    657            return (USB_ResetPort(hhcd->Instance));
   \                     HAL_HCD_ResetPort: (+1)
   \   00000000   0x6800             LDR      R0,[R0, #+0]
   \   00000002   0x.... 0x....      B.W      USB_ResetPort
    658          }
    659          
    660          /**
    661            * @}
    662            */
    663          
    664          /** @addtogroup HCD_Exported_Functions_Group4
    665           *  @brief   Peripheral State functions 
    666           *
    667          @verbatim   
    668           ===============================================================================
    669                                ##### Peripheral State functions #####
    670           ===============================================================================  
    671              [..]
    672              This subsection permits to get in run-time the status of the peripheral 
    673              and the data flow.
    674          
    675          @endverbatim
    676            * @{
    677            */
    678          
    679          /**
    680            * @brief  Return the HCD state
    681            * @param  hhcd: HCD handle
    682            * @retval HAL state
    683            */

   \                                 In section .text, align 2, keep-with-next
    684          HCD_StateTypeDef HAL_HCD_GetState(HCD_HandleTypeDef *hhcd)
    685          {
    686            return hhcd->State;
   \                     HAL_HCD_GetState: (+1)
   \   00000000   0xF890 0x028D      LDRB     R0,[R0, #+653]
   \   00000004   0x4770             BX       LR               ;; return
    687          }
    688          
    689          /**
    690            * @brief  Return  URB state for a channel
    691            * @param  hhcd: HCD handle
    692            * @param  chnum: Channel number.
    693            *         This parameter can be a value from 1 to 15
    694            * @retval URB state.
    695            *          This parameter can be one of these values:
    696            *            URB_IDLE/
    697            *            URB_DONE/
    698            *            URB_NOTREADY/
    699            *            URB_NYET/ 
    700            *            URB_ERROR/  
    701            *            URB_STALL/
    702            */

   \                                 In section .text, align 2, keep-with-next
    703          HCD_URBStateTypeDef HAL_HCD_HC_GetURBState(HCD_HandleTypeDef *hhcd, uint8_t chnum)
    704          {
    705            return hhcd->hc[chnum].urb_state;
   \                     HAL_HCD_HC_GetURBState: (+1)
   \   00000000   0xEB01 0x0281      ADD      R2,R1,R1, LSL #+2
   \   00000004   0xEB00 0x00C2      ADD      R0,R0,R2, LSL #+3
   \   00000008   0xF890 0x0058      LDRB     R0,[R0, #+88]
   \   0000000C   0x4770             BX       LR               ;; return
    706          }
    707          
    708          
    709          /**
    710            * @brief  Return the last host transfer size
    711            * @param  hhcd: HCD handle
    712            * @param  chnum: Channel number.
    713            *         This parameter can be a value from 1 to 15
    714            * @retval last transfer size in byte
    715            */

   \                                 In section .text, align 2, keep-with-next
    716          uint32_t HAL_HCD_HC_GetXferCount(HCD_HandleTypeDef *hhcd, uint8_t chnum)
    717          {
    718            return hhcd->hc[chnum].xfer_count; 
   \                     HAL_HCD_HC_GetXferCount: (+1)
   \   00000000   0xEB01 0x0281      ADD      R2,R1,R1, LSL #+2
   \   00000004   0xEB00 0x00C2      ADD      R0,R0,R2, LSL #+3
   \   00000008   0x6C80             LDR      R0,[R0, #+72]
   \   0000000A   0x4770             BX       LR               ;; return
    719          }
    720            
    721          /**
    722            * @brief  Return the Host Channel state
    723            * @param  hhcd: HCD handle
    724            * @param  chnum: Channel number.
    725            *         This parameter can be a value from 1 to 15
    726            * @retval Host channel state
    727            *          This parameter can be one of the these values:
    728            *            HC_IDLE/
    729            *            HC_XFRC/
    730            *            HC_HALTED/
    731            *            HC_NYET/ 
    732            *            HC_NAK/  
    733            *            HC_STALL/ 
    734            *            HC_XACTERR/  
    735            *            HC_BBLERR/  
    736            *            HC_DATATGLERR/    
    737            */

   \                                 In section .text, align 2, keep-with-next
    738          HCD_HCStateTypeDef  HAL_HCD_HC_GetState(HCD_HandleTypeDef *hhcd, uint8_t chnum)
    739          {
    740            return hhcd->hc[chnum].state;
   \                     HAL_HCD_HC_GetState: (+1)
   \   00000000   0xEB01 0x0281      ADD      R2,R1,R1, LSL #+2
   \   00000004   0xEB00 0x00C2      ADD      R0,R0,R2, LSL #+3
   \   00000008   0xF890 0x0059      LDRB     R0,[R0, #+89]
   \   0000000C   0x4770             BX       LR               ;; return
    741          }
    742          
    743          /**
    744            * @brief  Return the current Host frame number
    745            * @param  hhcd: HCD handle
    746            * @retval Current Host frame number
    747            */

   \                                 In section .text, align 2, keep-with-next
    748          uint32_t HAL_HCD_GetCurrentFrame(HCD_HandleTypeDef *hhcd)
    749          {
    750            return (USB_GetCurrentFrame(hhcd->Instance));
   \                     HAL_HCD_GetCurrentFrame: (+1)
   \   00000000   0x6800             LDR      R0,[R0, #+0]
   \   00000002   0x.... 0x....      B.W      USB_GetCurrentFrame
    751          }
    752          
    753          /**
    754            * @brief  Return the Host enumeration speed
    755            * @param  hhcd: HCD handle
    756            * @retval Enumeration speed
    757            */

   \                                 In section .text, align 2, keep-with-next
    758          uint32_t HAL_HCD_GetCurrentSpeed(HCD_HandleTypeDef *hhcd)
    759          {
    760            return (USB_GetHostSpeed(hhcd->Instance));
   \                     HAL_HCD_GetCurrentSpeed: (+1)
   \   00000000   0x6800             LDR      R0,[R0, #+0]
   \   00000002   0x.... 0x....      B.W      USB_GetHostSpeed
    761          }
    762          /**
    763            * @}
    764            */
    765          
    766          /**
    767            * @}
    768            */
    769          
    770          /** @addtogroup HCD_Private_Functions
    771            * @{
    772            */
    773          /**
    774            * @brief  This function handles Host Channel IN interrupt requests.
    775            * @param  hhcd: HCD handle
    776            * @param  chnum: Channel number.
    777            *         This parameter can be a value from 1 to 15
    778            * @retval none
    779            */

   \                                 In section .text, align 2, keep-with-next
    780          static void HCD_HC_IN_IRQHandler   (HCD_HandleTypeDef *hhcd, uint8_t chnum)
    781          {
   \                     HCD_HC_IN_IRQHandler: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
    782            USB_OTG_GlobalTypeDef *USBx = hhcd->Instance;
   \   00000008   0x6820             LDR      R0,[R4, #+0]
    783              
    784            if ((USBx_HC(chnum)->HCINT) &  USB_OTG_HCINT_AHBERR)
   \   0000000A   0xEB00 0x1045      ADD      R0,R0,R5, LSL #+5
   \   0000000E   0xF500 0x66A0      ADD      R6,R0,#+1280
   \   00000012   0x68B0             LDR      R0,[R6, #+8]
   \   00000014   0x0740             LSLS     R0,R0,#+29
   \   00000016   0xD506             BPL.N    ??HCD_HC_IN_IRQHandler_0
    785            {
    786              __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_AHBERR);
   \   00000018   0x2004             MOVS     R0,#+4
   \   0000001A   0x60B0             STR      R0,[R6, #+8]
    787              __HAL_HCD_UNMASK_HALT_HC_INT(chnum);
   \   0000001C   0x68F0             LDR      R0,[R6, #+12]
   \   0000001E   0xF040 0x0002      ORR      R0,R0,#0x2
   \   00000022   0x60F0             STR      R0,[R6, #+12]
   \   00000024   0xE030             B.N      ??HCD_HC_IN_IRQHandler_1
    788            }  
    789            else if ((USBx_HC(chnum)->HCINT) &  USB_OTG_HCINT_ACK)
   \                     ??HCD_HC_IN_IRQHandler_0: (+1)
   \   00000026   0x68B0             LDR      R0,[R6, #+8]
   \   00000028   0x0680             LSLS     R0,R0,#+26
   \   0000002A   0xD502             BPL.N    ??HCD_HC_IN_IRQHandler_2
    790            {
    791              __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_ACK);
   \   0000002C   0x2020             MOVS     R0,#+32
   \   0000002E   0x60B0             STR      R0,[R6, #+8]
   \   00000030   0xE02A             B.N      ??HCD_HC_IN_IRQHandler_1
    792            }
    793            
    794            else if ((USBx_HC(chnum)->HCINT) &  USB_OTG_HCINT_STALL)  
   \                     ??HCD_HC_IN_IRQHandler_2: (+1)
   \   00000032   0xEB05 0x0085      ADD      R0,R5,R5, LSL #+2
   \   00000036   0xEB04 0x07C0      ADD      R7,R4,R0, LSL #+3
   \   0000003A   0x68B0             LDR      R0,[R6, #+8]
   \   0000003C   0x0700             LSLS     R0,R0,#+28
   \   0000003E   0xD510             BPL.N    ??HCD_HC_IN_IRQHandler_3
    795            {
    796              __HAL_HCD_UNMASK_HALT_HC_INT(chnum);
   \   00000040   0x68F0             LDR      R0,[R6, #+12]
   \   00000042   0xF040 0x0002      ORR      R0,R0,#0x2
   \   00000046   0x60F0             STR      R0,[R6, #+12]
    797              hhcd->hc[chnum].state = HC_STALL;
   \   00000048   0x2005             MOVS     R0,#+5
   \   0000004A   0xF107 0x0144      ADD      R1,R7,#+68
   \   0000004E   0x7548             STRB     R0,[R1, #+21]
    798              __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_NAK);
   \   00000050   0x2010             MOVS     R0,#+16
   \   00000052   0x60B0             STR      R0,[R6, #+8]
    799              __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_STALL);    
   \   00000054   0x2008             MOVS     R0,#+8
   \   00000056   0x60B0             STR      R0,[R6, #+8]
    800              USB_HC_Halt(hhcd->Instance, chnum);    
   \   00000058   0x4629             MOV      R1,R5
   \   0000005A   0x6820             LDR      R0,[R4, #+0]
   \   0000005C   0x.... 0x....      BL       USB_HC_Halt
   \   00000060   0xE012             B.N      ??HCD_HC_IN_IRQHandler_1
    801            }
    802            else if ((USBx_HC(chnum)->HCINT) &  USB_OTG_HCINT_DTERR)
   \                     ??HCD_HC_IN_IRQHandler_3: (+1)
   \   00000062   0x68B0             LDR      R0,[R6, #+8]
   \   00000064   0x0540             LSLS     R0,R0,#+21
   \   00000066   0xD50F             BPL.N    ??HCD_HC_IN_IRQHandler_1
    803            {
    804              __HAL_HCD_UNMASK_HALT_HC_INT(chnum);
   \   00000068   0x68F0             LDR      R0,[R6, #+12]
   \   0000006A   0xF040 0x0002      ORR      R0,R0,#0x2
   \   0000006E   0x60F0             STR      R0,[R6, #+12]
    805              USB_HC_Halt(hhcd->Instance, chnum);  
   \   00000070   0x6820             LDR      R0,[R4, #+0]
   \   00000072   0x.... 0x....      BL       USB_HC_Halt
    806              __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_NAK);    
   \   00000076   0x2010             MOVS     R0,#+16
   \   00000078   0x60B0             STR      R0,[R6, #+8]
    807              hhcd->hc[chnum].state = HC_DATATGLERR;
   \   0000007A   0x2008             MOVS     R0,#+8
   \   0000007C   0xF107 0x0144      ADD      R1,R7,#+68
   \   00000080   0x7548             STRB     R0,[R1, #+21]
    808              __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_DTERR);
   \   00000082   0xF44F 0x6080      MOV      R0,#+1024
   \   00000086   0x60B0             STR      R0,[R6, #+8]
    809            }    
    810            
    811            if ((USBx_HC(chnum)->HCINT) &  USB_OTG_HCINT_FRMOR)
   \                     ??HCD_HC_IN_IRQHandler_1: (+1)
   \   00000088   0x68B0             LDR      R0,[R6, #+8]
   \   0000008A   0x0580             LSLS     R0,R0,#+22
   \   0000008C   0xD50B             BPL.N    ??HCD_HC_IN_IRQHandler_4
    812            {
    813              __HAL_HCD_UNMASK_HALT_HC_INT(chnum); 
   \   0000008E   0x68F0             LDR      R0,[R6, #+12]
   \   00000090   0xF040 0x0002      ORR      R0,R0,#0x2
   \   00000094   0x60F0             STR      R0,[R6, #+12]
    814              USB_HC_Halt(hhcd->Instance, chnum);  
   \   00000096   0x4629             MOV      R1,R5
   \   00000098   0x6820             LDR      R0,[R4, #+0]
   \   0000009A   0x.... 0x....      BL       USB_HC_Halt
    815              __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_FRMOR);
   \   0000009E   0xF44F 0x7000      MOV      R0,#+512
   \   000000A2   0x60B0             STR      R0,[R6, #+8]
   \   000000A4   0xE0C5             B.N      ??HCD_HC_IN_IRQHandler_5
    816            }
    817            
    818            else if ((USBx_HC(chnum)->HCINT) &  USB_OTG_HCINT_XFRC)
   \                     ??HCD_HC_IN_IRQHandler_4: (+1)
   \   000000A6   0x68B0             LDR      R0,[R6, #+8]
   \   000000A8   0x07C0             LSLS     R0,R0,#+31
   \   000000AA   0xD53E             BPL.N    ??HCD_HC_IN_IRQHandler_6
    819            {
    820              
    821              if (hhcd->Init.dma_enable)
   \   000000AC   0xEB05 0x0085      ADD      R0,R5,R5, LSL #+2
   \   000000B0   0xEB04 0x07C0      ADD      R7,R4,R0, LSL #+3
   \   000000B4   0xF107 0x0844      ADD      R8,R7,#+68
   \   000000B8   0x6920             LDR      R0,[R4, #+16]
   \   000000BA   0x2800             CMP      R0,#+0
   \   000000BC   0xD007             BEQ.N    ??HCD_HC_IN_IRQHandler_7
    822              {
    823                hhcd->hc[chnum].xfer_count = hhcd->hc[chnum].xfer_len - \
    824                                         (USBx_HC(chnum)->HCTSIZ & USB_OTG_HCTSIZ_XFRSIZ);
   \   000000BE   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \   000000C2   0x6931             LDR      R1,[R6, #+16]
   \   000000C4   0x0349             LSLS     R1,R1,#+13
   \   000000C6   0xEBB0 0x3051      SUBS     R0,R0,R1, LSR #+13
   \   000000CA   0xF8C8 0x0004      STR      R0,[R8, #+4]
    825              }
    826              
    827              hhcd->hc[chnum].state = HC_XFRC;
   \                     ??HCD_HC_IN_IRQHandler_7: (+1)
   \   000000CE   0x2001             MOVS     R0,#+1
   \   000000D0   0xF888 0x0015      STRB     R0,[R8, #+21]
    828              hhcd->hc[chnum].ErrCnt = 0;
   \   000000D4   0x2000             MOVS     R0,#+0
   \   000000D6   0xF8C8 0x0010      STR      R0,[R8, #+16]
    829              __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_XFRC);
   \   000000DA   0x2001             MOVS     R0,#+1
   \   000000DC   0x60B0             STR      R0,[R6, #+8]
    830              
    831              
    832              if ((hhcd->hc[chnum].ep_type == EP_TYPE_CTRL)||
    833                  (hhcd->hc[chnum].ep_type == EP_TYPE_BULK))
   \   000000DE   0xF897 0x003B      LDRB     R0,[R7, #+59]
   \   000000E2   0x2800             CMP      R0,#+0
   \   000000E4   0xD001             BEQ.N    ??HCD_HC_IN_IRQHandler_8
   \   000000E6   0x2802             CMP      R0,#+2
   \   000000E8   0xD10A             BNE.N    ??HCD_HC_IN_IRQHandler_9
    834              {
    835                __HAL_HCD_UNMASK_HALT_HC_INT(chnum); 
   \                     ??HCD_HC_IN_IRQHandler_8: (+1)
   \   000000EA   0x68F0             LDR      R0,[R6, #+12]
   \   000000EC   0xF040 0x0002      ORR      R0,R0,#0x2
   \   000000F0   0x60F0             STR      R0,[R6, #+12]
    836                USB_HC_Halt(hhcd->Instance, chnum); 
   \   000000F2   0x4629             MOV      R1,R5
   \   000000F4   0x6820             LDR      R0,[R4, #+0]
   \   000000F6   0x.... 0x....      BL       USB_HC_Halt
    837                __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_NAK);
   \   000000FA   0x2010             MOVS     R0,#+16
   \   000000FC   0x60B0             STR      R0,[R6, #+8]
   \   000000FE   0xE00D             B.N      ??HCD_HC_IN_IRQHandler_10
    838                
    839              }
    840              else if(hhcd->hc[chnum].ep_type == EP_TYPE_INTR)
   \                     ??HCD_HC_IN_IRQHandler_9: (+1)
   \   00000100   0x2803             CMP      R0,#+3
   \   00000102   0xD10B             BNE.N    ??HCD_HC_IN_IRQHandler_10
    841              {
    842                USBx_HC(chnum)->HCCHAR |= USB_OTG_HCCHAR_ODDFRM;
   \   00000104   0x6830             LDR      R0,[R6, #+0]
   \   00000106   0xF040 0x5000      ORR      R0,R0,#0x20000000
   \   0000010A   0x6030             STR      R0,[R6, #+0]
    843                hhcd->hc[chnum].urb_state = URB_DONE; 
   \   0000010C   0x2001             MOVS     R0,#+1
   \   0000010E   0xF888 0x0014      STRB     R0,[R8, #+20]
    844                HAL_HCD_HC_NotifyURBChange_Callback(hhcd, chnum, hhcd->hc[chnum].urb_state);
   \   00000112   0x4602             MOV      R2,R0
   \   00000114   0x4629             MOV      R1,R5
   \   00000116   0x4620             MOV      R0,R4
   \   00000118   0x.... 0x....      BL       HAL_HCD_HC_NotifyURBChange_Callback
    845              }
    846              hhcd->hc[chnum].toggle_in ^= 1;
   \                     ??HCD_HC_IN_IRQHandler_10: (+1)
   \   0000011C   0xF898 0x0008      LDRB     R0,[R8, #+8]
   \   00000120   0xF080 0x0001      EOR      R0,R0,#0x1
   \   00000124   0xF888 0x0008      STRB     R0,[R8, #+8]
   \   00000128   0xE083             B.N      ??HCD_HC_IN_IRQHandler_5
    847              
    848            }
    849            else if ((USBx_HC(chnum)->HCINT) &  USB_OTG_HCINT_CHH)
   \                     ??HCD_HC_IN_IRQHandler_6: (+1)
   \   0000012A   0x68B0             LDR      R0,[R6, #+8]
   \   0000012C   0x0780             LSLS     R0,R0,#+30
   \   0000012E   0xD53D             BPL.N    ??HCD_HC_IN_IRQHandler_11
    850            {
    851              __HAL_HCD_MASK_HALT_HC_INT(chnum); 
   \   00000130   0x68F0             LDR      R0,[R6, #+12]
   \   00000132   0xF020 0x0002      BIC      R0,R0,#0x2
   \   00000136   0x60F0             STR      R0,[R6, #+12]
    852              
    853              if(hhcd->hc[chnum].state == HC_XFRC)
   \   00000138   0xEB05 0x0085      ADD      R0,R5,R5, LSL #+2
   \   0000013C   0xEB04 0x07C0      ADD      R7,R4,R0, LSL #+3
   \   00000140   0xF107 0x0844      ADD      R8,R7,#+68
   \   00000144   0xF898 0x0015      LDRB     R0,[R8, #+21]
   \   00000148   0x2801             CMP      R0,#+1
   \   0000014A   0xD103             BNE.N    ??HCD_HC_IN_IRQHandler_12
    854              {
    855                hhcd->hc[chnum].urb_state  = URB_DONE;      
   \   0000014C   0x2001             MOVS     R0,#+1
   \   0000014E   0xF888 0x0014      STRB     R0,[R8, #+20]
   \   00000152   0xE022             B.N      ??HCD_HC_IN_IRQHandler_13
    856              }
    857              
    858              else if (hhcd->hc[chnum].state == HC_STALL) 
   \                     ??HCD_HC_IN_IRQHandler_12: (+1)
   \   00000154   0x2805             CMP      R0,#+5
   \   00000156   0xD103             BNE.N    ??HCD_HC_IN_IRQHandler_14
    859              {
    860                hhcd->hc[chnum].urb_state  = URB_STALL;
   \   00000158   0x2005             MOVS     R0,#+5
   \   0000015A   0xF888 0x0014      STRB     R0,[R8, #+20]
   \   0000015E   0xE01C             B.N      ??HCD_HC_IN_IRQHandler_13
    861              }   
    862              
    863              else if((hhcd->hc[chnum].state == HC_XACTERR) ||
    864                      (hhcd->hc[chnum].state == HC_DATATGLERR))
   \                     ??HCD_HC_IN_IRQHandler_14: (+1)
   \   00000160   0x2806             CMP      R0,#+6
   \   00000162   0xD001             BEQ.N    ??HCD_HC_IN_IRQHandler_15
   \   00000164   0x2808             CMP      R0,#+8
   \   00000166   0xD118             BNE.N    ??HCD_HC_IN_IRQHandler_13
    865              {
    866                if(hhcd->hc[chnum].ErrCnt++ > 3)
   \                     ??HCD_HC_IN_IRQHandler_15: (+1)
   \   00000168   0xF8D8 0x0010      LDR      R0,[R8, #+16]
   \   0000016C   0x1C41             ADDS     R1,R0,#+1
   \   0000016E   0xF8C8 0x1010      STR      R1,[R8, #+16]
   \   00000172   0x2804             CMP      R0,#+4
   \   00000174   0xD306             BCC.N    ??HCD_HC_IN_IRQHandler_16
    867                {      
    868                  hhcd->hc[chnum].ErrCnt = 0;
   \   00000176   0x2000             MOVS     R0,#+0
   \   00000178   0xF8C8 0x0010      STR      R0,[R8, #+16]
    869                  hhcd->hc[chnum].urb_state = URB_ERROR;
   \   0000017C   0x2004             MOVS     R0,#+4
   \   0000017E   0xF888 0x0014      STRB     R0,[R8, #+20]
   \   00000182   0xE002             B.N      ??HCD_HC_IN_IRQHandler_17
    870                }
    871                else
    872                {
    873                  hhcd->hc[chnum].urb_state = URB_NOTREADY;
   \                     ??HCD_HC_IN_IRQHandler_16: (+1)
   \   00000184   0x2002             MOVS     R0,#+2
   \   00000186   0xF888 0x0014      STRB     R0,[R8, #+20]
    874                }
    875                
    876                /* re-activate the channel  */
    877                USBx_HC(chnum)->HCCHAR &= ~USB_OTG_HCCHAR_CHDIS;         
   \                     ??HCD_HC_IN_IRQHandler_17: (+1)
   \   0000018A   0x6830             LDR      R0,[R6, #+0]
   \   0000018C   0xF020 0x4080      BIC      R0,R0,#0x40000000
   \   00000190   0x6030             STR      R0,[R6, #+0]
    878                USBx_HC(chnum)->HCCHAR |= USB_OTG_HCCHAR_CHENA;      
   \   00000192   0x6830             LDR      R0,[R6, #+0]
   \   00000194   0xF040 0x4000      ORR      R0,R0,#0x80000000
   \   00000198   0x6030             STR      R0,[R6, #+0]
    879              }
    880              __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_CHH);
   \                     ??HCD_HC_IN_IRQHandler_13: (+1)
   \   0000019A   0x2002             MOVS     R0,#+2
   \   0000019C   0x60B0             STR      R0,[R6, #+8]
    881              HAL_HCD_HC_NotifyURBChange_Callback(hhcd, chnum, hhcd->hc[chnum].urb_state);
   \   0000019E   0xF898 0x2014      LDRB     R2,[R8, #+20]
   \   000001A2   0x4629             MOV      R1,R5
   \   000001A4   0x4620             MOV      R0,R4
   \   000001A6   0x.... 0x....      BL       HAL_HCD_HC_NotifyURBChange_Callback
   \   000001AA   0xE042             B.N      ??HCD_HC_IN_IRQHandler_5
    882            }  
    883            
    884            else if ((USBx_HC(chnum)->HCINT) &  USB_OTG_HCINT_TXERR)
   \                     ??HCD_HC_IN_IRQHandler_11: (+1)
   \   000001AC   0x68B0             LDR      R0,[R6, #+8]
   \   000001AE   0x0600             LSLS     R0,R0,#+24
   \   000001B0   0xD518             BPL.N    ??HCD_HC_IN_IRQHandler_18
    885            {
    886              __HAL_HCD_UNMASK_HALT_HC_INT(chnum); 
   \   000001B2   0x68F0             LDR      R0,[R6, #+12]
   \   000001B4   0xF040 0x0002      ORR      R0,R0,#0x2
   \   000001B8   0x60F0             STR      R0,[R6, #+12]
    887               hhcd->hc[chnum].ErrCnt++;
   \   000001BA   0xEB05 0x0085      ADD      R0,R5,R5, LSL #+2
   \   000001BE   0xEB04 0x07C0      ADD      R7,R4,R0, LSL #+3
   \   000001C2   0xF107 0x0844      ADD      R8,R7,#+68
   \   000001C6   0xF8D8 0x0010      LDR      R0,[R8, #+16]
   \   000001CA   0x1C40             ADDS     R0,R0,#+1
   \   000001CC   0xF8C8 0x0010      STR      R0,[R8, #+16]
    888               hhcd->hc[chnum].state = HC_XACTERR;
   \   000001D0   0x2006             MOVS     R0,#+6
   \   000001D2   0xF888 0x0015      STRB     R0,[R8, #+21]
    889               USB_HC_Halt(hhcd->Instance, chnum);     
   \   000001D6   0x4629             MOV      R1,R5
   \   000001D8   0x6820             LDR      R0,[R4, #+0]
   \   000001DA   0x.... 0x....      BL       USB_HC_Halt
    890               __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_TXERR);
   \   000001DE   0x2080             MOVS     R0,#+128
   \   000001E0   0x60B0             STR      R0,[R6, #+8]
   \   000001E2   0xE026             B.N      ??HCD_HC_IN_IRQHandler_5
    891            }
    892            else if ((USBx_HC(chnum)->HCINT) &  USB_OTG_HCINT_NAK)
   \                     ??HCD_HC_IN_IRQHandler_18: (+1)
   \   000001E4   0x68B0             LDR      R0,[R6, #+8]
   \   000001E6   0x06C0             LSLS     R0,R0,#+27
   \   000001E8   0xD523             BPL.N    ??HCD_HC_IN_IRQHandler_5
    893            {  
    894              if(hhcd->hc[chnum].ep_type == EP_TYPE_INTR)
   \   000001EA   0xEB05 0x0085      ADD      R0,R5,R5, LSL #+2
   \   000001EE   0xEB04 0x07C0      ADD      R7,R4,R0, LSL #+3
   \   000001F2   0xF897 0x003B      LDRB     R0,[R7, #+59]
   \   000001F6   0x2803             CMP      R0,#+3
   \   000001F8   0xD107             BNE.N    ??HCD_HC_IN_IRQHandler_19
    895              {
    896                __HAL_HCD_UNMASK_HALT_HC_INT(chnum); 
   \   000001FA   0x68F0             LDR      R0,[R6, #+12]
   \   000001FC   0xF040 0x0002      ORR      R0,R0,#0x2
   \   00000200   0x60F0             STR      R0,[R6, #+12]
    897                USB_HC_Halt(hhcd->Instance, chnum);  
   \   00000202   0x4629             MOV      R1,R5
   \   00000204   0x6820             LDR      R0,[R4, #+0]
   \   00000206   0x.... 0x....      BL       USB_HC_Halt
    898              }
    899              
    900              hhcd->hc[chnum].state = HC_NAK;
   \                     ??HCD_HC_IN_IRQHandler_19: (+1)
   \   0000020A   0x2003             MOVS     R0,#+3
   \   0000020C   0xF107 0x0144      ADD      R1,R7,#+68
   \   00000210   0x7548             STRB     R0,[R1, #+21]
    901              __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_NAK);
   \   00000212   0x2010             MOVS     R0,#+16
   \   00000214   0x60B0             STR      R0,[R6, #+8]
    902               
    903              if  ((hhcd->hc[chnum].ep_type == EP_TYPE_CTRL)||
    904                   (hhcd->hc[chnum].ep_type == EP_TYPE_BULK))
   \   00000216   0xF897 0x003B      LDRB     R0,[R7, #+59]
   \   0000021A   0x2800             CMP      R0,#+0
   \   0000021C   0xD001             BEQ.N    ??HCD_HC_IN_IRQHandler_20
   \   0000021E   0x2802             CMP      R0,#+2
   \   00000220   0xD107             BNE.N    ??HCD_HC_IN_IRQHandler_5
    905              {
    906                /* re-activate the channel  */
    907                USBx_HC(chnum)->HCCHAR &= ~USB_OTG_HCCHAR_CHDIS;         
   \                     ??HCD_HC_IN_IRQHandler_20: (+1)
   \   00000222   0x6830             LDR      R0,[R6, #+0]
   \   00000224   0xF020 0x4080      BIC      R0,R0,#0x40000000
   \   00000228   0x6030             STR      R0,[R6, #+0]
    908                USBx_HC(chnum)->HCCHAR |= USB_OTG_HCCHAR_CHENA;
   \   0000022A   0x6830             LDR      R0,[R6, #+0]
   \   0000022C   0xF040 0x4000      ORR      R0,R0,#0x80000000
   \   00000230   0x6030             STR      R0,[R6, #+0]
    909              }
    910            }
    911          }
   \                     ??HCD_HC_IN_IRQHandler_5: (+1)
   \   00000232   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    912          
    913          /**
    914            * @brief  This function handles Host Channel OUT interrupt requests.
    915            * @param  hhcd: HCD handle
    916            * @param  chnum: Channel number.
    917            *         This parameter can be a value from 1 to 15
    918            * @retval none
    919            */

   \                                 In section .text, align 2, keep-with-next
    920          static void HCD_HC_OUT_IRQHandler  (HCD_HandleTypeDef *hhcd, uint8_t chnum)
    921          {
   \                     HCD_HC_OUT_IRQHandler: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    922            USB_OTG_GlobalTypeDef *USBx = hhcd->Instance;
   \   00000006   0x6820             LDR      R0,[R4, #+0]
    923            
    924            if ((USBx_HC(chnum)->HCINT) &  USB_OTG_HCINT_AHBERR)
   \   00000008   0xEB00 0x1045      ADD      R0,R0,R5, LSL #+5
   \   0000000C   0xF500 0x66A0      ADD      R6,R0,#+1280
   \   00000010   0x68B0             LDR      R0,[R6, #+8]
   \   00000012   0x0740             LSLS     R0,R0,#+29
   \   00000014   0xD506             BPL.N    ??HCD_HC_OUT_IRQHandler_0
    925            {
    926              __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_AHBERR);
   \   00000016   0x2004             MOVS     R0,#+4
   \   00000018   0x60B0             STR      R0,[R6, #+8]
    927              __HAL_HCD_UNMASK_HALT_HC_INT(chnum);
   \   0000001A   0x68F0             LDR      R0,[R6, #+12]
   \   0000001C   0xF040 0x0002      ORR      R0,R0,#0x2
   \   00000020   0x60F0             STR      R0,[R6, #+12]
   \   00000022   0xBDF1             POP      {R0,R4-R7,PC}
    928            }  
    929            else if ((USBx_HC(chnum)->HCINT) &  USB_OTG_HCINT_ACK)
   \                     ??HCD_HC_OUT_IRQHandler_0: (+1)
   \   00000024   0x68B0             LDR      R0,[R6, #+8]
   \   00000026   0x0680             LSLS     R0,R0,#+26
   \   00000028   0xD519             BPL.N    ??HCD_HC_OUT_IRQHandler_1
    930            {
    931              __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_ACK);
   \   0000002A   0x2020             MOVS     R0,#+32
   \   0000002C   0x60B0             STR      R0,[R6, #+8]
    932              
    933              if( hhcd->hc[chnum].do_ping == 1)
   \   0000002E   0xEB05 0x0085      ADD      R0,R5,R5, LSL #+2
   \   00000032   0xEB04 0x00C0      ADD      R0,R4,R0, LSL #+3
   \   00000036   0xF890 0x1039      LDRB     R1,[R0, #+57]
   \   0000003A   0x2901             CMP      R1,#+1
   \   0000003C   0xF040 0x80EC      BNE.W    ??HCD_HC_OUT_IRQHandler_2
    934              {
    935                hhcd->hc[chnum].state = HC_NYET;     
   \   00000040   0xF100 0x0754      ADD      R7,R0,#+84
   \   00000044   0x2004             MOVS     R0,#+4
   \   00000046   0x7178             STRB     R0,[R7, #+5]
    936                __HAL_HCD_UNMASK_HALT_HC_INT(chnum); 
   \   00000048   0x68F0             LDR      R0,[R6, #+12]
   \   0000004A   0xF040 0x0002      ORR      R0,R0,#0x2
   \   0000004E   0x60F0             STR      R0,[R6, #+12]
    937                USB_HC_Halt(hhcd->Instance, chnum); 
   \   00000050   0x4629             MOV      R1,R5
   \   00000052   0x6820             LDR      R0,[R4, #+0]
   \   00000054   0x.... 0x....      BL       USB_HC_Halt
    938                hhcd->hc[chnum].urb_state  = URB_NOTREADY;
   \   00000058   0x2002             MOVS     R0,#+2
   \   0000005A   0x7138             STRB     R0,[R7, #+4]
   \   0000005C   0xBDF1             POP      {R0,R4-R7,PC}
    939              }
    940            }
    941            
    942            else if ((USBx_HC(chnum)->HCINT) &  USB_OTG_HCINT_NYET)
   \                     ??HCD_HC_OUT_IRQHandler_1: (+1)
   \   0000005E   0x68B0             LDR      R0,[R6, #+8]
   \   00000060   0x0640             LSLS     R0,R0,#+25
   \   00000062   0xD513             BPL.N    ??HCD_HC_OUT_IRQHandler_3
    943            {
    944              hhcd->hc[chnum].state = HC_NYET;
   \   00000064   0xEB05 0x0085      ADD      R0,R5,R5, LSL #+2
   \   00000068   0xEB04 0x00C0      ADD      R0,R4,R0, LSL #+3
   \   0000006C   0xF100 0x0754      ADD      R7,R0,#+84
   \   00000070   0x2004             MOVS     R0,#+4
   \   00000072   0x7178             STRB     R0,[R7, #+5]
    945              hhcd->hc[chnum].ErrCnt= 0;    
   \   00000074   0x2000             MOVS     R0,#+0
   \   00000076   0x6038             STR      R0,[R7, #+0]
    946              __HAL_HCD_UNMASK_HALT_HC_INT(chnum); 
   \   00000078   0x68F0             LDR      R0,[R6, #+12]
   \   0000007A   0xF040 0x0002      ORR      R0,R0,#0x2
   \   0000007E   0x60F0             STR      R0,[R6, #+12]
    947              USB_HC_Halt(hhcd->Instance, chnum);      
   \   00000080   0x6820             LDR      R0,[R4, #+0]
   \   00000082   0x.... 0x....      BL       USB_HC_Halt
    948              __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_NYET);
   \   00000086   0x2040             MOVS     R0,#+64
   \   00000088   0x60B0             STR      R0,[R6, #+8]
   \   0000008A   0xBDF1             POP      {R0,R4-R7,PC}
    949              
    950            }  
    951            
    952            else if ((USBx_HC(chnum)->HCINT) &  USB_OTG_HCINT_FRMOR)
   \                     ??HCD_HC_OUT_IRQHandler_3: (+1)
   \   0000008C   0x68B0             LDR      R0,[R6, #+8]
   \   0000008E   0x0580             LSLS     R0,R0,#+22
   \   00000090   0xD50A             BPL.N    ??HCD_HC_OUT_IRQHandler_4
    953            {
    954              __HAL_HCD_UNMASK_HALT_HC_INT(chnum); 
   \   00000092   0x68F0             LDR      R0,[R6, #+12]
   \   00000094   0xF040 0x0002      ORR      R0,R0,#0x2
   \   00000098   0x60F0             STR      R0,[R6, #+12]
    955              USB_HC_Halt(hhcd->Instance, chnum);  
   \   0000009A   0x6820             LDR      R0,[R4, #+0]
   \   0000009C   0x.... 0x....      BL       USB_HC_Halt
    956              __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_FRMOR);
   \   000000A0   0xF44F 0x7000      MOV      R0,#+512
   \   000000A4   0x60B0             STR      R0,[R6, #+8]
   \   000000A6   0xBDF1             POP      {R0,R4-R7,PC}
    957            }
    958            
    959            else if ((USBx_HC(chnum)->HCINT) &  USB_OTG_HCINT_XFRC)
   \                     ??HCD_HC_OUT_IRQHandler_4: (+1)
   \   000000A8   0x68B0             LDR      R0,[R6, #+8]
   \   000000AA   0x07C0             LSLS     R0,R0,#+31
   \   000000AC   0xD512             BPL.N    ??HCD_HC_OUT_IRQHandler_5
    960            {
    961                hhcd->hc[chnum].ErrCnt = 0;  
   \   000000AE   0xEB05 0x0085      ADD      R0,R5,R5, LSL #+2
   \   000000B2   0xEB04 0x00C0      ADD      R0,R4,R0, LSL #+3
   \   000000B6   0xF100 0x0754      ADD      R7,R0,#+84
   \   000000BA   0x2000             MOVS     R0,#+0
   \   000000BC   0x6038             STR      R0,[R7, #+0]
    962              __HAL_HCD_UNMASK_HALT_HC_INT(chnum);
   \   000000BE   0x68F0             LDR      R0,[R6, #+12]
   \   000000C0   0xF040 0x0002      ORR      R0,R0,#0x2
   \   000000C4   0x60F0             STR      R0,[R6, #+12]
    963              USB_HC_Halt(hhcd->Instance, chnum);   
   \   000000C6   0x6820             LDR      R0,[R4, #+0]
   \   000000C8   0x.... 0x....      BL       USB_HC_Halt
    964              __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_XFRC);
   \   000000CC   0x2001             MOVS     R0,#+1
   \   000000CE   0x60B0             STR      R0,[R6, #+8]
    965              hhcd->hc[chnum].state = HC_XFRC;
   \   000000D0   0x7178             STRB     R0,[R7, #+5]
   \   000000D2   0xBDF1             POP      {R0,R4-R7,PC}
    966          
    967            }  
    968          
    969            else if ((USBx_HC(chnum)->HCINT) &  USB_OTG_HCINT_STALL)  
   \                     ??HCD_HC_OUT_IRQHandler_5: (+1)
   \   000000D4   0x68B0             LDR      R0,[R6, #+8]
   \   000000D6   0x0700             LSLS     R0,R0,#+28
   \   000000D8   0xD510             BPL.N    ??HCD_HC_OUT_IRQHandler_6
    970            {
    971              __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_STALL);  
   \   000000DA   0x2008             MOVS     R0,#+8
   \   000000DC   0x60B0             STR      R0,[R6, #+8]
    972              __HAL_HCD_UNMASK_HALT_HC_INT(chnum);
   \   000000DE   0x68F0             LDR      R0,[R6, #+12]
   \   000000E0   0xF040 0x0002      ORR      R0,R0,#0x2
   \   000000E4   0x60F0             STR      R0,[R6, #+12]
    973              USB_HC_Halt(hhcd->Instance, chnum);   
   \   000000E6   0x6820             LDR      R0,[R4, #+0]
   \   000000E8   0x.... 0x....      BL       USB_HC_Halt
    974              hhcd->hc[chnum].state = HC_STALL;    
   \   000000EC   0xEB05 0x0085      ADD      R0,R5,R5, LSL #+2
   \   000000F0   0xEB04 0x00C0      ADD      R0,R4,R0, LSL #+3
   \   000000F4   0x3054             ADDS     R0,R0,#+84
   \   000000F6   0x2105             MOVS     R1,#+5
   \   000000F8   0x7141             STRB     R1,[R0, #+5]
   \   000000FA   0xBDF1             POP      {R0,R4-R7,PC}
    975            }
    976          
    977            else if ((USBx_HC(chnum)->HCINT) &  USB_OTG_HCINT_NAK)
   \                     ??HCD_HC_OUT_IRQHandler_6: (+1)
   \   000000FC   0x68B0             LDR      R0,[R6, #+8]
   \   000000FE   0x06C0             LSLS     R0,R0,#+27
   \   00000100   0xD513             BPL.N    ??HCD_HC_OUT_IRQHandler_7
    978            {  
    979              hhcd->hc[chnum].ErrCnt = 0;  
   \   00000102   0xEB05 0x0085      ADD      R0,R5,R5, LSL #+2
   \   00000106   0xEB04 0x00C0      ADD      R0,R4,R0, LSL #+3
   \   0000010A   0xF100 0x0754      ADD      R7,R0,#+84
   \   0000010E   0x2000             MOVS     R0,#+0
   \   00000110   0x6038             STR      R0,[R7, #+0]
    980              __HAL_HCD_UNMASK_HALT_HC_INT(chnum); 
   \   00000112   0x68F0             LDR      R0,[R6, #+12]
   \   00000114   0xF040 0x0002      ORR      R0,R0,#0x2
   \   00000118   0x60F0             STR      R0,[R6, #+12]
    981              USB_HC_Halt(hhcd->Instance, chnum);   
   \   0000011A   0x6820             LDR      R0,[R4, #+0]
   \   0000011C   0x.... 0x....      BL       USB_HC_Halt
    982              hhcd->hc[chnum].state = HC_NAK;
   \   00000120   0x2003             MOVS     R0,#+3
   \   00000122   0x7178             STRB     R0,[R7, #+5]
    983              __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_NAK);
   \   00000124   0x2010             MOVS     R0,#+16
   \   00000126   0x60B0             STR      R0,[R6, #+8]
   \   00000128   0xBDF1             POP      {R0,R4-R7,PC}
    984            }
    985          
    986            else if ((USBx_HC(chnum)->HCINT) &  USB_OTG_HCINT_TXERR)
   \                     ??HCD_HC_OUT_IRQHandler_7: (+1)
   \   0000012A   0x68B0             LDR      R0,[R6, #+8]
   \   0000012C   0x0600             LSLS     R0,R0,#+24
   \   0000012E   0xD510             BPL.N    ??HCD_HC_OUT_IRQHandler_8
    987            {
    988              __HAL_HCD_UNMASK_HALT_HC_INT(chnum); 
   \   00000130   0x68F0             LDR      R0,[R6, #+12]
   \   00000132   0xF040 0x0002      ORR      R0,R0,#0x2
   \   00000136   0x60F0             STR      R0,[R6, #+12]
    989              USB_HC_Halt(hhcd->Instance, chnum);      
   \   00000138   0x6820             LDR      R0,[R4, #+0]
   \   0000013A   0x.... 0x....      BL       USB_HC_Halt
    990              hhcd->hc[chnum].state = HC_XACTERR;  
   \   0000013E   0xEB05 0x0085      ADD      R0,R5,R5, LSL #+2
   \   00000142   0xEB04 0x00C0      ADD      R0,R4,R0, LSL #+3
   \   00000146   0x3054             ADDS     R0,R0,#+84
   \   00000148   0x2106             MOVS     R1,#+6
   \   0000014A   0x7141             STRB     R1,[R0, #+5]
    991               __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_TXERR);
   \   0000014C   0x2080             MOVS     R0,#+128
   \   0000014E   0x60B0             STR      R0,[R6, #+8]
   \   00000150   0xBDF1             POP      {R0,R4-R7,PC}
    992            }
    993            
    994            else if ((USBx_HC(chnum)->HCINT) &  USB_OTG_HCINT_DTERR)
   \                     ??HCD_HC_OUT_IRQHandler_8: (+1)
   \   00000152   0x68B0             LDR      R0,[R6, #+8]
   \   00000154   0x0540             LSLS     R0,R0,#+21
   \   00000156   0xD513             BPL.N    ??HCD_HC_OUT_IRQHandler_9
    995            {
    996              __HAL_HCD_UNMASK_HALT_HC_INT(chnum); 
   \   00000158   0x68F0             LDR      R0,[R6, #+12]
   \   0000015A   0xF040 0x0002      ORR      R0,R0,#0x2
   \   0000015E   0x60F0             STR      R0,[R6, #+12]
    997              USB_HC_Halt(hhcd->Instance, chnum);      
   \   00000160   0x6820             LDR      R0,[R4, #+0]
   \   00000162   0x.... 0x....      BL       USB_HC_Halt
    998              __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_NAK);
   \   00000166   0x2010             MOVS     R0,#+16
   \   00000168   0x60B0             STR      R0,[R6, #+8]
    999              __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_DTERR);    
   \   0000016A   0xF44F 0x6080      MOV      R0,#+1024
   \   0000016E   0x60B0             STR      R0,[R6, #+8]
   1000              hhcd->hc[chnum].state = HC_DATATGLERR;
   \   00000170   0xEB05 0x0085      ADD      R0,R5,R5, LSL #+2
   \   00000174   0xEB04 0x00C0      ADD      R0,R4,R0, LSL #+3
   \   00000178   0x3054             ADDS     R0,R0,#+84
   \   0000017A   0x2108             MOVS     R1,#+8
   \   0000017C   0x7141             STRB     R1,[R0, #+5]
   \   0000017E   0xBDF1             POP      {R0,R4-R7,PC}
   1001            }
   1002            
   1003            
   1004            else if ((USBx_HC(chnum)->HCINT) &  USB_OTG_HCINT_CHH)
   \                     ??HCD_HC_OUT_IRQHandler_9: (+1)
   \   00000180   0x68B0             LDR      R0,[R6, #+8]
   \   00000182   0x0780             LSLS     R0,R0,#+30
   \   00000184   0xD548             BPL.N    ??HCD_HC_OUT_IRQHandler_2
   1005            {
   1006              __HAL_HCD_MASK_HALT_HC_INT(chnum); 
   \   00000186   0x68F0             LDR      R0,[R6, #+12]
   \   00000188   0xF020 0x0002      BIC      R0,R0,#0x2
   \   0000018C   0x60F0             STR      R0,[R6, #+12]
   1007              
   1008              if(hhcd->hc[chnum].state == HC_XFRC)
   \   0000018E   0xEB05 0x0085      ADD      R0,R5,R5, LSL #+2
   \   00000192   0xEB04 0x00C0      ADD      R0,R4,R0, LSL #+3
   \   00000196   0xF100 0x0754      ADD      R7,R0,#+84
   \   0000019A   0x7979             LDRB     R1,[R7, #+5]
   \   0000019C   0x2901             CMP      R1,#+1
   \   0000019E   0xD10A             BNE.N    ??HCD_HC_OUT_IRQHandler_10
   1009              {
   1010                hhcd->hc[chnum].urb_state  = URB_DONE;
   \   000001A0   0x2101             MOVS     R1,#+1
   \   000001A2   0x7139             STRB     R1,[R7, #+4]
   1011                if (hhcd->hc[chnum].ep_type == EP_TYPE_BULK)
   \   000001A4   0x3039             ADDS     R0,R0,#+57
   \   000001A6   0x7881             LDRB     R1,[R0, #+2]
   \   000001A8   0x2902             CMP      R1,#+2
   \   000001AA   0xD12E             BNE.N    ??HCD_HC_OUT_IRQHandler_11
   1012                {
   1013                  hhcd->hc[chnum].toggle_out ^= 1; 
   \   000001AC   0x7D01             LDRB     R1,[R0, #+20]
   \   000001AE   0xF081 0x0101      EOR      R1,R1,#0x1
   \   000001B2   0x7501             STRB     R1,[R0, #+20]
   \   000001B4   0xE029             B.N      ??HCD_HC_OUT_IRQHandler_11
   1014                }      
   1015              }
   1016              else if (hhcd->hc[chnum].state == HC_NAK) 
   \                     ??HCD_HC_OUT_IRQHandler_10: (+1)
   \   000001B6   0x2903             CMP      R1,#+3
   \   000001B8   0xD102             BNE.N    ??HCD_HC_OUT_IRQHandler_12
   1017              {
   1018                hhcd->hc[chnum].urb_state  = URB_NOTREADY;
   \   000001BA   0x2002             MOVS     R0,#+2
   \   000001BC   0x7138             STRB     R0,[R7, #+4]
   \   000001BE   0xE024             B.N      ??HCD_HC_OUT_IRQHandler_11
   1019              }  
   1020              
   1021              else if (hhcd->hc[chnum].state == HC_NYET) 
   \                     ??HCD_HC_OUT_IRQHandler_12: (+1)
   \   000001C0   0x2904             CMP      R1,#+4
   \   000001C2   0xD105             BNE.N    ??HCD_HC_OUT_IRQHandler_13
   1022              {
   1023                hhcd->hc[chnum].urb_state  = URB_NOTREADY;
   \   000001C4   0x2102             MOVS     R1,#+2
   \   000001C6   0x7139             STRB     R1,[R7, #+4]
   1024                hhcd->hc[chnum].do_ping = 0;
   \   000001C8   0x2100             MOVS     R1,#+0
   \   000001CA   0xF880 0x1039      STRB     R1,[R0, #+57]
   \   000001CE   0xE01C             B.N      ??HCD_HC_OUT_IRQHandler_11
   1025              }   
   1026              
   1027              else if (hhcd->hc[chnum].state == HC_STALL) 
   \                     ??HCD_HC_OUT_IRQHandler_13: (+1)
   \   000001D0   0x2905             CMP      R1,#+5
   \   000001D2   0xD102             BNE.N    ??HCD_HC_OUT_IRQHandler_14
   1028              {
   1029                hhcd->hc[chnum].urb_state  = URB_STALL;
   \   000001D4   0x2005             MOVS     R0,#+5
   \   000001D6   0x7138             STRB     R0,[R7, #+4]
   \   000001D8   0xE017             B.N      ??HCD_HC_OUT_IRQHandler_11
   1030              } 
   1031              
   1032              else if((hhcd->hc[chnum].state == HC_XACTERR) ||
   1033                      (hhcd->hc[chnum].state == HC_DATATGLERR))
   \                     ??HCD_HC_OUT_IRQHandler_14: (+1)
   \   000001DA   0x2906             CMP      R1,#+6
   \   000001DC   0xD001             BEQ.N    ??HCD_HC_OUT_IRQHandler_15
   \   000001DE   0x2908             CMP      R1,#+8
   \   000001E0   0xD113             BNE.N    ??HCD_HC_OUT_IRQHandler_11
   1034              {
   1035                if(hhcd->hc[chnum].ErrCnt++ > 3)
   \                     ??HCD_HC_OUT_IRQHandler_15: (+1)
   \   000001E2   0x6838             LDR      R0,[R7, #+0]
   \   000001E4   0x1C41             ADDS     R1,R0,#+1
   \   000001E6   0x6039             STR      R1,[R7, #+0]
   \   000001E8   0x2804             CMP      R0,#+4
   \   000001EA   0xD304             BCC.N    ??HCD_HC_OUT_IRQHandler_16
   1036                {      
   1037                  hhcd->hc[chnum].ErrCnt = 0;
   \   000001EC   0x2000             MOVS     R0,#+0
   \   000001EE   0x6038             STR      R0,[R7, #+0]
   1038                  hhcd->hc[chnum].urb_state = URB_ERROR;
   \   000001F0   0x2004             MOVS     R0,#+4
   \   000001F2   0x7138             STRB     R0,[R7, #+4]
   \   000001F4   0xE001             B.N      ??HCD_HC_OUT_IRQHandler_17
   1039                }
   1040                else
   1041                {
   1042                  hhcd->hc[chnum].urb_state = URB_NOTREADY;
   \                     ??HCD_HC_OUT_IRQHandler_16: (+1)
   \   000001F6   0x2002             MOVS     R0,#+2
   \   000001F8   0x7138             STRB     R0,[R7, #+4]
   1043                }
   1044                
   1045                /* re-activate the channel  */
   1046                USBx_HC(chnum)->HCCHAR &= ~USB_OTG_HCCHAR_CHDIS;         
   \                     ??HCD_HC_OUT_IRQHandler_17: (+1)
   \   000001FA   0x6830             LDR      R0,[R6, #+0]
   \   000001FC   0xF020 0x4080      BIC      R0,R0,#0x40000000
   \   00000200   0x6030             STR      R0,[R6, #+0]
   1047                USBx_HC(chnum)->HCCHAR |= USB_OTG_HCCHAR_CHENA;      
   \   00000202   0x6830             LDR      R0,[R6, #+0]
   \   00000204   0xF040 0x4000      ORR      R0,R0,#0x80000000
   \   00000208   0x6030             STR      R0,[R6, #+0]
   1048              }
   1049              
   1050              __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_CHH);
   \                     ??HCD_HC_OUT_IRQHandler_11: (+1)
   \   0000020A   0x2002             MOVS     R0,#+2
   \   0000020C   0x60B0             STR      R0,[R6, #+8]
   1051              HAL_HCD_HC_NotifyURBChange_Callback(hhcd, chnum, hhcd->hc[chnum].urb_state);  
   \   0000020E   0x793A             LDRB     R2,[R7, #+4]
   \   00000210   0x4629             MOV      R1,R5
   \   00000212   0x4620             MOV      R0,R4
   \   00000214   0x.... 0x....      BL       HAL_HCD_HC_NotifyURBChange_Callback
   1052            }
   1053          } 
   \                     ??HCD_HC_OUT_IRQHandler_2: (+1)
   \   00000218   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
   1054          
   1055          /**
   1056            * @brief  This function handles Rx Queue Level interrupt requests.
   1057            * @param  hhcd: HCD handle
   1058            * @retval none
   1059            */

   \                                 In section .text, align 2, keep-with-next
   1060          static void HCD_RXQLVL_IRQHandler  (HCD_HandleTypeDef *hhcd)
   1061          {
   \                     HCD_RXQLVL_IRQHandler: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4601             MOV      R1,R0
   1062            USB_OTG_GlobalTypeDef *USBx = hhcd->Instance;  
   \   00000004   0x6808             LDR      R0,[R1, #+0]
   \   00000006   0x4604             MOV      R4,R0
   1063            uint8_t                       channelnum =0;  
   1064            uint32_t                      pktsts;
   1065            uint32_t                      pktcnt; 
   1066            uint32_t                      temp = 0;
   1067            
   1068            temp = hhcd->Instance->GRXSTSP ;
   \   00000008   0x6A02             LDR      R2,[R0, #+32]
   1069            channelnum = temp &  USB_OTG_GRXSTSP_EPNUM;  
   \   0000000A   0xF002 0x050F      AND      R5,R2,#0xF
   1070            pktsts = (temp &  USB_OTG_GRXSTSP_PKTSTS) >> 17;
   1071            pktcnt = (temp &  USB_OTG_GRXSTSP_BCNT) >> 4;
   \   0000000E   0xF3C2 0x160A      UBFX     R6,R2,#+4,#+11
   1072              
   1073            switch (pktsts)
   \   00000012   0xF3C2 0x4243      UBFX     R2,R2,#+17,#+4
   \   00000016   0x2A02             CMP      R2,#+2
   \   00000018   0xD127             BNE.N    ??HCD_RXQLVL_IRQHandler_0
   1074            {
   1075            case GRXSTS_PKTSTS_IN:
   1076              /* Read the data into the host buffer. */
   1077              if ((pktcnt > 0) && (hhcd->hc[channelnum].xfer_buff != (void  *)0))
   \   0000001A   0x2E00             CMP      R6,#+0
   \   0000001C   0xD025             BEQ.N    ??HCD_RXQLVL_IRQHandler_0
   \   0000001E   0xEB05 0x0285      ADD      R2,R5,R5, LSL #+2
   \   00000022   0xEB01 0x01C2      ADD      R1,R1,R2, LSL #+3
   \   00000026   0xF101 0x0740      ADD      R7,R1,#+64
   \   0000002A   0x6839             LDR      R1,[R7, #+0]
   \   0000002C   0x2900             CMP      R1,#+0
   \   0000002E   0xD01C             BEQ.N    ??HCD_RXQLVL_IRQHandler_0
   1078              {  
   1079                
   1080                USB_ReadPacket(hhcd->Instance, hhcd->hc[channelnum].xfer_buff, pktcnt);
   \   00000030   0x4632             MOV      R2,R6
   \   00000032   0x.... 0x....      BL       USB_ReadPacket
   1081               
   1082                /*manage multiple Xfer */
   1083                hhcd->hc[channelnum].xfer_buff += pktcnt;           
   \   00000036   0x6838             LDR      R0,[R7, #+0]
   \   00000038   0x1830             ADDS     R0,R6,R0
   \   0000003A   0x6038             STR      R0,[R7, #+0]
   1084                hhcd->hc[channelnum].xfer_count  += pktcnt;
   \   0000003C   0x68B8             LDR      R0,[R7, #+8]
   \   0000003E   0x1830             ADDS     R0,R6,R0
   \   00000040   0x60B8             STR      R0,[R7, #+8]
   1085                  
   1086                if((USBx_HC(channelnum)->HCTSIZ & USB_OTG_HCTSIZ_PKTCNT) > 0)
   \   00000042   0xEB04 0x1045      ADD      R0,R4,R5, LSL #+5
   \   00000046   0xF500 0x60A0      ADD      R0,R0,#+1280
   \   0000004A   0x6901             LDR      R1,[R0, #+16]
   \   0000004C   0x....             LDR.N    R2,??DataTable0  ;; 0x1ff80000
   \   0000004E   0x4211             TST      R1,R2
   \   00000050   0xD00B             BEQ.N    ??HCD_RXQLVL_IRQHandler_0
   1087                {
   1088                  /* re-activate the channel when more packets are expected */
   1089                  USBx_HC(channelnum)->HCCHAR &= ~USB_OTG_HCCHAR_CHDIS; 
   \   00000052   0x6801             LDR      R1,[R0, #+0]
   \   00000054   0xF021 0x4180      BIC      R1,R1,#0x40000000
   \   00000058   0x6001             STR      R1,[R0, #+0]
   1090                  USBx_HC(channelnum)->HCCHAR |= USB_OTG_HCCHAR_CHENA;
   \   0000005A   0x6801             LDR      R1,[R0, #+0]
   \   0000005C   0xF041 0x4100      ORR      R1,R1,#0x80000000
   \   00000060   0x6001             STR      R1,[R0, #+0]
   1091                  hhcd->hc[channelnum].toggle_in ^= 1;
   \   00000062   0x7B38             LDRB     R0,[R7, #+12]
   \   00000064   0xF080 0x0001      EOR      R0,R0,#0x1
   \   00000068   0x7338             STRB     R0,[R7, #+12]
   1092                }
   1093              }
   1094              break;
   1095          
   1096            case GRXSTS_PKTSTS_DATA_TOGGLE_ERR:
   1097              break;
   1098            case GRXSTS_PKTSTS_IN_XFER_COMP:
   1099            case GRXSTS_PKTSTS_CH_HALTED:
   1100            default:
   1101              break;
   1102            }
   1103          }
   \                     ??HCD_RXQLVL_IRQHandler_0: (+1)
   \   0000006A   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
   1104          
   1105          /**
   1106            * @brief  This function handles Host Port interrupt requests.
   1107            * @param  hhcd: HCD handle
   1108            * @retval None
   1109            */

   \                                 In section .text, align 2, keep-with-next
   1110          static void HCD_Port_IRQHandler  (HCD_HandleTypeDef *hhcd)
   1111          {
   \                     HCD_Port_IRQHandler: (+1)
   \   00000000   0xB57C             PUSH     {R2-R6,LR}
   \   00000002   0x4605             MOV      R5,R0
   1112            USB_OTG_GlobalTypeDef *USBx = hhcd->Instance;  
   \   00000004   0x6828             LDR      R0,[R5, #+0]
   1113            __IO uint32_t hprt0, hprt0_dup;
   1114            
   1115            /* Handle Host Port Interrupts */
   1116            hprt0 = USBx_HPRT0;
   \   00000006   0x4606             MOV      R6,R0
   \   00000008   0xF506 0x6488      ADD      R4,R6,#+1088
   \   0000000C   0x6821             LDR      R1,[R4, #+0]
   \   0000000E   0x9101             STR      R1,[SP, #+4]
   1117            hprt0_dup = USBx_HPRT0;
   \   00000010   0x6821             LDR      R1,[R4, #+0]
   \   00000012   0x9100             STR      R1,[SP, #+0]
   1118            
   1119            hprt0_dup &= ~(USB_OTG_HPRT_PENA | USB_OTG_HPRT_PCDET |\
   1120                           USB_OTG_HPRT_PENCHNG | USB_OTG_HPRT_POCCHNG );
   \   00000014   0x9900             LDR      R1,[SP, #+0]
   \   00000016   0xF021 0x012E      BIC      R1,R1,#0x2E
   \   0000001A   0x9100             STR      R1,[SP, #+0]
   1121            
   1122            /* Check whether Port Connect detected */
   1123            if((hprt0 & USB_OTG_HPRT_PCDET) == USB_OTG_HPRT_PCDET)
   \   0000001C   0x9901             LDR      R1,[SP, #+4]
   \   0000001E   0x0789             LSLS     R1,R1,#+30
   \   00000020   0xD50D             BPL.N    ??HCD_Port_IRQHandler_0
   1124            {  
   1125              if((hprt0 & USB_OTG_HPRT_PCSTS) == USB_OTG_HPRT_PCSTS)
   \   00000022   0x9901             LDR      R1,[SP, #+4]
   \   00000024   0x07C9             LSLS     R1,R1,#+31
   \   00000026   0xD506             BPL.N    ??HCD_Port_IRQHandler_1
   1126              {
   1127                USB_MASK_INTERRUPT(hhcd->Instance, USB_OTG_GINTSTS_DISCINT);
   \   00000028   0x6981             LDR      R1,[R0, #+24]
   \   0000002A   0xF021 0x5100      BIC      R1,R1,#0x20000000
   \   0000002E   0x6181             STR      R1,[R0, #+24]
   1128                HAL_HCD_Connect_Callback(hhcd);
   \   00000030   0x4628             MOV      R0,R5
   \   00000032   0x.... 0x....      BL       HAL_HCD_Connect_Callback
   1129              }
   1130              hprt0_dup  |= USB_OTG_HPRT_PCDET;
   \                     ??HCD_Port_IRQHandler_1: (+1)
   \   00000036   0x9800             LDR      R0,[SP, #+0]
   \   00000038   0xF040 0x0002      ORR      R0,R0,#0x2
   \   0000003C   0x9000             STR      R0,[SP, #+0]
   1131              
   1132            }
   1133            
   1134            /* Check whether Port Enable Changed */
   1135            if((hprt0 & USB_OTG_HPRT_PENCHNG) == USB_OTG_HPRT_PENCHNG)
   \                     ??HCD_Port_IRQHandler_0: (+1)
   \   0000003E   0x9801             LDR      R0,[SP, #+4]
   \   00000040   0x0700             LSLS     R0,R0,#+28
   \   00000042   0xD535             BPL.N    ??HCD_Port_IRQHandler_2
   1136            {
   1137              hprt0_dup |= USB_OTG_HPRT_PENCHNG;
   \   00000044   0x9800             LDR      R0,[SP, #+0]
   \   00000046   0xF040 0x0008      ORR      R0,R0,#0x8
   \   0000004A   0x9000             STR      R0,[SP, #+0]
   1138              
   1139              if((hprt0 & USB_OTG_HPRT_PENA) == USB_OTG_HPRT_PENA)
   \   0000004C   0x9801             LDR      R0,[SP, #+4]
   \   0000004E   0x0740             LSLS     R0,R0,#+29
   \   00000050   0xD525             BPL.N    ??HCD_Port_IRQHandler_3
   1140              {    
   1141                if(hhcd->Init.phy_itface  == USB_OTG_EMBEDDED_PHY)
   \   00000052   0x69A8             LDR      R0,[R5, #+24]
   \   00000054   0x2802             CMP      R0,#+2
   \   00000056   0xD10E             BNE.N    ??HCD_Port_IRQHandler_4
   1142                {
   1143                  if ((hprt0 & USB_OTG_HPRT_PSPD) == (HPRT0_PRTSPD_LOW_SPEED << 17))
   \   00000058   0x6828             LDR      R0,[R5, #+0]
   \   0000005A   0x9901             LDR      R1,[SP, #+4]
   \   0000005C   0xF401 0x21C0      AND      R1,R1,#0x60000
   \   00000060   0xF5B1 0x2F80      CMP      R1,#+262144
   \   00000064   0xD103             BNE.N    ??HCD_Port_IRQHandler_5
   1144                  {
   1145                    USB_InitFSLSPClkSel(hhcd->Instance ,HCFG_6_MHZ );
   \   00000066   0x2102             MOVS     R1,#+2
   \   00000068   0x.... 0x....      BL       USB_InitFSLSPClkSel
   \   0000006C   0xE00B             B.N      ??HCD_Port_IRQHandler_6
   1146                  }
   1147                  else
   1148                  {
   1149                    USB_InitFSLSPClkSel(hhcd->Instance ,HCFG_48_MHZ );
   \                     ??HCD_Port_IRQHandler_5: (+1)
   \   0000006E   0x2101             MOVS     R1,#+1
   \   00000070   0x.... 0x....      BL       USB_InitFSLSPClkSel
   \   00000074   0xE007             B.N      ??HCD_Port_IRQHandler_6
   1150                  }
   1151                }
   1152                else
   1153                {
   1154                  if(hhcd->Init.speed == HCD_SPEED_FULL)
   \                     ??HCD_Port_IRQHandler_4: (+1)
   \   00000076   0x68E8             LDR      R0,[R5, #+12]
   \   00000078   0x2803             CMP      R0,#+3
   \   0000007A   0xD104             BNE.N    ??HCD_Port_IRQHandler_6
   1155                  {
   1156                    USBx_HOST->HFIR = (uint32_t)60000;
   \   0000007C   0xF64E 0x2060      MOVW     R0,#+60000
   \   00000080   0xF506 0x6180      ADD      R1,R6,#+1024
   \   00000084   0x6048             STR      R0,[R1, #+4]
   1157                  }
   1158                }
   1159                HAL_HCD_Connect_Callback(hhcd);
   \                     ??HCD_Port_IRQHandler_6: (+1)
   \   00000086   0x4628             MOV      R0,R5
   \   00000088   0x.... 0x....      BL       HAL_HCD_Connect_Callback
   1160                
   1161                if(hhcd->Init.speed == HCD_SPEED_HIGH)
   \   0000008C   0x68E8             LDR      R0,[R5, #+12]
   \   0000008E   0x2800             CMP      R0,#+0
   \   00000090   0xD10E             BNE.N    ??HCD_Port_IRQHandler_2
   1162                {
   1163                  USB_UNMASK_INTERRUPT(hhcd->Instance, USB_OTG_GINTSTS_DISCINT); 
   \   00000092   0x6828             LDR      R0,[R5, #+0]
   \   00000094   0x6981             LDR      R1,[R0, #+24]
   \   00000096   0xF041 0x5100      ORR      R1,R1,#0x20000000
   \   0000009A   0x6181             STR      R1,[R0, #+24]
   \   0000009C   0xE008             B.N      ??HCD_Port_IRQHandler_2
   1164                }
   1165              }
   1166              else
   1167              {
   1168                /* Cleanup HPRT */
   1169                USBx_HPRT0 &= ~(USB_OTG_HPRT_PENA | USB_OTG_HPRT_PCDET |\
   1170                  USB_OTG_HPRT_PENCHNG | USB_OTG_HPRT_POCCHNG );
   \                     ??HCD_Port_IRQHandler_3: (+1)
   \   0000009E   0x6820             LDR      R0,[R4, #+0]
   \   000000A0   0xF020 0x002E      BIC      R0,R0,#0x2E
   \   000000A4   0x6020             STR      R0,[R4, #+0]
   1171                
   1172                USB_UNMASK_INTERRUPT(hhcd->Instance, USB_OTG_GINTSTS_DISCINT); 
   \   000000A6   0x6828             LDR      R0,[R5, #+0]
   \   000000A8   0x6981             LDR      R1,[R0, #+24]
   \   000000AA   0xF041 0x5100      ORR      R1,R1,#0x20000000
   \   000000AE   0x6181             STR      R1,[R0, #+24]
   1173              }    
   1174            }
   1175            
   1176            /* Check For an overcurrent */
   1177            if((hprt0 & USB_OTG_HPRT_POCCHNG) == USB_OTG_HPRT_POCCHNG)
   \                     ??HCD_Port_IRQHandler_2: (+1)
   \   000000B0   0x9801             LDR      R0,[SP, #+4]
   \   000000B2   0x0680             LSLS     R0,R0,#+26
   \   000000B4   0xD503             BPL.N    ??HCD_Port_IRQHandler_7
   1178            {
   1179              hprt0_dup |= USB_OTG_HPRT_POCCHNG;
   \   000000B6   0x9800             LDR      R0,[SP, #+0]
   \   000000B8   0xF040 0x0020      ORR      R0,R0,#0x20
   \   000000BC   0x9000             STR      R0,[SP, #+0]
   1180            }
   1181          
   1182            /* Clear Port Interrupts */
   1183            USBx_HPRT0 = hprt0_dup;
   \                     ??HCD_Port_IRQHandler_7: (+1)
   \   000000BE   0x9800             LDR      R0,[SP, #+0]
   \   000000C0   0x6020             STR      R0,[R4, #+0]
   1184          }
   \   000000C2   0xBD73             POP      {R0,R1,R4-R6,PC}  ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0:
   \   00000000   0x1FF80000         DC32     0x1ff80000
   1185          
   1186          /**
   1187            * @}
   1188            */
   1189          
   1190          #endif /* HAL_HCD_MODULE_ENABLED */
   1191          /**
   1192            * @}
   1193            */
   1194          
   1195          /**
   1196            * @}
   1197            */
   1198          
   1199          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   HAL_HCD_Connect_Callback
       8   HAL_HCD_DeInit
         8   -> HAL_HCD_MspDeInit
         8   -> USB_DisableGlobalInt
       0   HAL_HCD_Disconnect_Callback
       0   HAL_HCD_GetCurrentFrame
         0   -> USB_GetCurrentFrame
       0   HAL_HCD_GetCurrentSpeed
         0   -> USB_GetHostSpeed
       0   HAL_HCD_GetState
       0   HAL_HCD_HC_GetState
       0   HAL_HCD_HC_GetURBState
       0   HAL_HCD_HC_GetXferCount
       8   HAL_HCD_HC_Halt
         8   -> USB_HC_Halt
      32   HAL_HCD_HC_Init
        32   -> USB_HC_Init
       0   HAL_HCD_HC_NotifyURBChange_Callback
      24   HAL_HCD_HC_SubmitRequest
         0   -> USB_HC_StartXfer
      24   HAL_HCD_IRQHandler
        24   -> HAL_HCD_Disconnect_Callback
        24   -> HAL_HCD_SOF_Callback
        24   -> HCD_HC_IN_IRQHandler
        24   -> HCD_HC_OUT_IRQHandler
        24   -> HCD_Port_IRQHandler
        24   -> HCD_RXQLVL_IRQHandler
        24   -> USB_GetMode
        24   -> USB_HC_ReadInterrupt
        24   -> USB_InitFSLSPClkSel
        24   -> USB_ReadInterrupts
      60   HAL_HCD_Init
        48   -> HAL_HCD_MspInit
        48   -> USB_CoreInit
        48   -> USB_DisableGlobalInt
        48   -> USB_HostInit
        48   -> USB_SetCurrentMode
        60   -> __aeabi_memcpy4
       0   HAL_HCD_MspDeInit
       0   HAL_HCD_MspInit
       0   HAL_HCD_ResetPort
         0   -> USB_ResetPort
       0   HAL_HCD_SOF_Callback
       8   HAL_HCD_Start
         8   -> USB_DriveVbus
         8   -> USB_EnableGlobalInt
       8   HAL_HCD_Stop
         8   -> USB_StopHost
      24   HCD_HC_IN_IRQHandler
        24   -> HAL_HCD_HC_NotifyURBChange_Callback
        24   -> USB_HC_Halt
      24   HCD_HC_OUT_IRQHandler
        24   -> HAL_HCD_HC_NotifyURBChange_Callback
        24   -> USB_HC_Halt
      24   HCD_Port_IRQHandler
        24   -> HAL_HCD_Connect_Callback
        24   -> USB_InitFSLSPClkSel
      24   HCD_RXQLVL_IRQHandler
        24   -> USB_ReadPacket


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable0
       2  HAL_HCD_Connect_Callback
      36  HAL_HCD_DeInit
       2  HAL_HCD_Disconnect_Callback
       6  HAL_HCD_GetCurrentFrame
       6  HAL_HCD_GetCurrentSpeed
       6  HAL_HCD_GetState
      14  HAL_HCD_HC_GetState
      14  HAL_HCD_HC_GetURBState
      12  HAL_HCD_HC_GetXferCount
      36  HAL_HCD_HC_Halt
      82  HAL_HCD_HC_Init
       2  HAL_HCD_HC_NotifyURBChange_Callback
     180  HAL_HCD_HC_SubmitRequest
     296  HAL_HCD_IRQHandler
      90  HAL_HCD_Init
       2  HAL_HCD_MspDeInit
       2  HAL_HCD_MspInit
       6  HAL_HCD_ResetPort
       2  HAL_HCD_SOF_Callback
      44  HAL_HCD_Start
      36  HAL_HCD_Stop
     566  HCD_HC_IN_IRQHandler
     538  HCD_HC_OUT_IRQHandler
     196  HCD_Port_IRQHandler
     108  HCD_RXQLVL_IRQHandler

 
 2 288 bytes in section .text
 
 2 288 bytes of CODE memory

Errors: none
Warnings: none
