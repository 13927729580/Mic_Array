###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.2.10312/W32 for ARM       22/Feb/2016  14:50:42
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_tim_ex.c
#    Command line =  
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_tim_ex.c
#        -D USE_HAL_DRIVER -D STM32F746xx -D USE_STM32746G_DISCO -D
#        USE_IOEXPANDER -D USE_USB_FS -lC
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
#        -lA
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
#        -o
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj
#        --no_unroll --debug --endian=little --cpu=Cortex-M7 -e --fpu=VFPv5_sp
#        --dlib_config "D:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Full.h" -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\CMSIS\Device\ST\STM32F7xx\Include\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\STM32F7xx_HAL_Driver\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\STM32746G-Discovery\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\Components\Common\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Log\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Fonts\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\CPU\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_Device_Library\Core\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Core\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Class\MSC\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\drivers\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_Audio\Addons\PDM\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_Device_Library\Class\AUDIO\Inc\
#        -Ohs --use_c++_inline --require_prototypes -I "D:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.3\arm\CMSIS\Include\" -D
#        ARM_MATH_CM7
#    List file    =  
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List\stm32f7xx_hal_tim_ex.lst
#    Object file  =  
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj\stm32f7xx_hal_tim_ex.o
#
###############################################################################

D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_tim_ex.c
      1          /**
                   ^
Warning[Pa050]: non-native end of line sequence detected (this diagnostic is
          only issued once)
      2            ******************************************************************************
      3            * @file    stm32f7xx_hal_tim_ex.c
      4            * @author  MCD Application Team
      5            * @version V1.0.1
      6            * @date    25-June-2015
      7            * @brief   TIM HAL module driver.
      8            *          This file provides firmware functions to manage the following 
      9            *          functionalities of the Timer extension peripheral:
     10            *           + Time Hall Sensor Interface Initialization
     11            *           + Time Hall Sensor Interface Start
     12            *           + Time Complementary signal bread and dead time configuration  
     13            *           + Time Master and Slave synchronization configuration
     14            *           + Time Output Compare/PWM Channel Configuration (for channels 5 and 6)
     15            *           + Time OCRef clear configuration
     16            *           + Timer remapping capabilities configuration  
     17            @verbatim 
     18            ==============================================================================
     19                                ##### TIMER Extended features #####
     20            ==============================================================================
     21            [..] 
     22              The Timer Extension features include: 
     23              (#) Complementary outputs with programmable dead-time for :
     24                  (++) Input Capture
     25                  (++) Output Compare
     26                  (++) PWM generation (Edge and Center-aligned Mode)
     27                  (++) One-pulse mode output
     28              (#) Synchronization circuit to control the timer with external signals and to 
     29                  interconnect several timers together.
     30              (#) Break input to put the timer output signals in reset state or in a known state.
     31              (#) Supports incremental (quadrature) encoder and hall-sensor circuitry for 
     32                  positioning purposes                
     33             
     34                                  ##### How to use this driver #####
     35            ==============================================================================
     36            [..]
     37               (#) Initialize the TIM low level resources by implementing the following functions 
     38                   depending from feature used :
     39                     (++) Complementary Output Compare : HAL_TIM_OC_MspInit()
     40                     (++) Complementary PWM generation : HAL_TIM_PWM_MspInit()
     41                     (++) Complementary One-pulse mode output : HAL_TIM_OnePulse_MspInit()
     42                     (++) Hall Sensor output : HAL_TIM_HallSensor_MspInit()
     43                     
     44               (#) Initialize the TIM low level resources :
     45                  (##) Enable the TIM interface clock using __TIMx_CLK_ENABLE(); 
     46                  (##) TIM pins configuration
     47                      (+++) Enable the clock for the TIM GPIOs using the following function:
     48                           __GPIOx_CLK_ENABLE();   
     49                      (+++) Configure these TIM pins in Alternate function mode using HAL_GPIO_Init();  
     50          
     51               (#) The external Clock can be configured, if needed (the default clock is the 
     52                   internal clock from the APBx), using the following function:
     53                   HAL_TIM_ConfigClockSource, the clock configuration should be done before 
     54                   any start function.
     55            
     56              (#) Configure the TIM in the desired functioning mode using one of the 
     57                  initialization function of this driver:
     58                  (++) HAL_TIMEx_HallSensor_Init and HAL_TIMEx_ConfigCommutationEvent: to use the 
     59                       Timer Hall Sensor Interface and the commutation event with the corresponding 
     60                       Interrupt and DMA request if needed (Note that One Timer is used to interface 
     61                       with the Hall sensor Interface and another Timer should be used to use 
     62                       the commutation event).
     63          
     64              (#) Activate the TIM peripheral using one of the start functions: 
     65                     (++) Complementary Output Compare : HAL_TIMEx_OCN_Start(), HAL_TIMEx_OCN_Start_DMA(), HAL_TIMEx_OC_Start_IT()
     66                     (++) Complementary PWM generation : HAL_TIMEx_PWMN_Start(), HAL_TIMEx_PWMN_Start_DMA(), HAL_TIMEx_PWMN_Start_IT()
     67                     (++) Complementary One-pulse mode output : HAL_TIMEx_OnePulseN_Start(), HAL_TIMEx_OnePulseN_Start_IT()
     68                     (++) Hall Sensor output : HAL_TIMEx_HallSensor_Start(), HAL_TIMEx_HallSensor_Start_DMA(), HAL_TIMEx_HallSensor_Start_IT().
     69          
     70            
     71            @endverbatim
     72            ******************************************************************************
     73            * @attention
     74            *
     75            * <h2><center>&copy; COPYRIGHT(c) 2015 STMicroelectronics</center></h2>
     76            *
     77            * Redistribution and use in source and binary forms, with or without modification,
     78            * are permitted provided that the following conditions are met:
     79            *   1. Redistributions of source code must retain the above copyright notice,
     80            *      this list of conditions and the following disclaimer.
     81            *   2. Redistributions in binary form must reproduce the above copyright notice,
     82            *      this list of conditions and the following disclaimer in the documentation
     83            *      and/or other materials provided with the distribution.
     84            *   3. Neither the name of STMicroelectronics nor the names of its contributors
     85            *      may be used to endorse or promote products derived from this software
     86            *      without specific prior written permission.
     87            *
     88            * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
     89            * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     90            * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     91            * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
     92            * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
     93            * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
     94            * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
     95            * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
     96            * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
     97            * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     98            *
     99            ******************************************************************************
    100            */ 
    101          
    102          /* Includes ------------------------------------------------------------------*/
    103          #include "stm32f7xx_hal.h"
    104          
    105          /** @addtogroup STM32F7xx_HAL_Driver
    106            * @{
    107            */
    108          
    109          /** @defgroup TIMEx TIMEx
    110            * @brief TIM Extended HAL module driver
    111            * @{
    112            */
    113          
    114          #ifdef HAL_TIM_MODULE_ENABLED
    115          
    116          /* Private typedef -----------------------------------------------------------*/
    117          /* Private define ------------------------------------------------------------*/
    118          #define BDTR_BKF_SHIFT  (16)
    119          #define BDTR_BK2F_SHIFT (20)
    120          /* Private macro -------------------------------------------------------------*/
    121          /* Private variables ---------------------------------------------------------*/
    122          /* Private function prototypes -----------------------------------------------*/
    123          /** @addtogroup TIMEx_Private_Functions
    124            * @{
    125            */
    126          static void TIM_CCxNChannelCmd(TIM_TypeDef* TIMx, uint32_t Channel, uint32_t ChannelNState);  
    127          static void TIM_OC5_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config);
    128          static void TIM_OC6_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config);
    129          /**
    130            * @}
    131            */
    132          /* Private functions ---------------------------------------------------------*/
    133          
    134          /** @defgroup TIMEx_Exported_Functions TIMEx Exported Functions
    135            * @{
    136            */
    137          
    138          /** @defgroup TIMEx_Exported_Functions_Group1 Extended Timer Hall Sensor functions
    139           *  @brief    Timer Hall Sensor functions 
    140           *
    141          @verbatim    
    142            ==============================================================================
    143                                ##### Timer Hall Sensor functions #####
    144            ==============================================================================
    145            [..]  
    146              This section provides functions allowing to:
    147              (+) Initialize and configure TIM HAL Sensor. 
    148              (+) De-initialize TIM HAL Sensor.
    149              (+) Start the Hall Sensor Interface.
    150              (+) Stop the Hall Sensor Interface.
    151              (+) Start the Hall Sensor Interface and enable interrupts.
    152              (+) Stop the Hall Sensor Interface and disable interrupts.
    153              (+) Start the Hall Sensor Interface and enable DMA transfers.
    154              (+) Stop the Hall Sensor Interface and disable DMA transfers.
    155           
    156          @endverbatim
    157            * @{
    158            */
    159          /**
    160            * @brief  Initializes the TIM Hall Sensor Interface and create the associated handle.
    161            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
    162            *                the configuration information for TIM module.
    163            * @param  sConfig: TIM Hall Sensor configuration structure
    164            * @retval HAL status
    165            */

   \                                 In section .text, align 2, keep-with-next
    166          HAL_StatusTypeDef HAL_TIMEx_HallSensor_Init(TIM_HandleTypeDef *htim, TIM_HallSensor_InitTypeDef* sConfig)
    167          {
   \                     HAL_TIMEx_HallSensor_Init: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0xB087             SUB      SP,SP,#+28
   \   00000006   0x460D             MOV      R5,R1
    168            TIM_OC_InitTypeDef OC_Config;
    169              
    170            /* Check the TIM handle allocation */
    171            if(htim == NULL)
   \   00000008   0xBF08             IT       EQ 
   \   0000000A   0x2001             MOVEQ    R0,#+1
    172            {
    173              return HAL_ERROR;
   \   0000000C   0xD050             BEQ.N    ??HAL_TIMEx_HallSensor_Init_0
    174            }
    175            
    176            assert_param(IS_TIM_XOR_INSTANCE(htim->Instance));
    177            assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
    178            assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
    179            assert_param(IS_TIM_IC_POLARITY(sConfig->IC1Polarity));
    180            assert_param(IS_TIM_IC_PRESCALER(sConfig->IC1Prescaler));
    181            assert_param(IS_TIM_IC_FILTER(sConfig->IC1Filter));
    182          
    183            /* Set the TIM state */
    184            htim->State= HAL_TIM_STATE_BUSY;
   \   0000000E   0x2002             MOVS     R0,#+2
   \   00000010   0xF884 0x0039      STRB     R0,[R4, #+57]
    185            
    186            /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
    187            HAL_TIMEx_HallSensor_MspInit(htim);
   \   00000014   0x4620             MOV      R0,R4
   \   00000016   0x.... 0x....      BL       HAL_TIMEx_HallSensor_MspInit
    188            
    189            /* Configure the Time base in the Encoder Mode */
    190            TIM_Base_SetConfig(htim->Instance, &htim->Init);
   \   0000001A   0x6820             LDR      R0,[R4, #+0]
   \   0000001C   0x1D21             ADDS     R1,R4,#+4
   \   0000001E   0x.... 0x....      BL       TIM_Base_SetConfig
    191            
    192            /* Configure the Channel 1 as Input Channel to interface with the three Outputs of the  Hall sensor */
    193            TIM_TI1_SetConfig(htim->Instance, sConfig->IC1Polarity, TIM_ICSELECTION_TRC, sConfig->IC1Filter);
   \   00000022   0x68AB             LDR      R3,[R5, #+8]
   \   00000024   0x6829             LDR      R1,[R5, #+0]
   \   00000026   0x6820             LDR      R0,[R4, #+0]
   \   00000028   0x2203             MOVS     R2,#+3
   \   0000002A   0x.... 0x....      BL       TIM_TI1_SetConfig
    194            
    195            /* Reset the IC1PSC Bits */
    196            htim->Instance->CCMR1 &= ~TIM_CCMR1_IC1PSC;
   \   0000002E   0x6820             LDR      R0,[R4, #+0]
   \   00000030   0x6981             LDR      R1,[R0, #+24]
   \   00000032   0xF021 0x010C      BIC      R1,R1,#0xC
   \   00000036   0x6181             STR      R1,[R0, #+24]
    197            /* Set the IC1PSC value */
    198            htim->Instance->CCMR1 |= sConfig->IC1Prescaler;
   \   00000038   0x6820             LDR      R0,[R4, #+0]
   \   0000003A   0x6981             LDR      R1,[R0, #+24]
   \   0000003C   0x686A             LDR      R2,[R5, #+4]
   \   0000003E   0x4311             ORRS     R1,R2,R1
    199            
    200            /* Enable the Hall sensor interface (XOR function of the three inputs) */
    201            htim->Instance->CR2 |= TIM_CR2_TI1S;
    202            
    203            /* Select the TIM_TS_TI1F_ED signal as Input trigger for the TIM */
    204            htim->Instance->SMCR &= ~TIM_SMCR_TS;
    205            htim->Instance->SMCR |= TIM_TS_TI1F_ED;
    206            
    207            /* Use the TIM_TS_TI1F_ED signal to reset the TIM counter each edge detection */  
    208            htim->Instance->SMCR &= ~TIM_SMCR_SMS;
   \   00000040   0x.... 0x....      LDR.W    R2,??DataTable5  ;; 0xfffefff8
   \   00000044   0x6181             STR      R1,[R0, #+24]
   \   00000046   0x6820             LDR      R0,[R4, #+0]
   \   00000048   0x6841             LDR      R1,[R0, #+4]
   \   0000004A   0xF041 0x0180      ORR      R1,R1,#0x80
   \   0000004E   0x6041             STR      R1,[R0, #+4]
   \   00000050   0x6820             LDR      R0,[R4, #+0]
   \   00000052   0x6881             LDR      R1,[R0, #+8]
   \   00000054   0xF021 0x0170      BIC      R1,R1,#0x70
   \   00000058   0x6081             STR      R1,[R0, #+8]
   \   0000005A   0x6820             LDR      R0,[R4, #+0]
   \   0000005C   0x6881             LDR      R1,[R0, #+8]
   \   0000005E   0xF041 0x0140      ORR      R1,R1,#0x40
   \   00000062   0x6081             STR      R1,[R0, #+8]
   \   00000064   0x6820             LDR      R0,[R4, #+0]
   \   00000066   0x6881             LDR      R1,[R0, #+8]
   \   00000068   0x4011             ANDS     R1,R2,R1
   \   0000006A   0x6081             STR      R1,[R0, #+8]
    209            htim->Instance->SMCR |= TIM_SLAVEMODE_RESET;
   \   0000006C   0x6820             LDR      R0,[R4, #+0]
   \   0000006E   0x6881             LDR      R1,[R0, #+8]
   \   00000070   0xF041 0x0104      ORR      R1,R1,#0x4
   \   00000074   0x6081             STR      R1,[R0, #+8]
    210            
    211            /* Program channel 2 in PWM 2 mode with the desired Commutation_Delay*/
    212            OC_Config.OCFastMode = TIM_OCFAST_DISABLE;
   \   00000076   0x2000             MOVS     R0,#+0
   \   00000078   0x9004             STR      R0,[SP, #+16]
    213            OC_Config.OCIdleState = TIM_OCIDLESTATE_RESET;
    214            OC_Config.OCMode = TIM_OCMODE_PWM2;
    215            OC_Config.OCNIdleState = TIM_OCNIDLESTATE_RESET;
    216            OC_Config.OCNPolarity = TIM_OCNPOLARITY_HIGH;
    217            OC_Config.OCPolarity = TIM_OCPOLARITY_HIGH;
    218            OC_Config.Pulse = sConfig->Commutation_Delay; 
    219              
    220            TIM_OC2_SetConfig(htim->Instance, &OC_Config);
   \   0000007A   0x4669             MOV      R1,SP
   \   0000007C   0x9005             STR      R0,[SP, #+20]
   \   0000007E   0x2070             MOVS     R0,#+112
   \   00000080   0x9000             STR      R0,[SP, #+0]
   \   00000082   0x2000             MOVS     R0,#+0
   \   00000084   0x9006             STR      R0,[SP, #+24]
   \   00000086   0x9003             STR      R0,[SP, #+12]
   \   00000088   0x9002             STR      R0,[SP, #+8]
   \   0000008A   0x68E8             LDR      R0,[R5, #+12]
   \   0000008C   0x9001             STR      R0,[SP, #+4]
   \   0000008E   0x6820             LDR      R0,[R4, #+0]
   \   00000090   0x.... 0x....      BL       TIM_OC2_SetConfig
    221            
    222            /* Select OC2REF as trigger output on TRGO: write the MMS bits in the TIMx_CR2
    223              register to 101 */
    224            htim->Instance->CR2 &= ~TIM_CR2_MMS;
   \   00000094   0x6820             LDR      R0,[R4, #+0]
   \   00000096   0x6841             LDR      R1,[R0, #+4]
   \   00000098   0xF021 0x0170      BIC      R1,R1,#0x70
   \   0000009C   0x6041             STR      R1,[R0, #+4]
    225            htim->Instance->CR2 |= TIM_TRGO_OC2REF; 
   \   0000009E   0x6820             LDR      R0,[R4, #+0]
   \   000000A0   0x6841             LDR      R1,[R0, #+4]
   \   000000A2   0xF041 0x0150      ORR      R1,R1,#0x50
   \   000000A6   0x6041             STR      R1,[R0, #+4]
    226            
    227            /* Initialize the TIM state*/
    228            htim->State= HAL_TIM_STATE_READY;
   \   000000A8   0x2001             MOVS     R0,#+1
   \   000000AA   0xF884 0x0039      STRB     R0,[R4, #+57]
    229          
    230            return HAL_OK;
   \   000000AE   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIMEx_HallSensor_Init_0: (+1)
   \   000000B0   0xB007             ADD      SP,SP,#+28
   \   000000B2   0xBD30             POP      {R4,R5,PC}       ;; return
    231          }
    232          
    233          /**
    234            * @brief  DeInitializes the TIM Hall Sensor interface  
    235            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
    236            *                the configuration information for TIM module.
    237            * @retval HAL status
    238            */

   \                                 In section .text, align 2, keep-with-next
    239          HAL_StatusTypeDef HAL_TIMEx_HallSensor_DeInit(TIM_HandleTypeDef *htim)
    240          {
   \                     HAL_TIMEx_HallSensor_DeInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    241            /* Check the parameters */
    242            assert_param(IS_TIM_INSTANCE(htim->Instance));
    243          
    244            htim->State = HAL_TIM_STATE_BUSY;
   \   00000004   0x2002             MOVS     R0,#+2
   \   00000006   0xF884 0x0039      STRB     R0,[R4, #+57]
    245            
    246            /* Disable the TIM Peripheral Clock */
    247            __HAL_TIM_DISABLE(htim);
   \   0000000A   0xF241 0x1211      MOVW     R2,#+4369
   \   0000000E   0x6820             LDR      R0,[R4, #+0]
   \   00000010   0x6A01             LDR      R1,[R0, #+32]
   \   00000012   0x4211             TST      R1,R2
   \   00000014   0xBF02             ITTT     EQ 
   \   00000016   0x6A01             LDREQ    R1,[R0, #+32]
   \   00000018   0xF240 0x4244      MOVWEQ   R2,#+1092
   \   0000001C   0x4211             TSTEQ    R1,R2
   \   0000001E   0xD103             BNE.N    ??HAL_TIMEx_HallSensor_DeInit_0
   \   00000020   0x6801             LDR      R1,[R0, #+0]
   \   00000022   0x0849             LSRS     R1,R1,#+1
   \   00000024   0x0049             LSLS     R1,R1,#+1
   \   00000026   0x6001             STR      R1,[R0, #+0]
    248              
    249            /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
    250            HAL_TIMEx_HallSensor_MspDeInit(htim);
   \                     ??HAL_TIMEx_HallSensor_DeInit_0: (+1)
   \   00000028   0x4620             MOV      R0,R4
   \   0000002A   0x.... 0x....      BL       HAL_TIMEx_HallSensor_MspDeInit
    251              
    252            /* Change TIM state */  
    253            htim->State = HAL_TIM_STATE_RESET; 
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0xF884 0x0039      STRB     R0,[R4, #+57]
    254          
    255            /* Release Lock */
    256            __HAL_UNLOCK(htim);
   \   00000034   0xF884 0x0038      STRB     R0,[R4, #+56]
    257          
    258            return HAL_OK;
   \   00000038   0xBD10             POP      {R4,PC}          ;; return
    259          }
    260          
    261          /**
    262            * @brief  Initializes the TIM Hall Sensor MSP.
    263            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
    264            *                the configuration information for TIM module.
    265            * @retval None
    266            */

   \                                 In section .text, align 2, keep-with-next
    267          __weak void HAL_TIMEx_HallSensor_MspInit(TIM_HandleTypeDef *htim)
    268          {
    269            /* NOTE : This function Should not be modified, when the callback is needed,
    270                      the HAL_TIMEx_HallSensor_MspInit could be implemented in the user file
    271             */
    272          }
   \                     HAL_TIMEx_HallSensor_MspInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    273          
    274          /**
    275            * @brief  DeInitializes TIM Hall Sensor MSP.
    276            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
    277            *                the configuration information for TIM module.
    278            * @retval None
    279            */

   \                                 In section .text, align 2, keep-with-next
    280          __weak void HAL_TIMEx_HallSensor_MspDeInit(TIM_HandleTypeDef *htim)
    281          {
    282            /* NOTE : This function Should not be modified, when the callback is needed,
    283                      the HAL_TIMEx_HallSensor_MspDeInit could be implemented in the user file
    284             */
    285          }
   \                     HAL_TIMEx_HallSensor_MspDeInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    286          
    287          /**
    288            * @brief  Starts the TIM Hall Sensor Interface.
    289            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
    290            *                the configuration information for TIM module.
    291            * @retval HAL status
    292            */

   \                                 In section .text, align 2, keep-with-next
    293          HAL_StatusTypeDef HAL_TIMEx_HallSensor_Start(TIM_HandleTypeDef *htim)
    294          {
   \                     HAL_TIMEx_HallSensor_Start: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    295            /* Check the parameters */
    296            assert_param(IS_TIM_XOR_INSTANCE(htim->Instance));
    297            
    298            /* Enable the Input Capture channels 1
    299              (in the Hall Sensor Interface the Three possible channels that can be used are TIM_CHANNEL_1, TIM_CHANNEL_2 and TIM_CHANNEL_3) */  
    300            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE); 
   \   00000004   0x2201             MOVS     R2,#+1
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x6820             LDR      R0,[R4, #+0]
   \   0000000A   0x.... 0x....      BL       TIM_CCxChannelCmd
    301            
    302            /* Enable the Peripheral */
    303            __HAL_TIM_ENABLE(htim);
   \   0000000E   0x6820             LDR      R0,[R4, #+0]
   \   00000010   0x6801             LDR      R1,[R0, #+0]
   \   00000012   0xF041 0x0101      ORR      R1,R1,#0x1
   \   00000016   0x6001             STR      R1,[R0, #+0]
    304            
    305            /* Return function status */
    306            return HAL_OK;
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0xBD10             POP      {R4,PC}          ;; return
    307          }
    308          
    309          /**
    310            * @brief  Stops the TIM Hall sensor Interface.
    311            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
    312            *                the configuration information for TIM module.
    313            * @retval HAL status
    314            */

   \                                 In section .text, align 2, keep-with-next
    315          HAL_StatusTypeDef HAL_TIMEx_HallSensor_Stop(TIM_HandleTypeDef *htim)
    316          {
   \                     HAL_TIMEx_HallSensor_Stop: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    317            /* Check the parameters */
    318            assert_param(IS_TIM_XOR_INSTANCE(htim->Instance));
    319            
    320            /* Disable the Input Capture channels 1, 2 and 3
    321              (in the Hall Sensor Interface the Three possible channels that can be used are TIM_CHANNEL_1, TIM_CHANNEL_2 and TIM_CHANNEL_3) */  
    322            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE); 
   \   00000004   0x2200             MOVS     R2,#+0
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x6820             LDR      R0,[R4, #+0]
   \   0000000A   0x.... 0x....      BL       TIM_CCxChannelCmd
    323          
    324            /* Disable the Peripheral */
    325            __HAL_TIM_DISABLE(htim);
   \   0000000E   0x6820             LDR      R0,[R4, #+0]
   \   00000010   0xF241 0x1211      MOVW     R2,#+4369
   \   00000014   0x6A01             LDR      R1,[R0, #+32]
   \   00000016   0x4211             TST      R1,R2
   \   00000018   0xBF02             ITTT     EQ 
   \   0000001A   0x6A01             LDREQ    R1,[R0, #+32]
   \   0000001C   0xF240 0x4244      MOVWEQ   R2,#+1092
   \   00000020   0x4211             TSTEQ    R1,R2
   \   00000022   0xD103             BNE.N    ??HAL_TIMEx_HallSensor_Stop_0
   \   00000024   0x6801             LDR      R1,[R0, #+0]
   \   00000026   0x0849             LSRS     R1,R1,#+1
   \   00000028   0x0049             LSLS     R1,R1,#+1
   \   0000002A   0x6001             STR      R1,[R0, #+0]
    326            
    327            /* Return function status */
    328            return HAL_OK;
   \                     ??HAL_TIMEx_HallSensor_Stop_0: (+1)
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0xBD10             POP      {R4,PC}          ;; return
    329          }
    330          
    331          /**
    332            * @brief  Starts the TIM Hall Sensor Interface in interrupt mode.
    333            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
    334            *                the configuration information for TIM module.
    335            * @retval HAL status
    336            */

   \                                 In section .text, align 2, keep-with-next
    337          HAL_StatusTypeDef HAL_TIMEx_HallSensor_Start_IT(TIM_HandleTypeDef *htim)
    338          { 
   \                     HAL_TIMEx_HallSensor_Start_IT: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    339            /* Check the parameters */
    340            assert_param(IS_TIM_XOR_INSTANCE(htim->Instance));
    341            
    342            /* Enable the capture compare Interrupts 1 event */
    343            __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
    344            
    345            /* Enable the Input Capture channels 1
    346              (in the Hall Sensor Interface the Three possible channels that can be used are TIM_CHANNEL_1, TIM_CHANNEL_2 and TIM_CHANNEL_3) */  
    347            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);  
   \   00000004   0x2201             MOVS     R2,#+1
   \   00000006   0x6820             LDR      R0,[R4, #+0]
   \   00000008   0x68C1             LDR      R1,[R0, #+12]
   \   0000000A   0xF041 0x0102      ORR      R1,R1,#0x2
   \   0000000E   0x60C1             STR      R1,[R0, #+12]
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0x.... 0x....      BL       TIM_CCxChannelCmd
    348            
    349            /* Enable the Peripheral */
    350            __HAL_TIM_ENABLE(htim);
   \   00000016   0x6820             LDR      R0,[R4, #+0]
   \   00000018   0x6801             LDR      R1,[R0, #+0]
   \   0000001A   0xF041 0x0101      ORR      R1,R1,#0x1
   \   0000001E   0x6001             STR      R1,[R0, #+0]
    351            
    352            /* Return function status */
    353            return HAL_OK;
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0xBD10             POP      {R4,PC}          ;; return
    354          }
    355          
    356          /**
    357            * @brief  Stops the TIM Hall Sensor Interface in interrupt mode.
    358            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
    359            *                the configuration information for TIM module.
    360            * @retval HAL status
    361            */

   \                                 In section .text, align 2, keep-with-next
    362          HAL_StatusTypeDef HAL_TIMEx_HallSensor_Stop_IT(TIM_HandleTypeDef *htim)
    363          {
   \                     HAL_TIMEx_HallSensor_Stop_IT: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    364            /* Check the parameters */
    365            assert_param(IS_TIM_XOR_INSTANCE(htim->Instance));
    366            
    367            /* Disable the Input Capture channels 1
    368              (in the Hall Sensor Interface the Three possible channels that can be used are TIM_CHANNEL_1, TIM_CHANNEL_2 and TIM_CHANNEL_3) */  
    369            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE); 
   \   00000004   0x2200             MOVS     R2,#+0
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x6820             LDR      R0,[R4, #+0]
   \   0000000A   0x.... 0x....      BL       TIM_CCxChannelCmd
    370            
    371            /* Disable the capture compare Interrupts event */
    372            __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
   \   0000000E   0x6820             LDR      R0,[R4, #+0]
    373            
    374            /* Disable the Peripheral */
    375            __HAL_TIM_DISABLE(htim);
   \   00000010   0xF241 0x1211      MOVW     R2,#+4369
   \   00000014   0x68C1             LDR      R1,[R0, #+12]
   \   00000016   0xF021 0x0102      BIC      R1,R1,#0x2
   \   0000001A   0x60C1             STR      R1,[R0, #+12]
   \   0000001C   0x6A01             LDR      R1,[R0, #+32]
   \   0000001E   0x4211             TST      R1,R2
   \   00000020   0xBF02             ITTT     EQ 
   \   00000022   0x6A01             LDREQ    R1,[R0, #+32]
   \   00000024   0xF240 0x4244      MOVWEQ   R2,#+1092
   \   00000028   0x4211             TSTEQ    R1,R2
   \   0000002A   0xD103             BNE.N    ??HAL_TIMEx_HallSensor_Stop_IT_0
   \   0000002C   0x6801             LDR      R1,[R0, #+0]
   \   0000002E   0x0849             LSRS     R1,R1,#+1
   \   00000030   0x0049             LSLS     R1,R1,#+1
   \   00000032   0x6001             STR      R1,[R0, #+0]
    376            
    377            /* Return function status */
    378            return HAL_OK;
   \                     ??HAL_TIMEx_HallSensor_Stop_IT_0: (+1)
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0xBD10             POP      {R4,PC}          ;; return
    379          }
    380          
    381          /**
    382            * @brief  Starts the TIM Hall Sensor Interface in DMA mode.
    383            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
    384            *                the configuration information for TIM module.
    385            * @param  pData: The destination Buffer address.
    386            * @param  Length: The length of data to be transferred from TIM peripheral to memory.
    387            * @retval HAL status
    388            */

   \                                 In section .text, align 2, keep-with-next
    389          HAL_StatusTypeDef HAL_TIMEx_HallSensor_Start_DMA(TIM_HandleTypeDef *htim, uint32_t *pData, uint16_t Length)
    390          {
   \                     HAL_TIMEx_HallSensor_Start_DMA: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460E             MOV      R6,R1
   \   00000006   0x4615             MOV      R5,R2
    391            /* Check the parameters */
    392            assert_param(IS_TIM_XOR_INSTANCE(htim->Instance));
    393            
    394             if((htim->State == HAL_TIM_STATE_BUSY))
   \   00000008   0xF894 0x0039      LDRB     R0,[R4, #+57]
   \   0000000C   0x2802             CMP      R0,#+2
   \   0000000E   0xD028             BEQ.N    ??HAL_TIMEx_HallSensor_Start_DMA_0
    395            {
    396               return HAL_BUSY;
    397            }
    398            else if((htim->State == HAL_TIM_STATE_READY))
   \   00000010   0xF894 0x0039      LDRB     R0,[R4, #+57]
   \   00000014   0x2801             CMP      R0,#+1
   \   00000016   0xD104             BNE.N    ??HAL_TIMEx_HallSensor_Start_DMA_1
    399            {
    400              if(((uint32_t)pData == 0 ) && (Length > 0)) 
   \   00000018   0xB906             CBNZ.N   R6,??HAL_TIMEx_HallSensor_Start_DMA_2
   \   0000001A   0xBB15             CBNZ.N   R5,??HAL_TIMEx_HallSensor_Start_DMA_0
    401              {
    402                return HAL_ERROR;                                    
    403              }
    404              else
    405              {
    406                htim->State = HAL_TIM_STATE_BUSY;
   \                     ??HAL_TIMEx_HallSensor_Start_DMA_2: (+1)
   \   0000001C   0x2002             MOVS     R0,#+2
   \   0000001E   0xF884 0x0039      STRB     R0,[R4, #+57]
    407              }
    408            }
    409            /* Enable the Input Capture channels 1
    410              (in the Hall Sensor Interface the Three possible channels that can be used are TIM_CHANNEL_1, TIM_CHANNEL_2 and TIM_CHANNEL_3) */  
    411            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE); 
   \                     ??HAL_TIMEx_HallSensor_Start_DMA_1: (+1)
   \   00000022   0x6820             LDR      R0,[R4, #+0]
   \   00000024   0x2201             MOVS     R2,#+1
   \   00000026   0x2100             MOVS     R1,#+0
   \   00000028   0x.... 0x....      BL       TIM_CCxChannelCmd
    412            
    413            /* Set the DMA Input Capture 1 Callback */
    414            htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = HAL_TIM_DMACaptureCplt;     
   \   0000002C   0x6A21             LDR      R1,[R4, #+32]
   \   0000002E   0x.... 0x....      LDR.W    R0,??DataTable7
    415            /* Set the DMA error callback */
    416            htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = HAL_TIM_DMAError ;
    417            
    418            /* Enable the DMA Stream for Capture 1*/
    419            HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->CCR1, (uint32_t)pData, Length);    
   \   00000032   0x462B             MOV      R3,R5
   \   00000034   0x4632             MOV      R2,R6
   \   00000036   0x63C8             STR      R0,[R1, #+60]
   \   00000038   0x6A21             LDR      R1,[R4, #+32]
   \   0000003A   0x.... 0x....      LDR.W    R0,??DataTable7_1
   \   0000003E   0x6488             STR      R0,[R1, #+72]
   \   00000040   0x6820             LDR      R0,[R4, #+0]
   \   00000042   0xF100 0x0134      ADD      R1,R0,#+52
   \   00000046   0x6A20             LDR      R0,[R4, #+32]
   \   00000048   0x.... 0x....      BL       HAL_DMA_Start_IT
    420            
    421            /* Enable the capture compare 1 Interrupt */
    422            __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
   \   0000004C   0x6820             LDR      R0,[R4, #+0]
   \   0000004E   0x68C1             LDR      R1,[R0, #+12]
   \   00000050   0xF441 0x7100      ORR      R1,R1,#0x200
   \   00000054   0x60C1             STR      R1,[R0, #+12]
    423           
    424            /* Enable the Peripheral */
    425            __HAL_TIM_ENABLE(htim);
   \   00000056   0x6820             LDR      R0,[R4, #+0]
   \   00000058   0x6801             LDR      R1,[R0, #+0]
   \   0000005A   0xF041 0x0101      ORR      R1,R1,#0x1
   \   0000005E   0x6001             STR      R1,[R0, #+0]
    426            
    427            /* Return function status */
    428            return HAL_OK;
   \   00000060   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIMEx_HallSensor_Start_DMA_0: (+1)
   \   00000062   0xBD70             POP      {R4-R6,PC}       ;; return
    429          }
    430          
    431          /**
    432            * @brief  Stops the TIM Hall Sensor Interface in DMA mode.
    433            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
    434            *                the configuration information for TIM module.
    435            * @retval HAL status
    436            */

   \                                 In section .text, align 2, keep-with-next
    437          HAL_StatusTypeDef HAL_TIMEx_HallSensor_Stop_DMA(TIM_HandleTypeDef *htim)
    438          {
   \                     HAL_TIMEx_HallSensor_Stop_DMA: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    439            /* Check the parameters */
    440            assert_param(IS_TIM_XOR_INSTANCE(htim->Instance));
    441            
    442            /* Disable the Input Capture channels 1
    443              (in the Hall Sensor Interface the Three possible channels that can be used are TIM_CHANNEL_1, TIM_CHANNEL_2 and TIM_CHANNEL_3) */  
    444            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE); 
   \   00000004   0x2200             MOVS     R2,#+0
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x6820             LDR      R0,[R4, #+0]
   \   0000000A   0x.... 0x....      BL       TIM_CCxChannelCmd
    445           
    446            
    447            /* Disable the capture compare Interrupts 1 event */
    448            __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
   \   0000000E   0x6820             LDR      R0,[R4, #+0]
    449           
    450            /* Disable the Peripheral */
    451            __HAL_TIM_DISABLE(htim);
   \   00000010   0xF241 0x1211      MOVW     R2,#+4369
   \   00000014   0x68C1             LDR      R1,[R0, #+12]
   \   00000016   0xF421 0x7100      BIC      R1,R1,#0x200
   \   0000001A   0x60C1             STR      R1,[R0, #+12]
   \   0000001C   0x6A01             LDR      R1,[R0, #+32]
   \   0000001E   0x4211             TST      R1,R2
   \   00000020   0xBF02             ITTT     EQ 
   \   00000022   0x6A01             LDREQ    R1,[R0, #+32]
   \   00000024   0xF240 0x4244      MOVWEQ   R2,#+1092
   \   00000028   0x4211             TSTEQ    R1,R2
   \   0000002A   0xD103             BNE.N    ??HAL_TIMEx_HallSensor_Stop_DMA_0
   \   0000002C   0x6801             LDR      R1,[R0, #+0]
   \   0000002E   0x0849             LSRS     R1,R1,#+1
   \   00000030   0x0049             LSLS     R1,R1,#+1
   \   00000032   0x6001             STR      R1,[R0, #+0]
    452            
    453            /* Return function status */
    454            return HAL_OK;
   \                     ??HAL_TIMEx_HallSensor_Stop_DMA_0: (+1)
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0xBD10             POP      {R4,PC}          ;; return
    455          }
    456          
    457          /**
    458            * @}
    459            */
    460            
    461          /** @defgroup TIMEx_Exported_Functions_Group2 Extended Timer Complementary Output Compare functions
    462           *  @brief    Timer Complementary Output Compare functions 
    463           *
    464          @verbatim   
    465            ==============================================================================
    466                        ##### Timer Complementary Output Compare functions #####
    467            ==============================================================================  
    468            [..]  
    469              This section provides functions allowing to:
    470              (+) Start the Complementary Output Compare/PWM.
    471              (+) Stop the Complementary Output Compare/PWM.
    472              (+) Start the Complementary Output Compare/PWM and enable interrupts.
    473              (+) Stop the Complementary Output Compare/PWM and disable interrupts.
    474              (+) Start the Complementary Output Compare/PWM and enable DMA transfers.
    475              (+) Stop the Complementary Output Compare/PWM and disable DMA transfers.
    476                         
    477          @endverbatim
    478            * @{
    479            */
    480            
    481          /**
    482            * @brief  Starts the TIM Output Compare signal generation on the complementary
    483            *         output.
    484            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
    485            *                the configuration information for TIM module.  
    486            * @param  Channel: TIM Channel to be enabled.
    487            *          This parameter can be one of the following values:
    488            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
    489            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
    490            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
    491            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
    492            * @retval HAL status
    493            */

   \                                 In section .text, align 2, keep-with-next
    494          HAL_StatusTypeDef HAL_TIMEx_OCN_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
    495          {
    496            /* Check the parameters */
    497            assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel)); 
    498            
    499               /* Enable the Capture compare channel N */
    500               TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_ENABLE);
   \                     HAL_TIMEx_OCN_Start: (+1)
   \   00000000   0x6800             LDR      R0,[R0, #+0]
   \   00000002   0x2204             MOVS     R2,#+4
   \   00000004   0xFA02 0xF101      LSL      R1,R2,R1
   \   00000008   0x6A02             LDR      R2,[R0, #+32]
   \   0000000A   0x438A             BICS     R2,R2,R1
   \   0000000C   0x6202             STR      R2,[R0, #+32]
   \   0000000E   0x6A02             LDR      R2,[R0, #+32]
   \   00000010   0x4311             ORRS     R1,R1,R2
   \   00000012   0x6201             STR      R1,[R0, #+32]
    501              
    502            /* Enable the Main Output */
    503              __HAL_TIM_MOE_ENABLE(htim);
   \   00000014   0x6C41             LDR      R1,[R0, #+68]
   \   00000016   0xF441 0x4100      ORR      R1,R1,#0x8000
   \   0000001A   0x6441             STR      R1,[R0, #+68]
    504          
    505            /* Enable the Peripheral */
    506            __HAL_TIM_ENABLE(htim);
   \   0000001C   0x6801             LDR      R1,[R0, #+0]
   \   0000001E   0xF041 0x0101      ORR      R1,R1,#0x1
   \   00000022   0x6001             STR      R1,[R0, #+0]
    507            
    508            /* Return function status */
    509            return HAL_OK;
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0x4770             BX       LR               ;; return
    510          } 
    511          
    512          /**
    513            * @brief  Stops the TIM Output Compare signal generation on the complementary
    514            *         output.
    515            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
    516            *                the configuration information for TIM module.
    517            * @param  Channel: TIM Channel to be disabled.
    518            *          This parameter can be one of the following values:
    519            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
    520            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
    521            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
    522            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
    523            * @retval HAL status
    524            */

   \                                 In section .text, align 2, keep-with-next
    525          HAL_StatusTypeDef HAL_TIMEx_OCN_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
    526          { 
    527            /* Check the parameters */
    528            assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel)); 
    529            
    530              /* Disable the Capture compare channel N */
    531            TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_DISABLE);
   \                     HAL_TIMEx_OCN_Stop: (+1)
   \   00000000   0x6800             LDR      R0,[R0, #+0]
   \   00000002   0x2304             MOVS     R3,#+4
   \   00000004   0xFA03 0xF101      LSL      R1,R3,R1
   \   00000008   0x6A02             LDR      R2,[R0, #+32]
   \   0000000A   0xEA22 0x0101      BIC      R1,R2,R1
   \   0000000E   0x6201             STR      R1,[R0, #+32]
   \   00000010   0x6A01             LDR      R1,[R0, #+32]
   \   00000012   0x6201             STR      R1,[R0, #+32]
    532              
    533            /* Disable the Main Output */
    534              __HAL_TIM_MOE_DISABLE(htim);
   \   00000014   0x6A02             LDR      R2,[R0, #+32]
   \   00000016   0xF241 0x1111      MOVW     R1,#+4369
   \   0000001A   0x420A             TST      R2,R1
   \   0000001C   0xBF02             ITTT     EQ 
   \   0000001E   0x6A02             LDREQ    R2,[R0, #+32]
   \   00000020   0xF240 0x4344      MOVWEQ   R3,#+1092
   \   00000024   0x421A             TSTEQ    R2,R3
   \   00000026   0xD103             BNE.N    ??HAL_TIMEx_OCN_Stop_0
   \   00000028   0x6C42             LDR      R2,[R0, #+68]
   \   0000002A   0xF422 0x4200      BIC      R2,R2,#0x8000
   \   0000002E   0x6442             STR      R2,[R0, #+68]
    535          
    536            /* Disable the Peripheral */
    537            __HAL_TIM_DISABLE(htim);
   \                     ??HAL_TIMEx_OCN_Stop_0: (+1)
   \   00000030   0x6A02             LDR      R2,[R0, #+32]
   \   00000032   0x420A             TST      R2,R1
   \   00000034   0xBF02             ITTT     EQ 
   \   00000036   0x6A01             LDREQ    R1,[R0, #+32]
   \   00000038   0xF240 0x4244      MOVWEQ   R2,#+1092
   \   0000003C   0x4211             TSTEQ    R1,R2
   \   0000003E   0xD103             BNE.N    ??HAL_TIMEx_OCN_Stop_1
   \   00000040   0x6801             LDR      R1,[R0, #+0]
   \   00000042   0x0849             LSRS     R1,R1,#+1
   \   00000044   0x0049             LSLS     R1,R1,#+1
   \   00000046   0x6001             STR      R1,[R0, #+0]
    538            
    539            /* Return function status */
    540            return HAL_OK;
   \                     ??HAL_TIMEx_OCN_Stop_1: (+1)
   \   00000048   0x2000             MOVS     R0,#+0
   \   0000004A   0x4770             BX       LR               ;; return
    541          } 
    542          
    543          /**
    544            * @brief  Starts the TIM Output Compare signal generation in interrupt mode 
    545            *         on the complementary output.
    546            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
    547            *                the configuration information for TIM module.
    548            * @param  Channel: TIM Channel to be enabled.
    549            *          This parameter can be one of the following values:
    550            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
    551            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
    552            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
    553            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
    554            * @retval HAL status
    555            */

   \                                 In section .text, align 4, keep-with-next
    556          HAL_StatusTypeDef HAL_TIMEx_OCN_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
    557          {
    558            /* Check the parameters */
    559            assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel)); 
    560            
    561            switch (Channel)
   \                     HAL_TIMEx_OCN_Start_IT: (+1)
   \   00000000   0x290C             CMP      R1,#+12
   \   00000002   0xD81C             BHI.N    ??HAL_TIMEx_OCN_Start_IT_1
   \   00000004   0xE8DF 0xF001      TBB      [PC, R1]
   \                     ??HAL_TIMEx_OCN_Start_IT_0:
   \   00000008   0x07 0x1B          DC8      0x7,0x1B,0x1B,0x1B
   \              0x1B 0x1B    
   \   0000000C   0x0C 0x1B          DC8      0xC,0x1B,0x1B,0x1B
   \              0x1B 0x1B    
   \   00000010   0x11 0x1B          DC8      0x11,0x1B,0x1B,0x1B
   \              0x1B 0x1B    
   \   00000014   0x16 0x00          DC8      0x16,0x0
    562            {
    563              case TIM_CHANNEL_1:
    564              {       
    565                /* Enable the TIM Output Compare interrupt */
    566                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
   \                     ??HAL_TIMEx_OCN_Start_IT_2: (+1)
   \   00000016   0x6802             LDR      R2,[R0, #+0]
   \   00000018   0x68D3             LDR      R3,[R2, #+12]
   \   0000001A   0xF043 0x0302      ORR      R3,R3,#0x2
   \   0000001E   0xE00D             B.N      ??HAL_TIMEx_OCN_Start_IT_3
    567              }
    568              break;
    569              
    570              case TIM_CHANNEL_2:
    571              {
    572                /* Enable the TIM Output Compare interrupt */
    573                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
   \                     ??HAL_TIMEx_OCN_Start_IT_4: (+1)
   \   00000020   0x6802             LDR      R2,[R0, #+0]
   \   00000022   0x68D3             LDR      R3,[R2, #+12]
   \   00000024   0xF043 0x0304      ORR      R3,R3,#0x4
   \   00000028   0xE008             B.N      ??HAL_TIMEx_OCN_Start_IT_3
    574              }
    575              break;
    576              
    577              case TIM_CHANNEL_3:
    578              {
    579                /* Enable the TIM Output Compare interrupt */
    580                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);
   \                     ??HAL_TIMEx_OCN_Start_IT_5: (+1)
   \   0000002A   0x6802             LDR      R2,[R0, #+0]
   \   0000002C   0x68D3             LDR      R3,[R2, #+12]
   \   0000002E   0xF043 0x0308      ORR      R3,R3,#0x8
   \   00000032   0xE003             B.N      ??HAL_TIMEx_OCN_Start_IT_3
    581              }
    582              break;
    583              
    584              case TIM_CHANNEL_4:
    585              {
    586                /* Enable the TIM Output Compare interrupt */
    587                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC4);
   \                     ??HAL_TIMEx_OCN_Start_IT_6: (+1)
   \   00000034   0x6802             LDR      R2,[R0, #+0]
   \   00000036   0x68D3             LDR      R3,[R2, #+12]
   \   00000038   0xF043 0x0310      ORR      R3,R3,#0x10
   \                     ??HAL_TIMEx_OCN_Start_IT_3: (+1)
   \   0000003C   0x60D3             STR      R3,[R2, #+12]
    588              }
    589              break;
    590              
    591              default:
    592              break;
    593            } 
    594            
    595            /* Enable the TIM Break interrupt */
    596            __HAL_TIM_ENABLE_IT(htim, TIM_IT_BREAK);
   \                     ??HAL_TIMEx_OCN_Start_IT_1: (+1)
   \   0000003E   0x6802             LDR      R2,[R0, #+0]
   \   00000040   0x68D0             LDR      R0,[R2, #+12]
   \   00000042   0xF040 0x0080      ORR      R0,R0,#0x80
   \   00000046   0x60D0             STR      R0,[R2, #+12]
    597            
    598            /* Enable the Capture compare channel N */
    599            TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_ENABLE);
   \   00000048   0x2004             MOVS     R0,#+4
   \   0000004A   0x4088             LSLS     R0,R0,R1
   \   0000004C   0x6A11             LDR      R1,[R2, #+32]
   \   0000004E   0x4381             BICS     R1,R1,R0
   \   00000050   0x6211             STR      R1,[R2, #+32]
   \   00000052   0x6A11             LDR      R1,[R2, #+32]
   \   00000054   0x4308             ORRS     R0,R0,R1
   \   00000056   0x6210             STR      R0,[R2, #+32]
    600          
    601            /* Enable the Main Output */
    602           __HAL_TIM_MOE_ENABLE(htim);
   \   00000058   0x6C50             LDR      R0,[R2, #+68]
   \   0000005A   0xF440 0x4000      ORR      R0,R0,#0x8000
   \   0000005E   0x6450             STR      R0,[R2, #+68]
    603          
    604            /* Enable the Peripheral */
    605            __HAL_TIM_ENABLE(htim);
   \   00000060   0x6810             LDR      R0,[R2, #+0]
   \   00000062   0xF040 0x0001      ORR      R0,R0,#0x1
   \   00000066   0x6010             STR      R0,[R2, #+0]
    606            
    607            /* Return function status */
    608            return HAL_OK;
   \   00000068   0x2000             MOVS     R0,#+0
   \   0000006A   0x4770             BX       LR               ;; return
    609          } 
    610          
    611          /**
    612            * @brief  Stops the TIM Output Compare signal generation in interrupt mode 
    613            *         on the complementary output.
    614            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
    615            *                the configuration information for TIM module.
    616            * @param  Channel: TIM Channel to be disabled.
    617            *          This parameter can be one of the following values:
    618            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
    619            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
    620            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
    621            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
    622            * @retval HAL status
    623            */

   \                                 In section .text, align 4, keep-with-next
    624          HAL_StatusTypeDef HAL_TIMEx_OCN_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
    625          {
    626            uint32_t tmpccer = 0; 
    627          
    628            /* Check the parameters */
    629            assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel)); 
    630            
    631            switch (Channel)
   \                     HAL_TIMEx_OCN_Stop_IT: (+1)
   \   00000000   0x290C             CMP      R1,#+12
   \   00000002   0xD81C             BHI.N    ??HAL_TIMEx_OCN_Stop_IT_1
   \   00000004   0xE8DF 0xF001      TBB      [PC, R1]
   \                     ??HAL_TIMEx_OCN_Stop_IT_0:
   \   00000008   0x07 0x1B          DC8      0x7,0x1B,0x1B,0x1B
   \              0x1B 0x1B    
   \   0000000C   0x0C 0x1B          DC8      0xC,0x1B,0x1B,0x1B
   \              0x1B 0x1B    
   \   00000010   0x11 0x1B          DC8      0x11,0x1B,0x1B,0x1B
   \              0x1B 0x1B    
   \   00000014   0x16 0x00          DC8      0x16,0x0
    632            {
    633              case TIM_CHANNEL_1:
    634              {       
    635                /* Disable the TIM Output Compare interrupt */
    636                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
   \                     ??HAL_TIMEx_OCN_Stop_IT_2: (+1)
   \   00000016   0x6802             LDR      R2,[R0, #+0]
   \   00000018   0x68D3             LDR      R3,[R2, #+12]
   \   0000001A   0xF023 0x0302      BIC      R3,R3,#0x2
   \   0000001E   0xE00D             B.N      ??HAL_TIMEx_OCN_Stop_IT_3
    637              }
    638              break;
    639              
    640              case TIM_CHANNEL_2:
    641              {
    642                /* Disable the TIM Output Compare interrupt */
    643                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
   \                     ??HAL_TIMEx_OCN_Stop_IT_4: (+1)
   \   00000020   0x6802             LDR      R2,[R0, #+0]
   \   00000022   0x68D3             LDR      R3,[R2, #+12]
   \   00000024   0xF023 0x0304      BIC      R3,R3,#0x4
   \   00000028   0xE008             B.N      ??HAL_TIMEx_OCN_Stop_IT_3
    644              }
    645              break;
    646              
    647              case TIM_CHANNEL_3:
    648              {
    649                /* Disable the TIM Output Compare interrupt */
    650                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);
   \                     ??HAL_TIMEx_OCN_Stop_IT_5: (+1)
   \   0000002A   0x6802             LDR      R2,[R0, #+0]
   \   0000002C   0x68D3             LDR      R3,[R2, #+12]
   \   0000002E   0xF023 0x0308      BIC      R3,R3,#0x8
   \   00000032   0xE003             B.N      ??HAL_TIMEx_OCN_Stop_IT_3
    651              }
    652              break;
    653              
    654              case TIM_CHANNEL_4:
    655              {
    656                /* Disable the TIM Output Compare interrupt */
    657                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC4);
   \                     ??HAL_TIMEx_OCN_Stop_IT_6: (+1)
   \   00000034   0x6802             LDR      R2,[R0, #+0]
   \   00000036   0x68D3             LDR      R3,[R2, #+12]
   \   00000038   0xF023 0x0310      BIC      R3,R3,#0x10
   \                     ??HAL_TIMEx_OCN_Stop_IT_3: (+1)
   \   0000003C   0x60D3             STR      R3,[R2, #+12]
    658              }
    659              break;
    660              
    661              default:
    662              break; 
    663            }
    664          
    665            /* Disable the Capture compare channel N */
    666            TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_DISABLE);
   \                     ??HAL_TIMEx_OCN_Stop_IT_1: (+1)
   \   0000003E   0x6802             LDR      R2,[R0, #+0]
   \   00000040   0x2304             MOVS     R3,#+4
   \   00000042   0xFA03 0xF101      LSL      R1,R3,R1
   \   00000046   0x6A10             LDR      R0,[R2, #+32]
   \   00000048   0x4388             BICS     R0,R0,R1
    667          
    668            /* Disable the TIM Break interrupt (only if no more channel is active) */
    669            tmpccer = htim->Instance->CCER;
    670            if ((tmpccer & (TIM_CCER_CC1NE | TIM_CCER_CC2NE | TIM_CCER_CC3NE)) == RESET)
   \   0000004A   0xF240 0x4144      MOVW     R1,#+1092
   \   0000004E   0x6210             STR      R0,[R2, #+32]
   \   00000050   0x6A10             LDR      R0,[R2, #+32]
   \   00000052   0x6210             STR      R0,[R2, #+32]
   \   00000054   0x6A10             LDR      R0,[R2, #+32]
   \   00000056   0x4208             TST      R0,R1
   \   00000058   0xD103             BNE.N    ??HAL_TIMEx_OCN_Stop_IT_7
    671            {
    672              __HAL_TIM_DISABLE_IT(htim, TIM_IT_BREAK);
   \   0000005A   0x68D0             LDR      R0,[R2, #+12]
   \   0000005C   0xF020 0x0080      BIC      R0,R0,#0x80
   \   00000060   0x60D0             STR      R0,[R2, #+12]
    673            }
    674          
    675            /* Disable the Main Output */
    676            __HAL_TIM_MOE_DISABLE(htim);
   \                     ??HAL_TIMEx_OCN_Stop_IT_7: (+1)
   \   00000062   0x6A13             LDR      R3,[R2, #+32]
   \   00000064   0xF241 0x1011      MOVW     R0,#+4369
   \   00000068   0x4203             TST      R3,R0
   \   0000006A   0xBF04             ITT      EQ 
   \   0000006C   0x6A13             LDREQ    R3,[R2, #+32]
   \   0000006E   0x420B             TSTEQ    R3,R1
   \   00000070   0xD103             BNE.N    ??HAL_TIMEx_OCN_Stop_IT_8
   \   00000072   0x6C53             LDR      R3,[R2, #+68]
   \   00000074   0xF423 0x4300      BIC      R3,R3,#0x8000
   \   00000078   0x6453             STR      R3,[R2, #+68]
    677          
    678            /* Disable the Peripheral */
    679            __HAL_TIM_DISABLE(htim);
   \                     ??HAL_TIMEx_OCN_Stop_IT_8: (+1)
   \   0000007A   0x6A13             LDR      R3,[R2, #+32]
   \   0000007C   0x4203             TST      R3,R0
   \   0000007E   0xBF04             ITT      EQ 
   \   00000080   0x6A10             LDREQ    R0,[R2, #+32]
   \   00000082   0x4208             TSTEQ    R0,R1
   \   00000084   0xD103             BNE.N    ??HAL_TIMEx_OCN_Stop_IT_9
   \   00000086   0x6810             LDR      R0,[R2, #+0]
   \   00000088   0x0840             LSRS     R0,R0,#+1
   \   0000008A   0x0040             LSLS     R0,R0,#+1
   \   0000008C   0x6010             STR      R0,[R2, #+0]
    680            
    681            /* Return function status */
    682            return HAL_OK;
   \                     ??HAL_TIMEx_OCN_Stop_IT_9: (+1)
   \   0000008E   0x2000             MOVS     R0,#+0
   \   00000090   0x4770             BX       LR               ;; return
    683          } 
    684          
    685          /**
    686            * @brief  Starts the TIM Output Compare signal generation in DMA mode 
    687            *         on the complementary output.
    688            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
    689            *                the configuration information for TIM module.
    690            * @param  Channel: TIM Channel to be enabled.
    691            *          This parameter can be one of the following values:
    692            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
    693            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
    694            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
    695            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
    696            * @param  pData: The source Buffer address.
    697            * @param  Length: The length of data to be transferred from memory to TIM peripheral
    698            * @retval HAL status
    699            */

   \                                 In section .text, align 4, keep-with-next
    700          HAL_StatusTypeDef HAL_TIMEx_OCN_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData, uint16_t Length)
    701          {
   \                     HAL_TIMEx_OCN_Start_DMA: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0xB081             SUB      SP,SP,#+4
   \   00000006   0x460D             MOV      R5,R1
   \   00000008   0x4611             MOV      R1,R2
    702            /* Check the parameters */
    703            assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel)); 
    704            
    705            if((htim->State == HAL_TIM_STATE_BUSY))
   \   0000000A   0xF894 0x0039      LDRB     R0,[R4, #+57]
   \   0000000E   0x2802             CMP      R0,#+2
   \   00000010   0xD074             BEQ.N    ??HAL_TIMEx_OCN_Start_DMA_1
    706            {
    707               return HAL_BUSY;
    708            }
    709            else if((htim->State == HAL_TIM_STATE_READY))
   \   00000012   0xF894 0x0039      LDRB     R0,[R4, #+57]
   \   00000016   0x2801             CMP      R0,#+1
   \   00000018   0xD105             BNE.N    ??HAL_TIMEx_OCN_Start_DMA_2
    710            {
    711              if(((uint32_t)pData == 0 ) && (Length > 0)) 
   \   0000001A   0xB909             CBNZ.N   R1,??HAL_TIMEx_OCN_Start_DMA_3
   \   0000001C   0x2B00             CMP      R3,#+0
   \   0000001E   0xD16D             BNE.N    ??HAL_TIMEx_OCN_Start_DMA_1
    712              {
    713                return HAL_ERROR;                                    
    714              }
    715              else
    716              {
    717                htim->State = HAL_TIM_STATE_BUSY;
   \                     ??HAL_TIMEx_OCN_Start_DMA_3: (+1)
   \   00000020   0x2002             MOVS     R0,#+2
   \   00000022   0xF884 0x0039      STRB     R0,[R4, #+57]
    718              }
    719            }    
    720            switch (Channel)
   \                     ??HAL_TIMEx_OCN_Start_DMA_2: (+1)
   \   00000026   0x2D0C             CMP      R5,#+12
   \   00000028   0xD854             BHI.N    ??HAL_TIMEx_OCN_Start_DMA_4
   \   0000002A   0xE8DF 0xF005      TBB      [PC, R5]
   \                     ??HAL_TIMEx_OCN_Start_DMA_0:
   \   0000002E   0x07 0x53          DC8      0x7,0x53,0x53,0x53
   \              0x53 0x53    
   \   00000032   0x1A 0x53          DC8      0x1A,0x53,0x53,0x53
   \              0x53 0x53    
   \   00000036   0x2D 0x53          DC8      0x2D,0x53,0x53,0x53
   \              0x53 0x53    
   \   0000003A   0x40 0x00          DC8      0x40,0x0
    721            {
    722              case TIM_CHANNEL_1:
    723              {      
    724                /* Set the DMA Period elapsed callback */
    725                htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = HAL_TIM_DMADelayPulseCplt;
   \                     ??HAL_TIMEx_OCN_Start_DMA_5: (+1)
   \   0000003C   0x6A22             LDR      R2,[R4, #+32]
   \   0000003E   0x.... 0x....      LDR.W    R0,??DataTable7_2
   \   00000042   0x63D0             STR      R0,[R2, #+60]
    726               
    727                /* Set the DMA error callback */
    728                htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = HAL_TIM_DMAError ;
   \   00000044   0x6A22             LDR      R2,[R4, #+32]
   \   00000046   0x.... 0x....      LDR.W    R0,??DataTable7_1
   \   0000004A   0x6490             STR      R0,[R2, #+72]
    729                
    730                /* Enable the DMA Stream */
    731                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)pData, (uint32_t)&htim->Instance->CCR1, Length);
   \   0000004C   0x6820             LDR      R0,[R4, #+0]
   \   0000004E   0xF100 0x0234      ADD      R2,R0,#+52
   \   00000052   0x6A20             LDR      R0,[R4, #+32]
   \   00000054   0x.... 0x....      BL       HAL_DMA_Start_IT
    732                
    733                /* Enable the TIM Output Compare DMA request */
    734                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
   \   00000058   0x6820             LDR      R0,[R4, #+0]
   \   0000005A   0x68C1             LDR      R1,[R0, #+12]
   \   0000005C   0xF441 0x7100      ORR      R1,R1,#0x200
   \   00000060   0xE037             B.N      ??HAL_TIMEx_OCN_Start_DMA_6
    735              }
    736              break;
    737              
    738              case TIM_CHANNEL_2:
    739              {
    740                /* Set the DMA Period elapsed callback */
    741                htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = HAL_TIM_DMADelayPulseCplt;
   \                     ??HAL_TIMEx_OCN_Start_DMA_7: (+1)
   \   00000062   0x6A62             LDR      R2,[R4, #+36]
   \   00000064   0x.... 0x....      LDR.W    R0,??DataTable7_2
   \   00000068   0x63D0             STR      R0,[R2, #+60]
    742               
    743                /* Set the DMA error callback */
    744                htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = HAL_TIM_DMAError ;
   \   0000006A   0x6A62             LDR      R2,[R4, #+36]
   \   0000006C   0x.... 0x....      LDR.W    R0,??DataTable7_1
   \   00000070   0x6490             STR      R0,[R2, #+72]
    745                
    746                /* Enable the DMA Stream */
    747                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)pData, (uint32_t)&htim->Instance->CCR2, Length);
   \   00000072   0x6820             LDR      R0,[R4, #+0]
   \   00000074   0xF100 0x0238      ADD      R2,R0,#+56
   \   00000078   0x6A60             LDR      R0,[R4, #+36]
   \   0000007A   0x.... 0x....      BL       HAL_DMA_Start_IT
    748                
    749                /* Enable the TIM Output Compare DMA request */
    750                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
   \   0000007E   0x6820             LDR      R0,[R4, #+0]
   \   00000080   0x68C1             LDR      R1,[R0, #+12]
   \   00000082   0xF441 0x6180      ORR      R1,R1,#0x400
   \   00000086   0xE024             B.N      ??HAL_TIMEx_OCN_Start_DMA_6
    751              }
    752              break;
    753              
    754              case TIM_CHANNEL_3:
    755          {
    756                /* Set the DMA Period elapsed callback */
    757                htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = HAL_TIM_DMADelayPulseCplt;
   \                     ??HAL_TIMEx_OCN_Start_DMA_8: (+1)
   \   00000088   0x6AA2             LDR      R2,[R4, #+40]
   \   0000008A   0x.... 0x....      LDR.W    R0,??DataTable7_2
   \   0000008E   0x63D0             STR      R0,[R2, #+60]
    758               
    759                /* Set the DMA error callback */
    760                htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = HAL_TIM_DMAError ;
   \   00000090   0x6AA2             LDR      R2,[R4, #+40]
   \   00000092   0x.... 0x....      LDR.W    R0,??DataTable7_1
   \   00000096   0x6490             STR      R0,[R2, #+72]
    761                
    762                /* Enable the DMA Stream */
    763                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)pData, (uint32_t)&htim->Instance->CCR3,Length);
   \   00000098   0x6820             LDR      R0,[R4, #+0]
   \   0000009A   0xF100 0x023C      ADD      R2,R0,#+60
   \   0000009E   0x6AA0             LDR      R0,[R4, #+40]
   \   000000A0   0x.... 0x....      BL       HAL_DMA_Start_IT
    764                
    765                /* Enable the TIM Output Compare DMA request */
    766                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);
   \   000000A4   0x6820             LDR      R0,[R4, #+0]
   \   000000A6   0x68C1             LDR      R1,[R0, #+12]
   \   000000A8   0xF441 0x6100      ORR      R1,R1,#0x800
   \   000000AC   0xE011             B.N      ??HAL_TIMEx_OCN_Start_DMA_6
    767              }
    768              break;
    769              
    770              case TIM_CHANNEL_4:
    771              {
    772               /* Set the DMA Period elapsed callback */
    773                htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = HAL_TIM_DMADelayPulseCplt;
   \                     ??HAL_TIMEx_OCN_Start_DMA_9: (+1)
   \   000000AE   0x6AE2             LDR      R2,[R4, #+44]
   \   000000B0   0x.... 0x....      LDR.W    R0,??DataTable7_2
   \   000000B4   0x63D0             STR      R0,[R2, #+60]
    774               
    775                /* Set the DMA error callback */
    776                htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = HAL_TIM_DMAError ;
   \   000000B6   0x6AE2             LDR      R2,[R4, #+44]
   \   000000B8   0x.... 0x....      LDR.W    R0,??DataTable7_1
   \   000000BC   0x6490             STR      R0,[R2, #+72]
    777                
    778                /* Enable the DMA Stream */
    779                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)pData, (uint32_t)&htim->Instance->CCR4, Length);
   \   000000BE   0x6820             LDR      R0,[R4, #+0]
   \   000000C0   0xF100 0x0240      ADD      R2,R0,#+64
   \   000000C4   0x6AE0             LDR      R0,[R4, #+44]
   \   000000C6   0x.... 0x....      BL       HAL_DMA_Start_IT
    780                
    781                /* Enable the TIM Output Compare DMA request */
    782                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC4);
   \   000000CA   0x6820             LDR      R0,[R4, #+0]
   \   000000CC   0x68C1             LDR      R1,[R0, #+12]
   \   000000CE   0xF441 0x5180      ORR      R1,R1,#0x1000
   \                     ??HAL_TIMEx_OCN_Start_DMA_6: (+1)
   \   000000D2   0x60C1             STR      R1,[R0, #+12]
    783              }
    784              break;
    785              
    786              default:
    787              break;
    788            }
    789          
    790            /* Enable the Capture compare channel N */
    791            TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_ENABLE);
   \                     ??HAL_TIMEx_OCN_Start_DMA_4: (+1)
   \   000000D4   0x6820             LDR      R0,[R4, #+0]
   \   000000D6   0x2104             MOVS     R1,#+4
   \   000000D8   0x40A9             LSLS     R1,R1,R5
   \   000000DA   0x6A02             LDR      R2,[R0, #+32]
   \   000000DC   0x438A             BICS     R2,R2,R1
   \   000000DE   0x6202             STR      R2,[R0, #+32]
   \   000000E0   0x6A02             LDR      R2,[R0, #+32]
   \   000000E2   0x4311             ORRS     R1,R1,R2
   \   000000E4   0x6201             STR      R1,[R0, #+32]
    792            
    793            /* Enable the Main Output */
    794            __HAL_TIM_MOE_ENABLE(htim);
   \   000000E6   0x6820             LDR      R0,[R4, #+0]
   \   000000E8   0x6C41             LDR      R1,[R0, #+68]
   \   000000EA   0xF441 0x4100      ORR      R1,R1,#0x8000
   \   000000EE   0x6441             STR      R1,[R0, #+68]
    795            
    796            /* Enable the Peripheral */
    797            __HAL_TIM_ENABLE(htim); 
   \   000000F0   0x6820             LDR      R0,[R4, #+0]
   \   000000F2   0x6801             LDR      R1,[R0, #+0]
   \   000000F4   0xF041 0x0101      ORR      R1,R1,#0x1
   \   000000F8   0x6001             STR      R1,[R0, #+0]
    798            
    799            /* Return function status */
    800            return HAL_OK;
   \   000000FA   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIMEx_OCN_Start_DMA_1: (+1)
   \   000000FC   0xB001             ADD      SP,SP,#+4
   \   000000FE   0xBD30             POP      {R4,R5,PC}       ;; return
    801          }
    802          
    803          /**
    804            * @brief  Stops the TIM Output Compare signal generation in DMA mode 
    805            *         on the complementary output.
    806            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
    807            *                the configuration information for TIM module.
    808            * @param  Channel: TIM Channel to be disabled.
    809            *          This parameter can be one of the following values:
    810            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
    811            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
    812            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
    813            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
    814            * @retval HAL status
    815            */

   \                                 In section .text, align 4, keep-with-next
    816          HAL_StatusTypeDef HAL_TIMEx_OCN_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
    817          {
    818            /* Check the parameters */
    819            assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel)); 
    820            
    821            switch (Channel)
   \                     HAL_TIMEx_OCN_Stop_DMA: (+1)
   \   00000000   0x290C             CMP      R1,#+12
   \   00000002   0xB410             PUSH     {R4}
   \   00000004   0xD81C             BHI.N    ??HAL_TIMEx_OCN_Stop_DMA_1
   \   00000006   0xE8DF 0xF001      TBB      [PC, R1]
   \                     ??HAL_TIMEx_OCN_Stop_DMA_0:
   \   0000000A   0x07 0x1B          DC8      0x7,0x1B,0x1B,0x1B
   \              0x1B 0x1B    
   \   0000000E   0x0C 0x1B          DC8      0xC,0x1B,0x1B,0x1B
   \              0x1B 0x1B    
   \   00000012   0x11 0x1B          DC8      0x11,0x1B,0x1B,0x1B
   \              0x1B 0x1B    
   \   00000016   0x16 0x00          DC8      0x16,0x0
    822            {
    823              case TIM_CHANNEL_1:
    824              {       
    825                /* Disable the TIM Output Compare DMA request */
    826                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
   \                     ??HAL_TIMEx_OCN_Stop_DMA_2: (+1)
   \   00000018   0x6802             LDR      R2,[R0, #+0]
   \   0000001A   0x68D3             LDR      R3,[R2, #+12]
   \   0000001C   0xF423 0x7300      BIC      R3,R3,#0x200
   \   00000020   0xE00D             B.N      ??HAL_TIMEx_OCN_Stop_DMA_3
    827              }
    828              break;
    829              
    830              case TIM_CHANNEL_2:
    831              {
    832                /* Disable the TIM Output Compare DMA request */
    833                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
   \                     ??HAL_TIMEx_OCN_Stop_DMA_4: (+1)
   \   00000022   0x6802             LDR      R2,[R0, #+0]
   \   00000024   0x68D3             LDR      R3,[R2, #+12]
   \   00000026   0xF423 0x6380      BIC      R3,R3,#0x400
   \   0000002A   0xE008             B.N      ??HAL_TIMEx_OCN_Stop_DMA_3
    834              }
    835              break;
    836              
    837              case TIM_CHANNEL_3:
    838              {
    839                /* Disable the TIM Output Compare DMA request */
    840                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);
   \                     ??HAL_TIMEx_OCN_Stop_DMA_5: (+1)
   \   0000002C   0x6802             LDR      R2,[R0, #+0]
   \   0000002E   0x68D3             LDR      R3,[R2, #+12]
   \   00000030   0xF423 0x6300      BIC      R3,R3,#0x800
   \   00000034   0xE003             B.N      ??HAL_TIMEx_OCN_Stop_DMA_3
    841              }
    842              break;
    843              
    844              case TIM_CHANNEL_4:
    845              {
    846                /* Disable the TIM Output Compare interrupt */
    847                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC4);
   \                     ??HAL_TIMEx_OCN_Stop_DMA_6: (+1)
   \   00000036   0x6802             LDR      R2,[R0, #+0]
   \   00000038   0x68D3             LDR      R3,[R2, #+12]
   \   0000003A   0xF423 0x5380      BIC      R3,R3,#0x1000
   \                     ??HAL_TIMEx_OCN_Stop_DMA_3: (+1)
   \   0000003E   0x60D3             STR      R3,[R2, #+12]
    848              }
    849              break;
    850              
    851              default:
    852              break;
    853            } 
    854            
    855            /* Disable the Capture compare channel N */
    856            TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_DISABLE);
   \                     ??HAL_TIMEx_OCN_Stop_DMA_1: (+1)
   \   00000040   0x6802             LDR      R2,[R0, #+0]
   \   00000042   0x2404             MOVS     R4,#+4
   \   00000044   0xFA04 0xF101      LSL      R1,R4,R1
   \   00000048   0x6A13             LDR      R3,[R2, #+32]
   \   0000004A   0xEA23 0x0101      BIC      R1,R3,R1
   \   0000004E   0x6211             STR      R1,[R2, #+32]
   \   00000050   0x6A11             LDR      R1,[R2, #+32]
   \   00000052   0x6211             STR      R1,[R2, #+32]
    857            
    858            /* Disable the Main Output */
    859            __HAL_TIM_MOE_DISABLE(htim);
   \   00000054   0x6801             LDR      R1,[R0, #+0]
   \   00000056   0xF241 0x1211      MOVW     R2,#+4369
   \   0000005A   0x6A0B             LDR      R3,[R1, #+32]
   \   0000005C   0x4213             TST      R3,R2
   \   0000005E   0xBF02             ITTT     EQ 
   \   00000060   0x6A0B             LDREQ    R3,[R1, #+32]
   \   00000062   0xF240 0x4444      MOVWEQ   R4,#+1092
   \   00000066   0x4223             TSTEQ    R3,R4
   \   00000068   0xD103             BNE.N    ??HAL_TIMEx_OCN_Stop_DMA_7
   \   0000006A   0x6C4B             LDR      R3,[R1, #+68]
   \   0000006C   0xF423 0x4300      BIC      R3,R3,#0x8000
   \   00000070   0x644B             STR      R3,[R1, #+68]
    860            
    861            /* Disable the Peripheral */
    862            __HAL_TIM_DISABLE(htim);
   \                     ??HAL_TIMEx_OCN_Stop_DMA_7: (+1)
   \   00000072   0x6801             LDR      R1,[R0, #+0]
   \   00000074   0x6A0B             LDR      R3,[R1, #+32]
   \   00000076   0x4213             TST      R3,R2
   \   00000078   0xBF02             ITTT     EQ 
   \   0000007A   0x6A0A             LDREQ    R2,[R1, #+32]
   \   0000007C   0xF240 0x4344      MOVWEQ   R3,#+1092
   \   00000080   0x421A             TSTEQ    R2,R3
   \   00000082   0xD103             BNE.N    ??HAL_TIMEx_OCN_Stop_DMA_8
   \   00000084   0x680A             LDR      R2,[R1, #+0]
   \   00000086   0x0852             LSRS     R2,R2,#+1
   \   00000088   0x0052             LSLS     R2,R2,#+1
   \   0000008A   0x600A             STR      R2,[R1, #+0]
    863            
    864            /* Change the htim state */
    865            htim->State = HAL_TIM_STATE_READY;
   \                     ??HAL_TIMEx_OCN_Stop_DMA_8: (+1)
   \   0000008C   0x2101             MOVS     R1,#+1
   \   0000008E   0xF880 0x1039      STRB     R1,[R0, #+57]
    866            
    867            /* Return function status */
    868            return HAL_OK;
   \   00000092   0x2000             MOVS     R0,#+0
   \   00000094   0xBC10             POP      {R4}
   \   00000096   0x4770             BX       LR               ;; return
    869          }
    870          
    871          /**
    872            * @}
    873            */
    874            
    875          /** @defgroup TIMEx_Exported_Functions_Group3 Extended Timer Complementary PWM functions
    876           *  @brief    Timer Complementary PWM functions 
    877           *
    878          @verbatim   
    879            ==============================================================================
    880                           ##### Timer Complementary PWM functions #####
    881            ==============================================================================  
    882            [..]  
    883              This section provides functions allowing to:
    884              (+) Start the Complementary PWM.
    885              (+) Stop the Complementary PWM.
    886              (+) Start the Complementary PWM and enable interrupts.
    887              (+) Stop the Complementary PWM and disable interrupts.
    888              (+) Start the Complementary PWM and enable DMA transfers.
    889              (+) Stop the Complementary PWM and disable DMA transfers.
    890              (+) Start the Complementary Input Capture measurement.
    891              (+) Stop the Complementary Input Capture.
    892              (+) Start the Complementary Input Capture and enable interrupts.
    893              (+) Stop the Complementary Input Capture and disable interrupts.
    894              (+) Start the Complementary Input Capture and enable DMA transfers.
    895              (+) Stop the Complementary Input Capture and disable DMA transfers.
    896              (+) Start the Complementary One Pulse generation.
    897              (+) Stop the Complementary One Pulse.
    898              (+) Start the Complementary One Pulse and enable interrupts.
    899              (+) Stop the Complementary One Pulse and disable interrupts.
    900                         
    901          @endverbatim
    902            * @{
    903            */
    904          
    905          /**
    906            * @brief  Starts the PWM signal generation on the complementary output.
    907            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
    908            *                the configuration information for TIM module.
    909            * @param  Channel: TIM Channel to be enabled.
    910            *          This parameter can be one of the following values:
    911            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
    912            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
    913            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
    914            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
    915            * @retval HAL status
    916            */

   \                                 In section .text, align 2, keep-with-next
    917          HAL_StatusTypeDef HAL_TIMEx_PWMN_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
    918          {
    919            /* Check the parameters */
    920            assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel)); 
    921            
    922            /* Enable the complementary PWM output  */
    923            TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_ENABLE);
   \                     HAL_TIMEx_PWMN_Start: (+1)
   \   00000000   0x6800             LDR      R0,[R0, #+0]
   \   00000002   0x2204             MOVS     R2,#+4
   \   00000004   0xFA02 0xF101      LSL      R1,R2,R1
   \   00000008   0x6A02             LDR      R2,[R0, #+32]
   \   0000000A   0x438A             BICS     R2,R2,R1
   \   0000000C   0x6202             STR      R2,[R0, #+32]
   \   0000000E   0x6A02             LDR      R2,[R0, #+32]
   \   00000010   0x4311             ORRS     R1,R1,R2
   \   00000012   0x6201             STR      R1,[R0, #+32]
    924            
    925            /* Enable the Main Output */
    926            __HAL_TIM_MOE_ENABLE(htim);
   \   00000014   0x6C41             LDR      R1,[R0, #+68]
   \   00000016   0xF441 0x4100      ORR      R1,R1,#0x8000
   \   0000001A   0x6441             STR      R1,[R0, #+68]
    927            
    928            /* Enable the Peripheral */
    929            __HAL_TIM_ENABLE(htim);
   \   0000001C   0x6801             LDR      R1,[R0, #+0]
   \   0000001E   0xF041 0x0101      ORR      R1,R1,#0x1
   \   00000022   0x6001             STR      R1,[R0, #+0]
    930            
    931            /* Return function status */
    932            return HAL_OK;
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0x4770             BX       LR               ;; return
    933          } 
    934          
    935          /**
    936            * @brief  Stops the PWM signal generation on the complementary output.
    937            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
    938            *                the configuration information for TIM module.
    939            * @param  Channel: TIM Channel to be disabled.
    940            *          This parameter can be one of the following values:
    941            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
    942            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
    943            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
    944            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
    945            * @retval HAL status
    946            */

   \                                 In section .text, align 2, keep-with-next
    947          HAL_StatusTypeDef HAL_TIMEx_PWMN_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
    948          { 
    949            /* Check the parameters */
    950            assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel)); 
    951            
    952            /* Disable the complementary PWM output  */
    953            TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_DISABLE);  
   \                     HAL_TIMEx_PWMN_Stop: (+1)
   \   00000000   0x6800             LDR      R0,[R0, #+0]
   \   00000002   0x2304             MOVS     R3,#+4
   \   00000004   0xFA03 0xF101      LSL      R1,R3,R1
   \   00000008   0x6A02             LDR      R2,[R0, #+32]
   \   0000000A   0xEA22 0x0101      BIC      R1,R2,R1
   \   0000000E   0x6201             STR      R1,[R0, #+32]
   \   00000010   0x6A01             LDR      R1,[R0, #+32]
   \   00000012   0x6201             STR      R1,[R0, #+32]
    954            
    955            /* Disable the Main Output */
    956            __HAL_TIM_MOE_DISABLE(htim);
   \   00000014   0x6A02             LDR      R2,[R0, #+32]
   \   00000016   0xF241 0x1111      MOVW     R1,#+4369
   \   0000001A   0x420A             TST      R2,R1
   \   0000001C   0xBF02             ITTT     EQ 
   \   0000001E   0x6A02             LDREQ    R2,[R0, #+32]
   \   00000020   0xF240 0x4344      MOVWEQ   R3,#+1092
   \   00000024   0x421A             TSTEQ    R2,R3
   \   00000026   0xD103             BNE.N    ??HAL_TIMEx_PWMN_Stop_0
   \   00000028   0x6C42             LDR      R2,[R0, #+68]
   \   0000002A   0xF422 0x4200      BIC      R2,R2,#0x8000
   \   0000002E   0x6442             STR      R2,[R0, #+68]
    957            
    958            /* Disable the Peripheral */
    959            __HAL_TIM_DISABLE(htim);
   \                     ??HAL_TIMEx_PWMN_Stop_0: (+1)
   \   00000030   0x6A02             LDR      R2,[R0, #+32]
   \   00000032   0x420A             TST      R2,R1
   \   00000034   0xBF02             ITTT     EQ 
   \   00000036   0x6A01             LDREQ    R1,[R0, #+32]
   \   00000038   0xF240 0x4244      MOVWEQ   R2,#+1092
   \   0000003C   0x4211             TSTEQ    R1,R2
   \   0000003E   0xD103             BNE.N    ??HAL_TIMEx_PWMN_Stop_1
   \   00000040   0x6801             LDR      R1,[R0, #+0]
   \   00000042   0x0849             LSRS     R1,R1,#+1
   \   00000044   0x0049             LSLS     R1,R1,#+1
   \   00000046   0x6001             STR      R1,[R0, #+0]
    960            
    961            /* Return function status */
    962            return HAL_OK;
   \                     ??HAL_TIMEx_PWMN_Stop_1: (+1)
   \   00000048   0x2000             MOVS     R0,#+0
   \   0000004A   0x4770             BX       LR               ;; return
    963          } 
    964          
    965          /**
    966            * @brief  Starts the PWM signal generation in interrupt mode on the 
    967            *         complementary output.
    968            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
    969            *                the configuration information for TIM module.
    970            * @param  Channel: TIM Channel to be disabled.
    971            *          This parameter can be one of the following values:
    972            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
    973            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
    974            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
    975            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
    976            * @retval HAL status
    977            */

   \                                 In section .text, align 4, keep-with-next
    978          HAL_StatusTypeDef HAL_TIMEx_PWMN_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
    979          {
    980            /* Check the parameters */
    981            assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel)); 
    982            
    983            switch (Channel)
   \                     HAL_TIMEx_PWMN_Start_IT: (+1)
   \   00000000   0x290C             CMP      R1,#+12
   \   00000002   0xD81C             BHI.N    ??HAL_TIMEx_PWMN_Start_IT_1
   \   00000004   0xE8DF 0xF001      TBB      [PC, R1]
   \                     ??HAL_TIMEx_PWMN_Start_IT_0:
   \   00000008   0x07 0x1B          DC8      0x7,0x1B,0x1B,0x1B
   \              0x1B 0x1B    
   \   0000000C   0x0C 0x1B          DC8      0xC,0x1B,0x1B,0x1B
   \              0x1B 0x1B    
   \   00000010   0x11 0x1B          DC8      0x11,0x1B,0x1B,0x1B
   \              0x1B 0x1B    
   \   00000014   0x16 0x00          DC8      0x16,0x0
    984            {
    985              case TIM_CHANNEL_1:
    986              {       
    987                /* Enable the TIM Capture/Compare 1 interrupt */
    988                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
   \                     ??HAL_TIMEx_PWMN_Start_IT_2: (+1)
   \   00000016   0x6802             LDR      R2,[R0, #+0]
   \   00000018   0x68D3             LDR      R3,[R2, #+12]
   \   0000001A   0xF043 0x0302      ORR      R3,R3,#0x2
   \   0000001E   0xE00D             B.N      ??HAL_TIMEx_PWMN_Start_IT_3
    989              }
    990              break;
    991              
    992              case TIM_CHANNEL_2:
    993              {
    994                /* Enable the TIM Capture/Compare 2 interrupt */
    995                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
   \                     ??HAL_TIMEx_PWMN_Start_IT_4: (+1)
   \   00000020   0x6802             LDR      R2,[R0, #+0]
   \   00000022   0x68D3             LDR      R3,[R2, #+12]
   \   00000024   0xF043 0x0304      ORR      R3,R3,#0x4
   \   00000028   0xE008             B.N      ??HAL_TIMEx_PWMN_Start_IT_3
    996              }
    997              break;
    998              
    999              case TIM_CHANNEL_3:
   1000              {
   1001                /* Enable the TIM Capture/Compare 3 interrupt */
   1002                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);
   \                     ??HAL_TIMEx_PWMN_Start_IT_5: (+1)
   \   0000002A   0x6802             LDR      R2,[R0, #+0]
   \   0000002C   0x68D3             LDR      R3,[R2, #+12]
   \   0000002E   0xF043 0x0308      ORR      R3,R3,#0x8
   \   00000032   0xE003             B.N      ??HAL_TIMEx_PWMN_Start_IT_3
   1003              }
   1004              break;
   1005              
   1006              case TIM_CHANNEL_4:
   1007              {
   1008                /* Enable the TIM Capture/Compare 4 interrupt */
   1009                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC4);
   \                     ??HAL_TIMEx_PWMN_Start_IT_6: (+1)
   \   00000034   0x6802             LDR      R2,[R0, #+0]
   \   00000036   0x68D3             LDR      R3,[R2, #+12]
   \   00000038   0xF043 0x0310      ORR      R3,R3,#0x10
   \                     ??HAL_TIMEx_PWMN_Start_IT_3: (+1)
   \   0000003C   0x60D3             STR      R3,[R2, #+12]
   1010              }
   1011              break;
   1012              
   1013              default:
   1014              break;
   1015            } 
   1016            
   1017            /* Enable the TIM Break interrupt */
   1018            __HAL_TIM_ENABLE_IT(htim, TIM_IT_BREAK);
   \                     ??HAL_TIMEx_PWMN_Start_IT_1: (+1)
   \   0000003E   0x6802             LDR      R2,[R0, #+0]
   \   00000040   0x68D0             LDR      R0,[R2, #+12]
   \   00000042   0xF040 0x0080      ORR      R0,R0,#0x80
   \   00000046   0x60D0             STR      R0,[R2, #+12]
   1019            
   1020            /* Enable the complementary PWM output  */
   1021            TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_ENABLE);
   \   00000048   0x2004             MOVS     R0,#+4
   \   0000004A   0x4088             LSLS     R0,R0,R1
   \   0000004C   0x6A11             LDR      R1,[R2, #+32]
   \   0000004E   0x4381             BICS     R1,R1,R0
   \   00000050   0x6211             STR      R1,[R2, #+32]
   \   00000052   0x6A11             LDR      R1,[R2, #+32]
   \   00000054   0x4308             ORRS     R0,R0,R1
   \   00000056   0x6210             STR      R0,[R2, #+32]
   1022            
   1023            /* Enable the Main Output */
   1024            __HAL_TIM_MOE_ENABLE(htim);
   \   00000058   0x6C50             LDR      R0,[R2, #+68]
   \   0000005A   0xF440 0x4000      ORR      R0,R0,#0x8000
   \   0000005E   0x6450             STR      R0,[R2, #+68]
   1025            
   1026            /* Enable the Peripheral */
   1027            __HAL_TIM_ENABLE(htim);
   \   00000060   0x6810             LDR      R0,[R2, #+0]
   \   00000062   0xF040 0x0001      ORR      R0,R0,#0x1
   \   00000066   0x6010             STR      R0,[R2, #+0]
   1028            
   1029            /* Return function status */
   1030            return HAL_OK;
   \   00000068   0x2000             MOVS     R0,#+0
   \   0000006A   0x4770             BX       LR               ;; return
   1031          } 
   1032          
   1033          /**
   1034            * @brief  Stops the PWM signal generation in interrupt mode on the 
   1035            *         complementary output.
   1036            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   1037            *                the configuration information for TIM module.
   1038            * @param  Channel: TIM Channel to be disabled.
   1039            *          This parameter can be one of the following values:
   1040            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1041            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1042            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1043            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1044            * @retval HAL status
   1045            */

   \                                 In section .text, align 4, keep-with-next
   1046          HAL_StatusTypeDef HAL_TIMEx_PWMN_Stop_IT (TIM_HandleTypeDef *htim, uint32_t Channel)
   1047          {
   1048            uint32_t tmpccer = 0;
   1049            
   1050            /* Check the parameters */
   1051            assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel)); 
   1052          
   1053            switch (Channel)
   \                     HAL_TIMEx_PWMN_Stop_IT: (+1)
   \   00000000   0x290C             CMP      R1,#+12
   \   00000002   0xD81C             BHI.N    ??HAL_TIMEx_PWMN_Stop_IT_1
   \   00000004   0xE8DF 0xF001      TBB      [PC, R1]
   \                     ??HAL_TIMEx_PWMN_Stop_IT_0:
   \   00000008   0x07 0x1B          DC8      0x7,0x1B,0x1B,0x1B
   \              0x1B 0x1B    
   \   0000000C   0x0C 0x1B          DC8      0xC,0x1B,0x1B,0x1B
   \              0x1B 0x1B    
   \   00000010   0x11 0x1B          DC8      0x11,0x1B,0x1B,0x1B
   \              0x1B 0x1B    
   \   00000014   0x16 0x00          DC8      0x16,0x0
   1054            {
   1055              case TIM_CHANNEL_1:
   1056              {       
   1057                /* Disable the TIM Capture/Compare 1 interrupt */
   1058                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
   \                     ??HAL_TIMEx_PWMN_Stop_IT_2: (+1)
   \   00000016   0x6802             LDR      R2,[R0, #+0]
   \   00000018   0x68D3             LDR      R3,[R2, #+12]
   \   0000001A   0xF023 0x0302      BIC      R3,R3,#0x2
   \   0000001E   0xE00D             B.N      ??HAL_TIMEx_PWMN_Stop_IT_3
   1059              }
   1060              break;
   1061              
   1062              case TIM_CHANNEL_2:
   1063              {
   1064                /* Disable the TIM Capture/Compare 2 interrupt */
   1065                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
   \                     ??HAL_TIMEx_PWMN_Stop_IT_4: (+1)
   \   00000020   0x6802             LDR      R2,[R0, #+0]
   \   00000022   0x68D3             LDR      R3,[R2, #+12]
   \   00000024   0xF023 0x0304      BIC      R3,R3,#0x4
   \   00000028   0xE008             B.N      ??HAL_TIMEx_PWMN_Stop_IT_3
   1066              }
   1067              break;
   1068              
   1069              case TIM_CHANNEL_3:
   1070              {
   1071                /* Disable the TIM Capture/Compare 3 interrupt */
   1072                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);
   \                     ??HAL_TIMEx_PWMN_Stop_IT_5: (+1)
   \   0000002A   0x6802             LDR      R2,[R0, #+0]
   \   0000002C   0x68D3             LDR      R3,[R2, #+12]
   \   0000002E   0xF023 0x0308      BIC      R3,R3,#0x8
   \   00000032   0xE003             B.N      ??HAL_TIMEx_PWMN_Stop_IT_3
   1073              }
   1074              break;
   1075              
   1076              case TIM_CHANNEL_4:
   1077              {
   1078                /* Disable the TIM Capture/Compare 3 interrupt */
   1079                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC4);
   \                     ??HAL_TIMEx_PWMN_Stop_IT_6: (+1)
   \   00000034   0x6802             LDR      R2,[R0, #+0]
   \   00000036   0x68D3             LDR      R3,[R2, #+12]
   \   00000038   0xF023 0x0310      BIC      R3,R3,#0x10
   \                     ??HAL_TIMEx_PWMN_Stop_IT_3: (+1)
   \   0000003C   0x60D3             STR      R3,[R2, #+12]
   1080              }
   1081              break;
   1082              
   1083              default:
   1084              break; 
   1085            }
   1086            
   1087            /* Disable the complementary PWM output  */
   1088            TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_DISABLE);
   \                     ??HAL_TIMEx_PWMN_Stop_IT_1: (+1)
   \   0000003E   0x6802             LDR      R2,[R0, #+0]
   \   00000040   0x2304             MOVS     R3,#+4
   \   00000042   0xFA03 0xF101      LSL      R1,R3,R1
   \   00000046   0x6A10             LDR      R0,[R2, #+32]
   \   00000048   0x4388             BICS     R0,R0,R1
   1089            
   1090            /* Disable the TIM Break interrupt (only if no more channel is active) */
   1091            tmpccer = htim->Instance->CCER;
   1092            if ((tmpccer & (TIM_CCER_CC1NE | TIM_CCER_CC2NE | TIM_CCER_CC3NE)) == RESET)
   \   0000004A   0xF240 0x4144      MOVW     R1,#+1092
   \   0000004E   0x6210             STR      R0,[R2, #+32]
   \   00000050   0x6A10             LDR      R0,[R2, #+32]
   \   00000052   0x6210             STR      R0,[R2, #+32]
   \   00000054   0x6A10             LDR      R0,[R2, #+32]
   \   00000056   0x4208             TST      R0,R1
   \   00000058   0xD103             BNE.N    ??HAL_TIMEx_PWMN_Stop_IT_7
   1093            {
   1094              __HAL_TIM_DISABLE_IT(htim, TIM_IT_BREAK);
   \   0000005A   0x68D0             LDR      R0,[R2, #+12]
   \   0000005C   0xF020 0x0080      BIC      R0,R0,#0x80
   \   00000060   0x60D0             STR      R0,[R2, #+12]
   1095            }
   1096            
   1097            /* Disable the Main Output */
   1098            __HAL_TIM_MOE_DISABLE(htim);
   \                     ??HAL_TIMEx_PWMN_Stop_IT_7: (+1)
   \   00000062   0x6A13             LDR      R3,[R2, #+32]
   \   00000064   0xF241 0x1011      MOVW     R0,#+4369
   \   00000068   0x4203             TST      R3,R0
   \   0000006A   0xBF04             ITT      EQ 
   \   0000006C   0x6A13             LDREQ    R3,[R2, #+32]
   \   0000006E   0x420B             TSTEQ    R3,R1
   \   00000070   0xD103             BNE.N    ??HAL_TIMEx_PWMN_Stop_IT_8
   \   00000072   0x6C53             LDR      R3,[R2, #+68]
   \   00000074   0xF423 0x4300      BIC      R3,R3,#0x8000
   \   00000078   0x6453             STR      R3,[R2, #+68]
   1099            
   1100            /* Disable the Peripheral */
   1101            __HAL_TIM_DISABLE(htim);
   \                     ??HAL_TIMEx_PWMN_Stop_IT_8: (+1)
   \   0000007A   0x6A13             LDR      R3,[R2, #+32]
   \   0000007C   0x4203             TST      R3,R0
   \   0000007E   0xBF04             ITT      EQ 
   \   00000080   0x6A10             LDREQ    R0,[R2, #+32]
   \   00000082   0x4208             TSTEQ    R0,R1
   \   00000084   0xD103             BNE.N    ??HAL_TIMEx_PWMN_Stop_IT_9
   \   00000086   0x6810             LDR      R0,[R2, #+0]
   \   00000088   0x0840             LSRS     R0,R0,#+1
   \   0000008A   0x0040             LSLS     R0,R0,#+1
   \   0000008C   0x6010             STR      R0,[R2, #+0]
   1102            
   1103            /* Return function status */
   1104            return HAL_OK;
   \                     ??HAL_TIMEx_PWMN_Stop_IT_9: (+1)
   \   0000008E   0x2000             MOVS     R0,#+0
   \   00000090   0x4770             BX       LR               ;; return
   1105          } 
   1106          
   1107          /**
   1108            * @brief  Starts the TIM PWM signal generation in DMA mode on the 
   1109            *         complementary output
   1110            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   1111            *                the configuration information for TIM module.
   1112            * @param  Channel: TIM Channel to be enabled.
   1113            *          This parameter can be one of the following values:
   1114            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1115            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1116            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1117            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1118            * @param  pData: The source Buffer address.
   1119            * @param  Length: The length of data to be transferred from memory to TIM peripheral
   1120            * @retval HAL status
   1121            */

   \                                 In section .text, align 4, keep-with-next
   1122          HAL_StatusTypeDef HAL_TIMEx_PWMN_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData, uint16_t Length)
   1123          {
   \                     HAL_TIMEx_PWMN_Start_DMA: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0xB081             SUB      SP,SP,#+4
   \   00000006   0x460D             MOV      R5,R1
   \   00000008   0x4611             MOV      R1,R2
   1124            /* Check the parameters */
   1125            assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel)); 
   1126            
   1127            if((htim->State == HAL_TIM_STATE_BUSY))
   \   0000000A   0xF894 0x0039      LDRB     R0,[R4, #+57]
   \   0000000E   0x2802             CMP      R0,#+2
   \   00000010   0xD074             BEQ.N    ??HAL_TIMEx_PWMN_Start_DMA_1
   1128            {
   1129               return HAL_BUSY;
   1130            }
   1131            else if((htim->State == HAL_TIM_STATE_READY))
   \   00000012   0xF894 0x0039      LDRB     R0,[R4, #+57]
   \   00000016   0x2801             CMP      R0,#+1
   \   00000018   0xD105             BNE.N    ??HAL_TIMEx_PWMN_Start_DMA_2
   1132            {
   1133              if(((uint32_t)pData == 0 ) && (Length > 0)) 
   \   0000001A   0xB909             CBNZ.N   R1,??HAL_TIMEx_PWMN_Start_DMA_3
   \   0000001C   0x2B00             CMP      R3,#+0
   \   0000001E   0xD16D             BNE.N    ??HAL_TIMEx_PWMN_Start_DMA_1
   1134              {
   1135                return HAL_ERROR;                                    
   1136              }
   1137              else
   1138              {
   1139                htim->State = HAL_TIM_STATE_BUSY;
   \                     ??HAL_TIMEx_PWMN_Start_DMA_3: (+1)
   \   00000020   0x2002             MOVS     R0,#+2
   \   00000022   0xF884 0x0039      STRB     R0,[R4, #+57]
   1140              }
   1141            }    
   1142            switch (Channel)
   \                     ??HAL_TIMEx_PWMN_Start_DMA_2: (+1)
   \   00000026   0x2D0C             CMP      R5,#+12
   \   00000028   0xD854             BHI.N    ??HAL_TIMEx_PWMN_Start_DMA_4
   \   0000002A   0xE8DF 0xF005      TBB      [PC, R5]
   \                     ??HAL_TIMEx_PWMN_Start_DMA_0:
   \   0000002E   0x07 0x53          DC8      0x7,0x53,0x53,0x53
   \              0x53 0x53    
   \   00000032   0x1A 0x53          DC8      0x1A,0x53,0x53,0x53
   \              0x53 0x53    
   \   00000036   0x2D 0x53          DC8      0x2D,0x53,0x53,0x53
   \              0x53 0x53    
   \   0000003A   0x40 0x00          DC8      0x40,0x0
   1143            {
   1144              case TIM_CHANNEL_1:
   1145              {      
   1146                /* Set the DMA Period elapsed callback */
   1147                htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = HAL_TIM_DMADelayPulseCplt;
   \                     ??HAL_TIMEx_PWMN_Start_DMA_5: (+1)
   \   0000003C   0x6A22             LDR      R2,[R4, #+32]
   \   0000003E   0x.... 0x....      LDR.W    R0,??DataTable7_2
   \   00000042   0x63D0             STR      R0,[R2, #+60]
   1148               
   1149                /* Set the DMA error callback */
   1150                htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = HAL_TIM_DMAError ;
   \   00000044   0x6A22             LDR      R2,[R4, #+32]
   \   00000046   0x.... 0x....      LDR.W    R0,??DataTable7_1
   \   0000004A   0x6490             STR      R0,[R2, #+72]
   1151                
   1152                /* Enable the DMA Stream */
   1153                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)pData, (uint32_t)&htim->Instance->CCR1, Length);
   \   0000004C   0x6820             LDR      R0,[R4, #+0]
   \   0000004E   0xF100 0x0234      ADD      R2,R0,#+52
   \   00000052   0x6A20             LDR      R0,[R4, #+32]
   \   00000054   0x.... 0x....      BL       HAL_DMA_Start_IT
   1154                
   1155                /* Enable the TIM Capture/Compare 1 DMA request */
   1156                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
   \   00000058   0x6820             LDR      R0,[R4, #+0]
   \   0000005A   0x68C1             LDR      R1,[R0, #+12]
   \   0000005C   0xF441 0x7100      ORR      R1,R1,#0x200
   \   00000060   0xE037             B.N      ??HAL_TIMEx_PWMN_Start_DMA_6
   1157              }
   1158              break;
   1159              
   1160              case TIM_CHANNEL_2:
   1161              {
   1162                /* Set the DMA Period elapsed callback */
   1163                htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = HAL_TIM_DMADelayPulseCplt;
   \                     ??HAL_TIMEx_PWMN_Start_DMA_7: (+1)
   \   00000062   0x6A62             LDR      R2,[R4, #+36]
   \   00000064   0x.... 0x....      LDR.W    R0,??DataTable7_2
   \   00000068   0x63D0             STR      R0,[R2, #+60]
   1164               
   1165                /* Set the DMA error callback */
   1166                htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = HAL_TIM_DMAError ;
   \   0000006A   0x6A62             LDR      R2,[R4, #+36]
   \   0000006C   0x.... 0x....      LDR.W    R0,??DataTable7_1
   \   00000070   0x6490             STR      R0,[R2, #+72]
   1167                
   1168                /* Enable the DMA Stream */
   1169                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)pData, (uint32_t)&htim->Instance->CCR2, Length);
   \   00000072   0x6820             LDR      R0,[R4, #+0]
   \   00000074   0xF100 0x0238      ADD      R2,R0,#+56
   \   00000078   0x6A60             LDR      R0,[R4, #+36]
   \   0000007A   0x.... 0x....      BL       HAL_DMA_Start_IT
   1170                
   1171                /* Enable the TIM Capture/Compare 2 DMA request */
   1172                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
   \   0000007E   0x6820             LDR      R0,[R4, #+0]
   \   00000080   0x68C1             LDR      R1,[R0, #+12]
   \   00000082   0xF441 0x6180      ORR      R1,R1,#0x400
   \   00000086   0xE024             B.N      ??HAL_TIMEx_PWMN_Start_DMA_6
   1173              }
   1174              break;
   1175              
   1176              case TIM_CHANNEL_3:
   1177              {
   1178                /* Set the DMA Period elapsed callback */
   1179                htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = HAL_TIM_DMADelayPulseCplt;
   \                     ??HAL_TIMEx_PWMN_Start_DMA_8: (+1)
   \   00000088   0x6AA2             LDR      R2,[R4, #+40]
   \   0000008A   0x.... 0x....      LDR.W    R0,??DataTable7_2
   \   0000008E   0x63D0             STR      R0,[R2, #+60]
   1180               
   1181                /* Set the DMA error callback */
   1182                htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = HAL_TIM_DMAError ;
   \   00000090   0x6AA2             LDR      R2,[R4, #+40]
   \   00000092   0x.... 0x....      LDR.W    R0,??DataTable7_1
   \   00000096   0x6490             STR      R0,[R2, #+72]
   1183                
   1184                /* Enable the DMA Stream */
   1185                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)pData, (uint32_t)&htim->Instance->CCR3,Length);
   \   00000098   0x6820             LDR      R0,[R4, #+0]
   \   0000009A   0xF100 0x023C      ADD      R2,R0,#+60
   \   0000009E   0x6AA0             LDR      R0,[R4, #+40]
   \   000000A0   0x.... 0x....      BL       HAL_DMA_Start_IT
   1186                
   1187                /* Enable the TIM Capture/Compare 3 DMA request */
   1188                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);
   \   000000A4   0x6820             LDR      R0,[R4, #+0]
   \   000000A6   0x68C1             LDR      R1,[R0, #+12]
   \   000000A8   0xF441 0x6100      ORR      R1,R1,#0x800
   \   000000AC   0xE011             B.N      ??HAL_TIMEx_PWMN_Start_DMA_6
   1189              }
   1190              break;
   1191              
   1192              case TIM_CHANNEL_4:
   1193              {
   1194               /* Set the DMA Period elapsed callback */
   1195                htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = HAL_TIM_DMADelayPulseCplt;
   \                     ??HAL_TIMEx_PWMN_Start_DMA_9: (+1)
   \   000000AE   0x6AE2             LDR      R2,[R4, #+44]
   \   000000B0   0x.... 0x....      LDR.W    R0,??DataTable7_2
   \   000000B4   0x63D0             STR      R0,[R2, #+60]
   1196               
   1197                /* Set the DMA error callback */
   1198                htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = HAL_TIM_DMAError ;
   \   000000B6   0x6AE2             LDR      R2,[R4, #+44]
   \   000000B8   0x.... 0x....      LDR.W    R0,??DataTable7_1
   \   000000BC   0x6490             STR      R0,[R2, #+72]
   1199                
   1200                /* Enable the DMA Stream */
   1201                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)pData, (uint32_t)&htim->Instance->CCR4, Length);
   \   000000BE   0x6820             LDR      R0,[R4, #+0]
   \   000000C0   0xF100 0x0240      ADD      R2,R0,#+64
   \   000000C4   0x6AE0             LDR      R0,[R4, #+44]
   \   000000C6   0x.... 0x....      BL       HAL_DMA_Start_IT
   1202                
   1203                /* Enable the TIM Capture/Compare 4 DMA request */
   1204                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC4);
   \   000000CA   0x6820             LDR      R0,[R4, #+0]
   \   000000CC   0x68C1             LDR      R1,[R0, #+12]
   \   000000CE   0xF441 0x5180      ORR      R1,R1,#0x1000
   \                     ??HAL_TIMEx_PWMN_Start_DMA_6: (+1)
   \   000000D2   0x60C1             STR      R1,[R0, #+12]
   1205              }
   1206              break;
   1207              
   1208              default:
   1209              break;
   1210            }
   1211          
   1212            /* Enable the complementary PWM output  */
   1213               TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_ENABLE);
   \                     ??HAL_TIMEx_PWMN_Start_DMA_4: (+1)
   \   000000D4   0x6820             LDR      R0,[R4, #+0]
   \   000000D6   0x2104             MOVS     R1,#+4
   \   000000D8   0x40A9             LSLS     R1,R1,R5
   \   000000DA   0x6A02             LDR      R2,[R0, #+32]
   \   000000DC   0x438A             BICS     R2,R2,R1
   \   000000DE   0x6202             STR      R2,[R0, #+32]
   \   000000E0   0x6A02             LDR      R2,[R0, #+32]
   \   000000E2   0x4311             ORRS     R1,R1,R2
   \   000000E4   0x6201             STR      R1,[R0, #+32]
   1214              
   1215            /* Enable the Main Output */
   1216              __HAL_TIM_MOE_ENABLE(htim);
   \   000000E6   0x6820             LDR      R0,[R4, #+0]
   \   000000E8   0x6C41             LDR      R1,[R0, #+68]
   \   000000EA   0xF441 0x4100      ORR      R1,R1,#0x8000
   \   000000EE   0x6441             STR      R1,[R0, #+68]
   1217            
   1218            /* Enable the Peripheral */
   1219            __HAL_TIM_ENABLE(htim); 
   \   000000F0   0x6820             LDR      R0,[R4, #+0]
   \   000000F2   0x6801             LDR      R1,[R0, #+0]
   \   000000F4   0xF041 0x0101      ORR      R1,R1,#0x1
   \   000000F8   0x6001             STR      R1,[R0, #+0]
   1220            
   1221            /* Return function status */
   1222            return HAL_OK;
   \   000000FA   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIMEx_PWMN_Start_DMA_1: (+1)
   \   000000FC   0xB001             ADD      SP,SP,#+4
   \   000000FE   0xBD30             POP      {R4,R5,PC}       ;; return
   1223          }
   1224          
   1225          /**
   1226            * @brief  Stops the TIM PWM signal generation in DMA mode on the complementary
   1227            *         output
   1228            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   1229            *                the configuration information for TIM module.
   1230            * @param  Channel: TIM Channel to be disabled.
   1231            *          This parameter can be one of the following values:
   1232            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1233            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1234            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1235            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1236            * @retval HAL status
   1237            */

   \                                 In section .text, align 4, keep-with-next
   1238          HAL_StatusTypeDef HAL_TIMEx_PWMN_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
   1239          {
   1240            /* Check the parameters */
   1241            assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel)); 
   1242            
   1243            switch (Channel)
   \                     HAL_TIMEx_PWMN_Stop_DMA: (+1)
   \   00000000   0x290C             CMP      R1,#+12
   \   00000002   0xB410             PUSH     {R4}
   \   00000004   0xD81C             BHI.N    ??HAL_TIMEx_PWMN_Stop_DMA_1
   \   00000006   0xE8DF 0xF001      TBB      [PC, R1]
   \                     ??HAL_TIMEx_PWMN_Stop_DMA_0:
   \   0000000A   0x07 0x1B          DC8      0x7,0x1B,0x1B,0x1B
   \              0x1B 0x1B    
   \   0000000E   0x0C 0x1B          DC8      0xC,0x1B,0x1B,0x1B
   \              0x1B 0x1B    
   \   00000012   0x11 0x1B          DC8      0x11,0x1B,0x1B,0x1B
   \              0x1B 0x1B    
   \   00000016   0x16 0x00          DC8      0x16,0x0
   1244            {
   1245              case TIM_CHANNEL_1:
   1246              {       
   1247                /* Disable the TIM Capture/Compare 1 DMA request */
   1248                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
   \                     ??HAL_TIMEx_PWMN_Stop_DMA_2: (+1)
   \   00000018   0x6802             LDR      R2,[R0, #+0]
   \   0000001A   0x68D3             LDR      R3,[R2, #+12]
   \   0000001C   0xF423 0x7300      BIC      R3,R3,#0x200
   \   00000020   0xE00D             B.N      ??HAL_TIMEx_PWMN_Stop_DMA_3
   1249              }
   1250              break;
   1251              
   1252              case TIM_CHANNEL_2:
   1253              {
   1254                /* Disable the TIM Capture/Compare 2 DMA request */
   1255                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
   \                     ??HAL_TIMEx_PWMN_Stop_DMA_4: (+1)
   \   00000022   0x6802             LDR      R2,[R0, #+0]
   \   00000024   0x68D3             LDR      R3,[R2, #+12]
   \   00000026   0xF423 0x6380      BIC      R3,R3,#0x400
   \   0000002A   0xE008             B.N      ??HAL_TIMEx_PWMN_Stop_DMA_3
   1256              }
   1257              break;
   1258              
   1259              case TIM_CHANNEL_3:
   1260              {
   1261                /* Disable the TIM Capture/Compare 3 DMA request */
   1262                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);
   \                     ??HAL_TIMEx_PWMN_Stop_DMA_5: (+1)
   \   0000002C   0x6802             LDR      R2,[R0, #+0]
   \   0000002E   0x68D3             LDR      R3,[R2, #+12]
   \   00000030   0xF423 0x6300      BIC      R3,R3,#0x800
   \   00000034   0xE003             B.N      ??HAL_TIMEx_PWMN_Stop_DMA_3
   1263              }
   1264              break;
   1265              
   1266              case TIM_CHANNEL_4:
   1267              {
   1268                /* Disable the TIM Capture/Compare 4 DMA request */
   1269                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC4);
   \                     ??HAL_TIMEx_PWMN_Stop_DMA_6: (+1)
   \   00000036   0x6802             LDR      R2,[R0, #+0]
   \   00000038   0x68D3             LDR      R3,[R2, #+12]
   \   0000003A   0xF423 0x5380      BIC      R3,R3,#0x1000
   \                     ??HAL_TIMEx_PWMN_Stop_DMA_3: (+1)
   \   0000003E   0x60D3             STR      R3,[R2, #+12]
   1270              }
   1271              break;
   1272              
   1273              default:
   1274              break;
   1275            } 
   1276            
   1277            /* Disable the complementary PWM output */
   1278              TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_DISABLE);
   \                     ??HAL_TIMEx_PWMN_Stop_DMA_1: (+1)
   \   00000040   0x6802             LDR      R2,[R0, #+0]
   \   00000042   0x2404             MOVS     R4,#+4
   \   00000044   0xFA04 0xF101      LSL      R1,R4,R1
   \   00000048   0x6A13             LDR      R3,[R2, #+32]
   \   0000004A   0xEA23 0x0101      BIC      R1,R3,R1
   \   0000004E   0x6211             STR      R1,[R2, #+32]
   \   00000050   0x6A11             LDR      R1,[R2, #+32]
   \   00000052   0x6211             STR      R1,[R2, #+32]
   1279               
   1280            /* Disable the Main Output */
   1281              __HAL_TIM_MOE_DISABLE(htim);
   \   00000054   0x6801             LDR      R1,[R0, #+0]
   \   00000056   0xF241 0x1211      MOVW     R2,#+4369
   \   0000005A   0x6A0B             LDR      R3,[R1, #+32]
   \   0000005C   0x4213             TST      R3,R2
   \   0000005E   0xBF02             ITTT     EQ 
   \   00000060   0x6A0B             LDREQ    R3,[R1, #+32]
   \   00000062   0xF240 0x4444      MOVWEQ   R4,#+1092
   \   00000066   0x4223             TSTEQ    R3,R4
   \   00000068   0xD103             BNE.N    ??HAL_TIMEx_PWMN_Stop_DMA_7
   \   0000006A   0x6C4B             LDR      R3,[R1, #+68]
   \   0000006C   0xF423 0x4300      BIC      R3,R3,#0x8000
   \   00000070   0x644B             STR      R3,[R1, #+68]
   1282          
   1283            /* Disable the Peripheral */
   1284            __HAL_TIM_DISABLE(htim);
   \                     ??HAL_TIMEx_PWMN_Stop_DMA_7: (+1)
   \   00000072   0x6801             LDR      R1,[R0, #+0]
   \   00000074   0x6A0B             LDR      R3,[R1, #+32]
   \   00000076   0x4213             TST      R3,R2
   \   00000078   0xBF02             ITTT     EQ 
   \   0000007A   0x6A0A             LDREQ    R2,[R1, #+32]
   \   0000007C   0xF240 0x4344      MOVWEQ   R3,#+1092
   \   00000080   0x421A             TSTEQ    R2,R3
   \   00000082   0xD103             BNE.N    ??HAL_TIMEx_PWMN_Stop_DMA_8
   \   00000084   0x680A             LDR      R2,[R1, #+0]
   \   00000086   0x0852             LSRS     R2,R2,#+1
   \   00000088   0x0052             LSLS     R2,R2,#+1
   \   0000008A   0x600A             STR      R2,[R1, #+0]
   1285            
   1286            /* Change the htim state */
   1287            htim->State = HAL_TIM_STATE_READY;
   \                     ??HAL_TIMEx_PWMN_Stop_DMA_8: (+1)
   \   0000008C   0x2101             MOVS     R1,#+1
   \   0000008E   0xF880 0x1039      STRB     R1,[R0, #+57]
   1288            
   1289            /* Return function status */
   1290            return HAL_OK;
   \   00000092   0x2000             MOVS     R0,#+0
   \   00000094   0xBC10             POP      {R4}
   \   00000096   0x4770             BX       LR               ;; return
   1291          }
   1292          
   1293          /**
   1294            * @}
   1295            */
   1296            
   1297          /** @defgroup TIMEx_Exported_Functions_Group4 Extended Timer Complementary One Pulse functions
   1298           *  @brief    Timer Complementary One Pulse functions 
   1299           *
   1300          @verbatim   
   1301            ==============================================================================
   1302                          ##### Timer Complementary One Pulse functions #####
   1303            ==============================================================================  
   1304            [..]  
   1305              This section provides functions allowing to:
   1306              (+) Start the Complementary One Pulse generation.
   1307              (+) Stop the Complementary One Pulse.
   1308              (+) Start the Complementary One Pulse and enable interrupts.
   1309              (+) Stop the Complementary One Pulse and disable interrupts.
   1310                         
   1311          @endverbatim
   1312            * @{
   1313            */
   1314          
   1315          /**
   1316            * @brief  Starts the TIM One Pulse signal generation on the complemetary 
   1317            *         output.
   1318            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   1319            *                the configuration information for TIM module.
   1320            * @param  OutputChannel: TIM Channel to be enabled.
   1321            *          This parameter can be one of the following values:
   1322            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1323            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1324            * @retval HAL status
   1325            */

   \                                 In section .text, align 2, keep-with-next
   1326          HAL_StatusTypeDef HAL_TIMEx_OnePulseN_Start(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
   1327            {
   1328            /* Check the parameters */
   1329            assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, OutputChannel)); 
   1330            
   1331            /* Enable the complementary One Pulse output */
   1332            TIM_CCxNChannelCmd(htim->Instance, OutputChannel, TIM_CCxN_ENABLE); 
   \                     HAL_TIMEx_OnePulseN_Start: (+1)
   \   00000000   0x6800             LDR      R0,[R0, #+0]
   \   00000002   0x2204             MOVS     R2,#+4
   \   00000004   0xFA02 0xF101      LSL      R1,R2,R1
   \   00000008   0x6A02             LDR      R2,[R0, #+32]
   \   0000000A   0x438A             BICS     R2,R2,R1
   \   0000000C   0x6202             STR      R2,[R0, #+32]
   \   0000000E   0x6A02             LDR      R2,[R0, #+32]
   \   00000010   0x4311             ORRS     R1,R1,R2
   \   00000012   0x6201             STR      R1,[R0, #+32]
   1333            
   1334            /* Enable the Main Output */
   1335            __HAL_TIM_MOE_ENABLE(htim);
   \   00000014   0x6C41             LDR      R1,[R0, #+68]
   \   00000016   0xF441 0x4100      ORR      R1,R1,#0x8000
   \   0000001A   0x6441             STR      R1,[R0, #+68]
   1336            
   1337            /* Return function status */
   1338            return HAL_OK;
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0x4770             BX       LR               ;; return
   1339          }
   1340          
   1341          /**
   1342            * @brief  Stops the TIM One Pulse signal generation on the complementary 
   1343            *         output.
   1344            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   1345            *                the configuration information for TIM module.
   1346            * @param  OutputChannel: TIM Channel to be disabled.
   1347            *          This parameter can be one of the following values:
   1348            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1349            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1350            * @retval HAL status
   1351            */

   \                                 In section .text, align 2, keep-with-next
   1352          HAL_StatusTypeDef HAL_TIMEx_OnePulseN_Stop(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
   1353          {
   1354          
   1355            /* Check the parameters */
   1356            assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, OutputChannel)); 
   1357          
   1358            /* Disable the complementary One Pulse output */
   1359              TIM_CCxNChannelCmd(htim->Instance, OutputChannel, TIM_CCxN_DISABLE);
   \                     HAL_TIMEx_OnePulseN_Stop: (+1)
   \   00000000   0x6800             LDR      R0,[R0, #+0]
   \   00000002   0x2304             MOVS     R3,#+4
   \   00000004   0xFA03 0xF101      LSL      R1,R3,R1
   \   00000008   0x6A02             LDR      R2,[R0, #+32]
   \   0000000A   0xEA22 0x0101      BIC      R1,R2,R1
   \   0000000E   0x6201             STR      R1,[R0, #+32]
   \   00000010   0x6A01             LDR      R1,[R0, #+32]
   \   00000012   0x6201             STR      R1,[R0, #+32]
   1360            
   1361            /* Disable the Main Output */
   1362              __HAL_TIM_MOE_DISABLE(htim);
   \   00000014   0x6A02             LDR      R2,[R0, #+32]
   \   00000016   0xF241 0x1111      MOVW     R1,#+4369
   \   0000001A   0x420A             TST      R2,R1
   \   0000001C   0xBF02             ITTT     EQ 
   \   0000001E   0x6A02             LDREQ    R2,[R0, #+32]
   \   00000020   0xF240 0x4344      MOVWEQ   R3,#+1092
   \   00000024   0x421A             TSTEQ    R2,R3
   \   00000026   0xD103             BNE.N    ??HAL_TIMEx_OnePulseN_Stop_0
   \   00000028   0x6C42             LDR      R2,[R0, #+68]
   \   0000002A   0xF422 0x4200      BIC      R2,R2,#0x8000
   \   0000002E   0x6442             STR      R2,[R0, #+68]
   1363            
   1364            /* Disable the Peripheral */
   1365            __HAL_TIM_DISABLE(htim); 
   \                     ??HAL_TIMEx_OnePulseN_Stop_0: (+1)
   \   00000030   0x6A02             LDR      R2,[R0, #+32]
   \   00000032   0x420A             TST      R2,R1
   \   00000034   0xBF02             ITTT     EQ 
   \   00000036   0x6A01             LDREQ    R1,[R0, #+32]
   \   00000038   0xF240 0x4244      MOVWEQ   R2,#+1092
   \   0000003C   0x4211             TSTEQ    R1,R2
   \   0000003E   0xD103             BNE.N    ??HAL_TIMEx_OnePulseN_Stop_1
   \   00000040   0x6801             LDR      R1,[R0, #+0]
   \   00000042   0x0849             LSRS     R1,R1,#+1
   \   00000044   0x0049             LSLS     R1,R1,#+1
   \   00000046   0x6001             STR      R1,[R0, #+0]
   1366             
   1367            /* Return function status */
   1368            return HAL_OK;
   \                     ??HAL_TIMEx_OnePulseN_Stop_1: (+1)
   \   00000048   0x2000             MOVS     R0,#+0
   \   0000004A   0x4770             BX       LR               ;; return
   1369          }
   1370          
   1371          /**
   1372            * @brief  Starts the TIM One Pulse signal generation in interrupt mode on the
   1373            *         complementary channel.
   1374            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   1375            *                the configuration information for TIM module.
   1376            * @param  OutputChannel: TIM Channel to be enabled.
   1377            *          This parameter can be one of the following values:
   1378            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1379            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1380            * @retval HAL status
   1381            */

   \                                 In section .text, align 2, keep-with-next
   1382          HAL_StatusTypeDef HAL_TIMEx_OnePulseN_Start_IT(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
   1383          {
   1384            /* Check the parameters */
   1385            assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, OutputChannel)); 
   1386          
   1387            /* Enable the TIM Capture/Compare 1 interrupt */
   1388            __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
   \                     HAL_TIMEx_OnePulseN_Start_IT: (+1)
   \   00000000   0x6800             LDR      R0,[R0, #+0]
   \   00000002   0x68C2             LDR      R2,[R0, #+12]
   \   00000004   0xF042 0x0202      ORR      R2,R2,#0x2
   \   00000008   0x60C2             STR      R2,[R0, #+12]
   1389            
   1390            /* Enable the TIM Capture/Compare 2 interrupt */
   1391            __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
   \   0000000A   0x68C2             LDR      R2,[R0, #+12]
   \   0000000C   0xF042 0x0204      ORR      R2,R2,#0x4
   \   00000010   0x60C2             STR      R2,[R0, #+12]
   1392            
   1393            /* Enable the complementary One Pulse output */
   1394            TIM_CCxNChannelCmd(htim->Instance, OutputChannel, TIM_CCxN_ENABLE); 
   \   00000012   0x2204             MOVS     R2,#+4
   \   00000014   0xFA02 0xF101      LSL      R1,R2,R1
   \   00000018   0x6A02             LDR      R2,[R0, #+32]
   \   0000001A   0x438A             BICS     R2,R2,R1
   \   0000001C   0x6202             STR      R2,[R0, #+32]
   \   0000001E   0x6A02             LDR      R2,[R0, #+32]
   \   00000020   0x4311             ORRS     R1,R1,R2
   \   00000022   0x6201             STR      R1,[R0, #+32]
   1395            
   1396            /* Enable the Main Output */
   1397            __HAL_TIM_MOE_ENABLE(htim);
   \   00000024   0x6C41             LDR      R1,[R0, #+68]
   \   00000026   0xF441 0x4100      ORR      R1,R1,#0x8000
   \   0000002A   0x6441             STR      R1,[R0, #+68]
   1398            
   1399            /* Return function status */
   1400            return HAL_OK;
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0x4770             BX       LR               ;; return
   1401            } 
   1402            
   1403          /**
   1404            * @brief  Stops the TIM One Pulse signal generation in interrupt mode on the
   1405            *         complementary channel.
   1406            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   1407            *                the configuration information for TIM module.
   1408            * @param  OutputChannel: TIM Channel to be disabled.
   1409            *          This parameter can be one of the following values:
   1410            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1411            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1412            * @retval HAL status
   1413            */

   \                                 In section .text, align 2, keep-with-next
   1414          HAL_StatusTypeDef HAL_TIMEx_OnePulseN_Stop_IT(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
   1415          {
   1416            /* Check the parameters */
   1417            assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, OutputChannel)); 
   1418          
   1419            /* Disable the TIM Capture/Compare 1 interrupt */
   1420            __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
   \                     HAL_TIMEx_OnePulseN_Stop_IT: (+1)
   \   00000000   0x6800             LDR      R0,[R0, #+0]
   1421            
   1422            /* Disable the TIM Capture/Compare 2 interrupt */
   1423            __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
   1424            
   1425            /* Disable the complementary One Pulse output */
   1426            TIM_CCxNChannelCmd(htim->Instance, OutputChannel, TIM_CCxN_DISABLE);
   \   00000002   0x2304             MOVS     R3,#+4
   \   00000004   0xFA03 0xF101      LSL      R1,R3,R1
   \   00000008   0x68C2             LDR      R2,[R0, #+12]
   \   0000000A   0xF022 0x0202      BIC      R2,R2,#0x2
   \   0000000E   0x60C2             STR      R2,[R0, #+12]
   \   00000010   0x68C2             LDR      R2,[R0, #+12]
   \   00000012   0xF022 0x0204      BIC      R2,R2,#0x4
   \   00000016   0x60C2             STR      R2,[R0, #+12]
   \   00000018   0x6A02             LDR      R2,[R0, #+32]
   \   0000001A   0xEA22 0x0101      BIC      R1,R2,R1
   \   0000001E   0x6201             STR      R1,[R0, #+32]
   \   00000020   0x6A01             LDR      R1,[R0, #+32]
   \   00000022   0x6201             STR      R1,[R0, #+32]
   1427            
   1428            /* Disable the Main Output */
   1429            __HAL_TIM_MOE_DISABLE(htim);
   \   00000024   0x6A02             LDR      R2,[R0, #+32]
   \   00000026   0xF241 0x1111      MOVW     R1,#+4369
   \   0000002A   0x420A             TST      R2,R1
   \   0000002C   0xBF02             ITTT     EQ 
   \   0000002E   0x6A02             LDREQ    R2,[R0, #+32]
   \   00000030   0xF240 0x4344      MOVWEQ   R3,#+1092
   \   00000034   0x421A             TSTEQ    R2,R3
   \   00000036   0xD103             BNE.N    ??HAL_TIMEx_OnePulseN_Stop_IT_0
   \   00000038   0x6C42             LDR      R2,[R0, #+68]
   \   0000003A   0xF422 0x4200      BIC      R2,R2,#0x8000
   \   0000003E   0x6442             STR      R2,[R0, #+68]
   1430            
   1431            /* Disable the Peripheral */
   1432             __HAL_TIM_DISABLE(htim);  
   \                     ??HAL_TIMEx_OnePulseN_Stop_IT_0: (+1)
   \   00000040   0x6A02             LDR      R2,[R0, #+32]
   \   00000042   0x420A             TST      R2,R1
   \   00000044   0xBF02             ITTT     EQ 
   \   00000046   0x6A01             LDREQ    R1,[R0, #+32]
   \   00000048   0xF240 0x4244      MOVWEQ   R2,#+1092
   \   0000004C   0x4211             TSTEQ    R1,R2
   \   0000004E   0xD103             BNE.N    ??HAL_TIMEx_OnePulseN_Stop_IT_1
   \   00000050   0x6801             LDR      R1,[R0, #+0]
   \   00000052   0x0849             LSRS     R1,R1,#+1
   \   00000054   0x0049             LSLS     R1,R1,#+1
   \   00000056   0x6001             STR      R1,[R0, #+0]
   1433            
   1434            /* Return function status */
   1435            return HAL_OK;
   \                     ??HAL_TIMEx_OnePulseN_Stop_IT_1: (+1)
   \   00000058   0x2000             MOVS     R0,#+0
   \   0000005A   0x4770             BX       LR               ;; return
   1436          }
   1437          
   1438          /**
   1439            * @}
   1440            */
   1441            
   1442          /** @defgroup TIMEx_Exported_Functions_Group5 Extended Peripheral Control functions
   1443           *  @brief   	Peripheral Control functions 
   1444           *
   1445          @verbatim   
   1446            ==============================================================================
   1447                              ##### Peripheral Control functions #####
   1448            ==============================================================================  
   1449            [..]  
   1450              This section provides functions allowing to:
   1451              (+) Configure The Input Output channels for OC, PWM, IC or One Pulse mode. 
   1452              (+) Configure External Clock source.
   1453              (+) Configure Complementary channels, break features and dead time.
   1454              (+) Configure Master and the Slave synchronization.
   1455              (+) Configure the commutation event in case of use of the Hall sensor interface.
   1456              (+) Configure the DMA Burst Mode.
   1457                
   1458          @endverbatim
   1459            * @{
   1460            */
   1461          /**
   1462            * @brief  Configure the TIM commutation event sequence.
   1463            * @note  This function is mandatory to use the commutation event in order to 
   1464            *        update the configuration at each commutation detection on the TRGI input of the Timer,
   1465            *        the typical use of this feature is with the use of another Timer(interface Timer) 
   1466            *        configured in Hall sensor interface, this interface Timer will generate the 
   1467            *        commutation at its TRGO output (connected to Timer used in this function) each time 
   1468            *        the TI1 of the Interface Timer detect a commutation at its input TI1.
   1469            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   1470            *                the configuration information for TIM module.
   1471            * @param  InputTrigger: the Internal trigger corresponding to the Timer Interfacing with the Hall sensor.
   1472            *          This parameter can be one of the following values:
   1473            *            @arg TIM_TS_ITR0: Internal trigger 0 selected
   1474            *            @arg TIM_TS_ITR1: Internal trigger 1 selected
   1475            *            @arg TIM_TS_ITR2: Internal trigger 2 selected
   1476            *            @arg TIM_TS_ITR3: Internal trigger 3 selected
   1477            *            @arg TIM_TS_NONE: No trigger is needed 
   1478            * @param  CommutationSource: the Commutation Event source.
   1479            *          This parameter can be one of the following values:
   1480            *            @arg TIM_COMMUTATION_TRGI: Commutation source is the TRGI of the Interface Timer
   1481            *            @arg TIM_COMMUTATION_SOFTWARE:  Commutation source is set by software using the COMG bit
   1482            * @retval HAL status
   1483            */

   \                                 In section .text, align 2, keep-with-next
   1484          HAL_StatusTypeDef HAL_TIMEx_ConfigCommutationEvent(TIM_HandleTypeDef *htim, uint32_t  InputTrigger, uint32_t  CommutationSource)
   1485          {
   1486            /* Check the parameters */
   1487            assert_param(IS_TIM_ADVANCED_INSTANCE(htim->Instance));
   1488            assert_param(IS_TIM_INTERNAL_TRIGGEREVENT_SELECTION(InputTrigger));
   1489            
   1490            __HAL_LOCK(htim);
   \                     HAL_TIMEx_ConfigCommutationEvent: (+1)
   \   00000000   0xF890 0x3038      LDRB     R3,[R0, #+56]
   \   00000004   0x2B01             CMP      R3,#+1
   \   00000006   0xD101             BNE.N    ??HAL_TIMEx_ConfigCommutationEvent_0
   \   00000008   0x2002             MOVS     R0,#+2
   \   0000000A   0x4770             BX       LR
   \                     ??HAL_TIMEx_ConfigCommutationEvent_0: (+1)
   \   0000000C   0x2301             MOVS     R3,#+1
   1491            
   1492            if ((InputTrigger == TIM_TS_ITR0) || (InputTrigger == TIM_TS_ITR1) ||
   1493                (InputTrigger == TIM_TS_ITR2) || (InputTrigger == TIM_TS_ITR3))
   \   0000000E   0x2900             CMP      R1,#+0
   \   00000010   0xF880 0x3038      STRB     R3,[R0, #+56]
   \   00000014   0xBF18             IT       NE 
   \   00000016   0x2910             CMPNE    R1,#+16
   \   00000018   0xD003             BEQ.N    ??HAL_TIMEx_ConfigCommutationEvent_1
   \   0000001A   0x2920             CMP      R1,#+32
   \   0000001C   0xBF18             IT       NE 
   \   0000001E   0x2930             CMPNE    R1,#+48
   \   00000020   0xD10B             BNE.N    ??HAL_TIMEx_ConfigCommutationEvent_2
   1494            {    
   1495              /* Select the Input trigger */
   1496              htim->Instance->SMCR &= ~TIM_SMCR_TS;
   \                     ??HAL_TIMEx_ConfigCommutationEvent_1: (+1)
   \   00000022   0x6803             LDR      R3,[R0, #+0]
   \   00000024   0xF8D3 0xC008      LDR      R12,[R3, #+8]
   \   00000028   0xF02C 0x0C70      BIC      R12,R12,#0x70
   \   0000002C   0xF8C3 0xC008      STR      R12,[R3, #+8]
   1497              htim->Instance->SMCR |= InputTrigger;
   \   00000030   0xF8D3 0xC008      LDR      R12,[R3, #+8]
   \   00000034   0xEA41 0x010C      ORR      R1,R1,R12
   \   00000038   0x6099             STR      R1,[R3, #+8]
   1498            }
   1499              
   1500            /* Select the Capture Compare preload feature */
   1501            htim->Instance->CR2 |= TIM_CR2_CCPC;
   \                     ??HAL_TIMEx_ConfigCommutationEvent_2: (+1)
   \   0000003A   0x6803             LDR      R3,[R0, #+0]
   \   0000003C   0x6859             LDR      R1,[R3, #+4]
   \   0000003E   0xF041 0x0101      ORR      R1,R1,#0x1
   \   00000042   0x6059             STR      R1,[R3, #+4]
   1502            /* Select the Commutation event source */
   1503            htim->Instance->CR2 &= ~TIM_CR2_CCUS;
   \   00000044   0x6859             LDR      R1,[R3, #+4]
   \   00000046   0xF021 0x0104      BIC      R1,R1,#0x4
   \   0000004A   0x6059             STR      R1,[R3, #+4]
   1504            htim->Instance->CR2 |= CommutationSource;
   \   0000004C   0x6859             LDR      R1,[R3, #+4]
   \   0000004E   0x4311             ORRS     R1,R2,R1
   \   00000050   0x6059             STR      R1,[R3, #+4]
   1505              
   1506            __HAL_UNLOCK(htim);
   \   00000052   0x2100             MOVS     R1,#+0
   \   00000054   0xF880 0x1038      STRB     R1,[R0, #+56]
   1507            
   1508            return HAL_OK;
   \   00000058   0x2000             MOVS     R0,#+0
   \   0000005A   0x4770             BX       LR               ;; return
   1509          }
   1510          
   1511          /**
   1512            * @brief  Configure the TIM commutation event sequence with interrupt.
   1513            * @note  This function is mandatory to use the commutation event in order to 
   1514            *        update the configuration at each commutation detection on the TRGI input of the Timer,
   1515            *        the typical use of this feature is with the use of another Timer(interface Timer) 
   1516            *        configured in Hall sensor interface, this interface Timer will generate the 
   1517            *        commutation at its TRGO output (connected to Timer used in this function) each time 
   1518            *        the TI1 of the Interface Timer detect a commutation at its input TI1.
   1519            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   1520            *                the configuration information for TIM module.
   1521            * @param  InputTrigger: the Internal trigger corresponding to the Timer Interfacing with the Hall sensor.
   1522            *          This parameter can be one of the following values:
   1523            *            @arg TIM_TS_ITR0: Internal trigger 0 selected
   1524            *            @arg TIM_TS_ITR1: Internal trigger 1 selected
   1525            *            @arg TIM_TS_ITR2: Internal trigger 2 selected
   1526            *            @arg TIM_TS_ITR3: Internal trigger 3 selected
   1527            *            @arg TIM_TS_NONE: No trigger is needed
   1528            * @param  CommutationSource: the Commutation Event source.
   1529            *          This parameter can be one of the following values:
   1530            *            @arg TIM_COMMUTATION_TRGI: Commutation source is the TRGI of the Interface Timer
   1531            *            @arg TIM_COMMUTATION_SOFTWARE:  Commutation source is set by software using the COMG bit
   1532            * @retval HAL status
   1533            */

   \                                 In section .text, align 2, keep-with-next
   1534          HAL_StatusTypeDef HAL_TIMEx_ConfigCommutationEvent_IT(TIM_HandleTypeDef *htim, uint32_t  InputTrigger, uint32_t  CommutationSource)
   1535          {
   1536            /* Check the parameters */
   1537            assert_param(IS_TIM_ADVANCED_INSTANCE(htim->Instance));
   1538            assert_param(IS_TIM_INTERNAL_TRIGGEREVENT_SELECTION(InputTrigger));
   1539            
   1540            __HAL_LOCK(htim);
   \                     HAL_TIMEx_ConfigCommutationEvent_IT: (+1)
   \   00000000   0xF890 0x3038      LDRB     R3,[R0, #+56]
   \   00000004   0x2B01             CMP      R3,#+1
   \   00000006   0xD101             BNE.N    ??HAL_TIMEx_ConfigCommutationEvent_IT_0
   \   00000008   0x2002             MOVS     R0,#+2
   \   0000000A   0x4770             BX       LR
   \                     ??HAL_TIMEx_ConfigCommutationEvent_IT_0: (+1)
   \   0000000C   0x2301             MOVS     R3,#+1
   1541            
   1542            if ((InputTrigger == TIM_TS_ITR0) || (InputTrigger == TIM_TS_ITR1) ||
   1543                (InputTrigger == TIM_TS_ITR2) || (InputTrigger == TIM_TS_ITR3))
   \   0000000E   0x2900             CMP      R1,#+0
   \   00000010   0xF880 0x3038      STRB     R3,[R0, #+56]
   \   00000014   0xBF18             IT       NE 
   \   00000016   0x2910             CMPNE    R1,#+16
   \   00000018   0xD003             BEQ.N    ??HAL_TIMEx_ConfigCommutationEvent_IT_1
   \   0000001A   0x2920             CMP      R1,#+32
   \   0000001C   0xBF18             IT       NE 
   \   0000001E   0x2930             CMPNE    R1,#+48
   \   00000020   0xD10B             BNE.N    ??HAL_TIMEx_ConfigCommutationEvent_IT_2
   1544            {    
   1545              /* Select the Input trigger */
   1546              htim->Instance->SMCR &= ~TIM_SMCR_TS;
   \                     ??HAL_TIMEx_ConfigCommutationEvent_IT_1: (+1)
   \   00000022   0x6803             LDR      R3,[R0, #+0]
   \   00000024   0xF8D3 0xC008      LDR      R12,[R3, #+8]
   \   00000028   0xF02C 0x0C70      BIC      R12,R12,#0x70
   \   0000002C   0xF8C3 0xC008      STR      R12,[R3, #+8]
   1547              htim->Instance->SMCR |= InputTrigger;
   \   00000030   0xF8D3 0xC008      LDR      R12,[R3, #+8]
   \   00000034   0xEA41 0x010C      ORR      R1,R1,R12
   \   00000038   0x6099             STR      R1,[R3, #+8]
   1548            }
   1549            
   1550            /* Select the Capture Compare preload feature */
   1551            htim->Instance->CR2 |= TIM_CR2_CCPC;
   \                     ??HAL_TIMEx_ConfigCommutationEvent_IT_2: (+1)
   \   0000003A   0x6803             LDR      R3,[R0, #+0]
   \   0000003C   0x6859             LDR      R1,[R3, #+4]
   \   0000003E   0xF041 0x0101      ORR      R1,R1,#0x1
   \   00000042   0x6059             STR      R1,[R3, #+4]
   1552            /* Select the Commutation event source */
   1553            htim->Instance->CR2 &= ~TIM_CR2_CCUS;
   \   00000044   0x6859             LDR      R1,[R3, #+4]
   \   00000046   0xF021 0x0104      BIC      R1,R1,#0x4
   \   0000004A   0x6059             STR      R1,[R3, #+4]
   1554            htim->Instance->CR2 |= CommutationSource;
   \   0000004C   0x6859             LDR      R1,[R3, #+4]
   \   0000004E   0x4311             ORRS     R1,R2,R1
   \   00000050   0x6059             STR      R1,[R3, #+4]
   1555              
   1556            /* Enable the Commutation Interrupt Request */
   1557            __HAL_TIM_ENABLE_IT(htim, TIM_IT_COM);
   \   00000052   0x68D9             LDR      R1,[R3, #+12]
   \   00000054   0xF041 0x0120      ORR      R1,R1,#0x20
   \   00000058   0x60D9             STR      R1,[R3, #+12]
   1558          
   1559            __HAL_UNLOCK(htim);
   \   0000005A   0x2100             MOVS     R1,#+0
   \   0000005C   0xF880 0x1038      STRB     R1,[R0, #+56]
   1560            
   1561            return HAL_OK;
   \   00000060   0x2000             MOVS     R0,#+0
   \   00000062   0x4770             BX       LR               ;; return
   1562          }
   1563          
   1564          /**
   1565            * @brief  Configure the TIM commutation event sequence with DMA.
   1566            * @note  This function is mandatory to use the commutation event in order to 
   1567            *        update the configuration at each commutation detection on the TRGI input of the Timer,
   1568            *        the typical use of this feature is with the use of another Timer(interface Timer) 
   1569            *        configured in Hall sensor interface, this interface Timer will generate the 
   1570            *        commutation at its TRGO output (connected to Timer used in this function) each time 
   1571            *        the TI1 of the Interface Timer detect a commutation at its input TI1.
   1572            * @note: The user should configure the DMA in his own software, in This function only the COMDE bit is set
   1573            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   1574            *                the configuration information for TIM module.
   1575            * @param  InputTrigger: the Internal trigger corresponding to the Timer Interfacing with the Hall sensor.
   1576            *          This parameter can be one of the following values:
   1577            *            @arg TIM_TS_ITR0: Internal trigger 0 selected
   1578            *            @arg TIM_TS_ITR1: Internal trigger 1 selected
   1579            *            @arg TIM_TS_ITR2: Internal trigger 2 selected
   1580            *            @arg TIM_TS_ITR3: Internal trigger 3 selected
   1581            *            @arg TIM_TS_NONE: No trigger is needed
   1582            * @param  CommutationSource: the Commutation Event source.
   1583            *          This parameter can be one of the following values:
   1584            *            @arg TIM_COMMUTATION_TRGI: Commutation source is the TRGI of the Interface Timer
   1585            *            @arg TIM_COMMUTATION_SOFTWARE:  Commutation source is set by software using the COMG bit
   1586            * @retval HAL status
   1587            */

   \                                 In section .text, align 2, keep-with-next
   1588          HAL_StatusTypeDef HAL_TIMEx_ConfigCommutationEvent_DMA(TIM_HandleTypeDef *htim, uint32_t  InputTrigger, uint32_t  CommutationSource)
   1589          {
   1590            /* Check the parameters */
   1591            assert_param(IS_TIM_ADVANCED_INSTANCE(htim->Instance));
   1592            assert_param(IS_TIM_INTERNAL_TRIGGEREVENT_SELECTION(InputTrigger));
   1593            
   1594            __HAL_LOCK(htim);
   \                     HAL_TIMEx_ConfigCommutationEvent_DMA: (+1)
   \   00000000   0xF890 0x3038      LDRB     R3,[R0, #+56]
   \   00000004   0x2B01             CMP      R3,#+1
   \   00000006   0xD101             BNE.N    ??HAL_TIMEx_ConfigCommutationEvent_DMA_0
   \   00000008   0x2002             MOVS     R0,#+2
   \   0000000A   0x4770             BX       LR
   \                     ??HAL_TIMEx_ConfigCommutationEvent_DMA_0: (+1)
   \   0000000C   0x2301             MOVS     R3,#+1
   1595            
   1596            if ((InputTrigger == TIM_TS_ITR0) || (InputTrigger == TIM_TS_ITR1) ||
   1597                (InputTrigger == TIM_TS_ITR2) || (InputTrigger == TIM_TS_ITR3))
   \   0000000E   0x2900             CMP      R1,#+0
   \   00000010   0xF880 0x3038      STRB     R3,[R0, #+56]
   \   00000014   0xBF18             IT       NE 
   \   00000016   0x2910             CMPNE    R1,#+16
   \   00000018   0xD003             BEQ.N    ??HAL_TIMEx_ConfigCommutationEvent_DMA_1
   \   0000001A   0x2920             CMP      R1,#+32
   \   0000001C   0xBF18             IT       NE 
   \   0000001E   0x2930             CMPNE    R1,#+48
   \   00000020   0xD10B             BNE.N    ??HAL_TIMEx_ConfigCommutationEvent_DMA_2
   1598            {    
   1599              /* Select the Input trigger */
   1600              htim->Instance->SMCR &= ~TIM_SMCR_TS;
   \                     ??HAL_TIMEx_ConfigCommutationEvent_DMA_1: (+1)
   \   00000022   0x6803             LDR      R3,[R0, #+0]
   \   00000024   0xF8D3 0xC008      LDR      R12,[R3, #+8]
   \   00000028   0xF02C 0x0C70      BIC      R12,R12,#0x70
   \   0000002C   0xF8C3 0xC008      STR      R12,[R3, #+8]
   1601              htim->Instance->SMCR |= InputTrigger;
   \   00000030   0xF8D3 0xC008      LDR      R12,[R3, #+8]
   \   00000034   0xEA41 0x010C      ORR      R1,R1,R12
   \   00000038   0x6099             STR      R1,[R3, #+8]
   1602            }
   1603            
   1604            /* Select the Capture Compare preload feature */
   1605            htim->Instance->CR2 |= TIM_CR2_CCPC;
   \                     ??HAL_TIMEx_ConfigCommutationEvent_DMA_2: (+1)
   \   0000003A   0x6803             LDR      R3,[R0, #+0]
   \   0000003C   0x6859             LDR      R1,[R3, #+4]
   \   0000003E   0xF041 0x0101      ORR      R1,R1,#0x1
   \   00000042   0x6059             STR      R1,[R3, #+4]
   1606            /* Select the Commutation event source */
   1607            htim->Instance->CR2 &= ~TIM_CR2_CCUS;
   \   00000044   0x6859             LDR      R1,[R3, #+4]
   \   00000046   0xF021 0x0104      BIC      R1,R1,#0x4
   \   0000004A   0x6059             STR      R1,[R3, #+4]
   1608            htim->Instance->CR2 |= CommutationSource;
   \   0000004C   0x6859             LDR      R1,[R3, #+4]
   \   0000004E   0x4311             ORRS     R1,R2,R1
   \   00000050   0x6059             STR      R1,[R3, #+4]
   1609            
   1610            /* Enable the Commutation DMA Request */
   1611            /* Set the DMA Commutation Callback */
   1612            htim->hdma[TIM_DMA_ID_COMMUTATION]->XferCpltCallback = HAL_TIMEx_DMACommutationCplt;     
   \   00000052   0x6B02             LDR      R2,[R0, #+48]
   \   00000054   0x.... 0x....      ADR.W    R1,TIMEx_DMACommutationCplt
   \   00000058   0x63D1             STR      R1,[R2, #+60]
   1613            /* Set the DMA error callback */
   1614            htim->hdma[TIM_DMA_ID_COMMUTATION]->XferErrorCallback = HAL_TIM_DMAError;
   \   0000005A   0x6B02             LDR      R2,[R0, #+48]
   \   0000005C   0x.... 0x....      LDR.W    R1,??DataTable7_1
   \   00000060   0x6491             STR      R1,[R2, #+72]
   1615            
   1616            /* Enable the Commutation DMA Request */
   1617            __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_COM);
   \   00000062   0x68D9             LDR      R1,[R3, #+12]
   \   00000064   0xF441 0x5100      ORR      R1,R1,#0x2000
   \   00000068   0x60D9             STR      R1,[R3, #+12]
   1618          
   1619            __HAL_UNLOCK(htim);
   \   0000006A   0x2100             MOVS     R1,#+0
   \   0000006C   0xF880 0x1038      STRB     R1,[R0, #+56]
   1620            
   1621            return HAL_OK;
   \   00000070   0x2000             MOVS     R0,#+0
   \   00000072   0x4770             BX       LR               ;; return
   1622          }
   1623          
   1624          /**
   1625            * @brief  Initializes the TIM Output Compare Channels according to the specified
   1626            *         parameters in the TIM_OC_InitTypeDef.
   1627            * @param  htim: TIM Output Compare handle
   1628            * @param  sConfig: TIM Output Compare configuration structure
   1629            * @param  Channel : TIM Channels to configure
   1630            *          This parameter can be one of the following values:
   1631            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1632            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1633            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1634            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected 
   1635            *            @arg TIM_CHANNEL_5: TIM Channel 5 selected 
   1636            *            @arg TIM_CHANNEL_6: TIM Channel 6 selected 
   1637            *            @arg TIM_CHANNEL_ALL: all output channels supported by the timer instance selected
   1638            * @retval HAL status
   1639            */

   \                                 In section .text, align 4, keep-with-next
   1640          HAL_StatusTypeDef HAL_TIM_OC_ConfigChannel(TIM_HandleTypeDef *htim, TIM_OC_InitTypeDef* sConfig, uint32_t Channel)
   1641          {  
   \                     HAL_TIM_OC_ConfigChannel: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   1642            /* Check the parameters */
   1643            assert_param(IS_TIM_CHANNELS(Channel)); 
   1644            assert_param(IS_TIM_OC_MODE(sConfig->OCMode));
   1645            assert_param(IS_TIM_OC_POLARITY(sConfig->OCPolarity));
   1646            assert_param(IS_TIM_OCN_POLARITY(sConfig->OCNPolarity));
   1647            assert_param(IS_TIM_OCNIDLE_STATE(sConfig->OCNIdleState));
   1648            assert_param(IS_TIM_OCIDLE_STATE(sConfig->OCIdleState));
   1649            
   1650            /* Check input state */
   1651            __HAL_LOCK(htim); 
   \   00000004   0xF894 0x0038      LDRB     R0,[R4, #+56]
   \   00000008   0x2801             CMP      R0,#+1
   \   0000000A   0xD101             BNE.N    ??HAL_TIM_OC_ConfigChannel_1
   \   0000000C   0x2002             MOVS     R0,#+2
   \   0000000E   0xBD10             POP      {R4,PC}
   \                     ??HAL_TIM_OC_ConfigChannel_1: (+1)
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0xF884 0x0038      STRB     R0,[R4, #+56]
   1652            
   1653            htim->State = HAL_TIM_STATE_BUSY;
   \   00000016   0x2002             MOVS     R0,#+2
   1654            
   1655            switch (Channel)
   \   00000018   0x2A14             CMP      R2,#+20
   \   0000001A   0xF884 0x0039      STRB     R0,[R4, #+57]
   \   0000001E   0xD823             BHI.N    ??HAL_TIM_OC_ConfigChannel_2
   \   00000020   0xE8DF 0xF002      TBB      [PC, R2]
   \                     ??HAL_TIM_OC_ConfigChannel_0:
   \   00000024   0x0B 0x22          DC8      0xB,0x22,0x22,0x22
   \              0x22 0x22    
   \   00000028   0x0F 0x22          DC8      0xF,0x22,0x22,0x22
   \              0x22 0x22    
   \   0000002C   0x13 0x22          DC8      0x13,0x22,0x22,0x22
   \              0x22 0x22    
   \   00000030   0x17 0x22          DC8      0x17,0x22,0x22,0x22
   \              0x22 0x22    
   \   00000034   0x1B 0x22          DC8      0x1B,0x22,0x22,0x22
   \              0x22 0x22    
   \   00000038   0x1F 0x00          DC8      0x1F,0x0
   1656            {
   1657              case TIM_CHANNEL_1:
   1658              {
   1659                /* Check the parameters */
   1660                assert_param(IS_TIM_CC1_INSTANCE(htim->Instance)); 
   1661                
   1662               /* Configure the TIM Channel 1 in Output Compare */
   1663                TIM_OC1_SetConfig(htim->Instance, sConfig);
   \                     ??HAL_TIM_OC_ConfigChannel_3: (+1)
   \   0000003A   0x6820             LDR      R0,[R4, #+0]
   \   0000003C   0x.... 0x....      BL       TIM_OC1_SetConfig
   1664              }
   1665              break;
   \   00000040   0xE012             B.N      ??HAL_TIM_OC_ConfigChannel_2
   1666              
   1667              case TIM_CHANNEL_2:
   1668              {
   1669                /* Check the parameters */
   1670                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance)); 
   1671                
   1672                /* Configure the TIM Channel 2 in Output Compare */
   1673                TIM_OC2_SetConfig(htim->Instance, sConfig);
   \                     ??HAL_TIM_OC_ConfigChannel_4: (+1)
   \   00000042   0x6820             LDR      R0,[R4, #+0]
   \   00000044   0x.... 0x....      BL       TIM_OC2_SetConfig
   1674              }
   1675              break;
   \   00000048   0xE00E             B.N      ??HAL_TIM_OC_ConfigChannel_2
   1676              
   1677              case TIM_CHANNEL_3:
   1678              {
   1679                /* Check the parameters */
   1680                assert_param(IS_TIM_CC3_INSTANCE(htim->Instance)); 
   1681                
   1682                /* Configure the TIM Channel 3 in Output Compare */
   1683                TIM_OC3_SetConfig(htim->Instance, sConfig);
   \                     ??HAL_TIM_OC_ConfigChannel_5: (+1)
   \   0000004A   0x6820             LDR      R0,[R4, #+0]
   \   0000004C   0x.... 0x....      BL       TIM_OC3_SetConfig
   1684              }
   1685              break;
   \   00000050   0xE00A             B.N      ??HAL_TIM_OC_ConfigChannel_2
   1686              
   1687              case TIM_CHANNEL_4:
   1688              {
   1689                /* Check the parameters */
   1690                assert_param(IS_TIM_CC4_INSTANCE(htim->Instance)); 
   1691                
   1692                 /* Configure the TIM Channel 4 in Output Compare */
   1693                 TIM_OC4_SetConfig(htim->Instance, sConfig);
   \                     ??HAL_TIM_OC_ConfigChannel_6: (+1)
   \   00000052   0x6820             LDR      R0,[R4, #+0]
   \   00000054   0x.... 0x....      BL       TIM_OC4_SetConfig
   1694              }
   1695              break;
   \   00000058   0xE006             B.N      ??HAL_TIM_OC_ConfigChannel_2
   1696              
   1697              case TIM_CHANNEL_5:
   1698              {
   1699                /* Check the parameters */
   1700                assert_param(IS_TIM_CC5_INSTANCE(htim->Instance)); 
   1701                
   1702                 /* Configure the TIM Channel 5 in Output Compare */
   1703                 TIM_OC5_SetConfig(htim->Instance, sConfig);
   \                     ??HAL_TIM_OC_ConfigChannel_7: (+1)
   \   0000005A   0x6820             LDR      R0,[R4, #+0]
   \   0000005C   0x.... 0x....      BL       TIM_OC5_SetConfig
   1704              }
   1705              break;
   \   00000060   0xE002             B.N      ??HAL_TIM_OC_ConfigChannel_2
   1706              
   1707              case TIM_CHANNEL_6:
   1708              {
   1709                /* Check the parameters */
   1710                assert_param(IS_TIM_CC6_INSTANCE(htim->Instance)); 
   1711                
   1712                 /* Configure the TIM Channel 6 in Output Compare */
   1713                 TIM_OC6_SetConfig(htim->Instance, sConfig);
   \                     ??HAL_TIM_OC_ConfigChannel_8: (+1)
   \   00000062   0x6820             LDR      R0,[R4, #+0]
   \   00000064   0x.... 0x....      BL       TIM_OC6_SetConfig
   1714              }
   1715              break;
   1716                  
   1717              default:
   1718              break;    
   1719            }
   1720            
   1721            htim->State = HAL_TIM_STATE_READY;
   \                     ??HAL_TIM_OC_ConfigChannel_2: (+1)
   \   00000068   0x2001             MOVS     R0,#+1
   \   0000006A   0xF884 0x0039      STRB     R0,[R4, #+57]
   1722            
   1723            __HAL_UNLOCK(htim); 
   \   0000006E   0x2000             MOVS     R0,#+0
   \   00000070   0xF884 0x0038      STRB     R0,[R4, #+56]
   1724            
   1725            return HAL_OK;
   \   00000074   0xBD10             POP      {R4,PC}          ;; return
   1726          }
   1727          
   1728          /**
   1729            * @brief  Initializes the TIM PWM  channels according to the specified
   1730            *         parameters in the TIM_OC_InitTypeDef.
   1731            * @param  htim: TIM PWM handle
   1732            * @param  sConfig: TIM PWM configuration structure
   1733            * @param  Channel : TIM Channels to be configured
   1734            *          This parameter can be one of the following values:
   1735            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1736            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1737            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1738            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1739            *            @arg TIM_CHANNEL_5: TIM Channel 5 selected 
   1740            *            @arg TIM_CHANNEL_6: TIM Channel 6 selected 
   1741            *            @arg TIM_CHANNEL_ALL: all PWM channels supported by the timer instance selected
   1742            * @retval HAL status
   1743            */

   \                                 In section .text, align 4, keep-with-next
   1744          HAL_StatusTypeDef HAL_TIM_PWM_ConfigChannel(TIM_HandleTypeDef *htim, 
   1745                                                      TIM_OC_InitTypeDef* sConfig, 
   1746                                                      uint32_t Channel)
   1747          {
   \                     HAL_TIM_PWM_ConfigChannel: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0xB081             SUB      SP,SP,#+4
   \   00000006   0x460D             MOV      R5,R1
   1748            /* Check the parameters */
   1749            assert_param(IS_TIM_CHANNELS(Channel)); 
   1750            assert_param(IS_TIM_PWM_MODE(sConfig->OCMode));
   1751            assert_param(IS_TIM_OC_POLARITY(sConfig->OCPolarity));
   1752            assert_param(IS_TIM_OCN_POLARITY(sConfig->OCNPolarity));
   1753            assert_param(IS_TIM_FAST_STATE(sConfig->OCFastMode));
   1754            assert_param(IS_TIM_OCNIDLE_STATE(sConfig->OCNIdleState));
   1755            assert_param(IS_TIM_OCIDLE_STATE(sConfig->OCIdleState));
   1756            
   1757            /* Check input state */
   1758            __HAL_LOCK(htim);
   \   00000008   0xF894 0x0038      LDRB     R0,[R4, #+56]
   \   0000000C   0x2801             CMP      R0,#+1
   \   0000000E   0xBF08             IT       EQ 
   \   00000010   0x2002             MOVEQ    R0,#+2
   \   00000012   0xF000 0x808F      BEQ.W    ??HAL_TIM_PWM_ConfigChannel_1
   \   00000016   0x2001             MOVS     R0,#+1
   \   00000018   0xF884 0x0038      STRB     R0,[R4, #+56]
   1759            
   1760            htim->State = HAL_TIM_STATE_BUSY;
   \   0000001C   0x2002             MOVS     R0,#+2
   1761              
   1762            switch (Channel)
   \   0000001E   0x2A14             CMP      R2,#+20
   \   00000020   0xF884 0x0039      STRB     R0,[R4, #+57]
   \   00000024   0xF200 0x8080      BHI.W    ??HAL_TIM_PWM_ConfigChannel_2
   \   00000028   0xE8DF 0xF002      TBB      [PC, R2]
   \                     ??HAL_TIM_PWM_ConfigChannel_0:
   \   0000002C   0x0B 0x7E          DC8      0xB,0x7E,0x7E,0x7E
   \              0x7E 0x7E    
   \   00000030   0x1E 0x7E          DC8      0x1E,0x7E,0x7E,0x7E
   \              0x7E 0x7E    
   \   00000034   0x32 0x7E          DC8      0x32,0x7E,0x7E,0x7E
   \              0x7E 0x7E    
   \   00000038   0x45 0x7E          DC8      0x45,0x7E,0x7E,0x7E
   \              0x7E 0x7E    
   \   0000003C   0x59 0x7E          DC8      0x59,0x7E,0x7E,0x7E
   \              0x7E 0x7E    
   \   00000040   0x6B 0x00          DC8      0x6B,0x0
   1763            {
   1764              case TIM_CHANNEL_1:
   1765              {
   1766                /* Check the parameters */
   1767                assert_param(IS_TIM_CC1_INSTANCE(htim->Instance)); 
   1768                
   1769                /* Configure the Channel 1 in PWM mode */
   1770                TIM_OC1_SetConfig(htim->Instance, sConfig);
   \                     ??HAL_TIM_PWM_ConfigChannel_3: (+1)
   \   00000042   0x6820             LDR      R0,[R4, #+0]
   \   00000044   0x.... 0x....      BL       TIM_OC1_SetConfig
   1771                
   1772                /* Set the Preload enable bit for channel1 */
   1773                htim->Instance->CCMR1 |= TIM_CCMR1_OC1PE;
   \   00000048   0x6820             LDR      R0,[R4, #+0]
   \   0000004A   0x6981             LDR      R1,[R0, #+24]
   \   0000004C   0xF041 0x0108      ORR      R1,R1,#0x8
   \   00000050   0x6181             STR      R1,[R0, #+24]
   1774                
   1775                /* Configure the Output Fast mode */
   1776                htim->Instance->CCMR1 &= ~TIM_CCMR1_OC1FE;
   \   00000052   0x6820             LDR      R0,[R4, #+0]
   \   00000054   0x6981             LDR      R1,[R0, #+24]
   \   00000056   0xF021 0x0104      BIC      R1,R1,#0x4
   \   0000005A   0x6181             STR      R1,[R0, #+24]
   1777                htim->Instance->CCMR1 |= sConfig->OCFastMode;
   \   0000005C   0x6820             LDR      R0,[R4, #+0]
   \   0000005E   0x6981             LDR      R1,[R0, #+24]
   \   00000060   0x692A             LDR      R2,[R5, #+16]
   \   00000062   0x4311             ORRS     R1,R2,R1
   \   00000064   0x6181             STR      R1,[R0, #+24]
   1778              }
   1779              break;
   1780              
   1781              case TIM_CHANNEL_2:
   1782              {
   1783                /* Check the parameters */
   1784                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance)); 
   1785                
   1786                /* Configure the Channel 2 in PWM mode */
   1787                TIM_OC2_SetConfig(htim->Instance, sConfig);
   1788                
   1789                /* Set the Preload enable bit for channel2 */
   1790                htim->Instance->CCMR1 |= TIM_CCMR1_OC2PE;
   1791                
   1792                /* Configure the Output Fast mode */
   1793                htim->Instance->CCMR1 &= ~TIM_CCMR1_OC2FE;
   1794                htim->Instance->CCMR1 |= sConfig->OCFastMode << 8;
   1795              }
   1796              break;
   \   00000066   0xE05F             B.N      ??HAL_TIM_PWM_ConfigChannel_2
   \                     ??HAL_TIM_PWM_ConfigChannel_4: (+1)
   \   00000068   0x6820             LDR      R0,[R4, #+0]
   \   0000006A   0x.... 0x....      BL       TIM_OC2_SetConfig
   \   0000006E   0x6820             LDR      R0,[R4, #+0]
   \   00000070   0x6981             LDR      R1,[R0, #+24]
   \   00000072   0xF441 0x6100      ORR      R1,R1,#0x800
   \   00000076   0x6181             STR      R1,[R0, #+24]
   \   00000078   0x6820             LDR      R0,[R4, #+0]
   \   0000007A   0x6981             LDR      R1,[R0, #+24]
   \   0000007C   0xF421 0x6180      BIC      R1,R1,#0x400
   \   00000080   0x6181             STR      R1,[R0, #+24]
   \   00000082   0x6820             LDR      R0,[R4, #+0]
   \   00000084   0x6981             LDR      R1,[R0, #+24]
   \   00000086   0x692A             LDR      R2,[R5, #+16]
   \   00000088   0xEA41 0x2102      ORR      R1,R1,R2, LSL #+8
   \   0000008C   0x6181             STR      R1,[R0, #+24]
   \   0000008E   0xE04B             B.N      ??HAL_TIM_PWM_ConfigChannel_2
   1797              
   1798              case TIM_CHANNEL_3:
   1799              {
   1800                /* Check the parameters */
   1801                assert_param(IS_TIM_CC3_INSTANCE(htim->Instance)); 
   1802                
   1803                /* Configure the Channel 3 in PWM mode */
   1804                TIM_OC3_SetConfig(htim->Instance, sConfig);
   \                     ??HAL_TIM_PWM_ConfigChannel_5: (+1)
   \   00000090   0x6820             LDR      R0,[R4, #+0]
   \   00000092   0x.... 0x....      BL       TIM_OC3_SetConfig
   1805                
   1806                /* Set the Preload enable bit for channel3 */
   1807                htim->Instance->CCMR2 |= TIM_CCMR2_OC3PE;
   \   00000096   0x6820             LDR      R0,[R4, #+0]
   \   00000098   0x69C1             LDR      R1,[R0, #+28]
   \   0000009A   0xF041 0x0108      ORR      R1,R1,#0x8
   \   0000009E   0x61C1             STR      R1,[R0, #+28]
   1808                
   1809               /* Configure the Output Fast mode */
   1810                htim->Instance->CCMR2 &= ~TIM_CCMR2_OC3FE;
   \   000000A0   0x6820             LDR      R0,[R4, #+0]
   \   000000A2   0x69C1             LDR      R1,[R0, #+28]
   \   000000A4   0xF021 0x0104      BIC      R1,R1,#0x4
   \   000000A8   0x61C1             STR      R1,[R0, #+28]
   1811                htim->Instance->CCMR2 |= sConfig->OCFastMode;  
   \   000000AA   0x6820             LDR      R0,[R4, #+0]
   \   000000AC   0x69C1             LDR      R1,[R0, #+28]
   \   000000AE   0x692A             LDR      R2,[R5, #+16]
   \   000000B0   0x4311             ORRS     R1,R2,R1
   \   000000B2   0x61C1             STR      R1,[R0, #+28]
   1812              }
   1813              break;
   1814              
   1815              case TIM_CHANNEL_4:
   1816              {
   1817                /* Check the parameters */
   1818                assert_param(IS_TIM_CC4_INSTANCE(htim->Instance)); 
   1819                
   1820                /* Configure the Channel 4 in PWM mode */
   1821                TIM_OC4_SetConfig(htim->Instance, sConfig);
   1822                
   1823                /* Set the Preload enable bit for channel4 */
   1824                htim->Instance->CCMR2 |= TIM_CCMR2_OC4PE;
   1825                
   1826               /* Configure the Output Fast mode */
   1827                htim->Instance->CCMR2 &= ~TIM_CCMR2_OC4FE;
   1828                htim->Instance->CCMR2 |= sConfig->OCFastMode << 8;  
   1829              }
   1830              break;
   \   000000B4   0xE038             B.N      ??HAL_TIM_PWM_ConfigChannel_2
   \                     ??HAL_TIM_PWM_ConfigChannel_6: (+1)
   \   000000B6   0x6820             LDR      R0,[R4, #+0]
   \   000000B8   0x.... 0x....      BL       TIM_OC4_SetConfig
   \   000000BC   0x6820             LDR      R0,[R4, #+0]
   \   000000BE   0x69C1             LDR      R1,[R0, #+28]
   \   000000C0   0xF441 0x6100      ORR      R1,R1,#0x800
   \   000000C4   0x61C1             STR      R1,[R0, #+28]
   \   000000C6   0x6820             LDR      R0,[R4, #+0]
   \   000000C8   0x69C1             LDR      R1,[R0, #+28]
   \   000000CA   0xF421 0x6180      BIC      R1,R1,#0x400
   \   000000CE   0x61C1             STR      R1,[R0, #+28]
   \   000000D0   0x6820             LDR      R0,[R4, #+0]
   \   000000D2   0x69C1             LDR      R1,[R0, #+28]
   \   000000D4   0x692A             LDR      R2,[R5, #+16]
   \   000000D6   0xEA41 0x2102      ORR      R1,R1,R2, LSL #+8
   \   000000DA   0x61C1             STR      R1,[R0, #+28]
   \   000000DC   0xE024             B.N      ??HAL_TIM_PWM_ConfigChannel_2
   1831              
   1832              case TIM_CHANNEL_5:
   1833              {
   1834                 /* Check the parameters */
   1835                assert_param(IS_TIM_CC5_INSTANCE(htim->Instance)); 
   1836                
   1837               /* Configure the Channel 5 in PWM mode */
   1838                TIM_OC5_SetConfig(htim->Instance, sConfig);
   \                     ??HAL_TIM_PWM_ConfigChannel_7: (+1)
   \   000000DE   0x6820             LDR      R0,[R4, #+0]
   \   000000E0   0x.... 0x....      BL       TIM_OC5_SetConfig
   1839                
   1840                /* Set the Preload enable bit for channel5*/
   1841                htim->Instance->CCMR3 |= TIM_CCMR3_OC5PE;
   \   000000E4   0x6820             LDR      R0,[R4, #+0]
   \   000000E6   0x6D41             LDR      R1,[R0, #+84]
   \   000000E8   0xF041 0x0108      ORR      R1,R1,#0x8
   \   000000EC   0x6541             STR      R1,[R0, #+84]
   1842                
   1843               /* Configure the Output Fast mode */
   1844                htim->Instance->CCMR3 &= ~TIM_CCMR3_OC5FE;
   \   000000EE   0x6820             LDR      R0,[R4, #+0]
   \   000000F0   0x6D41             LDR      R1,[R0, #+84]
   \   000000F2   0xF021 0x0104      BIC      R1,R1,#0x4
   \   000000F6   0x6541             STR      R1,[R0, #+84]
   1845                htim->Instance->CCMR3 |= sConfig->OCFastMode;  
   \   000000F8   0x6820             LDR      R0,[R4, #+0]
   \   000000FA   0x6D41             LDR      R1,[R0, #+84]
   \   000000FC   0x692A             LDR      R2,[R5, #+16]
   \   000000FE   0x4311             ORRS     R1,R2,R1
   \   00000100   0xE011             B.N      ??HAL_TIM_PWM_ConfigChannel_8
   1846              }
   1847              break;
   1848              
   1849              case TIM_CHANNEL_6:
   1850              {
   1851                 /* Check the parameters */
   1852                assert_param(IS_TIM_CC6_INSTANCE(htim->Instance)); 
   1853                
   1854               /* Configure the Channel 5 in PWM mode */
   1855                TIM_OC6_SetConfig(htim->Instance, sConfig);
   \                     ??HAL_TIM_PWM_ConfigChannel_9: (+1)
   \   00000102   0x6820             LDR      R0,[R4, #+0]
   \   00000104   0x.... 0x....      BL       TIM_OC6_SetConfig
   1856                
   1857                /* Set the Preload enable bit for channel6 */
   1858                htim->Instance->CCMR3 |= TIM_CCMR3_OC6PE;
   \   00000108   0x6820             LDR      R0,[R4, #+0]
   \   0000010A   0x6D41             LDR      R1,[R0, #+84]
   \   0000010C   0xF441 0x6100      ORR      R1,R1,#0x800
   \   00000110   0x6541             STR      R1,[R0, #+84]
   1859                
   1860               /* Configure the Output Fast mode */
   1861                htim->Instance->CCMR3 &= ~TIM_CCMR3_OC6FE;
   \   00000112   0x6820             LDR      R0,[R4, #+0]
   \   00000114   0x6D41             LDR      R1,[R0, #+84]
   \   00000116   0xF421 0x6180      BIC      R1,R1,#0x400
   \   0000011A   0x6541             STR      R1,[R0, #+84]
   1862                htim->Instance->CCMR3 |= sConfig->OCFastMode << 8;  
   \   0000011C   0x6820             LDR      R0,[R4, #+0]
   \   0000011E   0x6D41             LDR      R1,[R0, #+84]
   \   00000120   0x692A             LDR      R2,[R5, #+16]
   \   00000122   0xEA41 0x2102      ORR      R1,R1,R2, LSL #+8
   \                     ??HAL_TIM_PWM_ConfigChannel_8: (+1)
   \   00000126   0x6541             STR      R1,[R0, #+84]
   1863              }
   1864              break;
   1865              
   1866              default:
   1867              break;    
   1868            }
   1869            
   1870            htim->State = HAL_TIM_STATE_READY;
   \                     ??HAL_TIM_PWM_ConfigChannel_2: (+1)
   \   00000128   0x2001             MOVS     R0,#+1
   \   0000012A   0xF884 0x0039      STRB     R0,[R4, #+57]
   1871              
   1872            __HAL_UNLOCK(htim);
   \   0000012E   0x2000             MOVS     R0,#+0
   \   00000130   0xF884 0x0038      STRB     R0,[R4, #+56]
   1873            
   1874            return HAL_OK;
   \                     ??HAL_TIM_PWM_ConfigChannel_1: (+1)
   \   00000134   0xB001             ADD      SP,SP,#+4
   \   00000136   0xBD30             POP      {R4,R5,PC}       ;; return
   1875          }
   1876          
   1877          /**
   1878            * @brief  Configures the OCRef clear feature
   1879            * @param  htim: TIM handle
   1880            * @param  sClearInputConfig: pointer to a TIM_ClearInputConfigTypeDef structure that
   1881            *         contains the OCREF clear feature and parameters for the TIM peripheral. 
   1882            * @param  Channel: specifies the TIM Channel
   1883            *          This parameter can be one of the following values:
   1884            *            @arg TIM_Channel_1: TIM Channel 1
   1885            *            @arg TIM_Channel_2: TIM Channel 2
   1886            *            @arg TIM_Channel_3: TIM Channel 3
   1887            *            @arg TIM_Channel_4: TIM Channel 4
   1888            *            @arg TIM_Channel_5: TIM Channel 5
   1889            *            @arg TIM_Channel_6: TIM Channel 6
   1890            * @retval None
   1891            */ 

   \                                 In section .text, align 4, keep-with-next
   1892          HAL_StatusTypeDef HAL_TIM_ConfigOCrefClear(TIM_HandleTypeDef *htim,
   1893                                                     TIM_ClearInputConfigTypeDef *sClearInputConfig,
   1894                                                     uint32_t Channel)
   1895          { 
   \                     HAL_TIM_ConfigOCrefClear: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x4616             MOV      R6,R2
   1896            uint32_t tmpsmcr = 0;
   1897          
   1898            /* Check the parameters */ 
   1899            assert_param(IS_TIM_OCXREF_CLEAR_INSTANCE(htim->Instance));
   1900            assert_param(IS_TIM_CLEARINPUT_SOURCE(sClearInputConfig->ClearInputSource));
   1901                                                  
   1902            /* Check input state */
   1903            __HAL_LOCK(htim);
   \   00000008   0xF894 0x0038      LDRB     R0,[R4, #+56]
   \   0000000C   0x2801             CMP      R0,#+1
   \   0000000E   0xD101             BNE.N    ??HAL_TIM_ConfigOCrefClear_1
   \   00000010   0x2002             MOVS     R0,#+2
   \   00000012   0xBD70             POP      {R4-R6,PC}
   \                     ??HAL_TIM_ConfigOCrefClear_1: (+1)
   \   00000014   0x2001             MOVS     R0,#+1
   \   00000016   0xF884 0x0038      STRB     R0,[R4, #+56]
   1904            
   1905            switch (sClearInputConfig->ClearInputSource)
   \   0000001A   0x6868             LDR      R0,[R5, #+4]
   \   0000001C   0xB118             CBZ.N    R0,??HAL_TIM_ConfigOCrefClear_2
   \   0000001E   0x2802             CMP      R0,#+2
   \   00000020   0xD004             BEQ.N    ??HAL_TIM_ConfigOCrefClear_3
   \   00000022   0xD308             BCC.N    ??HAL_TIM_ConfigOCrefClear_4
   \   00000024   0xE012             B.N      ??HAL_TIM_ConfigOCrefClear_5
   1906            {
   1907              case TIM_CLEARINPUTSOURCE_NONE:
   1908              {
   1909                /* Clear the OCREF clear selection bit */
   1910                tmpsmcr &= ~TIM_SMCR_OCCS;
   1911                
   1912                /* Clear the ETR Bits */
   1913                tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
   1914                
   1915                /* Set TIMx_SMCR */
   1916                htim->Instance->SMCR = tmpsmcr;
   \                     ??HAL_TIM_ConfigOCrefClear_2: (+1)
   \   00000026   0x6821             LDR      R1,[R4, #+0]
   \   00000028   0x6088             STR      R0,[R1, #+8]
   1917             }
   1918              break;
   \   0000002A   0xE00F             B.N      ??HAL_TIM_ConfigOCrefClear_5
   1919              
   1920              case TIM_CLEARINPUTSOURCE_OCREFCLR:
   1921              {
   1922                /* Clear the OCREF clear selection bit */
   1923                htim->Instance->SMCR &= ~TIM_SMCR_OCCS;
   \                     ??HAL_TIM_ConfigOCrefClear_3: (+1)
   \   0000002C   0x6820             LDR      R0,[R4, #+0]
   \   0000002E   0x6881             LDR      R1,[R0, #+8]
   \   00000030   0xF021 0x0108      BIC      R1,R1,#0x8
   \   00000034   0xE009             B.N      ??HAL_TIM_ConfigOCrefClear_6
   1924              }
   1925              break;
   1926              
   1927              case TIM_CLEARINPUTSOURCE_ETR:
   1928              {
   1929                /* Check the parameters */ 
   1930                assert_param(IS_TIM_CLEARINPUT_POLARITY(sClearInputConfig->ClearInputPolarity));
   1931                assert_param(IS_TIM_CLEARINPUT_PRESCALER(sClearInputConfig->ClearInputPrescaler));
   1932                assert_param(IS_TIM_CLEARINPUT_FILTER(sClearInputConfig->ClearInputFilter));
   1933                
   1934                TIM_ETR_SetConfig(htim->Instance,
   1935                                  sClearInputConfig->ClearInputPrescaler,
   1936                                  sClearInputConfig->ClearInputPolarity,
   1937                                  sClearInputConfig->ClearInputFilter);
   \                     ??HAL_TIM_ConfigOCrefClear_4: (+1)
   \   00000036   0x692B             LDR      R3,[R5, #+16]
   \   00000038   0x68AA             LDR      R2,[R5, #+8]
   \   0000003A   0x68E9             LDR      R1,[R5, #+12]
   \   0000003C   0x6820             LDR      R0,[R4, #+0]
   \   0000003E   0x.... 0x....      BL       TIM_ETR_SetConfig
   1938                
   1939                /* Set the OCREF clear selection bit */
   1940                htim->Instance->SMCR |= TIM_SMCR_OCCS;
   \   00000042   0x6820             LDR      R0,[R4, #+0]
   \   00000044   0x6881             LDR      R1,[R0, #+8]
   \   00000046   0xF041 0x0108      ORR      R1,R1,#0x8
   \                     ??HAL_TIM_ConfigOCrefClear_6: (+1)
   \   0000004A   0x6081             STR      R1,[R0, #+8]
   1941              }
   1942              break;
   1943              default:  
   1944              break;
   1945            }
   1946            
   1947            switch (Channel)
   \                     ??HAL_TIM_ConfigOCrefClear_5: (+1)
   \   0000004C   0x2E14             CMP      R6,#+20
   \   0000004E   0xD858             BHI.N    ??HAL_TIM_ConfigOCrefClear_7
   \   00000050   0xE8DF 0xF006      TBB      [PC, R6]
   \                     ??HAL_TIM_ConfigOCrefClear_0:
   \   00000054   0x0B 0x57          DC8      0xB,0x57,0x57,0x57
   \              0x57 0x57    
   \   00000058   0x19 0x57          DC8      0x19,0x57,0x57,0x57
   \              0x57 0x57    
   \   0000005C   0x27 0x57          DC8      0x27,0x57,0x57,0x57
   \              0x57 0x57    
   \   00000060   0x35 0x57          DC8      0x35,0x57,0x57,0x57
   \              0x57 0x57    
   \   00000064   0x43 0x57          DC8      0x43,0x57,0x57,0x57
   \              0x57 0x57    
   \   00000068   0x4D 0x00          DC8      0x4D,0x0
   1948            { 
   1949              case TIM_CHANNEL_1:
   1950                {
   1951                  if(sClearInputConfig->ClearInputState != RESET)
   \                     ??HAL_TIM_ConfigOCrefClear_8: (+1)
   \   0000006A   0x6820             LDR      R0,[R4, #+0]
   \   0000006C   0x6829             LDR      R1,[R5, #+0]
   \   0000006E   0x2900             CMP      R1,#+0
   \   00000070   0x6981             LDR      R1,[R0, #+24]
   \   00000072   0xBF0C             ITE      EQ 
   \   00000074   0xF021 0x0180      BICEQ    R1,R1,#0x80
   \   00000078   0xF041 0x0180      ORRNE    R1,R1,#0x80
   1952                  {
   1953                    /* Enable the Ocref clear feature for Channel 1 */
   1954                    htim->Instance->CCMR1 |= TIM_CCMR1_OC1CE;
   1955                  }
   1956                  else
   1957                  {
   1958                    /* Disable the Ocref clear feature for Channel 1 */
   1959                    htim->Instance->CCMR1 &= ~TIM_CCMR1_OC1CE;      
   \   0000007C   0x6181             STR      R1,[R0, #+24]
   1960                  }
   1961                }    
   1962                break;
   1963              case TIM_CHANNEL_2:    
   1964                {
   1965                  if(sClearInputConfig->ClearInputState != RESET)
   1966                  {
   1967                    /* Enable the Ocref clear feature for Channel 2 */
   1968                    htim->Instance->CCMR1 |= TIM_CCMR1_OC2CE;
   1969                  }
   1970                  else
   1971                  {
   1972                    /* Disable the Ocref clear feature for Channel 2 */
   1973                    htim->Instance->CCMR1 &= ~TIM_CCMR1_OC2CE;      
   1974                  }
   1975                }    
   1976              break;
   1977              case TIM_CHANNEL_3:    
   1978                {
   1979                  if(sClearInputConfig->ClearInputState != RESET)
   1980                  {
   1981                    /* Enable the Ocref clear feature for Channel 3 */
   1982                    htim->Instance->CCMR2 |= TIM_CCMR2_OC3CE;
   1983                  }
   1984                  else
   1985                  {
   1986                    /* Disable the Ocref clear feature for Channel 3 */
   1987                    htim->Instance->CCMR2 &= ~TIM_CCMR2_OC3CE;      
   1988                  }
   1989                }    
   1990              break;
   1991              case TIM_CHANNEL_4:    
   1992                {
   1993                  if(sClearInputConfig->ClearInputState != RESET)
   1994                  {
   1995                    /* Enable the Ocref clear feature for Channel 4 */
   1996                    htim->Instance->CCMR2 |= TIM_CCMR2_OC4CE;
   1997                  }
   1998                  else
   1999                  {
   2000                    /* Disable the Ocref clear feature for Channel 4 */
   2001                    htim->Instance->CCMR2 &= ~TIM_CCMR2_OC4CE;      
   2002                  }
   2003                }    
   2004              break;
   2005              case TIM_CHANNEL_5:    
   2006                {
   2007                  if(sClearInputConfig->ClearInputState != RESET)
   2008                  {
   2009                    /* Enable the Ocref clear feature for Channel 1 */
   2010                    htim->Instance->CCMR3 |= TIM_CCMR3_OC5CE;
   2011                  }
   2012                  else
   2013                  {
   2014                    /* Disable the Ocref clear feature for Channel 1 */
   2015                    htim->Instance->CCMR3 &= ~TIM_CCMR3_OC5CE;      
   2016                  }
   2017                }    
   2018              break;
   2019              case TIM_CHANNEL_6:    
   2020                {
   2021                  if(sClearInputConfig->ClearInputState != RESET)
   2022                  {
   2023                    /* Enable the Ocref clear feature for Channel 1 */
   2024                    htim->Instance->CCMR3 |= TIM_CCMR3_OC6CE;
   2025                  }
   2026                  else
   2027                  {
   2028                    /* Disable the Ocref clear feature for Channel 1 */
   2029                    htim->Instance->CCMR3 &= ~TIM_CCMR3_OC6CE;      
   2030                  }
   2031                }    
   2032              break;
   2033              default:  
   2034              break;
   2035            } 
   2036            
   2037            __HAL_UNLOCK(htim);
   \   0000007E   0x2000             MOVS     R0,#+0
   \   00000080   0xF884 0x0038      STRB     R0,[R4, #+56]
   2038          
   2039            return HAL_OK;  
   \   00000084   0xBD70             POP      {R4-R6,PC}
   \                     ??HAL_TIM_ConfigOCrefClear_9: (+1)
   \   00000086   0x6820             LDR      R0,[R4, #+0]
   \   00000088   0x6829             LDR      R1,[R5, #+0]
   \   0000008A   0x2900             CMP      R1,#+0
   \   0000008C   0x6981             LDR      R1,[R0, #+24]
   \   0000008E   0xBF14             ITE      NE 
   \   00000090   0xF441 0x4100      ORRNE    R1,R1,#0x8000
   \   00000094   0xF421 0x4100      BICEQ    R1,R1,#0x8000
   \   00000098   0x6181             STR      R1,[R0, #+24]
   \   0000009A   0x2000             MOVS     R0,#+0
   \   0000009C   0xF884 0x0038      STRB     R0,[R4, #+56]
   \   000000A0   0xBD70             POP      {R4-R6,PC}
   \                     ??HAL_TIM_ConfigOCrefClear_10: (+1)
   \   000000A2   0x6820             LDR      R0,[R4, #+0]
   \   000000A4   0x6829             LDR      R1,[R5, #+0]
   \   000000A6   0x2900             CMP      R1,#+0
   \   000000A8   0x69C1             LDR      R1,[R0, #+28]
   \   000000AA   0xBF0C             ITE      EQ 
   \   000000AC   0xF021 0x0180      BICEQ    R1,R1,#0x80
   \   000000B0   0xF041 0x0180      ORRNE    R1,R1,#0x80
   \   000000B4   0x61C1             STR      R1,[R0, #+28]
   \   000000B6   0x2000             MOVS     R0,#+0
   \   000000B8   0xF884 0x0038      STRB     R0,[R4, #+56]
   \   000000BC   0xBD70             POP      {R4-R6,PC}
   \                     ??HAL_TIM_ConfigOCrefClear_11: (+1)
   \   000000BE   0x6820             LDR      R0,[R4, #+0]
   \   000000C0   0x6829             LDR      R1,[R5, #+0]
   \   000000C2   0x2900             CMP      R1,#+0
   \   000000C4   0x69C1             LDR      R1,[R0, #+28]
   \   000000C6   0xBF14             ITE      NE 
   \   000000C8   0xF441 0x4100      ORRNE    R1,R1,#0x8000
   \   000000CC   0xF421 0x4100      BICEQ    R1,R1,#0x8000
   \   000000D0   0x61C1             STR      R1,[R0, #+28]
   \   000000D2   0x2000             MOVS     R0,#+0
   \   000000D4   0xF884 0x0038      STRB     R0,[R4, #+56]
   \   000000D8   0xBD70             POP      {R4-R6,PC}
   \                     ??HAL_TIM_ConfigOCrefClear_12: (+1)
   \   000000DA   0x6820             LDR      R0,[R4, #+0]
   \   000000DC   0x6829             LDR      R1,[R5, #+0]
   \   000000DE   0x2900             CMP      R1,#+0
   \   000000E0   0x6D41             LDR      R1,[R0, #+84]
   \   000000E2   0xBF0C             ITE      EQ 
   \   000000E4   0xF021 0x0180      BICEQ    R1,R1,#0x80
   \   000000E8   0xF041 0x0180      ORRNE    R1,R1,#0x80
   \   000000EC   0xE008             B.N      ??HAL_TIM_ConfigOCrefClear_13
   \                     ??HAL_TIM_ConfigOCrefClear_14: (+1)
   \   000000EE   0x6820             LDR      R0,[R4, #+0]
   \   000000F0   0x6829             LDR      R1,[R5, #+0]
   \   000000F2   0x2900             CMP      R1,#+0
   \   000000F4   0x6D41             LDR      R1,[R0, #+84]
   \   000000F6   0xBF14             ITE      NE 
   \   000000F8   0xF441 0x4100      ORRNE    R1,R1,#0x8000
   \   000000FC   0xF421 0x4100      BICEQ    R1,R1,#0x8000
   \                     ??HAL_TIM_ConfigOCrefClear_13: (+1)
   \   00000100   0x6541             STR      R1,[R0, #+84]
   \                     ??HAL_TIM_ConfigOCrefClear_7: (+1)
   \   00000102   0x2000             MOVS     R0,#+0
   \   00000104   0xF884 0x0038      STRB     R0,[R4, #+56]
   \   00000108   0xBD70             POP      {R4-R6,PC}       ;; return
   2040          }  
   2041          
   2042          /**
   2043            * @brief  Configures the TIM in master mode.
   2044            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   2045            *                the configuration information for TIM module.   
   2046            * @param  sMasterConfig: pointer to a TIM_MasterConfigTypeDef structure that
   2047            *         contains the selected trigger output (TRGO) and the Master/Slave 
   2048            *         mode. 
   2049            * @retval HAL status
   2050            */

   \                                 In section .text, align 2, keep-with-next
   2051          HAL_StatusTypeDef HAL_TIMEx_MasterConfigSynchronization(TIM_HandleTypeDef *htim, TIM_MasterConfigTypeDef * sMasterConfig)
   2052          {
   \                     HAL_TIMEx_MasterConfigSynchronization: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
   2053            uint32_t tmpcr2;  
   2054            uint32_t tmpsmcr;  
   2055          
   2056            /* Check the parameters */
   2057            assert_param(IS_TIM_SYNCHRO_INSTANCE(htim->Instance));
   2058            assert_param(IS_TIM_TRGO_SOURCE(sMasterConfig->MasterOutputTrigger));
   2059            assert_param(IS_TIM_MSM_STATE(sMasterConfig->MasterSlaveMode));
   2060            
   2061            /* Check input state */
   2062            __HAL_LOCK(htim);
   \   00000002   0xF890 0x2038      LDRB     R2,[R0, #+56]
   \   00000006   0x2A01             CMP      R2,#+1
   \   00000008   0xBF08             IT       EQ 
   \   0000000A   0x2002             MOVEQ    R0,#+2
   \   0000000C   0xD01D             BEQ.N    ??HAL_TIMEx_MasterConfigSynchronization_0
   \   0000000E   0x2201             MOVS     R2,#+1
   2063          
   2064           /* Get the TIMx CR2 register value */
   2065            tmpcr2 = htim->Instance->CR2;
   2066          
   2067            /* Get the TIMx SMCR register value */
   2068            tmpsmcr = htim->Instance->SMCR;
   2069          
   2070            /* If the timer supports ADC synchronization through TRGO2, set the master mode selection 2 */
   2071            if (IS_TIM_TRGO2_INSTANCE(htim->Instance))
   \   00000010   0x....             LDR.N    R5,??DataTable7_3  ;; 0x40010000
   \   00000012   0xF880 0x2038      STRB     R2,[R0, #+56]
   \   00000016   0x6802             LDR      R2,[R0, #+0]
   \   00000018   0x42AA             CMP      R2,R5
   \   0000001A   0x6853             LDR      R3,[R2, #+4]
   \   0000001C   0x6894             LDR      R4,[R2, #+8]
   \   0000001E   0xBF1C             ITT      NE 
   \   00000020   0x....             LDRNE.N  R5,??DataTable7_4  ;; 0x40010400
   \   00000022   0x42AA             CMPNE    R2,R5
   \   00000024   0xD103             BNE.N    ??HAL_TIMEx_MasterConfigSynchronization_1
   2072            {
   2073              /* Check the parameters */
   2074              assert_param(IS_TIM_TRGO2_SOURCE(sMasterConfig->MasterOutputTrigger2));
   2075              
   2076              /* Clear the MMS2 bits */
   2077              tmpcr2 &= ~TIM_CR2_MMS2;
   2078              /* Select the TRGO2 source*/
   2079              tmpcr2 |= sMasterConfig->MasterOutputTrigger2;
   \   00000026   0x684D             LDR      R5,[R1, #+4]
   \   00000028   0xF423 0x0370      BIC      R3,R3,#0xF00000
   \   0000002C   0x432B             ORRS     R3,R5,R3
   2080            }
   2081            
   2082            /* Reset the MMS Bits */
   2083            tmpcr2 &= ~TIM_CR2_MMS;
   2084            /* Select the TRGO source */
   2085            tmpcr2 |=  sMasterConfig->MasterOutputTrigger;
   2086          
   2087            /* Reset the MSM Bit */
   2088            tmpsmcr &= ~TIM_SMCR_MSM;
   2089            /* Set master mode */
   2090            tmpsmcr |= sMasterConfig->MasterSlaveMode;
   \                     ??HAL_TIMEx_MasterConfigSynchronization_1: (+1)
   \   0000002E   0x688D             LDR      R5,[R1, #+8]
   2091            
   2092            /* Update TIMx CR2 */
   2093            htim->Instance->CR2 = tmpcr2;
   \   00000030   0x6809             LDR      R1,[R1, #+0]
   \   00000032   0xF023 0x0370      BIC      R3,R3,#0x70
   \   00000036   0xF024 0x0480      BIC      R4,R4,#0x80
   \   0000003A   0x4319             ORRS     R1,R1,R3
   \   0000003C   0x432C             ORRS     R4,R5,R4
   \   0000003E   0x6051             STR      R1,[R2, #+4]
   2094            
   2095            /* Update TIMx SMCR */
   2096            htim->Instance->SMCR = tmpsmcr;
   2097          
   2098            __HAL_UNLOCK(htim);
   \   00000040   0x2100             MOVS     R1,#+0
   \   00000042   0x6094             STR      R4,[R2, #+8]
   \   00000044   0xF880 0x1038      STRB     R1,[R0, #+56]
   2099            
   2100            return HAL_OK;
   \   00000048   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIMEx_MasterConfigSynchronization_0: (+1)
   \   0000004A   0xBC30             POP      {R4,R5}
   \   0000004C   0x4770             BX       LR               ;; return
   2101          } 
   2102                                                               
   2103          /**
   2104            * @brief   Configures the Break feature, dead time, Lock level, OSSI/OSSR State
   2105            *         and the AOE(automatic output enable).
   2106            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   2107            *                the configuration information for TIM module.
   2108            * @param  sBreakDeadTimeConfig: pointer to a TIM_ConfigBreakDeadConfig_TypeDef structure that
   2109            *         contains the BDTR Register configuration  information for the TIM peripheral. 
   2110            * @retval HAL status
   2111            */    

   \                                 In section .text, align 2, keep-with-next
   2112          HAL_StatusTypeDef HAL_TIMEx_ConfigBreakDeadTime(TIM_HandleTypeDef *htim, 
   2113                                                        TIM_BreakDeadTimeConfigTypeDef * sBreakDeadTimeConfig)
   2114          {
   2115            uint32_t tmpbdtr = 0;
   2116            
   2117            /* Check the parameters */
   2118            assert_param(IS_TIM_BREAK_INSTANCE(htim->Instance));
   2119            assert_param(IS_TIM_OSSR_STATE(sBreakDeadTimeConfig->OffStateRunMode));
   2120            assert_param(IS_TIM_OSSI_STATE(sBreakDeadTimeConfig->OffStateIDLEMode));
   2121            assert_param(IS_TIM_LOCK_LEVEL(sBreakDeadTimeConfig->LockLevel));
   2122            assert_param(IS_TIM_DEADTIME(sBreakDeadTimeConfig->DeadTime));
   2123            assert_param(IS_TIM_BREAK_STATE(sBreakDeadTimeConfig->BreakState));
   2124            assert_param(IS_TIM_BREAK_POLARITY(sBreakDeadTimeConfig->BreakPolarity));
   2125            assert_param(IS_TIM_BREAK_FILTER(sBreakDeadTimeConfig->BreakFilter));
   2126            assert_param(IS_TIM_AUTOMATIC_OUTPUT_STATE(sBreakDeadTimeConfig->AutomaticOutput));
   2127            assert_param(IS_TIM_BREAK2_STATE(sBreakDeadTimeConfig->Break2State));
   2128            assert_param(IS_TIM_BREAK2_POLARITY(sBreakDeadTimeConfig->Break2Polarity));
   2129            assert_param(IS_TIM_BREAK_FILTER(sBreakDeadTimeConfig->Break2Filter));
   2130            
   2131            /* Check input state */
   2132            __HAL_LOCK(htim);
   \                     HAL_TIMEx_ConfigBreakDeadTime: (+1)
   \   00000000   0xF890 0x2038      LDRB     R2,[R0, #+56]
   \   00000004   0x2A01             CMP      R2,#+1
   \   00000006   0xD101             BNE.N    ??HAL_TIMEx_ConfigBreakDeadTime_0
   \   00000008   0x2002             MOVS     R0,#+2
   \   0000000A   0x4770             BX       LR
   \                     ??HAL_TIMEx_ConfigBreakDeadTime_0: (+1)
   \   0000000C   0x2201             MOVS     R2,#+1
   \   0000000E   0xF880 0x2038      STRB     R2,[R0, #+56]
   2133            
   2134            htim->State = HAL_TIM_STATE_BUSY;
   \   00000012   0x2202             MOVS     R2,#+2
   \   00000014   0xF880 0x2039      STRB     R2,[R0, #+57]
   2135          
   2136            /* Set the Lock level, the Break enable Bit and the Polarity, the OSSR State,
   2137               the OSSI State, the dead time value and the Automatic Output Enable Bit */
   2138              
   2139            /* Clear the BDTR bits */
   2140            tmpbdtr &= ~(TIM_BDTR_DTG | TIM_BDTR_LOCK |  TIM_BDTR_OSSI | 
   2141                         TIM_BDTR_OSSR | TIM_BDTR_BKE | TIM_BDTR_BKP | 
   2142                         TIM_BDTR_AOE | TIM_BDTR_MOE | TIM_BDTR_BKF |
   2143                         TIM_BDTR_BK2F | TIM_BDTR_BK2E | TIM_BDTR_BK2P);
   2144          
   2145            /* Set the BDTR bits */
   2146            tmpbdtr |= sBreakDeadTimeConfig->DeadTime;
   2147            tmpbdtr |= sBreakDeadTimeConfig->LockLevel;
   2148            tmpbdtr |= sBreakDeadTimeConfig->OffStateIDLEMode;
   2149            tmpbdtr |= sBreakDeadTimeConfig->OffStateRunMode;
   2150            tmpbdtr |= sBreakDeadTimeConfig->BreakState;
   2151            tmpbdtr |= sBreakDeadTimeConfig->BreakPolarity;
   2152            tmpbdtr |= sBreakDeadTimeConfig->AutomaticOutput;
   2153            tmpbdtr |= (sBreakDeadTimeConfig->BreakFilter << BDTR_BKF_SHIFT);
   2154            tmpbdtr |= (sBreakDeadTimeConfig->Break2Filter << BDTR_BK2F_SHIFT);
   2155            tmpbdtr |= sBreakDeadTimeConfig->Break2State;
   2156            tmpbdtr |= sBreakDeadTimeConfig->Break2Polarity;
   2157            
   2158            /* Set TIMx_BDTR */
   2159            htim->Instance->BDTR = tmpbdtr;
   \   00000018   0x68CA             LDR      R2,[R1, #+12]
   \   0000001A   0x688B             LDR      R3,[R1, #+8]
   \   0000001C   0x431A             ORRS     R2,R3,R2
   \   0000001E   0x684B             LDR      R3,[R1, #+4]
   \   00000020   0x431A             ORRS     R2,R3,R2
   \   00000022   0x680B             LDR      R3,[R1, #+0]
   \   00000024   0x431A             ORRS     R2,R3,R2
   \   00000026   0x690B             LDR      R3,[R1, #+16]
   \   00000028   0x431A             ORRS     R2,R3,R2
   \   0000002A   0x694B             LDR      R3,[R1, #+20]
   \   0000002C   0x431A             ORRS     R2,R3,R2
   \   0000002E   0x6A8B             LDR      R3,[R1, #+40]
   \   00000030   0x431A             ORRS     R2,R3,R2
   \   00000032   0x698B             LDR      R3,[R1, #+24]
   \   00000034   0xEA42 0x4203      ORR      R2,R2,R3, LSL #+16
   \   00000038   0x6A4B             LDR      R3,[R1, #+36]
   \   0000003A   0xEA42 0x5203      ORR      R2,R2,R3, LSL #+20
   \   0000003E   0x69CB             LDR      R3,[R1, #+28]
   \   00000040   0x6A09             LDR      R1,[R1, #+32]
   \   00000042   0x431A             ORRS     R2,R3,R2
   \   00000044   0x4311             ORRS     R1,R1,R2
   \   00000046   0x6802             LDR      R2,[R0, #+0]
   \   00000048   0x6451             STR      R1,[R2, #+68]
   2160            
   2161            __HAL_UNLOCK(htim);
   \   0000004A   0x2100             MOVS     R1,#+0
   \   0000004C   0xF880 0x1038      STRB     R1,[R0, #+56]
   2162            
   2163            return HAL_OK;
   \   00000050   0x2000             MOVS     R0,#+0
   \   00000052   0x4770             BX       LR               ;; return
   2164          }
   2165          
   2166          /**
   2167            * @brief  Configures the TIM2, TIM5 and TIM11 Remapping input capabilities.
   2168            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   2169            *                the configuration information for TIM module.
   2170            * @param  Remap: specifies the TIM input remapping source.
   2171            *          This parameter can be one of the following values:
   2172            *            @arg TIM_TIM2_TIM8_TRGO: TIM2 ITR1 input is connected to TIM8 Trigger output(default)
   2173            *            @arg TIM_TIM2_ETH_PTP:   TIM2 ITR1 input is connected to ETH PTP trigger output.
   2174            *            @arg TIM_TIM2_USBFS_SOF: TIM2 ITR1 input is connected to USB FS SOF. 
   2175            *            @arg TIM_TIM2_USBHS_SOF: TIM2 ITR1 input is connected to USB HS SOF. 
   2176            *            @arg TIM_TIM5_GPIO:      TIM5 CH4 input is connected to dedicated Timer pin(default)
   2177            *            @arg TIM_TIM5_LSI:       TIM5 CH4 input is connected to LSI clock.
   2178            *            @arg TIM_TIM5_LSE:       TIM5 CH4 input is connected to LSE clock.
   2179            *            @arg TIM_TIM5_RTC:       TIM5 CH4 input is connected to RTC Output event.
   2180            *            @arg TIM_TIM11_GPIO:     TIM11 CH4 input is connected to dedicated Timer pin(default) 
   2181            *            @arg TIM_TIM11_SPDIF:    SPDIF Frame synchronous   
   2182            *            @arg TIM_TIM11_HSE:      TIM11 CH4 input is connected to HSE_RTC clock
   2183            *                                     (HSE divided by a programmable prescaler) 
   2184            *            @arg TIM_TIM11_MCO1:     TIM11 CH1 input is connected to MCO1    
   2185            * @retval HAL status
   2186            */

   \                                 In section .text, align 2, keep-with-next
   2187          HAL_StatusTypeDef HAL_TIMEx_RemapConfig(TIM_HandleTypeDef *htim, uint32_t Remap)
   2188          {
   2189            __HAL_LOCK(htim);
   \                     HAL_TIMEx_RemapConfig: (+1)
   \   00000000   0xF890 0x2038      LDRB     R2,[R0, #+56]
   \   00000004   0x2A01             CMP      R2,#+1
   \   00000006   0xD101             BNE.N    ??HAL_TIMEx_RemapConfig_0
   \   00000008   0x2002             MOVS     R0,#+2
   \   0000000A   0x4770             BX       LR
   \                     ??HAL_TIMEx_RemapConfig_0: (+1)
   \   0000000C   0x2201             MOVS     R2,#+1
   \   0000000E   0xF880 0x2038      STRB     R2,[R0, #+56]
   2190              
   2191            /* Check parameters */
   2192            assert_param(IS_TIM_REMAP_INSTANCE(htim->Instance));
   2193            assert_param(IS_TIM_REMAP(Remap));
   2194            
   2195            /* Set the Timer remapping configuration */
   2196            htim->Instance->OR = Remap;
   \   00000012   0x6802             LDR      R2,[R0, #+0]
   \   00000014   0x6511             STR      R1,[R2, #+80]
   2197            
   2198            htim->State = HAL_TIM_STATE_READY;
   \   00000016   0x2101             MOVS     R1,#+1
   \   00000018   0xF880 0x1039      STRB     R1,[R0, #+57]
   2199            
   2200            __HAL_UNLOCK(htim);  
   \   0000001C   0x2100             MOVS     R1,#+0
   \   0000001E   0xF880 0x1038      STRB     R1,[R0, #+56]
   2201            
   2202            return HAL_OK;
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0x4770             BX       LR               ;; return
   2203          }
   2204          
   2205          /**
   2206            * @brief  Group channel 5 and channel 1, 2 or 3
   2207            * @param  htim: TIM handle.
   2208            * @param  OCRef: specifies the reference signal(s) the OC5REF is combined with.
   2209            *         This parameter can be any combination of the following values:
   2210            *         TIM_GROUPCH5_NONE: No effect of OC5REF on OC1REFC, OC2REFC and OC3REFC
   2211            *         TIM_GROUPCH5_OC1REFC: OC1REFC is the logical AND of OC1REFC and OC5REF
   2212            *         TIM_GROUPCH5_OC2REFC: OC2REFC is the logical AND of OC2REFC and OC5REF
   2213            *         TIM_GROUPCH5_OC3REFC: OC3REFC is the logical AND of OC3REFC and OC5REF
   2214            * @retval HAL status
   2215            */

   \                                 In section .text, align 2, keep-with-next
   2216          HAL_StatusTypeDef HAL_TIMEx_GroupChannel5(TIM_HandleTypeDef *htim, uint32_t OCRef)
   2217          {
   2218            /* Check parameters */
   2219            assert_param(IS_TIM_COMBINED3PHASEPWM_INSTANCE(htim->Instance));
   2220            assert_param(IS_TIM_GROUPCH5(OCRef));
   2221          
   2222            /* Process Locked */
   2223            __HAL_LOCK(htim);
   \                     HAL_TIMEx_GroupChannel5: (+1)
   \   00000000   0xF890 0x2038      LDRB     R2,[R0, #+56]
   \   00000004   0x2A01             CMP      R2,#+1
   \   00000006   0xD101             BNE.N    ??HAL_TIMEx_GroupChannel5_0
   \   00000008   0x2002             MOVS     R0,#+2
   \   0000000A   0x4770             BX       LR
   \                     ??HAL_TIMEx_GroupChannel5_0: (+1)
   \   0000000C   0x2201             MOVS     R2,#+1
   \   0000000E   0xF880 0x2038      STRB     R2,[R0, #+56]
   2224            
   2225            htim->State = HAL_TIM_STATE_BUSY;
   \   00000012   0x2202             MOVS     R2,#+2
   \   00000014   0xF880 0x2039      STRB     R2,[R0, #+57]
   2226            
   2227            /* Clear GC5Cx bit fields */
   2228            htim->Instance->CCR5 &= ~(TIM_CCR5_GC5C3|TIM_CCR5_GC5C2|TIM_CCR5_GC5C1);
   \   00000018   0x6802             LDR      R2,[R0, #+0]
   \   0000001A   0x6D93             LDR      R3,[R2, #+88]
   \   0000001C   0x00DB             LSLS     R3,R3,#+3
   \   0000001E   0x08DB             LSRS     R3,R3,#+3
   \   00000020   0x6593             STR      R3,[R2, #+88]
   2229            
   2230            /* Set GC5Cx bit fields */
   2231            htim->Instance->CCR5 |= OCRef;
   \   00000022   0x6802             LDR      R2,[R0, #+0]
   \   00000024   0x6D93             LDR      R3,[R2, #+88]
   \   00000026   0x4319             ORRS     R1,R1,R3
   \   00000028   0x6591             STR      R1,[R2, #+88]
   2232                                             
   2233            htim->State = HAL_TIM_STATE_READY;                                 
   \   0000002A   0x2101             MOVS     R1,#+1
   \   0000002C   0xF880 0x1039      STRB     R1,[R0, #+57]
   2234            
   2235            __HAL_UNLOCK(htim);
   \   00000030   0x2100             MOVS     R1,#+0
   \   00000032   0xF880 0x1038      STRB     R1,[R0, #+56]
   2236            
   2237            return HAL_OK;
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0x4770             BX       LR               ;; return
   2238          }
   2239          
   2240          /**
   2241            * @}
   2242            */
   2243          
   2244          /** @defgroup TIMEx_Exported_Functions_Group6 Extended Callbacks functions 
   2245            * @brief    Extended Callbacks functions
   2246           *
   2247          @verbatim   
   2248            ==============================================================================
   2249                              ##### Extension Callbacks functions #####
   2250            ==============================================================================  
   2251            [..]  
   2252              This section provides Extension TIM callback functions:
   2253              (+) Timer Commutation callback
   2254              (+) Timer Break callback
   2255          
   2256          @endverbatim
   2257            * @{
   2258            */
   2259          
   2260          /**
   2261            * @brief  Hall commutation changed callback in non blocking mode 
   2262            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   2263            *                the configuration information for TIM module.
   2264            * @retval None
   2265            */

   \                                 In section .text, align 2, keep-with-next
   2266          __weak void HAL_TIMEx_CommutationCallback(TIM_HandleTypeDef *htim)
   2267          {
   2268            /* NOTE : This function Should not be modified, when the callback is needed,
   2269                      the HAL_TIMEx_CommutationCallback could be implemented in the user file
   2270             */
   2271          }
   \                     HAL_TIMEx_CommutationCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   2272          
   2273          /**
   2274            * @brief  Hall Break detection callback in non blocking mode 
   2275            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   2276            *                the configuration information for TIM module.
   2277            * @retval None
   2278            */

   \                                 In section .text, align 2, keep-with-next
   2279          __weak void HAL_TIMEx_BreakCallback(TIM_HandleTypeDef *htim)
   2280          {
   2281            /* NOTE : This function Should not be modified, when the callback is needed,
   2282                      the HAL_TIMEx_BreakCallback could be implemented in the user file
   2283             */
   2284          }
   \                     HAL_TIMEx_BreakCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   2285          
   2286          /**
   2287            * @}
   2288            */
   2289          
   2290          /** @defgroup TIMEx_Exported_Functions_Group7 Extended Peripheral State functions 
   2291           *  @brief    Extended Peripheral State functions
   2292           *
   2293          @verbatim   
   2294            ==============================================================================
   2295                          ##### Extension Peripheral State functions #####
   2296            ==============================================================================  
   2297            [..]
   2298              This subsection permits to get in run-time the status of the peripheral 
   2299              and the data flow.
   2300          
   2301          @endverbatim
   2302            * @{
   2303            */
   2304          
   2305          /**
   2306            * @brief  Return the TIM Hall Sensor interface state
   2307            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   2308            *                the configuration information for TIM module.
   2309            * @retval HAL state
   2310            */

   \                                 In section .text, align 2, keep-with-next
   2311          HAL_TIM_StateTypeDef HAL_TIMEx_HallSensor_GetState(TIM_HandleTypeDef *htim)
   2312          {
   2313            return htim->State;
   \                     HAL_TIMEx_HallSensor_GetState: (+1)
   \   00000000   0xF890 0x0039      LDRB     R0,[R0, #+57]
   \   00000004   0x4770             BX       LR               ;; return
   2314          }
   2315          
   2316          /**
   2317            * @}
   2318            */
   2319          
   2320          /**
   2321            * @brief  TIM DMA Commutation callback. 
   2322            * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
   2323            *                the configuration information for the specified DMA module.
   2324            * @retval None
   2325            */

   \                                 In section .text, align 4, keep-with-next
   2326          void HAL_TIMEx_DMACommutationCplt(DMA_HandleTypeDef *hdma)
   2327          {
   \                     TIMEx_DMACommutationCplt: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB081             SUB      SP,SP,#+4
   2328            TIM_HandleTypeDef* htim = ( TIM_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   \   00000004   0x6B80             LDR      R0,[R0, #+56]
   2329            
   2330            htim->State= HAL_TIM_STATE_READY;
   \   00000006   0x2101             MOVS     R1,#+1
   \   00000008   0xF880 0x1039      STRB     R1,[R0, #+57]
   2331              
   2332            HAL_TIMEx_CommutationCallback(htim); 
   \   0000000C   0x.... 0x....      BL       HAL_TIMEx_CommutationCallback
   2333          }
   \   00000010   0xB001             ADD      SP,SP,#+4
   \   00000012   0xBD00             POP      {PC}             ;; return
   2334          
   2335          /**
   2336            * @brief  Enables or disables the TIM Capture Compare Channel xN.
   2337            * @param  TIMx to select the TIM peripheral
   2338            * @param  Channel: specifies the TIM Channel
   2339            *          This parameter can be one of the following values:
   2340            *            @arg TIM_Channel_1: TIM Channel 1
   2341            *            @arg TIM_Channel_2: TIM Channel 2
   2342            *            @arg TIM_Channel_3: TIM Channel 3
   2343            * @param  ChannelNState: specifies the TIM Channel CCxNE bit new state.
   2344            *          This parameter can be: TIM_CCxN_ENABLE or TIM_CCxN_Disable. 
   2345            * @retval None
   2346            */
   2347          static void TIM_CCxNChannelCmd(TIM_TypeDef* TIMx, uint32_t Channel, uint32_t ChannelNState)
   2348          {
   2349            uint32_t tmp = 0;
   2350          
   2351            /* Check the parameters */
   2352            assert_param(IS_TIM_ADVANCED_INSTANCE(TIMx));
   2353            assert_param(IS_TIM_COMPLEMENTARY_CHANNELS(Channel));
   2354          
   2355            tmp = TIM_CCER_CC1NE << Channel;
   2356          
   2357            /* Reset the CCxNE Bit */
   2358            TIMx->CCER &= ~tmp;
   2359          
   2360            /* Set or reset the CCxNE Bit */ 
   2361            TIMx->CCER |= (uint32_t)(ChannelNState << Channel);
   2362          }
   2363          
   2364          /**
   2365            * @brief  Timer Output Compare 5 configuration
   2366            * @param  TIMx to select the TIM peripheral
   2367            * @param  OC_Config: The output configuration structure
   2368            * @retval None
   2369            */

   \                                 In section .text, align 2, keep-with-next
   2370          static void TIM_OC5_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
   2371          {
   \                     TIM_OC5_SetConfig: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
   2372            uint32_t tmpccmrx = 0;
   2373            uint32_t tmpccer = 0;
   2374            uint32_t tmpcr2 = 0; 
   2375          
   2376            /* Disable the output: Reset the CCxE Bit */
   2377            TIMx->CCER &= ~TIM_CCER_CC5E;
   \   00000002   0x6A02             LDR      R2,[R0, #+32]
   2378            
   2379            /* Get the TIMx CCER register value */
   2380            tmpccer = TIMx->CCER;
   2381            /* Get the TIMx CR2 register value */
   2382            tmpcr2 =  TIMx->CR2; 
   2383            /* Get the TIMx CCMR1 register value */
   2384            tmpccmrx = TIMx->CCMR3;
   2385          
   2386            /* Reset the Output Compare Mode Bits */
   2387            tmpccmrx &= ~(TIM_CCMR3_OC5M);
   2388            /* Select the Output Compare Mode */
   2389            tmpccmrx |= OC_Config->OCMode;
   \   00000004   0x....             LDR.N    R5,??DataTable7_5  ;; 0xfffeff8f
   \   00000006   0xF422 0x3280      BIC      R2,R2,#0x10000
   \   0000000A   0x6202             STR      R2,[R0, #+32]
   \   0000000C   0x6A02             LDR      R2,[R0, #+32]
   \   0000000E   0x6843             LDR      R3,[R0, #+4]
   \   00000010   0x6D44             LDR      R4,[R0, #+84]
   2390            
   2391            /* Reset the Output Polarity level */
   2392            tmpccer &= ~TIM_CCER_CC5P;
   2393            /* Set the Output Compare Polarity */
   2394            tmpccer |= (OC_Config->OCPolarity << 16);
   \   00000012   0xF422 0x3200      BIC      R2,R2,#0x20000
   \   00000016   0x402C             ANDS     R4,R5,R4
   \   00000018   0x680D             LDR      R5,[R1, #+0]
   \   0000001A   0x432C             ORRS     R4,R5,R4
   \   0000001C   0x688D             LDR      R5,[R1, #+8]
   \   0000001E   0xEA42 0x4205      ORR      R2,R2,R5, LSL #+16
   2395          
   2396            if(IS_TIM_BREAK_INSTANCE(TIMx))
   \   00000022   0x....             LDR.N    R5,??DataTable7_3  ;; 0x40010000
   \   00000024   0x42A8             CMP      R0,R5
   \   00000026   0xBF1C             ITT      NE 
   \   00000028   0x....             LDRNE.N  R5,??DataTable7_4  ;; 0x40010400
   \   0000002A   0x42A8             CMPNE    R0,R5
   \   0000002C   0xD104             BNE.N    ??TIM_OC5_SetConfig_0
   2397            {   
   2398              /* Reset the Output Compare IDLE State */
   2399              tmpcr2 &= ~TIM_CR2_OIS5;
   2400              /* Set the Output Idle state */
   2401              tmpcr2 |= (OC_Config->OCIdleState << 8);
   \   0000002E   0x694D             LDR      R5,[R1, #+20]
   \   00000030   0xF423 0x3380      BIC      R3,R3,#0x10000
   \   00000034   0xEA43 0x2305      ORR      R3,R3,R5, LSL #+8
   2402            }
   2403            /* Write to TIMx CR2 */
   2404            TIMx->CR2 = tmpcr2;
   \                     ??TIM_OC5_SetConfig_0: (+1)
   \   00000038   0x6043             STR      R3,[R0, #+4]
   2405            
   2406            /* Write to TIMx CCMR3 */
   2407            TIMx->CCMR3 = tmpccmrx;
   \   0000003A   0x6544             STR      R4,[R0, #+84]
   2408            
   2409            /* Set the Capture Compare Register value */
   2410            TIMx->CCR5 = OC_Config->Pulse;
   \   0000003C   0x6849             LDR      R1,[R1, #+4]
   \   0000003E   0x6581             STR      R1,[R0, #+88]
   2411            
   2412            /* Write to TIMx CCER */
   2413            TIMx->CCER = tmpccer;  
   \   00000040   0x6202             STR      R2,[R0, #+32]
   2414          }
   \   00000042   0xBC30             POP      {R4,R5}
   \   00000044   0x4770             BX       LR               ;; return
   2415          
   2416          /**
   2417            * @brief  Timer Output Compare 6 configuration
   2418            * @param  TIMx to select the TIM peripheral
   2419            * @param  OC_Config: The output configuration structure
   2420            * @retval None
   2421            */

   \                                 In section .text, align 2, keep-with-next
   2422          static void TIM_OC6_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
   2423          {
   \                     TIM_OC6_SetConfig: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
   2424            uint32_t tmpccmrx = 0;
   2425            uint32_t tmpccer = 0;
   2426            uint32_t tmpcr2 = 0; 
   2427          
   2428            /* Disable the output: Reset the CCxE Bit */
   2429            TIMx->CCER &= ~TIM_CCER_CC6E;
   \   00000002   0x6A02             LDR      R2,[R0, #+32]
   2430            
   2431            /* Get the TIMx CCER register value */
   2432            tmpccer = TIMx->CCER;
   2433            /* Get the TIMx CR2 register value */
   2434            tmpcr2 =  TIMx->CR2; 
   2435            /* Get the TIMx CCMR1 register value */
   2436            tmpccmrx = TIMx->CCMR3;
   2437              
   2438            /* Reset the Output Compare Mode Bits */
   2439            tmpccmrx &= ~(TIM_CCMR3_OC6M);
   2440            /* Select the Output Compare Mode */
   2441            tmpccmrx |= (OC_Config->OCMode << 8);
   \   00000004   0x....             LDR.N    R5,??DataTable7_6  ;; 0xfeff8fff
   \   00000006   0xF422 0x1280      BIC      R2,R2,#0x100000
   \   0000000A   0x6202             STR      R2,[R0, #+32]
   \   0000000C   0x6A02             LDR      R2,[R0, #+32]
   \   0000000E   0x6843             LDR      R3,[R0, #+4]
   \   00000010   0x6D44             LDR      R4,[R0, #+84]
   2442            
   2443            /* Reset the Output Polarity level */
   2444            tmpccer &= (uint32_t)~TIM_CCER_CC6P;
   2445            /* Set the Output Compare Polarity */
   2446            tmpccer |= (OC_Config->OCPolarity << 20);
   \   00000012   0xF422 0x1200      BIC      R2,R2,#0x200000
   \   00000016   0x402C             ANDS     R4,R5,R4
   \   00000018   0x680D             LDR      R5,[R1, #+0]
   \   0000001A   0xEA44 0x2405      ORR      R4,R4,R5, LSL #+8
   \   0000001E   0x688D             LDR      R5,[R1, #+8]
   \   00000020   0xEA42 0x5205      ORR      R2,R2,R5, LSL #+20
   2447          
   2448            if(IS_TIM_BREAK_INSTANCE(TIMx))
   \   00000024   0x....             LDR.N    R5,??DataTable7_3  ;; 0x40010000
   \   00000026   0x42A8             CMP      R0,R5
   \   00000028   0xBF1C             ITT      NE 
   \   0000002A   0x....             LDRNE.N  R5,??DataTable7_4  ;; 0x40010400
   \   0000002C   0x42A8             CMPNE    R0,R5
   \   0000002E   0xD104             BNE.N    ??TIM_OC6_SetConfig_0
   2449            {   
   2450              /* Reset the Output Compare IDLE State */
   2451              tmpcr2 &= ~TIM_CR2_OIS6;
   2452              /* Set the Output Idle state */
   2453              tmpcr2 |= (OC_Config->OCIdleState << 10);
   \   00000030   0x694D             LDR      R5,[R1, #+20]
   \   00000032   0xF423 0x2380      BIC      R3,R3,#0x40000
   \   00000036   0xEA43 0x2385      ORR      R3,R3,R5, LSL #+10
   2454            }
   2455            
   2456            /* Write to TIMx CR2 */
   2457            TIMx->CR2 = tmpcr2;
   \                     ??TIM_OC6_SetConfig_0: (+1)
   \   0000003A   0x6043             STR      R3,[R0, #+4]
   2458            
   2459            /* Write to TIMx CCMR3 */
   2460            TIMx->CCMR3 = tmpccmrx;
   \   0000003C   0x6544             STR      R4,[R0, #+84]
   2461            
   2462            /* Set the Capture Compare Register value */
   2463            TIMx->CCR6 = OC_Config->Pulse;
   \   0000003E   0x6849             LDR      R1,[R1, #+4]
   \   00000040   0x65C1             STR      R1,[R0, #+92]
   2464            
   2465            /* Write to TIMx CCER */
   2466            TIMx->CCER = tmpccer;  
   \   00000042   0x6202             STR      R2,[R0, #+32]
   2467          } 
   \   00000044   0xBC30             POP      {R4,R5}
   \   00000046   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5:
   \   00000000   0xFFFEFFF8         DC32     0xfffefff8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7:
   \   00000000   0x........         DC32     TIM_DMACaptureCplt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_1:
   \   00000000   0x........         DC32     TIM_DMAError

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_2:
   \   00000000   0x........         DC32     TIM_DMADelayPulseCplt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_3:
   \   00000000   0x40010000         DC32     0x40010000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_4:
   \   00000000   0x40010400         DC32     0x40010400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_5:
   \   00000000   0xFFFEFF8F         DC32     0xfffeff8f

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_6:
   \   00000000   0xFEFF8FFF         DC32     0xfeff8fff
   2468          
   2469          /**
   2470            * @}
   2471            */
   2472          
   2473          #endif /* HAL_TIM_MODULE_ENABLED */
   2474          /**
   2475            * @}
   2476            */ 
   2477          
   2478          /**
   2479            * @}
   2480            */ 
   2481          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   HAL_TIMEx_BreakCallback
       0   HAL_TIMEx_CommutationCallback
       0   HAL_TIMEx_ConfigBreakDeadTime
       0   HAL_TIMEx_ConfigCommutationEvent
       0   HAL_TIMEx_ConfigCommutationEvent_DMA
       0   HAL_TIMEx_ConfigCommutationEvent_IT
       0   HAL_TIMEx_GroupChannel5
       8   HAL_TIMEx_HallSensor_DeInit
         8   -> HAL_TIMEx_HallSensor_MspDeInit
       0   HAL_TIMEx_HallSensor_GetState
      40   HAL_TIMEx_HallSensor_Init
        40   -> HAL_TIMEx_HallSensor_MspInit
        40   -> TIM_Base_SetConfig
        40   -> TIM_OC2_SetConfig
        40   -> TIM_TI1_SetConfig
       0   HAL_TIMEx_HallSensor_MspDeInit
       0   HAL_TIMEx_HallSensor_MspInit
       8   HAL_TIMEx_HallSensor_Start
         8   -> TIM_CCxChannelCmd
      16   HAL_TIMEx_HallSensor_Start_DMA
        16   -> HAL_DMA_Start_IT
        16   -> TIM_CCxChannelCmd
       8   HAL_TIMEx_HallSensor_Start_IT
         8   -> TIM_CCxChannelCmd
       8   HAL_TIMEx_HallSensor_Stop
         8   -> TIM_CCxChannelCmd
       8   HAL_TIMEx_HallSensor_Stop_DMA
         8   -> TIM_CCxChannelCmd
       8   HAL_TIMEx_HallSensor_Stop_IT
         8   -> TIM_CCxChannelCmd
       8   HAL_TIMEx_MasterConfigSynchronization
       0   HAL_TIMEx_OCN_Start
      16   HAL_TIMEx_OCN_Start_DMA
        16   -> HAL_DMA_Start_IT
       0   HAL_TIMEx_OCN_Start_IT
       0   HAL_TIMEx_OCN_Stop
       4   HAL_TIMEx_OCN_Stop_DMA
       0   HAL_TIMEx_OCN_Stop_IT
       0   HAL_TIMEx_OnePulseN_Start
       0   HAL_TIMEx_OnePulseN_Start_IT
       0   HAL_TIMEx_OnePulseN_Stop
       0   HAL_TIMEx_OnePulseN_Stop_IT
       0   HAL_TIMEx_PWMN_Start
      16   HAL_TIMEx_PWMN_Start_DMA
        16   -> HAL_DMA_Start_IT
       0   HAL_TIMEx_PWMN_Start_IT
       0   HAL_TIMEx_PWMN_Stop
       4   HAL_TIMEx_PWMN_Stop_DMA
       0   HAL_TIMEx_PWMN_Stop_IT
       0   HAL_TIMEx_RemapConfig
      16   HAL_TIM_ConfigOCrefClear
        16   -> TIM_ETR_SetConfig
       8   HAL_TIM_OC_ConfigChannel
         8   -> TIM_OC1_SetConfig
         8   -> TIM_OC2_SetConfig
         8   -> TIM_OC3_SetConfig
         8   -> TIM_OC4_SetConfig
         8   -> TIM_OC5_SetConfig
         8   -> TIM_OC6_SetConfig
      16   HAL_TIM_PWM_ConfigChannel
        16   -> TIM_OC1_SetConfig
        16   -> TIM_OC2_SetConfig
        16   -> TIM_OC3_SetConfig
        16   -> TIM_OC4_SetConfig
        16   -> TIM_OC5_SetConfig
        16   -> TIM_OC6_SetConfig
       8   TIMEx_DMACommutationCplt
         8   -> HAL_TIMEx_CommutationCallback
       8   TIM_OC5_SetConfig
       8   TIM_OC6_SetConfig


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable5
       4  ??DataTable7
       4  ??DataTable7_1
       4  ??DataTable7_2
       4  ??DataTable7_3
       4  ??DataTable7_4
       4  ??DataTable7_5
       4  ??DataTable7_6
       2  HAL_TIMEx_BreakCallback
       2  HAL_TIMEx_CommutationCallback
      84  HAL_TIMEx_ConfigBreakDeadTime
      92  HAL_TIMEx_ConfigCommutationEvent
     116  HAL_TIMEx_ConfigCommutationEvent_DMA
     100  HAL_TIMEx_ConfigCommutationEvent_IT
      58  HAL_TIMEx_GroupChannel5
      58  HAL_TIMEx_HallSensor_DeInit
       6  HAL_TIMEx_HallSensor_GetState
     180  HAL_TIMEx_HallSensor_Init
       2  HAL_TIMEx_HallSensor_MspDeInit
       2  HAL_TIMEx_HallSensor_MspInit
      28  HAL_TIMEx_HallSensor_Start
     100  HAL_TIMEx_HallSensor_Start_DMA
      36  HAL_TIMEx_HallSensor_Start_IT
      48  HAL_TIMEx_HallSensor_Stop
      56  HAL_TIMEx_HallSensor_Stop_DMA
      56  HAL_TIMEx_HallSensor_Stop_IT
      78  HAL_TIMEx_MasterConfigSynchronization
      40  HAL_TIMEx_OCN_Start
     256  HAL_TIMEx_OCN_Start_DMA
     108  HAL_TIMEx_OCN_Start_IT
      76  HAL_TIMEx_OCN_Stop
     152  HAL_TIMEx_OCN_Stop_DMA
     146  HAL_TIMEx_OCN_Stop_IT
      32  HAL_TIMEx_OnePulseN_Start
      48  HAL_TIMEx_OnePulseN_Start_IT
      76  HAL_TIMEx_OnePulseN_Stop
      92  HAL_TIMEx_OnePulseN_Stop_IT
      40  HAL_TIMEx_PWMN_Start
     256  HAL_TIMEx_PWMN_Start_DMA
     108  HAL_TIMEx_PWMN_Start_IT
      76  HAL_TIMEx_PWMN_Stop
     152  HAL_TIMEx_PWMN_Stop_DMA
     146  HAL_TIMEx_PWMN_Stop_IT
      38  HAL_TIMEx_RemapConfig
     266  HAL_TIM_ConfigOCrefClear
     118  HAL_TIM_OC_ConfigChannel
     312  HAL_TIM_PWM_ConfigChannel
      20  TIMEx_DMACommutationCplt
      70  TIM_OC5_SetConfig
      72  TIM_OC6_SetConfig

 
 3 836 bytes in section .text
 
 3 836 bytes of CODE memory

Errors: none
Warnings: 1
