###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.2.10312/W32 for ARM       27/Feb/2016  21:24:37
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_uart.c
#    Command line =  
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_uart.c
#        -D USE_HAL_DRIVER -D STM32F746xx -D USE_STM32746G_DISCO -D
#        USE_IOEXPANDER -D USE_USB_FS -lC
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
#        -lA
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
#        -o
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M7 -e --fpu=VFPv5_sp --dlib_config "D:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.3\arm\INC\c\DLib_Config_Full.h"
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\Inc\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\CMSIS\Device\ST\STM32F7xx\Include\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\STM32F7xx_HAL_Driver\Inc\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\STM32746G-Discovery\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\Components\Common\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Log\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Fonts\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\CPU\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_Device_Library\Core\Inc\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Core\Inc\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Class\MSC\Inc\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\drivers\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_Audio\Addons\PDM\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_Device_Library\Class\AUDIO\Inc\
#        -On --use_c++_inline --require_prototypes -I "D:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.3\arm\CMSIS\Include\" -D
#        ARM_MATH_CM7
#    List file    =  
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List\stm32f7xx_hal_uart.lst
#    Object file  =  
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj\stm32f7xx_hal_uart.o
#
###############################################################################

H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_uart.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f7xx_hal_uart.c
      4            * @author  MCD Application Team
      5            * @version V1.0.1
      6            * @date    25-June-2015
      7            * @brief   UART HAL module driver.
      8            *          This file provides firmware functions to manage the following 
      9            *          functionalities of the Universal Asynchronous Receiver Transmitter (UART) peripheral:
     10            *           + Initialization and de-initialization functions
     11            *           + IO operation functions
     12            *           + Peripheral Control functions  
     13            *           + Peripheral State and Errors functions  
     14            *           
     15            @verbatim       
     16            ==============================================================================
     17                                  ##### How to use this driver #####
     18            ==============================================================================
     19            [..]
     20              The UART HAL driver can be used as follows:
     21              
     22              (#) Declare a UART_HandleTypeDef handle structure.
     23            
     24              (#) Initialize the UART low level resources by implementing the HAL_UART_MspInit() API:
     25                  (##) Enable the USARTx interface clock.
     26                  (##) UART pins configuration:
     27                      (+++) Enable the clock for the UART GPIOs.
     28                      (+++) Configure these UART pins as alternate function pull-up.
     29                  (##) NVIC configuration if you need to use interrupt process (HAL_UART_Transmit_IT()
     30                       and HAL_UART_Receive_IT() APIs):
     31                      (+++) Configure the USARTx interrupt priority.
     32                      (+++) Enable the NVIC USART IRQ handle.
     33                  (##) DMA Configuration if you need to use DMA process (HAL_UART_Transmit_DMA()
     34                       and HAL_UART_Receive_DMA() APIs):
     35                      (+++) Declare a DMA handle structure for the Tx/Rx stream.
     36                      (+++) Enable the DMAx interface clock.
     37                      (+++) Configure the declared DMA handle structure with the required 
     38                            Tx/Rx parameters.                
     39                      (+++) Configure the DMA Tx/Rx Stream.
     40                      (+++) Associate the initialized DMA handle to the UART DMA Tx/Rx handle.
     41                      (+++) Configure the priority and enable the NVIC for the transfer complete 
     42                            interrupt on the DMA Tx/Rx Stream.
     43          
     44              (#) Program the Baud Rate, Word Length, Stop Bit, Parity, Hardware 
     45                  flow control and Mode(Receiver/Transmitter) in the Init structure.
     46          
     47              (#) For the UART asynchronous mode, initialize the UART registers by calling
     48                  the HAL_UART_Init() API.
     49              
     50              (#) For the UART Half duplex mode, initialize the UART registers by calling 
     51                  the HAL_HalfDuplex_Init() API.
     52              
     53              (#) For the LIN mode, initialize the UART registers by calling the HAL_LIN_Init() API.
     54              
     55              (#) For the Multi-Processor mode, initialize the UART registers by calling 
     56                  the HAL_MultiProcessor_Init() API.
     57                  
     58               [..] 
     59                 (@) The specific UART interrupts (Transmission complete interrupt, 
     60                      RXNE interrupt and Error Interrupts) will be managed using the macros
     61                      __HAL_UART_ENABLE_IT() and __HAL_UART_DISABLE_IT() inside the transmit 
     62                      and receive process.
     63                    
     64               [..] 
     65                 (@) These APIs (HAL_UART_Init() and HAL_HalfDuplex_Init()) configure also the 
     66                      low level Hardware GPIO, CLOCK, CORTEX...etc) by calling the customized 
     67                      HAL_UART_MspInit() API.
     68                    
     69               [..] 
     70                  Three operation modes are available within this driver :     
     71            
     72               *** Polling mode IO operation ***
     73               =================================
     74               [..]    
     75                 (+) Send an amount of data in blocking mode using HAL_UART_Transmit() 
     76                 (+) Receive an amount of data in blocking mode using HAL_UART_Receive()
     77                 
     78               *** Interrupt mode IO operation ***    
     79               ===================================
     80               [..]    
     81                 (+) Send an amount of data in non blocking mode using HAL_UART_Transmit_IT() 
     82                 (+) At transmission end of transfer HAL_UART_TxCpltCallback is executed and user can 
     83                      add his own code by customization of function pointer HAL_UART_TxCpltCallback
     84                 (+) Receive an amount of data in non blocking mode using HAL_UART_Receive_IT() 
     85                 (+) At reception end of transfer HAL_UART_RxCpltCallback is executed and user can 
     86                      add his own code by customization of function pointer HAL_UART_RxCpltCallback
     87                 (+) In case of transfer Error, HAL_UART_ErrorCallback() function is executed and user can 
     88                      add his own code by customization of function pointer HAL_UART_ErrorCallback
     89          
     90               *** DMA mode IO operation ***    
     91               ==============================
     92               [..] 
     93                 (+) Send an amount of data in non blocking mode (DMA) using HAL_UART_Transmit_DMA() 
     94                 (+) At transmission end of half transfer HAL_UART_TxHalfCpltCallback is executed and user can 
     95                      add his own code by customization of function pointer HAL_UART_TxHalfCpltCallback 
     96                 (+) At transmission end of transfer HAL_UART_TxCpltCallback is executed and user can 
     97                      add his own code by customization of function pointer HAL_UART_TxCpltCallback
     98                 (+) Receive an amount of data in non blocking mode (DMA) using HAL_UART_Receive_DMA() 
     99                 (+) At reception end of half transfer HAL_UART_RxHalfCpltCallback is executed and user can 
    100                      add his own code by customization of function pointer HAL_UART_RxHalfCpltCallback 
    101                 (+) At reception end of transfer HAL_UART_RxCpltCallback is executed and user can 
    102                      add his own code by customization of function pointer HAL_UART_RxCpltCallback
    103                 (+) In case of transfer Error, HAL_UART_ErrorCallback() function is executed and user can 
    104                      add his own code by customization of function pointer HAL_UART_ErrorCallback
    105                 (+) Pause the DMA Transfer using HAL_UART_DMAPause()      
    106                 (+) Resume the DMA Transfer using HAL_UART_DMAResume()  
    107                 (+) Stop the DMA Transfer using HAL_UART_DMAStop()      
    108              
    109               *** UART HAL driver macros list ***
    110               ============================================= 
    111               [..]
    112                 Below the list of most used macros in UART HAL driver.
    113                 
    114                (+) __HAL_UART_ENABLE: Enable the UART peripheral 
    115                (+) __HAL_UART_DISABLE: Disable the UART peripheral     
    116                (+) __HAL_UART_GET_FLAG : Check whether the specified UART flag is set or not
    117                (+) __HAL_UART_CLEAR_IT : Clears the specified UART ISR flag
    118                (+) __HAL_UART_ENABLE_IT: Enable the specified UART interrupt
    119                (+) __HAL_UART_DISABLE_IT: Disable the specified UART interrupt
    120                (+) __HAL_UART_GET_IT_SOURCE: Check whether the specified UART interrupt has occurred or not
    121                
    122               [..] 
    123                 (@) You can refer to the UART HAL driver header file for more useful macros 
    124                
    125            @endverbatim
    126            ******************************************************************************
    127            * @attention
    128            *
    129            * <h2><center>&copy; COPYRIGHT(c) 2015 STMicroelectronics</center></h2>
    130            *
    131            * Redistribution and use in source and binary forms, with or without modification,
    132            * are permitted provided that the following conditions are met:
    133            *   1. Redistributions of source code must retain the above copyright notice,
    134            *      this list of conditions and the following disclaimer.
    135            *   2. Redistributions in binary form must reproduce the above copyright notice,
    136            *      this list of conditions and the following disclaimer in the documentation
    137            *      and/or other materials provided with the distribution.
    138            *   3. Neither the name of STMicroelectronics nor the names of its contributors
    139            *      may be used to endorse or promote products derived from this software
    140            *      without specific prior written permission.
    141            *
    142            * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
    143            * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
    144            * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
    145            * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
    146            * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
    147            * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
    148            * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
    149            * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
    150            * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
    151            * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
    152            *
    153            ******************************************************************************
    154            */ 
    155          
    156          /* Includes ------------------------------------------------------------------*/
    157          #include "stm32f7xx_hal.h"
    158          
    159          /** @addtogroup STM32F7xx_HAL_Driver
    160            * @{
    161            */
    162          
    163          /** @defgroup UART UART
    164            * @brief HAL UART module driver
    165            * @{
    166            */
    167          #ifdef HAL_UART_MODULE_ENABLED
    168              
    169          /* Private typedef -----------------------------------------------------------*/
    170          /* Private define ------------------------------------------------------------*/
    171          #define HAL_UART_TXDMA_TIMEOUTVALUE                      22000
    172          #define UART_CR1_FIELDS  ((uint32_t)(USART_CR1_M | USART_CR1_PCE | USART_CR1_PS | \
    173                                               USART_CR1_TE | USART_CR1_RE | USART_CR1_OVER8))
    174          /* Private macro -------------------------------------------------------------*/
    175          /* Private variables ---------------------------------------------------------*/
    176          /* Private function prototypes -----------------------------------------------*/
    177          static void UART_DMATransmitCplt(DMA_HandleTypeDef *hdma);
    178          static void UART_DMAReceiveCplt(DMA_HandleTypeDef *hdma);
    179          static void UART_DMARxHalfCplt(DMA_HandleTypeDef *hdma);
    180          static void UART_DMATxHalfCplt(DMA_HandleTypeDef *hdma);
    181          static void UART_DMAError(DMA_HandleTypeDef *hdma); 
    182          static HAL_StatusTypeDef UART_Transmit_IT(UART_HandleTypeDef *huart);
    183          static HAL_StatusTypeDef UART_EndTransmit_IT(UART_HandleTypeDef *huart);
    184          static HAL_StatusTypeDef UART_Receive_IT(UART_HandleTypeDef *huart);
    185          /* Private functions ---------------------------------------------------------*/
    186          
    187          /** @defgroup UART_Exported_Functions UART Exported Functions
    188            * @{
    189            */
    190          
    191          /** @defgroup UART_Exported_Functions_Group1 Initialization and de-initialization functions 
    192            *  @brief    Initialization and Configuration functions 
    193            *
    194          @verbatim    
    195          ===============================================================================
    196                      ##### Initialization and Configuration functions #####
    197           ===============================================================================
    198              [..]
    199              This subsection provides a set of functions allowing to initialize the USARTx or the UARTy 
    200              in asynchronous mode.
    201                (+) For the asynchronous mode only these parameters can be configured: 
    202                  (++) Baud Rate
    203                  (++) Word Length 
    204                  (++) Stop Bit
    205                  (++) Parity: If the parity is enabled, then the MSB bit of the data written
    206                       in the data register is transmitted but is changed by the parity bit.
    207                       Depending on the frame length defined by the M bit (8-bits or 9-bits),
    208                       please refer to Reference manual for possible UART frame formats.           
    209                  (++) Hardware flow control
    210                  (++) Receiver/transmitter modes
    211                  (++) Over Sampling Method
    212              [..]
    213              The HAL_UART_Init(), HAL_HalfDuplex_Init(), HAL_LIN_Init() and HAL_MultiProcessor_Init() APIs 
    214              follow respectively the UART asynchronous, UART Half duplex, LIN and Multi-Processor
    215              configuration procedures (details for the procedures are available in reference manual (RM0329)).
    216          
    217          @endverbatim
    218            * @{
    219            */
    220          
    221          /**
    222            * @brief Initializes the UART mode according to the specified
    223            *         parameters in the UART_InitTypeDef and creates the associated handle .
    224            * @param huart: uart handle
    225            * @retval HAL status
    226            */

   \                                 In section .text, align 2, keep-with-next
    227          HAL_StatusTypeDef HAL_UART_Init(UART_HandleTypeDef *huart)
    228          {
   \                     HAL_UART_Init: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    229            /* Check the UART handle allocation */
    230            if(huart == NULL)
   \   00000004   0x2C00             CMP      R4,#+0
   \   00000006   0xD101             BNE.N    ??HAL_UART_Init_0
    231            {
    232              return HAL_ERROR;
   \   00000008   0x2001             MOVS     R0,#+1
   \   0000000A   0xE037             B.N      ??HAL_UART_Init_1
    233            }
    234            
    235            if(huart->Init.HwFlowCtl != UART_HWCONTROL_NONE)
   \                     ??HAL_UART_Init_0: (+1)
   \   0000000C   0x69A0             LDR      R0,[R4, #+24]
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD1FF             BNE.N    ??HAL_UART_Init_2
    236            {
    237              /* Check the parameters */
    238              assert_param(IS_UART_HWFLOW_INSTANCE(huart->Instance));
    239            }
    240            else
    241            {
    242              /* Check the parameters */
    243              assert_param(IS_UART_INSTANCE(huart->Instance));
    244            }
    245            
    246            if(huart->State == HAL_UART_STATE_RESET)
   \                     ??HAL_UART_Init_3: (+1)
   \                     ??HAL_UART_Init_2: (+1)
   \   00000012   0xF894 0x0069      LDRB     R0,[R4, #+105]
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD105             BNE.N    ??HAL_UART_Init_4
    247            {
    248              /* Allocate lock resource and initialize it */
    249              huart->Lock = HAL_UNLOCKED;
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0xF884 0x0068      STRB     R0,[R4, #+104]
    250          
    251              /* Init the low level hardware : GPIO, CLOCK */
    252              HAL_UART_MspInit(huart);
   \   00000020   0x0020             MOVS     R0,R4
   \   00000022   0x.... 0x....      BL       HAL_UART_MspInit
    253            }
    254          
    255            huart->State = HAL_UART_STATE_BUSY;
   \                     ??HAL_UART_Init_4: (+1)
   \   00000026   0x2002             MOVS     R0,#+2
   \   00000028   0xF884 0x0069      STRB     R0,[R4, #+105]
    256          
    257            /* Disable the Peripheral */
    258            __HAL_UART_DISABLE(huart);
   \   0000002C   0x6820             LDR      R0,[R4, #+0]
   \   0000002E   0x6800             LDR      R0,[R0, #+0]
   \   00000030   0x0840             LSRS     R0,R0,#+1
   \   00000032   0x0040             LSLS     R0,R0,#+1
   \   00000034   0x6821             LDR      R1,[R4, #+0]
   \   00000036   0x6008             STR      R0,[R1, #+0]
    259            
    260            /* Set the UART Communication parameters */
    261            if (UART_SetConfig(huart) == HAL_ERROR)
   \   00000038   0x0020             MOVS     R0,R4
   \   0000003A   0x.... 0x....      BL       UART_SetConfig
   \   0000003E   0x2801             CMP      R0,#+1
   \   00000040   0xD101             BNE.N    ??HAL_UART_Init_5
    262            {
    263              return HAL_ERROR;
   \   00000042   0x2001             MOVS     R0,#+1
   \   00000044   0xE01A             B.N      ??HAL_UART_Init_1
    264            }
    265          
    266            if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
   \                     ??HAL_UART_Init_5: (+1)
   \   00000046   0x6A60             LDR      R0,[R4, #+36]
   \   00000048   0x2800             CMP      R0,#+0
   \   0000004A   0xD002             BEQ.N    ??HAL_UART_Init_6
    267            {
    268              UART_AdvFeatureConfig(huart);
   \   0000004C   0x0020             MOVS     R0,R4
   \   0000004E   0x.... 0x....      BL       UART_AdvFeatureConfig
    269            }
    270          
    271            /* In asynchronous mode, the following bits must be kept cleared:
    272            - LINEN and CLKEN bits in the USART_CR2 register,
    273            - SCEN, HDSEL and IREN  bits in the USART_CR3 register.*/
    274            huart->Instance->CR2 &= ~(USART_CR2_LINEN | USART_CR2_CLKEN);
   \                     ??HAL_UART_Init_6: (+1)
   \   00000052   0x6820             LDR      R0,[R4, #+0]
   \   00000054   0x6840             LDR      R0,[R0, #+4]
   \   00000056   0xF430 0x4090      BICS     R0,R0,#0x4800
   \   0000005A   0x6821             LDR      R1,[R4, #+0]
   \   0000005C   0x6048             STR      R0,[R1, #+4]
    275            huart->Instance->CR3 &= ~(USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN);
   \   0000005E   0x6820             LDR      R0,[R4, #+0]
   \   00000060   0x6880             LDR      R0,[R0, #+8]
   \   00000062   0xF030 0x002A      BICS     R0,R0,#0x2A
   \   00000066   0x6821             LDR      R1,[R4, #+0]
   \   00000068   0x6088             STR      R0,[R1, #+8]
    276          
    277            /* Enable the Peripheral */
    278            __HAL_UART_ENABLE(huart);
   \   0000006A   0x6820             LDR      R0,[R4, #+0]
   \   0000006C   0x6800             LDR      R0,[R0, #+0]
   \   0000006E   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000072   0x6821             LDR      R1,[R4, #+0]
   \   00000074   0x6008             STR      R0,[R1, #+0]
    279          
    280            /* TEACK and/or REACK to check before moving huart->State to Ready */
    281            return (UART_CheckIdleState(huart));
   \   00000076   0x0020             MOVS     R0,R4
   \   00000078   0x.... 0x....      BL       UART_CheckIdleState
   \                     ??HAL_UART_Init_1: (+1)
   \   0000007C   0xBD10             POP      {R4,PC}          ;; return
    282          }
    283          
    284          /**
    285            * @brief Initializes the half-duplex mode according to the specified
    286            *         parameters in the UART_InitTypeDef and creates the associated handle .
    287            * @param huart: UART handle
    288            * @retval HAL status
    289            */

   \                                 In section .text, align 2, keep-with-next
    290          HAL_StatusTypeDef HAL_HalfDuplex_Init(UART_HandleTypeDef *huart)
    291          {
   \                     HAL_HalfDuplex_Init: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    292            /* Check the UART handle allocation */
    293            if(huart == NULL)
   \   00000004   0x2C00             CMP      R4,#+0
   \   00000006   0xD101             BNE.N    ??HAL_HalfDuplex_Init_0
    294            {
    295              return HAL_ERROR;
   \   00000008   0x2001             MOVS     R0,#+1
   \   0000000A   0xE03A             B.N      ??HAL_HalfDuplex_Init_1
    296            }
    297            
    298            if(huart->State == HAL_UART_STATE_RESET)
   \                     ??HAL_HalfDuplex_Init_0: (+1)
   \   0000000C   0xF894 0x0069      LDRB     R0,[R4, #+105]
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD105             BNE.N    ??HAL_HalfDuplex_Init_2
    299            {
    300              /* Allocate lock resource and initialize it */
    301              huart->Lock = HAL_UNLOCKED;
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0xF884 0x0068      STRB     R0,[R4, #+104]
    302              /* Init the low level hardware : GPIO, CLOCK */
    303              HAL_UART_MspInit(huart);
   \   0000001A   0x0020             MOVS     R0,R4
   \   0000001C   0x.... 0x....      BL       HAL_UART_MspInit
    304            }
    305          
    306            huart->State = HAL_UART_STATE_BUSY;
   \                     ??HAL_HalfDuplex_Init_2: (+1)
   \   00000020   0x2002             MOVS     R0,#+2
   \   00000022   0xF884 0x0069      STRB     R0,[R4, #+105]
    307          
    308            /* Disable the Peripheral */
    309            __HAL_UART_DISABLE(huart);
   \   00000026   0x6820             LDR      R0,[R4, #+0]
   \   00000028   0x6800             LDR      R0,[R0, #+0]
   \   0000002A   0x0840             LSRS     R0,R0,#+1
   \   0000002C   0x0040             LSLS     R0,R0,#+1
   \   0000002E   0x6821             LDR      R1,[R4, #+0]
   \   00000030   0x6008             STR      R0,[R1, #+0]
    310          
    311            /* Set the UART Communication parameters */
    312            if (UART_SetConfig(huart) == HAL_ERROR)
   \   00000032   0x0020             MOVS     R0,R4
   \   00000034   0x.... 0x....      BL       UART_SetConfig
   \   00000038   0x2801             CMP      R0,#+1
   \   0000003A   0xD101             BNE.N    ??HAL_HalfDuplex_Init_3
    313            {
    314              return HAL_ERROR;
   \   0000003C   0x2001             MOVS     R0,#+1
   \   0000003E   0xE020             B.N      ??HAL_HalfDuplex_Init_1
    315            }
    316          
    317            if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
   \                     ??HAL_HalfDuplex_Init_3: (+1)
   \   00000040   0x6A60             LDR      R0,[R4, #+36]
   \   00000042   0x2800             CMP      R0,#+0
   \   00000044   0xD002             BEQ.N    ??HAL_HalfDuplex_Init_4
    318            {
    319              UART_AdvFeatureConfig(huart);
   \   00000046   0x0020             MOVS     R0,R4
   \   00000048   0x.... 0x....      BL       UART_AdvFeatureConfig
    320            }
    321          
    322            /* In half-duplex mode, the following bits must be kept cleared:
    323            - LINEN and CLKEN bits in the USART_CR2 register,
    324            - SCEN and IREN bits in the USART_CR3 register.*/
    325            huart->Instance->CR2 &= ~(USART_CR2_LINEN | USART_CR2_CLKEN);
   \                     ??HAL_HalfDuplex_Init_4: (+1)
   \   0000004C   0x6820             LDR      R0,[R4, #+0]
   \   0000004E   0x6840             LDR      R0,[R0, #+4]
   \   00000050   0xF430 0x4090      BICS     R0,R0,#0x4800
   \   00000054   0x6821             LDR      R1,[R4, #+0]
   \   00000056   0x6048             STR      R0,[R1, #+4]
    326            huart->Instance->CR3 &= ~(USART_CR3_IREN | USART_CR3_SCEN);
   \   00000058   0x6820             LDR      R0,[R4, #+0]
   \   0000005A   0x6880             LDR      R0,[R0, #+8]
   \   0000005C   0xF030 0x0022      BICS     R0,R0,#0x22
   \   00000060   0x6821             LDR      R1,[R4, #+0]
   \   00000062   0x6088             STR      R0,[R1, #+8]
    327          
    328            /* Enable the Half-Duplex mode by setting the HDSEL bit in the CR3 register */
    329            huart->Instance->CR3 |= USART_CR3_HDSEL;
   \   00000064   0x6820             LDR      R0,[R4, #+0]
   \   00000066   0x6880             LDR      R0,[R0, #+8]
   \   00000068   0xF050 0x0008      ORRS     R0,R0,#0x8
   \   0000006C   0x6821             LDR      R1,[R4, #+0]
   \   0000006E   0x6088             STR      R0,[R1, #+8]
    330          
    331            /* Enable the Peripheral */
    332            __HAL_UART_ENABLE(huart);
   \   00000070   0x6820             LDR      R0,[R4, #+0]
   \   00000072   0x6800             LDR      R0,[R0, #+0]
   \   00000074   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000078   0x6821             LDR      R1,[R4, #+0]
   \   0000007A   0x6008             STR      R0,[R1, #+0]
    333          
    334            /* TEACK and/or REACK to check before moving huart->State to Ready */
    335            return (UART_CheckIdleState(huart));
   \   0000007C   0x0020             MOVS     R0,R4
   \   0000007E   0x.... 0x....      BL       UART_CheckIdleState
   \                     ??HAL_HalfDuplex_Init_1: (+1)
   \   00000082   0xBD10             POP      {R4,PC}          ;; return
    336          }
    337          
    338          
    339          /**
    340            * @brief Initializes the LIN mode according to the specified
    341            *         parameters in the UART_InitTypeDef and creates the associated handle .
    342            * @param huart: uart handle
    343            * @param BreakDetectLength: specifies the LIN break detection length.
    344            *        This parameter can be one of the following values:
    345            *          @arg UART_LINBREAKDETECTLENGTH_10B: 10-bit break detection
    346            *          @arg UART_LINBREAKDETECTLENGTH_11B: 11-bit break detection
    347            * @retval HAL status
    348            */

   \                                 In section .text, align 2, keep-with-next
    349          HAL_StatusTypeDef HAL_LIN_Init(UART_HandleTypeDef *huart, uint32_t BreakDetectLength)
    350          {
   \                     HAL_LIN_Init: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    351            /* Check the UART handle allocation */
    352            if(huart == NULL)
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD101             BNE.N    ??HAL_LIN_Init_0
    353            {
    354              return HAL_ERROR;
   \   0000000A   0x2001             MOVS     R0,#+1
   \   0000000C   0xE041             B.N      ??HAL_LIN_Init_1
    355            }
    356          
    357            /* Check the parameters */
    358            assert_param(IS_UART_INSTANCE(huart->Instance));
    359            assert_param(IS_UART_LIN_BREAK_DETECT_LENGTH(BreakDetectLength));
    360            assert_param(IS_LIN_WORD_LENGTH(huart->Init.WordLength));
    361            	
    362            if(huart->State == HAL_UART_STATE_RESET)
   \                     ??HAL_LIN_Init_0: (+1)
   \   0000000E   0xF894 0x0069      LDRB     R0,[R4, #+105]
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD105             BNE.N    ??HAL_LIN_Init_2
    363            {  
    364              /* Allocate lock resource and initialize it */
    365              huart->Lock = HAL_UNLOCKED; 
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0xF884 0x0068      STRB     R0,[R4, #+104]
    366              /* Init the low level hardware : GPIO, CLOCK */
    367              HAL_UART_MspInit(huart);
   \   0000001C   0x0020             MOVS     R0,R4
   \   0000001E   0x.... 0x....      BL       HAL_UART_MspInit
    368            }
    369            
    370            huart->State = HAL_UART_STATE_BUSY;
   \                     ??HAL_LIN_Init_2: (+1)
   \   00000022   0x2002             MOVS     R0,#+2
   \   00000024   0xF884 0x0069      STRB     R0,[R4, #+105]
    371            
    372            /* Disable the Peripheral */
    373            __HAL_UART_DISABLE(huart);
   \   00000028   0x6820             LDR      R0,[R4, #+0]
   \   0000002A   0x6800             LDR      R0,[R0, #+0]
   \   0000002C   0x0840             LSRS     R0,R0,#+1
   \   0000002E   0x0040             LSLS     R0,R0,#+1
   \   00000030   0x6821             LDR      R1,[R4, #+0]
   \   00000032   0x6008             STR      R0,[R1, #+0]
    374            
    375            /* Set the UART Communication parameters */
    376            if (UART_SetConfig(huart) == HAL_ERROR)
   \   00000034   0x0020             MOVS     R0,R4
   \   00000036   0x.... 0x....      BL       UART_SetConfig
   \   0000003A   0x2801             CMP      R0,#+1
   \   0000003C   0xD101             BNE.N    ??HAL_LIN_Init_3
    377            {
    378              return HAL_ERROR;
   \   0000003E   0x2001             MOVS     R0,#+1
   \   00000040   0xE027             B.N      ??HAL_LIN_Init_1
    379            } 
    380            
    381            if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
   \                     ??HAL_LIN_Init_3: (+1)
   \   00000042   0x6A60             LDR      R0,[R4, #+36]
   \   00000044   0x2800             CMP      R0,#+0
   \   00000046   0xD002             BEQ.N    ??HAL_LIN_Init_4
    382            {
    383              UART_AdvFeatureConfig(huart);
   \   00000048   0x0020             MOVS     R0,R4
   \   0000004A   0x.... 0x....      BL       UART_AdvFeatureConfig
    384            }
    385            
    386            /* In LIN mode, the following bits must be kept cleared: 
    387            - LINEN and CLKEN bits in the USART_CR2 register,
    388            - SCEN and IREN bits in the USART_CR3 register.*/
    389            huart->Instance->CR2 &= ~(USART_CR2_CLKEN);
   \                     ??HAL_LIN_Init_4: (+1)
   \   0000004E   0x6820             LDR      R0,[R4, #+0]
   \   00000050   0x6840             LDR      R0,[R0, #+4]
   \   00000052   0xF430 0x6000      BICS     R0,R0,#0x800
   \   00000056   0x6821             LDR      R1,[R4, #+0]
   \   00000058   0x6048             STR      R0,[R1, #+4]
    390            huart->Instance->CR3 &= ~(USART_CR3_HDSEL | USART_CR3_IREN | USART_CR3_SCEN);
   \   0000005A   0x6820             LDR      R0,[R4, #+0]
   \   0000005C   0x6880             LDR      R0,[R0, #+8]
   \   0000005E   0xF030 0x002A      BICS     R0,R0,#0x2A
   \   00000062   0x6821             LDR      R1,[R4, #+0]
   \   00000064   0x6088             STR      R0,[R1, #+8]
    391            
    392            /* Enable the LIN mode by setting the LINEN bit in the CR2 register */
    393            huart->Instance->CR2 |= USART_CR2_LINEN;
   \   00000066   0x6820             LDR      R0,[R4, #+0]
   \   00000068   0x6840             LDR      R0,[R0, #+4]
   \   0000006A   0xF450 0x4080      ORRS     R0,R0,#0x4000
   \   0000006E   0x6821             LDR      R1,[R4, #+0]
   \   00000070   0x6048             STR      R0,[R1, #+4]
    394            
    395            /* Set the USART LIN Break detection length. */
    396            MODIFY_REG(huart->Instance->CR2, USART_CR2_LBDL, BreakDetectLength);
   \   00000072   0x6820             LDR      R0,[R4, #+0]
   \   00000074   0x6840             LDR      R0,[R0, #+4]
   \   00000076   0xF030 0x0020      BICS     R0,R0,#0x20
   \   0000007A   0x4328             ORRS     R0,R5,R0
   \   0000007C   0x6821             LDR      R1,[R4, #+0]
   \   0000007E   0x6048             STR      R0,[R1, #+4]
    397            
    398              /* Enable the Peripheral */
    399            __HAL_UART_ENABLE(huart);
   \   00000080   0x6820             LDR      R0,[R4, #+0]
   \   00000082   0x6800             LDR      R0,[R0, #+0]
   \   00000084   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000088   0x6821             LDR      R1,[R4, #+0]
   \   0000008A   0x6008             STR      R0,[R1, #+0]
    400            
    401            /* TEACK and/or REACK to check before moving huart->State to Ready */
    402            return (UART_CheckIdleState(huart));
   \   0000008C   0x0020             MOVS     R0,R4
   \   0000008E   0x.... 0x....      BL       UART_CheckIdleState
   \                     ??HAL_LIN_Init_1: (+1)
   \   00000092   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    403          }
    404          
    405          
    406          
    407          /**
    408            * @brief Initializes the multiprocessor mode according to the specified
    409            *         parameters in the UART_InitTypeDef and creates the associated handle.
    410            * @param huart: UART handle   
    411            * @param Address: UART node address (4-, 6-, 7- or 8-bit long)
    412            * @param WakeUpMethod: specifies the UART wakeup method.
    413            *        This parameter can be one of the following values:
    414            *          @arg UART_WAKEUPMETHOD_IDLELINE: WakeUp by an idle line detection
    415            *          @arg UART_WAKEUPMETHOD_ADDRESSMARK: WakeUp by an address mark
    416            * @note  If the user resorts to idle line detection wake up, the Address parameter
    417            *        is useless and ignored by the initialization function.               
    418            * @note  If the user resorts to address mark wake up, the address length detection 
    419            *        is configured by default to 4 bits only. For the UART to be able to 
    420            *        manage 6-, 7- or 8-bit long addresses detection                    
    421            * @retval HAL status
    422            */

   \                                 In section .text, align 2, keep-with-next
    423          HAL_StatusTypeDef HAL_MultiProcessor_Init(UART_HandleTypeDef *huart, uint8_t Address, uint32_t WakeUpMethod)
    424          {
   \                     HAL_MultiProcessor_Init: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    425            /* Check the UART handle allocation */
    426            if(huart == NULL)
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD101             BNE.N    ??HAL_MultiProcessor_Init_0
    427            {
    428              return HAL_ERROR;
   \   0000000C   0x2001             MOVS     R0,#+1
   \   0000000E   0xE047             B.N      ??HAL_MultiProcessor_Init_1
    429            }
    430          
    431            /* Check the wake up method parameter */
    432            assert_param(IS_UART_WAKEUPMETHOD(WakeUpMethod));
    433            
    434            if(huart->State == HAL_UART_STATE_RESET)
   \                     ??HAL_MultiProcessor_Init_0: (+1)
   \   00000010   0xF894 0x0069      LDRB     R0,[R4, #+105]
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD105             BNE.N    ??HAL_MultiProcessor_Init_2
    435            { 
    436              /* Allocate lock resource and initialize it */
    437              huart->Lock = HAL_UNLOCKED;  
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0xF884 0x0068      STRB     R0,[R4, #+104]
    438              /* Init the low level hardware : GPIO, CLOCK */
    439              HAL_UART_MspInit(huart);
   \   0000001E   0x0020             MOVS     R0,R4
   \   00000020   0x.... 0x....      BL       HAL_UART_MspInit
    440            }
    441            
    442            huart->State = HAL_UART_STATE_BUSY;
   \                     ??HAL_MultiProcessor_Init_2: (+1)
   \   00000024   0x2002             MOVS     R0,#+2
   \   00000026   0xF884 0x0069      STRB     R0,[R4, #+105]
    443            
    444            /* Disable the Peripheral */
    445            __HAL_UART_DISABLE(huart);
   \   0000002A   0x6820             LDR      R0,[R4, #+0]
   \   0000002C   0x6800             LDR      R0,[R0, #+0]
   \   0000002E   0x0840             LSRS     R0,R0,#+1
   \   00000030   0x0040             LSLS     R0,R0,#+1
   \   00000032   0x6821             LDR      R1,[R4, #+0]
   \   00000034   0x6008             STR      R0,[R1, #+0]
    446            
    447            /* Set the UART Communication parameters */
    448            if (UART_SetConfig(huart) == HAL_ERROR)
   \   00000036   0x0020             MOVS     R0,R4
   \   00000038   0x.... 0x....      BL       UART_SetConfig
   \   0000003C   0x2801             CMP      R0,#+1
   \   0000003E   0xD101             BNE.N    ??HAL_MultiProcessor_Init_3
    449            {
    450              return HAL_ERROR;
   \   00000040   0x2001             MOVS     R0,#+1
   \   00000042   0xE02D             B.N      ??HAL_MultiProcessor_Init_1
    451            } 
    452            
    453            if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
   \                     ??HAL_MultiProcessor_Init_3: (+1)
   \   00000044   0x6A60             LDR      R0,[R4, #+36]
   \   00000046   0x2800             CMP      R0,#+0
   \   00000048   0xD002             BEQ.N    ??HAL_MultiProcessor_Init_4
    454            {
    455              UART_AdvFeatureConfig(huart);
   \   0000004A   0x0020             MOVS     R0,R4
   \   0000004C   0x.... 0x....      BL       UART_AdvFeatureConfig
    456            }
    457            
    458            /* In multiprocessor mode, the following bits must be kept cleared: 
    459            - LINEN and CLKEN bits in the USART_CR2 register,
    460            - SCEN, HDSEL and IREN  bits in the USART_CR3 register. */
    461            huart->Instance->CR2 &= ~(USART_CR2_LINEN | USART_CR2_CLKEN);
   \                     ??HAL_MultiProcessor_Init_4: (+1)
   \   00000050   0x6820             LDR      R0,[R4, #+0]
   \   00000052   0x6840             LDR      R0,[R0, #+4]
   \   00000054   0xF430 0x4090      BICS     R0,R0,#0x4800
   \   00000058   0x6821             LDR      R1,[R4, #+0]
   \   0000005A   0x6048             STR      R0,[R1, #+4]
    462            huart->Instance->CR3 &= ~(USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN);
   \   0000005C   0x6820             LDR      R0,[R4, #+0]
   \   0000005E   0x6880             LDR      R0,[R0, #+8]
   \   00000060   0xF030 0x002A      BICS     R0,R0,#0x2A
   \   00000064   0x6821             LDR      R1,[R4, #+0]
   \   00000066   0x6088             STR      R0,[R1, #+8]
    463            
    464            if (WakeUpMethod == UART_WAKEUPMETHOD_ADDRESSMARK)
   \   00000068   0xF5B6 0x6F00      CMP      R6,#+2048
   \   0000006C   0xD108             BNE.N    ??HAL_MultiProcessor_Init_5
    465            {
    466              /* If address mark wake up method is chosen, set the USART address node */
    467              MODIFY_REG(huart->Instance->CR2, USART_CR2_ADD, ((uint32_t)Address << UART_CR2_ADDRESS_LSB_POS));
   \   0000006E   0x6820             LDR      R0,[R4, #+0]
   \   00000070   0x6840             LDR      R0,[R0, #+4]
   \   00000072   0x0200             LSLS     R0,R0,#+8        ;; ZeroExtS R0,R0,#+8,#+8
   \   00000074   0x0A00             LSRS     R0,R0,#+8
   \   00000076   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000078   0xEA50 0x6005      ORRS     R0,R0,R5, LSL #+24
   \   0000007C   0x6821             LDR      R1,[R4, #+0]
   \   0000007E   0x6048             STR      R0,[R1, #+4]
    468            }
    469            
    470            /* Set the wake up method by setting the WAKE bit in the CR1 register */
    471            MODIFY_REG(huart->Instance->CR1, USART_CR1_WAKE, WakeUpMethod);
   \                     ??HAL_MultiProcessor_Init_5: (+1)
   \   00000080   0x6820             LDR      R0,[R4, #+0]
   \   00000082   0x6800             LDR      R0,[R0, #+0]
   \   00000084   0xF430 0x6000      BICS     R0,R0,#0x800
   \   00000088   0x4330             ORRS     R0,R6,R0
   \   0000008A   0x6821             LDR      R1,[R4, #+0]
   \   0000008C   0x6008             STR      R0,[R1, #+0]
    472            
    473            /* Enable the Peripheral */
    474            __HAL_UART_ENABLE(huart); 
   \   0000008E   0x6820             LDR      R0,[R4, #+0]
   \   00000090   0x6800             LDR      R0,[R0, #+0]
   \   00000092   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000096   0x6821             LDR      R1,[R4, #+0]
   \   00000098   0x6008             STR      R0,[R1, #+0]
    475            
    476            /* TEACK and/or REACK to check before moving huart->State to Ready */
    477            return (UART_CheckIdleState(huart));
   \   0000009A   0x0020             MOVS     R0,R4
   \   0000009C   0x.... 0x....      BL       UART_CheckIdleState
   \                     ??HAL_MultiProcessor_Init_1: (+1)
   \   000000A0   0xBD70             POP      {R4-R6,PC}       ;; return
    478          }
    479          
    480          
    481          
    482          
    483          /**
    484            * @brief DeInitializes the UART peripheral 
    485            * @param huart: uart handle
    486            * @retval HAL status
    487            */

   \                                 In section .text, align 2, keep-with-next
    488          HAL_StatusTypeDef HAL_UART_DeInit(UART_HandleTypeDef *huart)
    489          {
   \                     HAL_UART_DeInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    490            /* Check the UART handle allocation */
    491            if(huart == NULL)
   \   00000004   0x2C00             CMP      R4,#+0
   \   00000006   0xD101             BNE.N    ??HAL_UART_DeInit_0
    492            {
    493              return HAL_ERROR;
   \   00000008   0x2001             MOVS     R0,#+1
   \   0000000A   0xE01D             B.N      ??HAL_UART_DeInit_1
    494            }
    495            
    496            /* Check the parameters */
    497            assert_param(IS_UART_INSTANCE(huart->Instance));
    498          
    499            huart->State = HAL_UART_STATE_BUSY;
   \                     ??HAL_UART_DeInit_0: (+1)
   \   0000000C   0x2002             MOVS     R0,#+2
   \   0000000E   0xF884 0x0069      STRB     R0,[R4, #+105]
    500            
    501            /* Disable the Peripheral */
    502            __HAL_UART_DISABLE(huart);
   \   00000012   0x6820             LDR      R0,[R4, #+0]
   \   00000014   0x6800             LDR      R0,[R0, #+0]
   \   00000016   0x0840             LSRS     R0,R0,#+1
   \   00000018   0x0040             LSLS     R0,R0,#+1
   \   0000001A   0x6821             LDR      R1,[R4, #+0]
   \   0000001C   0x6008             STR      R0,[R1, #+0]
    503            
    504            huart->Instance->CR1 = 0x0;
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0x6821             LDR      R1,[R4, #+0]
   \   00000022   0x6008             STR      R0,[R1, #+0]
    505            huart->Instance->CR2 = 0x0;
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0x6821             LDR      R1,[R4, #+0]
   \   00000028   0x6048             STR      R0,[R1, #+4]
    506            huart->Instance->CR3 = 0x0;
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0x6821             LDR      R1,[R4, #+0]
   \   0000002E   0x6088             STR      R0,[R1, #+8]
    507            
    508            /* DeInit the low level hardware */
    509            HAL_UART_MspDeInit(huart);
   \   00000030   0x0020             MOVS     R0,R4
   \   00000032   0x.... 0x....      BL       HAL_UART_MspDeInit
    510          
    511            huart->ErrorCode = HAL_UART_ERROR_NONE;
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0x66E0             STR      R0,[R4, #+108]
    512            huart->State = HAL_UART_STATE_RESET;
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0xF884 0x0069      STRB     R0,[R4, #+105]
    513            
    514            /* Process Unlock */
    515            __HAL_UNLOCK(huart);
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0xF884 0x0068      STRB     R0,[R4, #+104]
    516            
    517            return HAL_OK;
   \   00000046   0x2000             MOVS     R0,#+0
   \                     ??HAL_UART_DeInit_1: (+1)
   \   00000048   0xBD10             POP      {R4,PC}          ;; return
    518          }
    519          
    520          /**
    521            * @brief UART MSP Init
    522            * @param huart: uart handle
    523            * @retval None
    524            */

   \                                 In section .text, align 2, keep-with-next
    525           __weak void HAL_UART_MspInit(UART_HandleTypeDef *huart)
    526          {
    527            /* NOTE : This function should not be modified, when the callback is needed,
    528                      the HAL_UART_MspInit can be implemented in the user file
    529             */ 
    530          }
   \                     HAL_UART_MspInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    531          
    532          /**
    533            * @brief UART MSP DeInit
    534            * @param huart: uart handle
    535            * @retval None
    536            */

   \                                 In section .text, align 2, keep-with-next
    537           __weak void HAL_UART_MspDeInit(UART_HandleTypeDef *huart)
    538          {
    539            /* NOTE : This function should not be modified, when the callback is needed,
    540                      the HAL_UART_MspDeInit can be implemented in the user file
    541             */ 
    542          }
   \                     HAL_UART_MspDeInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    543          
    544          /**
    545            * @}
    546            */
    547          
    548          /** @defgroup UART_Exported_Functions_Group2 IO operation functions 
    549            *  @brief UART Transmit/Receive functions 
    550            *
    551          @verbatim   
    552           ===============================================================================
    553                                ##### IO operation functions #####
    554           ===============================================================================
    555              This subsection provides a set of functions allowing to manage the UART asynchronous
    556              and Half duplex data transfers.
    557          
    558              (#) There are two mode of transfer:
    559                 (+) Blocking mode: The communication is performed in polling mode. 
    560                      The HAL status of all data processing is returned by the same function 
    561                      after finishing transfer.  
    562                 (+) No-Blocking mode: The communication is performed using Interrupts 
    563                     or DMA, These API's return the HAL status.
    564                     The end of the data processing will be indicated through the 
    565                     dedicated UART IRQ when using Interrupt mode or the DMA IRQ when 
    566                     using DMA mode.
    567                     The HAL_UART_TxCpltCallback(), HAL_UART_RxCpltCallback() user callbacks 
    568                     will be executed respectively at the end of the transmit or Receive process
    569                     The HAL_UART_ErrorCallback()user callback will be executed when a communication error is detected
    570          
    571              (#) Blocking mode API's are :
    572                  (+) HAL_UART_Transmit()
    573                  (+) HAL_UART_Receive() 
    574                  
    575              (#) Non-Blocking mode API's with Interrupt are :
    576                  (+) HAL_UART_Transmit_IT()
    577                  (+) HAL_UART_Receive_IT()
    578                  (+) HAL_UART_IRQHandler()
    579                  (+) UART_Transmit_IT()
    580                  (+) UART_Receive_IT()
    581          
    582              (#) No-Blocking mode API's with DMA are :
    583                  (+) HAL_UART_Transmit_DMA()
    584                  (+) HAL_UART_Receive_DMA()
    585                  (+) HAL_UART_DMAPause()
    586                  (+) HAL_UART_DMAResume()
    587                  (+) HAL_UART_DMAStop()
    588          
    589              (#) A set of Transfer Complete Callbacks are provided in No_Blocking mode:
    590                  (+) HAL_UART_TxHalfCpltCallback()
    591                  (+) HAL_UART_TxCpltCallback()
    592                  (+) HAL_UART_RxHalfCpltCallback()
    593                  (+) HAL_UART_RxCpltCallback()
    594                  (+) HAL_UART_ErrorCallback()
    595          
    596          
    597              -@- In the Half duplex communication, it is forbidden to run the transmit 
    598                  and receive process in parallel, the UART state HAL_UART_STATE_BUSY_TX_RX can't be useful.
    599          
    600          @endverbatim
    601            * @{
    602            */
    603          
    604          /**
    605            * @brief Send an amount of data in blocking mode 
    606            * @param huart: uart handle
    607            * @param pData: pointer to data buffer
    608            * @param Size: amount of data to be sent
    609            * @param Timeout : Timeout duration
    610            * @retval HAL status
    611            */

   \                                 In section .text, align 2, keep-with-next
    612          HAL_StatusTypeDef HAL_UART_Transmit(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size, uint32_t Timeout)
    613          {
   \                     HAL_UART_Transmit: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
    614             uint16_t* tmp;
    615          
    616            if((huart->State == HAL_UART_STATE_READY) || (huart->State == HAL_UART_STATE_BUSY_RX))
   \   0000000C   0xF894 0x0069      LDRB     R0,[R4, #+105]
   \   00000010   0x2801             CMP      R0,#+1
   \   00000012   0xD003             BEQ.N    ??HAL_UART_Transmit_0
   \   00000014   0xF894 0x0069      LDRB     R0,[R4, #+105]
   \   00000018   0x2822             CMP      R0,#+34
   \   0000001A   0xD162             BNE.N    ??HAL_UART_Transmit_1
    617            {
    618              if((pData == NULL ) || (Size == 0))
   \                     ??HAL_UART_Transmit_0: (+1)
   \   0000001C   0x2D00             CMP      R5,#+0
   \   0000001E   0xD002             BEQ.N    ??HAL_UART_Transmit_2
   \   00000020   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000022   0x2E00             CMP      R6,#+0
   \   00000024   0xD101             BNE.N    ??HAL_UART_Transmit_3
    619              {
    620                return  HAL_ERROR;
   \                     ??HAL_UART_Transmit_2: (+1)
   \   00000026   0x2001             MOVS     R0,#+1
   \   00000028   0xE05C             B.N      ??HAL_UART_Transmit_4
    621              }
    622          
    623              /* Process Locked */
    624              __HAL_LOCK(huart);
   \                     ??HAL_UART_Transmit_3: (+1)
   \   0000002A   0xF894 0x0068      LDRB     R0,[R4, #+104]
   \   0000002E   0x2801             CMP      R0,#+1
   \   00000030   0xD101             BNE.N    ??HAL_UART_Transmit_5
   \   00000032   0x2002             MOVS     R0,#+2
   \   00000034   0xE056             B.N      ??HAL_UART_Transmit_4
   \                     ??HAL_UART_Transmit_5: (+1)
   \   00000036   0x2001             MOVS     R0,#+1
   \   00000038   0xF884 0x0068      STRB     R0,[R4, #+104]
    625          
    626              huart->ErrorCode = HAL_UART_ERROR_NONE;
   \   0000003C   0x2000             MOVS     R0,#+0
   \   0000003E   0x66E0             STR      R0,[R4, #+108]
    627              /* Check if a non-blocking receive process is ongoing or not */
    628              if(huart->State == HAL_UART_STATE_BUSY_RX) 
   \   00000040   0xF894 0x0069      LDRB     R0,[R4, #+105]
   \   00000044   0x2822             CMP      R0,#+34
   \   00000046   0xD103             BNE.N    ??HAL_UART_Transmit_6
    629              {
    630                huart->State = HAL_UART_STATE_BUSY_TX_RX;
   \   00000048   0x2032             MOVS     R0,#+50
   \   0000004A   0xF884 0x0069      STRB     R0,[R4, #+105]
   \   0000004E   0xE002             B.N      ??HAL_UART_Transmit_7
    631              }
    632              else
    633              {
    634                huart->State = HAL_UART_STATE_BUSY_TX;
   \                     ??HAL_UART_Transmit_6: (+1)
   \   00000050   0x2012             MOVS     R0,#+18
   \   00000052   0xF884 0x0069      STRB     R0,[R4, #+105]
    635              }
    636          
    637              huart->TxXferSize = Size;
   \                     ??HAL_UART_Transmit_7: (+1)
   \   00000056   0xF8A4 0x6050      STRH     R6,[R4, #+80]
    638              huart->TxXferCount = Size;
   \   0000005A   0xF8A4 0x6052      STRH     R6,[R4, #+82]
    639              while(huart->TxXferCount > 0)
   \                     ??HAL_UART_Transmit_8: (+1)
   \   0000005E   0xF8B4 0x0052      LDRH     R0,[R4, #+82]
   \   00000062   0x2800             CMP      R0,#+0
   \   00000064   0xD023             BEQ.N    ??HAL_UART_Transmit_9
    640              {
    641                huart->TxXferCount--;
   \   00000066   0xF8B4 0x0052      LDRH     R0,[R4, #+82]
   \   0000006A   0x1E40             SUBS     R0,R0,#+1
   \   0000006C   0xF8A4 0x0052      STRH     R0,[R4, #+82]
    642                  if(UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, Timeout) != HAL_OK)  
   \   00000070   0x003B             MOVS     R3,R7
   \   00000072   0x2200             MOVS     R2,#+0
   \   00000074   0x2180             MOVS     R1,#+128
   \   00000076   0x0020             MOVS     R0,R4
   \   00000078   0x.... 0x....      BL       UART_WaitOnFlagUntilTimeout
   \   0000007C   0x2800             CMP      R0,#+0
   \   0000007E   0xD001             BEQ.N    ??HAL_UART_Transmit_10
    643                  { 
    644                    return HAL_TIMEOUT;
   \   00000080   0x2003             MOVS     R0,#+3
   \   00000082   0xE02F             B.N      ??HAL_UART_Transmit_4
    645                  }
    646                if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
   \                     ??HAL_UART_Transmit_10: (+1)
   \   00000084   0x68A0             LDR      R0,[R4, #+8]
   \   00000086   0xF5B0 0x5F80      CMP      R0,#+4096
   \   0000008A   0xD10B             BNE.N    ??HAL_UART_Transmit_11
   \   0000008C   0x6920             LDR      R0,[R4, #+16]
   \   0000008E   0x2800             CMP      R0,#+0
   \   00000090   0xD108             BNE.N    ??HAL_UART_Transmit_11
    647                {
    648                  tmp = (uint16_t*) pData;
   \   00000092   0x46A8             MOV      R8,R5
    649                  huart->Instance->TDR = (*tmp & (uint16_t)0x01FF);
   \   00000094   0xF8B8 0x0000      LDRH     R0,[R8, #+0]
   \   00000098   0x05C0             LSLS     R0,R0,#+23       ;; ZeroExtS R0,R0,#+23,#+23
   \   0000009A   0x0DC0             LSRS     R0,R0,#+23
   \   0000009C   0x6821             LDR      R1,[R4, #+0]
   \   0000009E   0x6288             STR      R0,[R1, #+40]
    650                  pData += 2;
   \   000000A0   0x1CAD             ADDS     R5,R5,#+2
   \   000000A2   0xE7DC             B.N      ??HAL_UART_Transmit_8
    651                }
    652                else
    653                {
    654                  huart->Instance->TDR = (*pData++ & (uint8_t)0xFF);
   \                     ??HAL_UART_Transmit_11: (+1)
   \   000000A4   0x7828             LDRB     R0,[R5, #+0]
   \   000000A6   0x6821             LDR      R1,[R4, #+0]
   \   000000A8   0x6288             STR      R0,[R1, #+40]
   \   000000AA   0x1C6D             ADDS     R5,R5,#+1
   \   000000AC   0xE7D7             B.N      ??HAL_UART_Transmit_8
    655                }
    656              }
    657              if(UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TC, RESET, Timeout) != HAL_OK)  
   \                     ??HAL_UART_Transmit_9: (+1)
   \   000000AE   0x003B             MOVS     R3,R7
   \   000000B0   0x2200             MOVS     R2,#+0
   \   000000B2   0x2140             MOVS     R1,#+64
   \   000000B4   0x0020             MOVS     R0,R4
   \   000000B6   0x.... 0x....      BL       UART_WaitOnFlagUntilTimeout
   \   000000BA   0x2800             CMP      R0,#+0
   \   000000BC   0xD001             BEQ.N    ??HAL_UART_Transmit_12
    658              { 
    659                return HAL_TIMEOUT;
   \   000000BE   0x2003             MOVS     R0,#+3
   \   000000C0   0xE010             B.N      ??HAL_UART_Transmit_4
    660              }
    661              /* Check if a non-blocking receive Process is ongoing or not */
    662              if(huart->State == HAL_UART_STATE_BUSY_TX_RX) 
   \                     ??HAL_UART_Transmit_12: (+1)
   \   000000C2   0xF894 0x0069      LDRB     R0,[R4, #+105]
   \   000000C6   0x2832             CMP      R0,#+50
   \   000000C8   0xD103             BNE.N    ??HAL_UART_Transmit_13
    663              {
    664                huart->State = HAL_UART_STATE_BUSY_RX;
   \   000000CA   0x2022             MOVS     R0,#+34
   \   000000CC   0xF884 0x0069      STRB     R0,[R4, #+105]
   \   000000D0   0xE002             B.N      ??HAL_UART_Transmit_14
    665              }
    666              else
    667              {
    668                huart->State = HAL_UART_STATE_READY;
   \                     ??HAL_UART_Transmit_13: (+1)
   \   000000D2   0x2001             MOVS     R0,#+1
   \   000000D4   0xF884 0x0069      STRB     R0,[R4, #+105]
    669              }
    670          
    671              /* Process Unlocked */
    672              __HAL_UNLOCK(huart);
   \                     ??HAL_UART_Transmit_14: (+1)
   \   000000D8   0x2000             MOVS     R0,#+0
   \   000000DA   0xF884 0x0068      STRB     R0,[R4, #+104]
    673          
    674              return HAL_OK;
   \   000000DE   0x2000             MOVS     R0,#+0
   \   000000E0   0xE000             B.N      ??HAL_UART_Transmit_4
    675            }
    676            else
    677            {
    678              return HAL_BUSY;
   \                     ??HAL_UART_Transmit_1: (+1)
   \   000000E2   0x2002             MOVS     R0,#+2
   \                     ??HAL_UART_Transmit_4: (+1)
   \   000000E4   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    679            }
    680          }
    681          
    682          /**
    683            * @brief Receive an amount of data in blocking mode 
    684            * @param huart: uart handle
    685            * @param pData: pointer to data buffer
    686            * @param Size: amount of data to be received
    687            * @param Timeout : Timeout duration
    688            * @retval HAL status
    689            */

   \                                 In section .text, align 2, keep-with-next
    690          HAL_StatusTypeDef HAL_UART_Receive(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size, uint32_t Timeout)
    691          {
   \                     HAL_UART_Receive: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
    692            uint16_t* tmp;
    693            uint16_t uhMask;
    694          
    695            if((huart->State == HAL_UART_STATE_READY) || (huart->State == HAL_UART_STATE_BUSY_TX))
   \   0000000C   0xF894 0x0069      LDRB     R0,[R4, #+105]
   \   00000010   0x2801             CMP      R0,#+1
   \   00000012   0xD004             BEQ.N    ??HAL_UART_Receive_0
   \   00000014   0xF894 0x0069      LDRB     R0,[R4, #+105]
   \   00000018   0x2812             CMP      R0,#+18
   \   0000001A   0xF040 0x808A      BNE.W    ??HAL_UART_Receive_1
    696            {
    697              if((pData == NULL ) || (Size == 0))
   \                     ??HAL_UART_Receive_0: (+1)
   \   0000001E   0x2D00             CMP      R5,#+0
   \   00000020   0xD002             BEQ.N    ??HAL_UART_Receive_2
   \   00000022   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000024   0x2E00             CMP      R6,#+0
   \   00000026   0xD101             BNE.N    ??HAL_UART_Receive_3
    698              {
    699                return  HAL_ERROR;
   \                     ??HAL_UART_Receive_2: (+1)
   \   00000028   0x2001             MOVS     R0,#+1
   \   0000002A   0xE083             B.N      ??HAL_UART_Receive_4
    700              }
    701          
    702              /* Process Locked */
    703              __HAL_LOCK(huart);
   \                     ??HAL_UART_Receive_3: (+1)
   \   0000002C   0xF894 0x0068      LDRB     R0,[R4, #+104]
   \   00000030   0x2801             CMP      R0,#+1
   \   00000032   0xD101             BNE.N    ??HAL_UART_Receive_5
   \   00000034   0x2002             MOVS     R0,#+2
   \   00000036   0xE07D             B.N      ??HAL_UART_Receive_4
   \                     ??HAL_UART_Receive_5: (+1)
   \   00000038   0x2001             MOVS     R0,#+1
   \   0000003A   0xF884 0x0068      STRB     R0,[R4, #+104]
    704          
    705              huart->ErrorCode = HAL_UART_ERROR_NONE;
   \   0000003E   0x2000             MOVS     R0,#+0
   \   00000040   0x66E0             STR      R0,[R4, #+108]
    706              /* Check if a non-blocking transmit process is ongoing or not */
    707              if(huart->State == HAL_UART_STATE_BUSY_TX)
   \   00000042   0xF894 0x0069      LDRB     R0,[R4, #+105]
   \   00000046   0x2812             CMP      R0,#+18
   \   00000048   0xD103             BNE.N    ??HAL_UART_Receive_6
    708              {
    709                huart->State = HAL_UART_STATE_BUSY_TX_RX;
   \   0000004A   0x2032             MOVS     R0,#+50
   \   0000004C   0xF884 0x0069      STRB     R0,[R4, #+105]
   \   00000050   0xE002             B.N      ??HAL_UART_Receive_7
    710              }
    711              else
    712              {
    713                huart->State = HAL_UART_STATE_BUSY_RX;
   \                     ??HAL_UART_Receive_6: (+1)
   \   00000052   0x2022             MOVS     R0,#+34
   \   00000054   0xF884 0x0069      STRB     R0,[R4, #+105]
    714              }
    715          
    716              huart->RxXferSize = Size; 
   \                     ??HAL_UART_Receive_7: (+1)
   \   00000058   0xF8A4 0x6058      STRH     R6,[R4, #+88]
    717              huart->RxXferCount = Size;
   \   0000005C   0xF8A4 0x605A      STRH     R6,[R4, #+90]
    718          
    719              /* Computation of UART mask to apply to RDR register */
    720              UART_MASK_COMPUTATION(huart);
   \   00000060   0x68A0             LDR      R0,[R4, #+8]
   \   00000062   0xF5B0 0x5F80      CMP      R0,#+4096
   \   00000066   0xD10B             BNE.N    ??HAL_UART_Receive_8
   \   00000068   0x6920             LDR      R0,[R4, #+16]
   \   0000006A   0x2800             CMP      R0,#+0
   \   0000006C   0xD104             BNE.N    ??HAL_UART_Receive_9
   \   0000006E   0xF240 0x10FF      MOVW     R0,#+511
   \   00000072   0xF8A4 0x005C      STRH     R0,[R4, #+92]
   \   00000076   0xE01F             B.N      ??HAL_UART_Receive_10
   \                     ??HAL_UART_Receive_9: (+1)
   \   00000078   0x20FF             MOVS     R0,#+255
   \   0000007A   0xF8A4 0x005C      STRH     R0,[R4, #+92]
   \   0000007E   0xE01B             B.N      ??HAL_UART_Receive_10
   \                     ??HAL_UART_Receive_8: (+1)
   \   00000080   0x68A0             LDR      R0,[R4, #+8]
   \   00000082   0x2800             CMP      R0,#+0
   \   00000084   0xD10A             BNE.N    ??HAL_UART_Receive_11
   \   00000086   0x6920             LDR      R0,[R4, #+16]
   \   00000088   0x2800             CMP      R0,#+0
   \   0000008A   0xD103             BNE.N    ??HAL_UART_Receive_12
   \   0000008C   0x20FF             MOVS     R0,#+255
   \   0000008E   0xF8A4 0x005C      STRH     R0,[R4, #+92]
   \   00000092   0xE011             B.N      ??HAL_UART_Receive_10
   \                     ??HAL_UART_Receive_12: (+1)
   \   00000094   0x207F             MOVS     R0,#+127
   \   00000096   0xF8A4 0x005C      STRH     R0,[R4, #+92]
   \   0000009A   0xE00D             B.N      ??HAL_UART_Receive_10
   \                     ??HAL_UART_Receive_11: (+1)
   \   0000009C   0x68A0             LDR      R0,[R4, #+8]
   \   0000009E   0xF1B0 0x5F80      CMP      R0,#+268435456
   \   000000A2   0xD109             BNE.N    ??HAL_UART_Receive_10
   \   000000A4   0x6920             LDR      R0,[R4, #+16]
   \   000000A6   0x2800             CMP      R0,#+0
   \   000000A8   0xD103             BNE.N    ??HAL_UART_Receive_13
   \   000000AA   0x207F             MOVS     R0,#+127
   \   000000AC   0xF8A4 0x005C      STRH     R0,[R4, #+92]
   \   000000B0   0xE002             B.N      ??HAL_UART_Receive_10
   \                     ??HAL_UART_Receive_13: (+1)
   \   000000B2   0x203F             MOVS     R0,#+63
   \   000000B4   0xF8A4 0x005C      STRH     R0,[R4, #+92]
    721              uhMask = huart->Mask;
   \                     ??HAL_UART_Receive_10: (+1)
   \   000000B8   0xF8B4 0x005C      LDRH     R0,[R4, #+92]
   \   000000BC   0x4681             MOV      R9,R0
    722          
    723              /* as long as data have to be received */
    724              while(huart->RxXferCount > 0)
   \                     ??HAL_UART_Receive_14: (+1)
   \   000000BE   0xF8B4 0x005A      LDRH     R0,[R4, #+90]
   \   000000C2   0x2800             CMP      R0,#+0
   \   000000C4   0xD025             BEQ.N    ??HAL_UART_Receive_15
    725              {
    726                huart->RxXferCount--;
   \   000000C6   0xF8B4 0x005A      LDRH     R0,[R4, #+90]
   \   000000CA   0x1E40             SUBS     R0,R0,#+1
   \   000000CC   0xF8A4 0x005A      STRH     R0,[R4, #+90]
    727                  if(UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_RXNE, RESET, Timeout) != HAL_OK)  
   \   000000D0   0x003B             MOVS     R3,R7
   \   000000D2   0x2200             MOVS     R2,#+0
   \   000000D4   0x2120             MOVS     R1,#+32
   \   000000D6   0x0020             MOVS     R0,R4
   \   000000D8   0x.... 0x....      BL       UART_WaitOnFlagUntilTimeout
   \   000000DC   0x2800             CMP      R0,#+0
   \   000000DE   0xD001             BEQ.N    ??HAL_UART_Receive_16
    728                  {
    729                    return HAL_TIMEOUT;
   \   000000E0   0x2003             MOVS     R0,#+3
   \   000000E2   0xE027             B.N      ??HAL_UART_Receive_4
    730                  }
    731                if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
   \                     ??HAL_UART_Receive_16: (+1)
   \   000000E4   0x68A0             LDR      R0,[R4, #+8]
   \   000000E6   0xF5B0 0x5F80      CMP      R0,#+4096
   \   000000EA   0xD10B             BNE.N    ??HAL_UART_Receive_17
   \   000000EC   0x6920             LDR      R0,[R4, #+16]
   \   000000EE   0x2800             CMP      R0,#+0
   \   000000F0   0xD108             BNE.N    ??HAL_UART_Receive_17
    732                {
    733                  tmp = (uint16_t*) pData ;
   \   000000F2   0x46A8             MOV      R8,R5
    734                  *tmp = (uint16_t)(huart->Instance->RDR & uhMask);
   \   000000F4   0x6820             LDR      R0,[R4, #+0]
   \   000000F6   0x6A40             LDR      R0,[R0, #+36]
   \   000000F8   0xEA19 0x0000      ANDS     R0,R9,R0
   \   000000FC   0xF8A8 0x0000      STRH     R0,[R8, #+0]
    735                  pData +=2; 
   \   00000100   0x1CAD             ADDS     R5,R5,#+2
   \   00000102   0xE7DC             B.N      ??HAL_UART_Receive_14
    736                }
    737                else
    738                {
    739                  *pData++ = (uint8_t)(huart->Instance->RDR & (uint8_t)uhMask); 
   \                     ??HAL_UART_Receive_17: (+1)
   \   00000104   0x6820             LDR      R0,[R4, #+0]
   \   00000106   0x6A40             LDR      R0,[R0, #+36]
   \   00000108   0xEA19 0x0000      ANDS     R0,R9,R0
   \   0000010C   0x7028             STRB     R0,[R5, #+0]
   \   0000010E   0x1C6D             ADDS     R5,R5,#+1
   \   00000110   0xE7D5             B.N      ??HAL_UART_Receive_14
    740                }
    741              }
    742          
    743              /* Check if a non-blocking transmit Process is ongoing or not */
    744              if(huart->State == HAL_UART_STATE_BUSY_TX_RX) 
   \                     ??HAL_UART_Receive_15: (+1)
   \   00000112   0xF894 0x0069      LDRB     R0,[R4, #+105]
   \   00000116   0x2832             CMP      R0,#+50
   \   00000118   0xD103             BNE.N    ??HAL_UART_Receive_18
    745              {
    746                huart->State = HAL_UART_STATE_BUSY_TX;
   \   0000011A   0x2012             MOVS     R0,#+18
   \   0000011C   0xF884 0x0069      STRB     R0,[R4, #+105]
   \   00000120   0xE002             B.N      ??HAL_UART_Receive_19
    747              }
    748              else
    749              {
    750                huart->State = HAL_UART_STATE_READY;
   \                     ??HAL_UART_Receive_18: (+1)
   \   00000122   0x2001             MOVS     R0,#+1
   \   00000124   0xF884 0x0069      STRB     R0,[R4, #+105]
    751              }
    752              /* Process Unlocked */
    753              __HAL_UNLOCK(huart);
   \                     ??HAL_UART_Receive_19: (+1)
   \   00000128   0x2000             MOVS     R0,#+0
   \   0000012A   0xF884 0x0068      STRB     R0,[R4, #+104]
    754          
    755              return HAL_OK;
   \   0000012E   0x2000             MOVS     R0,#+0
   \   00000130   0xE000             B.N      ??HAL_UART_Receive_4
    756            }
    757            else
    758            {
    759              return HAL_BUSY;
   \                     ??HAL_UART_Receive_1: (+1)
   \   00000132   0x2002             MOVS     R0,#+2
   \                     ??HAL_UART_Receive_4: (+1)
   \   00000134   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    760            }
    761          }
    762          
    763          /**
    764            * @brief Send an amount of data in interrupt mode 
    765            * @param huart: uart handle
    766            * @param pData: pointer to data buffer
    767            * @param Size: amount of data to be sent
    768            * @retval HAL status
    769            */

   \                                 In section .text, align 2, keep-with-next
    770          HAL_StatusTypeDef HAL_UART_Transmit_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
    771          {  
   \                     HAL_UART_Transmit_IT: (+1)
   \   00000000   0xB410             PUSH     {R4}
   \   00000002   0x0003             MOVS     R3,R0
    772            if((huart->State == HAL_UART_STATE_READY) || (huart->State == HAL_UART_STATE_BUSY_RX))
   \   00000004   0xF893 0x0069      LDRB     R0,[R3, #+105]
   \   00000008   0x2801             CMP      R0,#+1
   \   0000000A   0xD003             BEQ.N    ??HAL_UART_Transmit_IT_0
   \   0000000C   0xF893 0x0069      LDRB     R0,[R3, #+105]
   \   00000010   0x2822             CMP      R0,#+34
   \   00000012   0xD132             BNE.N    ??HAL_UART_Transmit_IT_1
    773            {
    774              if((pData == NULL ) || (Size == 0)) 
   \                     ??HAL_UART_Transmit_IT_0: (+1)
   \   00000014   0x2900             CMP      R1,#+0
   \   00000016   0xD002             BEQ.N    ??HAL_UART_Transmit_IT_2
   \   00000018   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   0000001A   0x2A00             CMP      R2,#+0
   \   0000001C   0xD101             BNE.N    ??HAL_UART_Transmit_IT_3
    775              {
    776                return HAL_ERROR;
   \                     ??HAL_UART_Transmit_IT_2: (+1)
   \   0000001E   0x2001             MOVS     R0,#+1
   \   00000020   0xE02C             B.N      ??HAL_UART_Transmit_IT_4
    777              }
    778              
    779              /* Process Locked */
    780              __HAL_LOCK(huart);
   \                     ??HAL_UART_Transmit_IT_3: (+1)
   \   00000022   0xF893 0x0068      LDRB     R0,[R3, #+104]
   \   00000026   0x2801             CMP      R0,#+1
   \   00000028   0xD101             BNE.N    ??HAL_UART_Transmit_IT_5
   \   0000002A   0x2002             MOVS     R0,#+2
   \   0000002C   0xE026             B.N      ??HAL_UART_Transmit_IT_4
   \                     ??HAL_UART_Transmit_IT_5: (+1)
   \   0000002E   0x2001             MOVS     R0,#+1
   \   00000030   0xF883 0x0068      STRB     R0,[R3, #+104]
    781              
    782              huart->pTxBuffPtr = pData;
   \   00000034   0x64D9             STR      R1,[R3, #+76]
    783              huart->TxXferSize = Size;
   \   00000036   0xF8A3 0x2050      STRH     R2,[R3, #+80]
    784              huart->TxXferCount = Size;
   \   0000003A   0xF8A3 0x2052      STRH     R2,[R3, #+82]
    785              
    786              huart->ErrorCode = HAL_UART_ERROR_NONE;
   \   0000003E   0x2000             MOVS     R0,#+0
   \   00000040   0x66D8             STR      R0,[R3, #+108]
    787              /* Check if a receive process is ongoing or not */
    788              if(huart->State == HAL_UART_STATE_BUSY_RX) 
   \   00000042   0xF893 0x0069      LDRB     R0,[R3, #+105]
   \   00000046   0x2822             CMP      R0,#+34
   \   00000048   0xD103             BNE.N    ??HAL_UART_Transmit_IT_6
    789              {
    790                huart->State = HAL_UART_STATE_BUSY_TX_RX;
   \   0000004A   0x2032             MOVS     R0,#+50
   \   0000004C   0xF883 0x0069      STRB     R0,[R3, #+105]
   \   00000050   0xE002             B.N      ??HAL_UART_Transmit_IT_7
    791              }
    792              else
    793              {
    794                huart->State = HAL_UART_STATE_BUSY_TX;
   \                     ??HAL_UART_Transmit_IT_6: (+1)
   \   00000052   0x2012             MOVS     R0,#+18
   \   00000054   0xF883 0x0069      STRB     R0,[R3, #+105]
    795              }
    796              
    797              /* Enable the UART Error Interrupt: (Frame error, noise error, overrun error) */
    798              __HAL_UART_ENABLE_IT(huart, UART_IT_ERR);
   \                     ??HAL_UART_Transmit_IT_7: (+1)
   \   00000058   0x6818             LDR      R0,[R3, #+0]
   \   0000005A   0x6880             LDR      R0,[R0, #+8]
   \   0000005C   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000060   0x681C             LDR      R4,[R3, #+0]
   \   00000062   0x60A0             STR      R0,[R4, #+8]
    799              
    800              /* Process Unlocked */
    801              __HAL_UNLOCK(huart);    
   \   00000064   0x2000             MOVS     R0,#+0
   \   00000066   0xF883 0x0068      STRB     R0,[R3, #+104]
    802              
    803              /* Enable the UART Transmit Data Register Empty Interrupt */
    804              __HAL_UART_ENABLE_IT(huart, UART_IT_TXE);
   \   0000006A   0x6818             LDR      R0,[R3, #+0]
   \   0000006C   0x6800             LDR      R0,[R0, #+0]
   \   0000006E   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   00000072   0x681C             LDR      R4,[R3, #+0]
   \   00000074   0x6020             STR      R0,[R4, #+0]
    805              
    806              return HAL_OK;
   \   00000076   0x2000             MOVS     R0,#+0
   \   00000078   0xE000             B.N      ??HAL_UART_Transmit_IT_4
    807            }
    808            else
    809            {
    810              return HAL_BUSY;   
   \                     ??HAL_UART_Transmit_IT_1: (+1)
   \   0000007A   0x2002             MOVS     R0,#+2
   \                     ??HAL_UART_Transmit_IT_4: (+1)
   \   0000007C   0xBC10             POP      {R4}
   \   0000007E   0x4770             BX       LR               ;; return
    811            }
    812          }
    813          
    814          /**
    815            * @brief Receive an amount of data in interrupt mode 
    816            * @param huart: uart handle
    817            * @param pData: pointer to data buffer
    818            * @param Size: amount of data to be received
    819            * @retval HAL status
    820            */

   \                                 In section .text, align 2, keep-with-next
    821          HAL_StatusTypeDef HAL_UART_Receive_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
    822          {
   \                     HAL_UART_Receive_IT: (+1)
   \   00000000   0xB410             PUSH     {R4}
   \   00000002   0x0003             MOVS     R3,R0
    823            if((huart->State == HAL_UART_STATE_READY) || (huart->State == HAL_UART_STATE_BUSY_TX))
   \   00000004   0xF893 0x0069      LDRB     R0,[R3, #+105]
   \   00000008   0x2801             CMP      R0,#+1
   \   0000000A   0xD003             BEQ.N    ??HAL_UART_Receive_IT_0
   \   0000000C   0xF893 0x0069      LDRB     R0,[R3, #+105]
   \   00000010   0x2812             CMP      R0,#+18
   \   00000012   0xD164             BNE.N    ??HAL_UART_Receive_IT_1
    824            {
    825              if((pData == NULL ) || (Size == 0)) 
   \                     ??HAL_UART_Receive_IT_0: (+1)
   \   00000014   0x2900             CMP      R1,#+0
   \   00000016   0xD002             BEQ.N    ??HAL_UART_Receive_IT_2
   \   00000018   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   0000001A   0x2A00             CMP      R2,#+0
   \   0000001C   0xD101             BNE.N    ??HAL_UART_Receive_IT_3
    826              {
    827                return HAL_ERROR;
   \                     ??HAL_UART_Receive_IT_2: (+1)
   \   0000001E   0x2001             MOVS     R0,#+1
   \   00000020   0xE05E             B.N      ??HAL_UART_Receive_IT_4
    828              }
    829          
    830              /* Process Locked */
    831              __HAL_LOCK(huart);
   \                     ??HAL_UART_Receive_IT_3: (+1)
   \   00000022   0xF893 0x0068      LDRB     R0,[R3, #+104]
   \   00000026   0x2801             CMP      R0,#+1
   \   00000028   0xD101             BNE.N    ??HAL_UART_Receive_IT_5
   \   0000002A   0x2002             MOVS     R0,#+2
   \   0000002C   0xE058             B.N      ??HAL_UART_Receive_IT_4
   \                     ??HAL_UART_Receive_IT_5: (+1)
   \   0000002E   0x2001             MOVS     R0,#+1
   \   00000030   0xF883 0x0068      STRB     R0,[R3, #+104]
    832          
    833              huart->pRxBuffPtr = pData;
   \   00000034   0x6559             STR      R1,[R3, #+84]
    834              huart->RxXferSize = Size;
   \   00000036   0xF8A3 0x2058      STRH     R2,[R3, #+88]
    835              huart->RxXferCount = Size;
   \   0000003A   0xF8A3 0x205A      STRH     R2,[R3, #+90]
    836          
    837              /* Computation of UART mask to apply to RDR register */
    838              UART_MASK_COMPUTATION(huart);
   \   0000003E   0x6898             LDR      R0,[R3, #+8]
   \   00000040   0xF5B0 0x5F80      CMP      R0,#+4096
   \   00000044   0xD10B             BNE.N    ??HAL_UART_Receive_IT_6
   \   00000046   0x6918             LDR      R0,[R3, #+16]
   \   00000048   0x2800             CMP      R0,#+0
   \   0000004A   0xD104             BNE.N    ??HAL_UART_Receive_IT_7
   \   0000004C   0xF240 0x10FF      MOVW     R0,#+511
   \   00000050   0xF8A3 0x005C      STRH     R0,[R3, #+92]
   \   00000054   0xE01F             B.N      ??HAL_UART_Receive_IT_8
   \                     ??HAL_UART_Receive_IT_7: (+1)
   \   00000056   0x20FF             MOVS     R0,#+255
   \   00000058   0xF8A3 0x005C      STRH     R0,[R3, #+92]
   \   0000005C   0xE01B             B.N      ??HAL_UART_Receive_IT_8
   \                     ??HAL_UART_Receive_IT_6: (+1)
   \   0000005E   0x6898             LDR      R0,[R3, #+8]
   \   00000060   0x2800             CMP      R0,#+0
   \   00000062   0xD10A             BNE.N    ??HAL_UART_Receive_IT_9
   \   00000064   0x6918             LDR      R0,[R3, #+16]
   \   00000066   0x2800             CMP      R0,#+0
   \   00000068   0xD103             BNE.N    ??HAL_UART_Receive_IT_10
   \   0000006A   0x20FF             MOVS     R0,#+255
   \   0000006C   0xF8A3 0x005C      STRH     R0,[R3, #+92]
   \   00000070   0xE011             B.N      ??HAL_UART_Receive_IT_8
   \                     ??HAL_UART_Receive_IT_10: (+1)
   \   00000072   0x207F             MOVS     R0,#+127
   \   00000074   0xF8A3 0x005C      STRH     R0,[R3, #+92]
   \   00000078   0xE00D             B.N      ??HAL_UART_Receive_IT_8
   \                     ??HAL_UART_Receive_IT_9: (+1)
   \   0000007A   0x6898             LDR      R0,[R3, #+8]
   \   0000007C   0xF1B0 0x5F80      CMP      R0,#+268435456
   \   00000080   0xD109             BNE.N    ??HAL_UART_Receive_IT_8
   \   00000082   0x6918             LDR      R0,[R3, #+16]
   \   00000084   0x2800             CMP      R0,#+0
   \   00000086   0xD103             BNE.N    ??HAL_UART_Receive_IT_11
   \   00000088   0x207F             MOVS     R0,#+127
   \   0000008A   0xF8A3 0x005C      STRH     R0,[R3, #+92]
   \   0000008E   0xE002             B.N      ??HAL_UART_Receive_IT_8
   \                     ??HAL_UART_Receive_IT_11: (+1)
   \   00000090   0x203F             MOVS     R0,#+63
   \   00000092   0xF8A3 0x005C      STRH     R0,[R3, #+92]
    839          
    840              huart->ErrorCode = HAL_UART_ERROR_NONE;
   \                     ??HAL_UART_Receive_IT_8: (+1)
   \   00000096   0x2000             MOVS     R0,#+0
   \   00000098   0x66D8             STR      R0,[R3, #+108]
    841              /* Check if a transmit process is ongoing or not */
    842              if(huart->State == HAL_UART_STATE_BUSY_TX) 
   \   0000009A   0xF893 0x0069      LDRB     R0,[R3, #+105]
   \   0000009E   0x2812             CMP      R0,#+18
   \   000000A0   0xD103             BNE.N    ??HAL_UART_Receive_IT_12
    843              {
    844                huart->State = HAL_UART_STATE_BUSY_TX_RX;
   \   000000A2   0x2032             MOVS     R0,#+50
   \   000000A4   0xF883 0x0069      STRB     R0,[R3, #+105]
   \   000000A8   0xE002             B.N      ??HAL_UART_Receive_IT_13
    845              }
    846              else
    847              {
    848                huart->State = HAL_UART_STATE_BUSY_RX;
   \                     ??HAL_UART_Receive_IT_12: (+1)
   \   000000AA   0x2022             MOVS     R0,#+34
   \   000000AC   0xF883 0x0069      STRB     R0,[R3, #+105]
    849              }
    850          
    851              /* Enable the UART Parity Error Interrupt */
    852              __HAL_UART_ENABLE_IT(huart, UART_IT_PE);
   \                     ??HAL_UART_Receive_IT_13: (+1)
   \   000000B0   0x6818             LDR      R0,[R3, #+0]
   \   000000B2   0x6800             LDR      R0,[R0, #+0]
   \   000000B4   0xF450 0x7080      ORRS     R0,R0,#0x100
   \   000000B8   0x681C             LDR      R4,[R3, #+0]
   \   000000BA   0x6020             STR      R0,[R4, #+0]
    853          
    854              /* Enable the UART Error Interrupt: (Frame error, noise error, overrun error) */
    855              __HAL_UART_ENABLE_IT(huart, UART_IT_ERR);
   \   000000BC   0x6818             LDR      R0,[R3, #+0]
   \   000000BE   0x6880             LDR      R0,[R0, #+8]
   \   000000C0   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   000000C4   0x681C             LDR      R4,[R3, #+0]
   \   000000C6   0x60A0             STR      R0,[R4, #+8]
    856          
    857              /* Process Unlocked */
    858              __HAL_UNLOCK(huart);
   \   000000C8   0x2000             MOVS     R0,#+0
   \   000000CA   0xF883 0x0068      STRB     R0,[R3, #+104]
    859          
    860              /* Enable the UART Data Register not empty Interrupt */
    861              __HAL_UART_ENABLE_IT(huart, UART_IT_RXNE);
   \   000000CE   0x6818             LDR      R0,[R3, #+0]
   \   000000D0   0x6800             LDR      R0,[R0, #+0]
   \   000000D2   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   000000D6   0x681C             LDR      R4,[R3, #+0]
   \   000000D8   0x6020             STR      R0,[R4, #+0]
    862          
    863              return HAL_OK;
   \   000000DA   0x2000             MOVS     R0,#+0
   \   000000DC   0xE000             B.N      ??HAL_UART_Receive_IT_4
    864            }
    865            else
    866            {
    867              return HAL_BUSY; 
   \                     ??HAL_UART_Receive_IT_1: (+1)
   \   000000DE   0x2002             MOVS     R0,#+2
   \                     ??HAL_UART_Receive_IT_4: (+1)
   \   000000E0   0xBC10             POP      {R4}
   \   000000E2   0x4770             BX       LR               ;; return
    868            }
    869          }
    870          
    871          /**
    872            * @brief Send an amount of data in DMA mode 
    873            * @param huart: uart handle
    874            * @param pData: pointer to data buffer
    875            * @param Size: amount of data to be sent
    876            * @retval HAL status
    877            */

   \                                 In section .text, align 2, keep-with-next
    878          HAL_StatusTypeDef HAL_UART_Transmit_DMA(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
    879          {
   \                     HAL_UART_Transmit_DMA: (+1)
   \   00000000   0xB573             PUSH     {R0,R1,R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x0015             MOVS     R5,R2
    880            uint32_t *tmp;
    881            
    882            if((huart->State == HAL_UART_STATE_READY) || (huart->State == HAL_UART_STATE_BUSY_RX))
   \   00000006   0xF894 0x0069      LDRB     R0,[R4, #+105]
   \   0000000A   0x2801             CMP      R0,#+1
   \   0000000C   0xD003             BEQ.N    ??HAL_UART_Transmit_DMA_0
   \   0000000E   0xF894 0x0069      LDRB     R0,[R4, #+105]
   \   00000012   0x2822             CMP      R0,#+34
   \   00000014   0xD149             BNE.N    ??HAL_UART_Transmit_DMA_1
    883            {
    884              if((pData == NULL ) || (Size == 0)) 
   \                     ??HAL_UART_Transmit_DMA_0: (+1)
   \   00000016   0x9801             LDR      R0,[SP, #+4]
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD002             BEQ.N    ??HAL_UART_Transmit_DMA_2
   \   0000001C   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000001E   0x2D00             CMP      R5,#+0
   \   00000020   0xD101             BNE.N    ??HAL_UART_Transmit_DMA_3
    885              {
    886                return HAL_ERROR;
   \                     ??HAL_UART_Transmit_DMA_2: (+1)
   \   00000022   0x2001             MOVS     R0,#+1
   \   00000024   0xE042             B.N      ??HAL_UART_Transmit_DMA_4
    887              }
    888              
    889              /* Process Locked */
    890              __HAL_LOCK(huart);
   \                     ??HAL_UART_Transmit_DMA_3: (+1)
   \   00000026   0xF894 0x0068      LDRB     R0,[R4, #+104]
   \   0000002A   0x2801             CMP      R0,#+1
   \   0000002C   0xD101             BNE.N    ??HAL_UART_Transmit_DMA_5
   \   0000002E   0x2002             MOVS     R0,#+2
   \   00000030   0xE03C             B.N      ??HAL_UART_Transmit_DMA_4
   \                     ??HAL_UART_Transmit_DMA_5: (+1)
   \   00000032   0x2001             MOVS     R0,#+1
   \   00000034   0xF884 0x0068      STRB     R0,[R4, #+104]
    891              
    892              huart->pTxBuffPtr = pData;
   \   00000038   0x9801             LDR      R0,[SP, #+4]
   \   0000003A   0x64E0             STR      R0,[R4, #+76]
    893              huart->TxXferSize = Size;
   \   0000003C   0xF8A4 0x5050      STRH     R5,[R4, #+80]
    894              huart->TxXferCount = Size; 
   \   00000040   0xF8A4 0x5052      STRH     R5,[R4, #+82]
    895              
    896              huart->ErrorCode = HAL_UART_ERROR_NONE;
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0x66E0             STR      R0,[R4, #+108]
    897              /* Check if a receive process is ongoing or not */
    898              if(huart->State == HAL_UART_STATE_BUSY_RX) 
   \   00000048   0xF894 0x0069      LDRB     R0,[R4, #+105]
   \   0000004C   0x2822             CMP      R0,#+34
   \   0000004E   0xD103             BNE.N    ??HAL_UART_Transmit_DMA_6
    899              {
    900                huart->State = HAL_UART_STATE_BUSY_TX_RX;
   \   00000050   0x2032             MOVS     R0,#+50
   \   00000052   0xF884 0x0069      STRB     R0,[R4, #+105]
   \   00000056   0xE002             B.N      ??HAL_UART_Transmit_DMA_7
    901              }
    902              else
    903              {
    904                huart->State = HAL_UART_STATE_BUSY_TX;
   \                     ??HAL_UART_Transmit_DMA_6: (+1)
   \   00000058   0x2012             MOVS     R0,#+18
   \   0000005A   0xF884 0x0069      STRB     R0,[R4, #+105]
    905              }
    906              
    907              /* Set the UART DMA transfer complete callback */
    908              huart->hdmatx->XferCpltCallback = UART_DMATransmitCplt;
   \                     ??HAL_UART_Transmit_DMA_7: (+1)
   \   0000005E   0x.... 0x....      ADR.W    R0,UART_DMATransmitCplt
   \   00000062   0x6E21             LDR      R1,[R4, #+96]
   \   00000064   0x63C8             STR      R0,[R1, #+60]
    909              
    910              /* Set the UART DMA Half transfer complete callback */
    911              huart->hdmatx->XferHalfCpltCallback = UART_DMATxHalfCplt;
   \   00000066   0x.... 0x....      ADR.W    R0,UART_DMATxHalfCplt
   \   0000006A   0x6E21             LDR      R1,[R4, #+96]
   \   0000006C   0x6408             STR      R0,[R1, #+64]
    912              
    913              /* Set the DMA error callback */
    914              huart->hdmatx->XferErrorCallback = UART_DMAError;
   \   0000006E   0x.... 0x....      ADR.W    R0,UART_DMAError
   \   00000072   0x6E21             LDR      R1,[R4, #+96]
   \   00000074   0x6488             STR      R0,[R1, #+72]
    915          
    916              /* Enable the UART transmit DMA channel */
    917              tmp = (uint32_t*)&pData;
   \   00000076   0xA801             ADD      R0,SP,#+4
   \   00000078   0x0006             MOVS     R6,R0
    918              HAL_DMA_Start_IT(huart->hdmatx, *(uint32_t*)tmp, (uint32_t)&huart->Instance->TDR, Size);
   \   0000007A   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000007C   0x002B             MOVS     R3,R5
   \   0000007E   0x6820             LDR      R0,[R4, #+0]
   \   00000080   0xF110 0x0228      ADDS     R2,R0,#+40
   \   00000084   0x6831             LDR      R1,[R6, #+0]
   \   00000086   0x6E20             LDR      R0,[R4, #+96]
   \   00000088   0x.... 0x....      BL       HAL_DMA_Start_IT
    919          
    920              /* Clear the TC flag in the SR register by writing 0 to it */
    921              __HAL_UART_CLEAR_IT(huart, UART_FLAG_TC);
   \   0000008C   0xF07F 0x0040      MVNS     R0,#+64
   \   00000090   0x6821             LDR      R1,[R4, #+0]
   \   00000092   0x6208             STR      R0,[R1, #+32]
    922          
    923              
    924              /* Enable the DMA transfer for transmit request by setting the DMAT bit
    925                 in the UART CR3 register */
    926              huart->Instance->CR3 |= USART_CR3_DMAT;
   \   00000094   0x6820             LDR      R0,[R4, #+0]
   \   00000096   0x6880             LDR      R0,[R0, #+8]
   \   00000098   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   0000009C   0x6821             LDR      R1,[R4, #+0]
   \   0000009E   0x6088             STR      R0,[R1, #+8]
    927              
    928              /* Process Unlocked */
    929              __HAL_UNLOCK(huart);
   \   000000A0   0x2000             MOVS     R0,#+0
   \   000000A2   0xF884 0x0068      STRB     R0,[R4, #+104]
    930              
    931              return HAL_OK;
   \   000000A6   0x2000             MOVS     R0,#+0
   \   000000A8   0xE000             B.N      ??HAL_UART_Transmit_DMA_4
    932            }
    933            else
    934            {
    935              return HAL_BUSY;   
   \                     ??HAL_UART_Transmit_DMA_1: (+1)
   \   000000AA   0x2002             MOVS     R0,#+2
   \                     ??HAL_UART_Transmit_DMA_4: (+1)
   \   000000AC   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
    936            }
    937          }
    938          
    939          /**
    940            * @brief Receive an amount of data in DMA mode 
    941            * @param huart: uart handle
    942            * @param pData: pointer to data buffer
    943            * @param Size: amount of data to be received
    944            * @note   When the UART parity is enabled (PCE = 1), the received data contain 
    945            *         the parity bit (MSB position)     
    946            * @retval HAL status
    947            */

   \                                 In section .text, align 2, keep-with-next
    948          HAL_StatusTypeDef HAL_UART_Receive_DMA(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
    949          {
   \                     HAL_UART_Receive_DMA: (+1)
   \   00000000   0xB573             PUSH     {R0,R1,R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x0015             MOVS     R5,R2
    950            uint32_t *tmp;
    951            
    952            if((huart->State == HAL_UART_STATE_READY) || (huart->State == HAL_UART_STATE_BUSY_TX))
   \   00000006   0xF894 0x0069      LDRB     R0,[R4, #+105]
   \   0000000A   0x2801             CMP      R0,#+1
   \   0000000C   0xD003             BEQ.N    ??HAL_UART_Receive_DMA_0
   \   0000000E   0xF894 0x0069      LDRB     R0,[R4, #+105]
   \   00000012   0x2812             CMP      R0,#+18
   \   00000014   0xD143             BNE.N    ??HAL_UART_Receive_DMA_1
    953            {
    954              if((pData == NULL ) || (Size == 0)) 
   \                     ??HAL_UART_Receive_DMA_0: (+1)
   \   00000016   0x9801             LDR      R0,[SP, #+4]
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD002             BEQ.N    ??HAL_UART_Receive_DMA_2
   \   0000001C   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000001E   0x2D00             CMP      R5,#+0
   \   00000020   0xD101             BNE.N    ??HAL_UART_Receive_DMA_3
    955              {
    956                return HAL_ERROR;
   \                     ??HAL_UART_Receive_DMA_2: (+1)
   \   00000022   0x2001             MOVS     R0,#+1
   \   00000024   0xE03C             B.N      ??HAL_UART_Receive_DMA_4
    957              }
    958              
    959              /* Process Locked */
    960              __HAL_LOCK(huart);
   \                     ??HAL_UART_Receive_DMA_3: (+1)
   \   00000026   0xF894 0x0068      LDRB     R0,[R4, #+104]
   \   0000002A   0x2801             CMP      R0,#+1
   \   0000002C   0xD101             BNE.N    ??HAL_UART_Receive_DMA_5
   \   0000002E   0x2002             MOVS     R0,#+2
   \   00000030   0xE036             B.N      ??HAL_UART_Receive_DMA_4
   \                     ??HAL_UART_Receive_DMA_5: (+1)
   \   00000032   0x2001             MOVS     R0,#+1
   \   00000034   0xF884 0x0068      STRB     R0,[R4, #+104]
    961              
    962              huart->pRxBuffPtr = pData;
   \   00000038   0x9801             LDR      R0,[SP, #+4]
   \   0000003A   0x6560             STR      R0,[R4, #+84]
    963              huart->RxXferSize = Size;
   \   0000003C   0xF8A4 0x5058      STRH     R5,[R4, #+88]
    964              
    965              huart->ErrorCode = HAL_UART_ERROR_NONE;
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0x66E0             STR      R0,[R4, #+108]
    966              /* Check if a transmit process is ongoing or not */
    967              if(huart->State == HAL_UART_STATE_BUSY_TX) 
   \   00000044   0xF894 0x0069      LDRB     R0,[R4, #+105]
   \   00000048   0x2812             CMP      R0,#+18
   \   0000004A   0xD103             BNE.N    ??HAL_UART_Receive_DMA_6
    968              {
    969                huart->State = HAL_UART_STATE_BUSY_TX_RX;
   \   0000004C   0x2032             MOVS     R0,#+50
   \   0000004E   0xF884 0x0069      STRB     R0,[R4, #+105]
   \   00000052   0xE002             B.N      ??HAL_UART_Receive_DMA_7
    970              }
    971              else
    972              {
    973                huart->State = HAL_UART_STATE_BUSY_RX;
   \                     ??HAL_UART_Receive_DMA_6: (+1)
   \   00000054   0x2022             MOVS     R0,#+34
   \   00000056   0xF884 0x0069      STRB     R0,[R4, #+105]
    974              }
    975              
    976              /* Set the UART DMA transfer complete callback */
    977              huart->hdmarx->XferCpltCallback = UART_DMAReceiveCplt;
   \                     ??HAL_UART_Receive_DMA_7: (+1)
   \   0000005A   0x.... 0x....      ADR.W    R0,UART_DMAReceiveCplt
   \   0000005E   0x6E61             LDR      R1,[R4, #+100]
   \   00000060   0x63C8             STR      R0,[R1, #+60]
    978              
    979              /* Set the UART DMA Half transfer complete callback */
    980              huart->hdmarx->XferHalfCpltCallback = UART_DMARxHalfCplt;
   \   00000062   0x.... 0x....      ADR.W    R0,UART_DMARxHalfCplt
   \   00000066   0x6E61             LDR      R1,[R4, #+100]
   \   00000068   0x6408             STR      R0,[R1, #+64]
    981              
    982              /* Set the DMA error callback */
    983              huart->hdmarx->XferErrorCallback = UART_DMAError;
   \   0000006A   0x.... 0x....      ADR.W    R0,UART_DMAError
   \   0000006E   0x6E61             LDR      R1,[R4, #+100]
   \   00000070   0x6488             STR      R0,[R1, #+72]
    984          
    985              /* Enable the DMA channel */
    986              tmp = (uint32_t*)&pData;
   \   00000072   0xA801             ADD      R0,SP,#+4
   \   00000074   0x0006             MOVS     R6,R0
    987              HAL_DMA_Start_IT(huart->hdmarx, (uint32_t)&huart->Instance->RDR, *(uint32_t*)tmp, Size);
   \   00000076   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000078   0x002B             MOVS     R3,R5
   \   0000007A   0x6832             LDR      R2,[R6, #+0]
   \   0000007C   0x6820             LDR      R0,[R4, #+0]
   \   0000007E   0xF110 0x0124      ADDS     R1,R0,#+36
   \   00000082   0x6E60             LDR      R0,[R4, #+100]
   \   00000084   0x.... 0x....      BL       HAL_DMA_Start_IT
    988          
    989              /* Enable the DMA transfer for the receiver request by setting the DMAR bit 
    990                 in the UART CR3 register */
    991               huart->Instance->CR3 |= USART_CR3_DMAR;
   \   00000088   0x6820             LDR      R0,[R4, #+0]
   \   0000008A   0x6880             LDR      R0,[R0, #+8]
   \   0000008C   0xF050 0x0040      ORRS     R0,R0,#0x40
   \   00000090   0x6821             LDR      R1,[R4, #+0]
   \   00000092   0x6088             STR      R0,[R1, #+8]
    992              
    993               /* Process Unlocked */
    994               __HAL_UNLOCK(huart);
   \   00000094   0x2000             MOVS     R0,#+0
   \   00000096   0xF884 0x0068      STRB     R0,[R4, #+104]
    995               
    996              return HAL_OK;
   \   0000009A   0x2000             MOVS     R0,#+0
   \   0000009C   0xE000             B.N      ??HAL_UART_Receive_DMA_4
    997            }
    998            else
    999            {
   1000              return HAL_BUSY; 
   \                     ??HAL_UART_Receive_DMA_1: (+1)
   \   0000009E   0x2002             MOVS     R0,#+2
   \                     ??HAL_UART_Receive_DMA_4: (+1)
   \   000000A0   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
   1001            }
   1002          }
   1003          
   1004          /**
   1005            * @brief Pauses the DMA Transfer.
   1006            * @param huart: UART handle
   1007            * @retval None
   1008            */

   \                                 In section .text, align 2, keep-with-next
   1009          HAL_StatusTypeDef HAL_UART_DMAPause(UART_HandleTypeDef *huart)
   1010          {
   \                     HAL_UART_DMAPause: (+1)
   \   00000000   0x0001             MOVS     R1,R0
   1011            /* Process Locked */
   1012            __HAL_LOCK(huart);
   \   00000002   0xF891 0x0068      LDRB     R0,[R1, #+104]
   \   00000006   0x2801             CMP      R0,#+1
   \   00000008   0xD101             BNE.N    ??HAL_UART_DMAPause_0
   \   0000000A   0x2002             MOVS     R0,#+2
   \   0000000C   0xE02C             B.N      ??HAL_UART_DMAPause_1
   \                     ??HAL_UART_DMAPause_0: (+1)
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0xF881 0x0068      STRB     R0,[R1, #+104]
   1013            
   1014            if(huart->State == HAL_UART_STATE_BUSY_TX)
   \   00000014   0xF891 0x0069      LDRB     R0,[R1, #+105]
   \   00000018   0x2812             CMP      R0,#+18
   \   0000001A   0xD106             BNE.N    ??HAL_UART_DMAPause_2
   1015            {
   1016              /* Disable the UART DMA Tx request */
   1017              huart->Instance->CR3 &= (uint32_t)(~USART_CR3_DMAT);
   \   0000001C   0x6808             LDR      R0,[R1, #+0]
   \   0000001E   0x6880             LDR      R0,[R0, #+8]
   \   00000020   0xF030 0x0080      BICS     R0,R0,#0x80
   \   00000024   0x680A             LDR      R2,[R1, #+0]
   \   00000026   0x6090             STR      R0,[R2, #+8]
   \   00000028   0xE01A             B.N      ??HAL_UART_DMAPause_3
   1018            }
   1019            else if(huart->State == HAL_UART_STATE_BUSY_RX)
   \                     ??HAL_UART_DMAPause_2: (+1)
   \   0000002A   0xF891 0x0069      LDRB     R0,[R1, #+105]
   \   0000002E   0x2822             CMP      R0,#+34
   \   00000030   0xD106             BNE.N    ??HAL_UART_DMAPause_4
   1020            {
   1021              /* Disable the UART DMA Rx request */
   1022              huart->Instance->CR3 &= (uint32_t)(~USART_CR3_DMAR);
   \   00000032   0x6808             LDR      R0,[R1, #+0]
   \   00000034   0x6880             LDR      R0,[R0, #+8]
   \   00000036   0xF030 0x0040      BICS     R0,R0,#0x40
   \   0000003A   0x680A             LDR      R2,[R1, #+0]
   \   0000003C   0x6090             STR      R0,[R2, #+8]
   \   0000003E   0xE00F             B.N      ??HAL_UART_DMAPause_3
   1023            }
   1024            else if(huart->State == HAL_UART_STATE_BUSY_TX_RX)
   \                     ??HAL_UART_DMAPause_4: (+1)
   \   00000040   0xF891 0x0069      LDRB     R0,[R1, #+105]
   \   00000044   0x2832             CMP      R0,#+50
   \   00000046   0xD10B             BNE.N    ??HAL_UART_DMAPause_3
   1025            {
   1026              /* Disable the UART DMA Tx request */
   1027              huart->Instance->CR3 &= (uint32_t)(~USART_CR3_DMAT);
   \   00000048   0x6808             LDR      R0,[R1, #+0]
   \   0000004A   0x6880             LDR      R0,[R0, #+8]
   \   0000004C   0xF030 0x0080      BICS     R0,R0,#0x80
   \   00000050   0x680A             LDR      R2,[R1, #+0]
   \   00000052   0x6090             STR      R0,[R2, #+8]
   1028              /* Disable the UART DMA Rx request */
   1029              huart->Instance->CR3 &= (uint32_t)(~USART_CR3_DMAR);
   \   00000054   0x6808             LDR      R0,[R1, #+0]
   \   00000056   0x6880             LDR      R0,[R0, #+8]
   \   00000058   0xF030 0x0040      BICS     R0,R0,#0x40
   \   0000005C   0x680A             LDR      R2,[R1, #+0]
   \   0000005E   0x6090             STR      R0,[R2, #+8]
   1030            }
   1031            
   1032            /* Process Unlocked */
   1033            __HAL_UNLOCK(huart);
   \                     ??HAL_UART_DMAPause_3: (+1)
   \   00000060   0x2000             MOVS     R0,#+0
   \   00000062   0xF881 0x0068      STRB     R0,[R1, #+104]
   1034          
   1035            return HAL_OK; 
   \   00000066   0x2000             MOVS     R0,#+0
   \                     ??HAL_UART_DMAPause_1: (+1)
   \   00000068   0x4770             BX       LR               ;; return
   1036          }
   1037          
   1038          /**
   1039            * @brief Resumes the DMA Transfer.
   1040            * @param huart: UART handle
   1041            * @retval None
   1042            */

   \                                 In section .text, align 2, keep-with-next
   1043          HAL_StatusTypeDef HAL_UART_DMAResume(UART_HandleTypeDef *huart)
   1044          {
   \                     HAL_UART_DMAResume: (+1)
   \   00000000   0x0001             MOVS     R1,R0
   1045            /* Process Locked */
   1046            __HAL_LOCK(huart);
   \   00000002   0xF891 0x0068      LDRB     R0,[R1, #+104]
   \   00000006   0x2801             CMP      R0,#+1
   \   00000008   0xD101             BNE.N    ??HAL_UART_DMAResume_0
   \   0000000A   0x2002             MOVS     R0,#+2
   \   0000000C   0xE03B             B.N      ??HAL_UART_DMAResume_1
   \                     ??HAL_UART_DMAResume_0: (+1)
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0xF881 0x0068      STRB     R0,[R1, #+104]
   1047          
   1048            if(huart->State == HAL_UART_STATE_BUSY_TX)
   \   00000014   0xF891 0x0069      LDRB     R0,[R1, #+105]
   \   00000018   0x2812             CMP      R0,#+18
   \   0000001A   0xD106             BNE.N    ??HAL_UART_DMAResume_2
   1049            {
   1050              /* Enable the UART DMA Tx request */
   1051              huart->Instance->CR3 |= USART_CR3_DMAT;
   \   0000001C   0x6808             LDR      R0,[R1, #+0]
   \   0000001E   0x6880             LDR      R0,[R0, #+8]
   \   00000020   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   00000024   0x680A             LDR      R2,[R1, #+0]
   \   00000026   0x6090             STR      R0,[R2, #+8]
   \   00000028   0xE022             B.N      ??HAL_UART_DMAResume_3
   1052            }
   1053            else if(huart->State == HAL_UART_STATE_BUSY_RX)
   \                     ??HAL_UART_DMAResume_2: (+1)
   \   0000002A   0xF891 0x0069      LDRB     R0,[R1, #+105]
   \   0000002E   0x2822             CMP      R0,#+34
   \   00000030   0xD10A             BNE.N    ??HAL_UART_DMAResume_4
   1054            {
   1055          		/* Clear the Overrun flag before resuming the Rx transfer*/
   1056              __HAL_UART_CLEAR_IT(huart, UART_CLEAR_OREF);
   \   00000032   0xF07F 0x0008      MVNS     R0,#+8
   \   00000036   0x680A             LDR      R2,[R1, #+0]
   \   00000038   0x6210             STR      R0,[R2, #+32]
   1057          
   1058              /* Enable the UART DMA Rx request */
   1059              huart->Instance->CR3 |= USART_CR3_DMAR;
   \   0000003A   0x6808             LDR      R0,[R1, #+0]
   \   0000003C   0x6880             LDR      R0,[R0, #+8]
   \   0000003E   0xF050 0x0040      ORRS     R0,R0,#0x40
   \   00000042   0x680A             LDR      R2,[R1, #+0]
   \   00000044   0x6090             STR      R0,[R2, #+8]
   \   00000046   0xE013             B.N      ??HAL_UART_DMAResume_3
   1060            }
   1061            else if(huart->State == HAL_UART_STATE_BUSY_TX_RX)
   \                     ??HAL_UART_DMAResume_4: (+1)
   \   00000048   0xF891 0x0069      LDRB     R0,[R1, #+105]
   \   0000004C   0x2832             CMP      R0,#+50
   \   0000004E   0xD10F             BNE.N    ??HAL_UART_DMAResume_3
   1062            {
   1063          		/* Clear the Overrun flag before resuming the Rx transfer*/
   1064              __HAL_UART_CLEAR_IT(huart, UART_CLEAR_OREF);
   \   00000050   0xF07F 0x0008      MVNS     R0,#+8
   \   00000054   0x680A             LDR      R2,[R1, #+0]
   \   00000056   0x6210             STR      R0,[R2, #+32]
   1065          		
   1066              /* Enable the UART DMA Rx request  before the DMA Tx request */
   1067              huart->Instance->CR3 |= USART_CR3_DMAR;
   \   00000058   0x6808             LDR      R0,[R1, #+0]
   \   0000005A   0x6880             LDR      R0,[R0, #+8]
   \   0000005C   0xF050 0x0040      ORRS     R0,R0,#0x40
   \   00000060   0x680A             LDR      R2,[R1, #+0]
   \   00000062   0x6090             STR      R0,[R2, #+8]
   1068          
   1069              /* Enable the UART DMA Tx request */
   1070              huart->Instance->CR3 |= USART_CR3_DMAT;
   \   00000064   0x6808             LDR      R0,[R1, #+0]
   \   00000066   0x6880             LDR      R0,[R0, #+8]
   \   00000068   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   0000006C   0x680A             LDR      R2,[R1, #+0]
   \   0000006E   0x6090             STR      R0,[R2, #+8]
   1071            }
   1072          
   1073            /* If the UART peripheral is still not enabled, enable it */
   1074            if ((huart->Instance->CR1 & USART_CR1_UE) == 0)
   \                     ??HAL_UART_DMAResume_3: (+1)
   \   00000070   0x6808             LDR      R0,[R1, #+0]
   \   00000072   0x6800             LDR      R0,[R0, #+0]
   \   00000074   0x07C0             LSLS     R0,R0,#+31
   \   00000076   0xD405             BMI.N    ??HAL_UART_DMAResume_5
   1075            {
   1076              /* Enable UART peripheral */
   1077              __HAL_UART_ENABLE(huart);
   \   00000078   0x6808             LDR      R0,[R1, #+0]
   \   0000007A   0x6800             LDR      R0,[R0, #+0]
   \   0000007C   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000080   0x680A             LDR      R2,[R1, #+0]
   \   00000082   0x6010             STR      R0,[R2, #+0]
   1078            }
   1079          
   1080            return HAL_OK;
   \                     ??HAL_UART_DMAResume_5: (+1)
   \   00000084   0x2000             MOVS     R0,#+0
   \                     ??HAL_UART_DMAResume_1: (+1)
   \   00000086   0x4770             BX       LR               ;; return
   1081          }
   1082          
   1083          /**
   1084            * @brief Stops the DMA Transfer.
   1085            * @param huart: UART handle
   1086            * @retval None
   1087            */

   \                                 In section .text, align 2, keep-with-next
   1088          HAL_StatusTypeDef HAL_UART_DMAStop(UART_HandleTypeDef *huart)
   1089          {
   \                     HAL_UART_DMAStop: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1090            /* The Lock is not implemented on this API to allow the user application
   1091               to call the HAL UART API under callbacks HAL_UART_TxCpltCallback() / HAL_UART_RxCpltCallback() /
   1092               HAL_UART_TxHalfCpltCallback / HAL_UART_RxHalfCpltCallback: 
   1093               indeed, when HAL_DMA_Abort() API is called, the DMA TX/RX Transfer or Half Transfer complete  
   1094               interrupt is generated if the DMA transfer interruption occurs at the middle or at the end of 
   1095               the stream and the corresponding call back is executed. */
   1096            
   1097            /* Disable the UART Tx/Rx DMA requests */
   1098            huart->Instance->CR3 &= ~USART_CR3_DMAT;
   \   00000004   0x6820             LDR      R0,[R4, #+0]
   \   00000006   0x6880             LDR      R0,[R0, #+8]
   \   00000008   0xF030 0x0080      BICS     R0,R0,#0x80
   \   0000000C   0x6821             LDR      R1,[R4, #+0]
   \   0000000E   0x6088             STR      R0,[R1, #+8]
   1099            huart->Instance->CR3 &= ~USART_CR3_DMAR;
   \   00000010   0x6820             LDR      R0,[R4, #+0]
   \   00000012   0x6880             LDR      R0,[R0, #+8]
   \   00000014   0xF030 0x0040      BICS     R0,R0,#0x40
   \   00000018   0x6821             LDR      R1,[R4, #+0]
   \   0000001A   0x6088             STR      R0,[R1, #+8]
   1100            
   1101            /* Abort the UART DMA tx channel */
   1102            if(huart->hdmatx != NULL)
   \   0000001C   0x6E20             LDR      R0,[R4, #+96]
   \   0000001E   0x2800             CMP      R0,#+0
   \   00000020   0xD002             BEQ.N    ??HAL_UART_DMAStop_0
   1103            {
   1104              HAL_DMA_Abort(huart->hdmatx);
   \   00000022   0x6E20             LDR      R0,[R4, #+96]
   \   00000024   0x.... 0x....      BL       HAL_DMA_Abort
   1105            }
   1106            /* Abort the UART DMA rx channel */
   1107            if(huart->hdmarx != NULL)
   \                     ??HAL_UART_DMAStop_0: (+1)
   \   00000028   0x6E60             LDR      R0,[R4, #+100]
   \   0000002A   0x2800             CMP      R0,#+0
   \   0000002C   0xD002             BEQ.N    ??HAL_UART_DMAStop_1
   1108            {
   1109              HAL_DMA_Abort(huart->hdmarx);
   \   0000002E   0x6E60             LDR      R0,[R4, #+100]
   \   00000030   0x.... 0x....      BL       HAL_DMA_Abort
   1110            }
   1111            
   1112            huart->State = HAL_UART_STATE_READY;
   \                     ??HAL_UART_DMAStop_1: (+1)
   \   00000034   0x2001             MOVS     R0,#+1
   \   00000036   0xF884 0x0069      STRB     R0,[R4, #+105]
   1113            
   1114            return HAL_OK;
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0xBD10             POP      {R4,PC}          ;; return
   1115          }
   1116          
   1117          /**
   1118            * @brief This function handles UART interrupt request.
   1119            * @param huart: uart handle
   1120            * @retval None
   1121            */

   \                                 In section .text, align 2, keep-with-next
   1122          void HAL_UART_IRQHandler(UART_HandleTypeDef *huart)
   1123          {
   \                     HAL_UART_IRQHandler: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1124            /* UART parity error interrupt occurred -------------------------------------*/
   1125            if((__HAL_UART_GET_IT(huart, UART_IT_PE) != RESET) && (__HAL_UART_GET_IT_SOURCE(huart, UART_IT_PE) != RESET))
   \   00000004   0x6820             LDR      R0,[R4, #+0]
   \   00000006   0x69C0             LDR      R0,[R0, #+28]
   \   00000008   0x07C0             LSLS     R0,R0,#+31
   \   0000000A   0xD50E             BPL.N    ??HAL_UART_IRQHandler_0
   \   0000000C   0x6820             LDR      R0,[R4, #+0]
   \   0000000E   0x6800             LDR      R0,[R0, #+0]
   \   00000010   0x05C0             LSLS     R0,R0,#+23
   \   00000012   0xD50A             BPL.N    ??HAL_UART_IRQHandler_0
   1126            { 
   1127          		__HAL_UART_CLEAR_PEFLAG(huart);
   \   00000014   0xF07F 0x0001      MVNS     R0,#+1
   \   00000018   0x6821             LDR      R1,[R4, #+0]
   \   0000001A   0x6208             STR      R0,[R1, #+32]
   1128          
   1129              huart->ErrorCode |= HAL_UART_ERROR_PE;
   \   0000001C   0x6EE0             LDR      R0,[R4, #+108]
   \   0000001E   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000022   0x66E0             STR      R0,[R4, #+108]
   1130              /* Set the UART state ready to be able to start again the process */
   1131              huart->State = HAL_UART_STATE_READY;
   \   00000024   0x2001             MOVS     R0,#+1
   \   00000026   0xF884 0x0069      STRB     R0,[R4, #+105]
   1132            }
   1133            
   1134            /* UART frame error interrupt occurred --------------------------------------*/
   1135            if((__HAL_UART_GET_IT(huart, UART_IT_FE) != RESET) && (__HAL_UART_GET_IT_SOURCE(huart, UART_IT_ERR) != RESET))
   \                     ??HAL_UART_IRQHandler_0: (+1)
   \   0000002A   0x6820             LDR      R0,[R4, #+0]
   \   0000002C   0x69C0             LDR      R0,[R0, #+28]
   \   0000002E   0x0780             LSLS     R0,R0,#+30
   \   00000030   0xD50E             BPL.N    ??HAL_UART_IRQHandler_1
   \   00000032   0x6820             LDR      R0,[R4, #+0]
   \   00000034   0x6880             LDR      R0,[R0, #+8]
   \   00000036   0x07C0             LSLS     R0,R0,#+31
   \   00000038   0xD50A             BPL.N    ??HAL_UART_IRQHandler_1
   1136            { 
   1137              __HAL_UART_CLEAR_FEFLAG(huart);
   \   0000003A   0xF07F 0x0002      MVNS     R0,#+2
   \   0000003E   0x6821             LDR      R1,[R4, #+0]
   \   00000040   0x6208             STR      R0,[R1, #+32]
   1138          
   1139              huart->ErrorCode |= HAL_UART_ERROR_FE;
   \   00000042   0x6EE0             LDR      R0,[R4, #+108]
   \   00000044   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   00000048   0x66E0             STR      R0,[R4, #+108]
   1140              /* Set the UART state ready to be able to start again the process */
   1141              huart->State = HAL_UART_STATE_READY;
   \   0000004A   0x2001             MOVS     R0,#+1
   \   0000004C   0xF884 0x0069      STRB     R0,[R4, #+105]
   1142            }
   1143            
   1144            /* UART noise error interrupt occurred --------------------------------------*/
   1145            if((__HAL_UART_GET_IT(huart, UART_IT_NE) != RESET) && (__HAL_UART_GET_IT_SOURCE(huart, UART_IT_ERR) != RESET))
   \                     ??HAL_UART_IRQHandler_1: (+1)
   \   00000050   0x6820             LDR      R0,[R4, #+0]
   \   00000052   0x69C0             LDR      R0,[R0, #+28]
   \   00000054   0x0740             LSLS     R0,R0,#+29
   \   00000056   0xD50E             BPL.N    ??HAL_UART_IRQHandler_2
   \   00000058   0x6820             LDR      R0,[R4, #+0]
   \   0000005A   0x6880             LDR      R0,[R0, #+8]
   \   0000005C   0x07C0             LSLS     R0,R0,#+31
   \   0000005E   0xD50A             BPL.N    ??HAL_UART_IRQHandler_2
   1146            { 
   1147              __HAL_UART_CLEAR_NEFLAG(huart);
   \   00000060   0xF07F 0x0004      MVNS     R0,#+4
   \   00000064   0x6821             LDR      R1,[R4, #+0]
   \   00000066   0x6208             STR      R0,[R1, #+32]
   1148          
   1149              huart->ErrorCode |= HAL_UART_ERROR_NE;
   \   00000068   0x6EE0             LDR      R0,[R4, #+108]
   \   0000006A   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   0000006E   0x66E0             STR      R0,[R4, #+108]
   1150              /* Set the UART state ready to be able to start again the process */
   1151              huart->State = HAL_UART_STATE_READY;
   \   00000070   0x2001             MOVS     R0,#+1
   \   00000072   0xF884 0x0069      STRB     R0,[R4, #+105]
   1152            }
   1153            
   1154            /* UART Over-Run interrupt occurred -----------------------------------------*/
   1155            if((__HAL_UART_GET_IT(huart, UART_IT_ORE) != RESET) && (__HAL_UART_GET_IT_SOURCE(huart, UART_IT_ERR) != RESET))
   \                     ??HAL_UART_IRQHandler_2: (+1)
   \   00000076   0x6820             LDR      R0,[R4, #+0]
   \   00000078   0x69C0             LDR      R0,[R0, #+28]
   \   0000007A   0x0700             LSLS     R0,R0,#+28
   \   0000007C   0xD50E             BPL.N    ??HAL_UART_IRQHandler_3
   \   0000007E   0x6820             LDR      R0,[R4, #+0]
   \   00000080   0x6880             LDR      R0,[R0, #+8]
   \   00000082   0x07C0             LSLS     R0,R0,#+31
   \   00000084   0xD50A             BPL.N    ??HAL_UART_IRQHandler_3
   1156            { 
   1157              __HAL_UART_CLEAR_OREFLAG(huart);
   \   00000086   0xF07F 0x0008      MVNS     R0,#+8
   \   0000008A   0x6821             LDR      R1,[R4, #+0]
   \   0000008C   0x6208             STR      R0,[R1, #+32]
   1158          
   1159              huart->ErrorCode |= HAL_UART_ERROR_ORE;
   \   0000008E   0x6EE0             LDR      R0,[R4, #+108]
   \   00000090   0xF050 0x0008      ORRS     R0,R0,#0x8
   \   00000094   0x66E0             STR      R0,[R4, #+108]
   1160              /* Set the UART state ready to be able to start again the process */
   1161              huart->State = HAL_UART_STATE_READY;
   \   00000096   0x2001             MOVS     R0,#+1
   \   00000098   0xF884 0x0069      STRB     R0,[R4, #+105]
   1162            }
   1163          
   1164             /* Call UART Error Call back function if need be --------------------------*/
   1165            if(huart->ErrorCode != HAL_UART_ERROR_NONE)
   \                     ??HAL_UART_IRQHandler_3: (+1)
   \   0000009C   0x6EE0             LDR      R0,[R4, #+108]
   \   0000009E   0x2800             CMP      R0,#+0
   \   000000A0   0xD002             BEQ.N    ??HAL_UART_IRQHandler_4
   1166            {
   1167              HAL_UART_ErrorCallback(huart);
   \   000000A2   0x0020             MOVS     R0,R4
   \   000000A4   0x.... 0x....      BL       HAL_UART_ErrorCallback
   1168            }
   1169          
   1170            /* UART in mode Receiver ---------------------------------------------------*/
   1171            if((__HAL_UART_GET_IT(huart, UART_IT_RXNE) != RESET) && (__HAL_UART_GET_IT_SOURCE(huart, UART_IT_RXNE) != RESET))
   \                     ??HAL_UART_IRQHandler_4: (+1)
   \   000000A8   0x6820             LDR      R0,[R4, #+0]
   \   000000AA   0x69C0             LDR      R0,[R0, #+28]
   \   000000AC   0x0680             LSLS     R0,R0,#+26
   \   000000AE   0xD50C             BPL.N    ??HAL_UART_IRQHandler_5
   \   000000B0   0x6820             LDR      R0,[R4, #+0]
   \   000000B2   0x6800             LDR      R0,[R0, #+0]
   \   000000B4   0x0680             LSLS     R0,R0,#+26
   \   000000B6   0xD508             BPL.N    ??HAL_UART_IRQHandler_5
   1172            { 
   1173              UART_Receive_IT(huart);
   \   000000B8   0x0020             MOVS     R0,R4
   \   000000BA   0x.... 0x....      BL       UART_Receive_IT
   1174              /* Clear RXNE interrupt flag */
   1175              __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
   \   000000BE   0x6820             LDR      R0,[R4, #+0]
   \   000000C0   0x6980             LDR      R0,[R0, #+24]
   \   000000C2   0xF050 0x0008      ORRS     R0,R0,#0x8
   \   000000C6   0x6821             LDR      R1,[R4, #+0]
   \   000000C8   0x6188             STR      R0,[R1, #+24]
   1176            }
   1177            
   1178          
   1179            /* UART in mode Transmitter ------------------------------------------------*/
   1180           if((__HAL_UART_GET_IT(huart, UART_IT_TXE) != RESET) &&(__HAL_UART_GET_IT_SOURCE(huart, UART_IT_TXE) != RESET))
   \                     ??HAL_UART_IRQHandler_5: (+1)
   \   000000CA   0x6820             LDR      R0,[R4, #+0]
   \   000000CC   0x69C0             LDR      R0,[R0, #+28]
   \   000000CE   0x0600             LSLS     R0,R0,#+24
   \   000000D0   0xD506             BPL.N    ??HAL_UART_IRQHandler_6
   \   000000D2   0x6820             LDR      R0,[R4, #+0]
   \   000000D4   0x6800             LDR      R0,[R0, #+0]
   \   000000D6   0x0600             LSLS     R0,R0,#+24
   \   000000D8   0xD502             BPL.N    ??HAL_UART_IRQHandler_6
   1181            {
   1182              UART_Transmit_IT(huart);
   \   000000DA   0x0020             MOVS     R0,R4
   \   000000DC   0x.... 0x....      BL       UART_Transmit_IT
   1183            }
   1184          
   1185            /* UART in mode Transmitter (transmission end) -----------------------------*/
   1186           if((__HAL_UART_GET_IT(huart, UART_IT_TC) != RESET) &&(__HAL_UART_GET_IT_SOURCE(huart, UART_IT_TC) != RESET))
   \                     ??HAL_UART_IRQHandler_6: (+1)
   \   000000E0   0x6820             LDR      R0,[R4, #+0]
   \   000000E2   0x69C0             LDR      R0,[R0, #+28]
   \   000000E4   0x0640             LSLS     R0,R0,#+25
   \   000000E6   0xD506             BPL.N    ??HAL_UART_IRQHandler_7
   \   000000E8   0x6820             LDR      R0,[R4, #+0]
   \   000000EA   0x6800             LDR      R0,[R0, #+0]
   \   000000EC   0x0640             LSLS     R0,R0,#+25
   \   000000EE   0xD502             BPL.N    ??HAL_UART_IRQHandler_7
   1187            {
   1188              UART_EndTransmit_IT(huart);
   \   000000F0   0x0020             MOVS     R0,R4
   \   000000F2   0x.... 0x....      BL       UART_EndTransmit_IT
   1189            }
   1190            
   1191          }
   \                     ??HAL_UART_IRQHandler_7: (+1)
   \   000000F6   0xBD10             POP      {R4,PC}          ;; return
   1192          
   1193          
   1194          /**
   1195            * @brief  This function handles UART Communication Timeout.
   1196            * @param  huart: UART handle
   1197            * @param  Flag: specifies the UART flag to check.
   1198            * @param  Status: The new Flag status (SET or RESET).
   1199            * @param  Timeout: Timeout duration
   1200            * @retval HAL status
   1201            */

   \                                 In section .text, align 2, keep-with-next
   1202          HAL_StatusTypeDef UART_WaitOnFlagUntilTimeout(UART_HandleTypeDef *huart, uint32_t Flag, FlagStatus Status, uint32_t Timeout)
   1203          {
   \                     UART_WaitOnFlagUntilTimeout: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
   1204            uint32_t tickstart = HAL_GetTick();
   \   0000000C   0x.... 0x....      BL       HAL_GetTick
   \   00000010   0x4680             MOV      R8,R0
   1205            
   1206            /* Wait until flag is set */
   1207            if(Status == RESET)
   \   00000012   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000014   0x2E00             CMP      R6,#+0
   \   00000016   0xD12F             BNE.N    ??UART_WaitOnFlagUntilTimeout_0
   1208            {    
   1209              while(__HAL_UART_GET_FLAG(huart, Flag) == RESET)
   \                     ??UART_WaitOnFlagUntilTimeout_1: (+1)
   \   00000018   0x6820             LDR      R0,[R4, #+0]
   \   0000001A   0x69C0             LDR      R0,[R0, #+28]
   \   0000001C   0x4028             ANDS     R0,R5,R0
   \   0000001E   0x42A8             CMP      R0,R5
   \   00000020   0xD05A             BEQ.N    ??UART_WaitOnFlagUntilTimeout_2
   1210              {
   1211                /* Check for the Timeout */
   1212                if(Timeout != HAL_MAX_DELAY)
   \   00000022   0xF117 0x0F01      CMN      R7,#+1
   \   00000026   0xD0F7             BEQ.N    ??UART_WaitOnFlagUntilTimeout_1
   1213                {
   1214                  if((Timeout == 0)||((HAL_GetTick()-tickstart) >=  Timeout))
   \   00000028   0x2F00             CMP      R7,#+0
   \   0000002A   0xD005             BEQ.N    ??UART_WaitOnFlagUntilTimeout_3
   \   0000002C   0x.... 0x....      BL       HAL_GetTick
   \   00000030   0xEBB0 0x0008      SUBS     R0,R0,R8
   \   00000034   0x42B8             CMP      R0,R7
   \   00000036   0xD3EF             BCC.N    ??UART_WaitOnFlagUntilTimeout_1
   1215                  {
   1216                    /* Disable TXE, RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts for the interrupt process */
   1217                    __HAL_UART_DISABLE_IT(huart, UART_IT_TXE);
   \                     ??UART_WaitOnFlagUntilTimeout_3: (+1)
   \   00000038   0x6820             LDR      R0,[R4, #+0]
   \   0000003A   0x6800             LDR      R0,[R0, #+0]
   \   0000003C   0xF030 0x0080      BICS     R0,R0,#0x80
   \   00000040   0x6821             LDR      R1,[R4, #+0]
   \   00000042   0x6008             STR      R0,[R1, #+0]
   1218                    __HAL_UART_DISABLE_IT(huart, UART_IT_RXNE);
   \   00000044   0x6820             LDR      R0,[R4, #+0]
   \   00000046   0x6800             LDR      R0,[R0, #+0]
   \   00000048   0xF030 0x0020      BICS     R0,R0,#0x20
   \   0000004C   0x6821             LDR      R1,[R4, #+0]
   \   0000004E   0x6008             STR      R0,[R1, #+0]
   1219                    __HAL_UART_DISABLE_IT(huart, UART_IT_PE);
   \   00000050   0x6820             LDR      R0,[R4, #+0]
   \   00000052   0x6800             LDR      R0,[R0, #+0]
   \   00000054   0xF430 0x7080      BICS     R0,R0,#0x100
   \   00000058   0x6821             LDR      R1,[R4, #+0]
   \   0000005A   0x6008             STR      R0,[R1, #+0]
   1220                    __HAL_UART_DISABLE_IT(huart, UART_IT_ERR);
   \   0000005C   0x6820             LDR      R0,[R4, #+0]
   \   0000005E   0x6880             LDR      R0,[R0, #+8]
   \   00000060   0x0840             LSRS     R0,R0,#+1
   \   00000062   0x0040             LSLS     R0,R0,#+1
   \   00000064   0x6821             LDR      R1,[R4, #+0]
   \   00000066   0x6088             STR      R0,[R1, #+8]
   1221                    
   1222                    huart->State= HAL_UART_STATE_READY;
   \   00000068   0x2001             MOVS     R0,#+1
   \   0000006A   0xF884 0x0069      STRB     R0,[R4, #+105]
   1223                    
   1224                    /* Process Unlocked */
   1225                    __HAL_UNLOCK(huart);
   \   0000006E   0x2000             MOVS     R0,#+0
   \   00000070   0xF884 0x0068      STRB     R0,[R4, #+104]
   1226                    
   1227                    return HAL_TIMEOUT;
   \   00000074   0x2003             MOVS     R0,#+3
   \   00000076   0xE030             B.N      ??UART_WaitOnFlagUntilTimeout_4
   1228                  }
   1229                }
   1230              }
   1231            }
   1232            else
   1233            {
   1234              while(__HAL_UART_GET_FLAG(huart, Flag) != RESET)
   \                     ??UART_WaitOnFlagUntilTimeout_0: (+1)
   \   00000078   0x6820             LDR      R0,[R4, #+0]
   \   0000007A   0x69C0             LDR      R0,[R0, #+28]
   \   0000007C   0x4028             ANDS     R0,R5,R0
   \   0000007E   0x42A8             CMP      R0,R5
   \   00000080   0xD12A             BNE.N    ??UART_WaitOnFlagUntilTimeout_2
   1235              {
   1236                /* Check for the Timeout */
   1237                if(Timeout != HAL_MAX_DELAY)
   \   00000082   0xF117 0x0F01      CMN      R7,#+1
   \   00000086   0xD0F7             BEQ.N    ??UART_WaitOnFlagUntilTimeout_0
   1238                {
   1239                  if((Timeout == 0)||((HAL_GetTick()-tickstart) >=  Timeout))
   \   00000088   0x2F00             CMP      R7,#+0
   \   0000008A   0xD005             BEQ.N    ??UART_WaitOnFlagUntilTimeout_5
   \   0000008C   0x.... 0x....      BL       HAL_GetTick
   \   00000090   0xEBB0 0x0008      SUBS     R0,R0,R8
   \   00000094   0x42B8             CMP      R0,R7
   \   00000096   0xD3EF             BCC.N    ??UART_WaitOnFlagUntilTimeout_0
   1240                  {
   1241                    /* Disable TXE, RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts for the interrupt process */
   1242                    __HAL_UART_DISABLE_IT(huart, UART_IT_TXE);
   \                     ??UART_WaitOnFlagUntilTimeout_5: (+1)
   \   00000098   0x6820             LDR      R0,[R4, #+0]
   \   0000009A   0x6800             LDR      R0,[R0, #+0]
   \   0000009C   0xF030 0x0080      BICS     R0,R0,#0x80
   \   000000A0   0x6821             LDR      R1,[R4, #+0]
   \   000000A2   0x6008             STR      R0,[R1, #+0]
   1243                    __HAL_UART_DISABLE_IT(huart, UART_IT_RXNE);
   \   000000A4   0x6820             LDR      R0,[R4, #+0]
   \   000000A6   0x6800             LDR      R0,[R0, #+0]
   \   000000A8   0xF030 0x0020      BICS     R0,R0,#0x20
   \   000000AC   0x6821             LDR      R1,[R4, #+0]
   \   000000AE   0x6008             STR      R0,[R1, #+0]
   1244                    __HAL_UART_DISABLE_IT(huart, UART_IT_PE);
   \   000000B0   0x6820             LDR      R0,[R4, #+0]
   \   000000B2   0x6800             LDR      R0,[R0, #+0]
   \   000000B4   0xF430 0x7080      BICS     R0,R0,#0x100
   \   000000B8   0x6821             LDR      R1,[R4, #+0]
   \   000000BA   0x6008             STR      R0,[R1, #+0]
   1245                    __HAL_UART_DISABLE_IT(huart, UART_IT_ERR);
   \   000000BC   0x6820             LDR      R0,[R4, #+0]
   \   000000BE   0x6880             LDR      R0,[R0, #+8]
   \   000000C0   0x0840             LSRS     R0,R0,#+1
   \   000000C2   0x0040             LSLS     R0,R0,#+1
   \   000000C4   0x6821             LDR      R1,[R4, #+0]
   \   000000C6   0x6088             STR      R0,[R1, #+8]
   1246                    
   1247                    huart->State= HAL_UART_STATE_READY;
   \   000000C8   0x2001             MOVS     R0,#+1
   \   000000CA   0xF884 0x0069      STRB     R0,[R4, #+105]
   1248                    
   1249                    /* Process Unlocked */
   1250                    __HAL_UNLOCK(huart);
   \   000000CE   0x2000             MOVS     R0,#+0
   \   000000D0   0xF884 0x0068      STRB     R0,[R4, #+104]
   1251                    
   1252                    return HAL_TIMEOUT;
   \   000000D4   0x2003             MOVS     R0,#+3
   \   000000D6   0xE000             B.N      ??UART_WaitOnFlagUntilTimeout_4
   1253                  }
   1254                }
   1255              }
   1256            }
   1257            return HAL_OK;      
   \                     ??UART_WaitOnFlagUntilTimeout_2: (+1)
   \   000000D8   0x2000             MOVS     R0,#+0
   \                     ??UART_WaitOnFlagUntilTimeout_4: (+1)
   \   000000DA   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   1258          }
   1259          
   1260          
   1261          
   1262          /**
   1263            * @brief DMA UART transmit process complete callback 
   1264            * @param hdma: DMA handle
   1265            * @retval None
   1266            */

   \                                 In section .text, align 4, keep-with-next
   1267          static void UART_DMATransmitCplt(DMA_HandleTypeDef *hdma)     
   1268          {
   \                     UART_DMATransmitCplt: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1269            UART_HandleTypeDef* huart = ( UART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   \   00000004   0x6BA5             LDR      R5,[R4, #+56]
   1270            
   1271            /* DMA Normal mode*/
   1272            if((hdma->Instance->CR & DMA_SxCR_CIRC) == 0)
   \   00000006   0x6820             LDR      R0,[R4, #+0]
   \   00000008   0x6800             LDR      R0,[R0, #+0]
   \   0000000A   0x05C0             LSLS     R0,R0,#+23
   \   0000000C   0xD40F             BMI.N    ??UART_DMATransmitCplt_0
   1273            {
   1274              huart->TxXferCount = 0;
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0xF8A5 0x0052      STRH     R0,[R5, #+82]
   1275          
   1276              /* Disable the DMA transfer for transmit request by setting the DMAT bit
   1277                 in the UART CR3 register */
   1278              huart->Instance->CR3 &= (uint32_t)~((uint32_t)USART_CR3_DMAT);
   \   00000014   0x6828             LDR      R0,[R5, #+0]
   \   00000016   0x6880             LDR      R0,[R0, #+8]
   \   00000018   0xF030 0x0080      BICS     R0,R0,#0x80
   \   0000001C   0x6829             LDR      R1,[R5, #+0]
   \   0000001E   0x6088             STR      R0,[R1, #+8]
   1279          
   1280              /* Enable the UART Transmit Complete Interrupt */
   1281              __HAL_UART_ENABLE_IT(huart, UART_IT_TC);
   \   00000020   0x6828             LDR      R0,[R5, #+0]
   \   00000022   0x6800             LDR      R0,[R0, #+0]
   \   00000024   0xF050 0x0040      ORRS     R0,R0,#0x40
   \   00000028   0x6829             LDR      R1,[R5, #+0]
   \   0000002A   0x6008             STR      R0,[R1, #+0]
   \   0000002C   0xE002             B.N      ??UART_DMATransmitCplt_1
   1282            }
   1283            /* DMA Circular mode */
   1284            else
   1285            {
   1286              HAL_UART_TxCpltCallback(huart);
   \                     ??UART_DMATransmitCplt_0: (+1)
   \   0000002E   0x0028             MOVS     R0,R5
   \   00000030   0x.... 0x....      BL       HAL_UART_TxCpltCallback
   1287            }
   1288          }
   \                     ??UART_DMATransmitCplt_1: (+1)
   \   00000034   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1289          
   1290          /**
   1291            * @brief DMA UART transmit process half complete callback 
   1292            * @param hdma : DMA handle
   1293            * @retval None
   1294            */

   \                                 In section .text, align 4, keep-with-next
   1295          static void UART_DMATxHalfCplt(DMA_HandleTypeDef *hdma)
   1296          {
   \                     UART_DMATxHalfCplt: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1297            UART_HandleTypeDef* huart = (UART_HandleTypeDef*)((DMA_HandleTypeDef*)hdma)->Parent;
   \   00000004   0x6BA5             LDR      R5,[R4, #+56]
   1298          
   1299            HAL_UART_TxHalfCpltCallback(huart);
   \   00000006   0x0028             MOVS     R0,R5
   \   00000008   0x.... 0x....      BL       HAL_UART_TxHalfCpltCallback
   1300          }
   \   0000000C   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1301          
   1302          /**
   1303            * @brief DMA UART receive process complete callback 
   1304            * @param hdma: DMA handle
   1305            * @retval None
   1306            */

   \                                 In section .text, align 4, keep-with-next
   1307          static void UART_DMAReceiveCplt(DMA_HandleTypeDef *hdma)  
   1308          {
   \                     UART_DMAReceiveCplt: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1309            UART_HandleTypeDef* huart = ( UART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   \   00000004   0x6BA5             LDR      R5,[R4, #+56]
   1310            
   1311            /* DMA Normal mode */
   1312            if((hdma->Instance->CR & DMA_SxCR_CIRC) == 0)
   \   00000006   0x6820             LDR      R0,[R4, #+0]
   \   00000008   0x6800             LDR      R0,[R0, #+0]
   \   0000000A   0x05C0             LSLS     R0,R0,#+23
   \   0000000C   0xD413             BMI.N    ??UART_DMAReceiveCplt_0
   1313            { 
   1314              huart->RxXferCount = 0;
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0xF8A5 0x005A      STRH     R0,[R5, #+90]
   1315              
   1316              /* Disable the DMA transfer for the receiver request by setting the DMAR bit 
   1317              in the UART CR3 register */
   1318              huart->Instance->CR3 &= (uint32_t)~((uint32_t)USART_CR3_DMAR);
   \   00000014   0x6828             LDR      R0,[R5, #+0]
   \   00000016   0x6880             LDR      R0,[R0, #+8]
   \   00000018   0xF030 0x0040      BICS     R0,R0,#0x40
   \   0000001C   0x6829             LDR      R1,[R5, #+0]
   \   0000001E   0x6088             STR      R0,[R1, #+8]
   1319              
   1320              /* Check if a transmit Process is ongoing or not */
   1321              if(huart->State == HAL_UART_STATE_BUSY_TX_RX) 
   \   00000020   0xF895 0x0069      LDRB     R0,[R5, #+105]
   \   00000024   0x2832             CMP      R0,#+50
   \   00000026   0xD103             BNE.N    ??UART_DMAReceiveCplt_1
   1322              {
   1323                huart->State = HAL_UART_STATE_BUSY_TX;
   \   00000028   0x2012             MOVS     R0,#+18
   \   0000002A   0xF885 0x0069      STRB     R0,[R5, #+105]
   \   0000002E   0xE002             B.N      ??UART_DMAReceiveCplt_0
   1324              }
   1325              else
   1326              {
   1327                huart->State = HAL_UART_STATE_READY;
   \                     ??UART_DMAReceiveCplt_1: (+1)
   \   00000030   0x2001             MOVS     R0,#+1
   \   00000032   0xF885 0x0069      STRB     R0,[R5, #+105]
   1328              }
   1329            }
   1330            HAL_UART_RxCpltCallback(huart);
   \                     ??UART_DMAReceiveCplt_0: (+1)
   \   00000036   0x0028             MOVS     R0,R5
   \   00000038   0x.... 0x....      BL       HAL_UART_RxCpltCallback
   1331          }
   \   0000003C   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1332          
   1333          /**
   1334            * @brief DMA UART receive process half complete callback 
   1335            * @param hdma : DMA handle
   1336            * @retval None
   1337            */

   \                                 In section .text, align 4, keep-with-next
   1338          static void UART_DMARxHalfCplt(DMA_HandleTypeDef *hdma)
   1339          {
   \                     UART_DMARxHalfCplt: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1340            UART_HandleTypeDef* huart = (UART_HandleTypeDef*)((DMA_HandleTypeDef*)hdma)->Parent;
   \   00000004   0x6BA5             LDR      R5,[R4, #+56]
   1341          
   1342            HAL_UART_RxHalfCpltCallback(huart); 
   \   00000006   0x0028             MOVS     R0,R5
   \   00000008   0x.... 0x....      BL       HAL_UART_RxHalfCpltCallback
   1343          }
   \   0000000C   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1344          
   1345          /**
   1346            * @brief DMA UART communication error callback 
   1347            * @param hdma: DMA handle
   1348            * @retval None
   1349            */

   \                                 In section .text, align 4, keep-with-next
   1350          static void UART_DMAError(DMA_HandleTypeDef *hdma)   
   1351          {
   \                     UART_DMAError: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1352            UART_HandleTypeDef* huart = ( UART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   \   00000004   0x6BA5             LDR      R5,[R4, #+56]
   1353            huart->RxXferCount = 0;
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0xF8A5 0x005A      STRH     R0,[R5, #+90]
   1354            huart->TxXferCount = 0;
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0xF8A5 0x0052      STRH     R0,[R5, #+82]
   1355            huart->State= HAL_UART_STATE_READY;
   \   00000012   0x2001             MOVS     R0,#+1
   \   00000014   0xF885 0x0069      STRB     R0,[R5, #+105]
   1356            huart->ErrorCode |= HAL_UART_ERROR_DMA;
   \   00000018   0x6EE8             LDR      R0,[R5, #+108]
   \   0000001A   0xF050 0x0010      ORRS     R0,R0,#0x10
   \   0000001E   0x66E8             STR      R0,[R5, #+108]
   1357            HAL_UART_ErrorCallback(huart);
   \   00000020   0x0028             MOVS     R0,R5
   \   00000022   0x.... 0x....      BL       HAL_UART_ErrorCallback
   1358          }
   \   00000026   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1359          
   1360          /**
   1361            * @brief Tx Transfer completed callbacks
   1362            * @param huart: uart handle
   1363            * @retval None
   1364            */

   \                                 In section .text, align 2, keep-with-next
   1365           __weak void HAL_UART_TxCpltCallback(UART_HandleTypeDef *huart)
   1366          {
   1367            /* NOTE : This function should not be modified, when the callback is needed,
   1368                      the HAL_UART_TxCpltCallback can be implemented in the user file
   1369             */ 
   1370          }
   \                     HAL_UART_TxCpltCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1371          
   1372          /**
   1373            * @brief  Tx Half Transfer completed callbacks.
   1374            * @param  huart: UART handle
   1375            * @retval None
   1376            */

   \                                 In section .text, align 2, keep-with-next
   1377           __weak void HAL_UART_TxHalfCpltCallback(UART_HandleTypeDef *huart)
   1378          {
   1379            /* NOTE: This function should not be modified, when the callback is needed,
   1380                     the HAL_UART_TxHalfCpltCallback can be implemented in the user file
   1381             */ 
   1382          }
   \                     HAL_UART_TxHalfCpltCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1383          
   1384          /**
   1385            * @brief Rx Transfer completed callbacks
   1386            * @param huart: uart handle
   1387            * @retval None
   1388            */

   \                                 In section .text, align 2, keep-with-next
   1389          __weak void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)
   1390          {
   1391            /* NOTE : This function should not be modified, when the callback is needed,
   1392                      the HAL_UART_RxCpltCallback can be implemented in the user file
   1393             */
   1394          }
   \                     HAL_UART_RxCpltCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1395          
   1396          /**
   1397            * @brief  Rx Half Transfer completed callbacks.
   1398            * @param  huart: UART handle
   1399            * @retval None
   1400            */

   \                                 In section .text, align 2, keep-with-next
   1401          __weak void HAL_UART_RxHalfCpltCallback(UART_HandleTypeDef *huart)
   1402          {
   1403            /* NOTE: This function should not be modified, when the callback is needed,
   1404                     the HAL_UART_RxHalfCpltCallback can be implemented in the user file
   1405             */
   1406          }
   \                     HAL_UART_RxHalfCpltCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1407          
   1408          /**
   1409            * @brief UART error callbacks
   1410            * @param huart: uart handle
   1411            * @retval None
   1412            */

   \                                 In section .text, align 2, keep-with-next
   1413           __weak void HAL_UART_ErrorCallback(UART_HandleTypeDef *huart)
   1414          {
   1415            /* NOTE : This function should not be modified, when the callback is needed,
   1416                      the HAL_UART_ErrorCallback can be implemented in the user file
   1417             */ 
   1418          }
   \                     HAL_UART_ErrorCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1419          
   1420          /**
   1421            * @brief Send an amount of data in interrupt mode 
   1422            *         Function called under interruption only, once
   1423            *         interruptions have been enabled by HAL_UART_Transmit_IT()
   1424            * @param  huart: UART handle
   1425            * @retval HAL status
   1426            */

   \                                 In section .text, align 2, keep-with-next
   1427          static HAL_StatusTypeDef UART_Transmit_IT(UART_HandleTypeDef *huart)
   1428          {
   \                     UART_Transmit_IT: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1429            uint16_t* tmp;
   1430          
   1431            if ((huart->State == HAL_UART_STATE_BUSY_TX) || (huart->State == HAL_UART_STATE_BUSY_TX_RX))
   \   00000004   0xF894 0x0069      LDRB     R0,[R4, #+105]
   \   00000008   0x2812             CMP      R0,#+18
   \   0000000A   0xD003             BEQ.N    ??UART_Transmit_IT_0
   \   0000000C   0xF894 0x0069      LDRB     R0,[R4, #+105]
   \   00000010   0x2832             CMP      R0,#+50
   \   00000012   0xD149             BNE.N    ??UART_Transmit_IT_1
   1432            {
   1433          
   1434              if(huart->TxXferCount == 0)
   \                     ??UART_Transmit_IT_0: (+1)
   \   00000014   0xF8B4 0x0052      LDRH     R0,[R4, #+82]
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD126             BNE.N    ??UART_Transmit_IT_2
   1435              {
   1436                /* Disable the UART Transmit Data Register Empty Interrupt */
   1437                __HAL_UART_DISABLE_IT(huart, UART_IT_TXE);
   \   0000001C   0x6820             LDR      R0,[R4, #+0]
   \   0000001E   0x6800             LDR      R0,[R0, #+0]
   \   00000020   0xF030 0x0080      BICS     R0,R0,#0x80
   \   00000024   0x6821             LDR      R1,[R4, #+0]
   \   00000026   0x6008             STR      R0,[R1, #+0]
   1438          
   1439                /* Check if a receive Process is ongoing or not */
   1440                if(huart->State == HAL_UART_STATE_BUSY_TX_RX) 
   \   00000028   0xF894 0x0069      LDRB     R0,[R4, #+105]
   \   0000002C   0x2832             CMP      R0,#+50
   \   0000002E   0xD103             BNE.N    ??UART_Transmit_IT_3
   1441                {
   1442                  huart->State = HAL_UART_STATE_BUSY_RX;
   \   00000030   0x2022             MOVS     R0,#+34
   \   00000032   0xF884 0x0069      STRB     R0,[R4, #+105]
   \   00000036   0xE008             B.N      ??UART_Transmit_IT_4
   1443                }
   1444                else
   1445                {
   1446                  /* Disable the UART Error Interrupt: (Frame error, noise error, overrun error) */
   1447                  __HAL_UART_DISABLE_IT(huart, UART_IT_ERR);
   \                     ??UART_Transmit_IT_3: (+1)
   \   00000038   0x6820             LDR      R0,[R4, #+0]
   \   0000003A   0x6880             LDR      R0,[R0, #+8]
   \   0000003C   0x0840             LSRS     R0,R0,#+1
   \   0000003E   0x0040             LSLS     R0,R0,#+1
   \   00000040   0x6821             LDR      R1,[R4, #+0]
   \   00000042   0x6088             STR      R0,[R1, #+8]
   1448                  
   1449                  huart->State = HAL_UART_STATE_READY;
   \   00000044   0x2001             MOVS     R0,#+1
   \   00000046   0xF884 0x0069      STRB     R0,[R4, #+105]
   1450                }
   1451                
   1452                /* Wait on TC flag to be able to start a second transfer */
   1453                if(UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TC, RESET, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
   \                     ??UART_Transmit_IT_4: (+1)
   \   0000004A   0xF07F 0x437E      MVNS     R3,#-33554432
   \   0000004E   0x2200             MOVS     R2,#+0
   \   00000050   0x2140             MOVS     R1,#+64
   \   00000052   0x0020             MOVS     R0,R4
   \   00000054   0x.... 0x....      BL       UART_WaitOnFlagUntilTimeout
   \   00000058   0x2800             CMP      R0,#+0
   \   0000005A   0xD001             BEQ.N    ??UART_Transmit_IT_5
   1454                { 
   1455                  return HAL_TIMEOUT;
   \   0000005C   0x2003             MOVS     R0,#+3
   \   0000005E   0xE024             B.N      ??UART_Transmit_IT_6
   1456                }
   1457          
   1458                HAL_UART_TxCpltCallback(huart);
   \                     ??UART_Transmit_IT_5: (+1)
   \   00000060   0x0020             MOVS     R0,R4
   \   00000062   0x.... 0x....      BL       HAL_UART_TxCpltCallback
   1459          
   1460                return HAL_OK;
   \   00000066   0x2000             MOVS     R0,#+0
   \   00000068   0xE01F             B.N      ??UART_Transmit_IT_6
   1461              }
   1462              else
   1463              {
   1464                if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
   \                     ??UART_Transmit_IT_2: (+1)
   \   0000006A   0x68A0             LDR      R0,[R4, #+8]
   \   0000006C   0xF5B0 0x5F80      CMP      R0,#+4096
   \   00000070   0xD10D             BNE.N    ??UART_Transmit_IT_7
   \   00000072   0x6920             LDR      R0,[R4, #+16]
   \   00000074   0x2800             CMP      R0,#+0
   \   00000076   0xD10A             BNE.N    ??UART_Transmit_IT_7
   1465                {
   1466                  tmp = (uint16_t*) huart->pTxBuffPtr;
   \   00000078   0x6CE0             LDR      R0,[R4, #+76]
   \   0000007A   0x0005             MOVS     R5,R0
   1467                  huart->Instance->TDR = (*tmp & (uint16_t)0x01FF);
   \   0000007C   0x8828             LDRH     R0,[R5, #+0]
   \   0000007E   0x05C0             LSLS     R0,R0,#+23       ;; ZeroExtS R0,R0,#+23,#+23
   \   00000080   0x0DC0             LSRS     R0,R0,#+23
   \   00000082   0x6821             LDR      R1,[R4, #+0]
   \   00000084   0x6288             STR      R0,[R1, #+40]
   1468                  huart->pTxBuffPtr += 2;
   \   00000086   0x6CE0             LDR      R0,[R4, #+76]
   \   00000088   0x1C80             ADDS     R0,R0,#+2
   \   0000008A   0x64E0             STR      R0,[R4, #+76]
   \   0000008C   0xE005             B.N      ??UART_Transmit_IT_8
   1469                } 
   1470                else
   1471                {
   1472                  huart->Instance->TDR = (uint8_t)(*huart->pTxBuffPtr++ & (uint8_t)0xFF);
   \                     ??UART_Transmit_IT_7: (+1)
   \   0000008E   0x6CE0             LDR      R0,[R4, #+76]
   \   00000090   0x1C41             ADDS     R1,R0,#+1
   \   00000092   0x64E1             STR      R1,[R4, #+76]
   \   00000094   0x7800             LDRB     R0,[R0, #+0]
   \   00000096   0x6821             LDR      R1,[R4, #+0]
   \   00000098   0x6288             STR      R0,[R1, #+40]
   1473                }
   1474          
   1475                huart->TxXferCount--;
   \                     ??UART_Transmit_IT_8: (+1)
   \   0000009A   0xF8B4 0x0052      LDRH     R0,[R4, #+82]
   \   0000009E   0x1E40             SUBS     R0,R0,#+1
   \   000000A0   0xF8A4 0x0052      STRH     R0,[R4, #+82]
   1476                
   1477                return HAL_OK;
   \   000000A4   0x2000             MOVS     R0,#+0
   \   000000A6   0xE000             B.N      ??UART_Transmit_IT_6
   1478              }
   1479            }
   1480            else
   1481            {
   1482              return HAL_BUSY;   
   \                     ??UART_Transmit_IT_1: (+1)
   \   000000A8   0x2002             MOVS     R0,#+2
   \                     ??UART_Transmit_IT_6: (+1)
   \   000000AA   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1483            }
   1484          }
   1485          
   1486          /**
   1487            * @brief  Wrap up transmission in non-blocking mode.
   1488            * @param  huart: pointer to a UART_HandleTypeDef structure that contains
   1489            *                the configuration information for the specified UART module.
   1490            * @retval HAL status
   1491            */

   \                                 In section .text, align 2, keep-with-next
   1492          static HAL_StatusTypeDef UART_EndTransmit_IT(UART_HandleTypeDef *huart)
   1493          {
   \                     UART_EndTransmit_IT: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1494            /* Disable the UART Transmit Complete Interrupt */
   1495            __HAL_UART_DISABLE_IT(huart, UART_IT_TC);
   \   00000004   0x6820             LDR      R0,[R4, #+0]
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0xF030 0x0040      BICS     R0,R0,#0x40
   \   0000000C   0x6821             LDR      R1,[R4, #+0]
   \   0000000E   0x6008             STR      R0,[R1, #+0]
   1496          
   1497            /* Check if a receive process is ongoing or not */
   1498            if(huart->State == HAL_UART_STATE_BUSY_TX_RX)
   \   00000010   0xF894 0x0069      LDRB     R0,[R4, #+105]
   \   00000014   0x2832             CMP      R0,#+50
   \   00000016   0xD103             BNE.N    ??UART_EndTransmit_IT_0
   1499            {
   1500              huart->State = HAL_UART_STATE_BUSY_RX;
   \   00000018   0x2022             MOVS     R0,#+34
   \   0000001A   0xF884 0x0069      STRB     R0,[R4, #+105]
   \   0000001E   0xE008             B.N      ??UART_EndTransmit_IT_1
   1501            }
   1502            else
   1503            {
   1504              /* Disable the UART Error Interrupt: (Frame error, noise error, overrun error) */
   1505              __HAL_UART_DISABLE_IT(huart, UART_IT_ERR);
   \                     ??UART_EndTransmit_IT_0: (+1)
   \   00000020   0x6820             LDR      R0,[R4, #+0]
   \   00000022   0x6880             LDR      R0,[R0, #+8]
   \   00000024   0x0840             LSRS     R0,R0,#+1
   \   00000026   0x0040             LSLS     R0,R0,#+1
   \   00000028   0x6821             LDR      R1,[R4, #+0]
   \   0000002A   0x6088             STR      R0,[R1, #+8]
   1506          
   1507              huart->State = HAL_UART_STATE_READY;
   \   0000002C   0x2001             MOVS     R0,#+1
   \   0000002E   0xF884 0x0069      STRB     R0,[R4, #+105]
   1508            }
   1509          
   1510            HAL_UART_TxCpltCallback(huart);
   \                     ??UART_EndTransmit_IT_1: (+1)
   \   00000032   0x0020             MOVS     R0,R4
   \   00000034   0x.... 0x....      BL       HAL_UART_TxCpltCallback
   1511          
   1512            return HAL_OK;
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0xBD10             POP      {R4,PC}          ;; return
   1513          }
   1514          
   1515          /**
   1516            * @brief Receive an amount of data in interrupt mode 
   1517            *         Function called under interruption only, once
   1518            *         interruptions have been enabled by HAL_UART_Receive_IT()
   1519            * @param  huart: UART handle
   1520            * @retval HAL status
   1521            */

   \                                 In section .text, align 2, keep-with-next
   1522          static HAL_StatusTypeDef UART_Receive_IT(UART_HandleTypeDef *huart)
   1523          {
   \                     UART_Receive_IT: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1524            uint16_t* tmp;
   1525            uint16_t uhMask = huart->Mask;
   \   00000004   0xF8B4 0x605C      LDRH     R6,[R4, #+92]
   1526          
   1527            if((huart->State == HAL_UART_STATE_BUSY_RX) || (huart->State == HAL_UART_STATE_BUSY_TX_RX))
   \   00000008   0xF894 0x0069      LDRB     R0,[R4, #+105]
   \   0000000C   0x2822             CMP      R0,#+34
   \   0000000E   0xD003             BEQ.N    ??UART_Receive_IT_0
   \   00000010   0xF894 0x0069      LDRB     R0,[R4, #+105]
   \   00000014   0x2832             CMP      R0,#+50
   \   00000016   0xD144             BNE.N    ??UART_Receive_IT_1
   1528            {
   1529              
   1530              if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
   \                     ??UART_Receive_IT_0: (+1)
   \   00000018   0x68A0             LDR      R0,[R4, #+8]
   \   0000001A   0xF5B0 0x5F80      CMP      R0,#+4096
   \   0000001E   0xD10C             BNE.N    ??UART_Receive_IT_2
   \   00000020   0x6920             LDR      R0,[R4, #+16]
   \   00000022   0x2800             CMP      R0,#+0
   \   00000024   0xD109             BNE.N    ??UART_Receive_IT_2
   1531              {
   1532                tmp = (uint16_t*) huart->pRxBuffPtr ;
   \   00000026   0x6D60             LDR      R0,[R4, #+84]
   \   00000028   0x0005             MOVS     R5,R0
   1533                *tmp = (uint16_t)(huart->Instance->RDR & uhMask);
   \   0000002A   0x6820             LDR      R0,[R4, #+0]
   \   0000002C   0x6A40             LDR      R0,[R0, #+36]
   \   0000002E   0x4030             ANDS     R0,R6,R0
   \   00000030   0x8028             STRH     R0,[R5, #+0]
   1534                huart->pRxBuffPtr +=2;
   \   00000032   0x6D60             LDR      R0,[R4, #+84]
   \   00000034   0x1C80             ADDS     R0,R0,#+2
   \   00000036   0x6560             STR      R0,[R4, #+84]
   \   00000038   0xE006             B.N      ??UART_Receive_IT_3
   1535              }
   1536              else
   1537              {
   1538                *huart->pRxBuffPtr++ = (uint8_t)(huart->Instance->RDR & (uint8_t)uhMask); 
   \                     ??UART_Receive_IT_2: (+1)
   \   0000003A   0x6D60             LDR      R0,[R4, #+84]
   \   0000003C   0x1C41             ADDS     R1,R0,#+1
   \   0000003E   0x6561             STR      R1,[R4, #+84]
   \   00000040   0x6821             LDR      R1,[R4, #+0]
   \   00000042   0x6A49             LDR      R1,[R1, #+36]
   \   00000044   0x4031             ANDS     R1,R6,R1
   \   00000046   0x7001             STRB     R1,[R0, #+0]
   1539              }
   1540          
   1541              if(--huart->RxXferCount == 0)
   \                     ??UART_Receive_IT_3: (+1)
   \   00000048   0xF8B4 0x005A      LDRH     R0,[R4, #+90]
   \   0000004C   0x1E40             SUBS     R0,R0,#+1
   \   0000004E   0xF8A4 0x005A      STRH     R0,[R4, #+90]
   \   00000052   0xF8B4 0x005A      LDRH     R0,[R4, #+90]
   \   00000056   0x2800             CMP      R0,#+0
   \   00000058   0xD121             BNE.N    ??UART_Receive_IT_4
   1542              {
   1543                __HAL_UART_DISABLE_IT(huart, UART_IT_RXNE);
   \   0000005A   0x6820             LDR      R0,[R4, #+0]
   \   0000005C   0x6800             LDR      R0,[R0, #+0]
   \   0000005E   0xF030 0x0020      BICS     R0,R0,#0x20
   \   00000062   0x6821             LDR      R1,[R4, #+0]
   \   00000064   0x6008             STR      R0,[R1, #+0]
   1544          
   1545                /* Check if a transmit Process is ongoing or not */
   1546                if(huart->State == HAL_UART_STATE_BUSY_TX_RX) 
   \   00000066   0xF894 0x0069      LDRB     R0,[R4, #+105]
   \   0000006A   0x2832             CMP      R0,#+50
   \   0000006C   0xD103             BNE.N    ??UART_Receive_IT_5
   1547                {
   1548                  huart->State = HAL_UART_STATE_BUSY_TX;
   \   0000006E   0x2012             MOVS     R0,#+18
   \   00000070   0xF884 0x0069      STRB     R0,[R4, #+105]
   \   00000074   0xE00E             B.N      ??UART_Receive_IT_6
   1549                }
   1550                else
   1551                {
   1552                  /* Disable the UART Parity Error Interrupt */
   1553                  __HAL_UART_DISABLE_IT(huart, UART_IT_PE);
   \                     ??UART_Receive_IT_5: (+1)
   \   00000076   0x6820             LDR      R0,[R4, #+0]
   \   00000078   0x6800             LDR      R0,[R0, #+0]
   \   0000007A   0xF430 0x7080      BICS     R0,R0,#0x100
   \   0000007E   0x6821             LDR      R1,[R4, #+0]
   \   00000080   0x6008             STR      R0,[R1, #+0]
   1554          
   1555                  /* Disable the UART Error Interrupt: (Frame error, noise error, overrun error) */
   1556                  __HAL_UART_DISABLE_IT(huart, UART_IT_ERR);
   \   00000082   0x6820             LDR      R0,[R4, #+0]
   \   00000084   0x6880             LDR      R0,[R0, #+8]
   \   00000086   0x0840             LSRS     R0,R0,#+1
   \   00000088   0x0040             LSLS     R0,R0,#+1
   \   0000008A   0x6821             LDR      R1,[R4, #+0]
   \   0000008C   0x6088             STR      R0,[R1, #+8]
   1557          
   1558                  huart->State = HAL_UART_STATE_READY;
   \   0000008E   0x2001             MOVS     R0,#+1
   \   00000090   0xF884 0x0069      STRB     R0,[R4, #+105]
   1559                }
   1560                
   1561                HAL_UART_RxCpltCallback(huart);
   \                     ??UART_Receive_IT_6: (+1)
   \   00000094   0x0020             MOVS     R0,R4
   \   00000096   0x.... 0x....      BL       HAL_UART_RxCpltCallback
   1562                
   1563                return HAL_OK;
   \   0000009A   0x2000             MOVS     R0,#+0
   \   0000009C   0xE002             B.N      ??UART_Receive_IT_7
   1564              }
   1565              
   1566              return HAL_OK;
   \                     ??UART_Receive_IT_4: (+1)
   \   0000009E   0x2000             MOVS     R0,#+0
   \   000000A0   0xE000             B.N      ??UART_Receive_IT_7
   1567            }
   1568            else
   1569            {
   1570              return HAL_BUSY; 
   \                     ??UART_Receive_IT_1: (+1)
   \   000000A2   0x2002             MOVS     R0,#+2
   \                     ??UART_Receive_IT_7: (+1)
   \   000000A4   0xBD70             POP      {R4-R6,PC}       ;; return
   1571            }
   1572          }
   1573          
   1574          /**
   1575            * @}
   1576            */
   1577          
   1578          /** @defgroup UART_Exported_Functions_Group3 Peripheral Control functions 
   1579            *  @brief   UART control functions 
   1580            *
   1581          @verbatim   
   1582           ===============================================================================
   1583                                ##### Peripheral Control functions #####
   1584           ===============================================================================  
   1585              [..]
   1586              This subsection provides a set of functions allowing to control the UART.
   1587               (+) HAL_UART_GetState() API is helpful to check in run-time the state of the UART peripheral. 
   1588               (+) HAL_MultiProcessor_EnableMuteMode() API enables mute mode
   1589               (+) HAL_MultiProcessor_DisableMuteMode() API disables mute mode
   1590               (+) HAL_MultiProcessor_EnterMuteMode() API enters mute mode
   1591               (+) HAL_MultiProcessor_EnableMuteMode() API enables mute mode
   1592               (+) UART_SetConfig() API configures the UART peripheral
   1593               (+) UART_AdvFeatureConfig() API optionally configures the UART advanced features        
   1594               (+) UART_CheckIdleState() API ensures that TEACK and/or REACK are set after initialization 
   1595               (+) HAL_HalfDuplex_EnableTransmitter() API disables receiver and enables transmitter  
   1596               (+) HAL_HalfDuplex_EnableReceiver() API disables transmitter and enables receiver  
   1597               (+) HAL_LIN_SendBreak() API transmits the break characters           
   1598          @endverbatim
   1599            * @{
   1600            */
   1601          
   1602          /**
   1603            * @brief Enable UART in mute mode (doesn't mean UART enters mute mode;
   1604            * to enter mute mode, HAL_MultiProcessor_EnterMuteMode() API must be called)
   1605            * @param huart: UART handle
   1606            * @retval HAL status
   1607            */

   \                                 In section .text, align 2, keep-with-next
   1608          HAL_StatusTypeDef HAL_MultiProcessor_EnableMuteMode(UART_HandleTypeDef *huart)
   1609          {  
   \                     HAL_MultiProcessor_EnableMuteMode: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1610            /* Process Locked */
   1611            __HAL_LOCK(huart);
   \   00000004   0xF894 0x0068      LDRB     R0,[R4, #+104]
   \   00000008   0x2801             CMP      R0,#+1
   \   0000000A   0xD101             BNE.N    ??HAL_MultiProcessor_EnableMuteMode_0
   \   0000000C   0x2002             MOVS     R0,#+2
   \   0000000E   0xE011             B.N      ??HAL_MultiProcessor_EnableMuteMode_1
   \                     ??HAL_MultiProcessor_EnableMuteMode_0: (+1)
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0xF884 0x0068      STRB     R0,[R4, #+104]
   1612            
   1613            huart->State = HAL_UART_STATE_BUSY;
   \   00000016   0x2002             MOVS     R0,#+2
   \   00000018   0xF884 0x0069      STRB     R0,[R4, #+105]
   1614            
   1615            /* Enable USART mute mode by setting the MME bit in the CR1 register */
   1616            huart->Instance->CR1 |= USART_CR1_MME;
   \   0000001C   0x6820             LDR      R0,[R4, #+0]
   \   0000001E   0x6800             LDR      R0,[R0, #+0]
   \   00000020   0xF450 0x5000      ORRS     R0,R0,#0x2000
   \   00000024   0x6821             LDR      R1,[R4, #+0]
   \   00000026   0x6008             STR      R0,[R1, #+0]
   1617            
   1618            huart->State = HAL_UART_STATE_READY;
   \   00000028   0x2001             MOVS     R0,#+1
   \   0000002A   0xF884 0x0069      STRB     R0,[R4, #+105]
   1619            
   1620            return (UART_CheckIdleState(huart));
   \   0000002E   0x0020             MOVS     R0,R4
   \   00000030   0x.... 0x....      BL       UART_CheckIdleState
   \                     ??HAL_MultiProcessor_EnableMuteMode_1: (+1)
   \   00000034   0xBD10             POP      {R4,PC}          ;; return
   1621          }
   1622          
   1623          /**
   1624            * @brief Disable UART mute mode (doesn't mean it actually wakes up the software,
   1625            * as it may not have been in mute mode at this very moment).
   1626            * @param huart: uart handle
   1627            * @retval HAL status
   1628            */

   \                                 In section .text, align 2, keep-with-next
   1629          HAL_StatusTypeDef HAL_MultiProcessor_DisableMuteMode(UART_HandleTypeDef *huart)
   1630          { 
   \                     HAL_MultiProcessor_DisableMuteMode: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1631            /* Process Locked */
   1632            __HAL_LOCK(huart);
   \   00000004   0xF894 0x0068      LDRB     R0,[R4, #+104]
   \   00000008   0x2801             CMP      R0,#+1
   \   0000000A   0xD101             BNE.N    ??HAL_MultiProcessor_DisableMuteMode_0
   \   0000000C   0x2002             MOVS     R0,#+2
   \   0000000E   0xE011             B.N      ??HAL_MultiProcessor_DisableMuteMode_1
   \                     ??HAL_MultiProcessor_DisableMuteMode_0: (+1)
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0xF884 0x0068      STRB     R0,[R4, #+104]
   1633            
   1634            huart->State = HAL_UART_STATE_BUSY;
   \   00000016   0x2002             MOVS     R0,#+2
   \   00000018   0xF884 0x0069      STRB     R0,[R4, #+105]
   1635            
   1636             /* Disable USART mute mode by clearing the MME bit in the CR1 register */
   1637            huart->Instance->CR1 &= ~(USART_CR1_MME);
   \   0000001C   0x6820             LDR      R0,[R4, #+0]
   \   0000001E   0x6800             LDR      R0,[R0, #+0]
   \   00000020   0xF430 0x5000      BICS     R0,R0,#0x2000
   \   00000024   0x6821             LDR      R1,[R4, #+0]
   \   00000026   0x6008             STR      R0,[R1, #+0]
   1638            
   1639            huart->State = HAL_UART_STATE_READY;
   \   00000028   0x2001             MOVS     R0,#+1
   \   0000002A   0xF884 0x0069      STRB     R0,[R4, #+105]
   1640            
   1641            return (UART_CheckIdleState(huart));
   \   0000002E   0x0020             MOVS     R0,R4
   \   00000030   0x.... 0x....      BL       UART_CheckIdleState
   \                     ??HAL_MultiProcessor_DisableMuteMode_1: (+1)
   \   00000034   0xBD10             POP      {R4,PC}          ;; return
   1642          }
   1643          
   1644          /**
   1645            * @brief Enter UART mute mode (means UART actually enters mute mode).
   1646            * To exit from mute mode, HAL_MultiProcessor_DisableMuteMode() API must be called. 
   1647            * @param huart: uart handle
   1648            * @retval HAL status
   1649            */

   \                                 In section .text, align 2, keep-with-next
   1650          void HAL_MultiProcessor_EnterMuteMode(UART_HandleTypeDef *huart)
   1651          {    
   1652            __HAL_UART_SEND_REQ(huart, UART_MUTE_MODE_REQUEST);
   \                     HAL_MultiProcessor_EnterMuteMode: (+1)
   \   00000000   0x6801             LDR      R1,[R0, #+0]
   \   00000002   0x6989             LDR      R1,[R1, #+24]
   \   00000004   0xF051 0x0104      ORRS     R1,R1,#0x4
   \   00000008   0x6802             LDR      R2,[R0, #+0]
   \   0000000A   0x6191             STR      R1,[R2, #+24]
   1653          }
   \   0000000C   0x4770             BX       LR               ;; return
   1654          
   1655          
   1656          
   1657          /**
   1658            * @brief return the UART state
   1659            * @param huart: uart handle
   1660            * @retval HAL state
   1661            */

   \                                 In section .text, align 2, keep-with-next
   1662          HAL_UART_StateTypeDef HAL_UART_GetState(UART_HandleTypeDef *huart)
   1663          {
   1664            return huart->State;
   \                     HAL_UART_GetState: (+1)
   \   00000000   0xF890 0x0069      LDRB     R0,[R0, #+105]
   \   00000004   0x4770             BX       LR               ;; return
   1665          }
   1666          
   1667          /**
   1668          * @brief  Return the UART error code
   1669          * @param  huart : pointer to a UART_HandleTypeDef structure that contains
   1670            *              the configuration information for the specified UART.
   1671          * @retval UART Error Code
   1672          */

   \                                 In section .text, align 2, keep-with-next
   1673          uint32_t HAL_UART_GetError(UART_HandleTypeDef *huart)
   1674          {
   1675            return huart->ErrorCode;
   \                     HAL_UART_GetError: (+1)
   \   00000000   0x6EC0             LDR      R0,[R0, #+108]
   \   00000002   0x4770             BX       LR               ;; return
   1676          }
   1677          
   1678          /**
   1679            * @brief Configure the UART peripheral 
   1680            * @param huart: uart handle
   1681            * @retval None
   1682            */

   \                                 In section .text, align 2, keep-with-next
   1683          HAL_StatusTypeDef UART_SetConfig(UART_HandleTypeDef *huart)
   1684          {
   \                     UART_SetConfig: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
   1685            uint32_t tmpreg                     = 0x00000000;
   \   00000006   0x2500             MOVS     R5,#+0
   1686            UART_ClockSourceTypeDef clocksource = UART_CLOCKSOURCE_UNDEFINED;
   \   00000008   0x2610             MOVS     R6,#+16
   1687            uint16_t brrtemp                    = 0x0000;
   \   0000000A   0xF05F 0x0900      MOVS     R9,#+0
   1688            uint16_t usartdiv                   = 0x0000;
   \   0000000E   0x2700             MOVS     R7,#+0
   1689            HAL_StatusTypeDef ret               = HAL_OK;  
   \   00000010   0xF05F 0x0800      MOVS     R8,#+0
   1690            
   1691            /* Check the parameters */ 
   1692            assert_param(IS_UART_BAUDRATE(huart->Init.BaudRate));  
   1693            assert_param(IS_UART_WORD_LENGTH(huart->Init.WordLength));
   1694            assert_param(IS_UART_STOPBITS(huart->Init.StopBits));
   1695            assert_param(IS_UART_PARITY(huart->Init.Parity));
   1696            assert_param(IS_UART_MODE(huart->Init.Mode));
   1697            assert_param(IS_UART_HARDWARE_FLOW_CONTROL(huart->Init.HwFlowCtl));
   1698            assert_param(IS_UART_ONE_BIT_SAMPLE(huart->Init.OneBitSampling)); 
   1699          
   1700          
   1701            /*-------------------------- USART CR1 Configuration -----------------------*/
   1702            /* Clear M, PCE, PS, TE, RE and OVER8 bits and configure       
   1703             *  the UART Word Length, Parity, Mode and oversampling: 
   1704             *  set the M bits according to huart->Init.WordLength value 
   1705             *  set PCE and PS bits according to huart->Init.Parity value
   1706             *  set TE and RE bits according to huart->Init.Mode value
   1707             *  set OVER8 bit according to huart->Init.OverSampling value */
   1708            tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
   \   00000014   0x68A0             LDR      R0,[R4, #+8]
   \   00000016   0x6921             LDR      R1,[R4, #+16]
   \   00000018   0x4308             ORRS     R0,R1,R0
   \   0000001A   0x6961             LDR      R1,[R4, #+20]
   \   0000001C   0x4308             ORRS     R0,R1,R0
   \   0000001E   0x69E1             LDR      R1,[R4, #+28]
   \   00000020   0x4308             ORRS     R0,R1,R0
   \   00000022   0x0005             MOVS     R5,R0
   1709            MODIFY_REG(huart->Instance->CR1, UART_CR1_FIELDS, tmpreg);
   \   00000024   0x6820             LDR      R0,[R4, #+0]
   \   00000026   0x6800             LDR      R0,[R0, #+0]
   \   00000028   0x.... 0x....      LDR.W    R1,??DataTable0  ;; 0xefff69f3
   \   0000002C   0x4008             ANDS     R0,R1,R0
   \   0000002E   0x4328             ORRS     R0,R5,R0
   \   00000030   0x6821             LDR      R1,[R4, #+0]
   \   00000032   0x6008             STR      R0,[R1, #+0]
   1710          
   1711            /*-------------------------- USART CR2 Configuration -----------------------*/
   1712            /* Configure the UART Stop Bits: Set STOP[13:12] bits according 
   1713             * to huart->Init.StopBits value */
   1714            MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
   \   00000034   0x6820             LDR      R0,[R4, #+0]
   \   00000036   0x6840             LDR      R0,[R0, #+4]
   \   00000038   0xF430 0x5040      BICS     R0,R0,#0x3000
   \   0000003C   0x68E1             LDR      R1,[R4, #+12]
   \   0000003E   0x4308             ORRS     R0,R1,R0
   \   00000040   0x6821             LDR      R1,[R4, #+0]
   \   00000042   0x6048             STR      R0,[R1, #+4]
   1715            
   1716            /*-------------------------- USART CR3 Configuration -----------------------*/
   1717            /* Configure 
   1718             * - UART HardWare Flow Control: set CTSE and RTSE bits according 
   1719             *   to huart->Init.HwFlowCtl value 
   1720             * - one-bit sampling method versus three samples' majority rule according
   1721             *   to huart->Init.OneBitSampling */
   1722            tmpreg = (uint32_t)huart->Init.HwFlowCtl | huart->Init.OneBitSampling ;
   \   00000044   0x69A0             LDR      R0,[R4, #+24]
   \   00000046   0x6A21             LDR      R1,[R4, #+32]
   \   00000048   0x4308             ORRS     R0,R1,R0
   \   0000004A   0x0005             MOVS     R5,R0
   1723            MODIFY_REG(huart->Instance->CR3, (USART_CR3_RTSE | USART_CR3_CTSE | USART_CR3_ONEBIT), tmpreg);
   \   0000004C   0x6820             LDR      R0,[R4, #+0]
   \   0000004E   0x6880             LDR      R0,[R0, #+8]
   \   00000050   0xF430 0x6030      BICS     R0,R0,#0xB00
   \   00000054   0x4328             ORRS     R0,R5,R0
   \   00000056   0x6821             LDR      R1,[R4, #+0]
   \   00000058   0x6088             STR      R0,[R1, #+8]
   1724            
   1725            /*-------------------------- USART BRR Configuration -----------------------*/
   1726            UART_GETCLOCKSOURCE(huart, clocksource);
   \   0000005A   0x6820             LDR      R0,[R4, #+0]
   \   0000005C   0x.... 0x....      LDR.W    R1,??DataTable0_1  ;; 0x40011000
   \   00000060   0x4288             CMP      R0,R1
   \   00000062   0xD119             BNE.N    ??UART_SetConfig_0
   \   00000064   0x.... 0x....      LDR.W    R0,??DataTable0_2  ;; 0x40023890
   \   00000068   0x6800             LDR      R0,[R0, #+0]
   \   0000006A   0xF010 0x0003      ANDS     R0,R0,#0x3
   \   0000006E   0x2800             CMP      R0,#+0
   \   00000070   0xD005             BEQ.N    ??UART_SetConfig_1
   \   00000072   0x2802             CMP      R0,#+2
   \   00000074   0xD006             BEQ.N    ??UART_SetConfig_2
   \   00000076   0xD308             BCC.N    ??UART_SetConfig_3
   \   00000078   0x2803             CMP      R0,#+3
   \   0000007A   0xD009             BEQ.N    ??UART_SetConfig_4
   \   0000007C   0xE00B             B.N      ??UART_SetConfig_5
   \                     ??UART_SetConfig_1: (+1)
   \   0000007E   0x2001             MOVS     R0,#+1
   \   00000080   0x0006             MOVS     R6,R0
   \   00000082   0xE0E6             B.N      ??UART_SetConfig_6
   \                     ??UART_SetConfig_2: (+1)
   \   00000084   0x2002             MOVS     R0,#+2
   \   00000086   0x0006             MOVS     R6,R0
   \   00000088   0xE0E3             B.N      ??UART_SetConfig_6
   \                     ??UART_SetConfig_3: (+1)
   \   0000008A   0x2004             MOVS     R0,#+4
   \   0000008C   0x0006             MOVS     R6,R0
   \   0000008E   0xE0E0             B.N      ??UART_SetConfig_6
   \                     ??UART_SetConfig_4: (+1)
   \   00000090   0x2008             MOVS     R0,#+8
   \   00000092   0x0006             MOVS     R6,R0
   \   00000094   0xE0DD             B.N      ??UART_SetConfig_6
   \                     ??UART_SetConfig_5: (+1)
   \   00000096   0xE0DC             B.N      ??UART_SetConfig_6
   \                     ??UART_SetConfig_0: (+1)
   \   00000098   0x6820             LDR      R0,[R4, #+0]
   \   0000009A   0x....             LDR.N    R1,??DataTable0_3  ;; 0x40004400
   \   0000009C   0x4288             CMP      R0,R1
   \   0000009E   0xD119             BNE.N    ??UART_SetConfig_7
   \   000000A0   0x....             LDR.N    R0,??DataTable0_2  ;; 0x40023890
   \   000000A2   0x6800             LDR      R0,[R0, #+0]
   \   000000A4   0xF010 0x000C      ANDS     R0,R0,#0xC
   \   000000A8   0x2800             CMP      R0,#+0
   \   000000AA   0xD006             BEQ.N    ??UART_SetConfig_8
   \   000000AC   0x2804             CMP      R0,#+4
   \   000000AE   0xD00A             BEQ.N    ??UART_SetConfig_9
   \   000000B0   0x2808             CMP      R0,#+8
   \   000000B2   0xD005             BEQ.N    ??UART_SetConfig_10
   \   000000B4   0x280C             CMP      R0,#+12
   \   000000B6   0xD009             BEQ.N    ??UART_SetConfig_11
   \   000000B8   0xE00B             B.N      ??UART_SetConfig_12
   \                     ??UART_SetConfig_8: (+1)
   \   000000BA   0x2000             MOVS     R0,#+0
   \   000000BC   0x0006             MOVS     R6,R0
   \   000000BE   0xE0C8             B.N      ??UART_SetConfig_6
   \                     ??UART_SetConfig_10: (+1)
   \   000000C0   0x2002             MOVS     R0,#+2
   \   000000C2   0x0006             MOVS     R6,R0
   \   000000C4   0xE0C5             B.N      ??UART_SetConfig_6
   \                     ??UART_SetConfig_9: (+1)
   \   000000C6   0x2004             MOVS     R0,#+4
   \   000000C8   0x0006             MOVS     R6,R0
   \   000000CA   0xE0C2             B.N      ??UART_SetConfig_6
   \                     ??UART_SetConfig_11: (+1)
   \   000000CC   0x2008             MOVS     R0,#+8
   \   000000CE   0x0006             MOVS     R6,R0
   \   000000D0   0xE0BF             B.N      ??UART_SetConfig_6
   \                     ??UART_SetConfig_12: (+1)
   \   000000D2   0xE0BE             B.N      ??UART_SetConfig_6
   \                     ??UART_SetConfig_7: (+1)
   \   000000D4   0x6820             LDR      R0,[R4, #+0]
   \   000000D6   0x....             LDR.N    R1,??DataTable0_4  ;; 0x40004800
   \   000000D8   0x4288             CMP      R0,R1
   \   000000DA   0xD119             BNE.N    ??UART_SetConfig_13
   \   000000DC   0x....             LDR.N    R0,??DataTable0_2  ;; 0x40023890
   \   000000DE   0x6800             LDR      R0,[R0, #+0]
   \   000000E0   0xF010 0x0030      ANDS     R0,R0,#0x30
   \   000000E4   0x2800             CMP      R0,#+0
   \   000000E6   0xD006             BEQ.N    ??UART_SetConfig_14
   \   000000E8   0x2810             CMP      R0,#+16
   \   000000EA   0xD00A             BEQ.N    ??UART_SetConfig_15
   \   000000EC   0x2820             CMP      R0,#+32
   \   000000EE   0xD005             BEQ.N    ??UART_SetConfig_16
   \   000000F0   0x2830             CMP      R0,#+48
   \   000000F2   0xD009             BEQ.N    ??UART_SetConfig_17
   \   000000F4   0xE00B             B.N      ??UART_SetConfig_18
   \                     ??UART_SetConfig_14: (+1)
   \   000000F6   0x2000             MOVS     R0,#+0
   \   000000F8   0x0006             MOVS     R6,R0
   \   000000FA   0xE0AA             B.N      ??UART_SetConfig_6
   \                     ??UART_SetConfig_16: (+1)
   \   000000FC   0x2002             MOVS     R0,#+2
   \   000000FE   0x0006             MOVS     R6,R0
   \   00000100   0xE0A7             B.N      ??UART_SetConfig_6
   \                     ??UART_SetConfig_15: (+1)
   \   00000102   0x2004             MOVS     R0,#+4
   \   00000104   0x0006             MOVS     R6,R0
   \   00000106   0xE0A4             B.N      ??UART_SetConfig_6
   \                     ??UART_SetConfig_17: (+1)
   \   00000108   0x2008             MOVS     R0,#+8
   \   0000010A   0x0006             MOVS     R6,R0
   \   0000010C   0xE0A1             B.N      ??UART_SetConfig_6
   \                     ??UART_SetConfig_18: (+1)
   \   0000010E   0xE0A0             B.N      ??UART_SetConfig_6
   \                     ??UART_SetConfig_13: (+1)
   \   00000110   0x6820             LDR      R0,[R4, #+0]
   \   00000112   0x....             LDR.N    R1,??DataTable0_5  ;; 0x40004c00
   \   00000114   0x4288             CMP      R0,R1
   \   00000116   0xD119             BNE.N    ??UART_SetConfig_19
   \   00000118   0x....             LDR.N    R0,??DataTable0_2  ;; 0x40023890
   \   0000011A   0x6800             LDR      R0,[R0, #+0]
   \   0000011C   0xF010 0x00C0      ANDS     R0,R0,#0xC0
   \   00000120   0x2800             CMP      R0,#+0
   \   00000122   0xD006             BEQ.N    ??UART_SetConfig_20
   \   00000124   0x2840             CMP      R0,#+64
   \   00000126   0xD00A             BEQ.N    ??UART_SetConfig_21
   \   00000128   0x2880             CMP      R0,#+128
   \   0000012A   0xD005             BEQ.N    ??UART_SetConfig_22
   \   0000012C   0x28C0             CMP      R0,#+192
   \   0000012E   0xD009             BEQ.N    ??UART_SetConfig_23
   \   00000130   0xE00B             B.N      ??UART_SetConfig_24
   \                     ??UART_SetConfig_20: (+1)
   \   00000132   0x2000             MOVS     R0,#+0
   \   00000134   0x0006             MOVS     R6,R0
   \   00000136   0xE08C             B.N      ??UART_SetConfig_6
   \                     ??UART_SetConfig_22: (+1)
   \   00000138   0x2002             MOVS     R0,#+2
   \   0000013A   0x0006             MOVS     R6,R0
   \   0000013C   0xE089             B.N      ??UART_SetConfig_6
   \                     ??UART_SetConfig_21: (+1)
   \   0000013E   0x2004             MOVS     R0,#+4
   \   00000140   0x0006             MOVS     R6,R0
   \   00000142   0xE086             B.N      ??UART_SetConfig_6
   \                     ??UART_SetConfig_23: (+1)
   \   00000144   0x2008             MOVS     R0,#+8
   \   00000146   0x0006             MOVS     R6,R0
   \   00000148   0xE083             B.N      ??UART_SetConfig_6
   \                     ??UART_SetConfig_24: (+1)
   \   0000014A   0xE082             B.N      ??UART_SetConfig_6
   \                     ??UART_SetConfig_19: (+1)
   \   0000014C   0x6820             LDR      R0,[R4, #+0]
   \   0000014E   0x....             LDR.N    R1,??DataTable0_6  ;; 0x40005000
   \   00000150   0x4288             CMP      R0,R1
   \   00000152   0xD11C             BNE.N    ??UART_SetConfig_25
   \   00000154   0x....             LDR.N    R0,??DataTable0_2  ;; 0x40023890
   \   00000156   0x6800             LDR      R0,[R0, #+0]
   \   00000158   0xF410 0x7040      ANDS     R0,R0,#0x300
   \   0000015C   0x2800             CMP      R0,#+0
   \   0000015E   0xD009             BEQ.N    ??UART_SetConfig_26
   \   00000160   0xF5B0 0x7F80      CMP      R0,#+256
   \   00000164   0xD00C             BEQ.N    ??UART_SetConfig_27
   \   00000166   0xF5B0 0x7F00      CMP      R0,#+512
   \   0000016A   0xD006             BEQ.N    ??UART_SetConfig_28
   \   0000016C   0xF5B0 0x7F40      CMP      R0,#+768
   \   00000170   0xD009             BEQ.N    ??UART_SetConfig_29
   \   00000172   0xE00B             B.N      ??UART_SetConfig_30
   \                     ??UART_SetConfig_26: (+1)
   \   00000174   0x2000             MOVS     R0,#+0
   \   00000176   0x0006             MOVS     R6,R0
   \   00000178   0xE06B             B.N      ??UART_SetConfig_6
   \                     ??UART_SetConfig_28: (+1)
   \   0000017A   0x2002             MOVS     R0,#+2
   \   0000017C   0x0006             MOVS     R6,R0
   \   0000017E   0xE068             B.N      ??UART_SetConfig_6
   \                     ??UART_SetConfig_27: (+1)
   \   00000180   0x2004             MOVS     R0,#+4
   \   00000182   0x0006             MOVS     R6,R0
   \   00000184   0xE065             B.N      ??UART_SetConfig_6
   \                     ??UART_SetConfig_29: (+1)
   \   00000186   0x2008             MOVS     R0,#+8
   \   00000188   0x0006             MOVS     R6,R0
   \   0000018A   0xE062             B.N      ??UART_SetConfig_6
   \                     ??UART_SetConfig_30: (+1)
   \   0000018C   0xE061             B.N      ??UART_SetConfig_6
   \                     ??UART_SetConfig_25: (+1)
   \   0000018E   0x6820             LDR      R0,[R4, #+0]
   \   00000190   0x....             LDR.N    R1,??DataTable0_7  ;; 0x40011400
   \   00000192   0x4288             CMP      R0,R1
   \   00000194   0xD11C             BNE.N    ??UART_SetConfig_31
   \   00000196   0x....             LDR.N    R0,??DataTable0_2  ;; 0x40023890
   \   00000198   0x6800             LDR      R0,[R0, #+0]
   \   0000019A   0xF410 0x6040      ANDS     R0,R0,#0xC00
   \   0000019E   0x2800             CMP      R0,#+0
   \   000001A0   0xD009             BEQ.N    ??UART_SetConfig_32
   \   000001A2   0xF5B0 0x6F80      CMP      R0,#+1024
   \   000001A6   0xD00C             BEQ.N    ??UART_SetConfig_33
   \   000001A8   0xF5B0 0x6F00      CMP      R0,#+2048
   \   000001AC   0xD006             BEQ.N    ??UART_SetConfig_34
   \   000001AE   0xF5B0 0x6F40      CMP      R0,#+3072
   \   000001B2   0xD009             BEQ.N    ??UART_SetConfig_35
   \   000001B4   0xE00B             B.N      ??UART_SetConfig_36
   \                     ??UART_SetConfig_32: (+1)
   \   000001B6   0x2001             MOVS     R0,#+1
   \   000001B8   0x0006             MOVS     R6,R0
   \   000001BA   0xE04A             B.N      ??UART_SetConfig_6
   \                     ??UART_SetConfig_34: (+1)
   \   000001BC   0x2002             MOVS     R0,#+2
   \   000001BE   0x0006             MOVS     R6,R0
   \   000001C0   0xE047             B.N      ??UART_SetConfig_6
   \                     ??UART_SetConfig_33: (+1)
   \   000001C2   0x2004             MOVS     R0,#+4
   \   000001C4   0x0006             MOVS     R6,R0
   \   000001C6   0xE044             B.N      ??UART_SetConfig_6
   \                     ??UART_SetConfig_35: (+1)
   \   000001C8   0x2008             MOVS     R0,#+8
   \   000001CA   0x0006             MOVS     R6,R0
   \   000001CC   0xE041             B.N      ??UART_SetConfig_6
   \                     ??UART_SetConfig_36: (+1)
   \   000001CE   0xE040             B.N      ??UART_SetConfig_6
   \                     ??UART_SetConfig_31: (+1)
   \   000001D0   0x6820             LDR      R0,[R4, #+0]
   \   000001D2   0x....             LDR.N    R1,??DataTable0_8  ;; 0x40007800
   \   000001D4   0x4288             CMP      R0,R1
   \   000001D6   0xD11C             BNE.N    ??UART_SetConfig_37
   \   000001D8   0x....             LDR.N    R0,??DataTable0_2  ;; 0x40023890
   \   000001DA   0x6800             LDR      R0,[R0, #+0]
   \   000001DC   0xF410 0x5040      ANDS     R0,R0,#0x3000
   \   000001E0   0x2800             CMP      R0,#+0
   \   000001E2   0xD009             BEQ.N    ??UART_SetConfig_38
   \   000001E4   0xF5B0 0x5F80      CMP      R0,#+4096
   \   000001E8   0xD00C             BEQ.N    ??UART_SetConfig_39
   \   000001EA   0xF5B0 0x5F00      CMP      R0,#+8192
   \   000001EE   0xD006             BEQ.N    ??UART_SetConfig_40
   \   000001F0   0xF5B0 0x5F40      CMP      R0,#+12288
   \   000001F4   0xD009             BEQ.N    ??UART_SetConfig_41
   \   000001F6   0xE00B             B.N      ??UART_SetConfig_42
   \                     ??UART_SetConfig_38: (+1)
   \   000001F8   0x2000             MOVS     R0,#+0
   \   000001FA   0x0006             MOVS     R6,R0
   \   000001FC   0xE029             B.N      ??UART_SetConfig_6
   \                     ??UART_SetConfig_40: (+1)
   \   000001FE   0x2002             MOVS     R0,#+2
   \   00000200   0x0006             MOVS     R6,R0
   \   00000202   0xE026             B.N      ??UART_SetConfig_6
   \                     ??UART_SetConfig_39: (+1)
   \   00000204   0x2004             MOVS     R0,#+4
   \   00000206   0x0006             MOVS     R6,R0
   \   00000208   0xE023             B.N      ??UART_SetConfig_6
   \                     ??UART_SetConfig_41: (+1)
   \   0000020A   0x2008             MOVS     R0,#+8
   \   0000020C   0x0006             MOVS     R6,R0
   \   0000020E   0xE020             B.N      ??UART_SetConfig_6
   \                     ??UART_SetConfig_42: (+1)
   \   00000210   0xE01F             B.N      ??UART_SetConfig_6
   \                     ??UART_SetConfig_37: (+1)
   \   00000212   0x6820             LDR      R0,[R4, #+0]
   \   00000214   0x....             LDR.N    R1,??DataTable0_9  ;; 0x40007c00
   \   00000216   0x4288             CMP      R0,R1
   \   00000218   0xD11B             BNE.N    ??UART_SetConfig_6
   \   0000021A   0x....             LDR.N    R0,??DataTable0_2  ;; 0x40023890
   \   0000021C   0x6800             LDR      R0,[R0, #+0]
   \   0000021E   0xF410 0x4040      ANDS     R0,R0,#0xC000
   \   00000222   0x2800             CMP      R0,#+0
   \   00000224   0xD009             BEQ.N    ??UART_SetConfig_43
   \   00000226   0xF5B0 0x4F80      CMP      R0,#+16384
   \   0000022A   0xD00C             BEQ.N    ??UART_SetConfig_44
   \   0000022C   0xF5B0 0x4F00      CMP      R0,#+32768
   \   00000230   0xD006             BEQ.N    ??UART_SetConfig_45
   \   00000232   0xF5B0 0x4F40      CMP      R0,#+49152
   \   00000236   0xD009             BEQ.N    ??UART_SetConfig_46
   \   00000238   0xE00B             B.N      ??UART_SetConfig_47
   \                     ??UART_SetConfig_43: (+1)
   \   0000023A   0x2000             MOVS     R0,#+0
   \   0000023C   0x0006             MOVS     R6,R0
   \   0000023E   0xE008             B.N      ??UART_SetConfig_6
   \                     ??UART_SetConfig_45: (+1)
   \   00000240   0x2002             MOVS     R0,#+2
   \   00000242   0x0006             MOVS     R6,R0
   \   00000244   0xE005             B.N      ??UART_SetConfig_6
   \                     ??UART_SetConfig_44: (+1)
   \   00000246   0x2004             MOVS     R0,#+4
   \   00000248   0x0006             MOVS     R6,R0
   \   0000024A   0xE002             B.N      ??UART_SetConfig_6
   \                     ??UART_SetConfig_46: (+1)
   \   0000024C   0x2008             MOVS     R0,#+8
   \   0000024E   0x0006             MOVS     R6,R0
   \   00000250   0xE7FF             B.N      ??UART_SetConfig_6
   1727          
   1728            /* Check UART Over Sampling to set Baud Rate Register */
   1729            if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
   \                     ??UART_SetConfig_47: (+1)
   \                     ??UART_SetConfig_6: (+1)
   \   00000252   0x69E0             LDR      R0,[R4, #+28]
   \   00000254   0xF5B0 0x4F00      CMP      R0,#+32768
   \   00000258   0xD141             BNE.N    ??UART_SetConfig_48
   1730            { 
   1731              switch (clocksource)
   \   0000025A   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000025C   0x0030             MOVS     R0,R6
   \   0000025E   0x2800             CMP      R0,#+0
   \   00000260   0xD008             BEQ.N    ??UART_SetConfig_49
   \   00000262   0x2801             CMP      R0,#+1
   \   00000264   0xD00E             BEQ.N    ??UART_SetConfig_50
   \   00000266   0x2802             CMP      R0,#+2
   \   00000268   0xD014             BEQ.N    ??UART_SetConfig_51
   \   0000026A   0x2804             CMP      R0,#+4
   \   0000026C   0xD018             BEQ.N    ??UART_SetConfig_52
   \   0000026E   0x2808             CMP      R0,#+8
   \   00000270   0xD01E             BEQ.N    ??UART_SetConfig_53
   \   00000272   0xE024             B.N      ??UART_SetConfig_54
   1732              {
   1733              case UART_CLOCKSOURCE_PCLK1:
   1734                  usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HAL_RCC_GetPCLK1Freq(), huart->Init.BaudRate));
   \                     ??UART_SetConfig_49: (+1)
   \   00000274   0x.... 0x....      BL       HAL_RCC_GetPCLK1Freq
   \   00000278   0x0040             LSLS     R0,R0,#+1
   \   0000027A   0x6861             LDR      R1,[R4, #+4]
   \   0000027C   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   00000280   0x0007             MOVS     R7,R0
   1735                break;
   \   00000282   0xE01E             B.N      ??UART_SetConfig_55
   1736              case UART_CLOCKSOURCE_PCLK2:
   1737                  usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HAL_RCC_GetPCLK2Freq(), huart->Init.BaudRate));
   \                     ??UART_SetConfig_50: (+1)
   \   00000284   0x.... 0x....      BL       HAL_RCC_GetPCLK2Freq
   \   00000288   0x0040             LSLS     R0,R0,#+1
   \   0000028A   0x6861             LDR      R1,[R4, #+4]
   \   0000028C   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   00000290   0x0007             MOVS     R7,R0
   1738                break;
   \   00000292   0xE016             B.N      ??UART_SetConfig_55
   1739              case UART_CLOCKSOURCE_HSI:
   1740                  usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HSI_VALUE, huart->Init.BaudRate)); 
   \                     ??UART_SetConfig_51: (+1)
   \   00000294   0x....             LDR.N    R0,??DataTable0_10  ;; 0x1e84800
   \   00000296   0x6861             LDR      R1,[R4, #+4]
   \   00000298   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   0000029C   0x0007             MOVS     R7,R0
   1741                break;
   \   0000029E   0xE010             B.N      ??UART_SetConfig_55
   1742              case UART_CLOCKSOURCE_SYSCLK:
   1743                  usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HAL_RCC_GetSysClockFreq(), huart->Init.BaudRate));
   \                     ??UART_SetConfig_52: (+1)
   \   000002A0   0x.... 0x....      BL       HAL_RCC_GetSysClockFreq
   \   000002A4   0x0040             LSLS     R0,R0,#+1
   \   000002A6   0x6861             LDR      R1,[R4, #+4]
   \   000002A8   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   000002AC   0x0007             MOVS     R7,R0
   1744                break;
   \   000002AE   0xE008             B.N      ??UART_SetConfig_55
   1745              case UART_CLOCKSOURCE_LSE:
   1746                  usartdiv = (uint16_t)(UART_DIV_SAMPLING8(LSE_VALUE, huart->Init.BaudRate)); 
   \                     ??UART_SetConfig_53: (+1)
   \   000002B0   0xF45F 0x3080      MOVS     R0,#+65536
   \   000002B4   0x6861             LDR      R1,[R4, #+4]
   \   000002B6   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   000002BA   0x0007             MOVS     R7,R0
   1747                break;
   \   000002BC   0xE001             B.N      ??UART_SetConfig_55
   1748                case UART_CLOCKSOURCE_UNDEFINED:                
   1749              default:
   1750                  ret = HAL_ERROR; 
   \                     ??UART_SetConfig_54: (+1)
   \   000002BE   0x2001             MOVS     R0,#+1
   \   000002C0   0x4680             MOV      R8,R0
   1751                break;
   1752              }
   1753              
   1754              brrtemp = usartdiv & 0xFFF0;
   \                     ??UART_SetConfig_55: (+1)
   \   000002C2   0xF64F 0x70F0      MOVW     R0,#+65520
   \   000002C6   0x4038             ANDS     R0,R0,R7
   \   000002C8   0x4681             MOV      R9,R0
   1755              brrtemp |= (uint16_t)((usartdiv & (uint16_t)0x000F) >> 1U);
   \   000002CA   0xF3C7 0x0042      UBFX     R0,R7,#+1,#+3
   \   000002CE   0xEA50 0x0909      ORRS     R9,R0,R9
   1756              huart->Instance->BRR = brrtemp;
   \   000002D2   0xFA1F 0xF989      UXTH     R9,R9            ;; ZeroExt  R9,R9,#+16,#+16
   \   000002D6   0x6820             LDR      R0,[R4, #+0]
   \   000002D8   0xF8C0 0x900C      STR      R9,[R0, #+12]
   \   000002DC   0xE03A             B.N      ??UART_SetConfig_56
   1757            }
   1758            else
   1759            {
   1760              switch (clocksource)
   \                     ??UART_SetConfig_48: (+1)
   \   000002DE   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000002E0   0x0030             MOVS     R0,R6
   \   000002E2   0x2800             CMP      R0,#+0
   \   000002E4   0xD008             BEQ.N    ??UART_SetConfig_57
   \   000002E6   0x2801             CMP      R0,#+1
   \   000002E8   0xD00F             BEQ.N    ??UART_SetConfig_58
   \   000002EA   0x2802             CMP      R0,#+2
   \   000002EC   0xD016             BEQ.N    ??UART_SetConfig_59
   \   000002EE   0x2804             CMP      R0,#+4
   \   000002F0   0xD01C             BEQ.N    ??UART_SetConfig_60
   \   000002F2   0x2808             CMP      R0,#+8
   \   000002F4   0xD023             BEQ.N    ??UART_SetConfig_61
   \   000002F6   0xE02B             B.N      ??UART_SetConfig_62
   1761              {
   1762              case UART_CLOCKSOURCE_PCLK1: 
   1763                  huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(HAL_RCC_GetPCLK1Freq(), huart->Init.BaudRate));
   \                     ??UART_SetConfig_57: (+1)
   \   000002F8   0x.... 0x....      BL       HAL_RCC_GetPCLK1Freq
   \   000002FC   0x6861             LDR      R1,[R4, #+4]
   \   000002FE   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   00000302   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000304   0x6821             LDR      R1,[R4, #+0]
   \   00000306   0x60C8             STR      R0,[R1, #+12]
   1764                break;
   \   00000308   0xE024             B.N      ??UART_SetConfig_56
   1765              case UART_CLOCKSOURCE_PCLK2: 
   1766                  huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(HAL_RCC_GetPCLK2Freq(), huart->Init.BaudRate));
   \                     ??UART_SetConfig_58: (+1)
   \   0000030A   0x.... 0x....      BL       HAL_RCC_GetPCLK2Freq
   \   0000030E   0x6861             LDR      R1,[R4, #+4]
   \   00000310   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   00000314   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000316   0x6821             LDR      R1,[R4, #+0]
   \   00000318   0x60C8             STR      R0,[R1, #+12]
   1767                break;
   \   0000031A   0xE01B             B.N      ??UART_SetConfig_56
   1768              case UART_CLOCKSOURCE_HSI: 
   1769                  huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(HSI_VALUE, huart->Init.BaudRate)); 
   \                     ??UART_SetConfig_59: (+1)
   \   0000031C   0x....             LDR.N    R0,??DataTable0_11  ;; 0xf42400
   \   0000031E   0x6861             LDR      R1,[R4, #+4]
   \   00000320   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   00000324   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000326   0x6821             LDR      R1,[R4, #+0]
   \   00000328   0x60C8             STR      R0,[R1, #+12]
   1770                break; 
   \   0000032A   0xE013             B.N      ??UART_SetConfig_56
   1771              case UART_CLOCKSOURCE_SYSCLK:  
   1772                  huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(HAL_RCC_GetSysClockFreq(), huart->Init.BaudRate));
   \                     ??UART_SetConfig_60: (+1)
   \   0000032C   0x.... 0x....      BL       HAL_RCC_GetSysClockFreq
   \   00000330   0x6861             LDR      R1,[R4, #+4]
   \   00000332   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   00000336   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000338   0x6821             LDR      R1,[R4, #+0]
   \   0000033A   0x60C8             STR      R0,[R1, #+12]
   1773                break;  
   \   0000033C   0xE00A             B.N      ??UART_SetConfig_56
   1774              case UART_CLOCKSOURCE_LSE:
   1775                  huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(LSE_VALUE, huart->Init.BaudRate)); 
   \                     ??UART_SetConfig_61: (+1)
   \   0000033E   0xF44F 0x4000      MOV      R0,#+32768
   \   00000342   0x6861             LDR      R1,[R4, #+4]
   \   00000344   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   00000348   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000034A   0x6821             LDR      R1,[R4, #+0]
   \   0000034C   0x60C8             STR      R0,[R1, #+12]
   1776                break;
   \   0000034E   0xE001             B.N      ??UART_SetConfig_56
   1777                case UART_CLOCKSOURCE_UNDEFINED:                
   1778              default:
   1779                  ret = HAL_ERROR; 
   \                     ??UART_SetConfig_62: (+1)
   \   00000350   0x2001             MOVS     R0,#+1
   \   00000352   0x4680             MOV      R8,R0
   1780                break;
   1781              }
   1782            }
   1783          
   1784            return ret;   
   \                     ??UART_SetConfig_56: (+1)
   \   00000354   0x4640             MOV      R0,R8
   \   00000356   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000358   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
   1785          
   1786          }
   1787          
   1788          
   1789          /**
   1790            * @brief Configure the UART peripheral advanced features 
   1791            * @param huart: uart handle  
   1792            * @retval None
   1793            */

   \                                 In section .text, align 2, keep-with-next
   1794          void UART_AdvFeatureConfig(UART_HandleTypeDef *huart)
   1795          {
   1796            /* Check whether the set of advanced features to configure is properly set */ 
   1797            assert_param(IS_UART_ADVFEATURE_INIT(huart->AdvancedInit.AdvFeatureInit));
   1798            
   1799            /* if required, configure TX pin active level inversion */
   1800            if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_TXINVERT_INIT))
   \                     UART_AdvFeatureConfig: (+1)
   \   00000000   0xF890 0x1024      LDRB     R1,[R0, #+36]
   \   00000004   0x07C9             LSLS     R1,R1,#+31
   \   00000006   0xD507             BPL.N    ??UART_AdvFeatureConfig_0
   1801            {
   1802              assert_param(IS_UART_ADVFEATURE_TXINV(huart->AdvancedInit.TxPinLevelInvert));
   1803              MODIFY_REG(huart->Instance->CR2, USART_CR2_TXINV, huart->AdvancedInit.TxPinLevelInvert);
   \   00000008   0x6801             LDR      R1,[R0, #+0]
   \   0000000A   0x6849             LDR      R1,[R1, #+4]
   \   0000000C   0xF431 0x3100      BICS     R1,R1,#0x20000
   \   00000010   0x6A82             LDR      R2,[R0, #+40]
   \   00000012   0x4311             ORRS     R1,R2,R1
   \   00000014   0x6802             LDR      R2,[R0, #+0]
   \   00000016   0x6051             STR      R1,[R2, #+4]
   1804            }
   1805            
   1806            /* if required, configure RX pin active level inversion */
   1807            if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXINVERT_INIT))
   \                     ??UART_AdvFeatureConfig_0: (+1)
   \   00000018   0xF890 0x1024      LDRB     R1,[R0, #+36]
   \   0000001C   0x0789             LSLS     R1,R1,#+30
   \   0000001E   0xD507             BPL.N    ??UART_AdvFeatureConfig_1
   1808            {
   1809              assert_param(IS_UART_ADVFEATURE_RXINV(huart->AdvancedInit.RxPinLevelInvert));
   1810              MODIFY_REG(huart->Instance->CR2, USART_CR2_RXINV, huart->AdvancedInit.RxPinLevelInvert);
   \   00000020   0x6801             LDR      R1,[R0, #+0]
   \   00000022   0x6849             LDR      R1,[R1, #+4]
   \   00000024   0xF431 0x3180      BICS     R1,R1,#0x10000
   \   00000028   0x6AC2             LDR      R2,[R0, #+44]
   \   0000002A   0x4311             ORRS     R1,R2,R1
   \   0000002C   0x6802             LDR      R2,[R0, #+0]
   \   0000002E   0x6051             STR      R1,[R2, #+4]
   1811            }
   1812            
   1813            /* if required, configure data inversion */
   1814            if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DATAINVERT_INIT))
   \                     ??UART_AdvFeatureConfig_1: (+1)
   \   00000030   0xF890 0x1024      LDRB     R1,[R0, #+36]
   \   00000034   0x0749             LSLS     R1,R1,#+29
   \   00000036   0xD507             BPL.N    ??UART_AdvFeatureConfig_2
   1815            {
   1816              assert_param(IS_UART_ADVFEATURE_DATAINV(huart->AdvancedInit.DataInvert));
   1817              MODIFY_REG(huart->Instance->CR2, USART_CR2_DATAINV, huart->AdvancedInit.DataInvert);
   \   00000038   0x6801             LDR      R1,[R0, #+0]
   \   0000003A   0x6849             LDR      R1,[R1, #+4]
   \   0000003C   0xF431 0x2180      BICS     R1,R1,#0x40000
   \   00000040   0x6B02             LDR      R2,[R0, #+48]
   \   00000042   0x4311             ORRS     R1,R2,R1
   \   00000044   0x6802             LDR      R2,[R0, #+0]
   \   00000046   0x6051             STR      R1,[R2, #+4]
   1818            }
   1819            
   1820            /* if required, configure RX/TX pins swap */
   1821            if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_SWAP_INIT))
   \                     ??UART_AdvFeatureConfig_2: (+1)
   \   00000048   0xF890 0x1024      LDRB     R1,[R0, #+36]
   \   0000004C   0x0709             LSLS     R1,R1,#+28
   \   0000004E   0xD507             BPL.N    ??UART_AdvFeatureConfig_3
   1822            {
   1823              assert_param(IS_UART_ADVFEATURE_SWAP(huart->AdvancedInit.Swap));
   1824              MODIFY_REG(huart->Instance->CR2, USART_CR2_SWAP, huart->AdvancedInit.Swap);
   \   00000050   0x6801             LDR      R1,[R0, #+0]
   \   00000052   0x6849             LDR      R1,[R1, #+4]
   \   00000054   0xF431 0x4100      BICS     R1,R1,#0x8000
   \   00000058   0x6B42             LDR      R2,[R0, #+52]
   \   0000005A   0x4311             ORRS     R1,R2,R1
   \   0000005C   0x6802             LDR      R2,[R0, #+0]
   \   0000005E   0x6051             STR      R1,[R2, #+4]
   1825            }
   1826            
   1827            /* if required, configure RX overrun detection disabling */
   1828            if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXOVERRUNDISABLE_INIT))
   \                     ??UART_AdvFeatureConfig_3: (+1)
   \   00000060   0xF890 0x1024      LDRB     R1,[R0, #+36]
   \   00000064   0x06C9             LSLS     R1,R1,#+27
   \   00000066   0xD507             BPL.N    ??UART_AdvFeatureConfig_4
   1829            {
   1830              assert_param(IS_UART_OVERRUN(huart->AdvancedInit.OverrunDisable));  
   1831              MODIFY_REG(huart->Instance->CR3, USART_CR3_OVRDIS, huart->AdvancedInit.OverrunDisable);
   \   00000068   0x6801             LDR      R1,[R0, #+0]
   \   0000006A   0x6889             LDR      R1,[R1, #+8]
   \   0000006C   0xF431 0x5180      BICS     R1,R1,#0x1000
   \   00000070   0x6B82             LDR      R2,[R0, #+56]
   \   00000072   0x4311             ORRS     R1,R2,R1
   \   00000074   0x6802             LDR      R2,[R0, #+0]
   \   00000076   0x6091             STR      R1,[R2, #+8]
   1832            }
   1833            
   1834            /* if required, configure DMA disabling on reception error */
   1835            if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DMADISABLEONERROR_INIT))
   \                     ??UART_AdvFeatureConfig_4: (+1)
   \   00000078   0xF890 0x1024      LDRB     R1,[R0, #+36]
   \   0000007C   0x0689             LSLS     R1,R1,#+26
   \   0000007E   0xD507             BPL.N    ??UART_AdvFeatureConfig_5
   1836            {
   1837              assert_param(IS_UART_ADVFEATURE_DMAONRXERROR(huart->AdvancedInit.DMADisableonRxError));   
   1838              MODIFY_REG(huart->Instance->CR3, USART_CR3_DDRE, huart->AdvancedInit.DMADisableonRxError);
   \   00000080   0x6801             LDR      R1,[R0, #+0]
   \   00000082   0x6889             LDR      R1,[R1, #+8]
   \   00000084   0xF431 0x5100      BICS     R1,R1,#0x2000
   \   00000088   0x6BC2             LDR      R2,[R0, #+60]
   \   0000008A   0x4311             ORRS     R1,R2,R1
   \   0000008C   0x6802             LDR      R2,[R0, #+0]
   \   0000008E   0x6091             STR      R1,[R2, #+8]
   1839            }
   1840            
   1841            /* if required, configure auto Baud rate detection scheme */              
   1842            if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_AUTOBAUDRATE_INIT))
   \                     ??UART_AdvFeatureConfig_5: (+1)
   \   00000090   0xF890 0x1024      LDRB     R1,[R0, #+36]
   \   00000094   0x0649             LSLS     R1,R1,#+25
   \   00000096   0xD513             BPL.N    ??UART_AdvFeatureConfig_6
   1843            {
   1844              assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATE(huart->AdvancedInit.AutoBaudRateEnable));
   1845              MODIFY_REG(huart->Instance->CR2, USART_CR2_ABREN, huart->AdvancedInit.AutoBaudRateEnable);
   \   00000098   0x6801             LDR      R1,[R0, #+0]
   \   0000009A   0x6849             LDR      R1,[R1, #+4]
   \   0000009C   0xF431 0x1180      BICS     R1,R1,#0x100000
   \   000000A0   0x6C02             LDR      R2,[R0, #+64]
   \   000000A2   0x4311             ORRS     R1,R2,R1
   \   000000A4   0x6802             LDR      R2,[R0, #+0]
   \   000000A6   0x6051             STR      R1,[R2, #+4]
   1846              /* set auto Baudrate detection parameters if detection is enabled */
   1847              if(huart->AdvancedInit.AutoBaudRateEnable == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE)
   \   000000A8   0x6C01             LDR      R1,[R0, #+64]
   \   000000AA   0xF5B1 0x1F80      CMP      R1,#+1048576
   \   000000AE   0xD107             BNE.N    ??UART_AdvFeatureConfig_6
   1848              {
   1849                assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATEMODE(huart->AdvancedInit.AutoBaudRateMode));
   1850                MODIFY_REG(huart->Instance->CR2, USART_CR2_ABRMODE, huart->AdvancedInit.AutoBaudRateMode);
   \   000000B0   0x6801             LDR      R1,[R0, #+0]
   \   000000B2   0x6849             LDR      R1,[R1, #+4]
   \   000000B4   0xF431 0x01C0      BICS     R1,R1,#0x600000
   \   000000B8   0x6C42             LDR      R2,[R0, #+68]
   \   000000BA   0x4311             ORRS     R1,R2,R1
   \   000000BC   0x6802             LDR      R2,[R0, #+0]
   \   000000BE   0x6051             STR      R1,[R2, #+4]
   1851              }
   1852            }
   1853            
   1854            /* if required, configure MSB first on communication line */  
   1855            if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_MSBFIRST_INIT))
   \                     ??UART_AdvFeatureConfig_6: (+1)
   \   000000C0   0xF890 0x1024      LDRB     R1,[R0, #+36]
   \   000000C4   0x0609             LSLS     R1,R1,#+24
   \   000000C6   0xD507             BPL.N    ??UART_AdvFeatureConfig_7
   1856            {
   1857              assert_param(IS_UART_ADVFEATURE_MSBFIRST(huart->AdvancedInit.MSBFirst));   
   1858              MODIFY_REG(huart->Instance->CR2, USART_CR2_MSBFIRST, huart->AdvancedInit.MSBFirst);
   \   000000C8   0x6801             LDR      R1,[R0, #+0]
   \   000000CA   0x6849             LDR      R1,[R1, #+4]
   \   000000CC   0xF431 0x2100      BICS     R1,R1,#0x80000
   \   000000D0   0x6C82             LDR      R2,[R0, #+72]
   \   000000D2   0x4311             ORRS     R1,R2,R1
   \   000000D4   0x6802             LDR      R2,[R0, #+0]
   \   000000D6   0x6051             STR      R1,[R2, #+4]
   1859            }
   1860          }
   \                     ??UART_AdvFeatureConfig_7: (+1)
   \   000000D8   0x4770             BX       LR               ;; return
   1861          
   1862          
   1863          
   1864          /**
   1865            * @brief Check the UART Idle State
   1866            * @param huart: uart handle
   1867            * @retval HAL status
   1868            */

   \                                 In section .text, align 2, keep-with-next
   1869          HAL_StatusTypeDef UART_CheckIdleState(UART_HandleTypeDef *huart)
   1870          {
   \                     UART_CheckIdleState: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1871            /* Initialize the UART ErrorCode */
   1872            huart->ErrorCode = HAL_UART_ERROR_NONE;
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x66E0             STR      R0,[R4, #+108]
   1873            
   1874            /* Check if the Transmitter is enabled */
   1875            if((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
   \   00000008   0x6820             LDR      R0,[R4, #+0]
   \   0000000A   0x6800             LDR      R0,[R0, #+0]
   \   0000000C   0x0700             LSLS     R0,R0,#+28
   \   0000000E   0xD50B             BPL.N    ??UART_CheckIdleState_0
   1876            {
   1877              /* Wait until TEACK flag is set */
   1878              if(UART_WaitOnFlagUntilTimeout(huart, USART_ISR_TEACK, RESET, HAL_UART_TIMEOUT_VALUE) != HAL_OK)  
   \   00000010   0xF07F 0x437E      MVNS     R3,#-33554432
   \   00000014   0x2200             MOVS     R2,#+0
   \   00000016   0xF45F 0x1100      MOVS     R1,#+2097152
   \   0000001A   0x0020             MOVS     R0,R4
   \   0000001C   0x.... 0x....      BL       UART_WaitOnFlagUntilTimeout
   \   00000020   0x2800             CMP      R0,#+0
   \   00000022   0xD001             BEQ.N    ??UART_CheckIdleState_0
   1879              {
   1880                /* Timeout Occurred */
   1881                return HAL_TIMEOUT;
   \   00000024   0x2003             MOVS     R0,#+3
   \   00000026   0xE016             B.N      ??UART_CheckIdleState_1
   1882              }
   1883            }
   1884            /* Check if the Receiver is enabled */
   1885            if((huart->Instance->CR1 & USART_CR1_RE) == USART_CR1_RE)
   \                     ??UART_CheckIdleState_0: (+1)
   \   00000028   0x6820             LDR      R0,[R4, #+0]
   \   0000002A   0x6800             LDR      R0,[R0, #+0]
   \   0000002C   0x0740             LSLS     R0,R0,#+29
   \   0000002E   0xD50B             BPL.N    ??UART_CheckIdleState_2
   1886            {
   1887              /* Wait until REACK flag is set */
   1888              if(UART_WaitOnFlagUntilTimeout(huart, USART_ISR_REACK, RESET,  HAL_UART_TIMEOUT_VALUE) != HAL_OK)  
   \   00000030   0xF07F 0x437E      MVNS     R3,#-33554432
   \   00000034   0x2200             MOVS     R2,#+0
   \   00000036   0xF45F 0x0180      MOVS     R1,#+4194304
   \   0000003A   0x0020             MOVS     R0,R4
   \   0000003C   0x.... 0x....      BL       UART_WaitOnFlagUntilTimeout
   \   00000040   0x2800             CMP      R0,#+0
   \   00000042   0xD001             BEQ.N    ??UART_CheckIdleState_2
   1889              { 
   1890                /* Timeout Occurred */
   1891                return HAL_TIMEOUT;
   \   00000044   0x2003             MOVS     R0,#+3
   \   00000046   0xE006             B.N      ??UART_CheckIdleState_1
   1892              }
   1893            }
   1894            
   1895            /* Initialize the UART State */
   1896            huart->State= HAL_UART_STATE_READY;
   \                     ??UART_CheckIdleState_2: (+1)
   \   00000048   0x2001             MOVS     R0,#+1
   \   0000004A   0xF884 0x0069      STRB     R0,[R4, #+105]
   1897              
   1898            /* Process Unlocked */
   1899            __HAL_UNLOCK(huart);
   \   0000004E   0x2000             MOVS     R0,#+0
   \   00000050   0xF884 0x0068      STRB     R0,[R4, #+104]
   1900            
   1901            return HAL_OK;
   \   00000054   0x2000             MOVS     R0,#+0
   \                     ??UART_CheckIdleState_1: (+1)
   \   00000056   0xBD10             POP      {R4,PC}          ;; return
   1902          }
   1903          
   1904          /**
   1905            * @brief  Enables the UART transmitter and disables the UART receiver.
   1906            * @param  huart: UART handle
   1907            * @retval HAL status
   1908            * @retval None
   1909            */

   \                                 In section .text, align 2, keep-with-next
   1910          HAL_StatusTypeDef HAL_HalfDuplex_EnableTransmitter(UART_HandleTypeDef *huart)
   1911          {
   \                     HAL_HalfDuplex_EnableTransmitter: (+1)
   \   00000000   0x0001             MOVS     R1,R0
   1912            /* Process Locked */
   1913            __HAL_LOCK(huart);
   \   00000002   0xF891 0x0068      LDRB     R0,[R1, #+104]
   \   00000006   0x2801             CMP      R0,#+1
   \   00000008   0xD101             BNE.N    ??HAL_HalfDuplex_EnableTransmitter_0
   \   0000000A   0x2002             MOVS     R0,#+2
   \   0000000C   0xE018             B.N      ??HAL_HalfDuplex_EnableTransmitter_1
   \                     ??HAL_HalfDuplex_EnableTransmitter_0: (+1)
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0xF881 0x0068      STRB     R0,[R1, #+104]
   1914            huart->State = HAL_UART_STATE_BUSY;
   \   00000014   0x2002             MOVS     R0,#+2
   \   00000016   0xF881 0x0069      STRB     R0,[R1, #+105]
   1915            
   1916            /* Clear TE and RE bits */
   1917            CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TE | USART_CR1_RE));
   \   0000001A   0x6808             LDR      R0,[R1, #+0]
   \   0000001C   0x6800             LDR      R0,[R0, #+0]
   \   0000001E   0xF030 0x000C      BICS     R0,R0,#0xC
   \   00000022   0x680A             LDR      R2,[R1, #+0]
   \   00000024   0x6010             STR      R0,[R2, #+0]
   1918            /* Enable the USART's transmit interface by setting the TE bit in the USART CR1 register */
   1919            SET_BIT(huart->Instance->CR1, USART_CR1_TE);
   \   00000026   0x6808             LDR      R0,[R1, #+0]
   \   00000028   0x6800             LDR      R0,[R0, #+0]
   \   0000002A   0xF050 0x0008      ORRS     R0,R0,#0x8
   \   0000002E   0x680A             LDR      R2,[R1, #+0]
   \   00000030   0x6010             STR      R0,[R2, #+0]
   1920           
   1921            huart->State= HAL_UART_STATE_READY;
   \   00000032   0x2001             MOVS     R0,#+1
   \   00000034   0xF881 0x0069      STRB     R0,[R1, #+105]
   1922            /* Process Unlocked */
   1923            __HAL_UNLOCK(huart);
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0xF881 0x0068      STRB     R0,[R1, #+104]
   1924            
   1925            return HAL_OK;
   \   0000003E   0x2000             MOVS     R0,#+0
   \                     ??HAL_HalfDuplex_EnableTransmitter_1: (+1)
   \   00000040   0x4770             BX       LR               ;; return
   1926          }
   1927          
   1928          /**
   1929            * @brief  Enables the UART receiver and disables the UART transmitter.
   1930            * @param  huart: UART handle
   1931            * @retval HAL status
   1932            */

   \                                 In section .text, align 2, keep-with-next
   1933          HAL_StatusTypeDef HAL_HalfDuplex_EnableReceiver(UART_HandleTypeDef *huart)
   1934          {
   \                     HAL_HalfDuplex_EnableReceiver: (+1)
   \   00000000   0x0001             MOVS     R1,R0
   1935            /* Process Locked */
   1936            __HAL_LOCK(huart);
   \   00000002   0xF891 0x0068      LDRB     R0,[R1, #+104]
   \   00000006   0x2801             CMP      R0,#+1
   \   00000008   0xD101             BNE.N    ??HAL_HalfDuplex_EnableReceiver_0
   \   0000000A   0x2002             MOVS     R0,#+2
   \   0000000C   0xE018             B.N      ??HAL_HalfDuplex_EnableReceiver_1
   \                     ??HAL_HalfDuplex_EnableReceiver_0: (+1)
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0xF881 0x0068      STRB     R0,[R1, #+104]
   1937            huart->State = HAL_UART_STATE_BUSY;
   \   00000014   0x2002             MOVS     R0,#+2
   \   00000016   0xF881 0x0069      STRB     R0,[R1, #+105]
   1938          
   1939            /* Clear TE and RE bits */
   1940            CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TE | USART_CR1_RE));
   \   0000001A   0x6808             LDR      R0,[R1, #+0]
   \   0000001C   0x6800             LDR      R0,[R0, #+0]
   \   0000001E   0xF030 0x000C      BICS     R0,R0,#0xC
   \   00000022   0x680A             LDR      R2,[R1, #+0]
   \   00000024   0x6010             STR      R0,[R2, #+0]
   1941            /* Enable the USART's receive interface by setting the RE bit in the USART CR1 register */
   1942            SET_BIT(huart->Instance->CR1, USART_CR1_RE);
   \   00000026   0x6808             LDR      R0,[R1, #+0]
   \   00000028   0x6800             LDR      R0,[R0, #+0]
   \   0000002A   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   0000002E   0x680A             LDR      R2,[R1, #+0]
   \   00000030   0x6010             STR      R0,[R2, #+0]
   1943          
   1944            huart->State = HAL_UART_STATE_READY;
   \   00000032   0x2001             MOVS     R0,#+1
   \   00000034   0xF881 0x0069      STRB     R0,[R1, #+105]
   1945            /* Process Unlocked */
   1946            __HAL_UNLOCK(huart);
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0xF881 0x0068      STRB     R0,[R1, #+104]
   1947          
   1948            return HAL_OK;
   \   0000003E   0x2000             MOVS     R0,#+0
   \                     ??HAL_HalfDuplex_EnableReceiver_1: (+1)
   \   00000040   0x4770             BX       LR               ;; return
   1949          }
   1950          
   1951          
   1952          /**
   1953            * @brief  Transmits break characters.
   1954            * @param  huart: UART handle
   1955            * @retval HAL status
   1956            */

   \                                 In section .text, align 2, keep-with-next
   1957          HAL_StatusTypeDef HAL_LIN_SendBreak(UART_HandleTypeDef *huart)
   1958          {
   \                     HAL_LIN_SendBreak: (+1)
   \   00000000   0x0001             MOVS     R1,R0
   1959            /* Check the parameters */
   1960            assert_param(IS_UART_INSTANCE(huart->Instance));
   1961            
   1962            /* Process Locked */
   1963            __HAL_LOCK(huart);
   \   00000002   0xF891 0x0068      LDRB     R0,[R1, #+104]
   \   00000006   0x2801             CMP      R0,#+1
   \   00000008   0xD101             BNE.N    ??HAL_LIN_SendBreak_0
   \   0000000A   0x2002             MOVS     R0,#+2
   \   0000000C   0xE012             B.N      ??HAL_LIN_SendBreak_1
   \                     ??HAL_LIN_SendBreak_0: (+1)
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0xF881 0x0068      STRB     R0,[R1, #+104]
   1964            
   1965            huart->State = HAL_UART_STATE_BUSY;
   \   00000014   0x2002             MOVS     R0,#+2
   \   00000016   0xF881 0x0069      STRB     R0,[R1, #+105]
   1966            
   1967            /* Send break characters */
   1968            huart->Instance->RQR |= UART_SENDBREAK_REQUEST;  
   \   0000001A   0x6808             LDR      R0,[R1, #+0]
   \   0000001C   0x6980             LDR      R0,[R0, #+24]
   \   0000001E   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   00000022   0x680A             LDR      R2,[R1, #+0]
   \   00000024   0x6190             STR      R0,[R2, #+24]
   1969           
   1970            huart->State = HAL_UART_STATE_READY;
   \   00000026   0x2001             MOVS     R0,#+1
   \   00000028   0xF881 0x0069      STRB     R0,[R1, #+105]
   1971            
   1972            /* Process Unlocked */
   1973            __HAL_UNLOCK(huart);
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0xF881 0x0068      STRB     R0,[R1, #+104]
   1974            
   1975            return HAL_OK; 
   \   00000032   0x2000             MOVS     R0,#+0
   \                     ??HAL_LIN_SendBreak_1: (+1)
   \   00000034   0x4770             BX       LR               ;; return
   1976          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0:
   \   00000000   0xEFFF69F3         DC32     0xefff69f3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_1:
   \   00000000   0x40011000         DC32     0x40011000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_2:
   \   00000000   0x40023890         DC32     0x40023890

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_3:
   \   00000000   0x40004400         DC32     0x40004400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_4:
   \   00000000   0x40004800         DC32     0x40004800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_5:
   \   00000000   0x40004C00         DC32     0x40004c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_6:
   \   00000000   0x40005000         DC32     0x40005000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_7:
   \   00000000   0x40011400         DC32     0x40011400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_8:
   \   00000000   0x40007800         DC32     0x40007800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_9:
   \   00000000   0x40007C00         DC32     0x40007c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_10:
   \   00000000   0x01E84800         DC32     0x1e84800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_11:
   \   00000000   0x00F42400         DC32     0xf42400
   1977          
   1978          
   1979          /**
   1980            * @}
   1981            */
   1982          
   1983          /**
   1984            * @}
   1985            */
   1986          
   1987          #endif /* HAL_UART_MODULE_ENABLED */
   1988          /**
   1989            * @}
   1990            */
   1991          
   1992          /**
   1993            * @}
   1994            */
   1995          
   1996          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   HAL_HalfDuplex_EnableReceiver
       0   HAL_HalfDuplex_EnableTransmitter
       8   HAL_HalfDuplex_Init
         8   -> HAL_UART_MspInit
         8   -> UART_AdvFeatureConfig
         8   -> UART_CheckIdleState
         8   -> UART_SetConfig
      16   HAL_LIN_Init
        16   -> HAL_UART_MspInit
        16   -> UART_AdvFeatureConfig
        16   -> UART_CheckIdleState
        16   -> UART_SetConfig
       0   HAL_LIN_SendBreak
       8   HAL_MultiProcessor_DisableMuteMode
         8   -> UART_CheckIdleState
       8   HAL_MultiProcessor_EnableMuteMode
         8   -> UART_CheckIdleState
       0   HAL_MultiProcessor_EnterMuteMode
      16   HAL_MultiProcessor_Init
        16   -> HAL_UART_MspInit
        16   -> UART_AdvFeatureConfig
        16   -> UART_CheckIdleState
        16   -> UART_SetConfig
       0   HAL_UART_DMAPause
       0   HAL_UART_DMAResume
       8   HAL_UART_DMAStop
         8   -> HAL_DMA_Abort
       8   HAL_UART_DeInit
         8   -> HAL_UART_MspDeInit
       0   HAL_UART_ErrorCallback
       0   HAL_UART_GetError
       0   HAL_UART_GetState
       8   HAL_UART_IRQHandler
         8   -> HAL_UART_ErrorCallback
         8   -> UART_EndTransmit_IT
         8   -> UART_Receive_IT
         8   -> UART_Transmit_IT
       8   HAL_UART_Init
         8   -> HAL_UART_MspInit
         8   -> UART_AdvFeatureConfig
         8   -> UART_CheckIdleState
         8   -> UART_SetConfig
       0   HAL_UART_MspDeInit
       0   HAL_UART_MspInit
      32   HAL_UART_Receive
        32   -> UART_WaitOnFlagUntilTimeout
      24   HAL_UART_Receive_DMA
        24   -> HAL_DMA_Start_IT
       4   HAL_UART_Receive_IT
       0   HAL_UART_RxCpltCallback
       0   HAL_UART_RxHalfCpltCallback
      24   HAL_UART_Transmit
        24   -> UART_WaitOnFlagUntilTimeout
      24   HAL_UART_Transmit_DMA
        24   -> HAL_DMA_Start_IT
       4   HAL_UART_Transmit_IT
       0   HAL_UART_TxCpltCallback
       0   HAL_UART_TxHalfCpltCallback
       0   UART_AdvFeatureConfig
       8   UART_CheckIdleState
         8   -> UART_WaitOnFlagUntilTimeout
      16   UART_DMAError
        16   -> HAL_UART_ErrorCallback
      16   UART_DMAReceiveCplt
        16   -> HAL_UART_RxCpltCallback
      16   UART_DMARxHalfCplt
        16   -> HAL_UART_RxHalfCpltCallback
      16   UART_DMATransmitCplt
        16   -> HAL_UART_TxCpltCallback
      16   UART_DMATxHalfCplt
        16   -> HAL_UART_TxHalfCpltCallback
       8   UART_EndTransmit_IT
         8   -> HAL_UART_TxCpltCallback
      16   UART_Receive_IT
        16   -> HAL_UART_RxCpltCallback
      32   UART_SetConfig
        32   -> HAL_RCC_GetPCLK1Freq
        32   -> HAL_RCC_GetPCLK2Freq
        32   -> HAL_RCC_GetSysClockFreq
      16   UART_Transmit_IT
        16   -> HAL_UART_TxCpltCallback
        16   -> UART_WaitOnFlagUntilTimeout
      24   UART_WaitOnFlagUntilTimeout
        24   -> HAL_GetTick


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable0
       4  ??DataTable0_1
       4  ??DataTable0_10
       4  ??DataTable0_11
       4  ??DataTable0_2
       4  ??DataTable0_3
       4  ??DataTable0_4
       4  ??DataTable0_5
       4  ??DataTable0_6
       4  ??DataTable0_7
       4  ??DataTable0_8
       4  ??DataTable0_9
      66  HAL_HalfDuplex_EnableReceiver
      66  HAL_HalfDuplex_EnableTransmitter
     132  HAL_HalfDuplex_Init
     148  HAL_LIN_Init
      54  HAL_LIN_SendBreak
      54  HAL_MultiProcessor_DisableMuteMode
      54  HAL_MultiProcessor_EnableMuteMode
      14  HAL_MultiProcessor_EnterMuteMode
     162  HAL_MultiProcessor_Init
     106  HAL_UART_DMAPause
     136  HAL_UART_DMAResume
      62  HAL_UART_DMAStop
      74  HAL_UART_DeInit
       2  HAL_UART_ErrorCallback
       4  HAL_UART_GetError
       6  HAL_UART_GetState
     248  HAL_UART_IRQHandler
     126  HAL_UART_Init
       2  HAL_UART_MspDeInit
       2  HAL_UART_MspInit
     312  HAL_UART_Receive
     162  HAL_UART_Receive_DMA
     228  HAL_UART_Receive_IT
       2  HAL_UART_RxCpltCallback
       2  HAL_UART_RxHalfCpltCallback
     232  HAL_UART_Transmit
     174  HAL_UART_Transmit_DMA
     128  HAL_UART_Transmit_IT
       2  HAL_UART_TxCpltCallback
       2  HAL_UART_TxHalfCpltCallback
     218  UART_AdvFeatureConfig
      88  UART_CheckIdleState
      40  UART_DMAError
      62  UART_DMAReceiveCplt
      14  UART_DMARxHalfCplt
      54  UART_DMATransmitCplt
      14  UART_DMATxHalfCplt
      60  UART_EndTransmit_IT
     166  UART_Receive_IT
     860  UART_SetConfig
     172  UART_Transmit_IT
     222  UART_WaitOnFlagUntilTimeout

 
 4 780 bytes in section .text
 
 4 780 bytes of CODE memory

Errors: none
Warnings: none
