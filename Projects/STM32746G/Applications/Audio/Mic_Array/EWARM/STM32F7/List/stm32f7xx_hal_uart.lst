###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.2.10312/W32 for ARM       08/Apr/2016  18:41:55
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_uart.c
#    Command line =  
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_uart.c
#        -D USE_HAL_DRIVER -D STM32F746xx -D USE_STM32746G_DISCO -D
#        USE_IOEXPANDER -D USE_USB_FS -lC
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
#        -lA
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
#        -o
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj
#        --no_unroll --debug --endian=little --cpu=Cortex-M7 -e --fpu=VFPv5_sp
#        --dlib_config "D:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Full.h" -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\CMSIS\Device\ST\STM32F7xx\Include\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\STM32F7xx_HAL_Driver\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\STM32746G-Discovery\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\Components\Common\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Log\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Fonts\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\CPU\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_Device_Library\Core\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Core\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Class\MSC\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\drivers\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_Audio\Addons\PDM\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_Device_Library\Class\AUDIO\Inc\
#        -Ohs --use_c++_inline --require_prototypes -I "D:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.3\arm\CMSIS\Include\" -D
#        ARM_MATH_CM7 --relaxed_fp
#    List file    =  
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List\stm32f7xx_hal_uart.lst
#    Object file  =  
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj\stm32f7xx_hal_uart.o
#
###############################################################################

D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_uart.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f7xx_hal_uart.c
      4            * @author  MCD Application Team
      5            * @version V1.0.4
      6            * @date    09-December-2015
      7            * @brief   UART HAL module driver.
      8            *          This file provides firmware functions to manage the following 
      9            *          functionalities of the Universal Asynchronous Receiver Transmitter (UART) peripheral:
     10            *           + Initialization and de-initialization functions
     11            *           + IO operation functions
     12            *           + Peripheral Control functions  
     13            *           + Peripheral State and Errors functions  
     14            *           
     15            @verbatim       
     16            ==============================================================================
     17                                  ##### How to use this driver #####
     18            ==============================================================================
     19            [..]
     20              The UART HAL driver can be used as follows:
     21              
     22              (#) Declare a UART_HandleTypeDef handle structure.
     23            
     24              (#) Initialize the UART low level resources by implementing the HAL_UART_MspInit() API:
     25                  (##) Enable the USARTx interface clock.
     26                  (##) UART pins configuration:
     27                      (+++) Enable the clock for the UART GPIOs.
     28                      (+++) Configure these UART pins as alternate function pull-up.
     29                  (##) NVIC configuration if you need to use interrupt process (HAL_UART_Transmit_IT()
     30                       and HAL_UART_Receive_IT() APIs):
     31                      (+++) Configure the USARTx interrupt priority.
     32                      (+++) Enable the NVIC USART IRQ handle.
     33                  (##) DMA Configuration if you need to use DMA process (HAL_UART_Transmit_DMA()
     34                       and HAL_UART_Receive_DMA() APIs):
     35                      (+++) Declare a DMA handle structure for the Tx/Rx stream.
     36                      (+++) Enable the DMAx interface clock.
     37                      (+++) Configure the declared DMA handle structure with the required 
     38                            Tx/Rx parameters.                
     39                      (+++) Configure the DMA Tx/Rx Stream.
     40                      (+++) Associate the initialized DMA handle to the UART DMA Tx/Rx handle.
     41                      (+++) Configure the priority and enable the NVIC for the transfer complete 
     42                            interrupt on the DMA Tx/Rx Stream.
     43          
     44              (#) Program the Baud Rate, Word Length, Stop Bit, Parity, Hardware 
     45                  flow control and Mode(Receiver/Transmitter) in the Init structure.
     46          
     47              (#) For the UART asynchronous mode, initialize the UART registers by calling
     48                  the HAL_UART_Init() API.
     49              
     50              (#) For the UART Half duplex mode, initialize the UART registers by calling 
     51                  the HAL_HalfDuplex_Init() API.
     52              
     53              (#) For the LIN mode, initialize the UART registers by calling the HAL_LIN_Init() API.
     54              
     55              (#) For the Multi-Processor mode, initialize the UART registers by calling 
     56                  the HAL_MultiProcessor_Init() API.
     57                  
     58               [..] 
     59                 (@) The specific UART interrupts (Transmission complete interrupt, 
     60                      RXNE interrupt and Error Interrupts) will be managed using the macros
     61                      __HAL_UART_ENABLE_IT() and __HAL_UART_DISABLE_IT() inside the transmit 
     62                      and receive process.
     63                    
     64               [..] 
     65                 (@) These APIs (HAL_UART_Init() and HAL_HalfDuplex_Init()) configure also the 
     66                      low level Hardware GPIO, CLOCK, CORTEX...etc) by calling the customized 
     67                      HAL_UART_MspInit() API.
     68                    
     69               [..] 
     70                  Three operation modes are available within this driver :     
     71            
     72               *** Polling mode IO operation ***
     73               =================================
     74               [..]    
     75                 (+) Send an amount of data in blocking mode using HAL_UART_Transmit() 
     76                 (+) Receive an amount of data in blocking mode using HAL_UART_Receive()
     77                 
     78               *** Interrupt mode IO operation ***    
     79               ===================================
     80               [..]    
     81                 (+) Send an amount of data in non blocking mode using HAL_UART_Transmit_IT() 
     82                 (+) At transmission end of transfer HAL_UART_TxCpltCallback is executed and user can 
     83                      add his own code by customization of function pointer HAL_UART_TxCpltCallback
     84                 (+) Receive an amount of data in non blocking mode using HAL_UART_Receive_IT() 
     85                 (+) At reception end of transfer HAL_UART_RxCpltCallback is executed and user can 
     86                      add his own code by customization of function pointer HAL_UART_RxCpltCallback
     87                 (+) In case of transfer Error, HAL_UART_ErrorCallback() function is executed and user can 
     88                      add his own code by customization of function pointer HAL_UART_ErrorCallback
     89          
     90               *** DMA mode IO operation ***    
     91               ==============================
     92               [..] 
     93                 (+) Send an amount of data in non blocking mode (DMA) using HAL_UART_Transmit_DMA() 
     94                 (+) At transmission end of half transfer HAL_UART_TxHalfCpltCallback is executed and user can 
     95                      add his own code by customization of function pointer HAL_UART_TxHalfCpltCallback 
     96                 (+) At transmission end of transfer HAL_UART_TxCpltCallback is executed and user can 
     97                      add his own code by customization of function pointer HAL_UART_TxCpltCallback
     98                 (+) Receive an amount of data in non blocking mode (DMA) using HAL_UART_Receive_DMA() 
     99                 (+) At reception end of half transfer HAL_UART_RxHalfCpltCallback is executed and user can 
    100                      add his own code by customization of function pointer HAL_UART_RxHalfCpltCallback 
    101                 (+) At reception end of transfer HAL_UART_RxCpltCallback is executed and user can 
    102                      add his own code by customization of function pointer HAL_UART_RxCpltCallback
    103                 (+) In case of transfer Error, HAL_UART_ErrorCallback() function is executed and user can 
    104                      add his own code by customization of function pointer HAL_UART_ErrorCallback
    105                 (+) Pause the DMA Transfer using HAL_UART_DMAPause()      
    106                 (+) Resume the DMA Transfer using HAL_UART_DMAResume()  
    107                 (+) Stop the DMA Transfer using HAL_UART_DMAStop()      
    108              
    109               *** UART HAL driver macros list ***
    110               ============================================= 
    111               [..]
    112                 Below the list of most used macros in UART HAL driver.
    113                 
    114                (+) __HAL_UART_ENABLE: Enable the UART peripheral 
    115                (+) __HAL_UART_DISABLE: Disable the UART peripheral     
    116                (+) __HAL_UART_GET_FLAG : Check whether the specified UART flag is set or not
    117                (+) __HAL_UART_CLEAR_IT : Clears the specified UART ISR flag
    118                (+) __HAL_UART_ENABLE_IT: Enable the specified UART interrupt
    119                (+) __HAL_UART_DISABLE_IT: Disable the specified UART interrupt
    120                (+) __HAL_UART_GET_IT_SOURCE: Check whether the specified UART interrupt has occurred or not
    121                
    122               [..] 
    123                 (@) You can refer to the UART HAL driver header file for more useful macros 
    124                
    125            @endverbatim
    126            ******************************************************************************
    127            * @attention
    128            *
    129            * <h2><center>&copy; COPYRIGHT(c) 2015 STMicroelectronics</center></h2>
    130            *
    131            * Redistribution and use in source and binary forms, with or without modification,
    132            * are permitted provided that the following conditions are met:
    133            *   1. Redistributions of source code must retain the above copyright notice,
    134            *      this list of conditions and the following disclaimer.
    135            *   2. Redistributions in binary form must reproduce the above copyright notice,
    136            *      this list of conditions and the following disclaimer in the documentation
    137            *      and/or other materials provided with the distribution.
    138            *   3. Neither the name of STMicroelectronics nor the names of its contributors
    139            *      may be used to endorse or promote products derived from this software
    140            *      without specific prior written permission.
    141            *
    142            * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
    143            * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
    144            * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
    145            * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
    146            * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
    147            * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
    148            * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
    149            * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
    150            * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
    151            * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
    152            *
    153            ******************************************************************************
    154            */ 
    155          
    156          /* Includes ------------------------------------------------------------------*/
    157          #include "stm32f7xx_hal.h"
    158          
    159          /** @addtogroup STM32F7xx_HAL_Driver
    160            * @{
    161            */
    162          
    163          /** @defgroup UART UART
    164            * @brief HAL UART module driver
    165            * @{
    166            */
    167          #ifdef HAL_UART_MODULE_ENABLED
    168              
    169          /* Private typedef -----------------------------------------------------------*/
    170          /* Private define ------------------------------------------------------------*/
    171          #define UART_CR1_FIELDS  ((uint32_t)(USART_CR1_M | USART_CR1_PCE | USART_CR1_PS | \
    172                                               USART_CR1_TE | USART_CR1_RE | USART_CR1_OVER8))
    173          /* Private macro -------------------------------------------------------------*/
    174          /* Private variables ---------------------------------------------------------*/
    175          /* Private function prototypes -----------------------------------------------*/
    176          static void UART_DMATransmitCplt(DMA_HandleTypeDef *hdma);
    177          static void UART_DMAReceiveCplt(DMA_HandleTypeDef *hdma);
    178          static void UART_DMARxHalfCplt(DMA_HandleTypeDef *hdma);
    179          static void UART_DMATxHalfCplt(DMA_HandleTypeDef *hdma);
    180          static void UART_DMAError(DMA_HandleTypeDef *hdma); 
    181          static HAL_StatusTypeDef UART_Transmit_IT(UART_HandleTypeDef *huart);
    182          static HAL_StatusTypeDef UART_EndTransmit_IT(UART_HandleTypeDef *huart);
    183          static HAL_StatusTypeDef UART_Receive_IT(UART_HandleTypeDef *huart);
    184          /* Private functions ---------------------------------------------------------*/
    185          
    186          /** @defgroup UART_Exported_Functions UART Exported Functions
    187            * @{
    188            */
    189          
    190          /** @defgroup UART_Exported_Functions_Group1 Initialization and de-initialization functions 
    191            *  @brief    Initialization and Configuration functions 
    192            *
    193          @verbatim    
    194          ===============================================================================
    195                      ##### Initialization and Configuration functions #####
    196           ===============================================================================
    197              [..]
    198              This subsection provides a set of functions allowing to initialize the USARTx or the UARTy 
    199              in asynchronous mode.
    200                (+) For the asynchronous mode only these parameters can be configured: 
    201                  (++) Baud Rate
    202                  (++) Word Length 
    203                  (++) Stop Bit
    204                  (++) Parity: If the parity is enabled, then the MSB bit of the data written
    205                       in the data register is transmitted but is changed by the parity bit.
    206                       Depending on the frame length defined by the M bit (8-bits or 9-bits),
    207                       please refer to Reference manual for possible UART frame formats.           
    208                  (++) Hardware flow control
    209                  (++) Receiver/transmitter modes
    210                  (++) Over Sampling Method
    211              [..]
    212              The HAL_UART_Init(), HAL_HalfDuplex_Init(), HAL_LIN_Init() and HAL_MultiProcessor_Init() APIs 
    213              follow respectively the UART asynchronous, UART Half duplex, LIN and Multi-Processor
    214              configuration procedures (details for the procedures are available in reference manual (RM0329)).
    215          
    216          @endverbatim
    217            * @{
    218            */
    219          
    220          /**
    221            * @brief Initializes the UART mode according to the specified
    222            *         parameters in the UART_InitTypeDef and creates the associated handle .
    223            * @param huart: uart handle
    224            * @retval HAL status
    225            */

   \                                 In section .text, align 2, keep-with-next
    226          HAL_StatusTypeDef HAL_UART_Init(UART_HandleTypeDef *huart)
    227          {
   \                     HAL_UART_Init: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    228            /* Check the UART handle allocation */
    229            if(huart == NULL)
   \   00000004   0xD014             BEQ.N    ??HAL_UART_Init_0
    230            {
    231              return HAL_ERROR;
    232            }
    233            
    234            if(huart->Init.HwFlowCtl != UART_HWCONTROL_NONE)
    235            {
    236              /* Check the parameters */
    237              assert_param(IS_UART_HWFLOW_INSTANCE(huart->Instance));
    238            }
    239            else
    240            {
    241              /* Check the parameters */
    242              assert_param(IS_UART_INSTANCE(huart->Instance));
    243            }
    244            
    245            if(huart->State == HAL_UART_STATE_RESET)
   \   00000006   0xF894 0x0069      LDRB     R0,[R4, #+105]
   \   0000000A   0xB920             CBNZ.N   R0,??HAL_UART_Init_1
    246            {
    247              /* Allocate lock resource and initialize it */
    248              huart->Lock = HAL_UNLOCKED;
   \   0000000C   0xF884 0x0068      STRB     R0,[R4, #+104]
    249          
    250              /* Init the low level hardware : GPIO, CLOCK */
    251              HAL_UART_MspInit(huart);
   \   00000010   0x4620             MOV      R0,R4
   \   00000012   0x.... 0x....      BL       HAL_UART_MspInit
    252            }
    253          
    254            huart->State = HAL_UART_STATE_BUSY;
   \                     ??HAL_UART_Init_1: (+1)
   \   00000016   0x2002             MOVS     R0,#+2
   \   00000018   0xF884 0x0069      STRB     R0,[R4, #+105]
    255          
    256            /* Disable the Peripheral */
    257            __HAL_UART_DISABLE(huart);
   \   0000001C   0x6820             LDR      R0,[R4, #+0]
   \   0000001E   0x6801             LDR      R1,[R0, #+0]
   \   00000020   0x0849             LSRS     R1,R1,#+1
   \   00000022   0x0049             LSLS     R1,R1,#+1
   \   00000024   0x6001             STR      R1,[R0, #+0]
    258            
    259            /* Set the UART Communication parameters */
    260            if (UART_SetConfig(huart) == HAL_ERROR)
   \   00000026   0x4620             MOV      R0,R4
   \   00000028   0x.... 0x....      BL       UART_SetConfig
   \   0000002C   0x2801             CMP      R0,#+1
   \   0000002E   0xD101             BNE.N    ??HAL_UART_Init_2
    261            {
    262              return HAL_ERROR;
   \                     ??HAL_UART_Init_0: (+1)
   \   00000030   0x2001             MOVS     R0,#+1
   \   00000032   0xBD10             POP      {R4,PC}
    263            }
    264          
    265            if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
   \                     ??HAL_UART_Init_2: (+1)
   \   00000034   0x6A60             LDR      R0,[R4, #+36]
   \   00000036   0xB110             CBZ.N    R0,??HAL_UART_Init_3
    266            {
    267              UART_AdvFeatureConfig(huart);
   \   00000038   0x4620             MOV      R0,R4
   \   0000003A   0x.... 0x....      BL       UART_AdvFeatureConfig
    268            }
    269          
    270            /* In asynchronous mode, the following bits must be kept cleared:
    271            - LINEN and CLKEN bits in the USART_CR2 register,
    272            - SCEN, HDSEL and IREN  bits in the USART_CR3 register.*/
    273            huart->Instance->CR2 &= ~(USART_CR2_LINEN | USART_CR2_CLKEN);
   \                     ??HAL_UART_Init_3: (+1)
   \   0000003E   0x6820             LDR      R0,[R4, #+0]
   \   00000040   0x6841             LDR      R1,[R0, #+4]
   \   00000042   0xF421 0x4190      BIC      R1,R1,#0x4800
   \   00000046   0x6041             STR      R1,[R0, #+4]
    274            huart->Instance->CR3 &= ~(USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN);
   \   00000048   0x6820             LDR      R0,[R4, #+0]
   \   0000004A   0x6881             LDR      R1,[R0, #+8]
   \   0000004C   0xF021 0x012A      BIC      R1,R1,#0x2A
   \   00000050   0x6081             STR      R1,[R0, #+8]
    275          
    276            /* Enable the Peripheral */
    277            __HAL_UART_ENABLE(huart);
   \   00000052   0x6820             LDR      R0,[R4, #+0]
   \   00000054   0x6801             LDR      R1,[R0, #+0]
   \   00000056   0xF041 0x0101      ORR      R1,R1,#0x1
   \   0000005A   0x6001             STR      R1,[R0, #+0]
    278          
    279            /* TEACK and/or REACK to check before moving huart->State to Ready */
    280            return (UART_CheckIdleState(huart));
   \   0000005C   0x4620             MOV      R0,R4
   \   0000005E   0xE8BD 0x4010      POP      {R4,LR}
   \   00000062   0x.... 0x....      B.W      UART_CheckIdleState
    281          }
    282          
    283          /**
    284            * @brief Initializes the half-duplex mode according to the specified
    285            *         parameters in the UART_InitTypeDef and creates the associated handle .
    286            * @param huart: UART handle
    287            * @retval HAL status
    288            */

   \                                 In section .text, align 2, keep-with-next
    289          HAL_StatusTypeDef HAL_HalfDuplex_Init(UART_HandleTypeDef *huart)
    290          {
   \                     HAL_HalfDuplex_Init: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    291            /* Check the UART handle allocation */
    292            if(huart == NULL)
   \   00000004   0xD014             BEQ.N    ??HAL_HalfDuplex_Init_0
    293            {
    294              return HAL_ERROR;
    295            }
    296            
    297            if(huart->State == HAL_UART_STATE_RESET)
   \   00000006   0xF894 0x0069      LDRB     R0,[R4, #+105]
   \   0000000A   0xB920             CBNZ.N   R0,??HAL_HalfDuplex_Init_1
    298            {
    299              /* Allocate lock resource and initialize it */
    300              huart->Lock = HAL_UNLOCKED;
   \   0000000C   0xF884 0x0068      STRB     R0,[R4, #+104]
    301              /* Init the low level hardware : GPIO, CLOCK */
    302              HAL_UART_MspInit(huart);
   \   00000010   0x4620             MOV      R0,R4
   \   00000012   0x.... 0x....      BL       HAL_UART_MspInit
    303            }
    304          
    305            huart->State = HAL_UART_STATE_BUSY;
   \                     ??HAL_HalfDuplex_Init_1: (+1)
   \   00000016   0x2002             MOVS     R0,#+2
   \   00000018   0xF884 0x0069      STRB     R0,[R4, #+105]
    306          
    307            /* Disable the Peripheral */
    308            __HAL_UART_DISABLE(huart);
   \   0000001C   0x6820             LDR      R0,[R4, #+0]
   \   0000001E   0x6801             LDR      R1,[R0, #+0]
   \   00000020   0x0849             LSRS     R1,R1,#+1
   \   00000022   0x0049             LSLS     R1,R1,#+1
   \   00000024   0x6001             STR      R1,[R0, #+0]
    309          
    310            /* Set the UART Communication parameters */
    311            if (UART_SetConfig(huart) == HAL_ERROR)
   \   00000026   0x4620             MOV      R0,R4
   \   00000028   0x.... 0x....      BL       UART_SetConfig
   \   0000002C   0x2801             CMP      R0,#+1
   \   0000002E   0xD101             BNE.N    ??HAL_HalfDuplex_Init_2
    312            {
    313              return HAL_ERROR;
   \                     ??HAL_HalfDuplex_Init_0: (+1)
   \   00000030   0x2001             MOVS     R0,#+1
   \   00000032   0xBD10             POP      {R4,PC}
    314            }
    315          
    316            if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
   \                     ??HAL_HalfDuplex_Init_2: (+1)
   \   00000034   0x6A60             LDR      R0,[R4, #+36]
   \   00000036   0xB110             CBZ.N    R0,??HAL_HalfDuplex_Init_3
    317            {
    318              UART_AdvFeatureConfig(huart);
   \   00000038   0x4620             MOV      R0,R4
   \   0000003A   0x.... 0x....      BL       UART_AdvFeatureConfig
    319            }
    320          
    321            /* In half-duplex mode, the following bits must be kept cleared:
    322            - LINEN and CLKEN bits in the USART_CR2 register,
    323            - SCEN and IREN bits in the USART_CR3 register.*/
    324            huart->Instance->CR2 &= ~(USART_CR2_LINEN | USART_CR2_CLKEN);
   \                     ??HAL_HalfDuplex_Init_3: (+1)
   \   0000003E   0x6820             LDR      R0,[R4, #+0]
   \   00000040   0x6841             LDR      R1,[R0, #+4]
   \   00000042   0xF421 0x4190      BIC      R1,R1,#0x4800
   \   00000046   0x6041             STR      R1,[R0, #+4]
    325            huart->Instance->CR3 &= ~(USART_CR3_IREN | USART_CR3_SCEN);
   \   00000048   0x6820             LDR      R0,[R4, #+0]
   \   0000004A   0x6881             LDR      R1,[R0, #+8]
   \   0000004C   0xF021 0x0122      BIC      R1,R1,#0x22
   \   00000050   0x6081             STR      R1,[R0, #+8]
    326          
    327            /* Enable the Half-Duplex mode by setting the HDSEL bit in the CR3 register */
    328            huart->Instance->CR3 |= USART_CR3_HDSEL;
   \   00000052   0x6820             LDR      R0,[R4, #+0]
   \   00000054   0x6881             LDR      R1,[R0, #+8]
   \   00000056   0xF041 0x0108      ORR      R1,R1,#0x8
   \   0000005A   0x6081             STR      R1,[R0, #+8]
    329          
    330            /* Enable the Peripheral */
    331            __HAL_UART_ENABLE(huart);
   \   0000005C   0x6820             LDR      R0,[R4, #+0]
   \   0000005E   0x6801             LDR      R1,[R0, #+0]
   \   00000060   0xF041 0x0101      ORR      R1,R1,#0x1
   \   00000064   0x6001             STR      R1,[R0, #+0]
    332          
    333            /* TEACK and/or REACK to check before moving huart->State to Ready */
    334            return (UART_CheckIdleState(huart));
   \   00000066   0x4620             MOV      R0,R4
   \   00000068   0xE8BD 0x4010      POP      {R4,LR}
   \   0000006C   0x.... 0x....      B.W      UART_CheckIdleState
    335          }
    336          
    337          
    338          /**
    339            * @brief Initializes the LIN mode according to the specified
    340            *         parameters in the UART_InitTypeDef and creates the associated handle .
    341            * @param huart: uart handle
    342            * @param BreakDetectLength: specifies the LIN break detection length.
    343            *        This parameter can be one of the following values:
    344            *          @arg UART_LINBREAKDETECTLENGTH_10B: 10-bit break detection
    345            *          @arg UART_LINBREAKDETECTLENGTH_11B: 11-bit break detection
    346            * @retval HAL status
    347            */

   \                                 In section .text, align 2, keep-with-next
    348          HAL_StatusTypeDef HAL_LIN_Init(UART_HandleTypeDef *huart, uint32_t BreakDetectLength)
    349          {
   \                     HAL_LIN_Init: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0xB081             SUB      SP,SP,#+4
   \   00000006   0x460D             MOV      R5,R1
    350            /* Check the UART handle allocation */
    351            if(huart == NULL)
   \   00000008   0xD014             BEQ.N    ??HAL_LIN_Init_0
    352            {
    353              return HAL_ERROR;
    354            }
    355          
    356            /* Check the parameters */
    357            assert_param(IS_UART_INSTANCE(huart->Instance));
    358            assert_param(IS_UART_LIN_BREAK_DETECT_LENGTH(BreakDetectLength));
    359            assert_param(IS_LIN_WORD_LENGTH(huart->Init.WordLength));
    360            	
    361            if(huart->State == HAL_UART_STATE_RESET)
   \   0000000A   0xF894 0x0069      LDRB     R0,[R4, #+105]
   \   0000000E   0xB920             CBNZ.N   R0,??HAL_LIN_Init_1
    362            {  
    363              /* Allocate lock resource and initialize it */
    364              huart->Lock = HAL_UNLOCKED; 
   \   00000010   0xF884 0x0068      STRB     R0,[R4, #+104]
    365              /* Init the low level hardware : GPIO, CLOCK */
    366              HAL_UART_MspInit(huart);
   \   00000014   0x4620             MOV      R0,R4
   \   00000016   0x.... 0x....      BL       HAL_UART_MspInit
    367            }
    368            
    369            huart->State = HAL_UART_STATE_BUSY;
   \                     ??HAL_LIN_Init_1: (+1)
   \   0000001A   0x2002             MOVS     R0,#+2
   \   0000001C   0xF884 0x0069      STRB     R0,[R4, #+105]
    370            
    371            /* Disable the Peripheral */
    372            __HAL_UART_DISABLE(huart);
   \   00000020   0x6820             LDR      R0,[R4, #+0]
   \   00000022   0x6801             LDR      R1,[R0, #+0]
   \   00000024   0x0849             LSRS     R1,R1,#+1
   \   00000026   0x0049             LSLS     R1,R1,#+1
   \   00000028   0x6001             STR      R1,[R0, #+0]
    373            
    374            /* Set the UART Communication parameters */
    375            if (UART_SetConfig(huart) == HAL_ERROR)
   \   0000002A   0x4620             MOV      R0,R4
   \   0000002C   0x.... 0x....      BL       UART_SetConfig
   \   00000030   0x2801             CMP      R0,#+1
   \   00000032   0xD102             BNE.N    ??HAL_LIN_Init_2
    376            {
    377              return HAL_ERROR;
   \                     ??HAL_LIN_Init_0: (+1)
   \   00000034   0x2001             MOVS     R0,#+1
   \   00000036   0xB001             ADD      SP,SP,#+4
   \   00000038   0xBD30             POP      {R4,R5,PC}
    378            } 
    379            
    380            if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
   \                     ??HAL_LIN_Init_2: (+1)
   \   0000003A   0x6A60             LDR      R0,[R4, #+36]
   \   0000003C   0xB110             CBZ.N    R0,??HAL_LIN_Init_3
    381            {
    382              UART_AdvFeatureConfig(huart);
   \   0000003E   0x4620             MOV      R0,R4
   \   00000040   0x.... 0x....      BL       UART_AdvFeatureConfig
    383            }
    384            
    385            /* In LIN mode, the following bits must be kept cleared: 
    386            - LINEN and CLKEN bits in the USART_CR2 register,
    387            - SCEN and IREN bits in the USART_CR3 register.*/
    388            huart->Instance->CR2 &= ~(USART_CR2_CLKEN);
   \                     ??HAL_LIN_Init_3: (+1)
   \   00000044   0x6820             LDR      R0,[R4, #+0]
   \   00000046   0x6841             LDR      R1,[R0, #+4]
   \   00000048   0xF421 0x6100      BIC      R1,R1,#0x800
   \   0000004C   0x6041             STR      R1,[R0, #+4]
    389            huart->Instance->CR3 &= ~(USART_CR3_HDSEL | USART_CR3_IREN | USART_CR3_SCEN);
   \   0000004E   0x6820             LDR      R0,[R4, #+0]
   \   00000050   0x6881             LDR      R1,[R0, #+8]
   \   00000052   0xF021 0x012A      BIC      R1,R1,#0x2A
   \   00000056   0x6081             STR      R1,[R0, #+8]
    390            
    391            /* Enable the LIN mode by setting the LINEN bit in the CR2 register */
    392            huart->Instance->CR2 |= USART_CR2_LINEN;
   \   00000058   0x6820             LDR      R0,[R4, #+0]
   \   0000005A   0x6841             LDR      R1,[R0, #+4]
   \   0000005C   0xF441 0x4180      ORR      R1,R1,#0x4000
   \   00000060   0x6041             STR      R1,[R0, #+4]
    393            
    394            /* Set the USART LIN Break detection length. */
    395            MODIFY_REG(huart->Instance->CR2, USART_CR2_LBDL, BreakDetectLength);
   \   00000062   0x6820             LDR      R0,[R4, #+0]
   \   00000064   0x6841             LDR      R1,[R0, #+4]
   \   00000066   0xF021 0x0120      BIC      R1,R1,#0x20
   \   0000006A   0x4329             ORRS     R1,R5,R1
   \   0000006C   0x6041             STR      R1,[R0, #+4]
    396            
    397              /* Enable the Peripheral */
    398            __HAL_UART_ENABLE(huart);
   \   0000006E   0x6820             LDR      R0,[R4, #+0]
   \   00000070   0x6801             LDR      R1,[R0, #+0]
   \   00000072   0xF041 0x0101      ORR      R1,R1,#0x1
   \   00000076   0x6001             STR      R1,[R0, #+0]
    399            
    400            /* TEACK and/or REACK to check before moving huart->State to Ready */
    401            return (UART_CheckIdleState(huart));
   \   00000078   0x4620             MOV      R0,R4
   \   0000007A   0xB001             ADD      SP,SP,#+4
   \   0000007C   0xE8BD 0x4030      POP      {R4,R5,LR}
   \   00000080   0x.... 0x....      B.W      UART_CheckIdleState
    402          }
    403          
    404          
    405          
    406          /**
    407            * @brief Initializes the multiprocessor mode according to the specified
    408            *         parameters in the UART_InitTypeDef and creates the associated handle.
    409            * @param huart: UART handle   
    410            * @param Address: UART node address (4-, 6-, 7- or 8-bit long)
    411            * @param WakeUpMethod: specifies the UART wakeup method.
    412            *        This parameter can be one of the following values:
    413            *          @arg UART_WAKEUPMETHOD_IDLELINE: WakeUp by an idle line detection
    414            *          @arg UART_WAKEUPMETHOD_ADDRESSMARK: WakeUp by an address mark
    415            * @note  If the user resorts to idle line detection wake up, the Address parameter
    416            *        is useless and ignored by the initialization function.               
    417            * @note  If the user resorts to address mark wake up, the address length detection 
    418            *        is configured by default to 4 bits only. For the UART to be able to 
    419            *        manage 6-, 7- or 8-bit long addresses detection                    
    420            * @retval HAL status
    421            */

   \                                 In section .text, align 2, keep-with-next
    422          HAL_StatusTypeDef HAL_MultiProcessor_Init(UART_HandleTypeDef *huart, uint8_t Address, uint32_t WakeUpMethod)
    423          {
   \                     HAL_MultiProcessor_Init: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x460E             MOV      R6,R1
   \   00000006   0x4615             MOV      R5,R2
    424            /* Check the UART handle allocation */
    425            if(huart == NULL)
   \   00000008   0xD014             BEQ.N    ??HAL_MultiProcessor_Init_0
    426            {
    427              return HAL_ERROR;
    428            }
    429          
    430            /* Check the wake up method parameter */
    431            assert_param(IS_UART_WAKEUPMETHOD(WakeUpMethod));
    432            
    433            if(huart->State == HAL_UART_STATE_RESET)
   \   0000000A   0xF894 0x0069      LDRB     R0,[R4, #+105]
   \   0000000E   0xB920             CBNZ.N   R0,??HAL_MultiProcessor_Init_1
    434            { 
    435              /* Allocate lock resource and initialize it */
    436              huart->Lock = HAL_UNLOCKED;  
   \   00000010   0xF884 0x0068      STRB     R0,[R4, #+104]
    437              /* Init the low level hardware : GPIO, CLOCK */
    438              HAL_UART_MspInit(huart);
   \   00000014   0x4620             MOV      R0,R4
   \   00000016   0x.... 0x....      BL       HAL_UART_MspInit
    439            }
    440            
    441            huart->State = HAL_UART_STATE_BUSY;
   \                     ??HAL_MultiProcessor_Init_1: (+1)
   \   0000001A   0x2002             MOVS     R0,#+2
   \   0000001C   0xF884 0x0069      STRB     R0,[R4, #+105]
    442            
    443            /* Disable the Peripheral */
    444            __HAL_UART_DISABLE(huart);
   \   00000020   0x6820             LDR      R0,[R4, #+0]
   \   00000022   0x6801             LDR      R1,[R0, #+0]
   \   00000024   0x0849             LSRS     R1,R1,#+1
   \   00000026   0x0049             LSLS     R1,R1,#+1
   \   00000028   0x6001             STR      R1,[R0, #+0]
    445            
    446            /* Set the UART Communication parameters */
    447            if (UART_SetConfig(huart) == HAL_ERROR)
   \   0000002A   0x4620             MOV      R0,R4
   \   0000002C   0x.... 0x....      BL       UART_SetConfig
   \   00000030   0x2801             CMP      R0,#+1
   \   00000032   0xD101             BNE.N    ??HAL_MultiProcessor_Init_2
    448            {
    449              return HAL_ERROR;
   \                     ??HAL_MultiProcessor_Init_0: (+1)
   \   00000034   0x2001             MOVS     R0,#+1
   \   00000036   0xBD70             POP      {R4-R6,PC}
    450            } 
    451            
    452            if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
   \                     ??HAL_MultiProcessor_Init_2: (+1)
   \   00000038   0x6A60             LDR      R0,[R4, #+36]
   \   0000003A   0xB110             CBZ.N    R0,??HAL_MultiProcessor_Init_3
    453            {
    454              UART_AdvFeatureConfig(huart);
   \   0000003C   0x4620             MOV      R0,R4
   \   0000003E   0x.... 0x....      BL       UART_AdvFeatureConfig
    455            }
    456            
    457            /* In multiprocessor mode, the following bits must be kept cleared: 
    458            - LINEN and CLKEN bits in the USART_CR2 register,
    459            - SCEN, HDSEL and IREN  bits in the USART_CR3 register. */
    460            huart->Instance->CR2 &= ~(USART_CR2_LINEN | USART_CR2_CLKEN);
   \                     ??HAL_MultiProcessor_Init_3: (+1)
   \   00000042   0x6820             LDR      R0,[R4, #+0]
    461            huart->Instance->CR3 &= ~(USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN);
    462            
    463            if (WakeUpMethod == UART_WAKEUPMETHOD_ADDRESSMARK)
   \   00000044   0xF5B5 0x6F00      CMP      R5,#+2048
   \   00000048   0x6841             LDR      R1,[R0, #+4]
   \   0000004A   0xF421 0x4190      BIC      R1,R1,#0x4800
   \   0000004E   0x6041             STR      R1,[R0, #+4]
   \   00000050   0x6820             LDR      R0,[R4, #+0]
   \   00000052   0x6881             LDR      R1,[R0, #+8]
   \   00000054   0xF021 0x012A      BIC      R1,R1,#0x2A
   \   00000058   0x6081             STR      R1,[R0, #+8]
   \   0000005A   0xD106             BNE.N    ??HAL_MultiProcessor_Init_4
    464            {
    465              /* If address mark wake up method is chosen, set the USART address node */
    466              MODIFY_REG(huart->Instance->CR2, USART_CR2_ADD, ((uint32_t)Address << UART_CR2_ADDRESS_LSB_POS));
   \   0000005C   0x6820             LDR      R0,[R4, #+0]
   \   0000005E   0x6841             LDR      R1,[R0, #+4]
   \   00000060   0x0209             LSLS     R1,R1,#+8
   \   00000062   0x0A09             LSRS     R1,R1,#+8
   \   00000064   0xEA41 0x6106      ORR      R1,R1,R6, LSL #+24
   \   00000068   0x6041             STR      R1,[R0, #+4]
    467            }
    468            
    469            /* Set the wake up method by setting the WAKE bit in the CR1 register */
    470            MODIFY_REG(huart->Instance->CR1, USART_CR1_WAKE, WakeUpMethod);
   \                     ??HAL_MultiProcessor_Init_4: (+1)
   \   0000006A   0x6820             LDR      R0,[R4, #+0]
   \   0000006C   0x6801             LDR      R1,[R0, #+0]
   \   0000006E   0xF421 0x6100      BIC      R1,R1,#0x800
   \   00000072   0x4329             ORRS     R1,R5,R1
   \   00000074   0x6001             STR      R1,[R0, #+0]
    471            
    472            /* Enable the Peripheral */
    473            __HAL_UART_ENABLE(huart); 
   \   00000076   0x6820             LDR      R0,[R4, #+0]
   \   00000078   0x6801             LDR      R1,[R0, #+0]
   \   0000007A   0xF041 0x0101      ORR      R1,R1,#0x1
   \   0000007E   0x6001             STR      R1,[R0, #+0]
    474            
    475            /* TEACK and/or REACK to check before moving huart->State to Ready */
    476            return (UART_CheckIdleState(huart));
   \   00000080   0x4620             MOV      R0,R4
   \   00000082   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   00000086   0x.... 0x....      B.W      UART_CheckIdleState
    477          }
    478          
    479          
    480          
    481          
    482          /**
    483            * @brief DeInitializes the UART peripheral 
    484            * @param huart: uart handle
    485            * @retval HAL status
    486            */

   \                                 In section .text, align 2, keep-with-next
    487          HAL_StatusTypeDef HAL_UART_DeInit(UART_HandleTypeDef *huart)
    488          {
   \                     HAL_UART_DeInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    489            /* Check the UART handle allocation */
    490            if(huart == NULL)
   \   00000004   0xD101             BNE.N    ??HAL_UART_DeInit_0
    491            {
    492              return HAL_ERROR;
   \   00000006   0x2001             MOVS     R0,#+1
   \   00000008   0xBD10             POP      {R4,PC}
    493            }
    494            
    495            /* Check the parameters */
    496            assert_param(IS_UART_INSTANCE(huart->Instance));
    497          
    498            huart->State = HAL_UART_STATE_BUSY;
   \                     ??HAL_UART_DeInit_0: (+1)
   \   0000000A   0x2002             MOVS     R0,#+2
   \   0000000C   0xF884 0x0069      STRB     R0,[R4, #+105]
    499            
    500            /* Disable the Peripheral */
    501            __HAL_UART_DISABLE(huart);
   \   00000010   0x6820             LDR      R0,[R4, #+0]
   \   00000012   0x6801             LDR      R1,[R0, #+0]
   \   00000014   0x0849             LSRS     R1,R1,#+1
   \   00000016   0x0049             LSLS     R1,R1,#+1
   \   00000018   0x6001             STR      R1,[R0, #+0]
    502            
    503            huart->Instance->CR1 = 0x0;
   \   0000001A   0x6821             LDR      R1,[R4, #+0]
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0x6008             STR      R0,[R1, #+0]
    504            huart->Instance->CR2 = 0x0;
   \   00000020   0x6821             LDR      R1,[R4, #+0]
   \   00000022   0x6048             STR      R0,[R1, #+4]
    505            huart->Instance->CR3 = 0x0;
   \   00000024   0x6821             LDR      R1,[R4, #+0]
   \   00000026   0x6088             STR      R0,[R1, #+8]
    506            
    507            /* DeInit the low level hardware */
    508            HAL_UART_MspDeInit(huart);
   \   00000028   0x4620             MOV      R0,R4
   \   0000002A   0x.... 0x....      BL       HAL_UART_MspDeInit
    509          
    510            huart->ErrorCode = HAL_UART_ERROR_NONE;
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0x66E0             STR      R0,[R4, #+108]
    511            huart->State = HAL_UART_STATE_RESET;
   \   00000032   0xF884 0x0069      STRB     R0,[R4, #+105]
    512            
    513            /* Process Unlock */
    514            __HAL_UNLOCK(huart);
   \   00000036   0xF884 0x0068      STRB     R0,[R4, #+104]
    515            
    516            return HAL_OK;
   \   0000003A   0xBD10             POP      {R4,PC}          ;; return
    517          }
    518          
    519          /**
    520            * @brief UART MSP Init
    521            * @param huart: uart handle
    522            * @retval None
    523            */

   \                                 In section .text, align 2, keep-with-next
    524           __weak void HAL_UART_MspInit(UART_HandleTypeDef *huart)
    525          {
    526            /* Prevent unused argument(s) compilation warning */
    527            UNUSED(huart);
    528           
    529            /* NOTE : This function should not be modified, when the callback is needed,
    530                      the HAL_UART_MspInit can be implemented in the user file
    531             */ 
    532          }
   \                     HAL_UART_MspInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    533          
    534          /**
    535            * @brief UART MSP DeInit
    536            * @param huart: uart handle
    537            * @retval None
    538            */

   \                                 In section .text, align 2, keep-with-next
    539           __weak void HAL_UART_MspDeInit(UART_HandleTypeDef *huart)
    540          {
    541            /* Prevent unused argument(s) compilation warning */
    542            UNUSED(huart);
    543           
    544            /* NOTE : This function should not be modified, when the callback is needed,
    545                      the HAL_UART_MspDeInit can be implemented in the user file
    546             */ 
    547          }
   \                     HAL_UART_MspDeInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    548          
    549          /**
    550            * @}
    551            */
    552          
    553          /** @defgroup UART_Exported_Functions_Group2 IO operation functions 
    554            *  @brief UART Transmit/Receive functions 
    555            *
    556          @verbatim   
    557           ===============================================================================
    558                                ##### IO operation functions #####
    559           ===============================================================================
    560              This subsection provides a set of functions allowing to manage the UART asynchronous
    561              and Half duplex data transfers.
    562          
    563              (#) There are two mode of transfer:
    564                 (+) Blocking mode: The communication is performed in polling mode. 
    565                      The HAL status of all data processing is returned by the same function 
    566                      after finishing transfer.  
    567                 (+) No-Blocking mode: The communication is performed using Interrupts 
    568                     or DMA, These API's return the HAL status.
    569                     The end of the data processing will be indicated through the 
    570                     dedicated UART IRQ when using Interrupt mode or the DMA IRQ when 
    571                     using DMA mode.
    572                     The HAL_UART_TxCpltCallback(), HAL_UART_RxCpltCallback() user callbacks 
    573                     will be executed respectively at the end of the transmit or Receive process
    574                     The HAL_UART_ErrorCallback()user callback will be executed when a communication error is detected
    575          
    576              (#) Blocking mode API's are :
    577                  (+) HAL_UART_Transmit()
    578                  (+) HAL_UART_Receive() 
    579                  
    580              (#) Non-Blocking mode API's with Interrupt are :
    581                  (+) HAL_UART_Transmit_IT()
    582                  (+) HAL_UART_Receive_IT()
    583                  (+) HAL_UART_IRQHandler()
    584                  (+) UART_Transmit_IT()
    585                  (+) UART_Receive_IT()
    586          
    587              (#) No-Blocking mode API's with DMA are :
    588                  (+) HAL_UART_Transmit_DMA()
    589                  (+) HAL_UART_Receive_DMA()
    590                  (+) HAL_UART_DMAPause()
    591                  (+) HAL_UART_DMAResume()
    592                  (+) HAL_UART_DMAStop()
    593          
    594              (#) A set of Transfer Complete Callbacks are provided in No_Blocking mode:
    595                  (+) HAL_UART_TxHalfCpltCallback()
    596                  (+) HAL_UART_TxCpltCallback()
    597                  (+) HAL_UART_RxHalfCpltCallback()
    598                  (+) HAL_UART_RxCpltCallback()
    599                  (+) HAL_UART_ErrorCallback()
    600          
    601          
    602              -@- In the Half duplex communication, it is forbidden to run the transmit 
    603                  and receive process in parallel, the UART state HAL_UART_STATE_BUSY_TX_RX can't be useful.
    604          
    605          @endverbatim
    606            * @{
    607            */
    608          
    609          /**
    610            * @brief Send an amount of data in blocking mode 
    611            * @param huart: uart handle
    612            * @param pData: pointer to data buffer
    613            * @param Size: amount of data to be sent
    614            * @param Timeout : Timeout duration
    615            * @retval HAL status
    616            */

   \                                 In section .text, align 2, keep-with-next
    617          HAL_StatusTypeDef HAL_UART_Transmit(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size, uint32_t Timeout)
    618          {
   \                     HAL_UART_Transmit: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0xB081             SUB      SP,SP,#+4
   \   00000006   0x460E             MOV      R6,R1
   \   00000008   0x461D             MOV      R5,R3
    619             uint16_t* tmp;
    620          
    621            if((huart->State == HAL_UART_STATE_READY) || (huart->State == HAL_UART_STATE_BUSY_RX))
   \   0000000A   0xF894 0x0069      LDRB     R0,[R4, #+105]
   \   0000000E   0x2801             CMP      R0,#+1
   \   00000010   0xBF1C             ITT      NE 
   \   00000012   0xF894 0x0069      LDRBNE   R0,[R4, #+105]
   \   00000016   0x2822             CMPNE    R0,#+34
   \   00000018   0xD17C             BNE.N    ??HAL_UART_Transmit_0
    622            {
    623              if((pData == NULL ) || (Size == 0))
   \   0000001A   0x2E00             CMP      R6,#+0
   \   0000001C   0xBF14             ITE      NE 
   \   0000001E   0x2A00             CMPNE    R2,#+0
   \   00000020   0x2001             MOVEQ    R0,#+1
    624              {
    625                return  HAL_ERROR;
   \   00000022   0xD078             BEQ.N    ??HAL_UART_Transmit_1
    626              }
    627          
    628              /* Process Locked */
    629              __HAL_LOCK(huart);
   \   00000024   0xF894 0x0068      LDRB     R0,[R4, #+104]
   \   00000028   0x2801             CMP      R0,#+1
   \   0000002A   0xD073             BEQ.N    ??HAL_UART_Transmit_0
   \   0000002C   0x2001             MOVS     R0,#+1
   \   0000002E   0xF884 0x0068      STRB     R0,[R4, #+104]
    630          
    631              huart->ErrorCode = HAL_UART_ERROR_NONE;
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0x66E0             STR      R0,[R4, #+108]
    632              /* Check if a non-blocking receive process is ongoing or not */
    633              if(huart->State == HAL_UART_STATE_BUSY_RX) 
   \   00000036   0xF894 0x0069      LDRB     R0,[R4, #+105]
   \   0000003A   0x2822             CMP      R0,#+34
   \   0000003C   0xBF0C             ITE      EQ 
   \   0000003E   0x2032             MOVEQ    R0,#+50
   \   00000040   0x2012             MOVNE    R0,#+18
    634              {
    635                huart->State = HAL_UART_STATE_BUSY_TX_RX;
    636              }
    637              else
    638              {
    639                huart->State = HAL_UART_STATE_BUSY_TX;
   \   00000042   0xF884 0x0069      STRB     R0,[R4, #+105]
    640              }
    641          
    642              huart->TxXferSize = Size;
   \   00000046   0xF8A4 0x2050      STRH     R2,[R4, #+80]
    643              huart->TxXferCount = Size;
   \   0000004A   0xF8A4 0x2052      STRH     R2,[R4, #+82]
   \   0000004E   0xE000             B.N      ??HAL_UART_Transmit_2
    644              while(huart->TxXferCount > 0)
    645              {
    646                huart->TxXferCount--;
    647                  if(UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, Timeout) != HAL_OK)  
    648                  { 
    649                    return HAL_TIMEOUT;
    650                  }
    651                if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
    652                {
    653                  tmp = (uint16_t*) pData;
    654                  huart->Instance->TDR = (*tmp & (uint16_t)0x01FF);
   \                     ??HAL_UART_Transmit_3: (+1)
   \   00000050   0x6281             STR      R1,[R0, #+40]
    655                  pData += 2;
   \                     ??HAL_UART_Transmit_2: (+1)
   \   00000052   0xF8B4 0x0052      LDRH     R0,[R4, #+82]
   \   00000056   0x2800             CMP      R0,#+0
   \   00000058   0xD03D             BEQ.N    ??HAL_UART_Transmit_4
   \   0000005A   0x1E40             SUBS     R0,R0,#+1
   \   0000005C   0xF8A4 0x0052      STRH     R0,[R4, #+82]
   \   00000060   0x.... 0x....      BL       HAL_GetTick
   \   00000064   0x4607             MOV      R7,R0
   \                     ??HAL_UART_Transmit_5: (+1)
   \   00000066   0x6820             LDR      R0,[R4, #+0]
   \   00000068   0x69C1             LDR      R1,[R0, #+28]
   \   0000006A   0x0609             LSLS     R1,R1,#+24
   \   0000006C   0xD425             BMI.N    ??HAL_UART_Transmit_6
   \   0000006E   0xF115 0x0F01      CMN      R5,#+1
   \   00000072   0xD0F8             BEQ.N    ??HAL_UART_Transmit_5
   \   00000074   0xB125             CBZ.N    R5,??HAL_UART_Transmit_7
   \   00000076   0x.... 0x....      BL       HAL_GetTick
   \   0000007A   0x1BC0             SUBS     R0,R0,R7
   \   0000007C   0x42A8             CMP      R0,R5
   \   0000007E   0xD3F2             BCC.N    ??HAL_UART_Transmit_5
   \                     ??HAL_UART_Transmit_7: (+1)
   \   00000080   0x6820             LDR      R0,[R4, #+0]
   \   00000082   0x6801             LDR      R1,[R0, #+0]
   \   00000084   0xF021 0x0180      BIC      R1,R1,#0x80
   \   00000088   0x6001             STR      R1,[R0, #+0]
   \   0000008A   0x6820             LDR      R0,[R4, #+0]
   \   0000008C   0x6801             LDR      R1,[R0, #+0]
   \   0000008E   0xF021 0x0120      BIC      R1,R1,#0x20
   \   00000092   0x6001             STR      R1,[R0, #+0]
   \   00000094   0x6820             LDR      R0,[R4, #+0]
   \   00000096   0x6801             LDR      R1,[R0, #+0]
   \   00000098   0xF421 0x7180      BIC      R1,R1,#0x100
   \   0000009C   0x6001             STR      R1,[R0, #+0]
   \   0000009E   0x6820             LDR      R0,[R4, #+0]
   \   000000A0   0x6881             LDR      R1,[R0, #+8]
   \   000000A2   0x0849             LSRS     R1,R1,#+1
   \   000000A4   0x0049             LSLS     R1,R1,#+1
   \   000000A6   0x6081             STR      R1,[R0, #+8]
   \   000000A8   0x2001             MOVS     R0,#+1
   \   000000AA   0xF884 0x0069      STRB     R0,[R4, #+105]
   \   000000AE   0x2000             MOVS     R0,#+0
   \   000000B0   0xF884 0x0068      STRB     R0,[R4, #+104]
    656                }
    657                else
    658                {
    659                  huart->Instance->TDR = (*pData++ & (uint8_t)0xFF);
    660                }
    661              }
    662              if(UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TC, RESET, Timeout) != HAL_OK)  
    663              { 
    664                return HAL_TIMEOUT;
   \   000000B4   0x2003             MOVS     R0,#+3
   \   000000B6   0xB001             ADD      SP,SP,#+4
   \   000000B8   0xBDF0             POP      {R4-R7,PC}
    665              }
   \                     ??HAL_UART_Transmit_6: (+1)
   \   000000BA   0x68A1             LDR      R1,[R4, #+8]
   \   000000BC   0xF5B1 0x5F80      CMP      R1,#+4096
   \   000000C0   0xBF04             ITT      EQ 
   \   000000C2   0x6921             LDREQ    R1,[R4, #+16]
   \   000000C4   0x2900             CMPEQ    R1,#+0
   \   000000C6   0xBF11             ITEEE    NE 
   \   000000C8   0xF816 0x1B01      LDRBNE   R1,[R6], #+1
   \   000000CC   0xF836 0x1B02      LDRHEQ   R1,[R6], #+2
   \   000000D0   0x05C9             LSLEQ    R1,R1,#+23
   \   000000D2   0x0DC9             LSREQ    R1,R1,#+23
   \   000000D4   0xE7BC             B.N      ??HAL_UART_Transmit_3
   \                     ??HAL_UART_Transmit_4: (+1)
   \   000000D6   0x.... 0x....      BL       HAL_GetTick
   \   000000DA   0x4606             MOV      R6,R0
   \                     ??HAL_UART_Transmit_8: (+1)
   \   000000DC   0x6820             LDR      R0,[R4, #+0]
   \   000000DE   0x69C0             LDR      R0,[R0, #+28]
   \   000000E0   0x0640             LSLS     R0,R0,#+25
   \   000000E2   0xD40A             BMI.N    ??HAL_UART_Transmit_9
   \   000000E4   0xF115 0x0F01      CMN      R5,#+1
   \   000000E8   0xD0F8             BEQ.N    ??HAL_UART_Transmit_8
   \   000000EA   0x2D00             CMP      R5,#+0
   \   000000EC   0xD0C8             BEQ.N    ??HAL_UART_Transmit_7
   \   000000EE   0x.... 0x....      BL       HAL_GetTick
   \   000000F2   0x1B80             SUBS     R0,R0,R6
   \   000000F4   0x42A8             CMP      R0,R5
   \   000000F6   0xD3F1             BCC.N    ??HAL_UART_Transmit_8
   \   000000F8   0xE7C2             B.N      ??HAL_UART_Transmit_7
    666              /* Check if a non-blocking receive Process is ongoing or not */
    667              if(huart->State == HAL_UART_STATE_BUSY_TX_RX) 
   \                     ??HAL_UART_Transmit_9: (+1)
   \   000000FA   0xF894 0x0069      LDRB     R0,[R4, #+105]
   \   000000FE   0x2832             CMP      R0,#+50
   \   00000100   0xBF0C             ITE      EQ 
   \   00000102   0x2022             MOVEQ    R0,#+34
   \   00000104   0x2001             MOVNE    R0,#+1
    668              {
    669                huart->State = HAL_UART_STATE_BUSY_RX;
    670              }
    671              else
    672              {
    673                huart->State = HAL_UART_STATE_READY;
   \   00000106   0xF884 0x0069      STRB     R0,[R4, #+105]
    674              }
    675          
    676              /* Process Unlocked */
    677              __HAL_UNLOCK(huart);
   \   0000010A   0x2000             MOVS     R0,#+0
   \   0000010C   0xF884 0x0068      STRB     R0,[R4, #+104]
    678          
    679              return HAL_OK;
   \   00000110   0xB001             ADD      SP,SP,#+4
   \   00000112   0xBDF0             POP      {R4-R7,PC}
    680            }
    681            else
    682            {
    683              return HAL_BUSY;
   \                     ??HAL_UART_Transmit_0: (+1)
   \   00000114   0x2002             MOVS     R0,#+2
   \                     ??HAL_UART_Transmit_1: (+1)
   \   00000116   0xB001             ADD      SP,SP,#+4
   \   00000118   0xBDF0             POP      {R4-R7,PC}       ;; return
    684            }
    685          }
    686          
    687          /**
    688            * @brief Receive an amount of data in blocking mode 
    689            * @param huart: uart handle
    690            * @param pData: pointer to data buffer
    691            * @param Size: amount of data to be received
    692            * @param Timeout : Timeout duration
    693            * @retval HAL status
    694            */

   \                                 In section .text, align 2, keep-with-next
    695          HAL_StatusTypeDef HAL_UART_Receive(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size, uint32_t Timeout)
    696          {
   \                     HAL_UART_Receive: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
   \   00000008   0x461E             MOV      R6,R3
    697            uint16_t* tmp;
    698            uint16_t uhMask;
    699          
    700            if((huart->State == HAL_UART_STATE_READY) || (huart->State == HAL_UART_STATE_BUSY_TX))
   \   0000000A   0xF894 0x0069      LDRB     R0,[R4, #+105]
   \   0000000E   0x2801             CMP      R0,#+1
   \   00000010   0xBF1C             ITT      NE 
   \   00000012   0xF894 0x0069      LDRBNE   R0,[R4, #+105]
   \   00000016   0x2812             CMPNE    R0,#+18
   \   00000018   0xF040 0x808D      BNE.W    ??HAL_UART_Receive_0
    701            {
    702              if((pData == NULL ) || (Size == 0))
   \   0000001C   0x2D00             CMP      R5,#+0
   \   0000001E   0xBF14             ITE      NE 
   \   00000020   0x2A00             CMPNE    R2,#+0
   \   00000022   0x2001             MOVEQ    R0,#+1
    703              {
    704                return  HAL_ERROR;
   \   00000024   0xF000 0x8088      BEQ.W    ??HAL_UART_Receive_1
    705              }
    706          
    707              /* Process Locked */
    708              __HAL_LOCK(huart);
   \   00000028   0xF894 0x0068      LDRB     R0,[R4, #+104]
   \   0000002C   0x2801             CMP      R0,#+1
   \   0000002E   0xF000 0x8082      BEQ.W    ??HAL_UART_Receive_0
   \   00000032   0x2001             MOVS     R0,#+1
   \   00000034   0xF884 0x0068      STRB     R0,[R4, #+104]
    709          
    710              huart->ErrorCode = HAL_UART_ERROR_NONE;
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0x66E0             STR      R0,[R4, #+108]
    711              /* Check if a non-blocking transmit process is ongoing or not */
    712              if(huart->State == HAL_UART_STATE_BUSY_TX)
   \   0000003C   0xF894 0x0069      LDRB     R0,[R4, #+105]
   \   00000040   0x2812             CMP      R0,#+18
   \   00000042   0xBF0C             ITE      EQ 
   \   00000044   0x2032             MOVEQ    R0,#+50
   \   00000046   0x2022             MOVNE    R0,#+34
    713              {
    714                huart->State = HAL_UART_STATE_BUSY_TX_RX;
    715              }
    716              else
    717              {
    718                huart->State = HAL_UART_STATE_BUSY_RX;
   \   00000048   0xF884 0x0069      STRB     R0,[R4, #+105]
    719              }
    720          
    721              huart->RxXferSize = Size; 
    722              huart->RxXferCount = Size;
    723          
    724              /* Computation of UART mask to apply to RDR register */
    725              UART_MASK_COMPUTATION(huart);
   \   0000004C   0x68A0             LDR      R0,[R4, #+8]
   \   0000004E   0xF8A4 0x2058      STRH     R2,[R4, #+88]
   \   00000052   0xF5B0 0x5F80      CMP      R0,#+4096
   \   00000056   0xF8A4 0x205A      STRH     R2,[R4, #+90]
   \   0000005A   0xD106             BNE.N    ??HAL_UART_Receive_2
   \   0000005C   0x6920             LDR      R0,[R4, #+16]
   \   0000005E   0x2800             CMP      R0,#+0
   \   00000060   0xBF14             ITE      NE 
   \   00000062   0x20FF             MOVNE    R0,#+255
   \   00000064   0xF240 0x10FF      MOVWEQ   R0,#+511
   \   00000068   0xE00E             B.N      ??HAL_UART_Receive_3
   \                     ??HAL_UART_Receive_2: (+1)
   \   0000006A   0xB928             CBNZ.N   R0,??HAL_UART_Receive_4
   \   0000006C   0x6920             LDR      R0,[R4, #+16]
   \   0000006E   0x2800             CMP      R0,#+0
   \   00000070   0xBF14             ITE      NE 
   \   00000072   0x207F             MOVNE    R0,#+127
   \   00000074   0x20FF             MOVEQ    R0,#+255
   \   00000076   0xE007             B.N      ??HAL_UART_Receive_3
   \                     ??HAL_UART_Receive_4: (+1)
   \   00000078   0xF1B0 0x5F80      CMP      R0,#+268435456
   \   0000007C   0xD106             BNE.N    ??HAL_UART_Receive_5
   \   0000007E   0x6920             LDR      R0,[R4, #+16]
   \   00000080   0x2800             CMP      R0,#+0
   \   00000082   0xBF0C             ITE      EQ 
   \   00000084   0x207F             MOVEQ    R0,#+127
   \   00000086   0x203F             MOVNE    R0,#+63
   \                     ??HAL_UART_Receive_3: (+1)
   \   00000088   0xF8A4 0x005C      STRH     R0,[R4, #+92]
    726              uhMask = huart->Mask;
   \                     ??HAL_UART_Receive_5: (+1)
   \   0000008C   0xF8B4 0x705C      LDRH     R7,[R4, #+92]
   \   00000090   0xE003             B.N      ??HAL_UART_Receive_6
    727          
    728              /* as long as data have to be received */
    729              while(huart->RxXferCount > 0)
    730              {
    731                huart->RxXferCount--;
    732                  if(UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_RXNE, RESET, Timeout) != HAL_OK)  
    733                  {
    734                    return HAL_TIMEOUT;
    735                  }
    736                if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
    737                {
    738                  tmp = (uint16_t*) pData ;
    739                  *tmp = (uint16_t)(huart->Instance->RDR & uhMask);
   \                     ??HAL_UART_Receive_7: (+1)
   \   00000092   0x6A40             LDR      R0,[R0, #+36]
   \   00000094   0x4038             ANDS     R0,R7,R0
   \   00000096   0xF825 0x0B02      STRH     R0,[R5], #+2
    740                  pData +=2; 
    741                }
   \                     ??HAL_UART_Receive_6: (+1)
   \   0000009A   0xF8B4 0x005A      LDRH     R0,[R4, #+90]
   \   0000009E   0x2800             CMP      R0,#+0
   \   000000A0   0xD03C             BEQ.N    ??HAL_UART_Receive_8
   \   000000A2   0x1E40             SUBS     R0,R0,#+1
   \   000000A4   0xF8A4 0x005A      STRH     R0,[R4, #+90]
   \   000000A8   0x.... 0x....      BL       HAL_GetTick
   \   000000AC   0x4680             MOV      R8,R0
   \                     ??HAL_UART_Receive_9: (+1)
   \   000000AE   0x6820             LDR      R0,[R4, #+0]
   \   000000B0   0x69C1             LDR      R1,[R0, #+28]
   \   000000B2   0x0689             LSLS     R1,R1,#+26
   \   000000B4   0xD426             BMI.N    ??HAL_UART_Receive_10
   \   000000B6   0xF116 0x0F01      CMN      R6,#+1
   \   000000BA   0xD0F8             BEQ.N    ??HAL_UART_Receive_9
   \   000000BC   0xB12E             CBZ.N    R6,??HAL_UART_Receive_11
   \   000000BE   0x.... 0x....      BL       HAL_GetTick
   \   000000C2   0xEBA0 0x0008      SUB      R0,R0,R8
   \   000000C6   0x42B0             CMP      R0,R6
   \   000000C8   0xD3F1             BCC.N    ??HAL_UART_Receive_9
   \                     ??HAL_UART_Receive_11: (+1)
   \   000000CA   0x6820             LDR      R0,[R4, #+0]
   \   000000CC   0x6801             LDR      R1,[R0, #+0]
   \   000000CE   0xF021 0x0180      BIC      R1,R1,#0x80
   \   000000D2   0x6001             STR      R1,[R0, #+0]
   \   000000D4   0x6820             LDR      R0,[R4, #+0]
   \   000000D6   0x6801             LDR      R1,[R0, #+0]
   \   000000D8   0xF021 0x0120      BIC      R1,R1,#0x20
   \   000000DC   0x6001             STR      R1,[R0, #+0]
   \   000000DE   0x6820             LDR      R0,[R4, #+0]
   \   000000E0   0x6801             LDR      R1,[R0, #+0]
   \   000000E2   0xF421 0x7180      BIC      R1,R1,#0x100
   \   000000E6   0x6001             STR      R1,[R0, #+0]
   \   000000E8   0x6820             LDR      R0,[R4, #+0]
   \   000000EA   0x6881             LDR      R1,[R0, #+8]
   \   000000EC   0x0849             LSRS     R1,R1,#+1
   \   000000EE   0x0049             LSLS     R1,R1,#+1
   \   000000F0   0x6081             STR      R1,[R0, #+8]
   \   000000F2   0x2001             MOVS     R0,#+1
   \   000000F4   0xF884 0x0069      STRB     R0,[R4, #+105]
   \   000000F8   0x2000             MOVS     R0,#+0
   \   000000FA   0xF884 0x0068      STRB     R0,[R4, #+104]
   \   000000FE   0x2003             MOVS     R0,#+3
   \   00000100   0xE8BD 0x81F0      POP      {R4-R8,PC}
   \                     ??HAL_UART_Receive_10: (+1)
   \   00000104   0x68A1             LDR      R1,[R4, #+8]
   \   00000106   0xF5B1 0x5F80      CMP      R1,#+4096
   \   0000010A   0xBF04             ITT      EQ 
   \   0000010C   0x6921             LDREQ    R1,[R4, #+16]
   \   0000010E   0x2900             CMPEQ    R1,#+0
   \   00000110   0xD0BF             BEQ.N    ??HAL_UART_Receive_7
    742                else
    743                {
    744                  *pData++ = (uint8_t)(huart->Instance->RDR & (uint8_t)uhMask); 
   \   00000112   0x6A40             LDR      R0,[R0, #+36]
   \   00000114   0x4038             ANDS     R0,R7,R0
   \   00000116   0xF805 0x0B01      STRB     R0,[R5], #+1
   \   0000011A   0xE7BE             B.N      ??HAL_UART_Receive_6
    745                }
    746              }
    747          
    748              /* Check if a non-blocking transmit Process is ongoing or not */
    749              if(huart->State == HAL_UART_STATE_BUSY_TX_RX) 
   \                     ??HAL_UART_Receive_8: (+1)
   \   0000011C   0xF894 0x0069      LDRB     R0,[R4, #+105]
   \   00000120   0x2832             CMP      R0,#+50
   \   00000122   0xBF0C             ITE      EQ 
   \   00000124   0x2012             MOVEQ    R0,#+18
   \   00000126   0x2001             MOVNE    R0,#+1
    750              {
    751                huart->State = HAL_UART_STATE_BUSY_TX;
    752              }
    753              else
    754              {
    755                huart->State = HAL_UART_STATE_READY;
   \   00000128   0xF884 0x0069      STRB     R0,[R4, #+105]
    756              }
    757              /* Process Unlocked */
    758              __HAL_UNLOCK(huart);
   \   0000012C   0x2000             MOVS     R0,#+0
   \   0000012E   0xF884 0x0068      STRB     R0,[R4, #+104]
    759          
    760              return HAL_OK;
   \   00000132   0xE8BD 0x81F0      POP      {R4-R8,PC}
    761            }
    762            else
    763            {
    764              return HAL_BUSY;
   \                     ??HAL_UART_Receive_0: (+1)
   \   00000136   0x2002             MOVS     R0,#+2
   \                     ??HAL_UART_Receive_1: (+1)
   \   00000138   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    765            }
    766          }
    767          
    768          /**
    769            * @brief Send an amount of data in interrupt mode 
    770            * @param huart: uart handle
    771            * @param pData: pointer to data buffer
    772            * @param Size: amount of data to be sent
    773            * @retval HAL status
    774            */

   \                                 In section .text, align 2, keep-with-next
    775          HAL_StatusTypeDef HAL_UART_Transmit_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
    776          {  
    777            if((huart->State == HAL_UART_STATE_READY) || (huart->State == HAL_UART_STATE_BUSY_RX))
   \                     HAL_UART_Transmit_IT: (+1)
   \   00000000   0xF890 0x3069      LDRB     R3,[R0, #+105]
   \   00000004   0x2B01             CMP      R3,#+1
   \   00000006   0xBF1C             ITT      NE 
   \   00000008   0xF890 0x3069      LDRBNE   R3,[R0, #+105]
   \   0000000C   0x2B22             CMPNE    R3,#+34
   \   0000000E   0xD12A             BNE.N    ??HAL_UART_Transmit_IT_0
    778            {
    779              if((pData == NULL ) || (Size == 0)) 
   \   00000010   0x2900             CMP      R1,#+0
   \   00000012   0xBF18             IT       NE 
   \   00000014   0x2A00             CMPNE    R2,#+0
   \   00000016   0xD101             BNE.N    ??HAL_UART_Transmit_IT_1
    780              {
    781                return HAL_ERROR;
   \   00000018   0x2001             MOVS     R0,#+1
   \   0000001A   0x4770             BX       LR
    782              }
    783              
    784              /* Process Locked */
    785              __HAL_LOCK(huart);
   \                     ??HAL_UART_Transmit_IT_1: (+1)
   \   0000001C   0xF890 0x3068      LDRB     R3,[R0, #+104]
   \   00000020   0x2B01             CMP      R3,#+1
   \   00000022   0xD020             BEQ.N    ??HAL_UART_Transmit_IT_0
   \   00000024   0x2301             MOVS     R3,#+1
    786              
    787              huart->pTxBuffPtr = pData;
   \   00000026   0x64C1             STR      R1,[R0, #+76]
   \   00000028   0xF880 0x3068      STRB     R3,[R0, #+104]
    788              huart->TxXferSize = Size;
    789              huart->TxXferCount = Size;
    790              
    791              huart->ErrorCode = HAL_UART_ERROR_NONE;
   \   0000002C   0x2100             MOVS     R1,#+0
   \   0000002E   0xF8A0 0x2050      STRH     R2,[R0, #+80]
   \   00000032   0xF8A0 0x2052      STRH     R2,[R0, #+82]
   \   00000036   0x66C1             STR      R1,[R0, #+108]
    792              /* Check if a receive process is ongoing or not */
    793              if(huart->State == HAL_UART_STATE_BUSY_RX) 
   \   00000038   0xF890 0x1069      LDRB     R1,[R0, #+105]
   \   0000003C   0x2922             CMP      R1,#+34
   \   0000003E   0xBF0C             ITE      EQ 
   \   00000040   0x2132             MOVEQ    R1,#+50
   \   00000042   0x2112             MOVNE    R1,#+18
    794              {
    795                huart->State = HAL_UART_STATE_BUSY_TX_RX;
    796              }
    797              else
    798              {
    799                huart->State = HAL_UART_STATE_BUSY_TX;
   \   00000044   0xF880 0x1069      STRB     R1,[R0, #+105]
    800              }
    801              
    802              /* Enable the UART Error Interrupt: (Frame error, noise error, overrun error) */
    803              __HAL_UART_ENABLE_IT(huart, UART_IT_ERR);
   \   00000048   0x6801             LDR      R1,[R0, #+0]
   \   0000004A   0x688A             LDR      R2,[R1, #+8]
   \   0000004C   0xF042 0x0201      ORR      R2,R2,#0x1
   \   00000050   0x608A             STR      R2,[R1, #+8]
    804              
    805              /* Process Unlocked */
    806              __HAL_UNLOCK(huart);    
   \   00000052   0x2100             MOVS     R1,#+0
   \   00000054   0xF880 0x1068      STRB     R1,[R0, #+104]
    807              
    808              /* Enable the UART Transmit Data Register Empty Interrupt */
    809              __HAL_UART_ENABLE_IT(huart, UART_IT_TXE);
   \   00000058   0x6800             LDR      R0,[R0, #+0]
   \   0000005A   0x6801             LDR      R1,[R0, #+0]
   \   0000005C   0xF041 0x0180      ORR      R1,R1,#0x80
   \   00000060   0x6001             STR      R1,[R0, #+0]
    810              
    811              return HAL_OK;
   \   00000062   0x2000             MOVS     R0,#+0
   \   00000064   0x4770             BX       LR
    812            }
    813            else
    814            {
    815              return HAL_BUSY;   
   \                     ??HAL_UART_Transmit_IT_0: (+1)
   \   00000066   0x2002             MOVS     R0,#+2
   \   00000068   0x4770             BX       LR               ;; return
    816            }
    817          }
    818          
    819          /**
    820            * @brief Receive an amount of data in interrupt mode 
    821            * @param huart: uart handle
    822            * @param pData: pointer to data buffer
    823            * @param Size: amount of data to be received
    824            * @retval HAL status
    825            */

   \                                 In section .text, align 2, keep-with-next
    826          HAL_StatusTypeDef HAL_UART_Receive_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
    827          {
    828            if((huart->State == HAL_UART_STATE_READY) || (huart->State == HAL_UART_STATE_BUSY_TX))
   \                     HAL_UART_Receive_IT: (+1)
   \   00000000   0xF890 0x3069      LDRB     R3,[R0, #+105]
   \   00000004   0x2B01             CMP      R3,#+1
   \   00000006   0xBF1C             ITT      NE 
   \   00000008   0xF890 0x3069      LDRBNE   R3,[R0, #+105]
   \   0000000C   0x2B12             CMPNE    R3,#+18
   \   0000000E   0xD14B             BNE.N    ??HAL_UART_Receive_IT_0
    829            {
    830              if((pData == NULL ) || (Size == 0)) 
   \   00000010   0x2900             CMP      R1,#+0
   \   00000012   0xBF18             IT       NE 
   \   00000014   0x2A00             CMPNE    R2,#+0
   \   00000016   0xD101             BNE.N    ??HAL_UART_Receive_IT_1
    831              {
    832                return HAL_ERROR;
   \   00000018   0x2001             MOVS     R0,#+1
   \   0000001A   0x4770             BX       LR
    833              }
    834          
    835              /* Process Locked */
    836              __HAL_LOCK(huart);
   \                     ??HAL_UART_Receive_IT_1: (+1)
   \   0000001C   0xF890 0x3068      LDRB     R3,[R0, #+104]
   \   00000020   0x2B01             CMP      R3,#+1
   \   00000022   0xD041             BEQ.N    ??HAL_UART_Receive_IT_0
    837          
    838              huart->pRxBuffPtr = pData;
   \   00000024   0x6541             STR      R1,[R0, #+84]
   \   00000026   0x2301             MOVS     R3,#+1
    839              huart->RxXferSize = Size;
    840              huart->RxXferCount = Size;
    841          
    842              /* Computation of UART mask to apply to RDR register */
    843              UART_MASK_COMPUTATION(huart);
   \   00000028   0x6881             LDR      R1,[R0, #+8]
   \   0000002A   0xF880 0x3068      STRB     R3,[R0, #+104]
   \   0000002E   0xF8A0 0x2058      STRH     R2,[R0, #+88]
   \   00000032   0xF5B1 0x5F80      CMP      R1,#+4096
   \   00000036   0xF8A0 0x205A      STRH     R2,[R0, #+90]
   \   0000003A   0xD106             BNE.N    ??HAL_UART_Receive_IT_2
   \   0000003C   0x6901             LDR      R1,[R0, #+16]
   \   0000003E   0x2900             CMP      R1,#+0
   \   00000040   0xBF14             ITE      NE 
   \   00000042   0x21FF             MOVNE    R1,#+255
   \   00000044   0xF240 0x11FF      MOVWEQ   R1,#+511
   \   00000048   0xE00E             B.N      ??HAL_UART_Receive_IT_3
   \                     ??HAL_UART_Receive_IT_2: (+1)
   \   0000004A   0xB929             CBNZ.N   R1,??HAL_UART_Receive_IT_4
   \   0000004C   0x6901             LDR      R1,[R0, #+16]
   \   0000004E   0x2900             CMP      R1,#+0
   \   00000050   0xBF14             ITE      NE 
   \   00000052   0x217F             MOVNE    R1,#+127
   \   00000054   0x21FF             MOVEQ    R1,#+255
   \   00000056   0xE007             B.N      ??HAL_UART_Receive_IT_3
   \                     ??HAL_UART_Receive_IT_4: (+1)
   \   00000058   0xF1B1 0x5F80      CMP      R1,#+268435456
   \   0000005C   0xD106             BNE.N    ??HAL_UART_Receive_IT_5
   \   0000005E   0x6901             LDR      R1,[R0, #+16]
   \   00000060   0x2900             CMP      R1,#+0
   \   00000062   0xBF0C             ITE      EQ 
   \   00000064   0x217F             MOVEQ    R1,#+127
   \   00000066   0x213F             MOVNE    R1,#+63
   \                     ??HAL_UART_Receive_IT_3: (+1)
   \   00000068   0xF8A0 0x105C      STRH     R1,[R0, #+92]
    844          
    845              huart->ErrorCode = HAL_UART_ERROR_NONE;
   \                     ??HAL_UART_Receive_IT_5: (+1)
   \   0000006C   0x2100             MOVS     R1,#+0
   \   0000006E   0x66C1             STR      R1,[R0, #+108]
    846              /* Check if a transmit process is ongoing or not */
    847              if(huart->State == HAL_UART_STATE_BUSY_TX) 
   \   00000070   0xF890 0x1069      LDRB     R1,[R0, #+105]
   \   00000074   0x2912             CMP      R1,#+18
   \   00000076   0xBF0C             ITE      EQ 
   \   00000078   0x2132             MOVEQ    R1,#+50
   \   0000007A   0x2122             MOVNE    R1,#+34
    848              {
    849                huart->State = HAL_UART_STATE_BUSY_TX_RX;
    850              }
    851              else
    852              {
    853                huart->State = HAL_UART_STATE_BUSY_RX;
   \   0000007C   0xF880 0x1069      STRB     R1,[R0, #+105]
    854              }
    855          
    856              /* Enable the UART Parity Error Interrupt */
    857              __HAL_UART_ENABLE_IT(huart, UART_IT_PE);
   \   00000080   0x6801             LDR      R1,[R0, #+0]
   \   00000082   0x680A             LDR      R2,[R1, #+0]
   \   00000084   0xF442 0x7280      ORR      R2,R2,#0x100
   \   00000088   0x600A             STR      R2,[R1, #+0]
    858          
    859              /* Enable the UART Error Interrupt: (Frame error, noise error, overrun error) */
    860              __HAL_UART_ENABLE_IT(huart, UART_IT_ERR);
   \   0000008A   0x6801             LDR      R1,[R0, #+0]
   \   0000008C   0x688A             LDR      R2,[R1, #+8]
   \   0000008E   0xF042 0x0201      ORR      R2,R2,#0x1
   \   00000092   0x608A             STR      R2,[R1, #+8]
    861          
    862              /* Process Unlocked */
    863              __HAL_UNLOCK(huart);
   \   00000094   0x2100             MOVS     R1,#+0
   \   00000096   0xF880 0x1068      STRB     R1,[R0, #+104]
    864          
    865              /* Enable the UART Data Register not empty Interrupt */
    866              __HAL_UART_ENABLE_IT(huart, UART_IT_RXNE);
   \   0000009A   0x6800             LDR      R0,[R0, #+0]
   \   0000009C   0x6801             LDR      R1,[R0, #+0]
   \   0000009E   0xF041 0x0120      ORR      R1,R1,#0x20
   \   000000A2   0x6001             STR      R1,[R0, #+0]
    867          
    868              return HAL_OK;
   \   000000A4   0x2000             MOVS     R0,#+0
   \   000000A6   0x4770             BX       LR
    869            }
    870            else
    871            {
    872              return HAL_BUSY; 
   \                     ??HAL_UART_Receive_IT_0: (+1)
   \   000000A8   0x2002             MOVS     R0,#+2
   \   000000AA   0x4770             BX       LR               ;; return
    873            }
    874          }
    875          
    876          /**
    877            * @brief Send an amount of data in DMA mode 
    878            * @param huart: uart handle
    879            * @param pData: pointer to data buffer
    880            * @param Size: amount of data to be sent
    881            * @retval HAL status
    882            */

   \                                 In section .text, align 2, keep-with-next
    883          HAL_StatusTypeDef HAL_UART_Transmit_DMA(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
    884          {
   \                     HAL_UART_Transmit_DMA: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    885            uint32_t *tmp;
    886            
    887            if((huart->State == HAL_UART_STATE_READY) || (huart->State == HAL_UART_STATE_BUSY_RX))
   \   00000004   0xF894 0x0069      LDRB     R0,[R4, #+105]
   \   00000008   0x2801             CMP      R0,#+1
   \   0000000A   0xBF1C             ITT      NE 
   \   0000000C   0xF894 0x0069      LDRBNE   R0,[R4, #+105]
   \   00000010   0x2822             CMPNE    R0,#+34
   \   00000012   0xD13A             BNE.N    ??HAL_UART_Transmit_DMA_0
    888            {
    889              if((pData == NULL ) || (Size == 0)) 
   \   00000014   0x2900             CMP      R1,#+0
   \   00000016   0xBF18             IT       NE 
   \   00000018   0x2A00             CMPNE    R2,#+0
   \   0000001A   0xD101             BNE.N    ??HAL_UART_Transmit_DMA_1
    890              {
    891                return HAL_ERROR;
   \   0000001C   0x2001             MOVS     R0,#+1
   \   0000001E   0xBD10             POP      {R4,PC}
    892              }
    893              
    894              /* Process Locked */
    895              __HAL_LOCK(huart);
   \                     ??HAL_UART_Transmit_DMA_1: (+1)
   \   00000020   0xF894 0x0068      LDRB     R0,[R4, #+104]
   \   00000024   0x2801             CMP      R0,#+1
   \   00000026   0xD030             BEQ.N    ??HAL_UART_Transmit_DMA_0
   \   00000028   0x2001             MOVS     R0,#+1
    896              
    897              huart->pTxBuffPtr = pData;
   \   0000002A   0x64E1             STR      R1,[R4, #+76]
   \   0000002C   0xF884 0x0068      STRB     R0,[R4, #+104]
    898              huart->TxXferSize = Size;
    899              huart->TxXferCount = Size; 
    900              
    901              huart->ErrorCode = HAL_UART_ERROR_NONE;
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0xF8A4 0x2050      STRH     R2,[R4, #+80]
   \   00000036   0xF8A4 0x2052      STRH     R2,[R4, #+82]
   \   0000003A   0x66E0             STR      R0,[R4, #+108]
    902              /* Check if a receive process is ongoing or not */
    903              if(huart->State == HAL_UART_STATE_BUSY_RX) 
   \   0000003C   0xF894 0x0069      LDRB     R0,[R4, #+105]
   \   00000040   0x2822             CMP      R0,#+34
   \   00000042   0xBF0C             ITE      EQ 
   \   00000044   0x2032             MOVEQ    R0,#+50
   \   00000046   0x2012             MOVNE    R0,#+18
    904              {
    905                huart->State = HAL_UART_STATE_BUSY_TX_RX;
    906              }
    907              else
    908              {
    909                huart->State = HAL_UART_STATE_BUSY_TX;
   \   00000048   0xF884 0x0069      STRB     R0,[R4, #+105]
    910              }
    911              
    912              /* Set the UART DMA transfer complete callback */
    913              huart->hdmatx->XferCpltCallback = UART_DMATransmitCplt;
   \   0000004C   0x6E23             LDR      R3,[R4, #+96]
   \   0000004E   0x.... 0x....      ADR.W    R0,UART_DMATransmitCplt
   \   00000052   0x63D8             STR      R0,[R3, #+60]
    914              
    915              /* Set the UART DMA Half transfer complete callback */
    916              huart->hdmatx->XferHalfCpltCallback = UART_DMATxHalfCplt;
   \   00000054   0x6E23             LDR      R3,[R4, #+96]
   \   00000056   0x.... 0x....      ADR.W    R0,UART_DMATxHalfCplt
   \   0000005A   0x6418             STR      R0,[R3, #+64]
    917              
    918              /* Set the DMA error callback */
    919              huart->hdmatx->XferErrorCallback = UART_DMAError;
   \   0000005C   0x6E23             LDR      R3,[R4, #+96]
   \   0000005E   0x.... 0x....      ADR.W    R0,UART_DMAError
   \   00000062   0x6498             STR      R0,[R3, #+72]
    920          
    921              /* Enable the UART transmit DMA channel */
    922              tmp = (uint32_t*)&pData;
    923              HAL_DMA_Start_IT(huart->hdmatx, *(uint32_t*)tmp, (uint32_t)&huart->Instance->TDR, Size);
   \   00000064   0x6820             LDR      R0,[R4, #+0]
   \   00000066   0x4613             MOV      R3,R2
   \   00000068   0xF100 0x0228      ADD      R2,R0,#+40
   \   0000006C   0x6E20             LDR      R0,[R4, #+96]
   \   0000006E   0x.... 0x....      BL       HAL_DMA_Start_IT
    924          
    925              /* Clear the TC flag in the SR register by writing 0 to it */
    926              __HAL_UART_CLEAR_IT(huart, UART_FLAG_TC);
   \   00000072   0x6821             LDR      R1,[R4, #+0]
   \   00000074   0x2040             MOVS     R0,#+64
   \   00000076   0x6208             STR      R0,[R1, #+32]
    927          
    928              
    929              /* Enable the DMA transfer for transmit request by setting the DMAT bit
    930                 in the UART CR3 register */
    931              huart->Instance->CR3 |= USART_CR3_DMAT;
   \   00000078   0x6820             LDR      R0,[R4, #+0]
   \   0000007A   0x6881             LDR      R1,[R0, #+8]
   \   0000007C   0xF041 0x0180      ORR      R1,R1,#0x80
   \   00000080   0x6081             STR      R1,[R0, #+8]
    932              
    933              /* Process Unlocked */
    934              __HAL_UNLOCK(huart);
   \   00000082   0x2000             MOVS     R0,#+0
   \   00000084   0xF884 0x0068      STRB     R0,[R4, #+104]
    935              
    936              return HAL_OK;
   \   00000088   0xBD10             POP      {R4,PC}
    937            }
    938            else
    939            {
    940              return HAL_BUSY;   
   \                     ??HAL_UART_Transmit_DMA_0: (+1)
   \   0000008A   0x2002             MOVS     R0,#+2
   \   0000008C   0xBD10             POP      {R4,PC}          ;; return
    941            }
    942          }
    943          
    944          /**
    945            * @brief Receive an amount of data in DMA mode 
    946            * @param huart: uart handle
    947            * @param pData: pointer to data buffer
    948            * @param Size: amount of data to be received
    949            * @note   When the UART parity is enabled (PCE = 1), the received data contain 
    950            *         the parity bit (MSB position)     
    951            * @retval HAL status
    952            */

   \                                 In section .text, align 2, keep-with-next
    953          HAL_StatusTypeDef HAL_UART_Receive_DMA(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
    954          {
   \                     HAL_UART_Receive_DMA: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    955            uint32_t *tmp;
    956            
    957            if((huart->State == HAL_UART_STATE_READY) || (huart->State == HAL_UART_STATE_BUSY_TX))
   \   00000004   0xF894 0x0069      LDRB     R0,[R4, #+105]
   \   00000008   0x2801             CMP      R0,#+1
   \   0000000A   0xBF1C             ITT      NE 
   \   0000000C   0xF894 0x0069      LDRBNE   R0,[R4, #+105]
   \   00000010   0x2812             CMPNE    R0,#+18
   \   00000012   0xD136             BNE.N    ??HAL_UART_Receive_DMA_0
    958            {
    959              if((pData == NULL ) || (Size == 0)) 
   \   00000014   0x2900             CMP      R1,#+0
   \   00000016   0xBF18             IT       NE 
   \   00000018   0x2A00             CMPNE    R2,#+0
   \   0000001A   0xD101             BNE.N    ??HAL_UART_Receive_DMA_1
    960              {
    961                return HAL_ERROR;
   \   0000001C   0x2001             MOVS     R0,#+1
   \   0000001E   0xBD10             POP      {R4,PC}
    962              }
    963              
    964              /* Process Locked */
    965              __HAL_LOCK(huart);
   \                     ??HAL_UART_Receive_DMA_1: (+1)
   \   00000020   0xF894 0x0068      LDRB     R0,[R4, #+104]
   \   00000024   0x2801             CMP      R0,#+1
   \   00000026   0xD02C             BEQ.N    ??HAL_UART_Receive_DMA_0
   \   00000028   0x2001             MOVS     R0,#+1
    966              
    967              huart->pRxBuffPtr = pData;
   \   0000002A   0x6561             STR      R1,[R4, #+84]
   \   0000002C   0xF884 0x0068      STRB     R0,[R4, #+104]
    968              huart->RxXferSize = Size;
    969              
    970              huart->ErrorCode = HAL_UART_ERROR_NONE;
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0xF8A4 0x2058      STRH     R2,[R4, #+88]
   \   00000036   0x66E0             STR      R0,[R4, #+108]
    971              /* Check if a transmit process is ongoing or not */
    972              if(huart->State == HAL_UART_STATE_BUSY_TX) 
   \   00000038   0xF894 0x0069      LDRB     R0,[R4, #+105]
   \   0000003C   0x2812             CMP      R0,#+18
   \   0000003E   0xBF0C             ITE      EQ 
   \   00000040   0x2032             MOVEQ    R0,#+50
   \   00000042   0x2022             MOVNE    R0,#+34
    973              {
    974                huart->State = HAL_UART_STATE_BUSY_TX_RX;
    975              }
    976              else
    977              {
    978                huart->State = HAL_UART_STATE_BUSY_RX;
   \   00000044   0xF884 0x0069      STRB     R0,[R4, #+105]
    979              }
    980              
    981              /* Set the UART DMA transfer complete callback */
    982              huart->hdmarx->XferCpltCallback = UART_DMAReceiveCplt;
   \   00000048   0x6E63             LDR      R3,[R4, #+100]
   \   0000004A   0x.... 0x....      ADR.W    R0,UART_DMAReceiveCplt
   \   0000004E   0x63D8             STR      R0,[R3, #+60]
    983              
    984              /* Set the UART DMA Half transfer complete callback */
    985              huart->hdmarx->XferHalfCpltCallback = UART_DMARxHalfCplt;
   \   00000050   0x6E63             LDR      R3,[R4, #+100]
   \   00000052   0x.... 0x....      ADR.W    R0,UART_DMARxHalfCplt
   \   00000056   0x6418             STR      R0,[R3, #+64]
    986              
    987              /* Set the DMA error callback */
    988              huart->hdmarx->XferErrorCallback = UART_DMAError;
   \   00000058   0x6E63             LDR      R3,[R4, #+100]
   \   0000005A   0x.... 0x....      ADR.W    R0,UART_DMAError
   \   0000005E   0x6498             STR      R0,[R3, #+72]
    989          
    990              /* Enable the DMA channel */
    991              tmp = (uint32_t*)&pData;
    992              HAL_DMA_Start_IT(huart->hdmarx, (uint32_t)&huart->Instance->RDR, *(uint32_t*)tmp, Size);
   \   00000060   0x4613             MOV      R3,R2
   \   00000062   0x6820             LDR      R0,[R4, #+0]
   \   00000064   0x460A             MOV      R2,R1
   \   00000066   0xF100 0x0124      ADD      R1,R0,#+36
   \   0000006A   0x6E60             LDR      R0,[R4, #+100]
   \   0000006C   0x.... 0x....      BL       HAL_DMA_Start_IT
    993          
    994              /* Enable the DMA transfer for the receiver request by setting the DMAR bit 
    995                 in the UART CR3 register */
    996               huart->Instance->CR3 |= USART_CR3_DMAR;
   \   00000070   0x6820             LDR      R0,[R4, #+0]
   \   00000072   0x6881             LDR      R1,[R0, #+8]
   \   00000074   0xF041 0x0140      ORR      R1,R1,#0x40
   \   00000078   0x6081             STR      R1,[R0, #+8]
    997              
    998               /* Process Unlocked */
    999               __HAL_UNLOCK(huart);
   \   0000007A   0x2000             MOVS     R0,#+0
   \   0000007C   0xF884 0x0068      STRB     R0,[R4, #+104]
   1000               
   1001              return HAL_OK;
   \   00000080   0xBD10             POP      {R4,PC}
   1002            }
   1003            else
   1004            {
   1005              return HAL_BUSY; 
   \                     ??HAL_UART_Receive_DMA_0: (+1)
   \   00000082   0x2002             MOVS     R0,#+2
   \   00000084   0xBD10             POP      {R4,PC}          ;; return
   1006            }
   1007          }
   1008          
   1009          /**
   1010            * @brief Pauses the DMA Transfer.
   1011            * @param huart: UART handle
   1012            * @retval None
   1013            */

   \                                 In section .text, align 2, keep-with-next
   1014          HAL_StatusTypeDef HAL_UART_DMAPause(UART_HandleTypeDef *huart)
   1015          {
   1016            /* Process Locked */
   1017            __HAL_LOCK(huart);
   \                     HAL_UART_DMAPause: (+1)
   \   00000000   0xF890 0x1068      LDRB     R1,[R0, #+104]
   \   00000004   0x2901             CMP      R1,#+1
   \   00000006   0xD101             BNE.N    ??HAL_UART_DMAPause_0
   \   00000008   0x2002             MOVS     R0,#+2
   \   0000000A   0x4770             BX       LR
   \                     ??HAL_UART_DMAPause_0: (+1)
   \   0000000C   0x2101             MOVS     R1,#+1
   \   0000000E   0xF880 0x1068      STRB     R1,[R0, #+104]
   1018            
   1019            if(huart->State == HAL_UART_STATE_BUSY_TX)
   \   00000012   0xF890 0x1069      LDRB     R1,[R0, #+105]
   \   00000016   0x2912             CMP      R1,#+18
   \   00000018   0xD104             BNE.N    ??HAL_UART_DMAPause_1
   1020            {
   1021              /* Disable the UART DMA Tx request */
   1022              huart->Instance->CR3 &= (uint32_t)(~USART_CR3_DMAT);
   \   0000001A   0x6801             LDR      R1,[R0, #+0]
   \   0000001C   0x688A             LDR      R2,[R1, #+8]
   \   0000001E   0xF022 0x0280      BIC      R2,R2,#0x80
   \   00000022   0xE010             B.N      ??HAL_UART_DMAPause_2
   1023            }
   1024            else if(huart->State == HAL_UART_STATE_BUSY_RX)
   \                     ??HAL_UART_DMAPause_1: (+1)
   \   00000024   0xF890 0x1069      LDRB     R1,[R0, #+105]
   \   00000028   0x2922             CMP      R1,#+34
   \   0000002A   0xD008             BEQ.N    ??HAL_UART_DMAPause_3
   1025            {
   1026              /* Disable the UART DMA Rx request */
   1027              huart->Instance->CR3 &= (uint32_t)(~USART_CR3_DMAR);
   1028            }
   1029            else if(huart->State == HAL_UART_STATE_BUSY_TX_RX)
   \   0000002C   0xF890 0x1069      LDRB     R1,[R0, #+105]
   \   00000030   0x2932             CMP      R1,#+50
   \   00000032   0xD109             BNE.N    ??HAL_UART_DMAPause_4
   1030            {
   1031              /* Disable the UART DMA Tx request */
   1032              huart->Instance->CR3 &= (uint32_t)(~USART_CR3_DMAT);
   \   00000034   0x6801             LDR      R1,[R0, #+0]
   \   00000036   0x688A             LDR      R2,[R1, #+8]
   \   00000038   0xF022 0x0280      BIC      R2,R2,#0x80
   \   0000003C   0x608A             STR      R2,[R1, #+8]
   1033              /* Disable the UART DMA Rx request */
   1034              huart->Instance->CR3 &= (uint32_t)(~USART_CR3_DMAR);
   \                     ??HAL_UART_DMAPause_3: (+1)
   \   0000003E   0x6801             LDR      R1,[R0, #+0]
   \   00000040   0x688A             LDR      R2,[R1, #+8]
   \   00000042   0xF022 0x0240      BIC      R2,R2,#0x40
   \                     ??HAL_UART_DMAPause_2: (+1)
   \   00000046   0x608A             STR      R2,[R1, #+8]
   1035            }
   1036            
   1037            /* Process Unlocked */
   1038            __HAL_UNLOCK(huart);
   \                     ??HAL_UART_DMAPause_4: (+1)
   \   00000048   0x2100             MOVS     R1,#+0
   \   0000004A   0xF880 0x1068      STRB     R1,[R0, #+104]
   1039          
   1040            return HAL_OK; 
   \   0000004E   0x2000             MOVS     R0,#+0
   \   00000050   0x4770             BX       LR               ;; return
   1041          }
   1042          
   1043          /**
   1044            * @brief Resumes the DMA Transfer.
   1045            * @param huart: UART handle
   1046            * @retval None
   1047            */

   \                                 In section .text, align 2, keep-with-next
   1048          HAL_StatusTypeDef HAL_UART_DMAResume(UART_HandleTypeDef *huart)
   1049          {
   1050            /* Process Locked */
   1051            __HAL_LOCK(huart);
   \                     HAL_UART_DMAResume: (+1)
   \   00000000   0xF890 0x1068      LDRB     R1,[R0, #+104]
   \   00000004   0x2901             CMP      R1,#+1
   \   00000006   0xD101             BNE.N    ??HAL_UART_DMAResume_0
   \   00000008   0x2002             MOVS     R0,#+2
   \   0000000A   0x4770             BX       LR
   \                     ??HAL_UART_DMAResume_0: (+1)
   \   0000000C   0x2101             MOVS     R1,#+1
   \   0000000E   0xF880 0x1068      STRB     R1,[R0, #+104]
   1052          
   1053            if(huart->State == HAL_UART_STATE_BUSY_TX)
   \   00000012   0xF890 0x1069      LDRB     R1,[R0, #+105]
   \   00000016   0x2912             CMP      R1,#+18
   \   00000018   0xD017             BEQ.N    ??HAL_UART_DMAResume_1
   1054            {
   1055              /* Enable the UART DMA Tx request */
   1056              huart->Instance->CR3 |= USART_CR3_DMAT;
   1057            }
   1058            else if(huart->State == HAL_UART_STATE_BUSY_RX)
   \   0000001A   0xF890 0x1069      LDRB     R1,[R0, #+105]
   \   0000001E   0x2922             CMP      R1,#+34
   \   00000020   0xD107             BNE.N    ??HAL_UART_DMAResume_2
   1059            {
   1060          		/* Clear the Overrun flag before resuming the Rx transfer*/
   1061              __HAL_UART_CLEAR_IT(huart, UART_CLEAR_OREF);
   \   00000022   0x6802             LDR      R2,[R0, #+0]
   \   00000024   0x2108             MOVS     R1,#+8
   \   00000026   0x6211             STR      R1,[R2, #+32]
   1062          
   1063              /* Enable the UART DMA Rx request */
   1064              huart->Instance->CR3 |= USART_CR3_DMAR;
   \   00000028   0x6801             LDR      R1,[R0, #+0]
   \   0000002A   0x688A             LDR      R2,[R1, #+8]
   \   0000002C   0xF042 0x0240      ORR      R2,R2,#0x40
   \   00000030   0xE00F             B.N      ??HAL_UART_DMAResume_3
   1065            }
   1066            else if(huart->State == HAL_UART_STATE_BUSY_TX_RX)
   \                     ??HAL_UART_DMAResume_2: (+1)
   \   00000032   0xF890 0x1069      LDRB     R1,[R0, #+105]
   \   00000036   0x2932             CMP      R1,#+50
   \   00000038   0xD10C             BNE.N    ??HAL_UART_DMAResume_4
   1067            {
   1068          		/* Clear the Overrun flag before resuming the Rx transfer*/
   1069              __HAL_UART_CLEAR_IT(huart, UART_CLEAR_OREF);
   \   0000003A   0x6802             LDR      R2,[R0, #+0]
   \   0000003C   0x2108             MOVS     R1,#+8
   \   0000003E   0x6211             STR      R1,[R2, #+32]
   1070          		
   1071              /* Enable the UART DMA Rx request  before the DMA Tx request */
   1072              huart->Instance->CR3 |= USART_CR3_DMAR;
   \   00000040   0x6801             LDR      R1,[R0, #+0]
   \   00000042   0x688A             LDR      R2,[R1, #+8]
   \   00000044   0xF042 0x0240      ORR      R2,R2,#0x40
   \   00000048   0x608A             STR      R2,[R1, #+8]
   1073          
   1074              /* Enable the UART DMA Tx request */
   1075              huart->Instance->CR3 |= USART_CR3_DMAT;
   \                     ??HAL_UART_DMAResume_1: (+1)
   \   0000004A   0x6801             LDR      R1,[R0, #+0]
   \   0000004C   0x688A             LDR      R2,[R1, #+8]
   \   0000004E   0xF042 0x0280      ORR      R2,R2,#0x80
   \                     ??HAL_UART_DMAResume_3: (+1)
   \   00000052   0x608A             STR      R2,[R1, #+8]
   1076            }
   1077          
   1078            /* If the UART peripheral is still not enabled, enable it */
   1079            if ((huart->Instance->CR1 & USART_CR1_UE) == 0)
   \                     ??HAL_UART_DMAResume_4: (+1)
   \   00000054   0x6800             LDR      R0,[R0, #+0]
   \   00000056   0x6801             LDR      R1,[R0, #+0]
   \   00000058   0x07C9             LSLS     R1,R1,#+31
   \   0000005A   0xD403             BMI.N    ??HAL_UART_DMAResume_5
   1080            {
   1081              /* Enable UART peripheral */
   1082              __HAL_UART_ENABLE(huart);
   \   0000005C   0x6801             LDR      R1,[R0, #+0]
   \   0000005E   0xF041 0x0101      ORR      R1,R1,#0x1
   \   00000062   0x6001             STR      R1,[R0, #+0]
   1083            }
   1084          
   1085            return HAL_OK;
   \                     ??HAL_UART_DMAResume_5: (+1)
   \   00000064   0x2000             MOVS     R0,#+0
   \   00000066   0x4770             BX       LR               ;; return
   1086          }
   1087          
   1088          /**
   1089            * @brief Stops the DMA Transfer.
   1090            * @param huart: UART handle
   1091            * @retval None
   1092            */

   \                                 In section .text, align 2, keep-with-next
   1093          HAL_StatusTypeDef HAL_UART_DMAStop(UART_HandleTypeDef *huart)
   1094          {
   \                     HAL_UART_DMAStop: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   1095            /* The Lock is not implemented on this API to allow the user application
   1096               to call the HAL UART API under callbacks HAL_UART_TxCpltCallback() / HAL_UART_RxCpltCallback() /
   1097               HAL_UART_TxHalfCpltCallback / HAL_UART_RxHalfCpltCallback: 
   1098               indeed, when HAL_DMA_Abort() API is called, the DMA TX/RX Transfer or Half Transfer complete  
   1099               interrupt is generated if the DMA transfer interruption occurs at the middle or at the end of 
   1100               the stream and the corresponding call back is executed. */
   1101            
   1102            /* Disable the UART Tx/Rx DMA requests */
   1103            huart->Instance->CR3 &= ~USART_CR3_DMAT;
   \   00000004   0x6820             LDR      R0,[R4, #+0]
   \   00000006   0x6881             LDR      R1,[R0, #+8]
   \   00000008   0xF021 0x0180      BIC      R1,R1,#0x80
   \   0000000C   0x6081             STR      R1,[R0, #+8]
   1104            huart->Instance->CR3 &= ~USART_CR3_DMAR;
   \   0000000E   0x6820             LDR      R0,[R4, #+0]
   \   00000010   0x6881             LDR      R1,[R0, #+8]
   \   00000012   0xF021 0x0140      BIC      R1,R1,#0x40
   \   00000016   0x6081             STR      R1,[R0, #+8]
   1105            
   1106            /* Abort the UART DMA tx channel */
   1107            if(huart->hdmatx != NULL)
   \   00000018   0x6E20             LDR      R0,[R4, #+96]
   \   0000001A   0xB108             CBZ.N    R0,??HAL_UART_DMAStop_0
   1108            {
   1109              HAL_DMA_Abort(huart->hdmatx);
   \   0000001C   0x.... 0x....      BL       HAL_DMA_Abort
   1110            }
   1111            /* Abort the UART DMA rx channel */
   1112            if(huart->hdmarx != NULL)
   \                     ??HAL_UART_DMAStop_0: (+1)
   \   00000020   0x6E60             LDR      R0,[R4, #+100]
   \   00000022   0xB108             CBZ.N    R0,??HAL_UART_DMAStop_1
   1113            {
   1114              HAL_DMA_Abort(huart->hdmarx);
   \   00000024   0x.... 0x....      BL       HAL_DMA_Abort
   1115            }
   1116            
   1117            huart->State = HAL_UART_STATE_READY;
   \                     ??HAL_UART_DMAStop_1: (+1)
   \   00000028   0x2001             MOVS     R0,#+1
   \   0000002A   0xF884 0x0069      STRB     R0,[R4, #+105]
   1118            
   1119            return HAL_OK;
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0xBD10             POP      {R4,PC}          ;; return
   1120          }
   1121          
   1122          /**
   1123            * @brief This function handles UART interrupt request.
   1124            * @param huart: uart handle
   1125            * @retval None
   1126            */

   \                                 In section .text, align 2, keep-with-next
   1127          void HAL_UART_IRQHandler(UART_HandleTypeDef *huart)
   1128          {
   \                     HAL_UART_IRQHandler: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   1129            /* UART parity error interrupt occurred -------------------------------------*/
   1130            if((__HAL_UART_GET_IT(huart, UART_IT_PE) != RESET) && (__HAL_UART_GET_IT_SOURCE(huart, UART_IT_PE) != RESET))
   \   00000004   0x6820             LDR      R0,[R4, #+0]
   \   00000006   0x69C1             LDR      R1,[R0, #+28]
   \   00000008   0x07C9             LSLS     R1,R1,#+31
   \   0000000A   0xD50A             BPL.N    ??HAL_UART_IRQHandler_0
   \   0000000C   0x6801             LDR      R1,[R0, #+0]
   \   0000000E   0x05C9             LSLS     R1,R1,#+23
   \   00000010   0xD507             BPL.N    ??HAL_UART_IRQHandler_0
   1131            { 
   1132          		__HAL_UART_CLEAR_PEFLAG(huart);
   \   00000012   0x2101             MOVS     R1,#+1
   \   00000014   0x6201             STR      R1,[R0, #+32]
   1133          
   1134              huart->ErrorCode |= HAL_UART_ERROR_PE;
   \   00000016   0x6EE0             LDR      R0,[R4, #+108]
   \   00000018   0xF040 0x0001      ORR      R0,R0,#0x1
   \   0000001C   0x66E0             STR      R0,[R4, #+108]
   1135              /* Set the UART state ready to be able to start again the process */
   1136              huart->State = HAL_UART_STATE_READY;
   \   0000001E   0xF884 0x1069      STRB     R1,[R4, #+105]
   1137            }
   1138            
   1139            /* UART frame error interrupt occurred --------------------------------------*/
   1140            if((__HAL_UART_GET_IT(huart, UART_IT_FE) != RESET) && (__HAL_UART_GET_IT_SOURCE(huart, UART_IT_ERR) != RESET))
   \                     ??HAL_UART_IRQHandler_0: (+1)
   \   00000022   0x6820             LDR      R0,[R4, #+0]
   \   00000024   0x69C1             LDR      R1,[R0, #+28]
   \   00000026   0x0789             LSLS     R1,R1,#+30
   \   00000028   0xD50B             BPL.N    ??HAL_UART_IRQHandler_1
   \   0000002A   0x6881             LDR      R1,[R0, #+8]
   \   0000002C   0x07C9             LSLS     R1,R1,#+31
   \   0000002E   0xD508             BPL.N    ??HAL_UART_IRQHandler_1
   1141            { 
   1142              __HAL_UART_CLEAR_FEFLAG(huart);
   \   00000030   0x2102             MOVS     R1,#+2
   \   00000032   0x6201             STR      R1,[R0, #+32]
   1143          
   1144              huart->ErrorCode |= HAL_UART_ERROR_FE;
   \   00000034   0x6EE0             LDR      R0,[R4, #+108]
   \   00000036   0xF040 0x0004      ORR      R0,R0,#0x4
   \   0000003A   0x66E0             STR      R0,[R4, #+108]
   1145              /* Set the UART state ready to be able to start again the process */
   1146              huart->State = HAL_UART_STATE_READY;
   \   0000003C   0x2001             MOVS     R0,#+1
   \   0000003E   0xF884 0x0069      STRB     R0,[R4, #+105]
   1147            }
   1148            
   1149            /* UART noise error interrupt occurred --------------------------------------*/
   1150            if((__HAL_UART_GET_IT(huart, UART_IT_NE) != RESET) && (__HAL_UART_GET_IT_SOURCE(huart, UART_IT_ERR) != RESET))
   \                     ??HAL_UART_IRQHandler_1: (+1)
   \   00000042   0x6820             LDR      R0,[R4, #+0]
   \   00000044   0x69C1             LDR      R1,[R0, #+28]
   \   00000046   0x0749             LSLS     R1,R1,#+29
   \   00000048   0xD50B             BPL.N    ??HAL_UART_IRQHandler_2
   \   0000004A   0x6881             LDR      R1,[R0, #+8]
   \   0000004C   0x07C9             LSLS     R1,R1,#+31
   \   0000004E   0xD508             BPL.N    ??HAL_UART_IRQHandler_2
   1151            { 
   1152              __HAL_UART_CLEAR_NEFLAG(huart);
   \   00000050   0x2104             MOVS     R1,#+4
   \   00000052   0x6201             STR      R1,[R0, #+32]
   1153          
   1154              huart->ErrorCode |= HAL_UART_ERROR_NE;
   \   00000054   0x6EE0             LDR      R0,[R4, #+108]
   \   00000056   0xF040 0x0002      ORR      R0,R0,#0x2
   \   0000005A   0x66E0             STR      R0,[R4, #+108]
   1155              /* Set the UART state ready to be able to start again the process */
   1156              huart->State = HAL_UART_STATE_READY;
   \   0000005C   0x2001             MOVS     R0,#+1
   \   0000005E   0xF884 0x0069      STRB     R0,[R4, #+105]
   1157            }
   1158            
   1159            /* UART Over-Run interrupt occurred -----------------------------------------*/
   1160            if((__HAL_UART_GET_IT(huart, UART_IT_ORE) != RESET) && (__HAL_UART_GET_IT_SOURCE(huart, UART_IT_ERR) != RESET))
   \                     ??HAL_UART_IRQHandler_2: (+1)
   \   00000062   0x6820             LDR      R0,[R4, #+0]
   \   00000064   0x69C1             LDR      R1,[R0, #+28]
   \   00000066   0x0709             LSLS     R1,R1,#+28
   \   00000068   0xD50B             BPL.N    ??HAL_UART_IRQHandler_3
   \   0000006A   0x6881             LDR      R1,[R0, #+8]
   \   0000006C   0x07C9             LSLS     R1,R1,#+31
   \   0000006E   0xD508             BPL.N    ??HAL_UART_IRQHandler_3
   1161            { 
   1162              __HAL_UART_CLEAR_OREFLAG(huart);
   \   00000070   0x2108             MOVS     R1,#+8
   \   00000072   0x6201             STR      R1,[R0, #+32]
   1163          
   1164              huart->ErrorCode |= HAL_UART_ERROR_ORE;
   \   00000074   0x6EE0             LDR      R0,[R4, #+108]
   \   00000076   0xF040 0x0008      ORR      R0,R0,#0x8
   \   0000007A   0x66E0             STR      R0,[R4, #+108]
   1165              /* Set the UART state ready to be able to start again the process */
   1166              huart->State = HAL_UART_STATE_READY;
   \   0000007C   0x2001             MOVS     R0,#+1
   \   0000007E   0xF884 0x0069      STRB     R0,[R4, #+105]
   1167            }
   1168          
   1169             /* Call UART Error Call back function if need be --------------------------*/
   1170            if(huart->ErrorCode != HAL_UART_ERROR_NONE)
   \                     ??HAL_UART_IRQHandler_3: (+1)
   \   00000082   0x6EE0             LDR      R0,[R4, #+108]
   \   00000084   0xB110             CBZ.N    R0,??HAL_UART_IRQHandler_4
   1171            {
   1172              HAL_UART_ErrorCallback(huart);
   \   00000086   0x4620             MOV      R0,R4
   \   00000088   0x.... 0x....      BL       HAL_UART_ErrorCallback
   1173            }
   1174          
   1175            /* UART in mode Receiver ---------------------------------------------------*/
   1176            if((__HAL_UART_GET_IT(huart, UART_IT_RXNE) != RESET) && (__HAL_UART_GET_IT_SOURCE(huart, UART_IT_RXNE) != RESET))
   \                     ??HAL_UART_IRQHandler_4: (+1)
   \   0000008C   0x6820             LDR      R0,[R4, #+0]
   \   0000008E   0x69C1             LDR      R1,[R0, #+28]
   \   00000090   0x0689             LSLS     R1,R1,#+26
   \   00000092   0xD50A             BPL.N    ??HAL_UART_IRQHandler_5
   \   00000094   0x6800             LDR      R0,[R0, #+0]
   \   00000096   0x0680             LSLS     R0,R0,#+26
   \   00000098   0xD507             BPL.N    ??HAL_UART_IRQHandler_5
   1177            { 
   1178              UART_Receive_IT(huart);
   \   0000009A   0x4620             MOV      R0,R4
   \   0000009C   0x.... 0x....      BL       UART_Receive_IT
   1179              /* Clear RXNE interrupt flag */
   1180              __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
   \   000000A0   0x6820             LDR      R0,[R4, #+0]
   \   000000A2   0x6981             LDR      R1,[R0, #+24]
   \   000000A4   0xF041 0x0108      ORR      R1,R1,#0x8
   \   000000A8   0x6181             STR      R1,[R0, #+24]
   1181            }
   1182            
   1183          
   1184            /* UART in mode Transmitter ------------------------------------------------*/
   1185           if((__HAL_UART_GET_IT(huart, UART_IT_TXE) != RESET) &&(__HAL_UART_GET_IT_SOURCE(huart, UART_IT_TXE) != RESET))
   \                     ??HAL_UART_IRQHandler_5: (+1)
   \   000000AA   0x6820             LDR      R0,[R4, #+0]
   \   000000AC   0x69C1             LDR      R1,[R0, #+28]
   \   000000AE   0x0609             LSLS     R1,R1,#+24
   \   000000B0   0xD561             BPL.N    ??HAL_UART_IRQHandler_6
   \   000000B2   0x6801             LDR      R1,[R0, #+0]
   \   000000B4   0x0609             LSLS     R1,R1,#+24
   \   000000B6   0xD55E             BPL.N    ??HAL_UART_IRQHandler_6
   1186            {
   1187              UART_Transmit_IT(huart);
   \   000000B8   0xF894 0x1069      LDRB     R1,[R4, #+105]
   \   000000BC   0x2912             CMP      R1,#+18
   \   000000BE   0xBF1C             ITT      NE 
   \   000000C0   0xF894 0x1069      LDRBNE   R1,[R4, #+105]
   \   000000C4   0x2932             CMPNE    R1,#+50
   \   000000C6   0xD156             BNE.N    ??HAL_UART_IRQHandler_6
   \   000000C8   0xF8B4 0x1052      LDRH     R1,[R4, #+82]
   \   000000CC   0x2900             CMP      R1,#+0
   \   000000CE   0xD138             BNE.N    ??HAL_UART_IRQHandler_7
   \   000000D0   0x6801             LDR      R1,[R0, #+0]
   \   000000D2   0xF06F 0x467E      MVN      R6,#-33554432
   \   000000D6   0xF021 0x0180      BIC      R1,R1,#0x80
   \   000000DA   0x6001             STR      R1,[R0, #+0]
   \   000000DC   0xF894 0x0069      LDRB     R0,[R4, #+105]
   \   000000E0   0x2832             CMP      R0,#+50
   \   000000E2   0xBF0C             ITE      EQ 
   \   000000E4   0x2022             MOVEQ    R0,#+34
   \   000000E6   0x2001             MOVNE    R0,#+1
   \   000000E8   0xF884 0x0069      STRB     R0,[R4, #+105]
   \   000000EC   0x.... 0x....      BL       HAL_GetTick
   \   000000F0   0x4605             MOV      R5,R0
   \                     ??HAL_UART_IRQHandler_8: (+1)
   \   000000F2   0x6820             LDR      R0,[R4, #+0]
   \   000000F4   0x69C0             LDR      R0,[R0, #+28]
   \   000000F6   0x0640             LSLS     R0,R0,#+25
   \   000000F8   0xD41F             BMI.N    ??HAL_UART_IRQHandler_9
   \   000000FA   0x.... 0x....      BL       HAL_GetTick
   \   000000FE   0x1B40             SUBS     R0,R0,R5
   \   00000100   0x42B0             CMP      R0,R6
   \   00000102   0xD3F6             BCC.N    ??HAL_UART_IRQHandler_8
   \   00000104   0x6820             LDR      R0,[R4, #+0]
   \   00000106   0x6801             LDR      R1,[R0, #+0]
   \   00000108   0xF021 0x0180      BIC      R1,R1,#0x80
   \   0000010C   0x6001             STR      R1,[R0, #+0]
   \   0000010E   0x6820             LDR      R0,[R4, #+0]
   \   00000110   0x6801             LDR      R1,[R0, #+0]
   \   00000112   0xF021 0x0120      BIC      R1,R1,#0x20
   \   00000116   0x6001             STR      R1,[R0, #+0]
   \   00000118   0x6820             LDR      R0,[R4, #+0]
   \   0000011A   0x6801             LDR      R1,[R0, #+0]
   \   0000011C   0xF421 0x7180      BIC      R1,R1,#0x100
   \   00000120   0x6001             STR      R1,[R0, #+0]
   \   00000122   0x6820             LDR      R0,[R4, #+0]
   \   00000124   0x6881             LDR      R1,[R0, #+8]
   \   00000126   0x0849             LSRS     R1,R1,#+1
   \   00000128   0x0049             LSLS     R1,R1,#+1
   \   0000012A   0x6081             STR      R1,[R0, #+8]
   \   0000012C   0x2001             MOVS     R0,#+1
   \   0000012E   0xF884 0x0069      STRB     R0,[R4, #+105]
   \   00000132   0x2000             MOVS     R0,#+0
   \   00000134   0xF884 0x0068      STRB     R0,[R4, #+104]
   \   00000138   0xE01D             B.N      ??HAL_UART_IRQHandler_6
   \                     ??HAL_UART_IRQHandler_9: (+1)
   \   0000013A   0x4620             MOV      R0,R4
   \   0000013C   0x.... 0x....      BL       HAL_UART_TxCpltCallback
   \   00000140   0xE019             B.N      ??HAL_UART_IRQHandler_6
   \                     ??HAL_UART_IRQHandler_7: (+1)
   \   00000142   0x68A1             LDR      R1,[R4, #+8]
   \   00000144   0xF5B1 0x5F80      CMP      R1,#+4096
   \   00000148   0xBF04             ITT      EQ 
   \   0000014A   0x6921             LDREQ    R1,[R4, #+16]
   \   0000014C   0x2900             CMPEQ    R1,#+0
   \   0000014E   0xD108             BNE.N    ??HAL_UART_IRQHandler_10
   \   00000150   0x6CE1             LDR      R1,[R4, #+76]
   \   00000152   0x8809             LDRH     R1,[R1, #+0]
   \   00000154   0x05C9             LSLS     R1,R1,#+23
   \   00000156   0x0DC9             LSRS     R1,R1,#+23
   \   00000158   0x6281             STR      R1,[R0, #+40]
   \   0000015A   0x6CE0             LDR      R0,[R4, #+76]
   \   0000015C   0x1C80             ADDS     R0,R0,#+2
   \   0000015E   0x64E0             STR      R0,[R4, #+76]
   \   00000160   0xE004             B.N      ??HAL_UART_IRQHandler_11
   \                     ??HAL_UART_IRQHandler_10: (+1)
   \   00000162   0x6CE1             LDR      R1,[R4, #+76]
   \   00000164   0x1C4A             ADDS     R2,R1,#+1
   \   00000166   0x64E2             STR      R2,[R4, #+76]
   \   00000168   0x7809             LDRB     R1,[R1, #+0]
   \   0000016A   0x6281             STR      R1,[R0, #+40]
   \                     ??HAL_UART_IRQHandler_11: (+1)
   \   0000016C   0xF8B4 0x0052      LDRH     R0,[R4, #+82]
   \   00000170   0x1E40             SUBS     R0,R0,#+1
   \   00000172   0xF8A4 0x0052      STRH     R0,[R4, #+82]
   1188            }
   1189          
   1190            /* UART in mode Transmitter (transmission end) -----------------------------*/
   1191           if((__HAL_UART_GET_IT(huart, UART_IT_TC) != RESET) &&(__HAL_UART_GET_IT_SOURCE(huart, UART_IT_TC) != RESET))
   \                     ??HAL_UART_IRQHandler_6: (+1)
   \   00000176   0x6820             LDR      R0,[R4, #+0]
   \   00000178   0x69C1             LDR      R1,[R0, #+28]
   \   0000017A   0x0649             LSLS     R1,R1,#+25
   \   0000017C   0xD511             BPL.N    ??HAL_UART_IRQHandler_12
   \   0000017E   0x6801             LDR      R1,[R0, #+0]
   \   00000180   0x0649             LSLS     R1,R1,#+25
   \   00000182   0xD50E             BPL.N    ??HAL_UART_IRQHandler_12
   1192            {
   1193              UART_EndTransmit_IT(huart);
   \   00000184   0x6801             LDR      R1,[R0, #+0]
   \   00000186   0xF021 0x0140      BIC      R1,R1,#0x40
   \   0000018A   0x6001             STR      R1,[R0, #+0]
   \   0000018C   0xF894 0x0069      LDRB     R0,[R4, #+105]
   \   00000190   0x2832             CMP      R0,#+50
   \   00000192   0xBF0C             ITE      EQ 
   \   00000194   0x2022             MOVEQ    R0,#+34
   \   00000196   0x2001             MOVNE    R0,#+1
   \   00000198   0xF884 0x0069      STRB     R0,[R4, #+105]
   \   0000019C   0x4620             MOV      R0,R4
   \   0000019E   0x.... 0x....      BL       HAL_UART_TxCpltCallback
   1194            }
   1195            
   1196          }
   \                     ??HAL_UART_IRQHandler_12: (+1)
   \   000001A2   0xBD70             POP      {R4-R6,PC}       ;; return
   1197          
   1198          
   1199          /**
   1200            * @brief  This function handles UART Communication Timeout.
   1201            * @param  huart: UART handle
   1202            * @param  Flag: specifies the UART flag to check.
   1203            * @param  Status: The new Flag status (SET or RESET).
   1204            * @param  Timeout: Timeout duration
   1205            * @retval HAL status
   1206            */

   \                                 In section .text, align 2, keep-with-next
   1207          HAL_StatusTypeDef UART_WaitOnFlagUntilTimeout(UART_HandleTypeDef *huart, uint32_t Flag, FlagStatus Status, uint32_t Timeout)
   1208          {
   \                     UART_WaitOnFlagUntilTimeout: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
   \   00000008   0x4690             MOV      R8,R2
   \   0000000A   0x461E             MOV      R6,R3
   1209            uint32_t tickstart = HAL_GetTick();
   \   0000000C   0x.... 0x....      BL       HAL_GetTick
   1210            
   1211            /* Wait until flag is set */
   1212            if(Status == RESET)
   \   00000010   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000014   0x4607             MOV      R7,R0
   \   00000016   0xD10E             BNE.N    ??UART_WaitOnFlagUntilTimeout_0
   1213            {    
   1214              while(__HAL_UART_GET_FLAG(huart, Flag) == RESET)
   \                     ??UART_WaitOnFlagUntilTimeout_1: (+1)
   \   00000018   0x6820             LDR      R0,[R4, #+0]
   \   0000001A   0x69C0             LDR      R0,[R0, #+28]
   \   0000001C   0x4028             ANDS     R0,R5,R0
   \   0000001E   0x42A8             CMP      R0,R5
   \   00000020   0xD034             BEQ.N    ??UART_WaitOnFlagUntilTimeout_2
   1215              {
   1216                /* Check for the Timeout */
   1217                if(Timeout != HAL_MAX_DELAY)
   \   00000022   0xF116 0x0F01      CMN      R6,#+1
   \   00000026   0xD0F7             BEQ.N    ??UART_WaitOnFlagUntilTimeout_1
   1218                {
   1219                  if((Timeout == 0)||((HAL_GetTick()-tickstart) >=  Timeout))
   \   00000028   0xB19E             CBZ.N    R6,??UART_WaitOnFlagUntilTimeout_3
   \   0000002A   0x.... 0x....      BL       HAL_GetTick
   \   0000002E   0x1BC0             SUBS     R0,R0,R7
   \   00000030   0x42B0             CMP      R0,R6
   \   00000032   0xD3F1             BCC.N    ??UART_WaitOnFlagUntilTimeout_1
   1220                  {
   1221                    /* Disable TXE, RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts for the interrupt process */
   1222                    __HAL_UART_DISABLE_IT(huart, UART_IT_TXE);
   \   00000034   0xE00D             B.N      ??UART_WaitOnFlagUntilTimeout_3
   1223                    __HAL_UART_DISABLE_IT(huart, UART_IT_RXNE);
   1224                    __HAL_UART_DISABLE_IT(huart, UART_IT_PE);
   1225                    __HAL_UART_DISABLE_IT(huart, UART_IT_ERR);
   1226                    
   1227                    huart->State= HAL_UART_STATE_READY;
   1228                    
   1229                    /* Process Unlocked */
   1230                    __HAL_UNLOCK(huart);
   1231                    
   1232                    return HAL_TIMEOUT;
   1233                  }
   1234                }
   1235              }
   1236            }
   1237            else
   1238            {
   1239              while(__HAL_UART_GET_FLAG(huart, Flag) != RESET)
   \                     ??UART_WaitOnFlagUntilTimeout_0: (+1)
   \   00000036   0x6820             LDR      R0,[R4, #+0]
   \   00000038   0x69C0             LDR      R0,[R0, #+28]
   \   0000003A   0x4028             ANDS     R0,R5,R0
   \   0000003C   0x42A8             CMP      R0,R5
   \   0000003E   0xD125             BNE.N    ??UART_WaitOnFlagUntilTimeout_2
   1240              {
   1241                /* Check for the Timeout */
   1242                if(Timeout != HAL_MAX_DELAY)
   \   00000040   0xF116 0x0F01      CMN      R6,#+1
   \   00000044   0xD0F7             BEQ.N    ??UART_WaitOnFlagUntilTimeout_0
   1243                {
   1244                  if((Timeout == 0)||((HAL_GetTick()-tickstart) >=  Timeout))
   \   00000046   0xB126             CBZ.N    R6,??UART_WaitOnFlagUntilTimeout_3
   \   00000048   0x.... 0x....      BL       HAL_GetTick
   \   0000004C   0x1BC0             SUBS     R0,R0,R7
   \   0000004E   0x42B0             CMP      R0,R6
   \   00000050   0xD3F1             BCC.N    ??UART_WaitOnFlagUntilTimeout_0
   1245                  {
   1246                    /* Disable TXE, RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts for the interrupt process */
   1247                    __HAL_UART_DISABLE_IT(huart, UART_IT_TXE);
   \                     ??UART_WaitOnFlagUntilTimeout_3: (+1)
   \   00000052   0x6820             LDR      R0,[R4, #+0]
   \   00000054   0x6801             LDR      R1,[R0, #+0]
   \   00000056   0xF021 0x0180      BIC      R1,R1,#0x80
   \   0000005A   0x6001             STR      R1,[R0, #+0]
   1248                    __HAL_UART_DISABLE_IT(huart, UART_IT_RXNE);
   \   0000005C   0x6820             LDR      R0,[R4, #+0]
   \   0000005E   0x6801             LDR      R1,[R0, #+0]
   \   00000060   0xF021 0x0120      BIC      R1,R1,#0x20
   \   00000064   0x6001             STR      R1,[R0, #+0]
   1249                    __HAL_UART_DISABLE_IT(huart, UART_IT_PE);
   \   00000066   0x6820             LDR      R0,[R4, #+0]
   \   00000068   0x6801             LDR      R1,[R0, #+0]
   \   0000006A   0xF421 0x7180      BIC      R1,R1,#0x100
   \   0000006E   0x6001             STR      R1,[R0, #+0]
   1250                    __HAL_UART_DISABLE_IT(huart, UART_IT_ERR);
   \   00000070   0x6820             LDR      R0,[R4, #+0]
   \   00000072   0x6881             LDR      R1,[R0, #+8]
   \   00000074   0x0849             LSRS     R1,R1,#+1
   \   00000076   0x0049             LSLS     R1,R1,#+1
   \   00000078   0x6081             STR      R1,[R0, #+8]
   1251                    
   1252                    huart->State= HAL_UART_STATE_READY;
   \   0000007A   0x2001             MOVS     R0,#+1
   \   0000007C   0xF884 0x0069      STRB     R0,[R4, #+105]
   1253                    
   1254                    /* Process Unlocked */
   1255                    __HAL_UNLOCK(huart);
   \   00000080   0x2000             MOVS     R0,#+0
   \   00000082   0xF884 0x0068      STRB     R0,[R4, #+104]
   1256                    
   1257                    return HAL_TIMEOUT;
   \   00000086   0x2003             MOVS     R0,#+3
   \   00000088   0xE8BD 0x81F0      POP      {R4-R8,PC}
   1258                  }
   1259                }
   1260              }
   1261            }
   1262            return HAL_OK;      
   \                     ??UART_WaitOnFlagUntilTimeout_2: (+1)
   \   0000008C   0x2000             MOVS     R0,#+0
   \   0000008E   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   1263          }
   1264          
   1265          
   1266          
   1267          /**
   1268            * @brief DMA UART transmit process complete callback 
   1269            * @param hdma: DMA handle
   1270            * @retval None
   1271            */

   \                                 In section .text, align 4, keep-with-next
   1272          static void UART_DMATransmitCplt(DMA_HandleTypeDef *hdma)     
   1273          {
   \                     UART_DMATransmitCplt: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB081             SUB      SP,SP,#+4
   1274            UART_HandleTypeDef* huart = ( UART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   \   00000004   0x6B81             LDR      R1,[R0, #+56]
   1275            
   1276            /* DMA Normal mode*/
   1277            if((hdma->Instance->CR & DMA_SxCR_CIRC) == 0)
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0x6800             LDR      R0,[R0, #+0]
   \   0000000A   0x05C0             LSLS     R0,R0,#+23
   \   0000000C   0xD40D             BMI.N    ??UART_DMATransmitCplt_0
   1278            {
   1279              huart->TxXferCount = 0;
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0xF8A1 0x0052      STRH     R0,[R1, #+82]
   1280          
   1281              /* Disable the DMA transfer for transmit request by setting the DMAT bit
   1282                 in the UART CR3 register */
   1283              huart->Instance->CR3 &= (uint32_t)~((uint32_t)USART_CR3_DMAT);
   \   00000014   0x6808             LDR      R0,[R1, #+0]
   \   00000016   0x6881             LDR      R1,[R0, #+8]
   \   00000018   0xF021 0x0180      BIC      R1,R1,#0x80
   \   0000001C   0x6081             STR      R1,[R0, #+8]
   1284          
   1285              /* Enable the UART Transmit Complete Interrupt */
   1286              __HAL_UART_ENABLE_IT(huart, UART_IT_TC);
   \   0000001E   0x6801             LDR      R1,[R0, #+0]
   \   00000020   0xF041 0x0140      ORR      R1,R1,#0x40
   \   00000024   0x6001             STR      R1,[R0, #+0]
   1287            }
   1288            /* DMA Circular mode */
   1289            else
   1290            {
   1291              HAL_UART_TxCpltCallback(huart);
   1292            }
   1293          }
   \   00000026   0xB001             ADD      SP,SP,#+4
   \   00000028   0xBD00             POP      {PC}
   \                     ??UART_DMATransmitCplt_0: (+1)
   \   0000002A   0x4608             MOV      R0,R1
   \   0000002C   0x.... 0x....      BL       HAL_UART_TxCpltCallback
   \   00000030   0xB001             ADD      SP,SP,#+4
   \   00000032   0xBD00             POP      {PC}             ;; return
   1294          
   1295          /**
   1296            * @brief DMA UART transmit process half complete callback 
   1297            * @param hdma : DMA handle
   1298            * @retval None
   1299            */

   \                                 In section .text, align 4, keep-with-next
   1300          static void UART_DMATxHalfCplt(DMA_HandleTypeDef *hdma)
   1301          {
   \                     UART_DMATxHalfCplt: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB081             SUB      SP,SP,#+4
   1302            UART_HandleTypeDef* huart = (UART_HandleTypeDef*)((DMA_HandleTypeDef*)hdma)->Parent;
   1303          
   1304            HAL_UART_TxHalfCpltCallback(huart);
   \   00000004   0x6B80             LDR      R0,[R0, #+56]
   \   00000006   0x.... 0x....      BL       HAL_UART_TxHalfCpltCallback
   1305          }
   \   0000000A   0xB001             ADD      SP,SP,#+4
   \   0000000C   0xBD00             POP      {PC}             ;; return
   1306          
   1307          /**
   1308            * @brief DMA UART receive process complete callback 
   1309            * @param hdma: DMA handle
   1310            * @retval None
   1311            */

   \                                 In section .text, align 4, keep-with-next
   1312          static void UART_DMAReceiveCplt(DMA_HandleTypeDef *hdma)  
   1313          {
   \                     UART_DMAReceiveCplt: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB081             SUB      SP,SP,#+4
   1314            UART_HandleTypeDef* huart = ( UART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   \   00000004   0x6B81             LDR      R1,[R0, #+56]
   1315            
   1316            /* DMA Normal mode */
   1317            if((hdma->Instance->CR & DMA_SxCR_CIRC) == 0)
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0x6800             LDR      R0,[R0, #+0]
   \   0000000A   0x05C0             LSLS     R0,R0,#+23
   \   0000000C   0xD40F             BMI.N    ??UART_DMAReceiveCplt_0
   1318            { 
   1319              huart->RxXferCount = 0;
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0xF8A1 0x005A      STRH     R0,[R1, #+90]
   1320              
   1321              /* Disable the DMA transfer for the receiver request by setting the DMAR bit 
   1322              in the UART CR3 register */
   1323              huart->Instance->CR3 &= (uint32_t)~((uint32_t)USART_CR3_DMAR);
   \   00000014   0x6808             LDR      R0,[R1, #+0]
   \   00000016   0x6882             LDR      R2,[R0, #+8]
   \   00000018   0xF022 0x0240      BIC      R2,R2,#0x40
   \   0000001C   0x6082             STR      R2,[R0, #+8]
   1324              
   1325              /* Check if a transmit Process is ongoing or not */
   1326              if(huart->State == HAL_UART_STATE_BUSY_TX_RX) 
   \   0000001E   0xF891 0x0069      LDRB     R0,[R1, #+105]
   \   00000022   0x2832             CMP      R0,#+50
   \   00000024   0xBF0C             ITE      EQ 
   \   00000026   0x2012             MOVEQ    R0,#+18
   \   00000028   0x2001             MOVNE    R0,#+1
   1327              {
   1328                huart->State = HAL_UART_STATE_BUSY_TX;
   1329              }
   1330              else
   1331              {
   1332                huart->State = HAL_UART_STATE_READY;
   \   0000002A   0xF881 0x0069      STRB     R0,[R1, #+105]
   1333              }
   1334            }
   1335            HAL_UART_RxCpltCallback(huart);
   \                     ??UART_DMAReceiveCplt_0: (+1)
   \   0000002E   0x4608             MOV      R0,R1
   \   00000030   0x.... 0x....      BL       HAL_UART_RxCpltCallback
   1336          }
   \   00000034   0xB001             ADD      SP,SP,#+4
   \   00000036   0xBD00             POP      {PC}             ;; return
   1337          
   1338          /**
   1339            * @brief DMA UART receive process half complete callback 
   1340            * @param hdma : DMA handle
   1341            * @retval None
   1342            */

   \                                 In section .text, align 4, keep-with-next
   1343          static void UART_DMARxHalfCplt(DMA_HandleTypeDef *hdma)
   1344          {
   \                     UART_DMARxHalfCplt: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB081             SUB      SP,SP,#+4
   1345            UART_HandleTypeDef* huart = (UART_HandleTypeDef*)((DMA_HandleTypeDef*)hdma)->Parent;
   1346          
   1347            HAL_UART_RxHalfCpltCallback(huart); 
   \   00000004   0x6B80             LDR      R0,[R0, #+56]
   \   00000006   0x.... 0x....      BL       HAL_UART_RxHalfCpltCallback
   1348          }
   \   0000000A   0xB001             ADD      SP,SP,#+4
   \   0000000C   0xBD00             POP      {PC}             ;; return
   1349          
   1350          /**
   1351            * @brief DMA UART communication error callback 
   1352            * @param hdma: DMA handle
   1353            * @retval None
   1354            */

   \                                 In section .text, align 4, keep-with-next
   1355          static void UART_DMAError(DMA_HandleTypeDef *hdma)   
   1356          {
   \                     UART_DMAError: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB081             SUB      SP,SP,#+4
   1357            UART_HandleTypeDef* huart = ( UART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   \   00000004   0x6B80             LDR      R0,[R0, #+56]
   1358            huart->RxXferCount = 0;
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0xF8A0 0x105A      STRH     R1,[R0, #+90]
   1359            huart->TxXferCount = 0;
   \   0000000C   0xF8A0 0x1052      STRH     R1,[R0, #+82]
   1360            huart->State= HAL_UART_STATE_READY;
   \   00000010   0x2101             MOVS     R1,#+1
   \   00000012   0xF880 0x1069      STRB     R1,[R0, #+105]
   1361            huart->ErrorCode |= HAL_UART_ERROR_DMA;
   \   00000016   0x6EC1             LDR      R1,[R0, #+108]
   \   00000018   0xF041 0x0110      ORR      R1,R1,#0x10
   \   0000001C   0x66C1             STR      R1,[R0, #+108]
   1362            HAL_UART_ErrorCallback(huart);
   \   0000001E   0x.... 0x....      BL       HAL_UART_ErrorCallback
   1363          }
   \   00000022   0xB001             ADD      SP,SP,#+4
   \   00000024   0xBD00             POP      {PC}             ;; return
   1364          
   1365          /**
   1366            * @brief Tx Transfer completed callbacks
   1367            * @param huart: uart handle
   1368            * @retval None
   1369            */

   \                                 In section .text, align 2, keep-with-next
   1370           __weak void HAL_UART_TxCpltCallback(UART_HandleTypeDef *huart)
   1371          {
   1372            /* Prevent unused argument(s) compilation warning */
   1373            UNUSED(huart);
   1374           
   1375            /* NOTE : This function should not be modified, when the callback is needed,
   1376                      the HAL_UART_TxCpltCallback can be implemented in the user file
   1377             */ 
   1378          }
   \                     HAL_UART_TxCpltCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1379          
   1380          /**
   1381            * @brief  Tx Half Transfer completed callbacks.
   1382            * @param  huart: UART handle
   1383            * @retval None
   1384            */

   \                                 In section .text, align 2, keep-with-next
   1385           __weak void HAL_UART_TxHalfCpltCallback(UART_HandleTypeDef *huart)
   1386          {
   1387            /* Prevent unused argument(s) compilation warning */
   1388            UNUSED(huart);
   1389           
   1390            /* NOTE: This function should not be modified, when the callback is needed,
   1391                     the HAL_UART_TxHalfCpltCallback can be implemented in the user file
   1392             */ 
   1393          }
   \                     HAL_UART_TxHalfCpltCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1394          
   1395          /**
   1396            * @brief Rx Transfer completed callbacks
   1397            * @param huart: uart handle
   1398            * @retval None
   1399            */

   \                                 In section .text, align 2, keep-with-next
   1400          __weak void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)
   1401          {
   1402            /* Prevent unused argument(s) compilation warning */
   1403            UNUSED(huart);
   1404           
   1405            /* NOTE : This function should not be modified, when the callback is needed,
   1406                      the HAL_UART_RxCpltCallback can be implemented in the user file
   1407             */
   1408          }
   \                     HAL_UART_RxCpltCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1409          
   1410          /**
   1411            * @brief  Rx Half Transfer completed callbacks.
   1412            * @param  huart: UART handle
   1413            * @retval None
   1414            */

   \                                 In section .text, align 2, keep-with-next
   1415          __weak void HAL_UART_RxHalfCpltCallback(UART_HandleTypeDef *huart)
   1416          {
   1417            /* Prevent unused argument(s) compilation warning */
   1418            UNUSED(huart);
   1419           
   1420            /* NOTE: This function should not be modified, when the callback is needed,
   1421                     the HAL_UART_RxHalfCpltCallback can be implemented in the user file
   1422             */
   1423          }
   \                     HAL_UART_RxHalfCpltCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1424          
   1425          /**
   1426            * @brief UART error callbacks
   1427            * @param huart: uart handle
   1428            * @retval None
   1429            */

   \                                 In section .text, align 2, keep-with-next
   1430           __weak void HAL_UART_ErrorCallback(UART_HandleTypeDef *huart)
   1431          {
   1432            /* Prevent unused argument(s) compilation warning */
   1433            UNUSED(huart);
   1434           
   1435            /* NOTE : This function should not be modified, when the callback is needed,
   1436                      the HAL_UART_ErrorCallback can be implemented in the user file
   1437             */ 
   1438          }
   \                     HAL_UART_ErrorCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1439          
   1440          /**
   1441            * @brief Send an amount of data in interrupt mode 
   1442            *         Function called under interruption only, once
   1443            *         interruptions have been enabled by HAL_UART_Transmit_IT()
   1444            * @param  huart: UART handle
   1445            * @retval HAL status
   1446            */
   1447          static HAL_StatusTypeDef UART_Transmit_IT(UART_HandleTypeDef *huart)
   1448          {
   1449            uint16_t* tmp;
   1450          
   1451            if ((huart->State == HAL_UART_STATE_BUSY_TX) || (huart->State == HAL_UART_STATE_BUSY_TX_RX))
   1452            {
   1453          
   1454              if(huart->TxXferCount == 0)
   1455              {
   1456                /* Disable the UART Transmit Data Register Empty Interrupt */
   1457                __HAL_UART_DISABLE_IT(huart, UART_IT_TXE);
   1458          
   1459                /* Check if a receive Process is ongoing or not */
   1460                if(huart->State == HAL_UART_STATE_BUSY_TX_RX) 
   1461                {
   1462                  huart->State = HAL_UART_STATE_BUSY_RX;
   1463                }
   1464                else
   1465                {      
   1466                  huart->State = HAL_UART_STATE_READY;
   1467                }
   1468                
   1469                /* Wait on TC flag to be able to start a second transfer */
   1470                if(UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TC, RESET, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
   1471                { 
   1472                  return HAL_TIMEOUT;
   1473                }
   1474          
   1475                HAL_UART_TxCpltCallback(huart);
   1476          
   1477                return HAL_OK;
   1478              }
   1479              else
   1480              {
   1481                if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
   1482                {
   1483                  tmp = (uint16_t*) huart->pTxBuffPtr;
   1484                  huart->Instance->TDR = (*tmp & (uint16_t)0x01FF);
   1485                  huart->pTxBuffPtr += 2;
   1486                } 
   1487                else
   1488                {
   1489                  huart->Instance->TDR = (uint8_t)(*huart->pTxBuffPtr++ & (uint8_t)0xFF);
   1490                }
   1491          
   1492                huart->TxXferCount--;
   1493                
   1494                return HAL_OK;
   1495              }
   1496            }
   1497            else
   1498            {
   1499              return HAL_BUSY;   
   1500            }
   1501          }
   1502          
   1503          /**
   1504            * @brief  Wrap up transmission in non-blocking mode.
   1505            * @param  huart: pointer to a UART_HandleTypeDef structure that contains
   1506            *                the configuration information for the specified UART module.
   1507            * @retval HAL status
   1508            */
   1509          static HAL_StatusTypeDef UART_EndTransmit_IT(UART_HandleTypeDef *huart)
   1510          {
   1511            /* Disable the UART Transmit Complete Interrupt */
   1512            __HAL_UART_DISABLE_IT(huart, UART_IT_TC);
   1513          
   1514            /* Check if a receive process is ongoing or not */
   1515            if(huart->State == HAL_UART_STATE_BUSY_TX_RX)
   1516            {
   1517              huart->State = HAL_UART_STATE_BUSY_RX;
   1518            }
   1519            else
   1520            {
   1521              huart->State = HAL_UART_STATE_READY;
   1522            }
   1523          
   1524            HAL_UART_TxCpltCallback(huart);
   1525          
   1526            return HAL_OK;
   1527          }
   1528          
   1529          /**
   1530            * @brief Receive an amount of data in interrupt mode 
   1531            *         Function called under interruption only, once
   1532            *         interruptions have been enabled by HAL_UART_Receive_IT()
   1533            * @param  huart: UART handle
   1534            * @retval HAL status
   1535            */

   \                                 In section .text, align 2, keep-with-next
   1536          static HAL_StatusTypeDef UART_Receive_IT(UART_HandleTypeDef *huart)
   1537          {
   \                     UART_Receive_IT: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB081             SUB      SP,SP,#+4
   1538            uint16_t* tmp;
   1539            uint16_t uhMask = huart->Mask;
   \   00000004   0xF8B0 0x105C      LDRH     R1,[R0, #+92]
   1540          
   1541            if((huart->State == HAL_UART_STATE_BUSY_RX) || (huart->State == HAL_UART_STATE_BUSY_TX_RX))
   \   00000008   0xF890 0x2069      LDRB     R2,[R0, #+105]
   \   0000000C   0x2A22             CMP      R2,#+34
   \   0000000E   0xBF1C             ITT      NE 
   \   00000010   0xF890 0x2069      LDRBNE   R2,[R0, #+105]
   \   00000014   0x2A32             CMPNE    R2,#+50
   \   00000016   0xD13A             BNE.N    ??UART_Receive_IT_0
   1542            {
   1543              
   1544              if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
   \   00000018   0x6882             LDR      R2,[R0, #+8]
   \   0000001A   0xF5B2 0x5F80      CMP      R2,#+4096
   \   0000001E   0xBF04             ITT      EQ 
   \   00000020   0x6902             LDREQ    R2,[R0, #+16]
   \   00000022   0x2A00             CMPEQ    R2,#+0
   \   00000024   0xD108             BNE.N    ??UART_Receive_IT_1
   1545              {
   1546                tmp = (uint16_t*) huart->pRxBuffPtr ;
   1547                *tmp = (uint16_t)(huart->Instance->RDR & uhMask);
   \   00000026   0x6802             LDR      R2,[R0, #+0]
   \   00000028   0x6A52             LDR      R2,[R2, #+36]
   \   0000002A   0x4011             ANDS     R1,R1,R2
   \   0000002C   0x6D42             LDR      R2,[R0, #+84]
   \   0000002E   0x8011             STRH     R1,[R2, #+0]
   1548                huart->pRxBuffPtr +=2;
   \   00000030   0x6D41             LDR      R1,[R0, #+84]
   \   00000032   0x1C89             ADDS     R1,R1,#+2
   \   00000034   0x6541             STR      R1,[R0, #+84]
   \   00000036   0xE006             B.N      ??UART_Receive_IT_2
   1549              }
   1550              else
   1551              {
   1552                *huart->pRxBuffPtr++ = (uint8_t)(huart->Instance->RDR & (uint8_t)uhMask); 
   \                     ??UART_Receive_IT_1: (+1)
   \   00000038   0x6D42             LDR      R2,[R0, #+84]
   \   0000003A   0x1C53             ADDS     R3,R2,#+1
   \   0000003C   0x6543             STR      R3,[R0, #+84]
   \   0000003E   0x6803             LDR      R3,[R0, #+0]
   \   00000040   0x6A5B             LDR      R3,[R3, #+36]
   \   00000042   0x4019             ANDS     R1,R1,R3
   \   00000044   0x7011             STRB     R1,[R2, #+0]
   1553              }
   1554          
   1555              if(--huart->RxXferCount == 0)
   \                     ??UART_Receive_IT_2: (+1)
   \   00000046   0xF8B0 0x105A      LDRH     R1,[R0, #+90]
   \   0000004A   0x1E49             SUBS     R1,R1,#+1
   \   0000004C   0xF8A0 0x105A      STRH     R1,[R0, #+90]
   \   00000050   0xB289             UXTH     R1,R1
   \   00000052   0xB9C9             CBNZ.N   R1,??UART_Receive_IT_3
   1556              {
   1557                __HAL_UART_DISABLE_IT(huart, UART_IT_RXNE);
   \   00000054   0x6801             LDR      R1,[R0, #+0]
   \   00000056   0x680A             LDR      R2,[R1, #+0]
   \   00000058   0xF022 0x0220      BIC      R2,R2,#0x20
   \   0000005C   0x600A             STR      R2,[R1, #+0]
   1558          
   1559                /* Check if a transmit Process is ongoing or not */
   1560                if(huart->State == HAL_UART_STATE_BUSY_TX_RX) 
   \   0000005E   0xF890 0x1069      LDRB     R1,[R0, #+105]
   \   00000062   0x2932             CMP      R1,#+50
   \   00000064   0xBF08             IT       EQ 
   \   00000066   0x2112             MOVEQ    R1,#+18
   1561                {
   1562                  huart->State = HAL_UART_STATE_BUSY_TX;
   \   00000068   0xD00A             BEQ.N    ??UART_Receive_IT_4
   1563                }
   1564                else
   1565                {
   1566                  /* Disable the UART Parity Error Interrupt */
   1567                  __HAL_UART_DISABLE_IT(huart, UART_IT_PE);
   \   0000006A   0x6801             LDR      R1,[R0, #+0]
   \   0000006C   0x680A             LDR      R2,[R1, #+0]
   \   0000006E   0xF422 0x7280      BIC      R2,R2,#0x100
   \   00000072   0x600A             STR      R2,[R1, #+0]
   1568          
   1569                  /* Disable the UART Error Interrupt: (Frame error, noise error, overrun error) */
   1570                  __HAL_UART_DISABLE_IT(huart, UART_IT_ERR);
   \   00000074   0x6801             LDR      R1,[R0, #+0]
   \   00000076   0x688A             LDR      R2,[R1, #+8]
   \   00000078   0x0852             LSRS     R2,R2,#+1
   \   0000007A   0x0052             LSLS     R2,R2,#+1
   \   0000007C   0x608A             STR      R2,[R1, #+8]
   1571          
   1572                  huart->State = HAL_UART_STATE_READY;
   \   0000007E   0x2101             MOVS     R1,#+1
   \                     ??UART_Receive_IT_4: (+1)
   \   00000080   0xF880 0x1069      STRB     R1,[R0, #+105]
   1573                }
   1574                
   1575                HAL_UART_RxCpltCallback(huart);
   \   00000084   0x.... 0x....      BL       HAL_UART_RxCpltCallback
   1576                
   1577                return HAL_OK;
   1578              }
   1579              
   1580              return HAL_OK;
   \                     ??UART_Receive_IT_3: (+1)
   \   00000088   0x2000             MOVS     R0,#+0
   \   0000008A   0xB001             ADD      SP,SP,#+4
   \   0000008C   0xBD00             POP      {PC}
   1581            }
   1582            else
   1583            {
   1584              return HAL_BUSY; 
   \                     ??UART_Receive_IT_0: (+1)
   \   0000008E   0x2002             MOVS     R0,#+2
   \   00000090   0xB001             ADD      SP,SP,#+4
   \   00000092   0xBD00             POP      {PC}             ;; return
   1585            }
   1586          }
   1587          
   1588          /**
   1589            * @}
   1590            */
   1591          
   1592          /** @defgroup UART_Exported_Functions_Group3 Peripheral Control functions 
   1593            *  @brief   UART control functions 
   1594            *
   1595          @verbatim   
   1596           ===============================================================================
   1597                                ##### Peripheral Control functions #####
   1598           ===============================================================================  
   1599              [..]
   1600              This subsection provides a set of functions allowing to control the UART.
   1601               (+) HAL_UART_GetState() API is helpful to check in run-time the state of the UART peripheral. 
   1602               (+) HAL_MultiProcessor_EnableMuteMode() API enables mute mode
   1603               (+) HAL_MultiProcessor_DisableMuteMode() API disables mute mode
   1604               (+) HAL_MultiProcessor_EnterMuteMode() API enters mute mode
   1605               (+) HAL_MultiProcessor_EnableMuteMode() API enables mute mode
   1606               (+) UART_SetConfig() API configures the UART peripheral
   1607               (+) UART_AdvFeatureConfig() API optionally configures the UART advanced features        
   1608               (+) UART_CheckIdleState() API ensures that TEACK and/or REACK are set after initialization 
   1609               (+) HAL_HalfDuplex_EnableTransmitter() API disables receiver and enables transmitter  
   1610               (+) HAL_HalfDuplex_EnableReceiver() API disables transmitter and enables receiver  
   1611               (+) HAL_LIN_SendBreak() API transmits the break characters           
   1612          @endverbatim
   1613            * @{
   1614            */
   1615          
   1616          /**
   1617            * @brief Enable UART in mute mode (doesn't mean UART enters mute mode;
   1618            * to enter mute mode, HAL_MultiProcessor_EnterMuteMode() API must be called)
   1619            * @param huart: UART handle
   1620            * @retval HAL status
   1621            */

   \                                 In section .text, align 2, keep-with-next
   1622          HAL_StatusTypeDef HAL_MultiProcessor_EnableMuteMode(UART_HandleTypeDef *huart)
   1623          {  
   1624            /* Process Locked */
   1625            __HAL_LOCK(huart);
   \                     HAL_MultiProcessor_EnableMuteMode: (+1)
   \   00000000   0xF890 0x1068      LDRB     R1,[R0, #+104]
   \   00000004   0x2901             CMP      R1,#+1
   \   00000006   0xD101             BNE.N    ??HAL_MultiProcessor_EnableMuteMode_0
   \   00000008   0x2002             MOVS     R0,#+2
   \   0000000A   0x4770             BX       LR
   \                     ??HAL_MultiProcessor_EnableMuteMode_0: (+1)
   \   0000000C   0x2101             MOVS     R1,#+1
   \   0000000E   0xF880 0x1068      STRB     R1,[R0, #+104]
   1626            
   1627            huart->State = HAL_UART_STATE_BUSY;
   \   00000012   0x2102             MOVS     R1,#+2
   \   00000014   0xF880 0x1069      STRB     R1,[R0, #+105]
   1628            
   1629            /* Enable USART mute mode by setting the MME bit in the CR1 register */
   1630            huart->Instance->CR1 |= USART_CR1_MME;
   \   00000018   0x6801             LDR      R1,[R0, #+0]
   \   0000001A   0x680A             LDR      R2,[R1, #+0]
   \   0000001C   0xF442 0x5200      ORR      R2,R2,#0x2000
   \   00000020   0x600A             STR      R2,[R1, #+0]
   1631            
   1632            huart->State = HAL_UART_STATE_READY;
   \   00000022   0x2101             MOVS     R1,#+1
   \   00000024   0xF880 0x1069      STRB     R1,[R0, #+105]
   1633            
   1634            return (UART_CheckIdleState(huart));
   \   00000028   0x....             B.N      UART_CheckIdleState
   1635          }
   1636          
   1637          /**
   1638            * @brief Disable UART mute mode (doesn't mean it actually wakes up the software,
   1639            * as it may not have been in mute mode at this very moment).
   1640            * @param huart: uart handle
   1641            * @retval HAL status
   1642            */

   \                                 In section .text, align 2, keep-with-next
   1643          HAL_StatusTypeDef HAL_MultiProcessor_DisableMuteMode(UART_HandleTypeDef *huart)
   1644          { 
   1645            /* Process Locked */
   1646            __HAL_LOCK(huart);
   \                     HAL_MultiProcessor_DisableMuteMode: (+1)
   \   00000000   0xF890 0x1068      LDRB     R1,[R0, #+104]
   \   00000004   0x2901             CMP      R1,#+1
   \   00000006   0xD101             BNE.N    ??HAL_MultiProcessor_DisableMuteMode_0
   \   00000008   0x2002             MOVS     R0,#+2
   \   0000000A   0x4770             BX       LR
   \                     ??HAL_MultiProcessor_DisableMuteMode_0: (+1)
   \   0000000C   0x2101             MOVS     R1,#+1
   \   0000000E   0xF880 0x1068      STRB     R1,[R0, #+104]
   1647            
   1648            huart->State = HAL_UART_STATE_BUSY;
   \   00000012   0x2102             MOVS     R1,#+2
   \   00000014   0xF880 0x1069      STRB     R1,[R0, #+105]
   1649            
   1650             /* Disable USART mute mode by clearing the MME bit in the CR1 register */
   1651            huart->Instance->CR1 &= ~(USART_CR1_MME);
   \   00000018   0x6801             LDR      R1,[R0, #+0]
   \   0000001A   0x680A             LDR      R2,[R1, #+0]
   \   0000001C   0xF422 0x5200      BIC      R2,R2,#0x2000
   \   00000020   0x600A             STR      R2,[R1, #+0]
   1652            
   1653            huart->State = HAL_UART_STATE_READY;
   \   00000022   0x2101             MOVS     R1,#+1
   \   00000024   0xF880 0x1069      STRB     R1,[R0, #+105]
   1654            
   1655            return (UART_CheckIdleState(huart));
   \   00000028   0x....             B.N      UART_CheckIdleState
   1656          }
   1657          
   1658          /**
   1659            * @brief Enter UART mute mode (means UART actually enters mute mode).
   1660            * To exit from mute mode, HAL_MultiProcessor_DisableMuteMode() API must be called. 
   1661            * @param huart: uart handle
   1662            * @retval HAL status
   1663            */

   \                                 In section .text, align 2, keep-with-next
   1664          void HAL_MultiProcessor_EnterMuteMode(UART_HandleTypeDef *huart)
   1665          {    
   1666            __HAL_UART_SEND_REQ(huart, UART_MUTE_MODE_REQUEST);
   \                     HAL_MultiProcessor_EnterMuteMode: (+1)
   \   00000000   0x6800             LDR      R0,[R0, #+0]
   \   00000002   0x6981             LDR      R1,[R0, #+24]
   \   00000004   0xF041 0x0104      ORR      R1,R1,#0x4
   \   00000008   0x6181             STR      R1,[R0, #+24]
   1667          }
   \   0000000A   0x4770             BX       LR               ;; return
   1668          
   1669          
   1670          
   1671          /**
   1672            * @brief return the UART state
   1673            * @param huart: uart handle
   1674            * @retval HAL state
   1675            */

   \                                 In section .text, align 2, keep-with-next
   1676          HAL_UART_StateTypeDef HAL_UART_GetState(UART_HandleTypeDef *huart)
   1677          {
   1678            return huart->State;
   \                     HAL_UART_GetState: (+1)
   \   00000000   0xF890 0x0069      LDRB     R0,[R0, #+105]
   \   00000004   0x4770             BX       LR               ;; return
   1679          }
   1680          
   1681          /**
   1682          * @brief  Return the UART error code
   1683          * @param  huart : pointer to a UART_HandleTypeDef structure that contains
   1684            *              the configuration information for the specified UART.
   1685          * @retval UART Error Code
   1686          */

   \                                 In section .text, align 2, keep-with-next
   1687          uint32_t HAL_UART_GetError(UART_HandleTypeDef *huart)
   1688          {
   1689            return huart->ErrorCode;
   \                     HAL_UART_GetError: (+1)
   \   00000000   0x6EC0             LDR      R0,[R0, #+108]
   \   00000002   0x4770             BX       LR               ;; return
   1690          }
   1691          
   1692          /**
   1693            * @brief Configure the UART peripheral 
   1694            * @param huart: uart handle
   1695            * @retval None
   1696            */

   \                                 In section .text, align 4, keep-with-next
   1697          HAL_StatusTypeDef UART_SetConfig(UART_HandleTypeDef *huart)
   1698          {
   \                     UART_SetConfig: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   1699            uint32_t tmpreg                     = 0x00000000;
   1700            UART_ClockSourceTypeDef clocksource = UART_CLOCKSOURCE_UNDEFINED;
   1701            uint16_t brrtemp                    = 0x0000;
   1702            uint16_t usartdiv                   = 0x0000;
   1703            HAL_StatusTypeDef ret               = HAL_OK;  
   1704            
   1705            /* Check the parameters */ 
   1706            assert_param(IS_UART_BAUDRATE(huart->Init.BaudRate));  
   1707            assert_param(IS_UART_WORD_LENGTH(huart->Init.WordLength));
   1708            assert_param(IS_UART_STOPBITS(huart->Init.StopBits));
   1709            assert_param(IS_UART_PARITY(huart->Init.Parity));
   1710            assert_param(IS_UART_MODE(huart->Init.Mode));
   1711            assert_param(IS_UART_HARDWARE_FLOW_CONTROL(huart->Init.HwFlowCtl));
   1712            assert_param(IS_UART_ONE_BIT_SAMPLE(huart->Init.OneBitSampling)); 
   1713          
   1714          
   1715            /*-------------------------- USART CR1 Configuration -----------------------*/
   1716            /* Clear M, PCE, PS, TE, RE and OVER8 bits and configure       
   1717             *  the UART Word Length, Parity, Mode and oversampling: 
   1718             *  set the M bits according to huart->Init.WordLength value 
   1719             *  set PCE and PS bits according to huart->Init.Parity value
   1720             *  set TE and RE bits according to huart->Init.Mode value
   1721             *  set OVER8 bit according to huart->Init.OverSampling value */
   1722            tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
   1723            MODIFY_REG(huart->Instance->CR1, UART_CR1_FIELDS, tmpreg);
   \   00000002   0x....             LDR.N    R6,??DataTable0  ;; 0xefff69f3
   \   00000004   0x4605             MOV      R5,R0
   \   00000006   0x2010             MOVS     R0,#+16
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0x682A             LDR      R2,[R5, #+0]
   \   0000000C   0x2400             MOVS     R4,#+0
   \   0000000E   0x6813             LDR      R3,[R2, #+0]
   \   00000010   0x4033             ANDS     R3,R6,R3
   \   00000012   0x68AE             LDR      R6,[R5, #+8]
   \   00000014   0x4333             ORRS     R3,R6,R3
   \   00000016   0x692E             LDR      R6,[R5, #+16]
   \   00000018   0x4333             ORRS     R3,R6,R3
   \   0000001A   0x696E             LDR      R6,[R5, #+20]
   \   0000001C   0x4333             ORRS     R3,R6,R3
   \   0000001E   0x69EE             LDR      R6,[R5, #+28]
   \   00000020   0x4333             ORRS     R3,R6,R3
   \   00000022   0x6013             STR      R3,[R2, #+0]
   1724          
   1725            /*-------------------------- USART CR2 Configuration -----------------------*/
   1726            /* Configure the UART Stop Bits: Set STOP[13:12] bits according 
   1727             * to huart->Init.StopBits value */
   1728            MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
   \   00000024   0x6853             LDR      R3,[R2, #+4]
   \   00000026   0x68EE             LDR      R6,[R5, #+12]
   \   00000028   0xF423 0x5340      BIC      R3,R3,#0x3000
   \   0000002C   0x4333             ORRS     R3,R6,R3
   \   0000002E   0x6053             STR      R3,[R2, #+4]
   1729            
   1730            /*-------------------------- USART CR3 Configuration -----------------------*/
   1731            /* Configure 
   1732             * - UART HardWare Flow Control: set CTSE and RTSE bits according 
   1733             *   to huart->Init.HwFlowCtl value 
   1734             * - one-bit sampling method versus three samples' majority rule according
   1735             *   to huart->Init.OneBitSampling */
   1736            tmpreg = (uint32_t)huart->Init.HwFlowCtl | huart->Init.OneBitSampling ;
   1737            MODIFY_REG(huart->Instance->CR3, (USART_CR3_RTSE | USART_CR3_CTSE | USART_CR3_ONEBIT), tmpreg);
   \   00000030   0x6893             LDR      R3,[R2, #+8]
   \   00000032   0x69AE             LDR      R6,[R5, #+24]
   \   00000034   0xF423 0x6330      BIC      R3,R3,#0xB00
   \   00000038   0x4333             ORRS     R3,R6,R3
   \   0000003A   0x6A2E             LDR      R6,[R5, #+32]
   \   0000003C   0x4333             ORRS     R3,R6,R3
   \   0000003E   0x6093             STR      R3,[R2, #+8]
   1738            
   1739            /*-------------------------- USART BRR Configuration -----------------------*/
   1740            UART_GETCLOCKSOURCE(huart, clocksource);
   \   00000040   0x....             LDR.N    R3,??DataTable0_1  ;; 0x40011000
   \   00000042   0x429A             CMP      R2,R3
   \   00000044   0xD10B             BNE.N    ??UART_SetConfig_4
   \   00000046   0x....             LDR.N    R3,??DataTable0_2  ;; 0x40023890
   \   00000048   0x681B             LDR      R3,[R3, #+0]
   \   0000004A   0xF003 0x0303      AND      R3,R3,#0x3
   \   0000004E   0x2B03             CMP      R3,#+3
   \   00000050   0xD82A             BHI.N    ??UART_SetConfig_5
   \   00000052   0xE8DF 0xF003      TBB      [PC, R3]
   \                     ??UART_SetConfig_0:
   \   00000056   0x71 0x17          DC8      0x71,0x17,0x2,0x28
   \              0x02 0x28    
   \                     ??UART_SetConfig_6: (+1)
   \   0000005A   0x2002             MOVS     R0,#+2
   \   0000005C   0xE024             B.N      ??UART_SetConfig_5
   \                     ??UART_SetConfig_4: (+1)
   \   0000005E   0x....             LDR.N    R3,??DataTable0_3  ;; 0x40004400
   \   00000060   0x429A             CMP      R2,R3
   \   00000062   0xD111             BNE.N    ??UART_SetConfig_7
   \   00000064   0x....             LDR.N    R3,??DataTable0_2  ;; 0x40023890
   \   00000066   0x681B             LDR      R3,[R3, #+0]
   \   00000068   0xF003 0x030C      AND      R3,R3,#0xC
   \   0000006C   0x2B0C             CMP      R3,#+12
   \   0000006E   0xD81B             BHI.N    ??UART_SetConfig_5
   \   00000070   0xE8DF 0xF003      TBB      [PC, R3]
   \                     ??UART_SetConfig_1:
   \   00000074   0x89 0x1A          DC8      0x89,0x1A,0x1A,0x1A
   \              0x1A 0x1A    
   \   00000078   0x08 0x1A          DC8      0x8,0x1A,0x1A,0x1A
   \              0x1A 0x1A    
   \   0000007C   0x07 0x1A          DC8      0x7,0x1A,0x1A,0x1A
   \              0x1A 0x1A    
   \   00000080   0x19 0x00          DC8      0x19,0x0
   \                     ??UART_SetConfig_8: (+1)
   \   00000082   0xE7EA             B.N      ??UART_SetConfig_6
   \                     ??UART_SetConfig_9: (+1)
   \   00000084   0x2004             MOVS     R0,#+4
   \   00000086   0xE00F             B.N      ??UART_SetConfig_5
   \                     ??UART_SetConfig_7: (+1)
   \   00000088   0x....             LDR.N    R3,??DataTable0_4  ;; 0x40004800
   \   0000008A   0x429A             CMP      R2,R3
   \   0000008C   0xD122             BNE.N    ??UART_SetConfig_10
   \   0000008E   0x....             LDR.N    R3,??DataTable0_2  ;; 0x40023890
   \   00000090   0x681B             LDR      R3,[R3, #+0]
   \   00000092   0xF013 0x0330      ANDS     R3,R3,#0x30
   \   00000096   0xF000 0x8076      BEQ.W    ??UART_SetConfig_11
   \   0000009A   0x2B10             CMP      R3,#+16
   \   0000009C   0xD0F2             BEQ.N    ??UART_SetConfig_9
   \   0000009E   0x2B20             CMP      R3,#+32
   \   000000A0   0xD0DB             BEQ.N    ??UART_SetConfig_6
   \   000000A2   0x2B30             CMP      R3,#+48
   \   000000A4   0xD100             BNE.N    ??UART_SetConfig_5
   \                     ??UART_SetConfig_12: (+1)
   \   000000A6   0x2008             MOVS     R0,#+8
   1741          
   1742            /* Check UART Over Sampling to set Baud Rate Register */
   1743            if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
   \                     ??UART_SetConfig_5: (+1)
   \   000000A8   0x69EB             LDR      R3,[R5, #+28]
   \   000000AA   0xF5B3 0x4F00      CMP      R3,#+32768
   \   000000AE   0xF040 0x8090      BNE.W    ??UART_SetConfig_13
   1744            { 
   1745              switch (clocksource)
   \   000000B2   0x2808             CMP      R0,#+8
   \   000000B4   0xF200 0x8082      BHI.W    ??UART_SetConfig_14
   \   000000B8   0xE8DF 0xF000      TBB      [PC, R0]
   \                     ??UART_SetConfig_2:
   \   000000BC   0x05 0x67          DC8      0x5,0x67,0x6E,0x80
   \              0x6E 0x80    
   \   000000C0   0x73 0x80          DC8      0x73,0x80,0x80,0x80
   \              0x80 0x80    
   \   000000C4   0x7A 0x00          DC8      0x7A,0x0
   1746              {
   1747              case UART_CLOCKSOURCE_PCLK1:
   1748                  usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HAL_RCC_GetPCLK1Freq(), huart->Init.BaudRate));
   \                     ??UART_SetConfig_15: (+1)
   \   000000C6   0x.... 0x....      BL       HAL_RCC_GetPCLK1Freq
   \   000000CA   0x6869             LDR      R1,[R5, #+4]
   \   000000CC   0x0040             LSLS     R0,R0,#+1
   \   000000CE   0xFBB0 0xF1F1      UDIV     R1,R0,R1
   1749                break;
   1750              case UART_CLOCKSOURCE_PCLK2:
   1751                  usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HAL_RCC_GetPCLK2Freq(), huart->Init.BaudRate));
   1752                break;
   1753              case UART_CLOCKSOURCE_HSI:
   1754                  usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HSI_VALUE, huart->Init.BaudRate)); 
   1755                break;
   1756              case UART_CLOCKSOURCE_SYSCLK:
   1757                  usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HAL_RCC_GetSysClockFreq(), huart->Init.BaudRate));
   1758                break;
   1759              case UART_CLOCKSOURCE_LSE:
   1760                  usartdiv = (uint16_t)(UART_DIV_SAMPLING8(LSE_VALUE, huart->Init.BaudRate)); 
   1761                break;
   \   000000D2   0xE074             B.N      ??UART_SetConfig_16
   \                     ??UART_SetConfig_10: (+1)
   \   000000D4   0x....             LDR.N    R3,??DataTable0_5  ;; 0x40004c00
   \   000000D6   0x429A             CMP      R2,R3
   \   000000D8   0xD10B             BNE.N    ??UART_SetConfig_17
   \   000000DA   0x....             LDR.N    R3,??DataTable0_2  ;; 0x40023890
   \   000000DC   0x681B             LDR      R3,[R3, #+0]
   \   000000DE   0xF013 0x03C0      ANDS     R3,R3,#0xC0
   \   000000E2   0xD050             BEQ.N    ??UART_SetConfig_11
   \   000000E4   0x2B40             CMP      R3,#+64
   \   000000E6   0xD0CD             BEQ.N    ??UART_SetConfig_9
   \   000000E8   0x2B80             CMP      R3,#+128
   \   000000EA   0xD0B6             BEQ.N    ??UART_SetConfig_6
   \   000000EC   0x2BC0             CMP      R3,#+192
   \                     ??UART_SetConfig_18: (+1)
   \   000000EE   0xD0DA             BEQ.N    ??UART_SetConfig_12
   \   000000F0   0xE7DA             B.N      ??UART_SetConfig_5
   \                     ??UART_SetConfig_17: (+1)
   \   000000F2   0x....             LDR.N    R3,??DataTable0_6  ;; 0x40005000
   \   000000F4   0x429A             CMP      R2,R3
   \   000000F6   0xD10D             BNE.N    ??UART_SetConfig_19
   \   000000F8   0x....             LDR.N    R3,??DataTable0_2  ;; 0x40023890
   \   000000FA   0x681B             LDR      R3,[R3, #+0]
   \   000000FC   0xF413 0x7340      ANDS     R3,R3,#0x300
   \   00000100   0xD041             BEQ.N    ??UART_SetConfig_11
   \   00000102   0xF5B3 0x7F80      CMP      R3,#+256
   \   00000106   0xD0BD             BEQ.N    ??UART_SetConfig_9
   \   00000108   0xF5B3 0x7F00      CMP      R3,#+512
   \   0000010C   0xD0A5             BEQ.N    ??UART_SetConfig_6
   \   0000010E   0xF5B3 0x7F40      CMP      R3,#+768
   \   00000112   0xE7EC             B.N      ??UART_SetConfig_18
   \                     ??UART_SetConfig_19: (+1)
   \   00000114   0x....             LDR.N    R3,??DataTable0_7  ;; 0x40011400
   \   00000116   0x429A             CMP      R2,R3
   \   00000118   0xD110             BNE.N    ??UART_SetConfig_20
   \   0000011A   0x....             LDR.N    R3,??DataTable0_2  ;; 0x40023890
   \   0000011C   0x681B             LDR      R3,[R3, #+0]
   \   0000011E   0xF413 0x6340      ANDS     R3,R3,#0xC00
   \   00000122   0xD009             BEQ.N    ??UART_SetConfig_21
   \   00000124   0xF5B3 0x6F80      CMP      R3,#+1024
   \   00000128   0xD0AC             BEQ.N    ??UART_SetConfig_9
   \   0000012A   0xF5B3 0x6F00      CMP      R3,#+2048
   \   0000012E   0xF43F 0xAF94      BEQ.W    ??UART_SetConfig_6
   \   00000132   0xF5B3 0x6F40      CMP      R3,#+3072
   \   00000136   0xE7DA             B.N      ??UART_SetConfig_18
   \                     ??UART_SetConfig_21: (+1)
   \   00000138   0x2001             MOVS     R0,#+1
   \   0000013A   0xE7B5             B.N      ??UART_SetConfig_5
   \                     ??UART_SetConfig_20: (+1)
   \   0000013C   0x....             LDR.N    R3,??DataTable0_8  ;; 0x40007800
   \   0000013E   0x429A             CMP      R2,R3
   \   00000140   0xD10E             BNE.N    ??UART_SetConfig_22
   \   00000142   0x....             LDR.N    R3,??DataTable0_2  ;; 0x40023890
   \   00000144   0x681B             LDR      R3,[R3, #+0]
   \   00000146   0xF413 0x5340      ANDS     R3,R3,#0x3000
   \   0000014A   0xD01C             BEQ.N    ??UART_SetConfig_11
   \   0000014C   0xF5B3 0x5F80      CMP      R3,#+4096
   \   00000150   0xD098             BEQ.N    ??UART_SetConfig_9
   \   00000152   0xF5B3 0x5F00      CMP      R3,#+8192
   \   00000156   0xF43F 0xAF80      BEQ.W    ??UART_SetConfig_6
   \   0000015A   0xF5B3 0x5F40      CMP      R3,#+12288
   \   0000015E   0xE7C6             B.N      ??UART_SetConfig_18
   \                     ??UART_SetConfig_22: (+1)
   \   00000160   0x....             LDR.N    R3,??DataTable0_9  ;; 0x40007c00
   \   00000162   0x429A             CMP      R2,R3
   \   00000164   0xD1A0             BNE.N    ??UART_SetConfig_5
   \   00000166   0x....             LDR.N    R3,??DataTable0_2  ;; 0x40023890
   \   00000168   0x681B             LDR      R3,[R3, #+0]
   \   0000016A   0xF413 0x4340      ANDS     R3,R3,#0xC000
   \   0000016E   0xD00A             BEQ.N    ??UART_SetConfig_11
   \   00000170   0xF5B3 0x4F80      CMP      R3,#+16384
   \   00000174   0xF43F 0xAF86      BEQ.W    ??UART_SetConfig_9
   \   00000178   0xF5B3 0x4F00      CMP      R3,#+32768
   \   0000017C   0xF43F 0xAF6D      BEQ.W    ??UART_SetConfig_6
   \   00000180   0xF5B3 0x4F40      CMP      R3,#+49152
   \   00000184   0xE7B3             B.N      ??UART_SetConfig_18
   \                     ??UART_SetConfig_11: (+1)
   \   00000186   0x2000             MOVS     R0,#+0
   \   00000188   0xE78E             B.N      ??UART_SetConfig_5
   \                     ??UART_SetConfig_23: (+1)
   \   0000018A   0x.... 0x....      BL       HAL_RCC_GetPCLK2Freq
   \   0000018E   0x6869             LDR      R1,[R5, #+4]
   \   00000190   0x0040             LSLS     R0,R0,#+1
   \   00000192   0xFBB0 0xF1F1      UDIV     R1,R0,R1
   \   00000196   0xE012             B.N      ??UART_SetConfig_16
   \                     ??UART_SetConfig_24: (+1)
   \   00000198   0x6869             LDR      R1,[R5, #+4]
   \   0000019A   0x....             LDR.N    R0,??DataTable0_10  ;; 0x1e84800
   \   0000019C   0xFBB0 0xF1F1      UDIV     R1,R0,R1
   \   000001A0   0xE00D             B.N      ??UART_SetConfig_16
   \                     ??UART_SetConfig_25: (+1)
   \   000001A2   0x.... 0x....      BL       HAL_RCC_GetSysClockFreq
   \   000001A6   0x6869             LDR      R1,[R5, #+4]
   \   000001A8   0x0040             LSLS     R0,R0,#+1
   \   000001AA   0xFBB0 0xF1F1      UDIV     R1,R0,R1
   \   000001AE   0xE006             B.N      ??UART_SetConfig_16
   \                     ??UART_SetConfig_26: (+1)
   \   000001B0   0x6869             LDR      R1,[R5, #+4]
   \   000001B2   0xF44F 0x3080      MOV      R0,#+65536
   \   000001B6   0xFBB0 0xF1F1      UDIV     R1,R0,R1
   \   000001BA   0xE000             B.N      ??UART_SetConfig_16
   1762                case UART_CLOCKSOURCE_UNDEFINED:                
   1763              default:
   1764                  ret = HAL_ERROR; 
   \                     ??UART_SetConfig_14: (+1)
   \   000001BC   0x2401             MOVS     R4,#+1
   1765                break;
   1766              }
   1767              
   1768              brrtemp = usartdiv & 0xFFF0;
   1769              brrtemp |= (uint16_t)((usartdiv & (uint16_t)0x000F) >> 1U);
   1770              huart->Instance->BRR = brrtemp;
   \                     ??UART_SetConfig_16: (+1)
   \   000001BE   0xF64F 0x70F0      MOVW     R0,#+65520
   \   000001C2   0x4008             ANDS     R0,R0,R1
   \   000001C4   0xF3C1 0x0142      UBFX     R1,R1,#+1,#+3
   \   000001C8   0x4308             ORRS     R0,R1,R0
   \   000001CA   0x6829             LDR      R1,[R5, #+0]
   \   000001CC   0x60C8             STR      R0,[R1, #+12]
   1771            }
   1772            else
   1773            {
   1774              switch (clocksource)
   1775              {
   1776              case UART_CLOCKSOURCE_PCLK1: 
   1777                  huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(HAL_RCC_GetPCLK1Freq(), huart->Init.BaudRate));
   1778                break;
   1779              case UART_CLOCKSOURCE_PCLK2: 
   1780                  huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(HAL_RCC_GetPCLK2Freq(), huart->Init.BaudRate));
   1781                break;
   1782              case UART_CLOCKSOURCE_HSI: 
   1783                  huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(HSI_VALUE, huart->Init.BaudRate)); 
   1784                break; 
   1785              case UART_CLOCKSOURCE_SYSCLK:  
   1786                  huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(HAL_RCC_GetSysClockFreq(), huart->Init.BaudRate));
   1787                break;  
   1788              case UART_CLOCKSOURCE_LSE:
   1789                  huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(LSE_VALUE, huart->Init.BaudRate)); 
   1790                break;
   1791                case UART_CLOCKSOURCE_UNDEFINED:                
   1792              default:
   1793                  ret = HAL_ERROR; 
   1794                break;
   1795              }
   1796            }
   1797          
   1798            return ret;   
   \   000001CE   0x4620             MOV      R0,R4
   \   000001D0   0xBD70             POP      {R4-R6,PC}
   \                     ??UART_SetConfig_13: (+1)
   \   000001D2   0x2808             CMP      R0,#+8
   \   000001D4   0xD821             BHI.N    ??UART_SetConfig_27
   \   000001D6   0xE8DF 0xF000      TBB      [PC, R0]
   \                     ??UART_SetConfig_3:
   \   000001DA   0x05 0x08          DC8      0x5,0x8,0xB,0x20
   \              0x0B 0x20    
   \   000001DE   0x0D 0x20          DC8      0xD,0x20,0x20,0x20
   \              0x20 0x20    
   \   000001E2   0x17 0x00          DC8      0x17,0x0
   \                     ??UART_SetConfig_28: (+1)
   \   000001E4   0x.... 0x....      BL       HAL_RCC_GetPCLK1Freq
   \   000001E8   0xE006             B.N      ??UART_SetConfig_29
   \                     ??UART_SetConfig_30: (+1)
   \   000001EA   0x.... 0x....      BL       HAL_RCC_GetPCLK2Freq
   \   000001EE   0xE003             B.N      ??UART_SetConfig_29
   \                     ??UART_SetConfig_31: (+1)
   \   000001F0   0x....             LDR.N    R0,??DataTable0_11  ;; 0xf42400
   \   000001F2   0xE00B             B.N      ??UART_SetConfig_32
   \                     ??UART_SetConfig_33: (+1)
   \   000001F4   0x.... 0x....      BL       HAL_RCC_GetSysClockFreq
   \                     ??UART_SetConfig_29: (+1)
   \   000001F8   0x6869             LDR      R1,[R5, #+4]
   \   000001FA   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   000001FE   0x6829             LDR      R1,[R5, #+0]
   \   00000200   0xB280             UXTH     R0,R0
   \   00000202   0x60C8             STR      R0,[R1, #+12]
   \   00000204   0x4620             MOV      R0,R4
   \   00000206   0xBD70             POP      {R4-R6,PC}
   \                     ??UART_SetConfig_34: (+1)
   \   00000208   0xF44F 0x4000      MOV      R0,#+32768
   \                     ??UART_SetConfig_32: (+1)
   \   0000020C   0x6869             LDR      R1,[R5, #+4]
   \   0000020E   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   00000212   0xB280             UXTH     R0,R0
   \   00000214   0x60D0             STR      R0,[R2, #+12]
   \   00000216   0x4620             MOV      R0,R4
   \   00000218   0xBD70             POP      {R4-R6,PC}
   \                     ??UART_SetConfig_27: (+1)
   \   0000021A   0x2401             MOVS     R4,#+1
   \   0000021C   0x4620             MOV      R0,R4
   \   0000021E   0xBD70             POP      {R4-R6,PC}       ;; return
   1799          
   1800          }
   1801          
   1802          
   1803          /**
   1804            * @brief Configure the UART peripheral advanced features 
   1805            * @param huart: uart handle  
   1806            * @retval None
   1807            */

   \                                 In section .text, align 2, keep-with-next
   1808          void UART_AdvFeatureConfig(UART_HandleTypeDef *huart)
   1809          {
   1810            /* Check whether the set of advanced features to configure is properly set */ 
   1811            assert_param(IS_UART_ADVFEATURE_INIT(huart->AdvancedInit.AdvFeatureInit));
   1812            
   1813            /* if required, configure TX pin active level inversion */
   1814            if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_TXINVERT_INIT))
   \                     UART_AdvFeatureConfig: (+1)
   \   00000000   0xF890 0x1024      LDRB     R1,[R0, #+36]
   \   00000004   0x07C9             LSLS     R1,R1,#+31
   \   00000006   0xD506             BPL.N    ??UART_AdvFeatureConfig_0
   1815            {
   1816              assert_param(IS_UART_ADVFEATURE_TXINV(huart->AdvancedInit.TxPinLevelInvert));
   1817              MODIFY_REG(huart->Instance->CR2, USART_CR2_TXINV, huart->AdvancedInit.TxPinLevelInvert);
   \   00000008   0x6801             LDR      R1,[R0, #+0]
   \   0000000A   0x684A             LDR      R2,[R1, #+4]
   \   0000000C   0x6A83             LDR      R3,[R0, #+40]
   \   0000000E   0xF422 0x3200      BIC      R2,R2,#0x20000
   \   00000012   0x431A             ORRS     R2,R3,R2
   \   00000014   0x604A             STR      R2,[R1, #+4]
   1818            }
   1819            
   1820            /* if required, configure RX pin active level inversion */
   1821            if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXINVERT_INIT))
   \                     ??UART_AdvFeatureConfig_0: (+1)
   \   00000016   0xF890 0x1024      LDRB     R1,[R0, #+36]
   \   0000001A   0x0789             LSLS     R1,R1,#+30
   \   0000001C   0xD506             BPL.N    ??UART_AdvFeatureConfig_1
   1822            {
   1823              assert_param(IS_UART_ADVFEATURE_RXINV(huart->AdvancedInit.RxPinLevelInvert));
   1824              MODIFY_REG(huart->Instance->CR2, USART_CR2_RXINV, huart->AdvancedInit.RxPinLevelInvert);
   \   0000001E   0x6801             LDR      R1,[R0, #+0]
   \   00000020   0x684A             LDR      R2,[R1, #+4]
   \   00000022   0x6AC3             LDR      R3,[R0, #+44]
   \   00000024   0xF422 0x3280      BIC      R2,R2,#0x10000
   \   00000028   0x431A             ORRS     R2,R3,R2
   \   0000002A   0x604A             STR      R2,[R1, #+4]
   1825            }
   1826            
   1827            /* if required, configure data inversion */
   1828            if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DATAINVERT_INIT))
   \                     ??UART_AdvFeatureConfig_1: (+1)
   \   0000002C   0xF890 0x1024      LDRB     R1,[R0, #+36]
   \   00000030   0x0749             LSLS     R1,R1,#+29
   \   00000032   0xD506             BPL.N    ??UART_AdvFeatureConfig_2
   1829            {
   1830              assert_param(IS_UART_ADVFEATURE_DATAINV(huart->AdvancedInit.DataInvert));
   1831              MODIFY_REG(huart->Instance->CR2, USART_CR2_DATAINV, huart->AdvancedInit.DataInvert);
   \   00000034   0x6801             LDR      R1,[R0, #+0]
   \   00000036   0x684A             LDR      R2,[R1, #+4]
   \   00000038   0x6B03             LDR      R3,[R0, #+48]
   \   0000003A   0xF422 0x2280      BIC      R2,R2,#0x40000
   \   0000003E   0x431A             ORRS     R2,R3,R2
   \   00000040   0x604A             STR      R2,[R1, #+4]
   1832            }
   1833            
   1834            /* if required, configure RX/TX pins swap */
   1835            if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_SWAP_INIT))
   \                     ??UART_AdvFeatureConfig_2: (+1)
   \   00000042   0xF890 0x1024      LDRB     R1,[R0, #+36]
   \   00000046   0x0709             LSLS     R1,R1,#+28
   \   00000048   0xD506             BPL.N    ??UART_AdvFeatureConfig_3
   1836            {
   1837              assert_param(IS_UART_ADVFEATURE_SWAP(huart->AdvancedInit.Swap));
   1838              MODIFY_REG(huart->Instance->CR2, USART_CR2_SWAP, huart->AdvancedInit.Swap);
   \   0000004A   0x6801             LDR      R1,[R0, #+0]
   \   0000004C   0x684A             LDR      R2,[R1, #+4]
   \   0000004E   0x6B43             LDR      R3,[R0, #+52]
   \   00000050   0xF422 0x4200      BIC      R2,R2,#0x8000
   \   00000054   0x431A             ORRS     R2,R3,R2
   \   00000056   0x604A             STR      R2,[R1, #+4]
   1839            }
   1840            
   1841            /* if required, configure RX overrun detection disabling */
   1842            if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXOVERRUNDISABLE_INIT))
   \                     ??UART_AdvFeatureConfig_3: (+1)
   \   00000058   0xF890 0x1024      LDRB     R1,[R0, #+36]
   \   0000005C   0x06C9             LSLS     R1,R1,#+27
   \   0000005E   0xD506             BPL.N    ??UART_AdvFeatureConfig_4
   1843            {
   1844              assert_param(IS_UART_OVERRUN(huart->AdvancedInit.OverrunDisable));  
   1845              MODIFY_REG(huart->Instance->CR3, USART_CR3_OVRDIS, huart->AdvancedInit.OverrunDisable);
   \   00000060   0x6801             LDR      R1,[R0, #+0]
   \   00000062   0x688A             LDR      R2,[R1, #+8]
   \   00000064   0x6B83             LDR      R3,[R0, #+56]
   \   00000066   0xF422 0x5280      BIC      R2,R2,#0x1000
   \   0000006A   0x431A             ORRS     R2,R3,R2
   \   0000006C   0x608A             STR      R2,[R1, #+8]
   1846            }
   1847            
   1848            /* if required, configure DMA disabling on reception error */
   1849            if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DMADISABLEONERROR_INIT))
   \                     ??UART_AdvFeatureConfig_4: (+1)
   \   0000006E   0xF890 0x1024      LDRB     R1,[R0, #+36]
   \   00000072   0x0689             LSLS     R1,R1,#+26
   \   00000074   0xD506             BPL.N    ??UART_AdvFeatureConfig_5
   1850            {
   1851              assert_param(IS_UART_ADVFEATURE_DMAONRXERROR(huart->AdvancedInit.DMADisableonRxError));   
   1852              MODIFY_REG(huart->Instance->CR3, USART_CR3_DDRE, huart->AdvancedInit.DMADisableonRxError);
   \   00000076   0x6801             LDR      R1,[R0, #+0]
   \   00000078   0x688A             LDR      R2,[R1, #+8]
   \   0000007A   0x6BC3             LDR      R3,[R0, #+60]
   \   0000007C   0xF422 0x5200      BIC      R2,R2,#0x2000
   \   00000080   0x431A             ORRS     R2,R3,R2
   \   00000082   0x608A             STR      R2,[R1, #+8]
   1853            }
   1854            
   1855            /* if required, configure auto Baud rate detection scheme */              
   1856            if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_AUTOBAUDRATE_INIT))
   \                     ??UART_AdvFeatureConfig_5: (+1)
   \   00000084   0xF890 0x1024      LDRB     R1,[R0, #+36]
   \   00000088   0x0649             LSLS     R1,R1,#+25
   \   0000008A   0xD510             BPL.N    ??UART_AdvFeatureConfig_6
   1857            {
   1858              assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATE(huart->AdvancedInit.AutoBaudRateEnable));
   1859              MODIFY_REG(huart->Instance->CR2, USART_CR2_ABREN, huart->AdvancedInit.AutoBaudRateEnable);
   \   0000008C   0x6801             LDR      R1,[R0, #+0]
   \   0000008E   0x684A             LDR      R2,[R1, #+4]
   \   00000090   0x6C03             LDR      R3,[R0, #+64]
   \   00000092   0xF422 0x1280      BIC      R2,R2,#0x100000
   \   00000096   0x431A             ORRS     R2,R3,R2
   \   00000098   0x604A             STR      R2,[R1, #+4]
   1860              /* set auto Baudrate detection parameters if detection is enabled */
   1861              if(huart->AdvancedInit.AutoBaudRateEnable == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE)
   \   0000009A   0x6C02             LDR      R2,[R0, #+64]
   \   0000009C   0xF5B2 0x1F80      CMP      R2,#+1048576
   \   000000A0   0xD105             BNE.N    ??UART_AdvFeatureConfig_6
   1862              {
   1863                assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATEMODE(huart->AdvancedInit.AutoBaudRateMode));
   1864                MODIFY_REG(huart->Instance->CR2, USART_CR2_ABRMODE, huart->AdvancedInit.AutoBaudRateMode);
   \   000000A2   0x684A             LDR      R2,[R1, #+4]
   \   000000A4   0x6C43             LDR      R3,[R0, #+68]
   \   000000A6   0xF422 0x02C0      BIC      R2,R2,#0x600000
   \   000000AA   0x431A             ORRS     R2,R3,R2
   \   000000AC   0x604A             STR      R2,[R1, #+4]
   1865              }
   1866            }
   1867            
   1868            /* if required, configure MSB first on communication line */  
   1869            if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_MSBFIRST_INIT))
   \                     ??UART_AdvFeatureConfig_6: (+1)
   \   000000AE   0xF890 0x1024      LDRB     R1,[R0, #+36]
   \   000000B2   0x0609             LSLS     R1,R1,#+24
   \   000000B4   0xD506             BPL.N    ??UART_AdvFeatureConfig_7
   1870            {
   1871              assert_param(IS_UART_ADVFEATURE_MSBFIRST(huart->AdvancedInit.MSBFirst));   
   1872              MODIFY_REG(huart->Instance->CR2, USART_CR2_MSBFIRST, huart->AdvancedInit.MSBFirst);
   \   000000B6   0x6801             LDR      R1,[R0, #+0]
   \   000000B8   0x684A             LDR      R2,[R1, #+4]
   \   000000BA   0x6C80             LDR      R0,[R0, #+72]
   \   000000BC   0xF422 0x2200      BIC      R2,R2,#0x80000
   \   000000C0   0x4310             ORRS     R0,R0,R2
   \   000000C2   0x6048             STR      R0,[R1, #+4]
   1873            }
   1874          }
   \                     ??UART_AdvFeatureConfig_7: (+1)
   \   000000C4   0x4770             BX       LR               ;; return
   1875          
   1876          
   1877          
   1878          /**
   1879            * @brief Check the UART Idle State
   1880            * @param huart: uart handle
   1881            * @retval HAL status
   1882            */

   \                                 In section .text, align 2, keep-with-next
   1883          HAL_StatusTypeDef UART_CheckIdleState(UART_HandleTypeDef *huart)
   1884          {
   \                     UART_CheckIdleState: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   1885            /* Initialize the UART ErrorCode */
   1886            huart->ErrorCode = HAL_UART_ERROR_NONE;
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x66E0             STR      R0,[R4, #+108]
   1887            
   1888            /* Check if the Transmitter is enabled */
   1889            if((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
   \   00000008   0x6820             LDR      R0,[R4, #+0]
   \   0000000A   0x6800             LDR      R0,[R0, #+0]
   \   0000000C   0x0700             LSLS     R0,R0,#+28
   \   0000000E   0xD50E             BPL.N    ??UART_CheckIdleState_0
   1890            {
   1891              /* Wait until TEACK flag is set */
   1892              if(UART_WaitOnFlagUntilTimeout(huart, USART_ISR_TEACK, RESET, HAL_UART_TIMEOUT_VALUE) != HAL_OK)  
   \   00000010   0x.... 0x....      BL       HAL_GetTick
   \   00000014   0x4606             MOV      R6,R0
   \   00000016   0xF06F 0x457E      MVN      R5,#-33554432
   \                     ??UART_CheckIdleState_1: (+1)
   \   0000001A   0x6820             LDR      R0,[R4, #+0]
   \   0000001C   0x69C0             LDR      R0,[R0, #+28]
   \   0000001E   0x0280             LSLS     R0,R0,#+10
   \   00000020   0xD405             BMI.N    ??UART_CheckIdleState_0
   \   00000022   0x.... 0x....      BL       HAL_GetTick
   \   00000026   0x1B80             SUBS     R0,R0,R6
   \   00000028   0x42A8             CMP      R0,R5
   \   0000002A   0xD3F6             BCC.N    ??UART_CheckIdleState_1
   \   0000002C   0xE011             B.N      ??UART_CheckIdleState_2
   1893              {
   1894                /* Timeout Occurred */
   1895                return HAL_TIMEOUT;
   1896              }
   1897            }
   1898            /* Check if the Receiver is enabled */
   1899            if((huart->Instance->CR1 & USART_CR1_RE) == USART_CR1_RE)
   \                     ??UART_CheckIdleState_0: (+1)
   \   0000002E   0x6820             LDR      R0,[R4, #+0]
   \   00000030   0x6800             LDR      R0,[R0, #+0]
   \   00000032   0x0740             LSLS     R0,R0,#+29
   \   00000034   0xD529             BPL.N    ??UART_CheckIdleState_3
   1900            {
   1901              /* Wait until REACK flag is set */
   1902              if(UART_WaitOnFlagUntilTimeout(huart, USART_ISR_REACK, RESET,  HAL_UART_TIMEOUT_VALUE) != HAL_OK)  
   \   00000036   0x.... 0x....      BL       HAL_GetTick
   \   0000003A   0x4606             MOV      R6,R0
   \   0000003C   0xF06F 0x457E      MVN      R5,#-33554432
   \                     ??UART_CheckIdleState_4: (+1)
   \   00000040   0x6820             LDR      R0,[R4, #+0]
   \   00000042   0x69C0             LDR      R0,[R0, #+28]
   \   00000044   0x0240             LSLS     R0,R0,#+9
   \   00000046   0xD420             BMI.N    ??UART_CheckIdleState_3
   \   00000048   0x.... 0x....      BL       HAL_GetTick
   \   0000004C   0x1B80             SUBS     R0,R0,R6
   \   0000004E   0x42A8             CMP      R0,R5
   \   00000050   0xD3F6             BCC.N    ??UART_CheckIdleState_4
   \                     ??UART_CheckIdleState_2: (+1)
   \   00000052   0x6820             LDR      R0,[R4, #+0]
   \   00000054   0x6801             LDR      R1,[R0, #+0]
   \   00000056   0xF021 0x0180      BIC      R1,R1,#0x80
   \   0000005A   0x6001             STR      R1,[R0, #+0]
   \   0000005C   0x6820             LDR      R0,[R4, #+0]
   \   0000005E   0x6801             LDR      R1,[R0, #+0]
   \   00000060   0xF021 0x0120      BIC      R1,R1,#0x20
   \   00000064   0x6001             STR      R1,[R0, #+0]
   \   00000066   0x6820             LDR      R0,[R4, #+0]
   \   00000068   0x6801             LDR      R1,[R0, #+0]
   \   0000006A   0xF421 0x7180      BIC      R1,R1,#0x100
   \   0000006E   0x6001             STR      R1,[R0, #+0]
   \   00000070   0x6820             LDR      R0,[R4, #+0]
   \   00000072   0x6881             LDR      R1,[R0, #+8]
   \   00000074   0x0849             LSRS     R1,R1,#+1
   \   00000076   0x0049             LSLS     R1,R1,#+1
   \   00000078   0x6081             STR      R1,[R0, #+8]
   \   0000007A   0x2001             MOVS     R0,#+1
   \   0000007C   0xF884 0x0069      STRB     R0,[R4, #+105]
   \   00000080   0x2000             MOVS     R0,#+0
   \   00000082   0xF884 0x0068      STRB     R0,[R4, #+104]
   1903              { 
   1904                /* Timeout Occurred */
   1905                return HAL_TIMEOUT;
   \   00000086   0x2003             MOVS     R0,#+3
   \   00000088   0xBD70             POP      {R4-R6,PC}
   1906              }
   1907            }
   1908            
   1909            /* Initialize the UART State */
   1910            huart->State= HAL_UART_STATE_READY;
   \                     ??UART_CheckIdleState_3: (+1)
   \   0000008A   0x2001             MOVS     R0,#+1
   \   0000008C   0xF884 0x0069      STRB     R0,[R4, #+105]
   1911              
   1912            /* Process Unlocked */
   1913            __HAL_UNLOCK(huart);
   \   00000090   0x2000             MOVS     R0,#+0
   \   00000092   0xF884 0x0068      STRB     R0,[R4, #+104]
   1914            
   1915            return HAL_OK;
   \   00000096   0xBD70             POP      {R4-R6,PC}       ;; return
   1916          }
   1917          
   1918          /**
   1919            * @brief  Enables the UART transmitter and disables the UART receiver.
   1920            * @param  huart: UART handle
   1921            * @retval HAL status
   1922            * @retval None
   1923            */

   \                                 In section .text, align 2, keep-with-next
   1924          HAL_StatusTypeDef HAL_HalfDuplex_EnableTransmitter(UART_HandleTypeDef *huart)
   1925          {
   1926            /* Process Locked */
   1927            __HAL_LOCK(huart);
   \                     HAL_HalfDuplex_EnableTransmitter: (+1)
   \   00000000   0xF890 0x1068      LDRB     R1,[R0, #+104]
   \   00000004   0x2901             CMP      R1,#+1
   \   00000006   0xD101             BNE.N    ??HAL_HalfDuplex_EnableTransmitter_0
   \   00000008   0x2002             MOVS     R0,#+2
   \   0000000A   0x4770             BX       LR
   \                     ??HAL_HalfDuplex_EnableTransmitter_0: (+1)
   \   0000000C   0x2101             MOVS     R1,#+1
   \   0000000E   0xF880 0x1068      STRB     R1,[R0, #+104]
   1928            huart->State = HAL_UART_STATE_BUSY;
   \   00000012   0x2102             MOVS     R1,#+2
   \   00000014   0xF880 0x1069      STRB     R1,[R0, #+105]
   1929            
   1930            /* Clear TE and RE bits */
   1931            CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TE | USART_CR1_RE));
   \   00000018   0x6801             LDR      R1,[R0, #+0]
   \   0000001A   0x680A             LDR      R2,[R1, #+0]
   \   0000001C   0xF022 0x020C      BIC      R2,R2,#0xC
   \   00000020   0x600A             STR      R2,[R1, #+0]
   1932            /* Enable the USART's transmit interface by setting the TE bit in the USART CR1 register */
   1933            SET_BIT(huart->Instance->CR1, USART_CR1_TE);
   \   00000022   0x6801             LDR      R1,[R0, #+0]
   \   00000024   0x680A             LDR      R2,[R1, #+0]
   \   00000026   0xF042 0x0208      ORR      R2,R2,#0x8
   \   0000002A   0x600A             STR      R2,[R1, #+0]
   1934           
   1935            huart->State= HAL_UART_STATE_READY;
   \   0000002C   0x2101             MOVS     R1,#+1
   \   0000002E   0xF880 0x1069      STRB     R1,[R0, #+105]
   1936            /* Process Unlocked */
   1937            __HAL_UNLOCK(huart);
   \   00000032   0x2100             MOVS     R1,#+0
   \   00000034   0xF880 0x1068      STRB     R1,[R0, #+104]
   1938            
   1939            return HAL_OK;
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0x4770             BX       LR               ;; return
   1940          }
   1941          
   1942          /**
   1943            * @brief  Enables the UART receiver and disables the UART transmitter.
   1944            * @param  huart: UART handle
   1945            * @retval HAL status
   1946            */

   \                                 In section .text, align 2, keep-with-next
   1947          HAL_StatusTypeDef HAL_HalfDuplex_EnableReceiver(UART_HandleTypeDef *huart)
   1948          {
   1949            /* Process Locked */
   1950            __HAL_LOCK(huart);
   \                     HAL_HalfDuplex_EnableReceiver: (+1)
   \   00000000   0xF890 0x1068      LDRB     R1,[R0, #+104]
   \   00000004   0x2901             CMP      R1,#+1
   \   00000006   0xD101             BNE.N    ??HAL_HalfDuplex_EnableReceiver_0
   \   00000008   0x2002             MOVS     R0,#+2
   \   0000000A   0x4770             BX       LR
   \                     ??HAL_HalfDuplex_EnableReceiver_0: (+1)
   \   0000000C   0x2101             MOVS     R1,#+1
   \   0000000E   0xF880 0x1068      STRB     R1,[R0, #+104]
   1951            huart->State = HAL_UART_STATE_BUSY;
   \   00000012   0x2102             MOVS     R1,#+2
   \   00000014   0xF880 0x1069      STRB     R1,[R0, #+105]
   1952          
   1953            /* Clear TE and RE bits */
   1954            CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TE | USART_CR1_RE));
   \   00000018   0x6801             LDR      R1,[R0, #+0]
   \   0000001A   0x680A             LDR      R2,[R1, #+0]
   \   0000001C   0xF022 0x020C      BIC      R2,R2,#0xC
   \   00000020   0x600A             STR      R2,[R1, #+0]
   1955            /* Enable the USART's receive interface by setting the RE bit in the USART CR1 register */
   1956            SET_BIT(huart->Instance->CR1, USART_CR1_RE);
   \   00000022   0x6801             LDR      R1,[R0, #+0]
   \   00000024   0x680A             LDR      R2,[R1, #+0]
   \   00000026   0xF042 0x0204      ORR      R2,R2,#0x4
   \   0000002A   0x600A             STR      R2,[R1, #+0]
   1957          
   1958            huart->State = HAL_UART_STATE_READY;
   \   0000002C   0x2101             MOVS     R1,#+1
   \   0000002E   0xF880 0x1069      STRB     R1,[R0, #+105]
   1959            /* Process Unlocked */
   1960            __HAL_UNLOCK(huart);
   \   00000032   0x2100             MOVS     R1,#+0
   \   00000034   0xF880 0x1068      STRB     R1,[R0, #+104]
   1961          
   1962            return HAL_OK;
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0x4770             BX       LR               ;; return
   1963          }
   1964          
   1965          
   1966          /**
   1967            * @brief  Transmits break characters.
   1968            * @param  huart: UART handle
   1969            * @retval HAL status
   1970            */

   \                                 In section .text, align 2, keep-with-next
   1971          HAL_StatusTypeDef HAL_LIN_SendBreak(UART_HandleTypeDef *huart)
   1972          {
   1973            /* Check the parameters */
   1974            assert_param(IS_UART_INSTANCE(huart->Instance));
   1975            
   1976            /* Process Locked */
   1977            __HAL_LOCK(huart);
   \                     HAL_LIN_SendBreak: (+1)
   \   00000000   0xF890 0x1068      LDRB     R1,[R0, #+104]
   \   00000004   0x2901             CMP      R1,#+1
   \   00000006   0xD101             BNE.N    ??HAL_LIN_SendBreak_0
   \   00000008   0x2002             MOVS     R0,#+2
   \   0000000A   0x4770             BX       LR
   \                     ??HAL_LIN_SendBreak_0: (+1)
   \   0000000C   0x2101             MOVS     R1,#+1
   \   0000000E   0xF880 0x1068      STRB     R1,[R0, #+104]
   1978            
   1979            huart->State = HAL_UART_STATE_BUSY;
   \   00000012   0x2102             MOVS     R1,#+2
   \   00000014   0xF880 0x1069      STRB     R1,[R0, #+105]
   1980            
   1981            /* Send break characters */
   1982            huart->Instance->RQR |= UART_SENDBREAK_REQUEST;  
   \   00000018   0x6801             LDR      R1,[R0, #+0]
   \   0000001A   0x698A             LDR      R2,[R1, #+24]
   \   0000001C   0xF042 0x0202      ORR      R2,R2,#0x2
   \   00000020   0x618A             STR      R2,[R1, #+24]
   1983           
   1984            huart->State = HAL_UART_STATE_READY;
   \   00000022   0x2101             MOVS     R1,#+1
   \   00000024   0xF880 0x1069      STRB     R1,[R0, #+105]
   1985            
   1986            /* Process Unlocked */
   1987            __HAL_UNLOCK(huart);
   \   00000028   0x2100             MOVS     R1,#+0
   \   0000002A   0xF880 0x1068      STRB     R1,[R0, #+104]
   1988            
   1989            return HAL_OK; 
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0x4770             BX       LR               ;; return
   1990          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0:
   \   00000000   0xEFFF69F3         DC32     0xefff69f3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_1:
   \   00000000   0x40011000         DC32     0x40011000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_2:
   \   00000000   0x40023890         DC32     0x40023890

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_3:
   \   00000000   0x40004400         DC32     0x40004400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_4:
   \   00000000   0x40004800         DC32     0x40004800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_5:
   \   00000000   0x40004C00         DC32     0x40004c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_6:
   \   00000000   0x40005000         DC32     0x40005000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_7:
   \   00000000   0x40011400         DC32     0x40011400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_8:
   \   00000000   0x40007800         DC32     0x40007800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_9:
   \   00000000   0x40007C00         DC32     0x40007c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_10:
   \   00000000   0x01E84800         DC32     0x1e84800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_11:
   \   00000000   0x00F42400         DC32     0xf42400
   1991          
   1992          
   1993          /**
   1994            * @}
   1995            */
   1996          
   1997          /**
   1998            * @}
   1999            */
   2000          
   2001          #endif /* HAL_UART_MODULE_ENABLED */
   2002          /**
   2003            * @}
   2004            */
   2005          
   2006          /**
   2007            * @}
   2008            */
   2009          
   2010          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   HAL_HalfDuplex_EnableReceiver
       0   HAL_HalfDuplex_EnableTransmitter
       8   HAL_HalfDuplex_Init
         8   -> HAL_UART_MspInit
         8   -> UART_AdvFeatureConfig
         0   -> UART_CheckIdleState
         8   -> UART_SetConfig
      16   HAL_LIN_Init
        16   -> HAL_UART_MspInit
        16   -> UART_AdvFeatureConfig
         0   -> UART_CheckIdleState
        16   -> UART_SetConfig
       0   HAL_LIN_SendBreak
       0   HAL_MultiProcessor_DisableMuteMode
         0   -> UART_CheckIdleState
       0   HAL_MultiProcessor_EnableMuteMode
         0   -> UART_CheckIdleState
       0   HAL_MultiProcessor_EnterMuteMode
      16   HAL_MultiProcessor_Init
        16   -> HAL_UART_MspInit
        16   -> UART_AdvFeatureConfig
         0   -> UART_CheckIdleState
        16   -> UART_SetConfig
       0   HAL_UART_DMAPause
       0   HAL_UART_DMAResume
       8   HAL_UART_DMAStop
         8   -> HAL_DMA_Abort
       8   HAL_UART_DeInit
         8   -> HAL_UART_MspDeInit
       0   HAL_UART_ErrorCallback
       0   HAL_UART_GetError
       0   HAL_UART_GetState
      16   HAL_UART_IRQHandler
        16   -> HAL_GetTick
        16   -> HAL_UART_ErrorCallback
        16   -> HAL_UART_TxCpltCallback
        16   -> UART_Receive_IT
       8   HAL_UART_Init
         8   -> HAL_UART_MspInit
         8   -> UART_AdvFeatureConfig
         0   -> UART_CheckIdleState
         8   -> UART_SetConfig
       0   HAL_UART_MspDeInit
       0   HAL_UART_MspInit
      24   HAL_UART_Receive
        24   -> HAL_GetTick
       8   HAL_UART_Receive_DMA
         8   -> HAL_DMA_Start_IT
       0   HAL_UART_Receive_IT
       0   HAL_UART_RxCpltCallback
       0   HAL_UART_RxHalfCpltCallback
      24   HAL_UART_Transmit
        24   -> HAL_GetTick
       8   HAL_UART_Transmit_DMA
         8   -> HAL_DMA_Start_IT
       0   HAL_UART_Transmit_IT
       0   HAL_UART_TxCpltCallback
       0   HAL_UART_TxHalfCpltCallback
       0   UART_AdvFeatureConfig
      16   UART_CheckIdleState
        16   -> HAL_GetTick
       8   UART_DMAError
         8   -> HAL_UART_ErrorCallback
       8   UART_DMAReceiveCplt
         8   -> HAL_UART_RxCpltCallback
       8   UART_DMARxHalfCplt
         8   -> HAL_UART_RxHalfCpltCallback
       8   UART_DMATransmitCplt
         8   -> HAL_UART_TxCpltCallback
       8   UART_DMATxHalfCplt
         8   -> HAL_UART_TxHalfCpltCallback
       8   UART_Receive_IT
         8   -> HAL_UART_RxCpltCallback
      16   UART_SetConfig
        16   -> HAL_RCC_GetPCLK1Freq
        16   -> HAL_RCC_GetPCLK2Freq
        16   -> HAL_RCC_GetSysClockFreq
      24   UART_WaitOnFlagUntilTimeout
        24   -> HAL_GetTick


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable0
       4  ??DataTable0_1
       4  ??DataTable0_10
       4  ??DataTable0_11
       4  ??DataTable0_2
       4  ??DataTable0_3
       4  ??DataTable0_4
       4  ??DataTable0_5
       4  ??DataTable0_6
       4  ??DataTable0_7
       4  ??DataTable0_8
       4  ??DataTable0_9
      60  HAL_HalfDuplex_EnableReceiver
      60  HAL_HalfDuplex_EnableTransmitter
     112  HAL_HalfDuplex_Init
     132  HAL_LIN_Init
      50  HAL_LIN_SendBreak
      42  HAL_MultiProcessor_DisableMuteMode
      42  HAL_MultiProcessor_EnableMuteMode
      12  HAL_MultiProcessor_EnterMuteMode
     138  HAL_MultiProcessor_Init
      82  HAL_UART_DMAPause
     104  HAL_UART_DMAResume
      50  HAL_UART_DMAStop
      60  HAL_UART_DeInit
       2  HAL_UART_ErrorCallback
       4  HAL_UART_GetError
       6  HAL_UART_GetState
     420  HAL_UART_IRQHandler
     102  HAL_UART_Init
       2  HAL_UART_MspDeInit
       2  HAL_UART_MspInit
     316  HAL_UART_Receive
     134  HAL_UART_Receive_DMA
     172  HAL_UART_Receive_IT
       2  HAL_UART_RxCpltCallback
       2  HAL_UART_RxHalfCpltCallback
     282  HAL_UART_Transmit
     142  HAL_UART_Transmit_DMA
     106  HAL_UART_Transmit_IT
       2  HAL_UART_TxCpltCallback
       2  HAL_UART_TxHalfCpltCallback
     198  UART_AdvFeatureConfig
     152  UART_CheckIdleState
      38  UART_DMAError
      56  UART_DMAReceiveCplt
      14  UART_DMARxHalfCplt
      52  UART_DMATransmitCplt
      14  UART_DMATxHalfCplt
     148  UART_Receive_IT
     544  UART_SetConfig
     146  UART_WaitOnFlagUntilTimeout

 
 4 052 bytes in section .text
 
 4 052 bytes of CODE memory

Errors: none
Warnings: none
