###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.2.10312/W32 for ARM       19/Feb/2016  17:44:16
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\Src\usbd_conf.c
#    Command line =  
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\Src\usbd_conf.c
#        -D USE_HAL_DRIVER -D STM32F746xx -D USE_STM32746G_DISCO -D
#        USE_IOEXPANDER -D USE_USB_FS -lC
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
#        -lA
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
#        -o
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M7 -e --fpu=VFPv5_sp --dlib_config "D:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.3\arm\INC\c\DLib_Config_Full.h"
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\CMSIS\Device\ST\STM32F7xx\Include\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\STM32F7xx_HAL_Driver\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\STM32746G-Discovery\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\Components\Common\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Log\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Fonts\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\CPU\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_Device_Library\Core\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Core\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Class\MSC\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\drivers\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_Audio\Addons\PDM\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_Device_Library\Class\AUDIO\Inc\
#        -On --use_c++_inline --require_prototypes -I "D:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.3\arm\CMSIS\Include\" -D
#        ARM_MATH_CM7
#    List file    =  
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List\usbd_conf.lst
#    Object file  =  
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj\usbd_conf.o
#
###############################################################################

D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\Src\usbd_conf.c
      1          /**
      2            ******************************************************************************
      3            * @file    USB_Device/AUDIO_Standalone/Src/usbd_conf.c
      4            * @author  MCD Application Team
      5            * @version V1.0.0
      6            * @date    25-June-2015
      7            * @brief   This file implements the USB Device library callbacks and MSP
      8            ******************************************************************************
      9            * @attention
     10            *
     11            * <h2><center>&copy; COPYRIGHT(c) 2015 STMicroelectronics</center></h2>
     12            *
     13            * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
     14            * You may not use this file except in compliance with the License.
     15            * You may obtain a copy of the License at:
     16            *
     17            *        http://www.st.com/software_license_agreement_liberty_v2
     18            *
     19            * Unless required by applicable law or agreed to in writing, software 
     20            * distributed under the License is distributed on an "AS IS" BASIS, 
     21            * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     22            * See the License for the specific language governing permissions and
     23            * limitations under the License.
     24            *
     25            ******************************************************************************
     26            */
     27          
     28          /* Includes ------------------------------------------------------------------*/
     29          #include "main.h"
     30          
     31          /* Private typedef -----------------------------------------------------------*/
     32          /* Private define ------------------------------------------------------------*/
     33          /* Private macro -------------------------------------------------------------*/
     34          /* Private variables ---------------------------------------------------------*/

   \                                 In section .bss, align 4
     35          PCD_HandleTypeDef hpcd;
   \                     hpcd:
   \   00000000                      DS8 960
     36          
     37          /* Private function prototypes -----------------------------------------------*/
     38          /* Private functions ---------------------------------------------------------*/
     39            
     40          /*******************************************************************************
     41                                 PCD BSP Routines
     42          *******************************************************************************/
     43          
     44          /**
     45            * @brief  Initializes the PCD MSP.
     46            * @param  hpcd: PCD handle
     47            * @retval None
     48            */

   \                                 In section .text, align 2, keep-with-next
     49          void HAL_PCD_MspInit(PCD_HandleTypeDef *hpcd)
     50          {
   \                     HAL_PCD_MspInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB088             SUB      SP,SP,#+32
   \   00000004   0x0004             MOVS     R4,R0
     51            GPIO_InitTypeDef  GPIO_InitStruct;
     52            
     53            if(hpcd->Instance == USB_OTG_FS)
   \   00000006   0x6820             LDR      R0,[R4, #+0]
   \   00000008   0xF1B0 0x4FA0      CMP      R0,#+1342177280
   \   0000000C   0xD13E             BNE.N    ??HAL_PCD_MspInit_0
     54            {
     55              /* Configure USB FS GPIOs */
     56              __HAL_RCC_GPIOA_CLK_ENABLE();
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable2  ;; 0x40023830
   \   00000012   0x6800             LDR      R0,[R0, #+0]
   \   00000014   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000018   0x.... 0x....      LDR.W    R1,??DataTable2  ;; 0x40023830
   \   0000001C   0x6008             STR      R0,[R1, #+0]
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable2  ;; 0x40023830
   \   00000022   0x6800             LDR      R0,[R0, #+0]
   \   00000024   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   00000028   0x9000             STR      R0,[SP, #+0]
   \   0000002A   0x9800             LDR      R0,[SP, #+0]
     57              
     58              /* Configure DM DP Pins */
     59              GPIO_InitStruct.Pin = (GPIO_PIN_11 | GPIO_PIN_12);
   \   0000002C   0xF44F 0x50C0      MOV      R0,#+6144
   \   00000030   0x9001             STR      R0,[SP, #+4]
     60              GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
   \   00000032   0x2002             MOVS     R0,#+2
   \   00000034   0x9002             STR      R0,[SP, #+8]
     61              GPIO_InitStruct.Pull = GPIO_NOPULL;
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0x9003             STR      R0,[SP, #+12]
     62              GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
   \   0000003A   0x2003             MOVS     R0,#+3
   \   0000003C   0x9004             STR      R0,[SP, #+16]
     63              GPIO_InitStruct.Alternate = GPIO_AF10_OTG_FS;
   \   0000003E   0x200A             MOVS     R0,#+10
   \   00000040   0x9005             STR      R0,[SP, #+20]
     64              HAL_GPIO_Init(GPIOA, &GPIO_InitStruct); 
   \   00000042   0xA901             ADD      R1,SP,#+4
   \   00000044   0x....             LDR.N    R0,??DataTable2_1  ;; 0x40020000
   \   00000046   0x.... 0x....      BL       HAL_GPIO_Init
     65              
     66              /* Enable USB FS Clock */
     67              __HAL_RCC_USB_OTG_FS_CLK_ENABLE();
   \   0000004A   0x....             LDR.N    R0,??DataTable2_2  ;; 0x40023834
   \   0000004C   0x6800             LDR      R0,[R0, #+0]
   \   0000004E   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   00000052   0x....             LDR.N    R1,??DataTable2_2  ;; 0x40023834
   \   00000054   0x6008             STR      R0,[R1, #+0]
   \   00000056   0x....             LDR.N    R0,??DataTable2_2  ;; 0x40023834
   \   00000058   0x6800             LDR      R0,[R0, #+0]
   \   0000005A   0xF010 0x0080      ANDS     R0,R0,#0x80
   \   0000005E   0x9006             STR      R0,[SP, #+24]
   \   00000060   0x9806             LDR      R0,[SP, #+24]
   \   00000062   0x....             LDR.N    R0,??DataTable2_3  ;; 0x40023844
   \   00000064   0x6800             LDR      R0,[R0, #+0]
   \   00000066   0xF450 0x4080      ORRS     R0,R0,#0x4000
   \   0000006A   0x....             LDR.N    R1,??DataTable2_3  ;; 0x40023844
   \   0000006C   0x6008             STR      R0,[R1, #+0]
   \   0000006E   0x....             LDR.N    R0,??DataTable2_3  ;; 0x40023844
   \   00000070   0x6800             LDR      R0,[R0, #+0]
   \   00000072   0xF410 0x4080      ANDS     R0,R0,#0x4000
   \   00000076   0x9000             STR      R0,[SP, #+0]
   \   00000078   0x9800             LDR      R0,[SP, #+0]
     68              
     69              /* Set USBFS Interrupt priority */
     70              HAL_NVIC_SetPriority(OTG_FS_IRQn, 5, 0);
   \   0000007A   0x2200             MOVS     R2,#+0
   \   0000007C   0x2105             MOVS     R1,#+5
   \   0000007E   0x2043             MOVS     R0,#+67
   \   00000080   0x.... 0x....      BL       HAL_NVIC_SetPriority
     71              
     72              /* Enable USBFS Interrupt */
     73              HAL_NVIC_EnableIRQ(OTG_FS_IRQn);
   \   00000084   0x2043             MOVS     R0,#+67
   \   00000086   0x.... 0x....      BL       HAL_NVIC_EnableIRQ
   \   0000008A   0xE0A1             B.N      ??HAL_PCD_MspInit_1
     74            }
     75            else if(hpcd->Instance == USB_OTG_HS)
   \                     ??HAL_PCD_MspInit_0: (+1)
   \   0000008C   0x6820             LDR      R0,[R4, #+0]
   \   0000008E   0x....             LDR.N    R1,??DataTable2_4  ;; 0x40040000
   \   00000090   0x4288             CMP      R0,R1
   \   00000092   0xF040 0x809D      BNE.W    ??HAL_PCD_MspInit_1
     76            {
     77              /* Configure USB FS GPIOs */
     78              __HAL_RCC_GPIOA_CLK_ENABLE();
   \   00000096   0x....             LDR.N    R0,??DataTable2  ;; 0x40023830
   \   00000098   0x6800             LDR      R0,[R0, #+0]
   \   0000009A   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   0000009E   0x....             LDR.N    R1,??DataTable2  ;; 0x40023830
   \   000000A0   0x6008             STR      R0,[R1, #+0]
   \   000000A2   0x....             LDR.N    R0,??DataTable2  ;; 0x40023830
   \   000000A4   0x6800             LDR      R0,[R0, #+0]
   \   000000A6   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   000000AA   0x9000             STR      R0,[SP, #+0]
   \   000000AC   0x9800             LDR      R0,[SP, #+0]
     79              __HAL_RCC_GPIOB_CLK_ENABLE();
   \   000000AE   0x....             LDR.N    R0,??DataTable2  ;; 0x40023830
   \   000000B0   0x6800             LDR      R0,[R0, #+0]
   \   000000B2   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   000000B6   0x....             LDR.N    R1,??DataTable2  ;; 0x40023830
   \   000000B8   0x6008             STR      R0,[R1, #+0]
   \   000000BA   0x....             LDR.N    R0,??DataTable2  ;; 0x40023830
   \   000000BC   0x6800             LDR      R0,[R0, #+0]
   \   000000BE   0xF010 0x0002      ANDS     R0,R0,#0x2
   \   000000C2   0x9000             STR      R0,[SP, #+0]
   \   000000C4   0x9800             LDR      R0,[SP, #+0]
     80              __HAL_RCC_GPIOC_CLK_ENABLE();
   \   000000C6   0x....             LDR.N    R0,??DataTable2  ;; 0x40023830
   \   000000C8   0x6800             LDR      R0,[R0, #+0]
   \   000000CA   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   000000CE   0x....             LDR.N    R1,??DataTable2  ;; 0x40023830
   \   000000D0   0x6008             STR      R0,[R1, #+0]
   \   000000D2   0x....             LDR.N    R0,??DataTable2  ;; 0x40023830
   \   000000D4   0x6800             LDR      R0,[R0, #+0]
   \   000000D6   0xF010 0x0004      ANDS     R0,R0,#0x4
   \   000000DA   0x9000             STR      R0,[SP, #+0]
   \   000000DC   0x9800             LDR      R0,[SP, #+0]
     81              __HAL_RCC_GPIOH_CLK_ENABLE();
   \   000000DE   0x....             LDR.N    R0,??DataTable2  ;; 0x40023830
   \   000000E0   0x6800             LDR      R0,[R0, #+0]
   \   000000E2   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   000000E6   0x....             LDR.N    R1,??DataTable2  ;; 0x40023830
   \   000000E8   0x6008             STR      R0,[R1, #+0]
   \   000000EA   0x....             LDR.N    R0,??DataTable2  ;; 0x40023830
   \   000000EC   0x6800             LDR      R0,[R0, #+0]
   \   000000EE   0xF010 0x0080      ANDS     R0,R0,#0x80
   \   000000F2   0x9000             STR      R0,[SP, #+0]
   \   000000F4   0x9800             LDR      R0,[SP, #+0]
     82              
     83              /* CLK */
     84              GPIO_InitStruct.Pin = GPIO_PIN_5;
   \   000000F6   0x2020             MOVS     R0,#+32
   \   000000F8   0x9001             STR      R0,[SP, #+4]
     85              GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
   \   000000FA   0x2002             MOVS     R0,#+2
   \   000000FC   0x9002             STR      R0,[SP, #+8]
     86              GPIO_InitStruct.Pull = GPIO_NOPULL;
   \   000000FE   0x2000             MOVS     R0,#+0
   \   00000100   0x9003             STR      R0,[SP, #+12]
     87              GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
   \   00000102   0x2003             MOVS     R0,#+3
   \   00000104   0x9004             STR      R0,[SP, #+16]
     88              GPIO_InitStruct.Alternate = GPIO_AF10_OTG_HS;
   \   00000106   0x200A             MOVS     R0,#+10
   \   00000108   0x9005             STR      R0,[SP, #+20]
     89              HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
   \   0000010A   0xA901             ADD      R1,SP,#+4
   \   0000010C   0x....             LDR.N    R0,??DataTable2_1  ;; 0x40020000
   \   0000010E   0x.... 0x....      BL       HAL_GPIO_Init
     90              
     91              /* D0 */
     92              GPIO_InitStruct.Pin = GPIO_PIN_3;
   \   00000112   0x2008             MOVS     R0,#+8
   \   00000114   0x9001             STR      R0,[SP, #+4]
     93              GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
   \   00000116   0x2002             MOVS     R0,#+2
   \   00000118   0x9002             STR      R0,[SP, #+8]
     94              GPIO_InitStruct.Pull = GPIO_NOPULL;
   \   0000011A   0x2000             MOVS     R0,#+0
   \   0000011C   0x9003             STR      R0,[SP, #+12]
     95              GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
   \   0000011E   0x2003             MOVS     R0,#+3
   \   00000120   0x9004             STR      R0,[SP, #+16]
     96              GPIO_InitStruct.Alternate = GPIO_AF10_OTG_HS;
   \   00000122   0x200A             MOVS     R0,#+10
   \   00000124   0x9005             STR      R0,[SP, #+20]
     97              HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
   \   00000126   0xA901             ADD      R1,SP,#+4
   \   00000128   0x....             LDR.N    R0,??DataTable2_1  ;; 0x40020000
   \   0000012A   0x.... 0x....      BL       HAL_GPIO_Init
     98              
     99              /* D1 D2 D3 D4 D5 D6 D7 */
    100              GPIO_InitStruct.Pin = GPIO_PIN_0  | GPIO_PIN_1  | GPIO_PIN_5 |\
    101                GPIO_PIN_10 | GPIO_PIN_11 | GPIO_PIN_12 | GPIO_PIN_13;
   \   0000012E   0xF643 0x4023      MOVW     R0,#+15395
   \   00000132   0x9001             STR      R0,[SP, #+4]
    102              GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
   \   00000134   0x2002             MOVS     R0,#+2
   \   00000136   0x9002             STR      R0,[SP, #+8]
    103              GPIO_InitStruct.Pull = GPIO_NOPULL;
   \   00000138   0x2000             MOVS     R0,#+0
   \   0000013A   0x9003             STR      R0,[SP, #+12]
    104              GPIO_InitStruct.Alternate = GPIO_AF10_OTG_HS;
   \   0000013C   0x200A             MOVS     R0,#+10
   \   0000013E   0x9005             STR      R0,[SP, #+20]
    105              HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
   \   00000140   0xA901             ADD      R1,SP,#+4
   \   00000142   0x....             LDR.N    R0,??DataTable2_5  ;; 0x40020400
   \   00000144   0x.... 0x....      BL       HAL_GPIO_Init
    106              
    107              /* STP */
    108              GPIO_InitStruct.Pin = GPIO_PIN_0;
   \   00000148   0x2001             MOVS     R0,#+1
   \   0000014A   0x9001             STR      R0,[SP, #+4]
    109              GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
   \   0000014C   0x2002             MOVS     R0,#+2
   \   0000014E   0x9002             STR      R0,[SP, #+8]
    110              GPIO_InitStruct.Pull = GPIO_NOPULL;
   \   00000150   0x2000             MOVS     R0,#+0
   \   00000152   0x9003             STR      R0,[SP, #+12]
    111              GPIO_InitStruct.Alternate = GPIO_AF10_OTG_HS;
   \   00000154   0x200A             MOVS     R0,#+10
   \   00000156   0x9005             STR      R0,[SP, #+20]
    112              HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
   \   00000158   0xA901             ADD      R1,SP,#+4
   \   0000015A   0x....             LDR.N    R0,??DataTable2_6  ;; 0x40020800
   \   0000015C   0x.... 0x....      BL       HAL_GPIO_Init
    113              
    114              /* NXT */
    115              GPIO_InitStruct.Pin = GPIO_PIN_4;
   \   00000160   0x2010             MOVS     R0,#+16
   \   00000162   0x9001             STR      R0,[SP, #+4]
    116              GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
   \   00000164   0x2002             MOVS     R0,#+2
   \   00000166   0x9002             STR      R0,[SP, #+8]
    117              GPIO_InitStruct.Pull = GPIO_NOPULL;
   \   00000168   0x2000             MOVS     R0,#+0
   \   0000016A   0x9003             STR      R0,[SP, #+12]
    118              GPIO_InitStruct.Alternate = GPIO_AF10_OTG_HS;
   \   0000016C   0x200A             MOVS     R0,#+10
   \   0000016E   0x9005             STR      R0,[SP, #+20]
    119              HAL_GPIO_Init(GPIOH, &GPIO_InitStruct);
   \   00000170   0xA901             ADD      R1,SP,#+4
   \   00000172   0x....             LDR.N    R0,??DataTable2_7  ;; 0x40021c00
   \   00000174   0x.... 0x....      BL       HAL_GPIO_Init
    120              
    121              /* DIR */
    122              GPIO_InitStruct.Pin = GPIO_PIN_2;
   \   00000178   0x2004             MOVS     R0,#+4
   \   0000017A   0x9001             STR      R0,[SP, #+4]
    123              GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
   \   0000017C   0x2002             MOVS     R0,#+2
   \   0000017E   0x9002             STR      R0,[SP, #+8]
    124              GPIO_InitStruct.Pull = GPIO_NOPULL;
   \   00000180   0x2000             MOVS     R0,#+0
   \   00000182   0x9003             STR      R0,[SP, #+12]
    125              GPIO_InitStruct.Alternate = GPIO_AF10_OTG_HS;
   \   00000184   0x200A             MOVS     R0,#+10
   \   00000186   0x9005             STR      R0,[SP, #+20]
    126              HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
   \   00000188   0xA901             ADD      R1,SP,#+4
   \   0000018A   0x....             LDR.N    R0,??DataTable2_6  ;; 0x40020800
   \   0000018C   0x.... 0x....      BL       HAL_GPIO_Init
    127              
    128              __HAL_RCC_USB_OTG_HS_ULPI_CLK_ENABLE();
   \   00000190   0x....             LDR.N    R0,??DataTable2  ;; 0x40023830
   \   00000192   0x6800             LDR      R0,[R0, #+0]
   \   00000194   0xF050 0x4080      ORRS     R0,R0,#0x40000000
   \   00000198   0x....             LDR.N    R1,??DataTable2  ;; 0x40023830
   \   0000019A   0x6008             STR      R0,[R1, #+0]
   \   0000019C   0x....             LDR.N    R0,??DataTable2  ;; 0x40023830
   \   0000019E   0x6800             LDR      R0,[R0, #+0]
   \   000001A0   0xF010 0x4080      ANDS     R0,R0,#0x40000000
   \   000001A4   0x9000             STR      R0,[SP, #+0]
   \   000001A6   0x9800             LDR      R0,[SP, #+0]
    129              
    130              /* Enable USB HS Clocks */
    131              __HAL_RCC_USB_OTG_HS_CLK_ENABLE();
   \   000001A8   0x....             LDR.N    R0,??DataTable2  ;; 0x40023830
   \   000001AA   0x6800             LDR      R0,[R0, #+0]
   \   000001AC   0xF050 0x5000      ORRS     R0,R0,#0x20000000
   \   000001B0   0x....             LDR.N    R1,??DataTable2  ;; 0x40023830
   \   000001B2   0x6008             STR      R0,[R1, #+0]
   \   000001B4   0x....             LDR.N    R0,??DataTable2  ;; 0x40023830
   \   000001B6   0x6800             LDR      R0,[R0, #+0]
   \   000001B8   0xF010 0x5000      ANDS     R0,R0,#0x20000000
   \   000001BC   0x9000             STR      R0,[SP, #+0]
   \   000001BE   0x9800             LDR      R0,[SP, #+0]
    132              
    133              /* Set USBHS Interrupt to the lowest priority */
    134              HAL_NVIC_SetPriority(OTG_HS_IRQn, 5, 0);
   \   000001C0   0x2200             MOVS     R2,#+0
   \   000001C2   0x2105             MOVS     R1,#+5
   \   000001C4   0x204D             MOVS     R0,#+77
   \   000001C6   0x.... 0x....      BL       HAL_NVIC_SetPriority
    135              
    136              /* Enable USBHS Interrupt */
    137              HAL_NVIC_EnableIRQ(OTG_HS_IRQn);
   \   000001CA   0x204D             MOVS     R0,#+77
   \   000001CC   0x.... 0x....      BL       HAL_NVIC_EnableIRQ
    138            }   
    139          }
   \                     ??HAL_PCD_MspInit_1: (+1)
   \   000001D0   0xB008             ADD      SP,SP,#+32
   \   000001D2   0xBD10             POP      {R4,PC}          ;; return
    140          
    141          /**
    142            * @brief  De-Initializes the PCD MSP.
    143            * @param  hpcd: PCD handle
    144            * @retval None
    145            */

   \                                 In section .text, align 2, keep-with-next
    146          void HAL_PCD_MspDeInit(PCD_HandleTypeDef *hpcd)
    147          {
    148            if(hpcd->Instance == USB_OTG_FS)
   \                     HAL_PCD_MspDeInit: (+1)
   \   00000000   0x6801             LDR      R1,[R0, #+0]
   \   00000002   0xF1B1 0x4FA0      CMP      R1,#+1342177280
   \   00000006   0xD112             BNE.N    ??HAL_PCD_MspDeInit_0
    149            {  
    150              /* Disable USB FS Clock */
    151              __HAL_RCC_USB_OTG_FS_CLK_DISABLE();
   \   00000008   0x....             LDR.N    R1,??DataTable2_2  ;; 0x40023834
   \   0000000A   0x6809             LDR      R1,[R1, #+0]
   \   0000000C   0xF031 0x0180      BICS     R1,R1,#0x80
   \   00000010   0x....             LDR.N    R2,??DataTable2_2  ;; 0x40023834
   \   00000012   0x6011             STR      R1,[R2, #+0]
   \   00000014   0x....             LDR.N    R1,??DataTable2_3  ;; 0x40023844
   \   00000016   0x6809             LDR      R1,[R1, #+0]
   \   00000018   0xF431 0x4180      BICS     R1,R1,#0x4000
   \   0000001C   0x....             LDR.N    R2,??DataTable2_3  ;; 0x40023844
   \   0000001E   0x6011             STR      R1,[R2, #+0]
    152              __HAL_RCC_SYSCFG_CLK_DISABLE();
   \   00000020   0x....             LDR.N    R1,??DataTable2_3  ;; 0x40023844
   \   00000022   0x6809             LDR      R1,[R1, #+0]
   \   00000024   0xF431 0x4180      BICS     R1,R1,#0x4000
   \   00000028   0x....             LDR.N    R2,??DataTable2_3  ;; 0x40023844
   \   0000002A   0x6011             STR      R1,[R2, #+0]
   \   0000002C   0xE00F             B.N      ??HAL_PCD_MspDeInit_1
    153            }
    154            else if(hpcd->Instance == USB_OTG_HS)
   \                     ??HAL_PCD_MspDeInit_0: (+1)
   \   0000002E   0x6801             LDR      R1,[R0, #+0]
   \   00000030   0x....             LDR.N    R2,??DataTable2_4  ;; 0x40040000
   \   00000032   0x4291             CMP      R1,R2
   \   00000034   0xD10B             BNE.N    ??HAL_PCD_MspDeInit_1
    155            {  
    156              /* Disable USB HS Clocks */
    157              __HAL_RCC_USB_OTG_HS_CLK_DISABLE();
   \   00000036   0x....             LDR.N    R1,??DataTable2  ;; 0x40023830
   \   00000038   0x6809             LDR      R1,[R1, #+0]
   \   0000003A   0xF031 0x5100      BICS     R1,R1,#0x20000000
   \   0000003E   0x....             LDR.N    R2,??DataTable2  ;; 0x40023830
   \   00000040   0x6011             STR      R1,[R2, #+0]
    158              __HAL_RCC_SYSCFG_CLK_DISABLE();
   \   00000042   0x....             LDR.N    R1,??DataTable2_3  ;; 0x40023844
   \   00000044   0x6809             LDR      R1,[R1, #+0]
   \   00000046   0xF431 0x4180      BICS     R1,R1,#0x4000
   \   0000004A   0x....             LDR.N    R2,??DataTable2_3  ;; 0x40023844
   \   0000004C   0x6011             STR      R1,[R2, #+0]
    159            }  
    160          }
   \                     ??HAL_PCD_MspDeInit_1: (+1)
   \   0000004E   0x4770             BX       LR               ;; return
    161          
    162          /*******************************************************************************
    163                                 LL Driver Callbacks (PCD -> USB Device Library)
    164          *******************************************************************************/
    165          
    166          /**
    167            * @brief  SetupStage callback.
    168            * @param  hpcd: PCD handle
    169            * @retval None
    170            */

   \                                 In section .text, align 2, keep-with-next
    171          void HAL_PCD_SetupStageCallback(PCD_HandleTypeDef *hpcd)
    172          {
   \                     HAL_PCD_SetupStageCallback: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    173            USBD_LL_SetupStage(hpcd->pData, (uint8_t *)hpcd->Setup);
   \   00000004   0xF514 0x7160      ADDS     R1,R4,#+896
   \   00000008   0xF8D4 0x03BC      LDR      R0,[R4, #+956]
   \   0000000C   0x.... 0x....      BL       USBD_LL_SetupStage
    174          }
   \   00000010   0xBD10             POP      {R4,PC}          ;; return
    175          
    176          /**
    177            * @brief  DataOut Stage callback.
    178            * @param  hpcd: PCD handle
    179            * @param  epnum: Endpoint Number
    180            * @retval None
    181            */

   \                                 In section .text, align 2, keep-with-next
    182          void HAL_PCD_DataOutStageCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
    183          {
   \                     HAL_PCD_DataOutStageCallback: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    184            USBD_LL_DataOutStage(hpcd->pData, epnum, hpcd->OUT_ep[epnum].xfer_buff);
   \   00000006   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000008   0x201C             MOVS     R0,#+28
   \   0000000A   0xFB00 0x4005      MLA      R0,R0,R5,R4
   \   0000000E   0xF8D0 0x21E4      LDR      R2,[R0, #+484]
   \   00000012   0x0029             MOVS     R1,R5
   \   00000014   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000016   0xF8D4 0x03BC      LDR      R0,[R4, #+956]
   \   0000001A   0x.... 0x....      BL       USBD_LL_DataOutStage
    185          }
   \   0000001E   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    186          
    187          /**
    188            * @brief  DataIn Stage callback.
    189            * @param  hpcd: PCD handle
    190            * @param  epnum: Endpoint Number
    191            * @retval None
    192            */

   \                                 In section .text, align 2, keep-with-next
    193          void HAL_PCD_DataInStageCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
    194          {
   \                     HAL_PCD_DataInStageCallback: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    195            USBD_LL_DataInStage(hpcd->pData, epnum, hpcd->IN_ep[epnum].xfer_buff);
   \   00000006   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000008   0x201C             MOVS     R0,#+28
   \   0000000A   0xFB00 0x4005      MLA      R0,R0,R5,R4
   \   0000000E   0x6C02             LDR      R2,[R0, #+64]
   \   00000010   0x0029             MOVS     R1,R5
   \   00000012   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000014   0xF8D4 0x03BC      LDR      R0,[R4, #+956]
   \   00000018   0x.... 0x....      BL       USBD_LL_DataInStage
    196          }
   \   0000001C   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    197          
    198          /**
    199            * @brief  SOF callback.
    200            * @param  hpcd: PCD handle
    201            * @retval None
    202            */

   \                                 In section .text, align 2, keep-with-next
    203          void HAL_PCD_SOFCallback(PCD_HandleTypeDef *hpcd)
    204          {
   \                     HAL_PCD_SOFCallback: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    205            USBD_LL_SOF(hpcd->pData);
   \   00000004   0xF8D4 0x03BC      LDR      R0,[R4, #+956]
   \   00000008   0x.... 0x....      BL       USBD_LL_SOF
    206          }
   \   0000000C   0xBD10             POP      {R4,PC}          ;; return
    207          
    208          /**
    209            * @brief  Reset callback.
    210            * @param  hpcd: PCD handle
    211            * @retval None
    212            */

   \                                 In section .text, align 2, keep-with-next
    213          void HAL_PCD_ResetCallback(PCD_HandleTypeDef *hpcd)
    214          {   
   \                     HAL_PCD_ResetCallback: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    215            USBD_SpeedTypeDef speed = USBD_SPEED_FULL;
   \   00000004   0x2501             MOVS     R5,#+1
    216            
    217            /* Set USB Current Speed */
    218            switch(hpcd->Init.speed)
   \   00000006   0x68E0             LDR      R0,[R4, #+12]
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD002             BEQ.N    ??HAL_PCD_ResetCallback_0
   \   0000000C   0x2802             CMP      R0,#+2
   \   0000000E   0xD003             BEQ.N    ??HAL_PCD_ResetCallback_1
   \   00000010   0xE005             B.N      ??HAL_PCD_ResetCallback_2
    219            {
    220            case PCD_SPEED_HIGH:
    221              speed = USBD_SPEED_HIGH;
   \                     ??HAL_PCD_ResetCallback_0: (+1)
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0x0005             MOVS     R5,R0
    222              break;
   \   00000016   0xE004             B.N      ??HAL_PCD_ResetCallback_3
    223              
    224            case PCD_SPEED_FULL:
    225              speed = USBD_SPEED_FULL;
   \                     ??HAL_PCD_ResetCallback_1: (+1)
   \   00000018   0x2001             MOVS     R0,#+1
   \   0000001A   0x0005             MOVS     R5,R0
    226              break;   
   \   0000001C   0xE001             B.N      ??HAL_PCD_ResetCallback_3
    227              
    228            default:
    229              speed = USBD_SPEED_FULL;
   \                     ??HAL_PCD_ResetCallback_2: (+1)
   \   0000001E   0x2001             MOVS     R0,#+1
   \   00000020   0x0005             MOVS     R5,R0
    230              break;
    231            }
    232            
    233            /* Reset Device */
    234            USBD_LL_Reset(hpcd->pData);
   \                     ??HAL_PCD_ResetCallback_3: (+1)
   \   00000022   0xF8D4 0x03BC      LDR      R0,[R4, #+956]
   \   00000026   0x.... 0x....      BL       USBD_LL_Reset
    235            
    236            USBD_LL_SetSpeed(hpcd->pData, speed);
   \   0000002A   0x0029             MOVS     R1,R5
   \   0000002C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000002E   0xF8D4 0x03BC      LDR      R0,[R4, #+956]
   \   00000032   0x.... 0x....      BL       USBD_LL_SetSpeed
    237          }
   \   00000036   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    238          
    239          /**
    240            * @brief  Suspend callback.
    241            * @param  hpcd: PCD handle
    242            * @retval None
    243            */

   \                                 In section .text, align 2, keep-with-next
    244          void HAL_PCD_SuspendCallback(PCD_HandleTypeDef *hpcd)
    245          {
   \                     HAL_PCD_SuspendCallback: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    246            USBD_LL_Suspend(hpcd->pData);
   \   00000004   0xF8D4 0x03BC      LDR      R0,[R4, #+956]
   \   00000008   0x.... 0x....      BL       USBD_LL_Suspend
    247          }
   \   0000000C   0xBD10             POP      {R4,PC}          ;; return
    248          
    249          /**
    250            * @brief  Resume callback.
    251            * @param  hpcd: PCD handle
    252            * @retval None
    253            */

   \                                 In section .text, align 2, keep-with-next
    254          void HAL_PCD_ResumeCallback(PCD_HandleTypeDef *hpcd)
    255          {
   \                     HAL_PCD_ResumeCallback: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    256            USBD_LL_Resume(hpcd->pData);
   \   00000004   0xF8D4 0x03BC      LDR      R0,[R4, #+956]
   \   00000008   0x.... 0x....      BL       USBD_LL_Resume
    257          }
   \   0000000C   0xBD10             POP      {R4,PC}          ;; return
    258          
    259          /**
    260            * @brief  ISOOUTIncomplete callback.
    261            * @param  hpcd: PCD handle 
    262            * @param  epnum: Endpoint Number
    263            * @retval None
    264            */

   \                                 In section .text, align 2, keep-with-next
    265          void HAL_PCD_ISOOUTIncompleteCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
    266          {
   \                     HAL_PCD_ISOOUTIncompleteCallback: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    267            USBD_LL_IsoOUTIncomplete(hpcd->pData, epnum);
   \   00000006   0x0029             MOVS     R1,R5
   \   00000008   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000A   0xF8D4 0x03BC      LDR      R0,[R4, #+956]
   \   0000000E   0x.... 0x....      BL       USBD_LL_IsoOUTIncomplete
    268          }
   \   00000012   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    269          
    270          /**
    271            * @brief  ISOINIncomplete callback.
    272            * @param  hpcd: PCD handle 
    273            * @param  epnum: Endpoint Number
    274            * @retval None
    275            */

   \                                 In section .text, align 2, keep-with-next
    276          void HAL_PCD_ISOINIncompleteCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
    277          {
   \                     HAL_PCD_ISOINIncompleteCallback: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    278            USBD_LL_IsoINIncomplete(hpcd->pData, epnum);
   \   00000006   0x0029             MOVS     R1,R5
   \   00000008   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000A   0xF8D4 0x03BC      LDR      R0,[R4, #+956]
   \   0000000E   0x.... 0x....      BL       USBD_LL_IsoINIncomplete
    279          }
   \   00000012   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    280          
    281          /**
    282            * @brief  ConnectCallback callback.
    283            * @param  hpcd: PCD handle
    284            * @retval None
    285            */

   \                                 In section .text, align 2, keep-with-next
    286          void HAL_PCD_ConnectCallback(PCD_HandleTypeDef *hpcd)
    287          {
   \                     HAL_PCD_ConnectCallback: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    288            USBD_LL_DevConnected(hpcd->pData);
   \   00000004   0xF8D4 0x03BC      LDR      R0,[R4, #+956]
   \   00000008   0x.... 0x....      BL       USBD_LL_DevConnected
    289          }
   \   0000000C   0xBD10             POP      {R4,PC}          ;; return
    290          
    291          /**
    292            * @brief  Disconnect callback.
    293            * @param  hpcd: PCD handle
    294            * @retval None
    295            */

   \                                 In section .text, align 2, keep-with-next
    296          void HAL_PCD_DisconnectCallback(PCD_HandleTypeDef *hpcd)
    297          {
   \                     HAL_PCD_DisconnectCallback: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    298            USBD_LL_DevDisconnected(hpcd->pData);
   \   00000004   0xF8D4 0x03BC      LDR      R0,[R4, #+956]
   \   00000008   0x.... 0x....      BL       USBD_LL_DevDisconnected
    299          }
   \   0000000C   0xBD10             POP      {R4,PC}          ;; return
    300          
    301          
    302          /*******************************************************************************
    303                                 LL Driver Interface (USB Device Library --> PCD)
    304          *******************************************************************************/
    305          
    306          /**
    307            * @brief  Initializes the Low Level portion of the Device driver.
    308            * @param  pdev: Device handle
    309            * @retval USBD Status
    310            */

   \                                 In section .text, align 2, keep-with-next
    311          USBD_StatusTypeDef USBD_LL_Init(USBD_HandleTypeDef *pdev)
    312          {
   \                     USBD_LL_Init: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    313          #ifdef USE_USB_FS
    314            /* Set LL Driver parameters */
    315            hpcd.Instance = USB_OTG_FS;
   \   00000004   0xF05F 0x40A0      MOVS     R0,#+1342177280
   \   00000008   0x....             LDR.N    R1,??DataTable2_8
   \   0000000A   0x6008             STR      R0,[R1, #+0]
    316            hpcd.Init.dev_endpoints = 4;
   \   0000000C   0x2004             MOVS     R0,#+4
   \   0000000E   0x....             LDR.N    R1,??DataTable2_8
   \   00000010   0x6048             STR      R0,[R1, #+4]
    317            hpcd.Init.use_dedicated_ep1 = 0;
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0x....             LDR.N    R1,??DataTable2_8
   \   00000016   0x62C8             STR      R0,[R1, #+44]
    318            hpcd.Init.ep0_mps = 0x40;
   \   00000018   0x2040             MOVS     R0,#+64
   \   0000001A   0x....             LDR.N    R1,??DataTable2_8
   \   0000001C   0x6148             STR      R0,[R1, #+20]
    319            hpcd.Init.dma_enable = 0;
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0x....             LDR.N    R1,??DataTable2_8
   \   00000022   0x6108             STR      R0,[R1, #+16]
    320            hpcd.Init.low_power_enable = 0;
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0x....             LDR.N    R1,??DataTable2_8
   \   00000028   0x6208             STR      R0,[R1, #+32]
    321            hpcd.Init.phy_itface = PCD_PHY_EMBEDDED;
   \   0000002A   0x2002             MOVS     R0,#+2
   \   0000002C   0x....             LDR.N    R1,??DataTable2_8
   \   0000002E   0x6188             STR      R0,[R1, #+24]
    322            hpcd.Init.Sof_enable = 0;
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0x....             LDR.N    R1,??DataTable2_8
   \   00000034   0x61C8             STR      R0,[R1, #+28]
    323            hpcd.Init.speed = PCD_SPEED_FULL;
   \   00000036   0x2002             MOVS     R0,#+2
   \   00000038   0x....             LDR.N    R1,??DataTable2_8
   \   0000003A   0x60C8             STR      R0,[R1, #+12]
    324            hpcd.Init.vbus_sensing_enable = 0;
   \   0000003C   0x2000             MOVS     R0,#+0
   \   0000003E   0x....             LDR.N    R1,??DataTable2_8
   \   00000040   0x6288             STR      R0,[R1, #+40]
    325            hpcd.Init.lpm_enable = 0;
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0x....             LDR.N    R1,??DataTable2_8
   \   00000046   0x6248             STR      R0,[R1, #+36]
    326            
    327            /* Link The driver to the stack */
    328            hpcd.pData = pdev;
   \   00000048   0x....             LDR.N    R0,??DataTable2_8
   \   0000004A   0xF8C0 0x43BC      STR      R4,[R0, #+956]
    329            pdev->pData = &hpcd;
   \   0000004E   0x....             LDR.N    R0,??DataTable2_8
   \   00000050   0xF8C4 0x0220      STR      R0,[R4, #+544]
    330            
    331            /* Initialize LL Driver */
    332            HAL_PCD_Init(&hpcd);
   \   00000054   0x....             LDR.N    R0,??DataTable2_8
   \   00000056   0x.... 0x....      BL       HAL_PCD_Init
    333            
    334            HAL_PCDEx_SetRxFiFo(&hpcd, 0x80);
   \   0000005A   0x2180             MOVS     R1,#+128
   \   0000005C   0x....             LDR.N    R0,??DataTable2_8
   \   0000005E   0x.... 0x....      BL       HAL_PCDEx_SetRxFiFo
    335            HAL_PCDEx_SetTxFiFo(&hpcd, 0, 0x60);
   \   00000062   0x2260             MOVS     R2,#+96
   \   00000064   0x2100             MOVS     R1,#+0
   \   00000066   0x....             LDR.N    R0,??DataTable2_8
   \   00000068   0x.... 0x....      BL       HAL_PCDEx_SetTxFiFo
    336          #endif
    337            
    338          #ifdef USE_USB_HS
    339            /* Set LL Driver parameters */
    340            hpcd.Instance = USB_OTG_HS;
    341            hpcd.Init.dev_endpoints = 6;
    342            hpcd.Init.use_dedicated_ep1 = 0;
    343            hpcd.Init.ep0_mps = 0x40;
    344            
    345            /* Be aware that enabling DMA mode will result in data being sent only by
    346            multiple of 4 packet sizes. This is due to the fact that USB DMA does
    347            not allow sending data from non word-aligned addresses.
    348            For this specific application, it is advised to not enable this option
    349            unless required. */
    350            hpcd.Init.dma_enable = 0;
    351            hpcd.Init.low_power_enable = 0;
    352            hpcd.Init.lpm_enable = 0;
    353            hpcd.Init.phy_itface = PCD_PHY_ULPI; 
    354            hpcd.Init.Sof_enable = 0;
    355            hpcd.Init.speed = PCD_SPEED_HIGH;
    356            hpcd.Init.vbus_sensing_enable = 1;
    357            
    358            /* Link The driver to the stack */
    359            hpcd.pData = pdev;
    360            pdev->pData = &hpcd;
    361            
    362            /* Initialize LL Driver */
    363            HAL_PCD_Init(&hpcd);
    364            
    365            HAL_PCDEx_SetRxFiFo(&hpcd, 0x100);
    366            HAL_PCDEx_SetTxFiFo(&hpcd, 0, 0x200);
    367          #endif
    368            
    369            return USBD_OK;
   \   0000006C   0x2000             MOVS     R0,#+0
   \   0000006E   0xBD10             POP      {R4,PC}          ;; return
    370          }
    371          
    372          /**
    373            * @brief  De-Initializes the Low Level portion of the Device driver.
    374            * @param  pdev: Device handle
    375            * @retval USBD Status
    376            */

   \                                 In section .text, align 2, keep-with-next
    377          USBD_StatusTypeDef USBD_LL_DeInit(USBD_HandleTypeDef *pdev)
    378          {
   \                     USBD_LL_DeInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    379            HAL_PCD_DeInit(pdev->pData);
   \   00000004   0xF8D4 0x0220      LDR      R0,[R4, #+544]
   \   00000008   0x.... 0x....      BL       HAL_PCD_DeInit
    380            return USBD_OK;
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0xBD10             POP      {R4,PC}          ;; return
    381          }
    382          
    383          /**
    384            * @brief  Starts the Low Level portion of the Device driver. 
    385            * @param  pdev: Device handle
    386            * @retval USBD Status
    387            */

   \                                 In section .text, align 2, keep-with-next
    388          USBD_StatusTypeDef USBD_LL_Start(USBD_HandleTypeDef *pdev)
    389          {
   \                     USBD_LL_Start: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    390            HAL_PCD_Start(pdev->pData);
   \   00000004   0xF8D4 0x0220      LDR      R0,[R4, #+544]
   \   00000008   0x.... 0x....      BL       HAL_PCD_Start
    391            return USBD_OK;
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0xBD10             POP      {R4,PC}          ;; return
    392          }
    393          
    394          /**
    395            * @brief  Stops the Low Level portion of the Device driver.
    396            * @param  pdev: Device handle
    397            * @retval USBD Status
    398            */

   \                                 In section .text, align 2, keep-with-next
    399          USBD_StatusTypeDef USBD_LL_Stop(USBD_HandleTypeDef *pdev)
    400          {
   \                     USBD_LL_Stop: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    401            HAL_PCD_Stop(pdev->pData);
   \   00000004   0xF8D4 0x0220      LDR      R0,[R4, #+544]
   \   00000008   0x.... 0x....      BL       HAL_PCD_Stop
    402            return USBD_OK;
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0xBD10             POP      {R4,PC}          ;; return
    403          }
    404          
    405          /**
    406            * @brief  Opens an endpoint of the Low Level Driver.
    407            * @param  pdev: Device handle
    408            * @param  ep_addr: Endpoint Number
    409            * @param  ep_type: Endpoint Type
    410            * @param  ep_mps: Endpoint Max Packet Size
    411            * @retval USBD Status
    412            */

   \                                 In section .text, align 2, keep-with-next
    413          USBD_StatusTypeDef USBD_LL_OpenEP(USBD_HandleTypeDef *pdev,
    414                                            uint8_t ep_addr,
    415                                            uint8_t ep_type,
    416                                            uint16_t ep_mps)
    417          {
   \                     USBD_LL_OpenEP: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   \   00000008   0x001F             MOVS     R7,R3
    418            HAL_PCD_EP_Open(pdev->pData,
    419                            ep_addr,
    420                            ep_mps,
    421                            ep_type);
   \   0000000A   0x0033             MOVS     R3,R6
   \   0000000C   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   0000000E   0x003A             MOVS     R2,R7
   \   00000010   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000012   0x0029             MOVS     R1,R5
   \   00000014   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000016   0xF8D4 0x0220      LDR      R0,[R4, #+544]
   \   0000001A   0x.... 0x....      BL       HAL_PCD_EP_Open
    422            
    423            return USBD_OK;
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    424          }
    425          
    426          /**
    427            * @brief  Closes an endpoint of the Low Level Driver.
    428            * @param  pdev: Device handle
    429            * @param  ep_addr: Endpoint Number
    430            * @retval USBD Status
    431            */

   \                                 In section .text, align 2, keep-with-next
    432          USBD_StatusTypeDef USBD_LL_CloseEP(USBD_HandleTypeDef *pdev, uint8_t ep_addr)
    433          {
   \                     USBD_LL_CloseEP: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    434            HAL_PCD_EP_Close(pdev->pData, ep_addr);
   \   00000006   0x0029             MOVS     R1,R5
   \   00000008   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000A   0xF8D4 0x0220      LDR      R0,[R4, #+544]
   \   0000000E   0x.... 0x....      BL       HAL_PCD_EP_Close
    435            return USBD_OK;
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    436          }
    437          
    438          /**
    439            * @brief  Flushes an endpoint of the Low Level Driver.
    440            * @param  pdev: Device handle
    441            * @param  ep_addr: Endpoint Number
    442            * @retval USBD Status
    443            */

   \                                 In section .text, align 2, keep-with-next
    444          USBD_StatusTypeDef USBD_LL_FlushEP(USBD_HandleTypeDef *pdev, uint8_t ep_addr)
    445          {
   \                     USBD_LL_FlushEP: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    446            HAL_PCD_EP_Flush(pdev->pData, ep_addr);
   \   00000006   0x0029             MOVS     R1,R5
   \   00000008   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000A   0xF8D4 0x0220      LDR      R0,[R4, #+544]
   \   0000000E   0x.... 0x....      BL       HAL_PCD_EP_Flush
    447            return USBD_OK;
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    448          }
    449          
    450          /**
    451            * @brief  Sets a Stall condition on an endpoint of the Low Level Driver.
    452            * @param  pdev: Device handle
    453            * @param  ep_addr: Endpoint Number
    454            * @retval USBD Status
    455            */

   \                                 In section .text, align 2, keep-with-next
    456          USBD_StatusTypeDef USBD_LL_StallEP(USBD_HandleTypeDef *pdev, uint8_t ep_addr)
    457          {
   \                     USBD_LL_StallEP: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    458            HAL_PCD_EP_SetStall(pdev->pData, ep_addr);
   \   00000006   0x0029             MOVS     R1,R5
   \   00000008   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000A   0xF8D4 0x0220      LDR      R0,[R4, #+544]
   \   0000000E   0x.... 0x....      BL       HAL_PCD_EP_SetStall
    459            return USBD_OK;
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    460          }
    461          
    462          /**
    463            * @brief  Clears a Stall condition on an endpoint of the Low Level Driver.
    464            * @param  pdev: Device handle
    465            * @param  ep_addr: Endpoint Number
    466            * @retval USBD Status
    467            */

   \                                 In section .text, align 2, keep-with-next
    468          USBD_StatusTypeDef USBD_LL_ClearStallEP(USBD_HandleTypeDef *pdev, uint8_t ep_addr)
    469          {
   \                     USBD_LL_ClearStallEP: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    470            HAL_PCD_EP_ClrStall(pdev->pData, ep_addr);
   \   00000006   0x0029             MOVS     R1,R5
   \   00000008   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000A   0xF8D4 0x0220      LDR      R0,[R4, #+544]
   \   0000000E   0x.... 0x....      BL       HAL_PCD_EP_ClrStall
    471            return USBD_OK; 
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    472          }
    473          
    474          /**
    475            * @brief  Returns Stall condition.
    476            * @param  pdev: Device handle
    477            * @param  ep_addr: Endpoint Number
    478            * @retval Stall (1: Yes, 0: No)
    479            */

   \                                 In section .text, align 2, keep-with-next
    480          uint8_t USBD_LL_IsStallEP(USBD_HandleTypeDef *pdev, uint8_t ep_addr)
    481          {
   \                     USBD_LL_IsStallEP: (+1)
   \   00000000   0x0002             MOVS     R2,R0
    482            PCD_HandleTypeDef *hpcd = pdev->pData;
   \   00000002   0xF8D2 0x0220      LDR      R0,[R2, #+544]
    483            
    484            if((ep_addr & 0x80) == 0x80)
   \   00000006   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000008   0x060B             LSLS     R3,R1,#+24
   \   0000000A   0xD508             BPL.N    ??USBD_LL_IsStallEP_0
    485            {
    486              return hpcd->IN_ep[ep_addr & 0x7F].is_stall;
   \   0000000C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000E   0xF011 0x017F      ANDS     R1,R1,#0x7F
   \   00000012   0x231C             MOVS     R3,#+28
   \   00000014   0xFB03 0x0001      MLA      R0,R3,R1,R0
   \   00000018   0xF890 0x0036      LDRB     R0,[R0, #+54]
   \   0000001C   0xE007             B.N      ??USBD_LL_IsStallEP_1
    487            }
    488            else
    489            {
    490              return hpcd->OUT_ep[ep_addr & 0x7F].is_stall;
   \                     ??USBD_LL_IsStallEP_0: (+1)
   \   0000001E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000020   0xF011 0x017F      ANDS     R1,R1,#0x7F
   \   00000024   0x231C             MOVS     R3,#+28
   \   00000026   0xFB03 0x0001      MLA      R0,R3,R1,R0
   \   0000002A   0xF890 0x01DA      LDRB     R0,[R0, #+474]
   \                     ??USBD_LL_IsStallEP_1: (+1)
   \   0000002E   0x4770             BX       LR               ;; return
    491            }
    492          }
    493          
    494          /**
    495            * @brief  Assigns a USB address to the device.
    496            * @param  pdev: Device handle
    497            * @param  ep_addr: Endpoint Number
    498            * @retval USBD Status
    499            */

   \                                 In section .text, align 2, keep-with-next
    500          USBD_StatusTypeDef USBD_LL_SetUSBAddress(USBD_HandleTypeDef *pdev, uint8_t dev_addr)
    501          {
   \                     USBD_LL_SetUSBAddress: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    502            HAL_PCD_SetAddress(pdev->pData, dev_addr);
   \   00000006   0x0029             MOVS     R1,R5
   \   00000008   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000A   0xF8D4 0x0220      LDR      R0,[R4, #+544]
   \   0000000E   0x.... 0x....      BL       HAL_PCD_SetAddress
    503            return USBD_OK; 
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    504          }
    505          
    506          /**
    507            * @brief  Transmits data over an endpoint.
    508            * @param  pdev: Device handle
    509            * @param  ep_addr: Endpoint Number
    510            * @param  pbuf: Pointer to data to be sent
    511            * @param  size: Data size    
    512            * @retval USBD Status
    513            */

   \                                 In section .text, align 2, keep-with-next
    514          USBD_StatusTypeDef USBD_LL_Transmit(USBD_HandleTypeDef *pdev, 
    515                                              uint8_t ep_addr,
    516                                              uint8_t *pbuf,
    517                                              uint16_t size)
    518          {
   \                     USBD_LL_Transmit: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   \   00000008   0x001F             MOVS     R7,R3
    519            HAL_PCD_EP_Transmit(pdev->pData, ep_addr, pbuf, size);
   \   0000000A   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   0000000C   0x003B             MOVS     R3,R7
   \   0000000E   0x0032             MOVS     R2,R6
   \   00000010   0x0029             MOVS     R1,R5
   \   00000012   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000014   0xF8D4 0x0220      LDR      R0,[R4, #+544]
   \   00000018   0x.... 0x....      BL       HAL_PCD_EP_Transmit
    520            return USBD_OK;
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    521          }
    522          
    523          /**
    524            * @brief  Prepares an endpoint for reception.
    525            * @param  pdev: Device handle
    526            * @param  ep_addr: Endpoint Number
    527            * @param  pbuf: Pointer to data to be received
    528            * @param  size: Data size
    529            * @retval USBD Status
    530            */

   \                                 In section .text, align 2, keep-with-next
    531          USBD_StatusTypeDef USBD_LL_PrepareReceive(USBD_HandleTypeDef *pdev, 
    532                                                    uint8_t ep_addr,
    533                                                    uint8_t *pbuf,
    534                                                    uint16_t size)
    535          {
   \                     USBD_LL_PrepareReceive: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   \   00000008   0x001F             MOVS     R7,R3
    536            HAL_PCD_EP_Receive(pdev->pData, ep_addr, pbuf, size);
   \   0000000A   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   0000000C   0x003B             MOVS     R3,R7
   \   0000000E   0x0032             MOVS     R2,R6
   \   00000010   0x0029             MOVS     R1,R5
   \   00000012   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000014   0xF8D4 0x0220      LDR      R0,[R4, #+544]
   \   00000018   0x.... 0x....      BL       HAL_PCD_EP_Receive
    537            return USBD_OK;
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    538          }
    539          
    540          /**
    541            * @brief  Returns the last transferred packet size.
    542            * @param  pdev: Device handle
    543            * @param  ep_addr: Endpoint Number
    544            * @retval Received Data Size
    545            */

   \                                 In section .text, align 2, keep-with-next
    546          uint32_t USBD_LL_GetRxDataSize(USBD_HandleTypeDef *pdev, uint8_t ep_addr)
    547          {
   \                     USBD_LL_GetRxDataSize: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    548            return HAL_PCD_EP_GetRxCount(pdev->pData, ep_addr);
   \   00000006   0x0029             MOVS     R1,R5
   \   00000008   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000A   0xF8D4 0x0220      LDR      R0,[R4, #+544]
   \   0000000E   0x.... 0x....      BL       HAL_PCD_EP_GetRxCount
   \   00000012   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    549          }
    550          
    551          /**
    552            * @brief  Delays routine for the USB Device Library.
    553            * @param  Delay: Delay in ms
    554            * @retval None
    555            */

   \                                 In section .text, align 2, keep-with-next
    556          void USBD_LL_Delay(uint32_t Delay)
    557          {
   \                     USBD_LL_Delay: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    558            HAL_Delay(Delay);
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0x.... 0x....      BL       HAL_Delay
    559          }
   \   0000000A   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2:
   \   00000000   0x40023830         DC32     0x40023830

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_1:
   \   00000000   0x40020000         DC32     0x40020000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_2:
   \   00000000   0x40023834         DC32     0x40023834

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_3:
   \   00000000   0x40023844         DC32     0x40023844

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_4:
   \   00000000   0x40040000         DC32     0x40040000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_5:
   \   00000000   0x40020400         DC32     0x40020400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_6:
   \   00000000   0x40020800         DC32     0x40020800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_7:
   \   00000000   0x40021C00         DC32     0x40021c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_8:
   \   00000000   0x........         DC32     hpcd
    560          
    561          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   HAL_PCD_ConnectCallback
         8   -> USBD_LL_DevConnected
      16   HAL_PCD_DataInStageCallback
        16   -> USBD_LL_DataInStage
      16   HAL_PCD_DataOutStageCallback
        16   -> USBD_LL_DataOutStage
       8   HAL_PCD_DisconnectCallback
         8   -> USBD_LL_DevDisconnected
      16   HAL_PCD_ISOINIncompleteCallback
        16   -> USBD_LL_IsoINIncomplete
      16   HAL_PCD_ISOOUTIncompleteCallback
        16   -> USBD_LL_IsoOUTIncomplete
       0   HAL_PCD_MspDeInit
      40   HAL_PCD_MspInit
        40   -> HAL_GPIO_Init
        40   -> HAL_NVIC_EnableIRQ
        40   -> HAL_NVIC_SetPriority
      16   HAL_PCD_ResetCallback
        16   -> USBD_LL_Reset
        16   -> USBD_LL_SetSpeed
       8   HAL_PCD_ResumeCallback
         8   -> USBD_LL_Resume
       8   HAL_PCD_SOFCallback
         8   -> USBD_LL_SOF
       8   HAL_PCD_SetupStageCallback
         8   -> USBD_LL_SetupStage
       8   HAL_PCD_SuspendCallback
         8   -> USBD_LL_Suspend
      16   USBD_LL_ClearStallEP
        16   -> HAL_PCD_EP_ClrStall
      16   USBD_LL_CloseEP
        16   -> HAL_PCD_EP_Close
       8   USBD_LL_DeInit
         8   -> HAL_PCD_DeInit
       8   USBD_LL_Delay
         8   -> HAL_Delay
      16   USBD_LL_FlushEP
        16   -> HAL_PCD_EP_Flush
      16   USBD_LL_GetRxDataSize
        16   -> HAL_PCD_EP_GetRxCount
       8   USBD_LL_Init
         8   -> HAL_PCDEx_SetRxFiFo
         8   -> HAL_PCDEx_SetTxFiFo
         8   -> HAL_PCD_Init
       0   USBD_LL_IsStallEP
      24   USBD_LL_OpenEP
        24   -> HAL_PCD_EP_Open
      24   USBD_LL_PrepareReceive
        24   -> HAL_PCD_EP_Receive
      16   USBD_LL_SetUSBAddress
        16   -> HAL_PCD_SetAddress
      16   USBD_LL_StallEP
        16   -> HAL_PCD_EP_SetStall
       8   USBD_LL_Start
         8   -> HAL_PCD_Start
       8   USBD_LL_Stop
         8   -> HAL_PCD_Stop
      24   USBD_LL_Transmit
        24   -> HAL_PCD_EP_Transmit


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable2
       4  ??DataTable2_1
       4  ??DataTable2_2
       4  ??DataTable2_3
       4  ??DataTable2_4
       4  ??DataTable2_5
       4  ??DataTable2_6
       4  ??DataTable2_7
       4  ??DataTable2_8
      14  HAL_PCD_ConnectCallback
      30  HAL_PCD_DataInStageCallback
      32  HAL_PCD_DataOutStageCallback
      14  HAL_PCD_DisconnectCallback
      20  HAL_PCD_ISOINIncompleteCallback
      20  HAL_PCD_ISOOUTIncompleteCallback
      80  HAL_PCD_MspDeInit
     468  HAL_PCD_MspInit
      56  HAL_PCD_ResetCallback
      14  HAL_PCD_ResumeCallback
      14  HAL_PCD_SOFCallback
      18  HAL_PCD_SetupStageCallback
      14  HAL_PCD_SuspendCallback
      22  USBD_LL_ClearStallEP
      22  USBD_LL_CloseEP
      16  USBD_LL_DeInit
      12  USBD_LL_Delay
      22  USBD_LL_FlushEP
      20  USBD_LL_GetRxDataSize
     112  USBD_LL_Init
      48  USBD_LL_IsStallEP
      34  USBD_LL_OpenEP
      32  USBD_LL_PrepareReceive
      22  USBD_LL_SetUSBAddress
      22  USBD_LL_StallEP
      16  USBD_LL_Start
      16  USBD_LL_Stop
      32  USBD_LL_Transmit
     960  hpcd

 
   960 bytes in section .bss
 1 278 bytes in section .text
 
 1 278 bytes of CODE memory
   960 bytes of DATA memory

Errors: none
Warnings: none
