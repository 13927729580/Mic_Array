###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.2.10312/W32 for ARM       20/Feb/2016  22:27:37
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_ltdc.c
#    Command line =  
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_ltdc.c
#        -D USE_HAL_DRIVER -D STM32F746xx -D USE_STM32746G_DISCO -D
#        USE_IOEXPANDER -D USE_USB_FS -lC
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
#        -lA
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
#        -o
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M7 -e --fpu=VFPv5_sp --dlib_config "D:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.3\arm\INC\c\DLib_Config_Full.h"
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\Inc\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\CMSIS\Device\ST\STM32F7xx\Include\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\STM32F7xx_HAL_Driver\Inc\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\STM32746G-Discovery\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\Components\Common\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Log\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Fonts\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\CPU\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_Device_Library\Core\Inc\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Core\Inc\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Class\MSC\Inc\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\drivers\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_Audio\Addons\PDM\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_Device_Library\Class\AUDIO\Inc\
#        -On --use_c++_inline --require_prototypes -I "D:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.3\arm\CMSIS\Include\" -D
#        ARM_MATH_CM7
#    List file    =  
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List\stm32f7xx_hal_ltdc.lst
#    Object file  =  
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj\stm32f7xx_hal_ltdc.o
#
###############################################################################

H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_ltdc.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f7xx_hal_ltdc.c
      4            * @author  MCD Application Team
      5            * @version V1.0.1
      6            * @date    25-June-2015
      7            * @brief   LTDC HAL module driver.
      8            *          This file provides firmware functions to manage the following 
      9            *          functionalities of the LTDC peripheral:
     10            *           + Initialization and de-initialization functions
     11            *           + IO operation functions
     12            *           + Peripheral Control functions  
     13            *           + Peripheral State and Errors functions
     14            *           
     15            @verbatim      
     16            ==============================================================================
     17                                  ##### How to use this driver #####
     18            ==============================================================================
     19              [..]
     20               (#) Program the required configuration through the following parameters:   
     21                   the LTDC timing, the horizontal and vertical polarity, 
     22                   the pixel clock polarity, Data Enable polarity and the LTDC background color value 
     23                   using HAL_LTDC_Init() function
     24          
     25               (#) Program the required configuration through the following parameters:   
     26                   the pixel format, the blending factors, input alpha value, the window size 
     27                   and the image size using HAL_LTDC_ConfigLayer() function for foreground
     28                   or/and background layer.     
     29            
     30               (#) Optionally, configure and enable the CLUT using HAL_LTDC_ConfigCLUT() and 
     31                   HAL_LTDC_EnableCLUT functions.
     32                 
     33               (#) Optionally, enable the Dither using HAL_LTDC_EnableDither().       
     34          
     35               (#) Optionally, configure and enable the Color keying using HAL_LTDC_ConfigColorKeying()
     36                   and HAL_LTDC_EnableColorKeying functions.
     37          
     38               (#) Optionally, configure LineInterrupt using HAL_LTDC_ProgramLineEvent()
     39                   function
     40          
     41               (#) If needed, reconfigure and change the pixel format value, the alpha value
     42                   value, the window size, the window position and the layer start address 
     43                   for foreground or/and background layer using respectively the following 
     44                   functions: HAL_LTDC_SetPixelFormat(), HAL_LTDC_SetAlpha(), HAL_LTDC_SetWindowSize(),
     45                   HAL_LTDC_SetWindowPosition(), HAL_LTDC_SetAddress.
     46                               
     47               (#) To control LTDC state you can use the following function: HAL_LTDC_GetState()               
     48          
     49               *** LTDC HAL driver macros list ***
     50               ============================================= 
     51               [..]
     52                 Below the list of most used macros in LTDC HAL driver.
     53                 
     54                (+) __HAL_LTDC_ENABLE: Enable the LTDC.
     55                (+) __HAL_LTDC_DISABLE: Disable the LTDC.
     56                (+) __HAL_LTDC_LAYER_ENABLE: Enable the LTDC Layer.
     57                (+) __HAL_LTDC_LAYER_DISABLE: Disable the LTDC Layer.
     58                (+) __HAL_LTDC_RELOAD_CONFIG: Reload  Layer Configuration.
     59                (+) __HAL_LTDC_GET_FLAG: Get the LTDC pending flags.
     60                (+) __HAL_LTDC_CLEAR_FLAG: Clear the LTDC pending flags.
     61                (+) __HAL_LTDC_ENABLE_IT: Enable the specified LTDC interrupts. 
     62                (+) __HAL_LTDC_DISABLE_IT: Disable the specified LTDC interrupts.
     63                (+) __HAL_LTDC_GET_IT_SOURCE: Check whether the specified LTDC interrupt has occurred or not.
     64                
     65               [..] 
     66                 (@) You can refer to the LTDC HAL driver header file for more useful macros
     67            
     68            @endverbatim
     69            ******************************************************************************
     70            * @attention
     71            *
     72            * <h2><center>&copy; COPYRIGHT(c) 2015 STMicroelectronics</center></h2>
     73            *
     74            * Redistribution and use in source and binary forms, with or without modification,
     75            * are permitted provided that the following conditions are met:
     76            *   1. Redistributions of source code must retain the above copyright notice,
     77            *      this list of conditions and the following disclaimer.
     78            *   2. Redistributions in binary form must reproduce the above copyright notice,
     79            *      this list of conditions and the following disclaimer in the documentation
     80            *      and/or other materials provided with the distribution.
     81            *   3. Neither the name of STMicroelectronics nor the names of its contributors
     82            *      may be used to endorse or promote products derived from this software
     83            *      without specific prior written permission.
     84            *
     85            * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
     86            * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     87            * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     88            * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
     89            * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
     90            * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
     91            * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
     92            * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
     93            * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
     94            * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     95            *
     96            ******************************************************************************
     97            */ 
     98          
     99          /* Includes ------------------------------------------------------------------*/
    100          #include "stm32f7xx_hal.h"
    101          
    102          /** @addtogroup STM32F7xx_HAL_Driver
    103            * @{
    104            */
    105          #if defined(STM32F756xx) || defined(STM32F746xx)
    106          
    107          /** @defgroup LTDC LTDC
    108            * @brief LTDC HAL module driver
    109            * @{
    110            */
    111          
    112          #ifdef HAL_LTDC_MODULE_ENABLED
    113          
    114          /* Private typedef -----------------------------------------------------------*/
    115          /* Private define ------------------------------------------------------------*/
    116          /* Private macro -------------------------------------------------------------*/
    117          /* Private variables ---------------------------------------------------------*/    
    118          /* Private function prototypes -----------------------------------------------*/
    119          static void LTDC_SetConfig(LTDC_HandleTypeDef *hltdc, LTDC_LayerCfgTypeDef *pLayerCfg, uint32_t LayerIdx);
    120          /* Private functions ---------------------------------------------------------*/
    121          
    122          /** @defgroup LTDC_Exported_Functions LTDC Exported Functions
    123            * @{
    124            */
    125          
    126          /** @defgroup LTDC_Exported_Functions_Group1 Initialization and Configuration functions
    127           *  @brief   Initialization and Configuration functions
    128           *
    129          @verbatim   
    130           ===============================================================================
    131                          ##### Initialization and Configuration functions #####
    132           ===============================================================================  
    133              [..]  This section provides functions allowing to:
    134                (+) Initialize and configure the LTDC
    135                (+) De-initialize the LTDC 
    136          
    137          @endverbatim
    138            * @{
    139            */
    140            
    141          /**
    142            * @brief  Initializes the LTDC according to the specified
    143            *         parameters in the LTDC_InitTypeDef and create the associated handle.
    144            * @param  hltdc: pointer to a LTDC_HandleTypeDef structure that contains
    145            *                the configuration information for the LTDC.
    146            * @retval HAL status
    147            */

   \                                 In section .text, align 2, keep-with-next
    148          HAL_StatusTypeDef HAL_LTDC_Init(LTDC_HandleTypeDef *hltdc)
    149          {
   \                     HAL_LTDC_Init: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
    150            uint32_t tmp = 0, tmp1 = 0;
   \   00000004   0x2500             MOVS     R5,#+0
   \   00000006   0x2600             MOVS     R6,#+0
    151          
    152            /* Check the LTDC peripheral state */
    153            if(hltdc == NULL)
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD101             BNE.N    ??HAL_LTDC_Init_0
    154            {
    155              return HAL_ERROR;
   \   0000000C   0x2001             MOVS     R0,#+1
   \   0000000E   0xE093             B.N      ??HAL_LTDC_Init_1
    156            }
    157          
    158            /* Check function parameters */
    159            assert_param(IS_LTDC_ALL_INSTANCE(hltdc->Instance));
    160            assert_param(IS_LTDC_HSYNC(hltdc->Init.HorizontalSync));
    161            assert_param(IS_LTDC_VSYNC(hltdc->Init.VerticalSync));
    162            assert_param(IS_LTDC_AHBP(hltdc->Init.AccumulatedHBP));
    163            assert_param(IS_LTDC_AVBP(hltdc->Init.AccumulatedVBP));
    164            assert_param(IS_LTDC_AAH(hltdc->Init.AccumulatedActiveH));
    165            assert_param(IS_LTDC_AAW(hltdc->Init.AccumulatedActiveW));
    166            assert_param(IS_LTDC_TOTALH(hltdc->Init.TotalHeigh));
    167            assert_param(IS_LTDC_TOTALW(hltdc->Init.TotalWidth));
    168            assert_param(IS_LTDC_HSPOL(hltdc->Init.HSPolarity));
    169            assert_param(IS_LTDC_VSPOL(hltdc->Init.VSPolarity));
    170            assert_param(IS_LTDC_DEPOL(hltdc->Init.DEPolarity));
    171            assert_param(IS_LTDC_PCPOL(hltdc->Init.PCPolarity));
    172          
    173            if(hltdc->State == HAL_LTDC_STATE_RESET)
   \                     ??HAL_LTDC_Init_0: (+1)
   \   00000010   0xF894 0x00A1      LDRB     R0,[R4, #+161]
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD105             BNE.N    ??HAL_LTDC_Init_2
    174            {
    175              /* Allocate lock resource and initialize it */
    176              hltdc->Lock = HAL_UNLOCKED;
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0xF884 0x00A0      STRB     R0,[R4, #+160]
    177              /* Init the low level hardware */
    178              HAL_LTDC_MspInit(hltdc);
   \   0000001E   0x0020             MOVS     R0,R4
   \   00000020   0x.... 0x....      BL       HAL_LTDC_MspInit
    179            }
    180            
    181            /* Change LTDC peripheral state */
    182            hltdc->State = HAL_LTDC_STATE_BUSY;
   \                     ??HAL_LTDC_Init_2: (+1)
   \   00000024   0x2002             MOVS     R0,#+2
   \   00000026   0xF884 0x00A1      STRB     R0,[R4, #+161]
    183          
    184            /* Configures the HS, VS, DE and PC polarity */
    185            hltdc->Instance->GCR &= ~(LTDC_GCR_HSPOL | LTDC_GCR_VSPOL | LTDC_GCR_DEPOL | LTDC_GCR_PCPOL);
   \   0000002A   0x6820             LDR      R0,[R4, #+0]
   \   0000002C   0x6980             LDR      R0,[R0, #+24]
   \   0000002E   0x0100             LSLS     R0,R0,#+4        ;; ZeroExtS R0,R0,#+4,#+4
   \   00000030   0x0900             LSRS     R0,R0,#+4
   \   00000032   0x6821             LDR      R1,[R4, #+0]
   \   00000034   0x6188             STR      R0,[R1, #+24]
    186            hltdc->Instance->GCR |=  (uint32_t)(hltdc->Init.HSPolarity | hltdc->Init.VSPolarity | \
    187            hltdc->Init.DEPolarity | hltdc->Init.PCPolarity);
   \   00000036   0x6820             LDR      R0,[R4, #+0]
   \   00000038   0x6980             LDR      R0,[R0, #+24]
   \   0000003A   0x6861             LDR      R1,[R4, #+4]
   \   0000003C   0x68A2             LDR      R2,[R4, #+8]
   \   0000003E   0x4311             ORRS     R1,R2,R1
   \   00000040   0x68E2             LDR      R2,[R4, #+12]
   \   00000042   0x4311             ORRS     R1,R2,R1
   \   00000044   0x6922             LDR      R2,[R4, #+16]
   \   00000046   0x4311             ORRS     R1,R2,R1
   \   00000048   0x4308             ORRS     R0,R1,R0
   \   0000004A   0x6821             LDR      R1,[R4, #+0]
   \   0000004C   0x6188             STR      R0,[R1, #+24]
    188          
    189            /* Sets Synchronization size */
    190            hltdc->Instance->SSCR &= ~(LTDC_SSCR_VSH | LTDC_SSCR_HSW);
   \   0000004E   0x6820             LDR      R0,[R4, #+0]
   \   00000050   0x6880             LDR      R0,[R0, #+8]
   \   00000052   0x.... 0x....      LDR.W    R1,??DataTable4  ;; 0xf000f800
   \   00000056   0x4008             ANDS     R0,R1,R0
   \   00000058   0x6821             LDR      R1,[R4, #+0]
   \   0000005A   0x6088             STR      R0,[R1, #+8]
    191            tmp = (hltdc->Init.HorizontalSync << 16);
   \   0000005C   0x6960             LDR      R0,[R4, #+20]
   \   0000005E   0x0400             LSLS     R0,R0,#+16
   \   00000060   0x0005             MOVS     R5,R0
    192            hltdc->Instance->SSCR |= (tmp | hltdc->Init.VerticalSync);
   \   00000062   0x6820             LDR      R0,[R4, #+0]
   \   00000064   0x6880             LDR      R0,[R0, #+8]
   \   00000066   0x69A1             LDR      R1,[R4, #+24]
   \   00000068   0x4329             ORRS     R1,R1,R5
   \   0000006A   0x4308             ORRS     R0,R1,R0
   \   0000006C   0x6821             LDR      R1,[R4, #+0]
   \   0000006E   0x6088             STR      R0,[R1, #+8]
    193          
    194            /* Sets Accumulated Back porch */
    195            hltdc->Instance->BPCR &= ~(LTDC_BPCR_AVBP | LTDC_BPCR_AHBP);
   \   00000070   0x6820             LDR      R0,[R4, #+0]
   \   00000072   0x68C0             LDR      R0,[R0, #+12]
   \   00000074   0x.... 0x....      LDR.W    R1,??DataTable4  ;; 0xf000f800
   \   00000078   0x4008             ANDS     R0,R1,R0
   \   0000007A   0x6821             LDR      R1,[R4, #+0]
   \   0000007C   0x60C8             STR      R0,[R1, #+12]
    196            tmp = (hltdc->Init.AccumulatedHBP << 16);
   \   0000007E   0x69E0             LDR      R0,[R4, #+28]
   \   00000080   0x0400             LSLS     R0,R0,#+16
   \   00000082   0x0005             MOVS     R5,R0
    197            hltdc->Instance->BPCR |= (tmp | hltdc->Init.AccumulatedVBP);
   \   00000084   0x6820             LDR      R0,[R4, #+0]
   \   00000086   0x68C0             LDR      R0,[R0, #+12]
   \   00000088   0x6A21             LDR      R1,[R4, #+32]
   \   0000008A   0x4329             ORRS     R1,R1,R5
   \   0000008C   0x4308             ORRS     R0,R1,R0
   \   0000008E   0x6821             LDR      R1,[R4, #+0]
   \   00000090   0x60C8             STR      R0,[R1, #+12]
    198          
    199            /* Sets Accumulated Active Width */
    200            hltdc->Instance->AWCR &= ~(LTDC_AWCR_AAH | LTDC_AWCR_AAW);
   \   00000092   0x6820             LDR      R0,[R4, #+0]
   \   00000094   0x6900             LDR      R0,[R0, #+16]
   \   00000096   0x.... 0x....      LDR.W    R1,??DataTable4  ;; 0xf000f800
   \   0000009A   0x4008             ANDS     R0,R1,R0
   \   0000009C   0x6821             LDR      R1,[R4, #+0]
   \   0000009E   0x6108             STR      R0,[R1, #+16]
    201            tmp = (hltdc->Init.AccumulatedActiveW << 16);
   \   000000A0   0x6A60             LDR      R0,[R4, #+36]
   \   000000A2   0x0400             LSLS     R0,R0,#+16
   \   000000A4   0x0005             MOVS     R5,R0
    202            hltdc->Instance->AWCR |= (tmp | hltdc->Init.AccumulatedActiveH);
   \   000000A6   0x6820             LDR      R0,[R4, #+0]
   \   000000A8   0x6900             LDR      R0,[R0, #+16]
   \   000000AA   0x6AA1             LDR      R1,[R4, #+40]
   \   000000AC   0x4329             ORRS     R1,R1,R5
   \   000000AE   0x4308             ORRS     R0,R1,R0
   \   000000B0   0x6821             LDR      R1,[R4, #+0]
   \   000000B2   0x6108             STR      R0,[R1, #+16]
    203          
    204            /* Sets Total Width */
    205            hltdc->Instance->TWCR &= ~(LTDC_TWCR_TOTALH | LTDC_TWCR_TOTALW);
   \   000000B4   0x6820             LDR      R0,[R4, #+0]
   \   000000B6   0x6940             LDR      R0,[R0, #+20]
   \   000000B8   0x.... 0x....      LDR.W    R1,??DataTable4  ;; 0xf000f800
   \   000000BC   0x4008             ANDS     R0,R1,R0
   \   000000BE   0x6821             LDR      R1,[R4, #+0]
   \   000000C0   0x6148             STR      R0,[R1, #+20]
    206            tmp = (hltdc->Init.TotalWidth << 16);
   \   000000C2   0x6AE0             LDR      R0,[R4, #+44]
   \   000000C4   0x0400             LSLS     R0,R0,#+16
   \   000000C6   0x0005             MOVS     R5,R0
    207            hltdc->Instance->TWCR |= (tmp | hltdc->Init.TotalHeigh);
   \   000000C8   0x6820             LDR      R0,[R4, #+0]
   \   000000CA   0x6940             LDR      R0,[R0, #+20]
   \   000000CC   0x6B21             LDR      R1,[R4, #+48]
   \   000000CE   0x4329             ORRS     R1,R1,R5
   \   000000D0   0x4308             ORRS     R0,R1,R0
   \   000000D2   0x6821             LDR      R1,[R4, #+0]
   \   000000D4   0x6148             STR      R0,[R1, #+20]
    208          
    209            /* Sets the background color value */
    210            tmp = ((uint32_t)(hltdc->Init.Backcolor.Green) << 8);
   \   000000D6   0xF894 0x0035      LDRB     R0,[R4, #+53]
   \   000000DA   0x0200             LSLS     R0,R0,#+8
   \   000000DC   0x0005             MOVS     R5,R0
    211            tmp1 = ((uint32_t)(hltdc->Init.Backcolor.Red) << 16);
   \   000000DE   0xF894 0x0036      LDRB     R0,[R4, #+54]
   \   000000E2   0x0400             LSLS     R0,R0,#+16
   \   000000E4   0x0006             MOVS     R6,R0
    212            hltdc->Instance->BCCR &= ~(LTDC_BCCR_BCBLUE | LTDC_BCCR_BCGREEN | LTDC_BCCR_BCRED);
   \   000000E6   0x6820             LDR      R0,[R4, #+0]
   \   000000E8   0x6AC0             LDR      R0,[R0, #+44]
   \   000000EA   0xF010 0x407F      ANDS     R0,R0,#0xFF000000
   \   000000EE   0x6821             LDR      R1,[R4, #+0]
   \   000000F0   0x62C8             STR      R0,[R1, #+44]
    213            hltdc->Instance->BCCR |= (tmp1 | tmp | hltdc->Init.Backcolor.Blue);
   \   000000F2   0x6820             LDR      R0,[R4, #+0]
   \   000000F4   0x6AC0             LDR      R0,[R0, #+44]
   \   000000F6   0xEA55 0x0106      ORRS     R1,R5,R6
   \   000000FA   0xF894 0x2034      LDRB     R2,[R4, #+52]
   \   000000FE   0x4311             ORRS     R1,R2,R1
   \   00000100   0x4308             ORRS     R0,R1,R0
   \   00000102   0x6821             LDR      R1,[R4, #+0]
   \   00000104   0x62C8             STR      R0,[R1, #+44]
    214          
    215            /* Enable the transfer Error interrupt */
    216            __HAL_LTDC_ENABLE_IT(hltdc, LTDC_IT_TE);
   \   00000106   0x6820             LDR      R0,[R4, #+0]
   \   00000108   0x6B40             LDR      R0,[R0, #+52]
   \   0000010A   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   0000010E   0x6821             LDR      R1,[R4, #+0]
   \   00000110   0x6348             STR      R0,[R1, #+52]
    217          
    218            /* Enable the FIFO underrun interrupt */
    219            __HAL_LTDC_ENABLE_IT(hltdc, LTDC_IT_FU);
   \   00000112   0x6820             LDR      R0,[R4, #+0]
   \   00000114   0x6B40             LDR      R0,[R0, #+52]
   \   00000116   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   0000011A   0x6821             LDR      R1,[R4, #+0]
   \   0000011C   0x6348             STR      R0,[R1, #+52]
    220          
    221            /* Enable LTDC by setting LTDCEN bit */
    222            __HAL_LTDC_ENABLE(hltdc);
   \   0000011E   0x6820             LDR      R0,[R4, #+0]
   \   00000120   0x6980             LDR      R0,[R0, #+24]
   \   00000122   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000126   0x6821             LDR      R1,[R4, #+0]
   \   00000128   0x6188             STR      R0,[R1, #+24]
    223          
    224            /* Initialize the error code */
    225            hltdc->ErrorCode = HAL_LTDC_ERROR_NONE;  
   \   0000012A   0x2000             MOVS     R0,#+0
   \   0000012C   0xF8C4 0x00A4      STR      R0,[R4, #+164]
    226          
    227            /* Initialize the LTDC state*/
    228            hltdc->State = HAL_LTDC_STATE_READY;
   \   00000130   0x2001             MOVS     R0,#+1
   \   00000132   0xF884 0x00A1      STRB     R0,[R4, #+161]
    229          
    230            return HAL_OK;
   \   00000136   0x2000             MOVS     R0,#+0
   \                     ??HAL_LTDC_Init_1: (+1)
   \   00000138   0xBD70             POP      {R4-R6,PC}       ;; return
    231          }
    232          
    233          /**
    234            * @brief  Deinitializes the LTDC peripheral registers to their default reset
    235            *         values.
    236            * @param  hltdc: pointer to a LTDC_HandleTypeDef structure that contains
    237            *                the configuration information for the LTDC.
    238            * @retval None
    239            */
    240          

   \                                 In section .text, align 2, keep-with-next
    241          HAL_StatusTypeDef HAL_LTDC_DeInit(LTDC_HandleTypeDef *hltdc)
    242          {
   \                     HAL_LTDC_DeInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    243            /* DeInit the low level hardware */
    244            HAL_LTDC_MspDeInit(hltdc); 
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0x.... 0x....      BL       HAL_LTDC_MspDeInit
    245          
    246            /* Initialize the error code */
    247            hltdc->ErrorCode = HAL_LTDC_ERROR_NONE;
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0xF8C4 0x00A4      STR      R0,[R4, #+164]
    248          
    249            /* Initialize the LTDC state*/
    250            hltdc->State = HAL_LTDC_STATE_RESET;
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0xF884 0x00A1      STRB     R0,[R4, #+161]
    251          
    252            /* Release Lock */
    253            __HAL_UNLOCK(hltdc);
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0xF884 0x00A0      STRB     R0,[R4, #+160]
    254          
    255            return HAL_OK;
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0xBD10             POP      {R4,PC}          ;; return
    256          }
    257          
    258          /**
    259            * @brief  Initializes the LTDC MSP.
    260            * @param  hltdc : pointer to a LTDC_HandleTypeDef structure that contains
    261            *                the configuration information for the LTDC.
    262            * @retval None
    263            */

   \                                 In section .text, align 2, keep-with-next
    264          __weak void HAL_LTDC_MspInit(LTDC_HandleTypeDef* hltdc)
    265          {
    266            /* NOTE : This function Should not be modified, when the callback is needed,
    267                      the HAL_LTDC_MspInit could be implemented in the user file
    268             */ 
    269          }
   \                     HAL_LTDC_MspInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    270          
    271          /**
    272            * @brief  DeInitializes the LTDC MSP.
    273            * @param  hltdc : pointer to a LTDC_HandleTypeDef structure that contains
    274            *                the configuration information for the LTDC.
    275            * @retval None
    276            */

   \                                 In section .text, align 2, keep-with-next
    277          __weak void HAL_LTDC_MspDeInit(LTDC_HandleTypeDef* hltdc)
    278          {
    279            /* NOTE : This function Should not be modified, when the callback is needed,
    280                      the HAL_LTDC_MspDeInit could be implemented in the user file
    281             */
    282          }
   \                     HAL_LTDC_MspDeInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    283          
    284          /**
    285            * @}
    286            */
    287            
    288          /** @defgroup LTDC_Exported_Functions_Group2 IO operation functions 
    289           *  @brief   IO operation functions  
    290           *
    291          @verbatim
    292           ===============================================================================
    293                                #####  IO operation functions  #####
    294           ===============================================================================  
    295              [..]  This section provides function allowing to:
    296                (+) Handle LTDC interrupt request
    297          
    298          @endverbatim
    299            * @{
    300            */
    301          /**
    302            * @brief  Handles LTDC interrupt request.
    303            * @param  hltdc: pointer to a LTDC_HandleTypeDef structure that contains
    304            *                the configuration information for the LTDC.  
    305            * @retval HAL status
    306            */

   \                                 In section .text, align 2, keep-with-next
    307          void HAL_LTDC_IRQHandler(LTDC_HandleTypeDef *hltdc)
    308          {
   \                     HAL_LTDC_IRQHandler: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    309            /* Transfer Error Interrupt management ***************************************/
    310            if(__HAL_LTDC_GET_FLAG(hltdc, LTDC_FLAG_TE) != RESET)
   \   00000004   0x6820             LDR      R0,[R4, #+0]
   \   00000006   0x6B80             LDR      R0,[R0, #+56]
   \   00000008   0x0740             LSLS     R0,R0,#+29
   \   0000000A   0xD51B             BPL.N    ??HAL_LTDC_IRQHandler_0
    311            {
    312              if(__HAL_LTDC_GET_IT_SOURCE(hltdc, LTDC_IT_TE) != RESET)
   \   0000000C   0x6820             LDR      R0,[R4, #+0]
   \   0000000E   0x6B80             LDR      R0,[R0, #+56]
   \   00000010   0x0740             LSLS     R0,R0,#+29
   \   00000012   0xD517             BPL.N    ??HAL_LTDC_IRQHandler_0
    313              {
    314                /* Disable the transfer Error interrupt */
    315                __HAL_LTDC_DISABLE_IT(hltdc, LTDC_IT_TE);
   \   00000014   0x6820             LDR      R0,[R4, #+0]
   \   00000016   0x6B40             LDR      R0,[R0, #+52]
   \   00000018   0xF030 0x0004      BICS     R0,R0,#0x4
   \   0000001C   0x6821             LDR      R1,[R4, #+0]
   \   0000001E   0x6348             STR      R0,[R1, #+52]
    316          
    317                /* Clear the transfer error flag */
    318                __HAL_LTDC_CLEAR_FLAG(hltdc, LTDC_FLAG_TE);
   \   00000020   0x2004             MOVS     R0,#+4
   \   00000022   0x6821             LDR      R1,[R4, #+0]
   \   00000024   0x63C8             STR      R0,[R1, #+60]
    319          
    320                /* Update error code */
    321                hltdc->ErrorCode |= HAL_LTDC_ERROR_TE;
   \   00000026   0xF8D4 0x00A4      LDR      R0,[R4, #+164]
   \   0000002A   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   0000002E   0xF8C4 0x00A4      STR      R0,[R4, #+164]
    322          
    323                /* Change LTDC state */
    324                hltdc->State = HAL_LTDC_STATE_ERROR;
   \   00000032   0x2004             MOVS     R0,#+4
   \   00000034   0xF884 0x00A1      STRB     R0,[R4, #+161]
    325          
    326                /* Process unlocked */
    327                __HAL_UNLOCK(hltdc);
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0xF884 0x00A0      STRB     R0,[R4, #+160]
    328          
    329                /* Transfer error Callback */
    330                HAL_LTDC_ErrorCallback(hltdc);
   \   0000003E   0x0020             MOVS     R0,R4
   \   00000040   0x.... 0x....      BL       HAL_LTDC_ErrorCallback
    331              }
    332            }
    333            /* FIFO underrun Interrupt management ***************************************/
    334            if(__HAL_LTDC_GET_FLAG(hltdc, LTDC_FLAG_FU) != RESET)
   \                     ??HAL_LTDC_IRQHandler_0: (+1)
   \   00000044   0x6820             LDR      R0,[R4, #+0]
   \   00000046   0x6B80             LDR      R0,[R0, #+56]
   \   00000048   0x0780             LSLS     R0,R0,#+30
   \   0000004A   0xD51B             BPL.N    ??HAL_LTDC_IRQHandler_1
    335            {
    336              if(__HAL_LTDC_GET_IT_SOURCE(hltdc, LTDC_IT_FU) != RESET)
   \   0000004C   0x6820             LDR      R0,[R4, #+0]
   \   0000004E   0x6B80             LDR      R0,[R0, #+56]
   \   00000050   0x0780             LSLS     R0,R0,#+30
   \   00000052   0xD517             BPL.N    ??HAL_LTDC_IRQHandler_1
    337              {
    338                /* Disable the FIFO underrun interrupt */
    339                __HAL_LTDC_DISABLE_IT(hltdc, LTDC_IT_FU);
   \   00000054   0x6820             LDR      R0,[R4, #+0]
   \   00000056   0x6B40             LDR      R0,[R0, #+52]
   \   00000058   0xF030 0x0002      BICS     R0,R0,#0x2
   \   0000005C   0x6821             LDR      R1,[R4, #+0]
   \   0000005E   0x6348             STR      R0,[R1, #+52]
    340          
    341                /* Clear the FIFO underrun flag */
    342                __HAL_LTDC_CLEAR_FLAG(hltdc, LTDC_FLAG_FU);
   \   00000060   0x2002             MOVS     R0,#+2
   \   00000062   0x6821             LDR      R1,[R4, #+0]
   \   00000064   0x63C8             STR      R0,[R1, #+60]
    343          
    344                /* Update error code */
    345                hltdc->ErrorCode |= HAL_LTDC_ERROR_FU;
   \   00000066   0xF8D4 0x00A4      LDR      R0,[R4, #+164]
   \   0000006A   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   0000006E   0xF8C4 0x00A4      STR      R0,[R4, #+164]
    346          
    347                /* Change LTDC state */
    348                hltdc->State = HAL_LTDC_STATE_ERROR;
   \   00000072   0x2004             MOVS     R0,#+4
   \   00000074   0xF884 0x00A1      STRB     R0,[R4, #+161]
    349          
    350                /* Process unlocked */
    351                __HAL_UNLOCK(hltdc);
   \   00000078   0x2000             MOVS     R0,#+0
   \   0000007A   0xF884 0x00A0      STRB     R0,[R4, #+160]
    352                
    353                /* Transfer error Callback */
    354                HAL_LTDC_ErrorCallback(hltdc);
   \   0000007E   0x0020             MOVS     R0,R4
   \   00000080   0x.... 0x....      BL       HAL_LTDC_ErrorCallback
    355              }
    356            }
    357            /* Line Interrupt management ************************************************/
    358            if(__HAL_LTDC_GET_FLAG(hltdc, LTDC_FLAG_LI) != RESET)
   \                     ??HAL_LTDC_IRQHandler_1: (+1)
   \   00000084   0x6820             LDR      R0,[R4, #+0]
   \   00000086   0x6B80             LDR      R0,[R0, #+56]
   \   00000088   0x07C0             LSLS     R0,R0,#+31
   \   0000008A   0xD515             BPL.N    ??HAL_LTDC_IRQHandler_2
    359            {
    360              if(__HAL_LTDC_GET_IT_SOURCE(hltdc, LTDC_IT_LI) != RESET)
   \   0000008C   0x6820             LDR      R0,[R4, #+0]
   \   0000008E   0x6B80             LDR      R0,[R0, #+56]
   \   00000090   0x07C0             LSLS     R0,R0,#+31
   \   00000092   0xD511             BPL.N    ??HAL_LTDC_IRQHandler_2
    361              {
    362                /* Disable the Line interrupt */
    363                __HAL_LTDC_DISABLE_IT(hltdc, LTDC_IT_LI);
   \   00000094   0x6820             LDR      R0,[R4, #+0]
   \   00000096   0x6B40             LDR      R0,[R0, #+52]
   \   00000098   0x0840             LSRS     R0,R0,#+1
   \   0000009A   0x0040             LSLS     R0,R0,#+1
   \   0000009C   0x6821             LDR      R1,[R4, #+0]
   \   0000009E   0x6348             STR      R0,[R1, #+52]
    364          
    365                /* Clear the Line interrupt flag */  
    366                __HAL_LTDC_CLEAR_FLAG(hltdc, LTDC_FLAG_LI);
   \   000000A0   0x2001             MOVS     R0,#+1
   \   000000A2   0x6821             LDR      R1,[R4, #+0]
   \   000000A4   0x63C8             STR      R0,[R1, #+60]
    367          
    368                /* Change LTDC state */
    369                hltdc->State = HAL_LTDC_STATE_READY;
   \   000000A6   0x2001             MOVS     R0,#+1
   \   000000A8   0xF884 0x00A1      STRB     R0,[R4, #+161]
    370          
    371                /* Process unlocked */
    372                __HAL_UNLOCK(hltdc);
   \   000000AC   0x2000             MOVS     R0,#+0
   \   000000AE   0xF884 0x00A0      STRB     R0,[R4, #+160]
    373          
    374                /* Line interrupt Callback */
    375                HAL_LTDC_LineEvenCallback(hltdc);
   \   000000B2   0x0020             MOVS     R0,R4
   \   000000B4   0x.... 0x....      BL       HAL_LTDC_LineEventCallback
    376              }
    377            }
    378          }
   \                     ??HAL_LTDC_IRQHandler_2: (+1)
   \   000000B8   0xBD10             POP      {R4,PC}          ;; return
    379          
    380          /**
    381            * @brief  Error LTDC callback.
    382            * @param  hltdc: pointer to a LTDC_HandleTypeDef structure that contains
    383            *                the configuration information for the LTDC.
    384            * @retval None
    385            */

   \                                 In section .text, align 2, keep-with-next
    386          __weak void HAL_LTDC_ErrorCallback(LTDC_HandleTypeDef *hltdc)
    387          {
    388            /* NOTE : This function Should not be modified, when the callback is needed,
    389                      the HAL_LTDC_ErrorCallback could be implemented in the user file
    390             */
    391          }
   \                     HAL_LTDC_ErrorCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    392          
    393          /**
    394            * @brief  Line Event callback.
    395            * @param  hltdc: pointer to a LTDC_HandleTypeDef structure that contains
    396            *                the configuration information for the LTDC.
    397            * @retval None
    398            */

   \                                 In section .text, align 2, keep-with-next
    399          __weak void HAL_LTDC_LineEvenCallback(LTDC_HandleTypeDef *hltdc)
    400          {
    401            /* NOTE : This function Should not be modified, when the callback is needed,
    402                      the HAL_LTDC_LineEvenCallback could be implemented in the user file
    403             */
    404          }
   \                     HAL_LTDC_LineEventCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    405          
    406          /**
    407            * @}
    408            */
    409          
    410          /** @defgroup LTDC_Exported_Functions_Group3 Peripheral Control functions
    411           *  @brief    Peripheral Control functions 
    412           *
    413          @verbatim   
    414           ===============================================================================
    415                              ##### Peripheral Control functions #####
    416           ===============================================================================  
    417              [..]  This section provides functions allowing to:
    418                (+) Configure the LTDC foreground or/and background parameters.
    419                (+) Set the active layer.
    420                (+) Configure the color keying.
    421                (+) Configure the C-LUT.
    422                (+) Enable / Disable the color keying.
    423                (+) Enable / Disable the C-LUT.
    424                (+) Update the layer position.
    425                (+) Update the layer size.
    426                (+) Update pixel format on the fly. 
    427                (+) Update transparency on the fly.
    428                (+) Update address on the fly.
    429          
    430          @endverbatim
    431            * @{
    432            */
    433          
    434          /**
    435            * @brief  Configure the LTDC Layer according to the specified
    436            *         parameters in the LTDC_InitTypeDef and create the associated handle.
    437            * @param  hltdc:     pointer to a LTDC_HandleTypeDef structure that contains
    438            *                    the configuration information for the LTDC.
    439            * @param  pLayerCfg: pointer to a LTDC_LayerCfgTypeDef structure that contains
    440            *                    the configuration information for the Layer.
    441            * @param  LayerIdx:  LTDC Layer index.
    442            *                    This parameter can be one of the following values:
    443            *                    0 or 1
    444            * @retval HAL status
    445            */

   \                                 In section .text, align 2, keep-with-next
    446          HAL_StatusTypeDef HAL_LTDC_ConfigLayer(LTDC_HandleTypeDef *hltdc, LTDC_LayerCfgTypeDef *pLayerCfg, uint32_t LayerIdx)
    447          {   
   \                     HAL_LTDC_ConfigLayer: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    448            /* Process locked */
    449            __HAL_LOCK(hltdc);
   \   00000008   0xF894 0x00A0      LDRB     R0,[R4, #+160]
   \   0000000C   0x2801             CMP      R0,#+1
   \   0000000E   0xD101             BNE.N    ??HAL_LTDC_ConfigLayer_0
   \   00000010   0x2002             MOVS     R0,#+2
   \   00000012   0xE01C             B.N      ??HAL_LTDC_ConfigLayer_1
   \                     ??HAL_LTDC_ConfigLayer_0: (+1)
   \   00000014   0x2001             MOVS     R0,#+1
   \   00000016   0xF884 0x00A0      STRB     R0,[R4, #+160]
    450            
    451            /* Change LTDC peripheral state */
    452            hltdc->State = HAL_LTDC_STATE_BUSY;
   \   0000001A   0x2002             MOVS     R0,#+2
   \   0000001C   0xF884 0x00A1      STRB     R0,[R4, #+161]
    453          
    454            /* Check the parameters */
    455            assert_param(IS_LTDC_LAYER(LayerIdx));
    456            assert_param(IS_LTDC_PIXEL_FORMAT(pLayerCfg->PixelFormat));
    457            assert_param(IS_LTDC_BLENDING_FACTOR1(pLayerCfg->BlendingFactor1));
    458            assert_param(IS_LTDC_BLENDING_FACTOR2(pLayerCfg->BlendingFactor2));
    459            assert_param(IS_LTDC_HCONFIGST(pLayerCfg->WindowX0));
    460            assert_param(IS_LTDC_HCONFIGSP(pLayerCfg->WindowX1));
    461            assert_param(IS_LTDC_VCONFIGST(pLayerCfg->WindowY0));
    462            assert_param(IS_LTDC_VCONFIGSP(pLayerCfg->WindowY1));
    463            assert_param(IS_LTDC_ALPHA(pLayerCfg->Alpha0));
    464            assert_param(IS_LTDC_CFBLL(pLayerCfg->ImageWidth));
    465            assert_param(IS_LTDC_CFBLNBR(pLayerCfg->ImageHeight));
    466          
    467            /* Copy new layer configuration into handle structure */
    468            hltdc->LayerCfg[LayerIdx] = *pLayerCfg;  
   \   00000020   0x2034             MOVS     R0,#+52
   \   00000022   0xFB00 0x4006      MLA      R0,R0,R6,R4
   \   00000026   0x3038             ADDS     R0,R0,#+56
   \   00000028   0x0029             MOVS     R1,R5
   \   0000002A   0x2234             MOVS     R2,#+52
   \   0000002C   0x.... 0x....      BL       __aeabi_memcpy4
    469          
    470            /* Configure the LTDC Layer */  
    471            LTDC_SetConfig(hltdc, pLayerCfg, LayerIdx);
   \   00000030   0x0032             MOVS     R2,R6
   \   00000032   0x0029             MOVS     R1,R5
   \   00000034   0x0020             MOVS     R0,R4
   \   00000036   0x.... 0x....      BL       LTDC_SetConfig
    472          
    473            /* Sets the Reload type */
    474            hltdc->Instance->SRCR = LTDC_SRCR_IMR;
   \   0000003A   0x2001             MOVS     R0,#+1
   \   0000003C   0x6821             LDR      R1,[R4, #+0]
   \   0000003E   0x6248             STR      R0,[R1, #+36]
    475          
    476            /* Initialize the LTDC state*/
    477            hltdc->State  = HAL_LTDC_STATE_READY;
   \   00000040   0x2001             MOVS     R0,#+1
   \   00000042   0xF884 0x00A1      STRB     R0,[R4, #+161]
    478          
    479            /* Process unlocked */
    480            __HAL_UNLOCK(hltdc);
   \   00000046   0x2000             MOVS     R0,#+0
   \   00000048   0xF884 0x00A0      STRB     R0,[R4, #+160]
    481          
    482            return HAL_OK;
   \   0000004C   0x2000             MOVS     R0,#+0
   \                     ??HAL_LTDC_ConfigLayer_1: (+1)
   \   0000004E   0xBD70             POP      {R4-R6,PC}       ;; return
    483          }
    484          
    485          /**
    486            * @brief  Configure the color keying.
    487            * @param  hltdc:    pointer to a LTDC_HandleTypeDef structure that contains
    488            *                   the configuration information for the LTDC.
    489            * @param  RGBValue: the color key value
    490            * @param  LayerIdx:  LTDC Layer index.
    491            *                   This parameter can be one of the following values:
    492            *                   0 or 1
    493            * @retval HAL status
    494            */

   \                                 In section .text, align 2, keep-with-next
    495          HAL_StatusTypeDef HAL_LTDC_ConfigColorKeying(LTDC_HandleTypeDef *hltdc, uint32_t RGBValue, uint32_t LayerIdx)
    496          {
   \                     HAL_LTDC_ConfigColorKeying: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
   \   00000002   0x0003             MOVS     R3,R0
    497            /* Process locked */
    498            __HAL_LOCK(hltdc);
   \   00000004   0xF893 0x00A0      LDRB     R0,[R3, #+160]
   \   00000008   0x2801             CMP      R0,#+1
   \   0000000A   0xD101             BNE.N    ??HAL_LTDC_ConfigColorKeying_0
   \   0000000C   0x2002             MOVS     R0,#+2
   \   0000000E   0xE023             B.N      ??HAL_LTDC_ConfigColorKeying_1
   \                     ??HAL_LTDC_ConfigColorKeying_0: (+1)
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0xF883 0x00A0      STRB     R0,[R3, #+160]
    499          
    500            /* Change LTDC peripheral state */
    501            hltdc->State = HAL_LTDC_STATE_BUSY;
   \   00000016   0x2002             MOVS     R0,#+2
   \   00000018   0xF883 0x00A1      STRB     R0,[R3, #+161]
    502          
    503            /* Check the parameters */
    504            assert_param(IS_LTDC_LAYER(LayerIdx));
    505          
    506            /* Configures the default color values */
    507            LTDC_LAYER(hltdc, LayerIdx)->CKCR &=  ~(LTDC_LxCKCR_CKBLUE | LTDC_LxCKCR_CKGREEN | LTDC_LxCKCR_CKRED);
   \   0000001C   0x6818             LDR      R0,[R3, #+0]
   \   0000001E   0x2480             MOVS     R4,#+128
   \   00000020   0xFB04 0x0002      MLA      R0,R4,R2,R0
   \   00000024   0x3084             ADDS     R0,R0,#+132
   \   00000026   0x681C             LDR      R4,[R3, #+0]
   \   00000028   0x2580             MOVS     R5,#+128
   \   0000002A   0xFB05 0x4402      MLA      R4,R5,R2,R4
   \   0000002E   0x3484             ADDS     R4,R4,#+132
   \   00000030   0x68E4             LDR      R4,[R4, #+12]
   \   00000032   0xF014 0x447F      ANDS     R4,R4,#0xFF000000
   \   00000036   0x60C4             STR      R4,[R0, #+12]
    508            LTDC_LAYER(hltdc, LayerIdx)->CKCR  = RGBValue;
   \   00000038   0x6818             LDR      R0,[R3, #+0]
   \   0000003A   0x2480             MOVS     R4,#+128
   \   0000003C   0xFB04 0x0002      MLA      R0,R4,R2,R0
   \   00000040   0x3084             ADDS     R0,R0,#+132
   \   00000042   0x60C1             STR      R1,[R0, #+12]
    509          
    510            /* Sets the Reload type */
    511            hltdc->Instance->SRCR = LTDC_SRCR_IMR;
   \   00000044   0x2001             MOVS     R0,#+1
   \   00000046   0x681C             LDR      R4,[R3, #+0]
   \   00000048   0x6260             STR      R0,[R4, #+36]
    512          
    513            /* Change the LTDC state*/
    514            hltdc->State = HAL_LTDC_STATE_READY;
   \   0000004A   0x2001             MOVS     R0,#+1
   \   0000004C   0xF883 0x00A1      STRB     R0,[R3, #+161]
    515          
    516            /* Process unlocked */
    517            __HAL_UNLOCK(hltdc);
   \   00000050   0x2000             MOVS     R0,#+0
   \   00000052   0xF883 0x00A0      STRB     R0,[R3, #+160]
    518          
    519            return HAL_OK;
   \   00000056   0x2000             MOVS     R0,#+0
   \                     ??HAL_LTDC_ConfigColorKeying_1: (+1)
   \   00000058   0xBC30             POP      {R4,R5}
   \   0000005A   0x4770             BX       LR               ;; return
    520          }
    521          
    522          /**
    523            * @brief  Load the color lookup table.
    524            * @param  hltdc:    pointer to a LTDC_HandleTypeDef structure that contains
    525            *                   the configuration information for the LTDC.
    526            * @param  pCLUT:    pointer to the color lookup table address.
    527            * @param  CLUTSize: the color lookup table size.  
    528            * @param  LayerIdx:  LTDC Layer index.
    529            *                   This parameter can be one of the following values:
    530            *                   0 or 1
    531            * @retval HAL status
    532            */

   \                                 In section .text, align 2, keep-with-next
    533          HAL_StatusTypeDef HAL_LTDC_ConfigCLUT(LTDC_HandleTypeDef *hltdc, uint32_t *pCLUT, uint32_t CLUTSize, uint32_t LayerIdx)
    534          {
   \                     HAL_LTDC_ConfigCLUT: (+1)
   \   00000000   0xB4F0             PUSH     {R4-R7}
   \   00000002   0x0004             MOVS     R4,R0
    535            uint32_t tmp = 0;
   \   00000004   0x2500             MOVS     R5,#+0
    536            uint32_t counter = 0;
   \   00000006   0x2600             MOVS     R6,#+0
    537            uint32_t pcounter = 0;
   \   00000008   0x2700             MOVS     R7,#+0
    538          
    539            /* Process locked */
    540            __HAL_LOCK(hltdc);
   \   0000000A   0xF894 0x00A0      LDRB     R0,[R4, #+160]
   \   0000000E   0x2801             CMP      R0,#+1
   \   00000010   0xD101             BNE.N    ??HAL_LTDC_ConfigCLUT_0
   \   00000012   0x2002             MOVS     R0,#+2
   \   00000014   0xE049             B.N      ??HAL_LTDC_ConfigCLUT_1
   \                     ??HAL_LTDC_ConfigCLUT_0: (+1)
   \   00000016   0x2001             MOVS     R0,#+1
   \   00000018   0xF884 0x00A0      STRB     R0,[R4, #+160]
    541          
    542            /* Change LTDC peripheral state */
    543            hltdc->State = HAL_LTDC_STATE_BUSY;  
   \   0000001C   0x2002             MOVS     R0,#+2
   \   0000001E   0xF884 0x00A1      STRB     R0,[R4, #+161]
    544          
    545            /* Check the parameters */
    546            assert_param(IS_LTDC_LAYER(LayerIdx)); 
    547          
    548            for(counter = 0; (counter < CLUTSize); counter++)
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0x0006             MOVS     R6,R0
   \                     ??HAL_LTDC_ConfigCLUT_2: (+1)
   \   00000026   0x4296             CMP      R6,R2
   \   00000028   0xD238             BCS.N    ??HAL_LTDC_ConfigCLUT_3
    549            {
    550              if(hltdc->LayerCfg[LayerIdx].PixelFormat == LTDC_PIXEL_FORMAT_AL44)
   \   0000002A   0x2034             MOVS     R0,#+52
   \   0000002C   0xFB00 0x4003      MLA      R0,R0,R3,R4
   \   00000030   0x6C80             LDR      R0,[R0, #+72]
   \   00000032   0x2806             CMP      R0,#+6
   \   00000034   0xD115             BNE.N    ??HAL_LTDC_ConfigCLUT_4
    551              {
    552                tmp  = (((counter + 16*counter) << 24) | ((uint32_t)(*pCLUT) & 0xFF) | ((uint32_t)(*pCLUT) & 0xFF00) | ((uint32_t)(*pCLUT) & 0xFF0000));
   \   00000036   0xEB16 0x1006      ADDS     R0,R6,R6, LSL #+4
   \   0000003A   0xF891 0xC000      LDRB     R12,[R1, #+0]
   \   0000003E   0xFA5F 0xFC8C      UXTB     R12,R12          ;; ZeroExt  R12,R12,#+24,#+24
   \   00000042   0xEA5C 0x6000      ORRS     R0,R12,R0, LSL #+24
   \   00000046   0xF8D1 0xC000      LDR      R12,[R1, #+0]
   \   0000004A   0xF41C 0x4C7F      ANDS     R12,R12,#0xFF00
   \   0000004E   0xEA5C 0x0000      ORRS     R0,R12,R0
   \   00000052   0xF8D1 0xC000      LDR      R12,[R1, #+0]
   \   00000056   0xF41C 0x0C7F      ANDS     R12,R12,#0xFF0000
   \   0000005A   0xEA5C 0x0000      ORRS     R0,R12,R0
   \   0000005E   0x0005             MOVS     R5,R0
   \   00000060   0xE010             B.N      ??HAL_LTDC_ConfigCLUT_5
    553              }
    554              else
    555              { 
    556                tmp  = ((counter << 24) | ((uint32_t)(*pCLUT) & 0xFF) | ((uint32_t)(*pCLUT) & 0xFF00) | ((uint32_t)(*pCLUT) & 0xFF0000));
   \                     ??HAL_LTDC_ConfigCLUT_4: (+1)
   \   00000062   0x7808             LDRB     R0,[R1, #+0]
   \   00000064   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000066   0xEA50 0x6006      ORRS     R0,R0,R6, LSL #+24
   \   0000006A   0xF8D1 0xC000      LDR      R12,[R1, #+0]
   \   0000006E   0xF41C 0x4C7F      ANDS     R12,R12,#0xFF00
   \   00000072   0xEA5C 0x0000      ORRS     R0,R12,R0
   \   00000076   0xF8D1 0xC000      LDR      R12,[R1, #+0]
   \   0000007A   0xF41C 0x0C7F      ANDS     R12,R12,#0xFF0000
   \   0000007E   0xEA5C 0x0000      ORRS     R0,R12,R0
   \   00000082   0x0005             MOVS     R5,R0
    557              }
    558              pcounter = (uint32_t)pCLUT + sizeof(*pCLUT);
   \                     ??HAL_LTDC_ConfigCLUT_5: (+1)
   \   00000084   0x1D08             ADDS     R0,R1,#+4
   \   00000086   0x0007             MOVS     R7,R0
    559              pCLUT = (uint32_t *)pcounter;
   \   00000088   0x0039             MOVS     R1,R7
    560          
    561              /* Specifies the C-LUT address and RGB value */
    562              LTDC_LAYER(hltdc, LayerIdx)->CLUTWR  = tmp;
   \   0000008A   0x6820             LDR      R0,[R4, #+0]
   \   0000008C   0xF05F 0x0C80      MOVS     R12,#+128
   \   00000090   0xFB0C 0x0003      MLA      R0,R12,R3,R0
   \   00000094   0x3084             ADDS     R0,R0,#+132
   \   00000096   0x6405             STR      R5,[R0, #+64]
    563            }
   \   00000098   0x1C76             ADDS     R6,R6,#+1
   \   0000009A   0xE7C4             B.N      ??HAL_LTDC_ConfigCLUT_2
    564            
    565            /* Change the LTDC state*/
    566            hltdc->State = HAL_LTDC_STATE_READY; 
   \                     ??HAL_LTDC_ConfigCLUT_3: (+1)
   \   0000009C   0x2001             MOVS     R0,#+1
   \   0000009E   0xF884 0x00A1      STRB     R0,[R4, #+161]
    567          
    568            /* Process unlocked */
    569            __HAL_UNLOCK(hltdc);  
   \   000000A2   0x2000             MOVS     R0,#+0
   \   000000A4   0xF884 0x00A0      STRB     R0,[R4, #+160]
    570          
    571            return HAL_OK;
   \   000000A8   0x2000             MOVS     R0,#+0
   \                     ??HAL_LTDC_ConfigCLUT_1: (+1)
   \   000000AA   0xBCF0             POP      {R4-R7}
   \   000000AC   0x4770             BX       LR               ;; return
    572          }
    573          
    574          /**
    575            * @brief  Enable the color keying.
    576            * @param  hltdc:    pointer to a LTDC_HandleTypeDef structure that contains
    577            *                   the configuration information for the LTDC.
    578            * @param  LayerIdx:  LTDC Layer index.
    579            *                   This parameter can be one of the following values:
    580            *                   0 or 1
    581            * @retval  HAL status
    582            */

   \                                 In section .text, align 2, keep-with-next
    583          HAL_StatusTypeDef HAL_LTDC_EnableColorKeying(LTDC_HandleTypeDef *hltdc, uint32_t LayerIdx)
    584          {  
   \                     HAL_LTDC_EnableColorKeying: (+1)
   \   00000000   0xB410             PUSH     {R4}
   \   00000002   0x0002             MOVS     R2,R0
    585            /* Process locked */
    586            __HAL_LOCK(hltdc);
   \   00000004   0xF892 0x00A0      LDRB     R0,[R2, #+160]
   \   00000008   0x2801             CMP      R0,#+1
   \   0000000A   0xD101             BNE.N    ??HAL_LTDC_EnableColorKeying_0
   \   0000000C   0x2002             MOVS     R0,#+2
   \   0000000E   0xE01D             B.N      ??HAL_LTDC_EnableColorKeying_1
   \                     ??HAL_LTDC_EnableColorKeying_0: (+1)
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0xF882 0x00A0      STRB     R0,[R2, #+160]
    587          
    588            /* Change LTDC peripheral state */
    589            hltdc->State = HAL_LTDC_STATE_BUSY;
   \   00000016   0x2002             MOVS     R0,#+2
   \   00000018   0xF882 0x00A1      STRB     R0,[R2, #+161]
    590          
    591            /* Check the parameters */
    592            assert_param(IS_LTDC_LAYER(LayerIdx));
    593          
    594            /* Enable LTDC color keying by setting COLKEN bit */
    595            LTDC_LAYER(hltdc, LayerIdx)->CR |= (uint32_t)LTDC_LxCR_COLKEN;
   \   0000001C   0x6810             LDR      R0,[R2, #+0]
   \   0000001E   0x2380             MOVS     R3,#+128
   \   00000020   0xFB03 0x0001      MLA      R0,R3,R1,R0
   \   00000024   0xF8D0 0x0084      LDR      R0,[R0, #+132]
   \   00000028   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   0000002C   0x6813             LDR      R3,[R2, #+0]
   \   0000002E   0x2480             MOVS     R4,#+128
   \   00000030   0xFB04 0x3301      MLA      R3,R4,R1,R3
   \   00000034   0xF8C3 0x0084      STR      R0,[R3, #+132]
    596          
    597            /* Sets the Reload type */
    598            hltdc->Instance->SRCR = LTDC_SRCR_IMR;
   \   00000038   0x2001             MOVS     R0,#+1
   \   0000003A   0x6813             LDR      R3,[R2, #+0]
   \   0000003C   0x6258             STR      R0,[R3, #+36]
    599          
    600            /* Change the LTDC state*/
    601            hltdc->State = HAL_LTDC_STATE_READY; 
   \   0000003E   0x2001             MOVS     R0,#+1
   \   00000040   0xF882 0x00A1      STRB     R0,[R2, #+161]
    602          
    603            /* Process unlocked */
    604            __HAL_UNLOCK(hltdc);
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0xF882 0x00A0      STRB     R0,[R2, #+160]
    605          
    606            return HAL_OK;  
   \   0000004A   0x2000             MOVS     R0,#+0
   \                     ??HAL_LTDC_EnableColorKeying_1: (+1)
   \   0000004C   0xBC10             POP      {R4}
   \   0000004E   0x4770             BX       LR               ;; return
    607          }
    608            
    609          /**
    610            * @brief  Disable the color keying.
    611            * @param  hltdc:    pointer to a LTDC_HandleTypeDef structure that contains
    612            *                   the configuration information for the LTDC.
    613            * @param  LayerIdx:  LTDC Layer index.
    614            *                   This parameter can be one of the following values:
    615            *                   0 or 1
    616            * @retval  HAL status
    617            */

   \                                 In section .text, align 2, keep-with-next
    618          HAL_StatusTypeDef HAL_LTDC_DisableColorKeying(LTDC_HandleTypeDef *hltdc, uint32_t LayerIdx)
    619          {
   \                     HAL_LTDC_DisableColorKeying: (+1)
   \   00000000   0xB410             PUSH     {R4}
   \   00000002   0x0002             MOVS     R2,R0
    620            /* Process locked */
    621            __HAL_LOCK(hltdc);
   \   00000004   0xF892 0x00A0      LDRB     R0,[R2, #+160]
   \   00000008   0x2801             CMP      R0,#+1
   \   0000000A   0xD101             BNE.N    ??HAL_LTDC_DisableColorKeying_0
   \   0000000C   0x2002             MOVS     R0,#+2
   \   0000000E   0xE01D             B.N      ??HAL_LTDC_DisableColorKeying_1
   \                     ??HAL_LTDC_DisableColorKeying_0: (+1)
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0xF882 0x00A0      STRB     R0,[R2, #+160]
    622          
    623            /* Change LTDC peripheral state */
    624            hltdc->State = HAL_LTDC_STATE_BUSY;
   \   00000016   0x2002             MOVS     R0,#+2
   \   00000018   0xF882 0x00A1      STRB     R0,[R2, #+161]
    625          
    626            /* Check the parameters */
    627            assert_param(IS_LTDC_LAYER(LayerIdx));
    628          
    629            /* Disable LTDC color keying by setting COLKEN bit */
    630            LTDC_LAYER(hltdc, LayerIdx)->CR &= ~(uint32_t)LTDC_LxCR_COLKEN;
   \   0000001C   0x6810             LDR      R0,[R2, #+0]
   \   0000001E   0x2380             MOVS     R3,#+128
   \   00000020   0xFB03 0x0001      MLA      R0,R3,R1,R0
   \   00000024   0xF8D0 0x0084      LDR      R0,[R0, #+132]
   \   00000028   0xF030 0x0002      BICS     R0,R0,#0x2
   \   0000002C   0x6813             LDR      R3,[R2, #+0]
   \   0000002E   0x2480             MOVS     R4,#+128
   \   00000030   0xFB04 0x3301      MLA      R3,R4,R1,R3
   \   00000034   0xF8C3 0x0084      STR      R0,[R3, #+132]
    631          
    632            /* Sets the Reload type */
    633            hltdc->Instance->SRCR = LTDC_SRCR_IMR;
   \   00000038   0x2001             MOVS     R0,#+1
   \   0000003A   0x6813             LDR      R3,[R2, #+0]
   \   0000003C   0x6258             STR      R0,[R3, #+36]
    634          
    635            /* Change the LTDC state*/
    636            hltdc->State = HAL_LTDC_STATE_READY; 
   \   0000003E   0x2001             MOVS     R0,#+1
   \   00000040   0xF882 0x00A1      STRB     R0,[R2, #+161]
    637          
    638            /* Process unlocked */
    639            __HAL_UNLOCK(hltdc);
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0xF882 0x00A0      STRB     R0,[R2, #+160]
    640          
    641            return HAL_OK;
   \   0000004A   0x2000             MOVS     R0,#+0
   \                     ??HAL_LTDC_DisableColorKeying_1: (+1)
   \   0000004C   0xBC10             POP      {R4}
   \   0000004E   0x4770             BX       LR               ;; return
    642          }
    643          
    644          /**
    645            * @brief  Enable the color lookup table.
    646            * @param  hltdc:    pointer to a LTDC_HandleTypeDef structure that contains
    647            *                   the configuration information for the LTDC.
    648            * @param  LayerIdx:  LTDC Layer index.
    649            *                   This parameter can be one of the following values:
    650            *                   0 or 1
    651            * @retval  HAL status
    652            */

   \                                 In section .text, align 2, keep-with-next
    653          HAL_StatusTypeDef HAL_LTDC_EnableCLUT(LTDC_HandleTypeDef *hltdc, uint32_t LayerIdx)
    654          {
   \                     HAL_LTDC_EnableCLUT: (+1)
   \   00000000   0xB410             PUSH     {R4}
   \   00000002   0x0002             MOVS     R2,R0
    655          
    656            /* Process locked */
    657            __HAL_LOCK(hltdc);
   \   00000004   0xF892 0x00A0      LDRB     R0,[R2, #+160]
   \   00000008   0x2801             CMP      R0,#+1
   \   0000000A   0xD101             BNE.N    ??HAL_LTDC_EnableCLUT_0
   \   0000000C   0x2002             MOVS     R0,#+2
   \   0000000E   0xE01D             B.N      ??HAL_LTDC_EnableCLUT_1
   \                     ??HAL_LTDC_EnableCLUT_0: (+1)
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0xF882 0x00A0      STRB     R0,[R2, #+160]
    658          
    659            /* Change LTDC peripheral state */
    660            hltdc->State = HAL_LTDC_STATE_BUSY;
   \   00000016   0x2002             MOVS     R0,#+2
   \   00000018   0xF882 0x00A1      STRB     R0,[R2, #+161]
    661          
    662            /* Check the parameters */
    663            assert_param(IS_LTDC_LAYER(LayerIdx));
    664          
    665            /* Disable LTDC color lookup table by setting CLUTEN bit */
    666            LTDC_LAYER(hltdc, LayerIdx)->CR |= (uint32_t)LTDC_LxCR_CLUTEN;
   \   0000001C   0x6810             LDR      R0,[R2, #+0]
   \   0000001E   0x2380             MOVS     R3,#+128
   \   00000020   0xFB03 0x0001      MLA      R0,R3,R1,R0
   \   00000024   0xF8D0 0x0084      LDR      R0,[R0, #+132]
   \   00000028   0xF050 0x0010      ORRS     R0,R0,#0x10
   \   0000002C   0x6813             LDR      R3,[R2, #+0]
   \   0000002E   0x2480             MOVS     R4,#+128
   \   00000030   0xFB04 0x3301      MLA      R3,R4,R1,R3
   \   00000034   0xF8C3 0x0084      STR      R0,[R3, #+132]
    667          
    668            /* Sets the Reload type */
    669            hltdc->Instance->SRCR = LTDC_SRCR_IMR;
   \   00000038   0x2001             MOVS     R0,#+1
   \   0000003A   0x6813             LDR      R3,[R2, #+0]
   \   0000003C   0x6258             STR      R0,[R3, #+36]
    670          
    671            /* Change the LTDC state*/
    672            hltdc->State = HAL_LTDC_STATE_READY; 
   \   0000003E   0x2001             MOVS     R0,#+1
   \   00000040   0xF882 0x00A1      STRB     R0,[R2, #+161]
    673          
    674            /* Process unlocked */
    675            __HAL_UNLOCK(hltdc);
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0xF882 0x00A0      STRB     R0,[R2, #+160]
    676          
    677            return HAL_OK;
   \   0000004A   0x2000             MOVS     R0,#+0
   \                     ??HAL_LTDC_EnableCLUT_1: (+1)
   \   0000004C   0xBC10             POP      {R4}
   \   0000004E   0x4770             BX       LR               ;; return
    678          }
    679          
    680          /**
    681            * @brief  Disable the color lookup table.
    682            * @param  hltdc:    pointer to a LTDC_HandleTypeDef structure that contains
    683            *                   the configuration information for the LTDC.
    684            * @param  LayerIdx:  LTDC Layer index.
    685            *                   This parameter can be one of the following values:
    686            *                   0 or 1   
    687            * @retval  HAL status
    688            */

   \                                 In section .text, align 2, keep-with-next
    689          HAL_StatusTypeDef HAL_LTDC_DisableCLUT(LTDC_HandleTypeDef *hltdc, uint32_t LayerIdx)
    690          {
   \                     HAL_LTDC_DisableCLUT: (+1)
   \   00000000   0xB410             PUSH     {R4}
   \   00000002   0x0002             MOVS     R2,R0
    691           
    692            /* Process locked */
    693            __HAL_LOCK(hltdc);
   \   00000004   0xF892 0x00A0      LDRB     R0,[R2, #+160]
   \   00000008   0x2801             CMP      R0,#+1
   \   0000000A   0xD101             BNE.N    ??HAL_LTDC_DisableCLUT_0
   \   0000000C   0x2002             MOVS     R0,#+2
   \   0000000E   0xE01D             B.N      ??HAL_LTDC_DisableCLUT_1
   \                     ??HAL_LTDC_DisableCLUT_0: (+1)
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0xF882 0x00A0      STRB     R0,[R2, #+160]
    694          
    695            /* Change LTDC peripheral state */
    696            hltdc->State = HAL_LTDC_STATE_BUSY;
   \   00000016   0x2002             MOVS     R0,#+2
   \   00000018   0xF882 0x00A1      STRB     R0,[R2, #+161]
    697          
    698            /* Check the parameters */
    699            assert_param(IS_LTDC_LAYER(LayerIdx));
    700          
    701            /* Disable LTDC color lookup table by setting CLUTEN bit */
    702            LTDC_LAYER(hltdc, LayerIdx)->CR &= ~(uint32_t)LTDC_LxCR_CLUTEN;
   \   0000001C   0x6810             LDR      R0,[R2, #+0]
   \   0000001E   0x2380             MOVS     R3,#+128
   \   00000020   0xFB03 0x0001      MLA      R0,R3,R1,R0
   \   00000024   0xF8D0 0x0084      LDR      R0,[R0, #+132]
   \   00000028   0xF030 0x0010      BICS     R0,R0,#0x10
   \   0000002C   0x6813             LDR      R3,[R2, #+0]
   \   0000002E   0x2480             MOVS     R4,#+128
   \   00000030   0xFB04 0x3301      MLA      R3,R4,R1,R3
   \   00000034   0xF8C3 0x0084      STR      R0,[R3, #+132]
    703          
    704            /* Sets the Reload type */
    705            hltdc->Instance->SRCR = LTDC_SRCR_IMR;
   \   00000038   0x2001             MOVS     R0,#+1
   \   0000003A   0x6813             LDR      R3,[R2, #+0]
   \   0000003C   0x6258             STR      R0,[R3, #+36]
    706          
    707            /* Change the LTDC state*/
    708            hltdc->State = HAL_LTDC_STATE_READY; 
   \   0000003E   0x2001             MOVS     R0,#+1
   \   00000040   0xF882 0x00A1      STRB     R0,[R2, #+161]
    709          
    710            /* Process unlocked */
    711            __HAL_UNLOCK(hltdc);
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0xF882 0x00A0      STRB     R0,[R2, #+160]
    712          
    713            return HAL_OK;
   \   0000004A   0x2000             MOVS     R0,#+0
   \                     ??HAL_LTDC_DisableCLUT_1: (+1)
   \   0000004C   0xBC10             POP      {R4}
   \   0000004E   0x4770             BX       LR               ;; return
    714          }
    715          
    716          /**
    717            * @brief  Enables Dither.
    718            * @param  hltdc: pointer to a LTDC_HandleTypeDef structure that contains
    719            *                the configuration information for the LTDC.
    720            * @retval  HAL status
    721            */
    722          

   \                                 In section .text, align 2, keep-with-next
    723          HAL_StatusTypeDef HAL_LTDC_EnableDither(LTDC_HandleTypeDef *hltdc)
    724          {
   \                     HAL_LTDC_EnableDither: (+1)
   \   00000000   0x0001             MOVS     R1,R0
    725            /* Process locked */
    726            __HAL_LOCK(hltdc);
   \   00000002   0xF891 0x00A0      LDRB     R0,[R1, #+160]
   \   00000006   0x2801             CMP      R0,#+1
   \   00000008   0xD101             BNE.N    ??HAL_LTDC_EnableDither_0
   \   0000000A   0x2002             MOVS     R0,#+2
   \   0000000C   0xE014             B.N      ??HAL_LTDC_EnableDither_1
   \                     ??HAL_LTDC_EnableDither_0: (+1)
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0xF881 0x00A0      STRB     R0,[R1, #+160]
    727          
    728            /* Change LTDC peripheral state */
    729            hltdc->State = HAL_LTDC_STATE_BUSY;
   \   00000014   0x2002             MOVS     R0,#+2
   \   00000016   0xF881 0x00A1      STRB     R0,[R1, #+161]
    730          
    731            /* Enable Dither by setting DTEN bit */
    732            LTDC->GCR |= (uint32_t)LTDC_GCR_DTEN;
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable4_1  ;; 0x40016818
   \   0000001E   0x6800             LDR      R0,[R0, #+0]
   \   00000020   0xF450 0x3080      ORRS     R0,R0,#0x10000
   \   00000024   0x.... 0x....      LDR.W    R2,??DataTable4_1  ;; 0x40016818
   \   00000028   0x6010             STR      R0,[R2, #+0]
    733          
    734            /* Change the LTDC state*/
    735            hltdc->State = HAL_LTDC_STATE_READY; 
   \   0000002A   0x2001             MOVS     R0,#+1
   \   0000002C   0xF881 0x00A1      STRB     R0,[R1, #+161]
    736          
    737            /* Process unlocked */
    738            __HAL_UNLOCK(hltdc);
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0xF881 0x00A0      STRB     R0,[R1, #+160]
    739          
    740            return HAL_OK;
   \   00000036   0x2000             MOVS     R0,#+0
   \                     ??HAL_LTDC_EnableDither_1: (+1)
   \   00000038   0x4770             BX       LR               ;; return
    741          }
    742          
    743          /**
    744            * @brief  Disables Dither.
    745            * @param  hltdc: pointer to a LTDC_HandleTypeDef structure that contains
    746            *                the configuration information for the LTDC.
    747            * @retval  HAL status
    748            */
    749          

   \                                 In section .text, align 2, keep-with-next
    750          HAL_StatusTypeDef HAL_LTDC_DisableDither(LTDC_HandleTypeDef *hltdc)
    751          {
   \                     HAL_LTDC_DisableDither: (+1)
   \   00000000   0x0001             MOVS     R1,R0
    752            /* Process locked */
    753            __HAL_LOCK(hltdc);
   \   00000002   0xF891 0x00A0      LDRB     R0,[R1, #+160]
   \   00000006   0x2801             CMP      R0,#+1
   \   00000008   0xD101             BNE.N    ??HAL_LTDC_DisableDither_0
   \   0000000A   0x2002             MOVS     R0,#+2
   \   0000000C   0xE014             B.N      ??HAL_LTDC_DisableDither_1
   \                     ??HAL_LTDC_DisableDither_0: (+1)
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0xF881 0x00A0      STRB     R0,[R1, #+160]
    754          
    755            /* Change LTDC peripheral state */
    756            hltdc->State = HAL_LTDC_STATE_BUSY;
   \   00000014   0x2002             MOVS     R0,#+2
   \   00000016   0xF881 0x00A1      STRB     R0,[R1, #+161]
    757          
    758            /* Disable Dither by setting DTEN bit */
    759            LTDC->GCR &= ~(uint32_t)LTDC_GCR_DTEN;
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable4_1  ;; 0x40016818
   \   0000001E   0x6800             LDR      R0,[R0, #+0]
   \   00000020   0xF430 0x3080      BICS     R0,R0,#0x10000
   \   00000024   0x.... 0x....      LDR.W    R2,??DataTable4_1  ;; 0x40016818
   \   00000028   0x6010             STR      R0,[R2, #+0]
    760          
    761            /* Change the LTDC state*/
    762            hltdc->State = HAL_LTDC_STATE_READY;
   \   0000002A   0x2001             MOVS     R0,#+1
   \   0000002C   0xF881 0x00A1      STRB     R0,[R1, #+161]
    763          
    764            /* Process unlocked */
    765            __HAL_UNLOCK(hltdc);
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0xF881 0x00A0      STRB     R0,[R1, #+160]
    766          
    767            return HAL_OK;
   \   00000036   0x2000             MOVS     R0,#+0
   \                     ??HAL_LTDC_DisableDither_1: (+1)
   \   00000038   0x4770             BX       LR               ;; return
    768          }
    769          
    770          /**
    771            * @brief  Set the LTDC window size.
    772            * @param  hltdc:    pointer to a LTDC_HandleTypeDef structure that contains
    773            *                   the configuration information for the LTDC.
    774            * @param  XSize:    LTDC Pixel per line
    775            * @param  YSize:    LTDC Line number
    776            * @param  LayerIdx:  LTDC Layer index.
    777            *                   This parameter can be one of the following values:
    778            *                   0 or 1
    779            * @retval  HAL status
    780            */

   \                                 In section .text, align 2, keep-with-next
    781          HAL_StatusTypeDef HAL_LTDC_SetWindowSize(LTDC_HandleTypeDef *hltdc, uint32_t XSize, uint32_t YSize, uint32_t LayerIdx) 
    782          {
   \                     HAL_LTDC_SetWindowSize: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
    783            LTDC_LayerCfgTypeDef *pLayerCfg;
    784          
    785            /* Process locked */
    786            __HAL_LOCK(hltdc);
   \   0000000C   0xF894 0x00A0      LDRB     R0,[R4, #+160]
   \   00000010   0x2801             CMP      R0,#+1
   \   00000012   0xD101             BNE.N    ??HAL_LTDC_SetWindowSize_0
   \   00000014   0x2002             MOVS     R0,#+2
   \   00000016   0xE02D             B.N      ??HAL_LTDC_SetWindowSize_1
   \                     ??HAL_LTDC_SetWindowSize_0: (+1)
   \   00000018   0x2001             MOVS     R0,#+1
   \   0000001A   0xF884 0x00A0      STRB     R0,[R4, #+160]
    787          
    788            /* Change LTDC peripheral state */
    789            hltdc->State = HAL_LTDC_STATE_BUSY; 
   \   0000001E   0x2002             MOVS     R0,#+2
   \   00000020   0xF884 0x00A1      STRB     R0,[R4, #+161]
    790          
    791            /* Get layer configuration from handle structure */
    792            pLayerCfg = &hltdc->LayerCfg[LayerIdx];
   \   00000024   0x2034             MOVS     R0,#+52
   \   00000026   0xFB00 0x4007      MLA      R0,R0,R7,R4
   \   0000002A   0x3038             ADDS     R0,R0,#+56
   \   0000002C   0x4680             MOV      R8,R0
    793          
    794            /* Check the parameters (Layers parameters)*/
    795            assert_param(IS_LTDC_LAYER(LayerIdx));
    796            assert_param(IS_LTDC_HCONFIGST(pLayerCfg->WindowX0));
    797            assert_param(IS_LTDC_HCONFIGSP(pLayerCfg->WindowX1));
    798            assert_param(IS_LTDC_VCONFIGST(pLayerCfg->WindowY0));
    799            assert_param(IS_LTDC_VCONFIGSP(pLayerCfg->WindowY1));
    800            assert_param(IS_LTDC_CFBLL(XSize));
    801            assert_param(IS_LTDC_CFBLNBR(YSize));
    802          
    803            /* update horizontal start/stop */
    804            pLayerCfg->WindowX0 = 0;
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0xF8C8 0x0000      STR      R0,[R8, #+0]
    805            pLayerCfg->WindowX1 = XSize + pLayerCfg->WindowX0;
   \   00000034   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \   00000038   0x1940             ADDS     R0,R0,R5
   \   0000003A   0xF8C8 0x0004      STR      R0,[R8, #+4]
    806          
    807            /* update vertical start/stop */  
    808            pLayerCfg->WindowY0 = 0;
   \   0000003E   0x2000             MOVS     R0,#+0
   \   00000040   0xF8C8 0x0008      STR      R0,[R8, #+8]
    809            pLayerCfg->WindowY1 = YSize + pLayerCfg->WindowY0;
   \   00000044   0xF8D8 0x0008      LDR      R0,[R8, #+8]
   \   00000048   0x1980             ADDS     R0,R0,R6
   \   0000004A   0xF8C8 0x000C      STR      R0,[R8, #+12]
    810          
    811            /* Reconfigures the color frame buffer pitch in byte */
    812            pLayerCfg->ImageWidth = XSize;
   \   0000004E   0xF8C8 0x5028      STR      R5,[R8, #+40]
    813          
    814            /* Reconfigures the frame buffer line number */
    815            pLayerCfg->ImageHeight = YSize;
   \   00000052   0xF8C8 0x602C      STR      R6,[R8, #+44]
    816          
    817            /* Set LTDC parameters */
    818            LTDC_SetConfig(hltdc, pLayerCfg, LayerIdx);
   \   00000056   0x003A             MOVS     R2,R7
   \   00000058   0x4641             MOV      R1,R8
   \   0000005A   0x0020             MOVS     R0,R4
   \   0000005C   0x.... 0x....      BL       LTDC_SetConfig
    819          
    820            /* Sets the Reload type */
    821            hltdc->Instance->SRCR = LTDC_SRCR_IMR;
   \   00000060   0x2001             MOVS     R0,#+1
   \   00000062   0x6821             LDR      R1,[R4, #+0]
   \   00000064   0x6248             STR      R0,[R1, #+36]
    822          
    823            /* Change the LTDC state*/
    824            hltdc->State = HAL_LTDC_STATE_READY;
   \   00000066   0x2001             MOVS     R0,#+1
   \   00000068   0xF884 0x00A1      STRB     R0,[R4, #+161]
    825          
    826            /* Process unlocked */
    827            __HAL_UNLOCK(hltdc);
   \   0000006C   0x2000             MOVS     R0,#+0
   \   0000006E   0xF884 0x00A0      STRB     R0,[R4, #+160]
    828          
    829            return HAL_OK;
   \   00000072   0x2000             MOVS     R0,#+0
   \                     ??HAL_LTDC_SetWindowSize_1: (+1)
   \   00000074   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    830          }
    831          
    832          /**
    833            * @brief  Set the LTDC window position.
    834            * @param  hltdc:    pointer to a LTDC_HandleTypeDef structure that contains
    835            *                   the configuration information for the LTDC.
    836            * @param  X0:       LTDC window X offset
    837            * @param  Y0:       LTDC window Y offset
    838            * @param  LayerIdx:  LTDC Layer index.
    839            *                         This parameter can be one of the following values:
    840            *                         0 or 1
    841            * @retval  HAL status
    842            */

   \                                 In section .text, align 2, keep-with-next
    843          HAL_StatusTypeDef HAL_LTDC_SetWindowPosition(LTDC_HandleTypeDef *hltdc, uint32_t X0, uint32_t Y0, uint32_t LayerIdx)
    844          {
   \                     HAL_LTDC_SetWindowPosition: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
    845            LTDC_LayerCfgTypeDef *pLayerCfg;
    846            
    847            /* Process locked */
    848            __HAL_LOCK(hltdc);
   \   0000000C   0xF894 0x00A0      LDRB     R0,[R4, #+160]
   \   00000010   0x2801             CMP      R0,#+1
   \   00000012   0xD101             BNE.N    ??HAL_LTDC_SetWindowPosition_0
   \   00000014   0x2002             MOVS     R0,#+2
   \   00000016   0xE027             B.N      ??HAL_LTDC_SetWindowPosition_1
   \                     ??HAL_LTDC_SetWindowPosition_0: (+1)
   \   00000018   0x2001             MOVS     R0,#+1
   \   0000001A   0xF884 0x00A0      STRB     R0,[R4, #+160]
    849          
    850            /* Change LTDC peripheral state */
    851            hltdc->State = HAL_LTDC_STATE_BUSY;
   \   0000001E   0x2002             MOVS     R0,#+2
   \   00000020   0xF884 0x00A1      STRB     R0,[R4, #+161]
    852          
    853            /* Get layer configuration from handle structure */
    854            pLayerCfg = &hltdc->LayerCfg[LayerIdx];
   \   00000024   0x2034             MOVS     R0,#+52
   \   00000026   0xFB00 0x4007      MLA      R0,R0,R7,R4
   \   0000002A   0x3038             ADDS     R0,R0,#+56
   \   0000002C   0x4680             MOV      R8,R0
    855          
    856            /* Check the parameters */
    857            assert_param(IS_LTDC_LAYER(LayerIdx));
    858            assert_param(IS_LTDC_HCONFIGST(pLayerCfg->WindowX0));
    859            assert_param(IS_LTDC_HCONFIGSP(pLayerCfg->WindowX1));
    860            assert_param(IS_LTDC_VCONFIGST(pLayerCfg->WindowY0));
    861            assert_param(IS_LTDC_VCONFIGSP(pLayerCfg->WindowY1));
    862          
    863            /* update horizontal start/stop */
    864            pLayerCfg->WindowX0 = X0;
   \   0000002E   0xF8C8 0x5000      STR      R5,[R8, #+0]
    865            pLayerCfg->WindowX1 = X0 + pLayerCfg->ImageWidth;
   \   00000032   0xF8D8 0x0028      LDR      R0,[R8, #+40]
   \   00000036   0x1940             ADDS     R0,R0,R5
   \   00000038   0xF8C8 0x0004      STR      R0,[R8, #+4]
    866          
    867            /* update vertical start/stop */
    868            pLayerCfg->WindowY0 = Y0;
   \   0000003C   0xF8C8 0x6008      STR      R6,[R8, #+8]
    869            pLayerCfg->WindowY1 = Y0 + pLayerCfg->ImageHeight;
   \   00000040   0xF8D8 0x002C      LDR      R0,[R8, #+44]
   \   00000044   0x1980             ADDS     R0,R0,R6
   \   00000046   0xF8C8 0x000C      STR      R0,[R8, #+12]
    870          
    871            /* Set LTDC parameters */
    872            LTDC_SetConfig(hltdc, pLayerCfg, LayerIdx);
   \   0000004A   0x003A             MOVS     R2,R7
   \   0000004C   0x4641             MOV      R1,R8
   \   0000004E   0x0020             MOVS     R0,R4
   \   00000050   0x.... 0x....      BL       LTDC_SetConfig
    873          
    874            /* Sets the Reload type */
    875            hltdc->Instance->SRCR = LTDC_SRCR_IMR;
   \   00000054   0x2001             MOVS     R0,#+1
   \   00000056   0x6821             LDR      R1,[R4, #+0]
   \   00000058   0x6248             STR      R0,[R1, #+36]
    876          
    877            /* Change the LTDC state*/
    878            hltdc->State = HAL_LTDC_STATE_READY;
   \   0000005A   0x2001             MOVS     R0,#+1
   \   0000005C   0xF884 0x00A1      STRB     R0,[R4, #+161]
    879          
    880            /* Process unlocked */
    881            __HAL_UNLOCK(hltdc);
   \   00000060   0x2000             MOVS     R0,#+0
   \   00000062   0xF884 0x00A0      STRB     R0,[R4, #+160]
    882          
    883            return HAL_OK;
   \   00000066   0x2000             MOVS     R0,#+0
   \                     ??HAL_LTDC_SetWindowPosition_1: (+1)
   \   00000068   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    884          }
    885          
    886          /**
    887            * @brief  Reconfigure the pixel format.
    888            * @param  hltdc:       pointer to a LTDC_HandleTypeDef structure that contains
    889            *                      the configuration information for the LTDC.
    890            * @param  Pixelformat: new pixel format value.
    891            * @param  LayerIdx:    LTDC Layer index.
    892            *                      This parameter can be one of the following values:
    893            *                      0 or 1.
    894            * @retval  HAL status
    895            */

   \                                 In section .text, align 2, keep-with-next
    896          HAL_StatusTypeDef HAL_LTDC_SetPixelFormat(LTDC_HandleTypeDef *hltdc, uint32_t Pixelformat, uint32_t LayerIdx)
    897          {
   \                     HAL_LTDC_SetPixelFormat: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    898            LTDC_LayerCfgTypeDef *pLayerCfg;
    899          
    900            /* Process locked */
    901            __HAL_LOCK(hltdc);
   \   00000008   0xF894 0x00A0      LDRB     R0,[R4, #+160]
   \   0000000C   0x2801             CMP      R0,#+1
   \   0000000E   0xD101             BNE.N    ??HAL_LTDC_SetPixelFormat_0
   \   00000010   0x2002             MOVS     R0,#+2
   \   00000012   0xE01A             B.N      ??HAL_LTDC_SetPixelFormat_1
   \                     ??HAL_LTDC_SetPixelFormat_0: (+1)
   \   00000014   0x2001             MOVS     R0,#+1
   \   00000016   0xF884 0x00A0      STRB     R0,[R4, #+160]
    902          
    903            /* Change LTDC peripheral state */
    904            hltdc->State = HAL_LTDC_STATE_BUSY;
   \   0000001A   0x2002             MOVS     R0,#+2
   \   0000001C   0xF884 0x00A1      STRB     R0,[R4, #+161]
    905          
    906            /* Check the parameters */
    907            assert_param(IS_LTDC_LAYER(LayerIdx));
    908            assert_param(IS_LTDC_PIXEL_FORMAT(Pixelformat));
    909          
    910            /* Get layer configuration from handle structure */
    911            pLayerCfg = &hltdc->LayerCfg[LayerIdx];  
   \   00000020   0x2034             MOVS     R0,#+52
   \   00000022   0xFB00 0x4006      MLA      R0,R0,R6,R4
   \   00000026   0x3038             ADDS     R0,R0,#+56
   \   00000028   0x0007             MOVS     R7,R0
    912          
    913            /* Reconfigure the pixel format */
    914            pLayerCfg->PixelFormat = Pixelformat;
   \   0000002A   0x613D             STR      R5,[R7, #+16]
    915          
    916            /* Set LTDC parameters */
    917            LTDC_SetConfig(hltdc, pLayerCfg, LayerIdx);   
   \   0000002C   0x0032             MOVS     R2,R6
   \   0000002E   0x0039             MOVS     R1,R7
   \   00000030   0x0020             MOVS     R0,R4
   \   00000032   0x.... 0x....      BL       LTDC_SetConfig
    918          
    919            /* Sets the Reload type */
    920            hltdc->Instance->SRCR = LTDC_SRCR_IMR;
   \   00000036   0x2001             MOVS     R0,#+1
   \   00000038   0x6821             LDR      R1,[R4, #+0]
   \   0000003A   0x6248             STR      R0,[R1, #+36]
    921          
    922            /* Change the LTDC state*/
    923            hltdc->State = HAL_LTDC_STATE_READY;
   \   0000003C   0x2001             MOVS     R0,#+1
   \   0000003E   0xF884 0x00A1      STRB     R0,[R4, #+161]
    924          
    925            /* Process unlocked */
    926            __HAL_UNLOCK(hltdc);
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0xF884 0x00A0      STRB     R0,[R4, #+160]
    927          
    928            return HAL_OK;
   \   00000048   0x2000             MOVS     R0,#+0
   \                     ??HAL_LTDC_SetPixelFormat_1: (+1)
   \   0000004A   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    929          }
    930          
    931          /**
    932            * @brief  Reconfigure the layer alpha value.
    933            * @param  hltdc:    pointer to a LTDC_HandleTypeDef structure that contains
    934            *                   the configuration information for the LTDC.
    935            * @param  Alpha:    new alpha value.
    936            * @param  LayerIdx:  LTDC Layer index.
    937            *                   This parameter can be one of the following values:
    938            *                   0 or 1
    939            * @retval  HAL status
    940            */

   \                                 In section .text, align 2, keep-with-next
    941          HAL_StatusTypeDef HAL_LTDC_SetAlpha(LTDC_HandleTypeDef *hltdc, uint32_t Alpha, uint32_t LayerIdx)
    942          {
   \                     HAL_LTDC_SetAlpha: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    943            LTDC_LayerCfgTypeDef *pLayerCfg;
    944          
    945            /* Process locked */
    946            __HAL_LOCK(hltdc);
   \   00000008   0xF894 0x00A0      LDRB     R0,[R4, #+160]
   \   0000000C   0x2801             CMP      R0,#+1
   \   0000000E   0xD101             BNE.N    ??HAL_LTDC_SetAlpha_0
   \   00000010   0x2002             MOVS     R0,#+2
   \   00000012   0xE01A             B.N      ??HAL_LTDC_SetAlpha_1
   \                     ??HAL_LTDC_SetAlpha_0: (+1)
   \   00000014   0x2001             MOVS     R0,#+1
   \   00000016   0xF884 0x00A0      STRB     R0,[R4, #+160]
    947          
    948            /* Change LTDC peripheral state */
    949            hltdc->State = HAL_LTDC_STATE_BUSY;
   \   0000001A   0x2002             MOVS     R0,#+2
   \   0000001C   0xF884 0x00A1      STRB     R0,[R4, #+161]
    950          
    951            /* Check the parameters */
    952            assert_param(IS_LTDC_ALPHA(Alpha));
    953            assert_param(IS_LTDC_LAYER(LayerIdx));
    954          
    955            /* Get layer configuration from handle structure */
    956            pLayerCfg = &hltdc->LayerCfg[LayerIdx];
   \   00000020   0x2034             MOVS     R0,#+52
   \   00000022   0xFB00 0x4006      MLA      R0,R0,R6,R4
   \   00000026   0x3038             ADDS     R0,R0,#+56
   \   00000028   0x0007             MOVS     R7,R0
    957          
    958            /* Reconfigure the Alpha value */
    959            pLayerCfg->Alpha = Alpha;
   \   0000002A   0x617D             STR      R5,[R7, #+20]
    960          
    961            /* Set LTDC parameters */
    962            LTDC_SetConfig(hltdc, pLayerCfg, LayerIdx);
   \   0000002C   0x0032             MOVS     R2,R6
   \   0000002E   0x0039             MOVS     R1,R7
   \   00000030   0x0020             MOVS     R0,R4
   \   00000032   0x.... 0x....      BL       LTDC_SetConfig
    963          
    964            /* Sets the Reload type */
    965            hltdc->Instance->SRCR = LTDC_SRCR_IMR;
   \   00000036   0x2001             MOVS     R0,#+1
   \   00000038   0x6821             LDR      R1,[R4, #+0]
   \   0000003A   0x6248             STR      R0,[R1, #+36]
    966          
    967            /* Change the LTDC state*/
    968            hltdc->State = HAL_LTDC_STATE_READY;
   \   0000003C   0x2001             MOVS     R0,#+1
   \   0000003E   0xF884 0x00A1      STRB     R0,[R4, #+161]
    969          
    970            /* Process unlocked */
    971            __HAL_UNLOCK(hltdc);
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0xF884 0x00A0      STRB     R0,[R4, #+160]
    972          
    973            return HAL_OK;
   \   00000048   0x2000             MOVS     R0,#+0
   \                     ??HAL_LTDC_SetAlpha_1: (+1)
   \   0000004A   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    974          }
    975          /**
    976            * @brief  Reconfigure the frame buffer Address.
    977            * @param  hltdc:    pointer to a LTDC_HandleTypeDef structure that contains
    978            *                   the configuration information for the LTDC.
    979            * @param  Address:  new address value.
    980            * @param  LayerIdx: LTDC Layer index.
    981            *                   This parameter can be one of the following values:
    982            *                   0 or 1.
    983            * @retval  HAL status
    984            */

   \                                 In section .text, align 2, keep-with-next
    985          HAL_StatusTypeDef HAL_LTDC_SetAddress(LTDC_HandleTypeDef *hltdc, uint32_t Address, uint32_t LayerIdx)
    986          {
   \                     HAL_LTDC_SetAddress: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    987            LTDC_LayerCfgTypeDef *pLayerCfg;
    988          
    989            /* Process locked */
    990            __HAL_LOCK(hltdc);
   \   00000008   0xF894 0x00A0      LDRB     R0,[R4, #+160]
   \   0000000C   0x2801             CMP      R0,#+1
   \   0000000E   0xD101             BNE.N    ??HAL_LTDC_SetAddress_0
   \   00000010   0x2002             MOVS     R0,#+2
   \   00000012   0xE01A             B.N      ??HAL_LTDC_SetAddress_1
   \                     ??HAL_LTDC_SetAddress_0: (+1)
   \   00000014   0x2001             MOVS     R0,#+1
   \   00000016   0xF884 0x00A0      STRB     R0,[R4, #+160]
    991          
    992            /* Change LTDC peripheral state */
    993            hltdc->State = HAL_LTDC_STATE_BUSY;
   \   0000001A   0x2002             MOVS     R0,#+2
   \   0000001C   0xF884 0x00A1      STRB     R0,[R4, #+161]
    994          
    995            /* Check the parameters */
    996            assert_param(IS_LTDC_LAYER(LayerIdx));
    997          
    998            /* Get layer configuration from handle structure */
    999            pLayerCfg = &hltdc->LayerCfg[LayerIdx];
   \   00000020   0x2034             MOVS     R0,#+52
   \   00000022   0xFB00 0x4006      MLA      R0,R0,R6,R4
   \   00000026   0x3038             ADDS     R0,R0,#+56
   \   00000028   0x0007             MOVS     R7,R0
   1000          
   1001            /* Reconfigure the Address */
   1002            pLayerCfg->FBStartAdress = Address;
   \   0000002A   0x627D             STR      R5,[R7, #+36]
   1003          
   1004            /* Set LTDC parameters */
   1005            LTDC_SetConfig(hltdc, pLayerCfg, LayerIdx);
   \   0000002C   0x0032             MOVS     R2,R6
   \   0000002E   0x0039             MOVS     R1,R7
   \   00000030   0x0020             MOVS     R0,R4
   \   00000032   0x.... 0x....      BL       LTDC_SetConfig
   1006          
   1007            /* Sets the Reload type */
   1008            hltdc->Instance->SRCR = LTDC_SRCR_IMR;
   \   00000036   0x2001             MOVS     R0,#+1
   \   00000038   0x6821             LDR      R1,[R4, #+0]
   \   0000003A   0x6248             STR      R0,[R1, #+36]
   1009          
   1010            /* Change the LTDC state*/
   1011            hltdc->State = HAL_LTDC_STATE_READY;
   \   0000003C   0x2001             MOVS     R0,#+1
   \   0000003E   0xF884 0x00A1      STRB     R0,[R4, #+161]
   1012          
   1013            /* Process unlocked */
   1014            __HAL_UNLOCK(hltdc);
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0xF884 0x00A0      STRB     R0,[R4, #+160]
   1015          
   1016            return HAL_OK;
   \   00000048   0x2000             MOVS     R0,#+0
   \                     ??HAL_LTDC_SetAddress_1: (+1)
   \   0000004A   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1017          }
   1018          
   1019          /**
   1020            * @brief  Define the position of the line interrupt .
   1021            * @param  hltdc:             pointer to a LTDC_HandleTypeDef structure that contains
   1022            *                            the configuration information for the LTDC.
   1023            * @param  Line:   Line Interrupt Position.
   1024            * @retval  HAL status
   1025            */

   \                                 In section .text, align 2, keep-with-next
   1026          HAL_StatusTypeDef HAL_LTDC_ProgramLineEvent(LTDC_HandleTypeDef *hltdc, uint32_t Line)
   1027          {
   \                     HAL_LTDC_ProgramLineEvent: (+1)
   \   00000000   0x0002             MOVS     R2,R0
   1028            /* Process locked */
   1029            __HAL_LOCK(hltdc);
   \   00000002   0xF892 0x00A0      LDRB     R0,[R2, #+160]
   \   00000006   0x2801             CMP      R0,#+1
   \   00000008   0xD101             BNE.N    ??HAL_LTDC_ProgramLineEvent_0
   \   0000000A   0x2002             MOVS     R0,#+2
   \   0000000C   0xE014             B.N      ??HAL_LTDC_ProgramLineEvent_1
   \                     ??HAL_LTDC_ProgramLineEvent_0: (+1)
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0xF882 0x00A0      STRB     R0,[R2, #+160]
   1030          
   1031            /* Change LTDC peripheral state */
   1032            hltdc->State = HAL_LTDC_STATE_BUSY;
   \   00000014   0x2002             MOVS     R0,#+2
   \   00000016   0xF882 0x00A1      STRB     R0,[R2, #+161]
   1033          
   1034            /* Check the parameters */
   1035            assert_param(IS_LTDC_LIPOS(Line));
   1036          
   1037            /* Enable the Line interrupt */
   1038            __HAL_LTDC_ENABLE_IT(hltdc, LTDC_IT_LI);
   \   0000001A   0x6810             LDR      R0,[R2, #+0]
   \   0000001C   0x6B40             LDR      R0,[R0, #+52]
   \   0000001E   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000022   0x6813             LDR      R3,[R2, #+0]
   \   00000024   0x6358             STR      R0,[R3, #+52]
   1039          
   1040            /* Sets the Line Interrupt position */
   1041            LTDC->LIPCR = (uint32_t)Line;
   \   00000026   0x....             LDR.N    R0,??DataTable4_2  ;; 0x40016840
   \   00000028   0x6001             STR      R1,[R0, #+0]
   1042          
   1043            /* Change the LTDC state*/
   1044            hltdc->State = HAL_LTDC_STATE_READY;
   \   0000002A   0x2001             MOVS     R0,#+1
   \   0000002C   0xF882 0x00A1      STRB     R0,[R2, #+161]
   1045          
   1046            /* Process unlocked */
   1047            __HAL_UNLOCK(hltdc);
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0xF882 0x00A0      STRB     R0,[R2, #+160]
   1048          
   1049            return HAL_OK;
   \   00000036   0x2000             MOVS     R0,#+0
   \                     ??HAL_LTDC_ProgramLineEvent_1: (+1)
   \   00000038   0x4770             BX       LR               ;; return
   1050          }
   1051          
   1052          /**
   1053            * @}
   1054            */
   1055          
   1056          /** @defgroup LTDC_Exported_Functions_Group4 Peripheral State and Errors functions
   1057           *  @brief    Peripheral State and Errors functions 
   1058           *
   1059          @verbatim   
   1060           ===============================================================================
   1061                            ##### Peripheral State and Errors functions #####
   1062           ===============================================================================  
   1063              [..]
   1064              This subsection provides functions allowing to
   1065                (+) Check the LTDC state.
   1066                (+) Get error code.  
   1067          
   1068          @endverbatim
   1069            * @{
   1070            */ 
   1071          
   1072          /**
   1073            * @brief  Return the LTDC state
   1074            * @param  hltdc: pointer to a LTDC_HandleTypeDef structure that contains
   1075            *                the configuration information for the LTDC.
   1076            * @retval HAL state
   1077            */

   \                                 In section .text, align 2, keep-with-next
   1078          HAL_LTDC_StateTypeDef HAL_LTDC_GetState(LTDC_HandleTypeDef *hltdc)
   1079          {
   1080            return hltdc->State;
   \                     HAL_LTDC_GetState: (+1)
   \   00000000   0xF890 0x00A1      LDRB     R0,[R0, #+161]
   \   00000004   0x4770             BX       LR               ;; return
   1081          }
   1082          
   1083          /**
   1084          * @brief  Return the LTDC error code
   1085          * @param  hltdc : pointer to a LTDC_HandleTypeDef structure that contains
   1086            *               the configuration information for the LTDC.
   1087          * @retval LTDC Error Code
   1088          */

   \                                 In section .text, align 2, keep-with-next
   1089          uint32_t HAL_LTDC_GetError(LTDC_HandleTypeDef *hltdc)
   1090          {
   1091            return hltdc->ErrorCode;
   \                     HAL_LTDC_GetError: (+1)
   \   00000000   0xF8D0 0x00A4      LDR      R0,[R0, #+164]
   \   00000004   0x4770             BX       LR               ;; return
   1092          }
   1093          
   1094          /**
   1095            * @}
   1096            */
   1097          
   1098          /**
   1099            * @brief  Configures the LTDC peripheral 
   1100            * @param  hltdc   :  Pointer to a LTDC_HandleTypeDef structure that contains
   1101            *                   the configuration information for the LTDC.
   1102            * @param  pLayerCfg: Pointer LTDC Layer Configuration structure
   1103            * @param  LayerIdx:  LTDC Layer index.
   1104            *                    This parameter can be one of the following values: 0 or 1
   1105            * @retval None
   1106            */

   \                                 In section .text, align 2, keep-with-next
   1107          static void LTDC_SetConfig(LTDC_HandleTypeDef *hltdc, LTDC_LayerCfgTypeDef *pLayerCfg, uint32_t LayerIdx)
   1108          {
   \                     LTDC_SetConfig: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   1109            uint32_t tmp = 0;
   \   00000002   0x2300             MOVS     R3,#+0
   1110            uint32_t tmp1 = 0;
   \   00000004   0x2400             MOVS     R4,#+0
   1111            uint32_t tmp2 = 0;
   \   00000006   0x2500             MOVS     R5,#+0
   1112          
   1113            /* Configures the horizontal start and stop position */
   1114            tmp = ((pLayerCfg->WindowX1 + ((hltdc->Instance->BPCR & LTDC_BPCR_AHBP) >> 16)) << 16);
   \   00000008   0x684E             LDR      R6,[R1, #+4]
   \   0000000A   0x6807             LDR      R7,[R0, #+0]
   \   0000000C   0x68FF             LDR      R7,[R7, #+12]
   \   0000000E   0xF3C7 0x470B      UBFX     R7,R7,#+16,#+12
   \   00000012   0x19BE             ADDS     R6,R7,R6
   \   00000014   0x0436             LSLS     R6,R6,#+16
   \   00000016   0x0033             MOVS     R3,R6
   1115            LTDC_LAYER(hltdc, LayerIdx)->WHPCR &= ~(LTDC_LxWHPCR_WHSTPOS | LTDC_LxWHPCR_WHSPPOS);
   \   00000018   0x6806             LDR      R6,[R0, #+0]
   \   0000001A   0x2780             MOVS     R7,#+128
   \   0000001C   0xFB07 0x6602      MLA      R6,R7,R2,R6
   \   00000020   0x3684             ADDS     R6,R6,#+132
   \   00000022   0x6807             LDR      R7,[R0, #+0]
   \   00000024   0xF05F 0x0C80      MOVS     R12,#+128
   \   00000028   0xFB0C 0x7702      MLA      R7,R12,R2,R7
   \   0000002C   0x3784             ADDS     R7,R7,#+132
   \   0000002E   0x687F             LDR      R7,[R7, #+4]
   \   00000030   0xF417 0x4770      ANDS     R7,R7,#0xF000
   \   00000034   0x6077             STR      R7,[R6, #+4]
   1116            LTDC_LAYER(hltdc, LayerIdx)->WHPCR = ((pLayerCfg->WindowX0 + ((hltdc->Instance->BPCR & LTDC_BPCR_AHBP) >> 16) + 1) | tmp);
   \   00000036   0x6806             LDR      R6,[R0, #+0]
   \   00000038   0x2780             MOVS     R7,#+128
   \   0000003A   0xFB07 0x6602      MLA      R6,R7,R2,R6
   \   0000003E   0x3684             ADDS     R6,R6,#+132
   \   00000040   0x680F             LDR      R7,[R1, #+0]
   \   00000042   0xF8D0 0xC000      LDR      R12,[R0, #+0]
   \   00000046   0xF8DC 0xC00C      LDR      R12,[R12, #+12]
   \   0000004A   0xF3CC 0x4C0B      UBFX     R12,R12,#+16,#+12
   \   0000004E   0xEB1C 0x0707      ADDS     R7,R12,R7
   \   00000052   0x1C7F             ADDS     R7,R7,#+1
   \   00000054   0x431F             ORRS     R7,R3,R7
   \   00000056   0x6077             STR      R7,[R6, #+4]
   1117          
   1118            /* Configures the vertical start and stop position */
   1119            tmp = ((pLayerCfg->WindowY1 + (hltdc->Instance->BPCR & LTDC_BPCR_AVBP)) << 16);
   \   00000058   0x68CE             LDR      R6,[R1, #+12]
   \   0000005A   0x6807             LDR      R7,[R0, #+0]
   \   0000005C   0x68FF             LDR      R7,[R7, #+12]
   \   0000005E   0x057F             LSLS     R7,R7,#+21       ;; ZeroExtS R7,R7,#+21,#+21
   \   00000060   0x0D7F             LSRS     R7,R7,#+21
   \   00000062   0x19BE             ADDS     R6,R7,R6
   \   00000064   0x0436             LSLS     R6,R6,#+16
   \   00000066   0x0033             MOVS     R3,R6
   1120            LTDC_LAYER(hltdc, LayerIdx)->WVPCR &= ~(LTDC_LxWVPCR_WVSTPOS | LTDC_LxWVPCR_WVSPPOS);
   \   00000068   0x6806             LDR      R6,[R0, #+0]
   \   0000006A   0x2780             MOVS     R7,#+128
   \   0000006C   0xFB07 0x6602      MLA      R6,R7,R2,R6
   \   00000070   0x3684             ADDS     R6,R6,#+132
   \   00000072   0x6807             LDR      R7,[R0, #+0]
   \   00000074   0xF05F 0x0C80      MOVS     R12,#+128
   \   00000078   0xFB0C 0x7702      MLA      R7,R12,R2,R7
   \   0000007C   0x3784             ADDS     R7,R7,#+132
   \   0000007E   0x68BF             LDR      R7,[R7, #+8]
   \   00000080   0xF417 0x4770      ANDS     R7,R7,#0xF000
   \   00000084   0x60B7             STR      R7,[R6, #+8]
   1121            LTDC_LAYER(hltdc, LayerIdx)->WVPCR  = ((pLayerCfg->WindowY0 + (hltdc->Instance->BPCR & LTDC_BPCR_AVBP) + 1) | tmp);  
   \   00000086   0x6806             LDR      R6,[R0, #+0]
   \   00000088   0x2780             MOVS     R7,#+128
   \   0000008A   0xFB07 0x6602      MLA      R6,R7,R2,R6
   \   0000008E   0x3684             ADDS     R6,R6,#+132
   \   00000090   0x688F             LDR      R7,[R1, #+8]
   \   00000092   0xF8D0 0xC000      LDR      R12,[R0, #+0]
   \   00000096   0xF8DC 0xC00C      LDR      R12,[R12, #+12]
   \   0000009A   0xEA5F 0x5C4C      LSLS     R12,R12,#+21     ;; ZeroExtS R12,R12,#+21,#+21
   \   0000009E   0xEA5F 0x5C5C      LSRS     R12,R12,#+21
   \   000000A2   0xEB1C 0x0707      ADDS     R7,R12,R7
   \   000000A6   0x1C7F             ADDS     R7,R7,#+1
   \   000000A8   0x431F             ORRS     R7,R3,R7
   \   000000AA   0x60B7             STR      R7,[R6, #+8]
   1122          
   1123            /* Specifies the pixel format */
   1124            LTDC_LAYER(hltdc, LayerIdx)->PFCR &= ~(LTDC_LxPFCR_PF);
   \   000000AC   0x6806             LDR      R6,[R0, #+0]
   \   000000AE   0x2780             MOVS     R7,#+128
   \   000000B0   0xFB07 0x6602      MLA      R6,R7,R2,R6
   \   000000B4   0x3684             ADDS     R6,R6,#+132
   \   000000B6   0x6807             LDR      R7,[R0, #+0]
   \   000000B8   0xF05F 0x0C80      MOVS     R12,#+128
   \   000000BC   0xFB0C 0x7702      MLA      R7,R12,R2,R7
   \   000000C0   0x3784             ADDS     R7,R7,#+132
   \   000000C2   0x693F             LDR      R7,[R7, #+16]
   \   000000C4   0x08FF             LSRS     R7,R7,#+3
   \   000000C6   0x00FF             LSLS     R7,R7,#+3
   \   000000C8   0x6137             STR      R7,[R6, #+16]
   1125            LTDC_LAYER(hltdc, LayerIdx)->PFCR = (pLayerCfg->PixelFormat);
   \   000000CA   0x6806             LDR      R6,[R0, #+0]
   \   000000CC   0x2780             MOVS     R7,#+128
   \   000000CE   0xFB07 0x6602      MLA      R6,R7,R2,R6
   \   000000D2   0x3684             ADDS     R6,R6,#+132
   \   000000D4   0x690F             LDR      R7,[R1, #+16]
   \   000000D6   0x6137             STR      R7,[R6, #+16]
   1126          
   1127            /* Configures the default color values */
   1128            tmp = ((uint32_t)(pLayerCfg->Backcolor.Green) << 8);
   \   000000D8   0xF891 0x6031      LDRB     R6,[R1, #+49]
   \   000000DC   0x0236             LSLS     R6,R6,#+8
   \   000000DE   0x0033             MOVS     R3,R6
   1129            tmp1 = ((uint32_t)(pLayerCfg->Backcolor.Red) << 16);
   \   000000E0   0xF891 0x6032      LDRB     R6,[R1, #+50]
   \   000000E4   0x0436             LSLS     R6,R6,#+16
   \   000000E6   0x0034             MOVS     R4,R6
   1130            tmp2 = (pLayerCfg->Alpha0 << 24);  
   \   000000E8   0x698E             LDR      R6,[R1, #+24]
   \   000000EA   0x0636             LSLS     R6,R6,#+24
   \   000000EC   0x0035             MOVS     R5,R6
   1131            LTDC_LAYER(hltdc, LayerIdx)->DCCR &= ~(LTDC_LxDCCR_DCBLUE | LTDC_LxDCCR_DCGREEN | LTDC_LxDCCR_DCRED | LTDC_LxDCCR_DCALPHA);
   \   000000EE   0x6806             LDR      R6,[R0, #+0]
   \   000000F0   0x2780             MOVS     R7,#+128
   \   000000F2   0xFB07 0x6602      MLA      R6,R7,R2,R6
   \   000000F6   0x3684             ADDS     R6,R6,#+132
   \   000000F8   0x69B6             LDR      R6,[R6, #+24]
   \   000000FA   0x6806             LDR      R6,[R0, #+0]
   \   000000FC   0x2780             MOVS     R7,#+128
   \   000000FE   0xFB07 0x6602      MLA      R6,R7,R2,R6
   \   00000102   0x3684             ADDS     R6,R6,#+132
   \   00000104   0x2700             MOVS     R7,#+0
   \   00000106   0x61B7             STR      R7,[R6, #+24]
   1132            LTDC_LAYER(hltdc, LayerIdx)->DCCR = (pLayerCfg->Backcolor.Blue | tmp | tmp1 | tmp2); 
   \   00000108   0x6806             LDR      R6,[R0, #+0]
   \   0000010A   0x2780             MOVS     R7,#+128
   \   0000010C   0xFB07 0x6602      MLA      R6,R7,R2,R6
   \   00000110   0x3684             ADDS     R6,R6,#+132
   \   00000112   0xF891 0x7030      LDRB     R7,[R1, #+48]
   \   00000116   0x431F             ORRS     R7,R3,R7
   \   00000118   0x4327             ORRS     R7,R4,R7
   \   0000011A   0x432F             ORRS     R7,R5,R7
   \   0000011C   0x61B7             STR      R7,[R6, #+24]
   1133          
   1134            /* Specifies the constant alpha value */
   1135            LTDC_LAYER(hltdc, LayerIdx)->CACR &= ~(LTDC_LxCACR_CONSTA);
   \   0000011E   0x6806             LDR      R6,[R0, #+0]
   \   00000120   0x2780             MOVS     R7,#+128
   \   00000122   0xFB07 0x6602      MLA      R6,R7,R2,R6
   \   00000126   0x3684             ADDS     R6,R6,#+132
   \   00000128   0x6807             LDR      R7,[R0, #+0]
   \   0000012A   0xF05F 0x0C80      MOVS     R12,#+128
   \   0000012E   0xFB0C 0x7702      MLA      R7,R12,R2,R7
   \   00000132   0x3784             ADDS     R7,R7,#+132
   \   00000134   0x697F             LDR      R7,[R7, #+20]
   \   00000136   0x0A3F             LSRS     R7,R7,#+8
   \   00000138   0x023F             LSLS     R7,R7,#+8
   \   0000013A   0x6177             STR      R7,[R6, #+20]
   1136            LTDC_LAYER(hltdc, LayerIdx)->CACR = (pLayerCfg->Alpha);
   \   0000013C   0x6806             LDR      R6,[R0, #+0]
   \   0000013E   0x2780             MOVS     R7,#+128
   \   00000140   0xFB07 0x6602      MLA      R6,R7,R2,R6
   \   00000144   0x3684             ADDS     R6,R6,#+132
   \   00000146   0x694F             LDR      R7,[R1, #+20]
   \   00000148   0x6177             STR      R7,[R6, #+20]
   1137          
   1138            /* Specifies the blending factors */
   1139            LTDC_LAYER(hltdc, LayerIdx)->BFCR &= ~(LTDC_LxBFCR_BF2 | LTDC_LxBFCR_BF1);
   \   0000014A   0x6806             LDR      R6,[R0, #+0]
   \   0000014C   0x2780             MOVS     R7,#+128
   \   0000014E   0xFB07 0x6602      MLA      R6,R7,R2,R6
   \   00000152   0x3684             ADDS     R6,R6,#+132
   \   00000154   0x6807             LDR      R7,[R0, #+0]
   \   00000156   0xF05F 0x0C80      MOVS     R12,#+128
   \   0000015A   0xFB0C 0x7702      MLA      R7,R12,R2,R7
   \   0000015E   0x3784             ADDS     R7,R7,#+132
   \   00000160   0x69FF             LDR      R7,[R7, #+28]
   \   00000162   0x.... 0x....      LDR.W    R12,??DataTable4_3  ;; 0xfffff8f8
   \   00000166   0xEA1C 0x0707      ANDS     R7,R12,R7
   \   0000016A   0x61F7             STR      R7,[R6, #+28]
   1140            LTDC_LAYER(hltdc, LayerIdx)->BFCR = (pLayerCfg->BlendingFactor1 | pLayerCfg->BlendingFactor2);
   \   0000016C   0x6806             LDR      R6,[R0, #+0]
   \   0000016E   0x2780             MOVS     R7,#+128
   \   00000170   0xFB07 0x6602      MLA      R6,R7,R2,R6
   \   00000174   0x3684             ADDS     R6,R6,#+132
   \   00000176   0x69CF             LDR      R7,[R1, #+28]
   \   00000178   0xF8D1 0xC020      LDR      R12,[R1, #+32]
   \   0000017C   0xEA5C 0x0707      ORRS     R7,R12,R7
   \   00000180   0x61F7             STR      R7,[R6, #+28]
   1141          
   1142            /* Configures the color frame buffer start address */
   1143            LTDC_LAYER(hltdc, LayerIdx)->CFBAR &= ~(LTDC_LxCFBAR_CFBADD);
   \   00000182   0x6806             LDR      R6,[R0, #+0]
   \   00000184   0x2780             MOVS     R7,#+128
   \   00000186   0xFB07 0x6602      MLA      R6,R7,R2,R6
   \   0000018A   0x3684             ADDS     R6,R6,#+132
   \   0000018C   0x6AB6             LDR      R6,[R6, #+40]
   \   0000018E   0x6806             LDR      R6,[R0, #+0]
   \   00000190   0x2780             MOVS     R7,#+128
   \   00000192   0xFB07 0x6602      MLA      R6,R7,R2,R6
   \   00000196   0x3684             ADDS     R6,R6,#+132
   \   00000198   0x2700             MOVS     R7,#+0
   \   0000019A   0x62B7             STR      R7,[R6, #+40]
   1144            LTDC_LAYER(hltdc, LayerIdx)->CFBAR = (pLayerCfg->FBStartAdress);
   \   0000019C   0x6806             LDR      R6,[R0, #+0]
   \   0000019E   0x2780             MOVS     R7,#+128
   \   000001A0   0xFB07 0x6602      MLA      R6,R7,R2,R6
   \   000001A4   0x3684             ADDS     R6,R6,#+132
   \   000001A6   0x6A4F             LDR      R7,[R1, #+36]
   \   000001A8   0x62B7             STR      R7,[R6, #+40]
   1145          
   1146            if(pLayerCfg->PixelFormat == LTDC_PIXEL_FORMAT_ARGB8888)
   \   000001AA   0x690E             LDR      R6,[R1, #+16]
   \   000001AC   0x2E00             CMP      R6,#+0
   \   000001AE   0xD102             BNE.N    ??LTDC_SetConfig_0
   1147            {
   1148              tmp = 4;
   \   000001B0   0x2604             MOVS     R6,#+4
   \   000001B2   0x0033             MOVS     R3,R6
   \   000001B4   0xE016             B.N      ??LTDC_SetConfig_1
   1149            }
   1150            else if (pLayerCfg->PixelFormat == LTDC_PIXEL_FORMAT_RGB888)
   \                     ??LTDC_SetConfig_0: (+1)
   \   000001B6   0x690E             LDR      R6,[R1, #+16]
   \   000001B8   0x2E01             CMP      R6,#+1
   \   000001BA   0xD102             BNE.N    ??LTDC_SetConfig_2
   1151            {
   1152              tmp = 3;
   \   000001BC   0x2603             MOVS     R6,#+3
   \   000001BE   0x0033             MOVS     R3,R6
   \   000001C0   0xE010             B.N      ??LTDC_SetConfig_1
   1153            }
   1154            else if((pLayerCfg->PixelFormat == LTDC_PIXEL_FORMAT_ARGB4444) || \
   1155              (pLayerCfg->PixelFormat == LTDC_PIXEL_FORMAT_RGB565)   || \
   1156                (pLayerCfg->PixelFormat == LTDC_PIXEL_FORMAT_ARGB1555) || \
   1157                  (pLayerCfg->PixelFormat == LTDC_PIXEL_FORMAT_AL88))
   \                     ??LTDC_SetConfig_2: (+1)
   \   000001C2   0x690E             LDR      R6,[R1, #+16]
   \   000001C4   0x2E04             CMP      R6,#+4
   \   000001C6   0xD008             BEQ.N    ??LTDC_SetConfig_3
   \   000001C8   0x690E             LDR      R6,[R1, #+16]
   \   000001CA   0x2E02             CMP      R6,#+2
   \   000001CC   0xD005             BEQ.N    ??LTDC_SetConfig_3
   \   000001CE   0x690E             LDR      R6,[R1, #+16]
   \   000001D0   0x2E03             CMP      R6,#+3
   \   000001D2   0xD002             BEQ.N    ??LTDC_SetConfig_3
   \   000001D4   0x690E             LDR      R6,[R1, #+16]
   \   000001D6   0x2E07             CMP      R6,#+7
   \   000001D8   0xD102             BNE.N    ??LTDC_SetConfig_4
   1158            {
   1159              tmp = 2;
   \                     ??LTDC_SetConfig_3: (+1)
   \   000001DA   0x2602             MOVS     R6,#+2
   \   000001DC   0x0033             MOVS     R3,R6
   \   000001DE   0xE001             B.N      ??LTDC_SetConfig_1
   1160            }
   1161            else
   1162            {
   1163              tmp = 1;
   \                     ??LTDC_SetConfig_4: (+1)
   \   000001E0   0x2601             MOVS     R6,#+1
   \   000001E2   0x0033             MOVS     R3,R6
   1164            }
   1165          
   1166            /* Configures the color frame buffer pitch in byte */
   1167            LTDC_LAYER(hltdc, LayerIdx)->CFBLR  &= ~(LTDC_LxCFBLR_CFBLL | LTDC_LxCFBLR_CFBP);
   \                     ??LTDC_SetConfig_1: (+1)
   \   000001E4   0x6806             LDR      R6,[R0, #+0]
   \   000001E6   0x2780             MOVS     R7,#+128
   \   000001E8   0xFB07 0x6602      MLA      R6,R7,R2,R6
   \   000001EC   0x3684             ADDS     R6,R6,#+132
   \   000001EE   0x6807             LDR      R7,[R0, #+0]
   \   000001F0   0xF05F 0x0C80      MOVS     R12,#+128
   \   000001F4   0xFB0C 0x7702      MLA      R7,R12,R2,R7
   \   000001F8   0x3784             ADDS     R7,R7,#+132
   \   000001FA   0x6AFF             LDR      R7,[R7, #+44]
   \   000001FC   0xF017 0x27E0      ANDS     R7,R7,#0xE000E000
   \   00000200   0x62F7             STR      R7,[R6, #+44]
   1168            LTDC_LAYER(hltdc, LayerIdx)->CFBLR  = (((pLayerCfg->ImageWidth * tmp) << 16) | (((pLayerCfg->WindowX1 - pLayerCfg->WindowX0) * tmp)  + 3));
   \   00000202   0x6806             LDR      R6,[R0, #+0]
   \   00000204   0x2780             MOVS     R7,#+128
   \   00000206   0xFB07 0x6602      MLA      R6,R7,R2,R6
   \   0000020A   0x3684             ADDS     R6,R6,#+132
   \   0000020C   0x6A8F             LDR      R7,[R1, #+40]
   \   0000020E   0x435F             MULS     R7,R3,R7
   \   00000210   0xF8D1 0xC004      LDR      R12,[R1, #+4]
   \   00000214   0xF8D1 0xE000      LDR      LR,[R1, #+0]
   \   00000218   0xEBBC 0x0C0E      SUBS     R12,R12,LR
   \   0000021C   0xFB03 0xFC0C      MUL      R12,R3,R12
   \   00000220   0xF11C 0x0C03      ADDS     R12,R12,#+3
   \   00000224   0xEA5C 0x4707      ORRS     R7,R12,R7, LSL #+16
   \   00000228   0x62F7             STR      R7,[R6, #+44]
   1169          
   1170            /* Configures the frame buffer line number */
   1171            LTDC_LAYER(hltdc, LayerIdx)->CFBLNR  &= ~(LTDC_LxCFBLNR_CFBLNBR);
   \   0000022A   0x6806             LDR      R6,[R0, #+0]
   \   0000022C   0x2780             MOVS     R7,#+128
   \   0000022E   0xFB07 0x6602      MLA      R6,R7,R2,R6
   \   00000232   0x3684             ADDS     R6,R6,#+132
   \   00000234   0x6807             LDR      R7,[R0, #+0]
   \   00000236   0xF05F 0x0C80      MOVS     R12,#+128
   \   0000023A   0xFB0C 0x7702      MLA      R7,R12,R2,R7
   \   0000023E   0x3784             ADDS     R7,R7,#+132
   \   00000240   0x6B3F             LDR      R7,[R7, #+48]
   \   00000242   0x0AFF             LSRS     R7,R7,#+11
   \   00000244   0x02FF             LSLS     R7,R7,#+11
   \   00000246   0x6337             STR      R7,[R6, #+48]
   1172            LTDC_LAYER(hltdc, LayerIdx)->CFBLNR  = (pLayerCfg->ImageHeight);
   \   00000248   0x6806             LDR      R6,[R0, #+0]
   \   0000024A   0x2780             MOVS     R7,#+128
   \   0000024C   0xFB07 0x6602      MLA      R6,R7,R2,R6
   \   00000250   0x3684             ADDS     R6,R6,#+132
   \   00000252   0x6ACF             LDR      R7,[R1, #+44]
   \   00000254   0x6337             STR      R7,[R6, #+48]
   1173          
   1174            /* Enable LTDC_Layer by setting LEN bit */  
   1175            LTDC_LAYER(hltdc, LayerIdx)->CR |= (uint32_t)LTDC_LxCR_LEN;
   \   00000256   0x6806             LDR      R6,[R0, #+0]
   \   00000258   0x2780             MOVS     R7,#+128
   \   0000025A   0xFB07 0x6602      MLA      R6,R7,R2,R6
   \   0000025E   0xF8D6 0x6084      LDR      R6,[R6, #+132]
   \   00000262   0xF056 0x0601      ORRS     R6,R6,#0x1
   \   00000266   0x6807             LDR      R7,[R0, #+0]
   \   00000268   0xF05F 0x0C80      MOVS     R12,#+128
   \   0000026C   0xFB0C 0x7702      MLA      R7,R12,R2,R7
   \   00000270   0xF8C7 0x6084      STR      R6,[R7, #+132]
   1176          }
   \   00000274   0xBDF0             POP      {R4-R7,PC}       ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4:
   \   00000000   0xF000F800         DC32     0xf000f800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_1:
   \   00000000   0x40016818         DC32     0x40016818

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_2:
   \   00000000   0x40016840         DC32     0x40016840

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_3:
   \   00000000   0xFFFFF8F8         DC32     0xfffff8f8
   1177          
   1178          /**
   1179            * @}
   1180            */
   1181          
   1182          #endif /* HAL_LTDC_MODULE_ENABLED */
   1183          
   1184          /**
   1185            * @}
   1186            */
   1187          #endif /* STM32F756xx || STM32F746xx */
   1188          
   1189          /**
   1190            * @}
   1191            */
   1192          
   1193          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   HAL_LTDC_ConfigCLUT
       8   HAL_LTDC_ConfigColorKeying
      16   HAL_LTDC_ConfigLayer
        16   -> LTDC_SetConfig
        16   -> __aeabi_memcpy4
       8   HAL_LTDC_DeInit
         8   -> HAL_LTDC_MspDeInit
       4   HAL_LTDC_DisableCLUT
       4   HAL_LTDC_DisableColorKeying
       0   HAL_LTDC_DisableDither
       4   HAL_LTDC_EnableCLUT
       4   HAL_LTDC_EnableColorKeying
       0   HAL_LTDC_EnableDither
       0   HAL_LTDC_ErrorCallback
       0   HAL_LTDC_GetError
       0   HAL_LTDC_GetState
       8   HAL_LTDC_IRQHandler
         8   -> HAL_LTDC_ErrorCallback
         8   -> HAL_LTDC_LineEventCallback
      16   HAL_LTDC_Init
        16   -> HAL_LTDC_MspInit
       0   HAL_LTDC_LineEventCallback
       0   HAL_LTDC_MspDeInit
       0   HAL_LTDC_MspInit
       0   HAL_LTDC_ProgramLineEvent
      24   HAL_LTDC_SetAddress
        24   -> LTDC_SetConfig
      24   HAL_LTDC_SetAlpha
        24   -> LTDC_SetConfig
      24   HAL_LTDC_SetPixelFormat
        24   -> LTDC_SetConfig
      24   HAL_LTDC_SetWindowPosition
        24   -> LTDC_SetConfig
      24   HAL_LTDC_SetWindowSize
        24   -> LTDC_SetConfig
      20   LTDC_SetConfig


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable4
       4  ??DataTable4_1
       4  ??DataTable4_2
       4  ??DataTable4_3
     174  HAL_LTDC_ConfigCLUT
      92  HAL_LTDC_ConfigColorKeying
      80  HAL_LTDC_ConfigLayer
      32  HAL_LTDC_DeInit
      80  HAL_LTDC_DisableCLUT
      80  HAL_LTDC_DisableColorKeying
      58  HAL_LTDC_DisableDither
      80  HAL_LTDC_EnableCLUT
      80  HAL_LTDC_EnableColorKeying
      58  HAL_LTDC_EnableDither
       2  HAL_LTDC_ErrorCallback
       6  HAL_LTDC_GetError
       6  HAL_LTDC_GetState
     186  HAL_LTDC_IRQHandler
     314  HAL_LTDC_Init
       2  HAL_LTDC_LineEventCallback
       2  HAL_LTDC_MspDeInit
       2  HAL_LTDC_MspInit
      58  HAL_LTDC_ProgramLineEvent
      76  HAL_LTDC_SetAddress
      76  HAL_LTDC_SetAlpha
      76  HAL_LTDC_SetPixelFormat
     108  HAL_LTDC_SetWindowPosition
     120  HAL_LTDC_SetWindowSize
     630  LTDC_SetConfig

 
 2 494 bytes in section .text
 
 2 494 bytes of CODE memory

Errors: none
Warnings: none
