###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.2.10312/W32 for ARM       08/Mar/2016  16:10:17
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_ltdc.c
#    Command line =  
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_ltdc.c
#        -D USE_HAL_DRIVER -D STM32F746xx -D USE_STM32746G_DISCO -D
#        USE_IOEXPANDER -D USE_USB_FS -lC
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
#        -lA
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
#        -o
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj
#        --no_unroll --debug --endian=little --cpu=Cortex-M7 -e --fpu=VFPv5_sp
#        --dlib_config "D:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Full.h" -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\CMSIS\Device\ST\STM32F7xx\Include\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\STM32F7xx_HAL_Driver\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\STM32746G-Discovery\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\Components\Common\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Log\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Fonts\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\CPU\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_Device_Library\Core\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Core\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Class\MSC\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\drivers\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_Audio\Addons\PDM\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_Device_Library\Class\AUDIO\Inc\
#        -Oh --use_c++_inline --require_prototypes -I "D:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.3\arm\CMSIS\Include\" -D
#        ARM_MATH_CM7 --relaxed_fp
#    List file    =  
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List\stm32f7xx_hal_ltdc.lst
#    Object file  =  
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj\stm32f7xx_hal_ltdc.o
#
###############################################################################

D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_ltdc.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f7xx_hal_ltdc.c
      4            * @author  MCD Application Team
      5            * @version V1.0.1
      6            * @date    25-June-2015
      7            * @brief   LTDC HAL module driver.
      8            *          This file provides firmware functions to manage the following 
      9            *          functionalities of the LTDC peripheral:
     10            *           + Initialization and de-initialization functions
     11            *           + IO operation functions
     12            *           + Peripheral Control functions  
     13            *           + Peripheral State and Errors functions
     14            *           
     15            @verbatim      
     16            ==============================================================================
     17                                  ##### How to use this driver #####
     18            ==============================================================================
     19              [..]
     20               (#) Program the required configuration through the following parameters:   
     21                   the LTDC timing, the horizontal and vertical polarity, 
     22                   the pixel clock polarity, Data Enable polarity and the LTDC background color value 
     23                   using HAL_LTDC_Init() function
     24          
     25               (#) Program the required configuration through the following parameters:   
     26                   the pixel format, the blending factors, input alpha value, the window size 
     27                   and the image size using HAL_LTDC_ConfigLayer() function for foreground
     28                   or/and background layer.     
     29            
     30               (#) Optionally, configure and enable the CLUT using HAL_LTDC_ConfigCLUT() and 
     31                   HAL_LTDC_EnableCLUT functions.
     32                 
     33               (#) Optionally, enable the Dither using HAL_LTDC_EnableDither().       
     34          
     35               (#) Optionally, configure and enable the Color keying using HAL_LTDC_ConfigColorKeying()
     36                   and HAL_LTDC_EnableColorKeying functions.
     37          
     38               (#) Optionally, configure LineInterrupt using HAL_LTDC_ProgramLineEvent()
     39                   function
     40          
     41               (#) If needed, reconfigure and change the pixel format value, the alpha value
     42                   value, the window size, the window position and the layer start address 
     43                   for foreground or/and background layer using respectively the following 
     44                   functions: HAL_LTDC_SetPixelFormat(), HAL_LTDC_SetAlpha(), HAL_LTDC_SetWindowSize(),
     45                   HAL_LTDC_SetWindowPosition(), HAL_LTDC_SetAddress.
     46                               
     47               (#) To control LTDC state you can use the following function: HAL_LTDC_GetState()               
     48          
     49               *** LTDC HAL driver macros list ***
     50               ============================================= 
     51               [..]
     52                 Below the list of most used macros in LTDC HAL driver.
     53                 
     54                (+) __HAL_LTDC_ENABLE: Enable the LTDC.
     55                (+) __HAL_LTDC_DISABLE: Disable the LTDC.
     56                (+) __HAL_LTDC_LAYER_ENABLE: Enable the LTDC Layer.
     57                (+) __HAL_LTDC_LAYER_DISABLE: Disable the LTDC Layer.
     58                (+) __HAL_LTDC_RELOAD_CONFIG: Reload  Layer Configuration.
     59                (+) __HAL_LTDC_GET_FLAG: Get the LTDC pending flags.
     60                (+) __HAL_LTDC_CLEAR_FLAG: Clear the LTDC pending flags.
     61                (+) __HAL_LTDC_ENABLE_IT: Enable the specified LTDC interrupts. 
     62                (+) __HAL_LTDC_DISABLE_IT: Disable the specified LTDC interrupts.
     63                (+) __HAL_LTDC_GET_IT_SOURCE: Check whether the specified LTDC interrupt has occurred or not.
     64                
     65               [..] 
     66                 (@) You can refer to the LTDC HAL driver header file for more useful macros
     67            
     68            @endverbatim
     69            ******************************************************************************
     70            * @attention
     71            *
     72            * <h2><center>&copy; COPYRIGHT(c) 2015 STMicroelectronics</center></h2>
     73            *
     74            * Redistribution and use in source and binary forms, with or without modification,
     75            * are permitted provided that the following conditions are met:
     76            *   1. Redistributions of source code must retain the above copyright notice,
     77            *      this list of conditions and the following disclaimer.
     78            *   2. Redistributions in binary form must reproduce the above copyright notice,
     79            *      this list of conditions and the following disclaimer in the documentation
     80            *      and/or other materials provided with the distribution.
     81            *   3. Neither the name of STMicroelectronics nor the names of its contributors
     82            *      may be used to endorse or promote products derived from this software
     83            *      without specific prior written permission.
     84            *
     85            * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
     86            * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     87            * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     88            * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
     89            * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
     90            * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
     91            * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
     92            * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
     93            * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
     94            * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     95            *
     96            ******************************************************************************
     97            */ 
     98          
     99          /* Includes ------------------------------------------------------------------*/
    100          #include "stm32f7xx_hal.h"
    101          
    102          /** @addtogroup STM32F7xx_HAL_Driver
    103            * @{
    104            */
    105          #if defined(STM32F756xx) || defined(STM32F746xx)
    106          
    107          /** @defgroup LTDC LTDC
    108            * @brief LTDC HAL module driver
    109            * @{
    110            */
    111          
    112          #ifdef HAL_LTDC_MODULE_ENABLED
    113          
    114          /* Private typedef -----------------------------------------------------------*/
    115          /* Private define ------------------------------------------------------------*/
    116          /* Private macro -------------------------------------------------------------*/
    117          /* Private variables ---------------------------------------------------------*/    
    118          /* Private function prototypes -----------------------------------------------*/
    119          static void LTDC_SetConfig(LTDC_HandleTypeDef *hltdc, LTDC_LayerCfgTypeDef *pLayerCfg, uint32_t LayerIdx);
    120          /* Private functions ---------------------------------------------------------*/
    121          
    122          /** @defgroup LTDC_Exported_Functions LTDC Exported Functions
    123            * @{
    124            */
    125          
    126          /** @defgroup LTDC_Exported_Functions_Group1 Initialization and Configuration functions
    127           *  @brief   Initialization and Configuration functions
    128           *
    129          @verbatim   
    130           ===============================================================================
    131                          ##### Initialization and Configuration functions #####
    132           ===============================================================================  
    133              [..]  This section provides functions allowing to:
    134                (+) Initialize and configure the LTDC
    135                (+) De-initialize the LTDC 
    136          
    137          @endverbatim
    138            * @{
    139            */
    140            
    141          /**
    142            * @brief  Initializes the LTDC according to the specified
    143            *         parameters in the LTDC_InitTypeDef and create the associated handle.
    144            * @param  hltdc: pointer to a LTDC_HandleTypeDef structure that contains
    145            *                the configuration information for the LTDC.
    146            * @retval HAL status
    147            */

   \                                 In section .text, align 2, keep-with-next
    148          HAL_StatusTypeDef HAL_LTDC_Init(LTDC_HandleTypeDef *hltdc)
    149          {
   \                     HAL_LTDC_Init: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
    150            uint32_t tmp = 0, tmp1 = 0;
    151          
    152            /* Check the LTDC peripheral state */
    153            if(hltdc == NULL)
   \   00000004   0xD101             BNE.N    ??HAL_LTDC_Init_0
    154            {
    155              return HAL_ERROR;
   \   00000006   0x2001             MOVS     R0,#+1
   \   00000008   0xBD70             POP      {R4-R6,PC}
    156            }
    157          
    158            /* Check function parameters */
    159            assert_param(IS_LTDC_ALL_INSTANCE(hltdc->Instance));
    160            assert_param(IS_LTDC_HSYNC(hltdc->Init.HorizontalSync));
    161            assert_param(IS_LTDC_VSYNC(hltdc->Init.VerticalSync));
    162            assert_param(IS_LTDC_AHBP(hltdc->Init.AccumulatedHBP));
    163            assert_param(IS_LTDC_AVBP(hltdc->Init.AccumulatedVBP));
    164            assert_param(IS_LTDC_AAH(hltdc->Init.AccumulatedActiveH));
    165            assert_param(IS_LTDC_AAW(hltdc->Init.AccumulatedActiveW));
    166            assert_param(IS_LTDC_TOTALH(hltdc->Init.TotalHeigh));
    167            assert_param(IS_LTDC_TOTALW(hltdc->Init.TotalWidth));
    168            assert_param(IS_LTDC_HSPOL(hltdc->Init.HSPolarity));
    169            assert_param(IS_LTDC_VSPOL(hltdc->Init.VSPolarity));
    170            assert_param(IS_LTDC_DEPOL(hltdc->Init.DEPolarity));
    171            assert_param(IS_LTDC_PCPOL(hltdc->Init.PCPolarity));
    172          
    173            if(hltdc->State == HAL_LTDC_STATE_RESET)
   \                     ??HAL_LTDC_Init_0: (+1)
   \   0000000A   0xF104 0x05A0      ADD      R5,R4,#+160
   \   0000000E   0x7868             LDRB     R0,[R5, #+1]
   \   00000010   0xB918             CBNZ.N   R0,??HAL_LTDC_Init_1
    174            {
    175              /* Allocate lock resource and initialize it */
    176              hltdc->Lock = HAL_UNLOCKED;
   \   00000012   0x7028             STRB     R0,[R5, #+0]
    177              /* Init the low level hardware */
    178              HAL_LTDC_MspInit(hltdc);
   \   00000014   0x4620             MOV      R0,R4
   \   00000016   0x.... 0x....      BL       HAL_LTDC_MspInit
    179            }
    180            
    181            /* Change LTDC peripheral state */
    182            hltdc->State = HAL_LTDC_STATE_BUSY;
   \                     ??HAL_LTDC_Init_1: (+1)
   \   0000001A   0x2002             MOVS     R0,#+2
   \   0000001C   0x7068             STRB     R0,[R5, #+1]
    183          
    184            /* Configures the HS, VS, DE and PC polarity */
    185            hltdc->Instance->GCR &= ~(LTDC_GCR_HSPOL | LTDC_GCR_VSPOL | LTDC_GCR_DEPOL | LTDC_GCR_PCPOL);
   \   0000001E   0x6820             LDR      R0,[R4, #+0]
   \   00000020   0x6981             LDR      R1,[R0, #+24]
   \   00000022   0x0109             LSLS     R1,R1,#+4
   \   00000024   0x0909             LSRS     R1,R1,#+4
   \   00000026   0x6181             STR      R1,[R0, #+24]
    186            hltdc->Instance->GCR |=  (uint32_t)(hltdc->Init.HSPolarity | hltdc->Init.VSPolarity | \
    187            hltdc->Init.DEPolarity | hltdc->Init.PCPolarity);
   \   00000028   0x6820             LDR      R0,[R4, #+0]
   \   0000002A   0x6981             LDR      R1,[R0, #+24]
   \   0000002C   0x6862             LDR      R2,[R4, #+4]
   \   0000002E   0x68A3             LDR      R3,[R4, #+8]
   \   00000030   0x431A             ORRS     R2,R3,R2
   \   00000032   0x68E3             LDR      R3,[R4, #+12]
   \   00000034   0x431A             ORRS     R2,R3,R2
   \   00000036   0x6923             LDR      R3,[R4, #+16]
   \   00000038   0x431A             ORRS     R2,R3,R2
   \   0000003A   0x4311             ORRS     R1,R2,R1
   \   0000003C   0x6181             STR      R1,[R0, #+24]
    188          
    189            /* Sets Synchronization size */
    190            hltdc->Instance->SSCR &= ~(LTDC_SSCR_VSH | LTDC_SSCR_HSW);
   \   0000003E   0x6821             LDR      R1,[R4, #+0]
   \   00000040   0x.... 0x....      LDR.W    R0,??DataTable3  ;; 0xf000f800
   \   00000044   0x688A             LDR      R2,[R1, #+8]
   \   00000046   0x4002             ANDS     R2,R0,R2
   \   00000048   0x608A             STR      R2,[R1, #+8]
    191            tmp = (hltdc->Init.HorizontalSync << 16);
    192            hltdc->Instance->SSCR |= (tmp | hltdc->Init.VerticalSync);
   \   0000004A   0x6821             LDR      R1,[R4, #+0]
   \   0000004C   0x688A             LDR      R2,[R1, #+8]
   \   0000004E   0x6963             LDR      R3,[R4, #+20]
   \   00000050   0x69A6             LDR      R6,[R4, #+24]
   \   00000052   0xEA46 0x4303      ORR      R3,R6,R3, LSL #+16
   \   00000056   0x431A             ORRS     R2,R3,R2
   \   00000058   0x608A             STR      R2,[R1, #+8]
    193          
    194            /* Sets Accumulated Back porch */
    195            hltdc->Instance->BPCR &= ~(LTDC_BPCR_AVBP | LTDC_BPCR_AHBP);
   \   0000005A   0x6821             LDR      R1,[R4, #+0]
   \   0000005C   0x68CA             LDR      R2,[R1, #+12]
   \   0000005E   0x4002             ANDS     R2,R0,R2
   \   00000060   0x60CA             STR      R2,[R1, #+12]
    196            tmp = (hltdc->Init.AccumulatedHBP << 16);
    197            hltdc->Instance->BPCR |= (tmp | hltdc->Init.AccumulatedVBP);
   \   00000062   0x6821             LDR      R1,[R4, #+0]
   \   00000064   0x68CA             LDR      R2,[R1, #+12]
   \   00000066   0x69E3             LDR      R3,[R4, #+28]
   \   00000068   0x6A26             LDR      R6,[R4, #+32]
   \   0000006A   0xEA46 0x4303      ORR      R3,R6,R3, LSL #+16
   \   0000006E   0x431A             ORRS     R2,R3,R2
   \   00000070   0x60CA             STR      R2,[R1, #+12]
    198          
    199            /* Sets Accumulated Active Width */
    200            hltdc->Instance->AWCR &= ~(LTDC_AWCR_AAH | LTDC_AWCR_AAW);
   \   00000072   0x6821             LDR      R1,[R4, #+0]
   \   00000074   0x690A             LDR      R2,[R1, #+16]
   \   00000076   0x4002             ANDS     R2,R0,R2
   \   00000078   0x610A             STR      R2,[R1, #+16]
    201            tmp = (hltdc->Init.AccumulatedActiveW << 16);
    202            hltdc->Instance->AWCR |= (tmp | hltdc->Init.AccumulatedActiveH);
   \   0000007A   0x6821             LDR      R1,[R4, #+0]
   \   0000007C   0x690A             LDR      R2,[R1, #+16]
   \   0000007E   0x6A63             LDR      R3,[R4, #+36]
   \   00000080   0x6AA6             LDR      R6,[R4, #+40]
   \   00000082   0xEA46 0x4303      ORR      R3,R6,R3, LSL #+16
   \   00000086   0x431A             ORRS     R2,R3,R2
   \   00000088   0x610A             STR      R2,[R1, #+16]
    203          
    204            /* Sets Total Width */
    205            hltdc->Instance->TWCR &= ~(LTDC_TWCR_TOTALH | LTDC_TWCR_TOTALW);
   \   0000008A   0x6821             LDR      R1,[R4, #+0]
   \   0000008C   0x694A             LDR      R2,[R1, #+20]
   \   0000008E   0x4010             ANDS     R0,R0,R2
   \   00000090   0x6148             STR      R0,[R1, #+20]
    206            tmp = (hltdc->Init.TotalWidth << 16);
    207            hltdc->Instance->TWCR |= (tmp | hltdc->Init.TotalHeigh);
   \   00000092   0x6820             LDR      R0,[R4, #+0]
   \   00000094   0x6941             LDR      R1,[R0, #+20]
   \   00000096   0x6AE2             LDR      R2,[R4, #+44]
   \   00000098   0x6B23             LDR      R3,[R4, #+48]
   \   0000009A   0xEA43 0x4202      ORR      R2,R3,R2, LSL #+16
   \   0000009E   0x4311             ORRS     R1,R2,R1
   \   000000A0   0x6141             STR      R1,[R0, #+20]
    208          
    209            /* Sets the background color value */
    210            tmp = ((uint32_t)(hltdc->Init.Backcolor.Green) << 8);
   \   000000A2   0xF104 0x0034      ADD      R0,R4,#+52
    211            tmp1 = ((uint32_t)(hltdc->Init.Backcolor.Red) << 16);
    212            hltdc->Instance->BCCR &= ~(LTDC_BCCR_BCBLUE | LTDC_BCCR_BCGREEN | LTDC_BCCR_BCRED);
   \   000000A6   0x6823             LDR      R3,[R4, #+0]
   \   000000A8   0x7841             LDRB     R1,[R0, #+1]
   \   000000AA   0x7882             LDRB     R2,[R0, #+2]
   \   000000AC   0x6ADE             LDR      R6,[R3, #+44]
   \   000000AE   0xF006 0x467F      AND      R6,R6,#0xFF000000
   \   000000B2   0x62DE             STR      R6,[R3, #+44]
   \   000000B4   0x0412             LSLS     R2,R2,#+16
    213            hltdc->Instance->BCCR |= (tmp1 | tmp | hltdc->Init.Backcolor.Blue);
   \   000000B6   0x6823             LDR      R3,[R4, #+0]
   \   000000B8   0xEA42 0x2101      ORR      R1,R2,R1, LSL #+8
   \   000000BC   0x6ADE             LDR      R6,[R3, #+44]
   \   000000BE   0x7800             LDRB     R0,[R0, #+0]
   \   000000C0   0x4308             ORRS     R0,R0,R1
   \   000000C2   0x4330             ORRS     R0,R0,R6
   \   000000C4   0x62D8             STR      R0,[R3, #+44]
    214          
    215            /* Enable the transfer Error interrupt */
    216            __HAL_LTDC_ENABLE_IT(hltdc, LTDC_IT_TE);
   \   000000C6   0x6820             LDR      R0,[R4, #+0]
   \   000000C8   0x6B41             LDR      R1,[R0, #+52]
   \   000000CA   0xF041 0x0104      ORR      R1,R1,#0x4
   \   000000CE   0x6341             STR      R1,[R0, #+52]
    217          
    218            /* Enable the FIFO underrun interrupt */
    219            __HAL_LTDC_ENABLE_IT(hltdc, LTDC_IT_FU);
   \   000000D0   0x6820             LDR      R0,[R4, #+0]
   \   000000D2   0x6B41             LDR      R1,[R0, #+52]
   \   000000D4   0xF041 0x0102      ORR      R1,R1,#0x2
   \   000000D8   0x6341             STR      R1,[R0, #+52]
    220          
    221            /* Enable LTDC by setting LTDCEN bit */
    222            __HAL_LTDC_ENABLE(hltdc);
   \   000000DA   0x6820             LDR      R0,[R4, #+0]
   \   000000DC   0x6981             LDR      R1,[R0, #+24]
   \   000000DE   0xF041 0x0101      ORR      R1,R1,#0x1
   \   000000E2   0x6181             STR      R1,[R0, #+24]
    223          
    224            /* Initialize the error code */
    225            hltdc->ErrorCode = HAL_LTDC_ERROR_NONE;  
   \   000000E4   0x2000             MOVS     R0,#+0
   \   000000E6   0x6068             STR      R0,[R5, #+4]
    226          
    227            /* Initialize the LTDC state*/
    228            hltdc->State = HAL_LTDC_STATE_READY;
   \   000000E8   0x2001             MOVS     R0,#+1
   \   000000EA   0x7068             STRB     R0,[R5, #+1]
    229          
    230            return HAL_OK;
   \   000000EC   0x2000             MOVS     R0,#+0
   \   000000EE   0xBD70             POP      {R4-R6,PC}       ;; return
    231          }
    232          
    233          /**
    234            * @brief  Deinitializes the LTDC peripheral registers to their default reset
    235            *         values.
    236            * @param  hltdc: pointer to a LTDC_HandleTypeDef structure that contains
    237            *                the configuration information for the LTDC.
    238            * @retval None
    239            */
    240          

   \                                 In section .text, align 2, keep-with-next
    241          HAL_StatusTypeDef HAL_LTDC_DeInit(LTDC_HandleTypeDef *hltdc)
    242          {
   \                     HAL_LTDC_DeInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    243            /* DeInit the low level hardware */
    244            HAL_LTDC_MspDeInit(hltdc); 
   \   00000004   0x.... 0x....      BL       HAL_LTDC_MspDeInit
    245          
    246            /* Initialize the error code */
    247            hltdc->ErrorCode = HAL_LTDC_ERROR_NONE;
   \   00000008   0xF104 0x00A0      ADD      R0,R4,#+160
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0x6041             STR      R1,[R0, #+4]
    248          
    249            /* Initialize the LTDC state*/
    250            hltdc->State = HAL_LTDC_STATE_RESET;
   \   00000010   0x7041             STRB     R1,[R0, #+1]
    251          
    252            /* Release Lock */
    253            __HAL_UNLOCK(hltdc);
   \   00000012   0x7001             STRB     R1,[R0, #+0]
    254          
    255            return HAL_OK;
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0xBD10             POP      {R4,PC}          ;; return
    256          }
    257          
    258          /**
    259            * @brief  Initializes the LTDC MSP.
    260            * @param  hltdc : pointer to a LTDC_HandleTypeDef structure that contains
    261            *                the configuration information for the LTDC.
    262            * @retval None
    263            */

   \                                 In section .text, align 2, keep-with-next
    264          __weak void HAL_LTDC_MspInit(LTDC_HandleTypeDef* hltdc)
    265          {
    266            /* NOTE : This function Should not be modified, when the callback is needed,
    267                      the HAL_LTDC_MspInit could be implemented in the user file
    268             */ 
    269          }
   \                     HAL_LTDC_MspInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    270          
    271          /**
    272            * @brief  DeInitializes the LTDC MSP.
    273            * @param  hltdc : pointer to a LTDC_HandleTypeDef structure that contains
    274            *                the configuration information for the LTDC.
    275            * @retval None
    276            */

   \                                 In section .text, align 2, keep-with-next
    277          __weak void HAL_LTDC_MspDeInit(LTDC_HandleTypeDef* hltdc)
    278          {
    279            /* NOTE : This function Should not be modified, when the callback is needed,
    280                      the HAL_LTDC_MspDeInit could be implemented in the user file
    281             */
    282          }
   \                     HAL_LTDC_MspDeInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    283          
    284          /**
    285            * @}
    286            */
    287            
    288          /** @defgroup LTDC_Exported_Functions_Group2 IO operation functions 
    289           *  @brief   IO operation functions  
    290           *
    291          @verbatim
    292           ===============================================================================
    293                                #####  IO operation functions  #####
    294           ===============================================================================  
    295              [..]  This section provides function allowing to:
    296                (+) Handle LTDC interrupt request
    297          
    298          @endverbatim
    299            * @{
    300            */
    301          /**
    302            * @brief  Handles LTDC interrupt request.
    303            * @param  hltdc: pointer to a LTDC_HandleTypeDef structure that contains
    304            *                the configuration information for the LTDC.  
    305            * @retval HAL status
    306            */

   \                                 In section .text, align 2, keep-with-next
    307          void HAL_LTDC_IRQHandler(LTDC_HandleTypeDef *hltdc)
    308          {
   \                     HAL_LTDC_IRQHandler: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    309            /* Transfer Error Interrupt management ***************************************/
    310            if(__HAL_LTDC_GET_FLAG(hltdc, LTDC_FLAG_TE) != RESET)
   \   00000004   0x6820             LDR      R0,[R4, #+0]
   \   00000006   0x6B81             LDR      R1,[R0, #+56]
   \   00000008   0x0749             LSLS     R1,R1,#+29
   \   0000000A   0xD516             BPL.N    ??HAL_LTDC_IRQHandler_0
    311            {
    312              if(__HAL_LTDC_GET_IT_SOURCE(hltdc, LTDC_IT_TE) != RESET)
   \   0000000C   0x6B81             LDR      R1,[R0, #+56]
   \   0000000E   0x0749             LSLS     R1,R1,#+29
   \   00000010   0xD513             BPL.N    ??HAL_LTDC_IRQHandler_0
    313              {
    314                /* Disable the transfer Error interrupt */
    315                __HAL_LTDC_DISABLE_IT(hltdc, LTDC_IT_TE);
   \   00000012   0x6B41             LDR      R1,[R0, #+52]
   \   00000014   0xF021 0x0104      BIC      R1,R1,#0x4
   \   00000018   0x6341             STR      R1,[R0, #+52]
    316          
    317                /* Clear the transfer error flag */
    318                __HAL_LTDC_CLEAR_FLAG(hltdc, LTDC_FLAG_TE);
   \   0000001A   0x6821             LDR      R1,[R4, #+0]
   \   0000001C   0x2004             MOVS     R0,#+4
   \   0000001E   0x63C8             STR      R0,[R1, #+60]
    319          
    320                /* Update error code */
    321                hltdc->ErrorCode |= HAL_LTDC_ERROR_TE;
   \   00000020   0xF104 0x00A0      ADD      R0,R4,#+160
   \   00000024   0x6841             LDR      R1,[R0, #+4]
   \   00000026   0xF041 0x0101      ORR      R1,R1,#0x1
   \   0000002A   0x6041             STR      R1,[R0, #+4]
    322          
    323                /* Change LTDC state */
    324                hltdc->State = HAL_LTDC_STATE_ERROR;
   \   0000002C   0x2104             MOVS     R1,#+4
   \   0000002E   0x7041             STRB     R1,[R0, #+1]
    325          
    326                /* Process unlocked */
    327                __HAL_UNLOCK(hltdc);
   \   00000030   0x2100             MOVS     R1,#+0
   \   00000032   0x7001             STRB     R1,[R0, #+0]
    328          
    329                /* Transfer error Callback */
    330                HAL_LTDC_ErrorCallback(hltdc);
   \   00000034   0x4620             MOV      R0,R4
   \   00000036   0x.... 0x....      BL       HAL_LTDC_ErrorCallback
    331              }
    332            }
    333            /* FIFO underrun Interrupt management ***************************************/
    334            if(__HAL_LTDC_GET_FLAG(hltdc, LTDC_FLAG_FU) != RESET)
   \                     ??HAL_LTDC_IRQHandler_0: (+1)
   \   0000003A   0x6820             LDR      R0,[R4, #+0]
   \   0000003C   0x6B81             LDR      R1,[R0, #+56]
   \   0000003E   0x0789             LSLS     R1,R1,#+30
   \   00000040   0xD516             BPL.N    ??HAL_LTDC_IRQHandler_1
    335            {
    336              if(__HAL_LTDC_GET_IT_SOURCE(hltdc, LTDC_IT_FU) != RESET)
   \   00000042   0x6B81             LDR      R1,[R0, #+56]
   \   00000044   0x0789             LSLS     R1,R1,#+30
   \   00000046   0xD513             BPL.N    ??HAL_LTDC_IRQHandler_1
    337              {
    338                /* Disable the FIFO underrun interrupt */
    339                __HAL_LTDC_DISABLE_IT(hltdc, LTDC_IT_FU);
   \   00000048   0x6B41             LDR      R1,[R0, #+52]
   \   0000004A   0xF021 0x0102      BIC      R1,R1,#0x2
   \   0000004E   0x6341             STR      R1,[R0, #+52]
    340          
    341                /* Clear the FIFO underrun flag */
    342                __HAL_LTDC_CLEAR_FLAG(hltdc, LTDC_FLAG_FU);
   \   00000050   0x6821             LDR      R1,[R4, #+0]
   \   00000052   0x2002             MOVS     R0,#+2
   \   00000054   0x63C8             STR      R0,[R1, #+60]
    343          
    344                /* Update error code */
    345                hltdc->ErrorCode |= HAL_LTDC_ERROR_FU;
   \   00000056   0xF104 0x00A0      ADD      R0,R4,#+160
   \   0000005A   0x6841             LDR      R1,[R0, #+4]
   \   0000005C   0xF041 0x0102      ORR      R1,R1,#0x2
   \   00000060   0x6041             STR      R1,[R0, #+4]
    346          
    347                /* Change LTDC state */
    348                hltdc->State = HAL_LTDC_STATE_ERROR;
   \   00000062   0x2104             MOVS     R1,#+4
   \   00000064   0x7041             STRB     R1,[R0, #+1]
    349          
    350                /* Process unlocked */
    351                __HAL_UNLOCK(hltdc);
   \   00000066   0x2100             MOVS     R1,#+0
   \   00000068   0x7001             STRB     R1,[R0, #+0]
    352                
    353                /* Transfer error Callback */
    354                HAL_LTDC_ErrorCallback(hltdc);
   \   0000006A   0x4620             MOV      R0,R4
   \   0000006C   0x.... 0x....      BL       HAL_LTDC_ErrorCallback
    355              }
    356            }
    357            /* Line Interrupt management ************************************************/
    358            if(__HAL_LTDC_GET_FLAG(hltdc, LTDC_FLAG_LI) != RESET)
   \                     ??HAL_LTDC_IRQHandler_1: (+1)
   \   00000070   0x6820             LDR      R0,[R4, #+0]
   \   00000072   0x6B81             LDR      R1,[R0, #+56]
   \   00000074   0x07C9             LSLS     R1,R1,#+31
   \   00000076   0xD512             BPL.N    ??HAL_LTDC_IRQHandler_2
    359            {
    360              if(__HAL_LTDC_GET_IT_SOURCE(hltdc, LTDC_IT_LI) != RESET)
   \   00000078   0x6B81             LDR      R1,[R0, #+56]
   \   0000007A   0x07C9             LSLS     R1,R1,#+31
   \   0000007C   0xD50F             BPL.N    ??HAL_LTDC_IRQHandler_2
    361              {
    362                /* Disable the Line interrupt */
    363                __HAL_LTDC_DISABLE_IT(hltdc, LTDC_IT_LI);
   \   0000007E   0x6B41             LDR      R1,[R0, #+52]
   \   00000080   0x0849             LSRS     R1,R1,#+1
   \   00000082   0x0049             LSLS     R1,R1,#+1
   \   00000084   0x6341             STR      R1,[R0, #+52]
    364          
    365                /* Clear the Line interrupt flag */  
    366                __HAL_LTDC_CLEAR_FLAG(hltdc, LTDC_FLAG_LI);
   \   00000086   0x6821             LDR      R1,[R4, #+0]
   \   00000088   0x2001             MOVS     R0,#+1
   \   0000008A   0x63C8             STR      R0,[R1, #+60]
    367          
    368                /* Change LTDC state */
    369                hltdc->State = HAL_LTDC_STATE_READY;
   \   0000008C   0xF104 0x00A0      ADD      R0,R4,#+160
   \   00000090   0x2101             MOVS     R1,#+1
   \   00000092   0x7041             STRB     R1,[R0, #+1]
    370          
    371                /* Process unlocked */
    372                __HAL_UNLOCK(hltdc);
   \   00000094   0x2100             MOVS     R1,#+0
   \   00000096   0x7001             STRB     R1,[R0, #+0]
    373          
    374                /* Line interrupt Callback */
    375                HAL_LTDC_LineEvenCallback(hltdc);
   \   00000098   0x4620             MOV      R0,R4
   \   0000009A   0x.... 0x....      BL       HAL_LTDC_LineEventCallback
    376              }
    377            }
    378          }
   \                     ??HAL_LTDC_IRQHandler_2: (+1)
   \   0000009E   0xBD10             POP      {R4,PC}          ;; return
    379          
    380          /**
    381            * @brief  Error LTDC callback.
    382            * @param  hltdc: pointer to a LTDC_HandleTypeDef structure that contains
    383            *                the configuration information for the LTDC.
    384            * @retval None
    385            */

   \                                 In section .text, align 2, keep-with-next
    386          __weak void HAL_LTDC_ErrorCallback(LTDC_HandleTypeDef *hltdc)
    387          {
    388            /* NOTE : This function Should not be modified, when the callback is needed,
    389                      the HAL_LTDC_ErrorCallback could be implemented in the user file
    390             */
    391          }
   \                     HAL_LTDC_ErrorCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    392          
    393          /**
    394            * @brief  Line Event callback.
    395            * @param  hltdc: pointer to a LTDC_HandleTypeDef structure that contains
    396            *                the configuration information for the LTDC.
    397            * @retval None
    398            */

   \                                 In section .text, align 2, keep-with-next
    399          __weak void HAL_LTDC_LineEvenCallback(LTDC_HandleTypeDef *hltdc)
    400          {
    401            /* NOTE : This function Should not be modified, when the callback is needed,
    402                      the HAL_LTDC_LineEvenCallback could be implemented in the user file
    403             */
    404          }
   \                     HAL_LTDC_LineEventCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    405          
    406          /**
    407            * @}
    408            */
    409          
    410          /** @defgroup LTDC_Exported_Functions_Group3 Peripheral Control functions
    411           *  @brief    Peripheral Control functions 
    412           *
    413          @verbatim   
    414           ===============================================================================
    415                              ##### Peripheral Control functions #####
    416           ===============================================================================  
    417              [..]  This section provides functions allowing to:
    418                (+) Configure the LTDC foreground or/and background parameters.
    419                (+) Set the active layer.
    420                (+) Configure the color keying.
    421                (+) Configure the C-LUT.
    422                (+) Enable / Disable the color keying.
    423                (+) Enable / Disable the C-LUT.
    424                (+) Update the layer position.
    425                (+) Update the layer size.
    426                (+) Update pixel format on the fly. 
    427                (+) Update transparency on the fly.
    428                (+) Update address on the fly.
    429          
    430          @endverbatim
    431            * @{
    432            */
    433          
    434          /**
    435            * @brief  Configure the LTDC Layer according to the specified
    436            *         parameters in the LTDC_InitTypeDef and create the associated handle.
    437            * @param  hltdc:     pointer to a LTDC_HandleTypeDef structure that contains
    438            *                    the configuration information for the LTDC.
    439            * @param  pLayerCfg: pointer to a LTDC_LayerCfgTypeDef structure that contains
    440            *                    the configuration information for the Layer.
    441            * @param  LayerIdx:  LTDC Layer index.
    442            *                    This parameter can be one of the following values:
    443            *                    0 or 1
    444            * @retval HAL status
    445            */

   \                                 In section .text, align 2, keep-with-next
    446          HAL_StatusTypeDef HAL_LTDC_ConfigLayer(LTDC_HandleTypeDef *hltdc, LTDC_LayerCfgTypeDef *pLayerCfg, uint32_t LayerIdx)
    447          {   
   \                     HAL_LTDC_ConfigLayer: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
    448            /* Process locked */
    449            __HAL_LOCK(hltdc);
   \   00000004   0xF104 0x07A0      ADD      R7,R4,#+160
   \   00000008   0x460D             MOV      R5,R1
   \   0000000A   0x4616             MOV      R6,R2
   \   0000000C   0x7838             LDRB     R0,[R7, #+0]
   \   0000000E   0x2801             CMP      R0,#+1
   \   00000010   0xD101             BNE.N    ??HAL_LTDC_ConfigLayer_0
   \   00000012   0x2002             MOVS     R0,#+2
   \   00000014   0xBDF2             POP      {R1,R4-R7,PC}
   \                     ??HAL_LTDC_ConfigLayer_0: (+1)
   \   00000016   0x2001             MOVS     R0,#+1
    450            
    451            /* Change LTDC peripheral state */
    452            hltdc->State = HAL_LTDC_STATE_BUSY;
    453          
    454            /* Check the parameters */
    455            assert_param(IS_LTDC_LAYER(LayerIdx));
    456            assert_param(IS_LTDC_PIXEL_FORMAT(pLayerCfg->PixelFormat));
    457            assert_param(IS_LTDC_BLENDING_FACTOR1(pLayerCfg->BlendingFactor1));
    458            assert_param(IS_LTDC_BLENDING_FACTOR2(pLayerCfg->BlendingFactor2));
    459            assert_param(IS_LTDC_HCONFIGST(pLayerCfg->WindowX0));
    460            assert_param(IS_LTDC_HCONFIGSP(pLayerCfg->WindowX1));
    461            assert_param(IS_LTDC_VCONFIGST(pLayerCfg->WindowY0));
    462            assert_param(IS_LTDC_VCONFIGSP(pLayerCfg->WindowY1));
    463            assert_param(IS_LTDC_ALPHA(pLayerCfg->Alpha0));
    464            assert_param(IS_LTDC_CFBLL(pLayerCfg->ImageWidth));
    465            assert_param(IS_LTDC_CFBLNBR(pLayerCfg->ImageHeight));
    466          
    467            /* Copy new layer configuration into handle structure */
    468            hltdc->LayerCfg[LayerIdx] = *pLayerCfg;  
   \   00000018   0x2234             MOVS     R2,#+52
   \   0000001A   0x7038             STRB     R0,[R7, #+0]
   \   0000001C   0x2002             MOVS     R0,#+2
   \   0000001E   0x7078             STRB     R0,[R7, #+1]
   \   00000020   0x2034             MOVS     R0,#+52
   \   00000022   0xFB00 0x4006      MLA      R0,R0,R6,R4
   \   00000026   0x3038             ADDS     R0,R0,#+56
   \   00000028   0x.... 0x....      BL       __aeabi_memcpy4
    469          
    470            /* Configure the LTDC Layer */  
    471            LTDC_SetConfig(hltdc, pLayerCfg, LayerIdx);
   \   0000002C   0x4632             MOV      R2,R6
   \   0000002E   0x4629             MOV      R1,R5
   \   00000030   0x4620             MOV      R0,R4
   \   00000032   0x.... 0x....      BL       LTDC_SetConfig
    472          
    473            /* Sets the Reload type */
    474            hltdc->Instance->SRCR = LTDC_SRCR_IMR;
   \   00000036   0x6821             LDR      R1,[R4, #+0]
   \   00000038   0x2001             MOVS     R0,#+1
   \   0000003A   0x6248             STR      R0,[R1, #+36]
    475          
    476            /* Initialize the LTDC state*/
    477            hltdc->State  = HAL_LTDC_STATE_READY;
   \   0000003C   0x7078             STRB     R0,[R7, #+1]
    478          
    479            /* Process unlocked */
    480            __HAL_UNLOCK(hltdc);
   \   0000003E   0x2000             MOVS     R0,#+0
   \   00000040   0x7038             STRB     R0,[R7, #+0]
    481          
    482            return HAL_OK;
   \   00000042   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    483          }
    484          
    485          /**
    486            * @brief  Configure the color keying.
    487            * @param  hltdc:    pointer to a LTDC_HandleTypeDef structure that contains
    488            *                   the configuration information for the LTDC.
    489            * @param  RGBValue: the color key value
    490            * @param  LayerIdx:  LTDC Layer index.
    491            *                   This parameter can be one of the following values:
    492            *                   0 or 1
    493            * @retval HAL status
    494            */

   \                                 In section .text, align 2, keep-with-next
    495          HAL_StatusTypeDef HAL_LTDC_ConfigColorKeying(LTDC_HandleTypeDef *hltdc, uint32_t RGBValue, uint32_t LayerIdx)
    496          {
    497            /* Process locked */
    498            __HAL_LOCK(hltdc);
   \                     HAL_LTDC_ConfigColorKeying: (+1)
   \   00000000   0xF100 0x03A0      ADD      R3,R0,#+160
   \   00000004   0xB430             PUSH     {R4,R5}
   \   00000006   0x781C             LDRB     R4,[R3, #+0]
   \   00000008   0x2C01             CMP      R4,#+1
   \   0000000A   0xBF08             IT       EQ 
   \   0000000C   0x2002             MOVEQ    R0,#+2
   \   0000000E   0xD016             BEQ.N    ??HAL_LTDC_ConfigColorKeying_0
   \   00000010   0x2401             MOVS     R4,#+1
   \   00000012   0x701C             STRB     R4,[R3, #+0]
    499          
    500            /* Change LTDC peripheral state */
    501            hltdc->State = HAL_LTDC_STATE_BUSY;
   \   00000014   0x2402             MOVS     R4,#+2
   \   00000016   0x705C             STRB     R4,[R3, #+1]
    502          
    503            /* Check the parameters */
    504            assert_param(IS_LTDC_LAYER(LayerIdx));
    505          
    506            /* Configures the default color values */
    507            LTDC_LAYER(hltdc, LayerIdx)->CKCR &=  ~(LTDC_LxCKCR_CKBLUE | LTDC_LxCKCR_CKGREEN | LTDC_LxCKCR_CKRED);
   \   00000018   0x6804             LDR      R4,[R0, #+0]
   \   0000001A   0xEB04 0x14C2      ADD      R4,R4,R2, LSL #+7
   \   0000001E   0x3484             ADDS     R4,R4,#+132
   \   00000020   0x68E5             LDR      R5,[R4, #+12]
   \   00000022   0xF005 0x457F      AND      R5,R5,#0xFF000000
   \   00000026   0x60E5             STR      R5,[R4, #+12]
    508            LTDC_LAYER(hltdc, LayerIdx)->CKCR  = RGBValue;
   \   00000028   0x6804             LDR      R4,[R0, #+0]
   \   0000002A   0xEB04 0x12C2      ADD      R2,R4,R2, LSL #+7
   \   0000002E   0x3284             ADDS     R2,R2,#+132
   \   00000030   0x60D1             STR      R1,[R2, #+12]
    509          
    510            /* Sets the Reload type */
    511            hltdc->Instance->SRCR = LTDC_SRCR_IMR;
   \   00000032   0x6800             LDR      R0,[R0, #+0]
   \   00000034   0x2101             MOVS     R1,#+1
   \   00000036   0x6241             STR      R1,[R0, #+36]
    512          
    513            /* Change the LTDC state*/
    514            hltdc->State = HAL_LTDC_STATE_READY;
    515          
    516            /* Process unlocked */
    517            __HAL_UNLOCK(hltdc);
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0x7059             STRB     R1,[R3, #+1]
   \   0000003C   0x7018             STRB     R0,[R3, #+0]
    518          
    519            return HAL_OK;
   \                     ??HAL_LTDC_ConfigColorKeying_0: (+1)
   \   0000003E   0xBC30             POP      {R4,R5}
   \   00000040   0x4770             BX       LR               ;; return
    520          }
    521          
    522          /**
    523            * @brief  Load the color lookup table.
    524            * @param  hltdc:    pointer to a LTDC_HandleTypeDef structure that contains
    525            *                   the configuration information for the LTDC.
    526            * @param  pCLUT:    pointer to the color lookup table address.
    527            * @param  CLUTSize: the color lookup table size.  
    528            * @param  LayerIdx:  LTDC Layer index.
    529            *                   This parameter can be one of the following values:
    530            *                   0 or 1
    531            * @retval HAL status
    532            */

   \                                 In section .text, align 2, keep-with-next
    533          HAL_StatusTypeDef HAL_LTDC_ConfigCLUT(LTDC_HandleTypeDef *hltdc, uint32_t *pCLUT, uint32_t CLUTSize, uint32_t LayerIdx)
    534          {
   \                     HAL_LTDC_ConfigCLUT: (+1)
   \   00000000   0xB4F0             PUSH     {R4-R7}
    535            uint32_t tmp = 0;
    536            uint32_t counter = 0;
    537            uint32_t pcounter = 0;
    538          
    539            /* Process locked */
    540            __HAL_LOCK(hltdc);
   \   00000002   0xF100 0x05A0      ADD      R5,R0,#+160
   \   00000006   0x2400             MOVS     R4,#+0
   \   00000008   0x782E             LDRB     R6,[R5, #+0]
   \   0000000A   0x2E01             CMP      R6,#+1
   \   0000000C   0xBF08             IT       EQ 
   \   0000000E   0x2002             MOVEQ    R0,#+2
   \   00000010   0xD025             BEQ.N    ??HAL_LTDC_ConfigCLUT_0
   \   00000012   0x2601             MOVS     R6,#+1
   \   00000014   0x702E             STRB     R6,[R5, #+0]
    541          
    542            /* Change LTDC peripheral state */
    543            hltdc->State = HAL_LTDC_STATE_BUSY;  
   \   00000016   0x2602             MOVS     R6,#+2
   \   00000018   0x706E             STRB     R6,[R5, #+1]
    544          
    545            /* Check the parameters */
    546            assert_param(IS_LTDC_LAYER(LayerIdx)); 
    547          
    548            for(counter = 0; (counter < CLUTSize); counter++)
   \   0000001A   0xB1E2             CBZ.N    R2,??HAL_LTDC_ConfigCLUT_1
   \   0000001C   0x2634             MOVS     R6,#+52
   \   0000001E   0xFB06 0x0603      MLA      R6,R6,R3,R0
    549            {
    550              if(hltdc->LayerCfg[LayerIdx].PixelFormat == LTDC_PIXEL_FORMAT_AL44)
   \                     ??HAL_LTDC_ConfigCLUT_2: (+1)
   \   00000022   0x680F             LDR      R7,[R1, #+0]
   \   00000024   0xF8D6 0xC048      LDR      R12,[R6, #+72]
   \   00000028   0x023F             LSLS     R7,R7,#+8
   \   0000002A   0x0A3F             LSRS     R7,R7,#+8
   \   0000002C   0xF1BC 0x0F06      CMP      R12,#+6
   \   00000030   0xBF06             ITTE     EQ 
   \   00000032   0xEB04 0x1C04      ADDEQ    R12,R4,R4, LSL #+4
   \   00000036   0xEA47 0x670C      ORREQ    R7,R7,R12, LSL #+24
   \   0000003A   0xEA47 0x6704      ORRNE    R7,R7,R4, LSL #+24
    551              {
    552                tmp  = (((counter + 16*counter) << 24) | ((uint32_t)(*pCLUT) & 0xFF) | ((uint32_t)(*pCLUT) & 0xFF00) | ((uint32_t)(*pCLUT) & 0xFF0000));
    553              }
    554              else
    555              { 
    556                tmp  = ((counter << 24) | ((uint32_t)(*pCLUT) & 0xFF) | ((uint32_t)(*pCLUT) & 0xFF00) | ((uint32_t)(*pCLUT) & 0xFF0000));
    557              }
    558              pcounter = (uint32_t)pCLUT + sizeof(*pCLUT);
    559              pCLUT = (uint32_t *)pcounter;
    560          
    561              /* Specifies the C-LUT address and RGB value */
    562              LTDC_LAYER(hltdc, LayerIdx)->CLUTWR  = tmp;
   \   0000003E   0xF8D0 0xC000      LDR      R12,[R0, #+0]
   \   00000042   0x1D09             ADDS     R1,R1,#+4
    563            }
   \   00000044   0x1C64             ADDS     R4,R4,#+1
   \   00000046   0x4294             CMP      R4,R2
   \   00000048   0xEB0C 0x1CC3      ADD      R12,R12,R3, LSL #+7
   \   0000004C   0xF10C 0x0C84      ADD      R12,R12,#+132
   \   00000050   0xF8CC 0x7040      STR      R7,[R12, #+64]
   \   00000054   0xD3E5             BCC.N    ??HAL_LTDC_ConfigCLUT_2
    564            
    565            /* Change the LTDC state*/
    566            hltdc->State = HAL_LTDC_STATE_READY; 
   \                     ??HAL_LTDC_ConfigCLUT_1: (+1)
   \   00000056   0x2001             MOVS     R0,#+1
   \   00000058   0x7068             STRB     R0,[R5, #+1]
    567          
    568            /* Process unlocked */
    569            __HAL_UNLOCK(hltdc);  
   \   0000005A   0x2000             MOVS     R0,#+0
   \   0000005C   0x7028             STRB     R0,[R5, #+0]
    570          
    571            return HAL_OK;
   \                     ??HAL_LTDC_ConfigCLUT_0: (+1)
   \   0000005E   0xBCF0             POP      {R4-R7}
   \   00000060   0x4770             BX       LR               ;; return
    572          }
    573          
    574          /**
    575            * @brief  Enable the color keying.
    576            * @param  hltdc:    pointer to a LTDC_HandleTypeDef structure that contains
    577            *                   the configuration information for the LTDC.
    578            * @param  LayerIdx:  LTDC Layer index.
    579            *                   This parameter can be one of the following values:
    580            *                   0 or 1
    581            * @retval  HAL status
    582            */

   \                                 In section .text, align 2, keep-with-next
    583          HAL_StatusTypeDef HAL_LTDC_EnableColorKeying(LTDC_HandleTypeDef *hltdc, uint32_t LayerIdx)
    584          {  
    585            /* Process locked */
    586            __HAL_LOCK(hltdc);
   \                     HAL_LTDC_EnableColorKeying: (+1)
   \   00000000   0xF100 0x02A0      ADD      R2,R0,#+160
   \   00000004   0x7813             LDRB     R3,[R2, #+0]
   \   00000006   0x2B01             CMP      R3,#+1
   \   00000008   0xD101             BNE.N    ??HAL_LTDC_EnableColorKeying_0
   \   0000000A   0x2002             MOVS     R0,#+2
   \   0000000C   0x4770             BX       LR
   \                     ??HAL_LTDC_EnableColorKeying_0: (+1)
   \   0000000E   0x2301             MOVS     R3,#+1
   \   00000010   0x7013             STRB     R3,[R2, #+0]
    587          
    588            /* Change LTDC peripheral state */
    589            hltdc->State = HAL_LTDC_STATE_BUSY;
   \   00000012   0x2302             MOVS     R3,#+2
   \   00000014   0x7053             STRB     R3,[R2, #+1]
    590          
    591            /* Check the parameters */
    592            assert_param(IS_LTDC_LAYER(LayerIdx));
    593          
    594            /* Enable LTDC color keying by setting COLKEN bit */
    595            LTDC_LAYER(hltdc, LayerIdx)->CR |= (uint32_t)LTDC_LxCR_COLKEN;
   \   00000016   0x6803             LDR      R3,[R0, #+0]
   \   00000018   0xEB03 0x11C1      ADD      R1,R3,R1, LSL #+7
   \   0000001C   0xF851 0x3F84      LDR      R3,[R1, #+132]!
   \   00000020   0xF043 0x0302      ORR      R3,R3,#0x2
   \   00000024   0x....             B.N      ?Subroutine1
    596          
    597            /* Sets the Reload type */
    598            hltdc->Instance->SRCR = LTDC_SRCR_IMR;
    599          
    600            /* Change the LTDC state*/
    601            hltdc->State = HAL_LTDC_STATE_READY; 
    602          
    603            /* Process unlocked */
    604            __HAL_UNLOCK(hltdc);
    605          
    606            return HAL_OK;  
    607          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \   00000000   0x600B             STR      R3,[R1, #+0]
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x2101             MOVS     R1,#+1
   \   00000006   0x6241             STR      R1,[R0, #+36]
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x7051             STRB     R1,[R2, #+1]
   \   0000000C   0x7010             STRB     R0,[R2, #+0]
   \   0000000E   0x4770             BX       LR               ;; return
    608            
    609          /**
    610            * @brief  Disable the color keying.
    611            * @param  hltdc:    pointer to a LTDC_HandleTypeDef structure that contains
    612            *                   the configuration information for the LTDC.
    613            * @param  LayerIdx:  LTDC Layer index.
    614            *                   This parameter can be one of the following values:
    615            *                   0 or 1
    616            * @retval  HAL status
    617            */

   \                                 In section .text, align 2, keep-with-next
    618          HAL_StatusTypeDef HAL_LTDC_DisableColorKeying(LTDC_HandleTypeDef *hltdc, uint32_t LayerIdx)
    619          {
    620            /* Process locked */
    621            __HAL_LOCK(hltdc);
   \                     HAL_LTDC_DisableColorKeying: (+1)
   \   00000000   0xF100 0x02A0      ADD      R2,R0,#+160
   \   00000004   0x7813             LDRB     R3,[R2, #+0]
   \   00000006   0x2B01             CMP      R3,#+1
   \   00000008   0xD101             BNE.N    ??HAL_LTDC_DisableColorKeying_0
   \   0000000A   0x2002             MOVS     R0,#+2
   \   0000000C   0x4770             BX       LR
   \                     ??HAL_LTDC_DisableColorKeying_0: (+1)
   \   0000000E   0x2301             MOVS     R3,#+1
   \   00000010   0x7013             STRB     R3,[R2, #+0]
    622          
    623            /* Change LTDC peripheral state */
    624            hltdc->State = HAL_LTDC_STATE_BUSY;
   \   00000012   0x2302             MOVS     R3,#+2
   \   00000014   0x7053             STRB     R3,[R2, #+1]
    625          
    626            /* Check the parameters */
    627            assert_param(IS_LTDC_LAYER(LayerIdx));
    628          
    629            /* Disable LTDC color keying by setting COLKEN bit */
    630            LTDC_LAYER(hltdc, LayerIdx)->CR &= ~(uint32_t)LTDC_LxCR_COLKEN;
   \   00000016   0x6803             LDR      R3,[R0, #+0]
   \   00000018   0xEB03 0x11C1      ADD      R1,R3,R1, LSL #+7
   \   0000001C   0xF851 0x3F84      LDR      R3,[R1, #+132]!
   \   00000020   0xF023 0x0302      BIC      R3,R3,#0x2
   \   00000024                      REQUIRE ?Subroutine1
   \   00000024                      ;; // Fall through to label ?Subroutine1
    631          
    632            /* Sets the Reload type */
    633            hltdc->Instance->SRCR = LTDC_SRCR_IMR;
    634          
    635            /* Change the LTDC state*/
    636            hltdc->State = HAL_LTDC_STATE_READY; 
    637          
    638            /* Process unlocked */
    639            __HAL_UNLOCK(hltdc);
    640          
    641            return HAL_OK;
    642          }
    643          
    644          /**
    645            * @brief  Enable the color lookup table.
    646            * @param  hltdc:    pointer to a LTDC_HandleTypeDef structure that contains
    647            *                   the configuration information for the LTDC.
    648            * @param  LayerIdx:  LTDC Layer index.
    649            *                   This parameter can be one of the following values:
    650            *                   0 or 1
    651            * @retval  HAL status
    652            */

   \                                 In section .text, align 2, keep-with-next
    653          HAL_StatusTypeDef HAL_LTDC_EnableCLUT(LTDC_HandleTypeDef *hltdc, uint32_t LayerIdx)
    654          {
    655          
    656            /* Process locked */
    657            __HAL_LOCK(hltdc);
   \                     HAL_LTDC_EnableCLUT: (+1)
   \   00000000   0xF100 0x02A0      ADD      R2,R0,#+160
   \   00000004   0x7813             LDRB     R3,[R2, #+0]
   \   00000006   0x2B01             CMP      R3,#+1
   \   00000008   0xD101             BNE.N    ??HAL_LTDC_EnableCLUT_0
   \   0000000A   0x2002             MOVS     R0,#+2
   \   0000000C   0x4770             BX       LR
   \                     ??HAL_LTDC_EnableCLUT_0: (+1)
   \   0000000E   0x2301             MOVS     R3,#+1
   \   00000010   0x7013             STRB     R3,[R2, #+0]
    658          
    659            /* Change LTDC peripheral state */
    660            hltdc->State = HAL_LTDC_STATE_BUSY;
   \   00000012   0x2302             MOVS     R3,#+2
   \   00000014   0x7053             STRB     R3,[R2, #+1]
    661          
    662            /* Check the parameters */
    663            assert_param(IS_LTDC_LAYER(LayerIdx));
    664          
    665            /* Disable LTDC color lookup table by setting CLUTEN bit */
    666            LTDC_LAYER(hltdc, LayerIdx)->CR |= (uint32_t)LTDC_LxCR_CLUTEN;
   \   00000016   0x6803             LDR      R3,[R0, #+0]
   \   00000018   0xEB03 0x11C1      ADD      R1,R3,R1, LSL #+7
   \   0000001C   0xF851 0x3F84      LDR      R3,[R1, #+132]!
   \   00000020   0xF043 0x0310      ORR      R3,R3,#0x10
   \   00000024   0x....             B.N      ?Subroutine1
    667          
    668            /* Sets the Reload type */
    669            hltdc->Instance->SRCR = LTDC_SRCR_IMR;
    670          
    671            /* Change the LTDC state*/
    672            hltdc->State = HAL_LTDC_STATE_READY; 
    673          
    674            /* Process unlocked */
    675            __HAL_UNLOCK(hltdc);
    676          
    677            return HAL_OK;
    678          }
    679          
    680          /**
    681            * @brief  Disable the color lookup table.
    682            * @param  hltdc:    pointer to a LTDC_HandleTypeDef structure that contains
    683            *                   the configuration information for the LTDC.
    684            * @param  LayerIdx:  LTDC Layer index.
    685            *                   This parameter can be one of the following values:
    686            *                   0 or 1   
    687            * @retval  HAL status
    688            */

   \                                 In section .text, align 2, keep-with-next
    689          HAL_StatusTypeDef HAL_LTDC_DisableCLUT(LTDC_HandleTypeDef *hltdc, uint32_t LayerIdx)
    690          {
    691           
    692            /* Process locked */
    693            __HAL_LOCK(hltdc);
   \                     HAL_LTDC_DisableCLUT: (+1)
   \   00000000   0xF100 0x02A0      ADD      R2,R0,#+160
   \   00000004   0x7813             LDRB     R3,[R2, #+0]
   \   00000006   0x2B01             CMP      R3,#+1
   \   00000008   0xD101             BNE.N    ??HAL_LTDC_DisableCLUT_0
   \   0000000A   0x2002             MOVS     R0,#+2
   \   0000000C   0x4770             BX       LR
   \                     ??HAL_LTDC_DisableCLUT_0: (+1)
   \   0000000E   0x2301             MOVS     R3,#+1
   \   00000010   0x7013             STRB     R3,[R2, #+0]
    694          
    695            /* Change LTDC peripheral state */
    696            hltdc->State = HAL_LTDC_STATE_BUSY;
   \   00000012   0x2302             MOVS     R3,#+2
   \   00000014   0x7053             STRB     R3,[R2, #+1]
    697          
    698            /* Check the parameters */
    699            assert_param(IS_LTDC_LAYER(LayerIdx));
    700          
    701            /* Disable LTDC color lookup table by setting CLUTEN bit */
    702            LTDC_LAYER(hltdc, LayerIdx)->CR &= ~(uint32_t)LTDC_LxCR_CLUTEN;
   \   00000016   0x6803             LDR      R3,[R0, #+0]
   \   00000018   0xEB03 0x11C1      ADD      R1,R3,R1, LSL #+7
   \   0000001C   0xF851 0x3F84      LDR      R3,[R1, #+132]!
   \   00000020   0xF023 0x0310      BIC      R3,R3,#0x10
   \   00000024   0x....             B.N      ?Subroutine1
    703          
    704            /* Sets the Reload type */
    705            hltdc->Instance->SRCR = LTDC_SRCR_IMR;
    706          
    707            /* Change the LTDC state*/
    708            hltdc->State = HAL_LTDC_STATE_READY; 
    709          
    710            /* Process unlocked */
    711            __HAL_UNLOCK(hltdc);
    712          
    713            return HAL_OK;
    714          }
    715          
    716          /**
    717            * @brief  Enables Dither.
    718            * @param  hltdc: pointer to a LTDC_HandleTypeDef structure that contains
    719            *                the configuration information for the LTDC.
    720            * @retval  HAL status
    721            */
    722          

   \                                 In section .text, align 2, keep-with-next
    723          HAL_StatusTypeDef HAL_LTDC_EnableDither(LTDC_HandleTypeDef *hltdc)
    724          {
    725            /* Process locked */
    726            __HAL_LOCK(hltdc);
   \                     HAL_LTDC_EnableDither: (+1)
   \   00000000   0xF810 0x1FA0      LDRB     R1,[R0, #+160]!
   \   00000004   0x2901             CMP      R1,#+1
   \   00000006   0xD101             BNE.N    ??HAL_LTDC_EnableDither_0
   \   00000008   0x2002             MOVS     R0,#+2
   \   0000000A   0x4770             BX       LR
   \                     ??HAL_LTDC_EnableDither_0: (+1)
   \   0000000C   0x2101             MOVS     R1,#+1
   \   0000000E   0x7001             STRB     R1,[R0, #+0]
    727          
    728            /* Change LTDC peripheral state */
    729            hltdc->State = HAL_LTDC_STATE_BUSY;
   \   00000010   0x2102             MOVS     R1,#+2
   \   00000012   0x7041             STRB     R1,[R0, #+1]
    730          
    731            /* Enable Dither by setting DTEN bit */
    732            LTDC->GCR |= (uint32_t)LTDC_GCR_DTEN;
   \   00000014   0x....             LDR.N    R1,??DataTable3_1  ;; 0x40016818
   \   00000016   0x680A             LDR      R2,[R1, #+0]
   \   00000018   0xF442 0x3280      ORR      R2,R2,#0x10000
   \   0000001C   0x....             B.N      ?Subroutine2
    733          
    734            /* Change the LTDC state*/
    735            hltdc->State = HAL_LTDC_STATE_READY; 
    736          
    737            /* Process unlocked */
    738            __HAL_UNLOCK(hltdc);
    739          
    740            return HAL_OK;
    741          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine2: (+1)
   \   00000000   0x600A             STR      R2,[R1, #+0]
   \   00000002   0x2101             MOVS     R1,#+1
   \   00000004   0x7041             STRB     R1,[R0, #+1]
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x7001             STRB     R1,[R0, #+0]
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x4770             BX       LR               ;; return
    742          
    743          /**
    744            * @brief  Disables Dither.
    745            * @param  hltdc: pointer to a LTDC_HandleTypeDef structure that contains
    746            *                the configuration information for the LTDC.
    747            * @retval  HAL status
    748            */
    749          

   \                                 In section .text, align 2, keep-with-next
    750          HAL_StatusTypeDef HAL_LTDC_DisableDither(LTDC_HandleTypeDef *hltdc)
    751          {
    752            /* Process locked */
    753            __HAL_LOCK(hltdc);
   \                     HAL_LTDC_DisableDither: (+1)
   \   00000000   0xF810 0x1FA0      LDRB     R1,[R0, #+160]!
   \   00000004   0x2901             CMP      R1,#+1
   \   00000006   0xD101             BNE.N    ??HAL_LTDC_DisableDither_0
   \   00000008   0x2002             MOVS     R0,#+2
   \   0000000A   0x4770             BX       LR
   \                     ??HAL_LTDC_DisableDither_0: (+1)
   \   0000000C   0x2101             MOVS     R1,#+1
   \   0000000E   0x7001             STRB     R1,[R0, #+0]
    754          
    755            /* Change LTDC peripheral state */
    756            hltdc->State = HAL_LTDC_STATE_BUSY;
   \   00000010   0x2102             MOVS     R1,#+2
   \   00000012   0x7041             STRB     R1,[R0, #+1]
    757          
    758            /* Disable Dither by setting DTEN bit */
    759            LTDC->GCR &= ~(uint32_t)LTDC_GCR_DTEN;
   \   00000014   0x....             LDR.N    R1,??DataTable3_1  ;; 0x40016818
   \   00000016   0x680A             LDR      R2,[R1, #+0]
   \   00000018   0xF422 0x3280      BIC      R2,R2,#0x10000
   \   0000001C                      REQUIRE ?Subroutine2
   \   0000001C                      ;; // Fall through to label ?Subroutine2
    760          
    761            /* Change the LTDC state*/
    762            hltdc->State = HAL_LTDC_STATE_READY;
    763          
    764            /* Process unlocked */
    765            __HAL_UNLOCK(hltdc);
    766          
    767            return HAL_OK;
    768          }
    769          
    770          /**
    771            * @brief  Set the LTDC window size.
    772            * @param  hltdc:    pointer to a LTDC_HandleTypeDef structure that contains
    773            *                   the configuration information for the LTDC.
    774            * @param  XSize:    LTDC Pixel per line
    775            * @param  YSize:    LTDC Line number
    776            * @param  LayerIdx:  LTDC Layer index.
    777            *                   This parameter can be one of the following values:
    778            *                   0 or 1
    779            * @retval  HAL status
    780            */

   \                                 In section .text, align 2, keep-with-next
    781          HAL_StatusTypeDef HAL_LTDC_SetWindowSize(LTDC_HandleTypeDef *hltdc, uint32_t XSize, uint32_t YSize, uint32_t LayerIdx) 
    782          {
   \                     HAL_LTDC_SetWindowSize: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
    783            LTDC_LayerCfgTypeDef *pLayerCfg;
    784          
    785            /* Process locked */
    786            __HAL_LOCK(hltdc);
   \   00000004   0xF104 0x05A0      ADD      R5,R4,#+160
   \   00000008   0x7828             LDRB     R0,[R5, #+0]
   \   0000000A   0x2801             CMP      R0,#+1
   \   0000000C   0xD101             BNE.N    ??HAL_LTDC_SetWindowSize_0
   \   0000000E   0x2002             MOVS     R0,#+2
   \   00000010   0xBD70             POP      {R4-R6,PC}
   \                     ??HAL_LTDC_SetWindowSize_0: (+1)
   \   00000012   0x2001             MOVS     R0,#+1
    787          
    788            /* Change LTDC peripheral state */
    789            hltdc->State = HAL_LTDC_STATE_BUSY; 
    790          
    791            /* Get layer configuration from handle structure */
    792            pLayerCfg = &hltdc->LayerCfg[LayerIdx];
    793          
    794            /* Check the parameters (Layers parameters)*/
    795            assert_param(IS_LTDC_LAYER(LayerIdx));
    796            assert_param(IS_LTDC_HCONFIGST(pLayerCfg->WindowX0));
    797            assert_param(IS_LTDC_HCONFIGSP(pLayerCfg->WindowX1));
    798            assert_param(IS_LTDC_VCONFIGST(pLayerCfg->WindowY0));
    799            assert_param(IS_LTDC_VCONFIGSP(pLayerCfg->WindowY1));
    800            assert_param(IS_LTDC_CFBLL(XSize));
    801            assert_param(IS_LTDC_CFBLNBR(YSize));
    802          
    803            /* update horizontal start/stop */
    804            pLayerCfg->WindowX0 = 0;
   \   00000014   0x2600             MOVS     R6,#+0
   \   00000016   0x7028             STRB     R0,[R5, #+0]
   \   00000018   0x2002             MOVS     R0,#+2
   \   0000001A   0x7068             STRB     R0,[R5, #+1]
   \   0000001C   0x2034             MOVS     R0,#+52
   \   0000001E   0xFB00 0x4003      MLA      R0,R0,R3,R4
   \   00000022   0xF840 0x6F38      STR      R6,[R0, #+56]!
    805            pLayerCfg->WindowX1 = XSize + pLayerCfg->WindowX0;
   \   00000026   0x6041             STR      R1,[R0, #+4]
    806          
    807            /* update vertical start/stop */  
    808            pLayerCfg->WindowY0 = 0;
    809            pLayerCfg->WindowY1 = YSize + pLayerCfg->WindowY0;
    810          
    811            /* Reconfigures the color frame buffer pitch in byte */
    812            pLayerCfg->ImageWidth = XSize;
   \   00000028   0x6281             STR      R1,[R0, #+40]
    813          
    814            /* Reconfigures the frame buffer line number */
    815            pLayerCfg->ImageHeight = YSize;
    816          
    817            /* Set LTDC parameters */
    818            LTDC_SetConfig(hltdc, pLayerCfg, LayerIdx);
   \   0000002A   0x4601             MOV      R1,R0
   \   0000002C   0x6086             STR      R6,[R0, #+8]
   \   0000002E   0x60C2             STR      R2,[R0, #+12]
   \   00000030   0x62C2             STR      R2,[R0, #+44]
   \   00000032   0x461A             MOV      R2,R3
   \   00000034   0x....             B.N      ?Subroutine0
    819          
    820            /* Sets the Reload type */
    821            hltdc->Instance->SRCR = LTDC_SRCR_IMR;
    822          
    823            /* Change the LTDC state*/
    824            hltdc->State = HAL_LTDC_STATE_READY;
    825          
    826            /* Process unlocked */
    827            __HAL_UNLOCK(hltdc);
    828          
    829            return HAL_OK;
    830          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \   00000000   0x4620             MOV      R0,R4
   \   00000002   0x.... 0x....      BL       LTDC_SetConfig
   \   00000006   0x6821             LDR      R1,[R4, #+0]
   \   00000008   0x2001             MOVS     R0,#+1
   \   0000000A   0x6248             STR      R0,[R1, #+36]
   \   0000000C   0x7068             STRB     R0,[R5, #+1]
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0x7028             STRB     R0,[R5, #+0]
   \   00000012   0xBD70             POP      {R4-R6,PC}       ;; return
    831          
    832          /**
    833            * @brief  Set the LTDC window position.
    834            * @param  hltdc:    pointer to a LTDC_HandleTypeDef structure that contains
    835            *                   the configuration information for the LTDC.
    836            * @param  X0:       LTDC window X offset
    837            * @param  Y0:       LTDC window Y offset
    838            * @param  LayerIdx:  LTDC Layer index.
    839            *                         This parameter can be one of the following values:
    840            *                         0 or 1
    841            * @retval  HAL status
    842            */

   \                                 In section .text, align 2, keep-with-next
    843          HAL_StatusTypeDef HAL_LTDC_SetWindowPosition(LTDC_HandleTypeDef *hltdc, uint32_t X0, uint32_t Y0, uint32_t LayerIdx)
    844          {
   \                     HAL_LTDC_SetWindowPosition: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
    845            LTDC_LayerCfgTypeDef *pLayerCfg;
    846            
    847            /* Process locked */
    848            __HAL_LOCK(hltdc);
   \   00000004   0xF104 0x05A0      ADD      R5,R4,#+160
   \   00000008   0x7828             LDRB     R0,[R5, #+0]
   \   0000000A   0x2801             CMP      R0,#+1
   \   0000000C   0xD101             BNE.N    ??HAL_LTDC_SetWindowPosition_0
   \   0000000E   0x2002             MOVS     R0,#+2
   \   00000010   0xBD70             POP      {R4-R6,PC}
   \                     ??HAL_LTDC_SetWindowPosition_0: (+1)
   \   00000012   0x2001             MOVS     R0,#+1
   \   00000014   0x7028             STRB     R0,[R5, #+0]
    849          
    850            /* Change LTDC peripheral state */
    851            hltdc->State = HAL_LTDC_STATE_BUSY;
   \   00000016   0x2002             MOVS     R0,#+2
   \   00000018   0x7068             STRB     R0,[R5, #+1]
    852          
    853            /* Get layer configuration from handle structure */
    854            pLayerCfg = &hltdc->LayerCfg[LayerIdx];
   \   0000001A   0x2034             MOVS     R0,#+52
   \   0000001C   0xFB00 0x4003      MLA      R0,R0,R3,R4
    855          
    856            /* Check the parameters */
    857            assert_param(IS_LTDC_LAYER(LayerIdx));
    858            assert_param(IS_LTDC_HCONFIGST(pLayerCfg->WindowX0));
    859            assert_param(IS_LTDC_HCONFIGSP(pLayerCfg->WindowX1));
    860            assert_param(IS_LTDC_VCONFIGST(pLayerCfg->WindowY0));
    861            assert_param(IS_LTDC_VCONFIGSP(pLayerCfg->WindowY1));
    862          
    863            /* update horizontal start/stop */
    864            pLayerCfg->WindowX0 = X0;
   \   00000020   0xF840 0x1F38      STR      R1,[R0, #+56]!
    865            pLayerCfg->WindowX1 = X0 + pLayerCfg->ImageWidth;
    866          
    867            /* update vertical start/stop */
    868            pLayerCfg->WindowY0 = Y0;
   \   00000024   0x6082             STR      R2,[R0, #+8]
   \   00000026   0x6A86             LDR      R6,[R0, #+40]
   \   00000028   0x1871             ADDS     R1,R6,R1
   \   0000002A   0x6041             STR      R1,[R0, #+4]
    869            pLayerCfg->WindowY1 = Y0 + pLayerCfg->ImageHeight;
   \   0000002C   0x6AC1             LDR      R1,[R0, #+44]
   \   0000002E   0x1889             ADDS     R1,R1,R2
    870          
    871            /* Set LTDC parameters */
    872            LTDC_SetConfig(hltdc, pLayerCfg, LayerIdx);
   \   00000030   0x461A             MOV      R2,R3
   \   00000032   0x60C1             STR      R1,[R0, #+12]
   \   00000034   0x4601             MOV      R1,R0
   \   00000036                      REQUIRE ?Subroutine0
   \   00000036                      ;; // Fall through to label ?Subroutine0
    873          
    874            /* Sets the Reload type */
    875            hltdc->Instance->SRCR = LTDC_SRCR_IMR;
    876          
    877            /* Change the LTDC state*/
    878            hltdc->State = HAL_LTDC_STATE_READY;
    879          
    880            /* Process unlocked */
    881            __HAL_UNLOCK(hltdc);
    882          
    883            return HAL_OK;
    884          }
    885          
    886          /**
    887            * @brief  Reconfigure the pixel format.
    888            * @param  hltdc:       pointer to a LTDC_HandleTypeDef structure that contains
    889            *                      the configuration information for the LTDC.
    890            * @param  Pixelformat: new pixel format value.
    891            * @param  LayerIdx:    LTDC Layer index.
    892            *                      This parameter can be one of the following values:
    893            *                      0 or 1.
    894            * @retval  HAL status
    895            */

   \                                 In section .text, align 2, keep-with-next
    896          HAL_StatusTypeDef HAL_LTDC_SetPixelFormat(LTDC_HandleTypeDef *hltdc, uint32_t Pixelformat, uint32_t LayerIdx)
    897          {
   \                     HAL_LTDC_SetPixelFormat: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
    898            LTDC_LayerCfgTypeDef *pLayerCfg;
    899          
    900            /* Process locked */
    901            __HAL_LOCK(hltdc);
   \   00000004   0xF104 0x05A0      ADD      R5,R4,#+160
   \   00000008   0x7828             LDRB     R0,[R5, #+0]
   \   0000000A   0x2801             CMP      R0,#+1
   \   0000000C   0xD101             BNE.N    ??HAL_LTDC_SetPixelFormat_0
   \   0000000E   0x2002             MOVS     R0,#+2
   \   00000010   0xBD32             POP      {R1,R4,R5,PC}
   \                     ??HAL_LTDC_SetPixelFormat_0: (+1)
   \   00000012   0x2001             MOVS     R0,#+1
   \   00000014   0x7028             STRB     R0,[R5, #+0]
    902          
    903            /* Change LTDC peripheral state */
    904            hltdc->State = HAL_LTDC_STATE_BUSY;
   \   00000016   0x2002             MOVS     R0,#+2
   \   00000018   0x7068             STRB     R0,[R5, #+1]
    905          
    906            /* Check the parameters */
    907            assert_param(IS_LTDC_LAYER(LayerIdx));
    908            assert_param(IS_LTDC_PIXEL_FORMAT(Pixelformat));
    909          
    910            /* Get layer configuration from handle structure */
    911            pLayerCfg = &hltdc->LayerCfg[LayerIdx];  
   \   0000001A   0x2034             MOVS     R0,#+52
   \   0000001C   0xFB00 0x4002      MLA      R0,R0,R2,R4
   \   00000020   0x3038             ADDS     R0,R0,#+56
    912          
    913            /* Reconfigure the pixel format */
    914            pLayerCfg->PixelFormat = Pixelformat;
   \   00000022   0x6101             STR      R1,[R0, #+16]
    915          
    916            /* Set LTDC parameters */
    917            LTDC_SetConfig(hltdc, pLayerCfg, LayerIdx);   
   \   00000024   0x....             B.N      ?Subroutine3
    918          
    919            /* Sets the Reload type */
    920            hltdc->Instance->SRCR = LTDC_SRCR_IMR;
    921          
    922            /* Change the LTDC state*/
    923            hltdc->State = HAL_LTDC_STATE_READY;
    924          
    925            /* Process unlocked */
    926            __HAL_UNLOCK(hltdc);
    927          
    928            return HAL_OK;
    929          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine3: (+1)
   \   00000000   0x4601             MOV      R1,R0
   \   00000002   0x4620             MOV      R0,R4
   \   00000004   0x.... 0x....      BL       LTDC_SetConfig
   \   00000008   0x6821             LDR      R1,[R4, #+0]
   \   0000000A   0x2001             MOVS     R0,#+1
   \   0000000C   0x6248             STR      R0,[R1, #+36]
   \   0000000E   0x7068             STRB     R0,[R5, #+1]
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0x7028             STRB     R0,[R5, #+0]
   \   00000014   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    930          
    931          /**
    932            * @brief  Reconfigure the layer alpha value.
    933            * @param  hltdc:    pointer to a LTDC_HandleTypeDef structure that contains
    934            *                   the configuration information for the LTDC.
    935            * @param  Alpha:    new alpha value.
    936            * @param  LayerIdx:  LTDC Layer index.
    937            *                   This parameter can be one of the following values:
    938            *                   0 or 1
    939            * @retval  HAL status
    940            */

   \                                 In section .text, align 2, keep-with-next
    941          HAL_StatusTypeDef HAL_LTDC_SetAlpha(LTDC_HandleTypeDef *hltdc, uint32_t Alpha, uint32_t LayerIdx)
    942          {
   \                     HAL_LTDC_SetAlpha: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
    943            LTDC_LayerCfgTypeDef *pLayerCfg;
    944          
    945            /* Process locked */
    946            __HAL_LOCK(hltdc);
   \   00000004   0xF104 0x05A0      ADD      R5,R4,#+160
   \   00000008   0x7828             LDRB     R0,[R5, #+0]
   \   0000000A   0x2801             CMP      R0,#+1
   \   0000000C   0xD101             BNE.N    ??HAL_LTDC_SetAlpha_0
   \   0000000E   0x2002             MOVS     R0,#+2
   \   00000010   0xBD32             POP      {R1,R4,R5,PC}
   \                     ??HAL_LTDC_SetAlpha_0: (+1)
   \   00000012   0x2001             MOVS     R0,#+1
   \   00000014   0x7028             STRB     R0,[R5, #+0]
    947          
    948            /* Change LTDC peripheral state */
    949            hltdc->State = HAL_LTDC_STATE_BUSY;
   \   00000016   0x2002             MOVS     R0,#+2
   \   00000018   0x7068             STRB     R0,[R5, #+1]
    950          
    951            /* Check the parameters */
    952            assert_param(IS_LTDC_ALPHA(Alpha));
    953            assert_param(IS_LTDC_LAYER(LayerIdx));
    954          
    955            /* Get layer configuration from handle structure */
    956            pLayerCfg = &hltdc->LayerCfg[LayerIdx];
   \   0000001A   0x2034             MOVS     R0,#+52
   \   0000001C   0xFB00 0x4002      MLA      R0,R0,R2,R4
   \   00000020   0x3038             ADDS     R0,R0,#+56
    957          
    958            /* Reconfigure the Alpha value */
    959            pLayerCfg->Alpha = Alpha;
   \   00000022   0x6141             STR      R1,[R0, #+20]
    960          
    961            /* Set LTDC parameters */
    962            LTDC_SetConfig(hltdc, pLayerCfg, LayerIdx);
   \   00000024                      REQUIRE ?Subroutine3
   \   00000024                      ;; // Fall through to label ?Subroutine3
    963          
    964            /* Sets the Reload type */
    965            hltdc->Instance->SRCR = LTDC_SRCR_IMR;
    966          
    967            /* Change the LTDC state*/
    968            hltdc->State = HAL_LTDC_STATE_READY;
    969          
    970            /* Process unlocked */
    971            __HAL_UNLOCK(hltdc);
    972          
    973            return HAL_OK;
    974          }
    975          /**
    976            * @brief  Reconfigure the frame buffer Address.
    977            * @param  hltdc:    pointer to a LTDC_HandleTypeDef structure that contains
    978            *                   the configuration information for the LTDC.
    979            * @param  Address:  new address value.
    980            * @param  LayerIdx: LTDC Layer index.
    981            *                   This parameter can be one of the following values:
    982            *                   0 or 1.
    983            * @retval  HAL status
    984            */

   \                                 In section .text, align 2, keep-with-next
    985          HAL_StatusTypeDef HAL_LTDC_SetAddress(LTDC_HandleTypeDef *hltdc, uint32_t Address, uint32_t LayerIdx)
    986          {
   \                     HAL_LTDC_SetAddress: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
    987            LTDC_LayerCfgTypeDef *pLayerCfg;
    988          
    989            /* Process locked */
    990            __HAL_LOCK(hltdc);
   \   00000004   0xF104 0x05A0      ADD      R5,R4,#+160
   \   00000008   0x7828             LDRB     R0,[R5, #+0]
   \   0000000A   0x2801             CMP      R0,#+1
   \   0000000C   0xD101             BNE.N    ??HAL_LTDC_SetAddress_0
   \   0000000E   0x2002             MOVS     R0,#+2
   \   00000010   0xBD32             POP      {R1,R4,R5,PC}
   \                     ??HAL_LTDC_SetAddress_0: (+1)
   \   00000012   0x2001             MOVS     R0,#+1
   \   00000014   0x7028             STRB     R0,[R5, #+0]
    991          
    992            /* Change LTDC peripheral state */
    993            hltdc->State = HAL_LTDC_STATE_BUSY;
   \   00000016   0x2002             MOVS     R0,#+2
   \   00000018   0x7068             STRB     R0,[R5, #+1]
    994          
    995            /* Check the parameters */
    996            assert_param(IS_LTDC_LAYER(LayerIdx));
    997          
    998            /* Get layer configuration from handle structure */
    999            pLayerCfg = &hltdc->LayerCfg[LayerIdx];
   \   0000001A   0x2034             MOVS     R0,#+52
   \   0000001C   0xFB00 0x4002      MLA      R0,R0,R2,R4
   \   00000020   0x3038             ADDS     R0,R0,#+56
   1000          
   1001            /* Reconfigure the Address */
   1002            pLayerCfg->FBStartAdress = Address;
   \   00000022   0x6241             STR      R1,[R0, #+36]
   1003          
   1004            /* Set LTDC parameters */
   1005            LTDC_SetConfig(hltdc, pLayerCfg, LayerIdx);
   \   00000024   0x....             B.N      ?Subroutine3
   1006          
   1007            /* Sets the Reload type */
   1008            hltdc->Instance->SRCR = LTDC_SRCR_IMR;
   1009          
   1010            /* Change the LTDC state*/
   1011            hltdc->State = HAL_LTDC_STATE_READY;
   1012          
   1013            /* Process unlocked */
   1014            __HAL_UNLOCK(hltdc);
   1015          
   1016            return HAL_OK;
   1017          }
   1018          
   1019          /**
   1020            * @brief  Define the position of the line interrupt .
   1021            * @param  hltdc:             pointer to a LTDC_HandleTypeDef structure that contains
   1022            *                            the configuration information for the LTDC.
   1023            * @param  Line:   Line Interrupt Position.
   1024            * @retval  HAL status
   1025            */

   \                                 In section .text, align 2, keep-with-next
   1026          HAL_StatusTypeDef HAL_LTDC_ProgramLineEvent(LTDC_HandleTypeDef *hltdc, uint32_t Line)
   1027          {
   1028            /* Process locked */
   1029            __HAL_LOCK(hltdc);
   \                     HAL_LTDC_ProgramLineEvent: (+1)
   \   00000000   0xF100 0x02A0      ADD      R2,R0,#+160
   \   00000004   0x7813             LDRB     R3,[R2, #+0]
   \   00000006   0x2B01             CMP      R3,#+1
   \   00000008   0xD101             BNE.N    ??HAL_LTDC_ProgramLineEvent_0
   \   0000000A   0x2002             MOVS     R0,#+2
   \   0000000C   0x4770             BX       LR
   \                     ??HAL_LTDC_ProgramLineEvent_0: (+1)
   \   0000000E   0x2301             MOVS     R3,#+1
   \   00000010   0x7013             STRB     R3,[R2, #+0]
   1030          
   1031            /* Change LTDC peripheral state */
   1032            hltdc->State = HAL_LTDC_STATE_BUSY;
   \   00000012   0x2302             MOVS     R3,#+2
   \   00000014   0x7053             STRB     R3,[R2, #+1]
   1033          
   1034            /* Check the parameters */
   1035            assert_param(IS_LTDC_LIPOS(Line));
   1036          
   1037            /* Enable the Line interrupt */
   1038            __HAL_LTDC_ENABLE_IT(hltdc, LTDC_IT_LI);
   \   00000016   0x6800             LDR      R0,[R0, #+0]
   \   00000018   0x6B43             LDR      R3,[R0, #+52]
   \   0000001A   0xF043 0x0301      ORR      R3,R3,#0x1
   \   0000001E   0x6343             STR      R3,[R0, #+52]
   1039          
   1040            /* Sets the Line Interrupt position */
   1041            LTDC->LIPCR = (uint32_t)Line;
   \   00000020   0x....             LDR.N    R0,??DataTable3_2  ;; 0x40016840
   \   00000022   0x6001             STR      R1,[R0, #+0]
   1042          
   1043            /* Change the LTDC state*/
   1044            hltdc->State = HAL_LTDC_STATE_READY;
   \   00000024   0x2001             MOVS     R0,#+1
   \   00000026   0x7050             STRB     R0,[R2, #+1]
   1045          
   1046            /* Process unlocked */
   1047            __HAL_UNLOCK(hltdc);
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0x7010             STRB     R0,[R2, #+0]
   1048          
   1049            return HAL_OK;
   \   0000002C   0x4770             BX       LR               ;; return
   1050          }
   1051          
   1052          /**
   1053            * @}
   1054            */
   1055          
   1056          /** @defgroup LTDC_Exported_Functions_Group4 Peripheral State and Errors functions
   1057           *  @brief    Peripheral State and Errors functions 
   1058           *
   1059          @verbatim   
   1060           ===============================================================================
   1061                            ##### Peripheral State and Errors functions #####
   1062           ===============================================================================  
   1063              [..]
   1064              This subsection provides functions allowing to
   1065                (+) Check the LTDC state.
   1066                (+) Get error code.  
   1067          
   1068          @endverbatim
   1069            * @{
   1070            */ 
   1071          
   1072          /**
   1073            * @brief  Return the LTDC state
   1074            * @param  hltdc: pointer to a LTDC_HandleTypeDef structure that contains
   1075            *                the configuration information for the LTDC.
   1076            * @retval HAL state
   1077            */

   \                                 In section .text, align 2, keep-with-next
   1078          HAL_LTDC_StateTypeDef HAL_LTDC_GetState(LTDC_HandleTypeDef *hltdc)
   1079          {
   1080            return hltdc->State;
   \                     HAL_LTDC_GetState: (+1)
   \   00000000   0xF890 0x00A1      LDRB     R0,[R0, #+161]
   \   00000004   0x4770             BX       LR               ;; return
   1081          }
   1082          
   1083          /**
   1084          * @brief  Return the LTDC error code
   1085          * @param  hltdc : pointer to a LTDC_HandleTypeDef structure that contains
   1086            *               the configuration information for the LTDC.
   1087          * @retval LTDC Error Code
   1088          */

   \                                 In section .text, align 2, keep-with-next
   1089          uint32_t HAL_LTDC_GetError(LTDC_HandleTypeDef *hltdc)
   1090          {
   1091            return hltdc->ErrorCode;
   \                     HAL_LTDC_GetError: (+1)
   \   00000000   0xF8D0 0x00A4      LDR      R0,[R0, #+164]
   \   00000004   0x4770             BX       LR               ;; return
   1092          }
   1093          
   1094          /**
   1095            * @}
   1096            */
   1097          
   1098          /**
   1099            * @brief  Configures the LTDC peripheral 
   1100            * @param  hltdc   :  Pointer to a LTDC_HandleTypeDef structure that contains
   1101            *                   the configuration information for the LTDC.
   1102            * @param  pLayerCfg: Pointer LTDC Layer Configuration structure
   1103            * @param  LayerIdx:  LTDC Layer index.
   1104            *                    This parameter can be one of the following values: 0 or 1
   1105            * @retval None
   1106            */

   \                                 In section .text, align 2, keep-with-next
   1107          static void LTDC_SetConfig(LTDC_HandleTypeDef *hltdc, LTDC_LayerCfgTypeDef *pLayerCfg, uint32_t LayerIdx)
   1108          {
   \                     LTDC_SetConfig: (+1)
   \   00000000   0xB470             PUSH     {R4-R6}
   1109            uint32_t tmp = 0;
   1110            uint32_t tmp1 = 0;
   1111            uint32_t tmp2 = 0;
   1112          
   1113            /* Configures the horizontal start and stop position */
   1114            tmp = ((pLayerCfg->WindowX1 + ((hltdc->Instance->BPCR & LTDC_BPCR_AHBP) >> 16)) << 16);
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x684B             LDR      R3,[R1, #+4]
   \   00000006   0x68C4             LDR      R4,[R0, #+12]
   1115            LTDC_LAYER(hltdc, LayerIdx)->WHPCR &= ~(LTDC_LxWHPCR_WHSTPOS | LTDC_LxWHPCR_WHSPPOS);
   \   00000008   0xEB00 0x12C2      ADD      R2,R0,R2, LSL #+7
   \   0000000C   0xF3C4 0x440B      UBFX     R4,R4,#+16,#+12
   \   00000010   0x18E3             ADDS     R3,R4,R3
   \   00000012   0x3284             ADDS     R2,R2,#+132
   \   00000014   0x6854             LDR      R4,[R2, #+4]
   \   00000016   0xF404 0x4470      AND      R4,R4,#0xF000
   \   0000001A   0x6054             STR      R4,[R2, #+4]
   1116            LTDC_LAYER(hltdc, LayerIdx)->WHPCR = ((pLayerCfg->WindowX0 + ((hltdc->Instance->BPCR & LTDC_BPCR_AHBP) >> 16) + 1) | tmp);
   \   0000001C   0x680C             LDR      R4,[R1, #+0]
   \   0000001E   0x68C5             LDR      R5,[R0, #+12]
   \   00000020   0xF3C5 0x450B      UBFX     R5,R5,#+16,#+12
   \   00000024   0x192C             ADDS     R4,R5,R4
   \   00000026   0x1C64             ADDS     R4,R4,#+1
   \   00000028   0xEA44 0x4303      ORR      R3,R4,R3, LSL #+16
   \   0000002C   0x6053             STR      R3,[R2, #+4]
   1117          
   1118            /* Configures the vertical start and stop position */
   1119            tmp = ((pLayerCfg->WindowY1 + (hltdc->Instance->BPCR & LTDC_BPCR_AVBP)) << 16);
   \   0000002E   0x68CB             LDR      R3,[R1, #+12]
   \   00000030   0x68C4             LDR      R4,[R0, #+12]
   \   00000032   0x0564             LSLS     R4,R4,#+21
   \   00000034   0xEB13 0x5354      ADDS     R3,R3,R4, LSR #+21
   1120            LTDC_LAYER(hltdc, LayerIdx)->WVPCR &= ~(LTDC_LxWVPCR_WVSTPOS | LTDC_LxWVPCR_WVSPPOS);
   \   00000038   0x6894             LDR      R4,[R2, #+8]
   \   0000003A   0xF404 0x4470      AND      R4,R4,#0xF000
   \   0000003E   0x6094             STR      R4,[R2, #+8]
   1121            LTDC_LAYER(hltdc, LayerIdx)->WVPCR  = ((pLayerCfg->WindowY0 + (hltdc->Instance->BPCR & LTDC_BPCR_AVBP) + 1) | tmp);  
   \   00000040   0x688C             LDR      R4,[R1, #+8]
   \   00000042   0x68C0             LDR      R0,[R0, #+12]
   \   00000044   0x0540             LSLS     R0,R0,#+21
   \   00000046   0xEB14 0x5050      ADDS     R0,R4,R0, LSR #+21
   \   0000004A   0x1C40             ADDS     R0,R0,#+1
   \   0000004C   0xEA40 0x4003      ORR      R0,R0,R3, LSL #+16
   \   00000050   0x6090             STR      R0,[R2, #+8]
   1122          
   1123            /* Specifies the pixel format */
   1124            LTDC_LAYER(hltdc, LayerIdx)->PFCR &= ~(LTDC_LxPFCR_PF);
   \   00000052   0x6910             LDR      R0,[R2, #+16]
   \   00000054   0x08C0             LSRS     R0,R0,#+3
   \   00000056   0x00C0             LSLS     R0,R0,#+3
   \   00000058   0x6110             STR      R0,[R2, #+16]
   1125            LTDC_LAYER(hltdc, LayerIdx)->PFCR = (pLayerCfg->PixelFormat);
   \   0000005A   0x6908             LDR      R0,[R1, #+16]
   \   0000005C   0x6110             STR      R0,[R2, #+16]
   1126          
   1127            /* Configures the default color values */
   1128            tmp = ((uint32_t)(pLayerCfg->Backcolor.Green) << 8);
   \   0000005E   0xF101 0x0030      ADD      R0,R1,#+48
   1129            tmp1 = ((uint32_t)(pLayerCfg->Backcolor.Red) << 16);
   1130            tmp2 = (pLayerCfg->Alpha0 << 24);  
   \   00000062   0x698D             LDR      R5,[R1, #+24]
   \   00000064   0x7843             LDRB     R3,[R0, #+1]
   \   00000066   0x7884             LDRB     R4,[R0, #+2]
   1131            LTDC_LAYER(hltdc, LayerIdx)->DCCR &= ~(LTDC_LxDCCR_DCBLUE | LTDC_LxDCCR_DCGREEN | LTDC_LxDCCR_DCRED | LTDC_LxDCCR_DCALPHA);
   \   00000068   0x6996             LDR      R6,[R2, #+24]
   \   0000006A   0x2600             MOVS     R6,#+0
   \   0000006C   0x6196             STR      R6,[R2, #+24]
   1132            LTDC_LAYER(hltdc, LayerIdx)->DCCR = (pLayerCfg->Backcolor.Blue | tmp | tmp1 | tmp2); 
   \   0000006E   0x7800             LDRB     R0,[R0, #+0]
   \   00000070   0xEA40 0x2003      ORR      R0,R0,R3, LSL #+8
   1133          
   1134            /* Specifies the constant alpha value */
   1135            LTDC_LAYER(hltdc, LayerIdx)->CACR &= ~(LTDC_LxCACR_CONSTA);
   1136            LTDC_LAYER(hltdc, LayerIdx)->CACR = (pLayerCfg->Alpha);
   1137          
   1138            /* Specifies the blending factors */
   1139            LTDC_LAYER(hltdc, LayerIdx)->BFCR &= ~(LTDC_LxBFCR_BF2 | LTDC_LxBFCR_BF1);
   \   00000074   0x....             LDR.N    R3,??DataTable3_3  ;; 0xfffff8f8
   \   00000076   0xEA40 0x4004      ORR      R0,R0,R4, LSL #+16
   \   0000007A   0xEA40 0x6005      ORR      R0,R0,R5, LSL #+24
   \   0000007E   0x6190             STR      R0,[R2, #+24]
   \   00000080   0x6950             LDR      R0,[R2, #+20]
   \   00000082   0x0A00             LSRS     R0,R0,#+8
   \   00000084   0x0200             LSLS     R0,R0,#+8
   \   00000086   0x6150             STR      R0,[R2, #+20]
   \   00000088   0x6948             LDR      R0,[R1, #+20]
   \   0000008A   0x6150             STR      R0,[R2, #+20]
   \   0000008C   0x69D0             LDR      R0,[R2, #+28]
   \   0000008E   0x4018             ANDS     R0,R3,R0
   \   00000090   0x61D0             STR      R0,[R2, #+28]
   1140            LTDC_LAYER(hltdc, LayerIdx)->BFCR = (pLayerCfg->BlendingFactor1 | pLayerCfg->BlendingFactor2);
   \   00000092   0x69C8             LDR      R0,[R1, #+28]
   \   00000094   0x6A0B             LDR      R3,[R1, #+32]
   \   00000096   0x4318             ORRS     R0,R3,R0
   \   00000098   0x61D0             STR      R0,[R2, #+28]
   1141          
   1142            /* Configures the color frame buffer start address */
   1143            LTDC_LAYER(hltdc, LayerIdx)->CFBAR &= ~(LTDC_LxCFBAR_CFBADD);
   \   0000009A   0x6A90             LDR      R0,[R2, #+40]
   \   0000009C   0x6296             STR      R6,[R2, #+40]
   1144            LTDC_LAYER(hltdc, LayerIdx)->CFBAR = (pLayerCfg->FBStartAdress);
   \   0000009E   0x6A48             LDR      R0,[R1, #+36]
   \   000000A0   0x6290             STR      R0,[R2, #+40]
   1145          
   1146            if(pLayerCfg->PixelFormat == LTDC_PIXEL_FORMAT_ARGB8888)
   \   000000A2   0x6908             LDR      R0,[R1, #+16]
   \   000000A4   0xB908             CBNZ.N   R0,??LTDC_SetConfig_0
   1147            {
   1148              tmp = 4;
   \   000000A6   0x2004             MOVS     R0,#+4
   \   000000A8   0xE00E             B.N      ??LTDC_SetConfig_1
   1149            }
   1150            else if (pLayerCfg->PixelFormat == LTDC_PIXEL_FORMAT_RGB888)
   \                     ??LTDC_SetConfig_0: (+1)
   \   000000AA   0x2801             CMP      R0,#+1
   \   000000AC   0xBF08             IT       EQ 
   \   000000AE   0x2003             MOVEQ    R0,#+3
   1151            {
   1152              tmp = 3;
   \   000000B0   0xD00A             BEQ.N    ??LTDC_SetConfig_1
   1153            }
   1154            else if((pLayerCfg->PixelFormat == LTDC_PIXEL_FORMAT_ARGB4444) || \
   1155              (pLayerCfg->PixelFormat == LTDC_PIXEL_FORMAT_RGB565)   || \
   1156                (pLayerCfg->PixelFormat == LTDC_PIXEL_FORMAT_ARGB1555) || \
   1157                  (pLayerCfg->PixelFormat == LTDC_PIXEL_FORMAT_AL88))
   \   000000B2   0x2804             CMP      R0,#+4
   \   000000B4   0xBF18             IT       NE 
   \   000000B6   0x2802             CMPNE    R0,#+2
   \   000000B8   0xD003             BEQ.N    ??LTDC_SetConfig_2
   \   000000BA   0x2803             CMP      R0,#+3
   \   000000BC   0xBF18             IT       NE 
   \   000000BE   0x2807             CMPNE    R0,#+7
   \   000000C0   0xD101             BNE.N    ??LTDC_SetConfig_3
   1158            {
   1159              tmp = 2;
   \                     ??LTDC_SetConfig_2: (+1)
   \   000000C2   0x2002             MOVS     R0,#+2
   \   000000C4   0xE000             B.N      ??LTDC_SetConfig_1
   1160            }
   1161            else
   1162            {
   1163              tmp = 1;
   \                     ??LTDC_SetConfig_3: (+1)
   \   000000C6   0x2001             MOVS     R0,#+1
   1164            }
   1165          
   1166            /* Configures the color frame buffer pitch in byte */
   1167            LTDC_LAYER(hltdc, LayerIdx)->CFBLR  &= ~(LTDC_LxCFBLR_CFBLL | LTDC_LxCFBLR_CFBP);
   \                     ??LTDC_SetConfig_1: (+1)
   \   000000C8   0x6AD3             LDR      R3,[R2, #+44]
   \   000000CA   0xF003 0x23E0      AND      R3,R3,#0xE000E000
   \   000000CE   0x62D3             STR      R3,[R2, #+44]
   1168            LTDC_LAYER(hltdc, LayerIdx)->CFBLR  = (((pLayerCfg->ImageWidth * tmp) << 16) | (((pLayerCfg->WindowX1 - pLayerCfg->WindowX0) * tmp)  + 3));
   \   000000D0   0x6A8B             LDR      R3,[R1, #+40]
   \   000000D2   0x684C             LDR      R4,[R1, #+4]
   \   000000D4   0x680D             LDR      R5,[R1, #+0]
   \   000000D6   0x4343             MULS     R3,R0,R3
   \   000000D8   0x1B64             SUBS     R4,R4,R5
   \   000000DA   0x4360             MULS     R0,R0,R4
   \   000000DC   0x1CC0             ADDS     R0,R0,#+3
   \   000000DE   0xEA40 0x4003      ORR      R0,R0,R3, LSL #+16
   \   000000E2   0x62D0             STR      R0,[R2, #+44]
   1169          
   1170            /* Configures the frame buffer line number */
   1171            LTDC_LAYER(hltdc, LayerIdx)->CFBLNR  &= ~(LTDC_LxCFBLNR_CFBLNBR);
   \   000000E4   0x6B10             LDR      R0,[R2, #+48]
   \   000000E6   0x0AC0             LSRS     R0,R0,#+11
   \   000000E8   0x02C0             LSLS     R0,R0,#+11
   \   000000EA   0x6310             STR      R0,[R2, #+48]
   1172            LTDC_LAYER(hltdc, LayerIdx)->CFBLNR  = (pLayerCfg->ImageHeight);
   \   000000EC   0x6AC8             LDR      R0,[R1, #+44]
   \   000000EE   0x6310             STR      R0,[R2, #+48]
   1173          
   1174            /* Enable LTDC_Layer by setting LEN bit */  
   1175            LTDC_LAYER(hltdc, LayerIdx)->CR |= (uint32_t)LTDC_LxCR_LEN;
   \   000000F0   0x6810             LDR      R0,[R2, #+0]
   \   000000F2   0xF040 0x0001      ORR      R0,R0,#0x1
   \   000000F6   0x6010             STR      R0,[R2, #+0]
   1176          }
   \   000000F8   0xBC70             POP      {R4-R6}
   \   000000FA   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3:
   \   00000000   0xF000F800         DC32     0xf000f800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_1:
   \   00000000   0x40016818         DC32     0x40016818

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_2:
   \   00000000   0x40016840         DC32     0x40016840

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_3:
   \   00000000   0xFFFFF8F8         DC32     0xfffff8f8
   1177          
   1178          /**
   1179            * @}
   1180            */
   1181          
   1182          #endif /* HAL_LTDC_MODULE_ENABLED */
   1183          
   1184          /**
   1185            * @}
   1186            */
   1187          #endif /* STM32F756xx || STM32F746xx */
   1188          
   1189          /**
   1190            * @}
   1191            */
   1192          
   1193          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   HAL_LTDC_ConfigCLUT
       8   HAL_LTDC_ConfigColorKeying
      24   HAL_LTDC_ConfigLayer
        24   -> LTDC_SetConfig
        24   -> __aeabi_memcpy4
       8   HAL_LTDC_DeInit
         8   -> HAL_LTDC_MspDeInit
       0   HAL_LTDC_DisableCLUT
       0   HAL_LTDC_DisableColorKeying
       0   HAL_LTDC_DisableDither
       0   HAL_LTDC_EnableCLUT
       0   HAL_LTDC_EnableColorKeying
       0   HAL_LTDC_EnableDither
       0   HAL_LTDC_ErrorCallback
       0   HAL_LTDC_GetError
       0   HAL_LTDC_GetState
       8   HAL_LTDC_IRQHandler
         8   -> HAL_LTDC_ErrorCallback
         8   -> HAL_LTDC_LineEventCallback
      16   HAL_LTDC_Init
        16   -> HAL_LTDC_MspInit
       0   HAL_LTDC_LineEventCallback
       0   HAL_LTDC_MspDeInit
       0   HAL_LTDC_MspInit
       0   HAL_LTDC_ProgramLineEvent
      16   HAL_LTDC_SetAddress
        16   -> LTDC_SetConfig
      16   HAL_LTDC_SetAlpha
        16   -> LTDC_SetConfig
      16   HAL_LTDC_SetPixelFormat
        16   -> LTDC_SetConfig
      16   HAL_LTDC_SetWindowPosition
        16   -> LTDC_SetConfig
      16   HAL_LTDC_SetWindowSize
        16   -> LTDC_SetConfig
      12   LTDC_SetConfig


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable3
       4  ??DataTable3_1
       4  ??DataTable3_2
       4  ??DataTable3_3
      20  ?Subroutine0
      16  ?Subroutine1
      14  ?Subroutine2
      22  ?Subroutine3
      98  HAL_LTDC_ConfigCLUT
      66  HAL_LTDC_ConfigColorKeying
      68  HAL_LTDC_ConfigLayer
      24  HAL_LTDC_DeInit
      38  HAL_LTDC_DisableCLUT
      36  HAL_LTDC_DisableColorKeying
      28  HAL_LTDC_DisableDither
      38  HAL_LTDC_EnableCLUT
      38  HAL_LTDC_EnableColorKeying
      30  HAL_LTDC_EnableDither
       2  HAL_LTDC_ErrorCallback
       6  HAL_LTDC_GetError
       6  HAL_LTDC_GetState
     160  HAL_LTDC_IRQHandler
     240  HAL_LTDC_Init
       2  HAL_LTDC_LineEventCallback
       2  HAL_LTDC_MspDeInit
       2  HAL_LTDC_MspInit
      46  HAL_LTDC_ProgramLineEvent
      38  HAL_LTDC_SetAddress
      36  HAL_LTDC_SetAlpha
      38  HAL_LTDC_SetPixelFormat
      54  HAL_LTDC_SetWindowPosition
      54  HAL_LTDC_SetWindowSize
     252  LTDC_SetConfig

 
 1 490 bytes in section .text
 
 1 490 bytes of CODE memory

Errors: none
Warnings: none
