###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.2.10312/W32 for ARM       22/Feb/2016  17:57:54
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_spi.c
#    Command line =  
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_spi.c
#        -D USE_HAL_DRIVER -D STM32F746xx -D USE_STM32746G_DISCO -D
#        USE_IOEXPANDER -D USE_USB_FS -lC
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
#        -lA
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
#        -o
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj
#        --no_unroll --debug --endian=little --cpu=Cortex-M7 -e --fpu=VFPv5_sp
#        --dlib_config "D:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Full.h" -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\CMSIS\Device\ST\STM32F7xx\Include\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\STM32F7xx_HAL_Driver\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\STM32746G-Discovery\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\Components\Common\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Log\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Fonts\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\CPU\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_Device_Library\Core\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Core\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Class\MSC\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\drivers\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_Audio\Addons\PDM\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_Device_Library\Class\AUDIO\Inc\
#        -Ohs --use_c++_inline --require_prototypes -I "D:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.3\arm\CMSIS\Include\" -D
#        ARM_MATH_CM7
#    List file    =  
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List\stm32f7xx_hal_spi.lst
#    Object file  =  
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj\stm32f7xx_hal_spi.o
#
###############################################################################

D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_spi.c
      1          /**
                   ^
Warning[Pa050]: non-native end of line sequence detected (this diagnostic is
          only issued once)
      2            ******************************************************************************
      3            * @file    stm32f7xx_hal_spi.c
      4            * @author  MCD Application Team
      5            * @version V1.0.1
      6            * @date    25-June-2015
      7            * @brief   SPI HAL module driver.
      8            *          This file provides firmware functions to manage the following 
      9            *          functionalities of the Serial Peripheral Interface (SPI) peripheral:
     10            *           + Initialization and de-initialization functions
     11            *           + IO operation functions
     12            *           + Peripheral Control functions 
     13            *           + Peripheral State functions
     14            @verbatim
     15            ==============================================================================
     16                                  ##### How to use this driver #####
     17            ==============================================================================
     18              [..]
     19                The SPI HAL driver can be used as follows:
     20          
     21                (#) Declare a SPI_HandleTypeDef handle structure, for example:
     22                    SPI_HandleTypeDef  hspi;
     23          
     24                (#)Initialize the SPI low level resources by implementing the HAL_SPI_MspInit ()API:
     25                    (##) Enable the SPIx interface clock
     26                    (##) SPI pins configuration
     27                        (+++) Enable the clock for the SPI GPIOs
     28                        (+++) Configure these SPI pins as alternate function push-pull
     29                    (##) NVIC configuration if you need to use interrupt process
     30                        (+++) Configure the SPIx interrupt priority
     31                        (+++) Enable the NVIC SPI IRQ handle
     32                    (##) DMA Configuration if you need to use DMA process
     33                        (+++) Declare a DMA_HandleTypeDef handle structure for the transmit or receive channel
     34                        (+++) Enable the DMAx clock
     35                        (+++) Configure the DMA handle parameters
     36                        (+++) Configure the DMA Tx or Rx channel
     37                        (+++) Associate the initialized hdma_tx handle to the hspi DMA Tx or Rx handle
     38                        (+++) Configure the priority and enable the NVIC for the transfer complete interrupt on the DMA Tx or Rx channel
     39          
     40                (#) Program the Mode, BidirectionalMode , Data size, Baudrate Prescaler, NSS
     41                    management, Clock polarity and phase, FirstBit and CRC configuration in the hspi Init structure.
     42          
     43                (#) Initialize the SPI registers by calling the HAL_SPI_Init() API:
     44                    (++) This API configures also the low level Hardware GPIO, CLOCK, CORTEX...etc)
     45                        by calling the customised HAL_SPI_MspInit() API.
     46               [..]
     47                 Circular mode restriction:
     48                (#) The DMA circular mode cannot be used when the SPI is configured in these modes:
     49                    (##) Master 2Lines RxOnly
     50                    (##) Master 1Line Rx
     51                (#) The CRC feature is not managed when the DMA circular mode is enabled
     52                (#) When the SPI DMA Pause/Stop features are used, we must use the following APIs
     53                    the HAL_SPI_DMAPause()/ HAL_SPI_DMAStop() only under the SPI callbacks
     54          
     55            @endverbatim
     56            ******************************************************************************
     57            * @attention
     58            *
     59            * <h2><center>&copy; COPYRIGHT(c) 2015 STMicroelectronics</center></h2>
     60            *
     61            * Redistribution and use in source and binary forms, with or without modification,
     62            * are permitted provided that the following conditions are met:
     63            *   1. Redistributions of source code must retain the above copyright notice,
     64            *      this list of conditions and the following disclaimer.
     65            *   2. Redistributions in binary form must reproduce the above copyright notice,
     66            *      this list of conditions and the following disclaimer in the documentation
     67            *      and/or other materials provided with the distribution.
     68            *   3. Neither the name of STMicroelectronics nor the names of its contributors
     69            *      may be used to endorse or promote products derived from this software
     70            *      without specific prior written permission.
     71            *
     72            * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
     73            * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     74            * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     75            * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
     76            * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
     77            * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
     78            * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
     79            * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
     80            * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
     81            * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     82            *
     83            ******************************************************************************
     84            */
     85              
     86          /* Includes ------------------------------------------------------------------*/
     87          #include "stm32f7xx_hal.h"
     88             
     89          /** @addtogroup STM32F7xx_HAL_Driver
     90            * @{
     91            */
     92          
     93          /** @defgroup SPI SPI 
     94            * @brief SPI HAL module driver
     95            * @{
     96            */
     97          #ifdef HAL_SPI_MODULE_ENABLED
     98          
     99          /* Private typedef -----------------------------------------------------------*/
    100          /* Private defines -----------------------------------------------------------*/
    101          /** @defgroup SPI_Private_Constants SPI Private Constants
    102            * @{
    103            */
    104          #define SPI_DEFAULT_TIMEOUT 50
    105          /**
    106            * @}
    107            */
    108          
    109          /* Private macro -------------------------------------------------------------*/
    110          /* Private variables ---------------------------------------------------------*/
    111          /* Private function prototypes -----------------------------------------------*/
    112          /** @addtogroup SPI_Private_Functions
    113            * @{
    114            */
    115          static void SPI_DMATransmitCplt(DMA_HandleTypeDef *hdma);
    116          static void SPI_DMAReceiveCplt(DMA_HandleTypeDef *hdma);
    117          static void SPI_DMATransmitReceiveCplt(DMA_HandleTypeDef *hdma);
    118          static void SPI_DMAHalfTransmitCplt(DMA_HandleTypeDef *hdma);
    119          static void SPI_DMAHalfReceiveCplt(DMA_HandleTypeDef *hdma);
    120          static void SPI_DMAHalfTransmitReceiveCplt(DMA_HandleTypeDef *hdma);
    121          static void SPI_DMAError(DMA_HandleTypeDef *hdma);
    122          static HAL_StatusTypeDef SPI_WaitFlagStateUntilTimeout(SPI_HandleTypeDef *hspi, uint32_t Flag, uint32_t State, uint32_t Timeout);
    123          static HAL_StatusTypeDef SPI_WaitFifoStateUntilTimeout(SPI_HandleTypeDef *hspi, uint32_t Fifo, uint32_t State, uint32_t Timeout);
    124          static void SPI_TxISR_8BIT(struct __SPI_HandleTypeDef *hspi);
    125          static void SPI_TxISR_16BIT(struct __SPI_HandleTypeDef *hspi);
    126          static void SPI_RxISR_8BIT(struct __SPI_HandleTypeDef *hspi);
    127          static void SPI_RxISR_8BITCRC(struct __SPI_HandleTypeDef *hspi);
    128          static void SPI_RxISR_16BIT(struct __SPI_HandleTypeDef *hspi);
    129          static void SPI_RxISR_16BITCRC(struct __SPI_HandleTypeDef *hspi);
    130          static void SPI_2linesRxISR_8BIT(struct __SPI_HandleTypeDef *hspi);
    131          static void SPI_2linesRxISR_8BITCRC(struct __SPI_HandleTypeDef *hspi);
    132          static void SPI_2linesTxISR_8BIT(struct __SPI_HandleTypeDef *hspi);
    133          static void SPI_2linesTxISR_16BIT(struct __SPI_HandleTypeDef *hspi);
    134          static void SPI_2linesRxISR_16BIT(struct __SPI_HandleTypeDef *hspi);
    135          static void SPI_2linesRxISR_16BITCRC(struct __SPI_HandleTypeDef *hspi);
    136          static void SPI_CloseRxTx_ISR(SPI_HandleTypeDef *hspi);
    137          static void SPI_CloseRx_ISR(SPI_HandleTypeDef *hspi);
    138          static void SPI_CloseTx_ISR(SPI_HandleTypeDef *hspi);
    139          static HAL_StatusTypeDef SPI_EndRxTransaction(SPI_HandleTypeDef *hspi, uint32_t Timeout);
    140          static HAL_StatusTypeDef SPI_EndRxTxTransaction(SPI_HandleTypeDef *hspi, uint32_t Timeout);
    141          /**
    142            * @}
    143            */
    144          
    145          /* Exported functions ---------------------------------------------------------*/
    146          
    147          /** @defgroup SPI_Exported_Functions SPI Exported Functions
    148            * @{
    149            */
    150          
    151          /** @defgroup SPI_Exported_Functions_Group1 Initialization and de-initialization functions
    152           *  @brief    Initialization and Configuration functions
    153           *
    154          @verbatim
    155           ===============================================================================
    156                        ##### Initialization and de-initialization functions #####
    157           ===============================================================================
    158              [..]  This subsection provides a set of functions allowing to initialize and
    159                    de-initialize the SPIx peripheral:
    160          
    161                (+) User must implement HAL_SPI_MspInit() function in which he configures
    162                    all related peripherals resources (CLOCK, GPIO, DMA, IT and NVIC ).
    163          
    164                (+) Call the function HAL_SPI_Init() to configure the selected device with
    165                    the selected configuration:
    166                  (++) Mode
    167                  (++) Direction
    168                  (++) Data Size
    169                  (++) Clock Polarity and Phase
    170                  (++) NSS Management
    171                  (++) BaudRate Prescaler
    172                  (++) FirstBit
    173                  (++) TIMode
    174                  (++) CRC Calculation
    175                  (++) CRC Polynomial if CRC enabled
    176                  (++) CRC Length, used only with Data8 and Data16
    177                  (++) FIFO reception threshold
    178          
    179                (+) Call the function HAL_SPI_DeInit() to restore the default configuration
    180                    of the selected SPIx peripheral.
    181          
    182          @endverbatim
    183            * @{
    184            */
    185          
    186          /**
    187            * @brief  Initializes the SPI according to the specified parameters
    188            *         in the SPI_InitTypeDef and create the associated handle.
    189            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
    190            *               the configuration information for SPI module.
    191            * @retval HAL status
    192            */

   \                                 In section .text, align 2, keep-with-next
    193          HAL_StatusTypeDef HAL_SPI_Init(SPI_HandleTypeDef *hspi)
    194          {
   \                     HAL_SPI_Init: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0xB081             SUB      SP,SP,#+4
    195            uint32_t frxth;
    196          
    197            /* Check the SPI handle allocation */
    198            if(hspi == NULL)
   \   00000006   0xBF08             IT       EQ 
   \   00000008   0x2001             MOVEQ    R0,#+1
    199            {
    200              return HAL_ERROR;
   \   0000000A   0xD054             BEQ.N    ??HAL_SPI_Init_0
    201            }
    202          
    203            /* Check the parameters */
    204            assert_param(IS_SPI_ALL_INSTANCE(hspi->Instance));
    205            assert_param(IS_SPI_MODE(hspi->Init.Mode));
    206            assert_param(IS_SPI_DIRECTION(hspi->Init.Direction));
    207            assert_param(IS_SPI_DATASIZE(hspi->Init.DataSize));
    208            assert_param(IS_SPI_CPOL(hspi->Init.CLKPolarity));
    209            assert_param(IS_SPI_CPHA(hspi->Init.CLKPhase));
    210            assert_param(IS_SPI_NSS(hspi->Init.NSS));
    211            assert_param(IS_SPI_NSSP(hspi->Init.NSSPMode));
    212            assert_param(IS_SPI_BAUDRATE_PRESCALER(hspi->Init.BaudRatePrescaler));
    213            assert_param(IS_SPI_FIRST_BIT(hspi->Init.FirstBit));
    214            assert_param(IS_SPI_TIMODE(hspi->Init.TIMode));
    215            assert_param(IS_SPI_CRC_CALCULATION(hspi->Init.CRCCalculation));
    216            assert_param(IS_SPI_CRC_POLYNOMIAL(hspi->Init.CRCPolynomial));
    217            assert_param(IS_SPI_CRC_LENGTH(hspi->Init.CRCLength));
    218          
    219            if(hspi->State == HAL_SPI_STATE_RESET)
   \   0000000C   0xF894 0x005D      LDRB     R0,[R4, #+93]
   \   00000010   0xB920             CBNZ.N   R0,??HAL_SPI_Init_1
    220            {
    221              /* Allocate lock resource and initialize it */
    222              hspi->Lock = HAL_UNLOCKED;
   \   00000012   0xF884 0x005C      STRB     R0,[R4, #+92]
    223          
    224              /* Init the low level hardware : GPIO, CLOCK, NVIC... */
    225              HAL_SPI_MspInit(hspi);
   \   00000016   0x4620             MOV      R0,R4
   \   00000018   0x.... 0x....      BL       HAL_SPI_MspInit
    226            }
    227          
    228            hspi->State = HAL_SPI_STATE_BUSY;
   \                     ??HAL_SPI_Init_1: (+1)
   \   0000001C   0x2002             MOVS     R0,#+2
    229          
    230            /* Disable the selected SPI peripheral */
    231            __HAL_SPI_DISABLE(hspi);
    232          
    233            /* Align by default the rs fifo threshold on the data size */
    234            if(hspi->Init.DataSize > SPI_DATASIZE_8BIT)
   \   0000001E   0xF240 0x7301      MOVW     R3,#+1793
   \   00000022   0xF884 0x005D      STRB     R0,[R4, #+93]
   \   00000026   0x6820             LDR      R0,[R4, #+0]
   \   00000028   0x6801             LDR      R1,[R0, #+0]
   \   0000002A   0xF021 0x0140      BIC      R1,R1,#0x40
   \   0000002E   0x6001             STR      R1,[R0, #+0]
   \   00000030   0x68E2             LDR      R2,[R4, #+12]
   \   00000032   0x429A             CMP      R2,R3
   \   00000034   0xD304             BCC.N    ??HAL_SPI_Init_2
    235            {
    236              frxth = SPI_RXFIFO_THRESHOLD_HF;
   \   00000036   0x2100             MOVS     R1,#+0
    237            }
    238            else
    239            {
    240              frxth = SPI_RXFIFO_THRESHOLD_QF;
    241            }
    242          
    243            /* CRC calculation is valid only for 16Bit and 8 Bit */
    244            if(( hspi->Init.DataSize != SPI_DATASIZE_16BIT ) && ( hspi->Init.DataSize != SPI_DATASIZE_8BIT ))
   \   00000038   0xF5B2 0x6F70      CMP      R2,#+3840
   \   0000003C   0xD105             BNE.N    ??HAL_SPI_Init_3
   \   0000003E   0xE006             B.N      ??HAL_SPI_Init_4
   \                     ??HAL_SPI_Init_2: (+1)
   \   00000040   0xF5B2 0x6FE0      CMP      R2,#+1792
   \   00000044   0xF44F 0x5180      MOV      R1,#+4096
   \   00000048   0xD001             BEQ.N    ??HAL_SPI_Init_4
    245            {
    246              /* CRC must be disabled */
    247              hspi->Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
   \                     ??HAL_SPI_Init_3: (+1)
   \   0000004A   0x2500             MOVS     R5,#+0
   \   0000004C   0x62A5             STR      R5,[R4, #+40]
    248            }
    249          
    250            /* Align the CRC Length on the data size */
    251            if( hspi->Init.CRCLength == SPI_CRC_LENGTH_DATASIZE)
   \                     ??HAL_SPI_Init_4: (+1)
   \   0000004E   0x6B25             LDR      R5,[R4, #+48]
   \   00000050   0xB925             CBNZ.N   R5,??HAL_SPI_Init_5
    252            {
    253              /* CRC Length aligned on the data size : value set by default */
    254              if(hspi->Init.DataSize > SPI_DATASIZE_8BIT)
   \   00000052   0x429A             CMP      R2,R3
   \   00000054   0xBF2C             ITE      CS 
   \   00000056   0x2202             MOVCS    R2,#+2
   \   00000058   0x2201             MOVCC    R2,#+1
    255              {
    256                hspi->Init.CRCLength = SPI_CRC_LENGTH_16BIT;
    257              }
    258              else
    259              {
    260                hspi->Init.CRCLength = SPI_CRC_LENGTH_8BIT;
   \   0000005A   0x6322             STR      R2,[R4, #+48]
    261              }
    262            }
    263          
    264            /*---------------------------- SPIx CR1 & CR2 Configuration ------------------------*/
    265            /* Configure : SPI Mode, Communication Mode, Clock polarity and phase, NSS management,
    266            Communication speed, First bit, CRC calculation state, CRC Length */
    267            hspi->Instance->CR1 = (hspi->Init.Mode | hspi->Init.Direction |
    268                                   hspi->Init.CLKPolarity | hspi->Init.CLKPhase | (hspi->Init.NSS & SPI_CR1_SSM) |
    269                                   hspi->Init.BaudRatePrescaler | hspi->Init.FirstBit  | hspi->Init.CRCCalculation);
   \                     ??HAL_SPI_Init_5: (+1)
   \   0000005C   0x6862             LDR      R2,[R4, #+4]
   \   0000005E   0x68A3             LDR      R3,[R4, #+8]
   \   00000060   0x431A             ORRS     R2,R3,R2
   \   00000062   0x6923             LDR      R3,[R4, #+16]
   \   00000064   0x431A             ORRS     R2,R3,R2
   \   00000066   0x6963             LDR      R3,[R4, #+20]
   \   00000068   0x431A             ORRS     R2,R3,R2
   \   0000006A   0x69A3             LDR      R3,[R4, #+24]
   \   0000006C   0xF403 0x7300      AND      R3,R3,#0x200
   \   00000070   0x431A             ORRS     R2,R3,R2
   \   00000072   0x69E3             LDR      R3,[R4, #+28]
   \   00000074   0x431A             ORRS     R2,R3,R2
   \   00000076   0x6A23             LDR      R3,[R4, #+32]
   \   00000078   0x431A             ORRS     R2,R3,R2
   \   0000007A   0x6AA3             LDR      R3,[R4, #+40]
   \   0000007C   0x431A             ORRS     R2,R3,R2
   \   0000007E   0x6002             STR      R2,[R0, #+0]
    270          
    271            if( hspi->Init.CRCLength == SPI_CRC_LENGTH_16BIT)
   \   00000080   0x6B22             LDR      R2,[R4, #+48]
   \   00000082   0x2A02             CMP      R2,#+2
   \   00000084   0xD103             BNE.N    ??HAL_SPI_Init_6
    272            {
    273              hspi->Instance->CR1|= SPI_CR1_CRCL;
   \   00000086   0x6802             LDR      R2,[R0, #+0]
   \   00000088   0xF442 0x6200      ORR      R2,R2,#0x800
   \   0000008C   0x6002             STR      R2,[R0, #+0]
    274            }
    275          
    276            /* Configure : NSS management */
    277            /* Configure : Rx Fifo Threshold */
    278            hspi->Instance->CR2 = (((hspi->Init.NSS >> 16) & SPI_CR2_SSOE) | hspi->Init.TIMode | hspi->Init.NSSPMode |
    279                                   hspi->Init.DataSize ) | frxth;
   \                     ??HAL_SPI_Init_6: (+1)
   \   0000008E   0x69A2             LDR      R2,[R4, #+24]
   \   00000090   0x6A63             LDR      R3,[R4, #+36]
   \   00000092   0x0C12             LSRS     R2,R2,#+16
   \   00000094   0xF002 0x0204      AND      R2,R2,#0x4
   \   00000098   0x431A             ORRS     R2,R3,R2
   \   0000009A   0x6B63             LDR      R3,[R4, #+52]
   \   0000009C   0x431A             ORRS     R2,R3,R2
   \   0000009E   0x68E3             LDR      R3,[R4, #+12]
   \   000000A0   0x431A             ORRS     R2,R3,R2
   \   000000A2   0x4311             ORRS     R1,R1,R2
   \   000000A4   0x6041             STR      R1,[R0, #+4]
    280          
    281            /*---------------------------- SPIx CRCPOLY Configuration --------------------*/
    282            /* Configure : CRC Polynomial */
    283            hspi->Instance->CRCPR = hspi->Init.CRCPolynomial;
   \   000000A6   0x6AE1             LDR      R1,[R4, #+44]
   \   000000A8   0x6101             STR      R1,[R0, #+16]
    284          
    285            hspi->ErrorCode = HAL_SPI_ERROR_NONE;
   \   000000AA   0x2000             MOVS     R0,#+0
   \   000000AC   0x6620             STR      R0,[R4, #+96]
    286            hspi->State= HAL_SPI_STATE_READY;
   \   000000AE   0x2001             MOVS     R0,#+1
   \   000000B0   0xF884 0x005D      STRB     R0,[R4, #+93]
    287          
    288            return HAL_OK;
   \   000000B4   0x2000             MOVS     R0,#+0
   \                     ??HAL_SPI_Init_0: (+1)
   \   000000B6   0xB001             ADD      SP,SP,#+4
   \   000000B8   0xBD30             POP      {R4,R5,PC}       ;; return
    289          }
    290          
    291          /**
    292            * @brief  DeInitializes the SPI peripheral
    293            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
    294            *               the configuration information for SPI module.
    295            * @retval HAL status
    296            */

   \                                 In section .text, align 2, keep-with-next
    297          HAL_StatusTypeDef HAL_SPI_DeInit(SPI_HandleTypeDef *hspi)
    298          {
   \                     HAL_SPI_DeInit: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0xB081             SUB      SP,SP,#+4
    299            /* Check the SPI handle allocation */
    300            if(hspi == NULL)
   \   00000006   0xBF08             IT       EQ 
   \   00000008   0x2001             MOVEQ    R0,#+1
    301            {
    302              return HAL_ERROR;
   \   0000000A   0xF000 0x80B1      BEQ.W    ??HAL_SPI_DeInit_0
    303            }
    304          
    305            /* Check the parameters */
    306            assert_param(IS_SPI_ALL_INSTANCE(hspi->Instance));
    307          
    308            hspi->State = HAL_SPI_STATE_BUSY;
   \   0000000E   0x2002             MOVS     R0,#+2
   \   00000010   0xF884 0x005D      STRB     R0,[R4, #+93]
    309          
    310            /* check flag before the SPI disable */
    311            SPI_WaitFifoStateUntilTimeout(hspi, SPI_FLAG_FTLVL, SPI_FTLVL_EMPTY, SPI_DEFAULT_TIMEOUT);
   \   00000014   0x.... 0x....      BL       HAL_GetTick
   \   00000018   0x4605             MOV      R5,R0
   \                     ??HAL_SPI_DeInit_1: (+1)
   \   0000001A   0x6820             LDR      R0,[R4, #+0]
   \   0000001C   0x6880             LDR      R0,[R0, #+8]
   \   0000001E   0xF410 0x5FC0      TST      R0,#0x1800
   \   00000022   0xD02B             BEQ.N    ??HAL_SPI_DeInit_2
   \   00000024   0x.... 0x....      BL       HAL_GetTick
   \   00000028   0x1B40             SUBS     R0,R0,R5
   \   0000002A   0x2832             CMP      R0,#+50
   \   0000002C   0xD3F5             BCC.N    ??HAL_SPI_DeInit_1
   \   0000002E   0x6820             LDR      R0,[R4, #+0]
   \   00000030   0x6841             LDR      R1,[R0, #+4]
   \   00000032   0xF021 0x01E0      BIC      R1,R1,#0xE0
   \   00000036   0x6041             STR      R1,[R0, #+4]
   \   00000038   0x6861             LDR      R1,[R4, #+4]
   \   0000003A   0xF5B1 0x7F82      CMP      R1,#+260
   \   0000003E   0xD10A             BNE.N    ??HAL_SPI_DeInit_3
   \   00000040   0x68A1             LDR      R1,[R4, #+8]
   \   00000042   0xF5B1 0x4F00      CMP      R1,#+32768
   \   00000046   0xBF18             IT       NE 
   \   00000048   0xF5B1 0x6F80      CMPNE    R1,#+1024
   \   0000004C   0xD103             BNE.N    ??HAL_SPI_DeInit_3
   \   0000004E   0x6801             LDR      R1,[R0, #+0]
   \   00000050   0xF021 0x0140      BIC      R1,R1,#0x40
   \   00000054   0x6001             STR      R1,[R0, #+0]
   \                     ??HAL_SPI_DeInit_3: (+1)
   \   00000056   0x6AA1             LDR      R1,[R4, #+40]
   \   00000058   0xF5B1 0x5F00      CMP      R1,#+8192
   \   0000005C   0xD108             BNE.N    ??HAL_SPI_DeInit_4
   \   0000005E   0x6801             LDR      R1,[R0, #+0]
   \   00000060   0xF64D 0x72FF      MOVW     R2,#+57343
   \   00000064   0x4011             ANDS     R1,R2,R1
   \   00000066   0x6001             STR      R1,[R0, #+0]
   \   00000068   0x6801             LDR      R1,[R0, #+0]
   \   0000006A   0xF441 0x5100      ORR      R1,R1,#0x2000
   \   0000006E   0x6001             STR      R1,[R0, #+0]
   \                     ??HAL_SPI_DeInit_4: (+1)
   \   00000070   0x2001             MOVS     R0,#+1
   \   00000072   0xF884 0x005D      STRB     R0,[R4, #+93]
   \   00000076   0x2000             MOVS     R0,#+0
   \   00000078   0xF884 0x005C      STRB     R0,[R4, #+92]
    312            SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_BSY, RESET, SPI_DEFAULT_TIMEOUT);
   \                     ??HAL_SPI_DeInit_2: (+1)
   \   0000007C   0x.... 0x....      BL       HAL_GetTick
   \   00000080   0x4605             MOV      R5,R0
   \                     ??HAL_SPI_DeInit_5: (+1)
   \   00000082   0x6820             LDR      R0,[R4, #+0]
   \   00000084   0x6880             LDR      R0,[R0, #+8]
   \   00000086   0x0600             LSLS     R0,R0,#+24
   \   00000088   0xD52B             BPL.N    ??HAL_SPI_DeInit_6
   \   0000008A   0x.... 0x....      BL       HAL_GetTick
   \   0000008E   0x1B40             SUBS     R0,R0,R5
   \   00000090   0x2832             CMP      R0,#+50
   \   00000092   0xD3F6             BCC.N    ??HAL_SPI_DeInit_5
   \   00000094   0x6820             LDR      R0,[R4, #+0]
   \   00000096   0x6841             LDR      R1,[R0, #+4]
   \   00000098   0xF021 0x01E0      BIC      R1,R1,#0xE0
   \   0000009C   0x6041             STR      R1,[R0, #+4]
   \   0000009E   0x6861             LDR      R1,[R4, #+4]
   \   000000A0   0xF5B1 0x7F82      CMP      R1,#+260
   \   000000A4   0xD10A             BNE.N    ??HAL_SPI_DeInit_7
   \   000000A6   0x68A1             LDR      R1,[R4, #+8]
   \   000000A8   0xF5B1 0x4F00      CMP      R1,#+32768
   \   000000AC   0xBF18             IT       NE 
   \   000000AE   0xF5B1 0x6F80      CMPNE    R1,#+1024
   \   000000B2   0xD103             BNE.N    ??HAL_SPI_DeInit_7
   \   000000B4   0x6801             LDR      R1,[R0, #+0]
   \   000000B6   0xF021 0x0140      BIC      R1,R1,#0x40
   \   000000BA   0x6001             STR      R1,[R0, #+0]
   \                     ??HAL_SPI_DeInit_7: (+1)
   \   000000BC   0x6AA1             LDR      R1,[R4, #+40]
   \   000000BE   0xF5B1 0x5F00      CMP      R1,#+8192
   \   000000C2   0xD108             BNE.N    ??HAL_SPI_DeInit_8
   \   000000C4   0x6801             LDR      R1,[R0, #+0]
   \   000000C6   0xF64D 0x72FF      MOVW     R2,#+57343
   \   000000CA   0x4011             ANDS     R1,R2,R1
   \   000000CC   0x6001             STR      R1,[R0, #+0]
   \   000000CE   0x6801             LDR      R1,[R0, #+0]
   \   000000D0   0xF441 0x5100      ORR      R1,R1,#0x2000
   \   000000D4   0x6001             STR      R1,[R0, #+0]
   \                     ??HAL_SPI_DeInit_8: (+1)
   \   000000D6   0x2001             MOVS     R0,#+1
   \   000000D8   0xF884 0x005D      STRB     R0,[R4, #+93]
   \   000000DC   0x2000             MOVS     R0,#+0
   \   000000DE   0xF884 0x005C      STRB     R0,[R4, #+92]
    313            SPI_WaitFifoStateUntilTimeout(hspi, SPI_FLAG_FRLVL, SPI_FRLVL_EMPTY, SPI_DEFAULT_TIMEOUT);
   \                     ??HAL_SPI_DeInit_6: (+1)
   \   000000E2   0x.... 0x....      BL       HAL_GetTick
   \   000000E6   0x4605             MOV      R5,R0
   \                     ??HAL_SPI_DeInit_9: (+1)
   \   000000E8   0x6820             LDR      R0,[R4, #+0]
   \   000000EA   0x6881             LDR      R1,[R0, #+8]
   \   000000EC   0xF411 0x6FC0      TST      R1,#0x600
   \   000000F0   0xD030             BEQ.N    ??HAL_SPI_DeInit_10
   \   000000F2   0x7B00             LDRB     R0,[R0, #+12]
   \   000000F4   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \   000000F8   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   000000FC   0x.... 0x....      BL       HAL_GetTick
   \   00000100   0x1B40             SUBS     R0,R0,R5
   \   00000102   0x2832             CMP      R0,#+50
   \   00000104   0xD3F0             BCC.N    ??HAL_SPI_DeInit_9
   \   00000106   0x6820             LDR      R0,[R4, #+0]
   \   00000108   0x6841             LDR      R1,[R0, #+4]
   \   0000010A   0xF021 0x01E0      BIC      R1,R1,#0xE0
   \   0000010E   0x6041             STR      R1,[R0, #+4]
   \   00000110   0x6861             LDR      R1,[R4, #+4]
   \   00000112   0xF5B1 0x7F82      CMP      R1,#+260
   \   00000116   0xD10A             BNE.N    ??HAL_SPI_DeInit_11
   \   00000118   0x68A1             LDR      R1,[R4, #+8]
   \   0000011A   0xF5B1 0x4F00      CMP      R1,#+32768
   \   0000011E   0xBF18             IT       NE 
   \   00000120   0xF5B1 0x6F80      CMPNE    R1,#+1024
   \   00000124   0xD103             BNE.N    ??HAL_SPI_DeInit_11
   \   00000126   0x6801             LDR      R1,[R0, #+0]
   \   00000128   0xF021 0x0140      BIC      R1,R1,#0x40
   \   0000012C   0x6001             STR      R1,[R0, #+0]
   \                     ??HAL_SPI_DeInit_11: (+1)
   \   0000012E   0x6AA1             LDR      R1,[R4, #+40]
   \   00000130   0xF5B1 0x5F00      CMP      R1,#+8192
   \   00000134   0xD108             BNE.N    ??HAL_SPI_DeInit_12
   \   00000136   0x6801             LDR      R1,[R0, #+0]
   \   00000138   0xF64D 0x72FF      MOVW     R2,#+57343
   \   0000013C   0x4011             ANDS     R1,R2,R1
   \   0000013E   0x6001             STR      R1,[R0, #+0]
   \   00000140   0x6801             LDR      R1,[R0, #+0]
   \   00000142   0xF441 0x5100      ORR      R1,R1,#0x2000
   \   00000146   0x6001             STR      R1,[R0, #+0]
   \                     ??HAL_SPI_DeInit_12: (+1)
   \   00000148   0x2001             MOVS     R0,#+1
   \   0000014A   0xF884 0x005D      STRB     R0,[R4, #+93]
   \   0000014E   0x2000             MOVS     R0,#+0
   \   00000150   0xF884 0x005C      STRB     R0,[R4, #+92]
    314          
    315            /* Disable the SPI Peripheral Clock */
    316            __HAL_SPI_DISABLE(hspi);
   \                     ??HAL_SPI_DeInit_10: (+1)
   \   00000154   0x6820             LDR      R0,[R4, #+0]
   \   00000156   0x6801             LDR      R1,[R0, #+0]
   \   00000158   0xF021 0x0140      BIC      R1,R1,#0x40
   \   0000015C   0x6001             STR      R1,[R0, #+0]
    317          
    318            /* DeInit the low level hardware: GPIO, CLOCK, NVIC... */
    319            HAL_SPI_MspDeInit(hspi);
   \   0000015E   0x4620             MOV      R0,R4
   \   00000160   0x.... 0x....      BL       HAL_SPI_MspDeInit
    320          
    321            hspi->ErrorCode = HAL_SPI_ERROR_NONE;
   \   00000164   0x2000             MOVS     R0,#+0
   \   00000166   0x6620             STR      R0,[R4, #+96]
    322            hspi->State = HAL_SPI_STATE_RESET;
   \   00000168   0xF884 0x005D      STRB     R0,[R4, #+93]
    323          
    324            __HAL_UNLOCK(hspi);
   \   0000016C   0xF884 0x005C      STRB     R0,[R4, #+92]
    325          
    326            return HAL_OK;
   \                     ??HAL_SPI_DeInit_0: (+1)
   \   00000170   0xB001             ADD      SP,SP,#+4
   \   00000172   0xBD30             POP      {R4,R5,PC}       ;; return
    327          }
    328          
    329          /**
    330            * @brief SPI MSP Init
    331            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
    332            *               the configuration information for SPI module.
    333            * @retval None
    334            */

   \                                 In section .text, align 2, keep-with-next
    335           __weak void HAL_SPI_MspInit(SPI_HandleTypeDef *hspi)
    336           {
    337             /* NOTE : This function should not be modified, when the callback is needed,
    338                      the HAL_SPI_MspInit should be implemented in the user file
    339             */
    340          }
   \                     HAL_SPI_MspInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    341          
    342          /**
    343            * @brief SPI MSP DeInit
    344            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
    345            *               the configuration information for SPI module.
    346            * @retval None
    347            */

   \                                 In section .text, align 2, keep-with-next
    348           __weak void HAL_SPI_MspDeInit(SPI_HandleTypeDef *hspi)
    349          {
    350            /* NOTE : This function should not be modified, when the callback is needed,
    351                      the HAL_SPI_MspDeInit should be implemented in the user file
    352             */
    353          }
   \                     HAL_SPI_MspDeInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    354          
    355          /**
    356            * @}
    357            */
    358          
    359          /** @defgroup SPI_Exported_Functions_Group2 IO operation functions
    360           *  @brief   Data transfers functions
    361           *
    362          @verbatim
    363            ==============================================================================
    364                                ##### IO operation functions #####
    365           ===============================================================================
    366              This subsection provides a set of functions allowing to manage the SPI
    367              data transfers.
    368          
    369              [..] The SPI supports master and slave mode :
    370          
    371              (#) There are two modes of transfer:
    372                 (++) Blocking mode: The communication is performed in polling mode.
    373                      The HAL status of all data processing is returned by the same function
    374                      after finishing transfer.
    375                 (++) No-Blocking mode: The communication is performed using Interrupts
    376                     or DMA, These APIs return the HAL status.
    377                     The end of the data processing will be indicated through the
    378                     dedicated SPI IRQ when using Interrupt mode or the DMA IRQ when
    379                     using DMA mode.
    380                     The HAL_SPI_TxCpltCallback(), HAL_SPI_RxCpltCallback() and HAL_SPI_TxRxCpltCallback() user callbacks
    381                     will be executed respectively at the end of the transmit or Receive process
    382                     The HAL_SPI_ErrorCallback()user callback will be executed when a communication error is detected
    383          
    384              (#) APIs provided for these 2 transfer modes (Blocking mode or Non blocking mode using either Interrupt or DMA)
    385                  exist for 1Line (simplex) and 2Lines (full duplex) modes.
    386          
    387          @endverbatim
    388            * @{
    389            */
    390          
    391          /**
    392            * @brief  Transmit an amount of data in blocking mode
    393            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
    394            *               the configuration information for SPI module.
    395            * @param  pData: pointer to data buffer
    396            * @param  Size: amount of data to be sent
    397            * @param  Timeout: Timeout duration
    398            * @retval HAL status
    399            */

   \                                 In section .text, align 2, keep-with-next
    400          HAL_StatusTypeDef HAL_SPI_Transmit(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size, uint32_t Timeout)
    401          {
   \                     HAL_SPI_Transmit: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0xB082             SUB      SP,SP,#+8
   \   00000006   0x461D             MOV      R5,R3
    402            assert_param(IS_SPI_DIRECTION_2LINES_OR_1LINE(hspi->Init.Direction));
    403          
    404            /* Process Locked */
    405            __HAL_LOCK(hspi);
   \   00000008   0xF894 0x005C      LDRB     R0,[R4, #+92]
   \   0000000C   0x2801             CMP      R0,#+1
   \   0000000E   0xD00C             BEQ.N    ??HAL_SPI_Transmit_0
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0xF884 0x005C      STRB     R0,[R4, #+92]
    406          
    407            if(hspi->State != HAL_SPI_STATE_READY)
   \   00000016   0xF894 0x005D      LDRB     R0,[R4, #+93]
   \   0000001A   0x2801             CMP      R0,#+1
   \   0000001C   0xD008             BEQ.N    ??HAL_SPI_Transmit_1
    408            {
    409              hspi->State = HAL_SPI_STATE_READY;
   \   0000001E   0x2001             MOVS     R0,#+1
   \   00000020   0xF884 0x005D      STRB     R0,[R4, #+93]
    410             /* Process Unlocked */
    411             __HAL_UNLOCK(hspi);
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0xF884 0x005C      STRB     R0,[R4, #+92]
    412             return HAL_BUSY;
   \                     ??HAL_SPI_Transmit_0: (+1)
   \   0000002A   0x2002             MOVS     R0,#+2
    413            }
    414            
    415            if((pData == NULL ) || (Size == 0))
    416            {
    417              hspi->State = HAL_SPI_STATE_READY;
    418             /* Process Unlocked */
    419             __HAL_UNLOCK(hspi);
    420              return HAL_ERROR;
    421            }
    422          
    423            /* Set the transaction information */
    424            hspi->State       = HAL_SPI_STATE_BUSY_TX;
    425            hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
    426            hspi->pTxBuffPtr  = pData;
    427            hspi->TxXferSize  = Size;
    428            hspi->TxXferCount = Size;
    429            hspi->pRxBuffPtr  = (uint8_t *)NULL;
    430            hspi->RxXferSize  = 0;
    431            hspi->RxXferCount = 0;
    432          
    433            /* Configure communication direction : 1Line */
    434            if(hspi->Init.Direction == SPI_DIRECTION_1LINE)
    435            {
    436              SPI_1LINE_TX(hspi);
    437            }
    438          
    439            /* Reset CRC Calculation */
    440            if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
    441            {
    442              SPI_RESET_CRC(hspi);
    443            }
    444          
    445            /* Check if the SPI is already enabled */
    446            if((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
    447            {
    448              /* Enable SPI peripheral */
    449              __HAL_SPI_ENABLE(hspi);
    450            }
    451          
    452            /* Transmit data in 16 Bit mode */
    453            if(hspi->Init.DataSize > SPI_DATASIZE_8BIT)
    454            {
    455              /* Transmit data in 16 Bit mode */
    456              while (hspi->TxXferCount > 0)
    457              {
    458                /* Wait until TXE flag is set to send data */
    459                if(SPI_WaitFlagStateUntilTimeout(hspi,SPI_FLAG_TXE,SPI_FLAG_TXE,Timeout) != HAL_OK)
    460                {
    461                  hspi->State = HAL_SPI_STATE_READY;
    462                  /* Process Unlocked */
    463                 __HAL_UNLOCK(hspi);
    464                  return HAL_TIMEOUT;
    465                }
    466                hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
    467                hspi->pTxBuffPtr += sizeof(uint16_t);
    468                hspi->TxXferCount--;
    469              }
    470            }
    471            /* Transmit data in 8 Bit mode */
    472            else
    473            {
    474              while (hspi->TxXferCount > 0)
    475              {
    476                if(hspi->TxXferCount != 0x1)
    477                {
    478                  /* Wait until TXE flag is set to send data */
    479                  if(SPI_WaitFlagStateUntilTimeout(hspi,SPI_FLAG_TXE,SPI_FLAG_TXE,Timeout) != HAL_OK)
    480                  {
    481                    hspi->State = HAL_SPI_STATE_READY;
    482                    /* Process Unlocked */
    483                    __HAL_UNLOCK(hspi);
    484                    return HAL_TIMEOUT;
    485                  }
    486                  hspi->Instance->DR = *((uint16_t*)hspi->pTxBuffPtr);
    487                  hspi->pTxBuffPtr += sizeof(uint16_t);
    488                  hspi->TxXferCount -= 2;
    489                }
    490                else
    491                {
    492                  /* Wait until TXE flag is set to send data */
    493                  if(SPI_WaitFlagStateUntilTimeout(hspi,SPI_FLAG_TXE,SPI_FLAG_TXE,Timeout) != HAL_OK)  
    494                  {
    495                    return HAL_TIMEOUT;
    496                  }
    497                  *((__IO uint8_t*)&hspi->Instance->DR) = (*hspi->pTxBuffPtr++);
    498                  hspi->TxXferCount--;    
    499                }
    500              }
    501            }
    502          
    503            /* Enable CRC Transmission */
    504            if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
    505            {
    506               hspi->Instance->CR1|= SPI_CR1_CRCNEXT;
    507            }
    508          
    509            /* Check the end of the transaction */
    510            if(SPI_EndRxTxTransaction(hspi,Timeout) != HAL_OK)
    511            {
    512              return HAL_TIMEOUT;
    513            }
    514            
    515            /* Clear OVERUN flag in 2 Lines communication mode because received is not read */
    516            if(hspi->Init.Direction == SPI_DIRECTION_2LINES)
    517            {
    518              __HAL_SPI_CLEAR_OVRFLAG(hspi);
    519            }
    520              
    521            hspi->State = HAL_SPI_STATE_READY; 
    522          
    523            /* Process Unlocked */
    524            __HAL_UNLOCK(hspi);
    525            
    526            if(hspi->ErrorCode != HAL_SPI_ERROR_NONE)
    527            {   
    528              return HAL_ERROR;
    529            }
    530            else
    531            {
    532              return HAL_OK;
   \   0000002C   0xB002             ADD      SP,SP,#+8
   \   0000002E   0xBD70             POP      {R4-R6,PC}
   \                     ??HAL_SPI_Transmit_1: (+1)
   \   00000030   0x2900             CMP      R1,#+0
   \   00000032   0xBF18             IT       NE 
   \   00000034   0x2A00             CMPNE    R2,#+0
   \   00000036   0xD107             BNE.N    ??HAL_SPI_Transmit_2
   \   00000038   0xF884 0x005D      STRB     R0,[R4, #+93]
   \   0000003C   0x2000             MOVS     R0,#+0
   \   0000003E   0xF884 0x005C      STRB     R0,[R4, #+92]
   \   00000042   0x2001             MOVS     R0,#+1
   \   00000044   0xB002             ADD      SP,SP,#+8
   \   00000046   0xBD70             POP      {R4-R6,PC}
   \                     ??HAL_SPI_Transmit_2: (+1)
   \   00000048   0x2003             MOVS     R0,#+3
   \   0000004A   0x63A1             STR      R1,[R4, #+56]
   \   0000004C   0x68A1             LDR      R1,[R4, #+8]
   \   0000004E   0xF884 0x005D      STRB     R0,[R4, #+93]
   \   00000052   0x2000             MOVS     R0,#+0
   \   00000054   0x87A2             STRH     R2,[R4, #+60]
   \   00000056   0xF5B1 0x4F00      CMP      R1,#+32768
   \   0000005A   0x6620             STR      R0,[R4, #+96]
   \   0000005C   0x87E2             STRH     R2,[R4, #+62]
   \   0000005E   0x6420             STR      R0,[R4, #+64]
   \   00000060   0xF8A4 0x0044      STRH     R0,[R4, #+68]
   \   00000064   0xF8A4 0x0046      STRH     R0,[R4, #+70]
   \   00000068   0x6820             LDR      R0,[R4, #+0]
   \   0000006A   0xD103             BNE.N    ??HAL_SPI_Transmit_3
   \   0000006C   0x6801             LDR      R1,[R0, #+0]
   \   0000006E   0xF441 0x4180      ORR      R1,R1,#0x4000
   \   00000072   0x6001             STR      R1,[R0, #+0]
   \                     ??HAL_SPI_Transmit_3: (+1)
   \   00000074   0x6AA1             LDR      R1,[R4, #+40]
   \   00000076   0xF5B1 0x5F00      CMP      R1,#+8192
   \   0000007A   0xD108             BNE.N    ??HAL_SPI_Transmit_4
   \   0000007C   0x6801             LDR      R1,[R0, #+0]
   \   0000007E   0xF64D 0x72FF      MOVW     R2,#+57343
   \   00000082   0x4011             ANDS     R1,R2,R1
   \   00000084   0x6001             STR      R1,[R0, #+0]
   \   00000086   0x6801             LDR      R1,[R0, #+0]
   \   00000088   0xF441 0x5100      ORR      R1,R1,#0x2000
   \   0000008C   0x6001             STR      R1,[R0, #+0]
   \                     ??HAL_SPI_Transmit_4: (+1)
   \   0000008E   0x6801             LDR      R1,[R0, #+0]
   \   00000090   0x0649             LSLS     R1,R1,#+25
   \   00000092   0xD403             BMI.N    ??HAL_SPI_Transmit_5
   \   00000094   0x6801             LDR      R1,[R0, #+0]
   \   00000096   0xF041 0x0140      ORR      R1,R1,#0x40
   \   0000009A   0x6001             STR      R1,[R0, #+0]
   \                     ??HAL_SPI_Transmit_5: (+1)
   \   0000009C   0x68E0             LDR      R0,[R4, #+12]
   \   0000009E   0xF5B0 0x6FE0      CMP      R0,#+1792
   \   000000A2   0xD925             BLS.N    ??HAL_SPI_Transmit_6
   \   000000A4   0xE007             B.N      ??HAL_SPI_Transmit_7
   \                     ??HAL_SPI_Transmit_8: (+1)
   \   000000A6   0x6BA0             LDR      R0,[R4, #+56]
   \   000000A8   0xF830 0x2B02      LDRH     R2,[R0], #+2
   \   000000AC   0x60CA             STR      R2,[R1, #+12]
   \   000000AE   0x63A0             STR      R0,[R4, #+56]
   \   000000B0   0x8FE0             LDRH     R0,[R4, #+62]
   \   000000B2   0x1E40             SUBS     R0,R0,#+1
   \   000000B4   0x87E0             STRH     R0,[R4, #+62]
   \                     ??HAL_SPI_Transmit_7: (+1)
   \   000000B6   0x8FE0             LDRH     R0,[R4, #+62]
   \   000000B8   0x2800             CMP      R0,#+0
   \   000000BA   0xF000 0x809C      BEQ.W    ??HAL_SPI_Transmit_9
   \   000000BE   0x.... 0x....      BL       HAL_GetTick
   \   000000C2   0x4606             MOV      R6,R0
   \                     ??HAL_SPI_Transmit_10: (+1)
   \   000000C4   0x6821             LDR      R1,[R4, #+0]
   \   000000C6   0x6888             LDR      R0,[R1, #+8]
   \   000000C8   0x0780             LSLS     R0,R0,#+30
   \   000000CA   0xD4EC             BMI.N    ??HAL_SPI_Transmit_8
   \   000000CC   0xF115 0x0F01      CMN      R5,#+1
   \   000000D0   0xD0F8             BEQ.N    ??HAL_SPI_Transmit_10
   \   000000D2   0xB31D             CBZ.N    R5,??HAL_SPI_Transmit_11
   \   000000D4   0x.... 0x....      BL       HAL_GetTick
   \   000000D8   0x1B80             SUBS     R0,R0,R6
   \   000000DA   0x42A8             CMP      R0,R5
   \   000000DC   0xD3F2             BCC.N    ??HAL_SPI_Transmit_10
   \   000000DE   0xE01D             B.N      ??HAL_SPI_Transmit_11
   \                     ??HAL_SPI_Transmit_12: (+1)
   \   000000E0   0x6BA0             LDR      R0,[R4, #+56]
   \   000000E2   0xF830 0x2B02      LDRH     R2,[R0], #+2
   \   000000E6   0x60CA             STR      R2,[R1, #+12]
   \   000000E8   0x63A0             STR      R0,[R4, #+56]
   \   000000EA   0x8FE0             LDRH     R0,[R4, #+62]
   \   000000EC   0x1E80             SUBS     R0,R0,#+2
   \                     ??HAL_SPI_Transmit_13: (+1)
   \   000000EE   0x87E0             STRH     R0,[R4, #+62]
   \                     ??HAL_SPI_Transmit_6: (+1)
   \   000000F0   0x8FE0             LDRH     R0,[R4, #+62]
   \   000000F2   0x2800             CMP      R0,#+0
   \   000000F4   0xF000 0x807F      BEQ.W    ??HAL_SPI_Transmit_9
   \   000000F8   0x2801             CMP      R0,#+1
   \   000000FA   0xD039             BEQ.N    ??HAL_SPI_Transmit_14
   \   000000FC   0x.... 0x....      BL       HAL_GetTick
   \   00000100   0x4606             MOV      R6,R0
   \                     ??HAL_SPI_Transmit_15: (+1)
   \   00000102   0x6821             LDR      R1,[R4, #+0]
   \   00000104   0x6888             LDR      R0,[R1, #+8]
   \   00000106   0x0780             LSLS     R0,R0,#+30
   \   00000108   0xD4EA             BMI.N    ??HAL_SPI_Transmit_12
   \   0000010A   0xF115 0x0F01      CMN      R5,#+1
   \   0000010E   0xD0F8             BEQ.N    ??HAL_SPI_Transmit_15
   \   00000110   0xB125             CBZ.N    R5,??HAL_SPI_Transmit_11
   \   00000112   0x.... 0x....      BL       HAL_GetTick
   \   00000116   0x1B80             SUBS     R0,R0,R6
   \   00000118   0x42A8             CMP      R0,R5
   \   0000011A   0xD3F2             BCC.N    ??HAL_SPI_Transmit_15
   \                     ??HAL_SPI_Transmit_11: (+1)
   \   0000011C   0x6820             LDR      R0,[R4, #+0]
   \   0000011E   0x6841             LDR      R1,[R0, #+4]
   \   00000120   0xF021 0x01E0      BIC      R1,R1,#0xE0
   \   00000124   0x6041             STR      R1,[R0, #+4]
   \   00000126   0x6861             LDR      R1,[R4, #+4]
   \   00000128   0xF5B1 0x7F82      CMP      R1,#+260
   \   0000012C   0xD10A             BNE.N    ??HAL_SPI_Transmit_16
   \   0000012E   0x68A1             LDR      R1,[R4, #+8]
   \   00000130   0xF5B1 0x4F00      CMP      R1,#+32768
   \   00000134   0xBF18             IT       NE 
   \   00000136   0xF5B1 0x6F80      CMPNE    R1,#+1024
   \   0000013A   0xD103             BNE.N    ??HAL_SPI_Transmit_16
   \   0000013C   0x6801             LDR      R1,[R0, #+0]
   \   0000013E   0xF021 0x0140      BIC      R1,R1,#0x40
   \   00000142   0x6001             STR      R1,[R0, #+0]
   \                     ??HAL_SPI_Transmit_16: (+1)
   \   00000144   0x6AA1             LDR      R1,[R4, #+40]
   \   00000146   0xF5B1 0x5F00      CMP      R1,#+8192
   \   0000014A   0xD108             BNE.N    ??HAL_SPI_Transmit_17
   \   0000014C   0x6801             LDR      R1,[R0, #+0]
   \   0000014E   0xF64D 0x72FF      MOVW     R2,#+57343
   \   00000152   0x4011             ANDS     R1,R2,R1
   \   00000154   0x6001             STR      R1,[R0, #+0]
   \   00000156   0x6801             LDR      R1,[R0, #+0]
   \   00000158   0xF441 0x5100      ORR      R1,R1,#0x2000
   \   0000015C   0x6001             STR      R1,[R0, #+0]
   \                     ??HAL_SPI_Transmit_17: (+1)
   \   0000015E   0x2001             MOVS     R0,#+1
   \   00000160   0xF884 0x005D      STRB     R0,[R4, #+93]
   \   00000164   0x2000             MOVS     R0,#+0
   \   00000166   0xF884 0x005C      STRB     R0,[R4, #+92]
   \   0000016A   0x2003             MOVS     R0,#+3
   \   0000016C   0xB002             ADD      SP,SP,#+8
   \   0000016E   0xBD70             POP      {R4-R6,PC}
   \                     ??HAL_SPI_Transmit_14: (+1)
   \   00000170   0x.... 0x....      BL       HAL_GetTick
   \   00000174   0x4606             MOV      R6,R0
   \                     ??HAL_SPI_Transmit_18: (+1)
   \   00000176   0x6820             LDR      R0,[R4, #+0]
   \   00000178   0x6881             LDR      R1,[R0, #+8]
   \   0000017A   0x0789             LSLS     R1,R1,#+30
   \   0000017C   0xD432             BMI.N    ??HAL_SPI_Transmit_19
   \   0000017E   0xF115 0x0F01      CMN      R5,#+1
   \   00000182   0xD0F8             BEQ.N    ??HAL_SPI_Transmit_18
   \   00000184   0xB125             CBZ.N    R5,??HAL_SPI_Transmit_20
   \   00000186   0x.... 0x....      BL       HAL_GetTick
   \   0000018A   0x1B80             SUBS     R0,R0,R6
   \   0000018C   0x42A8             CMP      R0,R5
   \   0000018E   0xD3F2             BCC.N    ??HAL_SPI_Transmit_18
   \                     ??HAL_SPI_Transmit_20: (+1)
   \   00000190   0x6820             LDR      R0,[R4, #+0]
   \   00000192   0x6841             LDR      R1,[R0, #+4]
   \   00000194   0xF021 0x01E0      BIC      R1,R1,#0xE0
   \   00000198   0x6041             STR      R1,[R0, #+4]
   \   0000019A   0x6861             LDR      R1,[R4, #+4]
   \   0000019C   0xF5B1 0x7F82      CMP      R1,#+260
   \   000001A0   0xD10A             BNE.N    ??HAL_SPI_Transmit_21
   \   000001A2   0x68A1             LDR      R1,[R4, #+8]
   \   000001A4   0xF5B1 0x4F00      CMP      R1,#+32768
   \   000001A8   0xBF18             IT       NE 
   \   000001AA   0xF5B1 0x6F80      CMPNE    R1,#+1024
   \   000001AE   0xD103             BNE.N    ??HAL_SPI_Transmit_21
   \   000001B0   0x6801             LDR      R1,[R0, #+0]
   \   000001B2   0xF021 0x0140      BIC      R1,R1,#0x40
   \   000001B6   0x6001             STR      R1,[R0, #+0]
   \                     ??HAL_SPI_Transmit_21: (+1)
   \   000001B8   0x6AA1             LDR      R1,[R4, #+40]
   \   000001BA   0xF5B1 0x5F00      CMP      R1,#+8192
   \   000001BE   0xD108             BNE.N    ??HAL_SPI_Transmit_22
   \   000001C0   0x6801             LDR      R1,[R0, #+0]
   \   000001C2   0xF64D 0x72FF      MOVW     R2,#+57343
   \   000001C6   0x4011             ANDS     R1,R2,R1
   \   000001C8   0x6001             STR      R1,[R0, #+0]
   \   000001CA   0x6801             LDR      R1,[R0, #+0]
   \   000001CC   0xF441 0x5100      ORR      R1,R1,#0x2000
   \   000001D0   0x6001             STR      R1,[R0, #+0]
   \                     ??HAL_SPI_Transmit_22: (+1)
   \   000001D2   0x2001             MOVS     R0,#+1
   \   000001D4   0xF884 0x005D      STRB     R0,[R4, #+93]
   \   000001D8   0x2000             MOVS     R0,#+0
   \   000001DA   0xF884 0x005C      STRB     R0,[R4, #+92]
   \   000001DE   0x2003             MOVS     R0,#+3
   \   000001E0   0xB002             ADD      SP,SP,#+8
   \   000001E2   0xBD70             POP      {R4-R6,PC}
   \                     ??HAL_SPI_Transmit_19: (+1)
   \   000001E4   0x6BA1             LDR      R1,[R4, #+56]
   \   000001E6   0x1C49             ADDS     R1,R1,#+1
   \   000001E8   0x63A1             STR      R1,[R4, #+56]
   \   000001EA   0x1E49             SUBS     R1,R1,#+1
   \   000001EC   0x7809             LDRB     R1,[R1, #+0]
   \   000001EE   0x7301             STRB     R1,[R0, #+12]
   \   000001F0   0x8FE0             LDRH     R0,[R4, #+62]
   \   000001F2   0x1E40             SUBS     R0,R0,#+1
   \   000001F4   0xE77B             B.N      ??HAL_SPI_Transmit_13
   \                     ??HAL_SPI_Transmit_9: (+1)
   \   000001F6   0x6AA0             LDR      R0,[R4, #+40]
   \   000001F8   0xF5B0 0x5F00      CMP      R0,#+8192
   \   000001FC   0xD104             BNE.N    ??HAL_SPI_Transmit_23
   \   000001FE   0x6820             LDR      R0,[R4, #+0]
   \   00000200   0x6801             LDR      R1,[R0, #+0]
   \   00000202   0xF441 0x5180      ORR      R1,R1,#0x1000
   \   00000206   0x6001             STR      R1,[R0, #+0]
   \                     ??HAL_SPI_Transmit_23: (+1)
   \   00000208   0x.... 0x....      BL       HAL_GetTick
   \   0000020C   0x4606             MOV      R6,R0
   \                     ??HAL_SPI_Transmit_24: (+1)
   \   0000020E   0x6820             LDR      R0,[R4, #+0]
   \   00000210   0x6880             LDR      R0,[R0, #+8]
   \   00000212   0xF410 0x5FC0      TST      R0,#0x1800
   \   00000216   0xD036             BEQ.N    ??HAL_SPI_Transmit_25
   \   00000218   0xF115 0x0F01      CMN      R5,#+1
   \   0000021C   0xD0F7             BEQ.N    ??HAL_SPI_Transmit_24
   \   0000021E   0xB125             CBZ.N    R5,??HAL_SPI_Transmit_26
   \   00000220   0x.... 0x....      BL       HAL_GetTick
   \   00000224   0x1B80             SUBS     R0,R0,R6
   \   00000226   0x42A8             CMP      R0,R5
   \   00000228   0xD3F1             BCC.N    ??HAL_SPI_Transmit_24
   \                     ??HAL_SPI_Transmit_26: (+1)
   \   0000022A   0x6820             LDR      R0,[R4, #+0]
   \   0000022C   0x6841             LDR      R1,[R0, #+4]
   \   0000022E   0xF021 0x01E0      BIC      R1,R1,#0xE0
   \   00000232   0x6041             STR      R1,[R0, #+4]
   \   00000234   0x6861             LDR      R1,[R4, #+4]
   \   00000236   0xF5B1 0x7F82      CMP      R1,#+260
   \   0000023A   0xD10A             BNE.N    ??HAL_SPI_Transmit_27
   \   0000023C   0x68A1             LDR      R1,[R4, #+8]
   \   0000023E   0xF5B1 0x4F00      CMP      R1,#+32768
   \   00000242   0xBF18             IT       NE 
   \   00000244   0xF5B1 0x6F80      CMPNE    R1,#+1024
   \   00000248   0xD103             BNE.N    ??HAL_SPI_Transmit_27
   \   0000024A   0x6801             LDR      R1,[R0, #+0]
   \   0000024C   0xF021 0x0140      BIC      R1,R1,#0x40
   \   00000250   0x6001             STR      R1,[R0, #+0]
   \                     ??HAL_SPI_Transmit_27: (+1)
   \   00000252   0x6AA1             LDR      R1,[R4, #+40]
   \   00000254   0xF5B1 0x5F00      CMP      R1,#+8192
   \   00000258   0xD108             BNE.N    ??HAL_SPI_Transmit_28
   \   0000025A   0x6801             LDR      R1,[R0, #+0]
   \   0000025C   0xF64D 0x72FF      MOVW     R2,#+57343
   \   00000260   0x4011             ANDS     R1,R2,R1
   \   00000262   0x6001             STR      R1,[R0, #+0]
   \   00000264   0x6801             LDR      R1,[R0, #+0]
   \   00000266   0xF441 0x5100      ORR      R1,R1,#0x2000
   \   0000026A   0x6001             STR      R1,[R0, #+0]
   \                     ??HAL_SPI_Transmit_28: (+1)
   \   0000026C   0x2001             MOVS     R0,#+1
   \   0000026E   0xF884 0x005D      STRB     R0,[R4, #+93]
   \   00000272   0x2000             MOVS     R0,#+0
   \   00000274   0xF884 0x005C      STRB     R0,[R4, #+92]
   \   00000278   0x6E20             LDR      R0,[R4, #+96]
   \   0000027A   0xF040 0x0020      ORR      R0,R0,#0x20
   \   0000027E   0x6620             STR      R0,[R4, #+96]
   \   00000280   0x2003             MOVS     R0,#+3
   \   00000282   0xB002             ADD      SP,SP,#+8
   \   00000284   0xBD70             POP      {R4-R6,PC}
   \                     ??HAL_SPI_Transmit_25: (+1)
   \   00000286   0x.... 0x....      BL       HAL_GetTick
   \   0000028A   0x4606             MOV      R6,R0
   \                     ??HAL_SPI_Transmit_29: (+1)
   \   0000028C   0x6820             LDR      R0,[R4, #+0]
   \   0000028E   0x6880             LDR      R0,[R0, #+8]
   \   00000290   0x0600             LSLS     R0,R0,#+24
   \   00000292   0xD50A             BPL.N    ??HAL_SPI_Transmit_30
   \   00000294   0xF115 0x0F01      CMN      R5,#+1
   \   00000298   0xD0F8             BEQ.N    ??HAL_SPI_Transmit_29
   \   0000029A   0x2D00             CMP      R5,#+0
   \   0000029C   0xD0C5             BEQ.N    ??HAL_SPI_Transmit_26
   \   0000029E   0x.... 0x....      BL       HAL_GetTick
   \   000002A2   0x1B80             SUBS     R0,R0,R6
   \   000002A4   0x42A8             CMP      R0,R5
   \   000002A6   0xD3F1             BCC.N    ??HAL_SPI_Transmit_29
   \   000002A8   0xE7BF             B.N      ??HAL_SPI_Transmit_26
   \                     ??HAL_SPI_Transmit_30: (+1)
   \   000002AA   0x.... 0x....      BL       HAL_GetTick
   \   000002AE   0x4606             MOV      R6,R0
   \                     ??HAL_SPI_Transmit_31: (+1)
   \   000002B0   0x6820             LDR      R0,[R4, #+0]
   \   000002B2   0x6881             LDR      R1,[R0, #+8]
   \   000002B4   0xF411 0x6FC0      TST      R1,#0x600
   \   000002B8   0xD00F             BEQ.N    ??HAL_SPI_Transmit_32
   \   000002BA   0x7B00             LDRB     R0,[R0, #+12]
   \   000002BC   0xF115 0x0F01      CMN      R5,#+1
   \   000002C0   0xF88D 0x0004      STRB     R0,[SP, #+4]
   \   000002C4   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \   000002C8   0xD0F2             BEQ.N    ??HAL_SPI_Transmit_31
   \   000002CA   0x2D00             CMP      R5,#+0
   \   000002CC   0xD0AD             BEQ.N    ??HAL_SPI_Transmit_26
   \   000002CE   0x.... 0x....      BL       HAL_GetTick
   \   000002D2   0x1B80             SUBS     R0,R0,R6
   \   000002D4   0x42A8             CMP      R0,R5
   \   000002D6   0xD3EB             BCC.N    ??HAL_SPI_Transmit_31
   \   000002D8   0xE7A7             B.N      ??HAL_SPI_Transmit_26
   \                     ??HAL_SPI_Transmit_32: (+1)
   \   000002DA   0x68A1             LDR      R1,[R4, #+8]
   \   000002DC   0xB921             CBNZ.N   R1,??HAL_SPI_Transmit_33
   \   000002DE   0x68C1             LDR      R1,[R0, #+12]
   \   000002E0   0x9100             STR      R1,[SP, #+0]
   \   000002E2   0x6880             LDR      R0,[R0, #+8]
   \   000002E4   0x9000             STR      R0,[SP, #+0]
   \   000002E6   0x9800             LDR      R0,[SP, #+0]
   \                     ??HAL_SPI_Transmit_33: (+1)
   \   000002E8   0x2001             MOVS     R0,#+1
   \   000002EA   0xF884 0x005D      STRB     R0,[R4, #+93]
   \   000002EE   0x2000             MOVS     R0,#+0
   \   000002F0   0xF884 0x005C      STRB     R0,[R4, #+92]
   \   000002F4   0x6E20             LDR      R0,[R4, #+96]
   \   000002F6   0xB002             ADD      SP,SP,#+8
   \   000002F8   0x1E40             SUBS     R0,R0,#+1
   \   000002FA   0x4180             SBCS     R0,R0,R0
   \   000002FC   0x43C0             MVNS     R0,R0
   \   000002FE   0x0FC0             LSRS     R0,R0,#+31
   \   00000300   0xBD70             POP      {R4-R6,PC}       ;; return
    533            }
    534          }
    535          
    536          /**
    537            * @brief  Receive an amount of data in blocking mode
    538            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
    539            *               the configuration information for SPI module.
    540            * @param  pData: pointer to data buffer
    541            * @param  Size: amount of data to be received
    542            * @param  Timeout: Timeout duration
    543            * @retval HAL status
    544            */

   \                                 In section .text, align 2, keep-with-next
    545          HAL_StatusTypeDef HAL_SPI_Receive(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size, uint32_t Timeout)
    546          {
   \                     HAL_SPI_Receive: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0xB081             SUB      SP,SP,#+4
   \   00000006   0x461D             MOV      R5,R3
    547            __IO uint16_t tmpreg;
    548            
    549            if(hspi->State != HAL_SPI_STATE_READY)
   \   00000008   0xF894 0x005D      LDRB     R0,[R4, #+93]
   \   0000000C   0x2801             CMP      R0,#+1
   \   0000000E   0xD117             BNE.N    ??HAL_SPI_Receive_0
    550            {
    551              return HAL_BUSY;
    552            }
    553            
    554            if((pData == NULL ) || (Size == 0))
   \   00000010   0x2900             CMP      R1,#+0
   \   00000012   0xBF18             IT       NE 
   \   00000014   0x2A00             CMPNE    R2,#+0
   \   00000016   0xF000 0x81FB      BEQ.W    ??HAL_SPI_Receive_1
    555            {
    556              return HAL_ERROR;
    557            }
    558          
    559            if((hspi->Init.Mode == SPI_MODE_MASTER) && (hspi->Init.Direction == SPI_DIRECTION_2LINES))
   \   0000001A   0x6860             LDR      R0,[R4, #+4]
   \   0000001C   0xF5B0 0x7F82      CMP      R0,#+260
   \   00000020   0xBF04             ITT      EQ 
   \   00000022   0x68A0             LDREQ    R0,[R4, #+8]
   \   00000024   0x2800             CMPEQ    R0,#+0
   \   00000026   0xD107             BNE.N    ??HAL_SPI_Receive_2
    560            {
    561              /* the receive process is not supported in 2Lines direction master mode */
    562              /* in this case we call the transmitReceive process                     */
    563              return HAL_SPI_TransmitReceive(hspi,pData,pData,Size,Timeout);
   \   00000028   0x4613             MOV      R3,R2
   \   0000002A   0x9500             STR      R5,[SP, #+0]
   \   0000002C   0x460A             MOV      R2,R1
   \   0000002E   0x4620             MOV      R0,R4
   \   00000030   0x.... 0x....      BL       HAL_SPI_TransmitReceive
    564            }
    565            
    566            /* Process Locked */
    567            __HAL_LOCK(hspi);
    568              
    569            hspi->State       = HAL_SPI_STATE_BUSY_RX;
    570            hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
    571            hspi->pRxBuffPtr  = pData;
    572            hspi->RxXferSize  = Size;
    573            hspi->RxXferCount = Size;
    574            hspi->pTxBuffPtr  = (uint8_t *)NULL;
    575            hspi->TxXferSize  = 0;
    576            hspi->TxXferCount = 0;
    577          
    578            /* Reset CRC Calculation */
    579            if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
    580            {
    581              SPI_RESET_CRC(hspi);
    582              /* this is done to handle the CRCNEXT before the latest data */
    583              hspi->RxXferCount--;
    584            }
    585          
    586            /* Set the Rx Fido threshold */
    587            if(hspi->Init.DataSize > SPI_DATASIZE_8BIT)
    588            {
    589              /* set fiforxthreshold according the reception data length: 16bit */
    590              CLEAR_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
    591            }
    592            else
    593            {
    594              /* set fiforxthreshold according the reception data length: 8bit */
    595              SET_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
    596            }
    597          
    598            /* Configure communication direction 1Line and enabled SPI if needed */
    599            if(hspi->Init.Direction == SPI_DIRECTION_1LINE)
    600            {
    601              SPI_1LINE_RX(hspi);
    602            }
    603          
    604            /* Check if the SPI is already enabled */
    605            if((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
    606            {
    607              /* Enable SPI peripheral */
    608              __HAL_SPI_ENABLE(hspi);
    609            }
    610          
    611            /* Receive data in 8 Bit mode */
    612            if(hspi->Init.DataSize <= SPI_DATASIZE_8BIT)
    613            {
    614              while(hspi->RxXferCount > 1)
    615              {
    616                /* Wait until the RXNE flag */
    617                if(SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_RXNE, SPI_FLAG_RXNE, Timeout) != HAL_OK)
    618                {
    619                  return HAL_TIMEOUT;
    620                }
    621                (*hspi->pRxBuffPtr++)= *(__IO uint8_t *)&hspi->Instance->DR;
    622                hspi->RxXferCount--;  
    623              }
    624            }
    625            else /* Receive data in 16 Bit mode */
    626            {   
    627              while(hspi->RxXferCount > 1 )
    628              {
    629                /* Wait until RXNE flag is reset to read data */
    630                if(SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_RXNE, SPI_FLAG_RXNE, Timeout) != HAL_OK)
    631                {
    632                  return HAL_TIMEOUT;
    633                }
    634                *((uint16_t*)hspi->pRxBuffPtr) = hspi->Instance->DR;
    635                hspi->pRxBuffPtr += sizeof(uint16_t);
    636                hspi->RxXferCount--;
    637              } 
    638            }
    639            
    640            /* Enable CRC Transmission */
    641            if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE) 
    642            {
    643              hspi->Instance->CR1 |= SPI_CR1_CRCNEXT;
    644            }  
    645          
    646            /* Wait until RXNE flag is set */
    647            if(SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_RXNE, SPI_FLAG_RXNE, Timeout) != HAL_OK)
    648            {
    649              return HAL_TIMEOUT;
    650            }
    651            
    652            /* Receive last data in 16 Bit mode */
    653            if(hspi->Init.DataSize > SPI_DATASIZE_8BIT)
    654            {        
    655              *((uint16_t*)hspi->pRxBuffPtr) = hspi->Instance->DR;
    656              hspi->pRxBuffPtr += sizeof(uint16_t);
    657            }
    658            /* Receive last data in 8 Bit mode */
    659            else 
    660            {
    661              (*hspi->pRxBuffPtr++) = *(__IO uint8_t *)&hspi->Instance->DR;
    662            }
    663            hspi->RxXferCount--;
    664            
    665            /* Read CRC from DR to close CRC calculation process */
    666            if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
    667            {
    668              /* Wait until TXE flag */
    669              if(SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_RXNE, SPI_FLAG_RXNE, Timeout) != HAL_OK) 
    670              {
    671                /* Error on the CRC reception */
    672                hspi->ErrorCode|= HAL_SPI_ERROR_CRC;
    673              }
    674              if(hspi->Init.DataSize > SPI_DATASIZE_8BIT)
    675              {        
    676                tmpreg = hspi->Instance->DR;
    677                UNUSED(tmpreg); /* To avoid GCC warning */
    678              }
    679              else
    680              {
    681                tmpreg = *(__IO uint8_t *)&hspi->Instance->DR;
    682                UNUSED(tmpreg); /* To avoid GCC warning */
    683          
    684                if((hspi->Init.DataSize == SPI_DATASIZE_8BIT) && (hspi->Init.CRCLength == SPI_CRC_LENGTH_16BIT))
    685                {
    686                  if(SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_RXNE, SPI_FLAG_RXNE, Timeout) != HAL_OK)
    687                  {
    688                    /* Error on the CRC reception */
    689                    hspi->ErrorCode|= HAL_SPI_ERROR_FLAG;
    690                  }
    691                  tmpreg = *(__IO uint8_t *)&hspi->Instance->DR;
    692                  UNUSED(tmpreg); /* To avoid GCC warning */
    693                }
    694              }
    695            }
    696            
    697            /* Check the end of the transaction */
    698            if(SPI_EndRxTransaction(hspi,Timeout) != HAL_OK)
    699            {
    700              return HAL_TIMEOUT;
    701            }
    702          
    703            hspi->State = HAL_SPI_STATE_READY; 
    704              
    705            /* Check if CRC error occurred */
    706            if(__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_CRCERR) != RESET)
    707            {
    708              hspi->ErrorCode|= HAL_SPI_ERROR_CRC;
    709              __HAL_SPI_CLEAR_CRCERRFLAG(hspi);
    710                            
    711              /* Process Unlocked */
    712              __HAL_UNLOCK(hspi);
    713              return HAL_ERROR;
    714            }
    715              
    716            /* Process Unlocked */
    717            __HAL_UNLOCK(hspi);
    718            
    719            if(hspi->ErrorCode != HAL_SPI_ERROR_NONE)
    720            {   
    721              return HAL_ERROR;
    722            }
    723            else
    724            {
    725              return HAL_OK;
   \   00000034   0xB001             ADD      SP,SP,#+4
   \   00000036   0xBDF0             POP      {R4-R7,PC}
   \                     ??HAL_SPI_Receive_2: (+1)
   \   00000038   0xF894 0x005C      LDRB     R0,[R4, #+92]
   \   0000003C   0x2801             CMP      R0,#+1
   \   0000003E   0xD102             BNE.N    ??HAL_SPI_Receive_3
   \                     ??HAL_SPI_Receive_0: (+1)
   \   00000040   0x2002             MOVS     R0,#+2
   \   00000042   0xB001             ADD      SP,SP,#+4
   \   00000044   0xBDF0             POP      {R4-R7,PC}
   \                     ??HAL_SPI_Receive_3: (+1)
   \   00000046   0x2001             MOVS     R0,#+1
   \   00000048   0x6421             STR      R1,[R4, #+64]
   \   0000004A   0xF884 0x005C      STRB     R0,[R4, #+92]
   \   0000004E   0x2004             MOVS     R0,#+4
   \   00000050   0x6AA1             LDR      R1,[R4, #+40]
   \   00000052   0xF884 0x005D      STRB     R0,[R4, #+93]
   \   00000056   0x2000             MOVS     R0,#+0
   \   00000058   0xF8A4 0x2044      STRH     R2,[R4, #+68]
   \   0000005C   0xF5B1 0x5F00      CMP      R1,#+8192
   \   00000060   0x6620             STR      R0,[R4, #+96]
   \   00000062   0xF8A4 0x2046      STRH     R2,[R4, #+70]
   \   00000066   0x63A0             STR      R0,[R4, #+56]
   \   00000068   0x87A0             STRH     R0,[R4, #+60]
   \   0000006A   0x87E0             STRH     R0,[R4, #+62]
   \   0000006C   0x6820             LDR      R0,[R4, #+0]
   \   0000006E   0xD10D             BNE.N    ??HAL_SPI_Receive_4
   \   00000070   0x6801             LDR      R1,[R0, #+0]
   \   00000072   0xF64D 0x72FF      MOVW     R2,#+57343
   \   00000076   0x4011             ANDS     R1,R2,R1
   \   00000078   0x6001             STR      R1,[R0, #+0]
   \   0000007A   0x6801             LDR      R1,[R0, #+0]
   \   0000007C   0xF441 0x5100      ORR      R1,R1,#0x2000
   \   00000080   0x6001             STR      R1,[R0, #+0]
   \   00000082   0xF8B4 0x1046      LDRH     R1,[R4, #+70]
   \   00000086   0x1E49             SUBS     R1,R1,#+1
   \   00000088   0xF8A4 0x1046      STRH     R1,[R4, #+70]
   \                     ??HAL_SPI_Receive_4: (+1)
   \   0000008C   0x68E1             LDR      R1,[R4, #+12]
   \   0000008E   0xF240 0x7601      MOVW     R6,#+1793
   \   00000092   0x42B1             CMP      R1,R6
   \   00000094   0x6841             LDR      R1,[R0, #+4]
   \   00000096   0xBF2C             ITE      CS 
   \   00000098   0xF421 0x5180      BICCS    R1,R1,#0x1000
   \   0000009C   0xF441 0x5180      ORRCC    R1,R1,#0x1000
   \   000000A0   0x6041             STR      R1,[R0, #+4]
   \   000000A2   0x68A1             LDR      R1,[R4, #+8]
   \   000000A4   0xF5B1 0x4F00      CMP      R1,#+32768
   \   000000A8   0xD103             BNE.N    ??HAL_SPI_Receive_5
   \   000000AA   0x6801             LDR      R1,[R0, #+0]
   \   000000AC   0xF421 0x4180      BIC      R1,R1,#0x4000
   \   000000B0   0x6001             STR      R1,[R0, #+0]
   \                     ??HAL_SPI_Receive_5: (+1)
   \   000000B2   0x6801             LDR      R1,[R0, #+0]
   \   000000B4   0x0649             LSLS     R1,R1,#+25
   \   000000B6   0xD403             BMI.N    ??HAL_SPI_Receive_6
   \   000000B8   0x6801             LDR      R1,[R0, #+0]
   \   000000BA   0xF041 0x0140      ORR      R1,R1,#0x40
   \   000000BE   0x6001             STR      R1,[R0, #+0]
   \                     ??HAL_SPI_Receive_6: (+1)
   \   000000C0   0x68E0             LDR      R0,[R4, #+12]
   \   000000C2   0x42B0             CMP      R0,R6
   \   000000C4   0xD22A             BCS.N    ??HAL_SPI_Receive_7
   \   000000C6   0xE009             B.N      ??HAL_SPI_Receive_8
   \                     ??HAL_SPI_Receive_9: (+1)
   \   000000C8   0x6C20             LDR      R0,[R4, #+64]
   \   000000CA   0x1C42             ADDS     R2,R0,#+1
   \   000000CC   0x6422             STR      R2,[R4, #+64]
   \   000000CE   0x7B09             LDRB     R1,[R1, #+12]
   \   000000D0   0x7001             STRB     R1,[R0, #+0]
   \   000000D2   0xF8B4 0x0046      LDRH     R0,[R4, #+70]
   \   000000D6   0x1E40             SUBS     R0,R0,#+1
   \   000000D8   0xF8A4 0x0046      STRH     R0,[R4, #+70]
   \                     ??HAL_SPI_Receive_8: (+1)
   \   000000DC   0xF8B4 0x0046      LDRH     R0,[R4, #+70]
   \   000000E0   0x2802             CMP      R0,#+2
   \   000000E2   0xDB30             BLT.N    ??HAL_SPI_Receive_10
   \   000000E4   0x.... 0x....      BL       HAL_GetTick
   \   000000E8   0x4607             MOV      R7,R0
   \                     ??HAL_SPI_Receive_11: (+1)
   \   000000EA   0x6821             LDR      R1,[R4, #+0]
   \   000000EC   0x6888             LDR      R0,[R1, #+8]
   \   000000EE   0x07C0             LSLS     R0,R0,#+31
   \   000000F0   0xD4EA             BMI.N    ??HAL_SPI_Receive_9
   \   000000F2   0xF115 0x0F01      CMN      R5,#+1
   \   000000F6   0xD0F8             BEQ.N    ??HAL_SPI_Receive_11
   \   000000F8   0x2D00             CMP      R5,#+0
   \   000000FA   0xD03D             BEQ.N    ??HAL_SPI_Receive_12
   \   000000FC   0x.... 0x....      BL       HAL_GetTick
   \   00000100   0x1BC0             SUBS     R0,R0,R7
   \   00000102   0x42A8             CMP      R0,R5
   \   00000104   0xD3F1             BCC.N    ??HAL_SPI_Receive_11
   \   00000106   0xE037             B.N      ??HAL_SPI_Receive_12
   \                     ??HAL_SPI_Receive_13: (+1)
   \   00000108   0x6C20             LDR      R0,[R4, #+64]
   \   0000010A   0x68C9             LDR      R1,[R1, #+12]
   \   0000010C   0xF820 0x1B02      STRH     R1,[R0], #+2
   \   00000110   0x6420             STR      R0,[R4, #+64]
   \   00000112   0xF8B4 0x0046      LDRH     R0,[R4, #+70]
   \   00000116   0x1E40             SUBS     R0,R0,#+1
   \   00000118   0xF8A4 0x0046      STRH     R0,[R4, #+70]
   \                     ??HAL_SPI_Receive_7: (+1)
   \   0000011C   0xF8B4 0x0046      LDRH     R0,[R4, #+70]
   \   00000120   0x2802             CMP      R0,#+2
   \   00000122   0xDB10             BLT.N    ??HAL_SPI_Receive_10
   \   00000124   0x.... 0x....      BL       HAL_GetTick
   \   00000128   0x4607             MOV      R7,R0
   \                     ??HAL_SPI_Receive_14: (+1)
   \   0000012A   0x6821             LDR      R1,[R4, #+0]
   \   0000012C   0x6888             LDR      R0,[R1, #+8]
   \   0000012E   0x07C0             LSLS     R0,R0,#+31
   \   00000130   0xD4EA             BMI.N    ??HAL_SPI_Receive_13
   \   00000132   0xF115 0x0F01      CMN      R5,#+1
   \   00000136   0xD0F8             BEQ.N    ??HAL_SPI_Receive_14
   \   00000138   0xB1F5             CBZ.N    R5,??HAL_SPI_Receive_12
   \   0000013A   0x.... 0x....      BL       HAL_GetTick
   \   0000013E   0x1BC0             SUBS     R0,R0,R7
   \   00000140   0x42A8             CMP      R0,R5
   \   00000142   0xD3F2             BCC.N    ??HAL_SPI_Receive_14
   \   00000144   0xE018             B.N      ??HAL_SPI_Receive_12
   \                     ??HAL_SPI_Receive_10: (+1)
   \   00000146   0x6AA0             LDR      R0,[R4, #+40]
   \   00000148   0xF5B0 0x5F00      CMP      R0,#+8192
   \   0000014C   0xD104             BNE.N    ??HAL_SPI_Receive_15
   \   0000014E   0x6820             LDR      R0,[R4, #+0]
   \   00000150   0x6801             LDR      R1,[R0, #+0]
   \   00000152   0xF441 0x5180      ORR      R1,R1,#0x1000
   \   00000156   0x6001             STR      R1,[R0, #+0]
   \                     ??HAL_SPI_Receive_15: (+1)
   \   00000158   0x.... 0x....      BL       HAL_GetTick
   \   0000015C   0x4607             MOV      R7,R0
   \                     ??HAL_SPI_Receive_16: (+1)
   \   0000015E   0x6820             LDR      R0,[R4, #+0]
   \   00000160   0x6881             LDR      R1,[R0, #+8]
   \   00000162   0x07C9             LSLS     R1,R1,#+31
   \   00000164   0xD432             BMI.N    ??HAL_SPI_Receive_17
   \   00000166   0xF115 0x0F01      CMN      R5,#+1
   \   0000016A   0xD0F8             BEQ.N    ??HAL_SPI_Receive_16
   \   0000016C   0xB125             CBZ.N    R5,??HAL_SPI_Receive_12
   \   0000016E   0x.... 0x....      BL       HAL_GetTick
   \   00000172   0x1BC0             SUBS     R0,R0,R7
   \   00000174   0x42A8             CMP      R0,R5
   \   00000176   0xD3F2             BCC.N    ??HAL_SPI_Receive_16
   \                     ??HAL_SPI_Receive_12: (+1)
   \   00000178   0x6820             LDR      R0,[R4, #+0]
   \   0000017A   0x6841             LDR      R1,[R0, #+4]
   \   0000017C   0xF021 0x01E0      BIC      R1,R1,#0xE0
   \   00000180   0x6041             STR      R1,[R0, #+4]
   \   00000182   0x6861             LDR      R1,[R4, #+4]
   \   00000184   0xF5B1 0x7F82      CMP      R1,#+260
   \   00000188   0xD10A             BNE.N    ??HAL_SPI_Receive_18
   \   0000018A   0x68A1             LDR      R1,[R4, #+8]
   \   0000018C   0xF5B1 0x4F00      CMP      R1,#+32768
   \   00000190   0xBF18             IT       NE 
   \   00000192   0xF5B1 0x6F80      CMPNE    R1,#+1024
   \   00000196   0xD103             BNE.N    ??HAL_SPI_Receive_18
   \   00000198   0x6801             LDR      R1,[R0, #+0]
   \   0000019A   0xF021 0x0140      BIC      R1,R1,#0x40
   \   0000019E   0x6001             STR      R1,[R0, #+0]
   \                     ??HAL_SPI_Receive_18: (+1)
   \   000001A0   0x6AA1             LDR      R1,[R4, #+40]
   \   000001A2   0xF5B1 0x5F00      CMP      R1,#+8192
   \   000001A6   0xD108             BNE.N    ??HAL_SPI_Receive_19
   \   000001A8   0x6801             LDR      R1,[R0, #+0]
   \   000001AA   0xF64D 0x72FF      MOVW     R2,#+57343
   \   000001AE   0x4011             ANDS     R1,R2,R1
   \   000001B0   0x6001             STR      R1,[R0, #+0]
   \   000001B2   0x6801             LDR      R1,[R0, #+0]
   \   000001B4   0xF441 0x5100      ORR      R1,R1,#0x2000
   \   000001B8   0x6001             STR      R1,[R0, #+0]
   \                     ??HAL_SPI_Receive_19: (+1)
   \   000001BA   0x2001             MOVS     R0,#+1
   \   000001BC   0xF884 0x005D      STRB     R0,[R4, #+93]
   \   000001C0   0x2000             MOVS     R0,#+0
   \   000001C2   0xF884 0x005C      STRB     R0,[R4, #+92]
   \   000001C6   0x2003             MOVS     R0,#+3
   \   000001C8   0xB001             ADD      SP,SP,#+4
   \   000001CA   0xBDF0             POP      {R4-R7,PC}
   \                     ??HAL_SPI_Receive_17: (+1)
   \   000001CC   0x68E2             LDR      R2,[R4, #+12]
   \   000001CE   0x6C21             LDR      R1,[R4, #+64]
   \   000001D0   0x42B2             CMP      R2,R6
   \   000001D2   0xBF27             ITTEE    CS 
   \   000001D4   0x68C0             LDRCS    R0,[R0, #+12]
   \   000001D6   0xF821 0x0B02      STRHCS   R0,[R1], #+2
   \   000001DA   0x7B00             LDRBCC   R0,[R0, #+12]
   \   000001DC   0xF801 0x0B01      STRBCC   R0,[R1], #+1
   \   000001E0   0xF8B4 0x0046      LDRH     R0,[R4, #+70]
   \   000001E4   0x6421             STR      R1,[R4, #+64]
   \   000001E6   0x1E40             SUBS     R0,R0,#+1
   \   000001E8   0xF8A4 0x0046      STRH     R0,[R4, #+70]
   \   000001EC   0x6AA0             LDR      R0,[R4, #+40]
   \   000001EE   0xF5B0 0x5F00      CMP      R0,#+8192
   \   000001F2   0xF040 0x808D      BNE.W    ??HAL_SPI_Receive_20
   \   000001F6   0x.... 0x....      BL       HAL_GetTick
   \   000001FA   0x4607             MOV      R7,R0
   \                     ??HAL_SPI_Receive_21: (+1)
   \   000001FC   0x6820             LDR      R0,[R4, #+0]
   \   000001FE   0x6880             LDR      R0,[R0, #+8]
   \   00000200   0x07C0             LSLS     R0,R0,#+31
   \   00000202   0xD433             BMI.N    ??HAL_SPI_Receive_22
   \   00000204   0xF115 0x0F01      CMN      R5,#+1
   \   00000208   0xD0F8             BEQ.N    ??HAL_SPI_Receive_21
   \   0000020A   0xB125             CBZ.N    R5,??HAL_SPI_Receive_23
   \   0000020C   0x.... 0x....      BL       HAL_GetTick
   \   00000210   0x1BC0             SUBS     R0,R0,R7
   \   00000212   0x42A8             CMP      R0,R5
   \   00000214   0xD3F2             BCC.N    ??HAL_SPI_Receive_21
   \                     ??HAL_SPI_Receive_23: (+1)
   \   00000216   0x6820             LDR      R0,[R4, #+0]
   \   00000218   0x6841             LDR      R1,[R0, #+4]
   \   0000021A   0xF021 0x01E0      BIC      R1,R1,#0xE0
   \   0000021E   0x6041             STR      R1,[R0, #+4]
   \   00000220   0x6861             LDR      R1,[R4, #+4]
   \   00000222   0xF5B1 0x7F82      CMP      R1,#+260
   \   00000226   0xD10A             BNE.N    ??HAL_SPI_Receive_24
   \   00000228   0x68A1             LDR      R1,[R4, #+8]
   \   0000022A   0xF5B1 0x4F00      CMP      R1,#+32768
   \   0000022E   0xBF18             IT       NE 
   \   00000230   0xF5B1 0x6F80      CMPNE    R1,#+1024
   \   00000234   0xD103             BNE.N    ??HAL_SPI_Receive_24
   \   00000236   0x6801             LDR      R1,[R0, #+0]
   \   00000238   0xF021 0x0140      BIC      R1,R1,#0x40
   \   0000023C   0x6001             STR      R1,[R0, #+0]
   \                     ??HAL_SPI_Receive_24: (+1)
   \   0000023E   0x6AA1             LDR      R1,[R4, #+40]
   \   00000240   0xF5B1 0x5F00      CMP      R1,#+8192
   \   00000244   0xD108             BNE.N    ??HAL_SPI_Receive_25
   \   00000246   0x6801             LDR      R1,[R0, #+0]
   \   00000248   0xF64D 0x72FF      MOVW     R2,#+57343
   \   0000024C   0x4011             ANDS     R1,R2,R1
   \   0000024E   0x6001             STR      R1,[R0, #+0]
   \   00000250   0x6801             LDR      R1,[R0, #+0]
   \   00000252   0xF441 0x5100      ORR      R1,R1,#0x2000
   \   00000256   0x6001             STR      R1,[R0, #+0]
   \                     ??HAL_SPI_Receive_25: (+1)
   \   00000258   0x2001             MOVS     R0,#+1
   \   0000025A   0xF884 0x005D      STRB     R0,[R4, #+93]
   \   0000025E   0x2000             MOVS     R0,#+0
   \   00000260   0xF884 0x005C      STRB     R0,[R4, #+92]
   \   00000264   0x6E20             LDR      R0,[R4, #+96]
   \   00000266   0xF040 0x0002      ORR      R0,R0,#0x2
   \   0000026A   0x6620             STR      R0,[R4, #+96]
   \                     ??HAL_SPI_Receive_22: (+1)
   \   0000026C   0x68E0             LDR      R0,[R4, #+12]
   \   0000026E   0x6821             LDR      R1,[R4, #+0]
   \   00000270   0x42B0             CMP      R0,R6
   \   00000272   0xBF28             IT       CS 
   \   00000274   0x68C8             LDRCS    R0,[R1, #+12]
   \   00000276   0xD247             BCS.N    ??HAL_SPI_Receive_26
   \   00000278   0x7B09             LDRB     R1,[R1, #+12]
   \   0000027A   0xF5B0 0x6FE0      CMP      R0,#+1792
   \   0000027E   0xF8AD 0x1000      STRH     R1,[SP, #+0]
   \   00000282   0xF8BD 0x1000      LDRH     R1,[SP, #+0]
   \   00000286   0xBF04             ITT      EQ 
   \   00000288   0x6B20             LDREQ    R0,[R4, #+48]
   \   0000028A   0x2802             CMPEQ    R0,#+2
   \   0000028C   0xD140             BNE.N    ??HAL_SPI_Receive_20
   \   0000028E   0x.... 0x....      BL       HAL_GetTick
   \   00000292   0x4606             MOV      R6,R0
   \                     ??HAL_SPI_Receive_27: (+1)
   \   00000294   0x6820             LDR      R0,[R4, #+0]
   \   00000296   0x6880             LDR      R0,[R0, #+8]
   \   00000298   0x07C0             LSLS     R0,R0,#+31
   \   0000029A   0xD433             BMI.N    ??HAL_SPI_Receive_28
   \   0000029C   0xF115 0x0F01      CMN      R5,#+1
   \   000002A0   0xD0F8             BEQ.N    ??HAL_SPI_Receive_27
   \   000002A2   0xB125             CBZ.N    R5,??HAL_SPI_Receive_29
   \   000002A4   0x.... 0x....      BL       HAL_GetTick
   \   000002A8   0x1B80             SUBS     R0,R0,R6
   \   000002AA   0x42A8             CMP      R0,R5
   \   000002AC   0xD3F2             BCC.N    ??HAL_SPI_Receive_27
   \                     ??HAL_SPI_Receive_29: (+1)
   \   000002AE   0x6820             LDR      R0,[R4, #+0]
   \   000002B0   0x6841             LDR      R1,[R0, #+4]
   \   000002B2   0xF021 0x01E0      BIC      R1,R1,#0xE0
   \   000002B6   0x6041             STR      R1,[R0, #+4]
   \   000002B8   0x6861             LDR      R1,[R4, #+4]
   \   000002BA   0xF5B1 0x7F82      CMP      R1,#+260
   \   000002BE   0xD10A             BNE.N    ??HAL_SPI_Receive_30
   \   000002C0   0x68A1             LDR      R1,[R4, #+8]
   \   000002C2   0xF5B1 0x4F00      CMP      R1,#+32768
   \   000002C6   0xBF18             IT       NE 
   \   000002C8   0xF5B1 0x6F80      CMPNE    R1,#+1024
   \   000002CC   0xD103             BNE.N    ??HAL_SPI_Receive_30
   \   000002CE   0x6801             LDR      R1,[R0, #+0]
   \   000002D0   0xF021 0x0140      BIC      R1,R1,#0x40
   \   000002D4   0x6001             STR      R1,[R0, #+0]
   \                     ??HAL_SPI_Receive_30: (+1)
   \   000002D6   0x6AA1             LDR      R1,[R4, #+40]
   \   000002D8   0xF5B1 0x5F00      CMP      R1,#+8192
   \   000002DC   0xD108             BNE.N    ??HAL_SPI_Receive_31
   \   000002DE   0x6801             LDR      R1,[R0, #+0]
   \   000002E0   0xF64D 0x72FF      MOVW     R2,#+57343
   \   000002E4   0x4011             ANDS     R1,R2,R1
   \   000002E6   0x6001             STR      R1,[R0, #+0]
   \   000002E8   0x6801             LDR      R1,[R0, #+0]
   \   000002EA   0xF441 0x5100      ORR      R1,R1,#0x2000
   \   000002EE   0x6001             STR      R1,[R0, #+0]
   \                     ??HAL_SPI_Receive_31: (+1)
   \   000002F0   0x2001             MOVS     R0,#+1
   \   000002F2   0xF884 0x005D      STRB     R0,[R4, #+93]
   \   000002F6   0x2000             MOVS     R0,#+0
   \   000002F8   0xF884 0x005C      STRB     R0,[R4, #+92]
   \   000002FC   0x6E20             LDR      R0,[R4, #+96]
   \   000002FE   0xF040 0x0020      ORR      R0,R0,#0x20
   \   00000302   0x6620             STR      R0,[R4, #+96]
   \                     ??HAL_SPI_Receive_28: (+1)
   \   00000304   0x6820             LDR      R0,[R4, #+0]
   \   00000306   0x7B00             LDRB     R0,[R0, #+12]
   \                     ??HAL_SPI_Receive_26: (+1)
   \   00000308   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   \   0000030C   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \                     ??HAL_SPI_Receive_20: (+1)
   \   00000310   0x6860             LDR      R0,[R4, #+4]
   \   00000312   0xF5B0 0x7F82      CMP      R0,#+260
   \   00000316   0xD10B             BNE.N    ??HAL_SPI_Receive_32
   \   00000318   0x68A0             LDR      R0,[R4, #+8]
   \   0000031A   0xF5B0 0x4F00      CMP      R0,#+32768
   \   0000031E   0xBF18             IT       NE 
   \   00000320   0xF5B0 0x6F80      CMPNE    R0,#+1024
   \   00000324   0xD104             BNE.N    ??HAL_SPI_Receive_32
   \   00000326   0x6820             LDR      R0,[R4, #+0]
   \   00000328   0x6801             LDR      R1,[R0, #+0]
   \   0000032A   0xF021 0x0140      BIC      R1,R1,#0x40
   \   0000032E   0x6001             STR      R1,[R0, #+0]
   \                     ??HAL_SPI_Receive_32: (+1)
   \   00000330   0x.... 0x....      BL       HAL_GetTick
   \   00000334   0x4606             MOV      R6,R0
   \                     ??HAL_SPI_Receive_33: (+1)
   \   00000336   0x6820             LDR      R0,[R4, #+0]
   \   00000338   0x6880             LDR      R0,[R0, #+8]
   \   0000033A   0x0600             LSLS     R0,R0,#+24
   \   0000033C   0xD536             BPL.N    ??HAL_SPI_Receive_34
   \   0000033E   0xF115 0x0F01      CMN      R5,#+1
   \   00000342   0xD0F8             BEQ.N    ??HAL_SPI_Receive_33
   \   00000344   0xB125             CBZ.N    R5,??HAL_SPI_Receive_35
   \   00000346   0x.... 0x....      BL       HAL_GetTick
   \   0000034A   0x1B80             SUBS     R0,R0,R6
   \   0000034C   0x42A8             CMP      R0,R5
   \   0000034E   0xD3F2             BCC.N    ??HAL_SPI_Receive_33
   \                     ??HAL_SPI_Receive_35: (+1)
   \   00000350   0x6820             LDR      R0,[R4, #+0]
   \   00000352   0x6841             LDR      R1,[R0, #+4]
   \   00000354   0xF021 0x01E0      BIC      R1,R1,#0xE0
   \   00000358   0x6041             STR      R1,[R0, #+4]
   \   0000035A   0x6861             LDR      R1,[R4, #+4]
   \   0000035C   0xF5B1 0x7F82      CMP      R1,#+260
   \   00000360   0xD10A             BNE.N    ??HAL_SPI_Receive_36
   \   00000362   0x68A1             LDR      R1,[R4, #+8]
   \   00000364   0xF5B1 0x4F00      CMP      R1,#+32768
   \   00000368   0xBF18             IT       NE 
   \   0000036A   0xF5B1 0x6F80      CMPNE    R1,#+1024
   \   0000036E   0xD103             BNE.N    ??HAL_SPI_Receive_36
   \   00000370   0x6801             LDR      R1,[R0, #+0]
   \   00000372   0xF021 0x0140      BIC      R1,R1,#0x40
   \   00000376   0x6001             STR      R1,[R0, #+0]
   \                     ??HAL_SPI_Receive_36: (+1)
   \   00000378   0x6AA1             LDR      R1,[R4, #+40]
   \   0000037A   0xF5B1 0x5F00      CMP      R1,#+8192
   \   0000037E   0xD108             BNE.N    ??HAL_SPI_Receive_37
   \   00000380   0x6801             LDR      R1,[R0, #+0]
   \   00000382   0xF64D 0x72FF      MOVW     R2,#+57343
   \   00000386   0x4011             ANDS     R1,R2,R1
   \   00000388   0x6001             STR      R1,[R0, #+0]
   \   0000038A   0x6801             LDR      R1,[R0, #+0]
   \   0000038C   0xF441 0x5100      ORR      R1,R1,#0x2000
   \   00000390   0x6001             STR      R1,[R0, #+0]
   \                     ??HAL_SPI_Receive_37: (+1)
   \   00000392   0x2001             MOVS     R0,#+1
   \   00000394   0xF884 0x005D      STRB     R0,[R4, #+93]
   \   00000398   0x2000             MOVS     R0,#+0
   \   0000039A   0xF884 0x005C      STRB     R0,[R4, #+92]
   \   0000039E   0x6E20             LDR      R0,[R4, #+96]
   \   000003A0   0xF040 0x0020      ORR      R0,R0,#0x20
   \   000003A4   0x6620             STR      R0,[R4, #+96]
   \   000003A6   0x2003             MOVS     R0,#+3
   \   000003A8   0xB001             ADD      SP,SP,#+4
   \   000003AA   0xBDF0             POP      {R4-R7,PC}
   \                     ??HAL_SPI_Receive_34: (+1)
   \   000003AC   0x.... 0x....      BL       HAL_GetTick
   \   000003B0   0x4606             MOV      R6,R0
   \                     ??HAL_SPI_Receive_38: (+1)
   \   000003B2   0x6820             LDR      R0,[R4, #+0]
   \   000003B4   0x6881             LDR      R1,[R0, #+8]
   \   000003B6   0xF411 0x6FC0      TST      R1,#0x600
   \   000003BA   0xD00F             BEQ.N    ??HAL_SPI_Receive_39
   \   000003BC   0x7B00             LDRB     R0,[R0, #+12]
   \   000003BE   0xF115 0x0F01      CMN      R5,#+1
   \   000003C2   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \   000003C6   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   000003CA   0xD0F2             BEQ.N    ??HAL_SPI_Receive_38
   \   000003CC   0x2D00             CMP      R5,#+0
   \   000003CE   0xD0BF             BEQ.N    ??HAL_SPI_Receive_35
   \   000003D0   0x.... 0x....      BL       HAL_GetTick
   \   000003D4   0x1B80             SUBS     R0,R0,R6
   \   000003D6   0x42A8             CMP      R0,R5
   \   000003D8   0xD3EB             BCC.N    ??HAL_SPI_Receive_38
   \   000003DA   0xE7B9             B.N      ??HAL_SPI_Receive_35
   \                     ??HAL_SPI_Receive_39: (+1)
   \   000003DC   0x2101             MOVS     R1,#+1
   \   000003DE   0xF884 0x105D      STRB     R1,[R4, #+93]
   \   000003E2   0x6E21             LDR      R1,[R4, #+96]
   \   000003E4   0x6882             LDR      R2,[R0, #+8]
   \   000003E6   0x06D2             LSLS     R2,R2,#+27
   \   000003E8   0xD50B             BPL.N    ??HAL_SPI_Receive_40
   \   000003EA   0xF041 0x0102      ORR      R1,R1,#0x2
   \   000003EE   0x6621             STR      R1,[R4, #+96]
   \   000003F0   0xF64F 0x71EF      MOVW     R1,#+65519
   \   000003F4   0x6081             STR      R1,[R0, #+8]
   \   000003F6   0x2000             MOVS     R0,#+0
   \   000003F8   0xF884 0x005C      STRB     R0,[R4, #+92]
   \   000003FC   0x2001             MOVS     R0,#+1
   \   000003FE   0xB001             ADD      SP,SP,#+4
   \   00000400   0xBDF0             POP      {R4-R7,PC}
   \                     ??HAL_SPI_Receive_40: (+1)
   \   00000402   0x2000             MOVS     R0,#+0
   \   00000404   0xF884 0x005C      STRB     R0,[R4, #+92]
   \   00000408   0x1E48             SUBS     R0,R1,#+1
   \   0000040A   0x4180             SBCS     R0,R0,R0
   \   0000040C   0x43C0             MVNS     R0,R0
   \   0000040E   0x0FC0             LSRS     R0,R0,#+31
   \                     ??HAL_SPI_Receive_1: (+1)
   \   00000410   0xB001             ADD      SP,SP,#+4
   \   00000412   0xBDF0             POP      {R4-R7,PC}       ;; return
    726            }
    727          }
    728          
    729          /**
    730            * @brief  Transmit and Receive an amount of data in blocking mode
    731            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
    732            *               the configuration information for SPI module.
    733            * @param  pTxData: pointer to transmission data buffer
    734            * @param  pRxData: pointer to reception data buffer
    735            * @param  Size: amount of data to be sent and received
    736            * @param  Timeout: Timeout duration
    737            * @retval HAL status
    738            */

   \                                 In section .text, align 2, keep-with-next
    739          HAL_StatusTypeDef HAL_SPI_TransmitReceive(SPI_HandleTypeDef *hspi, uint8_t *pTxData, uint8_t *pRxData, uint16_t Size, uint32_t Timeout)
    740          {
   \                     HAL_SPI_TransmitReceive: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0xB082             SUB      SP,SP,#+8
    741            __IO uint16_t tmpreg = 0;
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x460D             MOV      R5,R1
   \   0000000C   0x4690             MOV      R8,R2
   \   0000000E   0x461F             MOV      R7,R3
   \   00000010   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    742            uint32_t tickstart = HAL_GetTick();
   \   00000014   0x.... 0x....      BL       HAL_GetTick
   \   00000018   0x4606             MOV      R6,R0
    743            
    744            assert_param(IS_SPI_DIRECTION_2LINES(hspi->Init.Direction));
    745            
    746            if(hspi->State != HAL_SPI_STATE_READY) 
   \   0000001A   0xF894 0x005D      LDRB     R0,[R4, #+93]
   \   0000001E   0x2801             CMP      R0,#+1
   \   00000020   0xD10A             BNE.N    ??HAL_SPI_TransmitReceive_0
    747            {
    748              return HAL_BUSY;
    749            }
    750            
    751            if((pTxData == NULL) || (pRxData == NULL) || (Size == 0))
   \   00000022   0x2D00             CMP      R5,#+0
   \   00000024   0xBF1C             ITT      NE 
   \   00000026   0xF1B8 0x0F00      CMPNE    R8,#+0
   \   0000002A   0x2F00             CMPNE    R7,#+0
   \   0000002C   0xF000 0x81F3      BEQ.W    ??HAL_SPI_TransmitReceive_1
    752            {
    753              return HAL_ERROR;
    754            }
    755          
    756            
    757            /* Process Locked */
    758            __HAL_LOCK(hspi); 
   \   00000030   0xF894 0x005C      LDRB     R0,[R4, #+92]
   \   00000034   0x2801             CMP      R0,#+1
   \   00000036   0xD103             BNE.N    ??HAL_SPI_TransmitReceive_2
   \                     ??HAL_SPI_TransmitReceive_0: (+1)
   \   00000038   0x2002             MOVS     R0,#+2
    759            
    760            hspi->State       = HAL_SPI_STATE_BUSY_TX_RX;
    761            hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
    762            hspi->pRxBuffPtr  = pRxData;
    763            hspi->RxXferCount = Size;
    764            hspi->RxXferSize  = Size;
    765            hspi->pTxBuffPtr  = pTxData;
    766            hspi->TxXferCount = Size;
    767            hspi->TxXferSize  = Size;
    768          
    769            /* Reset CRC Calculation */
    770            if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
    771            {
    772              SPI_RESET_CRC(hspi);
    773            }
    774          
    775            /* Set the Rx Fido threshold */
    776            if((hspi->Init.DataSize > SPI_DATASIZE_8BIT) || (hspi->RxXferCount > 1))
    777            {
    778              /* set fiforxthreshold according the reception data length: 16bit */
    779              CLEAR_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
    780            }
    781            else
    782            {
    783              /* set fiforxthreshold according the reception data length: 8bit */
    784              SET_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
    785            }
    786          
    787            /* Check if the SPI is already enabled */
    788            if((hspi->Instance->CR1 &SPI_CR1_SPE) != SPI_CR1_SPE)
    789            {
    790              /* Enable SPI peripheral */
    791              __HAL_SPI_ENABLE(hspi);
    792            }
    793          
    794            /* Transmit and Receive data in 16 Bit mode */
    795            if(hspi->Init.DataSize > SPI_DATASIZE_8BIT)
    796            {
    797              while ((hspi->TxXferCount > 0 ) || (hspi->RxXferCount > 0))
    798              {
    799                /* Check TXE flag */
    800                if((hspi->TxXferCount > 0) && ((hspi->Instance->SR & SPI_FLAG_TXE) == SPI_FLAG_TXE))
    801                {
    802                  hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
    803                  hspi->pTxBuffPtr += sizeof(uint16_t);
    804                  hspi->TxXferCount--;
    805          
    806                  /* Enable CRC Transmission */
    807                  if((hspi->TxXferCount == 0) && (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE))
    808                  {
    809                    SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
    810                  } 
    811                }
    812          
    813                /* Check RXNE flag */
    814                if((hspi->RxXferCount > 0) && ((hspi->Instance->SR & SPI_FLAG_RXNE) == SPI_FLAG_RXNE))
    815                {
    816                  *((uint16_t *)hspi->pRxBuffPtr) = hspi->Instance->DR;
    817                  hspi->pRxBuffPtr += sizeof(uint16_t);
    818                  hspi->RxXferCount--;
    819                }
    820                if(Timeout != HAL_MAX_DELAY)
    821                {
    822                  if((Timeout == 0) || ((HAL_GetTick()-tickstart) > Timeout)) 
    823                  {
    824                    hspi->State = HAL_SPI_STATE_READY;
    825                    __HAL_UNLOCK(hspi);
    826                    return HAL_TIMEOUT;
    827                  }
    828                }
    829              }
    830            }
    831            /* Transmit and Receive data in 8 Bit mode */
    832            else
    833            {
    834              while((hspi->TxXferCount > 0) || (hspi->RxXferCount > 0))
    835              {
    836                /* check TXE flag */
    837                if((hspi->TxXferCount > 0) && ((hspi->Instance->SR & SPI_FLAG_TXE) == SPI_FLAG_TXE))
    838                {
    839                  if(hspi->TxXferCount > 1)
    840                  {
    841                    hspi->Instance->DR = *((uint16_t*)hspi->pTxBuffPtr);
    842                    hspi->pTxBuffPtr += sizeof(uint16_t);
    843                    hspi->TxXferCount -= 2;
    844                  }
    845                  else
    846                  {
    847                    *(__IO uint8_t *)&hspi->Instance->DR = (*hspi->pTxBuffPtr++);
    848                    hspi->TxXferCount--;
    849                  }
    850          
    851                  /* Enable CRC Transmission */
    852                  if((hspi->TxXferCount == 0) && (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE))
    853                  {
    854                    SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
    855                  }
    856                }
    857          
    858                /* Wait until RXNE flag is reset */
    859                if((hspi->RxXferCount > 0) && ((hspi->Instance->SR & SPI_FLAG_RXNE) == SPI_FLAG_RXNE))
    860                {
    861                  if(hspi->RxXferCount > 1)
    862                  {
    863                    *((uint16_t*)hspi->pRxBuffPtr) = hspi->Instance->DR;
    864                    hspi->pRxBuffPtr += sizeof(uint16_t);
    865                    hspi->RxXferCount -= 2;
    866                    if(hspi->RxXferCount <= 1)
    867                    {
    868                      /* set fiforxthreshold before to switch on 8 bit data size */
    869                      SET_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
    870                    }
    871                  }
    872                  else
    873                  {
    874                    (*hspi->pRxBuffPtr++) =  *(__IO uint8_t *)&hspi->Instance->DR;
    875                    hspi->RxXferCount--;
    876                  }
    877                }
    878                if(Timeout != HAL_MAX_DELAY)
    879                {
    880                  if((Timeout == 0) || ((HAL_GetTick()-tickstart) > Timeout))
    881                  {
    882                    hspi->State = HAL_SPI_STATE_READY;
    883                    __HAL_UNLOCK(hspi);
    884                    return HAL_TIMEOUT;
    885                  }
    886                }
    887              }
    888            }
    889          
    890            /* Read CRC from DR to close CRC calculation process */
    891            if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
    892            {
    893              /* Wait until TXE flag */
    894              if(SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_RXNE, SPI_FLAG_RXNE, Timeout) != HAL_OK)
    895              {
    896                /* Error on the CRC reception */
    897                hspi->ErrorCode|= HAL_SPI_ERROR_CRC;
    898              }
    899          
    900              if(hspi->Init.DataSize == SPI_DATASIZE_16BIT)
    901              {
    902                tmpreg = hspi->Instance->DR;
    903                UNUSED(tmpreg); /* To avoid GCC warning */
    904              }
    905              else
    906              {
    907                tmpreg = *(__IO uint8_t *)&hspi->Instance->DR;
    908                UNUSED(tmpreg); /* To avoid GCC warning */
    909          
    910                if(hspi->Init.CRCLength == SPI_CRC_LENGTH_16BIT)
    911                {
    912                  if(SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_RXNE, SPI_FLAG_RXNE, Timeout) != HAL_OK)
    913                  {
    914                    /* Error on the CRC reception */
    915                    hspi->ErrorCode|= HAL_SPI_ERROR_CRC;
    916                  }
    917                  tmpreg = *(__IO uint8_t *)&hspi->Instance->DR;
    918                  UNUSED(tmpreg); /* To avoid GCC warning */
    919                }
    920              }
    921            }
    922          
    923            /* Check the end of the transaction */
    924            if(SPI_EndRxTxTransaction(hspi,Timeout) != HAL_OK)
    925            {
    926              return HAL_TIMEOUT;
    927            }
    928          
    929            hspi->State = HAL_SPI_STATE_READY;
    930            
    931            /* Check if CRC error occurred */
    932            if(__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_CRCERR) != RESET)
    933            {
    934              hspi->ErrorCode|= HAL_SPI_ERROR_CRC;
    935              /* Clear CRC Flag */
    936              __HAL_SPI_CLEAR_CRCERRFLAG(hspi);
    937              
    938              /* Process Unlocked */
    939              __HAL_UNLOCK(hspi);
    940              
    941              return HAL_ERROR;
    942            }
    943            
    944            /* Process Unlocked */
    945            __HAL_UNLOCK(hspi);
    946            
    947            if(hspi->ErrorCode != HAL_SPI_ERROR_NONE)
    948            {   
    949              return HAL_ERROR;
    950            }
    951            else
    952            {
    953              return HAL_OK;
   \   0000003A   0xB002             ADD      SP,SP,#+8
   \   0000003C   0xE8BD 0x81F0      POP      {R4-R8,PC}
   \                     ??HAL_SPI_TransmitReceive_2: (+1)
   \   00000040   0x2001             MOVS     R0,#+1
   \   00000042   0xF8C4 0x8040      STR      R8,[R4, #+64]
   \   00000046   0xF884 0x005C      STRB     R0,[R4, #+92]
   \   0000004A   0x2005             MOVS     R0,#+5
   \   0000004C   0xF884 0x005D      STRB     R0,[R4, #+93]
   \   00000050   0x2000             MOVS     R0,#+0
   \   00000052   0x6620             STR      R0,[R4, #+96]
   \   00000054   0xF8A4 0x7046      STRH     R7,[R4, #+70]
   \   00000058   0xF8A4 0x7044      STRH     R7,[R4, #+68]
   \   0000005C   0x63A5             STR      R5,[R4, #+56]
   \   0000005E   0x87E7             STRH     R7,[R4, #+62]
   \   00000060   0x87A7             STRH     R7,[R4, #+60]
   \   00000062   0x6AA0             LDR      R0,[R4, #+40]
   \   00000064   0xF5B0 0x5F00      CMP      R0,#+8192
   \   00000068   0xD109             BNE.N    ??HAL_SPI_TransmitReceive_3
   \   0000006A   0x6820             LDR      R0,[R4, #+0]
   \   0000006C   0xF64D 0x72FF      MOVW     R2,#+57343
   \   00000070   0x6801             LDR      R1,[R0, #+0]
   \   00000072   0x4011             ANDS     R1,R2,R1
   \   00000074   0x6001             STR      R1,[R0, #+0]
   \   00000076   0x6801             LDR      R1,[R0, #+0]
   \   00000078   0xF441 0x5100      ORR      R1,R1,#0x2000
   \   0000007C   0x6001             STR      R1,[R0, #+0]
   \                     ??HAL_SPI_TransmitReceive_3: (+1)
   \   0000007E   0x68E0             LDR      R0,[R4, #+12]
   \   00000080   0xF240 0x7101      MOVW     R1,#+1793
   \   00000084   0x4288             CMP      R0,R1
   \   00000086   0xD203             BCS.N    ??HAL_SPI_TransmitReceive_4
   \   00000088   0xF8B4 0x0046      LDRH     R0,[R4, #+70]
   \   0000008C   0x2802             CMP      R0,#+2
   \   0000008E   0xDB04             BLT.N    ??HAL_SPI_TransmitReceive_5
   \                     ??HAL_SPI_TransmitReceive_4: (+1)
   \   00000090   0x6820             LDR      R0,[R4, #+0]
   \   00000092   0x6842             LDR      R2,[R0, #+4]
   \   00000094   0xF422 0x5280      BIC      R2,R2,#0x1000
   \   00000098   0xE003             B.N      ??HAL_SPI_TransmitReceive_6
   \                     ??HAL_SPI_TransmitReceive_5: (+1)
   \   0000009A   0x6820             LDR      R0,[R4, #+0]
   \   0000009C   0x6842             LDR      R2,[R0, #+4]
   \   0000009E   0xF442 0x5280      ORR      R2,R2,#0x1000
   \                     ??HAL_SPI_TransmitReceive_6: (+1)
   \   000000A2   0x6042             STR      R2,[R0, #+4]
   \   000000A4   0x6820             LDR      R0,[R4, #+0]
   \   000000A6   0x6802             LDR      R2,[R0, #+0]
   \   000000A8   0x0652             LSLS     R2,R2,#+25
   \   000000AA   0xD403             BMI.N    ??HAL_SPI_TransmitReceive_7
   \   000000AC   0x6802             LDR      R2,[R0, #+0]
   \   000000AE   0xF042 0x0240      ORR      R2,R2,#0x40
   \   000000B2   0x6002             STR      R2,[R0, #+0]
   \                     ??HAL_SPI_TransmitReceive_7: (+1)
   \   000000B4   0x68E0             LDR      R0,[R4, #+12]
   \   000000B6   0x9D08             LDR      R5,[SP, #+32]
   \   000000B8   0x4288             CMP      R0,R1
   \   000000BA   0xF0C0 0x8082      BCC.W    ??HAL_SPI_TransmitReceive_8
   \                     ??HAL_SPI_TransmitReceive_9: (+1)
   \   000000BE   0x8FE1             LDRH     R1,[R4, #+62]
   \   000000C0   0x2900             CMP      R1,#+0
   \   000000C2   0xD14B             BNE.N    ??HAL_SPI_TransmitReceive_10
   \   000000C4   0xF8B4 0x0046      LDRH     R0,[R4, #+70]
   \   000000C8   0x2800             CMP      R0,#+0
   \   000000CA   0xD15D             BNE.N    ??HAL_SPI_TransmitReceive_11
   \                     ??HAL_SPI_TransmitReceive_12: (+1)
   \   000000CC   0x6AA0             LDR      R0,[R4, #+40]
   \   000000CE   0xF5B0 0x5F00      CMP      R0,#+8192
   \   000000D2   0xF040 0x811D      BNE.W    ??HAL_SPI_TransmitReceive_13
   \   000000D6   0x.... 0x....      BL       HAL_GetTick
   \   000000DA   0x4606             MOV      R6,R0
   \                     ??HAL_SPI_TransmitReceive_14: (+1)
   \   000000DC   0x6820             LDR      R0,[R4, #+0]
   \   000000DE   0x6880             LDR      R0,[R0, #+8]
   \   000000E0   0x07C0             LSLS     R0,R0,#+31
   \   000000E2   0xD433             BMI.N    ??HAL_SPI_TransmitReceive_15
   \   000000E4   0xF115 0x0F01      CMN      R5,#+1
   \   000000E8   0xD0F8             BEQ.N    ??HAL_SPI_TransmitReceive_14
   \   000000EA   0xB125             CBZ.N    R5,??HAL_SPI_TransmitReceive_16
   \   000000EC   0x.... 0x....      BL       HAL_GetTick
   \   000000F0   0x1B80             SUBS     R0,R0,R6
   \   000000F2   0x42A8             CMP      R0,R5
   \   000000F4   0xD3F2             BCC.N    ??HAL_SPI_TransmitReceive_14
   \                     ??HAL_SPI_TransmitReceive_16: (+1)
   \   000000F6   0x6820             LDR      R0,[R4, #+0]
   \   000000F8   0x6841             LDR      R1,[R0, #+4]
   \   000000FA   0xF021 0x01E0      BIC      R1,R1,#0xE0
   \   000000FE   0x6041             STR      R1,[R0, #+4]
   \   00000100   0x6861             LDR      R1,[R4, #+4]
   \   00000102   0xF5B1 0x7F82      CMP      R1,#+260
   \   00000106   0xD10A             BNE.N    ??HAL_SPI_TransmitReceive_17
   \   00000108   0x68A1             LDR      R1,[R4, #+8]
   \   0000010A   0xF5B1 0x4F00      CMP      R1,#+32768
   \   0000010E   0xBF18             IT       NE 
   \   00000110   0xF5B1 0x6F80      CMPNE    R1,#+1024
   \   00000114   0xD103             BNE.N    ??HAL_SPI_TransmitReceive_17
   \   00000116   0x6801             LDR      R1,[R0, #+0]
   \   00000118   0xF021 0x0140      BIC      R1,R1,#0x40
   \   0000011C   0x6001             STR      R1,[R0, #+0]
   \                     ??HAL_SPI_TransmitReceive_17: (+1)
   \   0000011E   0x6AA1             LDR      R1,[R4, #+40]
   \   00000120   0xF5B1 0x5F00      CMP      R1,#+8192
   \   00000124   0xD108             BNE.N    ??HAL_SPI_TransmitReceive_18
   \   00000126   0x6801             LDR      R1,[R0, #+0]
   \   00000128   0xF64D 0x72FF      MOVW     R2,#+57343
   \   0000012C   0x4011             ANDS     R1,R2,R1
   \   0000012E   0x6001             STR      R1,[R0, #+0]
   \   00000130   0x6801             LDR      R1,[R0, #+0]
   \   00000132   0xF441 0x5100      ORR      R1,R1,#0x2000
   \   00000136   0x6001             STR      R1,[R0, #+0]
   \                     ??HAL_SPI_TransmitReceive_18: (+1)
   \   00000138   0x2001             MOVS     R0,#+1
   \   0000013A   0xF884 0x005D      STRB     R0,[R4, #+93]
   \   0000013E   0x2000             MOVS     R0,#+0
   \   00000140   0xF884 0x005C      STRB     R0,[R4, #+92]
   \   00000144   0x6E20             LDR      R0,[R4, #+96]
   \   00000146   0xF040 0x0002      ORR      R0,R0,#0x2
   \   0000014A   0x6620             STR      R0,[R4, #+96]
   \                     ??HAL_SPI_TransmitReceive_15: (+1)
   \   0000014C   0x68E1             LDR      R1,[R4, #+12]
   \   0000014E   0x6820             LDR      R0,[R4, #+0]
   \   00000150   0xF5B1 0x6F70      CMP      R1,#+3840
   \   00000154   0xF040 0x8093      BNE.W    ??HAL_SPI_TransmitReceive_19
   \   00000158   0x68C0             LDR      R0,[R0, #+12]
   \   0000015A   0xE0D5             B.N      ??HAL_SPI_TransmitReceive_20
   \                     ??HAL_SPI_TransmitReceive_10: (+1)
   \   0000015C   0x6820             LDR      R0,[R4, #+0]
   \   0000015E   0x6882             LDR      R2,[R0, #+8]
   \   00000160   0x0792             LSLS     R2,R2,#+30
   \   00000162   0xD511             BPL.N    ??HAL_SPI_TransmitReceive_11
   \   00000164   0x6BA2             LDR      R2,[R4, #+56]
   \   00000166   0x1E49             SUBS     R1,R1,#+1
   \   00000168   0xF832 0x3B02      LDRH     R3,[R2], #+2
   \   0000016C   0x60C3             STR      R3,[R0, #+12]
   \   0000016E   0x87E1             STRH     R1,[R4, #+62]
   \   00000170   0xB289             UXTH     R1,R1
   \   00000172   0x2900             CMP      R1,#+0
   \   00000174   0x63A2             STR      R2,[R4, #+56]
   \   00000176   0xBF04             ITT      EQ 
   \   00000178   0x6AA1             LDREQ    R1,[R4, #+40]
   \   0000017A   0xF5B1 0x5F00      CMPEQ    R1,#+8192
   \   0000017E   0xD103             BNE.N    ??HAL_SPI_TransmitReceive_11
   \   00000180   0x6801             LDR      R1,[R0, #+0]
   \   00000182   0xF441 0x5180      ORR      R1,R1,#0x1000
   \   00000186   0x6001             STR      R1,[R0, #+0]
   \                     ??HAL_SPI_TransmitReceive_11: (+1)
   \   00000188   0xF8B4 0x0046      LDRH     R0,[R4, #+70]
   \   0000018C   0xB168             CBZ.N    R0,??HAL_SPI_TransmitReceive_21
   \   0000018E   0x6820             LDR      R0,[R4, #+0]
   \   00000190   0x6881             LDR      R1,[R0, #+8]
   \   00000192   0x07C9             LSLS     R1,R1,#+31
   \   00000194   0xD509             BPL.N    ??HAL_SPI_TransmitReceive_21
   \   00000196   0x6C21             LDR      R1,[R4, #+64]
   \   00000198   0x68C0             LDR      R0,[R0, #+12]
   \   0000019A   0x8008             STRH     R0,[R1, #+0]
   \   0000019C   0x1C88             ADDS     R0,R1,#+2
   \   0000019E   0x6420             STR      R0,[R4, #+64]
   \   000001A0   0xF8B4 0x0046      LDRH     R0,[R4, #+70]
   \   000001A4   0x1E40             SUBS     R0,R0,#+1
   \   000001A6   0xF8A4 0x0046      STRH     R0,[R4, #+70]
   \                     ??HAL_SPI_TransmitReceive_21: (+1)
   \   000001AA   0xF115 0x0F01      CMN      R5,#+1
   \   000001AE   0xD086             BEQ.N    ??HAL_SPI_TransmitReceive_9
   \   000001B0   0x2D00             CMP      R5,#+0
   \   000001B2   0xD05A             BEQ.N    ??HAL_SPI_TransmitReceive_22
   \   000001B4   0x.... 0x....      BL       HAL_GetTick
   \   000001B8   0x1B80             SUBS     R0,R0,R6
   \   000001BA   0x4285             CMP      R5,R0
   \   000001BC   0xF4BF 0xAF7F      BCS.W    ??HAL_SPI_TransmitReceive_9
   \   000001C0   0xE053             B.N      ??HAL_SPI_TransmitReceive_22
   \                     ??HAL_SPI_TransmitReceive_8: (+1)
   \   000001C2   0x8FE1             LDRH     R1,[R4, #+62]
   \   000001C4   0xB919             CBNZ.N   R1,??HAL_SPI_TransmitReceive_23
   \   000001C6   0xF8B4 0x0046      LDRH     R0,[R4, #+70]
   \   000001CA   0xBB08             CBNZ.N   R0,??HAL_SPI_TransmitReceive_24
   \   000001CC   0xE77E             B.N      ??HAL_SPI_TransmitReceive_12
   \                     ??HAL_SPI_TransmitReceive_23: (+1)
   \   000001CE   0x6820             LDR      R0,[R4, #+0]
   \   000001D0   0x6882             LDR      R2,[R0, #+8]
   \   000001D2   0x0792             LSLS     R2,R2,#+30
   \   000001D4   0xD51C             BPL.N    ??HAL_SPI_TransmitReceive_24
   \   000001D6   0x2902             CMP      R1,#+2
   \   000001D8   0xDB06             BLT.N    ??HAL_SPI_TransmitReceive_25
   \   000001DA   0x6BA2             LDR      R2,[R4, #+56]
   \   000001DC   0x1E89             SUBS     R1,R1,#+2
   \   000001DE   0xF832 0x3B02      LDRH     R3,[R2], #+2
   \   000001E2   0x60C3             STR      R3,[R0, #+12]
   \   000001E4   0x63A2             STR      R2,[R4, #+56]
   \   000001E6   0xE007             B.N      ??HAL_SPI_TransmitReceive_26
   \                     ??HAL_SPI_TransmitReceive_25: (+1)
   \   000001E8   0x6BA1             LDR      R1,[R4, #+56]
   \   000001EA   0x1C49             ADDS     R1,R1,#+1
   \   000001EC   0x63A1             STR      R1,[R4, #+56]
   \   000001EE   0x1E49             SUBS     R1,R1,#+1
   \   000001F0   0x7809             LDRB     R1,[R1, #+0]
   \   000001F2   0x7301             STRB     R1,[R0, #+12]
   \   000001F4   0x8FE1             LDRH     R1,[R4, #+62]
   \   000001F6   0x1E49             SUBS     R1,R1,#+1
   \                     ??HAL_SPI_TransmitReceive_26: (+1)
   \   000001F8   0x87E1             STRH     R1,[R4, #+62]
   \   000001FA   0x8FE1             LDRH     R1,[R4, #+62]
   \   000001FC   0x2900             CMP      R1,#+0
   \   000001FE   0xBF04             ITT      EQ 
   \   00000200   0x6AA1             LDREQ    R1,[R4, #+40]
   \   00000202   0xF5B1 0x5F00      CMPEQ    R1,#+8192
   \   00000206   0xD103             BNE.N    ??HAL_SPI_TransmitReceive_24
   \   00000208   0x6801             LDR      R1,[R0, #+0]
   \   0000020A   0xF441 0x5180      ORR      R1,R1,#0x1000
   \   0000020E   0x6001             STR      R1,[R0, #+0]
   \                     ??HAL_SPI_TransmitReceive_24: (+1)
   \   00000210   0xF8B4 0x1046      LDRH     R1,[R4, #+70]
   \   00000214   0xB301             CBZ.N    R1,??HAL_SPI_TransmitReceive_27
   \   00000216   0x6820             LDR      R0,[R4, #+0]
   \   00000218   0x6882             LDR      R2,[R0, #+8]
   \   0000021A   0x07D2             LSLS     R2,R2,#+31
   \   0000021C   0xD51C             BPL.N    ??HAL_SPI_TransmitReceive_27
   \   0000021E   0x2902             CMP      R1,#+2
   \   00000220   0x6C22             LDR      R2,[R4, #+64]
   \   00000222   0xDB10             BLT.N    ??HAL_SPI_TransmitReceive_28
   \   00000224   0x68C1             LDR      R1,[R0, #+12]
   \   00000226   0x8011             STRH     R1,[R2, #+0]
   \   00000228   0x1C91             ADDS     R1,R2,#+2
   \   0000022A   0x6421             STR      R1,[R4, #+64]
   \   0000022C   0xF8B4 0x1046      LDRH     R1,[R4, #+70]
   \   00000230   0x1E89             SUBS     R1,R1,#+2
   \   00000232   0xF8A4 0x1046      STRH     R1,[R4, #+70]
   \   00000236   0xB289             UXTH     R1,R1
   \   00000238   0x2902             CMP      R1,#+2
   \   0000023A   0xDA0D             BGE.N    ??HAL_SPI_TransmitReceive_27
   \   0000023C   0x6841             LDR      R1,[R0, #+4]
   \   0000023E   0xF441 0x5180      ORR      R1,R1,#0x1000
   \   00000242   0x6041             STR      R1,[R0, #+4]
   \   00000244   0xE008             B.N      ??HAL_SPI_TransmitReceive_27
   \                     ??HAL_SPI_TransmitReceive_28: (+1)
   \   00000246   0x1C51             ADDS     R1,R2,#+1
   \   00000248   0x6421             STR      R1,[R4, #+64]
   \   0000024A   0x7B00             LDRB     R0,[R0, #+12]
   \   0000024C   0x7010             STRB     R0,[R2, #+0]
   \   0000024E   0xF8B4 0x0046      LDRH     R0,[R4, #+70]
   \   00000252   0x1E40             SUBS     R0,R0,#+1
   \   00000254   0xF8A4 0x0046      STRH     R0,[R4, #+70]
   \                     ??HAL_SPI_TransmitReceive_27: (+1)
   \   00000258   0xF115 0x0F01      CMN      R5,#+1
   \   0000025C   0xD0B1             BEQ.N    ??HAL_SPI_TransmitReceive_8
   \   0000025E   0xB125             CBZ.N    R5,??HAL_SPI_TransmitReceive_22
   \   00000260   0x.... 0x....      BL       HAL_GetTick
   \   00000264   0x1B80             SUBS     R0,R0,R6
   \   00000266   0x4285             CMP      R5,R0
   \   00000268   0xD2AB             BCS.N    ??HAL_SPI_TransmitReceive_8
   \                     ??HAL_SPI_TransmitReceive_22: (+1)
   \   0000026A   0x2001             MOVS     R0,#+1
   \   0000026C   0xF884 0x005D      STRB     R0,[R4, #+93]
   \   00000270   0x2000             MOVS     R0,#+0
   \   00000272   0xF884 0x005C      STRB     R0,[R4, #+92]
   \   00000276   0x2003             MOVS     R0,#+3
   \   00000278   0xB002             ADD      SP,SP,#+8
   \   0000027A   0xE8BD 0x81F0      POP      {R4-R8,PC}
   \                     ??HAL_SPI_TransmitReceive_19: (+1)
   \   0000027E   0x7B00             LDRB     R0,[R0, #+12]
   \   00000280   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   \   00000284   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   00000288   0x6B20             LDR      R0,[R4, #+48]
   \   0000028A   0x2802             CMP      R0,#+2
   \   0000028C   0xD140             BNE.N    ??HAL_SPI_TransmitReceive_13
   \   0000028E   0x.... 0x....      BL       HAL_GetTick
   \   00000292   0x4606             MOV      R6,R0
   \                     ??HAL_SPI_TransmitReceive_29: (+1)
   \   00000294   0x6820             LDR      R0,[R4, #+0]
   \   00000296   0x6880             LDR      R0,[R0, #+8]
   \   00000298   0x07C0             LSLS     R0,R0,#+31
   \   0000029A   0xD433             BMI.N    ??HAL_SPI_TransmitReceive_30
   \   0000029C   0xF115 0x0F01      CMN      R5,#+1
   \   000002A0   0xD0F8             BEQ.N    ??HAL_SPI_TransmitReceive_29
   \   000002A2   0xB125             CBZ.N    R5,??HAL_SPI_TransmitReceive_31
   \   000002A4   0x.... 0x....      BL       HAL_GetTick
   \   000002A8   0x1B80             SUBS     R0,R0,R6
   \   000002AA   0x42A8             CMP      R0,R5
   \   000002AC   0xD3F2             BCC.N    ??HAL_SPI_TransmitReceive_29
   \                     ??HAL_SPI_TransmitReceive_31: (+1)
   \   000002AE   0x6820             LDR      R0,[R4, #+0]
   \   000002B0   0x6841             LDR      R1,[R0, #+4]
   \   000002B2   0xF021 0x01E0      BIC      R1,R1,#0xE0
   \   000002B6   0x6041             STR      R1,[R0, #+4]
   \   000002B8   0x6861             LDR      R1,[R4, #+4]
   \   000002BA   0xF5B1 0x7F82      CMP      R1,#+260
   \   000002BE   0xD10A             BNE.N    ??HAL_SPI_TransmitReceive_32
   \   000002C0   0x68A1             LDR      R1,[R4, #+8]
   \   000002C2   0xF5B1 0x4F00      CMP      R1,#+32768
   \   000002C6   0xBF18             IT       NE 
   \   000002C8   0xF5B1 0x6F80      CMPNE    R1,#+1024
   \   000002CC   0xD103             BNE.N    ??HAL_SPI_TransmitReceive_32
   \   000002CE   0x6801             LDR      R1,[R0, #+0]
   \   000002D0   0xF021 0x0140      BIC      R1,R1,#0x40
   \   000002D4   0x6001             STR      R1,[R0, #+0]
   \                     ??HAL_SPI_TransmitReceive_32: (+1)
   \   000002D6   0x6AA1             LDR      R1,[R4, #+40]
   \   000002D8   0xF5B1 0x5F00      CMP      R1,#+8192
   \   000002DC   0xD108             BNE.N    ??HAL_SPI_TransmitReceive_33
   \   000002DE   0x6801             LDR      R1,[R0, #+0]
   \   000002E0   0xF64D 0x72FF      MOVW     R2,#+57343
   \   000002E4   0x4011             ANDS     R1,R2,R1
   \   000002E6   0x6001             STR      R1,[R0, #+0]
   \   000002E8   0x6801             LDR      R1,[R0, #+0]
   \   000002EA   0xF441 0x5100      ORR      R1,R1,#0x2000
   \   000002EE   0x6001             STR      R1,[R0, #+0]
   \                     ??HAL_SPI_TransmitReceive_33: (+1)
   \   000002F0   0x2001             MOVS     R0,#+1
   \   000002F2   0xF884 0x005D      STRB     R0,[R4, #+93]
   \   000002F6   0x2000             MOVS     R0,#+0
   \   000002F8   0xF884 0x005C      STRB     R0,[R4, #+92]
   \   000002FC   0x6E20             LDR      R0,[R4, #+96]
   \   000002FE   0xF040 0x0002      ORR      R0,R0,#0x2
   \   00000302   0x6620             STR      R0,[R4, #+96]
   \                     ??HAL_SPI_TransmitReceive_30: (+1)
   \   00000304   0x6820             LDR      R0,[R4, #+0]
   \   00000306   0x7B00             LDRB     R0,[R0, #+12]
   \                     ??HAL_SPI_TransmitReceive_20: (+1)
   \   00000308   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   \   0000030C   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \                     ??HAL_SPI_TransmitReceive_13: (+1)
   \   00000310   0x.... 0x....      BL       HAL_GetTick
   \   00000314   0x4606             MOV      R6,R0
   \                     ??HAL_SPI_TransmitReceive_34: (+1)
   \   00000316   0x6820             LDR      R0,[R4, #+0]
   \   00000318   0x6880             LDR      R0,[R0, #+8]
   \   0000031A   0xF410 0x5FC0      TST      R0,#0x1800
   \   0000031E   0xD009             BEQ.N    ??HAL_SPI_TransmitReceive_35
   \   00000320   0xF115 0x0F01      CMN      R5,#+1
   \   00000324   0xD0F7             BEQ.N    ??HAL_SPI_TransmitReceive_34
   \   00000326   0xB365             CBZ.N    R5,??HAL_SPI_TransmitReceive_36
   \   00000328   0x.... 0x....      BL       HAL_GetTick
   \   0000032C   0x1B80             SUBS     R0,R0,R6
   \   0000032E   0x42A8             CMP      R0,R5
   \   00000330   0xD3F1             BCC.N    ??HAL_SPI_TransmitReceive_34
   \   00000332   0xE026             B.N      ??HAL_SPI_TransmitReceive_36
   \                     ??HAL_SPI_TransmitReceive_35: (+1)
   \   00000334   0x.... 0x....      BL       HAL_GetTick
   \   00000338   0x4606             MOV      R6,R0
   \                     ??HAL_SPI_TransmitReceive_37: (+1)
   \   0000033A   0x6820             LDR      R0,[R4, #+0]
   \   0000033C   0x6880             LDR      R0,[R0, #+8]
   \   0000033E   0x0600             LSLS     R0,R0,#+24
   \   00000340   0xD509             BPL.N    ??HAL_SPI_TransmitReceive_38
   \   00000342   0xF115 0x0F01      CMN      R5,#+1
   \   00000346   0xD0F8             BEQ.N    ??HAL_SPI_TransmitReceive_37
   \   00000348   0xB1DD             CBZ.N    R5,??HAL_SPI_TransmitReceive_36
   \   0000034A   0x.... 0x....      BL       HAL_GetTick
   \   0000034E   0x1B80             SUBS     R0,R0,R6
   \   00000350   0x42A8             CMP      R0,R5
   \   00000352   0xD3F2             BCC.N    ??HAL_SPI_TransmitReceive_37
   \   00000354   0xE015             B.N      ??HAL_SPI_TransmitReceive_36
   \                     ??HAL_SPI_TransmitReceive_38: (+1)
   \   00000356   0x.... 0x....      BL       HAL_GetTick
   \   0000035A   0x4606             MOV      R6,R0
   \                     ??HAL_SPI_TransmitReceive_39: (+1)
   \   0000035C   0x6820             LDR      R0,[R4, #+0]
   \   0000035E   0x6881             LDR      R1,[R0, #+8]
   \   00000360   0xF411 0x6FC0      TST      R1,#0x600
   \   00000364   0xD03C             BEQ.N    ??HAL_SPI_TransmitReceive_40
   \   00000366   0x7B00             LDRB     R0,[R0, #+12]
   \   00000368   0xF115 0x0F01      CMN      R5,#+1
   \   0000036C   0xF88D 0x0002      STRB     R0,[SP, #+2]
   \   00000370   0xF89D 0x0002      LDRB     R0,[SP, #+2]
   \   00000374   0xD0F2             BEQ.N    ??HAL_SPI_TransmitReceive_39
   \   00000376   0xB125             CBZ.N    R5,??HAL_SPI_TransmitReceive_36
   \   00000378   0x.... 0x....      BL       HAL_GetTick
   \   0000037C   0x1B80             SUBS     R0,R0,R6
   \   0000037E   0x42A8             CMP      R0,R5
   \   00000380   0xD3EC             BCC.N    ??HAL_SPI_TransmitReceive_39
   \                     ??HAL_SPI_TransmitReceive_36: (+1)
   \   00000382   0x6820             LDR      R0,[R4, #+0]
   \   00000384   0x6841             LDR      R1,[R0, #+4]
   \   00000386   0xF021 0x01E0      BIC      R1,R1,#0xE0
   \   0000038A   0x6041             STR      R1,[R0, #+4]
   \   0000038C   0x6861             LDR      R1,[R4, #+4]
   \   0000038E   0xF5B1 0x7F82      CMP      R1,#+260
   \   00000392   0xD10A             BNE.N    ??HAL_SPI_TransmitReceive_41
   \   00000394   0x68A1             LDR      R1,[R4, #+8]
   \   00000396   0xF5B1 0x4F00      CMP      R1,#+32768
   \   0000039A   0xBF18             IT       NE 
   \   0000039C   0xF5B1 0x6F80      CMPNE    R1,#+1024
   \   000003A0   0xD103             BNE.N    ??HAL_SPI_TransmitReceive_41
   \   000003A2   0x6801             LDR      R1,[R0, #+0]
   \   000003A4   0xF021 0x0140      BIC      R1,R1,#0x40
   \   000003A8   0x6001             STR      R1,[R0, #+0]
   \                     ??HAL_SPI_TransmitReceive_41: (+1)
   \   000003AA   0x6AA1             LDR      R1,[R4, #+40]
   \   000003AC   0xF5B1 0x5F00      CMP      R1,#+8192
   \   000003B0   0xD108             BNE.N    ??HAL_SPI_TransmitReceive_42
   \   000003B2   0x6801             LDR      R1,[R0, #+0]
   \   000003B4   0xF64D 0x72FF      MOVW     R2,#+57343
   \   000003B8   0x4011             ANDS     R1,R2,R1
   \   000003BA   0x6001             STR      R1,[R0, #+0]
   \   000003BC   0x6801             LDR      R1,[R0, #+0]
   \   000003BE   0xF441 0x5100      ORR      R1,R1,#0x2000
   \   000003C2   0x6001             STR      R1,[R0, #+0]
   \                     ??HAL_SPI_TransmitReceive_42: (+1)
   \   000003C4   0x2001             MOVS     R0,#+1
   \   000003C6   0xF884 0x005D      STRB     R0,[R4, #+93]
   \   000003CA   0x2000             MOVS     R0,#+0
   \   000003CC   0xF884 0x005C      STRB     R0,[R4, #+92]
   \   000003D0   0x6E20             LDR      R0,[R4, #+96]
   \   000003D2   0xF040 0x0020      ORR      R0,R0,#0x20
   \   000003D6   0x6620             STR      R0,[R4, #+96]
   \   000003D8   0x2003             MOVS     R0,#+3
   \   000003DA   0xB002             ADD      SP,SP,#+8
   \   000003DC   0xE8BD 0x81F0      POP      {R4-R8,PC}
   \                     ??HAL_SPI_TransmitReceive_40: (+1)
   \   000003E0   0x2101             MOVS     R1,#+1
   \   000003E2   0xF884 0x105D      STRB     R1,[R4, #+93]
   \   000003E6   0x6E21             LDR      R1,[R4, #+96]
   \   000003E8   0x6882             LDR      R2,[R0, #+8]
   \   000003EA   0x06D2             LSLS     R2,R2,#+27
   \   000003EC   0xD50C             BPL.N    ??HAL_SPI_TransmitReceive_43
   \   000003EE   0xF041 0x0102      ORR      R1,R1,#0x2
   \   000003F2   0x6621             STR      R1,[R4, #+96]
   \   000003F4   0xF64F 0x71EF      MOVW     R1,#+65519
   \   000003F8   0x6081             STR      R1,[R0, #+8]
   \   000003FA   0x2000             MOVS     R0,#+0
   \   000003FC   0xF884 0x005C      STRB     R0,[R4, #+92]
   \   00000400   0x2001             MOVS     R0,#+1
   \   00000402   0xB002             ADD      SP,SP,#+8
   \   00000404   0xE8BD 0x81F0      POP      {R4-R8,PC}
   \                     ??HAL_SPI_TransmitReceive_43: (+1)
   \   00000408   0x2000             MOVS     R0,#+0
   \   0000040A   0xF884 0x005C      STRB     R0,[R4, #+92]
   \   0000040E   0x1E48             SUBS     R0,R1,#+1
   \   00000410   0x4180             SBCS     R0,R0,R0
   \   00000412   0x43C0             MVNS     R0,R0
   \   00000414   0x0FC0             LSRS     R0,R0,#+31
   \                     ??HAL_SPI_TransmitReceive_1: (+1)
   \   00000416   0xB002             ADD      SP,SP,#+8
   \   00000418   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    954            }
    955          }
    956          
    957          /**
    958            * @brief  Transmit an amount of data in no-blocking mode with Interrupt
    959            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
    960            *               the configuration information for SPI module.
    961            * @param  pData: pointer to data buffer
    962            * @param  Size: amount of data to be sent
    963            * @retval HAL status
    964            */

   \                                 In section .text, align 2, keep-with-next
    965          HAL_StatusTypeDef HAL_SPI_Transmit_IT(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size)
    966          {
    967            assert_param(IS_SPI_DIRECTION_2LINES_OR_1LINE(hspi->Init.Direction));
    968            
    969            if(hspi->State == HAL_SPI_STATE_READY)
   \                     HAL_SPI_Transmit_IT: (+1)
   \   00000000   0xF890 0x305D      LDRB     R3,[R0, #+93]
   \   00000004   0x2B01             CMP      R3,#+1
   \   00000006   0xD149             BNE.N    ??HAL_SPI_Transmit_IT_0
    970            {
    971              if((pData == NULL) || (Size == 0)) 
   \   00000008   0x2900             CMP      R1,#+0
   \   0000000A   0xBF18             IT       NE 
   \   0000000C   0x2A00             CMPNE    R2,#+0
   \   0000000E   0xD101             BNE.N    ??HAL_SPI_Transmit_IT_1
    972              {
    973                return  HAL_ERROR;                                    
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0x4770             BX       LR
    974              }
    975              
    976              /* Process Locked */
    977              __HAL_LOCK(hspi);
   \                     ??HAL_SPI_Transmit_IT_1: (+1)
   \   00000014   0xF890 0x305C      LDRB     R3,[R0, #+92]
   \   00000018   0x2B01             CMP      R3,#+1
   \   0000001A   0xD03F             BEQ.N    ??HAL_SPI_Transmit_IT_0
   \   0000001C   0x2301             MOVS     R3,#+1
    978              
    979              hspi->State       = HAL_SPI_STATE_BUSY_TX;
    980              hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
    981              hspi->pTxBuffPtr  = pData;
   \   0000001E   0x6381             STR      R1,[R0, #+56]
   \   00000020   0xF880 0x305C      STRB     R3,[R0, #+92]
   \   00000024   0x2303             MOVS     R3,#+3
    982              hspi->TxXferSize  = Size;
    983              hspi->TxXferCount = Size;
    984              hspi->pRxBuffPtr  = NULL;
    985              hspi->RxXferSize  = 0;
    986              hspi->RxXferCount = 0;
    987          
    988              /* Set the function for IT treatement */
    989              if(hspi->Init.DataSize > SPI_DATASIZE_8BIT )
   \   00000026   0x68C1             LDR      R1,[R0, #+12]
   \   00000028   0xF880 0x305D      STRB     R3,[R0, #+93]
   \   0000002C   0x2300             MOVS     R3,#+0
   \   0000002E   0x8782             STRH     R2,[R0, #+60]
   \   00000030   0xF5B1 0x6FE0      CMP      R1,#+1792
   \   00000034   0x6603             STR      R3,[R0, #+96]
   \   00000036   0x87C2             STRH     R2,[R0, #+62]
   \   00000038   0x6403             STR      R3,[R0, #+64]
   \   0000003A   0xF8A0 0x3044      STRH     R3,[R0, #+68]
   \   0000003E   0xF8A0 0x3046      STRH     R3,[R0, #+70]
   \   00000042   0xBF8C             ITE      HI 
   \   00000044   0x.... 0x....      LDRHI.W  R1,??DataTable2
   \   00000048   0x.... 0x....      LDRLS.W  R1,??DataTable2_1
    990              {
    991                hspi->RxISR = NULL;
    992                hspi->TxISR = SPI_TxISR_16BIT;
    993              }
    994              else
    995              {
    996                hspi->RxISR = NULL;
    997                hspi->TxISR = SPI_TxISR_8BIT;
    998              }
    999              
   1000              /* Configure communication direction : 1Line */
   1001              if(hspi->Init.Direction == SPI_DIRECTION_1LINE)
   \   0000004C   0x6882             LDR      R2,[R0, #+8]
   \   0000004E   0x6501             STR      R1,[R0, #+80]
   \   00000050   0x64C3             STR      R3,[R0, #+76]
   \   00000052   0x6801             LDR      R1,[R0, #+0]
   \   00000054   0xF5B2 0x4F00      CMP      R2,#+32768
   \   00000058   0xD103             BNE.N    ??HAL_SPI_Transmit_IT_2
   1002              {
   1003                SPI_1LINE_TX(hspi);
   \   0000005A   0x680A             LDR      R2,[R1, #+0]
   \   0000005C   0xF442 0x4280      ORR      R2,R2,#0x4000
   \   00000060   0x600A             STR      R2,[R1, #+0]
   1004              }
   1005              
   1006              /* Reset CRC Calculation */
   1007              if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   \                     ??HAL_SPI_Transmit_IT_2: (+1)
   \   00000062   0x6A82             LDR      R2,[R0, #+40]
   \   00000064   0xF5B2 0x5F00      CMP      R2,#+8192
   \   00000068   0xD108             BNE.N    ??HAL_SPI_Transmit_IT_3
   1008              {
   1009                SPI_RESET_CRC(hspi);    
   \   0000006A   0x680A             LDR      R2,[R1, #+0]
   \   0000006C   0xF64D 0x73FF      MOVW     R3,#+57343
   \   00000070   0x401A             ANDS     R2,R3,R2
   \   00000072   0x600A             STR      R2,[R1, #+0]
   \   00000074   0x680A             LDR      R2,[R1, #+0]
   \   00000076   0xF442 0x5200      ORR      R2,R2,#0x2000
   \   0000007A   0x600A             STR      R2,[R1, #+0]
   1010              }
   1011              
   1012              /* Enable TXE and ERR interrupt */
   1013              __HAL_SPI_ENABLE_IT(hspi,(SPI_IT_TXE));
   \                     ??HAL_SPI_Transmit_IT_3: (+1)
   \   0000007C   0x684A             LDR      R2,[R1, #+4]
   \   0000007E   0xF042 0x0280      ORR      R2,R2,#0x80
   \   00000082   0x604A             STR      R2,[R1, #+4]
   1014          
   1015              /* Process Unlocked */
   1016              __HAL_UNLOCK(hspi);
   \   00000084   0x2200             MOVS     R2,#+0
   \   00000086   0xF880 0x205C      STRB     R2,[R0, #+92]
   1017          
   1018              /* Note : The SPI must be enabled after unlocking current process 
   1019                        to avoid the risk of SPI interrupt handle execution before current
   1020                        process unlock */
   1021                  
   1022              /* Check if the SPI is already enabled */ 
   1023              if((hspi->Instance->CR1 &SPI_CR1_SPE) != SPI_CR1_SPE)
   \   0000008A   0x6808             LDR      R0,[R1, #+0]
   \   0000008C   0x0640             LSLS     R0,R0,#+25
   \   0000008E   0xD403             BMI.N    ??HAL_SPI_Transmit_IT_4
   1024              {
   1025                /* Enable SPI peripheral */    
   1026                __HAL_SPI_ENABLE(hspi);
   \   00000090   0x6808             LDR      R0,[R1, #+0]
   \   00000092   0xF040 0x0040      ORR      R0,R0,#0x40
   \   00000096   0x6008             STR      R0,[R1, #+0]
   1027              }
   1028                  
   1029              return HAL_OK;
   \                     ??HAL_SPI_Transmit_IT_4: (+1)
   \   00000098   0x2000             MOVS     R0,#+0
   \   0000009A   0x4770             BX       LR
   1030            }
   1031            else
   1032            {
   1033              return HAL_BUSY;
   \                     ??HAL_SPI_Transmit_IT_0: (+1)
   \   0000009C   0x2002             MOVS     R0,#+2
   \   0000009E   0x4770             BX       LR               ;; return
   1034            }
   1035          }
   1036          
   1037          /**
   1038            * @brief  Receive an amount of data in no-blocking mode with Interrupt
   1039            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   1040            *               the configuration information for SPI module.
   1041            * @param  pData: pointer to data buffer
   1042            * @param  Size: amount of data to be sent
   1043            * @retval HAL status
   1044            */

   \                                 In section .text, align 2, keep-with-next
   1045          HAL_StatusTypeDef HAL_SPI_Receive_IT(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size)
   1046          {
   1047            if(hspi->State == HAL_SPI_STATE_READY)
   \                     HAL_SPI_Receive_IT: (+1)
   \   00000000   0xF890 0x305D      LDRB     R3,[R0, #+93]
   \   00000004   0x2B01             CMP      R3,#+1
   \   00000006   0xD16E             BNE.N    ??HAL_SPI_Receive_IT_0
   1048            {
   1049              if((pData == NULL) || (Size == 0))
   \   00000008   0x2900             CMP      R1,#+0
   \   0000000A   0xBF18             IT       NE 
   \   0000000C   0x2A00             CMPNE    R2,#+0
   \   0000000E   0xD101             BNE.N    ??HAL_SPI_Receive_IT_1
   1050              { 
   1051                return  HAL_ERROR;                      
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0x4770             BX       LR
   1052              }
   1053          
   1054              /* Process Locked */
   1055              __HAL_LOCK(hspi);
   \                     ??HAL_SPI_Receive_IT_1: (+1)
   \   00000014   0xF890 0x305C      LDRB     R3,[R0, #+92]
   \   00000018   0x2B01             CMP      R3,#+1
   \   0000001A   0xD064             BEQ.N    ??HAL_SPI_Receive_IT_0
   \   0000001C   0x2301             MOVS     R3,#+1
   1056              
   1057              /* Configure communication */
   1058              hspi->State       = HAL_SPI_STATE_BUSY_RX;
   1059              hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
   1060              hspi->pRxBuffPtr  = pData;
   \   0000001E   0x6401             STR      R1,[R0, #+64]
   \   00000020   0xF880 0x305C      STRB     R3,[R0, #+92]
   \   00000024   0x2304             MOVS     R3,#+4
   \   00000026   0xF880 0x305D      STRB     R3,[R0, #+93]
   \   0000002A   0x2300             MOVS     R3,#+0
   \   0000002C   0x6603             STR      R3,[R0, #+96]
   1061              hspi->RxXferSize  = Size;
   1062              hspi->RxXferCount = Size;
   1063              hspi->pTxBuffPtr  = NULL;
   \   0000002E   0x6383             STR      R3,[R0, #+56]
   1064              hspi->TxXferSize  = 0;
   \   00000030   0x8783             STRH     R3,[R0, #+60]
   1065              hspi->TxXferCount = 0;
   \   00000032   0x87C3             STRH     R3,[R0, #+62]
   1066          
   1067              if((hspi->Init.Mode == SPI_MODE_MASTER) && (hspi->Init.Direction == SPI_DIRECTION_2LINES))
   \   00000034   0x6843             LDR      R3,[R0, #+4]
   \   00000036   0xF8A0 0x2044      STRH     R2,[R0, #+68]
   \   0000003A   0xF5B3 0x7F82      CMP      R3,#+260
   \   0000003E   0xF8A0 0x2046      STRH     R2,[R0, #+70]
   \   00000042   0xBF04             ITT      EQ 
   \   00000044   0x6883             LDREQ    R3,[R0, #+8]
   \   00000046   0x2B00             CMPEQ    R3,#+0
   \   00000048   0xD104             BNE.N    ??HAL_SPI_Receive_IT_2
   1068              {
   1069                /* Process Unlocked */
   1070                __HAL_UNLOCK(hspi);
   \   0000004A   0xF880 0x305C      STRB     R3,[R0, #+92]
   1071                /* the receive process is not supported in 2Lines direction master mode */
   1072                /* in this we call the transmitReceive process          */
   1073                return HAL_SPI_TransmitReceive_IT(hspi,pData,pData,Size);
   \   0000004E   0x4613             MOV      R3,R2
   \   00000050   0x460A             MOV      R2,R1
   \   00000052   0x....             B.N      HAL_SPI_TransmitReceive_IT
   1074              }
   1075                  
   1076              if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   \                     ??HAL_SPI_Receive_IT_2: (+1)
   \   00000054   0x6A81             LDR      R1,[R0, #+40]
   \   00000056   0xF240 0x7201      MOVW     R2,#+1793
   \   0000005A   0xF5B1 0x5F00      CMP      R1,#+8192
   \   0000005E   0xD108             BNE.N    ??HAL_SPI_Receive_IT_3
   1077              {
   1078                hspi->CRCSize = 1;
   \   00000060   0x2101             MOVS     R1,#+1
   \   00000062   0x6481             STR      R1,[R0, #+72]
   1079                if((hspi->Init.DataSize <= SPI_DATASIZE_8BIT) && (hspi->Init.CRCLength == SPI_CRC_LENGTH_16BIT))
   \   00000064   0x68C1             LDR      R1,[R0, #+12]
   \   00000066   0x4291             CMP      R1,R2
   \   00000068   0xD205             BCS.N    ??HAL_SPI_Receive_IT_4
   \   0000006A   0x6B01             LDR      R1,[R0, #+48]
   \   0000006C   0x2902             CMP      R1,#+2
   \   0000006E   0xD102             BNE.N    ??HAL_SPI_Receive_IT_4
   1080                {
   1081                  hspi->CRCSize = 2;
   \   00000070   0xE000             B.N      ??HAL_SPI_Receive_IT_5
   1082                }
   1083              }
   1084              else
   1085              {
   1086                hspi->CRCSize = 0;
   \                     ??HAL_SPI_Receive_IT_3: (+1)
   \   00000072   0x2100             MOVS     R1,#+0
   \                     ??HAL_SPI_Receive_IT_5: (+1)
   \   00000074   0x6481             STR      R1,[R0, #+72]
   1087              }
   1088                  
   1089              /* check the data size to adapt Rx threshold and the set the function for IT treatment */
   1090              if(hspi->Init.DataSize > SPI_DATASIZE_8BIT )
   \                     ??HAL_SPI_Receive_IT_4: (+1)
   \   00000076   0x6801             LDR      R1,[R0, #+0]
   \   00000078   0x68C3             LDR      R3,[R0, #+12]
   \   0000007A   0x4293             CMP      R3,R2
   \   0000007C   0x684A             LDR      R2,[R1, #+4]
   \   0000007E   0xD305             BCC.N    ??HAL_SPI_Receive_IT_6
   1091              {
   1092                /* set fiforxthreshold according the reception data length: 16 bit */
   1093                CLEAR_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
   \   00000080   0xF422 0x5280      BIC      R2,R2,#0x1000
   \   00000084   0x604A             STR      R2,[R1, #+4]
   1094                hspi->RxISR = SPI_RxISR_16BIT;
   \   00000086   0x.... 0x....      ADR.W    R2,SPI_RxISR_16BIT
   1095                hspi->TxISR = NULL;
   \   0000008A   0xE004             B.N      ??HAL_SPI_Receive_IT_7
   1096              }
   1097              else
   1098              {
   1099                /* set fiforxthreshold according the reception data length: 8 bit */
   1100                SET_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
   \                     ??HAL_SPI_Receive_IT_6: (+1)
   \   0000008C   0xF442 0x5280      ORR      R2,R2,#0x1000
   \   00000090   0x604A             STR      R2,[R1, #+4]
   1101                hspi->RxISR = SPI_RxISR_8BIT;
   \   00000092   0x.... 0x....      ADR.W    R2,SPI_RxISR_8BIT
   1102                hspi->TxISR = NULL;
   \                     ??HAL_SPI_Receive_IT_7: (+1)
   \   00000096   0x64C2             STR      R2,[R0, #+76]
   \   00000098   0x2300             MOVS     R3,#+0
   1103              }
   1104              
   1105              /* Configure communication direction : 1Line */
   1106              if(hspi->Init.Direction == SPI_DIRECTION_1LINE)
   \   0000009A   0x6882             LDR      R2,[R0, #+8]
   \   0000009C   0x6503             STR      R3,[R0, #+80]
   \   0000009E   0xF5B2 0x4F00      CMP      R2,#+32768
   \   000000A2   0xD103             BNE.N    ??HAL_SPI_Receive_IT_8
   1107              {
   1108                SPI_1LINE_RX(hspi);
   \   000000A4   0x680A             LDR      R2,[R1, #+0]
   \   000000A6   0xF422 0x4280      BIC      R2,R2,#0x4000
   \   000000AA   0x600A             STR      R2,[R1, #+0]
   1109              }
   1110              
   1111              /* Reset CRC Calculation */
   1112              if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   \                     ??HAL_SPI_Receive_IT_8: (+1)
   \   000000AC   0x6A82             LDR      R2,[R0, #+40]
   \   000000AE   0xF5B2 0x5F00      CMP      R2,#+8192
   \   000000B2   0xD108             BNE.N    ??HAL_SPI_Receive_IT_9
   1113              {
   1114                SPI_RESET_CRC(hspi);
   \   000000B4   0x680A             LDR      R2,[R1, #+0]
   \   000000B6   0xF64D 0x73FF      MOVW     R3,#+57343
   \   000000BA   0x401A             ANDS     R2,R3,R2
   \   000000BC   0x600A             STR      R2,[R1, #+0]
   \   000000BE   0x680A             LDR      R2,[R1, #+0]
   \   000000C0   0xF442 0x5200      ORR      R2,R2,#0x2000
   \   000000C4   0x600A             STR      R2,[R1, #+0]
   1115              }
   1116              
   1117              /* Enable TXE and ERR interrupt */
   1118              __HAL_SPI_ENABLE_IT(hspi, (SPI_IT_RXNE | SPI_IT_ERR));
   \                     ??HAL_SPI_Receive_IT_9: (+1)
   \   000000C6   0x684A             LDR      R2,[R1, #+4]
   \   000000C8   0xF042 0x0260      ORR      R2,R2,#0x60
   \   000000CC   0x604A             STR      R2,[R1, #+4]
   1119              
   1120              /* Process Unlocked */
   1121              __HAL_UNLOCK(hspi);
   \   000000CE   0x2200             MOVS     R2,#+0
   \   000000D0   0xF880 0x205C      STRB     R2,[R0, #+92]
   1122              
   1123              /* Note : The SPI must be enabled after unlocking current process 
   1124              to avoid the risk of SPI interrupt handle execution before current
   1125              process unlock */
   1126              
   1127              /* Check if the SPI is already enabled */ 
   1128              if((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
   \   000000D4   0x6808             LDR      R0,[R1, #+0]
   \   000000D6   0x0640             LSLS     R0,R0,#+25
   \   000000D8   0xD403             BMI.N    ??HAL_SPI_Receive_IT_10
   1129              {
   1130                /* Enable SPI peripheral */    
   1131                __HAL_SPI_ENABLE(hspi);
   \   000000DA   0x6808             LDR      R0,[R1, #+0]
   \   000000DC   0xF040 0x0040      ORR      R0,R0,#0x40
   \   000000E0   0x6008             STR      R0,[R1, #+0]
   1132              }
   1133              
   1134              return HAL_OK;
   \                     ??HAL_SPI_Receive_IT_10: (+1)
   \   000000E2   0x2000             MOVS     R0,#+0
   \   000000E4   0x4770             BX       LR
   1135            }
   1136            else
   1137            {
   1138              return HAL_BUSY; 
   \                     ??HAL_SPI_Receive_IT_0: (+1)
   \   000000E6   0x2002             MOVS     R0,#+2
   \   000000E8   0x4770             BX       LR               ;; return
   1139            }
   1140          }
   1141          
   1142          /**
   1143            * @brief  Transmit and Receive an amount of data in no-blocking mode with Interrupt
   1144            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   1145            *               the configuration information for SPI module.
   1146            * @param  pTxData: pointer to transmission data buffer
   1147            * @param  pRxData: pointer to reception data buffer
   1148            * @param  Size: amount of data to be sent and received
   1149            * @retval HAL status
   1150            */

   \                                 In section .text, align 2, keep-with-next
   1151          HAL_StatusTypeDef HAL_SPI_TransmitReceive_IT(SPI_HandleTypeDef *hspi, uint8_t *pTxData, uint8_t *pRxData, uint16_t Size)
   1152          {
   \                     HAL_SPI_TransmitReceive_IT: (+1)
   \   00000000   0xB470             PUSH     {R4-R6}
   1153            assert_param(IS_SPI_DIRECTION_2LINES(hspi->Init.Direction));
   1154            
   1155            if((hspi->State == HAL_SPI_STATE_READY) || \
   1156               ((hspi->Init.Mode == SPI_MODE_MASTER) && (hspi->Init.Direction == SPI_DIRECTION_2LINES) && (hspi->State == HAL_SPI_STATE_BUSY_RX)))
   \   00000002   0xF890 0x405D      LDRB     R4,[R0, #+93]
   \   00000006   0x2C01             CMP      R4,#+1
   \   00000008   0xD007             BEQ.N    ??HAL_SPI_TransmitReceive_IT_0
   \   0000000A   0x6845             LDR      R5,[R0, #+4]
   \   0000000C   0xF5B5 0x7F82      CMP      R5,#+260
   \   00000010   0xBF02             ITTT     EQ 
   \   00000012   0x6885             LDREQ    R5,[R0, #+8]
   \   00000014   0x2D00             CMPEQ    R5,#+0
   \   00000016   0x2C04             CMPEQ    R4,#+4
   \   00000018   0xD16B             BNE.N    ??HAL_SPI_TransmitReceive_IT_1
   1157            {
   1158              if((pTxData == NULL ) || (pRxData == NULL ) || (Size == 0)) 
   \                     ??HAL_SPI_TransmitReceive_IT_0: (+1)
   \   0000001A   0x2900             CMP      R1,#+0
   \   0000001C   0xBF18             IT       NE 
   \   0000001E   0x2A00             CMPNE    R2,#+0
   \   00000020   0xD000             BEQ.N    ??HAL_SPI_TransmitReceive_IT_2
   \   00000022   0xB913             CBNZ.N   R3,??HAL_SPI_TransmitReceive_IT_3
   1159              {
   1160                return  HAL_ERROR;                                    
   \                     ??HAL_SPI_TransmitReceive_IT_2: (+1)
   \   00000024   0x2001             MOVS     R0,#+1
   \   00000026   0xBC70             POP      {R4-R6}
   \   00000028   0x4770             BX       LR
   1161              }
   1162              
   1163              /* Process locked */
   1164              __HAL_LOCK(hspi);
   \                     ??HAL_SPI_TransmitReceive_IT_3: (+1)
   \   0000002A   0xF890 0x505C      LDRB     R5,[R0, #+92]
   \   0000002E   0x2D01             CMP      R5,#+1
   \   00000030   0xD05F             BEQ.N    ??HAL_SPI_TransmitReceive_IT_1
   \   00000032   0x2501             MOVS     R5,#+1
   1165              
   1166              hspi->CRCSize = 0;
   1167              if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   \   00000034   0x6A86             LDR      R6,[R0, #+40]
   \   00000036   0xF880 0x505C      STRB     R5,[R0, #+92]
   \   0000003A   0x2500             MOVS     R5,#+0
   \   0000003C   0xF5B6 0x5F00      CMP      R6,#+8192
   \   00000040   0x6485             STR      R5,[R0, #+72]
   \   00000042   0xF240 0x7501      MOVW     R5,#+1793
   \   00000046   0xD108             BNE.N    ??HAL_SPI_TransmitReceive_IT_4
   1168              {
   1169                hspi->CRCSize = 1;
   \   00000048   0x2601             MOVS     R6,#+1
   \   0000004A   0x6486             STR      R6,[R0, #+72]
   1170                if((hspi->Init.DataSize <= SPI_DATASIZE_8BIT) && (hspi->Init.CRCLength == SPI_CRC_LENGTH_16BIT))
   \   0000004C   0x68C6             LDR      R6,[R0, #+12]
   \   0000004E   0x42AE             CMP      R6,R5
   \   00000050   0xD203             BCS.N    ??HAL_SPI_TransmitReceive_IT_4
   \   00000052   0x6B06             LDR      R6,[R0, #+48]
   \   00000054   0x2E02             CMP      R6,#+2
   \   00000056   0xBF08             IT       EQ 
   \   00000058   0x6486             STREQ    R6,[R0, #+72]
   1171                {
   1172                  hspi->CRCSize = 2;
   1173                }
   1174              }
   1175              
   1176              if(hspi->State != HAL_SPI_STATE_BUSY_RX)
   \                     ??HAL_SPI_TransmitReceive_IT_4: (+1)
   \   0000005A   0x2C04             CMP      R4,#+4
   \   0000005C   0xBF1C             ITT      NE 
   \   0000005E   0x2405             MOVNE    R4,#+5
   \   00000060   0xF880 0x405D      STRBNE   R4,[R0, #+93]
   1177              {
   1178                hspi->State = HAL_SPI_STATE_BUSY_TX_RX;
   1179              }
   1180              
   1181              hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
   1182              hspi->pTxBuffPtr  = pTxData;
   \   00000064   0x6381             STR      R1,[R0, #+56]
   \   00000066   0x2400             MOVS     R4,#+0
   1183              hspi->TxXferSize  = Size;
   1184              hspi->TxXferCount = Size;
   1185              hspi->pRxBuffPtr  = pRxData;
   1186              hspi->RxXferSize  = Size;
   1187              hspi->RxXferCount = Size;
   1188              
   1189              /* Set the function for IT treatement */
   1190              if(hspi->Init.DataSize > SPI_DATASIZE_8BIT )
   \   00000068   0x68C1             LDR      R1,[R0, #+12]
   \   0000006A   0x6604             STR      R4,[R0, #+96]
   \   0000006C   0x8783             STRH     R3,[R0, #+60]
   \   0000006E   0x42A9             CMP      R1,R5
   \   00000070   0x87C3             STRH     R3,[R0, #+62]
   \   00000072   0x6402             STR      R2,[R0, #+64]
   \   00000074   0xF8A0 0x3044      STRH     R3,[R0, #+68]
   \   00000078   0xF8A0 0x3046      STRH     R3,[R0, #+70]
   \   0000007C   0xBF27             ITTEE    CS 
   \   0000007E   0x.... 0x....      ADRCS.W  R1,SPI_2linesRxISR_16BIT
   \   00000082   0x.... 0x....      ADRCS.W  R2,SPI_2linesTxISR_16BIT
   \   00000086   0x.... 0x....      ADRCC.W  R1,SPI_2linesRxISR_8BIT
   \   0000008A   0x.... 0x....      ADRCC.W  R2,SPI_2linesTxISR_8BIT
   1191              {
   1192                hspi->RxISR = SPI_2linesRxISR_16BIT;
   1193                hspi->TxISR = SPI_2linesTxISR_16BIT;       
   1194              }
   1195              else
   1196              {
   1197                hspi->RxISR = SPI_2linesRxISR_8BIT;
   1198                hspi->TxISR = SPI_2linesTxISR_8BIT;
   \   0000008E   0x64C1             STR      R1,[R0, #+76]
   1199              }
   1200              
   1201              /* Reset CRC Calculation */
   1202              if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   \   00000090   0x6A81             LDR      R1,[R0, #+40]
   \   00000092   0x6502             STR      R2,[R0, #+80]
   \   00000094   0xF5B1 0x5F00      CMP      R1,#+8192
   \   00000098   0xD109             BNE.N    ??HAL_SPI_TransmitReceive_IT_5
   1203              {
   1204                SPI_RESET_CRC(hspi);
   \   0000009A   0x6801             LDR      R1,[R0, #+0]
   \   0000009C   0xF64D 0x73FF      MOVW     R3,#+57343
   \   000000A0   0x680A             LDR      R2,[R1, #+0]
   \   000000A2   0x401A             ANDS     R2,R3,R2
   \   000000A4   0x600A             STR      R2,[R1, #+0]
   \   000000A6   0x680A             LDR      R2,[R1, #+0]
   \   000000A8   0xF442 0x5200      ORR      R2,R2,#0x2000
   \   000000AC   0x600A             STR      R2,[R1, #+0]
   1205              }
   1206              
   1207              /* check if packing mode is enabled and if there is more than 2 data to receive */
   1208              if((hspi->Init.DataSize > SPI_DATASIZE_8BIT) || (hspi->RxXferCount >= 2))
   \                     ??HAL_SPI_TransmitReceive_IT_5: (+1)
   \   000000AE   0x68C1             LDR      R1,[R0, #+12]
   \   000000B0   0x42A9             CMP      R1,R5
   \   000000B2   0xD203             BCS.N    ??HAL_SPI_TransmitReceive_IT_6
   \   000000B4   0xF8B0 0x1046      LDRH     R1,[R0, #+70]
   \   000000B8   0x2902             CMP      R1,#+2
   \   000000BA   0xDB04             BLT.N    ??HAL_SPI_TransmitReceive_IT_7
   1209              {
   1210                /* set fiforxthreshold according the reception data length: 16 bit */
   1211                CLEAR_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
   \                     ??HAL_SPI_TransmitReceive_IT_6: (+1)
   \   000000BC   0x6801             LDR      R1,[R0, #+0]
   \   000000BE   0x684A             LDR      R2,[R1, #+4]
   \   000000C0   0xF422 0x5280      BIC      R2,R2,#0x1000
   \   000000C4   0xE003             B.N      ??HAL_SPI_TransmitReceive_IT_8
   1212              }
   1213              else
   1214              {
   1215                /* set fiforxthreshold according the reception data length: 8 bit */
   1216                SET_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
   \                     ??HAL_SPI_TransmitReceive_IT_7: (+1)
   \   000000C6   0x6801             LDR      R1,[R0, #+0]
   \   000000C8   0x684A             LDR      R2,[R1, #+4]
   \   000000CA   0xF442 0x5280      ORR      R2,R2,#0x1000
   \                     ??HAL_SPI_TransmitReceive_IT_8: (+1)
   \   000000CE   0x604A             STR      R2,[R1, #+4]
   1217              }
   1218              
   1219              /* Enable TXE, RXNE and ERR interrupt */
   1220              __HAL_SPI_ENABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_RXNE | SPI_IT_ERR));
   \   000000D0   0x6801             LDR      R1,[R0, #+0]
   \   000000D2   0x684A             LDR      R2,[R1, #+4]
   \   000000D4   0xF042 0x02E0      ORR      R2,R2,#0xE0
   \   000000D8   0x604A             STR      R2,[R1, #+4]
   1221              
   1222              /* Process Unlocked */
   1223              __HAL_UNLOCK(hspi);
   \   000000DA   0xF880 0x405C      STRB     R4,[R0, #+92]
   1224              
   1225              /* Check if the SPI is already enabled */ 
   1226              if((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
   \   000000DE   0x6808             LDR      R0,[R1, #+0]
   \   000000E0   0x0640             LSLS     R0,R0,#+25
   \   000000E2   0xD403             BMI.N    ??HAL_SPI_TransmitReceive_IT_9
   1227              {
   1228                /* Enable SPI peripheral */    
   1229                __HAL_SPI_ENABLE(hspi);
   \   000000E4   0x6808             LDR      R0,[R1, #+0]
   \   000000E6   0xF040 0x0040      ORR      R0,R0,#0x40
   \   000000EA   0x6008             STR      R0,[R1, #+0]
   1230              }
   1231              
   1232              return HAL_OK;
   \                     ??HAL_SPI_TransmitReceive_IT_9: (+1)
   \   000000EC   0x2000             MOVS     R0,#+0
   \   000000EE   0xBC70             POP      {R4-R6}
   \   000000F0   0x4770             BX       LR
   1233            }
   1234            else
   1235            {
   1236              return HAL_BUSY;
   \                     ??HAL_SPI_TransmitReceive_IT_1: (+1)
   \   000000F2   0x2002             MOVS     R0,#+2
   \   000000F4   0xBC70             POP      {R4-R6}
   \   000000F6   0x4770             BX       LR               ;; return
   1237            }
   1238          }
   1239          
   1240          /**
   1241            * @brief  Transmit an amount of data in no-blocking mode with DMA
   1242            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   1243            *               the configuration information for SPI module.
   1244            * @param  pData: pointer to data buffer
   1245            * @param  Size: amount of data to be sent
   1246            * @retval HAL status
   1247            */

   \                                 In section .text, align 2, keep-with-next
   1248          HAL_StatusTypeDef HAL_SPI_Transmit_DMA(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size)
   1249          {    
   \                     HAL_SPI_Transmit_DMA: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   1250            assert_param(IS_SPI_DIRECTION_2LINES_OR_1LINE(hspi->Init.Direction));
   1251          
   1252            if(hspi->State != HAL_SPI_STATE_READY) 
   \   00000004   0xF894 0x005D      LDRB     R0,[R4, #+93]
   \   00000008   0x2801             CMP      R0,#+1
   \   0000000A   0xD107             BNE.N    ??HAL_SPI_Transmit_DMA_0
   1253            {
   1254              return HAL_BUSY;
   1255            }
   1256            
   1257            if((pData == NULL) || (Size == 0))
   \   0000000C   0x2900             CMP      R1,#+0
   \   0000000E   0xBF18             IT       NE 
   \   00000010   0x2A00             CMPNE    R2,#+0
   \   00000012   0xD064             BEQ.N    ??HAL_SPI_Transmit_DMA_1
   1258            {
   1259              return HAL_ERROR;
   1260            }
   1261            
   1262            /* Process Locked */
   1263            __HAL_LOCK(hspi);
   \   00000014   0xF894 0x005C      LDRB     R0,[R4, #+92]
   \   00000018   0x2801             CMP      R0,#+1
   \   0000001A   0xD101             BNE.N    ??HAL_SPI_Transmit_DMA_2
   \                     ??HAL_SPI_Transmit_DMA_0: (+1)
   \   0000001C   0x2002             MOVS     R0,#+2
   \   0000001E   0xBD10             POP      {R4,PC}
   \                     ??HAL_SPI_Transmit_DMA_2: (+1)
   \   00000020   0x2001             MOVS     R0,#+1
   1264            
   1265            hspi->State       = HAL_SPI_STATE_BUSY_TX;
   1266            hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
   1267            hspi->pTxBuffPtr  = pData;
   \   00000022   0x63A1             STR      R1,[R4, #+56]
   \   00000024   0xF884 0x005C      STRB     R0,[R4, #+92]
   \   00000028   0x2003             MOVS     R0,#+3
   \   0000002A   0xF884 0x005D      STRB     R0,[R4, #+93]
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0x6620             STR      R0,[R4, #+96]
   1268            hspi->TxXferSize  = Size;
   \   00000032   0x87A2             STRH     R2,[R4, #+60]
   1269            hspi->TxXferCount = Size;
   \   00000034   0x87E2             STRH     R2,[R4, #+62]
   1270            hspi->pRxBuffPtr  = (uint8_t *)NULL;
   \   00000036   0x6420             STR      R0,[R4, #+64]
   1271            hspi->RxXferSize  = 0;
   \   00000038   0xF8A4 0x0044      STRH     R0,[R4, #+68]
   1272            hspi->RxXferCount = 0;
   \   0000003C   0xF8A4 0x0046      STRH     R0,[R4, #+70]
   1273            
   1274            /* Configure communication direction : 1Line */
   1275            if(hspi->Init.Direction == SPI_DIRECTION_1LINE)
   \   00000040   0x68A0             LDR      R0,[R4, #+8]
   \   00000042   0x6822             LDR      R2,[R4, #+0]
   \   00000044   0xF5B0 0x4F00      CMP      R0,#+32768
   \   00000048   0xD103             BNE.N    ??HAL_SPI_Transmit_DMA_3
   1276            {
   1277              SPI_1LINE_TX(hspi);
   \   0000004A   0x6810             LDR      R0,[R2, #+0]
   \   0000004C   0xF440 0x4080      ORR      R0,R0,#0x4000
   \   00000050   0x6010             STR      R0,[R2, #+0]
   1278            }
   1279            
   1280            /* Reset CRC Calculation */
   1281            if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   \                     ??HAL_SPI_Transmit_DMA_3: (+1)
   \   00000052   0x6AA0             LDR      R0,[R4, #+40]
   \   00000054   0xF5B0 0x5F00      CMP      R0,#+8192
   \   00000058   0xD108             BNE.N    ??HAL_SPI_Transmit_DMA_4
   1282            {
   1283              SPI_RESET_CRC(hspi);
   \   0000005A   0x6810             LDR      R0,[R2, #+0]
   \   0000005C   0xF64D 0x71FF      MOVW     R1,#+57343
   \   00000060   0x4008             ANDS     R0,R1,R0
   \   00000062   0x6010             STR      R0,[R2, #+0]
   \   00000064   0x6810             LDR      R0,[R2, #+0]
   \   00000066   0xF440 0x5000      ORR      R0,R0,#0x2000
   \   0000006A   0x6010             STR      R0,[R2, #+0]
   1284            }
   1285            
   1286            /* Set the SPI TxDMA Half transfer complete callback */
   1287            hspi->hdmatx->XferHalfCpltCallback = SPI_DMAHalfTransmitCplt;
   \                     ??HAL_SPI_Transmit_DMA_4: (+1)
   \   0000006C   0x6D60             LDR      R0,[R4, #+84]
   \   0000006E   0x.... 0x....      ADR.W    R1,SPI_DMAHalfTransmitCplt
   \   00000072   0x6401             STR      R1,[R0, #+64]
   1288            
   1289            /* Set the SPI TxDMA transfer complete callback */
   1290            hspi->hdmatx->XferCpltCallback = SPI_DMATransmitCplt;
   \   00000074   0x.... 0x....      ADR.W    R1,SPI_DMATransmitCplt
   \   00000078   0x63C1             STR      R1,[R0, #+60]
   1291            
   1292            /* Set the DMA error callback */
   1293            hspi->hdmatx->XferErrorCallback = SPI_DMAError;
   \   0000007A   0x.... 0x....      ADR.W    R1,SPI_DMAError
   \   0000007E   0x6481             STR      R1,[R0, #+72]
   1294            
   1295            CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_LDMATX);
   \   00000080   0x6851             LDR      R1,[R2, #+4]
   \   00000082   0xF421 0x4180      BIC      R1,R1,#0x4000
   \   00000086   0x6051             STR      R1,[R2, #+4]
   1296            /* packing mode is enabled only if the DMA setting is HALWORD */
   1297            if((hspi->Init.DataSize <= SPI_DATASIZE_8BIT) && (hspi->hdmatx->Init.MemDataAlignment == DMA_MDATAALIGN_HALFWORD))
   \   00000088   0x68E1             LDR      R1,[R4, #+12]
   \   0000008A   0x8FE3             LDRH     R3,[R4, #+62]
   \   0000008C   0xF5B1 0x6FE0      CMP      R1,#+1792
   \   00000090   0xD810             BHI.N    ??HAL_SPI_Transmit_DMA_5
   \   00000092   0x6981             LDR      R1,[R0, #+24]
   \   00000094   0xF5B1 0x5F00      CMP      R1,#+8192
   \   00000098   0xD10C             BNE.N    ??HAL_SPI_Transmit_DMA_5
   1298            {
   1299              /* Check the even/odd of the data size + crc if enabled */
   1300              if((hspi->TxXferCount & 0x1) == 0)
   \   0000009A   0x0859             LSRS     R1,R3,#+1
   \   0000009C   0x07DB             LSLS     R3,R3,#+31
   \   0000009E   0x6853             LDR      R3,[R2, #+4]
   \   000000A0   0xD404             BMI.N    ??HAL_SPI_Transmit_DMA_6
   1301              {
   1302                CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_LDMATX);
   \   000000A2   0xF423 0x4380      BIC      R3,R3,#0x4000
   \   000000A6   0x6053             STR      R3,[R2, #+4]
   1303                hspi->TxXferCount = (hspi->TxXferCount >> 1);
   \   000000A8   0x460B             MOV      R3,R1
   \   000000AA   0xE003             B.N      ??HAL_SPI_Transmit_DMA_5
   1304              }
   1305              else
   1306              {
   1307                SET_BIT(hspi->Instance->CR2, SPI_CR2_LDMATX);
   \                     ??HAL_SPI_Transmit_DMA_6: (+1)
   \   000000AC   0xF443 0x4380      ORR      R3,R3,#0x4000
   \   000000B0   0x6053             STR      R3,[R2, #+4]
   1308                hspi->TxXferCount = (hspi->TxXferCount >> 1) + 1;
   \   000000B2   0x1C4B             ADDS     R3,R1,#+1
   \                     ??HAL_SPI_Transmit_DMA_5: (+1)
   \   000000B4   0x87E3             STRH     R3,[R4, #+62]
   1309              }
   1310            }
   1311            
   1312            /* Enable the Tx DMA channel */
   1313            HAL_DMA_Start_IT(hspi->hdmatx, (uint32_t)hspi->pTxBuffPtr, (uint32_t)&hspi->Instance->DR, hspi->TxXferCount);
   \   000000B6   0x8FE3             LDRH     R3,[R4, #+62]
   \   000000B8   0x6BA1             LDR      R1,[R4, #+56]
   \   000000BA   0x320C             ADDS     R2,R2,#+12
   \   000000BC   0x.... 0x....      BL       HAL_DMA_Start_IT
   1314            
   1315            /* Check if the SPI is already enabled */ 
   1316            if((hspi->Instance->CR1 &SPI_CR1_SPE) != SPI_CR1_SPE)
   \   000000C0   0x6820             LDR      R0,[R4, #+0]
   \   000000C2   0x6801             LDR      R1,[R0, #+0]
   \   000000C4   0x0649             LSLS     R1,R1,#+25
   \   000000C6   0xD403             BMI.N    ??HAL_SPI_Transmit_DMA_7
   1317            {
   1318              /* Enable SPI peripheral */    
   1319              __HAL_SPI_ENABLE(hspi);
   \   000000C8   0x6801             LDR      R1,[R0, #+0]
   \   000000CA   0xF041 0x0140      ORR      R1,R1,#0x40
   \   000000CE   0x6001             STR      R1,[R0, #+0]
   1320            }
   1321          
   1322            /* Enable Tx DMA Request */
   1323            hspi->Instance->CR2 |= SPI_CR2_TXDMAEN;
   \                     ??HAL_SPI_Transmit_DMA_7: (+1)
   \   000000D0   0x6841             LDR      R1,[R0, #+4]
   \   000000D2   0xF041 0x0102      ORR      R1,R1,#0x2
   \   000000D6   0x6041             STR      R1,[R0, #+4]
   1324            
   1325            /* Process Unlocked */
   1326            __HAL_UNLOCK(hspi);
   \   000000D8   0x2000             MOVS     R0,#+0
   \   000000DA   0xF884 0x005C      STRB     R0,[R4, #+92]
   1327            
   1328            return HAL_OK;
   \                     ??HAL_SPI_Transmit_DMA_1: (+1)
   \   000000DE   0xBD10             POP      {R4,PC}          ;; return
   1329          }
   1330          
   1331          /**
   1332          * @brief  Receive an amount of data in no-blocking mode with DMA 
   1333          * @param  hspi: SPI handle
   1334          * @param  pData: pointer to data buffer
   1335          * @param  Size: amount of data to be sent
   1336          * @retval HAL status
   1337          */

   \                                 In section .text, align 2, keep-with-next
   1338          HAL_StatusTypeDef HAL_SPI_Receive_DMA(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size)
   1339          {
   \                     HAL_SPI_Receive_DMA: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   1340            if(hspi->State != HAL_SPI_STATE_READY)
   \   00000004   0xF894 0x005D      LDRB     R0,[R4, #+93]
   \   00000008   0x2801             CMP      R0,#+1
   \   0000000A   0xD107             BNE.N    ??HAL_SPI_Receive_DMA_0
   1341            {
   1342              return HAL_BUSY;
   1343            }
   1344            
   1345            if((pData == NULL) || (Size == 0))
   \   0000000C   0x2900             CMP      R1,#+0
   \   0000000E   0xBF18             IT       NE 
   \   00000010   0x2A00             CMPNE    R2,#+0
   \   00000012   0xD078             BEQ.N    ??HAL_SPI_Receive_DMA_1
   1346            {
   1347              return HAL_ERROR;
   1348            }
   1349            
   1350            /* Process Locked */
   1351            __HAL_LOCK(hspi);
   \   00000014   0xF894 0x005C      LDRB     R0,[R4, #+92]
   \   00000018   0x2801             CMP      R0,#+1
   \   0000001A   0xD101             BNE.N    ??HAL_SPI_Receive_DMA_2
   \                     ??HAL_SPI_Receive_DMA_0: (+1)
   \   0000001C   0x2002             MOVS     R0,#+2
   \   0000001E   0xBD10             POP      {R4,PC}
   \                     ??HAL_SPI_Receive_DMA_2: (+1)
   \   00000020   0x2001             MOVS     R0,#+1
   1352          
   1353            hspi->State       = HAL_SPI_STATE_BUSY_RX;
   1354            hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
   1355            hspi->pRxBuffPtr  = pData;
   \   00000022   0x6421             STR      R1,[R4, #+64]
   \   00000024   0xF884 0x005C      STRB     R0,[R4, #+92]
   \   00000028   0x2004             MOVS     R0,#+4
   \   0000002A   0xF884 0x005D      STRB     R0,[R4, #+93]
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0x6620             STR      R0,[R4, #+96]
   1356            hspi->RxXferSize  = Size;
   1357            hspi->RxXferCount = Size;
   1358            hspi->pTxBuffPtr  = (uint8_t *)NULL;
   \   00000032   0x63A0             STR      R0,[R4, #+56]
   1359            hspi->TxXferSize  = 0;
   \   00000034   0x87A0             STRH     R0,[R4, #+60]
   1360            hspi->TxXferCount = 0;
   \   00000036   0x87E0             STRH     R0,[R4, #+62]
   1361          
   1362            if((hspi->Init.Mode == SPI_MODE_MASTER) && (hspi->Init.Direction == SPI_DIRECTION_2LINES))
   \   00000038   0x6860             LDR      R0,[R4, #+4]
   \   0000003A   0xF8A4 0x2044      STRH     R2,[R4, #+68]
   \   0000003E   0xF5B0 0x7F82      CMP      R0,#+260
   \   00000042   0xF8A4 0x2046      STRH     R2,[R4, #+70]
   \   00000046   0xBF04             ITT      EQ 
   \   00000048   0x68A0             LDREQ    R0,[R4, #+8]
   \   0000004A   0x2800             CMPEQ    R0,#+0
   \   0000004C   0xD107             BNE.N    ??HAL_SPI_Receive_DMA_3
   1363            {
   1364              /* Process Unlocked */
   1365              __HAL_UNLOCK(hspi);
   \   0000004E   0xF884 0x005C      STRB     R0,[R4, #+92]
   1366              /* the receive process is not supported in 2Lines direction master mode */
   1367              /* in this case we call the transmitReceive process                     */
   1368              return HAL_SPI_TransmitReceive_DMA(hspi,pData,pData,Size);
   \   00000052   0x4613             MOV      R3,R2
   \   00000054   0x4620             MOV      R0,R4
   \   00000056   0x460A             MOV      R2,R1
   \   00000058   0xE8BD 0x4010      POP      {R4,LR}
   \   0000005C   0x....             B.N      HAL_SPI_TransmitReceive_DMA
   1369            }
   1370            
   1371            /* Configure communication direction : 1Line */
   1372            if(hspi->Init.Direction == SPI_DIRECTION_1LINE)
   \                     ??HAL_SPI_Receive_DMA_3: (+1)
   \   0000005E   0x68A0             LDR      R0,[R4, #+8]
   \   00000060   0xF5B0 0x4F00      CMP      R0,#+32768
   \   00000064   0xD104             BNE.N    ??HAL_SPI_Receive_DMA_4
   1373            {
   1374              SPI_1LINE_RX(hspi);
   \   00000066   0x6821             LDR      R1,[R4, #+0]
   \   00000068   0x6808             LDR      R0,[R1, #+0]
   \   0000006A   0xF420 0x4080      BIC      R0,R0,#0x4000
   \   0000006E   0x6008             STR      R0,[R1, #+0]
   1375            }
   1376            
   1377            /* Reset CRC Calculation */
   1378            if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   \                     ??HAL_SPI_Receive_DMA_4: (+1)
   \   00000070   0x6AA0             LDR      R0,[R4, #+40]
   \   00000072   0xF5B0 0x5F00      CMP      R0,#+8192
   \   00000076   0xD109             BNE.N    ??HAL_SPI_Receive_DMA_5
   1379            {
   1380              SPI_RESET_CRC(hspi);
   \   00000078   0x6821             LDR      R1,[R4, #+0]
   \   0000007A   0xF64D 0x72FF      MOVW     R2,#+57343
   \   0000007E   0x6808             LDR      R0,[R1, #+0]
   \   00000080   0x4010             ANDS     R0,R2,R0
   \   00000082   0x6008             STR      R0,[R1, #+0]
   \   00000084   0x6808             LDR      R0,[R1, #+0]
   \   00000086   0xF440 0x5000      ORR      R0,R0,#0x2000
   \   0000008A   0x6008             STR      R0,[R1, #+0]
   1381            }
   1382            
   1383            /* packing mode management is enabled by the DMA settings */
   1384            if((hspi->Init.DataSize <= SPI_DATASIZE_8BIT) && (hspi->hdmarx->Init.MemDataAlignment == DMA_MDATAALIGN_HALFWORD))
   \                     ??HAL_SPI_Receive_DMA_5: (+1)
   \   0000008C   0x68E1             LDR      R1,[R4, #+12]
   \   0000008E   0xF240 0x7001      MOVW     R0,#+1793
   \   00000092   0x4281             CMP      R1,R0
   \   00000094   0xD209             BCS.N    ??HAL_SPI_Receive_DMA_6
   \   00000096   0x6DA1             LDR      R1,[R4, #+88]
   \   00000098   0x6989             LDR      R1,[R1, #+24]
   \   0000009A   0xF5B1 0x5F00      CMP      R1,#+8192
   \   0000009E   0xD104             BNE.N    ??HAL_SPI_Receive_DMA_6
   1385            {
   1386              /* Process Locked */
   1387              __HAL_UNLOCK(hspi);
   \   000000A0   0x2000             MOVS     R0,#+0
   \   000000A2   0xF884 0x005C      STRB     R0,[R4, #+92]
   1388              /* Restriction the DMA data received is not allowed in this mode */
   1389              return HAL_ERROR;
   \   000000A6   0x2001             MOVS     R0,#+1
   \   000000A8   0xBD10             POP      {R4,PC}
   1390            }
   1391            
   1392            CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_LDMARX);
   \                     ??HAL_SPI_Receive_DMA_6: (+1)
   \   000000AA   0x6821             LDR      R1,[R4, #+0]
   \   000000AC   0x684A             LDR      R2,[R1, #+4]
   \   000000AE   0xF422 0x5200      BIC      R2,R2,#0x2000
   \   000000B2   0x604A             STR      R2,[R1, #+4]
   1393            if( hspi->Init.DataSize > SPI_DATASIZE_8BIT)
   \   000000B4   0x68E2             LDR      R2,[R4, #+12]
   \   000000B6   0x4282             CMP      R2,R0
   \   000000B8   0x6848             LDR      R0,[R1, #+4]
   1394            {
   1395              /* set fiforxthreshold according the reception data length: 16bit */
   1396              CLEAR_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
   1397            }
   1398            else
   1399            {
   1400              /* set fiforxthreshold according the reception data length: 8bit */
   1401              SET_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
   1402            }
   1403            
   1404            /* Set the SPI RxDMA Half transfer complete callback */
   1405            hspi->hdmarx->XferHalfCpltCallback = SPI_DMAHalfReceiveCplt;
   \   000000BA   0x.... 0x....      ADR.W    R2,SPI_DMAHalfReceiveCplt
   \   000000BE   0xBF2C             ITE      CS 
   \   000000C0   0xF420 0x5080      BICCS    R0,R0,#0x1000
   \   000000C4   0xF440 0x5080      ORRCC    R0,R0,#0x1000
   \   000000C8   0x6048             STR      R0,[R1, #+4]
   \   000000CA   0x6DA0             LDR      R0,[R4, #+88]
   \   000000CC   0x6402             STR      R2,[R0, #+64]
   1406          
   1407            /* Set the SPI Rx DMA transfer complete callback */
   1408            hspi->hdmarx->XferCpltCallback = SPI_DMAReceiveCplt;
   \   000000CE   0x.... 0x....      ADR.W    R2,SPI_DMAReceiveCplt
   \   000000D2   0x63C2             STR      R2,[R0, #+60]
   1409            
   1410            /* Set the DMA error callback */
   1411            hspi->hdmarx->XferErrorCallback = SPI_DMAError;
   \   000000D4   0x.... 0x....      ADR.W    R2,SPI_DMAError
   \   000000D8   0x6482             STR      R2,[R0, #+72]
   1412            
   1413            /* Enable Rx DMA Request */  
   1414            hspi->Instance->CR2 |= SPI_CR2_RXDMAEN;
   \   000000DA   0x684A             LDR      R2,[R1, #+4]
   \   000000DC   0xF042 0x0201      ORR      R2,R2,#0x1
   \   000000E0   0x604A             STR      R2,[R1, #+4]
   1415            
   1416            /* Enable the Rx DMA channel */
   1417            HAL_DMA_Start_IT(hspi->hdmarx, (uint32_t)&hspi->Instance->DR, (uint32_t)hspi->pRxBuffPtr, hspi->RxXferCount);
   \   000000E2   0xF8B4 0x3046      LDRH     R3,[R4, #+70]
   \   000000E6   0x6C22             LDR      R2,[R4, #+64]
   \   000000E8   0x310C             ADDS     R1,R1,#+12
   \   000000EA   0x.... 0x....      BL       HAL_DMA_Start_IT
   1418            
   1419            /* Process Unlocked */
   1420            __HAL_UNLOCK(hspi);
   \   000000EE   0x2000             MOVS     R0,#+0
   \   000000F0   0xF884 0x005C      STRB     R0,[R4, #+92]
   1421            
   1422            /* Check if the SPI is already enabled */ 
   1423            if((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
   \   000000F4   0x6820             LDR      R0,[R4, #+0]
   \   000000F6   0x6801             LDR      R1,[R0, #+0]
   \   000000F8   0x0649             LSLS     R1,R1,#+25
   \   000000FA   0xD403             BMI.N    ??HAL_SPI_Receive_DMA_7
   1424            {
   1425              /* Enable SPI peripheral */    
   1426              __HAL_SPI_ENABLE(hspi);
   \   000000FC   0x6801             LDR      R1,[R0, #+0]
   \   000000FE   0xF041 0x0140      ORR      R1,R1,#0x40
   \   00000102   0x6001             STR      R1,[R0, #+0]
   1427            }
   1428            
   1429            return HAL_OK;
   \                     ??HAL_SPI_Receive_DMA_7: (+1)
   \   00000104   0x2000             MOVS     R0,#+0
   \                     ??HAL_SPI_Receive_DMA_1: (+1)
   \   00000106   0xBD10             POP      {R4,PC}          ;; return
   1430          }
   1431          
   1432          /**
   1433            * @brief  Transmit and Receive an amount of data in no-blocking mode with DMA
   1434            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   1435            *               the configuration information for SPI module.
   1436            * @param  pTxData: pointer to transmission data buffer
   1437            * @param  pRxData: pointer to reception data buffer
   1438            * @note  When the CRC feature is enabled the pRxData Length must be Size + 1
   1439            * @param  Size: amount of data to be sent
   1440            * @retval HAL status
   1441            */

   \                                 In section .text, align 2, keep-with-next
   1442          HAL_StatusTypeDef HAL_SPI_TransmitReceive_DMA(SPI_HandleTypeDef *hspi, uint8_t *pTxData, uint8_t *pRxData, uint16_t Size)
   1443          {
   \                     HAL_SPI_TransmitReceive_DMA: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0xB081             SUB      SP,SP,#+4
   1444            assert_param(IS_SPI_DIRECTION_2LINES(hspi->Init.Direction));
   1445            
   1446            if((hspi->State == HAL_SPI_STATE_READY) ||
   1447               ((hspi->Init.Mode == SPI_MODE_MASTER) && (hspi->Init.Direction == SPI_DIRECTION_2LINES) && (hspi->State == HAL_SPI_STATE_BUSY_RX)))
   \   00000006   0xF894 0x005D      LDRB     R0,[R4, #+93]
   \   0000000A   0x2801             CMP      R0,#+1
   \   0000000C   0xD008             BEQ.N    ??HAL_SPI_TransmitReceive_DMA_0
   \   0000000E   0x6865             LDR      R5,[R4, #+4]
   \   00000010   0xF5B5 0x7F82      CMP      R5,#+260
   \   00000014   0xBF02             ITTT     EQ 
   \   00000016   0x68A5             LDREQ    R5,[R4, #+8]
   \   00000018   0x2D00             CMPEQ    R5,#+0
   \   0000001A   0x2804             CMPEQ    R0,#+4
   \   0000001C   0xF040 0x80B4      BNE.W    ??HAL_SPI_TransmitReceive_DMA_1
   1448            {
   1449              if((pTxData == NULL ) || (pRxData == NULL ) || (Size == 0)) 
   \                     ??HAL_SPI_TransmitReceive_DMA_0: (+1)
   \   00000020   0x2900             CMP      R1,#+0
   \   00000022   0xBF18             IT       NE 
   \   00000024   0x2A00             CMPNE    R2,#+0
   \   00000026   0xD000             BEQ.N    ??HAL_SPI_TransmitReceive_DMA_2
   \   00000028   0xB913             CBNZ.N   R3,??HAL_SPI_TransmitReceive_DMA_3
   1450              {
   1451                return  HAL_ERROR;                                    
   \                     ??HAL_SPI_TransmitReceive_DMA_2: (+1)
   \   0000002A   0x2001             MOVS     R0,#+1
   \   0000002C   0xB001             ADD      SP,SP,#+4
   \   0000002E   0xBD30             POP      {R4,R5,PC}
   1452              }
   1453              
   1454              /* Process locked */
   1455              __HAL_LOCK(hspi);
   \                     ??HAL_SPI_TransmitReceive_DMA_3: (+1)
   \   00000030   0xF894 0x505C      LDRB     R5,[R4, #+92]
   \   00000034   0x2D01             CMP      R5,#+1
   \   00000036   0xF000 0x80A7      BEQ.W    ??HAL_SPI_TransmitReceive_DMA_1
   \   0000003A   0x2501             MOVS     R5,#+1
   1456              
   1457              /* check if the transmit Receive function is not called by a receive master */
   1458              if(hspi->State != HAL_SPI_STATE_BUSY_RX)
   \   0000003C   0x2804             CMP      R0,#+4
   \   0000003E   0xF884 0x505C      STRB     R5,[R4, #+92]
   \   00000042   0xBF1C             ITT      NE 
   \   00000044   0x2005             MOVNE    R0,#+5
   \   00000046   0xF884 0x005D      STRBNE   R0,[R4, #+93]
   1459              {  
   1460                hspi->State = HAL_SPI_STATE_BUSY_TX_RX;
   1461              }
   1462              
   1463              hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
   \   0000004A   0x2000             MOVS     R0,#+0
   1464              hspi->pTxBuffPtr  = (uint8_t *)pTxData;
   \   0000004C   0x63A1             STR      R1,[R4, #+56]
   \   0000004E   0x6620             STR      R0,[R4, #+96]
   1465              hspi->TxXferSize  = Size;
   1466              hspi->TxXferCount = Size;
   1467              hspi->pRxBuffPtr  = (uint8_t *)pRxData;
   1468              hspi->RxXferSize  = Size;
   1469              hspi->RxXferCount = Size;
   1470              
   1471              /* Reset CRC Calculation + increase the rxsize */
   1472              if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   \   00000050   0x6AA0             LDR      R0,[R4, #+40]
   \   00000052   0x87A3             STRH     R3,[R4, #+60]
   \   00000054   0xF5B0 0x5F00      CMP      R0,#+8192
   \   00000058   0x87E3             STRH     R3,[R4, #+62]
   \   0000005A   0x6422             STR      R2,[R4, #+64]
   \   0000005C   0xF8A4 0x3044      STRH     R3,[R4, #+68]
   \   00000060   0xF8A4 0x3046      STRH     R3,[R4, #+70]
   \   00000064   0x6821             LDR      R1,[R4, #+0]
   \   00000066   0xD108             BNE.N    ??HAL_SPI_TransmitReceive_DMA_4
   1473              {
   1474                SPI_RESET_CRC(hspi);
   \   00000068   0x6808             LDR      R0,[R1, #+0]
   \   0000006A   0xF64D 0x72FF      MOVW     R2,#+57343
   \   0000006E   0x4010             ANDS     R0,R2,R0
   \   00000070   0x6008             STR      R0,[R1, #+0]
   \   00000072   0x6808             LDR      R0,[R1, #+0]
   \   00000074   0xF440 0x5000      ORR      R0,R0,#0x2000
   \   00000078   0x6008             STR      R0,[R1, #+0]
   1475              }
   1476              
   1477              /* Reset the threshold bit */
   1478              CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_LDMATX);
   \                     ??HAL_SPI_TransmitReceive_DMA_4: (+1)
   \   0000007A   0x6848             LDR      R0,[R1, #+4]
   \   0000007C   0xF420 0x4080      BIC      R0,R0,#0x4000
   \   00000080   0x6048             STR      R0,[R1, #+4]
   1479              CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_LDMARX);
   \   00000082   0x6848             LDR      R0,[R1, #+4]
   \   00000084   0xF420 0x5000      BIC      R0,R0,#0x2000
   \   00000088   0x6048             STR      R0,[R1, #+4]
   1480              
   1481              /* the packing mode management is enabled by the DMA settings according the spi data size */
   1482              if(hspi->Init.DataSize > SPI_DATASIZE_8BIT)
   \   0000008A   0x68E0             LDR      R0,[R4, #+12]
   \   0000008C   0xF5B0 0x6FE0      CMP      R0,#+1792
   \   00000090   0x6848             LDR      R0,[R1, #+4]
   \   00000092   0xD903             BLS.N    ??HAL_SPI_TransmitReceive_DMA_5
   1483              {
   1484                /* set fiforxthreshold according the reception data length: 16bit */
   1485                CLEAR_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
   \   00000094   0xF420 0x5080      BIC      R0,R0,#0x1000
   \   00000098   0x6048             STR      R0,[R1, #+4]
   \   0000009A   0xE033             B.N      ??HAL_SPI_TransmitReceive_DMA_6
   1486              }
   1487              else
   1488              {
   1489                /* set fiforxthreshold according the reception data length: 8bit */
   1490                SET_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
   \                     ??HAL_SPI_TransmitReceive_DMA_5: (+1)
   \   0000009C   0xF440 0x5080      ORR      R0,R0,#0x1000
   \   000000A0   0x6048             STR      R0,[R1, #+4]
   1491                
   1492                if(hspi->hdmatx->Init.MemDataAlignment == DMA_MDATAALIGN_HALFWORD)
   \   000000A2   0x6D60             LDR      R0,[R4, #+84]
   \   000000A4   0x6980             LDR      R0,[R0, #+24]
   \   000000A6   0xF5B0 0x5F00      CMP      R0,#+8192
   \   000000AA   0xD111             BNE.N    ??HAL_SPI_TransmitReceive_DMA_7
   1493                {
   1494                  if((hspi->TxXferSize & 0x1) == 0x0 )
   \   000000AC   0xF894 0x003C      LDRB     R0,[R4, #+60]
   \   000000B0   0x07C0             LSLS     R0,R0,#+31
   \   000000B2   0x6848             LDR      R0,[R1, #+4]
   \   000000B4   0xD405             BMI.N    ??HAL_SPI_TransmitReceive_DMA_8
   1495                  {
   1496                    CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_LDMATX);
   \   000000B6   0xF420 0x4080      BIC      R0,R0,#0x4000
   \   000000BA   0x6048             STR      R0,[R1, #+4]
   1497                    hspi->TxXferCount = hspi->TxXferCount >> 1;
   \   000000BC   0x8FE0             LDRH     R0,[R4, #+62]
   \   000000BE   0x0840             LSRS     R0,R0,#+1
   \   000000C0   0xE005             B.N      ??HAL_SPI_TransmitReceive_DMA_9
   1498                  }
   1499                  else
   1500                  {
   1501                    SET_BIT(hspi->Instance->CR2, SPI_CR2_LDMATX);
   \                     ??HAL_SPI_TransmitReceive_DMA_8: (+1)
   \   000000C2   0xF440 0x4080      ORR      R0,R0,#0x4000
   \   000000C6   0x6048             STR      R0,[R1, #+4]
   1502                    hspi->TxXferCount = (hspi->TxXferCount >> 1) + 1;
   \   000000C8   0x8FE0             LDRH     R0,[R4, #+62]
   \   000000CA   0x0840             LSRS     R0,R0,#+1
   \   000000CC   0x1C40             ADDS     R0,R0,#+1
   \                     ??HAL_SPI_TransmitReceive_DMA_9: (+1)
   \   000000CE   0x87E0             STRH     R0,[R4, #+62]
   1503                  }      
   1504                }
   1505                
   1506                if(hspi->hdmarx->Init.MemDataAlignment == DMA_MDATAALIGN_HALFWORD)
   \                     ??HAL_SPI_TransmitReceive_DMA_7: (+1)
   \   000000D0   0x6DA0             LDR      R0,[R4, #+88]
   \   000000D2   0x6980             LDR      R0,[R0, #+24]
   \   000000D4   0xF5B0 0x5F00      CMP      R0,#+8192
   \   000000D8   0xD114             BNE.N    ??HAL_SPI_TransmitReceive_DMA_6
   1507                {
   1508                  /* set fiforxthreshold according the reception data length: 16bit */
   1509                  CLEAR_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
   \   000000DA   0x6848             LDR      R0,[R1, #+4]
   \   000000DC   0xF420 0x5080      BIC      R0,R0,#0x1000
   \   000000E0   0x6048             STR      R0,[R1, #+4]
   1510                  
   1511                  /* Size must include the CRC length */
   1512                  if((hspi->RxXferCount & 0x1) == 0x0 )
   \   000000E2   0xF8B4 0x0046      LDRH     R0,[R4, #+70]
   \   000000E6   0x07C2             LSLS     R2,R0,#+31
   \   000000E8   0x684A             LDR      R2,[R1, #+4]
   \   000000EA   0xD404             BMI.N    ??HAL_SPI_TransmitReceive_DMA_10
   1513                  {
   1514                    CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_LDMARX);
   \   000000EC   0xF422 0x5200      BIC      R2,R2,#0x2000
   1515                    hspi->RxXferCount = hspi->RxXferCount >> 1;
   \   000000F0   0x0840             LSRS     R0,R0,#+1
   \   000000F2   0x604A             STR      R2,[R1, #+4]
   \   000000F4   0xE004             B.N      ??HAL_SPI_TransmitReceive_DMA_11
   1516                  }
   1517                  else
   1518                  {
   1519                    SET_BIT(hspi->Instance->CR2, SPI_CR2_LDMARX);
   \                     ??HAL_SPI_TransmitReceive_DMA_10: (+1)
   \   000000F6   0xF442 0x5200      ORR      R2,R2,#0x2000
   1520                    hspi->RxXferCount = (hspi->RxXferCount >> 1) + 1; 
   \   000000FA   0x0840             LSRS     R0,R0,#+1
   \   000000FC   0x604A             STR      R2,[R1, #+4]
   \   000000FE   0x1C40             ADDS     R0,R0,#+1
   \                     ??HAL_SPI_TransmitReceive_DMA_11: (+1)
   \   00000100   0xF8A4 0x0046      STRH     R0,[R4, #+70]
   1521                  } 
   1522                }
   1523              }   
   1524              
   1525              /* Set the SPI Rx DMA transfer complete callback because the last generated transfer request is 
   1526              the reception request (RXNE) */
   1527              if(hspi->State == HAL_SPI_STATE_BUSY_RX)
   \                     ??HAL_SPI_TransmitReceive_DMA_6: (+1)
   \   00000104   0xF894 0x205D      LDRB     R2,[R4, #+93]
   \   00000108   0x6DA0             LDR      R0,[R4, #+88]
   \   0000010A   0x2A04             CMP      R2,#+4
   \   0000010C   0xD105             BNE.N    ??HAL_SPI_TransmitReceive_DMA_12
   1528              {			
   1529                hspi->hdmarx->XferHalfCpltCallback = SPI_DMAHalfReceiveCplt;
   \   0000010E   0x.... 0x....      ADR.W    R2,SPI_DMAHalfReceiveCplt
   \   00000112   0x6402             STR      R2,[R0, #+64]
   1530                hspi->hdmarx->XferCpltCallback = SPI_DMAReceiveCplt;
   \   00000114   0x.... 0x....      ADR.W    R2,SPI_DMAReceiveCplt
   \   00000118   0xE004             B.N      ??HAL_SPI_TransmitReceive_DMA_13
   1531              }
   1532              else
   1533              {	
   1534                 hspi->hdmarx->XferHalfCpltCallback = SPI_DMAHalfTransmitReceiveCplt;
   \                     ??HAL_SPI_TransmitReceive_DMA_12: (+1)
   \   0000011A   0x.... 0x....      ADR.W    R2,SPI_DMAHalfTransmitReceiveCplt
   \   0000011E   0x6402             STR      R2,[R0, #+64]
   1535                hspi->hdmarx->XferCpltCallback = SPI_DMATransmitReceiveCplt;
   \   00000120   0x.... 0x....      ADR.W    R2,SPI_DMATransmitReceiveCplt
   1536              }
   1537              /* Set the DMA error callback */
   1538              hspi->hdmarx->XferErrorCallback = SPI_DMAError;
   \                     ??HAL_SPI_TransmitReceive_DMA_13: (+1)
   \   00000124   0x.... 0x....      ADR.W    R5,SPI_DMAError
   \   00000128   0x63C2             STR      R2,[R0, #+60]
   \   0000012A   0x6485             STR      R5,[R0, #+72]
   1539              
   1540              /* Enable Rx DMA Request */  
   1541              hspi->Instance->CR2 |= SPI_CR2_RXDMAEN;
   \   0000012C   0x684A             LDR      R2,[R1, #+4]
   \   0000012E   0xF042 0x0201      ORR      R2,R2,#0x1
   \   00000132   0x604A             STR      R2,[R1, #+4]
   1542              
   1543              /* Enable the Rx DMA channel */
   1544              HAL_DMA_Start_IT(hspi->hdmarx, (uint32_t)&hspi->Instance->DR, (uint32_t) hspi->pRxBuffPtr, hspi->RxXferCount);
   \   00000134   0xF8B4 0x3046      LDRH     R3,[R4, #+70]
   \   00000138   0x6C22             LDR      R2,[R4, #+64]
   \   0000013A   0x310C             ADDS     R1,R1,#+12
   \   0000013C   0x.... 0x....      BL       HAL_DMA_Start_IT
   1545              
   1546              /* Set the SPI Tx DMA transfer complete callback as NULL because the communication closing
   1547              is performed in DMA reception complete callback  */
   1548              hspi->hdmatx->XferHalfCpltCallback = NULL;
   \   00000140   0x6D60             LDR      R0,[R4, #+84]
   \   00000142   0x2100             MOVS     R1,#+0
   \   00000144   0x6401             STR      R1,[R0, #+64]
   1549              hspi->hdmatx->XferCpltCallback = NULL;
   \   00000146   0x63C1             STR      R1,[R0, #+60]
   1550          
   1551              if(hspi->State == HAL_SPI_STATE_BUSY_TX_RX)
   \   00000148   0xF894 0x105D      LDRB     R1,[R4, #+93]
   \   0000014C   0x2905             CMP      R1,#+5
   \   0000014E   0xBF0E             ITEE     EQ 
   \   00000150   0x6485             STREQ    R5,[R0, #+72]
   \   00000152   0x2100             MOVNE    R1,#+0
   \   00000154   0x6481             STRNE    R1,[R0, #+72]
   1552              {
   1553                /* Set the DMA error callback */
   1554                hspi->hdmatx->XferErrorCallback = SPI_DMAError;
   1555              }
   1556              else
   1557              {
   1558                hspi->hdmatx->XferErrorCallback = NULL;
   1559              } 
   1560              
   1561              /* Enable the Tx DMA channel */
   1562              HAL_DMA_Start_IT(hspi->hdmatx, (uint32_t)hspi->pTxBuffPtr, (uint32_t)&hspi->Instance->DR, hspi->TxXferCount);
   \   00000156   0x6821             LDR      R1,[R4, #+0]
   \   00000158   0x8FE3             LDRH     R3,[R4, #+62]
   \   0000015A   0xF101 0x020C      ADD      R2,R1,#+12
   \   0000015E   0x6BA1             LDR      R1,[R4, #+56]
   \   00000160   0x.... 0x....      BL       HAL_DMA_Start_IT
   1563          
   1564              /* Process Unlocked */
   1565              __HAL_UNLOCK(hspi);
   \   00000164   0x2000             MOVS     R0,#+0
   \   00000166   0xF884 0x005C      STRB     R0,[R4, #+92]
   1566                  
   1567              /* Check if the SPI is already enabled */ 
   1568              if((hspi->Instance->CR1 &SPI_CR1_SPE) != SPI_CR1_SPE)
   \   0000016A   0x6820             LDR      R0,[R4, #+0]
   \   0000016C   0x6801             LDR      R1,[R0, #+0]
   \   0000016E   0x0649             LSLS     R1,R1,#+25
   \   00000170   0xD403             BMI.N    ??HAL_SPI_TransmitReceive_DMA_14
   1569              {
   1570                /* Enable SPI peripheral */    
   1571                __HAL_SPI_ENABLE(hspi);
   \   00000172   0x6801             LDR      R1,[R0, #+0]
   \   00000174   0xF041 0x0140      ORR      R1,R1,#0x40
   \   00000178   0x6001             STR      R1,[R0, #+0]
   1572              }
   1573              
   1574              /* Enable Tx DMA Request */  
   1575              hspi->Instance->CR2 |= SPI_CR2_TXDMAEN;
   \                     ??HAL_SPI_TransmitReceive_DMA_14: (+1)
   \   0000017A   0x6841             LDR      R1,[R0, #+4]
   \   0000017C   0xF041 0x0102      ORR      R1,R1,#0x2
   \   00000180   0x6041             STR      R1,[R0, #+4]
   1576                  
   1577              return HAL_OK;
   \   00000182   0x2000             MOVS     R0,#+0
   \   00000184   0xB001             ADD      SP,SP,#+4
   \   00000186   0xBD30             POP      {R4,R5,PC}
   1578            }
   1579            else
   1580            {
   1581              return HAL_BUSY;
   \                     ??HAL_SPI_TransmitReceive_DMA_1: (+1)
   \   00000188   0x2002             MOVS     R0,#+2
   \   0000018A   0xB001             ADD      SP,SP,#+4
   \   0000018C   0xBD30             POP      {R4,R5,PC}       ;; return
   1582            }
   1583          }
   1584          
   1585          /**
   1586            * @brief Pauses the DMA Transfer.
   1587            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   1588            *               the configuration information for the specified SPI module.
   1589            * @retval HAL status
   1590            */

   \                                 In section .text, align 2, keep-with-next
   1591          HAL_StatusTypeDef HAL_SPI_DMAPause(SPI_HandleTypeDef *hspi)
   1592          {
   1593            /* Process Locked */
   1594            __HAL_LOCK(hspi);
   \                     HAL_SPI_DMAPause: (+1)
   \   00000000   0xF890 0x105C      LDRB     R1,[R0, #+92]
   \   00000004   0x2901             CMP      R1,#+1
   \   00000006   0xD101             BNE.N    ??HAL_SPI_DMAPause_0
   \   00000008   0x2002             MOVS     R0,#+2
   \   0000000A   0x4770             BX       LR
   \                     ??HAL_SPI_DMAPause_0: (+1)
   \   0000000C   0x2101             MOVS     R1,#+1
   \   0000000E   0xF880 0x105C      STRB     R1,[R0, #+92]
   1595          
   1596            /* Disable the SPI DMA Tx & Rx requests */
   1597            CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);
   \   00000012   0x6801             LDR      R1,[R0, #+0]
   \   00000014   0x684A             LDR      R2,[R1, #+4]
   \   00000016   0x0892             LSRS     R2,R2,#+2
   \   00000018   0x0092             LSLS     R2,R2,#+2
   \   0000001A   0x604A             STR      R2,[R1, #+4]
   1598          
   1599            /* Process Unlocked */
   1600            __HAL_UNLOCK(hspi);
   \   0000001C   0x2100             MOVS     R1,#+0
   \   0000001E   0xF880 0x105C      STRB     R1,[R0, #+92]
   1601          
   1602            return HAL_OK;
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0x4770             BX       LR               ;; return
   1603          }
   1604          
   1605          /**
   1606            * @brief Resumes the DMA Transfer.
   1607            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   1608            *               the configuration information for the specified SPI module.
   1609            * @retval HAL status
   1610            */

   \                                 In section .text, align 2, keep-with-next
   1611          HAL_StatusTypeDef HAL_SPI_DMAResume(SPI_HandleTypeDef *hspi)
   1612          {
   1613            /* Process Locked */
   1614            __HAL_LOCK(hspi);
   \                     HAL_SPI_DMAResume: (+1)
   \   00000000   0xF890 0x105C      LDRB     R1,[R0, #+92]
   \   00000004   0x2901             CMP      R1,#+1
   \   00000006   0xD101             BNE.N    ??HAL_SPI_DMAResume_0
   \   00000008   0x2002             MOVS     R0,#+2
   \   0000000A   0x4770             BX       LR
   \                     ??HAL_SPI_DMAResume_0: (+1)
   \   0000000C   0x2101             MOVS     R1,#+1
   \   0000000E   0xF880 0x105C      STRB     R1,[R0, #+92]
   1615          
   1616            /* Enable the SPI DMA Tx & Rx requests */
   1617            SET_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);
   \   00000012   0x6801             LDR      R1,[R0, #+0]
   \   00000014   0x684A             LDR      R2,[R1, #+4]
   \   00000016   0xF042 0x0203      ORR      R2,R2,#0x3
   \   0000001A   0x604A             STR      R2,[R1, #+4]
   1618          
   1619            /* Process Unlocked */
   1620            __HAL_UNLOCK(hspi);
   \   0000001C   0x2100             MOVS     R1,#+0
   \   0000001E   0xF880 0x105C      STRB     R1,[R0, #+92]
   1621          
   1622            return HAL_OK;
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0x4770             BX       LR               ;; return
   1623          }
   1624          
   1625          /**
   1626            * @brief Stops the DMA Transfer.
   1627            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   1628            *               the configuration information for the specified SPI module.
   1629            * @retval HAL status
   1630            */

   \                                 In section .text, align 2, keep-with-next
   1631          HAL_StatusTypeDef HAL_SPI_DMAStop(SPI_HandleTypeDef *hspi)
   1632          {
   \                     HAL_SPI_DMAStop: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   1633            /* The Lock is not implemented on this API to allow the user application
   1634               to call the HAL SPI API under callbacks HAL_SPI_TxCpltCallback() or HAL_SPI_RxCpltCallback() or HAL_SPI_TxRxCpltCallback():
   1635               when calling HAL_DMA_Abort() API the DMA TX/RX Transfer complete interrupt is generated
   1636               and the correspond call back is executed HAL_SPI_TxCpltCallback() or HAL_SPI_RxCpltCallback() or HAL_SPI_TxRxCpltCallback()
   1637               */
   1638            
   1639            /* Abort the SPI DMA tx Stream */
   1640            if(hspi->hdmatx != NULL)
   \   00000004   0x6D60             LDR      R0,[R4, #+84]
   \   00000006   0xB108             CBZ.N    R0,??HAL_SPI_DMAStop_0
   1641            {
   1642              HAL_DMA_Abort(hspi->hdmatx);
   \   00000008   0x.... 0x....      BL       HAL_DMA_Abort
   1643            }
   1644            /* Abort the SPI DMA rx Stream */
   1645            if(hspi->hdmarx != NULL)
   \                     ??HAL_SPI_DMAStop_0: (+1)
   \   0000000C   0x6DA0             LDR      R0,[R4, #+88]
   \   0000000E   0xB108             CBZ.N    R0,??HAL_SPI_DMAStop_1
   1646            {
   1647              HAL_DMA_Abort(hspi->hdmarx);
   \   00000010   0x.... 0x....      BL       HAL_DMA_Abort
   1648            }
   1649          
   1650            /* Disable the SPI DMA Tx & Rx requests */
   1651            CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);
   \                     ??HAL_SPI_DMAStop_1: (+1)
   \   00000014   0x6820             LDR      R0,[R4, #+0]
   \   00000016   0x6841             LDR      R1,[R0, #+4]
   \   00000018   0x0889             LSRS     R1,R1,#+2
   \   0000001A   0x0089             LSLS     R1,R1,#+2
   \   0000001C   0x6041             STR      R1,[R0, #+4]
   1652            hspi->State = HAL_SPI_STATE_READY;
   \   0000001E   0x2001             MOVS     R0,#+1
   \   00000020   0xF884 0x005D      STRB     R0,[R4, #+93]
   1653            return HAL_OK;
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0xBD10             POP      {R4,PC}          ;; return
   1654          }
   1655          
   1656          /**
   1657            * @brief  This function handles SPI interrupt request.
   1658            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   1659            *               the configuration information for the specified SPI module.
   1660            * @retval None
   1661            */

   \                                 In section .text, align 2, keep-with-next
   1662          void HAL_SPI_IRQHandler(SPI_HandleTypeDef *hspi)
   1663          {
   \                     HAL_SPI_IRQHandler: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB081             SUB      SP,SP,#+4
   1664            /* SPI in mode Receiver ----------------------------------------------------*/
   1665            if((__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_OVR) == RESET) &&
   1666               (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_RXNE) != RESET) && (__HAL_SPI_GET_IT_SOURCE(hspi, SPI_IT_RXNE) != RESET))
   \   00000004   0x6801             LDR      R1,[R0, #+0]
   \   00000006   0x688A             LDR      R2,[R1, #+8]
   \   00000008   0x0652             LSLS     R2,R2,#+25
   \   0000000A   0xD40A             BMI.N    ??HAL_SPI_IRQHandler_0
   \   0000000C   0x688A             LDR      R2,[R1, #+8]
   \   0000000E   0x07D2             LSLS     R2,R2,#+31
   \   00000010   0xD507             BPL.N    ??HAL_SPI_IRQHandler_0
   \   00000012   0x684A             LDR      R2,[R1, #+4]
   \   00000014   0x0652             LSLS     R2,R2,#+25
   \   00000016   0xD504             BPL.N    ??HAL_SPI_IRQHandler_0
   1667            {
   1668              hspi->RxISR(hspi);
   \   00000018   0x6CC1             LDR      R1,[R0, #+76]
   \   0000001A   0xB001             ADD      SP,SP,#+4
   \   0000001C   0xF85D 0xEB04      POP      {LR}
   \   00000020   0x4708             BX       R1
   1669              return;
   1670            }
   1671            
   1672            /* SPI in mode Transmitter ---------------------------------------------------*/
   1673            if((__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE) != RESET) && (__HAL_SPI_GET_IT_SOURCE(hspi, SPI_IT_TXE) != RESET))
   \                     ??HAL_SPI_IRQHandler_0: (+1)
   \   00000022   0x688A             LDR      R2,[R1, #+8]
   \   00000024   0x0792             LSLS     R2,R2,#+30
   \   00000026   0xD507             BPL.N    ??HAL_SPI_IRQHandler_1
   \   00000028   0x684A             LDR      R2,[R1, #+4]
   \   0000002A   0x0612             LSLS     R2,R2,#+24
   \   0000002C   0xD504             BPL.N    ??HAL_SPI_IRQHandler_1
   1674            {   
   1675              hspi->TxISR(hspi);
   \   0000002E   0x6D01             LDR      R1,[R0, #+80]
   \   00000030   0xB001             ADD      SP,SP,#+4
   \   00000032   0xF85D 0xEB04      POP      {LR}
   \   00000036   0x4708             BX       R1
   1676              return;
   1677            }
   1678            
   1679            /* SPI in ERROR Treatment ---------------------------------------------------*/
   1680            if((hspi->Instance->SR & (SPI_FLAG_MODF | SPI_FLAG_OVR | SPI_FLAG_FRE)) != RESET)  
   \                     ??HAL_SPI_IRQHandler_1: (+1)
   \   00000038   0x688A             LDR      R2,[R1, #+8]
   \   0000003A   0xF412 0x7FB0      TST      R2,#0x160
   \   0000003E   0xD030             BEQ.N    ??HAL_SPI_IRQHandler_2
   1681            {
   1682              /* SPI Overrun error interrupt occurred -------------------------------------*/
   1683              if(__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_OVR) != RESET) 
   \   00000040   0x688A             LDR      R2,[R1, #+8]
   \   00000042   0x0652             LSLS     R2,R2,#+25
   \   00000044   0xD50C             BPL.N    ??HAL_SPI_IRQHandler_3
   1684              {
   1685                if(hspi->State != HAL_SPI_STATE_BUSY_TX)
   \   00000046   0xF890 0x205D      LDRB     R2,[R0, #+93]
   \   0000004A   0x2A03             CMP      R2,#+3
   \   0000004C   0xD029             BEQ.N    ??HAL_SPI_IRQHandler_2
   1686                {
   1687                  hspi->ErrorCode |= HAL_SPI_ERROR_OVR;
   \   0000004E   0x6E02             LDR      R2,[R0, #+96]
   \   00000050   0xF042 0x0204      ORR      R2,R2,#0x4
   \   00000054   0x6602             STR      R2,[R0, #+96]
   1688                  __HAL_SPI_CLEAR_OVRFLAG(hspi);
   \   00000056   0x68CA             LDR      R2,[R1, #+12]
   \   00000058   0x9200             STR      R2,[SP, #+0]
   \   0000005A   0x688A             LDR      R2,[R1, #+8]
   \   0000005C   0x9200             STR      R2,[SP, #+0]
   \   0000005E   0x9A00             LDR      R2,[SP, #+0]
   1689                }
   1690                else
   1691                {
   1692                  return;
   1693                }
   1694              }
   1695              
   1696              /* SPI Mode Fault error interrupt occurred -------------------------------------*/
   1697              if(__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_MODF) != RESET)
   \                     ??HAL_SPI_IRQHandler_3: (+1)
   \   00000060   0x688A             LDR      R2,[R1, #+8]
   \   00000062   0x0692             LSLS     R2,R2,#+26
   \   00000064   0xD50A             BPL.N    ??HAL_SPI_IRQHandler_4
   1698              { 
   1699                hspi->ErrorCode |= HAL_SPI_ERROR_MODF;
   \   00000066   0x6E02             LDR      R2,[R0, #+96]
   \   00000068   0xF042 0x0201      ORR      R2,R2,#0x1
   \   0000006C   0x6602             STR      R2,[R0, #+96]
   1700                __HAL_SPI_CLEAR_MODFFLAG(hspi);
   \   0000006E   0x688A             LDR      R2,[R1, #+8]
   \   00000070   0x9200             STR      R2,[SP, #+0]
   \   00000072   0x680A             LDR      R2,[R1, #+0]
   \   00000074   0xF022 0x0240      BIC      R2,R2,#0x40
   \   00000078   0x600A             STR      R2,[R1, #+0]
   \   0000007A   0x9A00             LDR      R2,[SP, #+0]
   1701              }
   1702              
   1703              /* SPI Frame error interrupt occurred ----------------------------------------*/
   1704              if(__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_FRE) != RESET)
   \                     ??HAL_SPI_IRQHandler_4: (+1)
   \   0000007C   0x688A             LDR      R2,[R1, #+8]
   \   0000007E   0x05D2             LSLS     R2,R2,#+23
   \   00000080   0xD506             BPL.N    ??HAL_SPI_IRQHandler_5
   1705              { 
   1706                hspi->ErrorCode |= HAL_SPI_ERROR_FRE;
   \   00000082   0x6E02             LDR      R2,[R0, #+96]
   \   00000084   0xF042 0x0208      ORR      R2,R2,#0x8
   \   00000088   0x6602             STR      R2,[R0, #+96]
   1707                __HAL_SPI_CLEAR_FREFLAG(hspi);
   \   0000008A   0x688A             LDR      R2,[R1, #+8]
   \   0000008C   0x9200             STR      R2,[SP, #+0]
   \   0000008E   0x9A00             LDR      R2,[SP, #+0]
   1708              }
   1709              
   1710              __HAL_SPI_DISABLE_IT(hspi, SPI_IT_RXNE | SPI_IT_TXE | SPI_IT_ERR);
   \                     ??HAL_SPI_IRQHandler_5: (+1)
   \   00000090   0x684A             LDR      R2,[R1, #+4]
   \   00000092   0xF022 0x02E0      BIC      R2,R2,#0xE0
   \   00000096   0x604A             STR      R2,[R1, #+4]
   1711              hspi->State = HAL_SPI_STATE_READY;
   \   00000098   0x2101             MOVS     R1,#+1
   \   0000009A   0xF880 0x105D      STRB     R1,[R0, #+93]
   1712              HAL_SPI_ErrorCallback(hspi);
   \   0000009E   0x.... 0x....      BL       HAL_SPI_ErrorCallback
   1713              
   1714              return;
   1715            }
   1716          }
   \                     ??HAL_SPI_IRQHandler_2: (+1)
   \   000000A2   0xB001             ADD      SP,SP,#+4
   \   000000A4   0xBD00             POP      {PC}             ;; return
   1717          
   1718          /**
   1719            * @brief Tx Transfer completed callback
   1720            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   1721            *               the configuration information for SPI module.
   1722            * @retval None
   1723            */

   \                                 In section .text, align 2, keep-with-next
   1724          __weak void HAL_SPI_TxCpltCallback(SPI_HandleTypeDef *hspi)
   1725          {
   1726            /* NOTE : This function should not be modified, when the callback is needed,
   1727                      the HAL_SPI_TxCpltCallback should be implemented in the user file
   1728             */
   1729          }
   \                     HAL_SPI_TxCpltCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1730          
   1731          /**
   1732            * @brief Rx Transfer completed callbacks
   1733            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   1734            *               the configuration information for SPI module.
   1735            * @retval None
   1736            */

   \                                 In section .text, align 2, keep-with-next
   1737          __weak void HAL_SPI_RxCpltCallback(SPI_HandleTypeDef *hspi)
   1738          {
   1739            /* NOTE : This function should not be modified, when the callback is needed,
   1740                      the HAL_SPI_RxCpltCallback should be implemented in the user file
   1741             */
   1742          }
   \                     HAL_SPI_RxCpltCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1743          
   1744          /**
   1745            * @brief Tx and Rx Transfer completed callback
   1746            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   1747            *               the configuration information for SPI module.
   1748            * @retval None
   1749            */

   \                                 In section .text, align 2, keep-with-next
   1750          __weak void HAL_SPI_TxRxCpltCallback(SPI_HandleTypeDef *hspi)
   1751          {
   1752            /* NOTE : This function should not be modified, when the callback is needed,
   1753                      the HAL_SPI_TxRxCpltCallback should be implemented in the user file
   1754             */
   1755          }
   \                     HAL_SPI_TxRxCpltCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1756          
   1757          /**
   1758            * @brief Tx Half Transfer completed callback
   1759            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   1760            *               the configuration information for SPI module.
   1761            * @retval None
   1762            */

   \                                 In section .text, align 2, keep-with-next
   1763          __weak void HAL_SPI_TxHalfCpltCallback(SPI_HandleTypeDef *hspi)
   1764          {
   1765            /* NOTE : This function should not be modified, when the callback is needed,
   1766                      the HAL_SPI_TxHalfCpltCallback should be implemented in the user file
   1767             */
   1768          }
   \                     HAL_SPI_TxHalfCpltCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1769          
   1770          /**
   1771            * @brief Rx Half Transfer completed callback
   1772            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   1773            *               the configuration information for SPI module.
   1774            * @retval None
   1775            */

   \                                 In section .text, align 2, keep-with-next
   1776          __weak void HAL_SPI_RxHalfCpltCallback(SPI_HandleTypeDef *hspi)
   1777          {
   1778            /* NOTE : This function should not be modified, when the callback is needed,
   1779                      the HAL_SPI_RxHalfCpltCallback() should be implemented in the user file
   1780             */
   1781          }
   \                     HAL_SPI_RxHalfCpltCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1782          
   1783          /**
   1784            * @brief Tx and Rx Half Transfer callback
   1785            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   1786            *               the configuration information for SPI module.
   1787            * @retval None
   1788            */

   \                                 In section .text, align 2, keep-with-next
   1789          __weak void HAL_SPI_TxRxHalfCpltCallback(SPI_HandleTypeDef *hspi)
   1790          {
   1791            /* NOTE : This function should not be modified, when the callback is needed,
   1792                      the HAL_SPI_TxRxHalfCpltCallback() should be implemented in the user file
   1793             */
   1794          }
   \                     HAL_SPI_TxRxHalfCpltCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1795          
   1796          /**
   1797            * @brief SPI error callback
   1798            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   1799            *               the configuration information for SPI module.
   1800            * @retval None
   1801            */

   \                                 In section .text, align 2, keep-with-next
   1802           __weak void HAL_SPI_ErrorCallback(SPI_HandleTypeDef *hspi)
   1803          {
   1804            /* NOTE : This function should not be modified, when the callback is needed,
   1805                      the HAL_SPI_ErrorCallback should be implemented in the user file
   1806             */
   1807            /* NOTE : The ErrorCode parameter in the hspi handle is updated by the SPI processes
   1808                      and user can use HAL_SPI_GetError() API to check the latest error occurred
   1809             */
   1810          }
   \                     HAL_SPI_ErrorCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1811          
   1812          /**
   1813            * @}
   1814            */
   1815          
   1816          /**
   1817            * @}
   1818            */
   1819          
   1820          /** @defgroup SPI_Exported_Functions_Group3 Peripheral State and Errors functions
   1821            *  @brief   SPI control functions
   1822            *
   1823          @verbatim
   1824           ===============================================================================
   1825                                ##### Peripheral State and Errors functions #####
   1826           ===============================================================================
   1827              [..]
   1828              This subsection provides a set of functions allowing to control the SPI.
   1829               (+) HAL_SPI_GetState() API can be helpful to check in run-time the state of the SPI peripheral
   1830               (+) HAL_SPI_GetError() check in run-time Errors occurring during communication
   1831          @endverbatim
   1832            * @{
   1833            */
   1834          
   1835          /**
   1836            * @brief  Return the SPI state
   1837            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   1838            *               the configuration information for SPI module.
   1839            * @retval SPI state
   1840            */

   \                                 In section .text, align 2, keep-with-next
   1841          HAL_SPI_StateTypeDef HAL_SPI_GetState(SPI_HandleTypeDef *hspi)
   1842          {
   1843            return hspi->State;
   \                     HAL_SPI_GetState: (+1)
   \   00000000   0xF890 0x005D      LDRB     R0,[R0, #+93]
   \   00000004   0x4770             BX       LR               ;; return
   1844          }
   1845          
   1846          /**
   1847            * @brief  Return the SPI error code
   1848            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   1849            *               the configuration information for SPI module.
   1850            * @retval SPI error code in bitmap format
   1851            */

   \                                 In section .text, align 2, keep-with-next
   1852          uint32_t HAL_SPI_GetError(SPI_HandleTypeDef *hspi)
   1853          {
   1854            return hspi->ErrorCode;
   \                     HAL_SPI_GetError: (+1)
   \   00000000   0x6E00             LDR      R0,[R0, #+96]
   \   00000002   0x4770             BX       LR               ;; return
   1855          }
   1856          
   1857          /**
   1858            * @}
   1859            */
   1860          
   1861          /**
   1862            * @}
   1863            */
   1864          
   1865          /** @defgroup SPI_Private_Functions SPI Private Functions
   1866            * @{
   1867            */
   1868          
   1869          /**
   1870            * @brief DMA SPI transmit process complete callback
   1871            * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
   1872            *               the configuration information for the specified DMA module.
   1873            * @retval None
   1874            */

   \                                 In section .text, align 4, keep-with-next
   1875          static void SPI_DMATransmitCplt(DMA_HandleTypeDef *hdma)
   1876          {
   \                     SPI_DMATransmitCplt: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0x4601             MOV      R1,R0
   \   00000004   0xB081             SUB      SP,SP,#+4
   1877            SPI_HandleTypeDef* hspi = ( SPI_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   \   00000006   0x6B88             LDR      R0,[R1, #+56]
   1878          
   1879            /* DMA Normal Mode */
   1880            if((hdma->Instance->CR & DMA_SxCR_CIRC) == 0)
   \   00000008   0x6809             LDR      R1,[R1, #+0]
   \   0000000A   0x6809             LDR      R1,[R1, #+0]
   \   0000000C   0x05C9             LSLS     R1,R1,#+23
   \   0000000E   0xD416             BMI.N    ??SPI_DMATransmitCplt_0
   1881            {
   1882              /* Disable Tx DMA Request */
   1883              CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN);
   \   00000010   0x6801             LDR      R1,[R0, #+0]
   \   00000012   0x684A             LDR      R2,[R1, #+4]
   \   00000014   0xF022 0x0202      BIC      R2,R2,#0x2
   \   00000018   0x604A             STR      R2,[R1, #+4]
   1884          
   1885              /* Clear OVERUN flag in 2 Lines communication mode because received data is not read */
   1886              if(hspi->Init.Direction == SPI_DIRECTION_2LINES)
   \   0000001A   0x6882             LDR      R2,[R0, #+8]
   \   0000001C   0xB922             CBNZ.N   R2,??SPI_DMATransmitCplt_1
   1887              {
   1888                __HAL_SPI_CLEAR_OVRFLAG(hspi);
   \   0000001E   0x68CA             LDR      R2,[R1, #+12]
   \   00000020   0x9200             STR      R2,[SP, #+0]
   \   00000022   0x6889             LDR      R1,[R1, #+8]
   \   00000024   0x9100             STR      R1,[SP, #+0]
   \   00000026   0x9900             LDR      R1,[SP, #+0]
   1889              }
   1890          
   1891              hspi->TxXferCount = 0;
   \                     ??SPI_DMATransmitCplt_1: (+1)
   \   00000028   0x2100             MOVS     R1,#+0
   \   0000002A   0x87C1             STRH     R1,[R0, #+62]
   1892              hspi->State = HAL_SPI_STATE_READY;
   \   0000002C   0x2101             MOVS     R1,#+1
   \   0000002E   0xF880 0x105D      STRB     R1,[R0, #+93]
   1893          
   1894              if(hspi->ErrorCode != HAL_SPI_ERROR_NONE)
   \   00000032   0x6E01             LDR      R1,[R0, #+96]
   \   00000034   0xB119             CBZ.N    R1,??SPI_DMATransmitCplt_0
   1895              {
   1896                HAL_SPI_ErrorCallback(hspi);
   \   00000036   0x.... 0x....      BL       HAL_SPI_ErrorCallback
   1897                return;
   1898              }
   1899            }
   1900            HAL_SPI_TxCpltCallback(hspi);
   1901          }
   \   0000003A   0xB001             ADD      SP,SP,#+4
   \   0000003C   0xBD00             POP      {PC}
   \                     ??SPI_DMATransmitCplt_0: (+1)
   \   0000003E   0x.... 0x....      BL       HAL_SPI_TxCpltCallback
   \   00000042   0xB001             ADD      SP,SP,#+4
   \   00000044   0xBD00             POP      {PC}             ;; return
   1902          
   1903          /**
   1904            * @brief DMA SPI receive process complete callback
   1905            * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
   1906            *               the configuration information for the specified DMA module.
   1907            * @retval None
   1908            */

   \                                 In section .text, align 4, keep-with-next
   1909          static void SPI_DMAReceiveCplt(DMA_HandleTypeDef *hdma)
   1910          {
   \                     SPI_DMAReceiveCplt: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB081             SUB      SP,SP,#+4
   1911            __IO uint16_t tmpreg;
   1912            SPI_HandleTypeDef* hspi = ( SPI_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   \   00000004   0x6B84             LDR      R4,[R0, #+56]
   1913            
   1914            /* DMA Normal mode */
   1915            if((hdma->Instance->CR & DMA_SxCR_CIRC) == 0)
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0x6800             LDR      R0,[R0, #+0]
   \   0000000A   0x05C0             LSLS     R0,R0,#+23
   \   0000000C   0xF100 0x8103      BMI.W    ??SPI_DMAReceiveCplt_0
   1916            {  
   1917              /* CRC handling */
   1918              if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   \   00000010   0x6AA0             LDR      R0,[R4, #+40]
   \   00000012   0xF5B0 0x5F00      CMP      R0,#+8192
   \   00000016   0xF040 0x8083      BNE.W    ??SPI_DMAReceiveCplt_1
   1919              {
   1920                /* Wait until TXE flag */
   1921                if(SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_RXNE, SPI_FLAG_RXNE, SPI_DEFAULT_TIMEOUT) != HAL_OK)
   \   0000001A   0x.... 0x....      BL       HAL_GetTick
   \   0000001E   0x4605             MOV      R5,R0
   \                     ??SPI_DMAReceiveCplt_2: (+1)
   \   00000020   0x6820             LDR      R0,[R4, #+0]
   \   00000022   0x6880             LDR      R0,[R0, #+8]
   \   00000024   0x07C0             LSLS     R0,R0,#+31
   \   00000026   0xD42F             BMI.N    ??SPI_DMAReceiveCplt_3
   \   00000028   0x.... 0x....      BL       HAL_GetTick
   \   0000002C   0x1B40             SUBS     R0,R0,R5
   \   0000002E   0x2832             CMP      R0,#+50
   \   00000030   0xD3F6             BCC.N    ??SPI_DMAReceiveCplt_2
   \   00000032   0x6820             LDR      R0,[R4, #+0]
   \   00000034   0x6841             LDR      R1,[R0, #+4]
   \   00000036   0xF021 0x01E0      BIC      R1,R1,#0xE0
   \   0000003A   0x6041             STR      R1,[R0, #+4]
   \   0000003C   0x6861             LDR      R1,[R4, #+4]
   \   0000003E   0xF5B1 0x7F82      CMP      R1,#+260
   \   00000042   0xD10A             BNE.N    ??SPI_DMAReceiveCplt_4
   \   00000044   0x68A1             LDR      R1,[R4, #+8]
   \   00000046   0xF5B1 0x4F00      CMP      R1,#+32768
   \   0000004A   0xBF18             IT       NE 
   \   0000004C   0xF5B1 0x6F80      CMPNE    R1,#+1024
   \   00000050   0xD103             BNE.N    ??SPI_DMAReceiveCplt_4
   \   00000052   0x6801             LDR      R1,[R0, #+0]
   \   00000054   0xF021 0x0140      BIC      R1,R1,#0x40
   \   00000058   0x6001             STR      R1,[R0, #+0]
   \                     ??SPI_DMAReceiveCplt_4: (+1)
   \   0000005A   0x6AA1             LDR      R1,[R4, #+40]
   \   0000005C   0xF5B1 0x5F00      CMP      R1,#+8192
   \   00000060   0xD108             BNE.N    ??SPI_DMAReceiveCplt_5
   \   00000062   0x6801             LDR      R1,[R0, #+0]
   \   00000064   0xF64D 0x72FF      MOVW     R2,#+57343
   \   00000068   0x4011             ANDS     R1,R2,R1
   \   0000006A   0x6001             STR      R1,[R0, #+0]
   \   0000006C   0x6801             LDR      R1,[R0, #+0]
   \   0000006E   0xF441 0x5100      ORR      R1,R1,#0x2000
   \   00000072   0x6001             STR      R1,[R0, #+0]
   \                     ??SPI_DMAReceiveCplt_5: (+1)
   \   00000074   0x2001             MOVS     R0,#+1
   \   00000076   0xF884 0x005D      STRB     R0,[R4, #+93]
   \   0000007A   0x2000             MOVS     R0,#+0
   \   0000007C   0xF884 0x005C      STRB     R0,[R4, #+92]
   1922                {
   1923                  /* Error on the CRC reception */
   1924                  hspi->ErrorCode|= HAL_SPI_ERROR_CRC;      
   \   00000080   0x6E20             LDR      R0,[R4, #+96]
   \   00000082   0xF040 0x0002      ORR      R0,R0,#0x2
   \   00000086   0x6620             STR      R0,[R4, #+96]
   1925                }
   1926                if(hspi->Init.DataSize > SPI_DATASIZE_8BIT)
   \                     ??SPI_DMAReceiveCplt_3: (+1)
   \   00000088   0x68E1             LDR      R1,[R4, #+12]
   \   0000008A   0x6820             LDR      R0,[R4, #+0]
   \   0000008C   0xF5B1 0x6FE0      CMP      R1,#+1792
   \   00000090   0xBF88             IT       HI 
   \   00000092   0x68C0             LDRHI    R0,[R0, #+12]
   1927                {        
   1928                  tmpreg = hspi->Instance->DR;
   \   00000094   0xD840             BHI.N    ??SPI_DMAReceiveCplt_6
   1929                  UNUSED(tmpreg); /* To avoid GCC warning */
   1930                }
   1931                else
   1932                {
   1933                  tmpreg = *(__IO uint8_t *)&hspi->Instance->DR;
   \   00000096   0x7B00             LDRB     R0,[R0, #+12]
   \   00000098   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   1934                  UNUSED(tmpreg); /* To avoid GCC warning */
   \   0000009C   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   1935                  
   1936                  if(hspi->Init.CRCLength == SPI_CRC_LENGTH_16BIT)
   \   000000A0   0x6B20             LDR      R0,[R4, #+48]
   \   000000A2   0x2802             CMP      R0,#+2
   \   000000A4   0xD13C             BNE.N    ??SPI_DMAReceiveCplt_1
   1937                  {
   1938                    if(SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_RXNE, SPI_FLAG_RXNE, SPI_DEFAULT_TIMEOUT) != HAL_OK)
   \   000000A6   0x.... 0x....      BL       HAL_GetTick
   \   000000AA   0x4605             MOV      R5,R0
   \                     ??SPI_DMAReceiveCplt_7: (+1)
   \   000000AC   0x6820             LDR      R0,[R4, #+0]
   \   000000AE   0x6880             LDR      R0,[R0, #+8]
   \   000000B0   0x07C0             LSLS     R0,R0,#+31
   \   000000B2   0xD42F             BMI.N    ??SPI_DMAReceiveCplt_8
   \   000000B4   0x.... 0x....      BL       HAL_GetTick
   \   000000B8   0x1B40             SUBS     R0,R0,R5
   \   000000BA   0x2832             CMP      R0,#+50
   \   000000BC   0xD3F6             BCC.N    ??SPI_DMAReceiveCplt_7
   \   000000BE   0x6820             LDR      R0,[R4, #+0]
   \   000000C0   0x6841             LDR      R1,[R0, #+4]
   \   000000C2   0xF021 0x01E0      BIC      R1,R1,#0xE0
   \   000000C6   0x6041             STR      R1,[R0, #+4]
   \   000000C8   0x6861             LDR      R1,[R4, #+4]
   \   000000CA   0xF5B1 0x7F82      CMP      R1,#+260
   \   000000CE   0xD10A             BNE.N    ??SPI_DMAReceiveCplt_9
   \   000000D0   0x68A1             LDR      R1,[R4, #+8]
   \   000000D2   0xF5B1 0x4F00      CMP      R1,#+32768
   \   000000D6   0xBF18             IT       NE 
   \   000000D8   0xF5B1 0x6F80      CMPNE    R1,#+1024
   \   000000DC   0xD103             BNE.N    ??SPI_DMAReceiveCplt_9
   \   000000DE   0x6801             LDR      R1,[R0, #+0]
   \   000000E0   0xF021 0x0140      BIC      R1,R1,#0x40
   \   000000E4   0x6001             STR      R1,[R0, #+0]
   \                     ??SPI_DMAReceiveCplt_9: (+1)
   \   000000E6   0x6AA1             LDR      R1,[R4, #+40]
   \   000000E8   0xF5B1 0x5F00      CMP      R1,#+8192
   \   000000EC   0xD108             BNE.N    ??SPI_DMAReceiveCplt_10
   \   000000EE   0x6801             LDR      R1,[R0, #+0]
   \   000000F0   0xF64D 0x72FF      MOVW     R2,#+57343
   \   000000F4   0x4011             ANDS     R1,R2,R1
   \   000000F6   0x6001             STR      R1,[R0, #+0]
   \   000000F8   0x6801             LDR      R1,[R0, #+0]
   \   000000FA   0xF441 0x5100      ORR      R1,R1,#0x2000
   \   000000FE   0x6001             STR      R1,[R0, #+0]
   \                     ??SPI_DMAReceiveCplt_10: (+1)
   \   00000100   0x2001             MOVS     R0,#+1
   \   00000102   0xF884 0x005D      STRB     R0,[R4, #+93]
   \   00000106   0x2000             MOVS     R0,#+0
   \   00000108   0xF884 0x005C      STRB     R0,[R4, #+92]
   1939                    {
   1940                      /* Error on the CRC reception */
   1941                      hspi->ErrorCode|= HAL_SPI_ERROR_CRC;      
   \   0000010C   0x6E20             LDR      R0,[R4, #+96]
   \   0000010E   0xF040 0x0002      ORR      R0,R0,#0x2
   \   00000112   0x6620             STR      R0,[R4, #+96]
   1942                    }
   1943                    tmpreg = *(__IO uint8_t *)&hspi->Instance->DR;
   \                     ??SPI_DMAReceiveCplt_8: (+1)
   \   00000114   0x6820             LDR      R0,[R4, #+0]
   \   00000116   0x7B00             LDRB     R0,[R0, #+12]
   \                     ??SPI_DMAReceiveCplt_6: (+1)
   \   00000118   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   1944                    UNUSED(tmpreg); /* To avoid GCC warning */
   \   0000011C   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   1945                  }
   1946                }  
   1947              }
   1948              
   1949              /* Disable Rx DMA Request */
   1950              hspi->Instance->CR2 &= (uint32_t)(~SPI_CR2_RXDMAEN);
   \                     ??SPI_DMAReceiveCplt_1: (+1)
   \   00000120   0x6820             LDR      R0,[R4, #+0]
   \   00000122   0x6841             LDR      R1,[R0, #+4]
   \   00000124   0x0849             LSRS     R1,R1,#+1
   \   00000126   0x0049             LSLS     R1,R1,#+1
   \   00000128   0x6041             STR      R1,[R0, #+4]
   1951              /* Disable Tx DMA Request (done by default to handle the case master rx direction 2 lines) */
   1952              hspi->Instance->CR2 &= (uint32_t)(~SPI_CR2_TXDMAEN);
   \   0000012A   0x6841             LDR      R1,[R0, #+4]
   \   0000012C   0xF021 0x0102      BIC      R1,R1,#0x2
   \   00000130   0x6041             STR      R1,[R0, #+4]
   1953              
   1954              /* Check the end of the transaction */
   1955              SPI_EndRxTransaction(hspi,SPI_DEFAULT_TIMEOUT);
   \   00000132   0x6861             LDR      R1,[R4, #+4]
   \   00000134   0xF5B1 0x7F82      CMP      R1,#+260
   \   00000138   0xD10A             BNE.N    ??SPI_DMAReceiveCplt_11
   \   0000013A   0x68A1             LDR      R1,[R4, #+8]
   \   0000013C   0xF5B1 0x4F00      CMP      R1,#+32768
   \   00000140   0xBF18             IT       NE 
   \   00000142   0xF5B1 0x6F80      CMPNE    R1,#+1024
   \   00000146   0xD103             BNE.N    ??SPI_DMAReceiveCplt_11
   \   00000148   0x6801             LDR      R1,[R0, #+0]
   \   0000014A   0xF021 0x0140      BIC      R1,R1,#0x40
   \   0000014E   0x6001             STR      R1,[R0, #+0]
   \                     ??SPI_DMAReceiveCplt_11: (+1)
   \   00000150   0x.... 0x....      BL       HAL_GetTick
   \   00000154   0x4605             MOV      R5,R0
   \                     ??SPI_DMAReceiveCplt_12: (+1)
   \   00000156   0x6820             LDR      R0,[R4, #+0]
   \   00000158   0x6880             LDR      R0,[R0, #+8]
   \   0000015A   0x0600             LSLS     R0,R0,#+24
   \   0000015C   0xD505             BPL.N    ??SPI_DMAReceiveCplt_13
   \   0000015E   0x.... 0x....      BL       HAL_GetTick
   \   00000162   0x1B40             SUBS     R0,R0,R5
   \   00000164   0x2832             CMP      R0,#+50
   \   00000166   0xD3F6             BCC.N    ??SPI_DMAReceiveCplt_12
   \   00000168   0xE011             B.N      ??SPI_DMAReceiveCplt_14
   \                     ??SPI_DMAReceiveCplt_13: (+1)
   \   0000016A   0x.... 0x....      BL       HAL_GetTick
   \   0000016E   0x4605             MOV      R5,R0
   \                     ??SPI_DMAReceiveCplt_15: (+1)
   \   00000170   0x6820             LDR      R0,[R4, #+0]
   \   00000172   0x6881             LDR      R1,[R0, #+8]
   \   00000174   0xF411 0x6FC0      TST      R1,#0x600
   \   00000178   0xD034             BEQ.N    ??SPI_DMAReceiveCplt_16
   \   0000017A   0x7B00             LDRB     R0,[R0, #+12]
   \   0000017C   0xF88D 0x0002      STRB     R0,[SP, #+2]
   \   00000180   0xF89D 0x0002      LDRB     R0,[SP, #+2]
   \   00000184   0x.... 0x....      BL       HAL_GetTick
   \   00000188   0x1B40             SUBS     R0,R0,R5
   \   0000018A   0x2832             CMP      R0,#+50
   \   0000018C   0xD3F0             BCC.N    ??SPI_DMAReceiveCplt_15
   \                     ??SPI_DMAReceiveCplt_14: (+1)
   \   0000018E   0x6820             LDR      R0,[R4, #+0]
   \   00000190   0x6841             LDR      R1,[R0, #+4]
   \   00000192   0xF021 0x01E0      BIC      R1,R1,#0xE0
   \   00000196   0x6041             STR      R1,[R0, #+4]
   \   00000198   0x6861             LDR      R1,[R4, #+4]
   \   0000019A   0xF5B1 0x7F82      CMP      R1,#+260
   \   0000019E   0xD10A             BNE.N    ??SPI_DMAReceiveCplt_17
   \   000001A0   0x68A1             LDR      R1,[R4, #+8]
   \   000001A2   0xF5B1 0x4F00      CMP      R1,#+32768
   \   000001A6   0xBF18             IT       NE 
   \   000001A8   0xF5B1 0x6F80      CMPNE    R1,#+1024
   \   000001AC   0xD103             BNE.N    ??SPI_DMAReceiveCplt_17
   \   000001AE   0x6801             LDR      R1,[R0, #+0]
   \   000001B0   0xF021 0x0140      BIC      R1,R1,#0x40
   \   000001B4   0x6001             STR      R1,[R0, #+0]
   \                     ??SPI_DMAReceiveCplt_17: (+1)
   \   000001B6   0x6AA1             LDR      R1,[R4, #+40]
   \   000001B8   0xF5B1 0x5F00      CMP      R1,#+8192
   \   000001BC   0xD108             BNE.N    ??SPI_DMAReceiveCplt_18
   \   000001BE   0x6801             LDR      R1,[R0, #+0]
   \   000001C0   0xF64D 0x72FF      MOVW     R2,#+57343
   \   000001C4   0x4011             ANDS     R1,R2,R1
   \   000001C6   0x6001             STR      R1,[R0, #+0]
   \   000001C8   0x6801             LDR      R1,[R0, #+0]
   \   000001CA   0xF441 0x5100      ORR      R1,R1,#0x2000
   \   000001CE   0x6001             STR      R1,[R0, #+0]
   \                     ??SPI_DMAReceiveCplt_18: (+1)
   \   000001D0   0x2001             MOVS     R0,#+1
   \   000001D2   0xF884 0x005D      STRB     R0,[R4, #+93]
   \   000001D6   0x2000             MOVS     R0,#+0
   \   000001D8   0xF884 0x005C      STRB     R0,[R4, #+92]
   \   000001DC   0x6E20             LDR      R0,[R4, #+96]
   \   000001DE   0xF040 0x0020      ORR      R0,R0,#0x20
   \   000001E2   0x6620             STR      R0,[R4, #+96]
   1956              
   1957              hspi->RxXferCount = 0;
   \                     ??SPI_DMAReceiveCplt_16: (+1)
   \   000001E4   0x2000             MOVS     R0,#+0
   \   000001E6   0xF8A4 0x0046      STRH     R0,[R4, #+70]
   1958              hspi->State = HAL_SPI_STATE_READY;
   \   000001EA   0x2001             MOVS     R0,#+1
   \   000001EC   0xF884 0x005D      STRB     R0,[R4, #+93]
   1959              
   1960              /* Check if CRC error occurred */
   1961              if(__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_CRCERR) != RESET)
   \   000001F0   0x6821             LDR      R1,[R4, #+0]
   \   000001F2   0x6E20             LDR      R0,[R4, #+96]
   \   000001F4   0x688A             LDR      R2,[R1, #+8]
   \   000001F6   0x06D2             LSLS     R2,R2,#+27
   \   000001F8   0xD506             BPL.N    ??SPI_DMAReceiveCplt_19
   1962              {
   1963                hspi->ErrorCode|= HAL_SPI_ERROR_CRC;
   \   000001FA   0xF040 0x0002      ORR      R0,R0,#0x2
   \   000001FE   0x6620             STR      R0,[R4, #+96]
   1964                __HAL_SPI_CLEAR_CRCERRFLAG(hspi);
   \   00000200   0xF64F 0x70EF      MOVW     R0,#+65519
   \   00000204   0x6088             STR      R0,[R1, #+8]
   1965                HAL_SPI_RxCpltCallback(hspi);
   \   00000206   0xE006             B.N      ??SPI_DMAReceiveCplt_0
   1966              }
   1967              else
   1968              {
   1969                if(hspi->ErrorCode == HAL_SPI_ERROR_NONE)
   \                     ??SPI_DMAReceiveCplt_19: (+1)
   \   00000208   0x2800             CMP      R0,#+0
   \   0000020A   0x4620             MOV      R0,R4
   \   0000020C   0xD004             BEQ.N    ??SPI_DMAReceiveCplt_20
   1970                {
   1971                  HAL_SPI_RxCpltCallback(hspi);
   1972                }
   1973                else
   1974                {
   1975                  HAL_SPI_ErrorCallback(hspi); 
   \   0000020E   0x.... 0x....      BL       HAL_SPI_ErrorCallback
   1976                }
   1977              }
   1978            }
   1979            else
   1980            {
   1981              HAL_SPI_RxCpltCallback(hspi);
   1982            }
   1983          }
   \   00000212   0xB001             ADD      SP,SP,#+4
   \   00000214   0xBD30             POP      {R4,R5,PC}
   \                     ??SPI_DMAReceiveCplt_0: (+1)
   \   00000216   0x4620             MOV      R0,R4
   \                     ??SPI_DMAReceiveCplt_20: (+1)
   \   00000218   0x.... 0x....      BL       HAL_SPI_RxCpltCallback
   \   0000021C   0xB001             ADD      SP,SP,#+4
   \   0000021E   0xBD30             POP      {R4,R5,PC}       ;; return
   1984          
   1985          /**
   1986            * @brief DMA SPI transmit receive process complete callback
   1987            * @param  hdma : pointer to a DMA_HandleTypeDef structure that contains
   1988            *               the configuration information for the specified DMA module.
   1989            * @retval None
   1990            */

   \                                 In section .text, align 4, keep-with-next
   1991          static void SPI_DMATransmitReceiveCplt(DMA_HandleTypeDef *hdma)
   1992          {
   \                     SPI_DMATransmitReceiveCplt: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB081             SUB      SP,SP,#+4
   1993            __IO int16_t tmpreg;
   1994            SPI_HandleTypeDef* hspi = ( SPI_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   \   00000004   0x6B84             LDR      R4,[R0, #+56]
   1995            
   1996            /* CRC handling */
   1997            if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   \   00000006   0x6AA0             LDR      R0,[R4, #+40]
   \   00000008   0xF5B0 0x5F00      CMP      R0,#+8192
   \   0000000C   0xF040 0x8084      BNE.W    ??SPI_DMATransmitReceiveCplt_0
   1998            {
   1999              if((hspi->Init.DataSize == SPI_DATASIZE_8BIT) && (hspi->Init.CRCLength == SPI_CRC_LENGTH_8BIT))
   \   00000010   0x68E0             LDR      R0,[R4, #+12]
   \   00000012   0xF5B0 0x6FE0      CMP      R0,#+1792
   \   00000016   0xBF04             ITT      EQ 
   \   00000018   0x6B20             LDREQ    R0,[R4, #+48]
   \   0000001A   0x2801             CMPEQ    R0,#+1
   \   0000001C   0xD13C             BNE.N    ??SPI_DMATransmitReceiveCplt_1
   2000              {        
   2001                if(SPI_WaitFifoStateUntilTimeout(hspi, SPI_FLAG_FRLVL, SPI_FRLVL_QUARTER_FULL, SPI_DEFAULT_TIMEOUT) != HAL_OK)
   \   0000001E   0x.... 0x....      BL       HAL_GetTick
   \   00000022   0x4605             MOV      R5,R0
   \                     ??SPI_DMATransmitReceiveCplt_2: (+1)
   \   00000024   0x6820             LDR      R0,[R4, #+0]
   \   00000026   0x6880             LDR      R0,[R0, #+8]
   \   00000028   0xF400 0x60C0      AND      R0,R0,#0x600
   \   0000002C   0xF5B0 0x7F00      CMP      R0,#+512
   \   00000030   0xD02F             BEQ.N    ??SPI_DMATransmitReceiveCplt_3
   \   00000032   0x.... 0x....      BL       HAL_GetTick
   \   00000036   0x1B40             SUBS     R0,R0,R5
   \   00000038   0x2832             CMP      R0,#+50
   \   0000003A   0xD3F3             BCC.N    ??SPI_DMATransmitReceiveCplt_2
   \   0000003C   0x6820             LDR      R0,[R4, #+0]
   \   0000003E   0x6841             LDR      R1,[R0, #+4]
   \   00000040   0xF021 0x01E0      BIC      R1,R1,#0xE0
   \   00000044   0x6041             STR      R1,[R0, #+4]
   \   00000046   0x6861             LDR      R1,[R4, #+4]
   \   00000048   0xF5B1 0x7F82      CMP      R1,#+260
   \   0000004C   0xD10A             BNE.N    ??SPI_DMATransmitReceiveCplt_4
   \   0000004E   0x68A1             LDR      R1,[R4, #+8]
   \   00000050   0xF5B1 0x4F00      CMP      R1,#+32768
   \   00000054   0xBF18             IT       NE 
   \   00000056   0xF5B1 0x6F80      CMPNE    R1,#+1024
   \   0000005A   0xD103             BNE.N    ??SPI_DMATransmitReceiveCplt_4
   \   0000005C   0x6801             LDR      R1,[R0, #+0]
   \   0000005E   0xF021 0x0140      BIC      R1,R1,#0x40
   \   00000062   0x6001             STR      R1,[R0, #+0]
   \                     ??SPI_DMATransmitReceiveCplt_4: (+1)
   \   00000064   0x6AA1             LDR      R1,[R4, #+40]
   \   00000066   0xF5B1 0x5F00      CMP      R1,#+8192
   \   0000006A   0xD108             BNE.N    ??SPI_DMATransmitReceiveCplt_5
   \   0000006C   0x6801             LDR      R1,[R0, #+0]
   \   0000006E   0xF64D 0x72FF      MOVW     R2,#+57343
   \   00000072   0x4011             ANDS     R1,R2,R1
   \   00000074   0x6001             STR      R1,[R0, #+0]
   \   00000076   0x6801             LDR      R1,[R0, #+0]
   \   00000078   0xF441 0x5100      ORR      R1,R1,#0x2000
   \   0000007C   0x6001             STR      R1,[R0, #+0]
   \                     ??SPI_DMATransmitReceiveCplt_5: (+1)
   \   0000007E   0x2001             MOVS     R0,#+1
   \   00000080   0xF884 0x005D      STRB     R0,[R4, #+93]
   \   00000084   0x2000             MOVS     R0,#+0
   \   00000086   0xF884 0x005C      STRB     R0,[R4, #+92]
   2002                {
   2003                  /* Error on the CRC reception */
   2004                  hspi->ErrorCode|= HAL_SPI_ERROR_CRC;      
   \   0000008A   0x6E20             LDR      R0,[R4, #+96]
   \   0000008C   0xF040 0x0002      ORR      R0,R0,#0x2
   \   00000090   0x6620             STR      R0,[R4, #+96]
   2005                }
   2006                tmpreg = *(__IO uint8_t *)&hspi->Instance->DR;
   \                     ??SPI_DMATransmitReceiveCplt_3: (+1)
   \   00000092   0x6820             LDR      R0,[R4, #+0]
   \   00000094   0x7B00             LDRB     R0,[R0, #+12]
   \   00000096   0xE03B             B.N      ??SPI_DMATransmitReceiveCplt_6
   2007                UNUSED(tmpreg); /* To avoid GCC warning */
   2008              }
   2009              else
   2010              {
   2011                if(SPI_WaitFifoStateUntilTimeout(hspi, SPI_FLAG_FRLVL, SPI_FRLVL_HALF_FULL, SPI_DEFAULT_TIMEOUT) != HAL_OK)
   \                     ??SPI_DMATransmitReceiveCplt_1: (+1)
   \   00000098   0x.... 0x....      BL       HAL_GetTick
   \   0000009C   0x4605             MOV      R5,R0
   \                     ??SPI_DMATransmitReceiveCplt_7: (+1)
   \   0000009E   0x6820             LDR      R0,[R4, #+0]
   \   000000A0   0x6880             LDR      R0,[R0, #+8]
   \   000000A2   0xF400 0x60C0      AND      R0,R0,#0x600
   \   000000A6   0xF5B0 0x6F80      CMP      R0,#+1024
   \   000000AA   0xD02F             BEQ.N    ??SPI_DMATransmitReceiveCplt_8
   \   000000AC   0x.... 0x....      BL       HAL_GetTick
   \   000000B0   0x1B40             SUBS     R0,R0,R5
   \   000000B2   0x2832             CMP      R0,#+50
   \   000000B4   0xD3F3             BCC.N    ??SPI_DMATransmitReceiveCplt_7
   \   000000B6   0x6820             LDR      R0,[R4, #+0]
   \   000000B8   0x6841             LDR      R1,[R0, #+4]
   \   000000BA   0xF021 0x01E0      BIC      R1,R1,#0xE0
   \   000000BE   0x6041             STR      R1,[R0, #+4]
   \   000000C0   0x6861             LDR      R1,[R4, #+4]
   \   000000C2   0xF5B1 0x7F82      CMP      R1,#+260
   \   000000C6   0xD10A             BNE.N    ??SPI_DMATransmitReceiveCplt_9
   \   000000C8   0x68A1             LDR      R1,[R4, #+8]
   \   000000CA   0xF5B1 0x4F00      CMP      R1,#+32768
   \   000000CE   0xBF18             IT       NE 
   \   000000D0   0xF5B1 0x6F80      CMPNE    R1,#+1024
   \   000000D4   0xD103             BNE.N    ??SPI_DMATransmitReceiveCplt_9
   \   000000D6   0x6801             LDR      R1,[R0, #+0]
   \   000000D8   0xF021 0x0140      BIC      R1,R1,#0x40
   \   000000DC   0x6001             STR      R1,[R0, #+0]
   \                     ??SPI_DMATransmitReceiveCplt_9: (+1)
   \   000000DE   0x6AA1             LDR      R1,[R4, #+40]
   \   000000E0   0xF5B1 0x5F00      CMP      R1,#+8192
   \   000000E4   0xD108             BNE.N    ??SPI_DMATransmitReceiveCplt_10
   \   000000E6   0x6801             LDR      R1,[R0, #+0]
   \   000000E8   0xF64D 0x72FF      MOVW     R2,#+57343
   \   000000EC   0x4011             ANDS     R1,R2,R1
   \   000000EE   0x6001             STR      R1,[R0, #+0]
   \   000000F0   0x6801             LDR      R1,[R0, #+0]
   \   000000F2   0xF441 0x5100      ORR      R1,R1,#0x2000
   \   000000F6   0x6001             STR      R1,[R0, #+0]
   \                     ??SPI_DMATransmitReceiveCplt_10: (+1)
   \   000000F8   0x2001             MOVS     R0,#+1
   \   000000FA   0xF884 0x005D      STRB     R0,[R4, #+93]
   \   000000FE   0x2000             MOVS     R0,#+0
   \   00000100   0xF884 0x005C      STRB     R0,[R4, #+92]
   2012                {
   2013                  /* Error on the CRC reception */
   2014                  hspi->ErrorCode|= HAL_SPI_ERROR_CRC;      
   \   00000104   0x6E20             LDR      R0,[R4, #+96]
   \   00000106   0xF040 0x0002      ORR      R0,R0,#0x2
   \   0000010A   0x6620             STR      R0,[R4, #+96]
   2015                }
   2016                tmpreg = hspi->Instance->DR;
   \                     ??SPI_DMATransmitReceiveCplt_8: (+1)
   \   0000010C   0x6820             LDR      R0,[R4, #+0]
   \   0000010E   0x68C0             LDR      R0,[R0, #+12]
   \                     ??SPI_DMATransmitReceiveCplt_6: (+1)
   \   00000110   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   2017                UNUSED(tmpreg); /* To avoid GCC warning */
   \   00000114   0xF9BD 0x0000      LDRSH    R0,[SP, #+0]
   2018              }
   2019            }  
   2020            
   2021            /* Check the end of the transaction */
   2022            SPI_EndRxTxTransaction(hspi,SPI_DEFAULT_TIMEOUT);
   \                     ??SPI_DMATransmitReceiveCplt_0: (+1)
   \   00000118   0x.... 0x....      BL       HAL_GetTick
   \   0000011C   0x4605             MOV      R5,R0
   \                     ??SPI_DMATransmitReceiveCplt_11: (+1)
   \   0000011E   0x6820             LDR      R0,[R4, #+0]
   \   00000120   0x6880             LDR      R0,[R0, #+8]
   \   00000122   0xF410 0x5FC0      TST      R0,#0x1800
   \   00000126   0xD005             BEQ.N    ??SPI_DMATransmitReceiveCplt_12
   \   00000128   0x.... 0x....      BL       HAL_GetTick
   \   0000012C   0x1B40             SUBS     R0,R0,R5
   \   0000012E   0x2832             CMP      R0,#+50
   \   00000130   0xD3F5             BCC.N    ??SPI_DMATransmitReceiveCplt_11
   \   00000132   0xE01E             B.N      ??SPI_DMATransmitReceiveCplt_13
   \                     ??SPI_DMATransmitReceiveCplt_12: (+1)
   \   00000134   0x.... 0x....      BL       HAL_GetTick
   \   00000138   0x4605             MOV      R5,R0
   \                     ??SPI_DMATransmitReceiveCplt_14: (+1)
   \   0000013A   0x6820             LDR      R0,[R4, #+0]
   \   0000013C   0x6880             LDR      R0,[R0, #+8]
   \   0000013E   0x0600             LSLS     R0,R0,#+24
   \   00000140   0xD505             BPL.N    ??SPI_DMATransmitReceiveCplt_15
   \   00000142   0x.... 0x....      BL       HAL_GetTick
   \   00000146   0x1B40             SUBS     R0,R0,R5
   \   00000148   0x2832             CMP      R0,#+50
   \   0000014A   0xD3F6             BCC.N    ??SPI_DMATransmitReceiveCplt_14
   \   0000014C   0xE011             B.N      ??SPI_DMATransmitReceiveCplt_13
   \                     ??SPI_DMATransmitReceiveCplt_15: (+1)
   \   0000014E   0x.... 0x....      BL       HAL_GetTick
   \   00000152   0x4605             MOV      R5,R0
   \                     ??SPI_DMATransmitReceiveCplt_16: (+1)
   \   00000154   0x6820             LDR      R0,[R4, #+0]
   \   00000156   0x6881             LDR      R1,[R0, #+8]
   \   00000158   0xF411 0x6FC0      TST      R1,#0x600
   \   0000015C   0xD034             BEQ.N    ??SPI_DMATransmitReceiveCplt_17
   \   0000015E   0x7B00             LDRB     R0,[R0, #+12]
   \   00000160   0xF88D 0x0002      STRB     R0,[SP, #+2]
   \   00000164   0xF89D 0x0002      LDRB     R0,[SP, #+2]
   \   00000168   0x.... 0x....      BL       HAL_GetTick
   \   0000016C   0x1B40             SUBS     R0,R0,R5
   \   0000016E   0x2832             CMP      R0,#+50
   \   00000170   0xD3F0             BCC.N    ??SPI_DMATransmitReceiveCplt_16
   \                     ??SPI_DMATransmitReceiveCplt_13: (+1)
   \   00000172   0x6820             LDR      R0,[R4, #+0]
   \   00000174   0x6841             LDR      R1,[R0, #+4]
   \   00000176   0xF021 0x01E0      BIC      R1,R1,#0xE0
   \   0000017A   0x6041             STR      R1,[R0, #+4]
   \   0000017C   0x6861             LDR      R1,[R4, #+4]
   \   0000017E   0xF5B1 0x7F82      CMP      R1,#+260
   \   00000182   0xD10A             BNE.N    ??SPI_DMATransmitReceiveCplt_18
   \   00000184   0x68A1             LDR      R1,[R4, #+8]
   \   00000186   0xF5B1 0x4F00      CMP      R1,#+32768
   \   0000018A   0xBF18             IT       NE 
   \   0000018C   0xF5B1 0x6F80      CMPNE    R1,#+1024
   \   00000190   0xD103             BNE.N    ??SPI_DMATransmitReceiveCplt_18
   \   00000192   0x6801             LDR      R1,[R0, #+0]
   \   00000194   0xF021 0x0140      BIC      R1,R1,#0x40
   \   00000198   0x6001             STR      R1,[R0, #+0]
   \                     ??SPI_DMATransmitReceiveCplt_18: (+1)
   \   0000019A   0x6AA1             LDR      R1,[R4, #+40]
   \   0000019C   0xF5B1 0x5F00      CMP      R1,#+8192
   \   000001A0   0xD108             BNE.N    ??SPI_DMATransmitReceiveCplt_19
   \   000001A2   0x6801             LDR      R1,[R0, #+0]
   \   000001A4   0xF64D 0x72FF      MOVW     R2,#+57343
   \   000001A8   0x4011             ANDS     R1,R2,R1
   \   000001AA   0x6001             STR      R1,[R0, #+0]
   \   000001AC   0x6801             LDR      R1,[R0, #+0]
   \   000001AE   0xF441 0x5100      ORR      R1,R1,#0x2000
   \   000001B2   0x6001             STR      R1,[R0, #+0]
   \                     ??SPI_DMATransmitReceiveCplt_19: (+1)
   \   000001B4   0x2001             MOVS     R0,#+1
   \   000001B6   0xF884 0x005D      STRB     R0,[R4, #+93]
   \   000001BA   0x2000             MOVS     R0,#+0
   \   000001BC   0xF884 0x005C      STRB     R0,[R4, #+92]
   \   000001C0   0x6E20             LDR      R0,[R4, #+96]
   \   000001C2   0xF040 0x0020      ORR      R0,R0,#0x20
   \   000001C6   0x6620             STR      R0,[R4, #+96]
   2023            
   2024            /* Disable Tx DMA Request */
   2025            CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN);
   \                     ??SPI_DMATransmitReceiveCplt_17: (+1)
   \   000001C8   0x6820             LDR      R0,[R4, #+0]
   \   000001CA   0x6841             LDR      R1,[R0, #+4]
   \   000001CC   0xF021 0x0102      BIC      R1,R1,#0x2
   \   000001D0   0x6041             STR      R1,[R0, #+4]
   2026            
   2027            /* Disable Rx DMA Request */
   2028            CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_RXDMAEN);
   \   000001D2   0x6841             LDR      R1,[R0, #+4]
   \   000001D4   0x0849             LSRS     R1,R1,#+1
   \   000001D6   0x0049             LSLS     R1,R1,#+1
   \   000001D8   0x6041             STR      R1,[R0, #+4]
   2029             
   2030            hspi->TxXferCount = 0;
   \   000001DA   0x2100             MOVS     R1,#+0
   \   000001DC   0x87E1             STRH     R1,[R4, #+62]
   2031            hspi->RxXferCount = 0;
   \   000001DE   0xF8A4 0x1046      STRH     R1,[R4, #+70]
   2032            hspi->State = HAL_SPI_STATE_READY;
   \   000001E2   0x2101             MOVS     R1,#+1
   \   000001E4   0xF884 0x105D      STRB     R1,[R4, #+93]
   2033            
   2034            /* Check if CRC error occurred */
   2035            if(__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_CRCERR) != RESET)
   \   000001E8   0x6881             LDR      R1,[R0, #+8]
   \   000001EA   0x06C9             LSLS     R1,R1,#+27
   \   000001EC   0xD506             BPL.N    ??SPI_DMATransmitReceiveCplt_20
   2036            {
   2037              hspi->ErrorCode = HAL_SPI_ERROR_CRC;
   \   000001EE   0x2102             MOVS     R1,#+2
   \   000001F0   0x6621             STR      R1,[R4, #+96]
   2038              __HAL_SPI_CLEAR_CRCERRFLAG(hspi);
   \   000001F2   0xF64F 0x71EF      MOVW     R1,#+65519
   \   000001F6   0x6081             STR      R1,[R0, #+8]
   2039              HAL_SPI_ErrorCallback(hspi);
   \   000001F8   0x4620             MOV      R0,R4
   \   000001FA   0xE007             B.N      ??SPI_DMATransmitReceiveCplt_21
   2040            }
   2041            else
   2042            {     
   2043              if(hspi->ErrorCode == HAL_SPI_ERROR_NONE)
   \                     ??SPI_DMATransmitReceiveCplt_20: (+1)
   \   000001FC   0x6E20             LDR      R0,[R4, #+96]
   \   000001FE   0x2800             CMP      R0,#+0
   \   00000200   0x4620             MOV      R0,R4
   \   00000202   0xD103             BNE.N    ??SPI_DMATransmitReceiveCplt_21
   2044              {
   2045                HAL_SPI_TxRxCpltCallback(hspi);
   \   00000204   0x.... 0x....      BL       HAL_SPI_TxRxCpltCallback
   2046              }
   2047              else
   2048              {
   2049                HAL_SPI_ErrorCallback(hspi);
   2050              }
   2051            }
   2052          }
   \   00000208   0xB001             ADD      SP,SP,#+4
   \   0000020A   0xBD30             POP      {R4,R5,PC}
   \                     ??SPI_DMATransmitReceiveCplt_21: (+1)
   \   0000020C   0x.... 0x....      BL       HAL_SPI_ErrorCallback
   \   00000210   0xB001             ADD      SP,SP,#+4
   \   00000212   0xBD30             POP      {R4,R5,PC}       ;; return
   2053          
   2054          /**
   2055            * @brief DMA SPI half transmit process complete callback
   2056            * @param  hdma : pointer to a DMA_HandleTypeDef structure that contains
   2057            *               the configuration information for the specified DMA module.
   2058            * @retval None
   2059            */

   \                                 In section .text, align 4, keep-with-next
   2060          static void SPI_DMAHalfTransmitCplt(DMA_HandleTypeDef *hdma)
   2061          {
   \                     SPI_DMAHalfTransmitCplt: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB081             SUB      SP,SP,#+4
   2062            SPI_HandleTypeDef* hspi = ( SPI_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   2063          
   2064            HAL_SPI_TxHalfCpltCallback(hspi);
   \   00000004   0x6B80             LDR      R0,[R0, #+56]
   \   00000006   0x.... 0x....      BL       HAL_SPI_TxHalfCpltCallback
   2065          }
   \   0000000A   0xB001             ADD      SP,SP,#+4
   \   0000000C   0xBD00             POP      {PC}             ;; return
   2066          
   2067          /**
   2068            * @brief DMA SPI half receive process complete callback
   2069            * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
   2070            *               the configuration information for the specified DMA module.
   2071            * @retval None
   2072            */

   \                                 In section .text, align 4, keep-with-next
   2073          static void SPI_DMAHalfReceiveCplt(DMA_HandleTypeDef *hdma)
   2074          {
   \                     SPI_DMAHalfReceiveCplt: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB081             SUB      SP,SP,#+4
   2075            SPI_HandleTypeDef* hspi = ( SPI_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   2076          
   2077            HAL_SPI_RxHalfCpltCallback(hspi);
   \   00000004   0x6B80             LDR      R0,[R0, #+56]
   \   00000006   0x.... 0x....      BL       HAL_SPI_RxHalfCpltCallback
   2078          }
   \   0000000A   0xB001             ADD      SP,SP,#+4
   \   0000000C   0xBD00             POP      {PC}             ;; return
   2079          
   2080          /**
   2081            * @brief DMA SPI Half transmit receive process complete callback
   2082            * @param  hdma : pointer to a DMA_HandleTypeDef structure that contains
   2083            *               the configuration information for the specified DMA module.
   2084            * @retval None
   2085            */

   \                                 In section .text, align 4, keep-with-next
   2086          static void SPI_DMAHalfTransmitReceiveCplt(DMA_HandleTypeDef *hdma)
   2087          {
   \                     SPI_DMAHalfTransmitReceiveCplt: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB081             SUB      SP,SP,#+4
   2088            SPI_HandleTypeDef* hspi = ( SPI_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   2089          
   2090            HAL_SPI_TxRxHalfCpltCallback(hspi);
   \   00000004   0x6B80             LDR      R0,[R0, #+56]
   \   00000006   0x.... 0x....      BL       HAL_SPI_TxRxHalfCpltCallback
   2091          }
   \   0000000A   0xB001             ADD      SP,SP,#+4
   \   0000000C   0xBD00             POP      {PC}             ;; return
   2092          
   2093          /**
   2094            * @brief DMA SPI communication error callback
   2095            * @param  hdma : pointer to a DMA_HandleTypeDef structure that contains
   2096            *               the configuration information for the specified DMA module.
   2097            * @retval None
   2098            */

   \                                 In section .text, align 4, keep-with-next
   2099          static void SPI_DMAError(DMA_HandleTypeDef *hdma)
   2100          {
   \                     SPI_DMAError: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB081             SUB      SP,SP,#+4
   2101            SPI_HandleTypeDef* hspi = ( SPI_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   \   00000004   0x6B80             LDR      R0,[R0, #+56]
   2102          
   2103            /* Stop the disable DMA transfer on SPI side */
   2104            CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);
   \   00000006   0x6801             LDR      R1,[R0, #+0]
   \   00000008   0x684A             LDR      R2,[R1, #+4]
   \   0000000A   0x0892             LSRS     R2,R2,#+2
   \   0000000C   0x0092             LSLS     R2,R2,#+2
   \   0000000E   0x604A             STR      R2,[R1, #+4]
   2105          
   2106            hspi->ErrorCode|= HAL_SPI_ERROR_DMA;
   \   00000010   0x6E01             LDR      R1,[R0, #+96]
   \   00000012   0xF041 0x0110      ORR      R1,R1,#0x10
   \   00000016   0x6601             STR      R1,[R0, #+96]
   2107            hspi->State = HAL_SPI_STATE_READY;
   \   00000018   0x2101             MOVS     R1,#+1
   \   0000001A   0xF880 0x105D      STRB     R1,[R0, #+93]
   2108            HAL_SPI_ErrorCallback(hspi);
   \   0000001E   0x.... 0x....      BL       HAL_SPI_ErrorCallback
   2109          }
   \   00000022   0xB001             ADD      SP,SP,#+4
   \   00000024   0xBD00             POP      {PC}             ;; return
   2110          
   2111          /**
   2112            * @brief  Rx Handler for Transmit and Receive in Interrupt mode
   2113            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   2114            *               the configuration information for SPI module.
   2115            * @retval None
   2116            */

   \                                 In section .text, align 4, keep-with-next
   2117          static void SPI_2linesRxISR_8BIT(struct __SPI_HandleTypeDef *hspi)
   2118          {
   2119            /* Receive data in packing mode */
   2120            if(hspi->RxXferCount > 1)
   \                     SPI_2linesRxISR_8BIT: (+1)
   \   00000000   0xF8B0 0x3046      LDRH     R3,[R0, #+70]
   \   00000004   0x6C02             LDR      R2,[R0, #+64]
   \   00000006   0x6801             LDR      R1,[R0, #+0]
   \   00000008   0x2B02             CMP      R3,#+2
   \   0000000A   0xDB0F             BLT.N    ??SPI_2linesRxISR_8BIT_0
   2121            {
   2122              *((uint16_t*)hspi->pRxBuffPtr) = hspi->Instance->DR;
   \   0000000C   0x68CB             LDR      R3,[R1, #+12]
   \   0000000E   0xF822 0x3B02      STRH     R3,[R2], #+2
   2123              hspi->pRxBuffPtr += sizeof(uint16_t);
   2124              hspi->RxXferCount -= 2;
   \   00000012   0xF8B0 0x3046      LDRH     R3,[R0, #+70]
   \   00000016   0x1E9B             SUBS     R3,R3,#+2
   \   00000018   0xF8A0 0x3046      STRH     R3,[R0, #+70]
   2125              if(hspi->RxXferCount == 1)
   \   0000001C   0xB29B             UXTH     R3,R3
   \   0000001E   0x2B01             CMP      R3,#+1
   \   00000020   0xD10C             BNE.N    ??SPI_2linesRxISR_8BIT_1
   2126              {
   2127                /* set fiforxthreshold according the reception data length: 8bit */
   2128                SET_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
   \   00000022   0x684B             LDR      R3,[R1, #+4]
   \   00000024   0xF443 0x5380      ORR      R3,R3,#0x1000
   \   00000028   0x604B             STR      R3,[R1, #+4]
   \   0000002A   0xE007             B.N      ??SPI_2linesRxISR_8BIT_1
   2129              }
   2130            }
   2131            /* Receive data in 8 Bit mode */
   2132            else
   2133            {
   2134              *hspi->pRxBuffPtr++ = *((__IO uint8_t *)&hspi->Instance->DR);
   \                     ??SPI_2linesRxISR_8BIT_0: (+1)
   \   0000002C   0x7B0B             LDRB     R3,[R1, #+12]
   \   0000002E   0xF802 0x3B01      STRB     R3,[R2], #+1
   2135              hspi->RxXferCount--;
   \   00000032   0xF8B0 0x3046      LDRH     R3,[R0, #+70]
   \   00000036   0x1E5B             SUBS     R3,R3,#+1
   \   00000038   0xF8A0 0x3046      STRH     R3,[R0, #+70]
   \                     ??SPI_2linesRxISR_8BIT_1: (+1)
   \   0000003C   0x6402             STR      R2,[R0, #+64]
   2136            }
   2137            
   2138            /* check end of the reception */
   2139            if(hspi->RxXferCount == 0)
   \   0000003E   0xF8B0 0x2046      LDRH     R2,[R0, #+70]
   \   00000042   0xB99A             CBNZ.N   R2,??SPI_2linesRxISR_8BIT_2
   2140            {
   2141              if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   \   00000044   0x6A82             LDR      R2,[R0, #+40]
   \   00000046   0xF5B2 0x5F00      CMP      R2,#+8192
   \   0000004A   0x684A             LDR      R2,[R1, #+4]
   \   0000004C   0xD106             BNE.N    ??SPI_2linesRxISR_8BIT_3
   2142              {
   2143                SET_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
   \   0000004E   0xF442 0x5280      ORR      R2,R2,#0x1000
   \   00000052   0x604A             STR      R2,[R1, #+4]
   2144                hspi->RxISR =  SPI_2linesRxISR_8BITCRC;
   \   00000054   0x.... 0x....      ADR.W    R1,SPI_2linesRxISR_8BITCRC
   \   00000058   0x64C1             STR      R1,[R0, #+76]
   2145                return;
   \   0000005A   0x4770             BX       LR
   2146              }
   2147                  
   2148              /* Disable RXNE interrupt */
   2149              __HAL_SPI_DISABLE_IT(hspi, SPI_IT_RXNE);
   \                     ??SPI_2linesRxISR_8BIT_3: (+1)
   \   0000005C   0xF022 0x0240      BIC      R2,R2,#0x40
   \   00000060   0x604A             STR      R2,[R1, #+4]
   2150          
   2151              if(hspi->TxXferCount == 0)
   \   00000062   0x8FC1             LDRH     R1,[R0, #+62]
   \   00000064   0x2900             CMP      R1,#+0
   \   00000066   0xBF08             IT       EQ 
   2152              {
   2153                SPI_CloseRxTx_ISR(hspi);
   \   00000068   0x.... 0x....      BEQ.W    SPI_CloseRxTx_ISR
   2154              }
   2155            }
   2156          }
   \                     ??SPI_2linesRxISR_8BIT_2: (+1)
   \   0000006C   0x4770             BX       LR               ;; return
   2157          
   2158          /**
   2159            * @brief  Rx Handler for Transmit and Receive in Interrupt mode
   2160            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   2161            *               the configuration information for SPI module.
   2162            * @retval None
   2163            */

   \                                 In section .text, align 4, keep-with-next
   2164          static void SPI_2linesRxISR_8BITCRC(struct __SPI_HandleTypeDef *hspi)
   2165          {
   \                     SPI_2linesRxISR_8BITCRC: (+1)
   \   00000000   0xB082             SUB      SP,SP,#+8
   2166            __IO uint8_t tmpreg;
   2167            
   2168            tmpreg = *((__IO uint8_t *)&hspi->Instance->DR);
   \   00000002   0x6801             LDR      R1,[R0, #+0]
   \   00000004   0x7B0A             LDRB     R2,[R1, #+12]
   \   00000006   0xF88D 0x2000      STRB     R2,[SP, #+0]
   2169            UNUSED(tmpreg); /* To avoid GCC warning */
   \   0000000A   0xF89D 0x2000      LDRB     R2,[SP, #+0]
   2170          
   2171            hspi->CRCSize--;
   \   0000000E   0x6C82             LDR      R2,[R0, #+72]
   \   00000010   0x1E52             SUBS     R2,R2,#+1
   \   00000012   0x6482             STR      R2,[R0, #+72]
   2172            
   2173            /* check end of the reception */
   2174            if(hspi->CRCSize == 0)
   \   00000014   0xD107             BNE.N    ??SPI_2linesRxISR_8BITCRC_0
   2175            {
   2176              /* Disable RXNE interrupt */
   2177              __HAL_SPI_DISABLE_IT(hspi, SPI_IT_RXNE);
   \   00000016   0x684A             LDR      R2,[R1, #+4]
   \   00000018   0xF022 0x0240      BIC      R2,R2,#0x40
   \   0000001C   0x604A             STR      R2,[R1, #+4]
   2178          
   2179              if(hspi->TxXferCount == 0)
   \   0000001E   0x8FC1             LDRH     R1,[R0, #+62]
   \   00000020   0xB909             CBNZ.N   R1,??SPI_2linesRxISR_8BITCRC_0
   2180              {
   2181                SPI_CloseRxTx_ISR(hspi);
   \   00000022   0xB002             ADD      SP,SP,#+8
   \   00000024   0x....             B.N      SPI_CloseRxTx_ISR
   2182              }
   2183            }
   2184          }
   \                     ??SPI_2linesRxISR_8BITCRC_0: (+1)
   \   00000026   0xB002             ADD      SP,SP,#+8
   \   00000028   0x4770             BX       LR               ;; return
   2185          
   2186          /**
   2187            * @brief  Tx Handler for Transmit and Receive in Interrupt mode
   2188            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   2189            *               the configuration information for SPI module.
   2190            * @retval None
   2191            */

   \                                 In section .text, align 4, keep-with-next
   2192          static void SPI_2linesTxISR_8BIT(struct __SPI_HandleTypeDef *hspi)
   2193          {
   \                     SPI_2linesTxISR_8BIT: (+1)
   \   00000000   0xB410             PUSH     {R4}
   \   00000002   0xB081             SUB      SP,SP,#+4
   2194            /* Transmit data in packing Bit mode */
   2195            if(hspi->TxXferCount >= 2)
   \   00000004   0x8FC3             LDRH     R3,[R0, #+62]
   \   00000006   0x6B82             LDR      R2,[R0, #+56]
   \   00000008   0x6801             LDR      R1,[R0, #+0]
   \   0000000A   0x2B02             CMP      R3,#+2
   \   0000000C   0xDB04             BLT.N    ??SPI_2linesTxISR_8BIT_0
   2196            {
   2197              hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
   \   0000000E   0xF832 0x4B02      LDRH     R4,[R2], #+2
   2198              hspi->pTxBuffPtr += sizeof(uint16_t);
   2199              hspi->TxXferCount -= 2;
   \   00000012   0x1E9B             SUBS     R3,R3,#+2
   \   00000014   0x60CC             STR      R4,[R1, #+12]
   \   00000016   0xE004             B.N      ??SPI_2linesTxISR_8BIT_1
   2200            }
   2201            /* Transmit data in 8 Bit mode */
   2202            else
   2203            {        
   2204              *(__IO uint8_t *)&hspi->Instance->DR = (*hspi->pTxBuffPtr++);
   \                     ??SPI_2linesTxISR_8BIT_0: (+1)
   \   00000018   0xF812 0x3B01      LDRB     R3,[R2], #+1
   \   0000001C   0x730B             STRB     R3,[R1, #+12]
   2205              hspi->TxXferCount--;
   \   0000001E   0x8FC3             LDRH     R3,[R0, #+62]
   \   00000020   0x1E5B             SUBS     R3,R3,#+1
   \                     ??SPI_2linesTxISR_8BIT_1: (+1)
   \   00000022   0x87C3             STRH     R3,[R0, #+62]
   \   00000024   0x6382             STR      R2,[R0, #+56]
   2206            }
   2207            
   2208            /* check the end of the transmission */
   2209            if(hspi->TxXferCount == 0)
   \   00000026   0x8FC2             LDRH     R2,[R0, #+62]
   \   00000028   0xB98A             CBNZ.N   R2,??SPI_2linesTxISR_8BIT_2
   2210            {
   2211              if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   \   0000002A   0x6A82             LDR      R2,[R0, #+40]
   \   0000002C   0xF5B2 0x5F00      CMP      R2,#+8192
   \   00000030   0xD103             BNE.N    ??SPI_2linesTxISR_8BIT_3
   2212              {
   2213                hspi->Instance->CR1 |= SPI_CR1_CRCNEXT;
   \   00000032   0x680A             LDR      R2,[R1, #+0]
   \   00000034   0xF442 0x5280      ORR      R2,R2,#0x1000
   \   00000038   0x600A             STR      R2,[R1, #+0]
   2214              }
   2215              /* Disable TXE interrupt */
   2216              __HAL_SPI_DISABLE_IT(hspi, SPI_IT_TXE);
   \                     ??SPI_2linesTxISR_8BIT_3: (+1)
   \   0000003A   0x684A             LDR      R2,[R1, #+4]
   \   0000003C   0xF022 0x0280      BIC      R2,R2,#0x80
   \   00000040   0x604A             STR      R2,[R1, #+4]
   2217              
   2218              if(hspi->RxXferCount == 0)
   \   00000042   0xF8B0 0x1046      LDRH     R1,[R0, #+70]
   \   00000046   0xB911             CBNZ.N   R1,??SPI_2linesTxISR_8BIT_2
   2219              { 
   2220                SPI_CloseRxTx_ISR(hspi);
   \   00000048   0xB001             ADD      SP,SP,#+4
   \   0000004A   0xBC10             POP      {R4}
   \   0000004C   0x....             B.N      SPI_CloseRxTx_ISR
   2221              }
   2222            }
   2223          }
   \                     ??SPI_2linesTxISR_8BIT_2: (+1)
   \   0000004E   0xB001             ADD      SP,SP,#+4
   \   00000050   0xBC10             POP      {R4}
   \   00000052   0x4770             BX       LR               ;; return
   2224          
   2225          /**
   2226            * @brief  Rx 16Bit Handler for Transmit and Receive in Interrupt mode
   2227            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   2228            *               the configuration information for SPI module.
   2229            * @retval None
   2230            */

   \                                 In section .text, align 4, keep-with-next
   2231          static void SPI_2linesRxISR_16BIT(struct __SPI_HandleTypeDef *hspi)
   2232          {
   2233            /* Receive data in 16 Bit mode */
   2234            *((uint16_t*)hspi->pRxBuffPtr) = hspi->Instance->DR;
   \                     SPI_2linesRxISR_16BIT: (+1)
   \   00000000   0x6802             LDR      R2,[R0, #+0]
   \   00000002   0x6C01             LDR      R1,[R0, #+64]
   \   00000004   0x68D3             LDR      R3,[R2, #+12]
   \   00000006   0xF821 0x3B02      STRH     R3,[R1], #+2
   2235            hspi->pRxBuffPtr += sizeof(uint16_t);
   \   0000000A   0x6401             STR      R1,[R0, #+64]
   2236            hspi->RxXferCount--;
   \   0000000C   0xF8B0 0x1046      LDRH     R1,[R0, #+70]
   \   00000010   0x1E49             SUBS     R1,R1,#+1
   \   00000012   0xF8A0 0x1046      STRH     R1,[R0, #+70]
   2237          
   2238            if(hspi->RxXferCount == 0)
   \   00000016   0xB289             UXTH     R1,R1
   \   00000018   0xB981             CBNZ.N   R1,??SPI_2linesRxISR_16BIT_0
   2239            {
   2240              if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   \   0000001A   0x6A81             LDR      R1,[R0, #+40]
   \   0000001C   0xF5B1 0x5F00      CMP      R1,#+8192
   \   00000020   0xD103             BNE.N    ??SPI_2linesRxISR_16BIT_1
   2241              {
   2242                hspi->RxISR =  SPI_2linesRxISR_16BITCRC;
   \   00000022   0x.... 0x....      ADR.W    R1,SPI_2linesRxISR_16BITCRC
   \   00000026   0x64C1             STR      R1,[R0, #+76]
   2243                return;
   \   00000028   0x4770             BX       LR
   2244              }
   2245              
   2246              /* Disable RXNE interrupt */
   2247              __HAL_SPI_DISABLE_IT(hspi, SPI_IT_RXNE);
   \                     ??SPI_2linesRxISR_16BIT_1: (+1)
   \   0000002A   0x6851             LDR      R1,[R2, #+4]
   \   0000002C   0xF021 0x0140      BIC      R1,R1,#0x40
   \   00000030   0x6051             STR      R1,[R2, #+4]
   2248          
   2249              if(hspi->TxXferCount == 0)
   \   00000032   0x8FC1             LDRH     R1,[R0, #+62]
   \   00000034   0x2900             CMP      R1,#+0
   \   00000036   0xBF08             IT       EQ 
   2250              {
   2251                SPI_CloseRxTx_ISR(hspi);
   \   00000038   0x.... 0x....      BEQ.W    SPI_CloseRxTx_ISR
   2252              }
   2253            }
   2254          }
   \                     ??SPI_2linesRxISR_16BIT_0: (+1)
   \   0000003C   0x4770             BX       LR               ;; return
   2255          
   2256          /**
   2257            * @brief  Manage the CRC 16bit receive for Transmit and Receive in Interrupt mode
   2258            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   2259            *               the configuration information for SPI module.
   2260            * @retval None
   2261            */

   \                                 In section .text, align 4, keep-with-next
   2262          static void SPI_2linesRxISR_16BITCRC(struct __SPI_HandleTypeDef *hspi)
   2263          {
   \                     SPI_2linesRxISR_16BITCRC: (+1)
   \   00000000   0xB082             SUB      SP,SP,#+8
   2264            /* Receive data in 16 Bit mode */
   2265            __IO uint16_t tmpreg = hspi->Instance->DR;
   \   00000002   0x6801             LDR      R1,[R0, #+0]
   \   00000004   0x68CA             LDR      R2,[R1, #+12]
   \   00000006   0xF8AD 0x2000      STRH     R2,[SP, #+0]
   2266            UNUSED(tmpreg); /* To avoid GCC warning */
   \   0000000A   0xF8BD 0x2000      LDRH     R2,[SP, #+0]
   2267          
   2268            /* Disable RXNE interrupt */
   2269            __HAL_SPI_DISABLE_IT(hspi, SPI_IT_RXNE);
   \   0000000E   0x684A             LDR      R2,[R1, #+4]
   \   00000010   0xF022 0x0240      BIC      R2,R2,#0x40
   \   00000014   0x604A             STR      R2,[R1, #+4]
   2270          
   2271            SPI_CloseRxTx_ISR(hspi);
   \   00000016   0xB002             ADD      SP,SP,#+8
   \   00000018   0x....             B.N      SPI_CloseRxTx_ISR
   2272          }
   2273          
   2274          /**
   2275            * @brief  Tx Handler for Transmit and Receive in Interrupt mode
   2276            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   2277            *               the configuration information for SPI module.
   2278            * @retval None
   2279            */

   \                                 In section .text, align 4, keep-with-next
   2280          static void SPI_2linesTxISR_16BIT(struct __SPI_HandleTypeDef *hspi)
   2281          {
   2282            /* Transmit data in 16 Bit mode */
   2283            hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
   \                     SPI_2linesTxISR_16BIT: (+1)
   \   00000000   0x6B81             LDR      R1,[R0, #+56]
   \   00000002   0x6802             LDR      R2,[R0, #+0]
   \   00000004   0xF831 0x3B02      LDRH     R3,[R1], #+2
   \   00000008   0x60D3             STR      R3,[R2, #+12]
   2284            hspi->pTxBuffPtr += sizeof(uint16_t);
   \   0000000A   0x6381             STR      R1,[R0, #+56]
   2285            hspi->TxXferCount--;
   \   0000000C   0x8FC1             LDRH     R1,[R0, #+62]
   \   0000000E   0x1E49             SUBS     R1,R1,#+1
   \   00000010   0x87C1             STRH     R1,[R0, #+62]
   2286            
   2287            /* Enable CRC Transmission */
   2288            if(hspi->TxXferCount == 0)
   \   00000012   0xB289             UXTH     R1,R1
   \   00000014   0xB989             CBNZ.N   R1,??SPI_2linesTxISR_16BIT_0
   2289            {
   2290              if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   \   00000016   0x6A81             LDR      R1,[R0, #+40]
   \   00000018   0xF5B1 0x5F00      CMP      R1,#+8192
   \   0000001C   0xD103             BNE.N    ??SPI_2linesTxISR_16BIT_1
   2291              {
   2292                hspi->Instance->CR1 |= SPI_CR1_CRCNEXT;
   \   0000001E   0x6811             LDR      R1,[R2, #+0]
   \   00000020   0xF441 0x5180      ORR      R1,R1,#0x1000
   \   00000024   0x6011             STR      R1,[R2, #+0]
   2293              }
   2294              /* Disable TXE interrupt */
   2295              __HAL_SPI_DISABLE_IT(hspi, SPI_IT_TXE);
   \                     ??SPI_2linesTxISR_16BIT_1: (+1)
   \   00000026   0x6851             LDR      R1,[R2, #+4]
   \   00000028   0xF021 0x0180      BIC      R1,R1,#0x80
   \   0000002C   0x6051             STR      R1,[R2, #+4]
   2296          
   2297              if(hspi->RxXferCount == 0)
   \   0000002E   0xF8B0 0x1046      LDRH     R1,[R0, #+70]
   \   00000032   0x2900             CMP      R1,#+0
   \   00000034   0xBF08             IT       EQ 
   2298              {
   2299                SPI_CloseRxTx_ISR(hspi);
   \   00000036   0x.... 0x....      BEQ.W    SPI_CloseRxTx_ISR
   2300              }
   2301            }
   2302          }
   \                     ??SPI_2linesTxISR_16BIT_0: (+1)
   \   0000003A   0x4770             BX       LR               ;; return
   2303          
   2304          /**
   2305            * @brief  Manage the CRC receive in Interrupt context
   2306            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   2307            *               the configuration information for SPI module.
   2308            * @retval None
   2309            */

   \                                 In section .text, align 2, keep-with-next
   2310          static void SPI_RxISR_8BITCRC(struct __SPI_HandleTypeDef *hspi)
   2311          {
   \                     SPI_RxISR_8BITCRC: (+1)
   \   00000000   0xB082             SUB      SP,SP,#+8
   2312            __IO uint8_t tmpreg;
   2313            tmpreg = *((__IO uint8_t*)&hspi->Instance->DR);
   \   00000002   0x6801             LDR      R1,[R0, #+0]
   \   00000004   0x7B09             LDRB     R1,[R1, #+12]
   \   00000006   0xF88D 0x1000      STRB     R1,[SP, #+0]
   2314            UNUSED(tmpreg); /* To avoid GCC warning */
   \   0000000A   0xF89D 0x1000      LDRB     R1,[SP, #+0]
   2315          
   2316            hspi->CRCSize--;
   \   0000000E   0x6C81             LDR      R1,[R0, #+72]
   \   00000010   0x1E49             SUBS     R1,R1,#+1
   \   00000012   0x6481             STR      R1,[R0, #+72]
   2317            
   2318            if(hspi->CRCSize == 0)
   \   00000014   0xD101             BNE.N    ??SPI_RxISR_8BITCRC_0
   2319            { 
   2320              SPI_CloseRx_ISR(hspi);
   \   00000016   0xB002             ADD      SP,SP,#+8
   \   00000018   0x....             B.N      SPI_CloseRx_ISR
   2321            }
   2322          }
   \                     ??SPI_RxISR_8BITCRC_0: (+1)
   \   0000001A   0xB002             ADD      SP,SP,#+8
   \   0000001C   0x4770             BX       LR               ;; return
   2323          
   2324          /**
   2325            * @brief  Manage the receive in Interrupt context
   2326            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   2327            *               the configuration information for SPI module.
   2328            * @retval None
   2329            */

   \                                 In section .text, align 4, keep-with-next
   2330          static void SPI_RxISR_8BIT(struct __SPI_HandleTypeDef *hspi)
   2331          {
   2332            *hspi->pRxBuffPtr++ = (*(__IO uint8_t *)&hspi->Instance->DR);
   \                     SPI_RxISR_8BIT: (+1)
   \   00000000   0x6C01             LDR      R1,[R0, #+64]
   \   00000002   0x1C4A             ADDS     R2,R1,#+1
   \   00000004   0x6402             STR      R2,[R0, #+64]
   \   00000006   0x6802             LDR      R2,[R0, #+0]
   \   00000008   0x7B13             LDRB     R3,[R2, #+12]
   \   0000000A   0x700B             STRB     R3,[R1, #+0]
   2333            hspi->RxXferCount--;
   \   0000000C   0xF8B0 0x1046      LDRH     R1,[R0, #+70]
   \   00000010   0x1E49             SUBS     R1,R1,#+1
   \   00000012   0xF8A0 0x1046      STRH     R1,[R0, #+70]
   2334          
   2335            /* Enable CRC Transmission */
   2336            if((hspi->RxXferCount == 1) && (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE))
   \   00000016   0xB289             UXTH     R1,R1
   \   00000018   0x2901             CMP      R1,#+1
   \   0000001A   0xD108             BNE.N    ??SPI_RxISR_8BIT_0
   \   0000001C   0x6A80             LDR      R0,[R0, #+40]
   \   0000001E   0xF5B0 0x5F00      CMP      R0,#+8192
   \   00000022   0xD10D             BNE.N    ??SPI_RxISR_8BIT_1
   2337            {
   2338              hspi->Instance->CR1 |= SPI_CR1_CRCNEXT;
   \   00000024   0x6810             LDR      R0,[R2, #+0]
   \   00000026   0xF440 0x5080      ORR      R0,R0,#0x1000
   \   0000002A   0x6010             STR      R0,[R2, #+0]
   \   0000002C   0x4770             BX       LR
   2339            }
   2340          
   2341            if(hspi->RxXferCount == 0)
   \                     ??SPI_RxISR_8BIT_0: (+1)
   \   0000002E   0xB939             CBNZ.N   R1,??SPI_RxISR_8BIT_1
   2342            {
   2343              if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   \   00000030   0x6A81             LDR      R1,[R0, #+40]
   \   00000032   0xF5B1 0x5F00      CMP      R1,#+8192
   \   00000036   0xBF18             IT       NE 
   2344              {
   2345                hspi->RxISR =  SPI_RxISR_8BITCRC;
   2346                return;
   2347              }
   2348              SPI_CloseRx_ISR(hspi);
   \   00000038   0x.... 0x....      BNE.W    SPI_CloseRx_ISR
   \   0000003C   0x....             LDR.N    R1,??DataTable2_2
   \   0000003E   0x64C1             STR      R1,[R0, #+76]
   2349            }
   2350          }
   \                     ??SPI_RxISR_8BIT_1: (+1)
   \   00000040   0x4770             BX       LR               ;; return
   2351          
   2352          /**
   2353            * @brief  Manage the CRC 16bit receive in Interrupt context
   2354            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   2355            *               the configuration information for SPI module.
   2356            * @retval None
   2357            */

   \                                 In section .text, align 2, keep-with-next
   2358          static void SPI_RxISR_16BITCRC(struct __SPI_HandleTypeDef *hspi)
   2359          {
   \                     SPI_RxISR_16BITCRC: (+1)
   \   00000000   0xB082             SUB      SP,SP,#+8
   2360            __IO uint16_t tmpreg;
   2361            
   2362            tmpreg = hspi->Instance->DR;
   \   00000002   0x6801             LDR      R1,[R0, #+0]
   \   00000004   0x68CA             LDR      R2,[R1, #+12]
   \   00000006   0xF8AD 0x2000      STRH     R2,[SP, #+0]
   2363            UNUSED(tmpreg); /* To avoid GCC warning */
   \   0000000A   0xF8BD 0x2000      LDRH     R2,[SP, #+0]
   2364          
   2365            /* Disable RXNE and ERR interrupt */
   2366            __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_RXNE | SPI_IT_ERR));
   \   0000000E   0x684A             LDR      R2,[R1, #+4]
   \   00000010   0xF022 0x0260      BIC      R2,R2,#0x60
   \   00000014   0x604A             STR      R2,[R1, #+4]
   2367            
   2368            SPI_CloseRx_ISR(hspi);
   \   00000016   0xB002             ADD      SP,SP,#+8
   \   00000018   0x....             B.N      SPI_CloseRx_ISR
   2369          }
   2370          
   2371          /**
   2372            * @brief  Manage the 16Bit receive in Interrupt context
   2373            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   2374            *               the configuration information for SPI module.
   2375            * @retval None
   2376            */

   \                                 In section .text, align 4, keep-with-next
   2377          static void SPI_RxISR_16BIT(struct __SPI_HandleTypeDef *hspi)
   2378          {
   2379            *((uint16_t *)hspi->pRxBuffPtr) = hspi->Instance->DR;
   \                     SPI_RxISR_16BIT: (+1)
   \   00000000   0x6802             LDR      R2,[R0, #+0]
   \   00000002   0x6C01             LDR      R1,[R0, #+64]
   \   00000004   0x68D3             LDR      R3,[R2, #+12]
   \   00000006   0xF821 0x3B02      STRH     R3,[R1], #+2
   2380            hspi->pRxBuffPtr += sizeof(uint16_t);
   \   0000000A   0x6401             STR      R1,[R0, #+64]
   2381            hspi->RxXferCount--;
   \   0000000C   0xF8B0 0x1046      LDRH     R1,[R0, #+70]
   \   00000010   0x1E49             SUBS     R1,R1,#+1
   \   00000012   0xF8A0 0x1046      STRH     R1,[R0, #+70]
   2382            
   2383            /* Enable CRC Transmission */
   2384            if((hspi->RxXferCount == 1) && (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE))
   \   00000016   0xB289             UXTH     R1,R1
   \   00000018   0x2901             CMP      R1,#+1
   \   0000001A   0xD108             BNE.N    ??SPI_RxISR_16BIT_0
   \   0000001C   0x6A80             LDR      R0,[R0, #+40]
   \   0000001E   0xF5B0 0x5F00      CMP      R0,#+8192
   \   00000022   0xD10D             BNE.N    ??SPI_RxISR_16BIT_1
   2385            {
   2386              hspi->Instance->CR1 |= SPI_CR1_CRCNEXT;
   \   00000024   0x6810             LDR      R0,[R2, #+0]
   \   00000026   0xF440 0x5080      ORR      R0,R0,#0x1000
   \   0000002A   0x6010             STR      R0,[R2, #+0]
   \   0000002C   0x4770             BX       LR
   2387            }
   2388            
   2389            if(hspi->RxXferCount == 0)
   \                     ??SPI_RxISR_16BIT_0: (+1)
   \   0000002E   0xB939             CBNZ.N   R1,??SPI_RxISR_16BIT_1
   2390            {    
   2391              if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   \   00000030   0x6A81             LDR      R1,[R0, #+40]
   \   00000032   0xF5B1 0x5F00      CMP      R1,#+8192
   \   00000036   0xBF18             IT       NE 
   2392              {
   2393                hspi->RxISR = SPI_RxISR_16BITCRC;
   2394                return;
   2395              }
   2396              SPI_CloseRx_ISR(hspi);
   \   00000038   0x.... 0x....      BNE.W    SPI_CloseRx_ISR
   \   0000003C   0x....             LDR.N    R1,??DataTable2_3
   \   0000003E   0x64C1             STR      R1,[R0, #+76]
   2397            }
   2398          }
   \                     ??SPI_RxISR_16BIT_1: (+1)
   \   00000040   0x4770             BX       LR               ;; return
   2399          
   2400          /**
   2401            * @brief  Handle the data 8Bit transmit in Interrupt mode
   2402            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   2403            *               the configuration information for SPI module.
   2404            * @retval None
   2405            */

   \                                 In section .text, align 2, keep-with-next
   2406          static void SPI_TxISR_8BIT(struct __SPI_HandleTypeDef *hspi)
   2407          {
   2408            *(__IO uint8_t *)&hspi->Instance->DR = (*hspi->pTxBuffPtr++);
   \                     SPI_TxISR_8BIT: (+1)
   \   00000000   0x6B82             LDR      R2,[R0, #+56]
   \   00000002   0x6801             LDR      R1,[R0, #+0]
   \   00000004   0x1C52             ADDS     R2,R2,#+1
   \   00000006   0x6382             STR      R2,[R0, #+56]
   \   00000008   0x1E52             SUBS     R2,R2,#+1
   \   0000000A   0x7812             LDRB     R2,[R2, #+0]
   \   0000000C   0x730A             STRB     R2,[R1, #+12]
   2409            hspi->TxXferCount--;
   \   0000000E   0x8FC2             LDRH     R2,[R0, #+62]
   \   00000010   0x1E52             SUBS     R2,R2,#+1
   \   00000012   0x87C2             STRH     R2,[R0, #+62]
   2410            
   2411            if(hspi->TxXferCount == 0)
   \   00000014   0xB292             UXTH     R2,R2
   \   00000016   0xB942             CBNZ.N   R2,??SPI_TxISR_8BIT_0
   2412            {
   2413              if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   \   00000018   0x6A82             LDR      R2,[R0, #+40]
   \   0000001A   0xF5B2 0x5F00      CMP      R2,#+8192
   \   0000001E   0xD103             BNE.N    ??SPI_TxISR_8BIT_1
   2414              {
   2415                /* Enable CRC Transmission */
   2416                hspi->Instance->CR1 |= SPI_CR1_CRCNEXT;
   \   00000020   0x680A             LDR      R2,[R1, #+0]
   \   00000022   0xF442 0x5280      ORR      R2,R2,#0x1000
   \   00000026   0x600A             STR      R2,[R1, #+0]
   2417              }
   2418              SPI_CloseTx_ISR(hspi);
   \                     ??SPI_TxISR_8BIT_1: (+1)
   \   00000028   0x....             B.N      SPI_CloseTx_ISR
   2419            }
   2420          }
   \                     ??SPI_TxISR_8BIT_0: (+1)
   \   0000002A   0x4770             BX       LR               ;; return
   2421          
   2422          /**
   2423            * @brief  Handle the data 16Bit transmit in Interrupt mode
   2424            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   2425            *               the configuration information for SPI module.
   2426            * @retval None
   2427            */

   \                                 In section .text, align 2, keep-with-next
   2428          static void SPI_TxISR_16BIT(struct __SPI_HandleTypeDef *hspi)
   2429          { 
   2430            /* Transmit data in 16 Bit mode */
   2431            hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
   \                     SPI_TxISR_16BIT: (+1)
   \   00000000   0x6B81             LDR      R1,[R0, #+56]
   \   00000002   0x6802             LDR      R2,[R0, #+0]
   \   00000004   0xF831 0x3B02      LDRH     R3,[R1], #+2
   \   00000008   0x60D3             STR      R3,[R2, #+12]
   2432            hspi->pTxBuffPtr += sizeof(uint16_t);
   \   0000000A   0x6381             STR      R1,[R0, #+56]
   2433            hspi->TxXferCount--;
   \   0000000C   0x8FC1             LDRH     R1,[R0, #+62]
   \   0000000E   0x1E49             SUBS     R1,R1,#+1
   \   00000010   0x87C1             STRH     R1,[R0, #+62]
   2434            
   2435            if(hspi->TxXferCount == 0)
   \   00000012   0xB289             UXTH     R1,R1
   \   00000014   0xB941             CBNZ.N   R1,??SPI_TxISR_16BIT_0
   2436            {
   2437              if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   \   00000016   0x6A81             LDR      R1,[R0, #+40]
   \   00000018   0xF5B1 0x5F00      CMP      R1,#+8192
   \   0000001C   0xD103             BNE.N    ??SPI_TxISR_16BIT_1
   2438              {
   2439                /* Enable CRC Transmission */
   2440                hspi->Instance->CR1 |= SPI_CR1_CRCNEXT;
   \   0000001E   0x6811             LDR      R1,[R2, #+0]
   \   00000020   0xF441 0x5180      ORR      R1,R1,#0x1000
   \   00000024   0x6011             STR      R1,[R2, #+0]
   2441              }
   2442              SPI_CloseTx_ISR(hspi);
   \                     ??SPI_TxISR_16BIT_1: (+1)
   \   00000026   0x....             B.N      SPI_CloseTx_ISR
   2443            }
   2444          }
   \                     ??SPI_TxISR_16BIT_0: (+1)
   \   00000028   0x4770             BX       LR               ;; return
   2445          
   2446          /**
   2447            * @brief This function handles SPI Communication Timeout.
   2448            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   2449            *               the configuration information for SPI module.
   2450            * @param Flag : SPI flag to check
   2451            * @param State : flag state to check
   2452            * @param Timeout : Timeout duration
   2453            * @retval HAL status
   2454            */
   2455          static HAL_StatusTypeDef SPI_WaitFlagStateUntilTimeout(SPI_HandleTypeDef *hspi, uint32_t Flag, uint32_t State, uint32_t Timeout)
   2456          {
   2457            uint32_t tickstart = HAL_GetTick();
   2458          
   2459            while((hspi->Instance->SR & Flag) != State)
   2460            {
   2461              if(Timeout != HAL_MAX_DELAY)
   2462              {
   2463                if((Timeout == 0) || ((HAL_GetTick()-tickstart) >= Timeout))
   2464                {
   2465                  /* Disable the SPI and reset the CRC: the CRC value should be cleared
   2466                  on both master and slave sides in order to resynchronize the master
   2467                  and slave for their respective CRC calculation */
   2468          
   2469                  /* Disable TXE, RXNE and ERR interrupts for the interrupt process */
   2470                  __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_RXNE | SPI_IT_ERR));
   2471          
   2472                  if((hspi->Init.Mode == SPI_MODE_MASTER)&&((hspi->Init.Direction == SPI_DIRECTION_1LINE)||(hspi->Init.Direction == SPI_DIRECTION_2LINES_RXONLY)))
   2473                  {
   2474                    /* Disable SPI peripheral */
   2475                    __HAL_SPI_DISABLE(hspi);
   2476                  }
   2477          
   2478                  /* Reset CRC Calculation */
   2479                  if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   2480                  {
   2481                    SPI_RESET_CRC(hspi);
   2482                  }
   2483                  
   2484                  hspi->State= HAL_SPI_STATE_READY;
   2485                  
   2486                  /* Process Unlocked */
   2487                  __HAL_UNLOCK(hspi);
   2488                  
   2489                  return HAL_TIMEOUT;
   2490                }
   2491              }
   2492            }
   2493            
   2494            return HAL_OK;      
   2495          }
   2496          
   2497          /**
   2498            * @brief This function handles SPI Communication Timeout.
   2499            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   2500            *               the configuration information for SPI module.
   2501            * @param Fifo : Fifo to check
   2502            * @param State : Fifo state to check
   2503            * @param Timeout : Timeout duration
   2504            * @retval HAL status
   2505            */
   2506          static HAL_StatusTypeDef SPI_WaitFifoStateUntilTimeout(SPI_HandleTypeDef *hspi, uint32_t Fifo, uint32_t State, uint32_t Timeout)
   2507          {
   2508            __IO uint8_t tmpreg;
   2509            uint32_t tickstart = HAL_GetTick();
   2510          
   2511            while((hspi->Instance->SR & Fifo) != State)
   2512            {
   2513              if((Fifo == SPI_SR_FRLVL) && (State == SPI_FRLVL_EMPTY))
   2514              {
   2515                tmpreg = *((__IO uint8_t*)&hspi->Instance->DR);
   2516                UNUSED(tmpreg); /* To avoid GCC warning */
   2517              }
   2518          
   2519              if(Timeout != HAL_MAX_DELAY)
   2520              {
   2521                if((Timeout == 0) || ((HAL_GetTick()-tickstart) >= Timeout))
   2522                {
   2523                  /* Disable the SPI and reset the CRC: the CRC value should be cleared
   2524                            on both master and slave sides in order to resynchronize the master
   2525                           and slave for their respective CRC calculation */
   2526          
   2527                  /* Disable TXE, RXNE and ERR interrupts for the interrupt process */
   2528                  __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_RXNE | SPI_IT_ERR));
   2529          
   2530                  if((hspi->Init.Mode == SPI_MODE_MASTER)&&((hspi->Init.Direction == SPI_DIRECTION_1LINE)||(hspi->Init.Direction == SPI_DIRECTION_2LINES_RXONLY)))
   2531                  {
   2532                    /* Disable SPI peripheral */
   2533                    __HAL_SPI_DISABLE(hspi);
   2534                  }
   2535          
   2536                  /* Reset CRC Calculation */
   2537                  if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   2538                  {
   2539                    SPI_RESET_CRC(hspi);
   2540                  }
   2541          
   2542                  hspi->State = HAL_SPI_STATE_READY;
   2543          
   2544                  /* Process Unlocked */
   2545                  __HAL_UNLOCK(hspi);
   2546          
   2547                  return HAL_TIMEOUT;
   2548                }
   2549              }
   2550            }
   2551          
   2552            return HAL_OK;
   2553          }
   2554          
   2555          /**
   2556            * @brief This function handles the check of the RX transaction complete.
   2557            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   2558            *               the configuration information for SPI module.
   2559            * @param Timeout : Timeout duration
   2560            * @retval None
   2561            */
   2562          static HAL_StatusTypeDef SPI_EndRxTransaction(SPI_HandleTypeDef *hspi,  uint32_t Timeout)
   2563          {
   2564            if((hspi->Init.Mode == SPI_MODE_MASTER)&&((hspi->Init.Direction == SPI_DIRECTION_1LINE)||(hspi->Init.Direction == SPI_DIRECTION_2LINES_RXONLY)))
   2565            {
   2566              /* Disable SPI peripheral */
   2567              __HAL_SPI_DISABLE(hspi);
   2568            }
   2569            if(SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_BSY, RESET, Timeout) != HAL_OK)
   2570            {  
   2571              hspi->ErrorCode |= HAL_SPI_ERROR_FLAG;
   2572              return HAL_TIMEOUT;
   2573            }
   2574            if(SPI_WaitFifoStateUntilTimeout(hspi, SPI_FLAG_FRLVL, SPI_FRLVL_EMPTY, Timeout) != HAL_OK) 
   2575            {
   2576              hspi->ErrorCode |= HAL_SPI_ERROR_FLAG;
   2577              return HAL_TIMEOUT;
   2578            }
   2579            
   2580            return HAL_OK;
   2581          }
   2582            
   2583          /**
   2584            * @brief This function handles the check of the RXTX or TX transaction complete.
   2585            * @param hspi: SPI handle
   2586            * @param Timeout : Timeout duration
   2587            */
   2588          static HAL_StatusTypeDef SPI_EndRxTxTransaction(SPI_HandleTypeDef *hspi, uint32_t Timeout)
   2589          {
   2590            /* Procedure to check the transaction complete */
   2591            if(SPI_WaitFifoStateUntilTimeout(hspi, SPI_FLAG_FTLVL, SPI_FTLVL_EMPTY, Timeout) != HAL_OK)
   2592            {
   2593              hspi->ErrorCode |= HAL_SPI_ERROR_FLAG;
   2594              return HAL_TIMEOUT;
   2595            }
   2596            if(SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_BSY, RESET, Timeout) != HAL_OK)
   2597            {
   2598              hspi->ErrorCode |= HAL_SPI_ERROR_FLAG;
   2599              return HAL_TIMEOUT;
   2600            }
   2601            if(SPI_WaitFifoStateUntilTimeout(hspi, SPI_FLAG_FRLVL, SPI_FRLVL_EMPTY, Timeout) != HAL_OK)
   2602            {
   2603              hspi->ErrorCode |= HAL_SPI_ERROR_FLAG;
   2604              return HAL_TIMEOUT;
   2605            }
   2606            return HAL_OK;
   2607          }
   2608          
   2609          /**
   2610            * @brief This function handles the close of the RXTX transaction.
   2611            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   2612            *               the configuration information for SPI module.
   2613            * @retval None
   2614            */

   \                                 In section .text, align 2, keep-with-next
   2615          static void SPI_CloseRxTx_ISR(SPI_HandleTypeDef *hspi)
   2616          {
   \                     SPI_CloseRxTx_ISR: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB081             SUB      SP,SP,#+4
   2617            /* Disable ERR interrupt */
   2618            __HAL_SPI_DISABLE_IT(hspi, SPI_IT_ERR);
   \   00000004   0x6801             LDR      R1,[R0, #+0]
   \   00000006   0x684A             LDR      R2,[R1, #+4]
   \   00000008   0xF022 0x0220      BIC      R2,R2,#0x20
   \   0000000C   0x604A             STR      R2,[R1, #+4]
   2619          
   2620            /* Check if CRC error occurred */
   2621            if(__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_CRCERR) != RESET)
   \   0000000E   0x6E02             LDR      R2,[R0, #+96]
   \   00000010   0x688B             LDR      R3,[R1, #+8]
   \   00000012   0x06DB             LSLS     R3,R3,#+27
   \   00000014   0xD509             BPL.N    ??SPI_CloseRxTx_ISR_0
   2622            {
   2623              hspi->State = HAL_SPI_STATE_READY;
   2624              hspi->ErrorCode|= HAL_SPI_ERROR_CRC;
   \   00000016   0xF042 0x0202      ORR      R2,R2,#0x2
   \   0000001A   0x2301             MOVS     R3,#+1
   \   0000001C   0x6602             STR      R2,[R0, #+96]
   2625              __HAL_SPI_CLEAR_CRCERRFLAG(hspi);
   \   0000001E   0xF64F 0x72EF      MOVW     R2,#+65519
   \   00000022   0xF880 0x305D      STRB     R3,[R0, #+93]
   \   00000026   0x608A             STR      R2,[R1, #+8]
   2626              HAL_SPI_ErrorCallback(hspi);
   \   00000028   0xE015             B.N      ??SPI_CloseRxTx_ISR_1
   2627            }
   2628            else
   2629            {
   2630              if(hspi->ErrorCode == HAL_SPI_ERROR_NONE)
   \                     ??SPI_CloseRxTx_ISR_0: (+1)
   \   0000002A   0xB98A             CBNZ.N   R2,??SPI_CloseRxTx_ISR_2
   2631              {
   2632                if(hspi->State == HAL_SPI_STATE_BUSY_RX)
   \   0000002C   0xF890 0x105D      LDRB     R1,[R0, #+93]
   \   00000030   0x2904             CMP      R1,#+4
   \   00000032   0xD106             BNE.N    ??SPI_CloseRxTx_ISR_3
   2633                {
   2634                	hspi->State = HAL_SPI_STATE_READY;
   \   00000034   0x2101             MOVS     R1,#+1
   \   00000036   0xF880 0x105D      STRB     R1,[R0, #+93]
   2635                  HAL_SPI_RxCpltCallback(hspi);
   \   0000003A   0x.... 0x....      BL       HAL_SPI_RxCpltCallback
   2636                }
   2637                else
   2638                {
   2639                	hspi->State = HAL_SPI_STATE_READY;
   2640                  HAL_SPI_TxRxCpltCallback(hspi);
   2641                }      
   2642              }
   2643              else
   2644              {
   2645                hspi->State = HAL_SPI_STATE_READY;
   2646                HAL_SPI_ErrorCallback(hspi);
   2647              }
   2648            }
   2649          }
   \   0000003E   0xB001             ADD      SP,SP,#+4
   \   00000040   0xBD00             POP      {PC}
   \                     ??SPI_CloseRxTx_ISR_3: (+1)
   \   00000042   0x2101             MOVS     R1,#+1
   \   00000044   0xF880 0x105D      STRB     R1,[R0, #+93]
   \   00000048   0x.... 0x....      BL       HAL_SPI_TxRxCpltCallback
   \   0000004C   0xB001             ADD      SP,SP,#+4
   \   0000004E   0xBD00             POP      {PC}
   \                     ??SPI_CloseRxTx_ISR_2: (+1)
   \   00000050   0x2101             MOVS     R1,#+1
   \   00000052   0xF880 0x105D      STRB     R1,[R0, #+93]
   \                     ??SPI_CloseRxTx_ISR_1: (+1)
   \   00000056   0x.... 0x....      BL       HAL_SPI_ErrorCallback
   \   0000005A   0xB001             ADD      SP,SP,#+4
   \   0000005C   0xBD00             POP      {PC}             ;; return
   2650          
   2651          /**
   2652            * @brief This function handles the close of the RX transaction.
   2653            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   2654            *               the configuration information for SPI module.
   2655            * @retval None
   2656            */

   \                                 In section .text, align 2, keep-with-next
   2657          static void SPI_CloseRx_ISR(SPI_HandleTypeDef *hspi)
   2658          {
   \                     SPI_CloseRx_ISR: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0xB081             SUB      SP,SP,#+4
   2659              /* Disable RXNE and ERR interrupt */
   2660              __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_RXNE | SPI_IT_ERR));
   \   00000006   0x6820             LDR      R0,[R4, #+0]
   \   00000008   0x6841             LDR      R1,[R0, #+4]
   \   0000000A   0xF021 0x0160      BIC      R1,R1,#0x60
   \   0000000E   0x6041             STR      R1,[R0, #+4]
   2661              
   2662              /* Check the end of the transaction */
   2663              SPI_EndRxTransaction(hspi,SPI_DEFAULT_TIMEOUT);
   \   00000010   0x6861             LDR      R1,[R4, #+4]
   \   00000012   0xF5B1 0x7F82      CMP      R1,#+260
   \   00000016   0xD10A             BNE.N    ??SPI_CloseRx_ISR_0
   \   00000018   0x68A1             LDR      R1,[R4, #+8]
   \   0000001A   0xF5B1 0x4F00      CMP      R1,#+32768
   \   0000001E   0xBF18             IT       NE 
   \   00000020   0xF5B1 0x6F80      CMPNE    R1,#+1024
   \   00000024   0xD103             BNE.N    ??SPI_CloseRx_ISR_0
   \   00000026   0x6801             LDR      R1,[R0, #+0]
   \   00000028   0xF021 0x0140      BIC      R1,R1,#0x40
   \   0000002C   0x6001             STR      R1,[R0, #+0]
   \                     ??SPI_CloseRx_ISR_0: (+1)
   \   0000002E   0x.... 0x....      BL       HAL_GetTick
   \   00000032   0x4605             MOV      R5,R0
   \                     ??SPI_CloseRx_ISR_1: (+1)
   \   00000034   0x6820             LDR      R0,[R4, #+0]
   \   00000036   0x6880             LDR      R0,[R0, #+8]
   \   00000038   0x0600             LSLS     R0,R0,#+24
   \   0000003A   0xD505             BPL.N    ??SPI_CloseRx_ISR_2
   \   0000003C   0x.... 0x....      BL       HAL_GetTick
   \   00000040   0x1B40             SUBS     R0,R0,R5
   \   00000042   0x2832             CMP      R0,#+50
   \   00000044   0xD3F6             BCC.N    ??SPI_CloseRx_ISR_1
   \   00000046   0xE011             B.N      ??SPI_CloseRx_ISR_3
   \                     ??SPI_CloseRx_ISR_2: (+1)
   \   00000048   0x.... 0x....      BL       HAL_GetTick
   \   0000004C   0x4605             MOV      R5,R0
   \                     ??SPI_CloseRx_ISR_4: (+1)
   \   0000004E   0x6820             LDR      R0,[R4, #+0]
   \   00000050   0x6881             LDR      R1,[R0, #+8]
   \   00000052   0xF411 0x6FC0      TST      R1,#0x600
   \   00000056   0xD034             BEQ.N    ??SPI_CloseRx_ISR_5
   \   00000058   0x7B00             LDRB     R0,[R0, #+12]
   \   0000005A   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \   0000005E   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000062   0x.... 0x....      BL       HAL_GetTick
   \   00000066   0x1B40             SUBS     R0,R0,R5
   \   00000068   0x2832             CMP      R0,#+50
   \   0000006A   0xD3F0             BCC.N    ??SPI_CloseRx_ISR_4
   \                     ??SPI_CloseRx_ISR_3: (+1)
   \   0000006C   0x6820             LDR      R0,[R4, #+0]
   \   0000006E   0x6841             LDR      R1,[R0, #+4]
   \   00000070   0xF021 0x01E0      BIC      R1,R1,#0xE0
   \   00000074   0x6041             STR      R1,[R0, #+4]
   \   00000076   0x6861             LDR      R1,[R4, #+4]
   \   00000078   0xF5B1 0x7F82      CMP      R1,#+260
   \   0000007C   0xD10A             BNE.N    ??SPI_CloseRx_ISR_6
   \   0000007E   0x68A1             LDR      R1,[R4, #+8]
   \   00000080   0xF5B1 0x4F00      CMP      R1,#+32768
   \   00000084   0xBF18             IT       NE 
   \   00000086   0xF5B1 0x6F80      CMPNE    R1,#+1024
   \   0000008A   0xD103             BNE.N    ??SPI_CloseRx_ISR_6
   \   0000008C   0x6801             LDR      R1,[R0, #+0]
   \   0000008E   0xF021 0x0140      BIC      R1,R1,#0x40
   \   00000092   0x6001             STR      R1,[R0, #+0]
   \                     ??SPI_CloseRx_ISR_6: (+1)
   \   00000094   0x6AA1             LDR      R1,[R4, #+40]
   \   00000096   0xF5B1 0x5F00      CMP      R1,#+8192
   \   0000009A   0xD108             BNE.N    ??SPI_CloseRx_ISR_7
   \   0000009C   0x6801             LDR      R1,[R0, #+0]
   \   0000009E   0xF64D 0x72FF      MOVW     R2,#+57343
   \   000000A2   0x4011             ANDS     R1,R2,R1
   \   000000A4   0x6001             STR      R1,[R0, #+0]
   \   000000A6   0x6801             LDR      R1,[R0, #+0]
   \   000000A8   0xF441 0x5100      ORR      R1,R1,#0x2000
   \   000000AC   0x6001             STR      R1,[R0, #+0]
   \                     ??SPI_CloseRx_ISR_7: (+1)
   \   000000AE   0x2001             MOVS     R0,#+1
   \   000000B0   0xF884 0x005D      STRB     R0,[R4, #+93]
   \   000000B4   0x2000             MOVS     R0,#+0
   \   000000B6   0xF884 0x005C      STRB     R0,[R4, #+92]
   \   000000BA   0x6E20             LDR      R0,[R4, #+96]
   \   000000BC   0xF040 0x0020      ORR      R0,R0,#0x20
   \   000000C0   0x6620             STR      R0,[R4, #+96]
   2664          
   2665              hspi->State = HAL_SPI_STATE_READY;
   \                     ??SPI_CloseRx_ISR_5: (+1)
   \   000000C2   0x2001             MOVS     R0,#+1
   \   000000C4   0xF884 0x005D      STRB     R0,[R4, #+93]
   2666          
   2667              /* Check if CRC error occurred */
   2668              if(__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_CRCERR) != RESET)
   \   000000C8   0x6821             LDR      R1,[R4, #+0]
   \   000000CA   0x6E20             LDR      R0,[R4, #+96]
   \   000000CC   0x688A             LDR      R2,[R1, #+8]
   \   000000CE   0x06D2             LSLS     R2,R2,#+27
   \   000000D0   0xD507             BPL.N    ??SPI_CloseRx_ISR_8
   2669              {
   2670                hspi->ErrorCode|= HAL_SPI_ERROR_CRC;
   \   000000D2   0xF040 0x0002      ORR      R0,R0,#0x2
   \   000000D6   0x6620             STR      R0,[R4, #+96]
   2671                __HAL_SPI_CLEAR_CRCERRFLAG(hspi);
   \   000000D8   0xF64F 0x70EF      MOVW     R0,#+65519
   \   000000DC   0x6088             STR      R0,[R1, #+8]
   2672                HAL_SPI_ErrorCallback(hspi);
   \   000000DE   0x4620             MOV      R0,R4
   \   000000E0   0xE006             B.N      ??SPI_CloseRx_ISR_9
   2673              }
   2674              else
   2675              {
   2676                if(hspi->ErrorCode == HAL_SPI_ERROR_NONE)
   \                     ??SPI_CloseRx_ISR_8: (+1)
   \   000000E2   0x2800             CMP      R0,#+0
   \   000000E4   0x4620             MOV      R0,R4
   \   000000E6   0xD103             BNE.N    ??SPI_CloseRx_ISR_9
   2677                {
   2678                  HAL_SPI_RxCpltCallback(hspi);
   \   000000E8   0x.... 0x....      BL       HAL_SPI_RxCpltCallback
   2679                }
   2680                else
   2681                {
   2682                  HAL_SPI_ErrorCallback(hspi);
   2683                }
   2684              }
   2685          }
   \   000000EC   0xB001             ADD      SP,SP,#+4
   \   000000EE   0xBD30             POP      {R4,R5,PC}
   \                     ??SPI_CloseRx_ISR_9: (+1)
   \   000000F0   0x.... 0x....      BL       HAL_SPI_ErrorCallback
   \   000000F4   0xB001             ADD      SP,SP,#+4
   \   000000F6   0xBD30             POP      {R4,R5,PC}       ;; return
   2686          
   2687          /**
   2688            * @brief This function handles the close of the TX transaction.
   2689            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   2690            *               the configuration information for SPI module.
   2691            * @retval None
   2692            */

   \                                 In section .text, align 2, keep-with-next
   2693          static void SPI_CloseTx_ISR(SPI_HandleTypeDef *hspi)
   2694          {
   \                     SPI_CloseTx_ISR: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB081             SUB      SP,SP,#+4
   2695            /* Disable TXE and ERR interrupt */
   2696            __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_ERR));
   \   00000004   0x6801             LDR      R1,[R0, #+0]
   \   00000006   0x684A             LDR      R2,[R1, #+4]
   \   00000008   0xF022 0x02A0      BIC      R2,R2,#0xA0
   \   0000000C   0x604A             STR      R2,[R1, #+4]
   2697          
   2698            /* Clear OVERUN flag in 2 Lines communication mode because received is not read */
   2699            if(hspi->Init.Direction == SPI_DIRECTION_2LINES)
   \   0000000E   0x6882             LDR      R2,[R0, #+8]
   \   00000010   0xB922             CBNZ.N   R2,??SPI_CloseTx_ISR_0
   2700            {
   2701              __HAL_SPI_CLEAR_OVRFLAG(hspi);
   \   00000012   0x68CA             LDR      R2,[R1, #+12]
   \   00000014   0x9200             STR      R2,[SP, #+0]
   \   00000016   0x6889             LDR      R1,[R1, #+8]
   \   00000018   0x9100             STR      R1,[SP, #+0]
   \   0000001A   0x9900             LDR      R1,[SP, #+0]
   2702            }
   2703          
   2704            hspi->State = HAL_SPI_STATE_READY;
   \                     ??SPI_CloseTx_ISR_0: (+1)
   \   0000001C   0x2101             MOVS     R1,#+1
   \   0000001E   0xF880 0x105D      STRB     R1,[R0, #+93]
   2705            if(hspi->ErrorCode != HAL_SPI_ERROR_NONE)
   \   00000022   0x6E01             LDR      R1,[R0, #+96]
   \   00000024   0xB119             CBZ.N    R1,??SPI_CloseTx_ISR_1
   2706            {
   2707              HAL_SPI_ErrorCallback(hspi);
   \   00000026   0x.... 0x....      BL       HAL_SPI_ErrorCallback
   2708            }
   2709            else
   2710            {
   2711              HAL_SPI_TxCpltCallback(hspi);
   2712            }
   2713          }
   \   0000002A   0xB001             ADD      SP,SP,#+4
   \   0000002C   0xBD00             POP      {PC}
   \                     ??SPI_CloseTx_ISR_1: (+1)
   \   0000002E   0x.... 0x....      BL       HAL_SPI_TxCpltCallback
   \   00000032   0xB001             ADD      SP,SP,#+4
   \   00000034   0xBD00             POP      {PC}             ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2:
   \   00000000   0x........         DC32     SPI_TxISR_16BIT

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_1:
   \   00000000   0x........         DC32     SPI_TxISR_8BIT

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_2:
   \   00000000   0x........         DC32     SPI_RxISR_8BITCRC

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_3:
   \   00000000   0x........         DC32     SPI_RxISR_16BITCRC
   2714          
   2715          /**
   2716            * @}
   2717            */
   2718          
   2719          #endif /* HAL_SPI_MODULE_ENABLED */
   2720          /**
   2721            * @}
   2722            */
   2723          
   2724          /**
   2725            * @}
   2726            */
   2727          
   2728          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   HAL_SPI_DMAPause
       0   HAL_SPI_DMAResume
       8   HAL_SPI_DMAStop
         8   -> HAL_DMA_Abort
      16   HAL_SPI_DeInit
        16   -> HAL_GetTick
        16   -> HAL_SPI_MspDeInit
       0   HAL_SPI_ErrorCallback
       0   HAL_SPI_GetError
       0   HAL_SPI_GetState
       8   HAL_SPI_IRQHandler
         0   -- Indirect call
         8   -> HAL_SPI_ErrorCallback
      16   HAL_SPI_Init
        16   -> HAL_SPI_MspInit
       0   HAL_SPI_MspDeInit
       0   HAL_SPI_MspInit
      24   HAL_SPI_Receive
        24   -> HAL_GetTick
        24   -> HAL_SPI_TransmitReceive
       8   HAL_SPI_Receive_DMA
         8   -> HAL_DMA_Start_IT
         0   -> HAL_SPI_TransmitReceive_DMA
       0   HAL_SPI_Receive_IT
         0   -> HAL_SPI_TransmitReceive_IT
       0   HAL_SPI_RxCpltCallback
       0   HAL_SPI_RxHalfCpltCallback
      24   HAL_SPI_Transmit
        24   -> HAL_GetTick
      32   HAL_SPI_TransmitReceive
        32   -> HAL_GetTick
      16   HAL_SPI_TransmitReceive_DMA
        16   -> HAL_DMA_Start_IT
      12   HAL_SPI_TransmitReceive_IT
       8   HAL_SPI_Transmit_DMA
         8   -> HAL_DMA_Start_IT
       0   HAL_SPI_Transmit_IT
       0   HAL_SPI_TxCpltCallback
       0   HAL_SPI_TxHalfCpltCallback
       0   HAL_SPI_TxRxCpltCallback
       0   HAL_SPI_TxRxHalfCpltCallback
       0   SPI_2linesRxISR_16BIT
         0   -> SPI_CloseRxTx_ISR
       8   SPI_2linesRxISR_16BITCRC
         0   -> SPI_CloseRxTx_ISR
       0   SPI_2linesRxISR_8BIT
         0   -> SPI_CloseRxTx_ISR
       8   SPI_2linesRxISR_8BITCRC
         0   -> SPI_CloseRxTx_ISR
       0   SPI_2linesTxISR_16BIT
         0   -> SPI_CloseRxTx_ISR
       8   SPI_2linesTxISR_8BIT
         0   -> SPI_CloseRxTx_ISR
       8   SPI_CloseRxTx_ISR
         8   -> HAL_SPI_ErrorCallback
         8   -> HAL_SPI_RxCpltCallback
         8   -> HAL_SPI_TxRxCpltCallback
      16   SPI_CloseRx_ISR
        16   -> HAL_GetTick
        16   -> HAL_SPI_ErrorCallback
        16   -> HAL_SPI_RxCpltCallback
       8   SPI_CloseTx_ISR
         8   -> HAL_SPI_ErrorCallback
         8   -> HAL_SPI_TxCpltCallback
       8   SPI_DMAError
         8   -> HAL_SPI_ErrorCallback
       8   SPI_DMAHalfReceiveCplt
         8   -> HAL_SPI_RxHalfCpltCallback
       8   SPI_DMAHalfTransmitCplt
         8   -> HAL_SPI_TxHalfCpltCallback
       8   SPI_DMAHalfTransmitReceiveCplt
         8   -> HAL_SPI_TxRxHalfCpltCallback
      16   SPI_DMAReceiveCplt
        16   -> HAL_GetTick
        16   -> HAL_SPI_ErrorCallback
        16   -> HAL_SPI_RxCpltCallback
       8   SPI_DMATransmitCplt
         8   -> HAL_SPI_ErrorCallback
         8   -> HAL_SPI_TxCpltCallback
      16   SPI_DMATransmitReceiveCplt
        16   -> HAL_GetTick
        16   -> HAL_SPI_ErrorCallback
        16   -> HAL_SPI_TxRxCpltCallback
       0   SPI_RxISR_16BIT
         0   -> SPI_CloseRx_ISR
       8   SPI_RxISR_16BITCRC
         0   -> SPI_CloseRx_ISR
       0   SPI_RxISR_8BIT
         0   -> SPI_CloseRx_ISR
       8   SPI_RxISR_8BITCRC
         0   -> SPI_CloseRx_ISR
       0   SPI_TxISR_16BIT
         0   -> SPI_CloseTx_ISR
       0   SPI_TxISR_8BIT
         0   -> SPI_CloseTx_ISR


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable2
       4  ??DataTable2_1
       4  ??DataTable2_2
       4  ??DataTable2_3
      38  HAL_SPI_DMAPause
      38  HAL_SPI_DMAResume
      40  HAL_SPI_DMAStop
     372  HAL_SPI_DeInit
       2  HAL_SPI_ErrorCallback
       4  HAL_SPI_GetError
       6  HAL_SPI_GetState
     166  HAL_SPI_IRQHandler
     186  HAL_SPI_Init
       2  HAL_SPI_MspDeInit
       2  HAL_SPI_MspInit
    1044  HAL_SPI_Receive
     264  HAL_SPI_Receive_DMA
     234  HAL_SPI_Receive_IT
       2  HAL_SPI_RxCpltCallback
       2  HAL_SPI_RxHalfCpltCallback
     770  HAL_SPI_Transmit
    1052  HAL_SPI_TransmitReceive
     398  HAL_SPI_TransmitReceive_DMA
     248  HAL_SPI_TransmitReceive_IT
     224  HAL_SPI_Transmit_DMA
     160  HAL_SPI_Transmit_IT
       2  HAL_SPI_TxCpltCallback
       2  HAL_SPI_TxHalfCpltCallback
       2  HAL_SPI_TxRxCpltCallback
       2  HAL_SPI_TxRxHalfCpltCallback
      62  SPI_2linesRxISR_16BIT
      26  SPI_2linesRxISR_16BITCRC
     110  SPI_2linesRxISR_8BIT
      42  SPI_2linesRxISR_8BITCRC
      60  SPI_2linesTxISR_16BIT
      84  SPI_2linesTxISR_8BIT
      94  SPI_CloseRxTx_ISR
     248  SPI_CloseRx_ISR
      54  SPI_CloseTx_ISR
      38  SPI_DMAError
      14  SPI_DMAHalfReceiveCplt
      14  SPI_DMAHalfTransmitCplt
      14  SPI_DMAHalfTransmitReceiveCplt
     544  SPI_DMAReceiveCplt
      70  SPI_DMATransmitCplt
     532  SPI_DMATransmitReceiveCplt
      66  SPI_RxISR_16BIT
      26  SPI_RxISR_16BITCRC
      66  SPI_RxISR_8BIT
      30  SPI_RxISR_8BITCRC
      42  SPI_TxISR_16BIT
      44  SPI_TxISR_8BIT

 
 7 558 bytes in section .text
 
 7 558 bytes of CODE memory

Errors: none
Warnings: 1
