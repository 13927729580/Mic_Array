###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.2.10312/W32 for ARM       20/Dec/2015  03:50:39
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_spi.c
#    Command line =  
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_spi.c
#        -D USE_HAL_DRIVER -D STM32F746xx -D USE_STM32746G_DISCO -D
#        USE_IOEXPANDER -D USE_USB_FS -lC
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
#        -lA
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
#        -o
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj
#        --debug --endian=little --cpu=Cortex-M7 -e --fpu=VFPv5_sp
#        --dlib_config "D:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Full.h" -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\Inc\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\CMSIS\Device\ST\STM32F7xx\Include\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\STM32F7xx_HAL_Driver\Inc\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\STM32746G-Discovery\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\Components\Common\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Log\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Fonts\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\CPU\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_Device_Library\Core\Inc\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Core\Inc\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Class\MSC\Inc\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\drivers\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_Audio\Addons\PDM\
#        -Ohz --use_c++_inline --require_prototypes -I "D:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.3\arm\CMSIS\Include\" -D
#        ARM_MATH_CM7
#    List file    =  
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List\stm32f7xx_hal_spi.lst
#    Object file  =  
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj\stm32f7xx_hal_spi.o
#
###############################################################################

H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_spi.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f7xx_hal_spi.c
      4            * @author  MCD Application Team
      5            * @version V1.0.1
      6            * @date    25-June-2015
      7            * @brief   SPI HAL module driver.
      8            *          This file provides firmware functions to manage the following 
      9            *          functionalities of the Serial Peripheral Interface (SPI) peripheral:
     10            *           + Initialization and de-initialization functions
     11            *           + IO operation functions
     12            *           + Peripheral Control functions 
     13            *           + Peripheral State functions
     14            @verbatim
     15            ==============================================================================
     16                                  ##### How to use this driver #####
     17            ==============================================================================
     18              [..]
     19                The SPI HAL driver can be used as follows:
     20          
     21                (#) Declare a SPI_HandleTypeDef handle structure, for example:
     22                    SPI_HandleTypeDef  hspi;
     23          
     24                (#)Initialize the SPI low level resources by implementing the HAL_SPI_MspInit ()API:
     25                    (##) Enable the SPIx interface clock
     26                    (##) SPI pins configuration
     27                        (+++) Enable the clock for the SPI GPIOs
     28                        (+++) Configure these SPI pins as alternate function push-pull
     29                    (##) NVIC configuration if you need to use interrupt process
     30                        (+++) Configure the SPIx interrupt priority
     31                        (+++) Enable the NVIC SPI IRQ handle
     32                    (##) DMA Configuration if you need to use DMA process
     33                        (+++) Declare a DMA_HandleTypeDef handle structure for the transmit or receive channel
     34                        (+++) Enable the DMAx clock
     35                        (+++) Configure the DMA handle parameters
     36                        (+++) Configure the DMA Tx or Rx channel
     37                        (+++) Associate the initialized hdma_tx handle to the hspi DMA Tx or Rx handle
     38                        (+++) Configure the priority and enable the NVIC for the transfer complete interrupt on the DMA Tx or Rx channel
     39          
     40                (#) Program the Mode, BidirectionalMode , Data size, Baudrate Prescaler, NSS
     41                    management, Clock polarity and phase, FirstBit and CRC configuration in the hspi Init structure.
     42          
     43                (#) Initialize the SPI registers by calling the HAL_SPI_Init() API:
     44                    (++) This API configures also the low level Hardware GPIO, CLOCK, CORTEX...etc)
     45                        by calling the customised HAL_SPI_MspInit() API.
     46               [..]
     47                 Circular mode restriction:
     48                (#) The DMA circular mode cannot be used when the SPI is configured in these modes:
     49                    (##) Master 2Lines RxOnly
     50                    (##) Master 1Line Rx
     51                (#) The CRC feature is not managed when the DMA circular mode is enabled
     52                (#) When the SPI DMA Pause/Stop features are used, we must use the following APIs
     53                    the HAL_SPI_DMAPause()/ HAL_SPI_DMAStop() only under the SPI callbacks
     54          
     55            @endverbatim
     56            ******************************************************************************
     57            * @attention
     58            *
     59            * <h2><center>&copy; COPYRIGHT(c) 2015 STMicroelectronics</center></h2>
     60            *
     61            * Redistribution and use in source and binary forms, with or without modification,
     62            * are permitted provided that the following conditions are met:
     63            *   1. Redistributions of source code must retain the above copyright notice,
     64            *      this list of conditions and the following disclaimer.
     65            *   2. Redistributions in binary form must reproduce the above copyright notice,
     66            *      this list of conditions and the following disclaimer in the documentation
     67            *      and/or other materials provided with the distribution.
     68            *   3. Neither the name of STMicroelectronics nor the names of its contributors
     69            *      may be used to endorse or promote products derived from this software
     70            *      without specific prior written permission.
     71            *
     72            * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
     73            * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     74            * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     75            * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
     76            * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
     77            * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
     78            * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
     79            * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
     80            * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
     81            * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     82            *
     83            ******************************************************************************
     84            */
     85              
     86          /* Includes ------------------------------------------------------------------*/
     87          #include "stm32f7xx_hal.h"
     88             
     89          /** @addtogroup STM32F7xx_HAL_Driver
     90            * @{
     91            */
     92          
     93          /** @defgroup SPI SPI 
     94            * @brief SPI HAL module driver
     95            * @{
     96            */
     97          #ifdef HAL_SPI_MODULE_ENABLED
     98          
     99          /* Private typedef -----------------------------------------------------------*/
    100          /* Private defines -----------------------------------------------------------*/
    101          /** @defgroup SPI_Private_Constants SPI Private Constants
    102            * @{
    103            */
    104          #define SPI_DEFAULT_TIMEOUT 50
    105          /**
    106            * @}
    107            */
    108          
    109          /* Private macro -------------------------------------------------------------*/
    110          /* Private variables ---------------------------------------------------------*/
    111          /* Private function prototypes -----------------------------------------------*/
    112          /** @addtogroup SPI_Private_Functions
    113            * @{
    114            */
    115          static void SPI_DMATransmitCplt(DMA_HandleTypeDef *hdma);
    116          static void SPI_DMAReceiveCplt(DMA_HandleTypeDef *hdma);
    117          static void SPI_DMATransmitReceiveCplt(DMA_HandleTypeDef *hdma);
    118          static void SPI_DMAHalfTransmitCplt(DMA_HandleTypeDef *hdma);
    119          static void SPI_DMAHalfReceiveCplt(DMA_HandleTypeDef *hdma);
    120          static void SPI_DMAHalfTransmitReceiveCplt(DMA_HandleTypeDef *hdma);
    121          static void SPI_DMAError(DMA_HandleTypeDef *hdma);
    122          static HAL_StatusTypeDef SPI_WaitFlagStateUntilTimeout(SPI_HandleTypeDef *hspi, uint32_t Flag, uint32_t State, uint32_t Timeout);
    123          static HAL_StatusTypeDef SPI_WaitFifoStateUntilTimeout(SPI_HandleTypeDef *hspi, uint32_t Fifo, uint32_t State, uint32_t Timeout);
    124          static void SPI_TxISR_8BIT(struct __SPI_HandleTypeDef *hspi);
    125          static void SPI_TxISR_16BIT(struct __SPI_HandleTypeDef *hspi);
    126          static void SPI_RxISR_8BIT(struct __SPI_HandleTypeDef *hspi);
    127          static void SPI_RxISR_8BITCRC(struct __SPI_HandleTypeDef *hspi);
    128          static void SPI_RxISR_16BIT(struct __SPI_HandleTypeDef *hspi);
    129          static void SPI_RxISR_16BITCRC(struct __SPI_HandleTypeDef *hspi);
    130          static void SPI_2linesRxISR_8BIT(struct __SPI_HandleTypeDef *hspi);
    131          static void SPI_2linesRxISR_8BITCRC(struct __SPI_HandleTypeDef *hspi);
    132          static void SPI_2linesTxISR_8BIT(struct __SPI_HandleTypeDef *hspi);
    133          static void SPI_2linesTxISR_16BIT(struct __SPI_HandleTypeDef *hspi);
    134          static void SPI_2linesRxISR_16BIT(struct __SPI_HandleTypeDef *hspi);
    135          static void SPI_2linesRxISR_16BITCRC(struct __SPI_HandleTypeDef *hspi);
    136          static void SPI_CloseRxTx_ISR(SPI_HandleTypeDef *hspi);
    137          static void SPI_CloseRx_ISR(SPI_HandleTypeDef *hspi);
    138          static void SPI_CloseTx_ISR(SPI_HandleTypeDef *hspi);
    139          static HAL_StatusTypeDef SPI_EndRxTransaction(SPI_HandleTypeDef *hspi, uint32_t Timeout);
    140          static HAL_StatusTypeDef SPI_EndRxTxTransaction(SPI_HandleTypeDef *hspi, uint32_t Timeout);
    141          /**
    142            * @}
    143            */
    144          
    145          /* Exported functions ---------------------------------------------------------*/
    146          
    147          /** @defgroup SPI_Exported_Functions SPI Exported Functions
    148            * @{
    149            */
    150          
    151          /** @defgroup SPI_Exported_Functions_Group1 Initialization and de-initialization functions
    152           *  @brief    Initialization and Configuration functions
    153           *
    154          @verbatim
    155           ===============================================================================
    156                        ##### Initialization and de-initialization functions #####
    157           ===============================================================================
    158              [..]  This subsection provides a set of functions allowing to initialize and
    159                    de-initialize the SPIx peripheral:
    160          
    161                (+) User must implement HAL_SPI_MspInit() function in which he configures
    162                    all related peripherals resources (CLOCK, GPIO, DMA, IT and NVIC ).
    163          
    164                (+) Call the function HAL_SPI_Init() to configure the selected device with
    165                    the selected configuration:
    166                  (++) Mode
    167                  (++) Direction
    168                  (++) Data Size
    169                  (++) Clock Polarity and Phase
    170                  (++) NSS Management
    171                  (++) BaudRate Prescaler
    172                  (++) FirstBit
    173                  (++) TIMode
    174                  (++) CRC Calculation
    175                  (++) CRC Polynomial if CRC enabled
    176                  (++) CRC Length, used only with Data8 and Data16
    177                  (++) FIFO reception threshold
    178          
    179                (+) Call the function HAL_SPI_DeInit() to restore the default configuration
    180                    of the selected SPIx peripheral.
    181          
    182          @endverbatim
    183            * @{
    184            */
    185          
    186          /**
    187            * @brief  Initializes the SPI according to the specified parameters
    188            *         in the SPI_InitTypeDef and create the associated handle.
    189            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
    190            *               the configuration information for SPI module.
    191            * @retval HAL status
    192            */

   \                                 In section .text, align 2, keep-with-next
    193          HAL_StatusTypeDef HAL_SPI_Init(SPI_HandleTypeDef *hspi)
    194          {
   \                     HAL_SPI_Init: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
    195            uint32_t frxth;
    196          
    197            /* Check the SPI handle allocation */
    198            if(hspi == NULL)
   \   00000004   0xD101             BNE.N    ??HAL_SPI_Init_0
    199            {
    200              return HAL_ERROR;
   \   00000006   0x2001             MOVS     R0,#+1
   \   00000008   0xBD70             POP      {R4-R6,PC}
    201            }
    202          
    203            /* Check the parameters */
    204            assert_param(IS_SPI_ALL_INSTANCE(hspi->Instance));
    205            assert_param(IS_SPI_MODE(hspi->Init.Mode));
    206            assert_param(IS_SPI_DIRECTION(hspi->Init.Direction));
    207            assert_param(IS_SPI_DATASIZE(hspi->Init.DataSize));
    208            assert_param(IS_SPI_CPOL(hspi->Init.CLKPolarity));
    209            assert_param(IS_SPI_CPHA(hspi->Init.CLKPhase));
    210            assert_param(IS_SPI_NSS(hspi->Init.NSS));
    211            assert_param(IS_SPI_NSSP(hspi->Init.NSSPMode));
    212            assert_param(IS_SPI_BAUDRATE_PRESCALER(hspi->Init.BaudRatePrescaler));
    213            assert_param(IS_SPI_FIRST_BIT(hspi->Init.FirstBit));
    214            assert_param(IS_SPI_TIMODE(hspi->Init.TIMode));
    215            assert_param(IS_SPI_CRC_CALCULATION(hspi->Init.CRCCalculation));
    216            assert_param(IS_SPI_CRC_POLYNOMIAL(hspi->Init.CRCPolynomial));
    217            assert_param(IS_SPI_CRC_LENGTH(hspi->Init.CRCLength));
    218          
    219            if(hspi->State == HAL_SPI_STATE_RESET)
   \                     ??HAL_SPI_Init_0: (+1)
   \   0000000A   0xF104 0x055C      ADD      R5,R4,#+92
   \   0000000E   0x7868             LDRB     R0,[R5, #+1]
   \   00000010   0xB918             CBNZ.N   R0,??HAL_SPI_Init_1
    220            {
    221              /* Allocate lock resource and initialize it */
    222              hspi->Lock = HAL_UNLOCKED;
   \   00000012   0x7028             STRB     R0,[R5, #+0]
    223          
    224              /* Init the low level hardware : GPIO, CLOCK, NVIC... */
    225              HAL_SPI_MspInit(hspi);
   \   00000014   0x4620             MOV      R0,R4
   \   00000016   0x.... 0x....      BL       HAL_SPI_MspInit
    226            }
    227          
    228            hspi->State = HAL_SPI_STATE_BUSY;
   \                     ??HAL_SPI_Init_1: (+1)
   \   0000001A   0x2002             MOVS     R0,#+2
    229          
    230            /* Disable the selected SPI peripheral */
    231            __HAL_SPI_DISABLE(hspi);
    232          
    233            /* Align by default the rs fifo threshold on the data size */
    234            if(hspi->Init.DataSize > SPI_DATASIZE_8BIT)
   \   0000001C   0xF240 0x7301      MOVW     R3,#+1793
   \   00000020   0x7068             STRB     R0,[R5, #+1]
   \   00000022   0x.... 0x....      BL       ?Subroutine16
   \                     ??CrossCallReturnLabel_25: (+1)
   \   00000026   0x68E2             LDR      R2,[R4, #+12]
   \   00000028   0x429A             CMP      R2,R3
   \   0000002A   0xD304             BCC.N    ??HAL_SPI_Init_2
    235            {
    236              frxth = SPI_RXFIFO_THRESHOLD_HF;
   \   0000002C   0x2100             MOVS     R1,#+0
    237            }
    238            else
    239            {
    240              frxth = SPI_RXFIFO_THRESHOLD_QF;
    241            }
    242          
    243            /* CRC calculation is valid only for 16Bit and 8 Bit */
    244            if(( hspi->Init.DataSize != SPI_DATASIZE_16BIT ) && ( hspi->Init.DataSize != SPI_DATASIZE_8BIT ))
   \   0000002E   0xF5B2 0x6F70      CMP      R2,#+3840
   \   00000032   0xD105             BNE.N    ??HAL_SPI_Init_3
   \   00000034   0xE006             B.N      ??HAL_SPI_Init_4
   \                     ??HAL_SPI_Init_2: (+1)
   \   00000036   0xF5B2 0x6FE0      CMP      R2,#+1792
   \   0000003A   0xF44F 0x5180      MOV      R1,#+4096
   \   0000003E   0xD001             BEQ.N    ??HAL_SPI_Init_4
    245            {
    246              /* CRC must be disabled */
    247              hspi->Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
   \                     ??HAL_SPI_Init_3: (+1)
   \   00000040   0x2600             MOVS     R6,#+0
   \   00000042   0x62A6             STR      R6,[R4, #+40]
    248            }
    249          
    250            /* Align the CRC Length on the data size */
    251            if( hspi->Init.CRCLength == SPI_CRC_LENGTH_DATASIZE)
   \                     ??HAL_SPI_Init_4: (+1)
   \   00000044   0x6B26             LDR      R6,[R4, #+48]
   \   00000046   0xB926             CBNZ.N   R6,??HAL_SPI_Init_5
    252            {
    253              /* CRC Length aligned on the data size : value set by default */
    254              if(hspi->Init.DataSize > SPI_DATASIZE_8BIT)
   \   00000048   0x429A             CMP      R2,R3
   \   0000004A   0xBF2C             ITE      CS 
   \   0000004C   0x2202             MOVCS    R2,#+2
   \   0000004E   0x2201             MOVCC    R2,#+1
    255              {
    256                hspi->Init.CRCLength = SPI_CRC_LENGTH_16BIT;
    257              }
    258              else
    259              {
    260                hspi->Init.CRCLength = SPI_CRC_LENGTH_8BIT;
   \   00000050   0x6322             STR      R2,[R4, #+48]
    261              }
    262            }
    263          
    264            /*---------------------------- SPIx CR1 & CR2 Configuration ------------------------*/
    265            /* Configure : SPI Mode, Communication Mode, Clock polarity and phase, NSS management,
    266            Communication speed, First bit, CRC calculation state, CRC Length */
    267            hspi->Instance->CR1 = (hspi->Init.Mode | hspi->Init.Direction |
    268                                   hspi->Init.CLKPolarity | hspi->Init.CLKPhase | (hspi->Init.NSS & SPI_CR1_SSM) |
    269                                   hspi->Init.BaudRatePrescaler | hspi->Init.FirstBit  | hspi->Init.CRCCalculation);
   \                     ??HAL_SPI_Init_5: (+1)
   \   00000052   0x6862             LDR      R2,[R4, #+4]
   \   00000054   0x68A3             LDR      R3,[R4, #+8]
   \   00000056   0x431A             ORRS     R2,R3,R2
   \   00000058   0x6923             LDR      R3,[R4, #+16]
   \   0000005A   0x431A             ORRS     R2,R3,R2
   \   0000005C   0x6963             LDR      R3,[R4, #+20]
   \   0000005E   0x431A             ORRS     R2,R3,R2
   \   00000060   0x69A3             LDR      R3,[R4, #+24]
   \   00000062   0xF403 0x7300      AND      R3,R3,#0x200
   \   00000066   0x431A             ORRS     R2,R3,R2
   \   00000068   0x69E3             LDR      R3,[R4, #+28]
   \   0000006A   0x431A             ORRS     R2,R3,R2
   \   0000006C   0x6A23             LDR      R3,[R4, #+32]
   \   0000006E   0x431A             ORRS     R2,R3,R2
   \   00000070   0x6AA3             LDR      R3,[R4, #+40]
   \   00000072   0x431A             ORRS     R2,R3,R2
   \   00000074   0x6002             STR      R2,[R0, #+0]
    270          
    271            if( hspi->Init.CRCLength == SPI_CRC_LENGTH_16BIT)
   \   00000076   0x6B22             LDR      R2,[R4, #+48]
   \   00000078   0x2A02             CMP      R2,#+2
   \   0000007A   0xD103             BNE.N    ??HAL_SPI_Init_6
    272            {
    273              hspi->Instance->CR1|= SPI_CR1_CRCL;
   \   0000007C   0x6802             LDR      R2,[R0, #+0]
   \   0000007E   0xF442 0x6200      ORR      R2,R2,#0x800
   \   00000082   0x6002             STR      R2,[R0, #+0]
    274            }
    275          
    276            /* Configure : NSS management */
    277            /* Configure : Rx Fifo Threshold */
    278            hspi->Instance->CR2 = (((hspi->Init.NSS >> 16) & SPI_CR2_SSOE) | hspi->Init.TIMode | hspi->Init.NSSPMode |
    279                                   hspi->Init.DataSize ) | frxth;
   \                     ??HAL_SPI_Init_6: (+1)
   \   00000084   0x69A2             LDR      R2,[R4, #+24]
   \   00000086   0x6A63             LDR      R3,[R4, #+36]
   \   00000088   0x0C12             LSRS     R2,R2,#+16
   \   0000008A   0xF002 0x0204      AND      R2,R2,#0x4
   \   0000008E   0x431A             ORRS     R2,R3,R2
   \   00000090   0x6B63             LDR      R3,[R4, #+52]
   \   00000092   0x431A             ORRS     R2,R3,R2
   \   00000094   0x68E3             LDR      R3,[R4, #+12]
   \   00000096   0x431A             ORRS     R2,R3,R2
   \   00000098   0x4311             ORRS     R1,R1,R2
   \   0000009A   0x6041             STR      R1,[R0, #+4]
    280          
    281            /*---------------------------- SPIx CRCPOLY Configuration --------------------*/
    282            /* Configure : CRC Polynomial */
    283            hspi->Instance->CRCPR = hspi->Init.CRCPolynomial;
   \   0000009C   0x6AE1             LDR      R1,[R4, #+44]
   \   0000009E   0x6101             STR      R1,[R0, #+16]
    284          
    285            hspi->ErrorCode = HAL_SPI_ERROR_NONE;
   \   000000A0   0x2000             MOVS     R0,#+0
   \   000000A2   0x6068             STR      R0,[R5, #+4]
    286            hspi->State= HAL_SPI_STATE_READY;
   \   000000A4   0x2001             MOVS     R0,#+1
   \   000000A6   0x7068             STRB     R0,[R5, #+1]
    287          
    288            return HAL_OK;
   \   000000A8   0x2000             MOVS     R0,#+0
   \   000000AA   0xBD70             POP      {R4-R6,PC}       ;; return
    289          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine16: (+1)
   \   00000000   0x6820             LDR      R0,[R4, #+0]
   \   00000002   0x6801             LDR      R1,[R0, #+0]
   \   00000004   0xF021 0x0140      BIC      R1,R1,#0x40
   \   00000008   0x6001             STR      R1,[R0, #+0]
   \   0000000A   0x4770             BX       LR
    290          
    291          /**
    292            * @brief  DeInitializes the SPI peripheral
    293            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
    294            *               the configuration information for SPI module.
    295            * @retval HAL status
    296            */

   \                                 In section .text, align 2, keep-with-next
    297          HAL_StatusTypeDef HAL_SPI_DeInit(SPI_HandleTypeDef *hspi)
    298          {
   \                     HAL_SPI_DeInit: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0005             MOVS     R5,R0
    299            /* Check the SPI handle allocation */
    300            if(hspi == NULL)
   \   00000004   0xD101             BNE.N    ??HAL_SPI_DeInit_0
    301            {
    302              return HAL_ERROR;
   \   00000006   0x2001             MOVS     R0,#+1
   \   00000008   0xBD32             POP      {R1,R4,R5,PC}
    303            }
    304          
    305            /* Check the parameters */
    306            assert_param(IS_SPI_ALL_INSTANCE(hspi->Instance));
    307          
    308            hspi->State = HAL_SPI_STATE_BUSY;
   \                     ??HAL_SPI_DeInit_0: (+1)
   \   0000000A   0xF105 0x045C      ADD      R4,R5,#+92
   \   0000000E   0x2002             MOVS     R0,#+2
   \   00000010   0x7060             STRB     R0,[R4, #+1]
    309          
    310            /* check flag before the SPI disable */
    311            SPI_WaitFifoStateUntilTimeout(hspi, SPI_FLAG_FTLVL, SPI_FTLVL_EMPTY, SPI_DEFAULT_TIMEOUT);
   \   00000012   0x2332             MOVS     R3,#+50
   \   00000014   0x2200             MOVS     R2,#+0
   \   00000016   0xF44F 0x51C0      MOV      R1,#+6144
   \   0000001A   0x4628             MOV      R0,R5
   \   0000001C   0x.... 0x....      BL       SPI_WaitFifoStateUntilTimeout
    312            SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_BSY, RESET, SPI_DEFAULT_TIMEOUT);
   \   00000020   0x2332             MOVS     R3,#+50
   \   00000022   0x2200             MOVS     R2,#+0
   \   00000024   0x2180             MOVS     R1,#+128
   \   00000026   0x.... 0x....      BL       ??Subroutine21_0
    313            SPI_WaitFifoStateUntilTimeout(hspi, SPI_FLAG_FRLVL, SPI_FRLVL_EMPTY, SPI_DEFAULT_TIMEOUT);
   \                     ??CrossCallReturnLabel_36: (+1)
   \   0000002A   0x2332             MOVS     R3,#+50
   \   0000002C   0x2200             MOVS     R2,#+0
   \   0000002E   0xF44F 0x61C0      MOV      R1,#+1536
   \   00000032   0x4628             MOV      R0,R5
   \   00000034   0x.... 0x....      BL       SPI_WaitFifoStateUntilTimeout
    314          
    315            /* Disable the SPI Peripheral Clock */
    316            __HAL_SPI_DISABLE(hspi);
   \   00000038   0x6828             LDR      R0,[R5, #+0]
   \   0000003A   0x6801             LDR      R1,[R0, #+0]
   \   0000003C   0xF021 0x0140      BIC      R1,R1,#0x40
   \   00000040   0x6001             STR      R1,[R0, #+0]
    317          
    318            /* DeInit the low level hardware: GPIO, CLOCK, NVIC... */
    319            HAL_SPI_MspDeInit(hspi);
   \   00000042   0x4628             MOV      R0,R5
   \   00000044   0x.... 0x....      BL       HAL_SPI_MspDeInit
    320          
    321            hspi->ErrorCode = HAL_SPI_ERROR_NONE;
   \   00000048   0x2000             MOVS     R0,#+0
   \   0000004A   0x6060             STR      R0,[R4, #+4]
    322            hspi->State = HAL_SPI_STATE_RESET;
   \   0000004C   0x7060             STRB     R0,[R4, #+1]
    323          
    324            __HAL_UNLOCK(hspi);
   \   0000004E   0x7020             STRB     R0,[R4, #+0]
    325          
    326            return HAL_OK;
   \   00000050   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    327          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine21: (+1)
   \   00000000   0x2202             MOVS     R2,#+2
   \   00000002   0x2102             MOVS     R1,#+2
   \                     ??Subroutine21_0: (+1)
   \   00000004   0x4628             MOV      R0,R5
   \   00000006   0x.... 0x....      B.W      SPI_WaitFlagStateUntilTimeout
    328          
    329          /**
    330            * @brief SPI MSP Init
    331            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
    332            *               the configuration information for SPI module.
    333            * @retval None
    334            */

   \                                 In section .text, align 2, keep-with-next
    335           __weak void HAL_SPI_MspInit(SPI_HandleTypeDef *hspi)
    336           {
    337             /* NOTE : This function should not be modified, when the callback is needed,
    338                      the HAL_SPI_MspInit should be implemented in the user file
    339             */
    340          }
   \                     HAL_SPI_MspInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    341          
    342          /**
    343            * @brief SPI MSP DeInit
    344            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
    345            *               the configuration information for SPI module.
    346            * @retval None
    347            */

   \                                 In section .text, align 2, keep-with-next
    348           __weak void HAL_SPI_MspDeInit(SPI_HandleTypeDef *hspi)
    349          {
    350            /* NOTE : This function should not be modified, when the callback is needed,
    351                      the HAL_SPI_MspDeInit should be implemented in the user file
    352             */
    353          }
   \                     HAL_SPI_MspDeInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    354          
    355          /**
    356            * @}
    357            */
    358          
    359          /** @defgroup SPI_Exported_Functions_Group2 IO operation functions
    360           *  @brief   Data transfers functions
    361           *
    362          @verbatim
    363            ==============================================================================
    364                                ##### IO operation functions #####
    365           ===============================================================================
    366              This subsection provides a set of functions allowing to manage the SPI
    367              data transfers.
    368          
    369              [..] The SPI supports master and slave mode :
    370          
    371              (#) There are two modes of transfer:
    372                 (++) Blocking mode: The communication is performed in polling mode.
    373                      The HAL status of all data processing is returned by the same function
    374                      after finishing transfer.
    375                 (++) No-Blocking mode: The communication is performed using Interrupts
    376                     or DMA, These APIs return the HAL status.
    377                     The end of the data processing will be indicated through the
    378                     dedicated SPI IRQ when using Interrupt mode or the DMA IRQ when
    379                     using DMA mode.
    380                     The HAL_SPI_TxCpltCallback(), HAL_SPI_RxCpltCallback() and HAL_SPI_TxRxCpltCallback() user callbacks
    381                     will be executed respectively at the end of the transmit or Receive process
    382                     The HAL_SPI_ErrorCallback()user callback will be executed when a communication error is detected
    383          
    384              (#) APIs provided for these 2 transfer modes (Blocking mode or Non blocking mode using either Interrupt or DMA)
    385                  exist for 1Line (simplex) and 2Lines (full duplex) modes.
    386          
    387          @endverbatim
    388            * @{
    389            */
    390          
    391          /**
    392            * @brief  Transmit an amount of data in blocking mode
    393            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
    394            *               the configuration information for SPI module.
    395            * @param  pData: pointer to data buffer
    396            * @param  Size: amount of data to be sent
    397            * @param  Timeout: Timeout duration
    398            * @retval HAL status
    399            */

   \                                 In section .text, align 2, keep-with-next
    400          HAL_StatusTypeDef HAL_SPI_Transmit(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size, uint32_t Timeout)
    401          {
   \                     HAL_SPI_Transmit: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4605             MOV      R5,R0
    402            assert_param(IS_SPI_DIRECTION_2LINES_OR_1LINE(hspi->Init.Direction));
    403          
    404            /* Process Locked */
    405            __HAL_LOCK(hspi);
   \   00000004   0xF105 0x045C      ADD      R4,R5,#+92
   \   00000008   0x461E             MOV      R6,R3
   \   0000000A   0x7820             LDRB     R0,[R4, #+0]
   \   0000000C   0x2801             CMP      R0,#+1
   \   0000000E   0xD006             BEQ.N    ??CrossCallReturnLabel_5
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0x7020             STRB     R0,[R4, #+0]
    406          
    407            if(hspi->State != HAL_SPI_STATE_READY)
   \   00000014   0x7860             LDRB     R0,[R4, #+1]
   \   00000016   0x2801             CMP      R0,#+1
   \   00000018   0xD003             BEQ.N    ??HAL_SPI_Transmit_0
    408            {
    409              hspi->State = HAL_SPI_STATE_READY;
   \   0000001A   0x.... 0x....      BL       ?Subroutine10
    410             /* Process Unlocked */
    411             __HAL_UNLOCK(hspi);
    412             return HAL_BUSY;
   \                     ??CrossCallReturnLabel_5: (+1)
   \   0000001E   0x2002             MOVS     R0,#+2
   \   00000020   0xBDF2             POP      {R1,R4-R7,PC}
    413            }
    414            
    415            if((pData == NULL ) || (Size == 0))
   \                     ??HAL_SPI_Transmit_0: (+1)
   \   00000022   0x2900             CMP      R1,#+0
   \   00000024   0xBF18             IT       NE 
   \   00000026   0x2A00             CMPNE    R2,#+0
   \   00000028   0xD104             BNE.N    ??HAL_SPI_Transmit_1
    416            {
    417              hspi->State = HAL_SPI_STATE_READY;
   \   0000002A   0x7060             STRB     R0,[R4, #+1]
    418             /* Process Unlocked */
    419             __HAL_UNLOCK(hspi);
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0x7020             STRB     R0,[R4, #+0]
    420              return HAL_ERROR;
   \   00000030   0x2001             MOVS     R0,#+1
   \   00000032   0xBDF2             POP      {R1,R4-R7,PC}
    421            }
    422          
    423            /* Set the transaction information */
    424            hspi->State       = HAL_SPI_STATE_BUSY_TX;
   \                     ??HAL_SPI_Transmit_1: (+1)
   \   00000034   0x2003             MOVS     R0,#+3
    425            hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
    426            hspi->pTxBuffPtr  = pData;
   \   00000036   0xF105 0x0738      ADD      R7,R5,#+56
   \   0000003A   0x7060             STRB     R0,[R4, #+1]
   \   0000003C   0x2000             MOVS     R0,#+0
   \   0000003E   0x6060             STR      R0,[R4, #+4]
   \   00000040   0x6039             STR      R1,[R7, #+0]
    427            hspi->TxXferSize  = Size;
   \   00000042   0x80BA             STRH     R2,[R7, #+4]
    428            hspi->TxXferCount = Size;
   \   00000044   0x80FA             STRH     R2,[R7, #+6]
    429            hspi->pRxBuffPtr  = (uint8_t *)NULL;
   \   00000046   0x60B8             STR      R0,[R7, #+8]
    430            hspi->RxXferSize  = 0;
   \   00000048   0x81B8             STRH     R0,[R7, #+12]
    431            hspi->RxXferCount = 0;
   \   0000004A   0x81F8             STRH     R0,[R7, #+14]
    432          
    433            /* Configure communication direction : 1Line */
    434            if(hspi->Init.Direction == SPI_DIRECTION_1LINE)
   \   0000004C   0x68A9             LDR      R1,[R5, #+8]
   \   0000004E   0x6828             LDR      R0,[R5, #+0]
   \   00000050   0xF5B1 0x4F00      CMP      R1,#+32768
   \   00000054   0xD103             BNE.N    ??HAL_SPI_Transmit_2
    435            {
    436              SPI_1LINE_TX(hspi);
   \   00000056   0x6801             LDR      R1,[R0, #+0]
   \   00000058   0xF441 0x4180      ORR      R1,R1,#0x4000
   \   0000005C   0x6001             STR      R1,[R0, #+0]
    437            }
    438          
    439            /* Reset CRC Calculation */
    440            if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   \                     ??HAL_SPI_Transmit_2: (+1)
   \   0000005E   0x6AA9             LDR      R1,[R5, #+40]
   \   00000060   0xF5B1 0x5F00      CMP      R1,#+8192
   \   00000064   0xD101             BNE.N    ??CrossCallReturnLabel_30
    441            {
    442              SPI_RESET_CRC(hspi);
   \   00000066   0x.... 0x....      BL       ?Subroutine18
    443            }
    444          
    445            /* Check if the SPI is already enabled */
    446            if((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
   \                     ??CrossCallReturnLabel_30: (+1)
   \   0000006A   0x.... 0x....      BL       ?Subroutine17
    447            {
    448              /* Enable SPI peripheral */
    449              __HAL_SPI_ENABLE(hspi);
    450            }
    451          
    452            /* Transmit data in 16 Bit mode */
    453            if(hspi->Init.DataSize > SPI_DATASIZE_8BIT)
   \                     ??CrossCallReturnLabel_27: (+1)
   \   0000006E   0x68E8             LDR      R0,[R5, #+12]
   \   00000070   0xF5B0 0x6FE0      CMP      R0,#+1792
   \   00000074   0xD90F             BLS.N    ??HAL_SPI_Transmit_3
    454            {
    455              /* Transmit data in 16 Bit mode */
    456              while (hspi->TxXferCount > 0)
   \                     ??HAL_SPI_Transmit_4: (+1)
   \   00000076   0x88F8             LDRH     R0,[R7, #+6]
   \   00000078   0x2800             CMP      R0,#+0
   \   0000007A   0xD025             BEQ.N    ??HAL_SPI_Transmit_5
    457              {
    458                /* Wait until TXE flag is set to send data */
    459                if(SPI_WaitFlagStateUntilTimeout(hspi,SPI_FLAG_TXE,SPI_FLAG_TXE,Timeout) != HAL_OK)
   \   0000007C   0x4633             MOV      R3,R6
   \   0000007E   0x.... 0x....      BL       ?Subroutine21
   \                     ??CrossCallReturnLabel_39: (+1)
   \   00000082   0xB988             CBNZ.N   R0,??HAL_SPI_Transmit_6
    460                {
    461                  hspi->State = HAL_SPI_STATE_READY;
    462                  /* Process Unlocked */
    463                 __HAL_UNLOCK(hspi);
    464                  return HAL_TIMEOUT;
    465                }
    466                hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
   \   00000084   0x.... 0x....      BL       ?Subroutine24
    467                hspi->pTxBuffPtr += sizeof(uint16_t);
    468                hspi->TxXferCount--;
    469              }
    470            }
   \                     ??CrossCallReturnLabel_44: (+1)
   \   00000088   0x1E40             SUBS     R0,R0,#+1
   \   0000008A   0x80F8             STRH     R0,[R7, #+6]
   \   0000008C   0xE7F3             B.N      ??HAL_SPI_Transmit_4
    471            /* Transmit data in 8 Bit mode */
    472            else
    473            {
    474              while (hspi->TxXferCount > 0)
    475              {
    476                if(hspi->TxXferCount != 0x1)
    477                {
    478                  /* Wait until TXE flag is set to send data */
    479                  if(SPI_WaitFlagStateUntilTimeout(hspi,SPI_FLAG_TXE,SPI_FLAG_TXE,Timeout) != HAL_OK)
    480                  {
    481                    hspi->State = HAL_SPI_STATE_READY;
    482                    /* Process Unlocked */
    483                    __HAL_UNLOCK(hspi);
    484                    return HAL_TIMEOUT;
    485                  }
    486                  hspi->Instance->DR = *((uint16_t*)hspi->pTxBuffPtr);
   \                     ??HAL_SPI_Transmit_7: (+1)
   \   0000008E   0x.... 0x....      BL       ?Subroutine24
    487                  hspi->pTxBuffPtr += sizeof(uint16_t);
    488                  hspi->TxXferCount -= 2;
   \                     ??CrossCallReturnLabel_45: (+1)
   \   00000092   0x1E80             SUBS     R0,R0,#+2
   \                     ??HAL_SPI_Transmit_8: (+1)
   \   00000094   0x80F8             STRH     R0,[R7, #+6]
   \                     ??HAL_SPI_Transmit_3: (+1)
   \   00000096   0x88F8             LDRH     R0,[R7, #+6]
   \   00000098   0xB1B0             CBZ.N    R0,??HAL_SPI_Transmit_5
   \   0000009A   0x2801             CMP      R0,#+1
   \   0000009C   0x4633             MOV      R3,R6
   \   0000009E   0xD006             BEQ.N    ??HAL_SPI_Transmit_9
   \   000000A0   0x.... 0x....      BL       ?Subroutine21
   \                     ??CrossCallReturnLabel_38: (+1)
   \   000000A4   0x2800             CMP      R0,#+0
   \   000000A6   0xD0F2             BEQ.N    ??HAL_SPI_Transmit_7
   \                     ??HAL_SPI_Transmit_6: (+1)
   \   000000A8   0x.... 0x....      BL       ?Subroutine10
    489                }
   \                     ??CrossCallReturnLabel_6: (+1)
   \   000000AC   0xE01A             B.N      ??HAL_SPI_Transmit_10
    490                else
    491                {
    492                  /* Wait until TXE flag is set to send data */
    493                  if(SPI_WaitFlagStateUntilTimeout(hspi,SPI_FLAG_TXE,SPI_FLAG_TXE,Timeout) != HAL_OK)  
   \                     ??HAL_SPI_Transmit_9: (+1)
   \   000000AE   0x.... 0x....      BL       ?Subroutine21
   \                     ??CrossCallReturnLabel_37: (+1)
   \   000000B2   0xB9B8             CBNZ.N   R0,??HAL_SPI_Transmit_10
    494                  {
    495                    return HAL_TIMEOUT;
    496                  }
    497                  *((__IO uint8_t*)&hspi->Instance->DR) = (*hspi->pTxBuffPtr++);
   \   000000B4   0x6838             LDR      R0,[R7, #+0]
   \   000000B6   0x1C40             ADDS     R0,R0,#+1
   \   000000B8   0x6038             STR      R0,[R7, #+0]
   \   000000BA   0x1E40             SUBS     R0,R0,#+1
   \   000000BC   0x6829             LDR      R1,[R5, #+0]
   \   000000BE   0x7800             LDRB     R0,[R0, #+0]
   \   000000C0   0x7308             STRB     R0,[R1, #+12]
    498                  hspi->TxXferCount--;    
   \   000000C2   0x88F8             LDRH     R0,[R7, #+6]
   \   000000C4   0x1E40             SUBS     R0,R0,#+1
   \   000000C6   0xE7E5             B.N      ??HAL_SPI_Transmit_8
    499                }
    500              }
    501            }
    502          
    503            /* Enable CRC Transmission */
    504            if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   \                     ??HAL_SPI_Transmit_5: (+1)
   \   000000C8   0x6AA8             LDR      R0,[R5, #+40]
   \   000000CA   0xF5B0 0x5F00      CMP      R0,#+8192
   \   000000CE   0xD104             BNE.N    ??HAL_SPI_Transmit_11
    505            {
    506               hspi->Instance->CR1|= SPI_CR1_CRCNEXT;
   \   000000D0   0x6828             LDR      R0,[R5, #+0]
   \   000000D2   0x6801             LDR      R1,[R0, #+0]
   \   000000D4   0xF441 0x5180      ORR      R1,R1,#0x1000
   \   000000D8   0x6001             STR      R1,[R0, #+0]
    507            }
    508          
    509            /* Check the end of the transaction */
    510            if(SPI_EndRxTxTransaction(hspi,Timeout) != HAL_OK)
   \                     ??HAL_SPI_Transmit_11: (+1)
   \   000000DA   0x4631             MOV      R1,R6
   \   000000DC   0x4628             MOV      R0,R5
   \   000000DE   0x.... 0x....      BL       SPI_EndRxTxTransaction
   \   000000E2   0xB108             CBZ.N    R0,??HAL_SPI_Transmit_12
    511            {
    512              return HAL_TIMEOUT;
   \                     ??HAL_SPI_Transmit_10: (+1)
   \   000000E4   0x2003             MOVS     R0,#+3
   \   000000E6   0xBDF2             POP      {R1,R4-R7,PC}
    513            }
    514            
    515            /* Clear OVERUN flag in 2 Lines communication mode because received is not read */
    516            if(hspi->Init.Direction == SPI_DIRECTION_2LINES)
   \                     ??HAL_SPI_Transmit_12: (+1)
   \   000000E8   0x68A8             LDR      R0,[R5, #+8]
   \   000000EA   0xB928             CBNZ.N   R0,??HAL_SPI_Transmit_13
    517            {
    518              __HAL_SPI_CLEAR_OVRFLAG(hspi);
   \   000000EC   0x6828             LDR      R0,[R5, #+0]
   \   000000EE   0x68C1             LDR      R1,[R0, #+12]
   \   000000F0   0x9100             STR      R1,[SP, #+0]
   \   000000F2   0x6880             LDR      R0,[R0, #+8]
   \   000000F4   0x9000             STR      R0,[SP, #+0]
   \   000000F6   0x9800             LDR      R0,[SP, #+0]
    519            }
    520              
    521            hspi->State = HAL_SPI_STATE_READY; 
   \                     ??HAL_SPI_Transmit_13: (+1)
   \   000000F8   0x.... 0x....      BL       ?Subroutine10
    522          
    523            /* Process Unlocked */
    524            __HAL_UNLOCK(hspi);
    525            
    526            if(hspi->ErrorCode != HAL_SPI_ERROR_NONE)
   \                     ??CrossCallReturnLabel_7: (+1)
   \   000000FC   0x6860             LDR      R0,[R4, #+4]
   \   000000FE   0xB100             CBZ.N    R0,??HAL_SPI_Transmit_14
   \   00000100   0x2001             MOVS     R0,#+1
   \                     ??HAL_SPI_Transmit_14: (+1)
   \   00000102   0xB2C0             UXTB     R0,R0
    527            {   
    528              return HAL_ERROR;
    529            }
    530            else
    531            {
    532              return HAL_OK;
   \   00000104   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    533            }
    534          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine24: (+1)
   \   00000000   0x6838             LDR      R0,[R7, #+0]
   \   00000002   0x682A             LDR      R2,[R5, #+0]
   \   00000004   0xF830 0x1B02      LDRH     R1,[R0], #+2
   \   00000008   0x60D1             STR      R1,[R2, #+12]
   \   0000000A   0x6038             STR      R0,[R7, #+0]
   \   0000000C   0x88F8             LDRH     R0,[R7, #+6]
   \   0000000E   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine10: (+1)
   \   00000000   0x2001             MOVS     R0,#+1
   \   00000002   0x7060             STRB     R0,[R4, #+1]
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x7020             STRB     R0,[R4, #+0]
   \   00000008   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine18: (+1)
   \   00000000   0x6801             LDR      R1,[R0, #+0]
   \   00000002   0xF64D 0x72FF      MOVW     R2,#+57343
   \   00000006   0x4011             ANDS     R1,R2,R1
   \   00000008   0x6001             STR      R1,[R0, #+0]
   \   0000000A   0x6801             LDR      R1,[R0, #+0]
   \   0000000C   0xF441 0x5100      ORR      R1,R1,#0x2000
   \   00000010   0x6001             STR      R1,[R0, #+0]
   \   00000012   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine17: (+1)
   \   00000000   0x6801             LDR      R1,[R0, #+0]
   \   00000002   0x0649             LSLS     R1,R1,#+25
   \   00000004   0xD403             BMI.N    ??Subroutine17_0
   \   00000006   0x6801             LDR      R1,[R0, #+0]
   \   00000008   0xF041 0x0140      ORR      R1,R1,#0x40
   \   0000000C   0x6001             STR      R1,[R0, #+0]
   \                     ??Subroutine17_0: (+1)
   \   0000000E   0x4770             BX       LR
    535          
    536          /**
    537            * @brief  Receive an amount of data in blocking mode
    538            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
    539            *               the configuration information for SPI module.
    540            * @param  pData: pointer to data buffer
    541            * @param  Size: amount of data to be received
    542            * @param  Timeout: Timeout duration
    543            * @retval HAL status
    544            */

   \                                 In section .text, align 2, keep-with-next
    545          HAL_StatusTypeDef HAL_SPI_Receive(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size, uint32_t Timeout)
    546          {
   \                     HAL_SPI_Receive: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
    547            __IO uint16_t tmpreg;
    548            
    549            if(hspi->State != HAL_SPI_STATE_READY)
   \   00000004   0xF104 0x0644      ADD      R6,R4,#+68
   \   00000008   0x461D             MOV      R5,R3
   \   0000000A   0x7E70             LDRB     R0,[R6, #+25]
   \   0000000C   0x2801             CMP      R0,#+1
   \   0000000E   0xD114             BNE.N    ??HAL_SPI_Receive_0
    550            {
    551              return HAL_BUSY;
    552            }
    553            
    554            if((pData == NULL ) || (Size == 0))
   \   00000010   0x2900             CMP      R1,#+0
   \   00000012   0xBF18             IT       NE 
   \   00000014   0x2A00             CMPNE    R2,#+0
   \   00000016   0xD00C             BEQ.N    ??HAL_SPI_Receive_1
    555            {
    556              return HAL_ERROR;
    557            }
    558          
    559            if((hspi->Init.Mode == SPI_MODE_MASTER) && (hspi->Init.Direction == SPI_DIRECTION_2LINES))
   \   00000018   0x6860             LDR      R0,[R4, #+4]
   \   0000001A   0xF5B0 0x7F82      CMP      R0,#+260
   \   0000001E   0xBF04             ITT      EQ 
   \   00000020   0x68A0             LDREQ    R0,[R4, #+8]
   \   00000022   0x2800             CMPEQ    R0,#+0
   \   00000024   0xD106             BNE.N    ??HAL_SPI_Receive_2
    560            {
    561              /* the receive process is not supported in 2Lines direction master mode */
    562              /* in this case we call the transmitReceive process                     */
    563              return HAL_SPI_TransmitReceive(hspi,pData,pData,Size,Timeout);
   \   00000026   0x4613             MOV      R3,R2
   \   00000028   0x9500             STR      R5,[SP, #+0]
   \   0000002A   0x460A             MOV      R2,R1
   \   0000002C   0x4620             MOV      R0,R4
   \   0000002E   0x.... 0x....      BL       HAL_SPI_TransmitReceive
   \                     ??HAL_SPI_Receive_1: (+1)
   \   00000032   0xBDF2             POP      {R1,R4-R7,PC}
    564            }
    565            
    566            /* Process Locked */
    567            __HAL_LOCK(hspi);
   \                     ??HAL_SPI_Receive_2: (+1)
   \   00000034   0x7E30             LDRB     R0,[R6, #+24]
   \   00000036   0x2801             CMP      R0,#+1
   \   00000038   0xD101             BNE.N    ??HAL_SPI_Receive_3
   \                     ??HAL_SPI_Receive_0: (+1)
   \   0000003A   0x2002             MOVS     R0,#+2
   \   0000003C   0xBDF2             POP      {R1,R4-R7,PC}
   \                     ??HAL_SPI_Receive_3: (+1)
   \   0000003E   0x2001             MOVS     R0,#+1
   \   00000040   0x7630             STRB     R0,[R6, #+24]
    568              
    569            hspi->State       = HAL_SPI_STATE_BUSY_RX;
   \   00000042   0x2004             MOVS     R0,#+4
   \   00000044   0x7670             STRB     R0,[R6, #+25]
    570            hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
   \   00000046   0x2000             MOVS     R0,#+0
   \   00000048   0x61F0             STR      R0,[R6, #+28]
    571            hspi->pRxBuffPtr  = pData;
   \   0000004A   0x6421             STR      R1,[R4, #+64]
    572            hspi->RxXferSize  = Size;
   \   0000004C   0x8032             STRH     R2,[R6, #+0]
    573            hspi->RxXferCount = Size;
   \   0000004E   0x8072             STRH     R2,[R6, #+2]
    574            hspi->pTxBuffPtr  = (uint8_t *)NULL;
    575            hspi->TxXferSize  = 0;
    576            hspi->TxXferCount = 0;
    577          
    578            /* Reset CRC Calculation */
    579            if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   \   00000050   0x6AA1             LDR      R1,[R4, #+40]
   \   00000052   0x63A0             STR      R0,[R4, #+56]
   \   00000054   0xF5B1 0x5F00      CMP      R1,#+8192
   \   00000058   0x87A0             STRH     R0,[R4, #+60]
   \   0000005A   0x87E0             STRH     R0,[R4, #+62]
   \   0000005C   0x6820             LDR      R0,[R4, #+0]
   \   0000005E   0xD104             BNE.N    ??HAL_SPI_Receive_4
    580            {
    581              SPI_RESET_CRC(hspi);
   \   00000060   0x.... 0x....      BL       ?Subroutine18
    582              /* this is done to handle the CRCNEXT before the latest data */
    583              hspi->RxXferCount--;
   \                     ??CrossCallReturnLabel_31: (+1)
   \   00000064   0x8871             LDRH     R1,[R6, #+2]
   \   00000066   0x1E49             SUBS     R1,R1,#+1
   \   00000068   0x8071             STRH     R1,[R6, #+2]
    584            }
    585          
    586            /* Set the Rx Fido threshold */
    587            if(hspi->Init.DataSize > SPI_DATASIZE_8BIT)
   \                     ??HAL_SPI_Receive_4: (+1)
   \   0000006A   0x68E1             LDR      R1,[R4, #+12]
   \   0000006C   0xF240 0x7701      MOVW     R7,#+1793
   \   00000070   0x42B9             CMP      R1,R7
   \   00000072   0x6841             LDR      R1,[R0, #+4]
   \   00000074   0xBF2C             ITE      CS 
   \   00000076   0xF421 0x5180      BICCS    R1,R1,#0x1000
   \   0000007A   0xF441 0x5180      ORRCC    R1,R1,#0x1000
    588            {
    589              /* set fiforxthreshold according the reception data length: 16bit */
    590              CLEAR_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
    591            }
    592            else
    593            {
    594              /* set fiforxthreshold according the reception data length: 8bit */
    595              SET_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
   \   0000007E   0x6041             STR      R1,[R0, #+4]
    596            }
    597          
    598            /* Configure communication direction 1Line and enabled SPI if needed */
    599            if(hspi->Init.Direction == SPI_DIRECTION_1LINE)
   \   00000080   0x68A1             LDR      R1,[R4, #+8]
   \   00000082   0xF5B1 0x4F00      CMP      R1,#+32768
   \   00000086   0xD103             BNE.N    ??HAL_SPI_Receive_5
    600            {
    601              SPI_1LINE_RX(hspi);
   \   00000088   0x6801             LDR      R1,[R0, #+0]
   \   0000008A   0xF421 0x4180      BIC      R1,R1,#0x4000
   \   0000008E   0x6001             STR      R1,[R0, #+0]
    602            }
    603          
    604            /* Check if the SPI is already enabled */
    605            if((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
   \                     ??HAL_SPI_Receive_5: (+1)
   \   00000090   0x.... 0x....      BL       ?Subroutine17
    606            {
    607              /* Enable SPI peripheral */
    608              __HAL_SPI_ENABLE(hspi);
    609            }
    610          
    611            /* Receive data in 8 Bit mode */
    612            if(hspi->Init.DataSize <= SPI_DATASIZE_8BIT)
   \                     ??CrossCallReturnLabel_28: (+1)
   \   00000094   0x68E0             LDR      R0,[R4, #+12]
   \   00000096   0x42B8             CMP      R0,R7
   \   00000098   0xD21D             BCS.N    ??HAL_SPI_Receive_6
    613            {
    614              while(hspi->RxXferCount > 1)
   \                     ??HAL_SPI_Receive_7: (+1)
   \   0000009A   0x8870             LDRH     R0,[R6, #+2]
   \   0000009C   0x2802             CMP      R0,#+2
   \   0000009E   0xDB1D             BLT.N    ??HAL_SPI_Receive_8
    615              {
    616                /* Wait until the RXNE flag */
    617                if(SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_RXNE, SPI_FLAG_RXNE, Timeout) != HAL_OK)
   \   000000A0   0x.... 0x....      BL       ?Subroutine13
   \                     ??CrossCallReturnLabel_20: (+1)
   \   000000A4   0x2800             CMP      R0,#+0
   \   000000A6   0xD15F             BNE.N    ??HAL_SPI_Receive_9
    618                {
    619                  return HAL_TIMEOUT;
    620                }
    621                (*hspi->pRxBuffPtr++)= *(__IO uint8_t *)&hspi->Instance->DR;
   \   000000A8   0x6C20             LDR      R0,[R4, #+64]
   \   000000AA   0x1C41             ADDS     R1,R0,#+1
   \   000000AC   0x6421             STR      R1,[R4, #+64]
   \   000000AE   0x6821             LDR      R1,[R4, #+0]
   \   000000B0   0x7B09             LDRB     R1,[R1, #+12]
   \   000000B2   0x7001             STRB     R1,[R0, #+0]
    622                hspi->RxXferCount--;  
   \   000000B4   0x8870             LDRH     R0,[R6, #+2]
   \   000000B6   0x1E40             SUBS     R0,R0,#+1
   \   000000B8   0x8070             STRH     R0,[R6, #+2]
   \   000000BA   0xE7EE             B.N      ??HAL_SPI_Receive_7
    623              }
    624            }
    625            else /* Receive data in 16 Bit mode */
    626            {   
    627              while(hspi->RxXferCount > 1 )
    628              {
    629                /* Wait until RXNE flag is reset to read data */
    630                if(SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_RXNE, SPI_FLAG_RXNE, Timeout) != HAL_OK)
   \                     ??HAL_SPI_Receive_10: (+1)
   \   000000BC   0x.... 0x....      BL       ?Subroutine13
   \                     ??CrossCallReturnLabel_19: (+1)
   \   000000C0   0x2800             CMP      R0,#+0
   \   000000C2   0xD151             BNE.N    ??HAL_SPI_Receive_9
    631                {
    632                  return HAL_TIMEOUT;
    633                }
    634                *((uint16_t*)hspi->pRxBuffPtr) = hspi->Instance->DR;
   \   000000C4   0x6821             LDR      R1,[R4, #+0]
   \   000000C6   0x6C20             LDR      R0,[R4, #+64]
   \   000000C8   0x68C9             LDR      R1,[R1, #+12]
   \   000000CA   0xF820 0x1B02      STRH     R1,[R0], #+2
    635                hspi->pRxBuffPtr += sizeof(uint16_t);
   \   000000CE   0x6420             STR      R0,[R4, #+64]
    636                hspi->RxXferCount--;
   \   000000D0   0x8870             LDRH     R0,[R6, #+2]
   \   000000D2   0x1E40             SUBS     R0,R0,#+1
   \   000000D4   0x8070             STRH     R0,[R6, #+2]
    637              } 
   \                     ??HAL_SPI_Receive_6: (+1)
   \   000000D6   0x8870             LDRH     R0,[R6, #+2]
   \   000000D8   0x2802             CMP      R0,#+2
   \   000000DA   0xDAEF             BGE.N    ??HAL_SPI_Receive_10
    638            }
    639            
    640            /* Enable CRC Transmission */
    641            if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE) 
   \                     ??HAL_SPI_Receive_8: (+1)
   \   000000DC   0x.... 0x....      BL       ?Subroutine31
   \                     ??CrossCallReturnLabel_63: (+1)
   \   000000E0   0xD104             BNE.N    ??HAL_SPI_Receive_11
    642            {
    643              hspi->Instance->CR1 |= SPI_CR1_CRCNEXT;
   \   000000E2   0x6820             LDR      R0,[R4, #+0]
   \   000000E4   0x6801             LDR      R1,[R0, #+0]
   \   000000E6   0xF441 0x5180      ORR      R1,R1,#0x1000
   \   000000EA   0x6001             STR      R1,[R0, #+0]
    644            }  
    645          
    646            /* Wait until RXNE flag is set */
    647            if(SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_RXNE, SPI_FLAG_RXNE, Timeout) != HAL_OK)
   \                     ??HAL_SPI_Receive_11: (+1)
   \   000000EC   0x.... 0x....      BL       ?Subroutine13
   \                     ??CrossCallReturnLabel_18: (+1)
   \   000000F0   0x2800             CMP      R0,#+0
   \   000000F2   0xD139             BNE.N    ??HAL_SPI_Receive_9
    648            {
    649              return HAL_TIMEOUT;
    650            }
    651            
    652            /* Receive last data in 16 Bit mode */
    653            if(hspi->Init.DataSize > SPI_DATASIZE_8BIT)
   \   000000F4   0x68E2             LDR      R2,[R4, #+12]
   \   000000F6   0x6821             LDR      R1,[R4, #+0]
   \   000000F8   0x6C20             LDR      R0,[R4, #+64]
   \   000000FA   0x42BA             CMP      R2,R7
   \   000000FC   0xBF27             ITTEE    CS 
   \   000000FE   0x68C9             LDRCS    R1,[R1, #+12]
   \   00000100   0xF820 0x1B02      STRHCS   R1,[R0], #+2
   \   00000104   0x7B09             LDRBCC   R1,[R1, #+12]
   \   00000106   0xF800 0x1B01      STRBCC   R1,[R0], #+1
    654            {        
    655              *((uint16_t*)hspi->pRxBuffPtr) = hspi->Instance->DR;
    656              hspi->pRxBuffPtr += sizeof(uint16_t);
    657            }
    658            /* Receive last data in 8 Bit mode */
    659            else 
    660            {
    661              (*hspi->pRxBuffPtr++) = *(__IO uint8_t *)&hspi->Instance->DR;
   \   0000010A   0x6420             STR      R0,[R4, #+64]
    662            }
    663            hspi->RxXferCount--;
   \   0000010C   0x8870             LDRH     R0,[R6, #+2]
   \   0000010E   0x1E40             SUBS     R0,R0,#+1
   \   00000110   0x8070             STRH     R0,[R6, #+2]
    664            
    665            /* Read CRC from DR to close CRC calculation process */
    666            if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   \   00000112   0x.... 0x....      BL       ?Subroutine31
   \                     ??CrossCallReturnLabel_64: (+1)
   \   00000116   0xD122             BNE.N    ??CrossCallReturnLabel_74
    667            {
    668              /* Wait until TXE flag */
    669              if(SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_RXNE, SPI_FLAG_RXNE, Timeout) != HAL_OK) 
   \   00000118   0x.... 0x....      BL       ?Subroutine13
   \                     ??CrossCallReturnLabel_17: (+1)
   \   0000011C   0xB118             CBZ.N    R0,??HAL_SPI_Receive_12
    670              {
    671                /* Error on the CRC reception */
    672                hspi->ErrorCode|= HAL_SPI_ERROR_CRC;
   \   0000011E   0x69F0             LDR      R0,[R6, #+28]
   \   00000120   0xF040 0x0002      ORR      R0,R0,#0x2
   \   00000124   0x61F0             STR      R0,[R6, #+28]
    673              }
    674              if(hspi->Init.DataSize > SPI_DATASIZE_8BIT)
   \                     ??HAL_SPI_Receive_12: (+1)
   \   00000126   0x68E0             LDR      R0,[R4, #+12]
   \   00000128   0x6821             LDR      R1,[R4, #+0]
   \   0000012A   0x42B8             CMP      R0,R7
   \   0000012C   0xBF28             IT       CS 
   \   0000012E   0x68C8             LDRCS    R0,[R1, #+12]
    675              {        
    676                tmpreg = hspi->Instance->DR;
   \   00000130   0xD213             BCS.N    ??HAL_SPI_Receive_13
    677                UNUSED(tmpreg); /* To avoid GCC warning */
    678              }
    679              else
    680              {
    681                tmpreg = *(__IO uint8_t *)&hspi->Instance->DR;
   \   00000132   0x7B09             LDRB     R1,[R1, #+12]
    682                UNUSED(tmpreg); /* To avoid GCC warning */
    683          
    684                if((hspi->Init.DataSize == SPI_DATASIZE_8BIT) && (hspi->Init.CRCLength == SPI_CRC_LENGTH_16BIT))
   \   00000134   0xF5B0 0x6FE0      CMP      R0,#+1792
   \   00000138   0xF8AD 0x1000      STRH     R1,[SP, #+0]
   \   0000013C   0xF8BD 0x1000      LDRH     R1,[SP, #+0]
   \   00000140   0xBF04             ITT      EQ 
   \   00000142   0x6B20             LDREQ    R0,[R4, #+48]
   \   00000144   0x2802             CMPEQ    R0,#+2
   \   00000146   0xD10A             BNE.N    ??CrossCallReturnLabel_74
    685                {
    686                  if(SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_RXNE, SPI_FLAG_RXNE, Timeout) != HAL_OK)
   \   00000148   0x.... 0x....      BL       ?Subroutine13
   \                     ??CrossCallReturnLabel_16: (+1)
   \   0000014C   0xB118             CBZ.N    R0,??HAL_SPI_Receive_14
    687                  {
    688                    /* Error on the CRC reception */
    689                    hspi->ErrorCode|= HAL_SPI_ERROR_FLAG;
   \   0000014E   0x69F0             LDR      R0,[R6, #+28]
   \   00000150   0xF040 0x0020      ORR      R0,R0,#0x20
   \   00000154   0x61F0             STR      R0,[R6, #+28]
    690                  }
    691                  tmpreg = *(__IO uint8_t *)&hspi->Instance->DR;
   \                     ??HAL_SPI_Receive_14: (+1)
   \   00000156   0x6820             LDR      R0,[R4, #+0]
   \   00000158   0x7B00             LDRB     R0,[R0, #+12]
    692                  UNUSED(tmpreg); /* To avoid GCC warning */
    693                }
    694              }
    695            }
   \                     ??HAL_SPI_Receive_13: (+1)
   \   0000015A   0x.... 0x....      BL       ?Subroutine34
    696            
    697            /* Check the end of the transaction */
    698            if(SPI_EndRxTransaction(hspi,Timeout) != HAL_OK)
   \                     ??CrossCallReturnLabel_74: (+1)
   \   0000015E   0x4629             MOV      R1,R5
   \   00000160   0x4620             MOV      R0,R4
   \   00000162   0x.... 0x....      BL       SPI_EndRxTransaction
   \   00000166   0xB108             CBZ.N    R0,??HAL_SPI_Receive_15
    699            {
    700              return HAL_TIMEOUT;
   \                     ??HAL_SPI_Receive_9: (+1)
   \   00000168   0x2003             MOVS     R0,#+3
   \   0000016A   0xBDF2             POP      {R1,R4-R7,PC}
    701            }
    702          
    703            hspi->State = HAL_SPI_STATE_READY; 
   \                     ??HAL_SPI_Receive_15: (+1)
   \   0000016C   0x2001             MOVS     R0,#+1
   \   0000016E   0x7670             STRB     R0,[R6, #+25]
    704              
    705            /* Check if CRC error occurred */
    706            if(__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_CRCERR) != RESET)
   \   00000170   0x6821             LDR      R1,[R4, #+0]
   \   00000172   0x69F0             LDR      R0,[R6, #+28]
   \   00000174   0x688A             LDR      R2,[R1, #+8]
   \   00000176   0x06D2             LSLS     R2,R2,#+27
   \   00000178   0xD509             BPL.N    ??HAL_SPI_Receive_16
    707            {
    708              hspi->ErrorCode|= HAL_SPI_ERROR_CRC;
   \   0000017A   0xF040 0x0002      ORR      R0,R0,#0x2
   \   0000017E   0x61F0             STR      R0,[R6, #+28]
    709              __HAL_SPI_CLEAR_CRCERRFLAG(hspi);
   \   00000180   0xF64F 0x70EF      MOVW     R0,#+65519
   \   00000184   0x6088             STR      R0,[R1, #+8]
    710                            
    711              /* Process Unlocked */
    712              __HAL_UNLOCK(hspi);
   \   00000186   0x2000             MOVS     R0,#+0
   \   00000188   0x7630             STRB     R0,[R6, #+24]
    713              return HAL_ERROR;
   \   0000018A   0x2001             MOVS     R0,#+1
   \   0000018C   0xBDF2             POP      {R1,R4-R7,PC}
    714            }
    715              
    716            /* Process Unlocked */
    717            __HAL_UNLOCK(hspi);
   \                     ??HAL_SPI_Receive_16: (+1)
   \   0000018E   0x2100             MOVS     R1,#+0
   \   00000190   0x7631             STRB     R1,[R6, #+24]
    718            
    719            if(hspi->ErrorCode != HAL_SPI_ERROR_NONE)
   \   00000192   0xB100             CBZ.N    R0,??HAL_SPI_Receive_17
   \   00000194   0x2001             MOVS     R0,#+1
   \                     ??HAL_SPI_Receive_17: (+1)
   \   00000196   0xB2C0             UXTB     R0,R0
    720            {   
    721              return HAL_ERROR;
    722            }
    723            else
    724            {
    725              return HAL_OK;
   \                     ??HAL_SPI_Receive_18: (+1)
   \   00000198   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    726            }
    727          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine34: (+1)
   \   00000000   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   \   00000004   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   00000008   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine31: (+1)
   \   00000000   0x6AA0             LDR      R0,[R4, #+40]
   \   00000002   0xF5B0 0x5F00      CMP      R0,#+8192
   \   00000006   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine13: (+1)
   \   00000000   0x462B             MOV      R3,R5
   \                     ??Subroutine13_0: (+1)
   \   00000002   0x2201             MOVS     R2,#+1
   \   00000004   0x2101             MOVS     R1,#+1
   \   00000006   0x4620             MOV      R0,R4
   \   00000008   0x....             B.N      SPI_WaitFlagStateUntilTimeout
    728          
    729          /**
    730            * @brief  Transmit and Receive an amount of data in blocking mode
    731            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
    732            *               the configuration information for SPI module.
    733            * @param  pTxData: pointer to transmission data buffer
    734            * @param  pRxData: pointer to reception data buffer
    735            * @param  Size: amount of data to be sent and received
    736            * @param  Timeout: Timeout duration
    737            * @retval HAL status
    738            */

   \                                 In section .text, align 2, keep-with-next
    739          HAL_StatusTypeDef HAL_SPI_TransmitReceive(SPI_HandleTypeDef *hspi, uint8_t *pTxData, uint8_t *pRxData, uint16_t Size, uint32_t Timeout)
    740          {
   \                     HAL_SPI_TransmitReceive: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0xB082             SUB      SP,SP,#+8
    741            __IO uint16_t tmpreg = 0;
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x460E             MOV      R6,R1
   \   0000000C   0x4691             MOV      R9,R2
   \   0000000E   0x469A             MOV      R10,R3
   \   00000010   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   \   00000014   0xF104 0x055C      ADD      R5,R4,#+92
    742            uint32_t tickstart = HAL_GetTick();
   \   00000018   0x.... 0x....      BL       HAL_GetTick
   \   0000001C   0x4680             MOV      R8,R0
    743            
    744            assert_param(IS_SPI_DIRECTION_2LINES(hspi->Init.Direction));
    745            
    746            if(hspi->State != HAL_SPI_STATE_READY) 
   \   0000001E   0x7868             LDRB     R0,[R5, #+1]
   \   00000020   0x2801             CMP      R0,#+1
   \   00000022   0xD109             BNE.N    ??HAL_SPI_TransmitReceive_0
    747            {
    748              return HAL_BUSY;
    749            }
    750            
    751            if((pTxData == NULL) || (pRxData == NULL) || (Size == 0))
   \   00000024   0x2E00             CMP      R6,#+0
   \   00000026   0xBF1C             ITT      NE 
   \   00000028   0xF1B9 0x0F00      CMPNE    R9,#+0
   \   0000002C   0xF1BA 0x0F00      CMPNE    R10,#+0
   \   00000030   0xD003             BEQ.N    ??HAL_SPI_TransmitReceive_1
    752            {
    753              return HAL_ERROR;
    754            }
    755          
    756            
    757            /* Process Locked */
    758            __HAL_LOCK(hspi); 
   \   00000032   0x7828             LDRB     R0,[R5, #+0]
   \   00000034   0x2801             CMP      R0,#+1
   \   00000036   0xD101             BNE.N    ??HAL_SPI_TransmitReceive_2
   \                     ??HAL_SPI_TransmitReceive_0: (+1)
   \   00000038   0x2002             MOVS     R0,#+2
   \                     ??HAL_SPI_TransmitReceive_1: (+1)
   \   0000003A   0xE0F9             B.N      ??HAL_SPI_TransmitReceive_3
   \                     ??HAL_SPI_TransmitReceive_2: (+1)
   \   0000003C   0x2001             MOVS     R0,#+1
    759            
    760            hspi->State       = HAL_SPI_STATE_BUSY_TX_RX;
    761            hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
    762            hspi->pRxBuffPtr  = pRxData;
   \   0000003E   0xF104 0x0738      ADD      R7,R4,#+56
   \   00000042   0x7028             STRB     R0,[R5, #+0]
   \   00000044   0x2005             MOVS     R0,#+5
   \   00000046   0x7068             STRB     R0,[R5, #+1]
   \   00000048   0x2000             MOVS     R0,#+0
   \   0000004A   0x6068             STR      R0,[R5, #+4]
   \   0000004C   0xF8C7 0x9008      STR      R9,[R7, #+8]
    763            hspi->RxXferCount = Size;
   \   00000050   0xF8A7 0xA00E      STRH     R10,[R7, #+14]
    764            hspi->RxXferSize  = Size;
   \   00000054   0xF8A7 0xA00C      STRH     R10,[R7, #+12]
    765            hspi->pTxBuffPtr  = pTxData;
   \   00000058   0x603E             STR      R6,[R7, #+0]
    766            hspi->TxXferCount = Size;
   \   0000005A   0xF8A7 0xA006      STRH     R10,[R7, #+6]
    767            hspi->TxXferSize  = Size;
   \   0000005E   0xF8A7 0xA004      STRH     R10,[R7, #+4]
    768          
    769            /* Reset CRC Calculation */
    770            if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   \   00000062   0x.... 0x....      BL       ?Subroutine31
   \                     ??CrossCallReturnLabel_65: (+1)
   \   00000066   0xD109             BNE.N    ??HAL_SPI_TransmitReceive_4
    771            {
    772              SPI_RESET_CRC(hspi);
   \   00000068   0x6820             LDR      R0,[R4, #+0]
   \   0000006A   0xF64D 0x72FF      MOVW     R2,#+57343
   \   0000006E   0x6801             LDR      R1,[R0, #+0]
   \   00000070   0x4011             ANDS     R1,R2,R1
   \   00000072   0x6001             STR      R1,[R0, #+0]
   \   00000074   0x6801             LDR      R1,[R0, #+0]
   \   00000076   0xF441 0x5100      ORR      R1,R1,#0x2000
   \   0000007A   0x6001             STR      R1,[R0, #+0]
    773            }
    774          
    775            /* Set the Rx Fido threshold */
    776            if((hspi->Init.DataSize > SPI_DATASIZE_8BIT) || (hspi->RxXferCount > 1))
   \                     ??HAL_SPI_TransmitReceive_4: (+1)
   \   0000007C   0x68E0             LDR      R0,[R4, #+12]
   \   0000007E   0xF240 0x7101      MOVW     R1,#+1793
   \   00000082   0x4288             CMP      R0,R1
   \   00000084   0xD202             BCS.N    ??HAL_SPI_TransmitReceive_5
   \   00000086   0x89F8             LDRH     R0,[R7, #+14]
   \   00000088   0x2802             CMP      R0,#+2
   \   0000008A   0xDB04             BLT.N    ??HAL_SPI_TransmitReceive_6
    777            {
    778              /* set fiforxthreshold according the reception data length: 16bit */
    779              CLEAR_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
   \                     ??HAL_SPI_TransmitReceive_5: (+1)
   \   0000008C   0x6820             LDR      R0,[R4, #+0]
   \   0000008E   0x6842             LDR      R2,[R0, #+4]
   \   00000090   0xF422 0x5280      BIC      R2,R2,#0x1000
   \   00000094   0xE003             B.N      ??HAL_SPI_TransmitReceive_7
    780            }
    781            else
    782            {
    783              /* set fiforxthreshold according the reception data length: 8bit */
    784              SET_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
   \                     ??HAL_SPI_TransmitReceive_6: (+1)
   \   00000096   0x6820             LDR      R0,[R4, #+0]
   \   00000098   0x6842             LDR      R2,[R0, #+4]
   \   0000009A   0xF442 0x5280      ORR      R2,R2,#0x1000
   \                     ??HAL_SPI_TransmitReceive_7: (+1)
   \   0000009E   0x6042             STR      R2,[R0, #+4]
    785            }
    786          
    787            /* Check if the SPI is already enabled */
    788            if((hspi->Instance->CR1 &SPI_CR1_SPE) != SPI_CR1_SPE)
   \   000000A0   0x6820             LDR      R0,[R4, #+0]
   \   000000A2   0x6802             LDR      R2,[R0, #+0]
   \   000000A4   0x0652             LSLS     R2,R2,#+25
   \   000000A6   0xD403             BMI.N    ??HAL_SPI_TransmitReceive_8
    789            {
    790              /* Enable SPI peripheral */
    791              __HAL_SPI_ENABLE(hspi);
   \   000000A8   0x6802             LDR      R2,[R0, #+0]
   \   000000AA   0xF042 0x0240      ORR      R2,R2,#0x40
   \   000000AE   0x6002             STR      R2,[R0, #+0]
    792            }
    793          
    794            /* Transmit and Receive data in 16 Bit mode */
    795            if(hspi->Init.DataSize > SPI_DATASIZE_8BIT)
   \                     ??HAL_SPI_TransmitReceive_8: (+1)
   \   000000B0   0x68E0             LDR      R0,[R4, #+12]
   \   000000B2   0x9E0A             LDR      R6,[SP, #+40]
   \   000000B4   0x4288             CMP      R0,R1
   \   000000B6   0xD341             BCC.N    ??HAL_SPI_TransmitReceive_9
    796            {
    797              while ((hspi->TxXferCount > 0 ) || (hspi->RxXferCount > 0))
   \                     ??HAL_SPI_TransmitReceive_10: (+1)
   \   000000B8   0x88F9             LDRH     R1,[R7, #+6]
   \   000000BA   0xB991             CBNZ.N   R1,??HAL_SPI_TransmitReceive_11
   \   000000BC   0x89F8             LDRH     R0,[R7, #+14]
   \   000000BE   0xBB18             CBNZ.N   R0,??CrossCallReturnLabel_8
    798              {
    799                /* Check TXE flag */
    800                if((hspi->TxXferCount > 0) && ((hspi->Instance->SR & SPI_FLAG_TXE) == SPI_FLAG_TXE))
    801                {
    802                  hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
    803                  hspi->pTxBuffPtr += sizeof(uint16_t);
    804                  hspi->TxXferCount--;
    805          
    806                  /* Enable CRC Transmission */
    807                  if((hspi->TxXferCount == 0) && (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE))
    808                  {
    809                    SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
    810                  } 
    811                }
    812          
    813                /* Check RXNE flag */
    814                if((hspi->RxXferCount > 0) && ((hspi->Instance->SR & SPI_FLAG_RXNE) == SPI_FLAG_RXNE))
    815                {
    816                  *((uint16_t *)hspi->pRxBuffPtr) = hspi->Instance->DR;
    817                  hspi->pRxBuffPtr += sizeof(uint16_t);
    818                  hspi->RxXferCount--;
    819                }
    820                if(Timeout != HAL_MAX_DELAY)
    821                {
    822                  if((Timeout == 0) || ((HAL_GetTick()-tickstart) > Timeout)) 
    823                  {
    824                    hspi->State = HAL_SPI_STATE_READY;
    825                    __HAL_UNLOCK(hspi);
    826                    return HAL_TIMEOUT;
    827                  }
    828                }
    829              }
    830            }
    831            /* Transmit and Receive data in 8 Bit mode */
    832            else
    833            {
    834              while((hspi->TxXferCount > 0) || (hspi->RxXferCount > 0))
    835              {
    836                /* check TXE flag */
    837                if((hspi->TxXferCount > 0) && ((hspi->Instance->SR & SPI_FLAG_TXE) == SPI_FLAG_TXE))
    838                {
    839                  if(hspi->TxXferCount > 1)
    840                  {
    841                    hspi->Instance->DR = *((uint16_t*)hspi->pTxBuffPtr);
    842                    hspi->pTxBuffPtr += sizeof(uint16_t);
    843                    hspi->TxXferCount -= 2;
    844                  }
    845                  else
    846                  {
    847                    *(__IO uint8_t *)&hspi->Instance->DR = (*hspi->pTxBuffPtr++);
    848                    hspi->TxXferCount--;
    849                  }
    850          
    851                  /* Enable CRC Transmission */
    852                  if((hspi->TxXferCount == 0) && (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE))
    853                  {
    854                    SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
    855                  }
    856                }
    857          
    858                /* Wait until RXNE flag is reset */
    859                if((hspi->RxXferCount > 0) && ((hspi->Instance->SR & SPI_FLAG_RXNE) == SPI_FLAG_RXNE))
    860                {
    861                  if(hspi->RxXferCount > 1)
    862                  {
    863                    *((uint16_t*)hspi->pRxBuffPtr) = hspi->Instance->DR;
    864                    hspi->pRxBuffPtr += sizeof(uint16_t);
    865                    hspi->RxXferCount -= 2;
    866                    if(hspi->RxXferCount <= 1)
    867                    {
    868                      /* set fiforxthreshold before to switch on 8 bit data size */
    869                      SET_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
    870                    }
    871                  }
    872                  else
    873                  {
    874                    (*hspi->pRxBuffPtr++) =  *(__IO uint8_t *)&hspi->Instance->DR;
    875                    hspi->RxXferCount--;
    876                  }
    877                }
    878                if(Timeout != HAL_MAX_DELAY)
    879                {
    880                  if((Timeout == 0) || ((HAL_GetTick()-tickstart) > Timeout))
    881                  {
    882                    hspi->State = HAL_SPI_STATE_READY;
    883                    __HAL_UNLOCK(hspi);
    884                    return HAL_TIMEOUT;
    885                  }
    886                }
    887              }
    888            }
    889          
    890            /* Read CRC from DR to close CRC calculation process */
    891            if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   \                     ??HAL_SPI_TransmitReceive_12: (+1)
   \   000000C0   0x.... 0x....      BL       ?Subroutine31
   \                     ??CrossCallReturnLabel_66: (+1)
   \   000000C4   0xF040 0x8097      BNE.W    ??CrossCallReturnLabel_75
    892            {
    893              /* Wait until TXE flag */
    894              if(SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_RXNE, SPI_FLAG_RXNE, Timeout) != HAL_OK)
   \   000000C8   0x4633             MOV      R3,R6
   \   000000CA   0x.... 0x....      BL       ??Subroutine13_0
   \                     ??CrossCallReturnLabel_15: (+1)
   \   000000CE   0x.... 0x....      BL       ?Subroutine26
    895              {
    896                /* Error on the CRC reception */
    897                hspi->ErrorCode|= HAL_SPI_ERROR_CRC;
    898              }
    899          
    900              if(hspi->Init.DataSize == SPI_DATASIZE_16BIT)
   \                     ??CrossCallReturnLabel_48: (+1)
   \   000000D2   0x68E1             LDR      R1,[R4, #+12]
   \   000000D4   0x6820             LDR      R0,[R4, #+0]
   \   000000D6   0xF5B1 0x6F70      CMP      R1,#+3840
   \   000000DA   0xF040 0x8080      BNE.W    ??HAL_SPI_TransmitReceive_13
    901              {
    902                tmpreg = hspi->Instance->DR;
   \   000000DE   0x68C0             LDR      R0,[R0, #+12]
   \   000000E0   0xE087             B.N      ??HAL_SPI_TransmitReceive_14
    903                UNUSED(tmpreg); /* To avoid GCC warning */
    904              }
   \                     ??HAL_SPI_TransmitReceive_11: (+1)
   \   000000E2   0x6820             LDR      R0,[R4, #+0]
   \   000000E4   0x6882             LDR      R2,[R0, #+8]
   \   000000E6   0x0792             LSLS     R2,R2,#+30
   \   000000E8   0xD50E             BPL.N    ??CrossCallReturnLabel_8
   \   000000EA   0x683A             LDR      R2,[R7, #+0]
   \   000000EC   0x1E49             SUBS     R1,R1,#+1
   \   000000EE   0xF832 0x3B02      LDRH     R3,[R2], #+2
   \   000000F2   0x60C3             STR      R3,[R0, #+12]
   \   000000F4   0x80F9             STRH     R1,[R7, #+6]
   \   000000F6   0xB289             UXTH     R1,R1
   \   000000F8   0x2900             CMP      R1,#+0
   \   000000FA   0x603A             STR      R2,[R7, #+0]
   \   000000FC   0xBF04             ITT      EQ 
   \   000000FE   0x6AA1             LDREQ    R1,[R4, #+40]
   \   00000100   0xF5B1 0x5F00      CMPEQ    R1,#+8192
   \   00000104   0x.... 0x....      BL       ?Subroutine11
   \                     ??CrossCallReturnLabel_8: (+1)
   \   00000108   0x89F8             LDRH     R0,[R7, #+14]
   \   0000010A   0xB158             CBZ.N    R0,??HAL_SPI_TransmitReceive_15
   \   0000010C   0x6820             LDR      R0,[R4, #+0]
   \   0000010E   0x6881             LDR      R1,[R0, #+8]
   \   00000110   0x07C9             LSLS     R1,R1,#+31
   \   00000112   0xD507             BPL.N    ??HAL_SPI_TransmitReceive_15
   \   00000114   0x68B9             LDR      R1,[R7, #+8]
   \   00000116   0x68C0             LDR      R0,[R0, #+12]
   \   00000118   0x8008             STRH     R0,[R1, #+0]
   \   0000011A   0x1C88             ADDS     R0,R1,#+2
   \   0000011C   0x60B8             STR      R0,[R7, #+8]
   \   0000011E   0x89F8             LDRH     R0,[R7, #+14]
   \   00000120   0x1E40             SUBS     R0,R0,#+1
   \   00000122   0x81F8             STRH     R0,[R7, #+14]
   \                     ??HAL_SPI_TransmitReceive_15: (+1)
   \   00000124   0xF116 0x0F01      CMN      R6,#+1
   \   00000128   0xD0C6             BEQ.N    ??HAL_SPI_TransmitReceive_10
   \   0000012A   0x2E00             CMP      R6,#+0
   \   0000012C   0xD052             BEQ.N    ??HAL_SPI_TransmitReceive_16
   \   0000012E   0x.... 0x....      BL       HAL_GetTick
   \   00000132   0xEBA0 0x0008      SUB      R0,R0,R8
   \   00000136   0x4286             CMP      R6,R0
   \   00000138   0xD2BE             BCS.N    ??HAL_SPI_TransmitReceive_10
   \   0000013A   0xE04B             B.N      ??HAL_SPI_TransmitReceive_16
   \                     ??HAL_SPI_TransmitReceive_9: (+1)
   \   0000013C   0x88F9             LDRH     R1,[R7, #+6]
   \   0000013E   0xB911             CBNZ.N   R1,??HAL_SPI_TransmitReceive_17
   \   00000140   0x89F8             LDRH     R0,[R7, #+14]
   \   00000142   0xB9F0             CBNZ.N   R0,??CrossCallReturnLabel_9
   \   00000144   0xE7BC             B.N      ??HAL_SPI_TransmitReceive_12
   \                     ??HAL_SPI_TransmitReceive_17: (+1)
   \   00000146   0x6820             LDR      R0,[R4, #+0]
   \   00000148   0x6882             LDR      R2,[R0, #+8]
   \   0000014A   0x0792             LSLS     R2,R2,#+30
   \   0000014C   0xD519             BPL.N    ??CrossCallReturnLabel_9
   \   0000014E   0x2902             CMP      R1,#+2
   \   00000150   0xDB06             BLT.N    ??HAL_SPI_TransmitReceive_18
   \   00000152   0x683A             LDR      R2,[R7, #+0]
   \   00000154   0x1E89             SUBS     R1,R1,#+2
   \   00000156   0xF832 0x3B02      LDRH     R3,[R2], #+2
   \   0000015A   0x60C3             STR      R3,[R0, #+12]
   \   0000015C   0x603A             STR      R2,[R7, #+0]
   \   0000015E   0xE007             B.N      ??HAL_SPI_TransmitReceive_19
   \                     ??HAL_SPI_TransmitReceive_18: (+1)
   \   00000160   0x6839             LDR      R1,[R7, #+0]
   \   00000162   0x1C49             ADDS     R1,R1,#+1
   \   00000164   0x6039             STR      R1,[R7, #+0]
   \   00000166   0x1E49             SUBS     R1,R1,#+1
   \   00000168   0x7809             LDRB     R1,[R1, #+0]
   \   0000016A   0x7301             STRB     R1,[R0, #+12]
   \   0000016C   0x88F9             LDRH     R1,[R7, #+6]
   \   0000016E   0x1E49             SUBS     R1,R1,#+1
   \                     ??HAL_SPI_TransmitReceive_19: (+1)
   \   00000170   0x80F9             STRH     R1,[R7, #+6]
   \   00000172   0x88F9             LDRH     R1,[R7, #+6]
   \   00000174   0x2900             CMP      R1,#+0
   \   00000176   0xBF04             ITT      EQ 
   \   00000178   0x6AA1             LDREQ    R1,[R4, #+40]
   \   0000017A   0xF5B1 0x5F00      CMPEQ    R1,#+8192
   \   0000017E   0x.... 0x....      BL       ?Subroutine11
   \                     ??CrossCallReturnLabel_9: (+1)
   \   00000182   0x89F9             LDRH     R1,[R7, #+14]
   \   00000184   0xB1E1             CBZ.N    R1,??HAL_SPI_TransmitReceive_20
   \   00000186   0x6820             LDR      R0,[R4, #+0]
   \   00000188   0x6882             LDR      R2,[R0, #+8]
   \   0000018A   0x07D2             LSLS     R2,R2,#+31
   \   0000018C   0xD518             BPL.N    ??HAL_SPI_TransmitReceive_20
   \   0000018E   0x2902             CMP      R1,#+2
   \   00000190   0x68BA             LDR      R2,[R7, #+8]
   \   00000192   0xDB0E             BLT.N    ??HAL_SPI_TransmitReceive_21
   \   00000194   0x68C1             LDR      R1,[R0, #+12]
   \   00000196   0x8011             STRH     R1,[R2, #+0]
   \   00000198   0x1C91             ADDS     R1,R2,#+2
   \   0000019A   0x60B9             STR      R1,[R7, #+8]
   \   0000019C   0x89F9             LDRH     R1,[R7, #+14]
   \   0000019E   0x1E89             SUBS     R1,R1,#+2
   \   000001A0   0x81F9             STRH     R1,[R7, #+14]
   \   000001A2   0xB289             UXTH     R1,R1
   \   000001A4   0x2902             CMP      R1,#+2
   \   000001A6   0xDA0B             BGE.N    ??HAL_SPI_TransmitReceive_20
   \   000001A8   0x6841             LDR      R1,[R0, #+4]
   \   000001AA   0xF441 0x5180      ORR      R1,R1,#0x1000
   \   000001AE   0x6041             STR      R1,[R0, #+4]
   \   000001B0   0xE006             B.N      ??HAL_SPI_TransmitReceive_20
   \                     ??HAL_SPI_TransmitReceive_21: (+1)
   \   000001B2   0x1C51             ADDS     R1,R2,#+1
   \   000001B4   0x60B9             STR      R1,[R7, #+8]
   \   000001B6   0x7B00             LDRB     R0,[R0, #+12]
   \   000001B8   0x7010             STRB     R0,[R2, #+0]
   \   000001BA   0x89F8             LDRH     R0,[R7, #+14]
   \   000001BC   0x1E40             SUBS     R0,R0,#+1
   \   000001BE   0x81F8             STRH     R0,[R7, #+14]
   \                     ??HAL_SPI_TransmitReceive_20: (+1)
   \   000001C0   0xF116 0x0F01      CMN      R6,#+1
   \   000001C4   0xD0BA             BEQ.N    ??HAL_SPI_TransmitReceive_9
   \   000001C6   0xB12E             CBZ.N    R6,??HAL_SPI_TransmitReceive_16
   \   000001C8   0x.... 0x....      BL       HAL_GetTick
   \   000001CC   0xEBA0 0x0008      SUB      R0,R0,R8
   \   000001D0   0x4286             CMP      R6,R0
   \   000001D2   0xD2B3             BCS.N    ??HAL_SPI_TransmitReceive_9
   \                     ??HAL_SPI_TransmitReceive_16: (+1)
   \   000001D4   0x2001             MOVS     R0,#+1
   \   000001D6   0x7068             STRB     R0,[R5, #+1]
   \   000001D8   0x2000             MOVS     R0,#+0
   \   000001DA   0x7028             STRB     R0,[R5, #+0]
   \   000001DC   0xE010             B.N      ??HAL_SPI_TransmitReceive_22
    905              else
    906              {
    907                tmpreg = *(__IO uint8_t *)&hspi->Instance->DR;
   \                     ??HAL_SPI_TransmitReceive_13: (+1)
   \   000001DE   0x.... 0x....      BL       ?Subroutine32
    908                UNUSED(tmpreg); /* To avoid GCC warning */
    909          
    910                if(hspi->Init.CRCLength == SPI_CRC_LENGTH_16BIT)
   \                     ??CrossCallReturnLabel_70: (+1)
   \   000001E2   0xD108             BNE.N    ??CrossCallReturnLabel_75
    911                {
    912                  if(SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_RXNE, SPI_FLAG_RXNE, Timeout) != HAL_OK)
   \   000001E4   0x4633             MOV      R3,R6
   \   000001E6   0x.... 0x....      BL       ??Subroutine13_0
   \                     ??CrossCallReturnLabel_14: (+1)
   \   000001EA   0x.... 0x....      BL       ?Subroutine26
    913                  {
    914                    /* Error on the CRC reception */
    915                    hspi->ErrorCode|= HAL_SPI_ERROR_CRC;
    916                  }
    917                  tmpreg = *(__IO uint8_t *)&hspi->Instance->DR;
   \                     ??CrossCallReturnLabel_49: (+1)
   \   000001EE   0x6820             LDR      R0,[R4, #+0]
   \   000001F0   0x7B00             LDRB     R0,[R0, #+12]
    918                  UNUSED(tmpreg); /* To avoid GCC warning */
    919                }
    920              }
    921            }
   \                     ??HAL_SPI_TransmitReceive_14: (+1)
   \   000001F2   0x.... 0x....      BL       ?Subroutine34
    922          
    923            /* Check the end of the transaction */
    924            if(SPI_EndRxTxTransaction(hspi,Timeout) != HAL_OK)
   \                     ??CrossCallReturnLabel_75: (+1)
   \   000001F6   0x4631             MOV      R1,R6
   \   000001F8   0x4620             MOV      R0,R4
   \   000001FA   0x.... 0x....      BL       SPI_EndRxTxTransaction
   \   000001FE   0xB108             CBZ.N    R0,??HAL_SPI_TransmitReceive_23
    925            {
    926              return HAL_TIMEOUT;
   \                     ??HAL_SPI_TransmitReceive_22: (+1)
   \   00000200   0x2003             MOVS     R0,#+3
   \   00000202   0xE015             B.N      ??HAL_SPI_TransmitReceive_3
    927            }
    928          
    929            hspi->State = HAL_SPI_STATE_READY;
   \                     ??HAL_SPI_TransmitReceive_23: (+1)
   \   00000204   0x2001             MOVS     R0,#+1
   \   00000206   0x7068             STRB     R0,[R5, #+1]
    930            
    931            /* Check if CRC error occurred */
    932            if(__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_CRCERR) != RESET)
   \   00000208   0x6821             LDR      R1,[R4, #+0]
   \   0000020A   0x6868             LDR      R0,[R5, #+4]
   \   0000020C   0x688A             LDR      R2,[R1, #+8]
   \   0000020E   0x06D2             LSLS     R2,R2,#+27
   \   00000210   0xD509             BPL.N    ??HAL_SPI_TransmitReceive_24
    933            {
    934              hspi->ErrorCode|= HAL_SPI_ERROR_CRC;
   \   00000212   0xF040 0x0002      ORR      R0,R0,#0x2
   \   00000216   0x6068             STR      R0,[R5, #+4]
    935              /* Clear CRC Flag */
    936              __HAL_SPI_CLEAR_CRCERRFLAG(hspi);
   \   00000218   0xF64F 0x70EF      MOVW     R0,#+65519
   \   0000021C   0x6088             STR      R0,[R1, #+8]
    937              
    938              /* Process Unlocked */
    939              __HAL_UNLOCK(hspi);
   \   0000021E   0x2000             MOVS     R0,#+0
   \   00000220   0x7028             STRB     R0,[R5, #+0]
    940              
    941              return HAL_ERROR;
   \   00000222   0x2001             MOVS     R0,#+1
   \   00000224   0xE004             B.N      ??HAL_SPI_TransmitReceive_3
    942            }
    943            
    944            /* Process Unlocked */
    945            __HAL_UNLOCK(hspi);
   \                     ??HAL_SPI_TransmitReceive_24: (+1)
   \   00000226   0x2100             MOVS     R1,#+0
   \   00000228   0x7029             STRB     R1,[R5, #+0]
    946            
    947            if(hspi->ErrorCode != HAL_SPI_ERROR_NONE)
   \   0000022A   0xB100             CBZ.N    R0,??HAL_SPI_TransmitReceive_25
   \   0000022C   0x2001             MOVS     R0,#+1
   \                     ??HAL_SPI_TransmitReceive_25: (+1)
   \   0000022E   0xB2C0             UXTB     R0,R0
    948            {   
    949              return HAL_ERROR;
    950            }
    951            else
    952            {
    953              return HAL_OK;
   \                     ??HAL_SPI_TransmitReceive_3: (+1)
   \   00000230   0xE8BD 0x87F6      POP      {R1,R2,R4-R10,PC}  ;; return
    954            }
    955          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine26: (+1)
   \   00000000   0xB118             CBZ.N    R0,??Subroutine26_0
   \   00000002   0x6868             LDR      R0,[R5, #+4]
   \   00000004   0xF040 0x0002      ORR      R0,R0,#0x2
   \   00000008   0x6068             STR      R0,[R5, #+4]
   \                     ??Subroutine26_0: (+1)
   \   0000000A   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine11: (+1)
   \   00000000   0xD103             BNE.N    ??Subroutine11_0
   \   00000002   0x6801             LDR      R1,[R0, #+0]
   \   00000004   0xF441 0x5180      ORR      R1,R1,#0x1000
   \   00000008   0x6001             STR      R1,[R0, #+0]
   \                     ??Subroutine11_0: (+1)
   \   0000000A   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine32: (+1)
   \   00000000   0x7B00             LDRB     R0,[R0, #+12]
   \   00000002   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   \   00000006   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   0000000A   0x6B20             LDR      R0,[R4, #+48]
   \   0000000C   0x2802             CMP      R0,#+2
   \   0000000E   0x4770             BX       LR
    956          
    957          /**
    958            * @brief  Transmit an amount of data in no-blocking mode with Interrupt
    959            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
    960            *               the configuration information for SPI module.
    961            * @param  pData: pointer to data buffer
    962            * @param  Size: amount of data to be sent
    963            * @retval HAL status
    964            */

   \                                 In section .text, align 2, keep-with-next
    965          HAL_StatusTypeDef HAL_SPI_Transmit_IT(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size)
    966          {
    967            assert_param(IS_SPI_DIRECTION_2LINES_OR_1LINE(hspi->Init.Direction));
    968            
    969            if(hspi->State == HAL_SPI_STATE_READY)
   \                     HAL_SPI_Transmit_IT: (+1)
   \   00000000   0xF100 0x0344      ADD      R3,R0,#+68
   \   00000004   0xB510             PUSH     {R4,LR}
   \   00000006   0x7E5C             LDRB     R4,[R3, #+25]
   \   00000008   0x2C01             CMP      R4,#+1
   \   0000000A   0xD12C             BNE.N    ??HAL_SPI_Transmit_IT_0
    970            {
    971              if((pData == NULL) || (Size == 0)) 
   \   0000000C   0x2900             CMP      R1,#+0
   \   0000000E   0xBF18             IT       NE 
   \   00000010   0x2A00             CMPNE    R2,#+0
   \   00000012   0xD101             BNE.N    ??HAL_SPI_Transmit_IT_1
    972              {
    973                return  HAL_ERROR;                                    
   \   00000014   0x2001             MOVS     R0,#+1
   \   00000016   0xBD10             POP      {R4,PC}
    974              }
    975              
    976              /* Process Locked */
    977              __HAL_LOCK(hspi);
   \                     ??HAL_SPI_Transmit_IT_1: (+1)
   \   00000018   0x7E1C             LDRB     R4,[R3, #+24]
   \   0000001A   0x2C01             CMP      R4,#+1
   \   0000001C   0xD023             BEQ.N    ??HAL_SPI_Transmit_IT_0
   \   0000001E   0x2401             MOVS     R4,#+1
   \   00000020   0x761C             STRB     R4,[R3, #+24]
    978              
    979              hspi->State       = HAL_SPI_STATE_BUSY_TX;
   \   00000022   0x2403             MOVS     R4,#+3
   \   00000024   0x765C             STRB     R4,[R3, #+25]
    980              hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
   \   00000026   0x2400             MOVS     R4,#+0
   \   00000028   0x61DC             STR      R4,[R3, #+28]
    981              hspi->pTxBuffPtr  = pData;
   \   0000002A   0x6381             STR      R1,[R0, #+56]
    982              hspi->TxXferSize  = Size;
   \   0000002C   0x8782             STRH     R2,[R0, #+60]
    983              hspi->TxXferCount = Size;
   \   0000002E   0x87C2             STRH     R2,[R0, #+62]
    984              hspi->pRxBuffPtr  = NULL;
   \   00000030   0x6404             STR      R4,[R0, #+64]
    985              hspi->RxXferSize  = 0;
   \   00000032   0x801C             STRH     R4,[R3, #+0]
    986              hspi->RxXferCount = 0;
   \   00000034   0x805C             STRH     R4,[R3, #+2]
    987          
    988              /* Set the function for IT treatement */
    989              if(hspi->Init.DataSize > SPI_DATASIZE_8BIT )
   \   00000036   0x68C1             LDR      R1,[R0, #+12]
   \   00000038   0xF5B1 0x6FE0      CMP      R1,#+1792
   \   0000003C   0xBF8C             ITE      HI 
   \   0000003E   0x.... 0x....      ADRHI.W  R1,SPI_TxISR_16BIT
   \   00000042   0x.... 0x....      ADRLS.W  R1,SPI_TxISR_8BIT
    990              {
    991                hspi->RxISR = NULL;
    992                hspi->TxISR = SPI_TxISR_16BIT;
    993              }
    994              else
    995              {
    996                hspi->RxISR = NULL;
    997                hspi->TxISR = SPI_TxISR_8BIT;
   \   00000046   0x60D9             STR      R1,[R3, #+12]
   \   00000048   0x609C             STR      R4,[R3, #+8]
    998              }
    999              
   1000              /* Configure communication direction : 1Line */
   1001              if(hspi->Init.Direction == SPI_DIRECTION_1LINE)
   \   0000004A   0x6882             LDR      R2,[R0, #+8]
   \   0000004C   0x6801             LDR      R1,[R0, #+0]
   \   0000004E   0xF5B2 0x4F00      CMP      R2,#+32768
   \   00000052   0xD103             BNE.N    ??HAL_SPI_Transmit_IT_2
   1002              {
   1003                SPI_1LINE_TX(hspi);
   \   00000054   0x680A             LDR      R2,[R1, #+0]
   \   00000056   0xF442 0x4280      ORR      R2,R2,#0x4000
   \   0000005A   0x600A             STR      R2,[R1, #+0]
   1004              }
   1005              
   1006              /* Reset CRC Calculation */
   1007              if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   \                     ??HAL_SPI_Transmit_IT_2: (+1)
   \   0000005C   0x.... 0x....      BL       ?Subroutine8
   1008              {
   1009                SPI_RESET_CRC(hspi);    
   1010              }
   1011              
   1012              /* Enable TXE and ERR interrupt */
   1013              __HAL_SPI_ENABLE_IT(hspi,(SPI_IT_TXE));
   1014          
   1015              /* Process Unlocked */
   1016              __HAL_UNLOCK(hspi);
   1017          
   1018              /* Note : The SPI must be enabled after unlocking current process 
   1019                        to avoid the risk of SPI interrupt handle execution before current
   1020                        process unlock */
   1021                  
   1022              /* Check if the SPI is already enabled */ 
   1023              if((hspi->Instance->CR1 &SPI_CR1_SPE) != SPI_CR1_SPE)
   1024              {
   1025                /* Enable SPI peripheral */    
   1026                __HAL_SPI_ENABLE(hspi);
   1027              }
   1028                  
   1029              return HAL_OK;
   1030            }
   \                     ??CrossCallReturnLabel_0: (+1)
   \   00000060   0xF040 0x0080      ORR      R0,R0,#0x80
   \   00000064   0x....             B.N      ?Subroutine0
   1031            else
   1032            {
   1033              return HAL_BUSY;
   \                     ??HAL_SPI_Transmit_IT_0: (+1)
   \   00000066   0x2002             MOVS     R0,#+2
   \   00000068   0xBD10             POP      {R4,PC}          ;; return
   1034            }
   1035          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine8: (+1)
   \   00000000   0x6A80             LDR      R0,[R0, #+40]
   \                     ??Subroutine8_0: (+1)
   \   00000002   0xF5B0 0x5F00      CMP      R0,#+8192
   \   00000006   0xD108             BNE.N    ??Subroutine8_1
   \   00000008   0x6808             LDR      R0,[R1, #+0]
   \   0000000A   0xF64D 0x72FF      MOVW     R2,#+57343
   \   0000000E   0x4010             ANDS     R0,R2,R0
   \   00000010   0x6008             STR      R0,[R1, #+0]
   \   00000012   0x6808             LDR      R0,[R1, #+0]
   \   00000014   0xF440 0x5000      ORR      R0,R0,#0x2000
   \   00000018   0x6008             STR      R0,[R1, #+0]
   \                     ??Subroutine8_1: (+1)
   \   0000001A   0x6848             LDR      R0,[R1, #+4]
   \   0000001C   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \   00000000   0x6048             STR      R0,[R1, #+4]
   \   00000002   0x761C             STRB     R4,[R3, #+24]
   \   00000004   0x.... 0x....      BL       ?Subroutine23
   \                     ??CrossCallReturnLabel_42: (+1)
   \   00000008   0xBD10             POP      {R4,PC}

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine23: (+1)
   \   00000000   0x6808             LDR      R0,[R1, #+0]
   \   00000002   0x0640             LSLS     R0,R0,#+25
   \   00000004   0xD403             BMI.N    ??Subroutine23_0
   \   00000006   0x6808             LDR      R0,[R1, #+0]
   \   00000008   0xF040 0x0040      ORR      R0,R0,#0x40
   \   0000000C   0x6008             STR      R0,[R1, #+0]
   \                     ??Subroutine23_0: (+1)
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0x4770             BX       LR
   1036          
   1037          /**
   1038            * @brief  Receive an amount of data in no-blocking mode with Interrupt
   1039            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   1040            *               the configuration information for SPI module.
   1041            * @param  pData: pointer to data buffer
   1042            * @param  Size: amount of data to be sent
   1043            * @retval HAL status
   1044            */

   \                                 In section .text, align 2, keep-with-next
   1045          HAL_StatusTypeDef HAL_SPI_Receive_IT(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size)
   1046          {
   1047            if(hspi->State == HAL_SPI_STATE_READY)
   \                     HAL_SPI_Receive_IT: (+1)
   \   00000000   0xF100 0x0344      ADD      R3,R0,#+68
   \   00000004   0xB510             PUSH     {R4,LR}
   \   00000006   0x7E5C             LDRB     R4,[R3, #+25]
   \   00000008   0x2C01             CMP      R4,#+1
   \   0000000A   0xD152             BNE.N    ??HAL_SPI_Receive_IT_0
   1048            {
   1049              if((pData == NULL) || (Size == 0))
   \   0000000C   0x2900             CMP      R1,#+0
   \   0000000E   0xBF18             IT       NE 
   \   00000010   0x2A00             CMPNE    R2,#+0
   \   00000012   0xD101             BNE.N    ??HAL_SPI_Receive_IT_1
   1050              { 
   1051                return  HAL_ERROR;                      
   \   00000014   0x2001             MOVS     R0,#+1
   \   00000016   0xBD10             POP      {R4,PC}
   1052              }
   1053          
   1054              /* Process Locked */
   1055              __HAL_LOCK(hspi);
   \                     ??HAL_SPI_Receive_IT_1: (+1)
   \   00000018   0x7E1C             LDRB     R4,[R3, #+24]
   \   0000001A   0x2C01             CMP      R4,#+1
   \   0000001C   0xD049             BEQ.N    ??HAL_SPI_Receive_IT_0
   \   0000001E   0x2401             MOVS     R4,#+1
   \   00000020   0x761C             STRB     R4,[R3, #+24]
   1056              
   1057              /* Configure communication */
   1058              hspi->State       = HAL_SPI_STATE_BUSY_RX;
   \   00000022   0x2404             MOVS     R4,#+4
   \   00000024   0x765C             STRB     R4,[R3, #+25]
   1059              hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
   \   00000026   0x2400             MOVS     R4,#+0
   \   00000028   0x61DC             STR      R4,[R3, #+28]
   1060              hspi->pRxBuffPtr  = pData;
   \   0000002A   0x6401             STR      R1,[R0, #+64]
   1061              hspi->RxXferSize  = Size;
   \   0000002C   0x801A             STRH     R2,[R3, #+0]
   1062              hspi->RxXferCount = Size;
   \   0000002E   0x805A             STRH     R2,[R3, #+2]
   1063              hspi->pTxBuffPtr  = NULL;
   \   00000030   0x6384             STR      R4,[R0, #+56]
   1064              hspi->TxXferSize  = 0;
   \   00000032   0x8784             STRH     R4,[R0, #+60]
   1065              hspi->TxXferCount = 0;
   \   00000034   0x87C4             STRH     R4,[R0, #+62]
   1066          
   1067              if((hspi->Init.Mode == SPI_MODE_MASTER) && (hspi->Init.Direction == SPI_DIRECTION_2LINES))
   \   00000036   0x6844             LDR      R4,[R0, #+4]
   \   00000038   0xF5B4 0x7F82      CMP      R4,#+260
   \   0000003C   0xBF04             ITT      EQ 
   \   0000003E   0x6884             LDREQ    R4,[R0, #+8]
   \   00000040   0x2C00             CMPEQ    R4,#+0
   \   00000042   0xD105             BNE.N    ??HAL_SPI_Receive_IT_2
   1068              {
   1069                /* Process Unlocked */
   1070                __HAL_UNLOCK(hspi);
   \   00000044   0x761C             STRB     R4,[R3, #+24]
   1071                /* the receive process is not supported in 2Lines direction master mode */
   1072                /* in this we call the transmitReceive process          */
   1073                return HAL_SPI_TransmitReceive_IT(hspi,pData,pData,Size);
   \   00000046   0x4613             MOV      R3,R2
   \   00000048   0x460A             MOV      R2,R1
   \   0000004A   0xE8BD 0x4010      POP      {R4,LR}
   \   0000004E   0x....             B.N      HAL_SPI_TransmitReceive_IT
   1074              }
   1075                  
   1076              if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   \                     ??HAL_SPI_Receive_IT_2: (+1)
   \   00000050   0x6A81             LDR      R1,[R0, #+40]
   \   00000052   0xF240 0x7201      MOVW     R2,#+1793
   \   00000056   0xF5B1 0x5F00      CMP      R1,#+8192
   \   0000005A   0xD108             BNE.N    ??HAL_SPI_Receive_IT_3
   1077              {
   1078                hspi->CRCSize = 1;
   \   0000005C   0x2101             MOVS     R1,#+1
   \   0000005E   0x6059             STR      R1,[R3, #+4]
   1079                if((hspi->Init.DataSize <= SPI_DATASIZE_8BIT) && (hspi->Init.CRCLength == SPI_CRC_LENGTH_16BIT))
   \   00000060   0x68C1             LDR      R1,[R0, #+12]
   \   00000062   0x4291             CMP      R1,R2
   \   00000064   0xD205             BCS.N    ??HAL_SPI_Receive_IT_4
   \   00000066   0x6B01             LDR      R1,[R0, #+48]
   \   00000068   0x2902             CMP      R1,#+2
   \   0000006A   0xD102             BNE.N    ??HAL_SPI_Receive_IT_4
   1080                {
   1081                  hspi->CRCSize = 2;
   \   0000006C   0xE000             B.N      ??HAL_SPI_Receive_IT_5
   1082                }
   1083              }
   1084              else
   1085              {
   1086                hspi->CRCSize = 0;
   \                     ??HAL_SPI_Receive_IT_3: (+1)
   \   0000006E   0x2100             MOVS     R1,#+0
   \                     ??HAL_SPI_Receive_IT_5: (+1)
   \   00000070   0x6059             STR      R1,[R3, #+4]
   1087              }
   1088                  
   1089              /* check the data size to adapt Rx threshold and the set the function for IT treatment */
   1090              if(hspi->Init.DataSize > SPI_DATASIZE_8BIT )
   \                     ??HAL_SPI_Receive_IT_4: (+1)
   \   00000072   0x6801             LDR      R1,[R0, #+0]
   \   00000074   0x68C4             LDR      R4,[R0, #+12]
   \   00000076   0x4294             CMP      R4,R2
   \   00000078   0x684A             LDR      R2,[R1, #+4]
   \   0000007A   0xD305             BCC.N    ??HAL_SPI_Receive_IT_6
   1091              {
   1092                /* set fiforxthreshold according the reception data length: 16 bit */
   1093                CLEAR_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
   \   0000007C   0xF422 0x5280      BIC      R2,R2,#0x1000
   \   00000080   0x604A             STR      R2,[R1, #+4]
   1094                hspi->RxISR = SPI_RxISR_16BIT;
   \   00000082   0x.... 0x....      ADR.W    R2,SPI_RxISR_16BIT
   1095                hspi->TxISR = NULL;
   \   00000086   0xE004             B.N      ??HAL_SPI_Receive_IT_7
   1096              }
   1097              else
   1098              {
   1099                /* set fiforxthreshold according the reception data length: 8 bit */
   1100                SET_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
   \                     ??HAL_SPI_Receive_IT_6: (+1)
   \   00000088   0xF442 0x5280      ORR      R2,R2,#0x1000
   \   0000008C   0x604A             STR      R2,[R1, #+4]
   1101                hspi->RxISR = SPI_RxISR_8BIT;
   \   0000008E   0x.... 0x....      ADR.W    R2,SPI_RxISR_8BIT
   1102                hspi->TxISR = NULL;
   \                     ??HAL_SPI_Receive_IT_7: (+1)
   \   00000092   0x2400             MOVS     R4,#+0
   \   00000094   0x609A             STR      R2,[R3, #+8]
   \   00000096   0x60DC             STR      R4,[R3, #+12]
   1103              }
   1104              
   1105              /* Configure communication direction : 1Line */
   1106              if(hspi->Init.Direction == SPI_DIRECTION_1LINE)
   \   00000098   0x6882             LDR      R2,[R0, #+8]
   \   0000009A   0xF5B2 0x4F00      CMP      R2,#+32768
   \   0000009E   0xD103             BNE.N    ??HAL_SPI_Receive_IT_8
   1107              {
   1108                SPI_1LINE_RX(hspi);
   \   000000A0   0x680A             LDR      R2,[R1, #+0]
   \   000000A2   0xF422 0x4280      BIC      R2,R2,#0x4000
   \   000000A6   0x600A             STR      R2,[R1, #+0]
   1109              }
   1110              
   1111              /* Reset CRC Calculation */
   1112              if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   \                     ??HAL_SPI_Receive_IT_8: (+1)
   \   000000A8   0x.... 0x....      BL       ?Subroutine8
   1113              {
   1114                SPI_RESET_CRC(hspi);
   1115              }
   1116              
   1117              /* Enable TXE and ERR interrupt */
   1118              __HAL_SPI_ENABLE_IT(hspi, (SPI_IT_RXNE | SPI_IT_ERR));
   1119              
   1120              /* Process Unlocked */
   1121              __HAL_UNLOCK(hspi);
   1122              
   1123              /* Note : The SPI must be enabled after unlocking current process 
   1124              to avoid the risk of SPI interrupt handle execution before current
   1125              process unlock */
   1126              
   1127              /* Check if the SPI is already enabled */ 
   1128              if((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
   1129              {
   1130                /* Enable SPI peripheral */    
   1131                __HAL_SPI_ENABLE(hspi);
   1132              }
   1133              
   1134              return HAL_OK;
   1135            }
   \                     ??CrossCallReturnLabel_1: (+1)
   \   000000AC   0xF040 0x0060      ORR      R0,R0,#0x60
   \   000000B0   0x....             B.N      ?Subroutine0
   1136            else
   1137            {
   1138              return HAL_BUSY; 
   \                     ??HAL_SPI_Receive_IT_0: (+1)
   \   000000B2   0x2002             MOVS     R0,#+2
   \   000000B4   0xBD10             POP      {R4,PC}          ;; return
   1139            }
   1140          }
   1141          
   1142          /**
   1143            * @brief  Transmit and Receive an amount of data in no-blocking mode with Interrupt
   1144            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   1145            *               the configuration information for SPI module.
   1146            * @param  pTxData: pointer to transmission data buffer
   1147            * @param  pRxData: pointer to reception data buffer
   1148            * @param  Size: amount of data to be sent and received
   1149            * @retval HAL status
   1150            */

   \                                 In section .text, align 2, keep-with-next
   1151          HAL_StatusTypeDef HAL_SPI_TransmitReceive_IT(SPI_HandleTypeDef *hspi, uint8_t *pTxData, uint8_t *pRxData, uint16_t Size)
   1152          {
   \                     HAL_SPI_TransmitReceive_IT: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   1153            assert_param(IS_SPI_DIRECTION_2LINES(hspi->Init.Direction));
   1154            
   1155            if((hspi->State == HAL_SPI_STATE_READY) || \
   1156               ((hspi->Init.Mode == SPI_MODE_MASTER) && (hspi->Init.Direction == SPI_DIRECTION_2LINES) && (hspi->State == HAL_SPI_STATE_BUSY_RX)))
   \   00000002   0xF100 0x0444      ADD      R4,R0,#+68
   \   00000006   0x7E65             LDRB     R5,[R4, #+25]
   \   00000008   0x2D01             CMP      R5,#+1
   \   0000000A   0xD007             BEQ.N    ??HAL_SPI_TransmitReceive_IT_0
   \   0000000C   0x6846             LDR      R6,[R0, #+4]
   \   0000000E   0xF5B6 0x7F82      CMP      R6,#+260
   \   00000012   0xBF02             ITTT     EQ 
   \   00000014   0x6886             LDREQ    R6,[R0, #+8]
   \   00000016   0x2E00             CMPEQ    R6,#+0
   \   00000018   0x2D04             CMPEQ    R5,#+4
   \   0000001A   0xD15C             BNE.N    ??HAL_SPI_TransmitReceive_IT_1
   1157            {
   1158              if((pTxData == NULL ) || (pRxData == NULL ) || (Size == 0)) 
   \                     ??HAL_SPI_TransmitReceive_IT_0: (+1)
   \   0000001C   0x2900             CMP      R1,#+0
   \   0000001E   0xBF18             IT       NE 
   \   00000020   0x2A00             CMPNE    R2,#+0
   \   00000022   0xD000             BEQ.N    ??HAL_SPI_TransmitReceive_IT_2
   \   00000024   0xB90B             CBNZ.N   R3,??HAL_SPI_TransmitReceive_IT_3
   1159              {
   1160                return  HAL_ERROR;                                    
   \                     ??HAL_SPI_TransmitReceive_IT_2: (+1)
   \   00000026   0x2001             MOVS     R0,#+1
   \   00000028   0xBDF0             POP      {R4-R7,PC}
   1161              }
   1162              
   1163              /* Process locked */
   1164              __HAL_LOCK(hspi);
   \                     ??HAL_SPI_TransmitReceive_IT_3: (+1)
   \   0000002A   0x7E26             LDRB     R6,[R4, #+24]
   \   0000002C   0x2E01             CMP      R6,#+1
   \   0000002E   0xD052             BEQ.N    ??HAL_SPI_TransmitReceive_IT_1
   \   00000030   0x2601             MOVS     R6,#+1
   \   00000032   0x7626             STRB     R6,[R4, #+24]
   1165              
   1166              hspi->CRCSize = 0;
   \   00000034   0x2600             MOVS     R6,#+0
   \   00000036   0x6066             STR      R6,[R4, #+4]
   1167              if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   \   00000038   0x6A87             LDR      R7,[R0, #+40]
   \   0000003A   0xF240 0x7601      MOVW     R6,#+1793
   \   0000003E   0xF5B7 0x5F00      CMP      R7,#+8192
   \   00000042   0xD108             BNE.N    ??HAL_SPI_TransmitReceive_IT_4
   1168              {
   1169                hspi->CRCSize = 1;
   \   00000044   0x2701             MOVS     R7,#+1
   \   00000046   0x6067             STR      R7,[R4, #+4]
   1170                if((hspi->Init.DataSize <= SPI_DATASIZE_8BIT) && (hspi->Init.CRCLength == SPI_CRC_LENGTH_16BIT))
   \   00000048   0x68C7             LDR      R7,[R0, #+12]
   \   0000004A   0x42B7             CMP      R7,R6
   \   0000004C   0xD203             BCS.N    ??HAL_SPI_TransmitReceive_IT_4
   \   0000004E   0x6B07             LDR      R7,[R0, #+48]
   \   00000050   0x2F02             CMP      R7,#+2
   \   00000052   0xBF08             IT       EQ 
   \   00000054   0x6067             STREQ    R7,[R4, #+4]
   1171                {
   1172                  hspi->CRCSize = 2;
   1173                }
   1174              }
   1175              
   1176              if(hspi->State != HAL_SPI_STATE_BUSY_RX)
   \                     ??HAL_SPI_TransmitReceive_IT_4: (+1)
   \   00000056   0x2D04             CMP      R5,#+4
   \   00000058   0xBF1C             ITT      NE 
   \   0000005A   0x2505             MOVNE    R5,#+5
   \   0000005C   0x7665             STRBNE   R5,[R4, #+25]
   1177              {
   1178                hspi->State = HAL_SPI_STATE_BUSY_TX_RX;
   1179              }
   1180              
   1181              hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
   \   0000005E   0x2500             MOVS     R5,#+0
   \   00000060   0x61E5             STR      R5,[R4, #+28]
   1182              hspi->pTxBuffPtr  = pTxData;
   \   00000062   0x6381             STR      R1,[R0, #+56]
   1183              hspi->TxXferSize  = Size;
   \   00000064   0x8783             STRH     R3,[R0, #+60]
   1184              hspi->TxXferCount = Size;
   \   00000066   0x87C3             STRH     R3,[R0, #+62]
   1185              hspi->pRxBuffPtr  = pRxData;
   \   00000068   0x6402             STR      R2,[R0, #+64]
   1186              hspi->RxXferSize  = Size;
   \   0000006A   0x8023             STRH     R3,[R4, #+0]
   1187              hspi->RxXferCount = Size;
   \   0000006C   0x8063             STRH     R3,[R4, #+2]
   1188              
   1189              /* Set the function for IT treatement */
   1190              if(hspi->Init.DataSize > SPI_DATASIZE_8BIT )
   \   0000006E   0x68C1             LDR      R1,[R0, #+12]
   \   00000070   0x42B1             CMP      R1,R6
   \   00000072   0xBF27             ITTEE    CS 
   \   00000074   0x.... 0x....      ADRCS.W  R1,SPI_2linesRxISR_16BIT
   \   00000078   0x.... 0x....      ADRCS.W  R2,SPI_2linesTxISR_16BIT
   \   0000007C   0x.... 0x....      ADRCC.W  R1,SPI_2linesRxISR_8BIT
   \   00000080   0x.... 0x....      ADRCC.W  R2,SPI_2linesTxISR_8BIT
   1191              {
   1192                hspi->RxISR = SPI_2linesRxISR_16BIT;
   1193                hspi->TxISR = SPI_2linesTxISR_16BIT;       
   1194              }
   1195              else
   1196              {
   1197                hspi->RxISR = SPI_2linesRxISR_8BIT;
   1198                hspi->TxISR = SPI_2linesTxISR_8BIT;
   \   00000084   0x60E2             STR      R2,[R4, #+12]
   \   00000086   0x60A1             STR      R1,[R4, #+8]
   1199              }
   1200              
   1201              /* Reset CRC Calculation */
   1202              if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   \   00000088   0x6A81             LDR      R1,[R0, #+40]
   \   0000008A   0xF5B1 0x5F00      CMP      R1,#+8192
   \   0000008E   0xD109             BNE.N    ??HAL_SPI_TransmitReceive_IT_5
   1203              {
   1204                SPI_RESET_CRC(hspi);
   \   00000090   0x6801             LDR      R1,[R0, #+0]
   \   00000092   0xF64D 0x73FF      MOVW     R3,#+57343
   \   00000096   0x680A             LDR      R2,[R1, #+0]
   \   00000098   0x401A             ANDS     R2,R3,R2
   \   0000009A   0x600A             STR      R2,[R1, #+0]
   \   0000009C   0x680A             LDR      R2,[R1, #+0]
   \   0000009E   0xF442 0x5200      ORR      R2,R2,#0x2000
   \   000000A2   0x600A             STR      R2,[R1, #+0]
   1205              }
   1206              
   1207              /* check if packing mode is enabled and if there is more than 2 data to receive */
   1208              if((hspi->Init.DataSize > SPI_DATASIZE_8BIT) || (hspi->RxXferCount >= 2))
   \                     ??HAL_SPI_TransmitReceive_IT_5: (+1)
   \   000000A4   0x68C1             LDR      R1,[R0, #+12]
   \   000000A6   0x42B1             CMP      R1,R6
   \   000000A8   0xD202             BCS.N    ??HAL_SPI_TransmitReceive_IT_6
   \   000000AA   0x8861             LDRH     R1,[R4, #+2]
   \   000000AC   0x2902             CMP      R1,#+2
   \   000000AE   0xDB04             BLT.N    ??HAL_SPI_TransmitReceive_IT_7
   1209              {
   1210                /* set fiforxthreshold according the reception data length: 16 bit */
   1211                CLEAR_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
   \                     ??HAL_SPI_TransmitReceive_IT_6: (+1)
   \   000000B0   0x6801             LDR      R1,[R0, #+0]
   \   000000B2   0x684A             LDR      R2,[R1, #+4]
   \   000000B4   0xF422 0x5280      BIC      R2,R2,#0x1000
   \   000000B8   0xE003             B.N      ??HAL_SPI_TransmitReceive_IT_8
   1212              }
   1213              else
   1214              {
   1215                /* set fiforxthreshold according the reception data length: 8 bit */
   1216                SET_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
   \                     ??HAL_SPI_TransmitReceive_IT_7: (+1)
   \   000000BA   0x6801             LDR      R1,[R0, #+0]
   \   000000BC   0x684A             LDR      R2,[R1, #+4]
   \   000000BE   0xF442 0x5280      ORR      R2,R2,#0x1000
   \                     ??HAL_SPI_TransmitReceive_IT_8: (+1)
   \   000000C2   0x604A             STR      R2,[R1, #+4]
   1217              }
   1218              
   1219              /* Enable TXE, RXNE and ERR interrupt */
   1220              __HAL_SPI_ENABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_RXNE | SPI_IT_ERR));
   \   000000C4   0x6801             LDR      R1,[R0, #+0]
   \   000000C6   0x6848             LDR      R0,[R1, #+4]
   \   000000C8   0xF040 0x00E0      ORR      R0,R0,#0xE0
   \   000000CC   0x6048             STR      R0,[R1, #+4]
   1221              
   1222              /* Process Unlocked */
   1223              __HAL_UNLOCK(hspi);
   \   000000CE   0x7625             STRB     R5,[R4, #+24]
   1224              
   1225              /* Check if the SPI is already enabled */ 
   1226              if((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
   \   000000D0   0x.... 0x....      BL       ?Subroutine23
   1227              {
   1228                /* Enable SPI peripheral */    
   1229                __HAL_SPI_ENABLE(hspi);
   1230              }
   1231              
   1232              return HAL_OK;
   1233            }
   \                     ??CrossCallReturnLabel_43: (+1)
   \   000000D4   0xBDF0             POP      {R4-R7,PC}
   1234            else
   1235            {
   1236              return HAL_BUSY;
   \                     ??HAL_SPI_TransmitReceive_IT_1: (+1)
   \   000000D6   0x2002             MOVS     R0,#+2
   \   000000D8   0xBDF0             POP      {R4-R7,PC}       ;; return
   1237            }
   1238          }
   1239          
   1240          /**
   1241            * @brief  Transmit an amount of data in no-blocking mode with DMA
   1242            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   1243            *               the configuration information for SPI module.
   1244            * @param  pData: pointer to data buffer
   1245            * @param  Size: amount of data to be sent
   1246            * @retval HAL status
   1247            */

   \                                 In section .text, align 2, keep-with-next
   1248          HAL_StatusTypeDef HAL_SPI_Transmit_DMA(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size)
   1249          {    
   \                     HAL_SPI_Transmit_DMA: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4605             MOV      R5,R0
   1250            assert_param(IS_SPI_DIRECTION_2LINES_OR_1LINE(hspi->Init.Direction));
   1251          
   1252            if(hspi->State != HAL_SPI_STATE_READY) 
   \   00000004   0xF105 0x0444      ADD      R4,R5,#+68
   \   00000008   0x7E60             LDRB     R0,[R4, #+25]
   \   0000000A   0x2801             CMP      R0,#+1
   \   0000000C   0xD106             BNE.N    ??HAL_SPI_Transmit_DMA_0
   1253            {
   1254              return HAL_BUSY;
   1255            }
   1256            
   1257            if((pData == NULL) || (Size == 0))
   \   0000000E   0x2900             CMP      R1,#+0
   \   00000010   0xBF18             IT       NE 
   \   00000012   0x2A00             CMPNE    R2,#+0
   \   00000014   0xD056             BEQ.N    ??HAL_SPI_Transmit_DMA_1
   1258            {
   1259              return HAL_ERROR;
   1260            }
   1261            
   1262            /* Process Locked */
   1263            __HAL_LOCK(hspi);
   \   00000016   0x7E20             LDRB     R0,[R4, #+24]
   \   00000018   0x2801             CMP      R0,#+1
   \   0000001A   0xD101             BNE.N    ??HAL_SPI_Transmit_DMA_2
   \                     ??HAL_SPI_Transmit_DMA_0: (+1)
   \   0000001C   0x2002             MOVS     R0,#+2
   \   0000001E   0xBD32             POP      {R1,R4,R5,PC}
   \                     ??HAL_SPI_Transmit_DMA_2: (+1)
   \   00000020   0x2001             MOVS     R0,#+1
   \   00000022   0x7620             STRB     R0,[R4, #+24]
   1264            
   1265            hspi->State       = HAL_SPI_STATE_BUSY_TX;
   \   00000024   0x2003             MOVS     R0,#+3
   \   00000026   0x7660             STRB     R0,[R4, #+25]
   1266            hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0x61E0             STR      R0,[R4, #+28]
   1267            hspi->pTxBuffPtr  = pData;
   \   0000002C   0x63A9             STR      R1,[R5, #+56]
   1268            hspi->TxXferSize  = Size;
   \   0000002E   0x87AA             STRH     R2,[R5, #+60]
   1269            hspi->TxXferCount = Size;
   \   00000030   0x87EA             STRH     R2,[R5, #+62]
   1270            hspi->pRxBuffPtr  = (uint8_t *)NULL;
   \   00000032   0x6428             STR      R0,[R5, #+64]
   1271            hspi->RxXferSize  = 0;
   \   00000034   0x8020             STRH     R0,[R4, #+0]
   1272            hspi->RxXferCount = 0;
   \   00000036   0x8060             STRH     R0,[R4, #+2]
   1273            
   1274            /* Configure communication direction : 1Line */
   1275            if(hspi->Init.Direction == SPI_DIRECTION_1LINE)
   \   00000038   0x68A8             LDR      R0,[R5, #+8]
   \   0000003A   0x682A             LDR      R2,[R5, #+0]
   \   0000003C   0xF5B0 0x4F00      CMP      R0,#+32768
   \   00000040   0xD103             BNE.N    ??HAL_SPI_Transmit_DMA_3
   1276            {
   1277              SPI_1LINE_TX(hspi);
   \   00000042   0x6810             LDR      R0,[R2, #+0]
   \   00000044   0xF440 0x4080      ORR      R0,R0,#0x4000
   \   00000048   0x6010             STR      R0,[R2, #+0]
   1278            }
   1279            
   1280            /* Reset CRC Calculation */
   1281            if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   \                     ??HAL_SPI_Transmit_DMA_3: (+1)
   \   0000004A   0x6AA8             LDR      R0,[R5, #+40]
   \   0000004C   0xF5B0 0x5F00      CMP      R0,#+8192
   \   00000050   0xD108             BNE.N    ??HAL_SPI_Transmit_DMA_4
   1282            {
   1283              SPI_RESET_CRC(hspi);
   \   00000052   0x6810             LDR      R0,[R2, #+0]
   \   00000054   0xF64D 0x71FF      MOVW     R1,#+57343
   \   00000058   0x4008             ANDS     R0,R1,R0
   \   0000005A   0x6010             STR      R0,[R2, #+0]
   \   0000005C   0x6810             LDR      R0,[R2, #+0]
   \   0000005E   0xF440 0x5000      ORR      R0,R0,#0x2000
   \   00000062   0x6010             STR      R0,[R2, #+0]
   1284            }
   1285            
   1286            /* Set the SPI TxDMA Half transfer complete callback */
   1287            hspi->hdmatx->XferHalfCpltCallback = SPI_DMAHalfTransmitCplt;
   \                     ??HAL_SPI_Transmit_DMA_4: (+1)
   \   00000064   0x6920             LDR      R0,[R4, #+16]
   \   00000066   0x.... 0x....      ADR.W    R1,SPI_DMAHalfTransmitCplt
   \   0000006A   0x6401             STR      R1,[R0, #+64]
   1288            
   1289            /* Set the SPI TxDMA transfer complete callback */
   1290            hspi->hdmatx->XferCpltCallback = SPI_DMATransmitCplt;
   \   0000006C   0x.... 0x....      ADR.W    R1,SPI_DMATransmitCplt
   \   00000070   0x63C1             STR      R1,[R0, #+60]
   1291            
   1292            /* Set the DMA error callback */
   1293            hspi->hdmatx->XferErrorCallback = SPI_DMAError;
   \   00000072   0x.... 0x....      ADR.W    R1,SPI_DMAError
   \   00000076   0x6481             STR      R1,[R0, #+72]
   1294            
   1295            CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_LDMATX);
   \   00000078   0x6851             LDR      R1,[R2, #+4]
   \   0000007A   0xF421 0x4180      BIC      R1,R1,#0x4000
   \   0000007E   0x6051             STR      R1,[R2, #+4]
   1296            /* packing mode is enabled only if the DMA setting is HALWORD */
   1297            if((hspi->Init.DataSize <= SPI_DATASIZE_8BIT) && (hspi->hdmatx->Init.MemDataAlignment == DMA_MDATAALIGN_HALFWORD))
   \   00000080   0x68E9             LDR      R1,[R5, #+12]
   \   00000082   0x8FEB             LDRH     R3,[R5, #+62]
   \   00000084   0xF5B1 0x6FE0      CMP      R1,#+1792
   \   00000088   0xD810             BHI.N    ??HAL_SPI_Transmit_DMA_5
   \   0000008A   0x6981             LDR      R1,[R0, #+24]
   \   0000008C   0xF5B1 0x5F00      CMP      R1,#+8192
   \   00000090   0xD10C             BNE.N    ??HAL_SPI_Transmit_DMA_5
   1298            {
   1299              /* Check the even/odd of the data size + crc if enabled */
   1300              if((hspi->TxXferCount & 0x1) == 0)
   \   00000092   0x0859             LSRS     R1,R3,#+1
   \   00000094   0x07DB             LSLS     R3,R3,#+31
   \   00000096   0x6853             LDR      R3,[R2, #+4]
   \   00000098   0xD404             BMI.N    ??HAL_SPI_Transmit_DMA_6
   1301              {
   1302                CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_LDMATX);
   \   0000009A   0xF423 0x4380      BIC      R3,R3,#0x4000
   \   0000009E   0x6053             STR      R3,[R2, #+4]
   1303                hspi->TxXferCount = (hspi->TxXferCount >> 1);
   \   000000A0   0x460B             MOV      R3,R1
   \   000000A2   0xE003             B.N      ??HAL_SPI_Transmit_DMA_5
   1304              }
   1305              else
   1306              {
   1307                SET_BIT(hspi->Instance->CR2, SPI_CR2_LDMATX);
   \                     ??HAL_SPI_Transmit_DMA_6: (+1)
   \   000000A4   0xF443 0x4380      ORR      R3,R3,#0x4000
   \   000000A8   0x6053             STR      R3,[R2, #+4]
   1308                hspi->TxXferCount = (hspi->TxXferCount >> 1) + 1;
   \   000000AA   0x1C4B             ADDS     R3,R1,#+1
   \                     ??HAL_SPI_Transmit_DMA_5: (+1)
   \   000000AC   0x87EB             STRH     R3,[R5, #+62]
   1309              }
   1310            }
   1311            
   1312            /* Enable the Tx DMA channel */
   1313            HAL_DMA_Start_IT(hspi->hdmatx, (uint32_t)hspi->pTxBuffPtr, (uint32_t)&hspi->Instance->DR, hspi->TxXferCount);
   \   000000AE   0x8FEB             LDRH     R3,[R5, #+62]
   \   000000B0   0x6BA9             LDR      R1,[R5, #+56]
   \   000000B2   0x320C             ADDS     R2,R2,#+12
   \   000000B4   0x.... 0x....      BL       HAL_DMA_Start_IT
   1314            
   1315            /* Check if the SPI is already enabled */ 
   1316            if((hspi->Instance->CR1 &SPI_CR1_SPE) != SPI_CR1_SPE)
   \   000000B8   0x6828             LDR      R0,[R5, #+0]
   \   000000BA   0x.... 0x....      BL       ?Subroutine17
   1317            {
   1318              /* Enable SPI peripheral */    
   1319              __HAL_SPI_ENABLE(hspi);
   1320            }
   1321          
   1322            /* Enable Tx DMA Request */
   1323            hspi->Instance->CR2 |= SPI_CR2_TXDMAEN;
   \                     ??CrossCallReturnLabel_29: (+1)
   \   000000BE   0x.... 0x....      BL       ?Subroutine29
   1324            
   1325            /* Process Unlocked */
   1326            __HAL_UNLOCK(hspi);
   \                     ??CrossCallReturnLabel_54: (+1)
   \   000000C2   0x7620             STRB     R0,[R4, #+24]
   1327            
   1328            return HAL_OK;
   \                     ??HAL_SPI_Transmit_DMA_1: (+1)
   \   000000C4   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1329          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine29: (+1)
   \   00000000   0x6841             LDR      R1,[R0, #+4]
   \   00000002   0xF041 0x0102      ORR      R1,R1,#0x2
   \   00000006   0x6041             STR      R1,[R0, #+4]
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x4770             BX       LR
   1330          
   1331          /**
   1332          * @brief  Receive an amount of data in no-blocking mode with DMA 
   1333          * @param  hspi: SPI handle
   1334          * @param  pData: pointer to data buffer
   1335          * @param  Size: amount of data to be sent
   1336          * @retval HAL status
   1337          */

   \                                 In section .text, align 2, keep-with-next
   1338          HAL_StatusTypeDef HAL_SPI_Receive_DMA(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size)
   1339          {
   \                     HAL_SPI_Receive_DMA: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x.... 0x....      BL       ?Subroutine28
   1340            if(hspi->State != HAL_SPI_STATE_READY)
   \                     ??CrossCallReturnLabel_52: (+1)
   \   00000006   0xD106             BNE.N    ??HAL_SPI_Receive_DMA_0
   1341            {
   1342              return HAL_BUSY;
   1343            }
   1344            
   1345            if((pData == NULL) || (Size == 0))
   \   00000008   0x2900             CMP      R1,#+0
   \   0000000A   0xBF18             IT       NE 
   \   0000000C   0x2A00             CMPNE    R2,#+0
   \   0000000E   0xD060             BEQ.N    ??HAL_SPI_Receive_DMA_1
   1346            {
   1347              return HAL_ERROR;
   1348            }
   1349            
   1350            /* Process Locked */
   1351            __HAL_LOCK(hspi);
   \   00000010   0x7E28             LDRB     R0,[R5, #+24]
   \   00000012   0x2801             CMP      R0,#+1
   \   00000014   0xD101             BNE.N    ??HAL_SPI_Receive_DMA_2
   \                     ??HAL_SPI_Receive_DMA_0: (+1)
   \   00000016   0x2002             MOVS     R0,#+2
   \   00000018   0xBD32             POP      {R1,R4,R5,PC}
   \                     ??HAL_SPI_Receive_DMA_2: (+1)
   \   0000001A   0x2001             MOVS     R0,#+1
   \   0000001C   0x7628             STRB     R0,[R5, #+24]
   1352          
   1353            hspi->State       = HAL_SPI_STATE_BUSY_RX;
   \   0000001E   0x2004             MOVS     R0,#+4
   \   00000020   0x7668             STRB     R0,[R5, #+25]
   1354            hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0x61E8             STR      R0,[R5, #+28]
   1355            hspi->pRxBuffPtr  = pData;
   \   00000026   0x6421             STR      R1,[R4, #+64]
   1356            hspi->RxXferSize  = Size;
   \   00000028   0x802A             STRH     R2,[R5, #+0]
   1357            hspi->RxXferCount = Size;
   \   0000002A   0x806A             STRH     R2,[R5, #+2]
   1358            hspi->pTxBuffPtr  = (uint8_t *)NULL;
   \   0000002C   0x63A0             STR      R0,[R4, #+56]
   1359            hspi->TxXferSize  = 0;
   \   0000002E   0x87A0             STRH     R0,[R4, #+60]
   1360            hspi->TxXferCount = 0;
   \   00000030   0x87E0             STRH     R0,[R4, #+62]
   1361          
   1362            if((hspi->Init.Mode == SPI_MODE_MASTER) && (hspi->Init.Direction == SPI_DIRECTION_2LINES))
   \   00000032   0x6860             LDR      R0,[R4, #+4]
   \   00000034   0xF5B0 0x7F82      CMP      R0,#+260
   \   00000038   0xBF04             ITT      EQ 
   \   0000003A   0x68A0             LDREQ    R0,[R4, #+8]
   \   0000003C   0x2800             CMPEQ    R0,#+0
   \   0000003E   0xD107             BNE.N    ??HAL_SPI_Receive_DMA_3
   1363            {
   1364              /* Process Unlocked */
   1365              __HAL_UNLOCK(hspi);
   \   00000040   0x7628             STRB     R0,[R5, #+24]
   1366              /* the receive process is not supported in 2Lines direction master mode */
   1367              /* in this case we call the transmitReceive process                     */
   1368              return HAL_SPI_TransmitReceive_DMA(hspi,pData,pData,Size);
   \   00000042   0x4613             MOV      R3,R2
   \   00000044   0x4620             MOV      R0,R4
   \   00000046   0xB001             ADD      SP,SP,#+4
   \   00000048   0x460A             MOV      R2,R1
   \   0000004A   0xE8BD 0x4030      POP      {R4,R5,LR}
   \   0000004E   0x....             B.N      HAL_SPI_TransmitReceive_DMA
   1369            }
   1370            
   1371            /* Configure communication direction : 1Line */
   1372            if(hspi->Init.Direction == SPI_DIRECTION_1LINE)
   \                     ??HAL_SPI_Receive_DMA_3: (+1)
   \   00000050   0x68A0             LDR      R0,[R4, #+8]
   \   00000052   0xF5B0 0x4F00      CMP      R0,#+32768
   \   00000056   0xD104             BNE.N    ??HAL_SPI_Receive_DMA_4
   1373            {
   1374              SPI_1LINE_RX(hspi);
   \   00000058   0x6821             LDR      R1,[R4, #+0]
   \   0000005A   0x6808             LDR      R0,[R1, #+0]
   \   0000005C   0xF420 0x4080      BIC      R0,R0,#0x4000
   \   00000060   0x6008             STR      R0,[R1, #+0]
   1375            }
   1376            
   1377            /* Reset CRC Calculation */
   1378            if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   \                     ??HAL_SPI_Receive_DMA_4: (+1)
   \   00000062   0x.... 0x....      BL       ?Subroutine31
   \                     ??CrossCallReturnLabel_67: (+1)
   \   00000066   0xD109             BNE.N    ??HAL_SPI_Receive_DMA_5
   1379            {
   1380              SPI_RESET_CRC(hspi);
   \   00000068   0x6821             LDR      R1,[R4, #+0]
   \   0000006A   0xF64D 0x72FF      MOVW     R2,#+57343
   \   0000006E   0x6808             LDR      R0,[R1, #+0]
   \   00000070   0x4010             ANDS     R0,R2,R0
   \   00000072   0x6008             STR      R0,[R1, #+0]
   \   00000074   0x6808             LDR      R0,[R1, #+0]
   \   00000076   0xF440 0x5000      ORR      R0,R0,#0x2000
   \   0000007A   0x6008             STR      R0,[R1, #+0]
   1381            }
   1382            
   1383            /* packing mode management is enabled by the DMA settings */
   1384            if((hspi->Init.DataSize <= SPI_DATASIZE_8BIT) && (hspi->hdmarx->Init.MemDataAlignment == DMA_MDATAALIGN_HALFWORD))
   \                     ??HAL_SPI_Receive_DMA_5: (+1)
   \   0000007C   0x68E1             LDR      R1,[R4, #+12]
   \   0000007E   0xF240 0x7001      MOVW     R0,#+1793
   \   00000082   0x4281             CMP      R1,R0
   \   00000084   0xD208             BCS.N    ??HAL_SPI_Receive_DMA_6
   \   00000086   0x6969             LDR      R1,[R5, #+20]
   \   00000088   0x6989             LDR      R1,[R1, #+24]
   \   0000008A   0xF5B1 0x5F00      CMP      R1,#+8192
   \   0000008E   0xD103             BNE.N    ??HAL_SPI_Receive_DMA_6
   1385            {
   1386              /* Process Locked */
   1387              __HAL_UNLOCK(hspi);
   \   00000090   0x2000             MOVS     R0,#+0
   \   00000092   0x7628             STRB     R0,[R5, #+24]
   1388              /* Restriction the DMA data received is not allowed in this mode */
   1389              return HAL_ERROR;
   \   00000094   0x2001             MOVS     R0,#+1
   \   00000096   0xBD32             POP      {R1,R4,R5,PC}
   1390            }
   1391            
   1392            CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_LDMARX);
   \                     ??HAL_SPI_Receive_DMA_6: (+1)
   \   00000098   0x6821             LDR      R1,[R4, #+0]
   \   0000009A   0x684A             LDR      R2,[R1, #+4]
   \   0000009C   0xF422 0x5200      BIC      R2,R2,#0x2000
   \   000000A0   0x604A             STR      R2,[R1, #+4]
   1393            if( hspi->Init.DataSize > SPI_DATASIZE_8BIT)
   \   000000A2   0x68E2             LDR      R2,[R4, #+12]
   \   000000A4   0x4282             CMP      R2,R0
   \   000000A6   0x6848             LDR      R0,[R1, #+4]
   1394            {
   1395              /* set fiforxthreshold according the reception data length: 16bit */
   1396              CLEAR_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
   1397            }
   1398            else
   1399            {
   1400              /* set fiforxthreshold according the reception data length: 8bit */
   1401              SET_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
   1402            }
   1403            
   1404            /* Set the SPI RxDMA Half transfer complete callback */
   1405            hspi->hdmarx->XferHalfCpltCallback = SPI_DMAHalfReceiveCplt;
   \   000000A8   0x.... 0x....      ADR.W    R2,SPI_DMAHalfReceiveCplt
   \   000000AC   0xBF2C             ITE      CS 
   \   000000AE   0xF420 0x5080      BICCS    R0,R0,#0x1000
   \   000000B2   0xF440 0x5080      ORRCC    R0,R0,#0x1000
   \   000000B6   0x6048             STR      R0,[R1, #+4]
   \   000000B8   0x6968             LDR      R0,[R5, #+20]
   \   000000BA   0x6402             STR      R2,[R0, #+64]
   1406          
   1407            /* Set the SPI Rx DMA transfer complete callback */
   1408            hspi->hdmarx->XferCpltCallback = SPI_DMAReceiveCplt;
   \   000000BC   0x.... 0x....      ADR.W    R2,SPI_DMAReceiveCplt
   \   000000C0   0x63C2             STR      R2,[R0, #+60]
   1409            
   1410            /* Set the DMA error callback */
   1411            hspi->hdmarx->XferErrorCallback = SPI_DMAError;
   \   000000C2   0x.... 0x....      ADR.W    R2,SPI_DMAError
   \   000000C6   0x6482             STR      R2,[R0, #+72]
   1412            
   1413            /* Enable Rx DMA Request */  
   1414            hspi->Instance->CR2 |= SPI_CR2_RXDMAEN;
   \   000000C8   0x.... 0x....      BL       ?Subroutine36
   1415            
   1416            /* Enable the Rx DMA channel */
   1417            HAL_DMA_Start_IT(hspi->hdmarx, (uint32_t)&hspi->Instance->DR, (uint32_t)hspi->pRxBuffPtr, hspi->RxXferCount);
   1418            
   1419            /* Process Unlocked */
   1420            __HAL_UNLOCK(hspi);
   \                     ??CrossCallReturnLabel_80: (+1)
   \   000000CC   0x.... 0x....      BL       ?Subroutine14
   1421            
   1422            /* Check if the SPI is already enabled */ 
   1423            if((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
   1424            {
   1425              /* Enable SPI peripheral */    
   1426              __HAL_SPI_ENABLE(hspi);
   1427            }
   1428            
   1429            return HAL_OK;
   \                     ??CrossCallReturnLabel_21: (+1)
   \   000000D0   0x2000             MOVS     R0,#+0
   \                     ??HAL_SPI_Receive_DMA_1: (+1)
   \   000000D2   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1430          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine36: (+1)
   \   00000000   0x684A             LDR      R2,[R1, #+4]
   \   00000002   0xF042 0x0201      ORR      R2,R2,#0x1
   \   00000006   0x604A             STR      R2,[R1, #+4]
   \   00000008   0x886B             LDRH     R3,[R5, #+2]
   \   0000000A   0x6C22             LDR      R2,[R4, #+64]
   \   0000000C   0x310C             ADDS     R1,R1,#+12
   \   0000000E   0x.... 0x....      B.W      HAL_DMA_Start_IT

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine28: (+1)
   \   00000000   0x4604             MOV      R4,R0
   \   00000002   0xF104 0x0544      ADD      R5,R4,#+68
   \   00000006   0x7E68             LDRB     R0,[R5, #+25]
   \   00000008   0x2801             CMP      R0,#+1
   \   0000000A   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine14: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x7628             STRB     R0,[R5, #+24]
   \   00000004   0x6820             LDR      R0,[R4, #+0]
   \   00000006   0x6801             LDR      R1,[R0, #+0]
   \   00000008   0x0649             LSLS     R1,R1,#+25
   \   0000000A   0xD403             BMI.N    ??Subroutine14_0
   \   0000000C   0x6801             LDR      R1,[R0, #+0]
   \   0000000E   0xF041 0x0140      ORR      R1,R1,#0x40
   \   00000012   0x6001             STR      R1,[R0, #+0]
   \                     ??Subroutine14_0: (+1)
   \   00000014   0x4770             BX       LR
   1431          
   1432          /**
   1433            * @brief  Transmit and Receive an amount of data in no-blocking mode with DMA
   1434            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   1435            *               the configuration information for SPI module.
   1436            * @param  pTxData: pointer to transmission data buffer
   1437            * @param  pRxData: pointer to reception data buffer
   1438            * @note  When the CRC feature is enabled the pRxData Length must be Size + 1
   1439            * @param  Size: amount of data to be sent
   1440            * @retval HAL status
   1441            */

   \                                 In section .text, align 2, keep-with-next
   1442          HAL_StatusTypeDef HAL_SPI_TransmitReceive_DMA(SPI_HandleTypeDef *hspi, uint8_t *pTxData, uint8_t *pRxData, uint16_t Size)
   1443          {
   \                     HAL_SPI_TransmitReceive_DMA: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x.... 0x....      BL       ?Subroutine28
   1444            assert_param(IS_SPI_DIRECTION_2LINES(hspi->Init.Direction));
   1445            
   1446            if((hspi->State == HAL_SPI_STATE_READY) ||
   1447               ((hspi->Init.Mode == SPI_MODE_MASTER) && (hspi->Init.Direction == SPI_DIRECTION_2LINES) && (hspi->State == HAL_SPI_STATE_BUSY_RX)))
   \                     ??CrossCallReturnLabel_53: (+1)
   \   00000006   0xD008             BEQ.N    ??HAL_SPI_TransmitReceive_DMA_0
   \   00000008   0x6866             LDR      R6,[R4, #+4]
   \   0000000A   0xF5B6 0x7F82      CMP      R6,#+260
   \   0000000E   0xBF02             ITTT     EQ 
   \   00000010   0x68A6             LDREQ    R6,[R4, #+8]
   \   00000012   0x2E00             CMPEQ    R6,#+0
   \   00000014   0x2804             CMPEQ    R0,#+4
   \   00000016   0xF040 0x808A      BNE.W    ??HAL_SPI_TransmitReceive_DMA_1
   1448            {
   1449              if((pTxData == NULL ) || (pRxData == NULL ) || (Size == 0)) 
   \                     ??HAL_SPI_TransmitReceive_DMA_0: (+1)
   \   0000001A   0x2900             CMP      R1,#+0
   \   0000001C   0xBF18             IT       NE 
   \   0000001E   0x2A00             CMPNE    R2,#+0
   \   00000020   0xD000             BEQ.N    ??HAL_SPI_TransmitReceive_DMA_2
   \   00000022   0xB90B             CBNZ.N   R3,??HAL_SPI_TransmitReceive_DMA_3
   1450              {
   1451                return  HAL_ERROR;                                    
   \                     ??HAL_SPI_TransmitReceive_DMA_2: (+1)
   \   00000024   0x2001             MOVS     R0,#+1
   \   00000026   0xBD70             POP      {R4-R6,PC}
   1452              }
   1453              
   1454              /* Process locked */
   1455              __HAL_LOCK(hspi);
   \                     ??HAL_SPI_TransmitReceive_DMA_3: (+1)
   \   00000028   0x7E2E             LDRB     R6,[R5, #+24]
   \   0000002A   0x2E01             CMP      R6,#+1
   \   0000002C   0xF000 0x807F      BEQ.W    ??HAL_SPI_TransmitReceive_DMA_1
   \   00000030   0x2601             MOVS     R6,#+1
   1456              
   1457              /* check if the transmit Receive function is not called by a receive master */
   1458              if(hspi->State != HAL_SPI_STATE_BUSY_RX)
   \   00000032   0x2804             CMP      R0,#+4
   \   00000034   0x762E             STRB     R6,[R5, #+24]
   \   00000036   0xBF1C             ITT      NE 
   \   00000038   0x2005             MOVNE    R0,#+5
   \   0000003A   0x7668             STRBNE   R0,[R5, #+25]
   1459              {  
   1460                hspi->State = HAL_SPI_STATE_BUSY_TX_RX;
   1461              }
   1462              
   1463              hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
   \   0000003C   0x2000             MOVS     R0,#+0
   \   0000003E   0x61E8             STR      R0,[R5, #+28]
   1464              hspi->pTxBuffPtr  = (uint8_t *)pTxData;
   \   00000040   0x63A1             STR      R1,[R4, #+56]
   1465              hspi->TxXferSize  = Size;
   \   00000042   0x87A3             STRH     R3,[R4, #+60]
   1466              hspi->TxXferCount = Size;
   \   00000044   0x87E3             STRH     R3,[R4, #+62]
   1467              hspi->pRxBuffPtr  = (uint8_t *)pRxData;
   \   00000046   0x6422             STR      R2,[R4, #+64]
   1468              hspi->RxXferSize  = Size;
   \   00000048   0x802B             STRH     R3,[R5, #+0]
   1469              hspi->RxXferCount = Size;
   \   0000004A   0x806B             STRH     R3,[R5, #+2]
   1470              
   1471              /* Reset CRC Calculation + increase the rxsize */
   1472              if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   \   0000004C   0x6AA0             LDR      R0,[R4, #+40]
   \   0000004E   0x6821             LDR      R1,[R4, #+0]
   \   00000050   0x.... 0x....      BL       ??Subroutine8_0
   1473              {
   1474                SPI_RESET_CRC(hspi);
   1475              }
   1476              
   1477              /* Reset the threshold bit */
   1478              CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_LDMATX);
   \                     ??CrossCallReturnLabel_2: (+1)
   \   00000054   0xF420 0x4080      BIC      R0,R0,#0x4000
   \   00000058   0x6048             STR      R0,[R1, #+4]
   1479              CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_LDMARX);
   \   0000005A   0x6848             LDR      R0,[R1, #+4]
   \   0000005C   0xF420 0x5000      BIC      R0,R0,#0x2000
   \   00000060   0x6048             STR      R0,[R1, #+4]
   1480              
   1481              /* the packing mode management is enabled by the DMA settings according the spi data size */
   1482              if(hspi->Init.DataSize > SPI_DATASIZE_8BIT)
   \   00000062   0x68E0             LDR      R0,[R4, #+12]
   \   00000064   0xF5B0 0x6FE0      CMP      R0,#+1792
   \   00000068   0x6848             LDR      R0,[R1, #+4]
   \   0000006A   0xD903             BLS.N    ??HAL_SPI_TransmitReceive_DMA_4
   1483              {
   1484                /* set fiforxthreshold according the reception data length: 16bit */
   1485                CLEAR_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
   \   0000006C   0xF420 0x5080      BIC      R0,R0,#0x1000
   \   00000070   0x6048             STR      R0,[R1, #+4]
   \   00000072   0xE031             B.N      ??HAL_SPI_TransmitReceive_DMA_5
   1486              }
   1487              else
   1488              {
   1489                /* set fiforxthreshold according the reception data length: 8bit */
   1490                SET_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
   \                     ??HAL_SPI_TransmitReceive_DMA_4: (+1)
   \   00000074   0xF440 0x5080      ORR      R0,R0,#0x1000
   \   00000078   0x6048             STR      R0,[R1, #+4]
   1491                
   1492                if(hspi->hdmatx->Init.MemDataAlignment == DMA_MDATAALIGN_HALFWORD)
   \   0000007A   0x6928             LDR      R0,[R5, #+16]
   \   0000007C   0x6980             LDR      R0,[R0, #+24]
   \   0000007E   0xF5B0 0x5F00      CMP      R0,#+8192
   \   00000082   0xD111             BNE.N    ??HAL_SPI_TransmitReceive_DMA_6
   1493                {
   1494                  if((hspi->TxXferSize & 0x1) == 0x0 )
   \   00000084   0xF894 0x003C      LDRB     R0,[R4, #+60]
   \   00000088   0x07C0             LSLS     R0,R0,#+31
   \   0000008A   0x6848             LDR      R0,[R1, #+4]
   \   0000008C   0xD405             BMI.N    ??HAL_SPI_TransmitReceive_DMA_7
   1495                  {
   1496                    CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_LDMATX);
   \   0000008E   0xF420 0x4080      BIC      R0,R0,#0x4000
   \   00000092   0x6048             STR      R0,[R1, #+4]
   1497                    hspi->TxXferCount = hspi->TxXferCount >> 1;
   \   00000094   0x8FE0             LDRH     R0,[R4, #+62]
   \   00000096   0x0840             LSRS     R0,R0,#+1
   \   00000098   0xE005             B.N      ??HAL_SPI_TransmitReceive_DMA_8
   1498                  }
   1499                  else
   1500                  {
   1501                    SET_BIT(hspi->Instance->CR2, SPI_CR2_LDMATX);
   \                     ??HAL_SPI_TransmitReceive_DMA_7: (+1)
   \   0000009A   0xF440 0x4080      ORR      R0,R0,#0x4000
   \   0000009E   0x6048             STR      R0,[R1, #+4]
   1502                    hspi->TxXferCount = (hspi->TxXferCount >> 1) + 1;
   \   000000A0   0x8FE0             LDRH     R0,[R4, #+62]
   \   000000A2   0x0840             LSRS     R0,R0,#+1
   \   000000A4   0x1C40             ADDS     R0,R0,#+1
   \                     ??HAL_SPI_TransmitReceive_DMA_8: (+1)
   \   000000A6   0x87E0             STRH     R0,[R4, #+62]
   1503                  }      
   1504                }
   1505                
   1506                if(hspi->hdmarx->Init.MemDataAlignment == DMA_MDATAALIGN_HALFWORD)
   \                     ??HAL_SPI_TransmitReceive_DMA_6: (+1)
   \   000000A8   0x6968             LDR      R0,[R5, #+20]
   \   000000AA   0x6980             LDR      R0,[R0, #+24]
   \   000000AC   0xF5B0 0x5F00      CMP      R0,#+8192
   \   000000B0   0xD112             BNE.N    ??HAL_SPI_TransmitReceive_DMA_5
   1507                {
   1508                  /* set fiforxthreshold according the reception data length: 16bit */
   1509                  CLEAR_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
   \   000000B2   0x6848             LDR      R0,[R1, #+4]
   \   000000B4   0xF420 0x5080      BIC      R0,R0,#0x1000
   \   000000B8   0x6048             STR      R0,[R1, #+4]
   1510                  
   1511                  /* Size must include the CRC length */
   1512                  if((hspi->RxXferCount & 0x1) == 0x0 )
   \   000000BA   0x8868             LDRH     R0,[R5, #+2]
   \   000000BC   0x07C2             LSLS     R2,R0,#+31
   \   000000BE   0x684A             LDR      R2,[R1, #+4]
   \   000000C0   0xD404             BMI.N    ??HAL_SPI_TransmitReceive_DMA_9
   1513                  {
   1514                    CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_LDMARX);
   \   000000C2   0xF422 0x5200      BIC      R2,R2,#0x2000
   1515                    hspi->RxXferCount = hspi->RxXferCount >> 1;
   \   000000C6   0x0840             LSRS     R0,R0,#+1
   \   000000C8   0x604A             STR      R2,[R1, #+4]
   \   000000CA   0xE004             B.N      ??HAL_SPI_TransmitReceive_DMA_10
   1516                  }
   1517                  else
   1518                  {
   1519                    SET_BIT(hspi->Instance->CR2, SPI_CR2_LDMARX);
   \                     ??HAL_SPI_TransmitReceive_DMA_9: (+1)
   \   000000CC   0xF442 0x5200      ORR      R2,R2,#0x2000
   1520                    hspi->RxXferCount = (hspi->RxXferCount >> 1) + 1; 
   \   000000D0   0x0840             LSRS     R0,R0,#+1
   \   000000D2   0x604A             STR      R2,[R1, #+4]
   \   000000D4   0x1C40             ADDS     R0,R0,#+1
   \                     ??HAL_SPI_TransmitReceive_DMA_10: (+1)
   \   000000D6   0x8068             STRH     R0,[R5, #+2]
   1521                  } 
   1522                }
   1523              }   
   1524              
   1525              /* Set the SPI Rx DMA transfer complete callback because the last generated transfer request is 
   1526              the reception request (RXNE) */
   1527              if(hspi->State == HAL_SPI_STATE_BUSY_RX)
   \                     ??HAL_SPI_TransmitReceive_DMA_5: (+1)
   \   000000D8   0x7E6A             LDRB     R2,[R5, #+25]
   \   000000DA   0x6968             LDR      R0,[R5, #+20]
   \   000000DC   0x2A04             CMP      R2,#+4
   \   000000DE   0xD105             BNE.N    ??HAL_SPI_TransmitReceive_DMA_11
   1528              {			
   1529                hspi->hdmarx->XferHalfCpltCallback = SPI_DMAHalfReceiveCplt;
   \   000000E0   0x.... 0x....      ADR.W    R2,SPI_DMAHalfReceiveCplt
   \   000000E4   0x6402             STR      R2,[R0, #+64]
   1530                hspi->hdmarx->XferCpltCallback = SPI_DMAReceiveCplt;
   \   000000E6   0x.... 0x....      ADR.W    R2,SPI_DMAReceiveCplt
   \   000000EA   0xE004             B.N      ??HAL_SPI_TransmitReceive_DMA_12
   1531              }
   1532              else
   1533              {	
   1534                 hspi->hdmarx->XferHalfCpltCallback = SPI_DMAHalfTransmitReceiveCplt;
   \                     ??HAL_SPI_TransmitReceive_DMA_11: (+1)
   \   000000EC   0x.... 0x....      ADR.W    R2,SPI_DMAHalfTransmitReceiveCplt
   \   000000F0   0x6402             STR      R2,[R0, #+64]
   1535                hspi->hdmarx->XferCpltCallback = SPI_DMATransmitReceiveCplt;
   \   000000F2   0x.... 0x....      ADR.W    R2,SPI_DMATransmitReceiveCplt
   1536              }
   1537              /* Set the DMA error callback */
   1538              hspi->hdmarx->XferErrorCallback = SPI_DMAError;
   \                     ??HAL_SPI_TransmitReceive_DMA_12: (+1)
   \   000000F6   0x.... 0x....      ADR.W    R6,SPI_DMAError
   \   000000FA   0x63C2             STR      R2,[R0, #+60]
   \   000000FC   0x6486             STR      R6,[R0, #+72]
   1539              
   1540              /* Enable Rx DMA Request */  
   1541              hspi->Instance->CR2 |= SPI_CR2_RXDMAEN;
   \   000000FE   0x.... 0x....      BL       ?Subroutine36
   1542              
   1543              /* Enable the Rx DMA channel */
   1544              HAL_DMA_Start_IT(hspi->hdmarx, (uint32_t)&hspi->Instance->DR, (uint32_t) hspi->pRxBuffPtr, hspi->RxXferCount);
   1545              
   1546              /* Set the SPI Tx DMA transfer complete callback as NULL because the communication closing
   1547              is performed in DMA reception complete callback  */
   1548              hspi->hdmatx->XferHalfCpltCallback = NULL;
   \                     ??CrossCallReturnLabel_79: (+1)
   \   00000102   0x6928             LDR      R0,[R5, #+16]
   \   00000104   0x2100             MOVS     R1,#+0
   \   00000106   0x6401             STR      R1,[R0, #+64]
   1549              hspi->hdmatx->XferCpltCallback = NULL;
   \   00000108   0x63C1             STR      R1,[R0, #+60]
   1550          
   1551              if(hspi->State == HAL_SPI_STATE_BUSY_TX_RX)
   \   0000010A   0x7E69             LDRB     R1,[R5, #+25]
   \   0000010C   0x2905             CMP      R1,#+5
   \   0000010E   0xBF0E             ITEE     EQ 
   \   00000110   0x6486             STREQ    R6,[R0, #+72]
   \   00000112   0x2100             MOVNE    R1,#+0
   \   00000114   0x6481             STRNE    R1,[R0, #+72]
   1552              {
   1553                /* Set the DMA error callback */
   1554                hspi->hdmatx->XferErrorCallback = SPI_DMAError;
   1555              }
   1556              else
   1557              {
   1558                hspi->hdmatx->XferErrorCallback = NULL;
   1559              } 
   1560              
   1561              /* Enable the Tx DMA channel */
   1562              HAL_DMA_Start_IT(hspi->hdmatx, (uint32_t)hspi->pTxBuffPtr, (uint32_t)&hspi->Instance->DR, hspi->TxXferCount);
   \   00000116   0x6821             LDR      R1,[R4, #+0]
   \   00000118   0x8FE3             LDRH     R3,[R4, #+62]
   \   0000011A   0xF101 0x020C      ADD      R2,R1,#+12
   \   0000011E   0x6BA1             LDR      R1,[R4, #+56]
   \   00000120   0x.... 0x....      BL       HAL_DMA_Start_IT
   1563          
   1564              /* Process Unlocked */
   1565              __HAL_UNLOCK(hspi);
   \   00000124   0x.... 0x....      BL       ?Subroutine14
   1566                  
   1567              /* Check if the SPI is already enabled */ 
   1568              if((hspi->Instance->CR1 &SPI_CR1_SPE) != SPI_CR1_SPE)
   1569              {
   1570                /* Enable SPI peripheral */    
   1571                __HAL_SPI_ENABLE(hspi);
   1572              }
   1573              
   1574              /* Enable Tx DMA Request */  
   1575              hspi->Instance->CR2 |= SPI_CR2_TXDMAEN;
   \                     ??CrossCallReturnLabel_22: (+1)
   \   00000128   0x.... 0x....      BL       ?Subroutine29
   1576                  
   1577              return HAL_OK;
   1578            }
   \                     ??CrossCallReturnLabel_55: (+1)
   \   0000012C   0xBD70             POP      {R4-R6,PC}
   1579            else
   1580            {
   1581              return HAL_BUSY;
   \                     ??HAL_SPI_TransmitReceive_DMA_1: (+1)
   \   0000012E   0x2002             MOVS     R0,#+2
   \   00000130   0xBD70             POP      {R4-R6,PC}       ;; return
   1582            }
   1583          }
   1584          
   1585          /**
   1586            * @brief Pauses the DMA Transfer.
   1587            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   1588            *               the configuration information for the specified SPI module.
   1589            * @retval HAL status
   1590            */

   \                                 In section .text, align 2, keep-with-next
   1591          HAL_StatusTypeDef HAL_SPI_DMAPause(SPI_HandleTypeDef *hspi)
   1592          {
   1593            /* Process Locked */
   1594            __HAL_LOCK(hspi);
   \                     HAL_SPI_DMAPause: (+1)
   \   00000000   0xF890 0x105C      LDRB     R1,[R0, #+92]
   \   00000004   0x2901             CMP      R1,#+1
   \   00000006   0xD101             BNE.N    ??HAL_SPI_DMAPause_0
   \   00000008   0x2002             MOVS     R0,#+2
   \   0000000A   0x4770             BX       LR
   \                     ??HAL_SPI_DMAPause_0: (+1)
   \   0000000C   0x2101             MOVS     R1,#+1
   \   0000000E   0xF880 0x105C      STRB     R1,[R0, #+92]
   1595          
   1596            /* Disable the SPI DMA Tx & Rx requests */
   1597            CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);
   \   00000012   0x6801             LDR      R1,[R0, #+0]
   \   00000014   0x684A             LDR      R2,[R1, #+4]
   \   00000016   0x0892             LSRS     R2,R2,#+2
   \   00000018   0x0092             LSLS     R2,R2,#+2
   \   0000001A   0x....             B.N      ?Subroutine1
   1598          
   1599            /* Process Unlocked */
   1600            __HAL_UNLOCK(hspi);
   1601          
   1602            return HAL_OK;
   1603          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \   00000000   0x604A             STR      R2,[R1, #+4]
   \   00000002   0x2100             MOVS     R1,#+0
   \   00000004   0xF880 0x105C      STRB     R1,[R0, #+92]
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x4770             BX       LR               ;; return
   1604          
   1605          /**
   1606            * @brief Resumes the DMA Transfer.
   1607            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   1608            *               the configuration information for the specified SPI module.
   1609            * @retval HAL status
   1610            */

   \                                 In section .text, align 2, keep-with-next
   1611          HAL_StatusTypeDef HAL_SPI_DMAResume(SPI_HandleTypeDef *hspi)
   1612          {
   1613            /* Process Locked */
   1614            __HAL_LOCK(hspi);
   \                     HAL_SPI_DMAResume: (+1)
   \   00000000   0xF890 0x105C      LDRB     R1,[R0, #+92]
   \   00000004   0x2901             CMP      R1,#+1
   \   00000006   0xD101             BNE.N    ??HAL_SPI_DMAResume_0
   \   00000008   0x2002             MOVS     R0,#+2
   \   0000000A   0x4770             BX       LR
   \                     ??HAL_SPI_DMAResume_0: (+1)
   \   0000000C   0x2101             MOVS     R1,#+1
   \   0000000E   0xF880 0x105C      STRB     R1,[R0, #+92]
   1615          
   1616            /* Enable the SPI DMA Tx & Rx requests */
   1617            SET_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);
   \   00000012   0x6801             LDR      R1,[R0, #+0]
   \   00000014   0x684A             LDR      R2,[R1, #+4]
   \   00000016   0xF042 0x0203      ORR      R2,R2,#0x3
   \   0000001A                      REQUIRE ?Subroutine1
   \   0000001A                      ;; // Fall through to label ?Subroutine1
   1618          
   1619            /* Process Unlocked */
   1620            __HAL_UNLOCK(hspi);
   1621          
   1622            return HAL_OK;
   1623          }
   1624          
   1625          /**
   1626            * @brief Stops the DMA Transfer.
   1627            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   1628            *               the configuration information for the specified SPI module.
   1629            * @retval HAL status
   1630            */

   \                                 In section .text, align 2, keep-with-next
   1631          HAL_StatusTypeDef HAL_SPI_DMAStop(SPI_HandleTypeDef *hspi)
   1632          {
   \                     HAL_SPI_DMAStop: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   1633            /* The Lock is not implemented on this API to allow the user application
   1634               to call the HAL SPI API under callbacks HAL_SPI_TxCpltCallback() or HAL_SPI_RxCpltCallback() or HAL_SPI_TxRxCpltCallback():
   1635               when calling HAL_DMA_Abort() API the DMA TX/RX Transfer complete interrupt is generated
   1636               and the correspond call back is executed HAL_SPI_TxCpltCallback() or HAL_SPI_RxCpltCallback() or HAL_SPI_TxRxCpltCallback()
   1637               */
   1638            
   1639            /* Abort the SPI DMA tx Stream */
   1640            if(hspi->hdmatx != NULL)
   \   00000004   0x6D60             LDR      R0,[R4, #+84]
   \   00000006   0xB108             CBZ.N    R0,??HAL_SPI_DMAStop_0
   1641            {
   1642              HAL_DMA_Abort(hspi->hdmatx);
   \   00000008   0x.... 0x....      BL       HAL_DMA_Abort
   1643            }
   1644            /* Abort the SPI DMA rx Stream */
   1645            if(hspi->hdmarx != NULL)
   \                     ??HAL_SPI_DMAStop_0: (+1)
   \   0000000C   0x6DA0             LDR      R0,[R4, #+88]
   \   0000000E   0xB108             CBZ.N    R0,??HAL_SPI_DMAStop_1
   1646            {
   1647              HAL_DMA_Abort(hspi->hdmarx);
   \   00000010   0x.... 0x....      BL       HAL_DMA_Abort
   1648            }
   1649          
   1650            /* Disable the SPI DMA Tx & Rx requests */
   1651            CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);
   \                     ??HAL_SPI_DMAStop_1: (+1)
   \   00000014   0x6820             LDR      R0,[R4, #+0]
   \   00000016   0x6841             LDR      R1,[R0, #+4]
   \   00000018   0x0889             LSRS     R1,R1,#+2
   \   0000001A   0x0089             LSLS     R1,R1,#+2
   \   0000001C   0x6041             STR      R1,[R0, #+4]
   1652            hspi->State = HAL_SPI_STATE_READY;
   \   0000001E   0x2001             MOVS     R0,#+1
   \   00000020   0xF884 0x005D      STRB     R0,[R4, #+93]
   1653            return HAL_OK;
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0xBD10             POP      {R4,PC}          ;; return
   1654          }
   1655          
   1656          /**
   1657            * @brief  This function handles SPI interrupt request.
   1658            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   1659            *               the configuration information for the specified SPI module.
   1660            * @retval None
   1661            */

   \                                 In section .text, align 2, keep-with-next
   1662          void HAL_SPI_IRQHandler(SPI_HandleTypeDef *hspi)
   1663          {
   \                     HAL_SPI_IRQHandler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1664            /* SPI in mode Receiver ----------------------------------------------------*/
   1665            if((__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_OVR) == RESET) &&
   1666               (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_RXNE) != RESET) && (__HAL_SPI_GET_IT_SOURCE(hspi, SPI_IT_RXNE) != RESET))
   \   00000002   0x6801             LDR      R1,[R0, #+0]
   \   00000004   0x688A             LDR      R2,[R1, #+8]
   \   00000006   0x0652             LSLS     R2,R2,#+25
   \   00000008   0xD409             BMI.N    ??HAL_SPI_IRQHandler_0
   \   0000000A   0x688A             LDR      R2,[R1, #+8]
   \   0000000C   0x07D2             LSLS     R2,R2,#+31
   \   0000000E   0xD506             BPL.N    ??HAL_SPI_IRQHandler_0
   \   00000010   0x684A             LDR      R2,[R1, #+4]
   \   00000012   0x0652             LSLS     R2,R2,#+25
   \   00000014   0xD503             BPL.N    ??HAL_SPI_IRQHandler_0
   1667            {
   1668              hspi->RxISR(hspi);
   \   00000016   0x6CC1             LDR      R1,[R0, #+76]
   \   00000018   0xE8BD 0x4004      POP      {R2,LR}
   \   0000001C   0x4708             BX       R1
   1669              return;
   1670            }
   1671            
   1672            /* SPI in mode Transmitter ---------------------------------------------------*/
   1673            if((__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE) != RESET) && (__HAL_SPI_GET_IT_SOURCE(hspi, SPI_IT_TXE) != RESET))
   \                     ??HAL_SPI_IRQHandler_0: (+1)
   \   0000001E   0x688A             LDR      R2,[R1, #+8]
   \   00000020   0x0792             LSLS     R2,R2,#+30
   \   00000022   0xD506             BPL.N    ??HAL_SPI_IRQHandler_1
   \   00000024   0x684A             LDR      R2,[R1, #+4]
   \   00000026   0x0612             LSLS     R2,R2,#+24
   \   00000028   0xD503             BPL.N    ??HAL_SPI_IRQHandler_1
   1674            {   
   1675              hspi->TxISR(hspi);
   \   0000002A   0x6D01             LDR      R1,[R0, #+80]
   \   0000002C   0xE8BD 0x4004      POP      {R2,LR}
   \   00000030   0x4708             BX       R1
   1676              return;
   1677            }
   1678            
   1679            /* SPI in ERROR Treatment ---------------------------------------------------*/
   1680            if((hspi->Instance->SR & (SPI_FLAG_MODF | SPI_FLAG_OVR | SPI_FLAG_FRE)) != RESET)  
   \                     ??HAL_SPI_IRQHandler_1: (+1)
   \   00000032   0x688A             LDR      R2,[R1, #+8]
   \   00000034   0xF412 0x7FB0      TST      R2,#0x160
   \   00000038   0xD02F             BEQ.N    ??HAL_SPI_IRQHandler_2
   1681            {
   1682              /* SPI Overrun error interrupt occurred -------------------------------------*/
   1683              if(__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_OVR) != RESET) 
   \   0000003A   0x688A             LDR      R2,[R1, #+8]
   \   0000003C   0x0652             LSLS     R2,R2,#+25
   \   0000003E   0xD50C             BPL.N    ??HAL_SPI_IRQHandler_3
   1684              {
   1685                if(hspi->State != HAL_SPI_STATE_BUSY_TX)
   \   00000040   0xF890 0x205D      LDRB     R2,[R0, #+93]
   \   00000044   0x2A03             CMP      R2,#+3
   \   00000046   0xD028             BEQ.N    ??HAL_SPI_IRQHandler_2
   1686                {
   1687                  hspi->ErrorCode |= HAL_SPI_ERROR_OVR;
   \   00000048   0x6E02             LDR      R2,[R0, #+96]
   \   0000004A   0xF042 0x0204      ORR      R2,R2,#0x4
   \   0000004E   0x6602             STR      R2,[R0, #+96]
   1688                  __HAL_SPI_CLEAR_OVRFLAG(hspi);
   \   00000050   0x68CA             LDR      R2,[R1, #+12]
   \   00000052   0x9200             STR      R2,[SP, #+0]
   \   00000054   0x688A             LDR      R2,[R1, #+8]
   \   00000056   0x9200             STR      R2,[SP, #+0]
   \   00000058   0x9A00             LDR      R2,[SP, #+0]
   1689                }
   1690                else
   1691                {
   1692                  return;
   1693                }
   1694              }
   1695              
   1696              /* SPI Mode Fault error interrupt occurred -------------------------------------*/
   1697              if(__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_MODF) != RESET)
   \                     ??HAL_SPI_IRQHandler_3: (+1)
   \   0000005A   0x688A             LDR      R2,[R1, #+8]
   \   0000005C   0x0692             LSLS     R2,R2,#+26
   \   0000005E   0xD50A             BPL.N    ??HAL_SPI_IRQHandler_4
   1698              { 
   1699                hspi->ErrorCode |= HAL_SPI_ERROR_MODF;
   \   00000060   0x6E02             LDR      R2,[R0, #+96]
   \   00000062   0xF042 0x0201      ORR      R2,R2,#0x1
   \   00000066   0x6602             STR      R2,[R0, #+96]
   1700                __HAL_SPI_CLEAR_MODFFLAG(hspi);
   \   00000068   0x688A             LDR      R2,[R1, #+8]
   \   0000006A   0x9200             STR      R2,[SP, #+0]
   \   0000006C   0x680A             LDR      R2,[R1, #+0]
   \   0000006E   0xF022 0x0240      BIC      R2,R2,#0x40
   \   00000072   0x600A             STR      R2,[R1, #+0]
   \   00000074   0x9A00             LDR      R2,[SP, #+0]
   1701              }
   1702              
   1703              /* SPI Frame error interrupt occurred ----------------------------------------*/
   1704              if(__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_FRE) != RESET)
   \                     ??HAL_SPI_IRQHandler_4: (+1)
   \   00000076   0x688A             LDR      R2,[R1, #+8]
   \   00000078   0x05D2             LSLS     R2,R2,#+23
   \   0000007A   0xD506             BPL.N    ??HAL_SPI_IRQHandler_5
   1705              { 
   1706                hspi->ErrorCode |= HAL_SPI_ERROR_FRE;
   \   0000007C   0x6E02             LDR      R2,[R0, #+96]
   \   0000007E   0xF042 0x0208      ORR      R2,R2,#0x8
   \   00000082   0x6602             STR      R2,[R0, #+96]
   1707                __HAL_SPI_CLEAR_FREFLAG(hspi);
   \   00000084   0x688A             LDR      R2,[R1, #+8]
   \   00000086   0x9200             STR      R2,[SP, #+0]
   \   00000088   0x9A00             LDR      R2,[SP, #+0]
   1708              }
   1709              
   1710              __HAL_SPI_DISABLE_IT(hspi, SPI_IT_RXNE | SPI_IT_TXE | SPI_IT_ERR);
   \                     ??HAL_SPI_IRQHandler_5: (+1)
   \   0000008A   0x684A             LDR      R2,[R1, #+4]
   \   0000008C   0xF022 0x02E0      BIC      R2,R2,#0xE0
   \   00000090   0x604A             STR      R2,[R1, #+4]
   1711              hspi->State = HAL_SPI_STATE_READY;
   \   00000092   0x.... 0x....      BL       ?Subroutine30
   1712              HAL_SPI_ErrorCallback(hspi);
   \                     ??CrossCallReturnLabel_56: (+1)
   \   00000096   0x.... 0x....      BL       HAL_SPI_ErrorCallback
   1713              
   1714              return;
   1715            }
   1716          }
   \                     ??HAL_SPI_IRQHandler_2: (+1)
   \   0000009A   0xBD01             POP      {R0,PC}          ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine30: (+1)
   \   00000000   0x2101             MOVS     R1,#+1
   \   00000002   0xF880 0x105D      STRB     R1,[R0, #+93]
   \   00000006   0x4770             BX       LR
   1717          
   1718          /**
   1719            * @brief Tx Transfer completed callback
   1720            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   1721            *               the configuration information for SPI module.
   1722            * @retval None
   1723            */

   \                                 In section .text, align 2, keep-with-next
   1724          __weak void HAL_SPI_TxCpltCallback(SPI_HandleTypeDef *hspi)
   1725          {
   1726            /* NOTE : This function should not be modified, when the callback is needed,
   1727                      the HAL_SPI_TxCpltCallback should be implemented in the user file
   1728             */
   1729          }
   \                     HAL_SPI_TxCpltCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1730          
   1731          /**
   1732            * @brief Rx Transfer completed callbacks
   1733            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   1734            *               the configuration information for SPI module.
   1735            * @retval None
   1736            */

   \                                 In section .text, align 2, keep-with-next
   1737          __weak void HAL_SPI_RxCpltCallback(SPI_HandleTypeDef *hspi)
   1738          {
   1739            /* NOTE : This function should not be modified, when the callback is needed,
   1740                      the HAL_SPI_RxCpltCallback should be implemented in the user file
   1741             */
   1742          }
   \                     HAL_SPI_RxCpltCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1743          
   1744          /**
   1745            * @brief Tx and Rx Transfer completed callback
   1746            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   1747            *               the configuration information for SPI module.
   1748            * @retval None
   1749            */

   \                                 In section .text, align 2, keep-with-next
   1750          __weak void HAL_SPI_TxRxCpltCallback(SPI_HandleTypeDef *hspi)
   1751          {
   1752            /* NOTE : This function should not be modified, when the callback is needed,
   1753                      the HAL_SPI_TxRxCpltCallback should be implemented in the user file
   1754             */
   1755          }
   \                     HAL_SPI_TxRxCpltCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1756          
   1757          /**
   1758            * @brief Tx Half Transfer completed callback
   1759            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   1760            *               the configuration information for SPI module.
   1761            * @retval None
   1762            */

   \                                 In section .text, align 2, keep-with-next
   1763          __weak void HAL_SPI_TxHalfCpltCallback(SPI_HandleTypeDef *hspi)
   1764          {
   1765            /* NOTE : This function should not be modified, when the callback is needed,
   1766                      the HAL_SPI_TxHalfCpltCallback should be implemented in the user file
   1767             */
   1768          }
   \                     HAL_SPI_TxHalfCpltCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1769          
   1770          /**
   1771            * @brief Rx Half Transfer completed callback
   1772            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   1773            *               the configuration information for SPI module.
   1774            * @retval None
   1775            */

   \                                 In section .text, align 2, keep-with-next
   1776          __weak void HAL_SPI_RxHalfCpltCallback(SPI_HandleTypeDef *hspi)
   1777          {
   1778            /* NOTE : This function should not be modified, when the callback is needed,
   1779                      the HAL_SPI_RxHalfCpltCallback() should be implemented in the user file
   1780             */
   1781          }
   \                     HAL_SPI_RxHalfCpltCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1782          
   1783          /**
   1784            * @brief Tx and Rx Half Transfer callback
   1785            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   1786            *               the configuration information for SPI module.
   1787            * @retval None
   1788            */

   \                                 In section .text, align 2, keep-with-next
   1789          __weak void HAL_SPI_TxRxHalfCpltCallback(SPI_HandleTypeDef *hspi)
   1790          {
   1791            /* NOTE : This function should not be modified, when the callback is needed,
   1792                      the HAL_SPI_TxRxHalfCpltCallback() should be implemented in the user file
   1793             */
   1794          }
   \                     HAL_SPI_TxRxHalfCpltCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1795          
   1796          /**
   1797            * @brief SPI error callback
   1798            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   1799            *               the configuration information for SPI module.
   1800            * @retval None
   1801            */

   \                                 In section .text, align 2, keep-with-next
   1802           __weak void HAL_SPI_ErrorCallback(SPI_HandleTypeDef *hspi)
   1803          {
   1804            /* NOTE : This function should not be modified, when the callback is needed,
   1805                      the HAL_SPI_ErrorCallback should be implemented in the user file
   1806             */
   1807            /* NOTE : The ErrorCode parameter in the hspi handle is updated by the SPI processes
   1808                      and user can use HAL_SPI_GetError() API to check the latest error occurred
   1809             */
   1810          }
   \                     HAL_SPI_ErrorCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1811          
   1812          /**
   1813            * @}
   1814            */
   1815          
   1816          /**
   1817            * @}
   1818            */
   1819          
   1820          /** @defgroup SPI_Exported_Functions_Group3 Peripheral State and Errors functions
   1821            *  @brief   SPI control functions
   1822            *
   1823          @verbatim
   1824           ===============================================================================
   1825                                ##### Peripheral State and Errors functions #####
   1826           ===============================================================================
   1827              [..]
   1828              This subsection provides a set of functions allowing to control the SPI.
   1829               (+) HAL_SPI_GetState() API can be helpful to check in run-time the state of the SPI peripheral
   1830               (+) HAL_SPI_GetError() check in run-time Errors occurring during communication
   1831          @endverbatim
   1832            * @{
   1833            */
   1834          
   1835          /**
   1836            * @brief  Return the SPI state
   1837            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   1838            *               the configuration information for SPI module.
   1839            * @retval SPI state
   1840            */

   \                                 In section .text, align 2, keep-with-next
   1841          HAL_SPI_StateTypeDef HAL_SPI_GetState(SPI_HandleTypeDef *hspi)
   1842          {
   1843            return hspi->State;
   \                     HAL_SPI_GetState: (+1)
   \   00000000   0xF890 0x005D      LDRB     R0,[R0, #+93]
   \   00000004   0x4770             BX       LR               ;; return
   1844          }
   1845          
   1846          /**
   1847            * @brief  Return the SPI error code
   1848            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   1849            *               the configuration information for SPI module.
   1850            * @retval SPI error code in bitmap format
   1851            */

   \                                 In section .text, align 2, keep-with-next
   1852          uint32_t HAL_SPI_GetError(SPI_HandleTypeDef *hspi)
   1853          {
   1854            return hspi->ErrorCode;
   \                     HAL_SPI_GetError: (+1)
   \   00000000   0x6E00             LDR      R0,[R0, #+96]
   \   00000002   0x4770             BX       LR               ;; return
   1855          }
   1856          
   1857          /**
   1858            * @}
   1859            */
   1860          
   1861          /**
   1862            * @}
   1863            */
   1864          
   1865          /** @defgroup SPI_Private_Functions SPI Private Functions
   1866            * @{
   1867            */
   1868          
   1869          /**
   1870            * @brief DMA SPI transmit process complete callback
   1871            * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
   1872            *               the configuration information for the specified DMA module.
   1873            * @retval None
   1874            */

   \                                 In section .text, align 4, keep-with-next
   1875          static void SPI_DMATransmitCplt(DMA_HandleTypeDef *hdma)
   1876          {
   \                     SPI_DMATransmitCplt: (+1)
   \   00000000   0x4601             MOV      R1,R0
   \   00000002   0xB580             PUSH     {R7,LR}
   1877            SPI_HandleTypeDef* hspi = ( SPI_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   \   00000004   0x6B88             LDR      R0,[R1, #+56]
   1878          
   1879            /* DMA Normal Mode */
   1880            if((hdma->Instance->CR & DMA_SxCR_CIRC) == 0)
   \   00000006   0x6809             LDR      R1,[R1, #+0]
   \   00000008   0x6809             LDR      R1,[R1, #+0]
   \   0000000A   0x05C9             LSLS     R1,R1,#+23
   \   0000000C   0xD40C             BMI.N    ??SPI_DMATransmitCplt_0
   1881            {
   1882              /* Disable Tx DMA Request */
   1883              CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN);
   \   0000000E   0x6801             LDR      R1,[R0, #+0]
   \   00000010   0x684A             LDR      R2,[R1, #+4]
   \   00000012   0xF022 0x0202      BIC      R2,R2,#0x2
   \   00000016   0x.... 0x....      BL       ?Subroutine35
   1884          
   1885              /* Clear OVERUN flag in 2 Lines communication mode because received data is not read */
   1886              if(hspi->Init.Direction == SPI_DIRECTION_2LINES)
   1887              {
   1888                __HAL_SPI_CLEAR_OVRFLAG(hspi);
   1889              }
   1890          
   1891              hspi->TxXferCount = 0;
   \                     ??CrossCallReturnLabel_77: (+1)
   \   0000001A   0x2100             MOVS     R1,#+0
   \   0000001C   0x87C1             STRH     R1,[R0, #+62]
   1892              hspi->State = HAL_SPI_STATE_READY;
   \   0000001E   0x.... 0x....      BL       ?Subroutine30
   1893          
   1894              if(hspi->ErrorCode != HAL_SPI_ERROR_NONE)
   \                     ??CrossCallReturnLabel_57: (+1)
   \   00000022   0x6E01             LDR      R1,[R0, #+96]
   \   00000024   0xB101             CBZ.N    R1,??SPI_DMATransmitCplt_0
   1895              {
   1896                HAL_SPI_ErrorCallback(hspi);
   \   00000026   0x....             B.N      ?Subroutine4
   1897                return;
   1898              }
   1899            }
   1900            HAL_SPI_TxCpltCallback(hspi);
   \                     ??SPI_DMATransmitCplt_0: (+1)
   \   00000028   0x....             B.N      ?Subroutine3
   1901          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine4: (+1)
   \   00000000   0x.... 0x....      BL       HAL_SPI_ErrorCallback
   \   00000004   0xBD01             POP      {R0,PC}

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine3: (+1)
   \   00000000   0x.... 0x....      BL       HAL_SPI_TxCpltCallback
   \   00000004   0xBD01             POP      {R0,PC}          ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine35: (+1)
   \   00000000   0x604A             STR      R2,[R1, #+4]
   \   00000002   0x6882             LDR      R2,[R0, #+8]
   \   00000004   0xB922             CBNZ.N   R2,??Subroutine35_0
   \   00000006   0x68CA             LDR      R2,[R1, #+12]
   \   00000008   0x9200             STR      R2,[SP, #+0]
   \   0000000A   0x6889             LDR      R1,[R1, #+8]
   \   0000000C   0x9100             STR      R1,[SP, #+0]
   \   0000000E   0x9900             LDR      R1,[SP, #+0]
   \                     ??Subroutine35_0: (+1)
   \   00000010   0x4770             BX       LR
   1902          
   1903          /**
   1904            * @brief DMA SPI receive process complete callback
   1905            * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
   1906            *               the configuration information for the specified DMA module.
   1907            * @retval None
   1908            */

   \                                 In section .text, align 4, keep-with-next
   1909          static void SPI_DMAReceiveCplt(DMA_HandleTypeDef *hdma)
   1910          {
   \                     SPI_DMAReceiveCplt: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   1911            __IO uint16_t tmpreg;
   1912            SPI_HandleTypeDef* hspi = ( SPI_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   \   00000004   0x6B84             LDR      R4,[R0, #+56]
   1913            
   1914            /* DMA Normal mode */
   1915            if((hdma->Instance->CR & DMA_SxCR_CIRC) == 0)
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0x6800             LDR      R0,[R0, #+0]
   \   0000000A   0x05C0             LSLS     R0,R0,#+23
   \   0000000C   0xD437             BMI.N    ??SPI_DMAReceiveCplt_0
   1916            {  
   1917              /* CRC handling */
   1918              if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   \   0000000E   0x.... 0x....      BL       ?Subroutine31
   \                     ??CrossCallReturnLabel_68: (+1)
   \   00000012   0xD115             BNE.N    ??CrossCallReturnLabel_76
   1919              {
   1920                /* Wait until TXE flag */
   1921                if(SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_RXNE, SPI_FLAG_RXNE, SPI_DEFAULT_TIMEOUT) != HAL_OK)
   \   00000014   0x2332             MOVS     R3,#+50
   \   00000016   0x.... 0x....      BL       ??Subroutine13_0
   \                     ??CrossCallReturnLabel_13: (+1)
   \   0000001A   0x.... 0x....      BL       ?Subroutine27
   1922                {
   1923                  /* Error on the CRC reception */
   1924                  hspi->ErrorCode|= HAL_SPI_ERROR_CRC;      
   1925                }
   1926                if(hspi->Init.DataSize > SPI_DATASIZE_8BIT)
   \                     ??CrossCallReturnLabel_50: (+1)
   \   0000001E   0x68E1             LDR      R1,[R4, #+12]
   \   00000020   0x6820             LDR      R0,[R4, #+0]
   \   00000022   0xF5B1 0x6FE0      CMP      R1,#+1792
   \   00000026   0xBF88             IT       HI 
   \   00000028   0x68C0             LDRHI    R0,[R0, #+12]
   1927                {        
   1928                  tmpreg = hspi->Instance->DR;
   \   0000002A   0xD807             BHI.N    ??CrossCallReturnLabel_46
   1929                  UNUSED(tmpreg); /* To avoid GCC warning */
   1930                }
   1931                else
   1932                {
   1933                  tmpreg = *(__IO uint8_t *)&hspi->Instance->DR;
   \   0000002C   0x.... 0x....      BL       ?Subroutine32
   1934                  UNUSED(tmpreg); /* To avoid GCC warning */
   1935                  
   1936                  if(hspi->Init.CRCLength == SPI_CRC_LENGTH_16BIT)
   \                     ??CrossCallReturnLabel_71: (+1)
   \   00000030   0xD106             BNE.N    ??CrossCallReturnLabel_76
   1937                  {
   1938                    if(SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_RXNE, SPI_FLAG_RXNE, SPI_DEFAULT_TIMEOUT) != HAL_OK)
   \   00000032   0x2332             MOVS     R3,#+50
   \   00000034   0x.... 0x....      BL       ??Subroutine13_0
   1939                    {
   1940                      /* Error on the CRC reception */
   1941                      hspi->ErrorCode|= HAL_SPI_ERROR_CRC;      
   1942                    }
   1943                    tmpreg = *(__IO uint8_t *)&hspi->Instance->DR;
   1944                    UNUSED(tmpreg); /* To avoid GCC warning */
   1945                  }
   1946                }  
   1947              }
   \                     ??CrossCallReturnLabel_12: (+1)
   \   00000038   0x.... 0x....      BL       ?Subroutine25
   \                     ??CrossCallReturnLabel_46: (+1)
   \   0000003C   0x.... 0x....      BL       ?Subroutine34
   1948              
   1949              /* Disable Rx DMA Request */
   1950              hspi->Instance->CR2 &= (uint32_t)(~SPI_CR2_RXDMAEN);
   \                     ??CrossCallReturnLabel_76: (+1)
   \   00000040   0x6820             LDR      R0,[R4, #+0]
   \   00000042   0x6841             LDR      R1,[R0, #+4]
   \   00000044   0x0849             LSRS     R1,R1,#+1
   \   00000046   0x0049             LSLS     R1,R1,#+1
   \   00000048   0x6041             STR      R1,[R0, #+4]
   1951              /* Disable Tx DMA Request (done by default to handle the case master rx direction 2 lines) */
   1952              hspi->Instance->CR2 &= (uint32_t)(~SPI_CR2_TXDMAEN);
   \   0000004A   0x6841             LDR      R1,[R0, #+4]
   \   0000004C   0xF021 0x0102      BIC      R1,R1,#0x2
   \   00000050   0x6041             STR      R1,[R0, #+4]
   1953              
   1954              /* Check the end of the transaction */
   1955              SPI_EndRxTransaction(hspi,SPI_DEFAULT_TIMEOUT);
   \   00000052   0x2132             MOVS     R1,#+50
   \   00000054   0x4620             MOV      R0,R4
   \   00000056   0x.... 0x....      BL       SPI_EndRxTransaction
   1956              
   1957              hspi->RxXferCount = 0;
   \   0000005A   0xF104 0x0046      ADD      R0,R4,#+70
   \   0000005E   0x2100             MOVS     R1,#+0
   \   00000060   0x8001             STRH     R1,[R0, #+0]
   1958              hspi->State = HAL_SPI_STATE_READY;
   \   00000062   0x2101             MOVS     R1,#+1
   \   00000064   0x75C1             STRB     R1,[R0, #+23]
   1959              
   1960              /* Check if CRC error occurred */
   1961              if(__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_CRCERR) != RESET)
   \   00000066   0x6821             LDR      R1,[R4, #+0]
   \   00000068   0x6E20             LDR      R0,[R4, #+96]
   \   0000006A   0x688A             LDR      R2,[R1, #+8]
   \   0000006C   0x06D2             LSLS     R2,R2,#+27
   \   0000006E   0xD502             BPL.N    ??SPI_DMAReceiveCplt_1
   1962              {
   1963                hspi->ErrorCode|= HAL_SPI_ERROR_CRC;
   \   00000070   0x.... 0x....      BL       ?Subroutine33
   1964                __HAL_SPI_CLEAR_CRCERRFLAG(hspi);
   1965                HAL_SPI_RxCpltCallback(hspi);
   \                     ??CrossCallReturnLabel_72: (+1)
   \   00000074   0xE003             B.N      ??SPI_DMAReceiveCplt_0
   1966              }
   1967              else
   1968              {
   1969                if(hspi->ErrorCode == HAL_SPI_ERROR_NONE)
   \                     ??SPI_DMAReceiveCplt_1: (+1)
   \   00000076   0x2800             CMP      R0,#+0
   \   00000078   0x4620             MOV      R0,R4
   \   0000007A   0xD001             BEQ.N    ??SPI_DMAReceiveCplt_2
   1970                {
   1971                  HAL_SPI_RxCpltCallback(hspi);
   1972                }
   1973                else
   1974                {
   1975                  HAL_SPI_ErrorCallback(hspi); 
   \   0000007C   0x....             B.N      ?Subroutine5
   1976                }
   1977              }
   1978            }
   1979            else
   1980            {
   1981              HAL_SPI_RxCpltCallback(hspi);
   \                     ??SPI_DMAReceiveCplt_0: (+1)
   \   0000007E   0x4620             MOV      R0,R4
   \                     ??SPI_DMAReceiveCplt_2: (+1)
   \   00000080   0x.... 0x....      BL       HAL_SPI_RxCpltCallback
   1982            }
   1983          }
   \   00000084   0xBD13             POP      {R0,R1,R4,PC}    ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine5: (+1)
   \   00000000   0x.... 0x....      BL       HAL_SPI_ErrorCallback
   \   00000004   0xBD13             POP      {R0,R1,R4,PC}

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine27: (+1)
   \   00000000   0xB118             CBZ.N    R0,??Subroutine27_0
   \   00000002   0x6E20             LDR      R0,[R4, #+96]
   \   00000004   0xF040 0x0002      ORR      R0,R0,#0x2
   \   00000008   0x6620             STR      R0,[R4, #+96]
   \                     ??Subroutine27_0: (+1)
   \   0000000A   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine25: (+1)
   \   00000000   0xB118             CBZ.N    R0,??Subroutine25_0
   \   00000002   0x6E20             LDR      R0,[R4, #+96]
   \   00000004   0xF040 0x0002      ORR      R0,R0,#0x2
   \   00000008   0x6620             STR      R0,[R4, #+96]
   \                     ??Subroutine25_0: (+1)
   \   0000000A   0x6820             LDR      R0,[R4, #+0]
   \   0000000C   0x7B00             LDRB     R0,[R0, #+12]
   \   0000000E   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine33: (+1)
   \   00000000   0xF040 0x0002      ORR      R0,R0,#0x2
   \   00000004   0x6620             STR      R0,[R4, #+96]
   \   00000006   0xF64F 0x70EF      MOVW     R0,#+65519
   \   0000000A   0x6088             STR      R0,[R1, #+8]
   \   0000000C   0x4770             BX       LR
   1984          
   1985          /**
   1986            * @brief DMA SPI transmit receive process complete callback
   1987            * @param  hdma : pointer to a DMA_HandleTypeDef structure that contains
   1988            *               the configuration information for the specified DMA module.
   1989            * @retval None
   1990            */

   \                                 In section .text, align 4, keep-with-next
   1991          static void SPI_DMATransmitReceiveCplt(DMA_HandleTypeDef *hdma)
   1992          {
   \                     SPI_DMATransmitReceiveCplt: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   1993            __IO int16_t tmpreg;
   1994            SPI_HandleTypeDef* hspi = ( SPI_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   \   00000004   0x6B84             LDR      R4,[R0, #+56]
   1995            
   1996            /* CRC handling */
   1997            if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   \   00000006   0x.... 0x....      BL       ?Subroutine31
   \                     ??CrossCallReturnLabel_69: (+1)
   \   0000000A   0xD11B             BNE.N    ??SPI_DMATransmitReceiveCplt_0
   1998            {
   1999              if((hspi->Init.DataSize == SPI_DATASIZE_8BIT) && (hspi->Init.CRCLength == SPI_CRC_LENGTH_8BIT))
   \   0000000C   0x68E0             LDR      R0,[R4, #+12]
   \   0000000E   0xF5B0 0x6FE0      CMP      R0,#+1792
   \   00000012   0xBF04             ITT      EQ 
   \   00000014   0x6B20             LDREQ    R0,[R4, #+48]
   \   00000016   0x2801             CMPEQ    R0,#+1
   \   00000018   0xD107             BNE.N    ??SPI_DMATransmitReceiveCplt_1
   2000              {        
   2001                if(SPI_WaitFifoStateUntilTimeout(hspi, SPI_FLAG_FRLVL, SPI_FRLVL_QUARTER_FULL, SPI_DEFAULT_TIMEOUT) != HAL_OK)
   \   0000001A   0x2332             MOVS     R3,#+50
   \   0000001C   0xF44F 0x7200      MOV      R2,#+512
   \   00000020   0x.... 0x....      BL       ?Subroutine22
   2002                {
   2003                  /* Error on the CRC reception */
   2004                  hspi->ErrorCode|= HAL_SPI_ERROR_CRC;      
   2005                }
   2006                tmpreg = *(__IO uint8_t *)&hspi->Instance->DR;
   2007                UNUSED(tmpreg); /* To avoid GCC warning */
   2008              }
   \                     ??CrossCallReturnLabel_41: (+1)
   \   00000024   0x.... 0x....      BL       ?Subroutine25
   \                     ??CrossCallReturnLabel_47: (+1)
   \   00000028   0xE008             B.N      ??SPI_DMATransmitReceiveCplt_2
   2009              else
   2010              {
   2011                if(SPI_WaitFifoStateUntilTimeout(hspi, SPI_FLAG_FRLVL, SPI_FRLVL_HALF_FULL, SPI_DEFAULT_TIMEOUT) != HAL_OK)
   \                     ??SPI_DMATransmitReceiveCplt_1: (+1)
   \   0000002A   0x2332             MOVS     R3,#+50
   \   0000002C   0xF44F 0x6280      MOV      R2,#+1024
   \   00000030   0x.... 0x....      BL       ?Subroutine22
   \                     ??CrossCallReturnLabel_40: (+1)
   \   00000034   0x.... 0x....      BL       ?Subroutine27
   2012                {
   2013                  /* Error on the CRC reception */
   2014                  hspi->ErrorCode|= HAL_SPI_ERROR_CRC;      
   2015                }
   2016                tmpreg = hspi->Instance->DR;
   \                     ??CrossCallReturnLabel_51: (+1)
   \   00000038   0x6820             LDR      R0,[R4, #+0]
   \   0000003A   0x68C0             LDR      R0,[R0, #+12]
   \                     ??SPI_DMATransmitReceiveCplt_2: (+1)
   \   0000003C   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   2017                UNUSED(tmpreg); /* To avoid GCC warning */
   \   00000040   0xF9BD 0x0000      LDRSH    R0,[SP, #+0]
   2018              }
   2019            }  
   2020            
   2021            /* Check the end of the transaction */
   2022            SPI_EndRxTxTransaction(hspi,SPI_DEFAULT_TIMEOUT);
   \                     ??SPI_DMATransmitReceiveCplt_0: (+1)
   \   00000044   0x2132             MOVS     R1,#+50
   \   00000046   0x4620             MOV      R0,R4
   \   00000048   0x.... 0x....      BL       SPI_EndRxTxTransaction
   2023            
   2024            /* Disable Tx DMA Request */
   2025            CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN);
   \   0000004C   0x6820             LDR      R0,[R4, #+0]
   2026            
   2027            /* Disable Rx DMA Request */
   2028            CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_RXDMAEN);
   2029             
   2030            hspi->TxXferCount = 0;
   2031            hspi->RxXferCount = 0;
   \   0000004E   0x2200             MOVS     R2,#+0
   \   00000050   0x6841             LDR      R1,[R0, #+4]
   \   00000052   0xF021 0x0102      BIC      R1,R1,#0x2
   \   00000056   0x6041             STR      R1,[R0, #+4]
   \   00000058   0x6841             LDR      R1,[R0, #+4]
   \   0000005A   0x0849             LSRS     R1,R1,#+1
   \   0000005C   0x0049             LSLS     R1,R1,#+1
   \   0000005E   0x6041             STR      R1,[R0, #+4]
   \   00000060   0x2100             MOVS     R1,#+0
   \   00000062   0x87E1             STRH     R1,[R4, #+62]
   \   00000064   0xF104 0x0146      ADD      R1,R4,#+70
   \   00000068   0x800A             STRH     R2,[R1, #+0]
   2032            hspi->State = HAL_SPI_STATE_READY;
   \   0000006A   0x2201             MOVS     R2,#+1
   \   0000006C   0x75CA             STRB     R2,[R1, #+23]
   2033            
   2034            /* Check if CRC error occurred */
   2035            if(__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_CRCERR) != RESET)
   \   0000006E   0x6881             LDR      R1,[R0, #+8]
   \   00000070   0x06C9             LSLS     R1,R1,#+27
   \   00000072   0xD506             BPL.N    ??SPI_DMATransmitReceiveCplt_3
   2036            {
   2037              hspi->ErrorCode = HAL_SPI_ERROR_CRC;
   \   00000074   0x2102             MOVS     R1,#+2
   \   00000076   0x6621             STR      R1,[R4, #+96]
   2038              __HAL_SPI_CLEAR_CRCERRFLAG(hspi);
   \   00000078   0xF64F 0x71EF      MOVW     R1,#+65519
   \   0000007C   0x6081             STR      R1,[R0, #+8]
   2039              HAL_SPI_ErrorCallback(hspi);
   \   0000007E   0x4620             MOV      R0,R4
   \   00000080   0xE006             B.N      ??SPI_DMATransmitReceiveCplt_4
   2040            }
   2041            else
   2042            {     
   2043              if(hspi->ErrorCode == HAL_SPI_ERROR_NONE)
   \                     ??SPI_DMATransmitReceiveCplt_3: (+1)
   \   00000082   0x6E20             LDR      R0,[R4, #+96]
   \   00000084   0x2800             CMP      R0,#+0
   \   00000086   0x4620             MOV      R0,R4
   \   00000088   0xD102             BNE.N    ??SPI_DMATransmitReceiveCplt_4
   2044              {
   2045                HAL_SPI_TxRxCpltCallback(hspi);
   \   0000008A   0x.... 0x....      BL       HAL_SPI_TxRxCpltCallback
   \   0000008E   0xBD13             POP      {R0,R1,R4,PC}
   2046              }
   2047              else
   2048              {
   2049                HAL_SPI_ErrorCallback(hspi);
   \                     ??SPI_DMATransmitReceiveCplt_4: (+1)
   \   00000090                      REQUIRE ?Subroutine5
   \   00000090                      ;; // Fall through to label ?Subroutine5
   2050              }
   2051            }
   2052          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine22: (+1)
   \   00000000   0xF44F 0x61C0      MOV      R1,#+1536
   \   00000004   0x4620             MOV      R0,R4
   \   00000006   0x....             B.N      SPI_WaitFifoStateUntilTimeout
   2053          
   2054          /**
   2055            * @brief DMA SPI half transmit process complete callback
   2056            * @param  hdma : pointer to a DMA_HandleTypeDef structure that contains
   2057            *               the configuration information for the specified DMA module.
   2058            * @retval None
   2059            */

   \                                 In section .text, align 4, keep-with-next
   2060          static void SPI_DMAHalfTransmitCplt(DMA_HandleTypeDef *hdma)
   2061          {
   \                     SPI_DMAHalfTransmitCplt: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   2062            SPI_HandleTypeDef* hspi = ( SPI_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   2063          
   2064            HAL_SPI_TxHalfCpltCallback(hspi);
   \   00000002   0x6B80             LDR      R0,[R0, #+56]
   \   00000004   0x.... 0x....      BL       HAL_SPI_TxHalfCpltCallback
   2065          }
   \   00000008   0xBD01             POP      {R0,PC}          ;; return
   2066          
   2067          /**
   2068            * @brief DMA SPI half receive process complete callback
   2069            * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
   2070            *               the configuration information for the specified DMA module.
   2071            * @retval None
   2072            */

   \                                 In section .text, align 4, keep-with-next
   2073          static void SPI_DMAHalfReceiveCplt(DMA_HandleTypeDef *hdma)
   2074          {
   \                     SPI_DMAHalfReceiveCplt: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   2075            SPI_HandleTypeDef* hspi = ( SPI_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   2076          
   2077            HAL_SPI_RxHalfCpltCallback(hspi);
   \   00000002   0x6B80             LDR      R0,[R0, #+56]
   \   00000004   0x.... 0x....      BL       HAL_SPI_RxHalfCpltCallback
   2078          }
   \   00000008   0xBD01             POP      {R0,PC}          ;; return
   2079          
   2080          /**
   2081            * @brief DMA SPI Half transmit receive process complete callback
   2082            * @param  hdma : pointer to a DMA_HandleTypeDef structure that contains
   2083            *               the configuration information for the specified DMA module.
   2084            * @retval None
   2085            */

   \                                 In section .text, align 4, keep-with-next
   2086          static void SPI_DMAHalfTransmitReceiveCplt(DMA_HandleTypeDef *hdma)
   2087          {
   \                     SPI_DMAHalfTransmitReceiveCplt: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   2088            SPI_HandleTypeDef* hspi = ( SPI_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   2089          
   2090            HAL_SPI_TxRxHalfCpltCallback(hspi);
   \   00000002   0x6B80             LDR      R0,[R0, #+56]
   \   00000004   0x.... 0x....      BL       HAL_SPI_TxRxHalfCpltCallback
   2091          }
   \   00000008   0xBD01             POP      {R0,PC}          ;; return
   2092          
   2093          /**
   2094            * @brief DMA SPI communication error callback
   2095            * @param  hdma : pointer to a DMA_HandleTypeDef structure that contains
   2096            *               the configuration information for the specified DMA module.
   2097            * @retval None
   2098            */

   \                                 In section .text, align 4, keep-with-next
   2099          static void SPI_DMAError(DMA_HandleTypeDef *hdma)
   2100          {
   \                     SPI_DMAError: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   2101            SPI_HandleTypeDef* hspi = ( SPI_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   \   00000002   0x6B80             LDR      R0,[R0, #+56]
   2102          
   2103            /* Stop the disable DMA transfer on SPI side */
   2104            CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);
   \   00000004   0x6801             LDR      R1,[R0, #+0]
   \   00000006   0x684A             LDR      R2,[R1, #+4]
   \   00000008   0x0892             LSRS     R2,R2,#+2
   \   0000000A   0x0092             LSLS     R2,R2,#+2
   \   0000000C   0x604A             STR      R2,[R1, #+4]
   2105          
   2106            hspi->ErrorCode|= HAL_SPI_ERROR_DMA;
   \   0000000E   0x6E01             LDR      R1,[R0, #+96]
   \   00000010   0xF041 0x0110      ORR      R1,R1,#0x10
   \   00000014   0xF8C0 0x1060      STR.W    R1,[R0, #+96]
   2107            hspi->State = HAL_SPI_STATE_READY;
   \   00000018   0x.... 0x....      BL       ?Subroutine30
   2108            HAL_SPI_ErrorCallback(hspi);
   \                     ??CrossCallReturnLabel_58: (+1)
   \   0000001C                      REQUIRE ?Subroutine4
   \   0000001C                      ;; // Fall through to label ?Subroutine4
   2109          }
   2110          
   2111          /**
   2112            * @brief  Rx Handler for Transmit and Receive in Interrupt mode
   2113            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   2114            *               the configuration information for SPI module.
   2115            * @retval None
   2116            */

   \                                 In section .text, align 4, keep-with-next
   2117          static void SPI_2linesRxISR_8BIT(struct __SPI_HandleTypeDef *hspi)
   2118          {
   2119            /* Receive data in packing mode */
   2120            if(hspi->RxXferCount > 1)
   \                     SPI_2linesRxISR_8BIT: (+1)
   \   00000000   0xF8B0 0x3046      LDRH     R3,[R0, #+70]
   \   00000004   0x6C02             LDR      R2,[R0, #+64]
   \   00000006   0x6801             LDR      R1,[R0, #+0]
   \   00000008   0x2B02             CMP      R3,#+2
   \   0000000A   0xDB0F             BLT.N    ??SPI_2linesRxISR_8BIT_0
   2121            {
   2122              *((uint16_t*)hspi->pRxBuffPtr) = hspi->Instance->DR;
   \   0000000C   0x68CB             LDR      R3,[R1, #+12]
   \   0000000E   0xF822 0x3B02      STRH     R3,[R2], #+2
   2123              hspi->pRxBuffPtr += sizeof(uint16_t);
   2124              hspi->RxXferCount -= 2;
   \   00000012   0xF8B0 0x3046      LDRH     R3,[R0, #+70]
   \   00000016   0x1E9B             SUBS     R3,R3,#+2
   \   00000018   0xF8A0 0x3046      STRH     R3,[R0, #+70]
   2125              if(hspi->RxXferCount == 1)
   \   0000001C   0xB29B             UXTH     R3,R3
   \   0000001E   0x2B01             CMP      R3,#+1
   \   00000020   0xD10C             BNE.N    ??SPI_2linesRxISR_8BIT_1
   2126              {
   2127                /* set fiforxthreshold according the reception data length: 8bit */
   2128                SET_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
   \   00000022   0x684B             LDR      R3,[R1, #+4]
   \   00000024   0xF443 0x5380      ORR      R3,R3,#0x1000
   \   00000028   0x604B             STR      R3,[R1, #+4]
   \   0000002A   0xE007             B.N      ??SPI_2linesRxISR_8BIT_1
   2129              }
   2130            }
   2131            /* Receive data in 8 Bit mode */
   2132            else
   2133            {
   2134              *hspi->pRxBuffPtr++ = *((__IO uint8_t *)&hspi->Instance->DR);
   \                     ??SPI_2linesRxISR_8BIT_0: (+1)
   \   0000002C   0x7B0B             LDRB     R3,[R1, #+12]
   \   0000002E   0xF802 0x3B01      STRB     R3,[R2], #+1
   2135              hspi->RxXferCount--;
   \   00000032   0xF8B0 0x3046      LDRH     R3,[R0, #+70]
   \   00000036   0x1E5B             SUBS     R3,R3,#+1
   \   00000038   0xF8A0 0x3046      STRH     R3,[R0, #+70]
   \                     ??SPI_2linesRxISR_8BIT_1: (+1)
   \   0000003C   0x6402             STR      R2,[R0, #+64]
   2136            }
   2137            
   2138            /* check end of the reception */
   2139            if(hspi->RxXferCount == 0)
   \   0000003E   0xF8B0 0x2046      LDRH     R2,[R0, #+70]
   \   00000042   0xB99A             CBNZ.N   R2,??SPI_2linesRxISR_8BIT_2
   2140            {
   2141              if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   \   00000044   0x6A82             LDR      R2,[R0, #+40]
   \   00000046   0xF5B2 0x5F00      CMP      R2,#+8192
   \   0000004A   0x684A             LDR      R2,[R1, #+4]
   \   0000004C   0xD106             BNE.N    ??SPI_2linesRxISR_8BIT_3
   2142              {
   2143                SET_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
   \   0000004E   0xF442 0x5280      ORR      R2,R2,#0x1000
   \   00000052   0x604A             STR      R2,[R1, #+4]
   2144                hspi->RxISR =  SPI_2linesRxISR_8BITCRC;
   \   00000054   0x.... 0x....      ADR.W    R1,SPI_2linesRxISR_8BITCRC
   \   00000058   0x64C1             STR      R1,[R0, #+76]
   2145                return;
   \   0000005A   0x4770             BX       LR
   2146              }
   2147                  
   2148              /* Disable RXNE interrupt */
   2149              __HAL_SPI_DISABLE_IT(hspi, SPI_IT_RXNE);
   \                     ??SPI_2linesRxISR_8BIT_3: (+1)
   \   0000005C   0xF022 0x0240      BIC      R2,R2,#0x40
   \   00000060   0x604A             STR      R2,[R1, #+4]
   2150          
   2151              if(hspi->TxXferCount == 0)
   \   00000062   0x8FC1             LDRH     R1,[R0, #+62]
   \   00000064   0x2900             CMP      R1,#+0
   \   00000066   0xBF08             IT       EQ 
   2152              {
   2153                SPI_CloseRxTx_ISR(hspi);
   \   00000068   0x.... 0x....      BEQ.W    SPI_CloseRxTx_ISR
   2154              }
   2155            }
   2156          }
   \                     ??SPI_2linesRxISR_8BIT_2: (+1)
   \   0000006C   0x4770             BX       LR               ;; return
   2157          
   2158          /**
   2159            * @brief  Rx Handler for Transmit and Receive in Interrupt mode
   2160            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   2161            *               the configuration information for SPI module.
   2162            * @retval None
   2163            */

   \                                 In section .text, align 4, keep-with-next
   2164          static void SPI_2linesRxISR_8BITCRC(struct __SPI_HandleTypeDef *hspi)
   2165          {
   \                     SPI_2linesRxISR_8BITCRC: (+1)
   \   00000000   0xB082             SUB      SP,SP,#+8
   2166            __IO uint8_t tmpreg;
   2167            
   2168            tmpreg = *((__IO uint8_t *)&hspi->Instance->DR);
   \   00000002   0x6801             LDR      R1,[R0, #+0]
   \   00000004   0x7B0A             LDRB     R2,[R1, #+12]
   \   00000006   0xF88D 0x2000      STRB     R2,[SP, #+0]
   2169            UNUSED(tmpreg); /* To avoid GCC warning */
   \   0000000A   0xF89D 0x2000      LDRB     R2,[SP, #+0]
   2170          
   2171            hspi->CRCSize--;
   \   0000000E   0x6C82             LDR      R2,[R0, #+72]
   \   00000010   0x1E52             SUBS     R2,R2,#+1
   \   00000012   0x6482             STR      R2,[R0, #+72]
   2172            
   2173            /* check end of the reception */
   2174            if(hspi->CRCSize == 0)
   \   00000014   0xD106             BNE.N    ??SPI_2linesRxISR_8BITCRC_0
   2175            {
   2176              /* Disable RXNE interrupt */
   2177              __HAL_SPI_DISABLE_IT(hspi, SPI_IT_RXNE);
   \   00000016   0x684A             LDR      R2,[R1, #+4]
   \   00000018   0xF022 0x0240      BIC      R2,R2,#0x40
   \   0000001C   0x604A             STR      R2,[R1, #+4]
   2178          
   2179              if(hspi->TxXferCount == 0)
   \   0000001E   0x8FC1             LDRH     R1,[R0, #+62]
   \   00000020   0xB901             CBNZ.N   R1,??SPI_2linesRxISR_8BITCRC_0
   2180              {
   2181                SPI_CloseRxTx_ISR(hspi);
   \   00000022   0x....             B.N      ?Subroutine6
   2182              }
   2183            }
   2184          }
   \                     ??SPI_2linesRxISR_8BITCRC_0: (+1)
   \   00000024   0xB002             ADD      SP,SP,#+8
   \   00000026   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine6: (+1)
   \   00000000   0xB002             ADD      SP,SP,#+8
   \   00000002   0x....             B.N      SPI_CloseRxTx_ISR
   2185          
   2186          /**
   2187            * @brief  Tx Handler for Transmit and Receive in Interrupt mode
   2188            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   2189            *               the configuration information for SPI module.
   2190            * @retval None
   2191            */

   \                                 In section .text, align 4, keep-with-next
   2192          static void SPI_2linesTxISR_8BIT(struct __SPI_HandleTypeDef *hspi)
   2193          {
   \                     SPI_2linesTxISR_8BIT: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   2194            /* Transmit data in packing Bit mode */
   2195            if(hspi->TxXferCount >= 2)
   \   00000002   0x8FC3             LDRH     R3,[R0, #+62]
   \   00000004   0x6B82             LDR      R2,[R0, #+56]
   \   00000006   0x6801             LDR      R1,[R0, #+0]
   \   00000008   0x2B02             CMP      R3,#+2
   \   0000000A   0xDB04             BLT.N    ??SPI_2linesTxISR_8BIT_0
   2196            {
   2197              hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
   \   0000000C   0xF832 0x4B02      LDRH     R4,[R2], #+2
   2198              hspi->pTxBuffPtr += sizeof(uint16_t);
   2199              hspi->TxXferCount -= 2;
   \   00000010   0x1E9B             SUBS     R3,R3,#+2
   \   00000012   0x60CC             STR      R4,[R1, #+12]
   \   00000014   0xE004             B.N      ??SPI_2linesTxISR_8BIT_1
   2200            }
   2201            /* Transmit data in 8 Bit mode */
   2202            else
   2203            {        
   2204              *(__IO uint8_t *)&hspi->Instance->DR = (*hspi->pTxBuffPtr++);
   \                     ??SPI_2linesTxISR_8BIT_0: (+1)
   \   00000016   0xF812 0x3B01      LDRB     R3,[R2], #+1
   \   0000001A   0x730B             STRB     R3,[R1, #+12]
   2205              hspi->TxXferCount--;
   \   0000001C   0x8FC3             LDRH     R3,[R0, #+62]
   \   0000001E   0x1E5B             SUBS     R3,R3,#+1
   \                     ??SPI_2linesTxISR_8BIT_1: (+1)
   \   00000020   0x87C3             STRH     R3,[R0, #+62]
   \   00000022   0x6382             STR      R2,[R0, #+56]
   2206            }
   2207            
   2208            /* check the end of the transmission */
   2209            if(hspi->TxXferCount == 0)
   \   00000024   0x8FC2             LDRH     R2,[R0, #+62]
   \   00000026   0xB99A             CBNZ.N   R2,??SPI_2linesTxISR_8BIT_2
   2210            {
   2211              if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   \   00000028   0x6A82             LDR      R2,[R0, #+40]
   \   0000002A   0xF5B2 0x5F00      CMP      R2,#+8192
   \   0000002E   0xD103             BNE.N    ??SPI_2linesTxISR_8BIT_3
   2212              {
   2213                hspi->Instance->CR1 |= SPI_CR1_CRCNEXT;
   \   00000030   0x680A             LDR      R2,[R1, #+0]
   \   00000032   0xF442 0x5280      ORR      R2,R2,#0x1000
   \   00000036   0x600A             STR      R2,[R1, #+0]
   2214              }
   2215              /* Disable TXE interrupt */
   2216              __HAL_SPI_DISABLE_IT(hspi, SPI_IT_TXE);
   \                     ??SPI_2linesTxISR_8BIT_3: (+1)
   \   00000038   0x684A             LDR      R2,[R1, #+4]
   \   0000003A   0xF022 0x0280      BIC      R2,R2,#0x80
   \   0000003E   0x604A             STR      R2,[R1, #+4]
   2217              
   2218              if(hspi->RxXferCount == 0)
   \   00000040   0xF8B0 0x1046      LDRH     R1,[R0, #+70]
   \   00000044   0x2900             CMP      R1,#+0
   \   00000046   0xBF04             ITT      EQ 
   2219              { 
   2220                SPI_CloseRxTx_ISR(hspi);
   \   00000048   0xE8BD 0x4010      POPEQ    {R4,LR}
   \   0000004C   0x.... 0x....      BEQ.W    SPI_CloseRxTx_ISR
   2221              }
   2222            }
   2223          }
   \                     ??SPI_2linesTxISR_8BIT_2: (+1)
   \   00000050   0xBD10             POP      {R4,PC}          ;; return
   2224          
   2225          /**
   2226            * @brief  Rx 16Bit Handler for Transmit and Receive in Interrupt mode
   2227            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   2228            *               the configuration information for SPI module.
   2229            * @retval None
   2230            */

   \                                 In section .text, align 4, keep-with-next
   2231          static void SPI_2linesRxISR_16BIT(struct __SPI_HandleTypeDef *hspi)
   2232          {
   2233            /* Receive data in 16 Bit mode */
   2234            *((uint16_t*)hspi->pRxBuffPtr) = hspi->Instance->DR;
   \                     SPI_2linesRxISR_16BIT: (+1)
   \   00000000   0x6802             LDR      R2,[R0, #+0]
   \   00000002   0x6C01             LDR      R1,[R0, #+64]
   \   00000004   0x68D3             LDR      R3,[R2, #+12]
   \   00000006   0xF821 0x3B02      STRH     R3,[R1], #+2
   2235            hspi->pRxBuffPtr += sizeof(uint16_t);
   \   0000000A   0x6401             STR      R1,[R0, #+64]
   2236            hspi->RxXferCount--;
   \   0000000C   0xF8B0 0x1046      LDRH     R1,[R0, #+70]
   \   00000010   0x1E49             SUBS     R1,R1,#+1
   \   00000012   0xF8A0 0x1046      STRH     R1,[R0, #+70]
   2237          
   2238            if(hspi->RxXferCount == 0)
   \   00000016   0xB289             UXTH     R1,R1
   \   00000018   0xB981             CBNZ.N   R1,??SPI_2linesRxISR_16BIT_0
   2239            {
   2240              if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   \   0000001A   0x6A81             LDR      R1,[R0, #+40]
   \   0000001C   0xF5B1 0x5F00      CMP      R1,#+8192
   \   00000020   0xD103             BNE.N    ??SPI_2linesRxISR_16BIT_1
   2241              {
   2242                hspi->RxISR =  SPI_2linesRxISR_16BITCRC;
   \   00000022   0x.... 0x....      ADR.W    R1,SPI_2linesRxISR_16BITCRC
   \   00000026   0x64C1             STR      R1,[R0, #+76]
   2243                return;
   \   00000028   0x4770             BX       LR
   2244              }
   2245              
   2246              /* Disable RXNE interrupt */
   2247              __HAL_SPI_DISABLE_IT(hspi, SPI_IT_RXNE);
   \                     ??SPI_2linesRxISR_16BIT_1: (+1)
   \   0000002A   0x6851             LDR      R1,[R2, #+4]
   \   0000002C   0xF021 0x0140      BIC      R1,R1,#0x40
   \   00000030   0x6051             STR      R1,[R2, #+4]
   2248          
   2249              if(hspi->TxXferCount == 0)
   \   00000032   0x8FC1             LDRH     R1,[R0, #+62]
   \   00000034   0x2900             CMP      R1,#+0
   \   00000036   0xBF08             IT       EQ 
   2250              {
   2251                SPI_CloseRxTx_ISR(hspi);
   \   00000038   0x.... 0x....      BEQ.W    SPI_CloseRxTx_ISR
   2252              }
   2253            }
   2254          }
   \                     ??SPI_2linesRxISR_16BIT_0: (+1)
   \   0000003C   0x4770             BX       LR               ;; return
   2255          
   2256          /**
   2257            * @brief  Manage the CRC 16bit receive for Transmit and Receive in Interrupt mode
   2258            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   2259            *               the configuration information for SPI module.
   2260            * @retval None
   2261            */

   \                                 In section .text, align 4, keep-with-next
   2262          static void SPI_2linesRxISR_16BITCRC(struct __SPI_HandleTypeDef *hspi)
   2263          {
   \                     SPI_2linesRxISR_16BITCRC: (+1)
   \   00000000   0xB082             SUB      SP,SP,#+8
   2264            /* Receive data in 16 Bit mode */
   2265            __IO uint16_t tmpreg = hspi->Instance->DR;
   \   00000002   0x6801             LDR      R1,[R0, #+0]
   \   00000004   0x68CA             LDR      R2,[R1, #+12]
   \   00000006   0xF8AD 0x2000      STRH     R2,[SP, #+0]
   2266            UNUSED(tmpreg); /* To avoid GCC warning */
   \   0000000A   0xF8BD 0x2000      LDRH     R2,[SP, #+0]
   2267          
   2268            /* Disable RXNE interrupt */
   2269            __HAL_SPI_DISABLE_IT(hspi, SPI_IT_RXNE);
   \   0000000E   0x684A             LDR      R2,[R1, #+4]
   \   00000010   0xF022 0x0240      BIC      R2,R2,#0x40
   \   00000014   0xF8C1 0x2004      STR.W    R2,[R1, #+4]
   2270          
   2271            SPI_CloseRxTx_ISR(hspi);
   \   00000018                      REQUIRE ?Subroutine6
   \   00000018                      ;; // Fall through to label ?Subroutine6
   2272          }
   2273          
   2274          /**
   2275            * @brief  Tx Handler for Transmit and Receive in Interrupt mode
   2276            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   2277            *               the configuration information for SPI module.
   2278            * @retval None
   2279            */

   \                                 In section .text, align 4, keep-with-next
   2280          static void SPI_2linesTxISR_16BIT(struct __SPI_HandleTypeDef *hspi)
   2281          {
   2282            /* Transmit data in 16 Bit mode */
   2283            hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
   \                     SPI_2linesTxISR_16BIT: (+1)
   \   00000000   0x6B81             LDR      R1,[R0, #+56]
   \   00000002   0x6802             LDR      R2,[R0, #+0]
   \   00000004   0xF831 0x3B02      LDRH     R3,[R1], #+2
   \   00000008   0x60D3             STR      R3,[R2, #+12]
   2284            hspi->pTxBuffPtr += sizeof(uint16_t);
   \   0000000A   0x6381             STR      R1,[R0, #+56]
   2285            hspi->TxXferCount--;
   \   0000000C   0x8FC1             LDRH     R1,[R0, #+62]
   \   0000000E   0x1E49             SUBS     R1,R1,#+1
   \   00000010   0x87C1             STRH     R1,[R0, #+62]
   2286            
   2287            /* Enable CRC Transmission */
   2288            if(hspi->TxXferCount == 0)
   \   00000012   0xB289             UXTH     R1,R1
   \   00000014   0xB989             CBNZ.N   R1,??SPI_2linesTxISR_16BIT_0
   2289            {
   2290              if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   \   00000016   0x6A81             LDR      R1,[R0, #+40]
   \   00000018   0xF5B1 0x5F00      CMP      R1,#+8192
   \   0000001C   0xD103             BNE.N    ??SPI_2linesTxISR_16BIT_1
   2291              {
   2292                hspi->Instance->CR1 |= SPI_CR1_CRCNEXT;
   \   0000001E   0x6811             LDR      R1,[R2, #+0]
   \   00000020   0xF441 0x5180      ORR      R1,R1,#0x1000
   \   00000024   0x6011             STR      R1,[R2, #+0]
   2293              }
   2294              /* Disable TXE interrupt */
   2295              __HAL_SPI_DISABLE_IT(hspi, SPI_IT_TXE);
   \                     ??SPI_2linesTxISR_16BIT_1: (+1)
   \   00000026   0x6851             LDR      R1,[R2, #+4]
   \   00000028   0xF021 0x0180      BIC      R1,R1,#0x80
   \   0000002C   0x6051             STR      R1,[R2, #+4]
   2296          
   2297              if(hspi->RxXferCount == 0)
   \   0000002E   0xF8B0 0x1046      LDRH     R1,[R0, #+70]
   \   00000032   0x2900             CMP      R1,#+0
   \   00000034   0xBF08             IT       EQ 
   2298              {
   2299                SPI_CloseRxTx_ISR(hspi);
   \   00000036   0x.... 0x....      BEQ.W    SPI_CloseRxTx_ISR
   2300              }
   2301            }
   2302          }
   \                     ??SPI_2linesTxISR_16BIT_0: (+1)
   \   0000003A   0x4770             BX       LR               ;; return
   2303          
   2304          /**
   2305            * @brief  Manage the CRC receive in Interrupt context
   2306            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   2307            *               the configuration information for SPI module.
   2308            * @retval None
   2309            */

   \                                 In section .text, align 2, keep-with-next
   2310          static void SPI_RxISR_8BITCRC(struct __SPI_HandleTypeDef *hspi)
   2311          {
   \                     SPI_RxISR_8BITCRC: (+1)
   \   00000000   0xB082             SUB      SP,SP,#+8
   2312            __IO uint8_t tmpreg;
   2313            tmpreg = *((__IO uint8_t*)&hspi->Instance->DR);
   \   00000002   0x6801             LDR      R1,[R0, #+0]
   \   00000004   0x7B09             LDRB     R1,[R1, #+12]
   \   00000006   0xF88D 0x1000      STRB     R1,[SP, #+0]
   2314            UNUSED(tmpreg); /* To avoid GCC warning */
   \   0000000A   0xF89D 0x1000      LDRB     R1,[SP, #+0]
   2315          
   2316            hspi->CRCSize--;
   \   0000000E   0x6C81             LDR      R1,[R0, #+72]
   \   00000010   0x1E49             SUBS     R1,R1,#+1
   \   00000012   0x6481             STR      R1,[R0, #+72]
   2317            
   2318            if(hspi->CRCSize == 0)
   \   00000014   0xD100             BNE.N    ??SPI_RxISR_8BITCRC_0
   2319            { 
   2320              SPI_CloseRx_ISR(hspi);
   \   00000016   0x....             B.N      ?Subroutine7
   2321            }
   2322          }
   \                     ??SPI_RxISR_8BITCRC_0: (+1)
   \   00000018   0xB002             ADD      SP,SP,#+8
   \   0000001A   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine7: (+1)
   \   00000000   0xB002             ADD      SP,SP,#+8
   \   00000002   0x....             B.N      SPI_CloseRx_ISR
   2323          
   2324          /**
   2325            * @brief  Manage the receive in Interrupt context
   2326            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   2327            *               the configuration information for SPI module.
   2328            * @retval None
   2329            */

   \                                 In section .text, align 4, keep-with-next
   2330          static void SPI_RxISR_8BIT(struct __SPI_HandleTypeDef *hspi)
   2331          {
   2332            *hspi->pRxBuffPtr++ = (*(__IO uint8_t *)&hspi->Instance->DR);
   \                     SPI_RxISR_8BIT: (+1)
   \   00000000   0x6C01             LDR      R1,[R0, #+64]
   \   00000002   0x1C4A             ADDS     R2,R1,#+1
   \   00000004   0x6402             STR      R2,[R0, #+64]
   \   00000006   0x6802             LDR      R2,[R0, #+0]
   \   00000008   0x7B13             LDRB     R3,[R2, #+12]
   \   0000000A   0x700B             STRB     R3,[R1, #+0]
   2333            hspi->RxXferCount--;
   \   0000000C   0xF8B0 0x1046      LDRH     R1,[R0, #+70]
   \   00000010   0x1E49             SUBS     R1,R1,#+1
   \   00000012   0xF8A0 0x1046      STRH     R1,[R0, #+70]
   2334          
   2335            /* Enable CRC Transmission */
   2336            if((hspi->RxXferCount == 1) && (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE))
   \   00000016   0xB289             UXTH     R1,R1
   \   00000018   0x2901             CMP      R1,#+1
   \   0000001A   0xD104             BNE.N    ??SPI_RxISR_8BIT_0
   \   0000001C   0x6A80             LDR      R0,[R0, #+40]
   \   0000001E   0xF5B0 0x5F00      CMP      R0,#+8192
   \   00000022   0xD109             BNE.N    ??SPI_RxISR_8BIT_1
   2337            {
   2338              hspi->Instance->CR1 |= SPI_CR1_CRCNEXT;
   \   00000024   0x....             B.N      ?Subroutine2
   2339            }
   2340          
   2341            if(hspi->RxXferCount == 0)
   \                     ??SPI_RxISR_8BIT_0: (+1)
   \   00000026   0xB939             CBNZ.N   R1,??SPI_RxISR_8BIT_1
   2342            {
   2343              if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   \   00000028   0x6A81             LDR      R1,[R0, #+40]
   \   0000002A   0xF5B1 0x5F00      CMP      R1,#+8192
   \   0000002E   0xBF18             IT       NE 
   2344              {
   2345                hspi->RxISR =  SPI_RxISR_8BITCRC;
   2346                return;
   2347              }
   2348              SPI_CloseRx_ISR(hspi);
   \   00000030   0x.... 0x....      BNE.W    SPI_CloseRx_ISR
   \   00000034   0x....             LDR.N    R1,??DataTable1
   \   00000036   0x64C1             STR      R1,[R0, #+76]
   2349            }
   2350          }
   \                     ??SPI_RxISR_8BIT_1: (+1)
   \   00000038   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine2: (+1)
   \   00000000   0x6810             LDR      R0,[R2, #+0]
   \   00000002   0xF440 0x5080      ORR      R0,R0,#0x1000
   \   00000006   0x6010             STR      R0,[R2, #+0]
   \   00000008   0x4770             BX       LR
   2351          
   2352          /**
   2353            * @brief  Manage the CRC 16bit receive in Interrupt context
   2354            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   2355            *               the configuration information for SPI module.
   2356            * @retval None
   2357            */

   \                                 In section .text, align 2, keep-with-next
   2358          static void SPI_RxISR_16BITCRC(struct __SPI_HandleTypeDef *hspi)
   2359          {
   \                     SPI_RxISR_16BITCRC: (+1)
   \   00000000   0xB082             SUB      SP,SP,#+8
   2360            __IO uint16_t tmpreg;
   2361            
   2362            tmpreg = hspi->Instance->DR;
   \   00000002   0x6801             LDR      R1,[R0, #+0]
   \   00000004   0x68CA             LDR      R2,[R1, #+12]
   \   00000006   0xF8AD 0x2000      STRH     R2,[SP, #+0]
   2363            UNUSED(tmpreg); /* To avoid GCC warning */
   \   0000000A   0xF8BD 0x2000      LDRH     R2,[SP, #+0]
   2364          
   2365            /* Disable RXNE and ERR interrupt */
   2366            __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_RXNE | SPI_IT_ERR));
   \   0000000E   0x684A             LDR      R2,[R1, #+4]
   \   00000010   0xF022 0x0260      BIC      R2,R2,#0x60
   \   00000014   0x604A             STR      R2,[R1, #+4]
   2367            
   2368            SPI_CloseRx_ISR(hspi);
   \   00000016                      REQUIRE ?Subroutine7
   \   00000016                      ;; // Fall through to label ?Subroutine7
   2369          }
   2370          
   2371          /**
   2372            * @brief  Manage the 16Bit receive in Interrupt context
   2373            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   2374            *               the configuration information for SPI module.
   2375            * @retval None
   2376            */

   \                                 In section .text, align 4, keep-with-next
   2377          static void SPI_RxISR_16BIT(struct __SPI_HandleTypeDef *hspi)
   2378          {
   2379            *((uint16_t *)hspi->pRxBuffPtr) = hspi->Instance->DR;
   \                     SPI_RxISR_16BIT: (+1)
   \   00000000   0x6802             LDR      R2,[R0, #+0]
   \   00000002   0x6C01             LDR      R1,[R0, #+64]
   \   00000004   0x68D3             LDR      R3,[R2, #+12]
   \   00000006   0xF821 0x3B02      STRH     R3,[R1], #+2
   2380            hspi->pRxBuffPtr += sizeof(uint16_t);
   \   0000000A   0x6401             STR      R1,[R0, #+64]
   2381            hspi->RxXferCount--;
   \   0000000C   0xF8B0 0x1046      LDRH     R1,[R0, #+70]
   \   00000010   0x1E49             SUBS     R1,R1,#+1
   \   00000012   0xF8A0 0x1046      STRH     R1,[R0, #+70]
   2382            
   2383            /* Enable CRC Transmission */
   2384            if((hspi->RxXferCount == 1) && (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE))
   \   00000016   0xB289             UXTH     R1,R1
   \   00000018   0x2901             CMP      R1,#+1
   \   0000001A   0xD104             BNE.N    ??SPI_RxISR_16BIT_0
   \   0000001C   0x6A80             LDR      R0,[R0, #+40]
   \   0000001E   0xF5B0 0x5F00      CMP      R0,#+8192
   \   00000022   0xD109             BNE.N    ??SPI_RxISR_16BIT_1
   2385            {
   2386              hspi->Instance->CR1 |= SPI_CR1_CRCNEXT;
   \   00000024   0x....             B.N      ?Subroutine2
   2387            }
   2388            
   2389            if(hspi->RxXferCount == 0)
   \                     ??SPI_RxISR_16BIT_0: (+1)
   \   00000026   0xB939             CBNZ.N   R1,??SPI_RxISR_16BIT_1
   2390            {    
   2391              if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   \   00000028   0x6A81             LDR      R1,[R0, #+40]
   \   0000002A   0xF5B1 0x5F00      CMP      R1,#+8192
   \   0000002E   0xBF18             IT       NE 
   2392              {
   2393                hspi->RxISR = SPI_RxISR_16BITCRC;
   2394                return;
   2395              }
   2396              SPI_CloseRx_ISR(hspi);
   \   00000030   0x.... 0x....      BNE.W    SPI_CloseRx_ISR
   \   00000034   0x....             LDR.N    R1,??DataTable1_1
   \   00000036   0x64C1             STR      R1,[R0, #+76]
   2397            }
   2398          }
   \                     ??SPI_RxISR_16BIT_1: (+1)
   \   00000038   0x4770             BX       LR               ;; return
   2399          
   2400          /**
   2401            * @brief  Handle the data 8Bit transmit in Interrupt mode
   2402            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   2403            *               the configuration information for SPI module.
   2404            * @retval None
   2405            */

   \                                 In section .text, align 4, keep-with-next
   2406          static void SPI_TxISR_8BIT(struct __SPI_HandleTypeDef *hspi)
   2407          {
   2408            *(__IO uint8_t *)&hspi->Instance->DR = (*hspi->pTxBuffPtr++);
   \                     SPI_TxISR_8BIT: (+1)
   \   00000000   0xF100 0x0238      ADD      R2,R0,#+56
   \   00000004   0x6801             LDR      R1,[R0, #+0]
   \   00000006   0x6813             LDR      R3,[R2, #+0]
   \   00000008   0x1C5B             ADDS     R3,R3,#+1
   \   0000000A   0x6013             STR      R3,[R2, #+0]
   \   0000000C   0x1E5B             SUBS     R3,R3,#+1
   \   0000000E   0x781B             LDRB     R3,[R3, #+0]
   \   00000010   0x730B             STRB     R3,[R1, #+12]
   2409            hspi->TxXferCount--;
   \   00000012   0x88D3             LDRH     R3,[R2, #+6]
   \   00000014   0x1E5B             SUBS     R3,R3,#+1
   \   00000016   0x80D3             STRH     R3,[R2, #+6]
   2410            
   2411            if(hspi->TxXferCount == 0)
   \   00000018   0xB29B             UXTH     R3,R3
   \   0000001A   0xB943             CBNZ.N   R3,??SPI_TxISR_8BIT_0
   2412            {
   2413              if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   \   0000001C   0x6A82             LDR      R2,[R0, #+40]
   \   0000001E   0xF5B2 0x5F00      CMP      R2,#+8192
   \   00000022   0xD103             BNE.N    ??SPI_TxISR_8BIT_1
   2414              {
   2415                /* Enable CRC Transmission */
   2416                hspi->Instance->CR1 |= SPI_CR1_CRCNEXT;
   \   00000024   0x680A             LDR      R2,[R1, #+0]
   \   00000026   0xF442 0x5280      ORR      R2,R2,#0x1000
   \   0000002A   0x600A             STR      R2,[R1, #+0]
   2417              }
   2418              SPI_CloseTx_ISR(hspi);
   \                     ??SPI_TxISR_8BIT_1: (+1)
   \   0000002C   0x....             B.N      SPI_CloseTx_ISR
   2419            }
   2420          }
   \                     ??SPI_TxISR_8BIT_0: (+1)
   \   0000002E   0x4770             BX       LR               ;; return
   2421          
   2422          /**
   2423            * @brief  Handle the data 16Bit transmit in Interrupt mode
   2424            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   2425            *               the configuration information for SPI module.
   2426            * @retval None
   2427            */

   \                                 In section .text, align 4, keep-with-next
   2428          static void SPI_TxISR_16BIT(struct __SPI_HandleTypeDef *hspi)
   2429          { 
   2430            /* Transmit data in 16 Bit mode */
   2431            hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
   \                     SPI_TxISR_16BIT: (+1)
   \   00000000   0x6B81             LDR      R1,[R0, #+56]
   \   00000002   0x6802             LDR      R2,[R0, #+0]
   \   00000004   0xF831 0x3B02      LDRH     R3,[R1], #+2
   \   00000008   0x60D3             STR      R3,[R2, #+12]
   2432            hspi->pTxBuffPtr += sizeof(uint16_t);
   \   0000000A   0x6381             STR      R1,[R0, #+56]
   2433            hspi->TxXferCount--;
   \   0000000C   0x8FC1             LDRH     R1,[R0, #+62]
   \   0000000E   0x1E49             SUBS     R1,R1,#+1
   \   00000010   0x87C1             STRH     R1,[R0, #+62]
   2434            
   2435            if(hspi->TxXferCount == 0)
   \   00000012   0xB289             UXTH     R1,R1
   \   00000014   0xB941             CBNZ.N   R1,??SPI_TxISR_16BIT_0
   2436            {
   2437              if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   \   00000016   0x6A81             LDR      R1,[R0, #+40]
   \   00000018   0xF5B1 0x5F00      CMP      R1,#+8192
   \   0000001C   0xD103             BNE.N    ??SPI_TxISR_16BIT_1
   2438              {
   2439                /* Enable CRC Transmission */
   2440                hspi->Instance->CR1 |= SPI_CR1_CRCNEXT;
   \   0000001E   0x6811             LDR      R1,[R2, #+0]
   \   00000020   0xF441 0x5180      ORR      R1,R1,#0x1000
   \   00000024   0x6011             STR      R1,[R2, #+0]
   2441              }
   2442              SPI_CloseTx_ISR(hspi);
   \                     ??SPI_TxISR_16BIT_1: (+1)
   \   00000026   0x....             B.N      SPI_CloseTx_ISR
   2443            }
   2444          }
   \                     ??SPI_TxISR_16BIT_0: (+1)
   \   00000028   0x4770             BX       LR               ;; return
   2445          
   2446          /**
   2447            * @brief This function handles SPI Communication Timeout.
   2448            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   2449            *               the configuration information for SPI module.
   2450            * @param Flag : SPI flag to check
   2451            * @param State : flag state to check
   2452            * @param Timeout : Timeout duration
   2453            * @retval HAL status
   2454            */

   \                                 In section .text, align 2, keep-with-next
   2455          static HAL_StatusTypeDef SPI_WaitFlagStateUntilTimeout(SPI_HandleTypeDef *hspi, uint32_t Flag, uint32_t State, uint32_t Timeout)
   2456          {
   \                     SPI_WaitFlagStateUntilTimeout: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
   \   00000008   0x4690             MOV      R8,R2
   \   0000000A   0x461F             MOV      R7,R3
   2457            uint32_t tickstart = HAL_GetTick();
   \   0000000C   0x.... 0x....      BL       HAL_GetTick
   \   00000010   0x4606             MOV      R6,R0
   2458          
   2459            while((hspi->Instance->SR & Flag) != State)
   \                     ??SPI_WaitFlagStateUntilTimeout_0: (+1)
   \   00000012   0x6820             LDR      R0,[R4, #+0]
   \   00000014   0x6880             LDR      R0,[R0, #+8]
   \   00000016   0x4028             ANDS     R0,R5,R0
   \   00000018   0x4540             CMP      R0,R8
   \   0000001A   0xD016             BEQ.N    ??SPI_WaitFlagStateUntilTimeout_1
   2460            {
   2461              if(Timeout != HAL_MAX_DELAY)
   \   0000001C   0xF117 0x0F01      CMN      R7,#+1
   \   00000020   0xD0F7             BEQ.N    ??SPI_WaitFlagStateUntilTimeout_0
   2462              {
   2463                if((Timeout == 0) || ((HAL_GetTick()-tickstart) >= Timeout))
   \   00000022   0xB127             CBZ.N    R7,??SPI_WaitFlagStateUntilTimeout_2
   \   00000024   0x.... 0x....      BL       HAL_GetTick
   \   00000028   0x1B80             SUBS     R0,R0,R6
   \   0000002A   0x42B8             CMP      R0,R7
   \   0000002C   0xD3F1             BCC.N    ??SPI_WaitFlagStateUntilTimeout_0
   2464                {
   2465                  /* Disable the SPI and reset the CRC: the CRC value should be cleared
   2466                  on both master and slave sides in order to resynchronize the master
   2467                  and slave for their respective CRC calculation */
   2468          
   2469                  /* Disable TXE, RXNE and ERR interrupts for the interrupt process */
   2470                  __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_RXNE | SPI_IT_ERR));
   \                     ??SPI_WaitFlagStateUntilTimeout_2: (+1)
   \   0000002E   0x.... 0x....      BL       ?Subroutine15
   2471          
   2472                  if((hspi->Init.Mode == SPI_MODE_MASTER)&&((hspi->Init.Direction == SPI_DIRECTION_1LINE)||(hspi->Init.Direction == SPI_DIRECTION_2LINES_RXONLY)))
   \                     ??CrossCallReturnLabel_23: (+1)
   \   00000032   0xD107             BNE.N    ??CrossCallReturnLabel_10
   \   00000034   0x68A1             LDR      R1,[R4, #+8]
   \   00000036   0xF5B1 0x4F00      CMP      R1,#+32768
   \   0000003A   0xBF18             IT       NE 
   \   0000003C   0xF5B1 0x6F80      CMPNE    R1,#+1024
   \   00000040   0x.... 0x....      BL       ?Subroutine12
   2473                  {
   2474                    /* Disable SPI peripheral */
   2475                    __HAL_SPI_DISABLE(hspi);
   2476                  }
   2477          
   2478                  /* Reset CRC Calculation */
   2479                  if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   \                     ??CrossCallReturnLabel_10: (+1)
   \   00000044   0x.... 0x....      BL       ?Subroutine9
   2480                  {
   2481                    SPI_RESET_CRC(hspi);
   2482                  }
   2483                  
   2484                  hspi->State= HAL_SPI_STATE_READY;
   2485                  
   2486                  /* Process Unlocked */
   2487                  __HAL_UNLOCK(hspi);
   2488                  
   2489                  return HAL_TIMEOUT;
   2490                }
   2491              }
   2492            }
   \                     ??CrossCallReturnLabel_3: (+1)
   \   00000048   0xE000             B.N      ??SPI_WaitFlagStateUntilTimeout_3
   2493            
   2494            return HAL_OK;      
   \                     ??SPI_WaitFlagStateUntilTimeout_1: (+1)
   \   0000004A   0x2000             MOVS     R0,#+0
   \                     ??SPI_WaitFlagStateUntilTimeout_3: (+1)
   \   0000004C   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   2495          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine15: (+1)
   \   00000000   0x6820             LDR      R0,[R4, #+0]
   \   00000002   0x6841             LDR      R1,[R0, #+4]
   \   00000004   0xF021 0x01E0      BIC      R1,R1,#0xE0
   \   00000008   0x6041             STR      R1,[R0, #+4]
   \   0000000A   0x6861             LDR      R1,[R4, #+4]
   \   0000000C   0xF5B1 0x7F82      CMP      R1,#+260
   \   00000010   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine12: (+1)
   \   00000000   0xD103             BNE.N    ??Subroutine12_0
   \   00000002   0x6801             LDR      R1,[R0, #+0]
   \   00000004   0xF021 0x0140      BIC      R1,R1,#0x40
   \   00000008   0x6001             STR      R1,[R0, #+0]
   \                     ??Subroutine12_0: (+1)
   \   0000000A   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine9: (+1)
   \   00000000   0x6AA1             LDR      R1,[R4, #+40]
   \   00000002   0xF5B1 0x5F00      CMP      R1,#+8192
   \   00000006   0xD108             BNE.N    ??Subroutine9_0
   \   00000008   0x6801             LDR      R1,[R0, #+0]
   \   0000000A   0xF64D 0x72FF      MOVW     R2,#+57343
   \   0000000E   0x4011             ANDS     R1,R2,R1
   \   00000010   0x6001             STR      R1,[R0, #+0]
   \   00000012   0x6801             LDR      R1,[R0, #+0]
   \   00000014   0xF441 0x5100      ORR      R1,R1,#0x2000
   \   00000018   0x6001             STR      R1,[R0, #+0]
   \                     ??Subroutine9_0: (+1)
   \   0000001A   0xF104 0x005C      ADD      R0,R4,#+92
   \   0000001E   0x2101             MOVS     R1,#+1
   \   00000020   0x7041             STRB     R1,[R0, #+1]
   \   00000022   0x2100             MOVS     R1,#+0
   \   00000024   0x7001             STRB     R1,[R0, #+0]
   \   00000026   0x2003             MOVS     R0,#+3
   \   00000028   0x4770             BX       LR
   2496          
   2497          /**
   2498            * @brief This function handles SPI Communication Timeout.
   2499            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   2500            *               the configuration information for SPI module.
   2501            * @param Fifo : Fifo to check
   2502            * @param State : Fifo state to check
   2503            * @param Timeout : Timeout duration
   2504            * @retval HAL status
   2505            */

   \                                 In section .text, align 2, keep-with-next
   2506          static HAL_StatusTypeDef SPI_WaitFifoStateUntilTimeout(SPI_HandleTypeDef *hspi, uint32_t Fifo, uint32_t State, uint32_t Timeout)
   2507          {
   \                     SPI_WaitFifoStateUntilTimeout: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB082             SUB      SP,SP,#+8
   \   00000006   0x4604             MOV      R4,R0
   \   00000008   0x460D             MOV      R5,R1
   \   0000000A   0x4616             MOV      R6,R2
   \   0000000C   0x461F             MOV      R7,R3
   2508            __IO uint8_t tmpreg;
   2509            uint32_t tickstart = HAL_GetTick();
   \   0000000E   0x.... 0x....      BL       HAL_GetTick
   \   00000012   0x4680             MOV      R8,R0
   2510          
   2511            while((hspi->Instance->SR & Fifo) != State)
   \                     ??SPI_WaitFifoStateUntilTimeout_0: (+1)
   \   00000014   0x6820             LDR      R0,[R4, #+0]
   \   00000016   0x6881             LDR      R1,[R0, #+8]
   \   00000018   0x4029             ANDS     R1,R5,R1
   \   0000001A   0x42B1             CMP      R1,R6
   \   0000001C   0xD021             BEQ.N    ??SPI_WaitFifoStateUntilTimeout_1
   2512            {
   2513              if((Fifo == SPI_SR_FRLVL) && (State == SPI_FRLVL_EMPTY))
   \   0000001E   0xF5B5 0x6FC0      CMP      R5,#+1536
   \   00000022   0xBF08             IT       EQ 
   \   00000024   0x2E00             CMPEQ    R6,#+0
   \   00000026   0xD104             BNE.N    ??SPI_WaitFifoStateUntilTimeout_2
   2514              {
   2515                tmpreg = *((__IO uint8_t*)&hspi->Instance->DR);
   \   00000028   0x7B00             LDRB     R0,[R0, #+12]
   \   0000002A   0xF88D 0x0000      STRB     R0,[SP, #+0]
   2516                UNUSED(tmpreg); /* To avoid GCC warning */
   \   0000002E   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   2517              }
   2518          
   2519              if(Timeout != HAL_MAX_DELAY)
   \                     ??SPI_WaitFifoStateUntilTimeout_2: (+1)
   \   00000032   0xF117 0x0F01      CMN      R7,#+1
   \   00000036   0xD0ED             BEQ.N    ??SPI_WaitFifoStateUntilTimeout_0
   2520              {
   2521                if((Timeout == 0) || ((HAL_GetTick()-tickstart) >= Timeout))
   \   00000038   0xB12F             CBZ.N    R7,??SPI_WaitFifoStateUntilTimeout_3
   \   0000003A   0x.... 0x....      BL       HAL_GetTick
   \   0000003E   0xEBA0 0x0008      SUB      R0,R0,R8
   \   00000042   0x42B8             CMP      R0,R7
   \   00000044   0xD3E6             BCC.N    ??SPI_WaitFifoStateUntilTimeout_0
   2522                {
   2523                  /* Disable the SPI and reset the CRC: the CRC value should be cleared
   2524                            on both master and slave sides in order to resynchronize the master
   2525                           and slave for their respective CRC calculation */
   2526          
   2527                  /* Disable TXE, RXNE and ERR interrupts for the interrupt process */
   2528                  __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_RXNE | SPI_IT_ERR));
   \                     ??SPI_WaitFifoStateUntilTimeout_3: (+1)
   \   00000046   0x.... 0x....      BL       ?Subroutine15
   2529          
   2530                  if((hspi->Init.Mode == SPI_MODE_MASTER)&&((hspi->Init.Direction == SPI_DIRECTION_1LINE)||(hspi->Init.Direction == SPI_DIRECTION_2LINES_RXONLY)))
   \                     ??CrossCallReturnLabel_24: (+1)
   \   0000004A   0xD107             BNE.N    ??CrossCallReturnLabel_11
   \   0000004C   0x68A1             LDR      R1,[R4, #+8]
   \   0000004E   0xF5B1 0x4F00      CMP      R1,#+32768
   \   00000052   0xBF18             IT       NE 
   \   00000054   0xF5B1 0x6F80      CMPNE    R1,#+1024
   \   00000058   0x.... 0x....      BL       ?Subroutine12
   2531                  {
   2532                    /* Disable SPI peripheral */
   2533                    __HAL_SPI_DISABLE(hspi);
   2534                  }
   2535          
   2536                  /* Reset CRC Calculation */
   2537                  if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   \                     ??CrossCallReturnLabel_11: (+1)
   \   0000005C   0x.... 0x....      BL       ?Subroutine9
   2538                  {
   2539                    SPI_RESET_CRC(hspi);
   2540                  }
   2541          
   2542                  hspi->State = HAL_SPI_STATE_READY;
   2543          
   2544                  /* Process Unlocked */
   2545                  __HAL_UNLOCK(hspi);
   2546          
   2547                  return HAL_TIMEOUT;
   2548                }
   2549              }
   2550            }
   \                     ??CrossCallReturnLabel_4: (+1)
   \   00000060   0xE000             B.N      ??SPI_WaitFifoStateUntilTimeout_4
   2551          
   2552            return HAL_OK;
   \                     ??SPI_WaitFifoStateUntilTimeout_1: (+1)
   \   00000062   0x2000             MOVS     R0,#+0
   \                     ??SPI_WaitFifoStateUntilTimeout_4: (+1)
   \   00000064   0xE8BD 0x81F6      POP      {R1,R2,R4-R8,PC}  ;; return
   2553          }
   2554          
   2555          /**
   2556            * @brief This function handles the check of the RX transaction complete.
   2557            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   2558            *               the configuration information for SPI module.
   2559            * @param Timeout : Timeout duration
   2560            * @retval None
   2561            */

   \                                 In section .text, align 2, keep-with-next
   2562          static HAL_StatusTypeDef SPI_EndRxTransaction(SPI_HandleTypeDef *hspi,  uint32_t Timeout)
   2563          {
   \                     SPI_EndRxTransaction: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   2564            if((hspi->Init.Mode == SPI_MODE_MASTER)&&((hspi->Init.Direction == SPI_DIRECTION_1LINE)||(hspi->Init.Direction == SPI_DIRECTION_2LINES_RXONLY)))
   \   00000006   0x6860             LDR      R0,[R4, #+4]
   \   00000008   0xF5B0 0x7F82      CMP      R0,#+260
   \   0000000C   0xD108             BNE.N    ??CrossCallReturnLabel_26
   \   0000000E   0x68A0             LDR      R0,[R4, #+8]
   \   00000010   0xF5B0 0x4F00      CMP      R0,#+32768
   \   00000014   0xBF18             IT       NE 
   \   00000016   0xF5B0 0x6F80      CMPNE    R0,#+1024
   \   0000001A   0xD101             BNE.N    ??CrossCallReturnLabel_26
   2565            {
   2566              /* Disable SPI peripheral */
   2567              __HAL_SPI_DISABLE(hspi);
   \   0000001C   0x.... 0x....      BL       ?Subroutine16
   2568            }
   2569            if(SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_BSY, RESET, Timeout) != HAL_OK)
   \                     ??CrossCallReturnLabel_26: (+1)
   \   00000020   0x.... 0x....      BL       ?Subroutine20
   \                     ??CrossCallReturnLabel_35: (+1)
   \   00000024   0xB910             CBNZ.N   R0,??SPI_EndRxTransaction_0
   2570            {  
   2571              hspi->ErrorCode |= HAL_SPI_ERROR_FLAG;
   2572              return HAL_TIMEOUT;
   2573            }
   2574            if(SPI_WaitFifoStateUntilTimeout(hspi, SPI_FLAG_FRLVL, SPI_FRLVL_EMPTY, Timeout) != HAL_OK) 
   \   00000026   0x.... 0x....      BL       ?Subroutine19
   \                     ??CrossCallReturnLabel_33: (+1)
   \   0000002A   0xB108             CBZ.N    R0,??CrossCallReturnLabel_81
   2575            {
   2576              hspi->ErrorCode |= HAL_SPI_ERROR_FLAG;
   \                     ??SPI_EndRxTransaction_0: (+1)
   \   0000002C   0x.... 0x....      BL       ?Subroutine37
   2577              return HAL_TIMEOUT;
   2578            }
   2579            
   2580            return HAL_OK;
   \                     ??CrossCallReturnLabel_81: (+1)
   \   00000030   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   2581          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine37: (+1)
   \   00000000   0x6E20             LDR      R0,[R4, #+96]
   \   00000002   0xF040 0x0020      ORR      R0,R0,#0x20
   \   00000006   0x6620             STR      R0,[R4, #+96]
   \   00000008   0x2003             MOVS     R0,#+3
   \   0000000A   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine20: (+1)
   \   00000000   0x462B             MOV      R3,R5
   \   00000002   0x2200             MOVS     R2,#+0
   \   00000004   0x2180             MOVS     R1,#+128
   \   00000006   0x4620             MOV      R0,R4
   \   00000008   0x....             B.N      SPI_WaitFlagStateUntilTimeout

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine19: (+1)
   \   00000000   0x462B             MOV      R3,R5
   \   00000002   0x2200             MOVS     R2,#+0
   \   00000004   0xF44F 0x61C0      MOV      R1,#+1536
   \   00000008   0x4620             MOV      R0,R4
   \   0000000A   0x....             B.N      SPI_WaitFifoStateUntilTimeout
   2582            
   2583          /**
   2584            * @brief This function handles the check of the RXTX or TX transaction complete.
   2585            * @param hspi: SPI handle
   2586            * @param Timeout : Timeout duration
   2587            */

   \                                 In section .text, align 2, keep-with-next
   2588          static HAL_StatusTypeDef SPI_EndRxTxTransaction(SPI_HandleTypeDef *hspi, uint32_t Timeout)
   2589          {
   \                     SPI_EndRxTxTransaction: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x460D             MOV      R5,R1
   \   00000004   0x4604             MOV      R4,R0
   2590            /* Procedure to check the transaction complete */
   2591            if(SPI_WaitFifoStateUntilTimeout(hspi, SPI_FLAG_FTLVL, SPI_FTLVL_EMPTY, Timeout) != HAL_OK)
   \   00000006   0x462B             MOV      R3,R5
   \   00000008   0x2200             MOVS     R2,#+0
   \   0000000A   0xF44F 0x51C0      MOV      R1,#+6144
   \   0000000E   0x.... 0x....      BL       SPI_WaitFifoStateUntilTimeout
   \   00000012   0xB928             CBNZ.N   R0,??SPI_EndRxTxTransaction_0
   2592            {
   2593              hspi->ErrorCode |= HAL_SPI_ERROR_FLAG;
   2594              return HAL_TIMEOUT;
   2595            }
   2596            if(SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_BSY, RESET, Timeout) != HAL_OK)
   \   00000014   0x.... 0x....      BL       ?Subroutine20
   \                     ??CrossCallReturnLabel_34: (+1)
   \   00000018   0xB910             CBNZ.N   R0,??SPI_EndRxTxTransaction_0
   2597            {
   2598              hspi->ErrorCode |= HAL_SPI_ERROR_FLAG;
   2599              return HAL_TIMEOUT;
   2600            }
   2601            if(SPI_WaitFifoStateUntilTimeout(hspi, SPI_FLAG_FRLVL, SPI_FRLVL_EMPTY, Timeout) != HAL_OK)
   \   0000001A   0x.... 0x....      BL       ?Subroutine19
   \                     ??CrossCallReturnLabel_32: (+1)
   \   0000001E   0xB108             CBZ.N    R0,??CrossCallReturnLabel_82
   2602            {
   2603              hspi->ErrorCode |= HAL_SPI_ERROR_FLAG;
   \                     ??SPI_EndRxTxTransaction_0: (+1)
   \   00000020   0x.... 0x....      BL       ?Subroutine37
   2604              return HAL_TIMEOUT;
   2605            }
   2606            return HAL_OK;
   \                     ??CrossCallReturnLabel_82: (+1)
   \   00000024   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   2607          }
   2608          
   2609          /**
   2610            * @brief This function handles the close of the RXTX transaction.
   2611            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   2612            *               the configuration information for SPI module.
   2613            * @retval None
   2614            */

   \                                 In section .text, align 2, keep-with-next
   2615          static void SPI_CloseRxTx_ISR(SPI_HandleTypeDef *hspi)
   2616          {
   \                     SPI_CloseRxTx_ISR: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   2617            /* Disable ERR interrupt */
   2618            __HAL_SPI_DISABLE_IT(hspi, SPI_IT_ERR);
   \   00000002   0x6801             LDR      R1,[R0, #+0]
   \   00000004   0x684A             LDR      R2,[R1, #+4]
   \   00000006   0xF022 0x0220      BIC      R2,R2,#0x20
   \   0000000A   0x604A             STR      R2,[R1, #+4]
   2619          
   2620            /* Check if CRC error occurred */
   2621            if(__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_CRCERR) != RESET)
   \   0000000C   0x6E02             LDR      R2,[R0, #+96]
   \   0000000E   0x688B             LDR      R3,[R1, #+8]
   \   00000010   0x06DB             LSLS     R3,R3,#+27
   \   00000012   0xD509             BPL.N    ??SPI_CloseRxTx_ISR_0
   2622            {
   2623              hspi->State = HAL_SPI_STATE_READY;
   2624              hspi->ErrorCode|= HAL_SPI_ERROR_CRC;
   \   00000014   0xF042 0x0202      ORR      R2,R2,#0x2
   \   00000018   0x2301             MOVS     R3,#+1
   \   0000001A   0x6602             STR      R2,[R0, #+96]
   2625              __HAL_SPI_CLEAR_CRCERRFLAG(hspi);
   \   0000001C   0xF64F 0x72EF      MOVW     R2,#+65519
   \   00000020   0xF880 0x305D      STRB     R3,[R0, #+93]
   \   00000024   0x608A             STR      R2,[R1, #+8]
   2626              HAL_SPI_ErrorCallback(hspi);
   \   00000026   0xE010             B.N      ??CrossCallReturnLabel_61
   2627            }
   2628            else
   2629            {
   2630              if(hspi->ErrorCode == HAL_SPI_ERROR_NONE)
   \                     ??SPI_CloseRxTx_ISR_0: (+1)
   \   00000028   0xB96A             CBNZ.N   R2,??SPI_CloseRxTx_ISR_1
   2631              {
   2632                if(hspi->State == HAL_SPI_STATE_BUSY_RX)
   \   0000002A   0xF890 0x105D      LDRB     R1,[R0, #+93]
   \   0000002E   0x2904             CMP      R1,#+4
   \   00000030   0xD104             BNE.N    ??SPI_CloseRxTx_ISR_2
   2633                {
   2634                	hspi->State = HAL_SPI_STATE_READY;
   \   00000032   0x.... 0x....      BL       ?Subroutine30
   2635                  HAL_SPI_RxCpltCallback(hspi);
   \                     ??CrossCallReturnLabel_59: (+1)
   \   00000036   0x.... 0x....      BL       HAL_SPI_RxCpltCallback
   \   0000003A   0xBD01             POP      {R0,PC}
   2636                }
   2637                else
   2638                {
   2639                	hspi->State = HAL_SPI_STATE_READY;
   \                     ??SPI_CloseRxTx_ISR_2: (+1)
   \   0000003C   0x.... 0x....      BL       ?Subroutine30
   2640                  HAL_SPI_TxRxCpltCallback(hspi);
   \                     ??CrossCallReturnLabel_60: (+1)
   \   00000040   0x.... 0x....      BL       HAL_SPI_TxRxCpltCallback
   \   00000044   0xBD01             POP      {R0,PC}
   2641                }      
   2642              }
   2643              else
   2644              {
   2645                hspi->State = HAL_SPI_STATE_READY;
   \                     ??SPI_CloseRxTx_ISR_1: (+1)
   \   00000046   0x.... 0x....      BL       ?Subroutine30
   2646                HAL_SPI_ErrorCallback(hspi);
   2647              }
   2648            }
   \                     ??CrossCallReturnLabel_61: (+1)
   \   0000004A   0x....             B.N      ?Subroutine4
   2649          }
   2650          
   2651          /**
   2652            * @brief This function handles the close of the RX transaction.
   2653            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   2654            *               the configuration information for SPI module.
   2655            * @retval None
   2656            */

   \                                 In section .text, align 2, keep-with-next
   2657          static void SPI_CloseRx_ISR(SPI_HandleTypeDef *hspi)
   2658          {
   \                     SPI_CloseRx_ISR: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   2659              /* Disable RXNE and ERR interrupt */
   2660              __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_RXNE | SPI_IT_ERR));
   \   00000004   0x6820             LDR      R0,[R4, #+0]
   \   00000006   0x6841             LDR      R1,[R0, #+4]
   \   00000008   0xF021 0x0160      BIC      R1,R1,#0x60
   \   0000000C   0x6041             STR      R1,[R0, #+4]
   2661              
   2662              /* Check the end of the transaction */
   2663              SPI_EndRxTransaction(hspi,SPI_DEFAULT_TIMEOUT);
   \   0000000E   0x2132             MOVS     R1,#+50
   \   00000010   0x4620             MOV      R0,R4
   \   00000012   0x.... 0x....      BL       SPI_EndRxTransaction
   2664          
   2665              hspi->State = HAL_SPI_STATE_READY;
   \   00000016   0x2001             MOVS     R0,#+1
   \   00000018   0xF884 0x005D      STRB     R0,[R4, #+93]
   2666          
   2667              /* Check if CRC error occurred */
   2668              if(__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_CRCERR) != RESET)
   \   0000001C   0x6821             LDR      R1,[R4, #+0]
   \   0000001E   0x6E20             LDR      R0,[R4, #+96]
   \   00000020   0x688A             LDR      R2,[R1, #+8]
   \   00000022   0x06D2             LSLS     R2,R2,#+27
   \   00000024   0xD503             BPL.N    ??SPI_CloseRx_ISR_0
   2669              {
   2670                hspi->ErrorCode|= HAL_SPI_ERROR_CRC;
   \   00000026   0x.... 0x....      BL       ?Subroutine33
   2671                __HAL_SPI_CLEAR_CRCERRFLAG(hspi);
   2672                HAL_SPI_ErrorCallback(hspi);
   \                     ??CrossCallReturnLabel_73: (+1)
   \   0000002A   0x4620             MOV      R0,R4
   \   0000002C   0xE005             B.N      ??SPI_CloseRx_ISR_1
   2673              }
   2674              else
   2675              {
   2676                if(hspi->ErrorCode == HAL_SPI_ERROR_NONE)
   \                     ??SPI_CloseRx_ISR_0: (+1)
   \   0000002E   0x2800             CMP      R0,#+0
   \   00000030   0x4620             MOV      R0,R4
   \   00000032   0xD102             BNE.N    ??SPI_CloseRx_ISR_1
   2677                {
   2678                  HAL_SPI_RxCpltCallback(hspi);
   \   00000034   0x.... 0x....      BL       HAL_SPI_RxCpltCallback
   \   00000038   0xBD10             POP      {R4,PC}
   2679                }
   2680                else
   2681                {
   2682                  HAL_SPI_ErrorCallback(hspi);
   \                     ??SPI_CloseRx_ISR_1: (+1)
   \   0000003A   0x.... 0x....      BL       HAL_SPI_ErrorCallback
   2683                }
   2684              }
   2685          }
   \   0000003E   0xBD10             POP      {R4,PC}          ;; return
   2686          
   2687          /**
   2688            * @brief This function handles the close of the TX transaction.
   2689            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   2690            *               the configuration information for SPI module.
   2691            * @retval None
   2692            */

   \                                 In section .text, align 2, keep-with-next
   2693          static void SPI_CloseTx_ISR(SPI_HandleTypeDef *hspi)
   2694          {
   \                     SPI_CloseTx_ISR: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   2695            /* Disable TXE and ERR interrupt */
   2696            __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_ERR));
   \   00000002   0x6801             LDR      R1,[R0, #+0]
   \   00000004   0x684A             LDR      R2,[R1, #+4]
   \   00000006   0xF022 0x02A0      BIC      R2,R2,#0xA0
   \   0000000A   0x.... 0x....      BL       ?Subroutine35
   2697          
   2698            /* Clear OVERUN flag in 2 Lines communication mode because received is not read */
   2699            if(hspi->Init.Direction == SPI_DIRECTION_2LINES)
   2700            {
   2701              __HAL_SPI_CLEAR_OVRFLAG(hspi);
   2702            }
   2703          
   2704            hspi->State = HAL_SPI_STATE_READY;
   \                     ??CrossCallReturnLabel_78: (+1)
   \   0000000E   0x.... 0x....      BL       ?Subroutine30
   2705            if(hspi->ErrorCode != HAL_SPI_ERROR_NONE)
   \                     ??CrossCallReturnLabel_62: (+1)
   \   00000012   0x6E01             LDR      R1,[R0, #+96]
   \   00000014   0xB101             CBZ.N    R1,??SPI_CloseTx_ISR_0
   2706            {
   2707              HAL_SPI_ErrorCallback(hspi);
   \   00000016   0x....             B.N      ?Subroutine4
   2708            }
   2709            else
   2710            {
   2711              HAL_SPI_TxCpltCallback(hspi);
   \                     ??SPI_CloseTx_ISR_0: (+1)
   \   00000018                      REQUIRE ?Subroutine3
   \   00000018                      ;; // Fall through to label ?Subroutine3
   2712            }
   2713          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1:
   \   00000000   0x........         DC32     SPI_RxISR_8BITCRC

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_1:
   \   00000000   0x........         DC32     SPI_RxISR_16BITCRC
   2714          
   2715          /**
   2716            * @}
   2717            */
   2718          
   2719          #endif /* HAL_SPI_MODULE_ENABLED */
   2720          /**
   2721            * @}
   2722            */
   2723          
   2724          /**
   2725            * @}
   2726            */
   2727          
   2728          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   HAL_SPI_DMAPause
       0   HAL_SPI_DMAResume
       8   HAL_SPI_DMAStop
         8   -> HAL_DMA_Abort
      16   HAL_SPI_DeInit
        16   -> HAL_SPI_MspDeInit
        16   -> SPI_WaitFifoStateUntilTimeout
        16   -> SPI_WaitFlagStateUntilTimeout
       0   HAL_SPI_ErrorCallback
       0   HAL_SPI_GetError
       0   HAL_SPI_GetState
       8   HAL_SPI_IRQHandler
         0   -- Indirect call
         8   -> HAL_SPI_ErrorCallback
      16   HAL_SPI_Init
        16   -> HAL_SPI_MspInit
       0   HAL_SPI_MspDeInit
       0   HAL_SPI_MspInit
      24   HAL_SPI_Receive
        24   -> HAL_SPI_TransmitReceive
        24   -> SPI_EndRxTransaction
        24   -> SPI_WaitFlagStateUntilTimeout
      16   HAL_SPI_Receive_DMA
        16   -> HAL_DMA_Start_IT
         0   -> HAL_SPI_TransmitReceive_DMA
       8   HAL_SPI_Receive_IT
         0   -> HAL_SPI_TransmitReceive_IT
       0   HAL_SPI_RxCpltCallback
       0   HAL_SPI_RxHalfCpltCallback
      24   HAL_SPI_Transmit
        24   -> SPI_EndRxTxTransaction
        24   -> SPI_WaitFlagStateUntilTimeout
      40   HAL_SPI_TransmitReceive
        40   -> HAL_GetTick
        40   -> SPI_EndRxTxTransaction
        40   -> SPI_WaitFlagStateUntilTimeout
      16   HAL_SPI_TransmitReceive_DMA
        16   -> HAL_DMA_Start_IT
      20   HAL_SPI_TransmitReceive_IT
      16   HAL_SPI_Transmit_DMA
        16   -> HAL_DMA_Start_IT
       8   HAL_SPI_Transmit_IT
       0   HAL_SPI_TxCpltCallback
       0   HAL_SPI_TxHalfCpltCallback
       0   HAL_SPI_TxRxCpltCallback
       0   HAL_SPI_TxRxHalfCpltCallback
       0   SPI_2linesRxISR_16BIT
         0   -> SPI_CloseRxTx_ISR
       8   SPI_2linesRxISR_16BITCRC
         0   -> SPI_CloseRxTx_ISR
       0   SPI_2linesRxISR_8BIT
         0   -> SPI_CloseRxTx_ISR
       8   SPI_2linesRxISR_8BITCRC
         0   -> SPI_CloseRxTx_ISR
       0   SPI_2linesTxISR_16BIT
         0   -> SPI_CloseRxTx_ISR
       8   SPI_2linesTxISR_8BIT
         8   -> SPI_CloseRxTx_ISR
       8   SPI_CloseRxTx_ISR
         8   -> HAL_SPI_ErrorCallback
         8   -> HAL_SPI_RxCpltCallback
         8   -> HAL_SPI_TxRxCpltCallback
       8   SPI_CloseRx_ISR
         8   -> HAL_SPI_ErrorCallback
         8   -> HAL_SPI_RxCpltCallback
         8   -> SPI_EndRxTransaction
       8   SPI_CloseTx_ISR
         8   -> HAL_SPI_ErrorCallback
         8   -> HAL_SPI_TxCpltCallback
       8   SPI_DMAError
         8   -> HAL_SPI_ErrorCallback
       8   SPI_DMAHalfReceiveCplt
         8   -> HAL_SPI_RxHalfCpltCallback
       8   SPI_DMAHalfTransmitCplt
         8   -> HAL_SPI_TxHalfCpltCallback
       8   SPI_DMAHalfTransmitReceiveCplt
         8   -> HAL_SPI_TxRxHalfCpltCallback
      16   SPI_DMAReceiveCplt
        16   -> HAL_SPI_ErrorCallback
        16   -> HAL_SPI_RxCpltCallback
        16   -> SPI_EndRxTransaction
        16   -> SPI_WaitFlagStateUntilTimeout
       8   SPI_DMATransmitCplt
         8   -> HAL_SPI_ErrorCallback
         8   -> HAL_SPI_TxCpltCallback
      16   SPI_DMATransmitReceiveCplt
        16   -> HAL_SPI_ErrorCallback
        16   -> HAL_SPI_TxRxCpltCallback
        16   -> SPI_EndRxTxTransaction
        16   -> SPI_WaitFifoStateUntilTimeout
      16   SPI_EndRxTransaction
        16   -> SPI_WaitFifoStateUntilTimeout
        16   -> SPI_WaitFlagStateUntilTimeout
      16   SPI_EndRxTxTransaction
        16   -> SPI_WaitFifoStateUntilTimeout
        16   -> SPI_WaitFlagStateUntilTimeout
       0   SPI_RxISR_16BIT
         0   -> SPI_CloseRx_ISR
       8   SPI_RxISR_16BITCRC
         0   -> SPI_CloseRx_ISR
       0   SPI_RxISR_8BIT
         0   -> SPI_CloseRx_ISR
       8   SPI_RxISR_8BITCRC
         0   -> SPI_CloseRx_ISR
       0   SPI_TxISR_16BIT
         0   -> SPI_CloseTx_ISR
       0   SPI_TxISR_8BIT
         0   -> SPI_CloseTx_ISR
      32   SPI_WaitFifoStateUntilTimeout
        32   -> HAL_GetTick
      24   SPI_WaitFlagStateUntilTimeout
        24   -> HAL_GetTick


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable1
       4  ??DataTable1_1
      10  ?Subroutine0
      12  ?Subroutine1
      10  ?Subroutine10
      12  ?Subroutine11
      12  ?Subroutine12
      10  ?Subroutine13
      22  ?Subroutine14
      18  ?Subroutine15
      12  ?Subroutine16
      16  ?Subroutine17
      20  ?Subroutine18
      12  ?Subroutine19
      10  ?Subroutine2
      10  ?Subroutine20
      10  ?Subroutine21
       8  ?Subroutine22
      18  ?Subroutine23
      16  ?Subroutine24
      16  ?Subroutine25
      12  ?Subroutine26
      12  ?Subroutine27
      12  ?Subroutine28
      12  ?Subroutine29
       6  ?Subroutine3
       8  ?Subroutine30
       8  ?Subroutine31
      16  ?Subroutine32
      14  ?Subroutine33
      10  ?Subroutine34
      18  ?Subroutine35
      18  ?Subroutine36
      12  ?Subroutine37
       6  ?Subroutine4
       6  ?Subroutine5
       4  ?Subroutine6
       4  ?Subroutine7
      30  ?Subroutine8
      42  ?Subroutine9
      28  HAL_SPI_DMAPause
      26  HAL_SPI_DMAResume
      40  HAL_SPI_DMAStop
      82  HAL_SPI_DeInit
       2  HAL_SPI_ErrorCallback
       4  HAL_SPI_GetError
       6  HAL_SPI_GetState
     156  HAL_SPI_IRQHandler
     172  HAL_SPI_Init
       2  HAL_SPI_MspDeInit
       2  HAL_SPI_MspInit
     410  HAL_SPI_Receive
     212  HAL_SPI_Receive_DMA
     182  HAL_SPI_Receive_IT
       2  HAL_SPI_RxCpltCallback
       2  HAL_SPI_RxHalfCpltCallback
     262  HAL_SPI_Transmit
     564  HAL_SPI_TransmitReceive
     306  HAL_SPI_TransmitReceive_DMA
     218  HAL_SPI_TransmitReceive_IT
     198  HAL_SPI_Transmit_DMA
     106  HAL_SPI_Transmit_IT
       2  HAL_SPI_TxCpltCallback
       2  HAL_SPI_TxHalfCpltCallback
       2  HAL_SPI_TxRxCpltCallback
       2  HAL_SPI_TxRxHalfCpltCallback
      62  SPI_2linesRxISR_16BIT
      24  SPI_2linesRxISR_16BITCRC
     110  SPI_2linesRxISR_8BIT
      40  SPI_2linesRxISR_8BITCRC
      60  SPI_2linesTxISR_16BIT
      82  SPI_2linesTxISR_8BIT
      76  SPI_CloseRxTx_ISR
      64  SPI_CloseRx_ISR
      24  SPI_CloseTx_ISR
      28  SPI_DMAError
      10  SPI_DMAHalfReceiveCplt
      10  SPI_DMAHalfTransmitCplt
      10  SPI_DMAHalfTransmitReceiveCplt
     134  SPI_DMAReceiveCplt
      42  SPI_DMATransmitCplt
     144  SPI_DMATransmitReceiveCplt
      50  SPI_EndRxTransaction
      38  SPI_EndRxTxTransaction
      58  SPI_RxISR_16BIT
      22  SPI_RxISR_16BITCRC
      58  SPI_RxISR_8BIT
      28  SPI_RxISR_8BITCRC
      42  SPI_TxISR_16BIT
      48  SPI_TxISR_8BIT
     104  SPI_WaitFifoStateUntilTimeout
      80  SPI_WaitFlagStateUntilTimeout

 
 4 950 bytes in section .text
 
 4 950 bytes of CODE memory

Errors: none
Warnings: none
