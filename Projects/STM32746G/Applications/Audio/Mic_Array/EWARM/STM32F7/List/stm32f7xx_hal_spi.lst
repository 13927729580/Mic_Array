###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.2.10312/W32 for ARM       16/Apr/2016  18:31:02
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_spi.c
#    Command line =  
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_spi.c
#        -D USE_HAL_DRIVER -D STM32F746xx -D USE_STM32746G_DISCO -D
#        USE_IOEXPANDER -D USE_USB_FS -lC
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
#        -lA
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
#        -o
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj
#        --no_unroll --debug --endian=little --cpu=Cortex-M7 -e --fpu=VFPv5_sp
#        --dlib_config "D:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Full.h" -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\CMSIS\Device\ST\STM32F7xx\Include\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\STM32F7xx_HAL_Driver\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\STM32746G-Discovery\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\Components\Common\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Log\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Fonts\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\CPU\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_Device_Library\Core\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Core\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Class\MSC\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\drivers\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_Audio\Addons\PDM\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_Device_Library\Class\AUDIO\Inc\
#        -Oh --use_c++_inline --require_prototypes -I "D:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.3\arm\CMSIS\Include\" -D
#        ARM_MATH_CM7 --relaxed_fp
#    List file    =  
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List\stm32f7xx_hal_spi.lst
#    Object file  =  
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj\stm32f7xx_hal_spi.o
#
###############################################################################

D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_spi.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f7xx_hal_spi.c
      4            * @author  MCD Application Team
      5            * @version V1.0.4
      6            * @date    09-December-2015
      7            * @brief   SPI HAL module driver.
      8            *          This file provides firmware functions to manage the following 
      9            *          functionalities of the Serial Peripheral Interface (SPI) peripheral:
     10            *           + Initialization and de-initialization functions
     11            *           + IO operation functions
     12            *           + Peripheral Control functions 
     13            *           + Peripheral State functions
     14            @verbatim
     15            ==============================================================================
     16                                  ##### How to use this driver #####
     17            ==============================================================================
     18              [..]
     19                The SPI HAL driver can be used as follows:
     20          
     21                (#) Declare a SPI_HandleTypeDef handle structure, for example:
     22                    SPI_HandleTypeDef  hspi;
     23          
     24                (#)Initialize the SPI low level resources by implementing the HAL_SPI_MspInit ()API:
     25                    (##) Enable the SPIx interface clock
     26                    (##) SPI pins configuration
     27                        (+++) Enable the clock for the SPI GPIOs
     28                        (+++) Configure these SPI pins as alternate function push-pull
     29                    (##) NVIC configuration if you need to use interrupt process
     30                        (+++) Configure the SPIx interrupt priority
     31                        (+++) Enable the NVIC SPI IRQ handle
     32                    (##) DMA Configuration if you need to use DMA process
     33                        (+++) Declare a DMA_HandleTypeDef handle structure for the transmit or receive channel
     34                        (+++) Enable the DMAx clock
     35                        (+++) Configure the DMA handle parameters
     36                        (+++) Configure the DMA Tx or Rx channel
     37                        (+++) Associate the initialized hdma_tx handle to the hspi DMA Tx or Rx handle
     38                        (+++) Configure the priority and enable the NVIC for the transfer complete interrupt on the DMA Tx or Rx channel
     39          
     40                (#) Program the Mode, BidirectionalMode , Data size, Baudrate Prescaler, NSS
     41                    management, Clock polarity and phase, FirstBit and CRC configuration in the hspi Init structure.
     42          
     43                (#) Initialize the SPI registers by calling the HAL_SPI_Init() API:
     44                    (++) This API configures also the low level Hardware GPIO, CLOCK, CORTEX...etc)
     45                        by calling the customised HAL_SPI_MspInit() API.
     46               [..]
     47                 Circular mode restriction:
     48                (#) The DMA circular mode cannot be used when the SPI is configured in these modes:
     49                    (##) Master 2Lines RxOnly
     50                    (##) Master 1Line Rx
     51                (#) The CRC feature is not managed when the DMA circular mode is enabled
     52                (#) When the SPI DMA Pause/Stop features are used, we must use the following APIs
     53                    the HAL_SPI_DMAPause()/ HAL_SPI_DMAStop() only under the SPI callbacks
     54          
     55            @endverbatim
     56            ******************************************************************************
     57            * @attention
     58            *
     59            * <h2><center>&copy; COPYRIGHT(c) 2015 STMicroelectronics</center></h2>
     60            *
     61            * Redistribution and use in source and binary forms, with or without modification,
     62            * are permitted provided that the following conditions are met:
     63            *   1. Redistributions of source code must retain the above copyright notice,
     64            *      this list of conditions and the following disclaimer.
     65            *   2. Redistributions in binary form must reproduce the above copyright notice,
     66            *      this list of conditions and the following disclaimer in the documentation
     67            *      and/or other materials provided with the distribution.
     68            *   3. Neither the name of STMicroelectronics nor the names of its contributors
     69            *      may be used to endorse or promote products derived from this software
     70            *      without specific prior written permission.
     71            *
     72            * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
     73            * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     74            * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     75            * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
     76            * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
     77            * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
     78            * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
     79            * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
     80            * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
     81            * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     82            *
     83            ******************************************************************************
     84            */
     85              
     86          /* Includes ------------------------------------------------------------------*/
     87          #include "stm32f7xx_hal.h"
     88             
     89          /** @addtogroup STM32F7xx_HAL_Driver
     90            * @{
     91            */
     92          
     93          /** @defgroup SPI SPI 
     94            * @brief SPI HAL module driver
     95            * @{
     96            */
     97          #ifdef HAL_SPI_MODULE_ENABLED
     98          
     99          /* Private typedef -----------------------------------------------------------*/
    100          /* Private defines -----------------------------------------------------------*/
    101          /** @defgroup SPI_Private_Constants SPI Private Constants
    102            * @{
    103            */
    104          #define SPI_DEFAULT_TIMEOUT 50
    105          /**
    106            * @}
    107            */
    108          
    109          /* Private macro -------------------------------------------------------------*/
    110          /* Private variables ---------------------------------------------------------*/
    111          /* Private function prototypes -----------------------------------------------*/
    112          /** @addtogroup SPI_Private_Functions
    113            * @{
    114            */
    115          static void SPI_DMATransmitCplt(DMA_HandleTypeDef *hdma);
    116          static void SPI_DMAReceiveCplt(DMA_HandleTypeDef *hdma);
    117          static void SPI_DMATransmitReceiveCplt(DMA_HandleTypeDef *hdma);
    118          static void SPI_DMAHalfTransmitCplt(DMA_HandleTypeDef *hdma);
    119          static void SPI_DMAHalfReceiveCplt(DMA_HandleTypeDef *hdma);
    120          static void SPI_DMAHalfTransmitReceiveCplt(DMA_HandleTypeDef *hdma);
    121          static void SPI_DMAError(DMA_HandleTypeDef *hdma);
    122          static HAL_StatusTypeDef SPI_WaitFlagStateUntilTimeout(SPI_HandleTypeDef *hspi, uint32_t Flag, uint32_t State, uint32_t Timeout);
    123          static HAL_StatusTypeDef SPI_WaitFifoStateUntilTimeout(SPI_HandleTypeDef *hspi, uint32_t Fifo, uint32_t State, uint32_t Timeout);
    124          static void SPI_TxISR_8BIT(struct __SPI_HandleTypeDef *hspi);
    125          static void SPI_TxISR_16BIT(struct __SPI_HandleTypeDef *hspi);
    126          static void SPI_RxISR_8BIT(struct __SPI_HandleTypeDef *hspi);
    127          static void SPI_RxISR_8BITCRC(struct __SPI_HandleTypeDef *hspi);
    128          static void SPI_RxISR_16BIT(struct __SPI_HandleTypeDef *hspi);
    129          static void SPI_RxISR_16BITCRC(struct __SPI_HandleTypeDef *hspi);
    130          static void SPI_2linesRxISR_8BIT(struct __SPI_HandleTypeDef *hspi);
    131          static void SPI_2linesRxISR_8BITCRC(struct __SPI_HandleTypeDef *hspi);
    132          static void SPI_2linesTxISR_8BIT(struct __SPI_HandleTypeDef *hspi);
    133          static void SPI_2linesTxISR_16BIT(struct __SPI_HandleTypeDef *hspi);
    134          static void SPI_2linesRxISR_16BIT(struct __SPI_HandleTypeDef *hspi);
    135          static void SPI_2linesRxISR_16BITCRC(struct __SPI_HandleTypeDef *hspi);
    136          static void SPI_CloseRxTx_ISR(SPI_HandleTypeDef *hspi);
    137          static void SPI_CloseRx_ISR(SPI_HandleTypeDef *hspi);
    138          static void SPI_CloseTx_ISR(SPI_HandleTypeDef *hspi);
    139          static HAL_StatusTypeDef SPI_EndRxTransaction(SPI_HandleTypeDef *hspi, uint32_t Timeout);
    140          static HAL_StatusTypeDef SPI_EndRxTxTransaction(SPI_HandleTypeDef *hspi, uint32_t Timeout);
    141          /**
    142            * @}
    143            */
    144          
    145          /* Exported functions ---------------------------------------------------------*/
    146          
    147          /** @defgroup SPI_Exported_Functions SPI Exported Functions
    148            * @{
    149            */
    150          
    151          /** @defgroup SPI_Exported_Functions_Group1 Initialization and de-initialization functions
    152           *  @brief    Initialization and Configuration functions
    153           *
    154          @verbatim
    155           ===============================================================================
    156                        ##### Initialization and de-initialization functions #####
    157           ===============================================================================
    158              [..]  This subsection provides a set of functions allowing to initialize and
    159                    de-initialize the SPIx peripheral:
    160          
    161                (+) User must implement HAL_SPI_MspInit() function in which he configures
    162                    all related peripherals resources (CLOCK, GPIO, DMA, IT and NVIC ).
    163          
    164                (+) Call the function HAL_SPI_Init() to configure the selected device with
    165                    the selected configuration:
    166                  (++) Mode
    167                  (++) Direction
    168                  (++) Data Size
    169                  (++) Clock Polarity and Phase
    170                  (++) NSS Management
    171                  (++) BaudRate Prescaler
    172                  (++) FirstBit
    173                  (++) TIMode
    174                  (++) CRC Calculation
    175                  (++) CRC Polynomial if CRC enabled
    176                  (++) CRC Length, used only with Data8 and Data16
    177                  (++) FIFO reception threshold
    178          
    179                (+) Call the function HAL_SPI_DeInit() to restore the default configuration
    180                    of the selected SPIx peripheral.
    181          
    182          @endverbatim
    183            * @{
    184            */
    185          
    186          /**
    187            * @brief  Initializes the SPI according to the specified parameters
    188            *         in the SPI_InitTypeDef and create the associated handle.
    189            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
    190            *               the configuration information for SPI module.
    191            * @retval HAL status
    192            */

   \                                 In section .text, align 2, keep-with-next
    193          HAL_StatusTypeDef HAL_SPI_Init(SPI_HandleTypeDef *hspi)
    194          {
   \                     HAL_SPI_Init: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
    195            uint32_t frxth;
    196          
    197            /* Check the SPI handle allocation */
    198            if(hspi == NULL)
   \   00000004   0xD101             BNE.N    ??HAL_SPI_Init_0
    199            {
    200              return HAL_ERROR;
   \   00000006   0x2001             MOVS     R0,#+1
   \   00000008   0xBD70             POP      {R4-R6,PC}
    201            }
    202          
    203            /* Check the parameters */
    204            assert_param(IS_SPI_ALL_INSTANCE(hspi->Instance));
    205            assert_param(IS_SPI_MODE(hspi->Init.Mode));
    206            assert_param(IS_SPI_DIRECTION(hspi->Init.Direction));
    207            assert_param(IS_SPI_DATASIZE(hspi->Init.DataSize));
    208            assert_param(IS_SPI_CPOL(hspi->Init.CLKPolarity));
    209            assert_param(IS_SPI_CPHA(hspi->Init.CLKPhase));
    210            assert_param(IS_SPI_NSS(hspi->Init.NSS));
    211            assert_param(IS_SPI_NSSP(hspi->Init.NSSPMode));
    212            assert_param(IS_SPI_BAUDRATE_PRESCALER(hspi->Init.BaudRatePrescaler));
    213            assert_param(IS_SPI_FIRST_BIT(hspi->Init.FirstBit));
    214            assert_param(IS_SPI_TIMODE(hspi->Init.TIMode));
    215            assert_param(IS_SPI_CRC_CALCULATION(hspi->Init.CRCCalculation));
    216            assert_param(IS_SPI_CRC_POLYNOMIAL(hspi->Init.CRCPolynomial));
    217            assert_param(IS_SPI_CRC_LENGTH(hspi->Init.CRCLength));
    218          
    219            if(hspi->State == HAL_SPI_STATE_RESET)
   \                     ??HAL_SPI_Init_0: (+1)
   \   0000000A   0xF104 0x055C      ADD      R5,R4,#+92
   \   0000000E   0x7868             LDRB     R0,[R5, #+1]
   \   00000010   0xB918             CBNZ.N   R0,??HAL_SPI_Init_1
    220            {
    221              /* Allocate lock resource and initialize it */
    222              hspi->Lock = HAL_UNLOCKED;
   \   00000012   0x7028             STRB     R0,[R5, #+0]
    223          
    224              /* Init the low level hardware : GPIO, CLOCK, NVIC... */
    225              HAL_SPI_MspInit(hspi);
   \   00000014   0x4620             MOV      R0,R4
   \   00000016   0x.... 0x....      BL       HAL_SPI_MspInit
    226            }
    227          
    228            hspi->State = HAL_SPI_STATE_BUSY;
   \                     ??HAL_SPI_Init_1: (+1)
   \   0000001A   0x2002             MOVS     R0,#+2
    229          
    230            /* Disable the selected SPI peripheral */
    231            __HAL_SPI_DISABLE(hspi);
    232          
    233            /* Align by default the rs fifo threshold on the data size */
    234            if(hspi->Init.DataSize > SPI_DATASIZE_8BIT)
   \   0000001C   0xF240 0x7301      MOVW     R3,#+1793
   \   00000020   0x7068             STRB     R0,[R5, #+1]
   \   00000022   0x6820             LDR      R0,[R4, #+0]
   \   00000024   0x6801             LDR      R1,[R0, #+0]
   \   00000026   0xF021 0x0140      BIC      R1,R1,#0x40
   \   0000002A   0x6001             STR      R1,[R0, #+0]
   \   0000002C   0x68E2             LDR      R2,[R4, #+12]
   \   0000002E   0x429A             CMP      R2,R3
   \   00000030   0xD304             BCC.N    ??HAL_SPI_Init_2
    235            {
    236              frxth = SPI_RXFIFO_THRESHOLD_HF;
   \   00000032   0x2100             MOVS     R1,#+0
    237            }
    238            else
    239            {
    240              frxth = SPI_RXFIFO_THRESHOLD_QF;
    241            }
    242          
    243            /* CRC calculation is valid only for 16Bit and 8 Bit */
    244            if(( hspi->Init.DataSize != SPI_DATASIZE_16BIT ) && ( hspi->Init.DataSize != SPI_DATASIZE_8BIT ))
   \   00000034   0xF5B2 0x6F70      CMP      R2,#+3840
   \   00000038   0xD105             BNE.N    ??HAL_SPI_Init_3
   \   0000003A   0xE006             B.N      ??HAL_SPI_Init_4
   \                     ??HAL_SPI_Init_2: (+1)
   \   0000003C   0xF5B2 0x6FE0      CMP      R2,#+1792
   \   00000040   0xF44F 0x5180      MOV      R1,#+4096
   \   00000044   0xD001             BEQ.N    ??HAL_SPI_Init_4
    245            {
    246              /* CRC must be disabled */
    247              hspi->Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
   \                     ??HAL_SPI_Init_3: (+1)
   \   00000046   0x2600             MOVS     R6,#+0
   \   00000048   0x62A6             STR      R6,[R4, #+40]
    248            }
    249          
    250            /* Align the CRC Length on the data size */
    251            if( hspi->Init.CRCLength == SPI_CRC_LENGTH_DATASIZE)
   \                     ??HAL_SPI_Init_4: (+1)
   \   0000004A   0x6B26             LDR      R6,[R4, #+48]
   \   0000004C   0xB926             CBNZ.N   R6,??HAL_SPI_Init_5
    252            {
    253              /* CRC Length aligned on the data size : value set by default */
    254              if(hspi->Init.DataSize > SPI_DATASIZE_8BIT)
   \   0000004E   0x429A             CMP      R2,R3
   \   00000050   0xBF2C             ITE      CS 
   \   00000052   0x2202             MOVCS    R2,#+2
   \   00000054   0x2201             MOVCC    R2,#+1
    255              {
    256                hspi->Init.CRCLength = SPI_CRC_LENGTH_16BIT;
    257              }
    258              else
    259              {
    260                hspi->Init.CRCLength = SPI_CRC_LENGTH_8BIT;
   \   00000056   0x6322             STR      R2,[R4, #+48]
    261              }
    262            }
    263          
    264            /*---------------------------- SPIx CR1 & CR2 Configuration ------------------------*/
    265            /* Configure : SPI Mode, Communication Mode, Clock polarity and phase, NSS management,
    266            Communication speed, First bit, CRC calculation state, CRC Length */
    267            hspi->Instance->CR1 = (hspi->Init.Mode | hspi->Init.Direction |
    268                                   hspi->Init.CLKPolarity | hspi->Init.CLKPhase | (hspi->Init.NSS & SPI_CR1_SSM) |
    269                                   hspi->Init.BaudRatePrescaler | hspi->Init.FirstBit  | hspi->Init.CRCCalculation);
   \                     ??HAL_SPI_Init_5: (+1)
   \   00000058   0x6862             LDR      R2,[R4, #+4]
   \   0000005A   0x68A3             LDR      R3,[R4, #+8]
   \   0000005C   0x431A             ORRS     R2,R3,R2
   \   0000005E   0x6923             LDR      R3,[R4, #+16]
   \   00000060   0x431A             ORRS     R2,R3,R2
   \   00000062   0x6963             LDR      R3,[R4, #+20]
   \   00000064   0x431A             ORRS     R2,R3,R2
   \   00000066   0x69A3             LDR      R3,[R4, #+24]
   \   00000068   0xF403 0x7300      AND      R3,R3,#0x200
   \   0000006C   0x431A             ORRS     R2,R3,R2
   \   0000006E   0x69E3             LDR      R3,[R4, #+28]
   \   00000070   0x431A             ORRS     R2,R3,R2
   \   00000072   0x6A23             LDR      R3,[R4, #+32]
   \   00000074   0x431A             ORRS     R2,R3,R2
   \   00000076   0x6AA3             LDR      R3,[R4, #+40]
   \   00000078   0x431A             ORRS     R2,R3,R2
   \   0000007A   0x6002             STR      R2,[R0, #+0]
    270          
    271            if( hspi->Init.CRCLength == SPI_CRC_LENGTH_16BIT)
   \   0000007C   0x6B22             LDR      R2,[R4, #+48]
   \   0000007E   0x2A02             CMP      R2,#+2
   \   00000080   0xD103             BNE.N    ??HAL_SPI_Init_6
    272            {
    273              hspi->Instance->CR1|= SPI_CR1_CRCL;
   \   00000082   0x6802             LDR      R2,[R0, #+0]
   \   00000084   0xF442 0x6200      ORR      R2,R2,#0x800
   \   00000088   0x6002             STR      R2,[R0, #+0]
    274            }
    275          
    276            /* Configure : NSS management */
    277            /* Configure : Rx Fifo Threshold */
    278            hspi->Instance->CR2 = (((hspi->Init.NSS >> 16) & SPI_CR2_SSOE) | hspi->Init.TIMode | hspi->Init.NSSPMode |
    279                                   hspi->Init.DataSize ) | frxth;
   \                     ??HAL_SPI_Init_6: (+1)
   \   0000008A   0x69A2             LDR      R2,[R4, #+24]
   \   0000008C   0x6A63             LDR      R3,[R4, #+36]
   \   0000008E   0x0C12             LSRS     R2,R2,#+16
   \   00000090   0xF002 0x0204      AND      R2,R2,#0x4
   \   00000094   0x431A             ORRS     R2,R3,R2
   \   00000096   0x6B63             LDR      R3,[R4, #+52]
   \   00000098   0x431A             ORRS     R2,R3,R2
   \   0000009A   0x68E3             LDR      R3,[R4, #+12]
   \   0000009C   0x431A             ORRS     R2,R3,R2
   \   0000009E   0x4311             ORRS     R1,R1,R2
   \   000000A0   0x6041             STR      R1,[R0, #+4]
    280          
    281            /*---------------------------- SPIx CRCPOLY Configuration --------------------*/
    282            /* Configure : CRC Polynomial */
    283            hspi->Instance->CRCPR = hspi->Init.CRCPolynomial;
   \   000000A2   0x6AE1             LDR      R1,[R4, #+44]
   \   000000A4   0x6101             STR      R1,[R0, #+16]
    284          
    285            hspi->ErrorCode = HAL_SPI_ERROR_NONE;
   \   000000A6   0x2000             MOVS     R0,#+0
   \   000000A8   0x6068             STR      R0,[R5, #+4]
    286            hspi->State= HAL_SPI_STATE_READY;
   \   000000AA   0x2001             MOVS     R0,#+1
   \   000000AC   0x7068             STRB     R0,[R5, #+1]
    287          
    288            return HAL_OK;
   \   000000AE   0x2000             MOVS     R0,#+0
   \   000000B0   0xBD70             POP      {R4-R6,PC}       ;; return
    289          }
    290          
    291          /**
    292            * @brief  DeInitializes the SPI peripheral
    293            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
    294            *               the configuration information for SPI module.
    295            * @retval HAL status
    296            */

   \                                 In section .text, align 2, keep-with-next
    297          HAL_StatusTypeDef HAL_SPI_DeInit(SPI_HandleTypeDef *hspi)
    298          {
   \                     HAL_SPI_DeInit: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0xB082             SUB      SP,SP,#+8
    299            /* Check the SPI handle allocation */
    300            if(hspi == NULL)
   \   00000006   0xD101             BNE.N    ??HAL_SPI_DeInit_0
    301            {
    302              return HAL_ERROR;
   \   00000008   0x2001             MOVS     R0,#+1
   \   0000000A   0xBD76             POP      {R1,R2,R4-R6,PC}
    303            }
    304          
    305            /* Check the parameters */
    306            assert_param(IS_SPI_ALL_INSTANCE(hspi->Instance));
    307          
    308            hspi->State = HAL_SPI_STATE_BUSY;
   \                     ??HAL_SPI_DeInit_0: (+1)
   \   0000000C   0xF104 0x055C      ADD      R5,R4,#+92
   \   00000010   0x2002             MOVS     R0,#+2
   \   00000012   0x7068             STRB     R0,[R5, #+1]
    309          
    310            /* check flag before the SPI disable */
    311            SPI_WaitFifoStateUntilTimeout(hspi, SPI_FLAG_FTLVL, SPI_FTLVL_EMPTY, SPI_DEFAULT_TIMEOUT);
   \   00000014   0x.... 0x....      BL       HAL_GetTick
   \   00000018   0x4606             MOV      R6,R0
   \                     ??HAL_SPI_DeInit_1: (+1)
   \   0000001A   0x6820             LDR      R0,[R4, #+0]
   \   0000001C   0x6880             LDR      R0,[R0, #+8]
   \   0000001E   0xF410 0x5FC0      TST      R0,#0x1800
   \   00000022   0xD029             BEQ.N    ??HAL_SPI_DeInit_2
   \   00000024   0x.... 0x....      BL       HAL_GetTick
   \   00000028   0x1B80             SUBS     R0,R0,R6
   \   0000002A   0x2832             CMP      R0,#+50
   \   0000002C   0xD3F5             BCC.N    ??HAL_SPI_DeInit_1
   \   0000002E   0x6820             LDR      R0,[R4, #+0]
   \   00000030   0x6841             LDR      R1,[R0, #+4]
   \   00000032   0xF021 0x01E0      BIC      R1,R1,#0xE0
   \   00000036   0x6041             STR      R1,[R0, #+4]
   \   00000038   0x6861             LDR      R1,[R4, #+4]
   \   0000003A   0xF5B1 0x7F82      CMP      R1,#+260
   \   0000003E   0xD10A             BNE.N    ??HAL_SPI_DeInit_3
   \   00000040   0x68A1             LDR      R1,[R4, #+8]
   \   00000042   0xF5B1 0x4F00      CMP      R1,#+32768
   \   00000046   0xBF18             IT       NE 
   \   00000048   0xF5B1 0x6F80      CMPNE    R1,#+1024
   \   0000004C   0xD103             BNE.N    ??HAL_SPI_DeInit_3
   \   0000004E   0x6801             LDR      R1,[R0, #+0]
   \   00000050   0xF021 0x0140      BIC      R1,R1,#0x40
   \   00000054   0x6001             STR      R1,[R0, #+0]
   \                     ??HAL_SPI_DeInit_3: (+1)
   \   00000056   0x6AA1             LDR      R1,[R4, #+40]
   \   00000058   0xF5B1 0x5F00      CMP      R1,#+8192
   \   0000005C   0xD108             BNE.N    ??HAL_SPI_DeInit_4
   \   0000005E   0x6801             LDR      R1,[R0, #+0]
   \   00000060   0xF64D 0x72FF      MOVW     R2,#+57343
   \   00000064   0x4011             ANDS     R1,R2,R1
   \   00000066   0x6001             STR      R1,[R0, #+0]
   \   00000068   0x6801             LDR      R1,[R0, #+0]
   \   0000006A   0xF441 0x5100      ORR      R1,R1,#0x2000
   \   0000006E   0x6001             STR      R1,[R0, #+0]
   \                     ??HAL_SPI_DeInit_4: (+1)
   \   00000070   0x2001             MOVS     R0,#+1
   \   00000072   0x7068             STRB     R0,[R5, #+1]
   \   00000074   0x2000             MOVS     R0,#+0
   \   00000076   0x7028             STRB     R0,[R5, #+0]
    312            SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_BSY, RESET, SPI_DEFAULT_TIMEOUT);
   \                     ??HAL_SPI_DeInit_2: (+1)
   \   00000078   0x.... 0x....      BL       HAL_GetTick
   \   0000007C   0x4606             MOV      R6,R0
   \                     ??HAL_SPI_DeInit_5: (+1)
   \   0000007E   0x6820             LDR      R0,[R4, #+0]
   \   00000080   0x6880             LDR      R0,[R0, #+8]
   \   00000082   0x0600             LSLS     R0,R0,#+24
   \   00000084   0xD529             BPL.N    ??HAL_SPI_DeInit_6
   \   00000086   0x.... 0x....      BL       HAL_GetTick
   \   0000008A   0x1B80             SUBS     R0,R0,R6
   \   0000008C   0x2832             CMP      R0,#+50
   \   0000008E   0xD3F6             BCC.N    ??HAL_SPI_DeInit_5
   \   00000090   0x6820             LDR      R0,[R4, #+0]
   \   00000092   0x6841             LDR      R1,[R0, #+4]
   \   00000094   0xF021 0x01E0      BIC      R1,R1,#0xE0
   \   00000098   0x6041             STR      R1,[R0, #+4]
   \   0000009A   0x6861             LDR      R1,[R4, #+4]
   \   0000009C   0xF5B1 0x7F82      CMP      R1,#+260
   \   000000A0   0xD10A             BNE.N    ??HAL_SPI_DeInit_7
   \   000000A2   0x68A1             LDR      R1,[R4, #+8]
   \   000000A4   0xF5B1 0x4F00      CMP      R1,#+32768
   \   000000A8   0xBF18             IT       NE 
   \   000000AA   0xF5B1 0x6F80      CMPNE    R1,#+1024
   \   000000AE   0xD103             BNE.N    ??HAL_SPI_DeInit_7
   \   000000B0   0x6801             LDR      R1,[R0, #+0]
   \   000000B2   0xF021 0x0140      BIC      R1,R1,#0x40
   \   000000B6   0x6001             STR      R1,[R0, #+0]
   \                     ??HAL_SPI_DeInit_7: (+1)
   \   000000B8   0x6AA1             LDR      R1,[R4, #+40]
   \   000000BA   0xF5B1 0x5F00      CMP      R1,#+8192
   \   000000BE   0xD108             BNE.N    ??HAL_SPI_DeInit_8
   \   000000C0   0x6801             LDR      R1,[R0, #+0]
   \   000000C2   0xF64D 0x72FF      MOVW     R2,#+57343
   \   000000C6   0x4011             ANDS     R1,R2,R1
   \   000000C8   0x6001             STR      R1,[R0, #+0]
   \   000000CA   0x6801             LDR      R1,[R0, #+0]
   \   000000CC   0xF441 0x5100      ORR      R1,R1,#0x2000
   \   000000D0   0x6001             STR      R1,[R0, #+0]
   \                     ??HAL_SPI_DeInit_8: (+1)
   \   000000D2   0x2001             MOVS     R0,#+1
   \   000000D4   0x7068             STRB     R0,[R5, #+1]
   \   000000D6   0x2000             MOVS     R0,#+0
   \   000000D8   0x7028             STRB     R0,[R5, #+0]
    313            SPI_WaitFifoStateUntilTimeout(hspi, SPI_FLAG_FRLVL, SPI_FRLVL_EMPTY, SPI_DEFAULT_TIMEOUT);
   \                     ??HAL_SPI_DeInit_6: (+1)
   \   000000DA   0x.... 0x....      BL       HAL_GetTick
   \   000000DE   0x4606             MOV      R6,R0
   \                     ??HAL_SPI_DeInit_9: (+1)
   \   000000E0   0x6820             LDR      R0,[R4, #+0]
   \   000000E2   0x6881             LDR      R1,[R0, #+8]
   \   000000E4   0xF411 0x6FC0      TST      R1,#0x600
   \   000000E8   0xD02E             BEQ.N    ??HAL_SPI_DeInit_10
   \   000000EA   0x7B00             LDRB     R0,[R0, #+12]
   \   000000EC   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \   000000F0   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   000000F4   0x.... 0x....      BL       HAL_GetTick
   \   000000F8   0x1B80             SUBS     R0,R0,R6
   \   000000FA   0x2832             CMP      R0,#+50
   \   000000FC   0xD3F0             BCC.N    ??HAL_SPI_DeInit_9
   \   000000FE   0x6820             LDR      R0,[R4, #+0]
   \   00000100   0x6841             LDR      R1,[R0, #+4]
   \   00000102   0xF021 0x01E0      BIC      R1,R1,#0xE0
   \   00000106   0x6041             STR      R1,[R0, #+4]
   \   00000108   0x6861             LDR      R1,[R4, #+4]
   \   0000010A   0xF5B1 0x7F82      CMP      R1,#+260
   \   0000010E   0xD10A             BNE.N    ??HAL_SPI_DeInit_11
   \   00000110   0x68A1             LDR      R1,[R4, #+8]
   \   00000112   0xF5B1 0x4F00      CMP      R1,#+32768
   \   00000116   0xBF18             IT       NE 
   \   00000118   0xF5B1 0x6F80      CMPNE    R1,#+1024
   \   0000011C   0xD103             BNE.N    ??HAL_SPI_DeInit_11
   \   0000011E   0x6801             LDR      R1,[R0, #+0]
   \   00000120   0xF021 0x0140      BIC      R1,R1,#0x40
   \   00000124   0x6001             STR      R1,[R0, #+0]
   \                     ??HAL_SPI_DeInit_11: (+1)
   \   00000126   0x6AA1             LDR      R1,[R4, #+40]
   \   00000128   0xF5B1 0x5F00      CMP      R1,#+8192
   \   0000012C   0xD108             BNE.N    ??HAL_SPI_DeInit_12
   \   0000012E   0x6801             LDR      R1,[R0, #+0]
   \   00000130   0xF64D 0x72FF      MOVW     R2,#+57343
   \   00000134   0x4011             ANDS     R1,R2,R1
   \   00000136   0x6001             STR      R1,[R0, #+0]
   \   00000138   0x6801             LDR      R1,[R0, #+0]
   \   0000013A   0xF441 0x5100      ORR      R1,R1,#0x2000
   \   0000013E   0x6001             STR      R1,[R0, #+0]
   \                     ??HAL_SPI_DeInit_12: (+1)
   \   00000140   0x2001             MOVS     R0,#+1
   \   00000142   0x7068             STRB     R0,[R5, #+1]
   \   00000144   0x2000             MOVS     R0,#+0
   \   00000146   0x7028             STRB     R0,[R5, #+0]
    314          
    315            /* Disable the SPI Peripheral Clock */
    316            __HAL_SPI_DISABLE(hspi);
   \                     ??HAL_SPI_DeInit_10: (+1)
   \   00000148   0x6820             LDR      R0,[R4, #+0]
   \   0000014A   0x6801             LDR      R1,[R0, #+0]
   \   0000014C   0xF021 0x0140      BIC      R1,R1,#0x40
   \   00000150   0x6001             STR      R1,[R0, #+0]
    317          
    318            /* DeInit the low level hardware: GPIO, CLOCK, NVIC... */
    319            HAL_SPI_MspDeInit(hspi);
   \   00000152   0x4620             MOV      R0,R4
   \   00000154   0x.... 0x....      BL       HAL_SPI_MspDeInit
    320          
    321            hspi->ErrorCode = HAL_SPI_ERROR_NONE;
   \   00000158   0x2000             MOVS     R0,#+0
   \   0000015A   0x6068             STR      R0,[R5, #+4]
    322            hspi->State = HAL_SPI_STATE_RESET;
   \   0000015C   0x7068             STRB     R0,[R5, #+1]
    323          
    324            __HAL_UNLOCK(hspi);
   \   0000015E   0x7028             STRB     R0,[R5, #+0]
    325          
    326            return HAL_OK;
   \   00000160   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
    327          }
    328          
    329          /**
    330            * @brief SPI MSP Init
    331            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
    332            *               the configuration information for SPI module.
    333            * @retval None
    334            */

   \                                 In section .text, align 2, keep-with-next
    335           __weak void HAL_SPI_MspInit(SPI_HandleTypeDef *hspi)
    336           {
    337            /* Prevent unused argument(s) compilation warning */
    338            UNUSED(hspi);
    339           
    340             /* NOTE : This function should not be modified, when the callback is needed,
    341                      the HAL_SPI_MspInit should be implemented in the user file
    342             */
    343          }
   \                     HAL_SPI_MspInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    344          
    345          /**
    346            * @brief SPI MSP DeInit
    347            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
    348            *               the configuration information for SPI module.
    349            * @retval None
    350            */

   \                                 In section .text, align 2, keep-with-next
    351           __weak void HAL_SPI_MspDeInit(SPI_HandleTypeDef *hspi)
    352          {
    353            /* Prevent unused argument(s) compilation warning */
    354            UNUSED(hspi);
    355           
    356            /* NOTE : This function should not be modified, when the callback is needed,
    357                      the HAL_SPI_MspDeInit should be implemented in the user file
    358             */
    359          }
   \                     HAL_SPI_MspDeInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    360          
    361          /**
    362            * @}
    363            */
    364          
    365          /** @defgroup SPI_Exported_Functions_Group2 IO operation functions
    366           *  @brief   Data transfers functions
    367           *
    368          @verbatim
    369            ==============================================================================
    370                                ##### IO operation functions #####
    371           ===============================================================================
    372              This subsection provides a set of functions allowing to manage the SPI
    373              data transfers.
    374          
    375              [..] The SPI supports master and slave mode :
    376          
    377              (#) There are two modes of transfer:
    378                 (++) Blocking mode: The communication is performed in polling mode.
    379                      The HAL status of all data processing is returned by the same function
    380                      after finishing transfer.
    381                 (++) No-Blocking mode: The communication is performed using Interrupts
    382                     or DMA, These APIs return the HAL status.
    383                     The end of the data processing will be indicated through the
    384                     dedicated SPI IRQ when using Interrupt mode or the DMA IRQ when
    385                     using DMA mode.
    386                     The HAL_SPI_TxCpltCallback(), HAL_SPI_RxCpltCallback() and HAL_SPI_TxRxCpltCallback() user callbacks
    387                     will be executed respectively at the end of the transmit or Receive process
    388                     The HAL_SPI_ErrorCallback()user callback will be executed when a communication error is detected
    389          
    390              (#) APIs provided for these 2 transfer modes (Blocking mode or Non blocking mode using either Interrupt or DMA)
    391                  exist for 1Line (simplex) and 2Lines (full duplex) modes.
    392          
    393          @endverbatim
    394            * @{
    395            */
    396          
    397          /**
    398            * @brief  Transmit an amount of data in blocking mode
    399            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
    400            *               the configuration information for SPI module.
    401            * @param  pData: pointer to data buffer
    402            * @param  Size: amount of data to be sent
    403            * @param  Timeout: Timeout duration
    404            * @retval HAL status
    405            */

   \                                 In section .text, align 2, keep-with-next
    406          HAL_StatusTypeDef HAL_SPI_Transmit(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size, uint32_t Timeout)
    407          {
   \                     HAL_SPI_Transmit: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4605             MOV      R5,R0
    408            assert_param(IS_SPI_DIRECTION_2LINES_OR_1LINE(hspi->Init.Direction));
    409          
    410            /* Process Locked */
    411            __HAL_LOCK(hspi);
   \   00000006   0xF105 0x045C      ADD      R4,R5,#+92
   \   0000000A   0xB082             SUB      SP,SP,#+8
   \   0000000C   0x461E             MOV      R6,R3
   \   0000000E   0x7820             LDRB     R0,[R4, #+0]
   \   00000010   0x2801             CMP      R0,#+1
   \   00000012   0xD008             BEQ.N    ??HAL_SPI_Transmit_0
   \   00000014   0x2001             MOVS     R0,#+1
   \   00000016   0x7020             STRB     R0,[R4, #+0]
    412          
    413            if(hspi->State != HAL_SPI_STATE_READY)
   \   00000018   0x7860             LDRB     R0,[R4, #+1]
   \   0000001A   0x2801             CMP      R0,#+1
   \   0000001C   0xD004             BEQ.N    ??HAL_SPI_Transmit_1
    414            {
    415              hspi->State = HAL_SPI_STATE_READY;
   \   0000001E   0x2001             MOVS     R0,#+1
   \   00000020   0x7060             STRB     R0,[R4, #+1]
    416             /* Process Unlocked */
    417             __HAL_UNLOCK(hspi);
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0x7020             STRB     R0,[R4, #+0]
    418             return HAL_BUSY;
    419            }
   \                     ??HAL_SPI_Transmit_0: (+1)
   \   00000026   0x....             B.N      ?Subroutine2
    420            
    421            if((pData == NULL ) || (Size == 0))
   \                     ??HAL_SPI_Transmit_1: (+1)
   \   00000028   0x2900             CMP      R1,#+0
   \   0000002A   0xBF18             IT       NE 
   \   0000002C   0x2A00             CMPNE    R2,#+0
   \   0000002E   0xD103             BNE.N    ??HAL_SPI_Transmit_2
    422            {
    423              hspi->State = HAL_SPI_STATE_READY;
   \   00000030   0x7060             STRB     R0,[R4, #+1]
    424             /* Process Unlocked */
    425             __HAL_UNLOCK(hspi);
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0x7020             STRB     R0,[R4, #+0]
    426              return HAL_ERROR;
   \   00000036   0x....             B.N      ?Subroutine1
    427            }
    428          
    429            /* Set the transaction information */
    430            hspi->State       = HAL_SPI_STATE_BUSY_TX;
   \                     ??HAL_SPI_Transmit_2: (+1)
   \   00000038   0x2003             MOVS     R0,#+3
    431            hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
    432            hspi->pTxBuffPtr  = pData;
   \   0000003A   0xF105 0x0738      ADD      R7,R5,#+56
   \   0000003E   0x7060             STRB     R0,[R4, #+1]
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0x6060             STR      R0,[R4, #+4]
   \   00000044   0x6039             STR      R1,[R7, #+0]
    433            hspi->TxXferSize  = Size;
   \   00000046   0x80BA             STRH     R2,[R7, #+4]
    434            hspi->TxXferCount = Size;
   \   00000048   0x80FA             STRH     R2,[R7, #+6]
    435            hspi->pRxBuffPtr  = (uint8_t *)NULL;
   \   0000004A   0x60B8             STR      R0,[R7, #+8]
    436            hspi->RxXferSize  = 0;
   \   0000004C   0x81B8             STRH     R0,[R7, #+12]
    437            hspi->RxXferCount = 0;
   \   0000004E   0x81F8             STRH     R0,[R7, #+14]
    438          
    439            /* Configure communication direction : 1Line */
    440            if(hspi->Init.Direction == SPI_DIRECTION_1LINE)
   \   00000050   0x68A9             LDR      R1,[R5, #+8]
   \   00000052   0x6828             LDR      R0,[R5, #+0]
   \   00000054   0xF5B1 0x4F00      CMP      R1,#+32768
   \   00000058   0xD103             BNE.N    ??HAL_SPI_Transmit_3
    441            {
    442              SPI_1LINE_TX(hspi);
   \   0000005A   0x6801             LDR      R1,[R0, #+0]
   \   0000005C   0xF441 0x4180      ORR      R1,R1,#0x4000
   \   00000060   0x6001             STR      R1,[R0, #+0]
    443            }
    444          
    445            /* Reset CRC Calculation */
    446            if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   \                     ??HAL_SPI_Transmit_3: (+1)
   \   00000062   0x6AA9             LDR      R1,[R5, #+40]
   \   00000064   0xF5B1 0x5F00      CMP      R1,#+8192
   \   00000068   0xD108             BNE.N    ??HAL_SPI_Transmit_4
    447            {
    448              SPI_RESET_CRC(hspi);
   \   0000006A   0x6801             LDR      R1,[R0, #+0]
   \   0000006C   0xF64D 0x72FF      MOVW     R2,#+57343
   \   00000070   0x4011             ANDS     R1,R2,R1
   \   00000072   0x6001             STR      R1,[R0, #+0]
   \   00000074   0x6801             LDR      R1,[R0, #+0]
   \   00000076   0xF441 0x5100      ORR      R1,R1,#0x2000
   \   0000007A   0x6001             STR      R1,[R0, #+0]
    449            }
    450          
    451            /* Check if the SPI is already enabled */
    452            if((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
   \                     ??HAL_SPI_Transmit_4: (+1)
   \   0000007C   0x6801             LDR      R1,[R0, #+0]
   \   0000007E   0x0649             LSLS     R1,R1,#+25
   \   00000080   0xD403             BMI.N    ??HAL_SPI_Transmit_5
    453            {
    454              /* Enable SPI peripheral */
    455              __HAL_SPI_ENABLE(hspi);
   \   00000082   0x6801             LDR      R1,[R0, #+0]
   \   00000084   0xF041 0x0140      ORR      R1,R1,#0x40
   \   00000088   0x6001             STR      R1,[R0, #+0]
    456            }
    457          
    458            /* Transmit data in 16 Bit mode */
    459            if(hspi->Init.DataSize > SPI_DATASIZE_8BIT)
   \                     ??HAL_SPI_Transmit_5: (+1)
   \   0000008A   0x68E8             LDR      R0,[R5, #+12]
   \   0000008C   0xF5B0 0x6FE0      CMP      R0,#+1792
   \   00000090   0xD926             BLS.N    ??HAL_SPI_Transmit_6
   \   00000092   0xE007             B.N      ??HAL_SPI_Transmit_7
    460            {
    461              /* Transmit data in 16 Bit mode */
    462              while (hspi->TxXferCount > 0)
    463              {
    464                /* Wait until TXE flag is set to send data */
    465                if(SPI_WaitFlagStateUntilTimeout(hspi,SPI_FLAG_TXE,SPI_FLAG_TXE,Timeout) != HAL_OK)
    466                {
    467                  hspi->State = HAL_SPI_STATE_READY;
    468                  /* Process Unlocked */
    469                 __HAL_UNLOCK(hspi);
    470                  return HAL_TIMEOUT;
    471                }
    472                hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
   \                     ??HAL_SPI_Transmit_8: (+1)
   \   00000094   0x6838             LDR      R0,[R7, #+0]
   \   00000096   0xF830 0x2B02      LDRH     R2,[R0], #+2
   \   0000009A   0x60CA             STR      R2,[R1, #+12]
    473                hspi->pTxBuffPtr += sizeof(uint16_t);
   \   0000009C   0x6038             STR      R0,[R7, #+0]
    474                hspi->TxXferCount--;
   \   0000009E   0x88F8             LDRH     R0,[R7, #+6]
   \   000000A0   0x1E40             SUBS     R0,R0,#+1
   \   000000A2   0x80F8             STRH     R0,[R7, #+6]
   \                     ??HAL_SPI_Transmit_7: (+1)
   \   000000A4   0x88F8             LDRH     R0,[R7, #+6]
   \   000000A6   0x2800             CMP      R0,#+0
   \   000000A8   0xF000 0x8096      BEQ.W    ??HAL_SPI_Transmit_9
   \   000000AC   0x.... 0x....      BL       HAL_GetTick
   \   000000B0   0x4680             MOV      R8,R0
   \                     ??HAL_SPI_Transmit_10: (+1)
   \   000000B2   0x6829             LDR      R1,[R5, #+0]
   \   000000B4   0x6888             LDR      R0,[R1, #+8]
   \   000000B6   0x0780             LSLS     R0,R0,#+30
   \   000000B8   0xD4EC             BMI.N    ??HAL_SPI_Transmit_8
   \   000000BA   0xF116 0x0F01      CMN      R6,#+1
   \   000000BE   0xD0F8             BEQ.N    ??HAL_SPI_Transmit_10
   \   000000C0   0xB326             CBZ.N    R6,??HAL_SPI_Transmit_11
   \   000000C2   0x.... 0x....      BL       HAL_GetTick
   \   000000C6   0xEBA0 0x0008      SUB      R0,R0,R8
   \   000000CA   0x42B0             CMP      R0,R6
   \   000000CC   0xD3F1             BCC.N    ??HAL_SPI_Transmit_10
   \   000000CE   0xE01D             B.N      ??HAL_SPI_Transmit_11
    475              }
    476            }
    477            /* Transmit data in 8 Bit mode */
    478            else
    479            {
    480              while (hspi->TxXferCount > 0)
    481              {
    482                if(hspi->TxXferCount != 0x1)
    483                {
    484                  /* Wait until TXE flag is set to send data */
    485                  if(SPI_WaitFlagStateUntilTimeout(hspi,SPI_FLAG_TXE,SPI_FLAG_TXE,Timeout) != HAL_OK)
    486                  {
    487                    hspi->State = HAL_SPI_STATE_READY;
    488                    /* Process Unlocked */
    489                    __HAL_UNLOCK(hspi);
    490                    return HAL_TIMEOUT;
    491                  }
    492                  hspi->Instance->DR = *((uint16_t*)hspi->pTxBuffPtr);
   \                     ??HAL_SPI_Transmit_12: (+1)
   \   000000D0   0x6838             LDR      R0,[R7, #+0]
   \   000000D2   0xF830 0x2B02      LDRH     R2,[R0], #+2
   \   000000D6   0x60CA             STR      R2,[R1, #+12]
    493                  hspi->pTxBuffPtr += sizeof(uint16_t);
   \   000000D8   0x6038             STR      R0,[R7, #+0]
    494                  hspi->TxXferCount -= 2;
   \   000000DA   0x88F8             LDRH     R0,[R7, #+6]
   \   000000DC   0x1E80             SUBS     R0,R0,#+2
   \                     ??HAL_SPI_Transmit_13: (+1)
   \   000000DE   0x80F8             STRH     R0,[R7, #+6]
   \                     ??HAL_SPI_Transmit_6: (+1)
   \   000000E0   0x88F8             LDRH     R0,[R7, #+6]
   \   000000E2   0x2800             CMP      R0,#+0
   \   000000E4   0xD078             BEQ.N    ??HAL_SPI_Transmit_9
   \   000000E6   0x2801             CMP      R0,#+1
   \   000000E8   0xD036             BEQ.N    ??HAL_SPI_Transmit_14
   \   000000EA   0x.... 0x....      BL       HAL_GetTick
   \   000000EE   0x4680             MOV      R8,R0
   \                     ??HAL_SPI_Transmit_15: (+1)
   \   000000F0   0x6829             LDR      R1,[R5, #+0]
   \   000000F2   0x6888             LDR      R0,[R1, #+8]
   \   000000F4   0x0780             LSLS     R0,R0,#+30
   \   000000F6   0xD4EB             BMI.N    ??HAL_SPI_Transmit_12
   \   000000F8   0xF116 0x0F01      CMN      R6,#+1
   \   000000FC   0xD0F8             BEQ.N    ??HAL_SPI_Transmit_15
   \   000000FE   0xB12E             CBZ.N    R6,??HAL_SPI_Transmit_11
   \   00000100   0x.... 0x....      BL       HAL_GetTick
   \   00000104   0xEBA0 0x0008      SUB      R0,R0,R8
   \   00000108   0x42B0             CMP      R0,R6
   \   0000010A   0xD3F1             BCC.N    ??HAL_SPI_Transmit_15
   \                     ??HAL_SPI_Transmit_11: (+1)
   \   0000010C   0x6828             LDR      R0,[R5, #+0]
   \   0000010E   0x6841             LDR      R1,[R0, #+4]
   \   00000110   0xF021 0x01E0      BIC      R1,R1,#0xE0
   \   00000114   0x6041             STR      R1,[R0, #+4]
   \   00000116   0x6869             LDR      R1,[R5, #+4]
   \   00000118   0xF5B1 0x7F82      CMP      R1,#+260
   \   0000011C   0xD10A             BNE.N    ??HAL_SPI_Transmit_16
   \   0000011E   0x68A9             LDR      R1,[R5, #+8]
   \   00000120   0xF5B1 0x4F00      CMP      R1,#+32768
   \   00000124   0xBF18             IT       NE 
   \   00000126   0xF5B1 0x6F80      CMPNE    R1,#+1024
   \   0000012A   0xD103             BNE.N    ??HAL_SPI_Transmit_16
   \   0000012C   0x6801             LDR      R1,[R0, #+0]
   \   0000012E   0xF021 0x0140      BIC      R1,R1,#0x40
   \   00000132   0x6001             STR      R1,[R0, #+0]
   \                     ??HAL_SPI_Transmit_16: (+1)
   \   00000134   0x6AA9             LDR      R1,[R5, #+40]
   \   00000136   0xF5B1 0x5F00      CMP      R1,#+8192
   \   0000013A   0xD108             BNE.N    ??HAL_SPI_Transmit_17
   \   0000013C   0x6801             LDR      R1,[R0, #+0]
   \   0000013E   0xF64D 0x72FF      MOVW     R2,#+57343
   \   00000142   0x4011             ANDS     R1,R2,R1
   \   00000144   0x6001             STR      R1,[R0, #+0]
   \   00000146   0x6801             LDR      R1,[R0, #+0]
   \   00000148   0xF441 0x5100      ORR      R1,R1,#0x2000
   \   0000014C   0x6001             STR      R1,[R0, #+0]
   \                     ??HAL_SPI_Transmit_17: (+1)
   \   0000014E   0x2001             MOVS     R0,#+1
   \   00000150   0x7060             STRB     R0,[R4, #+1]
   \   00000152   0x2000             MOVS     R0,#+0
   \   00000154   0x7020             STRB     R0,[R4, #+0]
   \   00000156   0xE04D             B.N      ??HAL_SPI_Transmit_18
    495                }
    496                else
    497                {
    498                  /* Wait until TXE flag is set to send data */
    499                  if(SPI_WaitFlagStateUntilTimeout(hspi,SPI_FLAG_TXE,SPI_FLAG_TXE,Timeout) != HAL_OK)  
   \                     ??HAL_SPI_Transmit_14: (+1)
   \   00000158   0x.... 0x....      BL       HAL_GetTick
   \   0000015C   0x4680             MOV      R8,R0
   \                     ??HAL_SPI_Transmit_19: (+1)
   \   0000015E   0x6828             LDR      R0,[R5, #+0]
   \   00000160   0x6881             LDR      R1,[R0, #+8]
   \   00000162   0x0789             LSLS     R1,R1,#+30
   \   00000164   0xD42F             BMI.N    ??HAL_SPI_Transmit_20
   \   00000166   0xF116 0x0F01      CMN      R6,#+1
   \   0000016A   0xD0F8             BEQ.N    ??HAL_SPI_Transmit_19
   \   0000016C   0xB12E             CBZ.N    R6,??HAL_SPI_Transmit_21
   \   0000016E   0x.... 0x....      BL       HAL_GetTick
   \   00000172   0xEBA0 0x0008      SUB      R0,R0,R8
   \   00000176   0x42B0             CMP      R0,R6
   \   00000178   0xD3F1             BCC.N    ??HAL_SPI_Transmit_19
   \                     ??HAL_SPI_Transmit_21: (+1)
   \   0000017A   0x6828             LDR      R0,[R5, #+0]
   \   0000017C   0x6841             LDR      R1,[R0, #+4]
   \   0000017E   0xF021 0x01E0      BIC      R1,R1,#0xE0
   \   00000182   0x6041             STR      R1,[R0, #+4]
   \   00000184   0x6869             LDR      R1,[R5, #+4]
   \   00000186   0xF5B1 0x7F82      CMP      R1,#+260
   \   0000018A   0xD10A             BNE.N    ??HAL_SPI_Transmit_22
   \   0000018C   0x68A9             LDR      R1,[R5, #+8]
   \   0000018E   0xF5B1 0x4F00      CMP      R1,#+32768
   \   00000192   0xBF18             IT       NE 
   \   00000194   0xF5B1 0x6F80      CMPNE    R1,#+1024
   \   00000198   0xD103             BNE.N    ??HAL_SPI_Transmit_22
   \   0000019A   0x6801             LDR      R1,[R0, #+0]
   \   0000019C   0xF021 0x0140      BIC      R1,R1,#0x40
   \   000001A0   0x6001             STR      R1,[R0, #+0]
   \                     ??HAL_SPI_Transmit_22: (+1)
   \   000001A2   0x6AA9             LDR      R1,[R5, #+40]
   \   000001A4   0xF5B1 0x5F00      CMP      R1,#+8192
   \   000001A8   0xD108             BNE.N    ??HAL_SPI_Transmit_23
   \   000001AA   0x6801             LDR      R1,[R0, #+0]
   \   000001AC   0xF64D 0x72FF      MOVW     R2,#+57343
   \   000001B0   0x4011             ANDS     R1,R2,R1
   \   000001B2   0x6001             STR      R1,[R0, #+0]
   \   000001B4   0x6801             LDR      R1,[R0, #+0]
   \   000001B6   0xF441 0x5100      ORR      R1,R1,#0x2000
   \   000001BA   0x6001             STR      R1,[R0, #+0]
   \                     ??HAL_SPI_Transmit_23: (+1)
   \   000001BC   0x2001             MOVS     R0,#+1
   \   000001BE   0x7060             STRB     R0,[R4, #+1]
   \   000001C0   0x2000             MOVS     R0,#+0
   \   000001C2   0x7020             STRB     R0,[R4, #+0]
   \   000001C4   0xE016             B.N      ??HAL_SPI_Transmit_18
    500                  {
    501                    return HAL_TIMEOUT;
    502                  }
    503                  *((__IO uint8_t*)&hspi->Instance->DR) = (*hspi->pTxBuffPtr++);
   \                     ??HAL_SPI_Transmit_20: (+1)
   \   000001C6   0x6839             LDR      R1,[R7, #+0]
   \   000001C8   0x1C49             ADDS     R1,R1,#+1
   \   000001CA   0x6039             STR      R1,[R7, #+0]
   \   000001CC   0x1E49             SUBS     R1,R1,#+1
   \   000001CE   0x7809             LDRB     R1,[R1, #+0]
   \   000001D0   0x7301             STRB     R1,[R0, #+12]
    504                  hspi->TxXferCount--;    
   \   000001D2   0x88F8             LDRH     R0,[R7, #+6]
   \   000001D4   0x1E40             SUBS     R0,R0,#+1
   \   000001D6   0xE782             B.N      ??HAL_SPI_Transmit_13
    505                }
    506              }
    507            }
    508          
    509            /* Enable CRC Transmission */
    510            if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   \                     ??HAL_SPI_Transmit_9: (+1)
   \   000001D8   0x6AA8             LDR      R0,[R5, #+40]
   \   000001DA   0xF5B0 0x5F00      CMP      R0,#+8192
   \   000001DE   0xD104             BNE.N    ??HAL_SPI_Transmit_24
    511            {
    512               hspi->Instance->CR1|= SPI_CR1_CRCNEXT;
   \   000001E0   0x6828             LDR      R0,[R5, #+0]
   \   000001E2   0x6801             LDR      R1,[R0, #+0]
   \   000001E4   0xF441 0x5180      ORR      R1,R1,#0x1000
   \   000001E8   0x6001             STR      R1,[R0, #+0]
    513            }
    514          
    515            /* Check the end of the transaction */
    516            if(SPI_EndRxTxTransaction(hspi,Timeout) != HAL_OK)
   \                     ??HAL_SPI_Transmit_24: (+1)
   \   000001EA   0x4631             MOV      R1,R6
   \   000001EC   0x4628             MOV      R0,R5
   \   000001EE   0x.... 0x....      BL       SPI_EndRxTxTransaction
   \   000001F2   0xB100             CBZ.N    R0,??HAL_SPI_Transmit_25
    517            {
    518              return HAL_TIMEOUT;
   \                     ??HAL_SPI_Transmit_18: (+1)
   \   000001F4   0x....             B.N      ?Subroutine0
    519            }
    520            
    521            /* Clear OVERUN flag in 2 Lines communication mode because received is not read */
    522            if(hspi->Init.Direction == SPI_DIRECTION_2LINES)
   \                     ??HAL_SPI_Transmit_25: (+1)
   \   000001F6   0x68A8             LDR      R0,[R5, #+8]
   \   000001F8   0xB930             CBNZ.N   R0,??HAL_SPI_Transmit_26
    523            {
    524              __HAL_SPI_CLEAR_OVRFLAG(hspi);
   \   000001FA   0x9000             STR      R0,[SP, #+0]
   \   000001FC   0x6828             LDR      R0,[R5, #+0]
   \   000001FE   0x68C1             LDR      R1,[R0, #+12]
   \   00000200   0x9100             STR      R1,[SP, #+0]
   \   00000202   0x6880             LDR      R0,[R0, #+8]
   \   00000204   0x9000             STR      R0,[SP, #+0]
   \   00000206   0x9800             LDR      R0,[SP, #+0]
    525            }
    526              
    527            hspi->State = HAL_SPI_STATE_READY; 
   \                     ??HAL_SPI_Transmit_26: (+1)
   \   00000208   0x2001             MOVS     R0,#+1
   \   0000020A   0x7060             STRB     R0,[R4, #+1]
    528          
    529            /* Process Unlocked */
    530            __HAL_UNLOCK(hspi);
   \   0000020C   0x2000             MOVS     R0,#+0
   \   0000020E   0x7020             STRB     R0,[R4, #+0]
    531            
    532            if(hspi->ErrorCode != HAL_SPI_ERROR_NONE)
   \   00000210   0x6860             LDR      R0,[R4, #+4]
   \   00000212   0x1E40             SUBS     R0,R0,#+1
   \   00000214   0x4180             SBCS     R0,R0,R0
   \   00000216   0x43C0             MVNS     R0,R0
   \   00000218   0x0FC0             LSRS     R0,R0,#+31
    533            {   
    534              return HAL_ERROR;
    535            }
    536            else
    537            {
    538              return HAL_OK;
   \   0000021A   0xE8BD 0x81F6      POP      {R1,R2,R4-R8,PC}  ;; return
    539            }
    540          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine2: (+1)
   \   00000000   0x2002             MOVS     R0,#+2
   \   00000002   0xE8BD 0x81F6      POP      {R1,R2,R4-R8,PC}

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \   00000000   0x2001             MOVS     R0,#+1
   \   00000002   0xE8BD 0x81F6      POP      {R1,R2,R4-R8,PC}

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \   00000000   0x2003             MOVS     R0,#+3
   \   00000002   0xE8BD 0x81F6      POP      {R1,R2,R4-R8,PC}
    541          
    542          /**
    543            * @brief  Receive an amount of data in blocking mode
    544            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
    545            *               the configuration information for SPI module.
    546            * @param  pData: pointer to data buffer
    547            * @param  Size: amount of data to be received
    548            * @param  Timeout: Timeout duration
    549            * @retval HAL status
    550            */

   \                                 In section .text, align 2, keep-with-next
    551          HAL_StatusTypeDef HAL_SPI_Receive(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size, uint32_t Timeout)
    552          {
   \                     HAL_SPI_Receive: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4604             MOV      R4,R0
    553            __IO uint16_t tmpreg;
    554            
    555            if(hspi->State != HAL_SPI_STATE_READY)
   \   00000006   0xF104 0x0644      ADD      R6,R4,#+68
   \   0000000A   0xB082             SUB      SP,SP,#+8
   \   0000000C   0x461D             MOV      R5,R3
   \   0000000E   0x7E70             LDRB     R0,[R6, #+25]
   \   00000010   0x2801             CMP      R0,#+1
   \   00000012   0xD116             BNE.N    ??HAL_SPI_Receive_0
    556            {
    557              return HAL_BUSY;
    558            }
    559            
    560            if((pData == NULL ) || (Size == 0))
   \   00000014   0x2900             CMP      R1,#+0
   \   00000016   0xBF18             IT       NE 
   \   00000018   0x2A00             CMPNE    R2,#+0
   \   0000001A   0xF000 0x8118      BEQ.W    ??HAL_SPI_Receive_1
    561            {
    562              return HAL_ERROR;
    563            }
    564          
    565            if((hspi->Init.Mode == SPI_MODE_MASTER) && (hspi->Init.Direction == SPI_DIRECTION_2LINES))
   \   0000001E   0x6860             LDR      R0,[R4, #+4]
   \   00000020   0xF5B0 0x7F82      CMP      R0,#+260
   \   00000024   0xBF04             ITT      EQ 
   \   00000026   0x68A0             LDREQ    R0,[R4, #+8]
   \   00000028   0x2800             CMPEQ    R0,#+0
   \   0000002A   0xD107             BNE.N    ??HAL_SPI_Receive_2
    566            {
    567              /* the receive process is not supported in 2Lines direction master mode */
    568              /* in this case we call the transmitReceive process                     */
    569              return HAL_SPI_TransmitReceive(hspi,pData,pData,Size,Timeout);
   \   0000002C   0x4613             MOV      R3,R2
   \   0000002E   0x9500             STR      R5,[SP, #+0]
   \   00000030   0x460A             MOV      R2,R1
   \   00000032   0x4620             MOV      R0,R4
   \   00000034   0x.... 0x....      BL       HAL_SPI_TransmitReceive
    570            }
    571            
    572            /* Process Locked */
    573            __HAL_LOCK(hspi);
    574              
    575            hspi->State       = HAL_SPI_STATE_BUSY_RX;
    576            hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
    577            hspi->pRxBuffPtr  = pData;
    578            hspi->RxXferSize  = Size;
    579            hspi->RxXferCount = Size;
    580            hspi->pTxBuffPtr  = (uint8_t *)NULL;
    581            hspi->TxXferSize  = 0;
    582            hspi->TxXferCount = 0;
    583          
    584            /* Reset CRC Calculation */
    585            if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
    586            {
    587              SPI_RESET_CRC(hspi);
    588              /* this is done to handle the CRCNEXT before the latest data */
    589              hspi->RxXferCount--;
    590            }
    591          
    592            /* Set the Rx Fido threshold */
    593            if(hspi->Init.DataSize > SPI_DATASIZE_8BIT)
    594            {
    595              /* set fiforxthreshold according the reception data length: 16bit */
    596              CLEAR_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
    597            }
    598            else
    599            {
    600              /* set fiforxthreshold according the reception data length: 8bit */
    601              SET_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
    602            }
    603          
    604            /* Configure communication direction 1Line and enabled SPI if needed */
    605            if(hspi->Init.Direction == SPI_DIRECTION_1LINE)
    606            {
    607              SPI_1LINE_RX(hspi);
    608            }
    609          
    610            /* Check if the SPI is already enabled */
    611            if((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
    612            {
    613              /* Enable SPI peripheral */
    614              __HAL_SPI_ENABLE(hspi);
    615            }
    616          
    617            /* Receive data in 8 Bit mode */
    618            if(hspi->Init.DataSize <= SPI_DATASIZE_8BIT)
    619            {
    620              while(hspi->RxXferCount > 1)
    621              {
    622                /* Wait until the RXNE flag */
    623                if(SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_RXNE, SPI_FLAG_RXNE, Timeout) != HAL_OK)
    624                {
    625                  return HAL_TIMEOUT;
    626                }
    627                (*hspi->pRxBuffPtr++)= *(__IO uint8_t *)&hspi->Instance->DR;
    628                hspi->RxXferCount--;  
    629              }
    630            }
    631            else /* Receive data in 16 Bit mode */
    632            {   
    633              while(hspi->RxXferCount > 1 )
    634              {
    635                /* Wait until RXNE flag is reset to read data */
    636                if(SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_RXNE, SPI_FLAG_RXNE, Timeout) != HAL_OK)
    637                {
    638                  return HAL_TIMEOUT;
    639                }
    640                *((uint16_t*)hspi->pRxBuffPtr) = hspi->Instance->DR;
    641                hspi->pRxBuffPtr += sizeof(uint16_t);
    642                hspi->RxXferCount--;
    643              } 
    644            }
    645            
    646            /* Enable CRC Transmission */
    647            if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE) 
    648            {
    649              hspi->Instance->CR1 |= SPI_CR1_CRCNEXT;
    650            }  
    651          
    652            /* Wait until RXNE flag is set */
    653            if(SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_RXNE, SPI_FLAG_RXNE, Timeout) != HAL_OK)
    654            {
    655              return HAL_TIMEOUT;
    656            }
    657            
    658            /* Receive last data in 16 Bit mode */
    659            if(hspi->Init.DataSize > SPI_DATASIZE_8BIT)
    660            {        
    661              *((uint16_t*)hspi->pRxBuffPtr) = hspi->Instance->DR;
    662              hspi->pRxBuffPtr += sizeof(uint16_t);
    663            }
    664            /* Receive last data in 8 Bit mode */
    665            else 
    666            {
    667              (*hspi->pRxBuffPtr++) = *(__IO uint8_t *)&hspi->Instance->DR;
    668            }
    669            hspi->RxXferCount--;
    670            
    671            /* Read CRC from DR to close CRC calculation process */
    672            if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
    673            {
    674              /* Wait until TXE flag */
    675              if(SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_RXNE, SPI_FLAG_RXNE, Timeout) != HAL_OK) 
    676              {
    677                /* Error on the CRC reception */
    678                hspi->ErrorCode|= HAL_SPI_ERROR_CRC;
    679              }
    680              if(hspi->Init.DataSize > SPI_DATASIZE_8BIT)
    681              {        
    682                tmpreg = hspi->Instance->DR;
    683                UNUSED(tmpreg); /* To avoid GCC warning */
    684              }
    685              else
    686              {
    687                tmpreg = *(__IO uint8_t *)&hspi->Instance->DR;
    688                UNUSED(tmpreg); /* To avoid GCC warning */
    689          
    690                if((hspi->Init.DataSize == SPI_DATASIZE_8BIT) && (hspi->Init.CRCLength == SPI_CRC_LENGTH_16BIT))
    691                {
    692                  if(SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_RXNE, SPI_FLAG_RXNE, Timeout) != HAL_OK)
    693                  {
    694                    /* Error on the CRC reception */
    695                    hspi->ErrorCode|= HAL_SPI_ERROR_FLAG;
    696                  }
    697                  tmpreg = *(__IO uint8_t *)&hspi->Instance->DR;
    698                  UNUSED(tmpreg); /* To avoid GCC warning */
    699                }
    700              }
    701            }
    702            
    703            /* Check the end of the transaction */
    704            if(SPI_EndRxTransaction(hspi,Timeout) != HAL_OK)
    705            {
    706              return HAL_TIMEOUT;
    707            }
    708          
    709            hspi->State = HAL_SPI_STATE_READY; 
    710              
    711            /* Check if CRC error occurred */
    712            if(__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_CRCERR) != RESET)
    713            {
    714              hspi->ErrorCode|= HAL_SPI_ERROR_CRC;
    715              __HAL_SPI_CLEAR_CRCERRFLAG(hspi);
    716                            
    717              /* Process Unlocked */
    718              __HAL_UNLOCK(hspi);
    719              return HAL_ERROR;
    720            }
    721              
    722            /* Process Unlocked */
    723            __HAL_UNLOCK(hspi);
    724            
    725            if(hspi->ErrorCode != HAL_SPI_ERROR_NONE)
    726            {   
    727              return HAL_ERROR;
    728            }
    729            else
    730            {
    731              return HAL_OK;
   \   00000038   0xE8BD 0x81F6      POP      {R1,R2,R4-R8,PC}
   \                     ??HAL_SPI_Receive_2: (+1)
   \   0000003C   0x7E30             LDRB     R0,[R6, #+24]
   \   0000003E   0x2801             CMP      R0,#+1
   \   00000040   0xD100             BNE.N    ??HAL_SPI_Receive_3
   \                     ??HAL_SPI_Receive_0: (+1)
   \   00000042   0x....             B.N      ?Subroutine2
   \                     ??HAL_SPI_Receive_3: (+1)
   \   00000044   0x2001             MOVS     R0,#+1
   \   00000046   0x7630             STRB     R0,[R6, #+24]
   \   00000048   0x2004             MOVS     R0,#+4
   \   0000004A   0x7670             STRB     R0,[R6, #+25]
   \   0000004C   0x2000             MOVS     R0,#+0
   \   0000004E   0x61F0             STR      R0,[R6, #+28]
   \   00000050   0x6421             STR      R1,[R4, #+64]
   \   00000052   0x8032             STRH     R2,[R6, #+0]
   \   00000054   0x8072             STRH     R2,[R6, #+2]
   \   00000056   0x6AA1             LDR      R1,[R4, #+40]
   \   00000058   0x63A0             STR      R0,[R4, #+56]
   \   0000005A   0xF5B1 0x5F00      CMP      R1,#+8192
   \   0000005E   0x87A0             STRH     R0,[R4, #+60]
   \   00000060   0x87E0             STRH     R0,[R4, #+62]
   \   00000062   0x6820             LDR      R0,[R4, #+0]
   \   00000064   0xD10B             BNE.N    ??HAL_SPI_Receive_4
   \   00000066   0x6801             LDR      R1,[R0, #+0]
   \   00000068   0xF64D 0x72FF      MOVW     R2,#+57343
   \   0000006C   0x4011             ANDS     R1,R2,R1
   \   0000006E   0x6001             STR      R1,[R0, #+0]
   \   00000070   0x6801             LDR      R1,[R0, #+0]
   \   00000072   0xF441 0x5100      ORR      R1,R1,#0x2000
   \   00000076   0x6001             STR      R1,[R0, #+0]
   \   00000078   0x8871             LDRH     R1,[R6, #+2]
   \   0000007A   0x1E49             SUBS     R1,R1,#+1
   \   0000007C   0x8071             STRH     R1,[R6, #+2]
   \                     ??HAL_SPI_Receive_4: (+1)
   \   0000007E   0x68E1             LDR      R1,[R4, #+12]
   \   00000080   0xF240 0x7801      MOVW     R8,#+1793
   \   00000084   0x4541             CMP      R1,R8
   \   00000086   0x6841             LDR      R1,[R0, #+4]
   \   00000088   0xBF2C             ITE      CS 
   \   0000008A   0xF421 0x5180      BICCS    R1,R1,#0x1000
   \   0000008E   0xF441 0x5180      ORRCC    R1,R1,#0x1000
   \   00000092   0x6041             STR      R1,[R0, #+4]
   \   00000094   0x68A1             LDR      R1,[R4, #+8]
   \   00000096   0xF5B1 0x4F00      CMP      R1,#+32768
   \   0000009A   0xD103             BNE.N    ??HAL_SPI_Receive_5
   \   0000009C   0x6801             LDR      R1,[R0, #+0]
   \   0000009E   0xF421 0x4180      BIC      R1,R1,#0x4000
   \   000000A2   0x6001             STR      R1,[R0, #+0]
   \                     ??HAL_SPI_Receive_5: (+1)
   \   000000A4   0x6801             LDR      R1,[R0, #+0]
   \   000000A6   0x0649             LSLS     R1,R1,#+25
   \   000000A8   0xD403             BMI.N    ??HAL_SPI_Receive_6
   \   000000AA   0x6801             LDR      R1,[R0, #+0]
   \   000000AC   0xF041 0x0140      ORR      R1,R1,#0x40
   \   000000B0   0x6001             STR      R1,[R0, #+0]
   \                     ??HAL_SPI_Receive_6: (+1)
   \   000000B2   0x68E0             LDR      R0,[R4, #+12]
   \   000000B4   0x4540             CMP      R0,R8
   \   000000B6   0xD224             BCS.N    ??HAL_SPI_Receive_7
   \   000000B8   0xE007             B.N      ??HAL_SPI_Receive_8
   \                     ??HAL_SPI_Receive_9: (+1)
   \   000000BA   0x6C20             LDR      R0,[R4, #+64]
   \   000000BC   0x1C42             ADDS     R2,R0,#+1
   \   000000BE   0x6422             STR      R2,[R4, #+64]
   \   000000C0   0x7B09             LDRB     R1,[R1, #+12]
   \   000000C2   0x7001             STRB     R1,[R0, #+0]
   \   000000C4   0x8870             LDRH     R0,[R6, #+2]
   \   000000C6   0x1E40             SUBS     R0,R0,#+1
   \   000000C8   0x8070             STRH     R0,[R6, #+2]
   \                     ??HAL_SPI_Receive_8: (+1)
   \   000000CA   0x8870             LDRH     R0,[R6, #+2]
   \   000000CC   0x2802             CMP      R0,#+2
   \   000000CE   0xDB51             BLT.N    ??HAL_SPI_Receive_10
   \   000000D0   0x.... 0x....      BL       HAL_GetTick
   \   000000D4   0x4607             MOV      R7,R0
   \                     ??HAL_SPI_Receive_11: (+1)
   \   000000D6   0x6821             LDR      R1,[R4, #+0]
   \   000000D8   0x6888             LDR      R0,[R1, #+8]
   \   000000DA   0x07C0             LSLS     R0,R0,#+31
   \   000000DC   0xD4ED             BMI.N    ??HAL_SPI_Receive_9
   \   000000DE   0xF115 0x0F01      CMN      R5,#+1
   \   000000E2   0xD0F8             BEQ.N    ??HAL_SPI_Receive_11
   \   000000E4   0xB305             CBZ.N    R5,??HAL_SPI_Receive_12
   \   000000E6   0x.... 0x....      BL       HAL_GetTick
   \   000000EA   0x1BC0             SUBS     R0,R0,R7
   \   000000EC   0x42A8             CMP      R0,R5
   \   000000EE   0xD3F2             BCC.N    ??HAL_SPI_Receive_11
   \   000000F0   0xE01A             B.N      ??HAL_SPI_Receive_12
   \                     ??HAL_SPI_Receive_13: (+1)
   \   000000F2   0x6C20             LDR      R0,[R4, #+64]
   \   000000F4   0x68C9             LDR      R1,[R1, #+12]
   \   000000F6   0xF820 0x1B02      STRH     R1,[R0], #+2
   \   000000FA   0x6420             STR      R0,[R4, #+64]
   \   000000FC   0x8870             LDRH     R0,[R6, #+2]
   \   000000FE   0x1E40             SUBS     R0,R0,#+1
   \   00000100   0x8070             STRH     R0,[R6, #+2]
   \                     ??HAL_SPI_Receive_7: (+1)
   \   00000102   0x8870             LDRH     R0,[R6, #+2]
   \   00000104   0x2802             CMP      R0,#+2
   \   00000106   0xDB35             BLT.N    ??HAL_SPI_Receive_10
   \   00000108   0x.... 0x....      BL       HAL_GetTick
   \   0000010C   0x4607             MOV      R7,R0
   \                     ??HAL_SPI_Receive_14: (+1)
   \   0000010E   0x6821             LDR      R1,[R4, #+0]
   \   00000110   0x6888             LDR      R0,[R1, #+8]
   \   00000112   0x07C0             LSLS     R0,R0,#+31
   \   00000114   0xD4ED             BMI.N    ??HAL_SPI_Receive_13
   \   00000116   0xF115 0x0F01      CMN      R5,#+1
   \   0000011A   0xD0F8             BEQ.N    ??HAL_SPI_Receive_14
   \   0000011C   0xB125             CBZ.N    R5,??HAL_SPI_Receive_12
   \   0000011E   0x.... 0x....      BL       HAL_GetTick
   \   00000122   0x1BC0             SUBS     R0,R0,R7
   \   00000124   0x42A8             CMP      R0,R5
   \   00000126   0xD3F2             BCC.N    ??HAL_SPI_Receive_14
   \                     ??HAL_SPI_Receive_12: (+1)
   \   00000128   0x6820             LDR      R0,[R4, #+0]
   \   0000012A   0x6841             LDR      R1,[R0, #+4]
   \   0000012C   0xF021 0x01E0      BIC      R1,R1,#0xE0
   \   00000130   0x6041             STR      R1,[R0, #+4]
   \   00000132   0x6861             LDR      R1,[R4, #+4]
   \   00000134   0xF5B1 0x7F82      CMP      R1,#+260
   \   00000138   0xD10A             BNE.N    ??HAL_SPI_Receive_15
   \   0000013A   0x68A1             LDR      R1,[R4, #+8]
   \   0000013C   0xF5B1 0x4F00      CMP      R1,#+32768
   \   00000140   0xBF18             IT       NE 
   \   00000142   0xF5B1 0x6F80      CMPNE    R1,#+1024
   \   00000146   0xD103             BNE.N    ??HAL_SPI_Receive_15
   \   00000148   0x6801             LDR      R1,[R0, #+0]
   \   0000014A   0xF021 0x0140      BIC      R1,R1,#0x40
   \   0000014E   0x6001             STR      R1,[R0, #+0]
   \                     ??HAL_SPI_Receive_15: (+1)
   \   00000150   0x6AA1             LDR      R1,[R4, #+40]
   \   00000152   0xF5B1 0x5F00      CMP      R1,#+8192
   \   00000156   0xD108             BNE.N    ??HAL_SPI_Receive_16
   \   00000158   0x6801             LDR      R1,[R0, #+0]
   \   0000015A   0xF64D 0x72FF      MOVW     R2,#+57343
   \   0000015E   0x4011             ANDS     R1,R2,R1
   \   00000160   0x6001             STR      R1,[R0, #+0]
   \   00000162   0x6801             LDR      R1,[R0, #+0]
   \   00000164   0xF441 0x5100      ORR      R1,R1,#0x2000
   \   00000168   0x6001             STR      R1,[R0, #+0]
   \                     ??HAL_SPI_Receive_16: (+1)
   \   0000016A   0x2001             MOVS     R0,#+1
   \   0000016C   0x7670             STRB     R0,[R6, #+25]
   \   0000016E   0x2000             MOVS     R0,#+0
   \   00000170   0x7630             STRB     R0,[R6, #+24]
   \   00000172   0xE055             B.N      ??HAL_SPI_Receive_17
   \                     ??HAL_SPI_Receive_10: (+1)
   \   00000174   0x6AA0             LDR      R0,[R4, #+40]
   \   00000176   0xF5B0 0x5F00      CMP      R0,#+8192
   \   0000017A   0xD104             BNE.N    ??HAL_SPI_Receive_18
   \   0000017C   0x6820             LDR      R0,[R4, #+0]
   \   0000017E   0x6801             LDR      R1,[R0, #+0]
   \   00000180   0xF441 0x5180      ORR      R1,R1,#0x1000
   \   00000184   0x6001             STR      R1,[R0, #+0]
   \                     ??HAL_SPI_Receive_18: (+1)
   \   00000186   0x462B             MOV      R3,R5
   \   00000188   0x2201             MOVS     R2,#+1
   \   0000018A   0x2101             MOVS     R1,#+1
   \   0000018C   0x4620             MOV      R0,R4
   \   0000018E   0x.... 0x....      BL       SPI_WaitFlagStateUntilTimeout
   \   00000192   0x2800             CMP      R0,#+0
   \   00000194   0xD144             BNE.N    ??HAL_SPI_Receive_17
   \   00000196   0x68E2             LDR      R2,[R4, #+12]
   \   00000198   0x6821             LDR      R1,[R4, #+0]
   \   0000019A   0x6C20             LDR      R0,[R4, #+64]
   \   0000019C   0x4542             CMP      R2,R8
   \   0000019E   0xBF27             ITTEE    CS 
   \   000001A0   0x68C9             LDRCS    R1,[R1, #+12]
   \   000001A2   0xF820 0x1B02      STRHCS   R1,[R0], #+2
   \   000001A6   0x7B09             LDRBCC   R1,[R1, #+12]
   \   000001A8   0xF800 0x1B01      STRBCC   R1,[R0], #+1
   \   000001AC   0x6420             STR      R0,[R4, #+64]
   \   000001AE   0x8870             LDRH     R0,[R6, #+2]
   \   000001B0   0x1E40             SUBS     R0,R0,#+1
   \   000001B2   0x8070             STRH     R0,[R6, #+2]
   \   000001B4   0x6AA0             LDR      R0,[R4, #+40]
   \   000001B6   0xF5B0 0x5F00      CMP      R0,#+8192
   \   000001BA   0xD12C             BNE.N    ??HAL_SPI_Receive_19
   \   000001BC   0x462B             MOV      R3,R5
   \   000001BE   0x2201             MOVS     R2,#+1
   \   000001C0   0x2101             MOVS     R1,#+1
   \   000001C2   0x4620             MOV      R0,R4
   \   000001C4   0x.... 0x....      BL       SPI_WaitFlagStateUntilTimeout
   \   000001C8   0xB118             CBZ.N    R0,??HAL_SPI_Receive_20
   \   000001CA   0x69F0             LDR      R0,[R6, #+28]
   \   000001CC   0xF040 0x0002      ORR      R0,R0,#0x2
   \   000001D0   0x61F0             STR      R0,[R6, #+28]
   \                     ??HAL_SPI_Receive_20: (+1)
   \   000001D2   0x68E0             LDR      R0,[R4, #+12]
   \   000001D4   0x6821             LDR      R1,[R4, #+0]
   \   000001D6   0x4540             CMP      R0,R8
   \   000001D8   0xBF28             IT       CS 
   \   000001DA   0x68C8             LDRCS    R0,[R1, #+12]
   \   000001DC   0xD217             BCS.N    ??HAL_SPI_Receive_21
   \   000001DE   0x7B09             LDRB     R1,[R1, #+12]
   \   000001E0   0xF5B0 0x6FE0      CMP      R0,#+1792
   \   000001E4   0xF8AD 0x1000      STRH     R1,[SP, #+0]
   \   000001E8   0xF8BD 0x1000      LDRH     R1,[SP, #+0]
   \   000001EC   0xBF04             ITT      EQ 
   \   000001EE   0x6B20             LDREQ    R0,[R4, #+48]
   \   000001F0   0x2802             CMPEQ    R0,#+2
   \   000001F2   0xD110             BNE.N    ??HAL_SPI_Receive_19
   \   000001F4   0x462B             MOV      R3,R5
   \   000001F6   0x2201             MOVS     R2,#+1
   \   000001F8   0x2101             MOVS     R1,#+1
   \   000001FA   0x4620             MOV      R0,R4
   \   000001FC   0x.... 0x....      BL       SPI_WaitFlagStateUntilTimeout
   \   00000200   0xB118             CBZ.N    R0,??HAL_SPI_Receive_22
   \   00000202   0x69F0             LDR      R0,[R6, #+28]
   \   00000204   0xF040 0x0020      ORR      R0,R0,#0x20
   \   00000208   0x61F0             STR      R0,[R6, #+28]
   \                     ??HAL_SPI_Receive_22: (+1)
   \   0000020A   0x6820             LDR      R0,[R4, #+0]
   \   0000020C   0x7B00             LDRB     R0,[R0, #+12]
   \                     ??HAL_SPI_Receive_21: (+1)
   \   0000020E   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   \   00000212   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \                     ??HAL_SPI_Receive_19: (+1)
   \   00000216   0x4629             MOV      R1,R5
   \   00000218   0x4620             MOV      R0,R4
   \   0000021A   0x.... 0x....      BL       SPI_EndRxTransaction
   \   0000021E   0xB100             CBZ.N    R0,??HAL_SPI_Receive_23
   \                     ??HAL_SPI_Receive_17: (+1)
   \   00000220   0x....             B.N      ?Subroutine0
   \                     ??HAL_SPI_Receive_23: (+1)
   \   00000222   0x2001             MOVS     R0,#+1
   \   00000224   0x7670             STRB     R0,[R6, #+25]
   \   00000226   0x6821             LDR      R1,[R4, #+0]
   \   00000228   0x69F0             LDR      R0,[R6, #+28]
   \   0000022A   0x688A             LDR      R2,[R1, #+8]
   \   0000022C   0x06D2             LSLS     R2,R2,#+27
   \   0000022E   0xD508             BPL.N    ??HAL_SPI_Receive_24
   \   00000230   0xF040 0x0002      ORR      R0,R0,#0x2
   \   00000234   0x61F0             STR      R0,[R6, #+28]
   \   00000236   0xF64F 0x70EF      MOVW     R0,#+65519
   \   0000023A   0x6088             STR      R0,[R1, #+8]
   \   0000023C   0x2000             MOVS     R0,#+0
   \   0000023E   0x7630             STRB     R0,[R6, #+24]
   \   00000240   0x....             B.N      ?Subroutine1
   \                     ??HAL_SPI_Receive_24: (+1)
   \   00000242   0x2100             MOVS     R1,#+0
   \   00000244   0x1E40             SUBS     R0,R0,#+1
   \   00000246   0x4180             SBCS     R0,R0,R0
   \   00000248   0x43C0             MVNS     R0,R0
   \   0000024A   0x7631             STRB     R1,[R6, #+24]
   \   0000024C   0x0FC0             LSRS     R0,R0,#+31
   \                     ??HAL_SPI_Receive_1: (+1)
   \   0000024E   0xE8BD 0x81F6      POP      {R1,R2,R4-R8,PC}  ;; return
    732            }
    733          }
    734          
    735          /**
    736            * @brief  Transmit and Receive an amount of data in blocking mode
    737            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
    738            *               the configuration information for SPI module.
    739            * @param  pTxData: pointer to transmission data buffer
    740            * @param  pRxData: pointer to reception data buffer
    741            * @param  Size: amount of data to be sent and received
    742            * @param  Timeout: Timeout duration
    743            * @retval HAL status
    744            */

   \                                 In section .text, align 2, keep-with-next
    745          HAL_StatusTypeDef HAL_SPI_TransmitReceive(SPI_HandleTypeDef *hspi, uint8_t *pTxData, uint8_t *pRxData, uint16_t Size, uint32_t Timeout)
    746          {
   \                     HAL_SPI_TransmitReceive: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0xB082             SUB      SP,SP,#+8
    747            __IO uint16_t tmpreg = 0;
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x460E             MOV      R6,R1
   \   0000000C   0x4691             MOV      R9,R2
   \   0000000E   0x469A             MOV      R10,R3
   \   00000010   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   \   00000014   0xF104 0x055C      ADD      R5,R4,#+92
    748            uint32_t tickstart = HAL_GetTick();
   \   00000018   0x.... 0x....      BL       HAL_GetTick
   \   0000001C   0x4680             MOV      R8,R0
    749            
    750            assert_param(IS_SPI_DIRECTION_2LINES(hspi->Init.Direction));
    751            
    752            if(hspi->State != HAL_SPI_STATE_READY) 
   \   0000001E   0x7868             LDRB     R0,[R5, #+1]
   \   00000020   0x2801             CMP      R0,#+1
   \   00000022   0xD10A             BNE.N    ??HAL_SPI_TransmitReceive_0
    753            {
    754              return HAL_BUSY;
    755            }
    756            
    757            if((pTxData == NULL) || (pRxData == NULL) || (Size == 0))
   \   00000024   0x2E00             CMP      R6,#+0
   \   00000026   0xBF1C             ITT      NE 
   \   00000028   0xF1B9 0x0F00      CMPNE    R9,#+0
   \   0000002C   0xF1BA 0x0F00      CMPNE    R10,#+0
   \   00000030   0xF000 0x8122      BEQ.W    ??HAL_SPI_TransmitReceive_1
    758            {
    759              return HAL_ERROR;
    760            }
    761          
    762            
    763            /* Process Locked */
    764            __HAL_LOCK(hspi); 
   \   00000034   0x7828             LDRB     R0,[R5, #+0]
   \   00000036   0x2801             CMP      R0,#+1
   \   00000038   0xD102             BNE.N    ??HAL_SPI_TransmitReceive_2
   \                     ??HAL_SPI_TransmitReceive_0: (+1)
   \   0000003A   0x2002             MOVS     R0,#+2
    765            
    766            hspi->State       = HAL_SPI_STATE_BUSY_TX_RX;
    767            hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
    768            hspi->pRxBuffPtr  = pRxData;
    769            hspi->RxXferCount = Size;
    770            hspi->RxXferSize  = Size;
    771            hspi->pTxBuffPtr  = pTxData;
    772            hspi->TxXferCount = Size;
    773            hspi->TxXferSize  = Size;
    774          
    775            /* Reset CRC Calculation */
    776            if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
    777            {
    778              SPI_RESET_CRC(hspi);
    779            }
    780          
    781            /* Set the Rx Fido threshold */
    782            if((hspi->Init.DataSize > SPI_DATASIZE_8BIT) || (hspi->RxXferCount > 1))
    783            {
    784              /* set fiforxthreshold according the reception data length: 16bit */
    785              CLEAR_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
    786            }
    787            else
    788            {
    789              /* set fiforxthreshold according the reception data length: 8bit */
    790              SET_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
    791            }
    792          
    793            /* Check if the SPI is already enabled */
    794            if((hspi->Instance->CR1 &SPI_CR1_SPE) != SPI_CR1_SPE)
    795            {
    796              /* Enable SPI peripheral */
    797              __HAL_SPI_ENABLE(hspi);
    798            }
    799          
    800            /* Transmit and Receive data in 16 Bit mode */
    801            if(hspi->Init.DataSize > SPI_DATASIZE_8BIT)
    802            {
    803              while ((hspi->TxXferCount > 0 ) || (hspi->RxXferCount > 0))
    804              {
    805                /* Check TXE flag */
    806                if((hspi->TxXferCount > 0) && ((hspi->Instance->SR & SPI_FLAG_TXE) == SPI_FLAG_TXE))
    807                {
    808                  hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
    809                  hspi->pTxBuffPtr += sizeof(uint16_t);
    810                  hspi->TxXferCount--;
    811          
    812                  /* Enable CRC Transmission */
    813                  if((hspi->TxXferCount == 0) && (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE))
    814                  {
    815                    SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
    816                  } 
    817                }
    818          
    819                /* Check RXNE flag */
    820                if((hspi->RxXferCount > 0) && ((hspi->Instance->SR & SPI_FLAG_RXNE) == SPI_FLAG_RXNE))
    821                {
    822                  *((uint16_t *)hspi->pRxBuffPtr) = hspi->Instance->DR;
    823                  hspi->pRxBuffPtr += sizeof(uint16_t);
    824                  hspi->RxXferCount--;
    825                }
    826                if(Timeout != HAL_MAX_DELAY)
    827                {
    828                  if((Timeout == 0) || ((HAL_GetTick()-tickstart) > Timeout)) 
    829                  {
    830                    hspi->State = HAL_SPI_STATE_READY;
    831                    __HAL_UNLOCK(hspi);
    832                    return HAL_TIMEOUT;
    833                  }
    834                }
    835              }
    836            }
    837            /* Transmit and Receive data in 8 Bit mode */
    838            else
    839            {
    840              while((hspi->TxXferCount > 0) || (hspi->RxXferCount > 0))
    841              {
    842                /* check TXE flag */
    843                if((hspi->TxXferCount > 0) && ((hspi->Instance->SR & SPI_FLAG_TXE) == SPI_FLAG_TXE))
    844                {
    845                  if(hspi->TxXferCount > 1)
    846                  {
    847                    hspi->Instance->DR = *((uint16_t*)hspi->pTxBuffPtr);
    848                    hspi->pTxBuffPtr += sizeof(uint16_t);
    849                    hspi->TxXferCount -= 2;
    850                  }
    851                  else
    852                  {
    853                    *(__IO uint8_t *)&hspi->Instance->DR = (*hspi->pTxBuffPtr++);
    854                    hspi->TxXferCount--;
    855                  }
    856          
    857                  /* Enable CRC Transmission */
    858                  if((hspi->TxXferCount == 0) && (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE))
    859                  {
    860                    SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
    861                  }
    862                }
    863          
    864                /* Wait until RXNE flag is reset */
    865                if((hspi->RxXferCount > 0) && ((hspi->Instance->SR & SPI_FLAG_RXNE) == SPI_FLAG_RXNE))
    866                {
    867                  if(hspi->RxXferCount > 1)
    868                  {
    869                    *((uint16_t*)hspi->pRxBuffPtr) = hspi->Instance->DR;
    870                    hspi->pRxBuffPtr += sizeof(uint16_t);
    871                    hspi->RxXferCount -= 2;
    872                    if(hspi->RxXferCount <= 1)
    873                    {
    874                      /* set fiforxthreshold before to switch on 8 bit data size */
    875                      SET_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
    876                    }
    877                  }
    878                  else
    879                  {
    880                    (*hspi->pRxBuffPtr++) =  *(__IO uint8_t *)&hspi->Instance->DR;
    881                    hspi->RxXferCount--;
    882                  }
    883                }
    884                if(Timeout != HAL_MAX_DELAY)
    885                {
    886                  if((Timeout == 0) || ((HAL_GetTick()-tickstart) > Timeout))
    887                  {
    888                    hspi->State = HAL_SPI_STATE_READY;
    889                    __HAL_UNLOCK(hspi);
    890                    return HAL_TIMEOUT;
    891                  }
    892                }
    893              }
    894            }
    895          
    896            /* Read CRC from DR to close CRC calculation process */
    897            if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
    898            {
    899              /* Wait until TXE flag */
    900              if(SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_RXNE, SPI_FLAG_RXNE, Timeout) != HAL_OK)
    901              {
    902                /* Error on the CRC reception */
    903                hspi->ErrorCode|= HAL_SPI_ERROR_CRC;
    904              }
    905          
    906              if(hspi->Init.DataSize == SPI_DATASIZE_16BIT)
    907              {
    908                tmpreg = hspi->Instance->DR;
    909                UNUSED(tmpreg); /* To avoid GCC warning */
    910              }
    911              else
    912              {
    913                tmpreg = *(__IO uint8_t *)&hspi->Instance->DR;
    914                UNUSED(tmpreg); /* To avoid GCC warning */
    915          
    916                if(hspi->Init.CRCLength == SPI_CRC_LENGTH_16BIT)
    917                {
    918                  if(SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_RXNE, SPI_FLAG_RXNE, Timeout) != HAL_OK)
    919                  {
    920                    /* Error on the CRC reception */
    921                    hspi->ErrorCode|= HAL_SPI_ERROR_CRC;
    922                  }
    923                  tmpreg = *(__IO uint8_t *)&hspi->Instance->DR;
    924                  UNUSED(tmpreg); /* To avoid GCC warning */
    925                }
    926              }
    927            }
    928          
    929            /* Check the end of the transaction */
    930            if(SPI_EndRxTxTransaction(hspi,Timeout) != HAL_OK)
    931            {
    932              return HAL_TIMEOUT;
    933            }
    934          
    935            hspi->State = HAL_SPI_STATE_READY;
    936            
    937            /* Check if CRC error occurred */
    938            if(__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_CRCERR) != RESET)
    939            {
    940              hspi->ErrorCode|= HAL_SPI_ERROR_CRC;
    941              /* Clear CRC Flag */
    942              __HAL_SPI_CLEAR_CRCERRFLAG(hspi);
    943              
    944              /* Process Unlocked */
    945              __HAL_UNLOCK(hspi);
    946              
    947              return HAL_ERROR;
    948            }
    949            
    950            /* Process Unlocked */
    951            __HAL_UNLOCK(hspi);
    952            
    953            if(hspi->ErrorCode != HAL_SPI_ERROR_NONE)
    954            {   
    955              return HAL_ERROR;
    956            }
    957            else
    958            {
    959              return HAL_OK;
   \   0000003C   0xE8BD 0x87F6      POP      {R1,R2,R4-R10,PC}
   \                     ??HAL_SPI_TransmitReceive_2: (+1)
   \   00000040   0x2001             MOVS     R0,#+1
   \   00000042   0xF104 0x0738      ADD      R7,R4,#+56
   \   00000046   0x7028             STRB     R0,[R5, #+0]
   \   00000048   0x2005             MOVS     R0,#+5
   \   0000004A   0x7068             STRB     R0,[R5, #+1]
   \   0000004C   0x2000             MOVS     R0,#+0
   \   0000004E   0x6068             STR      R0,[R5, #+4]
   \   00000050   0xF8C7 0x9008      STR      R9,[R7, #+8]
   \   00000054   0xF8A7 0xA00E      STRH     R10,[R7, #+14]
   \   00000058   0xF8A7 0xA00C      STRH     R10,[R7, #+12]
   \   0000005C   0x603E             STR      R6,[R7, #+0]
   \   0000005E   0xF8A7 0xA006      STRH     R10,[R7, #+6]
   \   00000062   0xF8A7 0xA004      STRH     R10,[R7, #+4]
   \   00000066   0x6AA0             LDR      R0,[R4, #+40]
   \   00000068   0xF5B0 0x5F00      CMP      R0,#+8192
   \   0000006C   0xD109             BNE.N    ??HAL_SPI_TransmitReceive_3
   \   0000006E   0x6820             LDR      R0,[R4, #+0]
   \   00000070   0xF64D 0x72FF      MOVW     R2,#+57343
   \   00000074   0x6801             LDR      R1,[R0, #+0]
   \   00000076   0x4011             ANDS     R1,R2,R1
   \   00000078   0x6001             STR      R1,[R0, #+0]
   \   0000007A   0x6801             LDR      R1,[R0, #+0]
   \   0000007C   0xF441 0x5100      ORR      R1,R1,#0x2000
   \   00000080   0x6001             STR      R1,[R0, #+0]
   \                     ??HAL_SPI_TransmitReceive_3: (+1)
   \   00000082   0x68E0             LDR      R0,[R4, #+12]
   \   00000084   0xF240 0x7101      MOVW     R1,#+1793
   \   00000088   0x4288             CMP      R0,R1
   \   0000008A   0xD202             BCS.N    ??HAL_SPI_TransmitReceive_4
   \   0000008C   0x89F8             LDRH     R0,[R7, #+14]
   \   0000008E   0x2802             CMP      R0,#+2
   \   00000090   0xDB04             BLT.N    ??HAL_SPI_TransmitReceive_5
   \                     ??HAL_SPI_TransmitReceive_4: (+1)
   \   00000092   0x6820             LDR      R0,[R4, #+0]
   \   00000094   0x6842             LDR      R2,[R0, #+4]
   \   00000096   0xF422 0x5280      BIC      R2,R2,#0x1000
   \   0000009A   0xE003             B.N      ??HAL_SPI_TransmitReceive_6
   \                     ??HAL_SPI_TransmitReceive_5: (+1)
   \   0000009C   0x6820             LDR      R0,[R4, #+0]
   \   0000009E   0x6842             LDR      R2,[R0, #+4]
   \   000000A0   0xF442 0x5280      ORR      R2,R2,#0x1000
   \                     ??HAL_SPI_TransmitReceive_6: (+1)
   \   000000A4   0x6042             STR      R2,[R0, #+4]
   \   000000A6   0x6820             LDR      R0,[R4, #+0]
   \   000000A8   0x6802             LDR      R2,[R0, #+0]
   \   000000AA   0x0652             LSLS     R2,R2,#+25
   \   000000AC   0xD403             BMI.N    ??HAL_SPI_TransmitReceive_7
   \   000000AE   0x6802             LDR      R2,[R0, #+0]
   \   000000B0   0xF042 0x0240      ORR      R2,R2,#0x40
   \   000000B4   0x6002             STR      R2,[R0, #+0]
   \                     ??HAL_SPI_TransmitReceive_7: (+1)
   \   000000B6   0x68E0             LDR      R0,[R4, #+12]
   \   000000B8   0x9E0A             LDR      R6,[SP, #+40]
   \   000000BA   0x4288             CMP      R0,R1
   \   000000BC   0xD34B             BCC.N    ??HAL_SPI_TransmitReceive_8
   \                     ??HAL_SPI_TransmitReceive_9: (+1)
   \   000000BE   0x88F9             LDRH     R1,[R7, #+6]
   \   000000C0   0xB9C9             CBNZ.N   R1,??HAL_SPI_TransmitReceive_10
   \   000000C2   0x89F8             LDRH     R0,[R7, #+14]
   \   000000C4   0xBB68             CBNZ.N   R0,??HAL_SPI_TransmitReceive_11
   \                     ??HAL_SPI_TransmitReceive_12: (+1)
   \   000000C6   0x6AA0             LDR      R0,[R4, #+40]
   \   000000C8   0xF5B0 0x5F00      CMP      R0,#+8192
   \   000000CC   0xF040 0x80B0      BNE.W    ??HAL_SPI_TransmitReceive_13
   \   000000D0   0x4633             MOV      R3,R6
   \   000000D2   0x2201             MOVS     R2,#+1
   \   000000D4   0x2101             MOVS     R1,#+1
   \   000000D6   0x4620             MOV      R0,R4
   \   000000D8   0x.... 0x....      BL       SPI_WaitFlagStateUntilTimeout
   \   000000DC   0xB118             CBZ.N    R0,??HAL_SPI_TransmitReceive_14
   \   000000DE   0x6868             LDR      R0,[R5, #+4]
   \   000000E0   0xF040 0x0002      ORR      R0,R0,#0x2
   \   000000E4   0x6068             STR      R0,[R5, #+4]
   \                     ??HAL_SPI_TransmitReceive_14: (+1)
   \   000000E6   0x68E1             LDR      R1,[R4, #+12]
   \   000000E8   0x6820             LDR      R0,[R4, #+0]
   \   000000EA   0xF5B1 0x6F70      CMP      R1,#+3840
   \   000000EE   0xF040 0x8086      BNE.W    ??HAL_SPI_TransmitReceive_15
   \   000000F2   0x68C0             LDR      R0,[R0, #+12]
   \   000000F4   0xE098             B.N      ??HAL_SPI_TransmitReceive_16
   \                     ??HAL_SPI_TransmitReceive_10: (+1)
   \   000000F6   0x6820             LDR      R0,[R4, #+0]
   \   000000F8   0x6882             LDR      R2,[R0, #+8]
   \   000000FA   0x0792             LSLS     R2,R2,#+30
   \   000000FC   0xD511             BPL.N    ??HAL_SPI_TransmitReceive_11
   \   000000FE   0x683A             LDR      R2,[R7, #+0]
   \   00000100   0x1E49             SUBS     R1,R1,#+1
   \   00000102   0xF832 0x3B02      LDRH     R3,[R2], #+2
   \   00000106   0x60C3             STR      R3,[R0, #+12]
   \   00000108   0x80F9             STRH     R1,[R7, #+6]
   \   0000010A   0xB289             UXTH     R1,R1
   \   0000010C   0x2900             CMP      R1,#+0
   \   0000010E   0x603A             STR      R2,[R7, #+0]
   \   00000110   0xBF04             ITT      EQ 
   \   00000112   0x6AA1             LDREQ    R1,[R4, #+40]
   \   00000114   0xF5B1 0x5F00      CMPEQ    R1,#+8192
   \   00000118   0xD103             BNE.N    ??HAL_SPI_TransmitReceive_11
   \   0000011A   0x6801             LDR      R1,[R0, #+0]
   \   0000011C   0xF441 0x5180      ORR      R1,R1,#0x1000
   \   00000120   0x6001             STR      R1,[R0, #+0]
   \                     ??HAL_SPI_TransmitReceive_11: (+1)
   \   00000122   0x89F8             LDRH     R0,[R7, #+14]
   \   00000124   0xB158             CBZ.N    R0,??HAL_SPI_TransmitReceive_17
   \   00000126   0x6820             LDR      R0,[R4, #+0]
   \   00000128   0x6881             LDR      R1,[R0, #+8]
   \   0000012A   0x07C9             LSLS     R1,R1,#+31
   \   0000012C   0xD507             BPL.N    ??HAL_SPI_TransmitReceive_17
   \   0000012E   0x68B9             LDR      R1,[R7, #+8]
   \   00000130   0x68C0             LDR      R0,[R0, #+12]
   \   00000132   0x8008             STRH     R0,[R1, #+0]
   \   00000134   0x1C88             ADDS     R0,R1,#+2
   \   00000136   0x60B8             STR      R0,[R7, #+8]
   \   00000138   0x89F8             LDRH     R0,[R7, #+14]
   \   0000013A   0x1E40             SUBS     R0,R0,#+1
   \   0000013C   0x81F8             STRH     R0,[R7, #+14]
   \                     ??HAL_SPI_TransmitReceive_17: (+1)
   \   0000013E   0xF116 0x0F01      CMN      R6,#+1
   \   00000142   0xD0BC             BEQ.N    ??HAL_SPI_TransmitReceive_9
   \   00000144   0x2E00             CMP      R6,#+0
   \   00000146   0xD055             BEQ.N    ??HAL_SPI_TransmitReceive_18
   \   00000148   0x.... 0x....      BL       HAL_GetTick
   \   0000014C   0xEBA0 0x0008      SUB      R0,R0,R8
   \   00000150   0x4286             CMP      R6,R0
   \   00000152   0xD2B4             BCS.N    ??HAL_SPI_TransmitReceive_9
   \   00000154   0xE04E             B.N      ??HAL_SPI_TransmitReceive_18
   \                     ??HAL_SPI_TransmitReceive_8: (+1)
   \   00000156   0x88F9             LDRH     R1,[R7, #+6]
   \   00000158   0xB911             CBNZ.N   R1,??HAL_SPI_TransmitReceive_19
   \   0000015A   0x89F8             LDRH     R0,[R7, #+14]
   \   0000015C   0xBB08             CBNZ.N   R0,??HAL_SPI_TransmitReceive_20
   \   0000015E   0xE7B2             B.N      ??HAL_SPI_TransmitReceive_12
   \                     ??HAL_SPI_TransmitReceive_19: (+1)
   \   00000160   0x6820             LDR      R0,[R4, #+0]
   \   00000162   0x6882             LDR      R2,[R0, #+8]
   \   00000164   0x0792             LSLS     R2,R2,#+30
   \   00000166   0xD51C             BPL.N    ??HAL_SPI_TransmitReceive_20
   \   00000168   0x2902             CMP      R1,#+2
   \   0000016A   0xDB06             BLT.N    ??HAL_SPI_TransmitReceive_21
   \   0000016C   0x683A             LDR      R2,[R7, #+0]
   \   0000016E   0x1E89             SUBS     R1,R1,#+2
   \   00000170   0xF832 0x3B02      LDRH     R3,[R2], #+2
   \   00000174   0x60C3             STR      R3,[R0, #+12]
   \   00000176   0x603A             STR      R2,[R7, #+0]
   \   00000178   0xE007             B.N      ??HAL_SPI_TransmitReceive_22
   \                     ??HAL_SPI_TransmitReceive_21: (+1)
   \   0000017A   0x6839             LDR      R1,[R7, #+0]
   \   0000017C   0x1C49             ADDS     R1,R1,#+1
   \   0000017E   0x6039             STR      R1,[R7, #+0]
   \   00000180   0x1E49             SUBS     R1,R1,#+1
   \   00000182   0x7809             LDRB     R1,[R1, #+0]
   \   00000184   0x7301             STRB     R1,[R0, #+12]
   \   00000186   0x88F9             LDRH     R1,[R7, #+6]
   \   00000188   0x1E49             SUBS     R1,R1,#+1
   \                     ??HAL_SPI_TransmitReceive_22: (+1)
   \   0000018A   0x80F9             STRH     R1,[R7, #+6]
   \   0000018C   0x88F9             LDRH     R1,[R7, #+6]
   \   0000018E   0x2900             CMP      R1,#+0
   \   00000190   0xBF04             ITT      EQ 
   \   00000192   0x6AA1             LDREQ    R1,[R4, #+40]
   \   00000194   0xF5B1 0x5F00      CMPEQ    R1,#+8192
   \   00000198   0xD103             BNE.N    ??HAL_SPI_TransmitReceive_20
   \   0000019A   0x6801             LDR      R1,[R0, #+0]
   \   0000019C   0xF441 0x5180      ORR      R1,R1,#0x1000
   \   000001A0   0x6001             STR      R1,[R0, #+0]
   \                     ??HAL_SPI_TransmitReceive_20: (+1)
   \   000001A2   0x89F9             LDRH     R1,[R7, #+14]
   \   000001A4   0xB1E1             CBZ.N    R1,??HAL_SPI_TransmitReceive_23
   \   000001A6   0x6820             LDR      R0,[R4, #+0]
   \   000001A8   0x6882             LDR      R2,[R0, #+8]
   \   000001AA   0x07D2             LSLS     R2,R2,#+31
   \   000001AC   0xD518             BPL.N    ??HAL_SPI_TransmitReceive_23
   \   000001AE   0x2902             CMP      R1,#+2
   \   000001B0   0x68BA             LDR      R2,[R7, #+8]
   \   000001B2   0xDB0E             BLT.N    ??HAL_SPI_TransmitReceive_24
   \   000001B4   0x68C1             LDR      R1,[R0, #+12]
   \   000001B6   0x8011             STRH     R1,[R2, #+0]
   \   000001B8   0x1C91             ADDS     R1,R2,#+2
   \   000001BA   0x60B9             STR      R1,[R7, #+8]
   \   000001BC   0x89F9             LDRH     R1,[R7, #+14]
   \   000001BE   0x1E89             SUBS     R1,R1,#+2
   \   000001C0   0x81F9             STRH     R1,[R7, #+14]
   \   000001C2   0xB289             UXTH     R1,R1
   \   000001C4   0x2902             CMP      R1,#+2
   \   000001C6   0xDA0B             BGE.N    ??HAL_SPI_TransmitReceive_23
   \   000001C8   0x6841             LDR      R1,[R0, #+4]
   \   000001CA   0xF441 0x5180      ORR      R1,R1,#0x1000
   \   000001CE   0x6041             STR      R1,[R0, #+4]
   \   000001D0   0xE006             B.N      ??HAL_SPI_TransmitReceive_23
   \                     ??HAL_SPI_TransmitReceive_24: (+1)
   \   000001D2   0x1C51             ADDS     R1,R2,#+1
   \   000001D4   0x60B9             STR      R1,[R7, #+8]
   \   000001D6   0x7B00             LDRB     R0,[R0, #+12]
   \   000001D8   0x7010             STRB     R0,[R2, #+0]
   \   000001DA   0x89F8             LDRH     R0,[R7, #+14]
   \   000001DC   0x1E40             SUBS     R0,R0,#+1
   \   000001DE   0x81F8             STRH     R0,[R7, #+14]
   \                     ??HAL_SPI_TransmitReceive_23: (+1)
   \   000001E0   0xF116 0x0F01      CMN      R6,#+1
   \   000001E4   0xD0B7             BEQ.N    ??HAL_SPI_TransmitReceive_8
   \   000001E6   0xB12E             CBZ.N    R6,??HAL_SPI_TransmitReceive_18
   \   000001E8   0x.... 0x....      BL       HAL_GetTick
   \   000001EC   0xEBA0 0x0008      SUB      R0,R0,R8
   \   000001F0   0x4286             CMP      R6,R0
   \   000001F2   0xD2B0             BCS.N    ??HAL_SPI_TransmitReceive_8
   \                     ??HAL_SPI_TransmitReceive_18: (+1)
   \   000001F4   0x2001             MOVS     R0,#+1
   \   000001F6   0x7068             STRB     R0,[R5, #+1]
   \   000001F8   0x2000             MOVS     R0,#+0
   \   000001FA   0x7028             STRB     R0,[R5, #+0]
   \   000001FC   0xE042             B.N      ??HAL_SPI_TransmitReceive_25
   \                     ??HAL_SPI_TransmitReceive_15: (+1)
   \   000001FE   0x7B00             LDRB     R0,[R0, #+12]
   \   00000200   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   \   00000204   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   00000208   0x6B20             LDR      R0,[R4, #+48]
   \   0000020A   0x2802             CMP      R0,#+2
   \   0000020C   0xD110             BNE.N    ??HAL_SPI_TransmitReceive_13
   \   0000020E   0x4633             MOV      R3,R6
   \   00000210   0x2201             MOVS     R2,#+1
   \   00000212   0x2101             MOVS     R1,#+1
   \   00000214   0x4620             MOV      R0,R4
   \   00000216   0x.... 0x....      BL       SPI_WaitFlagStateUntilTimeout
   \   0000021A   0xB118             CBZ.N    R0,??HAL_SPI_TransmitReceive_26
   \   0000021C   0x6868             LDR      R0,[R5, #+4]
   \   0000021E   0xF040 0x0002      ORR      R0,R0,#0x2
   \   00000222   0x6068             STR      R0,[R5, #+4]
   \                     ??HAL_SPI_TransmitReceive_26: (+1)
   \   00000224   0x6820             LDR      R0,[R4, #+0]
   \   00000226   0x7B00             LDRB     R0,[R0, #+12]
   \                     ??HAL_SPI_TransmitReceive_16: (+1)
   \   00000228   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   \   0000022C   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \                     ??HAL_SPI_TransmitReceive_13: (+1)
   \   00000230   0x4633             MOV      R3,R6
   \   00000232   0x2200             MOVS     R2,#+0
   \   00000234   0xF44F 0x51C0      MOV      R1,#+6144
   \   00000238   0x4620             MOV      R0,R4
   \   0000023A   0x.... 0x....      BL       SPI_WaitFifoStateUntilTimeout
   \   0000023E   0xB9E8             CBNZ.N   R0,??HAL_SPI_TransmitReceive_27
   \   00000240   0x4633             MOV      R3,R6
   \   00000242   0x2200             MOVS     R2,#+0
   \   00000244   0x2180             MOVS     R1,#+128
   \   00000246   0x4620             MOV      R0,R4
   \   00000248   0x.... 0x....      BL       SPI_WaitFlagStateUntilTimeout
   \   0000024C   0xB9B0             CBNZ.N   R0,??HAL_SPI_TransmitReceive_27
   \   0000024E   0x4633             MOV      R3,R6
   \   00000250   0x2200             MOVS     R2,#+0
   \   00000252   0xF44F 0x61C0      MOV      R1,#+1536
   \   00000256   0x4620             MOV      R0,R4
   \   00000258   0x.... 0x....      BL       SPI_WaitFifoStateUntilTimeout
   \   0000025C   0xB970             CBNZ.N   R0,??HAL_SPI_TransmitReceive_27
   \   0000025E   0x2001             MOVS     R0,#+1
   \   00000260   0x7068             STRB     R0,[R5, #+1]
   \   00000262   0x6821             LDR      R1,[R4, #+0]
   \   00000264   0x6868             LDR      R0,[R5, #+4]
   \   00000266   0x688A             LDR      R2,[R1, #+8]
   \   00000268   0x06D2             LSLS     R2,R2,#+27
   \   0000026A   0xD40E             BMI.N    ??HAL_SPI_TransmitReceive_28
   \   0000026C   0x2100             MOVS     R1,#+0
   \   0000026E   0x1E40             SUBS     R0,R0,#+1
   \   00000270   0x4180             SBCS     R0,R0,R0
   \   00000272   0x43C0             MVNS     R0,R0
   \   00000274   0x7029             STRB     R1,[R5, #+0]
   \   00000276   0x0FC0             LSRS     R0,R0,#+31
   \                     ??HAL_SPI_TransmitReceive_1: (+1)
   \   00000278   0xE8BD 0x87F6      POP      {R1,R2,R4-R10,PC}  ;; return
   \                     ??HAL_SPI_TransmitReceive_27: (+1)
   \   0000027C   0x6868             LDR      R0,[R5, #+4]
   \   0000027E   0xF040 0x0020      ORR      R0,R0,#0x20
   \   00000282   0x6068             STR      R0,[R5, #+4]
   \                     ??HAL_SPI_TransmitReceive_25: (+1)
   \   00000284   0x2003             MOVS     R0,#+3
   \   00000286   0xE8BD 0x87F6      POP      {R1,R2,R4-R10,PC}
   \                     ??HAL_SPI_TransmitReceive_28: (+1)
   \   0000028A   0xF040 0x0002      ORR      R0,R0,#0x2
   \   0000028E   0x6068             STR      R0,[R5, #+4]
   \   00000290   0xF64F 0x70EF      MOVW     R0,#+65519
   \   00000294   0x6088             STR      R0,[R1, #+8]
   \   00000296   0x2000             MOVS     R0,#+0
   \   00000298   0x7028             STRB     R0,[R5, #+0]
   \   0000029A   0x2001             MOVS     R0,#+1
   \   0000029C   0xE8BD 0x87F6      POP      {R1,R2,R4-R10,PC}
    960            }
    961          }
    962          
    963          /**
    964            * @brief  Transmit an amount of data in no-blocking mode with Interrupt
    965            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
    966            *               the configuration information for SPI module.
    967            * @param  pData: pointer to data buffer
    968            * @param  Size: amount of data to be sent
    969            * @retval HAL status
    970            */

   \                                 In section .text, align 2, keep-with-next
    971          HAL_StatusTypeDef HAL_SPI_Transmit_IT(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size)
    972          {
    973            assert_param(IS_SPI_DIRECTION_2LINES_OR_1LINE(hspi->Init.Direction));
    974            
    975            if(hspi->State == HAL_SPI_STATE_READY)
   \                     HAL_SPI_Transmit_IT: (+1)
   \   00000000   0xF100 0x0344      ADD      R3,R0,#+68
   \   00000004   0xB410             PUSH     {R4}
   \   00000006   0x7E5C             LDRB     R4,[R3, #+25]
   \   00000008   0x2C01             CMP      R4,#+1
   \   0000000A   0xD142             BNE.N    ??HAL_SPI_Transmit_IT_0
    976            {
    977              if((pData == NULL) || (Size == 0)) 
   \   0000000C   0x2900             CMP      R1,#+0
   \   0000000E   0xBF14             ITE      NE 
   \   00000010   0x2A00             CMPNE    R2,#+0
   \   00000012   0x2001             MOVEQ    R0,#+1
    978              {
    979                return  HAL_ERROR;                                    
   \   00000014   0xD03E             BEQ.N    ??HAL_SPI_Transmit_IT_1
    980              }
    981              
    982              /* Process Locked */
    983              __HAL_LOCK(hspi);
   \   00000016   0x7E1C             LDRB     R4,[R3, #+24]
   \   00000018   0x2C01             CMP      R4,#+1
   \   0000001A   0xD03A             BEQ.N    ??HAL_SPI_Transmit_IT_0
   \   0000001C   0x2401             MOVS     R4,#+1
   \   0000001E   0x761C             STRB     R4,[R3, #+24]
    984              
    985              hspi->State       = HAL_SPI_STATE_BUSY_TX;
   \   00000020   0x2403             MOVS     R4,#+3
   \   00000022   0x765C             STRB     R4,[R3, #+25]
    986              hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
   \   00000024   0x2400             MOVS     R4,#+0
   \   00000026   0x61DC             STR      R4,[R3, #+28]
    987              hspi->pTxBuffPtr  = pData;
   \   00000028   0x6381             STR      R1,[R0, #+56]
    988              hspi->TxXferSize  = Size;
   \   0000002A   0x8782             STRH     R2,[R0, #+60]
    989              hspi->TxXferCount = Size;
   \   0000002C   0x87C2             STRH     R2,[R0, #+62]
    990              hspi->pRxBuffPtr  = NULL;
   \   0000002E   0x6404             STR      R4,[R0, #+64]
    991              hspi->RxXferSize  = 0;
   \   00000030   0x801C             STRH     R4,[R3, #+0]
    992              hspi->RxXferCount = 0;
   \   00000032   0x805C             STRH     R4,[R3, #+2]
    993          
    994              /* Set the function for IT treatement */
    995              if(hspi->Init.DataSize > SPI_DATASIZE_8BIT )
   \   00000034   0x68C1             LDR      R1,[R0, #+12]
   \   00000036   0xF5B1 0x6FE0      CMP      R1,#+1792
   \   0000003A   0xBF8C             ITE      HI 
   \   0000003C   0x.... 0x....      ADRHI.W  R1,SPI_TxISR_16BIT
   \   00000040   0x.... 0x....      ADRLS.W  R1,SPI_TxISR_8BIT
    996              {
    997                hspi->RxISR = NULL;
    998                hspi->TxISR = SPI_TxISR_16BIT;
    999              }
   1000              else
   1001              {
   1002                hspi->RxISR = NULL;
   1003                hspi->TxISR = SPI_TxISR_8BIT;
   \   00000044   0x60D9             STR      R1,[R3, #+12]
   \   00000046   0x609C             STR      R4,[R3, #+8]
   1004              }
   1005              
   1006              /* Configure communication direction : 1Line */
   1007              if(hspi->Init.Direction == SPI_DIRECTION_1LINE)
   \   00000048   0x6882             LDR      R2,[R0, #+8]
   \   0000004A   0x6801             LDR      R1,[R0, #+0]
   \   0000004C   0xF5B2 0x4F00      CMP      R2,#+32768
   \   00000050   0xD103             BNE.N    ??HAL_SPI_Transmit_IT_2
   1008              {
   1009                SPI_1LINE_TX(hspi);
   \   00000052   0x680A             LDR      R2,[R1, #+0]
   \   00000054   0xF442 0x4280      ORR      R2,R2,#0x4000
   \   00000058   0x600A             STR      R2,[R1, #+0]
   1010              }
   1011              
   1012              /* Reset CRC Calculation */
   1013              if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   \                     ??HAL_SPI_Transmit_IT_2: (+1)
   \   0000005A   0x6A80             LDR      R0,[R0, #+40]
   \   0000005C   0xF5B0 0x5F00      CMP      R0,#+8192
   \   00000060   0xD108             BNE.N    ??HAL_SPI_Transmit_IT_3
   1014              {
   1015                SPI_RESET_CRC(hspi);    
   \   00000062   0x6808             LDR      R0,[R1, #+0]
   \   00000064   0xF64D 0x72FF      MOVW     R2,#+57343
   \   00000068   0x4010             ANDS     R0,R2,R0
   \   0000006A   0x6008             STR      R0,[R1, #+0]
   \   0000006C   0x6808             LDR      R0,[R1, #+0]
   \   0000006E   0xF440 0x5000      ORR      R0,R0,#0x2000
   \   00000072   0x6008             STR      R0,[R1, #+0]
   1016              }
   1017              
   1018              /* Enable TXE and ERR interrupt */
   1019              __HAL_SPI_ENABLE_IT(hspi,(SPI_IT_TXE));
   \                     ??HAL_SPI_Transmit_IT_3: (+1)
   \   00000074   0x6848             LDR      R0,[R1, #+4]
   \   00000076   0xF040 0x0080      ORR      R0,R0,#0x80
   \   0000007A   0x6048             STR      R0,[R1, #+4]
   1020          
   1021              /* Process Unlocked */
   1022              __HAL_UNLOCK(hspi);
   \   0000007C   0x761C             STRB     R4,[R3, #+24]
   1023          
   1024              /* Note : The SPI must be enabled after unlocking current process 
   1025                        to avoid the risk of SPI interrupt handle execution before current
   1026                        process unlock */
   1027                  
   1028              /* Check if the SPI is already enabled */ 
   1029              if((hspi->Instance->CR1 &SPI_CR1_SPE) != SPI_CR1_SPE)
   \   0000007E   0x6808             LDR      R0,[R1, #+0]
   \   00000080   0x0640             LSLS     R0,R0,#+25
   \   00000082   0xD403             BMI.N    ??HAL_SPI_Transmit_IT_4
   1030              {
   1031                /* Enable SPI peripheral */    
   1032                __HAL_SPI_ENABLE(hspi);
   \   00000084   0x6808             LDR      R0,[R1, #+0]
   \   00000086   0xF040 0x0040      ORR      R0,R0,#0x40
   \   0000008A   0x6008             STR      R0,[R1, #+0]
   1033              }
   1034                  
   1035              return HAL_OK;
   \                     ??HAL_SPI_Transmit_IT_4: (+1)
   \   0000008C   0x2000             MOVS     R0,#+0
   \   0000008E   0xBC10             POP      {R4}
   \   00000090   0x4770             BX       LR
   1036            }
   1037            else
   1038            {
   1039              return HAL_BUSY;
   \                     ??HAL_SPI_Transmit_IT_0: (+1)
   \   00000092   0x2002             MOVS     R0,#+2
   \                     ??HAL_SPI_Transmit_IT_1: (+1)
   \   00000094   0xBC10             POP      {R4}
   \   00000096   0x4770             BX       LR               ;; return
   1040            }
   1041          }
   1042          
   1043          /**
   1044            * @brief  Receive an amount of data in no-blocking mode with Interrupt
   1045            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   1046            *               the configuration information for SPI module.
   1047            * @param  pData: pointer to data buffer
   1048            * @param  Size: amount of data to be sent
   1049            * @retval HAL status
   1050            */

   \                                 In section .text, align 2, keep-with-next
   1051          HAL_StatusTypeDef HAL_SPI_Receive_IT(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size)
   1052          {
   \                     HAL_SPI_Receive_IT: (+1)
   \   00000000   0xB418             PUSH     {R3,R4}
   1053            if(hspi->State == HAL_SPI_STATE_READY)
   \   00000002   0xF100 0x0344      ADD      R3,R0,#+68
   \   00000006   0x7E5C             LDRB     R4,[R3, #+25]
   \   00000008   0x2C01             CMP      R4,#+1
   \   0000000A   0xD168             BNE.N    ??HAL_SPI_Receive_IT_0
   1054            {
   1055              if((pData == NULL) || (Size == 0))
   \   0000000C   0x2900             CMP      R1,#+0
   \   0000000E   0xBF14             ITE      NE 
   \   00000010   0x2A00             CMPNE    R2,#+0
   \   00000012   0x2001             MOVEQ    R0,#+1
   1056              { 
   1057                return  HAL_ERROR;                      
   \   00000014   0xD064             BEQ.N    ??HAL_SPI_Receive_IT_1
   1058              }
   1059          
   1060              /* Process Locked */
   1061              __HAL_LOCK(hspi);
   \   00000016   0x7E1C             LDRB     R4,[R3, #+24]
   \   00000018   0x2C01             CMP      R4,#+1
   \   0000001A   0xD060             BEQ.N    ??HAL_SPI_Receive_IT_0
   \   0000001C   0x2401             MOVS     R4,#+1
   \   0000001E   0x761C             STRB     R4,[R3, #+24]
   1062              
   1063              /* Configure communication */
   1064              hspi->State       = HAL_SPI_STATE_BUSY_RX;
   \   00000020   0x2404             MOVS     R4,#+4
   \   00000022   0x765C             STRB     R4,[R3, #+25]
   1065              hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
   \   00000024   0x2400             MOVS     R4,#+0
   \   00000026   0x61DC             STR      R4,[R3, #+28]
   1066              hspi->pRxBuffPtr  = pData;
   \   00000028   0x6401             STR      R1,[R0, #+64]
   1067              hspi->RxXferSize  = Size;
   \   0000002A   0x801A             STRH     R2,[R3, #+0]
   1068              hspi->RxXferCount = Size;
   \   0000002C   0x805A             STRH     R2,[R3, #+2]
   1069              hspi->pTxBuffPtr  = NULL;
   \   0000002E   0x6384             STR      R4,[R0, #+56]
   1070              hspi->TxXferSize  = 0;
   \   00000030   0x8784             STRH     R4,[R0, #+60]
   1071              hspi->TxXferCount = 0;
   \   00000032   0x87C4             STRH     R4,[R0, #+62]
   1072          
   1073              if((hspi->Init.Mode == SPI_MODE_MASTER) && (hspi->Init.Direction == SPI_DIRECTION_2LINES))
   \   00000034   0x6844             LDR      R4,[R0, #+4]
   \   00000036   0xF5B4 0x7F82      CMP      R4,#+260
   \   0000003A   0xBF04             ITT      EQ 
   \   0000003C   0x6884             LDREQ    R4,[R0, #+8]
   \   0000003E   0x2C00             CMPEQ    R4,#+0
   \   00000040   0xD105             BNE.N    ??HAL_SPI_Receive_IT_2
   1074              {
   1075                /* Process Unlocked */
   1076                __HAL_UNLOCK(hspi);
   \   00000042   0x761C             STRB     R4,[R3, #+24]
   1077                /* the receive process is not supported in 2Lines direction master mode */
   1078                /* in this we call the transmitReceive process          */
   1079                return HAL_SPI_TransmitReceive_IT(hspi,pData,pData,Size);
   \   00000044   0x4613             MOV      R3,R2
   \   00000046   0xB001             ADD      SP,SP,#+4
   \   00000048   0x460A             MOV      R2,R1
   \   0000004A   0xBC10             POP      {R4}
   \   0000004C   0x....             B.N      HAL_SPI_TransmitReceive_IT
   1080              }
   1081                  
   1082              if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   \                     ??HAL_SPI_Receive_IT_2: (+1)
   \   0000004E   0x6A81             LDR      R1,[R0, #+40]
   \   00000050   0xF240 0x7201      MOVW     R2,#+1793
   \   00000054   0xF5B1 0x5F00      CMP      R1,#+8192
   \   00000058   0xD108             BNE.N    ??HAL_SPI_Receive_IT_3
   1083              {
   1084                hspi->CRCSize = 1;
   \   0000005A   0x2101             MOVS     R1,#+1
   \   0000005C   0x6059             STR      R1,[R3, #+4]
   1085                if((hspi->Init.DataSize <= SPI_DATASIZE_8BIT) && (hspi->Init.CRCLength == SPI_CRC_LENGTH_16BIT))
   \   0000005E   0x68C1             LDR      R1,[R0, #+12]
   \   00000060   0x4291             CMP      R1,R2
   \   00000062   0xD205             BCS.N    ??HAL_SPI_Receive_IT_4
   \   00000064   0x6B01             LDR      R1,[R0, #+48]
   \   00000066   0x2902             CMP      R1,#+2
   \   00000068   0xD102             BNE.N    ??HAL_SPI_Receive_IT_4
   1086                {
   1087                  hspi->CRCSize = 2;
   \   0000006A   0xE000             B.N      ??HAL_SPI_Receive_IT_5
   1088                }
   1089              }
   1090              else
   1091              {
   1092                hspi->CRCSize = 0;
   \                     ??HAL_SPI_Receive_IT_3: (+1)
   \   0000006C   0x2100             MOVS     R1,#+0
   \                     ??HAL_SPI_Receive_IT_5: (+1)
   \   0000006E   0x6059             STR      R1,[R3, #+4]
   1093              }
   1094                  
   1095              /* check the data size to adapt Rx threshold and the set the function for IT treatment */
   1096              if(hspi->Init.DataSize > SPI_DATASIZE_8BIT )
   \                     ??HAL_SPI_Receive_IT_4: (+1)
   \   00000070   0x6801             LDR      R1,[R0, #+0]
   \   00000072   0x68C4             LDR      R4,[R0, #+12]
   \   00000074   0x4294             CMP      R4,R2
   \   00000076   0x684A             LDR      R2,[R1, #+4]
   \   00000078   0xD305             BCC.N    ??HAL_SPI_Receive_IT_6
   1097              {
   1098                /* set fiforxthreshold according the reception data length: 16 bit */
   1099                CLEAR_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
   \   0000007A   0xF422 0x5280      BIC      R2,R2,#0x1000
   \   0000007E   0x604A             STR      R2,[R1, #+4]
   1100                hspi->RxISR = SPI_RxISR_16BIT;
   \   00000080   0x.... 0x....      ADR.W    R2,SPI_RxISR_16BIT
   1101                hspi->TxISR = NULL;
   \   00000084   0xE004             B.N      ??HAL_SPI_Receive_IT_7
   1102              }
   1103              else
   1104              {
   1105                /* set fiforxthreshold according the reception data length: 8 bit */
   1106                SET_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
   \                     ??HAL_SPI_Receive_IT_6: (+1)
   \   00000086   0xF442 0x5280      ORR      R2,R2,#0x1000
   \   0000008A   0x604A             STR      R2,[R1, #+4]
   1107                hspi->RxISR = SPI_RxISR_8BIT;
   \   0000008C   0x.... 0x....      ADR.W    R2,SPI_RxISR_8BIT
   1108                hspi->TxISR = NULL;
   \                     ??HAL_SPI_Receive_IT_7: (+1)
   \   00000090   0x2400             MOVS     R4,#+0
   \   00000092   0x609A             STR      R2,[R3, #+8]
   \   00000094   0x60DC             STR      R4,[R3, #+12]
   1109              }
   1110              
   1111              /* Configure communication direction : 1Line */
   1112              if(hspi->Init.Direction == SPI_DIRECTION_1LINE)
   \   00000096   0x6882             LDR      R2,[R0, #+8]
   \   00000098   0xF5B2 0x4F00      CMP      R2,#+32768
   \   0000009C   0xD103             BNE.N    ??HAL_SPI_Receive_IT_8
   1113              {
   1114                SPI_1LINE_RX(hspi);
   \   0000009E   0x680A             LDR      R2,[R1, #+0]
   \   000000A0   0xF422 0x4280      BIC      R2,R2,#0x4000
   \   000000A4   0x600A             STR      R2,[R1, #+0]
   1115              }
   1116              
   1117              /* Reset CRC Calculation */
   1118              if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   \                     ??HAL_SPI_Receive_IT_8: (+1)
   \   000000A6   0x6A80             LDR      R0,[R0, #+40]
   \   000000A8   0xF5B0 0x5F00      CMP      R0,#+8192
   \   000000AC   0xD108             BNE.N    ??HAL_SPI_Receive_IT_9
   1119              {
   1120                SPI_RESET_CRC(hspi);
   \   000000AE   0x6808             LDR      R0,[R1, #+0]
   \   000000B0   0xF64D 0x72FF      MOVW     R2,#+57343
   \   000000B4   0x4010             ANDS     R0,R2,R0
   \   000000B6   0x6008             STR      R0,[R1, #+0]
   \   000000B8   0x6808             LDR      R0,[R1, #+0]
   \   000000BA   0xF440 0x5000      ORR      R0,R0,#0x2000
   \   000000BE   0x6008             STR      R0,[R1, #+0]
   1121              }
   1122              
   1123              /* Enable TXE and ERR interrupt */
   1124              __HAL_SPI_ENABLE_IT(hspi, (SPI_IT_RXNE | SPI_IT_ERR));
   \                     ??HAL_SPI_Receive_IT_9: (+1)
   \   000000C0   0x6848             LDR      R0,[R1, #+4]
   \   000000C2   0xF040 0x0060      ORR      R0,R0,#0x60
   \   000000C6   0x6048             STR      R0,[R1, #+4]
   1125              
   1126              /* Process Unlocked */
   1127              __HAL_UNLOCK(hspi);
   \   000000C8   0x761C             STRB     R4,[R3, #+24]
   1128              
   1129              /* Note : The SPI must be enabled after unlocking current process 
   1130              to avoid the risk of SPI interrupt handle execution before current
   1131              process unlock */
   1132              
   1133              /* Check if the SPI is already enabled */ 
   1134              if((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
   \   000000CA   0x6808             LDR      R0,[R1, #+0]
   \   000000CC   0x0640             LSLS     R0,R0,#+25
   \   000000CE   0xD403             BMI.N    ??HAL_SPI_Receive_IT_10
   1135              {
   1136                /* Enable SPI peripheral */    
   1137                __HAL_SPI_ENABLE(hspi);
   \   000000D0   0x6808             LDR      R0,[R1, #+0]
   \   000000D2   0xF040 0x0040      ORR      R0,R0,#0x40
   \   000000D6   0x6008             STR      R0,[R1, #+0]
   1138              }
   1139              
   1140              return HAL_OK;
   \                     ??HAL_SPI_Receive_IT_10: (+1)
   \   000000D8   0x2000             MOVS     R0,#+0
   \   000000DA   0xBC12             POP      {R1,R4}
   \   000000DC   0x4770             BX       LR
   1141            }
   1142            else
   1143            {
   1144              return HAL_BUSY; 
   \                     ??HAL_SPI_Receive_IT_0: (+1)
   \   000000DE   0x2002             MOVS     R0,#+2
   \                     ??HAL_SPI_Receive_IT_1: (+1)
   \   000000E0   0xBC12             POP      {R1,R4}
   \   000000E2   0x4770             BX       LR               ;; return
   1145            }
   1146          }
   1147          
   1148          /**
   1149            * @brief  Transmit and Receive an amount of data in no-blocking mode with Interrupt
   1150            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   1151            *               the configuration information for SPI module.
   1152            * @param  pTxData: pointer to transmission data buffer
   1153            * @param  pRxData: pointer to reception data buffer
   1154            * @param  Size: amount of data to be sent and received
   1155            * @retval HAL status
   1156            */

   \                                 In section .text, align 2, keep-with-next
   1157          HAL_StatusTypeDef HAL_SPI_TransmitReceive_IT(SPI_HandleTypeDef *hspi, uint8_t *pTxData, uint8_t *pRxData, uint16_t Size)
   1158          {
   \                     HAL_SPI_TransmitReceive_IT: (+1)
   \   00000000   0xB4F0             PUSH     {R4-R7}
   1159            assert_param(IS_SPI_DIRECTION_2LINES(hspi->Init.Direction));
   1160            
   1161            if((hspi->State == HAL_SPI_STATE_READY) || \
   1162               ((hspi->Init.Mode == SPI_MODE_MASTER) && (hspi->Init.Direction == SPI_DIRECTION_2LINES) && (hspi->State == HAL_SPI_STATE_BUSY_RX)))
   \   00000002   0xF100 0x0444      ADD      R4,R0,#+68
   \   00000006   0x7E65             LDRB     R5,[R4, #+25]
   \   00000008   0x2D01             CMP      R5,#+1
   \   0000000A   0xD007             BEQ.N    ??HAL_SPI_TransmitReceive_IT_0
   \   0000000C   0x6846             LDR      R6,[R0, #+4]
   \   0000000E   0xF5B6 0x7F82      CMP      R6,#+260
   \   00000012   0xBF02             ITTT     EQ 
   \   00000014   0x6886             LDREQ    R6,[R0, #+8]
   \   00000016   0x2E00             CMPEQ    R6,#+0
   \   00000018   0x2D04             CMPEQ    R5,#+4
   \   0000001A   0xD164             BNE.N    ??HAL_SPI_TransmitReceive_IT_1
   1163            {
   1164              if((pTxData == NULL ) || (pRxData == NULL ) || (Size == 0)) 
   \                     ??HAL_SPI_TransmitReceive_IT_0: (+1)
   \   0000001C   0x2900             CMP      R1,#+0
   \   0000001E   0xBF18             IT       NE 
   \   00000020   0x2A00             CMPNE    R2,#+0
   \   00000022   0xD000             BEQ.N    ??HAL_SPI_TransmitReceive_IT_2
   \   00000024   0xB913             CBNZ.N   R3,??HAL_SPI_TransmitReceive_IT_3
   1165              {
   1166                return  HAL_ERROR;                                    
   \                     ??HAL_SPI_TransmitReceive_IT_2: (+1)
   \   00000026   0x2001             MOVS     R0,#+1
   \   00000028   0xBCF0             POP      {R4-R7}
   \   0000002A   0x4770             BX       LR
   1167              }
   1168              
   1169              /* Process locked */
   1170              __HAL_LOCK(hspi);
   \                     ??HAL_SPI_TransmitReceive_IT_3: (+1)
   \   0000002C   0x7E26             LDRB     R6,[R4, #+24]
   \   0000002E   0x2E01             CMP      R6,#+1
   \   00000030   0xD059             BEQ.N    ??HAL_SPI_TransmitReceive_IT_1
   \   00000032   0x2601             MOVS     R6,#+1
   \   00000034   0x7626             STRB     R6,[R4, #+24]
   1171              
   1172              hspi->CRCSize = 0;
   \   00000036   0x2600             MOVS     R6,#+0
   \   00000038   0x6066             STR      R6,[R4, #+4]
   1173              if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   \   0000003A   0x6A87             LDR      R7,[R0, #+40]
   \   0000003C   0xF240 0x7601      MOVW     R6,#+1793
   \   00000040   0xF5B7 0x5F00      CMP      R7,#+8192
   \   00000044   0xD108             BNE.N    ??HAL_SPI_TransmitReceive_IT_4
   1174              {
   1175                hspi->CRCSize = 1;
   \   00000046   0x2701             MOVS     R7,#+1
   \   00000048   0x6067             STR      R7,[R4, #+4]
   1176                if((hspi->Init.DataSize <= SPI_DATASIZE_8BIT) && (hspi->Init.CRCLength == SPI_CRC_LENGTH_16BIT))
   \   0000004A   0x68C7             LDR      R7,[R0, #+12]
   \   0000004C   0x42B7             CMP      R7,R6
   \   0000004E   0xD203             BCS.N    ??HAL_SPI_TransmitReceive_IT_4
   \   00000050   0x6B07             LDR      R7,[R0, #+48]
   \   00000052   0x2F02             CMP      R7,#+2
   \   00000054   0xBF08             IT       EQ 
   \   00000056   0x6067             STREQ    R7,[R4, #+4]
   1177                {
   1178                  hspi->CRCSize = 2;
   1179                }
   1180              }
   1181              
   1182              if(hspi->State != HAL_SPI_STATE_BUSY_RX)
   \                     ??HAL_SPI_TransmitReceive_IT_4: (+1)
   \   00000058   0x2D04             CMP      R5,#+4
   \   0000005A   0xBF1C             ITT      NE 
   \   0000005C   0x2505             MOVNE    R5,#+5
   \   0000005E   0x7665             STRBNE   R5,[R4, #+25]
   1183              {
   1184                hspi->State = HAL_SPI_STATE_BUSY_TX_RX;
   1185              }
   1186              
   1187              hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
   \   00000060   0x2500             MOVS     R5,#+0
   \   00000062   0x61E5             STR      R5,[R4, #+28]
   1188              hspi->pTxBuffPtr  = pTxData;
   \   00000064   0x6381             STR      R1,[R0, #+56]
   1189              hspi->TxXferSize  = Size;
   \   00000066   0x8783             STRH     R3,[R0, #+60]
   1190              hspi->TxXferCount = Size;
   \   00000068   0x87C3             STRH     R3,[R0, #+62]
   1191              hspi->pRxBuffPtr  = pRxData;
   \   0000006A   0x6402             STR      R2,[R0, #+64]
   1192              hspi->RxXferSize  = Size;
   \   0000006C   0x8023             STRH     R3,[R4, #+0]
   1193              hspi->RxXferCount = Size;
   \   0000006E   0x8063             STRH     R3,[R4, #+2]
   1194              
   1195              /* Set the function for IT treatement */
   1196              if(hspi->Init.DataSize > SPI_DATASIZE_8BIT )
   \   00000070   0x68C1             LDR      R1,[R0, #+12]
   \   00000072   0x42B1             CMP      R1,R6
   \   00000074   0xBF27             ITTEE    CS 
   \   00000076   0x.... 0x....      ADRCS.W  R1,SPI_2linesRxISR_16BIT
   \   0000007A   0x.... 0x....      ADRCS.W  R2,SPI_2linesTxISR_16BIT
   \   0000007E   0x.... 0x....      ADRCC.W  R1,SPI_2linesRxISR_8BIT
   \   00000082   0x.... 0x....      ADRCC.W  R2,SPI_2linesTxISR_8BIT
   1197              {
   1198                hspi->RxISR = SPI_2linesRxISR_16BIT;
   1199                hspi->TxISR = SPI_2linesTxISR_16BIT;       
   1200              }
   1201              else
   1202              {
   1203                hspi->RxISR = SPI_2linesRxISR_8BIT;
   1204                hspi->TxISR = SPI_2linesTxISR_8BIT;
   \   00000086   0x60E2             STR      R2,[R4, #+12]
   \   00000088   0x60A1             STR      R1,[R4, #+8]
   1205              }
   1206              
   1207              /* Reset CRC Calculation */
   1208              if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   \   0000008A   0x6A81             LDR      R1,[R0, #+40]
   \   0000008C   0xF5B1 0x5F00      CMP      R1,#+8192
   \   00000090   0xD109             BNE.N    ??HAL_SPI_TransmitReceive_IT_5
   1209              {
   1210                SPI_RESET_CRC(hspi);
   \   00000092   0x6801             LDR      R1,[R0, #+0]
   \   00000094   0xF64D 0x73FF      MOVW     R3,#+57343
   \   00000098   0x680A             LDR      R2,[R1, #+0]
   \   0000009A   0x401A             ANDS     R2,R3,R2
   \   0000009C   0x600A             STR      R2,[R1, #+0]
   \   0000009E   0x680A             LDR      R2,[R1, #+0]
   \   000000A0   0xF442 0x5200      ORR      R2,R2,#0x2000
   \   000000A4   0x600A             STR      R2,[R1, #+0]
   1211              }
   1212              
   1213              /* check if packing mode is enabled and if there is more than 2 data to receive */
   1214              if((hspi->Init.DataSize > SPI_DATASIZE_8BIT) || (hspi->RxXferCount >= 2))
   \                     ??HAL_SPI_TransmitReceive_IT_5: (+1)
   \   000000A6   0x68C1             LDR      R1,[R0, #+12]
   \   000000A8   0x42B1             CMP      R1,R6
   \   000000AA   0xD202             BCS.N    ??HAL_SPI_TransmitReceive_IT_6
   \   000000AC   0x8861             LDRH     R1,[R4, #+2]
   \   000000AE   0x2902             CMP      R1,#+2
   \   000000B0   0xDB04             BLT.N    ??HAL_SPI_TransmitReceive_IT_7
   1215              {
   1216                /* set fiforxthreshold according the reception data length: 16 bit */
   1217                CLEAR_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
   \                     ??HAL_SPI_TransmitReceive_IT_6: (+1)
   \   000000B2   0x6801             LDR      R1,[R0, #+0]
   \   000000B4   0x684A             LDR      R2,[R1, #+4]
   \   000000B6   0xF422 0x5280      BIC      R2,R2,#0x1000
   \   000000BA   0xE003             B.N      ??HAL_SPI_TransmitReceive_IT_8
   1218              }
   1219              else
   1220              {
   1221                /* set fiforxthreshold according the reception data length: 8 bit */
   1222                SET_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
   \                     ??HAL_SPI_TransmitReceive_IT_7: (+1)
   \   000000BC   0x6801             LDR      R1,[R0, #+0]
   \   000000BE   0x684A             LDR      R2,[R1, #+4]
   \   000000C0   0xF442 0x5280      ORR      R2,R2,#0x1000
   \                     ??HAL_SPI_TransmitReceive_IT_8: (+1)
   \   000000C4   0x604A             STR      R2,[R1, #+4]
   1223              }
   1224              
   1225              /* Enable TXE, RXNE and ERR interrupt */
   1226              __HAL_SPI_ENABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_RXNE | SPI_IT_ERR));
   \   000000C6   0x6801             LDR      R1,[R0, #+0]
   \   000000C8   0x6848             LDR      R0,[R1, #+4]
   \   000000CA   0xF040 0x00E0      ORR      R0,R0,#0xE0
   \   000000CE   0x6048             STR      R0,[R1, #+4]
   1227              
   1228              /* Process Unlocked */
   1229              __HAL_UNLOCK(hspi);
   \   000000D0   0x7625             STRB     R5,[R4, #+24]
   1230              
   1231              /* Check if the SPI is already enabled */ 
   1232              if((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
   \   000000D2   0x6808             LDR      R0,[R1, #+0]
   \   000000D4   0x0640             LSLS     R0,R0,#+25
   \   000000D6   0xD403             BMI.N    ??HAL_SPI_TransmitReceive_IT_9
   1233              {
   1234                /* Enable SPI peripheral */    
   1235                __HAL_SPI_ENABLE(hspi);
   \   000000D8   0x6808             LDR      R0,[R1, #+0]
   \   000000DA   0xF040 0x0040      ORR      R0,R0,#0x40
   \   000000DE   0x6008             STR      R0,[R1, #+0]
   1236              }
   1237              
   1238              return HAL_OK;
   \                     ??HAL_SPI_TransmitReceive_IT_9: (+1)
   \   000000E0   0x2000             MOVS     R0,#+0
   \   000000E2   0xBCF0             POP      {R4-R7}
   \   000000E4   0x4770             BX       LR
   1239            }
   1240            else
   1241            {
   1242              return HAL_BUSY;
   \                     ??HAL_SPI_TransmitReceive_IT_1: (+1)
   \   000000E6   0x2002             MOVS     R0,#+2
   \   000000E8   0xBCF0             POP      {R4-R7}
   \   000000EA   0x4770             BX       LR               ;; return
   1243            }
   1244          }
   1245          
   1246          /**
   1247            * @brief  Transmit an amount of data in no-blocking mode with DMA
   1248            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   1249            *               the configuration information for SPI module.
   1250            * @param  pData: pointer to data buffer
   1251            * @param  Size: amount of data to be sent
   1252            * @retval HAL status
   1253            */

   \                                 In section .text, align 2, keep-with-next
   1254          HAL_StatusTypeDef HAL_SPI_Transmit_DMA(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size)
   1255          {    
   \                     HAL_SPI_Transmit_DMA: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4605             MOV      R5,R0
   1256            assert_param(IS_SPI_DIRECTION_2LINES_OR_1LINE(hspi->Init.Direction));
   1257          
   1258            if(hspi->State != HAL_SPI_STATE_READY) 
   \   00000004   0xF105 0x0444      ADD      R4,R5,#+68
   \   00000008   0x7E60             LDRB     R0,[R4, #+25]
   \   0000000A   0x2801             CMP      R0,#+1
   \   0000000C   0xD106             BNE.N    ??HAL_SPI_Transmit_DMA_0
   1259            {
   1260              return HAL_BUSY;
   1261            }
   1262            
   1263            if((pData == NULL) || (Size == 0))
   \   0000000E   0x2900             CMP      R1,#+0
   \   00000010   0xBF18             IT       NE 
   \   00000012   0x2A00             CMPNE    R2,#+0
   \   00000014   0xD05E             BEQ.N    ??HAL_SPI_Transmit_DMA_1
   1264            {
   1265              return HAL_ERROR;
   1266            }
   1267            
   1268            /* Process Locked */
   1269            __HAL_LOCK(hspi);
   \   00000016   0x7E20             LDRB     R0,[R4, #+24]
   \   00000018   0x2801             CMP      R0,#+1
   \   0000001A   0xD101             BNE.N    ??HAL_SPI_Transmit_DMA_2
   \                     ??HAL_SPI_Transmit_DMA_0: (+1)
   \   0000001C   0x2002             MOVS     R0,#+2
   \   0000001E   0xBD32             POP      {R1,R4,R5,PC}
   \                     ??HAL_SPI_Transmit_DMA_2: (+1)
   \   00000020   0x2001             MOVS     R0,#+1
   \   00000022   0x7620             STRB     R0,[R4, #+24]
   1270            
   1271            hspi->State       = HAL_SPI_STATE_BUSY_TX;
   \   00000024   0x2003             MOVS     R0,#+3
   \   00000026   0x7660             STRB     R0,[R4, #+25]
   1272            hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0x61E0             STR      R0,[R4, #+28]
   1273            hspi->pTxBuffPtr  = pData;
   \   0000002C   0x63A9             STR      R1,[R5, #+56]
   1274            hspi->TxXferSize  = Size;
   \   0000002E   0x87AA             STRH     R2,[R5, #+60]
   1275            hspi->TxXferCount = Size;
   \   00000030   0x87EA             STRH     R2,[R5, #+62]
   1276            hspi->pRxBuffPtr  = (uint8_t *)NULL;
   \   00000032   0x6428             STR      R0,[R5, #+64]
   1277            hspi->RxXferSize  = 0;
   \   00000034   0x8020             STRH     R0,[R4, #+0]
   1278            hspi->RxXferCount = 0;
   \   00000036   0x8060             STRH     R0,[R4, #+2]
   1279            
   1280            /* Configure communication direction : 1Line */
   1281            if(hspi->Init.Direction == SPI_DIRECTION_1LINE)
   \   00000038   0x68A8             LDR      R0,[R5, #+8]
   \   0000003A   0x682A             LDR      R2,[R5, #+0]
   \   0000003C   0xF5B0 0x4F00      CMP      R0,#+32768
   \   00000040   0xD103             BNE.N    ??HAL_SPI_Transmit_DMA_3
   1282            {
   1283              SPI_1LINE_TX(hspi);
   \   00000042   0x6810             LDR      R0,[R2, #+0]
   \   00000044   0xF440 0x4080      ORR      R0,R0,#0x4000
   \   00000048   0x6010             STR      R0,[R2, #+0]
   1284            }
   1285            
   1286            /* Reset CRC Calculation */
   1287            if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   \                     ??HAL_SPI_Transmit_DMA_3: (+1)
   \   0000004A   0x6AA8             LDR      R0,[R5, #+40]
   \   0000004C   0xF5B0 0x5F00      CMP      R0,#+8192
   \   00000050   0xD108             BNE.N    ??HAL_SPI_Transmit_DMA_4
   1288            {
   1289              SPI_RESET_CRC(hspi);
   \   00000052   0x6810             LDR      R0,[R2, #+0]
   \   00000054   0xF64D 0x71FF      MOVW     R1,#+57343
   \   00000058   0x4008             ANDS     R0,R1,R0
   \   0000005A   0x6010             STR      R0,[R2, #+0]
   \   0000005C   0x6810             LDR      R0,[R2, #+0]
   \   0000005E   0xF440 0x5000      ORR      R0,R0,#0x2000
   \   00000062   0x6010             STR      R0,[R2, #+0]
   1290            }
   1291            
   1292            /* Set the SPI TxDMA Half transfer complete callback */
   1293            hspi->hdmatx->XferHalfCpltCallback = SPI_DMAHalfTransmitCplt;
   \                     ??HAL_SPI_Transmit_DMA_4: (+1)
   \   00000064   0x6920             LDR      R0,[R4, #+16]
   \   00000066   0x.... 0x....      ADR.W    R1,SPI_DMAHalfTransmitCplt
   \   0000006A   0x6401             STR      R1,[R0, #+64]
   1294            
   1295            /* Set the SPI TxDMA transfer complete callback */
   1296            hspi->hdmatx->XferCpltCallback = SPI_DMATransmitCplt;
   \   0000006C   0x.... 0x....      ADR.W    R1,SPI_DMATransmitCplt
   \   00000070   0x63C1             STR      R1,[R0, #+60]
   1297            
   1298            /* Set the DMA error callback */
   1299            hspi->hdmatx->XferErrorCallback = SPI_DMAError;
   \   00000072   0x.... 0x....      ADR.W    R1,SPI_DMAError
   \   00000076   0x6481             STR      R1,[R0, #+72]
   1300            
   1301            CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_LDMATX);
   \   00000078   0x6851             LDR      R1,[R2, #+4]
   \   0000007A   0xF421 0x4180      BIC      R1,R1,#0x4000
   \   0000007E   0x6051             STR      R1,[R2, #+4]
   1302            /* packing mode is enabled only if the DMA setting is HALWORD */
   1303            if((hspi->Init.DataSize <= SPI_DATASIZE_8BIT) && (hspi->hdmatx->Init.MemDataAlignment == DMA_MDATAALIGN_HALFWORD))
   \   00000080   0x68E9             LDR      R1,[R5, #+12]
   \   00000082   0x8FEB             LDRH     R3,[R5, #+62]
   \   00000084   0xF5B1 0x6FE0      CMP      R1,#+1792
   \   00000088   0xD810             BHI.N    ??HAL_SPI_Transmit_DMA_5
   \   0000008A   0x6981             LDR      R1,[R0, #+24]
   \   0000008C   0xF5B1 0x5F00      CMP      R1,#+8192
   \   00000090   0xD10C             BNE.N    ??HAL_SPI_Transmit_DMA_5
   1304            {
   1305              /* Check the even/odd of the data size + crc if enabled */
   1306              if((hspi->TxXferCount & 0x1) == 0)
   \   00000092   0x0859             LSRS     R1,R3,#+1
   \   00000094   0x07DB             LSLS     R3,R3,#+31
   \   00000096   0x6853             LDR      R3,[R2, #+4]
   \   00000098   0xD404             BMI.N    ??HAL_SPI_Transmit_DMA_6
   1307              {
   1308                CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_LDMATX);
   \   0000009A   0xF423 0x4380      BIC      R3,R3,#0x4000
   \   0000009E   0x6053             STR      R3,[R2, #+4]
   1309                hspi->TxXferCount = (hspi->TxXferCount >> 1);
   \   000000A0   0x460B             MOV      R3,R1
   \   000000A2   0xE003             B.N      ??HAL_SPI_Transmit_DMA_5
   1310              }
   1311              else
   1312              {
   1313                SET_BIT(hspi->Instance->CR2, SPI_CR2_LDMATX);
   \                     ??HAL_SPI_Transmit_DMA_6: (+1)
   \   000000A4   0xF443 0x4380      ORR      R3,R3,#0x4000
   \   000000A8   0x6053             STR      R3,[R2, #+4]
   1314                hspi->TxXferCount = (hspi->TxXferCount >> 1) + 1;
   \   000000AA   0x1C4B             ADDS     R3,R1,#+1
   \                     ??HAL_SPI_Transmit_DMA_5: (+1)
   \   000000AC   0x87EB             STRH     R3,[R5, #+62]
   1315              }
   1316            }
   1317            
   1318            /* Enable the Tx DMA channel */
   1319            HAL_DMA_Start_IT(hspi->hdmatx, (uint32_t)hspi->pTxBuffPtr, (uint32_t)&hspi->Instance->DR, hspi->TxXferCount);
   \   000000AE   0x8FEB             LDRH     R3,[R5, #+62]
   \   000000B0   0x6BA9             LDR      R1,[R5, #+56]
   \   000000B2   0x320C             ADDS     R2,R2,#+12
   \   000000B4   0x.... 0x....      BL       HAL_DMA_Start_IT
   1320            
   1321            /* Check if the SPI is already enabled */ 
   1322            if((hspi->Instance->CR1 &SPI_CR1_SPE) != SPI_CR1_SPE)
   \   000000B8   0x6828             LDR      R0,[R5, #+0]
   \   000000BA   0x6801             LDR      R1,[R0, #+0]
   \   000000BC   0x0649             LSLS     R1,R1,#+25
   \   000000BE   0xD403             BMI.N    ??HAL_SPI_Transmit_DMA_7
   1323            {
   1324              /* Enable SPI peripheral */    
   1325              __HAL_SPI_ENABLE(hspi);
   \   000000C0   0x6801             LDR      R1,[R0, #+0]
   \   000000C2   0xF041 0x0140      ORR      R1,R1,#0x40
   \   000000C6   0x6001             STR      R1,[R0, #+0]
   1326            }
   1327          
   1328            /* Enable Tx DMA Request */
   1329            hspi->Instance->CR2 |= SPI_CR2_TXDMAEN;
   \                     ??HAL_SPI_Transmit_DMA_7: (+1)
   \   000000C8   0x6841             LDR      R1,[R0, #+4]
   \   000000CA   0xF041 0x0102      ORR      R1,R1,#0x2
   \   000000CE   0x6041             STR      R1,[R0, #+4]
   1330            
   1331            /* Process Unlocked */
   1332            __HAL_UNLOCK(hspi);
   \   000000D0   0x2000             MOVS     R0,#+0
   \   000000D2   0x7620             STRB     R0,[R4, #+24]
   1333            
   1334            return HAL_OK;
   \                     ??HAL_SPI_Transmit_DMA_1: (+1)
   \   000000D4   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1335          }
   1336          
   1337          /**
   1338          * @brief  Receive an amount of data in no-blocking mode with DMA 
   1339          * @param  hspi: SPI handle
   1340          * @param  pData: pointer to data buffer
   1341          * @param  Size: amount of data to be sent
   1342          * @retval HAL status
   1343          */

   \                                 In section .text, align 2, keep-with-next
   1344          HAL_StatusTypeDef HAL_SPI_Receive_DMA(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size)
   1345          {
   \                     HAL_SPI_Receive_DMA: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   1346            if(hspi->State != HAL_SPI_STATE_READY)
   \   00000004   0xF104 0x0544      ADD      R5,R4,#+68
   \   00000008   0x7E68             LDRB     R0,[R5, #+25]
   \   0000000A   0x2801             CMP      R0,#+1
   \   0000000C   0xD106             BNE.N    ??HAL_SPI_Receive_DMA_0
   1347            {
   1348              return HAL_BUSY;
   1349            }
   1350            
   1351            if((pData == NULL) || (Size == 0))
   \   0000000E   0x2900             CMP      R1,#+0
   \   00000010   0xBF18             IT       NE 
   \   00000012   0x2A00             CMPNE    R2,#+0
   \   00000014   0xD070             BEQ.N    ??HAL_SPI_Receive_DMA_1
   1352            {
   1353              return HAL_ERROR;
   1354            }
   1355            
   1356            /* Process Locked */
   1357            __HAL_LOCK(hspi);
   \   00000016   0x7E28             LDRB     R0,[R5, #+24]
   \   00000018   0x2801             CMP      R0,#+1
   \   0000001A   0xD101             BNE.N    ??HAL_SPI_Receive_DMA_2
   \                     ??HAL_SPI_Receive_DMA_0: (+1)
   \   0000001C   0x2002             MOVS     R0,#+2
   \   0000001E   0xBD32             POP      {R1,R4,R5,PC}
   \                     ??HAL_SPI_Receive_DMA_2: (+1)
   \   00000020   0x2001             MOVS     R0,#+1
   \   00000022   0x7628             STRB     R0,[R5, #+24]
   1358          
   1359            hspi->State       = HAL_SPI_STATE_BUSY_RX;
   \   00000024   0x2004             MOVS     R0,#+4
   \   00000026   0x7668             STRB     R0,[R5, #+25]
   1360            hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0x61E8             STR      R0,[R5, #+28]
   1361            hspi->pRxBuffPtr  = pData;
   \   0000002C   0x6421             STR      R1,[R4, #+64]
   1362            hspi->RxXferSize  = Size;
   \   0000002E   0x802A             STRH     R2,[R5, #+0]
   1363            hspi->RxXferCount = Size;
   \   00000030   0x806A             STRH     R2,[R5, #+2]
   1364            hspi->pTxBuffPtr  = (uint8_t *)NULL;
   \   00000032   0x63A0             STR      R0,[R4, #+56]
   1365            hspi->TxXferSize  = 0;
   \   00000034   0x87A0             STRH     R0,[R4, #+60]
   1366            hspi->TxXferCount = 0;
   \   00000036   0x87E0             STRH     R0,[R4, #+62]
   1367          
   1368            if((hspi->Init.Mode == SPI_MODE_MASTER) && (hspi->Init.Direction == SPI_DIRECTION_2LINES))
   \   00000038   0x6860             LDR      R0,[R4, #+4]
   \   0000003A   0xF5B0 0x7F82      CMP      R0,#+260
   \   0000003E   0xBF04             ITT      EQ 
   \   00000040   0x68A0             LDREQ    R0,[R4, #+8]
   \   00000042   0x2800             CMPEQ    R0,#+0
   \   00000044   0xD107             BNE.N    ??HAL_SPI_Receive_DMA_3
   1369            {
   1370              /* Process Unlocked */
   1371              __HAL_UNLOCK(hspi);
   \   00000046   0x7628             STRB     R0,[R5, #+24]
   1372              /* the receive process is not supported in 2Lines direction master mode */
   1373              /* in this case we call the transmitReceive process                     */
   1374              return HAL_SPI_TransmitReceive_DMA(hspi,pData,pData,Size);
   \   00000048   0x4613             MOV      R3,R2
   \   0000004A   0x4620             MOV      R0,R4
   \   0000004C   0xB001             ADD      SP,SP,#+4
   \   0000004E   0x460A             MOV      R2,R1
   \   00000050   0xE8BD 0x4030      POP      {R4,R5,LR}
   \   00000054   0x....             B.N      HAL_SPI_TransmitReceive_DMA
   1375            }
   1376            
   1377            /* Configure communication direction : 1Line */
   1378            if(hspi->Init.Direction == SPI_DIRECTION_1LINE)
   \                     ??HAL_SPI_Receive_DMA_3: (+1)
   \   00000056   0x68A0             LDR      R0,[R4, #+8]
   \   00000058   0xF5B0 0x4F00      CMP      R0,#+32768
   \   0000005C   0xD104             BNE.N    ??HAL_SPI_Receive_DMA_4
   1379            {
   1380              SPI_1LINE_RX(hspi);
   \   0000005E   0x6821             LDR      R1,[R4, #+0]
   \   00000060   0x6808             LDR      R0,[R1, #+0]
   \   00000062   0xF420 0x4080      BIC      R0,R0,#0x4000
   \   00000066   0x6008             STR      R0,[R1, #+0]
   1381            }
   1382            
   1383            /* Reset CRC Calculation */
   1384            if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   \                     ??HAL_SPI_Receive_DMA_4: (+1)
   \   00000068   0x6AA0             LDR      R0,[R4, #+40]
   \   0000006A   0xF5B0 0x5F00      CMP      R0,#+8192
   \   0000006E   0xD109             BNE.N    ??HAL_SPI_Receive_DMA_5
   1385            {
   1386              SPI_RESET_CRC(hspi);
   \   00000070   0x6821             LDR      R1,[R4, #+0]
   \   00000072   0xF64D 0x72FF      MOVW     R2,#+57343
   \   00000076   0x6808             LDR      R0,[R1, #+0]
   \   00000078   0x4010             ANDS     R0,R2,R0
   \   0000007A   0x6008             STR      R0,[R1, #+0]
   \   0000007C   0x6808             LDR      R0,[R1, #+0]
   \   0000007E   0xF440 0x5000      ORR      R0,R0,#0x2000
   \   00000082   0x6008             STR      R0,[R1, #+0]
   1387            }
   1388            
   1389            /* packing mode management is enabled by the DMA settings */
   1390            if((hspi->Init.DataSize <= SPI_DATASIZE_8BIT) && (hspi->hdmarx->Init.MemDataAlignment == DMA_MDATAALIGN_HALFWORD))
   \                     ??HAL_SPI_Receive_DMA_5: (+1)
   \   00000084   0x68E1             LDR      R1,[R4, #+12]
   \   00000086   0xF240 0x7001      MOVW     R0,#+1793
   \   0000008A   0x4281             CMP      R1,R0
   \   0000008C   0xD208             BCS.N    ??HAL_SPI_Receive_DMA_6
   \   0000008E   0x6969             LDR      R1,[R5, #+20]
   \   00000090   0x6989             LDR      R1,[R1, #+24]
   \   00000092   0xF5B1 0x5F00      CMP      R1,#+8192
   \   00000096   0xD103             BNE.N    ??HAL_SPI_Receive_DMA_6
   1391            {
   1392              /* Process Locked */
   1393              __HAL_UNLOCK(hspi);
   \   00000098   0x2000             MOVS     R0,#+0
   \   0000009A   0x7628             STRB     R0,[R5, #+24]
   1394              /* Restriction the DMA data received is not allowed in this mode */
   1395              return HAL_ERROR;
   \   0000009C   0x2001             MOVS     R0,#+1
   \   0000009E   0xBD32             POP      {R1,R4,R5,PC}
   1396            }
   1397            
   1398            CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_LDMARX);
   \                     ??HAL_SPI_Receive_DMA_6: (+1)
   \   000000A0   0x6821             LDR      R1,[R4, #+0]
   \   000000A2   0x684A             LDR      R2,[R1, #+4]
   \   000000A4   0xF422 0x5200      BIC      R2,R2,#0x2000
   \   000000A8   0x604A             STR      R2,[R1, #+4]
   1399            if( hspi->Init.DataSize > SPI_DATASIZE_8BIT)
   \   000000AA   0x68E2             LDR      R2,[R4, #+12]
   \   000000AC   0x4282             CMP      R2,R0
   \   000000AE   0x6848             LDR      R0,[R1, #+4]
   1400            {
   1401              /* set fiforxthreshold according the reception data length: 16bit */
   1402              CLEAR_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
   1403            }
   1404            else
   1405            {
   1406              /* set fiforxthreshold according the reception data length: 8bit */
   1407              SET_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
   1408            }
   1409            
   1410            /* Set the SPI RxDMA Half transfer complete callback */
   1411            hspi->hdmarx->XferHalfCpltCallback = SPI_DMAHalfReceiveCplt;
   \   000000B0   0x.... 0x....      ADR.W    R2,SPI_DMAHalfReceiveCplt
   \   000000B4   0xBF2C             ITE      CS 
   \   000000B6   0xF420 0x5080      BICCS    R0,R0,#0x1000
   \   000000BA   0xF440 0x5080      ORRCC    R0,R0,#0x1000
   \   000000BE   0x6048             STR      R0,[R1, #+4]
   \   000000C0   0x6968             LDR      R0,[R5, #+20]
   \   000000C2   0x6402             STR      R2,[R0, #+64]
   1412          
   1413            /* Set the SPI Rx DMA transfer complete callback */
   1414            hspi->hdmarx->XferCpltCallback = SPI_DMAReceiveCplt;
   \   000000C4   0x.... 0x....      ADR.W    R2,SPI_DMAReceiveCplt
   \   000000C8   0x63C2             STR      R2,[R0, #+60]
   1415            
   1416            /* Set the DMA error callback */
   1417            hspi->hdmarx->XferErrorCallback = SPI_DMAError;
   \   000000CA   0x.... 0x....      ADR.W    R2,SPI_DMAError
   \   000000CE   0x6482             STR      R2,[R0, #+72]
   1418            
   1419            /* Enable Rx DMA Request */  
   1420            hspi->Instance->CR2 |= SPI_CR2_RXDMAEN;
   \   000000D0   0x684A             LDR      R2,[R1, #+4]
   \   000000D2   0xF042 0x0201      ORR      R2,R2,#0x1
   \   000000D6   0x604A             STR      R2,[R1, #+4]
   1421            
   1422            /* Enable the Rx DMA channel */
   1423            HAL_DMA_Start_IT(hspi->hdmarx, (uint32_t)&hspi->Instance->DR, (uint32_t)hspi->pRxBuffPtr, hspi->RxXferCount);
   \   000000D8   0x886B             LDRH     R3,[R5, #+2]
   \   000000DA   0x6C22             LDR      R2,[R4, #+64]
   \   000000DC   0x310C             ADDS     R1,R1,#+12
   \   000000DE   0x.... 0x....      BL       HAL_DMA_Start_IT
   1424            
   1425            /* Process Unlocked */
   1426            __HAL_UNLOCK(hspi);
   \   000000E2   0x2000             MOVS     R0,#+0
   \   000000E4   0x7628             STRB     R0,[R5, #+24]
   1427            
   1428            /* Check if the SPI is already enabled */ 
   1429            if((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
   \   000000E6   0x6820             LDR      R0,[R4, #+0]
   \   000000E8   0x6801             LDR      R1,[R0, #+0]
   \   000000EA   0x0649             LSLS     R1,R1,#+25
   \   000000EC   0xD403             BMI.N    ??HAL_SPI_Receive_DMA_7
   1430            {
   1431              /* Enable SPI peripheral */    
   1432              __HAL_SPI_ENABLE(hspi);
   \   000000EE   0x6801             LDR      R1,[R0, #+0]
   \   000000F0   0xF041 0x0140      ORR      R1,R1,#0x40
   \   000000F4   0x6001             STR      R1,[R0, #+0]
   1433            }
   1434            
   1435            return HAL_OK;
   \                     ??HAL_SPI_Receive_DMA_7: (+1)
   \   000000F6   0x2000             MOVS     R0,#+0
   \                     ??HAL_SPI_Receive_DMA_1: (+1)
   \   000000F8   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1436          }
   1437          
   1438          /**
   1439            * @brief  Transmit and Receive an amount of data in no-blocking mode with DMA
   1440            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   1441            *               the configuration information for SPI module.
   1442            * @param  pTxData: pointer to transmission data buffer
   1443            * @param  pRxData: pointer to reception data buffer
   1444            * @note  When the CRC feature is enabled the pRxData Length must be Size + 1
   1445            * @param  Size: amount of data to be sent
   1446            * @retval HAL status
   1447            */

   \                                 In section .text, align 2, keep-with-next
   1448          HAL_StatusTypeDef HAL_SPI_TransmitReceive_DMA(SPI_HandleTypeDef *hspi, uint8_t *pTxData, uint8_t *pRxData, uint16_t Size)
   1449          {
   \                     HAL_SPI_TransmitReceive_DMA: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   1450            assert_param(IS_SPI_DIRECTION_2LINES(hspi->Init.Direction));
   1451            
   1452            if((hspi->State == HAL_SPI_STATE_READY) ||
   1453               ((hspi->Init.Mode == SPI_MODE_MASTER) && (hspi->Init.Direction == SPI_DIRECTION_2LINES) && (hspi->State == HAL_SPI_STATE_BUSY_RX)))
   \   00000004   0xF104 0x0544      ADD      R5,R4,#+68
   \   00000008   0x7E68             LDRB     R0,[R5, #+25]
   \   0000000A   0x2801             CMP      R0,#+1
   \   0000000C   0xD008             BEQ.N    ??HAL_SPI_TransmitReceive_DMA_0
   \   0000000E   0x6866             LDR      R6,[R4, #+4]
   \   00000010   0xF5B6 0x7F82      CMP      R6,#+260
   \   00000014   0xBF02             ITTT     EQ 
   \   00000016   0x68A6             LDREQ    R6,[R4, #+8]
   \   00000018   0x2E00             CMPEQ    R6,#+0
   \   0000001A   0x2804             CMPEQ    R0,#+4
   \   0000001C   0xF040 0x80A7      BNE.W    ??HAL_SPI_TransmitReceive_DMA_1
   1454            {
   1455              if((pTxData == NULL ) || (pRxData == NULL ) || (Size == 0)) 
   \                     ??HAL_SPI_TransmitReceive_DMA_0: (+1)
   \   00000020   0x2900             CMP      R1,#+0
   \   00000022   0xBF18             IT       NE 
   \   00000024   0x2A00             CMPNE    R2,#+0
   \   00000026   0xD000             BEQ.N    ??HAL_SPI_TransmitReceive_DMA_2
   \   00000028   0xB90B             CBNZ.N   R3,??HAL_SPI_TransmitReceive_DMA_3
   1456              {
   1457                return  HAL_ERROR;                                    
   \                     ??HAL_SPI_TransmitReceive_DMA_2: (+1)
   \   0000002A   0x2001             MOVS     R0,#+1
   \   0000002C   0xBD70             POP      {R4-R6,PC}
   1458              }
   1459              
   1460              /* Process locked */
   1461              __HAL_LOCK(hspi);
   \                     ??HAL_SPI_TransmitReceive_DMA_3: (+1)
   \   0000002E   0x7E2E             LDRB     R6,[R5, #+24]
   \   00000030   0x2E01             CMP      R6,#+1
   \   00000032   0xF000 0x809C      BEQ.W    ??HAL_SPI_TransmitReceive_DMA_1
   \   00000036   0x2601             MOVS     R6,#+1
   1462              
   1463              /* check if the transmit Receive function is not called by a receive master */
   1464              if(hspi->State != HAL_SPI_STATE_BUSY_RX)
   \   00000038   0x2804             CMP      R0,#+4
   \   0000003A   0x762E             STRB     R6,[R5, #+24]
   \   0000003C   0xBF1C             ITT      NE 
   \   0000003E   0x2005             MOVNE    R0,#+5
   \   00000040   0x7668             STRBNE   R0,[R5, #+25]
   1465              {  
   1466                hspi->State = HAL_SPI_STATE_BUSY_TX_RX;
   1467              }
   1468              
   1469              hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0x61E8             STR      R0,[R5, #+28]
   1470              hspi->pTxBuffPtr  = (uint8_t *)pTxData;
   \   00000046   0x63A1             STR      R1,[R4, #+56]
   1471              hspi->TxXferSize  = Size;
   \   00000048   0x87A3             STRH     R3,[R4, #+60]
   1472              hspi->TxXferCount = Size;
   \   0000004A   0x87E3             STRH     R3,[R4, #+62]
   1473              hspi->pRxBuffPtr  = (uint8_t *)pRxData;
   \   0000004C   0x6422             STR      R2,[R4, #+64]
   1474              hspi->RxXferSize  = Size;
   \   0000004E   0x802B             STRH     R3,[R5, #+0]
   1475              hspi->RxXferCount = Size;
   \   00000050   0x806B             STRH     R3,[R5, #+2]
   1476              
   1477              /* Reset CRC Calculation + increase the rxsize */
   1478              if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   \   00000052   0x6AA0             LDR      R0,[R4, #+40]
   \   00000054   0x6821             LDR      R1,[R4, #+0]
   \   00000056   0xF5B0 0x5F00      CMP      R0,#+8192
   \   0000005A   0xD108             BNE.N    ??HAL_SPI_TransmitReceive_DMA_4
   1479              {
   1480                SPI_RESET_CRC(hspi);
   \   0000005C   0x6808             LDR      R0,[R1, #+0]
   \   0000005E   0xF64D 0x72FF      MOVW     R2,#+57343
   \   00000062   0x4010             ANDS     R0,R2,R0
   \   00000064   0x6008             STR      R0,[R1, #+0]
   \   00000066   0x6808             LDR      R0,[R1, #+0]
   \   00000068   0xF440 0x5000      ORR      R0,R0,#0x2000
   \   0000006C   0x6008             STR      R0,[R1, #+0]
   1481              }
   1482              
   1483              /* Reset the threshold bit */
   1484              CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_LDMATX);
   \                     ??HAL_SPI_TransmitReceive_DMA_4: (+1)
   \   0000006E   0x6848             LDR      R0,[R1, #+4]
   \   00000070   0xF420 0x4080      BIC      R0,R0,#0x4000
   \   00000074   0x6048             STR      R0,[R1, #+4]
   1485              CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_LDMARX);
   \   00000076   0x6848             LDR      R0,[R1, #+4]
   \   00000078   0xF420 0x5000      BIC      R0,R0,#0x2000
   \   0000007C   0x6048             STR      R0,[R1, #+4]
   1486              
   1487              /* the packing mode management is enabled by the DMA settings according the spi data size */
   1488              if(hspi->Init.DataSize > SPI_DATASIZE_8BIT)
   \   0000007E   0x68E0             LDR      R0,[R4, #+12]
   \   00000080   0xF5B0 0x6FE0      CMP      R0,#+1792
   \   00000084   0x6848             LDR      R0,[R1, #+4]
   \   00000086   0xD903             BLS.N    ??HAL_SPI_TransmitReceive_DMA_5
   1489              {
   1490                /* set fiforxthreshold according the reception data length: 16bit */
   1491                CLEAR_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
   \   00000088   0xF420 0x5080      BIC      R0,R0,#0x1000
   \   0000008C   0x6048             STR      R0,[R1, #+4]
   \   0000008E   0xE031             B.N      ??HAL_SPI_TransmitReceive_DMA_6
   1492              }
   1493              else
   1494              {
   1495                /* set fiforxthreshold according the reception data length: 8bit */
   1496                SET_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
   \                     ??HAL_SPI_TransmitReceive_DMA_5: (+1)
   \   00000090   0xF440 0x5080      ORR      R0,R0,#0x1000
   \   00000094   0x6048             STR      R0,[R1, #+4]
   1497                
   1498                if(hspi->hdmatx->Init.MemDataAlignment == DMA_MDATAALIGN_HALFWORD)
   \   00000096   0x6928             LDR      R0,[R5, #+16]
   \   00000098   0x6980             LDR      R0,[R0, #+24]
   \   0000009A   0xF5B0 0x5F00      CMP      R0,#+8192
   \   0000009E   0xD111             BNE.N    ??HAL_SPI_TransmitReceive_DMA_7
   1499                {
   1500                  if((hspi->TxXferSize & 0x1) == 0x0 )
   \   000000A0   0xF894 0x003C      LDRB     R0,[R4, #+60]
   \   000000A4   0x07C0             LSLS     R0,R0,#+31
   \   000000A6   0x6848             LDR      R0,[R1, #+4]
   \   000000A8   0xD405             BMI.N    ??HAL_SPI_TransmitReceive_DMA_8
   1501                  {
   1502                    CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_LDMATX);
   \   000000AA   0xF420 0x4080      BIC      R0,R0,#0x4000
   \   000000AE   0x6048             STR      R0,[R1, #+4]
   1503                    hspi->TxXferCount = hspi->TxXferCount >> 1;
   \   000000B0   0x8FE0             LDRH     R0,[R4, #+62]
   \   000000B2   0x0840             LSRS     R0,R0,#+1
   \   000000B4   0xE005             B.N      ??HAL_SPI_TransmitReceive_DMA_9
   1504                  }
   1505                  else
   1506                  {
   1507                    SET_BIT(hspi->Instance->CR2, SPI_CR2_LDMATX);
   \                     ??HAL_SPI_TransmitReceive_DMA_8: (+1)
   \   000000B6   0xF440 0x4080      ORR      R0,R0,#0x4000
   \   000000BA   0x6048             STR      R0,[R1, #+4]
   1508                    hspi->TxXferCount = (hspi->TxXferCount >> 1) + 1;
   \   000000BC   0x8FE0             LDRH     R0,[R4, #+62]
   \   000000BE   0x0840             LSRS     R0,R0,#+1
   \   000000C0   0x1C40             ADDS     R0,R0,#+1
   \                     ??HAL_SPI_TransmitReceive_DMA_9: (+1)
   \   000000C2   0x87E0             STRH     R0,[R4, #+62]
   1509                  }      
   1510                }
   1511                
   1512                if(hspi->hdmarx->Init.MemDataAlignment == DMA_MDATAALIGN_HALFWORD)
   \                     ??HAL_SPI_TransmitReceive_DMA_7: (+1)
   \   000000C4   0x6968             LDR      R0,[R5, #+20]
   \   000000C6   0x6980             LDR      R0,[R0, #+24]
   \   000000C8   0xF5B0 0x5F00      CMP      R0,#+8192
   \   000000CC   0xD112             BNE.N    ??HAL_SPI_TransmitReceive_DMA_6
   1513                {
   1514                  /* set fiforxthreshold according the reception data length: 16bit */
   1515                  CLEAR_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
   \   000000CE   0x6848             LDR      R0,[R1, #+4]
   \   000000D0   0xF420 0x5080      BIC      R0,R0,#0x1000
   \   000000D4   0x6048             STR      R0,[R1, #+4]
   1516                  
   1517                  /* Size must include the CRC length */
   1518                  if((hspi->RxXferCount & 0x1) == 0x0 )
   \   000000D6   0x8868             LDRH     R0,[R5, #+2]
   \   000000D8   0x07C2             LSLS     R2,R0,#+31
   \   000000DA   0x684A             LDR      R2,[R1, #+4]
   \   000000DC   0xD404             BMI.N    ??HAL_SPI_TransmitReceive_DMA_10
   1519                  {
   1520                    CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_LDMARX);
   \   000000DE   0xF422 0x5200      BIC      R2,R2,#0x2000
   1521                    hspi->RxXferCount = hspi->RxXferCount >> 1;
   \   000000E2   0x0840             LSRS     R0,R0,#+1
   \   000000E4   0x604A             STR      R2,[R1, #+4]
   \   000000E6   0xE004             B.N      ??HAL_SPI_TransmitReceive_DMA_11
   1522                  }
   1523                  else
   1524                  {
   1525                    SET_BIT(hspi->Instance->CR2, SPI_CR2_LDMARX);
   \                     ??HAL_SPI_TransmitReceive_DMA_10: (+1)
   \   000000E8   0xF442 0x5200      ORR      R2,R2,#0x2000
   1526                    hspi->RxXferCount = (hspi->RxXferCount >> 1) + 1; 
   \   000000EC   0x0840             LSRS     R0,R0,#+1
   \   000000EE   0x604A             STR      R2,[R1, #+4]
   \   000000F0   0x1C40             ADDS     R0,R0,#+1
   \                     ??HAL_SPI_TransmitReceive_DMA_11: (+1)
   \   000000F2   0x8068             STRH     R0,[R5, #+2]
   1527                  } 
   1528                }
   1529              }   
   1530              
   1531              /* Set the SPI Rx DMA transfer complete callback because the last generated transfer request is 
   1532              the reception request (RXNE) */
   1533              if(hspi->State == HAL_SPI_STATE_BUSY_RX)
   \                     ??HAL_SPI_TransmitReceive_DMA_6: (+1)
   \   000000F4   0x7E6A             LDRB     R2,[R5, #+25]
   \   000000F6   0x6968             LDR      R0,[R5, #+20]
   \   000000F8   0x2A04             CMP      R2,#+4
   \   000000FA   0xD105             BNE.N    ??HAL_SPI_TransmitReceive_DMA_12
   1534              {			
   1535                hspi->hdmarx->XferHalfCpltCallback = SPI_DMAHalfReceiveCplt;
   \   000000FC   0x.... 0x....      ADR.W    R2,SPI_DMAHalfReceiveCplt
   \   00000100   0x6402             STR      R2,[R0, #+64]
   1536                hspi->hdmarx->XferCpltCallback = SPI_DMAReceiveCplt;
   \   00000102   0x.... 0x....      ADR.W    R2,SPI_DMAReceiveCplt
   \   00000106   0xE004             B.N      ??HAL_SPI_TransmitReceive_DMA_13
   1537              }
   1538              else
   1539              {	
   1540                 hspi->hdmarx->XferHalfCpltCallback = SPI_DMAHalfTransmitReceiveCplt;
   \                     ??HAL_SPI_TransmitReceive_DMA_12: (+1)
   \   00000108   0x.... 0x....      ADR.W    R2,SPI_DMAHalfTransmitReceiveCplt
   \   0000010C   0x6402             STR      R2,[R0, #+64]
   1541                hspi->hdmarx->XferCpltCallback = SPI_DMATransmitReceiveCplt;
   \   0000010E   0x.... 0x....      ADR.W    R2,SPI_DMATransmitReceiveCplt
   1542              }
   1543              /* Set the DMA error callback */
   1544              hspi->hdmarx->XferErrorCallback = SPI_DMAError;
   \                     ??HAL_SPI_TransmitReceive_DMA_13: (+1)
   \   00000112   0x.... 0x....      ADR.W    R6,SPI_DMAError
   \   00000116   0x63C2             STR      R2,[R0, #+60]
   \   00000118   0x6486             STR      R6,[R0, #+72]
   1545              
   1546              /* Enable Rx DMA Request */  
   1547              hspi->Instance->CR2 |= SPI_CR2_RXDMAEN;
   \   0000011A   0x684A             LDR      R2,[R1, #+4]
   \   0000011C   0xF042 0x0201      ORR      R2,R2,#0x1
   \   00000120   0x604A             STR      R2,[R1, #+4]
   1548              
   1549              /* Enable the Rx DMA channel */
   1550              HAL_DMA_Start_IT(hspi->hdmarx, (uint32_t)&hspi->Instance->DR, (uint32_t) hspi->pRxBuffPtr, hspi->RxXferCount);
   \   00000122   0x886B             LDRH     R3,[R5, #+2]
   \   00000124   0x6C22             LDR      R2,[R4, #+64]
   \   00000126   0x310C             ADDS     R1,R1,#+12
   \   00000128   0x.... 0x....      BL       HAL_DMA_Start_IT
   1551              
   1552              /* Set the SPI Tx DMA transfer complete callback as NULL because the communication closing
   1553              is performed in DMA reception complete callback  */
   1554              hspi->hdmatx->XferHalfCpltCallback = NULL;
   \   0000012C   0x6928             LDR      R0,[R5, #+16]
   \   0000012E   0x2100             MOVS     R1,#+0
   \   00000130   0x6401             STR      R1,[R0, #+64]
   1555              hspi->hdmatx->XferCpltCallback = NULL;
   \   00000132   0x63C1             STR      R1,[R0, #+60]
   1556          
   1557              if(hspi->State == HAL_SPI_STATE_BUSY_TX_RX)
   \   00000134   0x7E69             LDRB     R1,[R5, #+25]
   \   00000136   0x2905             CMP      R1,#+5
   \   00000138   0xBF0E             ITEE     EQ 
   \   0000013A   0x6486             STREQ    R6,[R0, #+72]
   \   0000013C   0x2100             MOVNE    R1,#+0
   \   0000013E   0x6481             STRNE    R1,[R0, #+72]
   1558              {
   1559                /* Set the DMA error callback */
   1560                hspi->hdmatx->XferErrorCallback = SPI_DMAError;
   1561              }
   1562              else
   1563              {
   1564                hspi->hdmatx->XferErrorCallback = NULL;
   1565              } 
   1566              
   1567              /* Enable the Tx DMA channel */
   1568              HAL_DMA_Start_IT(hspi->hdmatx, (uint32_t)hspi->pTxBuffPtr, (uint32_t)&hspi->Instance->DR, hspi->TxXferCount);
   \   00000140   0x6821             LDR      R1,[R4, #+0]
   \   00000142   0x8FE3             LDRH     R3,[R4, #+62]
   \   00000144   0xF101 0x020C      ADD      R2,R1,#+12
   \   00000148   0x6BA1             LDR      R1,[R4, #+56]
   \   0000014A   0x.... 0x....      BL       HAL_DMA_Start_IT
   1569          
   1570              /* Process Unlocked */
   1571              __HAL_UNLOCK(hspi);
   \   0000014E   0x2000             MOVS     R0,#+0
   \   00000150   0x7628             STRB     R0,[R5, #+24]
   1572                  
   1573              /* Check if the SPI is already enabled */ 
   1574              if((hspi->Instance->CR1 &SPI_CR1_SPE) != SPI_CR1_SPE)
   \   00000152   0x6820             LDR      R0,[R4, #+0]
   \   00000154   0x6801             LDR      R1,[R0, #+0]
   \   00000156   0x0649             LSLS     R1,R1,#+25
   \   00000158   0xD403             BMI.N    ??HAL_SPI_TransmitReceive_DMA_14
   1575              {
   1576                /* Enable SPI peripheral */    
   1577                __HAL_SPI_ENABLE(hspi);
   \   0000015A   0x6801             LDR      R1,[R0, #+0]
   \   0000015C   0xF041 0x0140      ORR      R1,R1,#0x40
   \   00000160   0x6001             STR      R1,[R0, #+0]
   1578              }
   1579              
   1580              /* Enable Tx DMA Request */  
   1581              hspi->Instance->CR2 |= SPI_CR2_TXDMAEN;
   \                     ??HAL_SPI_TransmitReceive_DMA_14: (+1)
   \   00000162   0x6841             LDR      R1,[R0, #+4]
   \   00000164   0xF041 0x0102      ORR      R1,R1,#0x2
   \   00000168   0x6041             STR      R1,[R0, #+4]
   1582                  
   1583              return HAL_OK;
   \   0000016A   0x2000             MOVS     R0,#+0
   \   0000016C   0xBD70             POP      {R4-R6,PC}
   1584            }
   1585            else
   1586            {
   1587              return HAL_BUSY;
   \                     ??HAL_SPI_TransmitReceive_DMA_1: (+1)
   \   0000016E   0x2002             MOVS     R0,#+2
   \   00000170   0xBD70             POP      {R4-R6,PC}       ;; return
   1588            }
   1589          }
   1590          
   1591          /**
   1592            * @brief Pauses the DMA Transfer.
   1593            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   1594            *               the configuration information for the specified SPI module.
   1595            * @retval HAL status
   1596            */

   \                                 In section .text, align 2, keep-with-next
   1597          HAL_StatusTypeDef HAL_SPI_DMAPause(SPI_HandleTypeDef *hspi)
   1598          {
   1599            /* Process Locked */
   1600            __HAL_LOCK(hspi);
   \                     HAL_SPI_DMAPause: (+1)
   \   00000000   0xF890 0x105C      LDRB     R1,[R0, #+92]
   \   00000004   0x2901             CMP      R1,#+1
   \   00000006   0xD101             BNE.N    ??HAL_SPI_DMAPause_0
   \   00000008   0x2002             MOVS     R0,#+2
   \   0000000A   0x4770             BX       LR
   \                     ??HAL_SPI_DMAPause_0: (+1)
   \   0000000C   0x2101             MOVS     R1,#+1
   \   0000000E   0xF880 0x105C      STRB     R1,[R0, #+92]
   1601          
   1602            /* Disable the SPI DMA Tx & Rx requests */
   1603            CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);
   \   00000012   0x6801             LDR      R1,[R0, #+0]
   \   00000014   0x684A             LDR      R2,[R1, #+4]
   \   00000016   0x0892             LSRS     R2,R2,#+2
   \   00000018   0x0092             LSLS     R2,R2,#+2
   \   0000001A   0x....             B.N      ?Subroutine3
   1604          
   1605            /* Process Unlocked */
   1606            __HAL_UNLOCK(hspi);
   1607          
   1608            return HAL_OK;
   1609          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine3: (+1)
   \   00000000   0x604A             STR      R2,[R1, #+4]
   \   00000002   0x2100             MOVS     R1,#+0
   \   00000004   0xF880 0x105C      STRB     R1,[R0, #+92]
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x4770             BX       LR               ;; return
   1610          
   1611          /**
   1612            * @brief Resumes the DMA Transfer.
   1613            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   1614            *               the configuration information for the specified SPI module.
   1615            * @retval HAL status
   1616            */

   \                                 In section .text, align 2, keep-with-next
   1617          HAL_StatusTypeDef HAL_SPI_DMAResume(SPI_HandleTypeDef *hspi)
   1618          {
   1619            /* Process Locked */
   1620            __HAL_LOCK(hspi);
   \                     HAL_SPI_DMAResume: (+1)
   \   00000000   0xF890 0x105C      LDRB     R1,[R0, #+92]
   \   00000004   0x2901             CMP      R1,#+1
   \   00000006   0xD101             BNE.N    ??HAL_SPI_DMAResume_0
   \   00000008   0x2002             MOVS     R0,#+2
   \   0000000A   0x4770             BX       LR
   \                     ??HAL_SPI_DMAResume_0: (+1)
   \   0000000C   0x2101             MOVS     R1,#+1
   \   0000000E   0xF880 0x105C      STRB     R1,[R0, #+92]
   1621          
   1622            /* Enable the SPI DMA Tx & Rx requests */
   1623            SET_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);
   \   00000012   0x6801             LDR      R1,[R0, #+0]
   \   00000014   0x684A             LDR      R2,[R1, #+4]
   \   00000016   0xF042 0x0203      ORR      R2,R2,#0x3
   \   0000001A                      REQUIRE ?Subroutine3
   \   0000001A                      ;; // Fall through to label ?Subroutine3
   1624          
   1625            /* Process Unlocked */
   1626            __HAL_UNLOCK(hspi);
   1627          
   1628            return HAL_OK;
   1629          }
   1630          
   1631          /**
   1632            * @brief Stops the DMA Transfer.
   1633            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   1634            *               the configuration information for the specified SPI module.
   1635            * @retval HAL status
   1636            */

   \                                 In section .text, align 2, keep-with-next
   1637          HAL_StatusTypeDef HAL_SPI_DMAStop(SPI_HandleTypeDef *hspi)
   1638          {
   \                     HAL_SPI_DMAStop: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   1639            /* The Lock is not implemented on this API to allow the user application
   1640               to call the HAL SPI API under callbacks HAL_SPI_TxCpltCallback() or HAL_SPI_RxCpltCallback() or HAL_SPI_TxRxCpltCallback():
   1641               when calling HAL_DMA_Abort() API the DMA TX/RX Transfer complete interrupt is generated
   1642               and the correspond call back is executed HAL_SPI_TxCpltCallback() or HAL_SPI_RxCpltCallback() or HAL_SPI_TxRxCpltCallback()
   1643               */
   1644            
   1645            /* Abort the SPI DMA tx Stream */
   1646            if(hspi->hdmatx != NULL)
   \   00000004   0x6D60             LDR      R0,[R4, #+84]
   \   00000006   0xB108             CBZ.N    R0,??HAL_SPI_DMAStop_0
   1647            {
   1648              HAL_DMA_Abort(hspi->hdmatx);
   \   00000008   0x.... 0x....      BL       HAL_DMA_Abort
   1649            }
   1650            /* Abort the SPI DMA rx Stream */
   1651            if(hspi->hdmarx != NULL)
   \                     ??HAL_SPI_DMAStop_0: (+1)
   \   0000000C   0x6DA0             LDR      R0,[R4, #+88]
   \   0000000E   0xB108             CBZ.N    R0,??HAL_SPI_DMAStop_1
   1652            {
   1653              HAL_DMA_Abort(hspi->hdmarx);
   \   00000010   0x.... 0x....      BL       HAL_DMA_Abort
   1654            }
   1655          
   1656            /* Disable the SPI DMA Tx & Rx requests */
   1657            CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);
   \                     ??HAL_SPI_DMAStop_1: (+1)
   \   00000014   0x6820             LDR      R0,[R4, #+0]
   \   00000016   0x6841             LDR      R1,[R0, #+4]
   \   00000018   0x0889             LSRS     R1,R1,#+2
   \   0000001A   0x0089             LSLS     R1,R1,#+2
   \   0000001C   0x6041             STR      R1,[R0, #+4]
   1658            hspi->State = HAL_SPI_STATE_READY;
   \   0000001E   0x2001             MOVS     R0,#+1
   \   00000020   0xF884 0x005D      STRB     R0,[R4, #+93]
   1659            return HAL_OK;
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0xBD10             POP      {R4,PC}          ;; return
   1660          }
   1661          
   1662          /**
   1663            * @brief  This function handles SPI interrupt request.
   1664            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   1665            *               the configuration information for the specified SPI module.
   1666            * @retval None
   1667            */

   \                                 In section .text, align 2, keep-with-next
   1668          void HAL_SPI_IRQHandler(SPI_HandleTypeDef *hspi)
   1669          {
   \                     HAL_SPI_IRQHandler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1670            /* SPI in mode Receiver ----------------------------------------------------*/
   1671            if((__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_OVR) == RESET) &&
   1672               (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_RXNE) != RESET) && (__HAL_SPI_GET_IT_SOURCE(hspi, SPI_IT_RXNE) != RESET))
   \   00000002   0x6801             LDR      R1,[R0, #+0]
   \   00000004   0x688A             LDR      R2,[R1, #+8]
   \   00000006   0x0652             LSLS     R2,R2,#+25
   \   00000008   0xD409             BMI.N    ??HAL_SPI_IRQHandler_0
   \   0000000A   0x688A             LDR      R2,[R1, #+8]
   \   0000000C   0x07D2             LSLS     R2,R2,#+31
   \   0000000E   0xD506             BPL.N    ??HAL_SPI_IRQHandler_0
   \   00000010   0x684A             LDR      R2,[R1, #+4]
   \   00000012   0x0652             LSLS     R2,R2,#+25
   \   00000014   0xD503             BPL.N    ??HAL_SPI_IRQHandler_0
   1673            {
   1674              hspi->RxISR(hspi);
   \   00000016   0x6CC1             LDR      R1,[R0, #+76]
   \   00000018   0xE8BD 0x4004      POP      {R2,LR}
   \   0000001C   0x4708             BX       R1
   1675              return;
   1676            }
   1677            
   1678            /* SPI in mode Transmitter ---------------------------------------------------*/
   1679            if((__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE) != RESET) && (__HAL_SPI_GET_IT_SOURCE(hspi, SPI_IT_TXE) != RESET))
   \                     ??HAL_SPI_IRQHandler_0: (+1)
   \   0000001E   0x688A             LDR      R2,[R1, #+8]
   \   00000020   0x0792             LSLS     R2,R2,#+30
   \   00000022   0xD506             BPL.N    ??HAL_SPI_IRQHandler_1
   \   00000024   0x684A             LDR      R2,[R1, #+4]
   \   00000026   0x0612             LSLS     R2,R2,#+24
   \   00000028   0xD503             BPL.N    ??HAL_SPI_IRQHandler_1
   1680            {   
   1681              hspi->TxISR(hspi);
   \   0000002A   0x6D01             LDR      R1,[R0, #+80]
   \   0000002C   0xE8BD 0x4004      POP      {R2,LR}
   \   00000030   0x4708             BX       R1
   1682              return;
   1683            }
   1684            
   1685            /* SPI in ERROR Treatment ---------------------------------------------------*/
   1686            if((hspi->Instance->SR & (SPI_FLAG_MODF | SPI_FLAG_OVR | SPI_FLAG_FRE)) != RESET)  
   \                     ??HAL_SPI_IRQHandler_1: (+1)
   \   00000032   0x688A             LDR      R2,[R1, #+8]
   \   00000034   0xF412 0x7FB0      TST      R2,#0x160
   \   00000038   0xD036             BEQ.N    ??HAL_SPI_IRQHandler_2
   1687            {
   1688              /* SPI Overrun error interrupt occurred -------------------------------------*/
   1689              if(__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_OVR) != RESET) 
   \   0000003A   0x688A             LDR      R2,[R1, #+8]
   \   0000003C   0x0652             LSLS     R2,R2,#+25
   \   0000003E   0xD50E             BPL.N    ??HAL_SPI_IRQHandler_3
   1690              {
   1691                if(hspi->State != HAL_SPI_STATE_BUSY_TX)
   \   00000040   0xF890 0x205D      LDRB     R2,[R0, #+93]
   \   00000044   0x2A03             CMP      R2,#+3
   \   00000046   0xD02F             BEQ.N    ??HAL_SPI_IRQHandler_2
   1692                {
   1693                  hspi->ErrorCode |= HAL_SPI_ERROR_OVR;
   \   00000048   0x6E02             LDR      R2,[R0, #+96]
   \   0000004A   0xF042 0x0204      ORR      R2,R2,#0x4
   \   0000004E   0x6602             STR      R2,[R0, #+96]
   1694                  __HAL_SPI_CLEAR_OVRFLAG(hspi);
   \   00000050   0x2200             MOVS     R2,#+0
   \   00000052   0x9200             STR      R2,[SP, #+0]
   \   00000054   0x68CA             LDR      R2,[R1, #+12]
   \   00000056   0x9200             STR      R2,[SP, #+0]
   \   00000058   0x688A             LDR      R2,[R1, #+8]
   \   0000005A   0x9200             STR      R2,[SP, #+0]
   \   0000005C   0x9A00             LDR      R2,[SP, #+0]
   1695                }
   1696                else
   1697                {
   1698                  return;
   1699                }
   1700              }
   1701              
   1702              /* SPI Mode Fault error interrupt occurred -------------------------------------*/
   1703              if(__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_MODF) != RESET)
   \                     ??HAL_SPI_IRQHandler_3: (+1)
   \   0000005E   0x688A             LDR      R2,[R1, #+8]
   \   00000060   0x0692             LSLS     R2,R2,#+26
   \   00000062   0xD50C             BPL.N    ??HAL_SPI_IRQHandler_4
   1704              { 
   1705                hspi->ErrorCode |= HAL_SPI_ERROR_MODF;
   \   00000064   0x6E02             LDR      R2,[R0, #+96]
   \   00000066   0xF042 0x0201      ORR      R2,R2,#0x1
   \   0000006A   0x6602             STR      R2,[R0, #+96]
   1706                __HAL_SPI_CLEAR_MODFFLAG(hspi);
   \   0000006C   0x2200             MOVS     R2,#+0
   \   0000006E   0x9200             STR      R2,[SP, #+0]
   \   00000070   0x688A             LDR      R2,[R1, #+8]
   \   00000072   0x9200             STR      R2,[SP, #+0]
   \   00000074   0x680A             LDR      R2,[R1, #+0]
   \   00000076   0xF022 0x0240      BIC      R2,R2,#0x40
   \   0000007A   0x600A             STR      R2,[R1, #+0]
   \   0000007C   0x9A00             LDR      R2,[SP, #+0]
   1707              }
   1708              
   1709              /* SPI Frame error interrupt occurred ----------------------------------------*/
   1710              if(__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_FRE) != RESET)
   \                     ??HAL_SPI_IRQHandler_4: (+1)
   \   0000007E   0x688A             LDR      R2,[R1, #+8]
   \   00000080   0x05D2             LSLS     R2,R2,#+23
   \   00000082   0xD508             BPL.N    ??HAL_SPI_IRQHandler_5
   1711              { 
   1712                hspi->ErrorCode |= HAL_SPI_ERROR_FRE;
   \   00000084   0x6E02             LDR      R2,[R0, #+96]
   \   00000086   0xF042 0x0208      ORR      R2,R2,#0x8
   \   0000008A   0x6602             STR      R2,[R0, #+96]
   1713                __HAL_SPI_CLEAR_FREFLAG(hspi);
   \   0000008C   0x2200             MOVS     R2,#+0
   \   0000008E   0x9200             STR      R2,[SP, #+0]
   \   00000090   0x688A             LDR      R2,[R1, #+8]
   \   00000092   0x9200             STR      R2,[SP, #+0]
   \   00000094   0x9A00             LDR      R2,[SP, #+0]
   1714              }
   1715              
   1716              __HAL_SPI_DISABLE_IT(hspi, SPI_IT_RXNE | SPI_IT_TXE | SPI_IT_ERR);
   \                     ??HAL_SPI_IRQHandler_5: (+1)
   \   00000096   0x684A             LDR      R2,[R1, #+4]
   \   00000098   0xF022 0x02E0      BIC      R2,R2,#0xE0
   \   0000009C   0x604A             STR      R2,[R1, #+4]
   1717              hspi->State = HAL_SPI_STATE_READY;
   \   0000009E   0x2101             MOVS     R1,#+1
   \   000000A0   0xF880 0x105D      STRB     R1,[R0, #+93]
   1718              HAL_SPI_ErrorCallback(hspi);
   \   000000A4   0x.... 0x....      BL       HAL_SPI_ErrorCallback
   1719              
   1720              return;
   1721            }
   1722          }
   \                     ??HAL_SPI_IRQHandler_2: (+1)
   \   000000A8   0xBD01             POP      {R0,PC}          ;; return
   1723          
   1724          /**
   1725            * @brief Tx Transfer completed callback
   1726            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   1727            *               the configuration information for SPI module.
   1728            * @retval None
   1729            */

   \                                 In section .text, align 2, keep-with-next
   1730          __weak void HAL_SPI_TxCpltCallback(SPI_HandleTypeDef *hspi)
   1731          {
   1732            /* Prevent unused argument(s) compilation warning */
   1733            UNUSED(hspi);
   1734           
   1735            /* NOTE : This function should not be modified, when the callback is needed,
   1736                      the HAL_SPI_TxCpltCallback should be implemented in the user file
   1737             */
   1738          }
   \                     HAL_SPI_TxCpltCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1739          
   1740          /**
   1741            * @brief Rx Transfer completed callbacks
   1742            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   1743            *               the configuration information for SPI module.
   1744            * @retval None
   1745            */

   \                                 In section .text, align 2, keep-with-next
   1746          __weak void HAL_SPI_RxCpltCallback(SPI_HandleTypeDef *hspi)
   1747          {
   1748            /* Prevent unused argument(s) compilation warning */
   1749            UNUSED(hspi);
   1750             
   1751            /* NOTE : This function should not be modified, when the callback is needed,
   1752                      the HAL_SPI_RxCpltCallback should be implemented in the user file
   1753             */
   1754          }
   \                     HAL_SPI_RxCpltCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1755          
   1756          /**
   1757            * @brief Tx and Rx Transfer completed callback
   1758            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   1759            *               the configuration information for SPI module.
   1760            * @retval None
   1761            */

   \                                 In section .text, align 2, keep-with-next
   1762          __weak void HAL_SPI_TxRxCpltCallback(SPI_HandleTypeDef *hspi)
   1763          {
   1764            /* Prevent unused argument(s) compilation warning */
   1765            UNUSED(hspi);
   1766           
   1767            /* NOTE : This function should not be modified, when the callback is needed,
   1768                      the HAL_SPI_TxRxCpltCallback should be implemented in the user file
   1769             */
   1770          }
   \                     HAL_SPI_TxRxCpltCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1771          
   1772          /**
   1773            * @brief Tx Half Transfer completed callback
   1774            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   1775            *               the configuration information for SPI module.
   1776            * @retval None
   1777            */

   \                                 In section .text, align 2, keep-with-next
   1778          __weak void HAL_SPI_TxHalfCpltCallback(SPI_HandleTypeDef *hspi)
   1779          {
   1780            /* Prevent unused argument(s) compilation warning */
   1781            UNUSED(hspi);
   1782           
   1783            /* NOTE : This function should not be modified, when the callback is needed,
   1784                      the HAL_SPI_TxHalfCpltCallback should be implemented in the user file
   1785             */
   1786          }
   \                     HAL_SPI_TxHalfCpltCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1787          
   1788          /**
   1789            * @brief Rx Half Transfer completed callback
   1790            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   1791            *               the configuration information for SPI module.
   1792            * @retval None
   1793            */

   \                                 In section .text, align 2, keep-with-next
   1794          __weak void HAL_SPI_RxHalfCpltCallback(SPI_HandleTypeDef *hspi)
   1795          {
   1796            /* Prevent unused argument(s) compilation warning */
   1797            UNUSED(hspi);
   1798           
   1799            /* NOTE : This function should not be modified, when the callback is needed,
   1800                      the HAL_SPI_RxHalfCpltCallback() should be implemented in the user file
   1801             */
   1802          }
   \                     HAL_SPI_RxHalfCpltCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1803          
   1804          /**
   1805            * @brief Tx and Rx Half Transfer callback
   1806            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   1807            *               the configuration information for SPI module.
   1808            * @retval None
   1809            */

   \                                 In section .text, align 2, keep-with-next
   1810          __weak void HAL_SPI_TxRxHalfCpltCallback(SPI_HandleTypeDef *hspi)
   1811          {
   1812            /* Prevent unused argument(s) compilation warning */
   1813            UNUSED(hspi);
   1814           
   1815            /* NOTE : This function should not be modified, when the callback is needed,
   1816                      the HAL_SPI_TxRxHalfCpltCallback() should be implemented in the user file
   1817             */
   1818          }
   \                     HAL_SPI_TxRxHalfCpltCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1819          
   1820          /**
   1821            * @brief SPI error callback
   1822            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   1823            *               the configuration information for SPI module.
   1824            * @retval None
   1825            */

   \                                 In section .text, align 2, keep-with-next
   1826           __weak void HAL_SPI_ErrorCallback(SPI_HandleTypeDef *hspi)
   1827          {
   1828            /* Prevent unused argument(s) compilation warning */
   1829            UNUSED(hspi);
   1830           
   1831            /* NOTE : This function should not be modified, when the callback is needed,
   1832                      the HAL_SPI_ErrorCallback should be implemented in the user file
   1833             */
   1834            /* NOTE : The ErrorCode parameter in the hspi handle is updated by the SPI processes
   1835                      and user can use HAL_SPI_GetError() API to check the latest error occurred
   1836             */
   1837          }
   \                     HAL_SPI_ErrorCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1838          
   1839          /**
   1840            * @}
   1841            */
   1842          
   1843          /**
   1844            * @}
   1845            */
   1846          
   1847          /** @defgroup SPI_Exported_Functions_Group3 Peripheral State and Errors functions
   1848            *  @brief   SPI control functions
   1849            *
   1850          @verbatim
   1851           ===============================================================================
   1852                                ##### Peripheral State and Errors functions #####
   1853           ===============================================================================
   1854              [..]
   1855              This subsection provides a set of functions allowing to control the SPI.
   1856               (+) HAL_SPI_GetState() API can be helpful to check in run-time the state of the SPI peripheral
   1857               (+) HAL_SPI_GetError() check in run-time Errors occurring during communication
   1858          @endverbatim
   1859            * @{
   1860            */
   1861          
   1862          /**
   1863            * @brief  Return the SPI state
   1864            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   1865            *               the configuration information for SPI module.
   1866            * @retval SPI state
   1867            */

   \                                 In section .text, align 2, keep-with-next
   1868          HAL_SPI_StateTypeDef HAL_SPI_GetState(SPI_HandleTypeDef *hspi)
   1869          {
   1870            return hspi->State;
   \                     HAL_SPI_GetState: (+1)
   \   00000000   0xF890 0x005D      LDRB     R0,[R0, #+93]
   \   00000004   0x4770             BX       LR               ;; return
   1871          }
   1872          
   1873          /**
   1874            * @brief  Return the SPI error code
   1875            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   1876            *               the configuration information for SPI module.
   1877            * @retval SPI error code in bitmap format
   1878            */

   \                                 In section .text, align 2, keep-with-next
   1879          uint32_t HAL_SPI_GetError(SPI_HandleTypeDef *hspi)
   1880          {
   1881            return hspi->ErrorCode;
   \                     HAL_SPI_GetError: (+1)
   \   00000000   0x6E00             LDR      R0,[R0, #+96]
   \   00000002   0x4770             BX       LR               ;; return
   1882          }
   1883          
   1884          /**
   1885            * @}
   1886            */
   1887          
   1888          /**
   1889            * @}
   1890            */
   1891          
   1892          /** @defgroup SPI_Private_Functions SPI Private Functions
   1893            * @{
   1894            */
   1895          
   1896          /**
   1897            * @brief DMA SPI transmit process complete callback
   1898            * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
   1899            *               the configuration information for the specified DMA module.
   1900            * @retval None
   1901            */

   \                                 In section .text, align 4, keep-with-next
   1902          static void SPI_DMATransmitCplt(DMA_HandleTypeDef *hdma)
   1903          {
   \                     SPI_DMATransmitCplt: (+1)
   \   00000000   0x4601             MOV      R1,R0
   \   00000002   0xB580             PUSH     {R7,LR}
   1904            SPI_HandleTypeDef* hspi = ( SPI_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   \   00000004   0x6B88             LDR      R0,[R1, #+56]
   1905          
   1906            /* DMA Normal Mode */
   1907            if((hdma->Instance->CR & DMA_SxCR_CIRC) == 0)
   \   00000006   0x6809             LDR      R1,[R1, #+0]
   \   00000008   0x6809             LDR      R1,[R1, #+0]
   \   0000000A   0x05C9             LSLS     R1,R1,#+23
   \   0000000C   0xD414             BMI.N    ??SPI_DMATransmitCplt_0
   1908            {
   1909              /* Disable Tx DMA Request */
   1910              CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN);
   \   0000000E   0x6801             LDR      R1,[R0, #+0]
   \   00000010   0x684A             LDR      R2,[R1, #+4]
   \   00000012   0xF022 0x0202      BIC      R2,R2,#0x2
   \   00000016   0x604A             STR      R2,[R1, #+4]
   1911          
   1912              /* Clear OVERUN flag in 2 Lines communication mode because received data is not read */
   1913              if(hspi->Init.Direction == SPI_DIRECTION_2LINES)
   \   00000018   0x6882             LDR      R2,[R0, #+8]
   \   0000001A   0xB92A             CBNZ.N   R2,??SPI_DMATransmitCplt_1
   1914              {
   1915                __HAL_SPI_CLEAR_OVRFLAG(hspi);
   \   0000001C   0x9200             STR      R2,[SP, #+0]
   \   0000001E   0x68CA             LDR      R2,[R1, #+12]
   \   00000020   0x9200             STR      R2,[SP, #+0]
   \   00000022   0x6889             LDR      R1,[R1, #+8]
   \   00000024   0x9100             STR      R1,[SP, #+0]
   \   00000026   0x9900             LDR      R1,[SP, #+0]
   1916              }
   1917          
   1918              hspi->TxXferCount = 0;
   \                     ??SPI_DMATransmitCplt_1: (+1)
   \   00000028   0x2100             MOVS     R1,#+0
   \   0000002A   0x87C1             STRH     R1,[R0, #+62]
   1919              hspi->State = HAL_SPI_STATE_READY;
   \   0000002C   0x2101             MOVS     R1,#+1
   \   0000002E   0xF880 0x105D      STRB     R1,[R0, #+93]
   1920          
   1921              if(hspi->ErrorCode != HAL_SPI_ERROR_NONE)
   \   00000032   0x6E01             LDR      R1,[R0, #+96]
   \   00000034   0xB101             CBZ.N    R1,??SPI_DMATransmitCplt_0
   1922              {
   1923                HAL_SPI_ErrorCallback(hspi);
   \   00000036   0x....             B.N      ?Subroutine6
   1924                return;
   1925              }
   1926            }
   1927            HAL_SPI_TxCpltCallback(hspi);
   \                     ??SPI_DMATransmitCplt_0: (+1)
   \   00000038   0x.... 0x....      B.W      ?Subroutine5
   1928          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine6: (+1)
   \   00000000   0x.... 0x....      BL       HAL_SPI_ErrorCallback
   \   00000004   0xBD01             POP      {R0,PC}

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine5: (+1)
   \   00000000   0x.... 0x....      BL       HAL_SPI_TxCpltCallback
   \   00000004   0xBD01             POP      {R0,PC}          ;; return
   1929          
   1930          /**
   1931            * @brief DMA SPI receive process complete callback
   1932            * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
   1933            *               the configuration information for the specified DMA module.
   1934            * @retval None
   1935            */

   \                                 In section .text, align 4, keep-with-next
   1936          static void SPI_DMAReceiveCplt(DMA_HandleTypeDef *hdma)
   1937          {
   \                     SPI_DMAReceiveCplt: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   1938            __IO uint16_t tmpreg;
   1939            SPI_HandleTypeDef* hspi = ( SPI_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   \   00000002   0x6B84             LDR      R4,[R0, #+56]
   1940            
   1941            /* DMA Normal mode */
   1942            if((hdma->Instance->CR & DMA_SxCR_CIRC) == 0)
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0x05C0             LSLS     R0,R0,#+23
   \   0000000A   0xF100 0x80AB      BMI.W    ??SPI_DMAReceiveCplt_0
   1943            {  
   1944              /* CRC handling */
   1945              if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   \   0000000E   0x6AA0             LDR      R0,[R4, #+40]
   \   00000010   0xF5B0 0x5F00      CMP      R0,#+8192
   \   00000014   0xF040 0x8083      BNE.W    ??SPI_DMAReceiveCplt_1
   1946              {
   1947                /* Wait until TXE flag */
   1948                if(SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_RXNE, SPI_FLAG_RXNE, SPI_DEFAULT_TIMEOUT) != HAL_OK)
   \   00000018   0x.... 0x....      BL       HAL_GetTick
   \   0000001C   0x4605             MOV      R5,R0
   \                     ??SPI_DMAReceiveCplt_2: (+1)
   \   0000001E   0x6820             LDR      R0,[R4, #+0]
   \   00000020   0x6880             LDR      R0,[R0, #+8]
   \   00000022   0x07C0             LSLS     R0,R0,#+31
   \   00000024   0xD42F             BMI.N    ??SPI_DMAReceiveCplt_3
   \   00000026   0x.... 0x....      BL       HAL_GetTick
   \   0000002A   0x1B40             SUBS     R0,R0,R5
   \   0000002C   0x2832             CMP      R0,#+50
   \   0000002E   0xD3F6             BCC.N    ??SPI_DMAReceiveCplt_2
   \   00000030   0x6820             LDR      R0,[R4, #+0]
   \   00000032   0x6841             LDR      R1,[R0, #+4]
   \   00000034   0xF021 0x01E0      BIC      R1,R1,#0xE0
   \   00000038   0x6041             STR      R1,[R0, #+4]
   \   0000003A   0x6861             LDR      R1,[R4, #+4]
   \   0000003C   0xF5B1 0x7F82      CMP      R1,#+260
   \   00000040   0xD10A             BNE.N    ??SPI_DMAReceiveCplt_4
   \   00000042   0x68A1             LDR      R1,[R4, #+8]
   \   00000044   0xF5B1 0x4F00      CMP      R1,#+32768
   \   00000048   0xBF18             IT       NE 
   \   0000004A   0xF5B1 0x6F80      CMPNE    R1,#+1024
   \   0000004E   0xD103             BNE.N    ??SPI_DMAReceiveCplt_4
   \   00000050   0x6801             LDR      R1,[R0, #+0]
   \   00000052   0xF021 0x0140      BIC      R1,R1,#0x40
   \   00000056   0x6001             STR      R1,[R0, #+0]
   \                     ??SPI_DMAReceiveCplt_4: (+1)
   \   00000058   0x6AA1             LDR      R1,[R4, #+40]
   \   0000005A   0xF5B1 0x5F00      CMP      R1,#+8192
   \   0000005E   0xD108             BNE.N    ??SPI_DMAReceiveCplt_5
   \   00000060   0x6801             LDR      R1,[R0, #+0]
   \   00000062   0xF64D 0x72FF      MOVW     R2,#+57343
   \   00000066   0x4011             ANDS     R1,R2,R1
   \   00000068   0x6001             STR      R1,[R0, #+0]
   \   0000006A   0x6801             LDR      R1,[R0, #+0]
   \   0000006C   0xF441 0x5100      ORR      R1,R1,#0x2000
   \   00000070   0x6001             STR      R1,[R0, #+0]
   \                     ??SPI_DMAReceiveCplt_5: (+1)
   \   00000072   0xF104 0x0046      ADD      R0,R4,#+70
   \   00000076   0x2101             MOVS     R1,#+1
   \   00000078   0x75C1             STRB     R1,[R0, #+23]
   \   0000007A   0x2100             MOVS     R1,#+0
   \   0000007C   0x7581             STRB     R1,[R0, #+22]
   1949                {
   1950                  /* Error on the CRC reception */
   1951                  hspi->ErrorCode|= HAL_SPI_ERROR_CRC;      
   \   0000007E   0x6E20             LDR      R0,[R4, #+96]
   \   00000080   0xF040 0x0002      ORR      R0,R0,#0x2
   \   00000084   0x6620             STR      R0,[R4, #+96]
   1952                }
   1953                if(hspi->Init.DataSize > SPI_DATASIZE_8BIT)
   \                     ??SPI_DMAReceiveCplt_3: (+1)
   \   00000086   0x68E1             LDR      R1,[R4, #+12]
   \   00000088   0x6820             LDR      R0,[R4, #+0]
   \   0000008A   0xF5B1 0x6FE0      CMP      R1,#+1792
   \   0000008E   0xBF88             IT       HI 
   \   00000090   0x68C0             LDRHI    R0,[R0, #+12]
   1954                {        
   1955                  tmpreg = hspi->Instance->DR;
   \   00000092   0xD840             BHI.N    ??SPI_DMAReceiveCplt_6
   1956                  UNUSED(tmpreg); /* To avoid GCC warning */
   1957                }
   1958                else
   1959                {
   1960                  tmpreg = *(__IO uint8_t *)&hspi->Instance->DR;
   \   00000094   0x7B00             LDRB     R0,[R0, #+12]
   \   00000096   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   1961                  UNUSED(tmpreg); /* To avoid GCC warning */
   \   0000009A   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   1962                  
   1963                  if(hspi->Init.CRCLength == SPI_CRC_LENGTH_16BIT)
   \   0000009E   0x6B20             LDR      R0,[R4, #+48]
   \   000000A0   0x2802             CMP      R0,#+2
   \   000000A2   0xD13C             BNE.N    ??SPI_DMAReceiveCplt_1
   1964                  {
   1965                    if(SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_RXNE, SPI_FLAG_RXNE, SPI_DEFAULT_TIMEOUT) != HAL_OK)
   \   000000A4   0x.... 0x....      BL       HAL_GetTick
   \   000000A8   0x4605             MOV      R5,R0
   \                     ??SPI_DMAReceiveCplt_7: (+1)
   \   000000AA   0x6820             LDR      R0,[R4, #+0]
   \   000000AC   0x6880             LDR      R0,[R0, #+8]
   \   000000AE   0x07C0             LSLS     R0,R0,#+31
   \   000000B0   0xD42F             BMI.N    ??SPI_DMAReceiveCplt_8
   \   000000B2   0x.... 0x....      BL       HAL_GetTick
   \   000000B6   0x1B40             SUBS     R0,R0,R5
   \   000000B8   0x2832             CMP      R0,#+50
   \   000000BA   0xD3F6             BCC.N    ??SPI_DMAReceiveCplt_7
   \   000000BC   0x6820             LDR      R0,[R4, #+0]
   \   000000BE   0x6841             LDR      R1,[R0, #+4]
   \   000000C0   0xF021 0x01E0      BIC      R1,R1,#0xE0
   \   000000C4   0x6041             STR      R1,[R0, #+4]
   \   000000C6   0x6861             LDR      R1,[R4, #+4]
   \   000000C8   0xF5B1 0x7F82      CMP      R1,#+260
   \   000000CC   0xD10A             BNE.N    ??SPI_DMAReceiveCplt_9
   \   000000CE   0x68A1             LDR      R1,[R4, #+8]
   \   000000D0   0xF5B1 0x4F00      CMP      R1,#+32768
   \   000000D4   0xBF18             IT       NE 
   \   000000D6   0xF5B1 0x6F80      CMPNE    R1,#+1024
   \   000000DA   0xD103             BNE.N    ??SPI_DMAReceiveCplt_9
   \   000000DC   0x6801             LDR      R1,[R0, #+0]
   \   000000DE   0xF021 0x0140      BIC      R1,R1,#0x40
   \   000000E2   0x6001             STR      R1,[R0, #+0]
   \                     ??SPI_DMAReceiveCplt_9: (+1)
   \   000000E4   0x6AA1             LDR      R1,[R4, #+40]
   \   000000E6   0xF5B1 0x5F00      CMP      R1,#+8192
   \   000000EA   0xD108             BNE.N    ??SPI_DMAReceiveCplt_10
   \   000000EC   0x6801             LDR      R1,[R0, #+0]
   \   000000EE   0xF64D 0x72FF      MOVW     R2,#+57343
   \   000000F2   0x4011             ANDS     R1,R2,R1
   \   000000F4   0x6001             STR      R1,[R0, #+0]
   \   000000F6   0x6801             LDR      R1,[R0, #+0]
   \   000000F8   0xF441 0x5100      ORR      R1,R1,#0x2000
   \   000000FC   0x6001             STR      R1,[R0, #+0]
   \                     ??SPI_DMAReceiveCplt_10: (+1)
   \   000000FE   0xF104 0x0046      ADD      R0,R4,#+70
   \   00000102   0x2101             MOVS     R1,#+1
   \   00000104   0x75C1             STRB     R1,[R0, #+23]
   \   00000106   0x2100             MOVS     R1,#+0
   \   00000108   0x7581             STRB     R1,[R0, #+22]
   1966                    {
   1967                      /* Error on the CRC reception */
   1968                      hspi->ErrorCode|= HAL_SPI_ERROR_CRC;      
   \   0000010A   0x6E20             LDR      R0,[R4, #+96]
   \   0000010C   0xF040 0x0002      ORR      R0,R0,#0x2
   \   00000110   0x6620             STR      R0,[R4, #+96]
   1969                    }
   1970                    tmpreg = *(__IO uint8_t *)&hspi->Instance->DR;
   \                     ??SPI_DMAReceiveCplt_8: (+1)
   \   00000112   0x6820             LDR      R0,[R4, #+0]
   \   00000114   0x7B00             LDRB     R0,[R0, #+12]
   \                     ??SPI_DMAReceiveCplt_6: (+1)
   \   00000116   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   1971                    UNUSED(tmpreg); /* To avoid GCC warning */
   \   0000011A   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   1972                  }
   1973                }  
   1974              }
   1975              
   1976              /* Disable Rx DMA Request */
   1977              hspi->Instance->CR2 &= (uint32_t)(~SPI_CR2_RXDMAEN);
   \                     ??SPI_DMAReceiveCplt_1: (+1)
   \   0000011E   0x6820             LDR      R0,[R4, #+0]
   \   00000120   0x6841             LDR      R1,[R0, #+4]
   \   00000122   0x0849             LSRS     R1,R1,#+1
   \   00000124   0x0049             LSLS     R1,R1,#+1
   \   00000126   0x6041             STR      R1,[R0, #+4]
   1978              /* Disable Tx DMA Request (done by default to handle the case master rx direction 2 lines) */
   1979              hspi->Instance->CR2 &= (uint32_t)(~SPI_CR2_TXDMAEN);
   \   00000128   0x6841             LDR      R1,[R0, #+4]
   \   0000012A   0xF021 0x0102      BIC      R1,R1,#0x2
   \   0000012E   0x6041             STR      R1,[R0, #+4]
   1980              
   1981              /* Check the end of the transaction */
   1982              SPI_EndRxTransaction(hspi,SPI_DEFAULT_TIMEOUT);
   \   00000130   0x2132             MOVS     R1,#+50
   \   00000132   0x4620             MOV      R0,R4
   \   00000134   0x.... 0x....      BL       SPI_EndRxTransaction
   1983              
   1984              hspi->RxXferCount = 0;
   \   00000138   0xF104 0x0046      ADD      R0,R4,#+70
   \   0000013C   0x2100             MOVS     R1,#+0
   \   0000013E   0x8001             STRH     R1,[R0, #+0]
   1985              hspi->State = HAL_SPI_STATE_READY;
   \   00000140   0x2101             MOVS     R1,#+1
   \   00000142   0x75C1             STRB     R1,[R0, #+23]
   1986              
   1987              /* Check if CRC error occurred */
   1988              if(__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_CRCERR) != RESET)
   \   00000144   0x6821             LDR      R1,[R4, #+0]
   \   00000146   0x6E20             LDR      R0,[R4, #+96]
   \   00000148   0x688A             LDR      R2,[R1, #+8]
   \   0000014A   0x06D2             LSLS     R2,R2,#+27
   \   0000014C   0xD506             BPL.N    ??SPI_DMAReceiveCplt_11
   1989              {
   1990                hspi->ErrorCode|= HAL_SPI_ERROR_CRC;
   \   0000014E   0xF040 0x0002      ORR      R0,R0,#0x2
   \   00000152   0x6620             STR      R0,[R4, #+96]
   1991                __HAL_SPI_CLEAR_CRCERRFLAG(hspi);
   \   00000154   0xF64F 0x70EF      MOVW     R0,#+65519
   \   00000158   0x6088             STR      R0,[R1, #+8]
   1992                HAL_SPI_RxCpltCallback(hspi);
   \   0000015A   0xE003             B.N      ??SPI_DMAReceiveCplt_0
   1993              }
   1994              else
   1995              {
   1996                if(hspi->ErrorCode == HAL_SPI_ERROR_NONE)
   \                     ??SPI_DMAReceiveCplt_11: (+1)
   \   0000015C   0x2800             CMP      R0,#+0
   \   0000015E   0x4620             MOV      R0,R4
   \   00000160   0xD001             BEQ.N    ??SPI_DMAReceiveCplt_12
   1997                {
   1998                  HAL_SPI_RxCpltCallback(hspi);
   1999                }
   2000                else
   2001                {
   2002                  HAL_SPI_ErrorCallback(hspi); 
   \   00000162   0x....             B.N      ?Subroutine7
   2003                }
   2004              }
   2005            }
   2006            else
   2007            {
   2008              HAL_SPI_RxCpltCallback(hspi);
   \                     ??SPI_DMAReceiveCplt_0: (+1)
   \   00000164   0x4620             MOV      R0,R4
   \                     ??SPI_DMAReceiveCplt_12: (+1)
   \   00000166   0x.... 0x....      BL       HAL_SPI_RxCpltCallback
   2009            }
   2010          }
   \   0000016A   0xBD31             POP      {R0,R4,R5,PC}    ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine7: (+1)
   \   00000000   0x.... 0x....      BL       HAL_SPI_ErrorCallback
   \   00000004   0xBD31             POP      {R0,R4,R5,PC}
   2011          
   2012          /**
   2013            * @brief DMA SPI transmit receive process complete callback
   2014            * @param  hdma : pointer to a DMA_HandleTypeDef structure that contains
   2015            *               the configuration information for the specified DMA module.
   2016            * @retval None
   2017            */

   \                                 In section .text, align 4, keep-with-next
   2018          static void SPI_DMATransmitReceiveCplt(DMA_HandleTypeDef *hdma)
   2019          {
   \                     SPI_DMATransmitReceiveCplt: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   2020            __IO int16_t tmpreg;
   2021            SPI_HandleTypeDef* hspi = ( SPI_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   \   00000002   0x6B84             LDR      R4,[R0, #+56]
   2022            
   2023            /* CRC handling */
   2024            if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   \   00000004   0x6AA0             LDR      R0,[R4, #+40]
   \   00000006   0xF5B0 0x5F00      CMP      R0,#+8192
   \   0000000A   0xF040 0x8084      BNE.W    ??SPI_DMATransmitReceiveCplt_0
   2025            {
   2026              if((hspi->Init.DataSize == SPI_DATASIZE_8BIT) && (hspi->Init.CRCLength == SPI_CRC_LENGTH_8BIT))
   \   0000000E   0x68E0             LDR      R0,[R4, #+12]
   \   00000010   0xF5B0 0x6FE0      CMP      R0,#+1792
   \   00000014   0xBF04             ITT      EQ 
   \   00000016   0x6B20             LDREQ    R0,[R4, #+48]
   \   00000018   0x2801             CMPEQ    R0,#+1
   \   0000001A   0xD13C             BNE.N    ??SPI_DMATransmitReceiveCplt_1
   2027              {        
   2028                if(SPI_WaitFifoStateUntilTimeout(hspi, SPI_FLAG_FRLVL, SPI_FRLVL_QUARTER_FULL, SPI_DEFAULT_TIMEOUT) != HAL_OK)
   \   0000001C   0x.... 0x....      BL       HAL_GetTick
   \   00000020   0x4605             MOV      R5,R0
   \                     ??SPI_DMATransmitReceiveCplt_2: (+1)
   \   00000022   0x6820             LDR      R0,[R4, #+0]
   \   00000024   0x6880             LDR      R0,[R0, #+8]
   \   00000026   0xF400 0x60C0      AND      R0,R0,#0x600
   \   0000002A   0xF5B0 0x7F00      CMP      R0,#+512
   \   0000002E   0xD02F             BEQ.N    ??SPI_DMATransmitReceiveCplt_3
   \   00000030   0x.... 0x....      BL       HAL_GetTick
   \   00000034   0x1B40             SUBS     R0,R0,R5
   \   00000036   0x2832             CMP      R0,#+50
   \   00000038   0xD3F3             BCC.N    ??SPI_DMATransmitReceiveCplt_2
   \   0000003A   0x6820             LDR      R0,[R4, #+0]
   \   0000003C   0x6841             LDR      R1,[R0, #+4]
   \   0000003E   0xF021 0x01E0      BIC      R1,R1,#0xE0
   \   00000042   0x6041             STR      R1,[R0, #+4]
   \   00000044   0x6861             LDR      R1,[R4, #+4]
   \   00000046   0xF5B1 0x7F82      CMP      R1,#+260
   \   0000004A   0xD10A             BNE.N    ??SPI_DMATransmitReceiveCplt_4
   \   0000004C   0x68A1             LDR      R1,[R4, #+8]
   \   0000004E   0xF5B1 0x4F00      CMP      R1,#+32768
   \   00000052   0xBF18             IT       NE 
   \   00000054   0xF5B1 0x6F80      CMPNE    R1,#+1024
   \   00000058   0xD103             BNE.N    ??SPI_DMATransmitReceiveCplt_4
   \   0000005A   0x6801             LDR      R1,[R0, #+0]
   \   0000005C   0xF021 0x0140      BIC      R1,R1,#0x40
   \   00000060   0x6001             STR      R1,[R0, #+0]
   \                     ??SPI_DMATransmitReceiveCplt_4: (+1)
   \   00000062   0x6AA1             LDR      R1,[R4, #+40]
   \   00000064   0xF5B1 0x5F00      CMP      R1,#+8192
   \   00000068   0xD108             BNE.N    ??SPI_DMATransmitReceiveCplt_5
   \   0000006A   0x6801             LDR      R1,[R0, #+0]
   \   0000006C   0xF64D 0x72FF      MOVW     R2,#+57343
   \   00000070   0x4011             ANDS     R1,R2,R1
   \   00000072   0x6001             STR      R1,[R0, #+0]
   \   00000074   0x6801             LDR      R1,[R0, #+0]
   \   00000076   0xF441 0x5100      ORR      R1,R1,#0x2000
   \   0000007A   0x6001             STR      R1,[R0, #+0]
   \                     ??SPI_DMATransmitReceiveCplt_5: (+1)
   \   0000007C   0xF104 0x0046      ADD      R0,R4,#+70
   \   00000080   0x2101             MOVS     R1,#+1
   \   00000082   0x75C1             STRB     R1,[R0, #+23]
   \   00000084   0x2100             MOVS     R1,#+0
   \   00000086   0x7581             STRB     R1,[R0, #+22]
   2029                {
   2030                  /* Error on the CRC reception */
   2031                  hspi->ErrorCode|= HAL_SPI_ERROR_CRC;      
   \   00000088   0x6E20             LDR      R0,[R4, #+96]
   \   0000008A   0xF040 0x0002      ORR      R0,R0,#0x2
   \   0000008E   0x6620             STR      R0,[R4, #+96]
   2032                }
   2033                tmpreg = *(__IO uint8_t *)&hspi->Instance->DR;
   \                     ??SPI_DMATransmitReceiveCplt_3: (+1)
   \   00000090   0x6820             LDR      R0,[R4, #+0]
   \   00000092   0x7B00             LDRB     R0,[R0, #+12]
   \   00000094   0xE03B             B.N      ??SPI_DMATransmitReceiveCplt_6
   2034                UNUSED(tmpreg); /* To avoid GCC warning */
   2035              }
   2036              else
   2037              {
   2038                if(SPI_WaitFifoStateUntilTimeout(hspi, SPI_FLAG_FRLVL, SPI_FRLVL_HALF_FULL, SPI_DEFAULT_TIMEOUT) != HAL_OK)
   \                     ??SPI_DMATransmitReceiveCplt_1: (+1)
   \   00000096   0x.... 0x....      BL       HAL_GetTick
   \   0000009A   0x4605             MOV      R5,R0
   \                     ??SPI_DMATransmitReceiveCplt_7: (+1)
   \   0000009C   0x6820             LDR      R0,[R4, #+0]
   \   0000009E   0x6880             LDR      R0,[R0, #+8]
   \   000000A0   0xF400 0x60C0      AND      R0,R0,#0x600
   \   000000A4   0xF5B0 0x6F80      CMP      R0,#+1024
   \   000000A8   0xD02F             BEQ.N    ??SPI_DMATransmitReceiveCplt_8
   \   000000AA   0x.... 0x....      BL       HAL_GetTick
   \   000000AE   0x1B40             SUBS     R0,R0,R5
   \   000000B0   0x2832             CMP      R0,#+50
   \   000000B2   0xD3F3             BCC.N    ??SPI_DMATransmitReceiveCplt_7
   \   000000B4   0x6820             LDR      R0,[R4, #+0]
   \   000000B6   0x6841             LDR      R1,[R0, #+4]
   \   000000B8   0xF021 0x01E0      BIC      R1,R1,#0xE0
   \   000000BC   0x6041             STR      R1,[R0, #+4]
   \   000000BE   0x6861             LDR      R1,[R4, #+4]
   \   000000C0   0xF5B1 0x7F82      CMP      R1,#+260
   \   000000C4   0xD10A             BNE.N    ??SPI_DMATransmitReceiveCplt_9
   \   000000C6   0x68A1             LDR      R1,[R4, #+8]
   \   000000C8   0xF5B1 0x4F00      CMP      R1,#+32768
   \   000000CC   0xBF18             IT       NE 
   \   000000CE   0xF5B1 0x6F80      CMPNE    R1,#+1024
   \   000000D2   0xD103             BNE.N    ??SPI_DMATransmitReceiveCplt_9
   \   000000D4   0x6801             LDR      R1,[R0, #+0]
   \   000000D6   0xF021 0x0140      BIC      R1,R1,#0x40
   \   000000DA   0x6001             STR      R1,[R0, #+0]
   \                     ??SPI_DMATransmitReceiveCplt_9: (+1)
   \   000000DC   0x6AA1             LDR      R1,[R4, #+40]
   \   000000DE   0xF5B1 0x5F00      CMP      R1,#+8192
   \   000000E2   0xD108             BNE.N    ??SPI_DMATransmitReceiveCplt_10
   \   000000E4   0x6801             LDR      R1,[R0, #+0]
   \   000000E6   0xF64D 0x72FF      MOVW     R2,#+57343
   \   000000EA   0x4011             ANDS     R1,R2,R1
   \   000000EC   0x6001             STR      R1,[R0, #+0]
   \   000000EE   0x6801             LDR      R1,[R0, #+0]
   \   000000F0   0xF441 0x5100      ORR      R1,R1,#0x2000
   \   000000F4   0x6001             STR      R1,[R0, #+0]
   \                     ??SPI_DMATransmitReceiveCplt_10: (+1)
   \   000000F6   0xF104 0x0046      ADD      R0,R4,#+70
   \   000000FA   0x2101             MOVS     R1,#+1
   \   000000FC   0x75C1             STRB     R1,[R0, #+23]
   \   000000FE   0x2100             MOVS     R1,#+0
   \   00000100   0x7581             STRB     R1,[R0, #+22]
   2039                {
   2040                  /* Error on the CRC reception */
   2041                  hspi->ErrorCode|= HAL_SPI_ERROR_CRC;      
   \   00000102   0x6E20             LDR      R0,[R4, #+96]
   \   00000104   0xF040 0x0002      ORR      R0,R0,#0x2
   \   00000108   0x6620             STR      R0,[R4, #+96]
   2042                }
   2043                tmpreg = hspi->Instance->DR;
   \                     ??SPI_DMATransmitReceiveCplt_8: (+1)
   \   0000010A   0x6820             LDR      R0,[R4, #+0]
   \   0000010C   0x68C0             LDR      R0,[R0, #+12]
   \                     ??SPI_DMATransmitReceiveCplt_6: (+1)
   \   0000010E   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   2044                UNUSED(tmpreg); /* To avoid GCC warning */
   \   00000112   0xF9BD 0x0000      LDRSH    R0,[SP, #+0]
   2045              }
   2046            }  
   2047            
   2048            /* Check the end of the transaction */
   2049            SPI_EndRxTxTransaction(hspi,SPI_DEFAULT_TIMEOUT);
   \                     ??SPI_DMATransmitReceiveCplt_0: (+1)
   \   00000116   0x2132             MOVS     R1,#+50
   \   00000118   0x4620             MOV      R0,R4
   \   0000011A   0x.... 0x....      BL       SPI_EndRxTxTransaction
   2050            
   2051            /* Disable Tx DMA Request */
   2052            CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN);
   \   0000011E   0x6821             LDR      R1,[R4, #+0]
   2053            
   2054            /* Disable Rx DMA Request */
   2055            CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_RXDMAEN);
   2056             
   2057            hspi->TxXferCount = 0;
   2058            hspi->RxXferCount = 0;
   \   00000120   0x2200             MOVS     R2,#+0
   \   00000122   0x6848             LDR      R0,[R1, #+4]
   \   00000124   0xF020 0x0002      BIC      R0,R0,#0x2
   \   00000128   0x6048             STR      R0,[R1, #+4]
   \   0000012A   0x6848             LDR      R0,[R1, #+4]
   \   0000012C   0x0840             LSRS     R0,R0,#+1
   \   0000012E   0x0040             LSLS     R0,R0,#+1
   \   00000130   0x6048             STR      R0,[R1, #+4]
   \   00000132   0x2000             MOVS     R0,#+0
   \   00000134   0x87E0             STRH     R0,[R4, #+62]
   \   00000136   0xF104 0x0046      ADD      R0,R4,#+70
   \   0000013A   0x8002             STRH     R2,[R0, #+0]
   2059            hspi->State = HAL_SPI_STATE_READY;
   \   0000013C   0x2201             MOVS     R2,#+1
   \   0000013E   0x75C2             STRB     R2,[R0, #+23]
   2060            
   2061            /* Check if CRC error occurred */
   2062            if(__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_CRCERR) != RESET)
   \   00000140   0x6888             LDR      R0,[R1, #+8]
   \   00000142   0x06C0             LSLS     R0,R0,#+27
   \   00000144   0xD506             BPL.N    ??SPI_DMATransmitReceiveCplt_11
   2063            {
   2064              hspi->ErrorCode = HAL_SPI_ERROR_CRC;
   \   00000146   0x2002             MOVS     R0,#+2
   \   00000148   0x6620             STR      R0,[R4, #+96]
   2065              __HAL_SPI_CLEAR_CRCERRFLAG(hspi);
   \   0000014A   0xF64F 0x70EF      MOVW     R0,#+65519
   \   0000014E   0x6088             STR      R0,[R1, #+8]
   2066              HAL_SPI_ErrorCallback(hspi);
   \   00000150   0x4620             MOV      R0,R4
   \   00000152   0xE006             B.N      ??SPI_DMATransmitReceiveCplt_12
   2067            }
   2068            else
   2069            {     
   2070              if(hspi->ErrorCode == HAL_SPI_ERROR_NONE)
   \                     ??SPI_DMATransmitReceiveCplt_11: (+1)
   \   00000154   0x6E20             LDR      R0,[R4, #+96]
   \   00000156   0x2800             CMP      R0,#+0
   \   00000158   0x4620             MOV      R0,R4
   \   0000015A   0xD102             BNE.N    ??SPI_DMATransmitReceiveCplt_12
   2071              {
   2072                HAL_SPI_TxRxCpltCallback(hspi);
   \   0000015C   0x.... 0x....      BL       HAL_SPI_TxRxCpltCallback
   \   00000160   0xBD31             POP      {R0,R4,R5,PC}
   2073              }
   \                     ??SPI_DMATransmitReceiveCplt_12: (+1)
   \   00000162   0xBF00             Nop      
   2074              else
   2075              {
   2076                HAL_SPI_ErrorCallback(hspi);
   \   00000164                      REQUIRE ?Subroutine7
   \   00000164                      ;; // Fall through to label ?Subroutine7
   2077              }
   2078            }
   2079          }
   2080          
   2081          /**
   2082            * @brief DMA SPI half transmit process complete callback
   2083            * @param  hdma : pointer to a DMA_HandleTypeDef structure that contains
   2084            *               the configuration information for the specified DMA module.
   2085            * @retval None
   2086            */

   \                                 In section .text, align 4, keep-with-next
   2087          static void SPI_DMAHalfTransmitCplt(DMA_HandleTypeDef *hdma)
   2088          {
   \                     SPI_DMAHalfTransmitCplt: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   2089            SPI_HandleTypeDef* hspi = ( SPI_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   2090          
   2091            HAL_SPI_TxHalfCpltCallback(hspi);
   \   00000002   0x6B80             LDR      R0,[R0, #+56]
   \   00000004   0x.... 0x....      BL       HAL_SPI_TxHalfCpltCallback
   2092          }
   \   00000008   0xBD01             POP      {R0,PC}          ;; return
   2093          
   2094          /**
   2095            * @brief DMA SPI half receive process complete callback
   2096            * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
   2097            *               the configuration information for the specified DMA module.
   2098            * @retval None
   2099            */

   \                                 In section .text, align 4, keep-with-next
   2100          static void SPI_DMAHalfReceiveCplt(DMA_HandleTypeDef *hdma)
   2101          {
   \                     SPI_DMAHalfReceiveCplt: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   2102            SPI_HandleTypeDef* hspi = ( SPI_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   2103          
   2104            HAL_SPI_RxHalfCpltCallback(hspi);
   \   00000002   0x6B80             LDR      R0,[R0, #+56]
   \   00000004   0x.... 0x....      BL       HAL_SPI_RxHalfCpltCallback
   2105          }
   \   00000008   0xBD01             POP      {R0,PC}          ;; return
   2106          
   2107          /**
   2108            * @brief DMA SPI Half transmit receive process complete callback
   2109            * @param  hdma : pointer to a DMA_HandleTypeDef structure that contains
   2110            *               the configuration information for the specified DMA module.
   2111            * @retval None
   2112            */

   \                                 In section .text, align 4, keep-with-next
   2113          static void SPI_DMAHalfTransmitReceiveCplt(DMA_HandleTypeDef *hdma)
   2114          {
   \                     SPI_DMAHalfTransmitReceiveCplt: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   2115            SPI_HandleTypeDef* hspi = ( SPI_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   2116          
   2117            HAL_SPI_TxRxHalfCpltCallback(hspi);
   \   00000002   0x6B80             LDR      R0,[R0, #+56]
   \   00000004   0x.... 0x....      BL       HAL_SPI_TxRxHalfCpltCallback
   2118          }
   \   00000008   0xBD01             POP      {R0,PC}          ;; return
   2119          
   2120          /**
   2121            * @brief DMA SPI communication error callback
   2122            * @param  hdma : pointer to a DMA_HandleTypeDef structure that contains
   2123            *               the configuration information for the specified DMA module.
   2124            * @retval None
   2125            */

   \                                 In section .text, align 4, keep-with-next
   2126          static void SPI_DMAError(DMA_HandleTypeDef *hdma)
   2127          {
   \                     SPI_DMAError: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   2128            SPI_HandleTypeDef* hspi = ( SPI_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   \   00000002   0x6B80             LDR      R0,[R0, #+56]
   2129          
   2130            /* Stop the disable DMA transfer on SPI side */
   2131            CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);
   \   00000004   0x6801             LDR      R1,[R0, #+0]
   \   00000006   0x684A             LDR      R2,[R1, #+4]
   \   00000008   0x0892             LSRS     R2,R2,#+2
   \   0000000A   0x0092             LSLS     R2,R2,#+2
   \   0000000C   0x604A             STR      R2,[R1, #+4]
   2132          
   2133            hspi->ErrorCode|= HAL_SPI_ERROR_DMA;
   \   0000000E   0x6E01             LDR      R1,[R0, #+96]
   \   00000010   0xF041 0x0110      ORR      R1,R1,#0x10
   \   00000014   0x6601             STR      R1,[R0, #+96]
   2134            hspi->State = HAL_SPI_STATE_READY;
   \   00000016   0x2101             MOVS     R1,#+1
   \   00000018   0xF880 0x105D      STRB     R1,[R0, #+93]
   2135            HAL_SPI_ErrorCallback(hspi);
   \   0000001C                      REQUIRE ?Subroutine6
   \   0000001C                      ;; // Fall through to label ?Subroutine6
   2136          }
   2137          
   2138          /**
   2139            * @brief  Rx Handler for Transmit and Receive in Interrupt mode
   2140            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   2141            *               the configuration information for SPI module.
   2142            * @retval None
   2143            */

   \                                 In section .text, align 4, keep-with-next
   2144          static void SPI_2linesRxISR_8BIT(struct __SPI_HandleTypeDef *hspi)
   2145          {
   2146            /* Receive data in packing mode */
   2147            if(hspi->RxXferCount > 1)
   \                     SPI_2linesRxISR_8BIT: (+1)
   \   00000000   0xF8B0 0x3046      LDRH     R3,[R0, #+70]
   \   00000004   0x6C02             LDR      R2,[R0, #+64]
   \   00000006   0x6801             LDR      R1,[R0, #+0]
   \   00000008   0x2B02             CMP      R3,#+2
   \   0000000A   0xDB0F             BLT.N    ??SPI_2linesRxISR_8BIT_0
   2148            {
   2149              *((uint16_t*)hspi->pRxBuffPtr) = hspi->Instance->DR;
   \   0000000C   0x68CB             LDR      R3,[R1, #+12]
   \   0000000E   0xF822 0x3B02      STRH     R3,[R2], #+2
   2150              hspi->pRxBuffPtr += sizeof(uint16_t);
   2151              hspi->RxXferCount -= 2;
   \   00000012   0xF8B0 0x3046      LDRH     R3,[R0, #+70]
   \   00000016   0x1E9B             SUBS     R3,R3,#+2
   \   00000018   0xF8A0 0x3046      STRH     R3,[R0, #+70]
   2152              if(hspi->RxXferCount == 1)
   \   0000001C   0xB29B             UXTH     R3,R3
   \   0000001E   0x2B01             CMP      R3,#+1
   \   00000020   0xD10C             BNE.N    ??SPI_2linesRxISR_8BIT_1
   2153              {
   2154                /* set fiforxthreshold according the reception data length: 8bit */
   2155                SET_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
   \   00000022   0x684B             LDR      R3,[R1, #+4]
   \   00000024   0xF443 0x5380      ORR      R3,R3,#0x1000
   \   00000028   0x604B             STR      R3,[R1, #+4]
   \   0000002A   0xE007             B.N      ??SPI_2linesRxISR_8BIT_1
   2156              }
   2157            }
   2158            /* Receive data in 8 Bit mode */
   2159            else
   2160            {
   2161              *hspi->pRxBuffPtr++ = *((__IO uint8_t *)&hspi->Instance->DR);
   \                     ??SPI_2linesRxISR_8BIT_0: (+1)
   \   0000002C   0x7B0B             LDRB     R3,[R1, #+12]
   \   0000002E   0xF802 0x3B01      STRB     R3,[R2], #+1
   2162              hspi->RxXferCount--;
   \   00000032   0xF8B0 0x3046      LDRH     R3,[R0, #+70]
   \   00000036   0x1E5B             SUBS     R3,R3,#+1
   \   00000038   0xF8A0 0x3046      STRH     R3,[R0, #+70]
   \                     ??SPI_2linesRxISR_8BIT_1: (+1)
   \   0000003C   0x6402             STR      R2,[R0, #+64]
   2163            }
   2164            
   2165            /* check end of the reception */
   2166            if(hspi->RxXferCount == 0)
   \   0000003E   0xF8B0 0x2046      LDRH     R2,[R0, #+70]
   \   00000042   0xB99A             CBNZ.N   R2,??SPI_2linesRxISR_8BIT_2
   2167            {
   2168              if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   \   00000044   0x6A82             LDR      R2,[R0, #+40]
   \   00000046   0xF5B2 0x5F00      CMP      R2,#+8192
   \   0000004A   0x684A             LDR      R2,[R1, #+4]
   \   0000004C   0xD106             BNE.N    ??SPI_2linesRxISR_8BIT_3
   2169              {
   2170                SET_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
   \   0000004E   0xF442 0x5280      ORR      R2,R2,#0x1000
   \   00000052   0x604A             STR      R2,[R1, #+4]
   2171                hspi->RxISR =  SPI_2linesRxISR_8BITCRC;
   \   00000054   0x.... 0x....      ADR.W    R1,SPI_2linesRxISR_8BITCRC
   \   00000058   0x64C1             STR      R1,[R0, #+76]
   2172                return;
   \   0000005A   0x4770             BX       LR
   2173              }
   2174                  
   2175              /* Disable RXNE interrupt */
   2176              __HAL_SPI_DISABLE_IT(hspi, SPI_IT_RXNE);
   \                     ??SPI_2linesRxISR_8BIT_3: (+1)
   \   0000005C   0xF022 0x0240      BIC      R2,R2,#0x40
   \   00000060   0x604A             STR      R2,[R1, #+4]
   2177          
   2178              if(hspi->TxXferCount == 0)
   \   00000062   0x8FC1             LDRH     R1,[R0, #+62]
   \   00000064   0x2900             CMP      R1,#+0
   \   00000066   0xBF08             IT       EQ 
   2179              {
   2180                SPI_CloseRxTx_ISR(hspi);
   \   00000068   0x.... 0x....      BEQ.W    SPI_CloseRxTx_ISR
   2181              }
   2182            }
   2183          }
   \                     ??SPI_2linesRxISR_8BIT_2: (+1)
   \   0000006C   0x4770             BX       LR               ;; return
   2184          
   2185          /**
   2186            * @brief  Rx Handler for Transmit and Receive in Interrupt mode
   2187            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   2188            *               the configuration information for SPI module.
   2189            * @retval None
   2190            */

   \                                 In section .text, align 4, keep-with-next
   2191          static void SPI_2linesRxISR_8BITCRC(struct __SPI_HandleTypeDef *hspi)
   2192          {
   \                     SPI_2linesRxISR_8BITCRC: (+1)
   \   00000000   0xB082             SUB      SP,SP,#+8
   2193            __IO uint8_t tmpreg;
   2194            
   2195            tmpreg = *((__IO uint8_t *)&hspi->Instance->DR);
   \   00000002   0x6801             LDR      R1,[R0, #+0]
   \   00000004   0x7B0A             LDRB     R2,[R1, #+12]
   \   00000006   0xF88D 0x2000      STRB     R2,[SP, #+0]
   2196            UNUSED(tmpreg); /* To avoid GCC warning */
   \   0000000A   0xF89D 0x2000      LDRB     R2,[SP, #+0]
   2197          
   2198            hspi->CRCSize--;
   \   0000000E   0x6C82             LDR      R2,[R0, #+72]
   \   00000010   0x1E52             SUBS     R2,R2,#+1
   \   00000012   0x6482             STR      R2,[R0, #+72]
   2199            
   2200            /* check end of the reception */
   2201            if(hspi->CRCSize == 0)
   \   00000014   0xD106             BNE.N    ??SPI_2linesRxISR_8BITCRC_0
   2202            {
   2203              /* Disable RXNE interrupt */
   2204              __HAL_SPI_DISABLE_IT(hspi, SPI_IT_RXNE);
   \   00000016   0x684A             LDR      R2,[R1, #+4]
   \   00000018   0xF022 0x0240      BIC      R2,R2,#0x40
   \   0000001C   0x604A             STR      R2,[R1, #+4]
   2205          
   2206              if(hspi->TxXferCount == 0)
   \   0000001E   0x8FC1             LDRH     R1,[R0, #+62]
   \   00000020   0xB901             CBNZ.N   R1,??SPI_2linesRxISR_8BITCRC_0
   2207              {
   2208                SPI_CloseRxTx_ISR(hspi);
   \   00000022   0x....             B.N      ?Subroutine8
   2209              }
   2210            }
   2211          }
   \                     ??SPI_2linesRxISR_8BITCRC_0: (+1)
   \   00000024   0xB002             ADD      SP,SP,#+8
   \   00000026   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine8: (+1)
   \   00000000   0xB002             ADD      SP,SP,#+8
   \   00000002   0x....             B.N      SPI_CloseRxTx_ISR
   2212          
   2213          /**
   2214            * @brief  Tx Handler for Transmit and Receive in Interrupt mode
   2215            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   2216            *               the configuration information for SPI module.
   2217            * @retval None
   2218            */

   \                                 In section .text, align 4, keep-with-next
   2219          static void SPI_2linesTxISR_8BIT(struct __SPI_HandleTypeDef *hspi)
   2220          {
   \                     SPI_2linesTxISR_8BIT: (+1)
   \   00000000   0xB418             PUSH     {R3,R4}
   2221            /* Transmit data in packing Bit mode */
   2222            if(hspi->TxXferCount >= 2)
   \   00000002   0x8FC3             LDRH     R3,[R0, #+62]
   \   00000004   0x6B82             LDR      R2,[R0, #+56]
   \   00000006   0x6801             LDR      R1,[R0, #+0]
   \   00000008   0x2B02             CMP      R3,#+2
   \   0000000A   0xDB04             BLT.N    ??SPI_2linesTxISR_8BIT_0
   2223            {
   2224              hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
   \   0000000C   0xF832 0x4B02      LDRH     R4,[R2], #+2
   2225              hspi->pTxBuffPtr += sizeof(uint16_t);
   2226              hspi->TxXferCount -= 2;
   \   00000010   0x1E9B             SUBS     R3,R3,#+2
   \   00000012   0x60CC             STR      R4,[R1, #+12]
   \   00000014   0xE004             B.N      ??SPI_2linesTxISR_8BIT_1
   2227            }
   2228            /* Transmit data in 8 Bit mode */
   2229            else
   2230            {        
   2231              *(__IO uint8_t *)&hspi->Instance->DR = (*hspi->pTxBuffPtr++);
   \                     ??SPI_2linesTxISR_8BIT_0: (+1)
   \   00000016   0xF812 0x3B01      LDRB     R3,[R2], #+1
   \   0000001A   0x730B             STRB     R3,[R1, #+12]
   2232              hspi->TxXferCount--;
   \   0000001C   0x8FC3             LDRH     R3,[R0, #+62]
   \   0000001E   0x1E5B             SUBS     R3,R3,#+1
   \                     ??SPI_2linesTxISR_8BIT_1: (+1)
   \   00000020   0x87C3             STRH     R3,[R0, #+62]
   \   00000022   0x6382             STR      R2,[R0, #+56]
   2233            }
   2234            
   2235            /* check the end of the transmission */
   2236            if(hspi->TxXferCount == 0)
   \   00000024   0x8FC2             LDRH     R2,[R0, #+62]
   \   00000026   0xB992             CBNZ.N   R2,??SPI_2linesTxISR_8BIT_2
   2237            {
   2238              if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   \   00000028   0x6A82             LDR      R2,[R0, #+40]
   \   0000002A   0xF5B2 0x5F00      CMP      R2,#+8192
   \   0000002E   0xD103             BNE.N    ??SPI_2linesTxISR_8BIT_3
   2239              {
   2240                hspi->Instance->CR1 |= SPI_CR1_CRCNEXT;
   \   00000030   0x680A             LDR      R2,[R1, #+0]
   \   00000032   0xF442 0x5280      ORR      R2,R2,#0x1000
   \   00000036   0x600A             STR      R2,[R1, #+0]
   2241              }
   2242              /* Disable TXE interrupt */
   2243              __HAL_SPI_DISABLE_IT(hspi, SPI_IT_TXE);
   \                     ??SPI_2linesTxISR_8BIT_3: (+1)
   \   00000038   0x684A             LDR      R2,[R1, #+4]
   \   0000003A   0xF022 0x0280      BIC      R2,R2,#0x80
   \   0000003E   0x604A             STR      R2,[R1, #+4]
   2244              
   2245              if(hspi->RxXferCount == 0)
   \   00000040   0xF8B0 0x1046      LDRH     R1,[R0, #+70]
   \   00000044   0x2900             CMP      R1,#+0
   \   00000046   0xBF04             ITT      EQ 
   2246              { 
   2247                SPI_CloseRxTx_ISR(hspi);
   \   00000048   0xBC12             POPEQ    {R1,R4}
   \   0000004A   0x.... 0x....      BEQ.W    SPI_CloseRxTx_ISR
   2248              }
   2249            }
   2250          }
   \                     ??SPI_2linesTxISR_8BIT_2: (+1)
   \   0000004E   0xBC11             POP      {R0,R4}
   \   00000050   0x4770             BX       LR               ;; return
   2251          
   2252          /**
   2253            * @brief  Rx 16Bit Handler for Transmit and Receive in Interrupt mode
   2254            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   2255            *               the configuration information for SPI module.
   2256            * @retval None
   2257            */

   \                                 In section .text, align 4, keep-with-next
   2258          static void SPI_2linesRxISR_16BIT(struct __SPI_HandleTypeDef *hspi)
   2259          {
   2260            /* Receive data in 16 Bit mode */
   2261            *((uint16_t*)hspi->pRxBuffPtr) = hspi->Instance->DR;
   \                     SPI_2linesRxISR_16BIT: (+1)
   \   00000000   0x6802             LDR      R2,[R0, #+0]
   \   00000002   0x6C01             LDR      R1,[R0, #+64]
   \   00000004   0x68D3             LDR      R3,[R2, #+12]
   \   00000006   0xF821 0x3B02      STRH     R3,[R1], #+2
   2262            hspi->pRxBuffPtr += sizeof(uint16_t);
   \   0000000A   0x6401             STR      R1,[R0, #+64]
   2263            hspi->RxXferCount--;
   \   0000000C   0xF8B0 0x1046      LDRH     R1,[R0, #+70]
   \   00000010   0x1E49             SUBS     R1,R1,#+1
   \   00000012   0xF8A0 0x1046      STRH     R1,[R0, #+70]
   2264          
   2265            if(hspi->RxXferCount == 0)
   \   00000016   0xB289             UXTH     R1,R1
   \   00000018   0xB981             CBNZ.N   R1,??SPI_2linesRxISR_16BIT_0
   2266            {
   2267              if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   \   0000001A   0x6A81             LDR      R1,[R0, #+40]
   \   0000001C   0xF5B1 0x5F00      CMP      R1,#+8192
   \   00000020   0xD103             BNE.N    ??SPI_2linesRxISR_16BIT_1
   2268              {
   2269                hspi->RxISR =  SPI_2linesRxISR_16BITCRC;
   \   00000022   0x.... 0x....      ADR.W    R1,SPI_2linesRxISR_16BITCRC
   \   00000026   0x64C1             STR      R1,[R0, #+76]
   2270                return;
   \   00000028   0x4770             BX       LR
   2271              }
   2272              
   2273              /* Disable RXNE interrupt */
   2274              __HAL_SPI_DISABLE_IT(hspi, SPI_IT_RXNE);
   \                     ??SPI_2linesRxISR_16BIT_1: (+1)
   \   0000002A   0x6851             LDR      R1,[R2, #+4]
   \   0000002C   0xF021 0x0140      BIC      R1,R1,#0x40
   \   00000030   0x6051             STR      R1,[R2, #+4]
   2275          
   2276              if(hspi->TxXferCount == 0)
   \   00000032   0x8FC1             LDRH     R1,[R0, #+62]
   \   00000034   0x2900             CMP      R1,#+0
   \   00000036   0xBF08             IT       EQ 
   2277              {
   2278                SPI_CloseRxTx_ISR(hspi);
   \   00000038   0x.... 0x....      BEQ.W    SPI_CloseRxTx_ISR
   2279              }
   2280            }
   2281          }
   \                     ??SPI_2linesRxISR_16BIT_0: (+1)
   \   0000003C   0x4770             BX       LR               ;; return
   2282          
   2283          /**
   2284            * @brief  Manage the CRC 16bit receive for Transmit and Receive in Interrupt mode
   2285            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   2286            *               the configuration information for SPI module.
   2287            * @retval None
   2288            */

   \                                 In section .text, align 4, keep-with-next
   2289          static void SPI_2linesRxISR_16BITCRC(struct __SPI_HandleTypeDef *hspi)
   2290          {
   \                     SPI_2linesRxISR_16BITCRC: (+1)
   \   00000000   0xB082             SUB      SP,SP,#+8
   2291            /* Receive data in 16 Bit mode */
   2292            __IO uint16_t tmpreg = hspi->Instance->DR;
   \   00000002   0x6801             LDR      R1,[R0, #+0]
   \   00000004   0x68CA             LDR      R2,[R1, #+12]
   \   00000006   0xF8AD 0x2000      STRH     R2,[SP, #+0]
   2293            UNUSED(tmpreg); /* To avoid GCC warning */
   \   0000000A   0xF8BD 0x2000      LDRH     R2,[SP, #+0]
   2294          
   2295            /* Disable RXNE interrupt */
   2296            __HAL_SPI_DISABLE_IT(hspi, SPI_IT_RXNE);
   \   0000000E   0x684A             LDR      R2,[R1, #+4]
   \   00000010   0xF022 0x0240      BIC      R2,R2,#0x40
   \   00000014   0xF8C1 0x2004      STR.W    R2,[R1, #+4]
   2297          
   2298            SPI_CloseRxTx_ISR(hspi);
   \   00000018                      REQUIRE ?Subroutine8
   \   00000018                      ;; // Fall through to label ?Subroutine8
   2299          }
   2300          
   2301          /**
   2302            * @brief  Tx Handler for Transmit and Receive in Interrupt mode
   2303            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   2304            *               the configuration information for SPI module.
   2305            * @retval None
   2306            */

   \                                 In section .text, align 4, keep-with-next
   2307          static void SPI_2linesTxISR_16BIT(struct __SPI_HandleTypeDef *hspi)
   2308          {
   2309            /* Transmit data in 16 Bit mode */
   2310            hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
   \                     SPI_2linesTxISR_16BIT: (+1)
   \   00000000   0x6B81             LDR      R1,[R0, #+56]
   \   00000002   0x6802             LDR      R2,[R0, #+0]
   \   00000004   0xF831 0x3B02      LDRH     R3,[R1], #+2
   \   00000008   0x60D3             STR      R3,[R2, #+12]
   2311            hspi->pTxBuffPtr += sizeof(uint16_t);
   \   0000000A   0x6381             STR      R1,[R0, #+56]
   2312            hspi->TxXferCount--;
   \   0000000C   0x8FC1             LDRH     R1,[R0, #+62]
   \   0000000E   0x1E49             SUBS     R1,R1,#+1
   \   00000010   0x87C1             STRH     R1,[R0, #+62]
   2313            
   2314            /* Enable CRC Transmission */
   2315            if(hspi->TxXferCount == 0)
   \   00000012   0xB289             UXTH     R1,R1
   \   00000014   0xB989             CBNZ.N   R1,??SPI_2linesTxISR_16BIT_0
   2316            {
   2317              if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   \   00000016   0x6A81             LDR      R1,[R0, #+40]
   \   00000018   0xF5B1 0x5F00      CMP      R1,#+8192
   \   0000001C   0xD103             BNE.N    ??SPI_2linesTxISR_16BIT_1
   2318              {
   2319                hspi->Instance->CR1 |= SPI_CR1_CRCNEXT;
   \   0000001E   0x6811             LDR      R1,[R2, #+0]
   \   00000020   0xF441 0x5180      ORR      R1,R1,#0x1000
   \   00000024   0x6011             STR      R1,[R2, #+0]
   2320              }
   2321              /* Disable TXE interrupt */
   2322              __HAL_SPI_DISABLE_IT(hspi, SPI_IT_TXE);
   \                     ??SPI_2linesTxISR_16BIT_1: (+1)
   \   00000026   0x6851             LDR      R1,[R2, #+4]
   \   00000028   0xF021 0x0180      BIC      R1,R1,#0x80
   \   0000002C   0x6051             STR      R1,[R2, #+4]
   2323          
   2324              if(hspi->RxXferCount == 0)
   \   0000002E   0xF8B0 0x1046      LDRH     R1,[R0, #+70]
   \   00000032   0x2900             CMP      R1,#+0
   \   00000034   0xBF08             IT       EQ 
   2325              {
   2326                SPI_CloseRxTx_ISR(hspi);
   \   00000036   0x.... 0x....      BEQ.W    SPI_CloseRxTx_ISR
   2327              }
   2328            }
   2329          }
   \                     ??SPI_2linesTxISR_16BIT_0: (+1)
   \   0000003A   0x4770             BX       LR               ;; return
   2330          
   2331          /**
   2332            * @brief  Manage the CRC receive in Interrupt context
   2333            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   2334            *               the configuration information for SPI module.
   2335            * @retval None
   2336            */

   \                                 In section .text, align 2, keep-with-next
   2337          static void SPI_RxISR_8BITCRC(struct __SPI_HandleTypeDef *hspi)
   2338          {
   \                     SPI_RxISR_8BITCRC: (+1)
   \   00000000   0xB082             SUB      SP,SP,#+8
   2339            __IO uint8_t tmpreg;
   2340            tmpreg = *((__IO uint8_t*)&hspi->Instance->DR);
   \   00000002   0x6801             LDR      R1,[R0, #+0]
   \   00000004   0x7B09             LDRB     R1,[R1, #+12]
   \   00000006   0xF88D 0x1000      STRB     R1,[SP, #+0]
   2341            UNUSED(tmpreg); /* To avoid GCC warning */
   \   0000000A   0xF89D 0x1000      LDRB     R1,[SP, #+0]
   2342          
   2343            hspi->CRCSize--;
   \   0000000E   0x6C81             LDR      R1,[R0, #+72]
   \   00000010   0x1E49             SUBS     R1,R1,#+1
   \   00000012   0x6481             STR      R1,[R0, #+72]
   2344            
   2345            if(hspi->CRCSize == 0)
   \   00000014   0xD100             BNE.N    ??SPI_RxISR_8BITCRC_0
   2346            { 
   2347              SPI_CloseRx_ISR(hspi);
   \   00000016   0x....             B.N      ?Subroutine9
   2348            }
   2349          }
   \                     ??SPI_RxISR_8BITCRC_0: (+1)
   \   00000018   0xB002             ADD      SP,SP,#+8
   \   0000001A   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine9: (+1)
   \   00000000   0xB002             ADD      SP,SP,#+8
   \   00000002   0x....             B.N      SPI_CloseRx_ISR
   2350          
   2351          /**
   2352            * @brief  Manage the receive in Interrupt context
   2353            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   2354            *               the configuration information for SPI module.
   2355            * @retval None
   2356            */

   \                                 In section .text, align 4, keep-with-next
   2357          static void SPI_RxISR_8BIT(struct __SPI_HandleTypeDef *hspi)
   2358          {
   2359            *hspi->pRxBuffPtr++ = (*(__IO uint8_t *)&hspi->Instance->DR);
   \                     SPI_RxISR_8BIT: (+1)
   \   00000000   0x6C01             LDR      R1,[R0, #+64]
   \   00000002   0x1C4A             ADDS     R2,R1,#+1
   \   00000004   0x6402             STR      R2,[R0, #+64]
   \   00000006   0x6802             LDR      R2,[R0, #+0]
   \   00000008   0x7B13             LDRB     R3,[R2, #+12]
   \   0000000A   0x700B             STRB     R3,[R1, #+0]
   2360            hspi->RxXferCount--;
   \   0000000C   0xF8B0 0x1046      LDRH     R1,[R0, #+70]
   \   00000010   0x1E49             SUBS     R1,R1,#+1
   \   00000012   0xF8A0 0x1046      STRH     R1,[R0, #+70]
   2361          
   2362            /* Enable CRC Transmission */
   2363            if((hspi->RxXferCount == 1) && (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE))
   \   00000016   0xB289             UXTH     R1,R1
   \   00000018   0x2901             CMP      R1,#+1
   \   0000001A   0xD104             BNE.N    ??SPI_RxISR_8BIT_0
   \   0000001C   0x6A80             LDR      R0,[R0, #+40]
   \   0000001E   0xF5B0 0x5F00      CMP      R0,#+8192
   \   00000022   0xD109             BNE.N    ??SPI_RxISR_8BIT_1
   2364            {
   2365              hspi->Instance->CR1 |= SPI_CR1_CRCNEXT;
   \   00000024   0x....             B.N      ?Subroutine4
   2366            }
   2367          
   2368            if(hspi->RxXferCount == 0)
   \                     ??SPI_RxISR_8BIT_0: (+1)
   \   00000026   0xB939             CBNZ.N   R1,??SPI_RxISR_8BIT_1
   2369            {
   2370              if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   \   00000028   0x6A81             LDR      R1,[R0, #+40]
   \   0000002A   0xF5B1 0x5F00      CMP      R1,#+8192
   \   0000002E   0xBF18             IT       NE 
   2371              {
   2372                hspi->RxISR =  SPI_RxISR_8BITCRC;
   2373                return;
   2374              }
   2375              SPI_CloseRx_ISR(hspi);
   \   00000030   0x.... 0x....      BNE.W    SPI_CloseRx_ISR
   \   00000034   0x....             LDR.N    R1,??DataTable1
   \   00000036   0x64C1             STR      R1,[R0, #+76]
   2376            }
   2377          }
   \                     ??SPI_RxISR_8BIT_1: (+1)
   \   00000038   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine4: (+1)
   \   00000000   0x6810             LDR      R0,[R2, #+0]
   \   00000002   0xF440 0x5080      ORR      R0,R0,#0x1000
   \   00000006   0x6010             STR      R0,[R2, #+0]
   \   00000008   0x4770             BX       LR
   2378          
   2379          /**
   2380            * @brief  Manage the CRC 16bit receive in Interrupt context
   2381            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   2382            *               the configuration information for SPI module.
   2383            * @retval None
   2384            */

   \                                 In section .text, align 2, keep-with-next
   2385          static void SPI_RxISR_16BITCRC(struct __SPI_HandleTypeDef *hspi)
   2386          {
   \                     SPI_RxISR_16BITCRC: (+1)
   \   00000000   0xB082             SUB      SP,SP,#+8
   2387            __IO uint16_t tmpreg;
   2388            
   2389            tmpreg = hspi->Instance->DR;
   \   00000002   0x6801             LDR      R1,[R0, #+0]
   \   00000004   0x68CA             LDR      R2,[R1, #+12]
   \   00000006   0xF8AD 0x2000      STRH     R2,[SP, #+0]
   2390            UNUSED(tmpreg); /* To avoid GCC warning */
   \   0000000A   0xF8BD 0x2000      LDRH     R2,[SP, #+0]
   2391          
   2392            /* Disable RXNE and ERR interrupt */
   2393            __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_RXNE | SPI_IT_ERR));
   \   0000000E   0x684A             LDR      R2,[R1, #+4]
   \   00000010   0xF022 0x0260      BIC      R2,R2,#0x60
   \   00000014   0x604A             STR      R2,[R1, #+4]
   2394            
   2395            SPI_CloseRx_ISR(hspi);
   \   00000016                      REQUIRE ?Subroutine9
   \   00000016                      ;; // Fall through to label ?Subroutine9
   2396          }
   2397          
   2398          /**
   2399            * @brief  Manage the 16Bit receive in Interrupt context
   2400            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   2401            *               the configuration information for SPI module.
   2402            * @retval None
   2403            */

   \                                 In section .text, align 4, keep-with-next
   2404          static void SPI_RxISR_16BIT(struct __SPI_HandleTypeDef *hspi)
   2405          {
   2406            *((uint16_t *)hspi->pRxBuffPtr) = hspi->Instance->DR;
   \                     SPI_RxISR_16BIT: (+1)
   \   00000000   0x6802             LDR      R2,[R0, #+0]
   \   00000002   0x6C01             LDR      R1,[R0, #+64]
   \   00000004   0x68D3             LDR      R3,[R2, #+12]
   \   00000006   0xF821 0x3B02      STRH     R3,[R1], #+2
   2407            hspi->pRxBuffPtr += sizeof(uint16_t);
   \   0000000A   0x6401             STR      R1,[R0, #+64]
   2408            hspi->RxXferCount--;
   \   0000000C   0xF8B0 0x1046      LDRH     R1,[R0, #+70]
   \   00000010   0x1E49             SUBS     R1,R1,#+1
   \   00000012   0xF8A0 0x1046      STRH     R1,[R0, #+70]
   2409            
   2410            /* Enable CRC Transmission */
   2411            if((hspi->RxXferCount == 1) && (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE))
   \   00000016   0xB289             UXTH     R1,R1
   \   00000018   0x2901             CMP      R1,#+1
   \   0000001A   0xD104             BNE.N    ??SPI_RxISR_16BIT_0
   \   0000001C   0x6A80             LDR      R0,[R0, #+40]
   \   0000001E   0xF5B0 0x5F00      CMP      R0,#+8192
   \   00000022   0xD109             BNE.N    ??SPI_RxISR_16BIT_1
   2412            {
   2413              hspi->Instance->CR1 |= SPI_CR1_CRCNEXT;
   \   00000024   0x....             B.N      ?Subroutine4
   2414            }
   2415            
   2416            if(hspi->RxXferCount == 0)
   \                     ??SPI_RxISR_16BIT_0: (+1)
   \   00000026   0xB939             CBNZ.N   R1,??SPI_RxISR_16BIT_1
   2417            {    
   2418              if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   \   00000028   0x6A81             LDR      R1,[R0, #+40]
   \   0000002A   0xF5B1 0x5F00      CMP      R1,#+8192
   \   0000002E   0xBF18             IT       NE 
   2419              {
   2420                hspi->RxISR = SPI_RxISR_16BITCRC;
   2421                return;
   2422              }
   2423              SPI_CloseRx_ISR(hspi);
   \   00000030   0x.... 0x....      BNE.W    SPI_CloseRx_ISR
   \   00000034   0x....             LDR.N    R1,??DataTable1_1
   \   00000036   0x64C1             STR      R1,[R0, #+76]
   2424            }
   2425          }
   \                     ??SPI_RxISR_16BIT_1: (+1)
   \   00000038   0x4770             BX       LR               ;; return
   2426          
   2427          /**
   2428            * @brief  Handle the data 8Bit transmit in Interrupt mode
   2429            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   2430            *               the configuration information for SPI module.
   2431            * @retval None
   2432            */

   \                                 In section .text, align 4, keep-with-next
   2433          static void SPI_TxISR_8BIT(struct __SPI_HandleTypeDef *hspi)
   2434          {
   2435            *(__IO uint8_t *)&hspi->Instance->DR = (*hspi->pTxBuffPtr++);
   \                     SPI_TxISR_8BIT: (+1)
   \   00000000   0xF100 0x0238      ADD      R2,R0,#+56
   \   00000004   0x6801             LDR      R1,[R0, #+0]
   \   00000006   0x6813             LDR      R3,[R2, #+0]
   \   00000008   0x1C5B             ADDS     R3,R3,#+1
   \   0000000A   0x6013             STR      R3,[R2, #+0]
   \   0000000C   0x1E5B             SUBS     R3,R3,#+1
   \   0000000E   0x781B             LDRB     R3,[R3, #+0]
   \   00000010   0x730B             STRB     R3,[R1, #+12]
   2436            hspi->TxXferCount--;
   \   00000012   0x88D3             LDRH     R3,[R2, #+6]
   \   00000014   0x1E5B             SUBS     R3,R3,#+1
   \   00000016   0x80D3             STRH     R3,[R2, #+6]
   2437            
   2438            if(hspi->TxXferCount == 0)
   \   00000018   0xB29B             UXTH     R3,R3
   \   0000001A   0xB943             CBNZ.N   R3,??SPI_TxISR_8BIT_0
   2439            {
   2440              if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   \   0000001C   0x6A82             LDR      R2,[R0, #+40]
   \   0000001E   0xF5B2 0x5F00      CMP      R2,#+8192
   \   00000022   0xD103             BNE.N    ??SPI_TxISR_8BIT_1
   2441              {
   2442                /* Enable CRC Transmission */
   2443                hspi->Instance->CR1 |= SPI_CR1_CRCNEXT;
   \   00000024   0x680A             LDR      R2,[R1, #+0]
   \   00000026   0xF442 0x5280      ORR      R2,R2,#0x1000
   \   0000002A   0x600A             STR      R2,[R1, #+0]
   2444              }
   2445              SPI_CloseTx_ISR(hspi);
   \                     ??SPI_TxISR_8BIT_1: (+1)
   \   0000002C   0x....             B.N      SPI_CloseTx_ISR
   2446            }
   2447          }
   \                     ??SPI_TxISR_8BIT_0: (+1)
   \   0000002E   0x4770             BX       LR               ;; return
   2448          
   2449          /**
   2450            * @brief  Handle the data 16Bit transmit in Interrupt mode
   2451            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   2452            *               the configuration information for SPI module.
   2453            * @retval None
   2454            */

   \                                 In section .text, align 4, keep-with-next
   2455          static void SPI_TxISR_16BIT(struct __SPI_HandleTypeDef *hspi)
   2456          { 
   2457            /* Transmit data in 16 Bit mode */
   2458            hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
   \                     SPI_TxISR_16BIT: (+1)
   \   00000000   0x6B81             LDR      R1,[R0, #+56]
   \   00000002   0x6802             LDR      R2,[R0, #+0]
   \   00000004   0xF831 0x3B02      LDRH     R3,[R1], #+2
   \   00000008   0x60D3             STR      R3,[R2, #+12]
   2459            hspi->pTxBuffPtr += sizeof(uint16_t);
   \   0000000A   0x6381             STR      R1,[R0, #+56]
   2460            hspi->TxXferCount--;
   \   0000000C   0x8FC1             LDRH     R1,[R0, #+62]
   \   0000000E   0x1E49             SUBS     R1,R1,#+1
   \   00000010   0x87C1             STRH     R1,[R0, #+62]
   2461            
   2462            if(hspi->TxXferCount == 0)
   \   00000012   0xB289             UXTH     R1,R1
   \   00000014   0xB941             CBNZ.N   R1,??SPI_TxISR_16BIT_0
   2463            {
   2464              if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   \   00000016   0x6A81             LDR      R1,[R0, #+40]
   \   00000018   0xF5B1 0x5F00      CMP      R1,#+8192
   \   0000001C   0xD103             BNE.N    ??SPI_TxISR_16BIT_1
   2465              {
   2466                /* Enable CRC Transmission */
   2467                hspi->Instance->CR1 |= SPI_CR1_CRCNEXT;
   \   0000001E   0x6811             LDR      R1,[R2, #+0]
   \   00000020   0xF441 0x5180      ORR      R1,R1,#0x1000
   \   00000024   0x6011             STR      R1,[R2, #+0]
   2468              }
   2469              SPI_CloseTx_ISR(hspi);
   \                     ??SPI_TxISR_16BIT_1: (+1)
   \   00000026   0x....             B.N      SPI_CloseTx_ISR
   2470            }
   2471          }
   \                     ??SPI_TxISR_16BIT_0: (+1)
   \   00000028   0x4770             BX       LR               ;; return
   2472          
   2473          /**
   2474            * @brief This function handles SPI Communication Timeout.
   2475            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   2476            *               the configuration information for SPI module.
   2477            * @param Flag : SPI flag to check
   2478            * @param State : flag state to check
   2479            * @param Timeout : Timeout duration
   2480            * @retval HAL status
   2481            */

   \                                 In section .text, align 2, keep-with-next
   2482          static HAL_StatusTypeDef SPI_WaitFlagStateUntilTimeout(SPI_HandleTypeDef *hspi, uint32_t Flag, uint32_t State, uint32_t Timeout)
   2483          {
   \                     SPI_WaitFlagStateUntilTimeout: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
   \   00000008   0x4690             MOV      R8,R2
   \   0000000A   0x461F             MOV      R7,R3
   2484            uint32_t tickstart = HAL_GetTick();
   \   0000000C   0x.... 0x....      BL       HAL_GetTick
   \   00000010   0x4606             MOV      R6,R0
   2485          
   2486            while((hspi->Instance->SR & Flag) != State)
   \                     ??SPI_WaitFlagStateUntilTimeout_0: (+1)
   \   00000012   0x6820             LDR      R0,[R4, #+0]
   \   00000014   0x6880             LDR      R0,[R0, #+8]
   \   00000016   0x4028             ANDS     R0,R5,R0
   \   00000018   0x4540             CMP      R0,R8
   \   0000001A   0xD032             BEQ.N    ??SPI_WaitFlagStateUntilTimeout_1
   2487            {
   2488              if(Timeout != HAL_MAX_DELAY)
   \   0000001C   0xF117 0x0F01      CMN      R7,#+1
   \   00000020   0xD0F7             BEQ.N    ??SPI_WaitFlagStateUntilTimeout_0
   2489              {
   2490                if((Timeout == 0) || ((HAL_GetTick()-tickstart) >= Timeout))
   \   00000022   0xB127             CBZ.N    R7,??SPI_WaitFlagStateUntilTimeout_2
   \   00000024   0x.... 0x....      BL       HAL_GetTick
   \   00000028   0x1B80             SUBS     R0,R0,R6
   \   0000002A   0x42B8             CMP      R0,R7
   \   0000002C   0xD3F1             BCC.N    ??SPI_WaitFlagStateUntilTimeout_0
   2491                {
   2492                  /* Disable the SPI and reset the CRC: the CRC value should be cleared
   2493                  on both master and slave sides in order to resynchronize the master
   2494                  and slave for their respective CRC calculation */
   2495          
   2496                  /* Disable TXE, RXNE and ERR interrupts for the interrupt process */
   2497                  __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_RXNE | SPI_IT_ERR));
   \                     ??SPI_WaitFlagStateUntilTimeout_2: (+1)
   \   0000002E   0x6820             LDR      R0,[R4, #+0]
   \   00000030   0x6841             LDR      R1,[R0, #+4]
   \   00000032   0xF021 0x01E0      BIC      R1,R1,#0xE0
   \   00000036   0x6041             STR      R1,[R0, #+4]
   2498          
   2499                  if((hspi->Init.Mode == SPI_MODE_MASTER)&&((hspi->Init.Direction == SPI_DIRECTION_1LINE)||(hspi->Init.Direction == SPI_DIRECTION_2LINES_RXONLY)))
   \   00000038   0x6861             LDR      R1,[R4, #+4]
   \   0000003A   0xF5B1 0x7F82      CMP      R1,#+260
   \   0000003E   0xD10A             BNE.N    ??SPI_WaitFlagStateUntilTimeout_3
   \   00000040   0x68A1             LDR      R1,[R4, #+8]
   \   00000042   0xF5B1 0x4F00      CMP      R1,#+32768
   \   00000046   0xBF18             IT       NE 
   \   00000048   0xF5B1 0x6F80      CMPNE    R1,#+1024
   \   0000004C   0xD103             BNE.N    ??SPI_WaitFlagStateUntilTimeout_3
   2500                  {
   2501                    /* Disable SPI peripheral */
   2502                    __HAL_SPI_DISABLE(hspi);
   \   0000004E   0x6801             LDR      R1,[R0, #+0]
   \   00000050   0xF021 0x0140      BIC      R1,R1,#0x40
   \   00000054   0x6001             STR      R1,[R0, #+0]
   2503                  }
   2504          
   2505                  /* Reset CRC Calculation */
   2506                  if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   \                     ??SPI_WaitFlagStateUntilTimeout_3: (+1)
   \   00000056   0x6AA1             LDR      R1,[R4, #+40]
   \   00000058   0xF5B1 0x5F00      CMP      R1,#+8192
   \   0000005C   0xD108             BNE.N    ??SPI_WaitFlagStateUntilTimeout_4
   2507                  {
   2508                    SPI_RESET_CRC(hspi);
   \   0000005E   0x6801             LDR      R1,[R0, #+0]
   \   00000060   0xF64D 0x72FF      MOVW     R2,#+57343
   \   00000064   0x4011             ANDS     R1,R2,R1
   \   00000066   0x6001             STR      R1,[R0, #+0]
   \   00000068   0x6801             LDR      R1,[R0, #+0]
   \   0000006A   0xF441 0x5100      ORR      R1,R1,#0x2000
   \   0000006E   0x6001             STR      R1,[R0, #+0]
   2509                  }
   2510                  
   2511                  hspi->State= HAL_SPI_STATE_READY;
   \                     ??SPI_WaitFlagStateUntilTimeout_4: (+1)
   \   00000070   0xF104 0x005C      ADD      R0,R4,#+92
   \   00000074   0x2101             MOVS     R1,#+1
   \   00000076   0x7041             STRB     R1,[R0, #+1]
   2512                  
   2513                  /* Process Unlocked */
   2514                  __HAL_UNLOCK(hspi);
   \   00000078   0x2100             MOVS     R1,#+0
   \   0000007A   0x7001             STRB     R1,[R0, #+0]
   2515                  
   2516                  return HAL_TIMEOUT;
   \   0000007C   0x2003             MOVS     R0,#+3
   \   0000007E   0xE8BD 0x81F0      POP      {R4-R8,PC}
   2517                }
   2518              }
   2519            }
   2520            
   2521            return HAL_OK;      
   \                     ??SPI_WaitFlagStateUntilTimeout_1: (+1)
   \   00000082   0x2000             MOVS     R0,#+0
   \   00000084   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   2522          }
   2523          
   2524          /**
   2525            * @brief This function handles SPI Communication Timeout.
   2526            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   2527            *               the configuration information for SPI module.
   2528            * @param Fifo : Fifo to check
   2529            * @param State : Fifo state to check
   2530            * @param Timeout : Timeout duration
   2531            * @retval HAL status
   2532            */

   \                                 In section .text, align 2, keep-with-next
   2533          static HAL_StatusTypeDef SPI_WaitFifoStateUntilTimeout(SPI_HandleTypeDef *hspi, uint32_t Fifo, uint32_t State, uint32_t Timeout)
   2534          {
   \                     SPI_WaitFifoStateUntilTimeout: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB082             SUB      SP,SP,#+8
   \   00000006   0x4604             MOV      R4,R0
   \   00000008   0x460D             MOV      R5,R1
   \   0000000A   0x4616             MOV      R6,R2
   \   0000000C   0x461F             MOV      R7,R3
   2535            __IO uint8_t tmpreg;
   2536            uint32_t tickstart = HAL_GetTick();
   \   0000000E   0x.... 0x....      BL       HAL_GetTick
   \   00000012   0x4680             MOV      R8,R0
   2537          
   2538            while((hspi->Instance->SR & Fifo) != State)
   \                     ??SPI_WaitFifoStateUntilTimeout_0: (+1)
   \   00000014   0x6820             LDR      R0,[R4, #+0]
   \   00000016   0x6881             LDR      R1,[R0, #+8]
   \   00000018   0x4029             ANDS     R1,R5,R1
   \   0000001A   0x42B1             CMP      R1,R6
   \   0000001C   0xD03C             BEQ.N    ??SPI_WaitFifoStateUntilTimeout_1
   2539            {
   2540              if((Fifo == SPI_SR_FRLVL) && (State == SPI_FRLVL_EMPTY))
   \   0000001E   0xF5B5 0x6FC0      CMP      R5,#+1536
   \   00000022   0xBF08             IT       EQ 
   \   00000024   0x2E00             CMPEQ    R6,#+0
   \   00000026   0xD104             BNE.N    ??SPI_WaitFifoStateUntilTimeout_2
   2541              {
   2542                tmpreg = *((__IO uint8_t*)&hspi->Instance->DR);
   \   00000028   0x7B00             LDRB     R0,[R0, #+12]
   \   0000002A   0xF88D 0x0000      STRB     R0,[SP, #+0]
   2543                UNUSED(tmpreg); /* To avoid GCC warning */
   \   0000002E   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   2544              }
   2545          
   2546              if(Timeout != HAL_MAX_DELAY)
   \                     ??SPI_WaitFifoStateUntilTimeout_2: (+1)
   \   00000032   0xF117 0x0F01      CMN      R7,#+1
   \   00000036   0xD0ED             BEQ.N    ??SPI_WaitFifoStateUntilTimeout_0
   2547              {
   2548                if((Timeout == 0) || ((HAL_GetTick()-tickstart) >= Timeout))
   \   00000038   0xB12F             CBZ.N    R7,??SPI_WaitFifoStateUntilTimeout_3
   \   0000003A   0x.... 0x....      BL       HAL_GetTick
   \   0000003E   0xEBA0 0x0008      SUB      R0,R0,R8
   \   00000042   0x42B8             CMP      R0,R7
   \   00000044   0xD3E6             BCC.N    ??SPI_WaitFifoStateUntilTimeout_0
   2549                {
   2550                  /* Disable the SPI and reset the CRC: the CRC value should be cleared
   2551                            on both master and slave sides in order to resynchronize the master
   2552                           and slave for their respective CRC calculation */
   2553          
   2554                  /* Disable TXE, RXNE and ERR interrupts for the interrupt process */
   2555                  __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_RXNE | SPI_IT_ERR));
   \                     ??SPI_WaitFifoStateUntilTimeout_3: (+1)
   \   00000046   0x6820             LDR      R0,[R4, #+0]
   \   00000048   0x6841             LDR      R1,[R0, #+4]
   \   0000004A   0xF021 0x01E0      BIC      R1,R1,#0xE0
   \   0000004E   0x6041             STR      R1,[R0, #+4]
   2556          
   2557                  if((hspi->Init.Mode == SPI_MODE_MASTER)&&((hspi->Init.Direction == SPI_DIRECTION_1LINE)||(hspi->Init.Direction == SPI_DIRECTION_2LINES_RXONLY)))
   \   00000050   0x6861             LDR      R1,[R4, #+4]
   \   00000052   0xF5B1 0x7F82      CMP      R1,#+260
   \   00000056   0xD10A             BNE.N    ??SPI_WaitFifoStateUntilTimeout_4
   \   00000058   0x68A1             LDR      R1,[R4, #+8]
   \   0000005A   0xF5B1 0x4F00      CMP      R1,#+32768
   \   0000005E   0xBF18             IT       NE 
   \   00000060   0xF5B1 0x6F80      CMPNE    R1,#+1024
   \   00000064   0xD103             BNE.N    ??SPI_WaitFifoStateUntilTimeout_4
   2558                  {
   2559                    /* Disable SPI peripheral */
   2560                    __HAL_SPI_DISABLE(hspi);
   \   00000066   0x6801             LDR      R1,[R0, #+0]
   \   00000068   0xF021 0x0140      BIC      R1,R1,#0x40
   \   0000006C   0x6001             STR      R1,[R0, #+0]
   2561                  }
   2562          
   2563                  /* Reset CRC Calculation */
   2564                  if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   \                     ??SPI_WaitFifoStateUntilTimeout_4: (+1)
   \   0000006E   0x6AA1             LDR      R1,[R4, #+40]
   \   00000070   0xF5B1 0x5F00      CMP      R1,#+8192
   \   00000074   0xD108             BNE.N    ??SPI_WaitFifoStateUntilTimeout_5
   2565                  {
   2566                    SPI_RESET_CRC(hspi);
   \   00000076   0x6801             LDR      R1,[R0, #+0]
   \   00000078   0xF64D 0x72FF      MOVW     R2,#+57343
   \   0000007C   0x4011             ANDS     R1,R2,R1
   \   0000007E   0x6001             STR      R1,[R0, #+0]
   \   00000080   0x6801             LDR      R1,[R0, #+0]
   \   00000082   0xF441 0x5100      ORR      R1,R1,#0x2000
   \   00000086   0x6001             STR      R1,[R0, #+0]
   2567                  }
   2568          
   2569                  hspi->State = HAL_SPI_STATE_READY;
   \                     ??SPI_WaitFifoStateUntilTimeout_5: (+1)
   \   00000088   0xF104 0x005C      ADD      R0,R4,#+92
   \   0000008C   0x2101             MOVS     R1,#+1
   \   0000008E   0x7041             STRB     R1,[R0, #+1]
   2570          
   2571                  /* Process Unlocked */
   2572                  __HAL_UNLOCK(hspi);
   \   00000090   0x2100             MOVS     R1,#+0
   \   00000092   0x7001             STRB     R1,[R0, #+0]
   2573          
   2574                  return HAL_TIMEOUT;
   \   00000094   0x.... 0x....      B.W      ?Subroutine0
   2575                }
   2576              }
   2577            }
   2578          
   2579            return HAL_OK;
   \                     ??SPI_WaitFifoStateUntilTimeout_1: (+1)
   \   00000098   0x2000             MOVS     R0,#+0
   \   0000009A   0xE8BD 0x81F6      POP      {R1,R2,R4-R8,PC}  ;; return
   2580          }
   2581          
   2582          /**
   2583            * @brief This function handles the check of the RX transaction complete.
   2584            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   2585            *               the configuration information for SPI module.
   2586            * @param Timeout : Timeout duration
   2587            * @retval None
   2588            */

   \                                 In section .text, align 2, keep-with-next
   2589          static HAL_StatusTypeDef SPI_EndRxTransaction(SPI_HandleTypeDef *hspi,  uint32_t Timeout)
   2590          {
   \                     SPI_EndRxTransaction: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   2591            if((hspi->Init.Mode == SPI_MODE_MASTER)&&((hspi->Init.Direction == SPI_DIRECTION_1LINE)||(hspi->Init.Direction == SPI_DIRECTION_2LINES_RXONLY)))
   \   00000006   0x6860             LDR      R0,[R4, #+4]
   \   00000008   0xF5B0 0x7F82      CMP      R0,#+260
   \   0000000C   0xD10B             BNE.N    ??SPI_EndRxTransaction_0
   \   0000000E   0x68A0             LDR      R0,[R4, #+8]
   \   00000010   0xF5B0 0x4F00      CMP      R0,#+32768
   \   00000014   0xBF18             IT       NE 
   \   00000016   0xF5B0 0x6F80      CMPNE    R0,#+1024
   \   0000001A   0xD104             BNE.N    ??SPI_EndRxTransaction_0
   2592            {
   2593              /* Disable SPI peripheral */
   2594              __HAL_SPI_DISABLE(hspi);
   \   0000001C   0x6820             LDR      R0,[R4, #+0]
   \   0000001E   0x6801             LDR      R1,[R0, #+0]
   \   00000020   0xF021 0x0140      BIC      R1,R1,#0x40
   \   00000024   0x6001             STR      R1,[R0, #+0]
   2595            }
   2596            if(SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_BSY, RESET, Timeout) != HAL_OK)
   \                     ??SPI_EndRxTransaction_0: (+1)
   \   00000026   0x462B             MOV      R3,R5
   \   00000028   0x2200             MOVS     R2,#+0
   \   0000002A   0x2180             MOVS     R1,#+128
   \   0000002C   0x4620             MOV      R0,R4
   \   0000002E   0x.... 0x....      BL       SPI_WaitFlagStateUntilTimeout
   \   00000032   0xB938             CBNZ.N   R0,??SPI_EndRxTransaction_1
   2597            {  
   2598              hspi->ErrorCode |= HAL_SPI_ERROR_FLAG;
   2599              return HAL_TIMEOUT;
   2600            }
   2601            if(SPI_WaitFifoStateUntilTimeout(hspi, SPI_FLAG_FRLVL, SPI_FRLVL_EMPTY, Timeout) != HAL_OK) 
   \   00000034   0x462B             MOV      R3,R5
   \   00000036   0x2200             MOVS     R2,#+0
   \   00000038   0xF44F 0x61C0      MOV      R1,#+1536
   \   0000003C   0x4620             MOV      R0,R4
   \   0000003E   0x.... 0x....      BL       SPI_WaitFifoStateUntilTimeout
   \   00000042   0xB120             CBZ.N    R0,??SPI_EndRxTransaction_2
   2602            {
   2603              hspi->ErrorCode |= HAL_SPI_ERROR_FLAG;
   \                     ??SPI_EndRxTransaction_1: (+1)
   \   00000044   0x6E20             LDR      R0,[R4, #+96]
   \   00000046   0xF040 0x0020      ORR      R0,R0,#0x20
   \   0000004A   0x6620             STR      R0,[R4, #+96]
   2604              return HAL_TIMEOUT;
   \   0000004C   0x2003             MOVS     R0,#+3
   2605            }
   2606            
   2607            return HAL_OK;
   \                     ??SPI_EndRxTransaction_2: (+1)
   \   0000004E   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   2608          }
   2609            
   2610          /**
   2611            * @brief This function handles the check of the RXTX or TX transaction complete.
   2612            * @param hspi: SPI handle
   2613            * @param Timeout : Timeout duration
   2614            */

   \                                 In section .text, align 2, keep-with-next
   2615          static HAL_StatusTypeDef SPI_EndRxTxTransaction(SPI_HandleTypeDef *hspi, uint32_t Timeout)
   2616          {
   \                     SPI_EndRxTxTransaction: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x460D             MOV      R5,R1
   \   00000004   0x4604             MOV      R4,R0
   2617            /* Procedure to check the transaction complete */
   2618            if(SPI_WaitFifoStateUntilTimeout(hspi, SPI_FLAG_FTLVL, SPI_FTLVL_EMPTY, Timeout) != HAL_OK)
   \   00000006   0x462B             MOV      R3,R5
   \   00000008   0x2200             MOVS     R2,#+0
   \   0000000A   0xF44F 0x51C0      MOV      R1,#+6144
   \   0000000E   0x.... 0x....      BL       SPI_WaitFifoStateUntilTimeout
   \   00000012   0xB970             CBNZ.N   R0,??SPI_EndRxTxTransaction_0
   2619            {
   2620              hspi->ErrorCode |= HAL_SPI_ERROR_FLAG;
   2621              return HAL_TIMEOUT;
   2622            }
   2623            if(SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_BSY, RESET, Timeout) != HAL_OK)
   \   00000014   0x462B             MOV      R3,R5
   \   00000016   0x2200             MOVS     R2,#+0
   \   00000018   0x2180             MOVS     R1,#+128
   \   0000001A   0x4620             MOV      R0,R4
   \   0000001C   0x.... 0x....      BL       SPI_WaitFlagStateUntilTimeout
   \   00000020   0xB938             CBNZ.N   R0,??SPI_EndRxTxTransaction_0
   2624            {
   2625              hspi->ErrorCode |= HAL_SPI_ERROR_FLAG;
   2626              return HAL_TIMEOUT;
   2627            }
   2628            if(SPI_WaitFifoStateUntilTimeout(hspi, SPI_FLAG_FRLVL, SPI_FRLVL_EMPTY, Timeout) != HAL_OK)
   \   00000022   0x462B             MOV      R3,R5
   \   00000024   0x2200             MOVS     R2,#+0
   \   00000026   0xF44F 0x61C0      MOV      R1,#+1536
   \   0000002A   0x4620             MOV      R0,R4
   \   0000002C   0x.... 0x....      BL       SPI_WaitFifoStateUntilTimeout
   \   00000030   0xB120             CBZ.N    R0,??SPI_EndRxTxTransaction_1
   2629            {
   2630              hspi->ErrorCode |= HAL_SPI_ERROR_FLAG;
   \                     ??SPI_EndRxTxTransaction_0: (+1)
   \   00000032   0x6E20             LDR      R0,[R4, #+96]
   \   00000034   0xF040 0x0020      ORR      R0,R0,#0x20
   \   00000038   0x6620             STR      R0,[R4, #+96]
   2631              return HAL_TIMEOUT;
   \   0000003A   0x2003             MOVS     R0,#+3
   2632            }
   2633            return HAL_OK;
   \                     ??SPI_EndRxTxTransaction_1: (+1)
   \   0000003C   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   2634          }
   2635          
   2636          /**
   2637            * @brief This function handles the close of the RXTX transaction.
   2638            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   2639            *               the configuration information for SPI module.
   2640            * @retval None
   2641            */

   \                                 In section .text, align 2, keep-with-next
   2642          static void SPI_CloseRxTx_ISR(SPI_HandleTypeDef *hspi)
   2643          {
   \                     SPI_CloseRxTx_ISR: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   2644            /* Disable ERR interrupt */
   2645            __HAL_SPI_DISABLE_IT(hspi, SPI_IT_ERR);
   \   00000002   0x6801             LDR      R1,[R0, #+0]
   \   00000004   0x684A             LDR      R2,[R1, #+4]
   \   00000006   0xF022 0x0220      BIC      R2,R2,#0x20
   \   0000000A   0x604A             STR      R2,[R1, #+4]
   2646          
   2647            /* Check if CRC error occurred */
   2648            if(__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_CRCERR) != RESET)
   \   0000000C   0x6E02             LDR      R2,[R0, #+96]
   \   0000000E   0x688B             LDR      R3,[R1, #+8]
   \   00000010   0x06DB             LSLS     R3,R3,#+27
   \   00000012   0xD509             BPL.N    ??SPI_CloseRxTx_ISR_0
   2649            {
   2650              hspi->State = HAL_SPI_STATE_READY;
   2651              hspi->ErrorCode|= HAL_SPI_ERROR_CRC;
   \   00000014   0xF042 0x0202      ORR      R2,R2,#0x2
   \   00000018   0x2301             MOVS     R3,#+1
   \   0000001A   0x6602             STR      R2,[R0, #+96]
   2652              __HAL_SPI_CLEAR_CRCERRFLAG(hspi);
   \   0000001C   0xF64F 0x72EF      MOVW     R2,#+65519
   \   00000020   0xF880 0x305D      STRB     R3,[R0, #+93]
   \   00000024   0x608A             STR      R2,[R1, #+8]
   2653              HAL_SPI_ErrorCallback(hspi);
   \   00000026   0xE013             B.N      ??SPI_CloseRxTx_ISR_1
   2654            }
   2655            else
   2656            {
   2657              if(hspi->ErrorCode == HAL_SPI_ERROR_NONE)
   \                     ??SPI_CloseRxTx_ISR_0: (+1)
   \   00000028   0xB97A             CBNZ.N   R2,??SPI_CloseRxTx_ISR_2
   2658              {
   2659                if(hspi->State == HAL_SPI_STATE_BUSY_RX)
   \   0000002A   0xF890 0x105D      LDRB     R1,[R0, #+93]
   \   0000002E   0x2904             CMP      R1,#+4
   \   00000030   0xD105             BNE.N    ??SPI_CloseRxTx_ISR_3
   2660                {
   2661                	hspi->State = HAL_SPI_STATE_READY;
   \   00000032   0x2101             MOVS     R1,#+1
   \   00000034   0xF880 0x105D      STRB     R1,[R0, #+93]
   2662                  HAL_SPI_RxCpltCallback(hspi);
   \   00000038   0x.... 0x....      BL       HAL_SPI_RxCpltCallback
   \   0000003C   0xBD01             POP      {R0,PC}
   2663                }
   2664                else
   2665                {
   2666                	hspi->State = HAL_SPI_STATE_READY;
   \                     ??SPI_CloseRxTx_ISR_3: (+1)
   \   0000003E   0x2101             MOVS     R1,#+1
   \   00000040   0xF880 0x105D      STRB     R1,[R0, #+93]
   2667                  HAL_SPI_TxRxCpltCallback(hspi);
   \   00000044   0x.... 0x....      BL       HAL_SPI_TxRxCpltCallback
   \   00000048   0xBD01             POP      {R0,PC}
   2668                }      
   2669              }
   2670              else
   2671              {
   2672                hspi->State = HAL_SPI_STATE_READY;
   \                     ??SPI_CloseRxTx_ISR_2: (+1)
   \   0000004A   0x2101             MOVS     R1,#+1
   \   0000004C   0xF880 0x105D      STRB     R1,[R0, #+93]
   2673                HAL_SPI_ErrorCallback(hspi);
   2674              }
   2675            }
   \                     ??SPI_CloseRxTx_ISR_1: (+1)
   \   00000050   0x....             B.N      ?Subroutine6
   2676          }
   2677          
   2678          /**
   2679            * @brief This function handles the close of the RX transaction.
   2680            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   2681            *               the configuration information for SPI module.
   2682            * @retval None
   2683            */

   \                                 In section .text, align 2, keep-with-next
   2684          static void SPI_CloseRx_ISR(SPI_HandleTypeDef *hspi)
   2685          {
   \                     SPI_CloseRx_ISR: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   2686              /* Disable RXNE and ERR interrupt */
   2687              __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_RXNE | SPI_IT_ERR));
   \   00000004   0x6820             LDR      R0,[R4, #+0]
   \   00000006   0x6841             LDR      R1,[R0, #+4]
   \   00000008   0xF021 0x0160      BIC      R1,R1,#0x60
   \   0000000C   0x6041             STR      R1,[R0, #+4]
   2688              
   2689              /* Check the end of the transaction */
   2690              SPI_EndRxTransaction(hspi,SPI_DEFAULT_TIMEOUT);
   \   0000000E   0x2132             MOVS     R1,#+50
   \   00000010   0x4620             MOV      R0,R4
   \   00000012   0x.... 0x....      BL       SPI_EndRxTransaction
   2691          
   2692              hspi->State = HAL_SPI_STATE_READY;
   \   00000016   0x2001             MOVS     R0,#+1
   \   00000018   0xF884 0x005D      STRB     R0,[R4, #+93]
   2693          
   2694              /* Check if CRC error occurred */
   2695              if(__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_CRCERR) != RESET)
   \   0000001C   0x6821             LDR      R1,[R4, #+0]
   \   0000001E   0x6E20             LDR      R0,[R4, #+96]
   \   00000020   0x688A             LDR      R2,[R1, #+8]
   \   00000022   0x06D2             LSLS     R2,R2,#+27
   \   00000024   0xD507             BPL.N    ??SPI_CloseRx_ISR_0
   2696              {
   2697                hspi->ErrorCode|= HAL_SPI_ERROR_CRC;
   \   00000026   0xF040 0x0002      ORR      R0,R0,#0x2
   \   0000002A   0x6620             STR      R0,[R4, #+96]
   2698                __HAL_SPI_CLEAR_CRCERRFLAG(hspi);
   \   0000002C   0xF64F 0x70EF      MOVW     R0,#+65519
   \   00000030   0x6088             STR      R0,[R1, #+8]
   2699                HAL_SPI_ErrorCallback(hspi);
   \   00000032   0x4620             MOV      R0,R4
   \   00000034   0xE005             B.N      ??SPI_CloseRx_ISR_1
   2700              }
   2701              else
   2702              {
   2703                if(hspi->ErrorCode == HAL_SPI_ERROR_NONE)
   \                     ??SPI_CloseRx_ISR_0: (+1)
   \   00000036   0x2800             CMP      R0,#+0
   \   00000038   0x4620             MOV      R0,R4
   \   0000003A   0xD102             BNE.N    ??SPI_CloseRx_ISR_1
   2704                {
   2705                  HAL_SPI_RxCpltCallback(hspi);
   \   0000003C   0x.... 0x....      BL       HAL_SPI_RxCpltCallback
   \   00000040   0xBD10             POP      {R4,PC}
   2706                }
   2707                else
   2708                {
   2709                  HAL_SPI_ErrorCallback(hspi);
   \                     ??SPI_CloseRx_ISR_1: (+1)
   \   00000042   0x.... 0x....      BL       HAL_SPI_ErrorCallback
   2710                }
   2711              }
   2712          }
   \   00000046   0xBD10             POP      {R4,PC}          ;; return
   2713          
   2714          /**
   2715            * @brief This function handles the close of the TX transaction.
   2716            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   2717            *               the configuration information for SPI module.
   2718            * @retval None
   2719            */

   \                                 In section .text, align 2, keep-with-next
   2720          static void SPI_CloseTx_ISR(SPI_HandleTypeDef *hspi)
   2721          {
   \                     SPI_CloseTx_ISR: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   2722            /* Disable TXE and ERR interrupt */
   2723            __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_ERR));
   \   00000002   0x6801             LDR      R1,[R0, #+0]
   \   00000004   0x684A             LDR      R2,[R1, #+4]
   \   00000006   0xF022 0x02A0      BIC      R2,R2,#0xA0
   \   0000000A   0x604A             STR      R2,[R1, #+4]
   2724          
   2725            /* Clear OVERUN flag in 2 Lines communication mode because received is not read */
   2726            if(hspi->Init.Direction == SPI_DIRECTION_2LINES)
   \   0000000C   0x6882             LDR      R2,[R0, #+8]
   \   0000000E   0xB92A             CBNZ.N   R2,??SPI_CloseTx_ISR_0
   2727            {
   2728              __HAL_SPI_CLEAR_OVRFLAG(hspi);
   \   00000010   0x9200             STR      R2,[SP, #+0]
   \   00000012   0x68CA             LDR      R2,[R1, #+12]
   \   00000014   0x9200             STR      R2,[SP, #+0]
   \   00000016   0x6889             LDR      R1,[R1, #+8]
   \   00000018   0x9100             STR      R1,[SP, #+0]
   \   0000001A   0x9900             LDR      R1,[SP, #+0]
   2729            }
   2730          
   2731            hspi->State = HAL_SPI_STATE_READY;
   \                     ??SPI_CloseTx_ISR_0: (+1)
   \   0000001C   0x2101             MOVS     R1,#+1
   \   0000001E   0xF880 0x105D      STRB     R1,[R0, #+93]
   2732            if(hspi->ErrorCode != HAL_SPI_ERROR_NONE)
   \   00000022   0x6E01             LDR      R1,[R0, #+96]
   \   00000024   0xB101             CBZ.N    R1,??SPI_CloseTx_ISR_1
   2733            {
   2734              HAL_SPI_ErrorCallback(hspi);
   \   00000026   0x....             B.N      ?Subroutine6
   2735            }
   2736            else
   2737            {
   2738              HAL_SPI_TxCpltCallback(hspi);
   \                     ??SPI_CloseTx_ISR_1: (+1)
   \   00000028                      REQUIRE ?Subroutine5
   \   00000028                      ;; // Fall through to label ?Subroutine5
   2739            }
   2740          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1:
   \   00000000   0x........         DC32     SPI_RxISR_8BITCRC

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_1:
   \   00000000   0x........         DC32     SPI_RxISR_16BITCRC
   2741          
   2742          /**
   2743            * @}
   2744            */
   2745          
   2746          #endif /* HAL_SPI_MODULE_ENABLED */
   2747          /**
   2748            * @}
   2749            */
   2750          
   2751          /**
   2752            * @}
   2753            */
   2754          
   2755          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   HAL_SPI_DMAPause
       0   HAL_SPI_DMAResume
       8   HAL_SPI_DMAStop
         8   -> HAL_DMA_Abort
      24   HAL_SPI_DeInit
        24   -> HAL_GetTick
        24   -> HAL_SPI_MspDeInit
       0   HAL_SPI_ErrorCallback
       0   HAL_SPI_GetError
       0   HAL_SPI_GetState
       8   HAL_SPI_IRQHandler
         0   -- Indirect call
         8   -> HAL_SPI_ErrorCallback
      16   HAL_SPI_Init
        16   -> HAL_SPI_MspInit
       0   HAL_SPI_MspDeInit
       0   HAL_SPI_MspInit
      32   HAL_SPI_Receive
        32   -> HAL_GetTick
        32   -> HAL_SPI_TransmitReceive
        32   -> SPI_EndRxTransaction
        32   -> SPI_WaitFlagStateUntilTimeout
      16   HAL_SPI_Receive_DMA
        16   -> HAL_DMA_Start_IT
         0   -> HAL_SPI_TransmitReceive_DMA
       8   HAL_SPI_Receive_IT
         0   -> HAL_SPI_TransmitReceive_IT
       0   HAL_SPI_RxCpltCallback
       0   HAL_SPI_RxHalfCpltCallback
      32   HAL_SPI_Transmit
        32   -> HAL_GetTick
        32   -> SPI_EndRxTxTransaction
      40   HAL_SPI_TransmitReceive
        40   -> HAL_GetTick
        40   -> SPI_WaitFifoStateUntilTimeout
        40   -> SPI_WaitFlagStateUntilTimeout
      16   HAL_SPI_TransmitReceive_DMA
        16   -> HAL_DMA_Start_IT
      16   HAL_SPI_TransmitReceive_IT
      16   HAL_SPI_Transmit_DMA
        16   -> HAL_DMA_Start_IT
       4   HAL_SPI_Transmit_IT
       0   HAL_SPI_TxCpltCallback
       0   HAL_SPI_TxHalfCpltCallback
       0   HAL_SPI_TxRxCpltCallback
       0   HAL_SPI_TxRxHalfCpltCallback
       0   SPI_2linesRxISR_16BIT
         0   -> SPI_CloseRxTx_ISR
       8   SPI_2linesRxISR_16BITCRC
         0   -> SPI_CloseRxTx_ISR
       0   SPI_2linesRxISR_8BIT
         0   -> SPI_CloseRxTx_ISR
       8   SPI_2linesRxISR_8BITCRC
         0   -> SPI_CloseRxTx_ISR
       0   SPI_2linesTxISR_16BIT
         0   -> SPI_CloseRxTx_ISR
       8   SPI_2linesTxISR_8BIT
         8   -> SPI_CloseRxTx_ISR
       8   SPI_CloseRxTx_ISR
         8   -> HAL_SPI_ErrorCallback
         8   -> HAL_SPI_RxCpltCallback
         8   -> HAL_SPI_TxRxCpltCallback
       8   SPI_CloseRx_ISR
         8   -> HAL_SPI_ErrorCallback
         8   -> HAL_SPI_RxCpltCallback
         8   -> SPI_EndRxTransaction
       8   SPI_CloseTx_ISR
         8   -> HAL_SPI_ErrorCallback
         8   -> HAL_SPI_TxCpltCallback
       8   SPI_DMAError
         8   -> HAL_SPI_ErrorCallback
       8   SPI_DMAHalfReceiveCplt
         8   -> HAL_SPI_RxHalfCpltCallback
       8   SPI_DMAHalfTransmitCplt
         8   -> HAL_SPI_TxHalfCpltCallback
       8   SPI_DMAHalfTransmitReceiveCplt
         8   -> HAL_SPI_TxRxHalfCpltCallback
      16   SPI_DMAReceiveCplt
        16   -> HAL_GetTick
        16   -> HAL_SPI_ErrorCallback
        16   -> HAL_SPI_RxCpltCallback
        16   -> SPI_EndRxTransaction
       8   SPI_DMATransmitCplt
         8   -> HAL_SPI_ErrorCallback
         8   -> HAL_SPI_TxCpltCallback
      16   SPI_DMATransmitReceiveCplt
        16   -> HAL_GetTick
        16   -> HAL_SPI_ErrorCallback
        16   -> HAL_SPI_TxRxCpltCallback
        16   -> SPI_EndRxTxTransaction
      16   SPI_EndRxTransaction
        16   -> SPI_WaitFifoStateUntilTimeout
        16   -> SPI_WaitFlagStateUntilTimeout
      16   SPI_EndRxTxTransaction
        16   -> SPI_WaitFifoStateUntilTimeout
        16   -> SPI_WaitFlagStateUntilTimeout
       0   SPI_RxISR_16BIT
         0   -> SPI_CloseRx_ISR
       8   SPI_RxISR_16BITCRC
         0   -> SPI_CloseRx_ISR
       0   SPI_RxISR_8BIT
         0   -> SPI_CloseRx_ISR
       8   SPI_RxISR_8BITCRC
         0   -> SPI_CloseRx_ISR
       0   SPI_TxISR_16BIT
         0   -> SPI_CloseTx_ISR
       0   SPI_TxISR_8BIT
         0   -> SPI_CloseTx_ISR
      32   SPI_WaitFifoStateUntilTimeout
        32   -> HAL_GetTick
      24   SPI_WaitFlagStateUntilTimeout
        24   -> HAL_GetTick


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable1
       4  ??DataTable1_1
       6  ?Subroutine0
       6  ?Subroutine1
       6  ?Subroutine2
      12  ?Subroutine3
      10  ?Subroutine4
       6  ?Subroutine5
       6  ?Subroutine6
       6  ?Subroutine7
       4  ?Subroutine8
       4  ?Subroutine9
      28  HAL_SPI_DMAPause
      26  HAL_SPI_DMAResume
      40  HAL_SPI_DMAStop
     354  HAL_SPI_DeInit
       2  HAL_SPI_ErrorCallback
       4  HAL_SPI_GetError
       6  HAL_SPI_GetState
     170  HAL_SPI_IRQHandler
     178  HAL_SPI_Init
       2  HAL_SPI_MspDeInit
       2  HAL_SPI_MspInit
     594  HAL_SPI_Receive
     250  HAL_SPI_Receive_DMA
     228  HAL_SPI_Receive_IT
       2  HAL_SPI_RxCpltCallback
       2  HAL_SPI_RxHalfCpltCallback
     542  HAL_SPI_Transmit
     672  HAL_SPI_TransmitReceive
     370  HAL_SPI_TransmitReceive_DMA
     236  HAL_SPI_TransmitReceive_IT
     214  HAL_SPI_Transmit_DMA
     152  HAL_SPI_Transmit_IT
       2  HAL_SPI_TxCpltCallback
       2  HAL_SPI_TxHalfCpltCallback
       2  HAL_SPI_TxRxCpltCallback
       2  HAL_SPI_TxRxHalfCpltCallback
      62  SPI_2linesRxISR_16BIT
      24  SPI_2linesRxISR_16BITCRC
     110  SPI_2linesRxISR_8BIT
      40  SPI_2linesRxISR_8BITCRC
      60  SPI_2linesTxISR_16BIT
      82  SPI_2linesTxISR_8BIT
      82  SPI_CloseRxTx_ISR
      72  SPI_CloseRx_ISR
      40  SPI_CloseTx_ISR
      28  SPI_DMAError
      10  SPI_DMAHalfReceiveCplt
      10  SPI_DMAHalfTransmitCplt
      10  SPI_DMAHalfTransmitReceiveCplt
     364  SPI_DMAReceiveCplt
      60  SPI_DMATransmitCplt
     356  SPI_DMATransmitReceiveCplt
      80  SPI_EndRxTransaction
      62  SPI_EndRxTxTransaction
      58  SPI_RxISR_16BIT
      22  SPI_RxISR_16BITCRC
      58  SPI_RxISR_8BIT
      28  SPI_RxISR_8BITCRC
      42  SPI_TxISR_16BIT
      48  SPI_TxISR_8BIT
     158  SPI_WaitFifoStateUntilTimeout
     136  SPI_WaitFlagStateUntilTimeout

 
 6 258 bytes in section .text
 
 6 258 bytes of CODE memory

Errors: none
Warnings: none
