###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.2.10312/W32 for ARM       27/Feb/2016  00:32:41
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_spi.c
#    Command line =  
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_spi.c
#        -D USE_HAL_DRIVER -D STM32F746xx -D USE_STM32746G_DISCO -D
#        USE_IOEXPANDER -D USE_USB_FS -lC
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
#        -lA
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
#        -o
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M7 -e --fpu=VFPv5_sp --dlib_config
#        "D:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Full.h" -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\Inc\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\CMSIS\Device\ST\STM32F7xx\Include\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\STM32F7xx_HAL_Driver\Inc\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\STM32746G-Discovery\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\Components\Common\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Log\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Fonts\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\CPU\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_Device_Library\Core\Inc\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Core\Inc\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Class\MSC\Inc\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\drivers\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_Audio\Addons\PDM\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_Device_Library\Class\AUDIO\Inc\
#        -Om --use_c++_inline --require_prototypes -I "D:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.3\arm\CMSIS\Include\" -D
#        ARM_MATH_CM7
#    List file    =  
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List\stm32f7xx_hal_spi.lst
#    Object file  =  
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj\stm32f7xx_hal_spi.o
#
###############################################################################

H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_spi.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f7xx_hal_spi.c
      4            * @author  MCD Application Team
      5            * @version V1.0.1
      6            * @date    25-June-2015
      7            * @brief   SPI HAL module driver.
      8            *          This file provides firmware functions to manage the following 
      9            *          functionalities of the Serial Peripheral Interface (SPI) peripheral:
     10            *           + Initialization and de-initialization functions
     11            *           + IO operation functions
     12            *           + Peripheral Control functions 
     13            *           + Peripheral State functions
     14            @verbatim
     15            ==============================================================================
     16                                  ##### How to use this driver #####
     17            ==============================================================================
     18              [..]
     19                The SPI HAL driver can be used as follows:
     20          
     21                (#) Declare a SPI_HandleTypeDef handle structure, for example:
     22                    SPI_HandleTypeDef  hspi;
     23          
     24                (#)Initialize the SPI low level resources by implementing the HAL_SPI_MspInit ()API:
     25                    (##) Enable the SPIx interface clock
     26                    (##) SPI pins configuration
     27                        (+++) Enable the clock for the SPI GPIOs
     28                        (+++) Configure these SPI pins as alternate function push-pull
     29                    (##) NVIC configuration if you need to use interrupt process
     30                        (+++) Configure the SPIx interrupt priority
     31                        (+++) Enable the NVIC SPI IRQ handle
     32                    (##) DMA Configuration if you need to use DMA process
     33                        (+++) Declare a DMA_HandleTypeDef handle structure for the transmit or receive channel
     34                        (+++) Enable the DMAx clock
     35                        (+++) Configure the DMA handle parameters
     36                        (+++) Configure the DMA Tx or Rx channel
     37                        (+++) Associate the initialized hdma_tx handle to the hspi DMA Tx or Rx handle
     38                        (+++) Configure the priority and enable the NVIC for the transfer complete interrupt on the DMA Tx or Rx channel
     39          
     40                (#) Program the Mode, BidirectionalMode , Data size, Baudrate Prescaler, NSS
     41                    management, Clock polarity and phase, FirstBit and CRC configuration in the hspi Init structure.
     42          
     43                (#) Initialize the SPI registers by calling the HAL_SPI_Init() API:
     44                    (++) This API configures also the low level Hardware GPIO, CLOCK, CORTEX...etc)
     45                        by calling the customised HAL_SPI_MspInit() API.
     46               [..]
     47                 Circular mode restriction:
     48                (#) The DMA circular mode cannot be used when the SPI is configured in these modes:
     49                    (##) Master 2Lines RxOnly
     50                    (##) Master 1Line Rx
     51                (#) The CRC feature is not managed when the DMA circular mode is enabled
     52                (#) When the SPI DMA Pause/Stop features are used, we must use the following APIs
     53                    the HAL_SPI_DMAPause()/ HAL_SPI_DMAStop() only under the SPI callbacks
     54          
     55            @endverbatim
     56            ******************************************************************************
     57            * @attention
     58            *
     59            * <h2><center>&copy; COPYRIGHT(c) 2015 STMicroelectronics</center></h2>
     60            *
     61            * Redistribution and use in source and binary forms, with or without modification,
     62            * are permitted provided that the following conditions are met:
     63            *   1. Redistributions of source code must retain the above copyright notice,
     64            *      this list of conditions and the following disclaimer.
     65            *   2. Redistributions in binary form must reproduce the above copyright notice,
     66            *      this list of conditions and the following disclaimer in the documentation
     67            *      and/or other materials provided with the distribution.
     68            *   3. Neither the name of STMicroelectronics nor the names of its contributors
     69            *      may be used to endorse or promote products derived from this software
     70            *      without specific prior written permission.
     71            *
     72            * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
     73            * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     74            * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     75            * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
     76            * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
     77            * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
     78            * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
     79            * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
     80            * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
     81            * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     82            *
     83            ******************************************************************************
     84            */
     85              
     86          /* Includes ------------------------------------------------------------------*/
     87          #include "stm32f7xx_hal.h"
     88             
     89          /** @addtogroup STM32F7xx_HAL_Driver
     90            * @{
     91            */
     92          
     93          /** @defgroup SPI SPI 
     94            * @brief SPI HAL module driver
     95            * @{
     96            */
     97          #ifdef HAL_SPI_MODULE_ENABLED
     98          
     99          /* Private typedef -----------------------------------------------------------*/
    100          /* Private defines -----------------------------------------------------------*/
    101          /** @defgroup SPI_Private_Constants SPI Private Constants
    102            * @{
    103            */
    104          #define SPI_DEFAULT_TIMEOUT 50
    105          /**
    106            * @}
    107            */
    108          
    109          /* Private macro -------------------------------------------------------------*/
    110          /* Private variables ---------------------------------------------------------*/
    111          /* Private function prototypes -----------------------------------------------*/
    112          /** @addtogroup SPI_Private_Functions
    113            * @{
    114            */
    115          static void SPI_DMATransmitCplt(DMA_HandleTypeDef *hdma);
    116          static void SPI_DMAReceiveCplt(DMA_HandleTypeDef *hdma);
    117          static void SPI_DMATransmitReceiveCplt(DMA_HandleTypeDef *hdma);
    118          static void SPI_DMAHalfTransmitCplt(DMA_HandleTypeDef *hdma);
    119          static void SPI_DMAHalfReceiveCplt(DMA_HandleTypeDef *hdma);
    120          static void SPI_DMAHalfTransmitReceiveCplt(DMA_HandleTypeDef *hdma);
    121          static void SPI_DMAError(DMA_HandleTypeDef *hdma);
    122          static HAL_StatusTypeDef SPI_WaitFlagStateUntilTimeout(SPI_HandleTypeDef *hspi, uint32_t Flag, uint32_t State, uint32_t Timeout);
    123          static HAL_StatusTypeDef SPI_WaitFifoStateUntilTimeout(SPI_HandleTypeDef *hspi, uint32_t Fifo, uint32_t State, uint32_t Timeout);
    124          static void SPI_TxISR_8BIT(struct __SPI_HandleTypeDef *hspi);
    125          static void SPI_TxISR_16BIT(struct __SPI_HandleTypeDef *hspi);
    126          static void SPI_RxISR_8BIT(struct __SPI_HandleTypeDef *hspi);
    127          static void SPI_RxISR_8BITCRC(struct __SPI_HandleTypeDef *hspi);
    128          static void SPI_RxISR_16BIT(struct __SPI_HandleTypeDef *hspi);
    129          static void SPI_RxISR_16BITCRC(struct __SPI_HandleTypeDef *hspi);
    130          static void SPI_2linesRxISR_8BIT(struct __SPI_HandleTypeDef *hspi);
    131          static void SPI_2linesRxISR_8BITCRC(struct __SPI_HandleTypeDef *hspi);
    132          static void SPI_2linesTxISR_8BIT(struct __SPI_HandleTypeDef *hspi);
    133          static void SPI_2linesTxISR_16BIT(struct __SPI_HandleTypeDef *hspi);
    134          static void SPI_2linesRxISR_16BIT(struct __SPI_HandleTypeDef *hspi);
    135          static void SPI_2linesRxISR_16BITCRC(struct __SPI_HandleTypeDef *hspi);
    136          static void SPI_CloseRxTx_ISR(SPI_HandleTypeDef *hspi);
    137          static void SPI_CloseRx_ISR(SPI_HandleTypeDef *hspi);
    138          static void SPI_CloseTx_ISR(SPI_HandleTypeDef *hspi);
    139          static HAL_StatusTypeDef SPI_EndRxTransaction(SPI_HandleTypeDef *hspi, uint32_t Timeout);
    140          static HAL_StatusTypeDef SPI_EndRxTxTransaction(SPI_HandleTypeDef *hspi, uint32_t Timeout);
    141          /**
    142            * @}
    143            */
    144          
    145          /* Exported functions ---------------------------------------------------------*/
    146          
    147          /** @defgroup SPI_Exported_Functions SPI Exported Functions
    148            * @{
    149            */
    150          
    151          /** @defgroup SPI_Exported_Functions_Group1 Initialization and de-initialization functions
    152           *  @brief    Initialization and Configuration functions
    153           *
    154          @verbatim
    155           ===============================================================================
    156                        ##### Initialization and de-initialization functions #####
    157           ===============================================================================
    158              [..]  This subsection provides a set of functions allowing to initialize and
    159                    de-initialize the SPIx peripheral:
    160          
    161                (+) User must implement HAL_SPI_MspInit() function in which he configures
    162                    all related peripherals resources (CLOCK, GPIO, DMA, IT and NVIC ).
    163          
    164                (+) Call the function HAL_SPI_Init() to configure the selected device with
    165                    the selected configuration:
    166                  (++) Mode
    167                  (++) Direction
    168                  (++) Data Size
    169                  (++) Clock Polarity and Phase
    170                  (++) NSS Management
    171                  (++) BaudRate Prescaler
    172                  (++) FirstBit
    173                  (++) TIMode
    174                  (++) CRC Calculation
    175                  (++) CRC Polynomial if CRC enabled
    176                  (++) CRC Length, used only with Data8 and Data16
    177                  (++) FIFO reception threshold
    178          
    179                (+) Call the function HAL_SPI_DeInit() to restore the default configuration
    180                    of the selected SPIx peripheral.
    181          
    182          @endverbatim
    183            * @{
    184            */
    185          
    186          /**
    187            * @brief  Initializes the SPI according to the specified parameters
    188            *         in the SPI_InitTypeDef and create the associated handle.
    189            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
    190            *               the configuration information for SPI module.
    191            * @retval HAL status
    192            */

   \                                 In section .text, align 2, keep-with-next
    193          HAL_StatusTypeDef HAL_SPI_Init(SPI_HandleTypeDef *hspi)
    194          {
   \                     HAL_SPI_Init: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    195            uint32_t frxth;
    196          
    197            /* Check the SPI handle allocation */
    198            if(hspi == NULL)
   \   00000004   0xD101             BNE.N    ??HAL_SPI_Init_0
    199            {
    200              return HAL_ERROR;
   \   00000006   0x2001             MOVS     R0,#+1
   \   00000008   0xBD32             POP      {R1,R4,R5,PC}
    201            }
    202          
    203            /* Check the parameters */
    204            assert_param(IS_SPI_ALL_INSTANCE(hspi->Instance));
    205            assert_param(IS_SPI_MODE(hspi->Init.Mode));
    206            assert_param(IS_SPI_DIRECTION(hspi->Init.Direction));
    207            assert_param(IS_SPI_DATASIZE(hspi->Init.DataSize));
    208            assert_param(IS_SPI_CPOL(hspi->Init.CLKPolarity));
    209            assert_param(IS_SPI_CPHA(hspi->Init.CLKPhase));
    210            assert_param(IS_SPI_NSS(hspi->Init.NSS));
    211            assert_param(IS_SPI_NSSP(hspi->Init.NSSPMode));
    212            assert_param(IS_SPI_BAUDRATE_PRESCALER(hspi->Init.BaudRatePrescaler));
    213            assert_param(IS_SPI_FIRST_BIT(hspi->Init.FirstBit));
    214            assert_param(IS_SPI_TIMODE(hspi->Init.TIMode));
    215            assert_param(IS_SPI_CRC_CALCULATION(hspi->Init.CRCCalculation));
    216            assert_param(IS_SPI_CRC_POLYNOMIAL(hspi->Init.CRCPolynomial));
    217            assert_param(IS_SPI_CRC_LENGTH(hspi->Init.CRCLength));
    218          
    219            if(hspi->State == HAL_SPI_STATE_RESET)
   \                     ??HAL_SPI_Init_0: (+1)
   \   0000000A   0xF104 0x055C      ADD      R5,R4,#+92
   \   0000000E   0x7868             LDRB     R0,[R5, #+1]
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD104             BNE.N    ??HAL_SPI_Init_1
    220            {
    221              /* Allocate lock resource and initialize it */
    222              hspi->Lock = HAL_UNLOCKED;
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0x7028             STRB     R0,[R5, #+0]
    223          
    224              /* Init the low level hardware : GPIO, CLOCK, NVIC... */
    225              HAL_SPI_MspInit(hspi);
   \   00000018   0x4620             MOV      R0,R4
   \   0000001A   0x.... 0x....      BL       HAL_SPI_MspInit
    226            }
    227          
    228            hspi->State = HAL_SPI_STATE_BUSY;
   \                     ??HAL_SPI_Init_1: (+1)
   \   0000001E   0x2002             MOVS     R0,#+2
   \   00000020   0x7068             STRB     R0,[R5, #+1]
    229          
    230            /* Disable the selected SPI peripheral */
    231            __HAL_SPI_DISABLE(hspi);
   \   00000022   0x6820             LDR      R0,[R4, #+0]
   \   00000024   0x6801             LDR      R1,[R0, #+0]
   \   00000026   0xF021 0x0140      BIC      R1,R1,#0x40
   \   0000002A   0x6001             STR      R1,[R0, #+0]
    232          
    233            /* Align by default the rs fifo threshold on the data size */
    234            if(hspi->Init.DataSize > SPI_DATASIZE_8BIT)
   \   0000002C   0x68E1             LDR      R1,[R4, #+12]
   \   0000002E   0xF240 0x7201      MOVW     R2,#+1793
   \   00000032   0x4291             CMP      R1,R2
   \   00000034   0xD301             BCC.N    ??HAL_SPI_Init_2
    235            {
    236              frxth = SPI_RXFIFO_THRESHOLD_HF;
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0xE001             B.N      ??HAL_SPI_Init_3
    237            }
    238            else
    239            {
    240              frxth = SPI_RXFIFO_THRESHOLD_QF;
   \                     ??HAL_SPI_Init_2: (+1)
   \   0000003A   0xF44F 0x5080      MOV      R0,#+4096
    241            }
    242          
    243            /* CRC calculation is valid only for 16Bit and 8 Bit */
    244            if(( hspi->Init.DataSize != SPI_DATASIZE_16BIT ) && ( hspi->Init.DataSize != SPI_DATASIZE_8BIT ))
   \                     ??HAL_SPI_Init_3: (+1)
   \   0000003E   0xF5B1 0x6F70      CMP      R1,#+3840
   \   00000042   0xD004             BEQ.N    ??HAL_SPI_Init_4
   \   00000044   0xF5B1 0x6FE0      CMP      R1,#+1792
   \   00000048   0xD001             BEQ.N    ??HAL_SPI_Init_4
    245            {
    246              /* CRC must be disabled */
    247              hspi->Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
   \   0000004A   0x2100             MOVS     R1,#+0
   \   0000004C   0x62A1             STR      R1,[R4, #+40]
    248            }
    249          
    250            /* Align the CRC Length on the data size */
    251            if( hspi->Init.CRCLength == SPI_CRC_LENGTH_DATASIZE)
   \                     ??HAL_SPI_Init_4: (+1)
   \   0000004E   0x6B21             LDR      R1,[R4, #+48]
   \   00000050   0x2900             CMP      R1,#+0
   \   00000052   0xD107             BNE.N    ??HAL_SPI_Init_5
    252            {
    253              /* CRC Length aligned on the data size : value set by default */
    254              if(hspi->Init.DataSize > SPI_DATASIZE_8BIT)
   \   00000054   0x68E1             LDR      R1,[R4, #+12]
   \   00000056   0x4291             CMP      R1,R2
   \   00000058   0xD302             BCC.N    ??HAL_SPI_Init_6
    255              {
    256                hspi->Init.CRCLength = SPI_CRC_LENGTH_16BIT;
   \   0000005A   0x2102             MOVS     R1,#+2
   \   0000005C   0x6321             STR      R1,[R4, #+48]
   \   0000005E   0xE001             B.N      ??HAL_SPI_Init_5
    257              }
    258              else
    259              {
    260                hspi->Init.CRCLength = SPI_CRC_LENGTH_8BIT;
   \                     ??HAL_SPI_Init_6: (+1)
   \   00000060   0x2101             MOVS     R1,#+1
   \   00000062   0x6321             STR      R1,[R4, #+48]
    261              }
    262            }
    263          
    264            /*---------------------------- SPIx CR1 & CR2 Configuration ------------------------*/
    265            /* Configure : SPI Mode, Communication Mode, Clock polarity and phase, NSS management,
    266            Communication speed, First bit, CRC calculation state, CRC Length */
    267            hspi->Instance->CR1 = (hspi->Init.Mode | hspi->Init.Direction |
    268                                   hspi->Init.CLKPolarity | hspi->Init.CLKPhase | (hspi->Init.NSS & SPI_CR1_SSM) |
    269                                   hspi->Init.BaudRatePrescaler | hspi->Init.FirstBit  | hspi->Init.CRCCalculation);
   \                     ??HAL_SPI_Init_5: (+1)
   \   00000064   0x6861             LDR      R1,[R4, #+4]
   \   00000066   0x68A2             LDR      R2,[R4, #+8]
   \   00000068   0x4311             ORRS     R1,R2,R1
   \   0000006A   0x6922             LDR      R2,[R4, #+16]
   \   0000006C   0x4311             ORRS     R1,R2,R1
   \   0000006E   0x6962             LDR      R2,[R4, #+20]
   \   00000070   0x4311             ORRS     R1,R2,R1
   \   00000072   0x69A2             LDR      R2,[R4, #+24]
   \   00000074   0xF402 0x7200      AND      R2,R2,#0x200
   \   00000078   0x4311             ORRS     R1,R2,R1
   \   0000007A   0x69E2             LDR      R2,[R4, #+28]
   \   0000007C   0x4311             ORRS     R1,R2,R1
   \   0000007E   0x6A22             LDR      R2,[R4, #+32]
   \   00000080   0x4311             ORRS     R1,R2,R1
   \   00000082   0x6AA2             LDR      R2,[R4, #+40]
   \   00000084   0x4311             ORRS     R1,R2,R1
   \   00000086   0x6822             LDR      R2,[R4, #+0]
   \   00000088   0x6011             STR      R1,[R2, #+0]
    270          
    271            if( hspi->Init.CRCLength == SPI_CRC_LENGTH_16BIT)
   \   0000008A   0x6B21             LDR      R1,[R4, #+48]
   \   0000008C   0x2902             CMP      R1,#+2
   \   0000008E   0xD104             BNE.N    ??HAL_SPI_Init_7
    272            {
    273              hspi->Instance->CR1|= SPI_CR1_CRCL;
   \   00000090   0x6821             LDR      R1,[R4, #+0]
   \   00000092   0x680A             LDR      R2,[R1, #+0]
   \   00000094   0xF442 0x6200      ORR      R2,R2,#0x800
   \   00000098   0x600A             STR      R2,[R1, #+0]
    274            }
    275          
    276            /* Configure : NSS management */
    277            /* Configure : Rx Fifo Threshold */
    278            hspi->Instance->CR2 = (((hspi->Init.NSS >> 16) & SPI_CR2_SSOE) | hspi->Init.TIMode | hspi->Init.NSSPMode |
    279                                   hspi->Init.DataSize ) | frxth;
   \                     ??HAL_SPI_Init_7: (+1)
   \   0000009A   0x69A1             LDR      R1,[R4, #+24]
   \   0000009C   0x0C09             LSRS     R1,R1,#+16
   \   0000009E   0xF001 0x0104      AND      R1,R1,#0x4
   \   000000A2   0x6A62             LDR      R2,[R4, #+36]
   \   000000A4   0x4311             ORRS     R1,R2,R1
   \   000000A6   0x6B62             LDR      R2,[R4, #+52]
   \   000000A8   0x4311             ORRS     R1,R2,R1
   \   000000AA   0x68E2             LDR      R2,[R4, #+12]
   \   000000AC   0x4311             ORRS     R1,R2,R1
   \   000000AE   0x4308             ORRS     R0,R0,R1
   \   000000B0   0x6821             LDR      R1,[R4, #+0]
   \   000000B2   0x6048             STR      R0,[R1, #+4]
    280          
    281            /*---------------------------- SPIx CRCPOLY Configuration --------------------*/
    282            /* Configure : CRC Polynomial */
    283            hspi->Instance->CRCPR = hspi->Init.CRCPolynomial;
   \   000000B4   0x6AE0             LDR      R0,[R4, #+44]
   \   000000B6   0x6821             LDR      R1,[R4, #+0]
   \   000000B8   0x6108             STR      R0,[R1, #+16]
    284          
    285            hspi->ErrorCode = HAL_SPI_ERROR_NONE;
   \   000000BA   0x2000             MOVS     R0,#+0
   \   000000BC   0x6068             STR      R0,[R5, #+4]
    286            hspi->State= HAL_SPI_STATE_READY;
   \   000000BE   0x2001             MOVS     R0,#+1
   \   000000C0   0x7068             STRB     R0,[R5, #+1]
    287          
    288            return HAL_OK;
   \   000000C2   0x2000             MOVS     R0,#+0
   \   000000C4   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    289          }
    290          
    291          /**
    292            * @brief  DeInitializes the SPI peripheral
    293            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
    294            *               the configuration information for SPI module.
    295            * @retval HAL status
    296            */

   \                                 In section .text, align 2, keep-with-next
    297          HAL_StatusTypeDef HAL_SPI_DeInit(SPI_HandleTypeDef *hspi)
    298          {
   \                     HAL_SPI_DeInit: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0005             MOVS     R5,R0
    299            /* Check the SPI handle allocation */
    300            if(hspi == NULL)
   \   00000004   0xD101             BNE.N    ??HAL_SPI_DeInit_0
    301            {
    302              return HAL_ERROR;
   \   00000006   0x2001             MOVS     R0,#+1
   \   00000008   0xBD32             POP      {R1,R4,R5,PC}
    303            }
    304          
    305            /* Check the parameters */
    306            assert_param(IS_SPI_ALL_INSTANCE(hspi->Instance));
    307          
    308            hspi->State = HAL_SPI_STATE_BUSY;
   \                     ??HAL_SPI_DeInit_0: (+1)
   \   0000000A   0xF105 0x045C      ADD      R4,R5,#+92
   \   0000000E   0x2002             MOVS     R0,#+2
   \   00000010   0x7060             STRB     R0,[R4, #+1]
    309          
    310            /* check flag before the SPI disable */
    311            SPI_WaitFifoStateUntilTimeout(hspi, SPI_FLAG_FTLVL, SPI_FTLVL_EMPTY, SPI_DEFAULT_TIMEOUT);
   \   00000012   0x2332             MOVS     R3,#+50
   \   00000014   0x2200             MOVS     R2,#+0
   \   00000016   0xF44F 0x51C0      MOV      R1,#+6144
   \   0000001A   0x4628             MOV      R0,R5
   \   0000001C   0x.... 0x....      BL       SPI_WaitFifoStateUntilTimeout
    312            SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_BSY, RESET, SPI_DEFAULT_TIMEOUT);
   \   00000020   0x2332             MOVS     R3,#+50
   \   00000022   0x2200             MOVS     R2,#+0
   \   00000024   0x2180             MOVS     R1,#+128
   \   00000026   0x4628             MOV      R0,R5
   \   00000028   0x.... 0x....      BL       SPI_WaitFlagStateUntilTimeout
    313            SPI_WaitFifoStateUntilTimeout(hspi, SPI_FLAG_FRLVL, SPI_FRLVL_EMPTY, SPI_DEFAULT_TIMEOUT);
   \   0000002C   0x2332             MOVS     R3,#+50
   \   0000002E   0x2200             MOVS     R2,#+0
   \   00000030   0xF44F 0x61C0      MOV      R1,#+1536
   \   00000034   0x4628             MOV      R0,R5
   \   00000036   0x.... 0x....      BL       SPI_WaitFifoStateUntilTimeout
    314          
    315            /* Disable the SPI Peripheral Clock */
    316            __HAL_SPI_DISABLE(hspi);
   \   0000003A   0x6828             LDR      R0,[R5, #+0]
   \   0000003C   0x6801             LDR      R1,[R0, #+0]
   \   0000003E   0xF021 0x0140      BIC      R1,R1,#0x40
   \   00000042   0x6001             STR      R1,[R0, #+0]
    317          
    318            /* DeInit the low level hardware: GPIO, CLOCK, NVIC... */
    319            HAL_SPI_MspDeInit(hspi);
   \   00000044   0x4628             MOV      R0,R5
   \   00000046   0x.... 0x....      BL       HAL_SPI_MspDeInit
    320          
    321            hspi->ErrorCode = HAL_SPI_ERROR_NONE;
   \   0000004A   0x2000             MOVS     R0,#+0
   \   0000004C   0x6060             STR      R0,[R4, #+4]
    322            hspi->State = HAL_SPI_STATE_RESET;
   \   0000004E   0x7060             STRB     R0,[R4, #+1]
    323          
    324            __HAL_UNLOCK(hspi);
   \   00000050   0x7020             STRB     R0,[R4, #+0]
    325          
    326            return HAL_OK;
   \   00000052   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    327          }
    328          
    329          /**
    330            * @brief SPI MSP Init
    331            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
    332            *               the configuration information for SPI module.
    333            * @retval None
    334            */

   \                                 In section .text, align 2, keep-with-next
    335           __weak void HAL_SPI_MspInit(SPI_HandleTypeDef *hspi)
    336           {
    337             /* NOTE : This function should not be modified, when the callback is needed,
    338                      the HAL_SPI_MspInit should be implemented in the user file
    339             */
    340          }
   \                     HAL_SPI_MspInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    341          
    342          /**
    343            * @brief SPI MSP DeInit
    344            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
    345            *               the configuration information for SPI module.
    346            * @retval None
    347            */

   \                                 In section .text, align 2, keep-with-next
    348           __weak void HAL_SPI_MspDeInit(SPI_HandleTypeDef *hspi)
    349          {
    350            /* NOTE : This function should not be modified, when the callback is needed,
    351                      the HAL_SPI_MspDeInit should be implemented in the user file
    352             */
    353          }
   \                     HAL_SPI_MspDeInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    354          
    355          /**
    356            * @}
    357            */
    358          
    359          /** @defgroup SPI_Exported_Functions_Group2 IO operation functions
    360           *  @brief   Data transfers functions
    361           *
    362          @verbatim
    363            ==============================================================================
    364                                ##### IO operation functions #####
    365           ===============================================================================
    366              This subsection provides a set of functions allowing to manage the SPI
    367              data transfers.
    368          
    369              [..] The SPI supports master and slave mode :
    370          
    371              (#) There are two modes of transfer:
    372                 (++) Blocking mode: The communication is performed in polling mode.
    373                      The HAL status of all data processing is returned by the same function
    374                      after finishing transfer.
    375                 (++) No-Blocking mode: The communication is performed using Interrupts
    376                     or DMA, These APIs return the HAL status.
    377                     The end of the data processing will be indicated through the
    378                     dedicated SPI IRQ when using Interrupt mode or the DMA IRQ when
    379                     using DMA mode.
    380                     The HAL_SPI_TxCpltCallback(), HAL_SPI_RxCpltCallback() and HAL_SPI_TxRxCpltCallback() user callbacks
    381                     will be executed respectively at the end of the transmit or Receive process
    382                     The HAL_SPI_ErrorCallback()user callback will be executed when a communication error is detected
    383          
    384              (#) APIs provided for these 2 transfer modes (Blocking mode or Non blocking mode using either Interrupt or DMA)
    385                  exist for 1Line (simplex) and 2Lines (full duplex) modes.
    386          
    387          @endverbatim
    388            * @{
    389            */
    390          
    391          /**
    392            * @brief  Transmit an amount of data in blocking mode
    393            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
    394            *               the configuration information for SPI module.
    395            * @param  pData: pointer to data buffer
    396            * @param  Size: amount of data to be sent
    397            * @param  Timeout: Timeout duration
    398            * @retval HAL status
    399            */

   \                                 In section .text, align 2, keep-with-next
    400          HAL_StatusTypeDef HAL_SPI_Transmit(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size, uint32_t Timeout)
    401          {
   \                     HAL_SPI_Transmit: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x4605             MOV      R5,R0
   \   00000006   0x461E             MOV      R6,R3
    402            assert_param(IS_SPI_DIRECTION_2LINES_OR_1LINE(hspi->Init.Direction));
    403          
    404            /* Process Locked */
    405            __HAL_LOCK(hspi);
   \   00000008   0xF105 0x0444      ADD      R4,R5,#+68
   \   0000000C   0x7E20             LDRB     R0,[R4, #+24]
   \   0000000E   0x2801             CMP      R0,#+1
   \   00000010   0xD101             BNE.N    ??HAL_SPI_Transmit_0
   \   00000012   0x2002             MOVS     R0,#+2
   \   00000014   0xBD76             POP      {R1,R2,R4-R6,PC}
   \                     ??HAL_SPI_Transmit_0: (+1)
   \   00000016   0x2001             MOVS     R0,#+1
   \   00000018   0x7620             STRB     R0,[R4, #+24]
    406          
    407            if(hspi->State != HAL_SPI_STATE_READY)
   \   0000001A   0x7E60             LDRB     R0,[R4, #+25]
   \   0000001C   0x2801             CMP      R0,#+1
   \   0000001E   0xD005             BEQ.N    ??HAL_SPI_Transmit_1
    408            {
    409              hspi->State = HAL_SPI_STATE_READY;
   \   00000020   0x2001             MOVS     R0,#+1
   \   00000022   0x7660             STRB     R0,[R4, #+25]
    410             /* Process Unlocked */
    411             __HAL_UNLOCK(hspi);
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0x7620             STRB     R0,[R4, #+24]
    412             return HAL_BUSY;
   \   00000028   0x2002             MOVS     R0,#+2
   \   0000002A   0xBD76             POP      {R1,R2,R4-R6,PC}
    413            }
    414            
    415            if((pData == NULL ) || (Size == 0))
   \                     ??HAL_SPI_Transmit_1: (+1)
   \   0000002C   0x2900             CMP      R1,#+0
   \   0000002E   0xD001             BEQ.N    ??HAL_SPI_Transmit_2
   \   00000030   0x2A00             CMP      R2,#+0
   \   00000032   0xD105             BNE.N    ??HAL_SPI_Transmit_3
    416            {
    417              hspi->State = HAL_SPI_STATE_READY;
   \                     ??HAL_SPI_Transmit_2: (+1)
   \   00000034   0x2001             MOVS     R0,#+1
   \   00000036   0x7660             STRB     R0,[R4, #+25]
    418             /* Process Unlocked */
    419             __HAL_UNLOCK(hspi);
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0x7620             STRB     R0,[R4, #+24]
    420              return HAL_ERROR;
   \   0000003C   0x2001             MOVS     R0,#+1
   \   0000003E   0xBD76             POP      {R1,R2,R4-R6,PC}
    421            }
    422          
    423            /* Set the transaction information */
    424            hspi->State       = HAL_SPI_STATE_BUSY_TX;
   \                     ??HAL_SPI_Transmit_3: (+1)
   \   00000040   0x2003             MOVS     R0,#+3
   \   00000042   0x7660             STRB     R0,[R4, #+25]
    425            hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0x61E0             STR      R0,[R4, #+28]
    426            hspi->pTxBuffPtr  = pData;
   \   00000048   0x63A9             STR      R1,[R5, #+56]
    427            hspi->TxXferSize  = Size;
   \   0000004A   0x87AA             STRH     R2,[R5, #+60]
    428            hspi->TxXferCount = Size;
   \   0000004C   0x87EA             STRH     R2,[R5, #+62]
    429            hspi->pRxBuffPtr  = (uint8_t *)NULL;
   \   0000004E   0x6428             STR      R0,[R5, #+64]
    430            hspi->RxXferSize  = 0;
   \   00000050   0x8020             STRH     R0,[R4, #+0]
    431            hspi->RxXferCount = 0;
   \   00000052   0x8060             STRH     R0,[R4, #+2]
    432          
    433            /* Configure communication direction : 1Line */
    434            if(hspi->Init.Direction == SPI_DIRECTION_1LINE)
   \   00000054   0x68A8             LDR      R0,[R5, #+8]
   \   00000056   0xF5B0 0x4F00      CMP      R0,#+32768
   \   0000005A   0xD104             BNE.N    ??HAL_SPI_Transmit_4
    435            {
    436              SPI_1LINE_TX(hspi);
   \   0000005C   0x6828             LDR      R0,[R5, #+0]
   \   0000005E   0x6801             LDR      R1,[R0, #+0]
   \   00000060   0xF441 0x4180      ORR      R1,R1,#0x4000
   \   00000064   0x6001             STR      R1,[R0, #+0]
    437            }
    438          
    439            /* Reset CRC Calculation */
    440            if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   \                     ??HAL_SPI_Transmit_4: (+1)
   \   00000066   0x6AA8             LDR      R0,[R5, #+40]
   \   00000068   0xF5B0 0x5F00      CMP      R0,#+8192
   \   0000006C   0xD10A             BNE.N    ??HAL_SPI_Transmit_5
    441            {
    442              SPI_RESET_CRC(hspi);
   \   0000006E   0x6828             LDR      R0,[R5, #+0]
   \   00000070   0x6801             LDR      R1,[R0, #+0]
   \   00000072   0xF64D 0x72FF      MOVW     R2,#+57343
   \   00000076   0x4011             ANDS     R1,R2,R1
   \   00000078   0x6001             STR      R1,[R0, #+0]
   \   0000007A   0x6828             LDR      R0,[R5, #+0]
   \   0000007C   0x6801             LDR      R1,[R0, #+0]
   \   0000007E   0xF441 0x5100      ORR      R1,R1,#0x2000
   \   00000082   0x6001             STR      R1,[R0, #+0]
    443            }
    444          
    445            /* Check if the SPI is already enabled */
    446            if((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
   \                     ??HAL_SPI_Transmit_5: (+1)
   \   00000084   0x6828             LDR      R0,[R5, #+0]
   \   00000086   0x6801             LDR      R1,[R0, #+0]
   \   00000088   0x0649             LSLS     R1,R1,#+25
   \   0000008A   0xD403             BMI.N    ??HAL_SPI_Transmit_6
    447            {
    448              /* Enable SPI peripheral */
    449              __HAL_SPI_ENABLE(hspi);
   \   0000008C   0x6801             LDR      R1,[R0, #+0]
   \   0000008E   0xF041 0x0140      ORR      R1,R1,#0x40
   \   00000092   0x6001             STR      R1,[R0, #+0]
    450            }
    451          
    452            /* Transmit data in 16 Bit mode */
    453            if(hspi->Init.DataSize > SPI_DATASIZE_8BIT)
   \                     ??HAL_SPI_Transmit_6: (+1)
   \   00000094   0x68E8             LDR      R0,[R5, #+12]
   \   00000096   0xF5B0 0x6FE0      CMP      R0,#+1792
   \   0000009A   0xD91F             BLS.N    ??HAL_SPI_Transmit_7
    454            {
    455              /* Transmit data in 16 Bit mode */
    456              while (hspi->TxXferCount > 0)
   \                     ??HAL_SPI_Transmit_8: (+1)
   \   0000009C   0x8FE8             LDRH     R0,[R5, #+62]
   \   0000009E   0x2800             CMP      R0,#+0
   \   000000A0   0xD040             BEQ.N    ??HAL_SPI_Transmit_9
    457              {
    458                /* Wait until TXE flag is set to send data */
    459                if(SPI_WaitFlagStateUntilTimeout(hspi,SPI_FLAG_TXE,SPI_FLAG_TXE,Timeout) != HAL_OK)
   \   000000A2   0x4633             MOV      R3,R6
   \   000000A4   0x2202             MOVS     R2,#+2
   \   000000A6   0x4611             MOV      R1,R2
   \   000000A8   0x4628             MOV      R0,R5
   \   000000AA   0x.... 0x....      BL       SPI_WaitFlagStateUntilTimeout
   \   000000AE   0x2800             CMP      R0,#+0
   \   000000B0   0xD121             BNE.N    ??HAL_SPI_Transmit_10
    460                {
    461                  hspi->State = HAL_SPI_STATE_READY;
    462                  /* Process Unlocked */
    463                 __HAL_UNLOCK(hspi);
    464                  return HAL_TIMEOUT;
    465                }
    466                hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
   \   000000B2   0x6BA8             LDR      R0,[R5, #+56]
   \   000000B4   0x8800             LDRH     R0,[R0, #+0]
   \   000000B6   0x6829             LDR      R1,[R5, #+0]
   \   000000B8   0x60C8             STR      R0,[R1, #+12]
    467                hspi->pTxBuffPtr += sizeof(uint16_t);
   \   000000BA   0x6BA8             LDR      R0,[R5, #+56]
   \   000000BC   0x1C80             ADDS     R0,R0,#+2
   \   000000BE   0x63A8             STR      R0,[R5, #+56]
    468                hspi->TxXferCount--;
   \   000000C0   0x8FE8             LDRH     R0,[R5, #+62]
   \   000000C2   0x1E40             SUBS     R0,R0,#+1
   \   000000C4   0x87E8             STRH     R0,[R5, #+62]
   \   000000C6   0xE7E9             B.N      ??HAL_SPI_Transmit_8
    469              }
    470            }
    471            /* Transmit data in 8 Bit mode */
    472            else
    473            {
    474              while (hspi->TxXferCount > 0)
    475              {
    476                if(hspi->TxXferCount != 0x1)
    477                {
    478                  /* Wait until TXE flag is set to send data */
    479                  if(SPI_WaitFlagStateUntilTimeout(hspi,SPI_FLAG_TXE,SPI_FLAG_TXE,Timeout) != HAL_OK)
    480                  {
    481                    hspi->State = HAL_SPI_STATE_READY;
    482                    /* Process Unlocked */
    483                    __HAL_UNLOCK(hspi);
    484                    return HAL_TIMEOUT;
    485                  }
    486                  hspi->Instance->DR = *((uint16_t*)hspi->pTxBuffPtr);
   \                     ??HAL_SPI_Transmit_11: (+1)
   \   000000C8   0x6BA8             LDR      R0,[R5, #+56]
   \   000000CA   0x8800             LDRH     R0,[R0, #+0]
   \   000000CC   0x6829             LDR      R1,[R5, #+0]
   \   000000CE   0x60C8             STR      R0,[R1, #+12]
    487                  hspi->pTxBuffPtr += sizeof(uint16_t);
   \   000000D0   0x6BA8             LDR      R0,[R5, #+56]
   \   000000D2   0x1C80             ADDS     R0,R0,#+2
   \   000000D4   0x63A8             STR      R0,[R5, #+56]
    488                  hspi->TxXferCount -= 2;
   \   000000D6   0x8FE8             LDRH     R0,[R5, #+62]
   \   000000D8   0x1E80             SUBS     R0,R0,#+2
   \   000000DA   0x87E8             STRH     R0,[R5, #+62]
   \                     ??HAL_SPI_Transmit_7: (+1)
   \   000000DC   0x8FE8             LDRH     R0,[R5, #+62]
   \   000000DE   0x2800             CMP      R0,#+0
   \   000000E0   0xD020             BEQ.N    ??HAL_SPI_Transmit_9
   \   000000E2   0x2801             CMP      R0,#+1
   \   000000E4   0x4633             MOV      R3,R6
   \   000000E6   0xD00C             BEQ.N    ??HAL_SPI_Transmit_12
   \   000000E8   0x2202             MOVS     R2,#+2
   \   000000EA   0x4611             MOV      R1,R2
   \   000000EC   0x4628             MOV      R0,R5
   \   000000EE   0x.... 0x....      BL       SPI_WaitFlagStateUntilTimeout
   \   000000F2   0x2800             CMP      R0,#+0
   \   000000F4   0xD0E8             BEQ.N    ??HAL_SPI_Transmit_11
   \                     ??HAL_SPI_Transmit_10: (+1)
   \   000000F6   0x2001             MOVS     R0,#+1
   \   000000F8   0x7660             STRB     R0,[R4, #+25]
   \   000000FA   0x2000             MOVS     R0,#+0
   \   000000FC   0x7620             STRB     R0,[R4, #+24]
   \   000000FE   0x2003             MOVS     R0,#+3
   \   00000100   0xBD76             POP      {R1,R2,R4-R6,PC}
    489                }
    490                else
    491                {
    492                  /* Wait until TXE flag is set to send data */
    493                  if(SPI_WaitFlagStateUntilTimeout(hspi,SPI_FLAG_TXE,SPI_FLAG_TXE,Timeout) != HAL_OK)  
   \                     ??HAL_SPI_Transmit_12: (+1)
   \   00000102   0x2202             MOVS     R2,#+2
   \   00000104   0x4611             MOV      R1,R2
   \   00000106   0x4628             MOV      R0,R5
   \   00000108   0x.... 0x....      BL       SPI_WaitFlagStateUntilTimeout
   \   0000010C   0x2800             CMP      R0,#+0
   \   0000010E   0xD118             BNE.N    ??HAL_SPI_Transmit_13
    494                  {
    495                    return HAL_TIMEOUT;
    496                  }
    497                  *((__IO uint8_t*)&hspi->Instance->DR) = (*hspi->pTxBuffPtr++);
   \   00000110   0x6BA8             LDR      R0,[R5, #+56]
   \   00000112   0x1C41             ADDS     R1,R0,#+1
   \   00000114   0x63A9             STR      R1,[R5, #+56]
   \   00000116   0x7800             LDRB     R0,[R0, #+0]
   \   00000118   0x6829             LDR      R1,[R5, #+0]
   \   0000011A   0x7308             STRB     R0,[R1, #+12]
    498                  hspi->TxXferCount--;    
   \   0000011C   0x8FE8             LDRH     R0,[R5, #+62]
   \   0000011E   0x1E40             SUBS     R0,R0,#+1
   \   00000120   0x87E8             STRH     R0,[R5, #+62]
   \   00000122   0xE7DB             B.N      ??HAL_SPI_Transmit_7
    499                }
    500              }
    501            }
    502          
    503            /* Enable CRC Transmission */
    504            if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   \                     ??HAL_SPI_Transmit_9: (+1)
   \   00000124   0x6AA8             LDR      R0,[R5, #+40]
   \   00000126   0xF5B0 0x5F00      CMP      R0,#+8192
   \   0000012A   0xD104             BNE.N    ??HAL_SPI_Transmit_14
    505            {
    506               hspi->Instance->CR1|= SPI_CR1_CRCNEXT;
   \   0000012C   0x6828             LDR      R0,[R5, #+0]
   \   0000012E   0x6801             LDR      R1,[R0, #+0]
   \   00000130   0xF441 0x5180      ORR      R1,R1,#0x1000
   \   00000134   0x6001             STR      R1,[R0, #+0]
    507            }
    508          
    509            /* Check the end of the transaction */
    510            if(SPI_EndRxTxTransaction(hspi,Timeout) != HAL_OK)
   \                     ??HAL_SPI_Transmit_14: (+1)
   \   00000136   0x4631             MOV      R1,R6
   \   00000138   0x4628             MOV      R0,R5
   \   0000013A   0x.... 0x....      BL       SPI_EndRxTxTransaction
   \   0000013E   0x2800             CMP      R0,#+0
   \   00000140   0xD001             BEQ.N    ??HAL_SPI_Transmit_15
    511            {
    512              return HAL_TIMEOUT;
   \                     ??HAL_SPI_Transmit_13: (+1)
   \   00000142   0x2003             MOVS     R0,#+3
   \   00000144   0xBD76             POP      {R1,R2,R4-R6,PC}
    513            }
    514            
    515            /* Clear OVERUN flag in 2 Lines communication mode because received is not read */
    516            if(hspi->Init.Direction == SPI_DIRECTION_2LINES)
   \                     ??HAL_SPI_Transmit_15: (+1)
   \   00000146   0x68A8             LDR      R0,[R5, #+8]
   \   00000148   0x2800             CMP      R0,#+0
   \   0000014A   0xD105             BNE.N    ??HAL_SPI_Transmit_16
    517            {
    518              __HAL_SPI_CLEAR_OVRFLAG(hspi);
   \   0000014C   0x6828             LDR      R0,[R5, #+0]
   \   0000014E   0x68C1             LDR      R1,[R0, #+12]
   \   00000150   0x9100             STR      R1,[SP, #+0]
   \   00000152   0x6880             LDR      R0,[R0, #+8]
   \   00000154   0x9000             STR      R0,[SP, #+0]
   \   00000156   0x9800             LDR      R0,[SP, #+0]
    519            }
    520              
    521            hspi->State = HAL_SPI_STATE_READY; 
   \                     ??HAL_SPI_Transmit_16: (+1)
   \   00000158   0x2001             MOVS     R0,#+1
   \   0000015A   0x7660             STRB     R0,[R4, #+25]
    522          
    523            /* Process Unlocked */
    524            __HAL_UNLOCK(hspi);
   \   0000015C   0x2000             MOVS     R0,#+0
   \   0000015E   0x7620             STRB     R0,[R4, #+24]
    525            
    526            if(hspi->ErrorCode != HAL_SPI_ERROR_NONE)
   \   00000160   0x69E0             LDR      R0,[R4, #+28]
   \   00000162   0x1E40             SUBS     R0,R0,#+1
   \   00000164   0x4180             SBCS     R0,R0,R0
   \   00000166   0x43C0             MVNS     R0,R0
   \   00000168   0x0FC0             LSRS     R0,R0,#+31
    527            {   
    528              return HAL_ERROR;
    529            }
    530            else
    531            {
    532              return HAL_OK;
   \   0000016A   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
    533            }
    534          }
    535          
    536          /**
    537            * @brief  Receive an amount of data in blocking mode
    538            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
    539            *               the configuration information for SPI module.
    540            * @param  pData: pointer to data buffer
    541            * @param  Size: amount of data to be received
    542            * @param  Timeout: Timeout duration
    543            * @retval HAL status
    544            */

   \                                 In section .text, align 2, keep-with-next
    545          HAL_StatusTypeDef HAL_SPI_Receive(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size, uint32_t Timeout)
    546          {
   \                     HAL_SPI_Receive: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x461D             MOV      R5,R3
    547            __IO uint16_t tmpreg;
    548            
    549            if(hspi->State != HAL_SPI_STATE_READY)
   \   00000006   0xF104 0x0644      ADD      R6,R4,#+68
   \   0000000A   0x7E70             LDRB     R0,[R6, #+25]
   \   0000000C   0x2801             CMP      R0,#+1
   \   0000000E   0xD116             BNE.N    ??HAL_SPI_Receive_0
    550            {
    551              return HAL_BUSY;
    552            }
    553            
    554            if((pData == NULL ) || (Size == 0))
   \   00000010   0x2900             CMP      R1,#+0
   \   00000012   0xD001             BEQ.N    ??HAL_SPI_Receive_1
   \   00000014   0x2A00             CMP      R2,#+0
   \   00000016   0xD101             BNE.N    ??HAL_SPI_Receive_2
    555            {
    556              return HAL_ERROR;
   \                     ??HAL_SPI_Receive_1: (+1)
   \   00000018   0x2001             MOVS     R0,#+1
   \   0000001A   0xBDF2             POP      {R1,R4-R7,PC}
    557            }
    558          
    559            if((hspi->Init.Mode == SPI_MODE_MASTER) && (hspi->Init.Direction == SPI_DIRECTION_2LINES))
   \                     ??HAL_SPI_Receive_2: (+1)
   \   0000001C   0x6860             LDR      R0,[R4, #+4]
   \   0000001E   0xF5B0 0x7F82      CMP      R0,#+260
   \   00000022   0xD109             BNE.N    ??HAL_SPI_Receive_3
   \   00000024   0x68A0             LDR      R0,[R4, #+8]
   \   00000026   0x2800             CMP      R0,#+0
   \   00000028   0xD106             BNE.N    ??HAL_SPI_Receive_3
    560            {
    561              /* the receive process is not supported in 2Lines direction master mode */
    562              /* in this case we call the transmitReceive process                     */
    563              return HAL_SPI_TransmitReceive(hspi,pData,pData,Size,Timeout);
   \   0000002A   0x9500             STR      R5,[SP, #+0]
   \   0000002C   0x4613             MOV      R3,R2
   \   0000002E   0x460A             MOV      R2,R1
   \   00000030   0x4620             MOV      R0,R4
   \   00000032   0x.... 0x....      BL       HAL_SPI_TransmitReceive
   \   00000036   0xBDF2             POP      {R1,R4-R7,PC}
    564            }
    565            
    566            /* Process Locked */
    567            __HAL_LOCK(hspi);
   \                     ??HAL_SPI_Receive_3: (+1)
   \   00000038   0x7E30             LDRB     R0,[R6, #+24]
   \   0000003A   0x2801             CMP      R0,#+1
   \   0000003C   0xD101             BNE.N    ??HAL_SPI_Receive_4
   \                     ??HAL_SPI_Receive_0: (+1)
   \   0000003E   0x2002             MOVS     R0,#+2
   \   00000040   0xBDF2             POP      {R1,R4-R7,PC}
   \                     ??HAL_SPI_Receive_4: (+1)
   \   00000042   0x2001             MOVS     R0,#+1
   \   00000044   0x7630             STRB     R0,[R6, #+24]
    568              
    569            hspi->State       = HAL_SPI_STATE_BUSY_RX;
   \   00000046   0x2004             MOVS     R0,#+4
   \   00000048   0x7670             STRB     R0,[R6, #+25]
    570            hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
   \   0000004A   0x2000             MOVS     R0,#+0
   \   0000004C   0x61F0             STR      R0,[R6, #+28]
    571            hspi->pRxBuffPtr  = pData;
   \   0000004E   0x6421             STR      R1,[R4, #+64]
    572            hspi->RxXferSize  = Size;
   \   00000050   0x8032             STRH     R2,[R6, #+0]
    573            hspi->RxXferCount = Size;
   \   00000052   0x8072             STRH     R2,[R6, #+2]
    574            hspi->pTxBuffPtr  = (uint8_t *)NULL;
   \   00000054   0x63A0             STR      R0,[R4, #+56]
    575            hspi->TxXferSize  = 0;
   \   00000056   0x87A0             STRH     R0,[R4, #+60]
    576            hspi->TxXferCount = 0;
   \   00000058   0x87E0             STRH     R0,[R4, #+62]
    577          
    578            /* Reset CRC Calculation */
    579            if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   \   0000005A   0x6AA0             LDR      R0,[R4, #+40]
   \   0000005C   0xF5B0 0x5F00      CMP      R0,#+8192
   \   00000060   0xD10D             BNE.N    ??HAL_SPI_Receive_5
    580            {
    581              SPI_RESET_CRC(hspi);
   \   00000062   0x6820             LDR      R0,[R4, #+0]
   \   00000064   0x6801             LDR      R1,[R0, #+0]
   \   00000066   0xF64D 0x72FF      MOVW     R2,#+57343
   \   0000006A   0x4011             ANDS     R1,R2,R1
   \   0000006C   0x6001             STR      R1,[R0, #+0]
   \   0000006E   0x6820             LDR      R0,[R4, #+0]
   \   00000070   0x6801             LDR      R1,[R0, #+0]
   \   00000072   0xF441 0x5100      ORR      R1,R1,#0x2000
   \   00000076   0x6001             STR      R1,[R0, #+0]
    582              /* this is done to handle the CRCNEXT before the latest data */
    583              hspi->RxXferCount--;
   \   00000078   0x8870             LDRH     R0,[R6, #+2]
   \   0000007A   0x1E40             SUBS     R0,R0,#+1
   \   0000007C   0x8070             STRH     R0,[R6, #+2]
    584            }
    585          
    586            /* Set the Rx Fido threshold */
    587            if(hspi->Init.DataSize > SPI_DATASIZE_8BIT)
   \                     ??HAL_SPI_Receive_5: (+1)
   \   0000007E   0x6820             LDR      R0,[R4, #+0]
   \   00000080   0xF240 0x7701      MOVW     R7,#+1793
   \   00000084   0x68E1             LDR      R1,[R4, #+12]
   \   00000086   0x42B9             CMP      R1,R7
   \   00000088   0x6841             LDR      R1,[R0, #+4]
   \   0000008A   0xD303             BCC.N    ??HAL_SPI_Receive_6
    588            {
    589              /* set fiforxthreshold according the reception data length: 16bit */
    590              CLEAR_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
   \   0000008C   0xF421 0x5180      BIC      R1,R1,#0x1000
   \   00000090   0x6041             STR      R1,[R0, #+4]
   \   00000092   0xE002             B.N      ??HAL_SPI_Receive_7
    591            }
    592            else
    593            {
    594              /* set fiforxthreshold according the reception data length: 8bit */
    595              SET_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
   \                     ??HAL_SPI_Receive_6: (+1)
   \   00000094   0xF441 0x5180      ORR      R1,R1,#0x1000
   \   00000098   0x6041             STR      R1,[R0, #+4]
    596            }
    597          
    598            /* Configure communication direction 1Line and enabled SPI if needed */
    599            if(hspi->Init.Direction == SPI_DIRECTION_1LINE)
   \                     ??HAL_SPI_Receive_7: (+1)
   \   0000009A   0x68A0             LDR      R0,[R4, #+8]
   \   0000009C   0xF5B0 0x4F00      CMP      R0,#+32768
   \   000000A0   0xD104             BNE.N    ??HAL_SPI_Receive_8
    600            {
    601              SPI_1LINE_RX(hspi);
   \   000000A2   0x6820             LDR      R0,[R4, #+0]
   \   000000A4   0x6801             LDR      R1,[R0, #+0]
   \   000000A6   0xF421 0x4180      BIC      R1,R1,#0x4000
   \   000000AA   0x6001             STR      R1,[R0, #+0]
    602            }
    603          
    604            /* Check if the SPI is already enabled */
    605            if((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
   \                     ??HAL_SPI_Receive_8: (+1)
   \   000000AC   0x6820             LDR      R0,[R4, #+0]
   \   000000AE   0x6801             LDR      R1,[R0, #+0]
   \   000000B0   0x0649             LSLS     R1,R1,#+25
   \   000000B2   0xD403             BMI.N    ??HAL_SPI_Receive_9
    606            {
    607              /* Enable SPI peripheral */
    608              __HAL_SPI_ENABLE(hspi);
   \   000000B4   0x6801             LDR      R1,[R0, #+0]
   \   000000B6   0xF041 0x0140      ORR      R1,R1,#0x40
   \   000000BA   0x6001             STR      R1,[R0, #+0]
    609            }
    610          
    611            /* Receive data in 8 Bit mode */
    612            if(hspi->Init.DataSize <= SPI_DATASIZE_8BIT)
   \                     ??HAL_SPI_Receive_9: (+1)
   \   000000BC   0x68E0             LDR      R0,[R4, #+12]
   \   000000BE   0x42B8             CMP      R0,R7
   \   000000C0   0xD227             BCS.N    ??HAL_SPI_Receive_10
    613            {
    614              while(hspi->RxXferCount > 1)
   \                     ??HAL_SPI_Receive_11: (+1)
   \   000000C2   0x8870             LDRH     R0,[R6, #+2]
   \   000000C4   0x2802             CMP      R0,#+2
   \   000000C6   0xDB27             BLT.N    ??HAL_SPI_Receive_12
    615              {
    616                /* Wait until the RXNE flag */
    617                if(SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_RXNE, SPI_FLAG_RXNE, Timeout) != HAL_OK)
   \   000000C8   0x462B             MOV      R3,R5
   \   000000CA   0x2201             MOVS     R2,#+1
   \   000000CC   0x4611             MOV      R1,R2
   \   000000CE   0x4620             MOV      R0,R4
   \   000000D0   0x.... 0x....      BL       SPI_WaitFlagStateUntilTimeout
   \   000000D4   0x2800             CMP      R0,#+0
   \   000000D6   0xF040 0x8080      BNE.W    ??HAL_SPI_Receive_13
    618                {
    619                  return HAL_TIMEOUT;
    620                }
    621                (*hspi->pRxBuffPtr++)= *(__IO uint8_t *)&hspi->Instance->DR;
   \   000000DA   0x6C20             LDR      R0,[R4, #+64]
   \   000000DC   0x1C41             ADDS     R1,R0,#+1
   \   000000DE   0x6421             STR      R1,[R4, #+64]
   \   000000E0   0x6821             LDR      R1,[R4, #+0]
   \   000000E2   0x7B09             LDRB     R1,[R1, #+12]
   \   000000E4   0x7001             STRB     R1,[R0, #+0]
    622                hspi->RxXferCount--;  
   \   000000E6   0x8870             LDRH     R0,[R6, #+2]
   \   000000E8   0x1E40             SUBS     R0,R0,#+1
   \   000000EA   0x8070             STRH     R0,[R6, #+2]
   \   000000EC   0xE7E9             B.N      ??HAL_SPI_Receive_11
    623              }
    624            }
    625            else /* Receive data in 16 Bit mode */
    626            {   
    627              while(hspi->RxXferCount > 1 )
    628              {
    629                /* Wait until RXNE flag is reset to read data */
    630                if(SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_RXNE, SPI_FLAG_RXNE, Timeout) != HAL_OK)
   \                     ??HAL_SPI_Receive_14: (+1)
   \   000000EE   0x462B             MOV      R3,R5
   \   000000F0   0x2201             MOVS     R2,#+1
   \   000000F2   0x4611             MOV      R1,R2
   \   000000F4   0x4620             MOV      R0,R4
   \   000000F6   0x.... 0x....      BL       SPI_WaitFlagStateUntilTimeout
   \   000000FA   0x2800             CMP      R0,#+0
   \   000000FC   0xD16D             BNE.N    ??HAL_SPI_Receive_13
    631                {
    632                  return HAL_TIMEOUT;
    633                }
    634                *((uint16_t*)hspi->pRxBuffPtr) = hspi->Instance->DR;
   \   000000FE   0x6820             LDR      R0,[R4, #+0]
   \   00000100   0x68C0             LDR      R0,[R0, #+12]
   \   00000102   0x6C21             LDR      R1,[R4, #+64]
   \   00000104   0x8008             STRH     R0,[R1, #+0]
    635                hspi->pRxBuffPtr += sizeof(uint16_t);
   \   00000106   0x6C20             LDR      R0,[R4, #+64]
   \   00000108   0x1C80             ADDS     R0,R0,#+2
   \   0000010A   0x6420             STR      R0,[R4, #+64]
    636                hspi->RxXferCount--;
   \   0000010C   0x8870             LDRH     R0,[R6, #+2]
   \   0000010E   0x1E40             SUBS     R0,R0,#+1
   \   00000110   0x8070             STRH     R0,[R6, #+2]
    637              } 
   \                     ??HAL_SPI_Receive_10: (+1)
   \   00000112   0x8870             LDRH     R0,[R6, #+2]
   \   00000114   0x2802             CMP      R0,#+2
   \   00000116   0xDAEA             BGE.N    ??HAL_SPI_Receive_14
    638            }
    639            
    640            /* Enable CRC Transmission */
    641            if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE) 
   \                     ??HAL_SPI_Receive_12: (+1)
   \   00000118   0x6AA0             LDR      R0,[R4, #+40]
   \   0000011A   0xF5B0 0x5F00      CMP      R0,#+8192
   \   0000011E   0xD104             BNE.N    ??HAL_SPI_Receive_15
    642            {
    643              hspi->Instance->CR1 |= SPI_CR1_CRCNEXT;
   \   00000120   0x6820             LDR      R0,[R4, #+0]
   \   00000122   0x6801             LDR      R1,[R0, #+0]
   \   00000124   0xF441 0x5180      ORR      R1,R1,#0x1000
   \   00000128   0x6001             STR      R1,[R0, #+0]
    644            }  
    645          
    646            /* Wait until RXNE flag is set */
    647            if(SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_RXNE, SPI_FLAG_RXNE, Timeout) != HAL_OK)
   \                     ??HAL_SPI_Receive_15: (+1)
   \   0000012A   0x462B             MOV      R3,R5
   \   0000012C   0x2201             MOVS     R2,#+1
   \   0000012E   0x4611             MOV      R1,R2
   \   00000130   0x4620             MOV      R0,R4
   \   00000132   0x.... 0x....      BL       SPI_WaitFlagStateUntilTimeout
   \   00000136   0x2800             CMP      R0,#+0
   \   00000138   0xD14F             BNE.N    ??HAL_SPI_Receive_13
    648            {
    649              return HAL_TIMEOUT;
    650            }
    651            
    652            /* Receive last data in 16 Bit mode */
    653            if(hspi->Init.DataSize > SPI_DATASIZE_8BIT)
   \   0000013A   0x6C20             LDR      R0,[R4, #+64]
   \   0000013C   0x68E1             LDR      R1,[R4, #+12]
   \   0000013E   0x42B9             CMP      R1,R7
   \   00000140   0xD306             BCC.N    ??HAL_SPI_Receive_16
    654            {        
    655              *((uint16_t*)hspi->pRxBuffPtr) = hspi->Instance->DR;
   \   00000142   0x6821             LDR      R1,[R4, #+0]
   \   00000144   0x68C9             LDR      R1,[R1, #+12]
   \   00000146   0x8001             STRH     R1,[R0, #+0]
    656              hspi->pRxBuffPtr += sizeof(uint16_t);
   \   00000148   0x6C20             LDR      R0,[R4, #+64]
   \   0000014A   0x1C80             ADDS     R0,R0,#+2
   \   0000014C   0x6420             STR      R0,[R4, #+64]
   \   0000014E   0xE004             B.N      ??HAL_SPI_Receive_17
    657            }
    658            /* Receive last data in 8 Bit mode */
    659            else 
    660            {
    661              (*hspi->pRxBuffPtr++) = *(__IO uint8_t *)&hspi->Instance->DR;
   \                     ??HAL_SPI_Receive_16: (+1)
   \   00000150   0x1C41             ADDS     R1,R0,#+1
   \   00000152   0x6421             STR      R1,[R4, #+64]
   \   00000154   0x6821             LDR      R1,[R4, #+0]
   \   00000156   0x7B09             LDRB     R1,[R1, #+12]
   \   00000158   0x7001             STRB     R1,[R0, #+0]
    662            }
    663            hspi->RxXferCount--;
   \                     ??HAL_SPI_Receive_17: (+1)
   \   0000015A   0x8870             LDRH     R0,[R6, #+2]
   \   0000015C   0x1E40             SUBS     R0,R0,#+1
   \   0000015E   0x8070             STRH     R0,[R6, #+2]
    664            
    665            /* Read CRC from DR to close CRC calculation process */
    666            if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   \   00000160   0x6AA0             LDR      R0,[R4, #+40]
   \   00000162   0xF5B0 0x5F00      CMP      R0,#+8192
   \   00000166   0xD132             BNE.N    ??HAL_SPI_Receive_18
    667            {
    668              /* Wait until TXE flag */
    669              if(SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_RXNE, SPI_FLAG_RXNE, Timeout) != HAL_OK) 
   \   00000168   0x462B             MOV      R3,R5
   \   0000016A   0x2201             MOVS     R2,#+1
   \   0000016C   0x4611             MOV      R1,R2
   \   0000016E   0x4620             MOV      R0,R4
   \   00000170   0x.... 0x....      BL       SPI_WaitFlagStateUntilTimeout
   \   00000174   0x2800             CMP      R0,#+0
   \   00000176   0xD003             BEQ.N    ??HAL_SPI_Receive_19
    670              {
    671                /* Error on the CRC reception */
    672                hspi->ErrorCode|= HAL_SPI_ERROR_CRC;
   \   00000178   0x69F0             LDR      R0,[R6, #+28]
   \   0000017A   0xF040 0x0002      ORR      R0,R0,#0x2
   \   0000017E   0x61F0             STR      R0,[R6, #+28]
    673              }
    674              if(hspi->Init.DataSize > SPI_DATASIZE_8BIT)
   \                     ??HAL_SPI_Receive_19: (+1)
   \   00000180   0x68E0             LDR      R0,[R4, #+12]
   \   00000182   0x6821             LDR      R1,[R4, #+0]
   \   00000184   0x42B8             CMP      R0,R7
   \   00000186   0xD305             BCC.N    ??HAL_SPI_Receive_20
    675              {        
    676                tmpreg = hspi->Instance->DR;
   \   00000188   0x68C8             LDR      R0,[R1, #+12]
   \   0000018A   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    677                UNUSED(tmpreg); /* To avoid GCC warning */
   \   0000018E   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   00000192   0xE01C             B.N      ??HAL_SPI_Receive_18
    678              }
    679              else
    680              {
    681                tmpreg = *(__IO uint8_t *)&hspi->Instance->DR;
   \                     ??HAL_SPI_Receive_20: (+1)
   \   00000194   0x7B09             LDRB     R1,[R1, #+12]
   \   00000196   0xF8AD 0x1000      STRH     R1,[SP, #+0]
    682                UNUSED(tmpreg); /* To avoid GCC warning */
   \   0000019A   0xF8BD 0x1000      LDRH     R1,[SP, #+0]
    683          
    684                if((hspi->Init.DataSize == SPI_DATASIZE_8BIT) && (hspi->Init.CRCLength == SPI_CRC_LENGTH_16BIT))
   \   0000019E   0xF5B0 0x6FE0      CMP      R0,#+1792
   \   000001A2   0xD114             BNE.N    ??HAL_SPI_Receive_18
   \   000001A4   0x6B20             LDR      R0,[R4, #+48]
   \   000001A6   0x2802             CMP      R0,#+2
   \   000001A8   0xD111             BNE.N    ??HAL_SPI_Receive_18
    685                {
    686                  if(SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_RXNE, SPI_FLAG_RXNE, Timeout) != HAL_OK)
   \   000001AA   0x462B             MOV      R3,R5
   \   000001AC   0x2201             MOVS     R2,#+1
   \   000001AE   0x4611             MOV      R1,R2
   \   000001B0   0x4620             MOV      R0,R4
   \   000001B2   0x.... 0x....      BL       SPI_WaitFlagStateUntilTimeout
   \   000001B6   0x2800             CMP      R0,#+0
   \   000001B8   0xD003             BEQ.N    ??HAL_SPI_Receive_21
    687                  {
    688                    /* Error on the CRC reception */
    689                    hspi->ErrorCode|= HAL_SPI_ERROR_FLAG;
   \   000001BA   0x69F0             LDR      R0,[R6, #+28]
   \   000001BC   0xF040 0x0020      ORR      R0,R0,#0x20
   \   000001C0   0x61F0             STR      R0,[R6, #+28]
    690                  }
    691                  tmpreg = *(__IO uint8_t *)&hspi->Instance->DR;
   \                     ??HAL_SPI_Receive_21: (+1)
   \   000001C2   0x6820             LDR      R0,[R4, #+0]
   \   000001C4   0x7B00             LDRB     R0,[R0, #+12]
   \   000001C6   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    692                  UNUSED(tmpreg); /* To avoid GCC warning */
   \   000001CA   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
    693                }
    694              }
    695            }
    696            
    697            /* Check the end of the transaction */
    698            if(SPI_EndRxTransaction(hspi,Timeout) != HAL_OK)
   \                     ??HAL_SPI_Receive_18: (+1)
   \   000001CE   0x4629             MOV      R1,R5
   \   000001D0   0x4620             MOV      R0,R4
   \   000001D2   0x.... 0x....      BL       SPI_EndRxTransaction
   \   000001D6   0x2800             CMP      R0,#+0
   \   000001D8   0xD001             BEQ.N    ??HAL_SPI_Receive_22
    699            {
    700              return HAL_TIMEOUT;
   \                     ??HAL_SPI_Receive_13: (+1)
   \   000001DA   0x2003             MOVS     R0,#+3
   \   000001DC   0xBDF2             POP      {R1,R4-R7,PC}
    701            }
    702          
    703            hspi->State = HAL_SPI_STATE_READY; 
   \                     ??HAL_SPI_Receive_22: (+1)
   \   000001DE   0x2001             MOVS     R0,#+1
   \   000001E0   0x7670             STRB     R0,[R6, #+25]
    704              
    705            /* Check if CRC error occurred */
    706            if(__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_CRCERR) != RESET)
   \   000001E2   0x6820             LDR      R0,[R4, #+0]
   \   000001E4   0x6880             LDR      R0,[R0, #+8]
   \   000001E6   0x06C0             LSLS     R0,R0,#+27
   \   000001E8   0xD50B             BPL.N    ??HAL_SPI_Receive_23
    707            {
    708              hspi->ErrorCode|= HAL_SPI_ERROR_CRC;
   \   000001EA   0x69F0             LDR      R0,[R6, #+28]
   \   000001EC   0xF040 0x0002      ORR      R0,R0,#0x2
   \   000001F0   0x61F0             STR      R0,[R6, #+28]
    709              __HAL_SPI_CLEAR_CRCERRFLAG(hspi);
   \   000001F2   0xF64F 0x70EF      MOVW     R0,#+65519
   \   000001F6   0x6821             LDR      R1,[R4, #+0]
   \   000001F8   0x6088             STR      R0,[R1, #+8]
    710                            
    711              /* Process Unlocked */
    712              __HAL_UNLOCK(hspi);
   \   000001FA   0x2000             MOVS     R0,#+0
   \   000001FC   0x7630             STRB     R0,[R6, #+24]
    713              return HAL_ERROR;
   \   000001FE   0x2001             MOVS     R0,#+1
   \   00000200   0xBDF2             POP      {R1,R4-R7,PC}
    714            }
    715              
    716            /* Process Unlocked */
    717            __HAL_UNLOCK(hspi);
   \                     ??HAL_SPI_Receive_23: (+1)
   \   00000202   0x2000             MOVS     R0,#+0
   \   00000204   0x7630             STRB     R0,[R6, #+24]
    718            
    719            if(hspi->ErrorCode != HAL_SPI_ERROR_NONE)
   \   00000206   0x69F0             LDR      R0,[R6, #+28]
   \   00000208   0x1E40             SUBS     R0,R0,#+1
   \   0000020A   0x4180             SBCS     R0,R0,R0
   \   0000020C   0x43C0             MVNS     R0,R0
   \   0000020E   0x0FC0             LSRS     R0,R0,#+31
    720            {   
    721              return HAL_ERROR;
    722            }
    723            else
    724            {
    725              return HAL_OK;
   \   00000210   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    726            }
    727          }
    728          
    729          /**
    730            * @brief  Transmit and Receive an amount of data in blocking mode
    731            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
    732            *               the configuration information for SPI module.
    733            * @param  pTxData: pointer to transmission data buffer
    734            * @param  pRxData: pointer to reception data buffer
    735            * @param  Size: amount of data to be sent and received
    736            * @param  Timeout: Timeout duration
    737            * @retval HAL status
    738            */

   \                                 In section .text, align 2, keep-with-next
    739          HAL_StatusTypeDef HAL_SPI_TransmitReceive(SPI_HandleTypeDef *hspi, uint8_t *pTxData, uint8_t *pRxData, uint16_t Size, uint32_t Timeout)
    740          {
   \                     HAL_SPI_TransmitReceive: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460F             MOV      R7,R1
   \   00000008   0x4690             MOV      R8,R2
   \   0000000A   0x4699             MOV      R9,R3
    741            __IO uint16_t tmpreg = 0;
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    742            uint32_t tickstart = HAL_GetTick();
   \   00000012   0x.... 0x....      BL       HAL_GetTick
   \   00000016   0x4606             MOV      R6,R0
    743            
    744            assert_param(IS_SPI_DIRECTION_2LINES(hspi->Init.Direction));
    745            
    746            if(hspi->State != HAL_SPI_STATE_READY) 
   \   00000018   0xF104 0x0544      ADD      R5,R4,#+68
   \   0000001C   0x7E68             LDRB     R0,[R5, #+25]
   \   0000001E   0x2801             CMP      R0,#+1
   \   00000020   0xD10C             BNE.N    ??HAL_SPI_TransmitReceive_0
    747            {
    748              return HAL_BUSY;
    749            }
    750            
    751            if((pTxData == NULL) || (pRxData == NULL) || (Size == 0))
   \   00000022   0x2F00             CMP      R7,#+0
   \   00000024   0xD005             BEQ.N    ??HAL_SPI_TransmitReceive_1
   \   00000026   0xF1B8 0x0F00      CMP      R8,#+0
   \   0000002A   0xD002             BEQ.N    ??HAL_SPI_TransmitReceive_1
   \   0000002C   0xF1B9 0x0F00      CMP      R9,#+0
   \   00000030   0xD101             BNE.N    ??HAL_SPI_TransmitReceive_2
    752            {
    753              return HAL_ERROR;
   \                     ??HAL_SPI_TransmitReceive_1: (+1)
   \   00000032   0x2001             MOVS     R0,#+1
   \   00000034   0xE135             B.N      ??HAL_SPI_TransmitReceive_3
    754            }
    755          
    756            
    757            /* Process Locked */
    758            __HAL_LOCK(hspi); 
   \                     ??HAL_SPI_TransmitReceive_2: (+1)
   \   00000036   0x7E28             LDRB     R0,[R5, #+24]
   \   00000038   0x2801             CMP      R0,#+1
   \   0000003A   0xD101             BNE.N    ??HAL_SPI_TransmitReceive_4
   \                     ??HAL_SPI_TransmitReceive_0: (+1)
   \   0000003C   0x2002             MOVS     R0,#+2
   \   0000003E   0xE130             B.N      ??HAL_SPI_TransmitReceive_3
   \                     ??HAL_SPI_TransmitReceive_4: (+1)
   \   00000040   0x2001             MOVS     R0,#+1
   \   00000042   0x7628             STRB     R0,[R5, #+24]
    759            
    760            hspi->State       = HAL_SPI_STATE_BUSY_TX_RX;
   \   00000044   0x2005             MOVS     R0,#+5
   \   00000046   0x7668             STRB     R0,[R5, #+25]
    761            hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
   \   00000048   0x2000             MOVS     R0,#+0
   \   0000004A   0x61E8             STR      R0,[R5, #+28]
    762            hspi->pRxBuffPtr  = pRxData;
   \   0000004C   0xF8C4 0x8040      STR      R8,[R4, #+64]
    763            hspi->RxXferCount = Size;
   \   00000050   0xF8A5 0x9002      STRH     R9,[R5, #+2]
    764            hspi->RxXferSize  = Size;
   \   00000054   0xF8A5 0x9000      STRH     R9,[R5, #+0]
    765            hspi->pTxBuffPtr  = pTxData;
   \   00000058   0x63A7             STR      R7,[R4, #+56]
    766            hspi->TxXferCount = Size;
   \   0000005A   0xF8A4 0x903E      STRH     R9,[R4, #+62]
    767            hspi->TxXferSize  = Size;
   \   0000005E   0xF8A4 0x903C      STRH     R9,[R4, #+60]
    768          
    769            /* Reset CRC Calculation */
    770            if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   \   00000062   0x6AA0             LDR      R0,[R4, #+40]
   \   00000064   0xF5B0 0x5F00      CMP      R0,#+8192
   \   00000068   0xD10A             BNE.N    ??HAL_SPI_TransmitReceive_5
    771            {
    772              SPI_RESET_CRC(hspi);
   \   0000006A   0x6820             LDR      R0,[R4, #+0]
   \   0000006C   0x6801             LDR      R1,[R0, #+0]
   \   0000006E   0xF64D 0x72FF      MOVW     R2,#+57343
   \   00000072   0x4011             ANDS     R1,R2,R1
   \   00000074   0x6001             STR      R1,[R0, #+0]
   \   00000076   0x6820             LDR      R0,[R4, #+0]
   \   00000078   0x6801             LDR      R1,[R0, #+0]
   \   0000007A   0xF441 0x5100      ORR      R1,R1,#0x2000
   \   0000007E   0x6001             STR      R1,[R0, #+0]
    773            }
    774          
    775            /* Set the Rx Fido threshold */
    776            if((hspi->Init.DataSize > SPI_DATASIZE_8BIT) || (hspi->RxXferCount > 1))
   \                     ??HAL_SPI_TransmitReceive_5: (+1)
   \   00000080   0xF240 0x7001      MOVW     R0,#+1793
   \   00000084   0x68E1             LDR      R1,[R4, #+12]
   \   00000086   0x4281             CMP      R1,R0
   \   00000088   0xD202             BCS.N    ??HAL_SPI_TransmitReceive_6
   \   0000008A   0x8869             LDRH     R1,[R5, #+2]
   \   0000008C   0x2902             CMP      R1,#+2
   \   0000008E   0xDB05             BLT.N    ??HAL_SPI_TransmitReceive_7
    777            {
    778              /* set fiforxthreshold according the reception data length: 16bit */
    779              CLEAR_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
   \                     ??HAL_SPI_TransmitReceive_6: (+1)
   \   00000090   0x6821             LDR      R1,[R4, #+0]
   \   00000092   0x684A             LDR      R2,[R1, #+4]
   \   00000094   0xF422 0x5280      BIC      R2,R2,#0x1000
   \   00000098   0x604A             STR      R2,[R1, #+4]
   \   0000009A   0xE004             B.N      ??HAL_SPI_TransmitReceive_8
    780            }
    781            else
    782            {
    783              /* set fiforxthreshold according the reception data length: 8bit */
    784              SET_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
   \                     ??HAL_SPI_TransmitReceive_7: (+1)
   \   0000009C   0x6821             LDR      R1,[R4, #+0]
   \   0000009E   0x684A             LDR      R2,[R1, #+4]
   \   000000A0   0xF442 0x5280      ORR      R2,R2,#0x1000
   \   000000A4   0x604A             STR      R2,[R1, #+4]
    785            }
    786          
    787            /* Check if the SPI is already enabled */
    788            if((hspi->Instance->CR1 &SPI_CR1_SPE) != SPI_CR1_SPE)
   \                     ??HAL_SPI_TransmitReceive_8: (+1)
   \   000000A6   0x6821             LDR      R1,[R4, #+0]
   \   000000A8   0x680A             LDR      R2,[R1, #+0]
   \   000000AA   0x0652             LSLS     R2,R2,#+25
   \   000000AC   0xD403             BMI.N    ??HAL_SPI_TransmitReceive_9
    789            {
    790              /* Enable SPI peripheral */
    791              __HAL_SPI_ENABLE(hspi);
   \   000000AE   0x680A             LDR      R2,[R1, #+0]
   \   000000B0   0xF042 0x0240      ORR      R2,R2,#0x40
   \   000000B4   0x600A             STR      R2,[R1, #+0]
   \                     ??HAL_SPI_TransmitReceive_9: (+1)
   \   000000B6   0x9F08             LDR      R7,[SP, #+32]
    792            }
    793          
    794            /* Transmit and Receive data in 16 Bit mode */
    795            if(hspi->Init.DataSize > SPI_DATASIZE_8BIT)
   \   000000B8   0x68E1             LDR      R1,[R4, #+12]
   \   000000BA   0x4281             CMP      R1,R0
   \   000000BC   0xD33C             BCC.N    ??HAL_SPI_TransmitReceive_10
    796            {
    797              while ((hspi->TxXferCount > 0 ) || (hspi->RxXferCount > 0))
   \                     ??HAL_SPI_TransmitReceive_11: (+1)
   \   000000BE   0x8FE0             LDRH     R0,[R4, #+62]
   \   000000C0   0x2800             CMP      R0,#+0
   \   000000C2   0xD103             BNE.N    ??HAL_SPI_TransmitReceive_12
   \   000000C4   0x8869             LDRH     R1,[R5, #+2]
   \   000000C6   0x2900             CMP      R1,#+0
   \   000000C8   0xF000 0x8095      BEQ.W    ??HAL_SPI_TransmitReceive_13
    798              {
    799                /* Check TXE flag */
    800                if((hspi->TxXferCount > 0) && ((hspi->Instance->SR & SPI_FLAG_TXE) == SPI_FLAG_TXE))
   \                     ??HAL_SPI_TransmitReceive_12: (+1)
   \   000000CC   0x2800             CMP      R0,#+0
   \   000000CE   0xD018             BEQ.N    ??HAL_SPI_TransmitReceive_14
   \   000000D0   0x6820             LDR      R0,[R4, #+0]
   \   000000D2   0x6881             LDR      R1,[R0, #+8]
   \   000000D4   0x0789             LSLS     R1,R1,#+30
   \   000000D6   0xD514             BPL.N    ??HAL_SPI_TransmitReceive_14
    801                {
    802                  hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
   \   000000D8   0x6BA1             LDR      R1,[R4, #+56]
   \   000000DA   0x8809             LDRH     R1,[R1, #+0]
   \   000000DC   0x60C1             STR      R1,[R0, #+12]
    803                  hspi->pTxBuffPtr += sizeof(uint16_t);
   \   000000DE   0x6BA0             LDR      R0,[R4, #+56]
   \   000000E0   0x1C80             ADDS     R0,R0,#+2
   \   000000E2   0x63A0             STR      R0,[R4, #+56]
    804                  hspi->TxXferCount--;
   \   000000E4   0x8FE0             LDRH     R0,[R4, #+62]
   \   000000E6   0x1E40             SUBS     R0,R0,#+1
   \   000000E8   0x87E0             STRH     R0,[R4, #+62]
    805          
    806                  /* Enable CRC Transmission */
    807                  if((hspi->TxXferCount == 0) && (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE))
   \   000000EA   0xB280             UXTH     R0,R0
   \   000000EC   0x2800             CMP      R0,#+0
   \   000000EE   0xD108             BNE.N    ??HAL_SPI_TransmitReceive_14
   \   000000F0   0x6AA0             LDR      R0,[R4, #+40]
   \   000000F2   0xF5B0 0x5F00      CMP      R0,#+8192
   \   000000F6   0xD104             BNE.N    ??HAL_SPI_TransmitReceive_14
    808                  {
    809                    SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
   \   000000F8   0x6820             LDR      R0,[R4, #+0]
   \   000000FA   0x6801             LDR      R1,[R0, #+0]
   \   000000FC   0xF441 0x5180      ORR      R1,R1,#0x1000
   \   00000100   0x6001             STR      R1,[R0, #+0]
    810                  } 
    811                }
    812          
    813                /* Check RXNE flag */
    814                if((hspi->RxXferCount > 0) && ((hspi->Instance->SR & SPI_FLAG_RXNE) == SPI_FLAG_RXNE))
   \                     ??HAL_SPI_TransmitReceive_14: (+1)
   \   00000102   0x8868             LDRH     R0,[R5, #+2]
   \   00000104   0x2800             CMP      R0,#+0
   \   00000106   0xD00C             BEQ.N    ??HAL_SPI_TransmitReceive_15
   \   00000108   0x6820             LDR      R0,[R4, #+0]
   \   0000010A   0x6881             LDR      R1,[R0, #+8]
   \   0000010C   0x07C9             LSLS     R1,R1,#+31
   \   0000010E   0xD508             BPL.N    ??HAL_SPI_TransmitReceive_15
    815                {
    816                  *((uint16_t *)hspi->pRxBuffPtr) = hspi->Instance->DR;
   \   00000110   0x68C0             LDR      R0,[R0, #+12]
   \   00000112   0x6C21             LDR      R1,[R4, #+64]
   \   00000114   0x8008             STRH     R0,[R1, #+0]
    817                  hspi->pRxBuffPtr += sizeof(uint16_t);
   \   00000116   0x6C20             LDR      R0,[R4, #+64]
   \   00000118   0x1C80             ADDS     R0,R0,#+2
   \   0000011A   0x6420             STR      R0,[R4, #+64]
    818                  hspi->RxXferCount--;
   \   0000011C   0x8868             LDRH     R0,[R5, #+2]
   \   0000011E   0x1E40             SUBS     R0,R0,#+1
   \   00000120   0x8068             STRH     R0,[R5, #+2]
    819                }
    820                if(Timeout != HAL_MAX_DELAY)
   \                     ??HAL_SPI_TransmitReceive_15: (+1)
   \   00000122   0xF117 0x0F01      CMN      R7,#+1
   \   00000126   0xD0CA             BEQ.N    ??HAL_SPI_TransmitReceive_11
    821                {
    822                  if((Timeout == 0) || ((HAL_GetTick()-tickstart) > Timeout)) 
   \   00000128   0x2F00             CMP      R7,#+0
   \   0000012A   0xD05E             BEQ.N    ??HAL_SPI_TransmitReceive_16
   \   0000012C   0x.... 0x....      BL       HAL_GetTick
   \   00000130   0x1B80             SUBS     R0,R0,R6
   \   00000132   0x4287             CMP      R7,R0
   \   00000134   0xD2C3             BCS.N    ??HAL_SPI_TransmitReceive_11
   \   00000136   0xE058             B.N      ??HAL_SPI_TransmitReceive_16
    823                  {
    824                    hspi->State = HAL_SPI_STATE_READY;
    825                    __HAL_UNLOCK(hspi);
    826                    return HAL_TIMEOUT;
    827                  }
    828                }
    829              }
    830            }
    831            /* Transmit and Receive data in 8 Bit mode */
    832            else
    833            {
    834              while((hspi->TxXferCount > 0) || (hspi->RxXferCount > 0))
   \                     ??HAL_SPI_TransmitReceive_10: (+1)
   \   00000138   0x8FE0             LDRH     R0,[R4, #+62]
   \   0000013A   0x2800             CMP      R0,#+0
   \   0000013C   0xD102             BNE.N    ??HAL_SPI_TransmitReceive_17
   \   0000013E   0x8869             LDRH     R1,[R5, #+2]
   \   00000140   0x2900             CMP      R1,#+0
   \   00000142   0xD058             BEQ.N    ??HAL_SPI_TransmitReceive_13
    835              {
    836                /* check TXE flag */
    837                if((hspi->TxXferCount > 0) && ((hspi->Instance->SR & SPI_FLAG_TXE) == SPI_FLAG_TXE))
   \                     ??HAL_SPI_TransmitReceive_17: (+1)
   \   00000144   0x2800             CMP      R0,#+0
   \   00000146   0xD023             BEQ.N    ??HAL_SPI_TransmitReceive_18
   \   00000148   0x6821             LDR      R1,[R4, #+0]
   \   0000014A   0x688A             LDR      R2,[R1, #+8]
   \   0000014C   0x0792             LSLS     R2,R2,#+30
   \   0000014E   0xD51F             BPL.N    ??HAL_SPI_TransmitReceive_18
    838                {
    839                  if(hspi->TxXferCount > 1)
   \   00000150   0x6BA2             LDR      R2,[R4, #+56]
   \   00000152   0x2802             CMP      R0,#+2
   \   00000154   0xDB08             BLT.N    ??HAL_SPI_TransmitReceive_19
    840                  {
    841                    hspi->Instance->DR = *((uint16_t*)hspi->pTxBuffPtr);
   \   00000156   0x8810             LDRH     R0,[R2, #+0]
   \   00000158   0x60C8             STR      R0,[R1, #+12]
    842                    hspi->pTxBuffPtr += sizeof(uint16_t);
   \   0000015A   0x6BA0             LDR      R0,[R4, #+56]
   \   0000015C   0x1C80             ADDS     R0,R0,#+2
   \   0000015E   0x63A0             STR      R0,[R4, #+56]
    843                    hspi->TxXferCount -= 2;
   \   00000160   0x8FE0             LDRH     R0,[R4, #+62]
   \   00000162   0x1E80             SUBS     R0,R0,#+2
   \   00000164   0x87E0             STRH     R0,[R4, #+62]
   \   00000166   0xE007             B.N      ??HAL_SPI_TransmitReceive_20
    844                  }
    845                  else
    846                  {
    847                    *(__IO uint8_t *)&hspi->Instance->DR = (*hspi->pTxBuffPtr++);
   \                     ??HAL_SPI_TransmitReceive_19: (+1)
   \   00000168   0x1C50             ADDS     R0,R2,#+1
   \   0000016A   0x63A0             STR      R0,[R4, #+56]
   \   0000016C   0x7810             LDRB     R0,[R2, #+0]
   \   0000016E   0x6821             LDR      R1,[R4, #+0]
   \   00000170   0x7308             STRB     R0,[R1, #+12]
    848                    hspi->TxXferCount--;
   \   00000172   0x8FE0             LDRH     R0,[R4, #+62]
   \   00000174   0x1E40             SUBS     R0,R0,#+1
   \   00000176   0x87E0             STRH     R0,[R4, #+62]
    849                  }
    850          
    851                  /* Enable CRC Transmission */
    852                  if((hspi->TxXferCount == 0) && (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE))
   \                     ??HAL_SPI_TransmitReceive_20: (+1)
   \   00000178   0x8FE0             LDRH     R0,[R4, #+62]
   \   0000017A   0x2800             CMP      R0,#+0
   \   0000017C   0xD108             BNE.N    ??HAL_SPI_TransmitReceive_18
   \   0000017E   0x6AA0             LDR      R0,[R4, #+40]
   \   00000180   0xF5B0 0x5F00      CMP      R0,#+8192
   \   00000184   0xD104             BNE.N    ??HAL_SPI_TransmitReceive_18
    853                  {
    854                    SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
   \   00000186   0x6820             LDR      R0,[R4, #+0]
   \   00000188   0x6801             LDR      R1,[R0, #+0]
   \   0000018A   0xF441 0x5180      ORR      R1,R1,#0x1000
   \   0000018E   0x6001             STR      R1,[R0, #+0]
    855                  }
    856                }
    857          
    858                /* Wait until RXNE flag is reset */
    859                if((hspi->RxXferCount > 0) && ((hspi->Instance->SR & SPI_FLAG_RXNE) == SPI_FLAG_RXNE))
   \                     ??HAL_SPI_TransmitReceive_18: (+1)
   \   00000190   0x8868             LDRH     R0,[R5, #+2]
   \   00000192   0x2800             CMP      R0,#+0
   \   00000194   0xD01F             BEQ.N    ??HAL_SPI_TransmitReceive_21
   \   00000196   0x6821             LDR      R1,[R4, #+0]
   \   00000198   0x688A             LDR      R2,[R1, #+8]
   \   0000019A   0x07D2             LSLS     R2,R2,#+31
   \   0000019C   0xD51B             BPL.N    ??HAL_SPI_TransmitReceive_21
    860                {
    861                  if(hspi->RxXferCount > 1)
   \   0000019E   0x6C22             LDR      R2,[R4, #+64]
   \   000001A0   0x2802             CMP      R0,#+2
   \   000001A2   0xDB10             BLT.N    ??HAL_SPI_TransmitReceive_22
    862                  {
    863                    *((uint16_t*)hspi->pRxBuffPtr) = hspi->Instance->DR;
   \   000001A4   0x68C8             LDR      R0,[R1, #+12]
   \   000001A6   0x8010             STRH     R0,[R2, #+0]
    864                    hspi->pRxBuffPtr += sizeof(uint16_t);
   \   000001A8   0x6C20             LDR      R0,[R4, #+64]
   \   000001AA   0x1C80             ADDS     R0,R0,#+2
   \   000001AC   0x6420             STR      R0,[R4, #+64]
    865                    hspi->RxXferCount -= 2;
   \   000001AE   0x8868             LDRH     R0,[R5, #+2]
   \   000001B0   0x1E80             SUBS     R0,R0,#+2
   \   000001B2   0x8068             STRH     R0,[R5, #+2]
    866                    if(hspi->RxXferCount <= 1)
   \   000001B4   0xB280             UXTH     R0,R0
   \   000001B6   0x2802             CMP      R0,#+2
   \   000001B8   0xDA0D             BGE.N    ??HAL_SPI_TransmitReceive_21
    867                    {
    868                      /* set fiforxthreshold before to switch on 8 bit data size */
    869                      SET_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
   \   000001BA   0x6820             LDR      R0,[R4, #+0]
   \   000001BC   0x6841             LDR      R1,[R0, #+4]
   \   000001BE   0xF441 0x5180      ORR      R1,R1,#0x1000
   \   000001C2   0x6041             STR      R1,[R0, #+4]
   \   000001C4   0xE007             B.N      ??HAL_SPI_TransmitReceive_21
    870                    }
    871                  }
    872                  else
    873                  {
    874                    (*hspi->pRxBuffPtr++) =  *(__IO uint8_t *)&hspi->Instance->DR;
   \                     ??HAL_SPI_TransmitReceive_22: (+1)
   \   000001C6   0x1C50             ADDS     R0,R2,#+1
   \   000001C8   0x6420             STR      R0,[R4, #+64]
   \   000001CA   0x6820             LDR      R0,[R4, #+0]
   \   000001CC   0x7B00             LDRB     R0,[R0, #+12]
   \   000001CE   0x7010             STRB     R0,[R2, #+0]
    875                    hspi->RxXferCount--;
   \   000001D0   0x8868             LDRH     R0,[R5, #+2]
   \   000001D2   0x1E40             SUBS     R0,R0,#+1
   \   000001D4   0x8068             STRH     R0,[R5, #+2]
    876                  }
    877                }
    878                if(Timeout != HAL_MAX_DELAY)
   \                     ??HAL_SPI_TransmitReceive_21: (+1)
   \   000001D6   0xF117 0x0F01      CMN      R7,#+1
   \   000001DA   0xD0AD             BEQ.N    ??HAL_SPI_TransmitReceive_10
    879                {
    880                  if((Timeout == 0) || ((HAL_GetTick()-tickstart) > Timeout))
   \   000001DC   0x2F00             CMP      R7,#+0
   \   000001DE   0xD004             BEQ.N    ??HAL_SPI_TransmitReceive_16
   \   000001E0   0x.... 0x....      BL       HAL_GetTick
   \   000001E4   0x1B80             SUBS     R0,R0,R6
   \   000001E6   0x4287             CMP      R7,R0
   \   000001E8   0xD2A6             BCS.N    ??HAL_SPI_TransmitReceive_10
    881                  {
    882                    hspi->State = HAL_SPI_STATE_READY;
   \                     ??HAL_SPI_TransmitReceive_16: (+1)
   \   000001EA   0x2001             MOVS     R0,#+1
   \   000001EC   0x7668             STRB     R0,[R5, #+25]
    883                    __HAL_UNLOCK(hspi);
   \   000001EE   0x2000             MOVS     R0,#+0
   \   000001F0   0x7628             STRB     R0,[R5, #+24]
    884                    return HAL_TIMEOUT;
   \   000001F2   0x2003             MOVS     R0,#+3
   \   000001F4   0xE055             B.N      ??HAL_SPI_TransmitReceive_3
    885                  }
    886                }
    887              }
    888            }
    889          
    890            /* Read CRC from DR to close CRC calculation process */
    891            if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   \                     ??HAL_SPI_TransmitReceive_13: (+1)
   \   000001F6   0x6AA0             LDR      R0,[R4, #+40]
   \   000001F8   0xF5B0 0x5F00      CMP      R0,#+8192
   \   000001FC   0xD130             BNE.N    ??HAL_SPI_TransmitReceive_23
    892            {
    893              /* Wait until TXE flag */
    894              if(SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_RXNE, SPI_FLAG_RXNE, Timeout) != HAL_OK)
   \   000001FE   0x463B             MOV      R3,R7
   \   00000200   0x2201             MOVS     R2,#+1
   \   00000202   0x4611             MOV      R1,R2
   \   00000204   0x4620             MOV      R0,R4
   \   00000206   0x.... 0x....      BL       SPI_WaitFlagStateUntilTimeout
   \   0000020A   0x2800             CMP      R0,#+0
   \   0000020C   0xD003             BEQ.N    ??HAL_SPI_TransmitReceive_24
    895              {
    896                /* Error on the CRC reception */
    897                hspi->ErrorCode|= HAL_SPI_ERROR_CRC;
   \   0000020E   0x69E8             LDR      R0,[R5, #+28]
   \   00000210   0xF040 0x0002      ORR      R0,R0,#0x2
   \   00000214   0x61E8             STR      R0,[R5, #+28]
    898              }
    899          
    900              if(hspi->Init.DataSize == SPI_DATASIZE_16BIT)
   \                     ??HAL_SPI_TransmitReceive_24: (+1)
   \   00000216   0x6820             LDR      R0,[R4, #+0]
   \   00000218   0x68E1             LDR      R1,[R4, #+12]
   \   0000021A   0xF5B1 0x6F70      CMP      R1,#+3840
   \   0000021E   0xD105             BNE.N    ??HAL_SPI_TransmitReceive_25
    901              {
    902                tmpreg = hspi->Instance->DR;
   \   00000220   0x68C0             LDR      R0,[R0, #+12]
   \   00000222   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    903                UNUSED(tmpreg); /* To avoid GCC warning */
   \   00000226   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   0000022A   0xE019             B.N      ??HAL_SPI_TransmitReceive_23
    904              }
    905              else
    906              {
    907                tmpreg = *(__IO uint8_t *)&hspi->Instance->DR;
   \                     ??HAL_SPI_TransmitReceive_25: (+1)
   \   0000022C   0x7B00             LDRB     R0,[R0, #+12]
   \   0000022E   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    908                UNUSED(tmpreg); /* To avoid GCC warning */
   \   00000232   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
    909          
    910                if(hspi->Init.CRCLength == SPI_CRC_LENGTH_16BIT)
   \   00000236   0x6B20             LDR      R0,[R4, #+48]
   \   00000238   0x2802             CMP      R0,#+2
   \   0000023A   0xD111             BNE.N    ??HAL_SPI_TransmitReceive_23
    911                {
    912                  if(SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_RXNE, SPI_FLAG_RXNE, Timeout) != HAL_OK)
   \   0000023C   0x463B             MOV      R3,R7
   \   0000023E   0x2201             MOVS     R2,#+1
   \   00000240   0x4611             MOV      R1,R2
   \   00000242   0x4620             MOV      R0,R4
   \   00000244   0x.... 0x....      BL       SPI_WaitFlagStateUntilTimeout
   \   00000248   0x2800             CMP      R0,#+0
   \   0000024A   0xD003             BEQ.N    ??HAL_SPI_TransmitReceive_26
    913                  {
    914                    /* Error on the CRC reception */
    915                    hspi->ErrorCode|= HAL_SPI_ERROR_CRC;
   \   0000024C   0x69E8             LDR      R0,[R5, #+28]
   \   0000024E   0xF040 0x0002      ORR      R0,R0,#0x2
   \   00000252   0x61E8             STR      R0,[R5, #+28]
    916                  }
    917                  tmpreg = *(__IO uint8_t *)&hspi->Instance->DR;
   \                     ??HAL_SPI_TransmitReceive_26: (+1)
   \   00000254   0x6820             LDR      R0,[R4, #+0]
   \   00000256   0x7B00             LDRB     R0,[R0, #+12]
   \   00000258   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    918                  UNUSED(tmpreg); /* To avoid GCC warning */
   \   0000025C   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
    919                }
    920              }
    921            }
    922          
    923            /* Check the end of the transaction */
    924            if(SPI_EndRxTxTransaction(hspi,Timeout) != HAL_OK)
   \                     ??HAL_SPI_TransmitReceive_23: (+1)
   \   00000260   0x4639             MOV      R1,R7
   \   00000262   0x4620             MOV      R0,R4
   \   00000264   0x.... 0x....      BL       SPI_EndRxTxTransaction
   \   00000268   0x2800             CMP      R0,#+0
   \   0000026A   0xD001             BEQ.N    ??HAL_SPI_TransmitReceive_27
    925            {
    926              return HAL_TIMEOUT;
   \   0000026C   0x2003             MOVS     R0,#+3
   \   0000026E   0xE018             B.N      ??HAL_SPI_TransmitReceive_3
    927            }
    928          
    929            hspi->State = HAL_SPI_STATE_READY;
   \                     ??HAL_SPI_TransmitReceive_27: (+1)
   \   00000270   0x2001             MOVS     R0,#+1
   \   00000272   0x7668             STRB     R0,[R5, #+25]
    930            
    931            /* Check if CRC error occurred */
    932            if(__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_CRCERR) != RESET)
   \   00000274   0x6820             LDR      R0,[R4, #+0]
   \   00000276   0x6880             LDR      R0,[R0, #+8]
   \   00000278   0x06C0             LSLS     R0,R0,#+27
   \   0000027A   0xD50B             BPL.N    ??HAL_SPI_TransmitReceive_28
    933            {
    934              hspi->ErrorCode|= HAL_SPI_ERROR_CRC;
   \   0000027C   0x69E8             LDR      R0,[R5, #+28]
   \   0000027E   0xF040 0x0002      ORR      R0,R0,#0x2
   \   00000282   0x61E8             STR      R0,[R5, #+28]
    935              /* Clear CRC Flag */
    936              __HAL_SPI_CLEAR_CRCERRFLAG(hspi);
   \   00000284   0xF64F 0x70EF      MOVW     R0,#+65519
   \   00000288   0x6821             LDR      R1,[R4, #+0]
   \   0000028A   0x6088             STR      R0,[R1, #+8]
    937              
    938              /* Process Unlocked */
    939              __HAL_UNLOCK(hspi);
   \   0000028C   0x2000             MOVS     R0,#+0
   \   0000028E   0x7628             STRB     R0,[R5, #+24]
    940              
    941              return HAL_ERROR;
   \   00000290   0x2001             MOVS     R0,#+1
   \   00000292   0xE006             B.N      ??HAL_SPI_TransmitReceive_3
    942            }
    943            
    944            /* Process Unlocked */
    945            __HAL_UNLOCK(hspi);
   \                     ??HAL_SPI_TransmitReceive_28: (+1)
   \   00000294   0x2000             MOVS     R0,#+0
   \   00000296   0x7628             STRB     R0,[R5, #+24]
    946            
    947            if(hspi->ErrorCode != HAL_SPI_ERROR_NONE)
   \   00000298   0x69E8             LDR      R0,[R5, #+28]
   \   0000029A   0x1E40             SUBS     R0,R0,#+1
   \   0000029C   0x4180             SBCS     R0,R0,R0
   \   0000029E   0x43C0             MVNS     R0,R0
   \   000002A0   0x0FC0             LSRS     R0,R0,#+31
    948            {   
    949              return HAL_ERROR;
    950            }
    951            else
    952            {
    953              return HAL_OK;
   \                     ??HAL_SPI_TransmitReceive_3: (+1)
   \   000002A2   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    954            }
    955          }
    956          
    957          /**
    958            * @brief  Transmit an amount of data in no-blocking mode with Interrupt
    959            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
    960            *               the configuration information for SPI module.
    961            * @param  pData: pointer to data buffer
    962            * @param  Size: amount of data to be sent
    963            * @retval HAL status
    964            */

   \                                 In section .text, align 2, keep-with-next
    965          HAL_StatusTypeDef HAL_SPI_Transmit_IT(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size)
    966          {
   \                     HAL_SPI_Transmit_IT: (+1)
   \   00000000   0xB410             PUSH     {R4}
    967            assert_param(IS_SPI_DIRECTION_2LINES_OR_1LINE(hspi->Init.Direction));
    968            
    969            if(hspi->State == HAL_SPI_STATE_READY)
   \   00000002   0xF100 0x0344      ADD      R3,R0,#+68
   \   00000006   0x7E5C             LDRB     R4,[R3, #+25]
   \   00000008   0x2C01             CMP      R4,#+1
   \   0000000A   0xD14B             BNE.N    ??HAL_SPI_Transmit_IT_0
    970            {
    971              if((pData == NULL) || (Size == 0)) 
   \   0000000C   0x2900             CMP      R1,#+0
   \   0000000E   0xD001             BEQ.N    ??HAL_SPI_Transmit_IT_1
   \   00000010   0x2A00             CMP      R2,#+0
   \   00000012   0xD101             BNE.N    ??HAL_SPI_Transmit_IT_2
    972              {
    973                return  HAL_ERROR;                                    
   \                     ??HAL_SPI_Transmit_IT_1: (+1)
   \   00000014   0x2001             MOVS     R0,#+1
   \   00000016   0xE046             B.N      ??HAL_SPI_Transmit_IT_3
    974              }
    975              
    976              /* Process Locked */
    977              __HAL_LOCK(hspi);
   \                     ??HAL_SPI_Transmit_IT_2: (+1)
   \   00000018   0x7E1C             LDRB     R4,[R3, #+24]
   \   0000001A   0x2C01             CMP      R4,#+1
   \   0000001C   0xD042             BEQ.N    ??HAL_SPI_Transmit_IT_0
   \   0000001E   0x2401             MOVS     R4,#+1
   \   00000020   0x761C             STRB     R4,[R3, #+24]
    978              
    979              hspi->State       = HAL_SPI_STATE_BUSY_TX;
   \   00000022   0x2403             MOVS     R4,#+3
   \   00000024   0x765C             STRB     R4,[R3, #+25]
    980              hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
   \   00000026   0x2400             MOVS     R4,#+0
   \   00000028   0x61DC             STR      R4,[R3, #+28]
    981              hspi->pTxBuffPtr  = pData;
   \   0000002A   0x6381             STR      R1,[R0, #+56]
    982              hspi->TxXferSize  = Size;
   \   0000002C   0x8782             STRH     R2,[R0, #+60]
    983              hspi->TxXferCount = Size;
   \   0000002E   0x87C2             STRH     R2,[R0, #+62]
    984              hspi->pRxBuffPtr  = NULL;
   \   00000030   0x4621             MOV      R1,R4
   \   00000032   0x6401             STR      R1,[R0, #+64]
    985              hspi->RxXferSize  = 0;
   \   00000034   0x8019             STRH     R1,[R3, #+0]
    986              hspi->RxXferCount = 0;
   \   00000036   0x8059             STRH     R1,[R3, #+2]
    987          
    988              /* Set the function for IT treatement */
    989              if(hspi->Init.DataSize > SPI_DATASIZE_8BIT )
   \   00000038   0x68C1             LDR      R1,[R0, #+12]
   \   0000003A   0xF5B1 0x6FE0      CMP      R1,#+1792
   \   0000003E   0x4621             MOV      R1,R4
   \   00000040   0x6099             STR      R1,[R3, #+8]
   \   00000042   0xD903             BLS.N    ??HAL_SPI_Transmit_IT_4
    990              {
    991                hspi->RxISR = NULL;
    992                hspi->TxISR = SPI_TxISR_16BIT;
   \   00000044   0x.... 0x....      ADR.W    R1,SPI_TxISR_16BIT
   \   00000048   0x60D9             STR      R1,[R3, #+12]
   \   0000004A   0xE002             B.N      ??HAL_SPI_Transmit_IT_5
    993              }
    994              else
    995              {
    996                hspi->RxISR = NULL;
    997                hspi->TxISR = SPI_TxISR_8BIT;
   \                     ??HAL_SPI_Transmit_IT_4: (+1)
   \   0000004C   0x.... 0x....      ADR.W    R1,SPI_TxISR_8BIT
   \   00000050   0x60D9             STR      R1,[R3, #+12]
    998              }
    999              
   1000              /* Configure communication direction : 1Line */
   1001              if(hspi->Init.Direction == SPI_DIRECTION_1LINE)
   \                     ??HAL_SPI_Transmit_IT_5: (+1)
   \   00000052   0x6881             LDR      R1,[R0, #+8]
   \   00000054   0xF5B1 0x4F00      CMP      R1,#+32768
   \   00000058   0xD104             BNE.N    ??HAL_SPI_Transmit_IT_6
   1002              {
   1003                SPI_1LINE_TX(hspi);
   \   0000005A   0x6801             LDR      R1,[R0, #+0]
   \   0000005C   0x680A             LDR      R2,[R1, #+0]
   \   0000005E   0xF442 0x4280      ORR      R2,R2,#0x4000
   \   00000062   0x600A             STR      R2,[R1, #+0]
   1004              }
   1005              
   1006              /* Reset CRC Calculation */
   1007              if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   \                     ??HAL_SPI_Transmit_IT_6: (+1)
   \   00000064   0x6A81             LDR      R1,[R0, #+40]
   \   00000066   0xF5B1 0x5F00      CMP      R1,#+8192
   \   0000006A   0xD10A             BNE.N    ??HAL_SPI_Transmit_IT_7
   1008              {
   1009                SPI_RESET_CRC(hspi);    
   \   0000006C   0x6801             LDR      R1,[R0, #+0]
   \   0000006E   0x680A             LDR      R2,[R1, #+0]
   \   00000070   0xF64D 0x74FF      MOVW     R4,#+57343
   \   00000074   0x4022             ANDS     R2,R4,R2
   \   00000076   0x600A             STR      R2,[R1, #+0]
   \   00000078   0x6801             LDR      R1,[R0, #+0]
   \   0000007A   0x680A             LDR      R2,[R1, #+0]
   \   0000007C   0xF442 0x5200      ORR      R2,R2,#0x2000
   \   00000080   0x600A             STR      R2,[R1, #+0]
   1010              }
   1011              
   1012              /* Enable TXE and ERR interrupt */
   1013              __HAL_SPI_ENABLE_IT(hspi,(SPI_IT_TXE));
   \                     ??HAL_SPI_Transmit_IT_7: (+1)
   \   00000082   0x6801             LDR      R1,[R0, #+0]
   \   00000084   0x684A             LDR      R2,[R1, #+4]
   \   00000086   0xF042 0x0280      ORR      R2,R2,#0x80
   \   0000008A   0x604A             STR      R2,[R1, #+4]
   1014          
   1015              /* Process Unlocked */
   1016              __HAL_UNLOCK(hspi);
   \   0000008C   0x2100             MOVS     R1,#+0
   \   0000008E   0x7619             STRB     R1,[R3, #+24]
   1017          
   1018              /* Note : The SPI must be enabled after unlocking current process 
   1019                        to avoid the risk of SPI interrupt handle execution before current
   1020                        process unlock */
   1021                  
   1022              /* Check if the SPI is already enabled */ 
   1023              if((hspi->Instance->CR1 &SPI_CR1_SPE) != SPI_CR1_SPE)
   \   00000090   0x6800             LDR      R0,[R0, #+0]
   \   00000092   0x6801             LDR      R1,[R0, #+0]
   \   00000094   0x0649             LSLS     R1,R1,#+25
   \   00000096   0xD403             BMI.N    ??HAL_SPI_Transmit_IT_8
   1024              {
   1025                /* Enable SPI peripheral */    
   1026                __HAL_SPI_ENABLE(hspi);
   \   00000098   0x6801             LDR      R1,[R0, #+0]
   \   0000009A   0xF041 0x0140      ORR      R1,R1,#0x40
   \   0000009E   0x6001             STR      R1,[R0, #+0]
   1027              }
   1028                  
   1029              return HAL_OK;
   \                     ??HAL_SPI_Transmit_IT_8: (+1)
   \   000000A0   0x2000             MOVS     R0,#+0
   \   000000A2   0xE000             B.N      ??HAL_SPI_Transmit_IT_3
   1030            }
   1031            else
   1032            {
   1033              return HAL_BUSY;
   \                     ??HAL_SPI_Transmit_IT_0: (+1)
   \   000000A4   0x2002             MOVS     R0,#+2
   \                     ??HAL_SPI_Transmit_IT_3: (+1)
   \   000000A6   0xBC10             POP      {R4}
   \   000000A8   0x4770             BX       LR               ;; return
   1034            }
   1035          }
   1036          
   1037          /**
   1038            * @brief  Receive an amount of data in no-blocking mode with Interrupt
   1039            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   1040            *               the configuration information for SPI module.
   1041            * @param  pData: pointer to data buffer
   1042            * @param  Size: amount of data to be sent
   1043            * @retval HAL status
   1044            */

   \                                 In section .text, align 2, keep-with-next
   1045          HAL_StatusTypeDef HAL_SPI_Receive_IT(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size)
   1046          {
   \                     HAL_SPI_Receive_IT: (+1)
   \   00000000   0xB418             PUSH     {R3,R4}
   1047            if(hspi->State == HAL_SPI_STATE_READY)
   \   00000002   0xF100 0x0344      ADD      R3,R0,#+68
   \   00000006   0x7E5C             LDRB     R4,[R3, #+25]
   \   00000008   0x2C01             CMP      R4,#+1
   \   0000000A   0xD174             BNE.N    ??HAL_SPI_Receive_IT_0
   1048            {
   1049              if((pData == NULL) || (Size == 0))
   \   0000000C   0x2900             CMP      R1,#+0
   \   0000000E   0xD001             BEQ.N    ??HAL_SPI_Receive_IT_1
   \   00000010   0x2A00             CMP      R2,#+0
   \   00000012   0xD101             BNE.N    ??HAL_SPI_Receive_IT_2
   1050              { 
   1051                return  HAL_ERROR;                      
   \                     ??HAL_SPI_Receive_IT_1: (+1)
   \   00000014   0x2001             MOVS     R0,#+1
   \   00000016   0xE06F             B.N      ??HAL_SPI_Receive_IT_3
   1052              }
   1053          
   1054              /* Process Locked */
   1055              __HAL_LOCK(hspi);
   \                     ??HAL_SPI_Receive_IT_2: (+1)
   \   00000018   0x7E1C             LDRB     R4,[R3, #+24]
   \   0000001A   0x2C01             CMP      R4,#+1
   \   0000001C   0xD06B             BEQ.N    ??HAL_SPI_Receive_IT_0
   \   0000001E   0x2401             MOVS     R4,#+1
   \   00000020   0x761C             STRB     R4,[R3, #+24]
   1056              
   1057              /* Configure communication */
   1058              hspi->State       = HAL_SPI_STATE_BUSY_RX;
   \   00000022   0x2404             MOVS     R4,#+4
   \   00000024   0x765C             STRB     R4,[R3, #+25]
   1059              hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
   \   00000026   0x2400             MOVS     R4,#+0
   \   00000028   0x61DC             STR      R4,[R3, #+28]
   1060              hspi->pRxBuffPtr  = pData;
   \   0000002A   0x6401             STR      R1,[R0, #+64]
   1061              hspi->RxXferSize  = Size;
   \   0000002C   0x801A             STRH     R2,[R3, #+0]
   1062              hspi->RxXferCount = Size;
   \   0000002E   0x805A             STRH     R2,[R3, #+2]
   1063              hspi->pTxBuffPtr  = NULL;
   \   00000030   0x6384             STR      R4,[R0, #+56]
   1064              hspi->TxXferSize  = 0;
   \   00000032   0x8784             STRH     R4,[R0, #+60]
   1065              hspi->TxXferCount = 0;
   \   00000034   0x87C4             STRH     R4,[R0, #+62]
   1066          
   1067              if((hspi->Init.Mode == SPI_MODE_MASTER) && (hspi->Init.Direction == SPI_DIRECTION_2LINES))
   \   00000036   0x6844             LDR      R4,[R0, #+4]
   \   00000038   0xF5B4 0x7F82      CMP      R4,#+260
   \   0000003C   0xD109             BNE.N    ??HAL_SPI_Receive_IT_4
   \   0000003E   0x6884             LDR      R4,[R0, #+8]
   \   00000040   0x2C00             CMP      R4,#+0
   \   00000042   0xD106             BNE.N    ??HAL_SPI_Receive_IT_4
   1068              {
   1069                /* Process Unlocked */
   1070                __HAL_UNLOCK(hspi);
   \   00000044   0x2400             MOVS     R4,#+0
   \   00000046   0x761C             STRB     R4,[R3, #+24]
   1071                /* the receive process is not supported in 2Lines direction master mode */
   1072                /* in this we call the transmitReceive process          */
   1073                return HAL_SPI_TransmitReceive_IT(hspi,pData,pData,Size);
   \   00000048   0x4613             MOV      R3,R2
   \   0000004A   0x460A             MOV      R2,R1
   \   0000004C   0xB001             ADD      SP,SP,#+4
   \   0000004E   0xBC10             POP      {R4}
   \   00000050   0x....             B.N      HAL_SPI_TransmitReceive_IT
   1074              }
   1075                  
   1076              if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   \                     ??HAL_SPI_Receive_IT_4: (+1)
   \   00000052   0xF240 0x7101      MOVW     R1,#+1793
   \   00000056   0x6A82             LDR      R2,[R0, #+40]
   \   00000058   0xF5B2 0x5F00      CMP      R2,#+8192
   \   0000005C   0xD10A             BNE.N    ??HAL_SPI_Receive_IT_5
   1077              {
   1078                hspi->CRCSize = 1;
   \   0000005E   0x2201             MOVS     R2,#+1
   \   00000060   0x605A             STR      R2,[R3, #+4]
   1079                if((hspi->Init.DataSize <= SPI_DATASIZE_8BIT) && (hspi->Init.CRCLength == SPI_CRC_LENGTH_16BIT))
   \   00000062   0x68C2             LDR      R2,[R0, #+12]
   \   00000064   0x428A             CMP      R2,R1
   \   00000066   0xD207             BCS.N    ??HAL_SPI_Receive_IT_6
   \   00000068   0x6B02             LDR      R2,[R0, #+48]
   \   0000006A   0x2A02             CMP      R2,#+2
   \   0000006C   0xD104             BNE.N    ??HAL_SPI_Receive_IT_6
   1080                {
   1081                  hspi->CRCSize = 2;
   \   0000006E   0x2202             MOVS     R2,#+2
   \   00000070   0x605A             STR      R2,[R3, #+4]
   \   00000072   0xE001             B.N      ??HAL_SPI_Receive_IT_6
   1082                }
   1083              }
   1084              else
   1085              {
   1086                hspi->CRCSize = 0;
   \                     ??HAL_SPI_Receive_IT_5: (+1)
   \   00000074   0x2200             MOVS     R2,#+0
   \   00000076   0x605A             STR      R2,[R3, #+4]
   1087              }
   1088                  
   1089              /* check the data size to adapt Rx threshold and the set the function for IT treatment */
   1090              if(hspi->Init.DataSize > SPI_DATASIZE_8BIT )
   \                     ??HAL_SPI_Receive_IT_6: (+1)
   \   00000078   0x6802             LDR      R2,[R0, #+0]
   \   0000007A   0x68C4             LDR      R4,[R0, #+12]
   \   0000007C   0x428C             CMP      R4,R1
   \   0000007E   0x6851             LDR      R1,[R2, #+4]
   \   00000080   0xD308             BCC.N    ??HAL_SPI_Receive_IT_7
   1091              {
   1092                /* set fiforxthreshold according the reception data length: 16 bit */
   1093                CLEAR_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
   \   00000082   0xF421 0x5180      BIC      R1,R1,#0x1000
   \   00000086   0x6051             STR      R1,[R2, #+4]
   1094                hspi->RxISR = SPI_RxISR_16BIT;
   \   00000088   0x.... 0x....      ADR.W    R1,SPI_RxISR_16BIT
   \   0000008C   0x6099             STR      R1,[R3, #+8]
   1095                hspi->TxISR = NULL;
   \   0000008E   0x2100             MOVS     R1,#+0
   \   00000090   0x60D9             STR      R1,[R3, #+12]
   \   00000092   0xE007             B.N      ??HAL_SPI_Receive_IT_8
   1096              }
   1097              else
   1098              {
   1099                /* set fiforxthreshold according the reception data length: 8 bit */
   1100                SET_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
   \                     ??HAL_SPI_Receive_IT_7: (+1)
   \   00000094   0xF441 0x5180      ORR      R1,R1,#0x1000
   \   00000098   0x6051             STR      R1,[R2, #+4]
   1101                hspi->RxISR = SPI_RxISR_8BIT;
   \   0000009A   0x.... 0x....      ADR.W    R1,SPI_RxISR_8BIT
   \   0000009E   0x6099             STR      R1,[R3, #+8]
   1102                hspi->TxISR = NULL;
   \   000000A0   0x2100             MOVS     R1,#+0
   \   000000A2   0x60D9             STR      R1,[R3, #+12]
   1103              }
   1104              
   1105              /* Configure communication direction : 1Line */
   1106              if(hspi->Init.Direction == SPI_DIRECTION_1LINE)
   \                     ??HAL_SPI_Receive_IT_8: (+1)
   \   000000A4   0x6881             LDR      R1,[R0, #+8]
   \   000000A6   0xF5B1 0x4F00      CMP      R1,#+32768
   \   000000AA   0xD104             BNE.N    ??HAL_SPI_Receive_IT_9
   1107              {
   1108                SPI_1LINE_RX(hspi);
   \   000000AC   0x6801             LDR      R1,[R0, #+0]
   \   000000AE   0x680A             LDR      R2,[R1, #+0]
   \   000000B0   0xF422 0x4280      BIC      R2,R2,#0x4000
   \   000000B4   0x600A             STR      R2,[R1, #+0]
   1109              }
   1110              
   1111              /* Reset CRC Calculation */
   1112              if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   \                     ??HAL_SPI_Receive_IT_9: (+1)
   \   000000B6   0x6A81             LDR      R1,[R0, #+40]
   \   000000B8   0xF5B1 0x5F00      CMP      R1,#+8192
   \   000000BC   0xD10A             BNE.N    ??HAL_SPI_Receive_IT_10
   1113              {
   1114                SPI_RESET_CRC(hspi);
   \   000000BE   0x6801             LDR      R1,[R0, #+0]
   \   000000C0   0x680A             LDR      R2,[R1, #+0]
   \   000000C2   0xF64D 0x74FF      MOVW     R4,#+57343
   \   000000C6   0x4022             ANDS     R2,R4,R2
   \   000000C8   0x600A             STR      R2,[R1, #+0]
   \   000000CA   0x6801             LDR      R1,[R0, #+0]
   \   000000CC   0x680A             LDR      R2,[R1, #+0]
   \   000000CE   0xF442 0x5200      ORR      R2,R2,#0x2000
   \   000000D2   0x600A             STR      R2,[R1, #+0]
   1115              }
   1116              
   1117              /* Enable TXE and ERR interrupt */
   1118              __HAL_SPI_ENABLE_IT(hspi, (SPI_IT_RXNE | SPI_IT_ERR));
   \                     ??HAL_SPI_Receive_IT_10: (+1)
   \   000000D4   0x6801             LDR      R1,[R0, #+0]
   \   000000D6   0x684A             LDR      R2,[R1, #+4]
   \   000000D8   0xF042 0x0260      ORR      R2,R2,#0x60
   \   000000DC   0x604A             STR      R2,[R1, #+4]
   1119              
   1120              /* Process Unlocked */
   1121              __HAL_UNLOCK(hspi);
   \   000000DE   0x2100             MOVS     R1,#+0
   \   000000E0   0x7619             STRB     R1,[R3, #+24]
   1122              
   1123              /* Note : The SPI must be enabled after unlocking current process 
   1124              to avoid the risk of SPI interrupt handle execution before current
   1125              process unlock */
   1126              
   1127              /* Check if the SPI is already enabled */ 
   1128              if((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
   \   000000E2   0x6800             LDR      R0,[R0, #+0]
   \   000000E4   0x6801             LDR      R1,[R0, #+0]
   \   000000E6   0x0649             LSLS     R1,R1,#+25
   \   000000E8   0xD403             BMI.N    ??HAL_SPI_Receive_IT_11
   1129              {
   1130                /* Enable SPI peripheral */    
   1131                __HAL_SPI_ENABLE(hspi);
   \   000000EA   0x6801             LDR      R1,[R0, #+0]
   \   000000EC   0xF041 0x0140      ORR      R1,R1,#0x40
   \   000000F0   0x6001             STR      R1,[R0, #+0]
   1132              }
   1133              
   1134              return HAL_OK;
   \                     ??HAL_SPI_Receive_IT_11: (+1)
   \   000000F2   0x2000             MOVS     R0,#+0
   \   000000F4   0xE000             B.N      ??HAL_SPI_Receive_IT_3
   1135            }
   1136            else
   1137            {
   1138              return HAL_BUSY; 
   \                     ??HAL_SPI_Receive_IT_0: (+1)
   \   000000F6   0x2002             MOVS     R0,#+2
   \                     ??HAL_SPI_Receive_IT_3: (+1)
   \   000000F8   0xBC12             POP      {R1,R4}
   \   000000FA   0x4770             BX       LR               ;; return
   1139            }
   1140          }
   1141          
   1142          /**
   1143            * @brief  Transmit and Receive an amount of data in no-blocking mode with Interrupt
   1144            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   1145            *               the configuration information for SPI module.
   1146            * @param  pTxData: pointer to transmission data buffer
   1147            * @param  pRxData: pointer to reception data buffer
   1148            * @param  Size: amount of data to be sent and received
   1149            * @retval HAL status
   1150            */

   \                                 In section .text, align 2, keep-with-next
   1151          HAL_StatusTypeDef HAL_SPI_TransmitReceive_IT(SPI_HandleTypeDef *hspi, uint8_t *pTxData, uint8_t *pRxData, uint16_t Size)
   1152          {
   \                     HAL_SPI_TransmitReceive_IT: (+1)
   \   00000000   0xB470             PUSH     {R4-R6}
   1153            assert_param(IS_SPI_DIRECTION_2LINES(hspi->Init.Direction));
   1154            
   1155            if((hspi->State == HAL_SPI_STATE_READY) || \
   1156               ((hspi->Init.Mode == SPI_MODE_MASTER) && (hspi->Init.Direction == SPI_DIRECTION_2LINES) && (hspi->State == HAL_SPI_STATE_BUSY_RX)))
   \   00000002   0xF100 0x0444      ADD      R4,R0,#+68
   \   00000006   0x7E65             LDRB     R5,[R4, #+25]
   \   00000008   0x2D01             CMP      R5,#+1
   \   0000000A   0xD008             BEQ.N    ??HAL_SPI_TransmitReceive_IT_0
   \   0000000C   0x6846             LDR      R6,[R0, #+4]
   \   0000000E   0xF5B6 0x7F82      CMP      R6,#+260
   \   00000012   0xD171             BNE.N    ??HAL_SPI_TransmitReceive_IT_1
   \   00000014   0x6886             LDR      R6,[R0, #+8]
   \   00000016   0x2E00             CMP      R6,#+0
   \   00000018   0xD16E             BNE.N    ??HAL_SPI_TransmitReceive_IT_1
   \   0000001A   0x2D04             CMP      R5,#+4
   \   0000001C   0xD16C             BNE.N    ??HAL_SPI_TransmitReceive_IT_1
   1157            {
   1158              if((pTxData == NULL ) || (pRxData == NULL ) || (Size == 0)) 
   \                     ??HAL_SPI_TransmitReceive_IT_0: (+1)
   \   0000001E   0x2900             CMP      R1,#+0
   \   00000020   0xD003             BEQ.N    ??HAL_SPI_TransmitReceive_IT_2
   \   00000022   0x2A00             CMP      R2,#+0
   \   00000024   0xD001             BEQ.N    ??HAL_SPI_TransmitReceive_IT_2
   \   00000026   0x2B00             CMP      R3,#+0
   \   00000028   0xD101             BNE.N    ??HAL_SPI_TransmitReceive_IT_3
   1159              {
   1160                return  HAL_ERROR;                                    
   \                     ??HAL_SPI_TransmitReceive_IT_2: (+1)
   \   0000002A   0x2001             MOVS     R0,#+1
   \   0000002C   0xE065             B.N      ??HAL_SPI_TransmitReceive_IT_4
   1161              }
   1162              
   1163              /* Process locked */
   1164              __HAL_LOCK(hspi);
   \                     ??HAL_SPI_TransmitReceive_IT_3: (+1)
   \   0000002E   0x7E25             LDRB     R5,[R4, #+24]
   \   00000030   0x2D01             CMP      R5,#+1
   \   00000032   0xD061             BEQ.N    ??HAL_SPI_TransmitReceive_IT_1
   \   00000034   0x2501             MOVS     R5,#+1
   \   00000036   0x7625             STRB     R5,[R4, #+24]
   1165              
   1166              hspi->CRCSize = 0;
   \   00000038   0x2500             MOVS     R5,#+0
   \   0000003A   0x6065             STR      R5,[R4, #+4]
   1167              if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   \   0000003C   0xF240 0x7501      MOVW     R5,#+1793
   \   00000040   0x6A86             LDR      R6,[R0, #+40]
   \   00000042   0xF5B6 0x5F00      CMP      R6,#+8192
   \   00000046   0xD109             BNE.N    ??HAL_SPI_TransmitReceive_IT_5
   1168              {
   1169                hspi->CRCSize = 1;
   \   00000048   0x2601             MOVS     R6,#+1
   \   0000004A   0x6066             STR      R6,[R4, #+4]
   1170                if((hspi->Init.DataSize <= SPI_DATASIZE_8BIT) && (hspi->Init.CRCLength == SPI_CRC_LENGTH_16BIT))
   \   0000004C   0x68C6             LDR      R6,[R0, #+12]
   \   0000004E   0x42AE             CMP      R6,R5
   \   00000050   0xD204             BCS.N    ??HAL_SPI_TransmitReceive_IT_5
   \   00000052   0x6B06             LDR      R6,[R0, #+48]
   \   00000054   0x2E02             CMP      R6,#+2
   \   00000056   0xD101             BNE.N    ??HAL_SPI_TransmitReceive_IT_5
   1171                {
   1172                  hspi->CRCSize = 2;
   \   00000058   0x2602             MOVS     R6,#+2
   \   0000005A   0x6066             STR      R6,[R4, #+4]
   1173                }
   1174              }
   1175              
   1176              if(hspi->State != HAL_SPI_STATE_BUSY_RX)
   \                     ??HAL_SPI_TransmitReceive_IT_5: (+1)
   \   0000005C   0x7E66             LDRB     R6,[R4, #+25]
   \   0000005E   0x2E04             CMP      R6,#+4
   \   00000060   0xD001             BEQ.N    ??HAL_SPI_TransmitReceive_IT_6
   1177              {
   1178                hspi->State = HAL_SPI_STATE_BUSY_TX_RX;
   \   00000062   0x2605             MOVS     R6,#+5
   \   00000064   0x7666             STRB     R6,[R4, #+25]
   1179              }
   1180              
   1181              hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
   \                     ??HAL_SPI_TransmitReceive_IT_6: (+1)
   \   00000066   0x2600             MOVS     R6,#+0
   \   00000068   0x61E6             STR      R6,[R4, #+28]
   1182              hspi->pTxBuffPtr  = pTxData;
   \   0000006A   0x6381             STR      R1,[R0, #+56]
   1183              hspi->TxXferSize  = Size;
   \   0000006C   0x8783             STRH     R3,[R0, #+60]
   1184              hspi->TxXferCount = Size;
   \   0000006E   0x87C3             STRH     R3,[R0, #+62]
   1185              hspi->pRxBuffPtr  = pRxData;
   \   00000070   0x6402             STR      R2,[R0, #+64]
   1186              hspi->RxXferSize  = Size;
   \   00000072   0x8023             STRH     R3,[R4, #+0]
   1187              hspi->RxXferCount = Size;
   \   00000074   0x8063             STRH     R3,[R4, #+2]
   1188              
   1189              /* Set the function for IT treatement */
   1190              if(hspi->Init.DataSize > SPI_DATASIZE_8BIT )
   \   00000076   0x68C1             LDR      R1,[R0, #+12]
   \   00000078   0x42A9             CMP      R1,R5
   \   0000007A   0xD306             BCC.N    ??HAL_SPI_TransmitReceive_IT_7
   1191              {
   1192                hspi->RxISR = SPI_2linesRxISR_16BIT;
   \   0000007C   0x.... 0x....      ADR.W    R1,SPI_2linesRxISR_16BIT
   \   00000080   0x60A1             STR      R1,[R4, #+8]
   1193                hspi->TxISR = SPI_2linesTxISR_16BIT;       
   \   00000082   0x.... 0x....      ADR.W    R1,SPI_2linesTxISR_16BIT
   \   00000086   0x60E1             STR      R1,[R4, #+12]
   \   00000088   0xE005             B.N      ??HAL_SPI_TransmitReceive_IT_8
   1194              }
   1195              else
   1196              {
   1197                hspi->RxISR = SPI_2linesRxISR_8BIT;
   \                     ??HAL_SPI_TransmitReceive_IT_7: (+1)
   \   0000008A   0x.... 0x....      ADR.W    R1,SPI_2linesRxISR_8BIT
   \   0000008E   0x60A1             STR      R1,[R4, #+8]
   1198                hspi->TxISR = SPI_2linesTxISR_8BIT;
   \   00000090   0x.... 0x....      ADR.W    R1,SPI_2linesTxISR_8BIT
   \   00000094   0x60E1             STR      R1,[R4, #+12]
   1199              }
   1200              
   1201              /* Reset CRC Calculation */
   1202              if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   \                     ??HAL_SPI_TransmitReceive_IT_8: (+1)
   \   00000096   0x6A81             LDR      R1,[R0, #+40]
   \   00000098   0xF5B1 0x5F00      CMP      R1,#+8192
   \   0000009C   0xD10A             BNE.N    ??HAL_SPI_TransmitReceive_IT_9
   1203              {
   1204                SPI_RESET_CRC(hspi);
   \   0000009E   0x6801             LDR      R1,[R0, #+0]
   \   000000A0   0x680A             LDR      R2,[R1, #+0]
   \   000000A2   0xF64D 0x73FF      MOVW     R3,#+57343
   \   000000A6   0x401A             ANDS     R2,R3,R2
   \   000000A8   0x600A             STR      R2,[R1, #+0]
   \   000000AA   0x6801             LDR      R1,[R0, #+0]
   \   000000AC   0x680A             LDR      R2,[R1, #+0]
   \   000000AE   0xF442 0x5200      ORR      R2,R2,#0x2000
   \   000000B2   0x600A             STR      R2,[R1, #+0]
   1205              }
   1206              
   1207              /* check if packing mode is enabled and if there is more than 2 data to receive */
   1208              if((hspi->Init.DataSize > SPI_DATASIZE_8BIT) || (hspi->RxXferCount >= 2))
   \                     ??HAL_SPI_TransmitReceive_IT_9: (+1)
   \   000000B4   0x68C1             LDR      R1,[R0, #+12]
   \   000000B6   0x42A9             CMP      R1,R5
   \   000000B8   0xD202             BCS.N    ??HAL_SPI_TransmitReceive_IT_10
   \   000000BA   0x8861             LDRH     R1,[R4, #+2]
   \   000000BC   0x2902             CMP      R1,#+2
   \   000000BE   0xDB05             BLT.N    ??HAL_SPI_TransmitReceive_IT_11
   1209              {
   1210                /* set fiforxthreshold according the reception data length: 16 bit */
   1211                CLEAR_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
   \                     ??HAL_SPI_TransmitReceive_IT_10: (+1)
   \   000000C0   0x6801             LDR      R1,[R0, #+0]
   \   000000C2   0x684A             LDR      R2,[R1, #+4]
   \   000000C4   0xF422 0x5280      BIC      R2,R2,#0x1000
   \   000000C8   0x604A             STR      R2,[R1, #+4]
   \   000000CA   0xE004             B.N      ??HAL_SPI_TransmitReceive_IT_12
   1212              }
   1213              else
   1214              {
   1215                /* set fiforxthreshold according the reception data length: 8 bit */
   1216                SET_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
   \                     ??HAL_SPI_TransmitReceive_IT_11: (+1)
   \   000000CC   0x6801             LDR      R1,[R0, #+0]
   \   000000CE   0x684A             LDR      R2,[R1, #+4]
   \   000000D0   0xF442 0x5280      ORR      R2,R2,#0x1000
   \   000000D4   0x604A             STR      R2,[R1, #+4]
   1217              }
   1218              
   1219              /* Enable TXE, RXNE and ERR interrupt */
   1220              __HAL_SPI_ENABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_RXNE | SPI_IT_ERR));
   \                     ??HAL_SPI_TransmitReceive_IT_12: (+1)
   \   000000D6   0x6801             LDR      R1,[R0, #+0]
   \   000000D8   0x684A             LDR      R2,[R1, #+4]
   \   000000DA   0xF042 0x02E0      ORR      R2,R2,#0xE0
   \   000000DE   0x604A             STR      R2,[R1, #+4]
   1221              
   1222              /* Process Unlocked */
   1223              __HAL_UNLOCK(hspi);
   \   000000E0   0x4631             MOV      R1,R6
   \   000000E2   0x7621             STRB     R1,[R4, #+24]
   1224              
   1225              /* Check if the SPI is already enabled */ 
   1226              if((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
   \   000000E4   0x6800             LDR      R0,[R0, #+0]
   \   000000E6   0x6801             LDR      R1,[R0, #+0]
   \   000000E8   0x0649             LSLS     R1,R1,#+25
   \   000000EA   0xD403             BMI.N    ??HAL_SPI_TransmitReceive_IT_13
   1227              {
   1228                /* Enable SPI peripheral */    
   1229                __HAL_SPI_ENABLE(hspi);
   \   000000EC   0x6801             LDR      R1,[R0, #+0]
   \   000000EE   0xF041 0x0140      ORR      R1,R1,#0x40
   \   000000F2   0x6001             STR      R1,[R0, #+0]
   1230              }
   1231              
   1232              return HAL_OK;
   \                     ??HAL_SPI_TransmitReceive_IT_13: (+1)
   \   000000F4   0x4630             MOV      R0,R6
   \   000000F6   0xE000             B.N      ??HAL_SPI_TransmitReceive_IT_4
   1233            }
   1234            else
   1235            {
   1236              return HAL_BUSY;
   \                     ??HAL_SPI_TransmitReceive_IT_1: (+1)
   \   000000F8   0x2002             MOVS     R0,#+2
   \                     ??HAL_SPI_TransmitReceive_IT_4: (+1)
   \   000000FA   0xBC70             POP      {R4-R6}
   \   000000FC   0x4770             BX       LR               ;; return
   1237            }
   1238          }
   1239          
   1240          /**
   1241            * @brief  Transmit an amount of data in no-blocking mode with DMA
   1242            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   1243            *               the configuration information for SPI module.
   1244            * @param  pData: pointer to data buffer
   1245            * @param  Size: amount of data to be sent
   1246            * @retval HAL status
   1247            */

   \                                 In section .text, align 2, keep-with-next
   1248          HAL_StatusTypeDef HAL_SPI_Transmit_DMA(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size)
   1249          {    
   \                     HAL_SPI_Transmit_DMA: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4605             MOV      R5,R0
   1250            assert_param(IS_SPI_DIRECTION_2LINES_OR_1LINE(hspi->Init.Direction));
   1251          
   1252            if(hspi->State != HAL_SPI_STATE_READY) 
   \   00000004   0xF105 0x0444      ADD      R4,R5,#+68
   \   00000008   0x7E60             LDRB     R0,[R4, #+25]
   \   0000000A   0x2801             CMP      R0,#+1
   \   0000000C   0xD108             BNE.N    ??HAL_SPI_Transmit_DMA_0
   1253            {
   1254              return HAL_BUSY;
   1255            }
   1256            
   1257            if((pData == NULL) || (Size == 0))
   \   0000000E   0x2900             CMP      R1,#+0
   \   00000010   0xD001             BEQ.N    ??HAL_SPI_Transmit_DMA_1
   \   00000012   0x2A00             CMP      R2,#+0
   \   00000014   0xD101             BNE.N    ??HAL_SPI_Transmit_DMA_2
   1258            {
   1259              return HAL_ERROR;
   \                     ??HAL_SPI_Transmit_DMA_1: (+1)
   \   00000016   0x2001             MOVS     R0,#+1
   \   00000018   0xBD32             POP      {R1,R4,R5,PC}
   1260            }
   1261            
   1262            /* Process Locked */
   1263            __HAL_LOCK(hspi);
   \                     ??HAL_SPI_Transmit_DMA_2: (+1)
   \   0000001A   0x7E20             LDRB     R0,[R4, #+24]
   \   0000001C   0x2801             CMP      R0,#+1
   \   0000001E   0xD101             BNE.N    ??HAL_SPI_Transmit_DMA_3
   \                     ??HAL_SPI_Transmit_DMA_0: (+1)
   \   00000020   0x2002             MOVS     R0,#+2
   \   00000022   0xBD32             POP      {R1,R4,R5,PC}
   \                     ??HAL_SPI_Transmit_DMA_3: (+1)
   \   00000024   0x2001             MOVS     R0,#+1
   \   00000026   0x7620             STRB     R0,[R4, #+24]
   1264            
   1265            hspi->State       = HAL_SPI_STATE_BUSY_TX;
   \   00000028   0x2003             MOVS     R0,#+3
   \   0000002A   0x7660             STRB     R0,[R4, #+25]
   1266            hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0x61E0             STR      R0,[R4, #+28]
   1267            hspi->pTxBuffPtr  = pData;
   \   00000030   0x63A9             STR      R1,[R5, #+56]
   1268            hspi->TxXferSize  = Size;
   \   00000032   0x87AA             STRH     R2,[R5, #+60]
   1269            hspi->TxXferCount = Size;
   \   00000034   0x87EA             STRH     R2,[R5, #+62]
   1270            hspi->pRxBuffPtr  = (uint8_t *)NULL;
   \   00000036   0x6428             STR      R0,[R5, #+64]
   1271            hspi->RxXferSize  = 0;
   \   00000038   0x8020             STRH     R0,[R4, #+0]
   1272            hspi->RxXferCount = 0;
   \   0000003A   0x8060             STRH     R0,[R4, #+2]
   1273            
   1274            /* Configure communication direction : 1Line */
   1275            if(hspi->Init.Direction == SPI_DIRECTION_1LINE)
   \   0000003C   0x68A8             LDR      R0,[R5, #+8]
   \   0000003E   0xF5B0 0x4F00      CMP      R0,#+32768
   \   00000042   0xD104             BNE.N    ??HAL_SPI_Transmit_DMA_4
   1276            {
   1277              SPI_1LINE_TX(hspi);
   \   00000044   0x6828             LDR      R0,[R5, #+0]
   \   00000046   0x6801             LDR      R1,[R0, #+0]
   \   00000048   0xF441 0x4180      ORR      R1,R1,#0x4000
   \   0000004C   0x6001             STR      R1,[R0, #+0]
   1278            }
   1279            
   1280            /* Reset CRC Calculation */
   1281            if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   \                     ??HAL_SPI_Transmit_DMA_4: (+1)
   \   0000004E   0x6AA8             LDR      R0,[R5, #+40]
   \   00000050   0xF5B0 0x5F00      CMP      R0,#+8192
   \   00000054   0xD10A             BNE.N    ??HAL_SPI_Transmit_DMA_5
   1282            {
   1283              SPI_RESET_CRC(hspi);
   \   00000056   0x6828             LDR      R0,[R5, #+0]
   \   00000058   0x6801             LDR      R1,[R0, #+0]
   \   0000005A   0xF64D 0x72FF      MOVW     R2,#+57343
   \   0000005E   0x4011             ANDS     R1,R2,R1
   \   00000060   0x6001             STR      R1,[R0, #+0]
   \   00000062   0x6828             LDR      R0,[R5, #+0]
   \   00000064   0x6801             LDR      R1,[R0, #+0]
   \   00000066   0xF441 0x5100      ORR      R1,R1,#0x2000
   \   0000006A   0x6001             STR      R1,[R0, #+0]
   1284            }
   1285            
   1286            /* Set the SPI TxDMA Half transfer complete callback */
   1287            hspi->hdmatx->XferHalfCpltCallback = SPI_DMAHalfTransmitCplt;
   \                     ??HAL_SPI_Transmit_DMA_5: (+1)
   \   0000006C   0x.... 0x....      ADR.W    R0,SPI_DMAHalfTransmitCplt
   \   00000070   0x6921             LDR      R1,[R4, #+16]
   \   00000072   0x6408             STR      R0,[R1, #+64]
   1288            
   1289            /* Set the SPI TxDMA transfer complete callback */
   1290            hspi->hdmatx->XferCpltCallback = SPI_DMATransmitCplt;
   \   00000074   0x.... 0x....      ADR.W    R0,SPI_DMATransmitCplt
   \   00000078   0x6921             LDR      R1,[R4, #+16]
   \   0000007A   0x63C8             STR      R0,[R1, #+60]
   1291            
   1292            /* Set the DMA error callback */
   1293            hspi->hdmatx->XferErrorCallback = SPI_DMAError;
   \   0000007C   0x.... 0x....      ADR.W    R0,SPI_DMAError
   \   00000080   0x6921             LDR      R1,[R4, #+16]
   \   00000082   0x6488             STR      R0,[R1, #+72]
   1294            
   1295            CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_LDMATX);
   \   00000084   0x6828             LDR      R0,[R5, #+0]
   \   00000086   0x6841             LDR      R1,[R0, #+4]
   \   00000088   0xF421 0x4180      BIC      R1,R1,#0x4000
   \   0000008C   0x6041             STR      R1,[R0, #+4]
   1296            /* packing mode is enabled only if the DMA setting is HALWORD */
   1297            if((hspi->Init.DataSize <= SPI_DATASIZE_8BIT) && (hspi->hdmatx->Init.MemDataAlignment == DMA_MDATAALIGN_HALFWORD))
   \   0000008E   0x68E8             LDR      R0,[R5, #+12]
   \   00000090   0xF5B0 0x6FE0      CMP      R0,#+1792
   \   00000094   0xD818             BHI.N    ??HAL_SPI_Transmit_DMA_6
   \   00000096   0x6920             LDR      R0,[R4, #+16]
   \   00000098   0x6980             LDR      R0,[R0, #+24]
   \   0000009A   0xF5B0 0x5F00      CMP      R0,#+8192
   \   0000009E   0xD113             BNE.N    ??HAL_SPI_Transmit_DMA_6
   1298            {
   1299              /* Check the even/odd of the data size + crc if enabled */
   1300              if((hspi->TxXferCount & 0x1) == 0)
   \   000000A0   0x6828             LDR      R0,[R5, #+0]
   \   000000A2   0xF895 0x103E      LDRB     R1,[R5, #+62]
   \   000000A6   0x07C9             LSLS     R1,R1,#+31
   \   000000A8   0x6841             LDR      R1,[R0, #+4]
   \   000000AA   0xD406             BMI.N    ??HAL_SPI_Transmit_DMA_7
   1301              {
   1302                CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_LDMATX);
   \   000000AC   0xF421 0x4180      BIC      R1,R1,#0x4000
   \   000000B0   0x6041             STR      R1,[R0, #+4]
   1303                hspi->TxXferCount = (hspi->TxXferCount >> 1);
   \   000000B2   0x8FE8             LDRH     R0,[R5, #+62]
   \   000000B4   0x0840             LSRS     R0,R0,#+1
   \   000000B6   0x87E8             STRH     R0,[R5, #+62]
   \   000000B8   0xE006             B.N      ??HAL_SPI_Transmit_DMA_6
   1304              }
   1305              else
   1306              {
   1307                SET_BIT(hspi->Instance->CR2, SPI_CR2_LDMATX);
   \                     ??HAL_SPI_Transmit_DMA_7: (+1)
   \   000000BA   0xF441 0x4180      ORR      R1,R1,#0x4000
   \   000000BE   0x6041             STR      R1,[R0, #+4]
   1308                hspi->TxXferCount = (hspi->TxXferCount >> 1) + 1;
   \   000000C0   0x8FE8             LDRH     R0,[R5, #+62]
   \   000000C2   0x0840             LSRS     R0,R0,#+1
   \   000000C4   0x1C40             ADDS     R0,R0,#+1
   \   000000C6   0x87E8             STRH     R0,[R5, #+62]
   1309              }
   1310            }
   1311            
   1312            /* Enable the Tx DMA channel */
   1313            HAL_DMA_Start_IT(hspi->hdmatx, (uint32_t)hspi->pTxBuffPtr, (uint32_t)&hspi->Instance->DR, hspi->TxXferCount);
   \                     ??HAL_SPI_Transmit_DMA_6: (+1)
   \   000000C8   0x8FEB             LDRH     R3,[R5, #+62]
   \   000000CA   0x6828             LDR      R0,[R5, #+0]
   \   000000CC   0xF100 0x020C      ADD      R2,R0,#+12
   \   000000D0   0x6BA9             LDR      R1,[R5, #+56]
   \   000000D2   0x6920             LDR      R0,[R4, #+16]
   \   000000D4   0x.... 0x....      BL       HAL_DMA_Start_IT
   1314            
   1315            /* Check if the SPI is already enabled */ 
   1316            if((hspi->Instance->CR1 &SPI_CR1_SPE) != SPI_CR1_SPE)
   \   000000D8   0x6828             LDR      R0,[R5, #+0]
   \   000000DA   0x6801             LDR      R1,[R0, #+0]
   \   000000DC   0x0649             LSLS     R1,R1,#+25
   \   000000DE   0xD403             BMI.N    ??HAL_SPI_Transmit_DMA_8
   1317            {
   1318              /* Enable SPI peripheral */    
   1319              __HAL_SPI_ENABLE(hspi);
   \   000000E0   0x6801             LDR      R1,[R0, #+0]
   \   000000E2   0xF041 0x0140      ORR      R1,R1,#0x40
   \   000000E6   0x6001             STR      R1,[R0, #+0]
   1320            }
   1321          
   1322            /* Enable Tx DMA Request */
   1323            hspi->Instance->CR2 |= SPI_CR2_TXDMAEN;
   \                     ??HAL_SPI_Transmit_DMA_8: (+1)
   \   000000E8   0x6828             LDR      R0,[R5, #+0]
   \   000000EA   0x6841             LDR      R1,[R0, #+4]
   \   000000EC   0xF041 0x0102      ORR      R1,R1,#0x2
   \   000000F0   0x6041             STR      R1,[R0, #+4]
   1324            
   1325            /* Process Unlocked */
   1326            __HAL_UNLOCK(hspi);
   \   000000F2   0x2000             MOVS     R0,#+0
   \   000000F4   0x7620             STRB     R0,[R4, #+24]
   1327            
   1328            return HAL_OK;
   \   000000F6   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1329          }
   1330          
   1331          /**
   1332          * @brief  Receive an amount of data in no-blocking mode with DMA 
   1333          * @param  hspi: SPI handle
   1334          * @param  pData: pointer to data buffer
   1335          * @param  Size: amount of data to be sent
   1336          * @retval HAL status
   1337          */

   \                                 In section .text, align 2, keep-with-next
   1338          HAL_StatusTypeDef HAL_SPI_Receive_DMA(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size)
   1339          {
   \                     HAL_SPI_Receive_DMA: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   1340            if(hspi->State != HAL_SPI_STATE_READY)
   \   00000004   0xF104 0x0544      ADD      R5,R4,#+68
   \   00000008   0x7E68             LDRB     R0,[R5, #+25]
   \   0000000A   0x2801             CMP      R0,#+1
   \   0000000C   0xD108             BNE.N    ??HAL_SPI_Receive_DMA_0
   1341            {
   1342              return HAL_BUSY;
   1343            }
   1344            
   1345            if((pData == NULL) || (Size == 0))
   \   0000000E   0x2900             CMP      R1,#+0
   \   00000010   0xD001             BEQ.N    ??HAL_SPI_Receive_DMA_1
   \   00000012   0x2A00             CMP      R2,#+0
   \   00000014   0xD101             BNE.N    ??HAL_SPI_Receive_DMA_2
   1346            {
   1347              return HAL_ERROR;
   \                     ??HAL_SPI_Receive_DMA_1: (+1)
   \   00000016   0x2001             MOVS     R0,#+1
   \   00000018   0xBD32             POP      {R1,R4,R5,PC}
   1348            }
   1349            
   1350            /* Process Locked */
   1351            __HAL_LOCK(hspi);
   \                     ??HAL_SPI_Receive_DMA_2: (+1)
   \   0000001A   0x7E28             LDRB     R0,[R5, #+24]
   \   0000001C   0x2801             CMP      R0,#+1
   \   0000001E   0xD101             BNE.N    ??HAL_SPI_Receive_DMA_3
   \                     ??HAL_SPI_Receive_DMA_0: (+1)
   \   00000020   0x2002             MOVS     R0,#+2
   \   00000022   0xBD32             POP      {R1,R4,R5,PC}
   \                     ??HAL_SPI_Receive_DMA_3: (+1)
   \   00000024   0x2001             MOVS     R0,#+1
   \   00000026   0x7628             STRB     R0,[R5, #+24]
   1352          
   1353            hspi->State       = HAL_SPI_STATE_BUSY_RX;
   \   00000028   0x2004             MOVS     R0,#+4
   \   0000002A   0x7668             STRB     R0,[R5, #+25]
   1354            hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0x61E8             STR      R0,[R5, #+28]
   1355            hspi->pRxBuffPtr  = pData;
   \   00000030   0x6421             STR      R1,[R4, #+64]
   1356            hspi->RxXferSize  = Size;
   \   00000032   0x802A             STRH     R2,[R5, #+0]
   1357            hspi->RxXferCount = Size;
   \   00000034   0x806A             STRH     R2,[R5, #+2]
   1358            hspi->pTxBuffPtr  = (uint8_t *)NULL;
   \   00000036   0x63A0             STR      R0,[R4, #+56]
   1359            hspi->TxXferSize  = 0;
   \   00000038   0x87A0             STRH     R0,[R4, #+60]
   1360            hspi->TxXferCount = 0;
   \   0000003A   0x87E0             STRH     R0,[R4, #+62]
   1361          
   1362            if((hspi->Init.Mode == SPI_MODE_MASTER) && (hspi->Init.Direction == SPI_DIRECTION_2LINES))
   \   0000003C   0x68A0             LDR      R0,[R4, #+8]
   \   0000003E   0x6863             LDR      R3,[R4, #+4]
   \   00000040   0xF5B3 0x7F82      CMP      R3,#+260
   \   00000044   0xD10A             BNE.N    ??HAL_SPI_Receive_DMA_4
   \   00000046   0x2800             CMP      R0,#+0
   \   00000048   0xD108             BNE.N    ??HAL_SPI_Receive_DMA_4
   1363            {
   1364              /* Process Unlocked */
   1365              __HAL_UNLOCK(hspi);
   \   0000004A   0x2000             MOVS     R0,#+0
   \   0000004C   0x7628             STRB     R0,[R5, #+24]
   1366              /* the receive process is not supported in 2Lines direction master mode */
   1367              /* in this case we call the transmitReceive process                     */
   1368              return HAL_SPI_TransmitReceive_DMA(hspi,pData,pData,Size);
   \   0000004E   0x4613             MOV      R3,R2
   \   00000050   0x460A             MOV      R2,R1
   \   00000052   0x4620             MOV      R0,R4
   \   00000054   0xB001             ADD      SP,SP,#+4
   \   00000056   0xE8BD 0x4030      POP      {R4,R5,LR}
   \   0000005A   0x....             B.N      HAL_SPI_TransmitReceive_DMA
   1369            }
   1370            
   1371            /* Configure communication direction : 1Line */
   1372            if(hspi->Init.Direction == SPI_DIRECTION_1LINE)
   \                     ??HAL_SPI_Receive_DMA_4: (+1)
   \   0000005C   0xF5B0 0x4F00      CMP      R0,#+32768
   \   00000060   0xD104             BNE.N    ??HAL_SPI_Receive_DMA_5
   1373            {
   1374              SPI_1LINE_RX(hspi);
   \   00000062   0x6820             LDR      R0,[R4, #+0]
   \   00000064   0x6801             LDR      R1,[R0, #+0]
   \   00000066   0xF421 0x4180      BIC      R1,R1,#0x4000
   \   0000006A   0x6001             STR      R1,[R0, #+0]
   1375            }
   1376            
   1377            /* Reset CRC Calculation */
   1378            if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   \                     ??HAL_SPI_Receive_DMA_5: (+1)
   \   0000006C   0x6AA0             LDR      R0,[R4, #+40]
   \   0000006E   0xF5B0 0x5F00      CMP      R0,#+8192
   \   00000072   0xD10A             BNE.N    ??HAL_SPI_Receive_DMA_6
   1379            {
   1380              SPI_RESET_CRC(hspi);
   \   00000074   0x6820             LDR      R0,[R4, #+0]
   \   00000076   0x6801             LDR      R1,[R0, #+0]
   \   00000078   0xF64D 0x72FF      MOVW     R2,#+57343
   \   0000007C   0x4011             ANDS     R1,R2,R1
   \   0000007E   0x6001             STR      R1,[R0, #+0]
   \   00000080   0x6820             LDR      R0,[R4, #+0]
   \   00000082   0x6801             LDR      R1,[R0, #+0]
   \   00000084   0xF441 0x5100      ORR      R1,R1,#0x2000
   \   00000088   0x6001             STR      R1,[R0, #+0]
   1381            }
   1382            
   1383            /* packing mode management is enabled by the DMA settings */
   1384            if((hspi->Init.DataSize <= SPI_DATASIZE_8BIT) && (hspi->hdmarx->Init.MemDataAlignment == DMA_MDATAALIGN_HALFWORD))
   \                     ??HAL_SPI_Receive_DMA_6: (+1)
   \   0000008A   0xF240 0x7001      MOVW     R0,#+1793
   \   0000008E   0x68E1             LDR      R1,[R4, #+12]
   \   00000090   0x4281             CMP      R1,R0
   \   00000092   0xD208             BCS.N    ??HAL_SPI_Receive_DMA_7
   \   00000094   0x6969             LDR      R1,[R5, #+20]
   \   00000096   0x6989             LDR      R1,[R1, #+24]
   \   00000098   0xF5B1 0x5F00      CMP      R1,#+8192
   \   0000009C   0xD103             BNE.N    ??HAL_SPI_Receive_DMA_7
   1385            {
   1386              /* Process Locked */
   1387              __HAL_UNLOCK(hspi);
   \   0000009E   0x2000             MOVS     R0,#+0
   \   000000A0   0x7628             STRB     R0,[R5, #+24]
   1388              /* Restriction the DMA data received is not allowed in this mode */
   1389              return HAL_ERROR;
   \   000000A2   0x2001             MOVS     R0,#+1
   \   000000A4   0xBD32             POP      {R1,R4,R5,PC}
   1390            }
   1391            
   1392            CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_LDMARX);
   \                     ??HAL_SPI_Receive_DMA_7: (+1)
   \   000000A6   0x6821             LDR      R1,[R4, #+0]
   \   000000A8   0x684A             LDR      R2,[R1, #+4]
   \   000000AA   0xF422 0x5200      BIC      R2,R2,#0x2000
   \   000000AE   0x604A             STR      R2,[R1, #+4]
   1393            if( hspi->Init.DataSize > SPI_DATASIZE_8BIT)
   \   000000B0   0x6821             LDR      R1,[R4, #+0]
   \   000000B2   0x68E2             LDR      R2,[R4, #+12]
   \   000000B4   0x4282             CMP      R2,R0
   \   000000B6   0x6848             LDR      R0,[R1, #+4]
   \   000000B8   0xD303             BCC.N    ??HAL_SPI_Receive_DMA_8
   1394            {
   1395              /* set fiforxthreshold according the reception data length: 16bit */
   1396              CLEAR_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
   \   000000BA   0xF420 0x5080      BIC      R0,R0,#0x1000
   \   000000BE   0x6048             STR      R0,[R1, #+4]
   \   000000C0   0xE002             B.N      ??HAL_SPI_Receive_DMA_9
   1397            }
   1398            else
   1399            {
   1400              /* set fiforxthreshold according the reception data length: 8bit */
   1401              SET_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
   \                     ??HAL_SPI_Receive_DMA_8: (+1)
   \   000000C2   0xF440 0x5080      ORR      R0,R0,#0x1000
   \   000000C6   0x6048             STR      R0,[R1, #+4]
   1402            }
   1403            
   1404            /* Set the SPI RxDMA Half transfer complete callback */
   1405            hspi->hdmarx->XferHalfCpltCallback = SPI_DMAHalfReceiveCplt;
   \                     ??HAL_SPI_Receive_DMA_9: (+1)
   \   000000C8   0x.... 0x....      ADR.W    R0,SPI_DMAHalfReceiveCplt
   \   000000CC   0x6969             LDR      R1,[R5, #+20]
   \   000000CE   0x6408             STR      R0,[R1, #+64]
   1406          
   1407            /* Set the SPI Rx DMA transfer complete callback */
   1408            hspi->hdmarx->XferCpltCallback = SPI_DMAReceiveCplt;
   \   000000D0   0x.... 0x....      ADR.W    R0,SPI_DMAReceiveCplt
   \   000000D4   0x6969             LDR      R1,[R5, #+20]
   \   000000D6   0x63C8             STR      R0,[R1, #+60]
   1409            
   1410            /* Set the DMA error callback */
   1411            hspi->hdmarx->XferErrorCallback = SPI_DMAError;
   \   000000D8   0x.... 0x....      ADR.W    R0,SPI_DMAError
   \   000000DC   0x6969             LDR      R1,[R5, #+20]
   \   000000DE   0x6488             STR      R0,[R1, #+72]
   1412            
   1413            /* Enable Rx DMA Request */  
   1414            hspi->Instance->CR2 |= SPI_CR2_RXDMAEN;
   \   000000E0   0x6820             LDR      R0,[R4, #+0]
   \   000000E2   0x6841             LDR      R1,[R0, #+4]
   \   000000E4   0xF041 0x0101      ORR      R1,R1,#0x1
   \   000000E8   0x6041             STR      R1,[R0, #+4]
   1415            
   1416            /* Enable the Rx DMA channel */
   1417            HAL_DMA_Start_IT(hspi->hdmarx, (uint32_t)&hspi->Instance->DR, (uint32_t)hspi->pRxBuffPtr, hspi->RxXferCount);
   \   000000EA   0x886B             LDRH     R3,[R5, #+2]
   \   000000EC   0x6C22             LDR      R2,[R4, #+64]
   \   000000EE   0x6820             LDR      R0,[R4, #+0]
   \   000000F0   0xF100 0x010C      ADD      R1,R0,#+12
   \   000000F4   0x6968             LDR      R0,[R5, #+20]
   \   000000F6   0x.... 0x....      BL       HAL_DMA_Start_IT
   1418            
   1419            /* Process Unlocked */
   1420            __HAL_UNLOCK(hspi);
   \   000000FA   0x2000             MOVS     R0,#+0
   \   000000FC   0x7628             STRB     R0,[R5, #+24]
   1421            
   1422            /* Check if the SPI is already enabled */ 
   1423            if((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
   \   000000FE   0x6820             LDR      R0,[R4, #+0]
   \   00000100   0x6801             LDR      R1,[R0, #+0]
   \   00000102   0x0649             LSLS     R1,R1,#+25
   \   00000104   0xD403             BMI.N    ??HAL_SPI_Receive_DMA_10
   1424            {
   1425              /* Enable SPI peripheral */    
   1426              __HAL_SPI_ENABLE(hspi);
   \   00000106   0x6801             LDR      R1,[R0, #+0]
   \   00000108   0xF041 0x0140      ORR      R1,R1,#0x40
   \   0000010C   0x6001             STR      R1,[R0, #+0]
   1427            }
   1428            
   1429            return HAL_OK;
   \                     ??HAL_SPI_Receive_DMA_10: (+1)
   \   0000010E   0x2000             MOVS     R0,#+0
   \   00000110   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1430          }
   1431          
   1432          /**
   1433            * @brief  Transmit and Receive an amount of data in no-blocking mode with DMA
   1434            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   1435            *               the configuration information for SPI module.
   1436            * @param  pTxData: pointer to transmission data buffer
   1437            * @param  pRxData: pointer to reception data buffer
   1438            * @note  When the CRC feature is enabled the pRxData Length must be Size + 1
   1439            * @param  Size: amount of data to be sent
   1440            * @retval HAL status
   1441            */

   \                                 In section .text, align 2, keep-with-next
   1442          HAL_StatusTypeDef HAL_SPI_TransmitReceive_DMA(SPI_HandleTypeDef *hspi, uint8_t *pTxData, uint8_t *pRxData, uint16_t Size)
   1443          {
   \                     HAL_SPI_TransmitReceive_DMA: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   1444            assert_param(IS_SPI_DIRECTION_2LINES(hspi->Init.Direction));
   1445            
   1446            if((hspi->State == HAL_SPI_STATE_READY) ||
   1447               ((hspi->Init.Mode == SPI_MODE_MASTER) && (hspi->Init.Direction == SPI_DIRECTION_2LINES) && (hspi->State == HAL_SPI_STATE_BUSY_RX)))
   \   00000004   0xF104 0x0544      ADD      R5,R4,#+68
   \   00000008   0x7E68             LDRB     R0,[R5, #+25]
   \   0000000A   0x2801             CMP      R0,#+1
   \   0000000C   0xD00B             BEQ.N    ??HAL_SPI_TransmitReceive_DMA_0
   \   0000000E   0x6866             LDR      R6,[R4, #+4]
   \   00000010   0xF5B6 0x7F82      CMP      R6,#+260
   \   00000014   0xF040 0x80C8      BNE.W    ??HAL_SPI_TransmitReceive_DMA_1
   \   00000018   0x68A6             LDR      R6,[R4, #+8]
   \   0000001A   0x2E00             CMP      R6,#+0
   \   0000001C   0xF040 0x80C4      BNE.W    ??HAL_SPI_TransmitReceive_DMA_1
   \   00000020   0x2804             CMP      R0,#+4
   \   00000022   0xF040 0x80C1      BNE.W    ??HAL_SPI_TransmitReceive_DMA_1
   1448            {
   1449              if((pTxData == NULL ) || (pRxData == NULL ) || (Size == 0)) 
   \                     ??HAL_SPI_TransmitReceive_DMA_0: (+1)
   \   00000026   0x2900             CMP      R1,#+0
   \   00000028   0xD003             BEQ.N    ??HAL_SPI_TransmitReceive_DMA_2
   \   0000002A   0x2A00             CMP      R2,#+0
   \   0000002C   0xD001             BEQ.N    ??HAL_SPI_TransmitReceive_DMA_2
   \   0000002E   0x2B00             CMP      R3,#+0
   \   00000030   0xD101             BNE.N    ??HAL_SPI_TransmitReceive_DMA_3
   1450              {
   1451                return  HAL_ERROR;                                    
   \                     ??HAL_SPI_TransmitReceive_DMA_2: (+1)
   \   00000032   0x2001             MOVS     R0,#+1
   \   00000034   0xBD70             POP      {R4-R6,PC}
   1452              }
   1453              
   1454              /* Process locked */
   1455              __HAL_LOCK(hspi);
   \                     ??HAL_SPI_TransmitReceive_DMA_3: (+1)
   \   00000036   0x7E28             LDRB     R0,[R5, #+24]
   \   00000038   0x2801             CMP      R0,#+1
   \   0000003A   0xF000 0x80B5      BEQ.W    ??HAL_SPI_TransmitReceive_DMA_1
   \   0000003E   0x2001             MOVS     R0,#+1
   \   00000040   0x7628             STRB     R0,[R5, #+24]
   1456              
   1457              /* check if the transmit Receive function is not called by a receive master */
   1458              if(hspi->State != HAL_SPI_STATE_BUSY_RX)
   \   00000042   0x7E68             LDRB     R0,[R5, #+25]
   \   00000044   0x2804             CMP      R0,#+4
   \   00000046   0xD001             BEQ.N    ??HAL_SPI_TransmitReceive_DMA_4
   1459              {  
   1460                hspi->State = HAL_SPI_STATE_BUSY_TX_RX;
   \   00000048   0x2005             MOVS     R0,#+5
   \   0000004A   0x7668             STRB     R0,[R5, #+25]
   1461              }
   1462              
   1463              hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
   \                     ??HAL_SPI_TransmitReceive_DMA_4: (+1)
   \   0000004C   0x2000             MOVS     R0,#+0
   \   0000004E   0x61E8             STR      R0,[R5, #+28]
   1464              hspi->pTxBuffPtr  = (uint8_t *)pTxData;
   \   00000050   0x63A1             STR      R1,[R4, #+56]
   1465              hspi->TxXferSize  = Size;
   \   00000052   0x87A3             STRH     R3,[R4, #+60]
   1466              hspi->TxXferCount = Size;
   \   00000054   0x87E3             STRH     R3,[R4, #+62]
   1467              hspi->pRxBuffPtr  = (uint8_t *)pRxData;
   \   00000056   0x6422             STR      R2,[R4, #+64]
   1468              hspi->RxXferSize  = Size;
   \   00000058   0x802B             STRH     R3,[R5, #+0]
   1469              hspi->RxXferCount = Size;
   \   0000005A   0x806B             STRH     R3,[R5, #+2]
   1470              
   1471              /* Reset CRC Calculation + increase the rxsize */
   1472              if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   \   0000005C   0x6AA0             LDR      R0,[R4, #+40]
   \   0000005E   0xF5B0 0x5F00      CMP      R0,#+8192
   \   00000062   0xD10A             BNE.N    ??HAL_SPI_TransmitReceive_DMA_5
   1473              {
   1474                SPI_RESET_CRC(hspi);
   \   00000064   0x6820             LDR      R0,[R4, #+0]
   \   00000066   0x6801             LDR      R1,[R0, #+0]
   \   00000068   0xF64D 0x72FF      MOVW     R2,#+57343
   \   0000006C   0x4011             ANDS     R1,R2,R1
   \   0000006E   0x6001             STR      R1,[R0, #+0]
   \   00000070   0x6820             LDR      R0,[R4, #+0]
   \   00000072   0x6801             LDR      R1,[R0, #+0]
   \   00000074   0xF441 0x5100      ORR      R1,R1,#0x2000
   \   00000078   0x6001             STR      R1,[R0, #+0]
   1475              }
   1476              
   1477              /* Reset the threshold bit */
   1478              CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_LDMATX);
   \                     ??HAL_SPI_TransmitReceive_DMA_5: (+1)
   \   0000007A   0x6820             LDR      R0,[R4, #+0]
   \   0000007C   0x6841             LDR      R1,[R0, #+4]
   \   0000007E   0xF421 0x4180      BIC      R1,R1,#0x4000
   \   00000082   0x6041             STR      R1,[R0, #+4]
   1479              CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_LDMARX);
   \   00000084   0x6820             LDR      R0,[R4, #+0]
   \   00000086   0x6841             LDR      R1,[R0, #+4]
   \   00000088   0xF421 0x5100      BIC      R1,R1,#0x2000
   \   0000008C   0x6041             STR      R1,[R0, #+4]
   1480              
   1481              /* the packing mode management is enabled by the DMA settings according the spi data size */
   1482              if(hspi->Init.DataSize > SPI_DATASIZE_8BIT)
   \   0000008E   0x6820             LDR      R0,[R4, #+0]
   \   00000090   0x68E1             LDR      R1,[R4, #+12]
   \   00000092   0xF5B1 0x6FE0      CMP      R1,#+1792
   \   00000096   0x6841             LDR      R1,[R0, #+4]
   \   00000098   0xD903             BLS.N    ??HAL_SPI_TransmitReceive_DMA_6
   1483              {
   1484                /* set fiforxthreshold according the reception data length: 16bit */
   1485                CLEAR_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
   \   0000009A   0xF421 0x5180      BIC      R1,R1,#0x1000
   \   0000009E   0x6041             STR      R1,[R0, #+4]
   \   000000A0   0xE038             B.N      ??HAL_SPI_TransmitReceive_DMA_7
   1486              }
   1487              else
   1488              {
   1489                /* set fiforxthreshold according the reception data length: 8bit */
   1490                SET_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
   \                     ??HAL_SPI_TransmitReceive_DMA_6: (+1)
   \   000000A2   0xF441 0x5180      ORR      R1,R1,#0x1000
   \   000000A6   0x6041             STR      R1,[R0, #+4]
   1491                
   1492                if(hspi->hdmatx->Init.MemDataAlignment == DMA_MDATAALIGN_HALFWORD)
   \   000000A8   0x6928             LDR      R0,[R5, #+16]
   \   000000AA   0x6980             LDR      R0,[R0, #+24]
   \   000000AC   0xF5B0 0x5F00      CMP      R0,#+8192
   \   000000B0   0xD113             BNE.N    ??HAL_SPI_TransmitReceive_DMA_8
   1493                {
   1494                  if((hspi->TxXferSize & 0x1) == 0x0 )
   \   000000B2   0x6820             LDR      R0,[R4, #+0]
   \   000000B4   0xF894 0x103C      LDRB     R1,[R4, #+60]
   \   000000B8   0x07C9             LSLS     R1,R1,#+31
   \   000000BA   0x6841             LDR      R1,[R0, #+4]
   \   000000BC   0xD406             BMI.N    ??HAL_SPI_TransmitReceive_DMA_9
   1495                  {
   1496                    CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_LDMATX);
   \   000000BE   0xF421 0x4180      BIC      R1,R1,#0x4000
   \   000000C2   0x6041             STR      R1,[R0, #+4]
   1497                    hspi->TxXferCount = hspi->TxXferCount >> 1;
   \   000000C4   0x8FE0             LDRH     R0,[R4, #+62]
   \   000000C6   0x0840             LSRS     R0,R0,#+1
   \   000000C8   0x87E0             STRH     R0,[R4, #+62]
   \   000000CA   0xE006             B.N      ??HAL_SPI_TransmitReceive_DMA_8
   1498                  }
   1499                  else
   1500                  {
   1501                    SET_BIT(hspi->Instance->CR2, SPI_CR2_LDMATX);
   \                     ??HAL_SPI_TransmitReceive_DMA_9: (+1)
   \   000000CC   0xF441 0x4180      ORR      R1,R1,#0x4000
   \   000000D0   0x6041             STR      R1,[R0, #+4]
   1502                    hspi->TxXferCount = (hspi->TxXferCount >> 1) + 1;
   \   000000D2   0x8FE0             LDRH     R0,[R4, #+62]
   \   000000D4   0x0840             LSRS     R0,R0,#+1
   \   000000D6   0x1C40             ADDS     R0,R0,#+1
   \   000000D8   0x87E0             STRH     R0,[R4, #+62]
   1503                  }      
   1504                }
   1505                
   1506                if(hspi->hdmarx->Init.MemDataAlignment == DMA_MDATAALIGN_HALFWORD)
   \                     ??HAL_SPI_TransmitReceive_DMA_8: (+1)
   \   000000DA   0x6968             LDR      R0,[R5, #+20]
   \   000000DC   0x6980             LDR      R0,[R0, #+24]
   \   000000DE   0xF5B0 0x5F00      CMP      R0,#+8192
   \   000000E2   0xD117             BNE.N    ??HAL_SPI_TransmitReceive_DMA_7
   1507                {
   1508                  /* set fiforxthreshold according the reception data length: 16bit */
   1509                  CLEAR_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
   \   000000E4   0x6820             LDR      R0,[R4, #+0]
   \   000000E6   0x6841             LDR      R1,[R0, #+4]
   \   000000E8   0xF421 0x5180      BIC      R1,R1,#0x1000
   \   000000EC   0x6041             STR      R1,[R0, #+4]
   1510                  
   1511                  /* Size must include the CRC length */
   1512                  if((hspi->RxXferCount & 0x1) == 0x0 )
   \   000000EE   0x6820             LDR      R0,[R4, #+0]
   \   000000F0   0x78A9             LDRB     R1,[R5, #+2]
   \   000000F2   0x07C9             LSLS     R1,R1,#+31
   \   000000F4   0x6841             LDR      R1,[R0, #+4]
   \   000000F6   0xD406             BMI.N    ??HAL_SPI_TransmitReceive_DMA_10
   1513                  {
   1514                    CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_LDMARX);
   \   000000F8   0xF421 0x5100      BIC      R1,R1,#0x2000
   \   000000FC   0x6041             STR      R1,[R0, #+4]
   1515                    hspi->RxXferCount = hspi->RxXferCount >> 1;
   \   000000FE   0x8868             LDRH     R0,[R5, #+2]
   \   00000100   0x0840             LSRS     R0,R0,#+1
   \   00000102   0x8068             STRH     R0,[R5, #+2]
   \   00000104   0xE006             B.N      ??HAL_SPI_TransmitReceive_DMA_7
   1516                  }
   1517                  else
   1518                  {
   1519                    SET_BIT(hspi->Instance->CR2, SPI_CR2_LDMARX);
   \                     ??HAL_SPI_TransmitReceive_DMA_10: (+1)
   \   00000106   0xF441 0x5100      ORR      R1,R1,#0x2000
   \   0000010A   0x6041             STR      R1,[R0, #+4]
   1520                    hspi->RxXferCount = (hspi->RxXferCount >> 1) + 1; 
   \   0000010C   0x8868             LDRH     R0,[R5, #+2]
   \   0000010E   0x0840             LSRS     R0,R0,#+1
   \   00000110   0x1C40             ADDS     R0,R0,#+1
   \   00000112   0x8068             STRH     R0,[R5, #+2]
   1521                  } 
   1522                }
   1523              }   
   1524              
   1525              /* Set the SPI Rx DMA transfer complete callback because the last generated transfer request is 
   1526              the reception request (RXNE) */
   1527              if(hspi->State == HAL_SPI_STATE_BUSY_RX)
   \                     ??HAL_SPI_TransmitReceive_DMA_7: (+1)
   \   00000114   0x6968             LDR      R0,[R5, #+20]
   \   00000116   0x7E69             LDRB     R1,[R5, #+25]
   \   00000118   0x2904             CMP      R1,#+4
   \   0000011A   0xD107             BNE.N    ??HAL_SPI_TransmitReceive_DMA_11
   1528              {			
   1529                hspi->hdmarx->XferHalfCpltCallback = SPI_DMAHalfReceiveCplt;
   \   0000011C   0x.... 0x....      ADR.W    R1,SPI_DMAHalfReceiveCplt
   \   00000120   0x6401             STR      R1,[R0, #+64]
   1530                hspi->hdmarx->XferCpltCallback = SPI_DMAReceiveCplt;
   \   00000122   0x.... 0x....      ADR.W    R0,SPI_DMAReceiveCplt
   \   00000126   0x6969             LDR      R1,[R5, #+20]
   \   00000128   0x63C8             STR      R0,[R1, #+60]
   \   0000012A   0xE006             B.N      ??HAL_SPI_TransmitReceive_DMA_12
   1531              }
   1532              else
   1533              {	
   1534                 hspi->hdmarx->XferHalfCpltCallback = SPI_DMAHalfTransmitReceiveCplt;
   \                     ??HAL_SPI_TransmitReceive_DMA_11: (+1)
   \   0000012C   0x.... 0x....      ADR.W    R1,SPI_DMAHalfTransmitReceiveCplt
   \   00000130   0x6401             STR      R1,[R0, #+64]
   1535                hspi->hdmarx->XferCpltCallback = SPI_DMATransmitReceiveCplt;
   \   00000132   0x.... 0x....      ADR.W    R0,SPI_DMATransmitReceiveCplt
   \   00000136   0x6969             LDR      R1,[R5, #+20]
   \   00000138   0x63C8             STR      R0,[R1, #+60]
   1536              }
   1537              /* Set the DMA error callback */
   1538              hspi->hdmarx->XferErrorCallback = SPI_DMAError;
   \                     ??HAL_SPI_TransmitReceive_DMA_12: (+1)
   \   0000013A   0x.... 0x....      ADR.W    R6,SPI_DMAError
   \   0000013E   0x6968             LDR      R0,[R5, #+20]
   \   00000140   0x6486             STR      R6,[R0, #+72]
   1539              
   1540              /* Enable Rx DMA Request */  
   1541              hspi->Instance->CR2 |= SPI_CR2_RXDMAEN;
   \   00000142   0x6820             LDR      R0,[R4, #+0]
   \   00000144   0x6841             LDR      R1,[R0, #+4]
   \   00000146   0xF041 0x0101      ORR      R1,R1,#0x1
   \   0000014A   0x6041             STR      R1,[R0, #+4]
   1542              
   1543              /* Enable the Rx DMA channel */
   1544              HAL_DMA_Start_IT(hspi->hdmarx, (uint32_t)&hspi->Instance->DR, (uint32_t) hspi->pRxBuffPtr, hspi->RxXferCount);
   \   0000014C   0x886B             LDRH     R3,[R5, #+2]
   \   0000014E   0x6C22             LDR      R2,[R4, #+64]
   \   00000150   0x6820             LDR      R0,[R4, #+0]
   \   00000152   0xF100 0x010C      ADD      R1,R0,#+12
   \   00000156   0x6968             LDR      R0,[R5, #+20]
   \   00000158   0x.... 0x....      BL       HAL_DMA_Start_IT
   1545              
   1546              /* Set the SPI Tx DMA transfer complete callback as NULL because the communication closing
   1547              is performed in DMA reception complete callback  */
   1548              hspi->hdmatx->XferHalfCpltCallback = NULL;
   \   0000015C   0x2000             MOVS     R0,#+0
   \   0000015E   0x6929             LDR      R1,[R5, #+16]
   \   00000160   0x6408             STR      R0,[R1, #+64]
   1549              hspi->hdmatx->XferCpltCallback = NULL;
   \   00000162   0x6929             LDR      R1,[R5, #+16]
   \   00000164   0x63C8             STR      R0,[R1, #+60]
   1550          
   1551              if(hspi->State == HAL_SPI_STATE_BUSY_TX_RX)
   \   00000166   0x6928             LDR      R0,[R5, #+16]
   \   00000168   0x7E69             LDRB     R1,[R5, #+25]
   \   0000016A   0x2905             CMP      R1,#+5
   \   0000016C   0xD101             BNE.N    ??HAL_SPI_TransmitReceive_DMA_13
   1552              {
   1553                /* Set the DMA error callback */
   1554                hspi->hdmatx->XferErrorCallback = SPI_DMAError;
   \   0000016E   0x6486             STR      R6,[R0, #+72]
   \   00000170   0xE001             B.N      ??HAL_SPI_TransmitReceive_DMA_14
   1555              }
   1556              else
   1557              {
   1558                hspi->hdmatx->XferErrorCallback = NULL;
   \                     ??HAL_SPI_TransmitReceive_DMA_13: (+1)
   \   00000172   0x2100             MOVS     R1,#+0
   \   00000174   0x6481             STR      R1,[R0, #+72]
   1559              } 
   1560              
   1561              /* Enable the Tx DMA channel */
   1562              HAL_DMA_Start_IT(hspi->hdmatx, (uint32_t)hspi->pTxBuffPtr, (uint32_t)&hspi->Instance->DR, hspi->TxXferCount);
   \                     ??HAL_SPI_TransmitReceive_DMA_14: (+1)
   \   00000176   0x8FE3             LDRH     R3,[R4, #+62]
   \   00000178   0x6820             LDR      R0,[R4, #+0]
   \   0000017A   0xF100 0x020C      ADD      R2,R0,#+12
   \   0000017E   0x6BA1             LDR      R1,[R4, #+56]
   \   00000180   0x6928             LDR      R0,[R5, #+16]
   \   00000182   0x.... 0x....      BL       HAL_DMA_Start_IT
   1563          
   1564              /* Process Unlocked */
   1565              __HAL_UNLOCK(hspi);
   \   00000186   0x2000             MOVS     R0,#+0
   \   00000188   0x7628             STRB     R0,[R5, #+24]
   1566                  
   1567              /* Check if the SPI is already enabled */ 
   1568              if((hspi->Instance->CR1 &SPI_CR1_SPE) != SPI_CR1_SPE)
   \   0000018A   0x6820             LDR      R0,[R4, #+0]
   \   0000018C   0x6801             LDR      R1,[R0, #+0]
   \   0000018E   0x0649             LSLS     R1,R1,#+25
   \   00000190   0xD403             BMI.N    ??HAL_SPI_TransmitReceive_DMA_15
   1569              {
   1570                /* Enable SPI peripheral */    
   1571                __HAL_SPI_ENABLE(hspi);
   \   00000192   0x6801             LDR      R1,[R0, #+0]
   \   00000194   0xF041 0x0140      ORR      R1,R1,#0x40
   \   00000198   0x6001             STR      R1,[R0, #+0]
   1572              }
   1573              
   1574              /* Enable Tx DMA Request */  
   1575              hspi->Instance->CR2 |= SPI_CR2_TXDMAEN;
   \                     ??HAL_SPI_TransmitReceive_DMA_15: (+1)
   \   0000019A   0x6820             LDR      R0,[R4, #+0]
   \   0000019C   0x6841             LDR      R1,[R0, #+4]
   \   0000019E   0xF041 0x0102      ORR      R1,R1,#0x2
   \   000001A2   0x6041             STR      R1,[R0, #+4]
   1576                  
   1577              return HAL_OK;
   \   000001A4   0x2000             MOVS     R0,#+0
   \   000001A6   0xBD70             POP      {R4-R6,PC}
   1578            }
   1579            else
   1580            {
   1581              return HAL_BUSY;
   \                     ??HAL_SPI_TransmitReceive_DMA_1: (+1)
   \   000001A8   0x2002             MOVS     R0,#+2
   \   000001AA   0xBD70             POP      {R4-R6,PC}       ;; return
   1582            }
   1583          }
   1584          
   1585          /**
   1586            * @brief Pauses the DMA Transfer.
   1587            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   1588            *               the configuration information for the specified SPI module.
   1589            * @retval HAL status
   1590            */

   \                                 In section .text, align 2, keep-with-next
   1591          HAL_StatusTypeDef HAL_SPI_DMAPause(SPI_HandleTypeDef *hspi)
   1592          {
   1593            /* Process Locked */
   1594            __HAL_LOCK(hspi);
   \                     HAL_SPI_DMAPause: (+1)
   \   00000000   0xF890 0x105C      LDRB     R1,[R0, #+92]
   \   00000004   0x2901             CMP      R1,#+1
   \   00000006   0xD101             BNE.N    ??HAL_SPI_DMAPause_0
   \   00000008   0x2002             MOVS     R0,#+2
   \   0000000A   0x4770             BX       LR
   \                     ??HAL_SPI_DMAPause_0: (+1)
   \   0000000C   0x2101             MOVS     R1,#+1
   \   0000000E   0xF880 0x105C      STRB     R1,[R0, #+92]
   1595          
   1596            /* Disable the SPI DMA Tx & Rx requests */
   1597            CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);
   \   00000012   0x6801             LDR      R1,[R0, #+0]
   \   00000014   0x684A             LDR      R2,[R1, #+4]
   \   00000016   0x0892             LSRS     R2,R2,#+2
   \   00000018   0x0092             LSLS     R2,R2,#+2
   \   0000001A   0x604A             STR      R2,[R1, #+4]
   1598          
   1599            /* Process Unlocked */
   1600            __HAL_UNLOCK(hspi);
   \   0000001C   0x2100             MOVS     R1,#+0
   \   0000001E   0xF880 0x105C      STRB     R1,[R0, #+92]
   1601          
   1602            return HAL_OK;
   \   00000022   0x4608             MOV      R0,R1
   \   00000024   0x4770             BX       LR               ;; return
   1603          }
   1604          
   1605          /**
   1606            * @brief Resumes the DMA Transfer.
   1607            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   1608            *               the configuration information for the specified SPI module.
   1609            * @retval HAL status
   1610            */

   \                                 In section .text, align 2, keep-with-next
   1611          HAL_StatusTypeDef HAL_SPI_DMAResume(SPI_HandleTypeDef *hspi)
   1612          {
   1613            /* Process Locked */
   1614            __HAL_LOCK(hspi);
   \                     HAL_SPI_DMAResume: (+1)
   \   00000000   0xF890 0x105C      LDRB     R1,[R0, #+92]
   \   00000004   0x2901             CMP      R1,#+1
   \   00000006   0xD101             BNE.N    ??HAL_SPI_DMAResume_0
   \   00000008   0x2002             MOVS     R0,#+2
   \   0000000A   0x4770             BX       LR
   \                     ??HAL_SPI_DMAResume_0: (+1)
   \   0000000C   0x2101             MOVS     R1,#+1
   \   0000000E   0xF880 0x105C      STRB     R1,[R0, #+92]
   1615          
   1616            /* Enable the SPI DMA Tx & Rx requests */
   1617            SET_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);
   \   00000012   0x6801             LDR      R1,[R0, #+0]
   \   00000014   0x684A             LDR      R2,[R1, #+4]
   \   00000016   0xF042 0x0203      ORR      R2,R2,#0x3
   \   0000001A   0x604A             STR      R2,[R1, #+4]
   1618          
   1619            /* Process Unlocked */
   1620            __HAL_UNLOCK(hspi);
   \   0000001C   0x2100             MOVS     R1,#+0
   \   0000001E   0xF880 0x105C      STRB     R1,[R0, #+92]
   1621          
   1622            return HAL_OK;
   \   00000022   0x4608             MOV      R0,R1
   \   00000024   0x4770             BX       LR               ;; return
   1623          }
   1624          
   1625          /**
   1626            * @brief Stops the DMA Transfer.
   1627            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   1628            *               the configuration information for the specified SPI module.
   1629            * @retval HAL status
   1630            */

   \                                 In section .text, align 2, keep-with-next
   1631          HAL_StatusTypeDef HAL_SPI_DMAStop(SPI_HandleTypeDef *hspi)
   1632          {
   \                     HAL_SPI_DMAStop: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   1633            /* The Lock is not implemented on this API to allow the user application
   1634               to call the HAL SPI API under callbacks HAL_SPI_TxCpltCallback() or HAL_SPI_RxCpltCallback() or HAL_SPI_TxRxCpltCallback():
   1635               when calling HAL_DMA_Abort() API the DMA TX/RX Transfer complete interrupt is generated
   1636               and the correspond call back is executed HAL_SPI_TxCpltCallback() or HAL_SPI_RxCpltCallback() or HAL_SPI_TxRxCpltCallback()
   1637               */
   1638            
   1639            /* Abort the SPI DMA tx Stream */
   1640            if(hspi->hdmatx != NULL)
   \   00000004   0x6D60             LDR      R0,[R4, #+84]
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD001             BEQ.N    ??HAL_SPI_DMAStop_0
   1641            {
   1642              HAL_DMA_Abort(hspi->hdmatx);
   \   0000000A   0x.... 0x....      BL       HAL_DMA_Abort
   1643            }
   1644            /* Abort the SPI DMA rx Stream */
   1645            if(hspi->hdmarx != NULL)
   \                     ??HAL_SPI_DMAStop_0: (+1)
   \   0000000E   0x6DA0             LDR      R0,[R4, #+88]
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD001             BEQ.N    ??HAL_SPI_DMAStop_1
   1646            {
   1647              HAL_DMA_Abort(hspi->hdmarx);
   \   00000014   0x.... 0x....      BL       HAL_DMA_Abort
   1648            }
   1649          
   1650            /* Disable the SPI DMA Tx & Rx requests */
   1651            CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);
   \                     ??HAL_SPI_DMAStop_1: (+1)
   \   00000018   0x6820             LDR      R0,[R4, #+0]
   \   0000001A   0x6841             LDR      R1,[R0, #+4]
   \   0000001C   0x0889             LSRS     R1,R1,#+2
   \   0000001E   0x0089             LSLS     R1,R1,#+2
   \   00000020   0x6041             STR      R1,[R0, #+4]
   1652            hspi->State = HAL_SPI_STATE_READY;
   \   00000022   0x2001             MOVS     R0,#+1
   \   00000024   0xF884 0x005D      STRB     R0,[R4, #+93]
   1653            return HAL_OK;
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0xBD10             POP      {R4,PC}          ;; return
   1654          }
   1655          
   1656          /**
   1657            * @brief  This function handles SPI interrupt request.
   1658            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   1659            *               the configuration information for the specified SPI module.
   1660            * @retval None
   1661            */

   \                                 In section .text, align 2, keep-with-next
   1662          void HAL_SPI_IRQHandler(SPI_HandleTypeDef *hspi)
   1663          {
   \                     HAL_SPI_IRQHandler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1664            /* SPI in mode Receiver ----------------------------------------------------*/
   1665            if((__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_OVR) == RESET) &&
   1666               (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_RXNE) != RESET) && (__HAL_SPI_GET_IT_SOURCE(hspi, SPI_IT_RXNE) != RESET))
   \   00000002   0x6801             LDR      R1,[R0, #+0]
   \   00000004   0x688A             LDR      R2,[R1, #+8]
   \   00000006   0x0652             LSLS     R2,R2,#+25
   \   00000008   0xD409             BMI.N    ??HAL_SPI_IRQHandler_0
   \   0000000A   0x688A             LDR      R2,[R1, #+8]
   \   0000000C   0x07D2             LSLS     R2,R2,#+31
   \   0000000E   0xD506             BPL.N    ??HAL_SPI_IRQHandler_0
   \   00000010   0x684A             LDR      R2,[R1, #+4]
   \   00000012   0x0652             LSLS     R2,R2,#+25
   \   00000014   0xD503             BPL.N    ??HAL_SPI_IRQHandler_0
   1667            {
   1668              hspi->RxISR(hspi);
   \   00000016   0x6CC1             LDR      R1,[R0, #+76]
   \   00000018   0xE8BD 0x4004      POP      {R2,LR}
   \   0000001C   0x4708             BX       R1
   1669              return;
   1670            }
   1671            
   1672            /* SPI in mode Transmitter ---------------------------------------------------*/
   1673            if((__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE) != RESET) && (__HAL_SPI_GET_IT_SOURCE(hspi, SPI_IT_TXE) != RESET))
   \                     ??HAL_SPI_IRQHandler_0: (+1)
   \   0000001E   0x688A             LDR      R2,[R1, #+8]
   \   00000020   0x0792             LSLS     R2,R2,#+30
   \   00000022   0xD506             BPL.N    ??HAL_SPI_IRQHandler_1
   \   00000024   0x684A             LDR      R2,[R1, #+4]
   \   00000026   0x0612             LSLS     R2,R2,#+24
   \   00000028   0xD503             BPL.N    ??HAL_SPI_IRQHandler_1
   1674            {   
   1675              hspi->TxISR(hspi);
   \   0000002A   0x6D01             LDR      R1,[R0, #+80]
   \   0000002C   0xE8BD 0x4004      POP      {R2,LR}
   \   00000030   0x4708             BX       R1
   1676              return;
   1677            }
   1678            
   1679            /* SPI in ERROR Treatment ---------------------------------------------------*/
   1680            if((hspi->Instance->SR & (SPI_FLAG_MODF | SPI_FLAG_OVR | SPI_FLAG_FRE)) != RESET)  
   \                     ??HAL_SPI_IRQHandler_1: (+1)
   \   00000032   0x688A             LDR      R2,[R1, #+8]
   \   00000034   0xF412 0x7FB0      TST      R2,#0x160
   \   00000038   0xD036             BEQ.N    ??HAL_SPI_IRQHandler_2
   1681            {
   1682              /* SPI Overrun error interrupt occurred -------------------------------------*/
   1683              if(__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_OVR) != RESET) 
   \   0000003A   0x6889             LDR      R1,[R1, #+8]
   \   0000003C   0x0649             LSLS     R1,R1,#+25
   \   0000003E   0xD50D             BPL.N    ??HAL_SPI_IRQHandler_3
   1684              {
   1685                if(hspi->State != HAL_SPI_STATE_BUSY_TX)
   \   00000040   0xF890 0x105D      LDRB     R1,[R0, #+93]
   \   00000044   0x2903             CMP      R1,#+3
   \   00000046   0xD02F             BEQ.N    ??HAL_SPI_IRQHandler_2
   1686                {
   1687                  hspi->ErrorCode |= HAL_SPI_ERROR_OVR;
   \   00000048   0x6E01             LDR      R1,[R0, #+96]
   \   0000004A   0xF041 0x0104      ORR      R1,R1,#0x4
   \   0000004E   0x6601             STR      R1,[R0, #+96]
   1688                  __HAL_SPI_CLEAR_OVRFLAG(hspi);
   \   00000050   0x6801             LDR      R1,[R0, #+0]
   \   00000052   0x68CA             LDR      R2,[R1, #+12]
   \   00000054   0x9200             STR      R2,[SP, #+0]
   \   00000056   0x6889             LDR      R1,[R1, #+8]
   \   00000058   0x9100             STR      R1,[SP, #+0]
   \   0000005A   0x9900             LDR      R1,[SP, #+0]
   1689                }
   1690                else
   1691                {
   1692                  return;
   1693                }
   1694              }
   1695              
   1696              /* SPI Mode Fault error interrupt occurred -------------------------------------*/
   1697              if(__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_MODF) != RESET)
   \                     ??HAL_SPI_IRQHandler_3: (+1)
   \   0000005C   0x6801             LDR      R1,[R0, #+0]
   \   0000005E   0x6889             LDR      R1,[R1, #+8]
   \   00000060   0x0689             LSLS     R1,R1,#+26
   \   00000062   0xD50B             BPL.N    ??HAL_SPI_IRQHandler_4
   1698              { 
   1699                hspi->ErrorCode |= HAL_SPI_ERROR_MODF;
   \   00000064   0x6E01             LDR      R1,[R0, #+96]
   \   00000066   0xF041 0x0101      ORR      R1,R1,#0x1
   \   0000006A   0x6601             STR      R1,[R0, #+96]
   1700                __HAL_SPI_CLEAR_MODFFLAG(hspi);
   \   0000006C   0x6801             LDR      R1,[R0, #+0]
   \   0000006E   0x688A             LDR      R2,[R1, #+8]
   \   00000070   0x9200             STR      R2,[SP, #+0]
   \   00000072   0x680A             LDR      R2,[R1, #+0]
   \   00000074   0xF022 0x0240      BIC      R2,R2,#0x40
   \   00000078   0x600A             STR      R2,[R1, #+0]
   \   0000007A   0x9900             LDR      R1,[SP, #+0]
   1701              }
   1702              
   1703              /* SPI Frame error interrupt occurred ----------------------------------------*/
   1704              if(__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_FRE) != RESET)
   \                     ??HAL_SPI_IRQHandler_4: (+1)
   \   0000007C   0x6801             LDR      R1,[R0, #+0]
   \   0000007E   0x6889             LDR      R1,[R1, #+8]
   \   00000080   0x05C9             LSLS     R1,R1,#+23
   \   00000082   0xD507             BPL.N    ??HAL_SPI_IRQHandler_5
   1705              { 
   1706                hspi->ErrorCode |= HAL_SPI_ERROR_FRE;
   \   00000084   0x6E01             LDR      R1,[R0, #+96]
   \   00000086   0xF041 0x0108      ORR      R1,R1,#0x8
   \   0000008A   0x6601             STR      R1,[R0, #+96]
   1707                __HAL_SPI_CLEAR_FREFLAG(hspi);
   \   0000008C   0x6801             LDR      R1,[R0, #+0]
   \   0000008E   0x6889             LDR      R1,[R1, #+8]
   \   00000090   0x9100             STR      R1,[SP, #+0]
   \   00000092   0x9900             LDR      R1,[SP, #+0]
   1708              }
   1709              
   1710              __HAL_SPI_DISABLE_IT(hspi, SPI_IT_RXNE | SPI_IT_TXE | SPI_IT_ERR);
   \                     ??HAL_SPI_IRQHandler_5: (+1)
   \   00000094   0x6801             LDR      R1,[R0, #+0]
   \   00000096   0x684A             LDR      R2,[R1, #+4]
   \   00000098   0xF022 0x02E0      BIC      R2,R2,#0xE0
   \   0000009C   0x604A             STR      R2,[R1, #+4]
   1711              hspi->State = HAL_SPI_STATE_READY;
   \   0000009E   0x2101             MOVS     R1,#+1
   \   000000A0   0xF880 0x105D      STRB     R1,[R0, #+93]
   1712              HAL_SPI_ErrorCallback(hspi);
   \   000000A4   0x.... 0x....      BL       HAL_SPI_ErrorCallback
   1713              
   1714              return;
   1715            }
   1716          }
   \                     ??HAL_SPI_IRQHandler_2: (+1)
   \   000000A8   0xBD01             POP      {R0,PC}          ;; return
   1717          
   1718          /**
   1719            * @brief Tx Transfer completed callback
   1720            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   1721            *               the configuration information for SPI module.
   1722            * @retval None
   1723            */

   \                                 In section .text, align 2, keep-with-next
   1724          __weak void HAL_SPI_TxCpltCallback(SPI_HandleTypeDef *hspi)
   1725          {
   1726            /* NOTE : This function should not be modified, when the callback is needed,
   1727                      the HAL_SPI_TxCpltCallback should be implemented in the user file
   1728             */
   1729          }
   \                     HAL_SPI_TxCpltCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1730          
   1731          /**
   1732            * @brief Rx Transfer completed callbacks
   1733            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   1734            *               the configuration information for SPI module.
   1735            * @retval None
   1736            */

   \                                 In section .text, align 2, keep-with-next
   1737          __weak void HAL_SPI_RxCpltCallback(SPI_HandleTypeDef *hspi)
   1738          {
   1739            /* NOTE : This function should not be modified, when the callback is needed,
   1740                      the HAL_SPI_RxCpltCallback should be implemented in the user file
   1741             */
   1742          }
   \                     HAL_SPI_RxCpltCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1743          
   1744          /**
   1745            * @brief Tx and Rx Transfer completed callback
   1746            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   1747            *               the configuration information for SPI module.
   1748            * @retval None
   1749            */

   \                                 In section .text, align 2, keep-with-next
   1750          __weak void HAL_SPI_TxRxCpltCallback(SPI_HandleTypeDef *hspi)
   1751          {
   1752            /* NOTE : This function should not be modified, when the callback is needed,
   1753                      the HAL_SPI_TxRxCpltCallback should be implemented in the user file
   1754             */
   1755          }
   \                     HAL_SPI_TxRxCpltCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1756          
   1757          /**
   1758            * @brief Tx Half Transfer completed callback
   1759            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   1760            *               the configuration information for SPI module.
   1761            * @retval None
   1762            */

   \                                 In section .text, align 2, keep-with-next
   1763          __weak void HAL_SPI_TxHalfCpltCallback(SPI_HandleTypeDef *hspi)
   1764          {
   1765            /* NOTE : This function should not be modified, when the callback is needed,
   1766                      the HAL_SPI_TxHalfCpltCallback should be implemented in the user file
   1767             */
   1768          }
   \                     HAL_SPI_TxHalfCpltCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1769          
   1770          /**
   1771            * @brief Rx Half Transfer completed callback
   1772            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   1773            *               the configuration information for SPI module.
   1774            * @retval None
   1775            */

   \                                 In section .text, align 2, keep-with-next
   1776          __weak void HAL_SPI_RxHalfCpltCallback(SPI_HandleTypeDef *hspi)
   1777          {
   1778            /* NOTE : This function should not be modified, when the callback is needed,
   1779                      the HAL_SPI_RxHalfCpltCallback() should be implemented in the user file
   1780             */
   1781          }
   \                     HAL_SPI_RxHalfCpltCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1782          
   1783          /**
   1784            * @brief Tx and Rx Half Transfer callback
   1785            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   1786            *               the configuration information for SPI module.
   1787            * @retval None
   1788            */

   \                                 In section .text, align 2, keep-with-next
   1789          __weak void HAL_SPI_TxRxHalfCpltCallback(SPI_HandleTypeDef *hspi)
   1790          {
   1791            /* NOTE : This function should not be modified, when the callback is needed,
   1792                      the HAL_SPI_TxRxHalfCpltCallback() should be implemented in the user file
   1793             */
   1794          }
   \                     HAL_SPI_TxRxHalfCpltCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1795          
   1796          /**
   1797            * @brief SPI error callback
   1798            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   1799            *               the configuration information for SPI module.
   1800            * @retval None
   1801            */

   \                                 In section .text, align 2, keep-with-next
   1802           __weak void HAL_SPI_ErrorCallback(SPI_HandleTypeDef *hspi)
   1803          {
   1804            /* NOTE : This function should not be modified, when the callback is needed,
   1805                      the HAL_SPI_ErrorCallback should be implemented in the user file
   1806             */
   1807            /* NOTE : The ErrorCode parameter in the hspi handle is updated by the SPI processes
   1808                      and user can use HAL_SPI_GetError() API to check the latest error occurred
   1809             */
   1810          }
   \                     HAL_SPI_ErrorCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1811          
   1812          /**
   1813            * @}
   1814            */
   1815          
   1816          /**
   1817            * @}
   1818            */
   1819          
   1820          /** @defgroup SPI_Exported_Functions_Group3 Peripheral State and Errors functions
   1821            *  @brief   SPI control functions
   1822            *
   1823          @verbatim
   1824           ===============================================================================
   1825                                ##### Peripheral State and Errors functions #####
   1826           ===============================================================================
   1827              [..]
   1828              This subsection provides a set of functions allowing to control the SPI.
   1829               (+) HAL_SPI_GetState() API can be helpful to check in run-time the state of the SPI peripheral
   1830               (+) HAL_SPI_GetError() check in run-time Errors occurring during communication
   1831          @endverbatim
   1832            * @{
   1833            */
   1834          
   1835          /**
   1836            * @brief  Return the SPI state
   1837            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   1838            *               the configuration information for SPI module.
   1839            * @retval SPI state
   1840            */

   \                                 In section .text, align 2, keep-with-next
   1841          HAL_SPI_StateTypeDef HAL_SPI_GetState(SPI_HandleTypeDef *hspi)
   1842          {
   1843            return hspi->State;
   \                     HAL_SPI_GetState: (+1)
   \   00000000   0xF890 0x005D      LDRB     R0,[R0, #+93]
   \   00000004   0x4770             BX       LR               ;; return
   1844          }
   1845          
   1846          /**
   1847            * @brief  Return the SPI error code
   1848            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   1849            *               the configuration information for SPI module.
   1850            * @retval SPI error code in bitmap format
   1851            */

   \                                 In section .text, align 2, keep-with-next
   1852          uint32_t HAL_SPI_GetError(SPI_HandleTypeDef *hspi)
   1853          {
   1854            return hspi->ErrorCode;
   \                     HAL_SPI_GetError: (+1)
   \   00000000   0x6E00             LDR      R0,[R0, #+96]
   \   00000002   0x4770             BX       LR               ;; return
   1855          }
   1856          
   1857          /**
   1858            * @}
   1859            */
   1860          
   1861          /**
   1862            * @}
   1863            */
   1864          
   1865          /** @defgroup SPI_Private_Functions SPI Private Functions
   1866            * @{
   1867            */
   1868          
   1869          /**
   1870            * @brief DMA SPI transmit process complete callback
   1871            * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
   1872            *               the configuration information for the specified DMA module.
   1873            * @retval None
   1874            */

   \                                 In section .text, align 4, keep-with-next
   1875          static void SPI_DMATransmitCplt(DMA_HandleTypeDef *hdma)
   1876          {
   \                     SPI_DMATransmitCplt: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   \   00000002   0x4601             MOV      R1,R0
   1877            SPI_HandleTypeDef* hspi = ( SPI_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   \   00000004   0x6B88             LDR      R0,[R1, #+56]
   1878          
   1879            /* DMA Normal Mode */
   1880            if((hdma->Instance->CR & DMA_SxCR_CIRC) == 0)
   \   00000006   0x6809             LDR      R1,[R1, #+0]
   \   00000008   0x6809             LDR      R1,[R1, #+0]
   \   0000000A   0x05C9             LSLS     R1,R1,#+23
   \   0000000C   0xD418             BMI.N    ??SPI_DMATransmitCplt_0
   1881            {
   1882              /* Disable Tx DMA Request */
   1883              CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN);
   \   0000000E   0x6801             LDR      R1,[R0, #+0]
   \   00000010   0x684A             LDR      R2,[R1, #+4]
   \   00000012   0xF022 0x0202      BIC      R2,R2,#0x2
   \   00000016   0x604A             STR      R2,[R1, #+4]
   1884          
   1885              /* Clear OVERUN flag in 2 Lines communication mode because received data is not read */
   1886              if(hspi->Init.Direction == SPI_DIRECTION_2LINES)
   \   00000018   0x6881             LDR      R1,[R0, #+8]
   \   0000001A   0x2900             CMP      R1,#+0
   \   0000001C   0xD105             BNE.N    ??SPI_DMATransmitCplt_1
   1887              {
   1888                __HAL_SPI_CLEAR_OVRFLAG(hspi);
   \   0000001E   0x6801             LDR      R1,[R0, #+0]
   \   00000020   0x68CA             LDR      R2,[R1, #+12]
   \   00000022   0x9200             STR      R2,[SP, #+0]
   \   00000024   0x6889             LDR      R1,[R1, #+8]
   \   00000026   0x9100             STR      R1,[SP, #+0]
   \   00000028   0x9900             LDR      R1,[SP, #+0]
   1889              }
   1890          
   1891              hspi->TxXferCount = 0;
   \                     ??SPI_DMATransmitCplt_1: (+1)
   \   0000002A   0x2100             MOVS     R1,#+0
   \   0000002C   0x87C1             STRH     R1,[R0, #+62]
   1892              hspi->State = HAL_SPI_STATE_READY;
   \   0000002E   0x2101             MOVS     R1,#+1
   \   00000030   0xF880 0x105D      STRB     R1,[R0, #+93]
   1893          
   1894              if(hspi->ErrorCode != HAL_SPI_ERROR_NONE)
   \   00000034   0x6E01             LDR      R1,[R0, #+96]
   \   00000036   0x2900             CMP      R1,#+0
   \   00000038   0xD002             BEQ.N    ??SPI_DMATransmitCplt_0
   1895              {
   1896                HAL_SPI_ErrorCallback(hspi);
   \   0000003A   0x.... 0x....      BL       HAL_SPI_ErrorCallback
   1897                return;
   \   0000003E   0xBD01             POP      {R0,PC}
   1898              }
   1899            }
   1900            HAL_SPI_TxCpltCallback(hspi);
   \                     ??SPI_DMATransmitCplt_0: (+1)
   \   00000040   0x.... 0x....      BL       HAL_SPI_TxCpltCallback
   1901          }
   \   00000044   0xBD01             POP      {R0,PC}          ;; return
   1902          
   1903          /**
   1904            * @brief DMA SPI receive process complete callback
   1905            * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
   1906            *               the configuration information for the specified DMA module.
   1907            * @retval None
   1908            */

   \                                 In section .text, align 4, keep-with-next
   1909          static void SPI_DMAReceiveCplt(DMA_HandleTypeDef *hdma)
   1910          {
   \                     SPI_DMAReceiveCplt: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   1911            __IO uint16_t tmpreg;
   1912            SPI_HandleTypeDef* hspi = ( SPI_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   \   00000004   0x6B84             LDR      R4,[R0, #+56]
   1913            
   1914            /* DMA Normal mode */
   1915            if((hdma->Instance->CR & DMA_SxCR_CIRC) == 0)
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0x6800             LDR      R0,[R0, #+0]
   \   0000000A   0x05C0             LSLS     R0,R0,#+23
   \   0000000C   0xD461             BMI.N    ??SPI_DMAReceiveCplt_0
   1916            {  
   1917              /* CRC handling */
   1918              if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   \   0000000E   0x6AA0             LDR      R0,[R4, #+40]
   \   00000010   0xF5B0 0x5F00      CMP      R0,#+8192
   \   00000014   0xD130             BNE.N    ??SPI_DMAReceiveCplt_1
   1919              {
   1920                /* Wait until TXE flag */
   1921                if(SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_RXNE, SPI_FLAG_RXNE, SPI_DEFAULT_TIMEOUT) != HAL_OK)
   \   00000016   0x2332             MOVS     R3,#+50
   \   00000018   0x2201             MOVS     R2,#+1
   \   0000001A   0x4611             MOV      R1,R2
   \   0000001C   0x4620             MOV      R0,R4
   \   0000001E   0x.... 0x....      BL       SPI_WaitFlagStateUntilTimeout
   \   00000022   0x2800             CMP      R0,#+0
   \   00000024   0xD003             BEQ.N    ??SPI_DMAReceiveCplt_2
   1922                {
   1923                  /* Error on the CRC reception */
   1924                  hspi->ErrorCode|= HAL_SPI_ERROR_CRC;      
   \   00000026   0x6E20             LDR      R0,[R4, #+96]
   \   00000028   0xF040 0x0002      ORR      R0,R0,#0x2
   \   0000002C   0x6620             STR      R0,[R4, #+96]
   1925                }
   1926                if(hspi->Init.DataSize > SPI_DATASIZE_8BIT)
   \                     ??SPI_DMAReceiveCplt_2: (+1)
   \   0000002E   0x6820             LDR      R0,[R4, #+0]
   \   00000030   0x68E1             LDR      R1,[R4, #+12]
   \   00000032   0xF5B1 0x6FE0      CMP      R1,#+1792
   \   00000036   0xD905             BLS.N    ??SPI_DMAReceiveCplt_3
   1927                {        
   1928                  tmpreg = hspi->Instance->DR;
   \   00000038   0x68C0             LDR      R0,[R0, #+12]
   \   0000003A   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   1929                  UNUSED(tmpreg); /* To avoid GCC warning */
   \   0000003E   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   00000042   0xE019             B.N      ??SPI_DMAReceiveCplt_1
   1930                }
   1931                else
   1932                {
   1933                  tmpreg = *(__IO uint8_t *)&hspi->Instance->DR;
   \                     ??SPI_DMAReceiveCplt_3: (+1)
   \   00000044   0x7B00             LDRB     R0,[R0, #+12]
   \   00000046   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   1934                  UNUSED(tmpreg); /* To avoid GCC warning */
   \   0000004A   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   1935                  
   1936                  if(hspi->Init.CRCLength == SPI_CRC_LENGTH_16BIT)
   \   0000004E   0x6B20             LDR      R0,[R4, #+48]
   \   00000050   0x2802             CMP      R0,#+2
   \   00000052   0xD111             BNE.N    ??SPI_DMAReceiveCplt_1
   1937                  {
   1938                    if(SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_RXNE, SPI_FLAG_RXNE, SPI_DEFAULT_TIMEOUT) != HAL_OK)
   \   00000054   0x2332             MOVS     R3,#+50
   \   00000056   0x2201             MOVS     R2,#+1
   \   00000058   0x4611             MOV      R1,R2
   \   0000005A   0x4620             MOV      R0,R4
   \   0000005C   0x.... 0x....      BL       SPI_WaitFlagStateUntilTimeout
   \   00000060   0x2800             CMP      R0,#+0
   \   00000062   0xD003             BEQ.N    ??SPI_DMAReceiveCplt_4
   1939                    {
   1940                      /* Error on the CRC reception */
   1941                      hspi->ErrorCode|= HAL_SPI_ERROR_CRC;      
   \   00000064   0x6E20             LDR      R0,[R4, #+96]
   \   00000066   0xF040 0x0002      ORR      R0,R0,#0x2
   \   0000006A   0x6620             STR      R0,[R4, #+96]
   1942                    }
   1943                    tmpreg = *(__IO uint8_t *)&hspi->Instance->DR;
   \                     ??SPI_DMAReceiveCplt_4: (+1)
   \   0000006C   0x6820             LDR      R0,[R4, #+0]
   \   0000006E   0x7B00             LDRB     R0,[R0, #+12]
   \   00000070   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   1944                    UNUSED(tmpreg); /* To avoid GCC warning */
   \   00000074   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   1945                  }
   1946                }  
   1947              }
   1948              
   1949              /* Disable Rx DMA Request */
   1950              hspi->Instance->CR2 &= (uint32_t)(~SPI_CR2_RXDMAEN);
   \                     ??SPI_DMAReceiveCplt_1: (+1)
   \   00000078   0x6820             LDR      R0,[R4, #+0]
   \   0000007A   0x6841             LDR      R1,[R0, #+4]
   \   0000007C   0x0849             LSRS     R1,R1,#+1
   \   0000007E   0x0049             LSLS     R1,R1,#+1
   \   00000080   0x6041             STR      R1,[R0, #+4]
   1951              /* Disable Tx DMA Request (done by default to handle the case master rx direction 2 lines) */
   1952              hspi->Instance->CR2 &= (uint32_t)(~SPI_CR2_TXDMAEN);
   \   00000082   0x6820             LDR      R0,[R4, #+0]
   \   00000084   0x6841             LDR      R1,[R0, #+4]
   \   00000086   0xF021 0x0102      BIC      R1,R1,#0x2
   \   0000008A   0x6041             STR      R1,[R0, #+4]
   1953              
   1954              /* Check the end of the transaction */
   1955              SPI_EndRxTransaction(hspi,SPI_DEFAULT_TIMEOUT);
   \   0000008C   0x2132             MOVS     R1,#+50
   \   0000008E   0x4620             MOV      R0,R4
   \   00000090   0x.... 0x....      BL       SPI_EndRxTransaction
   1956              
   1957              hspi->RxXferCount = 0;
   \   00000094   0xF104 0x0046      ADD      R0,R4,#+70
   \   00000098   0x2100             MOVS     R1,#+0
   \   0000009A   0x8001             STRH     R1,[R0, #+0]
   1958              hspi->State = HAL_SPI_STATE_READY;
   \   0000009C   0x2101             MOVS     R1,#+1
   \   0000009E   0x75C1             STRB     R1,[R0, #+23]
   1959              
   1960              /* Check if CRC error occurred */
   1961              if(__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_CRCERR) != RESET)
   \   000000A0   0x6E20             LDR      R0,[R4, #+96]
   \   000000A2   0x6821             LDR      R1,[R4, #+0]
   \   000000A4   0x6889             LDR      R1,[R1, #+8]
   \   000000A6   0x06C9             LSLS     R1,R1,#+27
   \   000000A8   0xD50A             BPL.N    ??SPI_DMAReceiveCplt_5
   1962              {
   1963                hspi->ErrorCode|= HAL_SPI_ERROR_CRC;
   \   000000AA   0xF040 0x0002      ORR      R0,R0,#0x2
   \   000000AE   0x6620             STR      R0,[R4, #+96]
   1964                __HAL_SPI_CLEAR_CRCERRFLAG(hspi);
   \   000000B0   0xF64F 0x70EF      MOVW     R0,#+65519
   \   000000B4   0x6821             LDR      R1,[R4, #+0]
   \   000000B6   0x6088             STR      R0,[R1, #+8]
   1965                HAL_SPI_RxCpltCallback(hspi);
   \   000000B8   0x4620             MOV      R0,R4
   \   000000BA   0x.... 0x....      BL       HAL_SPI_RxCpltCallback
   \   000000BE   0xBD13             POP      {R0,R1,R4,PC}
   1966              }
   1967              else
   1968              {
   1969                if(hspi->ErrorCode == HAL_SPI_ERROR_NONE)
   \                     ??SPI_DMAReceiveCplt_5: (+1)
   \   000000C0   0x2800             CMP      R0,#+0
   \   000000C2   0x4620             MOV      R0,R4
   \   000000C4   0xD102             BNE.N    ??SPI_DMAReceiveCplt_6
   1970                {
   1971                  HAL_SPI_RxCpltCallback(hspi);
   \   000000C6   0x.... 0x....      BL       HAL_SPI_RxCpltCallback
   \   000000CA   0xBD13             POP      {R0,R1,R4,PC}
   1972                }
   1973                else
   1974                {
   1975                  HAL_SPI_ErrorCallback(hspi); 
   \                     ??SPI_DMAReceiveCplt_6: (+1)
   \   000000CC   0x.... 0x....      BL       HAL_SPI_ErrorCallback
   \   000000D0   0xBD13             POP      {R0,R1,R4,PC}
   1976                }
   1977              }
   1978            }
   1979            else
   1980            {
   1981              HAL_SPI_RxCpltCallback(hspi);
   \                     ??SPI_DMAReceiveCplt_0: (+1)
   \   000000D2   0x4620             MOV      R0,R4
   \   000000D4   0x.... 0x....      BL       HAL_SPI_RxCpltCallback
   1982            }
   1983          }
   \   000000D8   0xBD13             POP      {R0,R1,R4,PC}    ;; return
   1984          
   1985          /**
   1986            * @brief DMA SPI transmit receive process complete callback
   1987            * @param  hdma : pointer to a DMA_HandleTypeDef structure that contains
   1988            *               the configuration information for the specified DMA module.
   1989            * @retval None
   1990            */

   \                                 In section .text, align 4, keep-with-next
   1991          static void SPI_DMATransmitReceiveCplt(DMA_HandleTypeDef *hdma)
   1992          {
   \                     SPI_DMATransmitReceiveCplt: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   1993            __IO int16_t tmpreg;
   1994            SPI_HandleTypeDef* hspi = ( SPI_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   \   00000004   0x6B84             LDR      R4,[R0, #+56]
   1995            
   1996            /* CRC handling */
   1997            if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   \   00000006   0x6AA0             LDR      R0,[R4, #+40]
   \   00000008   0xF5B0 0x5F00      CMP      R0,#+8192
   \   0000000C   0xD12F             BNE.N    ??SPI_DMATransmitReceiveCplt_0
   1998            {
   1999              if((hspi->Init.DataSize == SPI_DATASIZE_8BIT) && (hspi->Init.CRCLength == SPI_CRC_LENGTH_8BIT))
   \   0000000E   0x68E0             LDR      R0,[R4, #+12]
   \   00000010   0xF5B0 0x6FE0      CMP      R0,#+1792
   \   00000014   0xD117             BNE.N    ??SPI_DMATransmitReceiveCplt_1
   \   00000016   0x6B20             LDR      R0,[R4, #+48]
   \   00000018   0x2801             CMP      R0,#+1
   \   0000001A   0xD114             BNE.N    ??SPI_DMATransmitReceiveCplt_1
   2000              {        
   2001                if(SPI_WaitFifoStateUntilTimeout(hspi, SPI_FLAG_FRLVL, SPI_FRLVL_QUARTER_FULL, SPI_DEFAULT_TIMEOUT) != HAL_OK)
   \   0000001C   0x2332             MOVS     R3,#+50
   \   0000001E   0xF44F 0x7200      MOV      R2,#+512
   \   00000022   0xF44F 0x61C0      MOV      R1,#+1536
   \   00000026   0x4620             MOV      R0,R4
   \   00000028   0x.... 0x....      BL       SPI_WaitFifoStateUntilTimeout
   \   0000002C   0x2800             CMP      R0,#+0
   \   0000002E   0xD003             BEQ.N    ??SPI_DMATransmitReceiveCplt_2
   2002                {
   2003                  /* Error on the CRC reception */
   2004                  hspi->ErrorCode|= HAL_SPI_ERROR_CRC;      
   \   00000030   0x6E20             LDR      R0,[R4, #+96]
   \   00000032   0xF040 0x0002      ORR      R0,R0,#0x2
   \   00000036   0x6620             STR      R0,[R4, #+96]
   2005                }
   2006                tmpreg = *(__IO uint8_t *)&hspi->Instance->DR;
   \                     ??SPI_DMATransmitReceiveCplt_2: (+1)
   \   00000038   0x6820             LDR      R0,[R4, #+0]
   \   0000003A   0x7B00             LDRB     R0,[R0, #+12]
   \   0000003C   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   2007                UNUSED(tmpreg); /* To avoid GCC warning */
   \   00000040   0xF9BD 0x0000      LDRSH    R0,[SP, #+0]
   \   00000044   0xE013             B.N      ??SPI_DMATransmitReceiveCplt_0
   2008              }
   2009              else
   2010              {
   2011                if(SPI_WaitFifoStateUntilTimeout(hspi, SPI_FLAG_FRLVL, SPI_FRLVL_HALF_FULL, SPI_DEFAULT_TIMEOUT) != HAL_OK)
   \                     ??SPI_DMATransmitReceiveCplt_1: (+1)
   \   00000046   0x2332             MOVS     R3,#+50
   \   00000048   0xF44F 0x6280      MOV      R2,#+1024
   \   0000004C   0xF44F 0x61C0      MOV      R1,#+1536
   \   00000050   0x4620             MOV      R0,R4
   \   00000052   0x.... 0x....      BL       SPI_WaitFifoStateUntilTimeout
   \   00000056   0x2800             CMP      R0,#+0
   \   00000058   0xD003             BEQ.N    ??SPI_DMATransmitReceiveCplt_3
   2012                {
   2013                  /* Error on the CRC reception */
   2014                  hspi->ErrorCode|= HAL_SPI_ERROR_CRC;      
   \   0000005A   0x6E20             LDR      R0,[R4, #+96]
   \   0000005C   0xF040 0x0002      ORR      R0,R0,#0x2
   \   00000060   0x6620             STR      R0,[R4, #+96]
   2015                }
   2016                tmpreg = hspi->Instance->DR;
   \                     ??SPI_DMATransmitReceiveCplt_3: (+1)
   \   00000062   0x6820             LDR      R0,[R4, #+0]
   \   00000064   0x68C0             LDR      R0,[R0, #+12]
   \   00000066   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   2017                UNUSED(tmpreg); /* To avoid GCC warning */
   \   0000006A   0xF9BD 0x0000      LDRSH    R0,[SP, #+0]
   2018              }
   2019            }  
   2020            
   2021            /* Check the end of the transaction */
   2022            SPI_EndRxTxTransaction(hspi,SPI_DEFAULT_TIMEOUT);
   \                     ??SPI_DMATransmitReceiveCplt_0: (+1)
   \   0000006E   0x2132             MOVS     R1,#+50
   \   00000070   0x4620             MOV      R0,R4
   \   00000072   0x.... 0x....      BL       SPI_EndRxTxTransaction
   2023            
   2024            /* Disable Tx DMA Request */
   2025            CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN);
   \   00000076   0x6820             LDR      R0,[R4, #+0]
   \   00000078   0x6841             LDR      R1,[R0, #+4]
   \   0000007A   0xF021 0x0102      BIC      R1,R1,#0x2
   \   0000007E   0x6041             STR      R1,[R0, #+4]
   2026            
   2027            /* Disable Rx DMA Request */
   2028            CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_RXDMAEN);
   \   00000080   0x6820             LDR      R0,[R4, #+0]
   \   00000082   0x6841             LDR      R1,[R0, #+4]
   \   00000084   0x0849             LSRS     R1,R1,#+1
   \   00000086   0x0049             LSLS     R1,R1,#+1
   \   00000088   0x6041             STR      R1,[R0, #+4]
   2029             
   2030            hspi->TxXferCount = 0;
   \   0000008A   0x2000             MOVS     R0,#+0
   \   0000008C   0x87E0             STRH     R0,[R4, #+62]
   2031            hspi->RxXferCount = 0;
   \   0000008E   0xF104 0x0046      ADD      R0,R4,#+70
   \   00000092   0x2100             MOVS     R1,#+0
   \   00000094   0x8001             STRH     R1,[R0, #+0]
   2032            hspi->State = HAL_SPI_STATE_READY;
   \   00000096   0x2101             MOVS     R1,#+1
   \   00000098   0x75C1             STRB     R1,[R0, #+23]
   2033            
   2034            /* Check if CRC error occurred */
   2035            if(__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_CRCERR) != RESET)
   \   0000009A   0x6820             LDR      R0,[R4, #+0]
   \   0000009C   0x6880             LDR      R0,[R0, #+8]
   \   0000009E   0x06C0             LSLS     R0,R0,#+27
   \   000000A0   0xD509             BPL.N    ??SPI_DMATransmitReceiveCplt_4
   2036            {
   2037              hspi->ErrorCode = HAL_SPI_ERROR_CRC;
   \   000000A2   0x2002             MOVS     R0,#+2
   \   000000A4   0x6620             STR      R0,[R4, #+96]
   2038              __HAL_SPI_CLEAR_CRCERRFLAG(hspi);
   \   000000A6   0xF64F 0x70EF      MOVW     R0,#+65519
   \   000000AA   0x6821             LDR      R1,[R4, #+0]
   \   000000AC   0x6088             STR      R0,[R1, #+8]
   2039              HAL_SPI_ErrorCallback(hspi);
   \   000000AE   0x4620             MOV      R0,R4
   \   000000B0   0x.... 0x....      BL       HAL_SPI_ErrorCallback
   \   000000B4   0xBD13             POP      {R0,R1,R4,PC}
   2040            }
   2041            else
   2042            {     
   2043              if(hspi->ErrorCode == HAL_SPI_ERROR_NONE)
   \                     ??SPI_DMATransmitReceiveCplt_4: (+1)
   \   000000B6   0x6E20             LDR      R0,[R4, #+96]
   \   000000B8   0x2800             CMP      R0,#+0
   \   000000BA   0x4620             MOV      R0,R4
   \   000000BC   0xD102             BNE.N    ??SPI_DMATransmitReceiveCplt_5
   2044              {
   2045                HAL_SPI_TxRxCpltCallback(hspi);
   \   000000BE   0x.... 0x....      BL       HAL_SPI_TxRxCpltCallback
   \   000000C2   0xBD13             POP      {R0,R1,R4,PC}
   2046              }
   2047              else
   2048              {
   2049                HAL_SPI_ErrorCallback(hspi);
   \                     ??SPI_DMATransmitReceiveCplt_5: (+1)
   \   000000C4   0x.... 0x....      BL       HAL_SPI_ErrorCallback
   2050              }
   2051            }
   2052          }
   \   000000C8   0xBD13             POP      {R0,R1,R4,PC}    ;; return
   2053          
   2054          /**
   2055            * @brief DMA SPI half transmit process complete callback
   2056            * @param  hdma : pointer to a DMA_HandleTypeDef structure that contains
   2057            *               the configuration information for the specified DMA module.
   2058            * @retval None
   2059            */

   \                                 In section .text, align 4, keep-with-next
   2060          static void SPI_DMAHalfTransmitCplt(DMA_HandleTypeDef *hdma)
   2061          {
   \                     SPI_DMAHalfTransmitCplt: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   2062            SPI_HandleTypeDef* hspi = ( SPI_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   2063          
   2064            HAL_SPI_TxHalfCpltCallback(hspi);
   \   00000002   0x6B80             LDR      R0,[R0, #+56]
   \   00000004   0x.... 0x....      BL       HAL_SPI_TxHalfCpltCallback
   2065          }
   \   00000008   0xBD01             POP      {R0,PC}          ;; return
   2066          
   2067          /**
   2068            * @brief DMA SPI half receive process complete callback
   2069            * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
   2070            *               the configuration information for the specified DMA module.
   2071            * @retval None
   2072            */

   \                                 In section .text, align 4, keep-with-next
   2073          static void SPI_DMAHalfReceiveCplt(DMA_HandleTypeDef *hdma)
   2074          {
   \                     SPI_DMAHalfReceiveCplt: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   2075            SPI_HandleTypeDef* hspi = ( SPI_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   2076          
   2077            HAL_SPI_RxHalfCpltCallback(hspi);
   \   00000002   0x6B80             LDR      R0,[R0, #+56]
   \   00000004   0x.... 0x....      BL       HAL_SPI_RxHalfCpltCallback
   2078          }
   \   00000008   0xBD01             POP      {R0,PC}          ;; return
   2079          
   2080          /**
   2081            * @brief DMA SPI Half transmit receive process complete callback
   2082            * @param  hdma : pointer to a DMA_HandleTypeDef structure that contains
   2083            *               the configuration information for the specified DMA module.
   2084            * @retval None
   2085            */

   \                                 In section .text, align 4, keep-with-next
   2086          static void SPI_DMAHalfTransmitReceiveCplt(DMA_HandleTypeDef *hdma)
   2087          {
   \                     SPI_DMAHalfTransmitReceiveCplt: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   2088            SPI_HandleTypeDef* hspi = ( SPI_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   2089          
   2090            HAL_SPI_TxRxHalfCpltCallback(hspi);
   \   00000002   0x6B80             LDR      R0,[R0, #+56]
   \   00000004   0x.... 0x....      BL       HAL_SPI_TxRxHalfCpltCallback
   2091          }
   \   00000008   0xBD01             POP      {R0,PC}          ;; return
   2092          
   2093          /**
   2094            * @brief DMA SPI communication error callback
   2095            * @param  hdma : pointer to a DMA_HandleTypeDef structure that contains
   2096            *               the configuration information for the specified DMA module.
   2097            * @retval None
   2098            */

   \                                 In section .text, align 4, keep-with-next
   2099          static void SPI_DMAError(DMA_HandleTypeDef *hdma)
   2100          {
   \                     SPI_DMAError: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   2101            SPI_HandleTypeDef* hspi = ( SPI_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   \   00000002   0x6B80             LDR      R0,[R0, #+56]
   2102          
   2103            /* Stop the disable DMA transfer on SPI side */
   2104            CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);
   \   00000004   0x6801             LDR      R1,[R0, #+0]
   \   00000006   0x684A             LDR      R2,[R1, #+4]
   \   00000008   0x0892             LSRS     R2,R2,#+2
   \   0000000A   0x0092             LSLS     R2,R2,#+2
   \   0000000C   0x604A             STR      R2,[R1, #+4]
   2105          
   2106            hspi->ErrorCode|= HAL_SPI_ERROR_DMA;
   \   0000000E   0x6E01             LDR      R1,[R0, #+96]
   \   00000010   0xF041 0x0110      ORR      R1,R1,#0x10
   \   00000014   0x6601             STR      R1,[R0, #+96]
   2107            hspi->State = HAL_SPI_STATE_READY;
   \   00000016   0x2101             MOVS     R1,#+1
   \   00000018   0xF880 0x105D      STRB     R1,[R0, #+93]
   2108            HAL_SPI_ErrorCallback(hspi);
   \   0000001C   0x.... 0x....      BL       HAL_SPI_ErrorCallback
   2109          }
   \   00000020   0xBD01             POP      {R0,PC}          ;; return
   2110          
   2111          /**
   2112            * @brief  Rx Handler for Transmit and Receive in Interrupt mode
   2113            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   2114            *               the configuration information for SPI module.
   2115            * @retval None
   2116            */

   \                                 In section .text, align 4, keep-with-next
   2117          static void SPI_2linesRxISR_8BIT(struct __SPI_HandleTypeDef *hspi)
   2118          {
   2119            /* Receive data in packing mode */
   2120            if(hspi->RxXferCount > 1)
   \                     SPI_2linesRxISR_8BIT: (+1)
   \   00000000   0x6C01             LDR      R1,[R0, #+64]
   \   00000002   0xF8B0 0x2046      LDRH     R2,[R0, #+70]
   \   00000006   0x2A02             CMP      R2,#+2
   \   00000008   0xDB13             BLT.N    ??SPI_2linesRxISR_8BIT_0
   2121            {
   2122              *((uint16_t*)hspi->pRxBuffPtr) = hspi->Instance->DR;
   \   0000000A   0x6802             LDR      R2,[R0, #+0]
   \   0000000C   0x68D2             LDR      R2,[R2, #+12]
   \   0000000E   0x800A             STRH     R2,[R1, #+0]
   2123              hspi->pRxBuffPtr += sizeof(uint16_t);
   \   00000010   0x6C01             LDR      R1,[R0, #+64]
   \   00000012   0x1C89             ADDS     R1,R1,#+2
   \   00000014   0x6401             STR      R1,[R0, #+64]
   2124              hspi->RxXferCount -= 2;
   \   00000016   0xF8B0 0x1046      LDRH     R1,[R0, #+70]
   \   0000001A   0x1E89             SUBS     R1,R1,#+2
   \   0000001C   0xF8A0 0x1046      STRH     R1,[R0, #+70]
   2125              if(hspi->RxXferCount == 1)
   \   00000020   0xB289             UXTH     R1,R1
   \   00000022   0x2901             CMP      R1,#+1
   \   00000024   0xD10F             BNE.N    ??SPI_2linesRxISR_8BIT_1
   2126              {
   2127                /* set fiforxthreshold according the reception data length: 8bit */
   2128                SET_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
   \   00000026   0x6801             LDR      R1,[R0, #+0]
   \   00000028   0x684A             LDR      R2,[R1, #+4]
   \   0000002A   0xF442 0x5280      ORR      R2,R2,#0x1000
   \   0000002E   0x604A             STR      R2,[R1, #+4]
   \   00000030   0xE009             B.N      ??SPI_2linesRxISR_8BIT_1
   2129              }
   2130            }
   2131            /* Receive data in 8 Bit mode */
   2132            else
   2133            {
   2134              *hspi->pRxBuffPtr++ = *((__IO uint8_t *)&hspi->Instance->DR);
   \                     ??SPI_2linesRxISR_8BIT_0: (+1)
   \   00000032   0x1C4A             ADDS     R2,R1,#+1
   \   00000034   0x6402             STR      R2,[R0, #+64]
   \   00000036   0x6802             LDR      R2,[R0, #+0]
   \   00000038   0x7B12             LDRB     R2,[R2, #+12]
   \   0000003A   0x700A             STRB     R2,[R1, #+0]
   2135              hspi->RxXferCount--;
   \   0000003C   0xF8B0 0x1046      LDRH     R1,[R0, #+70]
   \   00000040   0x1E49             SUBS     R1,R1,#+1
   \   00000042   0xF8A0 0x1046      STRH     R1,[R0, #+70]
   2136            }
   2137            
   2138            /* check end of the reception */
   2139            if(hspi->RxXferCount == 0)
   \                     ??SPI_2linesRxISR_8BIT_1: (+1)
   \   00000046   0xF8B0 0x1046      LDRH     R1,[R0, #+70]
   \   0000004A   0x2900             CMP      R1,#+0
   \   0000004C   0xD113             BNE.N    ??SPI_2linesRxISR_8BIT_2
   2140            {
   2141              if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   \   0000004E   0x6801             LDR      R1,[R0, #+0]
   \   00000050   0x6A82             LDR      R2,[R0, #+40]
   \   00000052   0xF5B2 0x5F00      CMP      R2,#+8192
   \   00000056   0x684A             LDR      R2,[R1, #+4]
   \   00000058   0xD106             BNE.N    ??SPI_2linesRxISR_8BIT_3
   2142              {
   2143                SET_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
   \   0000005A   0xF442 0x5280      ORR      R2,R2,#0x1000
   \   0000005E   0x604A             STR      R2,[R1, #+4]
   2144                hspi->RxISR =  SPI_2linesRxISR_8BITCRC;
   \   00000060   0x.... 0x....      ADR.W    R1,SPI_2linesRxISR_8BITCRC
   \   00000064   0x64C1             STR      R1,[R0, #+76]
   2145                return;
   \   00000066   0x4770             BX       LR
   2146              }
   2147                  
   2148              /* Disable RXNE interrupt */
   2149              __HAL_SPI_DISABLE_IT(hspi, SPI_IT_RXNE);
   \                     ??SPI_2linesRxISR_8BIT_3: (+1)
   \   00000068   0xF022 0x0240      BIC      R2,R2,#0x40
   \   0000006C   0x604A             STR      R2,[R1, #+4]
   2150          
   2151              if(hspi->TxXferCount == 0)
   \   0000006E   0x8FC1             LDRH     R1,[R0, #+62]
   \   00000070   0x2900             CMP      R1,#+0
   \   00000072   0xD100             BNE.N    ??SPI_2linesRxISR_8BIT_2
   2152              {
   2153                SPI_CloseRxTx_ISR(hspi);
   \   00000074   0x....             B.N      SPI_CloseRxTx_ISR
   2154              }
   2155            }
   2156          }
   \                     ??SPI_2linesRxISR_8BIT_2: (+1)
   \   00000076   0x4770             BX       LR               ;; return
   2157          
   2158          /**
   2159            * @brief  Rx Handler for Transmit and Receive in Interrupt mode
   2160            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   2161            *               the configuration information for SPI module.
   2162            * @retval None
   2163            */

   \                                 In section .text, align 4, keep-with-next
   2164          static void SPI_2linesRxISR_8BITCRC(struct __SPI_HandleTypeDef *hspi)
   2165          {
   \                     SPI_2linesRxISR_8BITCRC: (+1)
   \   00000000   0xB082             SUB      SP,SP,#+8
   2166            __IO uint8_t tmpreg;
   2167            
   2168            tmpreg = *((__IO uint8_t *)&hspi->Instance->DR);
   \   00000002   0x6801             LDR      R1,[R0, #+0]
   \   00000004   0x7B09             LDRB     R1,[R1, #+12]
   \   00000006   0xF88D 0x1000      STRB     R1,[SP, #+0]
   2169            UNUSED(tmpreg); /* To avoid GCC warning */
   \   0000000A   0xF89D 0x1000      LDRB     R1,[SP, #+0]
   2170          
   2171            hspi->CRCSize--;
   \   0000000E   0x6C81             LDR      R1,[R0, #+72]
   \   00000010   0x1E49             SUBS     R1,R1,#+1
   \   00000012   0x6481             STR      R1,[R0, #+72]
   2172            
   2173            /* check end of the reception */
   2174            if(hspi->CRCSize == 0)
   \   00000014   0xD109             BNE.N    ??SPI_2linesRxISR_8BITCRC_0
   2175            {
   2176              /* Disable RXNE interrupt */
   2177              __HAL_SPI_DISABLE_IT(hspi, SPI_IT_RXNE);
   \   00000016   0x6801             LDR      R1,[R0, #+0]
   \   00000018   0x684A             LDR      R2,[R1, #+4]
   \   0000001A   0xF022 0x0240      BIC      R2,R2,#0x40
   \   0000001E   0x604A             STR      R2,[R1, #+4]
   2178          
   2179              if(hspi->TxXferCount == 0)
   \   00000020   0x8FC1             LDRH     R1,[R0, #+62]
   \   00000022   0x2900             CMP      R1,#+0
   \   00000024   0xD101             BNE.N    ??SPI_2linesRxISR_8BITCRC_0
   2180              {
   2181                SPI_CloseRxTx_ISR(hspi);
   \   00000026   0xB002             ADD      SP,SP,#+8
   \   00000028   0x....             B.N      SPI_CloseRxTx_ISR
   2182              }
   2183            }
   2184          }
   \                     ??SPI_2linesRxISR_8BITCRC_0: (+1)
   \   0000002A   0xB002             ADD      SP,SP,#+8
   \   0000002C   0x4770             BX       LR               ;; return
   2185          
   2186          /**
   2187            * @brief  Tx Handler for Transmit and Receive in Interrupt mode
   2188            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   2189            *               the configuration information for SPI module.
   2190            * @retval None
   2191            */

   \                                 In section .text, align 4, keep-with-next
   2192          static void SPI_2linesTxISR_8BIT(struct __SPI_HandleTypeDef *hspi)
   2193          {
   2194            /* Transmit data in packing Bit mode */
   2195            if(hspi->TxXferCount >= 2)
   \                     SPI_2linesTxISR_8BIT: (+1)
   \   00000000   0x6B81             LDR      R1,[R0, #+56]
   \   00000002   0x8FC2             LDRH     R2,[R0, #+62]
   \   00000004   0x2A02             CMP      R2,#+2
   \   00000006   0xDB09             BLT.N    ??SPI_2linesTxISR_8BIT_0
   2196            {
   2197              hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
   \   00000008   0x8809             LDRH     R1,[R1, #+0]
   \   0000000A   0x6802             LDR      R2,[R0, #+0]
   \   0000000C   0x60D1             STR      R1,[R2, #+12]
   2198              hspi->pTxBuffPtr += sizeof(uint16_t);
   \   0000000E   0x6B81             LDR      R1,[R0, #+56]
   \   00000010   0x1C89             ADDS     R1,R1,#+2
   \   00000012   0x6381             STR      R1,[R0, #+56]
   2199              hspi->TxXferCount -= 2;
   \   00000014   0x8FC1             LDRH     R1,[R0, #+62]
   \   00000016   0x1E89             SUBS     R1,R1,#+2
   \   00000018   0x87C1             STRH     R1,[R0, #+62]
   \   0000001A   0xE007             B.N      ??SPI_2linesTxISR_8BIT_1
   2200            }
   2201            /* Transmit data in 8 Bit mode */
   2202            else
   2203            {        
   2204              *(__IO uint8_t *)&hspi->Instance->DR = (*hspi->pTxBuffPtr++);
   \                     ??SPI_2linesTxISR_8BIT_0: (+1)
   \   0000001C   0x1C4A             ADDS     R2,R1,#+1
   \   0000001E   0x6382             STR      R2,[R0, #+56]
   \   00000020   0x7809             LDRB     R1,[R1, #+0]
   \   00000022   0x6802             LDR      R2,[R0, #+0]
   \   00000024   0x7311             STRB     R1,[R2, #+12]
   2205              hspi->TxXferCount--;
   \   00000026   0x8FC1             LDRH     R1,[R0, #+62]
   \   00000028   0x1E49             SUBS     R1,R1,#+1
   \   0000002A   0x87C1             STRH     R1,[R0, #+62]
   2206            }
   2207            
   2208            /* check the end of the transmission */
   2209            if(hspi->TxXferCount == 0)
   \                     ??SPI_2linesTxISR_8BIT_1: (+1)
   \   0000002C   0x8FC1             LDRH     R1,[R0, #+62]
   \   0000002E   0x2900             CMP      R1,#+0
   \   00000030   0xD112             BNE.N    ??SPI_2linesTxISR_8BIT_2
   2210            {
   2211              if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   \   00000032   0x6A81             LDR      R1,[R0, #+40]
   \   00000034   0xF5B1 0x5F00      CMP      R1,#+8192
   \   00000038   0xD104             BNE.N    ??SPI_2linesTxISR_8BIT_3
   2212              {
   2213                hspi->Instance->CR1 |= SPI_CR1_CRCNEXT;
   \   0000003A   0x6801             LDR      R1,[R0, #+0]
   \   0000003C   0x680A             LDR      R2,[R1, #+0]
   \   0000003E   0xF442 0x5280      ORR      R2,R2,#0x1000
   \   00000042   0x600A             STR      R2,[R1, #+0]
   2214              }
   2215              /* Disable TXE interrupt */
   2216              __HAL_SPI_DISABLE_IT(hspi, SPI_IT_TXE);
   \                     ??SPI_2linesTxISR_8BIT_3: (+1)
   \   00000044   0x6801             LDR      R1,[R0, #+0]
   \   00000046   0x684A             LDR      R2,[R1, #+4]
   \   00000048   0xF022 0x0280      BIC      R2,R2,#0x80
   \   0000004C   0x604A             STR      R2,[R1, #+4]
   2217              
   2218              if(hspi->RxXferCount == 0)
   \   0000004E   0xF8B0 0x1046      LDRH     R1,[R0, #+70]
   \   00000052   0x2900             CMP      R1,#+0
   \   00000054   0xD100             BNE.N    ??SPI_2linesTxISR_8BIT_2
   2219              { 
   2220                SPI_CloseRxTx_ISR(hspi);
   \   00000056   0x....             B.N      SPI_CloseRxTx_ISR
   2221              }
   2222            }
   2223          }
   \                     ??SPI_2linesTxISR_8BIT_2: (+1)
   \   00000058   0x4770             BX       LR               ;; return
   2224          
   2225          /**
   2226            * @brief  Rx 16Bit Handler for Transmit and Receive in Interrupt mode
   2227            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   2228            *               the configuration information for SPI module.
   2229            * @retval None
   2230            */

   \                                 In section .text, align 4, keep-with-next
   2231          static void SPI_2linesRxISR_16BIT(struct __SPI_HandleTypeDef *hspi)
   2232          {
   2233            /* Receive data in 16 Bit mode */
   2234            *((uint16_t*)hspi->pRxBuffPtr) = hspi->Instance->DR;
   \                     SPI_2linesRxISR_16BIT: (+1)
   \   00000000   0x6801             LDR      R1,[R0, #+0]
   \   00000002   0x68C9             LDR      R1,[R1, #+12]
   \   00000004   0x6C02             LDR      R2,[R0, #+64]
   \   00000006   0x8011             STRH     R1,[R2, #+0]
   2235            hspi->pRxBuffPtr += sizeof(uint16_t);
   \   00000008   0x6C01             LDR      R1,[R0, #+64]
   \   0000000A   0x1C89             ADDS     R1,R1,#+2
   \   0000000C   0x6401             STR      R1,[R0, #+64]
   2236            hspi->RxXferCount--;
   \   0000000E   0xF8B0 0x1046      LDRH     R1,[R0, #+70]
   \   00000012   0x1E49             SUBS     R1,R1,#+1
   \   00000014   0xF8A0 0x1046      STRH     R1,[R0, #+70]
   2237          
   2238            if(hspi->RxXferCount == 0)
   \   00000018   0xB289             UXTH     R1,R1
   \   0000001A   0x2900             CMP      R1,#+0
   \   0000001C   0xD110             BNE.N    ??SPI_2linesRxISR_16BIT_0
   2239            {
   2240              if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   \   0000001E   0x6A81             LDR      R1,[R0, #+40]
   \   00000020   0xF5B1 0x5F00      CMP      R1,#+8192
   \   00000024   0xD103             BNE.N    ??SPI_2linesRxISR_16BIT_1
   2241              {
   2242                hspi->RxISR =  SPI_2linesRxISR_16BITCRC;
   \   00000026   0x.... 0x....      ADR.W    R1,SPI_2linesRxISR_16BITCRC
   \   0000002A   0x64C1             STR      R1,[R0, #+76]
   2243                return;
   \   0000002C   0x4770             BX       LR
   2244              }
   2245              
   2246              /* Disable RXNE interrupt */
   2247              __HAL_SPI_DISABLE_IT(hspi, SPI_IT_RXNE);
   \                     ??SPI_2linesRxISR_16BIT_1: (+1)
   \   0000002E   0x6801             LDR      R1,[R0, #+0]
   \   00000030   0x684A             LDR      R2,[R1, #+4]
   \   00000032   0xF022 0x0240      BIC      R2,R2,#0x40
   \   00000036   0x604A             STR      R2,[R1, #+4]
   2248          
   2249              if(hspi->TxXferCount == 0)
   \   00000038   0x8FC1             LDRH     R1,[R0, #+62]
   \   0000003A   0x2900             CMP      R1,#+0
   \   0000003C   0xD100             BNE.N    ??SPI_2linesRxISR_16BIT_0
   2250              {
   2251                SPI_CloseRxTx_ISR(hspi);
   \   0000003E   0x....             B.N      SPI_CloseRxTx_ISR
   2252              }
   2253            }
   2254          }
   \                     ??SPI_2linesRxISR_16BIT_0: (+1)
   \   00000040   0x4770             BX       LR               ;; return
   2255          
   2256          /**
   2257            * @brief  Manage the CRC 16bit receive for Transmit and Receive in Interrupt mode
   2258            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   2259            *               the configuration information for SPI module.
   2260            * @retval None
   2261            */

   \                                 In section .text, align 4, keep-with-next
   2262          static void SPI_2linesRxISR_16BITCRC(struct __SPI_HandleTypeDef *hspi)
   2263          {
   \                     SPI_2linesRxISR_16BITCRC: (+1)
   \   00000000   0xB082             SUB      SP,SP,#+8
   2264            /* Receive data in 16 Bit mode */
   2265            __IO uint16_t tmpreg = hspi->Instance->DR;
   \   00000002   0x6801             LDR      R1,[R0, #+0]
   \   00000004   0x68CA             LDR      R2,[R1, #+12]
   \   00000006   0xF8AD 0x2000      STRH     R2,[SP, #+0]
   2266            UNUSED(tmpreg); /* To avoid GCC warning */
   \   0000000A   0xF8BD 0x2000      LDRH     R2,[SP, #+0]
   2267          
   2268            /* Disable RXNE interrupt */
   2269            __HAL_SPI_DISABLE_IT(hspi, SPI_IT_RXNE);
   \   0000000E   0x684A             LDR      R2,[R1, #+4]
   \   00000010   0xF022 0x0240      BIC      R2,R2,#0x40
   \   00000014   0x604A             STR      R2,[R1, #+4]
   2270          
   2271            SPI_CloseRxTx_ISR(hspi);
   \   00000016   0xB002             ADD      SP,SP,#+8
   \   00000018   0x....             B.N      SPI_CloseRxTx_ISR
   2272          }
   2273          
   2274          /**
   2275            * @brief  Tx Handler for Transmit and Receive in Interrupt mode
   2276            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   2277            *               the configuration information for SPI module.
   2278            * @retval None
   2279            */

   \                                 In section .text, align 4, keep-with-next
   2280          static void SPI_2linesTxISR_16BIT(struct __SPI_HandleTypeDef *hspi)
   2281          {
   2282            /* Transmit data in 16 Bit mode */
   2283            hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
   \                     SPI_2linesTxISR_16BIT: (+1)
   \   00000000   0x6B81             LDR      R1,[R0, #+56]
   \   00000002   0x8809             LDRH     R1,[R1, #+0]
   \   00000004   0x6802             LDR      R2,[R0, #+0]
   \   00000006   0x60D1             STR      R1,[R2, #+12]
   2284            hspi->pTxBuffPtr += sizeof(uint16_t);
   \   00000008   0x6B81             LDR      R1,[R0, #+56]
   \   0000000A   0x1C89             ADDS     R1,R1,#+2
   \   0000000C   0x6381             STR      R1,[R0, #+56]
   2285            hspi->TxXferCount--;
   \   0000000E   0x8FC1             LDRH     R1,[R0, #+62]
   \   00000010   0x1E49             SUBS     R1,R1,#+1
   \   00000012   0x87C1             STRH     R1,[R0, #+62]
   2286            
   2287            /* Enable CRC Transmission */
   2288            if(hspi->TxXferCount == 0)
   \   00000014   0xB289             UXTH     R1,R1
   \   00000016   0x2900             CMP      R1,#+0
   \   00000018   0xD112             BNE.N    ??SPI_2linesTxISR_16BIT_0
   2289            {
   2290              if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   \   0000001A   0x6A81             LDR      R1,[R0, #+40]
   \   0000001C   0xF5B1 0x5F00      CMP      R1,#+8192
   \   00000020   0xD104             BNE.N    ??SPI_2linesTxISR_16BIT_1
   2291              {
   2292                hspi->Instance->CR1 |= SPI_CR1_CRCNEXT;
   \   00000022   0x6801             LDR      R1,[R0, #+0]
   \   00000024   0x680A             LDR      R2,[R1, #+0]
   \   00000026   0xF442 0x5280      ORR      R2,R2,#0x1000
   \   0000002A   0x600A             STR      R2,[R1, #+0]
   2293              }
   2294              /* Disable TXE interrupt */
   2295              __HAL_SPI_DISABLE_IT(hspi, SPI_IT_TXE);
   \                     ??SPI_2linesTxISR_16BIT_1: (+1)
   \   0000002C   0x6801             LDR      R1,[R0, #+0]
   \   0000002E   0x684A             LDR      R2,[R1, #+4]
   \   00000030   0xF022 0x0280      BIC      R2,R2,#0x80
   \   00000034   0x604A             STR      R2,[R1, #+4]
   2296          
   2297              if(hspi->RxXferCount == 0)
   \   00000036   0xF8B0 0x1046      LDRH     R1,[R0, #+70]
   \   0000003A   0x2900             CMP      R1,#+0
   \   0000003C   0xD100             BNE.N    ??SPI_2linesTxISR_16BIT_0
   2298              {
   2299                SPI_CloseRxTx_ISR(hspi);
   \   0000003E   0x....             B.N      SPI_CloseRxTx_ISR
   2300              }
   2301            }
   2302          }
   \                     ??SPI_2linesTxISR_16BIT_0: (+1)
   \   00000040   0x4770             BX       LR               ;; return
   2303          
   2304          /**
   2305            * @brief  Manage the CRC receive in Interrupt context
   2306            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   2307            *               the configuration information for SPI module.
   2308            * @retval None
   2309            */

   \                                 In section .text, align 2, keep-with-next
   2310          static void SPI_RxISR_8BITCRC(struct __SPI_HandleTypeDef *hspi)
   2311          {
   \                     SPI_RxISR_8BITCRC: (+1)
   \   00000000   0xB082             SUB      SP,SP,#+8
   2312            __IO uint8_t tmpreg;
   2313            tmpreg = *((__IO uint8_t*)&hspi->Instance->DR);
   \   00000002   0x6801             LDR      R1,[R0, #+0]
   \   00000004   0x7B09             LDRB     R1,[R1, #+12]
   \   00000006   0xF88D 0x1000      STRB     R1,[SP, #+0]
   2314            UNUSED(tmpreg); /* To avoid GCC warning */
   \   0000000A   0xF89D 0x1000      LDRB     R1,[SP, #+0]
   2315          
   2316            hspi->CRCSize--;
   \   0000000E   0x6C81             LDR      R1,[R0, #+72]
   \   00000010   0x1E49             SUBS     R1,R1,#+1
   \   00000012   0x6481             STR      R1,[R0, #+72]
   2317            
   2318            if(hspi->CRCSize == 0)
   \   00000014   0xD101             BNE.N    ??SPI_RxISR_8BITCRC_0
   2319            { 
   2320              SPI_CloseRx_ISR(hspi);
   \   00000016   0xB002             ADD      SP,SP,#+8
   \   00000018   0x....             B.N      SPI_CloseRx_ISR
   2321            }
   2322          }
   \                     ??SPI_RxISR_8BITCRC_0: (+1)
   \   0000001A   0xB002             ADD      SP,SP,#+8
   \   0000001C   0x4770             BX       LR               ;; return
   2323          
   2324          /**
   2325            * @brief  Manage the receive in Interrupt context
   2326            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   2327            *               the configuration information for SPI module.
   2328            * @retval None
   2329            */

   \                                 In section .text, align 4, keep-with-next
   2330          static void SPI_RxISR_8BIT(struct __SPI_HandleTypeDef *hspi)
   2331          {
   2332            *hspi->pRxBuffPtr++ = (*(__IO uint8_t *)&hspi->Instance->DR);
   \                     SPI_RxISR_8BIT: (+1)
   \   00000000   0x6C01             LDR      R1,[R0, #+64]
   \   00000002   0x1C4A             ADDS     R2,R1,#+1
   \   00000004   0x6402             STR      R2,[R0, #+64]
   \   00000006   0x6802             LDR      R2,[R0, #+0]
   \   00000008   0x7B12             LDRB     R2,[R2, #+12]
   \   0000000A   0x700A             STRB     R2,[R1, #+0]
   2333            hspi->RxXferCount--;
   \   0000000C   0xF8B0 0x1046      LDRH     R1,[R0, #+70]
   \   00000010   0x1E49             SUBS     R1,R1,#+1
   \   00000012   0xF8A0 0x1046      STRH     R1,[R0, #+70]
   2334          
   2335            /* Enable CRC Transmission */
   2336            if((hspi->RxXferCount == 1) && (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE))
   \   00000016   0xB289             UXTH     R1,R1
   \   00000018   0x2901             CMP      R1,#+1
   \   0000001A   0xD108             BNE.N    ??SPI_RxISR_8BIT_0
   \   0000001C   0x6A81             LDR      R1,[R0, #+40]
   \   0000001E   0xF5B1 0x5F00      CMP      R1,#+8192
   \   00000022   0xD104             BNE.N    ??SPI_RxISR_8BIT_0
   2337            {
   2338              hspi->Instance->CR1 |= SPI_CR1_CRCNEXT;
   \   00000024   0x6801             LDR      R1,[R0, #+0]
   \   00000026   0x680A             LDR      R2,[R1, #+0]
   \   00000028   0xF442 0x5280      ORR      R2,R2,#0x1000
   \   0000002C   0x600A             STR      R2,[R1, #+0]
   2339            }
   2340          
   2341            if(hspi->RxXferCount == 0)
   \                     ??SPI_RxISR_8BIT_0: (+1)
   \   0000002E   0xF8B0 0x1046      LDRH     R1,[R0, #+70]
   \   00000032   0x2900             CMP      R1,#+0
   \   00000034   0xD107             BNE.N    ??SPI_RxISR_8BIT_1
   2342            {
   2343              if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   \   00000036   0x6A81             LDR      R1,[R0, #+40]
   \   00000038   0xF5B1 0x5F00      CMP      R1,#+8192
   \   0000003C   0xD102             BNE.N    ??SPI_RxISR_8BIT_2
   2344              {
   2345                hspi->RxISR =  SPI_RxISR_8BITCRC;
   \   0000003E   0x....             LDR.N    R1,??DataTable1
   \   00000040   0x64C1             STR      R1,[R0, #+76]
   2346                return;
   \   00000042   0x4770             BX       LR
   2347              }
   2348              SPI_CloseRx_ISR(hspi);
   \                     ??SPI_RxISR_8BIT_2: (+1)
   \   00000044   0x....             B.N      SPI_CloseRx_ISR
   2349            }
   2350          }
   \                     ??SPI_RxISR_8BIT_1: (+1)
   \   00000046   0x4770             BX       LR               ;; return
   2351          
   2352          /**
   2353            * @brief  Manage the CRC 16bit receive in Interrupt context
   2354            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   2355            *               the configuration information for SPI module.
   2356            * @retval None
   2357            */

   \                                 In section .text, align 2, keep-with-next
   2358          static void SPI_RxISR_16BITCRC(struct __SPI_HandleTypeDef *hspi)
   2359          {
   \                     SPI_RxISR_16BITCRC: (+1)
   \   00000000   0xB082             SUB      SP,SP,#+8
   2360            __IO uint16_t tmpreg;
   2361            
   2362            tmpreg = hspi->Instance->DR;
   \   00000002   0x6801             LDR      R1,[R0, #+0]
   \   00000004   0x68CA             LDR      R2,[R1, #+12]
   \   00000006   0xF8AD 0x2000      STRH     R2,[SP, #+0]
   2363            UNUSED(tmpreg); /* To avoid GCC warning */
   \   0000000A   0xF8BD 0x2000      LDRH     R2,[SP, #+0]
   2364          
   2365            /* Disable RXNE and ERR interrupt */
   2366            __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_RXNE | SPI_IT_ERR));
   \   0000000E   0x684A             LDR      R2,[R1, #+4]
   \   00000010   0xF022 0x0260      BIC      R2,R2,#0x60
   \   00000014   0x604A             STR      R2,[R1, #+4]
   2367            
   2368            SPI_CloseRx_ISR(hspi);
   \   00000016   0xB002             ADD      SP,SP,#+8
   \   00000018   0x....             B.N      SPI_CloseRx_ISR
   2369          }
   2370          
   2371          /**
   2372            * @brief  Manage the 16Bit receive in Interrupt context
   2373            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   2374            *               the configuration information for SPI module.
   2375            * @retval None
   2376            */

   \                                 In section .text, align 4, keep-with-next
   2377          static void SPI_RxISR_16BIT(struct __SPI_HandleTypeDef *hspi)
   2378          {
   2379            *((uint16_t *)hspi->pRxBuffPtr) = hspi->Instance->DR;
   \                     SPI_RxISR_16BIT: (+1)
   \   00000000   0x6801             LDR      R1,[R0, #+0]
   \   00000002   0x68C9             LDR      R1,[R1, #+12]
   \   00000004   0x6C02             LDR      R2,[R0, #+64]
   \   00000006   0x8011             STRH     R1,[R2, #+0]
   2380            hspi->pRxBuffPtr += sizeof(uint16_t);
   \   00000008   0x6C01             LDR      R1,[R0, #+64]
   \   0000000A   0x1C89             ADDS     R1,R1,#+2
   \   0000000C   0x6401             STR      R1,[R0, #+64]
   2381            hspi->RxXferCount--;
   \   0000000E   0xF8B0 0x1046      LDRH     R1,[R0, #+70]
   \   00000012   0x1E49             SUBS     R1,R1,#+1
   \   00000014   0xF8A0 0x1046      STRH     R1,[R0, #+70]
   2382            
   2383            /* Enable CRC Transmission */
   2384            if((hspi->RxXferCount == 1) && (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE))
   \   00000018   0xB289             UXTH     R1,R1
   \   0000001A   0x2901             CMP      R1,#+1
   \   0000001C   0xD108             BNE.N    ??SPI_RxISR_16BIT_0
   \   0000001E   0x6A81             LDR      R1,[R0, #+40]
   \   00000020   0xF5B1 0x5F00      CMP      R1,#+8192
   \   00000024   0xD104             BNE.N    ??SPI_RxISR_16BIT_0
   2385            {
   2386              hspi->Instance->CR1 |= SPI_CR1_CRCNEXT;
   \   00000026   0x6801             LDR      R1,[R0, #+0]
   \   00000028   0x680A             LDR      R2,[R1, #+0]
   \   0000002A   0xF442 0x5280      ORR      R2,R2,#0x1000
   \   0000002E   0x600A             STR      R2,[R1, #+0]
   2387            }
   2388            
   2389            if(hspi->RxXferCount == 0)
   \                     ??SPI_RxISR_16BIT_0: (+1)
   \   00000030   0xF8B0 0x1046      LDRH     R1,[R0, #+70]
   \   00000034   0x2900             CMP      R1,#+0
   \   00000036   0xD107             BNE.N    ??SPI_RxISR_16BIT_1
   2390            {    
   2391              if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   \   00000038   0x6A81             LDR      R1,[R0, #+40]
   \   0000003A   0xF5B1 0x5F00      CMP      R1,#+8192
   \   0000003E   0xD102             BNE.N    ??SPI_RxISR_16BIT_2
   2392              {
   2393                hspi->RxISR = SPI_RxISR_16BITCRC;
   \   00000040   0x....             LDR.N    R1,??DataTable1_1
   \   00000042   0x64C1             STR      R1,[R0, #+76]
   2394                return;
   \   00000044   0x4770             BX       LR
   2395              }
   2396              SPI_CloseRx_ISR(hspi);
   \                     ??SPI_RxISR_16BIT_2: (+1)
   \   00000046   0x....             B.N      SPI_CloseRx_ISR
   2397            }
   2398          }
   \                     ??SPI_RxISR_16BIT_1: (+1)
   \   00000048   0x4770             BX       LR               ;; return
   2399          
   2400          /**
   2401            * @brief  Handle the data 8Bit transmit in Interrupt mode
   2402            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   2403            *               the configuration information for SPI module.
   2404            * @retval None
   2405            */

   \                                 In section .text, align 4, keep-with-next
   2406          static void SPI_TxISR_8BIT(struct __SPI_HandleTypeDef *hspi)
   2407          {
   2408            *(__IO uint8_t *)&hspi->Instance->DR = (*hspi->pTxBuffPtr++);
   \                     SPI_TxISR_8BIT: (+1)
   \   00000000   0x6B81             LDR      R1,[R0, #+56]
   \   00000002   0x1C4A             ADDS     R2,R1,#+1
   \   00000004   0x6382             STR      R2,[R0, #+56]
   \   00000006   0x7809             LDRB     R1,[R1, #+0]
   \   00000008   0x6802             LDR      R2,[R0, #+0]
   \   0000000A   0x7311             STRB     R1,[R2, #+12]
   2409            hspi->TxXferCount--;
   \   0000000C   0x8FC1             LDRH     R1,[R0, #+62]
   \   0000000E   0x1E49             SUBS     R1,R1,#+1
   \   00000010   0x87C1             STRH     R1,[R0, #+62]
   2410            
   2411            if(hspi->TxXferCount == 0)
   \   00000012   0xB289             UXTH     R1,R1
   \   00000014   0x2900             CMP      R1,#+0
   \   00000016   0xD109             BNE.N    ??SPI_TxISR_8BIT_0
   2412            {
   2413              if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   \   00000018   0x6A81             LDR      R1,[R0, #+40]
   \   0000001A   0xF5B1 0x5F00      CMP      R1,#+8192
   \   0000001E   0xD104             BNE.N    ??SPI_TxISR_8BIT_1
   2414              {
   2415                /* Enable CRC Transmission */
   2416                hspi->Instance->CR1 |= SPI_CR1_CRCNEXT;
   \   00000020   0x6801             LDR      R1,[R0, #+0]
   \   00000022   0x680A             LDR      R2,[R1, #+0]
   \   00000024   0xF442 0x5280      ORR      R2,R2,#0x1000
   \   00000028   0x600A             STR      R2,[R1, #+0]
   2417              }
   2418              SPI_CloseTx_ISR(hspi);
   \                     ??SPI_TxISR_8BIT_1: (+1)
   \   0000002A   0x....             B.N      SPI_CloseTx_ISR
   2419            }
   2420          }
   \                     ??SPI_TxISR_8BIT_0: (+1)
   \   0000002C   0x4770             BX       LR               ;; return
   2421          
   2422          /**
   2423            * @brief  Handle the data 16Bit transmit in Interrupt mode
   2424            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   2425            *               the configuration information for SPI module.
   2426            * @retval None
   2427            */

   \                                 In section .text, align 4, keep-with-next
   2428          static void SPI_TxISR_16BIT(struct __SPI_HandleTypeDef *hspi)
   2429          { 
   2430            /* Transmit data in 16 Bit mode */
   2431            hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
   \                     SPI_TxISR_16BIT: (+1)
   \   00000000   0x6B81             LDR      R1,[R0, #+56]
   \   00000002   0x8809             LDRH     R1,[R1, #+0]
   \   00000004   0x6802             LDR      R2,[R0, #+0]
   \   00000006   0x60D1             STR      R1,[R2, #+12]
   2432            hspi->pTxBuffPtr += sizeof(uint16_t);
   \   00000008   0x6B81             LDR      R1,[R0, #+56]
   \   0000000A   0x1C89             ADDS     R1,R1,#+2
   \   0000000C   0x6381             STR      R1,[R0, #+56]
   2433            hspi->TxXferCount--;
   \   0000000E   0x8FC1             LDRH     R1,[R0, #+62]
   \   00000010   0x1E49             SUBS     R1,R1,#+1
   \   00000012   0x87C1             STRH     R1,[R0, #+62]
   2434            
   2435            if(hspi->TxXferCount == 0)
   \   00000014   0xB289             UXTH     R1,R1
   \   00000016   0x2900             CMP      R1,#+0
   \   00000018   0xD109             BNE.N    ??SPI_TxISR_16BIT_0
   2436            {
   2437              if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   \   0000001A   0x6A81             LDR      R1,[R0, #+40]
   \   0000001C   0xF5B1 0x5F00      CMP      R1,#+8192
   \   00000020   0xD104             BNE.N    ??SPI_TxISR_16BIT_1
   2438              {
   2439                /* Enable CRC Transmission */
   2440                hspi->Instance->CR1 |= SPI_CR1_CRCNEXT;
   \   00000022   0x6801             LDR      R1,[R0, #+0]
   \   00000024   0x680A             LDR      R2,[R1, #+0]
   \   00000026   0xF442 0x5280      ORR      R2,R2,#0x1000
   \   0000002A   0x600A             STR      R2,[R1, #+0]
   2441              }
   2442              SPI_CloseTx_ISR(hspi);
   \                     ??SPI_TxISR_16BIT_1: (+1)
   \   0000002C   0x....             B.N      SPI_CloseTx_ISR
   2443            }
   2444          }
   \                     ??SPI_TxISR_16BIT_0: (+1)
   \   0000002E   0x4770             BX       LR               ;; return
   2445          
   2446          /**
   2447            * @brief This function handles SPI Communication Timeout.
   2448            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   2449            *               the configuration information for SPI module.
   2450            * @param Flag : SPI flag to check
   2451            * @param State : flag state to check
   2452            * @param Timeout : Timeout duration
   2453            * @retval HAL status
   2454            */

   \                                 In section .text, align 2, keep-with-next
   2455          static HAL_StatusTypeDef SPI_WaitFlagStateUntilTimeout(SPI_HandleTypeDef *hspi, uint32_t Flag, uint32_t State, uint32_t Timeout)
   2456          {
   \                     SPI_WaitFlagStateUntilTimeout: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
   \   00000008   0x4616             MOV      R6,R2
   \   0000000A   0x461F             MOV      R7,R3
   2457            uint32_t tickstart = HAL_GetTick();
   \   0000000C   0x.... 0x....      BL       HAL_GetTick
   \   00000010   0x4680             MOV      R8,R0
   2458          
   2459            while((hspi->Instance->SR & Flag) != State)
   \                     ??SPI_WaitFlagStateUntilTimeout_0: (+1)
   \   00000012   0x6820             LDR      R0,[R4, #+0]
   \   00000014   0x6880             LDR      R0,[R0, #+8]
   \   00000016   0x4028             ANDS     R0,R5,R0
   \   00000018   0x42B0             CMP      R0,R6
   \   0000001A   0xD036             BEQ.N    ??SPI_WaitFlagStateUntilTimeout_1
   2460            {
   2461              if(Timeout != HAL_MAX_DELAY)
   \   0000001C   0xF117 0x0F01      CMN      R7,#+1
   \   00000020   0xD0F7             BEQ.N    ??SPI_WaitFlagStateUntilTimeout_0
   2462              {
   2463                if((Timeout == 0) || ((HAL_GetTick()-tickstart) >= Timeout))
   \   00000022   0x2F00             CMP      R7,#+0
   \   00000024   0xD005             BEQ.N    ??SPI_WaitFlagStateUntilTimeout_2
   \   00000026   0x.... 0x....      BL       HAL_GetTick
   \   0000002A   0xEBA0 0x0008      SUB      R0,R0,R8
   \   0000002E   0x42B8             CMP      R0,R7
   \   00000030   0xD3EF             BCC.N    ??SPI_WaitFlagStateUntilTimeout_0
   2464                {
   2465                  /* Disable the SPI and reset the CRC: the CRC value should be cleared
   2466                  on both master and slave sides in order to resynchronize the master
   2467                  and slave for their respective CRC calculation */
   2468          
   2469                  /* Disable TXE, RXNE and ERR interrupts for the interrupt process */
   2470                  __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_RXNE | SPI_IT_ERR));
   \                     ??SPI_WaitFlagStateUntilTimeout_2: (+1)
   \   00000032   0x6820             LDR      R0,[R4, #+0]
   \   00000034   0x6841             LDR      R1,[R0, #+4]
   \   00000036   0xF021 0x01E0      BIC      R1,R1,#0xE0
   \   0000003A   0x6041             STR      R1,[R0, #+4]
   2471          
   2472                  if((hspi->Init.Mode == SPI_MODE_MASTER)&&((hspi->Init.Direction == SPI_DIRECTION_1LINE)||(hspi->Init.Direction == SPI_DIRECTION_2LINES_RXONLY)))
   \   0000003C   0x6860             LDR      R0,[R4, #+4]
   \   0000003E   0xF5B0 0x7F82      CMP      R0,#+260
   \   00000042   0xD10B             BNE.N    ??SPI_WaitFlagStateUntilTimeout_3
   \   00000044   0x68A0             LDR      R0,[R4, #+8]
   \   00000046   0xF5B0 0x4F00      CMP      R0,#+32768
   \   0000004A   0xD002             BEQ.N    ??SPI_WaitFlagStateUntilTimeout_4
   \   0000004C   0xF5B0 0x6F80      CMP      R0,#+1024
   \   00000050   0xD104             BNE.N    ??SPI_WaitFlagStateUntilTimeout_3
   2473                  {
   2474                    /* Disable SPI peripheral */
   2475                    __HAL_SPI_DISABLE(hspi);
   \                     ??SPI_WaitFlagStateUntilTimeout_4: (+1)
   \   00000052   0x6820             LDR      R0,[R4, #+0]
   \   00000054   0x6801             LDR      R1,[R0, #+0]
   \   00000056   0xF021 0x0140      BIC      R1,R1,#0x40
   \   0000005A   0x6001             STR      R1,[R0, #+0]
   2476                  }
   2477          
   2478                  /* Reset CRC Calculation */
   2479                  if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   \                     ??SPI_WaitFlagStateUntilTimeout_3: (+1)
   \   0000005C   0x6AA0             LDR      R0,[R4, #+40]
   \   0000005E   0xF5B0 0x5F00      CMP      R0,#+8192
   \   00000062   0xD10A             BNE.N    ??SPI_WaitFlagStateUntilTimeout_5
   2480                  {
   2481                    SPI_RESET_CRC(hspi);
   \   00000064   0x6820             LDR      R0,[R4, #+0]
   \   00000066   0x6801             LDR      R1,[R0, #+0]
   \   00000068   0xF64D 0x72FF      MOVW     R2,#+57343
   \   0000006C   0x4011             ANDS     R1,R2,R1
   \   0000006E   0x6001             STR      R1,[R0, #+0]
   \   00000070   0x6820             LDR      R0,[R4, #+0]
   \   00000072   0x6801             LDR      R1,[R0, #+0]
   \   00000074   0xF441 0x5100      ORR      R1,R1,#0x2000
   \   00000078   0x6001             STR      R1,[R0, #+0]
   2482                  }
   2483                  
   2484                  hspi->State= HAL_SPI_STATE_READY;
   \                     ??SPI_WaitFlagStateUntilTimeout_5: (+1)
   \   0000007A   0xF104 0x005C      ADD      R0,R4,#+92
   \   0000007E   0x2101             MOVS     R1,#+1
   \   00000080   0x7041             STRB     R1,[R0, #+1]
   2485                  
   2486                  /* Process Unlocked */
   2487                  __HAL_UNLOCK(hspi);
   \   00000082   0x2100             MOVS     R1,#+0
   \   00000084   0x7001             STRB     R1,[R0, #+0]
   2488                  
   2489                  return HAL_TIMEOUT;
   \   00000086   0x2003             MOVS     R0,#+3
   \   00000088   0xE000             B.N      ??SPI_WaitFlagStateUntilTimeout_6
   2490                }
   2491              }
   2492            }
   2493            
   2494            return HAL_OK;      
   \                     ??SPI_WaitFlagStateUntilTimeout_1: (+1)
   \   0000008A   0x2000             MOVS     R0,#+0
   \                     ??SPI_WaitFlagStateUntilTimeout_6: (+1)
   \   0000008C   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   2495          }
   2496          
   2497          /**
   2498            * @brief This function handles SPI Communication Timeout.
   2499            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   2500            *               the configuration information for SPI module.
   2501            * @param Fifo : Fifo to check
   2502            * @param State : Fifo state to check
   2503            * @param Timeout : Timeout duration
   2504            * @retval HAL status
   2505            */

   \                                 In section .text, align 2, keep-with-next
   2506          static HAL_StatusTypeDef SPI_WaitFifoStateUntilTimeout(SPI_HandleTypeDef *hspi, uint32_t Fifo, uint32_t State, uint32_t Timeout)
   2507          {
   \                     SPI_WaitFifoStateUntilTimeout: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB082             SUB      SP,SP,#+8
   \   00000006   0x4604             MOV      R4,R0
   \   00000008   0x460D             MOV      R5,R1
   \   0000000A   0x4616             MOV      R6,R2
   \   0000000C   0x461F             MOV      R7,R3
   2508            __IO uint8_t tmpreg;
   2509            uint32_t tickstart = HAL_GetTick();
   \   0000000E   0x.... 0x....      BL       HAL_GetTick
   \   00000012   0x4680             MOV      R8,R0
   2510          
   2511            while((hspi->Instance->SR & Fifo) != State)
   \                     ??SPI_WaitFifoStateUntilTimeout_0: (+1)
   \   00000014   0x6820             LDR      R0,[R4, #+0]
   \   00000016   0x6881             LDR      R1,[R0, #+8]
   \   00000018   0x4029             ANDS     R1,R5,R1
   \   0000001A   0x42B1             CMP      R1,R6
   \   0000001C   0xD040             BEQ.N    ??SPI_WaitFifoStateUntilTimeout_1
   2512            {
   2513              if((Fifo == SPI_SR_FRLVL) && (State == SPI_FRLVL_EMPTY))
   \   0000001E   0xF5B5 0x6FC0      CMP      R5,#+1536
   \   00000022   0xD106             BNE.N    ??SPI_WaitFifoStateUntilTimeout_2
   \   00000024   0x2E00             CMP      R6,#+0
   \   00000026   0xD104             BNE.N    ??SPI_WaitFifoStateUntilTimeout_2
   2514              {
   2515                tmpreg = *((__IO uint8_t*)&hspi->Instance->DR);
   \   00000028   0x7B00             LDRB     R0,[R0, #+12]
   \   0000002A   0xF88D 0x0000      STRB     R0,[SP, #+0]
   2516                UNUSED(tmpreg); /* To avoid GCC warning */
   \   0000002E   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   2517              }
   2518          
   2519              if(Timeout != HAL_MAX_DELAY)
   \                     ??SPI_WaitFifoStateUntilTimeout_2: (+1)
   \   00000032   0xF117 0x0F01      CMN      R7,#+1
   \   00000036   0xD0ED             BEQ.N    ??SPI_WaitFifoStateUntilTimeout_0
   2520              {
   2521                if((Timeout == 0) || ((HAL_GetTick()-tickstart) >= Timeout))
   \   00000038   0x2F00             CMP      R7,#+0
   \   0000003A   0xD005             BEQ.N    ??SPI_WaitFifoStateUntilTimeout_3
   \   0000003C   0x.... 0x....      BL       HAL_GetTick
   \   00000040   0xEBA0 0x0008      SUB      R0,R0,R8
   \   00000044   0x42B8             CMP      R0,R7
   \   00000046   0xD3E5             BCC.N    ??SPI_WaitFifoStateUntilTimeout_0
   2522                {
   2523                  /* Disable the SPI and reset the CRC: the CRC value should be cleared
   2524                            on both master and slave sides in order to resynchronize the master
   2525                           and slave for their respective CRC calculation */
   2526          
   2527                  /* Disable TXE, RXNE and ERR interrupts for the interrupt process */
   2528                  __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_RXNE | SPI_IT_ERR));
   \                     ??SPI_WaitFifoStateUntilTimeout_3: (+1)
   \   00000048   0x6820             LDR      R0,[R4, #+0]
   \   0000004A   0x6841             LDR      R1,[R0, #+4]
   \   0000004C   0xF021 0x01E0      BIC      R1,R1,#0xE0
   \   00000050   0x6041             STR      R1,[R0, #+4]
   2529          
   2530                  if((hspi->Init.Mode == SPI_MODE_MASTER)&&((hspi->Init.Direction == SPI_DIRECTION_1LINE)||(hspi->Init.Direction == SPI_DIRECTION_2LINES_RXONLY)))
   \   00000052   0x6860             LDR      R0,[R4, #+4]
   \   00000054   0xF5B0 0x7F82      CMP      R0,#+260
   \   00000058   0xD10B             BNE.N    ??SPI_WaitFifoStateUntilTimeout_4
   \   0000005A   0x68A0             LDR      R0,[R4, #+8]
   \   0000005C   0xF5B0 0x4F00      CMP      R0,#+32768
   \   00000060   0xD002             BEQ.N    ??SPI_WaitFifoStateUntilTimeout_5
   \   00000062   0xF5B0 0x6F80      CMP      R0,#+1024
   \   00000066   0xD104             BNE.N    ??SPI_WaitFifoStateUntilTimeout_4
   2531                  {
   2532                    /* Disable SPI peripheral */
   2533                    __HAL_SPI_DISABLE(hspi);
   \                     ??SPI_WaitFifoStateUntilTimeout_5: (+1)
   \   00000068   0x6820             LDR      R0,[R4, #+0]
   \   0000006A   0x6801             LDR      R1,[R0, #+0]
   \   0000006C   0xF021 0x0140      BIC      R1,R1,#0x40
   \   00000070   0x6001             STR      R1,[R0, #+0]
   2534                  }
   2535          
   2536                  /* Reset CRC Calculation */
   2537                  if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   \                     ??SPI_WaitFifoStateUntilTimeout_4: (+1)
   \   00000072   0x6AA0             LDR      R0,[R4, #+40]
   \   00000074   0xF5B0 0x5F00      CMP      R0,#+8192
   \   00000078   0xD10A             BNE.N    ??SPI_WaitFifoStateUntilTimeout_6
   2538                  {
   2539                    SPI_RESET_CRC(hspi);
   \   0000007A   0x6820             LDR      R0,[R4, #+0]
   \   0000007C   0x6801             LDR      R1,[R0, #+0]
   \   0000007E   0xF64D 0x72FF      MOVW     R2,#+57343
   \   00000082   0x4011             ANDS     R1,R2,R1
   \   00000084   0x6001             STR      R1,[R0, #+0]
   \   00000086   0x6820             LDR      R0,[R4, #+0]
   \   00000088   0x6801             LDR      R1,[R0, #+0]
   \   0000008A   0xF441 0x5100      ORR      R1,R1,#0x2000
   \   0000008E   0x6001             STR      R1,[R0, #+0]
   2540                  }
   2541          
   2542                  hspi->State = HAL_SPI_STATE_READY;
   \                     ??SPI_WaitFifoStateUntilTimeout_6: (+1)
   \   00000090   0xF104 0x005C      ADD      R0,R4,#+92
   \   00000094   0x2101             MOVS     R1,#+1
   \   00000096   0x7041             STRB     R1,[R0, #+1]
   2543          
   2544                  /* Process Unlocked */
   2545                  __HAL_UNLOCK(hspi);
   \   00000098   0x2100             MOVS     R1,#+0
   \   0000009A   0x7001             STRB     R1,[R0, #+0]
   2546          
   2547                  return HAL_TIMEOUT;
   \   0000009C   0x2003             MOVS     R0,#+3
   \   0000009E   0xE000             B.N      ??SPI_WaitFifoStateUntilTimeout_7
   2548                }
   2549              }
   2550            }
   2551          
   2552            return HAL_OK;
   \                     ??SPI_WaitFifoStateUntilTimeout_1: (+1)
   \   000000A0   0x2000             MOVS     R0,#+0
   \                     ??SPI_WaitFifoStateUntilTimeout_7: (+1)
   \   000000A2   0xE8BD 0x81F6      POP      {R1,R2,R4-R8,PC}  ;; return
   2553          }
   2554          
   2555          /**
   2556            * @brief This function handles the check of the RX transaction complete.
   2557            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   2558            *               the configuration information for SPI module.
   2559            * @param Timeout : Timeout duration
   2560            * @retval None
   2561            */

   \                                 In section .text, align 2, keep-with-next
   2562          static HAL_StatusTypeDef SPI_EndRxTransaction(SPI_HandleTypeDef *hspi,  uint32_t Timeout)
   2563          {
   \                     SPI_EndRxTransaction: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   2564            if((hspi->Init.Mode == SPI_MODE_MASTER)&&((hspi->Init.Direction == SPI_DIRECTION_1LINE)||(hspi->Init.Direction == SPI_DIRECTION_2LINES_RXONLY)))
   \   00000006   0x6860             LDR      R0,[R4, #+4]
   \   00000008   0xF5B0 0x7F82      CMP      R0,#+260
   \   0000000C   0xD10B             BNE.N    ??SPI_EndRxTransaction_0
   \   0000000E   0x68A0             LDR      R0,[R4, #+8]
   \   00000010   0xF5B0 0x4F00      CMP      R0,#+32768
   \   00000014   0xD002             BEQ.N    ??SPI_EndRxTransaction_1
   \   00000016   0xF5B0 0x6F80      CMP      R0,#+1024
   \   0000001A   0xD104             BNE.N    ??SPI_EndRxTransaction_0
   2565            {
   2566              /* Disable SPI peripheral */
   2567              __HAL_SPI_DISABLE(hspi);
   \                     ??SPI_EndRxTransaction_1: (+1)
   \   0000001C   0x6820             LDR      R0,[R4, #+0]
   \   0000001E   0x6801             LDR      R1,[R0, #+0]
   \   00000020   0xF021 0x0140      BIC      R1,R1,#0x40
   \   00000024   0x6001             STR      R1,[R0, #+0]
   2568            }
   2569            if(SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_BSY, RESET, Timeout) != HAL_OK)
   \                     ??SPI_EndRxTransaction_0: (+1)
   \   00000026   0x462B             MOV      R3,R5
   \   00000028   0x2200             MOVS     R2,#+0
   \   0000002A   0x2180             MOVS     R1,#+128
   \   0000002C   0x4620             MOV      R0,R4
   \   0000002E   0x.... 0x....      BL       SPI_WaitFlagStateUntilTimeout
   \   00000032   0x2800             CMP      R0,#+0
   \   00000034   0xD108             BNE.N    ??SPI_EndRxTransaction_2
   2570            {  
   2571              hspi->ErrorCode |= HAL_SPI_ERROR_FLAG;
   2572              return HAL_TIMEOUT;
   2573            }
   2574            if(SPI_WaitFifoStateUntilTimeout(hspi, SPI_FLAG_FRLVL, SPI_FRLVL_EMPTY, Timeout) != HAL_OK) 
   \   00000036   0x462B             MOV      R3,R5
   \   00000038   0x2200             MOVS     R2,#+0
   \   0000003A   0xF44F 0x61C0      MOV      R1,#+1536
   \   0000003E   0x4620             MOV      R0,R4
   \   00000040   0x.... 0x....      BL       SPI_WaitFifoStateUntilTimeout
   \   00000044   0x2800             CMP      R0,#+0
   \   00000046   0xD005             BEQ.N    ??SPI_EndRxTransaction_3
   2575            {
   2576              hspi->ErrorCode |= HAL_SPI_ERROR_FLAG;
   \                     ??SPI_EndRxTransaction_2: (+1)
   \   00000048   0x6E20             LDR      R0,[R4, #+96]
   \   0000004A   0xF040 0x0020      ORR      R0,R0,#0x20
   \   0000004E   0x6620             STR      R0,[R4, #+96]
   2577              return HAL_TIMEOUT;
   \   00000050   0x2003             MOVS     R0,#+3
   \   00000052   0xBD32             POP      {R1,R4,R5,PC}
   2578            }
   2579            
   2580            return HAL_OK;
   \                     ??SPI_EndRxTransaction_3: (+1)
   \   00000054   0x2000             MOVS     R0,#+0
   \   00000056   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   2581          }
   2582            
   2583          /**
   2584            * @brief This function handles the check of the RXTX or TX transaction complete.
   2585            * @param hspi: SPI handle
   2586            * @param Timeout : Timeout duration
   2587            */

   \                                 In section .text, align 2, keep-with-next
   2588          static HAL_StatusTypeDef SPI_EndRxTxTransaction(SPI_HandleTypeDef *hspi, uint32_t Timeout)
   2589          {
   \                     SPI_EndRxTxTransaction: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   2590            /* Procedure to check the transaction complete */
   2591            if(SPI_WaitFifoStateUntilTimeout(hspi, SPI_FLAG_FTLVL, SPI_FTLVL_EMPTY, Timeout) != HAL_OK)
   \   00000006   0x462B             MOV      R3,R5
   \   00000008   0x2200             MOVS     R2,#+0
   \   0000000A   0xF44F 0x51C0      MOV      R1,#+6144
   \   0000000E   0x.... 0x....      BL       SPI_WaitFifoStateUntilTimeout
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD110             BNE.N    ??SPI_EndRxTxTransaction_0
   2592            {
   2593              hspi->ErrorCode |= HAL_SPI_ERROR_FLAG;
   2594              return HAL_TIMEOUT;
   2595            }
   2596            if(SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_BSY, RESET, Timeout) != HAL_OK)
   \   00000016   0x462B             MOV      R3,R5
   \   00000018   0x2200             MOVS     R2,#+0
   \   0000001A   0x2180             MOVS     R1,#+128
   \   0000001C   0x4620             MOV      R0,R4
   \   0000001E   0x.... 0x....      BL       SPI_WaitFlagStateUntilTimeout
   \   00000022   0x2800             CMP      R0,#+0
   \   00000024   0xD108             BNE.N    ??SPI_EndRxTxTransaction_0
   2597            {
   2598              hspi->ErrorCode |= HAL_SPI_ERROR_FLAG;
   2599              return HAL_TIMEOUT;
   2600            }
   2601            if(SPI_WaitFifoStateUntilTimeout(hspi, SPI_FLAG_FRLVL, SPI_FRLVL_EMPTY, Timeout) != HAL_OK)
   \   00000026   0x462B             MOV      R3,R5
   \   00000028   0x2200             MOVS     R2,#+0
   \   0000002A   0xF44F 0x61C0      MOV      R1,#+1536
   \   0000002E   0x4620             MOV      R0,R4
   \   00000030   0x.... 0x....      BL       SPI_WaitFifoStateUntilTimeout
   \   00000034   0x2800             CMP      R0,#+0
   \   00000036   0xD005             BEQ.N    ??SPI_EndRxTxTransaction_1
   2602            {
   2603              hspi->ErrorCode |= HAL_SPI_ERROR_FLAG;
   \                     ??SPI_EndRxTxTransaction_0: (+1)
   \   00000038   0x6E20             LDR      R0,[R4, #+96]
   \   0000003A   0xF040 0x0020      ORR      R0,R0,#0x20
   \   0000003E   0x6620             STR      R0,[R4, #+96]
   2604              return HAL_TIMEOUT;
   \   00000040   0x2003             MOVS     R0,#+3
   \   00000042   0xBD32             POP      {R1,R4,R5,PC}
   2605            }
   2606            return HAL_OK;
   \                     ??SPI_EndRxTxTransaction_1: (+1)
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   2607          }
   2608          
   2609          /**
   2610            * @brief This function handles the close of the RXTX transaction.
   2611            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   2612            *               the configuration information for SPI module.
   2613            * @retval None
   2614            */

   \                                 In section .text, align 2, keep-with-next
   2615          static void SPI_CloseRxTx_ISR(SPI_HandleTypeDef *hspi)
   2616          {
   \                     SPI_CloseRxTx_ISR: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   2617            /* Disable ERR interrupt */
   2618            __HAL_SPI_DISABLE_IT(hspi, SPI_IT_ERR);
   \   00000002   0x6801             LDR      R1,[R0, #+0]
   \   00000004   0x684A             LDR      R2,[R1, #+4]
   \   00000006   0xF022 0x0220      BIC      R2,R2,#0x20
   \   0000000A   0x604A             STR      R2,[R1, #+4]
   2619          
   2620            /* Check if CRC error occurred */
   2621            if(__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_CRCERR) != RESET)
   \   0000000C   0x6801             LDR      R1,[R0, #+0]
   \   0000000E   0x6889             LDR      R1,[R1, #+8]
   \   00000010   0x06C9             LSLS     R1,R1,#+27
   \   00000012   0xD50D             BPL.N    ??SPI_CloseRxTx_ISR_0
   2622            {
   2623              hspi->State = HAL_SPI_STATE_READY;
   \   00000014   0x2101             MOVS     R1,#+1
   \   00000016   0xF880 0x105D      STRB     R1,[R0, #+93]
   2624              hspi->ErrorCode|= HAL_SPI_ERROR_CRC;
   \   0000001A   0x6E01             LDR      R1,[R0, #+96]
   \   0000001C   0xF041 0x0102      ORR      R1,R1,#0x2
   \   00000020   0x6601             STR      R1,[R0, #+96]
   2625              __HAL_SPI_CLEAR_CRCERRFLAG(hspi);
   \   00000022   0xF64F 0x71EF      MOVW     R1,#+65519
   \   00000026   0x6802             LDR      R2,[R0, #+0]
   \   00000028   0x6091             STR      R1,[R2, #+8]
   2626              HAL_SPI_ErrorCallback(hspi);
   \   0000002A   0x.... 0x....      BL       HAL_SPI_ErrorCallback
   \   0000002E   0xBD01             POP      {R0,PC}
   2627            }
   2628            else
   2629            {
   2630              if(hspi->ErrorCode == HAL_SPI_ERROR_NONE)
   \                     ??SPI_CloseRxTx_ISR_0: (+1)
   \   00000030   0x6E01             LDR      R1,[R0, #+96]
   \   00000032   0x2900             CMP      R1,#+0
   \   00000034   0xD10F             BNE.N    ??SPI_CloseRxTx_ISR_1
   2631              {
   2632                if(hspi->State == HAL_SPI_STATE_BUSY_RX)
   \   00000036   0xF890 0x105D      LDRB     R1,[R0, #+93]
   \   0000003A   0x2904             CMP      R1,#+4
   \   0000003C   0xD105             BNE.N    ??SPI_CloseRxTx_ISR_2
   2633                {
   2634                	hspi->State = HAL_SPI_STATE_READY;
   \   0000003E   0x2101             MOVS     R1,#+1
   \   00000040   0xF880 0x105D      STRB     R1,[R0, #+93]
   2635                  HAL_SPI_RxCpltCallback(hspi);
   \   00000044   0x.... 0x....      BL       HAL_SPI_RxCpltCallback
   \   00000048   0xBD01             POP      {R0,PC}
   2636                }
   2637                else
   2638                {
   2639                	hspi->State = HAL_SPI_STATE_READY;
   \                     ??SPI_CloseRxTx_ISR_2: (+1)
   \   0000004A   0x2101             MOVS     R1,#+1
   \   0000004C   0xF880 0x105D      STRB     R1,[R0, #+93]
   2640                  HAL_SPI_TxRxCpltCallback(hspi);
   \   00000050   0x.... 0x....      BL       HAL_SPI_TxRxCpltCallback
   \   00000054   0xBD01             POP      {R0,PC}
   2641                }      
   2642              }
   2643              else
   2644              {
   2645                hspi->State = HAL_SPI_STATE_READY;
   \                     ??SPI_CloseRxTx_ISR_1: (+1)
   \   00000056   0x2101             MOVS     R1,#+1
   \   00000058   0xF880 0x105D      STRB     R1,[R0, #+93]
   2646                HAL_SPI_ErrorCallback(hspi);
   \   0000005C   0x.... 0x....      BL       HAL_SPI_ErrorCallback
   2647              }
   2648            }
   2649          }
   \   00000060   0xBD01             POP      {R0,PC}          ;; return
   2650          
   2651          /**
   2652            * @brief This function handles the close of the RX transaction.
   2653            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   2654            *               the configuration information for SPI module.
   2655            * @retval None
   2656            */

   \                                 In section .text, align 2, keep-with-next
   2657          static void SPI_CloseRx_ISR(SPI_HandleTypeDef *hspi)
   2658          {
   \                     SPI_CloseRx_ISR: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   2659              /* Disable RXNE and ERR interrupt */
   2660              __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_RXNE | SPI_IT_ERR));
   \   00000004   0x6820             LDR      R0,[R4, #+0]
   \   00000006   0x6841             LDR      R1,[R0, #+4]
   \   00000008   0xF021 0x0160      BIC      R1,R1,#0x60
   \   0000000C   0x6041             STR      R1,[R0, #+4]
   2661              
   2662              /* Check the end of the transaction */
   2663              SPI_EndRxTransaction(hspi,SPI_DEFAULT_TIMEOUT);
   \   0000000E   0x2132             MOVS     R1,#+50
   \   00000010   0x4620             MOV      R0,R4
   \   00000012   0x.... 0x....      BL       SPI_EndRxTransaction
   2664          
   2665              hspi->State = HAL_SPI_STATE_READY;
   \   00000016   0x2001             MOVS     R0,#+1
   \   00000018   0xF884 0x005D      STRB     R0,[R4, #+93]
   2666          
   2667              /* Check if CRC error occurred */
   2668              if(__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_CRCERR) != RESET)
   \   0000001C   0x6E20             LDR      R0,[R4, #+96]
   \   0000001E   0x6821             LDR      R1,[R4, #+0]
   \   00000020   0x6889             LDR      R1,[R1, #+8]
   \   00000022   0x06C9             LSLS     R1,R1,#+27
   \   00000024   0xD50A             BPL.N    ??SPI_CloseRx_ISR_0
   2669              {
   2670                hspi->ErrorCode|= HAL_SPI_ERROR_CRC;
   \   00000026   0xF040 0x0002      ORR      R0,R0,#0x2
   \   0000002A   0x6620             STR      R0,[R4, #+96]
   2671                __HAL_SPI_CLEAR_CRCERRFLAG(hspi);
   \   0000002C   0xF64F 0x70EF      MOVW     R0,#+65519
   \   00000030   0x6821             LDR      R1,[R4, #+0]
   \   00000032   0x6088             STR      R0,[R1, #+8]
   2672                HAL_SPI_ErrorCallback(hspi);
   \   00000034   0x4620             MOV      R0,R4
   \   00000036   0x.... 0x....      BL       HAL_SPI_ErrorCallback
   \   0000003A   0xBD10             POP      {R4,PC}
   2673              }
   2674              else
   2675              {
   2676                if(hspi->ErrorCode == HAL_SPI_ERROR_NONE)
   \                     ??SPI_CloseRx_ISR_0: (+1)
   \   0000003C   0x2800             CMP      R0,#+0
   \   0000003E   0x4620             MOV      R0,R4
   \   00000040   0xD102             BNE.N    ??SPI_CloseRx_ISR_1
   2677                {
   2678                  HAL_SPI_RxCpltCallback(hspi);
   \   00000042   0x.... 0x....      BL       HAL_SPI_RxCpltCallback
   \   00000046   0xBD10             POP      {R4,PC}
   2679                }
   2680                else
   2681                {
   2682                  HAL_SPI_ErrorCallback(hspi);
   \                     ??SPI_CloseRx_ISR_1: (+1)
   \   00000048   0x.... 0x....      BL       HAL_SPI_ErrorCallback
   2683                }
   2684              }
   2685          }
   \   0000004C   0xBD10             POP      {R4,PC}          ;; return
   2686          
   2687          /**
   2688            * @brief This function handles the close of the TX transaction.
   2689            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   2690            *               the configuration information for SPI module.
   2691            * @retval None
   2692            */

   \                                 In section .text, align 2, keep-with-next
   2693          static void SPI_CloseTx_ISR(SPI_HandleTypeDef *hspi)
   2694          {
   \                     SPI_CloseTx_ISR: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   2695            /* Disable TXE and ERR interrupt */
   2696            __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_ERR));
   \   00000002   0x6801             LDR      R1,[R0, #+0]
   \   00000004   0x684A             LDR      R2,[R1, #+4]
   \   00000006   0xF022 0x02A0      BIC      R2,R2,#0xA0
   \   0000000A   0x604A             STR      R2,[R1, #+4]
   2697          
   2698            /* Clear OVERUN flag in 2 Lines communication mode because received is not read */
   2699            if(hspi->Init.Direction == SPI_DIRECTION_2LINES)
   \   0000000C   0x6881             LDR      R1,[R0, #+8]
   \   0000000E   0x2900             CMP      R1,#+0
   \   00000010   0xD105             BNE.N    ??SPI_CloseTx_ISR_0
   2700            {
   2701              __HAL_SPI_CLEAR_OVRFLAG(hspi);
   \   00000012   0x6801             LDR      R1,[R0, #+0]
   \   00000014   0x68CA             LDR      R2,[R1, #+12]
   \   00000016   0x9200             STR      R2,[SP, #+0]
   \   00000018   0x6889             LDR      R1,[R1, #+8]
   \   0000001A   0x9100             STR      R1,[SP, #+0]
   \   0000001C   0x9900             LDR      R1,[SP, #+0]
   2702            }
   2703          
   2704            hspi->State = HAL_SPI_STATE_READY;
   \                     ??SPI_CloseTx_ISR_0: (+1)
   \   0000001E   0x2101             MOVS     R1,#+1
   \   00000020   0xF880 0x105D      STRB     R1,[R0, #+93]
   2705            if(hspi->ErrorCode != HAL_SPI_ERROR_NONE)
   \   00000024   0x6E01             LDR      R1,[R0, #+96]
   \   00000026   0x2900             CMP      R1,#+0
   \   00000028   0xD002             BEQ.N    ??SPI_CloseTx_ISR_1
   2706            {
   2707              HAL_SPI_ErrorCallback(hspi);
   \   0000002A   0x.... 0x....      BL       HAL_SPI_ErrorCallback
   \   0000002E   0xBD01             POP      {R0,PC}
   2708            }
   2709            else
   2710            {
   2711              HAL_SPI_TxCpltCallback(hspi);
   \                     ??SPI_CloseTx_ISR_1: (+1)
   \   00000030   0x.... 0x....      BL       HAL_SPI_TxCpltCallback
   2712            }
   2713          }
   \   00000034   0xBD01             POP      {R0,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1:
   \   00000000   0x........         DC32     SPI_RxISR_8BITCRC

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_1:
   \   00000000   0x........         DC32     SPI_RxISR_16BITCRC
   2714          
   2715          /**
   2716            * @}
   2717            */
   2718          
   2719          #endif /* HAL_SPI_MODULE_ENABLED */
   2720          /**
   2721            * @}
   2722            */
   2723          
   2724          /**
   2725            * @}
   2726            */
   2727          
   2728          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   HAL_SPI_DMAPause
       0   HAL_SPI_DMAResume
       8   HAL_SPI_DMAStop
         8   -> HAL_DMA_Abort
      16   HAL_SPI_DeInit
        16   -> HAL_SPI_MspDeInit
        16   -> SPI_WaitFifoStateUntilTimeout
        16   -> SPI_WaitFlagStateUntilTimeout
       0   HAL_SPI_ErrorCallback
       0   HAL_SPI_GetError
       0   HAL_SPI_GetState
       8   HAL_SPI_IRQHandler
         0   -- Indirect call
         8   -> HAL_SPI_ErrorCallback
      16   HAL_SPI_Init
        16   -> HAL_SPI_MspInit
       0   HAL_SPI_MspDeInit
       0   HAL_SPI_MspInit
      24   HAL_SPI_Receive
        24   -> HAL_SPI_TransmitReceive
        24   -> SPI_EndRxTransaction
        24   -> SPI_WaitFlagStateUntilTimeout
      16   HAL_SPI_Receive_DMA
        16   -> HAL_DMA_Start_IT
         0   -> HAL_SPI_TransmitReceive_DMA
       8   HAL_SPI_Receive_IT
         0   -> HAL_SPI_TransmitReceive_IT
       0   HAL_SPI_RxCpltCallback
       0   HAL_SPI_RxHalfCpltCallback
      24   HAL_SPI_Transmit
        24   -> SPI_EndRxTxTransaction
        24   -> SPI_WaitFlagStateUntilTimeout
      32   HAL_SPI_TransmitReceive
        32   -> HAL_GetTick
        32   -> SPI_EndRxTxTransaction
        32   -> SPI_WaitFlagStateUntilTimeout
      16   HAL_SPI_TransmitReceive_DMA
        16   -> HAL_DMA_Start_IT
      12   HAL_SPI_TransmitReceive_IT
      16   HAL_SPI_Transmit_DMA
        16   -> HAL_DMA_Start_IT
       4   HAL_SPI_Transmit_IT
       0   HAL_SPI_TxCpltCallback
       0   HAL_SPI_TxHalfCpltCallback
       0   HAL_SPI_TxRxCpltCallback
       0   HAL_SPI_TxRxHalfCpltCallback
       0   SPI_2linesRxISR_16BIT
         0   -> SPI_CloseRxTx_ISR
       8   SPI_2linesRxISR_16BITCRC
         0   -> SPI_CloseRxTx_ISR
       0   SPI_2linesRxISR_8BIT
         0   -> SPI_CloseRxTx_ISR
       8   SPI_2linesRxISR_8BITCRC
         0   -> SPI_CloseRxTx_ISR
       0   SPI_2linesTxISR_16BIT
         0   -> SPI_CloseRxTx_ISR
       0   SPI_2linesTxISR_8BIT
         0   -> SPI_CloseRxTx_ISR
       8   SPI_CloseRxTx_ISR
         8   -> HAL_SPI_ErrorCallback
         8   -> HAL_SPI_RxCpltCallback
         8   -> HAL_SPI_TxRxCpltCallback
       8   SPI_CloseRx_ISR
         8   -> HAL_SPI_ErrorCallback
         8   -> HAL_SPI_RxCpltCallback
         8   -> SPI_EndRxTransaction
       8   SPI_CloseTx_ISR
         8   -> HAL_SPI_ErrorCallback
         8   -> HAL_SPI_TxCpltCallback
       8   SPI_DMAError
         8   -> HAL_SPI_ErrorCallback
       8   SPI_DMAHalfReceiveCplt
         8   -> HAL_SPI_RxHalfCpltCallback
       8   SPI_DMAHalfTransmitCplt
         8   -> HAL_SPI_TxHalfCpltCallback
       8   SPI_DMAHalfTransmitReceiveCplt
         8   -> HAL_SPI_TxRxHalfCpltCallback
      16   SPI_DMAReceiveCplt
        16   -> HAL_SPI_ErrorCallback
        16   -> HAL_SPI_RxCpltCallback
        16   -> SPI_EndRxTransaction
        16   -> SPI_WaitFlagStateUntilTimeout
       8   SPI_DMATransmitCplt
         8   -> HAL_SPI_ErrorCallback
         8   -> HAL_SPI_TxCpltCallback
      16   SPI_DMATransmitReceiveCplt
        16   -> HAL_SPI_ErrorCallback
        16   -> HAL_SPI_TxRxCpltCallback
        16   -> SPI_EndRxTxTransaction
        16   -> SPI_WaitFifoStateUntilTimeout
      16   SPI_EndRxTransaction
        16   -> SPI_WaitFifoStateUntilTimeout
        16   -> SPI_WaitFlagStateUntilTimeout
      16   SPI_EndRxTxTransaction
        16   -> SPI_WaitFifoStateUntilTimeout
        16   -> SPI_WaitFlagStateUntilTimeout
       0   SPI_RxISR_16BIT
         0   -> SPI_CloseRx_ISR
       8   SPI_RxISR_16BITCRC
         0   -> SPI_CloseRx_ISR
       0   SPI_RxISR_8BIT
         0   -> SPI_CloseRx_ISR
       8   SPI_RxISR_8BITCRC
         0   -> SPI_CloseRx_ISR
       0   SPI_TxISR_16BIT
         0   -> SPI_CloseTx_ISR
       0   SPI_TxISR_8BIT
         0   -> SPI_CloseTx_ISR
      32   SPI_WaitFifoStateUntilTimeout
        32   -> HAL_GetTick
      24   SPI_WaitFlagStateUntilTimeout
        24   -> HAL_GetTick


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable1
       4  ??DataTable1_1
      38  HAL_SPI_DMAPause
      38  HAL_SPI_DMAResume
      44  HAL_SPI_DMAStop
      84  HAL_SPI_DeInit
       2  HAL_SPI_ErrorCallback
       4  HAL_SPI_GetError
       6  HAL_SPI_GetState
     170  HAL_SPI_IRQHandler
     198  HAL_SPI_Init
       2  HAL_SPI_MspDeInit
       2  HAL_SPI_MspInit
     530  HAL_SPI_Receive
     274  HAL_SPI_Receive_DMA
     252  HAL_SPI_Receive_IT
       2  HAL_SPI_RxCpltCallback
       2  HAL_SPI_RxHalfCpltCallback
     364  HAL_SPI_Transmit
     678  HAL_SPI_TransmitReceive
     428  HAL_SPI_TransmitReceive_DMA
     254  HAL_SPI_TransmitReceive_IT
     248  HAL_SPI_Transmit_DMA
     170  HAL_SPI_Transmit_IT
       2  HAL_SPI_TxCpltCallback
       2  HAL_SPI_TxHalfCpltCallback
       2  HAL_SPI_TxRxCpltCallback
       2  HAL_SPI_TxRxHalfCpltCallback
      66  SPI_2linesRxISR_16BIT
      26  SPI_2linesRxISR_16BITCRC
     120  SPI_2linesRxISR_8BIT
      46  SPI_2linesRxISR_8BITCRC
      66  SPI_2linesTxISR_16BIT
      90  SPI_2linesTxISR_8BIT
      98  SPI_CloseRxTx_ISR
      78  SPI_CloseRx_ISR
      54  SPI_CloseTx_ISR
      34  SPI_DMAError
      10  SPI_DMAHalfReceiveCplt
      10  SPI_DMAHalfTransmitCplt
      10  SPI_DMAHalfTransmitReceiveCplt
     218  SPI_DMAReceiveCplt
      70  SPI_DMATransmitCplt
     202  SPI_DMATransmitReceiveCplt
      88  SPI_EndRxTransaction
      72  SPI_EndRxTxTransaction
      74  SPI_RxISR_16BIT
      26  SPI_RxISR_16BITCRC
      72  SPI_RxISR_8BIT
      30  SPI_RxISR_8BITCRC
      48  SPI_TxISR_16BIT
      46  SPI_TxISR_8BIT
     166  SPI_WaitFifoStateUntilTimeout
     144  SPI_WaitFlagStateUntilTimeout

 
 5 770 bytes in section .text
 
 5 770 bytes of CODE memory

Errors: none
Warnings: none
