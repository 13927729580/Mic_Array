///////////////////////////////////////////////////////////////////////////////
//
// IAR ANSI C/C++ Compiler V7.50.2.10312/W32 for ARM      13/Feb/2016  11:44:29
// Copyright 1999-2015 IAR Systems AB.
//
//    Cpu mode     =  thumb
//    Endian       =  little
//    Source file  =  
//        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_flash_ex.c
//    Command line =  
//        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_flash_ex.c
//        -D USE_HAL_DRIVER -D STM32F746xx -D USE_STM32746G_DISCO -D
//        USE_IOEXPANDER -D USE_USB_FS -lC
//        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
//        -lA
//        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
//        -o
//        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj
//        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
//        --no_clustering --no_scheduling --debug --endian=little
//        --cpu=Cortex-M7 -e --fpu=VFPv5_sp --dlib_config "D:\Program Files
//        (x86)\IAR Systems\Embedded Workbench
//        7.3\arm\INC\c\DLib_Config_Full.h" -I
//        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\Inc\
//        -I
//        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\CMSIS\Device\ST\STM32F7xx\Include\
//        -I
//        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\STM32F7xx_HAL_Driver\Inc\
//        -I
//        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\STM32746G-Discovery\
//        -I
//        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\Components\Common\
//        -I
//        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Log\
//        -I
//        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Fonts\
//        -I
//        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\CPU\
//        -I
//        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_Device_Library\Core\Inc\
//        -I
//        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Core\Inc\
//        -I
//        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Class\MSC\Inc\
//        -I
//        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\
//        -I
//        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\drivers\
//        -I
//        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_Audio\Addons\PDM\
//        -I
//        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_Device_Library\Class\AUDIO\Inc\
//        -On --use_c++_inline --require_prototypes -I "D:\Program Files
//        (x86)\IAR Systems\Embedded Workbench 7.3\arm\CMSIS\Include\" -D
//        ARM_MATH_CM7
//    List file    =  
//        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List\stm32f7xx_hal_flash_ex.s
//
///////////////////////////////////////////////////////////////////////////////

        RTMODEL "__SystemLibrary", "DLib"
        RTMODEL "__dlib_file_descriptor", "1"
        AAPCS BASE,INTERWORK,VFP
        PRESERVE8
        REQUIRE8

        #define SHT_PROGBITS 0x1

        EXTERN FLASH_WaitForLastOperation
        EXTERN pFlash

        PUBLIC FLASH_Erase_Sector
        PUBLIC HAL_FLASHEx_Erase
        PUBLIC HAL_FLASHEx_Erase_IT
        PUBLIC HAL_FLASHEx_OBGetConfig
        PUBLIC HAL_FLASHEx_OBProgram
        
          CFI Names cfiNames0
          CFI StackFrame CFA R13 DATA
          CFI Resource R0:32, R1:32, R2:32, R3:32, R4:32, R5:32, R6:32, R7:32
          CFI Resource R8:32, R9:32, R10:32, R11:32, R12:32, R13:32, R14:32
          CFI Resource D0:64, D1:64, D2:64, D3:64, D4:64, D5:64, D6:64, D7:64
          CFI Resource D8:64, D9:64, D10:64, D11:64, D12:64, D13:64, D14:64
          CFI Resource D15:64
          CFI EndNames cfiNames0
        
          CFI Common cfiCommon0 Using cfiNames0
          CFI CodeAlign 2
          CFI DataAlign 4
          CFI ReturnAddress R14 CODE
          CFI CFA R13+0
          CFI R0 Undefined
          CFI R1 Undefined
          CFI R2 Undefined
          CFI R3 Undefined
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R8 SameValue
          CFI R9 SameValue
          CFI R10 SameValue
          CFI R11 SameValue
          CFI R12 Undefined
          CFI R14 SameValue
          CFI D0 Undefined
          CFI D1 Undefined
          CFI D2 Undefined
          CFI D3 Undefined
          CFI D4 Undefined
          CFI D5 Undefined
          CFI D6 Undefined
          CFI D7 Undefined
          CFI D8 SameValue
          CFI D9 SameValue
          CFI D10 SameValue
          CFI D11 SameValue
          CFI D12 SameValue
          CFI D13 SameValue
          CFI D14 SameValue
          CFI D15 SameValue
          CFI EndCommon cfiCommon0
        
// H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_flash_ex.c
//    1 /**
//    2   ******************************************************************************
//    3   * @file    stm32f7xx_hal_flash_ex.c
//    4   * @author  MCD Application Team
//    5   * @version V1.0.1
//    6   * @date    25-June-2015
//    7   * @brief   Extended FLASH HAL module driver.
//    8   *          This file provides firmware functions to manage the following 
//    9   *          functionalities of the FLASH extension peripheral:
//   10   *           + Extended programming operations functions
//   11   *  
//   12   @verbatim
//   13   ==============================================================================
//   14                    ##### Flash Extension features #####
//   15   ==============================================================================
//   16            
//   17   [..] Comparing to other previous devices, the FLASH interface for STM32F727xx/437xx and 
//   18        devices contains the following additional features 
//   19        
//   20        (+) Capacity up to 2 Mbyte with dual bank architecture supporting read-while-write
//   21            capability (RWW)
//   22        (+) Dual bank memory organization       
//   23        (+) PCROP protection for all banks
//   24    
//   25                       ##### How to use this driver #####
//   26   ==============================================================================
//   27   [..] This driver provides functions to configure and program the FLASH memory 
//   28        of all STM32F7xx devices. It includes
//   29       (#) FLASH Memory Erase functions: 
//   30            (++) Lock and Unlock the FLASH interface using HAL_FLASH_Unlock() and 
//   31                 HAL_FLASH_Lock() functions
//   32            (++) Erase function: Erase sector, erase all sectors
//   33            (++) There are two modes of erase :
//   34              (+++) Polling Mode using HAL_FLASHEx_Erase()
//   35              (+++) Interrupt Mode using HAL_FLASHEx_Erase_IT()
//   36              
//   37       (#) Option Bytes Programming functions: Use HAL_FLASHEx_OBProgram() to :
//   38            (++) Set/Reset the write protection
//   39            (++) Set the Read protection Level
//   40            (++) Set the BOR level
//   41            (++) Program the user Option Bytes
//   42       (#) Advanced Option Bytes Programming functions: Use HAL_FLASHEx_AdvOBProgram() to :  
//   43        (++) Extended space (bank 2) erase function
//   44        (++) Full FLASH space (2 Mo) erase (bank 1 and bank 2)
//   45        (++) Dual Boot activation
//   46        (++) Write protection configuration for bank 2
//   47        (++) PCROP protection configuration and control for both banks
//   48   
//   49   @endverbatim
//   50   ******************************************************************************
//   51   * @attention
//   52   *
//   53   * <h2><center>&copy; COPYRIGHT(c) 2015 STMicroelectronics</center></h2>
//   54   *
//   55   * Redistribution and use in source and binary forms, with or without modification,
//   56   * are permitted provided that the following conditions are met:
//   57   *   1. Redistributions of source code must retain the above copyright notice,
//   58   *      this list of conditions and the following disclaimer.
//   59   *   2. Redistributions in binary form must reproduce the above copyright notice,
//   60   *      this list of conditions and the following disclaimer in the documentation
//   61   *      and/or other materials provided with the distribution.
//   62   *   3. Neither the name of STMicroelectronics nor the names of its contributors
//   63   *      may be used to endorse or promote products derived from this software
//   64   *      without specific prior written permission.
//   65   *
//   66   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
//   67   * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
//   68   * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
//   69   * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
//   70   * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
//   71   * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
//   72   * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
//   73   * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
//   74   * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
//   75   * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//   76   *
//   77   ******************************************************************************
//   78   */ 
//   79 
//   80 /* Includes ------------------------------------------------------------------*/
//   81 #include "stm32f7xx_hal.h"
//   82 
//   83 /** @addtogroup STM32F7xx_HAL_Driver
//   84   * @{
//   85   */
//   86 
//   87 /** @defgroup FLASHEx FLASHEx
//   88   * @brief FLASH HAL Extension module driver
//   89   * @{
//   90   */
//   91 
//   92 #ifdef HAL_FLASH_MODULE_ENABLED
//   93 
//   94 /* Private typedef -----------------------------------------------------------*/
//   95 /* Private define ------------------------------------------------------------*/
//   96 /** @addtogroup FLASHEx_Private_Constants
//   97   * @{
//   98   */    
//   99 #define SECTOR_MASK               ((uint32_t)0xFFFFFF07)
//  100 #define FLASH_TIMEOUT_VALUE       ((uint32_t)50000)/* 50 s */
//  101 /**
//  102   * @}
//  103   */
//  104     
//  105 /* Private macro -------------------------------------------------------------*/
//  106 /* Private variables ---------------------------------------------------------*/
//  107 /** @addtogroup FLASHEx_Private_Variables
//  108   * @{
//  109   */    
//  110 extern FLASH_ProcessTypeDef pFlash;
//  111 /**
//  112   * @}
//  113   */
//  114 
//  115 /* Private function prototypes -----------------------------------------------*/
//  116 /** @addtogroup FLASHEx_Private_Functions
//  117   * @{
//  118   */
//  119 /* Option bytes control */
//  120 static void               FLASH_MassErase(uint8_t VoltageRange);
//  121 static HAL_StatusTypeDef  FLASH_OB_EnableWRP(uint32_t WRPSector);
//  122 static HAL_StatusTypeDef  FLASH_OB_DisableWRP(uint32_t WRPSector);
//  123 static HAL_StatusTypeDef  FLASH_OB_RDP_LevelConfig(uint32_t Level);
//  124 static HAL_StatusTypeDef  FLASH_OB_UserConfig(uint32_t Wwdg, uint32_t Iwdg, uint32_t Stop, uint32_t Stdby, uint32_t Iwdgstop, uint32_t Iwdgstdby);
//  125 static HAL_StatusTypeDef  FLASH_OB_BOR_LevelConfig(uint8_t Level);
//  126 static HAL_StatusTypeDef  FLASH_OB_BootAddressConfig(uint32_t BootOption, uint32_t Address);
//  127 static uint32_t           FLASH_OB_GetUser(void);
//  128 static uint32_t           FLASH_OB_GetWRP(void);
//  129 static uint8_t            FLASH_OB_GetRDP(void);
//  130 static uint32_t           FLASH_OB_GetBOR(void);
//  131 static uint32_t           FLASH_OB_GetBootAddress(uint32_t BootOption);
//  132 
//  133 extern HAL_StatusTypeDef  FLASH_WaitForLastOperation(uint32_t Timeout);
//  134 /**
//  135   * @}
//  136   */
//  137 
//  138 /* Exported functions --------------------------------------------------------*/
//  139 /** @defgroup FLASHEx_Exported_Functions FLASHEx Exported Functions
//  140   * @{
//  141   */
//  142 
//  143 /** @defgroup FLASHEx_Exported_Functions_Group1 Extended IO operation functions
//  144  *  @brief   Extended IO operation functions 
//  145  *
//  146 @verbatim   
//  147  ===============================================================================
//  148                 ##### Extended programming operation functions #####
//  149  ===============================================================================  
//  150     [..]
//  151     This subsection provides a set of functions allowing to manage the Extension FLASH 
//  152     programming operations Operations.
//  153 
//  154 @endverbatim
//  155   * @{
//  156   */
//  157 /**
//  158   * @brief  Perform a mass erase or erase the specified FLASH memory sectors 
//  159   * @param[in]  pEraseInit: pointer to an FLASH_EraseInitTypeDef structure that
//  160   *         contains the configuration information for the erasing.
//  161   * 
//  162   * @param[out]  SectorError: pointer to variable  that
//  163   *         contains the configuration information on faulty sector in case of error 
//  164   *         (0xFFFFFFFF means that all the sectors have been correctly erased)
//  165   * 
//  166   * @retval HAL Status
//  167   */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock0 Using cfiCommon0
          CFI Function HAL_FLASHEx_Erase
        THUMB
//  168 HAL_StatusTypeDef HAL_FLASHEx_Erase(FLASH_EraseInitTypeDef *pEraseInit, uint32_t *SectorError)
//  169 {
HAL_FLASHEx_Erase:
        PUSH     {R3-R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI R7 Frame(CFA, -8)
          CFI R6 Frame(CFA, -12)
          CFI R5 Frame(CFA, -16)
          CFI R4 Frame(CFA, -20)
          CFI CFA R13+24
        MOVS     R4,R0
        MOVS     R5,R1
//  170   HAL_StatusTypeDef status = HAL_ERROR;
        MOVS     R6,#+1
//  171   uint32_t index = 0;
        MOVS     R7,#+0
//  172   
//  173   /* Process Locked */
//  174   __HAL_LOCK(&pFlash);
        LDR.W    R0,??DataTable15
        LDRB     R0,[R0, #+20]
        CMP      R0,#+1
        BNE.N    ??HAL_FLASHEx_Erase_0
        MOVS     R0,#+2
        B.N      ??HAL_FLASHEx_Erase_1
??HAL_FLASHEx_Erase_0:
        MOVS     R0,#+1
        LDR.W    R1,??DataTable15
        STRB     R0,[R1, #+20]
//  175 
//  176   /* Check the parameters */
//  177   assert_param(IS_FLASH_TYPEERASE(pEraseInit->TypeErase));
//  178 
//  179   /* Wait for last operation to be completed */
//  180   status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
        MOVW     R0,#+50000
          CFI FunCall FLASH_WaitForLastOperation
        BL       FLASH_WaitForLastOperation
        MOVS     R6,R0
//  181 
//  182   if(status == HAL_OK)
        UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
        CMP      R6,#+0
        BNE.N    ??HAL_FLASHEx_Erase_2
//  183   {
//  184     /*Initialization of SectorError variable*/
//  185     *SectorError = 0xFFFFFFFF;
        MOVS     R0,#-1
        STR      R0,[R5, #+0]
//  186     
//  187     if(pEraseInit->TypeErase == FLASH_TYPEERASE_MASSERASE)
        LDR      R0,[R4, #+0]
        CMP      R0,#+1
        BNE.N    ??HAL_FLASHEx_Erase_3
//  188     {
//  189       /*Mass erase to be done*/
//  190       FLASH_MassErase((uint8_t) pEraseInit->VoltageRange);
        LDR      R0,[R4, #+12]
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
          CFI FunCall FLASH_MassErase
        BL       FLASH_MassErase
//  191 
//  192       /* Wait for last operation to be completed */
//  193       status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
        MOVW     R0,#+50000
          CFI FunCall FLASH_WaitForLastOperation
        BL       FLASH_WaitForLastOperation
        MOVS     R6,R0
//  194       
//  195       /* if the erase operation is completed, disable the MER Bit */
//  196       FLASH->CR &= (~FLASH_MER_BIT);
        LDR.W    R0,??DataTable15_1  ;; 0x40023c10
        LDR      R0,[R0, #+0]
        BICS     R0,R0,#0x4
        LDR.W    R1,??DataTable15_1  ;; 0x40023c10
        STR      R0,[R1, #+0]
        B.N      ??HAL_FLASHEx_Erase_2
//  197     }
//  198     else
//  199     {
//  200       /* Check the parameters */
//  201       assert_param(IS_FLASH_NBSECTORS(pEraseInit->NbSectors + pEraseInit->Sector));
//  202 
//  203       /* Erase by sector by sector to be done*/
//  204       for(index = pEraseInit->Sector; index < (pEraseInit->NbSectors + pEraseInit->Sector); index++)
??HAL_FLASHEx_Erase_3:
        LDR      R0,[R4, #+4]
        MOVS     R7,R0
??HAL_FLASHEx_Erase_4:
        LDR      R0,[R4, #+8]
        LDR      R1,[R4, #+4]
        ADDS     R0,R1,R0
        CMP      R7,R0
        BCS.N    ??HAL_FLASHEx_Erase_2
//  205       {
//  206         FLASH_Erase_Sector(index, (uint8_t) pEraseInit->VoltageRange);
        LDR      R1,[R4, #+12]
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        MOVS     R0,R7
          CFI FunCall FLASH_Erase_Sector
        BL       FLASH_Erase_Sector
//  207 
//  208         /* Wait for last operation to be completed */
//  209         status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
        MOVW     R0,#+50000
          CFI FunCall FLASH_WaitForLastOperation
        BL       FLASH_WaitForLastOperation
        MOVS     R6,R0
//  210         
//  211         /* If the erase operation is completed, disable the SER Bit */
//  212         FLASH->CR &= (~FLASH_CR_SER);
        LDR.W    R0,??DataTable15_1  ;; 0x40023c10
        LDR      R0,[R0, #+0]
        BICS     R0,R0,#0x2
        LDR.W    R1,??DataTable15_1  ;; 0x40023c10
        STR      R0,[R1, #+0]
//  213         FLASH->CR &= SECTOR_MASK; 
        LDR.W    R0,??DataTable15_1  ;; 0x40023c10
        LDR      R0,[R0, #+0]
        BICS     R0,R0,#0xF8
        LDR.W    R1,??DataTable15_1  ;; 0x40023c10
        STR      R0,[R1, #+0]
//  214 
//  215         if(status != HAL_OK) 
        UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
        CMP      R6,#+0
        BEQ.N    ??HAL_FLASHEx_Erase_5
//  216         {
//  217           /* In case of error, stop erase procedure and return the faulty sector*/
//  218           *SectorError = index;
        STR      R7,[R5, #+0]
//  219           break;
        B.N      ??HAL_FLASHEx_Erase_2
//  220         }
//  221       }
??HAL_FLASHEx_Erase_5:
        ADDS     R7,R7,#+1
        B.N      ??HAL_FLASHEx_Erase_4
//  222     }
//  223   }
//  224 
//  225   /* Process Unlocked */
//  226   __HAL_UNLOCK(&pFlash);
??HAL_FLASHEx_Erase_2:
        MOVS     R0,#+0
        LDR.W    R1,??DataTable15
        STRB     R0,[R1, #+20]
//  227 
//  228   return status;
        MOVS     R0,R6
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
??HAL_FLASHEx_Erase_1:
        POP      {R1,R4-R7,PC}    ;; return
//  229 }
          CFI EndBlock cfiBlock0
//  230 
//  231 /**
//  232   * @brief  Perform a mass erase or erase the specified FLASH memory sectors  with interrupt enabled
//  233   * @param  pEraseInit: pointer to an FLASH_EraseInitTypeDef structure that
//  234   *         contains the configuration information for the erasing.
//  235   * 
//  236   * @retval HAL Status
//  237   */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock1 Using cfiCommon0
          CFI Function HAL_FLASHEx_Erase_IT
        THUMB
//  238 HAL_StatusTypeDef HAL_FLASHEx_Erase_IT(FLASH_EraseInitTypeDef *pEraseInit)
//  239 {
HAL_FLASHEx_Erase_IT:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
        MOVS     R4,R0
//  240   HAL_StatusTypeDef status = HAL_OK;
        MOVS     R5,#+0
//  241 
//  242   /* Process Locked */
//  243   __HAL_LOCK(&pFlash);
        LDR.W    R0,??DataTable15
        LDRB     R0,[R0, #+20]
        CMP      R0,#+1
        BNE.N    ??HAL_FLASHEx_Erase_IT_0
        MOVS     R0,#+2
        B.N      ??HAL_FLASHEx_Erase_IT_1
??HAL_FLASHEx_Erase_IT_0:
        MOVS     R0,#+1
        LDR.W    R1,??DataTable15
        STRB     R0,[R1, #+20]
//  244 
//  245   /* Check the parameters */
//  246   assert_param(IS_FLASH_TYPEERASE(pEraseInit->TypeErase));
//  247 
//  248   /* Enable End of FLASH Operation interrupt */
//  249   __HAL_FLASH_ENABLE_IT(FLASH_IT_EOP);
        LDR.W    R0,??DataTable15_1  ;; 0x40023c10
        LDR      R0,[R0, #+0]
        ORRS     R0,R0,#0x1000000
        LDR.W    R1,??DataTable15_1  ;; 0x40023c10
        STR      R0,[R1, #+0]
//  250   
//  251   /* Enable Error source interrupt */
//  252   __HAL_FLASH_ENABLE_IT(FLASH_IT_ERR);
        LDR.W    R0,??DataTable15_1  ;; 0x40023c10
        LDR      R0,[R0, #+0]
        ORRS     R0,R0,#0x2000000
        LDR.W    R1,??DataTable15_1  ;; 0x40023c10
        STR      R0,[R1, #+0]
//  253   
//  254   /* Clear pending flags (if any) */  
//  255   __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_EOP    | FLASH_FLAG_OPERR | FLASH_FLAG_WRPERR |\ 
//  256                          FLASH_FLAG_PGAERR | FLASH_FLAG_PGPERR| FLASH_FLAG_ERSERR);  
        MOVS     R0,#+243
        LDR.W    R1,??DataTable15_2  ;; 0x40023c0c
        STR      R0,[R1, #+0]
//  257   
//  258   if(pEraseInit->TypeErase == FLASH_TYPEERASE_MASSERASE)
        LDR      R0,[R4, #+0]
        CMP      R0,#+1
        BNE.N    ??HAL_FLASHEx_Erase_IT_2
//  259   {
//  260     /*Mass erase to be done*/
//  261     pFlash.ProcedureOnGoing = FLASH_PROC_MASSERASE;
        MOVS     R0,#+2
        LDR.W    R1,??DataTable15
        STRB     R0,[R1, #+0]
//  262     FLASH_MassErase((uint8_t) pEraseInit->VoltageRange);
        LDR      R0,[R4, #+12]
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
          CFI FunCall FLASH_MassErase
        BL       FLASH_MassErase
        B.N      ??HAL_FLASHEx_Erase_IT_3
//  263   }
//  264   else
//  265   {
//  266     /* Erase by sector to be done*/
//  267 
//  268     /* Check the parameters */
//  269     assert_param(IS_FLASH_NBSECTORS(pEraseInit->NbSectors + pEraseInit->Sector));
//  270 
//  271     pFlash.ProcedureOnGoing = FLASH_PROC_SECTERASE;
??HAL_FLASHEx_Erase_IT_2:
        MOVS     R0,#+1
        LDR.W    R1,??DataTable15
        STRB     R0,[R1, #+0]
//  272     pFlash.NbSectorsToErase = pEraseInit->NbSectors;
        LDR      R0,[R4, #+8]
        LDR.W    R1,??DataTable15
        STR      R0,[R1, #+4]
//  273     pFlash.Sector = pEraseInit->Sector;
        LDR      R0,[R4, #+4]
        LDR.N    R1,??DataTable15
        STR      R0,[R1, #+12]
//  274     pFlash.VoltageForErase = (uint8_t)pEraseInit->VoltageRange;
        LDR      R0,[R4, #+12]
        LDR.N    R1,??DataTable15
        STRB     R0,[R1, #+8]
//  275 
//  276     /*Erase 1st sector and wait for IT*/
//  277     FLASH_Erase_Sector(pEraseInit->Sector, pEraseInit->VoltageRange);
        LDR      R1,[R4, #+12]
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        LDR      R0,[R4, #+4]
          CFI FunCall FLASH_Erase_Sector
        BL       FLASH_Erase_Sector
//  278   }
//  279 
//  280   return status;
??HAL_FLASHEx_Erase_IT_3:
        MOVS     R0,R5
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
??HAL_FLASHEx_Erase_IT_1:
        POP      {R1,R4,R5,PC}    ;; return
//  281 }
          CFI EndBlock cfiBlock1
//  282 
//  283 /**
//  284   * @brief   Program option bytes
//  285   * @param  pOBInit: pointer to an FLASH_OBInitStruct structure that
//  286   *         contains the configuration information for the programming.
//  287   * 
//  288   * @retval HAL Status
//  289   */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock2 Using cfiCommon0
          CFI Function HAL_FLASHEx_OBProgram
        THUMB
//  290 HAL_StatusTypeDef HAL_FLASHEx_OBProgram(FLASH_OBProgramInitTypeDef *pOBInit)
//  291 {
HAL_FLASHEx_OBProgram:
        PUSH     {R4,R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+12
        SUB      SP,SP,#+12
          CFI CFA R13+24
        MOVS     R4,R0
//  292   HAL_StatusTypeDef status = HAL_ERROR;
        MOVS     R5,#+1
//  293   
//  294   /* Process Locked */
//  295   __HAL_LOCK(&pFlash);
        LDR.N    R0,??DataTable15
        LDRB     R0,[R0, #+20]
        CMP      R0,#+1
        BNE.N    ??HAL_FLASHEx_OBProgram_0
        MOVS     R0,#+2
        B.N      ??HAL_FLASHEx_OBProgram_1
??HAL_FLASHEx_OBProgram_0:
        MOVS     R0,#+1
        LDR.N    R1,??DataTable15
        STRB     R0,[R1, #+20]
//  296 
//  297   /* Check the parameters */
//  298   assert_param(IS_OPTIONBYTE(pOBInit->OptionType));
//  299 
//  300   /* Write protection configuration */
//  301   if((pOBInit->OptionType & OPTIONBYTE_WRP) == OPTIONBYTE_WRP)
        LDRB     R0,[R4, #+0]
        LSLS     R0,R0,#+31
        BPL.N    ??HAL_FLASHEx_OBProgram_2
//  302   {
//  303     assert_param(IS_WRPSTATE(pOBInit->WRPState));
//  304     if(pOBInit->WRPState == OB_WRPSTATE_ENABLE)
        LDR      R0,[R4, #+4]
        CMP      R0,#+1
        BNE.N    ??HAL_FLASHEx_OBProgram_3
//  305     {
//  306       /*Enable of Write protection on the selected Sector*/
//  307       status = FLASH_OB_EnableWRP(pOBInit->WRPSector);
        LDR      R0,[R4, #+8]
          CFI FunCall FLASH_OB_EnableWRP
        BL       FLASH_OB_EnableWRP
        MOVS     R5,R0
        B.N      ??HAL_FLASHEx_OBProgram_2
//  308     }
//  309     else
//  310     {
//  311       /*Disable of Write protection on the selected Sector*/
//  312       status = FLASH_OB_DisableWRP(pOBInit->WRPSector);
??HAL_FLASHEx_OBProgram_3:
        LDR      R0,[R4, #+8]
          CFI FunCall FLASH_OB_DisableWRP
        BL       FLASH_OB_DisableWRP
        MOVS     R5,R0
//  313     }
//  314   }
//  315 
//  316   /* Read protection configuration */
//  317   if((pOBInit->OptionType & OPTIONBYTE_RDP) == OPTIONBYTE_RDP)
??HAL_FLASHEx_OBProgram_2:
        LDRB     R0,[R4, #+0]
        LSLS     R0,R0,#+30
        BPL.N    ??HAL_FLASHEx_OBProgram_4
//  318   {
//  319     status = FLASH_OB_RDP_LevelConfig(pOBInit->RDPLevel);
        LDR      R0,[R4, #+12]
          CFI FunCall FLASH_OB_RDP_LevelConfig
        BL       FLASH_OB_RDP_LevelConfig
        MOVS     R5,R0
//  320   }
//  321 
//  322   /* USER  configuration */
//  323   if((pOBInit->OptionType & OPTIONBYTE_USER) == OPTIONBYTE_USER)
??HAL_FLASHEx_OBProgram_4:
        LDRB     R0,[R4, #+0]
        LSLS     R0,R0,#+29
        BPL.N    ??HAL_FLASHEx_OBProgram_5
//  324   {
//  325     status = FLASH_OB_UserConfig(pOBInit->USERConfig & OB_WWDG_SW, 
//  326                                  pOBInit->USERConfig & OB_IWDG_SW,
//  327                                  pOBInit->USERConfig & OB_STOP_NO_RST,
//  328                                  pOBInit->USERConfig & OB_STDBY_NO_RST, 
//  329                                  pOBInit->USERConfig & OB_IWDG_STOP_ACTIVE,
//  330                                  pOBInit->USERConfig & OB_IWDG_STDBY_ACTIVE);
        LDR      R0,[R4, #+20]
        ANDS     R0,R0,#0x40000000
        STR      R0,[SP, #+4]
        LDR      R0,[R4, #+20]
        ANDS     R0,R0,#0x40000000
        STR      R0,[SP, #+0]
        LDRB     R0,[R4, #+20]
        ANDS     R3,R0,#0x80
        LDRB     R0,[R4, #+20]
        ANDS     R2,R0,#0x40
        LDRB     R0,[R4, #+20]
        ANDS     R1,R0,#0x20
        LDRB     R0,[R4, #+20]
        ANDS     R0,R0,#0x10
          CFI FunCall FLASH_OB_UserConfig
        BL       FLASH_OB_UserConfig
        MOVS     R5,R0
//  331   }
//  332   
//  333   /* BOR Level  configuration */
//  334   if((pOBInit->OptionType & OPTIONBYTE_BOR) == OPTIONBYTE_BOR)
??HAL_FLASHEx_OBProgram_5:
        LDRB     R0,[R4, #+0]
        LSLS     R0,R0,#+28
        BPL.N    ??HAL_FLASHEx_OBProgram_6
//  335   {
//  336     status = FLASH_OB_BOR_LevelConfig(pOBInit->BORLevel);
        LDR      R0,[R4, #+16]
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
          CFI FunCall FLASH_OB_BOR_LevelConfig
        BL       FLASH_OB_BOR_LevelConfig
        MOVS     R5,R0
//  337   }
//  338   
//  339   /* Boot 0 Address configuration */
//  340   if((pOBInit->OptionType & OPTIONBYTE_BOOTADDR_0) == OPTIONBYTE_BOOTADDR_0)
??HAL_FLASHEx_OBProgram_6:
        LDRB     R0,[R4, #+0]
        LSLS     R0,R0,#+27
        BPL.N    ??HAL_FLASHEx_OBProgram_7
//  341   {
//  342     status = FLASH_OB_BootAddressConfig(OPTIONBYTE_BOOTADDR_0, pOBInit->BootAddr0);
        LDR      R1,[R4, #+24]
        MOVS     R0,#+16
          CFI FunCall FLASH_OB_BootAddressConfig
        BL       FLASH_OB_BootAddressConfig
        MOVS     R5,R0
//  343   }
//  344   
//  345   /* Boot 1 Address configuration */
//  346   if((pOBInit->OptionType & OPTIONBYTE_BOOTADDR_1) == OPTIONBYTE_BOOTADDR_1)
??HAL_FLASHEx_OBProgram_7:
        LDRB     R0,[R4, #+0]
        LSLS     R0,R0,#+26
        BPL.N    ??HAL_FLASHEx_OBProgram_8
//  347   {
//  348     status = FLASH_OB_BootAddressConfig(OPTIONBYTE_BOOTADDR_1, pOBInit->BootAddr1);
        LDR      R1,[R4, #+28]
        MOVS     R0,#+32
          CFI FunCall FLASH_OB_BootAddressConfig
        BL       FLASH_OB_BootAddressConfig
        MOVS     R5,R0
//  349   }
//  350 
//  351   /* Process Unlocked */
//  352   __HAL_UNLOCK(&pFlash);
??HAL_FLASHEx_OBProgram_8:
        MOVS     R0,#+0
        LDR.N    R1,??DataTable15
        STRB     R0,[R1, #+20]
//  353 
//  354   return status;
        MOVS     R0,R5
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
??HAL_FLASHEx_OBProgram_1:
        POP      {R1-R5,PC}       ;; return
//  355 }
          CFI EndBlock cfiBlock2
//  356 
//  357 /**
//  358   * @brief   Get the Option byte configuration
//  359   * @param  pOBInit: pointer to an FLASH_OBInitStruct structure that
//  360   *         contains the configuration information for the programming.
//  361   * 
//  362   * @retval None
//  363   */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock3 Using cfiCommon0
          CFI Function HAL_FLASHEx_OBGetConfig
        THUMB
//  364 void HAL_FLASHEx_OBGetConfig(FLASH_OBProgramInitTypeDef *pOBInit)
//  365 {
HAL_FLASHEx_OBGetConfig:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        MOVS     R4,R0
//  366   pOBInit->OptionType = OPTIONBYTE_WRP | OPTIONBYTE_RDP | OPTIONBYTE_USER |\ 
//  367 	                      OPTIONBYTE_BOR | OPTIONBYTE_BOOTADDR_0 | OPTIONBYTE_BOOTADDR_1;
        MOVS     R0,#+63
        STR      R0,[R4, #+0]
//  368 
//  369   /*Get WRP*/
//  370   pOBInit->WRPSector = FLASH_OB_GetWRP();
          CFI FunCall FLASH_OB_GetWRP
        BL       FLASH_OB_GetWRP
        STR      R0,[R4, #+8]
//  371 
//  372   /*Get RDP Level*/
//  373   pOBInit->RDPLevel = FLASH_OB_GetRDP();
          CFI FunCall FLASH_OB_GetRDP
        BL       FLASH_OB_GetRDP
        STR      R0,[R4, #+12]
//  374 
//  375   /*Get USER*/
//  376   pOBInit->USERConfig = FLASH_OB_GetUser();
          CFI FunCall FLASH_OB_GetUser
        BL       FLASH_OB_GetUser
        STR      R0,[R4, #+20]
//  377 
//  378   /*Get BOR Level*/
//  379   pOBInit->BORLevel = FLASH_OB_GetBOR();
          CFI FunCall FLASH_OB_GetBOR
        BL       FLASH_OB_GetBOR
        STR      R0,[R4, #+16]
//  380 	
//  381 	/*Get Boot Address when Boot pin = 0 */
//  382   pOBInit->BootAddr0 = FLASH_OB_GetBootAddress(OPTIONBYTE_BOOTADDR_0);
        MOVS     R0,#+16
          CFI FunCall FLASH_OB_GetBootAddress
        BL       FLASH_OB_GetBootAddress
        STR      R0,[R4, #+24]
//  383 	
//  384   /*Get Boot Address when Boot pin = 1 */
//  385   pOBInit->BootAddr1 = FLASH_OB_GetBootAddress(OPTIONBYTE_BOOTADDR_1);
        MOVS     R0,#+32
          CFI FunCall FLASH_OB_GetBootAddress
        BL       FLASH_OB_GetBootAddress
        STR      R0,[R4, #+28]
//  386 }
        POP      {R4,PC}          ;; return
          CFI EndBlock cfiBlock3
//  387 
//  388 /**
//  389   * @}
//  390   */
//  391 
//  392 /**
//  393   * @brief  Full erase of FLASH memory sectors 
//  394   * @param  VoltageRange: The device voltage range which defines the erase parallelism.  
//  395   *          This parameter can be one of the following values:
//  396   *            @arg VOLTAGE_RANGE_1: when the device voltage range is 1.8V to 2.1V, 
//  397   *                                  the operation will be done by byte (8-bit) 
//  398   *            @arg VOLTAGE_RANGE_2: when the device voltage range is 2.1V to 2.7V,
//  399   *                                  the operation will be done by half word (16-bit)
//  400   *            @arg VOLTAGE_RANGE_3: when the device voltage range is 2.7V to 3.6V,
//  401   *                                  the operation will be done by word (32-bit)
//  402   *            @arg VOLTAGE_RANGE_4: when the device voltage range is 2.7V to 3.6V + External Vpp, 
//  403   *                                  the operation will be done by double word (64-bit)
//  404   *
//  405   * @retval HAL Status
//  406   */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock4 Using cfiCommon0
          CFI Function FLASH_MassErase
          CFI NoCalls
        THUMB
//  407 static void FLASH_MassErase(uint8_t VoltageRange)
//  408 {
//  409   uint32_t tmp_psize = 0;
FLASH_MassErase:
        MOVS     R1,#+0
//  410   
//  411   /* Check the parameters */
//  412   assert_param(IS_VOLTAGERANGE(VoltageRange));
//  413 
//  414   /* if the previous operation is completed, proceed to erase all sectors */
//  415   FLASH->CR &= CR_PSIZE_MASK;
        LDR.N    R2,??DataTable15_1  ;; 0x40023c10
        LDR      R2,[R2, #+0]
        BICS     R2,R2,#0x300
        LDR.N    R3,??DataTable15_1  ;; 0x40023c10
        STR      R2,[R3, #+0]
//  416   FLASH->CR |= tmp_psize;
        LDR.N    R2,??DataTable15_1  ;; 0x40023c10
        LDR      R2,[R2, #+0]
        ORRS     R2,R1,R2
        LDR.N    R3,??DataTable15_1  ;; 0x40023c10
        STR      R2,[R3, #+0]
//  417   FLASH->CR |= FLASH_CR_MER;
        LDR.N    R2,??DataTable15_1  ;; 0x40023c10
        LDR      R2,[R2, #+0]
        ORRS     R2,R2,#0x4
        LDR.N    R3,??DataTable15_1  ;; 0x40023c10
        STR      R2,[R3, #+0]
//  418   FLASH->CR |= FLASH_CR_STRT;
        LDR.N    R2,??DataTable15_1  ;; 0x40023c10
        LDR      R2,[R2, #+0]
        ORRS     R2,R2,#0x10000
        LDR.N    R3,??DataTable15_1  ;; 0x40023c10
        STR      R2,[R3, #+0]
//  419   /* Data synchronous Barrier (DSB) Just after the write operation
//  420      This will force the CPU to respect the sequence of instruction (no optimization).*/
//  421   __DSB();
        DSB      
//  422 }
        BX       LR               ;; return
          CFI EndBlock cfiBlock4
//  423 
//  424 /**
//  425   * @brief  Erase the specified FLASH memory sector
//  426   * @param  Sector: FLASH sector to erase
//  427   *         The value of this parameter depend on device used within the same series      
//  428   * @param  VoltageRange: The device voltage range which defines the erase parallelism.  
//  429   *          This parameter can be one of the following values:
//  430   *            @arg FLASH_VOLTAGE_RANGE_1: when the device voltage range is 1.8V to 2.1V, 
//  431   *                                  the operation will be done by byte (8-bit) 
//  432   *            @arg FLASH_VOLTAGE_RANGE_2: when the device voltage range is 2.1V to 2.7V,
//  433   *                                  the operation will be done by half word (16-bit)
//  434   *            @arg FLASH_VOLTAGE_RANGE_3: when the device voltage range is 2.7V to 3.6V,
//  435   *                                  the operation will be done by word (32-bit)
//  436   *            @arg FLASH_VOLTAGE_RANGE_4: when the device voltage range is 2.7V to 3.6V + External Vpp, 
//  437   *                                  the operation will be done by double word (64-bit)
//  438   * 
//  439   * @retval None
//  440   */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock5 Using cfiCommon0
          CFI Function FLASH_Erase_Sector
          CFI NoCalls
        THUMB
//  441 void FLASH_Erase_Sector(uint32_t Sector, uint8_t VoltageRange)
//  442 {
FLASH_Erase_Sector:
        PUSH     {R4}
          CFI R4 Frame(CFA, -4)
          CFI CFA R13+4
//  443   uint32_t tmp_psize = 0;
        MOVS     R2,#+0
//  444 
//  445   /* Check the parameters */
//  446   assert_param(IS_FLASH_SECTOR(Sector));
//  447   assert_param(IS_VOLTAGERANGE(VoltageRange));
//  448   
//  449   if(VoltageRange == FLASH_VOLTAGE_RANGE_1)
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        CMP      R1,#+0
        BNE.N    ??FLASH_Erase_Sector_0
//  450   {
//  451      tmp_psize = FLASH_PSIZE_BYTE;
        MOVS     R3,#+0
        MOVS     R2,R3
        B.N      ??FLASH_Erase_Sector_1
//  452   }
//  453   else if(VoltageRange == FLASH_VOLTAGE_RANGE_2)
??FLASH_Erase_Sector_0:
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        CMP      R1,#+1
        BNE.N    ??FLASH_Erase_Sector_2
//  454   {
//  455     tmp_psize = FLASH_PSIZE_HALF_WORD;
        MOV      R3,#+256
        MOVS     R2,R3
        B.N      ??FLASH_Erase_Sector_1
//  456   }
//  457   else if(VoltageRange == FLASH_VOLTAGE_RANGE_3)
??FLASH_Erase_Sector_2:
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        CMP      R1,#+2
        BNE.N    ??FLASH_Erase_Sector_3
//  458   {
//  459     tmp_psize = FLASH_PSIZE_WORD;
        MOV      R3,#+512
        MOVS     R2,R3
        B.N      ??FLASH_Erase_Sector_1
//  460   }
//  461   else
//  462   {
//  463     tmp_psize = FLASH_PSIZE_DOUBLE_WORD;
??FLASH_Erase_Sector_3:
        MOV      R3,#+768
        MOVS     R2,R3
//  464   }
//  465 
//  466   /* If the previous operation is completed, proceed to erase the sector */
//  467   FLASH->CR &= CR_PSIZE_MASK;
??FLASH_Erase_Sector_1:
        LDR.N    R3,??DataTable15_1  ;; 0x40023c10
        LDR      R3,[R3, #+0]
        BICS     R3,R3,#0x300
        LDR.N    R4,??DataTable15_1  ;; 0x40023c10
        STR      R3,[R4, #+0]
//  468   FLASH->CR |= tmp_psize;
        LDR.N    R3,??DataTable15_1  ;; 0x40023c10
        LDR      R3,[R3, #+0]
        ORRS     R3,R2,R3
        LDR.N    R4,??DataTable15_1  ;; 0x40023c10
        STR      R3,[R4, #+0]
//  469   FLASH->CR &= SECTOR_MASK;
        LDR.N    R3,??DataTable15_1  ;; 0x40023c10
        LDR      R3,[R3, #+0]
        BICS     R3,R3,#0xF8
        LDR.N    R4,??DataTable15_1  ;; 0x40023c10
        STR      R3,[R4, #+0]
//  470   FLASH->CR |= FLASH_CR_SER | (Sector << POSITION_VAL(FLASH_CR_SNB));
        MOVS     R3,#+503316480
        CLZ      R3,R3
        LDR.N    R4,??DataTable15_1  ;; 0x40023c10
        LDR      R4,[R4, #+0]
        LSLS     R3,R0,R3
        ORRS     R3,R3,#0x2
        ORRS     R3,R3,R4
        LDR.N    R4,??DataTable15_1  ;; 0x40023c10
        STR      R3,[R4, #+0]
//  471   FLASH->CR |= FLASH_CR_STRT;
        LDR.N    R3,??DataTable15_1  ;; 0x40023c10
        LDR      R3,[R3, #+0]
        ORRS     R3,R3,#0x10000
        LDR.N    R4,??DataTable15_1  ;; 0x40023c10
        STR      R3,[R4, #+0]
//  472   
//  473   /* Data synchronous Barrier (DSB) Just after the write operation
//  474      This will force the CPU to respect the sequence of instruction (no optimization).*/
//  475   __DSB();
        DSB      
//  476 }
        POP      {R4}
          CFI R4 SameValue
          CFI CFA R13+0
        BX       LR               ;; return
          CFI EndBlock cfiBlock5
//  477 
//  478 /**
//  479   * @brief  Enable the write protection of the desired bank1 or bank 2 sectors
//  480   *
//  481   * @note   When the memory read protection level is selected (RDP level = 1), 
//  482   *         it is not possible to program or erase the flash sector i if CortexM4  
//  483   *         debug features are connected or boot code is executed in RAM, even if nWRPi = 1 
//  484   * @note   Active value of nWRPi bits is inverted when PCROP mode is active (SPRMOD =1).   
//  485   * 
//  486   * @param  WRPSector: specifies the sector(s) to be write protected.
//  487   *          This parameter can be one of the following values:
//  488   *            @arg WRPSector: A value between OB_WRP_SECTOR_0 and OB_WRP_SECTOR_7                      
//  489   *            @arg OB_WRP_SECTOR_All
//  490   *
//  491   * @retval HAL FLASH State   
//  492   */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock6 Using cfiCommon0
          CFI Function FLASH_OB_EnableWRP
        THUMB
//  493 static HAL_StatusTypeDef FLASH_OB_EnableWRP(uint32_t WRPSector)
//  494 {
FLASH_OB_EnableWRP:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
        MOVS     R4,R0
//  495   HAL_StatusTypeDef status = HAL_OK;
        MOVS     R5,#+0
//  496   
//  497   /* Check the parameters */
//  498   assert_param(IS_OB_WRP_SECTOR(WRPSector));
//  499     
//  500   /* Wait for last operation to be completed */
//  501   status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
        MOVW     R0,#+50000
          CFI FunCall FLASH_WaitForLastOperation
        BL       FLASH_WaitForLastOperation
        MOVS     R5,R0
//  502 
//  503   if(status == HAL_OK)
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        CMP      R5,#+0
        BNE.N    ??FLASH_OB_EnableWRP_0
//  504   {
//  505     /*Write protection enabled on sectors */
//  506     FLASH->OPTCR &= (~WRPSector);  
        LDR.N    R0,??DataTable15_3  ;; 0x40023c14
        LDR      R0,[R0, #+0]
        BICS     R0,R0,R4
        LDR.N    R1,??DataTable15_3  ;; 0x40023c14
        STR      R0,[R1, #+0]
//  507   }
//  508   
//  509   return status;
??FLASH_OB_EnableWRP_0:
        MOVS     R0,R5
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        POP      {R1,R4,R5,PC}    ;; return
//  510 }
          CFI EndBlock cfiBlock6
//  511 
//  512 /**
//  513   * @brief  Disable the write protection of the desired bank1 or bank 2 sectors
//  514   *
//  515   * @note   When the memory read protection level is selected (RDP level = 1), 
//  516   *         it is not possible to program or erase the flash sector i if CortexM4  
//  517   *         debug features are connected or boot code is executed in RAM, even if nWRPi = 1  
//  518   * 
//  519   * @param  WRPSector: specifies the sector(s) to be write protected.
//  520   *          This parameter can be one of the following values:
//  521   *            @arg WRPSector: A value between OB_WRP_SECTOR_0 and OB_WRP_SECTOR_7                      
//  522   *            @arg OB_WRP_Sector_All
//  523   *
//  524   *
//  525   * @retval HAL Status   
//  526   */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock7 Using cfiCommon0
          CFI Function FLASH_OB_DisableWRP
        THUMB
//  527 static HAL_StatusTypeDef FLASH_OB_DisableWRP(uint32_t WRPSector)
//  528 {
FLASH_OB_DisableWRP:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
        MOVS     R4,R0
//  529   HAL_StatusTypeDef status = HAL_OK;
        MOVS     R5,#+0
//  530   
//  531   /* Check the parameters */
//  532   assert_param(IS_OB_WRP_SECTOR(WRPSector));
//  533     
//  534   /* Wait for last operation to be completed */
//  535   status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
        MOVW     R0,#+50000
          CFI FunCall FLASH_WaitForLastOperation
        BL       FLASH_WaitForLastOperation
        MOVS     R5,R0
//  536 
//  537   if(status == HAL_OK)
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        CMP      R5,#+0
        BNE.N    ??FLASH_OB_DisableWRP_0
//  538   {
//  539     /* Write protection disabled on sectors */
//  540     FLASH->OPTCR |= (WRPSector); 
        LDR.N    R0,??DataTable15_3  ;; 0x40023c14
        LDR      R0,[R0, #+0]
        ORRS     R0,R4,R0
        LDR.N    R1,??DataTable15_3  ;; 0x40023c14
        STR      R0,[R1, #+0]
//  541   }
//  542 
//  543   return status;
??FLASH_OB_DisableWRP_0:
        MOVS     R0,R5
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        POP      {R1,R4,R5,PC}    ;; return
//  544 }
          CFI EndBlock cfiBlock7
//  545 
//  546 
//  547 
//  548 
//  549 /**
//  550   * @brief  Set the read protection level.
//  551   * @param  Level: specifies the read protection level.
//  552   *          This parameter can be one of the following values:
//  553   *            @arg OB_RDP_LEVEL_0: No protection
//  554   *            @arg OB_RDP_LEVEL_1: Read protection of the memory
//  555   *            @arg OB_RDP_LEVEL_2: Full chip protection
//  556   *   
//  557   * @note WARNING: When enabling OB_RDP level 2 it's no more possible to go back to level 1 or 0
//  558   *    
//  559   * @retval HAL Status
//  560   */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock8 Using cfiCommon0
          CFI Function FLASH_OB_RDP_LevelConfig
        THUMB
//  561 static HAL_StatusTypeDef FLASH_OB_RDP_LevelConfig(uint32_t Level)
//  562 {
FLASH_OB_RDP_LevelConfig:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
        MOVS     R4,R0
//  563   HAL_StatusTypeDef status = HAL_OK;
        MOVS     R5,#+0
//  564   
//  565   /* Check the parameters */
//  566   assert_param(IS_OB_RDP_LEVEL(Level));
//  567     
//  568   /* Wait for last operation to be completed */
//  569   status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
        MOVW     R0,#+50000
          CFI FunCall FLASH_WaitForLastOperation
        BL       FLASH_WaitForLastOperation
        MOVS     R5,R0
//  570 
//  571   if(status == HAL_OK)
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        CMP      R5,#+0
        BNE.N    ??FLASH_OB_RDP_LevelConfig_0
//  572   { 
//  573     MODIFY_REG(FLASH->OPTCR, FLASH_OPTCR_RDP, Level);
        LDR.N    R0,??DataTable15_3  ;; 0x40023c14
        LDR      R0,[R0, #+0]
        BICS     R0,R0,#0xFF00
        ORRS     R0,R4,R0
        LDR.N    R1,??DataTable15_3  ;; 0x40023c14
        STR      R0,[R1, #+0]
//  574   }
//  575   
//  576   return status;
??FLASH_OB_RDP_LevelConfig_0:
        MOVS     R0,R5
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        POP      {R1,R4,R5,PC}    ;; return
//  577 }
          CFI EndBlock cfiBlock8
//  578 
//  579 /**
//  580   * @brief  Program the FLASH User Option Byte: IWDG_SW / RST_STOP / RST_STDBY.    
//  581   * @param  Wwdg: Selects the IWDG mode
//  582   *          This parameter can be one of the following values:
//  583   *            @arg OB_WWDG_SW: Software WWDG selected
//  584   *            @arg OB_WWDG_HW: Hardware WWDG selected
//  585   * @param  Iwdg: Selects the WWDG mode
//  586   *          This parameter can be one of the following values:
//  587   *            @arg OB_IWDG_SW: Software IWDG selected
//  588   *            @arg OB_IWDG_HW: Hardware IWDG selected
//  589   * @param  Stop: Reset event when entering STOP mode.
//  590   *          This parameter  can be one of the following values:
//  591   *            @arg OB_STOP_NO_RST: No reset generated when entering in STOP
//  592   *            @arg OB_STOP_RST: Reset generated when entering in STOP
//  593   * @param  Stdby: Reset event when entering Standby mode.
//  594   *          This parameter  can be one of the following values:
//  595   *            @arg OB_STDBY_NO_RST: No reset generated when entering in STANDBY
//  596   *            @arg OB_STDBY_RST: Reset generated when entering in STANDBY
//  597   * @param  Iwdgstop: Independent watchdog counter freeze in Stop mode.
//  598   *          This parameter  can be one of the following values:
//  599   *            @arg OB_IWDG_STOP_FREEZE: Freeze IWDG counter in STOP
//  600   *            @arg OB_IWDG_STOP_ACTIVE: IWDG counter active in STOP
//  601   * @param  Iwdgstdby: Independent watchdog counter freeze in standby mode.
//  602   *          This parameter  can be one of the following values:
//  603   *            @arg OB_IWDG_STDBY_FREEZE: Freeze IWDG counter in STANDBY
//  604   *            @arg OB_IWDG_STDBY_ACTIVE: IWDG counter active in STANDBY           
//  605   * @retval HAL Status
//  606   */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock9 Using cfiCommon0
          CFI Function FLASH_OB_UserConfig
        THUMB
//  607 static HAL_StatusTypeDef FLASH_OB_UserConfig(uint32_t Wwdg, uint32_t Iwdg, uint32_t Stop, uint32_t Stdby, uint32_t Iwdgstop, uint32_t Iwdgstdby )
//  608 {
FLASH_OB_UserConfig:
        PUSH     {R0,R4-R11,LR}
          CFI R14 Frame(CFA, -4)
          CFI R11 Frame(CFA, -8)
          CFI R10 Frame(CFA, -12)
          CFI R9 Frame(CFA, -16)
          CFI R8 Frame(CFA, -20)
          CFI R7 Frame(CFA, -24)
          CFI R6 Frame(CFA, -28)
          CFI R5 Frame(CFA, -32)
          CFI R4 Frame(CFA, -36)
          CFI CFA R13+40
        MOVS     R4,R1
        MOVS     R5,R2
        MOVS     R6,R3
        LDR      R7,[SP, #+40]
        LDR      R8,[SP, #+44]
//  609   uint32_t useroptionmask = 0x00;
        MOVS     R9,#+0
//  610   uint32_t useroptionvalue = 0x00;
        MOVS     R10,#+0
//  611 
//  612   HAL_StatusTypeDef status = HAL_OK;
        MOVS     R11,#+0
//  613 
//  614   /* Check the parameters */
//  615   assert_param(IS_OB_WWDG_SOURCE(Wwdg));
//  616   assert_param(IS_OB_IWDG_SOURCE(Iwdg));
//  617   assert_param(IS_OB_STOP_SOURCE(Stop));
//  618   assert_param(IS_OB_STDBY_SOURCE(Stdby));
//  619   assert_param(IS_OB_IWDG_STOP_FREEZE(Iwdgstop));
//  620   assert_param(IS_OB_IWDG_STDBY_FREEZE(Iwdgstdby));
//  621 
//  622   /* Wait for last operation to be completed */
//  623   status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
        MOVW     R0,#+50000
          CFI FunCall FLASH_WaitForLastOperation
        BL       FLASH_WaitForLastOperation
        MOV      R11,R0
//  624   
//  625   if(status == HAL_OK)
        UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
        CMP      R11,#+0
        BNE.N    ??FLASH_OB_UserConfig_0
//  626   {
//  627     useroptionmask = (FLASH_OPTCR_WWDG_SW | FLASH_OPTCR_IWDG_SW | FLASH_OPTCR_nRST_STOP | \ 
//  628                       FLASH_OPTCR_nRST_STDBY | FLASH_OPTCR_IWDG_STOP | FLASH_OPTCR_IWDG_STDBY);
        LDR.N    R0,??DataTable15_4  ;; 0xc00000f0
        MOV      R9,R0
//  629                       
//  630     useroptionvalue = (Iwdg | Wwdg | Stop | Stdby | Iwdgstop | Iwdgstdby);
        LDR      R0,[SP, #+0]
        ORRS     R0,R0,R4
        ORRS     R0,R5,R0
        ORRS     R0,R6,R0
        ORRS     R0,R7,R0
        ORRS     R0,R8,R0
        MOV      R10,R0
//  631         
//  632     /* Update User Option Byte */               
//  633     MODIFY_REG(FLASH->OPTCR, useroptionmask, useroptionvalue);
        LDR.N    R0,??DataTable15_3  ;; 0x40023c14
        LDR      R0,[R0, #+0]
        BICS     R0,R0,R9
        ORRS     R0,R10,R0
        LDR.N    R1,??DataTable15_3  ;; 0x40023c14
        STR      R0,[R1, #+0]
//  634   }
//  635   
//  636   return status; 
??FLASH_OB_UserConfig_0:
        MOV      R0,R11
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        POP      {R1,R4-R11,PC}   ;; return
//  637 
//  638 }
          CFI EndBlock cfiBlock9
//  639 
//  640 /**
//  641   * @brief  Set the BOR Level. 
//  642   * @param  Level: specifies the Option Bytes BOR Reset Level.
//  643   *          This parameter can be one of the following values:
//  644   *            @arg OB_BOR_LEVEL3: Supply voltage ranges from 2.7 to 3.6 V
//  645   *            @arg OB_BOR_LEVEL2: Supply voltage ranges from 2.4 to 2.7 V
//  646   *            @arg OB_BOR_LEVEL1: Supply voltage ranges from 2.1 to 2.4 V
//  647   *            @arg OB_BOR_OFF: Supply voltage ranges from 1.62 to 2.1 V
//  648   * @retval HAL Status
//  649   */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock10 Using cfiCommon0
          CFI Function FLASH_OB_BOR_LevelConfig
          CFI NoCalls
        THUMB
//  650 static HAL_StatusTypeDef FLASH_OB_BOR_LevelConfig(uint8_t Level)
//  651 {
FLASH_OB_BOR_LevelConfig:
        MOVS     R1,R0
//  652   /* Check the parameters */
//  653   assert_param(IS_OB_BOR_LEVEL(Level));
//  654 
//  655   /* Set the BOR Level */
//  656   MODIFY_REG(FLASH->OPTCR, FLASH_OPTCR_BOR_LEV, Level);
        LDR.N    R0,??DataTable15_3  ;; 0x40023c14
        LDR      R0,[R0, #+0]
        BICS     R0,R0,#0xC
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        ORRS     R0,R1,R0
        LDR.N    R2,??DataTable15_3  ;; 0x40023c14
        STR      R0,[R2, #+0]
//  657   
//  658   return HAL_OK;
        MOVS     R0,#+0
        BX       LR               ;; return
//  659   
//  660 }
          CFI EndBlock cfiBlock10
//  661 
//  662 /**
//  663   * @brief  Configure Boot base address.
//  664   * 
//  665   * @param   BootOption : specifies Boot base address depending from Boot pin = 0 or pin = 1
//  666   *          This parameter can be one of the following values:
//  667   *            @arg OPTIONBYTE_BOOTADDR_0 : Boot address based when Boot pin = 0                 
//  668   *            @arg OPTIONBYTE_BOOTADDR_1 : Boot address based when Boot pin = 1  
//  669   * @param   Address: specifies Boot base address
//  670   *          This parameter can be one of the following values:
//  671   *            @arg OB_BOOTADDR_ITCM_RAM : Boot from ITCM RAM (0x00000000)                 
//  672   *            @arg OB_BOOTADDR_SYSTEM : Boot from System memory bootloader (0x00100000) 
//  673   *            @arg OB_BOOTADDR_ITCM_FLASH : Boot from Flash on ITCM interface (0x00200000)  
//  674   *            @arg OB_BOOTADDR_AXIM_FLASH : Boot from Flash on AXIM interface (0x08000000)  
//  675   *            @arg OB_BOOTADDR_DTCM_RAM : Boot from DTCM RAM (0x20000000)                 
//  676   *            @arg OB_BOOTADDR_SRAM1 : Boot from SRAM1 (0x20010000)                    
//  677   *            @arg OB_BOOTADDR_SRAM2 : Boot from SRAM2 (0x2004C000)              
//  678   *    
//  679   * @retval HAL Status
//  680   */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock11 Using cfiCommon0
          CFI Function FLASH_OB_BootAddressConfig
        THUMB
//  681 static HAL_StatusTypeDef FLASH_OB_BootAddressConfig(uint32_t BootOption, uint32_t Address)
//  682 {
FLASH_OB_BootAddressConfig:
        PUSH     {R4-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
        MOVS     R4,R0
        MOVS     R5,R1
//  683   HAL_StatusTypeDef status = HAL_OK;
        MOVS     R6,#+0
//  684   
//  685   /* Check the parameters */
//  686   assert_param(IS_OB_BOOT_ADDRESS(Address));
//  687     
//  688   /* Wait for last operation to be completed */
//  689   status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
        MOVW     R0,#+50000
          CFI FunCall FLASH_WaitForLastOperation
        BL       FLASH_WaitForLastOperation
        MOVS     R6,R0
//  690 
//  691   if(status == HAL_OK)
        UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
        CMP      R6,#+0
        BNE.N    ??FLASH_OB_BootAddressConfig_0
//  692   {
//  693     if(BootOption == OPTIONBYTE_BOOTADDR_0)
        CMP      R4,#+16
        BNE.N    ??FLASH_OB_BootAddressConfig_1
//  694     {			
//  695       MODIFY_REG(FLASH->OPTCR1, FLASH_OPTCR1_BOOT_ADD0, Address);
        LDR.N    R0,??DataTable15_5  ;; 0x40023c18
        LDR      R0,[R0, #+0]
        LSRS     R0,R0,#+16
        LSLS     R0,R0,#+16
        ORRS     R0,R5,R0
        LDR.N    R1,??DataTable15_5  ;; 0x40023c18
        STR      R0,[R1, #+0]
        B.N      ??FLASH_OB_BootAddressConfig_0
//  696 	  }
//  697 		else
//  698 		{
//  699 			MODIFY_REG(FLASH->OPTCR1, FLASH_OPTCR1_BOOT_ADD1, (Address << 16));
??FLASH_OB_BootAddressConfig_1:
        LDR.N    R0,??DataTable15_5  ;; 0x40023c18
        LDR      R0,[R0, #+0]
        PKHBT    R0,R0,R5, LSL #+16
        LDR.N    R1,??DataTable15_5  ;; 0x40023c18
        STR      R0,[R1, #+0]
//  700 		}
//  701   }
//  702   
//  703   return status;
??FLASH_OB_BootAddressConfig_0:
        MOVS     R0,R6
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        POP      {R4-R6,PC}       ;; return
//  704 }
          CFI EndBlock cfiBlock11
//  705 
//  706 /**
//  707   * @brief  Return the FLASH User Option Byte value.
//  708   * @retval uint32_t FLASH User Option Bytes values: IWDG_SW(Bit0), RST_STOP(Bit1)
//  709   *         and RST_STDBY(Bit2).
//  710   */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock12 Using cfiCommon0
          CFI Function FLASH_OB_GetUser
          CFI NoCalls
        THUMB
//  711 static uint32_t FLASH_OB_GetUser(void)
//  712 {
//  713   /* Return the User Option Byte */
//  714   return ((uint32_t)(FLASH->OPTCR & 0xC00000F0));
FLASH_OB_GetUser:
        LDR.N    R0,??DataTable15_3  ;; 0x40023c14
        LDR      R0,[R0, #+0]
        LDR.N    R1,??DataTable15_4  ;; 0xc00000f0
        ANDS     R0,R1,R0
        BX       LR               ;; return
//  715 }
          CFI EndBlock cfiBlock12
//  716 
//  717 /**
//  718   * @brief  Return the FLASH Write Protection Option Bytes value.
//  719   * @retval uint32_t FLASH Write Protection Option Bytes value
//  720   */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock13 Using cfiCommon0
          CFI Function FLASH_OB_GetWRP
          CFI NoCalls
        THUMB
//  721 static uint32_t FLASH_OB_GetWRP(void)
//  722 {
//  723   /* Return the FLASH write protection Register value */
//  724   return ((uint32_t)(FLASH->OPTCR & 0x00FF0000));
FLASH_OB_GetWRP:
        LDR.N    R0,??DataTable15_3  ;; 0x40023c14
        LDR      R0,[R0, #+0]
        ANDS     R0,R0,#0xFF0000
        BX       LR               ;; return
//  725 }
          CFI EndBlock cfiBlock13
//  726 
//  727 /**
//  728   * @brief  Returns the FLASH Read Protection level.
//  729   * @retval FlagStatus FLASH ReadOut Protection Status:
//  730   *         This parameter can be one of the following values:
//  731   *            @arg OB_RDP_LEVEL_0: No protection
//  732   *            @arg OB_RDP_LEVEL_1: Read protection of the memory
//  733   *            @arg OB_RDP_LEVEL_2: Full chip protection
//  734   */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock14 Using cfiCommon0
          CFI Function FLASH_OB_GetRDP
          CFI NoCalls
        THUMB
//  735 static uint8_t FLASH_OB_GetRDP(void)
//  736 {
//  737   uint8_t readstatus = OB_RDP_LEVEL_0;
FLASH_OB_GetRDP:
        MOVS     R0,#+170
//  738   
//  739   if (((FLASH->OPTCR & FLASH_OPTCR_RDP) >> 8) == OB_RDP_LEVEL_0)
        LDR.N    R1,??DataTable15_3  ;; 0x40023c14
        LDR      R1,[R1, #+0]
        UBFX     R1,R1,#+8,#+8
        CMP      R1,#+170
        BNE.N    ??FLASH_OB_GetRDP_0
//  740   {
//  741     readstatus = OB_RDP_LEVEL_0;
        MOVS     R1,#+170
        MOVS     R0,R1
        B.N      ??FLASH_OB_GetRDP_1
//  742   }
//  743   else if (((FLASH->OPTCR & FLASH_OPTCR_RDP) >> 8) == OB_RDP_LEVEL_2)
??FLASH_OB_GetRDP_0:
        LDR.N    R1,??DataTable15_3  ;; 0x40023c14
        LDR      R1,[R1, #+0]
        UBFX     R1,R1,#+8,#+8
        CMP      R1,#+204
        BNE.N    ??FLASH_OB_GetRDP_2
//  744   {
//  745     readstatus = OB_RDP_LEVEL_2;
        MOVS     R1,#+204
        MOVS     R0,R1
        B.N      ??FLASH_OB_GetRDP_1
//  746   }
//  747   else 
//  748   {
//  749     readstatus = OB_RDP_LEVEL_1;
??FLASH_OB_GetRDP_2:
        MOVS     R1,#+85
        MOVS     R0,R1
//  750   }
//  751 
//  752   return readstatus;
??FLASH_OB_GetRDP_1:
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BX       LR               ;; return
//  753 }
          CFI EndBlock cfiBlock14
//  754 
//  755 /**
//  756   * @brief  Returns the FLASH BOR level.
//  757   * @retval uint32_t The FLASH BOR level:
//  758   *           - OB_BOR_LEVEL3: Supply voltage ranges from 2.7 to 3.6 V
//  759   *           - OB_BOR_LEVEL2: Supply voltage ranges from 2.4 to 2.7 V
//  760   *           - OB_BOR_LEVEL1: Supply voltage ranges from 2.1 to 2.4 V
//  761   *           - OB_BOR_OFF   : Supply voltage ranges from 1.62 to 2.1 V  
//  762   */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock15 Using cfiCommon0
          CFI Function FLASH_OB_GetBOR
          CFI NoCalls
        THUMB
//  763 static uint32_t FLASH_OB_GetBOR(void)
//  764 {
//  765   /* Return the FLASH BOR level */
//  766   return ((uint32_t)(FLASH->OPTCR & 0x0C));
FLASH_OB_GetBOR:
        LDR.N    R0,??DataTable15_3  ;; 0x40023c14
        LDR      R0,[R0, #+0]
        ANDS     R0,R0,#0xC
        BX       LR               ;; return
//  767 }
          CFI EndBlock cfiBlock15
//  768 
//  769 /**
//  770   * @brief  Configure Boot base address.
//  771   * 
//  772   * @param   BootOption : specifies Boot base address depending from Boot pin = 0 or pin = 1
//  773   *          This parameter can be one of the following values:
//  774   *            @arg OPTIONBYTE_BOOTADDR_0 : Boot address based when Boot pin = 0                 
//  775   *            @arg OPTIONBYTE_BOOTADDR_1 : Boot address based when Boot pin = 1       
//  776   *    
//  777   * @retval uint32_t Boot Base Address:
//  778   *            - OB_BOOTADDR_ITCM_RAM : Boot from ITCM RAM (0x00000000)                 
//  779   *            - OB_BOOTADDR_SYSTEM : Boot from System memory bootloader (0x00100000) 
//  780   *            - OB_BOOTADDR_ITCM_FLASH : Boot from Flash on ITCM interface (0x00200000)  
//  781   *            - OB_BOOTADDR_AXIM_FLASH : Boot from Flash on AXIM interface (0x08000000)  
//  782   *            - OB_BOOTADDR_DTCM_RAM : Boot from DTCM RAM (0x20000000)                 
//  783   *            - OB_BOOTADDR_SRAM1 : Boot from SRAM1 (0x20010000)                    
//  784   *            - OB_BOOTADDR_SRAM2 : Boot from SRAM2 (0x2004C000) 
//  785   */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock16 Using cfiCommon0
          CFI Function FLASH_OB_GetBootAddress
          CFI NoCalls
        THUMB
//  786 static uint32_t FLASH_OB_GetBootAddress(uint32_t BootOption)
//  787 {  
FLASH_OB_GetBootAddress:
        MOVS     R1,R0
//  788   uint32_t Address = 0;
        MOVS     R0,#+0
//  789     
//  790 	/* Return the Boot base Address */
//  791   if(BootOption == OPTIONBYTE_BOOTADDR_0)
        CMP      R1,#+16
        BNE.N    ??FLASH_OB_GetBootAddress_0
//  792   {			
//  793     Address = FLASH->OPTCR1 & FLASH_OPTCR1_BOOT_ADD0;
        LDR.N    R2,??DataTable15_5  ;; 0x40023c18
        LDR      R2,[R2, #+0]
        UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
        MOVS     R0,R2
        B.N      ??FLASH_OB_GetBootAddress_1
//  794 	}
//  795   else
//  796 	{
//  797 		Address = ((FLASH->OPTCR1 & FLASH_OPTCR1_BOOT_ADD1) >> 16);
??FLASH_OB_GetBootAddress_0:
        LDR.N    R2,??DataTable15_5  ;; 0x40023c18
        LDR      R2,[R2, #+0]
        LSRS     R2,R2,#+16
        MOVS     R0,R2
//  798 	}
//  799 
//  800   return Address;
??FLASH_OB_GetBootAddress_1:
        BX       LR               ;; return
//  801 }
          CFI EndBlock cfiBlock16

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable15:
        DC32     pFlash

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable15_1:
        DC32     0x40023c10

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable15_2:
        DC32     0x40023c0c

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable15_3:
        DC32     0x40023c14

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable15_4:
        DC32     0xc00000f0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable15_5:
        DC32     0x40023c18

        SECTION `.iar_vfe_header`:DATA:NOALLOC:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
        DC32 0

        SECTION __DLIB_PERTHREAD:DATA:REORDER:NOROOT(0)
        SECTION_TYPE SHT_PROGBITS, 0

        SECTION __DLIB_PERTHREAD_init:DATA:REORDER:NOROOT(0)
        SECTION_TYPE SHT_PROGBITS, 0

        END
//  802 
//  803 /**
//  804   * @}
//  805   */
//  806   
//  807 #endif /* HAL_FLASH_MODULE_ENABLED */
//  808 
//  809 /**
//  810   * @}
//  811   */
//  812 
//  813 /**
//  814   * @}
//  815   */
//  816 
//  817 /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
// 
// 1 164 bytes in section .text
// 
// 1 164 bytes of CODE memory
//
//Errors: none
//Warnings: none
