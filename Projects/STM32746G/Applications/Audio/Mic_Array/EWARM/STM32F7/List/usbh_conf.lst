###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.2.10312/W32 for ARM       22/Dec/2015  15:52:44
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\sop1hc\Github\data\Mic_Array_V00\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\Src\usbh_conf.c
#    Command line =  
#        D:\sop1hc\Github\data\Mic_Array_V00\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\Src\usbh_conf.c
#        -D USE_HAL_DRIVER -D STM32F746xx -D USE_STM32746G_DISCO -D
#        USE_IOEXPANDER -D USE_USB_FS -lC
#        D:\sop1hc\Github\data\Mic_Array_V00\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
#        -lA
#        D:\sop1hc\Github\data\Mic_Array_V00\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
#        -o
#        D:\sop1hc\Github\data\Mic_Array_V00\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj
#        --debug --endian=little --cpu=Cortex-M7 -e --fpu=VFPv5_sp
#        --dlib_config "D:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Full.h" -I
#        D:\sop1hc\Github\data\Mic_Array_V00\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\CMSIS\Device\ST\STM32F7xx\Include\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\STM32F7xx_HAL_Driver\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\STM32746G-Discovery\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\Components\Common\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Log\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Fonts\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\CPU\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_Device_Library\Core\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Core\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Class\MSC\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\drivers\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_Audio\Addons\PDM\
#        -Ohz --use_c++_inline --require_prototypes -I "D:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.3\arm\CMSIS\Include\" -D
#        ARM_MATH_CM7
#    List file    =  
#        D:\sop1hc\Github\data\Mic_Array_V00\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List\usbh_conf.lst
#    Object file  =  
#        D:\sop1hc\Github\data\Mic_Array_V00\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj\usbh_conf.o
#
###############################################################################

D:\sop1hc\Github\data\Mic_Array_V00\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\Src\usbh_conf.c
      1          /**
      2            ******************************************************************************
      3            * @file    Audio/Audio_playback_and_record/Src/usbh_conf.c
      4            * @author  MCD Application Team
      5            * @version V1.0.0
      6            * @date    25-June-2015
      7            * @brief   USB Host configuration file.
      8            ******************************************************************************
      9            * @attention
     10            *
     11            * <h2><center>&copy; COPYRIGHT(c) 2015 STMicroelectronics</center></h2>
     12            *
     13            * Redistribution and use in source and binary forms, with or without modification,
     14            * are permitted provided that the following conditions are met:
     15            *   1. Redistributions of source code must retain the above copyright notice,
     16            *      this list of conditions and the following disclaimer.
     17            *   2. Redistributions in binary form must reproduce the above copyright notice,
     18            *      this list of conditions and the following disclaimer in the documentation
     19            *      and/or other materials provided with the distribution.
     20            *   3. Neither the name of STMicroelectronics nor the names of its contributors
     21            *      may be used to endorse or promote products derived from this software
     22            *      without specific prior written permission.
     23            *
     24            * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
     25            * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     26            * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     27            * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
     28            * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
     29            * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
     30            * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
     31            * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
     32            * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
     33            * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     34            *
     35            ******************************************************************************
     36            */
     37          
     38          /* Includes ------------------------------------------------------------------*/
     39          #include "stm32f7xx_hal.h"
     40          #include "usbh_core.h"
     41          #include "stm32746g_discovery.h"
     42          

   \                                 In section .bss, align 4
     43          HCD_HandleTypeDef hhcd;
   \                     hhcd:
   \   00000000                      DS8 660
     44          
     45          /*******************************************************************************
     46                                 HCD BSP Routines
     47          *******************************************************************************/
     48          /**
     49            * @brief  Initializes the HCD MSP.
     50            * @param  hhcd: HCD handle
     51            * @retval None
     52            */

   \                                 In section .text, align 2, keep-with-next
     53          void HAL_HCD_MspInit(HCD_HandleTypeDef *hhcd)
     54          {
   \                     HAL_HCD_MspInit: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB087             SUB      SP,SP,#+28
     55            GPIO_InitTypeDef  GPIO_InitStruct;
     56            
     57            if(hhcd->Instance == USB_OTG_FS)
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x....             LDR.N    R5,??DataTable5  ;; 0x40020000
   \   00000008   0x....             LDR.N    R4,??DataTable5_1  ;; 0x40023830
   \   0000000A   0xF1B0 0x4FA0      CMP      R0,#+1342177280
   \   0000000E   0xD130             BNE.N    ??HAL_HCD_MspInit_0
     58            {
     59              /* Configure USB FS GPIOs */
     60              __HAL_RCC_GPIOA_CLK_ENABLE();
   \   00000010   0x.... 0x....      BL       ?Subroutine3
     61              __HAL_RCC_GPIOD_CLK_ENABLE();
     62              
     63              GPIO_InitStruct.Pin = (GPIO_PIN_11 | GPIO_PIN_12);
     64              GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
     65              GPIO_InitStruct.Pull = GPIO_NOPULL;
     66              GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
     67              GPIO_InitStruct.Alternate = GPIO_AF10_OTG_FS;
     68              HAL_GPIO_Init(GPIOA, &GPIO_InitStruct); 
   \                     ??CrossCallReturnLabel_7: (+1)
   \   00000014   0xF040 0x0008      ORR      R0,R0,#0x8
   \   00000018   0x6020             STR      R0,[R4, #+0]
   \   0000001A   0x6820             LDR      R0,[R4, #+0]
   \   0000001C   0xF000 0x0008      AND      R0,R0,#0x8
   \   00000020   0x9000             STR      R0,[SP, #+0]
   \   00000022   0x9800             LDR      R0,[SP, #+0]
   \   00000024   0xF44F 0x50C0      MOV      R0,#+6144
   \   00000028   0x.... 0x....      BL       ?Subroutine1
     69              
     70              /* Configure POWER_SWITCH IO pin */
     71              GPIO_InitStruct.Pin = GPIO_PIN_5;
   \                     ??CrossCallReturnLabel_2: (+1)
   \   0000002C   0x2020             MOVS     R0,#+32
     72              GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
     73              GPIO_InitStruct.Pull = GPIO_NOPULL;
     74              HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
   \   0000002E   0xA901             ADD      R1,SP,#+4
   \   00000030   0x9001             STR      R0,[SP, #+4]
   \   00000032   0x2002             MOVS     R0,#+2
   \   00000034   0x9002             STR      R0,[SP, #+8]
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0x9003             STR      R0,[SP, #+12]
   \   0000003A   0x....             LDR.N    R0,??DataTable5_2  ;; 0x40020c00
   \   0000003C   0x.... 0x....      BL       HAL_GPIO_Init
     75              
     76              /* Enable USB FS Clocks */ 
     77              __HAL_RCC_USB_OTG_FS_CLK_ENABLE();
   \   00000040   0x6860             LDR      R0,[R4, #+4]
     78              
     79              /* Set USBFS Interrupt to the lowest priority */
     80              HAL_NVIC_SetPriority(OTG_FS_IRQn, 6, 0);
   \   00000042   0x2200             MOVS     R2,#+0
   \   00000044   0x2106             MOVS     R1,#+6
   \   00000046   0xF040 0x0080      ORR      R0,R0,#0x80
   \   0000004A   0x6060             STR      R0,[R4, #+4]
   \   0000004C   0x6860             LDR      R0,[R4, #+4]
   \   0000004E   0xF000 0x0080      AND      R0,R0,#0x80
   \   00000052   0x9000             STR      R0,[SP, #+0]
   \   00000054   0x9800             LDR      R0,[SP, #+0]
   \   00000056   0x6960             LDR      R0,[R4, #+20]
   \   00000058   0xF440 0x4080      ORR      R0,R0,#0x4000
   \   0000005C   0x6160             STR      R0,[R4, #+20]
   \   0000005E   0x6960             LDR      R0,[R4, #+20]
   \   00000060   0xF400 0x4080      AND      R0,R0,#0x4000
   \   00000064   0x9000             STR      R0,[SP, #+0]
   \   00000066   0x9800             LDR      R0,[SP, #+0]
   \   00000068   0x2043             MOVS     R0,#+67
   \   0000006A   0x.... 0x....      BL       HAL_NVIC_SetPriority
     81              
     82              /* Enable USBFS Interrupt */
     83              HAL_NVIC_EnableIRQ(OTG_FS_IRQn);
   \   0000006E   0x2043             MOVS     R0,#+67
   \   00000070   0xE058             B.N      ??HAL_HCD_MspInit_1
     84            } 
     85            else if(hhcd->Instance == USB_OTG_HS)
   \                     ??HAL_HCD_MspInit_0: (+1)
   \   00000072   0x....             LDR.N    R1,??DataTable5_3  ;; 0x40040000
   \   00000074   0x4288             CMP      R0,R1
   \   00000076   0xD157             BNE.N    ??HAL_HCD_MspInit_2
     86            {
     87              /* Configure USB HS GPIOs */
     88              __HAL_RCC_GPIOA_CLK_ENABLE();
   \   00000078   0x.... 0x....      BL       ?Subroutine3
     89              __HAL_RCC_GPIOB_CLK_ENABLE();
     90              __HAL_RCC_GPIOC_CLK_ENABLE();
     91              __HAL_RCC_GPIOH_CLK_ENABLE();
     92          	
     93              /* CLK */
     94              GPIO_InitStruct.Pin = GPIO_PIN_5;
     95              GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
     96              GPIO_InitStruct.Pull = GPIO_NOPULL;
     97              GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
     98              GPIO_InitStruct.Alternate = GPIO_AF10_OTG_HS;
     99              HAL_GPIO_Init(GPIOA, &GPIO_InitStruct); 
   \                     ??CrossCallReturnLabel_8: (+1)
   \   0000007C   0xF040 0x0002      ORR      R0,R0,#0x2
   \   00000080   0x6020             STR      R0,[R4, #+0]
   \   00000082   0x6820             LDR      R0,[R4, #+0]
   \   00000084   0xF000 0x0002      AND      R0,R0,#0x2
   \   00000088   0x9000             STR      R0,[SP, #+0]
   \   0000008A   0x9800             LDR      R0,[SP, #+0]
   \   0000008C   0x6820             LDR      R0,[R4, #+0]
   \   0000008E   0xF040 0x0004      ORR      R0,R0,#0x4
   \   00000092   0x6020             STR      R0,[R4, #+0]
   \   00000094   0x6820             LDR      R0,[R4, #+0]
   \   00000096   0xF000 0x0004      AND      R0,R0,#0x4
   \   0000009A   0x9000             STR      R0,[SP, #+0]
   \   0000009C   0x9800             LDR      R0,[SP, #+0]
   \   0000009E   0x6820             LDR      R0,[R4, #+0]
   \   000000A0   0xF040 0x0080      ORR      R0,R0,#0x80
   \   000000A4   0x6020             STR      R0,[R4, #+0]
   \   000000A6   0x6820             LDR      R0,[R4, #+0]
   \   000000A8   0xF000 0x0080      AND      R0,R0,#0x80
   \   000000AC   0x9000             STR      R0,[SP, #+0]
   \   000000AE   0x9800             LDR      R0,[SP, #+0]
   \   000000B0   0x2020             MOVS     R0,#+32
   \   000000B2   0x.... 0x....      BL       ?Subroutine1
    100              
    101              /* D0 */
    102              GPIO_InitStruct.Pin = GPIO_PIN_3;
   \                     ??CrossCallReturnLabel_1: (+1)
   \   000000B6   0x2008             MOVS     R0,#+8
    103              GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    104              GPIO_InitStruct.Pull = GPIO_NOPULL;
    105              GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
    106              GPIO_InitStruct.Alternate = GPIO_AF10_OTG_HS;
    107              HAL_GPIO_Init(GPIOA, &GPIO_InitStruct); 
   \   000000B8   0xA901             ADD      R1,SP,#+4
   \   000000BA   0x.... 0x....      BL       ?Subroutine1
    108              
    109              /* D1 D2 D3 D4 D5 D6 D7 */
    110              GPIO_InitStruct.Pin = GPIO_PIN_0  | GPIO_PIN_1  | GPIO_PIN_5 |\
    111                GPIO_PIN_10 | GPIO_PIN_11 | GPIO_PIN_12 | GPIO_PIN_13;
   \                     ??CrossCallReturnLabel_0: (+1)
   \   000000BE   0xF643 0x4023      MOVW     R0,#+15395
    112              GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    113              GPIO_InitStruct.Pull = GPIO_NOPULL;
    114              GPIO_InitStruct.Alternate = GPIO_AF10_OTG_HS;
    115              HAL_GPIO_Init(GPIOB, &GPIO_InitStruct); 
   \   000000C2   0x.... 0x....      BL       ?Subroutine2
   \                     ??CrossCallReturnLabel_3: (+1)
   \   000000C6   0x....             LDR.N    R0,??DataTable5_4  ;; 0x40020400
   \   000000C8   0x.... 0x....      BL       HAL_GPIO_Init
    116              
    117              /* STP */     
    118              GPIO_InitStruct.Pin = GPIO_PIN_0;
   \   000000CC   0x2001             MOVS     R0,#+1
    119              GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    120              GPIO_InitStruct.Pull = GPIO_NOPULL;
    121              GPIO_InitStruct.Alternate = GPIO_AF10_OTG_HS;
    122              HAL_GPIO_Init(GPIOC, &GPIO_InitStruct); 
   \   000000CE   0x....             LDR.N    R5,??DataTable5_5  ;; 0x40020800
   \   000000D0   0x.... 0x....      BL       ??Subroutine2_0
   \                     ??CrossCallReturnLabel_4: (+1)
   \   000000D4   0xA901             ADD      R1,SP,#+4
   \   000000D6   0x4628             MOV      R0,R5
   \   000000D8   0x.... 0x....      BL       HAL_GPIO_Init
    123              
    124              /* NXT */ 
    125              GPIO_InitStruct.Pin = GPIO_PIN_4;
   \   000000DC   0x2010             MOVS     R0,#+16
    126              GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    127              GPIO_InitStruct.Pull = GPIO_NOPULL;
    128              GPIO_InitStruct.Alternate = GPIO_AF10_OTG_HS;
    129              HAL_GPIO_Init(GPIOH, &GPIO_InitStruct);
   \   000000DE   0x.... 0x....      BL       ?Subroutine2
   \                     ??CrossCallReturnLabel_5: (+1)
   \   000000E2   0x....             LDR.N    R0,??DataTable5_6  ;; 0x40021c00
   \   000000E4   0x.... 0x....      BL       HAL_GPIO_Init
    130              
    131              /* DIR */
    132              GPIO_InitStruct.Pin = GPIO_PIN_2;
   \   000000E8   0x2004             MOVS     R0,#+4
    133              GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    134              GPIO_InitStruct.Pull = GPIO_NOPULL;
    135              GPIO_InitStruct.Alternate = GPIO_AF10_OTG_HS;
    136              HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
   \   000000EA   0x.... 0x....      BL       ?Subroutine2
   \                     ??CrossCallReturnLabel_6: (+1)
   \   000000EE   0x4628             MOV      R0,R5
   \   000000F0   0x.... 0x....      BL       HAL_GPIO_Init
    137              __HAL_RCC_USB_OTG_HS_ULPI_CLK_ENABLE();
   \   000000F4   0x6820             LDR      R0,[R4, #+0]
    138          
    139              /* Enable USB HS Clocks */ 
    140              __HAL_RCC_USB_OTG_HS_CLK_ENABLE();
    141              
    142              /* Set USBHS Interrupt to the lowest priority */
    143              HAL_NVIC_SetPriority(OTG_HS_IRQn, 6, 0);
   \   000000F6   0x2200             MOVS     R2,#+0
   \   000000F8   0x2106             MOVS     R1,#+6
   \   000000FA   0xF040 0x4080      ORR      R0,R0,#0x40000000
   \   000000FE   0x6020             STR      R0,[R4, #+0]
   \   00000100   0x6820             LDR      R0,[R4, #+0]
   \   00000102   0xF000 0x4080      AND      R0,R0,#0x40000000
   \   00000106   0x9000             STR      R0,[SP, #+0]
   \   00000108   0x9800             LDR      R0,[SP, #+0]
   \   0000010A   0x6820             LDR      R0,[R4, #+0]
   \   0000010C   0xF040 0x5000      ORR      R0,R0,#0x20000000
   \   00000110   0x6020             STR      R0,[R4, #+0]
   \   00000112   0x6820             LDR      R0,[R4, #+0]
   \   00000114   0xF000 0x5000      AND      R0,R0,#0x20000000
   \   00000118   0x9000             STR      R0,[SP, #+0]
   \   0000011A   0x9800             LDR      R0,[SP, #+0]
   \   0000011C   0x204D             MOVS     R0,#+77
   \   0000011E   0x.... 0x....      BL       HAL_NVIC_SetPriority
    144              
    145              /* Enable USBHS Interrupt */
    146              HAL_NVIC_EnableIRQ(OTG_HS_IRQn);
   \   00000122   0x204D             MOVS     R0,#+77
   \                     ??HAL_HCD_MspInit_1: (+1)
   \   00000124   0x.... 0x....      BL       HAL_NVIC_EnableIRQ
    147            }   
    148          }
   \                     ??HAL_HCD_MspInit_2: (+1)
   \   00000128   0xB007             ADD      SP,SP,#+28
   \   0000012A   0xBD30             POP      {R4,R5,PC}       ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine3: (+1)
   \   00000000   0x6820             LDR      R0,[R4, #+0]
   \   00000002   0xA901             ADD      R1,SP,#+4
   \   00000004   0xF040 0x0001      ORR      R0,R0,#0x1
   \   00000008   0x6020             STR      R0,[R4, #+0]
   \   0000000A   0x6820             LDR      R0,[R4, #+0]
   \   0000000C   0xF000 0x0001      AND      R0,R0,#0x1
   \   00000010   0x9000             STR      R0,[SP, #+0]
   \   00000012   0x9800             LDR      R0,[SP, #+0]
   \   00000014   0x6820             LDR      R0,[R4, #+0]
   \   00000016   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine2: (+1)
   \   00000000   0xA901             ADD      R1,SP,#+4
   \                     ??Subroutine2_0: (+1)
   \   00000002   0x9001             STR      R0,[SP, #+4]
   \   00000004   0x2002             MOVS     R0,#+2
   \   00000006   0x9002             STR      R0,[SP, #+8]
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x9003             STR      R0,[SP, #+12]
   \   0000000C   0x200A             MOVS     R0,#+10
   \   0000000E   0x9005             STR      R0,[SP, #+20]
   \   00000010   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \   00000000   0x9001             STR      R0,[SP, #+4]
   \   00000002   0x2002             MOVS     R0,#+2
   \   00000004   0x9002             STR      R0,[SP, #+8]
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x9003             STR      R0,[SP, #+12]
   \   0000000A   0x2003             MOVS     R0,#+3
   \   0000000C   0x9004             STR      R0,[SP, #+16]
   \   0000000E   0x200A             MOVS     R0,#+10
   \   00000010   0x9005             STR      R0,[SP, #+20]
   \   00000012   0x4628             MOV      R0,R5
   \   00000014   0x.... 0x....      B.W      HAL_GPIO_Init
    149          
    150          /**
    151            * @brief  DeInitializes the HCD MSP.
    152            * @param  hhcd: HCD handle
    153            * @retval None
    154            */

   \                                 In section .text, align 2, keep-with-next
    155          void HAL_HCD_MspDeInit(HCD_HandleTypeDef *hhcd)
    156          {
    157            if(hhcd->Instance == USB_OTG_FS)
   \                     HAL_HCD_MspDeInit: (+1)
   \   00000000   0x6800             LDR      R0,[R0, #+0]
   \   00000002   0x....             LDR.N    R1,??DataTable5_1  ;; 0x40023830
   \   00000004   0xF1B0 0x4FA0      CMP      R0,#+1342177280
   \   00000008   0xD108             BNE.N    ??HAL_HCD_MspDeInit_0
    158            {  
    159              /* Disable USB FS Clocks */ 
    160              __HAL_RCC_USB_OTG_FS_CLK_DISABLE();
   \   0000000A   0x6848             LDR      R0,[R1, #+4]
   \   0000000C   0xF020 0x0080      BIC      R0,R0,#0x80
   \   00000010   0x6048             STR      R0,[R1, #+4]
   \   00000012   0x6948             LDR      R0,[R1, #+20]
   \   00000014   0xF420 0x4080      BIC      R0,R0,#0x4000
   \   00000018   0x6148             STR      R0,[R1, #+20]
   \   0000001A   0x4770             BX       LR
    161            }
    162            else if(hhcd->Instance == USB_OTG_HS)
   \                     ??HAL_HCD_MspDeInit_0: (+1)
   \   0000001C   0x....             LDR.N    R2,??DataTable5_3  ;; 0x40040000
   \   0000001E   0x4290             CMP      R0,R2
   \   00000020   0xD107             BNE.N    ??HAL_HCD_MspDeInit_1
    163            {  
    164              /* Disable USB HS Clocks */ 
    165              __HAL_RCC_USB_OTG_HS_CLK_DISABLE();
   \   00000022   0x6808             LDR      R0,[R1, #+0]
   \   00000024   0xF020 0x5000      BIC      R0,R0,#0x20000000
   \   00000028   0x6008             STR      R0,[R1, #+0]
    166              __HAL_RCC_USB_OTG_HS_ULPI_CLK_DISABLE();
   \   0000002A   0x6808             LDR      R0,[R1, #+0]
   \   0000002C   0xF020 0x4080      BIC      R0,R0,#0x40000000
   \   00000030   0x6008             STR      R0,[R1, #+0]
    167            }  
    168          }
   \                     ??HAL_HCD_MspDeInit_1: (+1)
   \   00000032   0x4770             BX       LR               ;; return
    169          
    170          /*******************************************************************************
    171                                 LL Driver Callbacks (HCD -> USB Host Library)
    172          *******************************************************************************/
    173          
    174          /**
    175            * @brief  SOF callback.
    176            * @param  hhcd: HCD handle
    177            * @retval None
    178            */

   \                                 In section .text, align 2, keep-with-next
    179          void HAL_HCD_SOF_Callback(HCD_HandleTypeDef *hhcd)
    180          {
    181            USBH_LL_IncTimer (hhcd->pData);
   \                     HAL_HCD_SOF_Callback: (+1)
   \   00000000   0xF8D0 0x0290      LDR      R0,[R0, #+656]
   \   00000004   0x.... 0x....      B.W      USBH_LL_IncTimer
    182          }
    183          
    184          /**
    185            * @brief  Connect callback.
    186            * @param  hhcd: HCD handle
    187            * @retval None
    188            */

   \                                 In section .text, align 2, keep-with-next
    189          void HAL_HCD_Connect_Callback(HCD_HandleTypeDef *hhcd)
    190          {
    191            USBH_LL_Connect(hhcd->pData);
   \                     HAL_HCD_Connect_Callback: (+1)
   \   00000000   0xF8D0 0x0290      LDR      R0,[R0, #+656]
   \   00000004   0x.... 0x....      B.W      USBH_LL_Connect
    192          }
    193          
    194          /**
    195            * @brief  Disconnect callback.
    196            * @param  hhcd: HCD handle
    197            * @retval None
    198            */

   \                                 In section .text, align 2, keep-with-next
    199          void HAL_HCD_Disconnect_Callback(HCD_HandleTypeDef *hhcd)
    200          {
    201            USBH_LL_Disconnect(hhcd->pData);
   \                     HAL_HCD_Disconnect_Callback: (+1)
   \   00000000   0xF8D0 0x0290      LDR      R0,[R0, #+656]
   \   00000004   0x.... 0x....      B.W      USBH_LL_Disconnect
    202          } 
    203          
    204          
    205          /**
    206            * @brief  Notify URB state change callback.
    207            * @param  hhcd: HCD handle
    208            * @param  chnum: Channel number 
    209            * @param  urb_state: URB State
    210            * @retval None
    211            */

   \                                 In section .text, align 2, keep-with-next
    212          void HAL_HCD_HC_NotifyURBChange_Callback(HCD_HandleTypeDef *hhcd, uint8_t chnum, HCD_URBStateTypeDef urb_state)
    213          {
    214            /* To be used with OS to sync URB state with the global state machine */
    215          }
   \                     HAL_HCD_HC_NotifyURBChange_Callback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    216          
    217          /*******************************************************************************
    218                                 LL Driver Interface (USB Host Library --> HCD)
    219          *******************************************************************************/
    220          /**
    221            * @brief  USBH_LL_Init 
    222            *         Initialize the Low Level portion of the Host driver.
    223            * @param  phost: Host handle
    224            * @retval USBH Status
    225            */

   \                                 In section .text, align 2, keep-with-next
    226          USBH_StatusTypeDef USBH_LL_Init(USBH_HandleTypeDef *phost)
    227          {
   \                     USBH_LL_Init: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
    228          #ifdef USE_USB_FS  
    229            /* Set the LL driver parameters */
    230            hhcd.Instance = USB_OTG_FS;
   \   00000004   0x....             LDR.N    R5,??DataTable5_7
   \   00000006   0xF04F 0x40A0      MOV      R0,#+1342177280
    231            hhcd.Init.Host_channels = 11; 
    232            hhcd.Init.dma_enable = 0;
    233            hhcd.Init.low_power_enable = 0;
    234            hhcd.Init.phy_itface = HCD_PHY_EMBEDDED; 
    235            hhcd.Init.Sof_enable = 0;
    236            hhcd.Init.speed = HCD_SPEED_FULL;
    237            hhcd.Init.vbus_sensing_enable = 0;
    238            
    239            /* Link the driver to the stack */
    240            hhcd.pData = phost;
   \   0000000A   0xF8C5 0x4290      STR      R4,[R5, #+656]
   \   0000000E   0x6028             STR      R0,[R5, #+0]
   \   00000010   0x200B             MOVS     R0,#+11
   \   00000012   0x60A8             STR      R0,[R5, #+8]
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0x6128             STR      R0,[R5, #+16]
   \   00000018   0x6228             STR      R0,[R5, #+32]
   \   0000001A   0x2002             MOVS     R0,#+2
   \   0000001C   0x61A8             STR      R0,[R5, #+24]
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0x61E8             STR      R0,[R5, #+28]
   \   00000022   0x2003             MOVS     R0,#+3
   \   00000024   0x60E8             STR      R0,[R5, #+12]
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0x62A8             STR      R0,[R5, #+40]
    241            phost->pData = &hhcd;
    242            
    243            /* Initialize the LL Driver */
    244            HAL_HCD_Init(&hhcd);
   \   0000002A   0x4628             MOV      R0,R5
   \   0000002C   0xF8C4 0x52B0      STR      R5,[R4, #+688]
   \   00000030   0x.... 0x....      BL       HAL_HCD_Init
    245          #endif 
    246          #ifdef USE_USB_HS  
    247            /* Set the LL driver parameters */
    248            hhcd.Instance = USB_OTG_HS;
    249            hhcd.Init.Host_channels = 11; 
    250            hhcd.Init.dma_enable = 1;
    251            hhcd.Init.low_power_enable = 0;
    252            hhcd.Init.phy_itface = HCD_PHY_ULPI; 
    253            hhcd.Init.Sof_enable = 0;
    254            hhcd.Init.speed = HCD_SPEED_HIGH;
    255            hhcd.Init.vbus_sensing_enable = 0;
    256            hhcd.Init.use_external_vbus = 1;  
    257            
    258            /* Link the driver to the stack */
    259            hhcd.pData = phost;
    260            phost->pData = &hhcd;
    261            /* Initialize the LL driver */
    262            HAL_HCD_Init(&hhcd);
    263          #endif /*USE_USB_HS*/ 
    264          
    265            USBH_LL_SetTimer(phost, HAL_HCD_GetCurrentFrame(&hhcd));
   \   00000034   0x4628             MOV      R0,R5
   \   00000036   0x.... 0x....      BL       HAL_HCD_GetCurrentFrame
   \   0000003A   0x4601             MOV      R1,R0
   \   0000003C   0x4620             MOV      R0,R4
   \   0000003E   0x.... 0x....      BL       USBH_LL_SetTimer
    266            
    267            return USBH_OK;
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    268          }
    269          
    270          /**
    271            * @brief  De-Initializes the Low Level portion of the Host driver.
    272            * @param  phost: Host handle
    273            * @retval USBH Status
    274            */

   \                                 In section .text, align 2, keep-with-next
    275          USBH_StatusTypeDef USBH_LL_DeInit(USBH_HandleTypeDef *phost)
    276          {
   \                     USBH_LL_DeInit: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    277            HAL_HCD_DeInit(phost->pData);
   \   00000002   0xF8D0 0x02B0      LDR      R0,[R0, #+688]
   \   00000006   0x.... 0x....      BL       HAL_HCD_DeInit
    278            return USBH_OK; 
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0xBD02             POP      {R1,PC}          ;; return
    279          }
    280          
    281          /**
    282            * @brief  Starts the Low Level portion of the Host driver.   
    283            * @param  phost: Host handle
    284            * @retval USBH Status
    285            */

   \                                 In section .text, align 2, keep-with-next
    286          USBH_StatusTypeDef USBH_LL_Start(USBH_HandleTypeDef *phost)
    287          {
   \                     USBH_LL_Start: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    288            HAL_HCD_Start(phost->pData);
   \   00000002   0xF8D0 0x02B0      LDR      R0,[R0, #+688]
   \   00000006   0x.... 0x....      BL       HAL_HCD_Start
    289            return USBH_OK; 
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0xBD02             POP      {R1,PC}          ;; return
    290          }
    291          
    292          /**
    293            * @brief  Stops the Low Level portion of the Host driver.
    294            * @param  phost: Host handle
    295            * @retval USBH Status
    296            */

   \                                 In section .text, align 2, keep-with-next
    297          USBH_StatusTypeDef USBH_LL_Stop(USBH_HandleTypeDef *phost)
    298          {
   \                     USBH_LL_Stop: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    299            HAL_HCD_Stop(phost->pData);
   \   00000002   0xF8D0 0x02B0      LDR      R0,[R0, #+688]
   \   00000006   0x.... 0x....      BL       HAL_HCD_Stop
    300            return USBH_OK; 
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0xBD02             POP      {R1,PC}          ;; return
    301          }
    302          
    303          /**
    304            * @brief  Returns the USB Host Speed from the Low Level Driver.
    305            * @param  phost: Host handle
    306            * @retval USBH Speeds
    307            */

   \                                 In section .text, align 2, keep-with-next
    308          USBH_SpeedTypeDef USBH_LL_GetSpeed(USBH_HandleTypeDef *phost)
    309          {
   \                     USBH_LL_GetSpeed: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    310            USBH_SpeedTypeDef speed = USBH_SPEED_FULL;
    311            
    312            switch (HAL_HCD_GetCurrentSpeed(phost->pData))
   \   00000002   0xF8D0 0x02B0      LDR      R0,[R0, #+688]
   \   00000006   0x2401             MOVS     R4,#+1
   \   00000008   0x.... 0x....      BL       HAL_HCD_GetCurrentSpeed
   \   0000000C   0xB118             CBZ.N    R0,??USBH_LL_GetSpeed_0
   \   0000000E   0x2802             CMP      R0,#+2
   \   00000010   0xBF08             IT       EQ 
   \   00000012   0x2402             MOVEQ    R4,#+2
    313            {
    314            case 0: 
    315              speed = USBH_SPEED_HIGH;
    316              break;
    317              
    318            case 1: 
    319              speed = USBH_SPEED_FULL;    
    320              break;
    321              
    322            case 2: 
    323              speed = USBH_SPEED_LOW;   
   \   00000014   0xE000             B.N      ??USBH_LL_GetSpeed_1
   \                     ??USBH_LL_GetSpeed_0: (+1)
   \   00000016   0x2400             MOVS     R4,#+0
    324              break;
    325              
    326            default:  
    327              speed = USBH_SPEED_FULL;    
    328              break;    
    329            }
    330            return speed;
   \                     ??USBH_LL_GetSpeed_1: (+1)
   \   00000018   0x4620             MOV      R0,R4
   \   0000001A   0xBD10             POP      {R4,PC}          ;; return
    331          }
    332          
    333          /**
    334            * @brief  Resets the Host Port of the Low Level Driver.
    335            * @param  phost: Host handle
    336            * @retval USBH Status
    337            */

   \                                 In section .text, align 2, keep-with-next
    338          USBH_StatusTypeDef USBH_LL_ResetPort (USBH_HandleTypeDef *phost) 
    339          {
   \                     USBH_LL_ResetPort: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    340            HAL_HCD_ResetPort(phost->pData);
   \   00000002   0xF8D0 0x02B0      LDR      R0,[R0, #+688]
   \   00000006   0x.... 0x....      BL       HAL_HCD_ResetPort
    341            return USBH_OK; 
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0xBD02             POP      {R1,PC}          ;; return
    342          }
    343          
    344          /**
    345            * @brief  Returns the last transferred packet size.
    346            * @param  phost: Host handle
    347            * @param  pipe: Pipe index   
    348            * @retval Packet Size
    349            */

   \                                 In section .text, align 2, keep-with-next
    350          uint32_t USBH_LL_GetLastXferSize(USBH_HandleTypeDef *phost, uint8_t pipe)  
    351          {
    352            return HAL_HCD_HC_GetXferCount(phost->pData, pipe);
   \                     USBH_LL_GetLastXferSize: (+1)
   \   00000000   0xF8D0 0x02B0      LDR      R0,[R0, #+688]
   \   00000004   0x.... 0x....      B.W      HAL_HCD_HC_GetXferCount
    353          }
    354          
    355          /**
    356            * @brief  Opens a pipe of the Low Level Driver.
    357            * @param  phost: Host handle
    358            * @param  pipe: Pipe index
    359            * @param  epnum: Endpoint Number
    360            * @param  dev_address: Device USB address
    361            * @param  speed: Device Speed 
    362            * @param  ep_type: Endpoint Type
    363            * @param  mps: Endpoint Max Packet Size                 
    364            * @retval USBH Status
    365            */

   \                                 In section .text, align 2, keep-with-next
    366          USBH_StatusTypeDef USBH_LL_OpenPipe(USBH_HandleTypeDef *phost, 
    367                                              uint8_t pipe,
    368                                              uint8_t epnum,                                      
    369                                              uint8_t dev_address,
    370                                              uint8_t speed,
    371                                              uint8_t ep_type,
    372                                              uint16_t mps)
    373          {
   \                     USBH_LL_OpenPipe: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB084             SUB      SP,SP,#+16
    374            HAL_HCD_HC_Init(phost->pData,
    375                            pipe,
    376                            epnum,
    377                            dev_address,
    378                            speed,
    379                            ep_type,
    380                            mps);
   \   00000004   0x.... 0x....      BL       ?Subroutine4
   \                     ??CrossCallReturnLabel_9: (+1)
   \   00000008   0x.... 0x....      BL       HAL_HCD_HC_Init
    381            return USBH_OK; 
   \   0000000C   0x....             B.N      ?Subroutine0
    382          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0xB004             ADD      SP,SP,#+16
   \   00000004   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine4: (+1)
   \   00000000   0x9C08             LDR      R4,[SP, #+32]
   \   00000002   0x9402             STR      R4,[SP, #+8]
   \   00000004   0x9C07             LDR      R4,[SP, #+28]
   \   00000006   0x9401             STR      R4,[SP, #+4]
   \   00000008   0x9C06             LDR      R4,[SP, #+24]
   \   0000000A   0x9400             STR      R4,[SP, #+0]
   \   0000000C   0xF8D0 0x02B0      LDR      R0,[R0, #+688]
   \   00000010   0x4770             BX       LR
    383          
    384          /**
    385            * @brief  Closes a pipe of the Low Level Driver.
    386            * @param  phost: Host handle
    387            * @param  pipe: Pipe index               
    388            * @retval USBH Status
    389            */

   \                                 In section .text, align 2, keep-with-next
    390          USBH_StatusTypeDef USBH_LL_ClosePipe(USBH_HandleTypeDef *phost, uint8_t pipe)   
    391          {
   \                     USBH_LL_ClosePipe: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    392            HAL_HCD_HC_Halt(phost->pData, pipe);
   \   00000002   0xF8D0 0x02B0      LDR      R0,[R0, #+688]
   \   00000006   0x.... 0x....      BL       HAL_HCD_HC_Halt
    393            return USBH_OK; 
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0xBD02             POP      {R1,PC}          ;; return
    394          }
    395          
    396          /**
    397            * @brief  Submits a new URB to the low level driver.
    398            * @param  phost: Host handle
    399            * @param  pipe: Pipe index    
    400            *          This parameter can be a value from 1 to 15
    401            * @param  direction: Channel number
    402            *          This parameter can be one of these values:
    403            *           0: Output 
    404            *           1: Input
    405            * @param  ep_type: Endpoint Type
    406            *          This parameter can be one of these values:
    407            *            @arg EP_TYPE_CTRL: Control type
    408            *            @arg EP_TYPE_ISOC: Isochronous type
    409            *            @arg EP_TYPE_BULK: Bulk type
    410            *            @arg EP_TYPE_INTR: Interrupt type
    411            * @param  token: Endpoint Type
    412            *          This parameter can be one of these values:
    413            *            @arg 0: PID_SETUP
    414            *            @arg 1: PID_DATA
    415            * @param  pbuff: pointer to URB data
    416            * @param  length: length of URB data
    417            * @param  do_ping: activate do ping protocol (for high speed only)
    418            *          This parameter can be one of these values:
    419            *           0: do ping inactive 
    420            *           1: do ping active 
    421            * @retval USBH Status
    422            */

   \                                 In section .text, align 2, keep-with-next
    423          USBH_StatusTypeDef USBH_LL_SubmitURB(USBH_HandleTypeDef *phost, 
    424                                               uint8_t pipe, 
    425                                               uint8_t direction,
    426                                               uint8_t ep_type,  
    427                                               uint8_t token, 
    428                                               uint8_t* pbuff, 
    429                                               uint16_t length,
    430                                               uint8_t do_ping) 
    431          {
   \                     USBH_LL_SubmitURB: (+1)
   \   00000000   0xB51F             PUSH     {R0-R4,LR}
    432            HAL_HCD_HC_SubmitRequest(phost->pData,
    433                                     pipe, 
    434                                     direction,
    435                                     ep_type,  
    436                                     token, 
    437                                     pbuff, 
    438                                     length,
    439                                     do_ping);
   \   00000002   0x9C09             LDR      R4,[SP, #+36]
   \   00000004   0x9403             STR      R4,[SP, #+12]
   \   00000006   0x.... 0x....      BL       ?Subroutine4
   \                     ??CrossCallReturnLabel_10: (+1)
   \   0000000A   0x.... 0x....      BL       HAL_HCD_HC_SubmitRequest
    440            return USBH_OK;   
   \   0000000E                      REQUIRE ?Subroutine0
   \   0000000E                      ;; // Fall through to label ?Subroutine0
    441          }
    442          
    443          /**
    444            * @brief  Gets a URB state from the low level driver.
    445            * @param  phost: Host handle
    446            * @param  pipe: Pipe index
    447            *          This parameter can be a value from 1 to 15
    448            * @retval URB state
    449            *          This parameter can be one of these values:
    450            *            @arg URB_IDLE
    451            *            @arg URB_DONE
    452            *            @arg URB_NOTREADY
    453            *            @arg URB_NYET 
    454            *            @arg URB_ERROR  
    455            *            @arg URB_STALL      
    456            */

   \                                 In section .text, align 2, keep-with-next
    457          USBH_URBStateTypeDef USBH_LL_GetURBState(USBH_HandleTypeDef *phost, uint8_t pipe) 
    458          {
    459            return (USBH_URBStateTypeDef)HAL_HCD_HC_GetURBState (phost->pData, pipe);
   \                     USBH_LL_GetURBState: (+1)
   \   00000000   0xF8D0 0x02B0      LDR      R0,[R0, #+688]
   \   00000004   0x.... 0x....      B.W      HAL_HCD_HC_GetURBState
    460          }
    461          
    462          /**
    463            * @brief  Drives VBUS.
    464            * @param  phost: Host handle
    465            * @param  state: VBUS state
    466            *          This parameter can be one of these values:
    467            *           0: VBUS Active 
    468            *           1: VBUS Inactive
    469            * @retval USBH Status
    470            */

   \                                 In section .text, align 2, keep-with-next
    471          USBH_StatusTypeDef USBH_LL_DriverVBUS(USBH_HandleTypeDef *phost, uint8_t state)
    472          {
    473          #ifdef USE_USB_FS
    474            if(state == 0)
   \                     USBH_LL_DriverVBUS: (+1)
   \   00000000   0x2900             CMP      R1,#+0
   \   00000002   0x....             LDR.N    R0,??DataTable5_2  ;; 0x40020c00
   \   00000004   0xB580             PUSH     {R7,LR}
   \   00000006   0xBF0C             ITE      EQ 
   \   00000008   0x2201             MOVEQ    R2,#+1
   \   0000000A   0x2200             MOVNE    R2,#+0
    475            {
    476              HAL_GPIO_WritePin(GPIOD, GPIO_PIN_5, GPIO_PIN_SET);
    477            }
    478            else
    479            {
    480              HAL_GPIO_WritePin(GPIOD, GPIO_PIN_5, GPIO_PIN_RESET);
   \   0000000C   0x2120             MOVS     R1,#+32
   \   0000000E   0x.... 0x....      BL       HAL_GPIO_WritePin
    481            }
    482            
    483            HAL_Delay(200);
   \   00000012   0x20C8             MOVS     R0,#+200
   \   00000014   0x.... 0x....      BL       HAL_Delay
    484          #endif /* USE_USB_FS */
    485            return USBH_OK;  
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0xBD02             POP      {R1,PC}          ;; return
    486          }
    487          
    488          /**
    489            * @brief  Sets toggle for a pipe.
    490            * @param  phost: Host handle
    491            * @param  pipe: Pipe index   
    492            * @param  toggle: toggle (0/1)
    493            * @retval USBH Status
    494            */

   \                                 In section .text, align 2, keep-with-next
    495          USBH_StatusTypeDef USBH_LL_SetToggle(USBH_HandleTypeDef *phost, uint8_t pipe, uint8_t toggle)   
    496          {
    497            if(hhcd.hc[pipe].ep_is_in)
   \                     USBH_LL_SetToggle: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable5_7
   \   00000002   0x2328             MOVS     R3,#+40
   \   00000004   0xFB13 0x0001      SMLABB   R0,R3,R1,R0
   \   00000008   0xF810 0x1F37      LDRB     R1,[R0, #+55]!
   \   0000000C   0x2900             CMP      R1,#+0
   \   0000000E   0xBF14             ITE      NE 
   \   00000010   0x7542             STRBNE   R2,[R0, #+21]
   \   00000012   0x7582             STRBEQ   R2,[R0, #+22]
    498            {
    499              hhcd.hc[pipe].toggle_in = toggle;
    500            }
    501            else
    502            {
    503              hhcd.hc[pipe].toggle_out = toggle;
    504            }
    505            return USBH_OK; 
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0x4770             BX       LR               ;; return
    506          }
    507          
    508          /**
    509            * @brief  Returns the current toggle of a pipe.
    510            * @param  phost: Host handle
    511            * @param  pipe: Pipe index
    512            * @retval toggle (0/1)
    513            */

   \                                 In section .text, align 2, keep-with-next
    514          uint8_t USBH_LL_GetToggle(USBH_HandleTypeDef *phost, uint8_t pipe)   
    515          {
    516            uint8_t toggle = 0;
    517            
    518            if(hhcd.hc[pipe].ep_is_in)
   \                     USBH_LL_GetToggle: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable5_7
   \   00000002   0x2228             MOVS     R2,#+40
   \   00000004   0xFB12 0x0001      SMLABB   R0,R2,R1,R0
   \   00000008   0xF810 0x1F37      LDRB     R1,[R0, #+55]!
   \   0000000C   0x2900             CMP      R1,#+0
   \   0000000E   0xBF14             ITE      NE 
   \   00000010   0x7D40             LDRBNE   R0,[R0, #+21]
   \   00000012   0x7D80             LDRBEQ   R0,[R0, #+22]
    519            {
    520              toggle = hhcd.hc[pipe].toggle_in;
    521            }
    522            else
    523            {
    524              toggle = hhcd.hc[pipe].toggle_out;
   \   00000014   0x4770             BX       LR
    525            }
    526            return toggle; 
    527          }
    528          
    529          /**
    530            * @brief  Delay routine for the USB Host Library
    531            * @param  Delay: Delay in ms
    532            * @retval None
    533            */

   \                                 In section .text, align 2, keep-with-next
    534          void USBH_Delay(uint32_t Delay)
    535          {
    536            HAL_Delay(Delay);  
   \                     USBH_Delay: (+1)
   \   00000000   0x.... 0x....      B.W      HAL_Delay
    537          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5:
   \   00000000   0x40020000         DC32     0x40020000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_1:
   \   00000000   0x40023830         DC32     0x40023830

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_2:
   \   00000000   0x40020C00         DC32     0x40020c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_3:
   \   00000000   0x40040000         DC32     0x40040000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_4:
   \   00000000   0x40020400         DC32     0x40020400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_5:
   \   00000000   0x40020800         DC32     0x40020800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_6:
   \   00000000   0x40021C00         DC32     0x40021c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_7:
   \   00000000   0x........         DC32     hhcd
    538          
    539          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   HAL_HCD_Connect_Callback
         0   -> USBH_LL_Connect
       0   HAL_HCD_Disconnect_Callback
         0   -> USBH_LL_Disconnect
       0   HAL_HCD_HC_NotifyURBChange_Callback
       0   HAL_HCD_MspDeInit
      40   HAL_HCD_MspInit
        40   -> HAL_GPIO_Init
        40   -> HAL_NVIC_EnableIRQ
        40   -> HAL_NVIC_SetPriority
       0   HAL_HCD_SOF_Callback
         0   -> USBH_LL_IncTimer
       0   USBH_Delay
         0   -> HAL_Delay
       8   USBH_LL_ClosePipe
         8   -> HAL_HCD_HC_Halt
       8   USBH_LL_DeInit
         8   -> HAL_HCD_DeInit
       8   USBH_LL_DriverVBUS
         8   -> HAL_Delay
         8   -> HAL_GPIO_WritePin
       0   USBH_LL_GetLastXferSize
         0   -> HAL_HCD_HC_GetXferCount
       8   USBH_LL_GetSpeed
         8   -> HAL_HCD_GetCurrentSpeed
       0   USBH_LL_GetToggle
       0   USBH_LL_GetURBState
         0   -> HAL_HCD_HC_GetURBState
      16   USBH_LL_Init
        16   -> HAL_HCD_GetCurrentFrame
        16   -> HAL_HCD_Init
        16   -> USBH_LL_SetTimer
      24   USBH_LL_OpenPipe
        24   -> HAL_HCD_HC_Init
       8   USBH_LL_ResetPort
         8   -> HAL_HCD_ResetPort
       0   USBH_LL_SetToggle
       8   USBH_LL_Start
         8   -> HAL_HCD_Start
       8   USBH_LL_Stop
         8   -> HAL_HCD_Stop
      24   USBH_LL_SubmitURB
        24   -> HAL_HCD_HC_SubmitRequest


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable5
       4  ??DataTable5_1
       4  ??DataTable5_2
       4  ??DataTable5_3
       4  ??DataTable5_4
       4  ??DataTable5_5
       4  ??DataTable5_6
       4  ??DataTable5_7
       6  ?Subroutine0
      24  ?Subroutine1
      18  ?Subroutine2
      24  ?Subroutine3
      18  ?Subroutine4
       8  HAL_HCD_Connect_Callback
       8  HAL_HCD_Disconnect_Callback
       2  HAL_HCD_HC_NotifyURBChange_Callback
      52  HAL_HCD_MspDeInit
     300  HAL_HCD_MspInit
       8  HAL_HCD_SOF_Callback
       4  USBH_Delay
      14  USBH_LL_ClosePipe
      14  USBH_LL_DeInit
      28  USBH_LL_DriverVBUS
       8  USBH_LL_GetLastXferSize
      28  USBH_LL_GetSpeed
      22  USBH_LL_GetToggle
       8  USBH_LL_GetURBState
      70  USBH_LL_Init
      14  USBH_LL_OpenPipe
      14  USBH_LL_ResetPort
      24  USBH_LL_SetToggle
      14  USBH_LL_Start
      14  USBH_LL_Stop
      14  USBH_LL_SubmitURB
     660  hhcd

 
 660 bytes in section .bss
 790 bytes in section .text
 
 790 bytes of CODE memory
 660 bytes of DATA memory

Errors: none
Warnings: none
