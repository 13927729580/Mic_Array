///////////////////////////////////////////////////////////////////////////////
//
// IAR ANSI C/C++ Compiler V7.50.2.10312/W32 for ARM      20/Feb/2016  20:49:04
// Copyright 1999-2015 IAR Systems AB.
//
//    Cpu mode     =  thumb
//    Endian       =  little
//    Source file  =  
//        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Middlewares\ST\STM32_USB_Host_Library\Core\Src\usbh_core.c
//    Command line =  
//        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Middlewares\ST\STM32_USB_Host_Library\Core\Src\usbh_core.c
//        -D USE_HAL_DRIVER -D STM32F746xx -D USE_STM32746G_DISCO -D
//        USE_IOEXPANDER -D USE_USB_FS -lC
//        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
//        -lA
//        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
//        -o
//        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj
//        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
//        --no_clustering --no_scheduling --debug --endian=little
//        --cpu=Cortex-M7 -e --fpu=VFPv5_sp --dlib_config "D:\Program Files
//        (x86)\IAR Systems\Embedded Workbench
//        7.3\arm\INC\c\DLib_Config_Full.h" -I
//        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\Inc\
//        -I
//        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\CMSIS\Device\ST\STM32F7xx\Include\
//        -I
//        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\STM32F7xx_HAL_Driver\Inc\
//        -I
//        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\STM32746G-Discovery\
//        -I
//        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\Components\Common\
//        -I
//        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Log\
//        -I
//        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Fonts\
//        -I
//        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\CPU\
//        -I
//        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_Device_Library\Core\Inc\
//        -I
//        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Core\Inc\
//        -I
//        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Class\MSC\Inc\
//        -I
//        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\
//        -I
//        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\drivers\
//        -I
//        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_Audio\Addons\PDM\
//        -I
//        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_Device_Library\Class\AUDIO\Inc\
//        -On --use_c++_inline --require_prototypes -I "D:\Program Files
//        (x86)\IAR Systems\Embedded Workbench 7.3\arm\CMSIS\Include\" -D
//        ARM_MATH_CM7
//    List file    =  
//        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List\usbh_core.s
//
///////////////////////////////////////////////////////////////////////////////

        RTMODEL "__SystemLibrary", "DLib"
        RTMODEL "__dlib_file_descriptor", "1"
        RTMODEL "__dlib_full_locale_support", "1"
        RTMODEL "__iar_require _Printf", ""
        AAPCS BASE,INTERWORK,VFP
        PRESERVE8
        REQUIRE8

        #define SHT_PROGBITS 0x1

        EXTERN USBH_AllocPipe
        EXTERN USBH_Delay
        EXTERN USBH_FreePipe
        EXTERN USBH_Get_CfgDesc
        EXTERN USBH_Get_DevDesc
        EXTERN USBH_Get_StringDesc
        EXTERN USBH_LL_DriverVBUS
        EXTERN USBH_LL_GetSpeed
        EXTERN USBH_LL_Init
        EXTERN USBH_LL_ResetPort
        EXTERN USBH_LL_Start
        EXTERN USBH_LL_Stop
        EXTERN USBH_OpenPipe
        EXTERN USBH_SetAddress
        EXTERN USBH_SetCfg
        EXTERN printf

        PUBLIC USBH_DeInit
        PUBLIC USBH_FindInterface
        PUBLIC USBH_FindInterfaceIndex
        PUBLIC USBH_GetActiveClass
        PUBLIC USBH_Init
        PUBLIC USBH_LL_Connect
        PUBLIC USBH_LL_Disconnect
        PUBLIC USBH_LL_IncTimer
        PUBLIC USBH_LL_SetTimer
        PUBLIC USBH_Process
        PUBLIC USBH_ReEnumerate
        PUBLIC USBH_RegisterClass
        PUBLIC USBH_SelectInterface
        PUBLIC USBH_Start
        PUBLIC USBH_Stop
        
          CFI Names cfiNames0
          CFI StackFrame CFA R13 DATA
          CFI Resource R0:32, R1:32, R2:32, R3:32, R4:32, R5:32, R6:32, R7:32
          CFI Resource R8:32, R9:32, R10:32, R11:32, R12:32, R13:32, R14:32
          CFI Resource D0:64, D1:64, D2:64, D3:64, D4:64, D5:64, D6:64, D7:64
          CFI Resource D8:64, D9:64, D10:64, D11:64, D12:64, D13:64, D14:64
          CFI Resource D15:64
          CFI EndNames cfiNames0
        
          CFI Common cfiCommon0 Using cfiNames0
          CFI CodeAlign 2
          CFI DataAlign 4
          CFI ReturnAddress R14 CODE
          CFI CFA R13+0
          CFI R0 Undefined
          CFI R1 Undefined
          CFI R2 Undefined
          CFI R3 Undefined
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R8 SameValue
          CFI R9 SameValue
          CFI R10 SameValue
          CFI R11 SameValue
          CFI R12 Undefined
          CFI R14 SameValue
          CFI D0 Undefined
          CFI D1 Undefined
          CFI D2 Undefined
          CFI D3 Undefined
          CFI D4 Undefined
          CFI D5 Undefined
          CFI D6 Undefined
          CFI D7 Undefined
          CFI D8 SameValue
          CFI D9 SameValue
          CFI D10 SameValue
          CFI D11 SameValue
          CFI D12 SameValue
          CFI D13 SameValue
          CFI D14 SameValue
          CFI D15 SameValue
          CFI EndCommon cfiCommon0
        
// H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Middlewares\ST\STM32_USB_Host_Library\Core\Src\usbh_core.c
//    1 /**
//    2   ******************************************************************************
//    3   * @file    usbh_core.c 
//    4   * @author  MCD Application Team
//    5   * @version V3.2.1
//    6   * @date    26-June-2015
//    7   * @brief   This file implements the functions for the core state machine process
//    8   *          the enumeration and the control transfer process
//    9   ******************************************************************************
//   10   * @attention
//   11   *
//   12   * <h2><center>&copy; COPYRIGHT 2015 STMicroelectronics</center></h2>
//   13   *
//   14   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
//   15   * You may not use this file except in compliance with the License.
//   16   * You may obtain a copy of the License at:
//   17   *
//   18   *        http://www.st.com/software_license_agreement_liberty_v2
//   19   *
//   20   * Unless required by applicable law or agreed to in writing, software 
//   21   * distributed under the License is distributed on an "AS IS" BASIS, 
//   22   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//   23   * See the License for the specific language governing permissions and
//   24   * limitations under the License.
//   25   *
//   26   ******************************************************************************
//   27   */ 
//   28 /* Includes ------------------------------------------------------------------*/
//   29 
//   30 #include "usbh_core.h"
//   31 
//   32 
//   33 /** @addtogroup USBH_LIB
//   34   * @{
//   35   */
//   36 
//   37 /** @addtogroup USBH_LIB_CORE
//   38   * @{
//   39   */
//   40 
//   41 /** @defgroup USBH_CORE 
//   42   * @brief This file handles the basic enumeration when a device is connected 
//   43   *          to the host.
//   44   * @{
//   45   */ 
//   46 
//   47 
//   48 /** @defgroup USBH_CORE_Private_Defines
//   49   * @{
//   50   */ 
//   51 #define USBH_ADDRESS_DEFAULT                     0
//   52 #define USBH_ADDRESS_ASSIGNED                    1      
//   53 #define USBH_MPS_DEFAULT                         0x40
//   54 /**
//   55   * @}
//   56   */ 
//   57 
//   58 /** @defgroup USBH_CORE_Private_Macros
//   59   * @{
//   60   */ 
//   61 /**
//   62   * @}
//   63   */ 
//   64 
//   65 
//   66 /** @defgroup USBH_CORE_Private_Variables
//   67   * @{
//   68   */ 
//   69 /**
//   70   * @}
//   71   */ 
//   72  
//   73 
//   74 /** @defgroup USBH_CORE_Private_Functions
//   75   * @{
//   76   */ 
//   77 static USBH_StatusTypeDef  USBH_HandleEnum    (USBH_HandleTypeDef *phost);
//   78 static void                USBH_HandleSof     (USBH_HandleTypeDef *phost);
//   79 static USBH_StatusTypeDef  DeInitStateMachine(USBH_HandleTypeDef *phost);
//   80 
//   81 #if (USBH_USE_OS == 1)  
//   82 static void USBH_Process_OS(void const * argument);
//   83 #endif
//   84 
//   85 /**
//   86   * @brief  HCD_Init 
//   87   *         Initialize the HOST Core.
//   88   * @param  phost: Host Handle
//   89   * @param  pUsrFunc: User Callback
//   90   * @retval USBH Status
//   91   */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock0 Using cfiCommon0
          CFI Function USBH_Init
        THUMB
//   92 USBH_StatusTypeDef  USBH_Init(USBH_HandleTypeDef *phost, void (*pUsrFunc)(USBH_HandleTypeDef *phost, uint8_t ), uint8_t id)
//   93 {
USBH_Init:
        PUSH     {R4-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
        MOVS     R4,R0
        MOVS     R5,R1
        MOVS     R6,R2
//   94   /* Check whether the USB Host handle is valid */
//   95   if(phost == NULL)
        CMP      R4,#+0
        BNE.N    ??USBH_Init_0
//   96   {
//   97     USBH_ErrLog("Invalid Host handle");
        LDR.W    R0,??DataTable5_1
          CFI FunCall printf
        BL       printf
        LDR.W    R0,??DataTable5_2
          CFI FunCall printf
        BL       printf
        ADR.N    R0,??DataTable2  ;; "\n"
          CFI FunCall printf
        BL       printf
//   98     return USBH_FAIL; 
        MOVS     R0,#+2
        B.N      ??USBH_Init_1
//   99   }
//  100   
//  101   /* Set DRiver ID */
//  102   phost->id = id;
??USBH_Init_0:
        STRB     R6,[R4, #+684]
//  103   
//  104   /* Unlink class*/
//  105   phost->pActiveClass = NULL;
        MOVS     R0,#+0
        STR      R0,[R4, #+612]
//  106   phost->ClassNumber = 0;
        MOVS     R0,#+0
        STR      R0,[R4, #+616]
//  107   
//  108   /* Restore default states and prepare EP0 */ 
//  109   DeInitStateMachine(phost);
        MOVS     R0,R4
          CFI FunCall DeInitStateMachine
        BL       DeInitStateMachine
//  110   
//  111   /* Assign User process */
//  112   if(pUsrFunc != NULL)
        MOVS     R0,R5
        CMP      R0,#+0
        BEQ.N    ??USBH_Init_2
//  113   {
//  114     phost->pUser = pUsrFunc;
        STR      R5,[R4, #+692]
//  115   }
//  116   
//  117 #if (USBH_USE_OS == 1) 
//  118   
//  119   /* Create USB Host Queue */
//  120   osMessageQDef(USBH_Queue, 10, uint16_t);
//  121   phost->os_event = osMessageCreate (osMessageQ(USBH_Queue), NULL); 
//  122   
//  123   /*Create USB Host Task */
//  124 #if defined (USBH_PROCESS_STACK_SIZE)
//  125   osThreadDef(USBH_Thread, USBH_Process_OS, USBH_PROCESS_PRIO, 0, USBH_PROCESS_STACK_SIZE);
//  126 #else
//  127   osThreadDef(USBH_Thread, USBH_Process_OS, USBH_PROCESS_PRIO, 0, 8 * configMINIMAL_STACK_SIZE);
//  128 #endif  
//  129   phost->thread = osThreadCreate (osThread(USBH_Thread), phost);
//  130 #endif  
//  131   
//  132   /* Initialize low level driver */
//  133   USBH_LL_Init(phost);
??USBH_Init_2:
        MOVS     R0,R4
          CFI FunCall USBH_LL_Init
        BL       USBH_LL_Init
//  134   return USBH_OK;
        MOVS     R0,#+0
??USBH_Init_1:
        POP      {R4-R6,PC}       ;; return
//  135 }
          CFI EndBlock cfiBlock0
//  136 
//  137 /**
//  138   * @brief  HCD_Init 
//  139   *         De-Initialize the Host portion of the driver.
//  140   * @param  phost: Host Handle
//  141   * @retval USBH Status
//  142   */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock1 Using cfiCommon0
          CFI Function USBH_DeInit
        THUMB
//  143 USBH_StatusTypeDef  USBH_DeInit(USBH_HandleTypeDef *phost)
//  144 {
USBH_DeInit:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        MOVS     R4,R0
//  145   DeInitStateMachine(phost);
        MOVS     R0,R4
          CFI FunCall DeInitStateMachine
        BL       DeInitStateMachine
//  146   
//  147   if(phost->pData != NULL)
        LDR      R0,[R4, #+688]
        CMP      R0,#+0
        BEQ.N    ??USBH_DeInit_0
//  148   {
//  149     phost->pActiveClass->pData = NULL;
        MOVS     R0,#+0
        LDR      R1,[R4, #+612]
        STR      R0,[R1, #+28]
//  150     USBH_LL_Stop(phost);
        MOVS     R0,R4
          CFI FunCall USBH_LL_Stop
        BL       USBH_LL_Stop
//  151   }
//  152 
//  153   return USBH_OK;
??USBH_DeInit_0:
        MOVS     R0,#+0
        POP      {R4,PC}          ;; return
//  154 }
          CFI EndBlock cfiBlock1
//  155 
//  156 /**
//  157   * @brief  DeInitStateMachine 
//  158   *         De-Initialize the Host state machine.
//  159   * @param  phost: Host Handle
//  160   * @retval USBH Status
//  161   */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock2 Using cfiCommon0
          CFI Function DeInitStateMachine
          CFI NoCalls
        THUMB
//  162 static USBH_StatusTypeDef  DeInitStateMachine(USBH_HandleTypeDef *phost)
//  163 {
DeInitStateMachine:
        MOVS     R1,R0
//  164   uint32_t i = 0;
        MOVS     R2,#+0
//  165 
//  166   /* Clear Pipes flags*/
//  167   for ( ; i < USBH_MAX_PIPES_NBR; i++)
??DeInitStateMachine_0:
        CMP      R2,#+15
        BCS.N    ??DeInitStateMachine_1
//  168   {
//  169     phost->Pipes[i] = 0;
        MOVS     R0,#+0
        ADDS     R3,R1,R2, LSL #+2
        STR      R0,[R3, #+620]
//  170   }
        ADDS     R2,R2,#+1
        B.N      ??DeInitStateMachine_0
//  171   
//  172   for(i = 0; i< USBH_MAX_DATA_BUFFER; i++)
??DeInitStateMachine_1:
        MOVS     R0,#+0
        MOVS     R2,R0
??DeInitStateMachine_2:
        CMP      R2,#+512
        BCS.N    ??DeInitStateMachine_3
//  173   {
//  174     phost->device.Data[i] = 0;
        MOVS     R0,#+0
        ADDS     R3,R2,R1
        STRB     R0,[R3, #+28]
//  175   }
        ADDS     R2,R2,#+1
        B.N      ??DeInitStateMachine_2
//  176   
//  177   phost->gState = HOST_IDLE;
??DeInitStateMachine_3:
        MOVS     R0,#+0
        STRB     R0,[R1, #+0]
//  178   phost->EnumState = ENUM_IDLE;
        MOVS     R0,#+0
        STRB     R0,[R1, #+1]
//  179   phost->RequestState = CMD_SEND;
        MOVS     R0,#+1
        STRB     R0,[R1, #+2]
//  180   phost->Timer = 0;  
        MOVS     R0,#+0
        STR      R0,[R1, #+680]
//  181   
//  182   phost->Control.state = CTRL_SETUP;
        MOVS     R0,#+1
        STRB     R0,[R1, #+24]
//  183   phost->Control.pipe_size = USBH_MPS_DEFAULT;  
        MOVS     R0,#+64
        STRB     R0,[R1, #+6]
//  184   phost->Control.errorcount = 0;
        MOVS     R0,#+0
        STRB     R0,[R1, #+25]
//  185   
//  186   phost->device.address = USBH_ADDRESS_DEFAULT;
        MOVS     R0,#+0
        STRB     R0,[R1, #+540]
//  187   phost->device.speed   = USBH_SPEED_FULL;
        MOVS     R0,#+1
        STRB     R0,[R1, #+541]
//  188   
//  189   return USBH_OK;
        MOVS     R0,#+0
        BX       LR               ;; return
//  190 }
          CFI EndBlock cfiBlock2
//  191 
//  192 /**
//  193   * @brief  USBH_RegisterClass 
//  194   *         Link class driver to Host Core.
//  195   * @param  phost : Host Handle
//  196   * @param  pclass: Class handle
//  197   * @retval USBH Status
//  198   */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock3 Using cfiCommon0
          CFI Function USBH_RegisterClass
        THUMB
//  199 USBH_StatusTypeDef  USBH_RegisterClass(USBH_HandleTypeDef *phost, USBH_ClassTypeDef *pclass)
//  200 {
USBH_RegisterClass:
        PUSH     {R4-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
        MOVS     R4,R0
        MOVS     R5,R1
//  201   USBH_StatusTypeDef   status = USBH_OK;
        MOVS     R6,#+0
//  202   
//  203   if(pclass != 0)
        CMP      R5,#+0
        BEQ.N    ??USBH_RegisterClass_0
//  204   {
//  205     if(phost->ClassNumber < USBH_MAX_NUM_SUPPORTED_CLASS)
        LDR      R0,[R4, #+616]
        CMP      R0,#+0
        BNE.N    ??USBH_RegisterClass_1
//  206     {
//  207       /* link the class to the USB Host handle */
//  208       phost->pClass[phost->ClassNumber++] = pclass;
        LDR      R0,[R4, #+616]
        ADDS     R1,R0,#+1
        STR      R1,[R4, #+616]
        ADDS     R0,R4,R0, LSL #+2
        STR      R5,[R0, #+608]
//  209       status = USBH_OK;
        MOVS     R0,#+0
        MOVS     R6,R0
        B.N      ??USBH_RegisterClass_2
//  210     }
//  211     else
//  212     {
//  213       USBH_ErrLog("Max Class Number reached");
??USBH_RegisterClass_1:
        LDR.W    R0,??DataTable5_1
          CFI FunCall printf
        BL       printf
        LDR.W    R0,??DataTable5_3
          CFI FunCall printf
        BL       printf
        ADR.N    R0,??DataTable2  ;; "\n"
          CFI FunCall printf
        BL       printf
//  214       status = USBH_FAIL; 
        MOVS     R0,#+2
        MOVS     R6,R0
        B.N      ??USBH_RegisterClass_2
//  215     }
//  216   }
//  217   else
//  218   {
//  219     USBH_ErrLog("Invalid Class handle");
??USBH_RegisterClass_0:
        LDR.W    R0,??DataTable5_1
          CFI FunCall printf
        BL       printf
        LDR.W    R0,??DataTable5_4
          CFI FunCall printf
        BL       printf
        ADR.N    R0,??DataTable2  ;; "\n"
          CFI FunCall printf
        BL       printf
//  220     status = USBH_FAIL; 
        MOVS     R0,#+2
        MOVS     R6,R0
//  221   }
//  222   
//  223   return status;
??USBH_RegisterClass_2:
        MOVS     R0,R6
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        POP      {R4-R6,PC}       ;; return
//  224 }
          CFI EndBlock cfiBlock3
//  225 
//  226 /**
//  227   * @brief  USBH_SelectInterface 
//  228   *         Select current interface.
//  229   * @param  phost: Host Handle
//  230   * @param  interface: Interface number
//  231   * @retval USBH Status
//  232   */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock4 Using cfiCommon0
          CFI Function USBH_SelectInterface
        THUMB
//  233 USBH_StatusTypeDef USBH_SelectInterface(USBH_HandleTypeDef *phost, uint8_t interface)
//  234 {
USBH_SelectInterface:
        PUSH     {R4-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
        MOVS     R4,R0
        MOVS     R5,R1
//  235   USBH_StatusTypeDef   status = USBH_OK;
        MOVS     R6,#+0
//  236   
//  237   if(interface < phost->device.CfgDesc.bNumInterfaces)
        LDRB     R0,[R4, #+566]
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        CMP      R5,R0
        BCS.N    ??USBH_SelectInterface_0
//  238   {
//  239     phost->device.current_interface = interface;
        STRB     R5,[R4, #+543]
//  240     USBH_UsrLog ("Switching to Interface (#%d)", interface);
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        MOVS     R1,R5
        LDR.W    R0,??DataTable5_5
          CFI FunCall printf
        BL       printf
        ADR.N    R0,??DataTable2  ;; "\n"
          CFI FunCall printf
        BL       printf
//  241     USBH_UsrLog ("Class    : %xh", phost->device.CfgDesc.Itf_Desc[interface].bInterfaceClass );
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        MOVS     R0,#+34
        MLA      R0,R0,R5,R4
        LDRB     R1,[R0, #+577]
        LDR.W    R0,??DataTable5_6
          CFI FunCall printf
        BL       printf
        ADR.N    R0,??DataTable2  ;; "\n"
          CFI FunCall printf
        BL       printf
//  242     USBH_UsrLog ("SubClass : %xh", phost->device.CfgDesc.Itf_Desc[interface].bInterfaceSubClass );
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        MOVS     R0,#+34
        MLA      R0,R0,R5,R4
        LDRB     R1,[R0, #+578]
        LDR.W    R0,??DataTable5_7
          CFI FunCall printf
        BL       printf
        ADR.N    R0,??DataTable2  ;; "\n"
          CFI FunCall printf
        BL       printf
//  243     USBH_UsrLog ("Protocol : %xh", phost->device.CfgDesc.Itf_Desc[interface].bInterfaceProtocol );                 
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        MOVS     R0,#+34
        MLA      R0,R0,R5,R4
        LDRB     R1,[R0, #+579]
        LDR.W    R0,??DataTable5_8
          CFI FunCall printf
        BL       printf
        ADR.N    R0,??DataTable2  ;; "\n"
          CFI FunCall printf
        BL       printf
        B.N      ??USBH_SelectInterface_1
//  244   }
//  245   else
//  246   {
//  247     USBH_ErrLog ("Cannot Select This Interface.");
??USBH_SelectInterface_0:
        LDR.W    R0,??DataTable5_1
          CFI FunCall printf
        BL       printf
        LDR.W    R0,??DataTable5_9
          CFI FunCall printf
        BL       printf
        ADR.N    R0,??DataTable2  ;; "\n"
          CFI FunCall printf
        BL       printf
//  248     status = USBH_FAIL; 
        MOVS     R0,#+2
        MOVS     R6,R0
//  249   }
//  250   return status;  
??USBH_SelectInterface_1:
        MOVS     R0,R6
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        POP      {R4-R6,PC}       ;; return
//  251 }
          CFI EndBlock cfiBlock4

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable2:
        DC8      "\n",0x0,0x0
//  252 
//  253 /**
//  254   * @brief  USBH_GetActiveClass 
//  255   *         Return Device Class.
//  256   * @param  phost: Host Handle
//  257   * @param  interface: Interface index
//  258   * @retval Class Code
//  259   */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock5 Using cfiCommon0
          CFI Function USBH_GetActiveClass
          CFI NoCalls
        THUMB
//  260 uint8_t USBH_GetActiveClass(USBH_HandleTypeDef *phost)
//  261 {
//  262    return (phost->device.CfgDesc.Itf_Desc[0].bInterfaceClass);            
USBH_GetActiveClass:
        LDRB     R0,[R0, #+577]
        BX       LR               ;; return
//  263 }
          CFI EndBlock cfiBlock5
//  264 /**
//  265   * @brief  USBH_FindInterface 
//  266   *         Find the interface index for a specific class.
//  267   * @param  phost: Host Handle
//  268   * @param  Class: Class code
//  269   * @param  SubClass: SubClass code
//  270   * @param  Protocol: Protocol code
//  271   * @retval interface index in the configuration structure
//  272   * @note : (1)interface index 0xFF means interface index not found
//  273   */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock6 Using cfiCommon0
          CFI Function USBH_FindInterface
          CFI NoCalls
        THUMB
//  274 uint8_t  USBH_FindInterface(USBH_HandleTypeDef *phost, uint8_t Class, uint8_t SubClass, uint8_t Protocol)
//  275 {
USBH_FindInterface:
        PUSH     {R4-R7}
          CFI R7 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
        MOVS     R4,R0
//  276   USBH_InterfaceDescTypeDef    *pif ;
//  277   USBH_CfgDescTypeDef          *pcfg ;
//  278   int8_t                        if_ix = 0;
        MOVS     R7,#+0
//  279   
//  280   pif = (USBH_InterfaceDescTypeDef *)0;
        MOVS     R0,#+0
        MOVS     R5,R0
//  281   pcfg = &phost->device.CfgDesc;  
        ADDW     R0,R4,#+562
        MOVS     R6,R0
//  282   
//  283   while (if_ix < USBH_MAX_NUM_INTERFACES)
??USBH_FindInterface_0:
        SXTB     R7,R7            ;; SignExt  R7,R7,#+24,#+24
        CMP      R7,#+1
        BGE.N    ??USBH_FindInterface_1
//  284   {
//  285     pif = &pcfg->Itf_Desc[if_ix];
        SXTB     R7,R7            ;; SignExt  R7,R7,#+24,#+24
        MOVS     R0,#+34
        SMLABB   R0,R7,R0,R6
        ADDS     R0,R0,#+10
        MOVS     R5,R0
//  286     if(((pif->bInterfaceClass == Class) || (Class == 0xFF))&&
//  287        ((pif->bInterfaceSubClass == SubClass) || (SubClass == 0xFF))&&
//  288          ((pif->bInterfaceProtocol == Protocol) || (Protocol == 0xFF)))
        LDRB     R0,[R5, #+5]
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        CMP      R0,R1
        BEQ.N    ??USBH_FindInterface_2
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        CMP      R1,#+255
        BNE.N    ??USBH_FindInterface_3
??USBH_FindInterface_2:
        LDRB     R0,[R5, #+6]
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        CMP      R0,R2
        BEQ.N    ??USBH_FindInterface_4
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        CMP      R2,#+255
        BNE.N    ??USBH_FindInterface_3
??USBH_FindInterface_4:
        LDRB     R0,[R5, #+7]
        UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
        CMP      R0,R3
        BEQ.N    ??USBH_FindInterface_5
        UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
        CMP      R3,#+255
        BNE.N    ??USBH_FindInterface_3
//  289     {
//  290       return  if_ix;
??USBH_FindInterface_5:
        MOVS     R0,R7
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        B.N      ??USBH_FindInterface_6
//  291     }
//  292     if_ix++;
??USBH_FindInterface_3:
        ADDS     R7,R7,#+1
        B.N      ??USBH_FindInterface_0
//  293   }
//  294   return 0xFF;
??USBH_FindInterface_1:
        MOVS     R0,#+255
??USBH_FindInterface_6:
        POP      {R4-R7}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI CFA R13+0
        BX       LR               ;; return
//  295 }
          CFI EndBlock cfiBlock6
//  296 
//  297 /**
//  298   * @brief  USBH_FindInterfaceIndex 
//  299   *         Find the interface index for a specific class interface and alternate setting number.
//  300   * @param  phost: Host Handle
//  301   * @param  interface_number: interface number
//  302   * @param  alt_settings    : alternate setting number
//  303   * @retval interface index in the configuration structure
//  304   * @note : (1)interface index 0xFF means interface index not found
//  305   */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock7 Using cfiCommon0
          CFI Function USBH_FindInterfaceIndex
          CFI NoCalls
        THUMB
//  306 uint8_t  USBH_FindInterfaceIndex(USBH_HandleTypeDef *phost, uint8_t interface_number, uint8_t alt_settings)
//  307 {
USBH_FindInterfaceIndex:
        PUSH     {R4-R6}
          CFI R6 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+12
        MOVS     R3,R0
//  308   USBH_InterfaceDescTypeDef    *pif ;
//  309   USBH_CfgDescTypeDef          *pcfg ;
//  310   int8_t                        if_ix = 0;
        MOVS     R6,#+0
//  311   
//  312   pif = (USBH_InterfaceDescTypeDef *)0;
        MOVS     R0,#+0
        MOVS     R4,R0
//  313   pcfg = &phost->device.CfgDesc;  
        ADDW     R0,R3,#+562
        MOVS     R5,R0
//  314   
//  315   while (if_ix < USBH_MAX_NUM_INTERFACES)
??USBH_FindInterfaceIndex_0:
        SXTB     R6,R6            ;; SignExt  R6,R6,#+24,#+24
        CMP      R6,#+1
        BGE.N    ??USBH_FindInterfaceIndex_1
//  316   {
//  317     pif = &pcfg->Itf_Desc[if_ix];
        SXTB     R6,R6            ;; SignExt  R6,R6,#+24,#+24
        MOVS     R0,#+34
        SMLABB   R0,R6,R0,R5
        ADDS     R0,R0,#+10
        MOVS     R4,R0
//  318     if((pif->bInterfaceNumber == interface_number) && (pif->bAlternateSetting == alt_settings))
        LDRB     R0,[R4, #+2]
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        CMP      R0,R1
        BNE.N    ??USBH_FindInterfaceIndex_2
        LDRB     R0,[R4, #+3]
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        CMP      R0,R2
        BNE.N    ??USBH_FindInterfaceIndex_2
//  319     {
//  320       return  if_ix;
        MOVS     R0,R6
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        B.N      ??USBH_FindInterfaceIndex_3
//  321     }
//  322     if_ix++;
??USBH_FindInterfaceIndex_2:
        ADDS     R6,R6,#+1
        B.N      ??USBH_FindInterfaceIndex_0
//  323   }
//  324   return 0xFF;
??USBH_FindInterfaceIndex_1:
        MOVS     R0,#+255
??USBH_FindInterfaceIndex_3:
        POP      {R4-R6}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI CFA R13+0
        BX       LR               ;; return
//  325 }
          CFI EndBlock cfiBlock7
//  326 
//  327 /**
//  328   * @brief  USBH_Start 
//  329   *         Start the USB Host Core.
//  330   * @param  phost: Host Handle
//  331   * @retval USBH Status
//  332   */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock8 Using cfiCommon0
          CFI Function USBH_Start
        THUMB
//  333 USBH_StatusTypeDef  USBH_Start  (USBH_HandleTypeDef *phost)
//  334 {
USBH_Start:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        MOVS     R4,R0
//  335   /* Start the low level driver  */
//  336   USBH_LL_Start(phost);
        MOVS     R0,R4
          CFI FunCall USBH_LL_Start
        BL       USBH_LL_Start
//  337   
//  338   /* Activate VBUS on the port */ 
//  339   USBH_LL_DriverVBUS (phost, TRUE);
        MOVS     R1,#+1
        MOVS     R0,R4
          CFI FunCall USBH_LL_DriverVBUS
        BL       USBH_LL_DriverVBUS
//  340   
//  341   return USBH_OK;  
        MOVS     R0,#+0
        POP      {R4,PC}          ;; return
//  342 }
          CFI EndBlock cfiBlock8
//  343 
//  344 /**
//  345   * @brief  USBH_Stop 
//  346   *         Stop the USB Host Core.
//  347   * @param  phost: Host Handle
//  348   * @retval USBH Status
//  349   */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock9 Using cfiCommon0
          CFI Function USBH_Stop
        THUMB
//  350 USBH_StatusTypeDef  USBH_Stop   (USBH_HandleTypeDef *phost)
//  351 {
USBH_Stop:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        MOVS     R4,R0
//  352   /* Stop and cleanup the low level driver  */
//  353   USBH_LL_Stop(phost);  
        MOVS     R0,R4
          CFI FunCall USBH_LL_Stop
        BL       USBH_LL_Stop
//  354   
//  355   /* DeActivate VBUS on the port */ 
//  356   USBH_LL_DriverVBUS (phost, FALSE);
        MOVS     R1,#+0
        MOVS     R0,R4
          CFI FunCall USBH_LL_DriverVBUS
        BL       USBH_LL_DriverVBUS
//  357   
//  358   /* FRee Control Pipes */
//  359   USBH_FreePipe  (phost, phost->Control.pipe_in);
        LDRB     R1,[R4, #+4]
        MOVS     R0,R4
          CFI FunCall USBH_FreePipe
        BL       USBH_FreePipe
//  360   USBH_FreePipe  (phost, phost->Control.pipe_out);  
        LDRB     R1,[R4, #+5]
        MOVS     R0,R4
          CFI FunCall USBH_FreePipe
        BL       USBH_FreePipe
//  361   
//  362   return USBH_OK;  
        MOVS     R0,#+0
        POP      {R4,PC}          ;; return
//  363 }
          CFI EndBlock cfiBlock9
//  364 
//  365 /**
//  366   * @brief  HCD_ReEnumerate 
//  367   *         Perform a new Enumeration phase.
//  368   * @param  phost: Host Handle
//  369   * @retval USBH Status
//  370   */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock10 Using cfiCommon0
          CFI Function USBH_ReEnumerate
        THUMB
//  371 USBH_StatusTypeDef  USBH_ReEnumerate   (USBH_HandleTypeDef *phost)
//  372 {
USBH_ReEnumerate:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        MOVS     R4,R0
//  373   /*Stop Host */ 
//  374   USBH_Stop(phost);
        MOVS     R0,R4
          CFI FunCall USBH_Stop
        BL       USBH_Stop
//  375 
//  376   /*Device has disconnected, so wait for 200 ms */  
//  377   USBH_Delay(200);
        MOVS     R0,#+200
          CFI FunCall USBH_Delay
        BL       USBH_Delay
//  378   
//  379   /* Set State machines in default state */
//  380   DeInitStateMachine(phost);
        MOVS     R0,R4
          CFI FunCall DeInitStateMachine
        BL       DeInitStateMachine
//  381    
//  382   /* Start again the host */
//  383   USBH_Start(phost);
        MOVS     R0,R4
          CFI FunCall USBH_Start
        BL       USBH_Start
//  384       
//  385 #if (USBH_USE_OS == 1)
//  386       osMessagePut ( phost->os_event, USBH_PORT_EVENT, 0);
//  387 #endif  
//  388   return USBH_OK;  
        MOVS     R0,#+0
        POP      {R4,PC}          ;; return
//  389 }
          CFI EndBlock cfiBlock10
//  390 
//  391 /**
//  392   * @brief  USBH_Process 
//  393   *         Background process of the USB Core.
//  394   * @param  phost: Host Handle
//  395   * @retval USBH Status
//  396   */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock11 Using cfiCommon0
          CFI Function USBH_Process
        THUMB
//  397 USBH_StatusTypeDef  USBH_Process(USBH_HandleTypeDef *phost)
//  398 {
USBH_Process:
        PUSH     {R4,R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+12
        SUB      SP,SP,#+20
          CFI CFA R13+32
        MOVS     R4,R0
//  399   __IO USBH_StatusTypeDef status = USBH_FAIL;
        MOVS     R0,#+2
        STRB     R0,[SP, #+12]
//  400   uint8_t idx = 0;
        MOVS     R5,#+0
//  401   
//  402   switch (phost->gState)
        LDRB     R0,[R4, #+0]
        CMP      R0,#+0
        BEQ.N    ??USBH_Process_0
        CMP      R0,#+1
        BEQ.N    ??USBH_Process_1
        CMP      R0,#+2
        BEQ.N    ??USBH_Process_2
        CMP      R0,#+3
        BEQ.W    ??USBH_Process_3
        CMP      R0,#+5
        BEQ.N    ??USBH_Process_4
        CMP      R0,#+6
        BEQ.W    ??USBH_Process_5
        CMP      R0,#+7
        BEQ.N    ??USBH_Process_6
        CMP      R0,#+8
        BEQ.N    ??USBH_Process_7
        CMP      R0,#+9
        BEQ.W    ??USBH_Process_8
        CMP      R0,#+10
        BEQ.W    ??USBH_Process_9
        B.N      ??USBH_Process_10
//  403   {
//  404   case HOST_IDLE :
//  405     
//  406     if (phost->device.is_connected)  
??USBH_Process_0:
        LDRB     R0,[R4, #+542]
        CMP      R0,#+0
        BEQ.N    ??USBH_Process_11
//  407     {
//  408       /* Wait for 200 ms after connection */
//  409       phost->gState = HOST_DEV_WAIT_FOR_ATTACHMENT; 
        MOVS     R0,#+1
        STRB     R0,[R4, #+0]
//  410       USBH_Delay(200); 
        MOVS     R0,#+200
          CFI FunCall USBH_Delay
        BL       USBH_Delay
//  411       USBH_LL_ResetPort(phost);
        MOVS     R0,R4
          CFI FunCall USBH_LL_ResetPort
        BL       USBH_LL_ResetPort
//  412 #if (USBH_USE_OS == 1)
//  413       osMessagePut ( phost->os_event, USBH_PORT_EVENT, 0);
//  414 #endif
//  415     }
//  416     break;
??USBH_Process_11:
        B.N      ??USBH_Process_12
//  417     
//  418   case HOST_DEV_WAIT_FOR_ATTACHMENT:
//  419     break;    
??USBH_Process_1:
        B.N      ??USBH_Process_12
//  420     
//  421   case HOST_DEV_ATTACHED :
//  422     
//  423     USBH_UsrLog("USB Device Attached");  
??USBH_Process_2:
        LDR.W    R0,??DataTable5_10
          CFI FunCall printf
        BL       printf
        ADR.N    R0,??DataTable3  ;; "\n"
          CFI FunCall printf
        BL       printf
//  424       
//  425     /* Wait for 100 ms after Reset */
//  426     USBH_Delay(100); 
        MOVS     R0,#+100
          CFI FunCall USBH_Delay
        BL       USBH_Delay
//  427           
//  428     phost->device.speed = USBH_LL_GetSpeed(phost);
        MOVS     R0,R4
          CFI FunCall USBH_LL_GetSpeed
        BL       USBH_LL_GetSpeed
        STRB     R0,[R4, #+541]
//  429     
//  430     phost->gState = HOST_ENUMERATION;
        MOVS     R0,#+5
        STRB     R0,[R4, #+0]
//  431     
//  432     phost->Control.pipe_out = USBH_AllocPipe (phost, 0x00);
        MOVS     R1,#+0
        MOVS     R0,R4
          CFI FunCall USBH_AllocPipe
        BL       USBH_AllocPipe
        STRB     R0,[R4, #+5]
//  433     phost->Control.pipe_in  = USBH_AllocPipe (phost, 0x80);    
        MOVS     R1,#+128
        MOVS     R0,R4
          CFI FunCall USBH_AllocPipe
        BL       USBH_AllocPipe
        STRB     R0,[R4, #+4]
//  434     
//  435     
//  436     /* Open Control pipes */
//  437     USBH_OpenPipe (phost,
//  438                    phost->Control.pipe_in,
//  439                    0x80,
//  440                    phost->device.address,
//  441                    phost->device.speed,
//  442                    USBH_EP_CONTROL,
//  443                    phost->Control.pipe_size); 
        LDRB     R0,[R4, #+6]
        UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
        STR      R0,[SP, #+8]
        MOVS     R0,#+0
        STR      R0,[SP, #+4]
        LDRB     R0,[R4, #+541]
        STR      R0,[SP, #+0]
        LDRB     R3,[R4, #+540]
        MOVS     R2,#+128
        LDRB     R1,[R4, #+4]
        MOVS     R0,R4
          CFI FunCall USBH_OpenPipe
        BL       USBH_OpenPipe
//  444     
//  445     /* Open Control pipes */
//  446     USBH_OpenPipe (phost,
//  447                    phost->Control.pipe_out,
//  448                    0x00,
//  449                    phost->device.address,
//  450                    phost->device.speed,
//  451                    USBH_EP_CONTROL,
//  452                    phost->Control.pipe_size);
        LDRB     R0,[R4, #+6]
        UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
        STR      R0,[SP, #+8]
        MOVS     R0,#+0
        STR      R0,[SP, #+4]
        LDRB     R0,[R4, #+541]
        STR      R0,[SP, #+0]
        LDRB     R3,[R4, #+540]
        MOVS     R2,#+0
        LDRB     R1,[R4, #+5]
        MOVS     R0,R4
          CFI FunCall USBH_OpenPipe
        BL       USBH_OpenPipe
//  453     
//  454 #if (USBH_USE_OS == 1)
//  455     osMessagePut ( phost->os_event, USBH_PORT_EVENT, 0);
//  456 #endif    
//  457     
//  458     break;
        B.N      ??USBH_Process_12
//  459     
//  460   case HOST_ENUMERATION:     
//  461     /* Check for enumeration status */  
//  462     if ( USBH_HandleEnum(phost) == USBH_OK)
??USBH_Process_4:
        MOVS     R0,R4
          CFI FunCall USBH_HandleEnum
        BL       USBH_HandleEnum
        CMP      R0,#+0
        BNE.N    ??USBH_Process_13
//  463     { 
//  464       /* The function shall return USBH_OK when full enumeration is complete */
//  465       USBH_UsrLog ("Enumeration done.");
        LDR.W    R0,??DataTable5_11
          CFI FunCall printf
        BL       printf
        ADR.N    R0,??DataTable3  ;; "\n"
          CFI FunCall printf
        BL       printf
//  466       phost->device.current_interface = 0;
        MOVS     R0,#+0
        STRB     R0,[R4, #+543]
//  467       if(phost->device.DevDesc.bNumConfigurations == 1)
        LDRB     R0,[R4, #+561]
        CMP      R0,#+1
        BNE.N    ??USBH_Process_14
//  468       {
//  469         USBH_UsrLog ("This device has only 1 configuration.");
        LDR.W    R0,??DataTable5_12
          CFI FunCall printf
        BL       printf
        ADR.N    R0,??DataTable3  ;; "\n"
          CFI FunCall printf
        BL       printf
//  470         phost->gState  = HOST_SET_CONFIGURATION;        
        MOVS     R0,#+8
        STRB     R0,[R4, #+0]
        B.N      ??USBH_Process_13
//  471         
//  472       }
//  473       else
//  474       {
//  475         phost->gState  = HOST_INPUT; 
??USBH_Process_14:
        MOVS     R0,#+7
        STRB     R0,[R4, #+0]
//  476       }
//  477           
//  478     }
//  479     break;
??USBH_Process_13:
        B.N      ??USBH_Process_12
//  480     
//  481   case HOST_INPUT:
//  482     {
//  483       /* user callback for end of device basic enumeration */
//  484       if(phost->pUser != NULL)
??USBH_Process_6:
        LDR      R0,[R4, #+692]
        CMP      R0,#+0
        BEQ.N    ??USBH_Process_15
//  485       {
//  486         phost->pUser(phost, HOST_USER_SELECT_CONFIGURATION);
        MOVS     R1,#+1
        MOVS     R0,R4
        LDR      R2,[R4, #+692]
          CFI FunCall
        BLX      R2
//  487         phost->gState = HOST_SET_CONFIGURATION;
        MOVS     R0,#+8
        STRB     R0,[R4, #+0]
//  488         
//  489 #if (USBH_USE_OS == 1)
//  490         osMessagePut ( phost->os_event, USBH_STATE_CHANGED_EVENT, 0);
//  491 #endif         
//  492       }
//  493     }
//  494     break;
??USBH_Process_15:
        B.N      ??USBH_Process_12
//  495     
//  496   case HOST_SET_CONFIGURATION:
//  497     /* set configuration */
//  498     if (USBH_SetCfg(phost, phost->device.CfgDesc.bConfigurationValue) == USBH_OK)
??USBH_Process_7:
        LDRB     R1,[R4, #+567]
        UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
        MOVS     R0,R4
          CFI FunCall USBH_SetCfg
        BL       USBH_SetCfg
        CMP      R0,#+0
        BNE.N    ??USBH_Process_16
//  499     {
//  500       phost->gState  = HOST_CHECK_CLASS;
        MOVS     R0,#+9
        STRB     R0,[R4, #+0]
//  501       USBH_UsrLog ("Default configuration set.");
        LDR.W    R0,??DataTable5_13
          CFI FunCall printf
        BL       printf
        ADR.N    R0,??DataTable3  ;; "\n"
          CFI FunCall printf
        BL       printf
//  502       
//  503     }      
//  504     
//  505     break;
??USBH_Process_16:
        B.N      ??USBH_Process_12
//  506     
//  507   case HOST_CHECK_CLASS:
//  508     
//  509     if(phost->ClassNumber == 0)
??USBH_Process_8:
        LDR      R0,[R4, #+616]
        CMP      R0,#+0
        BNE.N    ??USBH_Process_17
//  510     {
//  511       USBH_UsrLog ("No Class has been registered.");
        LDR.W    R0,??DataTable5_14
          CFI FunCall printf
        BL       printf
        ADR.N    R0,??DataTable3  ;; "\n"
          CFI FunCall printf
        BL       printf
        B.N      ??USBH_Process_18
//  512     }
//  513     else
//  514     {
//  515       phost->pActiveClass = NULL;
??USBH_Process_17:
        MOVS     R0,#+0
        STR      R0,[R4, #+612]
//  516       
//  517       for (idx = 0; idx < USBH_MAX_NUM_SUPPORTED_CLASS ; idx ++)
        MOVS     R0,#+0
        MOVS     R5,R0
??USBH_Process_19:
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        CMP      R5,#+0
        BNE.N    ??USBH_Process_20
//  518       {
//  519         if(phost->pClass[idx]->ClassCode == phost->device.CfgDesc.Itf_Desc[0].bInterfaceClass)
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        ADDS     R0,R4,R5, LSL #+2
        LDR      R0,[R0, #+608]
        LDRB     R0,[R0, #+4]
        LDRB     R1,[R4, #+577]
        CMP      R0,R1
        BNE.N    ??USBH_Process_21
//  520         {
//  521           phost->pActiveClass = phost->pClass[idx];
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        ADDS     R0,R4,R5, LSL #+2
        LDR      R0,[R0, #+608]
        STR      R0,[R4, #+612]
//  522         }
//  523       }
??USBH_Process_21:
        ADDS     R5,R5,#+1
        B.N      ??USBH_Process_19
//  524       
//  525       if(phost->pActiveClass != NULL)
??USBH_Process_20:
        LDR      R0,[R4, #+612]
        CMP      R0,#+0
        BEQ.N    ??USBH_Process_22
//  526       {
//  527         if(phost->pActiveClass->Init(phost)== USBH_OK)
        MOVS     R0,R4
        LDR      R1,[R4, #+612]
        LDR      R1,[R1, #+8]
          CFI FunCall
        BLX      R1
        CMP      R0,#+0
        BNE.N    ??USBH_Process_23
//  528         {
//  529           phost->gState  = HOST_CLASS_REQUEST; 
        MOVS     R0,#+6
        STRB     R0,[R4, #+0]
//  530           USBH_UsrLog ("%s class started.", phost->pActiveClass->Name);
        LDR      R0,[R4, #+612]
        LDR      R1,[R0, #+0]
        LDR.W    R0,??DataTable5_15
          CFI FunCall printf
        BL       printf
        ADR.N    R0,??DataTable3  ;; "\n"
          CFI FunCall printf
        BL       printf
//  531           
//  532           /* Inform user that a class has been activated */
//  533           phost->pUser(phost, HOST_USER_CLASS_SELECTED);   
        MOVS     R1,#+3
        MOVS     R0,R4
        LDR      R2,[R4, #+692]
          CFI FunCall
        BLX      R2
        B.N      ??USBH_Process_18
//  534         }
//  535         else
//  536         {
//  537           phost->gState  = HOST_ABORT_STATE;
??USBH_Process_23:
        MOVS     R0,#+12
        STRB     R0,[R4, #+0]
//  538           USBH_UsrLog ("Device not supporting %s class.", phost->pActiveClass->Name);
        LDR      R0,[R4, #+612]
        LDR      R1,[R0, #+0]
        LDR.W    R0,??DataTable5_16
          CFI FunCall printf
        BL       printf
        ADR.N    R0,??DataTable3  ;; "\n"
          CFI FunCall printf
        BL       printf
        B.N      ??USBH_Process_18
//  539         }
//  540       }
//  541       else
//  542       {
//  543         phost->gState  = HOST_ABORT_STATE;
??USBH_Process_22:
        MOVS     R0,#+12
        STRB     R0,[R4, #+0]
//  544         USBH_UsrLog ("No registered class for this device.");
        LDR.W    R0,??DataTable5_17
          CFI FunCall printf
        BL       printf
        ADR.N    R0,??DataTable3  ;; "\n"
          CFI FunCall printf
        BL       printf
//  545       }
//  546     }
//  547     
//  548 #if (USBH_USE_OS == 1)
//  549     osMessagePut ( phost->os_event, USBH_STATE_CHANGED_EVENT, 0);
//  550 #endif 
//  551     break;    
??USBH_Process_18:
        B.N      ??USBH_Process_12
//  552     
//  553   case HOST_CLASS_REQUEST:  
//  554     /* process class standard control requests state machine */
//  555     if(phost->pActiveClass != NULL)
??USBH_Process_5:
        LDR      R0,[R4, #+612]
        CMP      R0,#+0
        BEQ.N    ??USBH_Process_24
//  556     {
//  557       status = phost->pActiveClass->Requests(phost);
        MOVS     R0,R4
        LDR      R1,[R4, #+612]
        LDR      R1,[R1, #+16]
          CFI FunCall
        BLX      R1
        STRB     R0,[SP, #+12]
//  558       
//  559       if(status == USBH_OK)
        LDRB     R0,[SP, #+12]
        CMP      R0,#+0
        BNE.N    ??USBH_Process_25
//  560       {
//  561         phost->gState  = HOST_CLASS;        
        MOVS     R0,#+10
        STRB     R0,[R4, #+0]
        B.N      ??USBH_Process_25
//  562       }  
//  563     }
//  564     else
//  565     {
//  566       phost->gState  = HOST_ABORT_STATE;
??USBH_Process_24:
        MOVS     R0,#+12
        STRB     R0,[R4, #+0]
//  567       USBH_ErrLog ("Invalid Class Driver.");
        LDR.N    R0,??DataTable5_1
          CFI FunCall printf
        BL       printf
        LDR.N    R0,??DataTable5_18
          CFI FunCall printf
        BL       printf
        ADR.N    R0,??DataTable3  ;; "\n"
          CFI FunCall printf
        BL       printf
//  568     
//  569 #if (USBH_USE_OS == 1)
//  570     osMessagePut ( phost->os_event, USBH_STATE_CHANGED_EVENT, 0);
//  571 #endif       
//  572     }
//  573     
//  574     break;    
??USBH_Process_25:
        B.N      ??USBH_Process_12
//  575   case HOST_CLASS:   
//  576     /* process class state machine */
//  577     if(phost->pActiveClass != NULL)
??USBH_Process_9:
        LDR      R0,[R4, #+612]
        CMP      R0,#+0
        BEQ.N    ??USBH_Process_26
//  578     { 
//  579       phost->pActiveClass->BgndProcess(phost);
        MOVS     R0,R4
        LDR      R1,[R4, #+612]
        LDR      R1,[R1, #+20]
          CFI FunCall
        BLX      R1
//  580     }
//  581     break;       
??USBH_Process_26:
        B.N      ??USBH_Process_12
//  582 
//  583   case HOST_DEV_DISCONNECTED :
//  584     
//  585     DeInitStateMachine(phost);  
??USBH_Process_3:
        MOVS     R0,R4
          CFI FunCall DeInitStateMachine
        BL       DeInitStateMachine
//  586     
//  587     /* Re-Initilaize Host for new Enumeration */
//  588     if(phost->pActiveClass != NULL)
        LDR      R0,[R4, #+612]
        CMP      R0,#+0
        BEQ.N    ??USBH_Process_27
//  589     {
//  590       phost->pActiveClass->DeInit(phost); 
        MOVS     R0,R4
        LDR      R1,[R4, #+612]
        LDR      R1,[R1, #+12]
          CFI FunCall
        BLX      R1
//  591       phost->pActiveClass = NULL;
        MOVS     R0,#+0
        STR      R0,[R4, #+612]
//  592     }     
//  593     break;
??USBH_Process_27:
        B.N      ??USBH_Process_12
//  594     
//  595   case HOST_ABORT_STATE:
//  596   default :
//  597     break;
//  598   }
//  599  return USBH_OK;  
??USBH_Process_10:
??USBH_Process_12:
        MOVS     R0,#+0
        ADD      SP,SP,#+20
          CFI CFA R13+12
        POP      {R4,R5,PC}       ;; return
//  600 }
          CFI EndBlock cfiBlock11

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable3:
        DC8      "\n",0x0,0x0
//  601 
//  602 
//  603 /**
//  604   * @brief  USBH_HandleEnum 
//  605   *         This function includes the complete enumeration process
//  606   * @param  phost: Host Handle
//  607   * @retval USBH_Status
//  608   */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock12 Using cfiCommon0
          CFI Function USBH_HandleEnum
        THUMB
//  609 static USBH_StatusTypeDef USBH_HandleEnum (USBH_HandleTypeDef *phost)
//  610 {
USBH_HandleEnum:
        PUSH     {R1-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+24
        MOVS     R4,R0
//  611   USBH_StatusTypeDef Status = USBH_BUSY;  
        MOVS     R5,#+1
//  612   
//  613   switch (phost->EnumState)
        LDRB     R0,[R4, #+1]
        CMP      R0,#+0
        BEQ.N    ??USBH_HandleEnum_0
        CMP      R0,#+2
        BEQ.N    ??USBH_HandleEnum_1
        BCC.N    ??USBH_HandleEnum_2
        CMP      R0,#+4
        BEQ.W    ??USBH_HandleEnum_3
        BCC.W    ??USBH_HandleEnum_4
        CMP      R0,#+6
        BEQ.W    ??USBH_HandleEnum_5
        BCC.W    ??USBH_HandleEnum_6
        CMP      R0,#+7
        BEQ.W    ??USBH_HandleEnum_7
        B.N      ??USBH_HandleEnum_8
//  614   {
//  615   case ENUM_IDLE:  
//  616     /* Get Device Desc for only 1st 8 bytes : To get EP0 MaxPacketSize */
//  617     if ( USBH_Get_DevDesc(phost, 8) == USBH_OK)
??USBH_HandleEnum_0:
        MOVS     R1,#+8
        MOVS     R0,R4
          CFI FunCall USBH_Get_DevDesc
        BL       USBH_Get_DevDesc
        CMP      R0,#+0
        BNE.N    ??USBH_HandleEnum_9
//  618     {
//  619       phost->Control.pipe_size = phost->device.DevDesc.bMaxPacketSize;
        LDRB     R0,[R4, #+551]
        STRB     R0,[R4, #+6]
//  620 
//  621       phost->EnumState = ENUM_GET_FULL_DEV_DESC;
        MOVS     R0,#+1
        STRB     R0,[R4, #+1]
//  622       
//  623       /* modify control channels configuration for MaxPacket size */
//  624       USBH_OpenPipe (phost,
//  625                            phost->Control.pipe_in,
//  626                            0x80,
//  627                            phost->device.address,
//  628                            phost->device.speed,
//  629                            USBH_EP_CONTROL,
//  630                            phost->Control.pipe_size); 
        LDRB     R0,[R4, #+6]
        UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
        STR      R0,[SP, #+8]
        MOVS     R0,#+0
        STR      R0,[SP, #+4]
        LDRB     R0,[R4, #+541]
        STR      R0,[SP, #+0]
        LDRB     R3,[R4, #+540]
        MOVS     R2,#+128
        LDRB     R1,[R4, #+4]
        MOVS     R0,R4
          CFI FunCall USBH_OpenPipe
        BL       USBH_OpenPipe
//  631       
//  632       /* Open Control pipes */
//  633       USBH_OpenPipe (phost,
//  634                            phost->Control.pipe_out,
//  635                            0x00,
//  636                            phost->device.address,
//  637                            phost->device.speed,
//  638                            USBH_EP_CONTROL,
//  639                            phost->Control.pipe_size);           
        LDRB     R0,[R4, #+6]
        UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
        STR      R0,[SP, #+8]
        MOVS     R0,#+0
        STR      R0,[SP, #+4]
        LDRB     R0,[R4, #+541]
        STR      R0,[SP, #+0]
        LDRB     R3,[R4, #+540]
        MOVS     R2,#+0
        LDRB     R1,[R4, #+5]
        MOVS     R0,R4
          CFI FunCall USBH_OpenPipe
        BL       USBH_OpenPipe
//  640       
//  641     }
//  642     break;
??USBH_HandleEnum_9:
        B.N      ??USBH_HandleEnum_10
//  643     
//  644   case ENUM_GET_FULL_DEV_DESC:  
//  645     /* Get FULL Device Desc  */
//  646     if ( USBH_Get_DevDesc(phost, USB_DEVICE_DESC_SIZE)== USBH_OK)
??USBH_HandleEnum_2:
        MOVS     R1,#+18
        MOVS     R0,R4
          CFI FunCall USBH_Get_DevDesc
        BL       USBH_Get_DevDesc
        CMP      R0,#+0
        BNE.N    ??USBH_HandleEnum_11
//  647     {
//  648       USBH_UsrLog("PID: %xh", phost->device.DevDesc.idProduct );  
        LDRH     R1,[R4, #+554]
        LDR.N    R0,??DataTable5_19
          CFI FunCall printf
        BL       printf
        ADR.N    R0,??DataTable5  ;; "\n"
          CFI FunCall printf
        BL       printf
//  649       USBH_UsrLog("VID: %xh", phost->device.DevDesc.idVendor );  
        LDRH     R1,[R4, #+552]
        LDR.N    R0,??DataTable5_20
          CFI FunCall printf
        BL       printf
        ADR.N    R0,??DataTable5  ;; "\n"
          CFI FunCall printf
        BL       printf
//  650       
//  651       phost->EnumState = ENUM_SET_ADDR;
        MOVS     R0,#+2
        STRB     R0,[R4, #+1]
//  652        
//  653     }
//  654     break;
??USBH_HandleEnum_11:
        B.N      ??USBH_HandleEnum_10
//  655    
//  656   case ENUM_SET_ADDR: 
//  657     /* set address */
//  658     if ( USBH_SetAddress(phost, USBH_DEVICE_ADDRESS) == USBH_OK)
??USBH_HandleEnum_1:
        MOVS     R1,#+1
        MOVS     R0,R4
          CFI FunCall USBH_SetAddress
        BL       USBH_SetAddress
        CMP      R0,#+0
        BNE.N    ??USBH_HandleEnum_12
//  659     {
//  660       USBH_Delay(2);
        MOVS     R0,#+2
          CFI FunCall USBH_Delay
        BL       USBH_Delay
//  661       phost->device.address = USBH_DEVICE_ADDRESS;
        MOVS     R0,#+1
        STRB     R0,[R4, #+540]
//  662       
//  663       /* user callback for device address assigned */
//  664       USBH_UsrLog("Address (#%d) assigned.", phost->device.address);
        LDRB     R1,[R4, #+540]
        LDR.N    R0,??DataTable5_21
          CFI FunCall printf
        BL       printf
        ADR.N    R0,??DataTable5  ;; "\n"
          CFI FunCall printf
        BL       printf
//  665       phost->EnumState = ENUM_GET_CFG_DESC;
        MOVS     R0,#+3
        STRB     R0,[R4, #+1]
//  666       
//  667       /* modify control channels to update device address */
//  668       USBH_OpenPipe (phost,
//  669                            phost->Control.pipe_in,
//  670                            0x80,
//  671                            phost->device.address,
//  672                            phost->device.speed,
//  673                            USBH_EP_CONTROL,
//  674                            phost->Control.pipe_size); 
        LDRB     R0,[R4, #+6]
        UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
        STR      R0,[SP, #+8]
        MOVS     R0,#+0
        STR      R0,[SP, #+4]
        LDRB     R0,[R4, #+541]
        STR      R0,[SP, #+0]
        LDRB     R3,[R4, #+540]
        MOVS     R2,#+128
        LDRB     R1,[R4, #+4]
        MOVS     R0,R4
          CFI FunCall USBH_OpenPipe
        BL       USBH_OpenPipe
//  675       
//  676       /* Open Control pipes */
//  677       USBH_OpenPipe (phost,
//  678                            phost->Control.pipe_out,
//  679                            0x00,
//  680                            phost->device.address,
//  681                            phost->device.speed,
//  682                            USBH_EP_CONTROL,
//  683                            phost->Control.pipe_size);        
        LDRB     R0,[R4, #+6]
        UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
        STR      R0,[SP, #+8]
        MOVS     R0,#+0
        STR      R0,[SP, #+4]
        LDRB     R0,[R4, #+541]
        STR      R0,[SP, #+0]
        LDRB     R3,[R4, #+540]
        MOVS     R2,#+0
        LDRB     R1,[R4, #+5]
        MOVS     R0,R4
          CFI FunCall USBH_OpenPipe
        BL       USBH_OpenPipe
//  684     }
//  685     break;
??USBH_HandleEnum_12:
        B.N      ??USBH_HandleEnum_10
//  686     
//  687   case ENUM_GET_CFG_DESC:  
//  688     /* get standard configuration descriptor */
//  689     if ( USBH_Get_CfgDesc(phost, 
//  690                           USB_CONFIGURATION_DESC_SIZE) == USBH_OK)
??USBH_HandleEnum_4:
        MOVS     R1,#+9
        MOVS     R0,R4
          CFI FunCall USBH_Get_CfgDesc
        BL       USBH_Get_CfgDesc
        CMP      R0,#+0
        BNE.N    ??USBH_HandleEnum_13
//  691     {
//  692       phost->EnumState = ENUM_GET_FULL_CFG_DESC;        
        MOVS     R0,#+4
        STRB     R0,[R4, #+1]
//  693     }
//  694     break;
??USBH_HandleEnum_13:
        B.N      ??USBH_HandleEnum_10
//  695     
//  696   case ENUM_GET_FULL_CFG_DESC:  
//  697     /* get FULL config descriptor (config, interface, endpoints) */
//  698     if (USBH_Get_CfgDesc(phost, 
//  699                          phost->device.CfgDesc.wTotalLength) == USBH_OK)
??USBH_HandleEnum_3:
        LDRH     R1,[R4, #+564]
        MOVS     R0,R4
          CFI FunCall USBH_Get_CfgDesc
        BL       USBH_Get_CfgDesc
        CMP      R0,#+0
        BNE.N    ??USBH_HandleEnum_14
//  700     {
//  701       phost->EnumState = ENUM_GET_MFC_STRING_DESC;       
        MOVS     R0,#+5
        STRB     R0,[R4, #+1]
//  702     }
//  703     break;
??USBH_HandleEnum_14:
        B.N      ??USBH_HandleEnum_10
//  704     
//  705   case ENUM_GET_MFC_STRING_DESC:  
//  706     if (phost->device.DevDesc.iManufacturer != 0)
??USBH_HandleEnum_6:
        LDRB     R0,[R4, #+558]
        CMP      R0,#+0
        BEQ.N    ??USBH_HandleEnum_15
//  707     { /* Check that Manufacturer String is available */
//  708       
//  709       if ( USBH_Get_StringDesc(phost,
//  710                                phost->device.DevDesc.iManufacturer, 
//  711                                 phost->device.Data , 
//  712                                0xff) == USBH_OK)
        MOVS     R3,#+255
        ADDS     R2,R4,#+28
        LDRB     R1,[R4, #+558]
        MOVS     R0,R4
          CFI FunCall USBH_Get_StringDesc
        BL       USBH_Get_StringDesc
        CMP      R0,#+0
        BNE.N    ??USBH_HandleEnum_16
//  713       {
//  714         /* User callback for Manufacturing string */
//  715         USBH_UsrLog("Manufacturer : %s",  (char *)phost->device.Data);
        ADDS     R1,R4,#+28
        LDR.N    R0,??DataTable5_22
          CFI FunCall printf
        BL       printf
        ADR.N    R0,??DataTable5  ;; "\n"
          CFI FunCall printf
        BL       printf
//  716         phost->EnumState = ENUM_GET_PRODUCT_STRING_DESC;
        MOVS     R0,#+6
        STRB     R0,[R4, #+1]
        B.N      ??USBH_HandleEnum_16
//  717         
//  718 #if (USBH_USE_OS == 1)
//  719     osMessagePut ( phost->os_event, USBH_STATE_CHANGED_EVENT, 0);
//  720 #endif          
//  721       }
//  722     }
//  723     else
//  724     {
//  725      USBH_UsrLog("Manufacturer : N/A");      
??USBH_HandleEnum_15:
        LDR.N    R0,??DataTable5_23
          CFI FunCall printf
        BL       printf
        ADR.N    R0,??DataTable5  ;; "\n"
          CFI FunCall printf
        BL       printf
//  726      phost->EnumState = ENUM_GET_PRODUCT_STRING_DESC; 
        MOVS     R0,#+6
        STRB     R0,[R4, #+1]
//  727 #if (USBH_USE_OS == 1)
//  728     osMessagePut ( phost->os_event, USBH_STATE_CHANGED_EVENT, 0);
//  729 #endif       
//  730     }
//  731     break;
??USBH_HandleEnum_16:
        B.N      ??USBH_HandleEnum_10
//  732     
//  733   case ENUM_GET_PRODUCT_STRING_DESC:   
//  734     if (phost->device.DevDesc.iProduct != 0)
??USBH_HandleEnum_5:
        LDRB     R0,[R4, #+559]
        CMP      R0,#+0
        BEQ.N    ??USBH_HandleEnum_17
//  735     { /* Check that Product string is available */
//  736       if ( USBH_Get_StringDesc(phost,
//  737                                phost->device.DevDesc.iProduct, 
//  738                                phost->device.Data, 
//  739                                0xff) == USBH_OK)
        MOVS     R3,#+255
        ADDS     R2,R4,#+28
        LDRB     R1,[R4, #+559]
        MOVS     R0,R4
          CFI FunCall USBH_Get_StringDesc
        BL       USBH_Get_StringDesc
        CMP      R0,#+0
        BNE.N    ??USBH_HandleEnum_18
//  740       {
//  741         /* User callback for Product string */
//  742         USBH_UsrLog("Product : %s",  (char *)phost->device.Data);
        ADDS     R1,R4,#+28
        LDR.N    R0,??DataTable5_24
          CFI FunCall printf
        BL       printf
        ADR.N    R0,??DataTable5  ;; "\n"
          CFI FunCall printf
        BL       printf
//  743         phost->EnumState = ENUM_GET_SERIALNUM_STRING_DESC;        
        MOVS     R0,#+7
        STRB     R0,[R4, #+1]
        B.N      ??USBH_HandleEnum_18
//  744       }
//  745     }
//  746     else
//  747     {
//  748       USBH_UsrLog("Product : N/A");
??USBH_HandleEnum_17:
        LDR.N    R0,??DataTable5_25
          CFI FunCall printf
        BL       printf
        ADR.N    R0,??DataTable5  ;; "\n"
          CFI FunCall printf
        BL       printf
//  749       phost->EnumState = ENUM_GET_SERIALNUM_STRING_DESC; 
        MOVS     R0,#+7
        STRB     R0,[R4, #+1]
//  750 #if (USBH_USE_OS == 1)
//  751     osMessagePut ( phost->os_event, USBH_STATE_CHANGED_EVENT, 0);
//  752 #endif        
//  753     } 
//  754     break;
??USBH_HandleEnum_18:
        B.N      ??USBH_HandleEnum_10
//  755     
//  756   case ENUM_GET_SERIALNUM_STRING_DESC:   
//  757     if (phost->device.DevDesc.iSerialNumber != 0)
??USBH_HandleEnum_7:
        LDRB     R0,[R4, #+560]
        CMP      R0,#+0
        BEQ.N    ??USBH_HandleEnum_19
//  758     { /* Check that Serial number string is available */    
//  759       if ( USBH_Get_StringDesc(phost,
//  760                                phost->device.DevDesc.iSerialNumber, 
//  761                                phost->device.Data, 
//  762                                0xff) == USBH_OK)
        MOVS     R3,#+255
        ADDS     R2,R4,#+28
        LDRB     R1,[R4, #+560]
        MOVS     R0,R4
          CFI FunCall USBH_Get_StringDesc
        BL       USBH_Get_StringDesc
        CMP      R0,#+0
        BNE.N    ??USBH_HandleEnum_20
//  763       {
//  764         /* User callback for Serial number string */
//  765          USBH_UsrLog("Serial Number : %s",  (char *)phost->device.Data);
        ADDS     R1,R4,#+28
        LDR.N    R0,??DataTable5_26
          CFI FunCall printf
        BL       printf
        ADR.N    R0,??DataTable5  ;; "\n"
          CFI FunCall printf
        BL       printf
//  766         Status = USBH_OK;
        MOVS     R0,#+0
        MOVS     R5,R0
        B.N      ??USBH_HandleEnum_20
//  767       }
//  768     }
//  769     else
//  770     {
//  771       USBH_UsrLog("Serial Number : N/A"); 
??USBH_HandleEnum_19:
        LDR.N    R0,??DataTable5_27
          CFI FunCall printf
        BL       printf
        ADR.N    R0,??DataTable5  ;; "\n"
          CFI FunCall printf
        BL       printf
//  772       Status = USBH_OK;
        MOVS     R0,#+0
        MOVS     R5,R0
//  773 #if (USBH_USE_OS == 1)
//  774     osMessagePut ( phost->os_event, USBH_STATE_CHANGED_EVENT, 0);
//  775 #endif        
//  776     }  
//  777     break;
??USBH_HandleEnum_20:
        B.N      ??USBH_HandleEnum_10
//  778     
//  779   default:
//  780     break;
//  781   }  
//  782   return Status;
??USBH_HandleEnum_8:
??USBH_HandleEnum_10:
        MOVS     R0,R5
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        POP      {R1-R5,PC}       ;; return
//  783 }
          CFI EndBlock cfiBlock12
//  784 
//  785 /**
//  786   * @brief  USBH_LL_SetTimer 
//  787   *         Set the initial Host Timer tick
//  788   * @param  phost: Host Handle
//  789   * @retval None
//  790   */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock13 Using cfiCommon0
          CFI Function USBH_LL_SetTimer
          CFI NoCalls
        THUMB
//  791 void  USBH_LL_SetTimer  (USBH_HandleTypeDef *phost, uint32_t time)
//  792 {
//  793   phost->Timer = time;
USBH_LL_SetTimer:
        STR      R1,[R0, #+680]
//  794 }
        BX       LR               ;; return
          CFI EndBlock cfiBlock13
//  795 /**
//  796   * @brief  USBH_LL_IncTimer 
//  797   *         Increment Host Timer tick
//  798   * @param  phost: Host Handle
//  799   * @retval None
//  800   */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock14 Using cfiCommon0
          CFI Function USBH_LL_IncTimer
        THUMB
//  801 void  USBH_LL_IncTimer  (USBH_HandleTypeDef *phost)
//  802 {
USBH_LL_IncTimer:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        MOVS     R4,R0
//  803   phost->Timer ++;
        LDR      R0,[R4, #+680]
        ADDS     R0,R0,#+1
        STR      R0,[R4, #+680]
//  804   USBH_HandleSof(phost);
        MOVS     R0,R4
          CFI FunCall USBH_HandleSof
        BL       USBH_HandleSof
//  805 }
        POP      {R4,PC}          ;; return
          CFI EndBlock cfiBlock14
//  806 
//  807 /**
//  808   * @brief  USBH_HandleSof 
//  809   *         Call SOF process
//  810   * @param  phost: Host Handle
//  811   * @retval None
//  812   */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock15 Using cfiCommon0
          CFI Function USBH_HandleSof
        THUMB
//  813 void  USBH_HandleSof  (USBH_HandleTypeDef *phost)
//  814 {
USBH_HandleSof:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        MOVS     R4,R0
//  815   if((phost->gState == HOST_CLASS)&&(phost->pActiveClass != NULL))
        LDRB     R0,[R4, #+0]
        CMP      R0,#+10
        BNE.N    ??USBH_HandleSof_0
        LDR      R0,[R4, #+612]
        CMP      R0,#+0
        BEQ.N    ??USBH_HandleSof_0
//  816   {
//  817     phost->pActiveClass->SOFProcess(phost);
        MOVS     R0,R4
        LDR      R1,[R4, #+612]
        LDR      R1,[R1, #+24]
          CFI FunCall
        BLX      R1
//  818   }
//  819 }
??USBH_HandleSof_0:
        POP      {R4,PC}          ;; return
          CFI EndBlock cfiBlock15
//  820 /**
//  821   * @brief  USBH_LL_Connect 
//  822   *         Handle USB Host connexion event
//  823   * @param  phost: Host Handle
//  824   * @retval USBH_Status
//  825   */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock16 Using cfiCommon0
          CFI Function USBH_LL_Connect
        THUMB
//  826 USBH_StatusTypeDef  USBH_LL_Connect  (USBH_HandleTypeDef *phost)
//  827 {
USBH_LL_Connect:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        MOVS     R4,R0
//  828   if(phost->gState == HOST_IDLE )
        LDRB     R0,[R4, #+0]
        CMP      R0,#+0
        BNE.N    ??USBH_LL_Connect_0
//  829   {
//  830     phost->device.is_connected = 1;
        MOVS     R0,#+1
        STRB     R0,[R4, #+542]
//  831     
//  832     if(phost->pUser != NULL)
        LDR      R0,[R4, #+692]
        CMP      R0,#+0
        BEQ.N    ??USBH_LL_Connect_1
//  833     {    
//  834       phost->pUser(phost, HOST_USER_CONNECTION);
        MOVS     R1,#+4
        MOVS     R0,R4
        LDR      R2,[R4, #+692]
          CFI FunCall
        BLX      R2
        B.N      ??USBH_LL_Connect_1
//  835     }
//  836   } 
//  837   else if(phost->gState == HOST_DEV_WAIT_FOR_ATTACHMENT )
??USBH_LL_Connect_0:
        LDRB     R0,[R4, #+0]
        CMP      R0,#+1
        BNE.N    ??USBH_LL_Connect_1
//  838   {
//  839     phost->gState = HOST_DEV_ATTACHED ;
        MOVS     R0,#+2
        STRB     R0,[R4, #+0]
//  840   }
//  841 #if (USBH_USE_OS == 1)
//  842   osMessagePut ( phost->os_event, USBH_PORT_EVENT, 0);
//  843 #endif 
//  844   
//  845   return USBH_OK;
??USBH_LL_Connect_1:
        MOVS     R0,#+0
        POP      {R4,PC}          ;; return
//  846 }
          CFI EndBlock cfiBlock16
//  847 
//  848 /**
//  849   * @brief  USBH_LL_Disconnect 
//  850   *         Handle USB Host disconnection event
//  851   * @param  phost: Host Handle
//  852   * @retval USBH_Status
//  853   */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock17 Using cfiCommon0
          CFI Function USBH_LL_Disconnect
        THUMB
//  854 USBH_StatusTypeDef  USBH_LL_Disconnect  (USBH_HandleTypeDef *phost)
//  855 {
USBH_LL_Disconnect:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        MOVS     R4,R0
//  856   /*Stop Host */ 
//  857   USBH_LL_Stop(phost);  
        MOVS     R0,R4
          CFI FunCall USBH_LL_Stop
        BL       USBH_LL_Stop
//  858   
//  859   /* FRee Control Pipes */
//  860   USBH_FreePipe  (phost, phost->Control.pipe_in);
        LDRB     R1,[R4, #+4]
        MOVS     R0,R4
          CFI FunCall USBH_FreePipe
        BL       USBH_FreePipe
//  861   USBH_FreePipe  (phost, phost->Control.pipe_out);  
        LDRB     R1,[R4, #+5]
        MOVS     R0,R4
          CFI FunCall USBH_FreePipe
        BL       USBH_FreePipe
//  862    
//  863   phost->device.is_connected = 0; 
        MOVS     R0,#+0
        STRB     R0,[R4, #+542]
//  864    
//  865   if(phost->pUser != NULL)
        LDR      R0,[R4, #+692]
        CMP      R0,#+0
        BEQ.N    ??USBH_LL_Disconnect_0
//  866   {    
//  867     phost->pUser(phost, HOST_USER_DISCONNECTION);
        MOVS     R1,#+5
        MOVS     R0,R4
        LDR      R2,[R4, #+692]
          CFI FunCall
        BLX      R2
//  868   }
//  869   USBH_UsrLog("USB Device disconnected"); 
??USBH_LL_Disconnect_0:
        LDR.N    R0,??DataTable5_28
          CFI FunCall printf
        BL       printf
        ADR.N    R0,??DataTable5  ;; "\n"
          CFI FunCall printf
        BL       printf
//  870   
//  871   /* Start the low level driver  */
//  872   USBH_LL_Start(phost);
        MOVS     R0,R4
          CFI FunCall USBH_LL_Start
        BL       USBH_LL_Start
//  873   
//  874   phost->gState = HOST_DEV_DISCONNECTED;
        MOVS     R0,#+3
        STRB     R0,[R4, #+0]
//  875   
//  876 #if (USBH_USE_OS == 1)
//  877   osMessagePut ( phost->os_event, USBH_PORT_EVENT, 0);
//  878 #endif 
//  879   
//  880   return USBH_OK;
        MOVS     R0,#+0
        POP      {R4,PC}          ;; return
//  881 }
          CFI EndBlock cfiBlock17

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable5:
        DC8      "\n",0x0,0x0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable5_1:
        DC32     ?_0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable5_2:
        DC32     ?_1

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable5_3:
        DC32     ?_3

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable5_4:
        DC32     ?_4

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable5_5:
        DC32     ?_5

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable5_6:
        DC32     ?_6

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable5_7:
        DC32     ?_7

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable5_8:
        DC32     ?_8

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable5_9:
        DC32     ?_9

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable5_10:
        DC32     ?_10

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable5_11:
        DC32     ?_11

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable5_12:
        DC32     ?_12

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable5_13:
        DC32     ?_13

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable5_14:
        DC32     ?_14

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable5_15:
        DC32     ?_15

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable5_16:
        DC32     ?_16

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable5_17:
        DC32     ?_17

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable5_18:
        DC32     ?_18

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable5_19:
        DC32     ?_19

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable5_20:
        DC32     ?_20

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable5_21:
        DC32     ?_21

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable5_22:
        DC32     ?_22

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable5_23:
        DC32     ?_23

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable5_24:
        DC32     ?_24

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable5_25:
        DC32     ?_25

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable5_26:
        DC32     ?_26

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable5_27:
        DC32     ?_27

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable5_28:
        DC32     ?_28

        SECTION `.iar_vfe_header`:DATA:NOALLOC:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
        DC32 0

        SECTION __DLIB_PERTHREAD:DATA:REORDER:NOROOT(0)
        SECTION_TYPE SHT_PROGBITS, 0

        SECTION __DLIB_PERTHREAD_init:DATA:REORDER:NOROOT(0)
        SECTION_TYPE SHT_PROGBITS, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_0:
        DC8 "ERROR: "

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_1:
        DC8 "Invalid Host handle"

        SECTION `.rodata`:CONST:REORDER:NOROOT(1)
        DATA
        DC8 "\012"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_3:
        DC8 "Max Class Number reached"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_4:
        DC8 "Invalid Class handle"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_5:
        DC8 "Switching to Interface (#%d)"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_6:
        DC8 "Class    : %xh"
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_7:
        DC8 "SubClass : %xh"
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_8:
        DC8 "Protocol : %xh"
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_9:
        DC8 "Cannot Select This Interface."
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_10:
        DC8 "USB Device Attached"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_11:
        DC8 "Enumeration done."
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_12:
        DC8 "This device has only 1 configuration."
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_13:
        DC8 "Default configuration set."
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_14:
        DC8 "No Class has been registered."
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_15:
        DC8 "%s class started."
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_16:
        DC8 "Device not supporting %s class."

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_17:
        DC8 "No registered class for this device."
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_18:
        DC8 "Invalid Class Driver."
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_19:
        DC8 "PID: %xh"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_20:
        DC8 "VID: %xh"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_21:
        DC8 "Address (#%d) assigned."

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_22:
        DC8 "Manufacturer : %s"
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_23:
        DC8 "Manufacturer : N/A"
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_24:
        DC8 "Product : %s"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_25:
        DC8 "Product : N/A"
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_26:
        DC8 "Serial Number : %s"
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_27:
        DC8 "Serial Number : N/A"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_28:
        DC8 "USB Device disconnected"

        END
//  882 
//  883 
//  884 #if (USBH_USE_OS == 1)  
//  885 /**
//  886   * @brief  USB Host Thread task
//  887   * @param  pvParameters not used
//  888   * @retval None
//  889   */
//  890 static void USBH_Process_OS(void const * argument)
//  891 {
//  892   osEvent event;
//  893   
//  894   for(;;)
//  895   {
//  896     event = osMessageGet(((USBH_HandleTypeDef *)argument)->os_event, osWaitForever );
//  897     
//  898     if( event.status == osEventMessage )
//  899     {
//  900       USBH_Process((USBH_HandleTypeDef *)argument);
//  901     }
//  902    }
//  903 }
//  904 
//  905 /**
//  906 * @brief  USBH_LL_NotifyURBChange 
//  907 *         Notify URB state Change
//  908 * @param  phost: Host handle
//  909 * @retval USBH Status
//  910 */
//  911 USBH_StatusTypeDef  USBH_LL_NotifyURBChange (USBH_HandleTypeDef *phost)
//  912 {
//  913   osMessagePut ( phost->os_event, USBH_URB_EVENT, 0);
//  914   return USBH_OK;
//  915 }
//  916 #endif  
//  917 /**
//  918   * @}
//  919   */ 
//  920 
//  921 /**
//  922   * @}
//  923   */ 
//  924 
//  925 /**
//  926   * @}
//  927   */
//  928 
//  929 /**
//  930   * @}
//  931   */ 
//  932 
//  933 /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
// 
//   634 bytes in section .rodata
// 2 192 bytes in section .text
// 
// 2 192 bytes of CODE  memory
//   634 bytes of CONST memory
//
//Errors: none
//Warnings: none
