###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.2.10312/W32 for ARM       13/Apr/2016  13:47:35
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Middlewares\ST\STM32_USB_Host_Library\Core\Src\usbh_core.c
#    Command line =  
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Middlewares\ST\STM32_USB_Host_Library\Core\Src\usbh_core.c
#        -D USE_HAL_DRIVER -D STM32F746xx -D USE_STM32746G_DISCO -D
#        USE_IOEXPANDER -D USE_USB_FS -lC
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
#        -lA
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
#        -o
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj
#        --no_unroll --debug --endian=little --cpu=Cortex-M7 -e --fpu=VFPv5_sp
#        --dlib_config "D:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Full.h" -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\CMSIS\Device\ST\STM32F7xx\Include\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\STM32F7xx_HAL_Driver\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\STM32746G-Discovery\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\Components\Common\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Log\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Fonts\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\CPU\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_Device_Library\Core\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Core\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Class\MSC\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\drivers\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_Audio\Addons\PDM\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_Device_Library\Class\AUDIO\Inc\
#        -Oh --use_c++_inline --require_prototypes -I "D:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.3\arm\CMSIS\Include\" -D
#        ARM_MATH_CM7 --relaxed_fp
#    List file    =  
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List\usbh_core.lst
#    Object file  =  
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj\usbh_core.o
#
###############################################################################

D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Middlewares\ST\STM32_USB_Host_Library\Core\Src\usbh_core.c
      1          /**
      2            ******************************************************************************
      3            * @file    usbh_core.c 
      4            * @author  MCD Application Team
      5            * @version V3.2.1
      6            * @date    26-June-2015
      7            * @brief   This file implements the functions for the core state machine process
      8            *          the enumeration and the control transfer process
      9            ******************************************************************************
     10            * @attention
     11            *
     12            * <h2><center>&copy; COPYRIGHT 2015 STMicroelectronics</center></h2>
     13            *
     14            * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
     15            * You may not use this file except in compliance with the License.
     16            * You may obtain a copy of the License at:
     17            *
     18            *        http://www.st.com/software_license_agreement_liberty_v2
     19            *
     20            * Unless required by applicable law or agreed to in writing, software 
     21            * distributed under the License is distributed on an "AS IS" BASIS, 
     22            * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     23            * See the License for the specific language governing permissions and
     24            * limitations under the License.
     25            *
     26            ******************************************************************************
     27            */ 
     28          /* Includes ------------------------------------------------------------------*/
     29          
     30          #include "usbh_core.h"
     31          
     32          
     33          /** @addtogroup USBH_LIB
     34            * @{
     35            */
     36          
     37          /** @addtogroup USBH_LIB_CORE
     38            * @{
     39            */
     40          
     41          /** @defgroup USBH_CORE 
     42            * @brief This file handles the basic enumeration when a device is connected 
     43            *          to the host.
     44            * @{
     45            */ 
     46          
     47          
     48          /** @defgroup USBH_CORE_Private_Defines
     49            * @{
     50            */ 
     51          #define USBH_ADDRESS_DEFAULT                     0
     52          #define USBH_ADDRESS_ASSIGNED                    1      
     53          #define USBH_MPS_DEFAULT                         0x40
     54          /**
     55            * @}
     56            */ 
     57          
     58          /** @defgroup USBH_CORE_Private_Macros
     59            * @{
     60            */ 
     61          /**
     62            * @}
     63            */ 
     64          
     65          
     66          /** @defgroup USBH_CORE_Private_Variables
     67            * @{
     68            */ 
     69          /**
     70            * @}
     71            */ 
     72           
     73          
     74          /** @defgroup USBH_CORE_Private_Functions
     75            * @{
     76            */ 
     77          static USBH_StatusTypeDef  USBH_HandleEnum    (USBH_HandleTypeDef *phost);
     78          static void                USBH_HandleSof     (USBH_HandleTypeDef *phost);
     79          static USBH_StatusTypeDef  DeInitStateMachine(USBH_HandleTypeDef *phost);
     80          
     81          #if (USBH_USE_OS == 1)  
     82          static void USBH_Process_OS(void const * argument);
     83          #endif
     84          
     85          /**
     86            * @brief  HCD_Init 
     87            *         Initialize the HOST Core.
     88            * @param  phost: Host Handle
     89            * @param  pUsrFunc: User Callback
     90            * @retval USBH Status
     91            */

   \                                 In section .text, align 2, keep-with-next
     92          USBH_StatusTypeDef  USBH_Init(USBH_HandleTypeDef *phost, void (*pUsrFunc)(USBH_HandleTypeDef *phost, uint8_t ), uint8_t id)
     93          {
   \                     USBH_Init: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x460D             MOV      R5,R1
     94            /* Check whether the USB Host handle is valid */
     95            if(phost == NULL)
   \   00000006   0xD10C             BNE.N    ??USBH_Init_0
     96            {
     97              USBH_ErrLog("Invalid Host handle");
   \   00000008   0x.... 0x....      ADR.W    R0,?_0
   \   0000000C   0x.... 0x....      BL       printf
   \   00000010   0x.... 0x....      ADR.W    R0,?_1
   \   00000014   0x.... 0x....      BL       printf
   \   00000018   0x....             ADR.N    R0,??DataTable31  ;; "\n"
   \   0000001A   0x.... 0x....      BL       printf
     98              return USBH_FAIL; 
   \   0000001E   0x2002             MOVS     R0,#+2
   \   00000020   0xBD70             POP      {R4-R6,PC}
     99            }
    100            
    101            /* Set DRiver ID */
    102            phost->id = id;
   \                     ??USBH_Init_0: (+1)
   \   00000022   0xF504 0x762B      ADD      R6,R4,#+684
    103            
    104            /* Unlink class*/
    105            phost->pActiveClass = NULL;
   \   00000026   0xF504 0x7019      ADD      R0,R4,#+612
   \   0000002A   0x7032             STRB     R2,[R6, #+0]
   \   0000002C   0x2100             MOVS     R1,#+0
   \   0000002E   0x6001             STR      R1,[R0, #+0]
    106            phost->ClassNumber = 0;
   \   00000030   0x6041             STR      R1,[R0, #+4]
    107            
    108            /* Restore default states and prepare EP0 */ 
    109            DeInitStateMachine(phost);
   \   00000032   0x4620             MOV      R0,R4
   \   00000034   0x.... 0x....      BL       DeInitStateMachine
    110            
    111            /* Assign User process */
    112            if(pUsrFunc != NULL)
   \   00000038   0x0028             MOVS     R0,R5
    113            {
    114              phost->pUser = pUsrFunc;
    115            }
    116            
    117          #if (USBH_USE_OS == 1) 
    118            
    119            /* Create USB Host Queue */
    120            osMessageQDef(USBH_Queue, 10, uint16_t);
    121            phost->os_event = osMessageCreate (osMessageQ(USBH_Queue), NULL); 
    122            
    123            /*Create USB Host Task */
    124          #if defined (USBH_PROCESS_STACK_SIZE)
    125            osThreadDef(USBH_Thread, USBH_Process_OS, USBH_PROCESS_PRIO, 0, USBH_PROCESS_STACK_SIZE);
    126          #else
    127            osThreadDef(USBH_Thread, USBH_Process_OS, USBH_PROCESS_PRIO, 0, 8 * configMINIMAL_STACK_SIZE);
    128          #endif  
    129            phost->thread = osThreadCreate (osThread(USBH_Thread), phost);
    130          #endif  
    131            
    132            /* Initialize low level driver */
    133            USBH_LL_Init(phost);
   \   0000003A   0x4620             MOV      R0,R4
   \   0000003C   0xBF18             IT       NE 
   \   0000003E   0x60B5             STRNE    R5,[R6, #+8]
   \   00000040   0x.... 0x....      BL       USBH_LL_Init
    134            return USBH_OK;
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0xBD70             POP      {R4-R6,PC}       ;; return
    135          }
    136          
    137          /**
    138            * @brief  HCD_Init 
    139            *         De-Initialize the Host portion of the driver.
    140            * @param  phost: Host Handle
    141            * @retval USBH Status
    142            */

   \                                 In section .text, align 2, keep-with-next
    143          USBH_StatusTypeDef  USBH_DeInit(USBH_HandleTypeDef *phost)
    144          {
   \                     USBH_DeInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    145            DeInitStateMachine(phost);
   \   00000004   0x.... 0x....      BL       DeInitStateMachine
    146            
    147            if(phost->pData != NULL)
   \   00000008   0xF504 0x7019      ADD      R0,R4,#+612
   \   0000000C   0x6CC1             LDR      R1,[R0, #+76]
   \   0000000E   0xB129             CBZ.N    R1,??USBH_DeInit_0
    148            {
    149              phost->pActiveClass->pData = NULL;
   \   00000010   0x6800             LDR      R0,[R0, #+0]
   \   00000012   0x2100             MOVS     R1,#+0
   \   00000014   0x61C1             STR      R1,[R0, #+28]
    150              USBH_LL_Stop(phost);
   \   00000016   0x4620             MOV      R0,R4
   \   00000018   0x.... 0x....      BL       USBH_LL_Stop
    151            }
    152          
    153            return USBH_OK;
   \                     ??USBH_DeInit_0: (+1)
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0xBD10             POP      {R4,PC}          ;; return
    154          }
    155          
    156          /**
    157            * @brief  DeInitStateMachine 
    158            *         De-Initialize the Host state machine.
    159            * @param  phost: Host Handle
    160            * @retval USBH Status
    161            */

   \                                 In section .text, align 2, keep-with-next
    162          static USBH_StatusTypeDef  DeInitStateMachine(USBH_HandleTypeDef *phost)
    163          {
   \                     DeInitStateMachine: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    164            uint32_t i = 0;
    165          
    166            /* Clear Pipes flags*/
    167            for ( ; i < USBH_MAX_PIPES_NBR; i++)
    168            {
    169              phost->Pipes[i] = 0;
   \   00000004   0x213C             MOVS     R1,#+60
   \   00000006   0xF504 0x701B      ADD      R0,R4,#+620
   \   0000000A   0x.... 0x....      BL       __aeabi_memclr4
    170            }
    171            
    172            for(i = 0; i< USBH_MAX_DATA_BUFFER; i++)
    173            {
    174              phost->device.Data[i] = 0;
   \   0000000E   0xF44F 0x7100      MOV      R1,#+512
   \   00000012   0xF104 0x001C      ADD      R0,R4,#+28
   \   00000016   0x.... 0x....      BL       __aeabi_memclr4
    175            }
    176            
    177            phost->gState = HOST_IDLE;
   \   0000001A   0x2000             MOVS     R0,#+0
    178            phost->EnumState = ENUM_IDLE;
    179            phost->RequestState = CMD_SEND;
    180            phost->Timer = 0;  
    181            
    182            phost->Control.state = CTRL_SETUP;
    183            phost->Control.pipe_size = USBH_MPS_DEFAULT;  
    184            phost->Control.errorcount = 0;
    185            
    186            phost->device.address = USBH_ADDRESS_DEFAULT;
   \   0000001C   0x2100             MOVS     R1,#+0
   \   0000001E   0x7020             STRB     R0,[R4, #+0]
   \   00000020   0x7060             STRB     R0,[R4, #+1]
   \   00000022   0x2001             MOVS     R0,#+1
   \   00000024   0x70A0             STRB     R0,[R4, #+2]
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0xF8C4 0x02A8      STR      R0,[R4, #+680]
   \   0000002C   0x2001             MOVS     R0,#+1
   \   0000002E   0x7620             STRB     R0,[R4, #+24]
   \   00000030   0x2040             MOVS     R0,#+64
   \   00000032   0x71A0             STRB     R0,[R4, #+6]
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0x7660             STRB     R0,[R4, #+25]
   \   00000038   0xF504 0x7007      ADD      R0,R4,#+540
   \   0000003C   0x7001             STRB     R1,[R0, #+0]
    187            phost->device.speed   = USBH_SPEED_FULL;
   \   0000003E   0x2101             MOVS     R1,#+1
   \   00000040   0x7041             STRB     R1,[R0, #+1]
    188            
    189            return USBH_OK;
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0xBD10             POP      {R4,PC}          ;; return
    190          }
    191          
    192          /**
    193            * @brief  USBH_RegisterClass 
    194            *         Link class driver to Host Core.
    195            * @param  phost : Host Handle
    196            * @param  pclass: Class handle
    197            * @retval USBH Status
    198            */

   \                                 In section .text, align 2, keep-with-next
    199          USBH_StatusTypeDef  USBH_RegisterClass(USBH_HandleTypeDef *phost, USBH_ClassTypeDef *pclass)
    200          {
   \                     USBH_RegisterClass: (+1)
   \   00000000   0x4602             MOV      R2,R0
    201            USBH_StatusTypeDef   status = USBH_OK;
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0xB510             PUSH     {R4,LR}
    202            
    203            if(pclass != 0)
   \   00000006   0xB179             CBZ.N    R1,??USBH_RegisterClass_0
    204            {
    205              if(phost->ClassNumber < USBH_MAX_NUM_SUPPORTED_CLASS)
   \   00000008   0xF8D2 0x3268      LDR      R3,[R2, #+616]
   \   0000000C   0xB92B             CBNZ.N   R3,??USBH_RegisterClass_1
    206              {
    207                /* link the class to the USB Host handle */
    208                phost->pClass[phost->ClassNumber++] = pclass;
   \   0000000E   0x2401             MOVS     R4,#+1
   \   00000010   0xF8C2 0x1260      STR      R1,[R2, #+608]
   \   00000014   0xF8C2 0x4268      STR      R4,[R2, #+616]
    209                status = USBH_OK;
   \   00000018   0xBD10             POP      {R4,PC}
    210              }
    211              else
    212              {
    213                USBH_ErrLog("Max Class Number reached");
   \                     ??USBH_RegisterClass_1: (+1)
   \   0000001A   0x.... 0x....      ADR.W    R0,?_0
   \   0000001E   0x.... 0x....      BL       printf
   \   00000022   0x.... 0x....      ADR.W    R0,?_3
   \   00000026   0xE005             B.N      ??USBH_RegisterClass_2
    214                status = USBH_FAIL; 
    215              }
    216            }
    217            else
    218            {
    219              USBH_ErrLog("Invalid Class handle");
   \                     ??USBH_RegisterClass_0: (+1)
   \   00000028   0x.... 0x....      ADR.W    R0,?_0
   \   0000002C   0x.... 0x....      BL       printf
   \   00000030   0x.... 0x....      ADR.W    R0,?_4
   \                     ??USBH_RegisterClass_2: (+1)
   \   00000034   0x.... 0x....      BL       printf
   \   00000038   0x....             ADR.N    R0,??DataTable31  ;; "\n"
   \   0000003A   0x.... 0x....      BL       printf
    220              status = USBH_FAIL; 
   \   0000003E   0x2002             MOVS     R0,#+2
    221            }
    222            
    223            return status;
   \   00000040   0xBD10             POP      {R4,PC}          ;; return
    224          }
    225          
    226          /**
    227            * @brief  USBH_SelectInterface 
    228            *         Select current interface.
    229            * @param  phost: Host Handle
    230            * @param  interface: Interface number
    231            * @retval USBH Status
    232            */

   \                                 In section .text, align 2, keep-with-next
    233          USBH_StatusTypeDef USBH_SelectInterface(USBH_HandleTypeDef *phost, uint8_t interface)
    234          {
   \                     USBH_SelectInterface: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4606             MOV      R6,R0
    235            USBH_StatusTypeDef   status = USBH_OK;
    236            
    237            if(interface < phost->device.CfgDesc.bNumInterfaces)
   \   00000004   0xF206 0x201F      ADDW     R0,R6,#+543
   \   00000008   0x460F             MOV      R7,R1
   \   0000000A   0x2400             MOVS     R4,#+0
   \   0000000C   0x7DC1             LDRB     R1,[R0, #+23]
   \   0000000E   0x....             ADR.N    R5,??DataTable31  ;; "\n"
   \   00000010   0x428F             CMP      R7,R1
   \   00000012   0xD227             BCS.N    ??USBH_SelectInterface_0
    238            {
    239              phost->device.current_interface = interface;
   \   00000014   0x7007             STRB     R7,[R0, #+0]
    240              USBH_UsrLog ("Switching to Interface (#%d)", interface);
   \   00000016   0x4639             MOV      R1,R7
   \   00000018   0x.... 0x....      ADR.W    R0,?_5
   \   0000001C   0x.... 0x....      BL       printf
   \   00000020   0x4628             MOV      R0,R5
   \   00000022   0x.... 0x....      BL       printf
    241              USBH_UsrLog ("Class    : %xh", phost->device.CfgDesc.Itf_Desc[interface].bInterfaceClass );
   \   00000026   0xEB07 0x1007      ADD      R0,R7,R7, LSL #+4
   \   0000002A   0xEB06 0x0040      ADD      R0,R6,R0, LSL #+1
   \   0000002E   0xF200 0x2641      ADDW     R6,R0,#+577
   \   00000032   0x.... 0x....      ADR.W    R0,?_6
   \   00000036   0x7831             LDRB     R1,[R6, #+0]
   \   00000038   0x.... 0x....      BL       printf
   \   0000003C   0x4628             MOV      R0,R5
   \   0000003E   0x.... 0x....      BL       printf
    242              USBH_UsrLog ("SubClass : %xh", phost->device.CfgDesc.Itf_Desc[interface].bInterfaceSubClass );
   \   00000042   0x7871             LDRB     R1,[R6, #+1]
   \   00000044   0x.... 0x....      ADR.W    R0,?_7
   \   00000048   0x.... 0x....      BL       printf
   \   0000004C   0x4628             MOV      R0,R5
   \   0000004E   0x.... 0x....      BL       printf
    243              USBH_UsrLog ("Protocol : %xh", phost->device.CfgDesc.Itf_Desc[interface].bInterfaceProtocol );                 
   \   00000052   0x78B1             LDRB     R1,[R6, #+2]
   \   00000054   0x.... 0x....      ADR.W    R0,?_8
   \   00000058   0x.... 0x....      BL       printf
   \   0000005C   0x4628             MOV      R0,R5
   \   0000005E   0x.... 0x....      BL       printf
   \   00000062   0xE00B             B.N      ??USBH_SelectInterface_1
    244            }
    245            else
    246            {
    247              USBH_ErrLog ("Cannot Select This Interface.");
   \                     ??USBH_SelectInterface_0: (+1)
   \   00000064   0x.... 0x....      ADR.W    R0,?_0
   \   00000068   0x2402             MOVS     R4,#+2
   \   0000006A   0x.... 0x....      BL       printf
   \   0000006E   0x.... 0x....      ADR.W    R0,?_9
   \   00000072   0x.... 0x....      BL       printf
   \   00000076   0x4628             MOV      R0,R5
   \   00000078   0x.... 0x....      BL       printf
    248              status = USBH_FAIL; 
    249            }
    250            return status;  
   \                     ??USBH_SelectInterface_1: (+1)
   \   0000007C   0x4620             MOV      R0,R4
   \   0000007E   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    251          }
    252          
    253          /**
    254            * @brief  USBH_GetActiveClass 
    255            *         Return Device Class.
    256            * @param  phost: Host Handle
    257            * @param  interface: Interface index
    258            * @retval Class Code
    259            */

   \                                 In section .text, align 2, keep-with-next
    260          uint8_t USBH_GetActiveClass(USBH_HandleTypeDef *phost)
    261          {
    262             return (phost->device.CfgDesc.Itf_Desc[0].bInterfaceClass);            
   \                     USBH_GetActiveClass: (+1)
   \   00000000   0xF890 0x0241      LDRB     R0,[R0, #+577]
   \   00000004   0x4770             BX       LR               ;; return
    263          }
    264          /**
    265            * @brief  USBH_FindInterface 
    266            *         Find the interface index for a specific class.
    267            * @param  phost: Host Handle
    268            * @param  Class: Class code
    269            * @param  SubClass: SubClass code
    270            * @param  Protocol: Protocol code
    271            * @retval interface index in the configuration structure
    272            * @note : (1)interface index 0xFF means interface index not found
    273            */

   \                                 In section .text, align 2, keep-with-next
    274          uint8_t  USBH_FindInterface(USBH_HandleTypeDef *phost, uint8_t Class, uint8_t SubClass, uint8_t Protocol)
    275          {
   \                     USBH_FindInterface: (+1)
   \   00000000   0xB490             PUSH     {R4,R7}
    276            USBH_InterfaceDescTypeDef    *pif ;
    277            USBH_CfgDescTypeDef          *pcfg ;
    278            int8_t                        if_ix = 0;
   \   00000002   0x2400             MOVS     R4,#+0
    279            
    280            pif = (USBH_InterfaceDescTypeDef *)0;
    281            pcfg = &phost->device.CfgDesc;  
   \   00000004   0xF500 0x700F      ADD      R0,R0,#+572
    282            
    283            while (if_ix < USBH_MAX_NUM_INTERFACES)
    284            {
    285              pif = &pcfg->Itf_Desc[if_ix];
    286              if(((pif->bInterfaceClass == Class) || (Class == 0xFF))&&
    287                 ((pif->bInterfaceSubClass == SubClass) || (SubClass == 0xFF))&&
    288                   ((pif->bInterfaceProtocol == Protocol) || (Protocol == 0xFF)))
   \                     ??USBH_FindInterface_0: (+1)
   \   00000008   0xF890 0xC005      LDRB     R12,[R0, #+5]
   \   0000000C   0x458C             CMP      R12,R1
   \   0000000E   0xBF18             IT       NE 
   \   00000010   0x29FF             CMPNE    R1,#+255
   \   00000012   0xD10E             BNE.N    ??USBH_FindInterface_1
   \   00000014   0xF890 0xC006      LDRB     R12,[R0, #+6]
   \   00000018   0x4594             CMP      R12,R2
   \   0000001A   0xBF18             IT       NE 
   \   0000001C   0x2AFF             CMPNE    R2,#+255
   \   0000001E   0xD108             BNE.N    ??USBH_FindInterface_1
   \   00000020   0xF890 0xC007      LDRB     R12,[R0, #+7]
   \   00000024   0x459C             CMP      R12,R3
   \   00000026   0xBF18             IT       NE 
   \   00000028   0x2BFF             CMPNE    R3,#+255
   \   0000002A   0xD102             BNE.N    ??USBH_FindInterface_1
    289              {
    290                return  if_ix;
   \   0000002C   0xB2E0             UXTB     R0,R4
   \   0000002E   0xBC90             POP      {R4,R7}
   \   00000030   0x4770             BX       LR
    291              }
    292              if_ix++;
   \                     ??USBH_FindInterface_1: (+1)
   \   00000032   0x1C64             ADDS     R4,R4,#+1
   \   00000034   0x3022             ADDS     R0,R0,#+34
    293            }
   \   00000036   0xB264             SXTB     R4,R4
   \   00000038   0x2C01             CMP      R4,#+1
   \   0000003A   0xDBE5             BLT.N    ??USBH_FindInterface_0
    294            return 0xFF;
   \   0000003C   0x20FF             MOVS     R0,#+255
   \   0000003E   0xBC90             POP      {R4,R7}
   \   00000040   0x4770             BX       LR               ;; return
    295          }
    296          
    297          /**
    298            * @brief  USBH_FindInterfaceIndex 
    299            *         Find the interface index for a specific class interface and alternate setting number.
    300            * @param  phost: Host Handle
    301            * @param  interface_number: interface number
    302            * @param  alt_settings    : alternate setting number
    303            * @retval interface index in the configuration structure
    304            * @note : (1)interface index 0xFF means interface index not found
    305            */

   \                                 In section .text, align 2, keep-with-next
    306          uint8_t  USBH_FindInterfaceIndex(USBH_HandleTypeDef *phost, uint8_t interface_number, uint8_t alt_settings)
    307          {
    308            USBH_InterfaceDescTypeDef    *pif ;
    309            USBH_CfgDescTypeDef          *pcfg ;
    310            int8_t                        if_ix = 0;
   \                     USBH_FindInterfaceIndex: (+1)
   \   00000000   0x2300             MOVS     R3,#+0
    311            
    312            pif = (USBH_InterfaceDescTypeDef *)0;
    313            pcfg = &phost->device.CfgDesc;  
   \   00000002   0xF500 0x700F      ADD      R0,R0,#+572
    314            
    315            while (if_ix < USBH_MAX_NUM_INTERFACES)
    316            {
    317              pif = &pcfg->Itf_Desc[if_ix];
    318              if((pif->bInterfaceNumber == interface_number) && (pif->bAlternateSetting == alt_settings))
   \                     ??USBH_FindInterfaceIndex_0: (+1)
   \   00000006   0xF890 0xC002      LDRB     R12,[R0, #+2]
   \   0000000A   0x458C             CMP      R12,R1
   \   0000000C   0xBF04             ITT      EQ 
   \   0000000E   0xF890 0xC003      LDRBEQ   R12,[R0, #+3]
   \   00000012   0x4594             CMPEQ    R12,R2
   \   00000014   0xD101             BNE.N    ??USBH_FindInterfaceIndex_1
    319              {
    320                return  if_ix;
   \   00000016   0xB2D8             UXTB     R0,R3
   \   00000018   0x4770             BX       LR
    321              }
    322              if_ix++;
   \                     ??USBH_FindInterfaceIndex_1: (+1)
   \   0000001A   0x1C5B             ADDS     R3,R3,#+1
   \   0000001C   0x3022             ADDS     R0,R0,#+34
    323            }
   \   0000001E   0xB25B             SXTB     R3,R3
   \   00000020   0x2B01             CMP      R3,#+1
   \   00000022   0xDBF0             BLT.N    ??USBH_FindInterfaceIndex_0
    324            return 0xFF;
   \   00000024   0x20FF             MOVS     R0,#+255
   \   00000026   0x4770             BX       LR               ;; return
    325          }
    326          
    327          /**
    328            * @brief  USBH_Start 
    329            *         Start the USB Host Core.
    330            * @param  phost: Host Handle
    331            * @retval USBH Status
    332            */

   \                                 In section .text, align 2, keep-with-next
    333          USBH_StatusTypeDef  USBH_Start  (USBH_HandleTypeDef *phost)
    334          {
   \                     USBH_Start: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    335            /* Start the low level driver  */
    336            USBH_LL_Start(phost);
   \   00000004   0x....             B.N      ?Subroutine0
    337            
    338            /* Activate VBUS on the port */ 
    339            USBH_LL_DriverVBUS (phost, TRUE);
    340            
    341            return USBH_OK;  
    342          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \   00000000   0x.... 0x....      BL       USBH_LL_Start
   \   00000004   0x2101             MOVS     R1,#+1
   \   00000006   0x4620             MOV      R0,R4
   \   00000008   0x.... 0x....      BL       USBH_LL_DriverVBUS
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0xBD10             POP      {R4,PC}          ;; return
    343          
    344          /**
    345            * @brief  USBH_Stop 
    346            *         Stop the USB Host Core.
    347            * @param  phost: Host Handle
    348            * @retval USBH Status
    349            */

   \                                 In section .text, align 2, keep-with-next
    350          USBH_StatusTypeDef  USBH_Stop   (USBH_HandleTypeDef *phost)
    351          {
   \                     USBH_Stop: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    352            /* Stop and cleanup the low level driver  */
    353            USBH_LL_Stop(phost);  
   \   00000004   0x.... 0x....      BL       USBH_LL_Stop
    354            
    355            /* DeActivate VBUS on the port */ 
    356            USBH_LL_DriverVBUS (phost, FALSE);
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0x4620             MOV      R0,R4
   \   0000000C   0x.... 0x....      BL       USBH_LL_DriverVBUS
    357            
    358            /* FRee Control Pipes */
    359            USBH_FreePipe  (phost, phost->Control.pipe_in);
   \   00000010   0x7921             LDRB     R1,[R4, #+4]
   \   00000012   0x4620             MOV      R0,R4
   \   00000014   0x.... 0x....      BL       USBH_FreePipe
    360            USBH_FreePipe  (phost, phost->Control.pipe_out);  
   \   00000018   0x7961             LDRB     R1,[R4, #+5]
   \   0000001A   0x4620             MOV      R0,R4
   \   0000001C   0x.... 0x....      BL       USBH_FreePipe
    361            
    362            return USBH_OK;  
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0xBD10             POP      {R4,PC}          ;; return
    363          }
    364          
    365          /**
    366            * @brief  HCD_ReEnumerate 
    367            *         Perform a new Enumeration phase.
    368            * @param  phost: Host Handle
    369            * @retval USBH Status
    370            */

   \                                 In section .text, align 2, keep-with-next
    371          USBH_StatusTypeDef  USBH_ReEnumerate   (USBH_HandleTypeDef *phost)
    372          {
   \                     USBH_ReEnumerate: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    373            /*Stop Host */ 
    374            USBH_Stop(phost);
   \   00000004   0x.... 0x....      BL       USBH_Stop
    375          
    376            /*Device has disconnected, so wait for 200 ms */  
    377            USBH_Delay(200);
   \   00000008   0x20C8             MOVS     R0,#+200
   \   0000000A   0x.... 0x....      BL       USBH_Delay
    378            
    379            /* Set State machines in default state */
    380            DeInitStateMachine(phost);
   \   0000000E   0x4620             MOV      R0,R4
   \   00000010   0x.... 0x....      BL       DeInitStateMachine
    381             
    382            /* Start again the host */
    383            USBH_Start(phost);
   \   00000014   0x4620             MOV      R0,R4
   \   00000016                      REQUIRE ?Subroutine0
   \   00000016                      ;; // Fall through to label ?Subroutine0
    384                
    385          #if (USBH_USE_OS == 1)
    386                osMessagePut ( phost->os_event, USBH_PORT_EVENT, 0);
    387          #endif  
    388            return USBH_OK;  
    389          }
    390          
    391          /**
    392            * @brief  USBH_Process 
    393            *         Background process of the USB Core.
    394            * @param  phost: Host Handle
    395            * @retval USBH Status
    396            */

   \                                 In section .text, align 4, keep-with-next
    397          USBH_StatusTypeDef  USBH_Process(USBH_HandleTypeDef *phost)
    398          {
   \                     USBH_Process: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0xB084             SUB      SP,SP,#+16
    399            __IO USBH_StatusTypeDef status = USBH_FAIL;
   \   00000006   0x2002             MOVS     R0,#+2
   \   00000008   0xF88D 0x0000      STRB     R0,[SP, #+0]
    400            uint8_t idx = 0;
    401            
    402            switch (phost->gState)
   \   0000000C   0x7820             LDRB     R0,[R4, #+0]
   \   0000000E   0x280A             CMP      R0,#+10
   \   00000010   0xF200 0x80E9      BHI.W    ??USBH_Process_1
   \   00000014   0xE8DF 0xF000      TBB      [PC, R0]
   \                     ??USBH_Process_0:
   \   00000018   0x06 0xE7          DC8      0x6,0xE7,0x15,0xDB
   \              0x15 0xDB    
   \   0000001C   0xE7 0x4A          DC8      0xE7,0x4A,0xB6,0x6A
   \              0xB6 0x6A    
   \   00000020   0x74 0x81          DC8      0x74,0x81,0xD3,0x0
   \              0xD3 0x00    
    403            {
    404            case HOST_IDLE :
    405              
    406              if (phost->device.is_connected)  
   \                     ??USBH_Process_2: (+1)
   \   00000024   0xF504 0x7007      ADD      R0,R4,#+540
   \   00000028   0x7880             LDRB     R0,[R0, #+2]
   \   0000002A   0x2800             CMP      R0,#+0
   \   0000002C   0xF000 0x80DB      BEQ.W    ??USBH_Process_1
    407              {
    408                /* Wait for 200 ms after connection */
    409                phost->gState = HOST_DEV_WAIT_FOR_ATTACHMENT; 
   \   00000030   0x2001             MOVS     R0,#+1
   \   00000032   0x7020             STRB     R0,[R4, #+0]
    410                USBH_Delay(200); 
   \   00000034   0x20C8             MOVS     R0,#+200
   \   00000036   0x.... 0x....      BL       USBH_Delay
    411                USBH_LL_ResetPort(phost);
   \   0000003A   0x4620             MOV      R0,R4
   \   0000003C   0x.... 0x....      BL       USBH_LL_ResetPort
   \   00000040   0xE0D1             B.N      ??USBH_Process_1
    412          #if (USBH_USE_OS == 1)
    413                osMessagePut ( phost->os_event, USBH_PORT_EVENT, 0);
    414          #endif
    415              }
    416              break;
    417              
    418            case HOST_DEV_WAIT_FOR_ATTACHMENT:
    419              break;    
    420              
    421            case HOST_DEV_ATTACHED :
    422              
    423              USBH_UsrLog("USB Device Attached");  
   \                     ??USBH_Process_3: (+1)
   \   00000042   0x.... 0x....      ADR.W    R0,?_10
   \   00000046   0xF504 0x7507      ADD      R5,R4,#+540
   \   0000004A   0x.... 0x....      BL       printf
   \   0000004E   0x....             ADR.N    R0,??DataTable33  ;; "\n"
   \   00000050   0x.... 0x....      BL       printf
    424                
    425              /* Wait for 100 ms after Reset */
    426              USBH_Delay(100); 
   \   00000054   0x2064             MOVS     R0,#+100
   \   00000056   0x.... 0x....      BL       USBH_Delay
    427                    
    428              phost->device.speed = USBH_LL_GetSpeed(phost);
   \   0000005A   0x4620             MOV      R0,R4
   \   0000005C   0x.... 0x....      BL       USBH_LL_GetSpeed
   \   00000060   0x7068             STRB     R0,[R5, #+1]
    429              
    430              phost->gState = HOST_ENUMERATION;
   \   00000062   0x2005             MOVS     R0,#+5
   \   00000064   0x7020             STRB     R0,[R4, #+0]
    431              
    432              phost->Control.pipe_out = USBH_AllocPipe (phost, 0x00);
   \   00000066   0x2100             MOVS     R1,#+0
   \   00000068   0x4620             MOV      R0,R4
   \   0000006A   0x.... 0x....      BL       USBH_AllocPipe
   \   0000006E   0x7160             STRB     R0,[R4, #+5]
    433              phost->Control.pipe_in  = USBH_AllocPipe (phost, 0x80);    
   \   00000070   0x2180             MOVS     R1,#+128
   \   00000072   0x4620             MOV      R0,R4
   \   00000074   0x.... 0x....      BL       USBH_AllocPipe
    434              
    435              
    436              /* Open Control pipes */
    437              USBH_OpenPipe (phost,
    438                             phost->Control.pipe_in,
    439                             0x80,
    440                             phost->device.address,
    441                             phost->device.speed,
    442                             USBH_EP_CONTROL,
    443                             phost->Control.pipe_size); 
   \   00000078   0x79A1             LDRB     R1,[R4, #+6]
   \   0000007A   0x7120             STRB     R0,[R4, #+4]
   \   0000007C   0x2280             MOVS     R2,#+128
   \   0000007E   0x9102             STR      R1,[SP, #+8]
   \   00000080   0x2100             MOVS     R1,#+0
   \   00000082   0x9101             STR      R1,[SP, #+4]
   \   00000084   0x7869             LDRB     R1,[R5, #+1]
   \   00000086   0x9100             STR      R1,[SP, #+0]
   \   00000088   0x782B             LDRB     R3,[R5, #+0]
   \   0000008A   0x4601             MOV      R1,R0
   \   0000008C   0x4620             MOV      R0,R4
   \   0000008E   0x.... 0x....      BL       USBH_OpenPipe
    444              
    445              /* Open Control pipes */
    446              USBH_OpenPipe (phost,
    447                             phost->Control.pipe_out,
    448                             0x00,
    449                             phost->device.address,
    450                             phost->device.speed,
    451                             USBH_EP_CONTROL,
    452                             phost->Control.pipe_size);
   \   00000092   0x79A0             LDRB     R0,[R4, #+6]
   \   00000094   0x2200             MOVS     R2,#+0
   \   00000096   0x9002             STR      R0,[SP, #+8]
   \   00000098   0x2000             MOVS     R0,#+0
   \   0000009A   0x9001             STR      R0,[SP, #+4]
   \   0000009C   0x7868             LDRB     R0,[R5, #+1]
   \   0000009E   0x9000             STR      R0,[SP, #+0]
   \   000000A0   0x782B             LDRB     R3,[R5, #+0]
   \   000000A2   0x7961             LDRB     R1,[R4, #+5]
   \   000000A4   0x4620             MOV      R0,R4
   \   000000A6   0x.... 0x....      BL       USBH_OpenPipe
    453              
    454          #if (USBH_USE_OS == 1)
    455              osMessagePut ( phost->os_event, USBH_PORT_EVENT, 0);
    456          #endif    
    457              
    458              break;
   \   000000AA   0xE09C             B.N      ??USBH_Process_1
    459              
    460            case HOST_ENUMERATION:     
    461              /* Check for enumeration status */  
    462              if ( USBH_HandleEnum(phost) == USBH_OK)
   \                     ??USBH_Process_4: (+1)
   \   000000AC   0x4620             MOV      R0,R4
   \   000000AE   0x.... 0x....      BL       USBH_HandleEnum
   \   000000B2   0x2800             CMP      R0,#+0
   \   000000B4   0xF040 0x8097      BNE.W    ??USBH_Process_1
    463              { 
    464                /* The function shall return USBH_OK when full enumeration is complete */
    465                USBH_UsrLog ("Enumeration done.");
   \   000000B8   0x.... 0x....      ADR.W    R0,?_11
   \   000000BC   0xF504 0x7507      ADD      R5,R4,#+540
   \   000000C0   0x.... 0x....      BL       printf
   \   000000C4   0x....             ADR.N    R6,??DataTable33  ;; "\n"
   \   000000C6   0x4630             MOV      R0,R6
   \   000000C8   0x.... 0x....      BL       printf
    466                phost->device.current_interface = 0;
   \   000000CC   0x2000             MOVS     R0,#+0
   \   000000CE   0x70E8             STRB     R0,[R5, #+3]
    467                if(phost->device.DevDesc.bNumConfigurations == 1)
   \   000000D0   0x7D68             LDRB     R0,[R5, #+21]
   \   000000D2   0x2801             CMP      R0,#+1
   \   000000D4   0xD108             BNE.N    ??USBH_Process_5
    468                {
    469                  USBH_UsrLog ("This device has only 1 configuration.");
   \   000000D6   0x.... 0x....      ADR.W    R0,?_12
   \   000000DA   0x.... 0x....      BL       printf
   \   000000DE   0x4630             MOV      R0,R6
   \   000000E0   0x.... 0x....      BL       printf
    470                  phost->gState  = HOST_SET_CONFIGURATION;        
   \   000000E4   0x2008             MOVS     R0,#+8
   \   000000E6   0xE05A             B.N      ??USBH_Process_6
    471                  
    472                }
    473                else
    474                {
    475                  phost->gState  = HOST_INPUT; 
   \                     ??USBH_Process_5: (+1)
   \   000000E8   0x2007             MOVS     R0,#+7
   \   000000EA   0xE058             B.N      ??USBH_Process_6
    476                }
    477                    
    478              }
    479              break;
    480              
    481            case HOST_INPUT:
    482              {
    483                /* user callback for end of device basic enumeration */
    484                if(phost->pUser != NULL)
   \                     ??USBH_Process_7: (+1)
   \   000000EC   0xF504 0x7518      ADD      R5,R4,#+608
   \   000000F0   0x6D6A             LDR      R2,[R5, #+84]
   \   000000F2   0x0010             MOVS     R0,R2
   \   000000F4   0xD077             BEQ.N    ??USBH_Process_1
    485                {
    486                  phost->pUser(phost, HOST_USER_SELECT_CONFIGURATION);
   \   000000F6   0x2101             MOVS     R1,#+1
   \   000000F8   0x4620             MOV      R0,R4
   \   000000FA   0x4790             BLX      R2
    487                  phost->gState = HOST_SET_CONFIGURATION;
   \   000000FC   0x2008             MOVS     R0,#+8
   \   000000FE   0xE04E             B.N      ??USBH_Process_6
    488                  
    489          #if (USBH_USE_OS == 1)
    490                  osMessagePut ( phost->os_event, USBH_STATE_CHANGED_EVENT, 0);
    491          #endif         
    492                }
    493              }
    494              break;
    495              
    496            case HOST_SET_CONFIGURATION:
    497              /* set configuration */
    498              if (USBH_SetCfg(phost, phost->device.CfgDesc.bConfigurationValue) == USBH_OK)
   \                     ??USBH_Process_8: (+1)
   \   00000100   0xF504 0x7007      ADD      R0,R4,#+540
   \   00000104   0x7EC1             LDRB     R1,[R0, #+27]
   \   00000106   0x4620             MOV      R0,R4
   \   00000108   0x.... 0x....      BL       USBH_SetCfg
   \   0000010C   0x2800             CMP      R0,#+0
   \   0000010E   0xD16A             BNE.N    ??USBH_Process_1
    499              {
    500                phost->gState  = HOST_CHECK_CLASS;
   \   00000110   0x2009             MOVS     R0,#+9
   \   00000112   0x7020             STRB     R0,[R4, #+0]
    501                USBH_UsrLog ("Default configuration set.");
   \   00000114   0x.... 0x....      ADR.W    R0,?_13
   \   00000118   0xE04B             B.N      ??USBH_Process_9
    502                
    503              }      
    504              
    505              break;
    506              
    507            case HOST_CHECK_CLASS:
    508              
    509              if(phost->ClassNumber == 0)
   \                     ??USBH_Process_10: (+1)
   \   0000011A   0xF504 0x7518      ADD      R5,R4,#+608
   \   0000011E   0x68A8             LDR      R0,[R5, #+8]
   \   00000120   0xB910             CBNZ.N   R0,??USBH_Process_11
    510              {
    511                USBH_UsrLog ("No Class has been registered.");
   \   00000122   0x.... 0x....      ADR.W    R0,?_14
   \   00000126   0xE044             B.N      ??USBH_Process_9
    512              }
    513              else
    514              {
    515                phost->pActiveClass = NULL;
    516                
    517                for (idx = 0; idx < USBH_MAX_NUM_SUPPORTED_CLASS ; idx ++)
    518                {
    519                  if(phost->pClass[idx]->ClassCode == phost->device.CfgDesc.Itf_Desc[0].bInterfaceClass)
   \                     ??USBH_Process_11: (+1)
   \   00000128   0x6829             LDR      R1,[R5, #+0]
   \   0000012A   0x2000             MOVS     R0,#+0
   \   0000012C   0x6068             STR      R0,[R5, #+4]
   \   0000012E   0xF894 0x2241      LDRB     R2,[R4, #+577]
   \   00000132   0x7908             LDRB     R0,[R1, #+4]
   \   00000134   0x4290             CMP      R0,R2
   \   00000136   0xD120             BNE.N    ??USBH_Process_12
    520                  {
    521                    phost->pActiveClass = phost->pClass[idx];
   \   00000138   0x6069             STR      R1,[R5, #+4]
    522                  }
    523                }
    524                
    525                if(phost->pActiveClass != NULL)
   \   0000013A   0xB1F1             CBZ.N    R1,??USBH_Process_12
    526                {
    527                  if(phost->pActiveClass->Init(phost)== USBH_OK)
   \   0000013C   0x6889             LDR      R1,[R1, #+8]
   \   0000013E   0x4620             MOV      R0,R4
   \   00000140   0x....             ADR.N    R6,??DataTable33  ;; "\n"
   \   00000142   0x4788             BLX      R1
   \   00000144   0xB978             CBNZ.N   R0,??USBH_Process_13
    528                  {
    529                    phost->gState  = HOST_CLASS_REQUEST; 
   \   00000146   0x2006             MOVS     R0,#+6
   \   00000148   0x7020             STRB     R0,[R4, #+0]
    530                    USBH_UsrLog ("%s class started.", phost->pActiveClass->Name);
   \   0000014A   0x6868             LDR      R0,[R5, #+4]
   \   0000014C   0x6801             LDR      R1,[R0, #+0]
   \   0000014E   0x.... 0x....      ADR.W    R0,?_15
   \   00000152   0x.... 0x....      BL       printf
   \   00000156   0x4630             MOV      R0,R6
   \   00000158   0x.... 0x....      BL       printf
    531                    
    532                    /* Inform user that a class has been activated */
    533                    phost->pUser(phost, HOST_USER_CLASS_SELECTED);   
   \   0000015C   0x6D6A             LDR      R2,[R5, #+84]
   \   0000015E   0x2103             MOVS     R1,#+3
   \   00000160   0x4620             MOV      R0,R4
   \   00000162   0x4790             BLX      R2
   \   00000164   0xE03F             B.N      ??USBH_Process_1
    534                  }
    535                  else
    536                  {
    537                    phost->gState  = HOST_ABORT_STATE;
   \                     ??USBH_Process_13: (+1)
   \   00000166   0x200C             MOVS     R0,#+12
   \   00000168   0x7020             STRB     R0,[R4, #+0]
    538                    USBH_UsrLog ("Device not supporting %s class.", phost->pActiveClass->Name);
   \   0000016A   0x6868             LDR      R0,[R5, #+4]
   \   0000016C   0x6801             LDR      R1,[R0, #+0]
   \   0000016E   0x.... 0x....      ADR.W    R0,?_16
   \   00000172   0x.... 0x....      BL       printf
   \   00000176   0x4630             MOV      R0,R6
   \   00000178   0xE01E             B.N      ??USBH_Process_14
    539                  }
    540                }
    541                else
    542                {
    543                  phost->gState  = HOST_ABORT_STATE;
   \                     ??USBH_Process_12: (+1)
   \   0000017A   0x200C             MOVS     R0,#+12
   \   0000017C   0x7020             STRB     R0,[R4, #+0]
    544                  USBH_UsrLog ("No registered class for this device.");
   \   0000017E   0x.... 0x....      ADR.W    R0,?_17
   \   00000182   0xE016             B.N      ??USBH_Process_9
    545                }
    546              }
    547              
    548          #if (USBH_USE_OS == 1)
    549              osMessagePut ( phost->os_event, USBH_STATE_CHANGED_EVENT, 0);
    550          #endif 
    551              break;    
    552              
    553            case HOST_CLASS_REQUEST:  
    554              /* process class standard control requests state machine */
    555              if(phost->pActiveClass != NULL)
   \                     ??USBH_Process_15: (+1)
   \   00000184   0xF504 0x7518      ADD      R5,R4,#+608
   \   00000188   0x6869             LDR      R1,[R5, #+4]
   \   0000018A   0xB151             CBZ.N    R1,??USBH_Process_16
    556              {
    557                status = phost->pActiveClass->Requests(phost);
   \   0000018C   0x6909             LDR      R1,[R1, #+16]
   \   0000018E   0x4620             MOV      R0,R4
   \   00000190   0x4788             BLX      R1
   \   00000192   0xF88D 0x0000      STRB     R0,[SP, #+0]
    558                
    559                if(status == USBH_OK)
   \   00000196   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000019A   0xBB20             CBNZ.N   R0,??USBH_Process_1
    560                {
    561                  phost->gState  = HOST_CLASS;        
   \   0000019C   0x200A             MOVS     R0,#+10
   \                     ??USBH_Process_6: (+1)
   \   0000019E   0x7020             STRB     R0,[R4, #+0]
   \   000001A0   0xE021             B.N      ??USBH_Process_1
    562                }  
    563              }
    564              else
    565              {
    566                phost->gState  = HOST_ABORT_STATE;
   \                     ??USBH_Process_16: (+1)
   \   000001A2   0x200C             MOVS     R0,#+12
   \   000001A4   0x7020             STRB     R0,[R4, #+0]
    567                USBH_ErrLog ("Invalid Class Driver.");
   \   000001A6   0x.... 0x....      ADR.W    R0,?_0
   \   000001AA   0x.... 0x....      BL       printf
   \   000001AE   0x.... 0x....      ADR.W    R0,?_18
   \                     ??USBH_Process_9: (+1)
   \   000001B2   0x.... 0x....      BL       printf
   \   000001B6   0x....             ADR.N    R0,??DataTable33  ;; "\n"
   \                     ??USBH_Process_14: (+1)
   \   000001B8   0x.... 0x....      BL       printf
   \   000001BC   0xE013             B.N      ??USBH_Process_1
    568              
    569          #if (USBH_USE_OS == 1)
    570              osMessagePut ( phost->os_event, USBH_STATE_CHANGED_EVENT, 0);
    571          #endif       
    572              }
    573              
    574              break;    
    575            case HOST_CLASS:   
    576              /* process class state machine */
    577              if(phost->pActiveClass != NULL)
   \                     ??USBH_Process_17: (+1)
   \   000001BE   0xF504 0x7518      ADD      R5,R4,#+608
   \   000001C2   0x6869             LDR      R1,[R5, #+4]
   \   000001C4   0xB179             CBZ.N    R1,??USBH_Process_1
    578              { 
    579                phost->pActiveClass->BgndProcess(phost);
   \   000001C6   0x6949             LDR      R1,[R1, #+20]
   \   000001C8   0x4620             MOV      R0,R4
   \   000001CA   0x4788             BLX      R1
   \   000001CC   0xE00B             B.N      ??USBH_Process_1
    580              }
    581              break;       
    582          
    583            case HOST_DEV_DISCONNECTED :
    584              
    585              DeInitStateMachine(phost);  
   \                     ??USBH_Process_18: (+1)
   \   000001CE   0x4620             MOV      R0,R4
   \   000001D0   0xF504 0x7518      ADD      R5,R4,#+608
   \   000001D4   0x.... 0x....      BL       DeInitStateMachine
    586              
    587              /* Re-Initilaize Host for new Enumeration */
    588              if(phost->pActiveClass != NULL)
   \   000001D8   0x6869             LDR      R1,[R5, #+4]
   \   000001DA   0xB121             CBZ.N    R1,??USBH_Process_1
    589              {
    590                phost->pActiveClass->DeInit(phost); 
   \   000001DC   0x68C9             LDR      R1,[R1, #+12]
   \   000001DE   0x4620             MOV      R0,R4
   \   000001E0   0x4788             BLX      R1
    591                phost->pActiveClass = NULL;
   \   000001E2   0x2000             MOVS     R0,#+0
   \   000001E4   0x6068             STR      R0,[R5, #+4]
    592              }     
    593              break;
    594              
    595            case HOST_ABORT_STATE:
    596            default :
    597              break;
    598            }
    599           return USBH_OK;  
   \                     ??USBH_Process_1: (+1)
   \   000001E6   0x2000             MOVS     R0,#+0
   \   000001E8   0xB004             ADD      SP,SP,#+16
   \   000001EA   0xBD70             POP      {R4-R6,PC}       ;; return
    600          }
    601          
    602          
    603          /**
    604            * @brief  USBH_HandleEnum 
    605            *         This function includes the complete enumeration process
    606            * @param  phost: Host Handle
    607            * @retval USBH_Status
    608            */

   \                                 In section .text, align 4, keep-with-next
    609          static USBH_StatusTypeDef USBH_HandleEnum (USBH_HandleTypeDef *phost)
    610          {
   \                     USBH_HandleEnum: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0x4605             MOV      R5,R0
    611            USBH_StatusTypeDef Status = USBH_BUSY;  
    612            
    613            switch (phost->EnumState)
   \   00000004   0x1C6E             ADDS     R6,R5,#+1
   \   00000006   0xB083             SUB      SP,SP,#+12
   \   00000008   0x2401             MOVS     R4,#+1
   \   0000000A   0x7830             LDRB     R0,[R6, #+0]
   \   0000000C   0x2807             CMP      R0,#+7
   \   0000000E   0xF200 0x80C7      BHI.W    ??USBH_HandleEnum_1
   \   00000012   0xE8DF 0xF000      TBB      [PC, R0]
   \                     ??USBH_HandleEnum_0:
   \   00000016   0x04 0x11          DC8      0x4,0x11,0x2D,0x5D
   \              0x2D 0x5D    
   \   0000001A   0x65 0x6F          DC8      0x65,0x6F,0x8F,0xAB
   \              0x8F 0xAB    
    614            {
    615            case ENUM_IDLE:  
    616              /* Get Device Desc for only 1st 8 bytes : To get EP0 MaxPacketSize */
    617              if ( USBH_Get_DevDesc(phost, 8) == USBH_OK)
   \                     ??USBH_HandleEnum_2: (+1)
   \   0000001E   0x2108             MOVS     R1,#+8
   \   00000020   0x4628             MOV      R0,R5
   \   00000022   0x.... 0x....      BL       USBH_Get_DevDesc
   \   00000026   0x2800             CMP      R0,#+0
   \   00000028   0xF040 0x80BA      BNE.W    ??USBH_HandleEnum_1
    618              {
    619                phost->Control.pipe_size = phost->device.DevDesc.bMaxPacketSize;
   \   0000002C   0xF505 0x7707      ADD      R7,R5,#+540
   \   00000030   0x7AF8             LDRB     R0,[R7, #+11]
    620          
    621                phost->EnumState = ENUM_GET_FULL_DEV_DESC;
   \   00000032   0x7034             STRB     R4,[R6, #+0]
   \   00000034   0x7170             STRB     R0,[R6, #+5]
    622                
    623                /* modify control channels configuration for MaxPacket size */
    624                USBH_OpenPipe (phost,
    625                                     phost->Control.pipe_in,
    626                                     0x80,
    627                                     phost->device.address,
    628                                     phost->device.speed,
    629                                     USBH_EP_CONTROL,
    630                                     phost->Control.pipe_size); 
   \   00000036   0xE032             B.N      ??USBH_HandleEnum_3
    631                
    632                /* Open Control pipes */
    633                USBH_OpenPipe (phost,
    634                                     phost->Control.pipe_out,
    635                                     0x00,
    636                                     phost->device.address,
    637                                     phost->device.speed,
    638                                     USBH_EP_CONTROL,
    639                                     phost->Control.pipe_size);           
    640                
    641              }
    642              break;
    643              
    644            case ENUM_GET_FULL_DEV_DESC:  
    645              /* Get FULL Device Desc  */
    646              if ( USBH_Get_DevDesc(phost, USB_DEVICE_DESC_SIZE)== USBH_OK)
   \                     ??USBH_HandleEnum_4: (+1)
   \   00000038   0x2112             MOVS     R1,#+18
   \   0000003A   0x4628             MOV      R0,R5
   \   0000003C   0x.... 0x....      BL       USBH_Get_DevDesc
   \   00000040   0x2800             CMP      R0,#+0
   \   00000042   0xF040 0x80AD      BNE.W    ??USBH_HandleEnum_1
    647              {
    648                USBH_UsrLog("PID: %xh", phost->device.DevDesc.idProduct );  
   \   00000046   0xF505 0x7707      ADD      R7,R5,#+540
   \   0000004A   0x.... 0x....      ADR.W    R0,?_19
   \   0000004E   0x....             ADR.N    R5,??DataTable33  ;; "\n"
   \   00000050   0x89F9             LDRH     R1,[R7, #+14]
   \   00000052   0x.... 0x....      BL       printf
   \   00000056   0x4628             MOV      R0,R5
   \   00000058   0x.... 0x....      BL       printf
    649                USBH_UsrLog("VID: %xh", phost->device.DevDesc.idVendor );  
   \   0000005C   0x89B9             LDRH     R1,[R7, #+12]
   \   0000005E   0x.... 0x....      ADR.W    R0,?_20
   \   00000062   0x.... 0x....      BL       printf
   \   00000066   0x4628             MOV      R0,R5
   \   00000068   0x.... 0x....      BL       printf
    650                
    651                phost->EnumState = ENUM_SET_ADDR;
   \   0000006C   0x2002             MOVS     R0,#+2
   \   0000006E   0xE07B             B.N      ??USBH_HandleEnum_5
    652                 
    653              }
    654              break;
    655             
    656            case ENUM_SET_ADDR: 
    657              /* set address */
    658              if ( USBH_SetAddress(phost, USBH_DEVICE_ADDRESS) == USBH_OK)
   \                     ??USBH_HandleEnum_6: (+1)
   \   00000070   0x2101             MOVS     R1,#+1
   \   00000072   0x4628             MOV      R0,R5
   \   00000074   0x.... 0x....      BL       USBH_SetAddress
   \   00000078   0x2800             CMP      R0,#+0
   \   0000007A   0xF040 0x8091      BNE.W    ??USBH_HandleEnum_1
    659              {
    660                USBH_Delay(2);
   \   0000007E   0x2002             MOVS     R0,#+2
   \   00000080   0xF505 0x7707      ADD      R7,R5,#+540
   \   00000084   0x.... 0x....      BL       USBH_Delay
    661                phost->device.address = USBH_DEVICE_ADDRESS;
   \   00000088   0x703C             STRB     R4,[R7, #+0]
    662                
    663                /* user callback for device address assigned */
    664                USBH_UsrLog("Address (#%d) assigned.", phost->device.address);
   \   0000008A   0x2101             MOVS     R1,#+1
   \   0000008C   0x.... 0x....      ADR.W    R0,?_21
   \   00000090   0x.... 0x....      BL       printf
   \   00000094   0x....             ADR.N    R0,??DataTable33  ;; "\n"
   \   00000096   0x.... 0x....      BL       printf
    665                phost->EnumState = ENUM_GET_CFG_DESC;
   \   0000009A   0x2003             MOVS     R0,#+3
   \   0000009C   0x7030             STRB     R0,[R6, #+0]
    666                
    667                /* modify control channels to update device address */
    668                USBH_OpenPipe (phost,
    669                                     phost->Control.pipe_in,
    670                                     0x80,
    671                                     phost->device.address,
    672                                     phost->device.speed,
    673                                     USBH_EP_CONTROL,
    674                                     phost->Control.pipe_size); 
   \                     ??USBH_HandleEnum_3: (+1)
   \   0000009E   0x7970             LDRB     R0,[R6, #+5]
   \   000000A0   0x2280             MOVS     R2,#+128
   \   000000A2   0x9002             STR      R0,[SP, #+8]
   \   000000A4   0x2000             MOVS     R0,#+0
   \   000000A6   0x9001             STR      R0,[SP, #+4]
   \   000000A8   0x7878             LDRB     R0,[R7, #+1]
   \   000000AA   0x9000             STR      R0,[SP, #+0]
   \   000000AC   0x783B             LDRB     R3,[R7, #+0]
   \   000000AE   0x78F1             LDRB     R1,[R6, #+3]
   \   000000B0   0x4628             MOV      R0,R5
   \   000000B2   0x.... 0x....      BL       USBH_OpenPipe
    675                
    676                /* Open Control pipes */
    677                USBH_OpenPipe (phost,
    678                                     phost->Control.pipe_out,
    679                                     0x00,
    680                                     phost->device.address,
    681                                     phost->device.speed,
    682                                     USBH_EP_CONTROL,
    683                                     phost->Control.pipe_size);        
   \   000000B6   0x7970             LDRB     R0,[R6, #+5]
   \   000000B8   0x2200             MOVS     R2,#+0
   \   000000BA   0x9002             STR      R0,[SP, #+8]
   \   000000BC   0x2000             MOVS     R0,#+0
   \   000000BE   0x9001             STR      R0,[SP, #+4]
   \   000000C0   0x7878             LDRB     R0,[R7, #+1]
   \   000000C2   0x9000             STR      R0,[SP, #+0]
   \   000000C4   0x783B             LDRB     R3,[R7, #+0]
   \   000000C6   0x7931             LDRB     R1,[R6, #+4]
   \   000000C8   0x4628             MOV      R0,R5
   \   000000CA   0x.... 0x....      BL       USBH_OpenPipe
   \   000000CE   0xE067             B.N      ??USBH_HandleEnum_1
    684              }
    685              break;
    686              
    687            case ENUM_GET_CFG_DESC:  
    688              /* get standard configuration descriptor */
    689              if ( USBH_Get_CfgDesc(phost, 
    690                                    USB_CONFIGURATION_DESC_SIZE) == USBH_OK)
   \                     ??USBH_HandleEnum_7: (+1)
   \   000000D0   0x2109             MOVS     R1,#+9
   \   000000D2   0x4628             MOV      R0,R5
   \   000000D4   0x.... 0x....      BL       USBH_Get_CfgDesc
   \   000000D8   0x2800             CMP      R0,#+0
   \   000000DA   0xD161             BNE.N    ??USBH_HandleEnum_1
    691              {
    692                phost->EnumState = ENUM_GET_FULL_CFG_DESC;        
   \   000000DC   0x2004             MOVS     R0,#+4
   \   000000DE   0xE043             B.N      ??USBH_HandleEnum_5
    693              }
    694              break;
    695              
    696            case ENUM_GET_FULL_CFG_DESC:  
    697              /* get FULL config descriptor (config, interface, endpoints) */
    698              if (USBH_Get_CfgDesc(phost, 
    699                                   phost->device.CfgDesc.wTotalLength) == USBH_OK)
   \                     ??USBH_HandleEnum_8: (+1)
   \   000000E0   0xF505 0x7007      ADD      R0,R5,#+540
   \   000000E4   0x8B01             LDRH     R1,[R0, #+24]
   \   000000E6   0x4628             MOV      R0,R5
   \   000000E8   0x.... 0x....      BL       USBH_Get_CfgDesc
   \   000000EC   0x2800             CMP      R0,#+0
   \   000000EE   0xD157             BNE.N    ??USBH_HandleEnum_1
    700              {
    701                phost->EnumState = ENUM_GET_MFC_STRING_DESC;       
   \   000000F0   0x2005             MOVS     R0,#+5
   \   000000F2   0xE039             B.N      ??USBH_HandleEnum_5
    702              }
    703              break;
    704              
    705            case ENUM_GET_MFC_STRING_DESC:  
    706              if (phost->device.DevDesc.iManufacturer != 0)
   \                     ??USBH_HandleEnum_9: (+1)
   \   000000F4   0xF505 0x7707      ADD      R7,R5,#+540
   \   000000F8   0x7CB9             LDRB     R1,[R7, #+18]
   \   000000FA   0xB191             CBZ.N    R1,??USBH_HandleEnum_10
    707              { /* Check that Manufacturer String is available */
    708                
    709                if ( USBH_Get_StringDesc(phost,
    710                                         phost->device.DevDesc.iManufacturer, 
    711                                          phost->device.Data , 
    712                                         0xff) == USBH_OK)
   \   000000FC   0x23FF             MOVS     R3,#+255
   \   000000FE   0xF105 0x021C      ADD      R2,R5,#+28
   \   00000102   0x4628             MOV      R0,R5
   \   00000104   0x.... 0x....      BL       USBH_Get_StringDesc
   \   00000108   0x2800             CMP      R0,#+0
   \   0000010A   0xD149             BNE.N    ??USBH_HandleEnum_1
    713                {
    714                  /* User callback for Manufacturing string */
    715                  USBH_UsrLog("Manufacturer : %s",  (char *)phost->device.Data);
   \   0000010C   0xF105 0x011C      ADD      R1,R5,#+28
   \   00000110   0x.... 0x....      ADR.W    R0,?_22
   \   00000114   0x.... 0x....      BL       printf
   \   00000118   0x....             ADR.N    R0,??DataTable33  ;; "\n"
   \   0000011A   0x.... 0x....      BL       printf
    716                  phost->EnumState = ENUM_GET_PRODUCT_STRING_DESC;
   \   0000011E   0x2006             MOVS     R0,#+6
   \   00000120   0xE022             B.N      ??USBH_HandleEnum_5
    717                  
    718          #if (USBH_USE_OS == 1)
    719              osMessagePut ( phost->os_event, USBH_STATE_CHANGED_EVENT, 0);
    720          #endif          
    721                }
    722              }
    723              else
    724              {
    725               USBH_UsrLog("Manufacturer : N/A");      
   \                     ??USBH_HandleEnum_10: (+1)
   \   00000122   0x.... 0x....      ADR.W    R0,?_23
   \   00000126   0x.... 0x....      BL       printf
   \   0000012A   0x....             ADR.N    R0,??DataTable33  ;; "\n"
   \   0000012C   0x.... 0x....      BL       printf
    726               phost->EnumState = ENUM_GET_PRODUCT_STRING_DESC; 
   \   00000130   0x2006             MOVS     R0,#+6
   \   00000132   0xE019             B.N      ??USBH_HandleEnum_5
    727          #if (USBH_USE_OS == 1)
    728              osMessagePut ( phost->os_event, USBH_STATE_CHANGED_EVENT, 0);
    729          #endif       
    730              }
    731              break;
    732              
    733            case ENUM_GET_PRODUCT_STRING_DESC:   
    734              if (phost->device.DevDesc.iProduct != 0)
   \                     ??USBH_HandleEnum_11: (+1)
   \   00000134   0xF505 0x7707      ADD      R7,R5,#+540
   \   00000138   0x7CF9             LDRB     R1,[R7, #+19]
   \   0000013A   0xB169             CBZ.N    R1,??USBH_HandleEnum_12
    735              { /* Check that Product string is available */
    736                if ( USBH_Get_StringDesc(phost,
    737                                         phost->device.DevDesc.iProduct, 
    738                                         phost->device.Data, 
    739                                         0xff) == USBH_OK)
   \   0000013C   0x23FF             MOVS     R3,#+255
   \   0000013E   0xF105 0x021C      ADD      R2,R5,#+28
   \   00000142   0x4628             MOV      R0,R5
   \   00000144   0x.... 0x....      BL       USBH_Get_StringDesc
   \   00000148   0xBB50             CBNZ.N   R0,??USBH_HandleEnum_1
    740                {
    741                  /* User callback for Product string */
    742                  USBH_UsrLog("Product : %s",  (char *)phost->device.Data);
   \   0000014A   0xF105 0x011C      ADD      R1,R5,#+28
   \   0000014E   0x.... 0x....      ADR.W    R0,?_24
   \   00000152   0x.... 0x....      BL       printf
   \   00000156   0xE003             B.N      ??USBH_HandleEnum_13
    743                  phost->EnumState = ENUM_GET_SERIALNUM_STRING_DESC;        
    744                }
    745              }
    746              else
    747              {
    748                USBH_UsrLog("Product : N/A");
   \                     ??USBH_HandleEnum_12: (+1)
   \   00000158   0x.... 0x....      ADR.W    R0,?_25
   \   0000015C   0x.... 0x....      BL       printf
   \                     ??USBH_HandleEnum_13: (+1)
   \   00000160   0x....             ADR.N    R0,??DataTable33  ;; "\n"
   \   00000162   0x.... 0x....      BL       printf
    749                phost->EnumState = ENUM_GET_SERIALNUM_STRING_DESC; 
   \   00000166   0x2007             MOVS     R0,#+7
   \                     ??USBH_HandleEnum_5: (+1)
   \   00000168   0x7030             STRB     R0,[R6, #+0]
   \   0000016A   0xE019             B.N      ??USBH_HandleEnum_1
    750          #if (USBH_USE_OS == 1)
    751              osMessagePut ( phost->os_event, USBH_STATE_CHANGED_EVENT, 0);
    752          #endif        
    753              } 
    754              break;
    755              
    756            case ENUM_GET_SERIALNUM_STRING_DESC:   
    757              if (phost->device.DevDesc.iSerialNumber != 0)
   \                     ??USBH_HandleEnum_14: (+1)
   \   0000016C   0xF505 0x7707      ADD      R7,R5,#+540
   \   00000170   0x7D39             LDRB     R1,[R7, #+20]
   \   00000172   0xB169             CBZ.N    R1,??USBH_HandleEnum_15
    758              { /* Check that Serial number string is available */    
    759                if ( USBH_Get_StringDesc(phost,
    760                                         phost->device.DevDesc.iSerialNumber, 
    761                                         phost->device.Data, 
    762                                         0xff) == USBH_OK)
   \   00000174   0x23FF             MOVS     R3,#+255
   \   00000176   0xF105 0x021C      ADD      R2,R5,#+28
   \   0000017A   0x4628             MOV      R0,R5
   \   0000017C   0x.... 0x....      BL       USBH_Get_StringDesc
   \   00000180   0xB970             CBNZ.N   R0,??USBH_HandleEnum_1
    763                {
    764                  /* User callback for Serial number string */
    765                   USBH_UsrLog("Serial Number : %s",  (char *)phost->device.Data);
   \   00000182   0xF105 0x011C      ADD      R1,R5,#+28
   \   00000186   0x.... 0x....      ADR.W    R0,?_26
   \   0000018A   0x.... 0x....      BL       printf
   \   0000018E   0xE003             B.N      ??USBH_HandleEnum_16
    766                  Status = USBH_OK;
    767                }
    768              }
    769              else
    770              {
    771                USBH_UsrLog("Serial Number : N/A"); 
   \                     ??USBH_HandleEnum_15: (+1)
   \   00000190   0x.... 0x....      ADR.W    R0,?_27
   \   00000194   0x.... 0x....      BL       printf
   \                     ??USBH_HandleEnum_16: (+1)
   \   00000198   0x....             ADR.N    R0,??DataTable33  ;; "\n"
   \   0000019A   0x.... 0x....      BL       printf
    772                Status = USBH_OK;
   \   0000019E   0x2400             MOVS     R4,#+0
    773          #if (USBH_USE_OS == 1)
    774              osMessagePut ( phost->os_event, USBH_STATE_CHANGED_EVENT, 0);
    775          #endif        
    776              }  
    777              break;
    778              
    779            default:
    780              break;
    781            }  
    782            return Status;
   \                     ??USBH_HandleEnum_1: (+1)
   \   000001A0   0x4620             MOV      R0,R4
   \   000001A2   0xB003             ADD      SP,SP,#+12
   \   000001A4   0xBDF0             POP      {R4-R7,PC}       ;; return
    783          }
    784          
    785          /**
    786            * @brief  USBH_LL_SetTimer 
    787            *         Set the initial Host Timer tick
    788            * @param  phost: Host Handle
    789            * @retval None
    790            */

   \                                 In section .text, align 2, keep-with-next
    791          void  USBH_LL_SetTimer  (USBH_HandleTypeDef *phost, uint32_t time)
    792          {
    793            phost->Timer = time;
   \                     USBH_LL_SetTimer: (+1)
   \   00000000   0xF8C0 0x12A8      STR      R1,[R0, #+680]
    794          }
   \   00000004   0x4770             BX       LR               ;; return
    795          /**
    796            * @brief  USBH_LL_IncTimer 
    797            *         Increment Host Timer tick
    798            * @param  phost: Host Handle
    799            * @retval None
    800            */

   \                                 In section .text, align 2, keep-with-next
    801          void  USBH_LL_IncTimer  (USBH_HandleTypeDef *phost)
    802          {
    803            phost->Timer ++;
   \                     USBH_LL_IncTimer: (+1)
   \   00000000   0xF500 0x7119      ADD      R1,R0,#+612
   \   00000004   0x6C4A             LDR      R2,[R1, #+68]
   \   00000006   0x1C52             ADDS     R2,R2,#+1
   \   00000008   0x644A             STR      R2,[R1, #+68]
    804            USBH_HandleSof(phost);
   \   0000000A   0x7802             LDRB     R2,[R0, #+0]
   \   0000000C   0x2A0A             CMP      R2,#+10
   \   0000000E   0xD104             BNE.N    ??USBH_LL_IncTimer_0
   \   00000010   0x6809             LDR      R1,[R1, #+0]
   \   00000012   0x2900             CMP      R1,#+0
   \   00000014   0xBF1C             ITT      NE 
   \   00000016   0x6989             LDRNE    R1,[R1, #+24]
   \   00000018   0x4708             BXNE     R1
    805          }
   \                     ??USBH_LL_IncTimer_0: (+1)
   \   0000001A   0x4770             BX       LR               ;; return
    806          
    807          /**
    808            * @brief  USBH_HandleSof 
    809            *         Call SOF process
    810            * @param  phost: Host Handle
    811            * @retval None
    812            */
    813          void  USBH_HandleSof  (USBH_HandleTypeDef *phost)
    814          {
    815            if((phost->gState == HOST_CLASS)&&(phost->pActiveClass != NULL))
    816            {
    817              phost->pActiveClass->SOFProcess(phost);
    818            }
    819          }
    820          /**
    821            * @brief  USBH_LL_Connect 
    822            *         Handle USB Host connexion event
    823            * @param  phost: Host Handle
    824            * @retval USBH_Status
    825            */

   \                                 In section .text, align 2, keep-with-next
    826          USBH_StatusTypeDef  USBH_LL_Connect  (USBH_HandleTypeDef *phost)
    827          {
   \                     USBH_LL_Connect: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    828            if(phost->gState == HOST_IDLE )
   \   00000002   0x7801             LDRB     R1,[R0, #+0]
   \   00000004   0xB949             CBNZ.N   R1,??USBH_LL_Connect_0
    829            {
    830              phost->device.is_connected = 1;
   \   00000006   0x2101             MOVS     R1,#+1
   \   00000008   0xF880 0x121E      STRB     R1,[R0, #+542]
    831              
    832              if(phost->pUser != NULL)
   \   0000000C   0xF8D0 0x22B4      LDR      R2,[R0, #+692]
   \   00000010   0x0011             MOVS     R1,R2
   \   00000012   0xD007             BEQ.N    ??USBH_LL_Connect_1
    833              {    
    834                phost->pUser(phost, HOST_USER_CONNECTION);
   \   00000014   0x2104             MOVS     R1,#+4
   \   00000016   0x4790             BLX      R2
   \   00000018   0xE004             B.N      ??USBH_LL_Connect_1
    835              }
    836            } 
    837            else if(phost->gState == HOST_DEV_WAIT_FOR_ATTACHMENT )
   \                     ??USBH_LL_Connect_0: (+1)
   \   0000001A   0x7801             LDRB     R1,[R0, #+0]
   \   0000001C   0x2901             CMP      R1,#+1
   \   0000001E   0xBF04             ITT      EQ 
   \   00000020   0x2102             MOVEQ    R1,#+2
   \   00000022   0x7001             STRBEQ   R1,[R0, #+0]
    838            {
    839              phost->gState = HOST_DEV_ATTACHED ;
    840            }
    841          #if (USBH_USE_OS == 1)
    842            osMessagePut ( phost->os_event, USBH_PORT_EVENT, 0);
    843          #endif 
    844            
    845            return USBH_OK;
   \                     ??USBH_LL_Connect_1: (+1)
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0xBD02             POP      {R1,PC}          ;; return
    846          }
    847          
    848          /**
    849            * @brief  USBH_LL_Disconnect 
    850            *         Handle USB Host disconnection event
    851            * @param  phost: Host Handle
    852            * @retval USBH_Status
    853            */

   \                                 In section .text, align 2, keep-with-next
    854          USBH_StatusTypeDef  USBH_LL_Disconnect  (USBH_HandleTypeDef *phost)
    855          {
   \                     USBH_LL_Disconnect: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    856            /*Stop Host */ 
    857            USBH_LL_Stop(phost);  
   \   00000004   0x.... 0x....      BL       USBH_LL_Stop
    858            
    859            /* FRee Control Pipes */
    860            USBH_FreePipe  (phost, phost->Control.pipe_in);
   \   00000008   0x7921             LDRB     R1,[R4, #+4]
   \   0000000A   0x4620             MOV      R0,R4
   \   0000000C   0x.... 0x....      BL       USBH_FreePipe
    861            USBH_FreePipe  (phost, phost->Control.pipe_out);  
   \   00000010   0x7961             LDRB     R1,[R4, #+5]
   \   00000012   0x4620             MOV      R0,R4
   \   00000014   0x.... 0x....      BL       USBH_FreePipe
    862             
    863            phost->device.is_connected = 0; 
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0xF884 0x021E      STRB     R0,[R4, #+542]
    864             
    865            if(phost->pUser != NULL)
   \   0000001E   0xF8D4 0x22B4      LDR      R2,[R4, #+692]
   \   00000022   0x0010             MOVS     R0,R2
   \   00000024   0xD002             BEQ.N    ??USBH_LL_Disconnect_0
    866            {    
    867              phost->pUser(phost, HOST_USER_DISCONNECTION);
   \   00000026   0x2105             MOVS     R1,#+5
   \   00000028   0x4620             MOV      R0,R4
   \   0000002A   0x4790             BLX      R2
    868            }
    869            USBH_UsrLog("USB Device disconnected"); 
   \                     ??USBH_LL_Disconnect_0: (+1)
   \   0000002C   0x.... 0x....      ADR.W    R0,?_28
   \   00000030   0x.... 0x....      BL       printf
   \   00000034   0x....             ADR.N    R0,??DataTable34  ;; "\n"
   \   00000036   0x.... 0x....      BL       printf
    870            
    871            /* Start the low level driver  */
    872            USBH_LL_Start(phost);
   \   0000003A   0x4620             MOV      R0,R4
   \   0000003C   0x.... 0x....      BL       USBH_LL_Start
    873            
    874            phost->gState = HOST_DEV_DISCONNECTED;
   \   00000040   0x2003             MOVS     R0,#+3
   \   00000042   0x7020             STRB     R0,[R4, #+0]
    875            
    876          #if (USBH_USE_OS == 1)
    877            osMessagePut ( phost->os_event, USBH_PORT_EVENT, 0);
    878          #endif 
    879            
    880            return USBH_OK;
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0xBD10             POP      {R4,PC}          ;; return
    881          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31:
   \   00000000   0x0A 0x00          DC8      "\n",0x0,0x0
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable33:
   \   00000000   0x0A 0x00          DC8      "\n",0x0,0x0
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable34:
   \   00000000   0x0A 0x00          DC8      "\n",0x0,0x0
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ?_0:
   \   00000000   0x45 0x52          DC8 "ERROR: "
   \              0x52 0x4F    
   \              0x52 0x3A    
   \              0x20 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ?_1:
   \   00000000   0x49 0x6E          DC8 "Invalid Host handle"
   \              0x76 0x61    
   \              0x6C 0x69    
   \              0x64 0x20    
   \              0x48 0x6F    
   \              0x73 0x74    
   \              0x20 0x68    
   \              0x61 0x6E    
   \              0x64 0x6C    
   \              0x65 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ?_3:
   \   00000000   0x4D 0x61          DC8 "Max Class Number reached"
   \              0x78 0x20    
   \              0x43 0x6C    
   \              0x61 0x73    
   \              0x73 0x20    
   \              0x4E 0x75    
   \              0x6D 0x62    
   \              0x65 0x72    
   \              0x20 0x72    
   \              0x65 0x61    
   \              0x63 0x68    
   \              0x65 0x64    
   \              0x00         
   \   00000019   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ?_4:
   \   00000000   0x49 0x6E          DC8 "Invalid Class handle"
   \              0x76 0x61    
   \              0x6C 0x69    
   \              0x64 0x20    
   \              0x43 0x6C    
   \              0x61 0x73    
   \              0x73 0x20    
   \              0x68 0x61    
   \              0x6E 0x64    
   \              0x6C 0x65    
   \              0x00         
   \   00000015   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ?_5:
   \   00000000   0x53 0x77          DC8 "Switching to Interface (#%d)"
   \              0x69 0x74    
   \              0x63 0x68    
   \              0x69 0x6E    
   \              0x67 0x20    
   \              0x74 0x6F    
   \              0x20 0x49    
   \              0x6E 0x74    
   \              0x65 0x72    
   \              0x66 0x61    
   \              0x63 0x65    
   \              0x20 0x28    
   \              0x23 0x25    
   \              0x64 0x29    
   \              0x00         
   \   0000001D   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ?_6:
   \   00000000   0x43 0x6C          DC8 "Class    : %xh"
   \              0x61 0x73    
   \              0x73 0x20    
   \              0x20 0x20    
   \              0x20 0x3A    
   \              0x20 0x25    
   \              0x78 0x68    
   \              0x00         
   \   0000000F   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_7:
   \   00000000   0x53 0x75          DC8 "SubClass : %xh"
   \              0x62 0x43    
   \              0x6C 0x61    
   \              0x73 0x73    
   \              0x20 0x3A    
   \              0x20 0x25    
   \              0x78 0x68    
   \              0x00         
   \   0000000F   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_8:
   \   00000000   0x50 0x72          DC8 "Protocol : %xh"
   \              0x6F 0x74    
   \              0x6F 0x63    
   \              0x6F 0x6C    
   \              0x20 0x3A    
   \              0x20 0x25    
   \              0x78 0x68    
   \              0x00         
   \   0000000F   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_9:
   \   00000000   0x43 0x61          DC8 "Cannot Select This Interface."
   \              0x6E 0x6E    
   \              0x6F 0x74    
   \              0x20 0x53    
   \              0x65 0x6C    
   \              0x65 0x63    
   \              0x74 0x20    
   \              0x54 0x68    
   \              0x69 0x73    
   \              0x20 0x49    
   \              0x6E 0x74    
   \              0x65 0x72    
   \              0x66 0x61    
   \              0x63 0x65    
   \              0x2E 0x00    
   \   0000001E   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_10:
   \   00000000   0x55 0x53          DC8 "USB Device Attached"
   \              0x42 0x20    
   \              0x44 0x65    
   \              0x76 0x69    
   \              0x63 0x65    
   \              0x20 0x41    
   \              0x74 0x74    
   \              0x61 0x63    
   \              0x68 0x65    
   \              0x64 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ?_11:
   \   00000000   0x45 0x6E          DC8 "Enumeration done."
   \              0x75 0x6D    
   \              0x65 0x72    
   \              0x61 0x74    
   \              0x69 0x6F    
   \              0x6E 0x20    
   \              0x64 0x6F    
   \              0x6E 0x65    
   \              0x2E 0x00    
   \   00000012   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_12:
   \   00000000   0x54 0x68          DC8 "This device has only 1 configuration."
   \              0x69 0x73    
   \              0x20 0x64    
   \              0x65 0x76    
   \              0x69 0x63    
   \              0x65 0x20    
   \              0x68 0x61    
   \              0x73 0x20    
   \              0x6F 0x6E    
   \              0x6C 0x79    
   \              0x20 0x31    
   \              0x20 0x63    
   \              0x6F 0x6E    
   \              0x66 0x69    
   \              0x67 0x75    
   \              0x72 0x61    
   \              0x74 0x69    
   \              0x6F 0x6E    
   \              0x2E 0x00    
   \   00000026   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_13:
   \   00000000   0x44 0x65          DC8 "Default configuration set."
   \              0x66 0x61    
   \              0x75 0x6C    
   \              0x74 0x20    
   \              0x63 0x6F    
   \              0x6E 0x66    
   \              0x69 0x67    
   \              0x75 0x72    
   \              0x61 0x74    
   \              0x69 0x6F    
   \              0x6E 0x20    
   \              0x73 0x65    
   \              0x74 0x2E    
   \              0x00         
   \   0000001B   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_14:
   \   00000000   0x4E 0x6F          DC8 "No Class has been registered."
   \              0x20 0x43    
   \              0x6C 0x61    
   \              0x73 0x73    
   \              0x20 0x68    
   \              0x61 0x73    
   \              0x20 0x62    
   \              0x65 0x65    
   \              0x6E 0x20    
   \              0x72 0x65    
   \              0x67 0x69    
   \              0x73 0x74    
   \              0x65 0x72    
   \              0x65 0x64    
   \              0x2E 0x00    
   \   0000001E   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_15:
   \   00000000   0x25 0x73          DC8 "%s class started."
   \              0x20 0x63    
   \              0x6C 0x61    
   \              0x73 0x73    
   \              0x20 0x73    
   \              0x74 0x61    
   \              0x72 0x74    
   \              0x65 0x64    
   \              0x2E 0x00    
   \   00000012   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_16:
   \   00000000   0x44 0x65          DC8 "Device not supporting %s class."
   \              0x76 0x69    
   \              0x63 0x65    
   \              0x20 0x6E    
   \              0x6F 0x74    
   \              0x20 0x73    
   \              0x75 0x70    
   \              0x70 0x6F    
   \              0x72 0x74    
   \              0x69 0x6E    
   \              0x67 0x20    
   \              0x25 0x73    
   \              0x20 0x63    
   \              0x6C 0x61    
   \              0x73 0x73    
   \              0x2E 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ?_17:
   \   00000000   0x4E 0x6F          DC8 "No registered class for this device."
   \              0x20 0x72    
   \              0x65 0x67    
   \              0x69 0x73    
   \              0x74 0x65    
   \              0x72 0x65    
   \              0x64 0x20    
   \              0x63 0x6C    
   \              0x61 0x73    
   \              0x73 0x20    
   \              0x66 0x6F    
   \              0x72 0x20    
   \              0x74 0x68    
   \              0x69 0x73    
   \              0x20 0x64    
   \              0x65 0x76    
   \              0x69 0x63    
   \              0x65 0x2E    
   \              0x00         
   \   00000025   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ?_18:
   \   00000000   0x49 0x6E          DC8 "Invalid Class Driver."
   \              0x76 0x61    
   \              0x6C 0x69    
   \              0x64 0x20    
   \              0x43 0x6C    
   \              0x61 0x73    
   \              0x73 0x20    
   \              0x44 0x72    
   \              0x69 0x76    
   \              0x65 0x72    
   \              0x2E 0x00    
   \   00000016   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_19:
   \   00000000   0x50 0x49          DC8 "PID: %xh"
   \              0x44 0x3A    
   \              0x20 0x25    
   \              0x78 0x68    
   \              0x00         
   \   00000009   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ?_20:
   \   00000000   0x56 0x49          DC8 "VID: %xh"
   \              0x44 0x3A    
   \              0x20 0x25    
   \              0x78 0x68    
   \              0x00         
   \   00000009   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ?_21:
   \   00000000   0x41 0x64          DC8 "Address (#%d) assigned."
   \              0x64 0x72    
   \              0x65 0x73    
   \              0x73 0x20    
   \              0x28 0x23    
   \              0x25 0x64    
   \              0x29 0x20    
   \              0x61 0x73    
   \              0x73 0x69    
   \              0x67 0x6E    
   \              0x65 0x64    
   \              0x2E 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ?_22:
   \   00000000   0x4D 0x61          DC8 "Manufacturer : %s"
   \              0x6E 0x75    
   \              0x66 0x61    
   \              0x63 0x74    
   \              0x75 0x72    
   \              0x65 0x72    
   \              0x20 0x3A    
   \              0x20 0x25    
   \              0x73 0x00    
   \   00000012   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_23:
   \   00000000   0x4D 0x61          DC8 "Manufacturer : N/A"
   \              0x6E 0x75    
   \              0x66 0x61    
   \              0x63 0x74    
   \              0x75 0x72    
   \              0x65 0x72    
   \              0x20 0x3A    
   \              0x20 0x4E    
   \              0x2F 0x41    
   \              0x00         
   \   00000013   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_24:
   \   00000000   0x50 0x72          DC8 "Product : %s"
   \              0x6F 0x64    
   \              0x75 0x63    
   \              0x74 0x20    
   \              0x3A 0x20    
   \              0x25 0x73    
   \              0x00         
   \   0000000D   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ?_25:
   \   00000000   0x50 0x72          DC8 "Product : N/A"
   \              0x6F 0x64    
   \              0x75 0x63    
   \              0x74 0x20    
   \              0x3A 0x20    
   \              0x4E 0x2F    
   \              0x41 0x00    
   \   0000000E   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_26:
   \   00000000   0x53 0x65          DC8 "Serial Number : %s"
   \              0x72 0x69    
   \              0x61 0x6C    
   \              0x20 0x4E    
   \              0x75 0x6D    
   \              0x62 0x65    
   \              0x72 0x20    
   \              0x3A 0x20    
   \              0x25 0x73    
   \              0x00         
   \   00000013   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_27:
   \   00000000   0x53 0x65          DC8 "Serial Number : N/A"
   \              0x72 0x69    
   \              0x61 0x6C    
   \              0x20 0x4E    
   \              0x75 0x6D    
   \              0x62 0x65    
   \              0x72 0x20    
   \              0x3A 0x20    
   \              0x4E 0x2F    
   \              0x41 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ?_28:
   \   00000000   0x55 0x53          DC8 "USB Device disconnected"
   \              0x42 0x20    
   \              0x44 0x65    
   \              0x76 0x69    
   \              0x63 0x65    
   \              0x20 0x64    
   \              0x69 0x73    
   \              0x63 0x6F    
   \              0x6E 0x6E    
   \              0x65 0x63    
   \              0x74 0x65    
   \              0x64 0x00    

   \                                 In section .rodata, align 2, keep-with-next
   \                     ?_2:
   \   00000000   0x0A 0x00          DC8 "\012"
    882          
    883          
    884          #if (USBH_USE_OS == 1)  
    885          /**
    886            * @brief  USB Host Thread task
    887            * @param  pvParameters not used
    888            * @retval None
    889            */
    890          static void USBH_Process_OS(void const * argument)
    891          {
    892            osEvent event;
    893            
    894            for(;;)
    895            {
    896              event = osMessageGet(((USBH_HandleTypeDef *)argument)->os_event, osWaitForever );
    897              
    898              if( event.status == osEventMessage )
    899              {
    900                USBH_Process((USBH_HandleTypeDef *)argument);
    901              }
    902             }
    903          }
    904          
    905          /**
    906          * @brief  USBH_LL_NotifyURBChange 
    907          *         Notify URB state Change
    908          * @param  phost: Host handle
    909          * @retval USBH Status
    910          */
    911          USBH_StatusTypeDef  USBH_LL_NotifyURBChange (USBH_HandleTypeDef *phost)
    912          {
    913            osMessagePut ( phost->os_event, USBH_URB_EVENT, 0);
    914            return USBH_OK;
    915          }
    916          #endif  
    917          /**
    918            * @}
    919            */ 
    920          
    921          /**
    922            * @}
    923            */ 
    924          
    925          /**
    926            * @}
    927            */
    928          
    929          /**
    930            * @}
    931            */ 
    932          
    933          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   DeInitStateMachine
         8   -> __aeabi_memclr4
       8   USBH_DeInit
         8   -> DeInitStateMachine
         8   -> USBH_LL_Stop
       8   USBH_FindInterface
       0   USBH_FindInterfaceIndex
       0   USBH_GetActiveClass
      32   USBH_HandleEnum
        32   -> USBH_Delay
        32   -> USBH_Get_CfgDesc
        32   -> USBH_Get_DevDesc
        32   -> USBH_Get_StringDesc
        32   -> USBH_OpenPipe
        32   -> USBH_SetAddress
        32   -> printf
      16   USBH_Init
        16   -> DeInitStateMachine
        16   -> USBH_LL_Init
        16   -> printf
       8   USBH_LL_Connect
         8   -- Indirect call
       8   USBH_LL_Disconnect
         8   -- Indirect call
         8   -> USBH_FreePipe
         8   -> USBH_LL_Start
         8   -> USBH_LL_Stop
         8   -> printf
       0   USBH_LL_IncTimer
         0   -- Indirect call
       0   USBH_LL_SetTimer
      32   USBH_Process
        32   -- Indirect call
        32   -> DeInitStateMachine
        32   -> USBH_AllocPipe
        32   -> USBH_Delay
        32   -> USBH_HandleEnum
        32   -> USBH_LL_GetSpeed
        32   -> USBH_LL_ResetPort
        32   -> USBH_OpenPipe
        32   -> USBH_SetCfg
        32   -> printf
       8   USBH_ReEnumerate
         8   -> DeInitStateMachine
         8   -> USBH_Delay
         8   -> USBH_LL_DriverVBUS
         8   -> USBH_LL_Start
         8   -> USBH_Stop
       8   USBH_RegisterClass
         8   -> printf
      24   USBH_SelectInterface
        24   -> printf
       8   USBH_Start
         8   -> USBH_LL_DriverVBUS
         8   -> USBH_LL_Start
       8   USBH_Stop
         8   -> USBH_FreePipe
         8   -> USBH_LL_DriverVBUS
         8   -> USBH_LL_Stop


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable31
       4  ??DataTable33
       4  ??DataTable34
      16  ?Subroutine0
       8  ?_0
      20  ?_1
      20  ?_10
      20  ?_11
      40  ?_12
      28  ?_13
      32  ?_14
      20  ?_15
      32  ?_16
      40  ?_17
      24  ?_18
      12  ?_19
       2  ?_2
      12  ?_20
      24  ?_21
      20  ?_22
      20  ?_23
      16  ?_24
      16  ?_25
      20  ?_26
      20  ?_27
      24  ?_28
      28  ?_3
      24  ?_4
      32  ?_5
      16  ?_6
      16  ?_7
      16  ?_8
      32  ?_9
      70  DeInitStateMachine
      32  USBH_DeInit
      66  USBH_FindInterface
      40  USBH_FindInterfaceIndex
       6  USBH_GetActiveClass
     422  USBH_HandleEnum
      72  USBH_Init
      40  USBH_LL_Connect
      72  USBH_LL_Disconnect
      28  USBH_LL_IncTimer
       6  USBH_LL_SetTimer
     492  USBH_Process
      22  USBH_ReEnumerate
      66  USBH_RegisterClass
     128  USBH_SelectInterface
       6  USBH_Start
      36  USBH_Stop

 
     2 bytes in section .rodata
 2 264 bytes in section .text
 
 2 264 bytes of CODE  memory
     2 bytes of CONST memory

Errors: none
Warnings: none
