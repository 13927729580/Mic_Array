###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.2.10312/W32 for ARM       25/Feb/2016  15:20:40
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Middlewares\ST\STM32_USB_Host_Library\Core\Src\usbh_core.c
#    Command line =  
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Middlewares\ST\STM32_USB_Host_Library\Core\Src\usbh_core.c
#        -D USE_HAL_DRIVER -D STM32F746xx -D USE_STM32746G_DISCO -D
#        USE_IOEXPANDER -D USE_USB_FS -lC
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
#        -lA
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
#        -o
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M7 -e --fpu=VFPv5_sp --dlib_config "D:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.3\arm\INC\c\DLib_Config_Full.h"
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\CMSIS\Device\ST\STM32F7xx\Include\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\STM32F7xx_HAL_Driver\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\STM32746G-Discovery\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\Components\Common\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Log\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Fonts\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\CPU\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_Device_Library\Core\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Core\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Class\MSC\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\drivers\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_Audio\Addons\PDM\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_Device_Library\Class\AUDIO\Inc\
#        -On --use_c++_inline --require_prototypes -I "D:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.3\arm\CMSIS\Include\" -D
#        ARM_MATH_CM7
#    List file    =  
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List\usbh_core.lst
#    Object file  =  
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj\usbh_core.o
#
###############################################################################

D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Middlewares\ST\STM32_USB_Host_Library\Core\Src\usbh_core.c
      1          /**
      2            ******************************************************************************
      3            * @file    usbh_core.c 
      4            * @author  MCD Application Team
      5            * @version V3.2.1
      6            * @date    26-June-2015
      7            * @brief   This file implements the functions for the core state machine process
      8            *          the enumeration and the control transfer process
      9            ******************************************************************************
     10            * @attention
     11            *
     12            * <h2><center>&copy; COPYRIGHT 2015 STMicroelectronics</center></h2>
     13            *
     14            * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
     15            * You may not use this file except in compliance with the License.
     16            * You may obtain a copy of the License at:
     17            *
     18            *        http://www.st.com/software_license_agreement_liberty_v2
     19            *
     20            * Unless required by applicable law or agreed to in writing, software 
     21            * distributed under the License is distributed on an "AS IS" BASIS, 
     22            * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     23            * See the License for the specific language governing permissions and
     24            * limitations under the License.
     25            *
     26            ******************************************************************************
     27            */ 
     28          /* Includes ------------------------------------------------------------------*/
     29          
     30          #include "usbh_core.h"
     31          
     32          
     33          /** @addtogroup USBH_LIB
     34            * @{
     35            */
     36          
     37          /** @addtogroup USBH_LIB_CORE
     38            * @{
     39            */
     40          
     41          /** @defgroup USBH_CORE 
     42            * @brief This file handles the basic enumeration when a device is connected 
     43            *          to the host.
     44            * @{
     45            */ 
     46          
     47          
     48          /** @defgroup USBH_CORE_Private_Defines
     49            * @{
     50            */ 
     51          #define USBH_ADDRESS_DEFAULT                     0
     52          #define USBH_ADDRESS_ASSIGNED                    1      
     53          #define USBH_MPS_DEFAULT                         0x40
     54          /**
     55            * @}
     56            */ 
     57          
     58          /** @defgroup USBH_CORE_Private_Macros
     59            * @{
     60            */ 
     61          /**
     62            * @}
     63            */ 
     64          
     65          
     66          /** @defgroup USBH_CORE_Private_Variables
     67            * @{
     68            */ 
     69          /**
     70            * @}
     71            */ 
     72           
     73          
     74          /** @defgroup USBH_CORE_Private_Functions
     75            * @{
     76            */ 
     77          static USBH_StatusTypeDef  USBH_HandleEnum    (USBH_HandleTypeDef *phost);
     78          static void                USBH_HandleSof     (USBH_HandleTypeDef *phost);
     79          static USBH_StatusTypeDef  DeInitStateMachine(USBH_HandleTypeDef *phost);
     80          
     81          #if (USBH_USE_OS == 1)  
     82          static void USBH_Process_OS(void const * argument);
     83          #endif
     84          
     85          /**
     86            * @brief  HCD_Init 
     87            *         Initialize the HOST Core.
     88            * @param  phost: Host Handle
     89            * @param  pUsrFunc: User Callback
     90            * @retval USBH Status
     91            */

   \                                 In section .text, align 2, keep-with-next
     92          USBH_StatusTypeDef  USBH_Init(USBH_HandleTypeDef *phost, void (*pUsrFunc)(USBH_HandleTypeDef *phost, uint8_t ), uint8_t id)
     93          {
   \                     USBH_Init: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
     94            /* Check whether the USB Host handle is valid */
     95            if(phost == NULL)
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD10C             BNE.N    ??USBH_Init_0
     96            {
     97              USBH_ErrLog("Invalid Host handle");
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable5_1
   \   00000010   0x.... 0x....      BL       printf
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable5_2
   \   00000018   0x.... 0x....      BL       printf
   \   0000001C   0x....             ADR.N    R0,??DataTable2  ;; "\n"
   \   0000001E   0x.... 0x....      BL       printf
     98              return USBH_FAIL; 
   \   00000022   0x2002             MOVS     R0,#+2
   \   00000024   0xE013             B.N      ??USBH_Init_1
     99            }
    100            
    101            /* Set DRiver ID */
    102            phost->id = id;
   \                     ??USBH_Init_0: (+1)
   \   00000026   0xF884 0x62AC      STRB     R6,[R4, #+684]
    103            
    104            /* Unlink class*/
    105            phost->pActiveClass = NULL;
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0xF8C4 0x0264      STR      R0,[R4, #+612]
    106            phost->ClassNumber = 0;
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0xF8C4 0x0268      STR      R0,[R4, #+616]
    107            
    108            /* Restore default states and prepare EP0 */ 
    109            DeInitStateMachine(phost);
   \   00000036   0x0020             MOVS     R0,R4
   \   00000038   0x.... 0x....      BL       DeInitStateMachine
    110            
    111            /* Assign User process */
    112            if(pUsrFunc != NULL)
   \   0000003C   0x0028             MOVS     R0,R5
   \   0000003E   0x2800             CMP      R0,#+0
   \   00000040   0xD001             BEQ.N    ??USBH_Init_2
    113            {
    114              phost->pUser = pUsrFunc;
   \   00000042   0xF8C4 0x52B4      STR      R5,[R4, #+692]
    115            }
    116            
    117          #if (USBH_USE_OS == 1) 
    118            
    119            /* Create USB Host Queue */
    120            osMessageQDef(USBH_Queue, 10, uint16_t);
    121            phost->os_event = osMessageCreate (osMessageQ(USBH_Queue), NULL); 
    122            
    123            /*Create USB Host Task */
    124          #if defined (USBH_PROCESS_STACK_SIZE)
    125            osThreadDef(USBH_Thread, USBH_Process_OS, USBH_PROCESS_PRIO, 0, USBH_PROCESS_STACK_SIZE);
    126          #else
    127            osThreadDef(USBH_Thread, USBH_Process_OS, USBH_PROCESS_PRIO, 0, 8 * configMINIMAL_STACK_SIZE);
    128          #endif  
    129            phost->thread = osThreadCreate (osThread(USBH_Thread), phost);
    130          #endif  
    131            
    132            /* Initialize low level driver */
    133            USBH_LL_Init(phost);
   \                     ??USBH_Init_2: (+1)
   \   00000046   0x0020             MOVS     R0,R4
   \   00000048   0x.... 0x....      BL       USBH_LL_Init
    134            return USBH_OK;
   \   0000004C   0x2000             MOVS     R0,#+0
   \                     ??USBH_Init_1: (+1)
   \   0000004E   0xBD70             POP      {R4-R6,PC}       ;; return
    135          }
    136          
    137          /**
    138            * @brief  HCD_Init 
    139            *         De-Initialize the Host portion of the driver.
    140            * @param  phost: Host Handle
    141            * @retval USBH Status
    142            */

   \                                 In section .text, align 2, keep-with-next
    143          USBH_StatusTypeDef  USBH_DeInit(USBH_HandleTypeDef *phost)
    144          {
   \                     USBH_DeInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    145            DeInitStateMachine(phost);
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0x.... 0x....      BL       DeInitStateMachine
    146            
    147            if(phost->pData != NULL)
   \   0000000A   0xF8D4 0x02B0      LDR      R0,[R4, #+688]
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD006             BEQ.N    ??USBH_DeInit_0
    148            {
    149              phost->pActiveClass->pData = NULL;
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0xF8D4 0x1264      LDR      R1,[R4, #+612]
   \   00000018   0x61C8             STR      R0,[R1, #+28]
    150              USBH_LL_Stop(phost);
   \   0000001A   0x0020             MOVS     R0,R4
   \   0000001C   0x.... 0x....      BL       USBH_LL_Stop
    151            }
    152          
    153            return USBH_OK;
   \                     ??USBH_DeInit_0: (+1)
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0xBD10             POP      {R4,PC}          ;; return
    154          }
    155          
    156          /**
    157            * @brief  DeInitStateMachine 
    158            *         De-Initialize the Host state machine.
    159            * @param  phost: Host Handle
    160            * @retval USBH Status
    161            */

   \                                 In section .text, align 2, keep-with-next
    162          static USBH_StatusTypeDef  DeInitStateMachine(USBH_HandleTypeDef *phost)
    163          {
   \                     DeInitStateMachine: (+1)
   \   00000000   0x0001             MOVS     R1,R0
    164            uint32_t i = 0;
   \   00000002   0x2200             MOVS     R2,#+0
    165          
    166            /* Clear Pipes flags*/
    167            for ( ; i < USBH_MAX_PIPES_NBR; i++)
   \                     ??DeInitStateMachine_0: (+1)
   \   00000004   0x2A0F             CMP      R2,#+15
   \   00000006   0xD206             BCS.N    ??DeInitStateMachine_1
    168            {
    169              phost->Pipes[i] = 0;
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0xEB11 0x0382      ADDS     R3,R1,R2, LSL #+2
   \   0000000E   0xF8C3 0x026C      STR      R0,[R3, #+620]
    170            }
   \   00000012   0x1C52             ADDS     R2,R2,#+1
   \   00000014   0xE7F6             B.N      ??DeInitStateMachine_0
    171            
    172            for(i = 0; i< USBH_MAX_DATA_BUFFER; i++)
   \                     ??DeInitStateMachine_1: (+1)
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0x0002             MOVS     R2,R0
   \                     ??DeInitStateMachine_2: (+1)
   \   0000001A   0xF5B2 0x7F00      CMP      R2,#+512
   \   0000001E   0xD204             BCS.N    ??DeInitStateMachine_3
    173            {
    174              phost->device.Data[i] = 0;
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0x1853             ADDS     R3,R2,R1
   \   00000024   0x7718             STRB     R0,[R3, #+28]
    175            }
   \   00000026   0x1C52             ADDS     R2,R2,#+1
   \   00000028   0xE7F7             B.N      ??DeInitStateMachine_2
    176            
    177            phost->gState = HOST_IDLE;
   \                     ??DeInitStateMachine_3: (+1)
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0x7008             STRB     R0,[R1, #+0]
    178            phost->EnumState = ENUM_IDLE;
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0x7048             STRB     R0,[R1, #+1]
    179            phost->RequestState = CMD_SEND;
   \   00000032   0x2001             MOVS     R0,#+1
   \   00000034   0x7088             STRB     R0,[R1, #+2]
    180            phost->Timer = 0;  
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0xF8C1 0x02A8      STR      R0,[R1, #+680]
    181            
    182            phost->Control.state = CTRL_SETUP;
   \   0000003C   0x2001             MOVS     R0,#+1
   \   0000003E   0x7608             STRB     R0,[R1, #+24]
    183            phost->Control.pipe_size = USBH_MPS_DEFAULT;  
   \   00000040   0x2040             MOVS     R0,#+64
   \   00000042   0x7188             STRB     R0,[R1, #+6]
    184            phost->Control.errorcount = 0;
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0x7648             STRB     R0,[R1, #+25]
    185            
    186            phost->device.address = USBH_ADDRESS_DEFAULT;
   \   00000048   0x2000             MOVS     R0,#+0
   \   0000004A   0xF881 0x021C      STRB     R0,[R1, #+540]
    187            phost->device.speed   = USBH_SPEED_FULL;
   \   0000004E   0x2001             MOVS     R0,#+1
   \   00000050   0xF881 0x021D      STRB     R0,[R1, #+541]
    188            
    189            return USBH_OK;
   \   00000054   0x2000             MOVS     R0,#+0
   \   00000056   0x4770             BX       LR               ;; return
    190          }
    191          
    192          /**
    193            * @brief  USBH_RegisterClass 
    194            *         Link class driver to Host Core.
    195            * @param  phost : Host Handle
    196            * @param  pclass: Class handle
    197            * @retval USBH Status
    198            */

   \                                 In section .text, align 2, keep-with-next
    199          USBH_StatusTypeDef  USBH_RegisterClass(USBH_HandleTypeDef *phost, USBH_ClassTypeDef *pclass)
    200          {
   \                     USBH_RegisterClass: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    201            USBH_StatusTypeDef   status = USBH_OK;
   \   00000006   0x2600             MOVS     R6,#+0
    202            
    203            if(pclass != 0)
   \   00000008   0x2D00             CMP      R5,#+0
   \   0000000A   0xD01D             BEQ.N    ??USBH_RegisterClass_0
    204            {
    205              if(phost->ClassNumber < USBH_MAX_NUM_SUPPORTED_CLASS)
   \   0000000C   0xF8D4 0x0268      LDR      R0,[R4, #+616]
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD10B             BNE.N    ??USBH_RegisterClass_1
    206              {
    207                /* link the class to the USB Host handle */
    208                phost->pClass[phost->ClassNumber++] = pclass;
   \   00000014   0xF8D4 0x0268      LDR      R0,[R4, #+616]
   \   00000018   0x1C41             ADDS     R1,R0,#+1
   \   0000001A   0xF8C4 0x1268      STR      R1,[R4, #+616]
   \   0000001E   0xEB14 0x0080      ADDS     R0,R4,R0, LSL #+2
   \   00000022   0xF8C0 0x5260      STR      R5,[R0, #+608]
    209                status = USBH_OK;
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0x0006             MOVS     R6,R0
   \   0000002A   0xE01A             B.N      ??USBH_RegisterClass_2
    210              }
    211              else
    212              {
    213                USBH_ErrLog("Max Class Number reached");
   \                     ??USBH_RegisterClass_1: (+1)
   \   0000002C   0x.... 0x....      LDR.W    R0,??DataTable5_1
   \   00000030   0x.... 0x....      BL       printf
   \   00000034   0x.... 0x....      LDR.W    R0,??DataTable5_3
   \   00000038   0x.... 0x....      BL       printf
   \   0000003C   0x....             ADR.N    R0,??DataTable2  ;; "\n"
   \   0000003E   0x.... 0x....      BL       printf
    214                status = USBH_FAIL; 
   \   00000042   0x2002             MOVS     R0,#+2
   \   00000044   0x0006             MOVS     R6,R0
   \   00000046   0xE00C             B.N      ??USBH_RegisterClass_2
    215              }
    216            }
    217            else
    218            {
    219              USBH_ErrLog("Invalid Class handle");
   \                     ??USBH_RegisterClass_0: (+1)
   \   00000048   0x.... 0x....      LDR.W    R0,??DataTable5_1
   \   0000004C   0x.... 0x....      BL       printf
   \   00000050   0x.... 0x....      LDR.W    R0,??DataTable5_4
   \   00000054   0x.... 0x....      BL       printf
   \   00000058   0x....             ADR.N    R0,??DataTable2  ;; "\n"
   \   0000005A   0x.... 0x....      BL       printf
    220              status = USBH_FAIL; 
   \   0000005E   0x2002             MOVS     R0,#+2
   \   00000060   0x0006             MOVS     R6,R0
    221            }
    222            
    223            return status;
   \                     ??USBH_RegisterClass_2: (+1)
   \   00000062   0x0030             MOVS     R0,R6
   \   00000064   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000066   0xBD70             POP      {R4-R6,PC}       ;; return
    224          }
    225          
    226          /**
    227            * @brief  USBH_SelectInterface 
    228            *         Select current interface.
    229            * @param  phost: Host Handle
    230            * @param  interface: Interface number
    231            * @retval USBH Status
    232            */

   \                                 In section .text, align 2, keep-with-next
    233          USBH_StatusTypeDef USBH_SelectInterface(USBH_HandleTypeDef *phost, uint8_t interface)
    234          {
   \                     USBH_SelectInterface: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    235            USBH_StatusTypeDef   status = USBH_OK;
   \   00000006   0x2600             MOVS     R6,#+0
    236            
    237            if(interface < phost->device.CfgDesc.bNumInterfaces)
   \   00000008   0xF894 0x0236      LDRB     R0,[R4, #+566]
   \   0000000C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000000E   0x4285             CMP      R5,R0
   \   00000010   0xD232             BCS.N    ??USBH_SelectInterface_0
    238            {
    239              phost->device.current_interface = interface;
   \   00000012   0xF884 0x521F      STRB     R5,[R4, #+543]
    240              USBH_UsrLog ("Switching to Interface (#%d)", interface);
   \   00000016   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000018   0x0029             MOVS     R1,R5
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable5_5
   \   0000001E   0x.... 0x....      BL       printf
   \   00000022   0x....             ADR.N    R0,??DataTable2  ;; "\n"
   \   00000024   0x.... 0x....      BL       printf
    241              USBH_UsrLog ("Class    : %xh", phost->device.CfgDesc.Itf_Desc[interface].bInterfaceClass );
   \   00000028   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000002A   0x2022             MOVS     R0,#+34
   \   0000002C   0xFB00 0x4005      MLA      R0,R0,R5,R4
   \   00000030   0xF890 0x1241      LDRB     R1,[R0, #+577]
   \   00000034   0x.... 0x....      LDR.W    R0,??DataTable5_6
   \   00000038   0x.... 0x....      BL       printf
   \   0000003C   0x....             ADR.N    R0,??DataTable2  ;; "\n"
   \   0000003E   0x.... 0x....      BL       printf
    242              USBH_UsrLog ("SubClass : %xh", phost->device.CfgDesc.Itf_Desc[interface].bInterfaceSubClass );
   \   00000042   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000044   0x2022             MOVS     R0,#+34
   \   00000046   0xFB00 0x4005      MLA      R0,R0,R5,R4
   \   0000004A   0xF890 0x1242      LDRB     R1,[R0, #+578]
   \   0000004E   0x.... 0x....      LDR.W    R0,??DataTable5_7
   \   00000052   0x.... 0x....      BL       printf
   \   00000056   0x....             ADR.N    R0,??DataTable2  ;; "\n"
   \   00000058   0x.... 0x....      BL       printf
    243              USBH_UsrLog ("Protocol : %xh", phost->device.CfgDesc.Itf_Desc[interface].bInterfaceProtocol );                 
   \   0000005C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000005E   0x2022             MOVS     R0,#+34
   \   00000060   0xFB00 0x4005      MLA      R0,R0,R5,R4
   \   00000064   0xF890 0x1243      LDRB     R1,[R0, #+579]
   \   00000068   0x.... 0x....      LDR.W    R0,??DataTable5_8
   \   0000006C   0x.... 0x....      BL       printf
   \   00000070   0x....             ADR.N    R0,??DataTable2  ;; "\n"
   \   00000072   0x.... 0x....      BL       printf
   \   00000076   0xE00C             B.N      ??USBH_SelectInterface_1
    244            }
    245            else
    246            {
    247              USBH_ErrLog ("Cannot Select This Interface.");
   \                     ??USBH_SelectInterface_0: (+1)
   \   00000078   0x.... 0x....      LDR.W    R0,??DataTable5_1
   \   0000007C   0x.... 0x....      BL       printf
   \   00000080   0x.... 0x....      LDR.W    R0,??DataTable5_9
   \   00000084   0x.... 0x....      BL       printf
   \   00000088   0x....             ADR.N    R0,??DataTable2  ;; "\n"
   \   0000008A   0x.... 0x....      BL       printf
    248              status = USBH_FAIL; 
   \   0000008E   0x2002             MOVS     R0,#+2
   \   00000090   0x0006             MOVS     R6,R0
    249            }
    250            return status;  
   \                     ??USBH_SelectInterface_1: (+1)
   \   00000092   0x0030             MOVS     R0,R6
   \   00000094   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000096   0xBD70             POP      {R4-R6,PC}       ;; return
    251          }
    252          
    253          /**
    254            * @brief  USBH_GetActiveClass 
    255            *         Return Device Class.
    256            * @param  phost: Host Handle
    257            * @param  interface: Interface index
    258            * @retval Class Code
    259            */

   \                                 In section .text, align 2, keep-with-next
    260          uint8_t USBH_GetActiveClass(USBH_HandleTypeDef *phost)
    261          {
    262             return (phost->device.CfgDesc.Itf_Desc[0].bInterfaceClass);            
   \                     USBH_GetActiveClass: (+1)
   \   00000000   0xF890 0x0241      LDRB     R0,[R0, #+577]
   \   00000004   0x4770             BX       LR               ;; return
    263          }
    264          /**
    265            * @brief  USBH_FindInterface 
    266            *         Find the interface index for a specific class.
    267            * @param  phost: Host Handle
    268            * @param  Class: Class code
    269            * @param  SubClass: SubClass code
    270            * @param  Protocol: Protocol code
    271            * @retval interface index in the configuration structure
    272            * @note : (1)interface index 0xFF means interface index not found
    273            */

   \                                 In section .text, align 2, keep-with-next
    274          uint8_t  USBH_FindInterface(USBH_HandleTypeDef *phost, uint8_t Class, uint8_t SubClass, uint8_t Protocol)
    275          {
   \                     USBH_FindInterface: (+1)
   \   00000000   0xB4F0             PUSH     {R4-R7}
   \   00000002   0x0004             MOVS     R4,R0
    276            USBH_InterfaceDescTypeDef    *pif ;
    277            USBH_CfgDescTypeDef          *pcfg ;
    278            int8_t                        if_ix = 0;
   \   00000004   0x2700             MOVS     R7,#+0
    279            
    280            pif = (USBH_InterfaceDescTypeDef *)0;
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x0005             MOVS     R5,R0
    281            pcfg = &phost->device.CfgDesc;  
   \   0000000A   0xF204 0x2032      ADDW     R0,R4,#+562
   \   0000000E   0x0006             MOVS     R6,R0
    282            
    283            while (if_ix < USBH_MAX_NUM_INTERFACES)
   \                     ??USBH_FindInterface_0: (+1)
   \   00000010   0xB27F             SXTB     R7,R7            ;; SignExt  R7,R7,#+24,#+24
   \   00000012   0x2F01             CMP      R7,#+1
   \   00000014   0xDA1F             BGE.N    ??USBH_FindInterface_1
    284            {
    285              pif = &pcfg->Itf_Desc[if_ix];
   \   00000016   0xB27F             SXTB     R7,R7            ;; SignExt  R7,R7,#+24,#+24
   \   00000018   0x2022             MOVS     R0,#+34
   \   0000001A   0xFB17 0x6000      SMLABB   R0,R7,R0,R6
   \   0000001E   0x300A             ADDS     R0,R0,#+10
   \   00000020   0x0005             MOVS     R5,R0
    286              if(((pif->bInterfaceClass == Class) || (Class == 0xFF))&&
    287                 ((pif->bInterfaceSubClass == SubClass) || (SubClass == 0xFF))&&
    288                   ((pif->bInterfaceProtocol == Protocol) || (Protocol == 0xFF)))
   \   00000022   0x7968             LDRB     R0,[R5, #+5]
   \   00000024   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000026   0x4288             CMP      R0,R1
   \   00000028   0xD002             BEQ.N    ??USBH_FindInterface_2
   \   0000002A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000002C   0x29FF             CMP      R1,#+255
   \   0000002E   0xD110             BNE.N    ??USBH_FindInterface_3
   \                     ??USBH_FindInterface_2: (+1)
   \   00000030   0x79A8             LDRB     R0,[R5, #+6]
   \   00000032   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000034   0x4290             CMP      R0,R2
   \   00000036   0xD002             BEQ.N    ??USBH_FindInterface_4
   \   00000038   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000003A   0x2AFF             CMP      R2,#+255
   \   0000003C   0xD109             BNE.N    ??USBH_FindInterface_3
   \                     ??USBH_FindInterface_4: (+1)
   \   0000003E   0x79E8             LDRB     R0,[R5, #+7]
   \   00000040   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000042   0x4298             CMP      R0,R3
   \   00000044   0xD002             BEQ.N    ??USBH_FindInterface_5
   \   00000046   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000048   0x2BFF             CMP      R3,#+255
   \   0000004A   0xD102             BNE.N    ??USBH_FindInterface_3
    289              {
    290                return  if_ix;
   \                     ??USBH_FindInterface_5: (+1)
   \   0000004C   0x0038             MOVS     R0,R7
   \   0000004E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000050   0xE002             B.N      ??USBH_FindInterface_6
    291              }
    292              if_ix++;
   \                     ??USBH_FindInterface_3: (+1)
   \   00000052   0x1C7F             ADDS     R7,R7,#+1
   \   00000054   0xE7DC             B.N      ??USBH_FindInterface_0
    293            }
    294            return 0xFF;
   \                     ??USBH_FindInterface_1: (+1)
   \   00000056   0x20FF             MOVS     R0,#+255
   \                     ??USBH_FindInterface_6: (+1)
   \   00000058   0xBCF0             POP      {R4-R7}
   \   0000005A   0x4770             BX       LR               ;; return
    295          }
    296          
    297          /**
    298            * @brief  USBH_FindInterfaceIndex 
    299            *         Find the interface index for a specific class interface and alternate setting number.
    300            * @param  phost: Host Handle
    301            * @param  interface_number: interface number
    302            * @param  alt_settings    : alternate setting number
    303            * @retval interface index in the configuration structure
    304            * @note : (1)interface index 0xFF means interface index not found
    305            */

   \                                 In section .text, align 2, keep-with-next
    306          uint8_t  USBH_FindInterfaceIndex(USBH_HandleTypeDef *phost, uint8_t interface_number, uint8_t alt_settings)
    307          {
   \                     USBH_FindInterfaceIndex: (+1)
   \   00000000   0xB470             PUSH     {R4-R6}
   \   00000002   0x0003             MOVS     R3,R0
    308            USBH_InterfaceDescTypeDef    *pif ;
    309            USBH_CfgDescTypeDef          *pcfg ;
    310            int8_t                        if_ix = 0;
   \   00000004   0x2600             MOVS     R6,#+0
    311            
    312            pif = (USBH_InterfaceDescTypeDef *)0;
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x0004             MOVS     R4,R0
    313            pcfg = &phost->device.CfgDesc;  
   \   0000000A   0xF203 0x2032      ADDW     R0,R3,#+562
   \   0000000E   0x0005             MOVS     R5,R0
    314            
    315            while (if_ix < USBH_MAX_NUM_INTERFACES)
   \                     ??USBH_FindInterfaceIndex_0: (+1)
   \   00000010   0xB276             SXTB     R6,R6            ;; SignExt  R6,R6,#+24,#+24
   \   00000012   0x2E01             CMP      R6,#+1
   \   00000014   0xDA12             BGE.N    ??USBH_FindInterfaceIndex_1
    316            {
    317              pif = &pcfg->Itf_Desc[if_ix];
   \   00000016   0xB276             SXTB     R6,R6            ;; SignExt  R6,R6,#+24,#+24
   \   00000018   0x2022             MOVS     R0,#+34
   \   0000001A   0xFB16 0x5000      SMLABB   R0,R6,R0,R5
   \   0000001E   0x300A             ADDS     R0,R0,#+10
   \   00000020   0x0004             MOVS     R4,R0
    318              if((pif->bInterfaceNumber == interface_number) && (pif->bAlternateSetting == alt_settings))
   \   00000022   0x78A0             LDRB     R0,[R4, #+2]
   \   00000024   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000026   0x4288             CMP      R0,R1
   \   00000028   0xD106             BNE.N    ??USBH_FindInterfaceIndex_2
   \   0000002A   0x78E0             LDRB     R0,[R4, #+3]
   \   0000002C   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000002E   0x4290             CMP      R0,R2
   \   00000030   0xD102             BNE.N    ??USBH_FindInterfaceIndex_2
    319              {
    320                return  if_ix;
   \   00000032   0x0030             MOVS     R0,R6
   \   00000034   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000036   0xE002             B.N      ??USBH_FindInterfaceIndex_3
    321              }
    322              if_ix++;
   \                     ??USBH_FindInterfaceIndex_2: (+1)
   \   00000038   0x1C76             ADDS     R6,R6,#+1
   \   0000003A   0xE7E9             B.N      ??USBH_FindInterfaceIndex_0
    323            }
    324            return 0xFF;
   \                     ??USBH_FindInterfaceIndex_1: (+1)
   \   0000003C   0x20FF             MOVS     R0,#+255
   \                     ??USBH_FindInterfaceIndex_3: (+1)
   \   0000003E   0xBC70             POP      {R4-R6}
   \   00000040   0x4770             BX       LR               ;; return
    325          }
    326          
    327          /**
    328            * @brief  USBH_Start 
    329            *         Start the USB Host Core.
    330            * @param  phost: Host Handle
    331            * @retval USBH Status
    332            */

   \                                 In section .text, align 2, keep-with-next
    333          USBH_StatusTypeDef  USBH_Start  (USBH_HandleTypeDef *phost)
    334          {
   \                     USBH_Start: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    335            /* Start the low level driver  */
    336            USBH_LL_Start(phost);
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0x.... 0x....      BL       USBH_LL_Start
    337            
    338            /* Activate VBUS on the port */ 
    339            USBH_LL_DriverVBUS (phost, TRUE);
   \   0000000A   0x2101             MOVS     R1,#+1
   \   0000000C   0x0020             MOVS     R0,R4
   \   0000000E   0x.... 0x....      BL       USBH_LL_DriverVBUS
    340            
    341            return USBH_OK;  
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0xBD10             POP      {R4,PC}          ;; return
    342          }
    343          
    344          /**
    345            * @brief  USBH_Stop 
    346            *         Stop the USB Host Core.
    347            * @param  phost: Host Handle
    348            * @retval USBH Status
    349            */

   \                                 In section .text, align 2, keep-with-next
    350          USBH_StatusTypeDef  USBH_Stop   (USBH_HandleTypeDef *phost)
    351          {
   \                     USBH_Stop: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    352            /* Stop and cleanup the low level driver  */
    353            USBH_LL_Stop(phost);  
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0x.... 0x....      BL       USBH_LL_Stop
    354            
    355            /* DeActivate VBUS on the port */ 
    356            USBH_LL_DriverVBUS (phost, FALSE);
   \   0000000A   0x2100             MOVS     R1,#+0
   \   0000000C   0x0020             MOVS     R0,R4
   \   0000000E   0x.... 0x....      BL       USBH_LL_DriverVBUS
    357            
    358            /* FRee Control Pipes */
    359            USBH_FreePipe  (phost, phost->Control.pipe_in);
   \   00000012   0x7921             LDRB     R1,[R4, #+4]
   \   00000014   0x0020             MOVS     R0,R4
   \   00000016   0x.... 0x....      BL       USBH_FreePipe
    360            USBH_FreePipe  (phost, phost->Control.pipe_out);  
   \   0000001A   0x7961             LDRB     R1,[R4, #+5]
   \   0000001C   0x0020             MOVS     R0,R4
   \   0000001E   0x.... 0x....      BL       USBH_FreePipe
    361            
    362            return USBH_OK;  
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0xBD10             POP      {R4,PC}          ;; return
    363          }
    364          
    365          /**
    366            * @brief  HCD_ReEnumerate 
    367            *         Perform a new Enumeration phase.
    368            * @param  phost: Host Handle
    369            * @retval USBH Status
    370            */

   \                                 In section .text, align 2, keep-with-next
    371          USBH_StatusTypeDef  USBH_ReEnumerate   (USBH_HandleTypeDef *phost)
    372          {
   \                     USBH_ReEnumerate: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    373            /*Stop Host */ 
    374            USBH_Stop(phost);
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0x.... 0x....      BL       USBH_Stop
    375          
    376            /*Device has disconnected, so wait for 200 ms */  
    377            USBH_Delay(200);
   \   0000000A   0x20C8             MOVS     R0,#+200
   \   0000000C   0x.... 0x....      BL       USBH_Delay
    378            
    379            /* Set State machines in default state */
    380            DeInitStateMachine(phost);
   \   00000010   0x0020             MOVS     R0,R4
   \   00000012   0x.... 0x....      BL       DeInitStateMachine
    381             
    382            /* Start again the host */
    383            USBH_Start(phost);
   \   00000016   0x0020             MOVS     R0,R4
   \   00000018   0x.... 0x....      BL       USBH_Start
    384                
    385          #if (USBH_USE_OS == 1)
    386                osMessagePut ( phost->os_event, USBH_PORT_EVENT, 0);
    387          #endif  
    388            return USBH_OK;  
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0xBD10             POP      {R4,PC}          ;; return
    389          }
    390          
    391          /**
    392            * @brief  USBH_Process 
    393            *         Background process of the USB Core.
    394            * @param  phost: Host Handle
    395            * @retval USBH Status
    396            */

   \                                 In section .text, align 2, keep-with-next
    397          USBH_StatusTypeDef  USBH_Process(USBH_HandleTypeDef *phost)
    398          {
   \                     USBH_Process: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB085             SUB      SP,SP,#+20
   \   00000004   0x0004             MOVS     R4,R0
    399            __IO USBH_StatusTypeDef status = USBH_FAIL;
   \   00000006   0x2002             MOVS     R0,#+2
   \   00000008   0xF88D 0x000C      STRB     R0,[SP, #+12]
    400            uint8_t idx = 0;
   \   0000000C   0x2500             MOVS     R5,#+0
    401            
    402            switch (phost->gState)
   \   0000000E   0x7820             LDRB     R0,[R4, #+0]
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD016             BEQ.N    ??USBH_Process_0
   \   00000014   0x2801             CMP      R0,#+1
   \   00000016   0xD021             BEQ.N    ??USBH_Process_1
   \   00000018   0x2802             CMP      R0,#+2
   \   0000001A   0xD020             BEQ.N    ??USBH_Process_2
   \   0000001C   0x2803             CMP      R0,#+3
   \   0000001E   0xF000 0x8119      BEQ.W    ??USBH_Process_3
   \   00000022   0x2805             CMP      R0,#+5
   \   00000024   0xD055             BEQ.N    ??USBH_Process_4
   \   00000026   0x2806             CMP      R0,#+6
   \   00000028   0xF000 0x80EC      BEQ.W    ??USBH_Process_5
   \   0000002C   0x2807             CMP      R0,#+7
   \   0000002E   0xD070             BEQ.N    ??USBH_Process_6
   \   00000030   0x2808             CMP      R0,#+8
   \   00000032   0xD07A             BEQ.N    ??USBH_Process_7
   \   00000034   0x2809             CMP      R0,#+9
   \   00000036   0xF000 0x808A      BEQ.W    ??USBH_Process_8
   \   0000003A   0x280A             CMP      R0,#+10
   \   0000003C   0xF000 0x8100      BEQ.W    ??USBH_Process_9
   \   00000040   0xE118             B.N      ??USBH_Process_10
    403            {
    404            case HOST_IDLE :
    405              
    406              if (phost->device.is_connected)  
   \                     ??USBH_Process_0: (+1)
   \   00000042   0xF894 0x021E      LDRB     R0,[R4, #+542]
   \   00000046   0x2800             CMP      R0,#+0
   \   00000048   0xD007             BEQ.N    ??USBH_Process_11
    407              {
    408                /* Wait for 200 ms after connection */
    409                phost->gState = HOST_DEV_WAIT_FOR_ATTACHMENT; 
   \   0000004A   0x2001             MOVS     R0,#+1
   \   0000004C   0x7020             STRB     R0,[R4, #+0]
    410                USBH_Delay(200); 
   \   0000004E   0x20C8             MOVS     R0,#+200
   \   00000050   0x.... 0x....      BL       USBH_Delay
    411                USBH_LL_ResetPort(phost);
   \   00000054   0x0020             MOVS     R0,R4
   \   00000056   0x.... 0x....      BL       USBH_LL_ResetPort
    412          #if (USBH_USE_OS == 1)
    413                osMessagePut ( phost->os_event, USBH_PORT_EVENT, 0);
    414          #endif
    415              }
    416              break;
   \                     ??USBH_Process_11: (+1)
   \   0000005A   0xE10B             B.N      ??USBH_Process_12
    417              
    418            case HOST_DEV_WAIT_FOR_ATTACHMENT:
    419              break;    
   \                     ??USBH_Process_1: (+1)
   \   0000005C   0xE10A             B.N      ??USBH_Process_12
    420              
    421            case HOST_DEV_ATTACHED :
    422              
    423              USBH_UsrLog("USB Device Attached");  
   \                     ??USBH_Process_2: (+1)
   \   0000005E   0x.... 0x....      LDR.W    R0,??DataTable5_10
   \   00000062   0x.... 0x....      BL       printf
   \   00000066   0x....             ADR.N    R0,??DataTable3  ;; "\n"
   \   00000068   0x.... 0x....      BL       printf
    424                
    425              /* Wait for 100 ms after Reset */
    426              USBH_Delay(100); 
   \   0000006C   0x2064             MOVS     R0,#+100
   \   0000006E   0x.... 0x....      BL       USBH_Delay
    427                    
    428              phost->device.speed = USBH_LL_GetSpeed(phost);
   \   00000072   0x0020             MOVS     R0,R4
   \   00000074   0x.... 0x....      BL       USBH_LL_GetSpeed
   \   00000078   0xF884 0x021D      STRB     R0,[R4, #+541]
    429              
    430              phost->gState = HOST_ENUMERATION;
   \   0000007C   0x2005             MOVS     R0,#+5
   \   0000007E   0x7020             STRB     R0,[R4, #+0]
    431              
    432              phost->Control.pipe_out = USBH_AllocPipe (phost, 0x00);
   \   00000080   0x2100             MOVS     R1,#+0
   \   00000082   0x0020             MOVS     R0,R4
   \   00000084   0x.... 0x....      BL       USBH_AllocPipe
   \   00000088   0x7160             STRB     R0,[R4, #+5]
    433              phost->Control.pipe_in  = USBH_AllocPipe (phost, 0x80);    
   \   0000008A   0x2180             MOVS     R1,#+128
   \   0000008C   0x0020             MOVS     R0,R4
   \   0000008E   0x.... 0x....      BL       USBH_AllocPipe
   \   00000092   0x7120             STRB     R0,[R4, #+4]
    434              
    435              
    436              /* Open Control pipes */
    437              USBH_OpenPipe (phost,
    438                             phost->Control.pipe_in,
    439                             0x80,
    440                             phost->device.address,
    441                             phost->device.speed,
    442                             USBH_EP_CONTROL,
    443                             phost->Control.pipe_size); 
   \   00000094   0x79A0             LDRB     R0,[R4, #+6]
   \   00000096   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000098   0x9002             STR      R0,[SP, #+8]
   \   0000009A   0x2000             MOVS     R0,#+0
   \   0000009C   0x9001             STR      R0,[SP, #+4]
   \   0000009E   0xF894 0x021D      LDRB     R0,[R4, #+541]
   \   000000A2   0x9000             STR      R0,[SP, #+0]
   \   000000A4   0xF894 0x321C      LDRB     R3,[R4, #+540]
   \   000000A8   0x2280             MOVS     R2,#+128
   \   000000AA   0x7921             LDRB     R1,[R4, #+4]
   \   000000AC   0x0020             MOVS     R0,R4
   \   000000AE   0x.... 0x....      BL       USBH_OpenPipe
    444              
    445              /* Open Control pipes */
    446              USBH_OpenPipe (phost,
    447                             phost->Control.pipe_out,
    448                             0x00,
    449                             phost->device.address,
    450                             phost->device.speed,
    451                             USBH_EP_CONTROL,
    452                             phost->Control.pipe_size);
   \   000000B2   0x79A0             LDRB     R0,[R4, #+6]
   \   000000B4   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000B6   0x9002             STR      R0,[SP, #+8]
   \   000000B8   0x2000             MOVS     R0,#+0
   \   000000BA   0x9001             STR      R0,[SP, #+4]
   \   000000BC   0xF894 0x021D      LDRB     R0,[R4, #+541]
   \   000000C0   0x9000             STR      R0,[SP, #+0]
   \   000000C2   0xF894 0x321C      LDRB     R3,[R4, #+540]
   \   000000C6   0x2200             MOVS     R2,#+0
   \   000000C8   0x7961             LDRB     R1,[R4, #+5]
   \   000000CA   0x0020             MOVS     R0,R4
   \   000000CC   0x.... 0x....      BL       USBH_OpenPipe
    453              
    454          #if (USBH_USE_OS == 1)
    455              osMessagePut ( phost->os_event, USBH_PORT_EVENT, 0);
    456          #endif    
    457              
    458              break;
   \   000000D0   0xE0D0             B.N      ??USBH_Process_12
    459              
    460            case HOST_ENUMERATION:     
    461              /* Check for enumeration status */  
    462              if ( USBH_HandleEnum(phost) == USBH_OK)
   \                     ??USBH_Process_4: (+1)
   \   000000D2   0x0020             MOVS     R0,R4
   \   000000D4   0x.... 0x....      BL       USBH_HandleEnum
   \   000000D8   0x2800             CMP      R0,#+0
   \   000000DA   0xD119             BNE.N    ??USBH_Process_13
    463              { 
    464                /* The function shall return USBH_OK when full enumeration is complete */
    465                USBH_UsrLog ("Enumeration done.");
   \   000000DC   0x.... 0x....      LDR.W    R0,??DataTable5_11
   \   000000E0   0x.... 0x....      BL       printf
   \   000000E4   0x....             ADR.N    R0,??DataTable3  ;; "\n"
   \   000000E6   0x.... 0x....      BL       printf
    466                phost->device.current_interface = 0;
   \   000000EA   0x2000             MOVS     R0,#+0
   \   000000EC   0xF884 0x021F      STRB     R0,[R4, #+543]
    467                if(phost->device.DevDesc.bNumConfigurations == 1)
   \   000000F0   0xF894 0x0231      LDRB     R0,[R4, #+561]
   \   000000F4   0x2801             CMP      R0,#+1
   \   000000F6   0xD109             BNE.N    ??USBH_Process_14
    468                {
    469                  USBH_UsrLog ("This device has only 1 configuration.");
   \   000000F8   0x.... 0x....      LDR.W    R0,??DataTable5_12
   \   000000FC   0x.... 0x....      BL       printf
   \   00000100   0x....             ADR.N    R0,??DataTable3  ;; "\n"
   \   00000102   0x.... 0x....      BL       printf
    470                  phost->gState  = HOST_SET_CONFIGURATION;        
   \   00000106   0x2008             MOVS     R0,#+8
   \   00000108   0x7020             STRB     R0,[R4, #+0]
   \   0000010A   0xE001             B.N      ??USBH_Process_13
    471                  
    472                }
    473                else
    474                {
    475                  phost->gState  = HOST_INPUT; 
   \                     ??USBH_Process_14: (+1)
   \   0000010C   0x2007             MOVS     R0,#+7
   \   0000010E   0x7020             STRB     R0,[R4, #+0]
    476                }
    477                    
    478              }
    479              break;
   \                     ??USBH_Process_13: (+1)
   \   00000110   0xE0B0             B.N      ??USBH_Process_12
    480              
    481            case HOST_INPUT:
    482              {
    483                /* user callback for end of device basic enumeration */
    484                if(phost->pUser != NULL)
   \                     ??USBH_Process_6: (+1)
   \   00000112   0xF8D4 0x02B4      LDR      R0,[R4, #+692]
   \   00000116   0x2800             CMP      R0,#+0
   \   00000118   0xD006             BEQ.N    ??USBH_Process_15
    485                {
    486                  phost->pUser(phost, HOST_USER_SELECT_CONFIGURATION);
   \   0000011A   0x2101             MOVS     R1,#+1
   \   0000011C   0x0020             MOVS     R0,R4
   \   0000011E   0xF8D4 0x22B4      LDR      R2,[R4, #+692]
   \   00000122   0x4790             BLX      R2
    487                  phost->gState = HOST_SET_CONFIGURATION;
   \   00000124   0x2008             MOVS     R0,#+8
   \   00000126   0x7020             STRB     R0,[R4, #+0]
    488                  
    489          #if (USBH_USE_OS == 1)
    490                  osMessagePut ( phost->os_event, USBH_STATE_CHANGED_EVENT, 0);
    491          #endif         
    492                }
    493              }
    494              break;
   \                     ??USBH_Process_15: (+1)
   \   00000128   0xE0A4             B.N      ??USBH_Process_12
    495              
    496            case HOST_SET_CONFIGURATION:
    497              /* set configuration */
    498              if (USBH_SetCfg(phost, phost->device.CfgDesc.bConfigurationValue) == USBH_OK)
   \                     ??USBH_Process_7: (+1)
   \   0000012A   0xF894 0x1237      LDRB     R1,[R4, #+567]
   \   0000012E   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000130   0x0020             MOVS     R0,R4
   \   00000132   0x.... 0x....      BL       USBH_SetCfg
   \   00000136   0x2800             CMP      R0,#+0
   \   00000138   0xD108             BNE.N    ??USBH_Process_16
    499              {
    500                phost->gState  = HOST_CHECK_CLASS;
   \   0000013A   0x2009             MOVS     R0,#+9
   \   0000013C   0x7020             STRB     R0,[R4, #+0]
    501                USBH_UsrLog ("Default configuration set.");
   \   0000013E   0x.... 0x....      LDR.W    R0,??DataTable5_13
   \   00000142   0x.... 0x....      BL       printf
   \   00000146   0x....             ADR.N    R0,??DataTable3  ;; "\n"
   \   00000148   0x.... 0x....      BL       printf
    502                
    503              }      
    504              
    505              break;
   \                     ??USBH_Process_16: (+1)
   \   0000014C   0xE092             B.N      ??USBH_Process_12
    506              
    507            case HOST_CHECK_CLASS:
    508              
    509              if(phost->ClassNumber == 0)
   \                     ??USBH_Process_8: (+1)
   \   0000014E   0xF8D4 0x0268      LDR      R0,[R4, #+616]
   \   00000152   0x2800             CMP      R0,#+0
   \   00000154   0xD107             BNE.N    ??USBH_Process_17
    510              {
    511                USBH_UsrLog ("No Class has been registered.");
   \   00000156   0x.... 0x....      LDR.W    R0,??DataTable5_14
   \   0000015A   0x.... 0x....      BL       printf
   \   0000015E   0x....             ADR.N    R0,??DataTable3  ;; "\n"
   \   00000160   0x.... 0x....      BL       printf
   \   00000164   0xE04D             B.N      ??USBH_Process_18
    512              }
    513              else
    514              {
    515                phost->pActiveClass = NULL;
   \                     ??USBH_Process_17: (+1)
   \   00000166   0x2000             MOVS     R0,#+0
   \   00000168   0xF8C4 0x0264      STR      R0,[R4, #+612]
    516                
    517                for (idx = 0; idx < USBH_MAX_NUM_SUPPORTED_CLASS ; idx ++)
   \   0000016C   0x2000             MOVS     R0,#+0
   \   0000016E   0x0005             MOVS     R5,R0
   \                     ??USBH_Process_19: (+1)
   \   00000170   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000172   0x2D00             CMP      R5,#+0
   \   00000174   0xD112             BNE.N    ??USBH_Process_20
    518                {
    519                  if(phost->pClass[idx]->ClassCode == phost->device.CfgDesc.Itf_Desc[0].bInterfaceClass)
   \   00000176   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000178   0xEB14 0x0085      ADDS     R0,R4,R5, LSL #+2
   \   0000017C   0xF8D0 0x0260      LDR      R0,[R0, #+608]
   \   00000180   0x7900             LDRB     R0,[R0, #+4]
   \   00000182   0xF894 0x1241      LDRB     R1,[R4, #+577]
   \   00000186   0x4288             CMP      R0,R1
   \   00000188   0xD106             BNE.N    ??USBH_Process_21
    520                  {
    521                    phost->pActiveClass = phost->pClass[idx];
   \   0000018A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000018C   0xEB14 0x0085      ADDS     R0,R4,R5, LSL #+2
   \   00000190   0xF8D0 0x0260      LDR      R0,[R0, #+608]
   \   00000194   0xF8C4 0x0264      STR      R0,[R4, #+612]
    522                  }
    523                }
   \                     ??USBH_Process_21: (+1)
   \   00000198   0x1C6D             ADDS     R5,R5,#+1
   \   0000019A   0xE7E9             B.N      ??USBH_Process_19
    524                
    525                if(phost->pActiveClass != NULL)
   \                     ??USBH_Process_20: (+1)
   \   0000019C   0xF8D4 0x0264      LDR      R0,[R4, #+612]
   \   000001A0   0x2800             CMP      R0,#+0
   \   000001A2   0xD025             BEQ.N    ??USBH_Process_22
    526                {
    527                  if(phost->pActiveClass->Init(phost)== USBH_OK)
   \   000001A4   0x0020             MOVS     R0,R4
   \   000001A6   0xF8D4 0x1264      LDR      R1,[R4, #+612]
   \   000001AA   0x6889             LDR      R1,[R1, #+8]
   \   000001AC   0x4788             BLX      R1
   \   000001AE   0x2800             CMP      R0,#+0
   \   000001B0   0xD111             BNE.N    ??USBH_Process_23
    528                  {
    529                    phost->gState  = HOST_CLASS_REQUEST; 
   \   000001B2   0x2006             MOVS     R0,#+6
   \   000001B4   0x7020             STRB     R0,[R4, #+0]
    530                    USBH_UsrLog ("%s class started.", phost->pActiveClass->Name);
   \   000001B6   0xF8D4 0x0264      LDR      R0,[R4, #+612]
   \   000001BA   0x6801             LDR      R1,[R0, #+0]
   \   000001BC   0x.... 0x....      LDR.W    R0,??DataTable5_15
   \   000001C0   0x.... 0x....      BL       printf
   \   000001C4   0x....             ADR.N    R0,??DataTable3  ;; "\n"
   \   000001C6   0x.... 0x....      BL       printf
    531                    
    532                    /* Inform user that a class has been activated */
    533                    phost->pUser(phost, HOST_USER_CLASS_SELECTED);   
   \   000001CA   0x2103             MOVS     R1,#+3
   \   000001CC   0x0020             MOVS     R0,R4
   \   000001CE   0xF8D4 0x22B4      LDR      R2,[R4, #+692]
   \   000001D2   0x4790             BLX      R2
   \   000001D4   0xE015             B.N      ??USBH_Process_18
    534                  }
    535                  else
    536                  {
    537                    phost->gState  = HOST_ABORT_STATE;
   \                     ??USBH_Process_23: (+1)
   \   000001D6   0x200C             MOVS     R0,#+12
   \   000001D8   0x7020             STRB     R0,[R4, #+0]
    538                    USBH_UsrLog ("Device not supporting %s class.", phost->pActiveClass->Name);
   \   000001DA   0xF8D4 0x0264      LDR      R0,[R4, #+612]
   \   000001DE   0x6801             LDR      R1,[R0, #+0]
   \   000001E0   0x.... 0x....      LDR.W    R0,??DataTable5_16
   \   000001E4   0x.... 0x....      BL       printf
   \   000001E8   0x....             ADR.N    R0,??DataTable3  ;; "\n"
   \   000001EA   0x.... 0x....      BL       printf
   \   000001EE   0xE008             B.N      ??USBH_Process_18
    539                  }
    540                }
    541                else
    542                {
    543                  phost->gState  = HOST_ABORT_STATE;
   \                     ??USBH_Process_22: (+1)
   \   000001F0   0x200C             MOVS     R0,#+12
   \   000001F2   0x7020             STRB     R0,[R4, #+0]
    544                  USBH_UsrLog ("No registered class for this device.");
   \   000001F4   0x.... 0x....      LDR.W    R0,??DataTable5_17
   \   000001F8   0x.... 0x....      BL       printf
   \   000001FC   0x....             ADR.N    R0,??DataTable3  ;; "\n"
   \   000001FE   0x.... 0x....      BL       printf
    545                }
    546              }
    547              
    548          #if (USBH_USE_OS == 1)
    549              osMessagePut ( phost->os_event, USBH_STATE_CHANGED_EVENT, 0);
    550          #endif 
    551              break;    
   \                     ??USBH_Process_18: (+1)
   \   00000202   0xE037             B.N      ??USBH_Process_12
    552              
    553            case HOST_CLASS_REQUEST:  
    554              /* process class standard control requests state machine */
    555              if(phost->pActiveClass != NULL)
   \                     ??USBH_Process_5: (+1)
   \   00000204   0xF8D4 0x0264      LDR      R0,[R4, #+612]
   \   00000208   0x2800             CMP      R0,#+0
   \   0000020A   0xD00D             BEQ.N    ??USBH_Process_24
    556              {
    557                status = phost->pActiveClass->Requests(phost);
   \   0000020C   0x0020             MOVS     R0,R4
   \   0000020E   0xF8D4 0x1264      LDR      R1,[R4, #+612]
   \   00000212   0x6909             LDR      R1,[R1, #+16]
   \   00000214   0x4788             BLX      R1
   \   00000216   0xF88D 0x000C      STRB     R0,[SP, #+12]
    558                
    559                if(status == USBH_OK)
   \   0000021A   0xF89D 0x000C      LDRB     R0,[SP, #+12]
   \   0000021E   0x2800             CMP      R0,#+0
   \   00000220   0xD10D             BNE.N    ??USBH_Process_25
    560                {
    561                  phost->gState  = HOST_CLASS;        
   \   00000222   0x200A             MOVS     R0,#+10
   \   00000224   0x7020             STRB     R0,[R4, #+0]
   \   00000226   0xE00A             B.N      ??USBH_Process_25
    562                }  
    563              }
    564              else
    565              {
    566                phost->gState  = HOST_ABORT_STATE;
   \                     ??USBH_Process_24: (+1)
   \   00000228   0x200C             MOVS     R0,#+12
   \   0000022A   0x7020             STRB     R0,[R4, #+0]
    567                USBH_ErrLog ("Invalid Class Driver.");
   \   0000022C   0x....             LDR.N    R0,??DataTable5_1
   \   0000022E   0x.... 0x....      BL       printf
   \   00000232   0x....             LDR.N    R0,??DataTable5_18
   \   00000234   0x.... 0x....      BL       printf
   \   00000238   0x....             ADR.N    R0,??DataTable3  ;; "\n"
   \   0000023A   0x.... 0x....      BL       printf
    568              
    569          #if (USBH_USE_OS == 1)
    570              osMessagePut ( phost->os_event, USBH_STATE_CHANGED_EVENT, 0);
    571          #endif       
    572              }
    573              
    574              break;    
   \                     ??USBH_Process_25: (+1)
   \   0000023E   0xE019             B.N      ??USBH_Process_12
    575            case HOST_CLASS:   
    576              /* process class state machine */
    577              if(phost->pActiveClass != NULL)
   \                     ??USBH_Process_9: (+1)
   \   00000240   0xF8D4 0x0264      LDR      R0,[R4, #+612]
   \   00000244   0x2800             CMP      R0,#+0
   \   00000246   0xD004             BEQ.N    ??USBH_Process_26
    578              { 
    579                phost->pActiveClass->BgndProcess(phost);
   \   00000248   0x0020             MOVS     R0,R4
   \   0000024A   0xF8D4 0x1264      LDR      R1,[R4, #+612]
   \   0000024E   0x6949             LDR      R1,[R1, #+20]
   \   00000250   0x4788             BLX      R1
    580              }
    581              break;       
   \                     ??USBH_Process_26: (+1)
   \   00000252   0xE00F             B.N      ??USBH_Process_12
    582          
    583            case HOST_DEV_DISCONNECTED :
    584              
    585              DeInitStateMachine(phost);  
   \                     ??USBH_Process_3: (+1)
   \   00000254   0x0020             MOVS     R0,R4
   \   00000256   0x.... 0x....      BL       DeInitStateMachine
    586              
    587              /* Re-Initilaize Host for new Enumeration */
    588              if(phost->pActiveClass != NULL)
   \   0000025A   0xF8D4 0x0264      LDR      R0,[R4, #+612]
   \   0000025E   0x2800             CMP      R0,#+0
   \   00000260   0xD007             BEQ.N    ??USBH_Process_27
    589              {
    590                phost->pActiveClass->DeInit(phost); 
   \   00000262   0x0020             MOVS     R0,R4
   \   00000264   0xF8D4 0x1264      LDR      R1,[R4, #+612]
   \   00000268   0x68C9             LDR      R1,[R1, #+12]
   \   0000026A   0x4788             BLX      R1
    591                phost->pActiveClass = NULL;
   \   0000026C   0x2000             MOVS     R0,#+0
   \   0000026E   0xF8C4 0x0264      STR      R0,[R4, #+612]
    592              }     
    593              break;
   \                     ??USBH_Process_27: (+1)
   \   00000272   0xE7FF             B.N      ??USBH_Process_12
    594              
    595            case HOST_ABORT_STATE:
    596            default :
    597              break;
    598            }
    599           return USBH_OK;  
   \                     ??USBH_Process_10: (+1)
   \                     ??USBH_Process_12: (+1)
   \   00000274   0x2000             MOVS     R0,#+0
   \   00000276   0xB005             ADD      SP,SP,#+20
   \   00000278   0xBD30             POP      {R4,R5,PC}       ;; return
    600          }
    601          
    602          
    603          /**
    604            * @brief  USBH_HandleEnum 
    605            *         This function includes the complete enumeration process
    606            * @param  phost: Host Handle
    607            * @retval USBH_Status
    608            */

   \                                 In section .text, align 2, keep-with-next
    609          static USBH_StatusTypeDef USBH_HandleEnum (USBH_HandleTypeDef *phost)
    610          {
   \                     USBH_HandleEnum: (+1)
   \   00000000   0xB53E             PUSH     {R1-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    611            USBH_StatusTypeDef Status = USBH_BUSY;  
   \   00000004   0x2501             MOVS     R5,#+1
    612            
    613            switch (phost->EnumState)
   \   00000006   0x7860             LDRB     R0,[R4, #+1]
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD010             BEQ.N    ??USBH_HandleEnum_0
   \   0000000C   0x2802             CMP      R0,#+2
   \   0000000E   0xD051             BEQ.N    ??USBH_HandleEnum_1
   \   00000010   0xD337             BCC.N    ??USBH_HandleEnum_2
   \   00000012   0x2804             CMP      R0,#+4
   \   00000014   0xF000 0x808C      BEQ.W    ??USBH_HandleEnum_3
   \   00000018   0xF0C0 0x8081      BCC.W    ??USBH_HandleEnum_4
   \   0000001C   0x2806             CMP      R0,#+6
   \   0000001E   0xF000 0x80B3      BEQ.W    ??USBH_HandleEnum_5
   \   00000022   0xF0C0 0x808F      BCC.W    ??USBH_HandleEnum_6
   \   00000026   0x2807             CMP      R0,#+7
   \   00000028   0xF000 0x80D0      BEQ.W    ??USBH_HandleEnum_7
   \   0000002C   0xE0F0             B.N      ??USBH_HandleEnum_8
    614            {
    615            case ENUM_IDLE:  
    616              /* Get Device Desc for only 1st 8 bytes : To get EP0 MaxPacketSize */
    617              if ( USBH_Get_DevDesc(phost, 8) == USBH_OK)
   \                     ??USBH_HandleEnum_0: (+1)
   \   0000002E   0x2108             MOVS     R1,#+8
   \   00000030   0x0020             MOVS     R0,R4
   \   00000032   0x.... 0x....      BL       USBH_Get_DevDesc
   \   00000036   0x2800             CMP      R0,#+0
   \   00000038   0xD122             BNE.N    ??USBH_HandleEnum_9
    618              {
    619                phost->Control.pipe_size = phost->device.DevDesc.bMaxPacketSize;
   \   0000003A   0xF894 0x0227      LDRB     R0,[R4, #+551]
   \   0000003E   0x71A0             STRB     R0,[R4, #+6]
    620          
    621                phost->EnumState = ENUM_GET_FULL_DEV_DESC;
   \   00000040   0x2001             MOVS     R0,#+1
   \   00000042   0x7060             STRB     R0,[R4, #+1]
    622                
    623                /* modify control channels configuration for MaxPacket size */
    624                USBH_OpenPipe (phost,
    625                                     phost->Control.pipe_in,
    626                                     0x80,
    627                                     phost->device.address,
    628                                     phost->device.speed,
    629                                     USBH_EP_CONTROL,
    630                                     phost->Control.pipe_size); 
   \   00000044   0x79A0             LDRB     R0,[R4, #+6]
   \   00000046   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000048   0x9002             STR      R0,[SP, #+8]
   \   0000004A   0x2000             MOVS     R0,#+0
   \   0000004C   0x9001             STR      R0,[SP, #+4]
   \   0000004E   0xF894 0x021D      LDRB     R0,[R4, #+541]
   \   00000052   0x9000             STR      R0,[SP, #+0]
   \   00000054   0xF894 0x321C      LDRB     R3,[R4, #+540]
   \   00000058   0x2280             MOVS     R2,#+128
   \   0000005A   0x7921             LDRB     R1,[R4, #+4]
   \   0000005C   0x0020             MOVS     R0,R4
   \   0000005E   0x.... 0x....      BL       USBH_OpenPipe
    631                
    632                /* Open Control pipes */
    633                USBH_OpenPipe (phost,
    634                                     phost->Control.pipe_out,
    635                                     0x00,
    636                                     phost->device.address,
    637                                     phost->device.speed,
    638                                     USBH_EP_CONTROL,
    639                                     phost->Control.pipe_size);           
   \   00000062   0x79A0             LDRB     R0,[R4, #+6]
   \   00000064   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000066   0x9002             STR      R0,[SP, #+8]
   \   00000068   0x2000             MOVS     R0,#+0
   \   0000006A   0x9001             STR      R0,[SP, #+4]
   \   0000006C   0xF894 0x021D      LDRB     R0,[R4, #+541]
   \   00000070   0x9000             STR      R0,[SP, #+0]
   \   00000072   0xF894 0x321C      LDRB     R3,[R4, #+540]
   \   00000076   0x2200             MOVS     R2,#+0
   \   00000078   0x7961             LDRB     R1,[R4, #+5]
   \   0000007A   0x0020             MOVS     R0,R4
   \   0000007C   0x.... 0x....      BL       USBH_OpenPipe
    640                
    641              }
    642              break;
   \                     ??USBH_HandleEnum_9: (+1)
   \   00000080   0xE0C6             B.N      ??USBH_HandleEnum_10
    643              
    644            case ENUM_GET_FULL_DEV_DESC:  
    645              /* Get FULL Device Desc  */
    646              if ( USBH_Get_DevDesc(phost, USB_DEVICE_DESC_SIZE)== USBH_OK)
   \                     ??USBH_HandleEnum_2: (+1)
   \   00000082   0x2112             MOVS     R1,#+18
   \   00000084   0x0020             MOVS     R0,R4
   \   00000086   0x.... 0x....      BL       USBH_Get_DevDesc
   \   0000008A   0x2800             CMP      R0,#+0
   \   0000008C   0xD111             BNE.N    ??USBH_HandleEnum_11
    647              {
    648                USBH_UsrLog("PID: %xh", phost->device.DevDesc.idProduct );  
   \   0000008E   0xF8B4 0x122A      LDRH     R1,[R4, #+554]
   \   00000092   0x....             LDR.N    R0,??DataTable5_19
   \   00000094   0x.... 0x....      BL       printf
   \   00000098   0x....             ADR.N    R0,??DataTable5  ;; "\n"
   \   0000009A   0x.... 0x....      BL       printf
    649                USBH_UsrLog("VID: %xh", phost->device.DevDesc.idVendor );  
   \   0000009E   0xF8B4 0x1228      LDRH     R1,[R4, #+552]
   \   000000A2   0x....             LDR.N    R0,??DataTable5_20
   \   000000A4   0x.... 0x....      BL       printf
   \   000000A8   0x....             ADR.N    R0,??DataTable5  ;; "\n"
   \   000000AA   0x.... 0x....      BL       printf
    650                
    651                phost->EnumState = ENUM_SET_ADDR;
   \   000000AE   0x2002             MOVS     R0,#+2
   \   000000B0   0x7060             STRB     R0,[R4, #+1]
    652                 
    653              }
    654              break;
   \                     ??USBH_HandleEnum_11: (+1)
   \   000000B2   0xE0AD             B.N      ??USBH_HandleEnum_10
    655             
    656            case ENUM_SET_ADDR: 
    657              /* set address */
    658              if ( USBH_SetAddress(phost, USBH_DEVICE_ADDRESS) == USBH_OK)
   \                     ??USBH_HandleEnum_1: (+1)
   \   000000B4   0x2101             MOVS     R1,#+1
   \   000000B6   0x0020             MOVS     R0,R4
   \   000000B8   0x.... 0x....      BL       USBH_SetAddress
   \   000000BC   0x2800             CMP      R0,#+0
   \   000000BE   0xD12D             BNE.N    ??USBH_HandleEnum_12
    659              {
    660                USBH_Delay(2);
   \   000000C0   0x2002             MOVS     R0,#+2
   \   000000C2   0x.... 0x....      BL       USBH_Delay
    661                phost->device.address = USBH_DEVICE_ADDRESS;
   \   000000C6   0x2001             MOVS     R0,#+1
   \   000000C8   0xF884 0x021C      STRB     R0,[R4, #+540]
    662                
    663                /* user callback for device address assigned */
    664                USBH_UsrLog("Address (#%d) assigned.", phost->device.address);
   \   000000CC   0xF894 0x121C      LDRB     R1,[R4, #+540]
   \   000000D0   0x....             LDR.N    R0,??DataTable5_21
   \   000000D2   0x.... 0x....      BL       printf
   \   000000D6   0x....             ADR.N    R0,??DataTable5  ;; "\n"
   \   000000D8   0x.... 0x....      BL       printf
    665                phost->EnumState = ENUM_GET_CFG_DESC;
   \   000000DC   0x2003             MOVS     R0,#+3
   \   000000DE   0x7060             STRB     R0,[R4, #+1]
    666                
    667                /* modify control channels to update device address */
    668                USBH_OpenPipe (phost,
    669                                     phost->Control.pipe_in,
    670                                     0x80,
    671                                     phost->device.address,
    672                                     phost->device.speed,
    673                                     USBH_EP_CONTROL,
    674                                     phost->Control.pipe_size); 
   \   000000E0   0x79A0             LDRB     R0,[R4, #+6]
   \   000000E2   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000E4   0x9002             STR      R0,[SP, #+8]
   \   000000E6   0x2000             MOVS     R0,#+0
   \   000000E8   0x9001             STR      R0,[SP, #+4]
   \   000000EA   0xF894 0x021D      LDRB     R0,[R4, #+541]
   \   000000EE   0x9000             STR      R0,[SP, #+0]
   \   000000F0   0xF894 0x321C      LDRB     R3,[R4, #+540]
   \   000000F4   0x2280             MOVS     R2,#+128
   \   000000F6   0x7921             LDRB     R1,[R4, #+4]
   \   000000F8   0x0020             MOVS     R0,R4
   \   000000FA   0x.... 0x....      BL       USBH_OpenPipe
    675                
    676                /* Open Control pipes */
    677                USBH_OpenPipe (phost,
    678                                     phost->Control.pipe_out,
    679                                     0x00,
    680                                     phost->device.address,
    681                                     phost->device.speed,
    682                                     USBH_EP_CONTROL,
    683                                     phost->Control.pipe_size);        
   \   000000FE   0x79A0             LDRB     R0,[R4, #+6]
   \   00000100   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000102   0x9002             STR      R0,[SP, #+8]
   \   00000104   0x2000             MOVS     R0,#+0
   \   00000106   0x9001             STR      R0,[SP, #+4]
   \   00000108   0xF894 0x021D      LDRB     R0,[R4, #+541]
   \   0000010C   0x9000             STR      R0,[SP, #+0]
   \   0000010E   0xF894 0x321C      LDRB     R3,[R4, #+540]
   \   00000112   0x2200             MOVS     R2,#+0
   \   00000114   0x7961             LDRB     R1,[R4, #+5]
   \   00000116   0x0020             MOVS     R0,R4
   \   00000118   0x.... 0x....      BL       USBH_OpenPipe
    684              }
    685              break;
   \                     ??USBH_HandleEnum_12: (+1)
   \   0000011C   0xE078             B.N      ??USBH_HandleEnum_10
    686              
    687            case ENUM_GET_CFG_DESC:  
    688              /* get standard configuration descriptor */
    689              if ( USBH_Get_CfgDesc(phost, 
    690                                    USB_CONFIGURATION_DESC_SIZE) == USBH_OK)
   \                     ??USBH_HandleEnum_4: (+1)
   \   0000011E   0x2109             MOVS     R1,#+9
   \   00000120   0x0020             MOVS     R0,R4
   \   00000122   0x.... 0x....      BL       USBH_Get_CfgDesc
   \   00000126   0x2800             CMP      R0,#+0
   \   00000128   0xD101             BNE.N    ??USBH_HandleEnum_13
    691              {
    692                phost->EnumState = ENUM_GET_FULL_CFG_DESC;        
   \   0000012A   0x2004             MOVS     R0,#+4
   \   0000012C   0x7060             STRB     R0,[R4, #+1]
    693              }
    694              break;
   \                     ??USBH_HandleEnum_13: (+1)
   \   0000012E   0xE06F             B.N      ??USBH_HandleEnum_10
    695              
    696            case ENUM_GET_FULL_CFG_DESC:  
    697              /* get FULL config descriptor (config, interface, endpoints) */
    698              if (USBH_Get_CfgDesc(phost, 
    699                                   phost->device.CfgDesc.wTotalLength) == USBH_OK)
   \                     ??USBH_HandleEnum_3: (+1)
   \   00000130   0xF8B4 0x1234      LDRH     R1,[R4, #+564]
   \   00000134   0x0020             MOVS     R0,R4
   \   00000136   0x.... 0x....      BL       USBH_Get_CfgDesc
   \   0000013A   0x2800             CMP      R0,#+0
   \   0000013C   0xD101             BNE.N    ??USBH_HandleEnum_14
    700              {
    701                phost->EnumState = ENUM_GET_MFC_STRING_DESC;       
   \   0000013E   0x2005             MOVS     R0,#+5
   \   00000140   0x7060             STRB     R0,[R4, #+1]
    702              }
    703              break;
   \                     ??USBH_HandleEnum_14: (+1)
   \   00000142   0xE065             B.N      ??USBH_HandleEnum_10
    704              
    705            case ENUM_GET_MFC_STRING_DESC:  
    706              if (phost->device.DevDesc.iManufacturer != 0)
   \                     ??USBH_HandleEnum_6: (+1)
   \   00000144   0xF894 0x022E      LDRB     R0,[R4, #+558]
   \   00000148   0x2800             CMP      R0,#+0
   \   0000014A   0xD014             BEQ.N    ??USBH_HandleEnum_15
    707              { /* Check that Manufacturer String is available */
    708                
    709                if ( USBH_Get_StringDesc(phost,
    710                                         phost->device.DevDesc.iManufacturer, 
    711                                          phost->device.Data , 
    712                                         0xff) == USBH_OK)
   \   0000014C   0x23FF             MOVS     R3,#+255
   \   0000014E   0xF114 0x021C      ADDS     R2,R4,#+28
   \   00000152   0xF894 0x122E      LDRB     R1,[R4, #+558]
   \   00000156   0x0020             MOVS     R0,R4
   \   00000158   0x.... 0x....      BL       USBH_Get_StringDesc
   \   0000015C   0x2800             CMP      R0,#+0
   \   0000015E   0xD112             BNE.N    ??USBH_HandleEnum_16
    713                {
    714                  /* User callback for Manufacturing string */
    715                  USBH_UsrLog("Manufacturer : %s",  (char *)phost->device.Data);
   \   00000160   0xF114 0x011C      ADDS     R1,R4,#+28
   \   00000164   0x....             LDR.N    R0,??DataTable5_22
   \   00000166   0x.... 0x....      BL       printf
   \   0000016A   0x....             ADR.N    R0,??DataTable5  ;; "\n"
   \   0000016C   0x.... 0x....      BL       printf
    716                  phost->EnumState = ENUM_GET_PRODUCT_STRING_DESC;
   \   00000170   0x2006             MOVS     R0,#+6
   \   00000172   0x7060             STRB     R0,[R4, #+1]
   \   00000174   0xE007             B.N      ??USBH_HandleEnum_16
    717                  
    718          #if (USBH_USE_OS == 1)
    719              osMessagePut ( phost->os_event, USBH_STATE_CHANGED_EVENT, 0);
    720          #endif          
    721                }
    722              }
    723              else
    724              {
    725               USBH_UsrLog("Manufacturer : N/A");      
   \                     ??USBH_HandleEnum_15: (+1)
   \   00000176   0x....             LDR.N    R0,??DataTable5_23
   \   00000178   0x.... 0x....      BL       printf
   \   0000017C   0x....             ADR.N    R0,??DataTable5  ;; "\n"
   \   0000017E   0x.... 0x....      BL       printf
    726               phost->EnumState = ENUM_GET_PRODUCT_STRING_DESC; 
   \   00000182   0x2006             MOVS     R0,#+6
   \   00000184   0x7060             STRB     R0,[R4, #+1]
    727          #if (USBH_USE_OS == 1)
    728              osMessagePut ( phost->os_event, USBH_STATE_CHANGED_EVENT, 0);
    729          #endif       
    730              }
    731              break;
   \                     ??USBH_HandleEnum_16: (+1)
   \   00000186   0xE043             B.N      ??USBH_HandleEnum_10
    732              
    733            case ENUM_GET_PRODUCT_STRING_DESC:   
    734              if (phost->device.DevDesc.iProduct != 0)
   \                     ??USBH_HandleEnum_5: (+1)
   \   00000188   0xF894 0x022F      LDRB     R0,[R4, #+559]
   \   0000018C   0x2800             CMP      R0,#+0
   \   0000018E   0xD014             BEQ.N    ??USBH_HandleEnum_17
    735              { /* Check that Product string is available */
    736                if ( USBH_Get_StringDesc(phost,
    737                                         phost->device.DevDesc.iProduct, 
    738                                         phost->device.Data, 
    739                                         0xff) == USBH_OK)
   \   00000190   0x23FF             MOVS     R3,#+255
   \   00000192   0xF114 0x021C      ADDS     R2,R4,#+28
   \   00000196   0xF894 0x122F      LDRB     R1,[R4, #+559]
   \   0000019A   0x0020             MOVS     R0,R4
   \   0000019C   0x.... 0x....      BL       USBH_Get_StringDesc
   \   000001A0   0x2800             CMP      R0,#+0
   \   000001A2   0xD112             BNE.N    ??USBH_HandleEnum_18
    740                {
    741                  /* User callback for Product string */
    742                  USBH_UsrLog("Product : %s",  (char *)phost->device.Data);
   \   000001A4   0xF114 0x011C      ADDS     R1,R4,#+28
   \   000001A8   0x....             LDR.N    R0,??DataTable5_24
   \   000001AA   0x.... 0x....      BL       printf
   \   000001AE   0x....             ADR.N    R0,??DataTable5  ;; "\n"
   \   000001B0   0x.... 0x....      BL       printf
    743                  phost->EnumState = ENUM_GET_SERIALNUM_STRING_DESC;        
   \   000001B4   0x2007             MOVS     R0,#+7
   \   000001B6   0x7060             STRB     R0,[R4, #+1]
   \   000001B8   0xE007             B.N      ??USBH_HandleEnum_18
    744                }
    745              }
    746              else
    747              {
    748                USBH_UsrLog("Product : N/A");
   \                     ??USBH_HandleEnum_17: (+1)
   \   000001BA   0x....             LDR.N    R0,??DataTable5_25
   \   000001BC   0x.... 0x....      BL       printf
   \   000001C0   0x....             ADR.N    R0,??DataTable5  ;; "\n"
   \   000001C2   0x.... 0x....      BL       printf
    749                phost->EnumState = ENUM_GET_SERIALNUM_STRING_DESC; 
   \   000001C6   0x2007             MOVS     R0,#+7
   \   000001C8   0x7060             STRB     R0,[R4, #+1]
    750          #if (USBH_USE_OS == 1)
    751              osMessagePut ( phost->os_event, USBH_STATE_CHANGED_EVENT, 0);
    752          #endif        
    753              } 
    754              break;
   \                     ??USBH_HandleEnum_18: (+1)
   \   000001CA   0xE021             B.N      ??USBH_HandleEnum_10
    755              
    756            case ENUM_GET_SERIALNUM_STRING_DESC:   
    757              if (phost->device.DevDesc.iSerialNumber != 0)
   \                     ??USBH_HandleEnum_7: (+1)
   \   000001CC   0xF894 0x0230      LDRB     R0,[R4, #+560]
   \   000001D0   0x2800             CMP      R0,#+0
   \   000001D2   0xD014             BEQ.N    ??USBH_HandleEnum_19
    758              { /* Check that Serial number string is available */    
    759                if ( USBH_Get_StringDesc(phost,
    760                                         phost->device.DevDesc.iSerialNumber, 
    761                                         phost->device.Data, 
    762                                         0xff) == USBH_OK)
   \   000001D4   0x23FF             MOVS     R3,#+255
   \   000001D6   0xF114 0x021C      ADDS     R2,R4,#+28
   \   000001DA   0xF894 0x1230      LDRB     R1,[R4, #+560]
   \   000001DE   0x0020             MOVS     R0,R4
   \   000001E0   0x.... 0x....      BL       USBH_Get_StringDesc
   \   000001E4   0x2800             CMP      R0,#+0
   \   000001E6   0xD112             BNE.N    ??USBH_HandleEnum_20
    763                {
    764                  /* User callback for Serial number string */
    765                   USBH_UsrLog("Serial Number : %s",  (char *)phost->device.Data);
   \   000001E8   0xF114 0x011C      ADDS     R1,R4,#+28
   \   000001EC   0x....             LDR.N    R0,??DataTable5_26
   \   000001EE   0x.... 0x....      BL       printf
   \   000001F2   0x....             ADR.N    R0,??DataTable5  ;; "\n"
   \   000001F4   0x.... 0x....      BL       printf
    766                  Status = USBH_OK;
   \   000001F8   0x2000             MOVS     R0,#+0
   \   000001FA   0x0005             MOVS     R5,R0
   \   000001FC   0xE007             B.N      ??USBH_HandleEnum_20
    767                }
    768              }
    769              else
    770              {
    771                USBH_UsrLog("Serial Number : N/A"); 
   \                     ??USBH_HandleEnum_19: (+1)
   \   000001FE   0x....             LDR.N    R0,??DataTable5_27
   \   00000200   0x.... 0x....      BL       printf
   \   00000204   0x....             ADR.N    R0,??DataTable5  ;; "\n"
   \   00000206   0x.... 0x....      BL       printf
    772                Status = USBH_OK;
   \   0000020A   0x2000             MOVS     R0,#+0
   \   0000020C   0x0005             MOVS     R5,R0
    773          #if (USBH_USE_OS == 1)
    774              osMessagePut ( phost->os_event, USBH_STATE_CHANGED_EVENT, 0);
    775          #endif        
    776              }  
    777              break;
   \                     ??USBH_HandleEnum_20: (+1)
   \   0000020E   0xE7FF             B.N      ??USBH_HandleEnum_10
    778              
    779            default:
    780              break;
    781            }  
    782            return Status;
   \                     ??USBH_HandleEnum_8: (+1)
   \                     ??USBH_HandleEnum_10: (+1)
   \   00000210   0x0028             MOVS     R0,R5
   \   00000212   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000214   0xBD3E             POP      {R1-R5,PC}       ;; return
    783          }
    784          
    785          /**
    786            * @brief  USBH_LL_SetTimer 
    787            *         Set the initial Host Timer tick
    788            * @param  phost: Host Handle
    789            * @retval None
    790            */

   \                                 In section .text, align 2, keep-with-next
    791          void  USBH_LL_SetTimer  (USBH_HandleTypeDef *phost, uint32_t time)
    792          {
    793            phost->Timer = time;
   \                     USBH_LL_SetTimer: (+1)
   \   00000000   0xF8C0 0x12A8      STR      R1,[R0, #+680]
    794          }
   \   00000004   0x4770             BX       LR               ;; return
    795          /**
    796            * @brief  USBH_LL_IncTimer 
    797            *         Increment Host Timer tick
    798            * @param  phost: Host Handle
    799            * @retval None
    800            */

   \                                 In section .text, align 2, keep-with-next
    801          void  USBH_LL_IncTimer  (USBH_HandleTypeDef *phost)
    802          {
   \                     USBH_LL_IncTimer: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    803            phost->Timer ++;
   \   00000004   0xF8D4 0x02A8      LDR      R0,[R4, #+680]
   \   00000008   0x1C40             ADDS     R0,R0,#+1
   \   0000000A   0xF8C4 0x02A8      STR      R0,[R4, #+680]
    804            USBH_HandleSof(phost);
   \   0000000E   0x0020             MOVS     R0,R4
   \   00000010   0x.... 0x....      BL       USBH_HandleSof
    805          }
   \   00000014   0xBD10             POP      {R4,PC}          ;; return
    806          
    807          /**
    808            * @brief  USBH_HandleSof 
    809            *         Call SOF process
    810            * @param  phost: Host Handle
    811            * @retval None
    812            */

   \                                 In section .text, align 2, keep-with-next
    813          void  USBH_HandleSof  (USBH_HandleTypeDef *phost)
    814          {
   \                     USBH_HandleSof: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    815            if((phost->gState == HOST_CLASS)&&(phost->pActiveClass != NULL))
   \   00000004   0x7820             LDRB     R0,[R4, #+0]
   \   00000006   0x280A             CMP      R0,#+10
   \   00000008   0xD108             BNE.N    ??USBH_HandleSof_0
   \   0000000A   0xF8D4 0x0264      LDR      R0,[R4, #+612]
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD004             BEQ.N    ??USBH_HandleSof_0
    816            {
    817              phost->pActiveClass->SOFProcess(phost);
   \   00000012   0x0020             MOVS     R0,R4
   \   00000014   0xF8D4 0x1264      LDR      R1,[R4, #+612]
   \   00000018   0x6989             LDR      R1,[R1, #+24]
   \   0000001A   0x4788             BLX      R1
    818            }
    819          }
   \                     ??USBH_HandleSof_0: (+1)
   \   0000001C   0xBD10             POP      {R4,PC}          ;; return
    820          /**
    821            * @brief  USBH_LL_Connect 
    822            *         Handle USB Host connexion event
    823            * @param  phost: Host Handle
    824            * @retval USBH_Status
    825            */

   \                                 In section .text, align 2, keep-with-next
    826          USBH_StatusTypeDef  USBH_LL_Connect  (USBH_HandleTypeDef *phost)
    827          {
   \                     USBH_LL_Connect: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    828            if(phost->gState == HOST_IDLE )
   \   00000004   0x7820             LDRB     R0,[R4, #+0]
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD10C             BNE.N    ??USBH_LL_Connect_0
    829            {
    830              phost->device.is_connected = 1;
   \   0000000A   0x2001             MOVS     R0,#+1
   \   0000000C   0xF884 0x021E      STRB     R0,[R4, #+542]
    831              
    832              if(phost->pUser != NULL)
   \   00000010   0xF8D4 0x02B4      LDR      R0,[R4, #+692]
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD00A             BEQ.N    ??USBH_LL_Connect_1
    833              {    
    834                phost->pUser(phost, HOST_USER_CONNECTION);
   \   00000018   0x2104             MOVS     R1,#+4
   \   0000001A   0x0020             MOVS     R0,R4
   \   0000001C   0xF8D4 0x22B4      LDR      R2,[R4, #+692]
   \   00000020   0x4790             BLX      R2
   \   00000022   0xE004             B.N      ??USBH_LL_Connect_1
    835              }
    836            } 
    837            else if(phost->gState == HOST_DEV_WAIT_FOR_ATTACHMENT )
   \                     ??USBH_LL_Connect_0: (+1)
   \   00000024   0x7820             LDRB     R0,[R4, #+0]
   \   00000026   0x2801             CMP      R0,#+1
   \   00000028   0xD101             BNE.N    ??USBH_LL_Connect_1
    838            {
    839              phost->gState = HOST_DEV_ATTACHED ;
   \   0000002A   0x2002             MOVS     R0,#+2
   \   0000002C   0x7020             STRB     R0,[R4, #+0]
    840            }
    841          #if (USBH_USE_OS == 1)
    842            osMessagePut ( phost->os_event, USBH_PORT_EVENT, 0);
    843          #endif 
    844            
    845            return USBH_OK;
   \                     ??USBH_LL_Connect_1: (+1)
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0xBD10             POP      {R4,PC}          ;; return
    846          }
    847          
    848          /**
    849            * @brief  USBH_LL_Disconnect 
    850            *         Handle USB Host disconnection event
    851            * @param  phost: Host Handle
    852            * @retval USBH_Status
    853            */

   \                                 In section .text, align 2, keep-with-next
    854          USBH_StatusTypeDef  USBH_LL_Disconnect  (USBH_HandleTypeDef *phost)
    855          {
   \                     USBH_LL_Disconnect: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    856            /*Stop Host */ 
    857            USBH_LL_Stop(phost);  
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0x.... 0x....      BL       USBH_LL_Stop
    858            
    859            /* FRee Control Pipes */
    860            USBH_FreePipe  (phost, phost->Control.pipe_in);
   \   0000000A   0x7921             LDRB     R1,[R4, #+4]
   \   0000000C   0x0020             MOVS     R0,R4
   \   0000000E   0x.... 0x....      BL       USBH_FreePipe
    861            USBH_FreePipe  (phost, phost->Control.pipe_out);  
   \   00000012   0x7961             LDRB     R1,[R4, #+5]
   \   00000014   0x0020             MOVS     R0,R4
   \   00000016   0x.... 0x....      BL       USBH_FreePipe
    862             
    863            phost->device.is_connected = 0; 
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0xF884 0x021E      STRB     R0,[R4, #+542]
    864             
    865            if(phost->pUser != NULL)
   \   00000020   0xF8D4 0x02B4      LDR      R0,[R4, #+692]
   \   00000024   0x2800             CMP      R0,#+0
   \   00000026   0xD004             BEQ.N    ??USBH_LL_Disconnect_0
    866            {    
    867              phost->pUser(phost, HOST_USER_DISCONNECTION);
   \   00000028   0x2105             MOVS     R1,#+5
   \   0000002A   0x0020             MOVS     R0,R4
   \   0000002C   0xF8D4 0x22B4      LDR      R2,[R4, #+692]
   \   00000030   0x4790             BLX      R2
    868            }
    869            USBH_UsrLog("USB Device disconnected"); 
   \                     ??USBH_LL_Disconnect_0: (+1)
   \   00000032   0x....             LDR.N    R0,??DataTable5_28
   \   00000034   0x.... 0x....      BL       printf
   \   00000038   0x....             ADR.N    R0,??DataTable5  ;; "\n"
   \   0000003A   0x.... 0x....      BL       printf
    870            
    871            /* Start the low level driver  */
    872            USBH_LL_Start(phost);
   \   0000003E   0x0020             MOVS     R0,R4
   \   00000040   0x.... 0x....      BL       USBH_LL_Start
    873            
    874            phost->gState = HOST_DEV_DISCONNECTED;
   \   00000044   0x2003             MOVS     R0,#+3
   \   00000046   0x7020             STRB     R0,[R4, #+0]
    875            
    876          #if (USBH_USE_OS == 1)
    877            osMessagePut ( phost->os_event, USBH_PORT_EVENT, 0);
    878          #endif 
    879            
    880            return USBH_OK;
   \   00000048   0x2000             MOVS     R0,#+0
   \   0000004A   0xBD10             POP      {R4,PC}          ;; return
    881          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2:
   \   00000000   0x0A 0x00          DC8      "\n",0x0,0x0
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3:
   \   00000000   0x0A 0x00          DC8      "\n",0x0,0x0
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5:
   \   00000000   0x0A 0x00          DC8      "\n",0x0,0x0
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_1:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_2:
   \   00000000   0x........         DC32     ?_1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_3:
   \   00000000   0x........         DC32     ?_3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_4:
   \   00000000   0x........         DC32     ?_4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_5:
   \   00000000   0x........         DC32     ?_5

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_6:
   \   00000000   0x........         DC32     ?_6

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_7:
   \   00000000   0x........         DC32     ?_7

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_8:
   \   00000000   0x........         DC32     ?_8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_9:
   \   00000000   0x........         DC32     ?_9

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_10:
   \   00000000   0x........         DC32     ?_10

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_11:
   \   00000000   0x........         DC32     ?_11

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_12:
   \   00000000   0x........         DC32     ?_12

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_13:
   \   00000000   0x........         DC32     ?_13

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_14:
   \   00000000   0x........         DC32     ?_14

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_15:
   \   00000000   0x........         DC32     ?_15

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_16:
   \   00000000   0x........         DC32     ?_16

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_17:
   \   00000000   0x........         DC32     ?_17

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_18:
   \   00000000   0x........         DC32     ?_18

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_19:
   \   00000000   0x........         DC32     ?_19

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_20:
   \   00000000   0x........         DC32     ?_20

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_21:
   \   00000000   0x........         DC32     ?_21

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_22:
   \   00000000   0x........         DC32     ?_22

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_23:
   \   00000000   0x........         DC32     ?_23

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_24:
   \   00000000   0x........         DC32     ?_24

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_25:
   \   00000000   0x........         DC32     ?_25

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_26:
   \   00000000   0x........         DC32     ?_26

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_27:
   \   00000000   0x........         DC32     ?_27

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_28:
   \   00000000   0x........         DC32     ?_28

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0x45 0x52          DC8 "ERROR: "
   \              0x52 0x4F    
   \              0x52 0x3A    
   \              0x20 0x00    

   \                                 In section .rodata, align 4
   \                     ?_1:
   \   00000000   0x49 0x6E          DC8 "Invalid Host handle"
   \              0x76 0x61    
   \              0x6C 0x69    
   \              0x64 0x20    
   \              0x48 0x6F    
   \              0x73 0x74    
   \              0x20 0x68    
   \              0x61 0x6E    
   \              0x64 0x6C    
   \              0x65 0x00    

   \                                 In section .rodata, align 2
   \   00000000   0x0A 0x00          DC8 "\012"

   \                                 In section .rodata, align 4
   \                     ?_3:
   \   00000000   0x4D 0x61          DC8 "Max Class Number reached"
   \              0x78 0x20    
   \              0x43 0x6C    
   \              0x61 0x73    
   \              0x73 0x20    
   \              0x4E 0x75    
   \              0x6D 0x62    
   \              0x65 0x72    
   \              0x20 0x72    
   \              0x65 0x61    
   \              0x63 0x68    
   \              0x65 0x64    
   \              0x00         
   \   00000019   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_4:
   \   00000000   0x49 0x6E          DC8 "Invalid Class handle"
   \              0x76 0x61    
   \              0x6C 0x69    
   \              0x64 0x20    
   \              0x43 0x6C    
   \              0x61 0x73    
   \              0x73 0x20    
   \              0x68 0x61    
   \              0x6E 0x64    
   \              0x6C 0x65    
   \              0x00         
   \   00000015   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_5:
   \   00000000   0x53 0x77          DC8 "Switching to Interface (#%d)"
   \              0x69 0x74    
   \              0x63 0x68    
   \              0x69 0x6E    
   \              0x67 0x20    
   \              0x74 0x6F    
   \              0x20 0x49    
   \              0x6E 0x74    
   \              0x65 0x72    
   \              0x66 0x61    
   \              0x63 0x65    
   \              0x20 0x28    
   \              0x23 0x25    
   \              0x64 0x29    
   \              0x00         
   \   0000001D   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_6:
   \   00000000   0x43 0x6C          DC8 "Class    : %xh"
   \              0x61 0x73    
   \              0x73 0x20    
   \              0x20 0x20    
   \              0x20 0x3A    
   \              0x20 0x25    
   \              0x78 0x68    
   \              0x00         
   \   0000000F   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     ?_7:
   \   00000000   0x53 0x75          DC8 "SubClass : %xh"
   \              0x62 0x43    
   \              0x6C 0x61    
   \              0x73 0x73    
   \              0x20 0x3A    
   \              0x20 0x25    
   \              0x78 0x68    
   \              0x00         
   \   0000000F   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     ?_8:
   \   00000000   0x50 0x72          DC8 "Protocol : %xh"
   \              0x6F 0x74    
   \              0x6F 0x63    
   \              0x6F 0x6C    
   \              0x20 0x3A    
   \              0x20 0x25    
   \              0x78 0x68    
   \              0x00         
   \   0000000F   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     ?_9:
   \   00000000   0x43 0x61          DC8 "Cannot Select This Interface."
   \              0x6E 0x6E    
   \              0x6F 0x74    
   \              0x20 0x53    
   \              0x65 0x6C    
   \              0x65 0x63    
   \              0x74 0x20    
   \              0x54 0x68    
   \              0x69 0x73    
   \              0x20 0x49    
   \              0x6E 0x74    
   \              0x65 0x72    
   \              0x66 0x61    
   \              0x63 0x65    
   \              0x2E 0x00    
   \   0000001E   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     ?_10:
   \   00000000   0x55 0x53          DC8 "USB Device Attached"
   \              0x42 0x20    
   \              0x44 0x65    
   \              0x76 0x69    
   \              0x63 0x65    
   \              0x20 0x41    
   \              0x74 0x74    
   \              0x61 0x63    
   \              0x68 0x65    
   \              0x64 0x00    

   \                                 In section .rodata, align 4
   \                     ?_11:
   \   00000000   0x45 0x6E          DC8 "Enumeration done."
   \              0x75 0x6D    
   \              0x65 0x72    
   \              0x61 0x74    
   \              0x69 0x6F    
   \              0x6E 0x20    
   \              0x64 0x6F    
   \              0x6E 0x65    
   \              0x2E 0x00    
   \   00000012   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     ?_12:
   \   00000000   0x54 0x68          DC8 "This device has only 1 configuration."
   \              0x69 0x73    
   \              0x20 0x64    
   \              0x65 0x76    
   \              0x69 0x63    
   \              0x65 0x20    
   \              0x68 0x61    
   \              0x73 0x20    
   \              0x6F 0x6E    
   \              0x6C 0x79    
   \              0x20 0x31    
   \              0x20 0x63    
   \              0x6F 0x6E    
   \              0x66 0x69    
   \              0x67 0x75    
   \              0x72 0x61    
   \              0x74 0x69    
   \              0x6F 0x6E    
   \              0x2E 0x00    
   \   00000026   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     ?_13:
   \   00000000   0x44 0x65          DC8 "Default configuration set."
   \              0x66 0x61    
   \              0x75 0x6C    
   \              0x74 0x20    
   \              0x63 0x6F    
   \              0x6E 0x66    
   \              0x69 0x67    
   \              0x75 0x72    
   \              0x61 0x74    
   \              0x69 0x6F    
   \              0x6E 0x20    
   \              0x73 0x65    
   \              0x74 0x2E    
   \              0x00         
   \   0000001B   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     ?_14:
   \   00000000   0x4E 0x6F          DC8 "No Class has been registered."
   \              0x20 0x43    
   \              0x6C 0x61    
   \              0x73 0x73    
   \              0x20 0x68    
   \              0x61 0x73    
   \              0x20 0x62    
   \              0x65 0x65    
   \              0x6E 0x20    
   \              0x72 0x65    
   \              0x67 0x69    
   \              0x73 0x74    
   \              0x65 0x72    
   \              0x65 0x64    
   \              0x2E 0x00    
   \   0000001E   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     ?_15:
   \   00000000   0x25 0x73          DC8 "%s class started."
   \              0x20 0x63    
   \              0x6C 0x61    
   \              0x73 0x73    
   \              0x20 0x73    
   \              0x74 0x61    
   \              0x72 0x74    
   \              0x65 0x64    
   \              0x2E 0x00    
   \   00000012   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     ?_16:
   \   00000000   0x44 0x65          DC8 "Device not supporting %s class."
   \              0x76 0x69    
   \              0x63 0x65    
   \              0x20 0x6E    
   \              0x6F 0x74    
   \              0x20 0x73    
   \              0x75 0x70    
   \              0x70 0x6F    
   \              0x72 0x74    
   \              0x69 0x6E    
   \              0x67 0x20    
   \              0x25 0x73    
   \              0x20 0x63    
   \              0x6C 0x61    
   \              0x73 0x73    
   \              0x2E 0x00    

   \                                 In section .rodata, align 4
   \                     ?_17:
   \   00000000   0x4E 0x6F          DC8 "No registered class for this device."
   \              0x20 0x72    
   \              0x65 0x67    
   \              0x69 0x73    
   \              0x74 0x65    
   \              0x72 0x65    
   \              0x64 0x20    
   \              0x63 0x6C    
   \              0x61 0x73    
   \              0x73 0x20    
   \              0x66 0x6F    
   \              0x72 0x20    
   \              0x74 0x68    
   \              0x69 0x73    
   \              0x20 0x64    
   \              0x65 0x76    
   \              0x69 0x63    
   \              0x65 0x2E    
   \              0x00         
   \   00000025   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_18:
   \   00000000   0x49 0x6E          DC8 "Invalid Class Driver."
   \              0x76 0x61    
   \              0x6C 0x69    
   \              0x64 0x20    
   \              0x43 0x6C    
   \              0x61 0x73    
   \              0x73 0x20    
   \              0x44 0x72    
   \              0x69 0x76    
   \              0x65 0x72    
   \              0x2E 0x00    
   \   00000016   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     ?_19:
   \   00000000   0x50 0x49          DC8 "PID: %xh"
   \              0x44 0x3A    
   \              0x20 0x25    
   \              0x78 0x68    
   \              0x00         
   \   00000009   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_20:
   \   00000000   0x56 0x49          DC8 "VID: %xh"
   \              0x44 0x3A    
   \              0x20 0x25    
   \              0x78 0x68    
   \              0x00         
   \   00000009   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_21:
   \   00000000   0x41 0x64          DC8 "Address (#%d) assigned."
   \              0x64 0x72    
   \              0x65 0x73    
   \              0x73 0x20    
   \              0x28 0x23    
   \              0x25 0x64    
   \              0x29 0x20    
   \              0x61 0x73    
   \              0x73 0x69    
   \              0x67 0x6E    
   \              0x65 0x64    
   \              0x2E 0x00    

   \                                 In section .rodata, align 4
   \                     ?_22:
   \   00000000   0x4D 0x61          DC8 "Manufacturer : %s"
   \              0x6E 0x75    
   \              0x66 0x61    
   \              0x63 0x74    
   \              0x75 0x72    
   \              0x65 0x72    
   \              0x20 0x3A    
   \              0x20 0x25    
   \              0x73 0x00    
   \   00000012   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     ?_23:
   \   00000000   0x4D 0x61          DC8 "Manufacturer : N/A"
   \              0x6E 0x75    
   \              0x66 0x61    
   \              0x63 0x74    
   \              0x75 0x72    
   \              0x65 0x72    
   \              0x20 0x3A    
   \              0x20 0x4E    
   \              0x2F 0x41    
   \              0x00         
   \   00000013   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     ?_24:
   \   00000000   0x50 0x72          DC8 "Product : %s"
   \              0x6F 0x64    
   \              0x75 0x63    
   \              0x74 0x20    
   \              0x3A 0x20    
   \              0x25 0x73    
   \              0x00         
   \   0000000D   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_25:
   \   00000000   0x50 0x72          DC8 "Product : N/A"
   \              0x6F 0x64    
   \              0x75 0x63    
   \              0x74 0x20    
   \              0x3A 0x20    
   \              0x4E 0x2F    
   \              0x41 0x00    
   \   0000000E   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     ?_26:
   \   00000000   0x53 0x65          DC8 "Serial Number : %s"
   \              0x72 0x69    
   \              0x61 0x6C    
   \              0x20 0x4E    
   \              0x75 0x6D    
   \              0x62 0x65    
   \              0x72 0x20    
   \              0x3A 0x20    
   \              0x25 0x73    
   \              0x00         
   \   00000013   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     ?_27:
   \   00000000   0x53 0x65          DC8 "Serial Number : N/A"
   \              0x72 0x69    
   \              0x61 0x6C    
   \              0x20 0x4E    
   \              0x75 0x6D    
   \              0x62 0x65    
   \              0x72 0x20    
   \              0x3A 0x20    
   \              0x4E 0x2F    
   \              0x41 0x00    

   \                                 In section .rodata, align 4
   \                     ?_28:
   \   00000000   0x55 0x53          DC8 "USB Device disconnected"
   \              0x42 0x20    
   \              0x44 0x65    
   \              0x76 0x69    
   \              0x63 0x65    
   \              0x20 0x64    
   \              0x69 0x73    
   \              0x63 0x6F    
   \              0x6E 0x6E    
   \              0x65 0x63    
   \              0x74 0x65    
   \              0x64 0x00    
    882          
    883          
    884          #if (USBH_USE_OS == 1)  
    885          /**
    886            * @brief  USB Host Thread task
    887            * @param  pvParameters not used
    888            * @retval None
    889            */
    890          static void USBH_Process_OS(void const * argument)
    891          {
    892            osEvent event;
    893            
    894            for(;;)
    895            {
    896              event = osMessageGet(((USBH_HandleTypeDef *)argument)->os_event, osWaitForever );
    897              
    898              if( event.status == osEventMessage )
    899              {
    900                USBH_Process((USBH_HandleTypeDef *)argument);
    901              }
    902             }
    903          }
    904          
    905          /**
    906          * @brief  USBH_LL_NotifyURBChange 
    907          *         Notify URB state Change
    908          * @param  phost: Host handle
    909          * @retval USBH Status
    910          */
    911          USBH_StatusTypeDef  USBH_LL_NotifyURBChange (USBH_HandleTypeDef *phost)
    912          {
    913            osMessagePut ( phost->os_event, USBH_URB_EVENT, 0);
    914            return USBH_OK;
    915          }
    916          #endif  
    917          /**
    918            * @}
    919            */ 
    920          
    921          /**
    922            * @}
    923            */ 
    924          
    925          /**
    926            * @}
    927            */
    928          
    929          /**
    930            * @}
    931            */ 
    932          
    933          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   DeInitStateMachine
       8   USBH_DeInit
         8   -> DeInitStateMachine
         8   -> USBH_LL_Stop
      16   USBH_FindInterface
      12   USBH_FindInterfaceIndex
       0   USBH_GetActiveClass
      24   USBH_HandleEnum
        24   -> USBH_Delay
        24   -> USBH_Get_CfgDesc
        24   -> USBH_Get_DevDesc
        24   -> USBH_Get_StringDesc
        24   -> USBH_OpenPipe
        24   -> USBH_SetAddress
        24   -> printf
       8   USBH_HandleSof
         8   -- Indirect call
      16   USBH_Init
        16   -> DeInitStateMachine
        16   -> USBH_LL_Init
        16   -> printf
       8   USBH_LL_Connect
         8   -- Indirect call
       8   USBH_LL_Disconnect
         8   -- Indirect call
         8   -> USBH_FreePipe
         8   -> USBH_LL_Start
         8   -> USBH_LL_Stop
         8   -> printf
       8   USBH_LL_IncTimer
         8   -> USBH_HandleSof
       0   USBH_LL_SetTimer
      32   USBH_Process
        32   -- Indirect call
        32   -> DeInitStateMachine
        32   -> USBH_AllocPipe
        32   -> USBH_Delay
        32   -> USBH_HandleEnum
        32   -> USBH_LL_GetSpeed
        32   -> USBH_LL_ResetPort
        32   -> USBH_OpenPipe
        32   -> USBH_SetCfg
        32   -> printf
       8   USBH_ReEnumerate
         8   -> DeInitStateMachine
         8   -> USBH_Delay
         8   -> USBH_Start
         8   -> USBH_Stop
      16   USBH_RegisterClass
        16   -> printf
      16   USBH_SelectInterface
        16   -> printf
       8   USBH_Start
         8   -> USBH_LL_DriverVBUS
         8   -> USBH_LL_Start
       8   USBH_Stop
         8   -> USBH_FreePipe
         8   -> USBH_LL_DriverVBUS
         8   -> USBH_LL_Stop


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable2
       4  ??DataTable3
       4  ??DataTable5
       4  ??DataTable5_1
       4  ??DataTable5_10
       4  ??DataTable5_11
       4  ??DataTable5_12
       4  ??DataTable5_13
       4  ??DataTable5_14
       4  ??DataTable5_15
       4  ??DataTable5_16
       4  ??DataTable5_17
       4  ??DataTable5_18
       4  ??DataTable5_19
       4  ??DataTable5_2
       4  ??DataTable5_20
       4  ??DataTable5_21
       4  ??DataTable5_22
       4  ??DataTable5_23
       4  ??DataTable5_24
       4  ??DataTable5_25
       4  ??DataTable5_26
       4  ??DataTable5_27
       4  ??DataTable5_28
       4  ??DataTable5_3
       4  ??DataTable5_4
       4  ??DataTable5_5
       4  ??DataTable5_6
       4  ??DataTable5_7
       4  ??DataTable5_8
       4  ??DataTable5_9
       8  ?_0
      20  ?_1
      20  ?_10
      20  ?_11
      40  ?_12
      28  ?_13
      32  ?_14
      20  ?_15
      32  ?_16
      40  ?_17
      24  ?_18
      12  ?_19
       2  ?_2
      12  ?_20
      24  ?_21
      20  ?_22
      20  ?_23
      16  ?_24
      16  ?_25
      20  ?_26
      20  ?_27
      24  ?_28
      28  ?_3
      24  ?_4
      32  ?_5
      16  ?_6
      16  ?_7
      16  ?_8
      32  ?_9
      88  DeInitStateMachine
      36  USBH_DeInit
      92  USBH_FindInterface
      66  USBH_FindInterfaceIndex
       6  USBH_GetActiveClass
     534  USBH_HandleEnum
      30  USBH_HandleSof
      80  USBH_Init
      50  USBH_LL_Connect
      76  USBH_LL_Disconnect
      22  USBH_LL_IncTimer
       6  USBH_LL_SetTimer
     634  USBH_Process
      32  USBH_ReEnumerate
     104  USBH_RegisterClass
     152  USBH_SelectInterface
      22  USBH_Start
      38  USBH_Stop

 
   634 bytes in section .rodata
 2 192 bytes in section .text
 
 2 192 bytes of CODE  memory
   634 bytes of CONST memory

Errors: none
Warnings: none
