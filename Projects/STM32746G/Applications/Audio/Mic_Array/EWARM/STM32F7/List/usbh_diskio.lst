###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.2.10312/W32 for ARM       27/Feb/2016  21:24:43
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\Src\usbh_diskio.c
#    Command line =  
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\Src\usbh_diskio.c
#        -D USE_HAL_DRIVER -D STM32F746xx -D USE_STM32746G_DISCO -D
#        USE_IOEXPANDER -D USE_USB_FS -lC
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
#        -lA
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
#        -o
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M7 -e --fpu=VFPv5_sp --dlib_config "D:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.3\arm\INC\c\DLib_Config_Full.h"
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\Inc\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\CMSIS\Device\ST\STM32F7xx\Include\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\STM32F7xx_HAL_Driver\Inc\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\STM32746G-Discovery\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\Components\Common\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Log\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Fonts\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\CPU\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_Device_Library\Core\Inc\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Core\Inc\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Class\MSC\Inc\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\drivers\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_Audio\Addons\PDM\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_Device_Library\Class\AUDIO\Inc\
#        -On --use_c++_inline --require_prototypes -I "D:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.3\arm\CMSIS\Include\" -D
#        ARM_MATH_CM7
#    List file    =  
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List\usbh_diskio.lst
#    Object file  =  
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj\usbh_diskio.o
#
###############################################################################

H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\Src\usbh_diskio.c
      1          /**
      2            ******************************************************************************
      3            * @file    Audio/Audio_playback_and_record/Src/usbh_diskio.c
      4            * @author  MCD Application Team
      5            * @version V1.0.0
      6            * @date    25-June-2015
      7            * @brief   USB diskio interface
      8            ******************************************************************************
      9            * @attention
     10            *
     11            * <h2><center>&copy; COPYRIGHT(c) 2015 STMicroelectronics</center></h2>
     12            *
     13            * Redistribution and use in source and binary forms, with or without modification,
     14            * are permitted provided that the following conditions are met:
     15            *   1. Redistributions of source code must retain the above copyright notice,
     16            *      this list of conditions and the following disclaimer.
     17            *   2. Redistributions in binary form must reproduce the above copyright notice,
     18            *      this list of conditions and the following disclaimer in the documentation
     19            *      and/or other materials provided with the distribution.
     20            *   3. Neither the name of STMicroelectronics nor the names of its contributors
     21            *      may be used to endorse or promote products derived from this software
     22            *      without specific prior written permission.
     23            *
     24            * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
     25            * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     26            * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     27            * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
     28            * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
     29            * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
     30            * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
     31            * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
     32            * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
     33            * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     34            *
     35            ******************************************************************************
     36            */
     37          
     38          /* Includes ------------------------------------------------------------------*/
     39          #include "ffconf.h"	
     40          #include "diskio.h"
     41          #include "usbh_msc.h"
     42          
     43          /* Private typedef -----------------------------------------------------------*/
     44          /* Private define ------------------------------------------------------------*/
     45          extern USBH_HandleTypeDef  hUSBHost;
     46          
     47          /* Private function prototypes -----------------------------------------------*/
     48          DWORD get_fattime(void);
     49          /* Private functions ---------------------------------------------------------*/
     50          
     51          /**
     52            * @brief  Initializes a Disk
     53            * @param  pdrv: Physical drive number
     54            * @retval DSTATUS: Operation status
     55            */

   \                                 In section .text, align 2, keep-with-next
     56          DSTATUS disk_initialize(BYTE pdrv)
     57          {
   \                     disk_initialize: (+1)
   \   00000000   0x0001             MOVS     R1,R0
     58            return RES_OK;
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0x4770             BX       LR               ;; return
     59          }
     60          
     61          /**
     62            * @brief  Gets Disk Status
     63            * @param  pdrv: Physical drive number
     64            * @retval DSTATUS: Operation status
     65            */

   \                                 In section .text, align 2, keep-with-next
     66          DSTATUS disk_status (BYTE pdrv)
     67          {
   \                     disk_status: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
     68            DRESULT res = RES_ERROR;
   \   00000004   0x2501             MOVS     R5,#+1
     69            
     70            if(USBH_MSC_UnitIsReady (&hUSBHost, pdrv))
   \   00000006   0x0021             MOVS     R1,R4
   \   00000008   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000A   0x....             LDR.N    R0,??DataTable3_1
   \   0000000C   0x.... 0x....      BL       USBH_MSC_UnitIsReady
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD002             BEQ.N    ??disk_status_0
     71            {
     72              res = RES_OK;
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0x0005             MOVS     R5,R0
   \   00000018   0xE001             B.N      ??disk_status_1
     73            }
     74            else
     75            {
     76              res = RES_ERROR;
   \                     ??disk_status_0: (+1)
   \   0000001A   0x2001             MOVS     R0,#+1
   \   0000001C   0x0005             MOVS     R5,R0
     77            }
     78            
     79            return res;
   \                     ??disk_status_1: (+1)
   \   0000001E   0x0028             MOVS     R0,R5
   \   00000020   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000022   0xBD32             POP      {R1,R4,R5,PC}    ;; return
     80          }
     81          
     82          /**
     83            * @brief  Reads Sector
     84            * @param  pdrv: Physical drive number
     85            * @param  *buff: Data buffer to store read data
     86            * @param  sector: Sector address (LBA)
     87            * @param  count: Number of sectors to read
     88            * @retval DRESULT: Operation result
     89            */

   \                                 In section .text, align 2, keep-with-next
     90          DRESULT disk_read (BYTE pdrv, BYTE *buff, DWORD sector, UINT count)
     91          {
   \                     disk_read: (+1)
   \   00000000   0xE92D 0x4FF4      PUSH     {R2,R4-R11,LR}
   \   00000004   0xF5AD 0x7D0E      SUB      SP,SP,#+568
   \   00000008   0x0004             MOVS     R4,R0
   \   0000000A   0x000D             MOVS     R5,R1
   \   0000000C   0x4698             MOV      R8,R3
     92            DRESULT res = RES_ERROR;
   \   0000000E   0x2601             MOVS     R6,#+1
     93            MSC_LUNTypeDef info;
     94            USBH_StatusTypeDef  status = USBH_OK;
   \   00000010   0x2700             MOVS     R7,#+0
     95            DWORD scratch [_MAX_SS / 4];
     96            
     97            if ((DWORD)buff & 3) /* DMA Alignment issue, do single up to aligned buffer */
   \   00000012   0xF015 0x0003      ANDS     R0,R5,#0x3
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD025             BEQ.N    ??disk_read_0
     98            {
     99              while ((count--)&&(status == USBH_OK))
   \                     ??disk_read_1: (+1)
   \   0000001A   0x4640             MOV      R0,R8
   \   0000001C   0xF1B0 0x0801      SUBS     R8,R0,#+1
   \   00000020   0x2800             CMP      R0,#+0
   \   00000022   0xD02A             BEQ.N    ??disk_read_2
   \   00000024   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000026   0x2F00             CMP      R7,#+0
   \   00000028   0xD127             BNE.N    ??disk_read_2
    100              {
    101                status = USBH_MSC_Read(&hUSBHost, pdrv, sector + count, (uint8_t *)scratch, 1);
   \   0000002A   0x2001             MOVS     R0,#+1
   \   0000002C   0x9000             STR      R0,[SP, #+0]
   \   0000002E   0xAB01             ADD      R3,SP,#+4
   \   00000030   0x988E             LDR      R0,[SP, #+568]
   \   00000032   0xEB18 0x0200      ADDS     R2,R8,R0
   \   00000036   0x0021             MOVS     R1,R4
   \   00000038   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000003A   0x....             LDR.N    R0,??DataTable3_1
   \   0000003C   0x.... 0x....      BL       USBH_MSC_Read
   \   00000040   0x0007             MOVS     R7,R0
    102                if(status == USBH_OK)
   \   00000042   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000044   0x2F00             CMP      R7,#+0
   \   00000046   0xD10D             BNE.N    ??disk_read_3
    103                {
    104                  memcpy(&buff[count * _MAX_SS], scratch, _MAX_SS);
   \   00000048   0xF44F 0x7900      MOV      R9,#+512
   \   0000004C   0xF10D 0x0A04      ADD      R10,SP,#+4
   \   00000050   0xF44F 0x7000      MOV      R0,#+512
   \   00000054   0xFB00 0x5B08      MLA      R11,R0,R8,R5
   \   00000058   0x464A             MOV      R2,R9
   \   0000005A   0x4651             MOV      R1,R10
   \   0000005C   0x4658             MOV      R0,R11
   \   0000005E   0x.... 0x....      BL       __aeabi_memcpy
    105                }
   \   00000062   0xE7DA             B.N      ??disk_read_1
    106                else
    107                {
    108                  break;
   \                     ??disk_read_3: (+1)
   \   00000064   0xE009             B.N      ??disk_read_2
    109                }
    110              }
    111            }
    112            else
    113            {
    114              status = USBH_MSC_Read(&hUSBHost, pdrv, sector, buff, count);
   \                     ??disk_read_0: (+1)
   \   00000066   0xF8CD 0x8000      STR      R8,[SP, #+0]
   \   0000006A   0x002B             MOVS     R3,R5
   \   0000006C   0x9A8E             LDR      R2,[SP, #+568]
   \   0000006E   0x0021             MOVS     R1,R4
   \   00000070   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000072   0x....             LDR.N    R0,??DataTable3_1
   \   00000074   0x.... 0x....      BL       USBH_MSC_Read
   \   00000078   0x0007             MOVS     R7,R0
    115            }
    116            
    117            if(status == USBH_OK)
   \                     ??disk_read_2: (+1)
   \   0000007A   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000007C   0x2F00             CMP      R7,#+0
   \   0000007E   0xD102             BNE.N    ??disk_read_4
    118            {
    119              res = RES_OK;
   \   00000080   0x2000             MOVS     R0,#+0
   \   00000082   0x0006             MOVS     R6,R0
   \   00000084   0xE01B             B.N      ??disk_read_5
    120            }
    121            else
    122            {
    123              USBH_MSC_GetLUNInfo(&hUSBHost, pdrv, &info); 
   \                     ??disk_read_4: (+1)
   \   00000086   0xAA81             ADD      R2,SP,#+516
   \   00000088   0x0021             MOVS     R1,R4
   \   0000008A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000008C   0x....             LDR.N    R0,??DataTable3_1
   \   0000008E   0x.... 0x....      BL       USBH_MSC_GetLUNInfo
    124              
    125              switch (info.sense.asc)
   \   00000092   0xF89D 0x0211      LDRB     R0,[SP, #+529]
   \   00000096   0x2804             CMP      R0,#+4
   \   00000098   0xD003             BEQ.N    ??disk_read_6
   \   0000009A   0x2828             CMP      R0,#+40
   \   0000009C   0xD001             BEQ.N    ??disk_read_6
   \   0000009E   0x283A             CMP      R0,#+58
   \   000000A0   0xD10B             BNE.N    ??disk_read_7
    126              {
    127              case SCSI_ASC_LOGICAL_UNIT_NOT_READY:
    128              case SCSI_ASC_MEDIUM_NOT_PRESENT:
    129              case SCSI_ASC_NOT_READY_TO_READY_CHANGE: 
    130                USBH_ErrLog("USB Disk is not ready!");  
   \                     ??disk_read_6: (+1)
   \   000000A2   0x....             LDR.N    R0,??DataTable3_2
   \   000000A4   0x.... 0x....      BL       printf
   \   000000A8   0x....             LDR.N    R0,??DataTable3_3
   \   000000AA   0x.... 0x....      BL       printf
   \   000000AE   0x....             ADR.N    R0,??DataTable3  ;; "\n"
   \   000000B0   0x.... 0x....      BL       printf
    131                res = RES_NOTRDY;
   \   000000B4   0x2003             MOVS     R0,#+3
   \   000000B6   0x0006             MOVS     R6,R0
    132                break; 
   \   000000B8   0xE001             B.N      ??disk_read_5
    133                
    134              default:
    135                res = RES_ERROR;
   \                     ??disk_read_7: (+1)
   \   000000BA   0x2001             MOVS     R0,#+1
   \   000000BC   0x0006             MOVS     R6,R0
    136                break;
    137              }
    138            }
    139            
    140            return res;
   \                     ??disk_read_5: (+1)
   \   000000BE   0x0030             MOVS     R0,R6
   \   000000C0   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000C2   0xF50D 0x7D0F      ADD      SP,SP,#+572
   \   000000C6   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    141          }
    142          
    143          /**
    144            * @brief  Writes Sector
    145            * @param  pdrv: Physical drive number
    146            * @param  *buff: Data to be written
    147            * @param  sector: Sector address (LBA)
    148            * @param  count: Number of sectors to write
    149            * @retval DRESULT: Operation result
    150            */
    151          #if _USE_WRITE

   \                                 In section .text, align 2, keep-with-next
    152          DRESULT disk_write (BYTE pdrv, const BYTE* buff, DWORD sector, UINT count)
    153          {
   \                     disk_write: (+1)
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0xF5AD 0x7D0F      SUB      SP,SP,#+572
   \   00000008   0x0004             MOVS     R4,R0
   \   0000000A   0x000D             MOVS     R5,R1
   \   0000000C   0x0016             MOVS     R6,R2
   \   0000000E   0x4699             MOV      R9,R3
    154            DRESULT res = RES_ERROR; 
   \   00000010   0x2701             MOVS     R7,#+1
    155            MSC_LUNTypeDef info;
    156            USBH_StatusTypeDef  status = USBH_OK;  
   \   00000012   0xF05F 0x0800      MOVS     R8,#+0
    157            DWORD scratch [_MAX_SS / 4];  
    158            
    159            if ((DWORD)buff & 3) /* DMA Alignment issue, do single up to aligned buffer */
   \   00000016   0xF015 0x0003      ANDS     R0,R5,#0x3
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD023             BEQ.N    ??disk_write_0
    160            {
    161              while (count--)
   \                     ??disk_write_1: (+1)
   \   0000001E   0x4648             MOV      R0,R9
   \   00000020   0xF1B0 0x0901      SUBS     R9,R0,#+1
   \   00000024   0x2800             CMP      R0,#+0
   \   00000026   0xD028             BEQ.N    ??disk_write_2
    162              {
    163                memcpy (scratch, &buff[count * _MAX_SS], _MAX_SS);
   \   00000028   0xF44F 0x7A00      MOV      R10,#+512
   \   0000002C   0xF44F 0x7000      MOV      R0,#+512
   \   00000030   0xFB00 0x5009      MLA      R0,R0,R9,R5
   \   00000034   0x9001             STR      R0,[SP, #+4]
   \   00000036   0xF10D 0x0B08      ADD      R11,SP,#+8
   \   0000003A   0x4652             MOV      R2,R10
   \   0000003C   0x9901             LDR      R1,[SP, #+4]
   \   0000003E   0x4658             MOV      R0,R11
   \   00000040   0x.... 0x....      BL       __aeabi_memcpy
    164                
    165                status = USBH_MSC_Write(&hUSBHost, pdrv, sector + count, (BYTE *)scratch, 1);
   \   00000044   0x2001             MOVS     R0,#+1
   \   00000046   0x9000             STR      R0,[SP, #+0]
   \   00000048   0xAB02             ADD      R3,SP,#+8
   \   0000004A   0xEB19 0x0206      ADDS     R2,R9,R6
   \   0000004E   0x0021             MOVS     R1,R4
   \   00000050   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000052   0x....             LDR.N    R0,??DataTable3_1
   \   00000054   0x.... 0x....      BL       USBH_MSC_Write
   \   00000058   0x4680             MOV      R8,R0
    166                if(status == USBH_FAIL)
   \   0000005A   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000005E   0xF1B8 0x0F02      CMP      R8,#+2
   \   00000062   0xD1DC             BNE.N    ??disk_write_1
    167                {
    168                  break;
   \   00000064   0xE009             B.N      ??disk_write_2
    169                }
    170              }
    171            }
    172            else
    173            {
    174              status = USBH_MSC_Write(&hUSBHost, pdrv, sector, (BYTE *)buff, count);
   \                     ??disk_write_0: (+1)
   \   00000066   0xF8CD 0x9000      STR      R9,[SP, #+0]
   \   0000006A   0x002B             MOVS     R3,R5
   \   0000006C   0x0032             MOVS     R2,R6
   \   0000006E   0x0021             MOVS     R1,R4
   \   00000070   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000072   0x....             LDR.N    R0,??DataTable3_1
   \   00000074   0x.... 0x....      BL       USBH_MSC_Write
   \   00000078   0x4680             MOV      R8,R0
    175            }
    176            
    177            if(status == USBH_OK)
   \                     ??disk_write_2: (+1)
   \   0000007A   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000007E   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000082   0xD102             BNE.N    ??disk_write_3
    178            {
    179              res = RES_OK;
   \   00000084   0x2000             MOVS     R0,#+0
   \   00000086   0x0007             MOVS     R7,R0
   \   00000088   0xE02A             B.N      ??disk_write_4
    180            }
    181            else
    182            {
    183              USBH_MSC_GetLUNInfo(&hUSBHost, pdrv, &info); 
   \                     ??disk_write_3: (+1)
   \   0000008A   0xAA82             ADD      R2,SP,#+520
   \   0000008C   0x0021             MOVS     R1,R4
   \   0000008E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000090   0x....             LDR.N    R0,??DataTable3_1
   \   00000092   0x.... 0x....      BL       USBH_MSC_GetLUNInfo
    184              
    185              switch (info.sense.asc)
   \   00000096   0xF89D 0x0215      LDRB     R0,[SP, #+533]
   \   0000009A   0x2804             CMP      R0,#+4
   \   0000009C   0xD012             BEQ.N    ??disk_write_5
   \   0000009E   0x2827             CMP      R0,#+39
   \   000000A0   0xD004             BEQ.N    ??disk_write_6
   \   000000A2   0x2828             CMP      R0,#+40
   \   000000A4   0xD00E             BEQ.N    ??disk_write_5
   \   000000A6   0x283A             CMP      R0,#+58
   \   000000A8   0xD00C             BEQ.N    ??disk_write_5
   \   000000AA   0xE017             B.N      ??disk_write_7
    186              {
    187              case SCSI_ASC_WRITE_PROTECTED:
    188                USBH_ErrLog("USB Disk is Write protected!");
   \                     ??disk_write_6: (+1)
   \   000000AC   0x....             LDR.N    R0,??DataTable3_2
   \   000000AE   0x.... 0x....      BL       printf
   \   000000B2   0x....             LDR.N    R0,??DataTable3_4
   \   000000B4   0x.... 0x....      BL       printf
   \   000000B8   0x....             ADR.N    R0,??DataTable3  ;; "\n"
   \   000000BA   0x.... 0x....      BL       printf
    189                res = RES_WRPRT;
   \   000000BE   0x2002             MOVS     R0,#+2
   \   000000C0   0x0007             MOVS     R7,R0
    190                break;
   \   000000C2   0xE00D             B.N      ??disk_write_4
    191                
    192              case SCSI_ASC_LOGICAL_UNIT_NOT_READY:
    193              case SCSI_ASC_MEDIUM_NOT_PRESENT:
    194              case SCSI_ASC_NOT_READY_TO_READY_CHANGE:
    195                USBH_ErrLog("USB Disk is not ready!");      
   \                     ??disk_write_5: (+1)
   \   000000C4   0x....             LDR.N    R0,??DataTable3_2
   \   000000C6   0x.... 0x....      BL       printf
   \   000000CA   0x....             LDR.N    R0,??DataTable3_3
   \   000000CC   0x.... 0x....      BL       printf
   \   000000D0   0x....             ADR.N    R0,??DataTable3  ;; "\n"
   \   000000D2   0x.... 0x....      BL       printf
    196                res = RES_NOTRDY;
   \   000000D6   0x2003             MOVS     R0,#+3
   \   000000D8   0x0007             MOVS     R7,R0
    197                break; 
   \   000000DA   0xE001             B.N      ??disk_write_4
    198                
    199              default:
    200                res = RES_ERROR;
   \                     ??disk_write_7: (+1)
   \   000000DC   0x2001             MOVS     R0,#+1
   \   000000DE   0x0007             MOVS     R7,R0
    201                break;
    202              }
    203            }
    204            
    205            return res;   
   \                     ??disk_write_4: (+1)
   \   000000E0   0x0038             MOVS     R0,R7
   \   000000E2   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000E4   0xF50D 0x7D0F      ADD      SP,SP,#+572
   \   000000E8   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    206          }
    207          #endif
    208          
    209          /**
    210            * @brief  I/O control operation
    211            * @param  pdrv: Physical drive number
    212            * @param  cmd: Control code
    213            * @param  *buff: Buffer to send/receive control data
    214            * @retval DRESULT: Operation result
    215            */
    216          #if _USE_IOCTL == 1

   \                                 In section .text, align 2, keep-with-next
    217          DRESULT disk_ioctl(BYTE pdrv, BYTE cmd, void *buff)
    218          {
   \                     disk_ioctl: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB08D             SUB      SP,SP,#+52
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
    219            DRESULT res = RES_OK;
   \   0000000A   0x2700             MOVS     R7,#+0
    220            MSC_LUNTypeDef info;
    221            
    222            switch (cmd) {
   \   0000000C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000000E   0x2D00             CMP      R5,#+0
   \   00000010   0xD005             BEQ.N    ??disk_ioctl_0
   \   00000012   0x2D02             CMP      R5,#+2
   \   00000014   0xD016             BEQ.N    ??disk_ioctl_1
   \   00000016   0xD305             BCC.N    ??disk_ioctl_2
   \   00000018   0x2D03             CMP      R5,#+3
   \   0000001A   0xD024             BEQ.N    ??disk_ioctl_3
   \   0000001C   0xE034             B.N      ??disk_ioctl_4
    223              /* Make sure that no pending write process */  
    224            case CTRL_SYNC:		
    225              res = RES_OK;
   \                     ??disk_ioctl_0: (+1)
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0x0007             MOVS     R7,R0
    226              break;
   \   00000022   0xE033             B.N      ??disk_ioctl_5
    227              
    228              /* Get number of sectors on the disk (DWORD) */ 
    229            case GET_SECTOR_COUNT:	
    230              if(USBH_MSC_GetLUNInfo(&hUSBHost, pdrv, &info) == USBH_OK)
   \                     ??disk_ioctl_2: (+1)
   \   00000024   0x466A             MOV      R2,SP
   \   00000026   0x0021             MOVS     R1,R4
   \   00000028   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000002A   0x....             LDR.N    R0,??DataTable3_1
   \   0000002C   0x.... 0x....      BL       USBH_MSC_GetLUNInfo
   \   00000030   0x2800             CMP      R0,#+0
   \   00000032   0xD104             BNE.N    ??disk_ioctl_6
    231              {
    232                *(DWORD*)buff = info.capacity.block_nbr;
   \   00000034   0x9801             LDR      R0,[SP, #+4]
   \   00000036   0x6030             STR      R0,[R6, #+0]
    233                res = RES_OK;
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0x0007             MOVS     R7,R0
   \   0000003C   0xE001             B.N      ??disk_ioctl_7
    234              }
    235              else
    236              {
    237                res = RES_ERROR;
   \                     ??disk_ioctl_6: (+1)
   \   0000003E   0x2001             MOVS     R0,#+1
   \   00000040   0x0007             MOVS     R7,R0
    238              }
    239              break;
   \                     ??disk_ioctl_7: (+1)
   \   00000042   0xE023             B.N      ??disk_ioctl_5
    240              
    241            case GET_SECTOR_SIZE :	/* Get R/W sector size (WORD) */
    242              if(USBH_MSC_GetLUNInfo(&hUSBHost, pdrv, &info) == USBH_OK)
   \                     ??disk_ioctl_1: (+1)
   \   00000044   0x466A             MOV      R2,SP
   \   00000046   0x0021             MOVS     R1,R4
   \   00000048   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000004A   0x....             LDR.N    R0,??DataTable3_1
   \   0000004C   0x.... 0x....      BL       USBH_MSC_GetLUNInfo
   \   00000050   0x2800             CMP      R0,#+0
   \   00000052   0xD105             BNE.N    ??disk_ioctl_8
    243              {
    244                *(DWORD*)buff = info.capacity.block_size;
   \   00000054   0xF8BD 0x0008      LDRH     R0,[SP, #+8]
   \   00000058   0x6030             STR      R0,[R6, #+0]
    245                res = RES_OK;
   \   0000005A   0x2000             MOVS     R0,#+0
   \   0000005C   0x0007             MOVS     R7,R0
   \   0000005E   0xE001             B.N      ??disk_ioctl_9
    246              }
    247              else
    248              {
    249                res = RES_ERROR;
   \                     ??disk_ioctl_8: (+1)
   \   00000060   0x2001             MOVS     R0,#+1
   \   00000062   0x0007             MOVS     R7,R0
    250              }
    251              break;
   \                     ??disk_ioctl_9: (+1)
   \   00000064   0xE012             B.N      ??disk_ioctl_5
    252              
    253              /* Get erase block size in unit of sector (DWORD) */  
    254            case GET_BLOCK_SIZE:	
    255              
    256              if(USBH_MSC_GetLUNInfo(&hUSBHost, pdrv, &info) == USBH_OK)
   \                     ??disk_ioctl_3: (+1)
   \   00000066   0x466A             MOV      R2,SP
   \   00000068   0x0021             MOVS     R1,R4
   \   0000006A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000006C   0x....             LDR.N    R0,??DataTable3_1
   \   0000006E   0x.... 0x....      BL       USBH_MSC_GetLUNInfo
   \   00000072   0x2800             CMP      R0,#+0
   \   00000074   0xD105             BNE.N    ??disk_ioctl_10
    257              {
    258                *(DWORD*)buff = info.capacity.block_size;
   \   00000076   0xF8BD 0x0008      LDRH     R0,[SP, #+8]
   \   0000007A   0x6030             STR      R0,[R6, #+0]
    259                res = RES_OK;
   \   0000007C   0x2000             MOVS     R0,#+0
   \   0000007E   0x0007             MOVS     R7,R0
   \   00000080   0xE001             B.N      ??disk_ioctl_11
    260              }
    261              else
    262              {
    263                res = RES_ERROR;
   \                     ??disk_ioctl_10: (+1)
   \   00000082   0x2001             MOVS     R0,#+1
   \   00000084   0x0007             MOVS     R7,R0
    264              }
    265              
    266              break;
   \                     ??disk_ioctl_11: (+1)
   \   00000086   0xE001             B.N      ??disk_ioctl_5
    267              
    268              
    269            default:
    270              res = RES_PARERR;
   \                     ??disk_ioctl_4: (+1)
   \   00000088   0x2004             MOVS     R0,#+4
   \   0000008A   0x0007             MOVS     R7,R0
    271            }
    272            
    273            return res;
   \                     ??disk_ioctl_5: (+1)
   \   0000008C   0x0038             MOVS     R0,R7
   \   0000008E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000090   0xB00D             ADD      SP,SP,#+52
   \   00000092   0xBDF0             POP      {R4-R7,PC}       ;; return
    274          }
    275          #endif
    276          
    277          /**
    278            * @brief  Gets Time from RTC 
    279            * @param  None
    280            * @retval Time in DWORD
    281            */

   \                                 In section .text, align 2, keep-with-next
    282          DWORD get_fattime(void)
    283          {
    284            return 0;
   \                     get_fattime: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x4770             BX       LR               ;; return
    285          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3:
   \   00000000   0x0A 0x00          DC8      "\n",0x0,0x0
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_1:
   \   00000000   0x........         DC32     hUSBHost

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_2:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_3:
   \   00000000   0x........         DC32     ?_1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_4:
   \   00000000   0x........         DC32     ?_3

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0x45 0x52          DC8 "ERROR: "
   \              0x52 0x4F    
   \              0x52 0x3A    
   \              0x20 0x00    

   \                                 In section .rodata, align 4
   \                     ?_1:
   \   00000000   0x55 0x53          DC8 "USB Disk is not ready!"
   \              0x42 0x20    
   \              0x44 0x69    
   \              0x73 0x6B    
   \              0x20 0x69    
   \              0x73 0x20    
   \              0x6E 0x6F    
   \              0x74 0x20    
   \              0x72 0x65    
   \              0x61 0x64    
   \              0x79 0x21    
   \              0x00         
   \   00000017   0x00               DC8 0

   \                                 In section .rodata, align 2
   \   00000000   0x0A 0x00          DC8 "\012"

   \                                 In section .rodata, align 4
   \                     ?_3:
   \   00000000   0x55 0x53          DC8 "USB Disk is Write protected!"
   \              0x42 0x20    
   \              0x44 0x69    
   \              0x73 0x6B    
   \              0x20 0x69    
   \              0x73 0x20    
   \              0x57 0x72    
   \              0x69 0x74    
   \              0x65 0x20    
   \              0x70 0x72    
   \              0x6F 0x74    
   \              0x65 0x63    
   \              0x74 0x65    
   \              0x64 0x21    
   \              0x00         
   \   0000001D   0x00 0x00          DC8 0, 0, 0
   \              0x00         
    286          
    287          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   disk_initialize
      72   disk_ioctl
        72   -> USBH_MSC_GetLUNInfo
     608   disk_read
       608   -> USBH_MSC_GetLUNInfo
       608   -> USBH_MSC_Read
       608   -> __aeabi_memcpy
       608   -> printf
      16   disk_status
        16   -> USBH_MSC_UnitIsReady
     608   disk_write
       608   -> USBH_MSC_GetLUNInfo
       608   -> USBH_MSC_Write
       608   -> __aeabi_memcpy
       608   -> printf
       0   get_fattime


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable3
       4  ??DataTable3_1
       4  ??DataTable3_2
       4  ??DataTable3_3
       4  ??DataTable3_4
       8  ?_0
      24  ?_1
       2  ?_2
      32  ?_3
       6  disk_initialize
     148  disk_ioctl
     202  disk_read
      36  disk_status
     236  disk_write
       4  get_fattime

 
  66 bytes in section .rodata
 652 bytes in section .text
 
 652 bytes of CODE  memory
  66 bytes of CONST memory

Errors: none
Warnings: none
