###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.2.10312/W32 for ARM       22/Feb/2016  17:57:54
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_tim.c
#    Command line =  
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_tim.c
#        -D USE_HAL_DRIVER -D STM32F746xx -D USE_STM32746G_DISCO -D
#        USE_IOEXPANDER -D USE_USB_FS -lC
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
#        -lA
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
#        -o
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj
#        --no_unroll --debug --endian=little --cpu=Cortex-M7 -e --fpu=VFPv5_sp
#        --dlib_config "D:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Full.h" -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\CMSIS\Device\ST\STM32F7xx\Include\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\STM32F7xx_HAL_Driver\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\STM32746G-Discovery\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\Components\Common\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Log\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Fonts\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\CPU\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_Device_Library\Core\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Core\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Class\MSC\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\drivers\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_Audio\Addons\PDM\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_Device_Library\Class\AUDIO\Inc\
#        -Ohs --use_c++_inline --require_prototypes -I "D:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.3\arm\CMSIS\Include\" -D
#        ARM_MATH_CM7
#    List file    =  
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List\stm32f7xx_hal_tim.lst
#    Object file  =  
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj\stm32f7xx_hal_tim.o
#
###############################################################################

D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_tim.c
      1          /**
                   ^
Warning[Pa050]: non-native end of line sequence detected (this diagnostic is
          only issued once)
      2            ******************************************************************************
      3            * @file    stm32f7xx_hal_tim.c
      4            * @author  MCD Application Team
      5            * @version V1.0.1
      6            * @date    25-June-2015
      7            * @brief   TIM HAL module driver.
      8            *          This file provides firmware functions to manage the following 
      9            *          functionalities of the Timer (TIM) peripheral:
     10            *           + Time Base Initialization
     11            *           + Time Base Start
     12            *           + Time Base Start Interruption
     13            *           + Time Base Start DMA
     14            *           + Time Output Compare/PWM Initialization
     15            *           + Time Output Compare/PWM Channel Configuration
     16            *           + Time Output Compare/PWM  Start
     17            *           + Time Output Compare/PWM  Start Interruption
     18            *           + Time Output Compare/PWM Start DMA
     19            *           + Time Input Capture Initialization
     20            *           + Time Input Capture Channel Configuration
     21            *           + Time Input Capture Start
     22            *           + Time Input Capture Start Interruption 
     23            *           + Time Input Capture Start DMA
     24            *           + Time One Pulse Initialization
     25            *           + Time One Pulse Channel Configuration
     26            *           + Time One Pulse Start 
     27            *           + Time Encoder Interface Initialization
     28            *           + Time Encoder Interface Start
     29            *           + Time Encoder Interface Start Interruption
     30            *           + Time Encoder Interface Start DMA
     31            *           + Commutation Event configuration with Interruption and DMA
     32            *           + Time OCRef clear configuration
     33            *           + Time External Clock configuration
     34            @verbatim 
     35            ==============================================================================
     36                                ##### TIMER Generic features #####
     37            ==============================================================================
     38            [..] The Timer features include: 
     39                 (#) 16-bit up, down, up/down auto-reload counter.
     40                 (#) 16-bit programmable prescaler allowing dividing (also on the fly) the 
     41                     counter clock frequency either by any factor between 1 and 65536.
     42                 (#) Up to 4 independent channels for:
     43                     (++) Input Capture
     44                     (++) Output Compare
     45                     (++) PWM generation (Edge and Center-aligned Mode)
     46                     (++) One-pulse mode output               
     47             
     48                                  ##### How to use this driver #####
     49            ==============================================================================
     50              [..]
     51               (#) Initialize the TIM low level resources by implementing the following functions 
     52                   depending from feature used :
     53                     (++) Time Base : HAL_TIM_Base_MspInit() 
     54                     (++) Input Capture : HAL_TIM_IC_MspInit()
     55                     (++) Output Compare : HAL_TIM_OC_MspInit()
     56                     (++) PWM generation : HAL_TIM_PWM_MspInit()
     57                     (++) One-pulse mode output : HAL_TIM_OnePulse_MspInit()
     58                     (++) Encoder mode output : HAL_TIM_Encoder_MspInit()
     59                     
     60               (#) Initialize the TIM low level resources :
     61                  (##) Enable the TIM interface clock using __TIMx_CLK_ENABLE(); 
     62                  (##) TIM pins configuration
     63                      (+++) Enable the clock for the TIM GPIOs using the following function:
     64                           __GPIOx_CLK_ENABLE();   
     65                      (+++) Configure these TIM pins in Alternate function mode using HAL_GPIO_Init();  
     66          
     67               (#) The external Clock can be configured, if needed (the default clock is the 
     68                   internal clock from the APBx), using the following function:
     69                   HAL_TIM_ConfigClockSource, the clock configuration should be done before 
     70                   any start function.
     71            
     72               (#) Configure the TIM in the desired functioning mode using one of the 
     73                   initialization function of this driver:
     74                   (++) HAL_TIM_Base_Init: to use the Timer to generate a simple time base
     75                   (++) HAL_TIM_OC_Init and HAL_TIM_OC_ConfigChannel: to use the Timer to generate an 
     76                        Output Compare signal.
     77                   (++) HAL_TIM_PWM_Init and HAL_TIM_PWM_ConfigChannel: to use the Timer to generate a 
     78                        PWM signal.
     79                   (++) HAL_TIM_IC_Init and HAL_TIM_IC_ConfigChannel: to use the Timer to measure an 
     80                        external signal.
     81                   (++) HAL_TIM_OnePulse_Init and HAL_TIM_OnePulse_ConfigChannel: to use the Timer 
     82                        in One Pulse Mode.
     83                   (++) HAL_TIM_Encoder_Init: to use the Timer Encoder Interface.
     84                   
     85               (#) Activate the TIM peripheral using one of the start functions depending from the feature used: 
     86                     (++) Time Base : HAL_TIM_Base_Start(), HAL_TIM_Base_Start_DMA(), HAL_TIM_Base_Start_IT()
     87                     (++) Input Capture :  HAL_TIM_IC_Start(), HAL_TIM_IC_Start_DMA(), HAL_TIM_IC_Start_IT()
     88                     (++) Output Compare : HAL_TIM_OC_Start(), HAL_TIM_OC_Start_DMA(), HAL_TIM_OC_Start_IT()
     89                     (++) PWM generation : HAL_TIM_PWM_Start(), HAL_TIM_PWM_Start_DMA(), HAL_TIM_PWM_Start_IT()
     90                     (++) One-pulse mode output : HAL_TIM_OnePulse_Start(), HAL_TIM_OnePulse_Start_IT()
     91                     (++) Encoder mode output : HAL_TIM_Encoder_Start(), HAL_TIM_Encoder_Start_DMA(), HAL_TIM_Encoder_Start_IT().
     92          
     93               (#) The DMA Burst is managed with the two following functions:
     94                   HAL_TIM_DMABurst_WriteStart()
     95                   HAL_TIM_DMABurst_ReadStart()
     96            
     97            @endverbatim
     98            ******************************************************************************
     99            * @attention
    100            *
    101            * <h2><center>&copy; COPYRIGHT(c) 2015 STMicroelectronics</center></h2>
    102            *
    103            * Redistribution and use in source and binary forms, with or without modification,
    104            * are permitted provided that the following conditions are met:
    105            *   1. Redistributions of source code must retain the above copyright notice,
    106            *      this list of conditions and the following disclaimer.
    107            *   2. Redistributions in binary form must reproduce the above copyright notice,
    108            *      this list of conditions and the following disclaimer in the documentation
    109            *      and/or other materials provided with the distribution.
    110            *   3. Neither the name of STMicroelectronics nor the names of its contributors
    111            *      may be used to endorse or promote products derived from this software
    112            *      without specific prior written permission.
    113            *
    114            * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
    115            * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
    116            * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
    117            * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
    118            * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
    119            * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
    120            * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
    121            * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
    122            * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
    123            * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
    124            *
    125            ******************************************************************************
    126            */ 
    127          
    128          /* Includes ------------------------------------------------------------------*/
    129          #include "stm32f7xx_hal.h"
    130          
    131          /** @addtogroup STM32F7xx_HAL_Driver
    132            * @{
    133            */
    134          
    135          /** @defgroup TIM TIM
    136            * @brief TIM HAL module driver
    137            * @{
    138            */
    139          
    140          #ifdef HAL_TIM_MODULE_ENABLED
    141          
    142          /* Private typedef -----------------------------------------------------------*/
    143          /* Private define ------------------------------------------------------------*/
    144          /* Private macro -------------------------------------------------------------*/
    145          /* Private variables ---------------------------------------------------------*/
    146          /** @addtogroup TIM_Private_Functions
    147            * @{
    148            */
    149          /* Private function prototypes -----------------------------------------------*/
    150          static void TIM_TI1_ConfigInputStage(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICFilter);
    151          static void TIM_TI2_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
    152                                 uint32_t TIM_ICFilter);
    153          static void TIM_TI2_ConfigInputStage(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICFilter);
    154          static void TIM_TI3_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
    155                                 uint32_t TIM_ICFilter);
    156          static void TIM_TI4_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
    157                                 uint32_t TIM_ICFilter);
    158          
    159          static void TIM_ITRx_SetConfig(TIM_TypeDef* TIMx, uint16_t TIM_ITRx);
    160          static void TIM_DMAPeriodElapsedCplt(DMA_HandleTypeDef *hdma);
    161          static void TIM_DMATriggerCplt(DMA_HandleTypeDef *hdma);
    162          static void TIM_SlaveTimer_SetConfig(TIM_HandleTypeDef *htim,
    163                                               TIM_SlaveConfigTypeDef * sSlaveConfig);
    164          /**
    165            * @}
    166            */
    167            
    168          /* Exported functions --------------------------------------------------------*/
    169          /** @defgroup TIM_Exported_Functions TIM Exported Functions
    170            * @{
    171            */
    172          
    173          /** @defgroup TIM_Exported_Functions_Group1 Time Base functions 
    174           *  @brief    Time Base functions 
    175           *
    176          @verbatim    
    177            ==============================================================================
    178                        ##### Time Base functions #####
    179            ==============================================================================
    180            [..]  
    181              This section provides functions allowing to:
    182              (+) Initialize and configure the TIM base. 
    183              (+) De-initialize the TIM base.
    184              (+) Start the Time Base.
    185              (+) Stop the Time Base.
    186              (+) Start the Time Base and enable interrupt.
    187              (+) Stop the Time Base and disable interrupt.
    188              (+) Start the Time Base and enable DMA transfer.
    189              (+) Stop the Time Base and disable DMA transfer.
    190           
    191          @endverbatim
    192            * @{
    193            */
    194          /**
    195            * @brief  Initializes the TIM Time base Unit according to the specified
    196            *         parameters in the TIM_HandleTypeDef and create the associated handle.
    197            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
    198            *                the configuration information for TIM module.
    199            * @retval HAL status
    200            */

   \                                 In section .text, align 2, keep-with-next
    201          HAL_StatusTypeDef HAL_TIM_Base_Init(TIM_HandleTypeDef *htim)
    202          { 
   \                     HAL_TIM_Base_Init: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0xB081             SUB      SP,SP,#+4
    203            /* Check the TIM handle allocation */
    204            if(htim == NULL)
   \   00000006   0xBF08             IT       EQ 
   \   00000008   0x2001             MOVEQ    R0,#+1
    205            {
    206              return HAL_ERROR;
   \   0000000A   0xD066             BEQ.N    ??HAL_TIM_Base_Init_0
    207            }
    208            
    209            /* Check the parameters */
    210            assert_param(IS_TIM_INSTANCE(htim->Instance)); 
    211            assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
    212            assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
    213            
    214            if(htim->State == HAL_TIM_STATE_RESET)
   \   0000000C   0xF894 0x0039      LDRB     R0,[R4, #+57]
   \   00000010   0xB910             CBNZ.N   R0,??HAL_TIM_Base_Init_1
    215            {  
    216              /* Init the low level hardware : GPIO, CLOCK, NVIC */
    217              HAL_TIM_Base_MspInit(htim);
   \   00000012   0x4620             MOV      R0,R4
   \   00000014   0x.... 0x....      BL       HAL_TIM_Base_MspInit
    218            }
    219            
    220            /* Set the TIM state */
    221            htim->State= HAL_TIM_STATE_BUSY;
   \                     ??HAL_TIM_Base_Init_1: (+1)
   \   00000018   0x2002             MOVS     R0,#+2
    222            
    223            /* Set the Time Base configuration */
    224            TIM_Base_SetConfig(htim->Instance, &htim->Init); 
   \   0000001A   0x.... 0x....      LDR.W    R2,??DataTable15  ;; 0x40010000
   \   0000001E   0xF884 0x0039      STRB     R0,[R4, #+57]
   \   00000022   0x1D20             ADDS     R0,R4,#+4
   \   00000024   0x6821             LDR      R1,[R4, #+0]
   \   00000026   0x4291             CMP      R1,R2
   \   00000028   0x680B             LDR      R3,[R1, #+0]
   \   0000002A   0xBF18             IT       NE 
   \   0000002C   0xF1B1 0x4F80      CMPNE    R1,#+1073741824
   \   00000030   0xD00F             BEQ.N    ??HAL_TIM_Base_Init_2
   \   00000032   0x.... 0x....      LDR.W    R5,??DataTable15_1  ;; 0x40000400
   \   00000036   0x42A9             CMP      R1,R5
   \   00000038   0xBF1C             ITT      NE 
   \   0000003A   0x.... 0x....      LDRNE.W  R5,??DataTable15_2  ;; 0x40000800
   \   0000003E   0x42A9             CMPNE    R1,R5
   \   00000040   0xD007             BEQ.N    ??HAL_TIM_Base_Init_2
   \   00000042   0x.... 0x....      LDR.W    R5,??DataTable15_3  ;; 0x40000c00
   \   00000046   0x42A9             CMP      R1,R5
   \   00000048   0xBF1C             ITT      NE 
   \   0000004A   0x.... 0x....      LDRNE.W  R5,??DataTable16  ;; 0x40010400
   \   0000004E   0x42A9             CMPNE    R1,R5
   \   00000050   0xD113             BNE.N    ??HAL_TIM_Base_Init_3
   \                     ??HAL_TIM_Base_Init_2: (+1)
   \   00000052   0x6845             LDR      R5,[R0, #+4]
   \   00000054   0xF023 0x0370      BIC      R3,R3,#0x70
   \   00000058   0x432B             ORRS     R3,R5,R3
   \   0000005A   0x4291             CMP      R1,R2
   \   0000005C   0xBF18             IT       NE 
   \   0000005E   0xF1B1 0x4F80      CMPNE    R1,#+1073741824
   \   00000062   0xD025             BEQ.N    ??HAL_TIM_Base_Init_4
   \   00000064   0x.... 0x....      LDR.W    R5,??DataTable15_1  ;; 0x40000400
   \   00000068   0x42A9             CMP      R1,R5
   \   0000006A   0xBF1F             ITTTT    NE 
   \   0000006C   0x.... 0x....      LDRNE.W  R5,??DataTable15_2  ;; 0x40000800
   \   00000070   0x42A9             CMPNE    R1,R5
   \   00000072   0x.... 0x....      LDRNE.W  R5,??DataTable15_3  ;; 0x40000c00
   \   00000076   0x42A9             CMPNE    R1,R5
   \   00000078   0xD01A             BEQ.N    ??HAL_TIM_Base_Init_4
   \                     ??HAL_TIM_Base_Init_3: (+1)
   \   0000007A   0x.... 0x....      LDR.W    R5,??DataTable16  ;; 0x40010400
   \   0000007E   0x42A9             CMP      R1,R5
   \   00000080   0xBF1C             ITT      NE 
   \   00000082   0x.... 0x....      LDRNE.W  R5,??DataTable16_1  ;; 0x40014000
   \   00000086   0x42A9             CMPNE    R1,R5
   \   00000088   0xD012             BEQ.N    ??HAL_TIM_Base_Init_4
   \   0000008A   0x.... 0x....      LDR.W    R5,??DataTable16_2  ;; 0x40014400
   \   0000008E   0x42A9             CMP      R1,R5
   \   00000090   0xBF1C             ITT      NE 
   \   00000092   0x.... 0x....      LDRNE.W  R5,??DataTable16_3  ;; 0x40014800
   \   00000096   0x42A9             CMPNE    R1,R5
   \   00000098   0xD00A             BEQ.N    ??HAL_TIM_Base_Init_4
   \   0000009A   0x.... 0x....      LDR.W    R5,??DataTable16_4  ;; 0x40001800
   \   0000009E   0x42A9             CMP      R1,R5
   \   000000A0   0xBF1F             ITTTT    NE 
   \   000000A2   0x.... 0x....      LDRNE.W  R5,??DataTable16_5  ;; 0x40001c00
   \   000000A6   0x42A9             CMPNE    R1,R5
   \   000000A8   0x.... 0x....      LDRNE.W  R5,??DataTable16_6  ;; 0x40002000
   \   000000AC   0x42A9             CMPNE    R1,R5
   \   000000AE   0xD103             BNE.N    ??HAL_TIM_Base_Init_5
   \                     ??HAL_TIM_Base_Init_4: (+1)
   \   000000B0   0x68C5             LDR      R5,[R0, #+12]
   \   000000B2   0xF423 0x7340      BIC      R3,R3,#0x300
   \   000000B6   0x432B             ORRS     R3,R5,R3
   \                     ??HAL_TIM_Base_Init_5: (+1)
   \   000000B8   0x600B             STR      R3,[R1, #+0]
   \   000000BA   0x6883             LDR      R3,[R0, #+8]
   \   000000BC   0x4291             CMP      R1,R2
   \   000000BE   0x62CB             STR      R3,[R1, #+44]
   \   000000C0   0x6803             LDR      R3,[R0, #+0]
   \   000000C2   0x628B             STR      R3,[R1, #+40]
   \   000000C4   0xBF19             ITTEE    NE 
   \   000000C6   0x.... 0x....      LDRNE.W  R2,??DataTable16  ;; 0x40010400
   \   000000CA   0x4291             CMPNE    R1,R2
   \   000000CC   0x6900             LDREQ    R0,[R0, #+16]
   \   000000CE   0x6308             STREQ    R0,[R1, #+48]
   \   000000D0   0x2001             MOVS     R0,#+1
   \   000000D2   0x6148             STR      R0,[R1, #+20]
    225            
    226            /* Initialize the TIM state*/
    227            htim->State= HAL_TIM_STATE_READY;
   \   000000D4   0xF884 0x0039      STRB     R0,[R4, #+57]
    228            
    229            return HAL_OK;
   \   000000D8   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_Base_Init_0: (+1)
   \   000000DA   0xB001             ADD      SP,SP,#+4
   \   000000DC   0xBD30             POP      {R4,R5,PC}       ;; return
    230          }
    231          
    232          /**
    233            * @brief  DeInitializes the TIM Base peripheral 
    234            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
    235            *                the configuration information for TIM module.
    236            * @retval HAL status
    237            */

   \                                 In section .text, align 2, keep-with-next
    238          HAL_StatusTypeDef HAL_TIM_Base_DeInit(TIM_HandleTypeDef *htim)
    239          {  
   \                     HAL_TIM_Base_DeInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    240            /* Check the parameters */
    241            assert_param(IS_TIM_INSTANCE(htim->Instance));
    242          
    243            htim->State = HAL_TIM_STATE_BUSY;
   \   00000004   0x2002             MOVS     R0,#+2
   \   00000006   0xF884 0x0039      STRB     R0,[R4, #+57]
    244             
    245            /* Disable the TIM Peripheral Clock */
    246            __HAL_TIM_DISABLE(htim);
   \   0000000A   0xF241 0x1211      MOVW     R2,#+4369
   \   0000000E   0x6820             LDR      R0,[R4, #+0]
   \   00000010   0x6A01             LDR      R1,[R0, #+32]
   \   00000012   0x4211             TST      R1,R2
   \   00000014   0xBF02             ITTT     EQ 
   \   00000016   0x6A01             LDREQ    R1,[R0, #+32]
   \   00000018   0xF240 0x4244      MOVWEQ   R2,#+1092
   \   0000001C   0x4211             TSTEQ    R1,R2
   \   0000001E   0xD103             BNE.N    ??HAL_TIM_Base_DeInit_0
   \   00000020   0x6801             LDR      R1,[R0, #+0]
   \   00000022   0x0849             LSRS     R1,R1,#+1
   \   00000024   0x0049             LSLS     R1,R1,#+1
   \   00000026   0x6001             STR      R1,[R0, #+0]
    247              
    248            /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
    249            HAL_TIM_Base_MspDeInit(htim);
   \                     ??HAL_TIM_Base_DeInit_0: (+1)
   \   00000028   0x4620             MOV      R0,R4
   \   0000002A   0x.... 0x....      BL       HAL_TIM_Base_MspDeInit
    250            
    251            /* Change TIM state */  
    252            htim->State = HAL_TIM_STATE_RESET; 
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0xF884 0x0039      STRB     R0,[R4, #+57]
    253            
    254            /* Release Lock */
    255            __HAL_UNLOCK(htim);
   \   00000034   0xF884 0x0038      STRB     R0,[R4, #+56]
    256          
    257            return HAL_OK;
   \   00000038   0xBD10             POP      {R4,PC}          ;; return
    258          }
    259          
    260          /**
    261            * @brief  Initializes the TIM Base MSP.
    262            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
    263            *                the configuration information for TIM module.
    264            * @retval None
    265            */

   \                                 In section .text, align 2, keep-with-next
    266          __weak void HAL_TIM_Base_MspInit(TIM_HandleTypeDef *htim)
    267          {
    268            /* NOTE : This function Should not be modified, when the callback is needed,
    269                      the HAL_TIM_Base_MspInit could be implemented in the user file
    270             */
    271          }
   \                     HAL_TIM_Base_MspInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    272          
    273          /**
    274            * @brief  DeInitializes TIM Base MSP.
    275            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
    276            *                the configuration information for TIM module.
    277            * @retval None
    278            */

   \                                 In section .text, align 2, keep-with-next
    279          __weak void HAL_TIM_Base_MspDeInit(TIM_HandleTypeDef *htim)
    280          {
    281            /* NOTE : This function Should not be modified, when the callback is needed,
    282                      the HAL_TIM_Base_MspDeInit could be implemented in the user file
    283             */
    284          }
   \                     HAL_TIM_Base_MspDeInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    285          
    286          /**
    287            * @brief  Starts the TIM Base generation.
    288            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
    289            *                the configuration information for TIM module.
    290            * @retval HAL status
    291            */

   \                                 In section .text, align 2, keep-with-next
    292          HAL_StatusTypeDef HAL_TIM_Base_Start(TIM_HandleTypeDef *htim)
    293          {
    294            /* Check the parameters */
    295            assert_param(IS_TIM_INSTANCE(htim->Instance));
    296            
    297            /* Set the TIM state */
    298            htim->State= HAL_TIM_STATE_BUSY;
   \                     HAL_TIM_Base_Start: (+1)
   \   00000000   0x2102             MOVS     R1,#+2
   \   00000002   0xF880 0x1039      STRB     R1,[R0, #+57]
    299            
    300            /* Enable the Peripheral */
    301            __HAL_TIM_ENABLE(htim);
   \   00000006   0x6801             LDR      R1,[R0, #+0]
   \   00000008   0x680A             LDR      R2,[R1, #+0]
   \   0000000A   0xF042 0x0201      ORR      R2,R2,#0x1
   \   0000000E   0x600A             STR      R2,[R1, #+0]
    302            
    303            /* Change the TIM state*/
    304            htim->State= HAL_TIM_STATE_READY;
   \   00000010   0x2101             MOVS     R1,#+1
   \   00000012   0xF880 0x1039      STRB     R1,[R0, #+57]
    305            
    306            /* Return function status */
    307            return HAL_OK;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0x4770             BX       LR               ;; return
    308          }
    309          
    310          /**
    311            * @brief  Stops the TIM Base generation.
    312            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
    313            *                the configuration information for TIM module.
    314            * @retval HAL status
    315            */

   \                                 In section .text, align 2, keep-with-next
    316          HAL_StatusTypeDef HAL_TIM_Base_Stop(TIM_HandleTypeDef *htim)
    317          {
    318            /* Check the parameters */
    319            assert_param(IS_TIM_INSTANCE(htim->Instance));
    320            
    321            /* Set the TIM state */
    322            htim->State= HAL_TIM_STATE_BUSY;
   \                     HAL_TIM_Base_Stop: (+1)
   \   00000000   0x2102             MOVS     R1,#+2
    323            
    324            /* Disable the Peripheral */
    325            __HAL_TIM_DISABLE(htim);
   \   00000002   0xF241 0x1311      MOVW     R3,#+4369
   \   00000006   0xF880 0x1039      STRB     R1,[R0, #+57]
   \   0000000A   0x6801             LDR      R1,[R0, #+0]
   \   0000000C   0x6A0A             LDR      R2,[R1, #+32]
   \   0000000E   0x421A             TST      R2,R3
   \   00000010   0xBF02             ITTT     EQ 
   \   00000012   0x6A0A             LDREQ    R2,[R1, #+32]
   \   00000014   0xF240 0x4344      MOVWEQ   R3,#+1092
   \   00000018   0x421A             TSTEQ    R2,R3
   \   0000001A   0xD103             BNE.N    ??HAL_TIM_Base_Stop_0
   \   0000001C   0x680A             LDR      R2,[R1, #+0]
   \   0000001E   0x0852             LSRS     R2,R2,#+1
   \   00000020   0x0052             LSLS     R2,R2,#+1
   \   00000022   0x600A             STR      R2,[R1, #+0]
    326            
    327            /* Change the TIM state*/
    328            htim->State= HAL_TIM_STATE_READY;
   \                     ??HAL_TIM_Base_Stop_0: (+1)
   \   00000024   0x2101             MOVS     R1,#+1
   \   00000026   0xF880 0x1039      STRB     R1,[R0, #+57]
    329            
    330            /* Return function status */
    331            return HAL_OK;
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0x4770             BX       LR               ;; return
    332          }
    333          
    334          /**
    335            * @brief  Starts the TIM Base generation in interrupt mode.
    336            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
    337            *                the configuration information for TIM module.
    338            * @retval HAL status
    339            */

   \                                 In section .text, align 2, keep-with-next
    340          HAL_StatusTypeDef HAL_TIM_Base_Start_IT(TIM_HandleTypeDef *htim)
    341          {
    342            /* Check the parameters */
    343            assert_param(IS_TIM_INSTANCE(htim->Instance));
    344            
    345            /* Enable the TIM Update interrupt */
    346            __HAL_TIM_ENABLE_IT(htim, TIM_IT_UPDATE);
   \                     HAL_TIM_Base_Start_IT: (+1)
   \   00000000   0x6800             LDR      R0,[R0, #+0]
   \   00000002   0x68C1             LDR      R1,[R0, #+12]
   \   00000004   0xF041 0x0101      ORR      R1,R1,#0x1
   \   00000008   0x60C1             STR      R1,[R0, #+12]
    347                
    348            /* Enable the Peripheral */
    349            __HAL_TIM_ENABLE(htim);
   \   0000000A   0x6801             LDR      R1,[R0, #+0]
   \   0000000C   0xF041 0x0101      ORR      R1,R1,#0x1
   \   00000010   0x6001             STR      R1,[R0, #+0]
    350                
    351            /* Return function status */
    352            return HAL_OK;
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0x4770             BX       LR               ;; return
    353          }
    354          
    355          /**
    356            * @brief  Stops the TIM Base generation in interrupt mode.
    357            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
    358            *                the configuration information for TIM module.
    359            * @retval HAL status
    360            */

   \                                 In section .text, align 2, keep-with-next
    361          HAL_StatusTypeDef HAL_TIM_Base_Stop_IT(TIM_HandleTypeDef *htim)
    362          {
    363            /* Check the parameters */
    364            assert_param(IS_TIM_INSTANCE(htim->Instance));
    365            /* Disable the TIM Update interrupt */
    366            __HAL_TIM_DISABLE_IT(htim, TIM_IT_UPDATE);
   \                     HAL_TIM_Base_Stop_IT: (+1)
   \   00000000   0x6800             LDR      R0,[R0, #+0]
    367                
    368            /* Disable the Peripheral */
    369            __HAL_TIM_DISABLE(htim);
   \   00000002   0xF241 0x1211      MOVW     R2,#+4369
   \   00000006   0x68C1             LDR      R1,[R0, #+12]
   \   00000008   0x0849             LSRS     R1,R1,#+1
   \   0000000A   0x0049             LSLS     R1,R1,#+1
   \   0000000C   0x60C1             STR      R1,[R0, #+12]
   \   0000000E   0x6A01             LDR      R1,[R0, #+32]
   \   00000010   0x4211             TST      R1,R2
   \   00000012   0xBF02             ITTT     EQ 
   \   00000014   0x6A01             LDREQ    R1,[R0, #+32]
   \   00000016   0xF240 0x4244      MOVWEQ   R2,#+1092
   \   0000001A   0x4211             TSTEQ    R1,R2
   \   0000001C   0xD103             BNE.N    ??HAL_TIM_Base_Stop_IT_0
   \   0000001E   0x6801             LDR      R1,[R0, #+0]
   \   00000020   0x0849             LSRS     R1,R1,#+1
   \   00000022   0x0049             LSLS     R1,R1,#+1
   \   00000024   0x6001             STR      R1,[R0, #+0]
    370              
    371            /* Return function status */
    372            return HAL_OK;
   \                     ??HAL_TIM_Base_Stop_IT_0: (+1)
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0x4770             BX       LR               ;; return
    373          }
    374          
    375          /**
    376            * @brief  Starts the TIM Base generation in DMA mode.
    377            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
    378            *                the configuration information for TIM module.
    379            * @param  pData: The source Buffer address.
    380            * @param  Length: The length of data to be transferred from memory to peripheral.
    381            * @retval HAL status
    382            */

   \                                 In section .text, align 2, keep-with-next
    383          HAL_StatusTypeDef HAL_TIM_Base_Start_DMA(TIM_HandleTypeDef *htim, uint32_t *pData, uint16_t Length)
    384          {
   \                     HAL_TIM_Base_Start_DMA: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    385            /* Check the parameters */
    386            assert_param(IS_TIM_DMA_INSTANCE(htim->Instance)); 
    387            
    388            if((htim->State == HAL_TIM_STATE_BUSY))
   \   00000004   0xF894 0x0039      LDRB     R0,[R4, #+57]
   \   00000008   0x2802             CMP      R0,#+2
   \   0000000A   0xD022             BEQ.N    ??HAL_TIM_Base_Start_DMA_0
    389            {
    390               return HAL_BUSY;
    391            }
    392            else if((htim->State == HAL_TIM_STATE_READY))
   \   0000000C   0xF894 0x0039      LDRB     R0,[R4, #+57]
   \   00000010   0x2801             CMP      R0,#+1
   \   00000012   0xD104             BNE.N    ??HAL_TIM_Base_Start_DMA_1
    393            {
    394              if((pData == 0 ) && (Length > 0)) 
   \   00000014   0xB901             CBNZ.N   R1,??HAL_TIM_Base_Start_DMA_2
   \   00000016   0xB9E2             CBNZ.N   R2,??HAL_TIM_Base_Start_DMA_0
    395              {
    396                return HAL_ERROR;                                    
    397              }
    398              else
    399              {
    400                htim->State = HAL_TIM_STATE_BUSY;
   \                     ??HAL_TIM_Base_Start_DMA_2: (+1)
   \   00000018   0x2002             MOVS     R0,#+2
   \   0000001A   0xF884 0x0039      STRB     R0,[R4, #+57]
    401              }
    402            }  
    403            /* Set the DMA Period elapsed callback */
    404            htim->hdma[TIM_DMA_ID_UPDATE]->XferCpltCallback = TIM_DMAPeriodElapsedCplt;
   \                     ??HAL_TIM_Base_Start_DMA_1: (+1)
   \   0000001E   0x69E3             LDR      R3,[R4, #+28]
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable16_7
   \   00000024   0x63D8             STR      R0,[R3, #+60]
    405               
    406            /* Set the DMA error callback */
    407            htim->hdma[TIM_DMA_ID_UPDATE]->XferErrorCallback = HAL_TIM_DMAError ;
   \   00000026   0x69E3             LDR      R3,[R4, #+28]
   \   00000028   0x.... 0x....      LDR.W    R0,??DataTable17
   \   0000002C   0x6498             STR      R0,[R3, #+72]
    408            
    409            /* Enable the DMA Stream */
    410            HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_UPDATE], (uint32_t)pData, (uint32_t)&htim->Instance->ARR, Length);
   \   0000002E   0x6820             LDR      R0,[R4, #+0]
   \   00000030   0x4613             MOV      R3,R2
   \   00000032   0xF100 0x022C      ADD      R2,R0,#+44
   \   00000036   0x69E0             LDR      R0,[R4, #+28]
   \   00000038   0x.... 0x....      BL       HAL_DMA_Start_IT
    411            
    412            /* Enable the TIM Update DMA request */
    413            __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_UPDATE);
   \   0000003C   0x6820             LDR      R0,[R4, #+0]
   \   0000003E   0x68C1             LDR      R1,[R0, #+12]
   \   00000040   0xF441 0x7180      ORR      R1,R1,#0x100
   \   00000044   0x60C1             STR      R1,[R0, #+12]
    414          
    415            /* Enable the Peripheral */
    416            __HAL_TIM_ENABLE(htim);  
   \   00000046   0x6820             LDR      R0,[R4, #+0]
   \   00000048   0x6801             LDR      R1,[R0, #+0]
   \   0000004A   0xF041 0x0101      ORR      R1,R1,#0x1
   \   0000004E   0x6001             STR      R1,[R0, #+0]
    417            
    418            /* Return function status */
    419            return HAL_OK;
   \   00000050   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_Base_Start_DMA_0: (+1)
   \   00000052   0xBD10             POP      {R4,PC}          ;; return
    420          }
    421          
    422          /**
    423            * @brief  Stops the TIM Base generation in DMA mode.
    424            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
    425            *                the configuration information for TIM module.
    426            * @retval HAL status
    427            */

   \                                 In section .text, align 2, keep-with-next
    428          HAL_StatusTypeDef HAL_TIM_Base_Stop_DMA(TIM_HandleTypeDef *htim)
    429          {
    430            /* Check the parameters */
    431            assert_param(IS_TIM_DMA_INSTANCE(htim->Instance));
    432            
    433            /* Disable the TIM Update DMA request */
    434            __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_UPDATE);
   \                     HAL_TIM_Base_Stop_DMA: (+1)
   \   00000000   0x6801             LDR      R1,[R0, #+0]
    435                
    436            /* Disable the Peripheral */
    437            __HAL_TIM_DISABLE(htim);
   \   00000002   0xF241 0x1311      MOVW     R3,#+4369
   \   00000006   0x68CA             LDR      R2,[R1, #+12]
   \   00000008   0xF422 0x7280      BIC      R2,R2,#0x100
   \   0000000C   0x60CA             STR      R2,[R1, #+12]
   \   0000000E   0x6801             LDR      R1,[R0, #+0]
   \   00000010   0x6A0A             LDR      R2,[R1, #+32]
   \   00000012   0x421A             TST      R2,R3
   \   00000014   0xBF02             ITTT     EQ 
   \   00000016   0x6A0A             LDREQ    R2,[R1, #+32]
   \   00000018   0xF240 0x4344      MOVWEQ   R3,#+1092
   \   0000001C   0x421A             TSTEQ    R2,R3
   \   0000001E   0xD103             BNE.N    ??HAL_TIM_Base_Stop_DMA_0
   \   00000020   0x680A             LDR      R2,[R1, #+0]
   \   00000022   0x0852             LSRS     R2,R2,#+1
   \   00000024   0x0052             LSLS     R2,R2,#+1
   \   00000026   0x600A             STR      R2,[R1, #+0]
    438              
    439            /* Change the htim state */
    440            htim->State = HAL_TIM_STATE_READY;
   \                     ??HAL_TIM_Base_Stop_DMA_0: (+1)
   \   00000028   0x2101             MOVS     R1,#+1
   \   0000002A   0xF880 0x1039      STRB     R1,[R0, #+57]
    441                
    442            /* Return function status */
    443            return HAL_OK;
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0x4770             BX       LR               ;; return
    444          }
    445          
    446          /**
    447            * @}
    448            */
    449            
    450          /** @defgroup TIM_Exported_Functions_Group2 Time Output Compare functions 
    451           *  @brief    Time Output Compare functions 
    452           *
    453          @verbatim    
    454            ==============================================================================
    455                            ##### Time Output Compare functions #####
    456            ==============================================================================
    457            [..]
    458              This section provides functions allowing to:
    459              (+) Initialize and configure the TIM Output Compare. 
    460              (+) De-initialize the TIM Output Compare.
    461              (+) Start the Time Output Compare.
    462              (+) Stop the Time Output Compare.
    463              (+) Start the Time Output Compare and enable interrupt.
    464              (+) Stop the Time Output Compare and disable interrupt.
    465              (+) Start the Time Output Compare and enable DMA transfer.
    466              (+) Stop the Time Output Compare and disable DMA transfer.
    467           
    468          @endverbatim
    469            * @{
    470            */
    471          /**
    472            * @brief  Initializes the TIM Output Compare according to the specified
    473            *         parameters in the TIM_HandleTypeDef and create the associated handle.
    474            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
    475            *                the configuration information for TIM module.
    476            * @retval HAL status
    477            */

   \                                 In section .text, align 2, keep-with-next
    478          HAL_StatusTypeDef HAL_TIM_OC_Init(TIM_HandleTypeDef* htim)
    479          {
   \                     HAL_TIM_OC_Init: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0xB081             SUB      SP,SP,#+4
    480            /* Check the TIM handle allocation */
    481            if(htim == NULL)
   \   00000006   0xBF08             IT       EQ 
   \   00000008   0x2001             MOVEQ    R0,#+1
    482            {
    483              return HAL_ERROR;
   \   0000000A   0xD068             BEQ.N    ??HAL_TIM_OC_Init_0
    484            }
    485          
    486            /* Check the parameters */
    487            assert_param(IS_TIM_INSTANCE(htim->Instance));
    488            assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
    489            assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
    490           
    491            if(htim->State == HAL_TIM_STATE_RESET)
   \   0000000C   0xF894 0x0039      LDRB     R0,[R4, #+57]
   \   00000010   0xB920             CBNZ.N   R0,??HAL_TIM_OC_Init_1
    492            { 
    493              /* Allocate lock resource and initialize it */
    494              htim->Lock = HAL_UNLOCKED;  
   \   00000012   0xF884 0x0038      STRB     R0,[R4, #+56]
    495              /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
    496              HAL_TIM_OC_MspInit(htim);
   \   00000016   0x4620             MOV      R0,R4
   \   00000018   0x.... 0x....      BL       HAL_TIM_OC_MspInit
    497            }
    498            
    499            /* Set the TIM state */
    500            htim->State= HAL_TIM_STATE_BUSY;
   \                     ??HAL_TIM_OC_Init_1: (+1)
   \   0000001C   0x2002             MOVS     R0,#+2
    501            
    502            /* Init the base time for the Output Compare */  
    503            TIM_Base_SetConfig(htim->Instance,  &htim->Init); 
   \   0000001E   0x.... 0x....      LDR.W    R2,??DataTable15  ;; 0x40010000
   \   00000022   0xF884 0x0039      STRB     R0,[R4, #+57]
   \   00000026   0x1D20             ADDS     R0,R4,#+4
   \   00000028   0x6821             LDR      R1,[R4, #+0]
   \   0000002A   0x4291             CMP      R1,R2
   \   0000002C   0x680B             LDR      R3,[R1, #+0]
   \   0000002E   0xBF18             IT       NE 
   \   00000030   0xF1B1 0x4F80      CMPNE    R1,#+1073741824
   \   00000034   0xD00F             BEQ.N    ??HAL_TIM_OC_Init_2
   \   00000036   0x.... 0x....      LDR.W    R5,??DataTable15_1  ;; 0x40000400
   \   0000003A   0x42A9             CMP      R1,R5
   \   0000003C   0xBF1C             ITT      NE 
   \   0000003E   0x.... 0x....      LDRNE.W  R5,??DataTable15_2  ;; 0x40000800
   \   00000042   0x42A9             CMPNE    R1,R5
   \   00000044   0xD007             BEQ.N    ??HAL_TIM_OC_Init_2
   \   00000046   0x.... 0x....      LDR.W    R5,??DataTable15_3  ;; 0x40000c00
   \   0000004A   0x42A9             CMP      R1,R5
   \   0000004C   0xBF1C             ITT      NE 
   \   0000004E   0x.... 0x....      LDRNE.W  R5,??DataTable16  ;; 0x40010400
   \   00000052   0x42A9             CMPNE    R1,R5
   \   00000054   0xD113             BNE.N    ??HAL_TIM_OC_Init_3
   \                     ??HAL_TIM_OC_Init_2: (+1)
   \   00000056   0x6845             LDR      R5,[R0, #+4]
   \   00000058   0xF023 0x0370      BIC      R3,R3,#0x70
   \   0000005C   0x432B             ORRS     R3,R5,R3
   \   0000005E   0x4291             CMP      R1,R2
   \   00000060   0xBF18             IT       NE 
   \   00000062   0xF1B1 0x4F80      CMPNE    R1,#+1073741824
   \   00000066   0xD025             BEQ.N    ??HAL_TIM_OC_Init_4
   \   00000068   0x.... 0x....      LDR.W    R5,??DataTable15_1  ;; 0x40000400
   \   0000006C   0x42A9             CMP      R1,R5
   \   0000006E   0xBF1F             ITTTT    NE 
   \   00000070   0x.... 0x....      LDRNE.W  R5,??DataTable15_2  ;; 0x40000800
   \   00000074   0x42A9             CMPNE    R1,R5
   \   00000076   0x.... 0x....      LDRNE.W  R5,??DataTable15_3  ;; 0x40000c00
   \   0000007A   0x42A9             CMPNE    R1,R5
   \   0000007C   0xD01A             BEQ.N    ??HAL_TIM_OC_Init_4
   \                     ??HAL_TIM_OC_Init_3: (+1)
   \   0000007E   0x.... 0x....      LDR.W    R5,??DataTable16  ;; 0x40010400
   \   00000082   0x42A9             CMP      R1,R5
   \   00000084   0xBF1C             ITT      NE 
   \   00000086   0x.... 0x....      LDRNE.W  R5,??DataTable16_1  ;; 0x40014000
   \   0000008A   0x42A9             CMPNE    R1,R5
   \   0000008C   0xD012             BEQ.N    ??HAL_TIM_OC_Init_4
   \   0000008E   0x.... 0x....      LDR.W    R5,??DataTable16_2  ;; 0x40014400
   \   00000092   0x42A9             CMP      R1,R5
   \   00000094   0xBF1C             ITT      NE 
   \   00000096   0x.... 0x....      LDRNE.W  R5,??DataTable16_3  ;; 0x40014800
   \   0000009A   0x42A9             CMPNE    R1,R5
   \   0000009C   0xD00A             BEQ.N    ??HAL_TIM_OC_Init_4
   \   0000009E   0x.... 0x....      LDR.W    R5,??DataTable16_4  ;; 0x40001800
   \   000000A2   0x42A9             CMP      R1,R5
   \   000000A4   0xBF1F             ITTTT    NE 
   \   000000A6   0x.... 0x....      LDRNE.W  R5,??DataTable16_5  ;; 0x40001c00
   \   000000AA   0x42A9             CMPNE    R1,R5
   \   000000AC   0x.... 0x....      LDRNE.W  R5,??DataTable16_6  ;; 0x40002000
   \   000000B0   0x42A9             CMPNE    R1,R5
   \   000000B2   0xD103             BNE.N    ??HAL_TIM_OC_Init_5
   \                     ??HAL_TIM_OC_Init_4: (+1)
   \   000000B4   0x68C5             LDR      R5,[R0, #+12]
   \   000000B6   0xF423 0x7340      BIC      R3,R3,#0x300
   \   000000BA   0x432B             ORRS     R3,R5,R3
   \                     ??HAL_TIM_OC_Init_5: (+1)
   \   000000BC   0x600B             STR      R3,[R1, #+0]
   \   000000BE   0x6883             LDR      R3,[R0, #+8]
   \   000000C0   0x4291             CMP      R1,R2
   \   000000C2   0x62CB             STR      R3,[R1, #+44]
   \   000000C4   0x6803             LDR      R3,[R0, #+0]
   \   000000C6   0x628B             STR      R3,[R1, #+40]
   \   000000C8   0xBF19             ITTEE    NE 
   \   000000CA   0x.... 0x....      LDRNE.W  R2,??DataTable16  ;; 0x40010400
   \   000000CE   0x4291             CMPNE    R1,R2
   \   000000D0   0x6900             LDREQ    R0,[R0, #+16]
   \   000000D2   0x6308             STREQ    R0,[R1, #+48]
   \   000000D4   0x2001             MOVS     R0,#+1
   \   000000D6   0x6148             STR      R0,[R1, #+20]
    504            
    505            /* Initialize the TIM state*/
    506            htim->State= HAL_TIM_STATE_READY;
   \   000000D8   0xF884 0x0039      STRB     R0,[R4, #+57]
    507            
    508            return HAL_OK;
   \   000000DC   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_OC_Init_0: (+1)
   \   000000DE   0xB001             ADD      SP,SP,#+4
   \   000000E0   0xBD30             POP      {R4,R5,PC}       ;; return
    509          }
    510          
    511          /**
    512            * @brief  DeInitializes the TIM peripheral 
    513            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
    514            *                the configuration information for TIM module.
    515            * @retval HAL status
    516            */

   \                                 In section .text, align 2, keep-with-next
    517          HAL_StatusTypeDef HAL_TIM_OC_DeInit(TIM_HandleTypeDef *htim)
    518          {
   \                     HAL_TIM_OC_DeInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    519            /* Check the parameters */
    520            assert_param(IS_TIM_INSTANCE(htim->Instance));
    521            
    522             htim->State = HAL_TIM_STATE_BUSY;
   \   00000004   0x2002             MOVS     R0,#+2
   \   00000006   0xF884 0x0039      STRB     R0,[R4, #+57]
    523             
    524            /* Disable the TIM Peripheral Clock */
    525            __HAL_TIM_DISABLE(htim);
   \   0000000A   0xF241 0x1211      MOVW     R2,#+4369
   \   0000000E   0x6820             LDR      R0,[R4, #+0]
   \   00000010   0x6A01             LDR      R1,[R0, #+32]
   \   00000012   0x4211             TST      R1,R2
   \   00000014   0xBF02             ITTT     EQ 
   \   00000016   0x6A01             LDREQ    R1,[R0, #+32]
   \   00000018   0xF240 0x4244      MOVWEQ   R2,#+1092
   \   0000001C   0x4211             TSTEQ    R1,R2
   \   0000001E   0xD103             BNE.N    ??HAL_TIM_OC_DeInit_0
   \   00000020   0x6801             LDR      R1,[R0, #+0]
   \   00000022   0x0849             LSRS     R1,R1,#+1
   \   00000024   0x0049             LSLS     R1,R1,#+1
   \   00000026   0x6001             STR      R1,[R0, #+0]
    526            
    527            /* DeInit the low level hardware: GPIO, CLOCK, NVIC and DMA */
    528            HAL_TIM_OC_MspDeInit(htim);
   \                     ??HAL_TIM_OC_DeInit_0: (+1)
   \   00000028   0x4620             MOV      R0,R4
   \   0000002A   0x.... 0x....      BL       HAL_TIM_OC_MspDeInit
    529              
    530            /* Change TIM state */  
    531            htim->State = HAL_TIM_STATE_RESET; 
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0xF884 0x0039      STRB     R0,[R4, #+57]
    532          
    533            /* Release Lock */
    534            __HAL_UNLOCK(htim);
   \   00000034   0xF884 0x0038      STRB     R0,[R4, #+56]
    535          
    536            return HAL_OK;
   \   00000038   0xBD10             POP      {R4,PC}          ;; return
    537          }
    538          
    539          /**
    540            * @brief  Initializes the TIM Output Compare MSP.
    541            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
    542            *                the configuration information for TIM module.
    543            * @retval None
    544            */

   \                                 In section .text, align 2, keep-with-next
    545          __weak void HAL_TIM_OC_MspInit(TIM_HandleTypeDef *htim)
    546          {
    547            /* NOTE : This function Should not be modified, when the callback is needed,
    548                      the HAL_TIM_OC_MspInit could be implemented in the user file
    549             */
    550          }
   \                     HAL_TIM_OC_MspInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    551          
    552          /**
    553            * @brief  DeInitializes TIM Output Compare MSP.
    554            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
    555            *                the configuration information for TIM module.
    556            * @retval None
    557            */

   \                                 In section .text, align 2, keep-with-next
    558          __weak void HAL_TIM_OC_MspDeInit(TIM_HandleTypeDef *htim)
    559          {
    560            /* NOTE : This function Should not be modified, when the callback is needed,
    561                      the HAL_TIM_OC_MspDeInit could be implemented in the user file
    562             */
    563          }
   \                     HAL_TIM_OC_MspDeInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    564          
    565          /**
    566            * @brief  Starts the TIM Output Compare signal generation.
    567            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
    568            *                the configuration information for TIM module.  
    569            * @param  Channel: TIM Channel to be enabled.
    570            *          This parameter can be one of the following values:
    571            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
    572            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
    573            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
    574            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected   
    575            * @retval HAL status
    576            */

   \                                 In section .text, align 2, keep-with-next
    577          HAL_StatusTypeDef HAL_TIM_OC_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
    578          {
    579            /* Check the parameters */
    580            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
    581            
    582            /* Enable the Output compare channel */
    583            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
   \                     HAL_TIM_OC_Start: (+1)
   \   00000000   0x6800             LDR      R0,[R0, #+0]
   \   00000002   0x2201             MOVS     R2,#+1
   \   00000004   0xFA02 0xF101      LSL      R1,R2,R1
   \   00000008   0x6A02             LDR      R2,[R0, #+32]
   \   0000000A   0x438A             BICS     R2,R2,R1
   \   0000000C   0x6202             STR      R2,[R0, #+32]
   \   0000000E   0x6A02             LDR      R2,[R0, #+32]
   \   00000010   0x4311             ORRS     R1,R1,R2
   \   00000012   0x6201             STR      R1,[R0, #+32]
    584            
    585            if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
   \   00000014   0x.... 0x....      LDR.W    R1,??DataTable15  ;; 0x40010000
   \   00000018   0x4288             CMP      R0,R1
   \   0000001A   0xBF1C             ITT      NE 
   \   0000001C   0x.... 0x....      LDRNE.W  R1,??DataTable16  ;; 0x40010400
   \   00000020   0x4288             CMPNE    R0,R1
   \   00000022   0xD103             BNE.N    ??HAL_TIM_OC_Start_0
    586            {
    587              /* Enable the main output */
    588              __HAL_TIM_MOE_ENABLE(htim);
   \   00000024   0x6C41             LDR      R1,[R0, #+68]
   \   00000026   0xF441 0x4100      ORR      R1,R1,#0x8000
   \   0000002A   0x6441             STR      R1,[R0, #+68]
    589            }
    590            
    591            /* Enable the Peripheral */
    592            __HAL_TIM_ENABLE(htim); 
   \                     ??HAL_TIM_OC_Start_0: (+1)
   \   0000002C   0x6801             LDR      R1,[R0, #+0]
   \   0000002E   0xF041 0x0101      ORR      R1,R1,#0x1
   \   00000032   0x6001             STR      R1,[R0, #+0]
    593            
    594            /* Return function status */
    595            return HAL_OK;
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0x4770             BX       LR               ;; return
    596          }
    597          
    598          /**
    599            * @brief  Stops the TIM Output Compare signal generation.
    600            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
    601            *                the configuration information for TIM module.
    602            * @param  Channel: TIM Channel to be disabled.
    603            *          This parameter can be one of the following values:
    604            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
    605            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
    606            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
    607            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
    608            * @retval HAL status
    609            */

   \                                 In section .text, align 2, keep-with-next
    610          HAL_StatusTypeDef HAL_TIM_OC_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
    611          {
    612            /* Check the parameters */
    613            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
    614            
    615            /* Disable the Output compare channel */
    616            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
   \                     HAL_TIM_OC_Stop: (+1)
   \   00000000   0x6800             LDR      R0,[R0, #+0]
   \   00000002   0x2301             MOVS     R3,#+1
   \   00000004   0xFA03 0xF101      LSL      R1,R3,R1
   \   00000008   0x6A02             LDR      R2,[R0, #+32]
   \   0000000A   0xEA22 0x0101      BIC      R1,R2,R1
   \   0000000E   0x6201             STR      R1,[R0, #+32]
   \   00000010   0x6A01             LDR      R1,[R0, #+32]
   \   00000012   0x6201             STR      R1,[R0, #+32]
    617            
    618            if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
   \   00000014   0x.... 0x....      LDR.W    R1,??DataTable15  ;; 0x40010000
   \   00000018   0x4288             CMP      R0,R1
   \   0000001A   0xBF1C             ITT      NE 
   \   0000001C   0x.... 0x....      LDRNE.W  R1,??DataTable16  ;; 0x40010400
   \   00000020   0x4288             CMPNE    R0,R1
   \   00000022   0xD10D             BNE.N    ??HAL_TIM_OC_Stop_0
    619            {
    620              /* Disable the Main Output */
    621              __HAL_TIM_MOE_DISABLE(htim);
   \   00000024   0x6A01             LDR      R1,[R0, #+32]
   \   00000026   0xF241 0x1211      MOVW     R2,#+4369
   \   0000002A   0x4211             TST      R1,R2
   \   0000002C   0xBF02             ITTT     EQ 
   \   0000002E   0x6A01             LDREQ    R1,[R0, #+32]
   \   00000030   0xF240 0x4244      MOVWEQ   R2,#+1092
   \   00000034   0x4211             TSTEQ    R1,R2
   \   00000036   0xD103             BNE.N    ??HAL_TIM_OC_Stop_0
   \   00000038   0x6C41             LDR      R1,[R0, #+68]
   \   0000003A   0xF421 0x4100      BIC      R1,R1,#0x8000
   \   0000003E   0x6441             STR      R1,[R0, #+68]
    622            }  
    623            
    624            /* Disable the Peripheral */
    625            __HAL_TIM_DISABLE(htim);  
   \                     ??HAL_TIM_OC_Stop_0: (+1)
   \   00000040   0x6A01             LDR      R1,[R0, #+32]
   \   00000042   0xF241 0x1211      MOVW     R2,#+4369
   \   00000046   0x4211             TST      R1,R2
   \   00000048   0xBF02             ITTT     EQ 
   \   0000004A   0x6A01             LDREQ    R1,[R0, #+32]
   \   0000004C   0xF240 0x4244      MOVWEQ   R2,#+1092
   \   00000050   0x4211             TSTEQ    R1,R2
   \   00000052   0xD103             BNE.N    ??HAL_TIM_OC_Stop_1
   \   00000054   0x6801             LDR      R1,[R0, #+0]
   \   00000056   0x0849             LSRS     R1,R1,#+1
   \   00000058   0x0049             LSLS     R1,R1,#+1
   \   0000005A   0x6001             STR      R1,[R0, #+0]
    626            
    627            /* Return function status */
    628            return HAL_OK;
   \                     ??HAL_TIM_OC_Stop_1: (+1)
   \   0000005C   0x2000             MOVS     R0,#+0
   \   0000005E   0x4770             BX       LR               ;; return
    629          }  
    630          
    631          /**
    632            * @brief  Starts the TIM Output Compare signal generation in interrupt mode.
    633            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
    634            *                the configuration information for TIM module.
    635            * @param  Channel: TIM Channel to be enabled.
    636            *          This parameter can be one of the following values:
    637            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
    638            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
    639            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
    640            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
    641            * @retval HAL status
    642            */

   \                                 In section .text, align 4, keep-with-next
    643          HAL_StatusTypeDef HAL_TIM_OC_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
    644          {
    645            /* Check the parameters */
    646            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
    647            
    648            switch (Channel)
   \                     HAL_TIM_OC_Start_IT: (+1)
   \   00000000   0x290C             CMP      R1,#+12
   \   00000002   0xD81C             BHI.N    ??HAL_TIM_OC_Start_IT_1
   \   00000004   0xE8DF 0xF001      TBB      [PC, R1]
   \                     ??HAL_TIM_OC_Start_IT_0:
   \   00000008   0x07 0x1B          DC8      0x7,0x1B,0x1B,0x1B
   \              0x1B 0x1B    
   \   0000000C   0x0C 0x1B          DC8      0xC,0x1B,0x1B,0x1B
   \              0x1B 0x1B    
   \   00000010   0x11 0x1B          DC8      0x11,0x1B,0x1B,0x1B
   \              0x1B 0x1B    
   \   00000014   0x16 0x00          DC8      0x16,0x0
    649            {
    650              case TIM_CHANNEL_1:
    651              {       
    652                /* Enable the TIM Capture/Compare 1 interrupt */
    653                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
   \                     ??HAL_TIM_OC_Start_IT_2: (+1)
   \   00000016   0x6802             LDR      R2,[R0, #+0]
   \   00000018   0x68D3             LDR      R3,[R2, #+12]
   \   0000001A   0xF043 0x0302      ORR      R3,R3,#0x2
   \   0000001E   0xE00D             B.N      ??HAL_TIM_OC_Start_IT_3
    654              }
    655              break;
    656              
    657              case TIM_CHANNEL_2:
    658              {
    659                /* Enable the TIM Capture/Compare 2 interrupt */
    660                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
   \                     ??HAL_TIM_OC_Start_IT_4: (+1)
   \   00000020   0x6802             LDR      R2,[R0, #+0]
   \   00000022   0x68D3             LDR      R3,[R2, #+12]
   \   00000024   0xF043 0x0304      ORR      R3,R3,#0x4
   \   00000028   0xE008             B.N      ??HAL_TIM_OC_Start_IT_3
    661              }
    662              break;
    663              
    664              case TIM_CHANNEL_3:
    665              {
    666                /* Enable the TIM Capture/Compare 3 interrupt */
    667                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);
   \                     ??HAL_TIM_OC_Start_IT_5: (+1)
   \   0000002A   0x6802             LDR      R2,[R0, #+0]
   \   0000002C   0x68D3             LDR      R3,[R2, #+12]
   \   0000002E   0xF043 0x0308      ORR      R3,R3,#0x8
   \   00000032   0xE003             B.N      ??HAL_TIM_OC_Start_IT_3
    668              }
    669              break;
    670              
    671              case TIM_CHANNEL_4:
    672              {
    673                /* Enable the TIM Capture/Compare 4 interrupt */
    674                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC4);
   \                     ??HAL_TIM_OC_Start_IT_6: (+1)
   \   00000034   0x6802             LDR      R2,[R0, #+0]
   \   00000036   0x68D3             LDR      R3,[R2, #+12]
   \   00000038   0xF043 0x0310      ORR      R3,R3,#0x10
   \                     ??HAL_TIM_OC_Start_IT_3: (+1)
   \   0000003C   0x60D3             STR      R3,[R2, #+12]
    675              }
    676              break;
    677              
    678              default:
    679              break;
    680            } 
    681          
    682            /* Enable the Output compare channel */
    683            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
   \                     ??HAL_TIM_OC_Start_IT_1: (+1)
   \   0000003E   0x6802             LDR      R2,[R0, #+0]
   \   00000040   0x2001             MOVS     R0,#+1
   \   00000042   0x4088             LSLS     R0,R0,R1
   \   00000044   0x6A11             LDR      R1,[R2, #+32]
   \   00000046   0x4381             BICS     R1,R1,R0
   \   00000048   0x6211             STR      R1,[R2, #+32]
   \   0000004A   0x6A11             LDR      R1,[R2, #+32]
   \   0000004C   0x4308             ORRS     R0,R0,R1
   \   0000004E   0x6210             STR      R0,[R2, #+32]
    684            
    685            if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
   \   00000050   0x.... 0x....      LDR.W    R0,??DataTable15  ;; 0x40010000
   \   00000054   0x4282             CMP      R2,R0
   \   00000056   0xBF1C             ITT      NE 
   \   00000058   0x.... 0x....      LDRNE.W  R0,??DataTable16  ;; 0x40010400
   \   0000005C   0x4282             CMPNE    R2,R0
   \   0000005E   0xD103             BNE.N    ??HAL_TIM_OC_Start_IT_7
    686            {
    687              /* Enable the main output */
    688              __HAL_TIM_MOE_ENABLE(htim);
   \   00000060   0x6C50             LDR      R0,[R2, #+68]
   \   00000062   0xF440 0x4000      ORR      R0,R0,#0x8000
   \   00000066   0x6450             STR      R0,[R2, #+68]
    689            }
    690          
    691            /* Enable the Peripheral */
    692            __HAL_TIM_ENABLE(htim);
   \                     ??HAL_TIM_OC_Start_IT_7: (+1)
   \   00000068   0x6810             LDR      R0,[R2, #+0]
   \   0000006A   0xF040 0x0001      ORR      R0,R0,#0x1
   \   0000006E   0x6010             STR      R0,[R2, #+0]
    693            
    694            /* Return function status */
    695            return HAL_OK;
   \   00000070   0x2000             MOVS     R0,#+0
   \   00000072   0x4770             BX       LR               ;; return
    696          }
    697          
    698          /**
    699            * @brief  Stops the TIM Output Compare signal generation in interrupt mode.
    700            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
    701            *                the configuration information for TIM module.
    702            * @param  Channel: TIM Channel to be disabled.
    703            *          This parameter can be one of the following values:
    704            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
    705            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
    706            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
    707            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
    708            * @retval HAL status
    709            */

   \                                 In section .text, align 4, keep-with-next
    710          HAL_StatusTypeDef HAL_TIM_OC_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
    711          {
    712            /* Check the parameters */
    713            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
    714            
    715            switch (Channel)
   \                     HAL_TIM_OC_Stop_IT: (+1)
   \   00000000   0x290C             CMP      R1,#+12
   \   00000002   0xD81C             BHI.N    ??HAL_TIM_OC_Stop_IT_1
   \   00000004   0xE8DF 0xF001      TBB      [PC, R1]
   \                     ??HAL_TIM_OC_Stop_IT_0:
   \   00000008   0x07 0x1B          DC8      0x7,0x1B,0x1B,0x1B
   \              0x1B 0x1B    
   \   0000000C   0x0C 0x1B          DC8      0xC,0x1B,0x1B,0x1B
   \              0x1B 0x1B    
   \   00000010   0x11 0x1B          DC8      0x11,0x1B,0x1B,0x1B
   \              0x1B 0x1B    
   \   00000014   0x16 0x00          DC8      0x16,0x0
    716            {
    717              case TIM_CHANNEL_1:
    718              {       
    719                /* Disable the TIM Capture/Compare 1 interrupt */
    720                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
   \                     ??HAL_TIM_OC_Stop_IT_2: (+1)
   \   00000016   0x6802             LDR      R2,[R0, #+0]
   \   00000018   0x68D3             LDR      R3,[R2, #+12]
   \   0000001A   0xF023 0x0302      BIC      R3,R3,#0x2
   \   0000001E   0xE00D             B.N      ??HAL_TIM_OC_Stop_IT_3
    721              }
    722              break;
    723              
    724              case TIM_CHANNEL_2:
    725              {
    726                /* Disable the TIM Capture/Compare 2 interrupt */
    727                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
   \                     ??HAL_TIM_OC_Stop_IT_4: (+1)
   \   00000020   0x6802             LDR      R2,[R0, #+0]
   \   00000022   0x68D3             LDR      R3,[R2, #+12]
   \   00000024   0xF023 0x0304      BIC      R3,R3,#0x4
   \   00000028   0xE008             B.N      ??HAL_TIM_OC_Stop_IT_3
    728              }
    729              break;
    730              
    731              case TIM_CHANNEL_3:
    732              {
    733                /* Disable the TIM Capture/Compare 3 interrupt */
    734                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);
   \                     ??HAL_TIM_OC_Stop_IT_5: (+1)
   \   0000002A   0x6802             LDR      R2,[R0, #+0]
   \   0000002C   0x68D3             LDR      R3,[R2, #+12]
   \   0000002E   0xF023 0x0308      BIC      R3,R3,#0x8
   \   00000032   0xE003             B.N      ??HAL_TIM_OC_Stop_IT_3
    735              }
    736              break;
    737              
    738              case TIM_CHANNEL_4:
    739              {
    740                /* Disable the TIM Capture/Compare 4 interrupt */
    741                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC4);
   \                     ??HAL_TIM_OC_Stop_IT_6: (+1)
   \   00000034   0x6802             LDR      R2,[R0, #+0]
   \   00000036   0x68D3             LDR      R3,[R2, #+12]
   \   00000038   0xF023 0x0310      BIC      R3,R3,#0x10
   \                     ??HAL_TIM_OC_Stop_IT_3: (+1)
   \   0000003C   0x60D3             STR      R3,[R2, #+12]
    742              }
    743              break;
    744              
    745              default:
    746              break; 
    747            } 
    748            
    749            /* Disable the Output compare channel */
    750            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE); 
   \                     ??HAL_TIM_OC_Stop_IT_1: (+1)
   \   0000003E   0x6802             LDR      R2,[R0, #+0]
   \   00000040   0x2301             MOVS     R3,#+1
   \   00000042   0xFA03 0xF101      LSL      R1,R3,R1
   \   00000046   0x6A10             LDR      R0,[R2, #+32]
   \   00000048   0x4388             BICS     R0,R0,R1
   \   0000004A   0x6210             STR      R0,[R2, #+32]
   \   0000004C   0x6A10             LDR      R0,[R2, #+32]
   \   0000004E   0x6210             STR      R0,[R2, #+32]
    751            
    752            if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
   \   00000050   0x.... 0x....      LDR.W    R0,??DataTable15  ;; 0x40010000
   \   00000054   0x4282             CMP      R2,R0
   \   00000056   0xBF1C             ITT      NE 
   \   00000058   0x.... 0x....      LDRNE.W  R0,??DataTable16  ;; 0x40010400
   \   0000005C   0x4282             CMPNE    R2,R0
   \   0000005E   0xD10D             BNE.N    ??HAL_TIM_OC_Stop_IT_7
    753            {
    754              /* Disable the Main Output */
    755              __HAL_TIM_MOE_DISABLE(htim);
   \   00000060   0x6A10             LDR      R0,[R2, #+32]
   \   00000062   0xF241 0x1111      MOVW     R1,#+4369
   \   00000066   0x4208             TST      R0,R1
   \   00000068   0xBF02             ITTT     EQ 
   \   0000006A   0x6A10             LDREQ    R0,[R2, #+32]
   \   0000006C   0xF240 0x4144      MOVWEQ   R1,#+1092
   \   00000070   0x4208             TSTEQ    R0,R1
   \   00000072   0xD103             BNE.N    ??HAL_TIM_OC_Stop_IT_7
   \   00000074   0x6C50             LDR      R0,[R2, #+68]
   \   00000076   0xF420 0x4000      BIC      R0,R0,#0x8000
   \   0000007A   0x6450             STR      R0,[R2, #+68]
    756            }
    757            
    758            /* Disable the Peripheral */
    759            __HAL_TIM_DISABLE(htim);  
   \                     ??HAL_TIM_OC_Stop_IT_7: (+1)
   \   0000007C   0x6A10             LDR      R0,[R2, #+32]
   \   0000007E   0xF241 0x1111      MOVW     R1,#+4369
   \   00000082   0x4208             TST      R0,R1
   \   00000084   0xBF02             ITTT     EQ 
   \   00000086   0x6A10             LDREQ    R0,[R2, #+32]
   \   00000088   0xF240 0x4144      MOVWEQ   R1,#+1092
   \   0000008C   0x4208             TSTEQ    R0,R1
   \   0000008E   0xD103             BNE.N    ??HAL_TIM_OC_Stop_IT_8
   \   00000090   0x6810             LDR      R0,[R2, #+0]
   \   00000092   0x0840             LSRS     R0,R0,#+1
   \   00000094   0x0040             LSLS     R0,R0,#+1
   \   00000096   0x6010             STR      R0,[R2, #+0]
    760            
    761            /* Return function status */
    762            return HAL_OK;
   \                     ??HAL_TIM_OC_Stop_IT_8: (+1)
   \   00000098   0x2000             MOVS     R0,#+0
   \   0000009A   0x4770             BX       LR               ;; return
    763          }
    764          
    765          /**
    766            * @brief  Starts the TIM Output Compare signal generation in DMA mode.
    767            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
    768            *                the configuration information for TIM module.
    769            * @param  Channel: TIM Channel to be enabled.
    770            *          This parameter can be one of the following values:
    771            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
    772            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
    773            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
    774            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
    775            * @param  pData: The source Buffer address.
    776            * @param  Length: The length of data to be transferred from memory to TIM peripheral
    777            * @retval HAL status
    778            */

   \                                 In section .text, align 4, keep-with-next
    779          HAL_StatusTypeDef HAL_TIM_OC_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData, uint16_t Length)
    780          {
   \                     HAL_TIM_OC_Start_DMA: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0xB081             SUB      SP,SP,#+4
   \   00000006   0x460D             MOV      R5,R1
   \   00000008   0x4611             MOV      R1,R2
    781            /* Check the parameters */
    782            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
    783            
    784            if((htim->State == HAL_TIM_STATE_BUSY))
   \   0000000A   0xF894 0x0039      LDRB     R0,[R4, #+57]
   \   0000000E   0x2802             CMP      R0,#+2
   \   00000010   0xF000 0x807D      BEQ.W    ??HAL_TIM_OC_Start_DMA_1
    785            {
    786               return HAL_BUSY;
    787            }
    788            else if((htim->State == HAL_TIM_STATE_READY))
   \   00000014   0xF894 0x0039      LDRB     R0,[R4, #+57]
   \   00000018   0x2801             CMP      R0,#+1
   \   0000001A   0xD105             BNE.N    ??HAL_TIM_OC_Start_DMA_2
    789            {
    790              if(((uint32_t)pData == 0 ) && (Length > 0)) 
   \   0000001C   0xB909             CBNZ.N   R1,??HAL_TIM_OC_Start_DMA_3
   \   0000001E   0x2B00             CMP      R3,#+0
   \   00000020   0xD175             BNE.N    ??HAL_TIM_OC_Start_DMA_1
    791              {
    792                return HAL_ERROR;                                    
    793              }
    794              else
    795              {
    796                htim->State = HAL_TIM_STATE_BUSY;
   \                     ??HAL_TIM_OC_Start_DMA_3: (+1)
   \   00000022   0x2002             MOVS     R0,#+2
   \   00000024   0xF884 0x0039      STRB     R0,[R4, #+57]
    797              }
    798            }    
    799            switch (Channel)
   \                     ??HAL_TIM_OC_Start_DMA_2: (+1)
   \   00000028   0x2D0C             CMP      R5,#+12
   \   0000002A   0xD854             BHI.N    ??HAL_TIM_OC_Start_DMA_4
   \   0000002C   0xE8DF 0xF005      TBB      [PC, R5]
   \                     ??HAL_TIM_OC_Start_DMA_0:
   \   00000030   0x07 0x53          DC8      0x7,0x53,0x53,0x53
   \              0x53 0x53    
   \   00000034   0x1A 0x53          DC8      0x1A,0x53,0x53,0x53
   \              0x53 0x53    
   \   00000038   0x2D 0x53          DC8      0x2D,0x53,0x53,0x53
   \              0x53 0x53    
   \   0000003C   0x40 0x00          DC8      0x40,0x0
    800            {
    801              case TIM_CHANNEL_1:
    802              {      
    803                /* Set the DMA Period elapsed callback */
    804                htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = HAL_TIM_DMADelayPulseCplt;
   \                     ??HAL_TIM_OC_Start_DMA_5: (+1)
   \   0000003E   0x6A22             LDR      R2,[R4, #+32]
   \   00000040   0x.... 0x....      LDR.W    R0,??DataTable21
   \   00000044   0x63D0             STR      R0,[R2, #+60]
    805               
    806                /* Set the DMA error callback */
    807                htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = HAL_TIM_DMAError ;
   \   00000046   0x6A22             LDR      R2,[R4, #+32]
   \   00000048   0x.... 0x....      LDR.W    R0,??DataTable17
   \   0000004C   0x6490             STR      R0,[R2, #+72]
    808                
    809                /* Enable the DMA Stream */
    810                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)pData, (uint32_t)&htim->Instance->CCR1, Length);
   \   0000004E   0x6820             LDR      R0,[R4, #+0]
   \   00000050   0xF100 0x0234      ADD      R2,R0,#+52
   \   00000054   0x6A20             LDR      R0,[R4, #+32]
   \   00000056   0x.... 0x....      BL       HAL_DMA_Start_IT
    811                
    812                /* Enable the TIM Capture/Compare 1 DMA request */
    813                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
   \   0000005A   0x6820             LDR      R0,[R4, #+0]
   \   0000005C   0x68C1             LDR      R1,[R0, #+12]
   \   0000005E   0xF441 0x7100      ORR      R1,R1,#0x200
   \   00000062   0xE037             B.N      ??HAL_TIM_OC_Start_DMA_6
    814              }
    815              break;
    816              
    817              case TIM_CHANNEL_2:
    818              {
    819                /* Set the DMA Period elapsed callback */
    820                htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = HAL_TIM_DMADelayPulseCplt;
   \                     ??HAL_TIM_OC_Start_DMA_7: (+1)
   \   00000064   0x6A62             LDR      R2,[R4, #+36]
   \   00000066   0x.... 0x....      LDR.W    R0,??DataTable21
   \   0000006A   0x63D0             STR      R0,[R2, #+60]
    821               
    822                /* Set the DMA error callback */
    823                htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = HAL_TIM_DMAError ;
   \   0000006C   0x6A62             LDR      R2,[R4, #+36]
   \   0000006E   0x.... 0x....      LDR.W    R0,??DataTable17
   \   00000072   0x6490             STR      R0,[R2, #+72]
    824                
    825                /* Enable the DMA Stream */
    826                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)pData, (uint32_t)&htim->Instance->CCR2, Length);
   \   00000074   0x6820             LDR      R0,[R4, #+0]
   \   00000076   0xF100 0x0238      ADD      R2,R0,#+56
   \   0000007A   0x6A60             LDR      R0,[R4, #+36]
   \   0000007C   0x.... 0x....      BL       HAL_DMA_Start_IT
    827                
    828                /* Enable the TIM Capture/Compare 2 DMA request */
    829                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
   \   00000080   0x6820             LDR      R0,[R4, #+0]
   \   00000082   0x68C1             LDR      R1,[R0, #+12]
   \   00000084   0xF441 0x6180      ORR      R1,R1,#0x400
   \   00000088   0xE024             B.N      ??HAL_TIM_OC_Start_DMA_6
    830              }
    831              break;
    832              
    833              case TIM_CHANNEL_3:
    834              {
    835                /* Set the DMA Period elapsed callback */
    836                htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = HAL_TIM_DMADelayPulseCplt;
   \                     ??HAL_TIM_OC_Start_DMA_8: (+1)
   \   0000008A   0x6AA2             LDR      R2,[R4, #+40]
   \   0000008C   0x.... 0x....      LDR.W    R0,??DataTable21
   \   00000090   0x63D0             STR      R0,[R2, #+60]
    837               
    838                /* Set the DMA error callback */
    839                htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = HAL_TIM_DMAError ;
   \   00000092   0x6AA2             LDR      R2,[R4, #+40]
   \   00000094   0x.... 0x....      LDR.W    R0,??DataTable17
   \   00000098   0x6490             STR      R0,[R2, #+72]
    840                
    841                /* Enable the DMA Stream */
    842                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)pData, (uint32_t)&htim->Instance->CCR3,Length);
   \   0000009A   0x6820             LDR      R0,[R4, #+0]
   \   0000009C   0xF100 0x023C      ADD      R2,R0,#+60
   \   000000A0   0x6AA0             LDR      R0,[R4, #+40]
   \   000000A2   0x.... 0x....      BL       HAL_DMA_Start_IT
    843                
    844                /* Enable the TIM Capture/Compare 3 DMA request */
    845                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);
   \   000000A6   0x6820             LDR      R0,[R4, #+0]
   \   000000A8   0x68C1             LDR      R1,[R0, #+12]
   \   000000AA   0xF441 0x6100      ORR      R1,R1,#0x800
   \   000000AE   0xE011             B.N      ??HAL_TIM_OC_Start_DMA_6
    846              }
    847              break;
    848              
    849              case TIM_CHANNEL_4:
    850              {
    851               /* Set the DMA Period elapsed callback */
    852                htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = HAL_TIM_DMADelayPulseCplt;
   \                     ??HAL_TIM_OC_Start_DMA_9: (+1)
   \   000000B0   0x6AE2             LDR      R2,[R4, #+44]
   \   000000B2   0x.... 0x....      LDR.W    R0,??DataTable21
   \   000000B6   0x63D0             STR      R0,[R2, #+60]
    853               
    854                /* Set the DMA error callback */
    855                htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = HAL_TIM_DMAError ;
   \   000000B8   0x6AE2             LDR      R2,[R4, #+44]
   \   000000BA   0x.... 0x....      LDR.W    R0,??DataTable17
   \   000000BE   0x6490             STR      R0,[R2, #+72]
    856                
    857                /* Enable the DMA Stream */
    858                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)pData, (uint32_t)&htim->Instance->CCR4, Length);
   \   000000C0   0x6820             LDR      R0,[R4, #+0]
   \   000000C2   0xF100 0x0240      ADD      R2,R0,#+64
   \   000000C6   0x6AE0             LDR      R0,[R4, #+44]
   \   000000C8   0x.... 0x....      BL       HAL_DMA_Start_IT
    859                
    860                /* Enable the TIM Capture/Compare 4 DMA request */
    861                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC4);
   \   000000CC   0x6820             LDR      R0,[R4, #+0]
   \   000000CE   0x68C1             LDR      R1,[R0, #+12]
   \   000000D0   0xF441 0x5180      ORR      R1,R1,#0x1000
   \                     ??HAL_TIM_OC_Start_DMA_6: (+1)
   \   000000D4   0x60C1             STR      R1,[R0, #+12]
    862              }
    863              break;
    864              
    865              default:
    866              break;
    867            }
    868          
    869            /* Enable the Output compare channel */
    870            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
   \                     ??HAL_TIM_OC_Start_DMA_4: (+1)
   \   000000D6   0x6820             LDR      R0,[R4, #+0]
   \   000000D8   0x2101             MOVS     R1,#+1
   \   000000DA   0x40A9             LSLS     R1,R1,R5
   \   000000DC   0x6A02             LDR      R2,[R0, #+32]
   \   000000DE   0x438A             BICS     R2,R2,R1
   \   000000E0   0x6202             STR      R2,[R0, #+32]
   \   000000E2   0x6A02             LDR      R2,[R0, #+32]
   \   000000E4   0x4311             ORRS     R1,R1,R2
   \   000000E6   0x6201             STR      R1,[R0, #+32]
    871            
    872            if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
   \   000000E8   0x6820             LDR      R0,[R4, #+0]
   \   000000EA   0x.... 0x....      LDR.W    R1,??DataTable15  ;; 0x40010000
   \   000000EE   0x4288             CMP      R0,R1
   \   000000F0   0xBF1C             ITT      NE 
   \   000000F2   0x.... 0x....      LDRNE.W  R1,??DataTable16  ;; 0x40010400
   \   000000F6   0x4288             CMPNE    R0,R1
   \   000000F8   0xD103             BNE.N    ??HAL_TIM_OC_Start_DMA_10
    873            {
    874              /* Enable the main output */
    875              __HAL_TIM_MOE_ENABLE(htim);
   \   000000FA   0x6C41             LDR      R1,[R0, #+68]
   \   000000FC   0xF441 0x4100      ORR      R1,R1,#0x8000
   \   00000100   0x6441             STR      R1,[R0, #+68]
    876            }  
    877            
    878            /* Enable the Peripheral */
    879            __HAL_TIM_ENABLE(htim); 
   \                     ??HAL_TIM_OC_Start_DMA_10: (+1)
   \   00000102   0x6820             LDR      R0,[R4, #+0]
   \   00000104   0x6801             LDR      R1,[R0, #+0]
   \   00000106   0xF041 0x0101      ORR      R1,R1,#0x1
   \   0000010A   0x6001             STR      R1,[R0, #+0]
    880            
    881            /* Return function status */
    882            return HAL_OK;
   \   0000010C   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_OC_Start_DMA_1: (+1)
   \   0000010E   0xB001             ADD      SP,SP,#+4
   \   00000110   0xBD30             POP      {R4,R5,PC}       ;; return
    883          }
    884          
    885          /**
    886            * @brief  Stops the TIM Output Compare signal generation in DMA mode.
    887            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
    888            *                the configuration information for TIM module.
    889            * @param  Channel: TIM Channel to be disabled.
    890            *          This parameter can be one of the following values:
    891            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
    892            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
    893            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
    894            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
    895            * @retval HAL status
    896            */

   \                                 In section .text, align 4, keep-with-next
    897          HAL_StatusTypeDef HAL_TIM_OC_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
    898          {
    899            /* Check the parameters */
    900            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
    901            
    902            switch (Channel)
   \                     HAL_TIM_OC_Stop_DMA: (+1)
   \   00000000   0x290C             CMP      R1,#+12
   \   00000002   0xB410             PUSH     {R4}
   \   00000004   0xD81C             BHI.N    ??HAL_TIM_OC_Stop_DMA_1
   \   00000006   0xE8DF 0xF001      TBB      [PC, R1]
   \                     ??HAL_TIM_OC_Stop_DMA_0:
   \   0000000A   0x07 0x1B          DC8      0x7,0x1B,0x1B,0x1B
   \              0x1B 0x1B    
   \   0000000E   0x0C 0x1B          DC8      0xC,0x1B,0x1B,0x1B
   \              0x1B 0x1B    
   \   00000012   0x11 0x1B          DC8      0x11,0x1B,0x1B,0x1B
   \              0x1B 0x1B    
   \   00000016   0x16 0x00          DC8      0x16,0x0
    903            {
    904              case TIM_CHANNEL_1:
    905              {       
    906                /* Disable the TIM Capture/Compare 1 DMA request */
    907                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
   \                     ??HAL_TIM_OC_Stop_DMA_2: (+1)
   \   00000018   0x6802             LDR      R2,[R0, #+0]
   \   0000001A   0x68D3             LDR      R3,[R2, #+12]
   \   0000001C   0xF423 0x7300      BIC      R3,R3,#0x200
   \   00000020   0xE00D             B.N      ??HAL_TIM_OC_Stop_DMA_3
    908              }
    909              break;
    910              
    911              case TIM_CHANNEL_2:
    912              {
    913                /* Disable the TIM Capture/Compare 2 DMA request */
    914                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
   \                     ??HAL_TIM_OC_Stop_DMA_4: (+1)
   \   00000022   0x6802             LDR      R2,[R0, #+0]
   \   00000024   0x68D3             LDR      R3,[R2, #+12]
   \   00000026   0xF423 0x6380      BIC      R3,R3,#0x400
   \   0000002A   0xE008             B.N      ??HAL_TIM_OC_Stop_DMA_3
    915              }
    916              break;
    917              
    918              case TIM_CHANNEL_3:
    919              {
    920                /* Disable the TIM Capture/Compare 3 DMA request */
    921                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);
   \                     ??HAL_TIM_OC_Stop_DMA_5: (+1)
   \   0000002C   0x6802             LDR      R2,[R0, #+0]
   \   0000002E   0x68D3             LDR      R3,[R2, #+12]
   \   00000030   0xF423 0x6300      BIC      R3,R3,#0x800
   \   00000034   0xE003             B.N      ??HAL_TIM_OC_Stop_DMA_3
    922              }
    923              break;
    924              
    925              case TIM_CHANNEL_4:
    926              {
    927                /* Disable the TIM Capture/Compare 4 interrupt */
    928                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC4);
   \                     ??HAL_TIM_OC_Stop_DMA_6: (+1)
   \   00000036   0x6802             LDR      R2,[R0, #+0]
   \   00000038   0x68D3             LDR      R3,[R2, #+12]
   \   0000003A   0xF423 0x5380      BIC      R3,R3,#0x1000
   \                     ??HAL_TIM_OC_Stop_DMA_3: (+1)
   \   0000003E   0x60D3             STR      R3,[R2, #+12]
    929              }
    930              break;
    931              
    932              default:
    933              break;
    934            } 
    935            
    936            /* Disable the Output compare channel */
    937            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
   \                     ??HAL_TIM_OC_Stop_DMA_1: (+1)
   \   00000040   0x6802             LDR      R2,[R0, #+0]
   \   00000042   0x2401             MOVS     R4,#+1
   \   00000044   0xFA04 0xF101      LSL      R1,R4,R1
   \   00000048   0x6A13             LDR      R3,[R2, #+32]
   \   0000004A   0xEA23 0x0101      BIC      R1,R3,R1
   \   0000004E   0x6211             STR      R1,[R2, #+32]
   \   00000050   0x6A11             LDR      R1,[R2, #+32]
   \   00000052   0x6211             STR      R1,[R2, #+32]
    938            
    939            if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
   \   00000054   0x6801             LDR      R1,[R0, #+0]
   \   00000056   0x.... 0x....      LDR.W    R2,??DataTable15  ;; 0x40010000
   \   0000005A   0x4291             CMP      R1,R2
   \   0000005C   0xBF1C             ITT      NE 
   \   0000005E   0x.... 0x....      LDRNE.W  R2,??DataTable16  ;; 0x40010400
   \   00000062   0x4291             CMPNE    R1,R2
   \   00000064   0xD10D             BNE.N    ??HAL_TIM_OC_Stop_DMA_7
    940            {
    941              /* Disable the Main Output */
    942              __HAL_TIM_MOE_DISABLE(htim);
   \   00000066   0x6A0A             LDR      R2,[R1, #+32]
   \   00000068   0xF241 0x1311      MOVW     R3,#+4369
   \   0000006C   0x421A             TST      R2,R3
   \   0000006E   0xBF02             ITTT     EQ 
   \   00000070   0x6A0A             LDREQ    R2,[R1, #+32]
   \   00000072   0xF240 0x4344      MOVWEQ   R3,#+1092
   \   00000076   0x421A             TSTEQ    R2,R3
   \   00000078   0xD103             BNE.N    ??HAL_TIM_OC_Stop_DMA_7
   \   0000007A   0x6C4A             LDR      R2,[R1, #+68]
   \   0000007C   0xF422 0x4200      BIC      R2,R2,#0x8000
   \   00000080   0x644A             STR      R2,[R1, #+68]
    943            }
    944            
    945            /* Disable the Peripheral */
    946            __HAL_TIM_DISABLE(htim);
   \                     ??HAL_TIM_OC_Stop_DMA_7: (+1)
   \   00000082   0x6801             LDR      R1,[R0, #+0]
   \   00000084   0xF241 0x1311      MOVW     R3,#+4369
   \   00000088   0x6A0A             LDR      R2,[R1, #+32]
   \   0000008A   0x421A             TST      R2,R3
   \   0000008C   0xBF02             ITTT     EQ 
   \   0000008E   0x6A0A             LDREQ    R2,[R1, #+32]
   \   00000090   0xF240 0x4344      MOVWEQ   R3,#+1092
   \   00000094   0x421A             TSTEQ    R2,R3
   \   00000096   0xD103             BNE.N    ??HAL_TIM_OC_Stop_DMA_8
   \   00000098   0x680A             LDR      R2,[R1, #+0]
   \   0000009A   0x0852             LSRS     R2,R2,#+1
   \   0000009C   0x0052             LSLS     R2,R2,#+1
   \   0000009E   0x600A             STR      R2,[R1, #+0]
    947            
    948            /* Change the htim state */
    949            htim->State = HAL_TIM_STATE_READY;
   \                     ??HAL_TIM_OC_Stop_DMA_8: (+1)
   \   000000A0   0xF880 0x4039      STRB     R4,[R0, #+57]
    950            
    951            /* Return function status */
    952            return HAL_OK;
   \   000000A4   0x2000             MOVS     R0,#+0
   \   000000A6   0xBC10             POP      {R4}
   \   000000A8   0x4770             BX       LR               ;; return
    953          }
    954          
    955          /**
    956            * @}
    957            */
    958          
    959          /** @defgroup TIM_Exported_Functions_Group3 Time PWM functions 
    960           *  @brief    Time PWM functions 
    961           *
    962          @verbatim    
    963            ==============================================================================
    964                                    ##### Time PWM functions #####
    965            ==============================================================================
    966            [..]  
    967              This section provides functions allowing to:
    968              (+) Initialize and configure the TIM OPWM. 
    969              (+) De-initialize the TIM PWM.
    970              (+) Start the Time PWM.
    971              (+) Stop the Time PWM.
    972              (+) Start the Time PWM and enable interrupt.
    973              (+) Stop the Time PWM and disable interrupt.
    974              (+) Start the Time PWM and enable DMA transfer.
    975              (+) Stop the Time PWM and disable DMA transfer.
    976           
    977          @endverbatim
    978            * @{
    979            */
    980          /**
    981            * @brief  Initializes the TIM PWM Time Base according to the specified
    982            *         parameters in the TIM_HandleTypeDef and create the associated handle.
    983            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
    984            *                the configuration information for TIM module.
    985            * @retval HAL status
    986            */

   \                                 In section .text, align 2, keep-with-next
    987          HAL_StatusTypeDef HAL_TIM_PWM_Init(TIM_HandleTypeDef *htim)
    988          {
   \                     HAL_TIM_PWM_Init: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0xB081             SUB      SP,SP,#+4
    989            /* Check the TIM handle allocation */
    990            if(htim == NULL)
   \   00000006   0xBF08             IT       EQ 
   \   00000008   0x2001             MOVEQ    R0,#+1
    991            {
    992              return HAL_ERROR;
   \   0000000A   0xD068             BEQ.N    ??HAL_TIM_PWM_Init_0
    993            }
    994          
    995            /* Check the parameters */
    996            assert_param(IS_TIM_INSTANCE(htim->Instance));
    997            assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
    998            assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
    999          
   1000            if(htim->State == HAL_TIM_STATE_RESET)
   \   0000000C   0xF894 0x0039      LDRB     R0,[R4, #+57]
   \   00000010   0xB920             CBNZ.N   R0,??HAL_TIM_PWM_Init_1
   1001            {
   1002              /* Allocate lock resource and initialize it */
   1003              htim->Lock = HAL_UNLOCKED;  
   \   00000012   0xF884 0x0038      STRB     R0,[R4, #+56]
   1004              /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
   1005              HAL_TIM_PWM_MspInit(htim);
   \   00000016   0x4620             MOV      R0,R4
   \   00000018   0x.... 0x....      BL       HAL_TIM_PWM_MspInit
   1006            }
   1007          
   1008            /* Set the TIM state */
   1009            htim->State= HAL_TIM_STATE_BUSY;  
   \                     ??HAL_TIM_PWM_Init_1: (+1)
   \   0000001C   0x2002             MOVS     R0,#+2
   1010            
   1011            /* Init the base time for the PWM */  
   1012            TIM_Base_SetConfig(htim->Instance, &htim->Init); 
   \   0000001E   0x.... 0x....      LDR.W    R2,??DataTable15  ;; 0x40010000
   \   00000022   0xF884 0x0039      STRB     R0,[R4, #+57]
   \   00000026   0x1D20             ADDS     R0,R4,#+4
   \   00000028   0x6821             LDR      R1,[R4, #+0]
   \   0000002A   0x4291             CMP      R1,R2
   \   0000002C   0x680B             LDR      R3,[R1, #+0]
   \   0000002E   0xBF18             IT       NE 
   \   00000030   0xF1B1 0x4F80      CMPNE    R1,#+1073741824
   \   00000034   0xD00F             BEQ.N    ??HAL_TIM_PWM_Init_2
   \   00000036   0x.... 0x....      LDR.W    R5,??DataTable15_1  ;; 0x40000400
   \   0000003A   0x42A9             CMP      R1,R5
   \   0000003C   0xBF1C             ITT      NE 
   \   0000003E   0x.... 0x....      LDRNE.W  R5,??DataTable15_2  ;; 0x40000800
   \   00000042   0x42A9             CMPNE    R1,R5
   \   00000044   0xD007             BEQ.N    ??HAL_TIM_PWM_Init_2
   \   00000046   0x.... 0x....      LDR.W    R5,??DataTable15_3  ;; 0x40000c00
   \   0000004A   0x42A9             CMP      R1,R5
   \   0000004C   0xBF1C             ITT      NE 
   \   0000004E   0x.... 0x....      LDRNE.W  R5,??DataTable16  ;; 0x40010400
   \   00000052   0x42A9             CMPNE    R1,R5
   \   00000054   0xD113             BNE.N    ??HAL_TIM_PWM_Init_3
   \                     ??HAL_TIM_PWM_Init_2: (+1)
   \   00000056   0x6845             LDR      R5,[R0, #+4]
   \   00000058   0xF023 0x0370      BIC      R3,R3,#0x70
   \   0000005C   0x432B             ORRS     R3,R5,R3
   \   0000005E   0x4291             CMP      R1,R2
   \   00000060   0xBF18             IT       NE 
   \   00000062   0xF1B1 0x4F80      CMPNE    R1,#+1073741824
   \   00000066   0xD025             BEQ.N    ??HAL_TIM_PWM_Init_4
   \   00000068   0x.... 0x....      LDR.W    R5,??DataTable15_1  ;; 0x40000400
   \   0000006C   0x42A9             CMP      R1,R5
   \   0000006E   0xBF1F             ITTTT    NE 
   \   00000070   0x.... 0x....      LDRNE.W  R5,??DataTable15_2  ;; 0x40000800
   \   00000074   0x42A9             CMPNE    R1,R5
   \   00000076   0x.... 0x....      LDRNE.W  R5,??DataTable15_3  ;; 0x40000c00
   \   0000007A   0x42A9             CMPNE    R1,R5
   \   0000007C   0xD01A             BEQ.N    ??HAL_TIM_PWM_Init_4
   \                     ??HAL_TIM_PWM_Init_3: (+1)
   \   0000007E   0x.... 0x....      LDR.W    R5,??DataTable16  ;; 0x40010400
   \   00000082   0x42A9             CMP      R1,R5
   \   00000084   0xBF1C             ITT      NE 
   \   00000086   0x.... 0x....      LDRNE.W  R5,??DataTable16_1  ;; 0x40014000
   \   0000008A   0x42A9             CMPNE    R1,R5
   \   0000008C   0xD012             BEQ.N    ??HAL_TIM_PWM_Init_4
   \   0000008E   0x.... 0x....      LDR.W    R5,??DataTable16_2  ;; 0x40014400
   \   00000092   0x42A9             CMP      R1,R5
   \   00000094   0xBF1C             ITT      NE 
   \   00000096   0x.... 0x....      LDRNE.W  R5,??DataTable16_3  ;; 0x40014800
   \   0000009A   0x42A9             CMPNE    R1,R5
   \   0000009C   0xD00A             BEQ.N    ??HAL_TIM_PWM_Init_4
   \   0000009E   0x.... 0x....      LDR.W    R5,??DataTable16_4  ;; 0x40001800
   \   000000A2   0x42A9             CMP      R1,R5
   \   000000A4   0xBF1F             ITTTT    NE 
   \   000000A6   0x.... 0x....      LDRNE.W  R5,??DataTable16_5  ;; 0x40001c00
   \   000000AA   0x42A9             CMPNE    R1,R5
   \   000000AC   0x.... 0x....      LDRNE.W  R5,??DataTable16_6  ;; 0x40002000
   \   000000B0   0x42A9             CMPNE    R1,R5
   \   000000B2   0xD103             BNE.N    ??HAL_TIM_PWM_Init_5
   \                     ??HAL_TIM_PWM_Init_4: (+1)
   \   000000B4   0x68C5             LDR      R5,[R0, #+12]
   \   000000B6   0xF423 0x7340      BIC      R3,R3,#0x300
   \   000000BA   0x432B             ORRS     R3,R5,R3
   \                     ??HAL_TIM_PWM_Init_5: (+1)
   \   000000BC   0x600B             STR      R3,[R1, #+0]
   \   000000BE   0x6883             LDR      R3,[R0, #+8]
   \   000000C0   0x4291             CMP      R1,R2
   \   000000C2   0x62CB             STR      R3,[R1, #+44]
   \   000000C4   0x6803             LDR      R3,[R0, #+0]
   \   000000C6   0x628B             STR      R3,[R1, #+40]
   \   000000C8   0xBF19             ITTEE    NE 
   \   000000CA   0x.... 0x....      LDRNE.W  R2,??DataTable16  ;; 0x40010400
   \   000000CE   0x4291             CMPNE    R1,R2
   \   000000D0   0x6900             LDREQ    R0,[R0, #+16]
   \   000000D2   0x6308             STREQ    R0,[R1, #+48]
   \   000000D4   0x2001             MOVS     R0,#+1
   \   000000D6   0x6148             STR      R0,[R1, #+20]
   1013             
   1014            /* Initialize the TIM state*/
   1015            htim->State= HAL_TIM_STATE_READY;
   \   000000D8   0xF884 0x0039      STRB     R0,[R4, #+57]
   1016            
   1017            return HAL_OK;
   \   000000DC   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_PWM_Init_0: (+1)
   \   000000DE   0xB001             ADD      SP,SP,#+4
   \   000000E0   0xBD30             POP      {R4,R5,PC}       ;; return
   1018          }  
   1019          
   1020          /**
   1021            * @brief  DeInitializes the TIM peripheral 
   1022            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   1023            *                the configuration information for TIM module.
   1024            * @retval HAL status
   1025            */

   \                                 In section .text, align 2, keep-with-next
   1026          HAL_StatusTypeDef HAL_TIM_PWM_DeInit(TIM_HandleTypeDef *htim)
   1027          {
   \                     HAL_TIM_PWM_DeInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   1028            /* Check the parameters */
   1029            assert_param(IS_TIM_INSTANCE(htim->Instance));
   1030            
   1031            htim->State = HAL_TIM_STATE_BUSY;
   \   00000004   0x2002             MOVS     R0,#+2
   \   00000006   0xF884 0x0039      STRB     R0,[R4, #+57]
   1032            
   1033            /* Disable the TIM Peripheral Clock */
   1034            __HAL_TIM_DISABLE(htim);
   \   0000000A   0xF241 0x1211      MOVW     R2,#+4369
   \   0000000E   0x6820             LDR      R0,[R4, #+0]
   \   00000010   0x6A01             LDR      R1,[R0, #+32]
   \   00000012   0x4211             TST      R1,R2
   \   00000014   0xBF02             ITTT     EQ 
   \   00000016   0x6A01             LDREQ    R1,[R0, #+32]
   \   00000018   0xF240 0x4244      MOVWEQ   R2,#+1092
   \   0000001C   0x4211             TSTEQ    R1,R2
   \   0000001E   0xD103             BNE.N    ??HAL_TIM_PWM_DeInit_0
   \   00000020   0x6801             LDR      R1,[R0, #+0]
   \   00000022   0x0849             LSRS     R1,R1,#+1
   \   00000024   0x0049             LSLS     R1,R1,#+1
   \   00000026   0x6001             STR      R1,[R0, #+0]
   1035              
   1036            /* DeInit the low level hardware: GPIO, CLOCK, NVIC and DMA */
   1037            HAL_TIM_PWM_MspDeInit(htim);
   \                     ??HAL_TIM_PWM_DeInit_0: (+1)
   \   00000028   0x4620             MOV      R0,R4
   \   0000002A   0x.... 0x....      BL       HAL_TIM_PWM_MspDeInit
   1038              
   1039            /* Change TIM state */  
   1040            htim->State = HAL_TIM_STATE_RESET; 
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0xF884 0x0039      STRB     R0,[R4, #+57]
   1041          
   1042            /* Release Lock */
   1043            __HAL_UNLOCK(htim);
   \   00000034   0xF884 0x0038      STRB     R0,[R4, #+56]
   1044          
   1045            return HAL_OK;
   \   00000038   0xBD10             POP      {R4,PC}          ;; return
   1046          }
   1047          
   1048          /**
   1049            * @brief  Initializes the TIM PWM MSP.
   1050            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   1051            *                the configuration information for TIM module.
   1052            * @retval None
   1053            */

   \                                 In section .text, align 2, keep-with-next
   1054          __weak void HAL_TIM_PWM_MspInit(TIM_HandleTypeDef *htim)
   1055          {
   1056            /* NOTE : This function Should not be modified, when the callback is needed,
   1057                      the HAL_TIM_PWM_MspInit could be implemented in the user file
   1058             */
   1059          }
   \                     HAL_TIM_PWM_MspInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1060          
   1061          /**
   1062            * @brief  DeInitializes TIM PWM MSP.
   1063            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   1064            *                the configuration information for TIM module.
   1065            * @retval None
   1066            */

   \                                 In section .text, align 2, keep-with-next
   1067          __weak void HAL_TIM_PWM_MspDeInit(TIM_HandleTypeDef *htim)
   1068          {
   1069            /* NOTE : This function Should not be modified, when the callback is needed,
   1070                      the HAL_TIM_PWM_MspDeInit could be implemented in the user file
   1071             */
   1072          }
   \                     HAL_TIM_PWM_MspDeInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1073          
   1074          /**
   1075            * @brief  Starts the PWM signal generation.
   1076            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   1077            *                the configuration information for TIM module.
   1078            * @param  Channel: TIM Channels to be enabled.
   1079            *          This parameter can be one of the following values:
   1080            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1081            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1082            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1083            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1084            * @retval HAL status
   1085            */

   \                                 In section .text, align 2, keep-with-next
   1086          HAL_StatusTypeDef HAL_TIM_PWM_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
   1087          {
   1088            /* Check the parameters */
   1089            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1090          
   1091            /* Enable the Capture compare channel */
   1092            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
   \                     HAL_TIM_PWM_Start: (+1)
   \   00000000   0x6800             LDR      R0,[R0, #+0]
   \   00000002   0x2201             MOVS     R2,#+1
   \   00000004   0xFA02 0xF101      LSL      R1,R2,R1
   \   00000008   0x6A02             LDR      R2,[R0, #+32]
   \   0000000A   0x438A             BICS     R2,R2,R1
   \   0000000C   0x6202             STR      R2,[R0, #+32]
   \   0000000E   0x6A02             LDR      R2,[R0, #+32]
   \   00000010   0x4311             ORRS     R1,R1,R2
   \   00000012   0x6201             STR      R1,[R0, #+32]
   1093            
   1094            if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
   \   00000014   0x....             LDR.N    R1,??DataTable15  ;; 0x40010000
   \   00000016   0x4288             CMP      R0,R1
   \   00000018   0xBF1C             ITT      NE 
   \   0000001A   0x.... 0x....      LDRNE.W  R1,??DataTable16  ;; 0x40010400
   \   0000001E   0x4288             CMPNE    R0,R1
   \   00000020   0xD103             BNE.N    ??HAL_TIM_PWM_Start_0
   1095            {
   1096              /* Enable the main output */
   1097              __HAL_TIM_MOE_ENABLE(htim);
   \   00000022   0x6C41             LDR      R1,[R0, #+68]
   \   00000024   0xF441 0x4100      ORR      R1,R1,#0x8000
   \   00000028   0x6441             STR      R1,[R0, #+68]
   1098            }
   1099              
   1100            /* Enable the Peripheral */
   1101            __HAL_TIM_ENABLE(htim);
   \                     ??HAL_TIM_PWM_Start_0: (+1)
   \   0000002A   0x6801             LDR      R1,[R0, #+0]
   \   0000002C   0xF041 0x0101      ORR      R1,R1,#0x1
   \   00000030   0x6001             STR      R1,[R0, #+0]
   1102            
   1103            /* Return function status */
   1104            return HAL_OK;
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0x4770             BX       LR               ;; return
   1105          } 
   1106          
   1107          /**
   1108            * @brief  Stops the PWM signal generation.
   1109            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   1110            *                the configuration information for TIM module.
   1111            * @param  Channel: TIM Channels to be disabled.
   1112            *          This parameter can be one of the following values:
   1113            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1114            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1115            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1116            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1117            * @retval HAL status
   1118            */

   \                                 In section .text, align 2, keep-with-next
   1119          HAL_StatusTypeDef HAL_TIM_PWM_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
   1120          { 
   1121            /* Check the parameters */
   1122            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1123              
   1124            /* Disable the Capture compare channel */
   1125            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
   \                     HAL_TIM_PWM_Stop: (+1)
   \   00000000   0x6802             LDR      R2,[R0, #+0]
   \   00000002   0xF04F 0x0C01      MOV      R12,#+1
   \   00000006   0xFA0C 0xF101      LSL      R1,R12,R1
   \   0000000A   0x6A13             LDR      R3,[R2, #+32]
   \   0000000C   0xEA23 0x0101      BIC      R1,R3,R1
   \   00000010   0x6211             STR      R1,[R2, #+32]
   \   00000012   0x6A11             LDR      R1,[R2, #+32]
   \   00000014   0x6211             STR      R1,[R2, #+32]
   1126            
   1127            if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
   \   00000016   0x6801             LDR      R1,[R0, #+0]
   \   00000018   0x....             LDR.N    R2,??DataTable15  ;; 0x40010000
   \   0000001A   0x4291             CMP      R1,R2
   \   0000001C   0xBF1C             ITT      NE 
   \   0000001E   0x.... 0x....      LDRNE.W  R2,??DataTable16  ;; 0x40010400
   \   00000022   0x4291             CMPNE    R1,R2
   \   00000024   0xD10D             BNE.N    ??HAL_TIM_PWM_Stop_0
   1128            {
   1129              /* Disable the Main Output */
   1130              __HAL_TIM_MOE_DISABLE(htim);
   \   00000026   0x6A0A             LDR      R2,[R1, #+32]
   \   00000028   0xF241 0x1311      MOVW     R3,#+4369
   \   0000002C   0x421A             TST      R2,R3
   \   0000002E   0xBF02             ITTT     EQ 
   \   00000030   0x6A0A             LDREQ    R2,[R1, #+32]
   \   00000032   0xF240 0x4344      MOVWEQ   R3,#+1092
   \   00000036   0x421A             TSTEQ    R2,R3
   \   00000038   0xD103             BNE.N    ??HAL_TIM_PWM_Stop_0
   \   0000003A   0x6C4A             LDR      R2,[R1, #+68]
   \   0000003C   0xF422 0x4200      BIC      R2,R2,#0x8000
   \   00000040   0x644A             STR      R2,[R1, #+68]
   1131            }
   1132            
   1133            /* Disable the Peripheral */
   1134            __HAL_TIM_DISABLE(htim);
   \                     ??HAL_TIM_PWM_Stop_0: (+1)
   \   00000042   0x6801             LDR      R1,[R0, #+0]
   \   00000044   0xF241 0x1311      MOVW     R3,#+4369
   \   00000048   0x6A0A             LDR      R2,[R1, #+32]
   \   0000004A   0x421A             TST      R2,R3
   \   0000004C   0xBF02             ITTT     EQ 
   \   0000004E   0x6A0A             LDREQ    R2,[R1, #+32]
   \   00000050   0xF240 0x4344      MOVWEQ   R3,#+1092
   \   00000054   0x421A             TSTEQ    R2,R3
   \   00000056   0xD103             BNE.N    ??HAL_TIM_PWM_Stop_1
   \   00000058   0x680A             LDR      R2,[R1, #+0]
   \   0000005A   0x0852             LSRS     R2,R2,#+1
   \   0000005C   0x0052             LSLS     R2,R2,#+1
   \   0000005E   0x600A             STR      R2,[R1, #+0]
   1135            
   1136            /* Change the htim state */
   1137            htim->State = HAL_TIM_STATE_READY;
   \                     ??HAL_TIM_PWM_Stop_1: (+1)
   \   00000060   0xF880 0xC039      STRB     R12,[R0, #+57]
   1138            
   1139            /* Return function status */
   1140            return HAL_OK;
   \   00000064   0x2000             MOVS     R0,#+0
   \   00000066   0x4770             BX       LR               ;; return
   1141          } 
   1142          
   1143          /**
   1144            * @brief  Starts the PWM signal generation in interrupt mode.
   1145            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   1146            *                the configuration information for TIM module.
   1147            * @param  Channel: TIM Channel to be disabled.
   1148            *          This parameter can be one of the following values:
   1149            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1150            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1151            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1152            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1153            * @retval HAL status
   1154            */

   \                                 In section .text, align 4, keep-with-next
   1155          HAL_StatusTypeDef HAL_TIM_PWM_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
   1156          {
   1157            /* Check the parameters */
   1158            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1159            
   1160            switch (Channel)
   \                     HAL_TIM_PWM_Start_IT: (+1)
   \   00000000   0x290C             CMP      R1,#+12
   \   00000002   0xD81C             BHI.N    ??HAL_TIM_PWM_Start_IT_1
   \   00000004   0xE8DF 0xF001      TBB      [PC, R1]
   \                     ??HAL_TIM_PWM_Start_IT_0:
   \   00000008   0x07 0x1B          DC8      0x7,0x1B,0x1B,0x1B
   \              0x1B 0x1B    
   \   0000000C   0x0C 0x1B          DC8      0xC,0x1B,0x1B,0x1B
   \              0x1B 0x1B    
   \   00000010   0x11 0x1B          DC8      0x11,0x1B,0x1B,0x1B
   \              0x1B 0x1B    
   \   00000014   0x16 0x00          DC8      0x16,0x0
   1161            {
   1162              case TIM_CHANNEL_1:
   1163              {       
   1164                /* Enable the TIM Capture/Compare 1 interrupt */
   1165                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
   \                     ??HAL_TIM_PWM_Start_IT_2: (+1)
   \   00000016   0x6802             LDR      R2,[R0, #+0]
   \   00000018   0x68D3             LDR      R3,[R2, #+12]
   \   0000001A   0xF043 0x0302      ORR      R3,R3,#0x2
   \   0000001E   0xE00D             B.N      ??HAL_TIM_PWM_Start_IT_3
   1166              }
   1167              break;
   1168              
   1169              case TIM_CHANNEL_2:
   1170              {
   1171                /* Enable the TIM Capture/Compare 2 interrupt */
   1172                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
   \                     ??HAL_TIM_PWM_Start_IT_4: (+1)
   \   00000020   0x6802             LDR      R2,[R0, #+0]
   \   00000022   0x68D3             LDR      R3,[R2, #+12]
   \   00000024   0xF043 0x0304      ORR      R3,R3,#0x4
   \   00000028   0xE008             B.N      ??HAL_TIM_PWM_Start_IT_3
   1173              }
   1174              break;
   1175              
   1176              case TIM_CHANNEL_3:
   1177              {
   1178                /* Enable the TIM Capture/Compare 3 interrupt */
   1179                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);
   \                     ??HAL_TIM_PWM_Start_IT_5: (+1)
   \   0000002A   0x6802             LDR      R2,[R0, #+0]
   \   0000002C   0x68D3             LDR      R3,[R2, #+12]
   \   0000002E   0xF043 0x0308      ORR      R3,R3,#0x8
   \   00000032   0xE003             B.N      ??HAL_TIM_PWM_Start_IT_3
   1180              }
   1181              break;
   1182              
   1183              case TIM_CHANNEL_4:
   1184              {
   1185                /* Enable the TIM Capture/Compare 4 interrupt */
   1186                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC4);
   \                     ??HAL_TIM_PWM_Start_IT_6: (+1)
   \   00000034   0x6802             LDR      R2,[R0, #+0]
   \   00000036   0x68D3             LDR      R3,[R2, #+12]
   \   00000038   0xF043 0x0310      ORR      R3,R3,#0x10
   \                     ??HAL_TIM_PWM_Start_IT_3: (+1)
   \   0000003C   0x60D3             STR      R3,[R2, #+12]
   1187              }
   1188              break;
   1189              
   1190              default:
   1191              break;
   1192            } 
   1193            
   1194            /* Enable the Capture compare channel */
   1195            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
   \                     ??HAL_TIM_PWM_Start_IT_1: (+1)
   \   0000003E   0x6802             LDR      R2,[R0, #+0]
   \   00000040   0x2001             MOVS     R0,#+1
   \   00000042   0x4088             LSLS     R0,R0,R1
   \   00000044   0x6A11             LDR      R1,[R2, #+32]
   \   00000046   0x4381             BICS     R1,R1,R0
   \   00000048   0x6211             STR      R1,[R2, #+32]
   \   0000004A   0x6A11             LDR      R1,[R2, #+32]
   \   0000004C   0x4308             ORRS     R0,R0,R1
   \   0000004E   0x6210             STR      R0,[R2, #+32]
   1196            
   1197            if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
   \   00000050   0x....             LDR.N    R0,??DataTable15  ;; 0x40010000
   \   00000052   0x4282             CMP      R2,R0
   \   00000054   0xBF1C             ITT      NE 
   \   00000056   0x....             LDRNE.N  R0,??DataTable16  ;; 0x40010400
   \   00000058   0x4282             CMPNE    R2,R0
   \   0000005A   0xD103             BNE.N    ??HAL_TIM_PWM_Start_IT_7
   1198            {
   1199              /* Enable the main output */
   1200              __HAL_TIM_MOE_ENABLE(htim);
   \   0000005C   0x6C50             LDR      R0,[R2, #+68]
   \   0000005E   0xF440 0x4000      ORR      R0,R0,#0x8000
   \   00000062   0x6450             STR      R0,[R2, #+68]
   1201            }
   1202          
   1203            /* Enable the Peripheral */
   1204            __HAL_TIM_ENABLE(htim);
   \                     ??HAL_TIM_PWM_Start_IT_7: (+1)
   \   00000064   0x6810             LDR      R0,[R2, #+0]
   \   00000066   0xF040 0x0001      ORR      R0,R0,#0x1
   \   0000006A   0x6010             STR      R0,[R2, #+0]
   1205            
   1206            /* Return function status */
   1207            return HAL_OK;
   \   0000006C   0x2000             MOVS     R0,#+0
   \   0000006E   0x4770             BX       LR               ;; return
   1208          } 
   1209          
   1210          /**
   1211            * @brief  Stops the PWM signal generation in interrupt mode.
   1212            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   1213            *                the configuration information for TIM module.
   1214            * @param  Channel: TIM Channels to be disabled.
   1215            *          This parameter can be one of the following values:
   1216            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1217            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1218            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1219            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1220            * @retval HAL status
   1221            */

   \                                 In section .text, align 4, keep-with-next
   1222          HAL_StatusTypeDef HAL_TIM_PWM_Stop_IT (TIM_HandleTypeDef *htim, uint32_t Channel)
   1223          {
   1224            /* Check the parameters */
   1225            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1226            
   1227            switch (Channel)
   \                     HAL_TIM_PWM_Stop_IT: (+1)
   \   00000000   0x290C             CMP      R1,#+12
   \   00000002   0xD81C             BHI.N    ??HAL_TIM_PWM_Stop_IT_1
   \   00000004   0xE8DF 0xF001      TBB      [PC, R1]
   \                     ??HAL_TIM_PWM_Stop_IT_0:
   \   00000008   0x07 0x1B          DC8      0x7,0x1B,0x1B,0x1B
   \              0x1B 0x1B    
   \   0000000C   0x0C 0x1B          DC8      0xC,0x1B,0x1B,0x1B
   \              0x1B 0x1B    
   \   00000010   0x11 0x1B          DC8      0x11,0x1B,0x1B,0x1B
   \              0x1B 0x1B    
   \   00000014   0x16 0x00          DC8      0x16,0x0
   1228            {
   1229              case TIM_CHANNEL_1:
   1230              {       
   1231                /* Disable the TIM Capture/Compare 1 interrupt */
   1232                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
   \                     ??HAL_TIM_PWM_Stop_IT_2: (+1)
   \   00000016   0x6802             LDR      R2,[R0, #+0]
   \   00000018   0x68D3             LDR      R3,[R2, #+12]
   \   0000001A   0xF023 0x0302      BIC      R3,R3,#0x2
   \   0000001E   0xE00D             B.N      ??HAL_TIM_PWM_Stop_IT_3
   1233              }
   1234              break;
   1235              
   1236              case TIM_CHANNEL_2:
   1237              {
   1238                /* Disable the TIM Capture/Compare 2 interrupt */
   1239                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
   \                     ??HAL_TIM_PWM_Stop_IT_4: (+1)
   \   00000020   0x6802             LDR      R2,[R0, #+0]
   \   00000022   0x68D3             LDR      R3,[R2, #+12]
   \   00000024   0xF023 0x0304      BIC      R3,R3,#0x4
   \   00000028   0xE008             B.N      ??HAL_TIM_PWM_Stop_IT_3
   1240              }
   1241              break;
   1242              
   1243              case TIM_CHANNEL_3:
   1244              {
   1245                /* Disable the TIM Capture/Compare 3 interrupt */
   1246                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);
   \                     ??HAL_TIM_PWM_Stop_IT_5: (+1)
   \   0000002A   0x6802             LDR      R2,[R0, #+0]
   \   0000002C   0x68D3             LDR      R3,[R2, #+12]
   \   0000002E   0xF023 0x0308      BIC      R3,R3,#0x8
   \   00000032   0xE003             B.N      ??HAL_TIM_PWM_Stop_IT_3
   1247              }
   1248              break;
   1249              
   1250              case TIM_CHANNEL_4:
   1251              {
   1252                /* Disable the TIM Capture/Compare 4 interrupt */
   1253                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC4);
   \                     ??HAL_TIM_PWM_Stop_IT_6: (+1)
   \   00000034   0x6802             LDR      R2,[R0, #+0]
   \   00000036   0x68D3             LDR      R3,[R2, #+12]
   \   00000038   0xF023 0x0310      BIC      R3,R3,#0x10
   \                     ??HAL_TIM_PWM_Stop_IT_3: (+1)
   \   0000003C   0x60D3             STR      R3,[R2, #+12]
   1254              }
   1255              break;
   1256              
   1257              default:
   1258              break; 
   1259            }
   1260            
   1261            /* Disable the Capture compare channel */
   1262            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
   \                     ??HAL_TIM_PWM_Stop_IT_1: (+1)
   \   0000003E   0x6802             LDR      R2,[R0, #+0]
   \   00000040   0x2301             MOVS     R3,#+1
   \   00000042   0xFA03 0xF101      LSL      R1,R3,R1
   \   00000046   0x6A10             LDR      R0,[R2, #+32]
   \   00000048   0x4388             BICS     R0,R0,R1
   \   0000004A   0x6210             STR      R0,[R2, #+32]
   \   0000004C   0x6A10             LDR      R0,[R2, #+32]
   \   0000004E   0x6210             STR      R0,[R2, #+32]
   1263            
   1264            if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
   \   00000050   0x....             LDR.N    R0,??DataTable15  ;; 0x40010000
   \   00000052   0x4282             CMP      R2,R0
   \   00000054   0xBF1C             ITT      NE 
   \   00000056   0x....             LDRNE.N  R0,??DataTable16  ;; 0x40010400
   \   00000058   0x4282             CMPNE    R2,R0
   \   0000005A   0xD10D             BNE.N    ??HAL_TIM_PWM_Stop_IT_7
   1265            {
   1266              /* Disable the Main Output */
   1267              __HAL_TIM_MOE_DISABLE(htim);
   \   0000005C   0x6A10             LDR      R0,[R2, #+32]
   \   0000005E   0xF241 0x1111      MOVW     R1,#+4369
   \   00000062   0x4208             TST      R0,R1
   \   00000064   0xBF02             ITTT     EQ 
   \   00000066   0x6A10             LDREQ    R0,[R2, #+32]
   \   00000068   0xF240 0x4144      MOVWEQ   R1,#+1092
   \   0000006C   0x4208             TSTEQ    R0,R1
   \   0000006E   0xD103             BNE.N    ??HAL_TIM_PWM_Stop_IT_7
   \   00000070   0x6C50             LDR      R0,[R2, #+68]
   \   00000072   0xF420 0x4000      BIC      R0,R0,#0x8000
   \   00000076   0x6450             STR      R0,[R2, #+68]
   1268            }
   1269            
   1270            /* Disable the Peripheral */
   1271            __HAL_TIM_DISABLE(htim);
   \                     ??HAL_TIM_PWM_Stop_IT_7: (+1)
   \   00000078   0x6A10             LDR      R0,[R2, #+32]
   \   0000007A   0xF241 0x1111      MOVW     R1,#+4369
   \   0000007E   0x4208             TST      R0,R1
   \   00000080   0xBF02             ITTT     EQ 
   \   00000082   0x6A10             LDREQ    R0,[R2, #+32]
   \   00000084   0xF240 0x4144      MOVWEQ   R1,#+1092
   \   00000088   0x4208             TSTEQ    R0,R1
   \   0000008A   0xD103             BNE.N    ??HAL_TIM_PWM_Stop_IT_8
   \   0000008C   0x6810             LDR      R0,[R2, #+0]
   \   0000008E   0x0840             LSRS     R0,R0,#+1
   \   00000090   0x0040             LSLS     R0,R0,#+1
   \   00000092   0x6010             STR      R0,[R2, #+0]
   1272            
   1273            /* Return function status */
   1274            return HAL_OK;
   \                     ??HAL_TIM_PWM_Stop_IT_8: (+1)
   \   00000094   0x2000             MOVS     R0,#+0
   \   00000096   0x4770             BX       LR               ;; return
   1275          } 
   1276          
   1277          /**
   1278            * @brief  Starts the TIM PWM signal generation in DMA mode.
   1279            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   1280            *                the configuration information for TIM module.
   1281            * @param  Channel: TIM Channels to be enabled.
   1282            *          This parameter can be one of the following values:
   1283            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1284            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1285            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1286            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1287            * @param  pData: The source Buffer address.
   1288            * @param  Length: The length of data to be transferred from memory to TIM peripheral
   1289            * @retval HAL status
   1290            */

   \                                 In section .text, align 4, keep-with-next
   1291          HAL_StatusTypeDef HAL_TIM_PWM_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData, uint16_t Length)
   1292          {
   \                     HAL_TIM_PWM_Start_DMA: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0xB081             SUB      SP,SP,#+4
   \   00000006   0x460D             MOV      R5,R1
   \   00000008   0x4611             MOV      R1,R2
   1293            /* Check the parameters */
   1294            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1295            
   1296            if((htim->State == HAL_TIM_STATE_BUSY))
   \   0000000A   0xF894 0x0039      LDRB     R0,[R4, #+57]
   \   0000000E   0x2802             CMP      R0,#+2
   \   00000010   0xF000 0x807B      BEQ.W    ??HAL_TIM_PWM_Start_DMA_1
   1297            {
   1298               return HAL_BUSY;
   1299            }
   1300            else if((htim->State == HAL_TIM_STATE_READY))
   \   00000014   0xF894 0x0039      LDRB     R0,[R4, #+57]
   \   00000018   0x2801             CMP      R0,#+1
   \   0000001A   0xD105             BNE.N    ??HAL_TIM_PWM_Start_DMA_2
   1301            {
   1302              if(((uint32_t)pData == 0 ) && (Length > 0)) 
   \   0000001C   0xB909             CBNZ.N   R1,??HAL_TIM_PWM_Start_DMA_3
   \   0000001E   0x2B00             CMP      R3,#+0
   \   00000020   0xD173             BNE.N    ??HAL_TIM_PWM_Start_DMA_1
   1303              {
   1304                return HAL_ERROR;                                    
   1305              }
   1306              else
   1307              {
   1308                htim->State = HAL_TIM_STATE_BUSY;
   \                     ??HAL_TIM_PWM_Start_DMA_3: (+1)
   \   00000022   0x2002             MOVS     R0,#+2
   \   00000024   0xF884 0x0039      STRB     R0,[R4, #+57]
   1309              }
   1310            }    
   1311            switch (Channel)
   \                     ??HAL_TIM_PWM_Start_DMA_2: (+1)
   \   00000028   0x2D0C             CMP      R5,#+12
   \   0000002A   0xD854             BHI.N    ??HAL_TIM_PWM_Start_DMA_4
   \   0000002C   0xE8DF 0xF005      TBB      [PC, R5]
   \                     ??HAL_TIM_PWM_Start_DMA_0:
   \   00000030   0x07 0x53          DC8      0x7,0x53,0x53,0x53
   \              0x53 0x53    
   \   00000034   0x1A 0x53          DC8      0x1A,0x53,0x53,0x53
   \              0x53 0x53    
   \   00000038   0x2D 0x53          DC8      0x2D,0x53,0x53,0x53
   \              0x53 0x53    
   \   0000003C   0x40 0x00          DC8      0x40,0x0
   1312            {
   1313              case TIM_CHANNEL_1:
   1314              {      
   1315                /* Set the DMA Period elapsed callback */
   1316                htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = HAL_TIM_DMADelayPulseCplt;
   \                     ??HAL_TIM_PWM_Start_DMA_5: (+1)
   \   0000003E   0x6A22             LDR      R2,[R4, #+32]
   \   00000040   0x.... 0x....      LDR.W    R0,??DataTable21
   \   00000044   0x63D0             STR      R0,[R2, #+60]
   1317               
   1318                /* Set the DMA error callback */
   1319                htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = HAL_TIM_DMAError ;
   \   00000046   0x6A22             LDR      R2,[R4, #+32]
   \   00000048   0x.... 0x....      LDR.W    R0,??DataTable17
   \   0000004C   0x6490             STR      R0,[R2, #+72]
   1320                
   1321                /* Enable the DMA Stream */
   1322                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)pData, (uint32_t)&htim->Instance->CCR1, Length);
   \   0000004E   0x6820             LDR      R0,[R4, #+0]
   \   00000050   0xF100 0x0234      ADD      R2,R0,#+52
   \   00000054   0x6A20             LDR      R0,[R4, #+32]
   \   00000056   0x.... 0x....      BL       HAL_DMA_Start_IT
   1323                
   1324                /* Enable the TIM Capture/Compare 1 DMA request */
   1325                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
   \   0000005A   0x6820             LDR      R0,[R4, #+0]
   \   0000005C   0x68C1             LDR      R1,[R0, #+12]
   \   0000005E   0xF441 0x7100      ORR      R1,R1,#0x200
   \   00000062   0xE037             B.N      ??HAL_TIM_PWM_Start_DMA_6
   1326              }
   1327              break;
   1328              
   1329              case TIM_CHANNEL_2:
   1330              {
   1331                /* Set the DMA Period elapsed callback */
   1332                htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = HAL_TIM_DMADelayPulseCplt;
   \                     ??HAL_TIM_PWM_Start_DMA_7: (+1)
   \   00000064   0x6A62             LDR      R2,[R4, #+36]
   \   00000066   0x.... 0x....      LDR.W    R0,??DataTable21
   \   0000006A   0x63D0             STR      R0,[R2, #+60]
   1333               
   1334                /* Set the DMA error callback */
   1335                htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = HAL_TIM_DMAError ;
   \   0000006C   0x6A62             LDR      R2,[R4, #+36]
   \   0000006E   0x.... 0x....      LDR.W    R0,??DataTable17
   \   00000072   0x6490             STR      R0,[R2, #+72]
   1336                
   1337                /* Enable the DMA Stream */
   1338                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)pData, (uint32_t)&htim->Instance->CCR2, Length);
   \   00000074   0x6820             LDR      R0,[R4, #+0]
   \   00000076   0xF100 0x0238      ADD      R2,R0,#+56
   \   0000007A   0x6A60             LDR      R0,[R4, #+36]
   \   0000007C   0x.... 0x....      BL       HAL_DMA_Start_IT
   1339                
   1340                /* Enable the TIM Capture/Compare 2 DMA request */
   1341                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
   \   00000080   0x6820             LDR      R0,[R4, #+0]
   \   00000082   0x68C1             LDR      R1,[R0, #+12]
   \   00000084   0xF441 0x6180      ORR      R1,R1,#0x400
   \   00000088   0xE024             B.N      ??HAL_TIM_PWM_Start_DMA_6
   1342              }
   1343              break;
   1344              
   1345              case TIM_CHANNEL_3:
   1346              {
   1347                /* Set the DMA Period elapsed callback */
   1348                htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = HAL_TIM_DMADelayPulseCplt;
   \                     ??HAL_TIM_PWM_Start_DMA_8: (+1)
   \   0000008A   0x6AA2             LDR      R2,[R4, #+40]
   \   0000008C   0x.... 0x....      LDR.W    R0,??DataTable21
   \   00000090   0x63D0             STR      R0,[R2, #+60]
   1349               
   1350                /* Set the DMA error callback */
   1351                htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = HAL_TIM_DMAError ;
   \   00000092   0x6AA2             LDR      R2,[R4, #+40]
   \   00000094   0x.... 0x....      LDR.W    R0,??DataTable17
   \   00000098   0x6490             STR      R0,[R2, #+72]
   1352                
   1353                /* Enable the DMA Stream */
   1354                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)pData, (uint32_t)&htim->Instance->CCR3,Length);
   \   0000009A   0x6820             LDR      R0,[R4, #+0]
   \   0000009C   0xF100 0x023C      ADD      R2,R0,#+60
   \   000000A0   0x6AA0             LDR      R0,[R4, #+40]
   \   000000A2   0x.... 0x....      BL       HAL_DMA_Start_IT
   1355                
   1356                /* Enable the TIM Output Capture/Compare 3 request */
   1357                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);
   \   000000A6   0x6820             LDR      R0,[R4, #+0]
   \   000000A8   0x68C1             LDR      R1,[R0, #+12]
   \   000000AA   0xF441 0x6100      ORR      R1,R1,#0x800
   \   000000AE   0xE011             B.N      ??HAL_TIM_PWM_Start_DMA_6
   1358              }
   1359              break;
   1360              
   1361              case TIM_CHANNEL_4:
   1362              {
   1363               /* Set the DMA Period elapsed callback */
   1364                htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = HAL_TIM_DMADelayPulseCplt;
   \                     ??HAL_TIM_PWM_Start_DMA_9: (+1)
   \   000000B0   0x6AE2             LDR      R2,[R4, #+44]
   \   000000B2   0x.... 0x....      LDR.W    R0,??DataTable21
   \   000000B6   0x63D0             STR      R0,[R2, #+60]
   1365               
   1366                /* Set the DMA error callback */
   1367                htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = HAL_TIM_DMAError ;
   \   000000B8   0x6AE2             LDR      R2,[R4, #+44]
   \   000000BA   0x.... 0x....      LDR.W    R0,??DataTable17
   \   000000BE   0x6490             STR      R0,[R2, #+72]
   1368                
   1369                /* Enable the DMA Stream */
   1370                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)pData, (uint32_t)&htim->Instance->CCR4, Length);
   \   000000C0   0x6820             LDR      R0,[R4, #+0]
   \   000000C2   0xF100 0x0240      ADD      R2,R0,#+64
   \   000000C6   0x6AE0             LDR      R0,[R4, #+44]
   \   000000C8   0x.... 0x....      BL       HAL_DMA_Start_IT
   1371                
   1372                /* Enable the TIM Capture/Compare 4 DMA request */
   1373                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC4);
   \   000000CC   0x6820             LDR      R0,[R4, #+0]
   \   000000CE   0x68C1             LDR      R1,[R0, #+12]
   \   000000D0   0xF441 0x5180      ORR      R1,R1,#0x1000
   \                     ??HAL_TIM_PWM_Start_DMA_6: (+1)
   \   000000D4   0x60C1             STR      R1,[R0, #+12]
   1374              }
   1375              break;
   1376              
   1377              default:
   1378              break;
   1379            }
   1380          
   1381            /* Enable the Capture compare channel */
   1382            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
   \                     ??HAL_TIM_PWM_Start_DMA_4: (+1)
   \   000000D6   0x6820             LDR      R0,[R4, #+0]
   \   000000D8   0x2101             MOVS     R1,#+1
   \   000000DA   0x40A9             LSLS     R1,R1,R5
   \   000000DC   0x6A02             LDR      R2,[R0, #+32]
   \   000000DE   0x438A             BICS     R2,R2,R1
   \   000000E0   0x6202             STR      R2,[R0, #+32]
   \   000000E2   0x6A02             LDR      R2,[R0, #+32]
   \   000000E4   0x4311             ORRS     R1,R1,R2
   \   000000E6   0x6201             STR      R1,[R0, #+32]
   1383              
   1384            if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
   \   000000E8   0x6820             LDR      R0,[R4, #+0]
   \   000000EA   0x....             LDR.N    R1,??DataTable15  ;; 0x40010000
   \   000000EC   0x4288             CMP      R0,R1
   \   000000EE   0xBF1C             ITT      NE 
   \   000000F0   0x....             LDRNE.N  R1,??DataTable16  ;; 0x40010400
   \   000000F2   0x4288             CMPNE    R0,R1
   \   000000F4   0xD103             BNE.N    ??HAL_TIM_PWM_Start_DMA_10
   1385            {
   1386              /* Enable the main output */
   1387              __HAL_TIM_MOE_ENABLE(htim);
   \   000000F6   0x6C41             LDR      R1,[R0, #+68]
   \   000000F8   0xF441 0x4100      ORR      R1,R1,#0x8000
   \   000000FC   0x6441             STR      R1,[R0, #+68]
   1388            }
   1389            
   1390            /* Enable the Peripheral */
   1391            __HAL_TIM_ENABLE(htim); 
   \                     ??HAL_TIM_PWM_Start_DMA_10: (+1)
   \   000000FE   0x6820             LDR      R0,[R4, #+0]
   \   00000100   0x6801             LDR      R1,[R0, #+0]
   \   00000102   0xF041 0x0101      ORR      R1,R1,#0x1
   \   00000106   0x6001             STR      R1,[R0, #+0]
   1392            
   1393            /* Return function status */
   1394            return HAL_OK;
   \   00000108   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_PWM_Start_DMA_1: (+1)
   \   0000010A   0xB001             ADD      SP,SP,#+4
   \   0000010C   0xBD30             POP      {R4,R5,PC}       ;; return
   1395          }
   1396          
   1397          /**
   1398            * @brief  Stops the TIM PWM signal generation in DMA mode.
   1399            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   1400            *                the configuration information for TIM module.
   1401            * @param  Channel: TIM Channels to be disabled.
   1402            *          This parameter can be one of the following values:
   1403            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1404            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1405            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1406            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1407            * @retval HAL status
   1408            */

   \                                 In section .text, align 4, keep-with-next
   1409          HAL_StatusTypeDef HAL_TIM_PWM_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
   1410          {
   1411            /* Check the parameters */
   1412            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1413            
   1414            switch (Channel)
   \                     HAL_TIM_PWM_Stop_DMA: (+1)
   \   00000000   0x290C             CMP      R1,#+12
   \   00000002   0xB410             PUSH     {R4}
   \   00000004   0xD81C             BHI.N    ??HAL_TIM_PWM_Stop_DMA_1
   \   00000006   0xE8DF 0xF001      TBB      [PC, R1]
   \                     ??HAL_TIM_PWM_Stop_DMA_0:
   \   0000000A   0x07 0x1B          DC8      0x7,0x1B,0x1B,0x1B
   \              0x1B 0x1B    
   \   0000000E   0x0C 0x1B          DC8      0xC,0x1B,0x1B,0x1B
   \              0x1B 0x1B    
   \   00000012   0x11 0x1B          DC8      0x11,0x1B,0x1B,0x1B
   \              0x1B 0x1B    
   \   00000016   0x16 0x00          DC8      0x16,0x0
   1415            {
   1416              case TIM_CHANNEL_1:
   1417              {       
   1418                /* Disable the TIM Capture/Compare 1 DMA request */
   1419                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
   \                     ??HAL_TIM_PWM_Stop_DMA_2: (+1)
   \   00000018   0x6802             LDR      R2,[R0, #+0]
   \   0000001A   0x68D3             LDR      R3,[R2, #+12]
   \   0000001C   0xF423 0x7300      BIC      R3,R3,#0x200
   \   00000020   0xE00D             B.N      ??HAL_TIM_PWM_Stop_DMA_3
   1420              }
   1421              break;
   1422              
   1423              case TIM_CHANNEL_2:
   1424              {
   1425                /* Disable the TIM Capture/Compare 2 DMA request */
   1426                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
   \                     ??HAL_TIM_PWM_Stop_DMA_4: (+1)
   \   00000022   0x6802             LDR      R2,[R0, #+0]
   \   00000024   0x68D3             LDR      R3,[R2, #+12]
   \   00000026   0xF423 0x6380      BIC      R3,R3,#0x400
   \   0000002A   0xE008             B.N      ??HAL_TIM_PWM_Stop_DMA_3
   1427              }
   1428              break;
   1429              
   1430              case TIM_CHANNEL_3:
   1431              {
   1432                /* Disable the TIM Capture/Compare 3 DMA request */
   1433                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);
   \                     ??HAL_TIM_PWM_Stop_DMA_5: (+1)
   \   0000002C   0x6802             LDR      R2,[R0, #+0]
   \   0000002E   0x68D3             LDR      R3,[R2, #+12]
   \   00000030   0xF423 0x6300      BIC      R3,R3,#0x800
   \   00000034   0xE003             B.N      ??HAL_TIM_PWM_Stop_DMA_3
   1434              }
   1435              break;
   1436              
   1437              case TIM_CHANNEL_4:
   1438              {
   1439                /* Disable the TIM Capture/Compare 4 interrupt */
   1440                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC4);
   \                     ??HAL_TIM_PWM_Stop_DMA_6: (+1)
   \   00000036   0x6802             LDR      R2,[R0, #+0]
   \   00000038   0x68D3             LDR      R3,[R2, #+12]
   \   0000003A   0xF423 0x5380      BIC      R3,R3,#0x1000
   \                     ??HAL_TIM_PWM_Stop_DMA_3: (+1)
   \   0000003E   0x60D3             STR      R3,[R2, #+12]
   1441              }
   1442              break;
   1443              
   1444              default:
   1445              break;
   1446            } 
   1447            
   1448            /* Disable the Capture compare channel */
   1449            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
   \                     ??HAL_TIM_PWM_Stop_DMA_1: (+1)
   \   00000040   0x6802             LDR      R2,[R0, #+0]
   \   00000042   0x2401             MOVS     R4,#+1
   \   00000044   0xFA04 0xF101      LSL      R1,R4,R1
   \   00000048   0x6A13             LDR      R3,[R2, #+32]
   \   0000004A   0xEA23 0x0101      BIC      R1,R3,R1
   \   0000004E   0x6211             STR      R1,[R2, #+32]
   \   00000050   0x6A11             LDR      R1,[R2, #+32]
   \   00000052   0x6211             STR      R1,[R2, #+32]
   1450            
   1451            if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
   \   00000054   0x6801             LDR      R1,[R0, #+0]
   \   00000056   0x....             LDR.N    R2,??DataTable15  ;; 0x40010000
   \   00000058   0x4291             CMP      R1,R2
   \   0000005A   0xBF1C             ITT      NE 
   \   0000005C   0x....             LDRNE.N  R2,??DataTable16  ;; 0x40010400
   \   0000005E   0x4291             CMPNE    R1,R2
   \   00000060   0xD10D             BNE.N    ??HAL_TIM_PWM_Stop_DMA_7
   1452            {
   1453              /* Disable the Main Output */
   1454              __HAL_TIM_MOE_DISABLE(htim);
   \   00000062   0x6A0A             LDR      R2,[R1, #+32]
   \   00000064   0xF241 0x1311      MOVW     R3,#+4369
   \   00000068   0x421A             TST      R2,R3
   \   0000006A   0xBF02             ITTT     EQ 
   \   0000006C   0x6A0A             LDREQ    R2,[R1, #+32]
   \   0000006E   0xF240 0x4344      MOVWEQ   R3,#+1092
   \   00000072   0x421A             TSTEQ    R2,R3
   \   00000074   0xD103             BNE.N    ??HAL_TIM_PWM_Stop_DMA_7
   \   00000076   0x6C4A             LDR      R2,[R1, #+68]
   \   00000078   0xF422 0x4200      BIC      R2,R2,#0x8000
   \   0000007C   0x644A             STR      R2,[R1, #+68]
   1455            }
   1456            
   1457            /* Disable the Peripheral */
   1458            __HAL_TIM_DISABLE(htim);
   \                     ??HAL_TIM_PWM_Stop_DMA_7: (+1)
   \   0000007E   0x6801             LDR      R1,[R0, #+0]
   \   00000080   0xF241 0x1311      MOVW     R3,#+4369
   \   00000084   0x6A0A             LDR      R2,[R1, #+32]
   \   00000086   0x421A             TST      R2,R3
   \   00000088   0xBF02             ITTT     EQ 
   \   0000008A   0x6A0A             LDREQ    R2,[R1, #+32]
   \   0000008C   0xF240 0x4344      MOVWEQ   R3,#+1092
   \   00000090   0x421A             TSTEQ    R2,R3
   \   00000092   0xD103             BNE.N    ??HAL_TIM_PWM_Stop_DMA_8
   \   00000094   0x680A             LDR      R2,[R1, #+0]
   \   00000096   0x0852             LSRS     R2,R2,#+1
   \   00000098   0x0052             LSLS     R2,R2,#+1
   \   0000009A   0x600A             STR      R2,[R1, #+0]
   1459            
   1460            /* Change the htim state */
   1461            htim->State = HAL_TIM_STATE_READY;
   \                     ??HAL_TIM_PWM_Stop_DMA_8: (+1)
   \   0000009C   0xF880 0x4039      STRB     R4,[R0, #+57]
   1462            
   1463            /* Return function status */
   1464            return HAL_OK;
   \   000000A0   0x2000             MOVS     R0,#+0
   \   000000A2   0xBC10             POP      {R4}
   \   000000A4   0x4770             BX       LR               ;; return
   1465          }
   1466          
   1467          /**
   1468            * @}
   1469            */
   1470          
   1471          /** @defgroup TIM_Exported_Functions_Group4 Time Input Capture functions 
   1472           *  @brief    Time Input Capture functions 
   1473           *
   1474          @verbatim    
   1475            ==============================================================================
   1476                        ##### Time Input Capture functions #####
   1477            ==============================================================================
   1478           [..]  
   1479             This section provides functions allowing to:
   1480             (+) Initialize and configure the TIM Input Capture. 
   1481             (+) De-initialize the TIM Input Capture.
   1482             (+) Start the Time Input Capture.
   1483             (+) Stop the Time Input Capture.
   1484             (+) Start the Time Input Capture and enable interrupt.
   1485             (+) Stop the Time Input Capture and disable interrupt.
   1486             (+) Start the Time Input Capture and enable DMA transfer.
   1487             (+) Stop the Time Input Capture and disable DMA transfer.
   1488           
   1489          @endverbatim
   1490            * @{
   1491            */
   1492          /**
   1493            * @brief  Initializes the TIM Input Capture Time base according to the specified
   1494            *         parameters in the TIM_HandleTypeDef and create the associated handle.
   1495            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   1496            *                the configuration information for TIM module.
   1497            * @retval HAL status
   1498            */

   \                                 In section .text, align 2, keep-with-next
   1499          HAL_StatusTypeDef HAL_TIM_IC_Init(TIM_HandleTypeDef *htim)
   1500          {
   \                     HAL_TIM_IC_Init: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0xB081             SUB      SP,SP,#+4
   1501            /* Check the TIM handle allocation */
   1502            if(htim == NULL)
   \   00000006   0xBF08             IT       EQ 
   \   00000008   0x2001             MOVEQ    R0,#+1
   1503            {
   1504              return HAL_ERROR;
   \   0000000A   0xD05F             BEQ.N    ??HAL_TIM_IC_Init_0
   1505            }
   1506          
   1507            /* Check the parameters */
   1508            assert_param(IS_TIM_INSTANCE(htim->Instance));
   1509            assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
   1510            assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision)); 
   1511          
   1512            if(htim->State == HAL_TIM_STATE_RESET)
   \   0000000C   0xF894 0x0039      LDRB     R0,[R4, #+57]
   \   00000010   0xB920             CBNZ.N   R0,??HAL_TIM_IC_Init_1
   1513            { 
   1514              /* Allocate lock resource and initialize it */
   1515              htim->Lock = HAL_UNLOCKED;   
   \   00000012   0xF884 0x0038      STRB     R0,[R4, #+56]
   1516              /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
   1517              HAL_TIM_IC_MspInit(htim);
   \   00000016   0x4620             MOV      R0,R4
   \   00000018   0x.... 0x....      BL       HAL_TIM_IC_MspInit
   1518            }
   1519            
   1520            /* Set the TIM state */
   1521            htim->State= HAL_TIM_STATE_BUSY;   
   \                     ??HAL_TIM_IC_Init_1: (+1)
   \   0000001C   0x2002             MOVS     R0,#+2
   1522            
   1523            /* Init the base time for the input capture */  
   1524            TIM_Base_SetConfig(htim->Instance, &htim->Init); 
   \   0000001E   0x.... 0x....      LDR.W    R2,??DataTable24  ;; 0x40010000
   \   00000022   0xF884 0x0039      STRB     R0,[R4, #+57]
   \   00000026   0x1D20             ADDS     R0,R4,#+4
   \   00000028   0x6821             LDR      R1,[R4, #+0]
   \   0000002A   0x4291             CMP      R1,R2
   \   0000002C   0x680B             LDR      R3,[R1, #+0]
   \   0000002E   0xBF18             IT       NE 
   \   00000030   0xF1B1 0x4F80      CMPNE    R1,#+1073741824
   \   00000034   0xD00E             BEQ.N    ??HAL_TIM_IC_Init_2
   \   00000036   0x.... 0x....      LDR.W    R5,??DataTable24_1  ;; 0x40000400
   \   0000003A   0x42A9             CMP      R1,R5
   \   0000003C   0xBF1C             ITT      NE 
   \   0000003E   0x.... 0x....      LDRNE.W  R5,??DataTable24_2  ;; 0x40000800
   \   00000042   0x42A9             CMPNE    R1,R5
   \   00000044   0xD006             BEQ.N    ??HAL_TIM_IC_Init_2
   \   00000046   0x.... 0x....      LDR.W    R5,??DataTable24_3  ;; 0x40000c00
   \   0000004A   0x42A9             CMP      R1,R5
   \   0000004C   0xBF1C             ITT      NE 
   \   0000004E   0x....             LDRNE.N  R5,??DataTable16  ;; 0x40010400
   \   00000050   0x42A9             CMPNE    R1,R5
   \   00000052   0xD113             BNE.N    ??HAL_TIM_IC_Init_3
   \                     ??HAL_TIM_IC_Init_2: (+1)
   \   00000054   0x6845             LDR      R5,[R0, #+4]
   \   00000056   0xF023 0x0370      BIC      R3,R3,#0x70
   \   0000005A   0x432B             ORRS     R3,R5,R3
   \   0000005C   0x4291             CMP      R1,R2
   \   0000005E   0xBF18             IT       NE 
   \   00000060   0xF1B1 0x4F80      CMPNE    R1,#+1073741824
   \   00000064   0xD01E             BEQ.N    ??HAL_TIM_IC_Init_4
   \   00000066   0x.... 0x....      LDR.W    R5,??DataTable24_1  ;; 0x40000400
   \   0000006A   0x42A9             CMP      R1,R5
   \   0000006C   0xBF1F             ITTTT    NE 
   \   0000006E   0x.... 0x....      LDRNE.W  R5,??DataTable24_2  ;; 0x40000800
   \   00000072   0x42A9             CMPNE    R1,R5
   \   00000074   0x.... 0x....      LDRNE.W  R5,??DataTable24_3  ;; 0x40000c00
   \   00000078   0x42A9             CMPNE    R1,R5
   \   0000007A   0xD013             BEQ.N    ??HAL_TIM_IC_Init_4
   \                     ??HAL_TIM_IC_Init_3: (+1)
   \   0000007C   0x....             LDR.N    R5,??DataTable16  ;; 0x40010400
   \   0000007E   0x42A9             CMP      R1,R5
   \   00000080   0xBF1C             ITT      NE 
   \   00000082   0x....             LDRNE.N  R5,??DataTable16_1  ;; 0x40014000
   \   00000084   0x42A9             CMPNE    R1,R5
   \   00000086   0xD00D             BEQ.N    ??HAL_TIM_IC_Init_4
   \   00000088   0x....             LDR.N    R5,??DataTable16_2  ;; 0x40014400
   \   0000008A   0x42A9             CMP      R1,R5
   \   0000008C   0xBF1C             ITT      NE 
   \   0000008E   0x....             LDRNE.N  R5,??DataTable16_3  ;; 0x40014800
   \   00000090   0x42A9             CMPNE    R1,R5
   \   00000092   0xD007             BEQ.N    ??HAL_TIM_IC_Init_4
   \   00000094   0x....             LDR.N    R5,??DataTable16_4  ;; 0x40001800
   \   00000096   0x42A9             CMP      R1,R5
   \   00000098   0xBF1F             ITTTT    NE 
   \   0000009A   0x....             LDRNE.N  R5,??DataTable16_5  ;; 0x40001c00
   \   0000009C   0x42A9             CMPNE    R1,R5
   \   0000009E   0x....             LDRNE.N  R5,??DataTable16_6  ;; 0x40002000
   \   000000A0   0x42A9             CMPNE    R1,R5
   \   000000A2   0xD103             BNE.N    ??HAL_TIM_IC_Init_5
   \                     ??HAL_TIM_IC_Init_4: (+1)
   \   000000A4   0x68C5             LDR      R5,[R0, #+12]
   \   000000A6   0xF423 0x7340      BIC      R3,R3,#0x300
   \   000000AA   0x432B             ORRS     R3,R5,R3
   \                     ??HAL_TIM_IC_Init_5: (+1)
   \   000000AC   0x600B             STR      R3,[R1, #+0]
   \   000000AE   0x6883             LDR      R3,[R0, #+8]
   \   000000B0   0x4291             CMP      R1,R2
   \   000000B2   0x62CB             STR      R3,[R1, #+44]
   \   000000B4   0x6803             LDR      R3,[R0, #+0]
   \   000000B6   0x628B             STR      R3,[R1, #+40]
   \   000000B8   0xBF19             ITTEE    NE 
   \   000000BA   0x....             LDRNE.N  R2,??DataTable16  ;; 0x40010400
   \   000000BC   0x4291             CMPNE    R1,R2
   \   000000BE   0x6900             LDREQ    R0,[R0, #+16]
   \   000000C0   0x6308             STREQ    R0,[R1, #+48]
   \   000000C2   0x2001             MOVS     R0,#+1
   \   000000C4   0x6148             STR      R0,[R1, #+20]
   1525             
   1526            /* Initialize the TIM state*/
   1527            htim->State= HAL_TIM_STATE_READY;
   \   000000C6   0xF884 0x0039      STRB     R0,[R4, #+57]
   1528            
   1529            return HAL_OK;
   \   000000CA   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_IC_Init_0: (+1)
   \   000000CC   0xB001             ADD      SP,SP,#+4
   \   000000CE   0xBD30             POP      {R4,R5,PC}       ;; return
   1530          }
   1531          
   1532          /**
   1533            * @brief  DeInitializes the TIM peripheral 
   1534            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   1535            *                the configuration information for TIM module.
   1536            * @retval HAL status
   1537            */

   \                                 In section .text, align 2, keep-with-next
   1538          HAL_StatusTypeDef HAL_TIM_IC_DeInit(TIM_HandleTypeDef *htim)
   1539          {
   \                     HAL_TIM_IC_DeInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   1540            /* Check the parameters */
   1541            assert_param(IS_TIM_INSTANCE(htim->Instance));
   1542          
   1543            htim->State = HAL_TIM_STATE_BUSY;
   \   00000004   0x2002             MOVS     R0,#+2
   \   00000006   0xF884 0x0039      STRB     R0,[R4, #+57]
   1544            
   1545            /* Disable the TIM Peripheral Clock */
   1546            __HAL_TIM_DISABLE(htim);
   \   0000000A   0xF241 0x1211      MOVW     R2,#+4369
   \   0000000E   0x6820             LDR      R0,[R4, #+0]
   \   00000010   0x6A01             LDR      R1,[R0, #+32]
   \   00000012   0x4211             TST      R1,R2
   \   00000014   0xBF02             ITTT     EQ 
   \   00000016   0x6A01             LDREQ    R1,[R0, #+32]
   \   00000018   0xF240 0x4244      MOVWEQ   R2,#+1092
   \   0000001C   0x4211             TSTEQ    R1,R2
   \   0000001E   0xD103             BNE.N    ??HAL_TIM_IC_DeInit_0
   \   00000020   0x6801             LDR      R1,[R0, #+0]
   \   00000022   0x0849             LSRS     R1,R1,#+1
   \   00000024   0x0049             LSLS     R1,R1,#+1
   \   00000026   0x6001             STR      R1,[R0, #+0]
   1547              
   1548            /* DeInit the low level hardware: GPIO, CLOCK, NVIC and DMA */
   1549            HAL_TIM_IC_MspDeInit(htim);
   \                     ??HAL_TIM_IC_DeInit_0: (+1)
   \   00000028   0x4620             MOV      R0,R4
   \   0000002A   0x.... 0x....      BL       HAL_TIM_IC_MspDeInit
   1550              
   1551            /* Change TIM state */  
   1552            htim->State = HAL_TIM_STATE_RESET;
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0xF884 0x0039      STRB     R0,[R4, #+57]
   1553          
   1554            /* Release Lock */
   1555            __HAL_UNLOCK(htim);
   \   00000034   0xF884 0x0038      STRB     R0,[R4, #+56]
   1556          
   1557            return HAL_OK;
   \   00000038   0xBD10             POP      {R4,PC}          ;; return
   1558          }
   1559          
   1560          /**
   1561            * @brief  Initializes the TIM INput Capture MSP.
   1562            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   1563            *                the configuration information for TIM module.
   1564            * @retval None
   1565            */

   \                                 In section .text, align 2, keep-with-next
   1566          __weak void HAL_TIM_IC_MspInit(TIM_HandleTypeDef *htim)
   1567          {
   1568            /* NOTE : This function Should not be modified, when the callback is needed,
   1569                      the HAL_TIM_IC_MspInit could be implemented in the user file
   1570             */
   1571          }
   \                     HAL_TIM_IC_MspInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1572          
   1573          /**
   1574            * @brief  DeInitializes TIM Input Capture MSP.
   1575            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   1576            *                the configuration information for TIM module.
   1577            * @retval None
   1578            */

   \                                 In section .text, align 2, keep-with-next
   1579          __weak void HAL_TIM_IC_MspDeInit(TIM_HandleTypeDef *htim)
   1580          {
   1581            /* NOTE : This function Should not be modified, when the callback is needed,
   1582                      the HAL_TIM_IC_MspDeInit could be implemented in the user file
   1583             */
   1584          }
   \                     HAL_TIM_IC_MspDeInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1585          
   1586          /**
   1587            * @brief  Starts the TIM Input Capture measurement.
   1588            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   1589            *                the configuration information for TIM module.
   1590            * @param  Channel: TIM Channels to be enabled.
   1591            *          This parameter can be one of the following values:
   1592            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1593            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1594            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1595            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1596            * @retval HAL status
   1597            */

   \                                 In section .text, align 2, keep-with-next
   1598          HAL_StatusTypeDef HAL_TIM_IC_Start (TIM_HandleTypeDef *htim, uint32_t Channel)
   1599          {
   1600            /* Check the parameters */
   1601            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1602            
   1603            /* Enable the Input Capture channel */
   1604            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
   \                     HAL_TIM_IC_Start: (+1)
   \   00000000   0x6800             LDR      R0,[R0, #+0]
   \   00000002   0x2201             MOVS     R2,#+1
   \   00000004   0xFA02 0xF101      LSL      R1,R2,R1
   \   00000008   0x6A02             LDR      R2,[R0, #+32]
   \   0000000A   0x438A             BICS     R2,R2,R1
   \   0000000C   0x6202             STR      R2,[R0, #+32]
   \   0000000E   0x6A02             LDR      R2,[R0, #+32]
   \   00000010   0x4311             ORRS     R1,R1,R2
   \   00000012   0x6201             STR      R1,[R0, #+32]
   1605              
   1606            /* Enable the Peripheral */
   1607            __HAL_TIM_ENABLE(htim);  
   \   00000014   0x6801             LDR      R1,[R0, #+0]
   \   00000016   0xF041 0x0101      ORR      R1,R1,#0x1
   \   0000001A   0x6001             STR      R1,[R0, #+0]
   1608          
   1609            /* Return function status */
   1610            return HAL_OK;  
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0x4770             BX       LR               ;; return
   1611          } 
   1612          
   1613          /**
   1614            * @brief  Stops the TIM Input Capture measurement.
   1615            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   1616            *                the configuration information for TIM module.
   1617            * @param  Channel: TIM Channels to be disabled.
   1618            *          This parameter can be one of the following values:
   1619            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1620            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1621            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1622            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1623            * @retval HAL status
   1624            */

   \                                 In section .text, align 2, keep-with-next
   1625          HAL_StatusTypeDef HAL_TIM_IC_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
   1626          { 
   1627            /* Check the parameters */
   1628            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1629            
   1630            /* Disable the Input Capture channel */
   1631            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
   \                     HAL_TIM_IC_Stop: (+1)
   \   00000000   0x6800             LDR      R0,[R0, #+0]
   \   00000002   0x2301             MOVS     R3,#+1
   \   00000004   0xFA03 0xF101      LSL      R1,R3,R1
   \   00000008   0x6A02             LDR      R2,[R0, #+32]
   \   0000000A   0xEA22 0x0101      BIC      R1,R2,R1
   1632            
   1633            /* Disable the Peripheral */
   1634            __HAL_TIM_DISABLE(htim); 
   \   0000000E   0xF241 0x1211      MOVW     R2,#+4369
   \   00000012   0x6201             STR      R1,[R0, #+32]
   \   00000014   0x6A01             LDR      R1,[R0, #+32]
   \   00000016   0x6201             STR      R1,[R0, #+32]
   \   00000018   0x6A01             LDR      R1,[R0, #+32]
   \   0000001A   0x4211             TST      R1,R2
   \   0000001C   0xBF02             ITTT     EQ 
   \   0000001E   0x6A01             LDREQ    R1,[R0, #+32]
   \   00000020   0xF240 0x4244      MOVWEQ   R2,#+1092
   \   00000024   0x4211             TSTEQ    R1,R2
   \   00000026   0xD103             BNE.N    ??HAL_TIM_IC_Stop_0
   \   00000028   0x6801             LDR      R1,[R0, #+0]
   \   0000002A   0x0849             LSRS     R1,R1,#+1
   \   0000002C   0x0049             LSLS     R1,R1,#+1
   \   0000002E   0x6001             STR      R1,[R0, #+0]
   1635            
   1636            /* Return function status */
   1637            return HAL_OK;
   \                     ??HAL_TIM_IC_Stop_0: (+1)
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0x4770             BX       LR               ;; return
   1638          }
   1639          
   1640          /**
   1641            * @brief  Starts the TIM Input Capture measurement in interrupt mode.
   1642            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   1643            *                the configuration information for TIM module.
   1644            * @param  Channel: TIM Channels to be enabled.
   1645            *          This parameter can be one of the following values:
   1646            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1647            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1648            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1649            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1650            * @retval HAL status
   1651            */

   \                                 In section .text, align 4, keep-with-next
   1652          HAL_StatusTypeDef HAL_TIM_IC_Start_IT (TIM_HandleTypeDef *htim, uint32_t Channel)
   1653          {
   1654            /* Check the parameters */
   1655            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1656            
   1657            switch (Channel)
   \                     HAL_TIM_IC_Start_IT: (+1)
   \   00000000   0x290C             CMP      R1,#+12
   \   00000002   0xD81C             BHI.N    ??HAL_TIM_IC_Start_IT_1
   \   00000004   0xE8DF 0xF001      TBB      [PC, R1]
   \                     ??HAL_TIM_IC_Start_IT_0:
   \   00000008   0x07 0x1B          DC8      0x7,0x1B,0x1B,0x1B
   \              0x1B 0x1B    
   \   0000000C   0x0C 0x1B          DC8      0xC,0x1B,0x1B,0x1B
   \              0x1B 0x1B    
   \   00000010   0x11 0x1B          DC8      0x11,0x1B,0x1B,0x1B
   \              0x1B 0x1B    
   \   00000014   0x16 0x00          DC8      0x16,0x0
   1658            {
   1659              case TIM_CHANNEL_1:
   1660              {       
   1661                /* Enable the TIM Capture/Compare 1 interrupt */
   1662                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
   \                     ??HAL_TIM_IC_Start_IT_2: (+1)
   \   00000016   0x6802             LDR      R2,[R0, #+0]
   \   00000018   0x68D3             LDR      R3,[R2, #+12]
   \   0000001A   0xF043 0x0302      ORR      R3,R3,#0x2
   \   0000001E   0xE00D             B.N      ??HAL_TIM_IC_Start_IT_3
   1663              }
   1664              break;
   1665              
   1666              case TIM_CHANNEL_2:
   1667              {
   1668                /* Enable the TIM Capture/Compare 2 interrupt */
   1669                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
   \                     ??HAL_TIM_IC_Start_IT_4: (+1)
   \   00000020   0x6802             LDR      R2,[R0, #+0]
   \   00000022   0x68D3             LDR      R3,[R2, #+12]
   \   00000024   0xF043 0x0304      ORR      R3,R3,#0x4
   \   00000028   0xE008             B.N      ??HAL_TIM_IC_Start_IT_3
   1670              }
   1671              break;
   1672              
   1673              case TIM_CHANNEL_3:
   1674              {
   1675                /* Enable the TIM Capture/Compare 3 interrupt */
   1676                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);
   \                     ??HAL_TIM_IC_Start_IT_5: (+1)
   \   0000002A   0x6802             LDR      R2,[R0, #+0]
   \   0000002C   0x68D3             LDR      R3,[R2, #+12]
   \   0000002E   0xF043 0x0308      ORR      R3,R3,#0x8
   \   00000032   0xE003             B.N      ??HAL_TIM_IC_Start_IT_3
   1677              }
   1678              break;
   1679              
   1680              case TIM_CHANNEL_4:
   1681              {
   1682                /* Enable the TIM Capture/Compare 4 interrupt */
   1683                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC4);
   \                     ??HAL_TIM_IC_Start_IT_6: (+1)
   \   00000034   0x6802             LDR      R2,[R0, #+0]
   \   00000036   0x68D3             LDR      R3,[R2, #+12]
   \   00000038   0xF043 0x0310      ORR      R3,R3,#0x10
   \                     ??HAL_TIM_IC_Start_IT_3: (+1)
   \   0000003C   0x60D3             STR      R3,[R2, #+12]
   1684              }
   1685              break;
   1686              
   1687              default:
   1688              break;
   1689            }  
   1690            /* Enable the Input Capture channel */
   1691            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
   \                     ??HAL_TIM_IC_Start_IT_1: (+1)
   \   0000003E   0x6802             LDR      R2,[R0, #+0]
   \   00000040   0x2001             MOVS     R0,#+1
   \   00000042   0x4088             LSLS     R0,R0,R1
   \   00000044   0x6A11             LDR      R1,[R2, #+32]
   \   00000046   0x4381             BICS     R1,R1,R0
   \   00000048   0x6211             STR      R1,[R2, #+32]
   \   0000004A   0x6A11             LDR      R1,[R2, #+32]
   \   0000004C   0x4308             ORRS     R0,R0,R1
   \   0000004E   0x6210             STR      R0,[R2, #+32]
   1692              
   1693            /* Enable the Peripheral */
   1694            __HAL_TIM_ENABLE(htim);  
   \   00000050   0x6810             LDR      R0,[R2, #+0]
   \   00000052   0xF040 0x0001      ORR      R0,R0,#0x1
   \   00000056   0x6010             STR      R0,[R2, #+0]
   1695          
   1696            /* Return function status */
   1697            return HAL_OK;  
   \   00000058   0x2000             MOVS     R0,#+0
   \   0000005A   0x4770             BX       LR               ;; return
   1698          } 
   1699          
   1700          /**
   1701            * @brief  Stops the TIM Input Capture measurement in interrupt mode.
   1702            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   1703            *                the configuration information for TIM module.
   1704            * @param  Channel: TIM Channels to be disabled.
   1705            *          This parameter can be one of the following values:
   1706            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1707            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1708            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1709            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1710            * @retval HAL status
   1711            */

   \                                 In section .text, align 4, keep-with-next
   1712          HAL_StatusTypeDef HAL_TIM_IC_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
   1713          {
   1714            /* Check the parameters */
   1715            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1716            
   1717            switch (Channel)
   \                     HAL_TIM_IC_Stop_IT: (+1)
   \   00000000   0x290C             CMP      R1,#+12
   \   00000002   0xD81C             BHI.N    ??HAL_TIM_IC_Stop_IT_1
   \   00000004   0xE8DF 0xF001      TBB      [PC, R1]
   \                     ??HAL_TIM_IC_Stop_IT_0:
   \   00000008   0x07 0x1B          DC8      0x7,0x1B,0x1B,0x1B
   \              0x1B 0x1B    
   \   0000000C   0x0C 0x1B          DC8      0xC,0x1B,0x1B,0x1B
   \              0x1B 0x1B    
   \   00000010   0x11 0x1B          DC8      0x11,0x1B,0x1B,0x1B
   \              0x1B 0x1B    
   \   00000014   0x16 0x00          DC8      0x16,0x0
   1718            {
   1719              case TIM_CHANNEL_1:
   1720              {       
   1721                /* Disable the TIM Capture/Compare 1 interrupt */
   1722                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
   \                     ??HAL_TIM_IC_Stop_IT_2: (+1)
   \   00000016   0x6802             LDR      R2,[R0, #+0]
   \   00000018   0x68D3             LDR      R3,[R2, #+12]
   \   0000001A   0xF023 0x0302      BIC      R3,R3,#0x2
   \   0000001E   0xE00D             B.N      ??HAL_TIM_IC_Stop_IT_3
   1723              }
   1724              break;
   1725              
   1726              case TIM_CHANNEL_2:
   1727              {
   1728                /* Disable the TIM Capture/Compare 2 interrupt */
   1729                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
   \                     ??HAL_TIM_IC_Stop_IT_4: (+1)
   \   00000020   0x6802             LDR      R2,[R0, #+0]
   \   00000022   0x68D3             LDR      R3,[R2, #+12]
   \   00000024   0xF023 0x0304      BIC      R3,R3,#0x4
   \   00000028   0xE008             B.N      ??HAL_TIM_IC_Stop_IT_3
   1730              }
   1731              break;
   1732              
   1733              case TIM_CHANNEL_3:
   1734              {
   1735                /* Disable the TIM Capture/Compare 3 interrupt */
   1736                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);
   \                     ??HAL_TIM_IC_Stop_IT_5: (+1)
   \   0000002A   0x6802             LDR      R2,[R0, #+0]
   \   0000002C   0x68D3             LDR      R3,[R2, #+12]
   \   0000002E   0xF023 0x0308      BIC      R3,R3,#0x8
   \   00000032   0xE003             B.N      ??HAL_TIM_IC_Stop_IT_3
   1737              }
   1738              break;
   1739              
   1740              case TIM_CHANNEL_4:
   1741              {
   1742                /* Disable the TIM Capture/Compare 4 interrupt */
   1743                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC4);
   \                     ??HAL_TIM_IC_Stop_IT_6: (+1)
   \   00000034   0x6802             LDR      R2,[R0, #+0]
   \   00000036   0x68D3             LDR      R3,[R2, #+12]
   \   00000038   0xF023 0x0310      BIC      R3,R3,#0x10
   \                     ??HAL_TIM_IC_Stop_IT_3: (+1)
   \   0000003C   0x60D3             STR      R3,[R2, #+12]
   1744              }
   1745              break;
   1746              
   1747              default:
   1748              break; 
   1749            } 
   1750            
   1751            /* Disable the Input Capture channel */
   1752            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE); 
   \                     ??HAL_TIM_IC_Stop_IT_1: (+1)
   \   0000003E   0x6802             LDR      R2,[R0, #+0]
   \   00000040   0x2301             MOVS     R3,#+1
   \   00000042   0xFA03 0xF101      LSL      R1,R3,R1
   \   00000046   0x6A10             LDR      R0,[R2, #+32]
   \   00000048   0x4388             BICS     R0,R0,R1
   1753            
   1754            /* Disable the Peripheral */
   1755            __HAL_TIM_DISABLE(htim); 
   \   0000004A   0xF241 0x1111      MOVW     R1,#+4369
   \   0000004E   0x6210             STR      R0,[R2, #+32]
   \   00000050   0x6A10             LDR      R0,[R2, #+32]
   \   00000052   0x6210             STR      R0,[R2, #+32]
   \   00000054   0x6A10             LDR      R0,[R2, #+32]
   \   00000056   0x4208             TST      R0,R1
   \   00000058   0xBF02             ITTT     EQ 
   \   0000005A   0x6A10             LDREQ    R0,[R2, #+32]
   \   0000005C   0xF240 0x4144      MOVWEQ   R1,#+1092
   \   00000060   0x4208             TSTEQ    R0,R1
   \   00000062   0xD103             BNE.N    ??HAL_TIM_IC_Stop_IT_7
   \   00000064   0x6810             LDR      R0,[R2, #+0]
   \   00000066   0x0840             LSRS     R0,R0,#+1
   \   00000068   0x0040             LSLS     R0,R0,#+1
   \   0000006A   0x6010             STR      R0,[R2, #+0]
   1756            
   1757            /* Return function status */
   1758            return HAL_OK;
   \                     ??HAL_TIM_IC_Stop_IT_7: (+1)
   \   0000006C   0x2000             MOVS     R0,#+0
   \   0000006E   0x4770             BX       LR               ;; return
   1759          }
   1760          
   1761          /**
   1762            * @brief  Starts the TIM Input Capture measurement on in DMA mode.
   1763            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   1764            *                the configuration information for TIM module.
   1765            * @param  Channel: TIM Channels to be enabled.
   1766            *          This parameter can be one of the following values:
   1767            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1768            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1769            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1770            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1771            * @param  pData: The destination Buffer address.
   1772            * @param  Length: The length of data to be transferred from TIM peripheral to memory.
   1773            * @retval HAL status
   1774            */

   \                                 In section .text, align 4, keep-with-next
   1775          HAL_StatusTypeDef HAL_TIM_IC_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData, uint16_t Length)
   1776          {
   \                     HAL_TIM_IC_Start_DMA: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0xB081             SUB      SP,SP,#+4
   \   00000006   0x460D             MOV      R5,R1
   1777            /* Check the parameters */
   1778            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1779            assert_param(IS_TIM_DMA_CC_INSTANCE(htim->Instance));
   1780            
   1781            if((htim->State == HAL_TIM_STATE_BUSY))
   \   00000008   0xF894 0x0039      LDRB     R0,[R4, #+57]
   \   0000000C   0x2802             CMP      R0,#+2
   \   0000000E   0xD06B             BEQ.N    ??HAL_TIM_IC_Start_DMA_1
   1782            {
   1783               return HAL_BUSY;
   1784            }
   1785            else if((htim->State == HAL_TIM_STATE_READY))
   \   00000010   0xF894 0x0039      LDRB     R0,[R4, #+57]
   \   00000014   0x2801             CMP      R0,#+1
   \   00000016   0xD105             BNE.N    ??HAL_TIM_IC_Start_DMA_2
   1786            {
   1787              if((pData == 0 ) && (Length > 0)) 
   \   00000018   0xB90A             CBNZ.N   R2,??HAL_TIM_IC_Start_DMA_3
   \   0000001A   0x2B00             CMP      R3,#+0
   \   0000001C   0xD164             BNE.N    ??HAL_TIM_IC_Start_DMA_1
   1788              {
   1789                return HAL_ERROR;                                    
   1790              }
   1791              else
   1792              {
   1793                htim->State = HAL_TIM_STATE_BUSY;
   \                     ??HAL_TIM_IC_Start_DMA_3: (+1)
   \   0000001E   0x2002             MOVS     R0,#+2
   \   00000020   0xF884 0x0039      STRB     R0,[R4, #+57]
   1794              }
   1795            }  
   1796             
   1797            switch (Channel)
   \                     ??HAL_TIM_IC_Start_DMA_2: (+1)
   \   00000024   0x2D0C             CMP      R5,#+12
   \   00000026   0xD850             BHI.N    ??HAL_TIM_IC_Start_DMA_4
   \   00000028   0xE8DF 0xF005      TBB      [PC, R5]
   \                     ??HAL_TIM_IC_Start_DMA_0:
   \   0000002C   0x07 0x4F          DC8      0x7,0x4F,0x4F,0x4F
   \              0x4F 0x4F    
   \   00000030   0x19 0x4F          DC8      0x19,0x4F,0x4F,0x4F
   \              0x4F 0x4F    
   \   00000034   0x2B 0x4F          DC8      0x2B,0x4F,0x4F,0x4F
   \              0x4F 0x4F    
   \   00000038   0x3D 0x00          DC8      0x3D,0x0
   1798            {
   1799              case TIM_CHANNEL_1:
   1800              {
   1801                /* Set the DMA Period elapsed callback */
   1802                htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = HAL_TIM_DMACaptureCplt;
   \                     ??HAL_TIM_IC_Start_DMA_5: (+1)
   \   0000003A   0x6A21             LDR      R1,[R4, #+32]
   \   0000003C   0x.... 0x....      LDR.W    R0,??DataTable25
   \   00000040   0x63C8             STR      R0,[R1, #+60]
   1803               
   1804                /* Set the DMA error callback */
   1805                htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = HAL_TIM_DMAError ;
   \   00000042   0x6A21             LDR      R1,[R4, #+32]
   \   00000044   0x....             LDR.N    R0,??DataTable21_1
   \   00000046   0x6488             STR      R0,[R1, #+72]
   1806                
   1807                /* Enable the DMA Stream */
   1808                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->CCR1, (uint32_t)pData, Length); 
   \   00000048   0x6820             LDR      R0,[R4, #+0]
   \   0000004A   0xF100 0x0134      ADD      R1,R0,#+52
   \   0000004E   0x6A20             LDR      R0,[R4, #+32]
   \   00000050   0x.... 0x....      BL       HAL_DMA_Start_IT
   1809                
   1810                /* Enable the TIM Capture/Compare 1 DMA request */      
   1811                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
   \   00000054   0x6820             LDR      R0,[R4, #+0]
   \   00000056   0x68C1             LDR      R1,[R0, #+12]
   \   00000058   0xF441 0x7100      ORR      R1,R1,#0x200
   \   0000005C   0xE034             B.N      ??HAL_TIM_IC_Start_DMA_6
   1812              }
   1813              break;
   1814              
   1815              case TIM_CHANNEL_2:
   1816              {
   1817                /* Set the DMA Period elapsed callback */
   1818                htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = HAL_TIM_DMACaptureCplt;
   \                     ??HAL_TIM_IC_Start_DMA_7: (+1)
   \   0000005E   0x6A61             LDR      R1,[R4, #+36]
   \   00000060   0x.... 0x....      LDR.W    R0,??DataTable25
   \   00000064   0x63C8             STR      R0,[R1, #+60]
   1819               
   1820                /* Set the DMA error callback */
   1821                htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = HAL_TIM_DMAError ;
   \   00000066   0x6A61             LDR      R1,[R4, #+36]
   \   00000068   0x....             LDR.N    R0,??DataTable21_1
   \   0000006A   0x6488             STR      R0,[R1, #+72]
   1822                
   1823                /* Enable the DMA Stream */
   1824                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->CCR2, (uint32_t)pData, Length);
   \   0000006C   0x6820             LDR      R0,[R4, #+0]
   \   0000006E   0xF100 0x0138      ADD      R1,R0,#+56
   \   00000072   0x6A60             LDR      R0,[R4, #+36]
   \   00000074   0x.... 0x....      BL       HAL_DMA_Start_IT
   1825                
   1826                /* Enable the TIM Capture/Compare 2  DMA request */
   1827                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
   \   00000078   0x6820             LDR      R0,[R4, #+0]
   \   0000007A   0x68C1             LDR      R1,[R0, #+12]
   \   0000007C   0xF441 0x6180      ORR      R1,R1,#0x400
   \   00000080   0xE022             B.N      ??HAL_TIM_IC_Start_DMA_6
   1828              }
   1829              break;
   1830              
   1831              case TIM_CHANNEL_3:
   1832              {
   1833                /* Set the DMA Period elapsed callback */
   1834                htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = HAL_TIM_DMACaptureCplt;
   \                     ??HAL_TIM_IC_Start_DMA_8: (+1)
   \   00000082   0x6AA1             LDR      R1,[R4, #+40]
   \   00000084   0x.... 0x....      LDR.W    R0,??DataTable25
   \   00000088   0x63C8             STR      R0,[R1, #+60]
   1835               
   1836                /* Set the DMA error callback */
   1837                htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = HAL_TIM_DMAError ;
   \   0000008A   0x6AA1             LDR      R1,[R4, #+40]
   \   0000008C   0x....             LDR.N    R0,??DataTable21_1
   \   0000008E   0x6488             STR      R0,[R1, #+72]
   1838                
   1839                /* Enable the DMA Stream */
   1840                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)&htim->Instance->CCR3, (uint32_t)pData, Length);
   \   00000090   0x6820             LDR      R0,[R4, #+0]
   \   00000092   0xF100 0x013C      ADD      R1,R0,#+60
   \   00000096   0x6AA0             LDR      R0,[R4, #+40]
   \   00000098   0x.... 0x....      BL       HAL_DMA_Start_IT
   1841                
   1842                /* Enable the TIM Capture/Compare 3  DMA request */
   1843                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);
   \   0000009C   0x6820             LDR      R0,[R4, #+0]
   \   0000009E   0x68C1             LDR      R1,[R0, #+12]
   \   000000A0   0xF441 0x6100      ORR      R1,R1,#0x800
   \   000000A4   0xE010             B.N      ??HAL_TIM_IC_Start_DMA_6
   1844              }
   1845              break;
   1846              
   1847              case TIM_CHANNEL_4:
   1848              {
   1849                /* Set the DMA Period elapsed callback */
   1850                htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = HAL_TIM_DMACaptureCplt;
   \                     ??HAL_TIM_IC_Start_DMA_9: (+1)
   \   000000A6   0x6AE1             LDR      R1,[R4, #+44]
   \   000000A8   0x.... 0x....      LDR.W    R0,??DataTable25
   \   000000AC   0x63C8             STR      R0,[R1, #+60]
   1851               
   1852                /* Set the DMA error callback */
   1853                htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = HAL_TIM_DMAError ;
   \   000000AE   0x6AE1             LDR      R1,[R4, #+44]
   \   000000B0   0x....             LDR.N    R0,??DataTable21_1
   \   000000B2   0x6488             STR      R0,[R1, #+72]
   1854                
   1855                /* Enable the DMA Stream */
   1856                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)&htim->Instance->CCR4, (uint32_t)pData, Length);
   \   000000B4   0x6820             LDR      R0,[R4, #+0]
   \   000000B6   0xF100 0x0140      ADD      R1,R0,#+64
   \   000000BA   0x6AE0             LDR      R0,[R4, #+44]
   \   000000BC   0x.... 0x....      BL       HAL_DMA_Start_IT
   1857                
   1858                /* Enable the TIM Capture/Compare 4  DMA request */
   1859                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC4);
   \   000000C0   0x6820             LDR      R0,[R4, #+0]
   \   000000C2   0x68C1             LDR      R1,[R0, #+12]
   \   000000C4   0xF441 0x5180      ORR      R1,R1,#0x1000
   \                     ??HAL_TIM_IC_Start_DMA_6: (+1)
   \   000000C8   0x60C1             STR      R1,[R0, #+12]
   1860              }
   1861              break;
   1862              
   1863              default:
   1864              break;
   1865            }
   1866          
   1867            /* Enable the Input Capture channel */
   1868            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
   \                     ??HAL_TIM_IC_Start_DMA_4: (+1)
   \   000000CA   0x6820             LDR      R0,[R4, #+0]
   \   000000CC   0x2101             MOVS     R1,#+1
   \   000000CE   0x40A9             LSLS     R1,R1,R5
   \   000000D0   0x6A02             LDR      R2,[R0, #+32]
   \   000000D2   0x438A             BICS     R2,R2,R1
   \   000000D4   0x6202             STR      R2,[R0, #+32]
   \   000000D6   0x6A02             LDR      R2,[R0, #+32]
   \   000000D8   0x4311             ORRS     R1,R1,R2
   \   000000DA   0x6201             STR      R1,[R0, #+32]
   1869             
   1870            /* Enable the Peripheral */
   1871            __HAL_TIM_ENABLE(htim); 
   \   000000DC   0x6820             LDR      R0,[R4, #+0]
   \   000000DE   0x6801             LDR      R1,[R0, #+0]
   \   000000E0   0xF041 0x0101      ORR      R1,R1,#0x1
   \   000000E4   0x6001             STR      R1,[R0, #+0]
   1872            
   1873            /* Return function status */
   1874            return HAL_OK;
   \   000000E6   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_IC_Start_DMA_1: (+1)
   \   000000E8   0xB001             ADD      SP,SP,#+4
   \   000000EA   0xBD30             POP      {R4,R5,PC}       ;; return
   1875          }
   1876          
   1877          /**
   1878            * @brief  Stops the TIM Input Capture measurement on in DMA mode.
   1879            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   1880            *                the configuration information for TIM module.
   1881            * @param  Channel: TIM Channels to be disabled.
   1882            *          This parameter can be one of the following values:
   1883            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1884            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1885            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1886            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1887            * @retval HAL status
   1888            */

   \                                 In section .text, align 4, keep-with-next
   1889          HAL_StatusTypeDef HAL_TIM_IC_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
   1890          {
   1891            /* Check the parameters */
   1892            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1893            assert_param(IS_TIM_DMA_CC_INSTANCE(htim->Instance));
   1894            
   1895            switch (Channel)
   \                     HAL_TIM_IC_Stop_DMA: (+1)
   \   00000000   0x290C             CMP      R1,#+12
   \   00000002   0xB410             PUSH     {R4}
   \   00000004   0xD81C             BHI.N    ??HAL_TIM_IC_Stop_DMA_1
   \   00000006   0xE8DF 0xF001      TBB      [PC, R1]
   \                     ??HAL_TIM_IC_Stop_DMA_0:
   \   0000000A   0x07 0x1B          DC8      0x7,0x1B,0x1B,0x1B
   \              0x1B 0x1B    
   \   0000000E   0x0C 0x1B          DC8      0xC,0x1B,0x1B,0x1B
   \              0x1B 0x1B    
   \   00000012   0x11 0x1B          DC8      0x11,0x1B,0x1B,0x1B
   \              0x1B 0x1B    
   \   00000016   0x16 0x00          DC8      0x16,0x0
   1896            {
   1897              case TIM_CHANNEL_1:
   1898              {       
   1899                /* Disable the TIM Capture/Compare 1 DMA request */
   1900                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
   \                     ??HAL_TIM_IC_Stop_DMA_2: (+1)
   \   00000018   0x6802             LDR      R2,[R0, #+0]
   \   0000001A   0x68D3             LDR      R3,[R2, #+12]
   \   0000001C   0xF423 0x7300      BIC      R3,R3,#0x200
   \   00000020   0xE00D             B.N      ??HAL_TIM_IC_Stop_DMA_3
   1901              }
   1902              break;
   1903              
   1904              case TIM_CHANNEL_2:
   1905              {
   1906                /* Disable the TIM Capture/Compare 2 DMA request */
   1907                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
   \                     ??HAL_TIM_IC_Stop_DMA_4: (+1)
   \   00000022   0x6802             LDR      R2,[R0, #+0]
   \   00000024   0x68D3             LDR      R3,[R2, #+12]
   \   00000026   0xF423 0x6380      BIC      R3,R3,#0x400
   \   0000002A   0xE008             B.N      ??HAL_TIM_IC_Stop_DMA_3
   1908              }
   1909              break;
   1910              
   1911              case TIM_CHANNEL_3:
   1912              {
   1913                /* Disable the TIM Capture/Compare 3  DMA request */
   1914                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);
   \                     ??HAL_TIM_IC_Stop_DMA_5: (+1)
   \   0000002C   0x6802             LDR      R2,[R0, #+0]
   \   0000002E   0x68D3             LDR      R3,[R2, #+12]
   \   00000030   0xF423 0x6300      BIC      R3,R3,#0x800
   \   00000034   0xE003             B.N      ??HAL_TIM_IC_Stop_DMA_3
   1915              }
   1916              break;
   1917              
   1918              case TIM_CHANNEL_4:
   1919              {
   1920                /* Disable the TIM Capture/Compare 4  DMA request */
   1921                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC4);
   \                     ??HAL_TIM_IC_Stop_DMA_6: (+1)
   \   00000036   0x6802             LDR      R2,[R0, #+0]
   \   00000038   0x68D3             LDR      R3,[R2, #+12]
   \   0000003A   0xF423 0x5380      BIC      R3,R3,#0x1000
   \                     ??HAL_TIM_IC_Stop_DMA_3: (+1)
   \   0000003E   0x60D3             STR      R3,[R2, #+12]
   1922              }
   1923              break;
   1924              
   1925              default:
   1926              break;
   1927            }
   1928          
   1929            /* Disable the Input Capture channel */
   1930            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
   \                     ??HAL_TIM_IC_Stop_DMA_1: (+1)
   \   00000040   0x6802             LDR      R2,[R0, #+0]
   \   00000042   0x2401             MOVS     R4,#+1
   \   00000044   0xFA04 0xF101      LSL      R1,R4,R1
   \   00000048   0x6A13             LDR      R3,[R2, #+32]
   \   0000004A   0xEA23 0x0101      BIC      R1,R3,R1
   1931            
   1932            /* Disable the Peripheral */
   1933            __HAL_TIM_DISABLE(htim); 
   \   0000004E   0xF241 0x1311      MOVW     R3,#+4369
   \   00000052   0x6211             STR      R1,[R2, #+32]
   \   00000054   0x6A11             LDR      R1,[R2, #+32]
   \   00000056   0x6211             STR      R1,[R2, #+32]
   \   00000058   0x6801             LDR      R1,[R0, #+0]
   \   0000005A   0x6A0A             LDR      R2,[R1, #+32]
   \   0000005C   0x421A             TST      R2,R3
   \   0000005E   0xBF02             ITTT     EQ 
   \   00000060   0x6A0A             LDREQ    R2,[R1, #+32]
   \   00000062   0xF240 0x4344      MOVWEQ   R3,#+1092
   \   00000066   0x421A             TSTEQ    R2,R3
   \   00000068   0xD103             BNE.N    ??HAL_TIM_IC_Stop_DMA_7
   \   0000006A   0x680A             LDR      R2,[R1, #+0]
   \   0000006C   0x0852             LSRS     R2,R2,#+1
   \   0000006E   0x0052             LSLS     R2,R2,#+1
   \   00000070   0x600A             STR      R2,[R1, #+0]
   1934            
   1935            /* Change the htim state */
   1936            htim->State = HAL_TIM_STATE_READY;
   \                     ??HAL_TIM_IC_Stop_DMA_7: (+1)
   \   00000072   0xF880 0x4039      STRB     R4,[R0, #+57]
   1937            
   1938            /* Return function status */
   1939            return HAL_OK;
   \   00000076   0x2000             MOVS     R0,#+0
   \   00000078   0xBC10             POP      {R4}
   \   0000007A   0x4770             BX       LR               ;; return
   1940          }  
   1941          /**
   1942            * @}
   1943            */
   1944            
   1945          /** @defgroup TIM_Exported_Functions_Group5 Time One Pulse functions 
   1946           *  @brief    Time One Pulse functions 
   1947           *
   1948          @verbatim    
   1949            ==============================================================================
   1950                                  ##### Time One Pulse functions #####
   1951            ==============================================================================
   1952            [..]  
   1953              This section provides functions allowing to:
   1954              (+) Initialize and configure the TIM One Pulse. 
   1955              (+) De-initialize the TIM One Pulse.
   1956              (+) Start the Time One Pulse.
   1957              (+) Stop the Time One Pulse.
   1958              (+) Start the Time One Pulse and enable interrupt.
   1959              (+) Stop the Time One Pulse and disable interrupt.
   1960              (+) Start the Time One Pulse and enable DMA transfer.
   1961              (+) Stop the Time One Pulse and disable DMA transfer.
   1962           
   1963          @endverbatim
   1964            * @{
   1965            */
   1966          /**
   1967            * @brief  Initializes the TIM One Pulse Time Base according to the specified
   1968            *         parameters in the TIM_HandleTypeDef and create the associated handle.
   1969            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   1970            *                the configuration information for TIM module.
   1971            * @param  OnePulseMode: Select the One pulse mode.
   1972            *         This parameter can be one of the following values:
   1973            *            @arg TIM_OPMODE_SINGLE: Only one pulse will be generated.
   1974            *            @arg TIM_OPMODE_REPETITIVE: Repetitive pulses will be generated.
   1975            * @retval HAL status
   1976            */

   \                                 In section .text, align 2, keep-with-next
   1977          HAL_StatusTypeDef HAL_TIM_OnePulse_Init(TIM_HandleTypeDef *htim, uint32_t OnePulseMode)
   1978          {
   \                     HAL_TIM_OnePulse_Init: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x460D             MOV      R5,R1
   1979            /* Check the TIM handle allocation */
   1980            if(htim == NULL)
   \   00000006   0xD101             BNE.N    ??HAL_TIM_OnePulse_Init_0
   1981            {
   1982              return HAL_ERROR;
   \   00000008   0x2001             MOVS     R0,#+1
   \   0000000A   0xBD70             POP      {R4-R6,PC}
   1983            }
   1984          
   1985            /* Check the parameters */
   1986            assert_param(IS_TIM_INSTANCE(htim->Instance));
   1987            assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
   1988            assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
   1989            assert_param(IS_TIM_OPM_MODE(OnePulseMode));
   1990            
   1991            if(htim->State == HAL_TIM_STATE_RESET)
   \                     ??HAL_TIM_OnePulse_Init_0: (+1)
   \   0000000C   0xF894 0x0039      LDRB     R0,[R4, #+57]
   \   00000010   0xB920             CBNZ.N   R0,??HAL_TIM_OnePulse_Init_1
   1992            { 
   1993              /* Allocate lock resource and initialize it */
   1994              htim->Lock = HAL_UNLOCKED;    
   \   00000012   0xF884 0x0038      STRB     R0,[R4, #+56]
   1995              /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
   1996              HAL_TIM_OnePulse_MspInit(htim);
   \   00000016   0x4620             MOV      R0,R4
   \   00000018   0x.... 0x....      BL       HAL_TIM_OnePulse_MspInit
   1997            }
   1998            
   1999            /* Set the TIM state */
   2000            htim->State= HAL_TIM_STATE_BUSY;  
   \                     ??HAL_TIM_OnePulse_Init_1: (+1)
   \   0000001C   0x2002             MOVS     R0,#+2
   2001            
   2002            /* Configure the Time base in the One Pulse Mode */
   2003            TIM_Base_SetConfig(htim->Instance, &htim->Init);
   \   0000001E   0x.... 0x....      LDR.W    R2,??DataTable24  ;; 0x40010000
   \   00000022   0xF884 0x0039      STRB     R0,[R4, #+57]
   \   00000026   0x1D20             ADDS     R0,R4,#+4
   \   00000028   0x6821             LDR      R1,[R4, #+0]
   \   0000002A   0x4291             CMP      R1,R2
   \   0000002C   0x680B             LDR      R3,[R1, #+0]
   \   0000002E   0xBF18             IT       NE 
   \   00000030   0xF1B1 0x4F80      CMPNE    R1,#+1073741824
   \   00000034   0xD00F             BEQ.N    ??HAL_TIM_OnePulse_Init_2
   \   00000036   0x.... 0x....      LDR.W    R6,??DataTable24_1  ;; 0x40000400
   \   0000003A   0x42B1             CMP      R1,R6
   \   0000003C   0xBF1C             ITT      NE 
   \   0000003E   0x.... 0x....      LDRNE.W  R6,??DataTable24_2  ;; 0x40000800
   \   00000042   0x42B1             CMPNE    R1,R6
   \   00000044   0xD007             BEQ.N    ??HAL_TIM_OnePulse_Init_2
   \   00000046   0x.... 0x....      LDR.W    R6,??DataTable24_3  ;; 0x40000c00
   \   0000004A   0x42B1             CMP      R1,R6
   \   0000004C   0xBF1C             ITT      NE 
   \   0000004E   0x.... 0x....      LDRNE.W  R6,??DataTable27  ;; 0x40010400
   \   00000052   0x42B1             CMPNE    R1,R6
   \   00000054   0xD113             BNE.N    ??HAL_TIM_OnePulse_Init_3
   \                     ??HAL_TIM_OnePulse_Init_2: (+1)
   \   00000056   0x6846             LDR      R6,[R0, #+4]
   \   00000058   0xF023 0x0370      BIC      R3,R3,#0x70
   \   0000005C   0x4333             ORRS     R3,R6,R3
   \   0000005E   0x4291             CMP      R1,R2
   \   00000060   0xBF18             IT       NE 
   \   00000062   0xF1B1 0x4F80      CMPNE    R1,#+1073741824
   \   00000066   0xD025             BEQ.N    ??HAL_TIM_OnePulse_Init_4
   \   00000068   0x.... 0x....      LDR.W    R6,??DataTable24_1  ;; 0x40000400
   \   0000006C   0x42B1             CMP      R1,R6
   \   0000006E   0xBF1F             ITTTT    NE 
   \   00000070   0x.... 0x....      LDRNE.W  R6,??DataTable24_2  ;; 0x40000800
   \   00000074   0x42B1             CMPNE    R1,R6
   \   00000076   0x.... 0x....      LDRNE.W  R6,??DataTable24_3  ;; 0x40000c00
   \   0000007A   0x42B1             CMPNE    R1,R6
   \   0000007C   0xD01A             BEQ.N    ??HAL_TIM_OnePulse_Init_4
   \                     ??HAL_TIM_OnePulse_Init_3: (+1)
   \   0000007E   0x.... 0x....      LDR.W    R6,??DataTable27  ;; 0x40010400
   \   00000082   0x42B1             CMP      R1,R6
   \   00000084   0xBF1C             ITT      NE 
   \   00000086   0x.... 0x....      LDRNE.W  R6,??DataTable26  ;; 0x40014000
   \   0000008A   0x42B1             CMPNE    R1,R6
   \   0000008C   0xD012             BEQ.N    ??HAL_TIM_OnePulse_Init_4
   \   0000008E   0x.... 0x....      LDR.W    R6,??DataTable26_1  ;; 0x40014400
   \   00000092   0x42B1             CMP      R1,R6
   \   00000094   0xBF1C             ITT      NE 
   \   00000096   0x.... 0x....      LDRNE.W  R6,??DataTable26_2  ;; 0x40014800
   \   0000009A   0x42B1             CMPNE    R1,R6
   \   0000009C   0xD00A             BEQ.N    ??HAL_TIM_OnePulse_Init_4
   \   0000009E   0x.... 0x....      LDR.W    R6,??DataTable26_3  ;; 0x40001800
   \   000000A2   0x42B1             CMP      R1,R6
   \   000000A4   0xBF1F             ITTTT    NE 
   \   000000A6   0x.... 0x....      LDRNE.W  R6,??DataTable26_4  ;; 0x40001c00
   \   000000AA   0x42B1             CMPNE    R1,R6
   \   000000AC   0x.... 0x....      LDRNE.W  R6,??DataTable26_5  ;; 0x40002000
   \   000000B0   0x42B1             CMPNE    R1,R6
   \   000000B2   0xD103             BNE.N    ??HAL_TIM_OnePulse_Init_5
   \                     ??HAL_TIM_OnePulse_Init_4: (+1)
   \   000000B4   0x68C6             LDR      R6,[R0, #+12]
   \   000000B6   0xF423 0x7340      BIC      R3,R3,#0x300
   \   000000BA   0x4333             ORRS     R3,R6,R3
   \                     ??HAL_TIM_OnePulse_Init_5: (+1)
   \   000000BC   0x600B             STR      R3,[R1, #+0]
   \   000000BE   0x6883             LDR      R3,[R0, #+8]
   \   000000C0   0x4291             CMP      R1,R2
   \   000000C2   0x62CB             STR      R3,[R1, #+44]
   \   000000C4   0x6803             LDR      R3,[R0, #+0]
   \   000000C6   0x628B             STR      R3,[R1, #+40]
   \   000000C8   0xBF19             ITTEE    NE 
   \   000000CA   0x.... 0x....      LDRNE.W  R2,??DataTable27  ;; 0x40010400
   \   000000CE   0x4291             CMPNE    R1,R2
   \   000000D0   0x6900             LDREQ    R0,[R0, #+16]
   \   000000D2   0x6308             STREQ    R0,[R1, #+48]
   \   000000D4   0x2001             MOVS     R0,#+1
   \   000000D6   0x6148             STR      R0,[R1, #+20]
   2004            
   2005            /* Reset the OPM Bit */
   2006            htim->Instance->CR1 &= ~TIM_CR1_OPM;
   \   000000D8   0x6820             LDR      R0,[R4, #+0]
   \   000000DA   0x6801             LDR      R1,[R0, #+0]
   \   000000DC   0xF021 0x0108      BIC      R1,R1,#0x8
   \   000000E0   0x6001             STR      R1,[R0, #+0]
   2007          
   2008            /* Configure the OPM Mode */
   2009            htim->Instance->CR1 |= OnePulseMode;
   \   000000E2   0x6820             LDR      R0,[R4, #+0]
   \   000000E4   0x6801             LDR      R1,[R0, #+0]
   \   000000E6   0x4329             ORRS     R1,R5,R1
   \   000000E8   0x6001             STR      R1,[R0, #+0]
   2010             
   2011            /* Initialize the TIM state*/
   2012            htim->State= HAL_TIM_STATE_READY;
   \   000000EA   0x2001             MOVS     R0,#+1
   \   000000EC   0xF884 0x0039      STRB     R0,[R4, #+57]
   2013            
   2014            return HAL_OK;
   \   000000F0   0x2000             MOVS     R0,#+0
   \   000000F2   0xBD70             POP      {R4-R6,PC}       ;; return
   2015          }
   2016          
   2017          /**
   2018            * @brief  DeInitializes the TIM One Pulse  
   2019            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   2020            *                the configuration information for TIM module.
   2021            * @retval HAL status
   2022            */

   \                                 In section .text, align 2, keep-with-next
   2023          HAL_StatusTypeDef HAL_TIM_OnePulse_DeInit(TIM_HandleTypeDef *htim)
   2024          {
   \                     HAL_TIM_OnePulse_DeInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   2025            /* Check the parameters */
   2026            assert_param(IS_TIM_INSTANCE(htim->Instance));
   2027            
   2028            htim->State = HAL_TIM_STATE_BUSY;
   \   00000004   0x2002             MOVS     R0,#+2
   \   00000006   0xF884 0x0039      STRB     R0,[R4, #+57]
   2029            
   2030            /* Disable the TIM Peripheral Clock */
   2031            __HAL_TIM_DISABLE(htim);
   \   0000000A   0xF241 0x1211      MOVW     R2,#+4369
   \   0000000E   0x6820             LDR      R0,[R4, #+0]
   \   00000010   0x6A01             LDR      R1,[R0, #+32]
   \   00000012   0x4211             TST      R1,R2
   \   00000014   0xBF02             ITTT     EQ 
   \   00000016   0x6A01             LDREQ    R1,[R0, #+32]
   \   00000018   0xF240 0x4244      MOVWEQ   R2,#+1092
   \   0000001C   0x4211             TSTEQ    R1,R2
   \   0000001E   0xD103             BNE.N    ??HAL_TIM_OnePulse_DeInit_0
   \   00000020   0x6801             LDR      R1,[R0, #+0]
   \   00000022   0x0849             LSRS     R1,R1,#+1
   \   00000024   0x0049             LSLS     R1,R1,#+1
   \   00000026   0x6001             STR      R1,[R0, #+0]
   2032            
   2033            /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
   2034            HAL_TIM_OnePulse_MspDeInit(htim);
   \                     ??HAL_TIM_OnePulse_DeInit_0: (+1)
   \   00000028   0x4620             MOV      R0,R4
   \   0000002A   0x.... 0x....      BL       HAL_TIM_OnePulse_MspDeInit
   2035              
   2036            /* Change TIM state */  
   2037            htim->State = HAL_TIM_STATE_RESET;
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0xF884 0x0039      STRB     R0,[R4, #+57]
   2038          
   2039            /* Release Lock */
   2040            __HAL_UNLOCK(htim);
   \   00000034   0xF884 0x0038      STRB     R0,[R4, #+56]
   2041          
   2042            return HAL_OK;
   \   00000038   0xBD10             POP      {R4,PC}          ;; return
   2043          }
   2044          
   2045          /**
   2046            * @brief  Initializes the TIM One Pulse MSP.
   2047            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   2048            *                the configuration information for TIM module.
   2049            * @retval None
   2050            */

   \                                 In section .text, align 2, keep-with-next
   2051          __weak void HAL_TIM_OnePulse_MspInit(TIM_HandleTypeDef *htim)
   2052          {
   2053            /* NOTE : This function Should not be modified, when the callback is needed,
   2054                      the HAL_TIM_OnePulse_MspInit could be implemented in the user file
   2055             */
   2056          }
   \                     HAL_TIM_OnePulse_MspInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   2057          
   2058          /**
   2059            * @brief  DeInitializes TIM One Pulse MSP.
   2060            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   2061            *                the configuration information for TIM module.
   2062            * @retval None
   2063            */

   \                                 In section .text, align 2, keep-with-next
   2064          __weak void HAL_TIM_OnePulse_MspDeInit(TIM_HandleTypeDef *htim)
   2065          {
   2066            /* NOTE : This function Should not be modified, when the callback is needed,
   2067                      the HAL_TIM_OnePulse_MspDeInit could be implemented in the user file
   2068             */
   2069          }
   \                     HAL_TIM_OnePulse_MspDeInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   2070          
   2071          /**
   2072            * @brief  Starts the TIM One Pulse signal generation.
   2073            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   2074            *                the configuration information for TIM module.
   2075            * @param  OutputChannel : TIM Channels to be enabled.
   2076            *          This parameter can be one of the following values:
   2077            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2078            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2079            * @retval HAL status
   2080            */

   \                                 In section .text, align 2, keep-with-next
   2081          HAL_StatusTypeDef HAL_TIM_OnePulse_Start(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
   2082          {
   2083            /* Enable the Capture compare and the Input Capture channels 
   2084              (in the OPM Mode the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2)
   2085              if TIM_CHANNEL_1 is used as output, the TIM_CHANNEL_2 will be used as input and
   2086              if TIM_CHANNEL_1 is used as input, the TIM_CHANNEL_2 will be used as output 
   2087              in all combinations, the TIM_CHANNEL_1 and TIM_CHANNEL_2 should be enabled together 
   2088              
   2089              No need to enable the counter, it's enabled automatically by hardware 
   2090              (the counter starts in response to a stimulus and generate a pulse */
   2091            
   2092            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE); 
   \                     HAL_TIM_OnePulse_Start: (+1)
   \   00000000   0x6800             LDR      R0,[R0, #+0]
   \   00000002   0x6A01             LDR      R1,[R0, #+32]
   \   00000004   0x0849             LSRS     R1,R1,#+1
   \   00000006   0x0049             LSLS     R1,R1,#+1
   \   00000008   0x6201             STR      R1,[R0, #+32]
   \   0000000A   0x6A01             LDR      R1,[R0, #+32]
   \   0000000C   0xF041 0x0101      ORR      R1,R1,#0x1
   \   00000010   0x6201             STR      R1,[R0, #+32]
   2093            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE); 
   \   00000012   0x6A01             LDR      R1,[R0, #+32]
   \   00000014   0xF021 0x0110      BIC      R1,R1,#0x10
   \   00000018   0x6201             STR      R1,[R0, #+32]
   \   0000001A   0x6A01             LDR      R1,[R0, #+32]
   \   0000001C   0xF041 0x0110      ORR      R1,R1,#0x10
   \   00000020   0x6201             STR      R1,[R0, #+32]
   2094            
   2095            if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
   \   00000022   0x.... 0x....      LDR.W    R1,??DataTable24  ;; 0x40010000
   \   00000026   0x4288             CMP      R0,R1
   \   00000028   0xBF1C             ITT      NE 
   \   0000002A   0x.... 0x....      LDRNE.W  R1,??DataTable27  ;; 0x40010400
   \   0000002E   0x4288             CMPNE    R0,R1
   \   00000030   0xD103             BNE.N    ??HAL_TIM_OnePulse_Start_0
   2096            {
   2097              /* Enable the main output */
   2098              __HAL_TIM_MOE_ENABLE(htim);
   \   00000032   0x6C41             LDR      R1,[R0, #+68]
   \   00000034   0xF441 0x4100      ORR      R1,R1,#0x8000
   \   00000038   0x6441             STR      R1,[R0, #+68]
   2099            }
   2100            
   2101            /* Return function status */
   2102            return HAL_OK;
   \                     ??HAL_TIM_OnePulse_Start_0: (+1)
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0x4770             BX       LR               ;; return
   2103          }
   2104          
   2105          /**
   2106            * @brief  Stops the TIM One Pulse signal generation.
   2107            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   2108            *                the configuration information for TIM module.
   2109            * @param  OutputChannel : TIM Channels to be disable.
   2110            *          This parameter can be one of the following values:
   2111            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2112            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2113            * @retval HAL status
   2114            */

   \                                 In section .text, align 2, keep-with-next
   2115          HAL_StatusTypeDef HAL_TIM_OnePulse_Stop(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
   2116          {
   2117            /* Disable the Capture compare and the Input Capture channels 
   2118            (in the OPM Mode the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2)
   2119            if TIM_CHANNEL_1 is used as output, the TIM_CHANNEL_2 will be used as input and
   2120            if TIM_CHANNEL_1 is used as input, the TIM_CHANNEL_2 will be used as output 
   2121            in all combinations, the TIM_CHANNEL_1 and TIM_CHANNEL_2 should be disabled together */
   2122            
   2123            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE); 
   \                     HAL_TIM_OnePulse_Stop: (+1)
   \   00000000   0x6800             LDR      R0,[R0, #+0]
   \   00000002   0x6A01             LDR      R1,[R0, #+32]
   \   00000004   0x0849             LSRS     R1,R1,#+1
   \   00000006   0x0049             LSLS     R1,R1,#+1
   \   00000008   0x6201             STR      R1,[R0, #+32]
   \   0000000A   0x6A01             LDR      R1,[R0, #+32]
   \   0000000C   0x6201             STR      R1,[R0, #+32]
   2124            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE); 
   \   0000000E   0x6A01             LDR      R1,[R0, #+32]
   \   00000010   0xF021 0x0110      BIC      R1,R1,#0x10
   \   00000014   0x6201             STR      R1,[R0, #+32]
   \   00000016   0x6A01             LDR      R1,[R0, #+32]
   \   00000018   0x6201             STR      R1,[R0, #+32]
   2125              
   2126            if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
   \   0000001A   0x.... 0x....      LDR.W    R1,??DataTable24  ;; 0x40010000
   \   0000001E   0x4288             CMP      R0,R1
   \   00000020   0xBF1C             ITT      NE 
   \   00000022   0x.... 0x....      LDRNE.W  R1,??DataTable27  ;; 0x40010400
   \   00000026   0x4288             CMPNE    R0,R1
   \   00000028   0xD10D             BNE.N    ??HAL_TIM_OnePulse_Stop_0
   2127            {
   2128              /* Disable the Main Output */
   2129              __HAL_TIM_MOE_DISABLE(htim);
   \   0000002A   0x6A01             LDR      R1,[R0, #+32]
   \   0000002C   0xF241 0x1211      MOVW     R2,#+4369
   \   00000030   0x4211             TST      R1,R2
   \   00000032   0xBF02             ITTT     EQ 
   \   00000034   0x6A01             LDREQ    R1,[R0, #+32]
   \   00000036   0xF240 0x4244      MOVWEQ   R2,#+1092
   \   0000003A   0x4211             TSTEQ    R1,R2
   \   0000003C   0xD103             BNE.N    ??HAL_TIM_OnePulse_Stop_0
   \   0000003E   0x6C41             LDR      R1,[R0, #+68]
   \   00000040   0xF421 0x4100      BIC      R1,R1,#0x8000
   \   00000044   0x6441             STR      R1,[R0, #+68]
   2130            }
   2131              
   2132            /* Disable the Peripheral */
   2133            __HAL_TIM_DISABLE(htim); 
   \                     ??HAL_TIM_OnePulse_Stop_0: (+1)
   \   00000046   0x6A01             LDR      R1,[R0, #+32]
   \   00000048   0xF241 0x1211      MOVW     R2,#+4369
   \   0000004C   0x4211             TST      R1,R2
   \   0000004E   0xBF02             ITTT     EQ 
   \   00000050   0x6A01             LDREQ    R1,[R0, #+32]
   \   00000052   0xF240 0x4244      MOVWEQ   R2,#+1092
   \   00000056   0x4211             TSTEQ    R1,R2
   \   00000058   0xD103             BNE.N    ??HAL_TIM_OnePulse_Stop_1
   \   0000005A   0x6801             LDR      R1,[R0, #+0]
   \   0000005C   0x0849             LSRS     R1,R1,#+1
   \   0000005E   0x0049             LSLS     R1,R1,#+1
   \   00000060   0x6001             STR      R1,[R0, #+0]
   2134            
   2135            /* Return function status */
   2136            return HAL_OK;
   \                     ??HAL_TIM_OnePulse_Stop_1: (+1)
   \   00000062   0x2000             MOVS     R0,#+0
   \   00000064   0x4770             BX       LR               ;; return
   2137          }
   2138          
   2139          /**
   2140            * @brief  Starts the TIM One Pulse signal generation in interrupt mode.
   2141            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   2142            *                the configuration information for TIM module.
   2143            * @param  OutputChannel : TIM Channels to be enabled.
   2144            *          This parameter can be one of the following values:
   2145            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2146            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2147            * @retval HAL status
   2148            */

   \                                 In section .text, align 2, keep-with-next
   2149          HAL_StatusTypeDef HAL_TIM_OnePulse_Start_IT(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
   2150          {
   2151            /* Enable the Capture compare and the Input Capture channels 
   2152              (in the OPM Mode the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2)
   2153              if TIM_CHANNEL_1 is used as output, the TIM_CHANNEL_2 will be used as input and
   2154              if TIM_CHANNEL_1 is used as input, the TIM_CHANNEL_2 will be used as output 
   2155              in all combinations, the TIM_CHANNEL_1 and TIM_CHANNEL_2 should be enabled together 
   2156              
   2157              No need to enable the counter, it's enabled automatically by hardware 
   2158              (the counter starts in response to a stimulus and generate a pulse */
   2159           
   2160            /* Enable the TIM Capture/Compare 1 interrupt */
   2161            __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
   \                     HAL_TIM_OnePulse_Start_IT: (+1)
   \   00000000   0x6800             LDR      R0,[R0, #+0]
   \   00000002   0x68C1             LDR      R1,[R0, #+12]
   \   00000004   0xF041 0x0102      ORR      R1,R1,#0x2
   \   00000008   0x60C1             STR      R1,[R0, #+12]
   2162            
   2163            /* Enable the TIM Capture/Compare 2 interrupt */
   2164            __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
   \   0000000A   0x68C1             LDR      R1,[R0, #+12]
   \   0000000C   0xF041 0x0104      ORR      R1,R1,#0x4
   \   00000010   0x60C1             STR      R1,[R0, #+12]
   2165            
   2166            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE); 
   \   00000012   0x6A01             LDR      R1,[R0, #+32]
   \   00000014   0x0849             LSRS     R1,R1,#+1
   \   00000016   0x0049             LSLS     R1,R1,#+1
   \   00000018   0x6201             STR      R1,[R0, #+32]
   \   0000001A   0x6A01             LDR      R1,[R0, #+32]
   \   0000001C   0xF041 0x0101      ORR      R1,R1,#0x1
   \   00000020   0x6201             STR      R1,[R0, #+32]
   2167            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE); 
   \   00000022   0x6A01             LDR      R1,[R0, #+32]
   \   00000024   0xF021 0x0110      BIC      R1,R1,#0x10
   \   00000028   0x6201             STR      R1,[R0, #+32]
   \   0000002A   0x6A01             LDR      R1,[R0, #+32]
   \   0000002C   0xF041 0x0110      ORR      R1,R1,#0x10
   \   00000030   0x6201             STR      R1,[R0, #+32]
   2168            
   2169            if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
   \   00000032   0x.... 0x....      LDR.W    R1,??DataTable24  ;; 0x40010000
   \   00000036   0x4288             CMP      R0,R1
   \   00000038   0xBF1C             ITT      NE 
   \   0000003A   0x.... 0x....      LDRNE.W  R1,??DataTable28  ;; 0x40010400
   \   0000003E   0x4288             CMPNE    R0,R1
   \   00000040   0xD103             BNE.N    ??HAL_TIM_OnePulse_Start_IT_0
   2170            {
   2171              /* Enable the main output */
   2172              __HAL_TIM_MOE_ENABLE(htim);
   \   00000042   0x6C41             LDR      R1,[R0, #+68]
   \   00000044   0xF441 0x4100      ORR      R1,R1,#0x8000
   \   00000048   0x6441             STR      R1,[R0, #+68]
   2173            }
   2174            
   2175            /* Return function status */
   2176            return HAL_OK;
   \                     ??HAL_TIM_OnePulse_Start_IT_0: (+1)
   \   0000004A   0x2000             MOVS     R0,#+0
   \   0000004C   0x4770             BX       LR               ;; return
   2177          }
   2178          
   2179          /**
   2180            * @brief  Stops the TIM One Pulse signal generation in interrupt mode.
   2181            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   2182            *                the configuration information for TIM module.
   2183            * @param  OutputChannel : TIM Channels to be enabled.
   2184            *          This parameter can be one of the following values:
   2185            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2186            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2187            * @retval HAL status
   2188            */

   \                                 In section .text, align 2, keep-with-next
   2189          HAL_StatusTypeDef HAL_TIM_OnePulse_Stop_IT(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
   2190          {
   2191            /* Disable the TIM Capture/Compare 1 interrupt */
   2192            __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);  
   \                     HAL_TIM_OnePulse_Stop_IT: (+1)
   \   00000000   0x6800             LDR      R0,[R0, #+0]
   \   00000002   0x68C1             LDR      R1,[R0, #+12]
   \   00000004   0xF021 0x0102      BIC      R1,R1,#0x2
   \   00000008   0x60C1             STR      R1,[R0, #+12]
   2193            
   2194            /* Disable the TIM Capture/Compare 2 interrupt */
   2195            __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
   \   0000000A   0x68C1             LDR      R1,[R0, #+12]
   \   0000000C   0xF021 0x0104      BIC      R1,R1,#0x4
   \   00000010   0x60C1             STR      R1,[R0, #+12]
   2196            
   2197            /* Disable the Capture compare and the Input Capture channels 
   2198            (in the OPM Mode the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2)
   2199            if TIM_CHANNEL_1 is used as output, the TIM_CHANNEL_2 will be used as input and
   2200            if TIM_CHANNEL_1 is used as input, the TIM_CHANNEL_2 will be used as output 
   2201            in all combinations, the TIM_CHANNEL_1 and TIM_CHANNEL_2 should be disabled together */  
   2202            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE); 
   \   00000012   0x6A01             LDR      R1,[R0, #+32]
   \   00000014   0x0849             LSRS     R1,R1,#+1
   \   00000016   0x0049             LSLS     R1,R1,#+1
   \   00000018   0x6201             STR      R1,[R0, #+32]
   \   0000001A   0x6A01             LDR      R1,[R0, #+32]
   \   0000001C   0x6201             STR      R1,[R0, #+32]
   2203            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE); 
   \   0000001E   0x6A01             LDR      R1,[R0, #+32]
   \   00000020   0xF021 0x0110      BIC      R1,R1,#0x10
   \   00000024   0x6201             STR      R1,[R0, #+32]
   \   00000026   0x6A01             LDR      R1,[R0, #+32]
   \   00000028   0x6201             STR      R1,[R0, #+32]
   2204              
   2205            if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
   \   0000002A   0x.... 0x....      LDR.W    R1,??DataTable24  ;; 0x40010000
   \   0000002E   0x4288             CMP      R0,R1
   \   00000030   0xBF1C             ITT      NE 
   \   00000032   0x.... 0x....      LDRNE.W  R1,??DataTable28  ;; 0x40010400
   \   00000036   0x4288             CMPNE    R0,R1
   \   00000038   0xD10D             BNE.N    ??HAL_TIM_OnePulse_Stop_IT_0
   2206            {
   2207              /* Disable the Main Output */
   2208              __HAL_TIM_MOE_DISABLE(htim);
   \   0000003A   0x6A01             LDR      R1,[R0, #+32]
   \   0000003C   0xF241 0x1211      MOVW     R2,#+4369
   \   00000040   0x4211             TST      R1,R2
   \   00000042   0xBF02             ITTT     EQ 
   \   00000044   0x6A01             LDREQ    R1,[R0, #+32]
   \   00000046   0xF240 0x4244      MOVWEQ   R2,#+1092
   \   0000004A   0x4211             TSTEQ    R1,R2
   \   0000004C   0xD103             BNE.N    ??HAL_TIM_OnePulse_Stop_IT_0
   \   0000004E   0x6C41             LDR      R1,[R0, #+68]
   \   00000050   0xF421 0x4100      BIC      R1,R1,#0x8000
   \   00000054   0x6441             STR      R1,[R0, #+68]
   2209            }
   2210              
   2211            /* Disable the Peripheral */
   2212             __HAL_TIM_DISABLE(htim);  
   \                     ??HAL_TIM_OnePulse_Stop_IT_0: (+1)
   \   00000056   0x6A01             LDR      R1,[R0, #+32]
   \   00000058   0xF241 0x1211      MOVW     R2,#+4369
   \   0000005C   0x4211             TST      R1,R2
   \   0000005E   0xBF02             ITTT     EQ 
   \   00000060   0x6A01             LDREQ    R1,[R0, #+32]
   \   00000062   0xF240 0x4244      MOVWEQ   R2,#+1092
   \   00000066   0x4211             TSTEQ    R1,R2
   \   00000068   0xD103             BNE.N    ??HAL_TIM_OnePulse_Stop_IT_1
   \   0000006A   0x6801             LDR      R1,[R0, #+0]
   \   0000006C   0x0849             LSRS     R1,R1,#+1
   \   0000006E   0x0049             LSLS     R1,R1,#+1
   \   00000070   0x6001             STR      R1,[R0, #+0]
   2213            
   2214            /* Return function status */
   2215            return HAL_OK;
   \                     ??HAL_TIM_OnePulse_Stop_IT_1: (+1)
   \   00000072   0x2000             MOVS     R0,#+0
   \   00000074   0x4770             BX       LR               ;; return
   2216          }
   2217          
   2218          /**
   2219            * @}
   2220            */
   2221          
   2222          /** @defgroup TIM_Exported_Functions_Group6 Time Encoder functions 
   2223           *  @brief    Time Encoder functions 
   2224           *
   2225          @verbatim    
   2226            ==============================================================================
   2227                                    ##### Time Encoder functions #####
   2228            ==============================================================================
   2229            [..]
   2230              This section provides functions allowing to:
   2231              (+) Initialize and configure the TIM Encoder. 
   2232              (+) De-initialize the TIM Encoder.
   2233              (+) Start the Time Encoder.
   2234              (+) Stop the Time Encoder.
   2235              (+) Start the Time Encoder and enable interrupt.
   2236              (+) Stop the Time Encoder and disable interrupt.
   2237              (+) Start the Time Encoder and enable DMA transfer.
   2238              (+) Stop the Time Encoder and disable DMA transfer.
   2239           
   2240          @endverbatim
   2241            * @{
   2242            */
   2243          /**
   2244            * @brief  Initializes the TIM Encoder Interface and create the associated handle.
   2245            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   2246            *                the configuration information for TIM module.
   2247            * @param  sConfig: TIM Encoder Interface configuration structure
   2248            * @retval HAL status
   2249            */

   \                                 In section .text, align 2, keep-with-next
   2250          HAL_StatusTypeDef HAL_TIM_Encoder_Init(TIM_HandleTypeDef *htim,  TIM_Encoder_InitTypeDef* sConfig)
   2251          {
   \                     HAL_TIM_Encoder_Init: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x460D             MOV      R5,R1
   2252            uint32_t tmpsmcr = 0;
   2253            uint32_t tmpccmr1 = 0;
   2254            uint32_t tmpccer = 0;
   2255            
   2256            /* Check the TIM handle allocation */
   2257            if(htim == NULL)
   \   00000006   0xD101             BNE.N    ??HAL_TIM_Encoder_Init_0
   2258            {
   2259              return HAL_ERROR;
   \   00000008   0x2001             MOVS     R0,#+1
   \   0000000A   0xBD70             POP      {R4-R6,PC}
   2260            }
   2261             
   2262            /* Check the parameters */
   2263            assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   2264            assert_param(IS_TIM_ENCODER_MODE(sConfig->EncoderMode));
   2265            assert_param(IS_TIM_IC_SELECTION(sConfig->IC1Selection));
   2266            assert_param(IS_TIM_IC_SELECTION(sConfig->IC2Selection));
   2267            assert_param(IS_TIM_IC_POLARITY(sConfig->IC1Polarity));
   2268            assert_param(IS_TIM_IC_POLARITY(sConfig->IC2Polarity));
   2269            assert_param(IS_TIM_IC_PRESCALER(sConfig->IC1Prescaler));
   2270            assert_param(IS_TIM_IC_PRESCALER(sConfig->IC2Prescaler));
   2271            assert_param(IS_TIM_IC_FILTER(sConfig->IC1Filter));
   2272            assert_param(IS_TIM_IC_FILTER(sConfig->IC2Filter));
   2273          
   2274            if(htim->State == HAL_TIM_STATE_RESET)
   \                     ??HAL_TIM_Encoder_Init_0: (+1)
   \   0000000C   0xF894 0x0039      LDRB     R0,[R4, #+57]
   \   00000010   0xB920             CBNZ.N   R0,??HAL_TIM_Encoder_Init_1
   2275            { 
   2276              /* Allocate lock resource and initialize it */
   2277              htim->Lock = HAL_UNLOCKED;  
   \   00000012   0xF884 0x0038      STRB     R0,[R4, #+56]
   2278              /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
   2279              HAL_TIM_Encoder_MspInit(htim);
   \   00000016   0x4620             MOV      R0,R4
   \   00000018   0x.... 0x....      BL       HAL_TIM_Encoder_MspInit
   2280            }
   2281            
   2282            /* Set the TIM state */
   2283            htim->State= HAL_TIM_STATE_BUSY;   
   \                     ??HAL_TIM_Encoder_Init_1: (+1)
   \   0000001C   0x2002             MOVS     R0,#+2
   2284              
   2285            /* Reset the SMS bits */
   2286            htim->Instance->SMCR &= ~TIM_SMCR_SMS;
   \   0000001E   0x.... 0x....      LDR.W    R2,??DataTable28_1  ;; 0xfffefff8
   \   00000022   0xF884 0x0039      STRB     R0,[R4, #+57]
   \   00000026   0x6820             LDR      R0,[R4, #+0]
   \   00000028   0x6881             LDR      R1,[R0, #+8]
   \   0000002A   0x4011             ANDS     R1,R2,R1
   2287            
   2288            /* Configure the Time base in the Encoder Mode */
   2289            TIM_Base_SetConfig(htim->Instance, &htim->Init);  
   \   0000002C   0x.... 0x....      LDR.W    R2,??DataTable24  ;; 0x40010000
   \   00000030   0x6081             STR      R1,[R0, #+8]
   \   00000032   0x1D20             ADDS     R0,R4,#+4
   \   00000034   0x6821             LDR      R1,[R4, #+0]
   \   00000036   0x4291             CMP      R1,R2
   \   00000038   0x680B             LDR      R3,[R1, #+0]
   \   0000003A   0xBF18             IT       NE 
   \   0000003C   0xF1B1 0x4F80      CMPNE    R1,#+1073741824
   \   00000040   0xD00F             BEQ.N    ??HAL_TIM_Encoder_Init_2
   \   00000042   0x.... 0x....      LDR.W    R6,??DataTable24_1  ;; 0x40000400
   \   00000046   0x42B1             CMP      R1,R6
   \   00000048   0xBF1C             ITT      NE 
   \   0000004A   0x.... 0x....      LDRNE.W  R6,??DataTable24_2  ;; 0x40000800
   \   0000004E   0x42B1             CMPNE    R1,R6
   \   00000050   0xD007             BEQ.N    ??HAL_TIM_Encoder_Init_2
   \   00000052   0x.... 0x....      LDR.W    R6,??DataTable24_3  ;; 0x40000c00
   \   00000056   0x42B1             CMP      R1,R6
   \   00000058   0xBF1C             ITT      NE 
   \   0000005A   0x.... 0x....      LDRNE.W  R6,??DataTable27  ;; 0x40010400
   \   0000005E   0x42B1             CMPNE    R1,R6
   \   00000060   0xD113             BNE.N    ??HAL_TIM_Encoder_Init_3
   \                     ??HAL_TIM_Encoder_Init_2: (+1)
   \   00000062   0x6846             LDR      R6,[R0, #+4]
   \   00000064   0xF023 0x0370      BIC      R3,R3,#0x70
   \   00000068   0x4333             ORRS     R3,R6,R3
   \   0000006A   0x4291             CMP      R1,R2
   \   0000006C   0xBF18             IT       NE 
   \   0000006E   0xF1B1 0x4F80      CMPNE    R1,#+1073741824
   \   00000072   0xD025             BEQ.N    ??HAL_TIM_Encoder_Init_4
   \   00000074   0x.... 0x....      LDR.W    R6,??DataTable24_1  ;; 0x40000400
   \   00000078   0x42B1             CMP      R1,R6
   \   0000007A   0xBF1F             ITTTT    NE 
   \   0000007C   0x.... 0x....      LDRNE.W  R6,??DataTable24_2  ;; 0x40000800
   \   00000080   0x42B1             CMPNE    R1,R6
   \   00000082   0x.... 0x....      LDRNE.W  R6,??DataTable24_3  ;; 0x40000c00
   \   00000086   0x42B1             CMPNE    R1,R6
   \   00000088   0xD01A             BEQ.N    ??HAL_TIM_Encoder_Init_4
   \                     ??HAL_TIM_Encoder_Init_3: (+1)
   \   0000008A   0x.... 0x....      LDR.W    R6,??DataTable27  ;; 0x40010400
   \   0000008E   0x42B1             CMP      R1,R6
   \   00000090   0xBF1C             ITT      NE 
   \   00000092   0x.... 0x....      LDRNE.W  R6,??DataTable26  ;; 0x40014000
   \   00000096   0x42B1             CMPNE    R1,R6
   \   00000098   0xD012             BEQ.N    ??HAL_TIM_Encoder_Init_4
   \   0000009A   0x.... 0x....      LDR.W    R6,??DataTable26_1  ;; 0x40014400
   \   0000009E   0x42B1             CMP      R1,R6
   \   000000A0   0xBF1C             ITT      NE 
   \   000000A2   0x.... 0x....      LDRNE.W  R6,??DataTable26_2  ;; 0x40014800
   \   000000A6   0x42B1             CMPNE    R1,R6
   \   000000A8   0xD00A             BEQ.N    ??HAL_TIM_Encoder_Init_4
   \   000000AA   0x.... 0x....      LDR.W    R6,??DataTable26_3  ;; 0x40001800
   \   000000AE   0x42B1             CMP      R1,R6
   \   000000B0   0xBF1F             ITTTT    NE 
   \   000000B2   0x.... 0x....      LDRNE.W  R6,??DataTable26_4  ;; 0x40001c00
   \   000000B6   0x42B1             CMPNE    R1,R6
   \   000000B8   0x.... 0x....      LDRNE.W  R6,??DataTable26_5  ;; 0x40002000
   \   000000BC   0x42B1             CMPNE    R1,R6
   \   000000BE   0xD103             BNE.N    ??HAL_TIM_Encoder_Init_5
   \                     ??HAL_TIM_Encoder_Init_4: (+1)
   \   000000C0   0x68C6             LDR      R6,[R0, #+12]
   \   000000C2   0xF423 0x7340      BIC      R3,R3,#0x300
   \   000000C6   0x4333             ORRS     R3,R6,R3
   \                     ??HAL_TIM_Encoder_Init_5: (+1)
   \   000000C8   0x600B             STR      R3,[R1, #+0]
   \   000000CA   0x6883             LDR      R3,[R0, #+8]
   \   000000CC   0x4291             CMP      R1,R2
   2290            
   2291            /* Get the TIMx SMCR register value */
   2292            tmpsmcr = htim->Instance->SMCR;
   2293          
   2294            /* Get the TIMx CCMR1 register value */
   2295            tmpccmr1 = htim->Instance->CCMR1;
   2296          
   2297            /* Get the TIMx CCER register value */
   2298            tmpccer = htim->Instance->CCER;
   2299          
   2300            /* Set the encoder Mode */
   2301            tmpsmcr |= sConfig->EncoderMode;
   2302          
   2303            /* Select the Capture Compare 1 and the Capture Compare 2 as input */
   2304            tmpccmr1 &= ~(TIM_CCMR1_CC1S | TIM_CCMR1_CC2S);
   2305            tmpccmr1 |= (sConfig->IC1Selection | (sConfig->IC2Selection << 8));
   2306            
   2307            /* Set the Capture Compare 1 and the Capture Compare 2 prescalers and filters */
   2308            tmpccmr1 &= ~(TIM_CCMR1_IC1PSC | TIM_CCMR1_IC2PSC);
   2309            tmpccmr1 &= ~(TIM_CCMR1_IC1F | TIM_CCMR1_IC2F);
   2310            tmpccmr1 |= sConfig->IC1Prescaler | (sConfig->IC2Prescaler << 8);
   2311            tmpccmr1 |= (sConfig->IC1Filter << 4) | (sConfig->IC2Filter << 12);
   \   000000CE   0x.... 0x....      LDR.W    R6,??DataTable28_2  ;; 0xfffffcfc
   \   000000D2   0x62CB             STR      R3,[R1, #+44]
   \   000000D4   0x6803             LDR      R3,[R0, #+0]
   \   000000D6   0x628B             STR      R3,[R1, #+40]
   \   000000D8   0xBF19             ITTEE    NE 
   \   000000DA   0x.... 0x....      LDRNE.W  R2,??DataTable27  ;; 0x40010400
   \   000000DE   0x4291             CMPNE    R1,R2
   \   000000E0   0x6900             LDREQ    R0,[R0, #+16]
   \   000000E2   0x6308             STREQ    R0,[R1, #+48]
   \   000000E4   0x2001             MOVS     R0,#+1
   \   000000E6   0x6148             STR      R0,[R1, #+20]
   \   000000E8   0x6820             LDR      R0,[R4, #+0]
   \   000000EA   0x6881             LDR      R1,[R0, #+8]
   \   000000EC   0x6983             LDR      R3,[R0, #+24]
   \   000000EE   0x6A02             LDR      R2,[R0, #+32]
   \   000000F0   0x4033             ANDS     R3,R6,R3
   \   000000F2   0x68AE             LDR      R6,[R5, #+8]
   2312          
   2313            /* Set the TI1 and the TI2 Polarities */
   2314            tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC2P);
   2315            tmpccer &= ~(TIM_CCER_CC1NP | TIM_CCER_CC2NP);
   2316            tmpccer |= sConfig->IC1Polarity | (sConfig->IC2Polarity << 4);
   \   000000F4   0xF022 0x02AA      BIC      R2,R2,#0xAA
   \   000000F8   0x4333             ORRS     R3,R6,R3
   \   000000FA   0x69AE             LDR      R6,[R5, #+24]
   \   000000FC   0xEA43 0x2306      ORR      R3,R3,R6, LSL #+8
   \   00000100   0x.... 0x....      LDR.W    R6,??DataTable28_3  ;; 0xffff0303
   \   00000104   0x4033             ANDS     R3,R6,R3
   \   00000106   0x68EE             LDR      R6,[R5, #+12]
   \   00000108   0x4333             ORRS     R3,R6,R3
   \   0000010A   0x69EE             LDR      R6,[R5, #+28]
   \   0000010C   0xEA43 0x2306      ORR      R3,R3,R6, LSL #+8
   \   00000110   0x692E             LDR      R6,[R5, #+16]
   \   00000112   0xEA43 0x1306      ORR      R3,R3,R6, LSL #+4
   \   00000116   0x6A2E             LDR      R6,[R5, #+32]
   \   00000118   0xEA43 0x3306      ORR      R3,R3,R6, LSL #+12
   \   0000011C   0x686E             LDR      R6,[R5, #+4]
   \   0000011E   0x4332             ORRS     R2,R6,R2
   \   00000120   0x696E             LDR      R6,[R5, #+20]
   2317            
   2318            /* Write to TIMx SMCR */
   2319            htim->Instance->SMCR = tmpsmcr;
   \   00000122   0x682D             LDR      R5,[R5, #+0]
   \   00000124   0xEA42 0x1206      ORR      R2,R2,R6, LSL #+4
   \   00000128   0x4329             ORRS     R1,R5,R1
   \   0000012A   0x6081             STR      R1,[R0, #+8]
   2320          
   2321            /* Write to TIMx CCMR1 */
   2322            htim->Instance->CCMR1 = tmpccmr1;
   \   0000012C   0x6820             LDR      R0,[R4, #+0]
   \   0000012E   0x6183             STR      R3,[R0, #+24]
   2323          
   2324            /* Write to TIMx CCER */
   2325            htim->Instance->CCER = tmpccer;
   \   00000130   0x6820             LDR      R0,[R4, #+0]
   \   00000132   0x6202             STR      R2,[R0, #+32]
   2326            
   2327            /* Initialize the TIM state*/
   2328            htim->State= HAL_TIM_STATE_READY;
   \   00000134   0x2001             MOVS     R0,#+1
   \   00000136   0xF884 0x0039      STRB     R0,[R4, #+57]
   2329            
   2330            return HAL_OK;
   \   0000013A   0x2000             MOVS     R0,#+0
   \   0000013C   0xBD70             POP      {R4-R6,PC}       ;; return
   2331          }
   2332          
   2333          /**
   2334            * @brief  DeInitializes the TIM Encoder interface  
   2335            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   2336            *                the configuration information for TIM module.
   2337            * @retval HAL status
   2338            */

   \                                 In section .text, align 2, keep-with-next
   2339          HAL_StatusTypeDef HAL_TIM_Encoder_DeInit(TIM_HandleTypeDef *htim)
   2340          {
   \                     HAL_TIM_Encoder_DeInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   2341            /* Check the parameters */
   2342            assert_param(IS_TIM_INSTANCE(htim->Instance));
   2343            
   2344            htim->State = HAL_TIM_STATE_BUSY;
   \   00000004   0x2002             MOVS     R0,#+2
   \   00000006   0xF884 0x0039      STRB     R0,[R4, #+57]
   2345            
   2346            /* Disable the TIM Peripheral Clock */
   2347            __HAL_TIM_DISABLE(htim);
   \   0000000A   0xF241 0x1211      MOVW     R2,#+4369
   \   0000000E   0x6820             LDR      R0,[R4, #+0]
   \   00000010   0x6A01             LDR      R1,[R0, #+32]
   \   00000012   0x4211             TST      R1,R2
   \   00000014   0xBF02             ITTT     EQ 
   \   00000016   0x6A01             LDREQ    R1,[R0, #+32]
   \   00000018   0xF240 0x4244      MOVWEQ   R2,#+1092
   \   0000001C   0x4211             TSTEQ    R1,R2
   \   0000001E   0xD103             BNE.N    ??HAL_TIM_Encoder_DeInit_0
   \   00000020   0x6801             LDR      R1,[R0, #+0]
   \   00000022   0x0849             LSRS     R1,R1,#+1
   \   00000024   0x0049             LSLS     R1,R1,#+1
   \   00000026   0x6001             STR      R1,[R0, #+0]
   2348            
   2349            /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
   2350            HAL_TIM_Encoder_MspDeInit(htim);
   \                     ??HAL_TIM_Encoder_DeInit_0: (+1)
   \   00000028   0x4620             MOV      R0,R4
   \   0000002A   0x.... 0x....      BL       HAL_TIM_Encoder_MspDeInit
   2351              
   2352            /* Change TIM state */  
   2353            htim->State = HAL_TIM_STATE_RESET;
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0xF884 0x0039      STRB     R0,[R4, #+57]
   2354           
   2355            /* Release Lock */
   2356            __HAL_UNLOCK(htim);
   \   00000034   0xF884 0x0038      STRB     R0,[R4, #+56]
   2357          
   2358            return HAL_OK;
   \   00000038   0xBD10             POP      {R4,PC}          ;; return
   2359          }
   2360          
   2361          /**
   2362            * @brief  Initializes the TIM Encoder Interface MSP.
   2363            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   2364            *                the configuration information for TIM module.
   2365            * @retval None
   2366            */

   \                                 In section .text, align 2, keep-with-next
   2367          __weak void HAL_TIM_Encoder_MspInit(TIM_HandleTypeDef *htim)
   2368          {
   2369            /* NOTE : This function Should not be modified, when the callback is needed,
   2370                      the HAL_TIM_Encoder_MspInit could be implemented in the user file
   2371             */
   2372          }
   \                     HAL_TIM_Encoder_MspInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   2373          
   2374          /**
   2375            * @brief  DeInitializes TIM Encoder Interface MSP.
   2376            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   2377            *                the configuration information for TIM module.
   2378            * @retval None
   2379            */

   \                                 In section .text, align 2, keep-with-next
   2380          __weak void HAL_TIM_Encoder_MspDeInit(TIM_HandleTypeDef *htim)
   2381          {
   2382            /* NOTE : This function Should not be modified, when the callback is needed,
   2383                      the HAL_TIM_Encoder_MspDeInit could be implemented in the user file
   2384             */
   2385          }
   \                     HAL_TIM_Encoder_MspDeInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   2386          
   2387          /**
   2388            * @brief  Starts the TIM Encoder Interface.
   2389            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   2390            *                the configuration information for TIM module.
   2391            * @param  Channel: TIM Channels to be enabled.
   2392            *          This parameter can be one of the following values:
   2393            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2394            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2395            *            @arg TIM_CHANNEL_ALL: TIM Channel 1 and TIM Channel 2 are selected
   2396            * @retval HAL status
   2397            */

   \                                 In section .text, align 2, keep-with-next
   2398          HAL_StatusTypeDef HAL_TIM_Encoder_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
   2399          {
   2400            /* Check the parameters */
   2401            assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   2402            
   2403            /* Enable the encoder interface channels */
   2404            switch (Channel)
   \                     HAL_TIM_Encoder_Start: (+1)
   \   00000000   0xB111             CBZ.N    R1,??HAL_TIM_Encoder_Start_0
   \   00000002   0x2904             CMP      R1,#+4
   \   00000004   0xD009             BEQ.N    ??HAL_TIM_Encoder_Start_1
   \   00000006   0xE00A             B.N      ??HAL_TIM_Encoder_Start_2
   2405            {
   2406              case TIM_CHANNEL_1:
   2407              {
   2408                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
   \                     ??HAL_TIM_Encoder_Start_0: (+1)
   \   00000008   0x6801             LDR      R1,[R0, #+0]
   \   0000000A   0x6A0A             LDR      R2,[R1, #+32]
   \   0000000C   0x0852             LSRS     R2,R2,#+1
   \   0000000E   0x0052             LSLS     R2,R2,#+1
   \   00000010   0x620A             STR      R2,[R1, #+32]
   \   00000012   0x6A0A             LDR      R2,[R1, #+32]
   \   00000014   0xF042 0x0201      ORR      R2,R2,#0x1
   \   00000018   0xE011             B.N      ??HAL_TIM_Encoder_Start_3
   2409                break; 
   2410              }
   2411              case TIM_CHANNEL_2:
   2412              { 
   2413                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE); 
   \                     ??HAL_TIM_Encoder_Start_1: (+1)
   \   0000001A   0x6801             LDR      R1,[R0, #+0]
   \   0000001C   0xE008             B.N      ??HAL_TIM_Encoder_Start_4
   2414                break;
   2415              }  
   2416              default :
   2417              {
   2418               TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
   \                     ??HAL_TIM_Encoder_Start_2: (+1)
   \   0000001E   0x6801             LDR      R1,[R0, #+0]
   \   00000020   0x6A0A             LDR      R2,[R1, #+32]
   \   00000022   0x0852             LSRS     R2,R2,#+1
   \   00000024   0x0052             LSLS     R2,R2,#+1
   \   00000026   0x620A             STR      R2,[R1, #+32]
   \   00000028   0x6A0A             LDR      R2,[R1, #+32]
   \   0000002A   0xF042 0x0201      ORR      R2,R2,#0x1
   \   0000002E   0x620A             STR      R2,[R1, #+32]
   2419               TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
   \                     ??HAL_TIM_Encoder_Start_4: (+1)
   \   00000030   0x6A0A             LDR      R2,[R1, #+32]
   \   00000032   0xF022 0x0210      BIC      R2,R2,#0x10
   \   00000036   0x620A             STR      R2,[R1, #+32]
   \   00000038   0x6A0A             LDR      R2,[R1, #+32]
   \   0000003A   0xF042 0x0210      ORR      R2,R2,#0x10
   \                     ??HAL_TIM_Encoder_Start_3: (+1)
   \   0000003E   0x620A             STR      R2,[R1, #+32]
   2420               break; 
   2421              }
   2422            }  
   2423            /* Enable the Peripheral */
   2424            __HAL_TIM_ENABLE(htim);
   \   00000040   0x6801             LDR      R1,[R0, #+0]
   \   00000042   0x6808             LDR      R0,[R1, #+0]
   \   00000044   0xF040 0x0001      ORR      R0,R0,#0x1
   \   00000048   0x6008             STR      R0,[R1, #+0]
   2425            
   2426            /* Return function status */
   2427            return HAL_OK;
   \   0000004A   0x2000             MOVS     R0,#+0
   \   0000004C   0x4770             BX       LR               ;; return
   2428          }
   2429          
   2430          /**
   2431            * @brief  Stops the TIM Encoder Interface.
   2432            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   2433            *                the configuration information for TIM module.
   2434            * @param  Channel: TIM Channels to be disabled.
   2435            *          This parameter can be one of the following values:
   2436            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2437            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2438            *            @arg TIM_CHANNEL_ALL: TIM Channel 1 and TIM Channel 2 are selected
   2439            * @retval HAL status
   2440            */

   \                                 In section .text, align 2, keep-with-next
   2441          HAL_StatusTypeDef HAL_TIM_Encoder_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
   2442          {
   2443            /* Check the parameters */
   2444              assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   2445              
   2446             /* Disable the Input Capture channels 1 and 2
   2447              (in the EncoderInterface the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2) */ 
   2448            switch (Channel)
   \                     HAL_TIM_Encoder_Stop: (+1)
   \   00000000   0xB111             CBZ.N    R1,??HAL_TIM_Encoder_Stop_0
   \   00000002   0x2904             CMP      R1,#+4
   \   00000004   0xD005             BEQ.N    ??HAL_TIM_Encoder_Stop_1
   \   00000006   0xE006             B.N      ??HAL_TIM_Encoder_Stop_2
   2449            {
   2450              case TIM_CHANNEL_1:
   2451              {
   2452                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
   \                     ??HAL_TIM_Encoder_Stop_0: (+1)
   \   00000008   0x6801             LDR      R1,[R0, #+0]
   \   0000000A   0x6A0A             LDR      R2,[R1, #+32]
   \   0000000C   0x0852             LSRS     R2,R2,#+1
   \   0000000E   0x0052             LSLS     R2,R2,#+1
   \   00000010   0xE00B             B.N      ??HAL_TIM_Encoder_Stop_3
   2453                break; 
   2454              }
   2455              case TIM_CHANNEL_2:
   2456              { 
   2457                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE); 
   \                     ??HAL_TIM_Encoder_Stop_1: (+1)
   \   00000012   0x6801             LDR      R1,[R0, #+0]
   \   00000014   0xE006             B.N      ??HAL_TIM_Encoder_Stop_4
   2458                break;
   2459              }  
   2460              default :
   2461              {
   2462               TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
   \                     ??HAL_TIM_Encoder_Stop_2: (+1)
   \   00000016   0x6801             LDR      R1,[R0, #+0]
   \   00000018   0x6A0A             LDR      R2,[R1, #+32]
   \   0000001A   0x0852             LSRS     R2,R2,#+1
   \   0000001C   0x0052             LSLS     R2,R2,#+1
   \   0000001E   0x620A             STR      R2,[R1, #+32]
   \   00000020   0x6A0A             LDR      R2,[R1, #+32]
   \   00000022   0x620A             STR      R2,[R1, #+32]
   2463               TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
   \                     ??HAL_TIM_Encoder_Stop_4: (+1)
   \   00000024   0x6A0A             LDR      R2,[R1, #+32]
   \   00000026   0xF022 0x0210      BIC      R2,R2,#0x10
   \                     ??HAL_TIM_Encoder_Stop_3: (+1)
   \   0000002A   0x620A             STR      R2,[R1, #+32]
   \   0000002C   0x6A0A             LDR      R2,[R1, #+32]
   \   0000002E   0x620A             STR      R2,[R1, #+32]
   2464               break; 
   2465              }
   2466            }  
   2467            /* Disable the Peripheral */
   2468            __HAL_TIM_DISABLE(htim);
   \   00000030   0x6801             LDR      R1,[R0, #+0]
   \   00000032   0xF241 0x1211      MOVW     R2,#+4369
   \   00000036   0x6A08             LDR      R0,[R1, #+32]
   \   00000038   0x4210             TST      R0,R2
   \   0000003A   0xBF02             ITTT     EQ 
   \   0000003C   0x6A08             LDREQ    R0,[R1, #+32]
   \   0000003E   0xF240 0x4244      MOVWEQ   R2,#+1092
   \   00000042   0x4210             TSTEQ    R0,R2
   \   00000044   0xD103             BNE.N    ??HAL_TIM_Encoder_Stop_5
   \   00000046   0x6808             LDR      R0,[R1, #+0]
   \   00000048   0x0840             LSRS     R0,R0,#+1
   \   0000004A   0x0040             LSLS     R0,R0,#+1
   \   0000004C   0x6008             STR      R0,[R1, #+0]
   2469            
   2470            /* Return function status */
   2471            return HAL_OK;
   \                     ??HAL_TIM_Encoder_Stop_5: (+1)
   \   0000004E   0x2000             MOVS     R0,#+0
   \   00000050   0x4770             BX       LR               ;; return
   2472          }
   2473          
   2474          /**
   2475            * @brief  Starts the TIM Encoder Interface in interrupt mode.
   2476            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   2477            *                the configuration information for TIM module.
   2478            * @param  Channel: TIM Channels to be enabled.
   2479            *          This parameter can be one of the following values:
   2480            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2481            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2482            *            @arg TIM_CHANNEL_ALL: TIM Channel 1 and TIM Channel 2 are selected
   2483            * @retval HAL status
   2484            */

   \                                 In section .text, align 2, keep-with-next
   2485          HAL_StatusTypeDef HAL_TIM_Encoder_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
   2486          {
   2487            /* Check the parameters */
   2488            assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   2489            
   2490            /* Enable the encoder interface channels */
   2491            /* Enable the capture compare Interrupts 1 and/or 2 */
   2492            switch (Channel)
   \                     HAL_TIM_Encoder_Start_IT: (+1)
   \   00000000   0xB111             CBZ.N    R1,??HAL_TIM_Encoder_Start_IT_0
   \   00000002   0x2904             CMP      R1,#+4
   \   00000004   0xD00D             BEQ.N    ??HAL_TIM_Encoder_Start_IT_1
   \   00000006   0xE016             B.N      ??HAL_TIM_Encoder_Start_IT_2
   2493            {
   2494              case TIM_CHANNEL_1:
   2495              {
   2496                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
   \                     ??HAL_TIM_Encoder_Start_IT_0: (+1)
   \   00000008   0x6801             LDR      R1,[R0, #+0]
   \   0000000A   0x6A0A             LDR      R2,[R1, #+32]
   \   0000000C   0x0852             LSRS     R2,R2,#+1
   \   0000000E   0x0052             LSLS     R2,R2,#+1
   \   00000010   0x620A             STR      R2,[R1, #+32]
   \   00000012   0x6A0A             LDR      R2,[R1, #+32]
   \   00000014   0xF042 0x0201      ORR      R2,R2,#0x1
   \   00000018   0x620A             STR      R2,[R1, #+32]
   2497                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
   \   0000001A   0x68CA             LDR      R2,[R1, #+12]
   \   0000001C   0xF042 0x0202      ORR      R2,R2,#0x2
   \   00000020   0xE021             B.N      ??HAL_TIM_Encoder_Start_IT_3
   2498                break; 
   2499              }
   2500              case TIM_CHANNEL_2:
   2501              { 
   2502                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
   \                     ??HAL_TIM_Encoder_Start_IT_1: (+1)
   \   00000022   0x6801             LDR      R1,[R0, #+0]
   \   00000024   0x6A0A             LDR      R2,[R1, #+32]
   \   00000026   0xF022 0x0210      BIC      R2,R2,#0x10
   \   0000002A   0x620A             STR      R2,[R1, #+32]
   \   0000002C   0x6A0A             LDR      R2,[R1, #+32]
   \   0000002E   0xF042 0x0210      ORR      R2,R2,#0x10
   \   00000032   0x620A             STR      R2,[R1, #+32]
   2503                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2); 
   \   00000034   0xE014             B.N      ??HAL_TIM_Encoder_Start_IT_4
   2504                break;
   2505              }  
   2506              default :
   2507              {
   2508               TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
   \                     ??HAL_TIM_Encoder_Start_IT_2: (+1)
   \   00000036   0x6801             LDR      R1,[R0, #+0]
   \   00000038   0x6A0A             LDR      R2,[R1, #+32]
   \   0000003A   0x0852             LSRS     R2,R2,#+1
   \   0000003C   0x0052             LSLS     R2,R2,#+1
   \   0000003E   0x620A             STR      R2,[R1, #+32]
   \   00000040   0x6A0A             LDR      R2,[R1, #+32]
   \   00000042   0xF042 0x0201      ORR      R2,R2,#0x1
   \   00000046   0x620A             STR      R2,[R1, #+32]
   2509               TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
   \   00000048   0x6A0A             LDR      R2,[R1, #+32]
   \   0000004A   0xF022 0x0210      BIC      R2,R2,#0x10
   \   0000004E   0x620A             STR      R2,[R1, #+32]
   \   00000050   0x6A0A             LDR      R2,[R1, #+32]
   \   00000052   0xF042 0x0210      ORR      R2,R2,#0x10
   \   00000056   0x620A             STR      R2,[R1, #+32]
   2510               __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
   \   00000058   0x68CA             LDR      R2,[R1, #+12]
   \   0000005A   0xF042 0x0202      ORR      R2,R2,#0x2
   \   0000005E   0x60CA             STR      R2,[R1, #+12]
   2511               __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
   \                     ??HAL_TIM_Encoder_Start_IT_4: (+1)
   \   00000060   0x68CA             LDR      R2,[R1, #+12]
   \   00000062   0xF042 0x0204      ORR      R2,R2,#0x4
   \                     ??HAL_TIM_Encoder_Start_IT_3: (+1)
   \   00000066   0x60CA             STR      R2,[R1, #+12]
   2512               break; 
   2513              }
   2514            }
   2515            
   2516            /* Enable the Peripheral */
   2517            __HAL_TIM_ENABLE(htim);
   \   00000068   0x6801             LDR      R1,[R0, #+0]
   \   0000006A   0x6808             LDR      R0,[R1, #+0]
   \   0000006C   0xF040 0x0001      ORR      R0,R0,#0x1
   \   00000070   0x6008             STR      R0,[R1, #+0]
   2518            
   2519            /* Return function status */
   2520            return HAL_OK;
   \   00000072   0x2000             MOVS     R0,#+0
   \   00000074   0x4770             BX       LR               ;; return
   2521          }
   2522          
   2523          /**
   2524            * @brief  Stops the TIM Encoder Interface in interrupt mode.
   2525            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   2526            *                the configuration information for TIM module.
   2527            * @param  Channel: TIM Channels to be disabled.
   2528            *          This parameter can be one of the following values:
   2529            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2530            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2531            *            @arg TIM_CHANNEL_ALL: TIM Channel 1 and TIM Channel 2 are selected
   2532            * @retval HAL status
   2533            */

   \                                 In section .text, align 2, keep-with-next
   2534          HAL_StatusTypeDef HAL_TIM_Encoder_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
   2535          {
   2536            /* Check the parameters */
   2537            assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   2538              
   2539            /* Disable the Input Capture channels 1 and 2
   2540              (in the EncoderInterface the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2) */ 
   2541            if(Channel == TIM_CHANNEL_1)
   \                     HAL_TIM_Encoder_Stop_IT: (+1)
   \   00000000   0xB959             CBNZ.N   R1,??HAL_TIM_Encoder_Stop_IT_0
   2542            {
   2543              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE); 
   \   00000002   0x6801             LDR      R1,[R0, #+0]
   \   00000004   0x6A0A             LDR      R2,[R1, #+32]
   \   00000006   0x0852             LSRS     R2,R2,#+1
   \   00000008   0x0052             LSLS     R2,R2,#+1
   \   0000000A   0x620A             STR      R2,[R1, #+32]
   \   0000000C   0x6A0A             LDR      R2,[R1, #+32]
   \   0000000E   0x620A             STR      R2,[R1, #+32]
   2544              
   2545              /* Disable the capture compare Interrupts 1 */
   2546            __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
   \   00000010   0x6801             LDR      R1,[R0, #+0]
   \   00000012   0x68CA             LDR      R2,[R1, #+12]
   \   00000014   0xF022 0x0202      BIC      R2,R2,#0x2
   \   00000018   0xE01E             B.N      ??HAL_TIM_Encoder_Stop_IT_1
   2547            }  
   2548            else if(Channel == TIM_CHANNEL_2)
   \                     ??HAL_TIM_Encoder_Stop_IT_0: (+1)
   \   0000001A   0x2904             CMP      R1,#+4
   \   0000001C   0x6801             LDR      R1,[R0, #+0]
   \   0000001E   0x6A0A             LDR      R2,[R1, #+32]
   \   00000020   0xD105             BNE.N    ??HAL_TIM_Encoder_Stop_IT_2
   2549            {  
   2550              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE); 
   \   00000022   0xF022 0x0210      BIC      R2,R2,#0x10
   \   00000026   0x620A             STR      R2,[R1, #+32]
   \   00000028   0x6A0A             LDR      R2,[R1, #+32]
   \   0000002A   0x620A             STR      R2,[R1, #+32]
   2551              
   2552              /* Disable the capture compare Interrupts 2 */
   2553            __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
   \   0000002C   0xE010             B.N      ??HAL_TIM_Encoder_Stop_IT_3
   2554            }  
   2555            else
   2556            {
   2557              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE); 
   \                     ??HAL_TIM_Encoder_Stop_IT_2: (+1)
   \   0000002E   0x0852             LSRS     R2,R2,#+1
   \   00000030   0x0052             LSLS     R2,R2,#+1
   \   00000032   0x620A             STR      R2,[R1, #+32]
   \   00000034   0x6A0A             LDR      R2,[R1, #+32]
   \   00000036   0x620A             STR      R2,[R1, #+32]
   2558              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE); 
   \   00000038   0x6801             LDR      R1,[R0, #+0]
   \   0000003A   0x6A0A             LDR      R2,[R1, #+32]
   \   0000003C   0xF022 0x0210      BIC      R2,R2,#0x10
   \   00000040   0x620A             STR      R2,[R1, #+32]
   \   00000042   0x6A0A             LDR      R2,[R1, #+32]
   \   00000044   0x620A             STR      R2,[R1, #+32]
   2559              
   2560              /* Disable the capture compare Interrupts 1 and 2 */
   2561              __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
   \   00000046   0x6801             LDR      R1,[R0, #+0]
   \   00000048   0x68CA             LDR      R2,[R1, #+12]
   \   0000004A   0xF022 0x0202      BIC      R2,R2,#0x2
   \   0000004E   0x60CA             STR      R2,[R1, #+12]
   2562              __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
   \                     ??HAL_TIM_Encoder_Stop_IT_3: (+1)
   \   00000050   0x6801             LDR      R1,[R0, #+0]
   \   00000052   0x68CA             LDR      R2,[R1, #+12]
   \   00000054   0xF022 0x0204      BIC      R2,R2,#0x4
   \                     ??HAL_TIM_Encoder_Stop_IT_1: (+1)
   \   00000058   0x60CA             STR      R2,[R1, #+12]
   2563            }
   2564              
   2565            /* Disable the Peripheral */
   2566            __HAL_TIM_DISABLE(htim);
   \   0000005A   0x6801             LDR      R1,[R0, #+0]
   \   0000005C   0xF241 0x1311      MOVW     R3,#+4369
   \   00000060   0x6A0A             LDR      R2,[R1, #+32]
   \   00000062   0x421A             TST      R2,R3
   \   00000064   0xBF02             ITTT     EQ 
   \   00000066   0x6A0A             LDREQ    R2,[R1, #+32]
   \   00000068   0xF240 0x4344      MOVWEQ   R3,#+1092
   \   0000006C   0x421A             TSTEQ    R2,R3
   \   0000006E   0xD103             BNE.N    ??HAL_TIM_Encoder_Stop_IT_4
   \   00000070   0x680A             LDR      R2,[R1, #+0]
   \   00000072   0x0852             LSRS     R2,R2,#+1
   \   00000074   0x0052             LSLS     R2,R2,#+1
   \   00000076   0x600A             STR      R2,[R1, #+0]
   2567            
   2568            /* Change the htim state */
   2569            htim->State = HAL_TIM_STATE_READY;
   \                     ??HAL_TIM_Encoder_Stop_IT_4: (+1)
   \   00000078   0x2101             MOVS     R1,#+1
   \   0000007A   0xF880 0x1039      STRB     R1,[R0, #+57]
   2570            
   2571            /* Return function status */
   2572            return HAL_OK;
   \   0000007E   0x2000             MOVS     R0,#+0
   \   00000080   0x4770             BX       LR               ;; return
   2573          }
   2574          
   2575          /**
   2576            * @brief  Starts the TIM Encoder Interface in DMA mode.
   2577            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   2578            *                the configuration information for TIM module.
   2579            * @param  Channel: TIM Channels to be enabled.
   2580            *          This parameter can be one of the following values:
   2581            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2582            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2583            *            @arg TIM_CHANNEL_ALL: TIM Channel 1 and TIM Channel 2 are selected
   2584            * @param  pData1: The destination Buffer address for IC1.
   2585            * @param  pData2: The destination Buffer address for IC2.
   2586            * @param  Length: The length of data to be transferred from TIM peripheral to memory.
   2587            * @retval HAL status
   2588            */

   \                                 In section .text, align 2, keep-with-next
   2589          HAL_StatusTypeDef HAL_TIM_Encoder_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData1, uint32_t *pData2, uint16_t Length)
   2590          {
   \                     HAL_TIM_Encoder_Start_DMA: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4605             MOV      R5,R0
   \   00000006   0x4698             MOV      R8,R3
   2591            /* Check the parameters */
   2592            assert_param(IS_TIM_DMA_CC_INSTANCE(htim->Instance));
   2593            
   2594            if((htim->State == HAL_TIM_STATE_BUSY))
   \   00000008   0xF895 0x0039      LDRB     R0,[R5, #+57]
   \   0000000C   0x2802             CMP      R0,#+2
   \   0000000E   0xF000 0x809A      BEQ.W    ??HAL_TIM_Encoder_Start_DMA_0
   \   00000012   0x9C06             LDR      R4,[SP, #+24]
   2595            {
   2596               return HAL_BUSY;
   2597            }
   2598            else if((htim->State == HAL_TIM_STATE_READY))
   \   00000014   0xF895 0x0039      LDRB     R0,[R5, #+57]
   \   00000018   0x2801             CMP      R0,#+1
   \   0000001A   0xD10A             BNE.N    ??HAL_TIM_Encoder_Start_DMA_1
   2599            {
   2600              if((((pData1 == 0) || (pData2 == 0) )) && (Length > 0)) 
   \   0000001C   0x2A00             CMP      R2,#+0
   \   0000001E   0xBF18             IT       NE 
   \   00000020   0xF1B8 0x0F00      CMPNE    R8,#+0
   \   00000024   0xD102             BNE.N    ??HAL_TIM_Encoder_Start_DMA_2
   \   00000026   0x2C00             CMP      R4,#+0
   \   00000028   0xF040 0x808D      BNE.W    ??HAL_TIM_Encoder_Start_DMA_0
   2601              {
   2602                return HAL_ERROR;                                    
   2603              }
   2604              else
   2605              {
   2606                htim->State = HAL_TIM_STATE_BUSY;
   \                     ??HAL_TIM_Encoder_Start_DMA_2: (+1)
   \   0000002C   0x2002             MOVS     R0,#+2
   \   0000002E   0xF885 0x0039      STRB     R0,[R5, #+57]
   2607              }
   2608            }  
   2609             
   2610            switch (Channel)
   \                     ??HAL_TIM_Encoder_Start_DMA_1: (+1)
   \   00000032   0xB121             CBZ.N    R1,??HAL_TIM_Encoder_Start_DMA_3
   \   00000034   0x2904             CMP      R1,#+4
   \   00000036   0xD025             BEQ.N    ??HAL_TIM_Encoder_Start_DMA_4
   \   00000038   0x293C             CMP      R1,#+60
   \   0000003A   0xD047             BEQ.N    ??HAL_TIM_Encoder_Start_DMA_5
   \   0000003C   0xE082             B.N      ??HAL_TIM_Encoder_Start_DMA_6
   2611            {
   2612              case TIM_CHANNEL_1:
   2613              {
   2614                /* Set the DMA Period elapsed callback */
   2615                htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = HAL_TIM_DMACaptureCplt;
   \                     ??HAL_TIM_Encoder_Start_DMA_3: (+1)
   \   0000003E   0x6A29             LDR      R1,[R5, #+32]
   \   00000040   0x.... 0x....      LDR.W    R0,??DataTable25
   2616               
   2617                /* Set the DMA error callback */
   2618                htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = HAL_TIM_DMAError ;
   2619                
   2620                /* Enable the DMA Stream */
   2621                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->CCR1, (uint32_t )pData1, Length); 
   \   00000044   0x4623             MOV      R3,R4
   \   00000046   0x63C8             STR      R0,[R1, #+60]
   \   00000048   0x6A29             LDR      R1,[R5, #+32]
   \   0000004A   0x.... 0x....      LDR.W    R0,??DataTable30
   \   0000004E   0x6488             STR      R0,[R1, #+72]
   \   00000050   0x6828             LDR      R0,[R5, #+0]
   \   00000052   0xF100 0x0134      ADD      R1,R0,#+52
   \   00000056   0x6A28             LDR      R0,[R5, #+32]
   \   00000058   0x.... 0x....      BL       HAL_DMA_Start_IT
   2622                
   2623                /* Enable the TIM Input Capture DMA request */      
   2624                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
   \   0000005C   0x6828             LDR      R0,[R5, #+0]
   \   0000005E   0x68C1             LDR      R1,[R0, #+12]
   \   00000060   0xF441 0x7100      ORR      R1,R1,#0x200
   \   00000064   0x60C1             STR      R1,[R0, #+12]
   2625                      
   2626                /* Enable the Peripheral */
   2627                __HAL_TIM_ENABLE(htim);
   \   00000066   0x6828             LDR      R0,[R5, #+0]
   \   00000068   0x6801             LDR      R1,[R0, #+0]
   \   0000006A   0xF041 0x0101      ORR      R1,R1,#0x1
   \   0000006E   0x6001             STR      R1,[R0, #+0]
   2628                
   2629                /* Enable the Capture compare channel */
   2630                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
   \   00000070   0x6828             LDR      R0,[R5, #+0]
   \   00000072   0x6A01             LDR      R1,[R0, #+32]
   \   00000074   0x0849             LSRS     R1,R1,#+1
   \   00000076   0x0049             LSLS     R1,R1,#+1
   \   00000078   0x6201             STR      R1,[R0, #+32]
   \   0000007A   0x6A01             LDR      R1,[R0, #+32]
   \   0000007C   0xF041 0x0101      ORR      R1,R1,#0x1
   \   00000080   0x6201             STR      R1,[R0, #+32]
   2631              }
   2632              break;
   2633              
   2634              case TIM_CHANNEL_2:
   2635              {
   2636                /* Set the DMA Period elapsed callback */
   2637                htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = HAL_TIM_DMACaptureCplt;
   2638               
   2639                /* Set the DMA error callback */
   2640                htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = HAL_TIM_DMAError;
   2641                /* Enable the DMA Stream */
   2642                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->CCR2, (uint32_t)pData2, Length);
   2643                
   2644                /* Enable the TIM Input Capture  DMA request */
   2645                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
   2646               
   2647                /* Enable the Peripheral */
   2648                __HAL_TIM_ENABLE(htim);
   2649                
   2650                /* Enable the Capture compare channel */
   2651                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
   2652              }
   2653              break;
   \   00000082   0xE05F             B.N      ??HAL_TIM_Encoder_Start_DMA_6
   \                     ??HAL_TIM_Encoder_Start_DMA_4: (+1)
   \   00000084   0x6A69             LDR      R1,[R5, #+36]
   \   00000086   0x.... 0x....      LDR.W    R0,??DataTable25
   \   0000008A   0x4623             MOV      R3,R4
   \   0000008C   0x4642             MOV      R2,R8
   \   0000008E   0x63C8             STR      R0,[R1, #+60]
   \   00000090   0x6A69             LDR      R1,[R5, #+36]
   \   00000092   0x.... 0x....      LDR.W    R0,??DataTable30
   \   00000096   0x6488             STR      R0,[R1, #+72]
   \   00000098   0x6828             LDR      R0,[R5, #+0]
   \   0000009A   0xF100 0x0138      ADD      R1,R0,#+56
   \   0000009E   0x6A68             LDR      R0,[R5, #+36]
   \   000000A0   0x.... 0x....      BL       HAL_DMA_Start_IT
   \   000000A4   0x6828             LDR      R0,[R5, #+0]
   \   000000A6   0x68C1             LDR      R1,[R0, #+12]
   \   000000A8   0xF441 0x6180      ORR      R1,R1,#0x400
   \   000000AC   0x60C1             STR      R1,[R0, #+12]
   \   000000AE   0x6828             LDR      R0,[R5, #+0]
   \   000000B0   0x6801             LDR      R1,[R0, #+0]
   \   000000B2   0xF041 0x0101      ORR      R1,R1,#0x1
   \   000000B6   0x6001             STR      R1,[R0, #+0]
   \   000000B8   0x6828             LDR      R0,[R5, #+0]
   \   000000BA   0x6A01             LDR      R1,[R0, #+32]
   \   000000BC   0xF021 0x0110      BIC      R1,R1,#0x10
   \   000000C0   0x6201             STR      R1,[R0, #+32]
   \   000000C2   0x6A01             LDR      R1,[R0, #+32]
   \   000000C4   0xF041 0x0110      ORR      R1,R1,#0x10
   \   000000C8   0x6201             STR      R1,[R0, #+32]
   \   000000CA   0xE03B             B.N      ??HAL_TIM_Encoder_Start_DMA_6
   2654              
   2655              case TIM_CHANNEL_ALL:
   2656              {
   2657                /* Set the DMA Period elapsed callback */
   2658                htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = HAL_TIM_DMACaptureCplt;
   \                     ??HAL_TIM_Encoder_Start_DMA_5: (+1)
   \   000000CC   0x6A28             LDR      R0,[R5, #+32]
   \   000000CE   0x.... 0x....      LDR.W    R7,??DataTable25
   2659               
   2660                /* Set the DMA error callback */
   2661                htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = HAL_TIM_DMAError ;
   \   000000D2   0x.... 0x....      LDR.W    R6,??DataTable30
   2662                
   2663                /* Enable the DMA Stream */
   2664                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->CCR1, (uint32_t)pData1, Length);
   \   000000D6   0x4623             MOV      R3,R4
   \   000000D8   0x63C7             STR      R7,[R0, #+60]
   \   000000DA   0x6A28             LDR      R0,[R5, #+32]
   \   000000DC   0x6486             STR      R6,[R0, #+72]
   \   000000DE   0x6828             LDR      R0,[R5, #+0]
   \   000000E0   0xF100 0x0134      ADD      R1,R0,#+52
   \   000000E4   0x6A28             LDR      R0,[R5, #+32]
   \   000000E6   0x.... 0x....      BL       HAL_DMA_Start_IT
   2665                
   2666                /* Set the DMA Period elapsed callback */
   2667                htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = HAL_TIM_DMACaptureCplt;
   \   000000EA   0x6A68             LDR      R0,[R5, #+36]
   2668               
   2669                /* Set the DMA error callback */
   2670                htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = HAL_TIM_DMAError ;
   2671                
   2672                /* Enable the DMA Stream */
   2673                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->CCR2, (uint32_t)pData2, Length);
   \   000000EC   0x4623             MOV      R3,R4
   \   000000EE   0x4642             MOV      R2,R8
   \   000000F0   0x63C7             STR      R7,[R0, #+60]
   \   000000F2   0x6A68             LDR      R0,[R5, #+36]
   \   000000F4   0x6486             STR      R6,[R0, #+72]
   \   000000F6   0x6828             LDR      R0,[R5, #+0]
   \   000000F8   0xF100 0x0138      ADD      R1,R0,#+56
   \   000000FC   0x6A68             LDR      R0,[R5, #+36]
   \   000000FE   0x.... 0x....      BL       HAL_DMA_Start_IT
   2674                    
   2675               /* Enable the Peripheral */
   2676                __HAL_TIM_ENABLE(htim);
   \   00000102   0x6828             LDR      R0,[R5, #+0]
   \   00000104   0x6801             LDR      R1,[R0, #+0]
   \   00000106   0xF041 0x0101      ORR      R1,R1,#0x1
   \   0000010A   0x6001             STR      R1,[R0, #+0]
   2677                
   2678                /* Enable the Capture compare channel */
   2679                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
   \   0000010C   0x6828             LDR      R0,[R5, #+0]
   \   0000010E   0x6A01             LDR      R1,[R0, #+32]
   \   00000110   0x0849             LSRS     R1,R1,#+1
   \   00000112   0x0049             LSLS     R1,R1,#+1
   \   00000114   0x6201             STR      R1,[R0, #+32]
   \   00000116   0x6A01             LDR      R1,[R0, #+32]
   \   00000118   0xF041 0x0101      ORR      R1,R1,#0x1
   \   0000011C   0x6201             STR      R1,[R0, #+32]
   2680                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
   \   0000011E   0x6828             LDR      R0,[R5, #+0]
   \   00000120   0x6A01             LDR      R1,[R0, #+32]
   \   00000122   0xF021 0x0110      BIC      R1,R1,#0x10
   \   00000126   0x6201             STR      R1,[R0, #+32]
   \   00000128   0x6A01             LDR      R1,[R0, #+32]
   \   0000012A   0xF041 0x0110      ORR      R1,R1,#0x10
   \   0000012E   0x6201             STR      R1,[R0, #+32]
   2681                
   2682                /* Enable the TIM Input Capture  DMA request */
   2683                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
   \   00000130   0x6828             LDR      R0,[R5, #+0]
   \   00000132   0x68C1             LDR      R1,[R0, #+12]
   \   00000134   0xF441 0x7100      ORR      R1,R1,#0x200
   \   00000138   0x60C1             STR      R1,[R0, #+12]
   2684                /* Enable the TIM Input Capture  DMA request */
   2685                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
   \   0000013A   0x6828             LDR      R0,[R5, #+0]
   \   0000013C   0x68C1             LDR      R1,[R0, #+12]
   \   0000013E   0xF441 0x6180      ORR      R1,R1,#0x400
   \   00000142   0x60C1             STR      R1,[R0, #+12]
   2686              }
   2687              break;
   2688              
   2689              default:
   2690              break;
   2691            }  
   2692            /* Return function status */
   2693            return HAL_OK;
   \                     ??HAL_TIM_Encoder_Start_DMA_6: (+1)
   \   00000144   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_Encoder_Start_DMA_0: (+1)
   \   00000146   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   2694          }
   2695          
   2696          /**
   2697            * @brief  Stops the TIM Encoder Interface in DMA mode.
   2698            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   2699            *                the configuration information for TIM module.
   2700            * @param  Channel: TIM Channels to be enabled.
   2701            *          This parameter can be one of the following values:
   2702            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2703            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2704            *            @arg TIM_CHANNEL_ALL: TIM Channel 1 and TIM Channel 2 are selected
   2705            * @retval HAL status
   2706            */

   \                                 In section .text, align 2, keep-with-next
   2707          HAL_StatusTypeDef HAL_TIM_Encoder_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
   2708          {
   2709            /* Check the parameters */
   2710            assert_param(IS_TIM_DMA_CC_INSTANCE(htim->Instance));
   2711            
   2712            /* Disable the Input Capture channels 1 and 2
   2713              (in the EncoderInterface the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2) */ 
   2714            if(Channel == TIM_CHANNEL_1)
   \                     HAL_TIM_Encoder_Stop_DMA: (+1)
   \   00000000   0xB959             CBNZ.N   R1,??HAL_TIM_Encoder_Stop_DMA_0
   2715            {
   2716              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE); 
   \   00000002   0x6801             LDR      R1,[R0, #+0]
   \   00000004   0x6A0A             LDR      R2,[R1, #+32]
   \   00000006   0x0852             LSRS     R2,R2,#+1
   \   00000008   0x0052             LSLS     R2,R2,#+1
   \   0000000A   0x620A             STR      R2,[R1, #+32]
   \   0000000C   0x6A0A             LDR      R2,[R1, #+32]
   \   0000000E   0x620A             STR      R2,[R1, #+32]
   2717              
   2718              /* Disable the capture compare DMA Request 1 */
   2719              __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
   \   00000010   0x6801             LDR      R1,[R0, #+0]
   \   00000012   0x68CA             LDR      R2,[R1, #+12]
   \   00000014   0xF422 0x7200      BIC      R2,R2,#0x200
   \   00000018   0xE01E             B.N      ??HAL_TIM_Encoder_Stop_DMA_1
   2720            }  
   2721            else if(Channel == TIM_CHANNEL_2)
   \                     ??HAL_TIM_Encoder_Stop_DMA_0: (+1)
   \   0000001A   0x2904             CMP      R1,#+4
   \   0000001C   0x6801             LDR      R1,[R0, #+0]
   \   0000001E   0x6A0A             LDR      R2,[R1, #+32]
   \   00000020   0xD105             BNE.N    ??HAL_TIM_Encoder_Stop_DMA_2
   2722            {  
   2723              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE); 
   \   00000022   0xF022 0x0210      BIC      R2,R2,#0x10
   \   00000026   0x620A             STR      R2,[R1, #+32]
   \   00000028   0x6A0A             LDR      R2,[R1, #+32]
   \   0000002A   0x620A             STR      R2,[R1, #+32]
   2724              
   2725              /* Disable the capture compare DMA Request 2 */
   2726              __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
   \   0000002C   0xE010             B.N      ??HAL_TIM_Encoder_Stop_DMA_3
   2727            }  
   2728            else
   2729            {
   2730              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE); 
   \                     ??HAL_TIM_Encoder_Stop_DMA_2: (+1)
   \   0000002E   0x0852             LSRS     R2,R2,#+1
   \   00000030   0x0052             LSLS     R2,R2,#+1
   \   00000032   0x620A             STR      R2,[R1, #+32]
   \   00000034   0x6A0A             LDR      R2,[R1, #+32]
   \   00000036   0x620A             STR      R2,[R1, #+32]
   2731              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE); 
   \   00000038   0x6801             LDR      R1,[R0, #+0]
   \   0000003A   0x6A0A             LDR      R2,[R1, #+32]
   \   0000003C   0xF022 0x0210      BIC      R2,R2,#0x10
   \   00000040   0x620A             STR      R2,[R1, #+32]
   \   00000042   0x6A0A             LDR      R2,[R1, #+32]
   \   00000044   0x620A             STR      R2,[R1, #+32]
   2732              
   2733              /* Disable the capture compare DMA Request 1 and 2 */
   2734              __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
   \   00000046   0x6801             LDR      R1,[R0, #+0]
   \   00000048   0x68CA             LDR      R2,[R1, #+12]
   \   0000004A   0xF422 0x7200      BIC      R2,R2,#0x200
   \   0000004E   0x60CA             STR      R2,[R1, #+12]
   2735              __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
   \                     ??HAL_TIM_Encoder_Stop_DMA_3: (+1)
   \   00000050   0x6801             LDR      R1,[R0, #+0]
   \   00000052   0x68CA             LDR      R2,[R1, #+12]
   \   00000054   0xF422 0x6280      BIC      R2,R2,#0x400
   \                     ??HAL_TIM_Encoder_Stop_DMA_1: (+1)
   \   00000058   0x60CA             STR      R2,[R1, #+12]
   2736            }
   2737            
   2738            /* Disable the Peripheral */
   2739            __HAL_TIM_DISABLE(htim);
   \   0000005A   0x6801             LDR      R1,[R0, #+0]
   \   0000005C   0xF241 0x1311      MOVW     R3,#+4369
   \   00000060   0x6A0A             LDR      R2,[R1, #+32]
   \   00000062   0x421A             TST      R2,R3
   \   00000064   0xBF02             ITTT     EQ 
   \   00000066   0x6A0A             LDREQ    R2,[R1, #+32]
   \   00000068   0xF240 0x4344      MOVWEQ   R3,#+1092
   \   0000006C   0x421A             TSTEQ    R2,R3
   \   0000006E   0xD103             BNE.N    ??HAL_TIM_Encoder_Stop_DMA_4
   \   00000070   0x680A             LDR      R2,[R1, #+0]
   \   00000072   0x0852             LSRS     R2,R2,#+1
   \   00000074   0x0052             LSLS     R2,R2,#+1
   \   00000076   0x600A             STR      R2,[R1, #+0]
   2740            
   2741            /* Change the htim state */
   2742            htim->State = HAL_TIM_STATE_READY;
   \                     ??HAL_TIM_Encoder_Stop_DMA_4: (+1)
   \   00000078   0x2101             MOVS     R1,#+1
   \   0000007A   0xF880 0x1039      STRB     R1,[R0, #+57]
   2743            
   2744            /* Return function status */
   2745            return HAL_OK;
   \   0000007E   0x2000             MOVS     R0,#+0
   \   00000080   0x4770             BX       LR               ;; return
   2746          }
   2747          
   2748          /**
   2749            * @}
   2750            */
   2751          /** @defgroup TIM_Exported_Functions_Group7 TIM IRQ handler management 
   2752           *  @brief    IRQ handler management 
   2753           *
   2754          @verbatim   
   2755            ==============================================================================
   2756                                  ##### IRQ handler management #####
   2757            ==============================================================================  
   2758            [..]  
   2759              This section provides Timer IRQ handler function.
   2760                         
   2761          @endverbatim
   2762            * @{
   2763            */
   2764          /**
   2765            * @brief  This function handles TIM interrupts requests.
   2766            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   2767            *                the configuration information for TIM module.
   2768            * @retval None
   2769            */

   \                                 In section .text, align 2, keep-with-next
   2770          void HAL_TIM_IRQHandler(TIM_HandleTypeDef *htim)
   2771          {
   \                     HAL_TIM_IRQHandler: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   2772            /* Capture compare 1 event */
   2773            if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC1) != RESET)
   \   00000004   0x6820             LDR      R0,[R4, #+0]
   \   00000006   0x6901             LDR      R1,[R0, #+16]
   \   00000008   0x0789             LSLS     R1,R1,#+30
   \   0000000A   0xD516             BPL.N    ??HAL_TIM_IRQHandler_0
   2774            {
   2775              if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC1) !=RESET)
   \   0000000C   0x68C1             LDR      R1,[R0, #+12]
   \   0000000E   0x0789             LSLS     R1,R1,#+30
   \   00000010   0xD513             BPL.N    ??HAL_TIM_IRQHandler_0
   2776              {
   2777                {
   2778                  __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC1);
   \   00000012   0xF06F 0x0102      MVN      R1,#+2
   \   00000016   0x6101             STR      R1,[R0, #+16]
   2779                  htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
   \   00000018   0x2101             MOVS     R1,#+1
   \   0000001A   0x7621             STRB     R1,[R4, #+24]
   2780                  
   2781                  /* Input capture event */
   2782                  if((htim->Instance->CCMR1 & TIM_CCMR1_CC1S) != 0x00)
   \   0000001C   0x6980             LDR      R0,[R0, #+24]
   \   0000001E   0xF010 0x0F03      TST      R0,#0x3
   \   00000022   0x4620             MOV      R0,R4
   \   00000024   0xD002             BEQ.N    ??HAL_TIM_IRQHandler_1
   2783                  {
   2784                    HAL_TIM_IC_CaptureCallback(htim);
   \   00000026   0x.... 0x....      BL       HAL_TIM_IC_CaptureCallback
   \   0000002A   0xE004             B.N      ??HAL_TIM_IRQHandler_2
   2785                  }
   2786                  /* Output compare event */
   2787                  else
   2788                  {
   2789                    HAL_TIM_OC_DelayElapsedCallback(htim);
   \                     ??HAL_TIM_IRQHandler_1: (+1)
   \   0000002C   0x.... 0x....      BL       HAL_TIM_OC_DelayElapsedCallback
   2790                    HAL_TIM_PWM_PulseFinishedCallback(htim);
   \   00000030   0x4620             MOV      R0,R4
   \   00000032   0x.... 0x....      BL       HAL_TIM_PWM_PulseFinishedCallback
   2791                  }
   2792                  htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
   \                     ??HAL_TIM_IRQHandler_2: (+1)
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0x7620             STRB     R0,[R4, #+24]
   2793                }
   2794              }
   2795            }
   2796            /* Capture compare 2 event */
   2797            if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC2) != RESET)
   \                     ??HAL_TIM_IRQHandler_0: (+1)
   \   0000003A   0x6820             LDR      R0,[R4, #+0]
   \   0000003C   0x6901             LDR      R1,[R0, #+16]
   \   0000003E   0x0749             LSLS     R1,R1,#+29
   \   00000040   0xD516             BPL.N    ??HAL_TIM_IRQHandler_3
   2798            {
   2799              if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC2) !=RESET)
   \   00000042   0x68C1             LDR      R1,[R0, #+12]
   \   00000044   0x0749             LSLS     R1,R1,#+29
   \   00000046   0xD513             BPL.N    ??HAL_TIM_IRQHandler_3
   2800              {
   2801                __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC2);
   \   00000048   0xF06F 0x0104      MVN      R1,#+4
   \   0000004C   0x6101             STR      R1,[R0, #+16]
   2802                htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
   \   0000004E   0x2102             MOVS     R1,#+2
   \   00000050   0x7621             STRB     R1,[R4, #+24]
   2803                /* Input capture event */
   2804                if((htim->Instance->CCMR1 & TIM_CCMR1_CC2S) != 0x00)
   \   00000052   0x6980             LDR      R0,[R0, #+24]
   \   00000054   0xF410 0x7F40      TST      R0,#0x300
   \   00000058   0x4620             MOV      R0,R4
   \   0000005A   0xD002             BEQ.N    ??HAL_TIM_IRQHandler_4
   2805                {          
   2806                  HAL_TIM_IC_CaptureCallback(htim);
   \   0000005C   0x.... 0x....      BL       HAL_TIM_IC_CaptureCallback
   \   00000060   0xE004             B.N      ??HAL_TIM_IRQHandler_5
   2807                }
   2808                /* Output compare event */
   2809                else
   2810                {
   2811                  HAL_TIM_OC_DelayElapsedCallback(htim);
   \                     ??HAL_TIM_IRQHandler_4: (+1)
   \   00000062   0x.... 0x....      BL       HAL_TIM_OC_DelayElapsedCallback
   2812                  HAL_TIM_PWM_PulseFinishedCallback(htim);
   \   00000066   0x4620             MOV      R0,R4
   \   00000068   0x.... 0x....      BL       HAL_TIM_PWM_PulseFinishedCallback
   2813                }
   2814                htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
   \                     ??HAL_TIM_IRQHandler_5: (+1)
   \   0000006C   0x2000             MOVS     R0,#+0
   \   0000006E   0x7620             STRB     R0,[R4, #+24]
   2815              }
   2816            }
   2817            /* Capture compare 3 event */
   2818            if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC3) != RESET)
   \                     ??HAL_TIM_IRQHandler_3: (+1)
   \   00000070   0x6820             LDR      R0,[R4, #+0]
   \   00000072   0x6901             LDR      R1,[R0, #+16]
   \   00000074   0x0709             LSLS     R1,R1,#+28
   \   00000076   0xD516             BPL.N    ??HAL_TIM_IRQHandler_6
   2819            {
   2820              if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC3) !=RESET)
   \   00000078   0x68C1             LDR      R1,[R0, #+12]
   \   0000007A   0x0709             LSLS     R1,R1,#+28
   \   0000007C   0xD513             BPL.N    ??HAL_TIM_IRQHandler_6
   2821              {
   2822                __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC3);
   \   0000007E   0xF06F 0x0108      MVN      R1,#+8
   \   00000082   0x6101             STR      R1,[R0, #+16]
   2823                htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
   \   00000084   0x2104             MOVS     R1,#+4
   \   00000086   0x7621             STRB     R1,[R4, #+24]
   2824                /* Input capture event */
   2825                if((htim->Instance->CCMR2 & TIM_CCMR2_CC3S) != 0x00)
   \   00000088   0x69C0             LDR      R0,[R0, #+28]
   \   0000008A   0xF010 0x0F03      TST      R0,#0x3
   \   0000008E   0x4620             MOV      R0,R4
   \   00000090   0xD002             BEQ.N    ??HAL_TIM_IRQHandler_7
   2826                {          
   2827                  HAL_TIM_IC_CaptureCallback(htim);
   \   00000092   0x.... 0x....      BL       HAL_TIM_IC_CaptureCallback
   \   00000096   0xE004             B.N      ??HAL_TIM_IRQHandler_8
   2828                }
   2829                /* Output compare event */
   2830                else
   2831                {
   2832                  HAL_TIM_OC_DelayElapsedCallback(htim);
   \                     ??HAL_TIM_IRQHandler_7: (+1)
   \   00000098   0x.... 0x....      BL       HAL_TIM_OC_DelayElapsedCallback
   2833                  HAL_TIM_PWM_PulseFinishedCallback(htim); 
   \   0000009C   0x4620             MOV      R0,R4
   \   0000009E   0x.... 0x....      BL       HAL_TIM_PWM_PulseFinishedCallback
   2834                }
   2835                htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
   \                     ??HAL_TIM_IRQHandler_8: (+1)
   \   000000A2   0x2000             MOVS     R0,#+0
   \   000000A4   0x7620             STRB     R0,[R4, #+24]
   2836              }
   2837            }
   2838            /* Capture compare 4 event */
   2839            if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC4) != RESET)
   \                     ??HAL_TIM_IRQHandler_6: (+1)
   \   000000A6   0x6820             LDR      R0,[R4, #+0]
   \   000000A8   0x6901             LDR      R1,[R0, #+16]
   \   000000AA   0x06C9             LSLS     R1,R1,#+27
   \   000000AC   0xD516             BPL.N    ??HAL_TIM_IRQHandler_9
   2840            {
   2841              if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC4) !=RESET)
   \   000000AE   0x68C1             LDR      R1,[R0, #+12]
   \   000000B0   0x06C9             LSLS     R1,R1,#+27
   \   000000B2   0xD513             BPL.N    ??HAL_TIM_IRQHandler_9
   2842              {
   2843                __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC4);
   \   000000B4   0xF06F 0x0110      MVN      R1,#+16
   \   000000B8   0x6101             STR      R1,[R0, #+16]
   2844                htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
   \   000000BA   0x2108             MOVS     R1,#+8
   \   000000BC   0x7621             STRB     R1,[R4, #+24]
   2845                /* Input capture event */
   2846                if((htim->Instance->CCMR2 & TIM_CCMR2_CC4S) != 0x00)
   \   000000BE   0x69C0             LDR      R0,[R0, #+28]
   \   000000C0   0xF410 0x7F40      TST      R0,#0x300
   \   000000C4   0x4620             MOV      R0,R4
   \   000000C6   0xD002             BEQ.N    ??HAL_TIM_IRQHandler_10
   2847                {          
   2848                  HAL_TIM_IC_CaptureCallback(htim);
   \   000000C8   0x.... 0x....      BL       HAL_TIM_IC_CaptureCallback
   \   000000CC   0xE004             B.N      ??HAL_TIM_IRQHandler_11
   2849                }
   2850                /* Output compare event */
   2851                else
   2852                {
   2853                  HAL_TIM_OC_DelayElapsedCallback(htim);
   \                     ??HAL_TIM_IRQHandler_10: (+1)
   \   000000CE   0x.... 0x....      BL       HAL_TIM_OC_DelayElapsedCallback
   2854                  HAL_TIM_PWM_PulseFinishedCallback(htim);
   \   000000D2   0x4620             MOV      R0,R4
   \   000000D4   0x.... 0x....      BL       HAL_TIM_PWM_PulseFinishedCallback
   2855                }
   2856                htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
   \                     ??HAL_TIM_IRQHandler_11: (+1)
   \   000000D8   0x2000             MOVS     R0,#+0
   \   000000DA   0x7620             STRB     R0,[R4, #+24]
   2857              }
   2858            }
   2859            /* TIM Update event */
   2860            if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_UPDATE) != RESET)
   \                     ??HAL_TIM_IRQHandler_9: (+1)
   \   000000DC   0x6820             LDR      R0,[R4, #+0]
   \   000000DE   0x6901             LDR      R1,[R0, #+16]
   \   000000E0   0x07C9             LSLS     R1,R1,#+31
   \   000000E2   0xD508             BPL.N    ??HAL_TIM_IRQHandler_12
   2861            {
   2862              if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_UPDATE) !=RESET)
   \   000000E4   0x68C1             LDR      R1,[R0, #+12]
   \   000000E6   0x07C9             LSLS     R1,R1,#+31
   \   000000E8   0xD505             BPL.N    ??HAL_TIM_IRQHandler_12
   2863              {
   2864                __HAL_TIM_CLEAR_IT(htim, TIM_IT_UPDATE);
   \   000000EA   0xF06F 0x0101      MVN      R1,#+1
   \   000000EE   0x6101             STR      R1,[R0, #+16]
   2865                HAL_TIM_PeriodElapsedCallback(htim);
   \   000000F0   0x4620             MOV      R0,R4
   \   000000F2   0x.... 0x....      BL       HAL_TIM_PeriodElapsedCallback
   2866              }
   2867            }
   2868            /* TIM Break input event */
   2869            if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_BREAK) != RESET)
   \                     ??HAL_TIM_IRQHandler_12: (+1)
   \   000000F6   0x6820             LDR      R0,[R4, #+0]
   \   000000F8   0x6901             LDR      R1,[R0, #+16]
   \   000000FA   0x0609             LSLS     R1,R1,#+24
   \   000000FC   0xD508             BPL.N    ??HAL_TIM_IRQHandler_13
   2870            {
   2871              if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_BREAK) !=RESET)
   \   000000FE   0x68C1             LDR      R1,[R0, #+12]
   \   00000100   0x0609             LSLS     R1,R1,#+24
   \   00000102   0xD505             BPL.N    ??HAL_TIM_IRQHandler_13
   2872              {
   2873                __HAL_TIM_CLEAR_IT(htim, TIM_IT_BREAK);
   \   00000104   0xF06F 0x0180      MVN      R1,#+128
   \   00000108   0x6101             STR      R1,[R0, #+16]
   2874                HAL_TIMEx_BreakCallback(htim);
   \   0000010A   0x4620             MOV      R0,R4
   \   0000010C   0x.... 0x....      BL       HAL_TIMEx_BreakCallback
   2875              }
   2876            }
   2877            
   2878              /* TIM Break input event */
   2879            if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_BREAK2) != RESET)
   \                     ??HAL_TIM_IRQHandler_13: (+1)
   \   00000110   0x6820             LDR      R0,[R4, #+0]
   \   00000112   0x6901             LDR      R1,[R0, #+16]
   \   00000114   0x05C9             LSLS     R1,R1,#+23
   \   00000116   0xD508             BPL.N    ??HAL_TIM_IRQHandler_14
   2880            {
   2881              if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_BREAK) !=RESET)
   \   00000118   0x68C1             LDR      R1,[R0, #+12]
   \   0000011A   0x0609             LSLS     R1,R1,#+24
   \   0000011C   0xD505             BPL.N    ??HAL_TIM_IRQHandler_14
   2882              {
   2883                __HAL_TIM_CLEAR_IT(htim, TIM_IT_BREAK);
   \   0000011E   0xF06F 0x0180      MVN      R1,#+128
   \   00000122   0x6101             STR      R1,[R0, #+16]
   2884                HAL_TIMEx_BreakCallback(htim);
   \   00000124   0x4620             MOV      R0,R4
   \   00000126   0x.... 0x....      BL       HAL_TIMEx_BreakCallback
   2885              }
   2886            }
   2887          
   2888            /* TIM Trigger detection event */
   2889            if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_TRIGGER) != RESET)
   \                     ??HAL_TIM_IRQHandler_14: (+1)
   \   0000012A   0x6820             LDR      R0,[R4, #+0]
   \   0000012C   0x6901             LDR      R1,[R0, #+16]
   \   0000012E   0x0649             LSLS     R1,R1,#+25
   \   00000130   0xD508             BPL.N    ??HAL_TIM_IRQHandler_15
   2890            {
   2891              if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_TRIGGER) !=RESET)
   \   00000132   0x68C1             LDR      R1,[R0, #+12]
   \   00000134   0x0649             LSLS     R1,R1,#+25
   \   00000136   0xD505             BPL.N    ??HAL_TIM_IRQHandler_15
   2892              {
   2893                __HAL_TIM_CLEAR_IT(htim, TIM_IT_TRIGGER);
   \   00000138   0xF06F 0x0140      MVN      R1,#+64
   \   0000013C   0x6101             STR      R1,[R0, #+16]
   2894                HAL_TIM_TriggerCallback(htim);
   \   0000013E   0x4620             MOV      R0,R4
   \   00000140   0x.... 0x....      BL       HAL_TIM_TriggerCallback
   2895              }
   2896            }
   2897            /* TIM commutation event */
   2898            if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_COM) != RESET)
   \                     ??HAL_TIM_IRQHandler_15: (+1)
   \   00000144   0x6820             LDR      R0,[R4, #+0]
   \   00000146   0x6901             LDR      R1,[R0, #+16]
   \   00000148   0x0689             LSLS     R1,R1,#+26
   \   0000014A   0xD50A             BPL.N    ??HAL_TIM_IRQHandler_16
   2899            {
   2900              if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_COM) !=RESET)
   \   0000014C   0x68C1             LDR      R1,[R0, #+12]
   \   0000014E   0x0689             LSLS     R1,R1,#+26
   \   00000150   0xD507             BPL.N    ??HAL_TIM_IRQHandler_16
   2901              {
   2902                __HAL_TIM_CLEAR_IT(htim, TIM_FLAG_COM);
   \   00000152   0xF06F 0x0120      MVN      R1,#+32
   \   00000156   0x6101             STR      R1,[R0, #+16]
   2903                HAL_TIMEx_CommutationCallback(htim);
   \   00000158   0x4620             MOV      R0,R4
   \   0000015A   0xE8BD 0x4010      POP      {R4,LR}
   \   0000015E   0x.... 0x....      B.W      HAL_TIMEx_CommutationCallback
   2904              }
   2905            }
   2906          }
   \                     ??HAL_TIM_IRQHandler_16: (+1)
   \   00000162   0xBD10             POP      {R4,PC}          ;; return
   2907          
   2908          /**
   2909            * @}
   2910            */
   2911            
   2912          /** @defgroup TIM_Exported_Functions_Group8 Peripheral Control functions
   2913           *  @brief   	Peripheral Control functions 
   2914           *
   2915          @verbatim   
   2916            ==============================================================================
   2917                             ##### Peripheral Control functions #####
   2918            ==============================================================================  
   2919           [..] 
   2920             This section provides functions allowing to:
   2921             (+) Configure The Input Output channels for OC, PWM, IC or One Pulse mode. 
   2922             (+) Configure External Clock source.
   2923             (+) Configure Complementary channels, break features and dead time.
   2924             (+) Configure Master and the Slave synchronization.
   2925             (+) Configure the DMA Burst Mode.
   2926                
   2927          @endverbatim
   2928            * @{
   2929            */
   2930            
   2931          /**
   2932            * @brief  Initializes the TIM Output Compare Channels according to the specified
   2933            *         parameters in the TIM_OC_InitTypeDef.
   2934            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   2935            *                the configuration information for TIM module.
   2936            * @param  sConfig: TIM Output Compare configuration structure
   2937            * @param  Channel: TIM Channels to be enabled.
   2938            *          This parameter can be one of the following values:
   2939            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2940            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2941            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   2942            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected 
   2943            * @retval HAL status
   2944            */

   \                                 In section .text, align 4, keep-with-next
   2945          __weak HAL_StatusTypeDef HAL_TIM_OC_ConfigChannel(TIM_HandleTypeDef *htim, TIM_OC_InitTypeDef* sConfig, uint32_t Channel)
   2946          {
   \                     HAL_TIM_OC_ConfigChannel: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   2947            /* Check the parameters */ 
   2948            assert_param(IS_TIM_CHANNELS(Channel)); 
   2949            assert_param(IS_TIM_OC_MODE(sConfig->OCMode));
   2950            assert_param(IS_TIM_OC_POLARITY(sConfig->OCPolarity));
   2951            assert_param(IS_TIM_OCN_POLARITY(sConfig->OCNPolarity));
   2952            assert_param(IS_TIM_OCNIDLE_STATE(sConfig->OCNIdleState));
   2953            assert_param(IS_TIM_OCIDLE_STATE(sConfig->OCIdleState));
   2954            
   2955            /* Check input state */
   2956            __HAL_LOCK(htim); 
   \   00000004   0xF894 0x0038      LDRB     R0,[R4, #+56]
   \   00000008   0x2801             CMP      R0,#+1
   \   0000000A   0xD101             BNE.N    ??HAL_TIM_OC_ConfigChannel_1
   \   0000000C   0x2002             MOVS     R0,#+2
   \   0000000E   0xBD10             POP      {R4,PC}
   \                     ??HAL_TIM_OC_ConfigChannel_1: (+1)
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0xF884 0x0038      STRB     R0,[R4, #+56]
   2957            
   2958            htim->State = HAL_TIM_STATE_BUSY;
   \   00000016   0x2002             MOVS     R0,#+2
   2959            
   2960            switch (Channel)
   \   00000018   0x2A0C             CMP      R2,#+12
   \   0000001A   0xF884 0x0039      STRB     R0,[R4, #+57]
   \   0000001E   0xD817             BHI.N    ??HAL_TIM_OC_ConfigChannel_2
   \   00000020   0xE8DF 0xF002      TBB      [PC, R2]
   \                     ??HAL_TIM_OC_ConfigChannel_0:
   \   00000024   0x07 0x16          DC8      0x7,0x16,0x16,0x16
   \              0x16 0x16    
   \   00000028   0x0B 0x16          DC8      0xB,0x16,0x16,0x16
   \              0x16 0x16    
   \   0000002C   0x0F 0x16          DC8      0xF,0x16,0x16,0x16
   \              0x16 0x16    
   \   00000030   0x13 0x00          DC8      0x13,0x0
   2961            {
   2962              case TIM_CHANNEL_1:
   2963              {
   2964                assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   2965                /* Configure the TIM Channel 1 in Output Compare */
   2966                TIM_OC1_SetConfig(htim->Instance, sConfig);
   \                     ??HAL_TIM_OC_ConfigChannel_3: (+1)
   \   00000032   0x6820             LDR      R0,[R4, #+0]
   \   00000034   0x.... 0x....      BL       TIM_OC1_SetConfig
   2967              }
   2968              break;
   \   00000038   0xE00A             B.N      ??HAL_TIM_OC_ConfigChannel_2
   2969              
   2970              case TIM_CHANNEL_2:
   2971              {
   2972                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   2973                /* Configure the TIM Channel 2 in Output Compare */
   2974                TIM_OC2_SetConfig(htim->Instance, sConfig);
   \                     ??HAL_TIM_OC_ConfigChannel_4: (+1)
   \   0000003A   0x6820             LDR      R0,[R4, #+0]
   \   0000003C   0x.... 0x....      BL       TIM_OC2_SetConfig
   2975              }
   2976              break;
   \   00000040   0xE006             B.N      ??HAL_TIM_OC_ConfigChannel_2
   2977              
   2978              case TIM_CHANNEL_3:
   2979              {
   2980                 assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
   2981                /* Configure the TIM Channel 3 in Output Compare */
   2982                TIM_OC3_SetConfig(htim->Instance, sConfig);
   \                     ??HAL_TIM_OC_ConfigChannel_5: (+1)
   \   00000042   0x6820             LDR      R0,[R4, #+0]
   \   00000044   0x.... 0x....      BL       TIM_OC3_SetConfig
   2983              }
   2984              break;
   \   00000048   0xE002             B.N      ??HAL_TIM_OC_ConfigChannel_2
   2985              
   2986              case TIM_CHANNEL_4:
   2987              {
   2988                assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
   2989                /* Configure the TIM Channel 4 in Output Compare */
   2990                TIM_OC4_SetConfig(htim->Instance, sConfig);
   \                     ??HAL_TIM_OC_ConfigChannel_6: (+1)
   \   0000004A   0x6820             LDR      R0,[R4, #+0]
   \   0000004C   0x.... 0x....      BL       TIM_OC4_SetConfig
   2991              }
   2992              break;
   2993              
   2994              default:
   2995              break;    
   2996            }
   2997            htim->State = HAL_TIM_STATE_READY;
   \                     ??HAL_TIM_OC_ConfigChannel_2: (+1)
   \   00000050   0x2001             MOVS     R0,#+1
   \   00000052   0xF884 0x0039      STRB     R0,[R4, #+57]
   2998            
   2999            __HAL_UNLOCK(htim); 
   \   00000056   0x2000             MOVS     R0,#+0
   \   00000058   0xF884 0x0038      STRB     R0,[R4, #+56]
   3000            
   3001            return HAL_OK;
   \   0000005C   0xBD10             POP      {R4,PC}          ;; return
   3002          }
   3003          
   3004          /**
   3005            * @brief  Initializes the TIM Input Capture Channels according to the specified
   3006            *         parameters in the TIM_IC_InitTypeDef.
   3007            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   3008            *                the configuration information for TIM module.
   3009            * @param  sConfig: TIM Input Capture configuration structure
   3010            * @param  Channel: TIM Channels to be enabled.
   3011            *          This parameter can be one of the following values:
   3012            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   3013            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   3014            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   3015            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected 
   3016            * @retval HAL status
   3017            */

   \                                 In section .text, align 2, keep-with-next
   3018          HAL_StatusTypeDef HAL_TIM_IC_ConfigChannel(TIM_HandleTypeDef *htim, TIM_IC_InitTypeDef* sConfig, uint32_t Channel)
   3019          {
   \                     HAL_TIM_IC_ConfigChannel: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   3020            /* Check the parameters */
   3021            assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   3022            assert_param(IS_TIM_IC_POLARITY(sConfig->ICPolarity));
   3023            assert_param(IS_TIM_IC_SELECTION(sConfig->ICSelection));
   3024            assert_param(IS_TIM_IC_PRESCALER(sConfig->ICPrescaler));
   3025            assert_param(IS_TIM_IC_FILTER(sConfig->ICFilter));
   3026            
   3027            __HAL_LOCK(htim);
   \   00000002   0xF890 0x3038      LDRB     R3,[R0, #+56]
   \   00000006   0x2B01             CMP      R3,#+1
   \   00000008   0xD101             BNE.N    ??HAL_TIM_IC_ConfigChannel_0
   \   0000000A   0x2002             MOVS     R0,#+2
   \   0000000C   0xBDF0             POP      {R4-R7,PC}
   \                     ??HAL_TIM_IC_ConfigChannel_0: (+1)
   \   0000000E   0x2301             MOVS     R3,#+1
   \   00000010   0xF880 0x3038      STRB     R3,[R0, #+56]
   3028            
   3029            htim->State = HAL_TIM_STATE_BUSY;
   \   00000014   0x2302             MOVS     R3,#+2
   3030            
   3031            if (Channel == TIM_CHANNEL_1)
   \   00000016   0x2A00             CMP      R2,#+0
   \   00000018   0xF880 0x3039      STRB     R3,[R0, #+57]
   \   0000001C   0xD149             BNE.N    ??HAL_TIM_IC_ConfigChannel_1
   3032            {
   3033              /* TI1 Configuration */
   3034              TIM_TI1_SetConfig(htim->Instance,
   3035                         sConfig->ICPolarity,
   3036                         sConfig->ICSelection,
   3037                         sConfig->ICFilter);
   \   0000001E   0x6805             LDR      R5,[R0, #+0]
   \   00000020   0x68CB             LDR      R3,[R1, #+12]
   \   00000022   0x684E             LDR      R6,[R1, #+4]
   \   00000024   0x680C             LDR      R4,[R1, #+0]
   \   00000026   0x.... 0x....      LDR.W    LR,??DataTable32  ;; 0x40010000
   \   0000002A   0x6A2A             LDR      R2,[R5, #+32]
   \   0000002C   0x0852             LSRS     R2,R2,#+1
   \   0000002E   0x0052             LSLS     R2,R2,#+1
   \   00000030   0x622A             STR      R2,[R5, #+32]
   \   00000032   0xF105 0x0218      ADD      R2,R5,#+24
   \   00000036   0x4575             CMP      R5,LR
   \   00000038   0xF8D2 0xC000      LDR      R12,[R2, #+0]
   \   0000003C   0x6A2F             LDR      R7,[R5, #+32]
   \   0000003E   0xBF18             IT       NE 
   \   00000040   0xF1B5 0x4F80      CMPNE    R5,#+1073741824
   \   00000044   0xD019             BEQ.N    ??HAL_TIM_IC_ConfigChannel_2
   \   00000046   0x.... 0x....      LDR.W    LR,??DataTable32_1  ;; 0x40000400
   \   0000004A   0x4575             CMP      R5,LR
   \   0000004C   0xBF1C             ITT      NE 
   \   0000004E   0x.... 0x....      LDRNE.W  LR,??DataTable32_2  ;; 0x40000800
   \   00000052   0x4575             CMPNE    R5,LR
   \   00000054   0xD011             BEQ.N    ??HAL_TIM_IC_ConfigChannel_2
   \   00000056   0x.... 0x....      LDR.W    LR,??DataTable32_3  ;; 0x40000c00
   \   0000005A   0x4575             CMP      R5,LR
   \   0000005C   0xBF1C             ITT      NE 
   \   0000005E   0x.... 0x....      LDRNE.W  LR,??DataTable27  ;; 0x40010400
   \   00000062   0x4575             CMPNE    R5,LR
   \   00000064   0xD009             BEQ.N    ??HAL_TIM_IC_ConfigChannel_2
   \   00000066   0x.... 0x....      LDR.W    LR,??DataTable26  ;; 0x40014000
   \   0000006A   0x4575             CMP      R5,LR
   \   0000006C   0xBF1E             ITTT     NE 
   \   0000006E   0x.... 0x....      LDRNE.W  LR,??DataTable26_3  ;; 0x40001800
   \   00000072   0x4575             CMPNE    R5,LR
   \   00000074   0xF04C 0x0601      ORRNE    R6,R12,#0x1
   \   00000078   0xD103             BNE.N    ??HAL_TIM_IC_ConfigChannel_3
   \                     ??HAL_TIM_IC_ConfigChannel_2: (+1)
   \   0000007A   0xEA4F 0x0C9C      LSR      R12,R12,#+2
   \   0000007E   0xEA46 0x068C      ORR      R6,R6,R12, LSL #+2
   \                     ??HAL_TIM_IC_ConfigChannel_3: (+1)
   \   00000082   0x011B             LSLS     R3,R3,#+4
   \   00000084   0xF026 0x06F0      BIC      R6,R6,#0xF0
   \   00000088   0xF003 0x03F0      AND      R3,R3,#0xF0
   \   0000008C   0x4333             ORRS     R3,R3,R6
   \   0000008E   0x6013             STR      R3,[R2, #+0]
   \   00000090   0xF027 0x020A      BIC      R2,R7,#0xA
   \   00000094   0xF004 0x030A      AND      R3,R4,#0xA
   \   00000098   0x431A             ORRS     R2,R3,R2
   \   0000009A   0x622A             STR      R2,[R5, #+32]
   3038                         
   3039              /* Reset the IC1PSC Bits */
   3040              htim->Instance->CCMR1 &= ~TIM_CCMR1_IC1PSC;
   \   0000009C   0x6802             LDR      R2,[R0, #+0]
   \   0000009E   0x6993             LDR      R3,[R2, #+24]
   \   000000A0   0xF023 0x030C      BIC      R3,R3,#0xC
   \   000000A4   0x6193             STR      R3,[R2, #+24]
   3041          
   3042              /* Set the IC1PSC value */
   3043              htim->Instance->CCMR1 |= sConfig->ICPrescaler;
   \   000000A6   0x6802             LDR      R2,[R0, #+0]
   \   000000A8   0x6993             LDR      R3,[R2, #+24]
   \   000000AA   0x6889             LDR      R1,[R1, #+8]
   \   000000AC   0x4319             ORRS     R1,R1,R3
   \   000000AE   0x6191             STR      R1,[R2, #+24]
   \   000000B0   0xE076             B.N      ??HAL_TIM_IC_ConfigChannel_4
   3044            }
   3045            else if (Channel == TIM_CHANNEL_2)
   \                     ??HAL_TIM_IC_ConfigChannel_1: (+1)
   \   000000B2   0x2A04             CMP      R2,#+4
   \   000000B4   0xD128             BNE.N    ??HAL_TIM_IC_ConfigChannel_5
   3046            {
   3047              /* TI2 Configuration */
   3048              assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   3049              
   3050              TIM_TI2_SetConfig(htim->Instance, 
   3051                                sConfig->ICPolarity,
   3052                                sConfig->ICSelection,
   3053                                sConfig->ICFilter);
   \   000000B6   0x6802             LDR      R2,[R0, #+0]
   \   000000B8   0x68CC             LDR      R4,[R1, #+12]
   \   000000BA   0x684D             LDR      R5,[R1, #+4]
   \   000000BC   0x680B             LDR      R3,[R1, #+0]
   \   000000BE   0x3218             ADDS     R2,R2,#+24
   \   000000C0   0x0324             LSLS     R4,R4,#+12
   \   000000C2   0xF404 0x4470      AND      R4,R4,#0xF000
   \   000000C6   0x011B             LSLS     R3,R3,#+4
   \   000000C8   0x6896             LDR      R6,[R2, #+8]
   \   000000CA   0xF003 0x03A0      AND      R3,R3,#0xA0
   \   000000CE   0xF026 0x0610      BIC      R6,R6,#0x10
   \   000000D2   0x6096             STR      R6,[R2, #+8]
   \   000000D4   0x6816             LDR      R6,[R2, #+0]
   \   000000D6   0x6897             LDR      R7,[R2, #+8]
   \   000000D8   0xF426 0x7640      BIC      R6,R6,#0x300
   \   000000DC   0xEA46 0x2505      ORR      R5,R6,R5, LSL #+8
   \   000000E0   0xF425 0x4570      BIC      R5,R5,#0xF000
   \   000000E4   0x432C             ORRS     R4,R4,R5
   \   000000E6   0x6014             STR      R4,[R2, #+0]
   \   000000E8   0xF027 0x04A0      BIC      R4,R7,#0xA0
   \   000000EC   0x4323             ORRS     R3,R3,R4
   \   000000EE   0x6093             STR      R3,[R2, #+8]
   3054                         
   3055              /* Reset the IC2PSC Bits */
   3056              htim->Instance->CCMR1 &= ~TIM_CCMR1_IC2PSC;
   \   000000F0   0x6802             LDR      R2,[R0, #+0]
   \   000000F2   0x6993             LDR      R3,[R2, #+24]
   \   000000F4   0xF423 0x6340      BIC      R3,R3,#0xC00
   \   000000F8   0x6193             STR      R3,[R2, #+24]
   3057          
   3058              /* Set the IC2PSC value */
   3059              htim->Instance->CCMR1 |= (sConfig->ICPrescaler << 8);
   \   000000FA   0x6802             LDR      R2,[R0, #+0]
   \   000000FC   0x6993             LDR      R3,[R2, #+24]
   \   000000FE   0x6889             LDR      R1,[R1, #+8]
   \   00000100   0xEA43 0x2101      ORR      R1,R3,R1, LSL #+8
   \   00000104   0x6191             STR      R1,[R2, #+24]
   \   00000106   0xE04B             B.N      ??HAL_TIM_IC_ConfigChannel_4
   3060            }
   3061            else if (Channel == TIM_CHANNEL_3)
   \                     ??HAL_TIM_IC_ConfigChannel_5: (+1)
   \   00000108   0x2A08             CMP      R2,#+8
   \   0000010A   0x68CC             LDR      R4,[R1, #+12]
   \   0000010C   0x684D             LDR      R5,[R1, #+4]
   \   0000010E   0x680B             LDR      R3,[R1, #+0]
   \   00000110   0x6802             LDR      R2,[R0, #+0]
   \   00000112   0xD121             BNE.N    ??HAL_TIM_IC_ConfigChannel_6
   3062            {
   3063              /* TI3 Configuration */
   3064              assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
   3065              
   3066              TIM_TI3_SetConfig(htim->Instance,  
   3067                         sConfig->ICPolarity,
   3068                         sConfig->ICSelection,
   3069                         sConfig->ICFilter);
   \   00000114   0x321C             ADDS     R2,R2,#+28
   \   00000116   0x0124             LSLS     R4,R4,#+4
   \   00000118   0xF004 0x04F0      AND      R4,R4,#0xF0
   \   0000011C   0x021B             LSLS     R3,R3,#+8
   \   0000011E   0x6856             LDR      R6,[R2, #+4]
   \   00000120   0xF403 0x6320      AND      R3,R3,#0xA00
   \   00000124   0xF426 0x7680      BIC      R6,R6,#0x100
   \   00000128   0x6056             STR      R6,[R2, #+4]
   \   0000012A   0x6816             LDR      R6,[R2, #+0]
   \   0000012C   0x6857             LDR      R7,[R2, #+4]
   \   0000012E   0x08B6             LSRS     R6,R6,#+2
   \   00000130   0xEA45 0x0586      ORR      R5,R5,R6, LSL #+2
   \   00000134   0xF025 0x05F0      BIC      R5,R5,#0xF0
   \   00000138   0x432C             ORRS     R4,R4,R5
   \   0000013A   0x6014             STR      R4,[R2, #+0]
   \   0000013C   0xF427 0x6420      BIC      R4,R7,#0xA00
   \   00000140   0x4323             ORRS     R3,R3,R4
   \   00000142   0x6053             STR      R3,[R2, #+4]
   3070                         
   3071              /* Reset the IC3PSC Bits */
   3072              htim->Instance->CCMR2 &= ~TIM_CCMR2_IC3PSC;
   \   00000144   0x6802             LDR      R2,[R0, #+0]
   \   00000146   0x69D3             LDR      R3,[R2, #+28]
   \   00000148   0xF023 0x030C      BIC      R3,R3,#0xC
   \   0000014C   0x61D3             STR      R3,[R2, #+28]
   3073          
   3074              /* Set the IC3PSC value */
   3075              htim->Instance->CCMR2 |= sConfig->ICPrescaler;
   \   0000014E   0x6802             LDR      R2,[R0, #+0]
   \   00000150   0x69D3             LDR      R3,[R2, #+28]
   \   00000152   0x6889             LDR      R1,[R1, #+8]
   \   00000154   0x4319             ORRS     R1,R1,R3
   \   00000156   0xE022             B.N      ??HAL_TIM_IC_ConfigChannel_7
   3076            }
   3077            else
   3078            {
   3079              /* TI4 Configuration */
   3080              assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
   3081              
   3082              TIM_TI4_SetConfig(htim->Instance, 
   3083                         sConfig->ICPolarity,
   3084                         sConfig->ICSelection,
   3085                         sConfig->ICFilter);
   \                     ??HAL_TIM_IC_ConfigChannel_6: (+1)
   \   00000158   0x321C             ADDS     R2,R2,#+28
   \   0000015A   0x0324             LSLS     R4,R4,#+12
   \   0000015C   0xF404 0x4470      AND      R4,R4,#0xF000
   \   00000160   0x031B             LSLS     R3,R3,#+12
   \   00000162   0x6856             LDR      R6,[R2, #+4]
   \   00000164   0xF403 0x4320      AND      R3,R3,#0xA000
   \   00000168   0xF426 0x5680      BIC      R6,R6,#0x1000
   \   0000016C   0x6056             STR      R6,[R2, #+4]
   \   0000016E   0x6816             LDR      R6,[R2, #+0]
   \   00000170   0x6857             LDR      R7,[R2, #+4]
   \   00000172   0xF426 0x7640      BIC      R6,R6,#0x300
   \   00000176   0xEA46 0x2505      ORR      R5,R6,R5, LSL #+8
   \   0000017A   0xF425 0x4570      BIC      R5,R5,#0xF000
   \   0000017E   0x432C             ORRS     R4,R4,R5
   \   00000180   0x6014             STR      R4,[R2, #+0]
   \   00000182   0xF427 0x4420      BIC      R4,R7,#0xA000
   \   00000186   0x4323             ORRS     R3,R3,R4
   \   00000188   0x6053             STR      R3,[R2, #+4]
   3086                         
   3087              /* Reset the IC4PSC Bits */
   3088              htim->Instance->CCMR2 &= ~TIM_CCMR2_IC4PSC;
   \   0000018A   0x6802             LDR      R2,[R0, #+0]
   \   0000018C   0x69D3             LDR      R3,[R2, #+28]
   \   0000018E   0xF423 0x6340      BIC      R3,R3,#0xC00
   \   00000192   0x61D3             STR      R3,[R2, #+28]
   3089          
   3090              /* Set the IC4PSC value */
   3091              htim->Instance->CCMR2 |= (sConfig->ICPrescaler << 8);
   \   00000194   0x6802             LDR      R2,[R0, #+0]
   \   00000196   0x69D3             LDR      R3,[R2, #+28]
   \   00000198   0x6889             LDR      R1,[R1, #+8]
   \   0000019A   0xEA43 0x2101      ORR      R1,R3,R1, LSL #+8
   \                     ??HAL_TIM_IC_ConfigChannel_7: (+1)
   \   0000019E   0x61D1             STR      R1,[R2, #+28]
   3092            }
   3093            
   3094            htim->State = HAL_TIM_STATE_READY;
   \                     ??HAL_TIM_IC_ConfigChannel_4: (+1)
   \   000001A0   0x2101             MOVS     R1,#+1
   \   000001A2   0xF880 0x1039      STRB     R1,[R0, #+57]
   3095              
   3096            __HAL_UNLOCK(htim);
   \   000001A6   0x2100             MOVS     R1,#+0
   \   000001A8   0xF880 0x1038      STRB     R1,[R0, #+56]
   3097            
   3098            return HAL_OK; 
   \   000001AC   0x2000             MOVS     R0,#+0
   \   000001AE   0xBDF0             POP      {R4-R7,PC}       ;; return
   3099          }
   3100          
   3101          /**
   3102            * @brief  Initializes the TIM PWM  channels according to the specified
   3103            *         parameters in the TIM_OC_InitTypeDef.
   3104            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   3105            *                the configuration information for TIM module.
   3106            * @param  sConfig: TIM PWM configuration structure
   3107            * @param  Channel: TIM Channels to be enabled.
   3108            *          This parameter can be one of the following values:
   3109            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   3110            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   3111            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   3112            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   3113            * @retval HAL status
   3114            */

   \                                 In section .text, align 4, keep-with-next
   3115          __weak HAL_StatusTypeDef HAL_TIM_PWM_ConfigChannel(TIM_HandleTypeDef *htim, TIM_OC_InitTypeDef* sConfig, uint32_t Channel)
   3116          {
   \                     HAL_TIM_PWM_ConfigChannel: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0xB081             SUB      SP,SP,#+4
   \   00000006   0x460D             MOV      R5,R1
   3117            __HAL_LOCK(htim);
   \   00000008   0xF894 0x0038      LDRB     R0,[R4, #+56]
   \   0000000C   0x2801             CMP      R0,#+1
   \   0000000E   0xBF08             IT       EQ 
   \   00000010   0x2002             MOVEQ    R0,#+2
   \   00000012   0xD062             BEQ.N    ??HAL_TIM_PWM_ConfigChannel_1
   \   00000014   0x2001             MOVS     R0,#+1
   \   00000016   0xF884 0x0038      STRB     R0,[R4, #+56]
   3118            
   3119            /* Check the parameters */ 
   3120            assert_param(IS_TIM_CHANNELS(Channel)); 
   3121            assert_param(IS_TIM_PWM_MODE(sConfig->OCMode));
   3122            assert_param(IS_TIM_OC_POLARITY(sConfig->OCPolarity));
   3123            assert_param(IS_TIM_OCN_POLARITY(sConfig->OCNPolarity));
   3124            assert_param(IS_TIM_OCNIDLE_STATE(sConfig->OCNIdleState));
   3125            assert_param(IS_TIM_OCIDLE_STATE(sConfig->OCIdleState));
   3126            assert_param(IS_TIM_FAST_STATE(sConfig->OCFastMode)); 
   3127            
   3128            htim->State = HAL_TIM_STATE_BUSY;
   \   0000001A   0x2002             MOVS     R0,#+2
   3129              
   3130            switch (Channel)
   \   0000001C   0x2A0C             CMP      R2,#+12
   \   0000001E   0xF884 0x0039      STRB     R0,[R4, #+57]
   \   00000022   0xD854             BHI.N    ??HAL_TIM_PWM_ConfigChannel_2
   \   00000024   0xE8DF 0xF002      TBB      [PC, R2]
   \                     ??HAL_TIM_PWM_ConfigChannel_0:
   \   00000028   0x07 0x53          DC8      0x7,0x53,0x53,0x53
   \              0x53 0x53    
   \   0000002C   0x1A 0x53          DC8      0x1A,0x53,0x53,0x53
   \              0x53 0x53    
   \   00000030   0x2E 0x53          DC8      0x2E,0x53,0x53,0x53
   \              0x53 0x53    
   \   00000034   0x40 0x00          DC8      0x40,0x0
   3131            {
   3132              case TIM_CHANNEL_1:
   3133              {
   3134                assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   3135                /* Configure the Channel 1 in PWM mode */
   3136                TIM_OC1_SetConfig(htim->Instance, sConfig);
   \                     ??HAL_TIM_PWM_ConfigChannel_3: (+1)
   \   00000036   0x6820             LDR      R0,[R4, #+0]
   \   00000038   0x.... 0x....      BL       TIM_OC1_SetConfig
   3137                
   3138                /* Set the Preload enable bit for channel1 */
   3139                htim->Instance->CCMR1 |= TIM_CCMR1_OC1PE;
   \   0000003C   0x6820             LDR      R0,[R4, #+0]
   \   0000003E   0x6981             LDR      R1,[R0, #+24]
   \   00000040   0xF041 0x0108      ORR      R1,R1,#0x8
   \   00000044   0x6181             STR      R1,[R0, #+24]
   3140                
   3141                /* Configure the Output Fast mode */
   3142                htim->Instance->CCMR1 &= ~TIM_CCMR1_OC1FE;
   \   00000046   0x6820             LDR      R0,[R4, #+0]
   \   00000048   0x6981             LDR      R1,[R0, #+24]
   \   0000004A   0xF021 0x0104      BIC      R1,R1,#0x4
   \   0000004E   0x6181             STR      R1,[R0, #+24]
   3143                htim->Instance->CCMR1 |= sConfig->OCFastMode;
   \   00000050   0x6820             LDR      R0,[R4, #+0]
   \   00000052   0x6981             LDR      R1,[R0, #+24]
   \   00000054   0x692A             LDR      R2,[R5, #+16]
   \   00000056   0x4311             ORRS     R1,R2,R1
   \   00000058   0x6181             STR      R1,[R0, #+24]
   3144              }
   3145              break;
   3146              
   3147              case TIM_CHANNEL_2:
   3148              {
   3149                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   3150                /* Configure the Channel 2 in PWM mode */
   3151                TIM_OC2_SetConfig(htim->Instance, sConfig);
   3152                
   3153                /* Set the Preload enable bit for channel2 */
   3154                htim->Instance->CCMR1 |= TIM_CCMR1_OC2PE;
   3155                
   3156                /* Configure the Output Fast mode */
   3157                htim->Instance->CCMR1 &= ~TIM_CCMR1_OC2FE;
   3158                htim->Instance->CCMR1 |= sConfig->OCFastMode << 8;
   3159              }
   3160              break;
   \   0000005A   0xE038             B.N      ??HAL_TIM_PWM_ConfigChannel_2
   \                     ??HAL_TIM_PWM_ConfigChannel_4: (+1)
   \   0000005C   0x6820             LDR      R0,[R4, #+0]
   \   0000005E   0x.... 0x....      BL       TIM_OC2_SetConfig
   \   00000062   0x6820             LDR      R0,[R4, #+0]
   \   00000064   0x6981             LDR      R1,[R0, #+24]
   \   00000066   0xF441 0x6100      ORR      R1,R1,#0x800
   \   0000006A   0x6181             STR      R1,[R0, #+24]
   \   0000006C   0x6820             LDR      R0,[R4, #+0]
   \   0000006E   0x6981             LDR      R1,[R0, #+24]
   \   00000070   0xF421 0x6180      BIC      R1,R1,#0x400
   \   00000074   0x6181             STR      R1,[R0, #+24]
   \   00000076   0x6820             LDR      R0,[R4, #+0]
   \   00000078   0x6981             LDR      R1,[R0, #+24]
   \   0000007A   0x692A             LDR      R2,[R5, #+16]
   \   0000007C   0xEA41 0x2102      ORR      R1,R1,R2, LSL #+8
   \   00000080   0x6181             STR      R1,[R0, #+24]
   \   00000082   0xE024             B.N      ??HAL_TIM_PWM_ConfigChannel_2
   3161              
   3162              case TIM_CHANNEL_3:
   3163              {
   3164                assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
   3165                /* Configure the Channel 3 in PWM mode */
   3166                TIM_OC3_SetConfig(htim->Instance, sConfig);
   \                     ??HAL_TIM_PWM_ConfigChannel_5: (+1)
   \   00000084   0x6820             LDR      R0,[R4, #+0]
   \   00000086   0x.... 0x....      BL       TIM_OC3_SetConfig
   3167                
   3168                /* Set the Preload enable bit for channel3 */
   3169                htim->Instance->CCMR2 |= TIM_CCMR2_OC3PE;
   \   0000008A   0x6820             LDR      R0,[R4, #+0]
   \   0000008C   0x69C1             LDR      R1,[R0, #+28]
   \   0000008E   0xF041 0x0108      ORR      R1,R1,#0x8
   \   00000092   0x61C1             STR      R1,[R0, #+28]
   3170                
   3171               /* Configure the Output Fast mode */
   3172                htim->Instance->CCMR2 &= ~TIM_CCMR2_OC3FE;
   \   00000094   0x6820             LDR      R0,[R4, #+0]
   \   00000096   0x69C1             LDR      R1,[R0, #+28]
   \   00000098   0xF021 0x0104      BIC      R1,R1,#0x4
   \   0000009C   0x61C1             STR      R1,[R0, #+28]
   3173                htim->Instance->CCMR2 |= sConfig->OCFastMode;  
   \   0000009E   0x6820             LDR      R0,[R4, #+0]
   \   000000A0   0x69C1             LDR      R1,[R0, #+28]
   \   000000A2   0x692A             LDR      R2,[R5, #+16]
   \   000000A4   0x4311             ORRS     R1,R2,R1
   \   000000A6   0xE011             B.N      ??HAL_TIM_PWM_ConfigChannel_6
   3174              }
   3175              break;
   3176              
   3177              case TIM_CHANNEL_4:
   3178              {
   3179                assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
   3180                /* Configure the Channel 4 in PWM mode */
   3181                TIM_OC4_SetConfig(htim->Instance, sConfig);
   \                     ??HAL_TIM_PWM_ConfigChannel_7: (+1)
   \   000000A8   0x6820             LDR      R0,[R4, #+0]
   \   000000AA   0x.... 0x....      BL       TIM_OC4_SetConfig
   3182                
   3183                /* Set the Preload enable bit for channel4 */
   3184                htim->Instance->CCMR2 |= TIM_CCMR2_OC4PE;
   \   000000AE   0x6820             LDR      R0,[R4, #+0]
   \   000000B0   0x69C1             LDR      R1,[R0, #+28]
   \   000000B2   0xF441 0x6100      ORR      R1,R1,#0x800
   \   000000B6   0x61C1             STR      R1,[R0, #+28]
   3185                
   3186               /* Configure the Output Fast mode */
   3187                htim->Instance->CCMR2 &= ~TIM_CCMR2_OC4FE;
   \   000000B8   0x6820             LDR      R0,[R4, #+0]
   \   000000BA   0x69C1             LDR      R1,[R0, #+28]
   \   000000BC   0xF421 0x6180      BIC      R1,R1,#0x400
   \   000000C0   0x61C1             STR      R1,[R0, #+28]
   3188                htim->Instance->CCMR2 |= sConfig->OCFastMode << 8;  
   \   000000C2   0x6820             LDR      R0,[R4, #+0]
   \   000000C4   0x69C1             LDR      R1,[R0, #+28]
   \   000000C6   0x692A             LDR      R2,[R5, #+16]
   \   000000C8   0xEA41 0x2102      ORR      R1,R1,R2, LSL #+8
   \                     ??HAL_TIM_PWM_ConfigChannel_6: (+1)
   \   000000CC   0x61C1             STR      R1,[R0, #+28]
   3189              }
   3190              break;
   3191              
   3192              default:
   3193              break;    
   3194            }
   3195            
   3196            htim->State = HAL_TIM_STATE_READY;
   \                     ??HAL_TIM_PWM_ConfigChannel_2: (+1)
   \   000000CE   0x2001             MOVS     R0,#+1
   \   000000D0   0xF884 0x0039      STRB     R0,[R4, #+57]
   3197              
   3198            __HAL_UNLOCK(htim);
   \   000000D4   0x2000             MOVS     R0,#+0
   \   000000D6   0xF884 0x0038      STRB     R0,[R4, #+56]
   3199            
   3200            return HAL_OK;
   \                     ??HAL_TIM_PWM_ConfigChannel_1: (+1)
   \   000000DA   0xB001             ADD      SP,SP,#+4
   \   000000DC   0xBD30             POP      {R4,R5,PC}       ;; return
   3201          }
   3202          
   3203          /**
   3204            * @brief  Initializes the TIM One Pulse Channels according to the specified
   3205            *         parameters in the TIM_OnePulse_InitTypeDef.
   3206            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   3207            *                the configuration information for TIM module.
   3208            * @param  sConfig: TIM One Pulse configuration structure
   3209            * @param  OutputChannel: TIM Channels to be enabled.
   3210            *          This parameter can be one of the following values:
   3211            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   3212            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   3213            * @param  InputChannel: TIM Channels to be enabled.
   3214            *          This parameter can be one of the following values:
   3215            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   3216            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   3217            * @retval HAL status
   3218            */

   \                                 In section .text, align 2, keep-with-next
   3219          HAL_StatusTypeDef HAL_TIM_OnePulse_ConfigChannel(TIM_HandleTypeDef *htim,  TIM_OnePulse_InitTypeDef* sConfig, uint32_t OutputChannel,  uint32_t InputChannel)
   3220          {
   \                     HAL_TIM_OnePulse_ConfigChannel: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x461E             MOV      R6,R3
   3221            TIM_OC_InitTypeDef temp1;
   3222            
   3223            /* Check the parameters */
   3224            assert_param(IS_TIM_OPM_CHANNELS(OutputChannel));
   3225            assert_param(IS_TIM_OPM_CHANNELS(InputChannel));
   3226          
   3227            if(OutputChannel != InputChannel)  
   \   00000004   0x42B2             CMP      R2,R6
   \   00000006   0xB088             SUB      SP,SP,#+32
   \   00000008   0x4604             MOV      R4,R0
   \   0000000A   0x460D             MOV      R5,R1
   \   0000000C   0xD07A             BEQ.N    ??HAL_TIM_OnePulse_ConfigChannel_0
   3228            {
   3229              __HAL_LOCK(htim);
   \   0000000E   0xF894 0x0038      LDRB     R0,[R4, #+56]
   \   00000012   0x2801             CMP      R0,#+1
   \   00000014   0xBF08             IT       EQ 
   \   00000016   0x2002             MOVEQ    R0,#+2
   \   00000018   0xD075             BEQ.N    ??HAL_TIM_OnePulse_ConfigChannel_1
   \   0000001A   0x2001             MOVS     R0,#+1
   \   0000001C   0xF884 0x0038      STRB     R0,[R4, #+56]
   3230            
   3231              htim->State = HAL_TIM_STATE_BUSY;
   \   00000020   0x2002             MOVS     R0,#+2
   \   00000022   0xF884 0x0039      STRB     R0,[R4, #+57]
   3232          
   3233              /* Extract the Output compare configuration from sConfig structure */  
   3234              temp1.OCMode = sConfig->OCMode;
   \   00000026   0x6828             LDR      R0,[R5, #+0]
   \   00000028   0x9000             STR      R0,[SP, #+0]
   3235              temp1.Pulse = sConfig->Pulse;
   \   0000002A   0x6868             LDR      R0,[R5, #+4]
   \   0000002C   0x9001             STR      R0,[SP, #+4]
   3236              temp1.OCPolarity = sConfig->OCPolarity;
   \   0000002E   0x68A8             LDR      R0,[R5, #+8]
   \   00000030   0x9002             STR      R0,[SP, #+8]
   3237              temp1.OCNPolarity = sConfig->OCNPolarity;
   \   00000032   0x68E8             LDR      R0,[R5, #+12]
   \   00000034   0x9003             STR      R0,[SP, #+12]
   3238              temp1.OCIdleState = sConfig->OCIdleState;
   \   00000036   0x6928             LDR      R0,[R5, #+16]
   \   00000038   0x9005             STR      R0,[SP, #+20]
   3239              temp1.OCNIdleState = sConfig->OCNIdleState; 
   \   0000003A   0x6968             LDR      R0,[R5, #+20]
   \   0000003C   0x9006             STR      R0,[SP, #+24]
   3240              
   3241              switch (OutputChannel)
   \   0000003E   0xB132             CBZ.N    R2,??HAL_TIM_OnePulse_ConfigChannel_2
   \   00000040   0x2A04             CMP      R2,#+4
   \   00000042   0xBF02             ITTT     EQ 
   3242              {
   3243                case TIM_CHANNEL_1:
   3244                {
   3245                  assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   3246                
   3247                  TIM_OC1_SetConfig(htim->Instance, &temp1); 
   3248                }
   3249                break;
   3250                case TIM_CHANNEL_2:
   3251                {
   3252                  assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   3253                
   3254                  TIM_OC2_SetConfig(htim->Instance, &temp1);
   \   00000044   0x4669             MOVEQ    R1,SP
   \   00000046   0x6820             LDREQ    R0,[R4, #+0]
   \   00000048   0x.... 0x....      BLEQ     TIM_OC2_SetConfig
   \   0000004C   0xE003             B.N      ??HAL_TIM_OnePulse_ConfigChannel_3
   3255                }
   \                     ??HAL_TIM_OnePulse_ConfigChannel_2: (+1)
   \   0000004E   0x6820             LDR      R0,[R4, #+0]
   \   00000050   0x4669             MOV      R1,SP
   \   00000052   0x.... 0x....      BL       TIM_OC1_SetConfig
   3256                break;
   3257                default:
   3258                break;  
   3259              } 
   3260              switch (InputChannel)
   \                     ??HAL_TIM_OnePulse_ConfigChannel_3: (+1)
   \   00000056   0xB116             CBZ.N    R6,??HAL_TIM_OnePulse_ConfigChannel_4
   \   00000058   0x2E04             CMP      R6,#+4
   \   0000005A   0xD015             BEQ.N    ??HAL_TIM_OnePulse_ConfigChannel_5
   \   0000005C   0xE04A             B.N      ??HAL_TIM_OnePulse_ConfigChannel_6
   3261              {
   3262                case TIM_CHANNEL_1:
   3263                {
   3264                  assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   3265                
   3266                  TIM_TI1_SetConfig(htim->Instance, sConfig->ICPolarity,
   3267                                  sConfig->ICSelection, sConfig->ICFilter);
   \                     ??HAL_TIM_OnePulse_ConfigChannel_4: (+1)
   \   0000005E   0x6A2B             LDR      R3,[R5, #+32]
   \   00000060   0x69EA             LDR      R2,[R5, #+28]
   \   00000062   0x69A9             LDR      R1,[R5, #+24]
   \   00000064   0x6820             LDR      R0,[R4, #+0]
   \   00000066   0x.... 0x....      BL       TIM_TI1_SetConfig
   3268                         
   3269                  /* Reset the IC1PSC Bits */
   3270                  htim->Instance->CCMR1 &= ~TIM_CCMR1_IC1PSC;
   \   0000006A   0x6820             LDR      R0,[R4, #+0]
   \   0000006C   0x6981             LDR      R1,[R0, #+24]
   \   0000006E   0xF021 0x010C      BIC      R1,R1,#0xC
   \   00000072   0x6181             STR      R1,[R0, #+24]
   3271          
   3272                  /* Select the Trigger source */
   3273                  htim->Instance->SMCR &= ~TIM_SMCR_TS;
   \   00000074   0x6820             LDR      R0,[R4, #+0]
   \   00000076   0x6881             LDR      R1,[R0, #+8]
   \   00000078   0xF021 0x0170      BIC      R1,R1,#0x70
   \   0000007C   0x6081             STR      R1,[R0, #+8]
   3274                  htim->Instance->SMCR |= TIM_TS_TI1FP1;
   \   0000007E   0x6820             LDR      R0,[R4, #+0]
   \   00000080   0x6881             LDR      R1,[R0, #+8]
   \   00000082   0xF041 0x0150      ORR      R1,R1,#0x50
   \   00000086   0xE029             B.N      ??HAL_TIM_OnePulse_ConfigChannel_7
   3275                
   3276                  /* Select the Slave Mode */      
   3277                  htim->Instance->SMCR &= ~TIM_SMCR_SMS;
   3278                  htim->Instance->SMCR |= TIM_SLAVEMODE_TRIGGER;
   3279                }
   3280                break;
   3281                case TIM_CHANNEL_2:
   3282                {
   3283                  assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   3284                
   3285                  TIM_TI2_SetConfig(htim->Instance, sConfig->ICPolarity,
   3286                           sConfig->ICSelection, sConfig->ICFilter);
   \                     ??HAL_TIM_OnePulse_ConfigChannel_5: (+1)
   \   00000088   0x6821             LDR      R1,[R4, #+0]
   \   0000008A   0x6A2A             LDR      R2,[R5, #+32]
   \   0000008C   0x69EB             LDR      R3,[R5, #+28]
   \   0000008E   0x69A8             LDR      R0,[R5, #+24]
   \   00000090   0x0312             LSLS     R2,R2,#+12
   \   00000092   0xF402 0x4270      AND      R2,R2,#0xF000
   \   00000096   0x6A0D             LDR      R5,[R1, #+32]
   \   00000098   0x0100             LSLS     R0,R0,#+4
   \   0000009A   0xF000 0x00A0      AND      R0,R0,#0xA0
   \   0000009E   0xF025 0x0510      BIC      R5,R5,#0x10
   \   000000A2   0x620D             STR      R5,[R1, #+32]
   \   000000A4   0x698D             LDR      R5,[R1, #+24]
   \   000000A6   0x6A0E             LDR      R6,[R1, #+32]
   \   000000A8   0xF425 0x7540      BIC      R5,R5,#0x300
   \   000000AC   0xEA45 0x2303      ORR      R3,R5,R3, LSL #+8
   \   000000B0   0xF423 0x4370      BIC      R3,R3,#0xF000
   \   000000B4   0x431A             ORRS     R2,R2,R3
   \   000000B6   0x618A             STR      R2,[R1, #+24]
   \   000000B8   0xF026 0x02A0      BIC      R2,R6,#0xA0
   \   000000BC   0x4310             ORRS     R0,R0,R2
   \   000000BE   0x6208             STR      R0,[R1, #+32]
   3287                         
   3288                  /* Reset the IC2PSC Bits */
   3289                  htim->Instance->CCMR1 &= ~TIM_CCMR1_IC2PSC;
   \   000000C0   0x6820             LDR      R0,[R4, #+0]
   \   000000C2   0x6981             LDR      R1,[R0, #+24]
   \   000000C4   0xF421 0x6140      BIC      R1,R1,#0xC00
   \   000000C8   0x6181             STR      R1,[R0, #+24]
   3290          
   3291                  /* Select the Trigger source */
   3292                  htim->Instance->SMCR &= ~TIM_SMCR_TS;
   \   000000CA   0x6820             LDR      R0,[R4, #+0]
   \   000000CC   0x6881             LDR      R1,[R0, #+8]
   \   000000CE   0xF021 0x0170      BIC      R1,R1,#0x70
   \   000000D2   0x6081             STR      R1,[R0, #+8]
   3293                  htim->Instance->SMCR |= TIM_TS_TI2FP2;
   \   000000D4   0x6820             LDR      R0,[R4, #+0]
   \   000000D6   0x6881             LDR      R1,[R0, #+8]
   \   000000D8   0xF041 0x0160      ORR      R1,R1,#0x60
   \                     ??HAL_TIM_OnePulse_ConfigChannel_7: (+1)
   \   000000DC   0x6081             STR      R1,[R0, #+8]
   3294                
   3295                  /* Select the Slave Mode */      
   3296                  htim->Instance->SMCR &= ~TIM_SMCR_SMS;
   \   000000DE   0x6820             LDR      R0,[R4, #+0]
   \   000000E0   0x.... 0x....      LDR.W    R2,??DataTable37  ;; 0xfffefff8
   \   000000E4   0x6881             LDR      R1,[R0, #+8]
   \   000000E6   0x4011             ANDS     R1,R2,R1
   \   000000E8   0x6081             STR      R1,[R0, #+8]
   3297                  htim->Instance->SMCR |= TIM_SLAVEMODE_TRIGGER;
   \   000000EA   0x6820             LDR      R0,[R4, #+0]
   \   000000EC   0x6881             LDR      R1,[R0, #+8]
   \   000000EE   0xF041 0x0106      ORR      R1,R1,#0x6
   \   000000F2   0x6081             STR      R1,[R0, #+8]
   3298                }
   3299                break;
   3300              
   3301                default:
   3302                break;  
   3303              }
   3304            
   3305              htim->State = HAL_TIM_STATE_READY;
   \                     ??HAL_TIM_OnePulse_ConfigChannel_6: (+1)
   \   000000F4   0x2001             MOVS     R0,#+1
   \   000000F6   0xF884 0x0039      STRB     R0,[R4, #+57]
   3306              
   3307              __HAL_UNLOCK(htim);
   \   000000FA   0x2000             MOVS     R0,#+0
   \   000000FC   0xF884 0x0038      STRB     R0,[R4, #+56]
   3308            
   3309              return HAL_OK;
   \   00000100   0xB008             ADD      SP,SP,#+32
   \   00000102   0xBD70             POP      {R4-R6,PC}
   3310            }
   3311            else
   3312            {
   3313              return HAL_ERROR;
   \                     ??HAL_TIM_OnePulse_ConfigChannel_0: (+1)
   \   00000104   0x2001             MOVS     R0,#+1
   \                     ??HAL_TIM_OnePulse_ConfigChannel_1: (+1)
   \   00000106   0xB008             ADD      SP,SP,#+32
   \   00000108   0xBD70             POP      {R4-R6,PC}       ;; return
   3314            }
   3315          } 
   3316          
   3317          /**
   3318            * @brief  Configure the DMA Burst to transfer Data from the memory to the TIM peripheral  
   3319            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   3320            *                the configuration information for TIM module.
   3321            * @param  BurstBaseAddress: TIM Base address from when the DMA will starts the Data write.
   3322            *         This parameters can be on of the following values:
   3323            *            @arg TIM_DMABASE_CR1  
   3324            *            @arg TIM_DMABASE_CR2
   3325            *            @arg TIM_DMABASE_SMCR
   3326            *            @arg TIM_DMABASE_DIER
   3327            *            @arg TIM_DMABASE_SR
   3328            *            @arg TIM_DMABASE_EGR
   3329            *            @arg TIM_DMABASE_CCMR1
   3330            *            @arg TIM_DMABASE_CCMR2
   3331            *            @arg TIM_DMABASE_CCER
   3332            *            @arg TIM_DMABASE_CNT   
   3333            *            @arg TIM_DMABASE_PSC   
   3334            *            @arg TIM_DMABASE_ARR
   3335            *            @arg TIM_DMABASE_RCR
   3336            *            @arg TIM_DMABASE_CCR1
   3337            *            @arg TIM_DMABASE_CCR2
   3338            *            @arg TIM_DMABASE_CCR3  
   3339            *            @arg TIM_DMABASE_CCR4
   3340            *            @arg TIM_DMABASE_BDTR
   3341            *            @arg TIM_DMABASE_DCR
   3342            * @param  BurstRequestSrc: TIM DMA Request sources.
   3343            *         This parameters can be on of the following values:
   3344            *            @arg TIM_DMA_UPDATE: TIM update Interrupt source
   3345            *            @arg TIM_DMA_CC1: TIM Capture Compare 1 DMA source
   3346            *            @arg TIM_DMA_CC2: TIM Capture Compare 2 DMA source
   3347            *            @arg TIM_DMA_CC3: TIM Capture Compare 3 DMA source
   3348            *            @arg TIM_DMA_CC4: TIM Capture Compare 4 DMA source
   3349            *            @arg TIM_DMA_COM: TIM Commutation DMA source
   3350            *            @arg TIM_DMA_TRIGGER: TIM Trigger DMA source
   3351            * @param  BurstBuffer: The Buffer address.
   3352            * @param  BurstLength: DMA Burst length. This parameter can be one value
   3353            *         between TIM_DMABURSTLENGTH_1TRANSFER and TIM_DMABURSTLENGTH_18TRANSFERS.
   3354            * @retval HAL status
   3355            */

   \                                 In section .text, align 2, keep-with-next
   3356          HAL_StatusTypeDef HAL_TIM_DMABurst_WriteStart(TIM_HandleTypeDef *htim, uint32_t BurstBaseAddress, uint32_t BurstRequestSrc,
   3357                                                        uint32_t* BurstBuffer, uint32_t  BurstLength)
   3358          {
   \                     HAL_TIM_DMABurst_WriteStart: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0xB081             SUB      SP,SP,#+4
   \   00000006   0x460E             MOV      R6,R1
   \   00000008   0x4615             MOV      R5,R2
   3359            /* Check the parameters */
   3360            assert_param(IS_TIM_DMABURST_INSTANCE(htim->Instance));
   3361            assert_param(IS_TIM_DMA_BASE(BurstBaseAddress));
   3362            assert_param(IS_TIM_DMA_SOURCE(BurstRequestSrc));
   3363            assert_param(IS_TIM_DMA_LENGTH(BurstLength));
   3364            
   3365            if((htim->State == HAL_TIM_STATE_BUSY))
   \   0000000A   0xF894 0x0039      LDRB     R0,[R4, #+57]
   \   0000000E   0x4619             MOV      R1,R3
   \   00000010   0x2802             CMP      R0,#+2
   \   00000012   0xF000 0x8098      BEQ.W    ??HAL_TIM_DMABurst_WriteStart_0
   \   00000016   0x9F06             LDR      R7,[SP, #+24]
   3366            {
   3367               return HAL_BUSY;
   3368            }
   3369            else if((htim->State == HAL_TIM_STATE_READY))
   \   00000018   0xF894 0x0039      LDRB     R0,[R4, #+57]
   \   0000001C   0x2801             CMP      R0,#+1
   \   0000001E   0xD106             BNE.N    ??HAL_TIM_DMABurst_WriteStart_1
   3370            {
   3371              if((BurstBuffer == 0 ) && (BurstLength > 0)) 
   \   00000020   0xB911             CBNZ.N   R1,??HAL_TIM_DMABurst_WriteStart_2
   \   00000022   0x2F00             CMP      R7,#+0
   \   00000024   0xF040 0x808F      BNE.W    ??HAL_TIM_DMABurst_WriteStart_0
   3372              {
   3373                return HAL_ERROR;                                    
   3374              }
   3375              else
   3376              {
   3377                htim->State = HAL_TIM_STATE_BUSY;
   \                     ??HAL_TIM_DMABurst_WriteStart_2: (+1)
   \   00000028   0x2002             MOVS     R0,#+2
   \   0000002A   0xF884 0x0039      STRB     R0,[R4, #+57]
   3378              }
   3379            }
   3380            switch(BurstRequestSrc)
   \                     ??HAL_TIM_DMABurst_WriteStart_1: (+1)
   \   0000002E   0xF5B5 0x7F80      CMP      R5,#+256
   \   00000032   0xD012             BEQ.N    ??HAL_TIM_DMABurst_WriteStart_3
   \   00000034   0xF5B5 0x7F00      CMP      R5,#+512
   \   00000038   0xD01E             BEQ.N    ??HAL_TIM_DMABurst_WriteStart_4
   \   0000003A   0xF5B5 0x6F80      CMP      R5,#+1024
   \   0000003E   0xD02A             BEQ.N    ??HAL_TIM_DMABurst_WriteStart_5
   \   00000040   0xF5B5 0x6F00      CMP      R5,#+2048
   \   00000044   0xD036             BEQ.N    ??HAL_TIM_DMABurst_WriteStart_6
   \   00000046   0xF5B5 0x5F80      CMP      R5,#+4096
   \   0000004A   0xD042             BEQ.N    ??HAL_TIM_DMABurst_WriteStart_7
   \   0000004C   0xF5B5 0x5F00      CMP      R5,#+8192
   \   00000050   0xD04E             BEQ.N    ??HAL_TIM_DMABurst_WriteStart_8
   \   00000052   0xF5B5 0x4F80      CMP      R5,#+16384
   \   00000056   0xD05A             BEQ.N    ??HAL_TIM_DMABurst_WriteStart_9
   \   00000058   0xE069             B.N      ??HAL_TIM_DMABurst_WriteStart_10
   3381            {
   3382              case TIM_DMA_UPDATE:
   3383              {  
   3384                /* Set the DMA Period elapsed callback */
   3385                htim->hdma[TIM_DMA_ID_UPDATE]->XferCpltCallback = TIM_DMAPeriodElapsedCplt;
   \                     ??HAL_TIM_DMABurst_WriteStart_3: (+1)
   \   0000005A   0x69E2             LDR      R2,[R4, #+28]
   \   0000005C   0x.... 0x....      ADR.W    R0,TIM_DMAPeriodElapsedCplt
   \   00000060   0x63D0             STR      R0,[R2, #+60]
   3386               
   3387                /* Set the DMA error callback */
   3388                htim->hdma[TIM_DMA_ID_UPDATE]->XferErrorCallback = HAL_TIM_DMAError ;
   \   00000062   0x69E2             LDR      R2,[R4, #+28]
   \   00000064   0x.... 0x....      ADR.W    R0,TIM_DMAError
   \   00000068   0x6490             STR      R0,[R2, #+72]
   3389            
   3390                /* Enable the DMA Stream */
   3391                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_UPDATE], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8) + 1); 
   \   0000006A   0x0A38             LSRS     R0,R7,#+8
   \   0000006C   0x1C43             ADDS     R3,R0,#+1
   \   0000006E   0x6820             LDR      R0,[R4, #+0]
   \   00000070   0xF100 0x024C      ADD      R2,R0,#+76
   \   00000074   0x69E0             LDR      R0,[R4, #+28]
   \   00000076   0xE058             B.N      ??HAL_TIM_DMABurst_WriteStart_11
   3392              }
   3393              break;
   3394              case TIM_DMA_CC1:
   3395              {  
   3396                /* Set the DMA Period elapsed callback */
   3397                htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = HAL_TIM_DMADelayPulseCplt;
   \                     ??HAL_TIM_DMABurst_WriteStart_4: (+1)
   \   00000078   0x6A22             LDR      R2,[R4, #+32]
   \   0000007A   0x.... 0x....      ADR.W    R0,TIM_DMADelayPulseCplt
   \   0000007E   0x63D0             STR      R0,[R2, #+60]
   3398               
   3399                /* Set the DMA error callback */
   3400                htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = HAL_TIM_DMAError ;
   \   00000080   0x6A22             LDR      R2,[R4, #+32]
   \   00000082   0x.... 0x....      ADR.W    R0,TIM_DMAError
   \   00000086   0x6490             STR      R0,[R2, #+72]
   3401            
   3402                /* Enable the DMA Stream */
   3403                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8) + 1);     
   \   00000088   0x0A38             LSRS     R0,R7,#+8
   \   0000008A   0x1C43             ADDS     R3,R0,#+1
   \   0000008C   0x6820             LDR      R0,[R4, #+0]
   \   0000008E   0xF100 0x024C      ADD      R2,R0,#+76
   \   00000092   0x6A20             LDR      R0,[R4, #+32]
   \   00000094   0xE049             B.N      ??HAL_TIM_DMABurst_WriteStart_11
   3404              }
   3405              break;
   3406              case TIM_DMA_CC2:
   3407              {  
   3408                /* Set the DMA Period elapsed callback */
   3409                htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = HAL_TIM_DMADelayPulseCplt;
   \                     ??HAL_TIM_DMABurst_WriteStart_5: (+1)
   \   00000096   0x6A62             LDR      R2,[R4, #+36]
   \   00000098   0x.... 0x....      ADR.W    R0,TIM_DMADelayPulseCplt
   \   0000009C   0x63D0             STR      R0,[R2, #+60]
   3410               
   3411                /* Set the DMA error callback */
   3412                htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = HAL_TIM_DMAError ;
   \   0000009E   0x6A62             LDR      R2,[R4, #+36]
   \   000000A0   0x.... 0x....      ADR.W    R0,TIM_DMAError
   \   000000A4   0x6490             STR      R0,[R2, #+72]
   3413            
   3414                /* Enable the DMA Stream */
   3415                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8) + 1);     
   \   000000A6   0x0A38             LSRS     R0,R7,#+8
   \   000000A8   0x1C43             ADDS     R3,R0,#+1
   \   000000AA   0x6820             LDR      R0,[R4, #+0]
   \   000000AC   0xF100 0x024C      ADD      R2,R0,#+76
   \   000000B0   0x6A60             LDR      R0,[R4, #+36]
   \   000000B2   0xE03A             B.N      ??HAL_TIM_DMABurst_WriteStart_11
   3416              }
   3417              break;
   3418              case TIM_DMA_CC3:
   3419              {  
   3420                /* Set the DMA Period elapsed callback */
   3421                htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = HAL_TIM_DMADelayPulseCplt;
   \                     ??HAL_TIM_DMABurst_WriteStart_6: (+1)
   \   000000B4   0x6AA2             LDR      R2,[R4, #+40]
   \   000000B6   0x.... 0x....      ADR.W    R0,TIM_DMADelayPulseCplt
   \   000000BA   0x63D0             STR      R0,[R2, #+60]
   3422               
   3423                /* Set the DMA error callback */
   3424                htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = HAL_TIM_DMAError ;
   \   000000BC   0x6AA2             LDR      R2,[R4, #+40]
   \   000000BE   0x.... 0x....      ADR.W    R0,TIM_DMAError
   \   000000C2   0x6490             STR      R0,[R2, #+72]
   3425            
   3426                /* Enable the DMA Stream */
   3427                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8) + 1);     
   \   000000C4   0x0A38             LSRS     R0,R7,#+8
   \   000000C6   0x1C43             ADDS     R3,R0,#+1
   \   000000C8   0x6820             LDR      R0,[R4, #+0]
   \   000000CA   0xF100 0x024C      ADD      R2,R0,#+76
   \   000000CE   0x6AA0             LDR      R0,[R4, #+40]
   \   000000D0   0xE02B             B.N      ??HAL_TIM_DMABurst_WriteStart_11
   3428              }
   3429              break;
   3430              case TIM_DMA_CC4:
   3431              {  
   3432                /* Set the DMA Period elapsed callback */
   3433                htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = HAL_TIM_DMADelayPulseCplt;
   \                     ??HAL_TIM_DMABurst_WriteStart_7: (+1)
   \   000000D2   0x6AE2             LDR      R2,[R4, #+44]
   \   000000D4   0x.... 0x....      ADR.W    R0,TIM_DMADelayPulseCplt
   \   000000D8   0x63D0             STR      R0,[R2, #+60]
   3434               
   3435                /* Set the DMA error callback */
   3436                htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = HAL_TIM_DMAError ;
   \   000000DA   0x6AE2             LDR      R2,[R4, #+44]
   \   000000DC   0x.... 0x....      ADR.W    R0,TIM_DMAError
   \   000000E0   0x6490             STR      R0,[R2, #+72]
   3437            
   3438                /* Enable the DMA Stream */
   3439                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8) + 1);     
   \   000000E2   0x0A38             LSRS     R0,R7,#+8
   \   000000E4   0x1C43             ADDS     R3,R0,#+1
   \   000000E6   0x6820             LDR      R0,[R4, #+0]
   \   000000E8   0xF100 0x024C      ADD      R2,R0,#+76
   \   000000EC   0x6AE0             LDR      R0,[R4, #+44]
   \   000000EE   0xE01C             B.N      ??HAL_TIM_DMABurst_WriteStart_11
   3440              }
   3441              break;
   3442              case TIM_DMA_COM:
   3443              {  
   3444                /* Set the DMA Period elapsed callback */
   3445                htim->hdma[TIM_DMA_ID_COMMUTATION]->XferCpltCallback = HAL_TIMEx_DMACommutationCplt;
   \                     ??HAL_TIM_DMABurst_WriteStart_8: (+1)
   \   000000F0   0x6B22             LDR      R2,[R4, #+48]
   \   000000F2   0x.... 0x....      LDR.W    R0,??DataTable37_1
   \   000000F6   0x63D0             STR      R0,[R2, #+60]
   3446               
   3447                /* Set the DMA error callback */
   3448                htim->hdma[TIM_DMA_ID_COMMUTATION]->XferErrorCallback = HAL_TIM_DMAError ;
   \   000000F8   0x6B22             LDR      R2,[R4, #+48]
   \   000000FA   0x.... 0x....      ADR.W    R0,TIM_DMAError
   \   000000FE   0x6490             STR      R0,[R2, #+72]
   3449            
   3450                /* Enable the DMA Stream */
   3451                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_COMMUTATION], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8) + 1);     
   \   00000100   0x0A38             LSRS     R0,R7,#+8
   \   00000102   0x1C43             ADDS     R3,R0,#+1
   \   00000104   0x6820             LDR      R0,[R4, #+0]
   \   00000106   0xF100 0x024C      ADD      R2,R0,#+76
   \   0000010A   0x6B20             LDR      R0,[R4, #+48]
   \   0000010C   0xE00D             B.N      ??HAL_TIM_DMABurst_WriteStart_11
   3452              }
   3453              break;
   3454              case TIM_DMA_TRIGGER:
   3455              {  
   3456                /* Set the DMA Period elapsed callback */
   3457                htim->hdma[TIM_DMA_ID_TRIGGER]->XferCpltCallback = TIM_DMATriggerCplt;
   \                     ??HAL_TIM_DMABurst_WriteStart_9: (+1)
   \   0000010E   0x6B62             LDR      R2,[R4, #+52]
   \   00000110   0x.... 0x....      ADR.W    R0,TIM_DMATriggerCplt
   \   00000114   0x63D0             STR      R0,[R2, #+60]
   3458               
   3459                /* Set the DMA error callback */
   3460                htim->hdma[TIM_DMA_ID_TRIGGER]->XferErrorCallback = HAL_TIM_DMAError ;
   \   00000116   0x6B62             LDR      R2,[R4, #+52]
   \   00000118   0x.... 0x....      ADR.W    R0,TIM_DMAError
   \   0000011C   0x6490             STR      R0,[R2, #+72]
   3461            
   3462                /* Enable the DMA Stream */
   3463                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_TRIGGER], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8) + 1);     
   \   0000011E   0x0A38             LSRS     R0,R7,#+8
   \   00000120   0x1C43             ADDS     R3,R0,#+1
   \   00000122   0x6820             LDR      R0,[R4, #+0]
   \   00000124   0xF100 0x024C      ADD      R2,R0,#+76
   \   00000128   0x6B60             LDR      R0,[R4, #+52]
   \                     ??HAL_TIM_DMABurst_WriteStart_11: (+1)
   \   0000012A   0x.... 0x....      BL       HAL_DMA_Start_IT
   3464              }
   3465              break;
   3466              default:
   3467              break;  
   3468            }
   3469             /* configure the DMA Burst Mode */
   3470             htim->Instance->DCR = BurstBaseAddress | BurstLength;  
   \                     ??HAL_TIM_DMABurst_WriteStart_10: (+1)
   \   0000012E   0x6821             LDR      R1,[R4, #+0]
   \   00000130   0xEA47 0x0006      ORR      R0,R7,R6
   \   00000134   0x6488             STR      R0,[R1, #+72]
   3471             
   3472             /* Enable the TIM DMA Request */
   3473             __HAL_TIM_ENABLE_DMA(htim, BurstRequestSrc);  
   \   00000136   0x6820             LDR      R0,[R4, #+0]
   \   00000138   0x68C1             LDR      R1,[R0, #+12]
   \   0000013A   0x4329             ORRS     R1,R5,R1
   \   0000013C   0x60C1             STR      R1,[R0, #+12]
   3474             
   3475             htim->State = HAL_TIM_STATE_READY;
   \   0000013E   0x2001             MOVS     R0,#+1
   \   00000140   0xF884 0x0039      STRB     R0,[R4, #+57]
   3476            
   3477            /* Return function status */
   3478            return HAL_OK;
   \   00000144   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_DMABurst_WriteStart_0: (+1)
   \   00000146   0xB001             ADD      SP,SP,#+4
   \   00000148   0xBDF0             POP      {R4-R7,PC}       ;; return
   3479          }
   3480          
   3481          /**
   3482            * @brief  Stops the TIM DMA Burst mode 
   3483            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   3484            *                the configuration information for TIM module.
   3485            * @param  BurstRequestSrc: TIM DMA Request sources to disable
   3486            * @retval HAL status
   3487            */

   \                                 In section .text, align 2, keep-with-next
   3488          HAL_StatusTypeDef HAL_TIM_DMABurst_WriteStop(TIM_HandleTypeDef *htim, uint32_t BurstRequestSrc)
   3489          {
   \                     HAL_TIM_DMABurst_WriteStop: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0x460D             MOV      R5,R1
   3490            /* Check the parameters */
   3491            assert_param(IS_TIM_DMA_SOURCE(BurstRequestSrc));
   3492            
   3493            /* Abort the DMA transfer (at least disable the DMA channel) */
   3494            switch(BurstRequestSrc)
   \   00000004   0xF5B5 0x7F80      CMP      R5,#+256
   \   00000008   0xB081             SUB      SP,SP,#+4
   \   0000000A   0x4604             MOV      R4,R0
   \   0000000C   0xD012             BEQ.N    ??HAL_TIM_DMABurst_WriteStop_0
   \   0000000E   0xF5B5 0x7F00      CMP      R5,#+512
   \   00000012   0xD011             BEQ.N    ??HAL_TIM_DMABurst_WriteStop_1
   \   00000014   0xF5B5 0x6F80      CMP      R5,#+1024
   \   00000018   0xD010             BEQ.N    ??HAL_TIM_DMABurst_WriteStop_2
   \   0000001A   0xF5B5 0x6F00      CMP      R5,#+2048
   \   0000001E   0xD00F             BEQ.N    ??HAL_TIM_DMABurst_WriteStop_3
   \   00000020   0xF5B5 0x5F80      CMP      R5,#+4096
   \   00000024   0xD00E             BEQ.N    ??HAL_TIM_DMABurst_WriteStop_4
   \   00000026   0xF5B5 0x5F00      CMP      R5,#+8192
   \   0000002A   0xD00D             BEQ.N    ??HAL_TIM_DMABurst_WriteStop_5
   \   0000002C   0xF5B5 0x4F80      CMP      R5,#+16384
   \   00000030   0xD00C             BEQ.N    ??HAL_TIM_DMABurst_WriteStop_6
   \   00000032   0xE00E             B.N      ??HAL_TIM_DMABurst_WriteStop_7
   3495            {
   3496              case TIM_DMA_UPDATE:
   3497              {  
   3498                HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_UPDATE]);
   \                     ??HAL_TIM_DMABurst_WriteStop_0: (+1)
   \   00000034   0x69E0             LDR      R0,[R4, #+28]
   \   00000036   0xE00A             B.N      ??HAL_TIM_DMABurst_WriteStop_8
   3499              }
   3500              break;
   3501              case TIM_DMA_CC1:
   3502              {  
   3503                HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC1]);
   \                     ??HAL_TIM_DMABurst_WriteStop_1: (+1)
   \   00000038   0x6A20             LDR      R0,[R4, #+32]
   \   0000003A   0xE008             B.N      ??HAL_TIM_DMABurst_WriteStop_8
   3504              }
   3505              break;
   3506              case TIM_DMA_CC2:
   3507              {  
   3508                HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC2]);
   \                     ??HAL_TIM_DMABurst_WriteStop_2: (+1)
   \   0000003C   0x6A60             LDR      R0,[R4, #+36]
   \   0000003E   0xE006             B.N      ??HAL_TIM_DMABurst_WriteStop_8
   3509              }
   3510              break;
   3511              case TIM_DMA_CC3:
   3512              {  
   3513                HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC3]);
   \                     ??HAL_TIM_DMABurst_WriteStop_3: (+1)
   \   00000040   0x6AA0             LDR      R0,[R4, #+40]
   \   00000042   0xE004             B.N      ??HAL_TIM_DMABurst_WriteStop_8
   3514              }
   3515              break;
   3516              case TIM_DMA_CC4:
   3517              {  
   3518                HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC4]);
   \                     ??HAL_TIM_DMABurst_WriteStop_4: (+1)
   \   00000044   0x6AE0             LDR      R0,[R4, #+44]
   \   00000046   0xE002             B.N      ??HAL_TIM_DMABurst_WriteStop_8
   3519              }
   3520              break;
   3521              case TIM_DMA_COM:
   3522              {  
   3523                HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_COMMUTATION]);
   \                     ??HAL_TIM_DMABurst_WriteStop_5: (+1)
   \   00000048   0x6B20             LDR      R0,[R4, #+48]
   \   0000004A   0xE000             B.N      ??HAL_TIM_DMABurst_WriteStop_8
   3524              }
   3525              break;
   3526              case TIM_DMA_TRIGGER:
   3527              {  
   3528                HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_TRIGGER]);
   \                     ??HAL_TIM_DMABurst_WriteStop_6: (+1)
   \   0000004C   0x6B60             LDR      R0,[R4, #+52]
   \                     ??HAL_TIM_DMABurst_WriteStop_8: (+1)
   \   0000004E   0x.... 0x....      BL       HAL_DMA_Abort
   3529              }
   3530              break;
   3531              default:
   3532              break;
   3533            }
   3534          
   3535            /* Disable the TIM Update DMA request */
   3536            __HAL_TIM_DISABLE_DMA(htim, BurstRequestSrc);
   \                     ??HAL_TIM_DMABurst_WriteStop_7: (+1)
   \   00000052   0x6820             LDR      R0,[R4, #+0]
   \   00000054   0x68C1             LDR      R1,[R0, #+12]
   \   00000056   0x43A9             BICS     R1,R1,R5
   \   00000058   0x60C1             STR      R1,[R0, #+12]
   3537                
   3538            /* Return function status */
   3539            return HAL_OK;  
   \   0000005A   0x2000             MOVS     R0,#+0
   \   0000005C   0xB001             ADD      SP,SP,#+4
   \   0000005E   0xBD30             POP      {R4,R5,PC}       ;; return
   3540          }
   3541          
   3542          /**
   3543            * @brief  Configure the DMA Burst to transfer Data from the TIM peripheral to the memory 
   3544            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   3545            *                the configuration information for TIM module.
   3546            * @param  BurstBaseAddress: TIM Base address from when the DMA will starts the Data read.
   3547            *         This parameters can be on of the following values:
   3548            *            @arg TIM_DMABASE_CR1  
   3549            *            @arg TIM_DMABASE_CR2
   3550            *            @arg TIM_DMABASE_SMCR
   3551            *            @arg TIM_DMABASE_DIER
   3552            *            @arg TIM_DMABASE_SR
   3553            *            @arg TIM_DMABASE_EGR
   3554            *            @arg TIM_DMABASE_CCMR1
   3555            *            @arg TIM_DMABASE_CCMR2
   3556            *            @arg TIM_DMABASE_CCER
   3557            *            @arg TIM_DMABASE_CNT   
   3558            *            @arg TIM_DMABASE_PSC   
   3559            *            @arg TIM_DMABASE_ARR
   3560            *            @arg TIM_DMABASE_RCR
   3561            *            @arg TIM_DMABASE_CCR1
   3562            *            @arg TIM_DMABASE_CCR2
   3563            *            @arg TIM_DMABASE_CCR3  
   3564            *            @arg TIM_DMABASE_CCR4
   3565            *            @arg TIM_DMABASE_BDTR
   3566            *            @arg TIM_DMABASE_DCR
   3567            * @param  BurstRequestSrc: TIM DMA Request sources.
   3568            *         This parameters can be on of the following values:
   3569            *            @arg TIM_DMA_UPDATE: TIM update Interrupt source
   3570            *            @arg TIM_DMA_CC1: TIM Capture Compare 1 DMA source
   3571            *            @arg TIM_DMA_CC2: TIM Capture Compare 2 DMA source
   3572            *            @arg TIM_DMA_CC3: TIM Capture Compare 3 DMA source
   3573            *            @arg TIM_DMA_CC4: TIM Capture Compare 4 DMA source
   3574            *            @arg TIM_DMA_COM: TIM Commutation DMA source
   3575            *            @arg TIM_DMA_TRIGGER: TIM Trigger DMA source
   3576            * @param  BurstBuffer: The Buffer address.
   3577            * @param  BurstLength: DMA Burst length. This parameter can be one value
   3578            *         between TIM_DMABURSTLENGTH_1TRANSFER and TIM_DMABURSTLENGTH_18TRANSFERS.
   3579            * @retval HAL status
   3580            */

   \                                 In section .text, align 2, keep-with-next
   3581          HAL_StatusTypeDef HAL_TIM_DMABurst_ReadStart(TIM_HandleTypeDef *htim, uint32_t BurstBaseAddress, uint32_t BurstRequestSrc,
   3582                                                       uint32_t  *BurstBuffer, uint32_t  BurstLength)
   3583          {
   \                     HAL_TIM_DMABurst_ReadStart: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0xB081             SUB      SP,SP,#+4
   \   00000006   0x4615             MOV      R5,R2
   \   00000008   0x460E             MOV      R6,R1
   3584            /* Check the parameters */
   3585            assert_param(IS_TIM_DMABURST_INSTANCE(htim->Instance));
   3586            assert_param(IS_TIM_DMA_BASE(BurstBaseAddress));
   3587            assert_param(IS_TIM_DMA_SOURCE(BurstRequestSrc));
   3588            assert_param(IS_TIM_DMA_LENGTH(BurstLength));
   3589            
   3590            if((htim->State == HAL_TIM_STATE_BUSY))
   \   0000000A   0xF894 0x0039      LDRB     R0,[R4, #+57]
   \   0000000E   0x461A             MOV      R2,R3
   \   00000010   0x2802             CMP      R0,#+2
   \   00000012   0xF000 0x8098      BEQ.W    ??HAL_TIM_DMABurst_ReadStart_0
   \   00000016   0x9F06             LDR      R7,[SP, #+24]
   3591            {
   3592               return HAL_BUSY;
   3593            }
   3594            else if((htim->State == HAL_TIM_STATE_READY))
   \   00000018   0xF894 0x0039      LDRB     R0,[R4, #+57]
   \   0000001C   0x2801             CMP      R0,#+1
   \   0000001E   0xD106             BNE.N    ??HAL_TIM_DMABurst_ReadStart_1
   3595            {
   3596              if((BurstBuffer == 0 ) && (BurstLength > 0)) 
   \   00000020   0xB912             CBNZ.N   R2,??HAL_TIM_DMABurst_ReadStart_2
   \   00000022   0x2F00             CMP      R7,#+0
   \   00000024   0xF040 0x808F      BNE.W    ??HAL_TIM_DMABurst_ReadStart_0
   3597              {
   3598                return HAL_ERROR;                                    
   3599              }
   3600              else
   3601              {
   3602                htim->State = HAL_TIM_STATE_BUSY;
   \                     ??HAL_TIM_DMABurst_ReadStart_2: (+1)
   \   00000028   0x2002             MOVS     R0,#+2
   \   0000002A   0xF884 0x0039      STRB     R0,[R4, #+57]
   3603              }
   3604            }  
   3605            switch(BurstRequestSrc)
   \                     ??HAL_TIM_DMABurst_ReadStart_1: (+1)
   \   0000002E   0xF5B5 0x7F80      CMP      R5,#+256
   \   00000032   0xD012             BEQ.N    ??HAL_TIM_DMABurst_ReadStart_3
   \   00000034   0xF5B5 0x7F00      CMP      R5,#+512
   \   00000038   0xD01E             BEQ.N    ??HAL_TIM_DMABurst_ReadStart_4
   \   0000003A   0xF5B5 0x6F80      CMP      R5,#+1024
   \   0000003E   0xD02A             BEQ.N    ??HAL_TIM_DMABurst_ReadStart_5
   \   00000040   0xF5B5 0x6F00      CMP      R5,#+2048
   \   00000044   0xD036             BEQ.N    ??HAL_TIM_DMABurst_ReadStart_6
   \   00000046   0xF5B5 0x5F80      CMP      R5,#+4096
   \   0000004A   0xD042             BEQ.N    ??HAL_TIM_DMABurst_ReadStart_7
   \   0000004C   0xF5B5 0x5F00      CMP      R5,#+8192
   \   00000050   0xD04E             BEQ.N    ??HAL_TIM_DMABurst_ReadStart_8
   \   00000052   0xF5B5 0x4F80      CMP      R5,#+16384
   \   00000056   0xD05A             BEQ.N    ??HAL_TIM_DMABurst_ReadStart_9
   \   00000058   0xE069             B.N      ??HAL_TIM_DMABurst_ReadStart_10
   3606            {
   3607              case TIM_DMA_UPDATE:
   3608              {  
   3609                /* Set the DMA Period elapsed callback */
   3610                htim->hdma[TIM_DMA_ID_UPDATE]->XferCpltCallback = TIM_DMAPeriodElapsedCplt;
   \                     ??HAL_TIM_DMABurst_ReadStart_3: (+1)
   \   0000005A   0x69E1             LDR      R1,[R4, #+28]
   \   0000005C   0x.... 0x....      ADR.W    R0,TIM_DMAPeriodElapsedCplt
   \   00000060   0x63C8             STR      R0,[R1, #+60]
   3611               
   3612                /* Set the DMA error callback */
   3613                htim->hdma[TIM_DMA_ID_UPDATE]->XferErrorCallback = HAL_TIM_DMAError ;
   \   00000062   0x69E1             LDR      R1,[R4, #+28]
   \   00000064   0x.... 0x....      ADR.W    R0,TIM_DMAError
   \   00000068   0x6488             STR      R0,[R1, #+72]
   3614            
   3615                /* Enable the DMA Stream */
   3616                 HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_UPDATE], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8) + 1);     
   \   0000006A   0x0A38             LSRS     R0,R7,#+8
   \   0000006C   0x1C43             ADDS     R3,R0,#+1
   \   0000006E   0x6820             LDR      R0,[R4, #+0]
   \   00000070   0xF100 0x014C      ADD      R1,R0,#+76
   \   00000074   0x69E0             LDR      R0,[R4, #+28]
   \   00000076   0xE058             B.N      ??HAL_TIM_DMABurst_ReadStart_11
   3617              }
   3618              break;
   3619              case TIM_DMA_CC1:
   3620              {  
   3621                /* Set the DMA Period elapsed callback */
   3622                htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = HAL_TIM_DMACaptureCplt;
   \                     ??HAL_TIM_DMABurst_ReadStart_4: (+1)
   \   00000078   0x6A21             LDR      R1,[R4, #+32]
   \   0000007A   0x.... 0x....      ADR.W    R0,TIM_DMACaptureCplt
   \   0000007E   0x63C8             STR      R0,[R1, #+60]
   3623               
   3624                /* Set the DMA error callback */
   3625                htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = HAL_TIM_DMAError ;
   \   00000080   0x6A21             LDR      R1,[R4, #+32]
   \   00000082   0x.... 0x....      ADR.W    R0,TIM_DMAError
   \   00000086   0x6488             STR      R0,[R1, #+72]
   3626            
   3627                /* Enable the DMA Stream */
   3628                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8) + 1);      
   \   00000088   0x0A38             LSRS     R0,R7,#+8
   \   0000008A   0x1C43             ADDS     R3,R0,#+1
   \   0000008C   0x6820             LDR      R0,[R4, #+0]
   \   0000008E   0xF100 0x014C      ADD      R1,R0,#+76
   \   00000092   0x6A20             LDR      R0,[R4, #+32]
   \   00000094   0xE049             B.N      ??HAL_TIM_DMABurst_ReadStart_11
   3629              }
   3630              break;
   3631              case TIM_DMA_CC2:
   3632              {  
   3633                /* Set the DMA Period elapsed callback */
   3634                htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = HAL_TIM_DMACaptureCplt;
   \                     ??HAL_TIM_DMABurst_ReadStart_5: (+1)
   \   00000096   0x6A61             LDR      R1,[R4, #+36]
   \   00000098   0x.... 0x....      ADR.W    R0,TIM_DMACaptureCplt
   \   0000009C   0x63C8             STR      R0,[R1, #+60]
   3635               
   3636                /* Set the DMA error callback */
   3637                htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = HAL_TIM_DMAError ;
   \   0000009E   0x6A61             LDR      R1,[R4, #+36]
   \   000000A0   0x.... 0x....      ADR.W    R0,TIM_DMAError
   \   000000A4   0x6488             STR      R0,[R1, #+72]
   3638            
   3639                /* Enable the DMA Stream */
   3640                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8) + 1);     
   \   000000A6   0x0A38             LSRS     R0,R7,#+8
   \   000000A8   0x1C43             ADDS     R3,R0,#+1
   \   000000AA   0x6820             LDR      R0,[R4, #+0]
   \   000000AC   0xF100 0x014C      ADD      R1,R0,#+76
   \   000000B0   0x6A60             LDR      R0,[R4, #+36]
   \   000000B2   0xE03A             B.N      ??HAL_TIM_DMABurst_ReadStart_11
   3641              }
   3642              break;
   3643              case TIM_DMA_CC3:
   3644              {  
   3645                /* Set the DMA Period elapsed callback */
   3646                htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = HAL_TIM_DMACaptureCplt;
   \                     ??HAL_TIM_DMABurst_ReadStart_6: (+1)
   \   000000B4   0x6AA1             LDR      R1,[R4, #+40]
   \   000000B6   0x.... 0x....      ADR.W    R0,TIM_DMACaptureCplt
   \   000000BA   0x63C8             STR      R0,[R1, #+60]
   3647               
   3648                /* Set the DMA error callback */
   3649                htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = HAL_TIM_DMAError ;
   \   000000BC   0x6AA1             LDR      R1,[R4, #+40]
   \   000000BE   0x.... 0x....      ADR.W    R0,TIM_DMAError
   \   000000C2   0x6488             STR      R0,[R1, #+72]
   3650            
   3651                /* Enable the DMA Stream */
   3652                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8) + 1);      
   \   000000C4   0x0A38             LSRS     R0,R7,#+8
   \   000000C6   0x1C43             ADDS     R3,R0,#+1
   \   000000C8   0x6820             LDR      R0,[R4, #+0]
   \   000000CA   0xF100 0x014C      ADD      R1,R0,#+76
   \   000000CE   0x6AA0             LDR      R0,[R4, #+40]
   \   000000D0   0xE02B             B.N      ??HAL_TIM_DMABurst_ReadStart_11
   3653              }
   3654              break;
   3655              case TIM_DMA_CC4:
   3656              {  
   3657                /* Set the DMA Period elapsed callback */
   3658                htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = HAL_TIM_DMACaptureCplt;
   \                     ??HAL_TIM_DMABurst_ReadStart_7: (+1)
   \   000000D2   0x6AE1             LDR      R1,[R4, #+44]
   \   000000D4   0x.... 0x....      ADR.W    R0,TIM_DMACaptureCplt
   \   000000D8   0x63C8             STR      R0,[R1, #+60]
   3659               
   3660                /* Set the DMA error callback */
   3661                htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = HAL_TIM_DMAError ;
   \   000000DA   0x6AE1             LDR      R1,[R4, #+44]
   \   000000DC   0x.... 0x....      ADR.W    R0,TIM_DMAError
   \   000000E0   0x6488             STR      R0,[R1, #+72]
   3662            
   3663                /* Enable the DMA Stream */
   3664                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8) + 1);      
   \   000000E2   0x0A38             LSRS     R0,R7,#+8
   \   000000E4   0x1C43             ADDS     R3,R0,#+1
   \   000000E6   0x6820             LDR      R0,[R4, #+0]
   \   000000E8   0xF100 0x014C      ADD      R1,R0,#+76
   \   000000EC   0x6AE0             LDR      R0,[R4, #+44]
   \   000000EE   0xE01C             B.N      ??HAL_TIM_DMABurst_ReadStart_11
   3665              }
   3666              break;
   3667              case TIM_DMA_COM:
   3668              {  
   3669                /* Set the DMA Period elapsed callback */
   3670                htim->hdma[TIM_DMA_ID_COMMUTATION]->XferCpltCallback = HAL_TIMEx_DMACommutationCplt;
   \                     ??HAL_TIM_DMABurst_ReadStart_8: (+1)
   \   000000F0   0x6B21             LDR      R1,[R4, #+48]
   \   000000F2   0x.... 0x....      LDR.W    R0,??DataTable37_1
   \   000000F6   0x63C8             STR      R0,[R1, #+60]
   3671               
   3672                /* Set the DMA error callback */
   3673                htim->hdma[TIM_DMA_ID_COMMUTATION]->XferErrorCallback = HAL_TIM_DMAError ;
   \   000000F8   0x6B21             LDR      R1,[R4, #+48]
   \   000000FA   0x.... 0x....      ADR.W    R0,TIM_DMAError
   \   000000FE   0x6488             STR      R0,[R1, #+72]
   3674            
   3675                /* Enable the DMA Stream */
   3676                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_COMMUTATION], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8) + 1);      
   \   00000100   0x0A38             LSRS     R0,R7,#+8
   \   00000102   0x1C43             ADDS     R3,R0,#+1
   \   00000104   0x6820             LDR      R0,[R4, #+0]
   \   00000106   0xF100 0x014C      ADD      R1,R0,#+76
   \   0000010A   0x6B20             LDR      R0,[R4, #+48]
   \   0000010C   0xE00D             B.N      ??HAL_TIM_DMABurst_ReadStart_11
   3677              }
   3678              break;
   3679              case TIM_DMA_TRIGGER:
   3680              {  
   3681                /* Set the DMA Period elapsed callback */
   3682                htim->hdma[TIM_DMA_ID_TRIGGER]->XferCpltCallback = TIM_DMATriggerCplt;
   \                     ??HAL_TIM_DMABurst_ReadStart_9: (+1)
   \   0000010E   0x6B61             LDR      R1,[R4, #+52]
   \   00000110   0x.... 0x....      ADR.W    R0,TIM_DMATriggerCplt
   \   00000114   0x63C8             STR      R0,[R1, #+60]
   3683               
   3684                /* Set the DMA error callback */
   3685                htim->hdma[TIM_DMA_ID_TRIGGER]->XferErrorCallback = HAL_TIM_DMAError ;
   \   00000116   0x6B61             LDR      R1,[R4, #+52]
   \   00000118   0x.... 0x....      ADR.W    R0,TIM_DMAError
   \   0000011C   0x6488             STR      R0,[R1, #+72]
   3686            
   3687                /* Enable the DMA Stream */
   3688                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_TRIGGER], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8) + 1);      
   \   0000011E   0x0A38             LSRS     R0,R7,#+8
   \   00000120   0x1C43             ADDS     R3,R0,#+1
   \   00000122   0x6820             LDR      R0,[R4, #+0]
   \   00000124   0xF100 0x014C      ADD      R1,R0,#+76
   \   00000128   0x6B60             LDR      R0,[R4, #+52]
   \                     ??HAL_TIM_DMABurst_ReadStart_11: (+1)
   \   0000012A   0x.... 0x....      BL       HAL_DMA_Start_IT
   3689              }
   3690              break;
   3691              default:
   3692              break;  
   3693            }
   3694          
   3695            /* configure the DMA Burst Mode */
   3696            htim->Instance->DCR = BurstBaseAddress | BurstLength;  
   \                     ??HAL_TIM_DMABurst_ReadStart_10: (+1)
   \   0000012E   0x6821             LDR      R1,[R4, #+0]
   \   00000130   0xEA47 0x0006      ORR      R0,R7,R6
   \   00000134   0x6488             STR      R0,[R1, #+72]
   3697            
   3698            /* Enable the TIM DMA Request */
   3699            __HAL_TIM_ENABLE_DMA(htim, BurstRequestSrc);
   \   00000136   0x6820             LDR      R0,[R4, #+0]
   \   00000138   0x68C1             LDR      R1,[R0, #+12]
   \   0000013A   0x4329             ORRS     R1,R5,R1
   \   0000013C   0x60C1             STR      R1,[R0, #+12]
   3700            
   3701            htim->State = HAL_TIM_STATE_READY;
   \   0000013E   0x2001             MOVS     R0,#+1
   \   00000140   0xF884 0x0039      STRB     R0,[R4, #+57]
   3702            
   3703            /* Return function status */
   3704            return HAL_OK;
   \   00000144   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_DMABurst_ReadStart_0: (+1)
   \   00000146   0xB001             ADD      SP,SP,#+4
   \   00000148   0xBDF0             POP      {R4-R7,PC}       ;; return
   3705          }
   3706          
   3707          /**
   3708            * @brief  Stop the DMA burst reading 
   3709            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   3710            *                the configuration information for TIM module.
   3711            * @param  BurstRequestSrc: TIM DMA Request sources to disable.
   3712            * @retval HAL status
   3713            */

   \                                 In section .text, align 2, keep-with-next
   3714          HAL_StatusTypeDef HAL_TIM_DMABurst_ReadStop(TIM_HandleTypeDef *htim, uint32_t BurstRequestSrc)
   3715          {
   \                     HAL_TIM_DMABurst_ReadStop: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0x460D             MOV      R5,R1
   3716            /* Check the parameters */
   3717            assert_param(IS_TIM_DMA_SOURCE(BurstRequestSrc));
   3718            
   3719            /* Abort the DMA transfer (at least disable the DMA channel) */
   3720            switch(BurstRequestSrc)
   \   00000004   0xF5B5 0x7F80      CMP      R5,#+256
   \   00000008   0xB081             SUB      SP,SP,#+4
   \   0000000A   0x4604             MOV      R4,R0
   \   0000000C   0xD012             BEQ.N    ??HAL_TIM_DMABurst_ReadStop_0
   \   0000000E   0xF5B5 0x7F00      CMP      R5,#+512
   \   00000012   0xD011             BEQ.N    ??HAL_TIM_DMABurst_ReadStop_1
   \   00000014   0xF5B5 0x6F80      CMP      R5,#+1024
   \   00000018   0xD010             BEQ.N    ??HAL_TIM_DMABurst_ReadStop_2
   \   0000001A   0xF5B5 0x6F00      CMP      R5,#+2048
   \   0000001E   0xD00F             BEQ.N    ??HAL_TIM_DMABurst_ReadStop_3
   \   00000020   0xF5B5 0x5F80      CMP      R5,#+4096
   \   00000024   0xD00E             BEQ.N    ??HAL_TIM_DMABurst_ReadStop_4
   \   00000026   0xF5B5 0x5F00      CMP      R5,#+8192
   \   0000002A   0xD00D             BEQ.N    ??HAL_TIM_DMABurst_ReadStop_5
   \   0000002C   0xF5B5 0x4F80      CMP      R5,#+16384
   \   00000030   0xD00C             BEQ.N    ??HAL_TIM_DMABurst_ReadStop_6
   \   00000032   0xE00E             B.N      ??HAL_TIM_DMABurst_ReadStop_7
   3721            {
   3722              case TIM_DMA_UPDATE:
   3723              {  
   3724                HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_UPDATE]);
   \                     ??HAL_TIM_DMABurst_ReadStop_0: (+1)
   \   00000034   0x69E0             LDR      R0,[R4, #+28]
   \   00000036   0xE00A             B.N      ??HAL_TIM_DMABurst_ReadStop_8
   3725              }
   3726              break;
   3727              case TIM_DMA_CC1:
   3728              {  
   3729                HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC1]);
   \                     ??HAL_TIM_DMABurst_ReadStop_1: (+1)
   \   00000038   0x6A20             LDR      R0,[R4, #+32]
   \   0000003A   0xE008             B.N      ??HAL_TIM_DMABurst_ReadStop_8
   3730              }
   3731              break;
   3732              case TIM_DMA_CC2:
   3733              {  
   3734                HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC2]);
   \                     ??HAL_TIM_DMABurst_ReadStop_2: (+1)
   \   0000003C   0x6A60             LDR      R0,[R4, #+36]
   \   0000003E   0xE006             B.N      ??HAL_TIM_DMABurst_ReadStop_8
   3735              }
   3736              break;
   3737              case TIM_DMA_CC3:
   3738              {  
   3739                HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC3]);
   \                     ??HAL_TIM_DMABurst_ReadStop_3: (+1)
   \   00000040   0x6AA0             LDR      R0,[R4, #+40]
   \   00000042   0xE004             B.N      ??HAL_TIM_DMABurst_ReadStop_8
   3740              }
   3741              break;
   3742              case TIM_DMA_CC4:
   3743              {  
   3744                HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC4]);
   \                     ??HAL_TIM_DMABurst_ReadStop_4: (+1)
   \   00000044   0x6AE0             LDR      R0,[R4, #+44]
   \   00000046   0xE002             B.N      ??HAL_TIM_DMABurst_ReadStop_8
   3745              }
   3746              break;
   3747              case TIM_DMA_COM:
   3748              {  
   3749                HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_COMMUTATION]);
   \                     ??HAL_TIM_DMABurst_ReadStop_5: (+1)
   \   00000048   0x6B20             LDR      R0,[R4, #+48]
   \   0000004A   0xE000             B.N      ??HAL_TIM_DMABurst_ReadStop_8
   3750              }
   3751              break;
   3752              case TIM_DMA_TRIGGER:
   3753              {  
   3754                HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_TRIGGER]);
   \                     ??HAL_TIM_DMABurst_ReadStop_6: (+1)
   \   0000004C   0x6B60             LDR      R0,[R4, #+52]
   \                     ??HAL_TIM_DMABurst_ReadStop_8: (+1)
   \   0000004E   0x.... 0x....      BL       HAL_DMA_Abort
   3755              }
   3756              break;
   3757              default:
   3758              break;  
   3759            }
   3760            
   3761            /* Disable the TIM Update DMA request */
   3762            __HAL_TIM_DISABLE_DMA(htim, BurstRequestSrc);
   \                     ??HAL_TIM_DMABurst_ReadStop_7: (+1)
   \   00000052   0x6820             LDR      R0,[R4, #+0]
   \   00000054   0x68C1             LDR      R1,[R0, #+12]
   \   00000056   0x43A9             BICS     R1,R1,R5
   \   00000058   0x60C1             STR      R1,[R0, #+12]
   3763                
   3764            /* Return function status */
   3765            return HAL_OK;  
   \   0000005A   0x2000             MOVS     R0,#+0
   \   0000005C   0xB001             ADD      SP,SP,#+4
   \   0000005E   0xBD30             POP      {R4,R5,PC}       ;; return
   3766          }
   3767          
   3768          /**
   3769            * @brief  Generate a software event
   3770            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   3771            *                the configuration information for TIM module.
   3772            * @param  EventSource: specifies the event source.
   3773            *          This parameter can be one of the following values:
   3774            *            @arg TIM_EVENTSOURCE_UPDATE: Timer update Event source
   3775            *            @arg TIM_EVENTSOURCE_CC1: Timer Capture Compare 1 Event source
   3776            *            @arg TIM_EVENTSOURCE_CC2: Timer Capture Compare 2 Event source
   3777            *            @arg TIM_EVENTSOURCE_CC3: Timer Capture Compare 3 Event source
   3778            *            @arg TIM_EVENTSOURCE_CC4: Timer Capture Compare 4 Event source
   3779            *            @arg TIM_EVENTSOURCE_COM: Timer COM event source  
   3780            *            @arg TIM_EVENTSOURCE_TRIGGER: Timer Trigger Event source
   3781            *            @arg TIM_EVENTSOURCE_BREAK: Timer Break event source
   3782            *            @arg TIM_EVENTSOURCE_BREAK2: Timer Break2 event source  
   3783            * @note   TIM6 and TIM7 can only generate an update event. 
   3784            * @note   TIM_EVENTSOURCE_COM, TIM_EVENTSOURCE_BREAK and TIM_EVENTSOURCE_BREAK2 are used only with TIM1 and TIM8.
   3785            * @retval HAL status
   3786            */ 
   3787          

   \                                 In section .text, align 2, keep-with-next
   3788          HAL_StatusTypeDef HAL_TIM_GenerateEvent(TIM_HandleTypeDef *htim, uint32_t EventSource)
   3789          {
   3790            /* Check the parameters */
   3791            assert_param(IS_TIM_INSTANCE(htim->Instance));
   3792            assert_param(IS_TIM_EVENT_SOURCE(EventSource));
   3793            
   3794            /* Process Locked */
   3795            __HAL_LOCK(htim);
   \                     HAL_TIM_GenerateEvent: (+1)
   \   00000000   0xF890 0x2038      LDRB     R2,[R0, #+56]
   \   00000004   0x2A01             CMP      R2,#+1
   \   00000006   0xD101             BNE.N    ??HAL_TIM_GenerateEvent_0
   \   00000008   0x2002             MOVS     R0,#+2
   \   0000000A   0x4770             BX       LR
   \                     ??HAL_TIM_GenerateEvent_0: (+1)
   \   0000000C   0x2201             MOVS     R2,#+1
   \   0000000E   0xF880 0x2038      STRB     R2,[R0, #+56]
   3796            
   3797            /* Change the TIM state */
   3798            htim->State = HAL_TIM_STATE_BUSY;
   \   00000012   0x2202             MOVS     R2,#+2
   \   00000014   0xF880 0x2039      STRB     R2,[R0, #+57]
   3799            
   3800            /* Set the event sources */
   3801            htim->Instance->EGR = EventSource;
   \   00000018   0x6802             LDR      R2,[R0, #+0]
   \   0000001A   0x6151             STR      R1,[R2, #+20]
   3802            
   3803            /* Change the TIM state */
   3804            htim->State = HAL_TIM_STATE_READY;
   \   0000001C   0x2101             MOVS     R1,#+1
   \   0000001E   0xF880 0x1039      STRB     R1,[R0, #+57]
   3805            
   3806            __HAL_UNLOCK(htim);
   \   00000022   0x2100             MOVS     R1,#+0
   \   00000024   0xF880 0x1038      STRB     R1,[R0, #+56]
   3807            
   3808            /* Return function status */
   3809            return HAL_OK;  
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0x4770             BX       LR               ;; return
   3810          }
   3811          
   3812          /**
   3813            * @brief  Configures the OCRef clear feature
   3814            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   3815            *                the configuration information for TIM module.
   3816            * @param  sClearInputConfig: pointer to a TIM_ClearInputConfigTypeDef structure that
   3817            *         contains the OCREF clear feature and parameters for the TIM peripheral. 
   3818            * @param  Channel: specifies the TIM Channel.
   3819            *          This parameter can be one of the following values:
   3820            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   3821            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   3822            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   3823            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   3824            * @retval HAL status
   3825            */ 

   \                                 In section .text, align 4, keep-with-next
   3826          __weak HAL_StatusTypeDef HAL_TIM_ConfigOCrefClear(TIM_HandleTypeDef *htim, TIM_ClearInputConfigTypeDef * sClearInputConfig, uint32_t Channel)
   3827          { 
   \                     HAL_TIM_ConfigOCrefClear: (+1)
   \   00000000   0xB4F0             PUSH     {R4-R7}
   3828            /* Check the parameters */
   3829            assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   3830            assert_param(IS_TIM_CHANNELS(Channel));
   3831            assert_param(IS_TIM_CLEARINPUT_SOURCE(sClearInputConfig->ClearInputSource));
   3832             
   3833            /* Process Locked */
   3834            __HAL_LOCK(htim);
   \   00000002   0xF890 0x3038      LDRB     R3,[R0, #+56]
   \   00000006   0x2B01             CMP      R3,#+1
   \   00000008   0xBF08             IT       EQ 
   \   0000000A   0x2002             MOVEQ    R0,#+2
   \   0000000C   0xD050             BEQ.N    ??HAL_TIM_ConfigOCrefClear_1
   \   0000000E   0x2301             MOVS     R3,#+1
   \   00000010   0xF880 0x3038      STRB     R3,[R0, #+56]
   3835            
   3836            htim->State = HAL_TIM_STATE_BUSY;
   \   00000014   0x2302             MOVS     R3,#+2
   \   00000016   0xF880 0x3039      STRB     R3,[R0, #+57]
   3837            
   3838            if(sClearInputConfig->ClearInputSource == TIM_CLEARINPUTSOURCE_ETR)
   \   0000001A   0x684B             LDR      R3,[R1, #+4]
   \   0000001C   0x2B01             CMP      R3,#+1
   \   0000001E   0xD10B             BNE.N    ??HAL_TIM_ConfigOCrefClear_2
   3839            {
   3840              assert_param(IS_TIM_CLEARINPUT_POLARITY(sClearInputConfig->ClearInputPolarity));
   3841              assert_param(IS_TIM_CLEARINPUT_PRESCALER(sClearInputConfig->ClearInputPrescaler));
   3842              assert_param(IS_TIM_CLEARINPUT_FILTER(sClearInputConfig->ClearInputFilter));
   3843            
   3844              TIM_ETR_SetConfig(htim->Instance, 
   3845                                sClearInputConfig->ClearInputPrescaler,
   3846                                sClearInputConfig->ClearInputPolarity,
   3847                                sClearInputConfig->ClearInputFilter);
   \   00000020   0x6806             LDR      R6,[R0, #+0]
   \   00000022   0x690B             LDR      R3,[R1, #+16]
   \   00000024   0x688C             LDR      R4,[R1, #+8]
   \   00000026   0x68CD             LDR      R5,[R1, #+12]
   \   00000028   0x68B7             LDR      R7,[R6, #+8]
   \   0000002A   0xF427 0x477F      BIC      R7,R7,#0xFF00
   \   0000002E   0x433D             ORRS     R5,R5,R7
   \   00000030   0x432C             ORRS     R4,R4,R5
   \   00000032   0xEA44 0x2303      ORR      R3,R4,R3, LSL #+8
   \   00000036   0x60B3             STR      R3,[R6, #+8]
   3848            }
   3849            
   3850            switch (Channel)
   \                     ??HAL_TIM_ConfigOCrefClear_2: (+1)
   \   00000038   0x2A0C             CMP      R2,#+12
   \   0000003A   0xD832             BHI.N    ??HAL_TIM_ConfigOCrefClear_3
   \   0000003C   0xE8DF 0xF002      TBB      [PC, R2]
   \                     ??HAL_TIM_ConfigOCrefClear_0:
   \   00000040   0x07 0x31          DC8      0x7,0x31,0x31,0x31
   \              0x31 0x31    
   \   00000044   0x12 0x31          DC8      0x12,0x31,0x31,0x31
   \              0x31 0x31    
   \   00000048   0x1D 0x31          DC8      0x1D,0x31,0x31,0x31
   \              0x31 0x31    
   \   0000004C   0x27 0x00          DC8      0x27,0x0
   3851            {
   3852              case TIM_CHANNEL_1:
   3853              {        
   3854                if(sClearInputConfig->ClearInputState != RESET)  
   \                     ??HAL_TIM_ConfigOCrefClear_4: (+1)
   \   0000004E   0x6809             LDR      R1,[R1, #+0]
   \   00000050   0x2900             CMP      R1,#+0
   \   00000052   0x6801             LDR      R1,[R0, #+0]
   \   00000054   0x698A             LDR      R2,[R1, #+24]
   \   00000056   0xBF0C             ITE      EQ 
   \   00000058   0xF022 0x0280      BICEQ    R2,R2,#0x80
   \   0000005C   0xF042 0x0280      ORRNE    R2,R2,#0x80
   3855                {
   3856                  /* Enable the Ocref clear feature for Channel 1 */
   3857                  htim->Instance->CCMR1 |= TIM_CCMR1_OC1CE;
   3858                }
   3859                else
   3860                {
   3861                  /* Disable the Ocref clear feature for Channel 1 */
   3862                  htim->Instance->CCMR1 &= ~TIM_CCMR1_OC1CE;      
   \   00000060   0x618A             STR      R2,[R1, #+24]
   \   00000062   0xE01E             B.N      ??HAL_TIM_ConfigOCrefClear_3
   3863                }
   3864              }    
   3865              break;
   3866              case TIM_CHANNEL_2:    
   3867              { 
   3868                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance)); 
   3869                if(sClearInputConfig->ClearInputState != RESET)  
   \                     ??HAL_TIM_ConfigOCrefClear_5: (+1)
   \   00000064   0x6809             LDR      R1,[R1, #+0]
   \   00000066   0x2900             CMP      R1,#+0
   \   00000068   0x6801             LDR      R1,[R0, #+0]
   \   0000006A   0x698A             LDR      R2,[R1, #+24]
   \   0000006C   0xBF14             ITE      NE 
   \   0000006E   0xF442 0x4200      ORRNE    R2,R2,#0x8000
   \   00000072   0xF422 0x4200      BICEQ    R2,R2,#0x8000
   3870                {
   3871                  /* Enable the Ocref clear feature for Channel 2 */
   3872                  htim->Instance->CCMR1 |= TIM_CCMR1_OC2CE;
   3873                }
   3874                else
   3875                {
   3876                  /* Disable the Ocref clear feature for Channel 2 */
   3877                  htim->Instance->CCMR1 &= ~TIM_CCMR1_OC2CE;      
   \   00000076   0x618A             STR      R2,[R1, #+24]
   \   00000078   0xE013             B.N      ??HAL_TIM_ConfigOCrefClear_3
   3878                }
   3879              } 
   3880              break;
   3881              case TIM_CHANNEL_3:   
   3882              {  
   3883                assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
   3884                if(sClearInputConfig->ClearInputState != RESET)  
   \                     ??HAL_TIM_ConfigOCrefClear_6: (+1)
   \   0000007A   0x6809             LDR      R1,[R1, #+0]
   \   0000007C   0x2900             CMP      R1,#+0
   \   0000007E   0x6801             LDR      R1,[R0, #+0]
   \   00000080   0x69CA             LDR      R2,[R1, #+28]
   \   00000082   0xBF0C             ITE      EQ 
   \   00000084   0xF022 0x0280      BICEQ    R2,R2,#0x80
   \   00000088   0xF042 0x0280      ORRNE    R2,R2,#0x80
   3885                {
   3886                  /* Enable the Ocref clear feature for Channel 3 */
   3887                  htim->Instance->CCMR2 |= TIM_CCMR2_OC3CE;
   3888                }
   3889                else
   3890                {
   3891                  /* Disable the Ocref clear feature for Channel 3 */
   3892                  htim->Instance->CCMR2 &= ~TIM_CCMR2_OC3CE;      
   \   0000008C   0xE008             B.N      ??HAL_TIM_ConfigOCrefClear_7
   3893                }
   3894              } 
   3895              break;
   3896              case TIM_CHANNEL_4:    
   3897              {  
   3898                assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
   3899                if(sClearInputConfig->ClearInputState != RESET)  
   \                     ??HAL_TIM_ConfigOCrefClear_8: (+1)
   \   0000008E   0x6809             LDR      R1,[R1, #+0]
   \   00000090   0x2900             CMP      R1,#+0
   \   00000092   0x6801             LDR      R1,[R0, #+0]
   \   00000094   0x69CA             LDR      R2,[R1, #+28]
   \   00000096   0xBF14             ITE      NE 
   \   00000098   0xF442 0x4200      ORRNE    R2,R2,#0x8000
   \   0000009C   0xF422 0x4200      BICEQ    R2,R2,#0x8000
   3900                {
   3901                  /* Enable the Ocref clear feature for Channel 4 */
   3902                  htim->Instance->CCMR2 |= TIM_CCMR2_OC4CE;
   3903                }
   3904                else
   3905                {
   3906                  /* Disable the Ocref clear feature for Channel 4 */
   3907                  htim->Instance->CCMR2 &= ~TIM_CCMR2_OC4CE;      
   \                     ??HAL_TIM_ConfigOCrefClear_7: (+1)
   \   000000A0   0x61CA             STR      R2,[R1, #+28]
   3908                }
   3909              } 
   3910              break;
   3911              default:  
   3912              break;
   3913            } 
   3914          
   3915            htim->State = HAL_TIM_STATE_READY;
   \                     ??HAL_TIM_ConfigOCrefClear_3: (+1)
   \   000000A2   0x2101             MOVS     R1,#+1
   \   000000A4   0xF880 0x1039      STRB     R1,[R0, #+57]
   3916            
   3917            __HAL_UNLOCK(htim);
   \   000000A8   0x2100             MOVS     R1,#+0
   \   000000AA   0xF880 0x1038      STRB     R1,[R0, #+56]
   3918            
   3919            return HAL_OK;  
   \   000000AE   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_ConfigOCrefClear_1: (+1)
   \   000000B0   0xBCF0             POP      {R4-R7}
   \   000000B2   0x4770             BX       LR               ;; return
   3920          }  
   3921          
   3922          /**
   3923            * @brief   Configures the clock source to be used
   3924            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   3925            *                the configuration information for TIM module.
   3926            * @param  sClockSourceConfig: pointer to a TIM_ClockConfigTypeDef structure that
   3927            *         contains the clock source information for the TIM peripheral. 
   3928            * @retval HAL status
   3929            */ 

   \                                 In section .text, align 2, keep-with-next
   3930          HAL_StatusTypeDef HAL_TIM_ConfigClockSource(TIM_HandleTypeDef *htim, TIM_ClockConfigTypeDef * sClockSourceConfig)    
   3931          {
   \                     HAL_TIM_ConfigClockSource: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
   3932            uint32_t tmpsmcr = 0;
   3933              
   3934            /* Process Locked */
   3935            __HAL_LOCK(htim);
   \   00000002   0xF890 0x2038      LDRB     R2,[R0, #+56]
   \   00000006   0x2A01             CMP      R2,#+1
   \   00000008   0xBF08             IT       EQ 
   \   0000000A   0x2002             MOVEQ    R0,#+2
   \   0000000C   0xF000 0x80C5      BEQ.W    ??HAL_TIM_ConfigClockSource_0
   \   00000010   0x2201             MOVS     R2,#+1
   3936            
   3937            htim->State = HAL_TIM_STATE_BUSY;
   3938            
   3939            /* Check the parameters */
   3940            assert_param(IS_TIM_CLOCKSOURCE(sClockSourceConfig->ClockSource));
   3941            assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
   3942            assert_param(IS_TIM_CLOCKPRESCALER(sClockSourceConfig->ClockPrescaler));
   3943            assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
   3944            
   3945            /* Reset the SMS, TS, ECE, ETPS and ETRF bits */
   3946            tmpsmcr = htim->Instance->SMCR;
   3947            tmpsmcr &= ~(TIM_SMCR_SMS | TIM_SMCR_TS);
   3948            tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
   3949            htim->Instance->SMCR = tmpsmcr;
   \   00000012   0x.... 0x....      LDR.W    R4,??DataTable37_2  ;; 0xfffe0088
   \   00000016   0xF880 0x2038      STRB     R2,[R0, #+56]
   \   0000001A   0x2202             MOVS     R2,#+2
   \   0000001C   0xF880 0x2039      STRB     R2,[R0, #+57]
   \   00000020   0x6802             LDR      R2,[R0, #+0]
   \   00000022   0x6893             LDR      R3,[R2, #+8]
   \   00000024   0x4023             ANDS     R3,R4,R3
   \   00000026   0x6093             STR      R3,[R2, #+8]
   3950            
   3951            switch (sClockSourceConfig->ClockSource)
   \   00000028   0x680A             LDR      R2,[R1, #+0]
   \   0000002A   0x2A00             CMP      R2,#+0
   \   0000002C   0xF000 0x8092      BEQ.W    ??HAL_TIM_ConfigClockSource_1
   \   00000030   0x2A10             CMP      R2,#+16
   \   00000032   0xF000 0x8096      BEQ.W    ??HAL_TIM_ConfigClockSource_2
   \   00000036   0x2A20             CMP      R2,#+32
   \   00000038   0xF000 0x809A      BEQ.W    ??HAL_TIM_ConfigClockSource_3
   \   0000003C   0x2A30             CMP      R2,#+48
   \   0000003E   0xF000 0x809E      BEQ.W    ??HAL_TIM_ConfigClockSource_4
   \   00000042   0x2A40             CMP      R2,#+64
   \   00000044   0xD06C             BEQ.N    ??HAL_TIM_ConfigClockSource_5
   \   00000046   0x2A50             CMP      R2,#+80
   \   00000048   0xD035             BEQ.N    ??HAL_TIM_ConfigClockSource_6
   \   0000004A   0x2A60             CMP      R2,#+96
   \   0000004C   0xD04D             BEQ.N    ??HAL_TIM_ConfigClockSource_7
   \   0000004E   0x2A70             CMP      R2,#+112
   \   00000050   0xD00C             BEQ.N    ??HAL_TIM_ConfigClockSource_8
   \   00000052   0xF5B2 0x5F80      CMP      R2,#+4096
   \   00000056   0xD003             BEQ.N    ??HAL_TIM_ConfigClockSource_9
   \   00000058   0xF5B2 0x5F00      CMP      R2,#+8192
   \   0000005C   0xD01A             BEQ.N    ??HAL_TIM_ConfigClockSource_10
   \   0000005E   0xE095             B.N      ??HAL_TIM_ConfigClockSource_11
   3952            {
   3953              case TIM_CLOCKSOURCE_INTERNAL:
   3954              { 
   3955                assert_param(IS_TIM_INSTANCE(htim->Instance));      
   3956                /* Disable slave mode to clock the prescaler directly with the internal clock */
   3957                htim->Instance->SMCR &= ~TIM_SMCR_SMS;
   \                     ??HAL_TIM_ConfigClockSource_9: (+1)
   \   00000060   0x6801             LDR      R1,[R0, #+0]
   \   00000062   0x.... 0x....      LDR.W    R3,??DataTable37  ;; 0xfffefff8
   \   00000066   0x688A             LDR      R2,[R1, #+8]
   \   00000068   0x401A             ANDS     R2,R3,R2
   \   0000006A   0xE08E             B.N      ??HAL_TIM_ConfigClockSource_12
   3958              }
   3959              break;
   3960              
   3961              case TIM_CLOCKSOURCE_ETRMODE1:
   3962              {
   3963                assert_param(IS_TIM_ETR_INSTANCE(htim->Instance));
   3964                /* Configure the ETR Clock source */
   3965                TIM_ETR_SetConfig(htim->Instance, 
   3966                                  sClockSourceConfig->ClockPrescaler, 
   3967                                  sClockSourceConfig->ClockPolarity, 
   3968                                  sClockSourceConfig->ClockFilter);
   \                     ??HAL_TIM_ConfigClockSource_8: (+1)
   \   0000006C   0x6804             LDR      R4,[R0, #+0]
   \   0000006E   0x68CA             LDR      R2,[R1, #+12]
   \   00000070   0x684B             LDR      R3,[R1, #+4]
   \   00000072   0x6889             LDR      R1,[R1, #+8]
   \   00000074   0x68A5             LDR      R5,[R4, #+8]
   \   00000076   0xF425 0x457F      BIC      R5,R5,#0xFF00
   \   0000007A   0x4329             ORRS     R1,R1,R5
   \   0000007C   0x4319             ORRS     R1,R3,R1
   3969                /* Get the TIMx SMCR register value */
   3970                tmpsmcr = htim->Instance->SMCR;
   3971                /* Reset the SMS and TS Bits */
   3972                tmpsmcr &= ~(TIM_SMCR_SMS | TIM_SMCR_TS);
   3973                /* Select the External clock mode1 and the ETRF trigger */
   3974                tmpsmcr |= (TIM_SLAVEMODE_EXTERNAL1 | TIM_CLOCKSOURCE_ETRMODE1);
   3975                /* Write to TIMx SMCR */
   3976                htim->Instance->SMCR = tmpsmcr;
   \   0000007E   0x.... 0x....      LDR.W    R3,??DataTable37_3  ;; 0xfffeff88
   \   00000082   0xEA41 0x2102      ORR      R1,R1,R2, LSL #+8
   \   00000086   0x60A1             STR      R1,[R4, #+8]
   \   00000088   0x6801             LDR      R1,[R0, #+0]
   \   0000008A   0x688A             LDR      R2,[R1, #+8]
   \   0000008C   0x401A             ANDS     R2,R3,R2
   \   0000008E   0xF042 0x0277      ORR      R2,R2,#0x77
   \   00000092   0xE07A             B.N      ??HAL_TIM_ConfigClockSource_12
   3977              }
   3978              break;
   3979              
   3980              case TIM_CLOCKSOURCE_ETRMODE2:
   3981              {
   3982                assert_param(IS_TIM_ETR_INSTANCE(htim->Instance));
   3983                /* Configure the ETR Clock source */
   3984                TIM_ETR_SetConfig(htim->Instance, 
   3985                                  sClockSourceConfig->ClockPrescaler, 
   3986                                  sClockSourceConfig->ClockPolarity,
   3987                                  sClockSourceConfig->ClockFilter);
   \                     ??HAL_TIM_ConfigClockSource_10: (+1)
   \   00000094   0x6804             LDR      R4,[R0, #+0]
   \   00000096   0x68CA             LDR      R2,[R1, #+12]
   \   00000098   0x684B             LDR      R3,[R1, #+4]
   \   0000009A   0x6889             LDR      R1,[R1, #+8]
   \   0000009C   0x68A5             LDR      R5,[R4, #+8]
   \   0000009E   0xF425 0x457F      BIC      R5,R5,#0xFF00
   \   000000A2   0x4329             ORRS     R1,R1,R5
   \   000000A4   0x4319             ORRS     R1,R3,R1
   \   000000A6   0xEA41 0x2102      ORR      R1,R1,R2, LSL #+8
   \   000000AA   0x60A1             STR      R1,[R4, #+8]
   3988                /* Enable the External clock mode2 */
   3989                htim->Instance->SMCR |= TIM_SMCR_ECE;
   \   000000AC   0x6801             LDR      R1,[R0, #+0]
   \   000000AE   0x688A             LDR      R2,[R1, #+8]
   \   000000B0   0xF442 0x4280      ORR      R2,R2,#0x4000
   \   000000B4   0xE069             B.N      ??HAL_TIM_ConfigClockSource_12
   3990              }
   3991              break;
   3992              
   3993              case TIM_CLOCKSOURCE_TI1:
   3994              {
   3995                assert_param(IS_TIM_CLOCKSOURCE_TIX_INSTANCE(htim->Instance));
   3996                TIM_TI1_ConfigInputStage(htim->Instance, 
   3997                                  sClockSourceConfig->ClockPolarity, 
   3998                                  sClockSourceConfig->ClockFilter);
   \                     ??HAL_TIM_ConfigClockSource_6: (+1)
   \   000000B6   0x68CA             LDR      R2,[R1, #+12]
   \   000000B8   0x684B             LDR      R3,[R1, #+4]
   \   000000BA   0x6801             LDR      R1,[R0, #+0]
   \   000000BC   0x3118             ADDS     R1,R1,#+24
   \   000000BE   0x688C             LDR      R4,[R1, #+8]
   \   000000C0   0x688D             LDR      R5,[R1, #+8]
   \   000000C2   0x086D             LSRS     R5,R5,#+1
   \   000000C4   0x006D             LSLS     R5,R5,#+1
   \   000000C6   0x608D             STR      R5,[R1, #+8]
   \   000000C8   0x680D             LDR      R5,[R1, #+0]
   \   000000CA   0xF025 0x05F0      BIC      R5,R5,#0xF0
   \   000000CE   0xEA45 0x1202      ORR      R2,R5,R2, LSL #+4
   \   000000D2   0x600A             STR      R2,[R1, #+0]
   \   000000D4   0xF024 0x020A      BIC      R2,R4,#0xA
   \   000000D8   0x431A             ORRS     R2,R3,R2
   \   000000DA   0x608A             STR      R2,[R1, #+8]
   3999                TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI1);
   \   000000DC   0x6801             LDR      R1,[R0, #+0]
   \   000000DE   0x688A             LDR      R2,[R1, #+8]
   \   000000E0   0xF022 0x0270      BIC      R2,R2,#0x70
   \   000000E4   0xF042 0x0257      ORR      R2,R2,#0x57
   \   000000E8   0xE04F             B.N      ??HAL_TIM_ConfigClockSource_12
   4000              }
   4001              break;
   4002              case TIM_CLOCKSOURCE_TI2:
   4003              {
   4004                assert_param(IS_TIM_CLOCKSOURCE_TIX_INSTANCE(htim->Instance));
   4005                TIM_TI2_ConfigInputStage(htim->Instance, 
   4006                                  sClockSourceConfig->ClockPolarity, 
   4007                                  sClockSourceConfig->ClockFilter);
   \                     ??HAL_TIM_ConfigClockSource_7: (+1)
   \   000000EA   0x68CA             LDR      R2,[R1, #+12]
   \   000000EC   0x684B             LDR      R3,[R1, #+4]
   \   000000EE   0x6801             LDR      R1,[R0, #+0]
   \   000000F0   0x3118             ADDS     R1,R1,#+24
   \   000000F2   0x688C             LDR      R4,[R1, #+8]
   \   000000F4   0xF024 0x0410      BIC      R4,R4,#0x10
   \   000000F8   0x608C             STR      R4,[R1, #+8]
   \   000000FA   0x680C             LDR      R4,[R1, #+0]
   \   000000FC   0x688D             LDR      R5,[R1, #+8]
   \   000000FE   0xF424 0x4470      BIC      R4,R4,#0xF000
   \   00000102   0xEA44 0x3202      ORR      R2,R4,R2, LSL #+12
   \   00000106   0x600A             STR      R2,[R1, #+0]
   \   00000108   0xF025 0x02A0      BIC      R2,R5,#0xA0
   \   0000010C   0xEA42 0x1203      ORR      R2,R2,R3, LSL #+4
   \   00000110   0x608A             STR      R2,[R1, #+8]
   4008                TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI2);
   \   00000112   0x6801             LDR      R1,[R0, #+0]
   \   00000114   0x688A             LDR      R2,[R1, #+8]
   \   00000116   0xF022 0x0270      BIC      R2,R2,#0x70
   \   0000011A   0xF042 0x0267      ORR      R2,R2,#0x67
   \   0000011E   0xE034             B.N      ??HAL_TIM_ConfigClockSource_12
   4009              }
   4010              break;
   4011              case TIM_CLOCKSOURCE_TI1ED:
   4012              {
   4013                assert_param(IS_TIM_CLOCKSOURCE_TIX_INSTANCE(htim->Instance));
   4014                TIM_TI1_ConfigInputStage(htim->Instance, 
   4015                                  sClockSourceConfig->ClockPolarity,
   4016                                  sClockSourceConfig->ClockFilter);
   \                     ??HAL_TIM_ConfigClockSource_5: (+1)
   \   00000120   0x68CA             LDR      R2,[R1, #+12]
   \   00000122   0x684B             LDR      R3,[R1, #+4]
   \   00000124   0x6801             LDR      R1,[R0, #+0]
   \   00000126   0x3118             ADDS     R1,R1,#+24
   \   00000128   0x688C             LDR      R4,[R1, #+8]
   \   0000012A   0x688D             LDR      R5,[R1, #+8]
   \   0000012C   0x086D             LSRS     R5,R5,#+1
   \   0000012E   0x006D             LSLS     R5,R5,#+1
   \   00000130   0x608D             STR      R5,[R1, #+8]
   \   00000132   0x680D             LDR      R5,[R1, #+0]
   \   00000134   0xF025 0x05F0      BIC      R5,R5,#0xF0
   \   00000138   0xEA45 0x1202      ORR      R2,R5,R2, LSL #+4
   \   0000013C   0x600A             STR      R2,[R1, #+0]
   \   0000013E   0xF024 0x020A      BIC      R2,R4,#0xA
   \   00000142   0x431A             ORRS     R2,R3,R2
   \   00000144   0x608A             STR      R2,[R1, #+8]
   4017                TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI1ED);
   \   00000146   0x6801             LDR      R1,[R0, #+0]
   \   00000148   0x688A             LDR      R2,[R1, #+8]
   \   0000014A   0xF022 0x0270      BIC      R2,R2,#0x70
   \   0000014E   0xF042 0x0247      ORR      R2,R2,#0x47
   \   00000152   0xE01A             B.N      ??HAL_TIM_ConfigClockSource_12
   4018              }
   4019              break;
   4020              case TIM_CLOCKSOURCE_ITR0:
   4021              {
   4022                assert_param(IS_TIM_CLOCKSOURCE_ITRX_INSTANCE(htim->Instance));
   4023                TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_ITR0);
   \                     ??HAL_TIM_ConfigClockSource_1: (+1)
   \   00000154   0x6801             LDR      R1,[R0, #+0]
   \   00000156   0x688A             LDR      R2,[R1, #+8]
   \   00000158   0xF022 0x0270      BIC      R2,R2,#0x70
   \   0000015C   0xF042 0x0207      ORR      R2,R2,#0x7
   \   00000160   0xE013             B.N      ??HAL_TIM_ConfigClockSource_12
   4024              }
   4025              break;
   4026              case TIM_CLOCKSOURCE_ITR1:
   4027              {
   4028                assert_param(IS_TIM_CLOCKSOURCE_ITRX_INSTANCE(htim->Instance));
   4029                TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_ITR1);
   \                     ??HAL_TIM_ConfigClockSource_2: (+1)
   \   00000162   0x6801             LDR      R1,[R0, #+0]
   \   00000164   0x688A             LDR      R2,[R1, #+8]
   \   00000166   0xF022 0x0270      BIC      R2,R2,#0x70
   \   0000016A   0xF042 0x0217      ORR      R2,R2,#0x17
   \   0000016E   0xE00C             B.N      ??HAL_TIM_ConfigClockSource_12
   4030              }
   4031              break;
   4032              case TIM_CLOCKSOURCE_ITR2:
   4033              {
   4034                assert_param(IS_TIM_CLOCKSOURCE_ITRX_INSTANCE(htim->Instance));
   4035                TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_ITR2);
   \                     ??HAL_TIM_ConfigClockSource_3: (+1)
   \   00000170   0x6801             LDR      R1,[R0, #+0]
   \   00000172   0x688A             LDR      R2,[R1, #+8]
   \   00000174   0xF022 0x0270      BIC      R2,R2,#0x70
   \   00000178   0xF042 0x0227      ORR      R2,R2,#0x27
   \   0000017C   0xE005             B.N      ??HAL_TIM_ConfigClockSource_12
   4036              }
   4037              break;
   4038              case TIM_CLOCKSOURCE_ITR3:
   4039              {
   4040                assert_param(IS_TIM_CLOCKSOURCE_ITRX_INSTANCE(htim->Instance));
   4041                TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_ITR3);
   \                     ??HAL_TIM_ConfigClockSource_4: (+1)
   \   0000017E   0x6801             LDR      R1,[R0, #+0]
   \   00000180   0x688A             LDR      R2,[R1, #+8]
   \   00000182   0xF022 0x0270      BIC      R2,R2,#0x70
   \   00000186   0xF042 0x0237      ORR      R2,R2,#0x37
   \                     ??HAL_TIM_ConfigClockSource_12: (+1)
   \   0000018A   0x608A             STR      R2,[R1, #+8]
   4042              }
   4043              break;
   4044              
   4045              default:
   4046              break;    
   4047            }
   4048            htim->State = HAL_TIM_STATE_READY;
   \                     ??HAL_TIM_ConfigClockSource_11: (+1)
   \   0000018C   0x2101             MOVS     R1,#+1
   \   0000018E   0xF880 0x1039      STRB     R1,[R0, #+57]
   4049            
   4050            __HAL_UNLOCK(htim);
   \   00000192   0x2100             MOVS     R1,#+0
   \   00000194   0xF880 0x1038      STRB     R1,[R0, #+56]
   4051            
   4052            return HAL_OK;
   \   00000198   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_ConfigClockSource_0: (+1)
   \   0000019A   0xBC30             POP      {R4,R5}
   \   0000019C   0x4770             BX       LR               ;; return
   4053          }
   4054          
   4055          /**
   4056            * @brief  Selects the signal connected to the TI1 input: direct from CH1_input
   4057            *         or a XOR combination between CH1_input, CH2_input & CH3_input
   4058            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   4059            *                the configuration information for TIM module.
   4060            * @param  TI1_Selection: Indicate whether or not channel 1 is connected to the
   4061            *         output of a XOR gate.
   4062            *         This parameter can be one of the following values:
   4063            *            @arg TIM_TI1SELECTION_CH1: The TIMx_CH1 pin is connected to TI1 input
   4064            *            @arg TIM_TI1SELECTION_XORCOMBINATION: The TIMx_CH1, CH2 and CH3
   4065            *            pins are connected to the TI1 input (XOR combination)
   4066            * @retval HAL status
   4067            */

   \                                 In section .text, align 2, keep-with-next
   4068          HAL_StatusTypeDef HAL_TIM_ConfigTI1Input(TIM_HandleTypeDef *htim, uint32_t TI1_Selection)
   4069          {
   4070            uint32_t tmpcr2 = 0;
   4071            
   4072            /* Check the parameters */
   4073            assert_param(IS_TIM_XOR_INSTANCE(htim->Instance)); 
   4074            assert_param(IS_TIM_TI1SELECTION(TI1_Selection));
   4075          
   4076            /* Get the TIMx CR2 register value */
   4077            tmpcr2 = htim->Instance->CR2;
   \                     HAL_TIM_ConfigTI1Input: (+1)
   \   00000000   0x6800             LDR      R0,[R0, #+0]
   \   00000002   0x6842             LDR      R2,[R0, #+4]
   4078          
   4079            /* Reset the TI1 selection */
   4080            tmpcr2 &= ~TIM_CR2_TI1S;
   4081          
   4082            /* Set the TI1 selection */
   4083            tmpcr2 |= TI1_Selection;
   4084            
   4085            /* Write to TIMxCR2 */
   4086            htim->Instance->CR2 = tmpcr2;
   \   00000004   0xF022 0x0280      BIC      R2,R2,#0x80
   \   00000008   0x4311             ORRS     R1,R1,R2
   \   0000000A   0x6041             STR      R1,[R0, #+4]
   4087          
   4088            return HAL_OK;
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x4770             BX       LR               ;; return
   4089          }
   4090          
   4091          /**
   4092            * @brief  Configures the TIM in Slave mode
   4093            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   4094            *                the configuration information for TIM module.
   4095            * @param  sSlaveConfig: pointer to a TIM_SlaveConfigTypeDef structure that
   4096            *         contains the selected trigger (internal trigger input, filtered
   4097            *         timer input or external trigger input) and the ) and the Slave 
   4098            *         mode (Disable, Reset, Gated, Trigger, External clock mode 1). 
   4099            * @retval HAL status
   4100            */

   \                                 In section .text, align 2, keep-with-next
   4101          HAL_StatusTypeDef HAL_TIM_SlaveConfigSynchronization(TIM_HandleTypeDef *htim, TIM_SlaveConfigTypeDef * sSlaveConfig)
   4102          {
   \                     HAL_TIM_SlaveConfigSynchronization: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
   4103            uint32_t tmpsmcr  = 0;
   4104            uint32_t tmpccmr1 = 0;
   4105            uint32_t tmpccer = 0;
   4106          
   4107            /* Check the parameters */
   4108            assert_param(IS_TIM_SLAVE_INSTANCE(htim->Instance));
   4109            assert_param(IS_TIM_SLAVE_MODE(sSlaveConfig->SlaveMode));
   4110            assert_param(IS_TIM_TRIGGER_SELECTION(sSlaveConfig->InputTrigger));
   4111             
   4112            __HAL_LOCK(htim);
   \   00000002   0xF890 0x2038      LDRB     R2,[R0, #+56]
   \   00000006   0x2A01             CMP      R2,#+1
   \   00000008   0xBF08             IT       EQ 
   \   0000000A   0x2002             MOVEQ    R0,#+2
   \   0000000C   0xD066             BEQ.N    ??HAL_TIM_SlaveConfigSynchronization_0
   \   0000000E   0x2201             MOVS     R2,#+1
   \   00000010   0xF880 0x2038      STRB     R2,[R0, #+56]
   4113            
   4114            htim->State = HAL_TIM_STATE_BUSY;
   \   00000014   0x2202             MOVS     R2,#+2
   \   00000016   0xF880 0x2039      STRB     R2,[R0, #+57]
   4115          
   4116            /* Get the TIMx SMCR register value */
   4117            tmpsmcr = htim->Instance->SMCR;
   \   0000001A   0x6802             LDR      R2,[R0, #+0]
   \   0000001C   0x6893             LDR      R3,[R2, #+8]
   4118          
   4119            /* Reset the Trigger Selection Bits */
   4120            tmpsmcr &= ~TIM_SMCR_TS;
   4121            /* Set the Input Trigger source */
   4122            tmpsmcr |= sSlaveConfig->InputTrigger;
   4123          
   4124            /* Reset the slave mode Bits */
   4125            tmpsmcr &= ~TIM_SMCR_SMS;
   4126            /* Set the slave mode */
   4127            tmpsmcr |= sSlaveConfig->SlaveMode;
   4128          
   4129            /* Write to TIMx SMCR */
   4130            htim->Instance->SMCR = tmpsmcr;
   \   0000001E   0x684C             LDR      R4,[R1, #+4]
   \   00000020   0xF023 0x0370      BIC      R3,R3,#0x70
   \   00000024   0x4323             ORRS     R3,R4,R3
   \   00000026   0x.... 0x....      LDR.W    R4,??DataTable37  ;; 0xfffefff8
   \   0000002A   0x4023             ANDS     R3,R4,R3
   \   0000002C   0x680C             LDR      R4,[R1, #+0]
   \   0000002E   0x4323             ORRS     R3,R4,R3
   \   00000030   0x6093             STR      R3,[R2, #+8]
   4131            
   4132            /* Configure the trigger prescaler, filter, and polarity */
   4133            switch (sSlaveConfig->InputTrigger)
   \   00000032   0x684A             LDR      R2,[R1, #+4]
   \   00000034   0x2A40             CMP      R2,#+64
   \   00000036   0xD012             BEQ.N    ??HAL_TIM_SlaveConfigSynchronization_1
   \   00000038   0x2A50             CMP      R2,#+80
   \   0000003A   0xD021             BEQ.N    ??HAL_TIM_SlaveConfigSynchronization_2
   \   0000003C   0x2A60             CMP      R2,#+96
   \   0000003E   0xD032             BEQ.N    ??HAL_TIM_SlaveConfigSynchronization_3
   \   00000040   0x2A70             CMP      R2,#+112
   \   00000042   0xD144             BNE.N    ??HAL_TIM_SlaveConfigSynchronization_4
   4134            {
   4135            case TIM_TS_ETRF:
   4136              {
   4137                /* Check the parameters */
   4138                assert_param(IS_TIM_ETR_INSTANCE(htim->Instance));
   4139                assert_param(IS_TIM_TRIGGERPRESCALER(sSlaveConfig->TriggerPrescaler));
   4140                assert_param(IS_TIM_TRIGGERPOLARITY(sSlaveConfig->TriggerPolarity));
   4141                assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
   4142                /* Configure the ETR Trigger source */
   4143                TIM_ETR_SetConfig(htim->Instance, 
   4144                                  sSlaveConfig->TriggerPrescaler, 
   4145                                  sSlaveConfig->TriggerPolarity, 
   4146                                  sSlaveConfig->TriggerFilter);
   \   00000044   0x6804             LDR      R4,[R0, #+0]
   \   00000046   0x690A             LDR      R2,[R1, #+16]
   \   00000048   0x688B             LDR      R3,[R1, #+8]
   \   0000004A   0x68C9             LDR      R1,[R1, #+12]
   \   0000004C   0x68A5             LDR      R5,[R4, #+8]
   \   0000004E   0xF425 0x457F      BIC      R5,R5,#0xFF00
   \   00000052   0x4329             ORRS     R1,R1,R5
   \   00000054   0x4319             ORRS     R1,R3,R1
   \   00000056   0xEA41 0x2102      ORR      R1,R1,R2, LSL #+8
   \   0000005A   0x60A1             STR      R1,[R4, #+8]
   4147              }
   4148              break;
   \   0000005C   0xE037             B.N      ??HAL_TIM_SlaveConfigSynchronization_4
   4149              
   4150            case TIM_TS_TI1F_ED:
   4151              {
   4152                /* Check the parameters */
   4153                assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   4154                assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
   4155                
   4156                /* Disable the Channel 1: Reset the CC1E Bit */
   4157                tmpccer = htim->Instance->CCER;
   \                     ??HAL_TIM_SlaveConfigSynchronization_1: (+1)
   \   0000005E   0x6802             LDR      R2,[R0, #+0]
   \   00000060   0x6A13             LDR      R3,[R2, #+32]
   4158                htim->Instance->CCER &= ~TIM_CCER_CC1E;
   \   00000062   0x6A14             LDR      R4,[R2, #+32]
   \   00000064   0x0864             LSRS     R4,R4,#+1
   \   00000066   0x0064             LSLS     R4,R4,#+1
   \   00000068   0x6214             STR      R4,[R2, #+32]
   4159                tmpccmr1 = htim->Instance->CCMR1;    
   \   0000006A   0x6802             LDR      R2,[R0, #+0]
   \   0000006C   0x6994             LDR      R4,[R2, #+24]
   4160                
   4161                /* Set the filter */
   4162                tmpccmr1 &= ~TIM_CCMR1_IC1F;
   4163                tmpccmr1 |= ((sSlaveConfig->TriggerFilter) << 4);
   4164                
   4165                /* Write to TIMx CCMR1 and CCER registers */
   4166                htim->Instance->CCMR1 = tmpccmr1;
   \   0000006E   0x6909             LDR      R1,[R1, #+16]
   \   00000070   0xF024 0x04F0      BIC      R4,R4,#0xF0
   \   00000074   0xEA44 0x1101      ORR      R1,R4,R1, LSL #+4
   \   00000078   0x6191             STR      R1,[R2, #+24]
   4167                htim->Instance->CCER = tmpccer;                               
   \   0000007A   0x6801             LDR      R1,[R0, #+0]
   \   0000007C   0x620B             STR      R3,[R1, #+32]
   4168                                         
   4169              }
   4170              break;
   \   0000007E   0xE026             B.N      ??HAL_TIM_SlaveConfigSynchronization_4
   4171              
   4172            case TIM_TS_TI1FP1:
   4173              {
   4174                /* Check the parameters */
   4175                assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   4176                assert_param(IS_TIM_TRIGGERPOLARITY(sSlaveConfig->TriggerPolarity));
   4177                assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
   4178          
   4179                /* Configure TI1 Filter and Polarity */
   4180                TIM_TI1_ConfigInputStage(htim->Instance,
   4181                                         sSlaveConfig->TriggerPolarity,
   4182                                         sSlaveConfig->TriggerFilter);
   \                     ??HAL_TIM_SlaveConfigSynchronization_2: (+1)
   \   00000080   0x690A             LDR      R2,[R1, #+16]
   \   00000082   0x688B             LDR      R3,[R1, #+8]
   \   00000084   0x6801             LDR      R1,[R0, #+0]
   \   00000086   0x3118             ADDS     R1,R1,#+24
   \   00000088   0x688C             LDR      R4,[R1, #+8]
   \   0000008A   0x688D             LDR      R5,[R1, #+8]
   \   0000008C   0x086D             LSRS     R5,R5,#+1
   \   0000008E   0x006D             LSLS     R5,R5,#+1
   \   00000090   0x608D             STR      R5,[R1, #+8]
   \   00000092   0x680D             LDR      R5,[R1, #+0]
   \   00000094   0xF025 0x05F0      BIC      R5,R5,#0xF0
   \   00000098   0xEA45 0x1202      ORR      R2,R5,R2, LSL #+4
   \   0000009C   0x600A             STR      R2,[R1, #+0]
   \   0000009E   0xF024 0x020A      BIC      R2,R4,#0xA
   \   000000A2   0x431A             ORRS     R2,R3,R2
   \   000000A4   0xE012             B.N      ??HAL_TIM_SlaveConfigSynchronization_5
   4183              }
   4184              break;
   4185              
   4186            case TIM_TS_TI2FP2:
   4187              {
   4188                /* Check the parameters */
   4189                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   4190                assert_param(IS_TIM_TRIGGERPOLARITY(sSlaveConfig->TriggerPolarity));
   4191                assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
   4192                
   4193                /* Configure TI2 Filter and Polarity */
   4194                TIM_TI2_ConfigInputStage(htim->Instance,
   4195                                          sSlaveConfig->TriggerPolarity,
   4196                                          sSlaveConfig->TriggerFilter);
   \                     ??HAL_TIM_SlaveConfigSynchronization_3: (+1)
   \   000000A6   0x690A             LDR      R2,[R1, #+16]
   \   000000A8   0x688B             LDR      R3,[R1, #+8]
   \   000000AA   0x6801             LDR      R1,[R0, #+0]
   \   000000AC   0x3118             ADDS     R1,R1,#+24
   \   000000AE   0x688C             LDR      R4,[R1, #+8]
   \   000000B0   0xF024 0x0410      BIC      R4,R4,#0x10
   \   000000B4   0x608C             STR      R4,[R1, #+8]
   \   000000B6   0x680C             LDR      R4,[R1, #+0]
   \   000000B8   0x688D             LDR      R5,[R1, #+8]
   \   000000BA   0xF424 0x4470      BIC      R4,R4,#0xF000
   \   000000BE   0xEA44 0x3202      ORR      R2,R4,R2, LSL #+12
   \   000000C2   0x600A             STR      R2,[R1, #+0]
   \   000000C4   0xF025 0x02A0      BIC      R2,R5,#0xA0
   \   000000C8   0xEA42 0x1203      ORR      R2,R2,R3, LSL #+4
   \                     ??HAL_TIM_SlaveConfigSynchronization_5: (+1)
   \   000000CC   0x608A             STR      R2,[R1, #+8]
   4197              }
   4198              break;
   4199              
   4200            case TIM_TS_ITR0:
   4201              {
   4202                /* Check the parameter */
   4203                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   4204              }
   4205              break;
   4206              
   4207            case TIM_TS_ITR1:
   4208              {
   4209                /* Check the parameter */
   4210                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   4211              }
   4212              break;
   4213              
   4214            case TIM_TS_ITR2:
   4215              {
   4216                /* Check the parameter */
   4217                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   4218              }
   4219              break;
   4220              
   4221            case TIM_TS_ITR3:
   4222              {
   4223                /* Check the parameter */
   4224                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   4225              }
   4226              break;
   4227                 
   4228            default:
   4229              break;
   4230            }
   4231            
   4232            htim->State = HAL_TIM_STATE_READY;
   \                     ??HAL_TIM_SlaveConfigSynchronization_4: (+1)
   \   000000CE   0x2101             MOVS     R1,#+1
   \   000000D0   0xF880 0x1039      STRB     R1,[R0, #+57]
   4233               
   4234            __HAL_UNLOCK(htim);  
   \   000000D4   0x2100             MOVS     R1,#+0
   \   000000D6   0xF880 0x1038      STRB     R1,[R0, #+56]
   4235            
   4236            return HAL_OK;
   \   000000DA   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_SlaveConfigSynchronization_0: (+1)
   \   000000DC   0xBC30             POP      {R4,R5}
   \   000000DE   0x4770             BX       LR               ;; return
   4237          } 
   4238          
   4239          /**
   4240            * @brief  Configures the TIM in Slave mode in interrupt mode
   4241            * @param  htim: TIM handle.
   4242            * @param  sSlaveConfig: pointer to a TIM_SlaveConfigTypeDef structure that
   4243            *         contains the selected trigger (internal trigger input, filtered
   4244            *         timer input or external trigger input) and the ) and the Slave 
   4245            *         mode (Disable, Reset, Gated, Trigger, External clock mode 1). 
   4246            * @retval HAL status
   4247            */

   \                                 In section .text, align 2, keep-with-next
   4248          HAL_StatusTypeDef HAL_TIM_SlaveConfigSynchronization_IT(TIM_HandleTypeDef *htim, 
   4249                                                                  TIM_SlaveConfigTypeDef * sSlaveConfig)
   4250          {
   \                     HAL_TIM_SlaveConfigSynchronization_IT: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
   4251            /* Check the parameters */
   4252            assert_param(IS_TIM_SLAVE_INSTANCE(htim->Instance));
   4253            assert_param(IS_TIM_SLAVE_MODE(sSlaveConfig->SlaveMode));
   4254            assert_param(IS_TIM_TRIGGER_SELECTION(sSlaveConfig->InputTrigger));
   4255            
   4256            __HAL_LOCK(htim);
   \   00000002   0xF890 0x2038      LDRB     R2,[R0, #+56]
   \   00000006   0x2A01             CMP      R2,#+1
   \   00000008   0xBF08             IT       EQ 
   \   0000000A   0x2002             MOVEQ    R0,#+2
   \   0000000C   0xD072             BEQ.N    ??HAL_TIM_SlaveConfigSynchronization_IT_0
   \   0000000E   0x2201             MOVS     R2,#+1
   \   00000010   0xF880 0x2038      STRB     R2,[R0, #+56]
   4257          
   4258            htim->State = HAL_TIM_STATE_BUSY;
   \   00000014   0x2202             MOVS     R2,#+2
   \   00000016   0xF880 0x2039      STRB     R2,[R0, #+57]
   4259            
   4260            TIM_SlaveTimer_SetConfig(htim, sSlaveConfig);
   \   0000001A   0x6802             LDR      R2,[R0, #+0]
   \   0000001C   0x6893             LDR      R3,[R2, #+8]
   \   0000001E   0x684C             LDR      R4,[R1, #+4]
   \   00000020   0xF023 0x0370      BIC      R3,R3,#0x70
   \   00000024   0x4323             ORRS     R3,R4,R3
   \   00000026   0x.... 0x....      LDR.W    R4,??DataTable37  ;; 0xfffefff8
   \   0000002A   0x4023             ANDS     R3,R4,R3
   \   0000002C   0x680C             LDR      R4,[R1, #+0]
   \   0000002E   0x4323             ORRS     R3,R4,R3
   \   00000030   0x6093             STR      R3,[R2, #+8]
   \   00000032   0x684A             LDR      R2,[R1, #+4]
   \   00000034   0x2A40             CMP      R2,#+64
   \   00000036   0xD02F             BEQ.N    ??HAL_TIM_SlaveConfigSynchronization_IT_1
   \   00000038   0x2A50             CMP      R2,#+80
   \   0000003A   0xD019             BEQ.N    ??HAL_TIM_SlaveConfigSynchronization_IT_2
   \   0000003C   0x2A60             CMP      R2,#+96
   \   0000003E   0xD002             BEQ.N    ??HAL_TIM_SlaveConfigSynchronization_IT_3
   \   00000040   0x2A70             CMP      R2,#+112
   \   00000042   0xD03A             BEQ.N    ??HAL_TIM_SlaveConfigSynchronization_IT_4
   \   00000044   0xE045             B.N      ??HAL_TIM_SlaveConfigSynchronization_IT_5
   \                     ??HAL_TIM_SlaveConfigSynchronization_IT_3: (+1)
   \   00000046   0x690A             LDR      R2,[R1, #+16]
   \   00000048   0x688B             LDR      R3,[R1, #+8]
   \   0000004A   0x6801             LDR      R1,[R0, #+0]
   \   0000004C   0x3118             ADDS     R1,R1,#+24
   \   0000004E   0x688C             LDR      R4,[R1, #+8]
   \   00000050   0xF024 0x0410      BIC      R4,R4,#0x10
   \   00000054   0x608C             STR      R4,[R1, #+8]
   \   00000056   0x680C             LDR      R4,[R1, #+0]
   \   00000058   0x688D             LDR      R5,[R1, #+8]
   \   0000005A   0xF424 0x4470      BIC      R4,R4,#0xF000
   \   0000005E   0xEA44 0x3202      ORR      R2,R4,R2, LSL #+12
   \   00000062   0x600A             STR      R2,[R1, #+0]
   \   00000064   0xF025 0x02A0      BIC      R2,R5,#0xA0
   \   00000068   0xEA42 0x1203      ORR      R2,R2,R3, LSL #+4
   \   0000006C   0x608A             STR      R2,[R1, #+8]
   \   0000006E   0xE030             B.N      ??HAL_TIM_SlaveConfigSynchronization_IT_5
   \                     ??HAL_TIM_SlaveConfigSynchronization_IT_2: (+1)
   \   00000070   0x690A             LDR      R2,[R1, #+16]
   \   00000072   0x688B             LDR      R3,[R1, #+8]
   \   00000074   0x6801             LDR      R1,[R0, #+0]
   \   00000076   0x3118             ADDS     R1,R1,#+24
   \   00000078   0x688C             LDR      R4,[R1, #+8]
   \   0000007A   0x688D             LDR      R5,[R1, #+8]
   \   0000007C   0x086D             LSRS     R5,R5,#+1
   \   0000007E   0x006D             LSLS     R5,R5,#+1
   \   00000080   0x608D             STR      R5,[R1, #+8]
   \   00000082   0x680D             LDR      R5,[R1, #+0]
   \   00000084   0xF025 0x05F0      BIC      R5,R5,#0xF0
   \   00000088   0xEA45 0x1202      ORR      R2,R5,R2, LSL #+4
   \   0000008C   0x600A             STR      R2,[R1, #+0]
   \   0000008E   0xF024 0x020A      BIC      R2,R4,#0xA
   \   00000092   0x431A             ORRS     R2,R3,R2
   \   00000094   0x608A             STR      R2,[R1, #+8]
   \   00000096   0xE01C             B.N      ??HAL_TIM_SlaveConfigSynchronization_IT_5
   \                     ??HAL_TIM_SlaveConfigSynchronization_IT_1: (+1)
   \   00000098   0x6802             LDR      R2,[R0, #+0]
   \   0000009A   0x6A13             LDR      R3,[R2, #+32]
   \   0000009C   0x6A14             LDR      R4,[R2, #+32]
   \   0000009E   0x0864             LSRS     R4,R4,#+1
   \   000000A0   0x0064             LSLS     R4,R4,#+1
   \   000000A2   0x6214             STR      R4,[R2, #+32]
   \   000000A4   0x6802             LDR      R2,[R0, #+0]
   \   000000A6   0x6994             LDR      R4,[R2, #+24]
   \   000000A8   0x6909             LDR      R1,[R1, #+16]
   \   000000AA   0xF024 0x04F0      BIC      R4,R4,#0xF0
   \   000000AE   0xEA44 0x1101      ORR      R1,R4,R1, LSL #+4
   \   000000B2   0x6191             STR      R1,[R2, #+24]
   \   000000B4   0x6801             LDR      R1,[R0, #+0]
   \   000000B6   0x620B             STR      R3,[R1, #+32]
   \   000000B8   0xE00B             B.N      ??HAL_TIM_SlaveConfigSynchronization_IT_5
   \                     ??HAL_TIM_SlaveConfigSynchronization_IT_4: (+1)
   \   000000BA   0x6804             LDR      R4,[R0, #+0]
   \   000000BC   0x690A             LDR      R2,[R1, #+16]
   \   000000BE   0x688B             LDR      R3,[R1, #+8]
   \   000000C0   0x68C9             LDR      R1,[R1, #+12]
   \   000000C2   0x68A5             LDR      R5,[R4, #+8]
   \   000000C4   0xF425 0x457F      BIC      R5,R5,#0xFF00
   \   000000C8   0x4329             ORRS     R1,R1,R5
   \   000000CA   0x4319             ORRS     R1,R3,R1
   \   000000CC   0xEA41 0x2102      ORR      R1,R1,R2, LSL #+8
   \   000000D0   0x60A1             STR      R1,[R4, #+8]
   4261            
   4262            /* Enable Trigger Interrupt */
   4263            __HAL_TIM_ENABLE_IT(htim, TIM_IT_TRIGGER);
   \                     ??HAL_TIM_SlaveConfigSynchronization_IT_5: (+1)
   \   000000D2   0x6801             LDR      R1,[R0, #+0]
   \   000000D4   0x68CA             LDR      R2,[R1, #+12]
   \   000000D6   0xF042 0x0240      ORR      R2,R2,#0x40
   \   000000DA   0x60CA             STR      R2,[R1, #+12]
   4264            
   4265            /* Disable Trigger DMA request */
   4266            __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_TRIGGER);
   \   000000DC   0x6801             LDR      R1,[R0, #+0]
   \   000000DE   0x68CA             LDR      R2,[R1, #+12]
   \   000000E0   0xF422 0x4280      BIC      R2,R2,#0x4000
   \   000000E4   0x60CA             STR      R2,[R1, #+12]
   4267            
   4268            htim->State = HAL_TIM_STATE_READY;
   \   000000E6   0x2101             MOVS     R1,#+1
   \   000000E8   0xF880 0x1039      STRB     R1,[R0, #+57]
   4269               
   4270            __HAL_UNLOCK(htim);  
   \   000000EC   0x2100             MOVS     R1,#+0
   \   000000EE   0xF880 0x1038      STRB     R1,[R0, #+56]
   4271            
   4272            return HAL_OK;
   \   000000F2   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_SlaveConfigSynchronization_IT_0: (+1)
   \   000000F4   0xBC30             POP      {R4,R5}
   \   000000F6   0x4770             BX       LR               ;; return
   4273          }
   4274          
   4275          /**
   4276            * @brief  Read the captured value from Capture Compare unit
   4277            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   4278            *                the configuration information for TIM module.
   4279            * @param  Channel: TIM Channels to be enabled.
   4280            *          This parameter can be one of the following values:
   4281            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   4282            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   4283            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   4284            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   4285            * @retval Captured value
   4286            */

   \                                 In section .text, align 4, keep-with-next
   4287          uint32_t HAL_TIM_ReadCapturedValue(TIM_HandleTypeDef *htim, uint32_t Channel)
   4288          {
   4289            uint32_t tmpreg = 0;
   4290            
   4291            __HAL_LOCK(htim);
   \                     HAL_TIM_ReadCapturedValue: (+1)
   \   00000000   0xF890 0x3038      LDRB     R3,[R0, #+56]
   \   00000004   0x2200             MOVS     R2,#+0
   \   00000006   0x2B01             CMP      R3,#+1
   \   00000008   0xD101             BNE.N    ??HAL_TIM_ReadCapturedValue_1
   \   0000000A   0x2002             MOVS     R0,#+2
   \   0000000C   0x4770             BX       LR
   \                     ??HAL_TIM_ReadCapturedValue_1: (+1)
   \   0000000E   0x2301             MOVS     R3,#+1
   4292            
   4293            switch (Channel)
   \   00000010   0x290C             CMP      R1,#+12
   \   00000012   0xF880 0x3038      STRB     R3,[R0, #+56]
   \   00000016   0xD81F             BHI.N    ??HAL_TIM_ReadCapturedValue_2
   \   00000018   0xE8DF 0xF001      TBB      [PC, R1]
   \                     ??HAL_TIM_ReadCapturedValue_0:
   \   0000001C   0x07 0x1E          DC8      0x7,0x1E,0x1E,0x1E
   \              0x1E 0x1E    
   \   00000020   0x0E 0x1E          DC8      0xE,0x1E,0x1E,0x1E
   \              0x1E 0x1E    
   \   00000024   0x15 0x1E          DC8      0x15,0x1E,0x1E,0x1E
   \              0x1E 0x1E    
   \   00000028   0x1C 0x00          DC8      0x1C,0x0
   4294            {
   4295              case TIM_CHANNEL_1:
   4296              {
   4297                /* Check the parameters */
   4298                assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   4299                
   4300                /* Return the capture 1 value */
   4301                tmpreg = htim->Instance->CCR1;
   \                     ??HAL_TIM_ReadCapturedValue_3: (+1)
   \   0000002A   0x6801             LDR      R1,[R0, #+0]
   \   0000002C   0x6B4A             LDR      R2,[R1, #+52]
   4302                
   4303                break;
   4304              }
   4305              case TIM_CHANNEL_2:
   4306              {
   4307                /* Check the parameters */
   4308                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   4309                
   4310                /* Return the capture 2 value */
   4311                tmpreg = htim->Instance->CCR2;
   4312                
   4313                break;
   4314              }
   4315              
   4316              case TIM_CHANNEL_3:
   4317              {
   4318                /* Check the parameters */
   4319                assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
   4320                
   4321                /* Return the capture 3 value */
   4322                tmpreg = htim->Instance->CCR3;
   4323                
   4324                break;
   4325              }
   4326              
   4327              case TIM_CHANNEL_4:
   4328              {
   4329                /* Check the parameters */
   4330                assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
   4331                
   4332                /* Return the capture 4 value */
   4333                tmpreg = htim->Instance->CCR4;
   4334                
   4335                break;
   4336              }
   4337              
   4338              default:
   4339              break;  
   4340            }
   4341               
   4342            __HAL_UNLOCK(htim);  
   \   0000002E   0x2100             MOVS     R1,#+0
   \   00000030   0xF880 0x1038      STRB     R1,[R0, #+56]
   4343            return tmpreg;
   \   00000034   0x4610             MOV      R0,R2
   \   00000036   0x4770             BX       LR
   \                     ??HAL_TIM_ReadCapturedValue_4: (+1)
   \   00000038   0x6801             LDR      R1,[R0, #+0]
   \   0000003A   0x6B8A             LDR      R2,[R1, #+56]
   \   0000003C   0x2100             MOVS     R1,#+0
   \   0000003E   0xF880 0x1038      STRB     R1,[R0, #+56]
   \   00000042   0x4610             MOV      R0,R2
   \   00000044   0x4770             BX       LR
   \                     ??HAL_TIM_ReadCapturedValue_5: (+1)
   \   00000046   0x6801             LDR      R1,[R0, #+0]
   \   00000048   0x6BCA             LDR      R2,[R1, #+60]
   \   0000004A   0x2100             MOVS     R1,#+0
   \   0000004C   0xF880 0x1038      STRB     R1,[R0, #+56]
   \   00000050   0x4610             MOV      R0,R2
   \   00000052   0x4770             BX       LR
   \                     ??HAL_TIM_ReadCapturedValue_6: (+1)
   \   00000054   0x6801             LDR      R1,[R0, #+0]
   \   00000056   0x6C0A             LDR      R2,[R1, #+64]
   \                     ??HAL_TIM_ReadCapturedValue_2: (+1)
   \   00000058   0x2100             MOVS     R1,#+0
   \   0000005A   0xF880 0x1038      STRB     R1,[R0, #+56]
   \   0000005E   0x4610             MOV      R0,R2
   \   00000060   0x4770             BX       LR               ;; return
   4344          }
   4345          
   4346          /**
   4347            * @}
   4348            */
   4349            
   4350          /** @defgroup TIM_Exported_Functions_Group9 TIM Callbacks functions
   4351           *  @brief    TIM Callbacks functions 
   4352           *
   4353          @verbatim   
   4354            ==============================================================================
   4355                                  ##### TIM Callbacks functions #####
   4356            ==============================================================================  
   4357           [..]  
   4358             This section provides TIM callback functions:
   4359             (+) Timer Period elapsed callback
   4360             (+) Timer Output Compare callback
   4361             (+) Timer Input capture callback
   4362             (+) Timer Trigger callback
   4363             (+) Timer Error callback
   4364          
   4365          @endverbatim
   4366            * @{
   4367            */
   4368          
   4369          /**
   4370            * @brief  Period elapsed callback in non blocking mode 
   4371            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   4372            *                the configuration information for TIM module.
   4373            * @retval None
   4374            */

   \                                 In section .text, align 2, keep-with-next
   4375          __weak void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
   4376          {
   4377            /* NOTE : This function Should not be modified, when the callback is needed,
   4378                      the __HAL_TIM_PeriodElapsedCallback could be implemented in the user file
   4379             */
   4380            
   4381          }
   \                     HAL_TIM_PeriodElapsedCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   4382          /**
   4383            * @brief  Output Compare callback in non blocking mode 
   4384            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   4385            *                the configuration information for TIM module.
   4386            * @retval None
   4387            */

   \                                 In section .text, align 2, keep-with-next
   4388          __weak void HAL_TIM_OC_DelayElapsedCallback(TIM_HandleTypeDef *htim)
   4389          {
   4390            /* NOTE : This function Should not be modified, when the callback is needed,
   4391                      the __HAL_TIM_OC_DelayElapsedCallback could be implemented in the user file
   4392             */
   4393          }
   \                     HAL_TIM_OC_DelayElapsedCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   4394          /**
   4395            * @brief  Input Capture callback in non blocking mode 
   4396            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   4397            *                the configuration information for TIM module.
   4398            * @retval None
   4399            */

   \                                 In section .text, align 2, keep-with-next
   4400          __weak void HAL_TIM_IC_CaptureCallback(TIM_HandleTypeDef *htim)
   4401          {
   4402            /* NOTE : This function Should not be modified, when the callback is needed,
   4403                      the __HAL_TIM_IC_CaptureCallback could be implemented in the user file
   4404             */
   4405          }
   \                     HAL_TIM_IC_CaptureCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   4406          
   4407          /**
   4408            * @brief  PWM Pulse finished callback in non blocking mode 
   4409            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   4410            *                the configuration information for TIM module.
   4411            * @retval None
   4412            */

   \                                 In section .text, align 2, keep-with-next
   4413          __weak void HAL_TIM_PWM_PulseFinishedCallback(TIM_HandleTypeDef *htim)
   4414          {
   4415            /* NOTE : This function Should not be modified, when the callback is needed,
   4416                      the __HAL_TIM_PWM_PulseFinishedCallback could be implemented in the user file
   4417             */
   4418          }
   \                     HAL_TIM_PWM_PulseFinishedCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   4419          
   4420          /**
   4421            * @brief  Hall Trigger detection callback in non blocking mode 
   4422            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   4423            *                the configuration information for TIM module.
   4424            * @retval None
   4425            */

   \                                 In section .text, align 2, keep-with-next
   4426          __weak void HAL_TIM_TriggerCallback(TIM_HandleTypeDef *htim)
   4427          {
   4428            /* NOTE : This function Should not be modified, when the callback is needed,
   4429                      the HAL_TIM_TriggerCallback could be implemented in the user file
   4430             */
   4431          }
   \                     HAL_TIM_TriggerCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   4432          
   4433          /**
   4434            * @brief  Timer error callback in non blocking mode 
   4435            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   4436            *                the configuration information for TIM module.
   4437            * @retval None
   4438            */

   \                                 In section .text, align 2, keep-with-next
   4439          __weak void HAL_TIM_ErrorCallback(TIM_HandleTypeDef *htim)
   4440          {
   4441            /* NOTE : This function Should not be modified, when the callback is needed,
   4442                      the HAL_TIM_ErrorCallback could be implemented in the user file
   4443             */
   4444          }
   \                     HAL_TIM_ErrorCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   4445          
   4446          /**
   4447            * @}
   4448            */
   4449          
   4450          /** @defgroup TIM_Exported_Functions_Group10 Peripheral State functions 
   4451           *  @brief   Peripheral State functions 
   4452           *
   4453          @verbatim   
   4454            ==============================================================================
   4455                                  ##### Peripheral State functions #####
   4456            ==============================================================================  
   4457            [..]
   4458              This subsection permits to get in run-time the status of the peripheral 
   4459              and the data flow.
   4460          
   4461          @endverbatim
   4462            * @{
   4463            */
   4464          
   4465          /**
   4466            * @brief  Return the TIM Base state
   4467            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   4468            *                the configuration information for TIM module.
   4469            * @retval HAL state
   4470            */

   \                                 In section .text, align 2, keep-with-next
   4471          HAL_TIM_StateTypeDef HAL_TIM_Base_GetState(TIM_HandleTypeDef *htim)
   4472          {
   4473            return htim->State;
   \                     HAL_TIM_Base_GetState: (+1)
   \   00000000   0xF890 0x0039      LDRB     R0,[R0, #+57]
   \   00000004   0x4770             BX       LR               ;; return
   4474          }
   4475          
   4476          /**
   4477            * @brief  Return the TIM OC state
   4478            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   4479            *                the configuration information for TIM module.
   4480            * @retval HAL state
   4481            */

   \                                 In section .text, align 2, keep-with-next
   4482          HAL_TIM_StateTypeDef HAL_TIM_OC_GetState(TIM_HandleTypeDef *htim)
   4483          {
   4484            return htim->State;
   \                     HAL_TIM_OC_GetState: (+1)
   \   00000000   0xF890 0x0039      LDRB     R0,[R0, #+57]
   \   00000004   0x4770             BX       LR               ;; return
   4485          }
   4486          
   4487          /**
   4488            * @brief  Return the TIM PWM state
   4489            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   4490            *                the configuration information for TIM module.
   4491            * @retval HAL state
   4492            */

   \                                 In section .text, align 2, keep-with-next
   4493          HAL_TIM_StateTypeDef HAL_TIM_PWM_GetState(TIM_HandleTypeDef *htim)
   4494          {
   4495            return htim->State;
   \                     HAL_TIM_PWM_GetState: (+1)
   \   00000000   0xF890 0x0039      LDRB     R0,[R0, #+57]
   \   00000004   0x4770             BX       LR               ;; return
   4496          }
   4497          
   4498          /**
   4499            * @brief  Return the TIM Input Capture state
   4500            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   4501            *                the configuration information for TIM module.
   4502            * @retval HAL state
   4503            */

   \                                 In section .text, align 2, keep-with-next
   4504          HAL_TIM_StateTypeDef HAL_TIM_IC_GetState(TIM_HandleTypeDef *htim)
   4505          {
   4506            return htim->State;
   \                     HAL_TIM_IC_GetState: (+1)
   \   00000000   0xF890 0x0039      LDRB     R0,[R0, #+57]
   \   00000004   0x4770             BX       LR               ;; return
   4507          }
   4508          
   4509          /**
   4510            * @brief  Return the TIM One Pulse Mode state
   4511            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   4512            *                the configuration information for TIM module.
   4513            * @retval HAL state
   4514            */

   \                                 In section .text, align 2, keep-with-next
   4515          HAL_TIM_StateTypeDef HAL_TIM_OnePulse_GetState(TIM_HandleTypeDef *htim)
   4516          {
   4517            return htim->State;
   \                     HAL_TIM_OnePulse_GetState: (+1)
   \   00000000   0xF890 0x0039      LDRB     R0,[R0, #+57]
   \   00000004   0x4770             BX       LR               ;; return
   4518          }
   4519          
   4520          /**
   4521            * @brief  Return the TIM Encoder Mode state
   4522            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   4523            *                the configuration information for TIM module.
   4524            * @retval HAL state
   4525            */

   \                                 In section .text, align 2, keep-with-next
   4526          HAL_TIM_StateTypeDef HAL_TIM_Encoder_GetState(TIM_HandleTypeDef *htim)
   4527          {
   4528            return htim->State;
   \                     HAL_TIM_Encoder_GetState: (+1)
   \   00000000   0xF890 0x0039      LDRB     R0,[R0, #+57]
   \   00000004   0x4770             BX       LR               ;; return
   4529          }
   4530          
   4531          /**
   4532            * @}
   4533            */
   4534          
   4535          /**
   4536            * @brief  TIM DMA error callback 
   4537            * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
   4538            *                the configuration information for the specified DMA module.
   4539            * @retval None
   4540            */

   \                                 In section .text, align 4, keep-with-next
   4541          void HAL_TIM_DMAError(DMA_HandleTypeDef *hdma)
   4542          {
   \                     TIM_DMAError: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB081             SUB      SP,SP,#+4
   4543            TIM_HandleTypeDef* htim = ( TIM_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   \   00000004   0x6B80             LDR      R0,[R0, #+56]
   4544            
   4545            htim->State= HAL_TIM_STATE_READY;
   \   00000006   0x2101             MOVS     R1,#+1
   \   00000008   0xF880 0x1039      STRB     R1,[R0, #+57]
   4546             
   4547            HAL_TIM_ErrorCallback(htim);
   \   0000000C   0x.... 0x....      BL       HAL_TIM_ErrorCallback
   4548          }
   \   00000010   0xB001             ADD      SP,SP,#+4
   \   00000012   0xBD00             POP      {PC}             ;; return
   4549          
   4550          /**
   4551            * @brief  TIM DMA Delay Pulse complete callback. 
   4552            * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
   4553            *                the configuration information for the specified DMA module.
   4554            * @retval None
   4555            */

   \                                 In section .text, align 4, keep-with-next
   4556          void HAL_TIM_DMADelayPulseCplt(DMA_HandleTypeDef *hdma)
   4557          {
   \                     TIM_DMADelayPulseCplt: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   4558            TIM_HandleTypeDef* htim = ( TIM_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   \   00000002   0x6B84             LDR      R4,[R0, #+56]
   4559            
   4560            htim->State= HAL_TIM_STATE_READY; 
   \   00000004   0x2101             MOVS     R1,#+1
   \   00000006   0xF884 0x1039      STRB     R1,[R4, #+57]
   4561            
   4562            if (hdma == htim->hdma[TIM_DMA_ID_CC1])
   \   0000000A   0x6A21             LDR      R1,[R4, #+32]
   \   0000000C   0x4288             CMP      R0,R1
   \   0000000E   0xBF08             IT       EQ 
   \   00000010   0x2001             MOVEQ    R0,#+1
   4563            {
   4564              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
   \   00000012   0xD00D             BEQ.N    ??TIM_DMADelayPulseCplt_0
   4565            }
   4566            else if (hdma == htim->hdma[TIM_DMA_ID_CC2])
   \   00000014   0x6A61             LDR      R1,[R4, #+36]
   \   00000016   0x4288             CMP      R0,R1
   \   00000018   0xBF08             IT       EQ 
   \   0000001A   0x2002             MOVEQ    R0,#+2
   4567            {
   4568              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
   \   0000001C   0xD008             BEQ.N    ??TIM_DMADelayPulseCplt_0
   4569            }
   4570            else if (hdma == htim->hdma[TIM_DMA_ID_CC3])
   \   0000001E   0x6AA1             LDR      R1,[R4, #+40]
   \   00000020   0x4288             CMP      R0,R1
   \   00000022   0xBF08             IT       EQ 
   \   00000024   0x2004             MOVEQ    R0,#+4
   4571            {
   4572              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
   \   00000026   0xD003             BEQ.N    ??TIM_DMADelayPulseCplt_0
   4573            }
   4574            else if (hdma == htim->hdma[TIM_DMA_ID_CC4])
   \   00000028   0x6AE1             LDR      R1,[R4, #+44]
   \   0000002A   0x4288             CMP      R0,R1
   \   0000002C   0xD101             BNE.N    ??TIM_DMADelayPulseCplt_1
   4575            {
   4576              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
   \   0000002E   0x2008             MOVS     R0,#+8
   \                     ??TIM_DMADelayPulseCplt_0: (+1)
   \   00000030   0x7620             STRB     R0,[R4, #+24]
   4577            }
   4578          
   4579            HAL_TIM_PWM_PulseFinishedCallback(htim);
   \                     ??TIM_DMADelayPulseCplt_1: (+1)
   \   00000032   0x4620             MOV      R0,R4
   \   00000034   0x.... 0x....      BL       HAL_TIM_PWM_PulseFinishedCallback
   4580          
   4581            htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0x7620             STRB     R0,[R4, #+24]
   4582          }
   \   0000003C   0xBD10             POP      {R4,PC}          ;; return
   4583          /**
   4584            * @brief  TIM DMA Capture complete callback. 
   4585            * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
   4586            *                the configuration information for the specified DMA module.
   4587            * @retval None
   4588            */

   \                                 In section .text, align 4, keep-with-next
   4589          void HAL_TIM_DMACaptureCplt(DMA_HandleTypeDef *hdma)
   4590          {
   \                     TIM_DMACaptureCplt: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   4591            TIM_HandleTypeDef* htim = ( TIM_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   \   00000002   0x6B84             LDR      R4,[R0, #+56]
   4592              
   4593             htim->State= HAL_TIM_STATE_READY; 
   \   00000004   0x2101             MOVS     R1,#+1
   \   00000006   0xF884 0x1039      STRB     R1,[R4, #+57]
   4594              
   4595            if (hdma == htim->hdma[TIM_DMA_ID_CC1])
   \   0000000A   0x6A21             LDR      R1,[R4, #+32]
   \   0000000C   0x4288             CMP      R0,R1
   \   0000000E   0xBF08             IT       EQ 
   \   00000010   0x2001             MOVEQ    R0,#+1
   4596            {
   4597              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
   \   00000012   0xD00D             BEQ.N    ??TIM_DMACaptureCplt_0
   4598            }
   4599            else if (hdma == htim->hdma[TIM_DMA_ID_CC2])
   \   00000014   0x6A61             LDR      R1,[R4, #+36]
   \   00000016   0x4288             CMP      R0,R1
   \   00000018   0xBF08             IT       EQ 
   \   0000001A   0x2002             MOVEQ    R0,#+2
   4600            {
   4601              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
   \   0000001C   0xD008             BEQ.N    ??TIM_DMACaptureCplt_0
   4602            }
   4603            else if (hdma == htim->hdma[TIM_DMA_ID_CC3])
   \   0000001E   0x6AA1             LDR      R1,[R4, #+40]
   \   00000020   0x4288             CMP      R0,R1
   \   00000022   0xBF08             IT       EQ 
   \   00000024   0x2004             MOVEQ    R0,#+4
   4604            {
   4605              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
   \   00000026   0xD003             BEQ.N    ??TIM_DMACaptureCplt_0
   4606            }
   4607            else if (hdma == htim->hdma[TIM_DMA_ID_CC4])
   \   00000028   0x6AE1             LDR      R1,[R4, #+44]
   \   0000002A   0x4288             CMP      R0,R1
   \   0000002C   0xD101             BNE.N    ??TIM_DMACaptureCplt_1
   4608            {
   4609              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
   \   0000002E   0x2008             MOVS     R0,#+8
   \                     ??TIM_DMACaptureCplt_0: (+1)
   \   00000030   0x7620             STRB     R0,[R4, #+24]
   4610            }
   4611            
   4612            HAL_TIM_IC_CaptureCallback(htim); 
   \                     ??TIM_DMACaptureCplt_1: (+1)
   \   00000032   0x4620             MOV      R0,R4
   \   00000034   0x.... 0x....      BL       HAL_TIM_IC_CaptureCallback
   4613            
   4614            htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0x7620             STRB     R0,[R4, #+24]
   4615          
   4616          }
   \   0000003C   0xBD10             POP      {R4,PC}          ;; return
   4617          
   4618          /**
   4619            * @brief  TIM DMA Period Elapse complete callback. 
   4620            * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
   4621            *                the configuration information for the specified DMA module.
   4622            * @retval None
   4623            */

   \                                 In section .text, align 4, keep-with-next
   4624          static void TIM_DMAPeriodElapsedCplt(DMA_HandleTypeDef *hdma)
   4625          {
   \                     TIM_DMAPeriodElapsedCplt: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB081             SUB      SP,SP,#+4
   4626            TIM_HandleTypeDef* htim = ( TIM_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   \   00000004   0x6B80             LDR      R0,[R0, #+56]
   4627            
   4628            htim->State= HAL_TIM_STATE_READY;
   \   00000006   0x2101             MOVS     R1,#+1
   \   00000008   0xF880 0x1039      STRB     R1,[R0, #+57]
   4629            
   4630            HAL_TIM_PeriodElapsedCallback(htim);
   \   0000000C   0x.... 0x....      BL       HAL_TIM_PeriodElapsedCallback
   4631          }
   \   00000010   0xB001             ADD      SP,SP,#+4
   \   00000012   0xBD00             POP      {PC}             ;; return
   4632          
   4633          /**
   4634            * @brief  TIM DMA Trigger callback. 
   4635            * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
   4636            *                the configuration information for the specified DMA module.
   4637            * @retval None
   4638            */

   \                                 In section .text, align 4, keep-with-next
   4639          static void TIM_DMATriggerCplt(DMA_HandleTypeDef *hdma)
   4640          {
   \                     TIM_DMATriggerCplt: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB081             SUB      SP,SP,#+4
   4641            TIM_HandleTypeDef* htim = ( TIM_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;  
   \   00000004   0x6B80             LDR      R0,[R0, #+56]
   4642            
   4643            htim->State= HAL_TIM_STATE_READY; 
   \   00000006   0x2101             MOVS     R1,#+1
   \   00000008   0xF880 0x1039      STRB     R1,[R0, #+57]
   4644            
   4645            HAL_TIM_TriggerCallback(htim);
   \   0000000C   0x.... 0x....      BL       HAL_TIM_TriggerCallback
   4646          }
   \   00000010   0xB001             ADD      SP,SP,#+4
   \   00000012   0xBD00             POP      {PC}             ;; return
   4647          
   4648          /**
   4649            * @brief  Time Base configuration
   4650            * @param  TIMx: TIM peripheral
   4651            * @param  Structure: pointer on TIM Time Base required parameters  
   4652            * @retval None
   4653            */

   \                                 In section .text, align 2, keep-with-next
   4654          void TIM_Base_SetConfig(TIM_TypeDef *TIMx, TIM_Base_InitTypeDef *Structure)
   4655          {
   4656            uint32_t tmpcr1 = 0;
   4657            tmpcr1 = TIMx->CR1;
   4658            
   4659            /* Set TIM Time Base Unit parameters ---------------------------------------*/
   4660            if(IS_TIM_CC3_INSTANCE(TIMx) != RESET)   
   \                     TIM_Base_SetConfig: (+1)
   \   00000000   0x....             LDR.N    R2,??DataTable32  ;; 0x40010000
   \   00000002   0x6803             LDR      R3,[R0, #+0]
   \   00000004   0x4290             CMP      R0,R2
   \   00000006   0xBF18             IT       NE 
   \   00000008   0xF1B0 0x4F80      CMPNE    R0,#+1073741824
   \   0000000C   0xD00F             BEQ.N    ??TIM_Base_SetConfig_0
   \   0000000E   0x.... 0x....      LDR.W    R12,??DataTable32_1  ;; 0x40000400
   \   00000012   0x4560             CMP      R0,R12
   \   00000014   0xBF1C             ITT      NE 
   \   00000016   0x.... 0x....      LDRNE.W  R12,??DataTable32_2  ;; 0x40000800
   \   0000001A   0x4560             CMPNE    R0,R12
   \   0000001C   0xD007             BEQ.N    ??TIM_Base_SetConfig_0
   \   0000001E   0x.... 0x....      LDR.W    R12,??DataTable32_3  ;; 0x40000c00
   \   00000022   0x4560             CMP      R0,R12
   \   00000024   0xBF1C             ITT      NE 
   \   00000026   0x.... 0x....      LDRNE.W  R12,??DataTable37_4  ;; 0x40010400
   \   0000002A   0x4560             CMPNE    R0,R12
   \   0000002C   0xD115             BNE.N    ??TIM_Base_SetConfig_1
   4661            {
   4662              /* Select the Counter Mode */
   4663              tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
   4664              tmpcr1 |= Structure->CounterMode;
   4665            }
   4666           
   4667            if(IS_TIM_CC1_INSTANCE(TIMx) != RESET)  
   \                     ??TIM_Base_SetConfig_0: (+1)
   \   0000002E   0x4290             CMP      R0,R2
   \   00000030   0xF8D1 0xC004      LDR      R12,[R1, #+4]
   \   00000034   0xF023 0x0370      BIC      R3,R3,#0x70
   \   00000038   0xEA4C 0x0303      ORR      R3,R12,R3
   \   0000003C   0xBF18             IT       NE 
   \   0000003E   0xF1B0 0x4F80      CMPNE    R0,#+1073741824
   \   00000042   0xD025             BEQ.N    ??TIM_Base_SetConfig_2
   \   00000044   0x.... 0x....      LDR.W    R12,??DataTable32_1  ;; 0x40000400
   \   00000048   0x4560             CMP      R0,R12
   \   0000004A   0xBF1F             ITTTT    NE 
   \   0000004C   0x.... 0x....      LDRNE.W  R12,??DataTable32_2  ;; 0x40000800
   \   00000050   0x4560             CMPNE    R0,R12
   \   00000052   0x.... 0x....      LDRNE.W  R12,??DataTable32_3  ;; 0x40000c00
   \   00000056   0x4560             CMPNE    R0,R12
   \   00000058   0xD01A             BEQ.N    ??TIM_Base_SetConfig_2
   \                     ??TIM_Base_SetConfig_1: (+1)
   \   0000005A   0x.... 0x....      LDR.W    R12,??DataTable37_4  ;; 0x40010400
   \   0000005E   0x4560             CMP      R0,R12
   \   00000060   0xBF1C             ITT      NE 
   \   00000062   0x.... 0x....      LDRNE.W  R12,??DataTable37_5  ;; 0x40014000
   \   00000066   0x4560             CMPNE    R0,R12
   \   00000068   0xD012             BEQ.N    ??TIM_Base_SetConfig_2
   \   0000006A   0x.... 0x....      LDR.W    R12,??DataTable37_6  ;; 0x40014400
   \   0000006E   0x4560             CMP      R0,R12
   \   00000070   0xBF1C             ITT      NE 
   \   00000072   0x.... 0x....      LDRNE.W  R12,??DataTable37_7  ;; 0x40014800
   \   00000076   0x4560             CMPNE    R0,R12
   \   00000078   0xD00A             BEQ.N    ??TIM_Base_SetConfig_2
   \   0000007A   0x.... 0x....      LDR.W    R12,??DataTable37_8  ;; 0x40001800
   \   0000007E   0x4560             CMP      R0,R12
   \   00000080   0xBF1F             ITTTT    NE 
   \   00000082   0x.... 0x....      LDRNE.W  R12,??DataTable37_9  ;; 0x40001c00
   \   00000086   0x4560             CMPNE    R0,R12
   \   00000088   0x.... 0x....      LDRNE.W  R12,??DataTable37_10  ;; 0x40002000
   \   0000008C   0x4560             CMPNE    R0,R12
   \   0000008E   0xD105             BNE.N    ??TIM_Base_SetConfig_3
   4668            {
   4669              /* Set the clock division */
   4670              tmpcr1 &= ~TIM_CR1_CKD;
   4671              tmpcr1 |= (uint32_t)Structure->ClockDivision;
   \                     ??TIM_Base_SetConfig_2: (+1)
   \   00000090   0xF8D1 0xC00C      LDR      R12,[R1, #+12]
   \   00000094   0xF423 0x7340      BIC      R3,R3,#0x300
   \   00000098   0xEA4C 0x0303      ORR      R3,R12,R3
   4672            }
   4673          
   4674            TIMx->CR1 = tmpcr1;
   \                     ??TIM_Base_SetConfig_3: (+1)
   \   0000009C   0x6003             STR      R3,[R0, #+0]
   4675          
   4676            /* Set the Auto-reload value */
   4677            TIMx->ARR = (uint32_t)Structure->Period ;
   \   0000009E   0x688B             LDR      R3,[R1, #+8]
   4678           
   4679            /* Set the Prescaler value */
   4680            TIMx->PSC = (uint32_t)Structure->Prescaler;
   4681              
   4682            if(IS_TIM_ADVANCED_INSTANCE(TIMx) != RESET)  
   \   000000A0   0x4290             CMP      R0,R2
   \   000000A2   0x62C3             STR      R3,[R0, #+44]
   \   000000A4   0x680B             LDR      R3,[R1, #+0]
   \   000000A6   0x6283             STR      R3,[R0, #+40]
   \   000000A8   0xBF19             ITTEE    NE 
   \   000000AA   0x....             LDRNE.N  R2,??DataTable37_4  ;; 0x40010400
   \   000000AC   0x4290             CMPNE    R0,R2
   \   000000AE   0x6909             LDREQ    R1,[R1, #+16]
   \   000000B0   0x6301             STREQ    R1,[R0, #+48]
   4683            {
   4684              /* Set the Repetition Counter value */
   4685              TIMx->RCR = Structure->RepetitionCounter;
   4686            }
   4687          
   4688            /* Generate an update event to reload the Prescaler 
   4689               and the repetition counter(only for TIM1 and TIM8) value immediately */
   4690            TIMx->EGR = TIM_EGR_UG;
   \   000000B2   0x2101             MOVS     R1,#+1
   \   000000B4   0x6141             STR      R1,[R0, #+20]
   4691          }
   \   000000B6   0x4770             BX       LR               ;; return
   4692          
   4693          /**
   4694            * @brief  Time Output Compare 1 configuration
   4695            * @param  TIMx to select the TIM peripheral
   4696            * @param  OC_Config: The output configuration structure
   4697            * @retval None
   4698            */

   \                                 In section .text, align 2, keep-with-next
   4699          void TIM_OC1_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
   4700          {
   \                     TIM_OC1_SetConfig: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
   4701            uint32_t tmpccmrx = 0;
   4702            uint32_t tmpccer = 0;
   4703            uint32_t tmpcr2 = 0;  
   4704          
   4705            /* Disable the Channel 1: Reset the CC1E Bit */
   4706            TIMx->CCER &= ~TIM_CCER_CC1E;
   \   00000002   0x6A02             LDR      R2,[R0, #+32]
   4707            
   4708            /* Get the TIMx CCER register value */
   4709            tmpccer = TIMx->CCER;
   4710            /* Get the TIMx CR2 register value */
   4711            tmpcr2 = TIMx->CR2;
   4712            
   4713            /* Get the TIMx CCMR1 register value */
   4714            tmpccmrx = TIMx->CCMR1;
   4715              
   4716            /* Reset the Output Compare Mode Bits */
   4717            tmpccmrx &= ~TIM_CCMR1_OC1M;
   4718            tmpccmrx &= ~TIM_CCMR1_CC1S;
   4719            /* Select the Output Compare Mode */
   4720            tmpccmrx |= OC_Config->OCMode;
   \   00000004   0x....             LDR.N    R5,??DataTable37_11  ;; 0xfffeff8c
   \   00000006   0x0852             LSRS     R2,R2,#+1
   \   00000008   0x0052             LSLS     R2,R2,#+1
   \   0000000A   0x6202             STR      R2,[R0, #+32]
   \   0000000C   0x6A04             LDR      R4,[R0, #+32]
   \   0000000E   0x6842             LDR      R2,[R0, #+4]
   \   00000010   0x6983             LDR      R3,[R0, #+24]
   4721            
   4722            /* Reset the Output Polarity level */
   4723            tmpccer &= ~TIM_CCER_CC1P;
   4724            /* Set the Output Compare Polarity */
   4725            tmpccer |= OC_Config->OCPolarity;
   \   00000012   0xF024 0x0402      BIC      R4,R4,#0x2
   \   00000016   0x402B             ANDS     R3,R5,R3
   \   00000018   0x680D             LDR      R5,[R1, #+0]
   \   0000001A   0x432B             ORRS     R3,R5,R3
   \   0000001C   0x688D             LDR      R5,[R1, #+8]
   \   0000001E   0x432C             ORRS     R4,R5,R4
   4726          
   4727              
   4728            if(IS_TIM_ADVANCED_INSTANCE(TIMx) != RESET)
   \   00000020   0x....             LDR.N    R5,??DataTable37_12  ;; 0x40010000
   \   00000022   0x42A8             CMP      R0,R5
   \   00000024   0xBF1C             ITT      NE 
   \   00000026   0x....             LDRNE.N  R5,??DataTable37_4  ;; 0x40010400
   \   00000028   0x42A8             CMPNE    R0,R5
   \   0000002A   0xD10B             BNE.N    ??TIM_OC1_SetConfig_0
   4729            {   
   4730              /* Reset the Output N Polarity level */
   4731              tmpccer &= ~TIM_CCER_CC1NP;
   4732              /* Set the Output N Polarity */
   4733              tmpccer |= OC_Config->OCNPolarity;
   4734              /* Reset the Output N State */
   4735              tmpccer &= ~TIM_CCER_CC1NE;
   4736              
   4737              /* Reset the Output Compare and Output Compare N IDLE State */
   4738              tmpcr2 &= ~TIM_CR2_OIS1;
   4739              tmpcr2 &= ~TIM_CR2_OIS1N;
   4740              /* Set the Output Idle state */
   4741              tmpcr2 |= OC_Config->OCIdleState;
   4742              /* Set the Output N Idle state */
   4743              tmpcr2 |= OC_Config->OCNIdleState;
   \   0000002C   0xF422 0x7240      BIC      R2,R2,#0x300
   \   00000030   0x68CD             LDR      R5,[R1, #+12]
   \   00000032   0xF024 0x0408      BIC      R4,R4,#0x8
   \   00000036   0x432C             ORRS     R4,R5,R4
   \   00000038   0x694D             LDR      R5,[R1, #+20]
   \   0000003A   0xF024 0x0404      BIC      R4,R4,#0x4
   \   0000003E   0x432A             ORRS     R2,R5,R2
   \   00000040   0x698D             LDR      R5,[R1, #+24]
   \   00000042   0x432A             ORRS     R2,R5,R2
   4744            }
   4745            /* Write to TIMx CR2 */
   4746            TIMx->CR2 = tmpcr2;
   \                     ??TIM_OC1_SetConfig_0: (+1)
   \   00000044   0x6042             STR      R2,[R0, #+4]
   4747            
   4748            /* Write to TIMx CCMR1 */
   4749            TIMx->CCMR1 = tmpccmrx;
   \   00000046   0x6183             STR      R3,[R0, #+24]
   4750            
   4751            /* Set the Capture Compare Register value */
   4752            TIMx->CCR1 = OC_Config->Pulse;
   \   00000048   0x6849             LDR      R1,[R1, #+4]
   \   0000004A   0x6341             STR      R1,[R0, #+52]
   4753            
   4754            /* Write to TIMx CCER */
   4755            TIMx->CCER = tmpccer;  
   \   0000004C   0x6204             STR      R4,[R0, #+32]
   4756          } 
   \   0000004E   0xBC30             POP      {R4,R5}
   \   00000050   0x4770             BX       LR               ;; return
   4757          
   4758          /**
   4759            * @brief  Time Output Compare 2 configuration
   4760            * @param  TIMx to select the TIM peripheral
   4761            * @param  OC_Config: The output configuration structure
   4762            * @retval None
   4763            */

   \                                 In section .text, align 2, keep-with-next
   4764          void TIM_OC2_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
   4765          {
   \                     TIM_OC2_SetConfig: (+1)
   \   00000000   0xB470             PUSH     {R4-R6}
   4766            uint32_t tmpccmrx = 0;
   4767            uint32_t tmpccer = 0;
   4768            uint32_t tmpcr2 = 0;
   4769             
   4770            /* Disable the Channel 2: Reset the CC2E Bit */
   4771            TIMx->CCER &= ~TIM_CCER_CC2E;
   \   00000002   0x6A02             LDR      R2,[R0, #+32]
   4772            
   4773            /* Get the TIMx CCER register value */  
   4774            tmpccer = TIMx->CCER;
   4775            /* Get the TIMx CR2 register value */
   4776            tmpcr2 = TIMx->CR2;
   4777            
   4778            /* Get the TIMx CCMR1 register value */
   4779            tmpccmrx = TIMx->CCMR1;
   4780              
   4781            /* Reset the Output Compare mode and Capture/Compare selection Bits */
   4782            tmpccmrx &= ~TIM_CCMR1_OC2M;
   4783            tmpccmrx &= ~TIM_CCMR1_CC2S;
   4784            
   4785            /* Select the Output Compare Mode */
   4786            tmpccmrx |= (OC_Config->OCMode << 8);
   \   00000004   0x....             LDR.N    R5,??DataTable37_13  ;; 0xfeff8cff
   \   00000006   0xF022 0x0210      BIC      R2,R2,#0x10
   \   0000000A   0x6202             STR      R2,[R0, #+32]
   \   0000000C   0x6A04             LDR      R4,[R0, #+32]
   \   0000000E   0x6842             LDR      R2,[R0, #+4]
   \   00000010   0x6983             LDR      R3,[R0, #+24]
   4787            
   4788            /* Reset the Output Polarity level */
   4789            tmpccer &= ~TIM_CCER_CC2P;
   4790            /* Set the Output Compare Polarity */
   4791            tmpccer |= (OC_Config->OCPolarity << 4);
   \   00000012   0xF024 0x0420      BIC      R4,R4,#0x20
   \   00000016   0x402B             ANDS     R3,R5,R3
   \   00000018   0x680D             LDR      R5,[R1, #+0]
   \   0000001A   0xEA43 0x2305      ORR      R3,R3,R5, LSL #+8
   \   0000001E   0x688D             LDR      R5,[R1, #+8]
   \   00000020   0xEA44 0x1405      ORR      R4,R4,R5, LSL #+4
   4792              
   4793            if(IS_TIM_ADVANCED_INSTANCE(TIMx) != RESET)
   \   00000024   0x....             LDR.N    R5,??DataTable37_12  ;; 0x40010000
   \   00000026   0x42A8             CMP      R0,R5
   \   00000028   0xBF1C             ITT      NE 
   \   0000002A   0x....             LDRNE.N  R5,??DataTable37_4  ;; 0x40010400
   \   0000002C   0x42A8             CMPNE    R0,R5
   \   0000002E   0xD10D             BNE.N    ??TIM_OC2_SetConfig_0
   4794            {
   4795              assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));
   4796              assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
   4797              assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));
   4798              
   4799              /* Reset the Output N Polarity level */
   4800              tmpccer &= ~TIM_CCER_CC2NP;
   4801              /* Set the Output N Polarity */
   4802              tmpccer |= (OC_Config->OCNPolarity << 4);
   4803              /* Reset the Output N State */
   4804              tmpccer &= ~TIM_CCER_CC2NE;
   \   00000030   0x68CD             LDR      R5,[R1, #+12]
   \   00000032   0xF024 0x0480      BIC      R4,R4,#0x80
   4805              
   4806              /* Reset the Output Compare and Output Compare N IDLE State */
   4807              tmpcr2 &= ~TIM_CR2_OIS2;
   4808              tmpcr2 &= ~TIM_CR2_OIS2N;
   4809              /* Set the Output Idle state */
   4810              tmpcr2 |= (OC_Config->OCIdleState << 2);
   4811              /* Set the Output N Idle state */
   4812              tmpcr2 |= (OC_Config->OCNIdleState << 2);
   \   00000036   0x698E             LDR      R6,[R1, #+24]
   \   00000038   0xF422 0x6240      BIC      R2,R2,#0xC00
   \   0000003C   0xEA44 0x1405      ORR      R4,R4,R5, LSL #+4
   \   00000040   0x694D             LDR      R5,[R1, #+20]
   \   00000042   0x4335             ORRS     R5,R6,R5
   \   00000044   0xF024 0x0440      BIC      R4,R4,#0x40
   \   00000048   0xEA42 0x0285      ORR      R2,R2,R5, LSL #+2
   4813            }
   4814            /* Write to TIMx CR2 */
   4815            TIMx->CR2 = tmpcr2;
   \                     ??TIM_OC2_SetConfig_0: (+1)
   \   0000004C   0x6042             STR      R2,[R0, #+4]
   4816            
   4817            /* Write to TIMx CCMR1 */
   4818            TIMx->CCMR1 = tmpccmrx;
   \   0000004E   0x6183             STR      R3,[R0, #+24]
   4819            
   4820            /* Set the Capture Compare Register value */
   4821            TIMx->CCR2 = OC_Config->Pulse;
   \   00000050   0x6849             LDR      R1,[R1, #+4]
   \   00000052   0x6381             STR      R1,[R0, #+56]
   4822            
   4823            /* Write to TIMx CCER */
   4824            TIMx->CCER = tmpccer;
   \   00000054   0x6204             STR      R4,[R0, #+32]
   4825          }
   \   00000056   0xBC70             POP      {R4-R6}
   \   00000058   0x4770             BX       LR               ;; return
   4826          
   4827          /**
   4828            * @brief  Time Output Compare 3 configuration
   4829            * @param  TIMx to select the TIM peripheral
   4830            * @param  OC_Config: The output configuration structure
   4831            * @retval None
   4832            */

   \                                 In section .text, align 2, keep-with-next
   4833          void TIM_OC3_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
   4834          {
   \                     TIM_OC3_SetConfig: (+1)
   \   00000000   0xB470             PUSH     {R4-R6}
   4835            uint32_t tmpccmrx = 0;
   4836            uint32_t tmpccer = 0;
   4837            uint32_t tmpcr2 = 0;   
   4838          
   4839            /* Disable the Channel 3: Reset the CC2E Bit */
   4840            TIMx->CCER &= ~TIM_CCER_CC3E;
   \   00000002   0x6A02             LDR      R2,[R0, #+32]
   4841            
   4842            /* Get the TIMx CCER register value */
   4843            tmpccer = TIMx->CCER;
   4844            /* Get the TIMx CR2 register value */
   4845            tmpcr2 = TIMx->CR2;
   4846            
   4847            /* Get the TIMx CCMR2 register value */
   4848            tmpccmrx = TIMx->CCMR2;
   4849              
   4850            /* Reset the Output Compare mode and Capture/Compare selection Bits */
   4851            tmpccmrx &= ~TIM_CCMR2_OC3M;
   4852            tmpccmrx &= ~TIM_CCMR2_CC3S;  
   4853            /* Select the Output Compare Mode */
   4854            tmpccmrx |= OC_Config->OCMode;
   \   00000004   0x....             LDR.N    R5,??DataTable37_11  ;; 0xfffeff8c
   \   00000006   0xF422 0x7280      BIC      R2,R2,#0x100
   \   0000000A   0x6202             STR      R2,[R0, #+32]
   \   0000000C   0x6A04             LDR      R4,[R0, #+32]
   \   0000000E   0x6842             LDR      R2,[R0, #+4]
   \   00000010   0x69C3             LDR      R3,[R0, #+28]
   4855            
   4856            /* Reset the Output Polarity level */
   4857            tmpccer &= ~TIM_CCER_CC3P;
   4858            /* Set the Output Compare Polarity */
   4859            tmpccer |= (OC_Config->OCPolarity << 8);
   \   00000012   0xF424 0x7400      BIC      R4,R4,#0x200
   \   00000016   0x402B             ANDS     R3,R5,R3
   \   00000018   0x680D             LDR      R5,[R1, #+0]
   \   0000001A   0x432B             ORRS     R3,R5,R3
   \   0000001C   0x688D             LDR      R5,[R1, #+8]
   \   0000001E   0xEA44 0x2405      ORR      R4,R4,R5, LSL #+8
   4860              
   4861            if(IS_TIM_ADVANCED_INSTANCE(TIMx) != RESET)
   \   00000022   0x....             LDR.N    R5,??DataTable37_12  ;; 0x40010000
   \   00000024   0x42A8             CMP      R0,R5
   \   00000026   0xBF1C             ITT      NE 
   \   00000028   0x....             LDRNE.N  R5,??DataTable37_4  ;; 0x40010400
   \   0000002A   0x42A8             CMPNE    R0,R5
   \   0000002C   0xD10D             BNE.N    ??TIM_OC3_SetConfig_0
   4862            {
   4863              assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));
   4864              assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
   4865              assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));
   4866              
   4867              /* Reset the Output N Polarity level */
   4868              tmpccer &= ~TIM_CCER_CC3NP;
   4869              /* Set the Output N Polarity */
   4870              tmpccer |= (OC_Config->OCNPolarity << 8);
   4871              /* Reset the Output N State */
   4872              tmpccer &= ~TIM_CCER_CC3NE;
   \   0000002E   0x68CD             LDR      R5,[R1, #+12]
   \   00000030   0xF424 0x6400      BIC      R4,R4,#0x800
   4873              
   4874              /* Reset the Output Compare and Output Compare N IDLE State */
   4875              tmpcr2 &= ~TIM_CR2_OIS3;
   4876              tmpcr2 &= ~TIM_CR2_OIS3N;
   4877              /* Set the Output Idle state */
   4878              tmpcr2 |= (OC_Config->OCIdleState << 4);
   4879              /* Set the Output N Idle state */
   4880              tmpcr2 |= (OC_Config->OCNIdleState << 4);
   \   00000034   0x698E             LDR      R6,[R1, #+24]
   \   00000036   0xF422 0x5240      BIC      R2,R2,#0x3000
   \   0000003A   0xEA44 0x2405      ORR      R4,R4,R5, LSL #+8
   \   0000003E   0x694D             LDR      R5,[R1, #+20]
   \   00000040   0x4335             ORRS     R5,R6,R5
   \   00000042   0xF424 0x6480      BIC      R4,R4,#0x400
   \   00000046   0xEA42 0x1205      ORR      R2,R2,R5, LSL #+4
   4881            }
   4882            /* Write to TIMx CR2 */
   4883            TIMx->CR2 = tmpcr2;
   \                     ??TIM_OC3_SetConfig_0: (+1)
   \   0000004A   0x6042             STR      R2,[R0, #+4]
   4884            
   4885            /* Write to TIMx CCMR2 */
   4886            TIMx->CCMR2 = tmpccmrx;
   \   0000004C   0x61C3             STR      R3,[R0, #+28]
   4887            
   4888            /* Set the Capture Compare Register value */
   4889            TIMx->CCR3 = OC_Config->Pulse;
   \   0000004E   0x6849             LDR      R1,[R1, #+4]
   \   00000050   0x63C1             STR      R1,[R0, #+60]
   4890            
   4891            /* Write to TIMx CCER */
   4892            TIMx->CCER = tmpccer;
   \   00000052   0x6204             STR      R4,[R0, #+32]
   4893          }
   \   00000054   0xBC70             POP      {R4-R6}
   \   00000056   0x4770             BX       LR               ;; return
   4894          
   4895          /**
   4896            * @brief  Time Output Compare 4 configuration
   4897            * @param  TIMx to select the TIM peripheral
   4898            * @param  OC_Config: The output configuration structure
   4899            * @retval None
   4900            */

   \                                 In section .text, align 2, keep-with-next
   4901          void TIM_OC4_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
   4902          {
   \                     TIM_OC4_SetConfig: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
   4903            uint32_t tmpccmrx = 0;
   4904            uint32_t tmpccer = 0;
   4905            uint32_t tmpcr2 = 0;
   4906          
   4907            /* Disable the Channel 4: Reset the CC4E Bit */
   4908            TIMx->CCER &= ~TIM_CCER_CC4E;
   \   00000002   0x6A02             LDR      R2,[R0, #+32]
   4909            
   4910            /* Get the TIMx CCER register value */
   4911            tmpccer = TIMx->CCER;
   4912            /* Get the TIMx CR2 register value */
   4913            tmpcr2 = TIMx->CR2;
   4914            
   4915            /* Get the TIMx CCMR2 register value */
   4916            tmpccmrx = TIMx->CCMR2;
   4917              
   4918            /* Reset the Output Compare mode and Capture/Compare selection Bits */
   4919            tmpccmrx &= ~TIM_CCMR2_OC4M;
   4920            tmpccmrx &= ~TIM_CCMR2_CC4S;
   4921            
   4922            /* Select the Output Compare Mode */
   4923            tmpccmrx |= (OC_Config->OCMode << 8);
   \   00000004   0x....             LDR.N    R5,??DataTable37_13  ;; 0xfeff8cff
   \   00000006   0xF422 0x5280      BIC      R2,R2,#0x1000
   \   0000000A   0x6202             STR      R2,[R0, #+32]
   \   0000000C   0x6A02             LDR      R2,[R0, #+32]
   \   0000000E   0x6843             LDR      R3,[R0, #+4]
   \   00000010   0x69C4             LDR      R4,[R0, #+28]
   4924            
   4925            /* Reset the Output Polarity level */
   4926            tmpccer &= ~TIM_CCER_CC4P;
   4927            /* Set the Output Compare Polarity */
   4928            tmpccer |= (OC_Config->OCPolarity << 12);
   \   00000012   0xF422 0x5200      BIC      R2,R2,#0x2000
   \   00000016   0x402C             ANDS     R4,R5,R4
   \   00000018   0x680D             LDR      R5,[R1, #+0]
   \   0000001A   0xEA44 0x2405      ORR      R4,R4,R5, LSL #+8
   \   0000001E   0x688D             LDR      R5,[R1, #+8]
   \   00000020   0xEA42 0x3205      ORR      R2,R2,R5, LSL #+12
   4929             
   4930            /*if((TIMx == TIM1) || (TIMx == TIM8))*/
   4931            if(IS_TIM_ADVANCED_INSTANCE(TIMx) != RESET)
   \   00000024   0x....             LDR.N    R5,??DataTable37_12  ;; 0x40010000
   \   00000026   0x42A8             CMP      R0,R5
   \   00000028   0xBF1C             ITT      NE 
   \   0000002A   0x....             LDRNE.N  R5,??DataTable37_4  ;; 0x40010400
   \   0000002C   0x42A8             CMPNE    R0,R5
   \   0000002E   0xD104             BNE.N    ??TIM_OC4_SetConfig_0
   4932            {
   4933              assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));
   4934              /* Reset the Output Compare IDLE State */
   4935              tmpcr2 &= ~TIM_CR2_OIS4;
   4936              /* Set the Output Idle state */
   4937              tmpcr2 |= (OC_Config->OCIdleState << 6);
   \   00000030   0x694D             LDR      R5,[R1, #+20]
   \   00000032   0xF423 0x4380      BIC      R3,R3,#0x4000
   \   00000036   0xEA43 0x1385      ORR      R3,R3,R5, LSL #+6
   4938            }
   4939            /* Write to TIMx CR2 */
   4940            TIMx->CR2 = tmpcr2;
   \                     ??TIM_OC4_SetConfig_0: (+1)
   \   0000003A   0x6043             STR      R3,[R0, #+4]
   4941            
   4942            /* Write to TIMx CCMR2 */  
   4943            TIMx->CCMR2 = tmpccmrx;
   \   0000003C   0x61C4             STR      R4,[R0, #+28]
   4944              
   4945            /* Set the Capture Compare Register value */
   4946            TIMx->CCR4 = OC_Config->Pulse;
   \   0000003E   0x6849             LDR      R1,[R1, #+4]
   \   00000040   0x6401             STR      R1,[R0, #+64]
   4947            
   4948            /* Write to TIMx CCER */
   4949            TIMx->CCER = tmpccer;
   \   00000042   0x6202             STR      R2,[R0, #+32]
   4950          }
   \   00000044   0xBC30             POP      {R4,R5}
   \   00000046   0x4770             BX       LR               ;; return
   4951          
   4952          /**
   4953            * @brief  Time Output Compare 4 configuration
   4954            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   4955            *                the configuration information for TIM module.
   4956            * @param  sSlaveConfig: The slave configuration structure
   4957            * @retval None
   4958            */
   4959          static void TIM_SlaveTimer_SetConfig(TIM_HandleTypeDef *htim,
   4960                                        TIM_SlaveConfigTypeDef * sSlaveConfig)
   4961          {
   4962            uint32_t tmpsmcr = 0;
   4963            uint32_t tmpccmr1 = 0;
   4964            uint32_t tmpccer = 0;
   4965          
   4966           /* Get the TIMx SMCR register value */
   4967            tmpsmcr = htim->Instance->SMCR;
   4968          
   4969            /* Reset the Trigger Selection Bits */
   4970            tmpsmcr &= ~TIM_SMCR_TS;
   4971            /* Set the Input Trigger source */
   4972            tmpsmcr |= sSlaveConfig->InputTrigger;
   4973          
   4974            /* Reset the slave mode Bits */
   4975            tmpsmcr &= ~TIM_SMCR_SMS;
   4976            /* Set the slave mode */
   4977            tmpsmcr |= sSlaveConfig->SlaveMode;
   4978          
   4979            /* Write to TIMx SMCR */
   4980            htim->Instance->SMCR = tmpsmcr;
   4981           
   4982            /* Configure the trigger prescaler, filter, and polarity */
   4983            switch (sSlaveConfig->InputTrigger)
   4984            {
   4985            case TIM_TS_ETRF:
   4986              {
   4987                /* Check the parameters */
   4988                assert_param(IS_TIM_ETR_INSTANCE(htim->Instance));
   4989                assert_param(IS_TIM_TRIGGERPRESCALER(sSlaveConfig->TriggerPrescaler));
   4990                assert_param(IS_TIM_TRIGGERPOLARITY(sSlaveConfig->TriggerPolarity));
   4991                assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
   4992                /* Configure the ETR Trigger source */
   4993                TIM_ETR_SetConfig(htim->Instance, 
   4994                                  sSlaveConfig->TriggerPrescaler, 
   4995                                  sSlaveConfig->TriggerPolarity, 
   4996                                  sSlaveConfig->TriggerFilter);
   4997              }
   4998              break;
   4999              
   5000            case TIM_TS_TI1F_ED:
   5001              {
   5002                /* Check the parameters */
   5003                assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   5004                assert_param(IS_TIM_TRIGGERPOLARITY(sSlaveConfig->TriggerPolarity));
   5005                assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
   5006            
   5007                /* Disable the Channel 1: Reset the CC1E Bit */
   5008                tmpccer = htim->Instance->CCER;
   5009                htim->Instance->CCER &= ~TIM_CCER_CC1E;
   5010                tmpccmr1 = htim->Instance->CCMR1;    
   5011                
   5012                /* Set the filter */
   5013                tmpccmr1 &= ~TIM_CCMR1_IC1F;
   5014                tmpccmr1 |= ((sSlaveConfig->TriggerFilter) << 4);
   5015                
   5016                /* Write to TIMx CCMR1 and CCER registers */
   5017                htim->Instance->CCMR1 = tmpccmr1;
   5018                htim->Instance->CCER = tmpccer;                               
   5019                                         
   5020              }
   5021              break;
   5022              
   5023            case TIM_TS_TI1FP1:
   5024              {
   5025                /* Check the parameters */
   5026                assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   5027                assert_param(IS_TIM_TRIGGERPOLARITY(sSlaveConfig->TriggerPolarity));
   5028                assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
   5029          
   5030                /* Configure TI1 Filter and Polarity */
   5031                TIM_TI1_ConfigInputStage(htim->Instance,
   5032                                         sSlaveConfig->TriggerPolarity,
   5033                                         sSlaveConfig->TriggerFilter);
   5034              }
   5035              break;
   5036              
   5037            case TIM_TS_TI2FP2:
   5038              {
   5039                /* Check the parameters */
   5040                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   5041                assert_param(IS_TIM_TRIGGERPOLARITY(sSlaveConfig->TriggerPolarity));
   5042                assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
   5043            
   5044                /* Configure TI2 Filter and Polarity */
   5045                TIM_TI2_ConfigInputStage(htim->Instance,
   5046                                          sSlaveConfig->TriggerPolarity,
   5047                                          sSlaveConfig->TriggerFilter);
   5048              }
   5049              break;
   5050              
   5051            case TIM_TS_ITR0:
   5052              {
   5053                /* Check the parameter */
   5054                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   5055              }
   5056              break;
   5057              
   5058            case TIM_TS_ITR1:
   5059              {
   5060                /* Check the parameter */
   5061                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   5062              }
   5063              break;
   5064              
   5065            case TIM_TS_ITR2:
   5066              {
   5067                /* Check the parameter */
   5068                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   5069              }
   5070              break;
   5071              
   5072            case TIM_TS_ITR3:
   5073              {
   5074                /* Check the parameter */
   5075                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   5076              }
   5077              break;
   5078                 
   5079            default:
   5080              break;
   5081            }
   5082          }
   5083          
   5084          /**
   5085            * @brief  Configure the TI1 as Input.
   5086            * @param  TIMx to select the TIM peripheral.
   5087            * @param  TIM_ICPolarity : The Input Polarity.
   5088            *          This parameter can be one of the following values:
   5089            *            @arg TIM_ICPolarity_Rising
   5090            *            @arg TIM_ICPolarity_Falling
   5091            *            @arg TIM_ICPolarity_BothEdge  
   5092            * @param  TIM_ICSelection: specifies the input to be used.
   5093            *          This parameter can be one of the following values:
   5094            *            @arg TIM_ICSelection_DirectTI: TIM Input 1 is selected to be connected to IC1.
   5095            *            @arg TIM_ICSelection_IndirectTI: TIM Input 1 is selected to be connected to IC2.
   5096            *            @arg TIM_ICSelection_TRC: TIM Input 1 is selected to be connected to TRC.
   5097            * @param  TIM_ICFilter: Specifies the Input Capture Filter.
   5098            *          This parameter must be a value between 0x00 and 0x0F.
   5099            * @retval None  
   5100            * @note TIM_ICFilter and TIM_ICPolarity are not used in INDIRECT mode as TI2FP1 
   5101            *       (on channel2 path) is used as the input signal. Therefore CCMR1 must be 
   5102            *        protected against un-initialized filter and polarity values.  
   5103            */

   \                                 In section .text, align 2, keep-with-next
   5104          void TIM_TI1_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
   5105                                 uint32_t TIM_ICFilter)
   5106          {
   \                     TIM_TI1_SetConfig: (+1)
   \   00000000   0xB470             PUSH     {R4-R6}
   5107            uint32_t tmpccmr1 = 0;
   5108            uint32_t tmpccer = 0;
   5109          
   5110            /* Disable the Channel 1: Reset the CC1E Bit */
   5111            TIMx->CCER &= ~TIM_CCER_CC1E;
   \   00000002   0x6A04             LDR      R4,[R0, #+32]
   5112            tmpccmr1 = TIMx->CCMR1;
   5113            tmpccer = TIMx->CCER;
   5114          
   5115            /* Select the Input */
   5116            if(IS_TIM_CC2_INSTANCE(TIMx) != RESET)
   \   00000004   0x....             LDR.N    R6,??DataTable37_12  ;; 0x40010000
   \   00000006   0x0864             LSRS     R4,R4,#+1
   \   00000008   0x0064             LSLS     R4,R4,#+1
   \   0000000A   0x6204             STR      R4,[R0, #+32]
   \   0000000C   0x6985             LDR      R5,[R0, #+24]
   \   0000000E   0x42B0             CMP      R0,R6
   \   00000010   0x6A04             LDR      R4,[R0, #+32]
   \   00000012   0xBF18             IT       NE 
   \   00000014   0xF1B0 0x4F80      CMPNE    R0,#+1073741824
   \   00000018   0xD011             BEQ.N    ??TIM_TI1_SetConfig_0
   \   0000001A   0x....             LDR.N    R6,??DataTable37_14  ;; 0x40000400
   \   0000001C   0x42B0             CMP      R0,R6
   \   0000001E   0xBF1C             ITT      NE 
   \   00000020   0x....             LDRNE.N  R6,??DataTable37_15  ;; 0x40000800
   \   00000022   0x42B0             CMPNE    R0,R6
   \   00000024   0xD00B             BEQ.N    ??TIM_TI1_SetConfig_0
   \   00000026   0x....             LDR.N    R6,??DataTable37_16  ;; 0x40000c00
   \   00000028   0x42B0             CMP      R0,R6
   \   0000002A   0xBF1C             ITT      NE 
   \   0000002C   0x....             LDRNE.N  R6,??DataTable37_4  ;; 0x40010400
   \   0000002E   0x42B0             CMPNE    R0,R6
   \   00000030   0xD005             BEQ.N    ??TIM_TI1_SetConfig_0
   \   00000032   0x....             LDR.N    R6,??DataTable37_5  ;; 0x40014000
   \   00000034   0x42B0             CMP      R0,R6
   \   00000036   0xBF1C             ITT      NE 
   \   00000038   0x....             LDRNE.N  R6,??DataTable37_8  ;; 0x40001800
   \   0000003A   0x42B0             CMPNE    R0,R6
   \   0000003C   0xD103             BNE.N    ??TIM_TI1_SetConfig_1
   5117            {
   5118              tmpccmr1 &= ~TIM_CCMR1_CC1S;
   5119              tmpccmr1 |= TIM_ICSelection;
   \                     ??TIM_TI1_SetConfig_0: (+1)
   \   0000003E   0x08AD             LSRS     R5,R5,#+2
   \   00000040   0xEA42 0x0285      ORR      R2,R2,R5, LSL #+2
   \   00000044   0xE001             B.N      ??TIM_TI1_SetConfig_2
   5120            } 
   5121            else
   5122            {
   5123              tmpccmr1 |= TIM_CCMR1_CC1S_0;
   \                     ??TIM_TI1_SetConfig_1: (+1)
   \   00000046   0xF045 0x0201      ORR      R2,R5,#0x1
   5124            }
   5125            
   5126            /* Set the filter */
   5127            tmpccmr1 &= ~TIM_CCMR1_IC1F;
   5128            tmpccmr1 |= ((TIM_ICFilter << 4) & TIM_CCMR1_IC1F);
   5129          
   5130            /* Select the Polarity and set the CC1E Bit */
   5131            tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
   5132            tmpccer |= (TIM_ICPolarity & (TIM_CCER_CC1P | TIM_CCER_CC1NP));
   5133          
   5134            /* Write to TIMx CCMR1 and CCER registers */
   5135            TIMx->CCMR1 = tmpccmr1;
   \                     ??TIM_TI1_SetConfig_2: (+1)
   \   0000004A   0x011B             LSLS     R3,R3,#+4
   \   0000004C   0xF022 0x02F0      BIC      R2,R2,#0xF0
   \   00000050   0xF003 0x03F0      AND      R3,R3,#0xF0
   \   00000054   0x431A             ORRS     R2,R3,R2
   \   00000056   0x6182             STR      R2,[R0, #+24]
   5136            TIMx->CCER = tmpccer;
   \   00000058   0xF024 0x020A      BIC      R2,R4,#0xA
   \   0000005C   0xF001 0x010A      AND      R1,R1,#0xA
   \   00000060   0x4311             ORRS     R1,R1,R2
   \   00000062   0x6201             STR      R1,[R0, #+32]
   5137          }
   \   00000064   0xBC70             POP      {R4-R6}
   \   00000066   0x4770             BX       LR               ;; return
   5138          
   5139          /**
   5140            * @brief  Configure the Polarity and Filter for TI1.
   5141            * @param  TIMx to select the TIM peripheral.
   5142            * @param  TIM_ICPolarity : The Input Polarity.
   5143            *          This parameter can be one of the following values:
   5144            *            @arg TIM_ICPolarity_Rising
   5145            *            @arg TIM_ICPolarity_Falling
   5146            *            @arg TIM_ICPolarity_BothEdge
   5147            * @param  TIM_ICFilter: Specifies the Input Capture Filter.
   5148            *          This parameter must be a value between 0x00 and 0x0F.
   5149            * @retval None
   5150            */
   5151          static void TIM_TI1_ConfigInputStage(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICFilter)
   5152          {
   5153            uint32_t tmpccmr1 = 0;
   5154            uint32_t tmpccer = 0;
   5155            
   5156            /* Disable the Channel 1: Reset the CC1E Bit */
   5157            tmpccer = TIMx->CCER;
   5158            TIMx->CCER &= ~TIM_CCER_CC1E;
   5159            tmpccmr1 = TIMx->CCMR1;    
   5160            
   5161            /* Set the filter */
   5162            tmpccmr1 &= ~TIM_CCMR1_IC1F;
   5163            tmpccmr1 |= (TIM_ICFilter << 4);
   5164            
   5165            /* Select the Polarity and set the CC1E Bit */
   5166            tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
   5167            tmpccer |= TIM_ICPolarity;
   5168            
   5169            /* Write to TIMx CCMR1 and CCER registers */
   5170            TIMx->CCMR1 = tmpccmr1;
   5171            TIMx->CCER = tmpccer;
   5172          }
   5173          
   5174          /**
   5175            * @brief  Configure the TI2 as Input.
   5176            * @param  TIMx to select the TIM peripheral
   5177            * @param  TIM_ICPolarity : The Input Polarity.
   5178            *          This parameter can be one of the following values:
   5179            *            @arg TIM_ICPolarity_Rising
   5180            *            @arg TIM_ICPolarity_Falling
   5181            *            @arg TIM_ICPolarity_BothEdge   
   5182            * @param  TIM_ICSelection: specifies the input to be used.
   5183            *          This parameter can be one of the following values:
   5184            *            @arg TIM_ICSelection_DirectTI: TIM Input 2 is selected to be connected to IC2.
   5185            *            @arg TIM_ICSelection_IndirectTI: TIM Input 2 is selected to be connected to IC1.
   5186            *            @arg TIM_ICSelection_TRC: TIM Input 2 is selected to be connected to TRC.
   5187            * @param  TIM_ICFilter: Specifies the Input Capture Filter.
   5188            *          This parameter must be a value between 0x00 and 0x0F.
   5189            * @retval None
   5190            * @note TIM_ICFilter and TIM_ICPolarity are not used in INDIRECT mode as TI1FP2 
   5191            *       (on channel1 path) is used as the input signal. Therefore CCMR1 must be 
   5192            *        protected against un-initialized filter and polarity values.  
   5193            */
   5194          static void TIM_TI2_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
   5195                                 uint32_t TIM_ICFilter)
   5196          {
   5197            uint32_t tmpccmr1 = 0;
   5198            uint32_t tmpccer = 0;
   5199          
   5200            /* Disable the Channel 2: Reset the CC2E Bit */
   5201            TIMx->CCER &= ~TIM_CCER_CC2E;
   5202            tmpccmr1 = TIMx->CCMR1;
   5203            tmpccer = TIMx->CCER;
   5204          
   5205            /* Select the Input */
   5206            tmpccmr1 &= ~TIM_CCMR1_CC2S;
   5207            tmpccmr1 |= (TIM_ICSelection << 8);
   5208          
   5209            /* Set the filter */
   5210            tmpccmr1 &= ~TIM_CCMR1_IC2F;
   5211            tmpccmr1 |= ((TIM_ICFilter << 12) & TIM_CCMR1_IC2F);
   5212          
   5213            /* Select the Polarity and set the CC2E Bit */
   5214            tmpccer &= ~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
   5215            tmpccer |= ((TIM_ICPolarity << 4) & (TIM_CCER_CC2P | TIM_CCER_CC2NP));
   5216          
   5217            /* Write to TIMx CCMR1 and CCER registers */
   5218            TIMx->CCMR1 = tmpccmr1 ;
   5219            TIMx->CCER = tmpccer;
   5220          }
   5221          
   5222          /**
   5223            * @brief  Configure the Polarity and Filter for TI2.
   5224            * @param  TIMx to select the TIM peripheral.
   5225            * @param  TIM_ICPolarity : The Input Polarity.
   5226            *          This parameter can be one of the following values:
   5227            *            @arg TIM_ICPolarity_Rising
   5228            *            @arg TIM_ICPolarity_Falling
   5229            *            @arg TIM_ICPolarity_BothEdge
   5230            * @param  TIM_ICFilter: Specifies the Input Capture Filter.
   5231            *          This parameter must be a value between 0x00 and 0x0F.
   5232            * @retval None
   5233            */
   5234          static void TIM_TI2_ConfigInputStage(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICFilter)
   5235          {
   5236          uint32_t tmpccmr1 = 0;
   5237            uint32_t tmpccer = 0;
   5238            
   5239            /* Disable the Channel 2: Reset the CC2E Bit */
   5240            TIMx->CCER &= ~TIM_CCER_CC2E;
   5241            tmpccmr1 = TIMx->CCMR1;
   5242            tmpccer = TIMx->CCER;
   5243            
   5244            /* Set the filter */
   5245            tmpccmr1 &= ~TIM_CCMR1_IC2F;
   5246            tmpccmr1 |= (TIM_ICFilter << 12);
   5247          
   5248            /* Select the Polarity and set the CC2E Bit */
   5249            tmpccer &= ~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
   5250            tmpccer |= (TIM_ICPolarity << 4);
   5251          
   5252            /* Write to TIMx CCMR1 and CCER registers */
   5253            TIMx->CCMR1 = tmpccmr1 ;
   5254            TIMx->CCER = tmpccer;
   5255          }
   5256          
   5257          /**
   5258            * @brief  Configure the TI3 as Input.
   5259            * @param  TIMx to select the TIM peripheral
   5260            * @param  TIM_ICPolarity : The Input Polarity.
   5261            *          This parameter can be one of the following values:
   5262            *            @arg TIM_ICPolarity_Rising
   5263            *            @arg TIM_ICPolarity_Falling
   5264            *            @arg TIM_ICPolarity_BothEdge         
   5265            * @param  TIM_ICSelection: specifies the input to be used.
   5266            *          This parameter can be one of the following values:
   5267            *            @arg TIM_ICSelection_DirectTI: TIM Input 3 is selected to be connected to IC3.
   5268            *            @arg TIM_ICSelection_IndirectTI: TIM Input 3 is selected to be connected to IC4.
   5269            *            @arg TIM_ICSelection_TRC: TIM Input 3 is selected to be connected to TRC.
   5270            * @param  TIM_ICFilter: Specifies the Input Capture Filter.
   5271            *          This parameter must be a value between 0x00 and 0x0F.
   5272            * @retval None
   5273            * @note TIM_ICFilter and TIM_ICPolarity are not used in INDIRECT mode as TI3FP4 
   5274            *       (on channel1 path) is used as the input signal. Therefore CCMR2 must be 
   5275            *        protected against un-initialized filter and polarity values.  
   5276            */
   5277          static void TIM_TI3_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
   5278                                 uint32_t TIM_ICFilter)
   5279          {
   5280            uint32_t tmpccmr2 = 0;
   5281            uint32_t tmpccer = 0;
   5282          
   5283            /* Disable the Channel 3: Reset the CC3E Bit */
   5284            TIMx->CCER &= ~TIM_CCER_CC3E;
   5285            tmpccmr2 = TIMx->CCMR2;
   5286            tmpccer = TIMx->CCER;
   5287          
   5288            /* Select the Input */
   5289            tmpccmr2 &= ~TIM_CCMR2_CC3S;
   5290            tmpccmr2 |= TIM_ICSelection;
   5291          
   5292            /* Set the filter */
   5293            tmpccmr2 &= ~TIM_CCMR2_IC3F;
   5294            tmpccmr2 |= ((TIM_ICFilter << 4) & TIM_CCMR2_IC3F);
   5295          
   5296            /* Select the Polarity and set the CC3E Bit */
   5297            tmpccer &= ~(TIM_CCER_CC3P | TIM_CCER_CC3NP);
   5298            tmpccer |= ((TIM_ICPolarity << 8) & (TIM_CCER_CC3P | TIM_CCER_CC3NP));
   5299          
   5300            /* Write to TIMx CCMR2 and CCER registers */
   5301            TIMx->CCMR2 = tmpccmr2;
   5302            TIMx->CCER = tmpccer;
   5303          }
   5304          
   5305          /**
   5306            * @brief  Configure the TI4 as Input.
   5307            * @param  TIMx to select the TIM peripheral
   5308            * @param  TIM_ICPolarity : The Input Polarity.
   5309            *          This parameter can be one of the following values:
   5310            *            @arg TIM_ICPolarity_Rising
   5311            *            @arg TIM_ICPolarity_Falling
   5312            *            @arg TIM_ICPolarity_BothEdge     
   5313            * @param  TIM_ICSelection: specifies the input to be used.
   5314            *          This parameter can be one of the following values:
   5315            *            @arg TIM_ICSelection_DirectTI: TIM Input 4 is selected to be connected to IC4.
   5316            *            @arg TIM_ICSelection_IndirectTI: TIM Input 4 is selected to be connected to IC3.
   5317            *            @arg TIM_ICSelection_TRC: TIM Input 4 is selected to be connected to TRC.
   5318            * @param  TIM_ICFilter: Specifies the Input Capture Filter.
   5319            *          This parameter must be a value between 0x00 and 0x0F.
   5320            * @retval None
   5321            * @note TIM_ICFilter and TIM_ICPolarity are not used in INDIRECT mode as TI4FP3 
   5322            *       (on channel1 path) is used as the input signal. Therefore CCMR2 must be 
   5323            *        protected against un-initialized filter and polarity values.  
   5324            */
   5325          static void TIM_TI4_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
   5326                                 uint32_t TIM_ICFilter)
   5327          {
   5328            uint32_t tmpccmr2 = 0;
   5329            uint32_t tmpccer = 0;
   5330          
   5331            /* Disable the Channel 4: Reset the CC4E Bit */
   5332            TIMx->CCER &= ~TIM_CCER_CC4E;
   5333            tmpccmr2 = TIMx->CCMR2;
   5334            tmpccer = TIMx->CCER;
   5335          
   5336            /* Select the Input */
   5337            tmpccmr2 &= ~TIM_CCMR2_CC4S;
   5338            tmpccmr2 |= (TIM_ICSelection << 8);
   5339          
   5340            /* Set the filter */
   5341            tmpccmr2 &= ~TIM_CCMR2_IC4F;
   5342            tmpccmr2 |= ((TIM_ICFilter << 12) & TIM_CCMR2_IC4F);
   5343          
   5344            /* Select the Polarity and set the CC4E Bit */
   5345            tmpccer &= ~(TIM_CCER_CC4P | TIM_CCER_CC4NP);
   5346            tmpccer |= ((TIM_ICPolarity << 12) & (TIM_CCER_CC4P | TIM_CCER_CC4NP));
   5347          
   5348            /* Write to TIMx CCMR2 and CCER registers */
   5349            TIMx->CCMR2 = tmpccmr2;
   5350            TIMx->CCER = tmpccer ;
   5351          }
   5352          
   5353          /**
   5354            * @brief  Selects the Input Trigger source
   5355            * @param  TIMx to select the TIM peripheral
   5356            * @param  TIM_ITRx: The Input Trigger source.
   5357            *          This parameter can be one of the following values:
   5358            *            @arg TIM_TS_ITR0: Internal Trigger 0
   5359            *            @arg TIM_TS_ITR1: Internal Trigger 1
   5360            *            @arg TIM_TS_ITR2: Internal Trigger 2
   5361            *            @arg TIM_TS_ITR3: Internal Trigger 3
   5362            *            @arg TIM_TS_TI1F_ED: TI1 Edge Detector
   5363            *            @arg TIM_TS_TI1FP1: Filtered Timer Input 1
   5364            *            @arg TIM_TS_TI2FP2: Filtered Timer Input 2
   5365            *            @arg TIM_TS_ETRF: External Trigger input
   5366            * @retval None
   5367            */
   5368          static void TIM_ITRx_SetConfig(TIM_TypeDef *TIMx, uint16_t TIM_ITRx)
   5369          {
   5370            uint32_t tmpsmcr = 0;
   5371            
   5372             /* Get the TIMx SMCR register value */
   5373             tmpsmcr = TIMx->SMCR;
   5374             /* Reset the TS Bits */
   5375             tmpsmcr &= ~TIM_SMCR_TS;
   5376             /* Set the Input Trigger source and the slave mode*/
   5377             tmpsmcr |= TIM_ITRx | TIM_SLAVEMODE_EXTERNAL1;
   5378             /* Write to TIMx SMCR */
   5379             TIMx->SMCR = tmpsmcr;
   5380          }
   5381          
   5382          /**
   5383            * @brief  Configures the TIMx External Trigger (ETR).
   5384            * @param  TIMx to select the TIM peripheral
   5385            * @param  TIM_ExtTRGPrescaler: The external Trigger Prescaler.
   5386            *          This parameter can be one of the following values:
   5387            *            @arg TIM_ExtTRGPSC_DIV1: ETRP Prescaler OFF.
   5388            *            @arg TIM_ExtTRGPSC_DIV2: ETRP frequency divided by 2.
   5389            *            @arg TIM_ExtTRGPSC_DIV4: ETRP frequency divided by 4.
   5390            *            @arg TIM_ExtTRGPSC_DIV8: ETRP frequency divided by 8.
   5391            * @param  TIM_ExtTRGPolarity: The external Trigger Polarity.
   5392            *          This parameter can be one of the following values:
   5393            *            @arg TIM_ExtTRGPolarity_Inverted: active low or falling edge active.
   5394            *            @arg TIM_ExtTRGPolarity_NonInverted: active high or rising edge active.
   5395            * @param  ExtTRGFilter: External Trigger Filter.
   5396            *          This parameter must be a value between 0x00 and 0x0F
   5397            * @retval None
   5398            */

   \                                 In section .text, align 2, keep-with-next
   5399          void TIM_ETR_SetConfig(TIM_TypeDef* TIMx, uint32_t TIM_ExtTRGPrescaler,
   5400                                 uint32_t TIM_ExtTRGPolarity, uint32_t ExtTRGFilter)
   5401          {
   5402            uint32_t tmpsmcr = 0;
   5403          
   5404            tmpsmcr = TIMx->SMCR;
   5405          
   5406            /* Reset the ETR Bits */
   5407            tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
   5408          
   5409            /* Set the Prescaler, the Filter value and the Polarity */
   5410            tmpsmcr |= (uint32_t)(TIM_ExtTRGPrescaler | (TIM_ExtTRGPolarity | (ExtTRGFilter << 8)));
   5411          
   5412            /* Write to TIMx SMCR */
   5413            TIMx->SMCR = tmpsmcr;
   \                     TIM_ETR_SetConfig: (+1)
   \   00000000   0xF8D0 0xC008      LDR      R12,[R0, #+8]
   \   00000004   0xF42C 0x4C7F      BIC      R12,R12,#0xFF00
   \   00000008   0xEA41 0x010C      ORR      R1,R1,R12
   \   0000000C   0x4311             ORRS     R1,R2,R1
   \   0000000E   0xEA41 0x2103      ORR      R1,R1,R3, LSL #+8
   \   00000012   0x6081             STR      R1,[R0, #+8]
   5414          } 
   \   00000014   0x4770             BX       LR               ;; return
   5415          
   5416          /**
   5417            * @brief  Enables or disables the TIM Capture Compare Channel x.
   5418            * @param  TIMx to select the TIM peripheral
   5419            * @param  Channel: specifies the TIM Channel
   5420            *          This parameter can be one of the following values:
   5421            *            @arg TIM_Channel_1: TIM Channel 1
   5422            *            @arg TIM_Channel_2: TIM Channel 2
   5423            *            @arg TIM_Channel_3: TIM Channel 3
   5424            *            @arg TIM_Channel_4: TIM Channel 4
   5425            * @param  ChannelState: specifies the TIM Channel CCxE bit new state.
   5426            *          This parameter can be: TIM_CCx_ENABLE or TIM_CCx_Disable. 
   5427            * @retval None
   5428            */

   \                                 In section .text, align 2, keep-with-next
   5429          void TIM_CCxChannelCmd(TIM_TypeDef* TIMx, uint32_t Channel, uint32_t ChannelState)
   5430          {
   5431            uint32_t tmp = 0;
   5432          
   5433            /* Check the parameters */
   5434            assert_param(IS_TIM_CC1_INSTANCE(TIMx)); 
   5435            assert_param(IS_TIM_CHANNELS(Channel));
   5436          
   5437            tmp = TIM_CCER_CC1E << Channel;
   5438          
   5439            /* Reset the CCxE Bit */
   5440            TIMx->CCER &= ~tmp;
   \                     TIM_CCxChannelCmd: (+1)
   \   00000000   0x6A03             LDR      R3,[R0, #+32]
   \   00000002   0xF04F 0x0C01      MOV      R12,#+1
   \   00000006   0xFA0C 0xFC01      LSL      R12,R12,R1
   5441          
   5442            /* Set or reset the CCxE Bit */ 
   5443            TIMx->CCER |= (uint32_t)(ChannelState << Channel);
   \   0000000A   0xFA02 0xF101      LSL      R1,R2,R1
   \   0000000E   0xEA23 0x030C      BIC      R3,R3,R12
   \   00000012   0x6203             STR      R3,[R0, #+32]
   \   00000014   0x6A03             LDR      R3,[R0, #+32]
   \   00000016   0x4319             ORRS     R1,R1,R3
   \   00000018   0x6201             STR      R1,[R0, #+32]
   5444          }
   \   0000001A   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15:
   \   00000000   0x40010000         DC32     0x40010000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_1:
   \   00000000   0x40000400         DC32     0x40000400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_2:
   \   00000000   0x40000800         DC32     0x40000800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_3:
   \   00000000   0x40000C00         DC32     0x40000c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16:
   \   00000000   0x40010400         DC32     0x40010400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_1:
   \   00000000   0x40014000         DC32     0x40014000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_2:
   \   00000000   0x40014400         DC32     0x40014400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_3:
   \   00000000   0x40014800         DC32     0x40014800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_4:
   \   00000000   0x40001800         DC32     0x40001800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_5:
   \   00000000   0x40001C00         DC32     0x40001c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_6:
   \   00000000   0x40002000         DC32     0x40002000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_7:
   \   00000000   0x........         DC32     TIM_DMAPeriodElapsedCplt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17:
   \   00000000   0x........         DC32     TIM_DMAError

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21:
   \   00000000   0x........         DC32     TIM_DMADelayPulseCplt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_1:
   \   00000000   0x........         DC32     TIM_DMAError

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24:
   \   00000000   0x40010000         DC32     0x40010000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_1:
   \   00000000   0x40000400         DC32     0x40000400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_2:
   \   00000000   0x40000800         DC32     0x40000800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_3:
   \   00000000   0x40000C00         DC32     0x40000c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25:
   \   00000000   0x........         DC32     TIM_DMACaptureCplt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26:
   \   00000000   0x40014000         DC32     0x40014000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_1:
   \   00000000   0x40014400         DC32     0x40014400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_2:
   \   00000000   0x40014800         DC32     0x40014800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_3:
   \   00000000   0x40001800         DC32     0x40001800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_4:
   \   00000000   0x40001C00         DC32     0x40001c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_5:
   \   00000000   0x40002000         DC32     0x40002000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27:
   \   00000000   0x40010400         DC32     0x40010400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28:
   \   00000000   0x40010400         DC32     0x40010400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_1:
   \   00000000   0xFFFEFFF8         DC32     0xfffefff8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_2:
   \   00000000   0xFFFFFCFC         DC32     0xfffffcfc

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_3:
   \   00000000   0xFFFF0303         DC32     0xffff0303

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30:
   \   00000000   0x........         DC32     TIM_DMAError

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32:
   \   00000000   0x40010000         DC32     0x40010000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32_1:
   \   00000000   0x40000400         DC32     0x40000400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32_2:
   \   00000000   0x40000800         DC32     0x40000800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32_3:
   \   00000000   0x40000C00         DC32     0x40000c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable37:
   \   00000000   0xFFFEFFF8         DC32     0xfffefff8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable37_1:
   \   00000000   0x........         DC32     TIMEx_DMACommutationCplt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable37_2:
   \   00000000   0xFFFE0088         DC32     0xfffe0088

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable37_3:
   \   00000000   0xFFFEFF88         DC32     0xfffeff88

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable37_4:
   \   00000000   0x40010400         DC32     0x40010400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable37_5:
   \   00000000   0x40014000         DC32     0x40014000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable37_6:
   \   00000000   0x40014400         DC32     0x40014400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable37_7:
   \   00000000   0x40014800         DC32     0x40014800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable37_8:
   \   00000000   0x40001800         DC32     0x40001800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable37_9:
   \   00000000   0x40001C00         DC32     0x40001c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable37_10:
   \   00000000   0x40002000         DC32     0x40002000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable37_11:
   \   00000000   0xFFFEFF8C         DC32     0xfffeff8c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable37_12:
   \   00000000   0x40010000         DC32     0x40010000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable37_13:
   \   00000000   0xFEFF8CFF         DC32     0xfeff8cff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable37_14:
   \   00000000   0x40000400         DC32     0x40000400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable37_15:
   \   00000000   0x40000800         DC32     0x40000800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable37_16:
   \   00000000   0x40000C00         DC32     0x40000c00
   5445          
   5446          
   5447          /**
   5448            * @}
   5449            */
   5450          
   5451          #endif /* HAL_TIM_MODULE_ENABLED */
   5452          /**
   5453            * @}
   5454            */ 
   5455          
   5456          /**
   5457            * @}
   5458            */ 
   5459          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   HAL_TIM_Base_DeInit
         8   -> HAL_TIM_Base_MspDeInit
       0   HAL_TIM_Base_GetState
      16   HAL_TIM_Base_Init
        16   -> HAL_TIM_Base_MspInit
       0   HAL_TIM_Base_MspDeInit
       0   HAL_TIM_Base_MspInit
       0   HAL_TIM_Base_Start
       8   HAL_TIM_Base_Start_DMA
         8   -> HAL_DMA_Start_IT
       0   HAL_TIM_Base_Start_IT
       0   HAL_TIM_Base_Stop
       0   HAL_TIM_Base_Stop_DMA
       0   HAL_TIM_Base_Stop_IT
       8   HAL_TIM_ConfigClockSource
      16   HAL_TIM_ConfigOCrefClear
       0   HAL_TIM_ConfigTI1Input
      24   HAL_TIM_DMABurst_ReadStart
        24   -> HAL_DMA_Start_IT
      16   HAL_TIM_DMABurst_ReadStop
        16   -> HAL_DMA_Abort
      24   HAL_TIM_DMABurst_WriteStart
        24   -> HAL_DMA_Start_IT
      16   HAL_TIM_DMABurst_WriteStop
        16   -> HAL_DMA_Abort
       8   HAL_TIM_Encoder_DeInit
         8   -> HAL_TIM_Encoder_MspDeInit
       0   HAL_TIM_Encoder_GetState
      16   HAL_TIM_Encoder_Init
        16   -> HAL_TIM_Encoder_MspInit
       0   HAL_TIM_Encoder_MspDeInit
       0   HAL_TIM_Encoder_MspInit
       0   HAL_TIM_Encoder_Start
      24   HAL_TIM_Encoder_Start_DMA
        24   -> HAL_DMA_Start_IT
       0   HAL_TIM_Encoder_Start_IT
       0   HAL_TIM_Encoder_Stop
       0   HAL_TIM_Encoder_Stop_DMA
       0   HAL_TIM_Encoder_Stop_IT
       0   HAL_TIM_ErrorCallback
       0   HAL_TIM_GenerateEvent
       0   HAL_TIM_IC_CaptureCallback
      20   HAL_TIM_IC_ConfigChannel
       8   HAL_TIM_IC_DeInit
         8   -> HAL_TIM_IC_MspDeInit
       0   HAL_TIM_IC_GetState
      16   HAL_TIM_IC_Init
        16   -> HAL_TIM_IC_MspInit
       0   HAL_TIM_IC_MspDeInit
       0   HAL_TIM_IC_MspInit
       0   HAL_TIM_IC_Start
      16   HAL_TIM_IC_Start_DMA
        16   -> HAL_DMA_Start_IT
       0   HAL_TIM_IC_Start_IT
       0   HAL_TIM_IC_Stop
       4   HAL_TIM_IC_Stop_DMA
       0   HAL_TIM_IC_Stop_IT
       8   HAL_TIM_IRQHandler
         8   -> HAL_TIMEx_BreakCallback
         0   -> HAL_TIMEx_CommutationCallback
         8   -> HAL_TIM_IC_CaptureCallback
         8   -> HAL_TIM_OC_DelayElapsedCallback
         8   -> HAL_TIM_PWM_PulseFinishedCallback
         8   -> HAL_TIM_PeriodElapsedCallback
         8   -> HAL_TIM_TriggerCallback
       8   HAL_TIM_OC_ConfigChannel
         8   -> TIM_OC1_SetConfig
         8   -> TIM_OC2_SetConfig
         8   -> TIM_OC3_SetConfig
         8   -> TIM_OC4_SetConfig
       8   HAL_TIM_OC_DeInit
         8   -> HAL_TIM_OC_MspDeInit
       0   HAL_TIM_OC_DelayElapsedCallback
       0   HAL_TIM_OC_GetState
      16   HAL_TIM_OC_Init
        16   -> HAL_TIM_OC_MspInit
       0   HAL_TIM_OC_MspDeInit
       0   HAL_TIM_OC_MspInit
       0   HAL_TIM_OC_Start
      16   HAL_TIM_OC_Start_DMA
        16   -> HAL_DMA_Start_IT
       0   HAL_TIM_OC_Start_IT
       0   HAL_TIM_OC_Stop
       4   HAL_TIM_OC_Stop_DMA
       0   HAL_TIM_OC_Stop_IT
      48   HAL_TIM_OnePulse_ConfigChannel
        48   -> TIM_OC1_SetConfig
        48   -> TIM_OC2_SetConfig
        48   -> TIM_TI1_SetConfig
       8   HAL_TIM_OnePulse_DeInit
         8   -> HAL_TIM_OnePulse_MspDeInit
       0   HAL_TIM_OnePulse_GetState
      16   HAL_TIM_OnePulse_Init
        16   -> HAL_TIM_OnePulse_MspInit
       0   HAL_TIM_OnePulse_MspDeInit
       0   HAL_TIM_OnePulse_MspInit
       0   HAL_TIM_OnePulse_Start
       0   HAL_TIM_OnePulse_Start_IT
       0   HAL_TIM_OnePulse_Stop
       0   HAL_TIM_OnePulse_Stop_IT
      16   HAL_TIM_PWM_ConfigChannel
        16   -> TIM_OC1_SetConfig
        16   -> TIM_OC2_SetConfig
        16   -> TIM_OC3_SetConfig
        16   -> TIM_OC4_SetConfig
       8   HAL_TIM_PWM_DeInit
         8   -> HAL_TIM_PWM_MspDeInit
       0   HAL_TIM_PWM_GetState
      16   HAL_TIM_PWM_Init
        16   -> HAL_TIM_PWM_MspInit
       0   HAL_TIM_PWM_MspDeInit
       0   HAL_TIM_PWM_MspInit
       0   HAL_TIM_PWM_PulseFinishedCallback
       0   HAL_TIM_PWM_Start
      16   HAL_TIM_PWM_Start_DMA
        16   -> HAL_DMA_Start_IT
       0   HAL_TIM_PWM_Start_IT
       0   HAL_TIM_PWM_Stop
       4   HAL_TIM_PWM_Stop_DMA
       0   HAL_TIM_PWM_Stop_IT
       0   HAL_TIM_PeriodElapsedCallback
       0   HAL_TIM_ReadCapturedValue
       8   HAL_TIM_SlaveConfigSynchronization
       8   HAL_TIM_SlaveConfigSynchronization_IT
       0   HAL_TIM_TriggerCallback
       0   TIM_Base_SetConfig
       0   TIM_CCxChannelCmd
       8   TIM_DMACaptureCplt
         8   -> HAL_TIM_IC_CaptureCallback
       8   TIM_DMADelayPulseCplt
         8   -> HAL_TIM_PWM_PulseFinishedCallback
       8   TIM_DMAError
         8   -> HAL_TIM_ErrorCallback
       8   TIM_DMAPeriodElapsedCplt
         8   -> HAL_TIM_PeriodElapsedCallback
       8   TIM_DMATriggerCplt
         8   -> HAL_TIM_TriggerCallback
       0   TIM_ETR_SetConfig
       8   TIM_OC1_SetConfig
      12   TIM_OC2_SetConfig
      12   TIM_OC3_SetConfig
       8   TIM_OC4_SetConfig
      12   TIM_TI1_SetConfig


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable15
       4  ??DataTable15_1
       4  ??DataTable15_2
       4  ??DataTable15_3
       4  ??DataTable16
       4  ??DataTable16_1
       4  ??DataTable16_2
       4  ??DataTable16_3
       4  ??DataTable16_4
       4  ??DataTable16_5
       4  ??DataTable16_6
       4  ??DataTable16_7
       4  ??DataTable17
       4  ??DataTable21
       4  ??DataTable21_1
       4  ??DataTable24
       4  ??DataTable24_1
       4  ??DataTable24_2
       4  ??DataTable24_3
       4  ??DataTable25
       4  ??DataTable26
       4  ??DataTable26_1
       4  ??DataTable26_2
       4  ??DataTable26_3
       4  ??DataTable26_4
       4  ??DataTable26_5
       4  ??DataTable27
       4  ??DataTable28
       4  ??DataTable28_1
       4  ??DataTable28_2
       4  ??DataTable28_3
       4  ??DataTable30
       4  ??DataTable32
       4  ??DataTable32_1
       4  ??DataTable32_2
       4  ??DataTable32_3
       4  ??DataTable37
       4  ??DataTable37_1
       4  ??DataTable37_10
       4  ??DataTable37_11
       4  ??DataTable37_12
       4  ??DataTable37_13
       4  ??DataTable37_14
       4  ??DataTable37_15
       4  ??DataTable37_16
       4  ??DataTable37_2
       4  ??DataTable37_3
       4  ??DataTable37_4
       4  ??DataTable37_5
       4  ??DataTable37_6
       4  ??DataTable37_7
       4  ??DataTable37_8
       4  ??DataTable37_9
      58  HAL_TIM_Base_DeInit
       6  HAL_TIM_Base_GetState
     222  HAL_TIM_Base_Init
       2  HAL_TIM_Base_MspDeInit
       2  HAL_TIM_Base_MspInit
      26  HAL_TIM_Base_Start
      84  HAL_TIM_Base_Start_DMA
      22  HAL_TIM_Base_Start_IT
      46  HAL_TIM_Base_Stop
      50  HAL_TIM_Base_Stop_DMA
      42  HAL_TIM_Base_Stop_IT
     414  HAL_TIM_ConfigClockSource
     180  HAL_TIM_ConfigOCrefClear
      16  HAL_TIM_ConfigTI1Input
     330  HAL_TIM_DMABurst_ReadStart
      96  HAL_TIM_DMABurst_ReadStop
     330  HAL_TIM_DMABurst_WriteStart
      96  HAL_TIM_DMABurst_WriteStop
      58  HAL_TIM_Encoder_DeInit
       6  HAL_TIM_Encoder_GetState
     318  HAL_TIM_Encoder_Init
       2  HAL_TIM_Encoder_MspDeInit
       2  HAL_TIM_Encoder_MspInit
      78  HAL_TIM_Encoder_Start
     330  HAL_TIM_Encoder_Start_DMA
     118  HAL_TIM_Encoder_Start_IT
      82  HAL_TIM_Encoder_Stop
     130  HAL_TIM_Encoder_Stop_DMA
     130  HAL_TIM_Encoder_Stop_IT
       2  HAL_TIM_ErrorCallback
      44  HAL_TIM_GenerateEvent
       2  HAL_TIM_IC_CaptureCallback
     432  HAL_TIM_IC_ConfigChannel
      58  HAL_TIM_IC_DeInit
       6  HAL_TIM_IC_GetState
     208  HAL_TIM_IC_Init
       2  HAL_TIM_IC_MspDeInit
       2  HAL_TIM_IC_MspInit
      32  HAL_TIM_IC_Start
     236  HAL_TIM_IC_Start_DMA
      92  HAL_TIM_IC_Start_IT
      52  HAL_TIM_IC_Stop
     124  HAL_TIM_IC_Stop_DMA
     112  HAL_TIM_IC_Stop_IT
     356  HAL_TIM_IRQHandler
      94  HAL_TIM_OC_ConfigChannel
      58  HAL_TIM_OC_DeInit
       2  HAL_TIM_OC_DelayElapsedCallback
       6  HAL_TIM_OC_GetState
     226  HAL_TIM_OC_Init
       2  HAL_TIM_OC_MspDeInit
       2  HAL_TIM_OC_MspInit
      56  HAL_TIM_OC_Start
     274  HAL_TIM_OC_Start_DMA
     116  HAL_TIM_OC_Start_IT
      96  HAL_TIM_OC_Stop
     170  HAL_TIM_OC_Stop_DMA
     156  HAL_TIM_OC_Stop_IT
     266  HAL_TIM_OnePulse_ConfigChannel
      58  HAL_TIM_OnePulse_DeInit
       6  HAL_TIM_OnePulse_GetState
     244  HAL_TIM_OnePulse_Init
       2  HAL_TIM_OnePulse_MspDeInit
       2  HAL_TIM_OnePulse_MspInit
      62  HAL_TIM_OnePulse_Start
      78  HAL_TIM_OnePulse_Start_IT
     102  HAL_TIM_OnePulse_Stop
     118  HAL_TIM_OnePulse_Stop_IT
     222  HAL_TIM_PWM_ConfigChannel
      58  HAL_TIM_PWM_DeInit
       6  HAL_TIM_PWM_GetState
     226  HAL_TIM_PWM_Init
       2  HAL_TIM_PWM_MspDeInit
       2  HAL_TIM_PWM_MspInit
       2  HAL_TIM_PWM_PulseFinishedCallback
      54  HAL_TIM_PWM_Start
     270  HAL_TIM_PWM_Start_DMA
     112  HAL_TIM_PWM_Start_IT
     104  HAL_TIM_PWM_Stop
     166  HAL_TIM_PWM_Stop_DMA
     152  HAL_TIM_PWM_Stop_IT
       2  HAL_TIM_PeriodElapsedCallback
      98  HAL_TIM_ReadCapturedValue
     224  HAL_TIM_SlaveConfigSynchronization
     248  HAL_TIM_SlaveConfigSynchronization_IT
       2  HAL_TIM_TriggerCallback
     184  TIM_Base_SetConfig
      28  TIM_CCxChannelCmd
      62  TIM_DMACaptureCplt
      62  TIM_DMADelayPulseCplt
      20  TIM_DMAError
      20  TIM_DMAPeriodElapsedCplt
      20  TIM_DMATriggerCplt
      22  TIM_ETR_SetConfig
      82  TIM_OC1_SetConfig
      90  TIM_OC2_SetConfig
      88  TIM_OC3_SetConfig
      72  TIM_OC4_SetConfig
     104  TIM_TI1_SetConfig

 
 10 248 bytes in section .text
 
 10 248 bytes of CODE memory

Errors: none
Warnings: 1
