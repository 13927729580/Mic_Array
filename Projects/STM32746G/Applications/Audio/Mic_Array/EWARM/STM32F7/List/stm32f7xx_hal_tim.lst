###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.2.10312/W32 for ARM       01/Feb/2016  11:10:27
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\sop1hc\Github\data\Mic_Array_V00\Mic_Array\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_tim.c
#    Command line =  
#        D:\sop1hc\Github\data\Mic_Array_V00\Mic_Array\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_tim.c
#        -D USE_HAL_DRIVER -D STM32F746xx -D USE_STM32746G_DISCO -D
#        USE_IOEXPANDER -D USE_USB_FS -lC
#        D:\sop1hc\Github\data\Mic_Array_V00\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
#        -lA
#        D:\sop1hc\Github\data\Mic_Array_V00\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
#        -o
#        D:\sop1hc\Github\data\Mic_Array_V00\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M7 -e --fpu=VFPv5_sp --dlib_config "D:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.3\arm\INC\c\DLib_Config_Full.h"
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\CMSIS\Device\ST\STM32F7xx\Include\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\STM32F7xx_HAL_Driver\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\STM32746G-Discovery\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\Components\Common\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Log\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Fonts\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\CPU\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_Device_Library\Core\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Core\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Class\MSC\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\drivers\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_Audio\Addons\PDM\
#        -On --use_c++_inline --require_prototypes -I "D:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.3\arm\CMSIS\Include\" -D
#        ARM_MATH_CM7
#    List file    =  
#        D:\sop1hc\Github\data\Mic_Array_V00\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List\stm32f7xx_hal_tim.lst
#    Object file  =  
#        D:\sop1hc\Github\data\Mic_Array_V00\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj\stm32f7xx_hal_tim.o
#
###############################################################################

D:\sop1hc\Github\data\Mic_Array_V00\Mic_Array\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_tim.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f7xx_hal_tim.c
      4            * @author  MCD Application Team
      5            * @version V1.0.1
      6            * @date    25-June-2015
      7            * @brief   TIM HAL module driver.
      8            *          This file provides firmware functions to manage the following 
      9            *          functionalities of the Timer (TIM) peripheral:
     10            *           + Time Base Initialization
     11            *           + Time Base Start
     12            *           + Time Base Start Interruption
     13            *           + Time Base Start DMA
     14            *           + Time Output Compare/PWM Initialization
     15            *           + Time Output Compare/PWM Channel Configuration
     16            *           + Time Output Compare/PWM  Start
     17            *           + Time Output Compare/PWM  Start Interruption
     18            *           + Time Output Compare/PWM Start DMA
     19            *           + Time Input Capture Initialization
     20            *           + Time Input Capture Channel Configuration
     21            *           + Time Input Capture Start
     22            *           + Time Input Capture Start Interruption 
     23            *           + Time Input Capture Start DMA
     24            *           + Time One Pulse Initialization
     25            *           + Time One Pulse Channel Configuration
     26            *           + Time One Pulse Start 
     27            *           + Time Encoder Interface Initialization
     28            *           + Time Encoder Interface Start
     29            *           + Time Encoder Interface Start Interruption
     30            *           + Time Encoder Interface Start DMA
     31            *           + Commutation Event configuration with Interruption and DMA
     32            *           + Time OCRef clear configuration
     33            *           + Time External Clock configuration
     34            @verbatim 
     35            ==============================================================================
     36                                ##### TIMER Generic features #####
     37            ==============================================================================
     38            [..] The Timer features include: 
     39                 (#) 16-bit up, down, up/down auto-reload counter.
     40                 (#) 16-bit programmable prescaler allowing dividing (also on the fly) the 
     41                     counter clock frequency either by any factor between 1 and 65536.
     42                 (#) Up to 4 independent channels for:
     43                     (++) Input Capture
     44                     (++) Output Compare
     45                     (++) PWM generation (Edge and Center-aligned Mode)
     46                     (++) One-pulse mode output               
     47             
     48                                  ##### How to use this driver #####
     49            ==============================================================================
     50              [..]
     51               (#) Initialize the TIM low level resources by implementing the following functions 
     52                   depending from feature used :
     53                     (++) Time Base : HAL_TIM_Base_MspInit() 
     54                     (++) Input Capture : HAL_TIM_IC_MspInit()
     55                     (++) Output Compare : HAL_TIM_OC_MspInit()
     56                     (++) PWM generation : HAL_TIM_PWM_MspInit()
     57                     (++) One-pulse mode output : HAL_TIM_OnePulse_MspInit()
     58                     (++) Encoder mode output : HAL_TIM_Encoder_MspInit()
     59                     
     60               (#) Initialize the TIM low level resources :
     61                  (##) Enable the TIM interface clock using __TIMx_CLK_ENABLE(); 
     62                  (##) TIM pins configuration
     63                      (+++) Enable the clock for the TIM GPIOs using the following function:
     64                           __GPIOx_CLK_ENABLE();   
     65                      (+++) Configure these TIM pins in Alternate function mode using HAL_GPIO_Init();  
     66          
     67               (#) The external Clock can be configured, if needed (the default clock is the 
     68                   internal clock from the APBx), using the following function:
     69                   HAL_TIM_ConfigClockSource, the clock configuration should be done before 
     70                   any start function.
     71            
     72               (#) Configure the TIM in the desired functioning mode using one of the 
     73                   initialization function of this driver:
     74                   (++) HAL_TIM_Base_Init: to use the Timer to generate a simple time base
     75                   (++) HAL_TIM_OC_Init and HAL_TIM_OC_ConfigChannel: to use the Timer to generate an 
     76                        Output Compare signal.
     77                   (++) HAL_TIM_PWM_Init and HAL_TIM_PWM_ConfigChannel: to use the Timer to generate a 
     78                        PWM signal.
     79                   (++) HAL_TIM_IC_Init and HAL_TIM_IC_ConfigChannel: to use the Timer to measure an 
     80                        external signal.
     81                   (++) HAL_TIM_OnePulse_Init and HAL_TIM_OnePulse_ConfigChannel: to use the Timer 
     82                        in One Pulse Mode.
     83                   (++) HAL_TIM_Encoder_Init: to use the Timer Encoder Interface.
     84                   
     85               (#) Activate the TIM peripheral using one of the start functions depending from the feature used: 
     86                     (++) Time Base : HAL_TIM_Base_Start(), HAL_TIM_Base_Start_DMA(), HAL_TIM_Base_Start_IT()
     87                     (++) Input Capture :  HAL_TIM_IC_Start(), HAL_TIM_IC_Start_DMA(), HAL_TIM_IC_Start_IT()
     88                     (++) Output Compare : HAL_TIM_OC_Start(), HAL_TIM_OC_Start_DMA(), HAL_TIM_OC_Start_IT()
     89                     (++) PWM generation : HAL_TIM_PWM_Start(), HAL_TIM_PWM_Start_DMA(), HAL_TIM_PWM_Start_IT()
     90                     (++) One-pulse mode output : HAL_TIM_OnePulse_Start(), HAL_TIM_OnePulse_Start_IT()
     91                     (++) Encoder mode output : HAL_TIM_Encoder_Start(), HAL_TIM_Encoder_Start_DMA(), HAL_TIM_Encoder_Start_IT().
     92          
     93               (#) The DMA Burst is managed with the two following functions:
     94                   HAL_TIM_DMABurst_WriteStart()
     95                   HAL_TIM_DMABurst_ReadStart()
     96            
     97            @endverbatim
     98            ******************************************************************************
     99            * @attention
    100            *
    101            * <h2><center>&copy; COPYRIGHT(c) 2015 STMicroelectronics</center></h2>
    102            *
    103            * Redistribution and use in source and binary forms, with or without modification,
    104            * are permitted provided that the following conditions are met:
    105            *   1. Redistributions of source code must retain the above copyright notice,
    106            *      this list of conditions and the following disclaimer.
    107            *   2. Redistributions in binary form must reproduce the above copyright notice,
    108            *      this list of conditions and the following disclaimer in the documentation
    109            *      and/or other materials provided with the distribution.
    110            *   3. Neither the name of STMicroelectronics nor the names of its contributors
    111            *      may be used to endorse or promote products derived from this software
    112            *      without specific prior written permission.
    113            *
    114            * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
    115            * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
    116            * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
    117            * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
    118            * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
    119            * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
    120            * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
    121            * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
    122            * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
    123            * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
    124            *
    125            ******************************************************************************
    126            */ 
    127          
    128          /* Includes ------------------------------------------------------------------*/
    129          #include "stm32f7xx_hal.h"
    130          
    131          /** @addtogroup STM32F7xx_HAL_Driver
    132            * @{
    133            */
    134          
    135          /** @defgroup TIM TIM
    136            * @brief TIM HAL module driver
    137            * @{
    138            */
    139          
    140          #ifdef HAL_TIM_MODULE_ENABLED
    141          
    142          /* Private typedef -----------------------------------------------------------*/
    143          /* Private define ------------------------------------------------------------*/
    144          /* Private macro -------------------------------------------------------------*/
    145          /* Private variables ---------------------------------------------------------*/
    146          /** @addtogroup TIM_Private_Functions
    147            * @{
    148            */
    149          /* Private function prototypes -----------------------------------------------*/
    150          static void TIM_TI1_ConfigInputStage(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICFilter);
    151          static void TIM_TI2_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
    152                                 uint32_t TIM_ICFilter);
    153          static void TIM_TI2_ConfigInputStage(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICFilter);
    154          static void TIM_TI3_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
    155                                 uint32_t TIM_ICFilter);
    156          static void TIM_TI4_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
    157                                 uint32_t TIM_ICFilter);
    158          
    159          static void TIM_ITRx_SetConfig(TIM_TypeDef* TIMx, uint16_t TIM_ITRx);
    160          static void TIM_DMAPeriodElapsedCplt(DMA_HandleTypeDef *hdma);
    161          static void TIM_DMATriggerCplt(DMA_HandleTypeDef *hdma);
    162          static void TIM_SlaveTimer_SetConfig(TIM_HandleTypeDef *htim,
    163                                               TIM_SlaveConfigTypeDef * sSlaveConfig);
    164          /**
    165            * @}
    166            */
    167            
    168          /* Exported functions --------------------------------------------------------*/
    169          /** @defgroup TIM_Exported_Functions TIM Exported Functions
    170            * @{
    171            */
    172          
    173          /** @defgroup TIM_Exported_Functions_Group1 Time Base functions 
    174           *  @brief    Time Base functions 
    175           *
    176          @verbatim    
    177            ==============================================================================
    178                        ##### Time Base functions #####
    179            ==============================================================================
    180            [..]  
    181              This section provides functions allowing to:
    182              (+) Initialize and configure the TIM base. 
    183              (+) De-initialize the TIM base.
    184              (+) Start the Time Base.
    185              (+) Stop the Time Base.
    186              (+) Start the Time Base and enable interrupt.
    187              (+) Stop the Time Base and disable interrupt.
    188              (+) Start the Time Base and enable DMA transfer.
    189              (+) Stop the Time Base and disable DMA transfer.
    190           
    191          @endverbatim
    192            * @{
    193            */
    194          /**
    195            * @brief  Initializes the TIM Time base Unit according to the specified
    196            *         parameters in the TIM_HandleTypeDef and create the associated handle.
    197            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
    198            *                the configuration information for TIM module.
    199            * @retval HAL status
    200            */

   \                                 In section .text, align 2, keep-with-next
    201          HAL_StatusTypeDef HAL_TIM_Base_Init(TIM_HandleTypeDef *htim)
    202          { 
   \                     HAL_TIM_Base_Init: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    203            /* Check the TIM handle allocation */
    204            if(htim == NULL)
   \   00000004   0x2C00             CMP      R4,#+0
   \   00000006   0xD101             BNE.N    ??HAL_TIM_Base_Init_0
    205            {
    206              return HAL_ERROR;
   \   00000008   0x2001             MOVS     R0,#+1
   \   0000000A   0xE011             B.N      ??HAL_TIM_Base_Init_1
    207            }
    208            
    209            /* Check the parameters */
    210            assert_param(IS_TIM_INSTANCE(htim->Instance)); 
    211            assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
    212            assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
    213            
    214            if(htim->State == HAL_TIM_STATE_RESET)
   \                     ??HAL_TIM_Base_Init_0: (+1)
   \   0000000C   0xF894 0x0039      LDRB     R0,[R4, #+57]
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD102             BNE.N    ??HAL_TIM_Base_Init_2
    215            {  
    216              /* Init the low level hardware : GPIO, CLOCK, NVIC */
    217              HAL_TIM_Base_MspInit(htim);
   \   00000014   0x0020             MOVS     R0,R4
   \   00000016   0x.... 0x....      BL       HAL_TIM_Base_MspInit
    218            }
    219            
    220            /* Set the TIM state */
    221            htim->State= HAL_TIM_STATE_BUSY;
   \                     ??HAL_TIM_Base_Init_2: (+1)
   \   0000001A   0x2002             MOVS     R0,#+2
   \   0000001C   0xF884 0x0039      STRB     R0,[R4, #+57]
    222            
    223            /* Set the Time Base configuration */
    224            TIM_Base_SetConfig(htim->Instance, &htim->Init); 
   \   00000020   0x1D21             ADDS     R1,R4,#+4
   \   00000022   0x6820             LDR      R0,[R4, #+0]
   \   00000024   0x.... 0x....      BL       TIM_Base_SetConfig
    225            
    226            /* Initialize the TIM state*/
    227            htim->State= HAL_TIM_STATE_READY;
   \   00000028   0x2001             MOVS     R0,#+1
   \   0000002A   0xF884 0x0039      STRB     R0,[R4, #+57]
    228            
    229            return HAL_OK;
   \   0000002E   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_Base_Init_1: (+1)
   \   00000030   0xBD10             POP      {R4,PC}          ;; return
    230          }
    231          
    232          /**
    233            * @brief  DeInitializes the TIM Base peripheral 
    234            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
    235            *                the configuration information for TIM module.
    236            * @retval HAL status
    237            */

   \                                 In section .text, align 2, keep-with-next
    238          HAL_StatusTypeDef HAL_TIM_Base_DeInit(TIM_HandleTypeDef *htim)
    239          {  
   \                     HAL_TIM_Base_DeInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    240            /* Check the parameters */
    241            assert_param(IS_TIM_INSTANCE(htim->Instance));
    242          
    243            htim->State = HAL_TIM_STATE_BUSY;
   \   00000004   0x2002             MOVS     R0,#+2
   \   00000006   0xF884 0x0039      STRB     R0,[R4, #+57]
    244             
    245            /* Disable the TIM Peripheral Clock */
    246            __HAL_TIM_DISABLE(htim);
   \   0000000A   0x6820             LDR      R0,[R4, #+0]
   \   0000000C   0x6A00             LDR      R0,[R0, #+32]
   \   0000000E   0xF241 0x1111      MOVW     R1,#+4369
   \   00000012   0x4208             TST      R0,R1
   \   00000014   0xD10B             BNE.N    ??HAL_TIM_Base_DeInit_0
   \   00000016   0x6820             LDR      R0,[R4, #+0]
   \   00000018   0x6A00             LDR      R0,[R0, #+32]
   \   0000001A   0xF240 0x4144      MOVW     R1,#+1092
   \   0000001E   0x4208             TST      R0,R1
   \   00000020   0xD105             BNE.N    ??HAL_TIM_Base_DeInit_0
   \   00000022   0x6820             LDR      R0,[R4, #+0]
   \   00000024   0x6800             LDR      R0,[R0, #+0]
   \   00000026   0x0840             LSRS     R0,R0,#+1
   \   00000028   0x0040             LSLS     R0,R0,#+1
   \   0000002A   0x6821             LDR      R1,[R4, #+0]
   \   0000002C   0x6008             STR      R0,[R1, #+0]
    247              
    248            /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
    249            HAL_TIM_Base_MspDeInit(htim);
   \                     ??HAL_TIM_Base_DeInit_0: (+1)
   \   0000002E   0x0020             MOVS     R0,R4
   \   00000030   0x.... 0x....      BL       HAL_TIM_Base_MspDeInit
    250            
    251            /* Change TIM state */  
    252            htim->State = HAL_TIM_STATE_RESET; 
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0xF884 0x0039      STRB     R0,[R4, #+57]
    253            
    254            /* Release Lock */
    255            __HAL_UNLOCK(htim);
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0xF884 0x0038      STRB     R0,[R4, #+56]
    256          
    257            return HAL_OK;
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0xBD10             POP      {R4,PC}          ;; return
    258          }
    259          
    260          /**
    261            * @brief  Initializes the TIM Base MSP.
    262            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
    263            *                the configuration information for TIM module.
    264            * @retval None
    265            */

   \                                 In section .text, align 2, keep-with-next
    266          __weak void HAL_TIM_Base_MspInit(TIM_HandleTypeDef *htim)
    267          {
    268            /* NOTE : This function Should not be modified, when the callback is needed,
    269                      the HAL_TIM_Base_MspInit could be implemented in the user file
    270             */
    271          }
   \                     HAL_TIM_Base_MspInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    272          
    273          /**
    274            * @brief  DeInitializes TIM Base MSP.
    275            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
    276            *                the configuration information for TIM module.
    277            * @retval None
    278            */

   \                                 In section .text, align 2, keep-with-next
    279          __weak void HAL_TIM_Base_MspDeInit(TIM_HandleTypeDef *htim)
    280          {
    281            /* NOTE : This function Should not be modified, when the callback is needed,
    282                      the HAL_TIM_Base_MspDeInit could be implemented in the user file
    283             */
    284          }
   \                     HAL_TIM_Base_MspDeInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    285          
    286          /**
    287            * @brief  Starts the TIM Base generation.
    288            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
    289            *                the configuration information for TIM module.
    290            * @retval HAL status
    291            */

   \                                 In section .text, align 2, keep-with-next
    292          HAL_StatusTypeDef HAL_TIM_Base_Start(TIM_HandleTypeDef *htim)
    293          {
   \                     HAL_TIM_Base_Start: (+1)
   \   00000000   0x0001             MOVS     R1,R0
    294            /* Check the parameters */
    295            assert_param(IS_TIM_INSTANCE(htim->Instance));
    296            
    297            /* Set the TIM state */
    298            htim->State= HAL_TIM_STATE_BUSY;
   \   00000002   0x2002             MOVS     R0,#+2
   \   00000004   0xF881 0x0039      STRB     R0,[R1, #+57]
    299            
    300            /* Enable the Peripheral */
    301            __HAL_TIM_ENABLE(htim);
   \   00000008   0x6808             LDR      R0,[R1, #+0]
   \   0000000A   0x6800             LDR      R0,[R0, #+0]
   \   0000000C   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000010   0x680A             LDR      R2,[R1, #+0]
   \   00000012   0x6010             STR      R0,[R2, #+0]
    302            
    303            /* Change the TIM state*/
    304            htim->State= HAL_TIM_STATE_READY;
   \   00000014   0x2001             MOVS     R0,#+1
   \   00000016   0xF881 0x0039      STRB     R0,[R1, #+57]
    305            
    306            /* Return function status */
    307            return HAL_OK;
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0x4770             BX       LR               ;; return
    308          }
    309          
    310          /**
    311            * @brief  Stops the TIM Base generation.
    312            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
    313            *                the configuration information for TIM module.
    314            * @retval HAL status
    315            */

   \                                 In section .text, align 2, keep-with-next
    316          HAL_StatusTypeDef HAL_TIM_Base_Stop(TIM_HandleTypeDef *htim)
    317          {
   \                     HAL_TIM_Base_Stop: (+1)
   \   00000000   0x0001             MOVS     R1,R0
    318            /* Check the parameters */
    319            assert_param(IS_TIM_INSTANCE(htim->Instance));
    320            
    321            /* Set the TIM state */
    322            htim->State= HAL_TIM_STATE_BUSY;
   \   00000002   0x2002             MOVS     R0,#+2
   \   00000004   0xF881 0x0039      STRB     R0,[R1, #+57]
    323            
    324            /* Disable the Peripheral */
    325            __HAL_TIM_DISABLE(htim);
   \   00000008   0x6808             LDR      R0,[R1, #+0]
   \   0000000A   0x6A00             LDR      R0,[R0, #+32]
   \   0000000C   0xF241 0x1211      MOVW     R2,#+4369
   \   00000010   0x4210             TST      R0,R2
   \   00000012   0xD10B             BNE.N    ??HAL_TIM_Base_Stop_0
   \   00000014   0x6808             LDR      R0,[R1, #+0]
   \   00000016   0x6A00             LDR      R0,[R0, #+32]
   \   00000018   0xF240 0x4244      MOVW     R2,#+1092
   \   0000001C   0x4210             TST      R0,R2
   \   0000001E   0xD105             BNE.N    ??HAL_TIM_Base_Stop_0
   \   00000020   0x6808             LDR      R0,[R1, #+0]
   \   00000022   0x6800             LDR      R0,[R0, #+0]
   \   00000024   0x0840             LSRS     R0,R0,#+1
   \   00000026   0x0040             LSLS     R0,R0,#+1
   \   00000028   0x680A             LDR      R2,[R1, #+0]
   \   0000002A   0x6010             STR      R0,[R2, #+0]
    326            
    327            /* Change the TIM state*/
    328            htim->State= HAL_TIM_STATE_READY;
   \                     ??HAL_TIM_Base_Stop_0: (+1)
   \   0000002C   0x2001             MOVS     R0,#+1
   \   0000002E   0xF881 0x0039      STRB     R0,[R1, #+57]
    329            
    330            /* Return function status */
    331            return HAL_OK;
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0x4770             BX       LR               ;; return
    332          }
    333          
    334          /**
    335            * @brief  Starts the TIM Base generation in interrupt mode.
    336            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
    337            *                the configuration information for TIM module.
    338            * @retval HAL status
    339            */

   \                                 In section .text, align 2, keep-with-next
    340          HAL_StatusTypeDef HAL_TIM_Base_Start_IT(TIM_HandleTypeDef *htim)
    341          {
   \                     HAL_TIM_Base_Start_IT: (+1)
   \   00000000   0x0001             MOVS     R1,R0
    342            /* Check the parameters */
    343            assert_param(IS_TIM_INSTANCE(htim->Instance));
    344            
    345            /* Enable the TIM Update interrupt */
    346            __HAL_TIM_ENABLE_IT(htim, TIM_IT_UPDATE);
   \   00000002   0x6808             LDR      R0,[R1, #+0]
   \   00000004   0x68C0             LDR      R0,[R0, #+12]
   \   00000006   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   0000000A   0x680A             LDR      R2,[R1, #+0]
   \   0000000C   0x60D0             STR      R0,[R2, #+12]
    347                
    348            /* Enable the Peripheral */
    349            __HAL_TIM_ENABLE(htim);
   \   0000000E   0x6808             LDR      R0,[R1, #+0]
   \   00000010   0x6800             LDR      R0,[R0, #+0]
   \   00000012   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000016   0x680A             LDR      R2,[R1, #+0]
   \   00000018   0x6010             STR      R0,[R2, #+0]
    350                
    351            /* Return function status */
    352            return HAL_OK;
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0x4770             BX       LR               ;; return
    353          }
    354          
    355          /**
    356            * @brief  Stops the TIM Base generation in interrupt mode.
    357            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
    358            *                the configuration information for TIM module.
    359            * @retval HAL status
    360            */

   \                                 In section .text, align 2, keep-with-next
    361          HAL_StatusTypeDef HAL_TIM_Base_Stop_IT(TIM_HandleTypeDef *htim)
    362          {
   \                     HAL_TIM_Base_Stop_IT: (+1)
   \   00000000   0x0001             MOVS     R1,R0
    363            /* Check the parameters */
    364            assert_param(IS_TIM_INSTANCE(htim->Instance));
    365            /* Disable the TIM Update interrupt */
    366            __HAL_TIM_DISABLE_IT(htim, TIM_IT_UPDATE);
   \   00000002   0x6808             LDR      R0,[R1, #+0]
   \   00000004   0x68C0             LDR      R0,[R0, #+12]
   \   00000006   0x0840             LSRS     R0,R0,#+1
   \   00000008   0x0040             LSLS     R0,R0,#+1
   \   0000000A   0x680A             LDR      R2,[R1, #+0]
   \   0000000C   0x60D0             STR      R0,[R2, #+12]
    367                
    368            /* Disable the Peripheral */
    369            __HAL_TIM_DISABLE(htim);
   \   0000000E   0x6808             LDR      R0,[R1, #+0]
   \   00000010   0x6A00             LDR      R0,[R0, #+32]
   \   00000012   0xF241 0x1211      MOVW     R2,#+4369
   \   00000016   0x4210             TST      R0,R2
   \   00000018   0xD10B             BNE.N    ??HAL_TIM_Base_Stop_IT_0
   \   0000001A   0x6808             LDR      R0,[R1, #+0]
   \   0000001C   0x6A00             LDR      R0,[R0, #+32]
   \   0000001E   0xF240 0x4244      MOVW     R2,#+1092
   \   00000022   0x4210             TST      R0,R2
   \   00000024   0xD105             BNE.N    ??HAL_TIM_Base_Stop_IT_0
   \   00000026   0x6808             LDR      R0,[R1, #+0]
   \   00000028   0x6800             LDR      R0,[R0, #+0]
   \   0000002A   0x0840             LSRS     R0,R0,#+1
   \   0000002C   0x0040             LSLS     R0,R0,#+1
   \   0000002E   0x680A             LDR      R2,[R1, #+0]
   \   00000030   0x6010             STR      R0,[R2, #+0]
    370              
    371            /* Return function status */
    372            return HAL_OK;
   \                     ??HAL_TIM_Base_Stop_IT_0: (+1)
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0x4770             BX       LR               ;; return
    373          }
    374          
    375          /**
    376            * @brief  Starts the TIM Base generation in DMA mode.
    377            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
    378            *                the configuration information for TIM module.
    379            * @param  pData: The source Buffer address.
    380            * @param  Length: The length of data to be transferred from memory to peripheral.
    381            * @retval HAL status
    382            */

   \                                 In section .text, align 2, keep-with-next
    383          HAL_StatusTypeDef HAL_TIM_Base_Start_DMA(TIM_HandleTypeDef *htim, uint32_t *pData, uint16_t Length)
    384          {
   \                     HAL_TIM_Base_Start_DMA: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    385            /* Check the parameters */
    386            assert_param(IS_TIM_DMA_INSTANCE(htim->Instance)); 
    387            
    388            if((htim->State == HAL_TIM_STATE_BUSY))
   \   00000008   0xF894 0x0039      LDRB     R0,[R4, #+57]
   \   0000000C   0x2802             CMP      R0,#+2
   \   0000000E   0xD101             BNE.N    ??HAL_TIM_Base_Start_DMA_0
    389            {
    390               return HAL_BUSY;
   \   00000010   0x2002             MOVS     R0,#+2
   \   00000012   0xE02B             B.N      ??HAL_TIM_Base_Start_DMA_1
    391            }
    392            else if((htim->State == HAL_TIM_STATE_READY))
   \                     ??HAL_TIM_Base_Start_DMA_0: (+1)
   \   00000014   0xF894 0x0039      LDRB     R0,[R4, #+57]
   \   00000018   0x2801             CMP      R0,#+1
   \   0000001A   0xD109             BNE.N    ??HAL_TIM_Base_Start_DMA_2
    393            {
    394              if((pData == 0 ) && (Length > 0)) 
   \   0000001C   0x2D00             CMP      R5,#+0
   \   0000001E   0xD104             BNE.N    ??HAL_TIM_Base_Start_DMA_3
   \   00000020   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000022   0x2E00             CMP      R6,#+0
   \   00000024   0xD001             BEQ.N    ??HAL_TIM_Base_Start_DMA_3
    395              {
    396                return HAL_ERROR;                                    
   \   00000026   0x2001             MOVS     R0,#+1
   \   00000028   0xE020             B.N      ??HAL_TIM_Base_Start_DMA_1
    397              }
    398              else
    399              {
    400                htim->State = HAL_TIM_STATE_BUSY;
   \                     ??HAL_TIM_Base_Start_DMA_3: (+1)
   \   0000002A   0x2002             MOVS     R0,#+2
   \   0000002C   0xF884 0x0039      STRB     R0,[R4, #+57]
    401              }
    402            }  
    403            /* Set the DMA Period elapsed callback */
    404            htim->hdma[TIM_DMA_ID_UPDATE]->XferCpltCallback = TIM_DMAPeriodElapsedCplt;
   \                     ??HAL_TIM_Base_Start_DMA_2: (+1)
   \   00000030   0x.... 0x....      LDR.W    R0,??DataTable12
   \   00000034   0x69E1             LDR      R1,[R4, #+28]
   \   00000036   0x63C8             STR      R0,[R1, #+60]
    405               
    406            /* Set the DMA error callback */
    407            htim->hdma[TIM_DMA_ID_UPDATE]->XferErrorCallback = HAL_TIM_DMAError ;
   \   00000038   0x.... 0x....      LDR.W    R0,??DataTable13
   \   0000003C   0x69E1             LDR      R1,[R4, #+28]
   \   0000003E   0x6488             STR      R0,[R1, #+72]
    408            
    409            /* Enable the DMA Stream */
    410            HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_UPDATE], (uint32_t)pData, (uint32_t)&htim->Instance->ARR, Length);
   \   00000040   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000042   0x0033             MOVS     R3,R6
   \   00000044   0x6820             LDR      R0,[R4, #+0]
   \   00000046   0xF110 0x022C      ADDS     R2,R0,#+44
   \   0000004A   0x0029             MOVS     R1,R5
   \   0000004C   0x69E0             LDR      R0,[R4, #+28]
   \   0000004E   0x.... 0x....      BL       HAL_DMA_Start_IT
    411            
    412            /* Enable the TIM Update DMA request */
    413            __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_UPDATE);
   \   00000052   0x6820             LDR      R0,[R4, #+0]
   \   00000054   0x68C0             LDR      R0,[R0, #+12]
   \   00000056   0xF450 0x7080      ORRS     R0,R0,#0x100
   \   0000005A   0x6821             LDR      R1,[R4, #+0]
   \   0000005C   0x60C8             STR      R0,[R1, #+12]
    414          
    415            /* Enable the Peripheral */
    416            __HAL_TIM_ENABLE(htim);  
   \   0000005E   0x6820             LDR      R0,[R4, #+0]
   \   00000060   0x6800             LDR      R0,[R0, #+0]
   \   00000062   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000066   0x6821             LDR      R1,[R4, #+0]
   \   00000068   0x6008             STR      R0,[R1, #+0]
    417            
    418            /* Return function status */
    419            return HAL_OK;
   \   0000006A   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_Base_Start_DMA_1: (+1)
   \   0000006C   0xBD70             POP      {R4-R6,PC}       ;; return
    420          }
    421          
    422          /**
    423            * @brief  Stops the TIM Base generation in DMA mode.
    424            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
    425            *                the configuration information for TIM module.
    426            * @retval HAL status
    427            */

   \                                 In section .text, align 2, keep-with-next
    428          HAL_StatusTypeDef HAL_TIM_Base_Stop_DMA(TIM_HandleTypeDef *htim)
    429          {
   \                     HAL_TIM_Base_Stop_DMA: (+1)
   \   00000000   0x0001             MOVS     R1,R0
    430            /* Check the parameters */
    431            assert_param(IS_TIM_DMA_INSTANCE(htim->Instance));
    432            
    433            /* Disable the TIM Update DMA request */
    434            __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_UPDATE);
   \   00000002   0x6808             LDR      R0,[R1, #+0]
   \   00000004   0x68C0             LDR      R0,[R0, #+12]
   \   00000006   0xF430 0x7080      BICS     R0,R0,#0x100
   \   0000000A   0x680A             LDR      R2,[R1, #+0]
   \   0000000C   0x60D0             STR      R0,[R2, #+12]
    435                
    436            /* Disable the Peripheral */
    437            __HAL_TIM_DISABLE(htim);
   \   0000000E   0x6808             LDR      R0,[R1, #+0]
   \   00000010   0x6A00             LDR      R0,[R0, #+32]
   \   00000012   0xF241 0x1211      MOVW     R2,#+4369
   \   00000016   0x4210             TST      R0,R2
   \   00000018   0xD10B             BNE.N    ??HAL_TIM_Base_Stop_DMA_0
   \   0000001A   0x6808             LDR      R0,[R1, #+0]
   \   0000001C   0x6A00             LDR      R0,[R0, #+32]
   \   0000001E   0xF240 0x4244      MOVW     R2,#+1092
   \   00000022   0x4210             TST      R0,R2
   \   00000024   0xD105             BNE.N    ??HAL_TIM_Base_Stop_DMA_0
   \   00000026   0x6808             LDR      R0,[R1, #+0]
   \   00000028   0x6800             LDR      R0,[R0, #+0]
   \   0000002A   0x0840             LSRS     R0,R0,#+1
   \   0000002C   0x0040             LSLS     R0,R0,#+1
   \   0000002E   0x680A             LDR      R2,[R1, #+0]
   \   00000030   0x6010             STR      R0,[R2, #+0]
    438              
    439            /* Change the htim state */
    440            htim->State = HAL_TIM_STATE_READY;
   \                     ??HAL_TIM_Base_Stop_DMA_0: (+1)
   \   00000032   0x2001             MOVS     R0,#+1
   \   00000034   0xF881 0x0039      STRB     R0,[R1, #+57]
    441                
    442            /* Return function status */
    443            return HAL_OK;
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0x4770             BX       LR               ;; return
    444          }
    445          
    446          /**
    447            * @}
    448            */
    449            
    450          /** @defgroup TIM_Exported_Functions_Group2 Time Output Compare functions 
    451           *  @brief    Time Output Compare functions 
    452           *
    453          @verbatim    
    454            ==============================================================================
    455                            ##### Time Output Compare functions #####
    456            ==============================================================================
    457            [..]
    458              This section provides functions allowing to:
    459              (+) Initialize and configure the TIM Output Compare. 
    460              (+) De-initialize the TIM Output Compare.
    461              (+) Start the Time Output Compare.
    462              (+) Stop the Time Output Compare.
    463              (+) Start the Time Output Compare and enable interrupt.
    464              (+) Stop the Time Output Compare and disable interrupt.
    465              (+) Start the Time Output Compare and enable DMA transfer.
    466              (+) Stop the Time Output Compare and disable DMA transfer.
    467           
    468          @endverbatim
    469            * @{
    470            */
    471          /**
    472            * @brief  Initializes the TIM Output Compare according to the specified
    473            *         parameters in the TIM_HandleTypeDef and create the associated handle.
    474            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
    475            *                the configuration information for TIM module.
    476            * @retval HAL status
    477            */

   \                                 In section .text, align 2, keep-with-next
    478          HAL_StatusTypeDef HAL_TIM_OC_Init(TIM_HandleTypeDef* htim)
    479          {
   \                     HAL_TIM_OC_Init: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    480            /* Check the TIM handle allocation */
    481            if(htim == NULL)
   \   00000004   0x2C00             CMP      R4,#+0
   \   00000006   0xD101             BNE.N    ??HAL_TIM_OC_Init_0
    482            {
    483              return HAL_ERROR;
   \   00000008   0x2001             MOVS     R0,#+1
   \   0000000A   0xE014             B.N      ??HAL_TIM_OC_Init_1
    484            }
    485          
    486            /* Check the parameters */
    487            assert_param(IS_TIM_INSTANCE(htim->Instance));
    488            assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
    489            assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
    490           
    491            if(htim->State == HAL_TIM_STATE_RESET)
   \                     ??HAL_TIM_OC_Init_0: (+1)
   \   0000000C   0xF894 0x0039      LDRB     R0,[R4, #+57]
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD105             BNE.N    ??HAL_TIM_OC_Init_2
    492            { 
    493              /* Allocate lock resource and initialize it */
    494              htim->Lock = HAL_UNLOCKED;  
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0xF884 0x0038      STRB     R0,[R4, #+56]
    495              /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
    496              HAL_TIM_OC_MspInit(htim);
   \   0000001A   0x0020             MOVS     R0,R4
   \   0000001C   0x.... 0x....      BL       HAL_TIM_OC_MspInit
    497            }
    498            
    499            /* Set the TIM state */
    500            htim->State= HAL_TIM_STATE_BUSY;
   \                     ??HAL_TIM_OC_Init_2: (+1)
   \   00000020   0x2002             MOVS     R0,#+2
   \   00000022   0xF884 0x0039      STRB     R0,[R4, #+57]
    501            
    502            /* Init the base time for the Output Compare */  
    503            TIM_Base_SetConfig(htim->Instance,  &htim->Init); 
   \   00000026   0x1D21             ADDS     R1,R4,#+4
   \   00000028   0x6820             LDR      R0,[R4, #+0]
   \   0000002A   0x.... 0x....      BL       TIM_Base_SetConfig
    504            
    505            /* Initialize the TIM state*/
    506            htim->State= HAL_TIM_STATE_READY;
   \   0000002E   0x2001             MOVS     R0,#+1
   \   00000030   0xF884 0x0039      STRB     R0,[R4, #+57]
    507            
    508            return HAL_OK;
   \   00000034   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_OC_Init_1: (+1)
   \   00000036   0xBD10             POP      {R4,PC}          ;; return
    509          }
    510          
    511          /**
    512            * @brief  DeInitializes the TIM peripheral 
    513            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
    514            *                the configuration information for TIM module.
    515            * @retval HAL status
    516            */

   \                                 In section .text, align 2, keep-with-next
    517          HAL_StatusTypeDef HAL_TIM_OC_DeInit(TIM_HandleTypeDef *htim)
    518          {
   \                     HAL_TIM_OC_DeInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    519            /* Check the parameters */
    520            assert_param(IS_TIM_INSTANCE(htim->Instance));
    521            
    522             htim->State = HAL_TIM_STATE_BUSY;
   \   00000004   0x2002             MOVS     R0,#+2
   \   00000006   0xF884 0x0039      STRB     R0,[R4, #+57]
    523             
    524            /* Disable the TIM Peripheral Clock */
    525            __HAL_TIM_DISABLE(htim);
   \   0000000A   0x6820             LDR      R0,[R4, #+0]
   \   0000000C   0x6A00             LDR      R0,[R0, #+32]
   \   0000000E   0xF241 0x1111      MOVW     R1,#+4369
   \   00000012   0x4208             TST      R0,R1
   \   00000014   0xD10B             BNE.N    ??HAL_TIM_OC_DeInit_0
   \   00000016   0x6820             LDR      R0,[R4, #+0]
   \   00000018   0x6A00             LDR      R0,[R0, #+32]
   \   0000001A   0xF240 0x4144      MOVW     R1,#+1092
   \   0000001E   0x4208             TST      R0,R1
   \   00000020   0xD105             BNE.N    ??HAL_TIM_OC_DeInit_0
   \   00000022   0x6820             LDR      R0,[R4, #+0]
   \   00000024   0x6800             LDR      R0,[R0, #+0]
   \   00000026   0x0840             LSRS     R0,R0,#+1
   \   00000028   0x0040             LSLS     R0,R0,#+1
   \   0000002A   0x6821             LDR      R1,[R4, #+0]
   \   0000002C   0x6008             STR      R0,[R1, #+0]
    526            
    527            /* DeInit the low level hardware: GPIO, CLOCK, NVIC and DMA */
    528            HAL_TIM_OC_MspDeInit(htim);
   \                     ??HAL_TIM_OC_DeInit_0: (+1)
   \   0000002E   0x0020             MOVS     R0,R4
   \   00000030   0x.... 0x....      BL       HAL_TIM_OC_MspDeInit
    529              
    530            /* Change TIM state */  
    531            htim->State = HAL_TIM_STATE_RESET; 
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0xF884 0x0039      STRB     R0,[R4, #+57]
    532          
    533            /* Release Lock */
    534            __HAL_UNLOCK(htim);
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0xF884 0x0038      STRB     R0,[R4, #+56]
    535          
    536            return HAL_OK;
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0xBD10             POP      {R4,PC}          ;; return
    537          }
    538          
    539          /**
    540            * @brief  Initializes the TIM Output Compare MSP.
    541            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
    542            *                the configuration information for TIM module.
    543            * @retval None
    544            */

   \                                 In section .text, align 2, keep-with-next
    545          __weak void HAL_TIM_OC_MspInit(TIM_HandleTypeDef *htim)
    546          {
    547            /* NOTE : This function Should not be modified, when the callback is needed,
    548                      the HAL_TIM_OC_MspInit could be implemented in the user file
    549             */
    550          }
   \                     HAL_TIM_OC_MspInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    551          
    552          /**
    553            * @brief  DeInitializes TIM Output Compare MSP.
    554            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
    555            *                the configuration information for TIM module.
    556            * @retval None
    557            */

   \                                 In section .text, align 2, keep-with-next
    558          __weak void HAL_TIM_OC_MspDeInit(TIM_HandleTypeDef *htim)
    559          {
    560            /* NOTE : This function Should not be modified, when the callback is needed,
    561                      the HAL_TIM_OC_MspDeInit could be implemented in the user file
    562             */
    563          }
   \                     HAL_TIM_OC_MspDeInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    564          
    565          /**
    566            * @brief  Starts the TIM Output Compare signal generation.
    567            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
    568            *                the configuration information for TIM module.  
    569            * @param  Channel: TIM Channel to be enabled.
    570            *          This parameter can be one of the following values:
    571            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
    572            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
    573            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
    574            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected   
    575            * @retval HAL status
    576            */

   \                                 In section .text, align 2, keep-with-next
    577          HAL_StatusTypeDef HAL_TIM_OC_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
    578          {
   \                     HAL_TIM_OC_Start: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    579            /* Check the parameters */
    580            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
    581            
    582            /* Enable the Output compare channel */
    583            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
   \   00000006   0x2201             MOVS     R2,#+1
   \   00000008   0x0029             MOVS     R1,R5
   \   0000000A   0x6820             LDR      R0,[R4, #+0]
   \   0000000C   0x.... 0x....      BL       TIM_CCxChannelCmd
    584            
    585            if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
   \   00000010   0x6820             LDR      R0,[R4, #+0]
   \   00000012   0x.... 0x....      LDR.W    R1,??DataTable13_1  ;; 0x40010000
   \   00000016   0x4288             CMP      R0,R1
   \   00000018   0xD004             BEQ.N    ??HAL_TIM_OC_Start_0
   \   0000001A   0x6820             LDR      R0,[R4, #+0]
   \   0000001C   0x.... 0x....      LDR.W    R1,??DataTable14  ;; 0x40010400
   \   00000020   0x4288             CMP      R0,R1
   \   00000022   0xD101             BNE.N    ??HAL_TIM_OC_Start_1
   \                     ??HAL_TIM_OC_Start_0: (+1)
   \   00000024   0x2001             MOVS     R0,#+1
   \   00000026   0xE000             B.N      ??HAL_TIM_OC_Start_2
   \                     ??HAL_TIM_OC_Start_1: (+1)
   \   00000028   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_OC_Start_2: (+1)
   \   0000002A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002C   0x2800             CMP      R0,#+0
   \   0000002E   0xD005             BEQ.N    ??HAL_TIM_OC_Start_3
    586            {
    587              /* Enable the main output */
    588              __HAL_TIM_MOE_ENABLE(htim);
   \   00000030   0x6820             LDR      R0,[R4, #+0]
   \   00000032   0x6C40             LDR      R0,[R0, #+68]
   \   00000034   0xF450 0x4000      ORRS     R0,R0,#0x8000
   \   00000038   0x6821             LDR      R1,[R4, #+0]
   \   0000003A   0x6448             STR      R0,[R1, #+68]
    589            }
    590            
    591            /* Enable the Peripheral */
    592            __HAL_TIM_ENABLE(htim); 
   \                     ??HAL_TIM_OC_Start_3: (+1)
   \   0000003C   0x6820             LDR      R0,[R4, #+0]
   \   0000003E   0x6800             LDR      R0,[R0, #+0]
   \   00000040   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000044   0x6821             LDR      R1,[R4, #+0]
   \   00000046   0x6008             STR      R0,[R1, #+0]
    593            
    594            /* Return function status */
    595            return HAL_OK;
   \   00000048   0x2000             MOVS     R0,#+0
   \   0000004A   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    596          }
    597          
    598          /**
    599            * @brief  Stops the TIM Output Compare signal generation.
    600            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
    601            *                the configuration information for TIM module.
    602            * @param  Channel: TIM Channel to be disabled.
    603            *          This parameter can be one of the following values:
    604            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
    605            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
    606            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
    607            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
    608            * @retval HAL status
    609            */

   \                                 In section .text, align 2, keep-with-next
    610          HAL_StatusTypeDef HAL_TIM_OC_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
    611          {
   \                     HAL_TIM_OC_Stop: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    612            /* Check the parameters */
    613            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
    614            
    615            /* Disable the Output compare channel */
    616            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
   \   00000006   0x2200             MOVS     R2,#+0
   \   00000008   0x0029             MOVS     R1,R5
   \   0000000A   0x6820             LDR      R0,[R4, #+0]
   \   0000000C   0x.... 0x....      BL       TIM_CCxChannelCmd
    617            
    618            if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
   \   00000010   0x6820             LDR      R0,[R4, #+0]
   \   00000012   0x.... 0x....      LDR.W    R1,??DataTable13_1  ;; 0x40010000
   \   00000016   0x4288             CMP      R0,R1
   \   00000018   0xD004             BEQ.N    ??HAL_TIM_OC_Stop_0
   \   0000001A   0x6820             LDR      R0,[R4, #+0]
   \   0000001C   0x.... 0x....      LDR.W    R1,??DataTable14  ;; 0x40010400
   \   00000020   0x4288             CMP      R0,R1
   \   00000022   0xD101             BNE.N    ??HAL_TIM_OC_Stop_1
   \                     ??HAL_TIM_OC_Stop_0: (+1)
   \   00000024   0x2001             MOVS     R0,#+1
   \   00000026   0xE000             B.N      ??HAL_TIM_OC_Stop_2
   \                     ??HAL_TIM_OC_Stop_1: (+1)
   \   00000028   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_OC_Stop_2: (+1)
   \   0000002A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002C   0x2800             CMP      R0,#+0
   \   0000002E   0xD011             BEQ.N    ??HAL_TIM_OC_Stop_3
    619            {
    620              /* Disable the Main Output */
    621              __HAL_TIM_MOE_DISABLE(htim);
   \   00000030   0x6820             LDR      R0,[R4, #+0]
   \   00000032   0x6A00             LDR      R0,[R0, #+32]
   \   00000034   0xF241 0x1111      MOVW     R1,#+4369
   \   00000038   0x4208             TST      R0,R1
   \   0000003A   0xD10B             BNE.N    ??HAL_TIM_OC_Stop_4
   \   0000003C   0x6820             LDR      R0,[R4, #+0]
   \   0000003E   0x6A00             LDR      R0,[R0, #+32]
   \   00000040   0xF240 0x4144      MOVW     R1,#+1092
   \   00000044   0x4208             TST      R0,R1
   \   00000046   0xD105             BNE.N    ??HAL_TIM_OC_Stop_4
   \   00000048   0x6820             LDR      R0,[R4, #+0]
   \   0000004A   0x6C40             LDR      R0,[R0, #+68]
   \   0000004C   0xF430 0x4000      BICS     R0,R0,#0x8000
   \   00000050   0x6821             LDR      R1,[R4, #+0]
   \   00000052   0x6448             STR      R0,[R1, #+68]
    622            }  
    623            
    624            /* Disable the Peripheral */
    625            __HAL_TIM_DISABLE(htim);  
   \                     ??HAL_TIM_OC_Stop_4: (+1)
   \                     ??HAL_TIM_OC_Stop_3: (+1)
   \   00000054   0x6820             LDR      R0,[R4, #+0]
   \   00000056   0x6A00             LDR      R0,[R0, #+32]
   \   00000058   0xF241 0x1111      MOVW     R1,#+4369
   \   0000005C   0x4208             TST      R0,R1
   \   0000005E   0xD10B             BNE.N    ??HAL_TIM_OC_Stop_5
   \   00000060   0x6820             LDR      R0,[R4, #+0]
   \   00000062   0x6A00             LDR      R0,[R0, #+32]
   \   00000064   0xF240 0x4144      MOVW     R1,#+1092
   \   00000068   0x4208             TST      R0,R1
   \   0000006A   0xD105             BNE.N    ??HAL_TIM_OC_Stop_5
   \   0000006C   0x6820             LDR      R0,[R4, #+0]
   \   0000006E   0x6800             LDR      R0,[R0, #+0]
   \   00000070   0x0840             LSRS     R0,R0,#+1
   \   00000072   0x0040             LSLS     R0,R0,#+1
   \   00000074   0x6821             LDR      R1,[R4, #+0]
   \   00000076   0x6008             STR      R0,[R1, #+0]
    626            
    627            /* Return function status */
    628            return HAL_OK;
   \                     ??HAL_TIM_OC_Stop_5: (+1)
   \   00000078   0x2000             MOVS     R0,#+0
   \   0000007A   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    629          }  
    630          
    631          /**
    632            * @brief  Starts the TIM Output Compare signal generation in interrupt mode.
    633            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
    634            *                the configuration information for TIM module.
    635            * @param  Channel: TIM Channel to be enabled.
    636            *          This parameter can be one of the following values:
    637            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
    638            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
    639            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
    640            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
    641            * @retval HAL status
    642            */

   \                                 In section .text, align 2, keep-with-next
    643          HAL_StatusTypeDef HAL_TIM_OC_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
    644          {
   \                     HAL_TIM_OC_Start_IT: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    645            /* Check the parameters */
    646            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
    647            
    648            switch (Channel)
   \   00000006   0x0028             MOVS     R0,R5
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD006             BEQ.N    ??HAL_TIM_OC_Start_IT_0
   \   0000000C   0x2804             CMP      R0,#+4
   \   0000000E   0xD00B             BEQ.N    ??HAL_TIM_OC_Start_IT_1
   \   00000010   0x2808             CMP      R0,#+8
   \   00000012   0xD010             BEQ.N    ??HAL_TIM_OC_Start_IT_2
   \   00000014   0x280C             CMP      R0,#+12
   \   00000016   0xD015             BEQ.N    ??HAL_TIM_OC_Start_IT_3
   \   00000018   0xE01B             B.N      ??HAL_TIM_OC_Start_IT_4
    649            {
    650              case TIM_CHANNEL_1:
    651              {       
    652                /* Enable the TIM Capture/Compare 1 interrupt */
    653                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
   \                     ??HAL_TIM_OC_Start_IT_0: (+1)
   \   0000001A   0x6820             LDR      R0,[R4, #+0]
   \   0000001C   0x68C0             LDR      R0,[R0, #+12]
   \   0000001E   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   00000022   0x6821             LDR      R1,[R4, #+0]
   \   00000024   0x60C8             STR      R0,[R1, #+12]
    654              }
    655              break;
   \   00000026   0xE014             B.N      ??HAL_TIM_OC_Start_IT_5
    656              
    657              case TIM_CHANNEL_2:
    658              {
    659                /* Enable the TIM Capture/Compare 2 interrupt */
    660                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
   \                     ??HAL_TIM_OC_Start_IT_1: (+1)
   \   00000028   0x6820             LDR      R0,[R4, #+0]
   \   0000002A   0x68C0             LDR      R0,[R0, #+12]
   \   0000002C   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   00000030   0x6821             LDR      R1,[R4, #+0]
   \   00000032   0x60C8             STR      R0,[R1, #+12]
    661              }
    662              break;
   \   00000034   0xE00D             B.N      ??HAL_TIM_OC_Start_IT_5
    663              
    664              case TIM_CHANNEL_3:
    665              {
    666                /* Enable the TIM Capture/Compare 3 interrupt */
    667                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);
   \                     ??HAL_TIM_OC_Start_IT_2: (+1)
   \   00000036   0x6820             LDR      R0,[R4, #+0]
   \   00000038   0x68C0             LDR      R0,[R0, #+12]
   \   0000003A   0xF050 0x0008      ORRS     R0,R0,#0x8
   \   0000003E   0x6821             LDR      R1,[R4, #+0]
   \   00000040   0x60C8             STR      R0,[R1, #+12]
    668              }
    669              break;
   \   00000042   0xE006             B.N      ??HAL_TIM_OC_Start_IT_5
    670              
    671              case TIM_CHANNEL_4:
    672              {
    673                /* Enable the TIM Capture/Compare 4 interrupt */
    674                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC4);
   \                     ??HAL_TIM_OC_Start_IT_3: (+1)
   \   00000044   0x6820             LDR      R0,[R4, #+0]
   \   00000046   0x68C0             LDR      R0,[R0, #+12]
   \   00000048   0xF050 0x0010      ORRS     R0,R0,#0x10
   \   0000004C   0x6821             LDR      R1,[R4, #+0]
   \   0000004E   0x60C8             STR      R0,[R1, #+12]
    675              }
    676              break;
   \   00000050   0xE7FF             B.N      ??HAL_TIM_OC_Start_IT_5
    677              
    678              default:
    679              break;
    680            } 
    681          
    682            /* Enable the Output compare channel */
    683            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
   \                     ??HAL_TIM_OC_Start_IT_4: (+1)
   \                     ??HAL_TIM_OC_Start_IT_5: (+1)
   \   00000052   0x2201             MOVS     R2,#+1
   \   00000054   0x0029             MOVS     R1,R5
   \   00000056   0x6820             LDR      R0,[R4, #+0]
   \   00000058   0x.... 0x....      BL       TIM_CCxChannelCmd
    684            
    685            if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
   \   0000005C   0x6820             LDR      R0,[R4, #+0]
   \   0000005E   0x.... 0x....      LDR.W    R1,??DataTable13_1  ;; 0x40010000
   \   00000062   0x4288             CMP      R0,R1
   \   00000064   0xD004             BEQ.N    ??HAL_TIM_OC_Start_IT_6
   \   00000066   0x6820             LDR      R0,[R4, #+0]
   \   00000068   0x.... 0x....      LDR.W    R1,??DataTable14  ;; 0x40010400
   \   0000006C   0x4288             CMP      R0,R1
   \   0000006E   0xD101             BNE.N    ??HAL_TIM_OC_Start_IT_7
   \                     ??HAL_TIM_OC_Start_IT_6: (+1)
   \   00000070   0x2001             MOVS     R0,#+1
   \   00000072   0xE000             B.N      ??HAL_TIM_OC_Start_IT_8
   \                     ??HAL_TIM_OC_Start_IT_7: (+1)
   \   00000074   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_OC_Start_IT_8: (+1)
   \   00000076   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000078   0x2800             CMP      R0,#+0
   \   0000007A   0xD005             BEQ.N    ??HAL_TIM_OC_Start_IT_9
    686            {
    687              /* Enable the main output */
    688              __HAL_TIM_MOE_ENABLE(htim);
   \   0000007C   0x6820             LDR      R0,[R4, #+0]
   \   0000007E   0x6C40             LDR      R0,[R0, #+68]
   \   00000080   0xF450 0x4000      ORRS     R0,R0,#0x8000
   \   00000084   0x6821             LDR      R1,[R4, #+0]
   \   00000086   0x6448             STR      R0,[R1, #+68]
    689            }
    690          
    691            /* Enable the Peripheral */
    692            __HAL_TIM_ENABLE(htim);
   \                     ??HAL_TIM_OC_Start_IT_9: (+1)
   \   00000088   0x6820             LDR      R0,[R4, #+0]
   \   0000008A   0x6800             LDR      R0,[R0, #+0]
   \   0000008C   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000090   0x6821             LDR      R1,[R4, #+0]
   \   00000092   0x6008             STR      R0,[R1, #+0]
    693            
    694            /* Return function status */
    695            return HAL_OK;
   \   00000094   0x2000             MOVS     R0,#+0
   \   00000096   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    696          }
    697          
    698          /**
    699            * @brief  Stops the TIM Output Compare signal generation in interrupt mode.
    700            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
    701            *                the configuration information for TIM module.
    702            * @param  Channel: TIM Channel to be disabled.
    703            *          This parameter can be one of the following values:
    704            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
    705            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
    706            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
    707            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
    708            * @retval HAL status
    709            */

   \                                 In section .text, align 2, keep-with-next
    710          HAL_StatusTypeDef HAL_TIM_OC_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
    711          {
   \                     HAL_TIM_OC_Stop_IT: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    712            /* Check the parameters */
    713            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
    714            
    715            switch (Channel)
   \   00000006   0x0028             MOVS     R0,R5
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD006             BEQ.N    ??HAL_TIM_OC_Stop_IT_0
   \   0000000C   0x2804             CMP      R0,#+4
   \   0000000E   0xD00B             BEQ.N    ??HAL_TIM_OC_Stop_IT_1
   \   00000010   0x2808             CMP      R0,#+8
   \   00000012   0xD010             BEQ.N    ??HAL_TIM_OC_Stop_IT_2
   \   00000014   0x280C             CMP      R0,#+12
   \   00000016   0xD015             BEQ.N    ??HAL_TIM_OC_Stop_IT_3
   \   00000018   0xE01B             B.N      ??HAL_TIM_OC_Stop_IT_4
    716            {
    717              case TIM_CHANNEL_1:
    718              {       
    719                /* Disable the TIM Capture/Compare 1 interrupt */
    720                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
   \                     ??HAL_TIM_OC_Stop_IT_0: (+1)
   \   0000001A   0x6820             LDR      R0,[R4, #+0]
   \   0000001C   0x68C0             LDR      R0,[R0, #+12]
   \   0000001E   0xF030 0x0002      BICS     R0,R0,#0x2
   \   00000022   0x6821             LDR      R1,[R4, #+0]
   \   00000024   0x60C8             STR      R0,[R1, #+12]
    721              }
    722              break;
   \   00000026   0xE014             B.N      ??HAL_TIM_OC_Stop_IT_5
    723              
    724              case TIM_CHANNEL_2:
    725              {
    726                /* Disable the TIM Capture/Compare 2 interrupt */
    727                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
   \                     ??HAL_TIM_OC_Stop_IT_1: (+1)
   \   00000028   0x6820             LDR      R0,[R4, #+0]
   \   0000002A   0x68C0             LDR      R0,[R0, #+12]
   \   0000002C   0xF030 0x0004      BICS     R0,R0,#0x4
   \   00000030   0x6821             LDR      R1,[R4, #+0]
   \   00000032   0x60C8             STR      R0,[R1, #+12]
    728              }
    729              break;
   \   00000034   0xE00D             B.N      ??HAL_TIM_OC_Stop_IT_5
    730              
    731              case TIM_CHANNEL_3:
    732              {
    733                /* Disable the TIM Capture/Compare 3 interrupt */
    734                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);
   \                     ??HAL_TIM_OC_Stop_IT_2: (+1)
   \   00000036   0x6820             LDR      R0,[R4, #+0]
   \   00000038   0x68C0             LDR      R0,[R0, #+12]
   \   0000003A   0xF030 0x0008      BICS     R0,R0,#0x8
   \   0000003E   0x6821             LDR      R1,[R4, #+0]
   \   00000040   0x60C8             STR      R0,[R1, #+12]
    735              }
    736              break;
   \   00000042   0xE006             B.N      ??HAL_TIM_OC_Stop_IT_5
    737              
    738              case TIM_CHANNEL_4:
    739              {
    740                /* Disable the TIM Capture/Compare 4 interrupt */
    741                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC4);
   \                     ??HAL_TIM_OC_Stop_IT_3: (+1)
   \   00000044   0x6820             LDR      R0,[R4, #+0]
   \   00000046   0x68C0             LDR      R0,[R0, #+12]
   \   00000048   0xF030 0x0010      BICS     R0,R0,#0x10
   \   0000004C   0x6821             LDR      R1,[R4, #+0]
   \   0000004E   0x60C8             STR      R0,[R1, #+12]
    742              }
    743              break;
   \   00000050   0xE7FF             B.N      ??HAL_TIM_OC_Stop_IT_5
    744              
    745              default:
    746              break; 
    747            } 
    748            
    749            /* Disable the Output compare channel */
    750            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE); 
   \                     ??HAL_TIM_OC_Stop_IT_4: (+1)
   \                     ??HAL_TIM_OC_Stop_IT_5: (+1)
   \   00000052   0x2200             MOVS     R2,#+0
   \   00000054   0x0029             MOVS     R1,R5
   \   00000056   0x6820             LDR      R0,[R4, #+0]
   \   00000058   0x.... 0x....      BL       TIM_CCxChannelCmd
    751            
    752            if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
   \   0000005C   0x6820             LDR      R0,[R4, #+0]
   \   0000005E   0x.... 0x....      LDR.W    R1,??DataTable13_1  ;; 0x40010000
   \   00000062   0x4288             CMP      R0,R1
   \   00000064   0xD004             BEQ.N    ??HAL_TIM_OC_Stop_IT_6
   \   00000066   0x6820             LDR      R0,[R4, #+0]
   \   00000068   0x.... 0x....      LDR.W    R1,??DataTable14  ;; 0x40010400
   \   0000006C   0x4288             CMP      R0,R1
   \   0000006E   0xD101             BNE.N    ??HAL_TIM_OC_Stop_IT_7
   \                     ??HAL_TIM_OC_Stop_IT_6: (+1)
   \   00000070   0x2001             MOVS     R0,#+1
   \   00000072   0xE000             B.N      ??HAL_TIM_OC_Stop_IT_8
   \                     ??HAL_TIM_OC_Stop_IT_7: (+1)
   \   00000074   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_OC_Stop_IT_8: (+1)
   \   00000076   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000078   0x2800             CMP      R0,#+0
   \   0000007A   0xD011             BEQ.N    ??HAL_TIM_OC_Stop_IT_9
    753            {
    754              /* Disable the Main Output */
    755              __HAL_TIM_MOE_DISABLE(htim);
   \   0000007C   0x6820             LDR      R0,[R4, #+0]
   \   0000007E   0x6A00             LDR      R0,[R0, #+32]
   \   00000080   0xF241 0x1111      MOVW     R1,#+4369
   \   00000084   0x4208             TST      R0,R1
   \   00000086   0xD10B             BNE.N    ??HAL_TIM_OC_Stop_IT_10
   \   00000088   0x6820             LDR      R0,[R4, #+0]
   \   0000008A   0x6A00             LDR      R0,[R0, #+32]
   \   0000008C   0xF240 0x4144      MOVW     R1,#+1092
   \   00000090   0x4208             TST      R0,R1
   \   00000092   0xD105             BNE.N    ??HAL_TIM_OC_Stop_IT_10
   \   00000094   0x6820             LDR      R0,[R4, #+0]
   \   00000096   0x6C40             LDR      R0,[R0, #+68]
   \   00000098   0xF430 0x4000      BICS     R0,R0,#0x8000
   \   0000009C   0x6821             LDR      R1,[R4, #+0]
   \   0000009E   0x6448             STR      R0,[R1, #+68]
    756            }
    757            
    758            /* Disable the Peripheral */
    759            __HAL_TIM_DISABLE(htim);  
   \                     ??HAL_TIM_OC_Stop_IT_10: (+1)
   \                     ??HAL_TIM_OC_Stop_IT_9: (+1)
   \   000000A0   0x6820             LDR      R0,[R4, #+0]
   \   000000A2   0x6A00             LDR      R0,[R0, #+32]
   \   000000A4   0xF241 0x1111      MOVW     R1,#+4369
   \   000000A8   0x4208             TST      R0,R1
   \   000000AA   0xD10B             BNE.N    ??HAL_TIM_OC_Stop_IT_11
   \   000000AC   0x6820             LDR      R0,[R4, #+0]
   \   000000AE   0x6A00             LDR      R0,[R0, #+32]
   \   000000B0   0xF240 0x4144      MOVW     R1,#+1092
   \   000000B4   0x4208             TST      R0,R1
   \   000000B6   0xD105             BNE.N    ??HAL_TIM_OC_Stop_IT_11
   \   000000B8   0x6820             LDR      R0,[R4, #+0]
   \   000000BA   0x6800             LDR      R0,[R0, #+0]
   \   000000BC   0x0840             LSRS     R0,R0,#+1
   \   000000BE   0x0040             LSLS     R0,R0,#+1
   \   000000C0   0x6821             LDR      R1,[R4, #+0]
   \   000000C2   0x6008             STR      R0,[R1, #+0]
    760            
    761            /* Return function status */
    762            return HAL_OK;
   \                     ??HAL_TIM_OC_Stop_IT_11: (+1)
   \   000000C4   0x2000             MOVS     R0,#+0
   \   000000C6   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    763          }
    764          
    765          /**
    766            * @brief  Starts the TIM Output Compare signal generation in DMA mode.
    767            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
    768            *                the configuration information for TIM module.
    769            * @param  Channel: TIM Channel to be enabled.
    770            *          This parameter can be one of the following values:
    771            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
    772            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
    773            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
    774            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
    775            * @param  pData: The source Buffer address.
    776            * @param  Length: The length of data to be transferred from memory to TIM peripheral
    777            * @retval HAL status
    778            */

   \                                 In section .text, align 2, keep-with-next
    779          HAL_StatusTypeDef HAL_TIM_OC_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData, uint16_t Length)
    780          {
   \                     HAL_TIM_OC_Start_DMA: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000F             MOVS     R7,R1
   \   00000006   0x0015             MOVS     R5,R2
   \   00000008   0x001E             MOVS     R6,R3
    781            /* Check the parameters */
    782            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
    783            
    784            if((htim->State == HAL_TIM_STATE_BUSY))
   \   0000000A   0xF894 0x0039      LDRB     R0,[R4, #+57]
   \   0000000E   0x2802             CMP      R0,#+2
   \   00000010   0xD101             BNE.N    ??HAL_TIM_OC_Start_DMA_0
    785            {
    786               return HAL_BUSY;
   \   00000012   0x2002             MOVS     R0,#+2
   \   00000014   0xE099             B.N      ??HAL_TIM_OC_Start_DMA_1
    787            }
    788            else if((htim->State == HAL_TIM_STATE_READY))
   \                     ??HAL_TIM_OC_Start_DMA_0: (+1)
   \   00000016   0xF894 0x0039      LDRB     R0,[R4, #+57]
   \   0000001A   0x2801             CMP      R0,#+1
   \   0000001C   0xD109             BNE.N    ??HAL_TIM_OC_Start_DMA_2
    789            {
    790              if(((uint32_t)pData == 0 ) && (Length > 0)) 
   \   0000001E   0x2D00             CMP      R5,#+0
   \   00000020   0xD104             BNE.N    ??HAL_TIM_OC_Start_DMA_3
   \   00000022   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000024   0x2E00             CMP      R6,#+0
   \   00000026   0xD001             BEQ.N    ??HAL_TIM_OC_Start_DMA_3
    791              {
    792                return HAL_ERROR;                                    
   \   00000028   0x2001             MOVS     R0,#+1
   \   0000002A   0xE08E             B.N      ??HAL_TIM_OC_Start_DMA_1
    793              }
    794              else
    795              {
    796                htim->State = HAL_TIM_STATE_BUSY;
   \                     ??HAL_TIM_OC_Start_DMA_3: (+1)
   \   0000002C   0x2002             MOVS     R0,#+2
   \   0000002E   0xF884 0x0039      STRB     R0,[R4, #+57]
    797              }
    798            }    
    799            switch (Channel)
   \                     ??HAL_TIM_OC_Start_DMA_2: (+1)
   \   00000032   0x0038             MOVS     R0,R7
   \   00000034   0x2800             CMP      R0,#+0
   \   00000036   0xD006             BEQ.N    ??HAL_TIM_OC_Start_DMA_4
   \   00000038   0x2804             CMP      R0,#+4
   \   0000003A   0xD01C             BEQ.N    ??HAL_TIM_OC_Start_DMA_5
   \   0000003C   0x2808             CMP      R0,#+8
   \   0000003E   0xD032             BEQ.N    ??HAL_TIM_OC_Start_DMA_6
   \   00000040   0x280C             CMP      R0,#+12
   \   00000042   0xD048             BEQ.N    ??HAL_TIM_OC_Start_DMA_7
   \   00000044   0xE05F             B.N      ??HAL_TIM_OC_Start_DMA_8
    800            {
    801              case TIM_CHANNEL_1:
    802              {      
    803                /* Set the DMA Period elapsed callback */
    804                htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = HAL_TIM_DMADelayPulseCplt;
   \                     ??HAL_TIM_OC_Start_DMA_4: (+1)
   \   00000046   0x.... 0x....      LDR.W    R0,??DataTable17
   \   0000004A   0x6A21             LDR      R1,[R4, #+32]
   \   0000004C   0x63C8             STR      R0,[R1, #+60]
    805               
    806                /* Set the DMA error callback */
    807                htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = HAL_TIM_DMAError ;
   \   0000004E   0x.... 0x....      LDR.W    R0,??DataTable13
   \   00000052   0x6A21             LDR      R1,[R4, #+32]
   \   00000054   0x6488             STR      R0,[R1, #+72]
    808                
    809                /* Enable the DMA Stream */
    810                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)pData, (uint32_t)&htim->Instance->CCR1, Length);
   \   00000056   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000058   0x0033             MOVS     R3,R6
   \   0000005A   0x6820             LDR      R0,[R4, #+0]
   \   0000005C   0xF110 0x0234      ADDS     R2,R0,#+52
   \   00000060   0x0029             MOVS     R1,R5
   \   00000062   0x6A20             LDR      R0,[R4, #+32]
   \   00000064   0x.... 0x....      BL       HAL_DMA_Start_IT
    811                
    812                /* Enable the TIM Capture/Compare 1 DMA request */
    813                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
   \   00000068   0x6820             LDR      R0,[R4, #+0]
   \   0000006A   0x68C0             LDR      R0,[R0, #+12]
   \   0000006C   0xF450 0x7000      ORRS     R0,R0,#0x200
   \   00000070   0x6821             LDR      R1,[R4, #+0]
   \   00000072   0x60C8             STR      R0,[R1, #+12]
    814              }
    815              break;
   \   00000074   0xE047             B.N      ??HAL_TIM_OC_Start_DMA_9
    816              
    817              case TIM_CHANNEL_2:
    818              {
    819                /* Set the DMA Period elapsed callback */
    820                htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = HAL_TIM_DMADelayPulseCplt;
   \                     ??HAL_TIM_OC_Start_DMA_5: (+1)
   \   00000076   0x.... 0x....      LDR.W    R0,??DataTable17
   \   0000007A   0x6A61             LDR      R1,[R4, #+36]
   \   0000007C   0x63C8             STR      R0,[R1, #+60]
    821               
    822                /* Set the DMA error callback */
    823                htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = HAL_TIM_DMAError ;
   \   0000007E   0x.... 0x....      LDR.W    R0,??DataTable13
   \   00000082   0x6A61             LDR      R1,[R4, #+36]
   \   00000084   0x6488             STR      R0,[R1, #+72]
    824                
    825                /* Enable the DMA Stream */
    826                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)pData, (uint32_t)&htim->Instance->CCR2, Length);
   \   00000086   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000088   0x0033             MOVS     R3,R6
   \   0000008A   0x6820             LDR      R0,[R4, #+0]
   \   0000008C   0xF110 0x0238      ADDS     R2,R0,#+56
   \   00000090   0x0029             MOVS     R1,R5
   \   00000092   0x6A60             LDR      R0,[R4, #+36]
   \   00000094   0x.... 0x....      BL       HAL_DMA_Start_IT
    827                
    828                /* Enable the TIM Capture/Compare 2 DMA request */
    829                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
   \   00000098   0x6820             LDR      R0,[R4, #+0]
   \   0000009A   0x68C0             LDR      R0,[R0, #+12]
   \   0000009C   0xF450 0x6080      ORRS     R0,R0,#0x400
   \   000000A0   0x6821             LDR      R1,[R4, #+0]
   \   000000A2   0x60C8             STR      R0,[R1, #+12]
    830              }
    831              break;
   \   000000A4   0xE02F             B.N      ??HAL_TIM_OC_Start_DMA_9
    832              
    833              case TIM_CHANNEL_3:
    834              {
    835                /* Set the DMA Period elapsed callback */
    836                htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = HAL_TIM_DMADelayPulseCplt;
   \                     ??HAL_TIM_OC_Start_DMA_6: (+1)
   \   000000A6   0x.... 0x....      LDR.W    R0,??DataTable17
   \   000000AA   0x6AA1             LDR      R1,[R4, #+40]
   \   000000AC   0x63C8             STR      R0,[R1, #+60]
    837               
    838                /* Set the DMA error callback */
    839                htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = HAL_TIM_DMAError ;
   \   000000AE   0x.... 0x....      LDR.W    R0,??DataTable13
   \   000000B2   0x6AA1             LDR      R1,[R4, #+40]
   \   000000B4   0x6488             STR      R0,[R1, #+72]
    840                
    841                /* Enable the DMA Stream */
    842                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)pData, (uint32_t)&htim->Instance->CCR3,Length);
   \   000000B6   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   000000B8   0x0033             MOVS     R3,R6
   \   000000BA   0x6820             LDR      R0,[R4, #+0]
   \   000000BC   0xF110 0x023C      ADDS     R2,R0,#+60
   \   000000C0   0x0029             MOVS     R1,R5
   \   000000C2   0x6AA0             LDR      R0,[R4, #+40]
   \   000000C4   0x.... 0x....      BL       HAL_DMA_Start_IT
    843                
    844                /* Enable the TIM Capture/Compare 3 DMA request */
    845                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);
   \   000000C8   0x6820             LDR      R0,[R4, #+0]
   \   000000CA   0x68C0             LDR      R0,[R0, #+12]
   \   000000CC   0xF450 0x6000      ORRS     R0,R0,#0x800
   \   000000D0   0x6821             LDR      R1,[R4, #+0]
   \   000000D2   0x60C8             STR      R0,[R1, #+12]
    846              }
    847              break;
   \   000000D4   0xE017             B.N      ??HAL_TIM_OC_Start_DMA_9
    848              
    849              case TIM_CHANNEL_4:
    850              {
    851               /* Set the DMA Period elapsed callback */
    852                htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = HAL_TIM_DMADelayPulseCplt;
   \                     ??HAL_TIM_OC_Start_DMA_7: (+1)
   \   000000D6   0x.... 0x....      LDR.W    R0,??DataTable17
   \   000000DA   0x6AE1             LDR      R1,[R4, #+44]
   \   000000DC   0x63C8             STR      R0,[R1, #+60]
    853               
    854                /* Set the DMA error callback */
    855                htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = HAL_TIM_DMAError ;
   \   000000DE   0x.... 0x....      LDR.W    R0,??DataTable13
   \   000000E2   0x6AE1             LDR      R1,[R4, #+44]
   \   000000E4   0x6488             STR      R0,[R1, #+72]
    856                
    857                /* Enable the DMA Stream */
    858                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)pData, (uint32_t)&htim->Instance->CCR4, Length);
   \   000000E6   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   000000E8   0x0033             MOVS     R3,R6
   \   000000EA   0x6820             LDR      R0,[R4, #+0]
   \   000000EC   0xF110 0x0240      ADDS     R2,R0,#+64
   \   000000F0   0x0029             MOVS     R1,R5
   \   000000F2   0x6AE0             LDR      R0,[R4, #+44]
   \   000000F4   0x.... 0x....      BL       HAL_DMA_Start_IT
    859                
    860                /* Enable the TIM Capture/Compare 4 DMA request */
    861                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC4);
   \   000000F8   0x6820             LDR      R0,[R4, #+0]
   \   000000FA   0x68C0             LDR      R0,[R0, #+12]
   \   000000FC   0xF450 0x5080      ORRS     R0,R0,#0x1000
   \   00000100   0x6821             LDR      R1,[R4, #+0]
   \   00000102   0x60C8             STR      R0,[R1, #+12]
    862              }
    863              break;
   \   00000104   0xE7FF             B.N      ??HAL_TIM_OC_Start_DMA_9
    864              
    865              default:
    866              break;
    867            }
    868          
    869            /* Enable the Output compare channel */
    870            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
   \                     ??HAL_TIM_OC_Start_DMA_8: (+1)
   \                     ??HAL_TIM_OC_Start_DMA_9: (+1)
   \   00000106   0x2201             MOVS     R2,#+1
   \   00000108   0x0039             MOVS     R1,R7
   \   0000010A   0x6820             LDR      R0,[R4, #+0]
   \   0000010C   0x.... 0x....      BL       TIM_CCxChannelCmd
    871            
    872            if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
   \   00000110   0x6820             LDR      R0,[R4, #+0]
   \   00000112   0x.... 0x....      LDR.W    R1,??DataTable13_1  ;; 0x40010000
   \   00000116   0x4288             CMP      R0,R1
   \   00000118   0xD004             BEQ.N    ??HAL_TIM_OC_Start_DMA_10
   \   0000011A   0x6820             LDR      R0,[R4, #+0]
   \   0000011C   0x.... 0x....      LDR.W    R1,??DataTable14  ;; 0x40010400
   \   00000120   0x4288             CMP      R0,R1
   \   00000122   0xD101             BNE.N    ??HAL_TIM_OC_Start_DMA_11
   \                     ??HAL_TIM_OC_Start_DMA_10: (+1)
   \   00000124   0x2001             MOVS     R0,#+1
   \   00000126   0xE000             B.N      ??HAL_TIM_OC_Start_DMA_12
   \                     ??HAL_TIM_OC_Start_DMA_11: (+1)
   \   00000128   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_OC_Start_DMA_12: (+1)
   \   0000012A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000012C   0x2800             CMP      R0,#+0
   \   0000012E   0xD005             BEQ.N    ??HAL_TIM_OC_Start_DMA_13
    873            {
    874              /* Enable the main output */
    875              __HAL_TIM_MOE_ENABLE(htim);
   \   00000130   0x6820             LDR      R0,[R4, #+0]
   \   00000132   0x6C40             LDR      R0,[R0, #+68]
   \   00000134   0xF450 0x4000      ORRS     R0,R0,#0x8000
   \   00000138   0x6821             LDR      R1,[R4, #+0]
   \   0000013A   0x6448             STR      R0,[R1, #+68]
    876            }  
    877            
    878            /* Enable the Peripheral */
    879            __HAL_TIM_ENABLE(htim); 
   \                     ??HAL_TIM_OC_Start_DMA_13: (+1)
   \   0000013C   0x6820             LDR      R0,[R4, #+0]
   \   0000013E   0x6800             LDR      R0,[R0, #+0]
   \   00000140   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000144   0x6821             LDR      R1,[R4, #+0]
   \   00000146   0x6008             STR      R0,[R1, #+0]
    880            
    881            /* Return function status */
    882            return HAL_OK;
   \   00000148   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_OC_Start_DMA_1: (+1)
   \   0000014A   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    883          }
    884          
    885          /**
    886            * @brief  Stops the TIM Output Compare signal generation in DMA mode.
    887            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
    888            *                the configuration information for TIM module.
    889            * @param  Channel: TIM Channel to be disabled.
    890            *          This parameter can be one of the following values:
    891            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
    892            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
    893            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
    894            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
    895            * @retval HAL status
    896            */

   \                                 In section .text, align 2, keep-with-next
    897          HAL_StatusTypeDef HAL_TIM_OC_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
    898          {
   \                     HAL_TIM_OC_Stop_DMA: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    899            /* Check the parameters */
    900            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
    901            
    902            switch (Channel)
   \   00000006   0x0028             MOVS     R0,R5
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD006             BEQ.N    ??HAL_TIM_OC_Stop_DMA_0
   \   0000000C   0x2804             CMP      R0,#+4
   \   0000000E   0xD00B             BEQ.N    ??HAL_TIM_OC_Stop_DMA_1
   \   00000010   0x2808             CMP      R0,#+8
   \   00000012   0xD010             BEQ.N    ??HAL_TIM_OC_Stop_DMA_2
   \   00000014   0x280C             CMP      R0,#+12
   \   00000016   0xD015             BEQ.N    ??HAL_TIM_OC_Stop_DMA_3
   \   00000018   0xE01B             B.N      ??HAL_TIM_OC_Stop_DMA_4
    903            {
    904              case TIM_CHANNEL_1:
    905              {       
    906                /* Disable the TIM Capture/Compare 1 DMA request */
    907                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
   \                     ??HAL_TIM_OC_Stop_DMA_0: (+1)
   \   0000001A   0x6820             LDR      R0,[R4, #+0]
   \   0000001C   0x68C0             LDR      R0,[R0, #+12]
   \   0000001E   0xF430 0x7000      BICS     R0,R0,#0x200
   \   00000022   0x6821             LDR      R1,[R4, #+0]
   \   00000024   0x60C8             STR      R0,[R1, #+12]
    908              }
    909              break;
   \   00000026   0xE014             B.N      ??HAL_TIM_OC_Stop_DMA_5
    910              
    911              case TIM_CHANNEL_2:
    912              {
    913                /* Disable the TIM Capture/Compare 2 DMA request */
    914                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
   \                     ??HAL_TIM_OC_Stop_DMA_1: (+1)
   \   00000028   0x6820             LDR      R0,[R4, #+0]
   \   0000002A   0x68C0             LDR      R0,[R0, #+12]
   \   0000002C   0xF430 0x6080      BICS     R0,R0,#0x400
   \   00000030   0x6821             LDR      R1,[R4, #+0]
   \   00000032   0x60C8             STR      R0,[R1, #+12]
    915              }
    916              break;
   \   00000034   0xE00D             B.N      ??HAL_TIM_OC_Stop_DMA_5
    917              
    918              case TIM_CHANNEL_3:
    919              {
    920                /* Disable the TIM Capture/Compare 3 DMA request */
    921                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);
   \                     ??HAL_TIM_OC_Stop_DMA_2: (+1)
   \   00000036   0x6820             LDR      R0,[R4, #+0]
   \   00000038   0x68C0             LDR      R0,[R0, #+12]
   \   0000003A   0xF430 0x6000      BICS     R0,R0,#0x800
   \   0000003E   0x6821             LDR      R1,[R4, #+0]
   \   00000040   0x60C8             STR      R0,[R1, #+12]
    922              }
    923              break;
   \   00000042   0xE006             B.N      ??HAL_TIM_OC_Stop_DMA_5
    924              
    925              case TIM_CHANNEL_4:
    926              {
    927                /* Disable the TIM Capture/Compare 4 interrupt */
    928                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC4);
   \                     ??HAL_TIM_OC_Stop_DMA_3: (+1)
   \   00000044   0x6820             LDR      R0,[R4, #+0]
   \   00000046   0x68C0             LDR      R0,[R0, #+12]
   \   00000048   0xF430 0x5080      BICS     R0,R0,#0x1000
   \   0000004C   0x6821             LDR      R1,[R4, #+0]
   \   0000004E   0x60C8             STR      R0,[R1, #+12]
    929              }
    930              break;
   \   00000050   0xE7FF             B.N      ??HAL_TIM_OC_Stop_DMA_5
    931              
    932              default:
    933              break;
    934            } 
    935            
    936            /* Disable the Output compare channel */
    937            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
   \                     ??HAL_TIM_OC_Stop_DMA_4: (+1)
   \                     ??HAL_TIM_OC_Stop_DMA_5: (+1)
   \   00000052   0x2200             MOVS     R2,#+0
   \   00000054   0x0029             MOVS     R1,R5
   \   00000056   0x6820             LDR      R0,[R4, #+0]
   \   00000058   0x.... 0x....      BL       TIM_CCxChannelCmd
    938            
    939            if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
   \   0000005C   0x6820             LDR      R0,[R4, #+0]
   \   0000005E   0x.... 0x....      LDR.W    R1,??DataTable13_1  ;; 0x40010000
   \   00000062   0x4288             CMP      R0,R1
   \   00000064   0xD004             BEQ.N    ??HAL_TIM_OC_Stop_DMA_6
   \   00000066   0x6820             LDR      R0,[R4, #+0]
   \   00000068   0x.... 0x....      LDR.W    R1,??DataTable14  ;; 0x40010400
   \   0000006C   0x4288             CMP      R0,R1
   \   0000006E   0xD101             BNE.N    ??HAL_TIM_OC_Stop_DMA_7
   \                     ??HAL_TIM_OC_Stop_DMA_6: (+1)
   \   00000070   0x2001             MOVS     R0,#+1
   \   00000072   0xE000             B.N      ??HAL_TIM_OC_Stop_DMA_8
   \                     ??HAL_TIM_OC_Stop_DMA_7: (+1)
   \   00000074   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_OC_Stop_DMA_8: (+1)
   \   00000076   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000078   0x2800             CMP      R0,#+0
   \   0000007A   0xD011             BEQ.N    ??HAL_TIM_OC_Stop_DMA_9
    940            {
    941              /* Disable the Main Output */
    942              __HAL_TIM_MOE_DISABLE(htim);
   \   0000007C   0x6820             LDR      R0,[R4, #+0]
   \   0000007E   0x6A00             LDR      R0,[R0, #+32]
   \   00000080   0xF241 0x1111      MOVW     R1,#+4369
   \   00000084   0x4208             TST      R0,R1
   \   00000086   0xD10B             BNE.N    ??HAL_TIM_OC_Stop_DMA_10
   \   00000088   0x6820             LDR      R0,[R4, #+0]
   \   0000008A   0x6A00             LDR      R0,[R0, #+32]
   \   0000008C   0xF240 0x4144      MOVW     R1,#+1092
   \   00000090   0x4208             TST      R0,R1
   \   00000092   0xD105             BNE.N    ??HAL_TIM_OC_Stop_DMA_10
   \   00000094   0x6820             LDR      R0,[R4, #+0]
   \   00000096   0x6C40             LDR      R0,[R0, #+68]
   \   00000098   0xF430 0x4000      BICS     R0,R0,#0x8000
   \   0000009C   0x6821             LDR      R1,[R4, #+0]
   \   0000009E   0x6448             STR      R0,[R1, #+68]
    943            }
    944            
    945            /* Disable the Peripheral */
    946            __HAL_TIM_DISABLE(htim);
   \                     ??HAL_TIM_OC_Stop_DMA_10: (+1)
   \                     ??HAL_TIM_OC_Stop_DMA_9: (+1)
   \   000000A0   0x6820             LDR      R0,[R4, #+0]
   \   000000A2   0x6A00             LDR      R0,[R0, #+32]
   \   000000A4   0xF241 0x1111      MOVW     R1,#+4369
   \   000000A8   0x4208             TST      R0,R1
   \   000000AA   0xD10B             BNE.N    ??HAL_TIM_OC_Stop_DMA_11
   \   000000AC   0x6820             LDR      R0,[R4, #+0]
   \   000000AE   0x6A00             LDR      R0,[R0, #+32]
   \   000000B0   0xF240 0x4144      MOVW     R1,#+1092
   \   000000B4   0x4208             TST      R0,R1
   \   000000B6   0xD105             BNE.N    ??HAL_TIM_OC_Stop_DMA_11
   \   000000B8   0x6820             LDR      R0,[R4, #+0]
   \   000000BA   0x6800             LDR      R0,[R0, #+0]
   \   000000BC   0x0840             LSRS     R0,R0,#+1
   \   000000BE   0x0040             LSLS     R0,R0,#+1
   \   000000C0   0x6821             LDR      R1,[R4, #+0]
   \   000000C2   0x6008             STR      R0,[R1, #+0]
    947            
    948            /* Change the htim state */
    949            htim->State = HAL_TIM_STATE_READY;
   \                     ??HAL_TIM_OC_Stop_DMA_11: (+1)
   \   000000C4   0x2001             MOVS     R0,#+1
   \   000000C6   0xF884 0x0039      STRB     R0,[R4, #+57]
    950            
    951            /* Return function status */
    952            return HAL_OK;
   \   000000CA   0x2000             MOVS     R0,#+0
   \   000000CC   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    953          }
    954          
    955          /**
    956            * @}
    957            */
    958          
    959          /** @defgroup TIM_Exported_Functions_Group3 Time PWM functions 
    960           *  @brief    Time PWM functions 
    961           *
    962          @verbatim    
    963            ==============================================================================
    964                                    ##### Time PWM functions #####
    965            ==============================================================================
    966            [..]  
    967              This section provides functions allowing to:
    968              (+) Initialize and configure the TIM OPWM. 
    969              (+) De-initialize the TIM PWM.
    970              (+) Start the Time PWM.
    971              (+) Stop the Time PWM.
    972              (+) Start the Time PWM and enable interrupt.
    973              (+) Stop the Time PWM and disable interrupt.
    974              (+) Start the Time PWM and enable DMA transfer.
    975              (+) Stop the Time PWM and disable DMA transfer.
    976           
    977          @endverbatim
    978            * @{
    979            */
    980          /**
    981            * @brief  Initializes the TIM PWM Time Base according to the specified
    982            *         parameters in the TIM_HandleTypeDef and create the associated handle.
    983            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
    984            *                the configuration information for TIM module.
    985            * @retval HAL status
    986            */

   \                                 In section .text, align 2, keep-with-next
    987          HAL_StatusTypeDef HAL_TIM_PWM_Init(TIM_HandleTypeDef *htim)
    988          {
   \                     HAL_TIM_PWM_Init: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    989            /* Check the TIM handle allocation */
    990            if(htim == NULL)
   \   00000004   0x2C00             CMP      R4,#+0
   \   00000006   0xD101             BNE.N    ??HAL_TIM_PWM_Init_0
    991            {
    992              return HAL_ERROR;
   \   00000008   0x2001             MOVS     R0,#+1
   \   0000000A   0xE014             B.N      ??HAL_TIM_PWM_Init_1
    993            }
    994          
    995            /* Check the parameters */
    996            assert_param(IS_TIM_INSTANCE(htim->Instance));
    997            assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
    998            assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
    999          
   1000            if(htim->State == HAL_TIM_STATE_RESET)
   \                     ??HAL_TIM_PWM_Init_0: (+1)
   \   0000000C   0xF894 0x0039      LDRB     R0,[R4, #+57]
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD105             BNE.N    ??HAL_TIM_PWM_Init_2
   1001            {
   1002              /* Allocate lock resource and initialize it */
   1003              htim->Lock = HAL_UNLOCKED;  
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0xF884 0x0038      STRB     R0,[R4, #+56]
   1004              /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
   1005              HAL_TIM_PWM_MspInit(htim);
   \   0000001A   0x0020             MOVS     R0,R4
   \   0000001C   0x.... 0x....      BL       HAL_TIM_PWM_MspInit
   1006            }
   1007          
   1008            /* Set the TIM state */
   1009            htim->State= HAL_TIM_STATE_BUSY;  
   \                     ??HAL_TIM_PWM_Init_2: (+1)
   \   00000020   0x2002             MOVS     R0,#+2
   \   00000022   0xF884 0x0039      STRB     R0,[R4, #+57]
   1010            
   1011            /* Init the base time for the PWM */  
   1012            TIM_Base_SetConfig(htim->Instance, &htim->Init); 
   \   00000026   0x1D21             ADDS     R1,R4,#+4
   \   00000028   0x6820             LDR      R0,[R4, #+0]
   \   0000002A   0x.... 0x....      BL       TIM_Base_SetConfig
   1013             
   1014            /* Initialize the TIM state*/
   1015            htim->State= HAL_TIM_STATE_READY;
   \   0000002E   0x2001             MOVS     R0,#+1
   \   00000030   0xF884 0x0039      STRB     R0,[R4, #+57]
   1016            
   1017            return HAL_OK;
   \   00000034   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_PWM_Init_1: (+1)
   \   00000036   0xBD10             POP      {R4,PC}          ;; return
   1018          }  
   1019          
   1020          /**
   1021            * @brief  DeInitializes the TIM peripheral 
   1022            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   1023            *                the configuration information for TIM module.
   1024            * @retval HAL status
   1025            */

   \                                 In section .text, align 2, keep-with-next
   1026          HAL_StatusTypeDef HAL_TIM_PWM_DeInit(TIM_HandleTypeDef *htim)
   1027          {
   \                     HAL_TIM_PWM_DeInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1028            /* Check the parameters */
   1029            assert_param(IS_TIM_INSTANCE(htim->Instance));
   1030            
   1031            htim->State = HAL_TIM_STATE_BUSY;
   \   00000004   0x2002             MOVS     R0,#+2
   \   00000006   0xF884 0x0039      STRB     R0,[R4, #+57]
   1032            
   1033            /* Disable the TIM Peripheral Clock */
   1034            __HAL_TIM_DISABLE(htim);
   \   0000000A   0x6820             LDR      R0,[R4, #+0]
   \   0000000C   0x6A00             LDR      R0,[R0, #+32]
   \   0000000E   0xF241 0x1111      MOVW     R1,#+4369
   \   00000012   0x4208             TST      R0,R1
   \   00000014   0xD10B             BNE.N    ??HAL_TIM_PWM_DeInit_0
   \   00000016   0x6820             LDR      R0,[R4, #+0]
   \   00000018   0x6A00             LDR      R0,[R0, #+32]
   \   0000001A   0xF240 0x4144      MOVW     R1,#+1092
   \   0000001E   0x4208             TST      R0,R1
   \   00000020   0xD105             BNE.N    ??HAL_TIM_PWM_DeInit_0
   \   00000022   0x6820             LDR      R0,[R4, #+0]
   \   00000024   0x6800             LDR      R0,[R0, #+0]
   \   00000026   0x0840             LSRS     R0,R0,#+1
   \   00000028   0x0040             LSLS     R0,R0,#+1
   \   0000002A   0x6821             LDR      R1,[R4, #+0]
   \   0000002C   0x6008             STR      R0,[R1, #+0]
   1035              
   1036            /* DeInit the low level hardware: GPIO, CLOCK, NVIC and DMA */
   1037            HAL_TIM_PWM_MspDeInit(htim);
   \                     ??HAL_TIM_PWM_DeInit_0: (+1)
   \   0000002E   0x0020             MOVS     R0,R4
   \   00000030   0x.... 0x....      BL       HAL_TIM_PWM_MspDeInit
   1038              
   1039            /* Change TIM state */  
   1040            htim->State = HAL_TIM_STATE_RESET; 
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0xF884 0x0039      STRB     R0,[R4, #+57]
   1041          
   1042            /* Release Lock */
   1043            __HAL_UNLOCK(htim);
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0xF884 0x0038      STRB     R0,[R4, #+56]
   1044          
   1045            return HAL_OK;
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0xBD10             POP      {R4,PC}          ;; return
   1046          }
   1047          
   1048          /**
   1049            * @brief  Initializes the TIM PWM MSP.
   1050            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   1051            *                the configuration information for TIM module.
   1052            * @retval None
   1053            */

   \                                 In section .text, align 2, keep-with-next
   1054          __weak void HAL_TIM_PWM_MspInit(TIM_HandleTypeDef *htim)
   1055          {
   1056            /* NOTE : This function Should not be modified, when the callback is needed,
   1057                      the HAL_TIM_PWM_MspInit could be implemented in the user file
   1058             */
   1059          }
   \                     HAL_TIM_PWM_MspInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1060          
   1061          /**
   1062            * @brief  DeInitializes TIM PWM MSP.
   1063            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   1064            *                the configuration information for TIM module.
   1065            * @retval None
   1066            */

   \                                 In section .text, align 2, keep-with-next
   1067          __weak void HAL_TIM_PWM_MspDeInit(TIM_HandleTypeDef *htim)
   1068          {
   1069            /* NOTE : This function Should not be modified, when the callback is needed,
   1070                      the HAL_TIM_PWM_MspDeInit could be implemented in the user file
   1071             */
   1072          }
   \                     HAL_TIM_PWM_MspDeInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1073          
   1074          /**
   1075            * @brief  Starts the PWM signal generation.
   1076            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   1077            *                the configuration information for TIM module.
   1078            * @param  Channel: TIM Channels to be enabled.
   1079            *          This parameter can be one of the following values:
   1080            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1081            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1082            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1083            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1084            * @retval HAL status
   1085            */

   \                                 In section .text, align 2, keep-with-next
   1086          HAL_StatusTypeDef HAL_TIM_PWM_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
   1087          {
   \                     HAL_TIM_PWM_Start: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1088            /* Check the parameters */
   1089            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1090          
   1091            /* Enable the Capture compare channel */
   1092            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
   \   00000006   0x2201             MOVS     R2,#+1
   \   00000008   0x0029             MOVS     R1,R5
   \   0000000A   0x6820             LDR      R0,[R4, #+0]
   \   0000000C   0x.... 0x....      BL       TIM_CCxChannelCmd
   1093            
   1094            if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
   \   00000010   0x6820             LDR      R0,[R4, #+0]
   \   00000012   0x.... 0x....      LDR.W    R1,??DataTable13_1  ;; 0x40010000
   \   00000016   0x4288             CMP      R0,R1
   \   00000018   0xD004             BEQ.N    ??HAL_TIM_PWM_Start_0
   \   0000001A   0x6820             LDR      R0,[R4, #+0]
   \   0000001C   0x.... 0x....      LDR.W    R1,??DataTable14  ;; 0x40010400
   \   00000020   0x4288             CMP      R0,R1
   \   00000022   0xD101             BNE.N    ??HAL_TIM_PWM_Start_1
   \                     ??HAL_TIM_PWM_Start_0: (+1)
   \   00000024   0x2001             MOVS     R0,#+1
   \   00000026   0xE000             B.N      ??HAL_TIM_PWM_Start_2
   \                     ??HAL_TIM_PWM_Start_1: (+1)
   \   00000028   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_PWM_Start_2: (+1)
   \   0000002A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002C   0x2800             CMP      R0,#+0
   \   0000002E   0xD005             BEQ.N    ??HAL_TIM_PWM_Start_3
   1095            {
   1096              /* Enable the main output */
   1097              __HAL_TIM_MOE_ENABLE(htim);
   \   00000030   0x6820             LDR      R0,[R4, #+0]
   \   00000032   0x6C40             LDR      R0,[R0, #+68]
   \   00000034   0xF450 0x4000      ORRS     R0,R0,#0x8000
   \   00000038   0x6821             LDR      R1,[R4, #+0]
   \   0000003A   0x6448             STR      R0,[R1, #+68]
   1098            }
   1099              
   1100            /* Enable the Peripheral */
   1101            __HAL_TIM_ENABLE(htim);
   \                     ??HAL_TIM_PWM_Start_3: (+1)
   \   0000003C   0x6820             LDR      R0,[R4, #+0]
   \   0000003E   0x6800             LDR      R0,[R0, #+0]
   \   00000040   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000044   0x6821             LDR      R1,[R4, #+0]
   \   00000046   0x6008             STR      R0,[R1, #+0]
   1102            
   1103            /* Return function status */
   1104            return HAL_OK;
   \   00000048   0x2000             MOVS     R0,#+0
   \   0000004A   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1105          } 
   1106          
   1107          /**
   1108            * @brief  Stops the PWM signal generation.
   1109            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   1110            *                the configuration information for TIM module.
   1111            * @param  Channel: TIM Channels to be disabled.
   1112            *          This parameter can be one of the following values:
   1113            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1114            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1115            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1116            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1117            * @retval HAL status
   1118            */

   \                                 In section .text, align 2, keep-with-next
   1119          HAL_StatusTypeDef HAL_TIM_PWM_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
   1120          { 
   \                     HAL_TIM_PWM_Stop: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1121            /* Check the parameters */
   1122            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1123              
   1124            /* Disable the Capture compare channel */
   1125            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
   \   00000006   0x2200             MOVS     R2,#+0
   \   00000008   0x0029             MOVS     R1,R5
   \   0000000A   0x6820             LDR      R0,[R4, #+0]
   \   0000000C   0x.... 0x....      BL       TIM_CCxChannelCmd
   1126            
   1127            if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
   \   00000010   0x6820             LDR      R0,[R4, #+0]
   \   00000012   0x.... 0x....      LDR.W    R1,??DataTable13_1  ;; 0x40010000
   \   00000016   0x4288             CMP      R0,R1
   \   00000018   0xD004             BEQ.N    ??HAL_TIM_PWM_Stop_0
   \   0000001A   0x6820             LDR      R0,[R4, #+0]
   \   0000001C   0x.... 0x....      LDR.W    R1,??DataTable14  ;; 0x40010400
   \   00000020   0x4288             CMP      R0,R1
   \   00000022   0xD101             BNE.N    ??HAL_TIM_PWM_Stop_1
   \                     ??HAL_TIM_PWM_Stop_0: (+1)
   \   00000024   0x2001             MOVS     R0,#+1
   \   00000026   0xE000             B.N      ??HAL_TIM_PWM_Stop_2
   \                     ??HAL_TIM_PWM_Stop_1: (+1)
   \   00000028   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_PWM_Stop_2: (+1)
   \   0000002A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002C   0x2800             CMP      R0,#+0
   \   0000002E   0xD011             BEQ.N    ??HAL_TIM_PWM_Stop_3
   1128            {
   1129              /* Disable the Main Output */
   1130              __HAL_TIM_MOE_DISABLE(htim);
   \   00000030   0x6820             LDR      R0,[R4, #+0]
   \   00000032   0x6A00             LDR      R0,[R0, #+32]
   \   00000034   0xF241 0x1111      MOVW     R1,#+4369
   \   00000038   0x4208             TST      R0,R1
   \   0000003A   0xD10B             BNE.N    ??HAL_TIM_PWM_Stop_4
   \   0000003C   0x6820             LDR      R0,[R4, #+0]
   \   0000003E   0x6A00             LDR      R0,[R0, #+32]
   \   00000040   0xF240 0x4144      MOVW     R1,#+1092
   \   00000044   0x4208             TST      R0,R1
   \   00000046   0xD105             BNE.N    ??HAL_TIM_PWM_Stop_4
   \   00000048   0x6820             LDR      R0,[R4, #+0]
   \   0000004A   0x6C40             LDR      R0,[R0, #+68]
   \   0000004C   0xF430 0x4000      BICS     R0,R0,#0x8000
   \   00000050   0x6821             LDR      R1,[R4, #+0]
   \   00000052   0x6448             STR      R0,[R1, #+68]
   1131            }
   1132            
   1133            /* Disable the Peripheral */
   1134            __HAL_TIM_DISABLE(htim);
   \                     ??HAL_TIM_PWM_Stop_4: (+1)
   \                     ??HAL_TIM_PWM_Stop_3: (+1)
   \   00000054   0x6820             LDR      R0,[R4, #+0]
   \   00000056   0x6A00             LDR      R0,[R0, #+32]
   \   00000058   0xF241 0x1111      MOVW     R1,#+4369
   \   0000005C   0x4208             TST      R0,R1
   \   0000005E   0xD10B             BNE.N    ??HAL_TIM_PWM_Stop_5
   \   00000060   0x6820             LDR      R0,[R4, #+0]
   \   00000062   0x6A00             LDR      R0,[R0, #+32]
   \   00000064   0xF240 0x4144      MOVW     R1,#+1092
   \   00000068   0x4208             TST      R0,R1
   \   0000006A   0xD105             BNE.N    ??HAL_TIM_PWM_Stop_5
   \   0000006C   0x6820             LDR      R0,[R4, #+0]
   \   0000006E   0x6800             LDR      R0,[R0, #+0]
   \   00000070   0x0840             LSRS     R0,R0,#+1
   \   00000072   0x0040             LSLS     R0,R0,#+1
   \   00000074   0x6821             LDR      R1,[R4, #+0]
   \   00000076   0x6008             STR      R0,[R1, #+0]
   1135            
   1136            /* Change the htim state */
   1137            htim->State = HAL_TIM_STATE_READY;
   \                     ??HAL_TIM_PWM_Stop_5: (+1)
   \   00000078   0x2001             MOVS     R0,#+1
   \   0000007A   0xF884 0x0039      STRB     R0,[R4, #+57]
   1138            
   1139            /* Return function status */
   1140            return HAL_OK;
   \   0000007E   0x2000             MOVS     R0,#+0
   \   00000080   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1141          } 
   1142          
   1143          /**
   1144            * @brief  Starts the PWM signal generation in interrupt mode.
   1145            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   1146            *                the configuration information for TIM module.
   1147            * @param  Channel: TIM Channel to be disabled.
   1148            *          This parameter can be one of the following values:
   1149            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1150            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1151            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1152            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1153            * @retval HAL status
   1154            */

   \                                 In section .text, align 2, keep-with-next
   1155          HAL_StatusTypeDef HAL_TIM_PWM_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
   1156          {
   \                     HAL_TIM_PWM_Start_IT: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1157            /* Check the parameters */
   1158            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1159            
   1160            switch (Channel)
   \   00000006   0x0028             MOVS     R0,R5
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD006             BEQ.N    ??HAL_TIM_PWM_Start_IT_0
   \   0000000C   0x2804             CMP      R0,#+4
   \   0000000E   0xD00B             BEQ.N    ??HAL_TIM_PWM_Start_IT_1
   \   00000010   0x2808             CMP      R0,#+8
   \   00000012   0xD010             BEQ.N    ??HAL_TIM_PWM_Start_IT_2
   \   00000014   0x280C             CMP      R0,#+12
   \   00000016   0xD015             BEQ.N    ??HAL_TIM_PWM_Start_IT_3
   \   00000018   0xE01B             B.N      ??HAL_TIM_PWM_Start_IT_4
   1161            {
   1162              case TIM_CHANNEL_1:
   1163              {       
   1164                /* Enable the TIM Capture/Compare 1 interrupt */
   1165                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
   \                     ??HAL_TIM_PWM_Start_IT_0: (+1)
   \   0000001A   0x6820             LDR      R0,[R4, #+0]
   \   0000001C   0x68C0             LDR      R0,[R0, #+12]
   \   0000001E   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   00000022   0x6821             LDR      R1,[R4, #+0]
   \   00000024   0x60C8             STR      R0,[R1, #+12]
   1166              }
   1167              break;
   \   00000026   0xE014             B.N      ??HAL_TIM_PWM_Start_IT_5
   1168              
   1169              case TIM_CHANNEL_2:
   1170              {
   1171                /* Enable the TIM Capture/Compare 2 interrupt */
   1172                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
   \                     ??HAL_TIM_PWM_Start_IT_1: (+1)
   \   00000028   0x6820             LDR      R0,[R4, #+0]
   \   0000002A   0x68C0             LDR      R0,[R0, #+12]
   \   0000002C   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   00000030   0x6821             LDR      R1,[R4, #+0]
   \   00000032   0x60C8             STR      R0,[R1, #+12]
   1173              }
   1174              break;
   \   00000034   0xE00D             B.N      ??HAL_TIM_PWM_Start_IT_5
   1175              
   1176              case TIM_CHANNEL_3:
   1177              {
   1178                /* Enable the TIM Capture/Compare 3 interrupt */
   1179                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);
   \                     ??HAL_TIM_PWM_Start_IT_2: (+1)
   \   00000036   0x6820             LDR      R0,[R4, #+0]
   \   00000038   0x68C0             LDR      R0,[R0, #+12]
   \   0000003A   0xF050 0x0008      ORRS     R0,R0,#0x8
   \   0000003E   0x6821             LDR      R1,[R4, #+0]
   \   00000040   0x60C8             STR      R0,[R1, #+12]
   1180              }
   1181              break;
   \   00000042   0xE006             B.N      ??HAL_TIM_PWM_Start_IT_5
   1182              
   1183              case TIM_CHANNEL_4:
   1184              {
   1185                /* Enable the TIM Capture/Compare 4 interrupt */
   1186                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC4);
   \                     ??HAL_TIM_PWM_Start_IT_3: (+1)
   \   00000044   0x6820             LDR      R0,[R4, #+0]
   \   00000046   0x68C0             LDR      R0,[R0, #+12]
   \   00000048   0xF050 0x0010      ORRS     R0,R0,#0x10
   \   0000004C   0x6821             LDR      R1,[R4, #+0]
   \   0000004E   0x60C8             STR      R0,[R1, #+12]
   1187              }
   1188              break;
   \   00000050   0xE7FF             B.N      ??HAL_TIM_PWM_Start_IT_5
   1189              
   1190              default:
   1191              break;
   1192            } 
   1193            
   1194            /* Enable the Capture compare channel */
   1195            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
   \                     ??HAL_TIM_PWM_Start_IT_4: (+1)
   \                     ??HAL_TIM_PWM_Start_IT_5: (+1)
   \   00000052   0x2201             MOVS     R2,#+1
   \   00000054   0x0029             MOVS     R1,R5
   \   00000056   0x6820             LDR      R0,[R4, #+0]
   \   00000058   0x.... 0x....      BL       TIM_CCxChannelCmd
   1196            
   1197            if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
   \   0000005C   0x6820             LDR      R0,[R4, #+0]
   \   0000005E   0x.... 0x....      LDR.W    R1,??DataTable13_1  ;; 0x40010000
   \   00000062   0x4288             CMP      R0,R1
   \   00000064   0xD004             BEQ.N    ??HAL_TIM_PWM_Start_IT_6
   \   00000066   0x6820             LDR      R0,[R4, #+0]
   \   00000068   0x.... 0x....      LDR.W    R1,??DataTable14  ;; 0x40010400
   \   0000006C   0x4288             CMP      R0,R1
   \   0000006E   0xD101             BNE.N    ??HAL_TIM_PWM_Start_IT_7
   \                     ??HAL_TIM_PWM_Start_IT_6: (+1)
   \   00000070   0x2001             MOVS     R0,#+1
   \   00000072   0xE000             B.N      ??HAL_TIM_PWM_Start_IT_8
   \                     ??HAL_TIM_PWM_Start_IT_7: (+1)
   \   00000074   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_PWM_Start_IT_8: (+1)
   \   00000076   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000078   0x2800             CMP      R0,#+0
   \   0000007A   0xD005             BEQ.N    ??HAL_TIM_PWM_Start_IT_9
   1198            {
   1199              /* Enable the main output */
   1200              __HAL_TIM_MOE_ENABLE(htim);
   \   0000007C   0x6820             LDR      R0,[R4, #+0]
   \   0000007E   0x6C40             LDR      R0,[R0, #+68]
   \   00000080   0xF450 0x4000      ORRS     R0,R0,#0x8000
   \   00000084   0x6821             LDR      R1,[R4, #+0]
   \   00000086   0x6448             STR      R0,[R1, #+68]
   1201            }
   1202          
   1203            /* Enable the Peripheral */
   1204            __HAL_TIM_ENABLE(htim);
   \                     ??HAL_TIM_PWM_Start_IT_9: (+1)
   \   00000088   0x6820             LDR      R0,[R4, #+0]
   \   0000008A   0x6800             LDR      R0,[R0, #+0]
   \   0000008C   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000090   0x6821             LDR      R1,[R4, #+0]
   \   00000092   0x6008             STR      R0,[R1, #+0]
   1205            
   1206            /* Return function status */
   1207            return HAL_OK;
   \   00000094   0x2000             MOVS     R0,#+0
   \   00000096   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1208          } 
   1209          
   1210          /**
   1211            * @brief  Stops the PWM signal generation in interrupt mode.
   1212            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   1213            *                the configuration information for TIM module.
   1214            * @param  Channel: TIM Channels to be disabled.
   1215            *          This parameter can be one of the following values:
   1216            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1217            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1218            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1219            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1220            * @retval HAL status
   1221            */

   \                                 In section .text, align 2, keep-with-next
   1222          HAL_StatusTypeDef HAL_TIM_PWM_Stop_IT (TIM_HandleTypeDef *htim, uint32_t Channel)
   1223          {
   \                     HAL_TIM_PWM_Stop_IT: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1224            /* Check the parameters */
   1225            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1226            
   1227            switch (Channel)
   \   00000006   0x0028             MOVS     R0,R5
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD006             BEQ.N    ??HAL_TIM_PWM_Stop_IT_0
   \   0000000C   0x2804             CMP      R0,#+4
   \   0000000E   0xD00B             BEQ.N    ??HAL_TIM_PWM_Stop_IT_1
   \   00000010   0x2808             CMP      R0,#+8
   \   00000012   0xD010             BEQ.N    ??HAL_TIM_PWM_Stop_IT_2
   \   00000014   0x280C             CMP      R0,#+12
   \   00000016   0xD015             BEQ.N    ??HAL_TIM_PWM_Stop_IT_3
   \   00000018   0xE01B             B.N      ??HAL_TIM_PWM_Stop_IT_4
   1228            {
   1229              case TIM_CHANNEL_1:
   1230              {       
   1231                /* Disable the TIM Capture/Compare 1 interrupt */
   1232                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
   \                     ??HAL_TIM_PWM_Stop_IT_0: (+1)
   \   0000001A   0x6820             LDR      R0,[R4, #+0]
   \   0000001C   0x68C0             LDR      R0,[R0, #+12]
   \   0000001E   0xF030 0x0002      BICS     R0,R0,#0x2
   \   00000022   0x6821             LDR      R1,[R4, #+0]
   \   00000024   0x60C8             STR      R0,[R1, #+12]
   1233              }
   1234              break;
   \   00000026   0xE014             B.N      ??HAL_TIM_PWM_Stop_IT_5
   1235              
   1236              case TIM_CHANNEL_2:
   1237              {
   1238                /* Disable the TIM Capture/Compare 2 interrupt */
   1239                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
   \                     ??HAL_TIM_PWM_Stop_IT_1: (+1)
   \   00000028   0x6820             LDR      R0,[R4, #+0]
   \   0000002A   0x68C0             LDR      R0,[R0, #+12]
   \   0000002C   0xF030 0x0004      BICS     R0,R0,#0x4
   \   00000030   0x6821             LDR      R1,[R4, #+0]
   \   00000032   0x60C8             STR      R0,[R1, #+12]
   1240              }
   1241              break;
   \   00000034   0xE00D             B.N      ??HAL_TIM_PWM_Stop_IT_5
   1242              
   1243              case TIM_CHANNEL_3:
   1244              {
   1245                /* Disable the TIM Capture/Compare 3 interrupt */
   1246                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);
   \                     ??HAL_TIM_PWM_Stop_IT_2: (+1)
   \   00000036   0x6820             LDR      R0,[R4, #+0]
   \   00000038   0x68C0             LDR      R0,[R0, #+12]
   \   0000003A   0xF030 0x0008      BICS     R0,R0,#0x8
   \   0000003E   0x6821             LDR      R1,[R4, #+0]
   \   00000040   0x60C8             STR      R0,[R1, #+12]
   1247              }
   1248              break;
   \   00000042   0xE006             B.N      ??HAL_TIM_PWM_Stop_IT_5
   1249              
   1250              case TIM_CHANNEL_4:
   1251              {
   1252                /* Disable the TIM Capture/Compare 4 interrupt */
   1253                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC4);
   \                     ??HAL_TIM_PWM_Stop_IT_3: (+1)
   \   00000044   0x6820             LDR      R0,[R4, #+0]
   \   00000046   0x68C0             LDR      R0,[R0, #+12]
   \   00000048   0xF030 0x0010      BICS     R0,R0,#0x10
   \   0000004C   0x6821             LDR      R1,[R4, #+0]
   \   0000004E   0x60C8             STR      R0,[R1, #+12]
   1254              }
   1255              break;
   \   00000050   0xE7FF             B.N      ??HAL_TIM_PWM_Stop_IT_5
   1256              
   1257              default:
   1258              break; 
   1259            }
   1260            
   1261            /* Disable the Capture compare channel */
   1262            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
   \                     ??HAL_TIM_PWM_Stop_IT_4: (+1)
   \                     ??HAL_TIM_PWM_Stop_IT_5: (+1)
   \   00000052   0x2200             MOVS     R2,#+0
   \   00000054   0x0029             MOVS     R1,R5
   \   00000056   0x6820             LDR      R0,[R4, #+0]
   \   00000058   0x.... 0x....      BL       TIM_CCxChannelCmd
   1263            
   1264            if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
   \   0000005C   0x6820             LDR      R0,[R4, #+0]
   \   0000005E   0x.... 0x....      LDR.W    R1,??DataTable13_1  ;; 0x40010000
   \   00000062   0x4288             CMP      R0,R1
   \   00000064   0xD004             BEQ.N    ??HAL_TIM_PWM_Stop_IT_6
   \   00000066   0x6820             LDR      R0,[R4, #+0]
   \   00000068   0x.... 0x....      LDR.W    R1,??DataTable14  ;; 0x40010400
   \   0000006C   0x4288             CMP      R0,R1
   \   0000006E   0xD101             BNE.N    ??HAL_TIM_PWM_Stop_IT_7
   \                     ??HAL_TIM_PWM_Stop_IT_6: (+1)
   \   00000070   0x2001             MOVS     R0,#+1
   \   00000072   0xE000             B.N      ??HAL_TIM_PWM_Stop_IT_8
   \                     ??HAL_TIM_PWM_Stop_IT_7: (+1)
   \   00000074   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_PWM_Stop_IT_8: (+1)
   \   00000076   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000078   0x2800             CMP      R0,#+0
   \   0000007A   0xD011             BEQ.N    ??HAL_TIM_PWM_Stop_IT_9
   1265            {
   1266              /* Disable the Main Output */
   1267              __HAL_TIM_MOE_DISABLE(htim);
   \   0000007C   0x6820             LDR      R0,[R4, #+0]
   \   0000007E   0x6A00             LDR      R0,[R0, #+32]
   \   00000080   0xF241 0x1111      MOVW     R1,#+4369
   \   00000084   0x4208             TST      R0,R1
   \   00000086   0xD10B             BNE.N    ??HAL_TIM_PWM_Stop_IT_10
   \   00000088   0x6820             LDR      R0,[R4, #+0]
   \   0000008A   0x6A00             LDR      R0,[R0, #+32]
   \   0000008C   0xF240 0x4144      MOVW     R1,#+1092
   \   00000090   0x4208             TST      R0,R1
   \   00000092   0xD105             BNE.N    ??HAL_TIM_PWM_Stop_IT_10
   \   00000094   0x6820             LDR      R0,[R4, #+0]
   \   00000096   0x6C40             LDR      R0,[R0, #+68]
   \   00000098   0xF430 0x4000      BICS     R0,R0,#0x8000
   \   0000009C   0x6821             LDR      R1,[R4, #+0]
   \   0000009E   0x6448             STR      R0,[R1, #+68]
   1268            }
   1269            
   1270            /* Disable the Peripheral */
   1271            __HAL_TIM_DISABLE(htim);
   \                     ??HAL_TIM_PWM_Stop_IT_10: (+1)
   \                     ??HAL_TIM_PWM_Stop_IT_9: (+1)
   \   000000A0   0x6820             LDR      R0,[R4, #+0]
   \   000000A2   0x6A00             LDR      R0,[R0, #+32]
   \   000000A4   0xF241 0x1111      MOVW     R1,#+4369
   \   000000A8   0x4208             TST      R0,R1
   \   000000AA   0xD10B             BNE.N    ??HAL_TIM_PWM_Stop_IT_11
   \   000000AC   0x6820             LDR      R0,[R4, #+0]
   \   000000AE   0x6A00             LDR      R0,[R0, #+32]
   \   000000B0   0xF240 0x4144      MOVW     R1,#+1092
   \   000000B4   0x4208             TST      R0,R1
   \   000000B6   0xD105             BNE.N    ??HAL_TIM_PWM_Stop_IT_11
   \   000000B8   0x6820             LDR      R0,[R4, #+0]
   \   000000BA   0x6800             LDR      R0,[R0, #+0]
   \   000000BC   0x0840             LSRS     R0,R0,#+1
   \   000000BE   0x0040             LSLS     R0,R0,#+1
   \   000000C0   0x6821             LDR      R1,[R4, #+0]
   \   000000C2   0x6008             STR      R0,[R1, #+0]
   1272            
   1273            /* Return function status */
   1274            return HAL_OK;
   \                     ??HAL_TIM_PWM_Stop_IT_11: (+1)
   \   000000C4   0x2000             MOVS     R0,#+0
   \   000000C6   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1275          } 
   1276          
   1277          /**
   1278            * @brief  Starts the TIM PWM signal generation in DMA mode.
   1279            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   1280            *                the configuration information for TIM module.
   1281            * @param  Channel: TIM Channels to be enabled.
   1282            *          This parameter can be one of the following values:
   1283            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1284            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1285            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1286            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1287            * @param  pData: The source Buffer address.
   1288            * @param  Length: The length of data to be transferred from memory to TIM peripheral
   1289            * @retval HAL status
   1290            */

   \                                 In section .text, align 2, keep-with-next
   1291          HAL_StatusTypeDef HAL_TIM_PWM_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData, uint16_t Length)
   1292          {
   \                     HAL_TIM_PWM_Start_DMA: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000F             MOVS     R7,R1
   \   00000006   0x0015             MOVS     R5,R2
   \   00000008   0x001E             MOVS     R6,R3
   1293            /* Check the parameters */
   1294            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1295            
   1296            if((htim->State == HAL_TIM_STATE_BUSY))
   \   0000000A   0xF894 0x0039      LDRB     R0,[R4, #+57]
   \   0000000E   0x2802             CMP      R0,#+2
   \   00000010   0xD101             BNE.N    ??HAL_TIM_PWM_Start_DMA_0
   1297            {
   1298               return HAL_BUSY;
   \   00000012   0x2002             MOVS     R0,#+2
   \   00000014   0xE099             B.N      ??HAL_TIM_PWM_Start_DMA_1
   1299            }
   1300            else if((htim->State == HAL_TIM_STATE_READY))
   \                     ??HAL_TIM_PWM_Start_DMA_0: (+1)
   \   00000016   0xF894 0x0039      LDRB     R0,[R4, #+57]
   \   0000001A   0x2801             CMP      R0,#+1
   \   0000001C   0xD109             BNE.N    ??HAL_TIM_PWM_Start_DMA_2
   1301            {
   1302              if(((uint32_t)pData == 0 ) && (Length > 0)) 
   \   0000001E   0x2D00             CMP      R5,#+0
   \   00000020   0xD104             BNE.N    ??HAL_TIM_PWM_Start_DMA_3
   \   00000022   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000024   0x2E00             CMP      R6,#+0
   \   00000026   0xD001             BEQ.N    ??HAL_TIM_PWM_Start_DMA_3
   1303              {
   1304                return HAL_ERROR;                                    
   \   00000028   0x2001             MOVS     R0,#+1
   \   0000002A   0xE08E             B.N      ??HAL_TIM_PWM_Start_DMA_1
   1305              }
   1306              else
   1307              {
   1308                htim->State = HAL_TIM_STATE_BUSY;
   \                     ??HAL_TIM_PWM_Start_DMA_3: (+1)
   \   0000002C   0x2002             MOVS     R0,#+2
   \   0000002E   0xF884 0x0039      STRB     R0,[R4, #+57]
   1309              }
   1310            }    
   1311            switch (Channel)
   \                     ??HAL_TIM_PWM_Start_DMA_2: (+1)
   \   00000032   0x0038             MOVS     R0,R7
   \   00000034   0x2800             CMP      R0,#+0
   \   00000036   0xD006             BEQ.N    ??HAL_TIM_PWM_Start_DMA_4
   \   00000038   0x2804             CMP      R0,#+4
   \   0000003A   0xD01C             BEQ.N    ??HAL_TIM_PWM_Start_DMA_5
   \   0000003C   0x2808             CMP      R0,#+8
   \   0000003E   0xD032             BEQ.N    ??HAL_TIM_PWM_Start_DMA_6
   \   00000040   0x280C             CMP      R0,#+12
   \   00000042   0xD048             BEQ.N    ??HAL_TIM_PWM_Start_DMA_7
   \   00000044   0xE05F             B.N      ??HAL_TIM_PWM_Start_DMA_8
   1312            {
   1313              case TIM_CHANNEL_1:
   1314              {      
   1315                /* Set the DMA Period elapsed callback */
   1316                htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = HAL_TIM_DMADelayPulseCplt;
   \                     ??HAL_TIM_PWM_Start_DMA_4: (+1)
   \   00000046   0x.... 0x....      LDR.W    R0,??DataTable17
   \   0000004A   0x6A21             LDR      R1,[R4, #+32]
   \   0000004C   0x63C8             STR      R0,[R1, #+60]
   1317               
   1318                /* Set the DMA error callback */
   1319                htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = HAL_TIM_DMAError ;
   \   0000004E   0x.... 0x....      LDR.W    R0,??DataTable13
   \   00000052   0x6A21             LDR      R1,[R4, #+32]
   \   00000054   0x6488             STR      R0,[R1, #+72]
   1320                
   1321                /* Enable the DMA Stream */
   1322                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)pData, (uint32_t)&htim->Instance->CCR1, Length);
   \   00000056   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000058   0x0033             MOVS     R3,R6
   \   0000005A   0x6820             LDR      R0,[R4, #+0]
   \   0000005C   0xF110 0x0234      ADDS     R2,R0,#+52
   \   00000060   0x0029             MOVS     R1,R5
   \   00000062   0x6A20             LDR      R0,[R4, #+32]
   \   00000064   0x.... 0x....      BL       HAL_DMA_Start_IT
   1323                
   1324                /* Enable the TIM Capture/Compare 1 DMA request */
   1325                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
   \   00000068   0x6820             LDR      R0,[R4, #+0]
   \   0000006A   0x68C0             LDR      R0,[R0, #+12]
   \   0000006C   0xF450 0x7000      ORRS     R0,R0,#0x200
   \   00000070   0x6821             LDR      R1,[R4, #+0]
   \   00000072   0x60C8             STR      R0,[R1, #+12]
   1326              }
   1327              break;
   \   00000074   0xE047             B.N      ??HAL_TIM_PWM_Start_DMA_9
   1328              
   1329              case TIM_CHANNEL_2:
   1330              {
   1331                /* Set the DMA Period elapsed callback */
   1332                htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = HAL_TIM_DMADelayPulseCplt;
   \                     ??HAL_TIM_PWM_Start_DMA_5: (+1)
   \   00000076   0x.... 0x....      LDR.W    R0,??DataTable17
   \   0000007A   0x6A61             LDR      R1,[R4, #+36]
   \   0000007C   0x63C8             STR      R0,[R1, #+60]
   1333               
   1334                /* Set the DMA error callback */
   1335                htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = HAL_TIM_DMAError ;
   \   0000007E   0x.... 0x....      LDR.W    R0,??DataTable13
   \   00000082   0x6A61             LDR      R1,[R4, #+36]
   \   00000084   0x6488             STR      R0,[R1, #+72]
   1336                
   1337                /* Enable the DMA Stream */
   1338                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)pData, (uint32_t)&htim->Instance->CCR2, Length);
   \   00000086   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000088   0x0033             MOVS     R3,R6
   \   0000008A   0x6820             LDR      R0,[R4, #+0]
   \   0000008C   0xF110 0x0238      ADDS     R2,R0,#+56
   \   00000090   0x0029             MOVS     R1,R5
   \   00000092   0x6A60             LDR      R0,[R4, #+36]
   \   00000094   0x.... 0x....      BL       HAL_DMA_Start_IT
   1339                
   1340                /* Enable the TIM Capture/Compare 2 DMA request */
   1341                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
   \   00000098   0x6820             LDR      R0,[R4, #+0]
   \   0000009A   0x68C0             LDR      R0,[R0, #+12]
   \   0000009C   0xF450 0x6080      ORRS     R0,R0,#0x400
   \   000000A0   0x6821             LDR      R1,[R4, #+0]
   \   000000A2   0x60C8             STR      R0,[R1, #+12]
   1342              }
   1343              break;
   \   000000A4   0xE02F             B.N      ??HAL_TIM_PWM_Start_DMA_9
   1344              
   1345              case TIM_CHANNEL_3:
   1346              {
   1347                /* Set the DMA Period elapsed callback */
   1348                htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = HAL_TIM_DMADelayPulseCplt;
   \                     ??HAL_TIM_PWM_Start_DMA_6: (+1)
   \   000000A6   0x.... 0x....      LDR.W    R0,??DataTable17
   \   000000AA   0x6AA1             LDR      R1,[R4, #+40]
   \   000000AC   0x63C8             STR      R0,[R1, #+60]
   1349               
   1350                /* Set the DMA error callback */
   1351                htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = HAL_TIM_DMAError ;
   \   000000AE   0x.... 0x....      LDR.W    R0,??DataTable13
   \   000000B2   0x6AA1             LDR      R1,[R4, #+40]
   \   000000B4   0x6488             STR      R0,[R1, #+72]
   1352                
   1353                /* Enable the DMA Stream */
   1354                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)pData, (uint32_t)&htim->Instance->CCR3,Length);
   \   000000B6   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   000000B8   0x0033             MOVS     R3,R6
   \   000000BA   0x6820             LDR      R0,[R4, #+0]
   \   000000BC   0xF110 0x023C      ADDS     R2,R0,#+60
   \   000000C0   0x0029             MOVS     R1,R5
   \   000000C2   0x6AA0             LDR      R0,[R4, #+40]
   \   000000C4   0x.... 0x....      BL       HAL_DMA_Start_IT
   1355                
   1356                /* Enable the TIM Output Capture/Compare 3 request */
   1357                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);
   \   000000C8   0x6820             LDR      R0,[R4, #+0]
   \   000000CA   0x68C0             LDR      R0,[R0, #+12]
   \   000000CC   0xF450 0x6000      ORRS     R0,R0,#0x800
   \   000000D0   0x6821             LDR      R1,[R4, #+0]
   \   000000D2   0x60C8             STR      R0,[R1, #+12]
   1358              }
   1359              break;
   \   000000D4   0xE017             B.N      ??HAL_TIM_PWM_Start_DMA_9
   1360              
   1361              case TIM_CHANNEL_4:
   1362              {
   1363               /* Set the DMA Period elapsed callback */
   1364                htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = HAL_TIM_DMADelayPulseCplt;
   \                     ??HAL_TIM_PWM_Start_DMA_7: (+1)
   \   000000D6   0x.... 0x....      LDR.W    R0,??DataTable17
   \   000000DA   0x6AE1             LDR      R1,[R4, #+44]
   \   000000DC   0x63C8             STR      R0,[R1, #+60]
   1365               
   1366                /* Set the DMA error callback */
   1367                htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = HAL_TIM_DMAError ;
   \   000000DE   0x.... 0x....      LDR.W    R0,??DataTable13
   \   000000E2   0x6AE1             LDR      R1,[R4, #+44]
   \   000000E4   0x6488             STR      R0,[R1, #+72]
   1368                
   1369                /* Enable the DMA Stream */
   1370                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)pData, (uint32_t)&htim->Instance->CCR4, Length);
   \   000000E6   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   000000E8   0x0033             MOVS     R3,R6
   \   000000EA   0x6820             LDR      R0,[R4, #+0]
   \   000000EC   0xF110 0x0240      ADDS     R2,R0,#+64
   \   000000F0   0x0029             MOVS     R1,R5
   \   000000F2   0x6AE0             LDR      R0,[R4, #+44]
   \   000000F4   0x.... 0x....      BL       HAL_DMA_Start_IT
   1371                
   1372                /* Enable the TIM Capture/Compare 4 DMA request */
   1373                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC4);
   \   000000F8   0x6820             LDR      R0,[R4, #+0]
   \   000000FA   0x68C0             LDR      R0,[R0, #+12]
   \   000000FC   0xF450 0x5080      ORRS     R0,R0,#0x1000
   \   00000100   0x6821             LDR      R1,[R4, #+0]
   \   00000102   0x60C8             STR      R0,[R1, #+12]
   1374              }
   1375              break;
   \   00000104   0xE7FF             B.N      ??HAL_TIM_PWM_Start_DMA_9
   1376              
   1377              default:
   1378              break;
   1379            }
   1380          
   1381            /* Enable the Capture compare channel */
   1382            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
   \                     ??HAL_TIM_PWM_Start_DMA_8: (+1)
   \                     ??HAL_TIM_PWM_Start_DMA_9: (+1)
   \   00000106   0x2201             MOVS     R2,#+1
   \   00000108   0x0039             MOVS     R1,R7
   \   0000010A   0x6820             LDR      R0,[R4, #+0]
   \   0000010C   0x.... 0x....      BL       TIM_CCxChannelCmd
   1383              
   1384            if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
   \   00000110   0x6820             LDR      R0,[R4, #+0]
   \   00000112   0x.... 0x....      LDR.W    R1,??DataTable13_1  ;; 0x40010000
   \   00000116   0x4288             CMP      R0,R1
   \   00000118   0xD004             BEQ.N    ??HAL_TIM_PWM_Start_DMA_10
   \   0000011A   0x6820             LDR      R0,[R4, #+0]
   \   0000011C   0x.... 0x....      LDR.W    R1,??DataTable14  ;; 0x40010400
   \   00000120   0x4288             CMP      R0,R1
   \   00000122   0xD101             BNE.N    ??HAL_TIM_PWM_Start_DMA_11
   \                     ??HAL_TIM_PWM_Start_DMA_10: (+1)
   \   00000124   0x2001             MOVS     R0,#+1
   \   00000126   0xE000             B.N      ??HAL_TIM_PWM_Start_DMA_12
   \                     ??HAL_TIM_PWM_Start_DMA_11: (+1)
   \   00000128   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_PWM_Start_DMA_12: (+1)
   \   0000012A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000012C   0x2800             CMP      R0,#+0
   \   0000012E   0xD005             BEQ.N    ??HAL_TIM_PWM_Start_DMA_13
   1385            {
   1386              /* Enable the main output */
   1387              __HAL_TIM_MOE_ENABLE(htim);
   \   00000130   0x6820             LDR      R0,[R4, #+0]
   \   00000132   0x6C40             LDR      R0,[R0, #+68]
   \   00000134   0xF450 0x4000      ORRS     R0,R0,#0x8000
   \   00000138   0x6821             LDR      R1,[R4, #+0]
   \   0000013A   0x6448             STR      R0,[R1, #+68]
   1388            }
   1389            
   1390            /* Enable the Peripheral */
   1391            __HAL_TIM_ENABLE(htim); 
   \                     ??HAL_TIM_PWM_Start_DMA_13: (+1)
   \   0000013C   0x6820             LDR      R0,[R4, #+0]
   \   0000013E   0x6800             LDR      R0,[R0, #+0]
   \   00000140   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000144   0x6821             LDR      R1,[R4, #+0]
   \   00000146   0x6008             STR      R0,[R1, #+0]
   1392            
   1393            /* Return function status */
   1394            return HAL_OK;
   \   00000148   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_PWM_Start_DMA_1: (+1)
   \   0000014A   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1395          }
   1396          
   1397          /**
   1398            * @brief  Stops the TIM PWM signal generation in DMA mode.
   1399            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   1400            *                the configuration information for TIM module.
   1401            * @param  Channel: TIM Channels to be disabled.
   1402            *          This parameter can be one of the following values:
   1403            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1404            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1405            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1406            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1407            * @retval HAL status
   1408            */

   \                                 In section .text, align 2, keep-with-next
   1409          HAL_StatusTypeDef HAL_TIM_PWM_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
   1410          {
   \                     HAL_TIM_PWM_Stop_DMA: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1411            /* Check the parameters */
   1412            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1413            
   1414            switch (Channel)
   \   00000006   0x0028             MOVS     R0,R5
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD006             BEQ.N    ??HAL_TIM_PWM_Stop_DMA_0
   \   0000000C   0x2804             CMP      R0,#+4
   \   0000000E   0xD00B             BEQ.N    ??HAL_TIM_PWM_Stop_DMA_1
   \   00000010   0x2808             CMP      R0,#+8
   \   00000012   0xD010             BEQ.N    ??HAL_TIM_PWM_Stop_DMA_2
   \   00000014   0x280C             CMP      R0,#+12
   \   00000016   0xD015             BEQ.N    ??HAL_TIM_PWM_Stop_DMA_3
   \   00000018   0xE01B             B.N      ??HAL_TIM_PWM_Stop_DMA_4
   1415            {
   1416              case TIM_CHANNEL_1:
   1417              {       
   1418                /* Disable the TIM Capture/Compare 1 DMA request */
   1419                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
   \                     ??HAL_TIM_PWM_Stop_DMA_0: (+1)
   \   0000001A   0x6820             LDR      R0,[R4, #+0]
   \   0000001C   0x68C0             LDR      R0,[R0, #+12]
   \   0000001E   0xF430 0x7000      BICS     R0,R0,#0x200
   \   00000022   0x6821             LDR      R1,[R4, #+0]
   \   00000024   0x60C8             STR      R0,[R1, #+12]
   1420              }
   1421              break;
   \   00000026   0xE014             B.N      ??HAL_TIM_PWM_Stop_DMA_5
   1422              
   1423              case TIM_CHANNEL_2:
   1424              {
   1425                /* Disable the TIM Capture/Compare 2 DMA request */
   1426                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
   \                     ??HAL_TIM_PWM_Stop_DMA_1: (+1)
   \   00000028   0x6820             LDR      R0,[R4, #+0]
   \   0000002A   0x68C0             LDR      R0,[R0, #+12]
   \   0000002C   0xF430 0x6080      BICS     R0,R0,#0x400
   \   00000030   0x6821             LDR      R1,[R4, #+0]
   \   00000032   0x60C8             STR      R0,[R1, #+12]
   1427              }
   1428              break;
   \   00000034   0xE00D             B.N      ??HAL_TIM_PWM_Stop_DMA_5
   1429              
   1430              case TIM_CHANNEL_3:
   1431              {
   1432                /* Disable the TIM Capture/Compare 3 DMA request */
   1433                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);
   \                     ??HAL_TIM_PWM_Stop_DMA_2: (+1)
   \   00000036   0x6820             LDR      R0,[R4, #+0]
   \   00000038   0x68C0             LDR      R0,[R0, #+12]
   \   0000003A   0xF430 0x6000      BICS     R0,R0,#0x800
   \   0000003E   0x6821             LDR      R1,[R4, #+0]
   \   00000040   0x60C8             STR      R0,[R1, #+12]
   1434              }
   1435              break;
   \   00000042   0xE006             B.N      ??HAL_TIM_PWM_Stop_DMA_5
   1436              
   1437              case TIM_CHANNEL_4:
   1438              {
   1439                /* Disable the TIM Capture/Compare 4 interrupt */
   1440                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC4);
   \                     ??HAL_TIM_PWM_Stop_DMA_3: (+1)
   \   00000044   0x6820             LDR      R0,[R4, #+0]
   \   00000046   0x68C0             LDR      R0,[R0, #+12]
   \   00000048   0xF430 0x5080      BICS     R0,R0,#0x1000
   \   0000004C   0x6821             LDR      R1,[R4, #+0]
   \   0000004E   0x60C8             STR      R0,[R1, #+12]
   1441              }
   1442              break;
   \   00000050   0xE7FF             B.N      ??HAL_TIM_PWM_Stop_DMA_5
   1443              
   1444              default:
   1445              break;
   1446            } 
   1447            
   1448            /* Disable the Capture compare channel */
   1449            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
   \                     ??HAL_TIM_PWM_Stop_DMA_4: (+1)
   \                     ??HAL_TIM_PWM_Stop_DMA_5: (+1)
   \   00000052   0x2200             MOVS     R2,#+0
   \   00000054   0x0029             MOVS     R1,R5
   \   00000056   0x6820             LDR      R0,[R4, #+0]
   \   00000058   0x.... 0x....      BL       TIM_CCxChannelCmd
   1450            
   1451            if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
   \   0000005C   0x6820             LDR      R0,[R4, #+0]
   \   0000005E   0x....             LDR.N    R1,??DataTable13_1  ;; 0x40010000
   \   00000060   0x4288             CMP      R0,R1
   \   00000062   0xD004             BEQ.N    ??HAL_TIM_PWM_Stop_DMA_6
   \   00000064   0x6820             LDR      R0,[R4, #+0]
   \   00000066   0x.... 0x....      LDR.W    R1,??DataTable14  ;; 0x40010400
   \   0000006A   0x4288             CMP      R0,R1
   \   0000006C   0xD101             BNE.N    ??HAL_TIM_PWM_Stop_DMA_7
   \                     ??HAL_TIM_PWM_Stop_DMA_6: (+1)
   \   0000006E   0x2001             MOVS     R0,#+1
   \   00000070   0xE000             B.N      ??HAL_TIM_PWM_Stop_DMA_8
   \                     ??HAL_TIM_PWM_Stop_DMA_7: (+1)
   \   00000072   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_PWM_Stop_DMA_8: (+1)
   \   00000074   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000076   0x2800             CMP      R0,#+0
   \   00000078   0xD011             BEQ.N    ??HAL_TIM_PWM_Stop_DMA_9
   1452            {
   1453              /* Disable the Main Output */
   1454              __HAL_TIM_MOE_DISABLE(htim);
   \   0000007A   0x6820             LDR      R0,[R4, #+0]
   \   0000007C   0x6A00             LDR      R0,[R0, #+32]
   \   0000007E   0xF241 0x1111      MOVW     R1,#+4369
   \   00000082   0x4208             TST      R0,R1
   \   00000084   0xD10B             BNE.N    ??HAL_TIM_PWM_Stop_DMA_10
   \   00000086   0x6820             LDR      R0,[R4, #+0]
   \   00000088   0x6A00             LDR      R0,[R0, #+32]
   \   0000008A   0xF240 0x4144      MOVW     R1,#+1092
   \   0000008E   0x4208             TST      R0,R1
   \   00000090   0xD105             BNE.N    ??HAL_TIM_PWM_Stop_DMA_10
   \   00000092   0x6820             LDR      R0,[R4, #+0]
   \   00000094   0x6C40             LDR      R0,[R0, #+68]
   \   00000096   0xF430 0x4000      BICS     R0,R0,#0x8000
   \   0000009A   0x6821             LDR      R1,[R4, #+0]
   \   0000009C   0x6448             STR      R0,[R1, #+68]
   1455            }
   1456            
   1457            /* Disable the Peripheral */
   1458            __HAL_TIM_DISABLE(htim);
   \                     ??HAL_TIM_PWM_Stop_DMA_10: (+1)
   \                     ??HAL_TIM_PWM_Stop_DMA_9: (+1)
   \   0000009E   0x6820             LDR      R0,[R4, #+0]
   \   000000A0   0x6A00             LDR      R0,[R0, #+32]
   \   000000A2   0xF241 0x1111      MOVW     R1,#+4369
   \   000000A6   0x4208             TST      R0,R1
   \   000000A8   0xD10B             BNE.N    ??HAL_TIM_PWM_Stop_DMA_11
   \   000000AA   0x6820             LDR      R0,[R4, #+0]
   \   000000AC   0x6A00             LDR      R0,[R0, #+32]
   \   000000AE   0xF240 0x4144      MOVW     R1,#+1092
   \   000000B2   0x4208             TST      R0,R1
   \   000000B4   0xD105             BNE.N    ??HAL_TIM_PWM_Stop_DMA_11
   \   000000B6   0x6820             LDR      R0,[R4, #+0]
   \   000000B8   0x6800             LDR      R0,[R0, #+0]
   \   000000BA   0x0840             LSRS     R0,R0,#+1
   \   000000BC   0x0040             LSLS     R0,R0,#+1
   \   000000BE   0x6821             LDR      R1,[R4, #+0]
   \   000000C0   0x6008             STR      R0,[R1, #+0]
   1459            
   1460            /* Change the htim state */
   1461            htim->State = HAL_TIM_STATE_READY;
   \                     ??HAL_TIM_PWM_Stop_DMA_11: (+1)
   \   000000C2   0x2001             MOVS     R0,#+1
   \   000000C4   0xF884 0x0039      STRB     R0,[R4, #+57]
   1462            
   1463            /* Return function status */
   1464            return HAL_OK;
   \   000000C8   0x2000             MOVS     R0,#+0
   \   000000CA   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1465          }
   1466          
   1467          /**
   1468            * @}
   1469            */
   1470          
   1471          /** @defgroup TIM_Exported_Functions_Group4 Time Input Capture functions 
   1472           *  @brief    Time Input Capture functions 
   1473           *
   1474          @verbatim    
   1475            ==============================================================================
   1476                        ##### Time Input Capture functions #####
   1477            ==============================================================================
   1478           [..]  
   1479             This section provides functions allowing to:
   1480             (+) Initialize and configure the TIM Input Capture. 
   1481             (+) De-initialize the TIM Input Capture.
   1482             (+) Start the Time Input Capture.
   1483             (+) Stop the Time Input Capture.
   1484             (+) Start the Time Input Capture and enable interrupt.
   1485             (+) Stop the Time Input Capture and disable interrupt.
   1486             (+) Start the Time Input Capture and enable DMA transfer.
   1487             (+) Stop the Time Input Capture and disable DMA transfer.
   1488           
   1489          @endverbatim
   1490            * @{
   1491            */
   1492          /**
   1493            * @brief  Initializes the TIM Input Capture Time base according to the specified
   1494            *         parameters in the TIM_HandleTypeDef and create the associated handle.
   1495            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   1496            *                the configuration information for TIM module.
   1497            * @retval HAL status
   1498            */

   \                                 In section .text, align 2, keep-with-next
   1499          HAL_StatusTypeDef HAL_TIM_IC_Init(TIM_HandleTypeDef *htim)
   1500          {
   \                     HAL_TIM_IC_Init: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1501            /* Check the TIM handle allocation */
   1502            if(htim == NULL)
   \   00000004   0x2C00             CMP      R4,#+0
   \   00000006   0xD101             BNE.N    ??HAL_TIM_IC_Init_0
   1503            {
   1504              return HAL_ERROR;
   \   00000008   0x2001             MOVS     R0,#+1
   \   0000000A   0xE014             B.N      ??HAL_TIM_IC_Init_1
   1505            }
   1506          
   1507            /* Check the parameters */
   1508            assert_param(IS_TIM_INSTANCE(htim->Instance));
   1509            assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
   1510            assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision)); 
   1511          
   1512            if(htim->State == HAL_TIM_STATE_RESET)
   \                     ??HAL_TIM_IC_Init_0: (+1)
   \   0000000C   0xF894 0x0039      LDRB     R0,[R4, #+57]
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD105             BNE.N    ??HAL_TIM_IC_Init_2
   1513            { 
   1514              /* Allocate lock resource and initialize it */
   1515              htim->Lock = HAL_UNLOCKED;   
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0xF884 0x0038      STRB     R0,[R4, #+56]
   1516              /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
   1517              HAL_TIM_IC_MspInit(htim);
   \   0000001A   0x0020             MOVS     R0,R4
   \   0000001C   0x.... 0x....      BL       HAL_TIM_IC_MspInit
   1518            }
   1519            
   1520            /* Set the TIM state */
   1521            htim->State= HAL_TIM_STATE_BUSY;   
   \                     ??HAL_TIM_IC_Init_2: (+1)
   \   00000020   0x2002             MOVS     R0,#+2
   \   00000022   0xF884 0x0039      STRB     R0,[R4, #+57]
   1522            
   1523            /* Init the base time for the input capture */  
   1524            TIM_Base_SetConfig(htim->Instance, &htim->Init); 
   \   00000026   0x1D21             ADDS     R1,R4,#+4
   \   00000028   0x6820             LDR      R0,[R4, #+0]
   \   0000002A   0x.... 0x....      BL       TIM_Base_SetConfig
   1525             
   1526            /* Initialize the TIM state*/
   1527            htim->State= HAL_TIM_STATE_READY;
   \   0000002E   0x2001             MOVS     R0,#+1
   \   00000030   0xF884 0x0039      STRB     R0,[R4, #+57]
   1528            
   1529            return HAL_OK;
   \   00000034   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_IC_Init_1: (+1)
   \   00000036   0xBD10             POP      {R4,PC}          ;; return
   1530          }
   1531          
   1532          /**
   1533            * @brief  DeInitializes the TIM peripheral 
   1534            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   1535            *                the configuration information for TIM module.
   1536            * @retval HAL status
   1537            */

   \                                 In section .text, align 2, keep-with-next
   1538          HAL_StatusTypeDef HAL_TIM_IC_DeInit(TIM_HandleTypeDef *htim)
   1539          {
   \                     HAL_TIM_IC_DeInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1540            /* Check the parameters */
   1541            assert_param(IS_TIM_INSTANCE(htim->Instance));
   1542          
   1543            htim->State = HAL_TIM_STATE_BUSY;
   \   00000004   0x2002             MOVS     R0,#+2
   \   00000006   0xF884 0x0039      STRB     R0,[R4, #+57]
   1544            
   1545            /* Disable the TIM Peripheral Clock */
   1546            __HAL_TIM_DISABLE(htim);
   \   0000000A   0x6820             LDR      R0,[R4, #+0]
   \   0000000C   0x6A00             LDR      R0,[R0, #+32]
   \   0000000E   0xF241 0x1111      MOVW     R1,#+4369
   \   00000012   0x4208             TST      R0,R1
   \   00000014   0xD10B             BNE.N    ??HAL_TIM_IC_DeInit_0
   \   00000016   0x6820             LDR      R0,[R4, #+0]
   \   00000018   0x6A00             LDR      R0,[R0, #+32]
   \   0000001A   0xF240 0x4144      MOVW     R1,#+1092
   \   0000001E   0x4208             TST      R0,R1
   \   00000020   0xD105             BNE.N    ??HAL_TIM_IC_DeInit_0
   \   00000022   0x6820             LDR      R0,[R4, #+0]
   \   00000024   0x6800             LDR      R0,[R0, #+0]
   \   00000026   0x0840             LSRS     R0,R0,#+1
   \   00000028   0x0040             LSLS     R0,R0,#+1
   \   0000002A   0x6821             LDR      R1,[R4, #+0]
   \   0000002C   0x6008             STR      R0,[R1, #+0]
   1547              
   1548            /* DeInit the low level hardware: GPIO, CLOCK, NVIC and DMA */
   1549            HAL_TIM_IC_MspDeInit(htim);
   \                     ??HAL_TIM_IC_DeInit_0: (+1)
   \   0000002E   0x0020             MOVS     R0,R4
   \   00000030   0x.... 0x....      BL       HAL_TIM_IC_MspDeInit
   1550              
   1551            /* Change TIM state */  
   1552            htim->State = HAL_TIM_STATE_RESET;
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0xF884 0x0039      STRB     R0,[R4, #+57]
   1553          
   1554            /* Release Lock */
   1555            __HAL_UNLOCK(htim);
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0xF884 0x0038      STRB     R0,[R4, #+56]
   1556          
   1557            return HAL_OK;
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0xBD10             POP      {R4,PC}          ;; return
   1558          }
   1559          
   1560          /**
   1561            * @brief  Initializes the TIM INput Capture MSP.
   1562            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   1563            *                the configuration information for TIM module.
   1564            * @retval None
   1565            */

   \                                 In section .text, align 2, keep-with-next
   1566          __weak void HAL_TIM_IC_MspInit(TIM_HandleTypeDef *htim)
   1567          {
   1568            /* NOTE : This function Should not be modified, when the callback is needed,
   1569                      the HAL_TIM_IC_MspInit could be implemented in the user file
   1570             */
   1571          }
   \                     HAL_TIM_IC_MspInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1572          
   1573          /**
   1574            * @brief  DeInitializes TIM Input Capture MSP.
   1575            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   1576            *                the configuration information for TIM module.
   1577            * @retval None
   1578            */

   \                                 In section .text, align 2, keep-with-next
   1579          __weak void HAL_TIM_IC_MspDeInit(TIM_HandleTypeDef *htim)
   1580          {
   1581            /* NOTE : This function Should not be modified, when the callback is needed,
   1582                      the HAL_TIM_IC_MspDeInit could be implemented in the user file
   1583             */
   1584          }
   \                     HAL_TIM_IC_MspDeInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1585          
   1586          /**
   1587            * @brief  Starts the TIM Input Capture measurement.
   1588            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   1589            *                the configuration information for TIM module.
   1590            * @param  Channel: TIM Channels to be enabled.
   1591            *          This parameter can be one of the following values:
   1592            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1593            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1594            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1595            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1596            * @retval HAL status
   1597            */

   \                                 In section .text, align 2, keep-with-next
   1598          HAL_StatusTypeDef HAL_TIM_IC_Start (TIM_HandleTypeDef *htim, uint32_t Channel)
   1599          {
   \                     HAL_TIM_IC_Start: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1600            /* Check the parameters */
   1601            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1602            
   1603            /* Enable the Input Capture channel */
   1604            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
   \   00000006   0x2201             MOVS     R2,#+1
   \   00000008   0x0029             MOVS     R1,R5
   \   0000000A   0x6820             LDR      R0,[R4, #+0]
   \   0000000C   0x.... 0x....      BL       TIM_CCxChannelCmd
   1605              
   1606            /* Enable the Peripheral */
   1607            __HAL_TIM_ENABLE(htim);  
   \   00000010   0x6820             LDR      R0,[R4, #+0]
   \   00000012   0x6800             LDR      R0,[R0, #+0]
   \   00000014   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000018   0x6821             LDR      R1,[R4, #+0]
   \   0000001A   0x6008             STR      R0,[R1, #+0]
   1608          
   1609            /* Return function status */
   1610            return HAL_OK;  
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1611          } 
   1612          
   1613          /**
   1614            * @brief  Stops the TIM Input Capture measurement.
   1615            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   1616            *                the configuration information for TIM module.
   1617            * @param  Channel: TIM Channels to be disabled.
   1618            *          This parameter can be one of the following values:
   1619            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1620            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1621            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1622            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1623            * @retval HAL status
   1624            */

   \                                 In section .text, align 2, keep-with-next
   1625          HAL_StatusTypeDef HAL_TIM_IC_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
   1626          { 
   \                     HAL_TIM_IC_Stop: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1627            /* Check the parameters */
   1628            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1629            
   1630            /* Disable the Input Capture channel */
   1631            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
   \   00000006   0x2200             MOVS     R2,#+0
   \   00000008   0x0029             MOVS     R1,R5
   \   0000000A   0x6820             LDR      R0,[R4, #+0]
   \   0000000C   0x.... 0x....      BL       TIM_CCxChannelCmd
   1632            
   1633            /* Disable the Peripheral */
   1634            __HAL_TIM_DISABLE(htim); 
   \   00000010   0x6820             LDR      R0,[R4, #+0]
   \   00000012   0x6A00             LDR      R0,[R0, #+32]
   \   00000014   0xF241 0x1111      MOVW     R1,#+4369
   \   00000018   0x4208             TST      R0,R1
   \   0000001A   0xD10B             BNE.N    ??HAL_TIM_IC_Stop_0
   \   0000001C   0x6820             LDR      R0,[R4, #+0]
   \   0000001E   0x6A00             LDR      R0,[R0, #+32]
   \   00000020   0xF240 0x4144      MOVW     R1,#+1092
   \   00000024   0x4208             TST      R0,R1
   \   00000026   0xD105             BNE.N    ??HAL_TIM_IC_Stop_0
   \   00000028   0x6820             LDR      R0,[R4, #+0]
   \   0000002A   0x6800             LDR      R0,[R0, #+0]
   \   0000002C   0x0840             LSRS     R0,R0,#+1
   \   0000002E   0x0040             LSLS     R0,R0,#+1
   \   00000030   0x6821             LDR      R1,[R4, #+0]
   \   00000032   0x6008             STR      R0,[R1, #+0]
   1635            
   1636            /* Return function status */
   1637            return HAL_OK;
   \                     ??HAL_TIM_IC_Stop_0: (+1)
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1638          }
   1639          
   1640          /**
   1641            * @brief  Starts the TIM Input Capture measurement in interrupt mode.
   1642            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   1643            *                the configuration information for TIM module.
   1644            * @param  Channel: TIM Channels to be enabled.
   1645            *          This parameter can be one of the following values:
   1646            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1647            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1648            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1649            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1650            * @retval HAL status
   1651            */

   \                                 In section .text, align 2, keep-with-next
   1652          HAL_StatusTypeDef HAL_TIM_IC_Start_IT (TIM_HandleTypeDef *htim, uint32_t Channel)
   1653          {
   \                     HAL_TIM_IC_Start_IT: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1654            /* Check the parameters */
   1655            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1656            
   1657            switch (Channel)
   \   00000006   0x0028             MOVS     R0,R5
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD006             BEQ.N    ??HAL_TIM_IC_Start_IT_0
   \   0000000C   0x2804             CMP      R0,#+4
   \   0000000E   0xD00B             BEQ.N    ??HAL_TIM_IC_Start_IT_1
   \   00000010   0x2808             CMP      R0,#+8
   \   00000012   0xD010             BEQ.N    ??HAL_TIM_IC_Start_IT_2
   \   00000014   0x280C             CMP      R0,#+12
   \   00000016   0xD015             BEQ.N    ??HAL_TIM_IC_Start_IT_3
   \   00000018   0xE01B             B.N      ??HAL_TIM_IC_Start_IT_4
   1658            {
   1659              case TIM_CHANNEL_1:
   1660              {       
   1661                /* Enable the TIM Capture/Compare 1 interrupt */
   1662                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
   \                     ??HAL_TIM_IC_Start_IT_0: (+1)
   \   0000001A   0x6820             LDR      R0,[R4, #+0]
   \   0000001C   0x68C0             LDR      R0,[R0, #+12]
   \   0000001E   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   00000022   0x6821             LDR      R1,[R4, #+0]
   \   00000024   0x60C8             STR      R0,[R1, #+12]
   1663              }
   1664              break;
   \   00000026   0xE014             B.N      ??HAL_TIM_IC_Start_IT_5
   1665              
   1666              case TIM_CHANNEL_2:
   1667              {
   1668                /* Enable the TIM Capture/Compare 2 interrupt */
   1669                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
   \                     ??HAL_TIM_IC_Start_IT_1: (+1)
   \   00000028   0x6820             LDR      R0,[R4, #+0]
   \   0000002A   0x68C0             LDR      R0,[R0, #+12]
   \   0000002C   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   00000030   0x6821             LDR      R1,[R4, #+0]
   \   00000032   0x60C8             STR      R0,[R1, #+12]
   1670              }
   1671              break;
   \   00000034   0xE00D             B.N      ??HAL_TIM_IC_Start_IT_5
   1672              
   1673              case TIM_CHANNEL_3:
   1674              {
   1675                /* Enable the TIM Capture/Compare 3 interrupt */
   1676                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);
   \                     ??HAL_TIM_IC_Start_IT_2: (+1)
   \   00000036   0x6820             LDR      R0,[R4, #+0]
   \   00000038   0x68C0             LDR      R0,[R0, #+12]
   \   0000003A   0xF050 0x0008      ORRS     R0,R0,#0x8
   \   0000003E   0x6821             LDR      R1,[R4, #+0]
   \   00000040   0x60C8             STR      R0,[R1, #+12]
   1677              }
   1678              break;
   \   00000042   0xE006             B.N      ??HAL_TIM_IC_Start_IT_5
   1679              
   1680              case TIM_CHANNEL_4:
   1681              {
   1682                /* Enable the TIM Capture/Compare 4 interrupt */
   1683                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC4);
   \                     ??HAL_TIM_IC_Start_IT_3: (+1)
   \   00000044   0x6820             LDR      R0,[R4, #+0]
   \   00000046   0x68C0             LDR      R0,[R0, #+12]
   \   00000048   0xF050 0x0010      ORRS     R0,R0,#0x10
   \   0000004C   0x6821             LDR      R1,[R4, #+0]
   \   0000004E   0x60C8             STR      R0,[R1, #+12]
   1684              }
   1685              break;
   \   00000050   0xE7FF             B.N      ??HAL_TIM_IC_Start_IT_5
   1686              
   1687              default:
   1688              break;
   1689            }  
   1690            /* Enable the Input Capture channel */
   1691            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
   \                     ??HAL_TIM_IC_Start_IT_4: (+1)
   \                     ??HAL_TIM_IC_Start_IT_5: (+1)
   \   00000052   0x2201             MOVS     R2,#+1
   \   00000054   0x0029             MOVS     R1,R5
   \   00000056   0x6820             LDR      R0,[R4, #+0]
   \   00000058   0x.... 0x....      BL       TIM_CCxChannelCmd
   1692              
   1693            /* Enable the Peripheral */
   1694            __HAL_TIM_ENABLE(htim);  
   \   0000005C   0x6820             LDR      R0,[R4, #+0]
   \   0000005E   0x6800             LDR      R0,[R0, #+0]
   \   00000060   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000064   0x6821             LDR      R1,[R4, #+0]
   \   00000066   0x6008             STR      R0,[R1, #+0]
   1695          
   1696            /* Return function status */
   1697            return HAL_OK;  
   \   00000068   0x2000             MOVS     R0,#+0
   \   0000006A   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1698          } 
   1699          
   1700          /**
   1701            * @brief  Stops the TIM Input Capture measurement in interrupt mode.
   1702            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   1703            *                the configuration information for TIM module.
   1704            * @param  Channel: TIM Channels to be disabled.
   1705            *          This parameter can be one of the following values:
   1706            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1707            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1708            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1709            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1710            * @retval HAL status
   1711            */

   \                                 In section .text, align 2, keep-with-next
   1712          HAL_StatusTypeDef HAL_TIM_IC_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
   1713          {
   \                     HAL_TIM_IC_Stop_IT: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1714            /* Check the parameters */
   1715            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1716            
   1717            switch (Channel)
   \   00000006   0x0028             MOVS     R0,R5
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD006             BEQ.N    ??HAL_TIM_IC_Stop_IT_0
   \   0000000C   0x2804             CMP      R0,#+4
   \   0000000E   0xD00B             BEQ.N    ??HAL_TIM_IC_Stop_IT_1
   \   00000010   0x2808             CMP      R0,#+8
   \   00000012   0xD010             BEQ.N    ??HAL_TIM_IC_Stop_IT_2
   \   00000014   0x280C             CMP      R0,#+12
   \   00000016   0xD015             BEQ.N    ??HAL_TIM_IC_Stop_IT_3
   \   00000018   0xE01B             B.N      ??HAL_TIM_IC_Stop_IT_4
   1718            {
   1719              case TIM_CHANNEL_1:
   1720              {       
   1721                /* Disable the TIM Capture/Compare 1 interrupt */
   1722                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
   \                     ??HAL_TIM_IC_Stop_IT_0: (+1)
   \   0000001A   0x6820             LDR      R0,[R4, #+0]
   \   0000001C   0x68C0             LDR      R0,[R0, #+12]
   \   0000001E   0xF030 0x0002      BICS     R0,R0,#0x2
   \   00000022   0x6821             LDR      R1,[R4, #+0]
   \   00000024   0x60C8             STR      R0,[R1, #+12]
   1723              }
   1724              break;
   \   00000026   0xE014             B.N      ??HAL_TIM_IC_Stop_IT_5
   1725              
   1726              case TIM_CHANNEL_2:
   1727              {
   1728                /* Disable the TIM Capture/Compare 2 interrupt */
   1729                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
   \                     ??HAL_TIM_IC_Stop_IT_1: (+1)
   \   00000028   0x6820             LDR      R0,[R4, #+0]
   \   0000002A   0x68C0             LDR      R0,[R0, #+12]
   \   0000002C   0xF030 0x0004      BICS     R0,R0,#0x4
   \   00000030   0x6821             LDR      R1,[R4, #+0]
   \   00000032   0x60C8             STR      R0,[R1, #+12]
   1730              }
   1731              break;
   \   00000034   0xE00D             B.N      ??HAL_TIM_IC_Stop_IT_5
   1732              
   1733              case TIM_CHANNEL_3:
   1734              {
   1735                /* Disable the TIM Capture/Compare 3 interrupt */
   1736                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);
   \                     ??HAL_TIM_IC_Stop_IT_2: (+1)
   \   00000036   0x6820             LDR      R0,[R4, #+0]
   \   00000038   0x68C0             LDR      R0,[R0, #+12]
   \   0000003A   0xF030 0x0008      BICS     R0,R0,#0x8
   \   0000003E   0x6821             LDR      R1,[R4, #+0]
   \   00000040   0x60C8             STR      R0,[R1, #+12]
   1737              }
   1738              break;
   \   00000042   0xE006             B.N      ??HAL_TIM_IC_Stop_IT_5
   1739              
   1740              case TIM_CHANNEL_4:
   1741              {
   1742                /* Disable the TIM Capture/Compare 4 interrupt */
   1743                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC4);
   \                     ??HAL_TIM_IC_Stop_IT_3: (+1)
   \   00000044   0x6820             LDR      R0,[R4, #+0]
   \   00000046   0x68C0             LDR      R0,[R0, #+12]
   \   00000048   0xF030 0x0010      BICS     R0,R0,#0x10
   \   0000004C   0x6821             LDR      R1,[R4, #+0]
   \   0000004E   0x60C8             STR      R0,[R1, #+12]
   1744              }
   1745              break;
   \   00000050   0xE7FF             B.N      ??HAL_TIM_IC_Stop_IT_5
   1746              
   1747              default:
   1748              break; 
   1749            } 
   1750            
   1751            /* Disable the Input Capture channel */
   1752            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE); 
   \                     ??HAL_TIM_IC_Stop_IT_4: (+1)
   \                     ??HAL_TIM_IC_Stop_IT_5: (+1)
   \   00000052   0x2200             MOVS     R2,#+0
   \   00000054   0x0029             MOVS     R1,R5
   \   00000056   0x6820             LDR      R0,[R4, #+0]
   \   00000058   0x.... 0x....      BL       TIM_CCxChannelCmd
   1753            
   1754            /* Disable the Peripheral */
   1755            __HAL_TIM_DISABLE(htim); 
   \   0000005C   0x6820             LDR      R0,[R4, #+0]
   \   0000005E   0x6A00             LDR      R0,[R0, #+32]
   \   00000060   0xF241 0x1111      MOVW     R1,#+4369
   \   00000064   0x4208             TST      R0,R1
   \   00000066   0xD10B             BNE.N    ??HAL_TIM_IC_Stop_IT_6
   \   00000068   0x6820             LDR      R0,[R4, #+0]
   \   0000006A   0x6A00             LDR      R0,[R0, #+32]
   \   0000006C   0xF240 0x4144      MOVW     R1,#+1092
   \   00000070   0x4208             TST      R0,R1
   \   00000072   0xD105             BNE.N    ??HAL_TIM_IC_Stop_IT_6
   \   00000074   0x6820             LDR      R0,[R4, #+0]
   \   00000076   0x6800             LDR      R0,[R0, #+0]
   \   00000078   0x0840             LSRS     R0,R0,#+1
   \   0000007A   0x0040             LSLS     R0,R0,#+1
   \   0000007C   0x6821             LDR      R1,[R4, #+0]
   \   0000007E   0x6008             STR      R0,[R1, #+0]
   1756            
   1757            /* Return function status */
   1758            return HAL_OK;
   \                     ??HAL_TIM_IC_Stop_IT_6: (+1)
   \   00000080   0x2000             MOVS     R0,#+0
   \   00000082   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1759          }
   1760          
   1761          /**
   1762            * @brief  Starts the TIM Input Capture measurement on in DMA mode.
   1763            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   1764            *                the configuration information for TIM module.
   1765            * @param  Channel: TIM Channels to be enabled.
   1766            *          This parameter can be one of the following values:
   1767            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1768            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1769            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1770            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1771            * @param  pData: The destination Buffer address.
   1772            * @param  Length: The length of data to be transferred from TIM peripheral to memory.
   1773            * @retval HAL status
   1774            */

   \                                 In section .text, align 2, keep-with-next
   1775          HAL_StatusTypeDef HAL_TIM_IC_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData, uint16_t Length)
   1776          {
   \                     HAL_TIM_IC_Start_DMA: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   \   00000008   0x001F             MOVS     R7,R3
   1777            /* Check the parameters */
   1778            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1779            assert_param(IS_TIM_DMA_CC_INSTANCE(htim->Instance));
   1780            
   1781            if((htim->State == HAL_TIM_STATE_BUSY))
   \   0000000A   0xF894 0x0039      LDRB     R0,[R4, #+57]
   \   0000000E   0x2802             CMP      R0,#+2
   \   00000010   0xD101             BNE.N    ??HAL_TIM_IC_Start_DMA_0
   1782            {
   1783               return HAL_BUSY;
   \   00000012   0x2002             MOVS     R0,#+2
   \   00000014   0xE081             B.N      ??HAL_TIM_IC_Start_DMA_1
   1784            }
   1785            else if((htim->State == HAL_TIM_STATE_READY))
   \                     ??HAL_TIM_IC_Start_DMA_0: (+1)
   \   00000016   0xF894 0x0039      LDRB     R0,[R4, #+57]
   \   0000001A   0x2801             CMP      R0,#+1
   \   0000001C   0xD109             BNE.N    ??HAL_TIM_IC_Start_DMA_2
   1786            {
   1787              if((pData == 0 ) && (Length > 0)) 
   \   0000001E   0x2E00             CMP      R6,#+0
   \   00000020   0xD104             BNE.N    ??HAL_TIM_IC_Start_DMA_3
   \   00000022   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000024   0x2F00             CMP      R7,#+0
   \   00000026   0xD001             BEQ.N    ??HAL_TIM_IC_Start_DMA_3
   1788              {
   1789                return HAL_ERROR;                                    
   \   00000028   0x2001             MOVS     R0,#+1
   \   0000002A   0xE076             B.N      ??HAL_TIM_IC_Start_DMA_1
   1790              }
   1791              else
   1792              {
   1793                htim->State = HAL_TIM_STATE_BUSY;
   \                     ??HAL_TIM_IC_Start_DMA_3: (+1)
   \   0000002C   0x2002             MOVS     R0,#+2
   \   0000002E   0xF884 0x0039      STRB     R0,[R4, #+57]
   1794              }
   1795            }  
   1796             
   1797            switch (Channel)
   \                     ??HAL_TIM_IC_Start_DMA_2: (+1)
   \   00000032   0x0028             MOVS     R0,R5
   \   00000034   0x2800             CMP      R0,#+0
   \   00000036   0xD006             BEQ.N    ??HAL_TIM_IC_Start_DMA_4
   \   00000038   0x2804             CMP      R0,#+4
   \   0000003A   0xD01C             BEQ.N    ??HAL_TIM_IC_Start_DMA_5
   \   0000003C   0x2808             CMP      R0,#+8
   \   0000003E   0xD032             BEQ.N    ??HAL_TIM_IC_Start_DMA_6
   \   00000040   0x280C             CMP      R0,#+12
   \   00000042   0xD047             BEQ.N    ??HAL_TIM_IC_Start_DMA_7
   \   00000044   0xE05D             B.N      ??HAL_TIM_IC_Start_DMA_8
   1798            {
   1799              case TIM_CHANNEL_1:
   1800              {
   1801                /* Set the DMA Period elapsed callback */
   1802                htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = HAL_TIM_DMACaptureCplt;
   \                     ??HAL_TIM_IC_Start_DMA_4: (+1)
   \   00000046   0x.... 0x....      LDR.W    R0,??DataTable20
   \   0000004A   0x6A21             LDR      R1,[R4, #+32]
   \   0000004C   0x63C8             STR      R0,[R1, #+60]
   1803               
   1804                /* Set the DMA error callback */
   1805                htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = HAL_TIM_DMAError ;
   \   0000004E   0x.... 0x....      LDR.W    R0,??DataTable17_1
   \   00000052   0x6A21             LDR      R1,[R4, #+32]
   \   00000054   0x6488             STR      R0,[R1, #+72]
   1806                
   1807                /* Enable the DMA Stream */
   1808                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->CCR1, (uint32_t)pData, Length); 
   \   00000056   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000058   0x003B             MOVS     R3,R7
   \   0000005A   0x0032             MOVS     R2,R6
   \   0000005C   0x6820             LDR      R0,[R4, #+0]
   \   0000005E   0xF110 0x0134      ADDS     R1,R0,#+52
   \   00000062   0x6A20             LDR      R0,[R4, #+32]
   \   00000064   0x.... 0x....      BL       HAL_DMA_Start_IT
   1809                
   1810                /* Enable the TIM Capture/Compare 1 DMA request */      
   1811                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
   \   00000068   0x6820             LDR      R0,[R4, #+0]
   \   0000006A   0x68C0             LDR      R0,[R0, #+12]
   \   0000006C   0xF450 0x7000      ORRS     R0,R0,#0x200
   \   00000070   0x6821             LDR      R1,[R4, #+0]
   \   00000072   0x60C8             STR      R0,[R1, #+12]
   1812              }
   1813              break;
   \   00000074   0xE045             B.N      ??HAL_TIM_IC_Start_DMA_9
   1814              
   1815              case TIM_CHANNEL_2:
   1816              {
   1817                /* Set the DMA Period elapsed callback */
   1818                htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = HAL_TIM_DMACaptureCplt;
   \                     ??HAL_TIM_IC_Start_DMA_5: (+1)
   \   00000076   0x.... 0x....      LDR.W    R0,??DataTable20
   \   0000007A   0x6A61             LDR      R1,[R4, #+36]
   \   0000007C   0x63C8             STR      R0,[R1, #+60]
   1819               
   1820                /* Set the DMA error callback */
   1821                htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = HAL_TIM_DMAError ;
   \   0000007E   0x.... 0x....      LDR.W    R0,??DataTable17_1
   \   00000082   0x6A61             LDR      R1,[R4, #+36]
   \   00000084   0x6488             STR      R0,[R1, #+72]
   1822                
   1823                /* Enable the DMA Stream */
   1824                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->CCR2, (uint32_t)pData, Length);
   \   00000086   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000088   0x003B             MOVS     R3,R7
   \   0000008A   0x0032             MOVS     R2,R6
   \   0000008C   0x6820             LDR      R0,[R4, #+0]
   \   0000008E   0xF110 0x0138      ADDS     R1,R0,#+56
   \   00000092   0x6A60             LDR      R0,[R4, #+36]
   \   00000094   0x.... 0x....      BL       HAL_DMA_Start_IT
   1825                
   1826                /* Enable the TIM Capture/Compare 2  DMA request */
   1827                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
   \   00000098   0x6820             LDR      R0,[R4, #+0]
   \   0000009A   0x68C0             LDR      R0,[R0, #+12]
   \   0000009C   0xF450 0x6080      ORRS     R0,R0,#0x400
   \   000000A0   0x6821             LDR      R1,[R4, #+0]
   \   000000A2   0x60C8             STR      R0,[R1, #+12]
   1828              }
   1829              break;
   \   000000A4   0xE02D             B.N      ??HAL_TIM_IC_Start_DMA_9
   1830              
   1831              case TIM_CHANNEL_3:
   1832              {
   1833                /* Set the DMA Period elapsed callback */
   1834                htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = HAL_TIM_DMACaptureCplt;
   \                     ??HAL_TIM_IC_Start_DMA_6: (+1)
   \   000000A6   0x.... 0x....      LDR.W    R0,??DataTable20
   \   000000AA   0x6AA1             LDR      R1,[R4, #+40]
   \   000000AC   0x63C8             STR      R0,[R1, #+60]
   1835               
   1836                /* Set the DMA error callback */
   1837                htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = HAL_TIM_DMAError ;
   \   000000AE   0x....             LDR.N    R0,??DataTable17_1
   \   000000B0   0x6AA1             LDR      R1,[R4, #+40]
   \   000000B2   0x6488             STR      R0,[R1, #+72]
   1838                
   1839                /* Enable the DMA Stream */
   1840                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)&htim->Instance->CCR3, (uint32_t)pData, Length);
   \   000000B4   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   000000B6   0x003B             MOVS     R3,R7
   \   000000B8   0x0032             MOVS     R2,R6
   \   000000BA   0x6820             LDR      R0,[R4, #+0]
   \   000000BC   0xF110 0x013C      ADDS     R1,R0,#+60
   \   000000C0   0x6AA0             LDR      R0,[R4, #+40]
   \   000000C2   0x.... 0x....      BL       HAL_DMA_Start_IT
   1841                
   1842                /* Enable the TIM Capture/Compare 3  DMA request */
   1843                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);
   \   000000C6   0x6820             LDR      R0,[R4, #+0]
   \   000000C8   0x68C0             LDR      R0,[R0, #+12]
   \   000000CA   0xF450 0x6000      ORRS     R0,R0,#0x800
   \   000000CE   0x6821             LDR      R1,[R4, #+0]
   \   000000D0   0x60C8             STR      R0,[R1, #+12]
   1844              }
   1845              break;
   \   000000D2   0xE016             B.N      ??HAL_TIM_IC_Start_DMA_9
   1846              
   1847              case TIM_CHANNEL_4:
   1848              {
   1849                /* Set the DMA Period elapsed callback */
   1850                htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = HAL_TIM_DMACaptureCplt;
   \                     ??HAL_TIM_IC_Start_DMA_7: (+1)
   \   000000D4   0x.... 0x....      LDR.W    R0,??DataTable20
   \   000000D8   0x6AE1             LDR      R1,[R4, #+44]
   \   000000DA   0x63C8             STR      R0,[R1, #+60]
   1851               
   1852                /* Set the DMA error callback */
   1853                htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = HAL_TIM_DMAError ;
   \   000000DC   0x....             LDR.N    R0,??DataTable17_1
   \   000000DE   0x6AE1             LDR      R1,[R4, #+44]
   \   000000E0   0x6488             STR      R0,[R1, #+72]
   1854                
   1855                /* Enable the DMA Stream */
   1856                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)&htim->Instance->CCR4, (uint32_t)pData, Length);
   \   000000E2   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   000000E4   0x003B             MOVS     R3,R7
   \   000000E6   0x0032             MOVS     R2,R6
   \   000000E8   0x6820             LDR      R0,[R4, #+0]
   \   000000EA   0xF110 0x0140      ADDS     R1,R0,#+64
   \   000000EE   0x6AE0             LDR      R0,[R4, #+44]
   \   000000F0   0x.... 0x....      BL       HAL_DMA_Start_IT
   1857                
   1858                /* Enable the TIM Capture/Compare 4  DMA request */
   1859                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC4);
   \   000000F4   0x6820             LDR      R0,[R4, #+0]
   \   000000F6   0x68C0             LDR      R0,[R0, #+12]
   \   000000F8   0xF450 0x5080      ORRS     R0,R0,#0x1000
   \   000000FC   0x6821             LDR      R1,[R4, #+0]
   \   000000FE   0x60C8             STR      R0,[R1, #+12]
   1860              }
   1861              break;
   \   00000100   0xE7FF             B.N      ??HAL_TIM_IC_Start_DMA_9
   1862              
   1863              default:
   1864              break;
   1865            }
   1866          
   1867            /* Enable the Input Capture channel */
   1868            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
   \                     ??HAL_TIM_IC_Start_DMA_8: (+1)
   \                     ??HAL_TIM_IC_Start_DMA_9: (+1)
   \   00000102   0x2201             MOVS     R2,#+1
   \   00000104   0x0029             MOVS     R1,R5
   \   00000106   0x6820             LDR      R0,[R4, #+0]
   \   00000108   0x.... 0x....      BL       TIM_CCxChannelCmd
   1869             
   1870            /* Enable the Peripheral */
   1871            __HAL_TIM_ENABLE(htim); 
   \   0000010C   0x6820             LDR      R0,[R4, #+0]
   \   0000010E   0x6800             LDR      R0,[R0, #+0]
   \   00000110   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000114   0x6821             LDR      R1,[R4, #+0]
   \   00000116   0x6008             STR      R0,[R1, #+0]
   1872            
   1873            /* Return function status */
   1874            return HAL_OK;
   \   00000118   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_IC_Start_DMA_1: (+1)
   \   0000011A   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1875          }
   1876          
   1877          /**
   1878            * @brief  Stops the TIM Input Capture measurement on in DMA mode.
   1879            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   1880            *                the configuration information for TIM module.
   1881            * @param  Channel: TIM Channels to be disabled.
   1882            *          This parameter can be one of the following values:
   1883            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1884            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1885            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1886            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1887            * @retval HAL status
   1888            */

   \                                 In section .text, align 2, keep-with-next
   1889          HAL_StatusTypeDef HAL_TIM_IC_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
   1890          {
   \                     HAL_TIM_IC_Stop_DMA: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1891            /* Check the parameters */
   1892            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1893            assert_param(IS_TIM_DMA_CC_INSTANCE(htim->Instance));
   1894            
   1895            switch (Channel)
   \   00000006   0x0028             MOVS     R0,R5
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD006             BEQ.N    ??HAL_TIM_IC_Stop_DMA_0
   \   0000000C   0x2804             CMP      R0,#+4
   \   0000000E   0xD00B             BEQ.N    ??HAL_TIM_IC_Stop_DMA_1
   \   00000010   0x2808             CMP      R0,#+8
   \   00000012   0xD010             BEQ.N    ??HAL_TIM_IC_Stop_DMA_2
   \   00000014   0x280C             CMP      R0,#+12
   \   00000016   0xD015             BEQ.N    ??HAL_TIM_IC_Stop_DMA_3
   \   00000018   0xE01B             B.N      ??HAL_TIM_IC_Stop_DMA_4
   1896            {
   1897              case TIM_CHANNEL_1:
   1898              {       
   1899                /* Disable the TIM Capture/Compare 1 DMA request */
   1900                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
   \                     ??HAL_TIM_IC_Stop_DMA_0: (+1)
   \   0000001A   0x6820             LDR      R0,[R4, #+0]
   \   0000001C   0x68C0             LDR      R0,[R0, #+12]
   \   0000001E   0xF430 0x7000      BICS     R0,R0,#0x200
   \   00000022   0x6821             LDR      R1,[R4, #+0]
   \   00000024   0x60C8             STR      R0,[R1, #+12]
   1901              }
   1902              break;
   \   00000026   0xE014             B.N      ??HAL_TIM_IC_Stop_DMA_5
   1903              
   1904              case TIM_CHANNEL_2:
   1905              {
   1906                /* Disable the TIM Capture/Compare 2 DMA request */
   1907                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
   \                     ??HAL_TIM_IC_Stop_DMA_1: (+1)
   \   00000028   0x6820             LDR      R0,[R4, #+0]
   \   0000002A   0x68C0             LDR      R0,[R0, #+12]
   \   0000002C   0xF430 0x6080      BICS     R0,R0,#0x400
   \   00000030   0x6821             LDR      R1,[R4, #+0]
   \   00000032   0x60C8             STR      R0,[R1, #+12]
   1908              }
   1909              break;
   \   00000034   0xE00D             B.N      ??HAL_TIM_IC_Stop_DMA_5
   1910              
   1911              case TIM_CHANNEL_3:
   1912              {
   1913                /* Disable the TIM Capture/Compare 3  DMA request */
   1914                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);
   \                     ??HAL_TIM_IC_Stop_DMA_2: (+1)
   \   00000036   0x6820             LDR      R0,[R4, #+0]
   \   00000038   0x68C0             LDR      R0,[R0, #+12]
   \   0000003A   0xF430 0x6000      BICS     R0,R0,#0x800
   \   0000003E   0x6821             LDR      R1,[R4, #+0]
   \   00000040   0x60C8             STR      R0,[R1, #+12]
   1915              }
   1916              break;
   \   00000042   0xE006             B.N      ??HAL_TIM_IC_Stop_DMA_5
   1917              
   1918              case TIM_CHANNEL_4:
   1919              {
   1920                /* Disable the TIM Capture/Compare 4  DMA request */
   1921                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC4);
   \                     ??HAL_TIM_IC_Stop_DMA_3: (+1)
   \   00000044   0x6820             LDR      R0,[R4, #+0]
   \   00000046   0x68C0             LDR      R0,[R0, #+12]
   \   00000048   0xF430 0x5080      BICS     R0,R0,#0x1000
   \   0000004C   0x6821             LDR      R1,[R4, #+0]
   \   0000004E   0x60C8             STR      R0,[R1, #+12]
   1922              }
   1923              break;
   \   00000050   0xE7FF             B.N      ??HAL_TIM_IC_Stop_DMA_5
   1924              
   1925              default:
   1926              break;
   1927            }
   1928          
   1929            /* Disable the Input Capture channel */
   1930            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
   \                     ??HAL_TIM_IC_Stop_DMA_4: (+1)
   \                     ??HAL_TIM_IC_Stop_DMA_5: (+1)
   \   00000052   0x2200             MOVS     R2,#+0
   \   00000054   0x0029             MOVS     R1,R5
   \   00000056   0x6820             LDR      R0,[R4, #+0]
   \   00000058   0x.... 0x....      BL       TIM_CCxChannelCmd
   1931            
   1932            /* Disable the Peripheral */
   1933            __HAL_TIM_DISABLE(htim); 
   \   0000005C   0x6820             LDR      R0,[R4, #+0]
   \   0000005E   0x6A00             LDR      R0,[R0, #+32]
   \   00000060   0xF241 0x1111      MOVW     R1,#+4369
   \   00000064   0x4208             TST      R0,R1
   \   00000066   0xD10B             BNE.N    ??HAL_TIM_IC_Stop_DMA_6
   \   00000068   0x6820             LDR      R0,[R4, #+0]
   \   0000006A   0x6A00             LDR      R0,[R0, #+32]
   \   0000006C   0xF240 0x4144      MOVW     R1,#+1092
   \   00000070   0x4208             TST      R0,R1
   \   00000072   0xD105             BNE.N    ??HAL_TIM_IC_Stop_DMA_6
   \   00000074   0x6820             LDR      R0,[R4, #+0]
   \   00000076   0x6800             LDR      R0,[R0, #+0]
   \   00000078   0x0840             LSRS     R0,R0,#+1
   \   0000007A   0x0040             LSLS     R0,R0,#+1
   \   0000007C   0x6821             LDR      R1,[R4, #+0]
   \   0000007E   0x6008             STR      R0,[R1, #+0]
   1934            
   1935            /* Change the htim state */
   1936            htim->State = HAL_TIM_STATE_READY;
   \                     ??HAL_TIM_IC_Stop_DMA_6: (+1)
   \   00000080   0x2001             MOVS     R0,#+1
   \   00000082   0xF884 0x0039      STRB     R0,[R4, #+57]
   1937            
   1938            /* Return function status */
   1939            return HAL_OK;
   \   00000086   0x2000             MOVS     R0,#+0
   \   00000088   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1940          }  
   1941          /**
   1942            * @}
   1943            */
   1944            
   1945          /** @defgroup TIM_Exported_Functions_Group5 Time One Pulse functions 
   1946           *  @brief    Time One Pulse functions 
   1947           *
   1948          @verbatim    
   1949            ==============================================================================
   1950                                  ##### Time One Pulse functions #####
   1951            ==============================================================================
   1952            [..]  
   1953              This section provides functions allowing to:
   1954              (+) Initialize and configure the TIM One Pulse. 
   1955              (+) De-initialize the TIM One Pulse.
   1956              (+) Start the Time One Pulse.
   1957              (+) Stop the Time One Pulse.
   1958              (+) Start the Time One Pulse and enable interrupt.
   1959              (+) Stop the Time One Pulse and disable interrupt.
   1960              (+) Start the Time One Pulse and enable DMA transfer.
   1961              (+) Stop the Time One Pulse and disable DMA transfer.
   1962           
   1963          @endverbatim
   1964            * @{
   1965            */
   1966          /**
   1967            * @brief  Initializes the TIM One Pulse Time Base according to the specified
   1968            *         parameters in the TIM_HandleTypeDef and create the associated handle.
   1969            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   1970            *                the configuration information for TIM module.
   1971            * @param  OnePulseMode: Select the One pulse mode.
   1972            *         This parameter can be one of the following values:
   1973            *            @arg TIM_OPMODE_SINGLE: Only one pulse will be generated.
   1974            *            @arg TIM_OPMODE_REPETITIVE: Repetitive pulses will be generated.
   1975            * @retval HAL status
   1976            */

   \                                 In section .text, align 2, keep-with-next
   1977          HAL_StatusTypeDef HAL_TIM_OnePulse_Init(TIM_HandleTypeDef *htim, uint32_t OnePulseMode)
   1978          {
   \                     HAL_TIM_OnePulse_Init: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1979            /* Check the TIM handle allocation */
   1980            if(htim == NULL)
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD101             BNE.N    ??HAL_TIM_OnePulse_Init_0
   1981            {
   1982              return HAL_ERROR;
   \   0000000A   0x2001             MOVS     R0,#+1
   \   0000000C   0xE01F             B.N      ??HAL_TIM_OnePulse_Init_1
   1983            }
   1984          
   1985            /* Check the parameters */
   1986            assert_param(IS_TIM_INSTANCE(htim->Instance));
   1987            assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
   1988            assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
   1989            assert_param(IS_TIM_OPM_MODE(OnePulseMode));
   1990            
   1991            if(htim->State == HAL_TIM_STATE_RESET)
   \                     ??HAL_TIM_OnePulse_Init_0: (+1)
   \   0000000E   0xF894 0x0039      LDRB     R0,[R4, #+57]
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD105             BNE.N    ??HAL_TIM_OnePulse_Init_2
   1992            { 
   1993              /* Allocate lock resource and initialize it */
   1994              htim->Lock = HAL_UNLOCKED;    
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0xF884 0x0038      STRB     R0,[R4, #+56]
   1995              /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
   1996              HAL_TIM_OnePulse_MspInit(htim);
   \   0000001C   0x0020             MOVS     R0,R4
   \   0000001E   0x.... 0x....      BL       HAL_TIM_OnePulse_MspInit
   1997            }
   1998            
   1999            /* Set the TIM state */
   2000            htim->State= HAL_TIM_STATE_BUSY;  
   \                     ??HAL_TIM_OnePulse_Init_2: (+1)
   \   00000022   0x2002             MOVS     R0,#+2
   \   00000024   0xF884 0x0039      STRB     R0,[R4, #+57]
   2001            
   2002            /* Configure the Time base in the One Pulse Mode */
   2003            TIM_Base_SetConfig(htim->Instance, &htim->Init);
   \   00000028   0x1D21             ADDS     R1,R4,#+4
   \   0000002A   0x6820             LDR      R0,[R4, #+0]
   \   0000002C   0x.... 0x....      BL       TIM_Base_SetConfig
   2004            
   2005            /* Reset the OPM Bit */
   2006            htim->Instance->CR1 &= ~TIM_CR1_OPM;
   \   00000030   0x6820             LDR      R0,[R4, #+0]
   \   00000032   0x6800             LDR      R0,[R0, #+0]
   \   00000034   0xF030 0x0008      BICS     R0,R0,#0x8
   \   00000038   0x6821             LDR      R1,[R4, #+0]
   \   0000003A   0x6008             STR      R0,[R1, #+0]
   2007          
   2008            /* Configure the OPM Mode */
   2009            htim->Instance->CR1 |= OnePulseMode;
   \   0000003C   0x6820             LDR      R0,[R4, #+0]
   \   0000003E   0x6800             LDR      R0,[R0, #+0]
   \   00000040   0x4328             ORRS     R0,R5,R0
   \   00000042   0x6821             LDR      R1,[R4, #+0]
   \   00000044   0x6008             STR      R0,[R1, #+0]
   2010             
   2011            /* Initialize the TIM state*/
   2012            htim->State= HAL_TIM_STATE_READY;
   \   00000046   0x2001             MOVS     R0,#+1
   \   00000048   0xF884 0x0039      STRB     R0,[R4, #+57]
   2013            
   2014            return HAL_OK;
   \   0000004C   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_OnePulse_Init_1: (+1)
   \   0000004E   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   2015          }
   2016          
   2017          /**
   2018            * @brief  DeInitializes the TIM One Pulse  
   2019            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   2020            *                the configuration information for TIM module.
   2021            * @retval HAL status
   2022            */

   \                                 In section .text, align 2, keep-with-next
   2023          HAL_StatusTypeDef HAL_TIM_OnePulse_DeInit(TIM_HandleTypeDef *htim)
   2024          {
   \                     HAL_TIM_OnePulse_DeInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   2025            /* Check the parameters */
   2026            assert_param(IS_TIM_INSTANCE(htim->Instance));
   2027            
   2028            htim->State = HAL_TIM_STATE_BUSY;
   \   00000004   0x2002             MOVS     R0,#+2
   \   00000006   0xF884 0x0039      STRB     R0,[R4, #+57]
   2029            
   2030            /* Disable the TIM Peripheral Clock */
   2031            __HAL_TIM_DISABLE(htim);
   \   0000000A   0x6820             LDR      R0,[R4, #+0]
   \   0000000C   0x6A00             LDR      R0,[R0, #+32]
   \   0000000E   0xF241 0x1111      MOVW     R1,#+4369
   \   00000012   0x4208             TST      R0,R1
   \   00000014   0xD10B             BNE.N    ??HAL_TIM_OnePulse_DeInit_0
   \   00000016   0x6820             LDR      R0,[R4, #+0]
   \   00000018   0x6A00             LDR      R0,[R0, #+32]
   \   0000001A   0xF240 0x4144      MOVW     R1,#+1092
   \   0000001E   0x4208             TST      R0,R1
   \   00000020   0xD105             BNE.N    ??HAL_TIM_OnePulse_DeInit_0
   \   00000022   0x6820             LDR      R0,[R4, #+0]
   \   00000024   0x6800             LDR      R0,[R0, #+0]
   \   00000026   0x0840             LSRS     R0,R0,#+1
   \   00000028   0x0040             LSLS     R0,R0,#+1
   \   0000002A   0x6821             LDR      R1,[R4, #+0]
   \   0000002C   0x6008             STR      R0,[R1, #+0]
   2032            
   2033            /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
   2034            HAL_TIM_OnePulse_MspDeInit(htim);
   \                     ??HAL_TIM_OnePulse_DeInit_0: (+1)
   \   0000002E   0x0020             MOVS     R0,R4
   \   00000030   0x.... 0x....      BL       HAL_TIM_OnePulse_MspDeInit
   2035              
   2036            /* Change TIM state */  
   2037            htim->State = HAL_TIM_STATE_RESET;
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0xF884 0x0039      STRB     R0,[R4, #+57]
   2038          
   2039            /* Release Lock */
   2040            __HAL_UNLOCK(htim);
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0xF884 0x0038      STRB     R0,[R4, #+56]
   2041          
   2042            return HAL_OK;
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0xBD10             POP      {R4,PC}          ;; return
   2043          }
   2044          
   2045          /**
   2046            * @brief  Initializes the TIM One Pulse MSP.
   2047            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   2048            *                the configuration information for TIM module.
   2049            * @retval None
   2050            */

   \                                 In section .text, align 2, keep-with-next
   2051          __weak void HAL_TIM_OnePulse_MspInit(TIM_HandleTypeDef *htim)
   2052          {
   2053            /* NOTE : This function Should not be modified, when the callback is needed,
   2054                      the HAL_TIM_OnePulse_MspInit could be implemented in the user file
   2055             */
   2056          }
   \                     HAL_TIM_OnePulse_MspInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   2057          
   2058          /**
   2059            * @brief  DeInitializes TIM One Pulse MSP.
   2060            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   2061            *                the configuration information for TIM module.
   2062            * @retval None
   2063            */

   \                                 In section .text, align 2, keep-with-next
   2064          __weak void HAL_TIM_OnePulse_MspDeInit(TIM_HandleTypeDef *htim)
   2065          {
   2066            /* NOTE : This function Should not be modified, when the callback is needed,
   2067                      the HAL_TIM_OnePulse_MspDeInit could be implemented in the user file
   2068             */
   2069          }
   \                     HAL_TIM_OnePulse_MspDeInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   2070          
   2071          /**
   2072            * @brief  Starts the TIM One Pulse signal generation.
   2073            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   2074            *                the configuration information for TIM module.
   2075            * @param  OutputChannel : TIM Channels to be enabled.
   2076            *          This parameter can be one of the following values:
   2077            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2078            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2079            * @retval HAL status
   2080            */

   \                                 In section .text, align 2, keep-with-next
   2081          HAL_StatusTypeDef HAL_TIM_OnePulse_Start(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
   2082          {
   \                     HAL_TIM_OnePulse_Start: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   2083            /* Enable the Capture compare and the Input Capture channels 
   2084              (in the OPM Mode the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2)
   2085              if TIM_CHANNEL_1 is used as output, the TIM_CHANNEL_2 will be used as input and
   2086              if TIM_CHANNEL_1 is used as input, the TIM_CHANNEL_2 will be used as output 
   2087              in all combinations, the TIM_CHANNEL_1 and TIM_CHANNEL_2 should be enabled together 
   2088              
   2089              No need to enable the counter, it's enabled automatically by hardware 
   2090              (the counter starts in response to a stimulus and generate a pulse */
   2091            
   2092            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE); 
   \   00000006   0x2201             MOVS     R2,#+1
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0x6820             LDR      R0,[R4, #+0]
   \   0000000C   0x.... 0x....      BL       TIM_CCxChannelCmd
   2093            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE); 
   \   00000010   0x2201             MOVS     R2,#+1
   \   00000012   0x2104             MOVS     R1,#+4
   \   00000014   0x6820             LDR      R0,[R4, #+0]
   \   00000016   0x.... 0x....      BL       TIM_CCxChannelCmd
   2094            
   2095            if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
   \   0000001A   0x6820             LDR      R0,[R4, #+0]
   \   0000001C   0x.... 0x....      LDR.W    R1,??DataTable21  ;; 0x40010000
   \   00000020   0x4288             CMP      R0,R1
   \   00000022   0xD003             BEQ.N    ??HAL_TIM_OnePulse_Start_0
   \   00000024   0x6820             LDR      R0,[R4, #+0]
   \   00000026   0x....             LDR.N    R1,??DataTable14  ;; 0x40010400
   \   00000028   0x4288             CMP      R0,R1
   \   0000002A   0xD101             BNE.N    ??HAL_TIM_OnePulse_Start_1
   \                     ??HAL_TIM_OnePulse_Start_0: (+1)
   \   0000002C   0x2001             MOVS     R0,#+1
   \   0000002E   0xE000             B.N      ??HAL_TIM_OnePulse_Start_2
   \                     ??HAL_TIM_OnePulse_Start_1: (+1)
   \   00000030   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_OnePulse_Start_2: (+1)
   \   00000032   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000034   0x2800             CMP      R0,#+0
   \   00000036   0xD005             BEQ.N    ??HAL_TIM_OnePulse_Start_3
   2096            {
   2097              /* Enable the main output */
   2098              __HAL_TIM_MOE_ENABLE(htim);
   \   00000038   0x6820             LDR      R0,[R4, #+0]
   \   0000003A   0x6C40             LDR      R0,[R0, #+68]
   \   0000003C   0xF450 0x4000      ORRS     R0,R0,#0x8000
   \   00000040   0x6821             LDR      R1,[R4, #+0]
   \   00000042   0x6448             STR      R0,[R1, #+68]
   2099            }
   2100            
   2101            /* Return function status */
   2102            return HAL_OK;
   \                     ??HAL_TIM_OnePulse_Start_3: (+1)
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   2103          }
   2104          
   2105          /**
   2106            * @brief  Stops the TIM One Pulse signal generation.
   2107            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   2108            *                the configuration information for TIM module.
   2109            * @param  OutputChannel : TIM Channels to be disable.
   2110            *          This parameter can be one of the following values:
   2111            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2112            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2113            * @retval HAL status
   2114            */

   \                                 In section .text, align 2, keep-with-next
   2115          HAL_StatusTypeDef HAL_TIM_OnePulse_Stop(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
   2116          {
   \                     HAL_TIM_OnePulse_Stop: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   2117            /* Disable the Capture compare and the Input Capture channels 
   2118            (in the OPM Mode the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2)
   2119            if TIM_CHANNEL_1 is used as output, the TIM_CHANNEL_2 will be used as input and
   2120            if TIM_CHANNEL_1 is used as input, the TIM_CHANNEL_2 will be used as output 
   2121            in all combinations, the TIM_CHANNEL_1 and TIM_CHANNEL_2 should be disabled together */
   2122            
   2123            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE); 
   \   00000006   0x2200             MOVS     R2,#+0
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0x6820             LDR      R0,[R4, #+0]
   \   0000000C   0x.... 0x....      BL       TIM_CCxChannelCmd
   2124            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE); 
   \   00000010   0x2200             MOVS     R2,#+0
   \   00000012   0x2104             MOVS     R1,#+4
   \   00000014   0x6820             LDR      R0,[R4, #+0]
   \   00000016   0x.... 0x....      BL       TIM_CCxChannelCmd
   2125              
   2126            if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
   \   0000001A   0x6820             LDR      R0,[R4, #+0]
   \   0000001C   0x.... 0x....      LDR.W    R1,??DataTable21  ;; 0x40010000
   \   00000020   0x4288             CMP      R0,R1
   \   00000022   0xD004             BEQ.N    ??HAL_TIM_OnePulse_Stop_0
   \   00000024   0x6820             LDR      R0,[R4, #+0]
   \   00000026   0x.... 0x....      LDR.W    R1,??DataTable21_1  ;; 0x40010400
   \   0000002A   0x4288             CMP      R0,R1
   \   0000002C   0xD101             BNE.N    ??HAL_TIM_OnePulse_Stop_1
   \                     ??HAL_TIM_OnePulse_Stop_0: (+1)
   \   0000002E   0x2001             MOVS     R0,#+1
   \   00000030   0xE000             B.N      ??HAL_TIM_OnePulse_Stop_2
   \                     ??HAL_TIM_OnePulse_Stop_1: (+1)
   \   00000032   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_OnePulse_Stop_2: (+1)
   \   00000034   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000036   0x2800             CMP      R0,#+0
   \   00000038   0xD011             BEQ.N    ??HAL_TIM_OnePulse_Stop_3
   2127            {
   2128              /* Disable the Main Output */
   2129              __HAL_TIM_MOE_DISABLE(htim);
   \   0000003A   0x6820             LDR      R0,[R4, #+0]
   \   0000003C   0x6A00             LDR      R0,[R0, #+32]
   \   0000003E   0xF241 0x1111      MOVW     R1,#+4369
   \   00000042   0x4208             TST      R0,R1
   \   00000044   0xD10B             BNE.N    ??HAL_TIM_OnePulse_Stop_4
   \   00000046   0x6820             LDR      R0,[R4, #+0]
   \   00000048   0x6A00             LDR      R0,[R0, #+32]
   \   0000004A   0xF240 0x4144      MOVW     R1,#+1092
   \   0000004E   0x4208             TST      R0,R1
   \   00000050   0xD105             BNE.N    ??HAL_TIM_OnePulse_Stop_4
   \   00000052   0x6820             LDR      R0,[R4, #+0]
   \   00000054   0x6C40             LDR      R0,[R0, #+68]
   \   00000056   0xF430 0x4000      BICS     R0,R0,#0x8000
   \   0000005A   0x6821             LDR      R1,[R4, #+0]
   \   0000005C   0x6448             STR      R0,[R1, #+68]
   2130            }
   2131              
   2132            /* Disable the Peripheral */
   2133            __HAL_TIM_DISABLE(htim); 
   \                     ??HAL_TIM_OnePulse_Stop_4: (+1)
   \                     ??HAL_TIM_OnePulse_Stop_3: (+1)
   \   0000005E   0x6820             LDR      R0,[R4, #+0]
   \   00000060   0x6A00             LDR      R0,[R0, #+32]
   \   00000062   0xF241 0x1111      MOVW     R1,#+4369
   \   00000066   0x4208             TST      R0,R1
   \   00000068   0xD10B             BNE.N    ??HAL_TIM_OnePulse_Stop_5
   \   0000006A   0x6820             LDR      R0,[R4, #+0]
   \   0000006C   0x6A00             LDR      R0,[R0, #+32]
   \   0000006E   0xF240 0x4144      MOVW     R1,#+1092
   \   00000072   0x4208             TST      R0,R1
   \   00000074   0xD105             BNE.N    ??HAL_TIM_OnePulse_Stop_5
   \   00000076   0x6820             LDR      R0,[R4, #+0]
   \   00000078   0x6800             LDR      R0,[R0, #+0]
   \   0000007A   0x0840             LSRS     R0,R0,#+1
   \   0000007C   0x0040             LSLS     R0,R0,#+1
   \   0000007E   0x6821             LDR      R1,[R4, #+0]
   \   00000080   0x6008             STR      R0,[R1, #+0]
   2134            
   2135            /* Return function status */
   2136            return HAL_OK;
   \                     ??HAL_TIM_OnePulse_Stop_5: (+1)
   \   00000082   0x2000             MOVS     R0,#+0
   \   00000084   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   2137          }
   2138          
   2139          /**
   2140            * @brief  Starts the TIM One Pulse signal generation in interrupt mode.
   2141            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   2142            *                the configuration information for TIM module.
   2143            * @param  OutputChannel : TIM Channels to be enabled.
   2144            *          This parameter can be one of the following values:
   2145            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2146            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2147            * @retval HAL status
   2148            */

   \                                 In section .text, align 2, keep-with-next
   2149          HAL_StatusTypeDef HAL_TIM_OnePulse_Start_IT(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
   2150          {
   \                     HAL_TIM_OnePulse_Start_IT: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   2151            /* Enable the Capture compare and the Input Capture channels 
   2152              (in the OPM Mode the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2)
   2153              if TIM_CHANNEL_1 is used as output, the TIM_CHANNEL_2 will be used as input and
   2154              if TIM_CHANNEL_1 is used as input, the TIM_CHANNEL_2 will be used as output 
   2155              in all combinations, the TIM_CHANNEL_1 and TIM_CHANNEL_2 should be enabled together 
   2156              
   2157              No need to enable the counter, it's enabled automatically by hardware 
   2158              (the counter starts in response to a stimulus and generate a pulse */
   2159           
   2160            /* Enable the TIM Capture/Compare 1 interrupt */
   2161            __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
   \   00000006   0x6820             LDR      R0,[R4, #+0]
   \   00000008   0x68C0             LDR      R0,[R0, #+12]
   \   0000000A   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   0000000E   0x6821             LDR      R1,[R4, #+0]
   \   00000010   0x60C8             STR      R0,[R1, #+12]
   2162            
   2163            /* Enable the TIM Capture/Compare 2 interrupt */
   2164            __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
   \   00000012   0x6820             LDR      R0,[R4, #+0]
   \   00000014   0x68C0             LDR      R0,[R0, #+12]
   \   00000016   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   0000001A   0x6821             LDR      R1,[R4, #+0]
   \   0000001C   0x60C8             STR      R0,[R1, #+12]
   2165            
   2166            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE); 
   \   0000001E   0x2201             MOVS     R2,#+1
   \   00000020   0x2100             MOVS     R1,#+0
   \   00000022   0x6820             LDR      R0,[R4, #+0]
   \   00000024   0x.... 0x....      BL       TIM_CCxChannelCmd
   2167            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE); 
   \   00000028   0x2201             MOVS     R2,#+1
   \   0000002A   0x2104             MOVS     R1,#+4
   \   0000002C   0x6820             LDR      R0,[R4, #+0]
   \   0000002E   0x.... 0x....      BL       TIM_CCxChannelCmd
   2168            
   2169            if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
   \   00000032   0x6820             LDR      R0,[R4, #+0]
   \   00000034   0x.... 0x....      LDR.W    R1,??DataTable21  ;; 0x40010000
   \   00000038   0x4288             CMP      R0,R1
   \   0000003A   0xD004             BEQ.N    ??HAL_TIM_OnePulse_Start_IT_0
   \   0000003C   0x6820             LDR      R0,[R4, #+0]
   \   0000003E   0x.... 0x....      LDR.W    R1,??DataTable21_1  ;; 0x40010400
   \   00000042   0x4288             CMP      R0,R1
   \   00000044   0xD101             BNE.N    ??HAL_TIM_OnePulse_Start_IT_1
   \                     ??HAL_TIM_OnePulse_Start_IT_0: (+1)
   \   00000046   0x2001             MOVS     R0,#+1
   \   00000048   0xE000             B.N      ??HAL_TIM_OnePulse_Start_IT_2
   \                     ??HAL_TIM_OnePulse_Start_IT_1: (+1)
   \   0000004A   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_OnePulse_Start_IT_2: (+1)
   \   0000004C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000004E   0x2800             CMP      R0,#+0
   \   00000050   0xD005             BEQ.N    ??HAL_TIM_OnePulse_Start_IT_3
   2170            {
   2171              /* Enable the main output */
   2172              __HAL_TIM_MOE_ENABLE(htim);
   \   00000052   0x6820             LDR      R0,[R4, #+0]
   \   00000054   0x6C40             LDR      R0,[R0, #+68]
   \   00000056   0xF450 0x4000      ORRS     R0,R0,#0x8000
   \   0000005A   0x6821             LDR      R1,[R4, #+0]
   \   0000005C   0x6448             STR      R0,[R1, #+68]
   2173            }
   2174            
   2175            /* Return function status */
   2176            return HAL_OK;
   \                     ??HAL_TIM_OnePulse_Start_IT_3: (+1)
   \   0000005E   0x2000             MOVS     R0,#+0
   \   00000060   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   2177          }
   2178          
   2179          /**
   2180            * @brief  Stops the TIM One Pulse signal generation in interrupt mode.
   2181            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   2182            *                the configuration information for TIM module.
   2183            * @param  OutputChannel : TIM Channels to be enabled.
   2184            *          This parameter can be one of the following values:
   2185            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2186            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2187            * @retval HAL status
   2188            */

   \                                 In section .text, align 2, keep-with-next
   2189          HAL_StatusTypeDef HAL_TIM_OnePulse_Stop_IT(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
   2190          {
   \                     HAL_TIM_OnePulse_Stop_IT: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   2191            /* Disable the TIM Capture/Compare 1 interrupt */
   2192            __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);  
   \   00000006   0x6820             LDR      R0,[R4, #+0]
   \   00000008   0x68C0             LDR      R0,[R0, #+12]
   \   0000000A   0xF030 0x0002      BICS     R0,R0,#0x2
   \   0000000E   0x6821             LDR      R1,[R4, #+0]
   \   00000010   0x60C8             STR      R0,[R1, #+12]
   2193            
   2194            /* Disable the TIM Capture/Compare 2 interrupt */
   2195            __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
   \   00000012   0x6820             LDR      R0,[R4, #+0]
   \   00000014   0x68C0             LDR      R0,[R0, #+12]
   \   00000016   0xF030 0x0004      BICS     R0,R0,#0x4
   \   0000001A   0x6821             LDR      R1,[R4, #+0]
   \   0000001C   0x60C8             STR      R0,[R1, #+12]
   2196            
   2197            /* Disable the Capture compare and the Input Capture channels 
   2198            (in the OPM Mode the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2)
   2199            if TIM_CHANNEL_1 is used as output, the TIM_CHANNEL_2 will be used as input and
   2200            if TIM_CHANNEL_1 is used as input, the TIM_CHANNEL_2 will be used as output 
   2201            in all combinations, the TIM_CHANNEL_1 and TIM_CHANNEL_2 should be disabled together */  
   2202            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE); 
   \   0000001E   0x2200             MOVS     R2,#+0
   \   00000020   0x2100             MOVS     R1,#+0
   \   00000022   0x6820             LDR      R0,[R4, #+0]
   \   00000024   0x.... 0x....      BL       TIM_CCxChannelCmd
   2203            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE); 
   \   00000028   0x2200             MOVS     R2,#+0
   \   0000002A   0x2104             MOVS     R1,#+4
   \   0000002C   0x6820             LDR      R0,[R4, #+0]
   \   0000002E   0x.... 0x....      BL       TIM_CCxChannelCmd
   2204              
   2205            if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
   \   00000032   0x6820             LDR      R0,[R4, #+0]
   \   00000034   0x.... 0x....      LDR.W    R1,??DataTable21  ;; 0x40010000
   \   00000038   0x4288             CMP      R0,R1
   \   0000003A   0xD004             BEQ.N    ??HAL_TIM_OnePulse_Stop_IT_0
   \   0000003C   0x6820             LDR      R0,[R4, #+0]
   \   0000003E   0x.... 0x....      LDR.W    R1,??DataTable21_1  ;; 0x40010400
   \   00000042   0x4288             CMP      R0,R1
   \   00000044   0xD101             BNE.N    ??HAL_TIM_OnePulse_Stop_IT_1
   \                     ??HAL_TIM_OnePulse_Stop_IT_0: (+1)
   \   00000046   0x2001             MOVS     R0,#+1
   \   00000048   0xE000             B.N      ??HAL_TIM_OnePulse_Stop_IT_2
   \                     ??HAL_TIM_OnePulse_Stop_IT_1: (+1)
   \   0000004A   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_OnePulse_Stop_IT_2: (+1)
   \   0000004C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000004E   0x2800             CMP      R0,#+0
   \   00000050   0xD011             BEQ.N    ??HAL_TIM_OnePulse_Stop_IT_3
   2206            {
   2207              /* Disable the Main Output */
   2208              __HAL_TIM_MOE_DISABLE(htim);
   \   00000052   0x6820             LDR      R0,[R4, #+0]
   \   00000054   0x6A00             LDR      R0,[R0, #+32]
   \   00000056   0xF241 0x1111      MOVW     R1,#+4369
   \   0000005A   0x4208             TST      R0,R1
   \   0000005C   0xD10B             BNE.N    ??HAL_TIM_OnePulse_Stop_IT_4
   \   0000005E   0x6820             LDR      R0,[R4, #+0]
   \   00000060   0x6A00             LDR      R0,[R0, #+32]
   \   00000062   0xF240 0x4144      MOVW     R1,#+1092
   \   00000066   0x4208             TST      R0,R1
   \   00000068   0xD105             BNE.N    ??HAL_TIM_OnePulse_Stop_IT_4
   \   0000006A   0x6820             LDR      R0,[R4, #+0]
   \   0000006C   0x6C40             LDR      R0,[R0, #+68]
   \   0000006E   0xF430 0x4000      BICS     R0,R0,#0x8000
   \   00000072   0x6821             LDR      R1,[R4, #+0]
   \   00000074   0x6448             STR      R0,[R1, #+68]
   2209            }
   2210              
   2211            /* Disable the Peripheral */
   2212             __HAL_TIM_DISABLE(htim);  
   \                     ??HAL_TIM_OnePulse_Stop_IT_4: (+1)
   \                     ??HAL_TIM_OnePulse_Stop_IT_3: (+1)
   \   00000076   0x6820             LDR      R0,[R4, #+0]
   \   00000078   0x6A00             LDR      R0,[R0, #+32]
   \   0000007A   0xF241 0x1111      MOVW     R1,#+4369
   \   0000007E   0x4208             TST      R0,R1
   \   00000080   0xD10B             BNE.N    ??HAL_TIM_OnePulse_Stop_IT_5
   \   00000082   0x6820             LDR      R0,[R4, #+0]
   \   00000084   0x6A00             LDR      R0,[R0, #+32]
   \   00000086   0xF240 0x4144      MOVW     R1,#+1092
   \   0000008A   0x4208             TST      R0,R1
   \   0000008C   0xD105             BNE.N    ??HAL_TIM_OnePulse_Stop_IT_5
   \   0000008E   0x6820             LDR      R0,[R4, #+0]
   \   00000090   0x6800             LDR      R0,[R0, #+0]
   \   00000092   0x0840             LSRS     R0,R0,#+1
   \   00000094   0x0040             LSLS     R0,R0,#+1
   \   00000096   0x6821             LDR      R1,[R4, #+0]
   \   00000098   0x6008             STR      R0,[R1, #+0]
   2213            
   2214            /* Return function status */
   2215            return HAL_OK;
   \                     ??HAL_TIM_OnePulse_Stop_IT_5: (+1)
   \   0000009A   0x2000             MOVS     R0,#+0
   \   0000009C   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   2216          }
   2217          
   2218          /**
   2219            * @}
   2220            */
   2221          
   2222          /** @defgroup TIM_Exported_Functions_Group6 Time Encoder functions 
   2223           *  @brief    Time Encoder functions 
   2224           *
   2225          @verbatim    
   2226            ==============================================================================
   2227                                    ##### Time Encoder functions #####
   2228            ==============================================================================
   2229            [..]
   2230              This section provides functions allowing to:
   2231              (+) Initialize and configure the TIM Encoder. 
   2232              (+) De-initialize the TIM Encoder.
   2233              (+) Start the Time Encoder.
   2234              (+) Stop the Time Encoder.
   2235              (+) Start the Time Encoder and enable interrupt.
   2236              (+) Stop the Time Encoder and disable interrupt.
   2237              (+) Start the Time Encoder and enable DMA transfer.
   2238              (+) Stop the Time Encoder and disable DMA transfer.
   2239           
   2240          @endverbatim
   2241            * @{
   2242            */
   2243          /**
   2244            * @brief  Initializes the TIM Encoder Interface and create the associated handle.
   2245            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   2246            *                the configuration information for TIM module.
   2247            * @param  sConfig: TIM Encoder Interface configuration structure
   2248            * @retval HAL status
   2249            */

   \                                 In section .text, align 2, keep-with-next
   2250          HAL_StatusTypeDef HAL_TIM_Encoder_Init(TIM_HandleTypeDef *htim,  TIM_Encoder_InitTypeDef* sConfig)
   2251          {
   \                     HAL_TIM_Encoder_Init: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   2252            uint32_t tmpsmcr = 0;
   \   00000008   0x2600             MOVS     R6,#+0
   2253            uint32_t tmpccmr1 = 0;
   \   0000000A   0x2700             MOVS     R7,#+0
   2254            uint32_t tmpccer = 0;
   \   0000000C   0xF05F 0x0800      MOVS     R8,#+0
   2255            
   2256            /* Check the TIM handle allocation */
   2257            if(htim == NULL)
   \   00000010   0x2C00             CMP      R4,#+0
   \   00000012   0xD101             BNE.N    ??HAL_TIM_Encoder_Init_0
   2258            {
   2259              return HAL_ERROR;
   \   00000014   0x2001             MOVS     R0,#+1
   \   00000016   0xE050             B.N      ??HAL_TIM_Encoder_Init_1
   2260            }
   2261             
   2262            /* Check the parameters */
   2263            assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   2264            assert_param(IS_TIM_ENCODER_MODE(sConfig->EncoderMode));
   2265            assert_param(IS_TIM_IC_SELECTION(sConfig->IC1Selection));
   2266            assert_param(IS_TIM_IC_SELECTION(sConfig->IC2Selection));
   2267            assert_param(IS_TIM_IC_POLARITY(sConfig->IC1Polarity));
   2268            assert_param(IS_TIM_IC_POLARITY(sConfig->IC2Polarity));
   2269            assert_param(IS_TIM_IC_PRESCALER(sConfig->IC1Prescaler));
   2270            assert_param(IS_TIM_IC_PRESCALER(sConfig->IC2Prescaler));
   2271            assert_param(IS_TIM_IC_FILTER(sConfig->IC1Filter));
   2272            assert_param(IS_TIM_IC_FILTER(sConfig->IC2Filter));
   2273          
   2274            if(htim->State == HAL_TIM_STATE_RESET)
   \                     ??HAL_TIM_Encoder_Init_0: (+1)
   \   00000018   0xF894 0x0039      LDRB     R0,[R4, #+57]
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD105             BNE.N    ??HAL_TIM_Encoder_Init_2
   2275            { 
   2276              /* Allocate lock resource and initialize it */
   2277              htim->Lock = HAL_UNLOCKED;  
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0xF884 0x0038      STRB     R0,[R4, #+56]
   2278              /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
   2279              HAL_TIM_Encoder_MspInit(htim);
   \   00000026   0x0020             MOVS     R0,R4
   \   00000028   0x.... 0x....      BL       HAL_TIM_Encoder_MspInit
   2280            }
   2281            
   2282            /* Set the TIM state */
   2283            htim->State= HAL_TIM_STATE_BUSY;   
   \                     ??HAL_TIM_Encoder_Init_2: (+1)
   \   0000002C   0x2002             MOVS     R0,#+2
   \   0000002E   0xF884 0x0039      STRB     R0,[R4, #+57]
   2284              
   2285            /* Reset the SMS bits */
   2286            htim->Instance->SMCR &= ~TIM_SMCR_SMS;
   \   00000032   0x6820             LDR      R0,[R4, #+0]
   \   00000034   0x6880             LDR      R0,[R0, #+8]
   \   00000036   0x.... 0x....      LDR.W    R1,??DataTable22  ;; 0xfffefff8
   \   0000003A   0x4008             ANDS     R0,R1,R0
   \   0000003C   0x6821             LDR      R1,[R4, #+0]
   \   0000003E   0x6088             STR      R0,[R1, #+8]
   2287            
   2288            /* Configure the Time base in the Encoder Mode */
   2289            TIM_Base_SetConfig(htim->Instance, &htim->Init);  
   \   00000040   0x1D21             ADDS     R1,R4,#+4
   \   00000042   0x6820             LDR      R0,[R4, #+0]
   \   00000044   0x.... 0x....      BL       TIM_Base_SetConfig
   2290            
   2291            /* Get the TIMx SMCR register value */
   2292            tmpsmcr = htim->Instance->SMCR;
   \   00000048   0x6820             LDR      R0,[R4, #+0]
   \   0000004A   0x6880             LDR      R0,[R0, #+8]
   \   0000004C   0x0006             MOVS     R6,R0
   2293          
   2294            /* Get the TIMx CCMR1 register value */
   2295            tmpccmr1 = htim->Instance->CCMR1;
   \   0000004E   0x6820             LDR      R0,[R4, #+0]
   \   00000050   0x6980             LDR      R0,[R0, #+24]
   \   00000052   0x0007             MOVS     R7,R0
   2296          
   2297            /* Get the TIMx CCER register value */
   2298            tmpccer = htim->Instance->CCER;
   \   00000054   0x6820             LDR      R0,[R4, #+0]
   \   00000056   0x6A00             LDR      R0,[R0, #+32]
   \   00000058   0x4680             MOV      R8,R0
   2299          
   2300            /* Set the encoder Mode */
   2301            tmpsmcr |= sConfig->EncoderMode;
   \   0000005A   0x6828             LDR      R0,[R5, #+0]
   \   0000005C   0x4306             ORRS     R6,R0,R6
   2302          
   2303            /* Select the Capture Compare 1 and the Capture Compare 2 as input */
   2304            tmpccmr1 &= ~(TIM_CCMR1_CC1S | TIM_CCMR1_CC2S);
   \   0000005E   0x.... 0x....      LDR.W    R0,??DataTable22_1  ;; 0xfffffcfc
   \   00000062   0x4007             ANDS     R7,R0,R7
   2305            tmpccmr1 |= (sConfig->IC1Selection | (sConfig->IC2Selection << 8));
   \   00000064   0x68A8             LDR      R0,[R5, #+8]
   \   00000066   0x69A9             LDR      R1,[R5, #+24]
   \   00000068   0xEA50 0x2001      ORRS     R0,R0,R1, LSL #+8
   \   0000006C   0x4307             ORRS     R7,R0,R7
   2306            
   2307            /* Set the Capture Compare 1 and the Capture Compare 2 prescalers and filters */
   2308            tmpccmr1 &= ~(TIM_CCMR1_IC1PSC | TIM_CCMR1_IC2PSC);
   \   0000006E   0x.... 0x....      LDR.W    R0,??DataTable22_2  ;; 0xfffff3f3
   \   00000072   0x4007             ANDS     R7,R0,R7
   2309            tmpccmr1 &= ~(TIM_CCMR1_IC1F | TIM_CCMR1_IC2F);
   \   00000074   0x.... 0x....      LDR.W    R0,??DataTable22_3  ;; 0xffff0f0f
   \   00000078   0x4007             ANDS     R7,R0,R7
   2310            tmpccmr1 |= sConfig->IC1Prescaler | (sConfig->IC2Prescaler << 8);
   \   0000007A   0x68E8             LDR      R0,[R5, #+12]
   \   0000007C   0x69E9             LDR      R1,[R5, #+28]
   \   0000007E   0xEA50 0x2001      ORRS     R0,R0,R1, LSL #+8
   \   00000082   0x4307             ORRS     R7,R0,R7
   2311            tmpccmr1 |= (sConfig->IC1Filter << 4) | (sConfig->IC2Filter << 12);
   \   00000084   0x6928             LDR      R0,[R5, #+16]
   \   00000086   0x6A29             LDR      R1,[R5, #+32]
   \   00000088   0x0309             LSLS     R1,R1,#+12
   \   0000008A   0xEA51 0x1000      ORRS     R0,R1,R0, LSL #+4
   \   0000008E   0x4307             ORRS     R7,R0,R7
   2312          
   2313            /* Set the TI1 and the TI2 Polarities */
   2314            tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC2P);
   \   00000090   0xF038 0x0822      BICS     R8,R8,#0x22
   2315            tmpccer &= ~(TIM_CCER_CC1NP | TIM_CCER_CC2NP);
   \   00000094   0xF038 0x0888      BICS     R8,R8,#0x88
   2316            tmpccer |= sConfig->IC1Polarity | (sConfig->IC2Polarity << 4);
   \   00000098   0x6868             LDR      R0,[R5, #+4]
   \   0000009A   0x6969             LDR      R1,[R5, #+20]
   \   0000009C   0xEA50 0x1001      ORRS     R0,R0,R1, LSL #+4
   \   000000A0   0xEA50 0x0808      ORRS     R8,R0,R8
   2317            
   2318            /* Write to TIMx SMCR */
   2319            htim->Instance->SMCR = tmpsmcr;
   \   000000A4   0x6820             LDR      R0,[R4, #+0]
   \   000000A6   0x6086             STR      R6,[R0, #+8]
   2320          
   2321            /* Write to TIMx CCMR1 */
   2322            htim->Instance->CCMR1 = tmpccmr1;
   \   000000A8   0x6820             LDR      R0,[R4, #+0]
   \   000000AA   0x6187             STR      R7,[R0, #+24]
   2323          
   2324            /* Write to TIMx CCER */
   2325            htim->Instance->CCER = tmpccer;
   \   000000AC   0x6820             LDR      R0,[R4, #+0]
   \   000000AE   0xF8C0 0x8020      STR      R8,[R0, #+32]
   2326            
   2327            /* Initialize the TIM state*/
   2328            htim->State= HAL_TIM_STATE_READY;
   \   000000B2   0x2001             MOVS     R0,#+1
   \   000000B4   0xF884 0x0039      STRB     R0,[R4, #+57]
   2329            
   2330            return HAL_OK;
   \   000000B8   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_Encoder_Init_1: (+1)
   \   000000BA   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   2331          }
   2332          
   2333          /**
   2334            * @brief  DeInitializes the TIM Encoder interface  
   2335            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   2336            *                the configuration information for TIM module.
   2337            * @retval HAL status
   2338            */

   \                                 In section .text, align 2, keep-with-next
   2339          HAL_StatusTypeDef HAL_TIM_Encoder_DeInit(TIM_HandleTypeDef *htim)
   2340          {
   \                     HAL_TIM_Encoder_DeInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   2341            /* Check the parameters */
   2342            assert_param(IS_TIM_INSTANCE(htim->Instance));
   2343            
   2344            htim->State = HAL_TIM_STATE_BUSY;
   \   00000004   0x2002             MOVS     R0,#+2
   \   00000006   0xF884 0x0039      STRB     R0,[R4, #+57]
   2345            
   2346            /* Disable the TIM Peripheral Clock */
   2347            __HAL_TIM_DISABLE(htim);
   \   0000000A   0x6820             LDR      R0,[R4, #+0]
   \   0000000C   0x6A00             LDR      R0,[R0, #+32]
   \   0000000E   0xF241 0x1111      MOVW     R1,#+4369
   \   00000012   0x4208             TST      R0,R1
   \   00000014   0xD10B             BNE.N    ??HAL_TIM_Encoder_DeInit_0
   \   00000016   0x6820             LDR      R0,[R4, #+0]
   \   00000018   0x6A00             LDR      R0,[R0, #+32]
   \   0000001A   0xF240 0x4144      MOVW     R1,#+1092
   \   0000001E   0x4208             TST      R0,R1
   \   00000020   0xD105             BNE.N    ??HAL_TIM_Encoder_DeInit_0
   \   00000022   0x6820             LDR      R0,[R4, #+0]
   \   00000024   0x6800             LDR      R0,[R0, #+0]
   \   00000026   0x0840             LSRS     R0,R0,#+1
   \   00000028   0x0040             LSLS     R0,R0,#+1
   \   0000002A   0x6821             LDR      R1,[R4, #+0]
   \   0000002C   0x6008             STR      R0,[R1, #+0]
   2348            
   2349            /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
   2350            HAL_TIM_Encoder_MspDeInit(htim);
   \                     ??HAL_TIM_Encoder_DeInit_0: (+1)
   \   0000002E   0x0020             MOVS     R0,R4
   \   00000030   0x.... 0x....      BL       HAL_TIM_Encoder_MspDeInit
   2351              
   2352            /* Change TIM state */  
   2353            htim->State = HAL_TIM_STATE_RESET;
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0xF884 0x0039      STRB     R0,[R4, #+57]
   2354           
   2355            /* Release Lock */
   2356            __HAL_UNLOCK(htim);
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0xF884 0x0038      STRB     R0,[R4, #+56]
   2357          
   2358            return HAL_OK;
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0xBD10             POP      {R4,PC}          ;; return
   2359          }
   2360          
   2361          /**
   2362            * @brief  Initializes the TIM Encoder Interface MSP.
   2363            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   2364            *                the configuration information for TIM module.
   2365            * @retval None
   2366            */

   \                                 In section .text, align 2, keep-with-next
   2367          __weak void HAL_TIM_Encoder_MspInit(TIM_HandleTypeDef *htim)
   2368          {
   2369            /* NOTE : This function Should not be modified, when the callback is needed,
   2370                      the HAL_TIM_Encoder_MspInit could be implemented in the user file
   2371             */
   2372          }
   \                     HAL_TIM_Encoder_MspInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   2373          
   2374          /**
   2375            * @brief  DeInitializes TIM Encoder Interface MSP.
   2376            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   2377            *                the configuration information for TIM module.
   2378            * @retval None
   2379            */

   \                                 In section .text, align 2, keep-with-next
   2380          __weak void HAL_TIM_Encoder_MspDeInit(TIM_HandleTypeDef *htim)
   2381          {
   2382            /* NOTE : This function Should not be modified, when the callback is needed,
   2383                      the HAL_TIM_Encoder_MspDeInit could be implemented in the user file
   2384             */
   2385          }
   \                     HAL_TIM_Encoder_MspDeInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   2386          
   2387          /**
   2388            * @brief  Starts the TIM Encoder Interface.
   2389            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   2390            *                the configuration information for TIM module.
   2391            * @param  Channel: TIM Channels to be enabled.
   2392            *          This parameter can be one of the following values:
   2393            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2394            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2395            *            @arg TIM_CHANNEL_ALL: TIM Channel 1 and TIM Channel 2 are selected
   2396            * @retval HAL status
   2397            */

   \                                 In section .text, align 2, keep-with-next
   2398          HAL_StatusTypeDef HAL_TIM_Encoder_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
   2399          {
   \                     HAL_TIM_Encoder_Start: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   2400            /* Check the parameters */
   2401            assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   2402            
   2403            /* Enable the encoder interface channels */
   2404            switch (Channel)
   \   00000006   0x0028             MOVS     R0,R5
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD002             BEQ.N    ??HAL_TIM_Encoder_Start_0
   \   0000000C   0x2804             CMP      R0,#+4
   \   0000000E   0xD006             BEQ.N    ??HAL_TIM_Encoder_Start_1
   \   00000010   0xE00B             B.N      ??HAL_TIM_Encoder_Start_2
   2405            {
   2406              case TIM_CHANNEL_1:
   2407              {
   2408                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
   \                     ??HAL_TIM_Encoder_Start_0: (+1)
   \   00000012   0x2201             MOVS     R2,#+1
   \   00000014   0x2100             MOVS     R1,#+0
   \   00000016   0x6820             LDR      R0,[R4, #+0]
   \   00000018   0x.... 0x....      BL       TIM_CCxChannelCmd
   2409                break; 
   \   0000001C   0xE00F             B.N      ??HAL_TIM_Encoder_Start_3
   2410              }
   2411              case TIM_CHANNEL_2:
   2412              { 
   2413                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE); 
   \                     ??HAL_TIM_Encoder_Start_1: (+1)
   \   0000001E   0x2201             MOVS     R2,#+1
   \   00000020   0x2104             MOVS     R1,#+4
   \   00000022   0x6820             LDR      R0,[R4, #+0]
   \   00000024   0x.... 0x....      BL       TIM_CCxChannelCmd
   2414                break;
   \   00000028   0xE009             B.N      ??HAL_TIM_Encoder_Start_3
   2415              }  
   2416              default :
   2417              {
   2418               TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
   \                     ??HAL_TIM_Encoder_Start_2: (+1)
   \   0000002A   0x2201             MOVS     R2,#+1
   \   0000002C   0x2100             MOVS     R1,#+0
   \   0000002E   0x6820             LDR      R0,[R4, #+0]
   \   00000030   0x.... 0x....      BL       TIM_CCxChannelCmd
   2419               TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
   \   00000034   0x2201             MOVS     R2,#+1
   \   00000036   0x2104             MOVS     R1,#+4
   \   00000038   0x6820             LDR      R0,[R4, #+0]
   \   0000003A   0x.... 0x....      BL       TIM_CCxChannelCmd
   2420               break; 
   2421              }
   2422            }  
   2423            /* Enable the Peripheral */
   2424            __HAL_TIM_ENABLE(htim);
   \                     ??HAL_TIM_Encoder_Start_3: (+1)
   \   0000003E   0x6820             LDR      R0,[R4, #+0]
   \   00000040   0x6800             LDR      R0,[R0, #+0]
   \   00000042   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000046   0x6821             LDR      R1,[R4, #+0]
   \   00000048   0x6008             STR      R0,[R1, #+0]
   2425            
   2426            /* Return function status */
   2427            return HAL_OK;
   \   0000004A   0x2000             MOVS     R0,#+0
   \   0000004C   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   2428          }
   2429          
   2430          /**
   2431            * @brief  Stops the TIM Encoder Interface.
   2432            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   2433            *                the configuration information for TIM module.
   2434            * @param  Channel: TIM Channels to be disabled.
   2435            *          This parameter can be one of the following values:
   2436            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2437            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2438            *            @arg TIM_CHANNEL_ALL: TIM Channel 1 and TIM Channel 2 are selected
   2439            * @retval HAL status
   2440            */

   \                                 In section .text, align 2, keep-with-next
   2441          HAL_StatusTypeDef HAL_TIM_Encoder_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
   2442          {
   \                     HAL_TIM_Encoder_Stop: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   2443            /* Check the parameters */
   2444              assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   2445              
   2446             /* Disable the Input Capture channels 1 and 2
   2447              (in the EncoderInterface the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2) */ 
   2448            switch (Channel)
   \   00000006   0x0028             MOVS     R0,R5
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD002             BEQ.N    ??HAL_TIM_Encoder_Stop_0
   \   0000000C   0x2804             CMP      R0,#+4
   \   0000000E   0xD006             BEQ.N    ??HAL_TIM_Encoder_Stop_1
   \   00000010   0xE00B             B.N      ??HAL_TIM_Encoder_Stop_2
   2449            {
   2450              case TIM_CHANNEL_1:
   2451              {
   2452                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
   \                     ??HAL_TIM_Encoder_Stop_0: (+1)
   \   00000012   0x2200             MOVS     R2,#+0
   \   00000014   0x2100             MOVS     R1,#+0
   \   00000016   0x6820             LDR      R0,[R4, #+0]
   \   00000018   0x.... 0x....      BL       TIM_CCxChannelCmd
   2453                break; 
   \   0000001C   0xE00F             B.N      ??HAL_TIM_Encoder_Stop_3
   2454              }
   2455              case TIM_CHANNEL_2:
   2456              { 
   2457                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE); 
   \                     ??HAL_TIM_Encoder_Stop_1: (+1)
   \   0000001E   0x2200             MOVS     R2,#+0
   \   00000020   0x2104             MOVS     R1,#+4
   \   00000022   0x6820             LDR      R0,[R4, #+0]
   \   00000024   0x.... 0x....      BL       TIM_CCxChannelCmd
   2458                break;
   \   00000028   0xE009             B.N      ??HAL_TIM_Encoder_Stop_3
   2459              }  
   2460              default :
   2461              {
   2462               TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
   \                     ??HAL_TIM_Encoder_Stop_2: (+1)
   \   0000002A   0x2200             MOVS     R2,#+0
   \   0000002C   0x2100             MOVS     R1,#+0
   \   0000002E   0x6820             LDR      R0,[R4, #+0]
   \   00000030   0x.... 0x....      BL       TIM_CCxChannelCmd
   2463               TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
   \   00000034   0x2200             MOVS     R2,#+0
   \   00000036   0x2104             MOVS     R1,#+4
   \   00000038   0x6820             LDR      R0,[R4, #+0]
   \   0000003A   0x.... 0x....      BL       TIM_CCxChannelCmd
   2464               break; 
   2465              }
   2466            }  
   2467            /* Disable the Peripheral */
   2468            __HAL_TIM_DISABLE(htim);
   \                     ??HAL_TIM_Encoder_Stop_3: (+1)
   \   0000003E   0x6820             LDR      R0,[R4, #+0]
   \   00000040   0x6A00             LDR      R0,[R0, #+32]
   \   00000042   0xF241 0x1111      MOVW     R1,#+4369
   \   00000046   0x4208             TST      R0,R1
   \   00000048   0xD10B             BNE.N    ??HAL_TIM_Encoder_Stop_4
   \   0000004A   0x6820             LDR      R0,[R4, #+0]
   \   0000004C   0x6A00             LDR      R0,[R0, #+32]
   \   0000004E   0xF240 0x4144      MOVW     R1,#+1092
   \   00000052   0x4208             TST      R0,R1
   \   00000054   0xD105             BNE.N    ??HAL_TIM_Encoder_Stop_4
   \   00000056   0x6820             LDR      R0,[R4, #+0]
   \   00000058   0x6800             LDR      R0,[R0, #+0]
   \   0000005A   0x0840             LSRS     R0,R0,#+1
   \   0000005C   0x0040             LSLS     R0,R0,#+1
   \   0000005E   0x6821             LDR      R1,[R4, #+0]
   \   00000060   0x6008             STR      R0,[R1, #+0]
   2469            
   2470            /* Return function status */
   2471            return HAL_OK;
   \                     ??HAL_TIM_Encoder_Stop_4: (+1)
   \   00000062   0x2000             MOVS     R0,#+0
   \   00000064   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   2472          }
   2473          
   2474          /**
   2475            * @brief  Starts the TIM Encoder Interface in interrupt mode.
   2476            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   2477            *                the configuration information for TIM module.
   2478            * @param  Channel: TIM Channels to be enabled.
   2479            *          This parameter can be one of the following values:
   2480            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2481            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2482            *            @arg TIM_CHANNEL_ALL: TIM Channel 1 and TIM Channel 2 are selected
   2483            * @retval HAL status
   2484            */

   \                                 In section .text, align 2, keep-with-next
   2485          HAL_StatusTypeDef HAL_TIM_Encoder_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
   2486          {
   \                     HAL_TIM_Encoder_Start_IT: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   2487            /* Check the parameters */
   2488            assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   2489            
   2490            /* Enable the encoder interface channels */
   2491            /* Enable the capture compare Interrupts 1 and/or 2 */
   2492            switch (Channel)
   \   00000006   0x0028             MOVS     R0,R5
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD002             BEQ.N    ??HAL_TIM_Encoder_Start_IT_0
   \   0000000C   0x2804             CMP      R0,#+4
   \   0000000E   0xD00C             BEQ.N    ??HAL_TIM_Encoder_Start_IT_1
   \   00000010   0xE017             B.N      ??HAL_TIM_Encoder_Start_IT_2
   2493            {
   2494              case TIM_CHANNEL_1:
   2495              {
   2496                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
   \                     ??HAL_TIM_Encoder_Start_IT_0: (+1)
   \   00000012   0x2201             MOVS     R2,#+1
   \   00000014   0x2100             MOVS     R1,#+0
   \   00000016   0x6820             LDR      R0,[R4, #+0]
   \   00000018   0x.... 0x....      BL       TIM_CCxChannelCmd
   2497                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
   \   0000001C   0x6820             LDR      R0,[R4, #+0]
   \   0000001E   0x68C0             LDR      R0,[R0, #+12]
   \   00000020   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   00000024   0x6821             LDR      R1,[R4, #+0]
   \   00000026   0x60C8             STR      R0,[R1, #+12]
   2498                break; 
   \   00000028   0xE021             B.N      ??HAL_TIM_Encoder_Start_IT_3
   2499              }
   2500              case TIM_CHANNEL_2:
   2501              { 
   2502                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
   \                     ??HAL_TIM_Encoder_Start_IT_1: (+1)
   \   0000002A   0x2201             MOVS     R2,#+1
   \   0000002C   0x2104             MOVS     R1,#+4
   \   0000002E   0x6820             LDR      R0,[R4, #+0]
   \   00000030   0x.... 0x....      BL       TIM_CCxChannelCmd
   2503                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2); 
   \   00000034   0x6820             LDR      R0,[R4, #+0]
   \   00000036   0x68C0             LDR      R0,[R0, #+12]
   \   00000038   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   0000003C   0x6821             LDR      R1,[R4, #+0]
   \   0000003E   0x60C8             STR      R0,[R1, #+12]
   2504                break;
   \   00000040   0xE015             B.N      ??HAL_TIM_Encoder_Start_IT_3
   2505              }  
   2506              default :
   2507              {
   2508               TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
   \                     ??HAL_TIM_Encoder_Start_IT_2: (+1)
   \   00000042   0x2201             MOVS     R2,#+1
   \   00000044   0x2100             MOVS     R1,#+0
   \   00000046   0x6820             LDR      R0,[R4, #+0]
   \   00000048   0x.... 0x....      BL       TIM_CCxChannelCmd
   2509               TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
   \   0000004C   0x2201             MOVS     R2,#+1
   \   0000004E   0x2104             MOVS     R1,#+4
   \   00000050   0x6820             LDR      R0,[R4, #+0]
   \   00000052   0x.... 0x....      BL       TIM_CCxChannelCmd
   2510               __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
   \   00000056   0x6820             LDR      R0,[R4, #+0]
   \   00000058   0x68C0             LDR      R0,[R0, #+12]
   \   0000005A   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   0000005E   0x6821             LDR      R1,[R4, #+0]
   \   00000060   0x60C8             STR      R0,[R1, #+12]
   2511               __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
   \   00000062   0x6820             LDR      R0,[R4, #+0]
   \   00000064   0x68C0             LDR      R0,[R0, #+12]
   \   00000066   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   0000006A   0x6821             LDR      R1,[R4, #+0]
   \   0000006C   0x60C8             STR      R0,[R1, #+12]
   2512               break; 
   2513              }
   2514            }
   2515            
   2516            /* Enable the Peripheral */
   2517            __HAL_TIM_ENABLE(htim);
   \                     ??HAL_TIM_Encoder_Start_IT_3: (+1)
   \   0000006E   0x6820             LDR      R0,[R4, #+0]
   \   00000070   0x6800             LDR      R0,[R0, #+0]
   \   00000072   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000076   0x6821             LDR      R1,[R4, #+0]
   \   00000078   0x6008             STR      R0,[R1, #+0]
   2518            
   2519            /* Return function status */
   2520            return HAL_OK;
   \   0000007A   0x2000             MOVS     R0,#+0
   \   0000007C   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   2521          }
   2522          
   2523          /**
   2524            * @brief  Stops the TIM Encoder Interface in interrupt mode.
   2525            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   2526            *                the configuration information for TIM module.
   2527            * @param  Channel: TIM Channels to be disabled.
   2528            *          This parameter can be one of the following values:
   2529            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2530            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2531            *            @arg TIM_CHANNEL_ALL: TIM Channel 1 and TIM Channel 2 are selected
   2532            * @retval HAL status
   2533            */

   \                                 In section .text, align 2, keep-with-next
   2534          HAL_StatusTypeDef HAL_TIM_Encoder_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
   2535          {
   \                     HAL_TIM_Encoder_Stop_IT: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   2536            /* Check the parameters */
   2537            assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   2538              
   2539            /* Disable the Input Capture channels 1 and 2
   2540              (in the EncoderInterface the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2) */ 
   2541            if(Channel == TIM_CHANNEL_1)
   \   00000006   0x2D00             CMP      R5,#+0
   \   00000008   0xD10B             BNE.N    ??HAL_TIM_Encoder_Stop_IT_0
   2542            {
   2543              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE); 
   \   0000000A   0x2200             MOVS     R2,#+0
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0x6820             LDR      R0,[R4, #+0]
   \   00000010   0x.... 0x....      BL       TIM_CCxChannelCmd
   2544              
   2545              /* Disable the capture compare Interrupts 1 */
   2546            __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
   \   00000014   0x6820             LDR      R0,[R4, #+0]
   \   00000016   0x68C0             LDR      R0,[R0, #+12]
   \   00000018   0xF030 0x0002      BICS     R0,R0,#0x2
   \   0000001C   0x6821             LDR      R1,[R4, #+0]
   \   0000001E   0x60C8             STR      R0,[R1, #+12]
   \   00000020   0xE023             B.N      ??HAL_TIM_Encoder_Stop_IT_1
   2547            }  
   2548            else if(Channel == TIM_CHANNEL_2)
   \                     ??HAL_TIM_Encoder_Stop_IT_0: (+1)
   \   00000022   0x2D04             CMP      R5,#+4
   \   00000024   0xD10B             BNE.N    ??HAL_TIM_Encoder_Stop_IT_2
   2549            {  
   2550              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE); 
   \   00000026   0x2200             MOVS     R2,#+0
   \   00000028   0x2104             MOVS     R1,#+4
   \   0000002A   0x6820             LDR      R0,[R4, #+0]
   \   0000002C   0x.... 0x....      BL       TIM_CCxChannelCmd
   2551              
   2552              /* Disable the capture compare Interrupts 2 */
   2553            __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
   \   00000030   0x6820             LDR      R0,[R4, #+0]
   \   00000032   0x68C0             LDR      R0,[R0, #+12]
   \   00000034   0xF030 0x0004      BICS     R0,R0,#0x4
   \   00000038   0x6821             LDR      R1,[R4, #+0]
   \   0000003A   0x60C8             STR      R0,[R1, #+12]
   \   0000003C   0xE015             B.N      ??HAL_TIM_Encoder_Stop_IT_1
   2554            }  
   2555            else
   2556            {
   2557              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE); 
   \                     ??HAL_TIM_Encoder_Stop_IT_2: (+1)
   \   0000003E   0x2200             MOVS     R2,#+0
   \   00000040   0x2100             MOVS     R1,#+0
   \   00000042   0x6820             LDR      R0,[R4, #+0]
   \   00000044   0x.... 0x....      BL       TIM_CCxChannelCmd
   2558              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE); 
   \   00000048   0x2200             MOVS     R2,#+0
   \   0000004A   0x2104             MOVS     R1,#+4
   \   0000004C   0x6820             LDR      R0,[R4, #+0]
   \   0000004E   0x.... 0x....      BL       TIM_CCxChannelCmd
   2559              
   2560              /* Disable the capture compare Interrupts 1 and 2 */
   2561              __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
   \   00000052   0x6820             LDR      R0,[R4, #+0]
   \   00000054   0x68C0             LDR      R0,[R0, #+12]
   \   00000056   0xF030 0x0002      BICS     R0,R0,#0x2
   \   0000005A   0x6821             LDR      R1,[R4, #+0]
   \   0000005C   0x60C8             STR      R0,[R1, #+12]
   2562              __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
   \   0000005E   0x6820             LDR      R0,[R4, #+0]
   \   00000060   0x68C0             LDR      R0,[R0, #+12]
   \   00000062   0xF030 0x0004      BICS     R0,R0,#0x4
   \   00000066   0x6821             LDR      R1,[R4, #+0]
   \   00000068   0x60C8             STR      R0,[R1, #+12]
   2563            }
   2564              
   2565            /* Disable the Peripheral */
   2566            __HAL_TIM_DISABLE(htim);
   \                     ??HAL_TIM_Encoder_Stop_IT_1: (+1)
   \   0000006A   0x6820             LDR      R0,[R4, #+0]
   \   0000006C   0x6A00             LDR      R0,[R0, #+32]
   \   0000006E   0xF241 0x1111      MOVW     R1,#+4369
   \   00000072   0x4208             TST      R0,R1
   \   00000074   0xD10B             BNE.N    ??HAL_TIM_Encoder_Stop_IT_3
   \   00000076   0x6820             LDR      R0,[R4, #+0]
   \   00000078   0x6A00             LDR      R0,[R0, #+32]
   \   0000007A   0xF240 0x4144      MOVW     R1,#+1092
   \   0000007E   0x4208             TST      R0,R1
   \   00000080   0xD105             BNE.N    ??HAL_TIM_Encoder_Stop_IT_3
   \   00000082   0x6820             LDR      R0,[R4, #+0]
   \   00000084   0x6800             LDR      R0,[R0, #+0]
   \   00000086   0x0840             LSRS     R0,R0,#+1
   \   00000088   0x0040             LSLS     R0,R0,#+1
   \   0000008A   0x6821             LDR      R1,[R4, #+0]
   \   0000008C   0x6008             STR      R0,[R1, #+0]
   2567            
   2568            /* Change the htim state */
   2569            htim->State = HAL_TIM_STATE_READY;
   \                     ??HAL_TIM_Encoder_Stop_IT_3: (+1)
   \   0000008E   0x2001             MOVS     R0,#+1
   \   00000090   0xF884 0x0039      STRB     R0,[R4, #+57]
   2570            
   2571            /* Return function status */
   2572            return HAL_OK;
   \   00000094   0x2000             MOVS     R0,#+0
   \   00000096   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   2573          }
   2574          
   2575          /**
   2576            * @brief  Starts the TIM Encoder Interface in DMA mode.
   2577            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   2578            *                the configuration information for TIM module.
   2579            * @param  Channel: TIM Channels to be enabled.
   2580            *          This parameter can be one of the following values:
   2581            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2582            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2583            *            @arg TIM_CHANNEL_ALL: TIM Channel 1 and TIM Channel 2 are selected
   2584            * @param  pData1: The destination Buffer address for IC1.
   2585            * @param  pData2: The destination Buffer address for IC2.
   2586            * @param  Length: The length of data to be transferred from TIM peripheral to memory.
   2587            * @retval HAL status
   2588            */

   \                                 In section .text, align 2, keep-with-next
   2589          HAL_StatusTypeDef HAL_TIM_Encoder_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData1, uint32_t *pData2, uint16_t Length)
   2590          {
   \                     HAL_TIM_Encoder_Start_DMA: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0005             MOVS     R5,R0
   \   00000006   0x4688             MOV      R8,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
   \   0000000C   0x9C06             LDR      R4,[SP, #+24]
   2591            /* Check the parameters */
   2592            assert_param(IS_TIM_DMA_CC_INSTANCE(htim->Instance));
   2593            
   2594            if((htim->State == HAL_TIM_STATE_BUSY))
   \   0000000E   0xF895 0x0039      LDRB     R0,[R5, #+57]
   \   00000012   0x2802             CMP      R0,#+2
   \   00000014   0xD101             BNE.N    ??HAL_TIM_Encoder_Start_DMA_0
   2595            {
   2596               return HAL_BUSY;
   \   00000016   0x2002             MOVS     R0,#+2
   \   00000018   0xE09D             B.N      ??HAL_TIM_Encoder_Start_DMA_1
   2597            }
   2598            else if((htim->State == HAL_TIM_STATE_READY))
   \                     ??HAL_TIM_Encoder_Start_DMA_0: (+1)
   \   0000001A   0xF895 0x0039      LDRB     R0,[R5, #+57]
   \   0000001E   0x2801             CMP      R0,#+1
   \   00000020   0xD10B             BNE.N    ??HAL_TIM_Encoder_Start_DMA_2
   2599            {
   2600              if((((pData1 == 0) || (pData2 == 0) )) && (Length > 0)) 
   \   00000022   0x2E00             CMP      R6,#+0
   \   00000024   0xD001             BEQ.N    ??HAL_TIM_Encoder_Start_DMA_3
   \   00000026   0x2F00             CMP      R7,#+0
   \   00000028   0xD104             BNE.N    ??HAL_TIM_Encoder_Start_DMA_4
   \                     ??HAL_TIM_Encoder_Start_DMA_3: (+1)
   \   0000002A   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   0000002C   0x2C00             CMP      R4,#+0
   \   0000002E   0xD001             BEQ.N    ??HAL_TIM_Encoder_Start_DMA_4
   2601              {
   2602                return HAL_ERROR;                                    
   \   00000030   0x2001             MOVS     R0,#+1
   \   00000032   0xE090             B.N      ??HAL_TIM_Encoder_Start_DMA_1
   2603              }
   2604              else
   2605              {
   2606                htim->State = HAL_TIM_STATE_BUSY;
   \                     ??HAL_TIM_Encoder_Start_DMA_4: (+1)
   \   00000034   0x2002             MOVS     R0,#+2
   \   00000036   0xF885 0x0039      STRB     R0,[R5, #+57]
   2607              }
   2608            }  
   2609             
   2610            switch (Channel)
   \                     ??HAL_TIM_Encoder_Start_DMA_2: (+1)
   \   0000003A   0x4640             MOV      R0,R8
   \   0000003C   0x2800             CMP      R0,#+0
   \   0000003E   0xD004             BEQ.N    ??HAL_TIM_Encoder_Start_DMA_5
   \   00000040   0x2804             CMP      R0,#+4
   \   00000042   0xD025             BEQ.N    ??HAL_TIM_Encoder_Start_DMA_6
   \   00000044   0x283C             CMP      R0,#+60
   \   00000046   0xD046             BEQ.N    ??HAL_TIM_Encoder_Start_DMA_7
   \   00000048   0xE084             B.N      ??HAL_TIM_Encoder_Start_DMA_8
   2611            {
   2612              case TIM_CHANNEL_1:
   2613              {
   2614                /* Set the DMA Period elapsed callback */
   2615                htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = HAL_TIM_DMACaptureCplt;
   \                     ??HAL_TIM_Encoder_Start_DMA_5: (+1)
   \   0000004A   0x.... 0x....      LDR.W    R0,??DataTable20
   \   0000004E   0x6A29             LDR      R1,[R5, #+32]
   \   00000050   0x63C8             STR      R0,[R1, #+60]
   2616               
   2617                /* Set the DMA error callback */
   2618                htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = HAL_TIM_DMAError ;
   \   00000052   0x.... 0x....      LDR.W    R0,??DataTable23
   \   00000056   0x6A29             LDR      R1,[R5, #+32]
   \   00000058   0x6488             STR      R0,[R1, #+72]
   2619                
   2620                /* Enable the DMA Stream */
   2621                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->CCR1, (uint32_t )pData1, Length); 
   \   0000005A   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   0000005C   0x0023             MOVS     R3,R4
   \   0000005E   0x0032             MOVS     R2,R6
   \   00000060   0x6828             LDR      R0,[R5, #+0]
   \   00000062   0xF110 0x0134      ADDS     R1,R0,#+52
   \   00000066   0x6A28             LDR      R0,[R5, #+32]
   \   00000068   0x.... 0x....      BL       HAL_DMA_Start_IT
   2622                
   2623                /* Enable the TIM Input Capture DMA request */      
   2624                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
   \   0000006C   0x6828             LDR      R0,[R5, #+0]
   \   0000006E   0x68C0             LDR      R0,[R0, #+12]
   \   00000070   0xF450 0x7000      ORRS     R0,R0,#0x200
   \   00000074   0x6829             LDR      R1,[R5, #+0]
   \   00000076   0x60C8             STR      R0,[R1, #+12]
   2625                      
   2626                /* Enable the Peripheral */
   2627                __HAL_TIM_ENABLE(htim);
   \   00000078   0x6828             LDR      R0,[R5, #+0]
   \   0000007A   0x6800             LDR      R0,[R0, #+0]
   \   0000007C   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000080   0x6829             LDR      R1,[R5, #+0]
   \   00000082   0x6008             STR      R0,[R1, #+0]
   2628                
   2629                /* Enable the Capture compare channel */
   2630                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
   \   00000084   0x2201             MOVS     R2,#+1
   \   00000086   0x2100             MOVS     R1,#+0
   \   00000088   0x6828             LDR      R0,[R5, #+0]
   \   0000008A   0x.... 0x....      BL       TIM_CCxChannelCmd
   2631              }
   2632              break;
   \   0000008E   0xE061             B.N      ??HAL_TIM_Encoder_Start_DMA_9
   2633              
   2634              case TIM_CHANNEL_2:
   2635              {
   2636                /* Set the DMA Period elapsed callback */
   2637                htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = HAL_TIM_DMACaptureCplt;
   \                     ??HAL_TIM_Encoder_Start_DMA_6: (+1)
   \   00000090   0x.... 0x....      LDR.W    R0,??DataTable20
   \   00000094   0x6A69             LDR      R1,[R5, #+36]
   \   00000096   0x63C8             STR      R0,[R1, #+60]
   2638               
   2639                /* Set the DMA error callback */
   2640                htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = HAL_TIM_DMAError;
   \   00000098   0x.... 0x....      LDR.W    R0,??DataTable23
   \   0000009C   0x6A69             LDR      R1,[R5, #+36]
   \   0000009E   0x6488             STR      R0,[R1, #+72]
   2641                /* Enable the DMA Stream */
   2642                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->CCR2, (uint32_t)pData2, Length);
   \   000000A0   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   000000A2   0x0023             MOVS     R3,R4
   \   000000A4   0x003A             MOVS     R2,R7
   \   000000A6   0x6828             LDR      R0,[R5, #+0]
   \   000000A8   0xF110 0x0138      ADDS     R1,R0,#+56
   \   000000AC   0x6A68             LDR      R0,[R5, #+36]
   \   000000AE   0x.... 0x....      BL       HAL_DMA_Start_IT
   2643                
   2644                /* Enable the TIM Input Capture  DMA request */
   2645                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
   \   000000B2   0x6828             LDR      R0,[R5, #+0]
   \   000000B4   0x68C0             LDR      R0,[R0, #+12]
   \   000000B6   0xF450 0x6080      ORRS     R0,R0,#0x400
   \   000000BA   0x6829             LDR      R1,[R5, #+0]
   \   000000BC   0x60C8             STR      R0,[R1, #+12]
   2646               
   2647                /* Enable the Peripheral */
   2648                __HAL_TIM_ENABLE(htim);
   \   000000BE   0x6828             LDR      R0,[R5, #+0]
   \   000000C0   0x6800             LDR      R0,[R0, #+0]
   \   000000C2   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   000000C6   0x6829             LDR      R1,[R5, #+0]
   \   000000C8   0x6008             STR      R0,[R1, #+0]
   2649                
   2650                /* Enable the Capture compare channel */
   2651                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
   \   000000CA   0x2201             MOVS     R2,#+1
   \   000000CC   0x2104             MOVS     R1,#+4
   \   000000CE   0x6828             LDR      R0,[R5, #+0]
   \   000000D0   0x.... 0x....      BL       TIM_CCxChannelCmd
   2652              }
   2653              break;
   \   000000D4   0xE03E             B.N      ??HAL_TIM_Encoder_Start_DMA_9
   2654              
   2655              case TIM_CHANNEL_ALL:
   2656              {
   2657                /* Set the DMA Period elapsed callback */
   2658                htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = HAL_TIM_DMACaptureCplt;
   \                     ??HAL_TIM_Encoder_Start_DMA_7: (+1)
   \   000000D6   0x.... 0x....      LDR.W    R0,??DataTable20
   \   000000DA   0x6A29             LDR      R1,[R5, #+32]
   \   000000DC   0x63C8             STR      R0,[R1, #+60]
   2659               
   2660                /* Set the DMA error callback */
   2661                htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = HAL_TIM_DMAError ;
   \   000000DE   0x.... 0x....      LDR.W    R0,??DataTable23
   \   000000E2   0x6A29             LDR      R1,[R5, #+32]
   \   000000E4   0x6488             STR      R0,[R1, #+72]
   2662                
   2663                /* Enable the DMA Stream */
   2664                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->CCR1, (uint32_t)pData1, Length);
   \   000000E6   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   000000E8   0x0023             MOVS     R3,R4
   \   000000EA   0x0032             MOVS     R2,R6
   \   000000EC   0x6828             LDR      R0,[R5, #+0]
   \   000000EE   0xF110 0x0134      ADDS     R1,R0,#+52
   \   000000F2   0x6A28             LDR      R0,[R5, #+32]
   \   000000F4   0x.... 0x....      BL       HAL_DMA_Start_IT
   2665                
   2666                /* Set the DMA Period elapsed callback */
   2667                htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = HAL_TIM_DMACaptureCplt;
   \   000000F8   0x.... 0x....      LDR.W    R0,??DataTable20
   \   000000FC   0x6A69             LDR      R1,[R5, #+36]
   \   000000FE   0x63C8             STR      R0,[R1, #+60]
   2668               
   2669                /* Set the DMA error callback */
   2670                htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = HAL_TIM_DMAError ;
   \   00000100   0x.... 0x....      LDR.W    R0,??DataTable23
   \   00000104   0x6A69             LDR      R1,[R5, #+36]
   \   00000106   0x6488             STR      R0,[R1, #+72]
   2671                
   2672                /* Enable the DMA Stream */
   2673                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->CCR2, (uint32_t)pData2, Length);
   \   00000108   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   0000010A   0x0023             MOVS     R3,R4
   \   0000010C   0x003A             MOVS     R2,R7
   \   0000010E   0x6828             LDR      R0,[R5, #+0]
   \   00000110   0xF110 0x0138      ADDS     R1,R0,#+56
   \   00000114   0x6A68             LDR      R0,[R5, #+36]
   \   00000116   0x.... 0x....      BL       HAL_DMA_Start_IT
   2674                    
   2675               /* Enable the Peripheral */
   2676                __HAL_TIM_ENABLE(htim);
   \   0000011A   0x6828             LDR      R0,[R5, #+0]
   \   0000011C   0x6800             LDR      R0,[R0, #+0]
   \   0000011E   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000122   0x6829             LDR      R1,[R5, #+0]
   \   00000124   0x6008             STR      R0,[R1, #+0]
   2677                
   2678                /* Enable the Capture compare channel */
   2679                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
   \   00000126   0x2201             MOVS     R2,#+1
   \   00000128   0x2100             MOVS     R1,#+0
   \   0000012A   0x6828             LDR      R0,[R5, #+0]
   \   0000012C   0x.... 0x....      BL       TIM_CCxChannelCmd
   2680                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
   \   00000130   0x2201             MOVS     R2,#+1
   \   00000132   0x2104             MOVS     R1,#+4
   \   00000134   0x6828             LDR      R0,[R5, #+0]
   \   00000136   0x.... 0x....      BL       TIM_CCxChannelCmd
   2681                
   2682                /* Enable the TIM Input Capture  DMA request */
   2683                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
   \   0000013A   0x6828             LDR      R0,[R5, #+0]
   \   0000013C   0x68C0             LDR      R0,[R0, #+12]
   \   0000013E   0xF450 0x7000      ORRS     R0,R0,#0x200
   \   00000142   0x6829             LDR      R1,[R5, #+0]
   \   00000144   0x60C8             STR      R0,[R1, #+12]
   2684                /* Enable the TIM Input Capture  DMA request */
   2685                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
   \   00000146   0x6828             LDR      R0,[R5, #+0]
   \   00000148   0x68C0             LDR      R0,[R0, #+12]
   \   0000014A   0xF450 0x6080      ORRS     R0,R0,#0x400
   \   0000014E   0x6829             LDR      R1,[R5, #+0]
   \   00000150   0x60C8             STR      R0,[R1, #+12]
   2686              }
   2687              break;
   \   00000152   0xE7FF             B.N      ??HAL_TIM_Encoder_Start_DMA_9
   2688              
   2689              default:
   2690              break;
   2691            }  
   2692            /* Return function status */
   2693            return HAL_OK;
   \                     ??HAL_TIM_Encoder_Start_DMA_8: (+1)
   \                     ??HAL_TIM_Encoder_Start_DMA_9: (+1)
   \   00000154   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_Encoder_Start_DMA_1: (+1)
   \   00000156   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   2694          }
   2695          
   2696          /**
   2697            * @brief  Stops the TIM Encoder Interface in DMA mode.
   2698            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   2699            *                the configuration information for TIM module.
   2700            * @param  Channel: TIM Channels to be enabled.
   2701            *          This parameter can be one of the following values:
   2702            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2703            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2704            *            @arg TIM_CHANNEL_ALL: TIM Channel 1 and TIM Channel 2 are selected
   2705            * @retval HAL status
   2706            */

   \                                 In section .text, align 2, keep-with-next
   2707          HAL_StatusTypeDef HAL_TIM_Encoder_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
   2708          {
   \                     HAL_TIM_Encoder_Stop_DMA: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   2709            /* Check the parameters */
   2710            assert_param(IS_TIM_DMA_CC_INSTANCE(htim->Instance));
   2711            
   2712            /* Disable the Input Capture channels 1 and 2
   2713              (in the EncoderInterface the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2) */ 
   2714            if(Channel == TIM_CHANNEL_1)
   \   00000006   0x2D00             CMP      R5,#+0
   \   00000008   0xD10B             BNE.N    ??HAL_TIM_Encoder_Stop_DMA_0
   2715            {
   2716              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE); 
   \   0000000A   0x2200             MOVS     R2,#+0
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0x6820             LDR      R0,[R4, #+0]
   \   00000010   0x.... 0x....      BL       TIM_CCxChannelCmd
   2717              
   2718              /* Disable the capture compare DMA Request 1 */
   2719              __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
   \   00000014   0x6820             LDR      R0,[R4, #+0]
   \   00000016   0x68C0             LDR      R0,[R0, #+12]
   \   00000018   0xF430 0x7000      BICS     R0,R0,#0x200
   \   0000001C   0x6821             LDR      R1,[R4, #+0]
   \   0000001E   0x60C8             STR      R0,[R1, #+12]
   \   00000020   0xE023             B.N      ??HAL_TIM_Encoder_Stop_DMA_1
   2720            }  
   2721            else if(Channel == TIM_CHANNEL_2)
   \                     ??HAL_TIM_Encoder_Stop_DMA_0: (+1)
   \   00000022   0x2D04             CMP      R5,#+4
   \   00000024   0xD10B             BNE.N    ??HAL_TIM_Encoder_Stop_DMA_2
   2722            {  
   2723              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE); 
   \   00000026   0x2200             MOVS     R2,#+0
   \   00000028   0x2104             MOVS     R1,#+4
   \   0000002A   0x6820             LDR      R0,[R4, #+0]
   \   0000002C   0x.... 0x....      BL       TIM_CCxChannelCmd
   2724              
   2725              /* Disable the capture compare DMA Request 2 */
   2726              __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
   \   00000030   0x6820             LDR      R0,[R4, #+0]
   \   00000032   0x68C0             LDR      R0,[R0, #+12]
   \   00000034   0xF430 0x6080      BICS     R0,R0,#0x400
   \   00000038   0x6821             LDR      R1,[R4, #+0]
   \   0000003A   0x60C8             STR      R0,[R1, #+12]
   \   0000003C   0xE015             B.N      ??HAL_TIM_Encoder_Stop_DMA_1
   2727            }  
   2728            else
   2729            {
   2730              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE); 
   \                     ??HAL_TIM_Encoder_Stop_DMA_2: (+1)
   \   0000003E   0x2200             MOVS     R2,#+0
   \   00000040   0x2100             MOVS     R1,#+0
   \   00000042   0x6820             LDR      R0,[R4, #+0]
   \   00000044   0x.... 0x....      BL       TIM_CCxChannelCmd
   2731              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE); 
   \   00000048   0x2200             MOVS     R2,#+0
   \   0000004A   0x2104             MOVS     R1,#+4
   \   0000004C   0x6820             LDR      R0,[R4, #+0]
   \   0000004E   0x.... 0x....      BL       TIM_CCxChannelCmd
   2732              
   2733              /* Disable the capture compare DMA Request 1 and 2 */
   2734              __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
   \   00000052   0x6820             LDR      R0,[R4, #+0]
   \   00000054   0x68C0             LDR      R0,[R0, #+12]
   \   00000056   0xF430 0x7000      BICS     R0,R0,#0x200
   \   0000005A   0x6821             LDR      R1,[R4, #+0]
   \   0000005C   0x60C8             STR      R0,[R1, #+12]
   2735              __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
   \   0000005E   0x6820             LDR      R0,[R4, #+0]
   \   00000060   0x68C0             LDR      R0,[R0, #+12]
   \   00000062   0xF430 0x6080      BICS     R0,R0,#0x400
   \   00000066   0x6821             LDR      R1,[R4, #+0]
   \   00000068   0x60C8             STR      R0,[R1, #+12]
   2736            }
   2737            
   2738            /* Disable the Peripheral */
   2739            __HAL_TIM_DISABLE(htim);
   \                     ??HAL_TIM_Encoder_Stop_DMA_1: (+1)
   \   0000006A   0x6820             LDR      R0,[R4, #+0]
   \   0000006C   0x6A00             LDR      R0,[R0, #+32]
   \   0000006E   0xF241 0x1111      MOVW     R1,#+4369
   \   00000072   0x4208             TST      R0,R1
   \   00000074   0xD10B             BNE.N    ??HAL_TIM_Encoder_Stop_DMA_3
   \   00000076   0x6820             LDR      R0,[R4, #+0]
   \   00000078   0x6A00             LDR      R0,[R0, #+32]
   \   0000007A   0xF240 0x4144      MOVW     R1,#+1092
   \   0000007E   0x4208             TST      R0,R1
   \   00000080   0xD105             BNE.N    ??HAL_TIM_Encoder_Stop_DMA_3
   \   00000082   0x6820             LDR      R0,[R4, #+0]
   \   00000084   0x6800             LDR      R0,[R0, #+0]
   \   00000086   0x0840             LSRS     R0,R0,#+1
   \   00000088   0x0040             LSLS     R0,R0,#+1
   \   0000008A   0x6821             LDR      R1,[R4, #+0]
   \   0000008C   0x6008             STR      R0,[R1, #+0]
   2740            
   2741            /* Change the htim state */
   2742            htim->State = HAL_TIM_STATE_READY;
   \                     ??HAL_TIM_Encoder_Stop_DMA_3: (+1)
   \   0000008E   0x2001             MOVS     R0,#+1
   \   00000090   0xF884 0x0039      STRB     R0,[R4, #+57]
   2743            
   2744            /* Return function status */
   2745            return HAL_OK;
   \   00000094   0x2000             MOVS     R0,#+0
   \   00000096   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   2746          }
   2747          
   2748          /**
   2749            * @}
   2750            */
   2751          /** @defgroup TIM_Exported_Functions_Group7 TIM IRQ handler management 
   2752           *  @brief    IRQ handler management 
   2753           *
   2754          @verbatim   
   2755            ==============================================================================
   2756                                  ##### IRQ handler management #####
   2757            ==============================================================================  
   2758            [..]  
   2759              This section provides Timer IRQ handler function.
   2760                         
   2761          @endverbatim
   2762            * @{
   2763            */
   2764          /**
   2765            * @brief  This function handles TIM interrupts requests.
   2766            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   2767            *                the configuration information for TIM module.
   2768            * @retval None
   2769            */

   \                                 In section .text, align 2, keep-with-next
   2770          void HAL_TIM_IRQHandler(TIM_HandleTypeDef *htim)
   2771          {
   \                     HAL_TIM_IRQHandler: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   2772            /* Capture compare 1 event */
   2773            if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC1) != RESET)
   \   00000004   0x6820             LDR      R0,[R4, #+0]
   \   00000006   0x6900             LDR      R0,[R0, #+16]
   \   00000008   0x0780             LSLS     R0,R0,#+30
   \   0000000A   0xD51A             BPL.N    ??HAL_TIM_IRQHandler_0
   2774            {
   2775              if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC1) !=RESET)
   \   0000000C   0x6820             LDR      R0,[R4, #+0]
   \   0000000E   0x68C0             LDR      R0,[R0, #+12]
   \   00000010   0x0780             LSLS     R0,R0,#+30
   \   00000012   0xD516             BPL.N    ??HAL_TIM_IRQHandler_0
   2776              {
   2777                {
   2778                  __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC1);
   \   00000014   0xF07F 0x0002      MVNS     R0,#+2
   \   00000018   0x6821             LDR      R1,[R4, #+0]
   \   0000001A   0x6108             STR      R0,[R1, #+16]
   2779                  htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
   \   0000001C   0x2001             MOVS     R0,#+1
   \   0000001E   0x7620             STRB     R0,[R4, #+24]
   2780                  
   2781                  /* Input capture event */
   2782                  if((htim->Instance->CCMR1 & TIM_CCMR1_CC1S) != 0x00)
   \   00000020   0x6820             LDR      R0,[R4, #+0]
   \   00000022   0x6980             LDR      R0,[R0, #+24]
   \   00000024   0xF010 0x0F03      TST      R0,#0x3
   \   00000028   0xD003             BEQ.N    ??HAL_TIM_IRQHandler_1
   2783                  {
   2784                    HAL_TIM_IC_CaptureCallback(htim);
   \   0000002A   0x0020             MOVS     R0,R4
   \   0000002C   0x.... 0x....      BL       HAL_TIM_IC_CaptureCallback
   \   00000030   0xE005             B.N      ??HAL_TIM_IRQHandler_2
   2785                  }
   2786                  /* Output compare event */
   2787                  else
   2788                  {
   2789                    HAL_TIM_OC_DelayElapsedCallback(htim);
   \                     ??HAL_TIM_IRQHandler_1: (+1)
   \   00000032   0x0020             MOVS     R0,R4
   \   00000034   0x.... 0x....      BL       HAL_TIM_OC_DelayElapsedCallback
   2790                    HAL_TIM_PWM_PulseFinishedCallback(htim);
   \   00000038   0x0020             MOVS     R0,R4
   \   0000003A   0x.... 0x....      BL       HAL_TIM_PWM_PulseFinishedCallback
   2791                  }
   2792                  htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
   \                     ??HAL_TIM_IRQHandler_2: (+1)
   \   0000003E   0x2000             MOVS     R0,#+0
   \   00000040   0x7620             STRB     R0,[R4, #+24]
   2793                }
   2794              }
   2795            }
   2796            /* Capture compare 2 event */
   2797            if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC2) != RESET)
   \                     ??HAL_TIM_IRQHandler_0: (+1)
   \   00000042   0x6820             LDR      R0,[R4, #+0]
   \   00000044   0x6900             LDR      R0,[R0, #+16]
   \   00000046   0x0740             LSLS     R0,R0,#+29
   \   00000048   0xD51A             BPL.N    ??HAL_TIM_IRQHandler_3
   2798            {
   2799              if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC2) !=RESET)
   \   0000004A   0x6820             LDR      R0,[R4, #+0]
   \   0000004C   0x68C0             LDR      R0,[R0, #+12]
   \   0000004E   0x0740             LSLS     R0,R0,#+29
   \   00000050   0xD516             BPL.N    ??HAL_TIM_IRQHandler_3
   2800              {
   2801                __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC2);
   \   00000052   0xF07F 0x0004      MVNS     R0,#+4
   \   00000056   0x6821             LDR      R1,[R4, #+0]
   \   00000058   0x6108             STR      R0,[R1, #+16]
   2802                htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
   \   0000005A   0x2002             MOVS     R0,#+2
   \   0000005C   0x7620             STRB     R0,[R4, #+24]
   2803                /* Input capture event */
   2804                if((htim->Instance->CCMR1 & TIM_CCMR1_CC2S) != 0x00)
   \   0000005E   0x6820             LDR      R0,[R4, #+0]
   \   00000060   0x6980             LDR      R0,[R0, #+24]
   \   00000062   0xF410 0x7F40      TST      R0,#0x300
   \   00000066   0xD003             BEQ.N    ??HAL_TIM_IRQHandler_4
   2805                {          
   2806                  HAL_TIM_IC_CaptureCallback(htim);
   \   00000068   0x0020             MOVS     R0,R4
   \   0000006A   0x.... 0x....      BL       HAL_TIM_IC_CaptureCallback
   \   0000006E   0xE005             B.N      ??HAL_TIM_IRQHandler_5
   2807                }
   2808                /* Output compare event */
   2809                else
   2810                {
   2811                  HAL_TIM_OC_DelayElapsedCallback(htim);
   \                     ??HAL_TIM_IRQHandler_4: (+1)
   \   00000070   0x0020             MOVS     R0,R4
   \   00000072   0x.... 0x....      BL       HAL_TIM_OC_DelayElapsedCallback
   2812                  HAL_TIM_PWM_PulseFinishedCallback(htim);
   \   00000076   0x0020             MOVS     R0,R4
   \   00000078   0x.... 0x....      BL       HAL_TIM_PWM_PulseFinishedCallback
   2813                }
   2814                htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
   \                     ??HAL_TIM_IRQHandler_5: (+1)
   \   0000007C   0x2000             MOVS     R0,#+0
   \   0000007E   0x7620             STRB     R0,[R4, #+24]
   2815              }
   2816            }
   2817            /* Capture compare 3 event */
   2818            if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC3) != RESET)
   \                     ??HAL_TIM_IRQHandler_3: (+1)
   \   00000080   0x6820             LDR      R0,[R4, #+0]
   \   00000082   0x6900             LDR      R0,[R0, #+16]
   \   00000084   0x0700             LSLS     R0,R0,#+28
   \   00000086   0xD51A             BPL.N    ??HAL_TIM_IRQHandler_6
   2819            {
   2820              if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC3) !=RESET)
   \   00000088   0x6820             LDR      R0,[R4, #+0]
   \   0000008A   0x68C0             LDR      R0,[R0, #+12]
   \   0000008C   0x0700             LSLS     R0,R0,#+28
   \   0000008E   0xD516             BPL.N    ??HAL_TIM_IRQHandler_6
   2821              {
   2822                __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC3);
   \   00000090   0xF07F 0x0008      MVNS     R0,#+8
   \   00000094   0x6821             LDR      R1,[R4, #+0]
   \   00000096   0x6108             STR      R0,[R1, #+16]
   2823                htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
   \   00000098   0x2004             MOVS     R0,#+4
   \   0000009A   0x7620             STRB     R0,[R4, #+24]
   2824                /* Input capture event */
   2825                if((htim->Instance->CCMR2 & TIM_CCMR2_CC3S) != 0x00)
   \   0000009C   0x6820             LDR      R0,[R4, #+0]
   \   0000009E   0x69C0             LDR      R0,[R0, #+28]
   \   000000A0   0xF010 0x0F03      TST      R0,#0x3
   \   000000A4   0xD003             BEQ.N    ??HAL_TIM_IRQHandler_7
   2826                {          
   2827                  HAL_TIM_IC_CaptureCallback(htim);
   \   000000A6   0x0020             MOVS     R0,R4
   \   000000A8   0x.... 0x....      BL       HAL_TIM_IC_CaptureCallback
   \   000000AC   0xE005             B.N      ??HAL_TIM_IRQHandler_8
   2828                }
   2829                /* Output compare event */
   2830                else
   2831                {
   2832                  HAL_TIM_OC_DelayElapsedCallback(htim);
   \                     ??HAL_TIM_IRQHandler_7: (+1)
   \   000000AE   0x0020             MOVS     R0,R4
   \   000000B0   0x.... 0x....      BL       HAL_TIM_OC_DelayElapsedCallback
   2833                  HAL_TIM_PWM_PulseFinishedCallback(htim); 
   \   000000B4   0x0020             MOVS     R0,R4
   \   000000B6   0x.... 0x....      BL       HAL_TIM_PWM_PulseFinishedCallback
   2834                }
   2835                htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
   \                     ??HAL_TIM_IRQHandler_8: (+1)
   \   000000BA   0x2000             MOVS     R0,#+0
   \   000000BC   0x7620             STRB     R0,[R4, #+24]
   2836              }
   2837            }
   2838            /* Capture compare 4 event */
   2839            if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC4) != RESET)
   \                     ??HAL_TIM_IRQHandler_6: (+1)
   \   000000BE   0x6820             LDR      R0,[R4, #+0]
   \   000000C0   0x6900             LDR      R0,[R0, #+16]
   \   000000C2   0x06C0             LSLS     R0,R0,#+27
   \   000000C4   0xD51A             BPL.N    ??HAL_TIM_IRQHandler_9
   2840            {
   2841              if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC4) !=RESET)
   \   000000C6   0x6820             LDR      R0,[R4, #+0]
   \   000000C8   0x68C0             LDR      R0,[R0, #+12]
   \   000000CA   0x06C0             LSLS     R0,R0,#+27
   \   000000CC   0xD516             BPL.N    ??HAL_TIM_IRQHandler_9
   2842              {
   2843                __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC4);
   \   000000CE   0xF07F 0x0010      MVNS     R0,#+16
   \   000000D2   0x6821             LDR      R1,[R4, #+0]
   \   000000D4   0x6108             STR      R0,[R1, #+16]
   2844                htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
   \   000000D6   0x2008             MOVS     R0,#+8
   \   000000D8   0x7620             STRB     R0,[R4, #+24]
   2845                /* Input capture event */
   2846                if((htim->Instance->CCMR2 & TIM_CCMR2_CC4S) != 0x00)
   \   000000DA   0x6820             LDR      R0,[R4, #+0]
   \   000000DC   0x69C0             LDR      R0,[R0, #+28]
   \   000000DE   0xF410 0x7F40      TST      R0,#0x300
   \   000000E2   0xD003             BEQ.N    ??HAL_TIM_IRQHandler_10
   2847                {          
   2848                  HAL_TIM_IC_CaptureCallback(htim);
   \   000000E4   0x0020             MOVS     R0,R4
   \   000000E6   0x.... 0x....      BL       HAL_TIM_IC_CaptureCallback
   \   000000EA   0xE005             B.N      ??HAL_TIM_IRQHandler_11
   2849                }
   2850                /* Output compare event */
   2851                else
   2852                {
   2853                  HAL_TIM_OC_DelayElapsedCallback(htim);
   \                     ??HAL_TIM_IRQHandler_10: (+1)
   \   000000EC   0x0020             MOVS     R0,R4
   \   000000EE   0x.... 0x....      BL       HAL_TIM_OC_DelayElapsedCallback
   2854                  HAL_TIM_PWM_PulseFinishedCallback(htim);
   \   000000F2   0x0020             MOVS     R0,R4
   \   000000F4   0x.... 0x....      BL       HAL_TIM_PWM_PulseFinishedCallback
   2855                }
   2856                htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
   \                     ??HAL_TIM_IRQHandler_11: (+1)
   \   000000F8   0x2000             MOVS     R0,#+0
   \   000000FA   0x7620             STRB     R0,[R4, #+24]
   2857              }
   2858            }
   2859            /* TIM Update event */
   2860            if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_UPDATE) != RESET)
   \                     ??HAL_TIM_IRQHandler_9: (+1)
   \   000000FC   0x6820             LDR      R0,[R4, #+0]
   \   000000FE   0x6900             LDR      R0,[R0, #+16]
   \   00000100   0x07C0             LSLS     R0,R0,#+31
   \   00000102   0xD50A             BPL.N    ??HAL_TIM_IRQHandler_12
   2861            {
   2862              if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_UPDATE) !=RESET)
   \   00000104   0x6820             LDR      R0,[R4, #+0]
   \   00000106   0x68C0             LDR      R0,[R0, #+12]
   \   00000108   0x07C0             LSLS     R0,R0,#+31
   \   0000010A   0xD506             BPL.N    ??HAL_TIM_IRQHandler_12
   2863              {
   2864                __HAL_TIM_CLEAR_IT(htim, TIM_IT_UPDATE);
   \   0000010C   0xF07F 0x0001      MVNS     R0,#+1
   \   00000110   0x6821             LDR      R1,[R4, #+0]
   \   00000112   0x6108             STR      R0,[R1, #+16]
   2865                HAL_TIM_PeriodElapsedCallback(htim);
   \   00000114   0x0020             MOVS     R0,R4
   \   00000116   0x.... 0x....      BL       HAL_TIM_PeriodElapsedCallback
   2866              }
   2867            }
   2868            /* TIM Break input event */
   2869            if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_BREAK) != RESET)
   \                     ??HAL_TIM_IRQHandler_12: (+1)
   \   0000011A   0x6820             LDR      R0,[R4, #+0]
   \   0000011C   0x6900             LDR      R0,[R0, #+16]
   \   0000011E   0x0600             LSLS     R0,R0,#+24
   \   00000120   0xD50A             BPL.N    ??HAL_TIM_IRQHandler_13
   2870            {
   2871              if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_BREAK) !=RESET)
   \   00000122   0x6820             LDR      R0,[R4, #+0]
   \   00000124   0x68C0             LDR      R0,[R0, #+12]
   \   00000126   0x0600             LSLS     R0,R0,#+24
   \   00000128   0xD506             BPL.N    ??HAL_TIM_IRQHandler_13
   2872              {
   2873                __HAL_TIM_CLEAR_IT(htim, TIM_IT_BREAK);
   \   0000012A   0xF07F 0x0080      MVNS     R0,#+128
   \   0000012E   0x6821             LDR      R1,[R4, #+0]
   \   00000130   0x6108             STR      R0,[R1, #+16]
   2874                HAL_TIMEx_BreakCallback(htim);
   \   00000132   0x0020             MOVS     R0,R4
   \   00000134   0x.... 0x....      BL       HAL_TIMEx_BreakCallback
   2875              }
   2876            }
   2877            
   2878              /* TIM Break input event */
   2879            if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_BREAK2) != RESET)
   \                     ??HAL_TIM_IRQHandler_13: (+1)
   \   00000138   0x6820             LDR      R0,[R4, #+0]
   \   0000013A   0x6900             LDR      R0,[R0, #+16]
   \   0000013C   0x05C0             LSLS     R0,R0,#+23
   \   0000013E   0xD50A             BPL.N    ??HAL_TIM_IRQHandler_14
   2880            {
   2881              if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_BREAK) !=RESET)
   \   00000140   0x6820             LDR      R0,[R4, #+0]
   \   00000142   0x68C0             LDR      R0,[R0, #+12]
   \   00000144   0x0600             LSLS     R0,R0,#+24
   \   00000146   0xD506             BPL.N    ??HAL_TIM_IRQHandler_14
   2882              {
   2883                __HAL_TIM_CLEAR_IT(htim, TIM_IT_BREAK);
   \   00000148   0xF07F 0x0080      MVNS     R0,#+128
   \   0000014C   0x6821             LDR      R1,[R4, #+0]
   \   0000014E   0x6108             STR      R0,[R1, #+16]
   2884                HAL_TIMEx_BreakCallback(htim);
   \   00000150   0x0020             MOVS     R0,R4
   \   00000152   0x.... 0x....      BL       HAL_TIMEx_BreakCallback
   2885              }
   2886            }
   2887          
   2888            /* TIM Trigger detection event */
   2889            if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_TRIGGER) != RESET)
   \                     ??HAL_TIM_IRQHandler_14: (+1)
   \   00000156   0x6820             LDR      R0,[R4, #+0]
   \   00000158   0x6900             LDR      R0,[R0, #+16]
   \   0000015A   0x0640             LSLS     R0,R0,#+25
   \   0000015C   0xD50A             BPL.N    ??HAL_TIM_IRQHandler_15
   2890            {
   2891              if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_TRIGGER) !=RESET)
   \   0000015E   0x6820             LDR      R0,[R4, #+0]
   \   00000160   0x68C0             LDR      R0,[R0, #+12]
   \   00000162   0x0640             LSLS     R0,R0,#+25
   \   00000164   0xD506             BPL.N    ??HAL_TIM_IRQHandler_15
   2892              {
   2893                __HAL_TIM_CLEAR_IT(htim, TIM_IT_TRIGGER);
   \   00000166   0xF07F 0x0040      MVNS     R0,#+64
   \   0000016A   0x6821             LDR      R1,[R4, #+0]
   \   0000016C   0x6108             STR      R0,[R1, #+16]
   2894                HAL_TIM_TriggerCallback(htim);
   \   0000016E   0x0020             MOVS     R0,R4
   \   00000170   0x.... 0x....      BL       HAL_TIM_TriggerCallback
   2895              }
   2896            }
   2897            /* TIM commutation event */
   2898            if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_COM) != RESET)
   \                     ??HAL_TIM_IRQHandler_15: (+1)
   \   00000174   0x6820             LDR      R0,[R4, #+0]
   \   00000176   0x6900             LDR      R0,[R0, #+16]
   \   00000178   0x0680             LSLS     R0,R0,#+26
   \   0000017A   0xD50A             BPL.N    ??HAL_TIM_IRQHandler_16
   2899            {
   2900              if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_COM) !=RESET)
   \   0000017C   0x6820             LDR      R0,[R4, #+0]
   \   0000017E   0x68C0             LDR      R0,[R0, #+12]
   \   00000180   0x0680             LSLS     R0,R0,#+26
   \   00000182   0xD506             BPL.N    ??HAL_TIM_IRQHandler_16
   2901              {
   2902                __HAL_TIM_CLEAR_IT(htim, TIM_FLAG_COM);
   \   00000184   0xF07F 0x0020      MVNS     R0,#+32
   \   00000188   0x6821             LDR      R1,[R4, #+0]
   \   0000018A   0x6108             STR      R0,[R1, #+16]
   2903                HAL_TIMEx_CommutationCallback(htim);
   \   0000018C   0x0020             MOVS     R0,R4
   \   0000018E   0x.... 0x....      BL       HAL_TIMEx_CommutationCallback
   2904              }
   2905            }
   2906          }
   \                     ??HAL_TIM_IRQHandler_16: (+1)
   \   00000192   0xBD10             POP      {R4,PC}          ;; return
   2907          
   2908          /**
   2909            * @}
   2910            */
   2911            
   2912          /** @defgroup TIM_Exported_Functions_Group8 Peripheral Control functions
   2913           *  @brief   	Peripheral Control functions 
   2914           *
   2915          @verbatim   
   2916            ==============================================================================
   2917                             ##### Peripheral Control functions #####
   2918            ==============================================================================  
   2919           [..] 
   2920             This section provides functions allowing to:
   2921             (+) Configure The Input Output channels for OC, PWM, IC or One Pulse mode. 
   2922             (+) Configure External Clock source.
   2923             (+) Configure Complementary channels, break features and dead time.
   2924             (+) Configure Master and the Slave synchronization.
   2925             (+) Configure the DMA Burst Mode.
   2926                
   2927          @endverbatim
   2928            * @{
   2929            */
   2930            
   2931          /**
   2932            * @brief  Initializes the TIM Output Compare Channels according to the specified
   2933            *         parameters in the TIM_OC_InitTypeDef.
   2934            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   2935            *                the configuration information for TIM module.
   2936            * @param  sConfig: TIM Output Compare configuration structure
   2937            * @param  Channel: TIM Channels to be enabled.
   2938            *          This parameter can be one of the following values:
   2939            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2940            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2941            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   2942            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected 
   2943            * @retval HAL status
   2944            */

   \                                 In section .text, align 2, keep-with-next
   2945          __weak HAL_StatusTypeDef HAL_TIM_OC_ConfigChannel(TIM_HandleTypeDef *htim, TIM_OC_InitTypeDef* sConfig, uint32_t Channel)
   2946          {
   \                     HAL_TIM_OC_ConfigChannel: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   2947            /* Check the parameters */ 
   2948            assert_param(IS_TIM_CHANNELS(Channel)); 
   2949            assert_param(IS_TIM_OC_MODE(sConfig->OCMode));
   2950            assert_param(IS_TIM_OC_POLARITY(sConfig->OCPolarity));
   2951            assert_param(IS_TIM_OCN_POLARITY(sConfig->OCNPolarity));
   2952            assert_param(IS_TIM_OCNIDLE_STATE(sConfig->OCNIdleState));
   2953            assert_param(IS_TIM_OCIDLE_STATE(sConfig->OCIdleState));
   2954            
   2955            /* Check input state */
   2956            __HAL_LOCK(htim); 
   \   00000008   0xF894 0x0038      LDRB     R0,[R4, #+56]
   \   0000000C   0x2801             CMP      R0,#+1
   \   0000000E   0xD101             BNE.N    ??HAL_TIM_OC_ConfigChannel_0
   \   00000010   0x2002             MOVS     R0,#+2
   \   00000012   0xE02A             B.N      ??HAL_TIM_OC_ConfigChannel_1
   \                     ??HAL_TIM_OC_ConfigChannel_0: (+1)
   \   00000014   0x2001             MOVS     R0,#+1
   \   00000016   0xF884 0x0038      STRB     R0,[R4, #+56]
   2957            
   2958            htim->State = HAL_TIM_STATE_BUSY;
   \   0000001A   0x2002             MOVS     R0,#+2
   \   0000001C   0xF884 0x0039      STRB     R0,[R4, #+57]
   2959            
   2960            switch (Channel)
   \   00000020   0x0030             MOVS     R0,R6
   \   00000022   0x2800             CMP      R0,#+0
   \   00000024   0xD006             BEQ.N    ??HAL_TIM_OC_ConfigChannel_2
   \   00000026   0x2804             CMP      R0,#+4
   \   00000028   0xD009             BEQ.N    ??HAL_TIM_OC_ConfigChannel_3
   \   0000002A   0x2808             CMP      R0,#+8
   \   0000002C   0xD00C             BEQ.N    ??HAL_TIM_OC_ConfigChannel_4
   \   0000002E   0x280C             CMP      R0,#+12
   \   00000030   0xD00F             BEQ.N    ??HAL_TIM_OC_ConfigChannel_5
   \   00000032   0xE013             B.N      ??HAL_TIM_OC_ConfigChannel_6
   2961            {
   2962              case TIM_CHANNEL_1:
   2963              {
   2964                assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   2965                /* Configure the TIM Channel 1 in Output Compare */
   2966                TIM_OC1_SetConfig(htim->Instance, sConfig);
   \                     ??HAL_TIM_OC_ConfigChannel_2: (+1)
   \   00000034   0x0029             MOVS     R1,R5
   \   00000036   0x6820             LDR      R0,[R4, #+0]
   \   00000038   0x.... 0x....      BL       TIM_OC1_SetConfig
   2967              }
   2968              break;
   \   0000003C   0xE00E             B.N      ??HAL_TIM_OC_ConfigChannel_7
   2969              
   2970              case TIM_CHANNEL_2:
   2971              {
   2972                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   2973                /* Configure the TIM Channel 2 in Output Compare */
   2974                TIM_OC2_SetConfig(htim->Instance, sConfig);
   \                     ??HAL_TIM_OC_ConfigChannel_3: (+1)
   \   0000003E   0x0029             MOVS     R1,R5
   \   00000040   0x6820             LDR      R0,[R4, #+0]
   \   00000042   0x.... 0x....      BL       TIM_OC2_SetConfig
   2975              }
   2976              break;
   \   00000046   0xE009             B.N      ??HAL_TIM_OC_ConfigChannel_7
   2977              
   2978              case TIM_CHANNEL_3:
   2979              {
   2980                 assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
   2981                /* Configure the TIM Channel 3 in Output Compare */
   2982                TIM_OC3_SetConfig(htim->Instance, sConfig);
   \                     ??HAL_TIM_OC_ConfigChannel_4: (+1)
   \   00000048   0x0029             MOVS     R1,R5
   \   0000004A   0x6820             LDR      R0,[R4, #+0]
   \   0000004C   0x.... 0x....      BL       TIM_OC3_SetConfig
   2983              }
   2984              break;
   \   00000050   0xE004             B.N      ??HAL_TIM_OC_ConfigChannel_7
   2985              
   2986              case TIM_CHANNEL_4:
   2987              {
   2988                assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
   2989                /* Configure the TIM Channel 4 in Output Compare */
   2990                TIM_OC4_SetConfig(htim->Instance, sConfig);
   \                     ??HAL_TIM_OC_ConfigChannel_5: (+1)
   \   00000052   0x0029             MOVS     R1,R5
   \   00000054   0x6820             LDR      R0,[R4, #+0]
   \   00000056   0x.... 0x....      BL       TIM_OC4_SetConfig
   2991              }
   2992              break;
   \   0000005A   0xE7FF             B.N      ??HAL_TIM_OC_ConfigChannel_7
   2993              
   2994              default:
   2995              break;    
   2996            }
   2997            htim->State = HAL_TIM_STATE_READY;
   \                     ??HAL_TIM_OC_ConfigChannel_6: (+1)
   \                     ??HAL_TIM_OC_ConfigChannel_7: (+1)
   \   0000005C   0x2001             MOVS     R0,#+1
   \   0000005E   0xF884 0x0039      STRB     R0,[R4, #+57]
   2998            
   2999            __HAL_UNLOCK(htim); 
   \   00000062   0x2000             MOVS     R0,#+0
   \   00000064   0xF884 0x0038      STRB     R0,[R4, #+56]
   3000            
   3001            return HAL_OK;
   \   00000068   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_OC_ConfigChannel_1: (+1)
   \   0000006A   0xBD70             POP      {R4-R6,PC}       ;; return
   3002          }
   3003          
   3004          /**
   3005            * @brief  Initializes the TIM Input Capture Channels according to the specified
   3006            *         parameters in the TIM_IC_InitTypeDef.
   3007            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   3008            *                the configuration information for TIM module.
   3009            * @param  sConfig: TIM Input Capture configuration structure
   3010            * @param  Channel: TIM Channels to be enabled.
   3011            *          This parameter can be one of the following values:
   3012            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   3013            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   3014            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   3015            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected 
   3016            * @retval HAL status
   3017            */

   \                                 In section .text, align 2, keep-with-next
   3018          HAL_StatusTypeDef HAL_TIM_IC_ConfigChannel(TIM_HandleTypeDef *htim, TIM_IC_InitTypeDef* sConfig, uint32_t Channel)
   3019          {
   \                     HAL_TIM_IC_ConfigChannel: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   3020            /* Check the parameters */
   3021            assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   3022            assert_param(IS_TIM_IC_POLARITY(sConfig->ICPolarity));
   3023            assert_param(IS_TIM_IC_SELECTION(sConfig->ICSelection));
   3024            assert_param(IS_TIM_IC_PRESCALER(sConfig->ICPrescaler));
   3025            assert_param(IS_TIM_IC_FILTER(sConfig->ICFilter));
   3026            
   3027            __HAL_LOCK(htim);
   \   00000008   0xF894 0x0038      LDRB     R0,[R4, #+56]
   \   0000000C   0x2801             CMP      R0,#+1
   \   0000000E   0xD101             BNE.N    ??HAL_TIM_IC_ConfigChannel_0
   \   00000010   0x2002             MOVS     R0,#+2
   \   00000012   0xE05F             B.N      ??HAL_TIM_IC_ConfigChannel_1
   \                     ??HAL_TIM_IC_ConfigChannel_0: (+1)
   \   00000014   0x2001             MOVS     R0,#+1
   \   00000016   0xF884 0x0038      STRB     R0,[R4, #+56]
   3028            
   3029            htim->State = HAL_TIM_STATE_BUSY;
   \   0000001A   0x2002             MOVS     R0,#+2
   \   0000001C   0xF884 0x0039      STRB     R0,[R4, #+57]
   3030            
   3031            if (Channel == TIM_CHANNEL_1)
   \   00000020   0x2E00             CMP      R6,#+0
   \   00000022   0xD112             BNE.N    ??HAL_TIM_IC_ConfigChannel_2
   3032            {
   3033              /* TI1 Configuration */
   3034              TIM_TI1_SetConfig(htim->Instance,
   3035                         sConfig->ICPolarity,
   3036                         sConfig->ICSelection,
   3037                         sConfig->ICFilter);
   \   00000024   0x68EB             LDR      R3,[R5, #+12]
   \   00000026   0x686A             LDR      R2,[R5, #+4]
   \   00000028   0x6829             LDR      R1,[R5, #+0]
   \   0000002A   0x6820             LDR      R0,[R4, #+0]
   \   0000002C   0x.... 0x....      BL       TIM_TI1_SetConfig
   3038                         
   3039              /* Reset the IC1PSC Bits */
   3040              htim->Instance->CCMR1 &= ~TIM_CCMR1_IC1PSC;
   \   00000030   0x6820             LDR      R0,[R4, #+0]
   \   00000032   0x6980             LDR      R0,[R0, #+24]
   \   00000034   0xF030 0x000C      BICS     R0,R0,#0xC
   \   00000038   0x6821             LDR      R1,[R4, #+0]
   \   0000003A   0x6188             STR      R0,[R1, #+24]
   3041          
   3042              /* Set the IC1PSC value */
   3043              htim->Instance->CCMR1 |= sConfig->ICPrescaler;
   \   0000003C   0x6820             LDR      R0,[R4, #+0]
   \   0000003E   0x6980             LDR      R0,[R0, #+24]
   \   00000040   0x68A9             LDR      R1,[R5, #+8]
   \   00000042   0x4308             ORRS     R0,R1,R0
   \   00000044   0x6821             LDR      R1,[R4, #+0]
   \   00000046   0x6188             STR      R0,[R1, #+24]
   \   00000048   0xE03D             B.N      ??HAL_TIM_IC_ConfigChannel_3
   3044            }
   3045            else if (Channel == TIM_CHANNEL_2)
   \                     ??HAL_TIM_IC_ConfigChannel_2: (+1)
   \   0000004A   0x2E04             CMP      R6,#+4
   \   0000004C   0xD113             BNE.N    ??HAL_TIM_IC_ConfigChannel_4
   3046            {
   3047              /* TI2 Configuration */
   3048              assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   3049              
   3050              TIM_TI2_SetConfig(htim->Instance, 
   3051                                sConfig->ICPolarity,
   3052                                sConfig->ICSelection,
   3053                                sConfig->ICFilter);
   \   0000004E   0x68EB             LDR      R3,[R5, #+12]
   \   00000050   0x686A             LDR      R2,[R5, #+4]
   \   00000052   0x6829             LDR      R1,[R5, #+0]
   \   00000054   0x6820             LDR      R0,[R4, #+0]
   \   00000056   0x.... 0x....      BL       TIM_TI2_SetConfig
   3054                         
   3055              /* Reset the IC2PSC Bits */
   3056              htim->Instance->CCMR1 &= ~TIM_CCMR1_IC2PSC;
   \   0000005A   0x6820             LDR      R0,[R4, #+0]
   \   0000005C   0x6980             LDR      R0,[R0, #+24]
   \   0000005E   0xF430 0x6040      BICS     R0,R0,#0xC00
   \   00000062   0x6821             LDR      R1,[R4, #+0]
   \   00000064   0x6188             STR      R0,[R1, #+24]
   3057          
   3058              /* Set the IC2PSC value */
   3059              htim->Instance->CCMR1 |= (sConfig->ICPrescaler << 8);
   \   00000066   0x6820             LDR      R0,[R4, #+0]
   \   00000068   0x6980             LDR      R0,[R0, #+24]
   \   0000006A   0x68A9             LDR      R1,[R5, #+8]
   \   0000006C   0xEA50 0x2001      ORRS     R0,R0,R1, LSL #+8
   \   00000070   0x6821             LDR      R1,[R4, #+0]
   \   00000072   0x6188             STR      R0,[R1, #+24]
   \   00000074   0xE027             B.N      ??HAL_TIM_IC_ConfigChannel_3
   3060            }
   3061            else if (Channel == TIM_CHANNEL_3)
   \                     ??HAL_TIM_IC_ConfigChannel_4: (+1)
   \   00000076   0x2E08             CMP      R6,#+8
   \   00000078   0xD112             BNE.N    ??HAL_TIM_IC_ConfigChannel_5
   3062            {
   3063              /* TI3 Configuration */
   3064              assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
   3065              
   3066              TIM_TI3_SetConfig(htim->Instance,  
   3067                         sConfig->ICPolarity,
   3068                         sConfig->ICSelection,
   3069                         sConfig->ICFilter);
   \   0000007A   0x68EB             LDR      R3,[R5, #+12]
   \   0000007C   0x686A             LDR      R2,[R5, #+4]
   \   0000007E   0x6829             LDR      R1,[R5, #+0]
   \   00000080   0x6820             LDR      R0,[R4, #+0]
   \   00000082   0x.... 0x....      BL       TIM_TI3_SetConfig
   3070                         
   3071              /* Reset the IC3PSC Bits */
   3072              htim->Instance->CCMR2 &= ~TIM_CCMR2_IC3PSC;
   \   00000086   0x6820             LDR      R0,[R4, #+0]
   \   00000088   0x69C0             LDR      R0,[R0, #+28]
   \   0000008A   0xF030 0x000C      BICS     R0,R0,#0xC
   \   0000008E   0x6821             LDR      R1,[R4, #+0]
   \   00000090   0x61C8             STR      R0,[R1, #+28]
   3073          
   3074              /* Set the IC3PSC value */
   3075              htim->Instance->CCMR2 |= sConfig->ICPrescaler;
   \   00000092   0x6820             LDR      R0,[R4, #+0]
   \   00000094   0x69C0             LDR      R0,[R0, #+28]
   \   00000096   0x68A9             LDR      R1,[R5, #+8]
   \   00000098   0x4308             ORRS     R0,R1,R0
   \   0000009A   0x6821             LDR      R1,[R4, #+0]
   \   0000009C   0x61C8             STR      R0,[R1, #+28]
   \   0000009E   0xE012             B.N      ??HAL_TIM_IC_ConfigChannel_3
   3076            }
   3077            else
   3078            {
   3079              /* TI4 Configuration */
   3080              assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
   3081              
   3082              TIM_TI4_SetConfig(htim->Instance, 
   3083                         sConfig->ICPolarity,
   3084                         sConfig->ICSelection,
   3085                         sConfig->ICFilter);
   \                     ??HAL_TIM_IC_ConfigChannel_5: (+1)
   \   000000A0   0x68EB             LDR      R3,[R5, #+12]
   \   000000A2   0x686A             LDR      R2,[R5, #+4]
   \   000000A4   0x6829             LDR      R1,[R5, #+0]
   \   000000A6   0x6820             LDR      R0,[R4, #+0]
   \   000000A8   0x.... 0x....      BL       TIM_TI4_SetConfig
   3086                         
   3087              /* Reset the IC4PSC Bits */
   3088              htim->Instance->CCMR2 &= ~TIM_CCMR2_IC4PSC;
   \   000000AC   0x6820             LDR      R0,[R4, #+0]
   \   000000AE   0x69C0             LDR      R0,[R0, #+28]
   \   000000B0   0xF430 0x6040      BICS     R0,R0,#0xC00
   \   000000B4   0x6821             LDR      R1,[R4, #+0]
   \   000000B6   0x61C8             STR      R0,[R1, #+28]
   3089          
   3090              /* Set the IC4PSC value */
   3091              htim->Instance->CCMR2 |= (sConfig->ICPrescaler << 8);
   \   000000B8   0x6820             LDR      R0,[R4, #+0]
   \   000000BA   0x69C0             LDR      R0,[R0, #+28]
   \   000000BC   0x68A9             LDR      R1,[R5, #+8]
   \   000000BE   0xEA50 0x2001      ORRS     R0,R0,R1, LSL #+8
   \   000000C2   0x6821             LDR      R1,[R4, #+0]
   \   000000C4   0x61C8             STR      R0,[R1, #+28]
   3092            }
   3093            
   3094            htim->State = HAL_TIM_STATE_READY;
   \                     ??HAL_TIM_IC_ConfigChannel_3: (+1)
   \   000000C6   0x2001             MOVS     R0,#+1
   \   000000C8   0xF884 0x0039      STRB     R0,[R4, #+57]
   3095              
   3096            __HAL_UNLOCK(htim);
   \   000000CC   0x2000             MOVS     R0,#+0
   \   000000CE   0xF884 0x0038      STRB     R0,[R4, #+56]
   3097            
   3098            return HAL_OK; 
   \   000000D2   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_IC_ConfigChannel_1: (+1)
   \   000000D4   0xBD70             POP      {R4-R6,PC}       ;; return
   3099          }
   3100          
   3101          /**
   3102            * @brief  Initializes the TIM PWM  channels according to the specified
   3103            *         parameters in the TIM_OC_InitTypeDef.
   3104            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   3105            *                the configuration information for TIM module.
   3106            * @param  sConfig: TIM PWM configuration structure
   3107            * @param  Channel: TIM Channels to be enabled.
   3108            *          This parameter can be one of the following values:
   3109            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   3110            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   3111            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   3112            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   3113            * @retval HAL status
   3114            */

   \                                 In section .text, align 2, keep-with-next
   3115          __weak HAL_StatusTypeDef HAL_TIM_PWM_ConfigChannel(TIM_HandleTypeDef *htim, TIM_OC_InitTypeDef* sConfig, uint32_t Channel)
   3116          {
   \                     HAL_TIM_PWM_ConfigChannel: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   3117            __HAL_LOCK(htim);
   \   00000008   0xF894 0x0038      LDRB     R0,[R4, #+56]
   \   0000000C   0x2801             CMP      R0,#+1
   \   0000000E   0xD101             BNE.N    ??HAL_TIM_PWM_ConfigChannel_0
   \   00000010   0x2002             MOVS     R0,#+2
   \   00000012   0xE074             B.N      ??HAL_TIM_PWM_ConfigChannel_1
   \                     ??HAL_TIM_PWM_ConfigChannel_0: (+1)
   \   00000014   0x2001             MOVS     R0,#+1
   \   00000016   0xF884 0x0038      STRB     R0,[R4, #+56]
   3118            
   3119            /* Check the parameters */ 
   3120            assert_param(IS_TIM_CHANNELS(Channel)); 
   3121            assert_param(IS_TIM_PWM_MODE(sConfig->OCMode));
   3122            assert_param(IS_TIM_OC_POLARITY(sConfig->OCPolarity));
   3123            assert_param(IS_TIM_OCN_POLARITY(sConfig->OCNPolarity));
   3124            assert_param(IS_TIM_OCNIDLE_STATE(sConfig->OCNIdleState));
   3125            assert_param(IS_TIM_OCIDLE_STATE(sConfig->OCIdleState));
   3126            assert_param(IS_TIM_FAST_STATE(sConfig->OCFastMode)); 
   3127            
   3128            htim->State = HAL_TIM_STATE_BUSY;
   \   0000001A   0x2002             MOVS     R0,#+2
   \   0000001C   0xF884 0x0039      STRB     R0,[R4, #+57]
   3129              
   3130            switch (Channel)
   \   00000020   0x0030             MOVS     R0,R6
   \   00000022   0x2800             CMP      R0,#+0
   \   00000024   0xD006             BEQ.N    ??HAL_TIM_PWM_ConfigChannel_2
   \   00000026   0x2804             CMP      R0,#+4
   \   00000028   0xD01B             BEQ.N    ??HAL_TIM_PWM_ConfigChannel_3
   \   0000002A   0x2808             CMP      R0,#+8
   \   0000002C   0xD031             BEQ.N    ??HAL_TIM_PWM_ConfigChannel_4
   \   0000002E   0x280C             CMP      R0,#+12
   \   00000030   0xD046             BEQ.N    ??HAL_TIM_PWM_ConfigChannel_5
   \   00000032   0xE05D             B.N      ??HAL_TIM_PWM_ConfigChannel_6
   3131            {
   3132              case TIM_CHANNEL_1:
   3133              {
   3134                assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   3135                /* Configure the Channel 1 in PWM mode */
   3136                TIM_OC1_SetConfig(htim->Instance, sConfig);
   \                     ??HAL_TIM_PWM_ConfigChannel_2: (+1)
   \   00000034   0x0029             MOVS     R1,R5
   \   00000036   0x6820             LDR      R0,[R4, #+0]
   \   00000038   0x.... 0x....      BL       TIM_OC1_SetConfig
   3137                
   3138                /* Set the Preload enable bit for channel1 */
   3139                htim->Instance->CCMR1 |= TIM_CCMR1_OC1PE;
   \   0000003C   0x6820             LDR      R0,[R4, #+0]
   \   0000003E   0x6980             LDR      R0,[R0, #+24]
   \   00000040   0xF050 0x0008      ORRS     R0,R0,#0x8
   \   00000044   0x6821             LDR      R1,[R4, #+0]
   \   00000046   0x6188             STR      R0,[R1, #+24]
   3140                
   3141                /* Configure the Output Fast mode */
   3142                htim->Instance->CCMR1 &= ~TIM_CCMR1_OC1FE;
   \   00000048   0x6820             LDR      R0,[R4, #+0]
   \   0000004A   0x6980             LDR      R0,[R0, #+24]
   \   0000004C   0xF030 0x0004      BICS     R0,R0,#0x4
   \   00000050   0x6821             LDR      R1,[R4, #+0]
   \   00000052   0x6188             STR      R0,[R1, #+24]
   3143                htim->Instance->CCMR1 |= sConfig->OCFastMode;
   \   00000054   0x6820             LDR      R0,[R4, #+0]
   \   00000056   0x6980             LDR      R0,[R0, #+24]
   \   00000058   0x6929             LDR      R1,[R5, #+16]
   \   0000005A   0x4308             ORRS     R0,R1,R0
   \   0000005C   0x6821             LDR      R1,[R4, #+0]
   \   0000005E   0x6188             STR      R0,[R1, #+24]
   3144              }
   3145              break;
   \   00000060   0xE046             B.N      ??HAL_TIM_PWM_ConfigChannel_7
   3146              
   3147              case TIM_CHANNEL_2:
   3148              {
   3149                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   3150                /* Configure the Channel 2 in PWM mode */
   3151                TIM_OC2_SetConfig(htim->Instance, sConfig);
   \                     ??HAL_TIM_PWM_ConfigChannel_3: (+1)
   \   00000062   0x0029             MOVS     R1,R5
   \   00000064   0x6820             LDR      R0,[R4, #+0]
   \   00000066   0x.... 0x....      BL       TIM_OC2_SetConfig
   3152                
   3153                /* Set the Preload enable bit for channel2 */
   3154                htim->Instance->CCMR1 |= TIM_CCMR1_OC2PE;
   \   0000006A   0x6820             LDR      R0,[R4, #+0]
   \   0000006C   0x6980             LDR      R0,[R0, #+24]
   \   0000006E   0xF450 0x6000      ORRS     R0,R0,#0x800
   \   00000072   0x6821             LDR      R1,[R4, #+0]
   \   00000074   0x6188             STR      R0,[R1, #+24]
   3155                
   3156                /* Configure the Output Fast mode */
   3157                htim->Instance->CCMR1 &= ~TIM_CCMR1_OC2FE;
   \   00000076   0x6820             LDR      R0,[R4, #+0]
   \   00000078   0x6980             LDR      R0,[R0, #+24]
   \   0000007A   0xF430 0x6080      BICS     R0,R0,#0x400
   \   0000007E   0x6821             LDR      R1,[R4, #+0]
   \   00000080   0x6188             STR      R0,[R1, #+24]
   3158                htim->Instance->CCMR1 |= sConfig->OCFastMode << 8;
   \   00000082   0x6820             LDR      R0,[R4, #+0]
   \   00000084   0x6980             LDR      R0,[R0, #+24]
   \   00000086   0x6929             LDR      R1,[R5, #+16]
   \   00000088   0xEA50 0x2001      ORRS     R0,R0,R1, LSL #+8
   \   0000008C   0x6821             LDR      R1,[R4, #+0]
   \   0000008E   0x6188             STR      R0,[R1, #+24]
   3159              }
   3160              break;
   \   00000090   0xE02E             B.N      ??HAL_TIM_PWM_ConfigChannel_7
   3161              
   3162              case TIM_CHANNEL_3:
   3163              {
   3164                assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
   3165                /* Configure the Channel 3 in PWM mode */
   3166                TIM_OC3_SetConfig(htim->Instance, sConfig);
   \                     ??HAL_TIM_PWM_ConfigChannel_4: (+1)
   \   00000092   0x0029             MOVS     R1,R5
   \   00000094   0x6820             LDR      R0,[R4, #+0]
   \   00000096   0x.... 0x....      BL       TIM_OC3_SetConfig
   3167                
   3168                /* Set the Preload enable bit for channel3 */
   3169                htim->Instance->CCMR2 |= TIM_CCMR2_OC3PE;
   \   0000009A   0x6820             LDR      R0,[R4, #+0]
   \   0000009C   0x69C0             LDR      R0,[R0, #+28]
   \   0000009E   0xF050 0x0008      ORRS     R0,R0,#0x8
   \   000000A2   0x6821             LDR      R1,[R4, #+0]
   \   000000A4   0x61C8             STR      R0,[R1, #+28]
   3170                
   3171               /* Configure the Output Fast mode */
   3172                htim->Instance->CCMR2 &= ~TIM_CCMR2_OC3FE;
   \   000000A6   0x6820             LDR      R0,[R4, #+0]
   \   000000A8   0x69C0             LDR      R0,[R0, #+28]
   \   000000AA   0xF030 0x0004      BICS     R0,R0,#0x4
   \   000000AE   0x6821             LDR      R1,[R4, #+0]
   \   000000B0   0x61C8             STR      R0,[R1, #+28]
   3173                htim->Instance->CCMR2 |= sConfig->OCFastMode;  
   \   000000B2   0x6820             LDR      R0,[R4, #+0]
   \   000000B4   0x69C0             LDR      R0,[R0, #+28]
   \   000000B6   0x6929             LDR      R1,[R5, #+16]
   \   000000B8   0x4308             ORRS     R0,R1,R0
   \   000000BA   0x6821             LDR      R1,[R4, #+0]
   \   000000BC   0x61C8             STR      R0,[R1, #+28]
   3174              }
   3175              break;
   \   000000BE   0xE017             B.N      ??HAL_TIM_PWM_ConfigChannel_7
   3176              
   3177              case TIM_CHANNEL_4:
   3178              {
   3179                assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
   3180                /* Configure the Channel 4 in PWM mode */
   3181                TIM_OC4_SetConfig(htim->Instance, sConfig);
   \                     ??HAL_TIM_PWM_ConfigChannel_5: (+1)
   \   000000C0   0x0029             MOVS     R1,R5
   \   000000C2   0x6820             LDR      R0,[R4, #+0]
   \   000000C4   0x.... 0x....      BL       TIM_OC4_SetConfig
   3182                
   3183                /* Set the Preload enable bit for channel4 */
   3184                htim->Instance->CCMR2 |= TIM_CCMR2_OC4PE;
   \   000000C8   0x6820             LDR      R0,[R4, #+0]
   \   000000CA   0x69C0             LDR      R0,[R0, #+28]
   \   000000CC   0xF450 0x6000      ORRS     R0,R0,#0x800
   \   000000D0   0x6821             LDR      R1,[R4, #+0]
   \   000000D2   0x61C8             STR      R0,[R1, #+28]
   3185                
   3186               /* Configure the Output Fast mode */
   3187                htim->Instance->CCMR2 &= ~TIM_CCMR2_OC4FE;
   \   000000D4   0x6820             LDR      R0,[R4, #+0]
   \   000000D6   0x69C0             LDR      R0,[R0, #+28]
   \   000000D8   0xF430 0x6080      BICS     R0,R0,#0x400
   \   000000DC   0x6821             LDR      R1,[R4, #+0]
   \   000000DE   0x61C8             STR      R0,[R1, #+28]
   3188                htim->Instance->CCMR2 |= sConfig->OCFastMode << 8;  
   \   000000E0   0x6820             LDR      R0,[R4, #+0]
   \   000000E2   0x69C0             LDR      R0,[R0, #+28]
   \   000000E4   0x6929             LDR      R1,[R5, #+16]
   \   000000E6   0xEA50 0x2001      ORRS     R0,R0,R1, LSL #+8
   \   000000EA   0x6821             LDR      R1,[R4, #+0]
   \   000000EC   0x61C8             STR      R0,[R1, #+28]
   3189              }
   3190              break;
   \   000000EE   0xE7FF             B.N      ??HAL_TIM_PWM_ConfigChannel_7
   3191              
   3192              default:
   3193              break;    
   3194            }
   3195            
   3196            htim->State = HAL_TIM_STATE_READY;
   \                     ??HAL_TIM_PWM_ConfigChannel_6: (+1)
   \                     ??HAL_TIM_PWM_ConfigChannel_7: (+1)
   \   000000F0   0x2001             MOVS     R0,#+1
   \   000000F2   0xF884 0x0039      STRB     R0,[R4, #+57]
   3197              
   3198            __HAL_UNLOCK(htim);
   \   000000F6   0x2000             MOVS     R0,#+0
   \   000000F8   0xF884 0x0038      STRB     R0,[R4, #+56]
   3199            
   3200            return HAL_OK;
   \   000000FC   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_PWM_ConfigChannel_1: (+1)
   \   000000FE   0xBD70             POP      {R4-R6,PC}       ;; return
   3201          }
   3202          
   3203          /**
   3204            * @brief  Initializes the TIM One Pulse Channels according to the specified
   3205            *         parameters in the TIM_OnePulse_InitTypeDef.
   3206            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   3207            *                the configuration information for TIM module.
   3208            * @param  sConfig: TIM One Pulse configuration structure
   3209            * @param  OutputChannel: TIM Channels to be enabled.
   3210            *          This parameter can be one of the following values:
   3211            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   3212            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   3213            * @param  InputChannel: TIM Channels to be enabled.
   3214            *          This parameter can be one of the following values:
   3215            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   3216            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   3217            * @retval HAL status
   3218            */

   \                                 In section .text, align 2, keep-with-next
   3219          HAL_StatusTypeDef HAL_TIM_OnePulse_ConfigChannel(TIM_HandleTypeDef *htim,  TIM_OnePulse_InitTypeDef* sConfig, uint32_t OutputChannel,  uint32_t InputChannel)
   3220          {
   \                     HAL_TIM_OnePulse_ConfigChannel: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB087             SUB      SP,SP,#+28
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
   3221            TIM_OC_InitTypeDef temp1;
   3222            
   3223            /* Check the parameters */
   3224            assert_param(IS_TIM_OPM_CHANNELS(OutputChannel));
   3225            assert_param(IS_TIM_OPM_CHANNELS(InputChannel));
   3226          
   3227            if(OutputChannel != InputChannel)  
   \   0000000C   0x42BE             CMP      R6,R7
   \   0000000E   0xF000 0x8082      BEQ.W    ??HAL_TIM_OnePulse_ConfigChannel_0
   3228            {
   3229              __HAL_LOCK(htim);
   \   00000012   0xF894 0x0038      LDRB     R0,[R4, #+56]
   \   00000016   0x2801             CMP      R0,#+1
   \   00000018   0xD101             BNE.N    ??HAL_TIM_OnePulse_ConfigChannel_1
   \   0000001A   0x2002             MOVS     R0,#+2
   \   0000001C   0xE07C             B.N      ??HAL_TIM_OnePulse_ConfigChannel_2
   \                     ??HAL_TIM_OnePulse_ConfigChannel_1: (+1)
   \   0000001E   0x2001             MOVS     R0,#+1
   \   00000020   0xF884 0x0038      STRB     R0,[R4, #+56]
   3230            
   3231              htim->State = HAL_TIM_STATE_BUSY;
   \   00000024   0x2002             MOVS     R0,#+2
   \   00000026   0xF884 0x0039      STRB     R0,[R4, #+57]
   3232          
   3233              /* Extract the Output compare configuration from sConfig structure */  
   3234              temp1.OCMode = sConfig->OCMode;
   \   0000002A   0x6828             LDR      R0,[R5, #+0]
   \   0000002C   0x9000             STR      R0,[SP, #+0]
   3235              temp1.Pulse = sConfig->Pulse;
   \   0000002E   0x6868             LDR      R0,[R5, #+4]
   \   00000030   0x9001             STR      R0,[SP, #+4]
   3236              temp1.OCPolarity = sConfig->OCPolarity;
   \   00000032   0x68A8             LDR      R0,[R5, #+8]
   \   00000034   0x9002             STR      R0,[SP, #+8]
   3237              temp1.OCNPolarity = sConfig->OCNPolarity;
   \   00000036   0x68E8             LDR      R0,[R5, #+12]
   \   00000038   0x9003             STR      R0,[SP, #+12]
   3238              temp1.OCIdleState = sConfig->OCIdleState;
   \   0000003A   0x6928             LDR      R0,[R5, #+16]
   \   0000003C   0x9005             STR      R0,[SP, #+20]
   3239              temp1.OCNIdleState = sConfig->OCNIdleState; 
   \   0000003E   0x6968             LDR      R0,[R5, #+20]
   \   00000040   0x9006             STR      R0,[SP, #+24]
   3240              
   3241              switch (OutputChannel)
   \   00000042   0x0030             MOVS     R0,R6
   \   00000044   0x2800             CMP      R0,#+0
   \   00000046   0xD002             BEQ.N    ??HAL_TIM_OnePulse_ConfigChannel_3
   \   00000048   0x2804             CMP      R0,#+4
   \   0000004A   0xD005             BEQ.N    ??HAL_TIM_OnePulse_ConfigChannel_4
   \   0000004C   0xE009             B.N      ??HAL_TIM_OnePulse_ConfigChannel_5
   3242              {
   3243                case TIM_CHANNEL_1:
   3244                {
   3245                  assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   3246                
   3247                  TIM_OC1_SetConfig(htim->Instance, &temp1); 
   \                     ??HAL_TIM_OnePulse_ConfigChannel_3: (+1)
   \   0000004E   0x4669             MOV      R1,SP
   \   00000050   0x6820             LDR      R0,[R4, #+0]
   \   00000052   0x.... 0x....      BL       TIM_OC1_SetConfig
   3248                }
   3249                break;
   \   00000056   0xE004             B.N      ??HAL_TIM_OnePulse_ConfigChannel_6
   3250                case TIM_CHANNEL_2:
   3251                {
   3252                  assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   3253                
   3254                  TIM_OC2_SetConfig(htim->Instance, &temp1);
   \                     ??HAL_TIM_OnePulse_ConfigChannel_4: (+1)
   \   00000058   0x4669             MOV      R1,SP
   \   0000005A   0x6820             LDR      R0,[R4, #+0]
   \   0000005C   0x.... 0x....      BL       TIM_OC2_SetConfig
   3255                }
   3256                break;
   \   00000060   0xE7FF             B.N      ??HAL_TIM_OnePulse_ConfigChannel_6
   3257                default:
   3258                break;  
   3259              } 
   3260              switch (InputChannel)
   \                     ??HAL_TIM_OnePulse_ConfigChannel_5: (+1)
   \                     ??HAL_TIM_OnePulse_ConfigChannel_6: (+1)
   \   00000062   0x0038             MOVS     R0,R7
   \   00000064   0x2800             CMP      R0,#+0
   \   00000066   0xD002             BEQ.N    ??HAL_TIM_OnePulse_ConfigChannel_7
   \   00000068   0x2804             CMP      R0,#+4
   \   0000006A   0xD026             BEQ.N    ??HAL_TIM_OnePulse_ConfigChannel_8
   \   0000006C   0xE04B             B.N      ??HAL_TIM_OnePulse_ConfigChannel_9
   3261              {
   3262                case TIM_CHANNEL_1:
   3263                {
   3264                  assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   3265                
   3266                  TIM_TI1_SetConfig(htim->Instance, sConfig->ICPolarity,
   3267                                  sConfig->ICSelection, sConfig->ICFilter);
   \                     ??HAL_TIM_OnePulse_ConfigChannel_7: (+1)
   \   0000006E   0x6A2B             LDR      R3,[R5, #+32]
   \   00000070   0x69EA             LDR      R2,[R5, #+28]
   \   00000072   0x69A9             LDR      R1,[R5, #+24]
   \   00000074   0x6820             LDR      R0,[R4, #+0]
   \   00000076   0x.... 0x....      BL       TIM_TI1_SetConfig
   3268                         
   3269                  /* Reset the IC1PSC Bits */
   3270                  htim->Instance->CCMR1 &= ~TIM_CCMR1_IC1PSC;
   \   0000007A   0x6820             LDR      R0,[R4, #+0]
   \   0000007C   0x6980             LDR      R0,[R0, #+24]
   \   0000007E   0xF030 0x000C      BICS     R0,R0,#0xC
   \   00000082   0x6821             LDR      R1,[R4, #+0]
   \   00000084   0x6188             STR      R0,[R1, #+24]
   3271          
   3272                  /* Select the Trigger source */
   3273                  htim->Instance->SMCR &= ~TIM_SMCR_TS;
   \   00000086   0x6820             LDR      R0,[R4, #+0]
   \   00000088   0x6880             LDR      R0,[R0, #+8]
   \   0000008A   0xF030 0x0070      BICS     R0,R0,#0x70
   \   0000008E   0x6821             LDR      R1,[R4, #+0]
   \   00000090   0x6088             STR      R0,[R1, #+8]
   3274                  htim->Instance->SMCR |= TIM_TS_TI1FP1;
   \   00000092   0x6820             LDR      R0,[R4, #+0]
   \   00000094   0x6880             LDR      R0,[R0, #+8]
   \   00000096   0xF050 0x0050      ORRS     R0,R0,#0x50
   \   0000009A   0x6821             LDR      R1,[R4, #+0]
   \   0000009C   0x6088             STR      R0,[R1, #+8]
   3275                
   3276                  /* Select the Slave Mode */      
   3277                  htim->Instance->SMCR &= ~TIM_SMCR_SMS;
   \   0000009E   0x6820             LDR      R0,[R4, #+0]
   \   000000A0   0x6880             LDR      R0,[R0, #+8]
   \   000000A2   0x.... 0x....      LDR.W    R1,??DataTable31  ;; 0xfffefff8
   \   000000A6   0x4008             ANDS     R0,R1,R0
   \   000000A8   0x6821             LDR      R1,[R4, #+0]
   \   000000AA   0x6088             STR      R0,[R1, #+8]
   3278                  htim->Instance->SMCR |= TIM_SLAVEMODE_TRIGGER;
   \   000000AC   0x6820             LDR      R0,[R4, #+0]
   \   000000AE   0x6880             LDR      R0,[R0, #+8]
   \   000000B0   0xF050 0x0006      ORRS     R0,R0,#0x6
   \   000000B4   0x6821             LDR      R1,[R4, #+0]
   \   000000B6   0x6088             STR      R0,[R1, #+8]
   3279                }
   3280                break;
   \   000000B8   0xE025             B.N      ??HAL_TIM_OnePulse_ConfigChannel_10
   3281                case TIM_CHANNEL_2:
   3282                {
   3283                  assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   3284                
   3285                  TIM_TI2_SetConfig(htim->Instance, sConfig->ICPolarity,
   3286                           sConfig->ICSelection, sConfig->ICFilter);
   \                     ??HAL_TIM_OnePulse_ConfigChannel_8: (+1)
   \   000000BA   0x6A2B             LDR      R3,[R5, #+32]
   \   000000BC   0x69EA             LDR      R2,[R5, #+28]
   \   000000BE   0x69A9             LDR      R1,[R5, #+24]
   \   000000C0   0x6820             LDR      R0,[R4, #+0]
   \   000000C2   0x.... 0x....      BL       TIM_TI2_SetConfig
   3287                         
   3288                  /* Reset the IC2PSC Bits */
   3289                  htim->Instance->CCMR1 &= ~TIM_CCMR1_IC2PSC;
   \   000000C6   0x6820             LDR      R0,[R4, #+0]
   \   000000C8   0x6980             LDR      R0,[R0, #+24]
   \   000000CA   0xF430 0x6040      BICS     R0,R0,#0xC00
   \   000000CE   0x6821             LDR      R1,[R4, #+0]
   \   000000D0   0x6188             STR      R0,[R1, #+24]
   3290          
   3291                  /* Select the Trigger source */
   3292                  htim->Instance->SMCR &= ~TIM_SMCR_TS;
   \   000000D2   0x6820             LDR      R0,[R4, #+0]
   \   000000D4   0x6880             LDR      R0,[R0, #+8]
   \   000000D6   0xF030 0x0070      BICS     R0,R0,#0x70
   \   000000DA   0x6821             LDR      R1,[R4, #+0]
   \   000000DC   0x6088             STR      R0,[R1, #+8]
   3293                  htim->Instance->SMCR |= TIM_TS_TI2FP2;
   \   000000DE   0x6820             LDR      R0,[R4, #+0]
   \   000000E0   0x6880             LDR      R0,[R0, #+8]
   \   000000E2   0xF050 0x0060      ORRS     R0,R0,#0x60
   \   000000E6   0x6821             LDR      R1,[R4, #+0]
   \   000000E8   0x6088             STR      R0,[R1, #+8]
   3294                
   3295                  /* Select the Slave Mode */      
   3296                  htim->Instance->SMCR &= ~TIM_SMCR_SMS;
   \   000000EA   0x6820             LDR      R0,[R4, #+0]
   \   000000EC   0x6880             LDR      R0,[R0, #+8]
   \   000000EE   0x.... 0x....      LDR.W    R1,??DataTable31  ;; 0xfffefff8
   \   000000F2   0x4008             ANDS     R0,R1,R0
   \   000000F4   0x6821             LDR      R1,[R4, #+0]
   \   000000F6   0x6088             STR      R0,[R1, #+8]
   3297                  htim->Instance->SMCR |= TIM_SLAVEMODE_TRIGGER;
   \   000000F8   0x6820             LDR      R0,[R4, #+0]
   \   000000FA   0x6880             LDR      R0,[R0, #+8]
   \   000000FC   0xF050 0x0006      ORRS     R0,R0,#0x6
   \   00000100   0x6821             LDR      R1,[R4, #+0]
   \   00000102   0x6088             STR      R0,[R1, #+8]
   3298                }
   3299                break;
   \   00000104   0xE7FF             B.N      ??HAL_TIM_OnePulse_ConfigChannel_10
   3300              
   3301                default:
   3302                break;  
   3303              }
   3304            
   3305              htim->State = HAL_TIM_STATE_READY;
   \                     ??HAL_TIM_OnePulse_ConfigChannel_9: (+1)
   \                     ??HAL_TIM_OnePulse_ConfigChannel_10: (+1)
   \   00000106   0x2001             MOVS     R0,#+1
   \   00000108   0xF884 0x0039      STRB     R0,[R4, #+57]
   3306              
   3307              __HAL_UNLOCK(htim);
   \   0000010C   0x2000             MOVS     R0,#+0
   \   0000010E   0xF884 0x0038      STRB     R0,[R4, #+56]
   3308            
   3309              return HAL_OK;
   \   00000112   0x2000             MOVS     R0,#+0
   \   00000114   0xE000             B.N      ??HAL_TIM_OnePulse_ConfigChannel_2
   3310            }
   3311            else
   3312            {
   3313              return HAL_ERROR;
   \                     ??HAL_TIM_OnePulse_ConfigChannel_0: (+1)
   \   00000116   0x2001             MOVS     R0,#+1
   \                     ??HAL_TIM_OnePulse_ConfigChannel_2: (+1)
   \   00000118   0xB007             ADD      SP,SP,#+28
   \   0000011A   0xBDF0             POP      {R4-R7,PC}       ;; return
   3314            }
   3315          } 
   3316          
   3317          /**
   3318            * @brief  Configure the DMA Burst to transfer Data from the memory to the TIM peripheral  
   3319            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   3320            *                the configuration information for TIM module.
   3321            * @param  BurstBaseAddress: TIM Base address from when the DMA will starts the Data write.
   3322            *         This parameters can be on of the following values:
   3323            *            @arg TIM_DMABASE_CR1  
   3324            *            @arg TIM_DMABASE_CR2
   3325            *            @arg TIM_DMABASE_SMCR
   3326            *            @arg TIM_DMABASE_DIER
   3327            *            @arg TIM_DMABASE_SR
   3328            *            @arg TIM_DMABASE_EGR
   3329            *            @arg TIM_DMABASE_CCMR1
   3330            *            @arg TIM_DMABASE_CCMR2
   3331            *            @arg TIM_DMABASE_CCER
   3332            *            @arg TIM_DMABASE_CNT   
   3333            *            @arg TIM_DMABASE_PSC   
   3334            *            @arg TIM_DMABASE_ARR
   3335            *            @arg TIM_DMABASE_RCR
   3336            *            @arg TIM_DMABASE_CCR1
   3337            *            @arg TIM_DMABASE_CCR2
   3338            *            @arg TIM_DMABASE_CCR3  
   3339            *            @arg TIM_DMABASE_CCR4
   3340            *            @arg TIM_DMABASE_BDTR
   3341            *            @arg TIM_DMABASE_DCR
   3342            * @param  BurstRequestSrc: TIM DMA Request sources.
   3343            *         This parameters can be on of the following values:
   3344            *            @arg TIM_DMA_UPDATE: TIM update Interrupt source
   3345            *            @arg TIM_DMA_CC1: TIM Capture Compare 1 DMA source
   3346            *            @arg TIM_DMA_CC2: TIM Capture Compare 2 DMA source
   3347            *            @arg TIM_DMA_CC3: TIM Capture Compare 3 DMA source
   3348            *            @arg TIM_DMA_CC4: TIM Capture Compare 4 DMA source
   3349            *            @arg TIM_DMA_COM: TIM Commutation DMA source
   3350            *            @arg TIM_DMA_TRIGGER: TIM Trigger DMA source
   3351            * @param  BurstBuffer: The Buffer address.
   3352            * @param  BurstLength: DMA Burst length. This parameter can be one value
   3353            *         between TIM_DMABURSTLENGTH_1TRANSFER and TIM_DMABURSTLENGTH_18TRANSFERS.
   3354            * @retval HAL status
   3355            */

   \                                 In section .text, align 2, keep-with-next
   3356          HAL_StatusTypeDef HAL_TIM_DMABurst_WriteStart(TIM_HandleTypeDef *htim, uint32_t BurstBaseAddress, uint32_t BurstRequestSrc,
   3357                                                        uint32_t* BurstBuffer, uint32_t  BurstLength)
   3358          {
   \                     HAL_TIM_DMABurst_WriteStart: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x4690             MOV      R8,R2
   \   0000000A   0x001E             MOVS     R6,R3
   \   0000000C   0x9F06             LDR      R7,[SP, #+24]
   3359            /* Check the parameters */
   3360            assert_param(IS_TIM_DMABURST_INSTANCE(htim->Instance));
   3361            assert_param(IS_TIM_DMA_BASE(BurstBaseAddress));
   3362            assert_param(IS_TIM_DMA_SOURCE(BurstRequestSrc));
   3363            assert_param(IS_TIM_DMA_LENGTH(BurstLength));
   3364            
   3365            if((htim->State == HAL_TIM_STATE_BUSY))
   \   0000000E   0xF894 0x0039      LDRB     R0,[R4, #+57]
   \   00000012   0x2802             CMP      R0,#+2
   \   00000014   0xD101             BNE.N    ??HAL_TIM_DMABurst_WriteStart_0
   3366            {
   3367               return HAL_BUSY;
   \   00000016   0x2002             MOVS     R0,#+2
   \   00000018   0xE0AF             B.N      ??HAL_TIM_DMABurst_WriteStart_1
   3368            }
   3369            else if((htim->State == HAL_TIM_STATE_READY))
   \                     ??HAL_TIM_DMABurst_WriteStart_0: (+1)
   \   0000001A   0xF894 0x0039      LDRB     R0,[R4, #+57]
   \   0000001E   0x2801             CMP      R0,#+1
   \   00000020   0xD108             BNE.N    ??HAL_TIM_DMABurst_WriteStart_2
   3370            {
   3371              if((BurstBuffer == 0 ) && (BurstLength > 0)) 
   \   00000022   0x2E00             CMP      R6,#+0
   \   00000024   0xD103             BNE.N    ??HAL_TIM_DMABurst_WriteStart_3
   \   00000026   0x2F00             CMP      R7,#+0
   \   00000028   0xD001             BEQ.N    ??HAL_TIM_DMABurst_WriteStart_3
   3372              {
   3373                return HAL_ERROR;                                    
   \   0000002A   0x2001             MOVS     R0,#+1
   \   0000002C   0xE0A5             B.N      ??HAL_TIM_DMABurst_WriteStart_1
   3374              }
   3375              else
   3376              {
   3377                htim->State = HAL_TIM_STATE_BUSY;
   \                     ??HAL_TIM_DMABurst_WriteStart_3: (+1)
   \   0000002E   0x2002             MOVS     R0,#+2
   \   00000030   0xF884 0x0039      STRB     R0,[R4, #+57]
   3378              }
   3379            }
   3380            switch(BurstRequestSrc)
   \                     ??HAL_TIM_DMABurst_WriteStart_2: (+1)
   \   00000034   0x4640             MOV      R0,R8
   \   00000036   0xF5B0 0x7F80      CMP      R0,#+256
   \   0000003A   0xD012             BEQ.N    ??HAL_TIM_DMABurst_WriteStart_4
   \   0000003C   0xF5B0 0x7F00      CMP      R0,#+512
   \   00000040   0xD021             BEQ.N    ??HAL_TIM_DMABurst_WriteStart_5
   \   00000042   0xF5B0 0x6F80      CMP      R0,#+1024
   \   00000046   0xD030             BEQ.N    ??HAL_TIM_DMABurst_WriteStart_6
   \   00000048   0xF5B0 0x6F00      CMP      R0,#+2048
   \   0000004C   0xD03F             BEQ.N    ??HAL_TIM_DMABurst_WriteStart_7
   \   0000004E   0xF5B0 0x5F80      CMP      R0,#+4096
   \   00000052   0xD04E             BEQ.N    ??HAL_TIM_DMABurst_WriteStart_8
   \   00000054   0xF5B0 0x5F00      CMP      R0,#+8192
   \   00000058   0xD05D             BEQ.N    ??HAL_TIM_DMABurst_WriteStart_9
   \   0000005A   0xF5B0 0x4F80      CMP      R0,#+16384
   \   0000005E   0xD06C             BEQ.N    ??HAL_TIM_DMABurst_WriteStart_10
   \   00000060   0xE07D             B.N      ??HAL_TIM_DMABurst_WriteStart_11
   3381            {
   3382              case TIM_DMA_UPDATE:
   3383              {  
   3384                /* Set the DMA Period elapsed callback */
   3385                htim->hdma[TIM_DMA_ID_UPDATE]->XferCpltCallback = TIM_DMAPeriodElapsedCplt;
   \                     ??HAL_TIM_DMABurst_WriteStart_4: (+1)
   \   00000062   0x.... 0x....      ADR.W    R0,TIM_DMAPeriodElapsedCplt
   \   00000066   0x69E1             LDR      R1,[R4, #+28]
   \   00000068   0x63C8             STR      R0,[R1, #+60]
   3386               
   3387                /* Set the DMA error callback */
   3388                htim->hdma[TIM_DMA_ID_UPDATE]->XferErrorCallback = HAL_TIM_DMAError ;
   \   0000006A   0x.... 0x....      ADR.W    R0,TIM_DMAError
   \   0000006E   0x69E1             LDR      R1,[R4, #+28]
   \   00000070   0x6488             STR      R0,[R1, #+72]
   3389            
   3390                /* Enable the DMA Stream */
   3391                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_UPDATE], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8) + 1); 
   \   00000072   0x0A38             LSRS     R0,R7,#+8
   \   00000074   0x1C43             ADDS     R3,R0,#+1
   \   00000076   0x6820             LDR      R0,[R4, #+0]
   \   00000078   0xF110 0x024C      ADDS     R2,R0,#+76
   \   0000007C   0x0031             MOVS     R1,R6
   \   0000007E   0x69E0             LDR      R0,[R4, #+28]
   \   00000080   0x.... 0x....      BL       HAL_DMA_Start_IT
   3392              }
   3393              break;
   \   00000084   0xE06B             B.N      ??HAL_TIM_DMABurst_WriteStart_12
   3394              case TIM_DMA_CC1:
   3395              {  
   3396                /* Set the DMA Period elapsed callback */
   3397                htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = HAL_TIM_DMADelayPulseCplt;
   \                     ??HAL_TIM_DMABurst_WriteStart_5: (+1)
   \   00000086   0x.... 0x....      ADR.W    R0,TIM_DMADelayPulseCplt
   \   0000008A   0x6A21             LDR      R1,[R4, #+32]
   \   0000008C   0x63C8             STR      R0,[R1, #+60]
   3398               
   3399                /* Set the DMA error callback */
   3400                htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = HAL_TIM_DMAError ;
   \   0000008E   0x.... 0x....      ADR.W    R0,TIM_DMAError
   \   00000092   0x6A21             LDR      R1,[R4, #+32]
   \   00000094   0x6488             STR      R0,[R1, #+72]
   3401            
   3402                /* Enable the DMA Stream */
   3403                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8) + 1);     
   \   00000096   0x0A38             LSRS     R0,R7,#+8
   \   00000098   0x1C43             ADDS     R3,R0,#+1
   \   0000009A   0x6820             LDR      R0,[R4, #+0]
   \   0000009C   0xF110 0x024C      ADDS     R2,R0,#+76
   \   000000A0   0x0031             MOVS     R1,R6
   \   000000A2   0x6A20             LDR      R0,[R4, #+32]
   \   000000A4   0x.... 0x....      BL       HAL_DMA_Start_IT
   3404              }
   3405              break;
   \   000000A8   0xE059             B.N      ??HAL_TIM_DMABurst_WriteStart_12
   3406              case TIM_DMA_CC2:
   3407              {  
   3408                /* Set the DMA Period elapsed callback */
   3409                htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = HAL_TIM_DMADelayPulseCplt;
   \                     ??HAL_TIM_DMABurst_WriteStart_6: (+1)
   \   000000AA   0x.... 0x....      ADR.W    R0,TIM_DMADelayPulseCplt
   \   000000AE   0x6A61             LDR      R1,[R4, #+36]
   \   000000B0   0x63C8             STR      R0,[R1, #+60]
   3410               
   3411                /* Set the DMA error callback */
   3412                htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = HAL_TIM_DMAError ;
   \   000000B2   0x.... 0x....      ADR.W    R0,TIM_DMAError
   \   000000B6   0x6A61             LDR      R1,[R4, #+36]
   \   000000B8   0x6488             STR      R0,[R1, #+72]
   3413            
   3414                /* Enable the DMA Stream */
   3415                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8) + 1);     
   \   000000BA   0x0A38             LSRS     R0,R7,#+8
   \   000000BC   0x1C43             ADDS     R3,R0,#+1
   \   000000BE   0x6820             LDR      R0,[R4, #+0]
   \   000000C0   0xF110 0x024C      ADDS     R2,R0,#+76
   \   000000C4   0x0031             MOVS     R1,R6
   \   000000C6   0x6A60             LDR      R0,[R4, #+36]
   \   000000C8   0x.... 0x....      BL       HAL_DMA_Start_IT
   3416              }
   3417              break;
   \   000000CC   0xE047             B.N      ??HAL_TIM_DMABurst_WriteStart_12
   3418              case TIM_DMA_CC3:
   3419              {  
   3420                /* Set the DMA Period elapsed callback */
   3421                htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = HAL_TIM_DMADelayPulseCplt;
   \                     ??HAL_TIM_DMABurst_WriteStart_7: (+1)
   \   000000CE   0x.... 0x....      ADR.W    R0,TIM_DMADelayPulseCplt
   \   000000D2   0x6AA1             LDR      R1,[R4, #+40]
   \   000000D4   0x63C8             STR      R0,[R1, #+60]
   3422               
   3423                /* Set the DMA error callback */
   3424                htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = HAL_TIM_DMAError ;
   \   000000D6   0x.... 0x....      ADR.W    R0,TIM_DMAError
   \   000000DA   0x6AA1             LDR      R1,[R4, #+40]
   \   000000DC   0x6488             STR      R0,[R1, #+72]
   3425            
   3426                /* Enable the DMA Stream */
   3427                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8) + 1);     
   \   000000DE   0x0A38             LSRS     R0,R7,#+8
   \   000000E0   0x1C43             ADDS     R3,R0,#+1
   \   000000E2   0x6820             LDR      R0,[R4, #+0]
   \   000000E4   0xF110 0x024C      ADDS     R2,R0,#+76
   \   000000E8   0x0031             MOVS     R1,R6
   \   000000EA   0x6AA0             LDR      R0,[R4, #+40]
   \   000000EC   0x.... 0x....      BL       HAL_DMA_Start_IT
   3428              }
   3429              break;
   \   000000F0   0xE035             B.N      ??HAL_TIM_DMABurst_WriteStart_12
   3430              case TIM_DMA_CC4:
   3431              {  
   3432                /* Set the DMA Period elapsed callback */
   3433                htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = HAL_TIM_DMADelayPulseCplt;
   \                     ??HAL_TIM_DMABurst_WriteStart_8: (+1)
   \   000000F2   0x.... 0x....      ADR.W    R0,TIM_DMADelayPulseCplt
   \   000000F6   0x6AE1             LDR      R1,[R4, #+44]
   \   000000F8   0x63C8             STR      R0,[R1, #+60]
   3434               
   3435                /* Set the DMA error callback */
   3436                htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = HAL_TIM_DMAError ;
   \   000000FA   0x.... 0x....      ADR.W    R0,TIM_DMAError
   \   000000FE   0x6AE1             LDR      R1,[R4, #+44]
   \   00000100   0x6488             STR      R0,[R1, #+72]
   3437            
   3438                /* Enable the DMA Stream */
   3439                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8) + 1);     
   \   00000102   0x0A38             LSRS     R0,R7,#+8
   \   00000104   0x1C43             ADDS     R3,R0,#+1
   \   00000106   0x6820             LDR      R0,[R4, #+0]
   \   00000108   0xF110 0x024C      ADDS     R2,R0,#+76
   \   0000010C   0x0031             MOVS     R1,R6
   \   0000010E   0x6AE0             LDR      R0,[R4, #+44]
   \   00000110   0x.... 0x....      BL       HAL_DMA_Start_IT
   3440              }
   3441              break;
   \   00000114   0xE023             B.N      ??HAL_TIM_DMABurst_WriteStart_12
   3442              case TIM_DMA_COM:
   3443              {  
   3444                /* Set the DMA Period elapsed callback */
   3445                htim->hdma[TIM_DMA_ID_COMMUTATION]->XferCpltCallback = HAL_TIMEx_DMACommutationCplt;
   \                     ??HAL_TIM_DMABurst_WriteStart_9: (+1)
   \   00000116   0x.... 0x....      LDR.W    R0,??DataTable31_1
   \   0000011A   0x6B21             LDR      R1,[R4, #+48]
   \   0000011C   0x63C8             STR      R0,[R1, #+60]
   3446               
   3447                /* Set the DMA error callback */
   3448                htim->hdma[TIM_DMA_ID_COMMUTATION]->XferErrorCallback = HAL_TIM_DMAError ;
   \   0000011E   0x.... 0x....      ADR.W    R0,TIM_DMAError
   \   00000122   0x6B21             LDR      R1,[R4, #+48]
   \   00000124   0x6488             STR      R0,[R1, #+72]
   3449            
   3450                /* Enable the DMA Stream */
   3451                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_COMMUTATION], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8) + 1);     
   \   00000126   0x0A38             LSRS     R0,R7,#+8
   \   00000128   0x1C43             ADDS     R3,R0,#+1
   \   0000012A   0x6820             LDR      R0,[R4, #+0]
   \   0000012C   0xF110 0x024C      ADDS     R2,R0,#+76
   \   00000130   0x0031             MOVS     R1,R6
   \   00000132   0x6B20             LDR      R0,[R4, #+48]
   \   00000134   0x.... 0x....      BL       HAL_DMA_Start_IT
   3452              }
   3453              break;
   \   00000138   0xE011             B.N      ??HAL_TIM_DMABurst_WriteStart_12
   3454              case TIM_DMA_TRIGGER:
   3455              {  
   3456                /* Set the DMA Period elapsed callback */
   3457                htim->hdma[TIM_DMA_ID_TRIGGER]->XferCpltCallback = TIM_DMATriggerCplt;
   \                     ??HAL_TIM_DMABurst_WriteStart_10: (+1)
   \   0000013A   0x.... 0x....      ADR.W    R0,TIM_DMATriggerCplt
   \   0000013E   0x6B61             LDR      R1,[R4, #+52]
   \   00000140   0x63C8             STR      R0,[R1, #+60]
   3458               
   3459                /* Set the DMA error callback */
   3460                htim->hdma[TIM_DMA_ID_TRIGGER]->XferErrorCallback = HAL_TIM_DMAError ;
   \   00000142   0x.... 0x....      ADR.W    R0,TIM_DMAError
   \   00000146   0x6B61             LDR      R1,[R4, #+52]
   \   00000148   0x6488             STR      R0,[R1, #+72]
   3461            
   3462                /* Enable the DMA Stream */
   3463                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_TRIGGER], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8) + 1);     
   \   0000014A   0x0A38             LSRS     R0,R7,#+8
   \   0000014C   0x1C43             ADDS     R3,R0,#+1
   \   0000014E   0x6820             LDR      R0,[R4, #+0]
   \   00000150   0xF110 0x024C      ADDS     R2,R0,#+76
   \   00000154   0x0031             MOVS     R1,R6
   \   00000156   0x6B60             LDR      R0,[R4, #+52]
   \   00000158   0x.... 0x....      BL       HAL_DMA_Start_IT
   3464              }
   3465              break;
   \   0000015C   0xE7FF             B.N      ??HAL_TIM_DMABurst_WriteStart_12
   3466              default:
   3467              break;  
   3468            }
   3469             /* configure the DMA Burst Mode */
   3470             htim->Instance->DCR = BurstBaseAddress | BurstLength;  
   \                     ??HAL_TIM_DMABurst_WriteStart_11: (+1)
   \                     ??HAL_TIM_DMABurst_WriteStart_12: (+1)
   \   0000015E   0xEA57 0x0005      ORRS     R0,R7,R5
   \   00000162   0x6821             LDR      R1,[R4, #+0]
   \   00000164   0x6488             STR      R0,[R1, #+72]
   3471             
   3472             /* Enable the TIM DMA Request */
   3473             __HAL_TIM_ENABLE_DMA(htim, BurstRequestSrc);  
   \   00000166   0x6820             LDR      R0,[R4, #+0]
   \   00000168   0x68C0             LDR      R0,[R0, #+12]
   \   0000016A   0xEA58 0x0000      ORRS     R0,R8,R0
   \   0000016E   0x6821             LDR      R1,[R4, #+0]
   \   00000170   0x60C8             STR      R0,[R1, #+12]
   3474             
   3475             htim->State = HAL_TIM_STATE_READY;
   \   00000172   0x2001             MOVS     R0,#+1
   \   00000174   0xF884 0x0039      STRB     R0,[R4, #+57]
   3476            
   3477            /* Return function status */
   3478            return HAL_OK;
   \   00000178   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_DMABurst_WriteStart_1: (+1)
   \   0000017A   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   3479          }
   3480          
   3481          /**
   3482            * @brief  Stops the TIM DMA Burst mode 
   3483            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   3484            *                the configuration information for TIM module.
   3485            * @param  BurstRequestSrc: TIM DMA Request sources to disable
   3486            * @retval HAL status
   3487            */

   \                                 In section .text, align 2, keep-with-next
   3488          HAL_StatusTypeDef HAL_TIM_DMABurst_WriteStop(TIM_HandleTypeDef *htim, uint32_t BurstRequestSrc)
   3489          {
   \                     HAL_TIM_DMABurst_WriteStop: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   3490            /* Check the parameters */
   3491            assert_param(IS_TIM_DMA_SOURCE(BurstRequestSrc));
   3492            
   3493            /* Abort the DMA transfer (at least disable the DMA channel) */
   3494            switch(BurstRequestSrc)
   \   00000006   0x0028             MOVS     R0,R5
   \   00000008   0xF5B0 0x7F80      CMP      R0,#+256
   \   0000000C   0xD012             BEQ.N    ??HAL_TIM_DMABurst_WriteStop_0
   \   0000000E   0xF5B0 0x7F00      CMP      R0,#+512
   \   00000012   0xD013             BEQ.N    ??HAL_TIM_DMABurst_WriteStop_1
   \   00000014   0xF5B0 0x6F80      CMP      R0,#+1024
   \   00000018   0xD014             BEQ.N    ??HAL_TIM_DMABurst_WriteStop_2
   \   0000001A   0xF5B0 0x6F00      CMP      R0,#+2048
   \   0000001E   0xD015             BEQ.N    ??HAL_TIM_DMABurst_WriteStop_3
   \   00000020   0xF5B0 0x5F80      CMP      R0,#+4096
   \   00000024   0xD016             BEQ.N    ??HAL_TIM_DMABurst_WriteStop_4
   \   00000026   0xF5B0 0x5F00      CMP      R0,#+8192
   \   0000002A   0xD017             BEQ.N    ??HAL_TIM_DMABurst_WriteStop_5
   \   0000002C   0xF5B0 0x4F80      CMP      R0,#+16384
   \   00000030   0xD018             BEQ.N    ??HAL_TIM_DMABurst_WriteStop_6
   \   00000032   0xE01B             B.N      ??HAL_TIM_DMABurst_WriteStop_7
   3495            {
   3496              case TIM_DMA_UPDATE:
   3497              {  
   3498                HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_UPDATE]);
   \                     ??HAL_TIM_DMABurst_WriteStop_0: (+1)
   \   00000034   0x69E0             LDR      R0,[R4, #+28]
   \   00000036   0x.... 0x....      BL       HAL_DMA_Abort
   3499              }
   3500              break;
   \   0000003A   0xE017             B.N      ??HAL_TIM_DMABurst_WriteStop_8
   3501              case TIM_DMA_CC1:
   3502              {  
   3503                HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC1]);
   \                     ??HAL_TIM_DMABurst_WriteStop_1: (+1)
   \   0000003C   0x6A20             LDR      R0,[R4, #+32]
   \   0000003E   0x.... 0x....      BL       HAL_DMA_Abort
   3504              }
   3505              break;
   \   00000042   0xE013             B.N      ??HAL_TIM_DMABurst_WriteStop_8
   3506              case TIM_DMA_CC2:
   3507              {  
   3508                HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC2]);
   \                     ??HAL_TIM_DMABurst_WriteStop_2: (+1)
   \   00000044   0x6A60             LDR      R0,[R4, #+36]
   \   00000046   0x.... 0x....      BL       HAL_DMA_Abort
   3509              }
   3510              break;
   \   0000004A   0xE00F             B.N      ??HAL_TIM_DMABurst_WriteStop_8
   3511              case TIM_DMA_CC3:
   3512              {  
   3513                HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC3]);
   \                     ??HAL_TIM_DMABurst_WriteStop_3: (+1)
   \   0000004C   0x6AA0             LDR      R0,[R4, #+40]
   \   0000004E   0x.... 0x....      BL       HAL_DMA_Abort
   3514              }
   3515              break;
   \   00000052   0xE00B             B.N      ??HAL_TIM_DMABurst_WriteStop_8
   3516              case TIM_DMA_CC4:
   3517              {  
   3518                HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC4]);
   \                     ??HAL_TIM_DMABurst_WriteStop_4: (+1)
   \   00000054   0x6AE0             LDR      R0,[R4, #+44]
   \   00000056   0x.... 0x....      BL       HAL_DMA_Abort
   3519              }
   3520              break;
   \   0000005A   0xE007             B.N      ??HAL_TIM_DMABurst_WriteStop_8
   3521              case TIM_DMA_COM:
   3522              {  
   3523                HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_COMMUTATION]);
   \                     ??HAL_TIM_DMABurst_WriteStop_5: (+1)
   \   0000005C   0x6B20             LDR      R0,[R4, #+48]
   \   0000005E   0x.... 0x....      BL       HAL_DMA_Abort
   3524              }
   3525              break;
   \   00000062   0xE003             B.N      ??HAL_TIM_DMABurst_WriteStop_8
   3526              case TIM_DMA_TRIGGER:
   3527              {  
   3528                HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_TRIGGER]);
   \                     ??HAL_TIM_DMABurst_WriteStop_6: (+1)
   \   00000064   0x6B60             LDR      R0,[R4, #+52]
   \   00000066   0x.... 0x....      BL       HAL_DMA_Abort
   3529              }
   3530              break;
   \   0000006A   0xE7FF             B.N      ??HAL_TIM_DMABurst_WriteStop_8
   3531              default:
   3532              break;
   3533            }
   3534          
   3535            /* Disable the TIM Update DMA request */
   3536            __HAL_TIM_DISABLE_DMA(htim, BurstRequestSrc);
   \                     ??HAL_TIM_DMABurst_WriteStop_7: (+1)
   \                     ??HAL_TIM_DMABurst_WriteStop_8: (+1)
   \   0000006C   0x6820             LDR      R0,[R4, #+0]
   \   0000006E   0x68C0             LDR      R0,[R0, #+12]
   \   00000070   0x43A8             BICS     R0,R0,R5
   \   00000072   0x6821             LDR      R1,[R4, #+0]
   \   00000074   0x60C8             STR      R0,[R1, #+12]
   3537                
   3538            /* Return function status */
   3539            return HAL_OK;  
   \   00000076   0x2000             MOVS     R0,#+0
   \   00000078   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   3540          }
   3541          
   3542          /**
   3543            * @brief  Configure the DMA Burst to transfer Data from the TIM peripheral to the memory 
   3544            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   3545            *                the configuration information for TIM module.
   3546            * @param  BurstBaseAddress: TIM Base address from when the DMA will starts the Data read.
   3547            *         This parameters can be on of the following values:
   3548            *            @arg TIM_DMABASE_CR1  
   3549            *            @arg TIM_DMABASE_CR2
   3550            *            @arg TIM_DMABASE_SMCR
   3551            *            @arg TIM_DMABASE_DIER
   3552            *            @arg TIM_DMABASE_SR
   3553            *            @arg TIM_DMABASE_EGR
   3554            *            @arg TIM_DMABASE_CCMR1
   3555            *            @arg TIM_DMABASE_CCMR2
   3556            *            @arg TIM_DMABASE_CCER
   3557            *            @arg TIM_DMABASE_CNT   
   3558            *            @arg TIM_DMABASE_PSC   
   3559            *            @arg TIM_DMABASE_ARR
   3560            *            @arg TIM_DMABASE_RCR
   3561            *            @arg TIM_DMABASE_CCR1
   3562            *            @arg TIM_DMABASE_CCR2
   3563            *            @arg TIM_DMABASE_CCR3  
   3564            *            @arg TIM_DMABASE_CCR4
   3565            *            @arg TIM_DMABASE_BDTR
   3566            *            @arg TIM_DMABASE_DCR
   3567            * @param  BurstRequestSrc: TIM DMA Request sources.
   3568            *         This parameters can be on of the following values:
   3569            *            @arg TIM_DMA_UPDATE: TIM update Interrupt source
   3570            *            @arg TIM_DMA_CC1: TIM Capture Compare 1 DMA source
   3571            *            @arg TIM_DMA_CC2: TIM Capture Compare 2 DMA source
   3572            *            @arg TIM_DMA_CC3: TIM Capture Compare 3 DMA source
   3573            *            @arg TIM_DMA_CC4: TIM Capture Compare 4 DMA source
   3574            *            @arg TIM_DMA_COM: TIM Commutation DMA source
   3575            *            @arg TIM_DMA_TRIGGER: TIM Trigger DMA source
   3576            * @param  BurstBuffer: The Buffer address.
   3577            * @param  BurstLength: DMA Burst length. This parameter can be one value
   3578            *         between TIM_DMABURSTLENGTH_1TRANSFER and TIM_DMABURSTLENGTH_18TRANSFERS.
   3579            * @retval HAL status
   3580            */

   \                                 In section .text, align 2, keep-with-next
   3581          HAL_StatusTypeDef HAL_TIM_DMABurst_ReadStart(TIM_HandleTypeDef *htim, uint32_t BurstBaseAddress, uint32_t BurstRequestSrc,
   3582                                                       uint32_t  *BurstBuffer, uint32_t  BurstLength)
   3583          {
   \                     HAL_TIM_DMABurst_ReadStart: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x4690             MOV      R8,R2
   \   0000000A   0x001E             MOVS     R6,R3
   \   0000000C   0x9F06             LDR      R7,[SP, #+24]
   3584            /* Check the parameters */
   3585            assert_param(IS_TIM_DMABURST_INSTANCE(htim->Instance));
   3586            assert_param(IS_TIM_DMA_BASE(BurstBaseAddress));
   3587            assert_param(IS_TIM_DMA_SOURCE(BurstRequestSrc));
   3588            assert_param(IS_TIM_DMA_LENGTH(BurstLength));
   3589            
   3590            if((htim->State == HAL_TIM_STATE_BUSY))
   \   0000000E   0xF894 0x0039      LDRB     R0,[R4, #+57]
   \   00000012   0x2802             CMP      R0,#+2
   \   00000014   0xD101             BNE.N    ??HAL_TIM_DMABurst_ReadStart_0
   3591            {
   3592               return HAL_BUSY;
   \   00000016   0x2002             MOVS     R0,#+2
   \   00000018   0xE0AF             B.N      ??HAL_TIM_DMABurst_ReadStart_1
   3593            }
   3594            else if((htim->State == HAL_TIM_STATE_READY))
   \                     ??HAL_TIM_DMABurst_ReadStart_0: (+1)
   \   0000001A   0xF894 0x0039      LDRB     R0,[R4, #+57]
   \   0000001E   0x2801             CMP      R0,#+1
   \   00000020   0xD108             BNE.N    ??HAL_TIM_DMABurst_ReadStart_2
   3595            {
   3596              if((BurstBuffer == 0 ) && (BurstLength > 0)) 
   \   00000022   0x2E00             CMP      R6,#+0
   \   00000024   0xD103             BNE.N    ??HAL_TIM_DMABurst_ReadStart_3
   \   00000026   0x2F00             CMP      R7,#+0
   \   00000028   0xD001             BEQ.N    ??HAL_TIM_DMABurst_ReadStart_3
   3597              {
   3598                return HAL_ERROR;                                    
   \   0000002A   0x2001             MOVS     R0,#+1
   \   0000002C   0xE0A5             B.N      ??HAL_TIM_DMABurst_ReadStart_1
   3599              }
   3600              else
   3601              {
   3602                htim->State = HAL_TIM_STATE_BUSY;
   \                     ??HAL_TIM_DMABurst_ReadStart_3: (+1)
   \   0000002E   0x2002             MOVS     R0,#+2
   \   00000030   0xF884 0x0039      STRB     R0,[R4, #+57]
   3603              }
   3604            }  
   3605            switch(BurstRequestSrc)
   \                     ??HAL_TIM_DMABurst_ReadStart_2: (+1)
   \   00000034   0x4640             MOV      R0,R8
   \   00000036   0xF5B0 0x7F80      CMP      R0,#+256
   \   0000003A   0xD012             BEQ.N    ??HAL_TIM_DMABurst_ReadStart_4
   \   0000003C   0xF5B0 0x7F00      CMP      R0,#+512
   \   00000040   0xD021             BEQ.N    ??HAL_TIM_DMABurst_ReadStart_5
   \   00000042   0xF5B0 0x6F80      CMP      R0,#+1024
   \   00000046   0xD030             BEQ.N    ??HAL_TIM_DMABurst_ReadStart_6
   \   00000048   0xF5B0 0x6F00      CMP      R0,#+2048
   \   0000004C   0xD03F             BEQ.N    ??HAL_TIM_DMABurst_ReadStart_7
   \   0000004E   0xF5B0 0x5F80      CMP      R0,#+4096
   \   00000052   0xD04E             BEQ.N    ??HAL_TIM_DMABurst_ReadStart_8
   \   00000054   0xF5B0 0x5F00      CMP      R0,#+8192
   \   00000058   0xD05D             BEQ.N    ??HAL_TIM_DMABurst_ReadStart_9
   \   0000005A   0xF5B0 0x4F80      CMP      R0,#+16384
   \   0000005E   0xD06C             BEQ.N    ??HAL_TIM_DMABurst_ReadStart_10
   \   00000060   0xE07D             B.N      ??HAL_TIM_DMABurst_ReadStart_11
   3606            {
   3607              case TIM_DMA_UPDATE:
   3608              {  
   3609                /* Set the DMA Period elapsed callback */
   3610                htim->hdma[TIM_DMA_ID_UPDATE]->XferCpltCallback = TIM_DMAPeriodElapsedCplt;
   \                     ??HAL_TIM_DMABurst_ReadStart_4: (+1)
   \   00000062   0x.... 0x....      ADR.W    R0,TIM_DMAPeriodElapsedCplt
   \   00000066   0x69E1             LDR      R1,[R4, #+28]
   \   00000068   0x63C8             STR      R0,[R1, #+60]
   3611               
   3612                /* Set the DMA error callback */
   3613                htim->hdma[TIM_DMA_ID_UPDATE]->XferErrorCallback = HAL_TIM_DMAError ;
   \   0000006A   0x.... 0x....      ADR.W    R0,TIM_DMAError
   \   0000006E   0x69E1             LDR      R1,[R4, #+28]
   \   00000070   0x6488             STR      R0,[R1, #+72]
   3614            
   3615                /* Enable the DMA Stream */
   3616                 HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_UPDATE], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8) + 1);     
   \   00000072   0x0A38             LSRS     R0,R7,#+8
   \   00000074   0x1C43             ADDS     R3,R0,#+1
   \   00000076   0x0032             MOVS     R2,R6
   \   00000078   0x6820             LDR      R0,[R4, #+0]
   \   0000007A   0xF110 0x014C      ADDS     R1,R0,#+76
   \   0000007E   0x69E0             LDR      R0,[R4, #+28]
   \   00000080   0x.... 0x....      BL       HAL_DMA_Start_IT
   3617              }
   3618              break;
   \   00000084   0xE06B             B.N      ??HAL_TIM_DMABurst_ReadStart_12
   3619              case TIM_DMA_CC1:
   3620              {  
   3621                /* Set the DMA Period elapsed callback */
   3622                htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = HAL_TIM_DMACaptureCplt;
   \                     ??HAL_TIM_DMABurst_ReadStart_5: (+1)
   \   00000086   0x.... 0x....      ADR.W    R0,TIM_DMACaptureCplt
   \   0000008A   0x6A21             LDR      R1,[R4, #+32]
   \   0000008C   0x63C8             STR      R0,[R1, #+60]
   3623               
   3624                /* Set the DMA error callback */
   3625                htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = HAL_TIM_DMAError ;
   \   0000008E   0x.... 0x....      ADR.W    R0,TIM_DMAError
   \   00000092   0x6A21             LDR      R1,[R4, #+32]
   \   00000094   0x6488             STR      R0,[R1, #+72]
   3626            
   3627                /* Enable the DMA Stream */
   3628                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8) + 1);      
   \   00000096   0x0A38             LSRS     R0,R7,#+8
   \   00000098   0x1C43             ADDS     R3,R0,#+1
   \   0000009A   0x0032             MOVS     R2,R6
   \   0000009C   0x6820             LDR      R0,[R4, #+0]
   \   0000009E   0xF110 0x014C      ADDS     R1,R0,#+76
   \   000000A2   0x6A20             LDR      R0,[R4, #+32]
   \   000000A4   0x.... 0x....      BL       HAL_DMA_Start_IT
   3629              }
   3630              break;
   \   000000A8   0xE059             B.N      ??HAL_TIM_DMABurst_ReadStart_12
   3631              case TIM_DMA_CC2:
   3632              {  
   3633                /* Set the DMA Period elapsed callback */
   3634                htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = HAL_TIM_DMACaptureCplt;
   \                     ??HAL_TIM_DMABurst_ReadStart_6: (+1)
   \   000000AA   0x.... 0x....      ADR.W    R0,TIM_DMACaptureCplt
   \   000000AE   0x6A61             LDR      R1,[R4, #+36]
   \   000000B0   0x63C8             STR      R0,[R1, #+60]
   3635               
   3636                /* Set the DMA error callback */
   3637                htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = HAL_TIM_DMAError ;
   \   000000B2   0x.... 0x....      ADR.W    R0,TIM_DMAError
   \   000000B6   0x6A61             LDR      R1,[R4, #+36]
   \   000000B8   0x6488             STR      R0,[R1, #+72]
   3638            
   3639                /* Enable the DMA Stream */
   3640                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8) + 1);     
   \   000000BA   0x0A38             LSRS     R0,R7,#+8
   \   000000BC   0x1C43             ADDS     R3,R0,#+1
   \   000000BE   0x0032             MOVS     R2,R6
   \   000000C0   0x6820             LDR      R0,[R4, #+0]
   \   000000C2   0xF110 0x014C      ADDS     R1,R0,#+76
   \   000000C6   0x6A60             LDR      R0,[R4, #+36]
   \   000000C8   0x.... 0x....      BL       HAL_DMA_Start_IT
   3641              }
   3642              break;
   \   000000CC   0xE047             B.N      ??HAL_TIM_DMABurst_ReadStart_12
   3643              case TIM_DMA_CC3:
   3644              {  
   3645                /* Set the DMA Period elapsed callback */
   3646                htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = HAL_TIM_DMACaptureCplt;
   \                     ??HAL_TIM_DMABurst_ReadStart_7: (+1)
   \   000000CE   0x.... 0x....      ADR.W    R0,TIM_DMACaptureCplt
   \   000000D2   0x6AA1             LDR      R1,[R4, #+40]
   \   000000D4   0x63C8             STR      R0,[R1, #+60]
   3647               
   3648                /* Set the DMA error callback */
   3649                htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = HAL_TIM_DMAError ;
   \   000000D6   0x.... 0x....      ADR.W    R0,TIM_DMAError
   \   000000DA   0x6AA1             LDR      R1,[R4, #+40]
   \   000000DC   0x6488             STR      R0,[R1, #+72]
   3650            
   3651                /* Enable the DMA Stream */
   3652                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8) + 1);      
   \   000000DE   0x0A38             LSRS     R0,R7,#+8
   \   000000E0   0x1C43             ADDS     R3,R0,#+1
   \   000000E2   0x0032             MOVS     R2,R6
   \   000000E4   0x6820             LDR      R0,[R4, #+0]
   \   000000E6   0xF110 0x014C      ADDS     R1,R0,#+76
   \   000000EA   0x6AA0             LDR      R0,[R4, #+40]
   \   000000EC   0x.... 0x....      BL       HAL_DMA_Start_IT
   3653              }
   3654              break;
   \   000000F0   0xE035             B.N      ??HAL_TIM_DMABurst_ReadStart_12
   3655              case TIM_DMA_CC4:
   3656              {  
   3657                /* Set the DMA Period elapsed callback */
   3658                htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = HAL_TIM_DMACaptureCplt;
   \                     ??HAL_TIM_DMABurst_ReadStart_8: (+1)
   \   000000F2   0x.... 0x....      ADR.W    R0,TIM_DMACaptureCplt
   \   000000F6   0x6AE1             LDR      R1,[R4, #+44]
   \   000000F8   0x63C8             STR      R0,[R1, #+60]
   3659               
   3660                /* Set the DMA error callback */
   3661                htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = HAL_TIM_DMAError ;
   \   000000FA   0x.... 0x....      ADR.W    R0,TIM_DMAError
   \   000000FE   0x6AE1             LDR      R1,[R4, #+44]
   \   00000100   0x6488             STR      R0,[R1, #+72]
   3662            
   3663                /* Enable the DMA Stream */
   3664                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8) + 1);      
   \   00000102   0x0A38             LSRS     R0,R7,#+8
   \   00000104   0x1C43             ADDS     R3,R0,#+1
   \   00000106   0x0032             MOVS     R2,R6
   \   00000108   0x6820             LDR      R0,[R4, #+0]
   \   0000010A   0xF110 0x014C      ADDS     R1,R0,#+76
   \   0000010E   0x6AE0             LDR      R0,[R4, #+44]
   \   00000110   0x.... 0x....      BL       HAL_DMA_Start_IT
   3665              }
   3666              break;
   \   00000114   0xE023             B.N      ??HAL_TIM_DMABurst_ReadStart_12
   3667              case TIM_DMA_COM:
   3668              {  
   3669                /* Set the DMA Period elapsed callback */
   3670                htim->hdma[TIM_DMA_ID_COMMUTATION]->XferCpltCallback = HAL_TIMEx_DMACommutationCplt;
   \                     ??HAL_TIM_DMABurst_ReadStart_9: (+1)
   \   00000116   0x.... 0x....      LDR.W    R0,??DataTable31_1
   \   0000011A   0x6B21             LDR      R1,[R4, #+48]
   \   0000011C   0x63C8             STR      R0,[R1, #+60]
   3671               
   3672                /* Set the DMA error callback */
   3673                htim->hdma[TIM_DMA_ID_COMMUTATION]->XferErrorCallback = HAL_TIM_DMAError ;
   \   0000011E   0x.... 0x....      ADR.W    R0,TIM_DMAError
   \   00000122   0x6B21             LDR      R1,[R4, #+48]
   \   00000124   0x6488             STR      R0,[R1, #+72]
   3674            
   3675                /* Enable the DMA Stream */
   3676                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_COMMUTATION], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8) + 1);      
   \   00000126   0x0A38             LSRS     R0,R7,#+8
   \   00000128   0x1C43             ADDS     R3,R0,#+1
   \   0000012A   0x0032             MOVS     R2,R6
   \   0000012C   0x6820             LDR      R0,[R4, #+0]
   \   0000012E   0xF110 0x014C      ADDS     R1,R0,#+76
   \   00000132   0x6B20             LDR      R0,[R4, #+48]
   \   00000134   0x.... 0x....      BL       HAL_DMA_Start_IT
   3677              }
   3678              break;
   \   00000138   0xE011             B.N      ??HAL_TIM_DMABurst_ReadStart_12
   3679              case TIM_DMA_TRIGGER:
   3680              {  
   3681                /* Set the DMA Period elapsed callback */
   3682                htim->hdma[TIM_DMA_ID_TRIGGER]->XferCpltCallback = TIM_DMATriggerCplt;
   \                     ??HAL_TIM_DMABurst_ReadStart_10: (+1)
   \   0000013A   0x.... 0x....      ADR.W    R0,TIM_DMATriggerCplt
   \   0000013E   0x6B61             LDR      R1,[R4, #+52]
   \   00000140   0x63C8             STR      R0,[R1, #+60]
   3683               
   3684                /* Set the DMA error callback */
   3685                htim->hdma[TIM_DMA_ID_TRIGGER]->XferErrorCallback = HAL_TIM_DMAError ;
   \   00000142   0x.... 0x....      ADR.W    R0,TIM_DMAError
   \   00000146   0x6B61             LDR      R1,[R4, #+52]
   \   00000148   0x6488             STR      R0,[R1, #+72]
   3686            
   3687                /* Enable the DMA Stream */
   3688                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_TRIGGER], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8) + 1);      
   \   0000014A   0x0A38             LSRS     R0,R7,#+8
   \   0000014C   0x1C43             ADDS     R3,R0,#+1
   \   0000014E   0x0032             MOVS     R2,R6
   \   00000150   0x6820             LDR      R0,[R4, #+0]
   \   00000152   0xF110 0x014C      ADDS     R1,R0,#+76
   \   00000156   0x6B60             LDR      R0,[R4, #+52]
   \   00000158   0x.... 0x....      BL       HAL_DMA_Start_IT
   3689              }
   3690              break;
   \   0000015C   0xE7FF             B.N      ??HAL_TIM_DMABurst_ReadStart_12
   3691              default:
   3692              break;  
   3693            }
   3694          
   3695            /* configure the DMA Burst Mode */
   3696            htim->Instance->DCR = BurstBaseAddress | BurstLength;  
   \                     ??HAL_TIM_DMABurst_ReadStart_11: (+1)
   \                     ??HAL_TIM_DMABurst_ReadStart_12: (+1)
   \   0000015E   0xEA57 0x0005      ORRS     R0,R7,R5
   \   00000162   0x6821             LDR      R1,[R4, #+0]
   \   00000164   0x6488             STR      R0,[R1, #+72]
   3697            
   3698            /* Enable the TIM DMA Request */
   3699            __HAL_TIM_ENABLE_DMA(htim, BurstRequestSrc);
   \   00000166   0x6820             LDR      R0,[R4, #+0]
   \   00000168   0x68C0             LDR      R0,[R0, #+12]
   \   0000016A   0xEA58 0x0000      ORRS     R0,R8,R0
   \   0000016E   0x6821             LDR      R1,[R4, #+0]
   \   00000170   0x60C8             STR      R0,[R1, #+12]
   3700            
   3701            htim->State = HAL_TIM_STATE_READY;
   \   00000172   0x2001             MOVS     R0,#+1
   \   00000174   0xF884 0x0039      STRB     R0,[R4, #+57]
   3702            
   3703            /* Return function status */
   3704            return HAL_OK;
   \   00000178   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_DMABurst_ReadStart_1: (+1)
   \   0000017A   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   3705          }
   3706          
   3707          /**
   3708            * @brief  Stop the DMA burst reading 
   3709            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   3710            *                the configuration information for TIM module.
   3711            * @param  BurstRequestSrc: TIM DMA Request sources to disable.
   3712            * @retval HAL status
   3713            */

   \                                 In section .text, align 2, keep-with-next
   3714          HAL_StatusTypeDef HAL_TIM_DMABurst_ReadStop(TIM_HandleTypeDef *htim, uint32_t BurstRequestSrc)
   3715          {
   \                     HAL_TIM_DMABurst_ReadStop: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   3716            /* Check the parameters */
   3717            assert_param(IS_TIM_DMA_SOURCE(BurstRequestSrc));
   3718            
   3719            /* Abort the DMA transfer (at least disable the DMA channel) */
   3720            switch(BurstRequestSrc)
   \   00000006   0x0028             MOVS     R0,R5
   \   00000008   0xF5B0 0x7F80      CMP      R0,#+256
   \   0000000C   0xD012             BEQ.N    ??HAL_TIM_DMABurst_ReadStop_0
   \   0000000E   0xF5B0 0x7F00      CMP      R0,#+512
   \   00000012   0xD013             BEQ.N    ??HAL_TIM_DMABurst_ReadStop_1
   \   00000014   0xF5B0 0x6F80      CMP      R0,#+1024
   \   00000018   0xD014             BEQ.N    ??HAL_TIM_DMABurst_ReadStop_2
   \   0000001A   0xF5B0 0x6F00      CMP      R0,#+2048
   \   0000001E   0xD015             BEQ.N    ??HAL_TIM_DMABurst_ReadStop_3
   \   00000020   0xF5B0 0x5F80      CMP      R0,#+4096
   \   00000024   0xD016             BEQ.N    ??HAL_TIM_DMABurst_ReadStop_4
   \   00000026   0xF5B0 0x5F00      CMP      R0,#+8192
   \   0000002A   0xD017             BEQ.N    ??HAL_TIM_DMABurst_ReadStop_5
   \   0000002C   0xF5B0 0x4F80      CMP      R0,#+16384
   \   00000030   0xD018             BEQ.N    ??HAL_TIM_DMABurst_ReadStop_6
   \   00000032   0xE01B             B.N      ??HAL_TIM_DMABurst_ReadStop_7
   3721            {
   3722              case TIM_DMA_UPDATE:
   3723              {  
   3724                HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_UPDATE]);
   \                     ??HAL_TIM_DMABurst_ReadStop_0: (+1)
   \   00000034   0x69E0             LDR      R0,[R4, #+28]
   \   00000036   0x.... 0x....      BL       HAL_DMA_Abort
   3725              }
   3726              break;
   \   0000003A   0xE017             B.N      ??HAL_TIM_DMABurst_ReadStop_8
   3727              case TIM_DMA_CC1:
   3728              {  
   3729                HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC1]);
   \                     ??HAL_TIM_DMABurst_ReadStop_1: (+1)
   \   0000003C   0x6A20             LDR      R0,[R4, #+32]
   \   0000003E   0x.... 0x....      BL       HAL_DMA_Abort
   3730              }
   3731              break;
   \   00000042   0xE013             B.N      ??HAL_TIM_DMABurst_ReadStop_8
   3732              case TIM_DMA_CC2:
   3733              {  
   3734                HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC2]);
   \                     ??HAL_TIM_DMABurst_ReadStop_2: (+1)
   \   00000044   0x6A60             LDR      R0,[R4, #+36]
   \   00000046   0x.... 0x....      BL       HAL_DMA_Abort
   3735              }
   3736              break;
   \   0000004A   0xE00F             B.N      ??HAL_TIM_DMABurst_ReadStop_8
   3737              case TIM_DMA_CC3:
   3738              {  
   3739                HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC3]);
   \                     ??HAL_TIM_DMABurst_ReadStop_3: (+1)
   \   0000004C   0x6AA0             LDR      R0,[R4, #+40]
   \   0000004E   0x.... 0x....      BL       HAL_DMA_Abort
   3740              }
   3741              break;
   \   00000052   0xE00B             B.N      ??HAL_TIM_DMABurst_ReadStop_8
   3742              case TIM_DMA_CC4:
   3743              {  
   3744                HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC4]);
   \                     ??HAL_TIM_DMABurst_ReadStop_4: (+1)
   \   00000054   0x6AE0             LDR      R0,[R4, #+44]
   \   00000056   0x.... 0x....      BL       HAL_DMA_Abort
   3745              }
   3746              break;
   \   0000005A   0xE007             B.N      ??HAL_TIM_DMABurst_ReadStop_8
   3747              case TIM_DMA_COM:
   3748              {  
   3749                HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_COMMUTATION]);
   \                     ??HAL_TIM_DMABurst_ReadStop_5: (+1)
   \   0000005C   0x6B20             LDR      R0,[R4, #+48]
   \   0000005E   0x.... 0x....      BL       HAL_DMA_Abort
   3750              }
   3751              break;
   \   00000062   0xE003             B.N      ??HAL_TIM_DMABurst_ReadStop_8
   3752              case TIM_DMA_TRIGGER:
   3753              {  
   3754                HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_TRIGGER]);
   \                     ??HAL_TIM_DMABurst_ReadStop_6: (+1)
   \   00000064   0x6B60             LDR      R0,[R4, #+52]
   \   00000066   0x.... 0x....      BL       HAL_DMA_Abort
   3755              }
   3756              break;
   \   0000006A   0xE7FF             B.N      ??HAL_TIM_DMABurst_ReadStop_8
   3757              default:
   3758              break;  
   3759            }
   3760            
   3761            /* Disable the TIM Update DMA request */
   3762            __HAL_TIM_DISABLE_DMA(htim, BurstRequestSrc);
   \                     ??HAL_TIM_DMABurst_ReadStop_7: (+1)
   \                     ??HAL_TIM_DMABurst_ReadStop_8: (+1)
   \   0000006C   0x6820             LDR      R0,[R4, #+0]
   \   0000006E   0x68C0             LDR      R0,[R0, #+12]
   \   00000070   0x43A8             BICS     R0,R0,R5
   \   00000072   0x6821             LDR      R1,[R4, #+0]
   \   00000074   0x60C8             STR      R0,[R1, #+12]
   3763                
   3764            /* Return function status */
   3765            return HAL_OK;  
   \   00000076   0x2000             MOVS     R0,#+0
   \   00000078   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   3766          }
   3767          
   3768          /**
   3769            * @brief  Generate a software event
   3770            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   3771            *                the configuration information for TIM module.
   3772            * @param  EventSource: specifies the event source.
   3773            *          This parameter can be one of the following values:
   3774            *            @arg TIM_EVENTSOURCE_UPDATE: Timer update Event source
   3775            *            @arg TIM_EVENTSOURCE_CC1: Timer Capture Compare 1 Event source
   3776            *            @arg TIM_EVENTSOURCE_CC2: Timer Capture Compare 2 Event source
   3777            *            @arg TIM_EVENTSOURCE_CC3: Timer Capture Compare 3 Event source
   3778            *            @arg TIM_EVENTSOURCE_CC4: Timer Capture Compare 4 Event source
   3779            *            @arg TIM_EVENTSOURCE_COM: Timer COM event source  
   3780            *            @arg TIM_EVENTSOURCE_TRIGGER: Timer Trigger Event source
   3781            *            @arg TIM_EVENTSOURCE_BREAK: Timer Break event source
   3782            *            @arg TIM_EVENTSOURCE_BREAK2: Timer Break2 event source  
   3783            * @note   TIM6 and TIM7 can only generate an update event. 
   3784            * @note   TIM_EVENTSOURCE_COM, TIM_EVENTSOURCE_BREAK and TIM_EVENTSOURCE_BREAK2 are used only with TIM1 and TIM8.
   3785            * @retval HAL status
   3786            */ 
   3787          

   \                                 In section .text, align 2, keep-with-next
   3788          HAL_StatusTypeDef HAL_TIM_GenerateEvent(TIM_HandleTypeDef *htim, uint32_t EventSource)
   3789          {
   \                     HAL_TIM_GenerateEvent: (+1)
   \   00000000   0x0002             MOVS     R2,R0
   3790            /* Check the parameters */
   3791            assert_param(IS_TIM_INSTANCE(htim->Instance));
   3792            assert_param(IS_TIM_EVENT_SOURCE(EventSource));
   3793            
   3794            /* Process Locked */
   3795            __HAL_LOCK(htim);
   \   00000002   0xF892 0x0038      LDRB     R0,[R2, #+56]
   \   00000006   0x2801             CMP      R0,#+1
   \   00000008   0xD101             BNE.N    ??HAL_TIM_GenerateEvent_0
   \   0000000A   0x2002             MOVS     R0,#+2
   \   0000000C   0xE00E             B.N      ??HAL_TIM_GenerateEvent_1
   \                     ??HAL_TIM_GenerateEvent_0: (+1)
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0xF882 0x0038      STRB     R0,[R2, #+56]
   3796            
   3797            /* Change the TIM state */
   3798            htim->State = HAL_TIM_STATE_BUSY;
   \   00000014   0x2002             MOVS     R0,#+2
   \   00000016   0xF882 0x0039      STRB     R0,[R2, #+57]
   3799            
   3800            /* Set the event sources */
   3801            htim->Instance->EGR = EventSource;
   \   0000001A   0x6810             LDR      R0,[R2, #+0]
   \   0000001C   0x6141             STR      R1,[R0, #+20]
   3802            
   3803            /* Change the TIM state */
   3804            htim->State = HAL_TIM_STATE_READY;
   \   0000001E   0x2001             MOVS     R0,#+1
   \   00000020   0xF882 0x0039      STRB     R0,[R2, #+57]
   3805            
   3806            __HAL_UNLOCK(htim);
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0xF882 0x0038      STRB     R0,[R2, #+56]
   3807            
   3808            /* Return function status */
   3809            return HAL_OK;  
   \   0000002A   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_GenerateEvent_1: (+1)
   \   0000002C   0x4770             BX       LR               ;; return
   3810          }
   3811          
   3812          /**
   3813            * @brief  Configures the OCRef clear feature
   3814            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   3815            *                the configuration information for TIM module.
   3816            * @param  sClearInputConfig: pointer to a TIM_ClearInputConfigTypeDef structure that
   3817            *         contains the OCREF clear feature and parameters for the TIM peripheral. 
   3818            * @param  Channel: specifies the TIM Channel.
   3819            *          This parameter can be one of the following values:
   3820            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   3821            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   3822            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   3823            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   3824            * @retval HAL status
   3825            */ 

   \                                 In section .text, align 2, keep-with-next
   3826          __weak HAL_StatusTypeDef HAL_TIM_ConfigOCrefClear(TIM_HandleTypeDef *htim, TIM_ClearInputConfigTypeDef * sClearInputConfig, uint32_t Channel)
   3827          { 
   \                     HAL_TIM_ConfigOCrefClear: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   3828            /* Check the parameters */
   3829            assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   3830            assert_param(IS_TIM_CHANNELS(Channel));
   3831            assert_param(IS_TIM_CLEARINPUT_SOURCE(sClearInputConfig->ClearInputSource));
   3832             
   3833            /* Process Locked */
   3834            __HAL_LOCK(htim);
   \   00000008   0xF894 0x0038      LDRB     R0,[R4, #+56]
   \   0000000C   0x2801             CMP      R0,#+1
   \   0000000E   0xD101             BNE.N    ??HAL_TIM_ConfigOCrefClear_0
   \   00000010   0x2002             MOVS     R0,#+2
   \   00000012   0xE063             B.N      ??HAL_TIM_ConfigOCrefClear_1
   \                     ??HAL_TIM_ConfigOCrefClear_0: (+1)
   \   00000014   0x2001             MOVS     R0,#+1
   \   00000016   0xF884 0x0038      STRB     R0,[R4, #+56]
   3835            
   3836            htim->State = HAL_TIM_STATE_BUSY;
   \   0000001A   0x2002             MOVS     R0,#+2
   \   0000001C   0xF884 0x0039      STRB     R0,[R4, #+57]
   3837            
   3838            if(sClearInputConfig->ClearInputSource == TIM_CLEARINPUTSOURCE_ETR)
   \   00000020   0x6868             LDR      R0,[R5, #+4]
   \   00000022   0x2801             CMP      R0,#+1
   \   00000024   0xD105             BNE.N    ??HAL_TIM_ConfigOCrefClear_2
   3839            {
   3840              assert_param(IS_TIM_CLEARINPUT_POLARITY(sClearInputConfig->ClearInputPolarity));
   3841              assert_param(IS_TIM_CLEARINPUT_PRESCALER(sClearInputConfig->ClearInputPrescaler));
   3842              assert_param(IS_TIM_CLEARINPUT_FILTER(sClearInputConfig->ClearInputFilter));
   3843            
   3844              TIM_ETR_SetConfig(htim->Instance, 
   3845                                sClearInputConfig->ClearInputPrescaler,
   3846                                sClearInputConfig->ClearInputPolarity,
   3847                                sClearInputConfig->ClearInputFilter);
   \   00000026   0x692B             LDR      R3,[R5, #+16]
   \   00000028   0x68AA             LDR      R2,[R5, #+8]
   \   0000002A   0x68E9             LDR      R1,[R5, #+12]
   \   0000002C   0x6820             LDR      R0,[R4, #+0]
   \   0000002E   0x.... 0x....      BL       TIM_ETR_SetConfig
   3848            }
   3849            
   3850            switch (Channel)
   \                     ??HAL_TIM_ConfigOCrefClear_2: (+1)
   \   00000032   0x0030             MOVS     R0,R6
   \   00000034   0x2800             CMP      R0,#+0
   \   00000036   0xD006             BEQ.N    ??HAL_TIM_ConfigOCrefClear_3
   \   00000038   0x2804             CMP      R0,#+4
   \   0000003A   0xD015             BEQ.N    ??HAL_TIM_ConfigOCrefClear_4
   \   0000003C   0x2808             CMP      R0,#+8
   \   0000003E   0xD024             BEQ.N    ??HAL_TIM_ConfigOCrefClear_5
   \   00000040   0x280C             CMP      R0,#+12
   \   00000042   0xD033             BEQ.N    ??HAL_TIM_ConfigOCrefClear_6
   \   00000044   0xE043             B.N      ??HAL_TIM_ConfigOCrefClear_7
   3851            {
   3852              case TIM_CHANNEL_1:
   3853              {        
   3854                if(sClearInputConfig->ClearInputState != RESET)  
   \                     ??HAL_TIM_ConfigOCrefClear_3: (+1)
   \   00000046   0x6828             LDR      R0,[R5, #+0]
   \   00000048   0x2800             CMP      R0,#+0
   \   0000004A   0xD006             BEQ.N    ??HAL_TIM_ConfigOCrefClear_8
   3855                {
   3856                  /* Enable the Ocref clear feature for Channel 1 */
   3857                  htim->Instance->CCMR1 |= TIM_CCMR1_OC1CE;
   \   0000004C   0x6820             LDR      R0,[R4, #+0]
   \   0000004E   0x6980             LDR      R0,[R0, #+24]
   \   00000050   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   00000054   0x6821             LDR      R1,[R4, #+0]
   \   00000056   0x6188             STR      R0,[R1, #+24]
   \   00000058   0xE005             B.N      ??HAL_TIM_ConfigOCrefClear_9
   3858                }
   3859                else
   3860                {
   3861                  /* Disable the Ocref clear feature for Channel 1 */
   3862                  htim->Instance->CCMR1 &= ~TIM_CCMR1_OC1CE;      
   \                     ??HAL_TIM_ConfigOCrefClear_8: (+1)
   \   0000005A   0x6820             LDR      R0,[R4, #+0]
   \   0000005C   0x6980             LDR      R0,[R0, #+24]
   \   0000005E   0xF030 0x0080      BICS     R0,R0,#0x80
   \   00000062   0x6821             LDR      R1,[R4, #+0]
   \   00000064   0x6188             STR      R0,[R1, #+24]
   3863                }
   3864              }    
   3865              break;
   \                     ??HAL_TIM_ConfigOCrefClear_9: (+1)
   \   00000066   0xE032             B.N      ??HAL_TIM_ConfigOCrefClear_10
   3866              case TIM_CHANNEL_2:    
   3867              { 
   3868                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance)); 
   3869                if(sClearInputConfig->ClearInputState != RESET)  
   \                     ??HAL_TIM_ConfigOCrefClear_4: (+1)
   \   00000068   0x6828             LDR      R0,[R5, #+0]
   \   0000006A   0x2800             CMP      R0,#+0
   \   0000006C   0xD006             BEQ.N    ??HAL_TIM_ConfigOCrefClear_11
   3870                {
   3871                  /* Enable the Ocref clear feature for Channel 2 */
   3872                  htim->Instance->CCMR1 |= TIM_CCMR1_OC2CE;
   \   0000006E   0x6820             LDR      R0,[R4, #+0]
   \   00000070   0x6980             LDR      R0,[R0, #+24]
   \   00000072   0xF450 0x4000      ORRS     R0,R0,#0x8000
   \   00000076   0x6821             LDR      R1,[R4, #+0]
   \   00000078   0x6188             STR      R0,[R1, #+24]
   \   0000007A   0xE005             B.N      ??HAL_TIM_ConfigOCrefClear_12
   3873                }
   3874                else
   3875                {
   3876                  /* Disable the Ocref clear feature for Channel 2 */
   3877                  htim->Instance->CCMR1 &= ~TIM_CCMR1_OC2CE;      
   \                     ??HAL_TIM_ConfigOCrefClear_11: (+1)
   \   0000007C   0x6820             LDR      R0,[R4, #+0]
   \   0000007E   0x6980             LDR      R0,[R0, #+24]
   \   00000080   0xF430 0x4000      BICS     R0,R0,#0x8000
   \   00000084   0x6821             LDR      R1,[R4, #+0]
   \   00000086   0x6188             STR      R0,[R1, #+24]
   3878                }
   3879              } 
   3880              break;
   \                     ??HAL_TIM_ConfigOCrefClear_12: (+1)
   \   00000088   0xE021             B.N      ??HAL_TIM_ConfigOCrefClear_10
   3881              case TIM_CHANNEL_3:   
   3882              {  
   3883                assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
   3884                if(sClearInputConfig->ClearInputState != RESET)  
   \                     ??HAL_TIM_ConfigOCrefClear_5: (+1)
   \   0000008A   0x6828             LDR      R0,[R5, #+0]
   \   0000008C   0x2800             CMP      R0,#+0
   \   0000008E   0xD006             BEQ.N    ??HAL_TIM_ConfigOCrefClear_13
   3885                {
   3886                  /* Enable the Ocref clear feature for Channel 3 */
   3887                  htim->Instance->CCMR2 |= TIM_CCMR2_OC3CE;
   \   00000090   0x6820             LDR      R0,[R4, #+0]
   \   00000092   0x69C0             LDR      R0,[R0, #+28]
   \   00000094   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   00000098   0x6821             LDR      R1,[R4, #+0]
   \   0000009A   0x61C8             STR      R0,[R1, #+28]
   \   0000009C   0xE005             B.N      ??HAL_TIM_ConfigOCrefClear_14
   3888                }
   3889                else
   3890                {
   3891                  /* Disable the Ocref clear feature for Channel 3 */
   3892                  htim->Instance->CCMR2 &= ~TIM_CCMR2_OC3CE;      
   \                     ??HAL_TIM_ConfigOCrefClear_13: (+1)
   \   0000009E   0x6820             LDR      R0,[R4, #+0]
   \   000000A0   0x69C0             LDR      R0,[R0, #+28]
   \   000000A2   0xF030 0x0080      BICS     R0,R0,#0x80
   \   000000A6   0x6821             LDR      R1,[R4, #+0]
   \   000000A8   0x61C8             STR      R0,[R1, #+28]
   3893                }
   3894              } 
   3895              break;
   \                     ??HAL_TIM_ConfigOCrefClear_14: (+1)
   \   000000AA   0xE010             B.N      ??HAL_TIM_ConfigOCrefClear_10
   3896              case TIM_CHANNEL_4:    
   3897              {  
   3898                assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
   3899                if(sClearInputConfig->ClearInputState != RESET)  
   \                     ??HAL_TIM_ConfigOCrefClear_6: (+1)
   \   000000AC   0x6828             LDR      R0,[R5, #+0]
   \   000000AE   0x2800             CMP      R0,#+0
   \   000000B0   0xD006             BEQ.N    ??HAL_TIM_ConfigOCrefClear_15
   3900                {
   3901                  /* Enable the Ocref clear feature for Channel 4 */
   3902                  htim->Instance->CCMR2 |= TIM_CCMR2_OC4CE;
   \   000000B2   0x6820             LDR      R0,[R4, #+0]
   \   000000B4   0x69C0             LDR      R0,[R0, #+28]
   \   000000B6   0xF450 0x4000      ORRS     R0,R0,#0x8000
   \   000000BA   0x6821             LDR      R1,[R4, #+0]
   \   000000BC   0x61C8             STR      R0,[R1, #+28]
   \   000000BE   0xE005             B.N      ??HAL_TIM_ConfigOCrefClear_16
   3903                }
   3904                else
   3905                {
   3906                  /* Disable the Ocref clear feature for Channel 4 */
   3907                  htim->Instance->CCMR2 &= ~TIM_CCMR2_OC4CE;      
   \                     ??HAL_TIM_ConfigOCrefClear_15: (+1)
   \   000000C0   0x6820             LDR      R0,[R4, #+0]
   \   000000C2   0x69C0             LDR      R0,[R0, #+28]
   \   000000C4   0xF430 0x4000      BICS     R0,R0,#0x8000
   \   000000C8   0x6821             LDR      R1,[R4, #+0]
   \   000000CA   0x61C8             STR      R0,[R1, #+28]
   3908                }
   3909              } 
   3910              break;
   \                     ??HAL_TIM_ConfigOCrefClear_16: (+1)
   \   000000CC   0xE7FF             B.N      ??HAL_TIM_ConfigOCrefClear_10
   3911              default:  
   3912              break;
   3913            } 
   3914          
   3915            htim->State = HAL_TIM_STATE_READY;
   \                     ??HAL_TIM_ConfigOCrefClear_7: (+1)
   \                     ??HAL_TIM_ConfigOCrefClear_10: (+1)
   \   000000CE   0x2001             MOVS     R0,#+1
   \   000000D0   0xF884 0x0039      STRB     R0,[R4, #+57]
   3916            
   3917            __HAL_UNLOCK(htim);
   \   000000D4   0x2000             MOVS     R0,#+0
   \   000000D6   0xF884 0x0038      STRB     R0,[R4, #+56]
   3918            
   3919            return HAL_OK;  
   \   000000DA   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_ConfigOCrefClear_1: (+1)
   \   000000DC   0xBD70             POP      {R4-R6,PC}       ;; return
   3920          }  
   3921          
   3922          /**
   3923            * @brief   Configures the clock source to be used
   3924            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   3925            *                the configuration information for TIM module.
   3926            * @param  sClockSourceConfig: pointer to a TIM_ClockConfigTypeDef structure that
   3927            *         contains the clock source information for the TIM peripheral. 
   3928            * @retval HAL status
   3929            */ 

   \                                 In section .text, align 2, keep-with-next
   3930          HAL_StatusTypeDef HAL_TIM_ConfigClockSource(TIM_HandleTypeDef *htim, TIM_ClockConfigTypeDef * sClockSourceConfig)    
   3931          {
   \                     HAL_TIM_ConfigClockSource: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   3932            uint32_t tmpsmcr = 0;
   \   00000006   0x2600             MOVS     R6,#+0
   3933              
   3934            /* Process Locked */
   3935            __HAL_LOCK(htim);
   \   00000008   0xF894 0x0038      LDRB     R0,[R4, #+56]
   \   0000000C   0x2801             CMP      R0,#+1
   \   0000000E   0xD101             BNE.N    ??HAL_TIM_ConfigClockSource_0
   \   00000010   0x2002             MOVS     R0,#+2
   \   00000012   0xE086             B.N      ??HAL_TIM_ConfigClockSource_1
   \                     ??HAL_TIM_ConfigClockSource_0: (+1)
   \   00000014   0x2001             MOVS     R0,#+1
   \   00000016   0xF884 0x0038      STRB     R0,[R4, #+56]
   3936            
   3937            htim->State = HAL_TIM_STATE_BUSY;
   \   0000001A   0x2002             MOVS     R0,#+2
   \   0000001C   0xF884 0x0039      STRB     R0,[R4, #+57]
   3938            
   3939            /* Check the parameters */
   3940            assert_param(IS_TIM_CLOCKSOURCE(sClockSourceConfig->ClockSource));
   3941            assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
   3942            assert_param(IS_TIM_CLOCKPRESCALER(sClockSourceConfig->ClockPrescaler));
   3943            assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
   3944            
   3945            /* Reset the SMS, TS, ECE, ETPS and ETRF bits */
   3946            tmpsmcr = htim->Instance->SMCR;
   \   00000020   0x6820             LDR      R0,[R4, #+0]
   \   00000022   0x6880             LDR      R0,[R0, #+8]
   \   00000024   0x0006             MOVS     R6,R0
   3947            tmpsmcr &= ~(TIM_SMCR_SMS | TIM_SMCR_TS);
   \   00000026   0x.... 0x....      LDR.W    R0,??DataTable31_2  ;; 0xfffeff88
   \   0000002A   0x4006             ANDS     R6,R0,R6
   3948            tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
   \   0000002C   0xF436 0x467F      BICS     R6,R6,#0xFF00
   3949            htim->Instance->SMCR = tmpsmcr;
   \   00000030   0x6820             LDR      R0,[R4, #+0]
   \   00000032   0x6086             STR      R6,[R0, #+8]
   3950            
   3951            switch (sClockSourceConfig->ClockSource)
   \   00000034   0x6828             LDR      R0,[R5, #+0]
   \   00000036   0x2800             CMP      R0,#+0
   \   00000038   0xD058             BEQ.N    ??HAL_TIM_ConfigClockSource_2
   \   0000003A   0x2810             CMP      R0,#+16
   \   0000003C   0xD05B             BEQ.N    ??HAL_TIM_ConfigClockSource_3
   \   0000003E   0x2820             CMP      R0,#+32
   \   00000040   0xD05E             BEQ.N    ??HAL_TIM_ConfigClockSource_4
   \   00000042   0x2830             CMP      R0,#+48
   \   00000044   0xD061             BEQ.N    ??HAL_TIM_ConfigClockSource_5
   \   00000046   0x2840             CMP      R0,#+64
   \   00000048   0xD046             BEQ.N    ??HAL_TIM_ConfigClockSource_6
   \   0000004A   0x2850             CMP      R0,#+80
   \   0000004C   0xD030             BEQ.N    ??HAL_TIM_ConfigClockSource_7
   \   0000004E   0x2860             CMP      R0,#+96
   \   00000050   0xD038             BEQ.N    ??HAL_TIM_ConfigClockSource_8
   \   00000052   0x2870             CMP      R0,#+112
   \   00000054   0xD00E             BEQ.N    ??HAL_TIM_ConfigClockSource_9
   \   00000056   0xF5B0 0x5F80      CMP      R0,#+4096
   \   0000005A   0xD003             BEQ.N    ??HAL_TIM_ConfigClockSource_10
   \   0000005C   0xF5B0 0x5F00      CMP      R0,#+8192
   \   00000060   0xD019             BEQ.N    ??HAL_TIM_ConfigClockSource_11
   \   00000062   0xE057             B.N      ??HAL_TIM_ConfigClockSource_12
   3952            {
   3953              case TIM_CLOCKSOURCE_INTERNAL:
   3954              { 
   3955                assert_param(IS_TIM_INSTANCE(htim->Instance));      
   3956                /* Disable slave mode to clock the prescaler directly with the internal clock */
   3957                htim->Instance->SMCR &= ~TIM_SMCR_SMS;
   \                     ??HAL_TIM_ConfigClockSource_10: (+1)
   \   00000064   0x6820             LDR      R0,[R4, #+0]
   \   00000066   0x6880             LDR      R0,[R0, #+8]
   \   00000068   0x.... 0x....      LDR.W    R1,??DataTable31  ;; 0xfffefff8
   \   0000006C   0x4008             ANDS     R0,R1,R0
   \   0000006E   0x6821             LDR      R1,[R4, #+0]
   \   00000070   0x6088             STR      R0,[R1, #+8]
   3958              }
   3959              break;
   \   00000072   0xE04F             B.N      ??HAL_TIM_ConfigClockSource_13
   3960              
   3961              case TIM_CLOCKSOURCE_ETRMODE1:
   3962              {
   3963                assert_param(IS_TIM_ETR_INSTANCE(htim->Instance));
   3964                /* Configure the ETR Clock source */
   3965                TIM_ETR_SetConfig(htim->Instance, 
   3966                                  sClockSourceConfig->ClockPrescaler, 
   3967                                  sClockSourceConfig->ClockPolarity, 
   3968                                  sClockSourceConfig->ClockFilter);
   \                     ??HAL_TIM_ConfigClockSource_9: (+1)
   \   00000074   0x68EB             LDR      R3,[R5, #+12]
   \   00000076   0x686A             LDR      R2,[R5, #+4]
   \   00000078   0x68A9             LDR      R1,[R5, #+8]
   \   0000007A   0x6820             LDR      R0,[R4, #+0]
   \   0000007C   0x.... 0x....      BL       TIM_ETR_SetConfig
   3969                /* Get the TIMx SMCR register value */
   3970                tmpsmcr = htim->Instance->SMCR;
   \   00000080   0x6820             LDR      R0,[R4, #+0]
   \   00000082   0x6880             LDR      R0,[R0, #+8]
   \   00000084   0x0006             MOVS     R6,R0
   3971                /* Reset the SMS and TS Bits */
   3972                tmpsmcr &= ~(TIM_SMCR_SMS | TIM_SMCR_TS);
   \   00000086   0x.... 0x....      LDR.W    R0,??DataTable31_2  ;; 0xfffeff88
   \   0000008A   0x4006             ANDS     R6,R0,R6
   3973                /* Select the External clock mode1 and the ETRF trigger */
   3974                tmpsmcr |= (TIM_SLAVEMODE_EXTERNAL1 | TIM_CLOCKSOURCE_ETRMODE1);
   \   0000008C   0xF056 0x0677      ORRS     R6,R6,#0x77
   3975                /* Write to TIMx SMCR */
   3976                htim->Instance->SMCR = tmpsmcr;
   \   00000090   0x6820             LDR      R0,[R4, #+0]
   \   00000092   0x6086             STR      R6,[R0, #+8]
   3977              }
   3978              break;
   \   00000094   0xE03E             B.N      ??HAL_TIM_ConfigClockSource_13
   3979              
   3980              case TIM_CLOCKSOURCE_ETRMODE2:
   3981              {
   3982                assert_param(IS_TIM_ETR_INSTANCE(htim->Instance));
   3983                /* Configure the ETR Clock source */
   3984                TIM_ETR_SetConfig(htim->Instance, 
   3985                                  sClockSourceConfig->ClockPrescaler, 
   3986                                  sClockSourceConfig->ClockPolarity,
   3987                                  sClockSourceConfig->ClockFilter);
   \                     ??HAL_TIM_ConfigClockSource_11: (+1)
   \   00000096   0x68EB             LDR      R3,[R5, #+12]
   \   00000098   0x686A             LDR      R2,[R5, #+4]
   \   0000009A   0x68A9             LDR      R1,[R5, #+8]
   \   0000009C   0x6820             LDR      R0,[R4, #+0]
   \   0000009E   0x.... 0x....      BL       TIM_ETR_SetConfig
   3988                /* Enable the External clock mode2 */
   3989                htim->Instance->SMCR |= TIM_SMCR_ECE;
   \   000000A2   0x6820             LDR      R0,[R4, #+0]
   \   000000A4   0x6880             LDR      R0,[R0, #+8]
   \   000000A6   0xF450 0x4080      ORRS     R0,R0,#0x4000
   \   000000AA   0x6821             LDR      R1,[R4, #+0]
   \   000000AC   0x6088             STR      R0,[R1, #+8]
   3990              }
   3991              break;
   \   000000AE   0xE031             B.N      ??HAL_TIM_ConfigClockSource_13
   3992              
   3993              case TIM_CLOCKSOURCE_TI1:
   3994              {
   3995                assert_param(IS_TIM_CLOCKSOURCE_TIX_INSTANCE(htim->Instance));
   3996                TIM_TI1_ConfigInputStage(htim->Instance, 
   3997                                  sClockSourceConfig->ClockPolarity, 
   3998                                  sClockSourceConfig->ClockFilter);
   \                     ??HAL_TIM_ConfigClockSource_7: (+1)
   \   000000B0   0x68EA             LDR      R2,[R5, #+12]
   \   000000B2   0x6869             LDR      R1,[R5, #+4]
   \   000000B4   0x6820             LDR      R0,[R4, #+0]
   \   000000B6   0x.... 0x....      BL       TIM_TI1_ConfigInputStage
   3999                TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI1);
   \   000000BA   0x2150             MOVS     R1,#+80
   \   000000BC   0x6820             LDR      R0,[R4, #+0]
   \   000000BE   0x.... 0x....      BL       TIM_ITRx_SetConfig
   4000              }
   4001              break;
   \   000000C2   0xE027             B.N      ??HAL_TIM_ConfigClockSource_13
   4002              case TIM_CLOCKSOURCE_TI2:
   4003              {
   4004                assert_param(IS_TIM_CLOCKSOURCE_TIX_INSTANCE(htim->Instance));
   4005                TIM_TI2_ConfigInputStage(htim->Instance, 
   4006                                  sClockSourceConfig->ClockPolarity, 
   4007                                  sClockSourceConfig->ClockFilter);
   \                     ??HAL_TIM_ConfigClockSource_8: (+1)
   \   000000C4   0x68EA             LDR      R2,[R5, #+12]
   \   000000C6   0x6869             LDR      R1,[R5, #+4]
   \   000000C8   0x6820             LDR      R0,[R4, #+0]
   \   000000CA   0x.... 0x....      BL       TIM_TI2_ConfigInputStage
   4008                TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI2);
   \   000000CE   0x2160             MOVS     R1,#+96
   \   000000D0   0x6820             LDR      R0,[R4, #+0]
   \   000000D2   0x.... 0x....      BL       TIM_ITRx_SetConfig
   4009              }
   4010              break;
   \   000000D6   0xE01D             B.N      ??HAL_TIM_ConfigClockSource_13
   4011              case TIM_CLOCKSOURCE_TI1ED:
   4012              {
   4013                assert_param(IS_TIM_CLOCKSOURCE_TIX_INSTANCE(htim->Instance));
   4014                TIM_TI1_ConfigInputStage(htim->Instance, 
   4015                                  sClockSourceConfig->ClockPolarity,
   4016                                  sClockSourceConfig->ClockFilter);
   \                     ??HAL_TIM_ConfigClockSource_6: (+1)
   \   000000D8   0x68EA             LDR      R2,[R5, #+12]
   \   000000DA   0x6869             LDR      R1,[R5, #+4]
   \   000000DC   0x6820             LDR      R0,[R4, #+0]
   \   000000DE   0x.... 0x....      BL       TIM_TI1_ConfigInputStage
   4017                TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI1ED);
   \   000000E2   0x2140             MOVS     R1,#+64
   \   000000E4   0x6820             LDR      R0,[R4, #+0]
   \   000000E6   0x.... 0x....      BL       TIM_ITRx_SetConfig
   4018              }
   4019              break;
   \   000000EA   0xE013             B.N      ??HAL_TIM_ConfigClockSource_13
   4020              case TIM_CLOCKSOURCE_ITR0:
   4021              {
   4022                assert_param(IS_TIM_CLOCKSOURCE_ITRX_INSTANCE(htim->Instance));
   4023                TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_ITR0);
   \                     ??HAL_TIM_ConfigClockSource_2: (+1)
   \   000000EC   0x2100             MOVS     R1,#+0
   \   000000EE   0x6820             LDR      R0,[R4, #+0]
   \   000000F0   0x.... 0x....      BL       TIM_ITRx_SetConfig
   4024              }
   4025              break;
   \   000000F4   0xE00E             B.N      ??HAL_TIM_ConfigClockSource_13
   4026              case TIM_CLOCKSOURCE_ITR1:
   4027              {
   4028                assert_param(IS_TIM_CLOCKSOURCE_ITRX_INSTANCE(htim->Instance));
   4029                TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_ITR1);
   \                     ??HAL_TIM_ConfigClockSource_3: (+1)
   \   000000F6   0x2110             MOVS     R1,#+16
   \   000000F8   0x6820             LDR      R0,[R4, #+0]
   \   000000FA   0x.... 0x....      BL       TIM_ITRx_SetConfig
   4030              }
   4031              break;
   \   000000FE   0xE009             B.N      ??HAL_TIM_ConfigClockSource_13
   4032              case TIM_CLOCKSOURCE_ITR2:
   4033              {
   4034                assert_param(IS_TIM_CLOCKSOURCE_ITRX_INSTANCE(htim->Instance));
   4035                TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_ITR2);
   \                     ??HAL_TIM_ConfigClockSource_4: (+1)
   \   00000100   0x2120             MOVS     R1,#+32
   \   00000102   0x6820             LDR      R0,[R4, #+0]
   \   00000104   0x.... 0x....      BL       TIM_ITRx_SetConfig
   4036              }
   4037              break;
   \   00000108   0xE004             B.N      ??HAL_TIM_ConfigClockSource_13
   4038              case TIM_CLOCKSOURCE_ITR3:
   4039              {
   4040                assert_param(IS_TIM_CLOCKSOURCE_ITRX_INSTANCE(htim->Instance));
   4041                TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_ITR3);
   \                     ??HAL_TIM_ConfigClockSource_5: (+1)
   \   0000010A   0x2130             MOVS     R1,#+48
   \   0000010C   0x6820             LDR      R0,[R4, #+0]
   \   0000010E   0x.... 0x....      BL       TIM_ITRx_SetConfig
   4042              }
   4043              break;
   \   00000112   0xE7FF             B.N      ??HAL_TIM_ConfigClockSource_13
   4044              
   4045              default:
   4046              break;    
   4047            }
   4048            htim->State = HAL_TIM_STATE_READY;
   \                     ??HAL_TIM_ConfigClockSource_12: (+1)
   \                     ??HAL_TIM_ConfigClockSource_13: (+1)
   \   00000114   0x2001             MOVS     R0,#+1
   \   00000116   0xF884 0x0039      STRB     R0,[R4, #+57]
   4049            
   4050            __HAL_UNLOCK(htim);
   \   0000011A   0x2000             MOVS     R0,#+0
   \   0000011C   0xF884 0x0038      STRB     R0,[R4, #+56]
   4051            
   4052            return HAL_OK;
   \   00000120   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_ConfigClockSource_1: (+1)
   \   00000122   0xBD70             POP      {R4-R6,PC}       ;; return
   4053          }
   4054          
   4055          /**
   4056            * @brief  Selects the signal connected to the TI1 input: direct from CH1_input
   4057            *         or a XOR combination between CH1_input, CH2_input & CH3_input
   4058            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   4059            *                the configuration information for TIM module.
   4060            * @param  TI1_Selection: Indicate whether or not channel 1 is connected to the
   4061            *         output of a XOR gate.
   4062            *         This parameter can be one of the following values:
   4063            *            @arg TIM_TI1SELECTION_CH1: The TIMx_CH1 pin is connected to TI1 input
   4064            *            @arg TIM_TI1SELECTION_XORCOMBINATION: The TIMx_CH1, CH2 and CH3
   4065            *            pins are connected to the TI1 input (XOR combination)
   4066            * @retval HAL status
   4067            */

   \                                 In section .text, align 2, keep-with-next
   4068          HAL_StatusTypeDef HAL_TIM_ConfigTI1Input(TIM_HandleTypeDef *htim, uint32_t TI1_Selection)
   4069          {
   \                     HAL_TIM_ConfigTI1Input: (+1)
   \   00000000   0x0002             MOVS     R2,R0
   4070            uint32_t tmpcr2 = 0;
   \   00000002   0x2300             MOVS     R3,#+0
   4071            
   4072            /* Check the parameters */
   4073            assert_param(IS_TIM_XOR_INSTANCE(htim->Instance)); 
   4074            assert_param(IS_TIM_TI1SELECTION(TI1_Selection));
   4075          
   4076            /* Get the TIMx CR2 register value */
   4077            tmpcr2 = htim->Instance->CR2;
   \   00000004   0x6810             LDR      R0,[R2, #+0]
   \   00000006   0x6840             LDR      R0,[R0, #+4]
   \   00000008   0x0003             MOVS     R3,R0
   4078          
   4079            /* Reset the TI1 selection */
   4080            tmpcr2 &= ~TIM_CR2_TI1S;
   \   0000000A   0xF033 0x0380      BICS     R3,R3,#0x80
   4081          
   4082            /* Set the TI1 selection */
   4083            tmpcr2 |= TI1_Selection;
   \   0000000E   0x430B             ORRS     R3,R1,R3
   4084            
   4085            /* Write to TIMxCR2 */
   4086            htim->Instance->CR2 = tmpcr2;
   \   00000010   0x6810             LDR      R0,[R2, #+0]
   \   00000012   0x6043             STR      R3,[R0, #+4]
   4087          
   4088            return HAL_OK;
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0x4770             BX       LR               ;; return
   4089          }
   4090          
   4091          /**
   4092            * @brief  Configures the TIM in Slave mode
   4093            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   4094            *                the configuration information for TIM module.
   4095            * @param  sSlaveConfig: pointer to a TIM_SlaveConfigTypeDef structure that
   4096            *         contains the selected trigger (internal trigger input, filtered
   4097            *         timer input or external trigger input) and the ) and the Slave 
   4098            *         mode (Disable, Reset, Gated, Trigger, External clock mode 1). 
   4099            * @retval HAL status
   4100            */

   \                                 In section .text, align 2, keep-with-next
   4101          HAL_StatusTypeDef HAL_TIM_SlaveConfigSynchronization(TIM_HandleTypeDef *htim, TIM_SlaveConfigTypeDef * sSlaveConfig)
   4102          {
   \                     HAL_TIM_SlaveConfigSynchronization: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   4103            uint32_t tmpsmcr  = 0;
   \   00000008   0x2600             MOVS     R6,#+0
   4104            uint32_t tmpccmr1 = 0;
   \   0000000A   0x2700             MOVS     R7,#+0
   4105            uint32_t tmpccer = 0;
   \   0000000C   0xF05F 0x0800      MOVS     R8,#+0
   4106          
   4107            /* Check the parameters */
   4108            assert_param(IS_TIM_SLAVE_INSTANCE(htim->Instance));
   4109            assert_param(IS_TIM_SLAVE_MODE(sSlaveConfig->SlaveMode));
   4110            assert_param(IS_TIM_TRIGGER_SELECTION(sSlaveConfig->InputTrigger));
   4111             
   4112            __HAL_LOCK(htim);
   \   00000010   0xF894 0x0038      LDRB     R0,[R4, #+56]
   \   00000014   0x2801             CMP      R0,#+1
   \   00000016   0xD101             BNE.N    ??HAL_TIM_SlaveConfigSynchronization_0
   \   00000018   0x2002             MOVS     R0,#+2
   \   0000001A   0xE059             B.N      ??HAL_TIM_SlaveConfigSynchronization_1
   \                     ??HAL_TIM_SlaveConfigSynchronization_0: (+1)
   \   0000001C   0x2001             MOVS     R0,#+1
   \   0000001E   0xF884 0x0038      STRB     R0,[R4, #+56]
   4113            
   4114            htim->State = HAL_TIM_STATE_BUSY;
   \   00000022   0x2002             MOVS     R0,#+2
   \   00000024   0xF884 0x0039      STRB     R0,[R4, #+57]
   4115          
   4116            /* Get the TIMx SMCR register value */
   4117            tmpsmcr = htim->Instance->SMCR;
   \   00000028   0x6820             LDR      R0,[R4, #+0]
   \   0000002A   0x6880             LDR      R0,[R0, #+8]
   \   0000002C   0x0006             MOVS     R6,R0
   4118          
   4119            /* Reset the Trigger Selection Bits */
   4120            tmpsmcr &= ~TIM_SMCR_TS;
   \   0000002E   0xF036 0x0670      BICS     R6,R6,#0x70
   4121            /* Set the Input Trigger source */
   4122            tmpsmcr |= sSlaveConfig->InputTrigger;
   \   00000032   0x6868             LDR      R0,[R5, #+4]
   \   00000034   0x4306             ORRS     R6,R0,R6
   4123          
   4124            /* Reset the slave mode Bits */
   4125            tmpsmcr &= ~TIM_SMCR_SMS;
   \   00000036   0x.... 0x....      LDR.W    R0,??DataTable31  ;; 0xfffefff8
   \   0000003A   0x4006             ANDS     R6,R0,R6
   4126            /* Set the slave mode */
   4127            tmpsmcr |= sSlaveConfig->SlaveMode;
   \   0000003C   0x6828             LDR      R0,[R5, #+0]
   \   0000003E   0x4306             ORRS     R6,R0,R6
   4128          
   4129            /* Write to TIMx SMCR */
   4130            htim->Instance->SMCR = tmpsmcr;
   \   00000040   0x6820             LDR      R0,[R4, #+0]
   \   00000042   0x6086             STR      R6,[R0, #+8]
   4131            
   4132            /* Configure the trigger prescaler, filter, and polarity */
   4133            switch (sSlaveConfig->InputTrigger)
   \   00000044   0x6868             LDR      R0,[R5, #+4]
   \   00000046   0x2800             CMP      R0,#+0
   \   00000048   0xD037             BEQ.N    ??HAL_TIM_SlaveConfigSynchronization_2
   \   0000004A   0x2810             CMP      R0,#+16
   \   0000004C   0xD036             BEQ.N    ??HAL_TIM_SlaveConfigSynchronization_3
   \   0000004E   0x2820             CMP      R0,#+32
   \   00000050   0xD035             BEQ.N    ??HAL_TIM_SlaveConfigSynchronization_4
   \   00000052   0x2830             CMP      R0,#+48
   \   00000054   0xD034             BEQ.N    ??HAL_TIM_SlaveConfigSynchronization_5
   \   00000056   0x2840             CMP      R0,#+64
   \   00000058   0xD00C             BEQ.N    ??HAL_TIM_SlaveConfigSynchronization_6
   \   0000005A   0x2850             CMP      R0,#+80
   \   0000005C   0xD021             BEQ.N    ??HAL_TIM_SlaveConfigSynchronization_7
   \   0000005E   0x2860             CMP      R0,#+96
   \   00000060   0xD025             BEQ.N    ??HAL_TIM_SlaveConfigSynchronization_8
   \   00000062   0x2870             CMP      R0,#+112
   \   00000064   0xD12D             BNE.N    ??HAL_TIM_SlaveConfigSynchronization_9
   4134            {
   4135            case TIM_TS_ETRF:
   4136              {
   4137                /* Check the parameters */
   4138                assert_param(IS_TIM_ETR_INSTANCE(htim->Instance));
   4139                assert_param(IS_TIM_TRIGGERPRESCALER(sSlaveConfig->TriggerPrescaler));
   4140                assert_param(IS_TIM_TRIGGERPOLARITY(sSlaveConfig->TriggerPolarity));
   4141                assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
   4142                /* Configure the ETR Trigger source */
   4143                TIM_ETR_SetConfig(htim->Instance, 
   4144                                  sSlaveConfig->TriggerPrescaler, 
   4145                                  sSlaveConfig->TriggerPolarity, 
   4146                                  sSlaveConfig->TriggerFilter);
   \                     ??HAL_TIM_SlaveConfigSynchronization_10: (+1)
   \   00000066   0x692B             LDR      R3,[R5, #+16]
   \   00000068   0x68AA             LDR      R2,[R5, #+8]
   \   0000006A   0x68E9             LDR      R1,[R5, #+12]
   \   0000006C   0x6820             LDR      R0,[R4, #+0]
   \   0000006E   0x.... 0x....      BL       TIM_ETR_SetConfig
   4147              }
   4148              break;
   \   00000072   0xE026             B.N      ??HAL_TIM_SlaveConfigSynchronization_11
   4149              
   4150            case TIM_TS_TI1F_ED:
   4151              {
   4152                /* Check the parameters */
   4153                assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   4154                assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
   4155                
   4156                /* Disable the Channel 1: Reset the CC1E Bit */
   4157                tmpccer = htim->Instance->CCER;
   \                     ??HAL_TIM_SlaveConfigSynchronization_6: (+1)
   \   00000074   0x6820             LDR      R0,[R4, #+0]
   \   00000076   0x6A00             LDR      R0,[R0, #+32]
   \   00000078   0x4680             MOV      R8,R0
   4158                htim->Instance->CCER &= ~TIM_CCER_CC1E;
   \   0000007A   0x6820             LDR      R0,[R4, #+0]
   \   0000007C   0x6A00             LDR      R0,[R0, #+32]
   \   0000007E   0x0840             LSRS     R0,R0,#+1
   \   00000080   0x0040             LSLS     R0,R0,#+1
   \   00000082   0x6821             LDR      R1,[R4, #+0]
   \   00000084   0x6208             STR      R0,[R1, #+32]
   4159                tmpccmr1 = htim->Instance->CCMR1;    
   \   00000086   0x6820             LDR      R0,[R4, #+0]
   \   00000088   0x6980             LDR      R0,[R0, #+24]
   \   0000008A   0x0007             MOVS     R7,R0
   4160                
   4161                /* Set the filter */
   4162                tmpccmr1 &= ~TIM_CCMR1_IC1F;
   \   0000008C   0xF037 0x07F0      BICS     R7,R7,#0xF0
   4163                tmpccmr1 |= ((sSlaveConfig->TriggerFilter) << 4);
   \   00000090   0x6928             LDR      R0,[R5, #+16]
   \   00000092   0xEA57 0x1700      ORRS     R7,R7,R0, LSL #+4
   4164                
   4165                /* Write to TIMx CCMR1 and CCER registers */
   4166                htim->Instance->CCMR1 = tmpccmr1;
   \   00000096   0x6820             LDR      R0,[R4, #+0]
   \   00000098   0x6187             STR      R7,[R0, #+24]
   4167                htim->Instance->CCER = tmpccer;                               
   \   0000009A   0x6820             LDR      R0,[R4, #+0]
   \   0000009C   0xF8C0 0x8020      STR      R8,[R0, #+32]
   4168                                         
   4169              }
   4170              break;
   \   000000A0   0xE00F             B.N      ??HAL_TIM_SlaveConfigSynchronization_11
   4171              
   4172            case TIM_TS_TI1FP1:
   4173              {
   4174                /* Check the parameters */
   4175                assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   4176                assert_param(IS_TIM_TRIGGERPOLARITY(sSlaveConfig->TriggerPolarity));
   4177                assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
   4178          
   4179                /* Configure TI1 Filter and Polarity */
   4180                TIM_TI1_ConfigInputStage(htim->Instance,
   4181                                         sSlaveConfig->TriggerPolarity,
   4182                                         sSlaveConfig->TriggerFilter);
   \                     ??HAL_TIM_SlaveConfigSynchronization_7: (+1)
   \   000000A2   0x692A             LDR      R2,[R5, #+16]
   \   000000A4   0x68A9             LDR      R1,[R5, #+8]
   \   000000A6   0x6820             LDR      R0,[R4, #+0]
   \   000000A8   0x.... 0x....      BL       TIM_TI1_ConfigInputStage
   4183              }
   4184              break;
   \   000000AC   0xE009             B.N      ??HAL_TIM_SlaveConfigSynchronization_11
   4185              
   4186            case TIM_TS_TI2FP2:
   4187              {
   4188                /* Check the parameters */
   4189                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   4190                assert_param(IS_TIM_TRIGGERPOLARITY(sSlaveConfig->TriggerPolarity));
   4191                assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
   4192                
   4193                /* Configure TI2 Filter and Polarity */
   4194                TIM_TI2_ConfigInputStage(htim->Instance,
   4195                                          sSlaveConfig->TriggerPolarity,
   4196                                          sSlaveConfig->TriggerFilter);
   \                     ??HAL_TIM_SlaveConfigSynchronization_8: (+1)
   \   000000AE   0x692A             LDR      R2,[R5, #+16]
   \   000000B0   0x68A9             LDR      R1,[R5, #+8]
   \   000000B2   0x6820             LDR      R0,[R4, #+0]
   \   000000B4   0x.... 0x....      BL       TIM_TI2_ConfigInputStage
   4197              }
   4198              break;
   \   000000B8   0xE003             B.N      ??HAL_TIM_SlaveConfigSynchronization_11
   4199              
   4200            case TIM_TS_ITR0:
   4201              {
   4202                /* Check the parameter */
   4203                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   4204              }
   4205              break;
   \                     ??HAL_TIM_SlaveConfigSynchronization_2: (+1)
   \   000000BA   0xE002             B.N      ??HAL_TIM_SlaveConfigSynchronization_11
   4206              
   4207            case TIM_TS_ITR1:
   4208              {
   4209                /* Check the parameter */
   4210                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   4211              }
   4212              break;
   \                     ??HAL_TIM_SlaveConfigSynchronization_3: (+1)
   \   000000BC   0xE001             B.N      ??HAL_TIM_SlaveConfigSynchronization_11
   4213              
   4214            case TIM_TS_ITR2:
   4215              {
   4216                /* Check the parameter */
   4217                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   4218              }
   4219              break;
   \                     ??HAL_TIM_SlaveConfigSynchronization_4: (+1)
   \   000000BE   0xE000             B.N      ??HAL_TIM_SlaveConfigSynchronization_11
   4220              
   4221            case TIM_TS_ITR3:
   4222              {
   4223                /* Check the parameter */
   4224                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   4225              }
   4226              break;
   \                     ??HAL_TIM_SlaveConfigSynchronization_5: (+1)
   \   000000C0   0xE7FF             B.N      ??HAL_TIM_SlaveConfigSynchronization_11
   4227                 
   4228            default:
   4229              break;
   4230            }
   4231            
   4232            htim->State = HAL_TIM_STATE_READY;
   \                     ??HAL_TIM_SlaveConfigSynchronization_9: (+1)
   \                     ??HAL_TIM_SlaveConfigSynchronization_11: (+1)
   \   000000C2   0x2001             MOVS     R0,#+1
   \   000000C4   0xF884 0x0039      STRB     R0,[R4, #+57]
   4233               
   4234            __HAL_UNLOCK(htim);  
   \   000000C8   0x2000             MOVS     R0,#+0
   \   000000CA   0xF884 0x0038      STRB     R0,[R4, #+56]
   4235            
   4236            return HAL_OK;
   \   000000CE   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_SlaveConfigSynchronization_1: (+1)
   \   000000D0   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   4237          } 
   4238          
   4239          /**
   4240            * @brief  Configures the TIM in Slave mode in interrupt mode
   4241            * @param  htim: TIM handle.
   4242            * @param  sSlaveConfig: pointer to a TIM_SlaveConfigTypeDef structure that
   4243            *         contains the selected trigger (internal trigger input, filtered
   4244            *         timer input or external trigger input) and the ) and the Slave 
   4245            *         mode (Disable, Reset, Gated, Trigger, External clock mode 1). 
   4246            * @retval HAL status
   4247            */

   \                                 In section .text, align 2, keep-with-next
   4248          HAL_StatusTypeDef HAL_TIM_SlaveConfigSynchronization_IT(TIM_HandleTypeDef *htim, 
   4249                                                                  TIM_SlaveConfigTypeDef * sSlaveConfig)
   4250          {
   \                     HAL_TIM_SlaveConfigSynchronization_IT: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   4251            /* Check the parameters */
   4252            assert_param(IS_TIM_SLAVE_INSTANCE(htim->Instance));
   4253            assert_param(IS_TIM_SLAVE_MODE(sSlaveConfig->SlaveMode));
   4254            assert_param(IS_TIM_TRIGGER_SELECTION(sSlaveConfig->InputTrigger));
   4255            
   4256            __HAL_LOCK(htim);
   \   00000006   0xF894 0x0038      LDRB     R0,[R4, #+56]
   \   0000000A   0x2801             CMP      R0,#+1
   \   0000000C   0xD101             BNE.N    ??HAL_TIM_SlaveConfigSynchronization_IT_0
   \   0000000E   0x2002             MOVS     R0,#+2
   \   00000010   0xE01C             B.N      ??HAL_TIM_SlaveConfigSynchronization_IT_1
   \                     ??HAL_TIM_SlaveConfigSynchronization_IT_0: (+1)
   \   00000012   0x2001             MOVS     R0,#+1
   \   00000014   0xF884 0x0038      STRB     R0,[R4, #+56]
   4257          
   4258            htim->State = HAL_TIM_STATE_BUSY;
   \   00000018   0x2002             MOVS     R0,#+2
   \   0000001A   0xF884 0x0039      STRB     R0,[R4, #+57]
   4259            
   4260            TIM_SlaveTimer_SetConfig(htim, sSlaveConfig);
   \   0000001E   0x0029             MOVS     R1,R5
   \   00000020   0x0020             MOVS     R0,R4
   \   00000022   0x.... 0x....      BL       TIM_SlaveTimer_SetConfig
   4261            
   4262            /* Enable Trigger Interrupt */
   4263            __HAL_TIM_ENABLE_IT(htim, TIM_IT_TRIGGER);
   \   00000026   0x6820             LDR      R0,[R4, #+0]
   \   00000028   0x68C0             LDR      R0,[R0, #+12]
   \   0000002A   0xF050 0x0040      ORRS     R0,R0,#0x40
   \   0000002E   0x6821             LDR      R1,[R4, #+0]
   \   00000030   0x60C8             STR      R0,[R1, #+12]
   4264            
   4265            /* Disable Trigger DMA request */
   4266            __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_TRIGGER);
   \   00000032   0x6820             LDR      R0,[R4, #+0]
   \   00000034   0x68C0             LDR      R0,[R0, #+12]
   \   00000036   0xF430 0x4080      BICS     R0,R0,#0x4000
   \   0000003A   0x6821             LDR      R1,[R4, #+0]
   \   0000003C   0x60C8             STR      R0,[R1, #+12]
   4267            
   4268            htim->State = HAL_TIM_STATE_READY;
   \   0000003E   0x2001             MOVS     R0,#+1
   \   00000040   0xF884 0x0039      STRB     R0,[R4, #+57]
   4269               
   4270            __HAL_UNLOCK(htim);  
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0xF884 0x0038      STRB     R0,[R4, #+56]
   4271            
   4272            return HAL_OK;
   \   0000004A   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_SlaveConfigSynchronization_IT_1: (+1)
   \   0000004C   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   4273          }
   4274          
   4275          /**
   4276            * @brief  Read the captured value from Capture Compare unit
   4277            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   4278            *                the configuration information for TIM module.
   4279            * @param  Channel: TIM Channels to be enabled.
   4280            *          This parameter can be one of the following values:
   4281            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   4282            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   4283            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   4284            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   4285            * @retval Captured value
   4286            */

   \                                 In section .text, align 2, keep-with-next
   4287          uint32_t HAL_TIM_ReadCapturedValue(TIM_HandleTypeDef *htim, uint32_t Channel)
   4288          {
   \                     HAL_TIM_ReadCapturedValue: (+1)
   \   00000000   0x0002             MOVS     R2,R0
   4289            uint32_t tmpreg = 0;
   \   00000002   0x2300             MOVS     R3,#+0
   4290            
   4291            __HAL_LOCK(htim);
   \   00000004   0xF892 0x0038      LDRB     R0,[R2, #+56]
   \   00000008   0x2801             CMP      R0,#+1
   \   0000000A   0xD101             BNE.N    ??HAL_TIM_ReadCapturedValue_0
   \   0000000C   0x2002             MOVS     R0,#+2
   \   0000000E   0xE020             B.N      ??HAL_TIM_ReadCapturedValue_1
   \                     ??HAL_TIM_ReadCapturedValue_0: (+1)
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0xF882 0x0038      STRB     R0,[R2, #+56]
   4292            
   4293            switch (Channel)
   \   00000016   0x0008             MOVS     R0,R1
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD006             BEQ.N    ??HAL_TIM_ReadCapturedValue_2
   \   0000001C   0x2804             CMP      R0,#+4
   \   0000001E   0xD008             BEQ.N    ??HAL_TIM_ReadCapturedValue_3
   \   00000020   0x2808             CMP      R0,#+8
   \   00000022   0xD00A             BEQ.N    ??HAL_TIM_ReadCapturedValue_4
   \   00000024   0x280C             CMP      R0,#+12
   \   00000026   0xD00C             BEQ.N    ??HAL_TIM_ReadCapturedValue_5
   \   00000028   0xE00F             B.N      ??HAL_TIM_ReadCapturedValue_6
   4294            {
   4295              case TIM_CHANNEL_1:
   4296              {
   4297                /* Check the parameters */
   4298                assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   4299                
   4300                /* Return the capture 1 value */
   4301                tmpreg = htim->Instance->CCR1;
   \                     ??HAL_TIM_ReadCapturedValue_2: (+1)
   \   0000002A   0x6810             LDR      R0,[R2, #+0]
   \   0000002C   0x6B40             LDR      R0,[R0, #+52]
   \   0000002E   0x0003             MOVS     R3,R0
   4302                
   4303                break;
   \   00000030   0xE00B             B.N      ??HAL_TIM_ReadCapturedValue_7
   4304              }
   4305              case TIM_CHANNEL_2:
   4306              {
   4307                /* Check the parameters */
   4308                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   4309                
   4310                /* Return the capture 2 value */
   4311                tmpreg = htim->Instance->CCR2;
   \                     ??HAL_TIM_ReadCapturedValue_3: (+1)
   \   00000032   0x6810             LDR      R0,[R2, #+0]
   \   00000034   0x6B80             LDR      R0,[R0, #+56]
   \   00000036   0x0003             MOVS     R3,R0
   4312                
   4313                break;
   \   00000038   0xE007             B.N      ??HAL_TIM_ReadCapturedValue_7
   4314              }
   4315              
   4316              case TIM_CHANNEL_3:
   4317              {
   4318                /* Check the parameters */
   4319                assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
   4320                
   4321                /* Return the capture 3 value */
   4322                tmpreg = htim->Instance->CCR3;
   \                     ??HAL_TIM_ReadCapturedValue_4: (+1)
   \   0000003A   0x6810             LDR      R0,[R2, #+0]
   \   0000003C   0x6BC0             LDR      R0,[R0, #+60]
   \   0000003E   0x0003             MOVS     R3,R0
   4323                
   4324                break;
   \   00000040   0xE003             B.N      ??HAL_TIM_ReadCapturedValue_7
   4325              }
   4326              
   4327              case TIM_CHANNEL_4:
   4328              {
   4329                /* Check the parameters */
   4330                assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
   4331                
   4332                /* Return the capture 4 value */
   4333                tmpreg = htim->Instance->CCR4;
   \                     ??HAL_TIM_ReadCapturedValue_5: (+1)
   \   00000042   0x6810             LDR      R0,[R2, #+0]
   \   00000044   0x6C00             LDR      R0,[R0, #+64]
   \   00000046   0x0003             MOVS     R3,R0
   4334                
   4335                break;
   \   00000048   0xE7FF             B.N      ??HAL_TIM_ReadCapturedValue_7
   4336              }
   4337              
   4338              default:
   4339              break;  
   4340            }
   4341               
   4342            __HAL_UNLOCK(htim);  
   \                     ??HAL_TIM_ReadCapturedValue_6: (+1)
   \                     ??HAL_TIM_ReadCapturedValue_7: (+1)
   \   0000004A   0x2000             MOVS     R0,#+0
   \   0000004C   0xF882 0x0038      STRB     R0,[R2, #+56]
   4343            return tmpreg;
   \   00000050   0x0018             MOVS     R0,R3
   \                     ??HAL_TIM_ReadCapturedValue_1: (+1)
   \   00000052   0x4770             BX       LR               ;; return
   4344          }
   4345          
   4346          /**
   4347            * @}
   4348            */
   4349            
   4350          /** @defgroup TIM_Exported_Functions_Group9 TIM Callbacks functions
   4351           *  @brief    TIM Callbacks functions 
   4352           *
   4353          @verbatim   
   4354            ==============================================================================
   4355                                  ##### TIM Callbacks functions #####
   4356            ==============================================================================  
   4357           [..]  
   4358             This section provides TIM callback functions:
   4359             (+) Timer Period elapsed callback
   4360             (+) Timer Output Compare callback
   4361             (+) Timer Input capture callback
   4362             (+) Timer Trigger callback
   4363             (+) Timer Error callback
   4364          
   4365          @endverbatim
   4366            * @{
   4367            */
   4368          
   4369          /**
   4370            * @brief  Period elapsed callback in non blocking mode 
   4371            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   4372            *                the configuration information for TIM module.
   4373            * @retval None
   4374            */

   \                                 In section .text, align 2, keep-with-next
   4375          __weak void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
   4376          {
   4377            /* NOTE : This function Should not be modified, when the callback is needed,
   4378                      the __HAL_TIM_PeriodElapsedCallback could be implemented in the user file
   4379             */
   4380            
   4381          }
   \                     HAL_TIM_PeriodElapsedCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   4382          /**
   4383            * @brief  Output Compare callback in non blocking mode 
   4384            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   4385            *                the configuration information for TIM module.
   4386            * @retval None
   4387            */

   \                                 In section .text, align 2, keep-with-next
   4388          __weak void HAL_TIM_OC_DelayElapsedCallback(TIM_HandleTypeDef *htim)
   4389          {
   4390            /* NOTE : This function Should not be modified, when the callback is needed,
   4391                      the __HAL_TIM_OC_DelayElapsedCallback could be implemented in the user file
   4392             */
   4393          }
   \                     HAL_TIM_OC_DelayElapsedCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   4394          /**
   4395            * @brief  Input Capture callback in non blocking mode 
   4396            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   4397            *                the configuration information for TIM module.
   4398            * @retval None
   4399            */

   \                                 In section .text, align 2, keep-with-next
   4400          __weak void HAL_TIM_IC_CaptureCallback(TIM_HandleTypeDef *htim)
   4401          {
   4402            /* NOTE : This function Should not be modified, when the callback is needed,
   4403                      the __HAL_TIM_IC_CaptureCallback could be implemented in the user file
   4404             */
   4405          }
   \                     HAL_TIM_IC_CaptureCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   4406          
   4407          /**
   4408            * @brief  PWM Pulse finished callback in non blocking mode 
   4409            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   4410            *                the configuration information for TIM module.
   4411            * @retval None
   4412            */

   \                                 In section .text, align 2, keep-with-next
   4413          __weak void HAL_TIM_PWM_PulseFinishedCallback(TIM_HandleTypeDef *htim)
   4414          {
   4415            /* NOTE : This function Should not be modified, when the callback is needed,
   4416                      the __HAL_TIM_PWM_PulseFinishedCallback could be implemented in the user file
   4417             */
   4418          }
   \                     HAL_TIM_PWM_PulseFinishedCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   4419          
   4420          /**
   4421            * @brief  Hall Trigger detection callback in non blocking mode 
   4422            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   4423            *                the configuration information for TIM module.
   4424            * @retval None
   4425            */

   \                                 In section .text, align 2, keep-with-next
   4426          __weak void HAL_TIM_TriggerCallback(TIM_HandleTypeDef *htim)
   4427          {
   4428            /* NOTE : This function Should not be modified, when the callback is needed,
   4429                      the HAL_TIM_TriggerCallback could be implemented in the user file
   4430             */
   4431          }
   \                     HAL_TIM_TriggerCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   4432          
   4433          /**
   4434            * @brief  Timer error callback in non blocking mode 
   4435            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   4436            *                the configuration information for TIM module.
   4437            * @retval None
   4438            */

   \                                 In section .text, align 2, keep-with-next
   4439          __weak void HAL_TIM_ErrorCallback(TIM_HandleTypeDef *htim)
   4440          {
   4441            /* NOTE : This function Should not be modified, when the callback is needed,
   4442                      the HAL_TIM_ErrorCallback could be implemented in the user file
   4443             */
   4444          }
   \                     HAL_TIM_ErrorCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   4445          
   4446          /**
   4447            * @}
   4448            */
   4449          
   4450          /** @defgroup TIM_Exported_Functions_Group10 Peripheral State functions 
   4451           *  @brief   Peripheral State functions 
   4452           *
   4453          @verbatim   
   4454            ==============================================================================
   4455                                  ##### Peripheral State functions #####
   4456            ==============================================================================  
   4457            [..]
   4458              This subsection permits to get in run-time the status of the peripheral 
   4459              and the data flow.
   4460          
   4461          @endverbatim
   4462            * @{
   4463            */
   4464          
   4465          /**
   4466            * @brief  Return the TIM Base state
   4467            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   4468            *                the configuration information for TIM module.
   4469            * @retval HAL state
   4470            */

   \                                 In section .text, align 2, keep-with-next
   4471          HAL_TIM_StateTypeDef HAL_TIM_Base_GetState(TIM_HandleTypeDef *htim)
   4472          {
   4473            return htim->State;
   \                     HAL_TIM_Base_GetState: (+1)
   \   00000000   0xF890 0x0039      LDRB     R0,[R0, #+57]
   \   00000004   0x4770             BX       LR               ;; return
   4474          }
   4475          
   4476          /**
   4477            * @brief  Return the TIM OC state
   4478            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   4479            *                the configuration information for TIM module.
   4480            * @retval HAL state
   4481            */

   \                                 In section .text, align 2, keep-with-next
   4482          HAL_TIM_StateTypeDef HAL_TIM_OC_GetState(TIM_HandleTypeDef *htim)
   4483          {
   4484            return htim->State;
   \                     HAL_TIM_OC_GetState: (+1)
   \   00000000   0xF890 0x0039      LDRB     R0,[R0, #+57]
   \   00000004   0x4770             BX       LR               ;; return
   4485          }
   4486          
   4487          /**
   4488            * @brief  Return the TIM PWM state
   4489            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   4490            *                the configuration information for TIM module.
   4491            * @retval HAL state
   4492            */

   \                                 In section .text, align 2, keep-with-next
   4493          HAL_TIM_StateTypeDef HAL_TIM_PWM_GetState(TIM_HandleTypeDef *htim)
   4494          {
   4495            return htim->State;
   \                     HAL_TIM_PWM_GetState: (+1)
   \   00000000   0xF890 0x0039      LDRB     R0,[R0, #+57]
   \   00000004   0x4770             BX       LR               ;; return
   4496          }
   4497          
   4498          /**
   4499            * @brief  Return the TIM Input Capture state
   4500            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   4501            *                the configuration information for TIM module.
   4502            * @retval HAL state
   4503            */

   \                                 In section .text, align 2, keep-with-next
   4504          HAL_TIM_StateTypeDef HAL_TIM_IC_GetState(TIM_HandleTypeDef *htim)
   4505          {
   4506            return htim->State;
   \                     HAL_TIM_IC_GetState: (+1)
   \   00000000   0xF890 0x0039      LDRB     R0,[R0, #+57]
   \   00000004   0x4770             BX       LR               ;; return
   4507          }
   4508          
   4509          /**
   4510            * @brief  Return the TIM One Pulse Mode state
   4511            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   4512            *                the configuration information for TIM module.
   4513            * @retval HAL state
   4514            */

   \                                 In section .text, align 2, keep-with-next
   4515          HAL_TIM_StateTypeDef HAL_TIM_OnePulse_GetState(TIM_HandleTypeDef *htim)
   4516          {
   4517            return htim->State;
   \                     HAL_TIM_OnePulse_GetState: (+1)
   \   00000000   0xF890 0x0039      LDRB     R0,[R0, #+57]
   \   00000004   0x4770             BX       LR               ;; return
   4518          }
   4519          
   4520          /**
   4521            * @brief  Return the TIM Encoder Mode state
   4522            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   4523            *                the configuration information for TIM module.
   4524            * @retval HAL state
   4525            */

   \                                 In section .text, align 2, keep-with-next
   4526          HAL_TIM_StateTypeDef HAL_TIM_Encoder_GetState(TIM_HandleTypeDef *htim)
   4527          {
   4528            return htim->State;
   \                     HAL_TIM_Encoder_GetState: (+1)
   \   00000000   0xF890 0x0039      LDRB     R0,[R0, #+57]
   \   00000004   0x4770             BX       LR               ;; return
   4529          }
   4530          
   4531          /**
   4532            * @}
   4533            */
   4534          
   4535          /**
   4536            * @brief  TIM DMA error callback 
   4537            * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
   4538            *                the configuration information for the specified DMA module.
   4539            * @retval None
   4540            */

   \                                 In section .text, align 4, keep-with-next
   4541          void HAL_TIM_DMAError(DMA_HandleTypeDef *hdma)
   4542          {
   \                     TIM_DMAError: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   4543            TIM_HandleTypeDef* htim = ( TIM_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   \   00000004   0x6BA5             LDR      R5,[R4, #+56]
   4544            
   4545            htim->State= HAL_TIM_STATE_READY;
   \   00000006   0x2001             MOVS     R0,#+1
   \   00000008   0xF885 0x0039      STRB     R0,[R5, #+57]
   4546             
   4547            HAL_TIM_ErrorCallback(htim);
   \   0000000C   0x0028             MOVS     R0,R5
   \   0000000E   0x.... 0x....      BL       HAL_TIM_ErrorCallback
   4548          }
   \   00000012   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   4549          
   4550          /**
   4551            * @brief  TIM DMA Delay Pulse complete callback. 
   4552            * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
   4553            *                the configuration information for the specified DMA module.
   4554            * @retval None
   4555            */

   \                                 In section .text, align 4, keep-with-next
   4556          void HAL_TIM_DMADelayPulseCplt(DMA_HandleTypeDef *hdma)
   4557          {
   \                     TIM_DMADelayPulseCplt: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   4558            TIM_HandleTypeDef* htim = ( TIM_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   \   00000004   0x6BA5             LDR      R5,[R4, #+56]
   4559            
   4560            htim->State= HAL_TIM_STATE_READY; 
   \   00000006   0x2001             MOVS     R0,#+1
   \   00000008   0xF885 0x0039      STRB     R0,[R5, #+57]
   4561            
   4562            if (hdma == htim->hdma[TIM_DMA_ID_CC1])
   \   0000000C   0x6A28             LDR      R0,[R5, #+32]
   \   0000000E   0x4284             CMP      R4,R0
   \   00000010   0xD102             BNE.N    ??TIM_DMADelayPulseCplt_0
   4563            {
   4564              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
   \   00000012   0x2001             MOVS     R0,#+1
   \   00000014   0x7628             STRB     R0,[R5, #+24]
   \   00000016   0xE010             B.N      ??TIM_DMADelayPulseCplt_1
   4565            }
   4566            else if (hdma == htim->hdma[TIM_DMA_ID_CC2])
   \                     ??TIM_DMADelayPulseCplt_0: (+1)
   \   00000018   0x6A68             LDR      R0,[R5, #+36]
   \   0000001A   0x4284             CMP      R4,R0
   \   0000001C   0xD102             BNE.N    ??TIM_DMADelayPulseCplt_2
   4567            {
   4568              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
   \   0000001E   0x2002             MOVS     R0,#+2
   \   00000020   0x7628             STRB     R0,[R5, #+24]
   \   00000022   0xE00A             B.N      ??TIM_DMADelayPulseCplt_1
   4569            }
   4570            else if (hdma == htim->hdma[TIM_DMA_ID_CC3])
   \                     ??TIM_DMADelayPulseCplt_2: (+1)
   \   00000024   0x6AA8             LDR      R0,[R5, #+40]
   \   00000026   0x4284             CMP      R4,R0
   \   00000028   0xD102             BNE.N    ??TIM_DMADelayPulseCplt_3
   4571            {
   4572              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
   \   0000002A   0x2004             MOVS     R0,#+4
   \   0000002C   0x7628             STRB     R0,[R5, #+24]
   \   0000002E   0xE004             B.N      ??TIM_DMADelayPulseCplt_1
   4573            }
   4574            else if (hdma == htim->hdma[TIM_DMA_ID_CC4])
   \                     ??TIM_DMADelayPulseCplt_3: (+1)
   \   00000030   0x6AE8             LDR      R0,[R5, #+44]
   \   00000032   0x4284             CMP      R4,R0
   \   00000034   0xD101             BNE.N    ??TIM_DMADelayPulseCplt_1
   4575            {
   4576              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
   \   00000036   0x2008             MOVS     R0,#+8
   \   00000038   0x7628             STRB     R0,[R5, #+24]
   4577            }
   4578          
   4579            HAL_TIM_PWM_PulseFinishedCallback(htim);
   \                     ??TIM_DMADelayPulseCplt_1: (+1)
   \   0000003A   0x0028             MOVS     R0,R5
   \   0000003C   0x.... 0x....      BL       HAL_TIM_PWM_PulseFinishedCallback
   4580          
   4581            htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0x7628             STRB     R0,[R5, #+24]
   4582          }
   \   00000044   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   4583          /**
   4584            * @brief  TIM DMA Capture complete callback. 
   4585            * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
   4586            *                the configuration information for the specified DMA module.
   4587            * @retval None
   4588            */

   \                                 In section .text, align 4, keep-with-next
   4589          void HAL_TIM_DMACaptureCplt(DMA_HandleTypeDef *hdma)
   4590          {
   \                     TIM_DMACaptureCplt: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   4591            TIM_HandleTypeDef* htim = ( TIM_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   \   00000004   0x6BA5             LDR      R5,[R4, #+56]
   4592              
   4593             htim->State= HAL_TIM_STATE_READY; 
   \   00000006   0x2001             MOVS     R0,#+1
   \   00000008   0xF885 0x0039      STRB     R0,[R5, #+57]
   4594              
   4595            if (hdma == htim->hdma[TIM_DMA_ID_CC1])
   \   0000000C   0x6A28             LDR      R0,[R5, #+32]
   \   0000000E   0x4284             CMP      R4,R0
   \   00000010   0xD102             BNE.N    ??TIM_DMACaptureCplt_0
   4596            {
   4597              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
   \   00000012   0x2001             MOVS     R0,#+1
   \   00000014   0x7628             STRB     R0,[R5, #+24]
   \   00000016   0xE010             B.N      ??TIM_DMACaptureCplt_1
   4598            }
   4599            else if (hdma == htim->hdma[TIM_DMA_ID_CC2])
   \                     ??TIM_DMACaptureCplt_0: (+1)
   \   00000018   0x6A68             LDR      R0,[R5, #+36]
   \   0000001A   0x4284             CMP      R4,R0
   \   0000001C   0xD102             BNE.N    ??TIM_DMACaptureCplt_2
   4600            {
   4601              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
   \   0000001E   0x2002             MOVS     R0,#+2
   \   00000020   0x7628             STRB     R0,[R5, #+24]
   \   00000022   0xE00A             B.N      ??TIM_DMACaptureCplt_1
   4602            }
   4603            else if (hdma == htim->hdma[TIM_DMA_ID_CC3])
   \                     ??TIM_DMACaptureCplt_2: (+1)
   \   00000024   0x6AA8             LDR      R0,[R5, #+40]
   \   00000026   0x4284             CMP      R4,R0
   \   00000028   0xD102             BNE.N    ??TIM_DMACaptureCplt_3
   4604            {
   4605              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
   \   0000002A   0x2004             MOVS     R0,#+4
   \   0000002C   0x7628             STRB     R0,[R5, #+24]
   \   0000002E   0xE004             B.N      ??TIM_DMACaptureCplt_1
   4606            }
   4607            else if (hdma == htim->hdma[TIM_DMA_ID_CC4])
   \                     ??TIM_DMACaptureCplt_3: (+1)
   \   00000030   0x6AE8             LDR      R0,[R5, #+44]
   \   00000032   0x4284             CMP      R4,R0
   \   00000034   0xD101             BNE.N    ??TIM_DMACaptureCplt_1
   4608            {
   4609              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
   \   00000036   0x2008             MOVS     R0,#+8
   \   00000038   0x7628             STRB     R0,[R5, #+24]
   4610            }
   4611            
   4612            HAL_TIM_IC_CaptureCallback(htim); 
   \                     ??TIM_DMACaptureCplt_1: (+1)
   \   0000003A   0x0028             MOVS     R0,R5
   \   0000003C   0x.... 0x....      BL       HAL_TIM_IC_CaptureCallback
   4613            
   4614            htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0x7628             STRB     R0,[R5, #+24]
   4615          
   4616          }
   \   00000044   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   4617          
   4618          /**
   4619            * @brief  TIM DMA Period Elapse complete callback. 
   4620            * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
   4621            *                the configuration information for the specified DMA module.
   4622            * @retval None
   4623            */

   \                                 In section .text, align 4, keep-with-next
   4624          static void TIM_DMAPeriodElapsedCplt(DMA_HandleTypeDef *hdma)
   4625          {
   \                     TIM_DMAPeriodElapsedCplt: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   4626            TIM_HandleTypeDef* htim = ( TIM_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   \   00000004   0x6BA5             LDR      R5,[R4, #+56]
   4627            
   4628            htim->State= HAL_TIM_STATE_READY;
   \   00000006   0x2001             MOVS     R0,#+1
   \   00000008   0xF885 0x0039      STRB     R0,[R5, #+57]
   4629            
   4630            HAL_TIM_PeriodElapsedCallback(htim);
   \   0000000C   0x0028             MOVS     R0,R5
   \   0000000E   0x.... 0x....      BL       HAL_TIM_PeriodElapsedCallback
   4631          }
   \   00000012   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   4632          
   4633          /**
   4634            * @brief  TIM DMA Trigger callback. 
   4635            * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
   4636            *                the configuration information for the specified DMA module.
   4637            * @retval None
   4638            */

   \                                 In section .text, align 4, keep-with-next
   4639          static void TIM_DMATriggerCplt(DMA_HandleTypeDef *hdma)
   4640          {
   \                     TIM_DMATriggerCplt: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   4641            TIM_HandleTypeDef* htim = ( TIM_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;  
   \   00000004   0x6BA5             LDR      R5,[R4, #+56]
   4642            
   4643            htim->State= HAL_TIM_STATE_READY; 
   \   00000006   0x2001             MOVS     R0,#+1
   \   00000008   0xF885 0x0039      STRB     R0,[R5, #+57]
   4644            
   4645            HAL_TIM_TriggerCallback(htim);
   \   0000000C   0x0028             MOVS     R0,R5
   \   0000000E   0x.... 0x....      BL       HAL_TIM_TriggerCallback
   4646          }
   \   00000012   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   4647          
   4648          /**
   4649            * @brief  Time Base configuration
   4650            * @param  TIMx: TIM peripheral
   4651            * @param  Structure: pointer on TIM Time Base required parameters  
   4652            * @retval None
   4653            */

   \                                 In section .text, align 2, keep-with-next
   4654          void TIM_Base_SetConfig(TIM_TypeDef *TIMx, TIM_Base_InitTypeDef *Structure)
   4655          {
   4656            uint32_t tmpcr1 = 0;
   \                     TIM_Base_SetConfig: (+1)
   \   00000000   0x2200             MOVS     R2,#+0
   4657            tmpcr1 = TIMx->CR1;
   \   00000002   0x6803             LDR      R3,[R0, #+0]
   \   00000004   0x001A             MOVS     R2,R3
   4658            
   4659            /* Set TIM Time Base Unit parameters ---------------------------------------*/
   4660            if(IS_TIM_CC3_INSTANCE(TIMx) != RESET)   
   \   00000006   0x.... 0x....      LDR.W    R3,??DataTable31_3  ;; 0x40010000
   \   0000000A   0x4298             CMP      R0,R3
   \   0000000C   0xD012             BEQ.N    ??TIM_Base_SetConfig_0
   \   0000000E   0xF1B0 0x4F80      CMP      R0,#+1073741824
   \   00000012   0xD00F             BEQ.N    ??TIM_Base_SetConfig_0
   \   00000014   0x.... 0x....      LDR.W    R3,??DataTable31_4  ;; 0x40000400
   \   00000018   0x4298             CMP      R0,R3
   \   0000001A   0xD00B             BEQ.N    ??TIM_Base_SetConfig_0
   \   0000001C   0x.... 0x....      LDR.W    R3,??DataTable31_5  ;; 0x40000800
   \   00000020   0x4298             CMP      R0,R3
   \   00000022   0xD007             BEQ.N    ??TIM_Base_SetConfig_0
   \   00000024   0x.... 0x....      LDR.W    R3,??DataTable31_6  ;; 0x40000c00
   \   00000028   0x4298             CMP      R0,R3
   \   0000002A   0xD003             BEQ.N    ??TIM_Base_SetConfig_0
   \   0000002C   0x.... 0x....      LDR.W    R3,??DataTable31_7  ;; 0x40010400
   \   00000030   0x4298             CMP      R0,R3
   \   00000032   0xD101             BNE.N    ??TIM_Base_SetConfig_1
   \                     ??TIM_Base_SetConfig_0: (+1)
   \   00000034   0x2301             MOVS     R3,#+1
   \   00000036   0xE000             B.N      ??TIM_Base_SetConfig_2
   \                     ??TIM_Base_SetConfig_1: (+1)
   \   00000038   0x2300             MOVS     R3,#+0
   \                     ??TIM_Base_SetConfig_2: (+1)
   \   0000003A   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   0000003C   0x2B00             CMP      R3,#+0
   \   0000003E   0xD003             BEQ.N    ??TIM_Base_SetConfig_3
   4661            {
   4662              /* Select the Counter Mode */
   4663              tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
   \   00000040   0xF032 0x0270      BICS     R2,R2,#0x70
   4664              tmpcr1 |= Structure->CounterMode;
   \   00000044   0x684B             LDR      R3,[R1, #+4]
   \   00000046   0x431A             ORRS     R2,R3,R2
   4665            }
   4666           
   4667            if(IS_TIM_CC1_INSTANCE(TIMx) != RESET)  
   \                     ??TIM_Base_SetConfig_3: (+1)
   \   00000048   0x.... 0x....      LDR.W    R3,??DataTable31_3  ;; 0x40010000
   \   0000004C   0x4298             CMP      R0,R3
   \   0000004E   0xD02A             BEQ.N    ??TIM_Base_SetConfig_4
   \   00000050   0xF1B0 0x4F80      CMP      R0,#+1073741824
   \   00000054   0xD027             BEQ.N    ??TIM_Base_SetConfig_4
   \   00000056   0x.... 0x....      LDR.W    R3,??DataTable31_4  ;; 0x40000400
   \   0000005A   0x4298             CMP      R0,R3
   \   0000005C   0xD023             BEQ.N    ??TIM_Base_SetConfig_4
   \   0000005E   0x.... 0x....      LDR.W    R3,??DataTable31_5  ;; 0x40000800
   \   00000062   0x4298             CMP      R0,R3
   \   00000064   0xD01F             BEQ.N    ??TIM_Base_SetConfig_4
   \   00000066   0x.... 0x....      LDR.W    R3,??DataTable31_6  ;; 0x40000c00
   \   0000006A   0x4298             CMP      R0,R3
   \   0000006C   0xD01B             BEQ.N    ??TIM_Base_SetConfig_4
   \   0000006E   0x.... 0x....      LDR.W    R3,??DataTable31_7  ;; 0x40010400
   \   00000072   0x4298             CMP      R0,R3
   \   00000074   0xD017             BEQ.N    ??TIM_Base_SetConfig_4
   \   00000076   0x.... 0x....      LDR.W    R3,??DataTable31_8  ;; 0x40014000
   \   0000007A   0x4298             CMP      R0,R3
   \   0000007C   0xD013             BEQ.N    ??TIM_Base_SetConfig_4
   \   0000007E   0x.... 0x....      LDR.W    R3,??DataTable31_9  ;; 0x40014400
   \   00000082   0x4298             CMP      R0,R3
   \   00000084   0xD00F             BEQ.N    ??TIM_Base_SetConfig_4
   \   00000086   0x.... 0x....      LDR.W    R3,??DataTable31_10  ;; 0x40014800
   \   0000008A   0x4298             CMP      R0,R3
   \   0000008C   0xD00B             BEQ.N    ??TIM_Base_SetConfig_4
   \   0000008E   0x.... 0x....      LDR.W    R3,??DataTable31_11  ;; 0x40001800
   \   00000092   0x4298             CMP      R0,R3
   \   00000094   0xD007             BEQ.N    ??TIM_Base_SetConfig_4
   \   00000096   0x.... 0x....      LDR.W    R3,??DataTable31_12  ;; 0x40001c00
   \   0000009A   0x4298             CMP      R0,R3
   \   0000009C   0xD003             BEQ.N    ??TIM_Base_SetConfig_4
   \   0000009E   0x.... 0x....      LDR.W    R3,??DataTable31_13  ;; 0x40002000
   \   000000A2   0x4298             CMP      R0,R3
   \   000000A4   0xD101             BNE.N    ??TIM_Base_SetConfig_5
   \                     ??TIM_Base_SetConfig_4: (+1)
   \   000000A6   0x2301             MOVS     R3,#+1
   \   000000A8   0xE000             B.N      ??TIM_Base_SetConfig_6
   \                     ??TIM_Base_SetConfig_5: (+1)
   \   000000AA   0x2300             MOVS     R3,#+0
   \                     ??TIM_Base_SetConfig_6: (+1)
   \   000000AC   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   000000AE   0x2B00             CMP      R3,#+0
   \   000000B0   0xD003             BEQ.N    ??TIM_Base_SetConfig_7
   4668            {
   4669              /* Set the clock division */
   4670              tmpcr1 &= ~TIM_CR1_CKD;
   \   000000B2   0xF432 0x7240      BICS     R2,R2,#0x300
   4671              tmpcr1 |= (uint32_t)Structure->ClockDivision;
   \   000000B6   0x68CB             LDR      R3,[R1, #+12]
   \   000000B8   0x431A             ORRS     R2,R3,R2
   4672            }
   4673          
   4674            TIMx->CR1 = tmpcr1;
   \                     ??TIM_Base_SetConfig_7: (+1)
   \   000000BA   0x6002             STR      R2,[R0, #+0]
   4675          
   4676            /* Set the Auto-reload value */
   4677            TIMx->ARR = (uint32_t)Structure->Period ;
   \   000000BC   0x688B             LDR      R3,[R1, #+8]
   \   000000BE   0x62C3             STR      R3,[R0, #+44]
   4678           
   4679            /* Set the Prescaler value */
   4680            TIMx->PSC = (uint32_t)Structure->Prescaler;
   \   000000C0   0x680B             LDR      R3,[R1, #+0]
   \   000000C2   0x6283             STR      R3,[R0, #+40]
   4681              
   4682            if(IS_TIM_ADVANCED_INSTANCE(TIMx) != RESET)  
   \   000000C4   0x....             LDR.N    R3,??DataTable31_3  ;; 0x40010000
   \   000000C6   0x4298             CMP      R0,R3
   \   000000C8   0xD002             BEQ.N    ??TIM_Base_SetConfig_8
   \   000000CA   0x....             LDR.N    R3,??DataTable31_7  ;; 0x40010400
   \   000000CC   0x4298             CMP      R0,R3
   \   000000CE   0xD101             BNE.N    ??TIM_Base_SetConfig_9
   \                     ??TIM_Base_SetConfig_8: (+1)
   \   000000D0   0x2301             MOVS     R3,#+1
   \   000000D2   0xE000             B.N      ??TIM_Base_SetConfig_10
   \                     ??TIM_Base_SetConfig_9: (+1)
   \   000000D4   0x2300             MOVS     R3,#+0
   \                     ??TIM_Base_SetConfig_10: (+1)
   \   000000D6   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   000000D8   0x2B00             CMP      R3,#+0
   \   000000DA   0xD001             BEQ.N    ??TIM_Base_SetConfig_11
   4683            {
   4684              /* Set the Repetition Counter value */
   4685              TIMx->RCR = Structure->RepetitionCounter;
   \   000000DC   0x690B             LDR      R3,[R1, #+16]
   \   000000DE   0x6303             STR      R3,[R0, #+48]
   4686            }
   4687          
   4688            /* Generate an update event to reload the Prescaler 
   4689               and the repetition counter(only for TIM1 and TIM8) value immediately */
   4690            TIMx->EGR = TIM_EGR_UG;
   \                     ??TIM_Base_SetConfig_11: (+1)
   \   000000E0   0x2301             MOVS     R3,#+1
   \   000000E2   0x6143             STR      R3,[R0, #+20]
   4691          }
   \   000000E4   0x4770             BX       LR               ;; return
   4692          
   4693          /**
   4694            * @brief  Time Output Compare 1 configuration
   4695            * @param  TIMx to select the TIM peripheral
   4696            * @param  OC_Config: The output configuration structure
   4697            * @retval None
   4698            */

   \                                 In section .text, align 2, keep-with-next
   4699          void TIM_OC1_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
   4700          {
   \                     TIM_OC1_SetConfig: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
   4701            uint32_t tmpccmrx = 0;
   \   00000002   0x2300             MOVS     R3,#+0
   4702            uint32_t tmpccer = 0;
   \   00000004   0x2400             MOVS     R4,#+0
   4703            uint32_t tmpcr2 = 0;  
   \   00000006   0x2200             MOVS     R2,#+0
   4704          
   4705            /* Disable the Channel 1: Reset the CC1E Bit */
   4706            TIMx->CCER &= ~TIM_CCER_CC1E;
   \   00000008   0x6A05             LDR      R5,[R0, #+32]
   \   0000000A   0x086D             LSRS     R5,R5,#+1
   \   0000000C   0x006D             LSLS     R5,R5,#+1
   \   0000000E   0x6205             STR      R5,[R0, #+32]
   4707            
   4708            /* Get the TIMx CCER register value */
   4709            tmpccer = TIMx->CCER;
   \   00000010   0x6A05             LDR      R5,[R0, #+32]
   \   00000012   0x002C             MOVS     R4,R5
   4710            /* Get the TIMx CR2 register value */
   4711            tmpcr2 = TIMx->CR2;
   \   00000014   0x6845             LDR      R5,[R0, #+4]
   \   00000016   0x002A             MOVS     R2,R5
   4712            
   4713            /* Get the TIMx CCMR1 register value */
   4714            tmpccmrx = TIMx->CCMR1;
   \   00000018   0x6985             LDR      R5,[R0, #+24]
   \   0000001A   0x002B             MOVS     R3,R5
   4715              
   4716            /* Reset the Output Compare Mode Bits */
   4717            tmpccmrx &= ~TIM_CCMR1_OC1M;
   \   0000001C   0x....             LDR.N    R5,??DataTable31_14  ;; 0xfffeff8f
   \   0000001E   0x402B             ANDS     R3,R5,R3
   4718            tmpccmrx &= ~TIM_CCMR1_CC1S;
   \   00000020   0x089B             LSRS     R3,R3,#+2
   \   00000022   0x009B             LSLS     R3,R3,#+2
   4719            /* Select the Output Compare Mode */
   4720            tmpccmrx |= OC_Config->OCMode;
   \   00000024   0x680D             LDR      R5,[R1, #+0]
   \   00000026   0x432B             ORRS     R3,R5,R3
   4721            
   4722            /* Reset the Output Polarity level */
   4723            tmpccer &= ~TIM_CCER_CC1P;
   \   00000028   0xF034 0x0402      BICS     R4,R4,#0x2
   4724            /* Set the Output Compare Polarity */
   4725            tmpccer |= OC_Config->OCPolarity;
   \   0000002C   0x688D             LDR      R5,[R1, #+8]
   \   0000002E   0x432C             ORRS     R4,R5,R4
   4726          
   4727              
   4728            if(IS_TIM_ADVANCED_INSTANCE(TIMx) != RESET)
   \   00000030   0x....             LDR.N    R5,??DataTable31_3  ;; 0x40010000
   \   00000032   0x42A8             CMP      R0,R5
   \   00000034   0xD002             BEQ.N    ??TIM_OC1_SetConfig_0
   \   00000036   0x....             LDR.N    R5,??DataTable31_7  ;; 0x40010400
   \   00000038   0x42A8             CMP      R0,R5
   \   0000003A   0xD101             BNE.N    ??TIM_OC1_SetConfig_1
   \                     ??TIM_OC1_SetConfig_0: (+1)
   \   0000003C   0x2501             MOVS     R5,#+1
   \   0000003E   0xE000             B.N      ??TIM_OC1_SetConfig_2
   \                     ??TIM_OC1_SetConfig_1: (+1)
   \   00000040   0x2500             MOVS     R5,#+0
   \                     ??TIM_OC1_SetConfig_2: (+1)
   \   00000042   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000044   0x2D00             CMP      R5,#+0
   \   00000046   0xD00D             BEQ.N    ??TIM_OC1_SetConfig_3
   4729            {   
   4730              /* Reset the Output N Polarity level */
   4731              tmpccer &= ~TIM_CCER_CC1NP;
   \   00000048   0xF034 0x0408      BICS     R4,R4,#0x8
   4732              /* Set the Output N Polarity */
   4733              tmpccer |= OC_Config->OCNPolarity;
   \   0000004C   0x68CD             LDR      R5,[R1, #+12]
   \   0000004E   0x432C             ORRS     R4,R5,R4
   4734              /* Reset the Output N State */
   4735              tmpccer &= ~TIM_CCER_CC1NE;
   \   00000050   0xF034 0x0404      BICS     R4,R4,#0x4
   4736              
   4737              /* Reset the Output Compare and Output Compare N IDLE State */
   4738              tmpcr2 &= ~TIM_CR2_OIS1;
   \   00000054   0xF432 0x7280      BICS     R2,R2,#0x100
   4739              tmpcr2 &= ~TIM_CR2_OIS1N;
   \   00000058   0xF432 0x7200      BICS     R2,R2,#0x200
   4740              /* Set the Output Idle state */
   4741              tmpcr2 |= OC_Config->OCIdleState;
   \   0000005C   0x694D             LDR      R5,[R1, #+20]
   \   0000005E   0x432A             ORRS     R2,R5,R2
   4742              /* Set the Output N Idle state */
   4743              tmpcr2 |= OC_Config->OCNIdleState;
   \   00000060   0x698D             LDR      R5,[R1, #+24]
   \   00000062   0x432A             ORRS     R2,R5,R2
   4744            }
   4745            /* Write to TIMx CR2 */
   4746            TIMx->CR2 = tmpcr2;
   \                     ??TIM_OC1_SetConfig_3: (+1)
   \   00000064   0x6042             STR      R2,[R0, #+4]
   4747            
   4748            /* Write to TIMx CCMR1 */
   4749            TIMx->CCMR1 = tmpccmrx;
   \   00000066   0x6183             STR      R3,[R0, #+24]
   4750            
   4751            /* Set the Capture Compare Register value */
   4752            TIMx->CCR1 = OC_Config->Pulse;
   \   00000068   0x684D             LDR      R5,[R1, #+4]
   \   0000006A   0x6345             STR      R5,[R0, #+52]
   4753            
   4754            /* Write to TIMx CCER */
   4755            TIMx->CCER = tmpccer;  
   \   0000006C   0x6204             STR      R4,[R0, #+32]
   4756          } 
   \   0000006E   0xBC30             POP      {R4,R5}
   \   00000070   0x4770             BX       LR               ;; return
   4757          
   4758          /**
   4759            * @brief  Time Output Compare 2 configuration
   4760            * @param  TIMx to select the TIM peripheral
   4761            * @param  OC_Config: The output configuration structure
   4762            * @retval None
   4763            */

   \                                 In section .text, align 2, keep-with-next
   4764          void TIM_OC2_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
   4765          {
   \                     TIM_OC2_SetConfig: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
   4766            uint32_t tmpccmrx = 0;
   \   00000002   0x2300             MOVS     R3,#+0
   4767            uint32_t tmpccer = 0;
   \   00000004   0x2400             MOVS     R4,#+0
   4768            uint32_t tmpcr2 = 0;
   \   00000006   0x2200             MOVS     R2,#+0
   4769             
   4770            /* Disable the Channel 2: Reset the CC2E Bit */
   4771            TIMx->CCER &= ~TIM_CCER_CC2E;
   \   00000008   0x6A05             LDR      R5,[R0, #+32]
   \   0000000A   0xF035 0x0510      BICS     R5,R5,#0x10
   \   0000000E   0x6205             STR      R5,[R0, #+32]
   4772            
   4773            /* Get the TIMx CCER register value */  
   4774            tmpccer = TIMx->CCER;
   \   00000010   0x6A05             LDR      R5,[R0, #+32]
   \   00000012   0x002C             MOVS     R4,R5
   4775            /* Get the TIMx CR2 register value */
   4776            tmpcr2 = TIMx->CR2;
   \   00000014   0x6845             LDR      R5,[R0, #+4]
   \   00000016   0x002A             MOVS     R2,R5
   4777            
   4778            /* Get the TIMx CCMR1 register value */
   4779            tmpccmrx = TIMx->CCMR1;
   \   00000018   0x6985             LDR      R5,[R0, #+24]
   \   0000001A   0x002B             MOVS     R3,R5
   4780              
   4781            /* Reset the Output Compare mode and Capture/Compare selection Bits */
   4782            tmpccmrx &= ~TIM_CCMR1_OC2M;
   \   0000001C   0x....             LDR.N    R5,??DataTable31_15  ;; 0xfeff8fff
   \   0000001E   0x402B             ANDS     R3,R5,R3
   4783            tmpccmrx &= ~TIM_CCMR1_CC2S;
   \   00000020   0xF433 0x7340      BICS     R3,R3,#0x300
   4784            
   4785            /* Select the Output Compare Mode */
   4786            tmpccmrx |= (OC_Config->OCMode << 8);
   \   00000024   0x680D             LDR      R5,[R1, #+0]
   \   00000026   0xEA53 0x2305      ORRS     R3,R3,R5, LSL #+8
   4787            
   4788            /* Reset the Output Polarity level */
   4789            tmpccer &= ~TIM_CCER_CC2P;
   \   0000002A   0xF034 0x0420      BICS     R4,R4,#0x20
   4790            /* Set the Output Compare Polarity */
   4791            tmpccer |= (OC_Config->OCPolarity << 4);
   \   0000002E   0x688D             LDR      R5,[R1, #+8]
   \   00000030   0xEA54 0x1405      ORRS     R4,R4,R5, LSL #+4
   4792              
   4793            if(IS_TIM_ADVANCED_INSTANCE(TIMx) != RESET)
   \   00000034   0x....             LDR.N    R5,??DataTable31_3  ;; 0x40010000
   \   00000036   0x42A8             CMP      R0,R5
   \   00000038   0xD002             BEQ.N    ??TIM_OC2_SetConfig_0
   \   0000003A   0x....             LDR.N    R5,??DataTable31_7  ;; 0x40010400
   \   0000003C   0x42A8             CMP      R0,R5
   \   0000003E   0xD101             BNE.N    ??TIM_OC2_SetConfig_1
   \                     ??TIM_OC2_SetConfig_0: (+1)
   \   00000040   0x2501             MOVS     R5,#+1
   \   00000042   0xE000             B.N      ??TIM_OC2_SetConfig_2
   \                     ??TIM_OC2_SetConfig_1: (+1)
   \   00000044   0x2500             MOVS     R5,#+0
   \                     ??TIM_OC2_SetConfig_2: (+1)
   \   00000046   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000048   0x2D00             CMP      R5,#+0
   \   0000004A   0xD010             BEQ.N    ??TIM_OC2_SetConfig_3
   4794            {
   4795              assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));
   4796              assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
   4797              assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));
   4798              
   4799              /* Reset the Output N Polarity level */
   4800              tmpccer &= ~TIM_CCER_CC2NP;
   \   0000004C   0xF034 0x0480      BICS     R4,R4,#0x80
   4801              /* Set the Output N Polarity */
   4802              tmpccer |= (OC_Config->OCNPolarity << 4);
   \   00000050   0x68CD             LDR      R5,[R1, #+12]
   \   00000052   0xEA54 0x1405      ORRS     R4,R4,R5, LSL #+4
   4803              /* Reset the Output N State */
   4804              tmpccer &= ~TIM_CCER_CC2NE;
   \   00000056   0xF034 0x0440      BICS     R4,R4,#0x40
   4805              
   4806              /* Reset the Output Compare and Output Compare N IDLE State */
   4807              tmpcr2 &= ~TIM_CR2_OIS2;
   \   0000005A   0xF432 0x6280      BICS     R2,R2,#0x400
   4808              tmpcr2 &= ~TIM_CR2_OIS2N;
   \   0000005E   0xF432 0x6200      BICS     R2,R2,#0x800
   4809              /* Set the Output Idle state */
   4810              tmpcr2 |= (OC_Config->OCIdleState << 2);
   \   00000062   0x694D             LDR      R5,[R1, #+20]
   \   00000064   0xEA52 0x0285      ORRS     R2,R2,R5, LSL #+2
   4811              /* Set the Output N Idle state */
   4812              tmpcr2 |= (OC_Config->OCNIdleState << 2);
   \   00000068   0x698D             LDR      R5,[R1, #+24]
   \   0000006A   0xEA52 0x0285      ORRS     R2,R2,R5, LSL #+2
   4813            }
   4814            /* Write to TIMx CR2 */
   4815            TIMx->CR2 = tmpcr2;
   \                     ??TIM_OC2_SetConfig_3: (+1)
   \   0000006E   0x6042             STR      R2,[R0, #+4]
   4816            
   4817            /* Write to TIMx CCMR1 */
   4818            TIMx->CCMR1 = tmpccmrx;
   \   00000070   0x6183             STR      R3,[R0, #+24]
   4819            
   4820            /* Set the Capture Compare Register value */
   4821            TIMx->CCR2 = OC_Config->Pulse;
   \   00000072   0x684D             LDR      R5,[R1, #+4]
   \   00000074   0x6385             STR      R5,[R0, #+56]
   4822            
   4823            /* Write to TIMx CCER */
   4824            TIMx->CCER = tmpccer;
   \   00000076   0x6204             STR      R4,[R0, #+32]
   4825          }
   \   00000078   0xBC30             POP      {R4,R5}
   \   0000007A   0x4770             BX       LR               ;; return
   4826          
   4827          /**
   4828            * @brief  Time Output Compare 3 configuration
   4829            * @param  TIMx to select the TIM peripheral
   4830            * @param  OC_Config: The output configuration structure
   4831            * @retval None
   4832            */

   \                                 In section .text, align 2, keep-with-next
   4833          void TIM_OC3_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
   4834          {
   \                     TIM_OC3_SetConfig: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
   4835            uint32_t tmpccmrx = 0;
   \   00000002   0x2300             MOVS     R3,#+0
   4836            uint32_t tmpccer = 0;
   \   00000004   0x2400             MOVS     R4,#+0
   4837            uint32_t tmpcr2 = 0;   
   \   00000006   0x2200             MOVS     R2,#+0
   4838          
   4839            /* Disable the Channel 3: Reset the CC2E Bit */
   4840            TIMx->CCER &= ~TIM_CCER_CC3E;
   \   00000008   0x6A05             LDR      R5,[R0, #+32]
   \   0000000A   0xF435 0x7580      BICS     R5,R5,#0x100
   \   0000000E   0x6205             STR      R5,[R0, #+32]
   4841            
   4842            /* Get the TIMx CCER register value */
   4843            tmpccer = TIMx->CCER;
   \   00000010   0x6A05             LDR      R5,[R0, #+32]
   \   00000012   0x002C             MOVS     R4,R5
   4844            /* Get the TIMx CR2 register value */
   4845            tmpcr2 = TIMx->CR2;
   \   00000014   0x6845             LDR      R5,[R0, #+4]
   \   00000016   0x002A             MOVS     R2,R5
   4846            
   4847            /* Get the TIMx CCMR2 register value */
   4848            tmpccmrx = TIMx->CCMR2;
   \   00000018   0x69C5             LDR      R5,[R0, #+28]
   \   0000001A   0x002B             MOVS     R3,R5
   4849              
   4850            /* Reset the Output Compare mode and Capture/Compare selection Bits */
   4851            tmpccmrx &= ~TIM_CCMR2_OC3M;
   \   0000001C   0x....             LDR.N    R5,??DataTable31_14  ;; 0xfffeff8f
   \   0000001E   0x402B             ANDS     R3,R5,R3
   4852            tmpccmrx &= ~TIM_CCMR2_CC3S;  
   \   00000020   0x089B             LSRS     R3,R3,#+2
   \   00000022   0x009B             LSLS     R3,R3,#+2
   4853            /* Select the Output Compare Mode */
   4854            tmpccmrx |= OC_Config->OCMode;
   \   00000024   0x680D             LDR      R5,[R1, #+0]
   \   00000026   0x432B             ORRS     R3,R5,R3
   4855            
   4856            /* Reset the Output Polarity level */
   4857            tmpccer &= ~TIM_CCER_CC3P;
   \   00000028   0xF434 0x7400      BICS     R4,R4,#0x200
   4858            /* Set the Output Compare Polarity */
   4859            tmpccer |= (OC_Config->OCPolarity << 8);
   \   0000002C   0x688D             LDR      R5,[R1, #+8]
   \   0000002E   0xEA54 0x2405      ORRS     R4,R4,R5, LSL #+8
   4860              
   4861            if(IS_TIM_ADVANCED_INSTANCE(TIMx) != RESET)
   \   00000032   0x....             LDR.N    R5,??DataTable31_3  ;; 0x40010000
   \   00000034   0x42A8             CMP      R0,R5
   \   00000036   0xD002             BEQ.N    ??TIM_OC3_SetConfig_0
   \   00000038   0x....             LDR.N    R5,??DataTable31_7  ;; 0x40010400
   \   0000003A   0x42A8             CMP      R0,R5
   \   0000003C   0xD101             BNE.N    ??TIM_OC3_SetConfig_1
   \                     ??TIM_OC3_SetConfig_0: (+1)
   \   0000003E   0x2501             MOVS     R5,#+1
   \   00000040   0xE000             B.N      ??TIM_OC3_SetConfig_2
   \                     ??TIM_OC3_SetConfig_1: (+1)
   \   00000042   0x2500             MOVS     R5,#+0
   \                     ??TIM_OC3_SetConfig_2: (+1)
   \   00000044   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000046   0x2D00             CMP      R5,#+0
   \   00000048   0xD010             BEQ.N    ??TIM_OC3_SetConfig_3
   4862            {
   4863              assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));
   4864              assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
   4865              assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));
   4866              
   4867              /* Reset the Output N Polarity level */
   4868              tmpccer &= ~TIM_CCER_CC3NP;
   \   0000004A   0xF434 0x6400      BICS     R4,R4,#0x800
   4869              /* Set the Output N Polarity */
   4870              tmpccer |= (OC_Config->OCNPolarity << 8);
   \   0000004E   0x68CD             LDR      R5,[R1, #+12]
   \   00000050   0xEA54 0x2405      ORRS     R4,R4,R5, LSL #+8
   4871              /* Reset the Output N State */
   4872              tmpccer &= ~TIM_CCER_CC3NE;
   \   00000054   0xF434 0x6480      BICS     R4,R4,#0x400
   4873              
   4874              /* Reset the Output Compare and Output Compare N IDLE State */
   4875              tmpcr2 &= ~TIM_CR2_OIS3;
   \   00000058   0xF432 0x5280      BICS     R2,R2,#0x1000
   4876              tmpcr2 &= ~TIM_CR2_OIS3N;
   \   0000005C   0xF432 0x5200      BICS     R2,R2,#0x2000
   4877              /* Set the Output Idle state */
   4878              tmpcr2 |= (OC_Config->OCIdleState << 4);
   \   00000060   0x694D             LDR      R5,[R1, #+20]
   \   00000062   0xEA52 0x1205      ORRS     R2,R2,R5, LSL #+4
   4879              /* Set the Output N Idle state */
   4880              tmpcr2 |= (OC_Config->OCNIdleState << 4);
   \   00000066   0x698D             LDR      R5,[R1, #+24]
   \   00000068   0xEA52 0x1205      ORRS     R2,R2,R5, LSL #+4
   4881            }
   4882            /* Write to TIMx CR2 */
   4883            TIMx->CR2 = tmpcr2;
   \                     ??TIM_OC3_SetConfig_3: (+1)
   \   0000006C   0x6042             STR      R2,[R0, #+4]
   4884            
   4885            /* Write to TIMx CCMR2 */
   4886            TIMx->CCMR2 = tmpccmrx;
   \   0000006E   0x61C3             STR      R3,[R0, #+28]
   4887            
   4888            /* Set the Capture Compare Register value */
   4889            TIMx->CCR3 = OC_Config->Pulse;
   \   00000070   0x684D             LDR      R5,[R1, #+4]
   \   00000072   0x63C5             STR      R5,[R0, #+60]
   4890            
   4891            /* Write to TIMx CCER */
   4892            TIMx->CCER = tmpccer;
   \   00000074   0x6204             STR      R4,[R0, #+32]
   4893          }
   \   00000076   0xBC30             POP      {R4,R5}
   \   00000078   0x4770             BX       LR               ;; return
   4894          
   4895          /**
   4896            * @brief  Time Output Compare 4 configuration
   4897            * @param  TIMx to select the TIM peripheral
   4898            * @param  OC_Config: The output configuration structure
   4899            * @retval None
   4900            */

   \                                 In section .text, align 2, keep-with-next
   4901          void TIM_OC4_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
   4902          {
   \                     TIM_OC4_SetConfig: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
   4903            uint32_t tmpccmrx = 0;
   \   00000002   0x2300             MOVS     R3,#+0
   4904            uint32_t tmpccer = 0;
   \   00000004   0x2400             MOVS     R4,#+0
   4905            uint32_t tmpcr2 = 0;
   \   00000006   0x2200             MOVS     R2,#+0
   4906          
   4907            /* Disable the Channel 4: Reset the CC4E Bit */
   4908            TIMx->CCER &= ~TIM_CCER_CC4E;
   \   00000008   0x6A05             LDR      R5,[R0, #+32]
   \   0000000A   0xF435 0x5580      BICS     R5,R5,#0x1000
   \   0000000E   0x6205             STR      R5,[R0, #+32]
   4909            
   4910            /* Get the TIMx CCER register value */
   4911            tmpccer = TIMx->CCER;
   \   00000010   0x6A05             LDR      R5,[R0, #+32]
   \   00000012   0x002C             MOVS     R4,R5
   4912            /* Get the TIMx CR2 register value */
   4913            tmpcr2 = TIMx->CR2;
   \   00000014   0x6845             LDR      R5,[R0, #+4]
   \   00000016   0x002A             MOVS     R2,R5
   4914            
   4915            /* Get the TIMx CCMR2 register value */
   4916            tmpccmrx = TIMx->CCMR2;
   \   00000018   0x69C5             LDR      R5,[R0, #+28]
   \   0000001A   0x002B             MOVS     R3,R5
   4917              
   4918            /* Reset the Output Compare mode and Capture/Compare selection Bits */
   4919            tmpccmrx &= ~TIM_CCMR2_OC4M;
   \   0000001C   0x....             LDR.N    R5,??DataTable31_15  ;; 0xfeff8fff
   \   0000001E   0x402B             ANDS     R3,R5,R3
   4920            tmpccmrx &= ~TIM_CCMR2_CC4S;
   \   00000020   0xF433 0x7340      BICS     R3,R3,#0x300
   4921            
   4922            /* Select the Output Compare Mode */
   4923            tmpccmrx |= (OC_Config->OCMode << 8);
   \   00000024   0x680D             LDR      R5,[R1, #+0]
   \   00000026   0xEA53 0x2305      ORRS     R3,R3,R5, LSL #+8
   4924            
   4925            /* Reset the Output Polarity level */
   4926            tmpccer &= ~TIM_CCER_CC4P;
   \   0000002A   0xF434 0x5400      BICS     R4,R4,#0x2000
   4927            /* Set the Output Compare Polarity */
   4928            tmpccer |= (OC_Config->OCPolarity << 12);
   \   0000002E   0x688D             LDR      R5,[R1, #+8]
   \   00000030   0xEA54 0x3405      ORRS     R4,R4,R5, LSL #+12
   4929             
   4930            /*if((TIMx == TIM1) || (TIMx == TIM8))*/
   4931            if(IS_TIM_ADVANCED_INSTANCE(TIMx) != RESET)
   \   00000034   0x....             LDR.N    R5,??DataTable31_3  ;; 0x40010000
   \   00000036   0x42A8             CMP      R0,R5
   \   00000038   0xD002             BEQ.N    ??TIM_OC4_SetConfig_0
   \   0000003A   0x....             LDR.N    R5,??DataTable31_7  ;; 0x40010400
   \   0000003C   0x42A8             CMP      R0,R5
   \   0000003E   0xD101             BNE.N    ??TIM_OC4_SetConfig_1
   \                     ??TIM_OC4_SetConfig_0: (+1)
   \   00000040   0x2501             MOVS     R5,#+1
   \   00000042   0xE000             B.N      ??TIM_OC4_SetConfig_2
   \                     ??TIM_OC4_SetConfig_1: (+1)
   \   00000044   0x2500             MOVS     R5,#+0
   \                     ??TIM_OC4_SetConfig_2: (+1)
   \   00000046   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000048   0x2D00             CMP      R5,#+0
   \   0000004A   0xD004             BEQ.N    ??TIM_OC4_SetConfig_3
   4932            {
   4933              assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));
   4934              /* Reset the Output Compare IDLE State */
   4935              tmpcr2 &= ~TIM_CR2_OIS4;
   \   0000004C   0xF432 0x4280      BICS     R2,R2,#0x4000
   4936              /* Set the Output Idle state */
   4937              tmpcr2 |= (OC_Config->OCIdleState << 6);
   \   00000050   0x694D             LDR      R5,[R1, #+20]
   \   00000052   0xEA52 0x1285      ORRS     R2,R2,R5, LSL #+6
   4938            }
   4939            /* Write to TIMx CR2 */
   4940            TIMx->CR2 = tmpcr2;
   \                     ??TIM_OC4_SetConfig_3: (+1)
   \   00000056   0x6042             STR      R2,[R0, #+4]
   4941            
   4942            /* Write to TIMx CCMR2 */  
   4943            TIMx->CCMR2 = tmpccmrx;
   \   00000058   0x61C3             STR      R3,[R0, #+28]
   4944              
   4945            /* Set the Capture Compare Register value */
   4946            TIMx->CCR4 = OC_Config->Pulse;
   \   0000005A   0x684D             LDR      R5,[R1, #+4]
   \   0000005C   0x6405             STR      R5,[R0, #+64]
   4947            
   4948            /* Write to TIMx CCER */
   4949            TIMx->CCER = tmpccer;
   \   0000005E   0x6204             STR      R4,[R0, #+32]
   4950          }
   \   00000060   0xBC30             POP      {R4,R5}
   \   00000062   0x4770             BX       LR               ;; return
   4951          
   4952          /**
   4953            * @brief  Time Output Compare 4 configuration
   4954            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   4955            *                the configuration information for TIM module.
   4956            * @param  sSlaveConfig: The slave configuration structure
   4957            * @retval None
   4958            */

   \                                 In section .text, align 2, keep-with-next
   4959          static void TIM_SlaveTimer_SetConfig(TIM_HandleTypeDef *htim,
   4960                                        TIM_SlaveConfigTypeDef * sSlaveConfig)
   4961          {
   \                     TIM_SlaveTimer_SetConfig: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   4962            uint32_t tmpsmcr = 0;
   \   00000008   0xF05F 0x0800      MOVS     R8,#+0
   4963            uint32_t tmpccmr1 = 0;
   \   0000000C   0x2600             MOVS     R6,#+0
   4964            uint32_t tmpccer = 0;
   \   0000000E   0x2700             MOVS     R7,#+0
   4965          
   4966           /* Get the TIMx SMCR register value */
   4967            tmpsmcr = htim->Instance->SMCR;
   \   00000010   0x6820             LDR      R0,[R4, #+0]
   \   00000012   0x6880             LDR      R0,[R0, #+8]
   \   00000014   0x4680             MOV      R8,R0
   4968          
   4969            /* Reset the Trigger Selection Bits */
   4970            tmpsmcr &= ~TIM_SMCR_TS;
   \   00000016   0xF038 0x0870      BICS     R8,R8,#0x70
   4971            /* Set the Input Trigger source */
   4972            tmpsmcr |= sSlaveConfig->InputTrigger;
   \   0000001A   0x6868             LDR      R0,[R5, #+4]
   \   0000001C   0xEA50 0x0808      ORRS     R8,R0,R8
   4973          
   4974            /* Reset the slave mode Bits */
   4975            tmpsmcr &= ~TIM_SMCR_SMS;
   \   00000020   0x....             LDR.N    R0,??DataTable31  ;; 0xfffefff8
   \   00000022   0xEA10 0x0808      ANDS     R8,R0,R8
   4976            /* Set the slave mode */
   4977            tmpsmcr |= sSlaveConfig->SlaveMode;
   \   00000026   0x6828             LDR      R0,[R5, #+0]
   \   00000028   0xEA50 0x0808      ORRS     R8,R0,R8
   4978          
   4979            /* Write to TIMx SMCR */
   4980            htim->Instance->SMCR = tmpsmcr;
   \   0000002C   0x6820             LDR      R0,[R4, #+0]
   \   0000002E   0xF8C0 0x8008      STR      R8,[R0, #+8]
   4981           
   4982            /* Configure the trigger prescaler, filter, and polarity */
   4983            switch (sSlaveConfig->InputTrigger)
   \   00000032   0x6868             LDR      R0,[R5, #+4]
   \   00000034   0x2800             CMP      R0,#+0
   \   00000036   0xD036             BEQ.N    ??TIM_SlaveTimer_SetConfig_0
   \   00000038   0x2810             CMP      R0,#+16
   \   0000003A   0xD035             BEQ.N    ??TIM_SlaveTimer_SetConfig_1
   \   0000003C   0x2820             CMP      R0,#+32
   \   0000003E   0xD034             BEQ.N    ??TIM_SlaveTimer_SetConfig_2
   \   00000040   0x2830             CMP      R0,#+48
   \   00000042   0xD033             BEQ.N    ??TIM_SlaveTimer_SetConfig_3
   \   00000044   0x2840             CMP      R0,#+64
   \   00000046   0xD00C             BEQ.N    ??TIM_SlaveTimer_SetConfig_4
   \   00000048   0x2850             CMP      R0,#+80
   \   0000004A   0xD020             BEQ.N    ??TIM_SlaveTimer_SetConfig_5
   \   0000004C   0x2860             CMP      R0,#+96
   \   0000004E   0xD024             BEQ.N    ??TIM_SlaveTimer_SetConfig_6
   \   00000050   0x2870             CMP      R0,#+112
   \   00000052   0xD12C             BNE.N    ??TIM_SlaveTimer_SetConfig_7
   4984            {
   4985            case TIM_TS_ETRF:
   4986              {
   4987                /* Check the parameters */
   4988                assert_param(IS_TIM_ETR_INSTANCE(htim->Instance));
   4989                assert_param(IS_TIM_TRIGGERPRESCALER(sSlaveConfig->TriggerPrescaler));
   4990                assert_param(IS_TIM_TRIGGERPOLARITY(sSlaveConfig->TriggerPolarity));
   4991                assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
   4992                /* Configure the ETR Trigger source */
   4993                TIM_ETR_SetConfig(htim->Instance, 
   4994                                  sSlaveConfig->TriggerPrescaler, 
   4995                                  sSlaveConfig->TriggerPolarity, 
   4996                                  sSlaveConfig->TriggerFilter);
   \                     ??TIM_SlaveTimer_SetConfig_8: (+1)
   \   00000054   0x692B             LDR      R3,[R5, #+16]
   \   00000056   0x68AA             LDR      R2,[R5, #+8]
   \   00000058   0x68E9             LDR      R1,[R5, #+12]
   \   0000005A   0x6820             LDR      R0,[R4, #+0]
   \   0000005C   0x.... 0x....      BL       TIM_ETR_SetConfig
   4997              }
   4998              break;
   \   00000060   0xE025             B.N      ??TIM_SlaveTimer_SetConfig_9
   4999              
   5000            case TIM_TS_TI1F_ED:
   5001              {
   5002                /* Check the parameters */
   5003                assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   5004                assert_param(IS_TIM_TRIGGERPOLARITY(sSlaveConfig->TriggerPolarity));
   5005                assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
   5006            
   5007                /* Disable the Channel 1: Reset the CC1E Bit */
   5008                tmpccer = htim->Instance->CCER;
   \                     ??TIM_SlaveTimer_SetConfig_4: (+1)
   \   00000062   0x6820             LDR      R0,[R4, #+0]
   \   00000064   0x6A00             LDR      R0,[R0, #+32]
   \   00000066   0x0007             MOVS     R7,R0
   5009                htim->Instance->CCER &= ~TIM_CCER_CC1E;
   \   00000068   0x6820             LDR      R0,[R4, #+0]
   \   0000006A   0x6A00             LDR      R0,[R0, #+32]
   \   0000006C   0x0840             LSRS     R0,R0,#+1
   \   0000006E   0x0040             LSLS     R0,R0,#+1
   \   00000070   0x6821             LDR      R1,[R4, #+0]
   \   00000072   0x6208             STR      R0,[R1, #+32]
   5010                tmpccmr1 = htim->Instance->CCMR1;    
   \   00000074   0x6820             LDR      R0,[R4, #+0]
   \   00000076   0x6980             LDR      R0,[R0, #+24]
   \   00000078   0x0006             MOVS     R6,R0
   5011                
   5012                /* Set the filter */
   5013                tmpccmr1 &= ~TIM_CCMR1_IC1F;
   \   0000007A   0xF036 0x06F0      BICS     R6,R6,#0xF0
   5014                tmpccmr1 |= ((sSlaveConfig->TriggerFilter) << 4);
   \   0000007E   0x6928             LDR      R0,[R5, #+16]
   \   00000080   0xEA56 0x1600      ORRS     R6,R6,R0, LSL #+4
   5015                
   5016                /* Write to TIMx CCMR1 and CCER registers */
   5017                htim->Instance->CCMR1 = tmpccmr1;
   \   00000084   0x6820             LDR      R0,[R4, #+0]
   \   00000086   0x6186             STR      R6,[R0, #+24]
   5018                htim->Instance->CCER = tmpccer;                               
   \   00000088   0x6820             LDR      R0,[R4, #+0]
   \   0000008A   0x6207             STR      R7,[R0, #+32]
   5019                                         
   5020              }
   5021              break;
   \   0000008C   0xE00F             B.N      ??TIM_SlaveTimer_SetConfig_9
   5022              
   5023            case TIM_TS_TI1FP1:
   5024              {
   5025                /* Check the parameters */
   5026                assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   5027                assert_param(IS_TIM_TRIGGERPOLARITY(sSlaveConfig->TriggerPolarity));
   5028                assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
   5029          
   5030                /* Configure TI1 Filter and Polarity */
   5031                TIM_TI1_ConfigInputStage(htim->Instance,
   5032                                         sSlaveConfig->TriggerPolarity,
   5033                                         sSlaveConfig->TriggerFilter);
   \                     ??TIM_SlaveTimer_SetConfig_5: (+1)
   \   0000008E   0x692A             LDR      R2,[R5, #+16]
   \   00000090   0x68A9             LDR      R1,[R5, #+8]
   \   00000092   0x6820             LDR      R0,[R4, #+0]
   \   00000094   0x.... 0x....      BL       TIM_TI1_ConfigInputStage
   5034              }
   5035              break;
   \   00000098   0xE009             B.N      ??TIM_SlaveTimer_SetConfig_9
   5036              
   5037            case TIM_TS_TI2FP2:
   5038              {
   5039                /* Check the parameters */
   5040                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   5041                assert_param(IS_TIM_TRIGGERPOLARITY(sSlaveConfig->TriggerPolarity));
   5042                assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
   5043            
   5044                /* Configure TI2 Filter and Polarity */
   5045                TIM_TI2_ConfigInputStage(htim->Instance,
   5046                                          sSlaveConfig->TriggerPolarity,
   5047                                          sSlaveConfig->TriggerFilter);
   \                     ??TIM_SlaveTimer_SetConfig_6: (+1)
   \   0000009A   0x692A             LDR      R2,[R5, #+16]
   \   0000009C   0x68A9             LDR      R1,[R5, #+8]
   \   0000009E   0x6820             LDR      R0,[R4, #+0]
   \   000000A0   0x.... 0x....      BL       TIM_TI2_ConfigInputStage
   5048              }
   5049              break;
   \   000000A4   0xE003             B.N      ??TIM_SlaveTimer_SetConfig_9
   5050              
   5051            case TIM_TS_ITR0:
   5052              {
   5053                /* Check the parameter */
   5054                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   5055              }
   5056              break;
   \                     ??TIM_SlaveTimer_SetConfig_0: (+1)
   \   000000A6   0xE002             B.N      ??TIM_SlaveTimer_SetConfig_9
   5057              
   5058            case TIM_TS_ITR1:
   5059              {
   5060                /* Check the parameter */
   5061                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   5062              }
   5063              break;
   \                     ??TIM_SlaveTimer_SetConfig_1: (+1)
   \   000000A8   0xE001             B.N      ??TIM_SlaveTimer_SetConfig_9
   5064              
   5065            case TIM_TS_ITR2:
   5066              {
   5067                /* Check the parameter */
   5068                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   5069              }
   5070              break;
   \                     ??TIM_SlaveTimer_SetConfig_2: (+1)
   \   000000AA   0xE000             B.N      ??TIM_SlaveTimer_SetConfig_9
   5071              
   5072            case TIM_TS_ITR3:
   5073              {
   5074                /* Check the parameter */
   5075                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   5076              }
   5077              break;
   \                     ??TIM_SlaveTimer_SetConfig_3: (+1)
   \   000000AC   0xE7FF             B.N      ??TIM_SlaveTimer_SetConfig_9
   5078                 
   5079            default:
   5080              break;
   5081            }
   5082          }
   \                     ??TIM_SlaveTimer_SetConfig_7: (+1)
   \                     ??TIM_SlaveTimer_SetConfig_9: (+1)
   \   000000AE   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   5083          
   5084          /**
   5085            * @brief  Configure the TI1 as Input.
   5086            * @param  TIMx to select the TIM peripheral.
   5087            * @param  TIM_ICPolarity : The Input Polarity.
   5088            *          This parameter can be one of the following values:
   5089            *            @arg TIM_ICPolarity_Rising
   5090            *            @arg TIM_ICPolarity_Falling
   5091            *            @arg TIM_ICPolarity_BothEdge  
   5092            * @param  TIM_ICSelection: specifies the input to be used.
   5093            *          This parameter can be one of the following values:
   5094            *            @arg TIM_ICSelection_DirectTI: TIM Input 1 is selected to be connected to IC1.
   5095            *            @arg TIM_ICSelection_IndirectTI: TIM Input 1 is selected to be connected to IC2.
   5096            *            @arg TIM_ICSelection_TRC: TIM Input 1 is selected to be connected to TRC.
   5097            * @param  TIM_ICFilter: Specifies the Input Capture Filter.
   5098            *          This parameter must be a value between 0x00 and 0x0F.
   5099            * @retval None  
   5100            * @note TIM_ICFilter and TIM_ICPolarity are not used in INDIRECT mode as TI2FP1 
   5101            *       (on channel2 path) is used as the input signal. Therefore CCMR1 must be 
   5102            *        protected against un-initialized filter and polarity values.  
   5103            */

   \                                 In section .text, align 2, keep-with-next
   5104          void TIM_TI1_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
   5105                                 uint32_t TIM_ICFilter)
   5106          {
   \                     TIM_TI1_SetConfig: (+1)
   \   00000000   0xB470             PUSH     {R4-R6}
   5107            uint32_t tmpccmr1 = 0;
   \   00000002   0x2400             MOVS     R4,#+0
   5108            uint32_t tmpccer = 0;
   \   00000004   0x2500             MOVS     R5,#+0
   5109          
   5110            /* Disable the Channel 1: Reset the CC1E Bit */
   5111            TIMx->CCER &= ~TIM_CCER_CC1E;
   \   00000006   0x6A06             LDR      R6,[R0, #+32]
   \   00000008   0x0876             LSRS     R6,R6,#+1
   \   0000000A   0x0076             LSLS     R6,R6,#+1
   \   0000000C   0x6206             STR      R6,[R0, #+32]
   5112            tmpccmr1 = TIMx->CCMR1;
   \   0000000E   0x6986             LDR      R6,[R0, #+24]
   \   00000010   0x0034             MOVS     R4,R6
   5113            tmpccer = TIMx->CCER;
   \   00000012   0x6A06             LDR      R6,[R0, #+32]
   \   00000014   0x0035             MOVS     R5,R6
   5114          
   5115            /* Select the Input */
   5116            if(IS_TIM_CC2_INSTANCE(TIMx) != RESET)
   \   00000016   0x....             LDR.N    R6,??DataTable31_3  ;; 0x40010000
   \   00000018   0x42B0             CMP      R0,R6
   \   0000001A   0xD014             BEQ.N    ??TIM_TI1_SetConfig_0
   \   0000001C   0xF1B0 0x4F80      CMP      R0,#+1073741824
   \   00000020   0xD011             BEQ.N    ??TIM_TI1_SetConfig_0
   \   00000022   0x....             LDR.N    R6,??DataTable31_4  ;; 0x40000400
   \   00000024   0x42B0             CMP      R0,R6
   \   00000026   0xD00E             BEQ.N    ??TIM_TI1_SetConfig_0
   \   00000028   0x....             LDR.N    R6,??DataTable31_5  ;; 0x40000800
   \   0000002A   0x42B0             CMP      R0,R6
   \   0000002C   0xD00B             BEQ.N    ??TIM_TI1_SetConfig_0
   \   0000002E   0x....             LDR.N    R6,??DataTable31_6  ;; 0x40000c00
   \   00000030   0x42B0             CMP      R0,R6
   \   00000032   0xD008             BEQ.N    ??TIM_TI1_SetConfig_0
   \   00000034   0x....             LDR.N    R6,??DataTable31_7  ;; 0x40010400
   \   00000036   0x42B0             CMP      R0,R6
   \   00000038   0xD005             BEQ.N    ??TIM_TI1_SetConfig_0
   \   0000003A   0x....             LDR.N    R6,??DataTable31_8  ;; 0x40014000
   \   0000003C   0x42B0             CMP      R0,R6
   \   0000003E   0xD002             BEQ.N    ??TIM_TI1_SetConfig_0
   \   00000040   0x....             LDR.N    R6,??DataTable31_11  ;; 0x40001800
   \   00000042   0x42B0             CMP      R0,R6
   \   00000044   0xD101             BNE.N    ??TIM_TI1_SetConfig_1
   \                     ??TIM_TI1_SetConfig_0: (+1)
   \   00000046   0x2601             MOVS     R6,#+1
   \   00000048   0xE000             B.N      ??TIM_TI1_SetConfig_2
   \                     ??TIM_TI1_SetConfig_1: (+1)
   \   0000004A   0x2600             MOVS     R6,#+0
   \                     ??TIM_TI1_SetConfig_2: (+1)
   \   0000004C   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000004E   0x2E00             CMP      R6,#+0
   \   00000050   0xD003             BEQ.N    ??TIM_TI1_SetConfig_3
   5117            {
   5118              tmpccmr1 &= ~TIM_CCMR1_CC1S;
   \   00000052   0x08A4             LSRS     R4,R4,#+2
   \   00000054   0x00A4             LSLS     R4,R4,#+2
   5119              tmpccmr1 |= TIM_ICSelection;
   \   00000056   0x4314             ORRS     R4,R2,R4
   \   00000058   0xE001             B.N      ??TIM_TI1_SetConfig_4
   5120            } 
   5121            else
   5122            {
   5123              tmpccmr1 |= TIM_CCMR1_CC1S_0;
   \                     ??TIM_TI1_SetConfig_3: (+1)
   \   0000005A   0xF054 0x0401      ORRS     R4,R4,#0x1
   5124            }
   5125            
   5126            /* Set the filter */
   5127            tmpccmr1 &= ~TIM_CCMR1_IC1F;
   \                     ??TIM_TI1_SetConfig_4: (+1)
   \   0000005E   0xF034 0x04F0      BICS     R4,R4,#0xF0
   5128            tmpccmr1 |= ((TIM_ICFilter << 4) & TIM_CCMR1_IC1F);
   \   00000062   0x011E             LSLS     R6,R3,#+4
   \   00000064   0xF016 0x06F0      ANDS     R6,R6,#0xF0
   \   00000068   0x4334             ORRS     R4,R6,R4
   5129          
   5130            /* Select the Polarity and set the CC1E Bit */
   5131            tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
   \   0000006A   0xF035 0x050A      BICS     R5,R5,#0xA
   5132            tmpccer |= (TIM_ICPolarity & (TIM_CCER_CC1P | TIM_CCER_CC1NP));
   \   0000006E   0xF011 0x060A      ANDS     R6,R1,#0xA
   \   00000072   0x4335             ORRS     R5,R6,R5
   5133          
   5134            /* Write to TIMx CCMR1 and CCER registers */
   5135            TIMx->CCMR1 = tmpccmr1;
   \   00000074   0x6184             STR      R4,[R0, #+24]
   5136            TIMx->CCER = tmpccer;
   \   00000076   0x6205             STR      R5,[R0, #+32]
   5137          }
   \   00000078   0xBC70             POP      {R4-R6}
   \   0000007A   0x4770             BX       LR               ;; return
   5138          
   5139          /**
   5140            * @brief  Configure the Polarity and Filter for TI1.
   5141            * @param  TIMx to select the TIM peripheral.
   5142            * @param  TIM_ICPolarity : The Input Polarity.
   5143            *          This parameter can be one of the following values:
   5144            *            @arg TIM_ICPolarity_Rising
   5145            *            @arg TIM_ICPolarity_Falling
   5146            *            @arg TIM_ICPolarity_BothEdge
   5147            * @param  TIM_ICFilter: Specifies the Input Capture Filter.
   5148            *          This parameter must be a value between 0x00 and 0x0F.
   5149            * @retval None
   5150            */

   \                                 In section .text, align 2, keep-with-next
   5151          static void TIM_TI1_ConfigInputStage(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICFilter)
   5152          {
   \                     TIM_TI1_ConfigInputStage: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
   5153            uint32_t tmpccmr1 = 0;
   \   00000002   0x2300             MOVS     R3,#+0
   5154            uint32_t tmpccer = 0;
   \   00000004   0x2400             MOVS     R4,#+0
   5155            
   5156            /* Disable the Channel 1: Reset the CC1E Bit */
   5157            tmpccer = TIMx->CCER;
   \   00000006   0x6A05             LDR      R5,[R0, #+32]
   \   00000008   0x002C             MOVS     R4,R5
   5158            TIMx->CCER &= ~TIM_CCER_CC1E;
   \   0000000A   0x6A05             LDR      R5,[R0, #+32]
   \   0000000C   0x086D             LSRS     R5,R5,#+1
   \   0000000E   0x006D             LSLS     R5,R5,#+1
   \   00000010   0x6205             STR      R5,[R0, #+32]
   5159            tmpccmr1 = TIMx->CCMR1;    
   \   00000012   0x6985             LDR      R5,[R0, #+24]
   \   00000014   0x002B             MOVS     R3,R5
   5160            
   5161            /* Set the filter */
   5162            tmpccmr1 &= ~TIM_CCMR1_IC1F;
   \   00000016   0xF033 0x03F0      BICS     R3,R3,#0xF0
   5163            tmpccmr1 |= (TIM_ICFilter << 4);
   \   0000001A   0xEA53 0x1302      ORRS     R3,R3,R2, LSL #+4
   5164            
   5165            /* Select the Polarity and set the CC1E Bit */
   5166            tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
   \   0000001E   0xF034 0x040A      BICS     R4,R4,#0xA
   5167            tmpccer |= TIM_ICPolarity;
   \   00000022   0x430C             ORRS     R4,R1,R4
   5168            
   5169            /* Write to TIMx CCMR1 and CCER registers */
   5170            TIMx->CCMR1 = tmpccmr1;
   \   00000024   0x6183             STR      R3,[R0, #+24]
   5171            TIMx->CCER = tmpccer;
   \   00000026   0x6204             STR      R4,[R0, #+32]
   5172          }
   \   00000028   0xBC30             POP      {R4,R5}
   \   0000002A   0x4770             BX       LR               ;; return
   5173          
   5174          /**
   5175            * @brief  Configure the TI2 as Input.
   5176            * @param  TIMx to select the TIM peripheral
   5177            * @param  TIM_ICPolarity : The Input Polarity.
   5178            *          This parameter can be one of the following values:
   5179            *            @arg TIM_ICPolarity_Rising
   5180            *            @arg TIM_ICPolarity_Falling
   5181            *            @arg TIM_ICPolarity_BothEdge   
   5182            * @param  TIM_ICSelection: specifies the input to be used.
   5183            *          This parameter can be one of the following values:
   5184            *            @arg TIM_ICSelection_DirectTI: TIM Input 2 is selected to be connected to IC2.
   5185            *            @arg TIM_ICSelection_IndirectTI: TIM Input 2 is selected to be connected to IC1.
   5186            *            @arg TIM_ICSelection_TRC: TIM Input 2 is selected to be connected to TRC.
   5187            * @param  TIM_ICFilter: Specifies the Input Capture Filter.
   5188            *          This parameter must be a value between 0x00 and 0x0F.
   5189            * @retval None
   5190            * @note TIM_ICFilter and TIM_ICPolarity are not used in INDIRECT mode as TI1FP2 
   5191            *       (on channel1 path) is used as the input signal. Therefore CCMR1 must be 
   5192            *        protected against un-initialized filter and polarity values.  
   5193            */

   \                                 In section .text, align 2, keep-with-next
   5194          static void TIM_TI2_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
   5195                                 uint32_t TIM_ICFilter)
   5196          {
   \                     TIM_TI2_SetConfig: (+1)
   \   00000000   0xB470             PUSH     {R4-R6}
   5197            uint32_t tmpccmr1 = 0;
   \   00000002   0x2400             MOVS     R4,#+0
   5198            uint32_t tmpccer = 0;
   \   00000004   0x2500             MOVS     R5,#+0
   5199          
   5200            /* Disable the Channel 2: Reset the CC2E Bit */
   5201            TIMx->CCER &= ~TIM_CCER_CC2E;
   \   00000006   0x6A06             LDR      R6,[R0, #+32]
   \   00000008   0xF036 0x0610      BICS     R6,R6,#0x10
   \   0000000C   0x6206             STR      R6,[R0, #+32]
   5202            tmpccmr1 = TIMx->CCMR1;
   \   0000000E   0x6986             LDR      R6,[R0, #+24]
   \   00000010   0x0034             MOVS     R4,R6
   5203            tmpccer = TIMx->CCER;
   \   00000012   0x6A06             LDR      R6,[R0, #+32]
   \   00000014   0x0035             MOVS     R5,R6
   5204          
   5205            /* Select the Input */
   5206            tmpccmr1 &= ~TIM_CCMR1_CC2S;
   \   00000016   0xF434 0x7440      BICS     R4,R4,#0x300
   5207            tmpccmr1 |= (TIM_ICSelection << 8);
   \   0000001A   0xEA54 0x2402      ORRS     R4,R4,R2, LSL #+8
   5208          
   5209            /* Set the filter */
   5210            tmpccmr1 &= ~TIM_CCMR1_IC2F;
   \   0000001E   0xF434 0x4470      BICS     R4,R4,#0xF000
   5211            tmpccmr1 |= ((TIM_ICFilter << 12) & TIM_CCMR1_IC2F);
   \   00000022   0x031E             LSLS     R6,R3,#+12
   \   00000024   0xF416 0x4670      ANDS     R6,R6,#0xF000
   \   00000028   0x4334             ORRS     R4,R6,R4
   5212          
   5213            /* Select the Polarity and set the CC2E Bit */
   5214            tmpccer &= ~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
   \   0000002A   0xF035 0x05A0      BICS     R5,R5,#0xA0
   5215            tmpccer |= ((TIM_ICPolarity << 4) & (TIM_CCER_CC2P | TIM_CCER_CC2NP));
   \   0000002E   0x010E             LSLS     R6,R1,#+4
   \   00000030   0xF016 0x06A0      ANDS     R6,R6,#0xA0
   \   00000034   0x4335             ORRS     R5,R6,R5
   5216          
   5217            /* Write to TIMx CCMR1 and CCER registers */
   5218            TIMx->CCMR1 = tmpccmr1 ;
   \   00000036   0x6184             STR      R4,[R0, #+24]
   5219            TIMx->CCER = tmpccer;
   \   00000038   0x6205             STR      R5,[R0, #+32]
   5220          }
   \   0000003A   0xBC70             POP      {R4-R6}
   \   0000003C   0x4770             BX       LR               ;; return
   5221          
   5222          /**
   5223            * @brief  Configure the Polarity and Filter for TI2.
   5224            * @param  TIMx to select the TIM peripheral.
   5225            * @param  TIM_ICPolarity : The Input Polarity.
   5226            *          This parameter can be one of the following values:
   5227            *            @arg TIM_ICPolarity_Rising
   5228            *            @arg TIM_ICPolarity_Falling
   5229            *            @arg TIM_ICPolarity_BothEdge
   5230            * @param  TIM_ICFilter: Specifies the Input Capture Filter.
   5231            *          This parameter must be a value between 0x00 and 0x0F.
   5232            * @retval None
   5233            */

   \                                 In section .text, align 2, keep-with-next
   5234          static void TIM_TI2_ConfigInputStage(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICFilter)
   5235          {
   \                     TIM_TI2_ConfigInputStage: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
   5236          uint32_t tmpccmr1 = 0;
   \   00000002   0x2300             MOVS     R3,#+0
   5237            uint32_t tmpccer = 0;
   \   00000004   0x2400             MOVS     R4,#+0
   5238            
   5239            /* Disable the Channel 2: Reset the CC2E Bit */
   5240            TIMx->CCER &= ~TIM_CCER_CC2E;
   \   00000006   0x6A05             LDR      R5,[R0, #+32]
   \   00000008   0xF035 0x0510      BICS     R5,R5,#0x10
   \   0000000C   0x6205             STR      R5,[R0, #+32]
   5241            tmpccmr1 = TIMx->CCMR1;
   \   0000000E   0x6985             LDR      R5,[R0, #+24]
   \   00000010   0x002B             MOVS     R3,R5
   5242            tmpccer = TIMx->CCER;
   \   00000012   0x6A05             LDR      R5,[R0, #+32]
   \   00000014   0x002C             MOVS     R4,R5
   5243            
   5244            /* Set the filter */
   5245            tmpccmr1 &= ~TIM_CCMR1_IC2F;
   \   00000016   0xF433 0x4370      BICS     R3,R3,#0xF000
   5246            tmpccmr1 |= (TIM_ICFilter << 12);
   \   0000001A   0xEA53 0x3302      ORRS     R3,R3,R2, LSL #+12
   5247          
   5248            /* Select the Polarity and set the CC2E Bit */
   5249            tmpccer &= ~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
   \   0000001E   0xF034 0x04A0      BICS     R4,R4,#0xA0
   5250            tmpccer |= (TIM_ICPolarity << 4);
   \   00000022   0xEA54 0x1401      ORRS     R4,R4,R1, LSL #+4
   5251          
   5252            /* Write to TIMx CCMR1 and CCER registers */
   5253            TIMx->CCMR1 = tmpccmr1 ;
   \   00000026   0x6183             STR      R3,[R0, #+24]
   5254            TIMx->CCER = tmpccer;
   \   00000028   0x6204             STR      R4,[R0, #+32]
   5255          }
   \   0000002A   0xBC30             POP      {R4,R5}
   \   0000002C   0x4770             BX       LR               ;; return
   5256          
   5257          /**
   5258            * @brief  Configure the TI3 as Input.
   5259            * @param  TIMx to select the TIM peripheral
   5260            * @param  TIM_ICPolarity : The Input Polarity.
   5261            *          This parameter can be one of the following values:
   5262            *            @arg TIM_ICPolarity_Rising
   5263            *            @arg TIM_ICPolarity_Falling
   5264            *            @arg TIM_ICPolarity_BothEdge         
   5265            * @param  TIM_ICSelection: specifies the input to be used.
   5266            *          This parameter can be one of the following values:
   5267            *            @arg TIM_ICSelection_DirectTI: TIM Input 3 is selected to be connected to IC3.
   5268            *            @arg TIM_ICSelection_IndirectTI: TIM Input 3 is selected to be connected to IC4.
   5269            *            @arg TIM_ICSelection_TRC: TIM Input 3 is selected to be connected to TRC.
   5270            * @param  TIM_ICFilter: Specifies the Input Capture Filter.
   5271            *          This parameter must be a value between 0x00 and 0x0F.
   5272            * @retval None
   5273            * @note TIM_ICFilter and TIM_ICPolarity are not used in INDIRECT mode as TI3FP4 
   5274            *       (on channel1 path) is used as the input signal. Therefore CCMR2 must be 
   5275            *        protected against un-initialized filter and polarity values.  
   5276            */

   \                                 In section .text, align 2, keep-with-next
   5277          static void TIM_TI3_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
   5278                                 uint32_t TIM_ICFilter)
   5279          {
   \                     TIM_TI3_SetConfig: (+1)
   \   00000000   0xB470             PUSH     {R4-R6}
   5280            uint32_t tmpccmr2 = 0;
   \   00000002   0x2400             MOVS     R4,#+0
   5281            uint32_t tmpccer = 0;
   \   00000004   0x2500             MOVS     R5,#+0
   5282          
   5283            /* Disable the Channel 3: Reset the CC3E Bit */
   5284            TIMx->CCER &= ~TIM_CCER_CC3E;
   \   00000006   0x6A06             LDR      R6,[R0, #+32]
   \   00000008   0xF436 0x7680      BICS     R6,R6,#0x100
   \   0000000C   0x6206             STR      R6,[R0, #+32]
   5285            tmpccmr2 = TIMx->CCMR2;
   \   0000000E   0x69C6             LDR      R6,[R0, #+28]
   \   00000010   0x0034             MOVS     R4,R6
   5286            tmpccer = TIMx->CCER;
   \   00000012   0x6A06             LDR      R6,[R0, #+32]
   \   00000014   0x0035             MOVS     R5,R6
   5287          
   5288            /* Select the Input */
   5289            tmpccmr2 &= ~TIM_CCMR2_CC3S;
   \   00000016   0x08A4             LSRS     R4,R4,#+2
   \   00000018   0x00A4             LSLS     R4,R4,#+2
   5290            tmpccmr2 |= TIM_ICSelection;
   \   0000001A   0x4314             ORRS     R4,R2,R4
   5291          
   5292            /* Set the filter */
   5293            tmpccmr2 &= ~TIM_CCMR2_IC3F;
   \   0000001C   0xF034 0x04F0      BICS     R4,R4,#0xF0
   5294            tmpccmr2 |= ((TIM_ICFilter << 4) & TIM_CCMR2_IC3F);
   \   00000020   0x011E             LSLS     R6,R3,#+4
   \   00000022   0xF016 0x06F0      ANDS     R6,R6,#0xF0
   \   00000026   0x4334             ORRS     R4,R6,R4
   5295          
   5296            /* Select the Polarity and set the CC3E Bit */
   5297            tmpccer &= ~(TIM_CCER_CC3P | TIM_CCER_CC3NP);
   \   00000028   0xF435 0x6520      BICS     R5,R5,#0xA00
   5298            tmpccer |= ((TIM_ICPolarity << 8) & (TIM_CCER_CC3P | TIM_CCER_CC3NP));
   \   0000002C   0x020E             LSLS     R6,R1,#+8
   \   0000002E   0xF416 0x6620      ANDS     R6,R6,#0xA00
   \   00000032   0x4335             ORRS     R5,R6,R5
   5299          
   5300            /* Write to TIMx CCMR2 and CCER registers */
   5301            TIMx->CCMR2 = tmpccmr2;
   \   00000034   0x61C4             STR      R4,[R0, #+28]
   5302            TIMx->CCER = tmpccer;
   \   00000036   0x6205             STR      R5,[R0, #+32]
   5303          }
   \   00000038   0xBC70             POP      {R4-R6}
   \   0000003A   0x4770             BX       LR               ;; return
   5304          
   5305          /**
   5306            * @brief  Configure the TI4 as Input.
   5307            * @param  TIMx to select the TIM peripheral
   5308            * @param  TIM_ICPolarity : The Input Polarity.
   5309            *          This parameter can be one of the following values:
   5310            *            @arg TIM_ICPolarity_Rising
   5311            *            @arg TIM_ICPolarity_Falling
   5312            *            @arg TIM_ICPolarity_BothEdge     
   5313            * @param  TIM_ICSelection: specifies the input to be used.
   5314            *          This parameter can be one of the following values:
   5315            *            @arg TIM_ICSelection_DirectTI: TIM Input 4 is selected to be connected to IC4.
   5316            *            @arg TIM_ICSelection_IndirectTI: TIM Input 4 is selected to be connected to IC3.
   5317            *            @arg TIM_ICSelection_TRC: TIM Input 4 is selected to be connected to TRC.
   5318            * @param  TIM_ICFilter: Specifies the Input Capture Filter.
   5319            *          This parameter must be a value between 0x00 and 0x0F.
   5320            * @retval None
   5321            * @note TIM_ICFilter and TIM_ICPolarity are not used in INDIRECT mode as TI4FP3 
   5322            *       (on channel1 path) is used as the input signal. Therefore CCMR2 must be 
   5323            *        protected against un-initialized filter and polarity values.  
   5324            */

   \                                 In section .text, align 2, keep-with-next
   5325          static void TIM_TI4_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
   5326                                 uint32_t TIM_ICFilter)
   5327          {
   \                     TIM_TI4_SetConfig: (+1)
   \   00000000   0xB470             PUSH     {R4-R6}
   5328            uint32_t tmpccmr2 = 0;
   \   00000002   0x2400             MOVS     R4,#+0
   5329            uint32_t tmpccer = 0;
   \   00000004   0x2500             MOVS     R5,#+0
   5330          
   5331            /* Disable the Channel 4: Reset the CC4E Bit */
   5332            TIMx->CCER &= ~TIM_CCER_CC4E;
   \   00000006   0x6A06             LDR      R6,[R0, #+32]
   \   00000008   0xF436 0x5680      BICS     R6,R6,#0x1000
   \   0000000C   0x6206             STR      R6,[R0, #+32]
   5333            tmpccmr2 = TIMx->CCMR2;
   \   0000000E   0x69C6             LDR      R6,[R0, #+28]
   \   00000010   0x0034             MOVS     R4,R6
   5334            tmpccer = TIMx->CCER;
   \   00000012   0x6A06             LDR      R6,[R0, #+32]
   \   00000014   0x0035             MOVS     R5,R6
   5335          
   5336            /* Select the Input */
   5337            tmpccmr2 &= ~TIM_CCMR2_CC4S;
   \   00000016   0xF434 0x7440      BICS     R4,R4,#0x300
   5338            tmpccmr2 |= (TIM_ICSelection << 8);
   \   0000001A   0xEA54 0x2402      ORRS     R4,R4,R2, LSL #+8
   5339          
   5340            /* Set the filter */
   5341            tmpccmr2 &= ~TIM_CCMR2_IC4F;
   \   0000001E   0xF434 0x4470      BICS     R4,R4,#0xF000
   5342            tmpccmr2 |= ((TIM_ICFilter << 12) & TIM_CCMR2_IC4F);
   \   00000022   0x031E             LSLS     R6,R3,#+12
   \   00000024   0xF416 0x4670      ANDS     R6,R6,#0xF000
   \   00000028   0x4334             ORRS     R4,R6,R4
   5343          
   5344            /* Select the Polarity and set the CC4E Bit */
   5345            tmpccer &= ~(TIM_CCER_CC4P | TIM_CCER_CC4NP);
   \   0000002A   0xF435 0x4520      BICS     R5,R5,#0xA000
   5346            tmpccer |= ((TIM_ICPolarity << 12) & (TIM_CCER_CC4P | TIM_CCER_CC4NP));
   \   0000002E   0x030E             LSLS     R6,R1,#+12
   \   00000030   0xF416 0x4620      ANDS     R6,R6,#0xA000
   \   00000034   0x4335             ORRS     R5,R6,R5
   5347          
   5348            /* Write to TIMx CCMR2 and CCER registers */
   5349            TIMx->CCMR2 = tmpccmr2;
   \   00000036   0x61C4             STR      R4,[R0, #+28]
   5350            TIMx->CCER = tmpccer ;
   \   00000038   0x6205             STR      R5,[R0, #+32]
   5351          }
   \   0000003A   0xBC70             POP      {R4-R6}
   \   0000003C   0x4770             BX       LR               ;; return
   5352          
   5353          /**
   5354            * @brief  Selects the Input Trigger source
   5355            * @param  TIMx to select the TIM peripheral
   5356            * @param  TIM_ITRx: The Input Trigger source.
   5357            *          This parameter can be one of the following values:
   5358            *            @arg TIM_TS_ITR0: Internal Trigger 0
   5359            *            @arg TIM_TS_ITR1: Internal Trigger 1
   5360            *            @arg TIM_TS_ITR2: Internal Trigger 2
   5361            *            @arg TIM_TS_ITR3: Internal Trigger 3
   5362            *            @arg TIM_TS_TI1F_ED: TI1 Edge Detector
   5363            *            @arg TIM_TS_TI1FP1: Filtered Timer Input 1
   5364            *            @arg TIM_TS_TI2FP2: Filtered Timer Input 2
   5365            *            @arg TIM_TS_ETRF: External Trigger input
   5366            * @retval None
   5367            */

   \                                 In section .text, align 2, keep-with-next
   5368          static void TIM_ITRx_SetConfig(TIM_TypeDef *TIMx, uint16_t TIM_ITRx)
   5369          {
   5370            uint32_t tmpsmcr = 0;
   \                     TIM_ITRx_SetConfig: (+1)
   \   00000000   0x2200             MOVS     R2,#+0
   5371            
   5372             /* Get the TIMx SMCR register value */
   5373             tmpsmcr = TIMx->SMCR;
   \   00000002   0x6883             LDR      R3,[R0, #+8]
   \   00000004   0x001A             MOVS     R2,R3
   5374             /* Reset the TS Bits */
   5375             tmpsmcr &= ~TIM_SMCR_TS;
   \   00000006   0xF032 0x0270      BICS     R2,R2,#0x70
   5376             /* Set the Input Trigger source and the slave mode*/
   5377             tmpsmcr |= TIM_ITRx | TIM_SLAVEMODE_EXTERNAL1;
   \   0000000A   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000000C   0xF051 0x0307      ORRS     R3,R1,#0x7
   \   00000010   0x431A             ORRS     R2,R3,R2
   5378             /* Write to TIMx SMCR */
   5379             TIMx->SMCR = tmpsmcr;
   \   00000012   0x6082             STR      R2,[R0, #+8]
   5380          }
   \   00000014   0x4770             BX       LR               ;; return
   5381          
   5382          /**
   5383            * @brief  Configures the TIMx External Trigger (ETR).
   5384            * @param  TIMx to select the TIM peripheral
   5385            * @param  TIM_ExtTRGPrescaler: The external Trigger Prescaler.
   5386            *          This parameter can be one of the following values:
   5387            *            @arg TIM_ExtTRGPSC_DIV1: ETRP Prescaler OFF.
   5388            *            @arg TIM_ExtTRGPSC_DIV2: ETRP frequency divided by 2.
   5389            *            @arg TIM_ExtTRGPSC_DIV4: ETRP frequency divided by 4.
   5390            *            @arg TIM_ExtTRGPSC_DIV8: ETRP frequency divided by 8.
   5391            * @param  TIM_ExtTRGPolarity: The external Trigger Polarity.
   5392            *          This parameter can be one of the following values:
   5393            *            @arg TIM_ExtTRGPolarity_Inverted: active low or falling edge active.
   5394            *            @arg TIM_ExtTRGPolarity_NonInverted: active high or rising edge active.
   5395            * @param  ExtTRGFilter: External Trigger Filter.
   5396            *          This parameter must be a value between 0x00 and 0x0F
   5397            * @retval None
   5398            */

   \                                 In section .text, align 2, keep-with-next
   5399          void TIM_ETR_SetConfig(TIM_TypeDef* TIMx, uint32_t TIM_ExtTRGPrescaler,
   5400                                 uint32_t TIM_ExtTRGPolarity, uint32_t ExtTRGFilter)
   5401          {
   \                     TIM_ETR_SetConfig: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
   5402            uint32_t tmpsmcr = 0;
   \   00000002   0x2400             MOVS     R4,#+0
   5403          
   5404            tmpsmcr = TIMx->SMCR;
   \   00000004   0x6885             LDR      R5,[R0, #+8]
   \   00000006   0x002C             MOVS     R4,R5
   5405          
   5406            /* Reset the ETR Bits */
   5407            tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
   \   00000008   0xF434 0x447F      BICS     R4,R4,#0xFF00
   5408          
   5409            /* Set the Prescaler, the Filter value and the Polarity */
   5410            tmpsmcr |= (uint32_t)(TIM_ExtTRGPrescaler | (TIM_ExtTRGPolarity | (ExtTRGFilter << 8)));
   \   0000000C   0xEA52 0x0501      ORRS     R5,R2,R1
   \   00000010   0xEA55 0x2503      ORRS     R5,R5,R3, LSL #+8
   \   00000014   0x432C             ORRS     R4,R5,R4
   5411          
   5412            /* Write to TIMx SMCR */
   5413            TIMx->SMCR = tmpsmcr;
   \   00000016   0x6084             STR      R4,[R0, #+8]
   5414          } 
   \   00000018   0xBC30             POP      {R4,R5}
   \   0000001A   0x4770             BX       LR               ;; return
   5415          
   5416          /**
   5417            * @brief  Enables or disables the TIM Capture Compare Channel x.
   5418            * @param  TIMx to select the TIM peripheral
   5419            * @param  Channel: specifies the TIM Channel
   5420            *          This parameter can be one of the following values:
   5421            *            @arg TIM_Channel_1: TIM Channel 1
   5422            *            @arg TIM_Channel_2: TIM Channel 2
   5423            *            @arg TIM_Channel_3: TIM Channel 3
   5424            *            @arg TIM_Channel_4: TIM Channel 4
   5425            * @param  ChannelState: specifies the TIM Channel CCxE bit new state.
   5426            *          This parameter can be: TIM_CCx_ENABLE or TIM_CCx_Disable. 
   5427            * @retval None
   5428            */

   \                                 In section .text, align 2, keep-with-next
   5429          void TIM_CCxChannelCmd(TIM_TypeDef* TIMx, uint32_t Channel, uint32_t ChannelState)
   5430          {
   \                     TIM_CCxChannelCmd: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
   5431            uint32_t tmp = 0;
   \   00000002   0x2300             MOVS     R3,#+0
   5432          
   5433            /* Check the parameters */
   5434            assert_param(IS_TIM_CC1_INSTANCE(TIMx)); 
   5435            assert_param(IS_TIM_CHANNELS(Channel));
   5436          
   5437            tmp = TIM_CCER_CC1E << Channel;
   \   00000004   0x2401             MOVS     R4,#+1
   \   00000006   0x408C             LSLS     R4,R4,R1
   \   00000008   0x0023             MOVS     R3,R4
   5438          
   5439            /* Reset the CCxE Bit */
   5440            TIMx->CCER &= ~tmp;
   \   0000000A   0x6A04             LDR      R4,[R0, #+32]
   \   0000000C   0x439C             BICS     R4,R4,R3
   \   0000000E   0x6204             STR      R4,[R0, #+32]
   5441          
   5442            /* Set or reset the CCxE Bit */ 
   5443            TIMx->CCER |= (uint32_t)(ChannelState << Channel);
   \   00000010   0x6A04             LDR      R4,[R0, #+32]
   \   00000012   0xFA12 0xF501      LSLS     R5,R2,R1
   \   00000016   0x432C             ORRS     R4,R5,R4
   \   00000018   0x6204             STR      R4,[R0, #+32]
   5444          }
   \   0000001A   0xBC30             POP      {R4,R5}
   \   0000001C   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12:
   \   00000000   0x........         DC32     TIM_DMAPeriodElapsedCplt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13:
   \   00000000   0x........         DC32     TIM_DMAError

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_1:
   \   00000000   0x40010000         DC32     0x40010000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14:
   \   00000000   0x40010400         DC32     0x40010400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17:
   \   00000000   0x........         DC32     TIM_DMADelayPulseCplt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_1:
   \   00000000   0x........         DC32     TIM_DMAError

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20:
   \   00000000   0x........         DC32     TIM_DMACaptureCplt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21:
   \   00000000   0x40010000         DC32     0x40010000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_1:
   \   00000000   0x40010400         DC32     0x40010400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22:
   \   00000000   0xFFFEFFF8         DC32     0xfffefff8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_1:
   \   00000000   0xFFFFFCFC         DC32     0xfffffcfc

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_2:
   \   00000000   0xFFFFF3F3         DC32     0xfffff3f3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_3:
   \   00000000   0xFFFF0F0F         DC32     0xffff0f0f

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23:
   \   00000000   0x........         DC32     TIM_DMAError

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31:
   \   00000000   0xFFFEFFF8         DC32     0xfffefff8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_1:
   \   00000000   0x........         DC32     TIMEx_DMACommutationCplt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_2:
   \   00000000   0xFFFEFF88         DC32     0xfffeff88

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_3:
   \   00000000   0x40010000         DC32     0x40010000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_4:
   \   00000000   0x40000400         DC32     0x40000400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_5:
   \   00000000   0x40000800         DC32     0x40000800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_6:
   \   00000000   0x40000C00         DC32     0x40000c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_7:
   \   00000000   0x40010400         DC32     0x40010400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_8:
   \   00000000   0x40014000         DC32     0x40014000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_9:
   \   00000000   0x40014400         DC32     0x40014400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_10:
   \   00000000   0x40014800         DC32     0x40014800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_11:
   \   00000000   0x40001800         DC32     0x40001800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_12:
   \   00000000   0x40001C00         DC32     0x40001c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_13:
   \   00000000   0x40002000         DC32     0x40002000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_14:
   \   00000000   0xFFFEFF8F         DC32     0xfffeff8f

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_15:
   \   00000000   0xFEFF8FFF         DC32     0xfeff8fff
   5445          
   5446          
   5447          /**
   5448            * @}
   5449            */
   5450          
   5451          #endif /* HAL_TIM_MODULE_ENABLED */
   5452          /**
   5453            * @}
   5454            */ 
   5455          
   5456          /**
   5457            * @}
   5458            */ 
   5459          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   HAL_TIM_Base_DeInit
         8   -> HAL_TIM_Base_MspDeInit
       0   HAL_TIM_Base_GetState
       8   HAL_TIM_Base_Init
         8   -> HAL_TIM_Base_MspInit
         8   -> TIM_Base_SetConfig
       0   HAL_TIM_Base_MspDeInit
       0   HAL_TIM_Base_MspInit
       0   HAL_TIM_Base_Start
      16   HAL_TIM_Base_Start_DMA
        16   -> HAL_DMA_Start_IT
       0   HAL_TIM_Base_Start_IT
       0   HAL_TIM_Base_Stop
       0   HAL_TIM_Base_Stop_DMA
       0   HAL_TIM_Base_Stop_IT
      16   HAL_TIM_ConfigClockSource
        16   -> TIM_ETR_SetConfig
        16   -> TIM_ITRx_SetConfig
        16   -> TIM_TI1_ConfigInputStage
        16   -> TIM_TI2_ConfigInputStage
      16   HAL_TIM_ConfigOCrefClear
        16   -> TIM_ETR_SetConfig
       0   HAL_TIM_ConfigTI1Input
      24   HAL_TIM_DMABurst_ReadStart
        24   -> HAL_DMA_Start_IT
      16   HAL_TIM_DMABurst_ReadStop
        16   -> HAL_DMA_Abort
      24   HAL_TIM_DMABurst_WriteStart
        24   -> HAL_DMA_Start_IT
      16   HAL_TIM_DMABurst_WriteStop
        16   -> HAL_DMA_Abort
       8   HAL_TIM_Encoder_DeInit
         8   -> HAL_TIM_Encoder_MspDeInit
       0   HAL_TIM_Encoder_GetState
      24   HAL_TIM_Encoder_Init
        24   -> HAL_TIM_Encoder_MspInit
        24   -> TIM_Base_SetConfig
       0   HAL_TIM_Encoder_MspDeInit
       0   HAL_TIM_Encoder_MspInit
      16   HAL_TIM_Encoder_Start
        16   -> TIM_CCxChannelCmd
      24   HAL_TIM_Encoder_Start_DMA
        24   -> HAL_DMA_Start_IT
        24   -> TIM_CCxChannelCmd
      16   HAL_TIM_Encoder_Start_IT
        16   -> TIM_CCxChannelCmd
      16   HAL_TIM_Encoder_Stop
        16   -> TIM_CCxChannelCmd
      16   HAL_TIM_Encoder_Stop_DMA
        16   -> TIM_CCxChannelCmd
      16   HAL_TIM_Encoder_Stop_IT
        16   -> TIM_CCxChannelCmd
       0   HAL_TIM_ErrorCallback
       0   HAL_TIM_GenerateEvent
       0   HAL_TIM_IC_CaptureCallback
      16   HAL_TIM_IC_ConfigChannel
        16   -> TIM_TI1_SetConfig
        16   -> TIM_TI2_SetConfig
        16   -> TIM_TI3_SetConfig
        16   -> TIM_TI4_SetConfig
       8   HAL_TIM_IC_DeInit
         8   -> HAL_TIM_IC_MspDeInit
       0   HAL_TIM_IC_GetState
       8   HAL_TIM_IC_Init
         8   -> HAL_TIM_IC_MspInit
         8   -> TIM_Base_SetConfig
       0   HAL_TIM_IC_MspDeInit
       0   HAL_TIM_IC_MspInit
      16   HAL_TIM_IC_Start
        16   -> TIM_CCxChannelCmd
      24   HAL_TIM_IC_Start_DMA
        24   -> HAL_DMA_Start_IT
        24   -> TIM_CCxChannelCmd
      16   HAL_TIM_IC_Start_IT
        16   -> TIM_CCxChannelCmd
      16   HAL_TIM_IC_Stop
        16   -> TIM_CCxChannelCmd
      16   HAL_TIM_IC_Stop_DMA
        16   -> TIM_CCxChannelCmd
      16   HAL_TIM_IC_Stop_IT
        16   -> TIM_CCxChannelCmd
       8   HAL_TIM_IRQHandler
         8   -> HAL_TIMEx_BreakCallback
         8   -> HAL_TIMEx_CommutationCallback
         8   -> HAL_TIM_IC_CaptureCallback
         8   -> HAL_TIM_OC_DelayElapsedCallback
         8   -> HAL_TIM_PWM_PulseFinishedCallback
         8   -> HAL_TIM_PeriodElapsedCallback
         8   -> HAL_TIM_TriggerCallback
      16   HAL_TIM_OC_ConfigChannel
        16   -> TIM_OC1_SetConfig
        16   -> TIM_OC2_SetConfig
        16   -> TIM_OC3_SetConfig
        16   -> TIM_OC4_SetConfig
       8   HAL_TIM_OC_DeInit
         8   -> HAL_TIM_OC_MspDeInit
       0   HAL_TIM_OC_DelayElapsedCallback
       0   HAL_TIM_OC_GetState
       8   HAL_TIM_OC_Init
         8   -> HAL_TIM_OC_MspInit
         8   -> TIM_Base_SetConfig
       0   HAL_TIM_OC_MspDeInit
       0   HAL_TIM_OC_MspInit
      16   HAL_TIM_OC_Start
        16   -> TIM_CCxChannelCmd
      24   HAL_TIM_OC_Start_DMA
        24   -> HAL_DMA_Start_IT
        24   -> TIM_CCxChannelCmd
      16   HAL_TIM_OC_Start_IT
        16   -> TIM_CCxChannelCmd
      16   HAL_TIM_OC_Stop
        16   -> TIM_CCxChannelCmd
      16   HAL_TIM_OC_Stop_DMA
        16   -> TIM_CCxChannelCmd
      16   HAL_TIM_OC_Stop_IT
        16   -> TIM_CCxChannelCmd
      48   HAL_TIM_OnePulse_ConfigChannel
        48   -> TIM_OC1_SetConfig
        48   -> TIM_OC2_SetConfig
        48   -> TIM_TI1_SetConfig
        48   -> TIM_TI2_SetConfig
       8   HAL_TIM_OnePulse_DeInit
         8   -> HAL_TIM_OnePulse_MspDeInit
       0   HAL_TIM_OnePulse_GetState
      16   HAL_TIM_OnePulse_Init
        16   -> HAL_TIM_OnePulse_MspInit
        16   -> TIM_Base_SetConfig
       0   HAL_TIM_OnePulse_MspDeInit
       0   HAL_TIM_OnePulse_MspInit
      16   HAL_TIM_OnePulse_Start
        16   -> TIM_CCxChannelCmd
      16   HAL_TIM_OnePulse_Start_IT
        16   -> TIM_CCxChannelCmd
      16   HAL_TIM_OnePulse_Stop
        16   -> TIM_CCxChannelCmd
      16   HAL_TIM_OnePulse_Stop_IT
        16   -> TIM_CCxChannelCmd
      16   HAL_TIM_PWM_ConfigChannel
        16   -> TIM_OC1_SetConfig
        16   -> TIM_OC2_SetConfig
        16   -> TIM_OC3_SetConfig
        16   -> TIM_OC4_SetConfig
       8   HAL_TIM_PWM_DeInit
         8   -> HAL_TIM_PWM_MspDeInit
       0   HAL_TIM_PWM_GetState
       8   HAL_TIM_PWM_Init
         8   -> HAL_TIM_PWM_MspInit
         8   -> TIM_Base_SetConfig
       0   HAL_TIM_PWM_MspDeInit
       0   HAL_TIM_PWM_MspInit
       0   HAL_TIM_PWM_PulseFinishedCallback
      16   HAL_TIM_PWM_Start
        16   -> TIM_CCxChannelCmd
      24   HAL_TIM_PWM_Start_DMA
        24   -> HAL_DMA_Start_IT
        24   -> TIM_CCxChannelCmd
      16   HAL_TIM_PWM_Start_IT
        16   -> TIM_CCxChannelCmd
      16   HAL_TIM_PWM_Stop
        16   -> TIM_CCxChannelCmd
      16   HAL_TIM_PWM_Stop_DMA
        16   -> TIM_CCxChannelCmd
      16   HAL_TIM_PWM_Stop_IT
        16   -> TIM_CCxChannelCmd
       0   HAL_TIM_PeriodElapsedCallback
       0   HAL_TIM_ReadCapturedValue
      24   HAL_TIM_SlaveConfigSynchronization
        24   -> TIM_ETR_SetConfig
        24   -> TIM_TI1_ConfigInputStage
        24   -> TIM_TI2_ConfigInputStage
      16   HAL_TIM_SlaveConfigSynchronization_IT
        16   -> TIM_SlaveTimer_SetConfig
       0   HAL_TIM_TriggerCallback
       0   TIM_Base_SetConfig
       8   TIM_CCxChannelCmd
      16   TIM_DMACaptureCplt
        16   -> HAL_TIM_IC_CaptureCallback
      16   TIM_DMADelayPulseCplt
        16   -> HAL_TIM_PWM_PulseFinishedCallback
      16   TIM_DMAError
        16   -> HAL_TIM_ErrorCallback
      16   TIM_DMAPeriodElapsedCplt
        16   -> HAL_TIM_PeriodElapsedCallback
      16   TIM_DMATriggerCplt
        16   -> HAL_TIM_TriggerCallback
       8   TIM_ETR_SetConfig
       0   TIM_ITRx_SetConfig
       8   TIM_OC1_SetConfig
       8   TIM_OC2_SetConfig
       8   TIM_OC3_SetConfig
       8   TIM_OC4_SetConfig
      24   TIM_SlaveTimer_SetConfig
        24   -> TIM_ETR_SetConfig
        24   -> TIM_TI1_ConfigInputStage
        24   -> TIM_TI2_ConfigInputStage
       8   TIM_TI1_ConfigInputStage
      12   TIM_TI1_SetConfig
       8   TIM_TI2_ConfigInputStage
      12   TIM_TI2_SetConfig
      12   TIM_TI3_SetConfig
      12   TIM_TI4_SetConfig


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable12
       4  ??DataTable13
       4  ??DataTable13_1
       4  ??DataTable14
       4  ??DataTable17
       4  ??DataTable17_1
       4  ??DataTable20
       4  ??DataTable21
       4  ??DataTable21_1
       4  ??DataTable22
       4  ??DataTable22_1
       4  ??DataTable22_2
       4  ??DataTable22_3
       4  ??DataTable23
       4  ??DataTable31
       4  ??DataTable31_1
       4  ??DataTable31_10
       4  ??DataTable31_11
       4  ??DataTable31_12
       4  ??DataTable31_13
       4  ??DataTable31_14
       4  ??DataTable31_15
       4  ??DataTable31_2
       4  ??DataTable31_3
       4  ??DataTable31_4
       4  ??DataTable31_5
       4  ??DataTable31_6
       4  ??DataTable31_7
       4  ??DataTable31_8
       4  ??DataTable31_9
      68  HAL_TIM_Base_DeInit
       6  HAL_TIM_Base_GetState
      50  HAL_TIM_Base_Init
       2  HAL_TIM_Base_MspDeInit
       2  HAL_TIM_Base_MspInit
      30  HAL_TIM_Base_Start
     110  HAL_TIM_Base_Start_DMA
      30  HAL_TIM_Base_Start_IT
      54  HAL_TIM_Base_Stop
      60  HAL_TIM_Base_Stop_DMA
      54  HAL_TIM_Base_Stop_IT
     292  HAL_TIM_ConfigClockSource
     222  HAL_TIM_ConfigOCrefClear
      24  HAL_TIM_ConfigTI1Input
     382  HAL_TIM_DMABurst_ReadStart
     122  HAL_TIM_DMABurst_ReadStop
     382  HAL_TIM_DMABurst_WriteStart
     122  HAL_TIM_DMABurst_WriteStop
      68  HAL_TIM_Encoder_DeInit
       6  HAL_TIM_Encoder_GetState
     190  HAL_TIM_Encoder_Init
       2  HAL_TIM_Encoder_MspDeInit
       2  HAL_TIM_Encoder_MspInit
      78  HAL_TIM_Encoder_Start
     346  HAL_TIM_Encoder_Start_DMA
     126  HAL_TIM_Encoder_Start_IT
     102  HAL_TIM_Encoder_Stop
     152  HAL_TIM_Encoder_Stop_DMA
     152  HAL_TIM_Encoder_Stop_IT
       2  HAL_TIM_ErrorCallback
      46  HAL_TIM_GenerateEvent
       2  HAL_TIM_IC_CaptureCallback
     214  HAL_TIM_IC_ConfigChannel
      68  HAL_TIM_IC_DeInit
       6  HAL_TIM_IC_GetState
      56  HAL_TIM_IC_Init
       2  HAL_TIM_IC_MspDeInit
       2  HAL_TIM_IC_MspInit
      32  HAL_TIM_IC_Start
     284  HAL_TIM_IC_Start_DMA
     108  HAL_TIM_IC_Start_IT
      56  HAL_TIM_IC_Stop
     138  HAL_TIM_IC_Stop_DMA
     132  HAL_TIM_IC_Stop_IT
     404  HAL_TIM_IRQHandler
     108  HAL_TIM_OC_ConfigChannel
      68  HAL_TIM_OC_DeInit
       2  HAL_TIM_OC_DelayElapsedCallback
       6  HAL_TIM_OC_GetState
      56  HAL_TIM_OC_Init
       2  HAL_TIM_OC_MspDeInit
       2  HAL_TIM_OC_MspInit
      76  HAL_TIM_OC_Start
     332  HAL_TIM_OC_Start_DMA
     152  HAL_TIM_OC_Start_IT
     124  HAL_TIM_OC_Stop
     206  HAL_TIM_OC_Stop_DMA
     200  HAL_TIM_OC_Stop_IT
     284  HAL_TIM_OnePulse_ConfigChannel
      68  HAL_TIM_OnePulse_DeInit
       6  HAL_TIM_OnePulse_GetState
      80  HAL_TIM_OnePulse_Init
       2  HAL_TIM_OnePulse_MspDeInit
       2  HAL_TIM_OnePulse_MspInit
      72  HAL_TIM_OnePulse_Start
      98  HAL_TIM_OnePulse_Start_IT
     134  HAL_TIM_OnePulse_Stop
     158  HAL_TIM_OnePulse_Stop_IT
     256  HAL_TIM_PWM_ConfigChannel
      68  HAL_TIM_PWM_DeInit
       6  HAL_TIM_PWM_GetState
      56  HAL_TIM_PWM_Init
       2  HAL_TIM_PWM_MspDeInit
       2  HAL_TIM_PWM_MspInit
       2  HAL_TIM_PWM_PulseFinishedCallback
      76  HAL_TIM_PWM_Start
     332  HAL_TIM_PWM_Start_DMA
     152  HAL_TIM_PWM_Start_IT
     130  HAL_TIM_PWM_Stop
     204  HAL_TIM_PWM_Stop_DMA
     200  HAL_TIM_PWM_Stop_IT
       2  HAL_TIM_PeriodElapsedCallback
      84  HAL_TIM_ReadCapturedValue
     212  HAL_TIM_SlaveConfigSynchronization
      78  HAL_TIM_SlaveConfigSynchronization_IT
       2  HAL_TIM_TriggerCallback
     230  TIM_Base_SetConfig
      30  TIM_CCxChannelCmd
      70  TIM_DMACaptureCplt
      70  TIM_DMADelayPulseCplt
      20  TIM_DMAError
      20  TIM_DMAPeriodElapsedCplt
      20  TIM_DMATriggerCplt
      28  TIM_ETR_SetConfig
      22  TIM_ITRx_SetConfig
     114  TIM_OC1_SetConfig
     124  TIM_OC2_SetConfig
     122  TIM_OC3_SetConfig
     100  TIM_OC4_SetConfig
     178  TIM_SlaveTimer_SetConfig
      44  TIM_TI1_ConfigInputStage
     124  TIM_TI1_SetConfig
      46  TIM_TI2_ConfigInputStage
      62  TIM_TI2_SetConfig
      60  TIM_TI3_SetConfig
      62  TIM_TI4_SetConfig

 
 10 556 bytes in section .text
 
 10 556 bytes of CODE memory

Errors: none
Warnings: none
