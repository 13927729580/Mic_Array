###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.2.10312/W32 for ARM       21/Dec/2015  22:48:25
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_tim.c
#    Command line =  
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_tim.c
#        -D USE_HAL_DRIVER -D STM32F746xx -D USE_STM32746G_DISCO -D
#        USE_IOEXPANDER -D USE_USB_FS -lC
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
#        -lA
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
#        -o
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj
#        --debug --endian=little --cpu=Cortex-M7 -e --fpu=VFPv5_sp
#        --dlib_config "D:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Full.h" -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\Inc\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\CMSIS\Device\ST\STM32F7xx\Include\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\STM32F7xx_HAL_Driver\Inc\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\STM32746G-Discovery\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\Components\Common\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Log\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Fonts\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\CPU\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_Device_Library\Core\Inc\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Core\Inc\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Class\MSC\Inc\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\drivers\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_Audio\Addons\PDM\
#        -Ohz --use_c++_inline --require_prototypes -I "D:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.3\arm\CMSIS\Include\" -D
#        ARM_MATH_CM7
#    List file    =  
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List\stm32f7xx_hal_tim.lst
#    Object file  =  
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj\stm32f7xx_hal_tim.o
#
###############################################################################

H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_tim.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f7xx_hal_tim.c
      4            * @author  MCD Application Team
      5            * @version V1.0.1
      6            * @date    25-June-2015
      7            * @brief   TIM HAL module driver.
      8            *          This file provides firmware functions to manage the following 
      9            *          functionalities of the Timer (TIM) peripheral:
     10            *           + Time Base Initialization
     11            *           + Time Base Start
     12            *           + Time Base Start Interruption
     13            *           + Time Base Start DMA
     14            *           + Time Output Compare/PWM Initialization
     15            *           + Time Output Compare/PWM Channel Configuration
     16            *           + Time Output Compare/PWM  Start
     17            *           + Time Output Compare/PWM  Start Interruption
     18            *           + Time Output Compare/PWM Start DMA
     19            *           + Time Input Capture Initialization
     20            *           + Time Input Capture Channel Configuration
     21            *           + Time Input Capture Start
     22            *           + Time Input Capture Start Interruption 
     23            *           + Time Input Capture Start DMA
     24            *           + Time One Pulse Initialization
     25            *           + Time One Pulse Channel Configuration
     26            *           + Time One Pulse Start 
     27            *           + Time Encoder Interface Initialization
     28            *           + Time Encoder Interface Start
     29            *           + Time Encoder Interface Start Interruption
     30            *           + Time Encoder Interface Start DMA
     31            *           + Commutation Event configuration with Interruption and DMA
     32            *           + Time OCRef clear configuration
     33            *           + Time External Clock configuration
     34            @verbatim 
     35            ==============================================================================
     36                                ##### TIMER Generic features #####
     37            ==============================================================================
     38            [..] The Timer features include: 
     39                 (#) 16-bit up, down, up/down auto-reload counter.
     40                 (#) 16-bit programmable prescaler allowing dividing (also on the fly) the 
     41                     counter clock frequency either by any factor between 1 and 65536.
     42                 (#) Up to 4 independent channels for:
     43                     (++) Input Capture
     44                     (++) Output Compare
     45                     (++) PWM generation (Edge and Center-aligned Mode)
     46                     (++) One-pulse mode output               
     47             
     48                                  ##### How to use this driver #####
     49            ==============================================================================
     50              [..]
     51               (#) Initialize the TIM low level resources by implementing the following functions 
     52                   depending from feature used :
     53                     (++) Time Base : HAL_TIM_Base_MspInit() 
     54                     (++) Input Capture : HAL_TIM_IC_MspInit()
     55                     (++) Output Compare : HAL_TIM_OC_MspInit()
     56                     (++) PWM generation : HAL_TIM_PWM_MspInit()
     57                     (++) One-pulse mode output : HAL_TIM_OnePulse_MspInit()
     58                     (++) Encoder mode output : HAL_TIM_Encoder_MspInit()
     59                     
     60               (#) Initialize the TIM low level resources :
     61                  (##) Enable the TIM interface clock using __TIMx_CLK_ENABLE(); 
     62                  (##) TIM pins configuration
     63                      (+++) Enable the clock for the TIM GPIOs using the following function:
     64                           __GPIOx_CLK_ENABLE();   
     65                      (+++) Configure these TIM pins in Alternate function mode using HAL_GPIO_Init();  
     66          
     67               (#) The external Clock can be configured, if needed (the default clock is the 
     68                   internal clock from the APBx), using the following function:
     69                   HAL_TIM_ConfigClockSource, the clock configuration should be done before 
     70                   any start function.
     71            
     72               (#) Configure the TIM in the desired functioning mode using one of the 
     73                   initialization function of this driver:
     74                   (++) HAL_TIM_Base_Init: to use the Timer to generate a simple time base
     75                   (++) HAL_TIM_OC_Init and HAL_TIM_OC_ConfigChannel: to use the Timer to generate an 
     76                        Output Compare signal.
     77                   (++) HAL_TIM_PWM_Init and HAL_TIM_PWM_ConfigChannel: to use the Timer to generate a 
     78                        PWM signal.
     79                   (++) HAL_TIM_IC_Init and HAL_TIM_IC_ConfigChannel: to use the Timer to measure an 
     80                        external signal.
     81                   (++) HAL_TIM_OnePulse_Init and HAL_TIM_OnePulse_ConfigChannel: to use the Timer 
     82                        in One Pulse Mode.
     83                   (++) HAL_TIM_Encoder_Init: to use the Timer Encoder Interface.
     84                   
     85               (#) Activate the TIM peripheral using one of the start functions depending from the feature used: 
     86                     (++) Time Base : HAL_TIM_Base_Start(), HAL_TIM_Base_Start_DMA(), HAL_TIM_Base_Start_IT()
     87                     (++) Input Capture :  HAL_TIM_IC_Start(), HAL_TIM_IC_Start_DMA(), HAL_TIM_IC_Start_IT()
     88                     (++) Output Compare : HAL_TIM_OC_Start(), HAL_TIM_OC_Start_DMA(), HAL_TIM_OC_Start_IT()
     89                     (++) PWM generation : HAL_TIM_PWM_Start(), HAL_TIM_PWM_Start_DMA(), HAL_TIM_PWM_Start_IT()
     90                     (++) One-pulse mode output : HAL_TIM_OnePulse_Start(), HAL_TIM_OnePulse_Start_IT()
     91                     (++) Encoder mode output : HAL_TIM_Encoder_Start(), HAL_TIM_Encoder_Start_DMA(), HAL_TIM_Encoder_Start_IT().
     92          
     93               (#) The DMA Burst is managed with the two following functions:
     94                   HAL_TIM_DMABurst_WriteStart()
     95                   HAL_TIM_DMABurst_ReadStart()
     96            
     97            @endverbatim
     98            ******************************************************************************
     99            * @attention
    100            *
    101            * <h2><center>&copy; COPYRIGHT(c) 2015 STMicroelectronics</center></h2>
    102            *
    103            * Redistribution and use in source and binary forms, with or without modification,
    104            * are permitted provided that the following conditions are met:
    105            *   1. Redistributions of source code must retain the above copyright notice,
    106            *      this list of conditions and the following disclaimer.
    107            *   2. Redistributions in binary form must reproduce the above copyright notice,
    108            *      this list of conditions and the following disclaimer in the documentation
    109            *      and/or other materials provided with the distribution.
    110            *   3. Neither the name of STMicroelectronics nor the names of its contributors
    111            *      may be used to endorse or promote products derived from this software
    112            *      without specific prior written permission.
    113            *
    114            * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
    115            * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
    116            * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
    117            * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
    118            * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
    119            * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
    120            * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
    121            * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
    122            * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
    123            * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
    124            *
    125            ******************************************************************************
    126            */ 
    127          
    128          /* Includes ------------------------------------------------------------------*/
    129          #include "stm32f7xx_hal.h"
    130          
    131          /** @addtogroup STM32F7xx_HAL_Driver
    132            * @{
    133            */
    134          
    135          /** @defgroup TIM TIM
    136            * @brief TIM HAL module driver
    137            * @{
    138            */
    139          
    140          #ifdef HAL_TIM_MODULE_ENABLED
    141          
    142          /* Private typedef -----------------------------------------------------------*/
    143          /* Private define ------------------------------------------------------------*/
    144          /* Private macro -------------------------------------------------------------*/
    145          /* Private variables ---------------------------------------------------------*/
    146          /** @addtogroup TIM_Private_Functions
    147            * @{
    148            */
    149          /* Private function prototypes -----------------------------------------------*/
    150          static void TIM_TI1_ConfigInputStage(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICFilter);
    151          static void TIM_TI2_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
    152                                 uint32_t TIM_ICFilter);
    153          static void TIM_TI2_ConfigInputStage(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICFilter);
    154          static void TIM_TI3_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
    155                                 uint32_t TIM_ICFilter);
    156          static void TIM_TI4_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
    157                                 uint32_t TIM_ICFilter);
    158          
    159          static void TIM_ITRx_SetConfig(TIM_TypeDef* TIMx, uint16_t TIM_ITRx);
    160          static void TIM_DMAPeriodElapsedCplt(DMA_HandleTypeDef *hdma);
    161          static void TIM_DMATriggerCplt(DMA_HandleTypeDef *hdma);
    162          static void TIM_SlaveTimer_SetConfig(TIM_HandleTypeDef *htim,
    163                                               TIM_SlaveConfigTypeDef * sSlaveConfig);
    164          /**
    165            * @}
    166            */
    167            
    168          /* Exported functions --------------------------------------------------------*/
    169          /** @defgroup TIM_Exported_Functions TIM Exported Functions
    170            * @{
    171            */
    172          
    173          /** @defgroup TIM_Exported_Functions_Group1 Time Base functions 
    174           *  @brief    Time Base functions 
    175           *
    176          @verbatim    
    177            ==============================================================================
    178                        ##### Time Base functions #####
    179            ==============================================================================
    180            [..]  
    181              This section provides functions allowing to:
    182              (+) Initialize and configure the TIM base. 
    183              (+) De-initialize the TIM base.
    184              (+) Start the Time Base.
    185              (+) Stop the Time Base.
    186              (+) Start the Time Base and enable interrupt.
    187              (+) Stop the Time Base and disable interrupt.
    188              (+) Start the Time Base and enable DMA transfer.
    189              (+) Stop the Time Base and disable DMA transfer.
    190           
    191          @endverbatim
    192            * @{
    193            */
    194          /**
    195            * @brief  Initializes the TIM Time base Unit according to the specified
    196            *         parameters in the TIM_HandleTypeDef and create the associated handle.
    197            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
    198            *                the configuration information for TIM module.
    199            * @retval HAL status
    200            */

   \                                 In section .text, align 2, keep-with-next
    201          HAL_StatusTypeDef HAL_TIM_Base_Init(TIM_HandleTypeDef *htim)
    202          { 
   \                     HAL_TIM_Base_Init: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    203            /* Check the TIM handle allocation */
    204            if(htim == NULL)
   \   00000004   0xD101             BNE.N    ??HAL_TIM_Base_Init_0
    205            {
    206              return HAL_ERROR;
   \   00000006   0x2001             MOVS     R0,#+1
   \   00000008   0xBD10             POP      {R4,PC}
    207            }
    208            
    209            /* Check the parameters */
    210            assert_param(IS_TIM_INSTANCE(htim->Instance)); 
    211            assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
    212            assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
    213            
    214            if(htim->State == HAL_TIM_STATE_RESET)
   \                     ??HAL_TIM_Base_Init_0: (+1)
   \   0000000A   0xF894 0x0039      LDRB     R0,[R4, #+57]
   \   0000000E   0xB910             CBNZ.N   R0,??HAL_TIM_Base_Init_1
    215            {  
    216              /* Init the low level hardware : GPIO, CLOCK, NVIC */
    217              HAL_TIM_Base_MspInit(htim);
   \   00000010   0x4620             MOV      R0,R4
   \   00000012   0x.... 0x....      BL       HAL_TIM_Base_MspInit
    218            }
    219            
    220            /* Set the TIM state */
    221            htim->State= HAL_TIM_STATE_BUSY;
   \                     ??HAL_TIM_Base_Init_1: (+1)
   \   00000016   0x2002             MOVS     R0,#+2
    222            
    223            /* Set the Time Base configuration */
    224            TIM_Base_SetConfig(htim->Instance, &htim->Init); 
   \   00000018   0x1D21             ADDS     R1,R4,#+4
   \   0000001A   0xF884 0x0039      STRB     R0,[R4, #+57]
   \   0000001E   0x6820             LDR      R0,[R4, #+0]
   \   00000020   0x.... 0x....      BL       TIM_Base_SetConfig
    225            
    226            /* Initialize the TIM state*/
    227            htim->State= HAL_TIM_STATE_READY;
   \   00000024   0x....             B.N      ??Subroutine1_0
    228            
    229            return HAL_OK;
    230          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \   00000000   0xD103             BNE.N    ??Subroutine1_0
   \   00000002   0x6801             LDR      R1,[R0, #+0]
   \   00000004   0x0849             LSRS     R1,R1,#+1
   \   00000006   0x0049             LSLS     R1,R1,#+1
   \   00000008   0x6001             STR      R1,[R0, #+0]
   \                     ??Subroutine1_0: (+1)
   \   0000000A   0x2001             MOVS     R0,#+1
   \   0000000C   0xF884 0x0039      STRB     R0,[R4, #+57]
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0xBD10             POP      {R4,PC}          ;; return
    231          
    232          /**
    233            * @brief  DeInitializes the TIM Base peripheral 
    234            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
    235            *                the configuration information for TIM module.
    236            * @retval HAL status
    237            */

   \                                 In section .text, align 2, keep-with-next
    238          HAL_StatusTypeDef HAL_TIM_Base_DeInit(TIM_HandleTypeDef *htim)
    239          {  
   \                     HAL_TIM_Base_DeInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    240            /* Check the parameters */
    241            assert_param(IS_TIM_INSTANCE(htim->Instance));
    242          
    243            htim->State = HAL_TIM_STATE_BUSY;
   \   00000002   0x.... 0x....      BL       ?Subroutine55
    244             
    245            /* Disable the TIM Peripheral Clock */
    246            __HAL_TIM_DISABLE(htim);
   \                     ??CrossCallReturnLabel_172: (+1)
   \   00000006   0xBF02             ITTT     EQ 
   \   00000008   0x6A0A             LDREQ    R2,[R1, #+32]
   \   0000000A   0xF240 0x4344      MOVWEQ   R3,#+1092
   \   0000000E   0x421A             TSTEQ    R2,R3
   \   00000010   0x.... 0x....      BL       ?Subroutine12
    247              
    248            /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
    249            HAL_TIM_Base_MspDeInit(htim);
   \                     ??CrossCallReturnLabel_8: (+1)
   \   00000014   0x.... 0x....      BL       HAL_TIM_Base_MspDeInit
    250            
    251            /* Change TIM state */  
    252            htim->State = HAL_TIM_STATE_RESET; 
   \   00000018   0x....             B.N      ?Subroutine4
    253            
    254            /* Release Lock */
    255            __HAL_UNLOCK(htim);
    256          
    257            return HAL_OK;
    258          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine4: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x7060             STRB     R0,[R4, #+1]
   \   00000004   0x7020             STRB     R0,[R4, #+0]
   \   00000006   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine55: (+1)
   \   00000000   0xF100 0x0438      ADD      R4,R0,#+56
   \   00000004   0x2102             MOVS     R1,#+2
   \   00000006   0x7061             STRB     R1,[R4, #+1]
   \   00000008   0x6801             LDR      R1,[R0, #+0]
   \   0000000A   0xF241 0x1311      MOVW     R3,#+4369
   \   0000000E   0x6A0A             LDR      R2,[R1, #+32]
   \   00000010   0x421A             TST      R2,R3
   \   00000012   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine12: (+1)
   \   00000000   0xD103             BNE.N    ??Subroutine12_0
   \   00000002   0x680A             LDR      R2,[R1, #+0]
   \   00000004   0x0852             LSRS     R2,R2,#+1
   \   00000006   0x0052             LSLS     R2,R2,#+1
   \   00000008   0x600A             STR      R2,[R1, #+0]
   \                     ??Subroutine12_0: (+1)
   \   0000000A   0x4770             BX       LR
    259          
    260          /**
    261            * @brief  Initializes the TIM Base MSP.
    262            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
    263            *                the configuration information for TIM module.
    264            * @retval None
    265            */

   \                                 In section .text, align 2, keep-with-next
    266          __weak void HAL_TIM_Base_MspInit(TIM_HandleTypeDef *htim)
    267          {
    268            /* NOTE : This function Should not be modified, when the callback is needed,
    269                      the HAL_TIM_Base_MspInit could be implemented in the user file
    270             */
    271          }
   \                     HAL_TIM_Base_MspInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    272          
    273          /**
    274            * @brief  DeInitializes TIM Base MSP.
    275            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
    276            *                the configuration information for TIM module.
    277            * @retval None
    278            */

   \                                 In section .text, align 2, keep-with-next
    279          __weak void HAL_TIM_Base_MspDeInit(TIM_HandleTypeDef *htim)
    280          {
    281            /* NOTE : This function Should not be modified, when the callback is needed,
    282                      the HAL_TIM_Base_MspDeInit could be implemented in the user file
    283             */
    284          }
   \                     HAL_TIM_Base_MspDeInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    285          
    286          /**
    287            * @brief  Starts the TIM Base generation.
    288            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
    289            *                the configuration information for TIM module.
    290            * @retval HAL status
    291            */

   \                                 In section .text, align 2, keep-with-next
    292          HAL_StatusTypeDef HAL_TIM_Base_Start(TIM_HandleTypeDef *htim)
    293          {
    294            /* Check the parameters */
    295            assert_param(IS_TIM_INSTANCE(htim->Instance));
    296            
    297            /* Set the TIM state */
    298            htim->State= HAL_TIM_STATE_BUSY;
   \                     HAL_TIM_Base_Start: (+1)
   \   00000000   0x2102             MOVS     R1,#+2
   \   00000002   0xF880 0x1039      STRB     R1,[R0, #+57]
    299            
    300            /* Enable the Peripheral */
    301            __HAL_TIM_ENABLE(htim);
   \   00000006   0x6801             LDR      R1,[R0, #+0]
   \   00000008   0x680A             LDR      R2,[R1, #+0]
   \   0000000A   0xF042 0x0201      ORR      R2,R2,#0x1
   \   0000000E   0x600A             STR      R2,[R1, #+0]
    302            
    303            /* Change the TIM state*/
    304            htim->State= HAL_TIM_STATE_READY;
   \   00000010   0x....             B.N      ??Subroutine6_0
    305            
    306            /* Return function status */
    307            return HAL_OK;
    308          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine6: (+1)
   \   00000000   0xD103             BNE.N    ??Subroutine6_0
   \   00000002   0x680A             LDR      R2,[R1, #+0]
   \   00000004   0x0852             LSRS     R2,R2,#+1
   \   00000006   0x0052             LSLS     R2,R2,#+1
   \   00000008   0x600A             STR      R2,[R1, #+0]
   \                     ??Subroutine6_0: (+1)
   \   0000000A   0x2101             MOVS     R1,#+1
   \   0000000C   0xF880 0x1039      STRB     R1,[R0, #+57]
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0x4770             BX       LR               ;; return
    309          
    310          /**
    311            * @brief  Stops the TIM Base generation.
    312            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
    313            *                the configuration information for TIM module.
    314            * @retval HAL status
    315            */

   \                                 In section .text, align 2, keep-with-next
    316          HAL_StatusTypeDef HAL_TIM_Base_Stop(TIM_HandleTypeDef *htim)
    317          {
    318            /* Check the parameters */
    319            assert_param(IS_TIM_INSTANCE(htim->Instance));
    320            
    321            /* Set the TIM state */
    322            htim->State= HAL_TIM_STATE_BUSY;
   \                     HAL_TIM_Base_Stop: (+1)
   \   00000000   0x2102             MOVS     R1,#+2
    323            
    324            /* Disable the Peripheral */
    325            __HAL_TIM_DISABLE(htim);
   \   00000002   0xF241 0x1311      MOVW     R3,#+4369
   \   00000006   0xF880 0x1039      STRB     R1,[R0, #+57]
   \   0000000A   0x6801             LDR      R1,[R0, #+0]
   \   0000000C   0x6A0A             LDR      R2,[R1, #+32]
   \   0000000E   0x421A             TST      R2,R3
   \   00000010   0xBF02             ITTT     EQ 
   \   00000012   0x6A0A             LDREQ    R2,[R1, #+32]
   \   00000014   0xF240 0x4344      MOVWEQ   R3,#+1092
   \   00000018   0x421A             TSTEQ    R2,R3
   \   0000001A   0x....             B.N      ?Subroutine6
    326            
    327            /* Change the TIM state*/
    328            htim->State= HAL_TIM_STATE_READY;
    329            
    330            /* Return function status */
    331            return HAL_OK;
    332          }
    333          
    334          /**
    335            * @brief  Starts the TIM Base generation in interrupt mode.
    336            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
    337            *                the configuration information for TIM module.
    338            * @retval HAL status
    339            */

   \                                 In section .text, align 2, keep-with-next
    340          HAL_StatusTypeDef HAL_TIM_Base_Start_IT(TIM_HandleTypeDef *htim)
    341          {
    342            /* Check the parameters */
    343            assert_param(IS_TIM_INSTANCE(htim->Instance));
    344            
    345            /* Enable the TIM Update interrupt */
    346            __HAL_TIM_ENABLE_IT(htim, TIM_IT_UPDATE);
   \                     HAL_TIM_Base_Start_IT: (+1)
   \   00000000   0x6800             LDR      R0,[R0, #+0]
   \   00000002   0x68C1             LDR      R1,[R0, #+12]
   \   00000004   0xF041 0x0101      ORR      R1,R1,#0x1
   \   00000008   0x60C1             STR      R1,[R0, #+12]
    347                
    348            /* Enable the Peripheral */
    349            __HAL_TIM_ENABLE(htim);
   \   0000000A   0x6801             LDR      R1,[R0, #+0]
   \   0000000C   0xF041 0x0101      ORR      R1,R1,#0x1
   \   00000010   0x6001             STR      R1,[R0, #+0]
    350                
    351            /* Return function status */
    352            return HAL_OK;
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0x4770             BX       LR               ;; return
    353          }
    354          
    355          /**
    356            * @brief  Stops the TIM Base generation in interrupt mode.
    357            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
    358            *                the configuration information for TIM module.
    359            * @retval HAL status
    360            */

   \                                 In section .text, align 2, keep-with-next
    361          HAL_StatusTypeDef HAL_TIM_Base_Stop_IT(TIM_HandleTypeDef *htim)
    362          {
    363            /* Check the parameters */
    364            assert_param(IS_TIM_INSTANCE(htim->Instance));
    365            /* Disable the TIM Update interrupt */
    366            __HAL_TIM_DISABLE_IT(htim, TIM_IT_UPDATE);
   \                     HAL_TIM_Base_Stop_IT: (+1)
   \   00000000   0x6800             LDR      R0,[R0, #+0]
    367                
    368            /* Disable the Peripheral */
    369            __HAL_TIM_DISABLE(htim);
   \   00000002   0xF241 0x1211      MOVW     R2,#+4369
   \   00000006   0x68C1             LDR      R1,[R0, #+12]
   \   00000008   0x0849             LSRS     R1,R1,#+1
   \   0000000A   0x0049             LSLS     R1,R1,#+1
   \   0000000C   0x60C1             STR      R1,[R0, #+12]
   \   0000000E   0x6A01             LDR      R1,[R0, #+32]
   \   00000010   0x4211             TST      R1,R2
   \   00000012   0xBF02             ITTT     EQ 
   \   00000014   0x6A01             LDREQ    R1,[R0, #+32]
   \   00000016   0xF240 0x4244      MOVWEQ   R2,#+1092
   \   0000001A   0x4211             TSTEQ    R1,R2
   \   0000001C   0xD103             BNE.N    ??HAL_TIM_Base_Stop_IT_0
   \   0000001E   0x6801             LDR      R1,[R0, #+0]
   \   00000020   0x0849             LSRS     R1,R1,#+1
   \   00000022   0x0049             LSLS     R1,R1,#+1
   \   00000024   0x6001             STR      R1,[R0, #+0]
    370              
    371            /* Return function status */
    372            return HAL_OK;
   \                     ??HAL_TIM_Base_Stop_IT_0: (+1)
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0x4770             BX       LR               ;; return
    373          }
    374          
    375          /**
    376            * @brief  Starts the TIM Base generation in DMA mode.
    377            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
    378            *                the configuration information for TIM module.
    379            * @param  pData: The source Buffer address.
    380            * @param  Length: The length of data to be transferred from memory to peripheral.
    381            * @retval HAL status
    382            */

   \                                 In section .text, align 2, keep-with-next
    383          HAL_StatusTypeDef HAL_TIM_Base_Start_DMA(TIM_HandleTypeDef *htim, uint32_t *pData, uint16_t Length)
    384          {
   \                     HAL_TIM_Base_Start_DMA: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    385            /* Check the parameters */
    386            assert_param(IS_TIM_DMA_INSTANCE(htim->Instance)); 
    387            
    388            if((htim->State == HAL_TIM_STATE_BUSY))
   \   00000004   0x.... 0x....      BL       ??Subroutine15_0
   \                     ??CrossCallReturnLabel_21: (+1)
   \   00000008   0xD01C             BEQ.N    ??CrossCallReturnLabel_128
    389            {
    390               return HAL_BUSY;
    391            }
    392            else if((htim->State == HAL_TIM_STATE_READY))
   \   0000000A   0x.... 0x....      BL       ??Subroutine16_0
   \                     ??CrossCallReturnLabel_27: (+1)
   \   0000000E   0xD103             BNE.N    ??CrossCallReturnLabel_31
    393            {
    394              if((pData == 0 ) && (Length > 0)) 
   \   00000010   0xB901             CBNZ.N   R1,??HAL_TIM_Base_Start_DMA_0
   \   00000012   0xB9BA             CBNZ.N   R2,??CrossCallReturnLabel_128
    395              {
    396                return HAL_ERROR;                                    
    397              }
    398              else
    399              {
    400                htim->State = HAL_TIM_STATE_BUSY;
   \                     ??HAL_TIM_Base_Start_DMA_0: (+1)
   \   00000014   0x.... 0x....      BL       ?Subroutine17
    401              }
    402            }  
    403            /* Set the DMA Period elapsed callback */
    404            htim->hdma[TIM_DMA_ID_UPDATE]->XferCpltCallback = TIM_DMAPeriodElapsedCplt;
   \                     ??CrossCallReturnLabel_31: (+1)
   \   00000018   0x69E3             LDR      R3,[R4, #+28]
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable17
   \   0000001E   0x63D8             STR      R0,[R3, #+60]
    405               
    406            /* Set the DMA error callback */
    407            htim->hdma[TIM_DMA_ID_UPDATE]->XferErrorCallback = HAL_TIM_DMAError ;
   \   00000020   0x69E3             LDR      R3,[R4, #+28]
   \   00000022   0x.... 0x....      LDR.W    R0,??DataTable17_1
   \   00000026   0x6498             STR      R0,[R3, #+72]
    408            
    409            /* Enable the DMA Stream */
    410            HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_UPDATE], (uint32_t)pData, (uint32_t)&htim->Instance->ARR, Length);
   \   00000028   0x6820             LDR      R0,[R4, #+0]
   \   0000002A   0x4613             MOV      R3,R2
   \   0000002C   0xF100 0x022C      ADD      R2,R0,#+44
   \   00000030   0x69E0             LDR      R0,[R4, #+28]
   \   00000032   0x.... 0x....      BL       HAL_DMA_Start_IT
    411            
    412            /* Enable the TIM Update DMA request */
    413            __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_UPDATE);
   \   00000036   0x6820             LDR      R0,[R4, #+0]
   \   00000038   0x68C1             LDR      R1,[R0, #+12]
   \   0000003A   0xF441 0x7180      ORR      R1,R1,#0x100
   \   0000003E   0x60C1             STR      R1,[R0, #+12]
    414          
    415            /* Enable the Peripheral */
    416            __HAL_TIM_ENABLE(htim);  
   \   00000040   0x.... 0x....      BL       ?Subroutine39
    417            
    418            /* Return function status */
    419            return HAL_OK;
   \                     ??CrossCallReturnLabel_128: (+1)
   \   00000044   0xBD10             POP      {R4,PC}          ;; return
    420          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine39: (+1)
   \   00000000   0x6820             LDR      R0,[R4, #+0]
   \   00000002   0x6801             LDR      R1,[R0, #+0]
   \   00000004   0xF041 0x0101      ORR      R1,R1,#0x1
   \   00000008   0x6001             STR      R1,[R0, #+0]
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine17: (+1)
   \   00000000   0x2002             MOVS     R0,#+2
   \   00000002   0xF884 0x0039      STRB     R0,[R4, #+57]
   \   00000006   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine16: (+1)
   \   00000000   0x9F06             LDR      R7,[SP, #+24]
   \                     ??Subroutine16_0: (+1)
   \   00000002   0xF894 0x0039      LDRB     R0,[R4, #+57]
   \   00000006   0x2801             CMP      R0,#+1
   \   00000008   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine15: (+1)
   \   00000000   0x4604             MOV      R4,R0
   \   00000002   0x460D             MOV      R5,R1
   \   00000004   0x4611             MOV      R1,R2
   \                     ??Subroutine15_0: (+1)
   \   00000006   0xF894 0x0039      LDRB     R0,[R4, #+57]
   \   0000000A   0x2802             CMP      R0,#+2
   \   0000000C   0x4770             BX       LR
    421          
    422          /**
    423            * @brief  Stops the TIM Base generation in DMA mode.
    424            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
    425            *                the configuration information for TIM module.
    426            * @retval HAL status
    427            */

   \                                 In section .text, align 2, keep-with-next
    428          HAL_StatusTypeDef HAL_TIM_Base_Stop_DMA(TIM_HandleTypeDef *htim)
    429          {
    430            /* Check the parameters */
    431            assert_param(IS_TIM_DMA_INSTANCE(htim->Instance));
    432            
    433            /* Disable the TIM Update DMA request */
    434            __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_UPDATE);
   \                     HAL_TIM_Base_Stop_DMA: (+1)
   \   00000000   0x6801             LDR      R1,[R0, #+0]
    435                
    436            /* Disable the Peripheral */
    437            __HAL_TIM_DISABLE(htim);
   \   00000002   0xF241 0x1311      MOVW     R3,#+4369
   \   00000006   0x68CA             LDR      R2,[R1, #+12]
   \   00000008   0xF422 0x7280      BIC      R2,R2,#0x100
   \   0000000C   0x60CA             STR      R2,[R1, #+12]
   \   0000000E   0x6801             LDR      R1,[R0, #+0]
   \   00000010   0x6A0A             LDR      R2,[R1, #+32]
   \   00000012   0x421A             TST      R2,R3
   \   00000014   0xBF02             ITTT     EQ 
   \   00000016   0x6A0A             LDREQ    R2,[R1, #+32]
   \   00000018   0xF240 0x4344      MOVWEQ   R3,#+1092
   \   0000001C   0x421A             TSTEQ    R2,R3
   \   0000001E                      REQUIRE ?Subroutine6
   \   0000001E                      ;; // Fall through to label ?Subroutine6
    438              
    439            /* Change the htim state */
    440            htim->State = HAL_TIM_STATE_READY;
    441                
    442            /* Return function status */
    443            return HAL_OK;
    444          }
    445          
    446          /**
    447            * @}
    448            */
    449            
    450          /** @defgroup TIM_Exported_Functions_Group2 Time Output Compare functions 
    451           *  @brief    Time Output Compare functions 
    452           *
    453          @verbatim    
    454            ==============================================================================
    455                            ##### Time Output Compare functions #####
    456            ==============================================================================
    457            [..]
    458              This section provides functions allowing to:
    459              (+) Initialize and configure the TIM Output Compare. 
    460              (+) De-initialize the TIM Output Compare.
    461              (+) Start the Time Output Compare.
    462              (+) Stop the Time Output Compare.
    463              (+) Start the Time Output Compare and enable interrupt.
    464              (+) Stop the Time Output Compare and disable interrupt.
    465              (+) Start the Time Output Compare and enable DMA transfer.
    466              (+) Stop the Time Output Compare and disable DMA transfer.
    467           
    468          @endverbatim
    469            * @{
    470            */
    471          /**
    472            * @brief  Initializes the TIM Output Compare according to the specified
    473            *         parameters in the TIM_HandleTypeDef and create the associated handle.
    474            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
    475            *                the configuration information for TIM module.
    476            * @retval HAL status
    477            */

   \                                 In section .text, align 2, keep-with-next
    478          HAL_StatusTypeDef HAL_TIM_OC_Init(TIM_HandleTypeDef* htim)
    479          {
   \                     HAL_TIM_OC_Init: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    480            /* Check the TIM handle allocation */
    481            if(htim == NULL)
   \   00000004   0xD101             BNE.N    ??HAL_TIM_OC_Init_0
    482            {
    483              return HAL_ERROR;
   \   00000006   0x2001             MOVS     R0,#+1
   \   00000008   0xBD32             POP      {R1,R4,R5,PC}
    484            }
    485          
    486            /* Check the parameters */
    487            assert_param(IS_TIM_INSTANCE(htim->Instance));
    488            assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
    489            assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
    490           
    491            if(htim->State == HAL_TIM_STATE_RESET)
   \                     ??HAL_TIM_OC_Init_0: (+1)
   \   0000000A   0xF104 0x0538      ADD      R5,R4,#+56
   \   0000000E   0x7868             LDRB     R0,[R5, #+1]
   \   00000010   0xB918             CBNZ.N   R0,??HAL_TIM_OC_Init_1
    492            { 
    493              /* Allocate lock resource and initialize it */
    494              htim->Lock = HAL_UNLOCKED;  
   \   00000012   0x7028             STRB     R0,[R5, #+0]
    495              /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
    496              HAL_TIM_OC_MspInit(htim);
   \   00000014   0x4620             MOV      R0,R4
   \   00000016   0x.... 0x....      BL       HAL_TIM_OC_MspInit
    497            }
    498            
    499            /* Set the TIM state */
    500            htim->State= HAL_TIM_STATE_BUSY;
   \                     ??HAL_TIM_OC_Init_1: (+1)
   \   0000001A   0x....             B.N      ?Subroutine9
    501            
    502            /* Init the base time for the Output Compare */  
    503            TIM_Base_SetConfig(htim->Instance,  &htim->Init); 
    504            
    505            /* Initialize the TIM state*/
    506            htim->State= HAL_TIM_STATE_READY;
    507            
    508            return HAL_OK;
    509          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine9: (+1)
   \   00000000   0x2002             MOVS     R0,#+2
   \   00000002   0x1D21             ADDS     R1,R4,#+4
   \   00000004   0x7068             STRB     R0,[R5, #+1]
   \   00000006   0x6820             LDR      R0,[R4, #+0]
   \   00000008   0x.... 0x....      BL       TIM_Base_SetConfig
   \   0000000C   0x2001             MOVS     R0,#+1
   \   0000000E   0x7068             STRB     R0,[R5, #+1]
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    510          
    511          /**
    512            * @brief  DeInitializes the TIM peripheral 
    513            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
    514            *                the configuration information for TIM module.
    515            * @retval HAL status
    516            */

   \                                 In section .text, align 2, keep-with-next
    517          HAL_StatusTypeDef HAL_TIM_OC_DeInit(TIM_HandleTypeDef *htim)
    518          {
   \                     HAL_TIM_OC_DeInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    519            /* Check the parameters */
    520            assert_param(IS_TIM_INSTANCE(htim->Instance));
    521            
    522             htim->State = HAL_TIM_STATE_BUSY;
   \   00000002   0x.... 0x....      BL       ?Subroutine55
    523             
    524            /* Disable the TIM Peripheral Clock */
    525            __HAL_TIM_DISABLE(htim);
   \                     ??CrossCallReturnLabel_173: (+1)
   \   00000006   0xBF02             ITTT     EQ 
   \   00000008   0x6A0A             LDREQ    R2,[R1, #+32]
   \   0000000A   0xF240 0x4344      MOVWEQ   R3,#+1092
   \   0000000E   0x421A             TSTEQ    R2,R3
   \   00000010   0x.... 0x....      BL       ?Subroutine12
    526            
    527            /* DeInit the low level hardware: GPIO, CLOCK, NVIC and DMA */
    528            HAL_TIM_OC_MspDeInit(htim);
   \                     ??CrossCallReturnLabel_9: (+1)
   \   00000014   0x.... 0x....      BL       HAL_TIM_OC_MspDeInit
    529              
    530            /* Change TIM state */  
    531            htim->State = HAL_TIM_STATE_RESET; 
   \   00000018                      REQUIRE ?Subroutine4
   \   00000018                      ;; // Fall through to label ?Subroutine4
    532          
    533            /* Release Lock */
    534            __HAL_UNLOCK(htim);
    535          
    536            return HAL_OK;
    537          }
    538          
    539          /**
    540            * @brief  Initializes the TIM Output Compare MSP.
    541            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
    542            *                the configuration information for TIM module.
    543            * @retval None
    544            */

   \                                 In section .text, align 2, keep-with-next
    545          __weak void HAL_TIM_OC_MspInit(TIM_HandleTypeDef *htim)
    546          {
    547            /* NOTE : This function Should not be modified, when the callback is needed,
    548                      the HAL_TIM_OC_MspInit could be implemented in the user file
    549             */
    550          }
   \                     HAL_TIM_OC_MspInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    551          
    552          /**
    553            * @brief  DeInitializes TIM Output Compare MSP.
    554            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
    555            *                the configuration information for TIM module.
    556            * @retval None
    557            */

   \                                 In section .text, align 2, keep-with-next
    558          __weak void HAL_TIM_OC_MspDeInit(TIM_HandleTypeDef *htim)
    559          {
    560            /* NOTE : This function Should not be modified, when the callback is needed,
    561                      the HAL_TIM_OC_MspDeInit could be implemented in the user file
    562             */
    563          }
   \                     HAL_TIM_OC_MspDeInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    564          
    565          /**
    566            * @brief  Starts the TIM Output Compare signal generation.
    567            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
    568            *                the configuration information for TIM module.  
    569            * @param  Channel: TIM Channel to be enabled.
    570            *          This parameter can be one of the following values:
    571            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
    572            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
    573            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
    574            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected   
    575            * @retval HAL status
    576            */

   \                                 In section .text, align 2, keep-with-next
    577          HAL_StatusTypeDef HAL_TIM_OC_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
    578          {
   \                     HAL_TIM_OC_Start: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x.... 0x....      BL       ?Subroutine22
    579            /* Check the parameters */
    580            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
    581            
    582            /* Enable the Output compare channel */
    583            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
    584            
    585            if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
   \                     ??CrossCallReturnLabel_74: (+1)
   \   00000006   0x.... 0x....      BL       ?Subroutine20
   \                     ??CrossCallReturnLabel_51: (+1)
   \   0000000A   0xBF1C             ITT      NE 
   \   0000000C   0x.... 0x....      LDRNE.W  R1,??DataTable17_2  ;; 0x40010400
   \   00000010   0x4288             CMPNE    R0,R1
   \   00000012   0x....             B.N      ?Subroutine0
    586            {
    587              /* Enable the main output */
    588              __HAL_TIM_MOE_ENABLE(htim);
    589            }
    590            
    591            /* Enable the Peripheral */
    592            __HAL_TIM_ENABLE(htim); 
    593            
    594            /* Return function status */
    595            return HAL_OK;
    596          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \   00000000   0xD103             BNE.N    ??Subroutine0_0
   \   00000002   0x6C41             LDR      R1,[R0, #+68]
   \   00000004   0xF441 0x4100      ORR      R1,R1,#0x8000
   \   00000008   0x6441             STR      R1,[R0, #+68]
   \                     ??Subroutine0_0: (+1)
   \   0000000A   0x6801             LDR      R1,[R0, #+0]
   \   0000000C   0xF041 0x0101      ORR      R1,R1,#0x1
   \   00000010   0x6001             STR      R1,[R0, #+0]
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine20: (+1)
   \   00000000   0x6820             LDR      R0,[R4, #+0]
   \   00000002   0x.... 0x....      LDR.W    R1,??DataTable18  ;; 0x40010000
   \   00000006   0x4288             CMP      R0,R1
   \   00000008   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine22: (+1)
   \   00000000   0x4604             MOV      R4,R0
   \   00000002   0x2201             MOVS     R2,#+1
   \                     ??Subroutine22_0: (+1)
   \   00000004   0x6820             LDR      R0,[R4, #+0]
   \   00000006   0x.... 0x....      B.W      TIM_CCxChannelCmd
    597          
    598          /**
    599            * @brief  Stops the TIM Output Compare signal generation.
    600            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
    601            *                the configuration information for TIM module.
    602            * @param  Channel: TIM Channel to be disabled.
    603            *          This parameter can be one of the following values:
    604            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
    605            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
    606            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
    607            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
    608            * @retval HAL status
    609            */

   \                                 In section .text, align 2, keep-with-next
    610          HAL_StatusTypeDef HAL_TIM_OC_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
    611          {
   \                     HAL_TIM_OC_Stop: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    612            /* Check the parameters */
    613            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
    614            
    615            /* Disable the Output compare channel */
    616            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
   \   00000004   0x2200             MOVS     R2,#+0
   \   00000006   0x.... 0x....      BL       ??Subroutine22_0
    617            
    618            if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
   \                     ??CrossCallReturnLabel_71: (+1)
   \   0000000A   0x.... 0x....      BL       ?Subroutine18
   \                     ??CrossCallReturnLabel_37: (+1)
   \   0000000E   0xBF1C             ITT      NE 
   \   00000010   0x.... 0x....      LDRNE.W  R3,??DataTable17_2  ;; 0x40010400
   \   00000014   0x4298             CMPNE    R0,R3
   \   00000016   0xD106             BNE.N    ??CrossCallReturnLabel_0
    619            {
    620              /* Disable the Main Output */
    621              __HAL_TIM_MOE_DISABLE(htim);
   \   00000018   0x6A03             LDR      R3,[R0, #+32]
   \   0000001A   0x4213             TST      R3,R2
   \   0000001C   0xBF04             ITT      EQ 
   \   0000001E   0x6A03             LDREQ    R3,[R0, #+32]
   \   00000020   0x420B             TSTEQ    R3,R1
   \   00000022   0x.... 0x....      BL       ?Subroutine11
    622            }  
    623            
    624            /* Disable the Peripheral */
    625            __HAL_TIM_DISABLE(htim);  
   \                     ??CrossCallReturnLabel_0: (+1)
   \   00000026   0x6A03             LDR      R3,[R0, #+32]
   \   00000028   0x4213             TST      R3,R2
   \   0000002A   0xBF04             ITT      EQ 
   \   0000002C   0x6A02             LDREQ    R2,[R0, #+32]
   \   0000002E   0x420A             TSTEQ    R2,R1
   \   00000030   0x....             B.N      ?Subroutine2
    626            
    627            /* Return function status */
    628            return HAL_OK;
    629          }  

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine2: (+1)
   \   00000000   0xD103             BNE.N    ??Subroutine2_0
   \   00000002   0x6801             LDR      R1,[R0, #+0]
   \   00000004   0x0849             LSRS     R1,R1,#+1
   \   00000006   0x0049             LSLS     R1,R1,#+1
   \   00000008   0x6001             STR      R1,[R0, #+0]
   \                     ??Subroutine2_0: (+1)
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine18: (+1)
   \   00000000   0x6820             LDR      R0,[R4, #+0]
   \   00000002   0x.... 0x....      LDR.W    R3,??DataTable18  ;; 0x40010000
   \   00000006   0xF240 0x4144      MOVW     R1,#+1092
   \   0000000A   0xF241 0x1211      MOVW     R2,#+4369
   \   0000000E   0x4298             CMP      R0,R3
   \   00000010   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine11: (+1)
   \   00000000   0xD103             BNE.N    ??Subroutine11_0
   \   00000002   0x6C43             LDR      R3,[R0, #+68]
   \   00000004   0xF423 0x4300      BIC      R3,R3,#0x8000
   \   00000008   0x6443             STR      R3,[R0, #+68]
   \                     ??Subroutine11_0: (+1)
   \   0000000A   0x4770             BX       LR
    630          
    631          /**
    632            * @brief  Starts the TIM Output Compare signal generation in interrupt mode.
    633            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
    634            *                the configuration information for TIM module.
    635            * @param  Channel: TIM Channel to be enabled.
    636            *          This parameter can be one of the following values:
    637            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
    638            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
    639            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
    640            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
    641            * @retval HAL status
    642            */

   \                                 In section .text, align 2, keep-with-next
    643          HAL_StatusTypeDef HAL_TIM_OC_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
    644          {
   \                     HAL_TIM_OC_Start_IT: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    645            /* Check the parameters */
    646            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
    647            
    648            switch (Channel)
   \   00000004   0x0008             MOVS     R0,R1
   \   00000006   0xD006             BEQ.N    ??HAL_TIM_OC_Start_IT_0
   \   00000008   0x2904             CMP      R1,#+4
   \   0000000A   0xD007             BEQ.N    ??HAL_TIM_OC_Start_IT_1
   \   0000000C   0x2908             CMP      R1,#+8
   \   0000000E   0xD008             BEQ.N    ??HAL_TIM_OC_Start_IT_2
   \   00000010   0x290C             CMP      R1,#+12
   \   00000012   0xD009             BEQ.N    ??HAL_TIM_OC_Start_IT_3
   \   00000014   0xE00B             B.N      ??HAL_TIM_OC_Start_IT_4
    649            {
    650              case TIM_CHANNEL_1:
    651              {       
    652                /* Enable the TIM Capture/Compare 1 interrupt */
    653                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
   \                     ??HAL_TIM_OC_Start_IT_0: (+1)
   \   00000016   0x.... 0x....      BL       ?Subroutine40
    654              }
   \                     ??CrossCallReturnLabel_130: (+1)
   \   0000001A   0xE007             B.N      ??CrossCallReturnLabel_139
    655              break;
    656              
    657              case TIM_CHANNEL_2:
    658              {
    659                /* Enable the TIM Capture/Compare 2 interrupt */
    660                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
   \                     ??HAL_TIM_OC_Start_IT_1: (+1)
   \   0000001C   0x.... 0x....      BL       ?Subroutine41
    661              }
   \                     ??CrossCallReturnLabel_133: (+1)
   \   00000020   0xE004             B.N      ??CrossCallReturnLabel_139
    662              break;
    663              
    664              case TIM_CHANNEL_3:
    665              {
    666                /* Enable the TIM Capture/Compare 3 interrupt */
    667                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);
   \                     ??HAL_TIM_OC_Start_IT_2: (+1)
   \   00000022   0x.... 0x....      BL       ?Subroutine42
    668              }
   \                     ??CrossCallReturnLabel_136: (+1)
   \   00000026   0xE001             B.N      ??CrossCallReturnLabel_139
    669              break;
    670              
    671              case TIM_CHANNEL_4:
    672              {
    673                /* Enable the TIM Capture/Compare 4 interrupt */
    674                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC4);
   \                     ??HAL_TIM_OC_Start_IT_3: (+1)
   \   00000028   0x.... 0x....      BL       ?Subroutine43
    675              }
   \                     ??CrossCallReturnLabel_139: (+1)
   \   0000002C   0x60C2             STR      R2,[R0, #+12]
    676              break;
    677              
    678              default:
    679              break;
    680            } 
    681          
    682            /* Enable the Output compare channel */
    683            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
   \                     ??HAL_TIM_OC_Start_IT_4: (+1)
   \   0000002E   0x.... 0x....      BL       ?Subroutine24
    684            
    685            if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
   \                     ??CrossCallReturnLabel_83: (+1)
   \   00000032   0x.... 0x....      BL       ?Subroutine20
   \                     ??CrossCallReturnLabel_52: (+1)
   \   00000036   0xBF1C             ITT      NE 
   \   00000038   0x.... 0x....      LDRNE.W  R1,??DataTable17_2  ;; 0x40010400
   \   0000003C   0x4288             CMPNE    R0,R1
   \   0000003E                      REQUIRE ?Subroutine0
   \   0000003E                      ;; // Fall through to label ?Subroutine0
    686            {
    687              /* Enable the main output */
    688              __HAL_TIM_MOE_ENABLE(htim);
    689            }
    690          
    691            /* Enable the Peripheral */
    692            __HAL_TIM_ENABLE(htim);
    693            
    694            /* Return function status */
    695            return HAL_OK;
    696          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine43: (+1)
   \   00000000   0x6820             LDR      R0,[R4, #+0]
   \   00000002   0x68C2             LDR      R2,[R0, #+12]
   \   00000004   0xF042 0x0210      ORR      R2,R2,#0x10
   \   00000008   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine42: (+1)
   \   00000000   0x6820             LDR      R0,[R4, #+0]
   \   00000002   0x68C2             LDR      R2,[R0, #+12]
   \   00000004   0xF042 0x0208      ORR      R2,R2,#0x8
   \   00000008   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine41: (+1)
   \   00000000   0x6820             LDR      R0,[R4, #+0]
   \   00000002   0x68C2             LDR      R2,[R0, #+12]
   \   00000004   0xF042 0x0204      ORR      R2,R2,#0x4
   \   00000008   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine40: (+1)
   \   00000000   0x6820             LDR      R0,[R4, #+0]
   \   00000002   0x68C2             LDR      R2,[R0, #+12]
   \   00000004   0xF042 0x0202      ORR      R2,R2,#0x2
   \   00000008   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine24: (+1)
   \   00000000   0x6820             LDR      R0,[R4, #+0]
   \   00000002   0x2201             MOVS     R2,#+1
   \   00000004   0x.... 0x....      B.W      TIM_CCxChannelCmd
    697          
    698          /**
    699            * @brief  Stops the TIM Output Compare signal generation in interrupt mode.
    700            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
    701            *                the configuration information for TIM module.
    702            * @param  Channel: TIM Channel to be disabled.
    703            *          This parameter can be one of the following values:
    704            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
    705            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
    706            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
    707            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
    708            * @retval HAL status
    709            */

   \                                 In section .text, align 2, keep-with-next
    710          HAL_StatusTypeDef HAL_TIM_OC_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
    711          {
   \                     HAL_TIM_OC_Stop_IT: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    712            /* Check the parameters */
    713            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
    714            
    715            switch (Channel)
   \   00000004   0x0008             MOVS     R0,R1
   \   00000006   0xD006             BEQ.N    ??HAL_TIM_OC_Stop_IT_0
   \   00000008   0x2904             CMP      R1,#+4
   \   0000000A   0xD007             BEQ.N    ??HAL_TIM_OC_Stop_IT_1
   \   0000000C   0x2908             CMP      R1,#+8
   \   0000000E   0xD008             BEQ.N    ??HAL_TIM_OC_Stop_IT_2
   \   00000010   0x290C             CMP      R1,#+12
   \   00000012   0xD009             BEQ.N    ??HAL_TIM_OC_Stop_IT_3
   \   00000014   0xE00B             B.N      ??HAL_TIM_OC_Stop_IT_4
    716            {
    717              case TIM_CHANNEL_1:
    718              {       
    719                /* Disable the TIM Capture/Compare 1 interrupt */
    720                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
   \                     ??HAL_TIM_OC_Stop_IT_0: (+1)
   \   00000016   0x.... 0x....      BL       ?Subroutine44
    721              }
   \                     ??CrossCallReturnLabel_142: (+1)
   \   0000001A   0xE007             B.N      ??CrossCallReturnLabel_151
    722              break;
    723              
    724              case TIM_CHANNEL_2:
    725              {
    726                /* Disable the TIM Capture/Compare 2 interrupt */
    727                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
   \                     ??HAL_TIM_OC_Stop_IT_1: (+1)
   \   0000001C   0x.... 0x....      BL       ?Subroutine45
    728              }
   \                     ??CrossCallReturnLabel_145: (+1)
   \   00000020   0xE004             B.N      ??CrossCallReturnLabel_151
    729              break;
    730              
    731              case TIM_CHANNEL_3:
    732              {
    733                /* Disable the TIM Capture/Compare 3 interrupt */
    734                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);
   \                     ??HAL_TIM_OC_Stop_IT_2: (+1)
   \   00000022   0x.... 0x....      BL       ?Subroutine46
    735              }
   \                     ??CrossCallReturnLabel_148: (+1)
   \   00000026   0xE001             B.N      ??CrossCallReturnLabel_151
    736              break;
    737              
    738              case TIM_CHANNEL_4:
    739              {
    740                /* Disable the TIM Capture/Compare 4 interrupt */
    741                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC4);
   \                     ??HAL_TIM_OC_Stop_IT_3: (+1)
   \   00000028   0x.... 0x....      BL       ?Subroutine47
    742              }
   \                     ??CrossCallReturnLabel_151: (+1)
   \   0000002C   0x60C2             STR      R2,[R0, #+12]
    743              break;
    744              
    745              default:
    746              break; 
    747            } 
    748            
    749            /* Disable the Output compare channel */
    750            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE); 
   \                     ??HAL_TIM_OC_Stop_IT_4: (+1)
   \   0000002E   0x.... 0x....      BL       ?Subroutine21
    751            
    752            if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
   \                     ??CrossCallReturnLabel_64: (+1)
   \   00000032   0x.... 0x....      BL       ?Subroutine18
   \                     ??CrossCallReturnLabel_38: (+1)
   \   00000036   0xBF1C             ITT      NE 
   \   00000038   0x.... 0x....      LDRNE.W  R3,??DataTable17_2  ;; 0x40010400
   \   0000003C   0x4298             CMPNE    R0,R3
   \   0000003E   0xD106             BNE.N    ??CrossCallReturnLabel_1
    753            {
    754              /* Disable the Main Output */
    755              __HAL_TIM_MOE_DISABLE(htim);
   \   00000040   0x6A03             LDR      R3,[R0, #+32]
   \   00000042   0x4213             TST      R3,R2
   \   00000044   0xBF04             ITT      EQ 
   \   00000046   0x6A03             LDREQ    R3,[R0, #+32]
   \   00000048   0x420B             TSTEQ    R3,R1
   \   0000004A   0x.... 0x....      BL       ?Subroutine11
    756            }
    757            
    758            /* Disable the Peripheral */
    759            __HAL_TIM_DISABLE(htim);  
   \                     ??CrossCallReturnLabel_1: (+1)
   \   0000004E   0x6A03             LDR      R3,[R0, #+32]
   \   00000050   0x4213             TST      R3,R2
   \   00000052   0xBF04             ITT      EQ 
   \   00000054   0x6A02             LDREQ    R2,[R0, #+32]
   \   00000056   0x420A             TSTEQ    R2,R1
   \   00000058                      REQUIRE ?Subroutine2
   \   00000058                      ;; // Fall through to label ?Subroutine2
    760            
    761            /* Return function status */
    762            return HAL_OK;
    763          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine47: (+1)
   \   00000000   0x6820             LDR      R0,[R4, #+0]
   \   00000002   0x68C2             LDR      R2,[R0, #+12]
   \   00000004   0xF022 0x0210      BIC      R2,R2,#0x10
   \   00000008   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine46: (+1)
   \   00000000   0x6820             LDR      R0,[R4, #+0]
   \   00000002   0x68C2             LDR      R2,[R0, #+12]
   \   00000004   0xF022 0x0208      BIC      R2,R2,#0x8
   \   00000008   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine45: (+1)
   \   00000000   0x6820             LDR      R0,[R4, #+0]
   \   00000002   0x68C2             LDR      R2,[R0, #+12]
   \   00000004   0xF022 0x0204      BIC      R2,R2,#0x4
   \   00000008   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine44: (+1)
   \   00000000   0x6820             LDR      R0,[R4, #+0]
   \   00000002   0x68C2             LDR      R2,[R0, #+12]
   \   00000004   0xF022 0x0202      BIC      R2,R2,#0x2
   \   00000008   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine21: (+1)
   \   00000000   0x6820             LDR      R0,[R4, #+0]
   \   00000002   0x2200             MOVS     R2,#+0
   \   00000004   0x.... 0x....      B.W      TIM_CCxChannelCmd
    764          
    765          /**
    766            * @brief  Starts the TIM Output Compare signal generation in DMA mode.
    767            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
    768            *                the configuration information for TIM module.
    769            * @param  Channel: TIM Channel to be enabled.
    770            *          This parameter can be one of the following values:
    771            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
    772            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
    773            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
    774            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
    775            * @param  pData: The source Buffer address.
    776            * @param  Length: The length of data to be transferred from memory to TIM peripheral
    777            * @retval HAL status
    778            */

   \                                 In section .text, align 2, keep-with-next
    779          HAL_StatusTypeDef HAL_TIM_OC_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData, uint16_t Length)
    780          {
   \                     HAL_TIM_OC_Start_DMA: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x.... 0x....      BL       ?Subroutine15
    781            /* Check the parameters */
    782            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
    783            
    784            if((htim->State == HAL_TIM_STATE_BUSY))
   \                     ??CrossCallReturnLabel_19: (+1)
   \   00000006   0xD02F             BEQ.N    ??CrossCallReturnLabel_14
    785            {
    786               return HAL_BUSY;
    787            }
    788            else if((htim->State == HAL_TIM_STATE_READY))
   \   00000008   0x.... 0x....      BL       ??Subroutine16_0
   \                     ??CrossCallReturnLabel_28: (+1)
   \   0000000C   0xD104             BNE.N    ??CrossCallReturnLabel_32
    789            {
    790              if(((uint32_t)pData == 0 ) && (Length > 0)) 
   \   0000000E   0xB909             CBNZ.N   R1,??HAL_TIM_OC_Start_DMA_0
   \   00000010   0x2B00             CMP      R3,#+0
   \   00000012   0xD129             BNE.N    ??CrossCallReturnLabel_14
    791              {
    792                return HAL_ERROR;                                    
    793              }
    794              else
    795              {
    796                htim->State = HAL_TIM_STATE_BUSY;
   \                     ??HAL_TIM_OC_Start_DMA_0: (+1)
   \   00000014   0x.... 0x....      BL       ?Subroutine17
    797              }
    798            }    
    799            switch (Channel)
   \                     ??CrossCallReturnLabel_32: (+1)
   \   00000018   0x.... 0x....      BL       ?Subroutine62
   \                     ??CrossCallReturnLabel_197: (+1)
   \   0000001C   0xD006             BEQ.N    ??HAL_TIM_OC_Start_DMA_1
   \   0000001E   0x2D04             CMP      R5,#+4
   \   00000020   0xD009             BEQ.N    ??HAL_TIM_OC_Start_DMA_2
   \   00000022   0x2D08             CMP      R5,#+8
   \   00000024   0xD00C             BEQ.N    ??HAL_TIM_OC_Start_DMA_3
   \   00000026   0x2D0C             CMP      R5,#+12
   \   00000028   0xD00F             BEQ.N    ??HAL_TIM_OC_Start_DMA_4
   \   0000002A   0xE013             B.N      ??HAL_TIM_OC_Start_DMA_5
    800            {
    801              case TIM_CHANNEL_1:
    802              {      
    803                /* Set the DMA Period elapsed callback */
    804                htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = HAL_TIM_DMADelayPulseCplt;
   \                     ??HAL_TIM_OC_Start_DMA_1: (+1)
   \   0000002C   0x.... 0x....      BL       ?Subroutine31
    805               
    806                /* Set the DMA error callback */
    807                htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = HAL_TIM_DMAError ;
    808                
    809                /* Enable the DMA Stream */
    810                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)pData, (uint32_t)&htim->Instance->CCR1, Length);
    811                
    812                /* Enable the TIM Capture/Compare 1 DMA request */
    813                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
   \                     ??CrossCallReturnLabel_109: (+1)
   \   00000030   0x.... 0x....      BL       ?Subroutine35
    814              }
   \                     ??CrossCallReturnLabel_116: (+1)
   \   00000034   0xE00D             B.N      ??CrossCallReturnLabel_125
    815              break;
    816              
    817              case TIM_CHANNEL_2:
    818              {
    819                /* Set the DMA Period elapsed callback */
    820                htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = HAL_TIM_DMADelayPulseCplt;
   \                     ??HAL_TIM_OC_Start_DMA_2: (+1)
   \   00000036   0x.... 0x....      BL       ?Subroutine32
    821               
    822                /* Set the DMA error callback */
    823                htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = HAL_TIM_DMAError ;
    824                
    825                /* Enable the DMA Stream */
    826                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)pData, (uint32_t)&htim->Instance->CCR2, Length);
    827                
    828                /* Enable the TIM Capture/Compare 2 DMA request */
    829                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
   \                     ??CrossCallReturnLabel_111: (+1)
   \   0000003A   0x.... 0x....      BL       ?Subroutine36
    830              }
   \                     ??CrossCallReturnLabel_119: (+1)
   \   0000003E   0xE008             B.N      ??CrossCallReturnLabel_125
    831              break;
    832              
    833              case TIM_CHANNEL_3:
    834              {
    835                /* Set the DMA Period elapsed callback */
    836                htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = HAL_TIM_DMADelayPulseCplt;
   \                     ??HAL_TIM_OC_Start_DMA_3: (+1)
   \   00000040   0x.... 0x....      BL       ?Subroutine33
    837               
    838                /* Set the DMA error callback */
    839                htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = HAL_TIM_DMAError ;
    840                
    841                /* Enable the DMA Stream */
    842                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)pData, (uint32_t)&htim->Instance->CCR3,Length);
    843                
    844                /* Enable the TIM Capture/Compare 3 DMA request */
    845                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);
   \                     ??CrossCallReturnLabel_113: (+1)
   \   00000044   0x.... 0x....      BL       ?Subroutine37
    846              }
   \                     ??CrossCallReturnLabel_122: (+1)
   \   00000048   0xE003             B.N      ??CrossCallReturnLabel_125
    847              break;
    848              
    849              case TIM_CHANNEL_4:
    850              {
    851               /* Set the DMA Period elapsed callback */
    852                htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = HAL_TIM_DMADelayPulseCplt;
   \                     ??HAL_TIM_OC_Start_DMA_4: (+1)
   \   0000004A   0x.... 0x....      BL       ?Subroutine34
    853               
    854                /* Set the DMA error callback */
    855                htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = HAL_TIM_DMAError ;
    856                
    857                /* Enable the DMA Stream */
    858                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)pData, (uint32_t)&htim->Instance->CCR4, Length);
    859                
    860                /* Enable the TIM Capture/Compare 4 DMA request */
    861                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC4);
   \                     ??CrossCallReturnLabel_115: (+1)
   \   0000004E   0x.... 0x....      BL       ?Subroutine38
    862              }
   \                     ??CrossCallReturnLabel_125: (+1)
   \   00000052   0x60C1             STR      R1,[R0, #+12]
    863              break;
    864              
    865              default:
    866              break;
    867            }
    868          
    869            /* Enable the Output compare channel */
    870            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
   \                     ??HAL_TIM_OC_Start_DMA_5: (+1)
   \   00000054   0x.... 0x....      BL       ?Subroutine25
    871            
    872            if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
   \                     ??CrossCallReturnLabel_86: (+1)
   \   00000058   0x.... 0x....      BL       ?Subroutine20
   \                     ??CrossCallReturnLabel_53: (+1)
   \   0000005C   0xBF1C             ITT      NE 
   \   0000005E   0x.... 0x....      LDRNE.W  R1,??DataTable17_2  ;; 0x40010400
   \   00000062   0x4288             CMPNE    R0,R1
   \   00000064   0x.... 0x....      BL       ?Subroutine13
    873            {
    874              /* Enable the main output */
    875              __HAL_TIM_MOE_ENABLE(htim);
    876            }  
    877            
    878            /* Enable the Peripheral */
    879            __HAL_TIM_ENABLE(htim); 
    880            
    881            /* Return function status */
    882            return HAL_OK;
   \                     ??CrossCallReturnLabel_14: (+1)
   \   00000068   0xBD70             POP      {R4-R6,PC}       ;; return
    883          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine62: (+1)
   \   00000000   0x002E             MOVS     R6,R5
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable17_1
   \   00000006   0x.... 0x....      LDR.W    R2,??DataTable19
   \   0000000A   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine38: (+1)
   \   00000000   0x6820             LDR      R0,[R4, #+0]
   \   00000002   0x68C1             LDR      R1,[R0, #+12]
   \   00000004   0xF441 0x5180      ORR      R1,R1,#0x1000
   \   00000008   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine37: (+1)
   \   00000000   0x6820             LDR      R0,[R4, #+0]
   \   00000002   0x68C1             LDR      R1,[R0, #+12]
   \   00000004   0xF441 0x6100      ORR      R1,R1,#0x800
   \   00000008   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine36: (+1)
   \   00000000   0x6820             LDR      R0,[R4, #+0]
   \   00000002   0x68C1             LDR      R1,[R0, #+12]
   \   00000004   0xF441 0x6180      ORR      R1,R1,#0x400
   \   00000008   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine35: (+1)
   \   00000000   0x6820             LDR      R0,[R4, #+0]
   \   00000002   0x68C1             LDR      R1,[R0, #+12]
   \   00000004   0xF441 0x7100      ORR      R1,R1,#0x200
   \   00000008   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine34: (+1)
   \   00000000   0x6AE6             LDR      R6,[R4, #+44]
   \   00000002   0x63F2             STR      R2,[R6, #+60]
   \   00000004   0x6AE2             LDR      R2,[R4, #+44]
   \   00000006   0x6490             STR      R0,[R2, #+72]
   \   00000008   0x6820             LDR      R0,[R4, #+0]
   \   0000000A   0xF100 0x0240      ADD      R2,R0,#+64
   \   0000000E   0x6AE0             LDR      R0,[R4, #+44]
   \   00000010   0x.... 0x....      B.W      HAL_DMA_Start_IT

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine33: (+1)
   \   00000000   0x6AA6             LDR      R6,[R4, #+40]
   \   00000002   0x63F2             STR      R2,[R6, #+60]
   \   00000004   0x6AA2             LDR      R2,[R4, #+40]
   \   00000006   0x6490             STR      R0,[R2, #+72]
   \   00000008   0x6820             LDR      R0,[R4, #+0]
   \   0000000A   0xF100 0x023C      ADD      R2,R0,#+60
   \   0000000E   0x6AA0             LDR      R0,[R4, #+40]
   \   00000010   0x.... 0x....      B.W      HAL_DMA_Start_IT

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine32: (+1)
   \   00000000   0x6A66             LDR      R6,[R4, #+36]
   \   00000002   0x63F2             STR      R2,[R6, #+60]
   \   00000004   0x6A62             LDR      R2,[R4, #+36]
   \   00000006   0x6490             STR      R0,[R2, #+72]
   \   00000008   0x6820             LDR      R0,[R4, #+0]
   \   0000000A   0xF100 0x0238      ADD      R2,R0,#+56
   \   0000000E   0x6A60             LDR      R0,[R4, #+36]
   \   00000010   0x.... 0x....      B.W      HAL_DMA_Start_IT

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine31: (+1)
   \   00000000   0x6A26             LDR      R6,[R4, #+32]
   \   00000002   0x63F2             STR      R2,[R6, #+60]
   \   00000004   0x6A22             LDR      R2,[R4, #+32]
   \   00000006   0x6490             STR      R0,[R2, #+72]
   \   00000008   0x6820             LDR      R0,[R4, #+0]
   \   0000000A   0xF100 0x0234      ADD      R2,R0,#+52
   \   0000000E   0x6A20             LDR      R0,[R4, #+32]
   \   00000010   0x.... 0x....      B.W      HAL_DMA_Start_IT

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine25: (+1)
   \   00000000   0x6820             LDR      R0,[R4, #+0]
   \   00000002   0x2201             MOVS     R2,#+1
   \   00000004   0x4629             MOV      R1,R5
   \   00000006   0x.... 0x....      B.W      TIM_CCxChannelCmd

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine13: (+1)
   \   00000000   0xD103             BNE.N    ??Subroutine13_0
   \   00000002   0x6C41             LDR      R1,[R0, #+68]
   \   00000004   0xF441 0x4100      ORR      R1,R1,#0x8000
   \   00000008   0x6441             STR      R1,[R0, #+68]
   \                     ??Subroutine13_0: (+1)
   \   0000000A   0x6820             LDR      R0,[R4, #+0]
   \   0000000C   0x6801             LDR      R1,[R0, #+0]
   \   0000000E   0xF041 0x0101      ORR      R1,R1,#0x1
   \   00000012   0x6001             STR      R1,[R0, #+0]
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0x4770             BX       LR
    884          
    885          /**
    886            * @brief  Stops the TIM Output Compare signal generation in DMA mode.
    887            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
    888            *                the configuration information for TIM module.
    889            * @param  Channel: TIM Channel to be disabled.
    890            *          This parameter can be one of the following values:
    891            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
    892            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
    893            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
    894            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
    895            * @retval HAL status
    896            */

   \                                 In section .text, align 2, keep-with-next
    897          HAL_StatusTypeDef HAL_TIM_OC_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
    898          {
   \                     HAL_TIM_OC_Stop_DMA: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    899            /* Check the parameters */
    900            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
    901            
    902            switch (Channel)
   \   00000004   0x0008             MOVS     R0,R1
   \   00000006   0xD006             BEQ.N    ??HAL_TIM_OC_Stop_DMA_0
   \   00000008   0x2904             CMP      R1,#+4
   \   0000000A   0xD007             BEQ.N    ??HAL_TIM_OC_Stop_DMA_1
   \   0000000C   0x2908             CMP      R1,#+8
   \   0000000E   0xD008             BEQ.N    ??HAL_TIM_OC_Stop_DMA_2
   \   00000010   0x290C             CMP      R1,#+12
   \   00000012   0xD009             BEQ.N    ??HAL_TIM_OC_Stop_DMA_3
   \   00000014   0xE00B             B.N      ??HAL_TIM_OC_Stop_DMA_4
    903            {
    904              case TIM_CHANNEL_1:
    905              {       
    906                /* Disable the TIM Capture/Compare 1 DMA request */
    907                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
   \                     ??HAL_TIM_OC_Stop_DMA_0: (+1)
   \   00000016   0x.... 0x....      BL       ?Subroutine48
    908              }
   \                     ??CrossCallReturnLabel_154: (+1)
   \   0000001A   0xE007             B.N      ??CrossCallReturnLabel_163
    909              break;
    910              
    911              case TIM_CHANNEL_2:
    912              {
    913                /* Disable the TIM Capture/Compare 2 DMA request */
    914                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
   \                     ??HAL_TIM_OC_Stop_DMA_1: (+1)
   \   0000001C   0x.... 0x....      BL       ?Subroutine49
    915              }
   \                     ??CrossCallReturnLabel_157: (+1)
   \   00000020   0xE004             B.N      ??CrossCallReturnLabel_163
    916              break;
    917              
    918              case TIM_CHANNEL_3:
    919              {
    920                /* Disable the TIM Capture/Compare 3 DMA request */
    921                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);
   \                     ??HAL_TIM_OC_Stop_DMA_2: (+1)
   \   00000022   0x.... 0x....      BL       ?Subroutine50
    922              }
   \                     ??CrossCallReturnLabel_160: (+1)
   \   00000026   0xE001             B.N      ??CrossCallReturnLabel_163
    923              break;
    924              
    925              case TIM_CHANNEL_4:
    926              {
    927                /* Disable the TIM Capture/Compare 4 interrupt */
    928                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC4);
   \                     ??HAL_TIM_OC_Stop_DMA_3: (+1)
   \   00000028   0x.... 0x....      BL       ?Subroutine51
    929              }
   \                     ??CrossCallReturnLabel_163: (+1)
   \   0000002C   0x60C2             STR      R2,[R0, #+12]
    930              break;
    931              
    932              default:
    933              break;
    934            } 
    935            
    936            /* Disable the Output compare channel */
    937            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
   \                     ??HAL_TIM_OC_Stop_DMA_4: (+1)
   \   0000002E   0x.... 0x....      BL       ?Subroutine21
    938            
    939            if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
   \                     ??CrossCallReturnLabel_63: (+1)
   \   00000032   0x.... 0x....      BL       ?Subroutine18
   \                     ??CrossCallReturnLabel_39: (+1)
   \   00000036   0xBF1C             ITT      NE 
   \   00000038   0x.... 0x....      LDRNE.W  R3,??DataTable17_2  ;; 0x40010400
   \   0000003C   0x4298             CMPNE    R0,R3
   \   0000003E   0xD106             BNE.N    ??CrossCallReturnLabel_2
    940            {
    941              /* Disable the Main Output */
    942              __HAL_TIM_MOE_DISABLE(htim);
   \   00000040   0x6A03             LDR      R3,[R0, #+32]
   \   00000042   0x4213             TST      R3,R2
   \   00000044   0xBF04             ITT      EQ 
   \   00000046   0x6A03             LDREQ    R3,[R0, #+32]
   \   00000048   0x420B             TSTEQ    R3,R1
   \   0000004A   0x.... 0x....      BL       ?Subroutine11
    943            }
    944            
    945            /* Disable the Peripheral */
    946            __HAL_TIM_DISABLE(htim);
   \                     ??CrossCallReturnLabel_2: (+1)
   \   0000004E   0x6820             LDR      R0,[R4, #+0]
   \   00000050   0x6A03             LDR      R3,[R0, #+32]
   \   00000052   0x4213             TST      R3,R2
   \   00000054   0xBF04             ITT      EQ 
   \   00000056   0x6A02             LDREQ    R2,[R0, #+32]
   \   00000058   0x420A             TSTEQ    R2,R1
   \   0000005A   0x....             B.N      ?Subroutine1
    947            
    948            /* Change the htim state */
    949            htim->State = HAL_TIM_STATE_READY;
    950            
    951            /* Return function status */
    952            return HAL_OK;
    953          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine51: (+1)
   \   00000000   0x6820             LDR      R0,[R4, #+0]
   \   00000002   0x68C2             LDR      R2,[R0, #+12]
   \   00000004   0xF422 0x5280      BIC      R2,R2,#0x1000
   \   00000008   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine50: (+1)
   \   00000000   0x6820             LDR      R0,[R4, #+0]
   \   00000002   0x68C2             LDR      R2,[R0, #+12]
   \   00000004   0xF422 0x6200      BIC      R2,R2,#0x800
   \   00000008   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine49: (+1)
   \   00000000   0x6820             LDR      R0,[R4, #+0]
   \   00000002   0x68C2             LDR      R2,[R0, #+12]
   \   00000004   0xF422 0x6280      BIC      R2,R2,#0x400
   \   00000008   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine48: (+1)
   \   00000000   0x6820             LDR      R0,[R4, #+0]
   \   00000002   0x68C2             LDR      R2,[R0, #+12]
   \   00000004   0xF422 0x7200      BIC      R2,R2,#0x200
   \   00000008   0x4770             BX       LR
    954          
    955          /**
    956            * @}
    957            */
    958          
    959          /** @defgroup TIM_Exported_Functions_Group3 Time PWM functions 
    960           *  @brief    Time PWM functions 
    961           *
    962          @verbatim    
    963            ==============================================================================
    964                                    ##### Time PWM functions #####
    965            ==============================================================================
    966            [..]  
    967              This section provides functions allowing to:
    968              (+) Initialize and configure the TIM OPWM. 
    969              (+) De-initialize the TIM PWM.
    970              (+) Start the Time PWM.
    971              (+) Stop the Time PWM.
    972              (+) Start the Time PWM and enable interrupt.
    973              (+) Stop the Time PWM and disable interrupt.
    974              (+) Start the Time PWM and enable DMA transfer.
    975              (+) Stop the Time PWM and disable DMA transfer.
    976           
    977          @endverbatim
    978            * @{
    979            */
    980          /**
    981            * @brief  Initializes the TIM PWM Time Base according to the specified
    982            *         parameters in the TIM_HandleTypeDef and create the associated handle.
    983            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
    984            *                the configuration information for TIM module.
    985            * @retval HAL status
    986            */

   \                                 In section .text, align 2, keep-with-next
    987          HAL_StatusTypeDef HAL_TIM_PWM_Init(TIM_HandleTypeDef *htim)
    988          {
   \                     HAL_TIM_PWM_Init: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    989            /* Check the TIM handle allocation */
    990            if(htim == NULL)
   \   00000004   0xD101             BNE.N    ??HAL_TIM_PWM_Init_0
    991            {
    992              return HAL_ERROR;
   \   00000006   0x2001             MOVS     R0,#+1
   \   00000008   0xBD32             POP      {R1,R4,R5,PC}
    993            }
    994          
    995            /* Check the parameters */
    996            assert_param(IS_TIM_INSTANCE(htim->Instance));
    997            assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
    998            assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
    999          
   1000            if(htim->State == HAL_TIM_STATE_RESET)
   \                     ??HAL_TIM_PWM_Init_0: (+1)
   \   0000000A   0xF104 0x0538      ADD      R5,R4,#+56
   \   0000000E   0x7868             LDRB     R0,[R5, #+1]
   \   00000010   0xB918             CBNZ.N   R0,??HAL_TIM_PWM_Init_1
   1001            {
   1002              /* Allocate lock resource and initialize it */
   1003              htim->Lock = HAL_UNLOCKED;  
   \   00000012   0x7028             STRB     R0,[R5, #+0]
   1004              /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
   1005              HAL_TIM_PWM_MspInit(htim);
   \   00000014   0x4620             MOV      R0,R4
   \   00000016   0x.... 0x....      BL       HAL_TIM_PWM_MspInit
   1006            }
   1007          
   1008            /* Set the TIM state */
   1009            htim->State= HAL_TIM_STATE_BUSY;  
   \                     ??HAL_TIM_PWM_Init_1: (+1)
   \   0000001A                      REQUIRE ?Subroutine9
   \   0000001A                      ;; // Fall through to label ?Subroutine9
   1010            
   1011            /* Init the base time for the PWM */  
   1012            TIM_Base_SetConfig(htim->Instance, &htim->Init); 
   1013             
   1014            /* Initialize the TIM state*/
   1015            htim->State= HAL_TIM_STATE_READY;
   1016            
   1017            return HAL_OK;
   1018          }  
   1019          
   1020          /**
   1021            * @brief  DeInitializes the TIM peripheral 
   1022            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   1023            *                the configuration information for TIM module.
   1024            * @retval HAL status
   1025            */

   \                                 In section .text, align 2, keep-with-next
   1026          HAL_StatusTypeDef HAL_TIM_PWM_DeInit(TIM_HandleTypeDef *htim)
   1027          {
   \                     HAL_TIM_PWM_DeInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   1028            /* Check the parameters */
   1029            assert_param(IS_TIM_INSTANCE(htim->Instance));
   1030            
   1031            htim->State = HAL_TIM_STATE_BUSY;
   \   00000002   0x.... 0x....      BL       ?Subroutine55
   1032            
   1033            /* Disable the TIM Peripheral Clock */
   1034            __HAL_TIM_DISABLE(htim);
   \                     ??CrossCallReturnLabel_174: (+1)
   \   00000006   0xBF02             ITTT     EQ 
   \   00000008   0x6A0A             LDREQ    R2,[R1, #+32]
   \   0000000A   0xF240 0x4344      MOVWEQ   R3,#+1092
   \   0000000E   0x421A             TSTEQ    R2,R3
   \   00000010   0x.... 0x....      BL       ?Subroutine12
   1035              
   1036            /* DeInit the low level hardware: GPIO, CLOCK, NVIC and DMA */
   1037            HAL_TIM_PWM_MspDeInit(htim);
   \                     ??CrossCallReturnLabel_10: (+1)
   \   00000014   0x.... 0x....      BL       HAL_TIM_PWM_MspDeInit
   1038              
   1039            /* Change TIM state */  
   1040            htim->State = HAL_TIM_STATE_RESET; 
   \   00000018   0x....             B.N      ?Subroutine4
   1041          
   1042            /* Release Lock */
   1043            __HAL_UNLOCK(htim);
   1044          
   1045            return HAL_OK;
   1046          }
   1047          
   1048          /**
   1049            * @brief  Initializes the TIM PWM MSP.
   1050            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   1051            *                the configuration information for TIM module.
   1052            * @retval None
   1053            */

   \                                 In section .text, align 2, keep-with-next
   1054          __weak void HAL_TIM_PWM_MspInit(TIM_HandleTypeDef *htim)
   1055          {
   1056            /* NOTE : This function Should not be modified, when the callback is needed,
   1057                      the HAL_TIM_PWM_MspInit could be implemented in the user file
   1058             */
   1059          }
   \                     HAL_TIM_PWM_MspInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1060          
   1061          /**
   1062            * @brief  DeInitializes TIM PWM MSP.
   1063            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   1064            *                the configuration information for TIM module.
   1065            * @retval None
   1066            */

   \                                 In section .text, align 2, keep-with-next
   1067          __weak void HAL_TIM_PWM_MspDeInit(TIM_HandleTypeDef *htim)
   1068          {
   1069            /* NOTE : This function Should not be modified, when the callback is needed,
   1070                      the HAL_TIM_PWM_MspDeInit could be implemented in the user file
   1071             */
   1072          }
   \                     HAL_TIM_PWM_MspDeInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1073          
   1074          /**
   1075            * @brief  Starts the PWM signal generation.
   1076            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   1077            *                the configuration information for TIM module.
   1078            * @param  Channel: TIM Channels to be enabled.
   1079            *          This parameter can be one of the following values:
   1080            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1081            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1082            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1083            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1084            * @retval HAL status
   1085            */

   \                                 In section .text, align 2, keep-with-next
   1086          HAL_StatusTypeDef HAL_TIM_PWM_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
   1087          {
   \                     HAL_TIM_PWM_Start: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x.... 0x....      BL       ?Subroutine22
   1088            /* Check the parameters */
   1089            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1090          
   1091            /* Enable the Capture compare channel */
   1092            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
   1093            
   1094            if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
   \                     ??CrossCallReturnLabel_73: (+1)
   \   00000006   0x.... 0x....      BL       ?Subroutine20
   \                     ??CrossCallReturnLabel_54: (+1)
   \   0000000A   0xBF1C             ITT      NE 
   \   0000000C   0x.... 0x....      LDRNE.W  R1,??DataTable17_2  ;; 0x40010400
   \   00000010   0x4288             CMPNE    R0,R1
   \   00000012   0x....             B.N      ?Subroutine0
   1095            {
   1096              /* Enable the main output */
   1097              __HAL_TIM_MOE_ENABLE(htim);
   1098            }
   1099              
   1100            /* Enable the Peripheral */
   1101            __HAL_TIM_ENABLE(htim);
   1102            
   1103            /* Return function status */
   1104            return HAL_OK;
   1105          } 
   1106          
   1107          /**
   1108            * @brief  Stops the PWM signal generation.
   1109            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   1110            *                the configuration information for TIM module.
   1111            * @param  Channel: TIM Channels to be disabled.
   1112            *          This parameter can be one of the following values:
   1113            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1114            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1115            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1116            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1117            * @retval HAL status
   1118            */

   \                                 In section .text, align 2, keep-with-next
   1119          HAL_StatusTypeDef HAL_TIM_PWM_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
   1120          { 
   \                     HAL_TIM_PWM_Stop: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   1121            /* Check the parameters */
   1122            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1123              
   1124            /* Disable the Capture compare channel */
   1125            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
   \   00000004   0x2200             MOVS     R2,#+0
   \   00000006   0x.... 0x....      BL       ??Subroutine22_0
   1126            
   1127            if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
   \                     ??CrossCallReturnLabel_70: (+1)
   \   0000000A   0x.... 0x....      BL       ?Subroutine18
   \                     ??CrossCallReturnLabel_40: (+1)
   \   0000000E   0xBF1C             ITT      NE 
   \   00000010   0x.... 0x....      LDRNE.W  R3,??DataTable17_2  ;; 0x40010400
   \   00000014   0x4298             CMPNE    R0,R3
   \   00000016   0xD106             BNE.N    ??CrossCallReturnLabel_3
   1128            {
   1129              /* Disable the Main Output */
   1130              __HAL_TIM_MOE_DISABLE(htim);
   \   00000018   0x6A03             LDR      R3,[R0, #+32]
   \   0000001A   0x4213             TST      R3,R2
   \   0000001C   0xBF04             ITT      EQ 
   \   0000001E   0x6A03             LDREQ    R3,[R0, #+32]
   \   00000020   0x420B             TSTEQ    R3,R1
   \   00000022   0x.... 0x....      BL       ?Subroutine11
   1131            }
   1132            
   1133            /* Disable the Peripheral */
   1134            __HAL_TIM_DISABLE(htim);
   \                     ??CrossCallReturnLabel_3: (+1)
   \   00000026   0x6820             LDR      R0,[R4, #+0]
   \   00000028   0x6A03             LDR      R3,[R0, #+32]
   \   0000002A   0x4213             TST      R3,R2
   \   0000002C   0xBF04             ITT      EQ 
   \   0000002E   0x6A02             LDREQ    R2,[R0, #+32]
   \   00000030   0x420A             TSTEQ    R2,R1
   \   00000032                      REQUIRE ?Subroutine1
   \   00000032                      ;; // Fall through to label ?Subroutine1
   1135            
   1136            /* Change the htim state */
   1137            htim->State = HAL_TIM_STATE_READY;
   1138            
   1139            /* Return function status */
   1140            return HAL_OK;
   1141          } 
   1142          
   1143          /**
   1144            * @brief  Starts the PWM signal generation in interrupt mode.
   1145            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   1146            *                the configuration information for TIM module.
   1147            * @param  Channel: TIM Channel to be disabled.
   1148            *          This parameter can be one of the following values:
   1149            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1150            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1151            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1152            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1153            * @retval HAL status
   1154            */

   \                                 In section .text, align 2, keep-with-next
   1155          HAL_StatusTypeDef HAL_TIM_PWM_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
   1156          {
   \                     HAL_TIM_PWM_Start_IT: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   1157            /* Check the parameters */
   1158            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1159            
   1160            switch (Channel)
   \   00000004   0x0008             MOVS     R0,R1
   \   00000006   0xD006             BEQ.N    ??HAL_TIM_PWM_Start_IT_0
   \   00000008   0x2904             CMP      R1,#+4
   \   0000000A   0xD007             BEQ.N    ??HAL_TIM_PWM_Start_IT_1
   \   0000000C   0x2908             CMP      R1,#+8
   \   0000000E   0xD008             BEQ.N    ??HAL_TIM_PWM_Start_IT_2
   \   00000010   0x290C             CMP      R1,#+12
   \   00000012   0xD009             BEQ.N    ??HAL_TIM_PWM_Start_IT_3
   \   00000014   0xE00B             B.N      ??HAL_TIM_PWM_Start_IT_4
   1161            {
   1162              case TIM_CHANNEL_1:
   1163              {       
   1164                /* Enable the TIM Capture/Compare 1 interrupt */
   1165                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
   \                     ??HAL_TIM_PWM_Start_IT_0: (+1)
   \   00000016   0x.... 0x....      BL       ?Subroutine40
   1166              }
   \                     ??CrossCallReturnLabel_131: (+1)
   \   0000001A   0xE007             B.N      ??CrossCallReturnLabel_140
   1167              break;
   1168              
   1169              case TIM_CHANNEL_2:
   1170              {
   1171                /* Enable the TIM Capture/Compare 2 interrupt */
   1172                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
   \                     ??HAL_TIM_PWM_Start_IT_1: (+1)
   \   0000001C   0x.... 0x....      BL       ?Subroutine41
   1173              }
   \                     ??CrossCallReturnLabel_134: (+1)
   \   00000020   0xE004             B.N      ??CrossCallReturnLabel_140
   1174              break;
   1175              
   1176              case TIM_CHANNEL_3:
   1177              {
   1178                /* Enable the TIM Capture/Compare 3 interrupt */
   1179                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);
   \                     ??HAL_TIM_PWM_Start_IT_2: (+1)
   \   00000022   0x.... 0x....      BL       ?Subroutine42
   1180              }
   \                     ??CrossCallReturnLabel_137: (+1)
   \   00000026   0xE001             B.N      ??CrossCallReturnLabel_140
   1181              break;
   1182              
   1183              case TIM_CHANNEL_4:
   1184              {
   1185                /* Enable the TIM Capture/Compare 4 interrupt */
   1186                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC4);
   \                     ??HAL_TIM_PWM_Start_IT_3: (+1)
   \   00000028   0x.... 0x....      BL       ?Subroutine43
   1187              }
   \                     ??CrossCallReturnLabel_140: (+1)
   \   0000002C   0x60C2             STR      R2,[R0, #+12]
   1188              break;
   1189              
   1190              default:
   1191              break;
   1192            } 
   1193            
   1194            /* Enable the Capture compare channel */
   1195            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
   \                     ??HAL_TIM_PWM_Start_IT_4: (+1)
   \   0000002E   0x.... 0x....      BL       ?Subroutine24
   1196            
   1197            if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
   \                     ??CrossCallReturnLabel_82: (+1)
   \   00000032   0x.... 0x....      BL       ?Subroutine20
   \                     ??CrossCallReturnLabel_55: (+1)
   \   00000036   0xBF1C             ITT      NE 
   \   00000038   0x.... 0x....      LDRNE.W  R1,??DataTable17_2  ;; 0x40010400
   \   0000003C   0x4288             CMPNE    R0,R1
   \   0000003E   0x....             B.N      ?Subroutine0
   1198            {
   1199              /* Enable the main output */
   1200              __HAL_TIM_MOE_ENABLE(htim);
   1201            }
   1202          
   1203            /* Enable the Peripheral */
   1204            __HAL_TIM_ENABLE(htim);
   1205            
   1206            /* Return function status */
   1207            return HAL_OK;
   1208          } 
   1209          
   1210          /**
   1211            * @brief  Stops the PWM signal generation in interrupt mode.
   1212            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   1213            *                the configuration information for TIM module.
   1214            * @param  Channel: TIM Channels to be disabled.
   1215            *          This parameter can be one of the following values:
   1216            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1217            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1218            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1219            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1220            * @retval HAL status
   1221            */

   \                                 In section .text, align 2, keep-with-next
   1222          HAL_StatusTypeDef HAL_TIM_PWM_Stop_IT (TIM_HandleTypeDef *htim, uint32_t Channel)
   1223          {
   \                     HAL_TIM_PWM_Stop_IT: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   1224            /* Check the parameters */
   1225            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1226            
   1227            switch (Channel)
   \   00000004   0x0008             MOVS     R0,R1
   \   00000006   0xD006             BEQ.N    ??HAL_TIM_PWM_Stop_IT_0
   \   00000008   0x2904             CMP      R1,#+4
   \   0000000A   0xD007             BEQ.N    ??HAL_TIM_PWM_Stop_IT_1
   \   0000000C   0x2908             CMP      R1,#+8
   \   0000000E   0xD008             BEQ.N    ??HAL_TIM_PWM_Stop_IT_2
   \   00000010   0x290C             CMP      R1,#+12
   \   00000012   0xD009             BEQ.N    ??HAL_TIM_PWM_Stop_IT_3
   \   00000014   0xE00B             B.N      ??HAL_TIM_PWM_Stop_IT_4
   1228            {
   1229              case TIM_CHANNEL_1:
   1230              {       
   1231                /* Disable the TIM Capture/Compare 1 interrupt */
   1232                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
   \                     ??HAL_TIM_PWM_Stop_IT_0: (+1)
   \   00000016   0x.... 0x....      BL       ?Subroutine44
   1233              }
   \                     ??CrossCallReturnLabel_143: (+1)
   \   0000001A   0xE007             B.N      ??CrossCallReturnLabel_152
   1234              break;
   1235              
   1236              case TIM_CHANNEL_2:
   1237              {
   1238                /* Disable the TIM Capture/Compare 2 interrupt */
   1239                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
   \                     ??HAL_TIM_PWM_Stop_IT_1: (+1)
   \   0000001C   0x.... 0x....      BL       ?Subroutine45
   1240              }
   \                     ??CrossCallReturnLabel_146: (+1)
   \   00000020   0xE004             B.N      ??CrossCallReturnLabel_152
   1241              break;
   1242              
   1243              case TIM_CHANNEL_3:
   1244              {
   1245                /* Disable the TIM Capture/Compare 3 interrupt */
   1246                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);
   \                     ??HAL_TIM_PWM_Stop_IT_2: (+1)
   \   00000022   0x.... 0x....      BL       ?Subroutine46
   1247              }
   \                     ??CrossCallReturnLabel_149: (+1)
   \   00000026   0xE001             B.N      ??CrossCallReturnLabel_152
   1248              break;
   1249              
   1250              case TIM_CHANNEL_4:
   1251              {
   1252                /* Disable the TIM Capture/Compare 4 interrupt */
   1253                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC4);
   \                     ??HAL_TIM_PWM_Stop_IT_3: (+1)
   \   00000028   0x.... 0x....      BL       ?Subroutine47
   1254              }
   \                     ??CrossCallReturnLabel_152: (+1)
   \   0000002C   0x60C2             STR      R2,[R0, #+12]
   1255              break;
   1256              
   1257              default:
   1258              break; 
   1259            }
   1260            
   1261            /* Disable the Capture compare channel */
   1262            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
   \                     ??HAL_TIM_PWM_Stop_IT_4: (+1)
   \   0000002E   0x.... 0x....      BL       ?Subroutine21
   1263            
   1264            if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
   \                     ??CrossCallReturnLabel_62: (+1)
   \   00000032   0x.... 0x....      BL       ?Subroutine18
   \                     ??CrossCallReturnLabel_41: (+1)
   \   00000036   0xBF1C             ITT      NE 
   \   00000038   0x.... 0x....      LDRNE.W  R3,??DataTable17_2  ;; 0x40010400
   \   0000003C   0x4298             CMPNE    R0,R3
   \   0000003E   0xD106             BNE.N    ??CrossCallReturnLabel_4
   1265            {
   1266              /* Disable the Main Output */
   1267              __HAL_TIM_MOE_DISABLE(htim);
   \   00000040   0x6A03             LDR      R3,[R0, #+32]
   \   00000042   0x4213             TST      R3,R2
   \   00000044   0xBF04             ITT      EQ 
   \   00000046   0x6A03             LDREQ    R3,[R0, #+32]
   \   00000048   0x420B             TSTEQ    R3,R1
   \   0000004A   0x.... 0x....      BL       ?Subroutine11
   1268            }
   1269            
   1270            /* Disable the Peripheral */
   1271            __HAL_TIM_DISABLE(htim);
   \                     ??CrossCallReturnLabel_4: (+1)
   \   0000004E   0x6A03             LDR      R3,[R0, #+32]
   \   00000050   0x4213             TST      R3,R2
   \   00000052   0xBF04             ITT      EQ 
   \   00000054   0x6A02             LDREQ    R2,[R0, #+32]
   \   00000056   0x420A             TSTEQ    R2,R1
   \   00000058   0x....             B.N      ?Subroutine2
   1272            
   1273            /* Return function status */
   1274            return HAL_OK;
   1275          } 
   1276          
   1277          /**
   1278            * @brief  Starts the TIM PWM signal generation in DMA mode.
   1279            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   1280            *                the configuration information for TIM module.
   1281            * @param  Channel: TIM Channels to be enabled.
   1282            *          This parameter can be one of the following values:
   1283            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1284            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1285            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1286            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1287            * @param  pData: The source Buffer address.
   1288            * @param  Length: The length of data to be transferred from memory to TIM peripheral
   1289            * @retval HAL status
   1290            */

   \                                 In section .text, align 2, keep-with-next
   1291          HAL_StatusTypeDef HAL_TIM_PWM_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData, uint16_t Length)
   1292          {
   \                     HAL_TIM_PWM_Start_DMA: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x.... 0x....      BL       ?Subroutine15
   1293            /* Check the parameters */
   1294            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1295            
   1296            if((htim->State == HAL_TIM_STATE_BUSY))
   \                     ??CrossCallReturnLabel_20: (+1)
   \   00000006   0xD02F             BEQ.N    ??CrossCallReturnLabel_15
   1297            {
   1298               return HAL_BUSY;
   1299            }
   1300            else if((htim->State == HAL_TIM_STATE_READY))
   \   00000008   0x.... 0x....      BL       ??Subroutine16_0
   \                     ??CrossCallReturnLabel_29: (+1)
   \   0000000C   0xD104             BNE.N    ??CrossCallReturnLabel_33
   1301            {
   1302              if(((uint32_t)pData == 0 ) && (Length > 0)) 
   \   0000000E   0xB909             CBNZ.N   R1,??HAL_TIM_PWM_Start_DMA_0
   \   00000010   0x2B00             CMP      R3,#+0
   \   00000012   0xD129             BNE.N    ??CrossCallReturnLabel_15
   1303              {
   1304                return HAL_ERROR;                                    
   1305              }
   1306              else
   1307              {
   1308                htim->State = HAL_TIM_STATE_BUSY;
   \                     ??HAL_TIM_PWM_Start_DMA_0: (+1)
   \   00000014   0x.... 0x....      BL       ?Subroutine17
   1309              }
   1310            }    
   1311            switch (Channel)
   \                     ??CrossCallReturnLabel_33: (+1)
   \   00000018   0x.... 0x....      BL       ?Subroutine62
   \                     ??CrossCallReturnLabel_198: (+1)
   \   0000001C   0xD006             BEQ.N    ??HAL_TIM_PWM_Start_DMA_1
   \   0000001E   0x2D04             CMP      R5,#+4
   \   00000020   0xD009             BEQ.N    ??HAL_TIM_PWM_Start_DMA_2
   \   00000022   0x2D08             CMP      R5,#+8
   \   00000024   0xD00C             BEQ.N    ??HAL_TIM_PWM_Start_DMA_3
   \   00000026   0x2D0C             CMP      R5,#+12
   \   00000028   0xD00F             BEQ.N    ??HAL_TIM_PWM_Start_DMA_4
   \   0000002A   0xE013             B.N      ??HAL_TIM_PWM_Start_DMA_5
   1312            {
   1313              case TIM_CHANNEL_1:
   1314              {      
   1315                /* Set the DMA Period elapsed callback */
   1316                htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = HAL_TIM_DMADelayPulseCplt;
   \                     ??HAL_TIM_PWM_Start_DMA_1: (+1)
   \   0000002C   0x.... 0x....      BL       ?Subroutine31
   1317               
   1318                /* Set the DMA error callback */
   1319                htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = HAL_TIM_DMAError ;
   1320                
   1321                /* Enable the DMA Stream */
   1322                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)pData, (uint32_t)&htim->Instance->CCR1, Length);
   1323                
   1324                /* Enable the TIM Capture/Compare 1 DMA request */
   1325                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
   \                     ??CrossCallReturnLabel_108: (+1)
   \   00000030   0x.... 0x....      BL       ?Subroutine35
   1326              }
   \                     ??CrossCallReturnLabel_117: (+1)
   \   00000034   0xE00D             B.N      ??CrossCallReturnLabel_126
   1327              break;
   1328              
   1329              case TIM_CHANNEL_2:
   1330              {
   1331                /* Set the DMA Period elapsed callback */
   1332                htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = HAL_TIM_DMADelayPulseCplt;
   \                     ??HAL_TIM_PWM_Start_DMA_2: (+1)
   \   00000036   0x.... 0x....      BL       ?Subroutine32
   1333               
   1334                /* Set the DMA error callback */
   1335                htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = HAL_TIM_DMAError ;
   1336                
   1337                /* Enable the DMA Stream */
   1338                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)pData, (uint32_t)&htim->Instance->CCR2, Length);
   1339                
   1340                /* Enable the TIM Capture/Compare 2 DMA request */
   1341                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
   \                     ??CrossCallReturnLabel_110: (+1)
   \   0000003A   0x.... 0x....      BL       ?Subroutine36
   1342              }
   \                     ??CrossCallReturnLabel_120: (+1)
   \   0000003E   0xE008             B.N      ??CrossCallReturnLabel_126
   1343              break;
   1344              
   1345              case TIM_CHANNEL_3:
   1346              {
   1347                /* Set the DMA Period elapsed callback */
   1348                htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = HAL_TIM_DMADelayPulseCplt;
   \                     ??HAL_TIM_PWM_Start_DMA_3: (+1)
   \   00000040   0x.... 0x....      BL       ?Subroutine33
   1349               
   1350                /* Set the DMA error callback */
   1351                htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = HAL_TIM_DMAError ;
   1352                
   1353                /* Enable the DMA Stream */
   1354                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)pData, (uint32_t)&htim->Instance->CCR3,Length);
   1355                
   1356                /* Enable the TIM Output Capture/Compare 3 request */
   1357                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);
   \                     ??CrossCallReturnLabel_112: (+1)
   \   00000044   0x.... 0x....      BL       ?Subroutine37
   1358              }
   \                     ??CrossCallReturnLabel_123: (+1)
   \   00000048   0xE003             B.N      ??CrossCallReturnLabel_126
   1359              break;
   1360              
   1361              case TIM_CHANNEL_4:
   1362              {
   1363               /* Set the DMA Period elapsed callback */
   1364                htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = HAL_TIM_DMADelayPulseCplt;
   \                     ??HAL_TIM_PWM_Start_DMA_4: (+1)
   \   0000004A   0x.... 0x....      BL       ?Subroutine34
   1365               
   1366                /* Set the DMA error callback */
   1367                htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = HAL_TIM_DMAError ;
   1368                
   1369                /* Enable the DMA Stream */
   1370                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)pData, (uint32_t)&htim->Instance->CCR4, Length);
   1371                
   1372                /* Enable the TIM Capture/Compare 4 DMA request */
   1373                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC4);
   \                     ??CrossCallReturnLabel_114: (+1)
   \   0000004E   0x.... 0x....      BL       ?Subroutine38
   1374              }
   \                     ??CrossCallReturnLabel_126: (+1)
   \   00000052   0x60C1             STR      R1,[R0, #+12]
   1375              break;
   1376              
   1377              default:
   1378              break;
   1379            }
   1380          
   1381            /* Enable the Capture compare channel */
   1382            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
   \                     ??HAL_TIM_PWM_Start_DMA_5: (+1)
   \   00000054   0x.... 0x....      BL       ?Subroutine25
   1383              
   1384            if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
   \                     ??CrossCallReturnLabel_85: (+1)
   \   00000058   0x.... 0x....      BL       ?Subroutine20
   \                     ??CrossCallReturnLabel_56: (+1)
   \   0000005C   0xBF1C             ITT      NE 
   \   0000005E   0x.... 0x....      LDRNE.W  R1,??DataTable17_2  ;; 0x40010400
   \   00000062   0x4288             CMPNE    R0,R1
   \   00000064   0x.... 0x....      BL       ?Subroutine13
   1385            {
   1386              /* Enable the main output */
   1387              __HAL_TIM_MOE_ENABLE(htim);
   1388            }
   1389            
   1390            /* Enable the Peripheral */
   1391            __HAL_TIM_ENABLE(htim); 
   1392            
   1393            /* Return function status */
   1394            return HAL_OK;
   \                     ??CrossCallReturnLabel_15: (+1)
   \   00000068   0xBD70             POP      {R4-R6,PC}       ;; return
   1395          }
   1396          
   1397          /**
   1398            * @brief  Stops the TIM PWM signal generation in DMA mode.
   1399            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   1400            *                the configuration information for TIM module.
   1401            * @param  Channel: TIM Channels to be disabled.
   1402            *          This parameter can be one of the following values:
   1403            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1404            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1405            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1406            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1407            * @retval HAL status
   1408            */

   \                                 In section .text, align 2, keep-with-next
   1409          HAL_StatusTypeDef HAL_TIM_PWM_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
   1410          {
   \                     HAL_TIM_PWM_Stop_DMA: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   1411            /* Check the parameters */
   1412            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1413            
   1414            switch (Channel)
   \   00000004   0x0008             MOVS     R0,R1
   \   00000006   0xD006             BEQ.N    ??HAL_TIM_PWM_Stop_DMA_0
   \   00000008   0x2904             CMP      R1,#+4
   \   0000000A   0xD007             BEQ.N    ??HAL_TIM_PWM_Stop_DMA_1
   \   0000000C   0x2908             CMP      R1,#+8
   \   0000000E   0xD008             BEQ.N    ??HAL_TIM_PWM_Stop_DMA_2
   \   00000010   0x290C             CMP      R1,#+12
   \   00000012   0xD009             BEQ.N    ??HAL_TIM_PWM_Stop_DMA_3
   \   00000014   0xE00B             B.N      ??HAL_TIM_PWM_Stop_DMA_4
   1415            {
   1416              case TIM_CHANNEL_1:
   1417              {       
   1418                /* Disable the TIM Capture/Compare 1 DMA request */
   1419                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
   \                     ??HAL_TIM_PWM_Stop_DMA_0: (+1)
   \   00000016   0x.... 0x....      BL       ?Subroutine48
   1420              }
   \                     ??CrossCallReturnLabel_155: (+1)
   \   0000001A   0xE007             B.N      ??CrossCallReturnLabel_164
   1421              break;
   1422              
   1423              case TIM_CHANNEL_2:
   1424              {
   1425                /* Disable the TIM Capture/Compare 2 DMA request */
   1426                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
   \                     ??HAL_TIM_PWM_Stop_DMA_1: (+1)
   \   0000001C   0x.... 0x....      BL       ?Subroutine49
   1427              }
   \                     ??CrossCallReturnLabel_158: (+1)
   \   00000020   0xE004             B.N      ??CrossCallReturnLabel_164
   1428              break;
   1429              
   1430              case TIM_CHANNEL_3:
   1431              {
   1432                /* Disable the TIM Capture/Compare 3 DMA request */
   1433                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);
   \                     ??HAL_TIM_PWM_Stop_DMA_2: (+1)
   \   00000022   0x.... 0x....      BL       ?Subroutine50
   1434              }
   \                     ??CrossCallReturnLabel_161: (+1)
   \   00000026   0xE001             B.N      ??CrossCallReturnLabel_164
   1435              break;
   1436              
   1437              case TIM_CHANNEL_4:
   1438              {
   1439                /* Disable the TIM Capture/Compare 4 interrupt */
   1440                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC4);
   \                     ??HAL_TIM_PWM_Stop_DMA_3: (+1)
   \   00000028   0x.... 0x....      BL       ?Subroutine51
   1441              }
   \                     ??CrossCallReturnLabel_164: (+1)
   \   0000002C   0x60C2             STR      R2,[R0, #+12]
   1442              break;
   1443              
   1444              default:
   1445              break;
   1446            } 
   1447            
   1448            /* Disable the Capture compare channel */
   1449            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
   \                     ??HAL_TIM_PWM_Stop_DMA_4: (+1)
   \   0000002E   0x.... 0x....      BL       ?Subroutine21
   1450            
   1451            if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
   \                     ??CrossCallReturnLabel_61: (+1)
   \   00000032   0x.... 0x....      BL       ?Subroutine18
   \                     ??CrossCallReturnLabel_42: (+1)
   \   00000036   0xBF1C             ITT      NE 
   \   00000038   0x.... 0x....      LDRNE.W  R3,??DataTable17_2  ;; 0x40010400
   \   0000003C   0x4298             CMPNE    R0,R3
   \   0000003E   0xD106             BNE.N    ??CrossCallReturnLabel_5
   1452            {
   1453              /* Disable the Main Output */
   1454              __HAL_TIM_MOE_DISABLE(htim);
   \   00000040   0x6A03             LDR      R3,[R0, #+32]
   \   00000042   0x4213             TST      R3,R2
   \   00000044   0xBF04             ITT      EQ 
   \   00000046   0x6A03             LDREQ    R3,[R0, #+32]
   \   00000048   0x420B             TSTEQ    R3,R1
   \   0000004A   0x.... 0x....      BL       ?Subroutine11
   1455            }
   1456            
   1457            /* Disable the Peripheral */
   1458            __HAL_TIM_DISABLE(htim);
   \                     ??CrossCallReturnLabel_5: (+1)
   \   0000004E   0x6820             LDR      R0,[R4, #+0]
   \   00000050   0x6A03             LDR      R3,[R0, #+32]
   \   00000052   0x4213             TST      R3,R2
   \   00000054   0xBF04             ITT      EQ 
   \   00000056   0x6A02             LDREQ    R2,[R0, #+32]
   \   00000058   0x420A             TSTEQ    R2,R1
   \   0000005A   0x....             B.N      ?Subroutine1
   1459            
   1460            /* Change the htim state */
   1461            htim->State = HAL_TIM_STATE_READY;
   1462            
   1463            /* Return function status */
   1464            return HAL_OK;
   1465          }
   1466          
   1467          /**
   1468            * @}
   1469            */
   1470          
   1471          /** @defgroup TIM_Exported_Functions_Group4 Time Input Capture functions 
   1472           *  @brief    Time Input Capture functions 
   1473           *
   1474          @verbatim    
   1475            ==============================================================================
   1476                        ##### Time Input Capture functions #####
   1477            ==============================================================================
   1478           [..]  
   1479             This section provides functions allowing to:
   1480             (+) Initialize and configure the TIM Input Capture. 
   1481             (+) De-initialize the TIM Input Capture.
   1482             (+) Start the Time Input Capture.
   1483             (+) Stop the Time Input Capture.
   1484             (+) Start the Time Input Capture and enable interrupt.
   1485             (+) Stop the Time Input Capture and disable interrupt.
   1486             (+) Start the Time Input Capture and enable DMA transfer.
   1487             (+) Stop the Time Input Capture and disable DMA transfer.
   1488           
   1489          @endverbatim
   1490            * @{
   1491            */
   1492          /**
   1493            * @brief  Initializes the TIM Input Capture Time base according to the specified
   1494            *         parameters in the TIM_HandleTypeDef and create the associated handle.
   1495            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   1496            *                the configuration information for TIM module.
   1497            * @retval HAL status
   1498            */

   \                                 In section .text, align 2, keep-with-next
   1499          HAL_StatusTypeDef HAL_TIM_IC_Init(TIM_HandleTypeDef *htim)
   1500          {
   \                     HAL_TIM_IC_Init: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1501            /* Check the TIM handle allocation */
   1502            if(htim == NULL)
   \   00000004   0xD101             BNE.N    ??HAL_TIM_IC_Init_0
   1503            {
   1504              return HAL_ERROR;
   \   00000006   0x2001             MOVS     R0,#+1
   \   00000008   0xBD32             POP      {R1,R4,R5,PC}
   1505            }
   1506          
   1507            /* Check the parameters */
   1508            assert_param(IS_TIM_INSTANCE(htim->Instance));
   1509            assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
   1510            assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision)); 
   1511          
   1512            if(htim->State == HAL_TIM_STATE_RESET)
   \                     ??HAL_TIM_IC_Init_0: (+1)
   \   0000000A   0xF104 0x0538      ADD      R5,R4,#+56
   \   0000000E   0x7868             LDRB     R0,[R5, #+1]
   \   00000010   0xB918             CBNZ.N   R0,??HAL_TIM_IC_Init_1
   1513            { 
   1514              /* Allocate lock resource and initialize it */
   1515              htim->Lock = HAL_UNLOCKED;   
   \   00000012   0x7028             STRB     R0,[R5, #+0]
   1516              /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
   1517              HAL_TIM_IC_MspInit(htim);
   \   00000014   0x4620             MOV      R0,R4
   \   00000016   0x.... 0x....      BL       HAL_TIM_IC_MspInit
   1518            }
   1519            
   1520            /* Set the TIM state */
   1521            htim->State= HAL_TIM_STATE_BUSY;   
   \                     ??HAL_TIM_IC_Init_1: (+1)
   \   0000001A   0x....             B.N      ?Subroutine9
   1522            
   1523            /* Init the base time for the input capture */  
   1524            TIM_Base_SetConfig(htim->Instance, &htim->Init); 
   1525             
   1526            /* Initialize the TIM state*/
   1527            htim->State= HAL_TIM_STATE_READY;
   1528            
   1529            return HAL_OK;
   1530          }
   1531          
   1532          /**
   1533            * @brief  DeInitializes the TIM peripheral 
   1534            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   1535            *                the configuration information for TIM module.
   1536            * @retval HAL status
   1537            */

   \                                 In section .text, align 2, keep-with-next
   1538          HAL_StatusTypeDef HAL_TIM_IC_DeInit(TIM_HandleTypeDef *htim)
   1539          {
   \                     HAL_TIM_IC_DeInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   1540            /* Check the parameters */
   1541            assert_param(IS_TIM_INSTANCE(htim->Instance));
   1542          
   1543            htim->State = HAL_TIM_STATE_BUSY;
   \   00000002   0x.... 0x....      BL       ?Subroutine55
   1544            
   1545            /* Disable the TIM Peripheral Clock */
   1546            __HAL_TIM_DISABLE(htim);
   \                     ??CrossCallReturnLabel_175: (+1)
   \   00000006   0xBF02             ITTT     EQ 
   \   00000008   0x6A0A             LDREQ    R2,[R1, #+32]
   \   0000000A   0xF240 0x4344      MOVWEQ   R3,#+1092
   \   0000000E   0x421A             TSTEQ    R2,R3
   \   00000010   0x.... 0x....      BL       ?Subroutine12
   1547              
   1548            /* DeInit the low level hardware: GPIO, CLOCK, NVIC and DMA */
   1549            HAL_TIM_IC_MspDeInit(htim);
   \                     ??CrossCallReturnLabel_11: (+1)
   \   00000014   0x.... 0x....      BL       HAL_TIM_IC_MspDeInit
   1550              
   1551            /* Change TIM state */  
   1552            htim->State = HAL_TIM_STATE_RESET;
   \   00000018   0x....             B.N      ?Subroutine4
   1553          
   1554            /* Release Lock */
   1555            __HAL_UNLOCK(htim);
   1556          
   1557            return HAL_OK;
   1558          }
   1559          
   1560          /**
   1561            * @brief  Initializes the TIM INput Capture MSP.
   1562            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   1563            *                the configuration information for TIM module.
   1564            * @retval None
   1565            */

   \                                 In section .text, align 2, keep-with-next
   1566          __weak void HAL_TIM_IC_MspInit(TIM_HandleTypeDef *htim)
   1567          {
   1568            /* NOTE : This function Should not be modified, when the callback is needed,
   1569                      the HAL_TIM_IC_MspInit could be implemented in the user file
   1570             */
   1571          }
   \                     HAL_TIM_IC_MspInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1572          
   1573          /**
   1574            * @brief  DeInitializes TIM Input Capture MSP.
   1575            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   1576            *                the configuration information for TIM module.
   1577            * @retval None
   1578            */

   \                                 In section .text, align 2, keep-with-next
   1579          __weak void HAL_TIM_IC_MspDeInit(TIM_HandleTypeDef *htim)
   1580          {
   1581            /* NOTE : This function Should not be modified, when the callback is needed,
   1582                      the HAL_TIM_IC_MspDeInit could be implemented in the user file
   1583             */
   1584          }
   \                     HAL_TIM_IC_MspDeInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1585          
   1586          /**
   1587            * @brief  Starts the TIM Input Capture measurement.
   1588            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   1589            *                the configuration information for TIM module.
   1590            * @param  Channel: TIM Channels to be enabled.
   1591            *          This parameter can be one of the following values:
   1592            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1593            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1594            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1595            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1596            * @retval HAL status
   1597            */

   \                                 In section .text, align 2, keep-with-next
   1598          HAL_StatusTypeDef HAL_TIM_IC_Start (TIM_HandleTypeDef *htim, uint32_t Channel)
   1599          {
   \                     HAL_TIM_IC_Start: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x.... 0x....      BL       ?Subroutine22
   1600            /* Check the parameters */
   1601            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1602            
   1603            /* Enable the Input Capture channel */
   1604            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
   1605              
   1606            /* Enable the Peripheral */
   1607            __HAL_TIM_ENABLE(htim);  
   \                     ??CrossCallReturnLabel_72: (+1)
   \   00000006   0x6820             LDR      R0,[R4, #+0]
   \   00000008   0x....             B.N      ??Subroutine0_0
   1608          
   1609            /* Return function status */
   1610            return HAL_OK;  
   1611          } 
   1612          
   1613          /**
   1614            * @brief  Stops the TIM Input Capture measurement.
   1615            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   1616            *                the configuration information for TIM module.
   1617            * @param  Channel: TIM Channels to be disabled.
   1618            *          This parameter can be one of the following values:
   1619            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1620            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1621            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1622            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1623            * @retval HAL status
   1624            */

   \                                 In section .text, align 2, keep-with-next
   1625          HAL_StatusTypeDef HAL_TIM_IC_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
   1626          { 
   \                     HAL_TIM_IC_Stop: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   1627            /* Check the parameters */
   1628            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1629            
   1630            /* Disable the Input Capture channel */
   1631            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
   \   00000004   0x2200             MOVS     R2,#+0
   \   00000006   0x.... 0x....      BL       ??Subroutine22_0
   1632            
   1633            /* Disable the Peripheral */
   1634            __HAL_TIM_DISABLE(htim); 
   \                     ??CrossCallReturnLabel_69: (+1)
   \   0000000A   0x.... 0x....      BL       ??Subroutine19_0
   \                     ??CrossCallReturnLabel_47: (+1)
   \   0000000E   0xBF02             ITTT     EQ 
   \   00000010   0x6A01             LDREQ    R1,[R0, #+32]
   \   00000012   0xF240 0x4244      MOVWEQ   R2,#+1092
   \   00000016   0x4211             TSTEQ    R1,R2
   \   00000018   0x....             B.N      ?Subroutine2
   1635            
   1636            /* Return function status */
   1637            return HAL_OK;
   1638          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine19: (+1)
   \   00000000   0x60C1             STR      R1,[R0, #+12]
   \                     ??Subroutine19_0: (+1)
   \   00000002   0x6820             LDR      R0,[R4, #+0]
   \   00000004   0xF241 0x1211      MOVW     R2,#+4369
   \   00000008   0x6A01             LDR      R1,[R0, #+32]
   \   0000000A   0x4211             TST      R1,R2
   \   0000000C   0x4770             BX       LR
   1639          
   1640          /**
   1641            * @brief  Starts the TIM Input Capture measurement in interrupt mode.
   1642            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   1643            *                the configuration information for TIM module.
   1644            * @param  Channel: TIM Channels to be enabled.
   1645            *          This parameter can be one of the following values:
   1646            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1647            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1648            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1649            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1650            * @retval HAL status
   1651            */

   \                                 In section .text, align 2, keep-with-next
   1652          HAL_StatusTypeDef HAL_TIM_IC_Start_IT (TIM_HandleTypeDef *htim, uint32_t Channel)
   1653          {
   \                     HAL_TIM_IC_Start_IT: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   1654            /* Check the parameters */
   1655            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1656            
   1657            switch (Channel)
   \   00000004   0x0008             MOVS     R0,R1
   \   00000006   0xD006             BEQ.N    ??HAL_TIM_IC_Start_IT_0
   \   00000008   0x2904             CMP      R1,#+4
   \   0000000A   0xD007             BEQ.N    ??HAL_TIM_IC_Start_IT_1
   \   0000000C   0x2908             CMP      R1,#+8
   \   0000000E   0xD008             BEQ.N    ??HAL_TIM_IC_Start_IT_2
   \   00000010   0x290C             CMP      R1,#+12
   \   00000012   0xD009             BEQ.N    ??HAL_TIM_IC_Start_IT_3
   \   00000014   0xE00B             B.N      ??HAL_TIM_IC_Start_IT_4
   1658            {
   1659              case TIM_CHANNEL_1:
   1660              {       
   1661                /* Enable the TIM Capture/Compare 1 interrupt */
   1662                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
   \                     ??HAL_TIM_IC_Start_IT_0: (+1)
   \   00000016   0x.... 0x....      BL       ?Subroutine40
   1663              }
   \                     ??CrossCallReturnLabel_132: (+1)
   \   0000001A   0xE007             B.N      ??CrossCallReturnLabel_141
   1664              break;
   1665              
   1666              case TIM_CHANNEL_2:
   1667              {
   1668                /* Enable the TIM Capture/Compare 2 interrupt */
   1669                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
   \                     ??HAL_TIM_IC_Start_IT_1: (+1)
   \   0000001C   0x.... 0x....      BL       ?Subroutine41
   1670              }
   \                     ??CrossCallReturnLabel_135: (+1)
   \   00000020   0xE004             B.N      ??CrossCallReturnLabel_141
   1671              break;
   1672              
   1673              case TIM_CHANNEL_3:
   1674              {
   1675                /* Enable the TIM Capture/Compare 3 interrupt */
   1676                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);
   \                     ??HAL_TIM_IC_Start_IT_2: (+1)
   \   00000022   0x.... 0x....      BL       ?Subroutine42
   1677              }
   \                     ??CrossCallReturnLabel_138: (+1)
   \   00000026   0xE001             B.N      ??CrossCallReturnLabel_141
   1678              break;
   1679              
   1680              case TIM_CHANNEL_4:
   1681              {
   1682                /* Enable the TIM Capture/Compare 4 interrupt */
   1683                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC4);
   \                     ??HAL_TIM_IC_Start_IT_3: (+1)
   \   00000028   0x.... 0x....      BL       ?Subroutine43
   1684              }
   \                     ??CrossCallReturnLabel_141: (+1)
   \   0000002C   0x60C2             STR      R2,[R0, #+12]
   1685              break;
   1686              
   1687              default:
   1688              break;
   1689            }  
   1690            /* Enable the Input Capture channel */
   1691            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
   \                     ??HAL_TIM_IC_Start_IT_4: (+1)
   \   0000002E   0x.... 0x....      BL       ?Subroutine24
   1692              
   1693            /* Enable the Peripheral */
   1694            __HAL_TIM_ENABLE(htim);  
   \                     ??CrossCallReturnLabel_81: (+1)
   \   00000032   0x6820             LDR      R0,[R4, #+0]
   \   00000034   0x....             B.N      ??Subroutine0_0
   1695          
   1696            /* Return function status */
   1697            return HAL_OK;  
   1698          } 
   1699          
   1700          /**
   1701            * @brief  Stops the TIM Input Capture measurement in interrupt mode.
   1702            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   1703            *                the configuration information for TIM module.
   1704            * @param  Channel: TIM Channels to be disabled.
   1705            *          This parameter can be one of the following values:
   1706            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1707            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1708            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1709            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1710            * @retval HAL status
   1711            */

   \                                 In section .text, align 2, keep-with-next
   1712          HAL_StatusTypeDef HAL_TIM_IC_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
   1713          {
   \                     HAL_TIM_IC_Stop_IT: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   1714            /* Check the parameters */
   1715            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1716            
   1717            switch (Channel)
   \   00000004   0x0008             MOVS     R0,R1
   \   00000006   0xD006             BEQ.N    ??HAL_TIM_IC_Stop_IT_0
   \   00000008   0x2904             CMP      R1,#+4
   \   0000000A   0xD007             BEQ.N    ??HAL_TIM_IC_Stop_IT_1
   \   0000000C   0x2908             CMP      R1,#+8
   \   0000000E   0xD008             BEQ.N    ??HAL_TIM_IC_Stop_IT_2
   \   00000010   0x290C             CMP      R1,#+12
   \   00000012   0xD009             BEQ.N    ??HAL_TIM_IC_Stop_IT_3
   \   00000014   0xE00B             B.N      ??HAL_TIM_IC_Stop_IT_4
   1718            {
   1719              case TIM_CHANNEL_1:
   1720              {       
   1721                /* Disable the TIM Capture/Compare 1 interrupt */
   1722                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
   \                     ??HAL_TIM_IC_Stop_IT_0: (+1)
   \   00000016   0x.... 0x....      BL       ?Subroutine44
   1723              }
   \                     ??CrossCallReturnLabel_144: (+1)
   \   0000001A   0xE007             B.N      ??CrossCallReturnLabel_153
   1724              break;
   1725              
   1726              case TIM_CHANNEL_2:
   1727              {
   1728                /* Disable the TIM Capture/Compare 2 interrupt */
   1729                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
   \                     ??HAL_TIM_IC_Stop_IT_1: (+1)
   \   0000001C   0x.... 0x....      BL       ?Subroutine45
   1730              }
   \                     ??CrossCallReturnLabel_147: (+1)
   \   00000020   0xE004             B.N      ??CrossCallReturnLabel_153
   1731              break;
   1732              
   1733              case TIM_CHANNEL_3:
   1734              {
   1735                /* Disable the TIM Capture/Compare 3 interrupt */
   1736                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);
   \                     ??HAL_TIM_IC_Stop_IT_2: (+1)
   \   00000022   0x.... 0x....      BL       ?Subroutine46
   1737              }
   \                     ??CrossCallReturnLabel_150: (+1)
   \   00000026   0xE001             B.N      ??CrossCallReturnLabel_153
   1738              break;
   1739              
   1740              case TIM_CHANNEL_4:
   1741              {
   1742                /* Disable the TIM Capture/Compare 4 interrupt */
   1743                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC4);
   \                     ??HAL_TIM_IC_Stop_IT_3: (+1)
   \   00000028   0x.... 0x....      BL       ?Subroutine47
   1744              }
   \                     ??CrossCallReturnLabel_153: (+1)
   \   0000002C   0x60C2             STR      R2,[R0, #+12]
   1745              break;
   1746              
   1747              default:
   1748              break; 
   1749            } 
   1750            
   1751            /* Disable the Input Capture channel */
   1752            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE); 
   \                     ??HAL_TIM_IC_Stop_IT_4: (+1)
   \   0000002E   0x.... 0x....      BL       ?Subroutine21
   1753            
   1754            /* Disable the Peripheral */
   1755            __HAL_TIM_DISABLE(htim); 
   \                     ??CrossCallReturnLabel_60: (+1)
   \   00000032   0x.... 0x....      BL       ??Subroutine19_0
   \                     ??CrossCallReturnLabel_48: (+1)
   \   00000036   0xBF02             ITTT     EQ 
   \   00000038   0x6A01             LDREQ    R1,[R0, #+32]
   \   0000003A   0xF240 0x4244      MOVWEQ   R2,#+1092
   \   0000003E   0x4211             TSTEQ    R1,R2
   \   00000040   0x....             B.N      ?Subroutine2
   1756            
   1757            /* Return function status */
   1758            return HAL_OK;
   1759          }
   1760          
   1761          /**
   1762            * @brief  Starts the TIM Input Capture measurement on in DMA mode.
   1763            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   1764            *                the configuration information for TIM module.
   1765            * @param  Channel: TIM Channels to be enabled.
   1766            *          This parameter can be one of the following values:
   1767            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1768            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1769            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1770            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1771            * @param  pData: The destination Buffer address.
   1772            * @param  Length: The length of data to be transferred from TIM peripheral to memory.
   1773            * @retval HAL status
   1774            */

   \                                 In section .text, align 2, keep-with-next
   1775          HAL_StatusTypeDef HAL_TIM_IC_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData, uint16_t Length)
   1776          {
   \                     HAL_TIM_IC_Start_DMA: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   1777            /* Check the parameters */
   1778            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1779            assert_param(IS_TIM_DMA_CC_INSTANCE(htim->Instance));
   1780            
   1781            if((htim->State == HAL_TIM_STATE_BUSY))
   \   00000006   0x.... 0x....      BL       ??Subroutine15_0
   \                     ??CrossCallReturnLabel_22: (+1)
   \   0000000A   0xD04B             BEQ.N    ??CrossCallReturnLabel_129
   1782            {
   1783               return HAL_BUSY;
   1784            }
   1785            else if((htim->State == HAL_TIM_STATE_READY))
   \   0000000C   0x.... 0x....      BL       ??Subroutine16_0
   \                     ??CrossCallReturnLabel_30: (+1)
   \   00000010   0xD104             BNE.N    ??CrossCallReturnLabel_34
   1786            {
   1787              if((pData == 0 ) && (Length > 0)) 
   \   00000012   0xB90A             CBNZ.N   R2,??HAL_TIM_IC_Start_DMA_0
   \   00000014   0x2B00             CMP      R3,#+0
   \   00000016   0xD145             BNE.N    ??CrossCallReturnLabel_129
   1788              {
   1789                return HAL_ERROR;                                    
   1790              }
   1791              else
   1792              {
   1793                htim->State = HAL_TIM_STATE_BUSY;
   \                     ??HAL_TIM_IC_Start_DMA_0: (+1)
   \   00000018   0x.... 0x....      BL       ?Subroutine17
   1794              }
   1795            }  
   1796             
   1797            switch (Channel)
   \                     ??CrossCallReturnLabel_34: (+1)
   \   0000001C   0x002E             MOVS     R6,R5
   \   0000001E   0x....             LDR.N    R0,??DataTable17_1
   \   00000020   0x.... 0x....      LDR.W    R1,??DataTable20
   \   00000024   0xD006             BEQ.N    ??HAL_TIM_IC_Start_DMA_1
   \   00000026   0x2D04             CMP      R5,#+4
   \   00000028   0xD011             BEQ.N    ??HAL_TIM_IC_Start_DMA_2
   \   0000002A   0x2D08             CMP      R5,#+8
   \   0000002C   0xD01C             BEQ.N    ??HAL_TIM_IC_Start_DMA_3
   \   0000002E   0x2D0C             CMP      R5,#+12
   \   00000030   0xD027             BEQ.N    ??HAL_TIM_IC_Start_DMA_4
   \   00000032   0xE033             B.N      ??HAL_TIM_IC_Start_DMA_5
   1798            {
   1799              case TIM_CHANNEL_1:
   1800              {
   1801                /* Set the DMA Period elapsed callback */
   1802                htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = HAL_TIM_DMACaptureCplt;
   \                     ??HAL_TIM_IC_Start_DMA_1: (+1)
   \   00000034   0x6A26             LDR      R6,[R4, #+32]
   \   00000036   0x63F1             STR      R1,[R6, #+60]
   1803               
   1804                /* Set the DMA error callback */
   1805                htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = HAL_TIM_DMAError ;
   \   00000038   0x6A21             LDR      R1,[R4, #+32]
   \   0000003A   0x6488             STR      R0,[R1, #+72]
   1806                
   1807                /* Enable the DMA Stream */
   1808                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->CCR1, (uint32_t)pData, Length); 
   \   0000003C   0x6820             LDR      R0,[R4, #+0]
   \   0000003E   0xF100 0x0134      ADD      R1,R0,#+52
   \   00000042   0x6A20             LDR      R0,[R4, #+32]
   \   00000044   0x.... 0x....      BL       HAL_DMA_Start_IT
   1809                
   1810                /* Enable the TIM Capture/Compare 1 DMA request */      
   1811                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
   \   00000048   0x.... 0x....      BL       ?Subroutine35
   1812              }
   \                     ??CrossCallReturnLabel_118: (+1)
   \   0000004C   0xE025             B.N      ??CrossCallReturnLabel_127
   1813              break;
   1814              
   1815              case TIM_CHANNEL_2:
   1816              {
   1817                /* Set the DMA Period elapsed callback */
   1818                htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = HAL_TIM_DMACaptureCplt;
   \                     ??HAL_TIM_IC_Start_DMA_2: (+1)
   \   0000004E   0x6A66             LDR      R6,[R4, #+36]
   \   00000050   0x63F1             STR      R1,[R6, #+60]
   1819               
   1820                /* Set the DMA error callback */
   1821                htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = HAL_TIM_DMAError ;
   \   00000052   0x6A61             LDR      R1,[R4, #+36]
   \   00000054   0x6488             STR      R0,[R1, #+72]
   1822                
   1823                /* Enable the DMA Stream */
   1824                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->CCR2, (uint32_t)pData, Length);
   \   00000056   0x6820             LDR      R0,[R4, #+0]
   \   00000058   0xF100 0x0138      ADD      R1,R0,#+56
   \   0000005C   0x6A60             LDR      R0,[R4, #+36]
   \   0000005E   0x.... 0x....      BL       HAL_DMA_Start_IT
   1825                
   1826                /* Enable the TIM Capture/Compare 2  DMA request */
   1827                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
   \   00000062   0x.... 0x....      BL       ?Subroutine36
   1828              }
   \                     ??CrossCallReturnLabel_121: (+1)
   \   00000066   0xE018             B.N      ??CrossCallReturnLabel_127
   1829              break;
   1830              
   1831              case TIM_CHANNEL_3:
   1832              {
   1833                /* Set the DMA Period elapsed callback */
   1834                htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = HAL_TIM_DMACaptureCplt;
   \                     ??HAL_TIM_IC_Start_DMA_3: (+1)
   \   00000068   0x6AA6             LDR      R6,[R4, #+40]
   \   0000006A   0x63F1             STR      R1,[R6, #+60]
   1835               
   1836                /* Set the DMA error callback */
   1837                htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = HAL_TIM_DMAError ;
   \   0000006C   0x6AA1             LDR      R1,[R4, #+40]
   \   0000006E   0x6488             STR      R0,[R1, #+72]
   1838                
   1839                /* Enable the DMA Stream */
   1840                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)&htim->Instance->CCR3, (uint32_t)pData, Length);
   \   00000070   0x6820             LDR      R0,[R4, #+0]
   \   00000072   0xF100 0x013C      ADD      R1,R0,#+60
   \   00000076   0x6AA0             LDR      R0,[R4, #+40]
   \   00000078   0x.... 0x....      BL       HAL_DMA_Start_IT
   1841                
   1842                /* Enable the TIM Capture/Compare 3  DMA request */
   1843                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);
   \   0000007C   0x.... 0x....      BL       ?Subroutine37
   1844              }
   \                     ??CrossCallReturnLabel_124: (+1)
   \   00000080   0xE00B             B.N      ??CrossCallReturnLabel_127
   1845              break;
   1846              
   1847              case TIM_CHANNEL_4:
   1848              {
   1849                /* Set the DMA Period elapsed callback */
   1850                htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = HAL_TIM_DMACaptureCplt;
   \                     ??HAL_TIM_IC_Start_DMA_4: (+1)
   \   00000082   0x6AE6             LDR      R6,[R4, #+44]
   \   00000084   0x63F1             STR      R1,[R6, #+60]
   1851               
   1852                /* Set the DMA error callback */
   1853                htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = HAL_TIM_DMAError ;
   \   00000086   0x6AE1             LDR      R1,[R4, #+44]
   \   00000088   0x6488             STR      R0,[R1, #+72]
   1854                
   1855                /* Enable the DMA Stream */
   1856                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)&htim->Instance->CCR4, (uint32_t)pData, Length);
   \   0000008A   0x6820             LDR      R0,[R4, #+0]
   \   0000008C   0xF100 0x0140      ADD      R1,R0,#+64
   \   00000090   0x6AE0             LDR      R0,[R4, #+44]
   \   00000092   0x.... 0x....      BL       HAL_DMA_Start_IT
   1857                
   1858                /* Enable the TIM Capture/Compare 4  DMA request */
   1859                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC4);
   \   00000096   0x.... 0x....      BL       ?Subroutine38
   1860              }
   \                     ??CrossCallReturnLabel_127: (+1)
   \   0000009A   0x60C1             STR      R1,[R0, #+12]
   1861              break;
   1862              
   1863              default:
   1864              break;
   1865            }
   1866          
   1867            /* Enable the Input Capture channel */
   1868            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
   \                     ??HAL_TIM_IC_Start_DMA_5: (+1)
   \   0000009C   0x.... 0x....      BL       ?Subroutine25
   1869             
   1870            /* Enable the Peripheral */
   1871            __HAL_TIM_ENABLE(htim); 
   \                     ??CrossCallReturnLabel_84: (+1)
   \   000000A0   0x.... 0x....      BL       ?Subroutine39
   1872            
   1873            /* Return function status */
   1874            return HAL_OK;
   \                     ??CrossCallReturnLabel_129: (+1)
   \   000000A4   0xBD70             POP      {R4-R6,PC}       ;; return
   1875          }
   1876          
   1877          /**
   1878            * @brief  Stops the TIM Input Capture measurement on in DMA mode.
   1879            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   1880            *                the configuration information for TIM module.
   1881            * @param  Channel: TIM Channels to be disabled.
   1882            *          This parameter can be one of the following values:
   1883            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1884            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1885            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1886            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1887            * @retval HAL status
   1888            */

   \                                 In section .text, align 2, keep-with-next
   1889          HAL_StatusTypeDef HAL_TIM_IC_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
   1890          {
   \                     HAL_TIM_IC_Stop_DMA: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   1891            /* Check the parameters */
   1892            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1893            assert_param(IS_TIM_DMA_CC_INSTANCE(htim->Instance));
   1894            
   1895            switch (Channel)
   \   00000004   0x0008             MOVS     R0,R1
   \   00000006   0xD006             BEQ.N    ??HAL_TIM_IC_Stop_DMA_0
   \   00000008   0x2904             CMP      R1,#+4
   \   0000000A   0xD007             BEQ.N    ??HAL_TIM_IC_Stop_DMA_1
   \   0000000C   0x2908             CMP      R1,#+8
   \   0000000E   0xD008             BEQ.N    ??HAL_TIM_IC_Stop_DMA_2
   \   00000010   0x290C             CMP      R1,#+12
   \   00000012   0xD009             BEQ.N    ??HAL_TIM_IC_Stop_DMA_3
   \   00000014   0xE00B             B.N      ??HAL_TIM_IC_Stop_DMA_4
   1896            {
   1897              case TIM_CHANNEL_1:
   1898              {       
   1899                /* Disable the TIM Capture/Compare 1 DMA request */
   1900                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
   \                     ??HAL_TIM_IC_Stop_DMA_0: (+1)
   \   00000016   0x.... 0x....      BL       ?Subroutine48
   1901              }
   \                     ??CrossCallReturnLabel_156: (+1)
   \   0000001A   0xE007             B.N      ??CrossCallReturnLabel_165
   1902              break;
   1903              
   1904              case TIM_CHANNEL_2:
   1905              {
   1906                /* Disable the TIM Capture/Compare 2 DMA request */
   1907                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
   \                     ??HAL_TIM_IC_Stop_DMA_1: (+1)
   \   0000001C   0x.... 0x....      BL       ?Subroutine49
   1908              }
   \                     ??CrossCallReturnLabel_159: (+1)
   \   00000020   0xE004             B.N      ??CrossCallReturnLabel_165
   1909              break;
   1910              
   1911              case TIM_CHANNEL_3:
   1912              {
   1913                /* Disable the TIM Capture/Compare 3  DMA request */
   1914                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);
   \                     ??HAL_TIM_IC_Stop_DMA_2: (+1)
   \   00000022   0x.... 0x....      BL       ?Subroutine50
   1915              }
   \                     ??CrossCallReturnLabel_162: (+1)
   \   00000026   0xE001             B.N      ??CrossCallReturnLabel_165
   1916              break;
   1917              
   1918              case TIM_CHANNEL_4:
   1919              {
   1920                /* Disable the TIM Capture/Compare 4  DMA request */
   1921                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC4);
   \                     ??HAL_TIM_IC_Stop_DMA_3: (+1)
   \   00000028   0x.... 0x....      BL       ?Subroutine51
   1922              }
   \                     ??CrossCallReturnLabel_165: (+1)
   \   0000002C   0x60C2             STR      R2,[R0, #+12]
   1923              break;
   1924              
   1925              default:
   1926              break;
   1927            }
   1928          
   1929            /* Disable the Input Capture channel */
   1930            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
   \                     ??HAL_TIM_IC_Stop_DMA_4: (+1)
   \   0000002E   0x.... 0x....      BL       ?Subroutine21
   1931            
   1932            /* Disable the Peripheral */
   1933            __HAL_TIM_DISABLE(htim); 
   \                     ??CrossCallReturnLabel_59: (+1)
   \   00000032   0x.... 0x....      BL       ??Subroutine19_0
   \                     ??CrossCallReturnLabel_49: (+1)
   \   00000036   0xBF02             ITTT     EQ 
   \   00000038   0x6A01             LDREQ    R1,[R0, #+32]
   \   0000003A   0xF240 0x4244      MOVWEQ   R2,#+1092
   \   0000003E   0x4211             TSTEQ    R1,R2
   \   00000040   0x....             B.N      ?Subroutine1
   1934            
   1935            /* Change the htim state */
   1936            htim->State = HAL_TIM_STATE_READY;
   1937            
   1938            /* Return function status */
   1939            return HAL_OK;
   1940          }  
   1941          /**
   1942            * @}
   1943            */
   1944            
   1945          /** @defgroup TIM_Exported_Functions_Group5 Time One Pulse functions 
   1946           *  @brief    Time One Pulse functions 
   1947           *
   1948          @verbatim    
   1949            ==============================================================================
   1950                                  ##### Time One Pulse functions #####
   1951            ==============================================================================
   1952            [..]  
   1953              This section provides functions allowing to:
   1954              (+) Initialize and configure the TIM One Pulse. 
   1955              (+) De-initialize the TIM One Pulse.
   1956              (+) Start the Time One Pulse.
   1957              (+) Stop the Time One Pulse.
   1958              (+) Start the Time One Pulse and enable interrupt.
   1959              (+) Stop the Time One Pulse and disable interrupt.
   1960              (+) Start the Time One Pulse and enable DMA transfer.
   1961              (+) Stop the Time One Pulse and disable DMA transfer.
   1962           
   1963          @endverbatim
   1964            * @{
   1965            */
   1966          /**
   1967            * @brief  Initializes the TIM One Pulse Time Base according to the specified
   1968            *         parameters in the TIM_HandleTypeDef and create the associated handle.
   1969            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   1970            *                the configuration information for TIM module.
   1971            * @param  OnePulseMode: Select the One pulse mode.
   1972            *         This parameter can be one of the following values:
   1973            *            @arg TIM_OPMODE_SINGLE: Only one pulse will be generated.
   1974            *            @arg TIM_OPMODE_REPETITIVE: Repetitive pulses will be generated.
   1975            * @retval HAL status
   1976            */

   \                                 In section .text, align 2, keep-with-next
   1977          HAL_StatusTypeDef HAL_TIM_OnePulse_Init(TIM_HandleTypeDef *htim, uint32_t OnePulseMode)
   1978          {
   \                     HAL_TIM_OnePulse_Init: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0006             MOVS     R6,R0
   \   00000004   0x460C             MOV      R4,R1
   1979            /* Check the TIM handle allocation */
   1980            if(htim == NULL)
   \   00000006   0xD101             BNE.N    ??HAL_TIM_OnePulse_Init_0
   1981            {
   1982              return HAL_ERROR;
   \   00000008   0x2001             MOVS     R0,#+1
   \   0000000A   0xBD70             POP      {R4-R6,PC}
   1983            }
   1984          
   1985            /* Check the parameters */
   1986            assert_param(IS_TIM_INSTANCE(htim->Instance));
   1987            assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
   1988            assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
   1989            assert_param(IS_TIM_OPM_MODE(OnePulseMode));
   1990            
   1991            if(htim->State == HAL_TIM_STATE_RESET)
   \                     ??HAL_TIM_OnePulse_Init_0: (+1)
   \   0000000C   0xF106 0x0538      ADD      R5,R6,#+56
   \   00000010   0x7868             LDRB     R0,[R5, #+1]
   \   00000012   0xB918             CBNZ.N   R0,??HAL_TIM_OnePulse_Init_1
   1992            { 
   1993              /* Allocate lock resource and initialize it */
   1994              htim->Lock = HAL_UNLOCKED;    
   \   00000014   0x7028             STRB     R0,[R5, #+0]
   1995              /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
   1996              HAL_TIM_OnePulse_MspInit(htim);
   \   00000016   0x4630             MOV      R0,R6
   \   00000018   0x.... 0x....      BL       HAL_TIM_OnePulse_MspInit
   1997            }
   1998            
   1999            /* Set the TIM state */
   2000            htim->State= HAL_TIM_STATE_BUSY;  
   \                     ??HAL_TIM_OnePulse_Init_1: (+1)
   \   0000001C   0x2002             MOVS     R0,#+2
   2001            
   2002            /* Configure the Time base in the One Pulse Mode */
   2003            TIM_Base_SetConfig(htim->Instance, &htim->Init);
   \   0000001E   0x1D31             ADDS     R1,R6,#+4
   \   00000020   0x7068             STRB     R0,[R5, #+1]
   \   00000022   0x6830             LDR      R0,[R6, #+0]
   \   00000024   0x.... 0x....      BL       TIM_Base_SetConfig
   2004            
   2005            /* Reset the OPM Bit */
   2006            htim->Instance->CR1 &= ~TIM_CR1_OPM;
   \   00000028   0x6830             LDR      R0,[R6, #+0]
   \   0000002A   0x6801             LDR      R1,[R0, #+0]
   \   0000002C   0xF021 0x0108      BIC      R1,R1,#0x8
   \   00000030   0x6001             STR      R1,[R0, #+0]
   2007          
   2008            /* Configure the OPM Mode */
   2009            htim->Instance->CR1 |= OnePulseMode;
   \   00000032   0x6830             LDR      R0,[R6, #+0]
   \   00000034   0x6801             LDR      R1,[R0, #+0]
   \   00000036   0x4321             ORRS     R1,R4,R1
   \   00000038   0x6001             STR      R1,[R0, #+0]
   2010             
   2011            /* Initialize the TIM state*/
   2012            htim->State= HAL_TIM_STATE_READY;
   \   0000003A   0x2001             MOVS     R0,#+1
   \   0000003C   0x7068             STRB     R0,[R5, #+1]
   2013            
   2014            return HAL_OK;
   \   0000003E   0x2000             MOVS     R0,#+0
   \   00000040   0xBD70             POP      {R4-R6,PC}       ;; return
   2015          }
   2016          
   2017          /**
   2018            * @brief  DeInitializes the TIM One Pulse  
   2019            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   2020            *                the configuration information for TIM module.
   2021            * @retval HAL status
   2022            */

   \                                 In section .text, align 2, keep-with-next
   2023          HAL_StatusTypeDef HAL_TIM_OnePulse_DeInit(TIM_HandleTypeDef *htim)
   2024          {
   \                     HAL_TIM_OnePulse_DeInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   2025            /* Check the parameters */
   2026            assert_param(IS_TIM_INSTANCE(htim->Instance));
   2027            
   2028            htim->State = HAL_TIM_STATE_BUSY;
   \   00000002   0x.... 0x....      BL       ?Subroutine55
   2029            
   2030            /* Disable the TIM Peripheral Clock */
   2031            __HAL_TIM_DISABLE(htim);
   \                     ??CrossCallReturnLabel_176: (+1)
   \   00000006   0xBF02             ITTT     EQ 
   \   00000008   0x6A0A             LDREQ    R2,[R1, #+32]
   \   0000000A   0xF240 0x4344      MOVWEQ   R3,#+1092
   \   0000000E   0x421A             TSTEQ    R2,R3
   \   00000010   0x.... 0x....      BL       ?Subroutine12
   2032            
   2033            /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
   2034            HAL_TIM_OnePulse_MspDeInit(htim);
   \                     ??CrossCallReturnLabel_12: (+1)
   \   00000014   0x.... 0x....      BL       HAL_TIM_OnePulse_MspDeInit
   2035              
   2036            /* Change TIM state */  
   2037            htim->State = HAL_TIM_STATE_RESET;
   \   00000018   0x....             B.N      ?Subroutine4
   2038          
   2039            /* Release Lock */
   2040            __HAL_UNLOCK(htim);
   2041          
   2042            return HAL_OK;
   2043          }
   2044          
   2045          /**
   2046            * @brief  Initializes the TIM One Pulse MSP.
   2047            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   2048            *                the configuration information for TIM module.
   2049            * @retval None
   2050            */

   \                                 In section .text, align 2, keep-with-next
   2051          __weak void HAL_TIM_OnePulse_MspInit(TIM_HandleTypeDef *htim)
   2052          {
   2053            /* NOTE : This function Should not be modified, when the callback is needed,
   2054                      the HAL_TIM_OnePulse_MspInit could be implemented in the user file
   2055             */
   2056          }
   \                     HAL_TIM_OnePulse_MspInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   2057          
   2058          /**
   2059            * @brief  DeInitializes TIM One Pulse MSP.
   2060            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   2061            *                the configuration information for TIM module.
   2062            * @retval None
   2063            */

   \                                 In section .text, align 2, keep-with-next
   2064          __weak void HAL_TIM_OnePulse_MspDeInit(TIM_HandleTypeDef *htim)
   2065          {
   2066            /* NOTE : This function Should not be modified, when the callback is needed,
   2067                      the HAL_TIM_OnePulse_MspDeInit could be implemented in the user file
   2068             */
   2069          }
   \                     HAL_TIM_OnePulse_MspDeInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   2070          
   2071          /**
   2072            * @brief  Starts the TIM One Pulse signal generation.
   2073            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   2074            *                the configuration information for TIM module.
   2075            * @param  OutputChannel : TIM Channels to be enabled.
   2076            *          This parameter can be one of the following values:
   2077            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2078            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2079            * @retval HAL status
   2080            */

   \                                 In section .text, align 2, keep-with-next
   2081          HAL_StatusTypeDef HAL_TIM_OnePulse_Start(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
   2082          {
   \                     HAL_TIM_OnePulse_Start: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   2083            /* Enable the Capture compare and the Input Capture channels 
   2084              (in the OPM Mode the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2)
   2085              if TIM_CHANNEL_1 is used as output, the TIM_CHANNEL_2 will be used as input and
   2086              if TIM_CHANNEL_1 is used as input, the TIM_CHANNEL_2 will be used as output 
   2087              in all combinations, the TIM_CHANNEL_1 and TIM_CHANNEL_2 should be enabled together 
   2088              
   2089              No need to enable the counter, it's enabled automatically by hardware 
   2090              (the counter starts in response to a stimulus and generate a pulse */
   2091            
   2092            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE); 
   \   00000004   0x2201             MOVS     R2,#+1
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x.... 0x....      BL       ??Subroutine22_0
   2093            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE); 
   \                     ??CrossCallReturnLabel_68: (+1)
   \   0000000C   0x.... 0x....      BL       ?Subroutine26
   2094            
   2095            if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
   \                     ??CrossCallReturnLabel_89: (+1)
   \   00000010   0x.... 0x....      BL       ?Subroutine20
   \                     ??CrossCallReturnLabel_57: (+1)
   \   00000014   0xBF1C             ITT      NE 
   \   00000016   0x....             LDRNE.N  R1,??DataTable17_2  ;; 0x40010400
   \   00000018   0x4288             CMPNE    R0,R1
   \   0000001A   0x....             B.N      ?Subroutine3
   2096            {
   2097              /* Enable the main output */
   2098              __HAL_TIM_MOE_ENABLE(htim);
   2099            }
   2100            
   2101            /* Return function status */
   2102            return HAL_OK;
   2103          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine3: (+1)
   \   00000000   0xD103             BNE.N    ??Subroutine3_0
   \   00000002   0x6C41             LDR      R1,[R0, #+68]
   \   00000004   0xF441 0x4100      ORR      R1,R1,#0x8000
   \   00000008   0x6441             STR      R1,[R0, #+68]
   \                     ??Subroutine3_0: (+1)
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine26: (+1)
   \   00000000   0x6820             LDR      R0,[R4, #+0]
   \   00000002   0x2201             MOVS     R2,#+1
   \   00000004   0x2104             MOVS     R1,#+4
   \   00000006   0x.... 0x....      B.W      TIM_CCxChannelCmd
   2104          
   2105          /**
   2106            * @brief  Stops the TIM One Pulse signal generation.
   2107            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   2108            *                the configuration information for TIM module.
   2109            * @param  OutputChannel : TIM Channels to be disable.
   2110            *          This parameter can be one of the following values:
   2111            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2112            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2113            * @retval HAL status
   2114            */

   \                                 In section .text, align 2, keep-with-next
   2115          HAL_StatusTypeDef HAL_TIM_OnePulse_Stop(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
   2116          {
   \                     HAL_TIM_OnePulse_Stop: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   2117            /* Disable the Capture compare and the Input Capture channels 
   2118            (in the OPM Mode the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2)
   2119            if TIM_CHANNEL_1 is used as output, the TIM_CHANNEL_2 will be used as input and
   2120            if TIM_CHANNEL_1 is used as input, the TIM_CHANNEL_2 will be used as output 
   2121            in all combinations, the TIM_CHANNEL_1 and TIM_CHANNEL_2 should be disabled together */
   2122            
   2123            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE); 
   \   00000004   0x2200             MOVS     R2,#+0
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x.... 0x....      BL       ??Subroutine22_0
   2124            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE); 
   \                     ??CrossCallReturnLabel_67: (+1)
   \   0000000C   0x.... 0x....      BL       ?Subroutine23
   2125              
   2126            if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
   \                     ??CrossCallReturnLabel_78: (+1)
   \   00000010   0x.... 0x....      BL       ?Subroutine18
   \                     ??CrossCallReturnLabel_43: (+1)
   \   00000014   0xBF1C             ITT      NE 
   \   00000016   0x....             LDRNE.N  R3,??DataTable17_2  ;; 0x40010400
   \   00000018   0x4298             CMPNE    R0,R3
   \   0000001A   0xD106             BNE.N    ??CrossCallReturnLabel_6
   2127            {
   2128              /* Disable the Main Output */
   2129              __HAL_TIM_MOE_DISABLE(htim);
   \   0000001C   0x6A03             LDR      R3,[R0, #+32]
   \   0000001E   0x4213             TST      R3,R2
   \   00000020   0xBF04             ITT      EQ 
   \   00000022   0x6A03             LDREQ    R3,[R0, #+32]
   \   00000024   0x420B             TSTEQ    R3,R1
   \   00000026   0x.... 0x....      BL       ?Subroutine11
   2130            }
   2131              
   2132            /* Disable the Peripheral */
   2133            __HAL_TIM_DISABLE(htim); 
   \                     ??CrossCallReturnLabel_6: (+1)
   \   0000002A   0x6A03             LDR      R3,[R0, #+32]
   \   0000002C   0x4213             TST      R3,R2
   \   0000002E   0xBF04             ITT      EQ 
   \   00000030   0x6A02             LDREQ    R2,[R0, #+32]
   \   00000032   0x420A             TSTEQ    R2,R1
   \   00000034   0x....             B.N      ?Subroutine2
   2134            
   2135            /* Return function status */
   2136            return HAL_OK;
   2137          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine23: (+1)
   \   00000000   0x6820             LDR      R0,[R4, #+0]
   \   00000002   0x2200             MOVS     R2,#+0
   \   00000004   0x2104             MOVS     R1,#+4
   \   00000006   0x.... 0x....      B.W      TIM_CCxChannelCmd
   2138          
   2139          /**
   2140            * @brief  Starts the TIM One Pulse signal generation in interrupt mode.
   2141            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   2142            *                the configuration information for TIM module.
   2143            * @param  OutputChannel : TIM Channels to be enabled.
   2144            *          This parameter can be one of the following values:
   2145            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2146            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2147            * @retval HAL status
   2148            */

   \                                 In section .text, align 2, keep-with-next
   2149          HAL_StatusTypeDef HAL_TIM_OnePulse_Start_IT(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
   2150          {
   \                     HAL_TIM_OnePulse_Start_IT: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   2151            /* Enable the Capture compare and the Input Capture channels 
   2152              (in the OPM Mode the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2)
   2153              if TIM_CHANNEL_1 is used as output, the TIM_CHANNEL_2 will be used as input and
   2154              if TIM_CHANNEL_1 is used as input, the TIM_CHANNEL_2 will be used as output 
   2155              in all combinations, the TIM_CHANNEL_1 and TIM_CHANNEL_2 should be enabled together 
   2156              
   2157              No need to enable the counter, it's enabled automatically by hardware 
   2158              (the counter starts in response to a stimulus and generate a pulse */
   2159           
   2160            /* Enable the TIM Capture/Compare 1 interrupt */
   2161            __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
   2162            
   2163            /* Enable the TIM Capture/Compare 2 interrupt */
   2164            __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
   2165            
   2166            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE); 
   \   00000004   0x2201             MOVS     R2,#+1
   \   00000006   0x.... 0x....      BL       ?Subroutine53
   \                     ??CrossCallReturnLabel_168: (+1)
   \   0000000A   0x68C1             LDR      R1,[R0, #+12]
   \   0000000C   0xF041 0x0104      ORR      R1,R1,#0x4
   \   00000010   0x60C1             STR      R1,[R0, #+12]
   \   00000012   0x.... 0x....      BL       ??Subroutine60_0
   2167            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE); 
   \                     ??CrossCallReturnLabel_189: (+1)
   \   00000016   0x.... 0x....      BL       ?Subroutine26
   2168            
   2169            if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
   \                     ??CrossCallReturnLabel_88: (+1)
   \   0000001A   0x.... 0x....      BL       ?Subroutine20
   \                     ??CrossCallReturnLabel_58: (+1)
   \   0000001E   0xBF1C             ITT      NE 
   \   00000020   0x....             LDRNE.N  R1,??DataTable17_2  ;; 0x40010400
   \   00000022   0x4288             CMPNE    R0,R1
   \   00000024                      REQUIRE ?Subroutine3
   \   00000024                      ;; // Fall through to label ?Subroutine3
   2170            {
   2171              /* Enable the main output */
   2172              __HAL_TIM_MOE_ENABLE(htim);
   2173            }
   2174            
   2175            /* Return function status */
   2176            return HAL_OK;
   2177          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine60: (+1)
   \   00000000   0x2200             MOVS     R2,#+0
   \                     ??Subroutine60_0: (+1)
   \   00000002   0x2100             MOVS     R1,#+0
   \   00000004   0x.... 0x....      B.W      TIM_CCxChannelCmd

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine53: (+1)
   \   00000000   0x6820             LDR      R0,[R4, #+0]
   \   00000002   0x68C1             LDR      R1,[R0, #+12]
   \   00000004   0xF041 0x0102      ORR      R1,R1,#0x2
   \   00000008   0x60C1             STR      R1,[R0, #+12]
   \   0000000A   0x4770             BX       LR
   2178          
   2179          /**
   2180            * @brief  Stops the TIM One Pulse signal generation in interrupt mode.
   2181            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   2182            *                the configuration information for TIM module.
   2183            * @param  OutputChannel : TIM Channels to be enabled.
   2184            *          This parameter can be one of the following values:
   2185            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2186            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2187            * @retval HAL status
   2188            */

   \                                 In section .text, align 2, keep-with-next
   2189          HAL_StatusTypeDef HAL_TIM_OnePulse_Stop_IT(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
   2190          {
   \                     HAL_TIM_OnePulse_Stop_IT: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   2191            /* Disable the TIM Capture/Compare 1 interrupt */
   2192            __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);  
   2193            
   2194            /* Disable the TIM Capture/Compare 2 interrupt */
   2195            __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
   2196            
   2197            /* Disable the Capture compare and the Input Capture channels 
   2198            (in the OPM Mode the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2)
   2199            if TIM_CHANNEL_1 is used as output, the TIM_CHANNEL_2 will be used as input and
   2200            if TIM_CHANNEL_1 is used as input, the TIM_CHANNEL_2 will be used as output 
   2201            in all combinations, the TIM_CHANNEL_1 and TIM_CHANNEL_2 should be disabled together */  
   2202            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE); 
   \   00000004   0x2200             MOVS     R2,#+0
   \   00000006   0x.... 0x....      BL       ?Subroutine54
   \                     ??CrossCallReturnLabel_170: (+1)
   \   0000000A   0x68C1             LDR      R1,[R0, #+12]
   \   0000000C   0xF021 0x0104      BIC      R1,R1,#0x4
   \   00000010   0x60C1             STR      R1,[R0, #+12]
   \   00000012   0x.... 0x....      BL       ??Subroutine60_0
   2203            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE); 
   \                     ??CrossCallReturnLabel_188: (+1)
   \   00000016   0x.... 0x....      BL       ?Subroutine23
   2204              
   2205            if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
   \                     ??CrossCallReturnLabel_77: (+1)
   \   0000001A   0x.... 0x....      BL       ?Subroutine18
   \                     ??CrossCallReturnLabel_44: (+1)
   \   0000001E   0xBF1C             ITT      NE 
   \   00000020   0x....             LDRNE.N  R3,??DataTable17_2  ;; 0x40010400
   \   00000022   0x4298             CMPNE    R0,R3
   \   00000024   0xD106             BNE.N    ??CrossCallReturnLabel_7
   2206            {
   2207              /* Disable the Main Output */
   2208              __HAL_TIM_MOE_DISABLE(htim);
   \   00000026   0x6A03             LDR      R3,[R0, #+32]
   \   00000028   0x4213             TST      R3,R2
   \   0000002A   0xBF04             ITT      EQ 
   \   0000002C   0x6A03             LDREQ    R3,[R0, #+32]
   \   0000002E   0x420B             TSTEQ    R3,R1
   \   00000030   0x.... 0x....      BL       ?Subroutine11
   2209            }
   2210              
   2211            /* Disable the Peripheral */
   2212             __HAL_TIM_DISABLE(htim);  
   \                     ??CrossCallReturnLabel_7: (+1)
   \   00000034   0x6A03             LDR      R3,[R0, #+32]
   \   00000036   0x4213             TST      R3,R2
   \   00000038   0xBF04             ITT      EQ 
   \   0000003A   0x6A02             LDREQ    R2,[R0, #+32]
   \   0000003C   0x420A             TSTEQ    R2,R1
   \   0000003E   0x....             B.N      ?Subroutine2
   2213            
   2214            /* Return function status */
   2215            return HAL_OK;
   2216          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine54: (+1)
   \   00000000   0x6820             LDR      R0,[R4, #+0]
   \   00000002   0x68C1             LDR      R1,[R0, #+12]
   \   00000004   0xF021 0x0102      BIC      R1,R1,#0x2
   \   00000008   0x60C1             STR      R1,[R0, #+12]
   \   0000000A   0x4770             BX       LR
   2217          
   2218          /**
   2219            * @}
   2220            */
   2221          
   2222          /** @defgroup TIM_Exported_Functions_Group6 Time Encoder functions 
   2223           *  @brief    Time Encoder functions 
   2224           *
   2225          @verbatim    
   2226            ==============================================================================
   2227                                    ##### Time Encoder functions #####
   2228            ==============================================================================
   2229            [..]
   2230              This section provides functions allowing to:
   2231              (+) Initialize and configure the TIM Encoder. 
   2232              (+) De-initialize the TIM Encoder.
   2233              (+) Start the Time Encoder.
   2234              (+) Stop the Time Encoder.
   2235              (+) Start the Time Encoder and enable interrupt.
   2236              (+) Stop the Time Encoder and disable interrupt.
   2237              (+) Start the Time Encoder and enable DMA transfer.
   2238              (+) Stop the Time Encoder and disable DMA transfer.
   2239           
   2240          @endverbatim
   2241            * @{
   2242            */
   2243          /**
   2244            * @brief  Initializes the TIM Encoder Interface and create the associated handle.
   2245            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   2246            *                the configuration information for TIM module.
   2247            * @param  sConfig: TIM Encoder Interface configuration structure
   2248            * @retval HAL status
   2249            */

   \                                 In section .text, align 2, keep-with-next
   2250          HAL_StatusTypeDef HAL_TIM_Encoder_Init(TIM_HandleTypeDef *htim,  TIM_Encoder_InitTypeDef* sConfig)
   2251          {
   \                     HAL_TIM_Encoder_Init: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x460D             MOV      R5,R1
   2252            uint32_t tmpsmcr = 0;
   2253            uint32_t tmpccmr1 = 0;
   2254            uint32_t tmpccer = 0;
   2255            
   2256            /* Check the TIM handle allocation */
   2257            if(htim == NULL)
   \   00000006   0xD101             BNE.N    ??HAL_TIM_Encoder_Init_0
   2258            {
   2259              return HAL_ERROR;
   \   00000008   0x2001             MOVS     R0,#+1
   \   0000000A   0xBDF2             POP      {R1,R4-R7,PC}
   2260            }
   2261             
   2262            /* Check the parameters */
   2263            assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   2264            assert_param(IS_TIM_ENCODER_MODE(sConfig->EncoderMode));
   2265            assert_param(IS_TIM_IC_SELECTION(sConfig->IC1Selection));
   2266            assert_param(IS_TIM_IC_SELECTION(sConfig->IC2Selection));
   2267            assert_param(IS_TIM_IC_POLARITY(sConfig->IC1Polarity));
   2268            assert_param(IS_TIM_IC_POLARITY(sConfig->IC2Polarity));
   2269            assert_param(IS_TIM_IC_PRESCALER(sConfig->IC1Prescaler));
   2270            assert_param(IS_TIM_IC_PRESCALER(sConfig->IC2Prescaler));
   2271            assert_param(IS_TIM_IC_FILTER(sConfig->IC1Filter));
   2272            assert_param(IS_TIM_IC_FILTER(sConfig->IC2Filter));
   2273          
   2274            if(htim->State == HAL_TIM_STATE_RESET)
   \                     ??HAL_TIM_Encoder_Init_0: (+1)
   \   0000000C   0xF104 0x0638      ADD      R6,R4,#+56
   \   00000010   0x7870             LDRB     R0,[R6, #+1]
   \   00000012   0xB918             CBNZ.N   R0,??HAL_TIM_Encoder_Init_1
   2275            { 
   2276              /* Allocate lock resource and initialize it */
   2277              htim->Lock = HAL_UNLOCKED;  
   \   00000014   0x7030             STRB     R0,[R6, #+0]
   2278              /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
   2279              HAL_TIM_Encoder_MspInit(htim);
   \   00000016   0x4620             MOV      R0,R4
   \   00000018   0x.... 0x....      BL       HAL_TIM_Encoder_MspInit
   2280            }
   2281            
   2282            /* Set the TIM state */
   2283            htim->State= HAL_TIM_STATE_BUSY;   
   \                     ??HAL_TIM_Encoder_Init_1: (+1)
   \   0000001C   0x2002             MOVS     R0,#+2
   2284              
   2285            /* Reset the SMS bits */
   2286            htim->Instance->SMCR &= ~TIM_SMCR_SMS;
   \   0000001E   0x.... 0x....      LDR.W    R2,??DataTable22  ;; 0xfffefff8
   \   00000022   0x7070             STRB     R0,[R6, #+1]
   \   00000024   0x6820             LDR      R0,[R4, #+0]
   2287            
   2288            /* Configure the Time base in the Encoder Mode */
   2289            TIM_Base_SetConfig(htim->Instance, &htim->Init);  
   \   00000026   0x.... 0x....      LDR.W    R7,??DataTable22_1  ;; 0xfffffcfc
   \   0000002A   0x6881             LDR      R1,[R0, #+8]
   \   0000002C   0x4011             ANDS     R1,R2,R1
   \   0000002E   0x6081             STR      R1,[R0, #+8]
   \   00000030   0x6820             LDR      R0,[R4, #+0]
   \   00000032   0x1D21             ADDS     R1,R4,#+4
   \   00000034   0x.... 0x....      BL       TIM_Base_SetConfig
   2290            
   2291            /* Get the TIMx SMCR register value */
   2292            tmpsmcr = htim->Instance->SMCR;
   \   00000038   0x6820             LDR      R0,[R4, #+0]
   \   0000003A   0x6881             LDR      R1,[R0, #+8]
   2293          
   2294            /* Get the TIMx CCMR1 register value */
   2295            tmpccmr1 = htim->Instance->CCMR1;
   \   0000003C   0x6983             LDR      R3,[R0, #+24]
   2296          
   2297            /* Get the TIMx CCER register value */
   2298            tmpccer = htim->Instance->CCER;
   \   0000003E   0x6A02             LDR      R2,[R0, #+32]
   2299          
   2300            /* Set the encoder Mode */
   2301            tmpsmcr |= sConfig->EncoderMode;
   2302          
   2303            /* Select the Capture Compare 1 and the Capture Compare 2 as input */
   2304            tmpccmr1 &= ~(TIM_CCMR1_CC1S | TIM_CCMR1_CC2S);
   2305            tmpccmr1 |= (sConfig->IC1Selection | (sConfig->IC2Selection << 8));
   2306            
   2307            /* Set the Capture Compare 1 and the Capture Compare 2 prescalers and filters */
   2308            tmpccmr1 &= ~(TIM_CCMR1_IC1PSC | TIM_CCMR1_IC2PSC);
   2309            tmpccmr1 &= ~(TIM_CCMR1_IC1F | TIM_CCMR1_IC2F);
   2310            tmpccmr1 |= sConfig->IC1Prescaler | (sConfig->IC2Prescaler << 8);
   2311            tmpccmr1 |= (sConfig->IC1Filter << 4) | (sConfig->IC2Filter << 12);
   \   00000040   0x403B             ANDS     R3,R7,R3
   \   00000042   0x68AF             LDR      R7,[R5, #+8]
   2312          
   2313            /* Set the TI1 and the TI2 Polarities */
   2314            tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC2P);
   2315            tmpccer &= ~(TIM_CCER_CC1NP | TIM_CCER_CC2NP);
   2316            tmpccer |= sConfig->IC1Polarity | (sConfig->IC2Polarity << 4);
   \   00000044   0xF022 0x02AA      BIC      R2,R2,#0xAA
   \   00000048   0x433B             ORRS     R3,R7,R3
   \   0000004A   0x69AF             LDR      R7,[R5, #+24]
   \   0000004C   0xEA43 0x2307      ORR      R3,R3,R7, LSL #+8
   \   00000050   0x.... 0x....      LDR.W    R7,??DataTable22_2  ;; 0xffff0303
   \   00000054   0x403B             ANDS     R3,R7,R3
   \   00000056   0x68EF             LDR      R7,[R5, #+12]
   \   00000058   0x433B             ORRS     R3,R7,R3
   \   0000005A   0x69EF             LDR      R7,[R5, #+28]
   \   0000005C   0xEA43 0x2307      ORR      R3,R3,R7, LSL #+8
   \   00000060   0x692F             LDR      R7,[R5, #+16]
   \   00000062   0xEA43 0x1307      ORR      R3,R3,R7, LSL #+4
   \   00000066   0x6A2F             LDR      R7,[R5, #+32]
   \   00000068   0xEA43 0x3307      ORR      R3,R3,R7, LSL #+12
   \   0000006C   0x686F             LDR      R7,[R5, #+4]
   \   0000006E   0x433A             ORRS     R2,R7,R2
   \   00000070   0x696F             LDR      R7,[R5, #+20]
   2317            
   2318            /* Write to TIMx SMCR */
   2319            htim->Instance->SMCR = tmpsmcr;
   \   00000072   0x682D             LDR      R5,[R5, #+0]
   \   00000074   0xEA42 0x1207      ORR      R2,R2,R7, LSL #+4
   \   00000078   0x4329             ORRS     R1,R5,R1
   \   0000007A   0x6081             STR      R1,[R0, #+8]
   2320          
   2321            /* Write to TIMx CCMR1 */
   2322            htim->Instance->CCMR1 = tmpccmr1;
   \   0000007C   0x6820             LDR      R0,[R4, #+0]
   \   0000007E   0x6183             STR      R3,[R0, #+24]
   2323          
   2324            /* Write to TIMx CCER */
   2325            htim->Instance->CCER = tmpccer;
   \   00000080   0x6820             LDR      R0,[R4, #+0]
   \   00000082   0x6202             STR      R2,[R0, #+32]
   2326            
   2327            /* Initialize the TIM state*/
   2328            htim->State= HAL_TIM_STATE_READY;
   \   00000084   0x2001             MOVS     R0,#+1
   \   00000086   0x7070             STRB     R0,[R6, #+1]
   2329            
   2330            return HAL_OK;
   \   00000088   0x2000             MOVS     R0,#+0
   \   0000008A   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   2331          }
   2332          
   2333          /**
   2334            * @brief  DeInitializes the TIM Encoder interface  
   2335            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   2336            *                the configuration information for TIM module.
   2337            * @retval HAL status
   2338            */

   \                                 In section .text, align 2, keep-with-next
   2339          HAL_StatusTypeDef HAL_TIM_Encoder_DeInit(TIM_HandleTypeDef *htim)
   2340          {
   \                     HAL_TIM_Encoder_DeInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   2341            /* Check the parameters */
   2342            assert_param(IS_TIM_INSTANCE(htim->Instance));
   2343            
   2344            htim->State = HAL_TIM_STATE_BUSY;
   \   00000002   0x.... 0x....      BL       ?Subroutine55
   2345            
   2346            /* Disable the TIM Peripheral Clock */
   2347            __HAL_TIM_DISABLE(htim);
   \                     ??CrossCallReturnLabel_177: (+1)
   \   00000006   0xBF02             ITTT     EQ 
   \   00000008   0x6A0A             LDREQ    R2,[R1, #+32]
   \   0000000A   0xF240 0x4344      MOVWEQ   R3,#+1092
   \   0000000E   0x421A             TSTEQ    R2,R3
   \   00000010   0x.... 0x....      BL       ?Subroutine12
   2348            
   2349            /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
   2350            HAL_TIM_Encoder_MspDeInit(htim);
   \                     ??CrossCallReturnLabel_13: (+1)
   \   00000014   0x.... 0x....      BL       HAL_TIM_Encoder_MspDeInit
   2351              
   2352            /* Change TIM state */  
   2353            htim->State = HAL_TIM_STATE_RESET;
   \   00000018   0x.... 0x....      B.W      ?Subroutine4
   2354           
   2355            /* Release Lock */
   2356            __HAL_UNLOCK(htim);
   2357          
   2358            return HAL_OK;
   2359          }
   2360          
   2361          /**
   2362            * @brief  Initializes the TIM Encoder Interface MSP.
   2363            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   2364            *                the configuration information for TIM module.
   2365            * @retval None
   2366            */

   \                                 In section .text, align 2, keep-with-next
   2367          __weak void HAL_TIM_Encoder_MspInit(TIM_HandleTypeDef *htim)
   2368          {
   2369            /* NOTE : This function Should not be modified, when the callback is needed,
   2370                      the HAL_TIM_Encoder_MspInit could be implemented in the user file
   2371             */
   2372          }
   \                     HAL_TIM_Encoder_MspInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   2373          
   2374          /**
   2375            * @brief  DeInitializes TIM Encoder Interface MSP.
   2376            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   2377            *                the configuration information for TIM module.
   2378            * @retval None
   2379            */

   \                                 In section .text, align 2, keep-with-next
   2380          __weak void HAL_TIM_Encoder_MspDeInit(TIM_HandleTypeDef *htim)
   2381          {
   2382            /* NOTE : This function Should not be modified, when the callback is needed,
   2383                      the HAL_TIM_Encoder_MspDeInit could be implemented in the user file
   2384             */
   2385          }
   \                     HAL_TIM_Encoder_MspDeInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   2386          
   2387          /**
   2388            * @brief  Starts the TIM Encoder Interface.
   2389            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   2390            *                the configuration information for TIM module.
   2391            * @param  Channel: TIM Channels to be enabled.
   2392            *          This parameter can be one of the following values:
   2393            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2394            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2395            *            @arg TIM_CHANNEL_ALL: TIM Channel 1 and TIM Channel 2 are selected
   2396            * @retval HAL status
   2397            */

   \                                 In section .text, align 2, keep-with-next
   2398          HAL_StatusTypeDef HAL_TIM_Encoder_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
   2399          {
   \                     HAL_TIM_Encoder_Start: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   2400            /* Check the parameters */
   2401            assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   2402            
   2403            /* Enable the encoder interface channels */
   2404            switch (Channel)
   \   00000004   0xB109             CBZ.N    R1,??HAL_TIM_Encoder_Start_0
   \   00000006   0x2904             CMP      R1,#+4
   \   00000008   0xD101             BNE.N    ??HAL_TIM_Encoder_Start_1
   2405            {
   2406              case TIM_CHANNEL_1:
   2407              {
   2408                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
   2409                break; 
   2410              }
   2411              case TIM_CHANNEL_2:
   2412              { 
   2413                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE); 
   \                     ??HAL_TIM_Encoder_Start_0: (+1)
   \   0000000A   0x2201             MOVS     R2,#+1
   \   0000000C   0xE003             B.N      ??HAL_TIM_Encoder_Start_2
   2414                break;
   2415              }  
   2416              default :
   2417              {
   2418               TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
   \                     ??HAL_TIM_Encoder_Start_1: (+1)
   \   0000000E   0x.... 0x....      BL       ?Subroutine52
   2419               TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
   \                     ??CrossCallReturnLabel_167: (+1)
   \   00000012   0x2201             MOVS     R2,#+1
   \   00000014   0x2104             MOVS     R1,#+4
   \                     ??HAL_TIM_Encoder_Start_2: (+1)
   \   00000016   0x.... 0x....      BL       ??Subroutine22_0
   2420               break; 
   2421              }
   2422            }  
   2423            /* Enable the Peripheral */
   2424            __HAL_TIM_ENABLE(htim);
   \                     ??CrossCallReturnLabel_66: (+1)
   \   0000001A   0x6820             LDR      R0,[R4, #+0]
   \   0000001C   0x.... 0x....      B.W      ??Subroutine0_0
   2425            
   2426            /* Return function status */
   2427            return HAL_OK;
   2428          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine52: (+1)
   \   00000000   0x6820             LDR      R0,[R4, #+0]
   \   00000002   0x2201             MOVS     R2,#+1
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x.... 0x....      B.W      TIM_CCxChannelCmd
   2429          
   2430          /**
   2431            * @brief  Stops the TIM Encoder Interface.
   2432            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   2433            *                the configuration information for TIM module.
   2434            * @param  Channel: TIM Channels to be disabled.
   2435            *          This parameter can be one of the following values:
   2436            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2437            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2438            *            @arg TIM_CHANNEL_ALL: TIM Channel 1 and TIM Channel 2 are selected
   2439            * @retval HAL status
   2440            */

   \                                 In section .text, align 2, keep-with-next
   2441          HAL_StatusTypeDef HAL_TIM_Encoder_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
   2442          {
   \                     HAL_TIM_Encoder_Stop: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   2443            /* Check the parameters */
   2444              assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   2445              
   2446             /* Disable the Input Capture channels 1 and 2
   2447              (in the EncoderInterface the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2) */ 
   2448            switch (Channel)
   \   00000004   0xB109             CBZ.N    R1,??HAL_TIM_Encoder_Stop_0
   \   00000006   0x2904             CMP      R1,#+4
   \   00000008   0xD101             BNE.N    ??HAL_TIM_Encoder_Stop_1
   2449            {
   2450              case TIM_CHANNEL_1:
   2451              {
   2452                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
   2453                break; 
   2454              }
   2455              case TIM_CHANNEL_2:
   2456              { 
   2457                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE); 
   \                     ??HAL_TIM_Encoder_Stop_0: (+1)
   \   0000000A   0x2200             MOVS     R2,#+0
   \   0000000C   0xE004             B.N      ??HAL_TIM_Encoder_Stop_2
   2458                break;
   2459              }  
   2460              default :
   2461              {
   2462               TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
   \                     ??HAL_TIM_Encoder_Stop_1: (+1)
   \   0000000E   0x6820             LDR      R0,[R4, #+0]
   \   00000010   0x.... 0x....      BL       ?Subroutine60
   2463               TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
   \                     ??CrossCallReturnLabel_192: (+1)
   \   00000014   0x2200             MOVS     R2,#+0
   \   00000016   0x2104             MOVS     R1,#+4
   \                     ??HAL_TIM_Encoder_Stop_2: (+1)
   \   00000018   0x.... 0x....      BL       ??Subroutine22_0
   2464               break; 
   2465              }
   2466            }  
   2467            /* Disable the Peripheral */
   2468            __HAL_TIM_DISABLE(htim);
   \                     ??CrossCallReturnLabel_65: (+1)
   \   0000001C   0x.... 0x....      BL       ??Subroutine19_0
   \                     ??CrossCallReturnLabel_50: (+1)
   \   00000020   0xBF02             ITTT     EQ 
   \   00000022   0x6A01             LDREQ    R1,[R0, #+32]
   \   00000024   0xF240 0x4244      MOVWEQ   R2,#+1092
   \   00000028   0x4211             TSTEQ    R1,R2
   \   0000002A   0x.... 0x....      B.W      ?Subroutine2
   2469            
   2470            /* Return function status */
   2471            return HAL_OK;
   2472          }
   2473          
   2474          /**
   2475            * @brief  Starts the TIM Encoder Interface in interrupt mode.
   2476            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   2477            *                the configuration information for TIM module.
   2478            * @param  Channel: TIM Channels to be enabled.
   2479            *          This parameter can be one of the following values:
   2480            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2481            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2482            *            @arg TIM_CHANNEL_ALL: TIM Channel 1 and TIM Channel 2 are selected
   2483            * @retval HAL status
   2484            */

   \                                 In section .text, align 2, keep-with-next
   2485          HAL_StatusTypeDef HAL_TIM_Encoder_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
   2486          {
   \                     HAL_TIM_Encoder_Start_IT: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   2487            /* Check the parameters */
   2488            assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   2489            
   2490            /* Enable the encoder interface channels */
   2491            /* Enable the capture compare Interrupts 1 and/or 2 */
   2492            switch (Channel)
   \   00000004   0xB111             CBZ.N    R1,??HAL_TIM_Encoder_Start_IT_0
   \   00000006   0x2904             CMP      R1,#+4
   \   00000008   0xD007             BEQ.N    ??HAL_TIM_Encoder_Start_IT_1
   \   0000000A   0xE00A             B.N      ??HAL_TIM_Encoder_Start_IT_2
   2493            {
   2494              case TIM_CHANNEL_1:
   2495              {
   2496                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
   \                     ??HAL_TIM_Encoder_Start_IT_0: (+1)
   \   0000000C   0x.... 0x....      BL       ?Subroutine24
   2497                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
   \                     ??CrossCallReturnLabel_80: (+1)
   \   00000010   0x6820             LDR      R0,[R4, #+0]
   \   00000012   0x68C1             LDR      R1,[R0, #+12]
   \   00000014   0xF041 0x0102      ORR      R1,R1,#0x2
   \   00000018   0xE00C             B.N      ??HAL_TIM_Encoder_Start_IT_3
   2498                break; 
   2499              }
   2500              case TIM_CHANNEL_2:
   2501              { 
   2502                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
   \                     ??HAL_TIM_Encoder_Start_IT_1: (+1)
   \   0000001A   0x.... 0x....      BL       ?Subroutine24
   2503                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2); 
   \                     ??CrossCallReturnLabel_79: (+1)
   \   0000001E   0x6820             LDR      R0,[R4, #+0]
   \   00000020   0xE005             B.N      ??CrossCallReturnLabel_169
   2504                break;
   2505              }  
   2506              default :
   2507              {
   2508               TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
   \                     ??HAL_TIM_Encoder_Start_IT_2: (+1)
   \   00000022   0x.... 0x....      BL       ?Subroutine52
   2509               TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
   \                     ??CrossCallReturnLabel_166: (+1)
   \   00000026   0x.... 0x....      BL       ?Subroutine26
   2510               __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
   \                     ??CrossCallReturnLabel_87: (+1)
   \   0000002A   0x.... 0x....      BL       ?Subroutine53
   2511               __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
   \                     ??CrossCallReturnLabel_169: (+1)
   \   0000002E   0x68C1             LDR      R1,[R0, #+12]
   \   00000030   0xF041 0x0104      ORR      R1,R1,#0x4
   \                     ??HAL_TIM_Encoder_Start_IT_3: (+1)
   \   00000034   0x60C1             STR      R1,[R0, #+12]
   2512               break; 
   2513              }
   2514            }
   2515            
   2516            /* Enable the Peripheral */
   2517            __HAL_TIM_ENABLE(htim);
   \   00000036   0x6820             LDR      R0,[R4, #+0]
   \   00000038   0x.... 0x....      B.W      ??Subroutine0_0
   2518            
   2519            /* Return function status */
   2520            return HAL_OK;
   2521          }
   2522          
   2523          /**
   2524            * @brief  Stops the TIM Encoder Interface in interrupt mode.
   2525            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   2526            *                the configuration information for TIM module.
   2527            * @param  Channel: TIM Channels to be disabled.
   2528            *          This parameter can be one of the following values:
   2529            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2530            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2531            *            @arg TIM_CHANNEL_ALL: TIM Channel 1 and TIM Channel 2 are selected
   2532            * @retval HAL status
   2533            */

   \                                 In section .text, align 2, keep-with-next
   2534          HAL_StatusTypeDef HAL_TIM_Encoder_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
   2535          {
   \                     HAL_TIM_Encoder_Stop_IT: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   2536            /* Check the parameters */
   2537            assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   2538              
   2539            /* Disable the Input Capture channels 1 and 2
   2540              (in the EncoderInterface the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2) */ 
   2541            if(Channel == TIM_CHANNEL_1)
   \   00000004   0x6820             LDR      R0,[R4, #+0]
   \   00000006   0xB931             CBNZ.N   R1,??HAL_TIM_Encoder_Stop_IT_0
   2542            {
   2543              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE); 
   \   00000008   0x.... 0x....      BL       ?Subroutine61
   2544              
   2545              /* Disable the capture compare Interrupts 1 */
   2546            __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
   \                     ??CrossCallReturnLabel_196: (+1)
   \   0000000C   0x6820             LDR      R0,[R4, #+0]
   \   0000000E   0x68C1             LDR      R1,[R0, #+12]
   \   00000010   0xF021 0x0102      BIC      R1,R1,#0x2
   \   00000014   0xE00E             B.N      ??HAL_TIM_Encoder_Stop_IT_1
   2547            }  
   2548            else if(Channel == TIM_CHANNEL_2)
   \                     ??HAL_TIM_Encoder_Stop_IT_0: (+1)
   \   00000016   0x2904             CMP      R1,#+4
   \   00000018   0xD102             BNE.N    ??HAL_TIM_Encoder_Stop_IT_2
   2549            {  
   2550              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE); 
   \   0000001A   0x.... 0x....      BL       ?Subroutine61
   2551              
   2552              /* Disable the capture compare Interrupts 2 */
   2553            __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
   \                     ??CrossCallReturnLabel_195: (+1)
   \   0000001E   0xE005             B.N      ??CrossCallReturnLabel_171
   2554            }  
   2555            else
   2556            {
   2557              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE); 
   \                     ??HAL_TIM_Encoder_Stop_IT_2: (+1)
   \   00000020   0x.... 0x....      BL       ?Subroutine60
   2558              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE); 
   \                     ??CrossCallReturnLabel_191: (+1)
   \   00000024   0x.... 0x....      BL       ?Subroutine23
   2559              
   2560              /* Disable the capture compare Interrupts 1 and 2 */
   2561              __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
   \                     ??CrossCallReturnLabel_76: (+1)
   \   00000028   0x.... 0x....      BL       ?Subroutine54
   2562              __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
   \                     ??CrossCallReturnLabel_171: (+1)
   \   0000002C   0x6820             LDR      R0,[R4, #+0]
   \   0000002E   0x68C1             LDR      R1,[R0, #+12]
   \   00000030   0xF021 0x0104      BIC      R1,R1,#0x4
   2563            }
   \                     ??HAL_TIM_Encoder_Stop_IT_1: (+1)
   \   00000034   0x.... 0x....      BL       ?Subroutine19
   2564              
   2565            /* Disable the Peripheral */
   2566            __HAL_TIM_DISABLE(htim);
   \                     ??CrossCallReturnLabel_45: (+1)
   \   00000038   0xBF02             ITTT     EQ 
   \   0000003A   0x6A01             LDREQ    R1,[R0, #+32]
   \   0000003C   0xF240 0x4244      MOVWEQ   R2,#+1092
   \   00000040   0x4211             TSTEQ    R1,R2
   \   00000042   0x.... 0x....      B.W      ?Subroutine1
   2567            
   2568            /* Change the htim state */
   2569            htim->State = HAL_TIM_STATE_READY;
   2570            
   2571            /* Return function status */
   2572            return HAL_OK;
   2573          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine61: (+1)
   \   00000000   0x2200             MOVS     R2,#+0
   \   00000002   0x.... 0x....      B.W      TIM_CCxChannelCmd
   2574          
   2575          /**
   2576            * @brief  Starts the TIM Encoder Interface in DMA mode.
   2577            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   2578            *                the configuration information for TIM module.
   2579            * @param  Channel: TIM Channels to be enabled.
   2580            *          This parameter can be one of the following values:
   2581            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2582            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2583            *            @arg TIM_CHANNEL_ALL: TIM Channel 1 and TIM Channel 2 are selected
   2584            * @param  pData1: The destination Buffer address for IC1.
   2585            * @param  pData2: The destination Buffer address for IC2.
   2586            * @param  Length: The length of data to be transferred from TIM peripheral to memory.
   2587            * @retval HAL status
   2588            */

   \                                 In section .text, align 2, keep-with-next
   2589          HAL_StatusTypeDef HAL_TIM_Encoder_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData1, uint32_t *pData2, uint16_t Length)
   2590          {
   \                     HAL_TIM_Encoder_Start_DMA: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4605             MOV      R5,R0
   \   00000006   0x4698             MOV      R8,R3
   2591            /* Check the parameters */
   2592            assert_param(IS_TIM_DMA_CC_INSTANCE(htim->Instance));
   2593            
   2594            if((htim->State == HAL_TIM_STATE_BUSY))
   \   00000008   0xF895 0x0039      LDRB     R0,[R5, #+57]
   \   0000000C   0x2802             CMP      R0,#+2
   \   0000000E   0xD04C             BEQ.N    ??HAL_TIM_Encoder_Start_DMA_0
   \   00000010   0x9C06             LDR      R4,[SP, #+24]
   2595            {
   2596               return HAL_BUSY;
   2597            }
   2598            else if((htim->State == HAL_TIM_STATE_READY))
   \   00000012   0xF895 0x0039      LDRB     R0,[R5, #+57]
   \   00000016   0x2801             CMP      R0,#+1
   \   00000018   0xD109             BNE.N    ??HAL_TIM_Encoder_Start_DMA_1
   2599            {
   2600              if((((pData1 == 0) || (pData2 == 0) )) && (Length > 0)) 
   \   0000001A   0x2A00             CMP      R2,#+0
   \   0000001C   0xBF18             IT       NE 
   \   0000001E   0xF1B8 0x0F00      CMPNE    R8,#+0
   \   00000022   0xD101             BNE.N    ??HAL_TIM_Encoder_Start_DMA_2
   \   00000024   0x2C00             CMP      R4,#+0
   \   00000026   0xD140             BNE.N    ??HAL_TIM_Encoder_Start_DMA_0
   2601              {
   2602                return HAL_ERROR;                                    
   2603              }
   2604              else
   2605              {
   2606                htim->State = HAL_TIM_STATE_BUSY;
   \                     ??HAL_TIM_Encoder_Start_DMA_2: (+1)
   \   00000028   0x2002             MOVS     R0,#+2
   \   0000002A   0xF885 0x0039      STRB     R0,[R5, #+57]
   2607              }
   2608            }  
   2609             
   2610            switch (Channel)
   \                     ??HAL_TIM_Encoder_Start_DMA_1: (+1)
   \   0000002E   0x.... 0x....      ADR.W    R7,TIM_DMAError
   \   00000032   0x.... 0x....      ADR.W    R6,TIM_DMACaptureCplt
   \   00000036   0xB121             CBZ.N    R1,??HAL_TIM_Encoder_Start_DMA_3
   \   00000038   0x2904             CMP      R1,#+4
   \   0000003A   0xD00D             BEQ.N    ??HAL_TIM_Encoder_Start_DMA_4
   \   0000003C   0x293C             CMP      R1,#+60
   \   0000003E   0xD019             BEQ.N    ??HAL_TIM_Encoder_Start_DMA_5
   \   00000040   0xE032             B.N      ??HAL_TIM_Encoder_Start_DMA_6
   2611            {
   2612              case TIM_CHANNEL_1:
   2613              {
   2614                /* Set the DMA Period elapsed callback */
   2615                htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = HAL_TIM_DMACaptureCplt;
   \                     ??HAL_TIM_Encoder_Start_DMA_3: (+1)
   \   00000042   0x.... 0x....      BL       ?Subroutine58
   2616               
   2617                /* Set the DMA error callback */
   2618                htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = HAL_TIM_DMAError ;
   2619                
   2620                /* Enable the DMA Stream */
   2621                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->CCR1, (uint32_t )pData1, Length); 
   2622                
   2623                /* Enable the TIM Input Capture DMA request */      
   2624                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
   \                     ??CrossCallReturnLabel_184: (+1)
   \   00000046   0x6828             LDR      R0,[R5, #+0]
   2625                      
   2626                /* Enable the Peripheral */
   2627                __HAL_TIM_ENABLE(htim);
   2628                
   2629                /* Enable the Capture compare channel */
   2630                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
   \   00000048   0x2201             MOVS     R2,#+1
   \   0000004A   0x68C1             LDR      R1,[R0, #+12]
   \   0000004C   0xF441 0x7100      ORR      R1,R1,#0x200
   \   00000050   0x.... 0x....      BL       ?Subroutine56
   2631              }
   \                     ??CrossCallReturnLabel_178: (+1)
   \   00000054   0x2100             MOVS     R1,#+0
   \   00000056   0xE009             B.N      ??HAL_TIM_Encoder_Start_DMA_7
   2632              break;
   2633              
   2634              case TIM_CHANNEL_2:
   2635              {
   2636                /* Set the DMA Period elapsed callback */
   2637                htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = HAL_TIM_DMACaptureCplt;
   \                     ??HAL_TIM_Encoder_Start_DMA_4: (+1)
   \   00000058   0x.... 0x....      BL       ?Subroutine57
   2638               
   2639                /* Set the DMA error callback */
   2640                htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = HAL_TIM_DMAError;
   2641                /* Enable the DMA Stream */
   2642                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->CCR2, (uint32_t)pData2, Length);
   2643                
   2644                /* Enable the TIM Input Capture  DMA request */
   2645                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
   \                     ??CrossCallReturnLabel_182: (+1)
   \   0000005C   0x6828             LDR      R0,[R5, #+0]
   2646               
   2647                /* Enable the Peripheral */
   2648                __HAL_TIM_ENABLE(htim);
   2649                
   2650                /* Enable the Capture compare channel */
   2651                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
   \   0000005E   0x2201             MOVS     R2,#+1
   \   00000060   0x68C1             LDR      R1,[R0, #+12]
   \   00000062   0xF441 0x6180      ORR      R1,R1,#0x400
   \   00000066   0x.... 0x....      BL       ?Subroutine56
   2652              }
   \                     ??CrossCallReturnLabel_179: (+1)
   \   0000006A   0x2104             MOVS     R1,#+4
   \                     ??HAL_TIM_Encoder_Start_DMA_7: (+1)
   \   0000006C   0x6828             LDR      R0,[R5, #+0]
   \   0000006E   0x.... 0x....      BL       TIM_CCxChannelCmd
   2653              break;
   \   00000072   0xE019             B.N      ??HAL_TIM_Encoder_Start_DMA_6
   2654              
   2655              case TIM_CHANNEL_ALL:
   2656              {
   2657                /* Set the DMA Period elapsed callback */
   2658                htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = HAL_TIM_DMACaptureCplt;
   \                     ??HAL_TIM_Encoder_Start_DMA_5: (+1)
   \   00000074   0x.... 0x....      BL       ?Subroutine58
   2659               
   2660                /* Set the DMA error callback */
   2661                htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = HAL_TIM_DMAError ;
   2662                
   2663                /* Enable the DMA Stream */
   2664                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->CCR1, (uint32_t)pData1, Length);
   2665                
   2666                /* Set the DMA Period elapsed callback */
   2667                htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = HAL_TIM_DMACaptureCplt;
   \                     ??CrossCallReturnLabel_183: (+1)
   \   00000078   0x.... 0x....      BL       ?Subroutine57
   2668               
   2669                /* Set the DMA error callback */
   2670                htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = HAL_TIM_DMAError ;
   2671                
   2672                /* Enable the DMA Stream */
   2673                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->CCR2, (uint32_t)pData2, Length);
   2674                    
   2675               /* Enable the Peripheral */
   2676                __HAL_TIM_ENABLE(htim);
   \                     ??CrossCallReturnLabel_181: (+1)
   \   0000007C   0x6828             LDR      R0,[R5, #+0]
   2677                
   2678                /* Enable the Capture compare channel */
   2679                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
   \   0000007E   0x2201             MOVS     R2,#+1
   \   00000080   0x.... 0x....      BL       ??Subroutine56_0
   \                     ??CrossCallReturnLabel_180: (+1)
   \   00000084   0x6828             LDR      R0,[R5, #+0]
   \   00000086   0x.... 0x....      BL       ??Subroutine60_0
   2680                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
   \                     ??CrossCallReturnLabel_187: (+1)
   \   0000008A   0x6828             LDR      R0,[R5, #+0]
   \   0000008C   0x2201             MOVS     R2,#+1
   \   0000008E   0x2104             MOVS     R1,#+4
   \   00000090   0x.... 0x....      BL       TIM_CCxChannelCmd
   2681                
   2682                /* Enable the TIM Input Capture  DMA request */
   2683                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
   \   00000094   0x6828             LDR      R0,[R5, #+0]
   \   00000096   0x68C1             LDR      R1,[R0, #+12]
   \   00000098   0xF441 0x7100      ORR      R1,R1,#0x200
   \   0000009C   0x60C1             STR      R1,[R0, #+12]
   2684                /* Enable the TIM Input Capture  DMA request */
   2685                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
   \   0000009E   0x6828             LDR      R0,[R5, #+0]
   \   000000A0   0x68C1             LDR      R1,[R0, #+12]
   \   000000A2   0xF441 0x6180      ORR      R1,R1,#0x400
   \   000000A6   0x60C1             STR      R1,[R0, #+12]
   2686              }
   2687              break;
   2688              
   2689              default:
   2690              break;
   2691            }  
   2692            /* Return function status */
   2693            return HAL_OK;
   \                     ??HAL_TIM_Encoder_Start_DMA_6: (+1)
   \   000000A8   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_Encoder_Start_DMA_0: (+1)
   \   000000AA   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   2694          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine58: (+1)
   \   00000000   0x6A28             LDR      R0,[R5, #+32]
   \   00000002   0x4623             MOV      R3,R4
   \   00000004   0x63C6             STR      R6,[R0, #+60]
   \   00000006   0x6A28             LDR      R0,[R5, #+32]
   \   00000008   0x6487             STR      R7,[R0, #+72]
   \   0000000A   0x6828             LDR      R0,[R5, #+0]
   \   0000000C   0xF100 0x0134      ADD      R1,R0,#+52
   \   00000010   0x6A28             LDR      R0,[R5, #+32]
   \   00000012   0x.... 0x....      B.W      HAL_DMA_Start_IT

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine57: (+1)
   \   00000000   0x6A68             LDR      R0,[R5, #+36]
   \   00000002   0x4623             MOV      R3,R4
   \   00000004   0x4642             MOV      R2,R8
   \   00000006   0x63C6             STR      R6,[R0, #+60]
   \   00000008   0x6A68             LDR      R0,[R5, #+36]
   \   0000000A   0x6487             STR      R7,[R0, #+72]
   \   0000000C   0x6828             LDR      R0,[R5, #+0]
   \   0000000E   0xF100 0x0138      ADD      R1,R0,#+56
   \   00000012   0x6A68             LDR      R0,[R5, #+36]
   \   00000014   0x.... 0x....      B.W      HAL_DMA_Start_IT

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine56: (+1)
   \   00000000   0x60C1             STR      R1,[R0, #+12]
   \   00000002   0x6828             LDR      R0,[R5, #+0]
   \                     ??Subroutine56_0: (+1)
   \   00000004   0x6801             LDR      R1,[R0, #+0]
   \   00000006   0xF041 0x0101      ORR      R1,R1,#0x1
   \   0000000A   0x6001             STR      R1,[R0, #+0]
   \   0000000C   0x4770             BX       LR
   2695          
   2696          /**
   2697            * @brief  Stops the TIM Encoder Interface in DMA mode.
   2698            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   2699            *                the configuration information for TIM module.
   2700            * @param  Channel: TIM Channels to be enabled.
   2701            *          This parameter can be one of the following values:
   2702            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2703            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2704            *            @arg TIM_CHANNEL_ALL: TIM Channel 1 and TIM Channel 2 are selected
   2705            * @retval HAL status
   2706            */

   \                                 In section .text, align 2, keep-with-next
   2707          HAL_StatusTypeDef HAL_TIM_Encoder_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
   2708          {
   \                     HAL_TIM_Encoder_Stop_DMA: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   2709            /* Check the parameters */
   2710            assert_param(IS_TIM_DMA_CC_INSTANCE(htim->Instance));
   2711            
   2712            /* Disable the Input Capture channels 1 and 2
   2713              (in the EncoderInterface the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2) */ 
   2714            if(Channel == TIM_CHANNEL_1)
   \   00000004   0x6820             LDR      R0,[R4, #+0]
   \   00000006   0xB931             CBNZ.N   R1,??HAL_TIM_Encoder_Stop_DMA_0
   2715            {
   2716              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE); 
   \   00000008   0x.... 0x....      BL       ?Subroutine61
   2717              
   2718              /* Disable the capture compare DMA Request 1 */
   2719              __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
   \                     ??CrossCallReturnLabel_194: (+1)
   \   0000000C   0x6820             LDR      R0,[R4, #+0]
   \   0000000E   0x68C1             LDR      R1,[R0, #+12]
   \   00000010   0xF421 0x7100      BIC      R1,R1,#0x200
   \   00000014   0xE011             B.N      ??HAL_TIM_Encoder_Stop_DMA_1
   2720            }  
   2721            else if(Channel == TIM_CHANNEL_2)
   \                     ??HAL_TIM_Encoder_Stop_DMA_0: (+1)
   \   00000016   0x2904             CMP      R1,#+4
   \   00000018   0xD102             BNE.N    ??HAL_TIM_Encoder_Stop_DMA_2
   2722            {  
   2723              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE); 
   \   0000001A   0x.... 0x....      BL       ?Subroutine61
   2724              
   2725              /* Disable the capture compare DMA Request 2 */
   2726              __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
   \                     ??CrossCallReturnLabel_193: (+1)
   \   0000001E   0xE008             B.N      ??HAL_TIM_Encoder_Stop_DMA_3
   2727            }  
   2728            else
   2729            {
   2730              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE); 
   \                     ??HAL_TIM_Encoder_Stop_DMA_2: (+1)
   \   00000020   0x.... 0x....      BL       ?Subroutine60
   2731              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE); 
   \                     ??CrossCallReturnLabel_190: (+1)
   \   00000024   0x.... 0x....      BL       ?Subroutine23
   2732              
   2733              /* Disable the capture compare DMA Request 1 and 2 */
   2734              __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
   \                     ??CrossCallReturnLabel_75: (+1)
   \   00000028   0x6820             LDR      R0,[R4, #+0]
   \   0000002A   0x68C1             LDR      R1,[R0, #+12]
   \   0000002C   0xF421 0x7100      BIC      R1,R1,#0x200
   \   00000030   0x60C1             STR      R1,[R0, #+12]
   2735              __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
   \                     ??HAL_TIM_Encoder_Stop_DMA_3: (+1)
   \   00000032   0x6820             LDR      R0,[R4, #+0]
   \   00000034   0x68C1             LDR      R1,[R0, #+12]
   \   00000036   0xF421 0x6180      BIC      R1,R1,#0x400
   2736            }
   \                     ??HAL_TIM_Encoder_Stop_DMA_1: (+1)
   \   0000003A   0x.... 0x....      BL       ?Subroutine19
   2737            
   2738            /* Disable the Peripheral */
   2739            __HAL_TIM_DISABLE(htim);
   \                     ??CrossCallReturnLabel_46: (+1)
   \   0000003E   0xBF02             ITTT     EQ 
   \   00000040   0x6A01             LDREQ    R1,[R0, #+32]
   \   00000042   0xF240 0x4244      MOVWEQ   R2,#+1092
   \   00000046   0x4211             TSTEQ    R1,R2
   \   00000048   0x.... 0x....      B.W      ?Subroutine1
   2740            
   2741            /* Change the htim state */
   2742            htim->State = HAL_TIM_STATE_READY;
   2743            
   2744            /* Return function status */
   2745            return HAL_OK;
   2746          }
   2747          
   2748          /**
   2749            * @}
   2750            */
   2751          /** @defgroup TIM_Exported_Functions_Group7 TIM IRQ handler management 
   2752           *  @brief    IRQ handler management 
   2753           *
   2754          @verbatim   
   2755            ==============================================================================
   2756                                  ##### IRQ handler management #####
   2757            ==============================================================================  
   2758            [..]  
   2759              This section provides Timer IRQ handler function.
   2760                         
   2761          @endverbatim
   2762            * @{
   2763            */
   2764          /**
   2765            * @brief  This function handles TIM interrupts requests.
   2766            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   2767            *                the configuration information for TIM module.
   2768            * @retval None
   2769            */

   \                                 In section .text, align 2, keep-with-next
   2770          void HAL_TIM_IRQHandler(TIM_HandleTypeDef *htim)
   2771          {
   \                     HAL_TIM_IRQHandler: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   2772            /* Capture compare 1 event */
   2773            if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC1) != RESET)
   \   00000004   0x6820             LDR      R0,[R4, #+0]
   \   00000006   0x6901             LDR      R1,[R0, #+16]
   \   00000008   0x0789             LSLS     R1,R1,#+30
   \   0000000A   0xD516             BPL.N    ??HAL_TIM_IRQHandler_0
   2774            {
   2775              if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC1) !=RESET)
   \   0000000C   0x68C1             LDR      R1,[R0, #+12]
   \   0000000E   0x0789             LSLS     R1,R1,#+30
   \   00000010   0xD513             BPL.N    ??HAL_TIM_IRQHandler_0
   2776              {
   2777                {
   2778                  __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC1);
   \   00000012   0xF06F 0x0102      MVN      R1,#+2
   \   00000016   0x6101             STR      R1,[R0, #+16]
   2779                  htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
   \   00000018   0x2101             MOVS     R1,#+1
   \   0000001A   0x7621             STRB     R1,[R4, #+24]
   2780                  
   2781                  /* Input capture event */
   2782                  if((htim->Instance->CCMR1 & TIM_CCMR1_CC1S) != 0x00)
   \   0000001C   0x6980             LDR      R0,[R0, #+24]
   \   0000001E   0xF010 0x0F03      TST      R0,#0x3
   \   00000022   0x4620             MOV      R0,R4
   \   00000024   0xD002             BEQ.N    ??HAL_TIM_IRQHandler_1
   2783                  {
   2784                    HAL_TIM_IC_CaptureCallback(htim);
   \   00000026   0x.... 0x....      BL       HAL_TIM_IC_CaptureCallback
   \   0000002A   0xE004             B.N      ??HAL_TIM_IRQHandler_2
   2785                  }
   2786                  /* Output compare event */
   2787                  else
   2788                  {
   2789                    HAL_TIM_OC_DelayElapsedCallback(htim);
   \                     ??HAL_TIM_IRQHandler_1: (+1)
   \   0000002C   0x.... 0x....      BL       HAL_TIM_OC_DelayElapsedCallback
   2790                    HAL_TIM_PWM_PulseFinishedCallback(htim);
   \   00000030   0x4620             MOV      R0,R4
   \   00000032   0x.... 0x....      BL       HAL_TIM_PWM_PulseFinishedCallback
   2791                  }
   2792                  htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
   \                     ??HAL_TIM_IRQHandler_2: (+1)
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0x7620             STRB     R0,[R4, #+24]
   2793                }
   2794              }
   2795            }
   2796            /* Capture compare 2 event */
   2797            if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC2) != RESET)
   \                     ??HAL_TIM_IRQHandler_0: (+1)
   \   0000003A   0x6820             LDR      R0,[R4, #+0]
   \   0000003C   0x6901             LDR      R1,[R0, #+16]
   \   0000003E   0x0749             LSLS     R1,R1,#+29
   \   00000040   0xD516             BPL.N    ??HAL_TIM_IRQHandler_3
   2798            {
   2799              if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC2) !=RESET)
   \   00000042   0x68C1             LDR      R1,[R0, #+12]
   \   00000044   0x0749             LSLS     R1,R1,#+29
   \   00000046   0xD513             BPL.N    ??HAL_TIM_IRQHandler_3
   2800              {
   2801                __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC2);
   \   00000048   0xF06F 0x0104      MVN      R1,#+4
   \   0000004C   0x6101             STR      R1,[R0, #+16]
   2802                htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
   \   0000004E   0x2102             MOVS     R1,#+2
   \   00000050   0x7621             STRB     R1,[R4, #+24]
   2803                /* Input capture event */
   2804                if((htim->Instance->CCMR1 & TIM_CCMR1_CC2S) != 0x00)
   \   00000052   0x6980             LDR      R0,[R0, #+24]
   \   00000054   0xF410 0x7F40      TST      R0,#0x300
   \   00000058   0x4620             MOV      R0,R4
   \   0000005A   0xD002             BEQ.N    ??HAL_TIM_IRQHandler_4
   2805                {          
   2806                  HAL_TIM_IC_CaptureCallback(htim);
   \   0000005C   0x.... 0x....      BL       HAL_TIM_IC_CaptureCallback
   \   00000060   0xE004             B.N      ??HAL_TIM_IRQHandler_5
   2807                }
   2808                /* Output compare event */
   2809                else
   2810                {
   2811                  HAL_TIM_OC_DelayElapsedCallback(htim);
   \                     ??HAL_TIM_IRQHandler_4: (+1)
   \   00000062   0x.... 0x....      BL       HAL_TIM_OC_DelayElapsedCallback
   2812                  HAL_TIM_PWM_PulseFinishedCallback(htim);
   \   00000066   0x4620             MOV      R0,R4
   \   00000068   0x.... 0x....      BL       HAL_TIM_PWM_PulseFinishedCallback
   2813                }
   2814                htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
   \                     ??HAL_TIM_IRQHandler_5: (+1)
   \   0000006C   0x2000             MOVS     R0,#+0
   \   0000006E   0x7620             STRB     R0,[R4, #+24]
   2815              }
   2816            }
   2817            /* Capture compare 3 event */
   2818            if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC3) != RESET)
   \                     ??HAL_TIM_IRQHandler_3: (+1)
   \   00000070   0x6820             LDR      R0,[R4, #+0]
   \   00000072   0x6901             LDR      R1,[R0, #+16]
   \   00000074   0x0709             LSLS     R1,R1,#+28
   \   00000076   0xD516             BPL.N    ??HAL_TIM_IRQHandler_6
   2819            {
   2820              if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC3) !=RESET)
   \   00000078   0x68C1             LDR      R1,[R0, #+12]
   \   0000007A   0x0709             LSLS     R1,R1,#+28
   \   0000007C   0xD513             BPL.N    ??HAL_TIM_IRQHandler_6
   2821              {
   2822                __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC3);
   \   0000007E   0xF06F 0x0108      MVN      R1,#+8
   \   00000082   0x6101             STR      R1,[R0, #+16]
   2823                htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
   \   00000084   0x2104             MOVS     R1,#+4
   \   00000086   0x7621             STRB     R1,[R4, #+24]
   2824                /* Input capture event */
   2825                if((htim->Instance->CCMR2 & TIM_CCMR2_CC3S) != 0x00)
   \   00000088   0x69C0             LDR      R0,[R0, #+28]
   \   0000008A   0xF010 0x0F03      TST      R0,#0x3
   \   0000008E   0x4620             MOV      R0,R4
   \   00000090   0xD002             BEQ.N    ??HAL_TIM_IRQHandler_7
   2826                {          
   2827                  HAL_TIM_IC_CaptureCallback(htim);
   \   00000092   0x.... 0x....      BL       HAL_TIM_IC_CaptureCallback
   \   00000096   0xE004             B.N      ??HAL_TIM_IRQHandler_8
   2828                }
   2829                /* Output compare event */
   2830                else
   2831                {
   2832                  HAL_TIM_OC_DelayElapsedCallback(htim);
   \                     ??HAL_TIM_IRQHandler_7: (+1)
   \   00000098   0x.... 0x....      BL       HAL_TIM_OC_DelayElapsedCallback
   2833                  HAL_TIM_PWM_PulseFinishedCallback(htim); 
   \   0000009C   0x4620             MOV      R0,R4
   \   0000009E   0x.... 0x....      BL       HAL_TIM_PWM_PulseFinishedCallback
   2834                }
   2835                htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
   \                     ??HAL_TIM_IRQHandler_8: (+1)
   \   000000A2   0x2000             MOVS     R0,#+0
   \   000000A4   0x7620             STRB     R0,[R4, #+24]
   2836              }
   2837            }
   2838            /* Capture compare 4 event */
   2839            if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC4) != RESET)
   \                     ??HAL_TIM_IRQHandler_6: (+1)
   \   000000A6   0x6820             LDR      R0,[R4, #+0]
   \   000000A8   0x6901             LDR      R1,[R0, #+16]
   \   000000AA   0x06C9             LSLS     R1,R1,#+27
   \   000000AC   0xD516             BPL.N    ??HAL_TIM_IRQHandler_9
   2840            {
   2841              if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC4) !=RESET)
   \   000000AE   0x68C1             LDR      R1,[R0, #+12]
   \   000000B0   0x06C9             LSLS     R1,R1,#+27
   \   000000B2   0xD513             BPL.N    ??HAL_TIM_IRQHandler_9
   2842              {
   2843                __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC4);
   \   000000B4   0xF06F 0x0110      MVN      R1,#+16
   \   000000B8   0x6101             STR      R1,[R0, #+16]
   2844                htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
   \   000000BA   0x2108             MOVS     R1,#+8
   \   000000BC   0x7621             STRB     R1,[R4, #+24]
   2845                /* Input capture event */
   2846                if((htim->Instance->CCMR2 & TIM_CCMR2_CC4S) != 0x00)
   \   000000BE   0x69C0             LDR      R0,[R0, #+28]
   \   000000C0   0xF410 0x7F40      TST      R0,#0x300
   \   000000C4   0x4620             MOV      R0,R4
   \   000000C6   0xD002             BEQ.N    ??HAL_TIM_IRQHandler_10
   2847                {          
   2848                  HAL_TIM_IC_CaptureCallback(htim);
   \   000000C8   0x.... 0x....      BL       HAL_TIM_IC_CaptureCallback
   \   000000CC   0xE004             B.N      ??HAL_TIM_IRQHandler_11
   2849                }
   2850                /* Output compare event */
   2851                else
   2852                {
   2853                  HAL_TIM_OC_DelayElapsedCallback(htim);
   \                     ??HAL_TIM_IRQHandler_10: (+1)
   \   000000CE   0x.... 0x....      BL       HAL_TIM_OC_DelayElapsedCallback
   2854                  HAL_TIM_PWM_PulseFinishedCallback(htim);
   \   000000D2   0x4620             MOV      R0,R4
   \   000000D4   0x.... 0x....      BL       HAL_TIM_PWM_PulseFinishedCallback
   2855                }
   2856                htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
   \                     ??HAL_TIM_IRQHandler_11: (+1)
   \   000000D8   0x2000             MOVS     R0,#+0
   \   000000DA   0x7620             STRB     R0,[R4, #+24]
   2857              }
   2858            }
   2859            /* TIM Update event */
   2860            if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_UPDATE) != RESET)
   \                     ??HAL_TIM_IRQHandler_9: (+1)
   \   000000DC   0x6820             LDR      R0,[R4, #+0]
   \   000000DE   0x6901             LDR      R1,[R0, #+16]
   \   000000E0   0x07C9             LSLS     R1,R1,#+31
   \   000000E2   0xD508             BPL.N    ??HAL_TIM_IRQHandler_12
   2861            {
   2862              if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_UPDATE) !=RESET)
   \   000000E4   0x68C1             LDR      R1,[R0, #+12]
   \   000000E6   0x07C9             LSLS     R1,R1,#+31
   \   000000E8   0xD505             BPL.N    ??HAL_TIM_IRQHandler_12
   2863              {
   2864                __HAL_TIM_CLEAR_IT(htim, TIM_IT_UPDATE);
   \   000000EA   0xF06F 0x0101      MVN      R1,#+1
   \   000000EE   0x6101             STR      R1,[R0, #+16]
   2865                HAL_TIM_PeriodElapsedCallback(htim);
   \   000000F0   0x4620             MOV      R0,R4
   \   000000F2   0x.... 0x....      BL       HAL_TIM_PeriodElapsedCallback
   2866              }
   2867            }
   2868            /* TIM Break input event */
   2869            if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_BREAK) != RESET)
   \                     ??HAL_TIM_IRQHandler_12: (+1)
   \   000000F6   0x6820             LDR      R0,[R4, #+0]
   \   000000F8   0xF06F 0x0580      MVN      R5,#+128
   \   000000FC   0x6901             LDR      R1,[R0, #+16]
   \   000000FE   0x0609             LSLS     R1,R1,#+24
   \   00000100   0xD506             BPL.N    ??HAL_TIM_IRQHandler_13
   2870            {
   2871              if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_BREAK) !=RESET)
   \   00000102   0x68C1             LDR      R1,[R0, #+12]
   \   00000104   0x0609             LSLS     R1,R1,#+24
   \   00000106   0xD503             BPL.N    ??HAL_TIM_IRQHandler_13
   2872              {
   2873                __HAL_TIM_CLEAR_IT(htim, TIM_IT_BREAK);
   \   00000108   0x6105             STR      R5,[R0, #+16]
   2874                HAL_TIMEx_BreakCallback(htim);
   \   0000010A   0x4620             MOV      R0,R4
   \   0000010C   0x.... 0x....      BL       HAL_TIMEx_BreakCallback
   2875              }
   2876            }
   2877            
   2878              /* TIM Break input event */
   2879            if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_BREAK2) != RESET)
   \                     ??HAL_TIM_IRQHandler_13: (+1)
   \   00000110   0x6820             LDR      R0,[R4, #+0]
   \   00000112   0x6901             LDR      R1,[R0, #+16]
   \   00000114   0x05C9             LSLS     R1,R1,#+23
   \   00000116   0xD506             BPL.N    ??HAL_TIM_IRQHandler_14
   2880            {
   2881              if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_BREAK) !=RESET)
   \   00000118   0x68C1             LDR      R1,[R0, #+12]
   \   0000011A   0x0609             LSLS     R1,R1,#+24
   \   0000011C   0xD503             BPL.N    ??HAL_TIM_IRQHandler_14
   2882              {
   2883                __HAL_TIM_CLEAR_IT(htim, TIM_IT_BREAK);
   \   0000011E   0x6105             STR      R5,[R0, #+16]
   2884                HAL_TIMEx_BreakCallback(htim);
   \   00000120   0x4620             MOV      R0,R4
   \   00000122   0x.... 0x....      BL       HAL_TIMEx_BreakCallback
   2885              }
   2886            }
   2887          
   2888            /* TIM Trigger detection event */
   2889            if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_TRIGGER) != RESET)
   \                     ??HAL_TIM_IRQHandler_14: (+1)
   \   00000126   0x6820             LDR      R0,[R4, #+0]
   \   00000128   0x6901             LDR      R1,[R0, #+16]
   \   0000012A   0x0649             LSLS     R1,R1,#+25
   \   0000012C   0xD508             BPL.N    ??HAL_TIM_IRQHandler_15
   2890            {
   2891              if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_TRIGGER) !=RESET)
   \   0000012E   0x68C1             LDR      R1,[R0, #+12]
   \   00000130   0x0649             LSLS     R1,R1,#+25
   \   00000132   0xD505             BPL.N    ??HAL_TIM_IRQHandler_15
   2892              {
   2893                __HAL_TIM_CLEAR_IT(htim, TIM_IT_TRIGGER);
   \   00000134   0xF06F 0x0140      MVN      R1,#+64
   \   00000138   0x6101             STR      R1,[R0, #+16]
   2894                HAL_TIM_TriggerCallback(htim);
   \   0000013A   0x4620             MOV      R0,R4
   \   0000013C   0x.... 0x....      BL       HAL_TIM_TriggerCallback
   2895              }
   2896            }
   2897            /* TIM commutation event */
   2898            if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_COM) != RESET)
   \                     ??HAL_TIM_IRQHandler_15: (+1)
   \   00000140   0x6820             LDR      R0,[R4, #+0]
   \   00000142   0x6901             LDR      R1,[R0, #+16]
   \   00000144   0x0689             LSLS     R1,R1,#+26
   \   00000146   0xD50A             BPL.N    ??HAL_TIM_IRQHandler_16
   2899            {
   2900              if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_COM) !=RESET)
   \   00000148   0x68C1             LDR      R1,[R0, #+12]
   \   0000014A   0x0689             LSLS     R1,R1,#+26
   \   0000014C   0xD507             BPL.N    ??HAL_TIM_IRQHandler_16
   2901              {
   2902                __HAL_TIM_CLEAR_IT(htim, TIM_FLAG_COM);
   \   0000014E   0xF06F 0x0120      MVN      R1,#+32
   \   00000152   0x6101             STR      R1,[R0, #+16]
   2903                HAL_TIMEx_CommutationCallback(htim);
   \   00000154   0x4620             MOV      R0,R4
   \   00000156   0xE8BD 0x4032      POP      {R1,R4,R5,LR}
   \   0000015A   0x.... 0x....      B.W      HAL_TIMEx_CommutationCallback
   2904              }
   2905            }
   2906          }
   \                     ??HAL_TIM_IRQHandler_16: (+1)
   \   0000015E   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   2907          
   2908          /**
   2909            * @}
   2910            */
   2911            
   2912          /** @defgroup TIM_Exported_Functions_Group8 Peripheral Control functions
   2913           *  @brief   	Peripheral Control functions 
   2914           *
   2915          @verbatim   
   2916            ==============================================================================
   2917                             ##### Peripheral Control functions #####
   2918            ==============================================================================  
   2919           [..] 
   2920             This section provides functions allowing to:
   2921             (+) Configure The Input Output channels for OC, PWM, IC or One Pulse mode. 
   2922             (+) Configure External Clock source.
   2923             (+) Configure Complementary channels, break features and dead time.
   2924             (+) Configure Master and the Slave synchronization.
   2925             (+) Configure the DMA Burst Mode.
   2926                
   2927          @endverbatim
   2928            * @{
   2929            */
   2930            
   2931          /**
   2932            * @brief  Initializes the TIM Output Compare Channels according to the specified
   2933            *         parameters in the TIM_OC_InitTypeDef.
   2934            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   2935            *                the configuration information for TIM module.
   2936            * @param  sConfig: TIM Output Compare configuration structure
   2937            * @param  Channel: TIM Channels to be enabled.
   2938            *          This parameter can be one of the following values:
   2939            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2940            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2941            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   2942            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected 
   2943            * @retval HAL status
   2944            */

   \                                 In section .text, align 2, keep-with-next
   2945          __weak HAL_StatusTypeDef HAL_TIM_OC_ConfigChannel(TIM_HandleTypeDef *htim, TIM_OC_InitTypeDef* sConfig, uint32_t Channel)
   2946          {
   \                     HAL_TIM_OC_ConfigChannel: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   2947            /* Check the parameters */ 
   2948            assert_param(IS_TIM_CHANNELS(Channel)); 
   2949            assert_param(IS_TIM_OC_MODE(sConfig->OCMode));
   2950            assert_param(IS_TIM_OC_POLARITY(sConfig->OCPolarity));
   2951            assert_param(IS_TIM_OCN_POLARITY(sConfig->OCNPolarity));
   2952            assert_param(IS_TIM_OCNIDLE_STATE(sConfig->OCNIdleState));
   2953            assert_param(IS_TIM_OCIDLE_STATE(sConfig->OCIdleState));
   2954            
   2955            /* Check input state */
   2956            __HAL_LOCK(htim); 
   \   00000002   0xF100 0x0438      ADD      R4,R0,#+56
   \   00000006   0x7823             LDRB     R3,[R4, #+0]
   \   00000008   0x2B01             CMP      R3,#+1
   \   0000000A   0xD101             BNE.N    ??HAL_TIM_OC_ConfigChannel_0
   \   0000000C   0x2002             MOVS     R0,#+2
   \   0000000E   0xBD10             POP      {R4,PC}
   \                     ??HAL_TIM_OC_ConfigChannel_0: (+1)
   \   00000010   0x2301             MOVS     R3,#+1
   \   00000012   0x7023             STRB     R3,[R4, #+0]
   2957            
   2958            htim->State = HAL_TIM_STATE_BUSY;
   \   00000014   0x2302             MOVS     R3,#+2
   \   00000016   0x7063             STRB     R3,[R4, #+1]
   2959            
   2960            switch (Channel)
   \   00000018   0xB14A             CBZ.N    R2,??HAL_TIM_OC_ConfigChannel_1
   \   0000001A   0x2A04             CMP      R2,#+4
   \   0000001C   0xD00B             BEQ.N    ??HAL_TIM_OC_ConfigChannel_2
   \   0000001E   0x2A08             CMP      R2,#+8
   \   00000020   0xD00D             BEQ.N    ??HAL_TIM_OC_ConfigChannel_3
   \   00000022   0x2A0C             CMP      R2,#+12
   \   00000024   0xBF04             ITT      EQ 
   2961            {
   2962              case TIM_CHANNEL_1:
   2963              {
   2964                assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   2965                /* Configure the TIM Channel 1 in Output Compare */
   2966                TIM_OC1_SetConfig(htim->Instance, sConfig);
   2967              }
   2968              break;
   2969              
   2970              case TIM_CHANNEL_2:
   2971              {
   2972                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   2973                /* Configure the TIM Channel 2 in Output Compare */
   2974                TIM_OC2_SetConfig(htim->Instance, sConfig);
   2975              }
   2976              break;
   2977              
   2978              case TIM_CHANNEL_3:
   2979              {
   2980                 assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
   2981                /* Configure the TIM Channel 3 in Output Compare */
   2982                TIM_OC3_SetConfig(htim->Instance, sConfig);
   2983              }
   2984              break;
   2985              
   2986              case TIM_CHANNEL_4:
   2987              {
   2988                assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
   2989                /* Configure the TIM Channel 4 in Output Compare */
   2990                TIM_OC4_SetConfig(htim->Instance, sConfig);
   \   00000026   0x6800             LDREQ    R0,[R0, #+0]
   \   00000028   0x.... 0x....      BLEQ     TIM_OC4_SetConfig
   \   0000002C   0xE00A             B.N      ??HAL_TIM_OC_ConfigChannel_4
   2991              }
   \                     ??HAL_TIM_OC_ConfigChannel_1: (+1)
   \   0000002E   0x6800             LDR      R0,[R0, #+0]
   \   00000030   0x.... 0x....      BL       TIM_OC1_SetConfig
   \   00000034   0xE006             B.N      ??HAL_TIM_OC_ConfigChannel_4
   \                     ??HAL_TIM_OC_ConfigChannel_2: (+1)
   \   00000036   0x6800             LDR      R0,[R0, #+0]
   \   00000038   0x.... 0x....      BL       TIM_OC2_SetConfig
   \   0000003C   0xE002             B.N      ??HAL_TIM_OC_ConfigChannel_4
   \                     ??HAL_TIM_OC_ConfigChannel_3: (+1)
   \   0000003E   0x6800             LDR      R0,[R0, #+0]
   \   00000040   0x.... 0x....      BL       TIM_OC3_SetConfig
   2992              break;
   2993              
   2994              default:
   2995              break;    
   2996            }
   2997            htim->State = HAL_TIM_STATE_READY;
   \                     ??HAL_TIM_OC_ConfigChannel_4: (+1)
   \   00000044   0x2001             MOVS     R0,#+1
   \   00000046   0x7060             STRB     R0,[R4, #+1]
   2998            
   2999            __HAL_UNLOCK(htim); 
   \   00000048   0x.... 0x....      B.W      ?Subroutine5
   3000            
   3001            return HAL_OK;
   3002          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine5: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x7020             STRB     R0,[R4, #+0]
   \   00000004   0xBD10             POP      {R4,PC}          ;; return
   3003          
   3004          /**
   3005            * @brief  Initializes the TIM Input Capture Channels according to the specified
   3006            *         parameters in the TIM_IC_InitTypeDef.
   3007            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   3008            *                the configuration information for TIM module.
   3009            * @param  sConfig: TIM Input Capture configuration structure
   3010            * @param  Channel: TIM Channels to be enabled.
   3011            *          This parameter can be one of the following values:
   3012            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   3013            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   3014            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   3015            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected 
   3016            * @retval HAL status
   3017            */

   \                                 In section .text, align 2, keep-with-next
   3018          HAL_StatusTypeDef HAL_TIM_IC_ConfigChannel(TIM_HandleTypeDef *htim, TIM_IC_InitTypeDef* sConfig, uint32_t Channel)
   3019          {
   \                     HAL_TIM_IC_ConfigChannel: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4605             MOV      R5,R0
   3020            /* Check the parameters */
   3021            assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   3022            assert_param(IS_TIM_IC_POLARITY(sConfig->ICPolarity));
   3023            assert_param(IS_TIM_IC_SELECTION(sConfig->ICSelection));
   3024            assert_param(IS_TIM_IC_PRESCALER(sConfig->ICPrescaler));
   3025            assert_param(IS_TIM_IC_FILTER(sConfig->ICFilter));
   3026            
   3027            __HAL_LOCK(htim);
   \   00000004   0xF105 0x0438      ADD      R4,R5,#+56
   \   00000008   0x460E             MOV      R6,R1
   \   0000000A   0x7820             LDRB     R0,[R4, #+0]
   \   0000000C   0x2801             CMP      R0,#+1
   \   0000000E   0xD101             BNE.N    ??HAL_TIM_IC_ConfigChannel_0
   \   00000010   0x2002             MOVS     R0,#+2
   \   00000012   0xBDF2             POP      {R1,R4-R7,PC}
   \                     ??HAL_TIM_IC_ConfigChannel_0: (+1)
   \   00000014   0x2001             MOVS     R0,#+1
   \   00000016   0x7020             STRB     R0,[R4, #+0]
   3028            
   3029            htim->State = HAL_TIM_STATE_BUSY;
   \   00000018   0x2002             MOVS     R0,#+2
   \   0000001A   0x7060             STRB     R0,[R4, #+1]
   3030            
   3031            if (Channel == TIM_CHANNEL_1)
   \   0000001C   0xB97A             CBNZ.N   R2,??HAL_TIM_IC_ConfigChannel_1
   3032            {
   3033              /* TI1 Configuration */
   3034              TIM_TI1_SetConfig(htim->Instance,
   3035                         sConfig->ICPolarity,
   3036                         sConfig->ICSelection,
   3037                         sConfig->ICFilter);
   \   0000001E   0x68F3             LDR      R3,[R6, #+12]
   \   00000020   0x6872             LDR      R2,[R6, #+4]
   \   00000022   0x6831             LDR      R1,[R6, #+0]
   \   00000024   0x6828             LDR      R0,[R5, #+0]
   \   00000026   0x.... 0x....      BL       TIM_TI1_SetConfig
   3038                         
   3039              /* Reset the IC1PSC Bits */
   3040              htim->Instance->CCMR1 &= ~TIM_CCMR1_IC1PSC;
   \   0000002A   0x6828             LDR      R0,[R5, #+0]
   \   0000002C   0x6981             LDR      R1,[R0, #+24]
   \   0000002E   0xF021 0x010C      BIC      R1,R1,#0xC
   \   00000032   0x6181             STR      R1,[R0, #+24]
   3041          
   3042              /* Set the IC1PSC value */
   3043              htim->Instance->CCMR1 |= sConfig->ICPrescaler;
   \   00000034   0x6828             LDR      R0,[R5, #+0]
   \   00000036   0x6981             LDR      R1,[R0, #+24]
   \   00000038   0x68B2             LDR      R2,[R6, #+8]
   \   0000003A   0x4311             ORRS     R1,R2,R1
   \   0000003C   0xE011             B.N      ??HAL_TIM_IC_ConfigChannel_2
   3044            }
   3045            else if (Channel == TIM_CHANNEL_2)
   \                     ??HAL_TIM_IC_ConfigChannel_1: (+1)
   \   0000003E   0x2A04             CMP      R2,#+4
   \   00000040   0xD111             BNE.N    ??HAL_TIM_IC_ConfigChannel_3
   3046            {
   3047              /* TI2 Configuration */
   3048              assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   3049              
   3050              TIM_TI2_SetConfig(htim->Instance, 
   3051                                sConfig->ICPolarity,
   3052                                sConfig->ICSelection,
   3053                                sConfig->ICFilter);
   \   00000042   0x68F3             LDR      R3,[R6, #+12]
   \   00000044   0x6872             LDR      R2,[R6, #+4]
   \   00000046   0x6831             LDR      R1,[R6, #+0]
   \   00000048   0x6828             LDR      R0,[R5, #+0]
   \   0000004A   0x.... 0x....      BL       TIM_TI2_SetConfig
   3054                         
   3055              /* Reset the IC2PSC Bits */
   3056              htim->Instance->CCMR1 &= ~TIM_CCMR1_IC2PSC;
   \   0000004E   0x6828             LDR      R0,[R5, #+0]
   \   00000050   0x6981             LDR      R1,[R0, #+24]
   \   00000052   0xF421 0x6140      BIC      R1,R1,#0xC00
   \   00000056   0x6181             STR      R1,[R0, #+24]
   3057          
   3058              /* Set the IC2PSC value */
   3059              htim->Instance->CCMR1 |= (sConfig->ICPrescaler << 8);
   \   00000058   0x6828             LDR      R0,[R5, #+0]
   \   0000005A   0x6981             LDR      R1,[R0, #+24]
   \   0000005C   0x68B2             LDR      R2,[R6, #+8]
   \   0000005E   0xEA41 0x2102      ORR      R1,R1,R2, LSL #+8
   \                     ??HAL_TIM_IC_ConfigChannel_2: (+1)
   \   00000062   0x6181             STR      R1,[R0, #+24]
   \   00000064   0xE054             B.N      ??HAL_TIM_IC_ConfigChannel_4
   3060            }
   3061            else if (Channel == TIM_CHANNEL_3)
   \                     ??HAL_TIM_IC_ConfigChannel_3: (+1)
   \   00000066   0x2A08             CMP      R2,#+8
   \   00000068   0x68F1             LDR      R1,[R6, #+12]
   \   0000006A   0xD129             BNE.N    ??HAL_TIM_IC_ConfigChannel_5
   3062            {
   3063              /* TI3 Configuration */
   3064              assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
   3065              
   3066              TIM_TI3_SetConfig(htim->Instance,  
   3067                         sConfig->ICPolarity,
   3068                         sConfig->ICSelection,
   3069                         sConfig->ICFilter);
   \   0000006C   0x682B             LDR      R3,[R5, #+0]
   \   0000006E   0xF8D6 0xC004      LDR      R12,[R6, #+4]
   \   00000072   0x6832             LDR      R2,[R6, #+0]
   \   00000074   0x0109             LSLS     R1,R1,#+4
   \   00000076   0xF001 0x01F0      AND      R1,R1,#0xF0
   \   0000007A   0x6A18             LDR      R0,[R3, #+32]
   \   0000007C   0xF420 0x7080      BIC      R0,R0,#0x100
   \   00000080   0x6218             STR      R0,[R3, #+32]
   \   00000082   0xF103 0x001C      ADD      R0,R3,#+28
   \   00000086   0xF8D0 0xE000      LDR      LR,[R0, #+0]
   \   0000008A   0x6A1F             LDR      R7,[R3, #+32]
   \   0000008C   0xEA4F 0x0E9E      LSR      LR,LR,#+2
   \   00000090   0xEA4C 0x0C8E      ORR      R12,R12,LR, LSL #+2
   \   00000094   0xF02C 0x0CF0      BIC      R12,R12,#0xF0
   \   00000098   0xEA41 0x010C      ORR      R1,R1,R12
   \   0000009C   0x6001             STR      R1,[R0, #+0]
   \   0000009E   0x0211             LSLS     R1,R2,#+8
   \   000000A0   0xF427 0x6020      BIC      R0,R7,#0xA00
   \   000000A4   0xF401 0x6120      AND      R1,R1,#0xA00
   \   000000A8   0x4308             ORRS     R0,R1,R0
   \   000000AA   0x6218             STR      R0,[R3, #+32]
   3070                         
   3071              /* Reset the IC3PSC Bits */
   3072              htim->Instance->CCMR2 &= ~TIM_CCMR2_IC3PSC;
   \   000000AC   0x6828             LDR      R0,[R5, #+0]
   \   000000AE   0x69C1             LDR      R1,[R0, #+28]
   \   000000B0   0xF021 0x010C      BIC      R1,R1,#0xC
   \   000000B4   0x61C1             STR      R1,[R0, #+28]
   3073          
   3074              /* Set the IC3PSC value */
   3075              htim->Instance->CCMR2 |= sConfig->ICPrescaler;
   \   000000B6   0x6828             LDR      R0,[R5, #+0]
   \   000000B8   0x69C1             LDR      R1,[R0, #+28]
   \   000000BA   0x68B2             LDR      R2,[R6, #+8]
   \   000000BC   0x4311             ORRS     R1,R2,R1
   \   000000BE   0xE026             B.N      ??HAL_TIM_IC_ConfigChannel_6
   3076            }
   3077            else
   3078            {
   3079              /* TI4 Configuration */
   3080              assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
   3081              
   3082              TIM_TI4_SetConfig(htim->Instance, 
   3083                         sConfig->ICPolarity,
   3084                         sConfig->ICSelection,
   3085                         sConfig->ICFilter);
   \                     ??HAL_TIM_IC_ConfigChannel_5: (+1)
   \   000000C0   0x6828             LDR      R0,[R5, #+0]
   \   000000C2   0x6877             LDR      R7,[R6, #+4]
   \   000000C4   0x6832             LDR      R2,[R6, #+0]
   \   000000C6   0x0309             LSLS     R1,R1,#+12
   \   000000C8   0x301C             ADDS     R0,R0,#+28
   \   000000CA   0xF401 0x4170      AND      R1,R1,#0xF000
   \   000000CE   0x0312             LSLS     R2,R2,#+12
   \   000000D0   0xF402 0x4220      AND      R2,R2,#0xA000
   \   000000D4   0x6843             LDR      R3,[R0, #+4]
   \   000000D6   0xF423 0x5380      BIC      R3,R3,#0x1000
   \   000000DA   0x6043             STR      R3,[R0, #+4]
   \   000000DC   0xF8D0 0xC000      LDR      R12,[R0, #+0]
   \   000000E0   0x6843             LDR      R3,[R0, #+4]
   \   000000E2   0xF42C 0x7C40      BIC      R12,R12,#0x300
   \   000000E6   0xEA4C 0x2707      ORR      R7,R12,R7, LSL #+8
   \   000000EA   0xF427 0x4770      BIC      R7,R7,#0xF000
   \   000000EE   0x4339             ORRS     R1,R1,R7
   \   000000F0   0x6001             STR      R1,[R0, #+0]
   \   000000F2   0xF423 0x4120      BIC      R1,R3,#0xA000
   \   000000F6   0x4311             ORRS     R1,R2,R1
   \   000000F8   0x6041             STR      R1,[R0, #+4]
   3086                         
   3087              /* Reset the IC4PSC Bits */
   3088              htim->Instance->CCMR2 &= ~TIM_CCMR2_IC4PSC;
   \   000000FA   0x6828             LDR      R0,[R5, #+0]
   \   000000FC   0x69C1             LDR      R1,[R0, #+28]
   \   000000FE   0xF421 0x6140      BIC      R1,R1,#0xC00
   \   00000102   0x61C1             STR      R1,[R0, #+28]
   3089          
   3090              /* Set the IC4PSC value */
   3091              htim->Instance->CCMR2 |= (sConfig->ICPrescaler << 8);
   \   00000104   0x6828             LDR      R0,[R5, #+0]
   \   00000106   0x69C1             LDR      R1,[R0, #+28]
   \   00000108   0x68B2             LDR      R2,[R6, #+8]
   \   0000010A   0xEA41 0x2102      ORR      R1,R1,R2, LSL #+8
   \                     ??HAL_TIM_IC_ConfigChannel_6: (+1)
   \   0000010E   0x61C1             STR      R1,[R0, #+28]
   3092            }
   3093            
   3094            htim->State = HAL_TIM_STATE_READY;
   \                     ??HAL_TIM_IC_ConfigChannel_4: (+1)
   \   00000110   0x.... 0x....      BL       ?Subroutine14
   3095              
   3096            __HAL_UNLOCK(htim);
   3097            
   3098            return HAL_OK; 
   \                     ??CrossCallReturnLabel_16: (+1)
   \   00000114   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   3099          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine14: (+1)
   \   00000000   0x2001             MOVS     R0,#+1
   \   00000002   0x7060             STRB     R0,[R4, #+1]
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x7020             STRB     R0,[R4, #+0]
   \   00000008   0x4770             BX       LR
   3100          
   3101          /**
   3102            * @brief  Initializes the TIM PWM  channels according to the specified
   3103            *         parameters in the TIM_OC_InitTypeDef.
   3104            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   3105            *                the configuration information for TIM module.
   3106            * @param  sConfig: TIM PWM configuration structure
   3107            * @param  Channel: TIM Channels to be enabled.
   3108            *          This parameter can be one of the following values:
   3109            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   3110            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   3111            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   3112            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   3113            * @retval HAL status
   3114            */

   \                                 In section .text, align 2, keep-with-next
   3115          __weak HAL_StatusTypeDef HAL_TIM_PWM_ConfigChannel(TIM_HandleTypeDef *htim, TIM_OC_InitTypeDef* sConfig, uint32_t Channel)
   3116          {
   \                     HAL_TIM_PWM_ConfigChannel: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4606             MOV      R6,R0
   3117            __HAL_LOCK(htim);
   \   00000004   0xF106 0x0438      ADD      R4,R6,#+56
   \   00000008   0x460D             MOV      R5,R1
   \   0000000A   0x7820             LDRB     R0,[R4, #+0]
   \   0000000C   0x2801             CMP      R0,#+1
   \   0000000E   0xD101             BNE.N    ??HAL_TIM_PWM_ConfigChannel_0
   \   00000010   0x2002             MOVS     R0,#+2
   \   00000012   0xBD70             POP      {R4-R6,PC}
   \                     ??HAL_TIM_PWM_ConfigChannel_0: (+1)
   \   00000014   0x2001             MOVS     R0,#+1
   \   00000016   0x7020             STRB     R0,[R4, #+0]
   3118            
   3119            /* Check the parameters */ 
   3120            assert_param(IS_TIM_CHANNELS(Channel)); 
   3121            assert_param(IS_TIM_PWM_MODE(sConfig->OCMode));
   3122            assert_param(IS_TIM_OC_POLARITY(sConfig->OCPolarity));
   3123            assert_param(IS_TIM_OCN_POLARITY(sConfig->OCNPolarity));
   3124            assert_param(IS_TIM_OCNIDLE_STATE(sConfig->OCNIdleState));
   3125            assert_param(IS_TIM_OCIDLE_STATE(sConfig->OCIdleState));
   3126            assert_param(IS_TIM_FAST_STATE(sConfig->OCFastMode)); 
   3127            
   3128            htim->State = HAL_TIM_STATE_BUSY;
   \   00000018   0x2002             MOVS     R0,#+2
   \   0000001A   0x7060             STRB     R0,[R4, #+1]
   3129              
   3130            switch (Channel)
   \   0000001C   0xB132             CBZ.N    R2,??HAL_TIM_PWM_ConfigChannel_1
   \   0000001E   0x2A04             CMP      R2,#+4
   \   00000020   0xD014             BEQ.N    ??HAL_TIM_PWM_ConfigChannel_2
   \   00000022   0x2A08             CMP      R2,#+8
   \   00000024   0xD024             BEQ.N    ??HAL_TIM_PWM_ConfigChannel_3
   \   00000026   0x2A0C             CMP      R2,#+12
   \   00000028   0xD032             BEQ.N    ??HAL_TIM_PWM_ConfigChannel_4
   \   0000002A   0xE042             B.N      ??HAL_TIM_PWM_ConfigChannel_5
   3131            {
   3132              case TIM_CHANNEL_1:
   3133              {
   3134                assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   3135                /* Configure the Channel 1 in PWM mode */
   3136                TIM_OC1_SetConfig(htim->Instance, sConfig);
   \                     ??HAL_TIM_PWM_ConfigChannel_1: (+1)
   \   0000002C   0x6830             LDR      R0,[R6, #+0]
   \   0000002E   0x.... 0x....      BL       TIM_OC1_SetConfig
   3137                
   3138                /* Set the Preload enable bit for channel1 */
   3139                htim->Instance->CCMR1 |= TIM_CCMR1_OC1PE;
   \   00000032   0x6830             LDR      R0,[R6, #+0]
   \   00000034   0x6981             LDR      R1,[R0, #+24]
   \   00000036   0xF041 0x0108      ORR      R1,R1,#0x8
   \   0000003A   0x.... 0x....      BL       ?Subroutine64
   3140                
   3141                /* Configure the Output Fast mode */
   3142                htim->Instance->CCMR1 &= ~TIM_CCMR1_OC1FE;
   3143                htim->Instance->CCMR1 |= sConfig->OCFastMode;
   3144              }
   \                     ??CrossCallReturnLabel_203: (+1)
   \   0000003E   0xF021 0x0104      BIC      R1,R1,#0x4
   \   00000042   0x.... 0x....      BL       ?Subroutine64
   \                     ??CrossCallReturnLabel_204: (+1)
   \   00000046   0x692A             LDR      R2,[R5, #+16]
   \   00000048   0x4311             ORRS     R1,R2,R1
   \   0000004A   0xE00F             B.N      ??HAL_TIM_PWM_ConfigChannel_6
   3145              break;
   3146              
   3147              case TIM_CHANNEL_2:
   3148              {
   3149                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   3150                /* Configure the Channel 2 in PWM mode */
   3151                TIM_OC2_SetConfig(htim->Instance, sConfig);
   \                     ??HAL_TIM_PWM_ConfigChannel_2: (+1)
   \   0000004C   0x6830             LDR      R0,[R6, #+0]
   \   0000004E   0x.... 0x....      BL       TIM_OC2_SetConfig
   3152                
   3153                /* Set the Preload enable bit for channel2 */
   3154                htim->Instance->CCMR1 |= TIM_CCMR1_OC2PE;
   \   00000052   0x6830             LDR      R0,[R6, #+0]
   \   00000054   0x6981             LDR      R1,[R0, #+24]
   \   00000056   0xF441 0x6100      ORR      R1,R1,#0x800
   \   0000005A   0x.... 0x....      BL       ?Subroutine64
   3155                
   3156                /* Configure the Output Fast mode */
   3157                htim->Instance->CCMR1 &= ~TIM_CCMR1_OC2FE;
   3158                htim->Instance->CCMR1 |= sConfig->OCFastMode << 8;
   3159              }
   \                     ??CrossCallReturnLabel_205: (+1)
   \   0000005E   0xF421 0x6180      BIC      R1,R1,#0x400
   \   00000062   0x.... 0x....      BL       ?Subroutine64
   \                     ??CrossCallReturnLabel_206: (+1)
   \   00000066   0x692A             LDR      R2,[R5, #+16]
   \   00000068   0xEA41 0x2102      ORR      R1,R1,R2, LSL #+8
   \                     ??HAL_TIM_PWM_ConfigChannel_6: (+1)
   \   0000006C   0x6181             STR      R1,[R0, #+24]
   3160              break;
   \   0000006E   0xE020             B.N      ??HAL_TIM_PWM_ConfigChannel_5
   3161              
   3162              case TIM_CHANNEL_3:
   3163              {
   3164                assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
   3165                /* Configure the Channel 3 in PWM mode */
   3166                TIM_OC3_SetConfig(htim->Instance, sConfig);
   \                     ??HAL_TIM_PWM_ConfigChannel_3: (+1)
   \   00000070   0x6830             LDR      R0,[R6, #+0]
   \   00000072   0x.... 0x....      BL       TIM_OC3_SetConfig
   3167                
   3168                /* Set the Preload enable bit for channel3 */
   3169                htim->Instance->CCMR2 |= TIM_CCMR2_OC3PE;
   \   00000076   0x6830             LDR      R0,[R6, #+0]
   \   00000078   0x69C1             LDR      R1,[R0, #+28]
   \   0000007A   0xF041 0x0108      ORR      R1,R1,#0x8
   \   0000007E   0x.... 0x....      BL       ?Subroutine65
   3170                
   3171               /* Configure the Output Fast mode */
   3172                htim->Instance->CCMR2 &= ~TIM_CCMR2_OC3FE;
   3173                htim->Instance->CCMR2 |= sConfig->OCFastMode;  
   3174              }
   \                     ??CrossCallReturnLabel_207: (+1)
   \   00000082   0xF021 0x0104      BIC      R1,R1,#0x4
   \   00000086   0x.... 0x....      BL       ?Subroutine65
   \                     ??CrossCallReturnLabel_208: (+1)
   \   0000008A   0x692A             LDR      R2,[R5, #+16]
   \   0000008C   0x4311             ORRS     R1,R2,R1
   \   0000008E   0xE00F             B.N      ??HAL_TIM_PWM_ConfigChannel_7
   3175              break;
   3176              
   3177              case TIM_CHANNEL_4:
   3178              {
   3179                assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
   3180                /* Configure the Channel 4 in PWM mode */
   3181                TIM_OC4_SetConfig(htim->Instance, sConfig);
   \                     ??HAL_TIM_PWM_ConfigChannel_4: (+1)
   \   00000090   0x6830             LDR      R0,[R6, #+0]
   \   00000092   0x.... 0x....      BL       TIM_OC4_SetConfig
   3182                
   3183                /* Set the Preload enable bit for channel4 */
   3184                htim->Instance->CCMR2 |= TIM_CCMR2_OC4PE;
   \   00000096   0x6830             LDR      R0,[R6, #+0]
   \   00000098   0x69C1             LDR      R1,[R0, #+28]
   \   0000009A   0xF441 0x6100      ORR      R1,R1,#0x800
   \   0000009E   0x.... 0x....      BL       ?Subroutine65
   3185                
   3186               /* Configure the Output Fast mode */
   3187                htim->Instance->CCMR2 &= ~TIM_CCMR2_OC4FE;
   3188                htim->Instance->CCMR2 |= sConfig->OCFastMode << 8;  
   3189              }
   \                     ??CrossCallReturnLabel_209: (+1)
   \   000000A2   0xF421 0x6180      BIC      R1,R1,#0x400
   \   000000A6   0x.... 0x....      BL       ?Subroutine65
   \                     ??CrossCallReturnLabel_210: (+1)
   \   000000AA   0x692A             LDR      R2,[R5, #+16]
   \   000000AC   0xEA41 0x2102      ORR      R1,R1,R2, LSL #+8
   \                     ??HAL_TIM_PWM_ConfigChannel_7: (+1)
   \   000000B0   0x61C1             STR      R1,[R0, #+28]
   3190              break;
   3191              
   3192              default:
   3193              break;    
   3194            }
   3195            
   3196            htim->State = HAL_TIM_STATE_READY;
   \                     ??HAL_TIM_PWM_ConfigChannel_5: (+1)
   \   000000B2   0x.... 0x....      BL       ?Subroutine14
   3197              
   3198            __HAL_UNLOCK(htim);
   3199            
   3200            return HAL_OK;
   \                     ??CrossCallReturnLabel_17: (+1)
   \   000000B6   0xBD70             POP      {R4-R6,PC}       ;; return
   3201          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine65: (+1)
   \   00000000   0x61C1             STR      R1,[R0, #+28]
   \   00000002   0x6830             LDR      R0,[R6, #+0]
   \   00000004   0x69C1             LDR      R1,[R0, #+28]
   \   00000006   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine64: (+1)
   \   00000000   0x6181             STR      R1,[R0, #+24]
   \   00000002   0x6830             LDR      R0,[R6, #+0]
   \   00000004   0x6981             LDR      R1,[R0, #+24]
   \   00000006   0x4770             BX       LR
   3202          
   3203          /**
   3204            * @brief  Initializes the TIM One Pulse Channels according to the specified
   3205            *         parameters in the TIM_OnePulse_InitTypeDef.
   3206            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   3207            *                the configuration information for TIM module.
   3208            * @param  sConfig: TIM One Pulse configuration structure
   3209            * @param  OutputChannel: TIM Channels to be enabled.
   3210            *          This parameter can be one of the following values:
   3211            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   3212            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   3213            * @param  InputChannel: TIM Channels to be enabled.
   3214            *          This parameter can be one of the following values:
   3215            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   3216            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   3217            * @retval HAL status
   3218            */

   \                                 In section .text, align 2, keep-with-next
   3219          HAL_StatusTypeDef HAL_TIM_OnePulse_ConfigChannel(TIM_HandleTypeDef *htim,  TIM_OnePulse_InitTypeDef* sConfig, uint32_t OutputChannel,  uint32_t InputChannel)
   3220          {
   \                     HAL_TIM_OnePulse_ConfigChannel: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x461E             MOV      R6,R3
   3221            TIM_OC_InitTypeDef temp1;
   3222            
   3223            /* Check the parameters */
   3224            assert_param(IS_TIM_OPM_CHANNELS(OutputChannel));
   3225            assert_param(IS_TIM_OPM_CHANNELS(InputChannel));
   3226          
   3227            if(OutputChannel != InputChannel)  
   \   00000006   0x42B2             CMP      R2,R6
   \   00000008   0xB088             SUB      SP,SP,#+32
   \   0000000A   0x4604             MOV      R4,R0
   \   0000000C   0x460D             MOV      R5,R1
   \   0000000E   0xD055             BEQ.N    ??HAL_TIM_OnePulse_ConfigChannel_0
   3228            {
   3229              __HAL_LOCK(htim);
   \   00000010   0xF104 0x0738      ADD      R7,R4,#+56
   \   00000014   0x7838             LDRB     R0,[R7, #+0]
   \   00000016   0x2801             CMP      R0,#+1
   \   00000018   0xBF08             IT       EQ 
   \   0000001A   0x2002             MOVEQ    R0,#+2
   \   0000001C   0xD04F             BEQ.N    ??HAL_TIM_OnePulse_ConfigChannel_1
   \   0000001E   0x2001             MOVS     R0,#+1
   \   00000020   0x7038             STRB     R0,[R7, #+0]
   3230            
   3231              htim->State = HAL_TIM_STATE_BUSY;
   \   00000022   0x2002             MOVS     R0,#+2
   \   00000024   0x7078             STRB     R0,[R7, #+1]
   3232          
   3233              /* Extract the Output compare configuration from sConfig structure */  
   3234              temp1.OCMode = sConfig->OCMode;
   \   00000026   0x6828             LDR      R0,[R5, #+0]
   \   00000028   0x9000             STR      R0,[SP, #+0]
   3235              temp1.Pulse = sConfig->Pulse;
   \   0000002A   0x6868             LDR      R0,[R5, #+4]
   \   0000002C   0x9001             STR      R0,[SP, #+4]
   3236              temp1.OCPolarity = sConfig->OCPolarity;
   \   0000002E   0x68A8             LDR      R0,[R5, #+8]
   \   00000030   0x9002             STR      R0,[SP, #+8]
   3237              temp1.OCNPolarity = sConfig->OCNPolarity;
   \   00000032   0x68E8             LDR      R0,[R5, #+12]
   \   00000034   0x9003             STR      R0,[SP, #+12]
   3238              temp1.OCIdleState = sConfig->OCIdleState;
   \   00000036   0x6928             LDR      R0,[R5, #+16]
   \   00000038   0x9005             STR      R0,[SP, #+20]
   3239              temp1.OCNIdleState = sConfig->OCNIdleState; 
   \   0000003A   0x6968             LDR      R0,[R5, #+20]
   \   0000003C   0x9006             STR      R0,[SP, #+24]
   3240              
   3241              switch (OutputChannel)
   \   0000003E   0xB132             CBZ.N    R2,??HAL_TIM_OnePulse_ConfigChannel_2
   \   00000040   0x2A04             CMP      R2,#+4
   \   00000042   0xBF02             ITTT     EQ 
   3242              {
   3243                case TIM_CHANNEL_1:
   3244                {
   3245                  assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   3246                
   3247                  TIM_OC1_SetConfig(htim->Instance, &temp1); 
   3248                }
   3249                break;
   3250                case TIM_CHANNEL_2:
   3251                {
   3252                  assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   3253                
   3254                  TIM_OC2_SetConfig(htim->Instance, &temp1);
   \   00000044   0x4669             MOVEQ    R1,SP
   \   00000046   0x6820             LDREQ    R0,[R4, #+0]
   \   00000048   0x.... 0x....      BLEQ     TIM_OC2_SetConfig
   \   0000004C   0xE003             B.N      ??HAL_TIM_OnePulse_ConfigChannel_3
   3255                }
   \                     ??HAL_TIM_OnePulse_ConfigChannel_2: (+1)
   \   0000004E   0x6820             LDR      R0,[R4, #+0]
   \   00000050   0x4669             MOV      R1,SP
   \   00000052   0x.... 0x....      BL       TIM_OC1_SetConfig
   3256                break;
   3257                default:
   3258                break;  
   3259              } 
   3260              switch (InputChannel)
   \                     ??HAL_TIM_OnePulse_ConfigChannel_3: (+1)
   \   00000056   0x.... 0x....      LDR.W    R8,??DataTable22  ;; 0xfffefff8
   \   0000005A   0xB116             CBZ.N    R6,??HAL_TIM_OnePulse_ConfigChannel_4
   \   0000005C   0x2E04             CMP      R6,#+4
   \   0000005E   0xD00F             BEQ.N    ??HAL_TIM_OnePulse_ConfigChannel_5
   \   00000060   0xE027             B.N      ??HAL_TIM_OnePulse_ConfigChannel_6
   3261              {
   3262                case TIM_CHANNEL_1:
   3263                {
   3264                  assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   3265                
   3266                  TIM_TI1_SetConfig(htim->Instance, sConfig->ICPolarity,
   3267                                  sConfig->ICSelection, sConfig->ICFilter);
   \                     ??HAL_TIM_OnePulse_ConfigChannel_4: (+1)
   \   00000062   0x6A2B             LDR      R3,[R5, #+32]
   \   00000064   0x69EA             LDR      R2,[R5, #+28]
   \   00000066   0x69A9             LDR      R1,[R5, #+24]
   \   00000068   0x6820             LDR      R0,[R4, #+0]
   \   0000006A   0x.... 0x....      BL       TIM_TI1_SetConfig
   3268                         
   3269                  /* Reset the IC1PSC Bits */
   3270                  htim->Instance->CCMR1 &= ~TIM_CCMR1_IC1PSC;
   \   0000006E   0x6820             LDR      R0,[R4, #+0]
   \   00000070   0x6981             LDR      R1,[R0, #+24]
   \   00000072   0xF021 0x010C      BIC      R1,R1,#0xC
   \   00000076   0x.... 0x....      BL       ?Subroutine30
   3271          
   3272                  /* Select the Trigger source */
   3273                  htim->Instance->SMCR &= ~TIM_SMCR_TS;
   3274                  htim->Instance->SMCR |= TIM_TS_TI1FP1;
   3275                
   3276                  /* Select the Slave Mode */      
   3277                  htim->Instance->SMCR &= ~TIM_SMCR_SMS;
   3278                  htim->Instance->SMCR |= TIM_SLAVEMODE_TRIGGER;
   3279                }
   \                     ??CrossCallReturnLabel_106: (+1)
   \   0000007A   0xF041 0x0150      ORR      R1,R1,#0x50
   \   0000007E   0xE00D             B.N      ??HAL_TIM_OnePulse_ConfigChannel_7
   3280                break;
   3281                case TIM_CHANNEL_2:
   3282                {
   3283                  assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   3284                
   3285                  TIM_TI2_SetConfig(htim->Instance, sConfig->ICPolarity,
   3286                           sConfig->ICSelection, sConfig->ICFilter);
   \                     ??HAL_TIM_OnePulse_ConfigChannel_5: (+1)
   \   00000080   0x6A2B             LDR      R3,[R5, #+32]
   \   00000082   0x69EA             LDR      R2,[R5, #+28]
   \   00000084   0x69A9             LDR      R1,[R5, #+24]
   \   00000086   0x6820             LDR      R0,[R4, #+0]
   \   00000088   0x.... 0x....      BL       TIM_TI2_SetConfig
   3287                         
   3288                  /* Reset the IC2PSC Bits */
   3289                  htim->Instance->CCMR1 &= ~TIM_CCMR1_IC2PSC;
   \   0000008C   0x6820             LDR      R0,[R4, #+0]
   \   0000008E   0x6981             LDR      R1,[R0, #+24]
   \   00000090   0xF421 0x6140      BIC      R1,R1,#0xC00
   \   00000094   0x.... 0x....      BL       ?Subroutine30
   3290          
   3291                  /* Select the Trigger source */
   3292                  htim->Instance->SMCR &= ~TIM_SMCR_TS;
   3293                  htim->Instance->SMCR |= TIM_TS_TI2FP2;
   \                     ??CrossCallReturnLabel_107: (+1)
   \   00000098   0xF041 0x0160      ORR      R1,R1,#0x60
   \                     ??HAL_TIM_OnePulse_ConfigChannel_7: (+1)
   \   0000009C   0x6081             STR      R1,[R0, #+8]
   3294                
   3295                  /* Select the Slave Mode */      
   3296                  htim->Instance->SMCR &= ~TIM_SMCR_SMS;
   \   0000009E   0x6820             LDR      R0,[R4, #+0]
   \   000000A0   0x6881             LDR      R1,[R0, #+8]
   \   000000A2   0xEA08 0x0101      AND      R1,R8,R1
   \   000000A6   0x6081             STR      R1,[R0, #+8]
   3297                  htim->Instance->SMCR |= TIM_SLAVEMODE_TRIGGER;
   \   000000A8   0x6820             LDR      R0,[R4, #+0]
   \   000000AA   0x6881             LDR      R1,[R0, #+8]
   \   000000AC   0xF041 0x0106      ORR      R1,R1,#0x6
   \   000000B0   0x6081             STR      R1,[R0, #+8]
   3298                }
   3299                break;
   3300              
   3301                default:
   3302                break;  
   3303              }
   3304            
   3305              htim->State = HAL_TIM_STATE_READY;
   \                     ??HAL_TIM_OnePulse_ConfigChannel_6: (+1)
   \   000000B2   0x2001             MOVS     R0,#+1
   \   000000B4   0x7078             STRB     R0,[R7, #+1]
   3306              
   3307              __HAL_UNLOCK(htim);
   \   000000B6   0x2000             MOVS     R0,#+0
   \   000000B8   0x7038             STRB     R0,[R7, #+0]
   3308            
   3309              return HAL_OK;
   \   000000BA   0xE000             B.N      ??HAL_TIM_OnePulse_ConfigChannel_1
   3310            }
   3311            else
   3312            {
   3313              return HAL_ERROR;
   \                     ??HAL_TIM_OnePulse_ConfigChannel_0: (+1)
   \   000000BC   0x2001             MOVS     R0,#+1
   \                     ??HAL_TIM_OnePulse_ConfigChannel_1: (+1)
   \   000000BE   0xB008             ADD      SP,SP,#+32
   \   000000C0   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   3314            }
   3315          } 

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine30: (+1)
   \   00000000   0x6181             STR      R1,[R0, #+24]
   \   00000002   0x6820             LDR      R0,[R4, #+0]
   \   00000004   0x6881             LDR      R1,[R0, #+8]
   \   00000006   0xF021 0x0170      BIC      R1,R1,#0x70
   \   0000000A   0x6081             STR      R1,[R0, #+8]
   \   0000000C   0x6820             LDR      R0,[R4, #+0]
   \   0000000E   0x6881             LDR      R1,[R0, #+8]
   \   00000010   0x4770             BX       LR
   3316          
   3317          /**
   3318            * @brief  Configure the DMA Burst to transfer Data from the memory to the TIM peripheral  
   3319            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   3320            *                the configuration information for TIM module.
   3321            * @param  BurstBaseAddress: TIM Base address from when the DMA will starts the Data write.
   3322            *         This parameters can be on of the following values:
   3323            *            @arg TIM_DMABASE_CR1  
   3324            *            @arg TIM_DMABASE_CR2
   3325            *            @arg TIM_DMABASE_SMCR
   3326            *            @arg TIM_DMABASE_DIER
   3327            *            @arg TIM_DMABASE_SR
   3328            *            @arg TIM_DMABASE_EGR
   3329            *            @arg TIM_DMABASE_CCMR1
   3330            *            @arg TIM_DMABASE_CCMR2
   3331            *            @arg TIM_DMABASE_CCER
   3332            *            @arg TIM_DMABASE_CNT   
   3333            *            @arg TIM_DMABASE_PSC   
   3334            *            @arg TIM_DMABASE_ARR
   3335            *            @arg TIM_DMABASE_RCR
   3336            *            @arg TIM_DMABASE_CCR1
   3337            *            @arg TIM_DMABASE_CCR2
   3338            *            @arg TIM_DMABASE_CCR3  
   3339            *            @arg TIM_DMABASE_CCR4
   3340            *            @arg TIM_DMABASE_BDTR
   3341            *            @arg TIM_DMABASE_DCR
   3342            * @param  BurstRequestSrc: TIM DMA Request sources.
   3343            *         This parameters can be on of the following values:
   3344            *            @arg TIM_DMA_UPDATE: TIM update Interrupt source
   3345            *            @arg TIM_DMA_CC1: TIM Capture Compare 1 DMA source
   3346            *            @arg TIM_DMA_CC2: TIM Capture Compare 2 DMA source
   3347            *            @arg TIM_DMA_CC3: TIM Capture Compare 3 DMA source
   3348            *            @arg TIM_DMA_CC4: TIM Capture Compare 4 DMA source
   3349            *            @arg TIM_DMA_COM: TIM Commutation DMA source
   3350            *            @arg TIM_DMA_TRIGGER: TIM Trigger DMA source
   3351            * @param  BurstBuffer: The Buffer address.
   3352            * @param  BurstLength: DMA Burst length. This parameter can be one value
   3353            *         between TIM_DMABURSTLENGTH_1TRANSFER and TIM_DMABURSTLENGTH_18TRANSFERS.
   3354            * @retval HAL status
   3355            */

   \                                 In section .text, align 2, keep-with-next
   3356          HAL_StatusTypeDef HAL_TIM_DMABurst_WriteStart(TIM_HandleTypeDef *htim, uint32_t BurstBaseAddress, uint32_t BurstRequestSrc,
   3357                                                        uint32_t* BurstBuffer, uint32_t  BurstLength)
   3358          {
   \                     HAL_TIM_DMABurst_WriteStart: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460E             MOV      R6,R1
   \   00000006   0x4615             MOV      R5,R2
   \   00000008   0x4619             MOV      R1,R3
   3359            /* Check the parameters */
   3360            assert_param(IS_TIM_DMABURST_INSTANCE(htim->Instance));
   3361            assert_param(IS_TIM_DMA_BASE(BurstBaseAddress));
   3362            assert_param(IS_TIM_DMA_SOURCE(BurstRequestSrc));
   3363            assert_param(IS_TIM_DMA_LENGTH(BurstLength));
   3364            
   3365            if((htim->State == HAL_TIM_STATE_BUSY))
   \   0000000A   0x.... 0x....      BL       ??Subroutine15_0
   \                     ??CrossCallReturnLabel_23: (+1)
   \   0000000E   0xD06B             BEQ.N    ??CrossCallReturnLabel_90
   \   00000010   0x.... 0x....      BL       ?Subroutine16
   3366            {
   3367               return HAL_BUSY;
   3368            }
   3369            else if((htim->State == HAL_TIM_STATE_READY))
   \                     ??CrossCallReturnLabel_25: (+1)
   \   00000014   0xD104             BNE.N    ??CrossCallReturnLabel_35
   3370            {
   3371              if((BurstBuffer == 0 ) && (BurstLength > 0)) 
   \   00000016   0xB909             CBNZ.N   R1,??HAL_TIM_DMABurst_WriteStart_0
   \   00000018   0x2F00             CMP      R7,#+0
   \   0000001A   0xD165             BNE.N    ??CrossCallReturnLabel_90
   3372              {
   3373                return HAL_ERROR;                                    
   3374              }
   3375              else
   3376              {
   3377                htim->State = HAL_TIM_STATE_BUSY;
   \                     ??HAL_TIM_DMABurst_WriteStart_0: (+1)
   \   0000001C   0x.... 0x....      BL       ?Subroutine17
   3378              }
   3379            }
   3380            switch(BurstRequestSrc)
   \                     ??CrossCallReturnLabel_35: (+1)
   \   00000020   0x0A38             LSRS     R0,R7,#+8
   \   00000022   0x1C43             ADDS     R3,R0,#+1
   \   00000024   0xF5B5 0x7F80      CMP      R5,#+256
   \   00000028   0x.... 0x....      ADR.W    R2,TIM_DMADelayPulseCplt
   \   0000002C   0x.... 0x....      ADR.W    R0,TIM_DMAError
   \   00000030   0xD012             BEQ.N    ??HAL_TIM_DMABurst_WriteStart_1
   \   00000032   0xF5B5 0x7F00      CMP      R5,#+512
   \   00000036   0xD01A             BEQ.N    ??HAL_TIM_DMABurst_WriteStart_2
   \   00000038   0xF5B5 0x6F80      CMP      R5,#+1024
   \   0000003C   0xD020             BEQ.N    ??HAL_TIM_DMABurst_WriteStart_3
   \   0000003E   0xF5B5 0x6F00      CMP      R5,#+2048
   \   00000042   0xD026             BEQ.N    ??HAL_TIM_DMABurst_WriteStart_4
   \   00000044   0xF5B5 0x5F80      CMP      R5,#+4096
   \   00000048   0xD02C             BEQ.N    ??HAL_TIM_DMABurst_WriteStart_5
   \   0000004A   0xF5B5 0x5F00      CMP      R5,#+8192
   \   0000004E   0xD032             BEQ.N    ??HAL_TIM_DMABurst_WriteStart_6
   \   00000050   0xF5B5 0x4F80      CMP      R5,#+16384
   \   00000054   0xD03A             BEQ.N    ??HAL_TIM_DMABurst_WriteStart_7
   \   00000056   0xE045             B.N      ??HAL_TIM_DMABurst_WriteStart_8
   3381            {
   3382              case TIM_DMA_UPDATE:
   3383              {  
   3384                /* Set the DMA Period elapsed callback */
   3385                htim->hdma[TIM_DMA_ID_UPDATE]->XferCpltCallback = TIM_DMAPeriodElapsedCplt;
   \                     ??HAL_TIM_DMABurst_WriteStart_1: (+1)
   \   00000058   0xF8D4 0xC01C      LDR      R12,[R4, #+28]
   \   0000005C   0x.... 0x....      ADR.W    R2,TIM_DMAPeriodElapsedCplt
   \   00000060   0xF8CC 0x203C      STR      R2,[R12, #+60]
   3386               
   3387                /* Set the DMA error callback */
   3388                htim->hdma[TIM_DMA_ID_UPDATE]->XferErrorCallback = HAL_TIM_DMAError ;
   \   00000064   0x69E2             LDR      R2,[R4, #+28]
   \   00000066   0x.... 0x....      BL       ?Subroutine28
   3389            
   3390                /* Enable the DMA Stream */
   3391                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_UPDATE], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8) + 1); 
   3392              }
   \                     ??CrossCallReturnLabel_92: (+1)
   \   0000006A   0x69E0             LDR      R0,[R4, #+28]
   \   0000006C   0xE038             B.N      ??HAL_TIM_DMABurst_WriteStart_9
   3393              break;
   3394              case TIM_DMA_CC1:
   3395              {  
   3396                /* Set the DMA Period elapsed callback */
   3397                htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = HAL_TIM_DMADelayPulseCplt;
   \                     ??HAL_TIM_DMABurst_WriteStart_2: (+1)
   \   0000006E   0xF8D4 0xC020      LDR      R12,[R4, #+32]
   \   00000072   0xF8CC 0x203C      STR      R2,[R12, #+60]
   3398               
   3399                /* Set the DMA error callback */
   3400                htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = HAL_TIM_DMAError ;
   \   00000076   0x6A22             LDR      R2,[R4, #+32]
   \   00000078   0x.... 0x....      BL       ?Subroutine28
   3401            
   3402                /* Enable the DMA Stream */
   3403                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8) + 1);     
   3404              }
   \                     ??CrossCallReturnLabel_93: (+1)
   \   0000007C   0x6A20             LDR      R0,[R4, #+32]
   \   0000007E   0xE02F             B.N      ??HAL_TIM_DMABurst_WriteStart_9
   3405              break;
   3406              case TIM_DMA_CC2:
   3407              {  
   3408                /* Set the DMA Period elapsed callback */
   3409                htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = HAL_TIM_DMADelayPulseCplt;
   \                     ??HAL_TIM_DMABurst_WriteStart_3: (+1)
   \   00000080   0xF8D4 0xC024      LDR      R12,[R4, #+36]
   \   00000084   0xF8CC 0x203C      STR      R2,[R12, #+60]
   3410               
   3411                /* Set the DMA error callback */
   3412                htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = HAL_TIM_DMAError ;
   \   00000088   0x6A62             LDR      R2,[R4, #+36]
   \   0000008A   0x.... 0x....      BL       ?Subroutine28
   3413            
   3414                /* Enable the DMA Stream */
   3415                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8) + 1);     
   3416              }
   \                     ??CrossCallReturnLabel_94: (+1)
   \   0000008E   0x6A60             LDR      R0,[R4, #+36]
   \   00000090   0xE026             B.N      ??HAL_TIM_DMABurst_WriteStart_9
   3417              break;
   3418              case TIM_DMA_CC3:
   3419              {  
   3420                /* Set the DMA Period elapsed callback */
   3421                htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = HAL_TIM_DMADelayPulseCplt;
   \                     ??HAL_TIM_DMABurst_WriteStart_4: (+1)
   \   00000092   0xF8D4 0xC028      LDR      R12,[R4, #+40]
   \   00000096   0xF8CC 0x203C      STR      R2,[R12, #+60]
   3422               
   3423                /* Set the DMA error callback */
   3424                htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = HAL_TIM_DMAError ;
   \   0000009A   0x6AA2             LDR      R2,[R4, #+40]
   \   0000009C   0x.... 0x....      BL       ?Subroutine28
   3425            
   3426                /* Enable the DMA Stream */
   3427                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8) + 1);     
   3428              }
   \                     ??CrossCallReturnLabel_95: (+1)
   \   000000A0   0x6AA0             LDR      R0,[R4, #+40]
   \   000000A2   0xE01D             B.N      ??HAL_TIM_DMABurst_WriteStart_9
   3429              break;
   3430              case TIM_DMA_CC4:
   3431              {  
   3432                /* Set the DMA Period elapsed callback */
   3433                htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = HAL_TIM_DMADelayPulseCplt;
   \                     ??HAL_TIM_DMABurst_WriteStart_5: (+1)
   \   000000A4   0xF8D4 0xC02C      LDR      R12,[R4, #+44]
   \   000000A8   0xF8CC 0x203C      STR      R2,[R12, #+60]
   3434               
   3435                /* Set the DMA error callback */
   3436                htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = HAL_TIM_DMAError ;
   \   000000AC   0x6AE2             LDR      R2,[R4, #+44]
   \   000000AE   0x.... 0x....      BL       ?Subroutine28
   3437            
   3438                /* Enable the DMA Stream */
   3439                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8) + 1);     
   3440              }
   \                     ??CrossCallReturnLabel_96: (+1)
   \   000000B2   0x6AE0             LDR      R0,[R4, #+44]
   \   000000B4   0xE014             B.N      ??HAL_TIM_DMABurst_WriteStart_9
   3441              break;
   3442              case TIM_DMA_COM:
   3443              {  
   3444                /* Set the DMA Period elapsed callback */
   3445                htim->hdma[TIM_DMA_ID_COMMUTATION]->XferCpltCallback = HAL_TIMEx_DMACommutationCplt;
   \                     ??HAL_TIM_DMABurst_WriteStart_6: (+1)
   \   000000B6   0xF8D4 0xC030      LDR      R12,[R4, #+48]
   \   000000BA   0x.... 0x....      LDR.W    R2,??DataTable29
   \   000000BE   0xF8CC 0x203C      STR      R2,[R12, #+60]
   3446               
   3447                /* Set the DMA error callback */
   3448                htim->hdma[TIM_DMA_ID_COMMUTATION]->XferErrorCallback = HAL_TIM_DMAError ;
   \   000000C2   0x6B22             LDR      R2,[R4, #+48]
   \   000000C4   0x.... 0x....      BL       ?Subroutine28
   3449            
   3450                /* Enable the DMA Stream */
   3451                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_COMMUTATION], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8) + 1);     
   3452              }
   \                     ??CrossCallReturnLabel_97: (+1)
   \   000000C8   0x6B20             LDR      R0,[R4, #+48]
   \   000000CA   0xE009             B.N      ??HAL_TIM_DMABurst_WriteStart_9
   3453              break;
   3454              case TIM_DMA_TRIGGER:
   3455              {  
   3456                /* Set the DMA Period elapsed callback */
   3457                htim->hdma[TIM_DMA_ID_TRIGGER]->XferCpltCallback = TIM_DMATriggerCplt;
   \                     ??HAL_TIM_DMABurst_WriteStart_7: (+1)
   \   000000CC   0xF8D4 0xC034      LDR      R12,[R4, #+52]
   \   000000D0   0x.... 0x....      ADR.W    R2,TIM_DMATriggerCplt
   \   000000D4   0xF8CC 0x203C      STR      R2,[R12, #+60]
   3458               
   3459                /* Set the DMA error callback */
   3460                htim->hdma[TIM_DMA_ID_TRIGGER]->XferErrorCallback = HAL_TIM_DMAError ;
   \   000000D8   0x6B62             LDR      R2,[R4, #+52]
   \   000000DA   0x.... 0x....      BL       ?Subroutine28
   3461            
   3462                /* Enable the DMA Stream */
   3463                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_TRIGGER], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8) + 1);     
   3464              }
   \                     ??CrossCallReturnLabel_98: (+1)
   \   000000DE   0x6B60             LDR      R0,[R4, #+52]
   \                     ??HAL_TIM_DMABurst_WriteStart_9: (+1)
   \   000000E0   0x.... 0x....      BL       HAL_DMA_Start_IT
   3465              break;
   3466              default:
   3467              break;  
   3468            }
   3469             /* configure the DMA Burst Mode */
   3470             htim->Instance->DCR = BurstBaseAddress | BurstLength;  
   \                     ??HAL_TIM_DMABurst_WriteStart_8: (+1)
   \   000000E4   0x.... 0x....      BL       ?Subroutine27
   3471             
   3472             /* Enable the TIM DMA Request */
   3473             __HAL_TIM_ENABLE_DMA(htim, BurstRequestSrc);  
   3474             
   3475             htim->State = HAL_TIM_STATE_READY;
   3476            
   3477            /* Return function status */
   3478            return HAL_OK;
   \                     ??CrossCallReturnLabel_90: (+1)
   \   000000E8   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   3479          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine28: (+1)
   \   00000000   0x6490             STR      R0,[R2, #+72]
   \   00000002   0x6820             LDR      R0,[R4, #+0]
   \   00000004   0xF100 0x024C      ADD      R2,R0,#+76
   \   00000008   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine27: (+1)
   \   00000000   0x6821             LDR      R1,[R4, #+0]
   \   00000002   0xEA47 0x0006      ORR      R0,R7,R6
   \   00000006   0x6488             STR      R0,[R1, #+72]
   \   00000008   0x6820             LDR      R0,[R4, #+0]
   \   0000000A   0x68C1             LDR      R1,[R0, #+12]
   \   0000000C   0x4329             ORRS     R1,R5,R1
   \   0000000E   0x60C1             STR      R1,[R0, #+12]
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0xF884 0x0039      STRB     R0,[R4, #+57]
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0x4770             BX       LR
   3480          
   3481          /**
   3482            * @brief  Stops the TIM DMA Burst mode 
   3483            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   3484            *                the configuration information for TIM module.
   3485            * @param  BurstRequestSrc: TIM DMA Request sources to disable
   3486            * @retval HAL status
   3487            */

   \                                 In section .text, align 2, keep-with-next
   3488          HAL_StatusTypeDef HAL_TIM_DMABurst_WriteStop(TIM_HandleTypeDef *htim, uint32_t BurstRequestSrc)
   \                     HAL_TIM_DMABurst_WriteStop: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x....             B.N      ?Subroutine8

   \                                 In section .text, align 2, keep-with-next
   3489          {
   \                     ?Subroutine8: (+1)
   \   00000000   0x460D             MOV      R5,R1
   3490            /* Check the parameters */
   3491            assert_param(IS_TIM_DMA_SOURCE(BurstRequestSrc));
   3492            
   3493            /* Abort the DMA transfer (at least disable the DMA channel) */
   3494            switch(BurstRequestSrc)
   \   00000002   0xF5B5 0x7F80      CMP      R5,#+256
   \   00000006   0x4604             MOV      R4,R0
   \   00000008   0xD012             BEQ.N    ??Subroutine8_0
   \   0000000A   0xF5B5 0x7F00      CMP      R5,#+512
   \   0000000E   0xD011             BEQ.N    ??Subroutine8_1
   \   00000010   0xF5B5 0x6F80      CMP      R5,#+1024
   \   00000014   0xD010             BEQ.N    ??Subroutine8_2
   \   00000016   0xF5B5 0x6F00      CMP      R5,#+2048
   \   0000001A   0xD00F             BEQ.N    ??Subroutine8_3
   \   0000001C   0xF5B5 0x5F80      CMP      R5,#+4096
   \   00000020   0xD00E             BEQ.N    ??Subroutine8_4
   \   00000022   0xF5B5 0x5F00      CMP      R5,#+8192
   \   00000026   0xD00D             BEQ.N    ??Subroutine8_5
   \   00000028   0xF5B5 0x4F80      CMP      R5,#+16384
   \   0000002C   0xD00C             BEQ.N    ??Subroutine8_6
   \   0000002E   0xE00E             B.N      ??Subroutine8_7
   3495            {
   3496              case TIM_DMA_UPDATE:
   3497              {  
   3498                HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_UPDATE]);
   \                     ??Subroutine8_0: (+1)
   \   00000030   0x69E0             LDR      R0,[R4, #+28]
   \   00000032   0xE00A             B.N      ??Subroutine8_8
   3499              }
   3500              break;
   3501              case TIM_DMA_CC1:
   3502              {  
   3503                HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC1]);
   \                     ??Subroutine8_1: (+1)
   \   00000034   0x6A20             LDR      R0,[R4, #+32]
   \   00000036   0xE008             B.N      ??Subroutine8_8
   3504              }
   3505              break;
   3506              case TIM_DMA_CC2:
   3507              {  
   3508                HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC2]);
   \                     ??Subroutine8_2: (+1)
   \   00000038   0x6A60             LDR      R0,[R4, #+36]
   \   0000003A   0xE006             B.N      ??Subroutine8_8
   3509              }
   3510              break;
   3511              case TIM_DMA_CC3:
   3512              {  
   3513                HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC3]);
   \                     ??Subroutine8_3: (+1)
   \   0000003C   0x6AA0             LDR      R0,[R4, #+40]
   \   0000003E   0xE004             B.N      ??Subroutine8_8
   3514              }
   3515              break;
   3516              case TIM_DMA_CC4:
   3517              {  
   3518                HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC4]);
   \                     ??Subroutine8_4: (+1)
   \   00000040   0x6AE0             LDR      R0,[R4, #+44]
   \   00000042   0xE002             B.N      ??Subroutine8_8
   3519              }
   3520              break;
   3521              case TIM_DMA_COM:
   3522              {  
   3523                HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_COMMUTATION]);
   \                     ??Subroutine8_5: (+1)
   \   00000044   0x6B20             LDR      R0,[R4, #+48]
   \   00000046   0xE000             B.N      ??Subroutine8_8
   3524              }
   3525              break;
   3526              case TIM_DMA_TRIGGER:
   3527              {  
   3528                HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_TRIGGER]);
   \                     ??Subroutine8_6: (+1)
   \   00000048   0x6B60             LDR      R0,[R4, #+52]
   \                     ??Subroutine8_8: (+1)
   \   0000004A   0x.... 0x....      BL       HAL_DMA_Abort
   3529              }
   3530              break;
   3531              default:
   3532              break;
   3533            }
   3534          
   3535            /* Disable the TIM Update DMA request */
   3536            __HAL_TIM_DISABLE_DMA(htim, BurstRequestSrc);
   \                     ??Subroutine8_7: (+1)
   \   0000004E   0x6820             LDR      R0,[R4, #+0]
   \   00000050   0x68C1             LDR      R1,[R0, #+12]
   \   00000052   0x43A9             BICS     R1,R1,R5
   \   00000054   0x60C1             STR      R1,[R0, #+12]
   3537                
   3538            /* Return function status */
   3539            return HAL_OK;  
   \   00000056   0x2000             MOVS     R0,#+0
   \   00000058   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   3540          }
   3541          
   3542          /**
   3543            * @brief  Configure the DMA Burst to transfer Data from the TIM peripheral to the memory 
   3544            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   3545            *                the configuration information for TIM module.
   3546            * @param  BurstBaseAddress: TIM Base address from when the DMA will starts the Data read.
   3547            *         This parameters can be on of the following values:
   3548            *            @arg TIM_DMABASE_CR1  
   3549            *            @arg TIM_DMABASE_CR2
   3550            *            @arg TIM_DMABASE_SMCR
   3551            *            @arg TIM_DMABASE_DIER
   3552            *            @arg TIM_DMABASE_SR
   3553            *            @arg TIM_DMABASE_EGR
   3554            *            @arg TIM_DMABASE_CCMR1
   3555            *            @arg TIM_DMABASE_CCMR2
   3556            *            @arg TIM_DMABASE_CCER
   3557            *            @arg TIM_DMABASE_CNT   
   3558            *            @arg TIM_DMABASE_PSC   
   3559            *            @arg TIM_DMABASE_ARR
   3560            *            @arg TIM_DMABASE_RCR
   3561            *            @arg TIM_DMABASE_CCR1
   3562            *            @arg TIM_DMABASE_CCR2
   3563            *            @arg TIM_DMABASE_CCR3  
   3564            *            @arg TIM_DMABASE_CCR4
   3565            *            @arg TIM_DMABASE_BDTR
   3566            *            @arg TIM_DMABASE_DCR
   3567            * @param  BurstRequestSrc: TIM DMA Request sources.
   3568            *         This parameters can be on of the following values:
   3569            *            @arg TIM_DMA_UPDATE: TIM update Interrupt source
   3570            *            @arg TIM_DMA_CC1: TIM Capture Compare 1 DMA source
   3571            *            @arg TIM_DMA_CC2: TIM Capture Compare 2 DMA source
   3572            *            @arg TIM_DMA_CC3: TIM Capture Compare 3 DMA source
   3573            *            @arg TIM_DMA_CC4: TIM Capture Compare 4 DMA source
   3574            *            @arg TIM_DMA_COM: TIM Commutation DMA source
   3575            *            @arg TIM_DMA_TRIGGER: TIM Trigger DMA source
   3576            * @param  BurstBuffer: The Buffer address.
   3577            * @param  BurstLength: DMA Burst length. This parameter can be one value
   3578            *         between TIM_DMABURSTLENGTH_1TRANSFER and TIM_DMABURSTLENGTH_18TRANSFERS.
   3579            * @retval HAL status
   3580            */

   \                                 In section .text, align 2, keep-with-next
   3581          HAL_StatusTypeDef HAL_TIM_DMABurst_ReadStart(TIM_HandleTypeDef *htim, uint32_t BurstBaseAddress, uint32_t BurstRequestSrc,
   3582                                                       uint32_t  *BurstBuffer, uint32_t  BurstLength)
   3583          {
   \                     HAL_TIM_DMABurst_ReadStart: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x4615             MOV      R5,R2
   \   00000006   0x460E             MOV      R6,R1
   \   00000008   0x461A             MOV      R2,R3
   3584            /* Check the parameters */
   3585            assert_param(IS_TIM_DMABURST_INSTANCE(htim->Instance));
   3586            assert_param(IS_TIM_DMA_BASE(BurstBaseAddress));
   3587            assert_param(IS_TIM_DMA_SOURCE(BurstRequestSrc));
   3588            assert_param(IS_TIM_DMA_LENGTH(BurstLength));
   3589            
   3590            if((htim->State == HAL_TIM_STATE_BUSY))
   \   0000000A   0x.... 0x....      BL       ??Subroutine15_0
   \                     ??CrossCallReturnLabel_24: (+1)
   \   0000000E   0xD06B             BEQ.N    ??CrossCallReturnLabel_91
   \   00000010   0x.... 0x....      BL       ?Subroutine16
   3591            {
   3592               return HAL_BUSY;
   3593            }
   3594            else if((htim->State == HAL_TIM_STATE_READY))
   \                     ??CrossCallReturnLabel_26: (+1)
   \   00000014   0xD104             BNE.N    ??CrossCallReturnLabel_36
   3595            {
   3596              if((BurstBuffer == 0 ) && (BurstLength > 0)) 
   \   00000016   0xB90A             CBNZ.N   R2,??HAL_TIM_DMABurst_ReadStart_0
   \   00000018   0x2F00             CMP      R7,#+0
   \   0000001A   0xD165             BNE.N    ??CrossCallReturnLabel_91
   3597              {
   3598                return HAL_ERROR;                                    
   3599              }
   3600              else
   3601              {
   3602                htim->State = HAL_TIM_STATE_BUSY;
   \                     ??HAL_TIM_DMABurst_ReadStart_0: (+1)
   \   0000001C   0x.... 0x....      BL       ?Subroutine17
   3603              }
   3604            }  
   3605            switch(BurstRequestSrc)
   \                     ??CrossCallReturnLabel_36: (+1)
   \   00000020   0x0A38             LSRS     R0,R7,#+8
   \   00000022   0x1C43             ADDS     R3,R0,#+1
   \   00000024   0xF5B5 0x7F80      CMP      R5,#+256
   \   00000028   0x.... 0x....      ADR.W    R1,TIM_DMACaptureCplt
   \   0000002C   0x.... 0x....      ADR.W    R0,TIM_DMAError
   \   00000030   0xD012             BEQ.N    ??HAL_TIM_DMABurst_ReadStart_1
   \   00000032   0xF5B5 0x7F00      CMP      R5,#+512
   \   00000036   0xD01A             BEQ.N    ??HAL_TIM_DMABurst_ReadStart_2
   \   00000038   0xF5B5 0x6F80      CMP      R5,#+1024
   \   0000003C   0xD020             BEQ.N    ??HAL_TIM_DMABurst_ReadStart_3
   \   0000003E   0xF5B5 0x6F00      CMP      R5,#+2048
   \   00000042   0xD026             BEQ.N    ??HAL_TIM_DMABurst_ReadStart_4
   \   00000044   0xF5B5 0x5F80      CMP      R5,#+4096
   \   00000048   0xD02C             BEQ.N    ??HAL_TIM_DMABurst_ReadStart_5
   \   0000004A   0xF5B5 0x5F00      CMP      R5,#+8192
   \   0000004E   0xD032             BEQ.N    ??HAL_TIM_DMABurst_ReadStart_6
   \   00000050   0xF5B5 0x4F80      CMP      R5,#+16384
   \   00000054   0xD03A             BEQ.N    ??HAL_TIM_DMABurst_ReadStart_7
   \   00000056   0xE045             B.N      ??HAL_TIM_DMABurst_ReadStart_8
   3606            {
   3607              case TIM_DMA_UPDATE:
   3608              {  
   3609                /* Set the DMA Period elapsed callback */
   3610                htim->hdma[TIM_DMA_ID_UPDATE]->XferCpltCallback = TIM_DMAPeriodElapsedCplt;
   \                     ??HAL_TIM_DMABurst_ReadStart_1: (+1)
   \   00000058   0xF8D4 0xC01C      LDR      R12,[R4, #+28]
   \   0000005C   0x.... 0x....      ADR.W    R1,TIM_DMAPeriodElapsedCplt
   \   00000060   0xF8CC 0x103C      STR      R1,[R12, #+60]
   3611               
   3612                /* Set the DMA error callback */
   3613                htim->hdma[TIM_DMA_ID_UPDATE]->XferErrorCallback = HAL_TIM_DMAError ;
   \   00000064   0x69E1             LDR      R1,[R4, #+28]
   \   00000066   0x.... 0x....      BL       ?Subroutine29
   3614            
   3615                /* Enable the DMA Stream */
   3616                 HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_UPDATE], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8) + 1);     
   3617              }
   \                     ??CrossCallReturnLabel_99: (+1)
   \   0000006A   0x69E0             LDR      R0,[R4, #+28]
   \   0000006C   0xE038             B.N      ??HAL_TIM_DMABurst_ReadStart_9
   3618              break;
   3619              case TIM_DMA_CC1:
   3620              {  
   3621                /* Set the DMA Period elapsed callback */
   3622                htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = HAL_TIM_DMACaptureCplt;
   \                     ??HAL_TIM_DMABurst_ReadStart_2: (+1)
   \   0000006E   0xF8D4 0xC020      LDR      R12,[R4, #+32]
   \   00000072   0xF8CC 0x103C      STR      R1,[R12, #+60]
   3623               
   3624                /* Set the DMA error callback */
   3625                htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = HAL_TIM_DMAError ;
   \   00000076   0x6A21             LDR      R1,[R4, #+32]
   \   00000078   0x.... 0x....      BL       ?Subroutine29
   3626            
   3627                /* Enable the DMA Stream */
   3628                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8) + 1);      
   3629              }
   \                     ??CrossCallReturnLabel_100: (+1)
   \   0000007C   0x6A20             LDR      R0,[R4, #+32]
   \   0000007E   0xE02F             B.N      ??HAL_TIM_DMABurst_ReadStart_9
   3630              break;
   3631              case TIM_DMA_CC2:
   3632              {  
   3633                /* Set the DMA Period elapsed callback */
   3634                htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = HAL_TIM_DMACaptureCplt;
   \                     ??HAL_TIM_DMABurst_ReadStart_3: (+1)
   \   00000080   0xF8D4 0xC024      LDR      R12,[R4, #+36]
   \   00000084   0xF8CC 0x103C      STR      R1,[R12, #+60]
   3635               
   3636                /* Set the DMA error callback */
   3637                htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = HAL_TIM_DMAError ;
   \   00000088   0x6A61             LDR      R1,[R4, #+36]
   \   0000008A   0x.... 0x....      BL       ?Subroutine29
   3638            
   3639                /* Enable the DMA Stream */
   3640                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8) + 1);     
   3641              }
   \                     ??CrossCallReturnLabel_101: (+1)
   \   0000008E   0x6A60             LDR      R0,[R4, #+36]
   \   00000090   0xE026             B.N      ??HAL_TIM_DMABurst_ReadStart_9
   3642              break;
   3643              case TIM_DMA_CC3:
   3644              {  
   3645                /* Set the DMA Period elapsed callback */
   3646                htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = HAL_TIM_DMACaptureCplt;
   \                     ??HAL_TIM_DMABurst_ReadStart_4: (+1)
   \   00000092   0xF8D4 0xC028      LDR      R12,[R4, #+40]
   \   00000096   0xF8CC 0x103C      STR      R1,[R12, #+60]
   3647               
   3648                /* Set the DMA error callback */
   3649                htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = HAL_TIM_DMAError ;
   \   0000009A   0x6AA1             LDR      R1,[R4, #+40]
   \   0000009C   0x.... 0x....      BL       ?Subroutine29
   3650            
   3651                /* Enable the DMA Stream */
   3652                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8) + 1);      
   3653              }
   \                     ??CrossCallReturnLabel_102: (+1)
   \   000000A0   0x6AA0             LDR      R0,[R4, #+40]
   \   000000A2   0xE01D             B.N      ??HAL_TIM_DMABurst_ReadStart_9
   3654              break;
   3655              case TIM_DMA_CC4:
   3656              {  
   3657                /* Set the DMA Period elapsed callback */
   3658                htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = HAL_TIM_DMACaptureCplt;
   \                     ??HAL_TIM_DMABurst_ReadStart_5: (+1)
   \   000000A4   0xF8D4 0xC02C      LDR      R12,[R4, #+44]
   \   000000A8   0xF8CC 0x103C      STR      R1,[R12, #+60]
   3659               
   3660                /* Set the DMA error callback */
   3661                htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = HAL_TIM_DMAError ;
   \   000000AC   0x6AE1             LDR      R1,[R4, #+44]
   \   000000AE   0x.... 0x....      BL       ?Subroutine29
   3662            
   3663                /* Enable the DMA Stream */
   3664                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8) + 1);      
   3665              }
   \                     ??CrossCallReturnLabel_103: (+1)
   \   000000B2   0x6AE0             LDR      R0,[R4, #+44]
   \   000000B4   0xE014             B.N      ??HAL_TIM_DMABurst_ReadStart_9
   3666              break;
   3667              case TIM_DMA_COM:
   3668              {  
   3669                /* Set the DMA Period elapsed callback */
   3670                htim->hdma[TIM_DMA_ID_COMMUTATION]->XferCpltCallback = HAL_TIMEx_DMACommutationCplt;
   \                     ??HAL_TIM_DMABurst_ReadStart_6: (+1)
   \   000000B6   0xF8D4 0xC030      LDR      R12,[R4, #+48]
   \   000000BA   0x.... 0x....      LDR.W    R1,??DataTable29
   \   000000BE   0xF8CC 0x103C      STR      R1,[R12, #+60]
   3671               
   3672                /* Set the DMA error callback */
   3673                htim->hdma[TIM_DMA_ID_COMMUTATION]->XferErrorCallback = HAL_TIM_DMAError ;
   \   000000C2   0x6B21             LDR      R1,[R4, #+48]
   \   000000C4   0x.... 0x....      BL       ?Subroutine29
   3674            
   3675                /* Enable the DMA Stream */
   3676                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_COMMUTATION], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8) + 1);      
   3677              }
   \                     ??CrossCallReturnLabel_104: (+1)
   \   000000C8   0x6B20             LDR      R0,[R4, #+48]
   \   000000CA   0xE009             B.N      ??HAL_TIM_DMABurst_ReadStart_9
   3678              break;
   3679              case TIM_DMA_TRIGGER:
   3680              {  
   3681                /* Set the DMA Period elapsed callback */
   3682                htim->hdma[TIM_DMA_ID_TRIGGER]->XferCpltCallback = TIM_DMATriggerCplt;
   \                     ??HAL_TIM_DMABurst_ReadStart_7: (+1)
   \   000000CC   0xF8D4 0xC034      LDR      R12,[R4, #+52]
   \   000000D0   0x.... 0x....      ADR.W    R1,TIM_DMATriggerCplt
   \   000000D4   0xF8CC 0x103C      STR      R1,[R12, #+60]
   3683               
   3684                /* Set the DMA error callback */
   3685                htim->hdma[TIM_DMA_ID_TRIGGER]->XferErrorCallback = HAL_TIM_DMAError ;
   \   000000D8   0x6B61             LDR      R1,[R4, #+52]
   \   000000DA   0x.... 0x....      BL       ?Subroutine29
   3686            
   3687                /* Enable the DMA Stream */
   3688                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_TRIGGER], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8) + 1);      
   3689              }
   \                     ??CrossCallReturnLabel_105: (+1)
   \   000000DE   0x6B60             LDR      R0,[R4, #+52]
   \                     ??HAL_TIM_DMABurst_ReadStart_9: (+1)
   \   000000E0   0x.... 0x....      BL       HAL_DMA_Start_IT
   3690              break;
   3691              default:
   3692              break;  
   3693            }
   3694          
   3695            /* configure the DMA Burst Mode */
   3696            htim->Instance->DCR = BurstBaseAddress | BurstLength;  
   \                     ??HAL_TIM_DMABurst_ReadStart_8: (+1)
   \   000000E4   0x.... 0x....      BL       ?Subroutine27
   3697            
   3698            /* Enable the TIM DMA Request */
   3699            __HAL_TIM_ENABLE_DMA(htim, BurstRequestSrc);
   3700            
   3701            htim->State = HAL_TIM_STATE_READY;
   3702            
   3703            /* Return function status */
   3704            return HAL_OK;
   \                     ??CrossCallReturnLabel_91: (+1)
   \   000000E8   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   3705          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine29: (+1)
   \   00000000   0x6488             STR      R0,[R1, #+72]
   \   00000002   0x6820             LDR      R0,[R4, #+0]
   \   00000004   0xF100 0x014C      ADD      R1,R0,#+76
   \   00000008   0x4770             BX       LR
   3706          
   3707          /**
   3708            * @brief  Stop the DMA burst reading 
   3709            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   3710            *                the configuration information for TIM module.
   3711            * @param  BurstRequestSrc: TIM DMA Request sources to disable.
   3712            * @retval HAL status
   3713            */

   \                                 In section .text, align 2, keep-with-next
   3714          HAL_StatusTypeDef HAL_TIM_DMABurst_ReadStop(TIM_HandleTypeDef *htim, uint32_t BurstRequestSrc)
   \                     HAL_TIM_DMABurst_ReadStop: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002                      REQUIRE ?Subroutine8
   \   00000002                      ;; // Fall through to label ?Subroutine8
   3715          {
   3716            /* Check the parameters */
   3717            assert_param(IS_TIM_DMA_SOURCE(BurstRequestSrc));
   3718            
   3719            /* Abort the DMA transfer (at least disable the DMA channel) */
   3720            switch(BurstRequestSrc)
   3721            {
   3722              case TIM_DMA_UPDATE:
   3723              {  
   3724                HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_UPDATE]);
   3725              }
   3726              break;
   3727              case TIM_DMA_CC1:
   3728              {  
   3729                HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC1]);
   3730              }
   3731              break;
   3732              case TIM_DMA_CC2:
   3733              {  
   3734                HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC2]);
   3735              }
   3736              break;
   3737              case TIM_DMA_CC3:
   3738              {  
   3739                HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC3]);
   3740              }
   3741              break;
   3742              case TIM_DMA_CC4:
   3743              {  
   3744                HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC4]);
   3745              }
   3746              break;
   3747              case TIM_DMA_COM:
   3748              {  
   3749                HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_COMMUTATION]);
   3750              }
   3751              break;
   3752              case TIM_DMA_TRIGGER:
   3753              {  
   3754                HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_TRIGGER]);
   3755              }
   3756              break;
   3757              default:
   3758              break;  
   3759            }
   3760            
   3761            /* Disable the TIM Update DMA request */
   3762            __HAL_TIM_DISABLE_DMA(htim, BurstRequestSrc);
   3763                
   3764            /* Return function status */
   3765            return HAL_OK;  
   3766          }
   3767          
   3768          /**
   3769            * @brief  Generate a software event
   3770            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   3771            *                the configuration information for TIM module.
   3772            * @param  EventSource: specifies the event source.
   3773            *          This parameter can be one of the following values:
   3774            *            @arg TIM_EVENTSOURCE_UPDATE: Timer update Event source
   3775            *            @arg TIM_EVENTSOURCE_CC1: Timer Capture Compare 1 Event source
   3776            *            @arg TIM_EVENTSOURCE_CC2: Timer Capture Compare 2 Event source
   3777            *            @arg TIM_EVENTSOURCE_CC3: Timer Capture Compare 3 Event source
   3778            *            @arg TIM_EVENTSOURCE_CC4: Timer Capture Compare 4 Event source
   3779            *            @arg TIM_EVENTSOURCE_COM: Timer COM event source  
   3780            *            @arg TIM_EVENTSOURCE_TRIGGER: Timer Trigger Event source
   3781            *            @arg TIM_EVENTSOURCE_BREAK: Timer Break event source
   3782            *            @arg TIM_EVENTSOURCE_BREAK2: Timer Break2 event source  
   3783            * @note   TIM6 and TIM7 can only generate an update event. 
   3784            * @note   TIM_EVENTSOURCE_COM, TIM_EVENTSOURCE_BREAK and TIM_EVENTSOURCE_BREAK2 are used only with TIM1 and TIM8.
   3785            * @retval HAL status
   3786            */ 
   3787          

   \                                 In section .text, align 2, keep-with-next
   3788          HAL_StatusTypeDef HAL_TIM_GenerateEvent(TIM_HandleTypeDef *htim, uint32_t EventSource)
   3789          {
   3790            /* Check the parameters */
   3791            assert_param(IS_TIM_INSTANCE(htim->Instance));
   3792            assert_param(IS_TIM_EVENT_SOURCE(EventSource));
   3793            
   3794            /* Process Locked */
   3795            __HAL_LOCK(htim);
   \                     HAL_TIM_GenerateEvent: (+1)
   \   00000000   0xF100 0x0238      ADD      R2,R0,#+56
   \   00000004   0x7813             LDRB     R3,[R2, #+0]
   \   00000006   0x2B01             CMP      R3,#+1
   \   00000008   0xD101             BNE.N    ??HAL_TIM_GenerateEvent_0
   \   0000000A   0x2002             MOVS     R0,#+2
   \   0000000C   0x4770             BX       LR
   \                     ??HAL_TIM_GenerateEvent_0: (+1)
   \   0000000E   0x2301             MOVS     R3,#+1
   \   00000010   0x7013             STRB     R3,[R2, #+0]
   3796            
   3797            /* Change the TIM state */
   3798            htim->State = HAL_TIM_STATE_BUSY;
   \   00000012   0x2302             MOVS     R3,#+2
   \   00000014   0x7053             STRB     R3,[R2, #+1]
   3799            
   3800            /* Set the event sources */
   3801            htim->Instance->EGR = EventSource;
   \   00000016   0x6800             LDR      R0,[R0, #+0]
   \   00000018   0x6141             STR      R1,[R0, #+20]
   3802            
   3803            /* Change the TIM state */
   3804            htim->State = HAL_TIM_STATE_READY;
   \   0000001A   0x2001             MOVS     R0,#+1
   \   0000001C   0x7050             STRB     R0,[R2, #+1]
   3805            
   3806            __HAL_UNLOCK(htim);
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0x7010             STRB     R0,[R2, #+0]
   3807            
   3808            /* Return function status */
   3809            return HAL_OK;  
   \   00000022   0x4770             BX       LR               ;; return
   3810          }
   3811          
   3812          /**
   3813            * @brief  Configures the OCRef clear feature
   3814            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   3815            *                the configuration information for TIM module.
   3816            * @param  sClearInputConfig: pointer to a TIM_ClearInputConfigTypeDef structure that
   3817            *         contains the OCREF clear feature and parameters for the TIM peripheral. 
   3818            * @param  Channel: specifies the TIM Channel.
   3819            *          This parameter can be one of the following values:
   3820            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   3821            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   3822            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   3823            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   3824            * @retval HAL status
   3825            */ 

   \                                 In section .text, align 2, keep-with-next
   3826          __weak HAL_StatusTypeDef HAL_TIM_ConfigOCrefClear(TIM_HandleTypeDef *htim, TIM_ClearInputConfigTypeDef * sClearInputConfig, uint32_t Channel)
   3827          { 
   \                     HAL_TIM_ConfigOCrefClear: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4606             MOV      R6,R0
   3828            /* Check the parameters */
   3829            assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   3830            assert_param(IS_TIM_CHANNELS(Channel));
   3831            assert_param(IS_TIM_CLEARINPUT_SOURCE(sClearInputConfig->ClearInputSource));
   3832             
   3833            /* Process Locked */
   3834            __HAL_LOCK(htim);
   \   00000004   0xF106 0x0538      ADD      R5,R6,#+56
   \   00000008   0x460C             MOV      R4,R1
   \   0000000A   0x4617             MOV      R7,R2
   \   0000000C   0x7828             LDRB     R0,[R5, #+0]
   \   0000000E   0x2801             CMP      R0,#+1
   \   00000010   0xD101             BNE.N    ??HAL_TIM_ConfigOCrefClear_0
   \   00000012   0x2002             MOVS     R0,#+2
   \   00000014   0xBDF2             POP      {R1,R4-R7,PC}
   \                     ??HAL_TIM_ConfigOCrefClear_0: (+1)
   \   00000016   0x2001             MOVS     R0,#+1
   \   00000018   0x7028             STRB     R0,[R5, #+0]
   3835            
   3836            htim->State = HAL_TIM_STATE_BUSY;
   \   0000001A   0x2002             MOVS     R0,#+2
   \   0000001C   0x7068             STRB     R0,[R5, #+1]
   3837            
   3838            if(sClearInputConfig->ClearInputSource == TIM_CLEARINPUTSOURCE_ETR)
   \   0000001E   0x6860             LDR      R0,[R4, #+4]
   \   00000020   0x2801             CMP      R0,#+1
   \   00000022   0xD105             BNE.N    ??HAL_TIM_ConfigOCrefClear_1
   3839            {
   3840              assert_param(IS_TIM_CLEARINPUT_POLARITY(sClearInputConfig->ClearInputPolarity));
   3841              assert_param(IS_TIM_CLEARINPUT_PRESCALER(sClearInputConfig->ClearInputPrescaler));
   3842              assert_param(IS_TIM_CLEARINPUT_FILTER(sClearInputConfig->ClearInputFilter));
   3843            
   3844              TIM_ETR_SetConfig(htim->Instance, 
   3845                                sClearInputConfig->ClearInputPrescaler,
   3846                                sClearInputConfig->ClearInputPolarity,
   3847                                sClearInputConfig->ClearInputFilter);
   \   00000024   0x6923             LDR      R3,[R4, #+16]
   \   00000026   0x68A2             LDR      R2,[R4, #+8]
   \   00000028   0x68E1             LDR      R1,[R4, #+12]
   \   0000002A   0x6830             LDR      R0,[R6, #+0]
   \   0000002C   0x.... 0x....      BL       TIM_ETR_SetConfig
   3848            }
   3849            
   3850            switch (Channel)
   \                     ??HAL_TIM_ConfigOCrefClear_1: (+1)
   \   00000030   0xB137             CBZ.N    R7,??HAL_TIM_ConfigOCrefClear_2
   \   00000032   0x2F04             CMP      R7,#+4
   \   00000034   0xD00D             BEQ.N    ??HAL_TIM_ConfigOCrefClear_3
   \   00000036   0x2F08             CMP      R7,#+8
   \   00000038   0xD015             BEQ.N    ??HAL_TIM_ConfigOCrefClear_4
   \   0000003A   0x2F0C             CMP      R7,#+12
   \   0000003C   0xD01C             BEQ.N    ??HAL_TIM_ConfigOCrefClear_5
   \   0000003E   0xE024             B.N      ??HAL_TIM_ConfigOCrefClear_6
   3851            {
   3852              case TIM_CHANNEL_1:
   3853              {        
   3854                if(sClearInputConfig->ClearInputState != RESET)  
   \                     ??HAL_TIM_ConfigOCrefClear_2: (+1)
   \   00000040   0x.... 0x....      BL       ?Subroutine63
   \                     ??CrossCallReturnLabel_199: (+1)
   \   00000044   0x6981             LDR      R1,[R0, #+24]
   \   00000046   0xBF0C             ITE      EQ 
   \   00000048   0xF021 0x0180      BICEQ    R1,R1,#0x80
   \   0000004C   0xF041 0x0180      ORRNE    R1,R1,#0x80
   3855                {
   3856                  /* Enable the Ocref clear feature for Channel 1 */
   3857                  htim->Instance->CCMR1 |= TIM_CCMR1_OC1CE;
   3858                }
   3859                else
   3860                {
   3861                  /* Disable the Ocref clear feature for Channel 1 */
   3862                  htim->Instance->CCMR1 &= ~TIM_CCMR1_OC1CE;      
   \   00000050   0xE007             B.N      ??HAL_TIM_ConfigOCrefClear_7
   3863                }
   3864              }    
   3865              break;
   3866              case TIM_CHANNEL_2:    
   3867              { 
   3868                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance)); 
   3869                if(sClearInputConfig->ClearInputState != RESET)  
   \                     ??HAL_TIM_ConfigOCrefClear_3: (+1)
   \   00000052   0x.... 0x....      BL       ?Subroutine63
   \                     ??CrossCallReturnLabel_200: (+1)
   \   00000056   0x6981             LDR      R1,[R0, #+24]
   \   00000058   0xBF14             ITE      NE 
   \   0000005A   0xF441 0x4100      ORRNE    R1,R1,#0x8000
   \   0000005E   0xF421 0x4100      BICEQ    R1,R1,#0x8000
   3870                {
   3871                  /* Enable the Ocref clear feature for Channel 2 */
   3872                  htim->Instance->CCMR1 |= TIM_CCMR1_OC2CE;
   3873                }
   3874                else
   3875                {
   3876                  /* Disable the Ocref clear feature for Channel 2 */
   3877                  htim->Instance->CCMR1 &= ~TIM_CCMR1_OC2CE;      
   \                     ??HAL_TIM_ConfigOCrefClear_7: (+1)
   \   00000062   0x6181             STR      R1,[R0, #+24]
   \   00000064   0xE011             B.N      ??HAL_TIM_ConfigOCrefClear_6
   3878                }
   3879              } 
   3880              break;
   3881              case TIM_CHANNEL_3:   
   3882              {  
   3883                assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
   3884                if(sClearInputConfig->ClearInputState != RESET)  
   \                     ??HAL_TIM_ConfigOCrefClear_4: (+1)
   \   00000066   0x.... 0x....      BL       ?Subroutine63
   \                     ??CrossCallReturnLabel_201: (+1)
   \   0000006A   0x69C1             LDR      R1,[R0, #+28]
   \   0000006C   0xBF0C             ITE      EQ 
   \   0000006E   0xF021 0x0180      BICEQ    R1,R1,#0x80
   \   00000072   0xF041 0x0180      ORRNE    R1,R1,#0x80
   3885                {
   3886                  /* Enable the Ocref clear feature for Channel 3 */
   3887                  htim->Instance->CCMR2 |= TIM_CCMR2_OC3CE;
   3888                }
   3889                else
   3890                {
   3891                  /* Disable the Ocref clear feature for Channel 3 */
   3892                  htim->Instance->CCMR2 &= ~TIM_CCMR2_OC3CE;      
   \   00000076   0xE007             B.N      ??HAL_TIM_ConfigOCrefClear_8
   3893                }
   3894              } 
   3895              break;
   3896              case TIM_CHANNEL_4:    
   3897              {  
   3898                assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
   3899                if(sClearInputConfig->ClearInputState != RESET)  
   \                     ??HAL_TIM_ConfigOCrefClear_5: (+1)
   \   00000078   0x.... 0x....      BL       ?Subroutine63
   \                     ??CrossCallReturnLabel_202: (+1)
   \   0000007C   0x69C1             LDR      R1,[R0, #+28]
   \   0000007E   0xBF14             ITE      NE 
   \   00000080   0xF441 0x4100      ORRNE    R1,R1,#0x8000
   \   00000084   0xF421 0x4100      BICEQ    R1,R1,#0x8000
   3900                {
   3901                  /* Enable the Ocref clear feature for Channel 4 */
   3902                  htim->Instance->CCMR2 |= TIM_CCMR2_OC4CE;
   3903                }
   3904                else
   3905                {
   3906                  /* Disable the Ocref clear feature for Channel 4 */
   3907                  htim->Instance->CCMR2 &= ~TIM_CCMR2_OC4CE;      
   \                     ??HAL_TIM_ConfigOCrefClear_8: (+1)
   \   00000088   0x61C1             STR      R1,[R0, #+28]
   3908                }
   3909              } 
   3910              break;
   3911              default:  
   3912              break;
   3913            } 
   3914          
   3915            htim->State = HAL_TIM_STATE_READY;
   \                     ??HAL_TIM_ConfigOCrefClear_6: (+1)
   \   0000008A   0x2001             MOVS     R0,#+1
   \   0000008C   0x7068             STRB     R0,[R5, #+1]
   3916            
   3917            __HAL_UNLOCK(htim);
   \   0000008E   0x2000             MOVS     R0,#+0
   \   00000090   0x7028             STRB     R0,[R5, #+0]
   3918            
   3919            return HAL_OK;  
   \   00000092   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   3920          }  

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine63: (+1)
   \   00000000   0x6830             LDR      R0,[R6, #+0]
   \   00000002   0x6821             LDR      R1,[R4, #+0]
   \   00000004   0x2900             CMP      R1,#+0
   \   00000006   0x4770             BX       LR
   3921          
   3922          /**
   3923            * @brief   Configures the clock source to be used
   3924            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   3925            *                the configuration information for TIM module.
   3926            * @param  sClockSourceConfig: pointer to a TIM_ClockConfigTypeDef structure that
   3927            *         contains the clock source information for the TIM peripheral. 
   3928            * @retval HAL status
   3929            */ 

   \                                 In section .text, align 2, keep-with-next
   3930          HAL_StatusTypeDef HAL_TIM_ConfigClockSource(TIM_HandleTypeDef *htim, TIM_ClockConfigTypeDef * sClockSourceConfig)    
   3931          {
   \                     HAL_TIM_ConfigClockSource: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4605             MOV      R5,R0
   3932            uint32_t tmpsmcr = 0;
   3933              
   3934            /* Process Locked */
   3935            __HAL_LOCK(htim);
   \   00000004   0xF105 0x0438      ADD      R4,R5,#+56
   \   00000008   0x7820             LDRB     R0,[R4, #+0]
   \   0000000A   0x2801             CMP      R0,#+1
   \   0000000C   0xD101             BNE.N    ??HAL_TIM_ConfigClockSource_0
   \   0000000E   0x2002             MOVS     R0,#+2
   \   00000010   0xBD32             POP      {R1,R4,R5,PC}
   \                     ??HAL_TIM_ConfigClockSource_0: (+1)
   \   00000012   0x2001             MOVS     R0,#+1
   3936            
   3937            htim->State = HAL_TIM_STATE_BUSY;
   3938            
   3939            /* Check the parameters */
   3940            assert_param(IS_TIM_CLOCKSOURCE(sClockSourceConfig->ClockSource));
   3941            assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
   3942            assert_param(IS_TIM_CLOCKPRESCALER(sClockSourceConfig->ClockPrescaler));
   3943            assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
   3944            
   3945            /* Reset the SMS, TS, ECE, ETPS and ETRF bits */
   3946            tmpsmcr = htim->Instance->SMCR;
   3947            tmpsmcr &= ~(TIM_SMCR_SMS | TIM_SMCR_TS);
   3948            tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
   3949            htim->Instance->SMCR = tmpsmcr;
   \   00000014   0x.... 0x....      LDR.W    R3,??DataTable29_1  ;; 0xfffe0088
   \   00000018   0x7020             STRB     R0,[R4, #+0]
   \   0000001A   0x2002             MOVS     R0,#+2
   \   0000001C   0x7060             STRB     R0,[R4, #+1]
   \   0000001E   0x6828             LDR      R0,[R5, #+0]
   \   00000020   0x6882             LDR      R2,[R0, #+8]
   \   00000022   0x401A             ANDS     R2,R3,R2
   \   00000024   0x6082             STR      R2,[R0, #+8]
   3950            
   3951            switch (sClockSourceConfig->ClockSource)
   \   00000026   0x6808             LDR      R0,[R1, #+0]
   \   00000028   0x2800             CMP      R0,#+0
   \   0000002A   0xD03A             BEQ.N    ??HAL_TIM_ConfigClockSource_1
   \   0000002C   0x2810             CMP      R0,#+16
   \   0000002E   0xD03A             BEQ.N    ??HAL_TIM_ConfigClockSource_2
   \   00000030   0x2820             CMP      R0,#+32
   \   00000032   0xD03A             BEQ.N    ??HAL_TIM_ConfigClockSource_3
   \   00000034   0x2830             CMP      R0,#+48
   \   00000036   0xD03A             BEQ.N    ??HAL_TIM_ConfigClockSource_4
   \   00000038   0x2840             CMP      R0,#+64
   \   0000003A   0xD02E             BEQ.N    ??HAL_TIM_ConfigClockSource_5
   \   0000003C   0x2850             CMP      R0,#+80
   \   0000003E   0xD021             BEQ.N    ??HAL_TIM_ConfigClockSource_6
   \   00000040   0x2860             CMP      R0,#+96
   \   00000042   0xD023             BEQ.N    ??HAL_TIM_ConfigClockSource_7
   \   00000044   0x2870             CMP      R0,#+112
   \   00000046   0xD00B             BEQ.N    ??HAL_TIM_ConfigClockSource_8
   \   00000048   0xF5B0 0x5F80      CMP      R0,#+4096
   \   0000004C   0xD003             BEQ.N    ??HAL_TIM_ConfigClockSource_9
   \   0000004E   0xF5B0 0x5F00      CMP      R0,#+8192
   \   00000052   0xD00F             BEQ.N    ??HAL_TIM_ConfigClockSource_10
   \   00000054   0xE02F             B.N      ??HAL_TIM_ConfigClockSource_11
   3952            {
   3953              case TIM_CLOCKSOURCE_INTERNAL:
   3954              { 
   3955                assert_param(IS_TIM_INSTANCE(htim->Instance));      
   3956                /* Disable slave mode to clock the prescaler directly with the internal clock */
   3957                htim->Instance->SMCR &= ~TIM_SMCR_SMS;
   \                     ??HAL_TIM_ConfigClockSource_9: (+1)
   \   00000056   0x6828             LDR      R0,[R5, #+0]
   \   00000058   0x....             LDR.N    R2,??DataTable22  ;; 0xfffefff8
   \   0000005A   0x6881             LDR      R1,[R0, #+8]
   \   0000005C   0x4011             ANDS     R1,R2,R1
   \   0000005E   0xE00F             B.N      ??HAL_TIM_ConfigClockSource_12
   3958              }
   3959              break;
   3960              
   3961              case TIM_CLOCKSOURCE_ETRMODE1:
   3962              {
   3963                assert_param(IS_TIM_ETR_INSTANCE(htim->Instance));
   3964                /* Configure the ETR Clock source */
   3965                TIM_ETR_SetConfig(htim->Instance, 
   3966                                  sClockSourceConfig->ClockPrescaler, 
   3967                                  sClockSourceConfig->ClockPolarity, 
   3968                                  sClockSourceConfig->ClockFilter);
   \                     ??HAL_TIM_ConfigClockSource_8: (+1)
   \   00000060   0x.... 0x....      BL       ?Subroutine66
   3969                /* Get the TIMx SMCR register value */
   3970                tmpsmcr = htim->Instance->SMCR;
   \                     ??CrossCallReturnLabel_212: (+1)
   \   00000064   0x6828             LDR      R0,[R5, #+0]
   3971                /* Reset the SMS and TS Bits */
   3972                tmpsmcr &= ~(TIM_SMCR_SMS | TIM_SMCR_TS);
   3973                /* Select the External clock mode1 and the ETRF trigger */
   3974                tmpsmcr |= (TIM_SLAVEMODE_EXTERNAL1 | TIM_CLOCKSOURCE_ETRMODE1);
   3975                /* Write to TIMx SMCR */
   3976                htim->Instance->SMCR = tmpsmcr;
   \   00000066   0x.... 0x....      LDR.W    R2,??DataTable29_2  ;; 0xfffeff88
   \   0000006A   0x6881             LDR      R1,[R0, #+8]
   \   0000006C   0x4011             ANDS     R1,R2,R1
   \   0000006E   0xF041 0x0177      ORR      R1,R1,#0x77
   \   00000072   0xE005             B.N      ??HAL_TIM_ConfigClockSource_12
   3977              }
   3978              break;
   3979              
   3980              case TIM_CLOCKSOURCE_ETRMODE2:
   3981              {
   3982                assert_param(IS_TIM_ETR_INSTANCE(htim->Instance));
   3983                /* Configure the ETR Clock source */
   3984                TIM_ETR_SetConfig(htim->Instance, 
   3985                                  sClockSourceConfig->ClockPrescaler, 
   3986                                  sClockSourceConfig->ClockPolarity,
   3987                                  sClockSourceConfig->ClockFilter);
   \                     ??HAL_TIM_ConfigClockSource_10: (+1)
   \   00000074   0x.... 0x....      BL       ?Subroutine66
   3988                /* Enable the External clock mode2 */
   3989                htim->Instance->SMCR |= TIM_SMCR_ECE;
   \                     ??CrossCallReturnLabel_211: (+1)
   \   00000078   0x6828             LDR      R0,[R5, #+0]
   \   0000007A   0x6881             LDR      R1,[R0, #+8]
   \   0000007C   0xF441 0x4180      ORR      R1,R1,#0x4000
   \                     ??HAL_TIM_ConfigClockSource_12: (+1)
   \   00000080   0x6081             STR      R1,[R0, #+8]
   3990              }
   3991              break;
   \   00000082   0xE018             B.N      ??HAL_TIM_ConfigClockSource_11
   3992              
   3993              case TIM_CLOCKSOURCE_TI1:
   3994              {
   3995                assert_param(IS_TIM_CLOCKSOURCE_TIX_INSTANCE(htim->Instance));
   3996                TIM_TI1_ConfigInputStage(htim->Instance, 
   3997                                  sClockSourceConfig->ClockPolarity, 
   3998                                  sClockSourceConfig->ClockFilter);
   \                     ??HAL_TIM_ConfigClockSource_6: (+1)
   \   00000084   0x.... 0x....      BL       ?Subroutine68
   3999                TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI1);
   \                     ??CrossCallReturnLabel_217: (+1)
   \   00000088   0x2150             MOVS     R1,#+80
   \   0000008A   0xE011             B.N      ??HAL_TIM_ConfigClockSource_13
   4000              }
   4001              break;
   4002              case TIM_CLOCKSOURCE_TI2:
   4003              {
   4004                assert_param(IS_TIM_CLOCKSOURCE_TIX_INSTANCE(htim->Instance));
   4005                TIM_TI2_ConfigInputStage(htim->Instance, 
   4006                                  sClockSourceConfig->ClockPolarity, 
   4007                                  sClockSourceConfig->ClockFilter);
   \                     ??HAL_TIM_ConfigClockSource_7: (+1)
   \   0000008C   0x68CA             LDR      R2,[R1, #+12]
   \   0000008E   0x6849             LDR      R1,[R1, #+4]
   \   00000090   0x6828             LDR      R0,[R5, #+0]
   \   00000092   0x.... 0x....      BL       TIM_TI2_ConfigInputStage
   4008                TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI2);
   \   00000096   0x2160             MOVS     R1,#+96
   \   00000098   0xE00A             B.N      ??HAL_TIM_ConfigClockSource_13
   4009              }
   4010              break;
   4011              case TIM_CLOCKSOURCE_TI1ED:
   4012              {
   4013                assert_param(IS_TIM_CLOCKSOURCE_TIX_INSTANCE(htim->Instance));
   4014                TIM_TI1_ConfigInputStage(htim->Instance, 
   4015                                  sClockSourceConfig->ClockPolarity,
   4016                                  sClockSourceConfig->ClockFilter);
   \                     ??HAL_TIM_ConfigClockSource_5: (+1)
   \   0000009A   0x.... 0x....      BL       ?Subroutine68
   4017                TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI1ED);
   \                     ??CrossCallReturnLabel_216: (+1)
   \   0000009E   0x2140             MOVS     R1,#+64
   \   000000A0   0xE006             B.N      ??HAL_TIM_ConfigClockSource_13
   4018              }
   4019              break;
   4020              case TIM_CLOCKSOURCE_ITR0:
   4021              {
   4022                assert_param(IS_TIM_CLOCKSOURCE_ITRX_INSTANCE(htim->Instance));
   4023                TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_ITR0);
   \                     ??HAL_TIM_ConfigClockSource_1: (+1)
   \   000000A2   0x2100             MOVS     R1,#+0
   \   000000A4   0xE004             B.N      ??HAL_TIM_ConfigClockSource_13
   4024              }
   4025              break;
   4026              case TIM_CLOCKSOURCE_ITR1:
   4027              {
   4028                assert_param(IS_TIM_CLOCKSOURCE_ITRX_INSTANCE(htim->Instance));
   4029                TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_ITR1);
   \                     ??HAL_TIM_ConfigClockSource_2: (+1)
   \   000000A6   0x2110             MOVS     R1,#+16
   \   000000A8   0xE002             B.N      ??HAL_TIM_ConfigClockSource_13
   4030              }
   4031              break;
   4032              case TIM_CLOCKSOURCE_ITR2:
   4033              {
   4034                assert_param(IS_TIM_CLOCKSOURCE_ITRX_INSTANCE(htim->Instance));
   4035                TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_ITR2);
   \                     ??HAL_TIM_ConfigClockSource_3: (+1)
   \   000000AA   0x2120             MOVS     R1,#+32
   \   000000AC   0xE000             B.N      ??HAL_TIM_ConfigClockSource_13
   4036              }
   4037              break;
   4038              case TIM_CLOCKSOURCE_ITR3:
   4039              {
   4040                assert_param(IS_TIM_CLOCKSOURCE_ITRX_INSTANCE(htim->Instance));
   4041                TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_ITR3);
   \                     ??HAL_TIM_ConfigClockSource_4: (+1)
   \   000000AE   0x2130             MOVS     R1,#+48
   \                     ??HAL_TIM_ConfigClockSource_13: (+1)
   \   000000B0   0x6828             LDR      R0,[R5, #+0]
   \   000000B2   0x.... 0x....      BL       TIM_ITRx_SetConfig
   4042              }
   4043              break;
   4044              
   4045              default:
   4046              break;    
   4047            }
   4048            htim->State = HAL_TIM_STATE_READY;
   \                     ??HAL_TIM_ConfigClockSource_11: (+1)
   \   000000B6   0x....             B.N      ?Subroutine10
   4049            
   4050            __HAL_UNLOCK(htim);
   4051            
   4052            return HAL_OK;
   4053          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine68: (+1)
   \   00000000   0x68CA             LDR      R2,[R1, #+12]
   \   00000002   0x6849             LDR      R1,[R1, #+4]
   \   00000004   0x6828             LDR      R0,[R5, #+0]
   \   00000006   0x....             B.N      TIM_TI1_ConfigInputStage

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine66: (+1)
   \   00000000   0x68CB             LDR      R3,[R1, #+12]
   \   00000002   0x684A             LDR      R2,[R1, #+4]
   \   00000004   0x6889             LDR      R1,[R1, #+8]
   \   00000006   0x6828             LDR      R0,[R5, #+0]
   \   00000008   0x....             B.N      TIM_ETR_SetConfig

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine10: (+1)
   \   00000000   0x.... 0x....      BL       ?Subroutine14
   \                     ??CrossCallReturnLabel_18: (+1)
   \   00000004   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   4054          
   4055          /**
   4056            * @brief  Selects the signal connected to the TI1 input: direct from CH1_input
   4057            *         or a XOR combination between CH1_input, CH2_input & CH3_input
   4058            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   4059            *                the configuration information for TIM module.
   4060            * @param  TI1_Selection: Indicate whether or not channel 1 is connected to the
   4061            *         output of a XOR gate.
   4062            *         This parameter can be one of the following values:
   4063            *            @arg TIM_TI1SELECTION_CH1: The TIMx_CH1 pin is connected to TI1 input
   4064            *            @arg TIM_TI1SELECTION_XORCOMBINATION: The TIMx_CH1, CH2 and CH3
   4065            *            pins are connected to the TI1 input (XOR combination)
   4066            * @retval HAL status
   4067            */

   \                                 In section .text, align 2, keep-with-next
   4068          HAL_StatusTypeDef HAL_TIM_ConfigTI1Input(TIM_HandleTypeDef *htim, uint32_t TI1_Selection)
   4069          {
   4070            uint32_t tmpcr2 = 0;
   4071            
   4072            /* Check the parameters */
   4073            assert_param(IS_TIM_XOR_INSTANCE(htim->Instance)); 
   4074            assert_param(IS_TIM_TI1SELECTION(TI1_Selection));
   4075          
   4076            /* Get the TIMx CR2 register value */
   4077            tmpcr2 = htim->Instance->CR2;
   \                     HAL_TIM_ConfigTI1Input: (+1)
   \   00000000   0x6800             LDR      R0,[R0, #+0]
   \   00000002   0x6842             LDR      R2,[R0, #+4]
   4078          
   4079            /* Reset the TI1 selection */
   4080            tmpcr2 &= ~TIM_CR2_TI1S;
   4081          
   4082            /* Set the TI1 selection */
   4083            tmpcr2 |= TI1_Selection;
   4084            
   4085            /* Write to TIMxCR2 */
   4086            htim->Instance->CR2 = tmpcr2;
   \   00000004   0xF022 0x0280      BIC      R2,R2,#0x80
   \   00000008   0x4311             ORRS     R1,R1,R2
   \   0000000A   0x6041             STR      R1,[R0, #+4]
   4087          
   4088            return HAL_OK;
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x4770             BX       LR               ;; return
   4089          }
   4090          
   4091          /**
   4092            * @brief  Configures the TIM in Slave mode
   4093            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   4094            *                the configuration information for TIM module.
   4095            * @param  sSlaveConfig: pointer to a TIM_SlaveConfigTypeDef structure that
   4096            *         contains the selected trigger (internal trigger input, filtered
   4097            *         timer input or external trigger input) and the ) and the Slave 
   4098            *         mode (Disable, Reset, Gated, Trigger, External clock mode 1). 
   4099            * @retval HAL status
   4100            */

   \                                 In section .text, align 2, keep-with-next
   4101          HAL_StatusTypeDef HAL_TIM_SlaveConfigSynchronization(TIM_HandleTypeDef *htim, TIM_SlaveConfigTypeDef * sSlaveConfig)
   4102          {
   \                     HAL_TIM_SlaveConfigSynchronization: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   4103            uint32_t tmpsmcr  = 0;
   4104            uint32_t tmpccmr1 = 0;
   4105            uint32_t tmpccer = 0;
   4106          
   4107            /* Check the parameters */
   4108            assert_param(IS_TIM_SLAVE_INSTANCE(htim->Instance));
   4109            assert_param(IS_TIM_SLAVE_MODE(sSlaveConfig->SlaveMode));
   4110            assert_param(IS_TIM_TRIGGER_SELECTION(sSlaveConfig->InputTrigger));
   4111             
   4112            __HAL_LOCK(htim);
   \   00000002   0xF100 0x0438      ADD      R4,R0,#+56
   \   00000006   0x7822             LDRB     R2,[R4, #+0]
   \   00000008   0x2A01             CMP      R2,#+1
   \   0000000A   0xD101             BNE.N    ??HAL_TIM_SlaveConfigSynchronization_0
   \   0000000C   0x2002             MOVS     R0,#+2
   \   0000000E   0xBD32             POP      {R1,R4,R5,PC}
   \                     ??HAL_TIM_SlaveConfigSynchronization_0: (+1)
   \   00000010   0x2201             MOVS     R2,#+1
   \   00000012   0x7022             STRB     R2,[R4, #+0]
   4113            
   4114            htim->State = HAL_TIM_STATE_BUSY;
   \   00000014   0x2202             MOVS     R2,#+2
   \   00000016   0x7062             STRB     R2,[R4, #+1]
   4115          
   4116            /* Get the TIMx SMCR register value */
   4117            tmpsmcr = htim->Instance->SMCR;
   \   00000018   0x6802             LDR      R2,[R0, #+0]
   \   0000001A   0x6893             LDR      R3,[R2, #+8]
   4118          
   4119            /* Reset the Trigger Selection Bits */
   4120            tmpsmcr &= ~TIM_SMCR_TS;
   4121            /* Set the Input Trigger source */
   4122            tmpsmcr |= sSlaveConfig->InputTrigger;
   4123          
   4124            /* Reset the slave mode Bits */
   4125            tmpsmcr &= ~TIM_SMCR_SMS;
   4126            /* Set the slave mode */
   4127            tmpsmcr |= sSlaveConfig->SlaveMode;
   4128          
   4129            /* Write to TIMx SMCR */
   4130            htim->Instance->SMCR = tmpsmcr;
   \   0000001C   0x684D             LDR      R5,[R1, #+4]
   \   0000001E   0xF023 0x0370      BIC      R3,R3,#0x70
   \   00000022   0x432B             ORRS     R3,R5,R3
   \   00000024   0x....             LDR.N    R5,??DataTable22  ;; 0xfffefff8
   \   00000026   0x402B             ANDS     R3,R5,R3
   \   00000028   0x680D             LDR      R5,[R1, #+0]
   \   0000002A   0x432B             ORRS     R3,R5,R3
   \   0000002C   0x6093             STR      R3,[R2, #+8]
   4131            
   4132            /* Configure the trigger prescaler, filter, and polarity */
   4133            switch (sSlaveConfig->InputTrigger)
   \   0000002E   0x684A             LDR      R2,[R1, #+4]
   \   00000030   0x2A40             CMP      R2,#+64
   \   00000032   0xD00C             BEQ.N    ??HAL_TIM_SlaveConfigSynchronization_1
   \   00000034   0x2A50             CMP      R2,#+80
   \   00000036   0xD01B             BEQ.N    ??HAL_TIM_SlaveConfigSynchronization_2
   \   00000038   0x2A60             CMP      R2,#+96
   \   0000003A   0xD01F             BEQ.N    ??HAL_TIM_SlaveConfigSynchronization_3
   \   0000003C   0x2A70             CMP      R2,#+112
   \   0000003E   0xD122             BNE.N    ??HAL_TIM_SlaveConfigSynchronization_4
   4134            {
   4135            case TIM_TS_ETRF:
   4136              {
   4137                /* Check the parameters */
   4138                assert_param(IS_TIM_ETR_INSTANCE(htim->Instance));
   4139                assert_param(IS_TIM_TRIGGERPRESCALER(sSlaveConfig->TriggerPrescaler));
   4140                assert_param(IS_TIM_TRIGGERPOLARITY(sSlaveConfig->TriggerPolarity));
   4141                assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
   4142                /* Configure the ETR Trigger source */
   4143                TIM_ETR_SetConfig(htim->Instance, 
   4144                                  sSlaveConfig->TriggerPrescaler, 
   4145                                  sSlaveConfig->TriggerPolarity, 
   4146                                  sSlaveConfig->TriggerFilter);
   \   00000040   0x690B             LDR      R3,[R1, #+16]
   \   00000042   0x688A             LDR      R2,[R1, #+8]
   \   00000044   0x68C9             LDR      R1,[R1, #+12]
   \   00000046   0x6800             LDR      R0,[R0, #+0]
   \   00000048   0x.... 0x....      BL       TIM_ETR_SetConfig
   4147              }
   4148              break;
   \   0000004C   0xE01B             B.N      ??HAL_TIM_SlaveConfigSynchronization_4
   4149              
   4150            case TIM_TS_TI1F_ED:
   4151              {
   4152                /* Check the parameters */
   4153                assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   4154                assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
   4155                
   4156                /* Disable the Channel 1: Reset the CC1E Bit */
   4157                tmpccer = htim->Instance->CCER;
   \                     ??HAL_TIM_SlaveConfigSynchronization_1: (+1)
   \   0000004E   0x6802             LDR      R2,[R0, #+0]
   \   00000050   0x6A13             LDR      R3,[R2, #+32]
   4158                htim->Instance->CCER &= ~TIM_CCER_CC1E;
   \   00000052   0x6A15             LDR      R5,[R2, #+32]
   \   00000054   0x086D             LSRS     R5,R5,#+1
   \   00000056   0x006D             LSLS     R5,R5,#+1
   \   00000058   0x6215             STR      R5,[R2, #+32]
   4159                tmpccmr1 = htim->Instance->CCMR1;    
   \   0000005A   0x6802             LDR      R2,[R0, #+0]
   \   0000005C   0x6995             LDR      R5,[R2, #+24]
   4160                
   4161                /* Set the filter */
   4162                tmpccmr1 &= ~TIM_CCMR1_IC1F;
   4163                tmpccmr1 |= ((sSlaveConfig->TriggerFilter) << 4);
   4164                
   4165                /* Write to TIMx CCMR1 and CCER registers */
   4166                htim->Instance->CCMR1 = tmpccmr1;
   \   0000005E   0x6909             LDR      R1,[R1, #+16]
   \   00000060   0xF025 0x05F0      BIC      R5,R5,#0xF0
   \   00000064   0xEA45 0x1101      ORR      R1,R5,R1, LSL #+4
   \   00000068   0x6191             STR      R1,[R2, #+24]
   4167                htim->Instance->CCER = tmpccer;                               
   \   0000006A   0x6800             LDR      R0,[R0, #+0]
   \   0000006C   0x6203             STR      R3,[R0, #+32]
   4168                                         
   4169              }
   4170              break;
   \   0000006E   0xE00A             B.N      ??HAL_TIM_SlaveConfigSynchronization_4
   4171              
   4172            case TIM_TS_TI1FP1:
   4173              {
   4174                /* Check the parameters */
   4175                assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   4176                assert_param(IS_TIM_TRIGGERPOLARITY(sSlaveConfig->TriggerPolarity));
   4177                assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
   4178          
   4179                /* Configure TI1 Filter and Polarity */
   4180                TIM_TI1_ConfigInputStage(htim->Instance,
   4181                                         sSlaveConfig->TriggerPolarity,
   4182                                         sSlaveConfig->TriggerFilter);
   \                     ??HAL_TIM_SlaveConfigSynchronization_2: (+1)
   \   00000070   0x690A             LDR      R2,[R1, #+16]
   \   00000072   0x6889             LDR      R1,[R1, #+8]
   \   00000074   0x6800             LDR      R0,[R0, #+0]
   \   00000076   0x.... 0x....      BL       TIM_TI1_ConfigInputStage
   4183              }
   4184              break;
   \   0000007A   0xE004             B.N      ??HAL_TIM_SlaveConfigSynchronization_4
   4185              
   4186            case TIM_TS_TI2FP2:
   4187              {
   4188                /* Check the parameters */
   4189                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   4190                assert_param(IS_TIM_TRIGGERPOLARITY(sSlaveConfig->TriggerPolarity));
   4191                assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
   4192                
   4193                /* Configure TI2 Filter and Polarity */
   4194                TIM_TI2_ConfigInputStage(htim->Instance,
   4195                                          sSlaveConfig->TriggerPolarity,
   4196                                          sSlaveConfig->TriggerFilter);
   \                     ??HAL_TIM_SlaveConfigSynchronization_3: (+1)
   \   0000007C   0x690A             LDR      R2,[R1, #+16]
   \   0000007E   0x6889             LDR      R1,[R1, #+8]
   \   00000080   0x6800             LDR      R0,[R0, #+0]
   \   00000082   0x.... 0x....      BL       TIM_TI2_ConfigInputStage
   4197              }
   4198              break;
   4199              
   4200            case TIM_TS_ITR0:
   4201              {
   4202                /* Check the parameter */
   4203                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   4204              }
   4205              break;
   4206              
   4207            case TIM_TS_ITR1:
   4208              {
   4209                /* Check the parameter */
   4210                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   4211              }
   4212              break;
   4213              
   4214            case TIM_TS_ITR2:
   4215              {
   4216                /* Check the parameter */
   4217                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   4218              }
   4219              break;
   4220              
   4221            case TIM_TS_ITR3:
   4222              {
   4223                /* Check the parameter */
   4224                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   4225              }
   4226              break;
   4227                 
   4228            default:
   4229              break;
   4230            }
   4231            
   4232            htim->State = HAL_TIM_STATE_READY;
   \                     ??HAL_TIM_SlaveConfigSynchronization_4: (+1)
   \   00000086                      REQUIRE ?Subroutine10
   \   00000086                      ;; // Fall through to label ?Subroutine10
   4233               
   4234            __HAL_UNLOCK(htim);  
   4235            
   4236            return HAL_OK;
   4237          } 
   4238          
   4239          /**
   4240            * @brief  Configures the TIM in Slave mode in interrupt mode
   4241            * @param  htim: TIM handle.
   4242            * @param  sSlaveConfig: pointer to a TIM_SlaveConfigTypeDef structure that
   4243            *         contains the selected trigger (internal trigger input, filtered
   4244            *         timer input or external trigger input) and the ) and the Slave 
   4245            *         mode (Disable, Reset, Gated, Trigger, External clock mode 1). 
   4246            * @retval HAL status
   4247            */

   \                                 In section .text, align 2, keep-with-next
   4248          HAL_StatusTypeDef HAL_TIM_SlaveConfigSynchronization_IT(TIM_HandleTypeDef *htim, 
   4249                                                                  TIM_SlaveConfigTypeDef * sSlaveConfig)
   4250          {
   \                     HAL_TIM_SlaveConfigSynchronization_IT: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   4251            /* Check the parameters */
   4252            assert_param(IS_TIM_SLAVE_INSTANCE(htim->Instance));
   4253            assert_param(IS_TIM_SLAVE_MODE(sSlaveConfig->SlaveMode));
   4254            assert_param(IS_TIM_TRIGGER_SELECTION(sSlaveConfig->InputTrigger));
   4255            
   4256            __HAL_LOCK(htim);
   \   00000004   0xF104 0x0538      ADD      R5,R4,#+56
   \   00000008   0x7828             LDRB     R0,[R5, #+0]
   \   0000000A   0x2801             CMP      R0,#+1
   \   0000000C   0xD101             BNE.N    ??HAL_TIM_SlaveConfigSynchronization_IT_0
   \   0000000E   0x2002             MOVS     R0,#+2
   \   00000010   0xBD32             POP      {R1,R4,R5,PC}
   \                     ??HAL_TIM_SlaveConfigSynchronization_IT_0: (+1)
   \   00000012   0x2001             MOVS     R0,#+1
   \   00000014   0x7028             STRB     R0,[R5, #+0]
   4257          
   4258            htim->State = HAL_TIM_STATE_BUSY;
   \   00000016   0x2002             MOVS     R0,#+2
   \   00000018   0x7068             STRB     R0,[R5, #+1]
   4259            
   4260            TIM_SlaveTimer_SetConfig(htim, sSlaveConfig);
   \   0000001A   0x6820             LDR      R0,[R4, #+0]
   \   0000001C   0x6882             LDR      R2,[R0, #+8]
   \   0000001E   0x684B             LDR      R3,[R1, #+4]
   \   00000020   0xF022 0x0270      BIC      R2,R2,#0x70
   \   00000024   0x431A             ORRS     R2,R3,R2
   \   00000026   0x....             LDR.N    R3,??DataTable22  ;; 0xfffefff8
   \   00000028   0x401A             ANDS     R2,R3,R2
   \   0000002A   0x680B             LDR      R3,[R1, #+0]
   \   0000002C   0x431A             ORRS     R2,R3,R2
   \   0000002E   0x6082             STR      R2,[R0, #+8]
   \   00000030   0x6848             LDR      R0,[R1, #+4]
   \   00000032   0x2840             CMP      R0,#+64
   \   00000034   0xD012             BEQ.N    ??HAL_TIM_SlaveConfigSynchronization_IT_1
   \   00000036   0x2850             CMP      R0,#+80
   \   00000038   0xD00A             BEQ.N    ??HAL_TIM_SlaveConfigSynchronization_IT_2
   \   0000003A   0x2860             CMP      R0,#+96
   \   0000003C   0xD002             BEQ.N    ??HAL_TIM_SlaveConfigSynchronization_IT_3
   \   0000003E   0x2870             CMP      R0,#+112
   \   00000040   0xD01D             BEQ.N    ??HAL_TIM_SlaveConfigSynchronization_IT_4
   \   00000042   0xE022             B.N      ??HAL_TIM_SlaveConfigSynchronization_IT_5
   \                     ??HAL_TIM_SlaveConfigSynchronization_IT_3: (+1)
   \   00000044   0x690A             LDR      R2,[R1, #+16]
   \   00000046   0x6889             LDR      R1,[R1, #+8]
   \   00000048   0x6820             LDR      R0,[R4, #+0]
   \   0000004A   0x.... 0x....      BL       TIM_TI2_ConfigInputStage
   \   0000004E   0xE01C             B.N      ??HAL_TIM_SlaveConfigSynchronization_IT_5
   \                     ??HAL_TIM_SlaveConfigSynchronization_IT_2: (+1)
   \   00000050   0x690A             LDR      R2,[R1, #+16]
   \   00000052   0x6889             LDR      R1,[R1, #+8]
   \   00000054   0x6820             LDR      R0,[R4, #+0]
   \   00000056   0x.... 0x....      BL       TIM_TI1_ConfigInputStage
   \   0000005A   0xE016             B.N      ??HAL_TIM_SlaveConfigSynchronization_IT_5
   \                     ??HAL_TIM_SlaveConfigSynchronization_IT_1: (+1)
   \   0000005C   0x6820             LDR      R0,[R4, #+0]
   \   0000005E   0x6A02             LDR      R2,[R0, #+32]
   \   00000060   0x6A03             LDR      R3,[R0, #+32]
   \   00000062   0x085B             LSRS     R3,R3,#+1
   \   00000064   0x005B             LSLS     R3,R3,#+1
   \   00000066   0x6203             STR      R3,[R0, #+32]
   \   00000068   0x6820             LDR      R0,[R4, #+0]
   \   0000006A   0x6983             LDR      R3,[R0, #+24]
   \   0000006C   0x6909             LDR      R1,[R1, #+16]
   \   0000006E   0xF023 0x03F0      BIC      R3,R3,#0xF0
   \   00000072   0xEA43 0x1101      ORR      R1,R3,R1, LSL #+4
   \   00000076   0x6181             STR      R1,[R0, #+24]
   \   00000078   0x6820             LDR      R0,[R4, #+0]
   \   0000007A   0x6202             STR      R2,[R0, #+32]
   \   0000007C   0xE005             B.N      ??HAL_TIM_SlaveConfigSynchronization_IT_5
   \                     ??HAL_TIM_SlaveConfigSynchronization_IT_4: (+1)
   \   0000007E   0x690B             LDR      R3,[R1, #+16]
   \   00000080   0x688A             LDR      R2,[R1, #+8]
   \   00000082   0x68C9             LDR      R1,[R1, #+12]
   \   00000084   0x6820             LDR      R0,[R4, #+0]
   \   00000086   0x.... 0x....      BL       TIM_ETR_SetConfig
   4261            
   4262            /* Enable Trigger Interrupt */
   4263            __HAL_TIM_ENABLE_IT(htim, TIM_IT_TRIGGER);
   \                     ??HAL_TIM_SlaveConfigSynchronization_IT_5: (+1)
   \   0000008A   0x6820             LDR      R0,[R4, #+0]
   \   0000008C   0x68C1             LDR      R1,[R0, #+12]
   \   0000008E   0xF041 0x0140      ORR      R1,R1,#0x40
   \   00000092   0x60C1             STR      R1,[R0, #+12]
   4264            
   4265            /* Disable Trigger DMA request */
   4266            __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_TRIGGER);
   \   00000094   0x6820             LDR      R0,[R4, #+0]
   \   00000096   0x68C1             LDR      R1,[R0, #+12]
   \   00000098   0xF421 0x4180      BIC      R1,R1,#0x4000
   \   0000009C   0x60C1             STR      R1,[R0, #+12]
   4267            
   4268            htim->State = HAL_TIM_STATE_READY;
   \   0000009E   0x2001             MOVS     R0,#+1
   \   000000A0   0x7068             STRB     R0,[R5, #+1]
   4269               
   4270            __HAL_UNLOCK(htim);  
   \   000000A2   0x2000             MOVS     R0,#+0
   \   000000A4   0x7028             STRB     R0,[R5, #+0]
   4271            
   4272            return HAL_OK;
   \   000000A6   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   4273          }
   4274          
   4275          /**
   4276            * @brief  Read the captured value from Capture Compare unit
   4277            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   4278            *                the configuration information for TIM module.
   4279            * @param  Channel: TIM Channels to be enabled.
   4280            *          This parameter can be one of the following values:
   4281            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   4282            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   4283            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   4284            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   4285            * @retval Captured value
   4286            */

   \                                 In section .text, align 2, keep-with-next
   4287          uint32_t HAL_TIM_ReadCapturedValue(TIM_HandleTypeDef *htim, uint32_t Channel)
   4288          {
   4289            uint32_t tmpreg = 0;
   4290            
   4291            __HAL_LOCK(htim);
   \                     HAL_TIM_ReadCapturedValue: (+1)
   \   00000000   0xF890 0x3038      LDRB     R3,[R0, #+56]
   \   00000004   0x2200             MOVS     R2,#+0
   \   00000006   0x2B01             CMP      R3,#+1
   \   00000008   0xD101             BNE.N    ??HAL_TIM_ReadCapturedValue_0
   \   0000000A   0x2002             MOVS     R0,#+2
   \   0000000C   0x4770             BX       LR
   \                     ??HAL_TIM_ReadCapturedValue_0: (+1)
   \   0000000E   0x2301             MOVS     R3,#+1
   \   00000010   0xF880 0x3038      STRB     R3,[R0, #+56]
   4292            
   4293            switch (Channel)
   \   00000014   0xB141             CBZ.N    R1,??HAL_TIM_ReadCapturedValue_1
   \   00000016   0x2904             CMP      R1,#+4
   \   00000018   0xD009             BEQ.N    ??HAL_TIM_ReadCapturedValue_2
   \   0000001A   0x2908             CMP      R1,#+8
   \   0000001C   0xD00A             BEQ.N    ??HAL_TIM_ReadCapturedValue_3
   \   0000001E   0x290C             CMP      R1,#+12
   \   00000020   0xBF04             ITT      EQ 
   \   00000022   0x6801             LDREQ    R1,[R0, #+0]
   \   00000024   0x6C0A             LDREQ    R2,[R1, #+64]
   4294            {
   4295              case TIM_CHANNEL_1:
   4296              {
   4297                /* Check the parameters */
   4298                assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   4299                
   4300                /* Return the capture 1 value */
   4301                tmpreg = htim->Instance->CCR1;
   4302                
   4303                break;
   4304              }
   4305              case TIM_CHANNEL_2:
   4306              {
   4307                /* Check the parameters */
   4308                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   4309                
   4310                /* Return the capture 2 value */
   4311                tmpreg = htim->Instance->CCR2;
   4312                
   4313                break;
   4314              }
   4315              
   4316              case TIM_CHANNEL_3:
   4317              {
   4318                /* Check the parameters */
   4319                assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
   4320                
   4321                /* Return the capture 3 value */
   4322                tmpreg = htim->Instance->CCR3;
   4323                
   4324                break;
   4325              }
   4326              
   4327              case TIM_CHANNEL_4:
   4328              {
   4329                /* Check the parameters */
   4330                assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
   4331                
   4332                /* Return the capture 4 value */
   4333                tmpreg = htim->Instance->CCR4;
   \   00000026   0xE007             B.N      ??HAL_TIM_ReadCapturedValue_4
   \                     ??HAL_TIM_ReadCapturedValue_1: (+1)
   \   00000028   0x6801             LDR      R1,[R0, #+0]
   \   0000002A   0x6B4A             LDR      R2,[R1, #+52]
   \   0000002C   0xE004             B.N      ??HAL_TIM_ReadCapturedValue_4
   \                     ??HAL_TIM_ReadCapturedValue_2: (+1)
   \   0000002E   0x6801             LDR      R1,[R0, #+0]
   \   00000030   0x6B8A             LDR      R2,[R1, #+56]
   \   00000032   0xE001             B.N      ??HAL_TIM_ReadCapturedValue_4
   \                     ??HAL_TIM_ReadCapturedValue_3: (+1)
   \   00000034   0x6801             LDR      R1,[R0, #+0]
   \   00000036   0x6BCA             LDR      R2,[R1, #+60]
   4334                
   4335                break;
   4336              }
   4337              
   4338              default:
   4339              break;  
   4340            }
   4341               
   4342            __HAL_UNLOCK(htim);  
   \                     ??HAL_TIM_ReadCapturedValue_4: (+1)
   \   00000038   0x2100             MOVS     R1,#+0
   \   0000003A   0xF880 0x1038      STRB     R1,[R0, #+56]
   4343            return tmpreg;
   \   0000003E   0x4610             MOV      R0,R2
   \   00000040   0x4770             BX       LR               ;; return
   4344          }
   4345          
   4346          /**
   4347            * @}
   4348            */
   4349            
   4350          /** @defgroup TIM_Exported_Functions_Group9 TIM Callbacks functions
   4351           *  @brief    TIM Callbacks functions 
   4352           *
   4353          @verbatim   
   4354            ==============================================================================
   4355                                  ##### TIM Callbacks functions #####
   4356            ==============================================================================  
   4357           [..]  
   4358             This section provides TIM callback functions:
   4359             (+) Timer Period elapsed callback
   4360             (+) Timer Output Compare callback
   4361             (+) Timer Input capture callback
   4362             (+) Timer Trigger callback
   4363             (+) Timer Error callback
   4364          
   4365          @endverbatim
   4366            * @{
   4367            */
   4368          
   4369          /**
   4370            * @brief  Period elapsed callback in non blocking mode 
   4371            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   4372            *                the configuration information for TIM module.
   4373            * @retval None
   4374            */

   \                                 In section .text, align 2, keep-with-next
   4375          __weak void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
   4376          {
   4377            /* NOTE : This function Should not be modified, when the callback is needed,
   4378                      the __HAL_TIM_PeriodElapsedCallback could be implemented in the user file
   4379             */
   4380            
   4381          }
   \                     HAL_TIM_PeriodElapsedCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   4382          /**
   4383            * @brief  Output Compare callback in non blocking mode 
   4384            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   4385            *                the configuration information for TIM module.
   4386            * @retval None
   4387            */

   \                                 In section .text, align 2, keep-with-next
   4388          __weak void HAL_TIM_OC_DelayElapsedCallback(TIM_HandleTypeDef *htim)
   4389          {
   4390            /* NOTE : This function Should not be modified, when the callback is needed,
   4391                      the __HAL_TIM_OC_DelayElapsedCallback could be implemented in the user file
   4392             */
   4393          }
   \                     HAL_TIM_OC_DelayElapsedCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   4394          /**
   4395            * @brief  Input Capture callback in non blocking mode 
   4396            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   4397            *                the configuration information for TIM module.
   4398            * @retval None
   4399            */

   \                                 In section .text, align 2, keep-with-next
   4400          __weak void HAL_TIM_IC_CaptureCallback(TIM_HandleTypeDef *htim)
   4401          {
   4402            /* NOTE : This function Should not be modified, when the callback is needed,
   4403                      the __HAL_TIM_IC_CaptureCallback could be implemented in the user file
   4404             */
   4405          }
   \                     HAL_TIM_IC_CaptureCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   4406          
   4407          /**
   4408            * @brief  PWM Pulse finished callback in non blocking mode 
   4409            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   4410            *                the configuration information for TIM module.
   4411            * @retval None
   4412            */

   \                                 In section .text, align 2, keep-with-next
   4413          __weak void HAL_TIM_PWM_PulseFinishedCallback(TIM_HandleTypeDef *htim)
   4414          {
   4415            /* NOTE : This function Should not be modified, when the callback is needed,
   4416                      the __HAL_TIM_PWM_PulseFinishedCallback could be implemented in the user file
   4417             */
   4418          }
   \                     HAL_TIM_PWM_PulseFinishedCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   4419          
   4420          /**
   4421            * @brief  Hall Trigger detection callback in non blocking mode 
   4422            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   4423            *                the configuration information for TIM module.
   4424            * @retval None
   4425            */

   \                                 In section .text, align 2, keep-with-next
   4426          __weak void HAL_TIM_TriggerCallback(TIM_HandleTypeDef *htim)
   4427          {
   4428            /* NOTE : This function Should not be modified, when the callback is needed,
   4429                      the HAL_TIM_TriggerCallback could be implemented in the user file
   4430             */
   4431          }
   \                     HAL_TIM_TriggerCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   4432          
   4433          /**
   4434            * @brief  Timer error callback in non blocking mode 
   4435            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   4436            *                the configuration information for TIM module.
   4437            * @retval None
   4438            */

   \                                 In section .text, align 2, keep-with-next
   4439          __weak void HAL_TIM_ErrorCallback(TIM_HandleTypeDef *htim)
   4440          {
   4441            /* NOTE : This function Should not be modified, when the callback is needed,
   4442                      the HAL_TIM_ErrorCallback could be implemented in the user file
   4443             */
   4444          }
   \                     HAL_TIM_ErrorCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   4445          
   4446          /**
   4447            * @}
   4448            */
   4449          
   4450          /** @defgroup TIM_Exported_Functions_Group10 Peripheral State functions 
   4451           *  @brief   Peripheral State functions 
   4452           *
   4453          @verbatim   
   4454            ==============================================================================
   4455                                  ##### Peripheral State functions #####
   4456            ==============================================================================  
   4457            [..]
   4458              This subsection permits to get in run-time the status of the peripheral 
   4459              and the data flow.
   4460          
   4461          @endverbatim
   4462            * @{
   4463            */
   4464          
   4465          /**
   4466            * @brief  Return the TIM Base state
   4467            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   4468            *                the configuration information for TIM module.
   4469            * @retval HAL state
   4470            */

   \                                 In section .text, align 2, keep-with-next
   4471          HAL_TIM_StateTypeDef HAL_TIM_Base_GetState(TIM_HandleTypeDef *htim)
   4472          {
   4473            return htim->State;
   \                     HAL_TIM_Base_GetState: (+1)
   \   00000000   0x....             B.N      ?Subroutine7
   4474          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine7: (+1)
   \   00000000   0xF890 0x0039      LDRB     R0,[R0, #+57]
   \   00000004   0x4770             BX       LR               ;; return
   4475          
   4476          /**
   4477            * @brief  Return the TIM OC state
   4478            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   4479            *                the configuration information for TIM module.
   4480            * @retval HAL state
   4481            */

   \                                 In section .text, align 2, keep-with-next
   4482          HAL_TIM_StateTypeDef HAL_TIM_OC_GetState(TIM_HandleTypeDef *htim)
   \                     HAL_TIM_OC_GetState: (+1)
   \   00000000   0xBF00             Nop      
   4483          {
   4484            return htim->State;
   \   00000002                      REQUIRE ?Subroutine7
   \   00000002                      ;; // Fall through to label ?Subroutine7
   4485          }
   4486          
   4487          /**
   4488            * @brief  Return the TIM PWM state
   4489            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   4490            *                the configuration information for TIM module.
   4491            * @retval HAL state
   4492            */

   \                                 In section .text, align 2, keep-with-next
   4493          HAL_TIM_StateTypeDef HAL_TIM_PWM_GetState(TIM_HandleTypeDef *htim)
   4494          {
   4495            return htim->State;
   \                     HAL_TIM_PWM_GetState: (+1)
   \   00000000   0x....             B.N      ?Subroutine7
   4496          }
   4497          
   4498          /**
   4499            * @brief  Return the TIM Input Capture state
   4500            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   4501            *                the configuration information for TIM module.
   4502            * @retval HAL state
   4503            */

   \                                 In section .text, align 2, keep-with-next
   4504          HAL_TIM_StateTypeDef HAL_TIM_IC_GetState(TIM_HandleTypeDef *htim)
   4505          {
   4506            return htim->State;
   \                     HAL_TIM_IC_GetState: (+1)
   \   00000000   0x....             B.N      ?Subroutine7
   4507          }
   4508          
   4509          /**
   4510            * @brief  Return the TIM One Pulse Mode state
   4511            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   4512            *                the configuration information for TIM module.
   4513            * @retval HAL state
   4514            */

   \                                 In section .text, align 2, keep-with-next
   4515          HAL_TIM_StateTypeDef HAL_TIM_OnePulse_GetState(TIM_HandleTypeDef *htim)
   4516          {
   4517            return htim->State;
   \                     HAL_TIM_OnePulse_GetState: (+1)
   \   00000000   0x....             B.N      ?Subroutine7
   4518          }
   4519          
   4520          /**
   4521            * @brief  Return the TIM Encoder Mode state
   4522            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   4523            *                the configuration information for TIM module.
   4524            * @retval HAL state
   4525            */

   \                                 In section .text, align 2, keep-with-next
   4526          HAL_TIM_StateTypeDef HAL_TIM_Encoder_GetState(TIM_HandleTypeDef *htim)
   4527          {
   4528            return htim->State;
   \                     HAL_TIM_Encoder_GetState: (+1)
   \   00000000   0x....             B.N      ?Subroutine7
   4529          }
   4530          
   4531          /**
   4532            * @}
   4533            */
   4534          
   4535          /**
   4536            * @brief  TIM DMA error callback 
   4537            * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
   4538            *                the configuration information for the specified DMA module.
   4539            * @retval None
   4540            */

   \                                 In section .text, align 4, keep-with-next
   4541          void HAL_TIM_DMAError(DMA_HandleTypeDef *hdma)
   4542          {
   \                     TIM_DMAError: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   4543            TIM_HandleTypeDef* htim = ( TIM_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   \   00000002   0x.... 0x....      BL       ?Subroutine67
   4544            
   4545            htim->State= HAL_TIM_STATE_READY;
   4546             
   4547            HAL_TIM_ErrorCallback(htim);
   \                     ??CrossCallReturnLabel_213: (+1)
   \   00000006   0x.... 0x....      BL       HAL_TIM_ErrorCallback
   4548          }
   \   0000000A   0xBD01             POP      {R0,PC}          ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine67: (+1)
   \   00000000   0x6B80             LDR      R0,[R0, #+56]
   \   00000002   0x2101             MOVS     R1,#+1
   \   00000004   0xF880 0x1039      STRB     R1,[R0, #+57]
   \   00000008   0x4770             BX       LR
   4549          
   4550          /**
   4551            * @brief  TIM DMA Delay Pulse complete callback. 
   4552            * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
   4553            *                the configuration information for the specified DMA module.
   4554            * @retval None
   4555            */

   \                                 In section .text, align 4, keep-with-next
   4556          void HAL_TIM_DMADelayPulseCplt(DMA_HandleTypeDef *hdma)
   4557          {
   \                     TIM_DMADelayPulseCplt: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   4558            TIM_HandleTypeDef* htim = ( TIM_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   \   00000002   0x.... 0x....      BL       ?Subroutine59
   4559            
   4560            htim->State= HAL_TIM_STATE_READY; 
   4561            
   4562            if (hdma == htim->hdma[TIM_DMA_ID_CC1])
   \                     ??CrossCallReturnLabel_185: (+1)
   \   00000006   0xBF08             IT       EQ 
   \   00000008   0x2001             MOVEQ    R0,#+1
   4563            {
   4564              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
   \   0000000A   0xD00D             BEQ.N    ??TIM_DMADelayPulseCplt_0
   4565            }
   4566            else if (hdma == htim->hdma[TIM_DMA_ID_CC2])
   \   0000000C   0x68E2             LDR      R2,[R4, #+12]
   \   0000000E   0x4290             CMP      R0,R2
   \   00000010   0xBF08             IT       EQ 
   \   00000012   0x2002             MOVEQ    R0,#+2
   4567            {
   4568              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
   \   00000014   0xD008             BEQ.N    ??TIM_DMADelayPulseCplt_0
   4569            }
   4570            else if (hdma == htim->hdma[TIM_DMA_ID_CC3])
   \   00000016   0x6922             LDR      R2,[R4, #+16]
   \   00000018   0x4290             CMP      R0,R2
   \   0000001A   0xBF08             IT       EQ 
   \   0000001C   0x2004             MOVEQ    R0,#+4
   4571            {
   4572              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
   \   0000001E   0xD003             BEQ.N    ??TIM_DMADelayPulseCplt_0
   4573            }
   4574            else if (hdma == htim->hdma[TIM_DMA_ID_CC4])
   \   00000020   0x6962             LDR      R2,[R4, #+20]
   \   00000022   0x4290             CMP      R0,R2
   \   00000024   0xD101             BNE.N    ??TIM_DMADelayPulseCplt_1
   4575            {
   4576              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
   \   00000026   0x2008             MOVS     R0,#+8
   \                     ??TIM_DMADelayPulseCplt_0: (+1)
   \   00000028   0x7020             STRB     R0,[R4, #+0]
   4577            }
   4578          
   4579            HAL_TIM_PWM_PulseFinishedCallback(htim);
   \                     ??TIM_DMADelayPulseCplt_1: (+1)
   \   0000002A   0x4608             MOV      R0,R1
   \   0000002C   0x.... 0x....      BL       HAL_TIM_PWM_PulseFinishedCallback
   4580          
   4581            htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
   \   00000030                      REQUIRE ?Subroutine5
   \   00000030                      ;; // Fall through to label ?Subroutine5
   4582          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine59: (+1)
   \   00000000   0x6B81             LDR      R1,[R0, #+56]
   \   00000002   0x2201             MOVS     R2,#+1
   \   00000004   0xF101 0x0418      ADD      R4,R1,#+24
   \   00000008   0xF881 0x2039      STRB     R2,[R1, #+57]
   \   0000000C   0x68A2             LDR      R2,[R4, #+8]
   \   0000000E   0x4290             CMP      R0,R2
   \   00000010   0x4770             BX       LR
   4583          /**
   4584            * @brief  TIM DMA Capture complete callback. 
   4585            * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
   4586            *                the configuration information for the specified DMA module.
   4587            * @retval None
   4588            */

   \                                 In section .text, align 4, keep-with-next
   4589          void HAL_TIM_DMACaptureCplt(DMA_HandleTypeDef *hdma)
   4590          {
   \                     TIM_DMACaptureCplt: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   4591            TIM_HandleTypeDef* htim = ( TIM_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   \   00000002   0x.... 0x....      BL       ?Subroutine59
   4592              
   4593             htim->State= HAL_TIM_STATE_READY; 
   4594              
   4595            if (hdma == htim->hdma[TIM_DMA_ID_CC1])
   \                     ??CrossCallReturnLabel_186: (+1)
   \   00000006   0xBF08             IT       EQ 
   \   00000008   0x2001             MOVEQ    R0,#+1
   4596            {
   4597              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
   \   0000000A   0xD00D             BEQ.N    ??TIM_DMACaptureCplt_0
   4598            }
   4599            else if (hdma == htim->hdma[TIM_DMA_ID_CC2])
   \   0000000C   0x68E2             LDR      R2,[R4, #+12]
   \   0000000E   0x4290             CMP      R0,R2
   \   00000010   0xBF08             IT       EQ 
   \   00000012   0x2002             MOVEQ    R0,#+2
   4600            {
   4601              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
   \   00000014   0xD008             BEQ.N    ??TIM_DMACaptureCplt_0
   4602            }
   4603            else if (hdma == htim->hdma[TIM_DMA_ID_CC3])
   \   00000016   0x6922             LDR      R2,[R4, #+16]
   \   00000018   0x4290             CMP      R0,R2
   \   0000001A   0xBF08             IT       EQ 
   \   0000001C   0x2004             MOVEQ    R0,#+4
   4604            {
   4605              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
   \   0000001E   0xD003             BEQ.N    ??TIM_DMACaptureCplt_0
   4606            }
   4607            else if (hdma == htim->hdma[TIM_DMA_ID_CC4])
   \   00000020   0x6962             LDR      R2,[R4, #+20]
   \   00000022   0x4290             CMP      R0,R2
   \   00000024   0xD101             BNE.N    ??TIM_DMACaptureCplt_1
   4608            {
   4609              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
   \   00000026   0x2008             MOVS     R0,#+8
   \                     ??TIM_DMACaptureCplt_0: (+1)
   \   00000028   0x7020             STRB     R0,[R4, #+0]
   4610            }
   4611            
   4612            HAL_TIM_IC_CaptureCallback(htim); 
   \                     ??TIM_DMACaptureCplt_1: (+1)
   \   0000002A   0x4608             MOV      R0,R1
   \   0000002C   0x.... 0x....      BL       HAL_TIM_IC_CaptureCallback
   4613            
   4614            htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
   \   00000030   0x....             B.N      ?Subroutine5
   4615          
   4616          }
   4617          
   4618          /**
   4619            * @brief  TIM DMA Period Elapse complete callback. 
   4620            * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
   4621            *                the configuration information for the specified DMA module.
   4622            * @retval None
   4623            */

   \                                 In section .text, align 4, keep-with-next
   4624          static void TIM_DMAPeriodElapsedCplt(DMA_HandleTypeDef *hdma)
   4625          {
   \                     TIM_DMAPeriodElapsedCplt: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   4626            TIM_HandleTypeDef* htim = ( TIM_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   \   00000002   0x.... 0x....      BL       ?Subroutine67
   4627            
   4628            htim->State= HAL_TIM_STATE_READY;
   4629            
   4630            HAL_TIM_PeriodElapsedCallback(htim);
   \                     ??CrossCallReturnLabel_214: (+1)
   \   00000006   0x.... 0x....      BL       HAL_TIM_PeriodElapsedCallback
   4631          }
   \   0000000A   0xBD01             POP      {R0,PC}          ;; return
   4632          
   4633          /**
   4634            * @brief  TIM DMA Trigger callback. 
   4635            * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
   4636            *                the configuration information for the specified DMA module.
   4637            * @retval None
   4638            */

   \                                 In section .text, align 4, keep-with-next
   4639          static void TIM_DMATriggerCplt(DMA_HandleTypeDef *hdma)
   4640          {
   \                     TIM_DMATriggerCplt: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   4641            TIM_HandleTypeDef* htim = ( TIM_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;  
   \   00000002   0x.... 0x....      BL       ?Subroutine67
   4642            
   4643            htim->State= HAL_TIM_STATE_READY; 
   4644            
   4645            HAL_TIM_TriggerCallback(htim);
   \                     ??CrossCallReturnLabel_215: (+1)
   \   00000006   0x.... 0x....      BL       HAL_TIM_TriggerCallback
   4646          }
   \   0000000A   0xBD01             POP      {R0,PC}          ;; return
   4647          
   4648          /**
   4649            * @brief  Time Base configuration
   4650            * @param  TIMx: TIM peripheral
   4651            * @param  Structure: pointer on TIM Time Base required parameters  
   4652            * @retval None
   4653            */

   \                                 In section .text, align 2, keep-with-next
   4654          void TIM_Base_SetConfig(TIM_TypeDef *TIMx, TIM_Base_InitTypeDef *Structure)
   4655          {
   4656            uint32_t tmpcr1 = 0;
   4657            tmpcr1 = TIMx->CR1;
   4658            
   4659            /* Set TIM Time Base Unit parameters ---------------------------------------*/
   4660            if(IS_TIM_CC3_INSTANCE(TIMx) != RESET)   
   \                     TIM_Base_SetConfig: (+1)
   \   00000000   0x....             LDR.N    R3,??DataTable29_3  ;; 0x40010000
   \   00000002   0x....             LDR.N    R2,??DataTable29_4  ;; 0x40010400
   \   00000004   0x4298             CMP      R0,R3
   \   00000006   0xB5F0             PUSH     {R4-R7,LR}
   \   00000008   0x6804             LDR      R4,[R0, #+0]
   \   0000000A   0x....             LDR.N    R5,??DataTable29_5  ;; 0x40000c00
   \   0000000C   0xBF18             IT       NE 
   \   0000000E   0xF1B0 0x4F80      CMPNE    R0,#+1073741824
   \   00000012   0x....             LDR.N    R6,??DataTable29_6  ;; 0x40000800
   \   00000014   0x....             LDR.N    R7,??DataTable29_7  ;; 0x40000400
   \   00000016   0xD007             BEQ.N    ??TIM_Base_SetConfig_0
   \   00000018   0x42B8             CMP      R0,R7
   \   0000001A   0xBF18             IT       NE 
   \   0000001C   0x42B0             CMPNE    R0,R6
   \   0000001E   0xD003             BEQ.N    ??TIM_Base_SetConfig_0
   \   00000020   0x42A8             CMP      R0,R5
   \   00000022   0xBF18             IT       NE 
   \   00000024   0x4290             CMPNE    R0,R2
   \   00000026   0xD10F             BNE.N    ??TIM_Base_SetConfig_1
   4661            {
   4662              /* Select the Counter Mode */
   4663              tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
   4664              tmpcr1 |= Structure->CounterMode;
   4665            }
   4666           
   4667            if(IS_TIM_CC1_INSTANCE(TIMx) != RESET)  
   \                     ??TIM_Base_SetConfig_0: (+1)
   \   00000028   0x4298             CMP      R0,R3
   \   0000002A   0xF8D1 0xC004      LDR      R12,[R1, #+4]
   \   0000002E   0xF024 0x0470      BIC      R4,R4,#0x70
   \   00000032   0xEA4C 0x0404      ORR      R4,R12,R4
   \   00000036   0xBF18             IT       NE 
   \   00000038   0xF1B0 0x4F80      CMPNE    R0,#+1073741824
   \   0000003C   0xD017             BEQ.N    ??TIM_Base_SetConfig_2
   \   0000003E   0x42B8             CMP      R0,R7
   \   00000040   0xBF1C             ITT      NE 
   \   00000042   0x42B0             CMPNE    R0,R6
   \   00000044   0x42A8             CMPNE    R0,R5
   \   00000046   0xD012             BEQ.N    ??TIM_Base_SetConfig_2
   \                     ??TIM_Base_SetConfig_1: (+1)
   \   00000048   0x4290             CMP      R0,R2
   \   0000004A   0xBF1C             ITT      NE 
   \   0000004C   0x....             LDRNE.N  R5,??DataTable29_8  ;; 0x40014000
   \   0000004E   0x42A8             CMPNE    R0,R5
   \   00000050   0xD00D             BEQ.N    ??TIM_Base_SetConfig_2
   \   00000052   0x....             LDR.N    R5,??DataTable29_9  ;; 0x40014400
   \   00000054   0x42A8             CMP      R0,R5
   \   00000056   0xBF1C             ITT      NE 
   \   00000058   0x....             LDRNE.N  R5,??DataTable29_10  ;; 0x40014800
   \   0000005A   0x42A8             CMPNE    R0,R5
   \   0000005C   0xD007             BEQ.N    ??TIM_Base_SetConfig_2
   \   0000005E   0x....             LDR.N    R5,??DataTable29_11  ;; 0x40001800
   \   00000060   0x42A8             CMP      R0,R5
   \   00000062   0xBF1F             ITTTT    NE 
   \   00000064   0x....             LDRNE.N  R5,??DataTable29_12  ;; 0x40001c00
   \   00000066   0x42A8             CMPNE    R0,R5
   \   00000068   0x....             LDRNE.N  R5,??DataTable29_13  ;; 0x40002000
   \   0000006A   0x42A8             CMPNE    R0,R5
   \   0000006C   0xD103             BNE.N    ??TIM_Base_SetConfig_3
   4668            {
   4669              /* Set the clock division */
   4670              tmpcr1 &= ~TIM_CR1_CKD;
   4671              tmpcr1 |= (uint32_t)Structure->ClockDivision;
   \                     ??TIM_Base_SetConfig_2: (+1)
   \   0000006E   0x68CD             LDR      R5,[R1, #+12]
   \   00000070   0xF424 0x7440      BIC      R4,R4,#0x300
   \   00000074   0x432C             ORRS     R4,R5,R4
   4672            }
   4673          
   4674            TIMx->CR1 = tmpcr1;
   \                     ??TIM_Base_SetConfig_3: (+1)
   \   00000076   0x6004             STR      R4,[R0, #+0]
   4675          
   4676            /* Set the Auto-reload value */
   4677            TIMx->ARR = (uint32_t)Structure->Period ;
   \   00000078   0x688C             LDR      R4,[R1, #+8]
   4678           
   4679            /* Set the Prescaler value */
   4680            TIMx->PSC = (uint32_t)Structure->Prescaler;
   4681              
   4682            if(IS_TIM_ADVANCED_INSTANCE(TIMx) != RESET)  
   \   0000007A   0x4298             CMP      R0,R3
   \   0000007C   0x62C4             STR      R4,[R0, #+44]
   \   0000007E   0x680C             LDR      R4,[R1, #+0]
   \   00000080   0x6284             STR      R4,[R0, #+40]
   \   00000082   0xBF12             ITEE     NE 
   \   00000084   0x4290             CMPNE    R0,R2
   \   00000086   0x6909             LDREQ    R1,[R1, #+16]
   \   00000088   0x6301             STREQ    R1,[R0, #+48]
   4683            {
   4684              /* Set the Repetition Counter value */
   4685              TIMx->RCR = Structure->RepetitionCounter;
   4686            }
   4687          
   4688            /* Generate an update event to reload the Prescaler 
   4689               and the repetition counter(only for TIM1 and TIM8) value immediately */
   4690            TIMx->EGR = TIM_EGR_UG;
   \   0000008A   0x2101             MOVS     R1,#+1
   \   0000008C   0x6141             STR      R1,[R0, #+20]
   4691          }
   \   0000008E   0xBDF0             POP      {R4-R7,PC}       ;; return
   4692          
   4693          /**
   4694            * @brief  Time Output Compare 1 configuration
   4695            * @param  TIMx to select the TIM peripheral
   4696            * @param  OC_Config: The output configuration structure
   4697            * @retval None
   4698            */

   \                                 In section .text, align 2, keep-with-next
   4699          void TIM_OC1_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
   4700          {
   \                     TIM_OC1_SetConfig: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   4701            uint32_t tmpccmrx = 0;
   4702            uint32_t tmpccer = 0;
   4703            uint32_t tmpcr2 = 0;  
   4704          
   4705            /* Disable the Channel 1: Reset the CC1E Bit */
   4706            TIMx->CCER &= ~TIM_CCER_CC1E;
   \   00000002   0x6A02             LDR      R2,[R0, #+32]
   4707            
   4708            /* Get the TIMx CCER register value */
   4709            tmpccer = TIMx->CCER;
   4710            /* Get the TIMx CR2 register value */
   4711            tmpcr2 = TIMx->CR2;
   4712            
   4713            /* Get the TIMx CCMR1 register value */
   4714            tmpccmrx = TIMx->CCMR1;
   4715              
   4716            /* Reset the Output Compare Mode Bits */
   4717            tmpccmrx &= ~TIM_CCMR1_OC1M;
   4718            tmpccmrx &= ~TIM_CCMR1_CC1S;
   4719            /* Select the Output Compare Mode */
   4720            tmpccmrx |= OC_Config->OCMode;
   \   00000004   0x....             LDR.N    R5,??DataTable29_14  ;; 0xfffeff8c
   \   00000006   0x0852             LSRS     R2,R2,#+1
   \   00000008   0x0052             LSLS     R2,R2,#+1
   \   0000000A   0x6202             STR      R2,[R0, #+32]
   \   0000000C   0x6A04             LDR      R4,[R0, #+32]
   \   0000000E   0x6842             LDR      R2,[R0, #+4]
   \   00000010   0x6983             LDR      R3,[R0, #+24]
   4721            
   4722            /* Reset the Output Polarity level */
   4723            tmpccer &= ~TIM_CCER_CC1P;
   4724            /* Set the Output Compare Polarity */
   4725            tmpccer |= OC_Config->OCPolarity;
   \   00000012   0xF024 0x0402      BIC      R4,R4,#0x2
   \   00000016   0x402B             ANDS     R3,R5,R3
   \   00000018   0x680D             LDR      R5,[R1, #+0]
   \   0000001A   0x432B             ORRS     R3,R5,R3
   \   0000001C   0x688D             LDR      R5,[R1, #+8]
   \   0000001E   0x432C             ORRS     R4,R5,R4
   4726          
   4727              
   4728            if(IS_TIM_ADVANCED_INSTANCE(TIMx) != RESET)
   \   00000020   0x.... 0x....      BL       ?Subroutine69
   \                     ??CrossCallReturnLabel_218: (+1)
   \   00000024   0xBF1C             ITT      NE 
   \   00000026   0x....             LDRNE.N  R5,??DataTable29_4  ;; 0x40010400
   \   00000028   0x42A8             CMPNE    R0,R5
   \   0000002A   0xD10B             BNE.N    ??TIM_OC1_SetConfig_0
   4729            {   
   4730              /* Reset the Output N Polarity level */
   4731              tmpccer &= ~TIM_CCER_CC1NP;
   4732              /* Set the Output N Polarity */
   4733              tmpccer |= OC_Config->OCNPolarity;
   4734              /* Reset the Output N State */
   4735              tmpccer &= ~TIM_CCER_CC1NE;
   4736              
   4737              /* Reset the Output Compare and Output Compare N IDLE State */
   4738              tmpcr2 &= ~TIM_CR2_OIS1;
   4739              tmpcr2 &= ~TIM_CR2_OIS1N;
   4740              /* Set the Output Idle state */
   4741              tmpcr2 |= OC_Config->OCIdleState;
   4742              /* Set the Output N Idle state */
   4743              tmpcr2 |= OC_Config->OCNIdleState;
   \   0000002C   0xF422 0x7240      BIC      R2,R2,#0x300
   \   00000030   0x68CD             LDR      R5,[R1, #+12]
   \   00000032   0xF024 0x0408      BIC      R4,R4,#0x8
   \   00000036   0x432C             ORRS     R4,R5,R4
   \   00000038   0x694D             LDR      R5,[R1, #+20]
   \   0000003A   0xF024 0x0404      BIC      R4,R4,#0x4
   \   0000003E   0x432A             ORRS     R2,R5,R2
   \   00000040   0x698D             LDR      R5,[R1, #+24]
   \   00000042   0x432A             ORRS     R2,R5,R2
   4744            }
   4745            /* Write to TIMx CR2 */
   4746            TIMx->CR2 = tmpcr2;
   \                     ??TIM_OC1_SetConfig_0: (+1)
   \   00000044   0x6042             STR      R2,[R0, #+4]
   4747            
   4748            /* Write to TIMx CCMR1 */
   4749            TIMx->CCMR1 = tmpccmrx;
   \   00000046   0x6183             STR      R3,[R0, #+24]
   4750            
   4751            /* Set the Capture Compare Register value */
   4752            TIMx->CCR1 = OC_Config->Pulse;
   \   00000048   0x6849             LDR      R1,[R1, #+4]
   \   0000004A   0x6341             STR      R1,[R0, #+52]
   4753            
   4754            /* Write to TIMx CCER */
   4755            TIMx->CCER = tmpccer;  
   \   0000004C   0x6204             STR      R4,[R0, #+32]
   4756          } 
   \   0000004E   0xBD30             POP      {R4,R5,PC}       ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine69: (+1)
   \   00000000   0x....             LDR.N    R5,??DataTable29_3  ;; 0x40010000
   \   00000002   0x42A8             CMP      R0,R5
   \   00000004   0x4770             BX       LR
   4757          
   4758          /**
   4759            * @brief  Time Output Compare 2 configuration
   4760            * @param  TIMx to select the TIM peripheral
   4761            * @param  OC_Config: The output configuration structure
   4762            * @retval None
   4763            */

   \                                 In section .text, align 2, keep-with-next
   4764          void TIM_OC2_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
   4765          {
   \                     TIM_OC2_SetConfig: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   4766            uint32_t tmpccmrx = 0;
   4767            uint32_t tmpccer = 0;
   4768            uint32_t tmpcr2 = 0;
   4769             
   4770            /* Disable the Channel 2: Reset the CC2E Bit */
   4771            TIMx->CCER &= ~TIM_CCER_CC2E;
   \   00000002   0x6A02             LDR      R2,[R0, #+32]
   4772            
   4773            /* Get the TIMx CCER register value */  
   4774            tmpccer = TIMx->CCER;
   4775            /* Get the TIMx CR2 register value */
   4776            tmpcr2 = TIMx->CR2;
   4777            
   4778            /* Get the TIMx CCMR1 register value */
   4779            tmpccmrx = TIMx->CCMR1;
   4780              
   4781            /* Reset the Output Compare mode and Capture/Compare selection Bits */
   4782            tmpccmrx &= ~TIM_CCMR1_OC2M;
   4783            tmpccmrx &= ~TIM_CCMR1_CC2S;
   4784            
   4785            /* Select the Output Compare Mode */
   4786            tmpccmrx |= (OC_Config->OCMode << 8);
   \   00000004   0x....             LDR.N    R5,??DataTable29_15  ;; 0xfeff8cff
   \   00000006   0xF022 0x0210      BIC      R2,R2,#0x10
   \   0000000A   0x6202             STR      R2,[R0, #+32]
   \   0000000C   0x6A04             LDR      R4,[R0, #+32]
   \   0000000E   0x6842             LDR      R2,[R0, #+4]
   \   00000010   0x6983             LDR      R3,[R0, #+24]
   4787            
   4788            /* Reset the Output Polarity level */
   4789            tmpccer &= ~TIM_CCER_CC2P;
   4790            /* Set the Output Compare Polarity */
   4791            tmpccer |= (OC_Config->OCPolarity << 4);
   \   00000012   0xF024 0x0420      BIC      R4,R4,#0x20
   \   00000016   0x402B             ANDS     R3,R5,R3
   \   00000018   0x680D             LDR      R5,[R1, #+0]
   \   0000001A   0xEA43 0x2305      ORR      R3,R3,R5, LSL #+8
   \   0000001E   0x688D             LDR      R5,[R1, #+8]
   \   00000020   0xEA44 0x1405      ORR      R4,R4,R5, LSL #+4
   4792              
   4793            if(IS_TIM_ADVANCED_INSTANCE(TIMx) != RESET)
   \   00000024   0x.... 0x....      BL       ?Subroutine69
   \                     ??CrossCallReturnLabel_219: (+1)
   \   00000028   0xBF1C             ITT      NE 
   \   0000002A   0x....             LDRNE.N  R5,??DataTable29_4  ;; 0x40010400
   \   0000002C   0x42A8             CMPNE    R0,R5
   \   0000002E   0xD10D             BNE.N    ??TIM_OC2_SetConfig_0
   4794            {
   4795              assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));
   4796              assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
   4797              assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));
   4798              
   4799              /* Reset the Output N Polarity level */
   4800              tmpccer &= ~TIM_CCER_CC2NP;
   4801              /* Set the Output N Polarity */
   4802              tmpccer |= (OC_Config->OCNPolarity << 4);
   4803              /* Reset the Output N State */
   4804              tmpccer &= ~TIM_CCER_CC2NE;
   \   00000030   0x68CD             LDR      R5,[R1, #+12]
   \   00000032   0xF024 0x0480      BIC      R4,R4,#0x80
   4805              
   4806              /* Reset the Output Compare and Output Compare N IDLE State */
   4807              tmpcr2 &= ~TIM_CR2_OIS2;
   4808              tmpcr2 &= ~TIM_CR2_OIS2N;
   4809              /* Set the Output Idle state */
   4810              tmpcr2 |= (OC_Config->OCIdleState << 2);
   4811              /* Set the Output N Idle state */
   4812              tmpcr2 |= (OC_Config->OCNIdleState << 2);
   \   00000036   0x698E             LDR      R6,[R1, #+24]
   \   00000038   0xF422 0x6240      BIC      R2,R2,#0xC00
   \   0000003C   0xEA44 0x1405      ORR      R4,R4,R5, LSL #+4
   \   00000040   0x694D             LDR      R5,[R1, #+20]
   \   00000042   0x4335             ORRS     R5,R6,R5
   \   00000044   0xF024 0x0440      BIC      R4,R4,#0x40
   \   00000048   0xEA42 0x0285      ORR      R2,R2,R5, LSL #+2
   4813            }
   4814            /* Write to TIMx CR2 */
   4815            TIMx->CR2 = tmpcr2;
   \                     ??TIM_OC2_SetConfig_0: (+1)
   \   0000004C   0x6042             STR      R2,[R0, #+4]
   4816            
   4817            /* Write to TIMx CCMR1 */
   4818            TIMx->CCMR1 = tmpccmrx;
   \   0000004E   0x6183             STR      R3,[R0, #+24]
   4819            
   4820            /* Set the Capture Compare Register value */
   4821            TIMx->CCR2 = OC_Config->Pulse;
   \   00000050   0x6849             LDR      R1,[R1, #+4]
   \   00000052   0x6381             STR      R1,[R0, #+56]
   4822            
   4823            /* Write to TIMx CCER */
   4824            TIMx->CCER = tmpccer;
   \   00000054   0x6204             STR      R4,[R0, #+32]
   4825          }
   \   00000056   0xBD70             POP      {R4-R6,PC}       ;; return
   4826          
   4827          /**
   4828            * @brief  Time Output Compare 3 configuration
   4829            * @param  TIMx to select the TIM peripheral
   4830            * @param  OC_Config: The output configuration structure
   4831            * @retval None
   4832            */

   \                                 In section .text, align 2, keep-with-next
   4833          void TIM_OC3_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
   4834          {
   \                     TIM_OC3_SetConfig: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   4835            uint32_t tmpccmrx = 0;
   4836            uint32_t tmpccer = 0;
   4837            uint32_t tmpcr2 = 0;   
   4838          
   4839            /* Disable the Channel 3: Reset the CC2E Bit */
   4840            TIMx->CCER &= ~TIM_CCER_CC3E;
   \   00000002   0x6A02             LDR      R2,[R0, #+32]
   4841            
   4842            /* Get the TIMx CCER register value */
   4843            tmpccer = TIMx->CCER;
   4844            /* Get the TIMx CR2 register value */
   4845            tmpcr2 = TIMx->CR2;
   4846            
   4847            /* Get the TIMx CCMR2 register value */
   4848            tmpccmrx = TIMx->CCMR2;
   4849              
   4850            /* Reset the Output Compare mode and Capture/Compare selection Bits */
   4851            tmpccmrx &= ~TIM_CCMR2_OC3M;
   4852            tmpccmrx &= ~TIM_CCMR2_CC3S;  
   4853            /* Select the Output Compare Mode */
   4854            tmpccmrx |= OC_Config->OCMode;
   \   00000004   0x....             LDR.N    R5,??DataTable29_14  ;; 0xfffeff8c
   \   00000006   0xF422 0x7280      BIC      R2,R2,#0x100
   \   0000000A   0x6202             STR      R2,[R0, #+32]
   \   0000000C   0x6A04             LDR      R4,[R0, #+32]
   \   0000000E   0x6842             LDR      R2,[R0, #+4]
   \   00000010   0x69C3             LDR      R3,[R0, #+28]
   4855            
   4856            /* Reset the Output Polarity level */
   4857            tmpccer &= ~TIM_CCER_CC3P;
   4858            /* Set the Output Compare Polarity */
   4859            tmpccer |= (OC_Config->OCPolarity << 8);
   \   00000012   0xF424 0x7400      BIC      R4,R4,#0x200
   \   00000016   0x402B             ANDS     R3,R5,R3
   \   00000018   0x680D             LDR      R5,[R1, #+0]
   \   0000001A   0x432B             ORRS     R3,R5,R3
   \   0000001C   0x688D             LDR      R5,[R1, #+8]
   \   0000001E   0xEA44 0x2405      ORR      R4,R4,R5, LSL #+8
   4860              
   4861            if(IS_TIM_ADVANCED_INSTANCE(TIMx) != RESET)
   \   00000022   0x.... 0x....      BL       ?Subroutine69
   \                     ??CrossCallReturnLabel_220: (+1)
   \   00000026   0xBF1C             ITT      NE 
   \   00000028   0x....             LDRNE.N  R5,??DataTable29_4  ;; 0x40010400
   \   0000002A   0x42A8             CMPNE    R0,R5
   \   0000002C   0xD10D             BNE.N    ??TIM_OC3_SetConfig_0
   4862            {
   4863              assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));
   4864              assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
   4865              assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));
   4866              
   4867              /* Reset the Output N Polarity level */
   4868              tmpccer &= ~TIM_CCER_CC3NP;
   4869              /* Set the Output N Polarity */
   4870              tmpccer |= (OC_Config->OCNPolarity << 8);
   4871              /* Reset the Output N State */
   4872              tmpccer &= ~TIM_CCER_CC3NE;
   \   0000002E   0x68CD             LDR      R5,[R1, #+12]
   \   00000030   0xF424 0x6400      BIC      R4,R4,#0x800
   4873              
   4874              /* Reset the Output Compare and Output Compare N IDLE State */
   4875              tmpcr2 &= ~TIM_CR2_OIS3;
   4876              tmpcr2 &= ~TIM_CR2_OIS3N;
   4877              /* Set the Output Idle state */
   4878              tmpcr2 |= (OC_Config->OCIdleState << 4);
   4879              /* Set the Output N Idle state */
   4880              tmpcr2 |= (OC_Config->OCNIdleState << 4);
   \   00000034   0x698E             LDR      R6,[R1, #+24]
   \   00000036   0xF422 0x5240      BIC      R2,R2,#0x3000
   \   0000003A   0xEA44 0x2405      ORR      R4,R4,R5, LSL #+8
   \   0000003E   0x694D             LDR      R5,[R1, #+20]
   \   00000040   0x4335             ORRS     R5,R6,R5
   \   00000042   0xF424 0x6480      BIC      R4,R4,#0x400
   \   00000046   0xEA42 0x1205      ORR      R2,R2,R5, LSL #+4
   4881            }
   4882            /* Write to TIMx CR2 */
   4883            TIMx->CR2 = tmpcr2;
   \                     ??TIM_OC3_SetConfig_0: (+1)
   \   0000004A   0x6042             STR      R2,[R0, #+4]
   4884            
   4885            /* Write to TIMx CCMR2 */
   4886            TIMx->CCMR2 = tmpccmrx;
   \   0000004C   0x61C3             STR      R3,[R0, #+28]
   4887            
   4888            /* Set the Capture Compare Register value */
   4889            TIMx->CCR3 = OC_Config->Pulse;
   \   0000004E   0x6849             LDR      R1,[R1, #+4]
   \   00000050   0x63C1             STR      R1,[R0, #+60]
   4890            
   4891            /* Write to TIMx CCER */
   4892            TIMx->CCER = tmpccer;
   \   00000052   0x6204             STR      R4,[R0, #+32]
   4893          }
   \   00000054   0xBD70             POP      {R4-R6,PC}       ;; return
   4894          
   4895          /**
   4896            * @brief  Time Output Compare 4 configuration
   4897            * @param  TIMx to select the TIM peripheral
   4898            * @param  OC_Config: The output configuration structure
   4899            * @retval None
   4900            */

   \                                 In section .text, align 2, keep-with-next
   4901          void TIM_OC4_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
   4902          {
   \                     TIM_OC4_SetConfig: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   4903            uint32_t tmpccmrx = 0;
   4904            uint32_t tmpccer = 0;
   4905            uint32_t tmpcr2 = 0;
   4906          
   4907            /* Disable the Channel 4: Reset the CC4E Bit */
   4908            TIMx->CCER &= ~TIM_CCER_CC4E;
   \   00000002   0x6A02             LDR      R2,[R0, #+32]
   4909            
   4910            /* Get the TIMx CCER register value */
   4911            tmpccer = TIMx->CCER;
   4912            /* Get the TIMx CR2 register value */
   4913            tmpcr2 = TIMx->CR2;
   4914            
   4915            /* Get the TIMx CCMR2 register value */
   4916            tmpccmrx = TIMx->CCMR2;
   4917              
   4918            /* Reset the Output Compare mode and Capture/Compare selection Bits */
   4919            tmpccmrx &= ~TIM_CCMR2_OC4M;
   4920            tmpccmrx &= ~TIM_CCMR2_CC4S;
   4921            
   4922            /* Select the Output Compare Mode */
   4923            tmpccmrx |= (OC_Config->OCMode << 8);
   \   00000004   0x....             LDR.N    R5,??DataTable29_15  ;; 0xfeff8cff
   \   00000006   0xF422 0x5280      BIC      R2,R2,#0x1000
   \   0000000A   0x6202             STR      R2,[R0, #+32]
   \   0000000C   0x6A02             LDR      R2,[R0, #+32]
   \   0000000E   0x6843             LDR      R3,[R0, #+4]
   \   00000010   0x69C4             LDR      R4,[R0, #+28]
   4924            
   4925            /* Reset the Output Polarity level */
   4926            tmpccer &= ~TIM_CCER_CC4P;
   4927            /* Set the Output Compare Polarity */
   4928            tmpccer |= (OC_Config->OCPolarity << 12);
   \   00000012   0xF422 0x5200      BIC      R2,R2,#0x2000
   \   00000016   0x402C             ANDS     R4,R5,R4
   \   00000018   0x680D             LDR      R5,[R1, #+0]
   \   0000001A   0xEA44 0x2405      ORR      R4,R4,R5, LSL #+8
   \   0000001E   0x688D             LDR      R5,[R1, #+8]
   \   00000020   0xEA42 0x3205      ORR      R2,R2,R5, LSL #+12
   4929             
   4930            /*if((TIMx == TIM1) || (TIMx == TIM8))*/
   4931            if(IS_TIM_ADVANCED_INSTANCE(TIMx) != RESET)
   \   00000024   0x.... 0x....      BL       ?Subroutine69
   \                     ??CrossCallReturnLabel_221: (+1)
   \   00000028   0xBF1C             ITT      NE 
   \   0000002A   0x....             LDRNE.N  R5,??DataTable29_4  ;; 0x40010400
   \   0000002C   0x42A8             CMPNE    R0,R5
   \   0000002E   0xD104             BNE.N    ??TIM_OC4_SetConfig_0
   4932            {
   4933              assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));
   4934              /* Reset the Output Compare IDLE State */
   4935              tmpcr2 &= ~TIM_CR2_OIS4;
   4936              /* Set the Output Idle state */
   4937              tmpcr2 |= (OC_Config->OCIdleState << 6);
   \   00000030   0x694D             LDR      R5,[R1, #+20]
   \   00000032   0xF423 0x4380      BIC      R3,R3,#0x4000
   \   00000036   0xEA43 0x1385      ORR      R3,R3,R5, LSL #+6
   4938            }
   4939            /* Write to TIMx CR2 */
   4940            TIMx->CR2 = tmpcr2;
   \                     ??TIM_OC4_SetConfig_0: (+1)
   \   0000003A   0x6043             STR      R3,[R0, #+4]
   4941            
   4942            /* Write to TIMx CCMR2 */  
   4943            TIMx->CCMR2 = tmpccmrx;
   \   0000003C   0x61C4             STR      R4,[R0, #+28]
   4944              
   4945            /* Set the Capture Compare Register value */
   4946            TIMx->CCR4 = OC_Config->Pulse;
   \   0000003E   0x6849             LDR      R1,[R1, #+4]
   \   00000040   0x6401             STR      R1,[R0, #+64]
   4947            
   4948            /* Write to TIMx CCER */
   4949            TIMx->CCER = tmpccer;
   \   00000042   0x6202             STR      R2,[R0, #+32]
   4950          }
   \   00000044   0xBD30             POP      {R4,R5,PC}       ;; return
   4951          
   4952          /**
   4953            * @brief  Time Output Compare 4 configuration
   4954            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   4955            *                the configuration information for TIM module.
   4956            * @param  sSlaveConfig: The slave configuration structure
   4957            * @retval None
   4958            */
   4959          static void TIM_SlaveTimer_SetConfig(TIM_HandleTypeDef *htim,
   4960                                        TIM_SlaveConfigTypeDef * sSlaveConfig)
   4961          {
   4962            uint32_t tmpsmcr = 0;
   4963            uint32_t tmpccmr1 = 0;
   4964            uint32_t tmpccer = 0;
   4965          
   4966           /* Get the TIMx SMCR register value */
   4967            tmpsmcr = htim->Instance->SMCR;
   4968          
   4969            /* Reset the Trigger Selection Bits */
   4970            tmpsmcr &= ~TIM_SMCR_TS;
   4971            /* Set the Input Trigger source */
   4972            tmpsmcr |= sSlaveConfig->InputTrigger;
   4973          
   4974            /* Reset the slave mode Bits */
   4975            tmpsmcr &= ~TIM_SMCR_SMS;
   4976            /* Set the slave mode */
   4977            tmpsmcr |= sSlaveConfig->SlaveMode;
   4978          
   4979            /* Write to TIMx SMCR */
   4980            htim->Instance->SMCR = tmpsmcr;
   4981           
   4982            /* Configure the trigger prescaler, filter, and polarity */
   4983            switch (sSlaveConfig->InputTrigger)
   4984            {
   4985            case TIM_TS_ETRF:
   4986              {
   4987                /* Check the parameters */
   4988                assert_param(IS_TIM_ETR_INSTANCE(htim->Instance));
   4989                assert_param(IS_TIM_TRIGGERPRESCALER(sSlaveConfig->TriggerPrescaler));
   4990                assert_param(IS_TIM_TRIGGERPOLARITY(sSlaveConfig->TriggerPolarity));
   4991                assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
   4992                /* Configure the ETR Trigger source */
   4993                TIM_ETR_SetConfig(htim->Instance, 
   4994                                  sSlaveConfig->TriggerPrescaler, 
   4995                                  sSlaveConfig->TriggerPolarity, 
   4996                                  sSlaveConfig->TriggerFilter);
   4997              }
   4998              break;
   4999              
   5000            case TIM_TS_TI1F_ED:
   5001              {
   5002                /* Check the parameters */
   5003                assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   5004                assert_param(IS_TIM_TRIGGERPOLARITY(sSlaveConfig->TriggerPolarity));
   5005                assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
   5006            
   5007                /* Disable the Channel 1: Reset the CC1E Bit */
   5008                tmpccer = htim->Instance->CCER;
   5009                htim->Instance->CCER &= ~TIM_CCER_CC1E;
   5010                tmpccmr1 = htim->Instance->CCMR1;    
   5011                
   5012                /* Set the filter */
   5013                tmpccmr1 &= ~TIM_CCMR1_IC1F;
   5014                tmpccmr1 |= ((sSlaveConfig->TriggerFilter) << 4);
   5015                
   5016                /* Write to TIMx CCMR1 and CCER registers */
   5017                htim->Instance->CCMR1 = tmpccmr1;
   5018                htim->Instance->CCER = tmpccer;                               
   5019                                         
   5020              }
   5021              break;
   5022              
   5023            case TIM_TS_TI1FP1:
   5024              {
   5025                /* Check the parameters */
   5026                assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   5027                assert_param(IS_TIM_TRIGGERPOLARITY(sSlaveConfig->TriggerPolarity));
   5028                assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
   5029          
   5030                /* Configure TI1 Filter and Polarity */
   5031                TIM_TI1_ConfigInputStage(htim->Instance,
   5032                                         sSlaveConfig->TriggerPolarity,
   5033                                         sSlaveConfig->TriggerFilter);
   5034              }
   5035              break;
   5036              
   5037            case TIM_TS_TI2FP2:
   5038              {
   5039                /* Check the parameters */
   5040                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   5041                assert_param(IS_TIM_TRIGGERPOLARITY(sSlaveConfig->TriggerPolarity));
   5042                assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
   5043            
   5044                /* Configure TI2 Filter and Polarity */
   5045                TIM_TI2_ConfigInputStage(htim->Instance,
   5046                                          sSlaveConfig->TriggerPolarity,
   5047                                          sSlaveConfig->TriggerFilter);
   5048              }
   5049              break;
   5050              
   5051            case TIM_TS_ITR0:
   5052              {
   5053                /* Check the parameter */
   5054                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   5055              }
   5056              break;
   5057              
   5058            case TIM_TS_ITR1:
   5059              {
   5060                /* Check the parameter */
   5061                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   5062              }
   5063              break;
   5064              
   5065            case TIM_TS_ITR2:
   5066              {
   5067                /* Check the parameter */
   5068                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   5069              }
   5070              break;
   5071              
   5072            case TIM_TS_ITR3:
   5073              {
   5074                /* Check the parameter */
   5075                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   5076              }
   5077              break;
   5078                 
   5079            default:
   5080              break;
   5081            }
   5082          }
   5083          
   5084          /**
   5085            * @brief  Configure the TI1 as Input.
   5086            * @param  TIMx to select the TIM peripheral.
   5087            * @param  TIM_ICPolarity : The Input Polarity.
   5088            *          This parameter can be one of the following values:
   5089            *            @arg TIM_ICPolarity_Rising
   5090            *            @arg TIM_ICPolarity_Falling
   5091            *            @arg TIM_ICPolarity_BothEdge  
   5092            * @param  TIM_ICSelection: specifies the input to be used.
   5093            *          This parameter can be one of the following values:
   5094            *            @arg TIM_ICSelection_DirectTI: TIM Input 1 is selected to be connected to IC1.
   5095            *            @arg TIM_ICSelection_IndirectTI: TIM Input 1 is selected to be connected to IC2.
   5096            *            @arg TIM_ICSelection_TRC: TIM Input 1 is selected to be connected to TRC.
   5097            * @param  TIM_ICFilter: Specifies the Input Capture Filter.
   5098            *          This parameter must be a value between 0x00 and 0x0F.
   5099            * @retval None  
   5100            * @note TIM_ICFilter and TIM_ICPolarity are not used in INDIRECT mode as TI2FP1 
   5101            *       (on channel2 path) is used as the input signal. Therefore CCMR1 must be 
   5102            *        protected against un-initialized filter and polarity values.  
   5103            */

   \                                 In section .text, align 2, keep-with-next
   5104          void TIM_TI1_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
   5105                                 uint32_t TIM_ICFilter)
   5106          {
   \                     TIM_TI1_SetConfig: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   5107            uint32_t tmpccmr1 = 0;
   5108            uint32_t tmpccer = 0;
   5109          
   5110            /* Disable the Channel 1: Reset the CC1E Bit */
   5111            TIMx->CCER &= ~TIM_CCER_CC1E;
   \   00000002   0x6A04             LDR      R4,[R0, #+32]
   5112            tmpccmr1 = TIMx->CCMR1;
   5113            tmpccer = TIMx->CCER;
   5114          
   5115            /* Select the Input */
   5116            if(IS_TIM_CC2_INSTANCE(TIMx) != RESET)
   \   00000004   0x....             LDR.N    R6,??DataTable29_3  ;; 0x40010000
   \   00000006   0x0864             LSRS     R4,R4,#+1
   \   00000008   0x0064             LSLS     R4,R4,#+1
   \   0000000A   0x6204             STR      R4,[R0, #+32]
   \   0000000C   0x6985             LDR      R5,[R0, #+24]
   \   0000000E   0x42B0             CMP      R0,R6
   \   00000010   0x6A04             LDR      R4,[R0, #+32]
   \   00000012   0xBF18             IT       NE 
   \   00000014   0xF1B0 0x4F80      CMPNE    R0,#+1073741824
   \   00000018   0xD011             BEQ.N    ??TIM_TI1_SetConfig_0
   \   0000001A   0x....             LDR.N    R6,??DataTable29_7  ;; 0x40000400
   \   0000001C   0x42B0             CMP      R0,R6
   \   0000001E   0xBF1C             ITT      NE 
   \   00000020   0x....             LDRNE.N  R6,??DataTable29_6  ;; 0x40000800
   \   00000022   0x42B0             CMPNE    R0,R6
   \   00000024   0xD00B             BEQ.N    ??TIM_TI1_SetConfig_0
   \   00000026   0x....             LDR.N    R6,??DataTable29_5  ;; 0x40000c00
   \   00000028   0x42B0             CMP      R0,R6
   \   0000002A   0xBF1C             ITT      NE 
   \   0000002C   0x....             LDRNE.N  R6,??DataTable29_4  ;; 0x40010400
   \   0000002E   0x42B0             CMPNE    R0,R6
   \   00000030   0xD005             BEQ.N    ??TIM_TI1_SetConfig_0
   \   00000032   0x....             LDR.N    R6,??DataTable29_8  ;; 0x40014000
   \   00000034   0x42B0             CMP      R0,R6
   \   00000036   0xBF1C             ITT      NE 
   \   00000038   0x....             LDRNE.N  R6,??DataTable29_11  ;; 0x40001800
   \   0000003A   0x42B0             CMPNE    R0,R6
   \   0000003C   0xD103             BNE.N    ??TIM_TI1_SetConfig_1
   5117            {
   5118              tmpccmr1 &= ~TIM_CCMR1_CC1S;
   5119              tmpccmr1 |= TIM_ICSelection;
   \                     ??TIM_TI1_SetConfig_0: (+1)
   \   0000003E   0x08AD             LSRS     R5,R5,#+2
   \   00000040   0xEA42 0x0285      ORR      R2,R2,R5, LSL #+2
   \   00000044   0xE001             B.N      ??TIM_TI1_SetConfig_2
   5120            } 
   5121            else
   5122            {
   5123              tmpccmr1 |= TIM_CCMR1_CC1S_0;
   \                     ??TIM_TI1_SetConfig_1: (+1)
   \   00000046   0xF045 0x0201      ORR      R2,R5,#0x1
   5124            }
   5125            
   5126            /* Set the filter */
   5127            tmpccmr1 &= ~TIM_CCMR1_IC1F;
   5128            tmpccmr1 |= ((TIM_ICFilter << 4) & TIM_CCMR1_IC1F);
   5129          
   5130            /* Select the Polarity and set the CC1E Bit */
   5131            tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
   5132            tmpccer |= (TIM_ICPolarity & (TIM_CCER_CC1P | TIM_CCER_CC1NP));
   5133          
   5134            /* Write to TIMx CCMR1 and CCER registers */
   5135            TIMx->CCMR1 = tmpccmr1;
   \                     ??TIM_TI1_SetConfig_2: (+1)
   \   0000004A   0x011B             LSLS     R3,R3,#+4
   \   0000004C   0xF022 0x02F0      BIC      R2,R2,#0xF0
   \   00000050   0xF003 0x03F0      AND      R3,R3,#0xF0
   \   00000054   0x431A             ORRS     R2,R3,R2
   \   00000056   0x6182             STR      R2,[R0, #+24]
   5136            TIMx->CCER = tmpccer;
   \   00000058   0xF024 0x020A      BIC      R2,R4,#0xA
   \   0000005C   0xF001 0x010A      AND      R1,R1,#0xA
   \   00000060   0x4311             ORRS     R1,R1,R2
   \   00000062   0x6201             STR      R1,[R0, #+32]
   5137          }
   \   00000064   0xBD70             POP      {R4-R6,PC}       ;; return
   5138          
   5139          /**
   5140            * @brief  Configure the Polarity and Filter for TI1.
   5141            * @param  TIMx to select the TIM peripheral.
   5142            * @param  TIM_ICPolarity : The Input Polarity.
   5143            *          This parameter can be one of the following values:
   5144            *            @arg TIM_ICPolarity_Rising
   5145            *            @arg TIM_ICPolarity_Falling
   5146            *            @arg TIM_ICPolarity_BothEdge
   5147            * @param  TIM_ICFilter: Specifies the Input Capture Filter.
   5148            *          This parameter must be a value between 0x00 and 0x0F.
   5149            * @retval None
   5150            */

   \                                 In section .text, align 2, keep-with-next
   5151          static void TIM_TI1_ConfigInputStage(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICFilter)
   5152          {
   \                     TIM_TI1_ConfigInputStage: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   5153            uint32_t tmpccmr1 = 0;
   5154            uint32_t tmpccer = 0;
   5155            
   5156            /* Disable the Channel 1: Reset the CC1E Bit */
   5157            tmpccer = TIMx->CCER;
   \   00000002   0x6A03             LDR      R3,[R0, #+32]
   5158            TIMx->CCER &= ~TIM_CCER_CC1E;
   \   00000004   0x6A04             LDR      R4,[R0, #+32]
   \   00000006   0x0864             LSRS     R4,R4,#+1
   \   00000008   0x0064             LSLS     R4,R4,#+1
   \   0000000A   0x6204             STR      R4,[R0, #+32]
   5159            tmpccmr1 = TIMx->CCMR1;    
   5160            
   5161            /* Set the filter */
   5162            tmpccmr1 &= ~TIM_CCMR1_IC1F;
   5163            tmpccmr1 |= (TIM_ICFilter << 4);
   5164            
   5165            /* Select the Polarity and set the CC1E Bit */
   5166            tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
   5167            tmpccer |= TIM_ICPolarity;
   5168            
   5169            /* Write to TIMx CCMR1 and CCER registers */
   5170            TIMx->CCMR1 = tmpccmr1;
   \   0000000C   0x6984             LDR      R4,[R0, #+24]
   \   0000000E   0xF024 0x04F0      BIC      R4,R4,#0xF0
   \   00000012   0xEA44 0x1202      ORR      R2,R4,R2, LSL #+4
   \   00000016   0x6182             STR      R2,[R0, #+24]
   5171            TIMx->CCER = tmpccer;
   \   00000018   0xF023 0x020A      BIC      R2,R3,#0xA
   \   0000001C   0x4311             ORRS     R1,R1,R2
   \   0000001E   0x6201             STR      R1,[R0, #+32]
   5172          }
   \   00000020   0xBD10             POP      {R4,PC}          ;; return
   5173          
   5174          /**
   5175            * @brief  Configure the TI2 as Input.
   5176            * @param  TIMx to select the TIM peripheral
   5177            * @param  TIM_ICPolarity : The Input Polarity.
   5178            *          This parameter can be one of the following values:
   5179            *            @arg TIM_ICPolarity_Rising
   5180            *            @arg TIM_ICPolarity_Falling
   5181            *            @arg TIM_ICPolarity_BothEdge   
   5182            * @param  TIM_ICSelection: specifies the input to be used.
   5183            *          This parameter can be one of the following values:
   5184            *            @arg TIM_ICSelection_DirectTI: TIM Input 2 is selected to be connected to IC2.
   5185            *            @arg TIM_ICSelection_IndirectTI: TIM Input 2 is selected to be connected to IC1.
   5186            *            @arg TIM_ICSelection_TRC: TIM Input 2 is selected to be connected to TRC.
   5187            * @param  TIM_ICFilter: Specifies the Input Capture Filter.
   5188            *          This parameter must be a value between 0x00 and 0x0F.
   5189            * @retval None
   5190            * @note TIM_ICFilter and TIM_ICPolarity are not used in INDIRECT mode as TI1FP2 
   5191            *       (on channel1 path) is used as the input signal. Therefore CCMR1 must be 
   5192            *        protected against un-initialized filter and polarity values.  
   5193            */

   \                                 In section .text, align 2, keep-with-next
   5194          static void TIM_TI2_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
   5195                                 uint32_t TIM_ICFilter)
   5196          {
   \                     TIM_TI2_SetConfig: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   5197            uint32_t tmpccmr1 = 0;
   5198            uint32_t tmpccer = 0;
   5199          
   5200            /* Disable the Channel 2: Reset the CC2E Bit */
   5201            TIMx->CCER &= ~TIM_CCER_CC2E;
   \   00000002   0x6A04             LDR      R4,[R0, #+32]
   5202            tmpccmr1 = TIMx->CCMR1;
   5203            tmpccer = TIMx->CCER;
   5204          
   5205            /* Select the Input */
   5206            tmpccmr1 &= ~TIM_CCMR1_CC2S;
   5207            tmpccmr1 |= (TIM_ICSelection << 8);
   5208          
   5209            /* Set the filter */
   5210            tmpccmr1 &= ~TIM_CCMR1_IC2F;
   5211            tmpccmr1 |= ((TIM_ICFilter << 12) & TIM_CCMR1_IC2F);
   5212          
   5213            /* Select the Polarity and set the CC2E Bit */
   5214            tmpccer &= ~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
   5215            tmpccer |= ((TIM_ICPolarity << 4) & (TIM_CCER_CC2P | TIM_CCER_CC2NP));
   5216          
   5217            /* Write to TIMx CCMR1 and CCER registers */
   5218            TIMx->CCMR1 = tmpccmr1 ;
   \   00000004   0x031B             LSLS     R3,R3,#+12
   \   00000006   0xF403 0x4370      AND      R3,R3,#0xF000
   5219            TIMx->CCER = tmpccer;
   \   0000000A   0x0109             LSLS     R1,R1,#+4
   \   0000000C   0xF024 0x0410      BIC      R4,R4,#0x10
   \   00000010   0xF001 0x01A0      AND      R1,R1,#0xA0
   \   00000014   0x6204             STR      R4,[R0, #+32]
   \   00000016   0x6984             LDR      R4,[R0, #+24]
   \   00000018   0x6A05             LDR      R5,[R0, #+32]
   \   0000001A   0xF424 0x7440      BIC      R4,R4,#0x300
   \   0000001E   0xEA44 0x2202      ORR      R2,R4,R2, LSL #+8
   \   00000022   0xF422 0x4270      BIC      R2,R2,#0xF000
   \   00000026   0x431A             ORRS     R2,R3,R2
   \   00000028   0x6182             STR      R2,[R0, #+24]
   \   0000002A   0xF025 0x02A0      BIC      R2,R5,#0xA0
   \   0000002E   0x4311             ORRS     R1,R1,R2
   \   00000030   0x6201             STR      R1,[R0, #+32]
   5220          }
   \   00000032   0xBD30             POP      {R4,R5,PC}       ;; return
   5221          
   5222          /**
   5223            * @brief  Configure the Polarity and Filter for TI2.
   5224            * @param  TIMx to select the TIM peripheral.
   5225            * @param  TIM_ICPolarity : The Input Polarity.
   5226            *          This parameter can be one of the following values:
   5227            *            @arg TIM_ICPolarity_Rising
   5228            *            @arg TIM_ICPolarity_Falling
   5229            *            @arg TIM_ICPolarity_BothEdge
   5230            * @param  TIM_ICFilter: Specifies the Input Capture Filter.
   5231            *          This parameter must be a value between 0x00 and 0x0F.
   5232            * @retval None
   5233            */

   \                                 In section .text, align 2, keep-with-next
   5234          static void TIM_TI2_ConfigInputStage(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICFilter)
   5235          {
   \                     TIM_TI2_ConfigInputStage: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   5236          uint32_t tmpccmr1 = 0;
   5237            uint32_t tmpccer = 0;
   5238            
   5239            /* Disable the Channel 2: Reset the CC2E Bit */
   5240            TIMx->CCER &= ~TIM_CCER_CC2E;
   \   00000002   0x6A03             LDR      R3,[R0, #+32]
   \   00000004   0xF023 0x0310      BIC      R3,R3,#0x10
   \   00000008   0x6203             STR      R3,[R0, #+32]
   5241            tmpccmr1 = TIMx->CCMR1;
   \   0000000A   0x6983             LDR      R3,[R0, #+24]
   5242            tmpccer = TIMx->CCER;
   \   0000000C   0x6A04             LDR      R4,[R0, #+32]
   5243            
   5244            /* Set the filter */
   5245            tmpccmr1 &= ~TIM_CCMR1_IC2F;
   5246            tmpccmr1 |= (TIM_ICFilter << 12);
   5247          
   5248            /* Select the Polarity and set the CC2E Bit */
   5249            tmpccer &= ~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
   5250            tmpccer |= (TIM_ICPolarity << 4);
   5251          
   5252            /* Write to TIMx CCMR1 and CCER registers */
   5253            TIMx->CCMR1 = tmpccmr1 ;
   \   0000000E   0xF423 0x4370      BIC      R3,R3,#0xF000
   \   00000012   0xEA43 0x3202      ORR      R2,R3,R2, LSL #+12
   \   00000016   0x6182             STR      R2,[R0, #+24]
   5254            TIMx->CCER = tmpccer;
   \   00000018   0xF024 0x02A0      BIC      R2,R4,#0xA0
   \   0000001C   0xEA42 0x1101      ORR      R1,R2,R1, LSL #+4
   \   00000020   0x6201             STR      R1,[R0, #+32]
   5255          }
   \   00000022   0xBD10             POP      {R4,PC}          ;; return
   5256          
   5257          /**
   5258            * @brief  Configure the TI3 as Input.
   5259            * @param  TIMx to select the TIM peripheral
   5260            * @param  TIM_ICPolarity : The Input Polarity.
   5261            *          This parameter can be one of the following values:
   5262            *            @arg TIM_ICPolarity_Rising
   5263            *            @arg TIM_ICPolarity_Falling
   5264            *            @arg TIM_ICPolarity_BothEdge         
   5265            * @param  TIM_ICSelection: specifies the input to be used.
   5266            *          This parameter can be one of the following values:
   5267            *            @arg TIM_ICSelection_DirectTI: TIM Input 3 is selected to be connected to IC3.
   5268            *            @arg TIM_ICSelection_IndirectTI: TIM Input 3 is selected to be connected to IC4.
   5269            *            @arg TIM_ICSelection_TRC: TIM Input 3 is selected to be connected to TRC.
   5270            * @param  TIM_ICFilter: Specifies the Input Capture Filter.
   5271            *          This parameter must be a value between 0x00 and 0x0F.
   5272            * @retval None
   5273            * @note TIM_ICFilter and TIM_ICPolarity are not used in INDIRECT mode as TI3FP4 
   5274            *       (on channel1 path) is used as the input signal. Therefore CCMR2 must be 
   5275            *        protected against un-initialized filter and polarity values.  
   5276            */
   5277          static void TIM_TI3_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
   5278                                 uint32_t TIM_ICFilter)
   5279          {
   5280            uint32_t tmpccmr2 = 0;
   5281            uint32_t tmpccer = 0;
   5282          
   5283            /* Disable the Channel 3: Reset the CC3E Bit */
   5284            TIMx->CCER &= ~TIM_CCER_CC3E;
   5285            tmpccmr2 = TIMx->CCMR2;
   5286            tmpccer = TIMx->CCER;
   5287          
   5288            /* Select the Input */
   5289            tmpccmr2 &= ~TIM_CCMR2_CC3S;
   5290            tmpccmr2 |= TIM_ICSelection;
   5291          
   5292            /* Set the filter */
   5293            tmpccmr2 &= ~TIM_CCMR2_IC3F;
   5294            tmpccmr2 |= ((TIM_ICFilter << 4) & TIM_CCMR2_IC3F);
   5295          
   5296            /* Select the Polarity and set the CC3E Bit */
   5297            tmpccer &= ~(TIM_CCER_CC3P | TIM_CCER_CC3NP);
   5298            tmpccer |= ((TIM_ICPolarity << 8) & (TIM_CCER_CC3P | TIM_CCER_CC3NP));
   5299          
   5300            /* Write to TIMx CCMR2 and CCER registers */
   5301            TIMx->CCMR2 = tmpccmr2;
   5302            TIMx->CCER = tmpccer;
   5303          }
   5304          
   5305          /**
   5306            * @brief  Configure the TI4 as Input.
   5307            * @param  TIMx to select the TIM peripheral
   5308            * @param  TIM_ICPolarity : The Input Polarity.
   5309            *          This parameter can be one of the following values:
   5310            *            @arg TIM_ICPolarity_Rising
   5311            *            @arg TIM_ICPolarity_Falling
   5312            *            @arg TIM_ICPolarity_BothEdge     
   5313            * @param  TIM_ICSelection: specifies the input to be used.
   5314            *          This parameter can be one of the following values:
   5315            *            @arg TIM_ICSelection_DirectTI: TIM Input 4 is selected to be connected to IC4.
   5316            *            @arg TIM_ICSelection_IndirectTI: TIM Input 4 is selected to be connected to IC3.
   5317            *            @arg TIM_ICSelection_TRC: TIM Input 4 is selected to be connected to TRC.
   5318            * @param  TIM_ICFilter: Specifies the Input Capture Filter.
   5319            *          This parameter must be a value between 0x00 and 0x0F.
   5320            * @retval None
   5321            * @note TIM_ICFilter and TIM_ICPolarity are not used in INDIRECT mode as TI4FP3 
   5322            *       (on channel1 path) is used as the input signal. Therefore CCMR2 must be 
   5323            *        protected against un-initialized filter and polarity values.  
   5324            */
   5325          static void TIM_TI4_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
   5326                                 uint32_t TIM_ICFilter)
   5327          {
   5328            uint32_t tmpccmr2 = 0;
   5329            uint32_t tmpccer = 0;
   5330          
   5331            /* Disable the Channel 4: Reset the CC4E Bit */
   5332            TIMx->CCER &= ~TIM_CCER_CC4E;
   5333            tmpccmr2 = TIMx->CCMR2;
   5334            tmpccer = TIMx->CCER;
   5335          
   5336            /* Select the Input */
   5337            tmpccmr2 &= ~TIM_CCMR2_CC4S;
   5338            tmpccmr2 |= (TIM_ICSelection << 8);
   5339          
   5340            /* Set the filter */
   5341            tmpccmr2 &= ~TIM_CCMR2_IC4F;
   5342            tmpccmr2 |= ((TIM_ICFilter << 12) & TIM_CCMR2_IC4F);
   5343          
   5344            /* Select the Polarity and set the CC4E Bit */
   5345            tmpccer &= ~(TIM_CCER_CC4P | TIM_CCER_CC4NP);
   5346            tmpccer |= ((TIM_ICPolarity << 12) & (TIM_CCER_CC4P | TIM_CCER_CC4NP));
   5347          
   5348            /* Write to TIMx CCMR2 and CCER registers */
   5349            TIMx->CCMR2 = tmpccmr2;
   5350            TIMx->CCER = tmpccer ;
   5351          }
   5352          
   5353          /**
   5354            * @brief  Selects the Input Trigger source
   5355            * @param  TIMx to select the TIM peripheral
   5356            * @param  TIM_ITRx: The Input Trigger source.
   5357            *          This parameter can be one of the following values:
   5358            *            @arg TIM_TS_ITR0: Internal Trigger 0
   5359            *            @arg TIM_TS_ITR1: Internal Trigger 1
   5360            *            @arg TIM_TS_ITR2: Internal Trigger 2
   5361            *            @arg TIM_TS_ITR3: Internal Trigger 3
   5362            *            @arg TIM_TS_TI1F_ED: TI1 Edge Detector
   5363            *            @arg TIM_TS_TI1FP1: Filtered Timer Input 1
   5364            *            @arg TIM_TS_TI2FP2: Filtered Timer Input 2
   5365            *            @arg TIM_TS_ETRF: External Trigger input
   5366            * @retval None
   5367            */

   \                                 In section .text, align 2, keep-with-next
   5368          static void TIM_ITRx_SetConfig(TIM_TypeDef *TIMx, uint16_t TIM_ITRx)
   5369          {
   5370            uint32_t tmpsmcr = 0;
   5371            
   5372             /* Get the TIMx SMCR register value */
   5373             tmpsmcr = TIMx->SMCR;
   5374             /* Reset the TS Bits */
   5375             tmpsmcr &= ~TIM_SMCR_TS;
   5376             /* Set the Input Trigger source and the slave mode*/
   5377             tmpsmcr |= TIM_ITRx | TIM_SLAVEMODE_EXTERNAL1;
   5378             /* Write to TIMx SMCR */
   5379             TIMx->SMCR = tmpsmcr;
   \                     TIM_ITRx_SetConfig: (+1)
   \   00000000   0x6882             LDR      R2,[R0, #+8]
   \   00000002   0xF022 0x0270      BIC      R2,R2,#0x70
   \   00000006   0x4311             ORRS     R1,R1,R2
   \   00000008   0xF041 0x0107      ORR      R1,R1,#0x7
   \   0000000C   0x6081             STR      R1,[R0, #+8]
   5380          }
   \   0000000E   0x4770             BX       LR               ;; return
   5381          
   5382          /**
   5383            * @brief  Configures the TIMx External Trigger (ETR).
   5384            * @param  TIMx to select the TIM peripheral
   5385            * @param  TIM_ExtTRGPrescaler: The external Trigger Prescaler.
   5386            *          This parameter can be one of the following values:
   5387            *            @arg TIM_ExtTRGPSC_DIV1: ETRP Prescaler OFF.
   5388            *            @arg TIM_ExtTRGPSC_DIV2: ETRP frequency divided by 2.
   5389            *            @arg TIM_ExtTRGPSC_DIV4: ETRP frequency divided by 4.
   5390            *            @arg TIM_ExtTRGPSC_DIV8: ETRP frequency divided by 8.
   5391            * @param  TIM_ExtTRGPolarity: The external Trigger Polarity.
   5392            *          This parameter can be one of the following values:
   5393            *            @arg TIM_ExtTRGPolarity_Inverted: active low or falling edge active.
   5394            *            @arg TIM_ExtTRGPolarity_NonInverted: active high or rising edge active.
   5395            * @param  ExtTRGFilter: External Trigger Filter.
   5396            *          This parameter must be a value between 0x00 and 0x0F
   5397            * @retval None
   5398            */

   \                                 In section .text, align 2, keep-with-next
   5399          void TIM_ETR_SetConfig(TIM_TypeDef* TIMx, uint32_t TIM_ExtTRGPrescaler,
   5400                                 uint32_t TIM_ExtTRGPolarity, uint32_t ExtTRGFilter)
   5401          {
   \                     TIM_ETR_SetConfig: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   5402            uint32_t tmpsmcr = 0;
   5403          
   5404            tmpsmcr = TIMx->SMCR;
   5405          
   5406            /* Reset the ETR Bits */
   5407            tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
   5408          
   5409            /* Set the Prescaler, the Filter value and the Polarity */
   5410            tmpsmcr |= (uint32_t)(TIM_ExtTRGPrescaler | (TIM_ExtTRGPolarity | (ExtTRGFilter << 8)));
   5411          
   5412            /* Write to TIMx SMCR */
   5413            TIMx->SMCR = tmpsmcr;
   \   00000002   0x6884             LDR      R4,[R0, #+8]
   \   00000004   0xF424 0x447F      BIC      R4,R4,#0xFF00
   \   00000008   0x4321             ORRS     R1,R1,R4
   \   0000000A   0x4311             ORRS     R1,R2,R1
   \   0000000C   0xEA41 0x2103      ORR      R1,R1,R3, LSL #+8
   \   00000010   0x6081             STR      R1,[R0, #+8]
   5414          } 
   \   00000012   0xBD10             POP      {R4,PC}          ;; return
   5415          
   5416          /**
   5417            * @brief  Enables or disables the TIM Capture Compare Channel x.
   5418            * @param  TIMx to select the TIM peripheral
   5419            * @param  Channel: specifies the TIM Channel
   5420            *          This parameter can be one of the following values:
   5421            *            @arg TIM_Channel_1: TIM Channel 1
   5422            *            @arg TIM_Channel_2: TIM Channel 2
   5423            *            @arg TIM_Channel_3: TIM Channel 3
   5424            *            @arg TIM_Channel_4: TIM Channel 4
   5425            * @param  ChannelState: specifies the TIM Channel CCxE bit new state.
   5426            *          This parameter can be: TIM_CCx_ENABLE or TIM_CCx_Disable. 
   5427            * @retval None
   5428            */

   \                                 In section .text, align 2, keep-with-next
   5429          void TIM_CCxChannelCmd(TIM_TypeDef* TIMx, uint32_t Channel, uint32_t ChannelState)
   5430          {
   \                     TIM_CCxChannelCmd: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   5431            uint32_t tmp = 0;
   5432          
   5433            /* Check the parameters */
   5434            assert_param(IS_TIM_CC1_INSTANCE(TIMx)); 
   5435            assert_param(IS_TIM_CHANNELS(Channel));
   5436          
   5437            tmp = TIM_CCER_CC1E << Channel;
   5438          
   5439            /* Reset the CCxE Bit */
   5440            TIMx->CCER &= ~tmp;
   \   00000002   0x6A03             LDR      R3,[R0, #+32]
   \   00000004   0x2401             MOVS     R4,#+1
   \   00000006   0x408C             LSLS     R4,R4,R1
   5441          
   5442            /* Set or reset the CCxE Bit */ 
   5443            TIMx->CCER |= (uint32_t)(ChannelState << Channel);
   \   00000008   0xFA02 0xF101      LSL      R1,R2,R1
   \   0000000C   0x43A3             BICS     R3,R3,R4
   \   0000000E   0x6203             STR      R3,[R0, #+32]
   \   00000010   0x6A03             LDR      R3,[R0, #+32]
   \   00000012   0x4319             ORRS     R1,R1,R3
   \   00000014   0x6201             STR      R1,[R0, #+32]
   5444          }
   \   00000016   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17:
   \   00000000   0x........         DC32     TIM_DMAPeriodElapsedCplt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_1:
   \   00000000   0x........         DC32     TIM_DMAError

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_2:
   \   00000000   0x40010400         DC32     0x40010400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18:
   \   00000000   0x40010000         DC32     0x40010000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19:
   \   00000000   0x........         DC32     TIM_DMADelayPulseCplt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20:
   \   00000000   0x........         DC32     TIM_DMACaptureCplt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22:
   \   00000000   0xFFFEFFF8         DC32     0xfffefff8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_1:
   \   00000000   0xFFFFFCFC         DC32     0xfffffcfc

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_2:
   \   00000000   0xFFFF0303         DC32     0xffff0303

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29:
   \   00000000   0x........         DC32     TIMEx_DMACommutationCplt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29_1:
   \   00000000   0xFFFE0088         DC32     0xfffe0088

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29_2:
   \   00000000   0xFFFEFF88         DC32     0xfffeff88

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29_3:
   \   00000000   0x40010000         DC32     0x40010000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29_4:
   \   00000000   0x40010400         DC32     0x40010400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29_5:
   \   00000000   0x40000C00         DC32     0x40000c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29_6:
   \   00000000   0x40000800         DC32     0x40000800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29_7:
   \   00000000   0x40000400         DC32     0x40000400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29_8:
   \   00000000   0x40014000         DC32     0x40014000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29_9:
   \   00000000   0x40014400         DC32     0x40014400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29_10:
   \   00000000   0x40014800         DC32     0x40014800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29_11:
   \   00000000   0x40001800         DC32     0x40001800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29_12:
   \   00000000   0x40001C00         DC32     0x40001c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29_13:
   \   00000000   0x40002000         DC32     0x40002000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29_14:
   \   00000000   0xFFFEFF8C         DC32     0xfffeff8c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29_15:
   \   00000000   0xFEFF8CFF         DC32     0xfeff8cff
   5445          
   5446          
   5447          /**
   5448            * @}
   5449            */
   5450          
   5451          #endif /* HAL_TIM_MODULE_ENABLED */
   5452          /**
   5453            * @}
   5454            */ 
   5455          
   5456          /**
   5457            * @}
   5458            */ 
   5459          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   HAL_TIM_Base_DeInit
         8   -> HAL_TIM_Base_MspDeInit
       0   HAL_TIM_Base_GetState
       8   HAL_TIM_Base_Init
         8   -> HAL_TIM_Base_MspInit
         8   -> TIM_Base_SetConfig
       0   HAL_TIM_Base_MspDeInit
       0   HAL_TIM_Base_MspInit
       0   HAL_TIM_Base_Start
       8   HAL_TIM_Base_Start_DMA
         8   -> HAL_DMA_Start_IT
       0   HAL_TIM_Base_Start_IT
       0   HAL_TIM_Base_Stop
       0   HAL_TIM_Base_Stop_DMA
       0   HAL_TIM_Base_Stop_IT
      16   HAL_TIM_ConfigClockSource
        16   -> TIM_ETR_SetConfig
        16   -> TIM_ITRx_SetConfig
        16   -> TIM_TI1_ConfigInputStage
        16   -> TIM_TI2_ConfigInputStage
      24   HAL_TIM_ConfigOCrefClear
        24   -> TIM_ETR_SetConfig
       0   HAL_TIM_ConfigTI1Input
      24   HAL_TIM_DMABurst_ReadStart
        24   -> HAL_DMA_Start_IT
       0   HAL_TIM_DMABurst_ReadStop
        16   -> HAL_DMA_Abort
      24   HAL_TIM_DMABurst_WriteStart
        24   -> HAL_DMA_Start_IT
      16   HAL_TIM_DMABurst_WriteStop
        16   -> HAL_DMA_Abort
       8   HAL_TIM_Encoder_DeInit
         8   -> HAL_TIM_Encoder_MspDeInit
       0   HAL_TIM_Encoder_GetState
      24   HAL_TIM_Encoder_Init
        24   -> HAL_TIM_Encoder_MspInit
        24   -> TIM_Base_SetConfig
       0   HAL_TIM_Encoder_MspDeInit
       0   HAL_TIM_Encoder_MspInit
       8   HAL_TIM_Encoder_Start
         8   -> TIM_CCxChannelCmd
      24   HAL_TIM_Encoder_Start_DMA
        24   -> HAL_DMA_Start_IT
        24   -> TIM_CCxChannelCmd
       8   HAL_TIM_Encoder_Start_IT
         8   -> TIM_CCxChannelCmd
       8   HAL_TIM_Encoder_Stop
         8   -> TIM_CCxChannelCmd
       8   HAL_TIM_Encoder_Stop_DMA
         8   -> TIM_CCxChannelCmd
       8   HAL_TIM_Encoder_Stop_IT
         8   -> TIM_CCxChannelCmd
       0   HAL_TIM_ErrorCallback
       0   HAL_TIM_GenerateEvent
       0   HAL_TIM_IC_CaptureCallback
      24   HAL_TIM_IC_ConfigChannel
        24   -> TIM_TI1_SetConfig
        24   -> TIM_TI2_SetConfig
       8   HAL_TIM_IC_DeInit
         8   -> HAL_TIM_IC_MspDeInit
       0   HAL_TIM_IC_GetState
      16   HAL_TIM_IC_Init
        16   -> HAL_TIM_IC_MspInit
        16   -> TIM_Base_SetConfig
       0   HAL_TIM_IC_MspDeInit
       0   HAL_TIM_IC_MspInit
       8   HAL_TIM_IC_Start
         8   -> TIM_CCxChannelCmd
      16   HAL_TIM_IC_Start_DMA
        16   -> HAL_DMA_Start_IT
        16   -> TIM_CCxChannelCmd
       8   HAL_TIM_IC_Start_IT
         8   -> TIM_CCxChannelCmd
       8   HAL_TIM_IC_Stop
         8   -> TIM_CCxChannelCmd
       8   HAL_TIM_IC_Stop_DMA
         8   -> TIM_CCxChannelCmd
       8   HAL_TIM_IC_Stop_IT
         8   -> TIM_CCxChannelCmd
      16   HAL_TIM_IRQHandler
        16   -> HAL_TIMEx_BreakCallback
         0   -> HAL_TIMEx_CommutationCallback
        16   -> HAL_TIM_IC_CaptureCallback
        16   -> HAL_TIM_OC_DelayElapsedCallback
        16   -> HAL_TIM_PWM_PulseFinishedCallback
        16   -> HAL_TIM_PeriodElapsedCallback
        16   -> HAL_TIM_TriggerCallback
       8   HAL_TIM_OC_ConfigChannel
         8   -> TIM_OC1_SetConfig
         8   -> TIM_OC2_SetConfig
         8   -> TIM_OC3_SetConfig
         8   -> TIM_OC4_SetConfig
       8   HAL_TIM_OC_DeInit
         8   -> HAL_TIM_OC_MspDeInit
       0   HAL_TIM_OC_DelayElapsedCallback
       0   HAL_TIM_OC_GetState
      16   HAL_TIM_OC_Init
        16   -> HAL_TIM_OC_MspInit
        16   -> TIM_Base_SetConfig
       0   HAL_TIM_OC_MspDeInit
       0   HAL_TIM_OC_MspInit
       8   HAL_TIM_OC_Start
         8   -> TIM_CCxChannelCmd
      16   HAL_TIM_OC_Start_DMA
        16   -> HAL_DMA_Start_IT
        16   -> TIM_CCxChannelCmd
       8   HAL_TIM_OC_Start_IT
         8   -> TIM_CCxChannelCmd
       8   HAL_TIM_OC_Stop
         8   -> TIM_CCxChannelCmd
       8   HAL_TIM_OC_Stop_DMA
         8   -> TIM_CCxChannelCmd
       8   HAL_TIM_OC_Stop_IT
         8   -> TIM_CCxChannelCmd
      56   HAL_TIM_OnePulse_ConfigChannel
        56   -> TIM_OC1_SetConfig
        56   -> TIM_OC2_SetConfig
        56   -> TIM_TI1_SetConfig
        56   -> TIM_TI2_SetConfig
       8   HAL_TIM_OnePulse_DeInit
         8   -> HAL_TIM_OnePulse_MspDeInit
       0   HAL_TIM_OnePulse_GetState
      16   HAL_TIM_OnePulse_Init
        16   -> HAL_TIM_OnePulse_MspInit
        16   -> TIM_Base_SetConfig
       0   HAL_TIM_OnePulse_MspDeInit
       0   HAL_TIM_OnePulse_MspInit
       8   HAL_TIM_OnePulse_Start
         8   -> TIM_CCxChannelCmd
       8   HAL_TIM_OnePulse_Start_IT
         8   -> TIM_CCxChannelCmd
       8   HAL_TIM_OnePulse_Stop
         8   -> TIM_CCxChannelCmd
       8   HAL_TIM_OnePulse_Stop_IT
         8   -> TIM_CCxChannelCmd
      16   HAL_TIM_PWM_ConfigChannel
        16   -> TIM_OC1_SetConfig
        16   -> TIM_OC2_SetConfig
        16   -> TIM_OC3_SetConfig
        16   -> TIM_OC4_SetConfig
       8   HAL_TIM_PWM_DeInit
         8   -> HAL_TIM_PWM_MspDeInit
       0   HAL_TIM_PWM_GetState
      16   HAL_TIM_PWM_Init
        16   -> HAL_TIM_PWM_MspInit
        16   -> TIM_Base_SetConfig
       0   HAL_TIM_PWM_MspDeInit
       0   HAL_TIM_PWM_MspInit
       0   HAL_TIM_PWM_PulseFinishedCallback
       8   HAL_TIM_PWM_Start
         8   -> TIM_CCxChannelCmd
      16   HAL_TIM_PWM_Start_DMA
        16   -> HAL_DMA_Start_IT
        16   -> TIM_CCxChannelCmd
       8   HAL_TIM_PWM_Start_IT
         8   -> TIM_CCxChannelCmd
       8   HAL_TIM_PWM_Stop
         8   -> TIM_CCxChannelCmd
       8   HAL_TIM_PWM_Stop_DMA
         8   -> TIM_CCxChannelCmd
       8   HAL_TIM_PWM_Stop_IT
         8   -> TIM_CCxChannelCmd
       0   HAL_TIM_PeriodElapsedCallback
       0   HAL_TIM_ReadCapturedValue
      16   HAL_TIM_SlaveConfigSynchronization
        16   -> TIM_ETR_SetConfig
        16   -> TIM_TI1_ConfigInputStage
        16   -> TIM_TI2_ConfigInputStage
      16   HAL_TIM_SlaveConfigSynchronization_IT
        16   -> TIM_ETR_SetConfig
        16   -> TIM_TI1_ConfigInputStage
        16   -> TIM_TI2_ConfigInputStage
       0   HAL_TIM_TriggerCallback
      20   TIM_Base_SetConfig
       8   TIM_CCxChannelCmd
       8   TIM_DMACaptureCplt
         8   -> HAL_TIM_IC_CaptureCallback
       8   TIM_DMADelayPulseCplt
         8   -> HAL_TIM_PWM_PulseFinishedCallback
       8   TIM_DMAError
         8   -> HAL_TIM_ErrorCallback
       8   TIM_DMAPeriodElapsedCplt
         8   -> HAL_TIM_PeriodElapsedCallback
       8   TIM_DMATriggerCplt
         8   -> HAL_TIM_TriggerCallback
       8   TIM_ETR_SetConfig
       0   TIM_ITRx_SetConfig
      12   TIM_OC1_SetConfig
      16   TIM_OC2_SetConfig
      16   TIM_OC3_SetConfig
      12   TIM_OC4_SetConfig
       8   TIM_TI1_ConfigInputStage
      16   TIM_TI1_SetConfig
       8   TIM_TI2_ConfigInputStage
      12   TIM_TI2_SetConfig


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable17
       4  ??DataTable17_1
       4  ??DataTable17_2
       4  ??DataTable18
       4  ??DataTable19
       4  ??DataTable20
       4  ??DataTable22
       4  ??DataTable22_1
       4  ??DataTable22_2
       4  ??DataTable29
       4  ??DataTable29_1
       4  ??DataTable29_10
       4  ??DataTable29_11
       4  ??DataTable29_12
       4  ??DataTable29_13
       4  ??DataTable29_14
       4  ??DataTable29_15
       4  ??DataTable29_2
       4  ??DataTable29_3
       4  ??DataTable29_4
       4  ??DataTable29_5
       4  ??DataTable29_6
       4  ??DataTable29_7
       4  ??DataTable29_8
       4  ??DataTable29_9
      22  ?Subroutine0
      20  ?Subroutine1
       6  ?Subroutine10
      12  ?Subroutine11
      12  ?Subroutine12
      24  ?Subroutine13
      10  ?Subroutine14
      14  ?Subroutine15
      10  ?Subroutine16
       8  ?Subroutine17
      18  ?Subroutine18
      14  ?Subroutine19
      14  ?Subroutine2
      10  ?Subroutine20
       8  ?Subroutine21
      10  ?Subroutine22
      10  ?Subroutine23
       8  ?Subroutine24
      10  ?Subroutine25
      10  ?Subroutine26
      26  ?Subroutine27
      10  ?Subroutine28
      10  ?Subroutine29
      14  ?Subroutine3
      18  ?Subroutine30
      20  ?Subroutine31
      20  ?Subroutine32
      20  ?Subroutine33
      20  ?Subroutine34
      10  ?Subroutine35
      10  ?Subroutine36
      10  ?Subroutine37
      10  ?Subroutine38
      14  ?Subroutine39
       8  ?Subroutine4
      10  ?Subroutine40
      10  ?Subroutine41
      10  ?Subroutine42
      10  ?Subroutine43
      10  ?Subroutine44
      10  ?Subroutine45
      10  ?Subroutine46
      10  ?Subroutine47
      10  ?Subroutine48
      10  ?Subroutine49
       6  ?Subroutine5
      10  ?Subroutine50
      10  ?Subroutine51
      10  ?Subroutine52
      12  ?Subroutine53
      12  ?Subroutine54
      20  ?Subroutine55
      14  ?Subroutine56
      24  ?Subroutine57
      22  ?Subroutine58
      18  ?Subroutine59
      20  ?Subroutine6
       8  ?Subroutine60
       6  ?Subroutine61
      12  ?Subroutine62
       8  ?Subroutine63
       8  ?Subroutine64
       8  ?Subroutine65
      10  ?Subroutine66
      10  ?Subroutine67
       8  ?Subroutine68
       6  ?Subroutine69
       6  ?Subroutine7
      90  ?Subroutine8
      20  ?Subroutine9
      26  HAL_TIM_Base_DeInit
       2  HAL_TIM_Base_GetState
      38  HAL_TIM_Base_Init
       2  HAL_TIM_Base_MspDeInit
       2  HAL_TIM_Base_MspInit
      18  HAL_TIM_Base_Start
      70  HAL_TIM_Base_Start_DMA
      22  HAL_TIM_Base_Start_IT
      28  HAL_TIM_Base_Stop
      30  HAL_TIM_Base_Stop_DMA
      42  HAL_TIM_Base_Stop_IT
     184  HAL_TIM_ConfigClockSource
     148  HAL_TIM_ConfigOCrefClear
      16  HAL_TIM_ConfigTI1Input
     234  HAL_TIM_DMABurst_ReadStart
       2  HAL_TIM_DMABurst_ReadStop
     234  HAL_TIM_DMABurst_WriteStart
       4  HAL_TIM_DMABurst_WriteStop
      28  HAL_TIM_Encoder_DeInit
       2  HAL_TIM_Encoder_GetState
     140  HAL_TIM_Encoder_Init
       2  HAL_TIM_Encoder_MspDeInit
       2  HAL_TIM_Encoder_MspInit
      32  HAL_TIM_Encoder_Start
     174  HAL_TIM_Encoder_Start_DMA
      60  HAL_TIM_Encoder_Start_IT
      46  HAL_TIM_Encoder_Stop
      76  HAL_TIM_Encoder_Stop_DMA
      70  HAL_TIM_Encoder_Stop_IT
       2  HAL_TIM_ErrorCallback
      36  HAL_TIM_GenerateEvent
       2  HAL_TIM_IC_CaptureCallback
     278  HAL_TIM_IC_ConfigChannel
      26  HAL_TIM_IC_DeInit
       2  HAL_TIM_IC_GetState
      28  HAL_TIM_IC_Init
       2  HAL_TIM_IC_MspDeInit
       2  HAL_TIM_IC_MspInit
      10  HAL_TIM_IC_Start
     166  HAL_TIM_IC_Start_DMA
      54  HAL_TIM_IC_Start_IT
      26  HAL_TIM_IC_Stop
      66  HAL_TIM_IC_Stop_DMA
      66  HAL_TIM_IC_Stop_IT
     352  HAL_TIM_IRQHandler
      76  HAL_TIM_OC_ConfigChannel
      24  HAL_TIM_OC_DeInit
       2  HAL_TIM_OC_DelayElapsedCallback
       2  HAL_TIM_OC_GetState
      28  HAL_TIM_OC_Init
       2  HAL_TIM_OC_MspDeInit
       2  HAL_TIM_OC_MspInit
      20  HAL_TIM_OC_Start
     106  HAL_TIM_OC_Start_DMA
      62  HAL_TIM_OC_Start_IT
      50  HAL_TIM_OC_Stop
      92  HAL_TIM_OC_Stop_DMA
      88  HAL_TIM_OC_Stop_IT
     196  HAL_TIM_OnePulse_ConfigChannel
      26  HAL_TIM_OnePulse_DeInit
       2  HAL_TIM_OnePulse_GetState
      66  HAL_TIM_OnePulse_Init
       2  HAL_TIM_OnePulse_MspDeInit
       2  HAL_TIM_OnePulse_MspInit
      28  HAL_TIM_OnePulse_Start
      36  HAL_TIM_OnePulse_Start_IT
      54  HAL_TIM_OnePulse_Stop
      64  HAL_TIM_OnePulse_Stop_IT
     184  HAL_TIM_PWM_ConfigChannel
      26  HAL_TIM_PWM_DeInit
       2  HAL_TIM_PWM_GetState
      26  HAL_TIM_PWM_Init
       2  HAL_TIM_PWM_MspDeInit
       2  HAL_TIM_PWM_MspInit
       2  HAL_TIM_PWM_PulseFinishedCallback
      20  HAL_TIM_PWM_Start
     106  HAL_TIM_PWM_Start_DMA
      64  HAL_TIM_PWM_Start_IT
      50  HAL_TIM_PWM_Stop
      92  HAL_TIM_PWM_Stop_DMA
      90  HAL_TIM_PWM_Stop_IT
       2  HAL_TIM_PeriodElapsedCallback
      66  HAL_TIM_ReadCapturedValue
     134  HAL_TIM_SlaveConfigSynchronization
     168  HAL_TIM_SlaveConfigSynchronization_IT
       2  HAL_TIM_TriggerCallback
     144  TIM_Base_SetConfig
      24  TIM_CCxChannelCmd
      50  TIM_DMACaptureCplt
      48  TIM_DMADelayPulseCplt
      12  TIM_DMAError
      12  TIM_DMAPeriodElapsedCplt
      12  TIM_DMATriggerCplt
      20  TIM_ETR_SetConfig
      16  TIM_ITRx_SetConfig
      80  TIM_OC1_SetConfig
      88  TIM_OC2_SetConfig
      86  TIM_OC3_SetConfig
      70  TIM_OC4_SetConfig
      34  TIM_TI1_ConfigInputStage
     102  TIM_TI1_SetConfig
      36  TIM_TI2_ConfigInputStage
      52  TIM_TI2_SetConfig

 
 6 854 bytes in section .text
 
 6 854 bytes of CODE memory

Errors: none
Warnings: none
