###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.2.10312/W32 for ARM       20/Dec/2015  12:46:30
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\Src\main.c
#    Command line =  
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\Src\main.c
#        -D USE_HAL_DRIVER -D STM32F746xx -D USE_STM32746G_DISCO -D
#        USE_IOEXPANDER -D USE_USB_FS -lC
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
#        -lA
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
#        -o
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj
#        --debug --endian=little --cpu=Cortex-M7 -e --fpu=VFPv5_sp
#        --dlib_config "D:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Full.h" -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\Inc\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\CMSIS\Device\ST\STM32F7xx\Include\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\STM32F7xx_HAL_Driver\Inc\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\STM32746G-Discovery\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\Components\Common\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Log\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Fonts\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\CPU\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_Device_Library\Core\Inc\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Core\Inc\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Class\MSC\Inc\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\drivers\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_Audio\Addons\PDM\
#        -Ohz --use_c++_inline --require_prototypes -I "D:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.3\arm\CMSIS\Include\" -D
#        ARM_MATH_CM7
#    List file    =  
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List\main.lst
#    Object file  =  
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj\main.o
#
###############################################################################

H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\Src\main.c
      1          /**
      2            ******************************************************************************
      3            * @file    Audio/Mic_Array/Src/main.c
      4            * @author  Phan Le Son
      5            * @version V1.0.0
      6            * @date    12-Dec-2015 
      7            * @brief   Microphone Array
      8            ******************************************************************************
      9          
     10            */
     11          
     12          /* Includes ------------------------------------------------------------------*/
     13          
     14          #include "pdm_filter.h"
     15          #include "main.h"
     16          #include <stdio.h>
     17          
     18          
     19          /* Private typedef -----------------------------------------------------------*/
     20          /* Private define ------------------------------------------------------------*/
     21          /* Private macro -------------------------------------------------------------*/
     22          
     23          
     24          /* I2C TIMING Register define when I2C clock source is APB1 (SYSCLK/4) */
     25          /* I2C TIMING is calculated in case of the I2C Clock source is the APB1CLK = 50 MHz */
     26          /* This example use TIMING to 0x40912732 to reach 100 kHz speed (Rise time = 700 ns, Fall time = 100 ns) */
     27          
     28          #define AUDIO_FILE_SZE          990000
     29          #define AUIDO_START_ADDRESS     58 /* Offset relative to audio file header size */
     30          
     31          #define DEBUG           0
     32          
     33          
     34          /* Private variables ---------------------------------------------------------*/

   \                                 In section .bss, align 4
     35          USBH_HandleTypeDef hUSBHost;
   \                     hUSBHost:
   \   00000000                      DS8 696

   \                                 In section .bss, align 1
     36          AUDIO_ApplicationTypeDef appli_state = APPLICATION_IDLE;//APPLICATION_IDLE
   \                     appli_state:
   \   00000000                      DS8 1
     37          
     38          extern I2C_HandleTypeDef hi2c1;

   \                                 In section .bss, align 4
     39          UART_HandleTypeDef huart6;
   \                     huart6:
   \   00000000                      DS8 112

   \                                 In section .bss, align 4
     40          SPI_HandleTypeDef hspi5;
   \                     hspi5:
   \   00000000                      DS8 100
     41          GPIO_InitTypeDef GPIO_INS;
     42          
     43          AUDIO_IN_BufferTypeDef Buffer1, Buffer2;
     44          AUDIO_IN_BufferTypeDef Buffer3;
     45          
     46          

   \                                 In section .data, align 4
     47          uint8_t  pI2CData[20]= {0,10,20,30,40,50,60,70,80,90,100,110,120,130,140,150,160,170,180,190};
   \                     pI2CData:
   \   00000000   0x00 0x0A          DC8 0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120, 130, 140, 150
   \              0x14 0x1E    
   \              0x28 0x32    
   \              0x3C 0x46    
   \              0x50 0x5A    
   \              0x64 0x6E    
   \              0x78 0x82    
   \              0x8C 0x96    
   \   00000010   0xA0 0xAA          DC8 160, 170, 180, 190
   \              0xB4 0xBE    

   \                                 In section .bss, align 4
     48          uint8_t  pI2CRx[10];
     49          extern uint8_t  pcSTAComnd[19];
     50          extern const uint16_t AUDIO_SAMPLE[];
     51          
     52          uint16_t __IO idxSPI5DataBuf1, idxSPI5DataBuf2;
     53          uint16_t __IO cntRisingEXTI;
     54          
     55          /* Buffer used for reception */
     56          uint8_t aRxBuffer[1024];
     57          
     58          
     59          #if (DEBUG)
     60          uint8_t  pUARTBuf[128];
     61          #endif
     62          
     63          /* Private function prototypes -----------------------------------------------*/
     64          static void SystemClock_Config(void);
     65          static void USBH_UserProcess(USBH_HandleTypeDef *phost, uint8_t id);
                             ^
Warning[Pe177]: function "USBH_UserProcess" was declared but never referenced
     66          static void AUDIO_InitApplication(void);
                             ^
Warning[Pe177]: function "AUDIO_InitApplication" was declared but never
          referenced
     67          static void CPU_CACHE_Enable(void);
     68          static void SystemClock_Config1(void);
                             ^
Warning[Pe177]: function "SystemClock_Config1" was declared but never
          referenced
     69          static uint16_t SPI_I2S_ReceiveData(SPI_TypeDef* SPIx);
     70          
     71          void UART6_Init(void);
     72          void MX_SPI5_Init(void);
     73          void ReadSTASeq(uint8_t Addr, uint8_t *pBufOut,uint8_t Len );
     74          void WriteSTAByte(uint8_t Addr, uint8_t *pBufIn, uint8_t len);
     75          void SPI5_CallBack(SPI_HandleTypeDef *hspi);
     76          static void SPI_I2S_SendData(SPI_TypeDef* SPIx, uint16_t Data);
     77          
     78          
     79          char __IO flg10ms;
   \                     flg10ms:
   \   00000000                      DS8 1
   \   00000001                      DS8 3
   \                     GPIO_INS:
   \   00000004                      DS8 20
     80          uint8_t flgSTAIni;
     81          
     82          
     83          /* Private functions ---------------------------------------------------------*/
     84          
     85          /**
     86            * @brief  Main program
     87            * @param  None
     88            * @retval None
     89            */

   \                                 In section .text, align 2, keep-with-next
     90          int main(void)
     91          {
   \                     main: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
     92          
     93             uint8_t j;
     94             j=0;
   \   00000004   0x2400             MOVS     R4,#+0
     95            /* Enable the CPU Cache */
     96            CPU_CACHE_Enable();
   \   00000006   0x.... 0x....      BL       ?Subroutine0
   \                     ??CrossCallReturnLabel_0: (+1)
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable10  ;; 0xe000ef50
   \   0000000E   0x.... 0x....      LDR.W    R1,??DataTable10_1  ;; 0xe000ed14
   \   00000012   0x6004             STR      R4,[R0, #+0]
   \   00000014   0x680A             LDR      R2,[R1, #+0]
   \   00000016   0xF442 0x3200      ORR      R2,R2,#0x20000
   \   0000001A   0x600A             STR      R2,[R1, #+0]
   \   0000001C   0x.... 0x....      BL       ?Subroutine0
   \                     ??CrossCallReturnLabel_1: (+1)
   \   00000020   0x670C             STR      R4,[R1, #+112]
   \   00000022   0xF3BF 0x8F4F      DSB      
   \   00000026   0x6ECA             LDR      R2,[R1, #+108]
   \   00000028   0xF3C2 0x334E      UBFX     R3,R2,#+13,#+15
   \                     ??main_0: (+1)
   \   0000002C   0xF3C2 0x05C9      UBFX     R5,R2,#+3,#+10
   \                     ??main_1: (+1)
   \   00000030   0xF643 0x76E0      MOVW     R6,#+16352
   \   00000034   0xEA06 0x1643      AND      R6,R6,R3, LSL #+5
   \   00000038   0xEA46 0x7685      ORR      R6,R6,R5, LSL #+30
   \   0000003C   0x6106             STR      R6,[R0, #+16]
   \   0000003E   0x462E             MOV      R6,R5
   \   00000040   0x1E75             SUBS     R5,R6,#+1
   \   00000042   0x2E00             CMP      R6,#+0
   \   00000044   0xD1F4             BNE.N    ??main_1
   \   00000046   0x461D             MOV      R5,R3
   \   00000048   0x1E6B             SUBS     R3,R5,#+1
   \   0000004A   0x2D00             CMP      R5,#+0
   \   0000004C   0xD1EE             BNE.N    ??main_0
   \   0000004E   0xF3BF 0x8F4F      DSB      
   \   00000052   0x6808             LDR      R0,[R1, #+0]
   \   00000054   0xF440 0x3080      ORR      R0,R0,#0x10000
   \   00000058   0x6008             STR      R0,[R1, #+0]
   \   0000005A   0x.... 0x....      BL       ?Subroutine0
     97            
     98            /* STM32F7xx HAL library initialization:
     99                 - Configure the Flash ART accelerator on ITCM interface
    100                 - Configure the Systick to generate an interrupt each 1 msec
    101                 - Set NVIC Group Priority to 4
    102                 - Global MSP (MCU Support Package) initialization
    103               */   
    104            HAL_Init();
   \                     ??CrossCallReturnLabel_2: (+1)
   \   0000005E   0x.... 0x....      BL       HAL_Init
    105            
    106            /* Configure the system clock to 216 MHz */
    107            SystemClock_Config(); 
   \   00000062   0x.... 0x....      BL       SystemClock_Config
    108            //SystemClock_Config1();
    109          
    110            /* Init Audio Application */
    111            //AUDIO_InitApplication();
    112              /* Configure LED1 */
    113            BSP_LED_Init(LED1);
   \   00000066   0x2000             MOVS     R0,#+0
   \   00000068   0x.... 0x....      LDR.W    R5,??DataTable10_2
   \   0000006C   0x.... 0x....      BL       BSP_LED_Init
    114            BSP_LED_Init(LED2);
   \   00000070   0x2001             MOVS     R0,#+1
   \   00000072   0x.... 0x....      BL       BSP_LED_Init
    115            
    116            /* Initialize for Audio player with CS43L22 */
    117             WavePlayerInit(48000);
   \   00000076   0xF64B 0x3080      MOVW     R0,#+48000
   \   0000007A   0x.... 0x....      BL       WavePlayerInit
    118          
    119              /* Play on */
    120            AudioFlashPlay((uint16_t*)(AUDIO_SAMPLE + AUIDO_START_ADDRESS),AUDIO_FILE_SZE,AUIDO_START_ADDRESS);
   \   0000007E   0x223A             MOVS     R2,#+58
   \   00000080   0x.... 0x....      LDR.W    R1,??DataTable10_3  ;; 0xf1b30
   \   00000084   0x.... 0x....      LDR.W    R0,??DataTable10_4
   \   00000088   0x.... 0x....      BL       AudioFlashPlay
    121            
    122            /* Init TS module */
    123            //BSP_TS_Init(BSP_LCD_GetXSize(), BSP_LCD_GetYSize());
    124          
    125            /* Init Host Library */
    126            //USBH_Init(&hUSBHost, USBH_UserProcess, 0);
    127          
    128            /* Add Supported Class */
    129            //USBH_RegisterClass(&hUSBHost, USBH_MSC_CLASS);
    130            
    131            /* Start Host Process */
    132            //USBH_Start(&hUSBHost);
    133          
    134           
    135            
    136           
    137          
    138             /* ----------------------*/
    139             __GPIOB_CLK_ENABLE();
   \   0000008C   0x.... 0x....      LDR.W    R0,??DataTable10_5  ;; 0x40023830
   \   00000090   0x6801             LDR      R1,[R0, #+0]
   \   00000092   0xF041 0x0102      ORR      R1,R1,#0x2
   \   00000096   0x6001             STR      R1,[R0, #+0]
   \   00000098   0x6800             LDR      R0,[R0, #+0]
    140            GPIO_INS.Pin = GPIO_PIN_4;
    141            GPIO_INS.Mode =GPIO_MODE_IT_RISING;
    142            GPIO_INS.Pull =GPIO_NOPULL;
    143            GPIO_INS.Speed =GPIO_SPEED_HIGH;
    144            HAL_GPIO_Init(GPIOB,&GPIO_INS);
   \   0000009A   0x1D29             ADDS     R1,R5,#+4
   \   0000009C   0xF000 0x0002      AND      R0,R0,#0x2
   \   000000A0   0x9000             STR      R0,[SP, #+0]
   \   000000A2   0x9800             LDR      R0,[SP, #+0]
   \   000000A4   0x2010             MOVS     R0,#+16
   \   000000A6   0x60EC             STR      R4,[R5, #+12]
   \   000000A8   0x6068             STR      R0,[R5, #+4]
   \   000000AA   0x.... 0x....      LDR.W    R0,??DataTable10_6  ;; 0x10110000
   \   000000AE   0x60A8             STR      R0,[R5, #+8]
   \   000000B0   0x2003             MOVS     R0,#+3
   \   000000B2   0x6128             STR      R0,[R5, #+16]
   \   000000B4   0x.... 0x....      LDR.W    R0,??DataTable10_7  ;; 0x40020400
   \   000000B8   0x.... 0x....      BL       HAL_GPIO_Init
    145          
    146            /* Enable and set Button EXTI Interrupt to the lowest priority */
    147            HAL_NVIC_SetPriority((IRQn_Type)EXTI4_IRQn, 0x0F, 0x00);
   \   000000BC   0x2200             MOVS     R2,#+0
   \   000000BE   0x210F             MOVS     R1,#+15
   \   000000C0   0x200A             MOVS     R0,#+10
   \   000000C2   0x.... 0x....      BL       HAL_NVIC_SetPriority
    148            HAL_NVIC_EnableIRQ((IRQn_Type)EXTI4_IRQn);
   \   000000C6   0x200A             MOVS     R0,#+10
   \   000000C8   0x.... 0x....      BL       HAL_NVIC_EnableIRQ
    149            /*-----------------------*/
    150          	
    151          
    152            //sop1hc
    153            ///////Audio_Streaming_Ini();
    154            /* control the STA321 */
    155            ///////MX_I2C1_Init(); 
    156            //MX_SPI5_Init();
    157            //HAL_Delay(10000);
    158            //__HAL_SPI_DISABLE(&hspi5);
    159            
    160            ////////I2S_Init();
    161          
    162            ////////STA321MP_Ini();	
    163          #if (DEBUG)  
    164            /* UART for debug */
    165            UART6_Init();
    166          #endif
    167            
    168          
    169          
    170           
    171            /* Run Application (Blocking mode) */
    172            while (1)
    173            {
    174          
    175          
    176          	/* USB Host Background task */
    177              //USBH_Process(&hUSBHost);
    178              
    179              /* AUDIO Menu Process */
    180              //AUDIO_MenuProcess();
    181          
    182          
    183          
    184              	  //if(HAL_SPI_TransmitReceive_IT(&hspi5, (uint8_t*)&Buffer1.pcm_buff[0], (uint8_t *)aRxBuffer, 1024) != HAL_OK)
    185                   {
    186                      /* Transfer error in transmission process */
    187                     //Error_Handler();
    188                    }
    189              if (flg10ms==1)
   \                     ??main_2: (+1)
   \   000000CC   0x7828             LDRB     R0,[R5, #+0]
   \   000000CE   0x2801             CMP      R0,#+1
   \   000000D0   0xD1FC             BNE.N    ??main_2
    190              {
    191                  flg10ms=0;
    192          		
    193                  //BSP_LED_Toggle(LED1);
    194          
    195          
    196                  //HAL_SPI_Receive_IT(&hspi5,(uint8_t *)&Buffer1.pcm_buff[0],124);
    197          	    //HAL_SPI_Receive(&hspi5,(uint8_t *)aRxBuffer,124,1000);
    198          
    199          	    //ReadSTASeq(pI2CData[j], pI2CRx, 10);
    200          		 
    201          
    202          #if (DEBUG)
    203          	     for(uint8_t i=0;i<10;i++)
    204          	     {
    205          		    sprintf(pUARTBuf,"Reg[ 0x%.2X ]: 0x%.2X \r\n",(pI2CData[j]+i),pI2CRx[i]);
    206          
    207          	        while(HAL_UART_Transmit(&huart6,pUARTBuf,20,1000)!= HAL_OK)
    208          	        {
    209          	          ;
    210          	        }
    211          	     }		   
    212          #endif
    213          
    214               
    215                 j++;
   \   000000D2   0x1C64             ADDS     R4,R4,#+1
   \   000000D4   0x2000             MOVS     R0,#+0
    216          
    217                 if (j==100) //50*10ms = 500 ms
   \   000000D6   0xB2E4             UXTB     R4,R4
   \   000000D8   0x2C64             CMP      R4,#+100
   \   000000DA   0x7028             STRB     R0,[R5, #+0]
   \   000000DC   0xD1F6             BNE.N    ??main_2
    218                 {
    219           
    220          
    221          #if (DEBUG)
    222          		 sprintf(pUARTBuf,"------------------");
    223          		 while(HAL_UART_Transmit(&huart6,pUARTBuf,30,1000)!= HAL_OK)
    224          	     {
    225          	          ;
    226          	      }
    227          #endif
    228                   BSP_LED_Toggle(LED1);
   \   000000DE   0x.... 0x....      BL       BSP_LED_Toggle
    229          		 BSP_LED_Toggle(LED2);
   \   000000E2   0x2001             MOVS     R0,#+1
   \   000000E4   0x2400             MOVS     R4,#+0
   \   000000E6   0x.... 0x....      BL       BSP_LED_Toggle
    230          	   	 j=0;
   \   000000EA   0xE7EF             B.N      ??main_2
    231                           
    232                 }
    233          
    234          
    235              }
    236            }
    237            
    238          }
    239          
    240          /**
    241            * @brief  Toggle Leds.
    242            * @param  None
    243            * @retval None
    244            */

   \                                 In section .text, align 2, keep-with-next
    245          void Toggle_Leds(void)
    246          {
    247            static uint32_t ticks = 0;
    248          
    249            if (ticks++ > 200)
   \                     Toggle_Leds: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable10_8
   \   00000004   0x6801             LDR      R1,[R0, #+0]
   \   00000006   0x1C4A             ADDS     R2,R1,#+1
   \   00000008   0x29C9             CMP      R1,#+201
   \   0000000A   0xBF28             IT       CS 
   \   0000000C   0x2200             MOVCS    R2,#+0
    250            {
    251              //BSP_LED_Toggle(LED1);
    252              ticks = 0;
   \   0000000E   0x6002             STR      R2,[R0, #+0]
    253            }
    254          }
   \   00000010   0x4770             BX       LR               ;; return
    255          
    256          
    257          /**
    258            * @brief  System Clock Configuration
    259            *         The system Clock is configured as follow : 
    260            *            System Clock source            = PLL (HSE)
    261            *            SYSCLK(Hz)                     = 216000000
    262            *            HCLK(Hz)                       = 216000000
    263            *            AHB Prescaler                  = 1
    264            *            APB1 Prescaler                 = 4
    265            *            APB2 Prescaler                 = 2
    266            *            HSE Frequency(Hz)              = 25000000
    267            *            PLL_M                          = 25
    268            *            PLL_N                          = 432
    269            *            PLL_P                          = 2
    270            *            PLL_Q                          = 9
    271            *            VDD(V)                         = 3.3
    272            *            Main regulator output voltage  = Scale1 mode
    273            *            Flash Latency(WS)              = 7
    274            * @param  None
    275            * @retval None
    276            */

   \                                 In section .text, align 2, keep-with-next
    277          static void SystemClock_Config(void)
    278          {
   \                     SystemClock_Config: (+1)
   \   00000000   0xB500             PUSH     {LR}
    279          
    280             RCC_OscInitTypeDef RCC_OscInitStruct;
    281            RCC_ClkInitTypeDef RCC_ClkInitStruct;
    282            RCC_PeriphCLKInitTypeDef PeriphClkInitStruct;
    283          
    284            __PWR_CLK_ENABLE();
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable10_9  ;; 0x40023840
   \   00000006   0xB0B3             SUB      SP,SP,#+204
   \   00000008   0x6801             LDR      R1,[R0, #+0]
   \   0000000A   0xF041 0x5180      ORR      R1,R1,#0x10000000
   \   0000000E   0x6001             STR      R1,[R0, #+0]
   \   00000010   0x6800             LDR      R0,[R0, #+0]
   \   00000012   0xF000 0x5080      AND      R0,R0,#0x10000000
   \   00000016   0x9000             STR      R0,[SP, #+0]
   \   00000018   0x9800             LDR      R0,[SP, #+0]
    285          
    286            __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE3);
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable10_10  ;; 0x40007000
   \   0000001E   0x6801             LDR      R1,[R0, #+0]
   \   00000020   0xF421 0x4140      BIC      R1,R1,#0xC000
   \   00000024   0xF441 0x4180      ORR      R1,R1,#0x4000
   \   00000028   0x6001             STR      R1,[R0, #+0]
   \   0000002A   0x6800             LDR      R0,[R0, #+0]
   \   0000002C   0xF400 0x4040      AND      R0,R0,#0xC000
   \   00000030   0x9000             STR      R0,[SP, #+0]
   \   00000032   0x9800             LDR      R0,[SP, #+0]
    287          
    288            RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
   \   00000034   0x2002             MOVS     R0,#+2
   \   00000036   0x9006             STR      R0,[SP, #+24]
    289            RCC_OscInitStruct.HSIState = RCC_HSI_ON;
   \   00000038   0x2001             MOVS     R0,#+1
   \   0000003A   0x9009             STR      R0,[SP, #+36]
    290            RCC_OscInitStruct.HSICalibrationValue = 16;
   \   0000003C   0x2010             MOVS     R0,#+16
   \   0000003E   0x900A             STR      R0,[SP, #+40]
    291            RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
   \   00000040   0x2002             MOVS     R0,#+2
   \   00000042   0x900C             STR      R0,[SP, #+48]
    292            RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0x900D             STR      R0,[SP, #+52]
    293            RCC_OscInitStruct.PLL.PLLM = 16;
   \   00000048   0x2010             MOVS     R0,#+16
   \   0000004A   0x900E             STR      R0,[SP, #+56]
    294            RCC_OscInitStruct.PLL.PLLN = 200;
   \   0000004C   0x20C8             MOVS     R0,#+200
   \   0000004E   0x900F             STR      R0,[SP, #+60]
    295            RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
   \   00000050   0x2002             MOVS     R0,#+2
   \   00000052   0x9010             STR      R0,[SP, #+64]
    296            RCC_OscInitStruct.PLL.PLLQ = 2;
   \   00000054   0x9011             STR      R0,[SP, #+68]
    297            HAL_RCC_OscConfig(&RCC_OscInitStruct);
   \   00000056   0xA806             ADD      R0,SP,#+24
   \   00000058   0x.... 0x....      BL       HAL_RCC_OscConfig
    298          
    299            HAL_PWREx_ActivateOverDrive();
   \   0000005C   0x.... 0x....      BL       HAL_PWREx_EnableOverDrive
    300          
    301            RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
    302                                        |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
   \   00000060   0x200F             MOVS     R0,#+15
    303            RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
    304            RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV2;
    305            RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
    306            RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
    307            HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_1);
   \   00000062   0x2101             MOVS     R1,#+1
   \   00000064   0x9001             STR      R0,[SP, #+4]
   \   00000066   0x2002             MOVS     R0,#+2
   \   00000068   0x9002             STR      R0,[SP, #+8]
   \   0000006A   0x2080             MOVS     R0,#+128
   \   0000006C   0x9003             STR      R0,[SP, #+12]
   \   0000006E   0x2000             MOVS     R0,#+0
   \   00000070   0x9004             STR      R0,[SP, #+16]
   \   00000072   0x9005             STR      R0,[SP, #+20]
   \   00000074   0xA801             ADD      R0,SP,#+4
   \   00000076   0x.... 0x....      BL       HAL_RCC_ClockConfig
    308          
    309            PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_UART4|RCC_PERIPHCLK_I2C1
    310                                        |RCC_PERIPHCLK_I2C2|RCC_PERIPHCLK_I2S;
   \   0000007A   0xF24C 0x2001      MOVW     R0,#+49665
   \   0000007E   0x9012             STR      R0,[SP, #+72]
    311            PeriphClkInitStruct.PLLI2S.PLLI2SN = 192;
   \   00000080   0x20C0             MOVS     R0,#+192
   \   00000082   0x9013             STR      R0,[SP, #+76]
    312            PeriphClkInitStruct.PLLI2S.PLLI2SP = 0;
   \   00000084   0x2000             MOVS     R0,#+0
   \   00000086   0x9016             STR      R0,[SP, #+88]
    313            PeriphClkInitStruct.PLLI2S.PLLI2SR = 2;
   \   00000088   0x2002             MOVS     R0,#+2
   \   0000008A   0x9014             STR      R0,[SP, #+80]
    314            PeriphClkInitStruct.PLLI2S.PLLI2SQ = 2;
   \   0000008C   0x9015             STR      R0,[SP, #+84]
    315            PeriphClkInitStruct.PLLI2SDivQ = 1;
   \   0000008E   0x2001             MOVS     R0,#+1
   \   00000090   0x901B             STR      R0,[SP, #+108]
    316            PeriphClkInitStruct.I2sClockSelection = RCC_I2SCLKSOURCE_PLLI2S;
   \   00000092   0x2000             MOVS     R0,#+0
   \   00000094   0x901F             STR      R0,[SP, #+124]
    317            PeriphClkInitStruct.Uart4ClockSelection = RCC_UART4CLKSOURCE_PCLK1;
   \   00000096   0x9026             STR      R0,[SP, #+152]
    318            PeriphClkInitStruct.I2c1ClockSelection = RCC_I2C1CLKSOURCE_PCLK1;
   \   00000098   0x902B             STR      R0,[SP, #+172]
    319            PeriphClkInitStruct.I2c2ClockSelection = RCC_I2C2CLKSOURCE_PCLK1;
   \   0000009A   0x902C             STR      R0,[SP, #+176]
    320            HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct);
   \   0000009C   0xA812             ADD      R0,SP,#+72
   \   0000009E   0x.... 0x....      BL       HAL_RCCEx_PeriphCLKConfig
    321          
    322            HAL_SYSTICK_Config(HAL_RCC_GetHCLKFreq()/1000);
   \   000000A2   0x.... 0x....      BL       HAL_RCC_GetHCLKFreq
   \   000000A6   0xF44F 0x717A      MOV      R1,#+1000
   \   000000AA   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   000000AE   0x.... 0x....      BL       HAL_SYSTICK_Config
    323          
    324            HAL_SYSTICK_CLKSourceConfig(SYSTICK_CLKSOURCE_HCLK);
   \   000000B2   0x2004             MOVS     R0,#+4
   \   000000B4   0x.... 0x....      BL       HAL_SYSTICK_CLKSourceConfig
    325          }
   \   000000B8   0xB033             ADD      SP,SP,#+204
   \   000000BA   0xBD00             POP      {PC}             ;; return
    326          
    327          
    328          
    329          #ifdef  USE_FULL_ASSERT
    330          /**
    331            * @brief  Reports the name of the source file and the source line number
    332            *         where the assert_param error has occurred.
    333            * @param  file: pointer to the source file name
    334            * @param  line: assert_param error line source number
    335            * @retval None
    336            */
    337          void assert_failed(uint8_t* file, uint32_t line)
    338          { 
    339            /* User can add his own implementation to report the file name and line number,
    340               ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
    341          
    342            /* Infinite loop */
    343            while (1)
    344            {
    345            }
    346          }
    347          #endif
    348          
    349          /**
    350            * @brief  CPU L1-Cache enable.
    351            * @param  None
    352            * @retval None
    353            */
    354          static void CPU_CACHE_Enable(void)
    355          {
    356            /* Enable I-Cache */
    357            SCB_EnableICache();
    358          
    359            /* Enable D-Cache */
    360            SCB_EnableDCache();
    361          }
    362          
    363          
    364          /* I2C1 init function */

   \                                 In section .text, align 2, keep-with-next
    365          void MX_I2C1_Init(void)
    366          {
   \                     MX_I2C1_Init: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    367          
    368          
    369            hi2c1.Instance = I2C1;
   \   00000002   0x.... 0x....      LDR.W    R4,??DataTable10_11
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable10_12  ;; 0x40005400
   \   0000000A   0x6020             STR      R0,[R4, #+0]
    370            hi2c1.Init.Timing =DISCOVERY_I2Cx_TIMING; //I2C_SPEED DISCOVERY_I2Cx_TIMING;
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable10_13  ;; 0x40912732
   \   00000010   0x6060             STR      R0,[R4, #+4]
    371                                                     //I2C_TIMING ;//I2C_TIMING  0x00303D5D
    372            hi2c1.Init.OwnAddress1 = 0x33;
   \   00000012   0x2033             MOVS     R0,#+51
   \   00000014   0x60A0             STR      R0,[R4, #+8]
    373            hi2c1.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
   \   00000016   0x2001             MOVS     R0,#+1
   \   00000018   0x60E0             STR      R0,[R4, #+12]
    374            hi2c1.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0x6120             STR      R0,[R4, #+16]
    375            hi2c1.Init.OwnAddress2 = 0;
   \   0000001E   0x6160             STR      R0,[R4, #+20]
    376            hi2c1.Init.OwnAddress2Masks = I2C_OA2_NOMASK;
   \   00000020   0x61A0             STR      R0,[R4, #+24]
    377            hi2c1.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
   \   00000022   0x61E0             STR      R0,[R4, #+28]
    378            hi2c1.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
   \   00000024   0x6220             STR      R0,[R4, #+32]
    379            HAL_I2C_Init(&hi2c1);
   \   00000026   0x4620             MOV      R0,R4
   \   00000028   0x.... 0x....      BL       HAL_I2C_Init
    380          
    381              /**Configure Analogue filter 
    382              */
    383            HAL_I2CEx_AnalogFilter_Config(&hi2c1, I2C_ANALOGFILTER_ENABLE);
   \   0000002C   0x4620             MOV      R0,R4
   \   0000002E   0x2100             MOVS     R1,#+0
   \   00000030   0xE8BD 0x4010      POP      {R4,LR}
   \   00000034   0x.... 0x....      B.W      HAL_I2CEx_ConfigAnalogFilter
    384          
    385          }
    386          
    387          
    388          

   \                                 In section .text, align 2, keep-with-next
    389          void HAL_I2C_MspInit(I2C_HandleTypeDef* hi2c)
    390          {
   \                     HAL_I2C_MspInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB086             SUB      SP,SP,#+24
    391          
    392            GPIO_InitTypeDef GPIO_InitStruct;
    393              
    394            if(hi2c->Instance==I2C1)
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x....             LDR.N    R1,??DataTable10_12  ;; 0x40005400
   \   00000008   0x....             LDR.N    R4,??DataTable10_5  ;; 0x40023830
   \   0000000A   0x4288             CMP      R0,R1
   \   0000000C   0xD121             BNE.N    ??HAL_I2C_MspInit_0
    395            {
    396            /* USER CODE BEGIN I2C1_MspInit 0 */
    397          
    398              /*##-1- Configure the I2C clock source. The clock is derived from the SYSCLK #*/
    399              //RCC_PeriphCLKInitStruct.PeriphClockSelection = RCC_PERIPHCLK_I2C1;
    400              //RCC_PeriphCLKInitStruct.I2c1ClockSelection = RCC_I2C1CLKSOURCE_PCLK1;
    401              //HAL_RCCEx_PeriphCLKConfig(&RCC_PeriphCLKInitStruct);
    402          
    403              /*##-2- Enable peripherals and GPIO Clocks #################################*/
    404              /* Enable GPIO TX/RX clock */
    405              __HAL_RCC_GPIOB_CLK_ENABLE();
   \   0000000E   0x6820             LDR      R0,[R4, #+0]
    406          
    407            
    408            
    409              /**I2C1 GPIO Configuration    
    410              PB6     ------> I2C1_SCL (PB6)
    411              PB7     ------> I2C1_SDA (PB7) 
    412              */
    413              GPIO_InitStruct.Pin = GPIO_PIN_6|GPIO_PIN_7;
    414              GPIO_InitStruct.Mode = GPIO_MODE_AF_OD;
    415              GPIO_InitStruct.Pull = GPIO_PULLUP;
    416              GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
    417              GPIO_InitStruct.Alternate = GPIO_AF4_I2C1;
    418              HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
   \   00000010   0xA901             ADD      R1,SP,#+4
   \   00000012   0xF040 0x0002      ORR      R0,R0,#0x2
   \   00000016   0x6020             STR      R0,[R4, #+0]
   \   00000018   0x6820             LDR      R0,[R4, #+0]
   \   0000001A   0xF000 0x0002      AND      R0,R0,#0x2
   \   0000001E   0x9000             STR      R0,[SP, #+0]
   \   00000020   0x9800             LDR      R0,[SP, #+0]
   \   00000022   0x20C0             MOVS     R0,#+192
   \   00000024   0x.... 0x....      BL       ?Subroutine2
   \                     ??CrossCallReturnLabel_5: (+1)
   \   00000028   0x....             LDR.N    R0,??DataTable10_7  ;; 0x40020400
   \   0000002A   0x.... 0x....      BL       HAL_GPIO_Init
    419          
    420              /* Peripheral clock enable */
    421              __HAL_RCC_I2C1_CLK_ENABLE();
   \   0000002E   0x6920             LDR      R0,[R4, #+16]
    422          	  /* Peripheral interrupt init*/
    423              HAL_NVIC_SetPriority(I2C1_EV_IRQn, 3, 0);
   \   00000030   0x2200             MOVS     R2,#+0
   \   00000032   0x2103             MOVS     R1,#+3
   \   00000034   0xF440 0x1000      ORR      R0,R0,#0x200000
   \   00000038   0x6120             STR      R0,[R4, #+16]
   \   0000003A   0x6920             LDR      R0,[R4, #+16]
   \   0000003C   0xF400 0x1000      AND      R0,R0,#0x200000
   \   00000040   0x9000             STR      R0,[SP, #+0]
   \   00000042   0x9800             LDR      R0,[SP, #+0]
   \   00000044   0x201F             MOVS     R0,#+31
   \   00000046   0x.... 0x....      BL       HAL_NVIC_SetPriority
    424              HAL_NVIC_EnableIRQ(I2C1_EV_IRQn);
   \   0000004A   0x201F             MOVS     R0,#+31
   \   0000004C   0x.... 0x....      BL       HAL_NVIC_EnableIRQ
   \   00000050   0xE012             B.N      ??HAL_I2C_MspInit_1
    425            /* USER CODE BEGIN I2C1_MspInit 1 */
    426          
    427          
    428            /* USER CODE END I2C1_MspInit 1 */
    429            }
    430            else if(hi2c->Instance==I2C2)
   \                     ??HAL_I2C_MspInit_0: (+1)
   \   00000052   0x....             LDR.N    R1,??DataTable10_14  ;; 0x40005800
   \   00000054   0x4288             CMP      R0,R1
   \   00000056   0xD10F             BNE.N    ??HAL_I2C_MspInit_1
    431            {
    432            /* USER CODE BEGIN I2C2_MspInit 0 */
    433          
    434            /* USER CODE END I2C2_MspInit 0 */
    435            
    436              /**I2C2 GPIO Configuration    
    437              PF0     ------> I2C2_SDA
    438              PF1     ------> I2C2_SCL 
    439              */
    440              GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_1;
   \   00000058   0x2003             MOVS     R0,#+3
    441              GPIO_InitStruct.Mode = GPIO_MODE_AF_OD;
    442              GPIO_InitStruct.Pull = GPIO_PULLUP;
    443              GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
    444              GPIO_InitStruct.Alternate = GPIO_AF4_I2C2;
    445              HAL_GPIO_Init(GPIOF, &GPIO_InitStruct);
   \   0000005A   0xA901             ADD      R1,SP,#+4
   \   0000005C   0x.... 0x....      BL       ?Subroutine2
   \                     ??CrossCallReturnLabel_6: (+1)
   \   00000060   0x....             LDR.N    R0,??DataTable10_15  ;; 0x40021400
   \   00000062   0x.... 0x....      BL       HAL_GPIO_Init
    446          
    447              /* Peripheral clock enable */
    448              __HAL_RCC_I2C2_CLK_ENABLE();
   \   00000066   0x6920             LDR      R0,[R4, #+16]
   \   00000068   0xF440 0x0080      ORR      R0,R0,#0x400000
   \   0000006C   0x6120             STR      R0,[R4, #+16]
   \   0000006E   0x6920             LDR      R0,[R4, #+16]
   \   00000070   0xF400 0x0080      AND      R0,R0,#0x400000
   \   00000074   0x9000             STR      R0,[SP, #+0]
   \   00000076   0x9800             LDR      R0,[SP, #+0]
    449            /* USER CODE BEGIN I2C2_MspInit 1 */
    450          
    451            /* USER CODE END I2C2_MspInit 1 */
    452            }
    453          
    454          }
   \                     ??HAL_I2C_MspInit_1: (+1)
   \   00000078   0xB006             ADD      SP,SP,#+24
   \   0000007A   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine2: (+1)
   \   00000000   0x9001             STR      R0,[SP, #+4]
   \   00000002   0x2012             MOVS     R0,#+18
   \   00000004   0x9002             STR      R0,[SP, #+8]
   \   00000006   0x2001             MOVS     R0,#+1
   \   00000008   0x9003             STR      R0,[SP, #+12]
   \   0000000A   0x2003             MOVS     R0,#+3
   \   0000000C   0x9004             STR      R0,[SP, #+16]
   \   0000000E   0x2004             MOVS     R0,#+4
   \   00000010   0x9005             STR      R0,[SP, #+20]
   \   00000012   0x4770             BX       LR
    455          
    456          /*---------------------------------------------------*/
    457          /*   UART                                            */
    458          /* UART4 init function */

   \                                 In section .text, align 2, keep-with-next
    459          void UART6_Init(void)
    460          {
    461          
    462            huart6.Instance = USART6;
   \                     UART6_Init: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable10_16
   \   00000002   0x....             LDR.N    R1,??DataTable10_17  ;; 0x40011400
   \   00000004   0x6001             STR      R1,[R0, #+0]
    463            huart6.Init.BaudRate = 115200;
   \   00000006   0xF44F 0x31E1      MOV      R1,#+115200
   \   0000000A   0x6041             STR      R1,[R0, #+4]
    464            huart6.Init.WordLength = UART_WORDLENGTH_8B;
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0x6081             STR      R1,[R0, #+8]
    465            huart6.Init.StopBits = UART_STOPBITS_1;
   \   00000010   0x60C1             STR      R1,[R0, #+12]
    466            huart6.Init.Parity = UART_PARITY_NONE;
   \   00000012   0x6101             STR      R1,[R0, #+16]
    467            huart6.Init.Mode = UART_MODE_TX_RX;
   \   00000014   0x210C             MOVS     R1,#+12
   \   00000016   0x6141             STR      R1,[R0, #+20]
    468            huart6.Init.HwFlowCtl = UART_HWCONTROL_NONE;
   \   00000018   0x2100             MOVS     R1,#+0
   \   0000001A   0x6181             STR      R1,[R0, #+24]
    469            huart6.Init.OverSampling = UART_OVERSAMPLING_16;
   \   0000001C   0x61C1             STR      R1,[R0, #+28]
    470            huart6.Init.OneBitSampling = UART_ONEBIT_SAMPLING_DISABLED ;
   \   0000001E   0x6201             STR      R1,[R0, #+32]
    471            huart6.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
   \   00000020   0x6241             STR      R1,[R0, #+36]
    472            HAL_UART_Init(&huart6);
   \   00000022   0x.... 0x....      B.W      HAL_UART_Init
    473          
    474          }
    475          

   \                                 In section .text, align 2, keep-with-next
    476          void HAL_UART_MspInit(UART_HandleTypeDef* huart)
    477          {
    478          
    479            GPIO_InitTypeDef GPIO_InitStruct;
    480            if(huart->Instance==USART6)
   \                     HAL_UART_MspInit: (+1)
   \   00000000   0x6800             LDR      R0,[R0, #+0]
   \   00000002   0x....             LDR.N    R1,??DataTable10_17  ;; 0x40011400
   \   00000004   0x4288             CMP      R0,R1
   \   00000006   0xD000             BEQ.N    ??HAL_UART_MspInit_0
   \   00000008   0x4770             BX       LR
    481            {
    482            /* USER CODE BEGIN UART6_MspInit 0 */
    483          
    484            /* USER CODE END UART4_MspInit 0 */
    485              /* Peripheral clock enable */
    486              __USART6_CLK_ENABLE();
   \                     ??HAL_UART_MspInit_0: (+1)
   \   0000000A   0xB500             PUSH     {LR}
   \   0000000C   0x....             LDR.N    R0,??DataTable10_5  ;; 0x40023830
   \   0000000E   0xB087             SUB      SP,SP,#+28
   \   00000010   0x6941             LDR      R1,[R0, #+20]
   \   00000012   0xF041 0x0120      ORR      R1,R1,#0x20
   \   00000016   0x6141             STR      R1,[R0, #+20]
   \   00000018   0x6941             LDR      R1,[R0, #+20]
   \   0000001A   0xF001 0x0120      AND      R1,R1,#0x20
   \   0000001E   0x9100             STR      R1,[SP, #+0]
   \   00000020   0x9900             LDR      R1,[SP, #+0]
    487              __GPIOC_CLK_ENABLE();
   \   00000022   0x6801             LDR      R1,[R0, #+0]
   \   00000024   0xF041 0x0104      ORR      R1,R1,#0x4
   \   00000028   0x6001             STR      R1,[R0, #+0]
   \   0000002A   0x6800             LDR      R0,[R0, #+0]
    488            
    489              /**UART4 GPIO Configuration    
    490              PC10     ------> UART4_TX (PC6)
    491              PC11     ------> UART4_RX (PC7)
    492              */
    493              GPIO_InitStruct.Pin = GPIO_PIN_6|GPIO_PIN_6;
    494              GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    495              GPIO_InitStruct.Pull = GPIO_PULLUP;
    496              GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
    497              GPIO_InitStruct.Alternate = GPIO_AF8_USART6;
    498              HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
   \   0000002C   0xA901             ADD      R1,SP,#+4
   \   0000002E   0xF000 0x0004      AND      R0,R0,#0x4
   \   00000032   0x9000             STR      R0,[SP, #+0]
   \   00000034   0x9800             LDR      R0,[SP, #+0]
   \   00000036   0x2040             MOVS     R0,#+64
   \   00000038   0x9001             STR      R0,[SP, #+4]
   \   0000003A   0x2002             MOVS     R0,#+2
   \   0000003C   0x9002             STR      R0,[SP, #+8]
   \   0000003E   0x2001             MOVS     R0,#+1
   \   00000040   0x9003             STR      R0,[SP, #+12]
   \   00000042   0x2003             MOVS     R0,#+3
   \   00000044   0x9004             STR      R0,[SP, #+16]
   \   00000046   0x2008             MOVS     R0,#+8
   \   00000048   0x9005             STR      R0,[SP, #+20]
   \   0000004A   0x....             LDR.N    R0,??DataTable10_18  ;; 0x40020800
   \   0000004C   0x.... 0x....      BL       HAL_GPIO_Init
    499          
    500          	  /* NVIC for USART */
    501            HAL_NVIC_SetPriority(USART6_IRQn, 0, 1);
   \   00000050   0x2201             MOVS     R2,#+1
   \   00000052   0x2100             MOVS     R1,#+0
   \   00000054   0x2047             MOVS     R0,#+71
   \   00000056   0x.... 0x....      BL       HAL_NVIC_SetPriority
    502            HAL_NVIC_EnableIRQ(USART6_IRQn);
   \   0000005A   0x2047             MOVS     R0,#+71
   \   0000005C   0x.... 0x....      BL       HAL_NVIC_EnableIRQ
    503          
    504            /* USER CODE BEGIN UART4_MspInit 1 */
    505          
    506            /* USER CODE END UART4_MspInit 1 */
    507            }
    508          
    509          }
   \   00000060   0xB007             ADD      SP,SP,#+28
   \   00000062   0xBD00             POP      {PC}             ;; return
    510          
    511          
    512          

   \                                 In section .text, align 2, keep-with-next
    513          void HAL_SPI_MspInit(SPI_HandleTypeDef* hspi)
    514          {
   \                     HAL_SPI_MspInit: (+1)
   \   00000000   0xB500             PUSH     {LR}
    515          
    516            GPIO_InitTypeDef GPIO_InitStruct;
    517            if(hspi->Instance==SPI4)
   \   00000002   0x....             LDR.N    R2,??DataTable10_19  ;; 0x40013400
   \   00000004   0xB087             SUB      SP,SP,#+28
   \   00000006   0x6801             LDR      R1,[R0, #+0]
   \   00000008   0x....             LDR.N    R0,??DataTable10_5  ;; 0x40023830
   \   0000000A   0x4291             CMP      R1,R2
   \   0000000C   0xD10E             BNE.N    ??HAL_SPI_MspInit_0
    518            {
    519            /* USER CODE BEGIN SPI4_MspInit 0 */
    520          
    521            /* USER CODE END SPI4_MspInit 0 */
    522              /* Peripheral clock enable */
    523              __SPI4_CLK_ENABLE();
   \   0000000E   0x6941             LDR      R1,[R0, #+20]
   \   00000010   0xF441 0x5100      ORR      R1,R1,#0x2000
   \   00000014   0x6141             STR      R1,[R0, #+20]
   \   00000016   0x6940             LDR      R0,[R0, #+20]
    524            
    525            
    526              /**SPI4 GPIO Configuration    
    527              PE2     ------> SPI4_SCK
    528              PE4     ------> SPI4_NSS
    529              PE5     ------> SPI4_MISO
    530              PE6     ------> SPI4_MOSI 
    531              */
    532              GPIO_InitStruct.Pin = GPIO_PIN_2|GPIO_PIN_4|GPIO_PIN_5|GPIO_PIN_6;
    533              GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    534              GPIO_InitStruct.Pull = GPIO_NOPULL;
    535              GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
    536              GPIO_InitStruct.Alternate = GPIO_AF5_SPI4;
    537              HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
   \   00000018   0xA901             ADD      R1,SP,#+4
   \   0000001A   0xF400 0x5000      AND      R0,R0,#0x2000
   \   0000001E   0x9000             STR      R0,[SP, #+0]
   \   00000020   0x9800             LDR      R0,[SP, #+0]
   \   00000022   0x2074             MOVS     R0,#+116
   \   00000024   0x.... 0x....      BL       ?Subroutine1
    538          
    539            /* USER CODE BEGIN SPI4_MspInit 1 */
    540          
    541            /* USER CODE END SPI4_MspInit 1 */
    542            }
   \                     ??CrossCallReturnLabel_3: (+1)
   \   00000028   0x....             LDR.N    R0,??DataTable10_20  ;; 0x40021000
   \   0000002A   0xE03D             B.N      ??HAL_SPI_MspInit_1
    543            else if(hspi->Instance==SPI5)
   \                     ??HAL_SPI_MspInit_0: (+1)
   \   0000002C   0x....             LDR.N    R2,??DataTable10_21  ;; 0x40015000
   \   0000002E   0x4291             CMP      R1,R2
   \   00000030   0xD128             BNE.N    ??HAL_SPI_MspInit_2
    544            {
    545            /* USER CODE BEGIN SPI5_MspInit 0 */
    546          
    547            /* USER CODE END SPI5_MspInit 0 */
    548              /* Peripheral clock enable */
    549              __HAL_RCC_SPI5_CLK_ENABLE();
   \   00000032   0x6941             LDR      R1,[R0, #+20]
   \   00000034   0xF441 0x1180      ORR      R1,R1,#0x100000
   \   00000038   0x6141             STR      R1,[R0, #+20]
   \   0000003A   0x6941             LDR      R1,[R0, #+20]
   \   0000003C   0xF401 0x1180      AND      R1,R1,#0x100000
   \   00000040   0x9100             STR      R1,[SP, #+0]
   \   00000042   0x9900             LDR      R1,[SP, #+0]
    550              __HAL_RCC_GPIOF_CLK_ENABLE();
   \   00000044   0x6801             LDR      R1,[R0, #+0]
   \   00000046   0xF041 0x0120      ORR      R1,R1,#0x20
   \   0000004A   0x6001             STR      R1,[R0, #+0]
   \   0000004C   0x6800             LDR      R0,[R0, #+0]
    551            
    552              /**SPI5 GPIO Configuration    
    553              PF7     ------> SPI5_SCK  --> PF7
    554              PF11     ------> SPI5_MOSI --> PF9
    555                               SPI5_MISO --> PF8
    556                                    NSS   -->  PF6
    557              */
    558              GPIO_InitStruct.Pin = GPIO_PIN_6|GPIO_PIN_7|GPIO_PIN_9|GPIO_PIN_8;
    559              GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    560              GPIO_InitStruct.Pull = GPIO_PULLDOWN;
    561              GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
    562              GPIO_InitStruct.Alternate = GPIO_AF5_SPI5;
    563              HAL_GPIO_Init(GPIOF, &GPIO_InitStruct);
   \   0000004E   0xA901             ADD      R1,SP,#+4
   \   00000050   0xF000 0x0020      AND      R0,R0,#0x20
   \   00000054   0x9000             STR      R0,[SP, #+0]
   \   00000056   0x9800             LDR      R0,[SP, #+0]
   \   00000058   0xF44F 0x7070      MOV      R0,#+960
   \   0000005C   0x9001             STR      R0,[SP, #+4]
   \   0000005E   0x2002             MOVS     R0,#+2
   \   00000060   0x9002             STR      R0,[SP, #+8]
   \   00000062   0x9003             STR      R0,[SP, #+12]
   \   00000064   0x2003             MOVS     R0,#+3
   \   00000066   0x9004             STR      R0,[SP, #+16]
   \   00000068   0x2005             MOVS     R0,#+5
   \   0000006A   0x9005             STR      R0,[SP, #+20]
   \   0000006C   0x....             LDR.N    R0,??DataTable10_15  ;; 0x40021400
   \   0000006E   0x.... 0x....      BL       HAL_GPIO_Init
    564          
    565            /* Peripheral interrupt init*/
    566              HAL_NVIC_SetPriority(SPI5_IRQn, 2, 2);
   \   00000072   0x2202             MOVS     R2,#+2
   \   00000074   0x2102             MOVS     R1,#+2
   \   00000076   0x2055             MOVS     R0,#+85
   \   00000078   0x.... 0x....      BL       HAL_NVIC_SetPriority
    567              HAL_NVIC_EnableIRQ(SPI5_IRQn);
   \   0000007C   0x2055             MOVS     R0,#+85
   \   0000007E   0x.... 0x....      BL       HAL_NVIC_EnableIRQ
   \   00000082   0xE013             B.N      ??HAL_SPI_MspInit_3
    568            /* USER CODE BEGIN SPI5_MspInit 1 */
    569          
    570            /* USER CODE END SPI5_MspInit 1 */
    571            }
    572            else if(hspi->Instance==SPI6)
   \                     ??HAL_SPI_MspInit_2: (+1)
   \   00000084   0x....             LDR.N    R2,??DataTable10_22  ;; 0x40015400
   \   00000086   0x4291             CMP      R1,R2
   \   00000088   0xD110             BNE.N    ??HAL_SPI_MspInit_3
    573            {
    574            /* USER CODE BEGIN SPI6_MspInit 0 */
    575          
    576            /* USER CODE END SPI6_MspInit 0 */
    577              /* Peripheral clock enable */
    578              __SPI6_CLK_ENABLE();
   \   0000008A   0x6941             LDR      R1,[R0, #+20]
   \   0000008C   0xF441 0x1100      ORR      R1,R1,#0x200000
   \   00000090   0x6141             STR      R1,[R0, #+20]
   \   00000092   0x6940             LDR      R0,[R0, #+20]
    579            
    580              /**SPI6 GPIO Configuration    
    581              PG13     ------> SPI6_SCK
    582              PG14     ------> SPI6_MOSI 
    583              */
    584              GPIO_InitStruct.Pin = GPIO_PIN_13|GPIO_PIN_14;
    585              GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    586              GPIO_InitStruct.Pull = GPIO_NOPULL;
    587              GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
    588              GPIO_InitStruct.Alternate = GPIO_AF5_SPI6;
    589              HAL_GPIO_Init(GPIOG, &GPIO_InitStruct);
   \   00000094   0xA901             ADD      R1,SP,#+4
   \   00000096   0xF400 0x1000      AND      R0,R0,#0x200000
   \   0000009A   0x9000             STR      R0,[SP, #+0]
   \   0000009C   0x9800             LDR      R0,[SP, #+0]
   \   0000009E   0xF44F 0x40C0      MOV      R0,#+24576
   \   000000A2   0x.... 0x....      BL       ?Subroutine1
    590          
    591            /* USER CODE BEGIN SPI6_MspInit 1 */
    592          
    593            /* USER CODE END SPI6_MspInit 1 */
    594            }
   \                     ??CrossCallReturnLabel_4: (+1)
   \   000000A6   0x....             LDR.N    R0,??DataTable10_23  ;; 0x40021800
   \                     ??HAL_SPI_MspInit_1: (+1)
   \   000000A8   0x.... 0x....      BL       HAL_GPIO_Init
    595          
    596          }
   \                     ??HAL_SPI_MspInit_3: (+1)
   \   000000AC   0xB007             ADD      SP,SP,#+28
   \   000000AE   0xBD00             POP      {PC}             ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \   00000000   0x9001             STR      R0,[SP, #+4]
   \   00000002   0x2002             MOVS     R0,#+2
   \   00000004   0x9002             STR      R0,[SP, #+8]
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x9003             STR      R0,[SP, #+12]
   \   0000000A   0x2003             MOVS     R0,#+3
   \   0000000C   0x9004             STR      R0,[SP, #+16]
   \   0000000E   0x2005             MOVS     R0,#+5
   \   00000010   0x9005             STR      R0,[SP, #+20]
   \   00000012   0x4770             BX       LR
    597          
    598          
    599          /* SPI5 init function */

   \                                 In section .text, align 2, keep-with-next
    600          void MX_SPI5_Init(void)
    601          {
   \                     MX_SPI5_Init: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    602          
    603            hspi5.Instance = SPI5;
   \   00000002   0x....             LDR.N    R4,??DataTable10_24
   \   00000004   0x....             LDR.N    R0,??DataTable10_21  ;; 0x40015000
   \   00000006   0x6020             STR      R0,[R4, #+0]
    604            hspi5.Init.Mode = SPI_MODE_SLAVE;
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x6060             STR      R0,[R4, #+4]
    605            hspi5.Init.Direction = SPI_DIRECTION_2LINES_RXONLY;//SPI_DIRECTION_2LINES_RXONLY
   \   0000000C   0xF44F 0x6080      MOV      R0,#+1024
   \   00000010   0x60A0             STR      R0,[R4, #+8]
    606            hspi5.Init.DataSize = SPI_DATASIZE_16BIT;
   \   00000012   0xF44F 0x6070      MOV      R0,#+3840
   \   00000016   0x60E0             STR      R0,[R4, #+12]
    607            hspi5.Init.CLKPolarity = SPI_POLARITY_LOW;
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x6120             STR      R0,[R4, #+16]
    608            hspi5.Init.CLKPhase = SPI_PHASE_1EDGE;
   \   0000001C   0x6160             STR      R0,[R4, #+20]
    609            hspi5.Init.NSS = SPI_NSS_SOFT;//SPI_NSS_HARD_INPUT
   \   0000001E   0xF44F 0x7000      MOV      R0,#+512
   \   00000022   0x61A0             STR      R0,[R4, #+24]
    610            hspi5.Init.FirstBit = SPI_FIRSTBIT_MSB;
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0x6220             STR      R0,[R4, #+32]
    611            hspi5.Init.TIMode = SPI_TIMODE_DISABLE;
   \   00000028   0x6260             STR      R0,[R4, #+36]
    612            hspi5.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLED;
   \   0000002A   0x62A0             STR      R0,[R4, #+40]
    613            hspi5.Init.CRCPolynomial = 7;
   \   0000002C   0x2007             MOVS     R0,#+7
   \   0000002E   0x62E0             STR      R0,[R4, #+44]
    614            hspi5.Init.CRCLength = SPI_CRC_LENGTH_DATASIZE;
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0x6320             STR      R0,[R4, #+48]
    615            hspi5.Init.NSSPMode = SPI_NSS_PULSE_DISABLE;
   \   00000034   0x6360             STR      R0,[R4, #+52]
    616            //hspi5.RxISR = SPI5_CallBack;
    617            HAL_SPI_Init(&hspi5);
   \   00000036   0x4620             MOV      R0,R4
   \   00000038   0x.... 0x....      BL       HAL_SPI_Init
    618          
    619          
    620            //HAL_GPIO_WritePin(GPIOF,GPIO_PIN_6,GPIO_PIN_SET);
    621            /* Enable TXE, RXNE and ERR interrupt */
    622           __HAL_SPI_ENABLE_IT(&hspi5, (SPI_IT_RXNE| SPI_IT_ERR));
   \   0000003C   0x6820             LDR      R0,[R4, #+0]
   \   0000003E   0x6841             LDR      R1,[R0, #+4]
   \   00000040   0xF041 0x0160      ORR      R1,R1,#0x60
   \   00000044   0x6041             STR      R1,[R0, #+4]
    623          
    624           __HAL_SPI_ENABLE(&hspi5);
   \   00000046   0x6801             LDR      R1,[R0, #+0]
   \   00000048   0xF041 0x0140      ORR      R1,R1,#0x40
   \   0000004C   0x6001             STR      R1,[R0, #+0]
    625          
    626          }
   \   0000004E   0xBD10             POP      {R4,PC}          ;; return
    627          
    628          
    629          

   \                                 In section .text, align 2, keep-with-next
    630          void SPI5_IRQHandler(void)
    631          {
    632            static uint16_t stNipple;
    633            static uint8_t stLR, stOder;
    634            
    635            /* USER CODE BEGIN SPI5_IRQn 0 */
    636          
    637            /* USER CODE END SPI5_IRQn 0 */
    638            //HAL_SPI_IRQHandler(&hspi5);
    639            /* USER CODE BEGIN SPI5_IRQn 1 */
    640          
    641            /* USER CODE END SPI5_IRQn 1 */
    642              /* Check if data are available in SPI Data register */
    643            /* SPI in mode Receiver ----------------------------------------------------*/
    644            if(
    645               (__HAL_SPI_GET_FLAG(&hspi5, SPI_FLAG_OVR) == RESET)&&
    646               (__HAL_SPI_GET_FLAG(&hspi5, SPI_FLAG_RXNE) != RESET)&&
    647               (__HAL_SPI_GET_IT_SOURCE(&hspi5, SPI_IT_RXNE) != RESET))
   \                     SPI5_IRQHandler: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable10_24
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x6881             LDR      R1,[R0, #+8]
   \   00000006   0x0649             LSLS     R1,R1,#+25
   \   00000008   0xD500             BPL.N    ??SPI5_IRQHandler_0
   \   0000000A   0x4770             BX       LR
   \                     ??SPI5_IRQHandler_0: (+1)
   \   0000000C   0xB570             PUSH     {R4-R6,LR}
   \   0000000E   0x6881             LDR      R1,[R0, #+8]
   \   00000010   0x07C9             LSLS     R1,R1,#+31
   \   00000012   0xD55F             BPL.N    ??SPI5_IRQHandler_1
   \   00000014   0x6840             LDR      R0,[R0, #+4]
   \   00000016   0x0640             LSLS     R0,R0,#+25
   \   00000018   0xD55C             BPL.N    ??SPI5_IRQHandler_1
    648            {
    649          
    650          
    651             uint16_t test;
    652             test =  SPI_I2S_ReceiveData(SPI5);
    653             //SPI_I2S_SendData(SPI5,0);
    654             //BSP_LED_Toggle(LED1);
    655             //if (HAL_GPIO_ReadPin(GPIOB,GPIO_PIN_4)==GPIO_PIN_SET)
    656             {
    657          
    658                stOder^=0x01;
   \   0000001A   0x....             LDR.N    R1,??DataTable10_25
   \   0000001C   0x....             LDR.N    R0,??DataTable10_26  ;; 0x4001500c
   \   0000001E   0x6802             LDR      R2,[R0, #+0]
   \   00000020   0xF501 0x4010      ADD      R0,R1,#+36864
   \   00000024   0x3018             ADDS     R0,R0,#+24
   \   00000026   0xB292             UXTH     R2,R2
   \   00000028   0x7A83             LDRB     R3,[R0, #+10]
   \   0000002A   0xF093 0x0301      EORS     R3,R3,#0x1
   \   0000002E   0x7283             STRB     R3,[R0, #+10]
    659                if(stOder==0x00)
   \   00000030   0xD141             BNE.N    ??SPI5_IRQHandler_2
    660                {
    661          
    662                    //BSP_LED_On(LED1);  
    663          
    664          		  stLR^=0x01;
   \   00000032   0x7A43             LDRB     R3,[R0, #+9]
    665          		  if (stLR==0x01)
   \   00000034   0xF641 0x74FE      MOVW     R4,#+8190
   \   00000038   0xF083 0x0301      EOR      R3,R3,#0x1
   \   0000003C   0x2B01             CMP      R3,#+1
   \   0000003E   0x7243             STRB     R3,[R0, #+9]
   \   00000040   0xD11B             BNE.N    ??SPI5_IRQHandler_3
    666          		  {
    667          		    if (Buffer1.offset + idxSPI5DataBuf1 < AUDIO_OUT_BUFFER_SIZE-2) 
   \   00000042   0xF644 0x0308      MOVW     R3,#+18440
   \   00000046   0x585D             LDR      R5,[R3, R1]
   \   00000048   0x8986             LDRH     R6,[R0, #+12]
   \   0000004A   0xFA15 0xF686      UXTAH    R6,R5,R6
   \   0000004E   0x42A6             CMP      R6,R4
   \   00000050   0xD23C             BCS.N    ??SPI5_IRQHandler_4
    668          		    {
    669          	               Buffer1.pcm_buff[Buffer1.offset + idxSPI5DataBuf1++] =((test>>4)|(stNipple<<12));
   \   00000052   0x8984             LDRH     R4,[R0, #+12]
   \   00000054   0x1C66             ADDS     R6,R4,#+1
   \   00000056   0xFA15 0xF484      UXTAH    R4,R5,R4
   \   0000005A   0x8186             STRH     R6,[R0, #+12]
   \   0000005C   0x8A06             LDRH     R6,[R0, #+16]
   \   0000005E   0x0336             LSLS     R6,R6,#+12
   \   00000060   0xEA46 0x1222      ORR      R2,R6,R2, ASR #+4
   \   00000064   0xF821 0x2014      STRH     R2,[R1, R4, LSL #+1]
    670          				   Buffer1.pcm_buff[Buffer1.offset + idxSPI5DataBuf1++] =((test>>4)|(stNipple<<12));
   \   00000068   0x8984             LDRH     R4,[R0, #+12]
   \   0000006A   0x1C65             ADDS     R5,R4,#+1
   \   0000006C   0x8185             STRH     R5,[R0, #+12]
   \   0000006E   0x585B             LDR      R3,[R3, R1]
   \   00000070   0xFA13 0xF384      UXTAH    R3,R3,R4
   \   00000074   0xF821 0x2013      STRH     R2,[R1, R3, LSL #+1]
   \   00000078   0xE028             B.N      ??SPI5_IRQHandler_4
    671          		    }
    672          		  }
    673          		  else
    674          		  {
    675          		     if (Buffer2.offset + idxSPI5DataBuf2 < AUDIO_OUT_BUFFER_SIZE-2)
   \                     ??SPI5_IRQHandler_3: (+1)
   \   0000007A   0x6803             LDR      R3,[R0, #+0]
   \   0000007C   0x89C5             LDRH     R5,[R0, #+14]
   \   0000007E   0xFA13 0xF585      UXTAH    R5,R3,R5
   \   00000082   0x42A5             CMP      R5,R4
   \   00000084   0xD222             BCS.N    ??SPI5_IRQHandler_4
    676          		     {
    677          	               Buffer2.pcm_buff[Buffer2.offset + idxSPI5DataBuf2++] = ((test>>4)|(stNipple<<12));
   \   00000086   0x89C4             LDRH     R4,[R0, #+14]
   \   00000088   0x1C65             ADDS     R5,R4,#+1
   \   0000008A   0x81C5             STRH     R5,[R0, #+14]
   \   0000008C   0x8A05             LDRH     R5,[R0, #+16]
   \   0000008E   0xFA13 0xF384      UXTAH    R3,R3,R4
   \   00000092   0xEB01 0x0343      ADD      R3,R1,R3, LSL #+1
   \   00000096   0x032D             LSLS     R5,R5,#+12
   \   00000098   0xEA45 0x1222      ORR      R2,R5,R2, ASR #+4
   \   0000009C   0xF644 0x0510      MOVW     R5,#+18448
   \   000000A0   0x52EA             STRH     R2,[R5, R3]
    678          				   Buffer2.pcm_buff[Buffer2.offset + idxSPI5DataBuf2++] = ((test>>4)|(stNipple<<12));
   \   000000A2   0x89C3             LDRH     R3,[R0, #+14]
   \   000000A4   0x1C5C             ADDS     R4,R3,#+1
   \   000000A6   0x81C4             STRH     R4,[R0, #+14]
   \   000000A8   0x6804             LDR      R4,[R0, #+0]
   \   000000AA   0xFA14 0xF383      UXTAH    R3,R4,R3
   \   000000AE   0xEB01 0x0143      ADD      R1,R1,R3, LSL #+1
   \   000000B2   0x526A             STRH     R2,[R5, R1]
   \   000000B4   0xE00A             B.N      ??SPI5_IRQHandler_4
    679          		     }
    680          
    681          		  }
    682          			  
    683                }
    684          	  else
    685          	  {
    686          	      //Buffer1.pcm_buff[idxSPI5DataBuf++] = 0;
    687          	      //BSP_LED_Off(LED1);  
    688                     stNipple = (test);
   \                     ??SPI5_IRQHandler_2: (+1)
   \   000000B6   0x8202             STRH     R2,[R0, #+16]
    689          		  Buffer3.pcm_buff[Buffer2.offset + idxSPI5DataBuf2] = stNipple;
   \   000000B8   0x6802             LDR      R2,[R0, #+0]
   \   000000BA   0x89C3             LDRH     R3,[R0, #+14]
   \   000000BC   0xFA12 0xF283      UXTAH    R2,R2,R3
   \   000000C0   0x8A03             LDRH     R3,[R0, #+16]
   \   000000C2   0xEB01 0x0142      ADD      R1,R1,R2, LSL #+1
   \   000000C6   0xF249 0x022C      MOVW     R2,#+36908
   \   000000CA   0x5253             STRH     R3,[R2, R1]
    690          	  }
    691          
    692          
    693          	  
    694             	}
    695              //else
    696              {
    697               // BSP_LED_Off(LED1);
    698              }
    699          
    700          
    701            // if (idxSPI5DataBuf >= AUDIO_IN_PCM_BUFFER_SIZE) idxSPI5DataBuf=0;
    702             //SPI5->DR = 3333;
    703              if(flgSTAIni==0)
   \                     ??SPI5_IRQHandler_4: (+1)
   \   000000CC   0x7A01             LDRB     R1,[R0, #+8]
   \   000000CE   0xB909             CBNZ.N   R1,??SPI5_IRQHandler_1
    704              {
    705                  flgSTAIni=1;
   \   000000D0   0x2101             MOVS     R1,#+1
   \   000000D2   0x7201             STRB     R1,[R0, #+8]
    706          		//__HAL_SPI_DISABLE(&hspi5);
    707                  						 
    708              }
    709                
    710            }
    711            
    712            
    713            
    714          
    715          }
   \                     ??SPI5_IRQHandler_1: (+1)
   \   000000D4   0xBD70             POP      {R4-R6,PC}       ;; return

   \                                 In section .bss, align 4
   \                     Buffer1:
   \   00000000                      DS8 18448
   \                     Buffer2:
   \   00004810                      DS8 18448
   \                     flgSTAIni:
   \   00009020                      DS8 1
   \   00009021                      DS8 1
   \   00009022                      DS8 1
   \   00009023                      DS8 1
   \                     idxSPI5DataBuf1:
   \   00009024                      DS8 2
   \                     idxSPI5DataBuf2:
   \   00009026                      DS8 2
   \   00009028                      DS8 2
   \   0000902A                      DS8 2
   \                     Buffer3:
   \   0000902C                      DS8 18448

   \                                 In section .bss, align 4
   \                     pI2CRx:
   \   00000000                      DS8 12

   \                                 In section .bss, align 2
   \                     cntRisingEXTI:
   \   00000000                      DS8 2

   \                                 In section .bss, align 4
   \                     aRxBuffer:
   \   00000000                      DS8 1024

   \                                 In section .bss, align 4
   \                     ??ticks:
   \   00000000                      DS8 4
    716          
    717          static uint16_t SPI_I2S_ReceiveData(SPI_TypeDef* SPIx)
    718          {
    719            /* Check the parameters */
    720            assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
    721            
    722            /* Return the data in the DR register */
    723            return SPIx->DR;
    724          }
    725          
    726          static void SPI_I2S_SendData(SPI_TypeDef* SPIx, uint16_t Data)
                             ^
Warning[Pe177]: function "SPI_I2S_SendData" was declared but never referenced
    727          {
    728            /* set the data to the DR register */
    729            SPIx->DR=Data;
    730          }
    731          	
    732          

   \                                 In section .text, align 2, keep-with-next
    733          void EXTI4_IRQHandler(void)
    734          {
   \                     EXTI4_IRQHandler: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    735              /* EXTI line interrupt detected */
    736            if(__HAL_GPIO_EXTI_GET_IT(GPIO_PIN_4) != RESET)
   \   00000002   0x....             LDR.N    R4,??DataTable10_27  ;; 0x40013c14
   \   00000004   0x6820             LDR      R0,[R4, #+0]
   \   00000006   0x06C0             LSLS     R0,R0,#+27
   \   00000008   0xD510             BPL.N    ??EXTI4_IRQHandler_0
    737            {
    738              
    739               if (cntRisingEXTI==10)
   \   0000000A   0x....             LDR.N    R5,??DataTable10_28
   \   0000000C   0x8828             LDRH     R0,[R5, #+0]
   \   0000000E   0x280A             CMP      R0,#+10
   \   00000010   0xD107             BNE.N    ??EXTI4_IRQHandler_1
    740               {
    741              	/*--------------Enable read PCM data --------------------*/
    742                  MX_SPI5_Init(); 
   \   00000012   0x.... 0x....      BL       MX_SPI5_Init
    743                  //__HAL_SPI_ENABLE_IT(&hspi5, (SPI_IT_RXNE| SPI_IT_ERR));
    744          		//__HAL_UNLOCK(&hspi5);
    745                  //__HAL_SPI_ENABLE(&hspi5);
    746          		cntRisingEXTI=0;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0x8028             STRH     R0,[R5, #+0]
    747          
    748          		/*Disable external interrupt */
    749          		HAL_NVIC_DisableIRQ((IRQn_Type)(EXTI4_IRQn));
   \   0000001A   0x200A             MOVS     R0,#+10
   \   0000001C   0x.... 0x....      BL       HAL_NVIC_DisableIRQ
   \   00000020   0xE002             B.N      ??EXTI4_IRQHandler_2
    750          		//HAL_GPIO_DeInit(GPIOB,GPIO_PIN_4);
    751               }
    752               else
    753               {
    754                   cntRisingEXTI++;
   \                     ??EXTI4_IRQHandler_1: (+1)
   \   00000022   0x8828             LDRH     R0,[R5, #+0]
   \   00000024   0x1C40             ADDS     R0,R0,#+1
   \   00000026   0x8028             STRH     R0,[R5, #+0]
    755          		 //__HAL_SPI_DISABLE(&hspi5);
    756               }
    757          	 __HAL_GPIO_EXTI_CLEAR_IT(GPIO_PIN_4);
   \                     ??EXTI4_IRQHandler_2: (+1)
   \   00000028   0x2010             MOVS     R0,#+16
   \   0000002A   0x6020             STR      R0,[R4, #+0]
    758          
    759            }
    760          }
   \                     ??EXTI4_IRQHandler_0: (+1)
   \   0000002C   0xBD31             POP      {R0,R4,R5,PC}    ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \   00000000   0xF3BF 0x8F4F      DSB      
   \   00000004   0xF3BF 0x8F6F      ISB      
   \   00000008   0x4770             BX       LR

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10:
   \   00000000   0xE000EF50         DC32     0xe000ef50

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_1:
   \   00000000   0xE000ED14         DC32     0xe000ed14

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_2:
   \   00000000   0x........         DC32     flg10ms

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_3:
   \   00000000   0x000F1B30         DC32     0xf1b30

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_4:
   \   00000000   0x........         DC32     AUDIO_SAMPLE+0x74

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_5:
   \   00000000   0x40023830         DC32     0x40023830

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_6:
   \   00000000   0x10110000         DC32     0x10110000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_7:
   \   00000000   0x40020400         DC32     0x40020400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_8:
   \   00000000   0x........         DC32     ??ticks

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_9:
   \   00000000   0x40023840         DC32     0x40023840

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_10:
   \   00000000   0x40007000         DC32     0x40007000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_11:
   \   00000000   0x........         DC32     hi2c1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_12:
   \   00000000   0x40005400         DC32     0x40005400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_13:
   \   00000000   0x40912732         DC32     0x40912732

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_14:
   \   00000000   0x40005800         DC32     0x40005800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_15:
   \   00000000   0x40021400         DC32     0x40021400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_16:
   \   00000000   0x........         DC32     huart6

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_17:
   \   00000000   0x40011400         DC32     0x40011400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_18:
   \   00000000   0x40020800         DC32     0x40020800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_19:
   \   00000000   0x40013400         DC32     0x40013400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_20:
   \   00000000   0x40021000         DC32     0x40021000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_21:
   \   00000000   0x40015000         DC32     0x40015000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_22:
   \   00000000   0x40015400         DC32     0x40015400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_23:
   \   00000000   0x40021800         DC32     0x40021800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_24:
   \   00000000   0x........         DC32     hspi5

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_25:
   \   00000000   0x........         DC32     Buffer1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_26:
   \   00000000   0x4001500C         DC32     0x4001500c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_27:
   \   00000000   0x40013C14         DC32     0x40013c14

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_28:
   \   00000000   0x........         DC32     cntRisingEXTI
    761          
    762          
    763          
    764          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   EXTI4_IRQHandler
        16   -> HAL_NVIC_DisableIRQ
        16   -> MX_SPI5_Init
      32   HAL_I2C_MspInit
        32   -> HAL_GPIO_Init
        32   -> HAL_NVIC_EnableIRQ
        32   -> HAL_NVIC_SetPriority
      32   HAL_SPI_MspInit
        32   -> HAL_GPIO_Init
        32   -> HAL_NVIC_EnableIRQ
        32   -> HAL_NVIC_SetPriority
      32   HAL_UART_MspInit
        32   -> HAL_GPIO_Init
        32   -> HAL_NVIC_EnableIRQ
        32   -> HAL_NVIC_SetPriority
       8   MX_I2C1_Init
         0   -> HAL_I2CEx_ConfigAnalogFilter
         8   -> HAL_I2C_Init
       8   MX_SPI5_Init
         8   -> HAL_SPI_Init
      16   SPI5_IRQHandler
     208   SystemClock_Config
       208   -> HAL_PWREx_EnableOverDrive
       208   -> HAL_RCCEx_PeriphCLKConfig
       208   -> HAL_RCC_ClockConfig
       208   -> HAL_RCC_GetHCLKFreq
       208   -> HAL_RCC_OscConfig
       208   -> HAL_SYSTICK_CLKSourceConfig
       208   -> HAL_SYSTICK_Config
       0   Toggle_Leds
       0   UART6_Init
         0   -> HAL_UART_Init
      24   main
        24   -> AudioFlashPlay
        24   -> BSP_LED_Init
        24   -> BSP_LED_Toggle
        24   -> HAL_GPIO_Init
        24   -> HAL_Init
        24   -> HAL_NVIC_EnableIRQ
        24   -> HAL_NVIC_SetPriority
        24   -> SystemClock_Config
        24   -> WavePlayerInit


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable10
       4  ??DataTable10_1
       4  ??DataTable10_10
       4  ??DataTable10_11
       4  ??DataTable10_12
       4  ??DataTable10_13
       4  ??DataTable10_14
       4  ??DataTable10_15
       4  ??DataTable10_16
       4  ??DataTable10_17
       4  ??DataTable10_18
       4  ??DataTable10_19
       4  ??DataTable10_2
       4  ??DataTable10_20
       4  ??DataTable10_21
       4  ??DataTable10_22
       4  ??DataTable10_23
       4  ??DataTable10_24
       4  ??DataTable10_25
       4  ??DataTable10_26
       4  ??DataTable10_27
       4  ??DataTable10_28
       4  ??DataTable10_3
       4  ??DataTable10_4
       4  ??DataTable10_5
       4  ??DataTable10_6
       4  ??DataTable10_7
       4  ??DataTable10_8
       4  ??DataTable10_9
      10  ?Subroutine0
      20  ?Subroutine1
      20  ?Subroutine2
   55356  Buffer1
          Buffer2
          flgSTAIni
          stLR
          stOder
          idxSPI5DataBuf1
          idxSPI5DataBuf2
          stNipple
          Buffer3
      46  EXTI4_IRQHandler
     124  HAL_I2C_MspInit
     176  HAL_SPI_MspInit
     100  HAL_UART_MspInit
      56  MX_I2C1_Init
      80  MX_SPI5_Init
     214  SPI5_IRQHandler
     188  SystemClock_Config
      18  Toggle_Leds
      38  UART6_Init
    1024  aRxBuffer
       1  appli_state
       2  cntRisingEXTI
      24  flg10ms
          GPIO_INS
     696  hUSBHost
     100  hspi5
     112  huart6
     236  main
      20  pI2CData
      12  pI2CRx
       4  ticks

 
 57 331 bytes in section .bss
     20 bytes in section .data
  1 442 bytes in section .text
 
  1 442 bytes of CODE memory
 57 351 bytes of DATA memory

Errors: none
Warnings: 4
