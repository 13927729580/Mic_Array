###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.2.10312/W32 for ARM       22/Dec/2015  15:52:40
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\sop1hc\Github\data\Mic_Array_V00\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\Src\main.c
#    Command line =  
#        D:\sop1hc\Github\data\Mic_Array_V00\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\Src\main.c
#        -D USE_HAL_DRIVER -D STM32F746xx -D USE_STM32746G_DISCO -D
#        USE_IOEXPANDER -D USE_USB_FS -lC
#        D:\sop1hc\Github\data\Mic_Array_V00\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
#        -lA
#        D:\sop1hc\Github\data\Mic_Array_V00\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
#        -o
#        D:\sop1hc\Github\data\Mic_Array_V00\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj
#        --debug --endian=little --cpu=Cortex-M7 -e --fpu=VFPv5_sp
#        --dlib_config "D:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Full.h" -I
#        D:\sop1hc\Github\data\Mic_Array_V00\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\CMSIS\Device\ST\STM32F7xx\Include\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\STM32F7xx_HAL_Driver\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\STM32746G-Discovery\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\Components\Common\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Log\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Fonts\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\CPU\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_Device_Library\Core\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Core\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Class\MSC\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\drivers\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_Audio\Addons\PDM\
#        -Ohz --use_c++_inline --require_prototypes -I "D:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.3\arm\CMSIS\Include\" -D
#        ARM_MATH_CM7
#    List file    =  
#        D:\sop1hc\Github\data\Mic_Array_V00\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List\main.lst
#    Object file  =  
#        D:\sop1hc\Github\data\Mic_Array_V00\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj\main.o
#
###############################################################################

D:\sop1hc\Github\data\Mic_Array_V00\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\Src\main.c
      1          /**
      2            ******************************************************************************
      3            * @file    Audio/Mic_Array/Src/main.c
      4            * @author  Phan Le Son
      5            * @version V1.0.0
      6            * @date    12-Dec-2015 
      7            * @brief   Microphone Array
      8            ******************************************************************************
      9          
     10            */
     11          
     12          /* Includes ------------------------------------------------------------------*/
     13          
     14          #include "pdm_filter.h"
     15          #include "main.h"
     16          #include <stdio.h>
     17          
     18          
     19          /* Private typedef -----------------------------------------------------------*/
     20          /* Private define ------------------------------------------------------------*/
     21          /* Private macro -------------------------------------------------------------*/
     22          
     23          
     24          /* I2C TIMING Register define when I2C clock source is APB1 (SYSCLK/4) */
     25          /* I2C TIMING is calculated in case of the I2C Clock source is the APB1CLK = 50 MHz */
     26          /* This example use TIMING to 0x40912732 to reach 100 kHz speed (Rise time = 700 ns, Fall time = 100 ns) */
     27          
     28          
     29          
     30          #define DEBUG           0
     31          
     32          
     33          /* Private variables ---------------------------------------------------------*/

   \                                 In section .bss, align 4
     34          USBH_HandleTypeDef hUSBHost;
   \                     hUSBHost:
   \   00000000                      DS8 696

   \                                 In section .bss, align 1
     35          AUDIO_ApplicationTypeDef appli_state = APPLICATION_IDLE;//APPLICATION_IDLE
   \                     appli_state:
   \   00000000                      DS8 1
     36          
     37          extern I2C_HandleTypeDef hi2c1;

   \                                 In section .bss, align 4
     38          UART_HandleTypeDef huart6;
   \                     huart6:
   \   00000000                      DS8 112

   \                                 In section .bss, align 4
     39          SPI_HandleTypeDef hspi5;
   \                     hspi5:
   \   00000000                      DS8 100
     40          GPIO_InitTypeDef GPIO_INS;
     41          
     42          AUDIO_IN_BufferTypeDef Buffer1, Buffer2;
     43          AUDIO_IN_BufferTypeDef Buffer3;
     44          
     45          

   \                                 In section .data, align 4
     46          uint8_t  pI2CData[20]= {0,10,20,30,40,50,60,70,80,90,100,110,120,130,140,150,160,170,180,190};
   \                     pI2CData:
   \   00000000   0x00 0x0A          DC8 0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120, 130, 140, 150
   \              0x14 0x1E    
   \              0x28 0x32    
   \              0x3C 0x46    
   \              0x50 0x5A    
   \              0x64 0x6E    
   \              0x78 0x82    
   \              0x8C 0x96    
   \   00000010   0xA0 0xAA          DC8 160, 170, 180, 190
   \              0xB4 0xBE    

   \                                 In section .bss, align 4
     47          uint8_t  pI2CRx[10];
     48          //extern const uint16_t AUDIO_SAMPLE[];
     49          extern uint8_t  pcSTAComnd[19];
     50          
     51          uint16_t __IO idxSPI5DataBuf1, idxSPI5DataBuf2;
     52          uint16_t __IO cntRisingEXTI;
     53          
     54          /* Buffer used for reception */
     55          uint8_t aRxBuffer[1024];
     56          
     57          
     58          #if (DEBUG)
     59          uint8_t  pUARTBuf[128];
     60          #endif
     61          
     62          /* Private function prototypes -----------------------------------------------*/
     63          static void SystemClock_Config(void);
     64          
     65          static void CPU_CACHE_Enable(void);
     66          
     67          static uint16_t SPI_I2S_ReceiveData(SPI_TypeDef* SPIx);
     68          
     69          void UART6_Init(void);
     70          void MX_SPI5_Init(void);
     71          void ReadSTASeq(uint8_t Addr, uint8_t *pBufOut,uint8_t Len );
     72          void WriteSTAByte(uint8_t Addr, uint8_t *pBufIn, uint8_t len);
     73          void SPI5_CallBack(SPI_HandleTypeDef *hspi);
     74          
     75          
     76          char __IO flg10ms;
   \                     flg10ms:
   \   00000000                      DS8 1
   \   00000001                      DS8 3
   \                     GPIO_INS:
   \   00000004                      DS8 20
     77          uint8_t flgSTAIni;
     78          
     79          
     80          /* Private functions ---------------------------------------------------------*/
     81          
     82          /**
     83            * @brief  Main program
     84            * @param  None
     85            * @retval None
     86            */

   \                                 In section .text, align 2, keep-with-next
     87          int main(void)
     88          {
   \                     main: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
     89          
     90             uint8_t j;
     91             j=0;
   \   00000004   0x2400             MOVS     R4,#+0
     92            /* Enable the CPU Cache */
     93            CPU_CACHE_Enable();
   \   00000006   0x.... 0x....      BL       ?Subroutine0
   \                     ??CrossCallReturnLabel_0: (+1)
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable10  ;; 0xe000ef50
   \   0000000E   0x.... 0x....      LDR.W    R1,??DataTable10_1  ;; 0xe000ed14
   \   00000012   0x6004             STR      R4,[R0, #+0]
   \   00000014   0x680A             LDR      R2,[R1, #+0]
   \   00000016   0xF442 0x3200      ORR      R2,R2,#0x20000
   \   0000001A   0x600A             STR      R2,[R1, #+0]
   \   0000001C   0x.... 0x....      BL       ?Subroutine0
   \                     ??CrossCallReturnLabel_1: (+1)
   \   00000020   0x670C             STR      R4,[R1, #+112]
   \   00000022   0xF3BF 0x8F4F      DSB      
   \   00000026   0x6ECA             LDR      R2,[R1, #+108]
   \   00000028   0xF3C2 0x334E      UBFX     R3,R2,#+13,#+15
   \                     ??main_0: (+1)
   \   0000002C   0xF3C2 0x05C9      UBFX     R5,R2,#+3,#+10
   \                     ??main_1: (+1)
   \   00000030   0xF643 0x76E0      MOVW     R6,#+16352
   \   00000034   0xEA06 0x1643      AND      R6,R6,R3, LSL #+5
   \   00000038   0xEA46 0x7685      ORR      R6,R6,R5, LSL #+30
   \   0000003C   0x6106             STR      R6,[R0, #+16]
   \   0000003E   0x462E             MOV      R6,R5
   \   00000040   0x1E75             SUBS     R5,R6,#+1
   \   00000042   0x2E00             CMP      R6,#+0
   \   00000044   0xD1F4             BNE.N    ??main_1
   \   00000046   0x461D             MOV      R5,R3
   \   00000048   0x1E6B             SUBS     R3,R5,#+1
   \   0000004A   0x2D00             CMP      R5,#+0
   \   0000004C   0xD1EE             BNE.N    ??main_0
   \   0000004E   0xF3BF 0x8F4F      DSB      
   \   00000052   0x6808             LDR      R0,[R1, #+0]
   \   00000054   0xF440 0x3080      ORR      R0,R0,#0x10000
   \   00000058   0x6008             STR      R0,[R1, #+0]
   \   0000005A   0x.... 0x....      BL       ?Subroutine0
     94            
     95            /* STM32F7xx HAL library initialization:
     96                 - Configure the Flash ART accelerator on ITCM interface
     97                 - Configure the Systick to generate an interrupt each 1 msec
     98                 - Set NVIC Group Priority to 4
     99                 - Global MSP (MCU Support Package) initialization
    100               */   
    101            HAL_Init();
   \                     ??CrossCallReturnLabel_2: (+1)
   \   0000005E   0x.... 0x....      BL       HAL_Init
    102            
    103            /* Configure the system clock to 216 MHz */
    104            SystemClock_Config(); 
   \   00000062   0x.... 0x....      BL       SystemClock_Config
    105            //SystemClock_Config1();
    106          
    107            /* Init Audio Application */
    108            //AUDIO_InitApplication();
    109              /* Configure LED1 */
    110            BSP_LED_Init(LED1);
   \   00000066   0x2000             MOVS     R0,#+0
   \   00000068   0x.... 0x....      LDR.W    R5,??DataTable10_2
   \   0000006C   0x.... 0x....      BL       BSP_LED_Init
    111            BSP_LED_Init(LED2);
   \   00000070   0x2001             MOVS     R0,#+1
   \   00000072   0x.... 0x....      BL       BSP_LED_Init
    112            
    113            /* Initialize for Audio player with CS43L22 */
    114           WavePlayerInit(48000);
   \   00000076   0xF64B 0x3080      MOVW     R0,#+48000
   \   0000007A   0x.... 0x....      BL       WavePlayerInit
    115          
    116              /* Play on */
    117            //AudioFlashPlay((uint16_t*)(AUDIO_SAMPLE + AUIDO_START_ADDRESS),AUDIO_FILE_SZE,AUIDO_START_ADDRESS);
    118            //while(1);
    119            
    120            /* Init TS module */
    121            //BSP_TS_Init(BSP_LCD_GetXSize(), BSP_LCD_GetYSize());
    122          
    123            /* Init Host Library */
    124            //USBH_Init(&hUSBHost, USBH_UserProcess, 0);
    125          
    126            /* Add Supported Class */
    127            //USBH_RegisterClass(&hUSBHost, USBH_MSC_CLASS);
    128            
    129            /* Start Host Process */
    130            //USBH_Start(&hUSBHost);
    131          
    132           
    133            
    134           
    135          
    136             /* ----------------------*/
    137             __GPIOB_CLK_ENABLE();
   \   0000007E   0x.... 0x....      LDR.W    R0,??DataTable10_3  ;; 0x40023830
   \   00000082   0x6801             LDR      R1,[R0, #+0]
   \   00000084   0xF041 0x0102      ORR      R1,R1,#0x2
   \   00000088   0x6001             STR      R1,[R0, #+0]
   \   0000008A   0x6800             LDR      R0,[R0, #+0]
    138            GPIO_INS.Pin = GPIO_PIN_4;
    139            GPIO_INS.Mode =GPIO_MODE_IT_RISING;
    140            GPIO_INS.Pull =GPIO_NOPULL;
    141            GPIO_INS.Speed =GPIO_SPEED_HIGH;
    142            HAL_GPIO_Init(GPIOB,&GPIO_INS);
   \   0000008C   0x1D29             ADDS     R1,R5,#+4
   \   0000008E   0xF000 0x0002      AND      R0,R0,#0x2
   \   00000092   0x9000             STR      R0,[SP, #+0]
   \   00000094   0x9800             LDR      R0,[SP, #+0]
   \   00000096   0x2010             MOVS     R0,#+16
   \   00000098   0x60EC             STR      R4,[R5, #+12]
   \   0000009A   0x6068             STR      R0,[R5, #+4]
   \   0000009C   0x.... 0x....      LDR.W    R0,??DataTable10_4  ;; 0x10110000
   \   000000A0   0x60A8             STR      R0,[R5, #+8]
   \   000000A2   0x2003             MOVS     R0,#+3
   \   000000A4   0x6128             STR      R0,[R5, #+16]
   \   000000A6   0x.... 0x....      LDR.W    R0,??DataTable10_5  ;; 0x40020400
   \   000000AA   0x.... 0x....      BL       HAL_GPIO_Init
    143          
    144            /* Enable and set Button EXTI Interrupt to the lowest priority */
    145            HAL_NVIC_SetPriority((IRQn_Type)EXTI4_IRQn, 0x0F, 0x00);
   \   000000AE   0x2200             MOVS     R2,#+0
   \   000000B0   0x210F             MOVS     R1,#+15
   \   000000B2   0x200A             MOVS     R0,#+10
   \   000000B4   0x.... 0x....      BL       HAL_NVIC_SetPriority
    146            HAL_NVIC_EnableIRQ((IRQn_Type)EXTI4_IRQn);
   \   000000B8   0x200A             MOVS     R0,#+10
   \   000000BA   0x.... 0x....      BL       HAL_NVIC_EnableIRQ
    147            /*-----------------------*/
    148          	
    149          
    150            //sop1hc
    151            ///////Audio_Streaming_Ini();
    152            /* control the STA321 */
    153            ///////MX_I2C1_Init(); 
    154            //MX_SPI5_Init();
    155            //HAL_Delay(10000);
    156            //__HAL_SPI_DISABLE(&hspi5);
    157            
    158            ////////I2S_Init();
    159          
    160            ////////STA321MP_Ini();	
    161          #if (DEBUG)  
    162            /* UART for debug */
    163            UART6_Init();
    164          #endif
    165            
    166          
    167          
    168           
    169            /* Run Application (Blocking mode) */
    170            while (1)
    171            {
    172          
    173          
    174          	/* USB Host Background task */
    175              //USBH_Process(&hUSBHost);
    176              
    177              /* AUDIO Menu Process */
    178              //AUDIO_MenuProcess();
    179          
    180          
    181          
    182              	  //if(HAL_SPI_TransmitReceive_IT(&hspi5, (uint8_t*)&Buffer1.pcm_buff[0], (uint8_t *)aRxBuffer, 1024) != HAL_OK)
    183                   {
    184                      /* Transfer error in transmission process */
    185                     //Error_Handler();
    186                    }
    187              if (flg10ms==1)
   \                     ??main_2: (+1)
   \   000000BE   0x7828             LDRB     R0,[R5, #+0]
   \   000000C0   0x2801             CMP      R0,#+1
   \   000000C2   0xD1FC             BNE.N    ??main_2
    188              {
    189                  flg10ms=0;
    190          		
    191                  //BSP_LED_Toggle(LED1);
    192          
    193          
    194                  //HAL_SPI_Receive_IT(&hspi5,(uint8_t *)&Buffer1.pcm_buff[0],124);
    195          	    //HAL_SPI_Receive(&hspi5,(uint8_t *)aRxBuffer,124,1000);
    196          
    197          	    //ReadSTASeq(pI2CData[j], pI2CRx, 10);
    198          		 
    199          
    200          #if (DEBUG)
    201          	     for(uint8_t i=0;i<10;i++)
    202          	     {
    203          		    sprintf(pUARTBuf,"Reg[ 0x%.2X ]: 0x%.2X \r\n",(pI2CData[j]+i),pI2CRx[i]);
    204          
    205          	        while(HAL_UART_Transmit(&huart6,pUARTBuf,20,1000)!= HAL_OK)
    206          	        {
    207          	          ;
    208          	        }
    209          	     }		   
    210          #endif
    211          
    212               
    213                 j++;
   \   000000C4   0x1C64             ADDS     R4,R4,#+1
   \   000000C6   0x2000             MOVS     R0,#+0
    214          
    215                 if (j==100) //50*10ms = 500 ms
   \   000000C8   0xB2E4             UXTB     R4,R4
   \   000000CA   0x2C64             CMP      R4,#+100
   \   000000CC   0x7028             STRB     R0,[R5, #+0]
   \   000000CE   0xD1F6             BNE.N    ??main_2
    216                 {
    217           
    218          
    219          #if (DEBUG)
    220          		 sprintf(pUARTBuf,"------------------");
    221          		 while(HAL_UART_Transmit(&huart6,pUARTBuf,30,1000)!= HAL_OK)
    222          	     {
    223          	          ;
    224          	      }
    225          #endif
    226                   BSP_LED_Toggle(LED1);
   \   000000D0   0x.... 0x....      BL       BSP_LED_Toggle
    227          		 BSP_LED_Toggle(LED2);
   \   000000D4   0x2001             MOVS     R0,#+1
   \   000000D6   0x2400             MOVS     R4,#+0
   \   000000D8   0x.... 0x....      BL       BSP_LED_Toggle
    228          	   	 j=0;
   \   000000DC   0xE7EF             B.N      ??main_2
    229                           
    230                 }
    231          
    232          
    233              }
    234            }
    235            
    236          }
    237          
    238          /**
    239            * @brief  Toggle Leds.
    240            * @param  None
    241            * @retval None
    242            */

   \                                 In section .text, align 2, keep-with-next
    243          void Toggle_Leds(void)
    244          {
    245            static uint32_t ticks = 0;
    246          
    247            if (ticks++ > 200)
   \                     Toggle_Leds: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable10_6
   \   00000004   0x6801             LDR      R1,[R0, #+0]
   \   00000006   0x1C4A             ADDS     R2,R1,#+1
   \   00000008   0x29C9             CMP      R1,#+201
   \   0000000A   0xBF28             IT       CS 
   \   0000000C   0x2200             MOVCS    R2,#+0
    248            {
    249              //BSP_LED_Toggle(LED1);
    250              ticks = 0;
   \   0000000E   0x6002             STR      R2,[R0, #+0]
    251            }
    252          }
   \   00000010   0x4770             BX       LR               ;; return
    253          
    254          
    255          /**
    256            * @brief  System Clock Configuration
    257            *         The system Clock is configured as follow : 
    258            *            System Clock source            = PLL (HSE)
    259            *            SYSCLK(Hz)                     = 216000000
    260            *            HCLK(Hz)                       = 216000000
    261            *            AHB Prescaler                  = 1
    262            *            APB1 Prescaler                 = 4
    263            *            APB2 Prescaler                 = 2
    264            *            HSE Frequency(Hz)              = 25000000
    265            *            PLL_M                          = 25
    266            *            PLL_N                          = 432
    267            *            PLL_P                          = 2
    268            *            PLL_Q                          = 9
    269            *            VDD(V)                         = 3.3
    270            *            Main regulator output voltage  = Scale1 mode
    271            *            Flash Latency(WS)              = 7
    272            * @param  None
    273            * @retval None
    274            */

   \                                 In section .text, align 2, keep-with-next
    275          static void SystemClock_Config(void)
    276          {
   \                     SystemClock_Config: (+1)
   \   00000000   0xB500             PUSH     {LR}
    277          
    278             RCC_OscInitTypeDef RCC_OscInitStruct;
    279            RCC_ClkInitTypeDef RCC_ClkInitStruct;
    280            RCC_PeriphCLKInitTypeDef PeriphClkInitStruct;
    281          
    282            __PWR_CLK_ENABLE();
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable10_7  ;; 0x40023840
   \   00000006   0xB0B3             SUB      SP,SP,#+204
   \   00000008   0x6801             LDR      R1,[R0, #+0]
   \   0000000A   0xF041 0x5180      ORR      R1,R1,#0x10000000
   \   0000000E   0x6001             STR      R1,[R0, #+0]
   \   00000010   0x6800             LDR      R0,[R0, #+0]
   \   00000012   0xF000 0x5080      AND      R0,R0,#0x10000000
   \   00000016   0x9000             STR      R0,[SP, #+0]
   \   00000018   0x9800             LDR      R0,[SP, #+0]
    283          
    284            __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE3);
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable10_8  ;; 0x40007000
   \   0000001E   0x6801             LDR      R1,[R0, #+0]
   \   00000020   0xF421 0x4140      BIC      R1,R1,#0xC000
   \   00000024   0xF441 0x4180      ORR      R1,R1,#0x4000
   \   00000028   0x6001             STR      R1,[R0, #+0]
   \   0000002A   0x6800             LDR      R0,[R0, #+0]
   \   0000002C   0xF400 0x4040      AND      R0,R0,#0xC000
   \   00000030   0x9000             STR      R0,[SP, #+0]
   \   00000032   0x9800             LDR      R0,[SP, #+0]
    285          
    286            RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
   \   00000034   0x2002             MOVS     R0,#+2
   \   00000036   0x9006             STR      R0,[SP, #+24]
    287            RCC_OscInitStruct.HSIState = RCC_HSI_ON;
   \   00000038   0x2001             MOVS     R0,#+1
   \   0000003A   0x9009             STR      R0,[SP, #+36]
    288            RCC_OscInitStruct.HSICalibrationValue = 16;
   \   0000003C   0x2010             MOVS     R0,#+16
   \   0000003E   0x900A             STR      R0,[SP, #+40]
    289            RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
   \   00000040   0x2002             MOVS     R0,#+2
   \   00000042   0x900C             STR      R0,[SP, #+48]
    290            RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0x900D             STR      R0,[SP, #+52]
    291            RCC_OscInitStruct.PLL.PLLM = 16;
   \   00000048   0x2010             MOVS     R0,#+16
   \   0000004A   0x900E             STR      R0,[SP, #+56]
    292            RCC_OscInitStruct.PLL.PLLN = 200;
   \   0000004C   0x20C8             MOVS     R0,#+200
   \   0000004E   0x900F             STR      R0,[SP, #+60]
    293            RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
   \   00000050   0x2002             MOVS     R0,#+2
   \   00000052   0x9010             STR      R0,[SP, #+64]
    294            RCC_OscInitStruct.PLL.PLLQ = 2;
   \   00000054   0x9011             STR      R0,[SP, #+68]
    295            HAL_RCC_OscConfig(&RCC_OscInitStruct);
   \   00000056   0xA806             ADD      R0,SP,#+24
   \   00000058   0x.... 0x....      BL       HAL_RCC_OscConfig
    296          
    297            HAL_PWREx_ActivateOverDrive();
   \   0000005C   0x.... 0x....      BL       HAL_PWREx_EnableOverDrive
    298          
    299            RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
    300                                        |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
   \   00000060   0x200F             MOVS     R0,#+15
    301            RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
    302            RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV2;
    303            RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
    304            RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
    305            HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_1);
   \   00000062   0x2101             MOVS     R1,#+1
   \   00000064   0x9001             STR      R0,[SP, #+4]
   \   00000066   0x2002             MOVS     R0,#+2
   \   00000068   0x9002             STR      R0,[SP, #+8]
   \   0000006A   0x2080             MOVS     R0,#+128
   \   0000006C   0x9003             STR      R0,[SP, #+12]
   \   0000006E   0x2000             MOVS     R0,#+0
   \   00000070   0x9004             STR      R0,[SP, #+16]
   \   00000072   0x9005             STR      R0,[SP, #+20]
   \   00000074   0xA801             ADD      R0,SP,#+4
   \   00000076   0x.... 0x....      BL       HAL_RCC_ClockConfig
    306          
    307            PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_UART4|RCC_PERIPHCLK_I2C1
    308                                        |RCC_PERIPHCLK_I2C2|RCC_PERIPHCLK_I2S;
   \   0000007A   0xF24C 0x2001      MOVW     R0,#+49665
   \   0000007E   0x9012             STR      R0,[SP, #+72]
    309            PeriphClkInitStruct.PLLI2S.PLLI2SN = 192;
   \   00000080   0x20C0             MOVS     R0,#+192
   \   00000082   0x9013             STR      R0,[SP, #+76]
    310            PeriphClkInitStruct.PLLI2S.PLLI2SP = 0;
   \   00000084   0x2000             MOVS     R0,#+0
   \   00000086   0x9016             STR      R0,[SP, #+88]
    311            PeriphClkInitStruct.PLLI2S.PLLI2SR = 2;
   \   00000088   0x2002             MOVS     R0,#+2
   \   0000008A   0x9014             STR      R0,[SP, #+80]
    312            PeriphClkInitStruct.PLLI2S.PLLI2SQ = 2;
   \   0000008C   0x9015             STR      R0,[SP, #+84]
    313            PeriphClkInitStruct.PLLI2SDivQ = 1;
   \   0000008E   0x2001             MOVS     R0,#+1
   \   00000090   0x901B             STR      R0,[SP, #+108]
    314            PeriphClkInitStruct.I2sClockSelection = RCC_I2SCLKSOURCE_PLLI2S;
   \   00000092   0x2000             MOVS     R0,#+0
   \   00000094   0x901F             STR      R0,[SP, #+124]
    315            PeriphClkInitStruct.Uart4ClockSelection = RCC_UART4CLKSOURCE_PCLK1;
   \   00000096   0x9026             STR      R0,[SP, #+152]
    316            PeriphClkInitStruct.I2c1ClockSelection = RCC_I2C1CLKSOURCE_PCLK1;
   \   00000098   0x902B             STR      R0,[SP, #+172]
    317            PeriphClkInitStruct.I2c2ClockSelection = RCC_I2C2CLKSOURCE_PCLK1;
   \   0000009A   0x902C             STR      R0,[SP, #+176]
    318            HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct);
   \   0000009C   0xA812             ADD      R0,SP,#+72
   \   0000009E   0x.... 0x....      BL       HAL_RCCEx_PeriphCLKConfig
    319          
    320            HAL_SYSTICK_Config(HAL_RCC_GetHCLKFreq()/1000);
   \   000000A2   0x.... 0x....      BL       HAL_RCC_GetHCLKFreq
   \   000000A6   0xF44F 0x717A      MOV      R1,#+1000
   \   000000AA   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   000000AE   0x.... 0x....      BL       HAL_SYSTICK_Config
    321          
    322            HAL_SYSTICK_CLKSourceConfig(SYSTICK_CLKSOURCE_HCLK);
   \   000000B2   0x2004             MOVS     R0,#+4
   \   000000B4   0x.... 0x....      BL       HAL_SYSTICK_CLKSourceConfig
    323          }
   \   000000B8   0xB033             ADD      SP,SP,#+204
   \   000000BA   0xBD00             POP      {PC}             ;; return
    324          
    325          
    326          
    327          #ifdef  USE_FULL_ASSERT
    328          /**
    329            * @brief  Reports the name of the source file and the source line number
    330            *         where the assert_param error has occurred.
    331            * @param  file: pointer to the source file name
    332            * @param  line: assert_param error line source number
    333            * @retval None
    334            */
    335          void assert_failed(uint8_t* file, uint32_t line)
    336          { 
    337            /* User can add his own implementation to report the file name and line number,
    338               ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
    339          
    340            /* Infinite loop */
    341            while (1)
    342            {
    343            }
    344          }
    345          #endif
    346          
    347          /**
    348            * @brief  CPU L1-Cache enable.
    349            * @param  None
    350            * @retval None
    351            */
    352          static void CPU_CACHE_Enable(void)
    353          {
    354            /* Enable I-Cache */
    355            SCB_EnableICache();
    356          
    357            /* Enable D-Cache */
    358            SCB_EnableDCache();
    359          }
    360          
    361          
    362          /* I2C1 init function */

   \                                 In section .text, align 2, keep-with-next
    363          void MX_I2C1_Init(void)
    364          {
   \                     MX_I2C1_Init: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    365          
    366          
    367            hi2c1.Instance = I2C1;
   \   00000002   0x.... 0x....      LDR.W    R4,??DataTable10_9
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable10_10  ;; 0x40005400
   \   0000000A   0x6020             STR      R0,[R4, #+0]
    368            hi2c1.Init.Timing =0x00C0EFFF; //I2C_SPEED DISCOVERY_I2Cx_TIMING;
   \   0000000C   0x....             LDR.N    R0,??DataTable10_11  ;; 0xc0efff
   \   0000000E   0x6060             STR      R0,[R4, #+4]
    369                                                     //I2C_TIMING ;//I2C_TIMING  0x00303D5D
    370                                                     //DISCOVERY_I2Cx_TIMING
    371            hi2c1.Init.OwnAddress1 = 0x33;
   \   00000010   0x2033             MOVS     R0,#+51
   \   00000012   0x60A0             STR      R0,[R4, #+8]
    372            hi2c1.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
   \   00000014   0x2001             MOVS     R0,#+1
   \   00000016   0x60E0             STR      R0,[R4, #+12]
    373            hi2c1.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x6120             STR      R0,[R4, #+16]
    374            hi2c1.Init.OwnAddress2 = 0;
   \   0000001C   0x6160             STR      R0,[R4, #+20]
    375            hi2c1.Init.OwnAddress2Masks = I2C_OA2_NOMASK;
   \   0000001E   0x61A0             STR      R0,[R4, #+24]
    376            hi2c1.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
   \   00000020   0x61E0             STR      R0,[R4, #+28]
    377            hi2c1.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
   \   00000022   0x6220             STR      R0,[R4, #+32]
    378            HAL_I2C_Init(&hi2c1);
   \   00000024   0x4620             MOV      R0,R4
   \   00000026   0x.... 0x....      BL       HAL_I2C_Init
    379          
    380             /*Configure Analogue filter */
    381            HAL_I2CEx_AnalogFilter_Config(&hi2c1, I2C_ANALOGFILTER_ENABLE);
   \   0000002A   0x4620             MOV      R0,R4
   \   0000002C   0x2100             MOVS     R1,#+0
   \   0000002E   0xE8BD 0x4010      POP      {R4,LR}
   \   00000032   0x.... 0x....      B.W      HAL_I2CEx_ConfigAnalogFilter
    382          
    383          }
    384          
    385          
    386          

   \                                 In section .text, align 2, keep-with-next
    387          void HAL_I2C_MspInit(I2C_HandleTypeDef* hi2c)
    388          {
   \                     HAL_I2C_MspInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB086             SUB      SP,SP,#+24
    389          
    390            GPIO_InitTypeDef GPIO_InitStruct;
    391              
    392            if(hi2c->Instance==I2C1)
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x....             LDR.N    R1,??DataTable10_10  ;; 0x40005400
   \   00000008   0x....             LDR.N    R4,??DataTable10_3  ;; 0x40023830
   \   0000000A   0x4288             CMP      R0,R1
   \   0000000C   0xD121             BNE.N    ??HAL_I2C_MspInit_0
    393            {
    394            /* USER CODE BEGIN I2C1_MspInit 0 */
    395          
    396              /*##-1- Configure the I2C clock source. The clock is derived from the SYSCLK #*/
    397              //RCC_PeriphCLKInitStruct.PeriphClockSelection = RCC_PERIPHCLK_I2C1;
    398              //RCC_PeriphCLKInitStruct.I2c1ClockSelection = RCC_I2C1CLKSOURCE_PCLK1;
    399              //HAL_RCCEx_PeriphCLKConfig(&RCC_PeriphCLKInitStruct);
    400          
    401              /*##-2- Enable peripherals and GPIO Clocks #################################*/
    402              /* Enable GPIO TX/RX clock */
    403              __HAL_RCC_GPIOB_CLK_ENABLE();
   \   0000000E   0x6820             LDR      R0,[R4, #+0]
    404          
    405            
    406            
    407              /**I2C1 GPIO Configuration    
    408              PB6     ------> I2C1_SCL (PB6)
    409              PB7     ------> I2C1_SDA (PB7) 
    410              */
    411              GPIO_InitStruct.Pin = GPIO_PIN_6|GPIO_PIN_7;
    412              GPIO_InitStruct.Mode = GPIO_MODE_AF_OD;
    413              GPIO_InitStruct.Pull = GPIO_PULLUP;
    414              GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
    415              GPIO_InitStruct.Alternate = GPIO_AF4_I2C1;
    416              HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
   \   00000010   0xA901             ADD      R1,SP,#+4
   \   00000012   0xF040 0x0002      ORR      R0,R0,#0x2
   \   00000016   0x6020             STR      R0,[R4, #+0]
   \   00000018   0x6820             LDR      R0,[R4, #+0]
   \   0000001A   0xF000 0x0002      AND      R0,R0,#0x2
   \   0000001E   0x9000             STR      R0,[SP, #+0]
   \   00000020   0x9800             LDR      R0,[SP, #+0]
   \   00000022   0x20C0             MOVS     R0,#+192
   \   00000024   0x.... 0x....      BL       ?Subroutine2
   \                     ??CrossCallReturnLabel_5: (+1)
   \   00000028   0x....             LDR.N    R0,??DataTable10_5  ;; 0x40020400
   \   0000002A   0x.... 0x....      BL       HAL_GPIO_Init
    417          
    418              /* Peripheral clock enable */
    419              __HAL_RCC_I2C1_CLK_ENABLE();
   \   0000002E   0x6920             LDR      R0,[R4, #+16]
    420          	  /* Peripheral interrupt init*/
    421              HAL_NVIC_SetPriority(I2C1_EV_IRQn, 3, 0);
   \   00000030   0x2200             MOVS     R2,#+0
   \   00000032   0x2103             MOVS     R1,#+3
   \   00000034   0xF440 0x1000      ORR      R0,R0,#0x200000
   \   00000038   0x6120             STR      R0,[R4, #+16]
   \   0000003A   0x6920             LDR      R0,[R4, #+16]
   \   0000003C   0xF400 0x1000      AND      R0,R0,#0x200000
   \   00000040   0x9000             STR      R0,[SP, #+0]
   \   00000042   0x9800             LDR      R0,[SP, #+0]
   \   00000044   0x201F             MOVS     R0,#+31
   \   00000046   0x.... 0x....      BL       HAL_NVIC_SetPriority
    422              HAL_NVIC_EnableIRQ(I2C1_EV_IRQn);
   \   0000004A   0x201F             MOVS     R0,#+31
   \   0000004C   0x.... 0x....      BL       HAL_NVIC_EnableIRQ
   \   00000050   0xE012             B.N      ??HAL_I2C_MspInit_1
    423            /* USER CODE BEGIN I2C1_MspInit 1 */
    424          
    425          
    426            /* USER CODE END I2C1_MspInit 1 */
    427            }
    428            else if(hi2c->Instance==I2C2)
   \                     ??HAL_I2C_MspInit_0: (+1)
   \   00000052   0x....             LDR.N    R1,??DataTable10_12  ;; 0x40005800
   \   00000054   0x4288             CMP      R0,R1
   \   00000056   0xD10F             BNE.N    ??HAL_I2C_MspInit_1
    429            {
    430            /* USER CODE BEGIN I2C2_MspInit 0 */
    431          
    432            /* USER CODE END I2C2_MspInit 0 */
    433            
    434              /**I2C2 GPIO Configuration    
    435              PF0     ------> I2C2_SDA
    436              PF1     ------> I2C2_SCL 
    437              */
    438              GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_1;
   \   00000058   0x2003             MOVS     R0,#+3
    439              GPIO_InitStruct.Mode = GPIO_MODE_AF_OD;
    440              GPIO_InitStruct.Pull = GPIO_PULLUP;
    441              GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
    442              GPIO_InitStruct.Alternate = GPIO_AF4_I2C2;
    443              HAL_GPIO_Init(GPIOF, &GPIO_InitStruct);
   \   0000005A   0xA901             ADD      R1,SP,#+4
   \   0000005C   0x.... 0x....      BL       ?Subroutine2
   \                     ??CrossCallReturnLabel_6: (+1)
   \   00000060   0x....             LDR.N    R0,??DataTable10_13  ;; 0x40021400
   \   00000062   0x.... 0x....      BL       HAL_GPIO_Init
    444          
    445              /* Peripheral clock enable */
    446              __HAL_RCC_I2C2_CLK_ENABLE();
   \   00000066   0x6920             LDR      R0,[R4, #+16]
   \   00000068   0xF440 0x0080      ORR      R0,R0,#0x400000
   \   0000006C   0x6120             STR      R0,[R4, #+16]
   \   0000006E   0x6920             LDR      R0,[R4, #+16]
   \   00000070   0xF400 0x0080      AND      R0,R0,#0x400000
   \   00000074   0x9000             STR      R0,[SP, #+0]
   \   00000076   0x9800             LDR      R0,[SP, #+0]
    447            /* USER CODE BEGIN I2C2_MspInit 1 */
    448          
    449            /* USER CODE END I2C2_MspInit 1 */
    450            }
    451          
    452          }
   \                     ??HAL_I2C_MspInit_1: (+1)
   \   00000078   0xB006             ADD      SP,SP,#+24
   \   0000007A   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine2: (+1)
   \   00000000   0x9001             STR      R0,[SP, #+4]
   \   00000002   0x2012             MOVS     R0,#+18
   \   00000004   0x9002             STR      R0,[SP, #+8]
   \   00000006   0x2001             MOVS     R0,#+1
   \   00000008   0x9003             STR      R0,[SP, #+12]
   \   0000000A   0x2003             MOVS     R0,#+3
   \   0000000C   0x9004             STR      R0,[SP, #+16]
   \   0000000E   0x2004             MOVS     R0,#+4
   \   00000010   0x9005             STR      R0,[SP, #+20]
   \   00000012   0x4770             BX       LR
    453          
    454          /*---------------------------------------------------*/
    455          /*   UART                                            */
    456          /* UART4 init function */

   \                                 In section .text, align 2, keep-with-next
    457          void UART6_Init(void)
    458          {
    459          
    460            huart6.Instance = USART6;
   \                     UART6_Init: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable10_14
   \   00000002   0x....             LDR.N    R1,??DataTable10_15  ;; 0x40011400
   \   00000004   0x6001             STR      R1,[R0, #+0]
    461            huart6.Init.BaudRate = 115200;
   \   00000006   0xF44F 0x31E1      MOV      R1,#+115200
   \   0000000A   0x6041             STR      R1,[R0, #+4]
    462            huart6.Init.WordLength = UART_WORDLENGTH_8B;
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0x6081             STR      R1,[R0, #+8]
    463            huart6.Init.StopBits = UART_STOPBITS_1;
   \   00000010   0x60C1             STR      R1,[R0, #+12]
    464            huart6.Init.Parity = UART_PARITY_NONE;
   \   00000012   0x6101             STR      R1,[R0, #+16]
    465            huart6.Init.Mode = UART_MODE_TX_RX;
   \   00000014   0x210C             MOVS     R1,#+12
   \   00000016   0x6141             STR      R1,[R0, #+20]
    466            huart6.Init.HwFlowCtl = UART_HWCONTROL_NONE;
   \   00000018   0x2100             MOVS     R1,#+0
   \   0000001A   0x6181             STR      R1,[R0, #+24]
    467            huart6.Init.OverSampling = UART_OVERSAMPLING_16;
   \   0000001C   0x61C1             STR      R1,[R0, #+28]
    468            huart6.Init.OneBitSampling = UART_ONEBIT_SAMPLING_DISABLED ;
   \   0000001E   0x6201             STR      R1,[R0, #+32]
    469            huart6.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
   \   00000020   0x6241             STR      R1,[R0, #+36]
    470            HAL_UART_Init(&huart6);
   \   00000022   0x.... 0x....      B.W      HAL_UART_Init
    471          
    472          }
    473          

   \                                 In section .text, align 2, keep-with-next
    474          void HAL_UART_MspInit(UART_HandleTypeDef* huart)
    475          {
    476          
    477            GPIO_InitTypeDef GPIO_InitStruct;
    478            if(huart->Instance==USART6)
   \                     HAL_UART_MspInit: (+1)
   \   00000000   0x6800             LDR      R0,[R0, #+0]
   \   00000002   0x....             LDR.N    R1,??DataTable10_15  ;; 0x40011400
   \   00000004   0x4288             CMP      R0,R1
   \   00000006   0xD000             BEQ.N    ??HAL_UART_MspInit_0
   \   00000008   0x4770             BX       LR
    479            {
    480            /* USER CODE BEGIN UART6_MspInit 0 */
    481          
    482            /* USER CODE END UART4_MspInit 0 */
    483              /* Peripheral clock enable */
    484              __USART6_CLK_ENABLE();
   \                     ??HAL_UART_MspInit_0: (+1)
   \   0000000A   0xB500             PUSH     {LR}
   \   0000000C   0x....             LDR.N    R0,??DataTable10_3  ;; 0x40023830
   \   0000000E   0xB087             SUB      SP,SP,#+28
   \   00000010   0x6941             LDR      R1,[R0, #+20]
   \   00000012   0xF041 0x0120      ORR      R1,R1,#0x20
   \   00000016   0x6141             STR      R1,[R0, #+20]
   \   00000018   0x6941             LDR      R1,[R0, #+20]
   \   0000001A   0xF001 0x0120      AND      R1,R1,#0x20
   \   0000001E   0x9100             STR      R1,[SP, #+0]
   \   00000020   0x9900             LDR      R1,[SP, #+0]
    485              __GPIOC_CLK_ENABLE();
   \   00000022   0x6801             LDR      R1,[R0, #+0]
   \   00000024   0xF041 0x0104      ORR      R1,R1,#0x4
   \   00000028   0x6001             STR      R1,[R0, #+0]
   \   0000002A   0x6800             LDR      R0,[R0, #+0]
    486            
    487              /**UART4 GPIO Configuration    
    488              PC10     ------> UART4_TX (PC6)
    489              PC11     ------> UART4_RX (PC7)
    490              */
    491              GPIO_InitStruct.Pin = GPIO_PIN_6|GPIO_PIN_6;
    492              GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    493              GPIO_InitStruct.Pull = GPIO_PULLUP;
    494              GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
    495              GPIO_InitStruct.Alternate = GPIO_AF8_USART6;
    496              HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
   \   0000002C   0xA901             ADD      R1,SP,#+4
   \   0000002E   0xF000 0x0004      AND      R0,R0,#0x4
   \   00000032   0x9000             STR      R0,[SP, #+0]
   \   00000034   0x9800             LDR      R0,[SP, #+0]
   \   00000036   0x2040             MOVS     R0,#+64
   \   00000038   0x9001             STR      R0,[SP, #+4]
   \   0000003A   0x2002             MOVS     R0,#+2
   \   0000003C   0x9002             STR      R0,[SP, #+8]
   \   0000003E   0x2001             MOVS     R0,#+1
   \   00000040   0x9003             STR      R0,[SP, #+12]
   \   00000042   0x2003             MOVS     R0,#+3
   \   00000044   0x9004             STR      R0,[SP, #+16]
   \   00000046   0x2008             MOVS     R0,#+8
   \   00000048   0x9005             STR      R0,[SP, #+20]
   \   0000004A   0x....             LDR.N    R0,??DataTable10_16  ;; 0x40020800
   \   0000004C   0x.... 0x....      BL       HAL_GPIO_Init
    497          
    498          	  /* NVIC for USART */
    499            HAL_NVIC_SetPriority(USART6_IRQn, 0, 1);
   \   00000050   0x2201             MOVS     R2,#+1
   \   00000052   0x2100             MOVS     R1,#+0
   \   00000054   0x2047             MOVS     R0,#+71
   \   00000056   0x.... 0x....      BL       HAL_NVIC_SetPriority
    500            HAL_NVIC_EnableIRQ(USART6_IRQn);
   \   0000005A   0x2047             MOVS     R0,#+71
   \   0000005C   0x.... 0x....      BL       HAL_NVIC_EnableIRQ
    501          
    502            /* USER CODE BEGIN UART4_MspInit 1 */
    503          
    504            /* USER CODE END UART4_MspInit 1 */
    505            }
    506          
    507          }
   \   00000060   0xB007             ADD      SP,SP,#+28
   \   00000062   0xBD00             POP      {PC}             ;; return
    508          
    509          
    510          

   \                                 In section .text, align 2, keep-with-next
    511          void HAL_SPI_MspInit(SPI_HandleTypeDef* hspi)
    512          {
   \                     HAL_SPI_MspInit: (+1)
   \   00000000   0xB500             PUSH     {LR}
    513          
    514            GPIO_InitTypeDef GPIO_InitStruct;
    515            if(hspi->Instance==SPI4)
   \   00000002   0x....             LDR.N    R2,??DataTable10_17  ;; 0x40013400
   \   00000004   0xB087             SUB      SP,SP,#+28
   \   00000006   0x6801             LDR      R1,[R0, #+0]
   \   00000008   0x....             LDR.N    R0,??DataTable10_3  ;; 0x40023830
   \   0000000A   0x4291             CMP      R1,R2
   \   0000000C   0xD10E             BNE.N    ??HAL_SPI_MspInit_0
    516            {
    517            /* USER CODE BEGIN SPI4_MspInit 0 */
    518          
    519            /* USER CODE END SPI4_MspInit 0 */
    520              /* Peripheral clock enable */
    521              __SPI4_CLK_ENABLE();
   \   0000000E   0x6941             LDR      R1,[R0, #+20]
   \   00000010   0xF441 0x5100      ORR      R1,R1,#0x2000
   \   00000014   0x6141             STR      R1,[R0, #+20]
   \   00000016   0x6940             LDR      R0,[R0, #+20]
    522            
    523            
    524              /**SPI4 GPIO Configuration    
    525              PE2     ------> SPI4_SCK
    526              PE4     ------> SPI4_NSS
    527              PE5     ------> SPI4_MISO
    528              PE6     ------> SPI4_MOSI 
    529              */
    530              GPIO_InitStruct.Pin = GPIO_PIN_2|GPIO_PIN_4|GPIO_PIN_5|GPIO_PIN_6;
    531              GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    532              GPIO_InitStruct.Pull = GPIO_NOPULL;
    533              GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
    534              GPIO_InitStruct.Alternate = GPIO_AF5_SPI4;
    535              HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
   \   00000018   0xA901             ADD      R1,SP,#+4
   \   0000001A   0xF400 0x5000      AND      R0,R0,#0x2000
   \   0000001E   0x9000             STR      R0,[SP, #+0]
   \   00000020   0x9800             LDR      R0,[SP, #+0]
   \   00000022   0x2074             MOVS     R0,#+116
   \   00000024   0x.... 0x....      BL       ?Subroutine1
    536          
    537            /* USER CODE BEGIN SPI4_MspInit 1 */
    538          
    539            /* USER CODE END SPI4_MspInit 1 */
    540            }
   \                     ??CrossCallReturnLabel_3: (+1)
   \   00000028   0x....             LDR.N    R0,??DataTable10_18  ;; 0x40021000
   \   0000002A   0xE03D             B.N      ??HAL_SPI_MspInit_1
    541            else if(hspi->Instance==SPI5)
   \                     ??HAL_SPI_MspInit_0: (+1)
   \   0000002C   0x....             LDR.N    R2,??DataTable10_19  ;; 0x40015000
   \   0000002E   0x4291             CMP      R1,R2
   \   00000030   0xD128             BNE.N    ??HAL_SPI_MspInit_2
    542            {
    543            /* USER CODE BEGIN SPI5_MspInit 0 */
    544          
    545            /* USER CODE END SPI5_MspInit 0 */
    546              /* Peripheral clock enable */
    547              __HAL_RCC_SPI5_CLK_ENABLE();
   \   00000032   0x6941             LDR      R1,[R0, #+20]
   \   00000034   0xF441 0x1180      ORR      R1,R1,#0x100000
   \   00000038   0x6141             STR      R1,[R0, #+20]
   \   0000003A   0x6941             LDR      R1,[R0, #+20]
   \   0000003C   0xF401 0x1180      AND      R1,R1,#0x100000
   \   00000040   0x9100             STR      R1,[SP, #+0]
   \   00000042   0x9900             LDR      R1,[SP, #+0]
    548              __HAL_RCC_GPIOF_CLK_ENABLE();
   \   00000044   0x6801             LDR      R1,[R0, #+0]
   \   00000046   0xF041 0x0120      ORR      R1,R1,#0x20
   \   0000004A   0x6001             STR      R1,[R0, #+0]
   \   0000004C   0x6800             LDR      R0,[R0, #+0]
    549            
    550              /**SPI5 GPIO Configuration    
    551              PF7     ------> SPI5_SCK  --> PF7
    552              PF11     ------> SPI5_MOSI --> PF9
    553                               SPI5_MISO --> PF8
    554                                    NSS   -->  PF6
    555              */
    556              GPIO_InitStruct.Pin = GPIO_PIN_6|GPIO_PIN_7|GPIO_PIN_9|GPIO_PIN_8;
    557              GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    558              GPIO_InitStruct.Pull = GPIO_PULLDOWN;
    559              GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
    560              GPIO_InitStruct.Alternate = GPIO_AF5_SPI5;
    561              HAL_GPIO_Init(GPIOF, &GPIO_InitStruct);
   \   0000004E   0xA901             ADD      R1,SP,#+4
   \   00000050   0xF000 0x0020      AND      R0,R0,#0x20
   \   00000054   0x9000             STR      R0,[SP, #+0]
   \   00000056   0x9800             LDR      R0,[SP, #+0]
   \   00000058   0xF44F 0x7070      MOV      R0,#+960
   \   0000005C   0x9001             STR      R0,[SP, #+4]
   \   0000005E   0x2002             MOVS     R0,#+2
   \   00000060   0x9002             STR      R0,[SP, #+8]
   \   00000062   0x9003             STR      R0,[SP, #+12]
   \   00000064   0x2003             MOVS     R0,#+3
   \   00000066   0x9004             STR      R0,[SP, #+16]
   \   00000068   0x2005             MOVS     R0,#+5
   \   0000006A   0x9005             STR      R0,[SP, #+20]
   \   0000006C   0x....             LDR.N    R0,??DataTable10_13  ;; 0x40021400
   \   0000006E   0x.... 0x....      BL       HAL_GPIO_Init
    562          
    563            /* Peripheral interrupt init*/
    564              HAL_NVIC_SetPriority(SPI5_IRQn, 2, 2);
   \   00000072   0x2202             MOVS     R2,#+2
   \   00000074   0x2102             MOVS     R1,#+2
   \   00000076   0x2055             MOVS     R0,#+85
   \   00000078   0x.... 0x....      BL       HAL_NVIC_SetPriority
    565              HAL_NVIC_EnableIRQ(SPI5_IRQn);
   \   0000007C   0x2055             MOVS     R0,#+85
   \   0000007E   0x.... 0x....      BL       HAL_NVIC_EnableIRQ
   \   00000082   0xE013             B.N      ??HAL_SPI_MspInit_3
    566            /* USER CODE BEGIN SPI5_MspInit 1 */
    567          
    568            /* USER CODE END SPI5_MspInit 1 */
    569            }
    570            else if(hspi->Instance==SPI6)
   \                     ??HAL_SPI_MspInit_2: (+1)
   \   00000084   0x....             LDR.N    R2,??DataTable10_20  ;; 0x40015400
   \   00000086   0x4291             CMP      R1,R2
   \   00000088   0xD110             BNE.N    ??HAL_SPI_MspInit_3
    571            {
    572            /* USER CODE BEGIN SPI6_MspInit 0 */
    573          
    574            /* USER CODE END SPI6_MspInit 0 */
    575              /* Peripheral clock enable */
    576              __SPI6_CLK_ENABLE();
   \   0000008A   0x6941             LDR      R1,[R0, #+20]
   \   0000008C   0xF441 0x1100      ORR      R1,R1,#0x200000
   \   00000090   0x6141             STR      R1,[R0, #+20]
   \   00000092   0x6940             LDR      R0,[R0, #+20]
    577            
    578              /**SPI6 GPIO Configuration    
    579              PG13     ------> SPI6_SCK
    580              PG14     ------> SPI6_MOSI 
    581              */
    582              GPIO_InitStruct.Pin = GPIO_PIN_13|GPIO_PIN_14;
    583              GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    584              GPIO_InitStruct.Pull = GPIO_NOPULL;
    585              GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
    586              GPIO_InitStruct.Alternate = GPIO_AF5_SPI6;
    587              HAL_GPIO_Init(GPIOG, &GPIO_InitStruct);
   \   00000094   0xA901             ADD      R1,SP,#+4
   \   00000096   0xF400 0x1000      AND      R0,R0,#0x200000
   \   0000009A   0x9000             STR      R0,[SP, #+0]
   \   0000009C   0x9800             LDR      R0,[SP, #+0]
   \   0000009E   0xF44F 0x40C0      MOV      R0,#+24576
   \   000000A2   0x.... 0x....      BL       ?Subroutine1
    588          
    589            /* USER CODE BEGIN SPI6_MspInit 1 */
    590          
    591            /* USER CODE END SPI6_MspInit 1 */
    592            }
   \                     ??CrossCallReturnLabel_4: (+1)
   \   000000A6   0x....             LDR.N    R0,??DataTable10_21  ;; 0x40021800
   \                     ??HAL_SPI_MspInit_1: (+1)
   \   000000A8   0x.... 0x....      BL       HAL_GPIO_Init
    593          
    594          }
   \                     ??HAL_SPI_MspInit_3: (+1)
   \   000000AC   0xB007             ADD      SP,SP,#+28
   \   000000AE   0xBD00             POP      {PC}             ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \   00000000   0x9001             STR      R0,[SP, #+4]
   \   00000002   0x2002             MOVS     R0,#+2
   \   00000004   0x9002             STR      R0,[SP, #+8]
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x9003             STR      R0,[SP, #+12]
   \   0000000A   0x2003             MOVS     R0,#+3
   \   0000000C   0x9004             STR      R0,[SP, #+16]
   \   0000000E   0x2005             MOVS     R0,#+5
   \   00000010   0x9005             STR      R0,[SP, #+20]
   \   00000012   0x4770             BX       LR
    595          
    596          
    597          /* SPI5 init function */

   \                                 In section .text, align 2, keep-with-next
    598          void MX_SPI5_Init(void)
    599          {
   \                     MX_SPI5_Init: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    600          
    601            hspi5.Instance = SPI5;
   \   00000002   0x....             LDR.N    R4,??DataTable10_22
   \   00000004   0x....             LDR.N    R0,??DataTable10_19  ;; 0x40015000
   \   00000006   0x6020             STR      R0,[R4, #+0]
    602            hspi5.Init.Mode = SPI_MODE_SLAVE;
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x6060             STR      R0,[R4, #+4]
    603            hspi5.Init.Direction = SPI_DIRECTION_2LINES_RXONLY;//SPI_DIRECTION_2LINES_RXONLY
   \   0000000C   0xF44F 0x6080      MOV      R0,#+1024
   \   00000010   0x60A0             STR      R0,[R4, #+8]
    604            hspi5.Init.DataSize = SPI_DATASIZE_16BIT;
   \   00000012   0xF44F 0x6070      MOV      R0,#+3840
   \   00000016   0x60E0             STR      R0,[R4, #+12]
    605            hspi5.Init.CLKPolarity = SPI_POLARITY_LOW;
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x6120             STR      R0,[R4, #+16]
    606            hspi5.Init.CLKPhase = SPI_PHASE_1EDGE;
   \   0000001C   0x6160             STR      R0,[R4, #+20]
    607            hspi5.Init.NSS = SPI_NSS_SOFT;//SPI_NSS_HARD_INPUT
   \   0000001E   0xF44F 0x7000      MOV      R0,#+512
   \   00000022   0x61A0             STR      R0,[R4, #+24]
    608            hspi5.Init.FirstBit = SPI_FIRSTBIT_MSB;
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0x6220             STR      R0,[R4, #+32]
    609            hspi5.Init.TIMode = SPI_TIMODE_DISABLE;
   \   00000028   0x6260             STR      R0,[R4, #+36]
    610            hspi5.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLED;
   \   0000002A   0x62A0             STR      R0,[R4, #+40]
    611            hspi5.Init.CRCPolynomial = 7;
   \   0000002C   0x2007             MOVS     R0,#+7
   \   0000002E   0x62E0             STR      R0,[R4, #+44]
    612            hspi5.Init.CRCLength = SPI_CRC_LENGTH_DATASIZE;
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0x6320             STR      R0,[R4, #+48]
    613            hspi5.Init.NSSPMode = SPI_NSS_PULSE_DISABLE;
   \   00000034   0x6360             STR      R0,[R4, #+52]
    614            //hspi5.RxISR = SPI5_CallBack;
    615            HAL_SPI_Init(&hspi5);
   \   00000036   0x4620             MOV      R0,R4
   \   00000038   0x.... 0x....      BL       HAL_SPI_Init
    616          
    617          
    618            //HAL_GPIO_WritePin(GPIOF,GPIO_PIN_6,GPIO_PIN_SET);
    619            /* Enable TXE, RXNE and ERR interrupt */
    620           __HAL_SPI_ENABLE_IT(&hspi5, (SPI_IT_RXNE| SPI_IT_ERR));
   \   0000003C   0x6820             LDR      R0,[R4, #+0]
   \   0000003E   0x6841             LDR      R1,[R0, #+4]
   \   00000040   0xF041 0x0160      ORR      R1,R1,#0x60
   \   00000044   0x6041             STR      R1,[R0, #+4]
    621          
    622           __HAL_SPI_ENABLE(&hspi5);
   \   00000046   0x6801             LDR      R1,[R0, #+0]
   \   00000048   0xF041 0x0140      ORR      R1,R1,#0x40
   \   0000004C   0x6001             STR      R1,[R0, #+0]
    623          
    624          }
   \   0000004E   0xBD10             POP      {R4,PC}          ;; return
    625          
    626          
    627          

   \                                 In section .text, align 2, keep-with-next
    628          void SPI5_IRQHandler(void)
    629          {
    630            static uint16_t stNipple;
    631            static uint8_t stLR, stOder;
    632            
    633            /* USER CODE BEGIN SPI5_IRQn 0 */
    634          
    635            /* USER CODE END SPI5_IRQn 0 */
    636            //HAL_SPI_IRQHandler(&hspi5);
    637            /* USER CODE BEGIN SPI5_IRQn 1 */
    638          
    639            /* USER CODE END SPI5_IRQn 1 */
    640              /* Check if data are available in SPI Data register */
    641            /* SPI in mode Receiver ----------------------------------------------------*/
    642            if(
    643               (__HAL_SPI_GET_FLAG(&hspi5, SPI_FLAG_OVR) == RESET)&&
    644               (__HAL_SPI_GET_FLAG(&hspi5, SPI_FLAG_RXNE) != RESET)&&
    645               (__HAL_SPI_GET_IT_SOURCE(&hspi5, SPI_IT_RXNE) != RESET))
   \                     SPI5_IRQHandler: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable10_22
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x6881             LDR      R1,[R0, #+8]
   \   00000006   0x0649             LSLS     R1,R1,#+25
   \   00000008   0xD500             BPL.N    ??SPI5_IRQHandler_0
   \   0000000A   0x4770             BX       LR
   \                     ??SPI5_IRQHandler_0: (+1)
   \   0000000C   0xB570             PUSH     {R4-R6,LR}
   \   0000000E   0x6881             LDR      R1,[R0, #+8]
   \   00000010   0x07C9             LSLS     R1,R1,#+31
   \   00000012   0xD55F             BPL.N    ??SPI5_IRQHandler_1
   \   00000014   0x6840             LDR      R0,[R0, #+4]
   \   00000016   0x0640             LSLS     R0,R0,#+25
   \   00000018   0xD55C             BPL.N    ??SPI5_IRQHandler_1
    646            {
    647          
    648          
    649             uint16_t test;
    650             test =  SPI_I2S_ReceiveData(SPI5);
    651             //SPI_I2S_SendData(SPI5,0);
    652             //BSP_LED_Toggle(LED1);
    653             //if (HAL_GPIO_ReadPin(GPIOB,GPIO_PIN_4)==GPIO_PIN_SET)
    654             {
    655          
    656                stOder^=0x01;
   \   0000001A   0x....             LDR.N    R1,??DataTable10_23
   \   0000001C   0x....             LDR.N    R0,??DataTable10_24  ;; 0x4001500c
   \   0000001E   0x6802             LDR      R2,[R0, #+0]
   \   00000020   0xF501 0x4010      ADD      R0,R1,#+36864
   \   00000024   0x3018             ADDS     R0,R0,#+24
   \   00000026   0xB292             UXTH     R2,R2
   \   00000028   0x7A83             LDRB     R3,[R0, #+10]
   \   0000002A   0xF093 0x0301      EORS     R3,R3,#0x1
   \   0000002E   0x7283             STRB     R3,[R0, #+10]
    657                if(stOder==0x00)
   \   00000030   0xD141             BNE.N    ??SPI5_IRQHandler_2
    658                {
    659          
    660                    //BSP_LED_On(LED1);  
    661          
    662          		  stLR^=0x01;
   \   00000032   0x7A43             LDRB     R3,[R0, #+9]
    663          		  if (stLR==0x01)
   \   00000034   0xF641 0x74FE      MOVW     R4,#+8190
   \   00000038   0xF083 0x0301      EOR      R3,R3,#0x1
   \   0000003C   0x2B01             CMP      R3,#+1
   \   0000003E   0x7243             STRB     R3,[R0, #+9]
   \   00000040   0xD11B             BNE.N    ??SPI5_IRQHandler_3
    664          		  {
    665          		    if (Buffer1.offset + idxSPI5DataBuf1 < AUDIO_OUT_BUFFER_SIZE-2) 
   \   00000042   0xF644 0x0308      MOVW     R3,#+18440
   \   00000046   0x585D             LDR      R5,[R3, R1]
   \   00000048   0x8986             LDRH     R6,[R0, #+12]
   \   0000004A   0xFA15 0xF686      UXTAH    R6,R5,R6
   \   0000004E   0x42A6             CMP      R6,R4
   \   00000050   0xD23C             BCS.N    ??SPI5_IRQHandler_4
    666          		    {
    667          	               Buffer1.pcm_buff[Buffer1.offset + idxSPI5DataBuf1++] =((test>>4)|(stNipple<<12));
   \   00000052   0x8984             LDRH     R4,[R0, #+12]
   \   00000054   0x1C66             ADDS     R6,R4,#+1
   \   00000056   0xFA15 0xF484      UXTAH    R4,R5,R4
   \   0000005A   0x8186             STRH     R6,[R0, #+12]
   \   0000005C   0x8A06             LDRH     R6,[R0, #+16]
   \   0000005E   0x0336             LSLS     R6,R6,#+12
   \   00000060   0xEA46 0x1222      ORR      R2,R6,R2, ASR #+4
   \   00000064   0xF821 0x2014      STRH     R2,[R1, R4, LSL #+1]
    668          				   Buffer1.pcm_buff[Buffer1.offset + idxSPI5DataBuf1++] =((test>>4)|(stNipple<<12));
   \   00000068   0x8984             LDRH     R4,[R0, #+12]
   \   0000006A   0x1C65             ADDS     R5,R4,#+1
   \   0000006C   0x8185             STRH     R5,[R0, #+12]
   \   0000006E   0x585B             LDR      R3,[R3, R1]
   \   00000070   0xFA13 0xF384      UXTAH    R3,R3,R4
   \   00000074   0xF821 0x2013      STRH     R2,[R1, R3, LSL #+1]
   \   00000078   0xE028             B.N      ??SPI5_IRQHandler_4
    669          		    }
    670          		  }
    671          		  else
    672          		  {
    673          		     if (Buffer2.offset + idxSPI5DataBuf2 < AUDIO_OUT_BUFFER_SIZE-2)
   \                     ??SPI5_IRQHandler_3: (+1)
   \   0000007A   0x6803             LDR      R3,[R0, #+0]
   \   0000007C   0x89C5             LDRH     R5,[R0, #+14]
   \   0000007E   0xFA13 0xF585      UXTAH    R5,R3,R5
   \   00000082   0x42A5             CMP      R5,R4
   \   00000084   0xD222             BCS.N    ??SPI5_IRQHandler_4
    674          		     {
    675          	               Buffer2.pcm_buff[Buffer2.offset + idxSPI5DataBuf2++] = ((test>>4)|(stNipple<<12));
   \   00000086   0x89C4             LDRH     R4,[R0, #+14]
   \   00000088   0x1C65             ADDS     R5,R4,#+1
   \   0000008A   0x81C5             STRH     R5,[R0, #+14]
   \   0000008C   0x8A05             LDRH     R5,[R0, #+16]
   \   0000008E   0xFA13 0xF384      UXTAH    R3,R3,R4
   \   00000092   0xEB01 0x0343      ADD      R3,R1,R3, LSL #+1
   \   00000096   0x032D             LSLS     R5,R5,#+12
   \   00000098   0xEA45 0x1222      ORR      R2,R5,R2, ASR #+4
   \   0000009C   0xF644 0x0510      MOVW     R5,#+18448
   \   000000A0   0x52EA             STRH     R2,[R5, R3]
    676          				   Buffer2.pcm_buff[Buffer2.offset + idxSPI5DataBuf2++] = ((test>>4)|(stNipple<<12));
   \   000000A2   0x89C3             LDRH     R3,[R0, #+14]
   \   000000A4   0x1C5C             ADDS     R4,R3,#+1
   \   000000A6   0x81C4             STRH     R4,[R0, #+14]
   \   000000A8   0x6804             LDR      R4,[R0, #+0]
   \   000000AA   0xFA14 0xF383      UXTAH    R3,R4,R3
   \   000000AE   0xEB01 0x0143      ADD      R1,R1,R3, LSL #+1
   \   000000B2   0x526A             STRH     R2,[R5, R1]
   \   000000B4   0xE00A             B.N      ??SPI5_IRQHandler_4
    677          		     }
    678          
    679          		  }
    680          			  
    681                }
    682          	  else
    683          	  {
    684          	      //Buffer1.pcm_buff[idxSPI5DataBuf++] = 0;
    685          	      //BSP_LED_Off(LED1);  
    686                     stNipple = (test);
   \                     ??SPI5_IRQHandler_2: (+1)
   \   000000B6   0x8202             STRH     R2,[R0, #+16]
    687          		  Buffer3.pcm_buff[Buffer2.offset + idxSPI5DataBuf2] = stNipple;
   \   000000B8   0x6802             LDR      R2,[R0, #+0]
   \   000000BA   0x89C3             LDRH     R3,[R0, #+14]
   \   000000BC   0xFA12 0xF283      UXTAH    R2,R2,R3
   \   000000C0   0x8A03             LDRH     R3,[R0, #+16]
   \   000000C2   0xEB01 0x0142      ADD      R1,R1,R2, LSL #+1
   \   000000C6   0xF249 0x022C      MOVW     R2,#+36908
   \   000000CA   0x5253             STRH     R3,[R2, R1]
    688          	  }
    689          
    690          
    691          	  
    692             	}
    693              //else
    694              {
    695               // BSP_LED_Off(LED1);
    696              }
    697          
    698          
    699            // if (idxSPI5DataBuf >= AUDIO_IN_PCM_BUFFER_SIZE) idxSPI5DataBuf=0;
    700             //SPI5->DR = 3333;
    701              if(flgSTAIni==0)
   \                     ??SPI5_IRQHandler_4: (+1)
   \   000000CC   0x7A01             LDRB     R1,[R0, #+8]
   \   000000CE   0xB909             CBNZ.N   R1,??SPI5_IRQHandler_1
    702              {
    703                  flgSTAIni=1;
   \   000000D0   0x2101             MOVS     R1,#+1
   \   000000D2   0x7201             STRB     R1,[R0, #+8]
    704          		//__HAL_SPI_DISABLE(&hspi5);
    705                  						 
    706              }
    707                
    708            }
    709            
    710            
    711            
    712          
    713          }
   \                     ??SPI5_IRQHandler_1: (+1)
   \   000000D4   0xBD70             POP      {R4-R6,PC}       ;; return

   \                                 In section .bss, align 4
   \                     Buffer1:
   \   00000000                      DS8 18448
   \                     Buffer2:
   \   00004810                      DS8 18448
   \                     flgSTAIni:
   \   00009020                      DS8 1
   \   00009021                      DS8 1
   \   00009022                      DS8 1
   \   00009023                      DS8 1
   \                     idxSPI5DataBuf1:
   \   00009024                      DS8 2
   \                     idxSPI5DataBuf2:
   \   00009026                      DS8 2
   \   00009028                      DS8 2
   \   0000902A                      DS8 2
   \                     Buffer3:
   \   0000902C                      DS8 18448

   \                                 In section .bss, align 4
   \                     pI2CRx:
   \   00000000                      DS8 12

   \                                 In section .bss, align 2
   \                     cntRisingEXTI:
   \   00000000                      DS8 2

   \                                 In section .bss, align 4
   \                     aRxBuffer:
   \   00000000                      DS8 1024

   \                                 In section .bss, align 4
   \                     ??ticks:
   \   00000000                      DS8 4
    714          
    715          static uint16_t SPI_I2S_ReceiveData(SPI_TypeDef* SPIx)
    716          {
    717            /* Check the parameters */
    718            assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
    719            
    720            /* Return the data in the DR register */
    721            return SPIx->DR;
    722          }
    723          
    724          

   \                                 In section .text, align 2, keep-with-next
    725          void EXTI4_IRQHandler(void)
    726          {
   \                     EXTI4_IRQHandler: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    727              /* EXTI line interrupt detected */
    728            if(__HAL_GPIO_EXTI_GET_IT(GPIO_PIN_4) != RESET)
   \   00000002   0x....             LDR.N    R4,??DataTable10_25  ;; 0x40013c14
   \   00000004   0x6820             LDR      R0,[R4, #+0]
   \   00000006   0x06C0             LSLS     R0,R0,#+27
   \   00000008   0xD510             BPL.N    ??EXTI4_IRQHandler_0
    729            {
    730              
    731               if (cntRisingEXTI==10)
   \   0000000A   0x....             LDR.N    R5,??DataTable10_26
   \   0000000C   0x8828             LDRH     R0,[R5, #+0]
   \   0000000E   0x280A             CMP      R0,#+10
   \   00000010   0xD107             BNE.N    ??EXTI4_IRQHandler_1
    732               {
    733              	/*--------------Enable read PCM data --------------------*/
    734                  MX_SPI5_Init(); 
   \   00000012   0x.... 0x....      BL       MX_SPI5_Init
    735                  //__HAL_SPI_ENABLE_IT(&hspi5, (SPI_IT_RXNE| SPI_IT_ERR));
    736          		//__HAL_UNLOCK(&hspi5);
    737                  //__HAL_SPI_ENABLE(&hspi5);
    738          		cntRisingEXTI=0;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0x8028             STRH     R0,[R5, #+0]
    739          
    740          		/*Disable external interrupt */
    741          		HAL_NVIC_DisableIRQ((IRQn_Type)(EXTI4_IRQn));
   \   0000001A   0x200A             MOVS     R0,#+10
   \   0000001C   0x.... 0x....      BL       HAL_NVIC_DisableIRQ
   \   00000020   0xE002             B.N      ??EXTI4_IRQHandler_2
    742          		//HAL_GPIO_DeInit(GPIOB,GPIO_PIN_4);
    743               }
    744               else
    745               {
    746                   cntRisingEXTI++;
   \                     ??EXTI4_IRQHandler_1: (+1)
   \   00000022   0x8828             LDRH     R0,[R5, #+0]
   \   00000024   0x1C40             ADDS     R0,R0,#+1
   \   00000026   0x8028             STRH     R0,[R5, #+0]
    747          		 //__HAL_SPI_DISABLE(&hspi5);
    748               }
    749          	 __HAL_GPIO_EXTI_CLEAR_IT(GPIO_PIN_4);
   \                     ??EXTI4_IRQHandler_2: (+1)
   \   00000028   0x2010             MOVS     R0,#+16
   \   0000002A   0x6020             STR      R0,[R4, #+0]
    750          
    751            }
    752          }
   \                     ??EXTI4_IRQHandler_0: (+1)
   \   0000002C   0xBD31             POP      {R0,R4,R5,PC}    ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \   00000000   0xF3BF 0x8F4F      DSB      
   \   00000004   0xF3BF 0x8F6F      ISB      
   \   00000008   0x4770             BX       LR

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10:
   \   00000000   0xE000EF50         DC32     0xe000ef50

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_1:
   \   00000000   0xE000ED14         DC32     0xe000ed14

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_2:
   \   00000000   0x........         DC32     flg10ms

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_3:
   \   00000000   0x40023830         DC32     0x40023830

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_4:
   \   00000000   0x10110000         DC32     0x10110000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_5:
   \   00000000   0x40020400         DC32     0x40020400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_6:
   \   00000000   0x........         DC32     ??ticks

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_7:
   \   00000000   0x40023840         DC32     0x40023840

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_8:
   \   00000000   0x40007000         DC32     0x40007000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_9:
   \   00000000   0x........         DC32     hi2c1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_10:
   \   00000000   0x40005400         DC32     0x40005400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_11:
   \   00000000   0x00C0EFFF         DC32     0xc0efff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_12:
   \   00000000   0x40005800         DC32     0x40005800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_13:
   \   00000000   0x40021400         DC32     0x40021400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_14:
   \   00000000   0x........         DC32     huart6

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_15:
   \   00000000   0x40011400         DC32     0x40011400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_16:
   \   00000000   0x40020800         DC32     0x40020800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_17:
   \   00000000   0x40013400         DC32     0x40013400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_18:
   \   00000000   0x40021000         DC32     0x40021000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_19:
   \   00000000   0x40015000         DC32     0x40015000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_20:
   \   00000000   0x40015400         DC32     0x40015400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_21:
   \   00000000   0x40021800         DC32     0x40021800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_22:
   \   00000000   0x........         DC32     hspi5

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_23:
   \   00000000   0x........         DC32     Buffer1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_24:
   \   00000000   0x4001500C         DC32     0x4001500c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_25:
   \   00000000   0x40013C14         DC32     0x40013c14

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_26:
   \   00000000   0x........         DC32     cntRisingEXTI
    753          
    754          
    755          
    756          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   EXTI4_IRQHandler
        16   -> HAL_NVIC_DisableIRQ
        16   -> MX_SPI5_Init
      32   HAL_I2C_MspInit
        32   -> HAL_GPIO_Init
        32   -> HAL_NVIC_EnableIRQ
        32   -> HAL_NVIC_SetPriority
      32   HAL_SPI_MspInit
        32   -> HAL_GPIO_Init
        32   -> HAL_NVIC_EnableIRQ
        32   -> HAL_NVIC_SetPriority
      32   HAL_UART_MspInit
        32   -> HAL_GPIO_Init
        32   -> HAL_NVIC_EnableIRQ
        32   -> HAL_NVIC_SetPriority
       8   MX_I2C1_Init
         0   -> HAL_I2CEx_ConfigAnalogFilter
         8   -> HAL_I2C_Init
       8   MX_SPI5_Init
         8   -> HAL_SPI_Init
      16   SPI5_IRQHandler
     208   SystemClock_Config
       208   -> HAL_PWREx_EnableOverDrive
       208   -> HAL_RCCEx_PeriphCLKConfig
       208   -> HAL_RCC_ClockConfig
       208   -> HAL_RCC_GetHCLKFreq
       208   -> HAL_RCC_OscConfig
       208   -> HAL_SYSTICK_CLKSourceConfig
       208   -> HAL_SYSTICK_Config
       0   Toggle_Leds
       0   UART6_Init
         0   -> HAL_UART_Init
      24   main
        24   -> BSP_LED_Init
        24   -> BSP_LED_Toggle
        24   -> HAL_GPIO_Init
        24   -> HAL_Init
        24   -> HAL_NVIC_EnableIRQ
        24   -> HAL_NVIC_SetPriority
        24   -> SystemClock_Config
        24   -> WavePlayerInit


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable10
       4  ??DataTable10_1
       4  ??DataTable10_10
       4  ??DataTable10_11
       4  ??DataTable10_12
       4  ??DataTable10_13
       4  ??DataTable10_14
       4  ??DataTable10_15
       4  ??DataTable10_16
       4  ??DataTable10_17
       4  ??DataTable10_18
       4  ??DataTable10_19
       4  ??DataTable10_2
       4  ??DataTable10_20
       4  ??DataTable10_21
       4  ??DataTable10_22
       4  ??DataTable10_23
       4  ??DataTable10_24
       4  ??DataTable10_25
       4  ??DataTable10_26
       4  ??DataTable10_3
       4  ??DataTable10_4
       4  ??DataTable10_5
       4  ??DataTable10_6
       4  ??DataTable10_7
       4  ??DataTable10_8
       4  ??DataTable10_9
      10  ?Subroutine0
      20  ?Subroutine1
      20  ?Subroutine2
   55356  Buffer1
          Buffer2
          flgSTAIni
          stLR
          stOder
          idxSPI5DataBuf1
          idxSPI5DataBuf2
          stNipple
          Buffer3
      46  EXTI4_IRQHandler
     124  HAL_I2C_MspInit
     176  HAL_SPI_MspInit
     100  HAL_UART_MspInit
      54  MX_I2C1_Init
      80  MX_SPI5_Init
     214  SPI5_IRQHandler
     188  SystemClock_Config
      18  Toggle_Leds
      38  UART6_Init
    1024  aRxBuffer
       1  appli_state
       2  cntRisingEXTI
      24  flg10ms
          GPIO_INS
     696  hUSBHost
     100  hspi5
     112  huart6
     222  main
      20  pI2CData
      12  pI2CRx
       4  ticks

 
 57 331 bytes in section .bss
     20 bytes in section .data
  1 418 bytes in section .text
 
  1 418 bytes of CODE memory
 57 351 bytes of DATA memory

Errors: none
Warnings: none
