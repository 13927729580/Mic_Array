###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.2.10312/W32 for ARM       20/Feb/2016  22:27:40
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_sram.c
#    Command line =  
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_sram.c
#        -D USE_HAL_DRIVER -D STM32F746xx -D USE_STM32746G_DISCO -D
#        USE_IOEXPANDER -D USE_USB_FS -lC
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
#        -lA
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
#        -o
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M7 -e --fpu=VFPv5_sp --dlib_config "D:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.3\arm\INC\c\DLib_Config_Full.h"
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\Inc\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\CMSIS\Device\ST\STM32F7xx\Include\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\STM32F7xx_HAL_Driver\Inc\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\STM32746G-Discovery\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\Components\Common\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Log\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Fonts\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\CPU\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_Device_Library\Core\Inc\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Core\Inc\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Class\MSC\Inc\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\drivers\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_Audio\Addons\PDM\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_Device_Library\Class\AUDIO\Inc\
#        -On --use_c++_inline --require_prototypes -I "D:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.3\arm\CMSIS\Include\" -D
#        ARM_MATH_CM7
#    List file    =  
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List\stm32f7xx_hal_sram.lst
#    Object file  =  
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj\stm32f7xx_hal_sram.o
#
###############################################################################

H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_sram.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f7xx_hal_sram.c
      4            * @author  MCD Application Team
      5            * @version V1.0.1
      6            * @date    25-June-2015
      7            * @brief   SRAM HAL module driver.
      8            *          This file provides a generic firmware to drive SRAM memories  
      9            *          mounted as external device.
     10            *         
     11            @verbatim
     12            ==============================================================================
     13                                    ##### How to use this driver #####
     14            ==============================================================================  
     15            [..]
     16              This driver is a generic layered driver which contains a set of APIs used to 
     17              control SRAM memories. It uses the FMC layer functions to interface 
     18              with SRAM devices.  
     19              The following sequence should be followed to configure the FMC to interface
     20              with SRAM/PSRAM memories: 
     21                
     22             (#) Declare a SRAM_HandleTypeDef handle structure, for example:
     23                    SRAM_HandleTypeDef  hsram; and: 
     24                    
     25                 (++) Fill the SRAM_HandleTypeDef handle "Init" field with the allowed 
     26                      values of the structure member.
     27                      
     28                 (++) Fill the SRAM_HandleTypeDef handle "Instance" field with a predefined 
     29                      base register instance for NOR or SRAM device 
     30                                   
     31                 (++) Fill the SRAM_HandleTypeDef handle "Extended" field with a predefined
     32                      base register instance for NOR or SRAM extended mode 
     33                       
     34             (#) Declare two FMC_NORSRAM_TimingTypeDef structures, for both normal and extended 
     35                 mode timings; for example:
     36                    FMC_NORSRAM_TimingTypeDef  Timing and FMC_NORSRAM_TimingTypeDef  ExTiming;
     37                and fill its fields with the allowed values of the structure member.
     38                
     39             (#) Initialize the SRAM Controller by calling the function HAL_SRAM_Init(). This function
     40                 performs the following sequence:
     41                    
     42                 (##) MSP hardware layer configuration using the function HAL_SRAM_MspInit()
     43                 (##) Control register configuration using the FMC NORSRAM interface function 
     44                      FMC_NORSRAM_Init()
     45                 (##) Timing register configuration using the FMC NORSRAM interface function 
     46                      FMC_NORSRAM_Timing_Init()
     47                 (##) Extended mode Timing register configuration using the FMC NORSRAM interface function 
     48                      FMC_NORSRAM_Extended_Timing_Init()
     49                 (##) Enable the SRAM device using the macro __FMC_NORSRAM_ENABLE()    
     50          
     51             (#) At this stage you can perform read/write accesses from/to the memory connected 
     52                 to the NOR/SRAM Bank. You can perform either polling or DMA transfer using the
     53                 following APIs:
     54                 (++) HAL_SRAM_Read()/HAL_SRAM_Write() for polling read/write access
     55                 (++) HAL_SRAM_Read_DMA()/HAL_SRAM_Write_DMA() for DMA read/write transfer
     56                 
     57             (#) You can also control the SRAM device by calling the control APIs HAL_SRAM_WriteOperation_Enable()/
     58                 HAL_SRAM_WriteOperation_Disable() to respectively enable/disable the SRAM write operation  
     59                 
     60             (#) You can continuously monitor the SRAM device HAL state by calling the function
     61                 HAL_SRAM_GetState()              
     62                                       
     63            @endverbatim
     64            ******************************************************************************
     65            * @attention
     66            *
     67            * <h2><center>&copy; COPYRIGHT(c) 2015 STMicroelectronics</center></h2>
     68            *
     69            * Redistribution and use in source and binary forms, with or without modification,
     70            * are permitted provided that the following conditions are met:
     71            *   1. Redistributions of source code must retain the above copyright notice,
     72            *      this list of conditions and the following disclaimer.
     73            *   2. Redistributions in binary form must reproduce the above copyright notice,
     74            *      this list of conditions and the following disclaimer in the documentation
     75            *      and/or other materials provided with the distribution.
     76            *   3. Neither the name of STMicroelectronics nor the names of its contributors
     77            *      may be used to endorse or promote products derived from this software
     78            *      without specific prior written permission.
     79            *
     80            * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
     81            * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     82            * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     83            * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
     84            * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
     85            * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
     86            * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
     87            * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
     88            * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
     89            * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     90            *
     91            ******************************************************************************
     92            */ 
     93          
     94          /* Includes ------------------------------------------------------------------*/
     95          #include "stm32f7xx_hal.h"
     96          
     97          /** @addtogroup STM32F7xx_HAL_Driver
     98            * @{
     99            */
    100          
    101          /** @defgroup SRAM SRAM 
    102            * @brief SRAM driver modules
    103            * @{
    104            */
    105          #ifdef HAL_SRAM_MODULE_ENABLED
    106          /* Private typedef -----------------------------------------------------------*/
    107          /* Private define ------------------------------------------------------------*/
    108          /* Private macro -------------------------------------------------------------*/    
    109          /* Private variables ---------------------------------------------------------*/
    110          /* Private function prototypes -----------------------------------------------*/
    111          /* Exported functions --------------------------------------------------------*/
    112          
    113          /** @defgroup SRAM_Exported_Functions SRAM Exported Functions
    114            * @{
    115            */
    116          
    117          /** @defgroup SRAM_Exported_Functions_Group1 Initialization and de-initialization functions
    118            * @brief    Initialization and Configuration functions.
    119            *
    120            @verbatim    
    121            ==============================================================================
    122                     ##### SRAM Initialization and de_initialization functions #####
    123            ==============================================================================
    124              [..]  This section provides functions allowing to initialize/de-initialize
    125                    the SRAM memory
    126            
    127          @endverbatim
    128            * @{
    129            */
    130          
    131          /**
    132            * @brief  Performs the SRAM device initialization sequence
    133            * @param  hsram: pointer to a SRAM_HandleTypeDef structure that contains
    134            *                the configuration information for SRAM module.
    135            * @param  Timing: Pointer to SRAM control timing structure 
    136            * @param  ExtTiming: Pointer to SRAM extended mode timing structure  
    137            * @retval HAL status
    138            */

   \                                 In section .text, align 2, keep-with-next
    139          HAL_StatusTypeDef HAL_SRAM_Init(SRAM_HandleTypeDef *hsram, FMC_NORSRAM_TimingTypeDef *Timing, FMC_NORSRAM_TimingTypeDef *ExtTiming)
    140          { 
   \                     HAL_SRAM_Init: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    141            /* Check the SRAM handle parameter */
    142            if(hsram == NULL)
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD101             BNE.N    ??HAL_SRAM_Init_0
    143            {
    144               return HAL_ERROR;
   \   0000000C   0x2001             MOVS     R0,#+1
   \   0000000E   0xE024             B.N      ??HAL_SRAM_Init_1
    145            }
    146            
    147            if(hsram->State == HAL_SRAM_STATE_RESET)
   \                     ??HAL_SRAM_Init_0: (+1)
   \   00000010   0xF894 0x0045      LDRB     R0,[R4, #+69]
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD105             BNE.N    ??HAL_SRAM_Init_2
    148            {  
    149              /* Allocate lock resource and initialize it */
    150              hsram->Lock = HAL_UNLOCKED;
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0xF884 0x0044      STRB     R0,[R4, #+68]
    151              /* Initialize the low level hardware (MSP) */
    152              HAL_SRAM_MspInit(hsram);
   \   0000001E   0x0020             MOVS     R0,R4
   \   00000020   0x.... 0x....      BL       HAL_SRAM_MspInit
    153            }
    154            
    155            /* Initialize SRAM control Interface */
    156            FMC_NORSRAM_Init(hsram->Instance, &(hsram->Init));
   \                     ??HAL_SRAM_Init_2: (+1)
   \   00000024   0xF114 0x0108      ADDS     R1,R4,#+8
   \   00000028   0x6820             LDR      R0,[R4, #+0]
   \   0000002A   0x.... 0x....      BL       FMC_NORSRAM_Init
    157          
    158            /* Initialize SRAM timing Interface */
    159            FMC_NORSRAM_Timing_Init(hsram->Instance, Timing, hsram->Init.NSBank); 
   \   0000002E   0x68A2             LDR      R2,[R4, #+8]
   \   00000030   0x0029             MOVS     R1,R5
   \   00000032   0x6820             LDR      R0,[R4, #+0]
   \   00000034   0x.... 0x....      BL       FMC_NORSRAM_Timing_Init
    160          
    161            /* Initialize SRAM extended mode timing Interface */
    162            FMC_NORSRAM_Extended_Timing_Init(hsram->Extended, ExtTiming, hsram->Init.NSBank,  hsram->Init.ExtendedMode);  
   \   00000038   0x6AE3             LDR      R3,[R4, #+44]
   \   0000003A   0x68A2             LDR      R2,[R4, #+8]
   \   0000003C   0x0031             MOVS     R1,R6
   \   0000003E   0x6860             LDR      R0,[R4, #+4]
   \   00000040   0x.... 0x....      BL       FMC_NORSRAM_Extended_Timing_Init
    163            
    164            /* Enable the NORSRAM device */
    165            __FMC_NORSRAM_ENABLE(hsram->Instance, hsram->Init.NSBank); 
   \   00000044   0x6820             LDR      R0,[R4, #+0]
   \   00000046   0x68A1             LDR      R1,[R4, #+8]
   \   00000048   0xF850 0x0021      LDR      R0,[R0, R1, LSL #+2]
   \   0000004C   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000050   0x6821             LDR      R1,[R4, #+0]
   \   00000052   0x68A2             LDR      R2,[R4, #+8]
   \   00000054   0xF841 0x0022      STR      R0,[R1, R2, LSL #+2]
    166            
    167            return HAL_OK;
   \   00000058   0x2000             MOVS     R0,#+0
   \                     ??HAL_SRAM_Init_1: (+1)
   \   0000005A   0xBD70             POP      {R4-R6,PC}       ;; return
    168          }
    169          
    170          /**
    171            * @brief  Performs the SRAM device De-initialization sequence.
    172            * @param  hsram: pointer to a SRAM_HandleTypeDef structure that contains
    173            *                the configuration information for SRAM module.
    174            * @retval HAL status
    175            */

   \                                 In section .text, align 2, keep-with-next
    176          HAL_StatusTypeDef  HAL_SRAM_DeInit(SRAM_HandleTypeDef *hsram)
    177          { 
   \                     HAL_SRAM_DeInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    178            /* De-Initialize the low level hardware (MSP) */
    179            HAL_SRAM_MspDeInit(hsram);
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0x.... 0x....      BL       HAL_SRAM_MspDeInit
    180             
    181            /* Configure the SRAM registers with their reset values */
    182            FMC_NORSRAM_DeInit(hsram->Instance, hsram->Extended, hsram->Init.NSBank);
   \   0000000A   0x68A2             LDR      R2,[R4, #+8]
   \   0000000C   0x6861             LDR      R1,[R4, #+4]
   \   0000000E   0x6820             LDR      R0,[R4, #+0]
   \   00000010   0x.... 0x....      BL       FMC_NORSRAM_DeInit
    183          
    184            hsram->State = HAL_SRAM_STATE_RESET;
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0xF884 0x0045      STRB     R0,[R4, #+69]
    185            
    186            /* Release Lock */
    187            __HAL_UNLOCK(hsram);
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0xF884 0x0044      STRB     R0,[R4, #+68]
    188          
    189            return HAL_OK;
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0xBD10             POP      {R4,PC}          ;; return
    190          }
    191          
    192          /**
    193            * @brief  SRAM MSP Init.
    194            * @param  hsram: pointer to a SRAM_HandleTypeDef structure that contains
    195            *                the configuration information for SRAM module.
    196            * @retval None
    197            */

   \                                 In section .text, align 2, keep-with-next
    198          __weak void HAL_SRAM_MspInit(SRAM_HandleTypeDef *hsram)
    199          {
    200            /* NOTE : This function Should not be modified, when the callback is needed,
    201                      the HAL_SRAM_MspInit could be implemented in the user file
    202             */ 
    203          }
   \                     HAL_SRAM_MspInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    204          
    205          /**
    206            * @brief  SRAM MSP DeInit.
    207            * @param  hsram: pointer to a SRAM_HandleTypeDef structure that contains
    208            *                the configuration information for SRAM module.
    209            * @retval None
    210            */

   \                                 In section .text, align 2, keep-with-next
    211          __weak void HAL_SRAM_MspDeInit(SRAM_HandleTypeDef *hsram)
    212          {
    213            /* NOTE : This function Should not be modified, when the callback is needed,
    214                      the HAL_SRAM_MspDeInit could be implemented in the user file
    215             */ 
    216          }
   \                     HAL_SRAM_MspDeInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    217          
    218          /**
    219            * @brief  DMA transfer complete callback.
    220            * @param  hdma: pointer to a SRAM_HandleTypeDef structure that contains
    221            *                the configuration information for SRAM module.
    222            * @retval None
    223            */

   \                                 In section .text, align 2, keep-with-next
    224          __weak void HAL_SRAM_DMA_XferCpltCallback(DMA_HandleTypeDef *hdma)
    225          {
    226            /* NOTE : This function Should not be modified, when the callback is needed,
    227                      the HAL_SRAM_DMA_XferCpltCallback could be implemented in the user file
    228             */ 
    229          }
   \                     HAL_SRAM_DMA_XferCpltCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    230          
    231          /**
    232            * @brief  DMA transfer complete error callback.
    233            * @param  hdma: pointer to a SRAM_HandleTypeDef structure that contains
    234            *                the configuration information for SRAM module.
    235            * @retval None
    236            */

   \                                 In section .text, align 2, keep-with-next
    237          __weak void HAL_SRAM_DMA_XferErrorCallback(DMA_HandleTypeDef *hdma)
    238          {
    239            /* NOTE : This function Should not be modified, when the callback is needed,
    240                      the HAL_SRAM_DMA_XferErrorCallback could be implemented in the user file
    241             */ 
    242          }
   \                     HAL_SRAM_DMA_XferErrorCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    243          
    244          /**
    245            * @}
    246            */
    247          
    248          /** @defgroup SRAM_Exported_Functions_Group2 Input Output and memory control functions 
    249            * @brief    Input Output and memory control functions 
    250            *
    251            @verbatim    
    252            ==============================================================================
    253                            ##### SRAM Input and Output functions #####
    254            ==============================================================================
    255            [..]  
    256              This section provides functions allowing to use and control the SRAM memory
    257            
    258          @endverbatim
    259            * @{
    260            */
    261          
    262          /**
    263            * @brief  Reads 8-bit buffer from SRAM memory. 
    264            * @param  hsram: pointer to a SRAM_HandleTypeDef structure that contains
    265            *                the configuration information for SRAM module.
    266            * @param  pAddress: Pointer to read start address
    267            * @param  pDstBuffer: Pointer to destination buffer  
    268            * @param  BufferSize: Size of the buffer to read from memory
    269            * @retval HAL status
    270            */

   \                                 In section .text, align 2, keep-with-next
    271          HAL_StatusTypeDef HAL_SRAM_Read_8b(SRAM_HandleTypeDef *hsram, uint32_t *pAddress, uint8_t *pDstBuffer, uint32_t BufferSize)
    272          {
   \                     HAL_SRAM_Read_8b: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
   \   00000002   0x0004             MOVS     R4,R0
    273            __IO uint8_t * psramaddress = (uint8_t *)pAddress;
   \   00000004   0x000D             MOVS     R5,R1
    274            
    275            /* Process Locked */
    276            __HAL_LOCK(hsram);
   \   00000006   0xF894 0x0044      LDRB     R0,[R4, #+68]
   \   0000000A   0x2801             CMP      R0,#+1
   \   0000000C   0xD101             BNE.N    ??HAL_SRAM_Read_8b_0
   \   0000000E   0x2002             MOVS     R0,#+2
   \   00000010   0xE014             B.N      ??HAL_SRAM_Read_8b_1
   \                     ??HAL_SRAM_Read_8b_0: (+1)
   \   00000012   0x2001             MOVS     R0,#+1
   \   00000014   0xF884 0x0044      STRB     R0,[R4, #+68]
    277            
    278            /* Update the SRAM controller state */
    279            hsram->State = HAL_SRAM_STATE_BUSY;  
   \   00000018   0x2002             MOVS     R0,#+2
   \   0000001A   0xF884 0x0045      STRB     R0,[R4, #+69]
    280            
    281            /* Read data from memory */
    282            for(; BufferSize != 0; BufferSize--)
   \                     ??HAL_SRAM_Read_8b_2: (+1)
   \   0000001E   0x2B00             CMP      R3,#+0
   \   00000020   0xD005             BEQ.N    ??HAL_SRAM_Read_8b_3
    283            {
    284              *pDstBuffer = *(__IO uint8_t *)psramaddress;
   \   00000022   0x7828             LDRB     R0,[R5, #+0]
   \   00000024   0x7010             STRB     R0,[R2, #+0]
    285              pDstBuffer++;
   \   00000026   0x1C52             ADDS     R2,R2,#+1
    286              psramaddress++;
   \   00000028   0x1C6D             ADDS     R5,R5,#+1
    287            }
   \   0000002A   0x1E5B             SUBS     R3,R3,#+1
   \   0000002C   0xE7F7             B.N      ??HAL_SRAM_Read_8b_2
    288            
    289            /* Update the SRAM controller state */
    290            hsram->State = HAL_SRAM_STATE_READY;    
   \                     ??HAL_SRAM_Read_8b_3: (+1)
   \   0000002E   0x2001             MOVS     R0,#+1
   \   00000030   0xF884 0x0045      STRB     R0,[R4, #+69]
    291          
    292            /* Process unlocked */
    293            __HAL_UNLOCK(hsram); 
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0xF884 0x0044      STRB     R0,[R4, #+68]
    294              
    295            return HAL_OK;   
   \   0000003A   0x2000             MOVS     R0,#+0
   \                     ??HAL_SRAM_Read_8b_1: (+1)
   \   0000003C   0xBC30             POP      {R4,R5}
   \   0000003E   0x4770             BX       LR               ;; return
    296          }
    297          
    298          /**
    299            * @brief  Writes 8-bit buffer to SRAM memory. 
    300            * @param  hsram: pointer to a SRAM_HandleTypeDef structure that contains
    301            *                the configuration information for SRAM module.
    302            * @param  pAddress: Pointer to write start address
    303            * @param  pSrcBuffer: Pointer to source buffer to write  
    304            * @param  BufferSize: Size of the buffer to write to memory
    305            * @retval HAL status
    306            */

   \                                 In section .text, align 2, keep-with-next
    307          HAL_StatusTypeDef HAL_SRAM_Write_8b(SRAM_HandleTypeDef *hsram, uint32_t *pAddress, uint8_t *pSrcBuffer, uint32_t BufferSize)
    308          {
   \                     HAL_SRAM_Write_8b: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
   \   00000002   0x0004             MOVS     R4,R0
    309            __IO uint8_t * psramaddress = (uint8_t *)pAddress;
   \   00000004   0x000D             MOVS     R5,R1
    310            
    311            /* Check the SRAM controller state */
    312            if(hsram->State == HAL_SRAM_STATE_PROTECTED)
   \   00000006   0xF894 0x0045      LDRB     R0,[R4, #+69]
   \   0000000A   0x2804             CMP      R0,#+4
   \   0000000C   0xD101             BNE.N    ??HAL_SRAM_Write_8b_0
    313            {
    314              return  HAL_ERROR; 
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0xE01A             B.N      ??HAL_SRAM_Write_8b_1
    315            }
    316            
    317            /* Process Locked */
    318            __HAL_LOCK(hsram);
   \                     ??HAL_SRAM_Write_8b_0: (+1)
   \   00000012   0xF894 0x0044      LDRB     R0,[R4, #+68]
   \   00000016   0x2801             CMP      R0,#+1
   \   00000018   0xD101             BNE.N    ??HAL_SRAM_Write_8b_2
   \   0000001A   0x2002             MOVS     R0,#+2
   \   0000001C   0xE014             B.N      ??HAL_SRAM_Write_8b_1
   \                     ??HAL_SRAM_Write_8b_2: (+1)
   \   0000001E   0x2001             MOVS     R0,#+1
   \   00000020   0xF884 0x0044      STRB     R0,[R4, #+68]
    319            
    320            /* Update the SRAM controller state */
    321            hsram->State = HAL_SRAM_STATE_BUSY; 
   \   00000024   0x2002             MOVS     R0,#+2
   \   00000026   0xF884 0x0045      STRB     R0,[R4, #+69]
    322          
    323            /* Write data to memory */
    324            for(; BufferSize != 0; BufferSize--)
   \                     ??HAL_SRAM_Write_8b_3: (+1)
   \   0000002A   0x2B00             CMP      R3,#+0
   \   0000002C   0xD005             BEQ.N    ??HAL_SRAM_Write_8b_4
    325            {
    326              *(__IO uint8_t *)psramaddress = *pSrcBuffer; 
   \   0000002E   0x7810             LDRB     R0,[R2, #+0]
   \   00000030   0x7028             STRB     R0,[R5, #+0]
    327              pSrcBuffer++;
   \   00000032   0x1C52             ADDS     R2,R2,#+1
    328              psramaddress++;    
   \   00000034   0x1C6D             ADDS     R5,R5,#+1
    329            }    
   \   00000036   0x1E5B             SUBS     R3,R3,#+1
   \   00000038   0xE7F7             B.N      ??HAL_SRAM_Write_8b_3
    330          
    331            /* Update the SRAM controller state */
    332            hsram->State = HAL_SRAM_STATE_READY; 
   \                     ??HAL_SRAM_Write_8b_4: (+1)
   \   0000003A   0x2001             MOVS     R0,#+1
   \   0000003C   0xF884 0x0045      STRB     R0,[R4, #+69]
    333            
    334            /* Process unlocked */
    335            __HAL_UNLOCK(hsram);
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0xF884 0x0044      STRB     R0,[R4, #+68]
    336              
    337            return HAL_OK;   
   \   00000046   0x2000             MOVS     R0,#+0
   \                     ??HAL_SRAM_Write_8b_1: (+1)
   \   00000048   0xBC30             POP      {R4,R5}
   \   0000004A   0x4770             BX       LR               ;; return
    338          }
    339          
    340          /**
    341            * @brief  Reads 16-bit buffer from SRAM memory. 
    342            * @param  hsram: pointer to a SRAM_HandleTypeDef structure that contains
    343            *                the configuration information for SRAM module.
    344            * @param  pAddress: Pointer to read start address
    345            * @param  pDstBuffer: Pointer to destination buffer  
    346            * @param  BufferSize: Size of the buffer to read from memory
    347            * @retval HAL status
    348            */

   \                                 In section .text, align 2, keep-with-next
    349          HAL_StatusTypeDef HAL_SRAM_Read_16b(SRAM_HandleTypeDef *hsram, uint32_t *pAddress, uint16_t *pDstBuffer, uint32_t BufferSize)
    350          {
   \                     HAL_SRAM_Read_16b: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
   \   00000002   0x0004             MOVS     R4,R0
    351            __IO uint16_t * psramaddress = (uint16_t *)pAddress;
   \   00000004   0x000D             MOVS     R5,R1
    352            
    353            /* Process Locked */
    354            __HAL_LOCK(hsram);
   \   00000006   0xF894 0x0044      LDRB     R0,[R4, #+68]
   \   0000000A   0x2801             CMP      R0,#+1
   \   0000000C   0xD101             BNE.N    ??HAL_SRAM_Read_16b_0
   \   0000000E   0x2002             MOVS     R0,#+2
   \   00000010   0xE014             B.N      ??HAL_SRAM_Read_16b_1
   \                     ??HAL_SRAM_Read_16b_0: (+1)
   \   00000012   0x2001             MOVS     R0,#+1
   \   00000014   0xF884 0x0044      STRB     R0,[R4, #+68]
    355            
    356            /* Update the SRAM controller state */
    357            hsram->State = HAL_SRAM_STATE_BUSY;  
   \   00000018   0x2002             MOVS     R0,#+2
   \   0000001A   0xF884 0x0045      STRB     R0,[R4, #+69]
    358            
    359            /* Read data from memory */
    360            for(; BufferSize != 0; BufferSize--)
   \                     ??HAL_SRAM_Read_16b_2: (+1)
   \   0000001E   0x2B00             CMP      R3,#+0
   \   00000020   0xD005             BEQ.N    ??HAL_SRAM_Read_16b_3
    361            {
    362              *pDstBuffer = *(__IO uint16_t *)psramaddress;
   \   00000022   0x8828             LDRH     R0,[R5, #+0]
   \   00000024   0x8010             STRH     R0,[R2, #+0]
    363              pDstBuffer++;
   \   00000026   0x1C92             ADDS     R2,R2,#+2
    364              psramaddress++;
   \   00000028   0x1CAD             ADDS     R5,R5,#+2
    365            }
   \   0000002A   0x1E5B             SUBS     R3,R3,#+1
   \   0000002C   0xE7F7             B.N      ??HAL_SRAM_Read_16b_2
    366            
    367            /* Update the SRAM controller state */
    368            hsram->State = HAL_SRAM_STATE_READY;    
   \                     ??HAL_SRAM_Read_16b_3: (+1)
   \   0000002E   0x2001             MOVS     R0,#+1
   \   00000030   0xF884 0x0045      STRB     R0,[R4, #+69]
    369          
    370            /* Process unlocked */
    371            __HAL_UNLOCK(hsram); 
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0xF884 0x0044      STRB     R0,[R4, #+68]
    372              
    373            return HAL_OK;  
   \   0000003A   0x2000             MOVS     R0,#+0
   \                     ??HAL_SRAM_Read_16b_1: (+1)
   \   0000003C   0xBC30             POP      {R4,R5}
   \   0000003E   0x4770             BX       LR               ;; return
    374          }
    375          
    376          /**
    377            * @brief  Writes 16-bit buffer to SRAM memory. 
    378            * @param  hsram: pointer to a SRAM_HandleTypeDef structure that contains
    379            *                the configuration information for SRAM module.
    380            * @param  pAddress: Pointer to write start address
    381            * @param  pSrcBuffer: Pointer to source buffer to write  
    382            * @param  BufferSize: Size of the buffer to write to memory
    383            * @retval HAL status
    384            */

   \                                 In section .text, align 2, keep-with-next
    385          HAL_StatusTypeDef HAL_SRAM_Write_16b(SRAM_HandleTypeDef *hsram, uint32_t *pAddress, uint16_t *pSrcBuffer, uint32_t BufferSize)
    386          {
   \                     HAL_SRAM_Write_16b: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
   \   00000002   0x0004             MOVS     R4,R0
    387            __IO uint16_t * psramaddress = (uint16_t *)pAddress; 
   \   00000004   0x000D             MOVS     R5,R1
    388            
    389            /* Check the SRAM controller state */
    390            if(hsram->State == HAL_SRAM_STATE_PROTECTED)
   \   00000006   0xF894 0x0045      LDRB     R0,[R4, #+69]
   \   0000000A   0x2804             CMP      R0,#+4
   \   0000000C   0xD101             BNE.N    ??HAL_SRAM_Write_16b_0
    391            {
    392              return  HAL_ERROR; 
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0xE01A             B.N      ??HAL_SRAM_Write_16b_1
    393            }
    394            
    395            /* Process Locked */
    396            __HAL_LOCK(hsram);
   \                     ??HAL_SRAM_Write_16b_0: (+1)
   \   00000012   0xF894 0x0044      LDRB     R0,[R4, #+68]
   \   00000016   0x2801             CMP      R0,#+1
   \   00000018   0xD101             BNE.N    ??HAL_SRAM_Write_16b_2
   \   0000001A   0x2002             MOVS     R0,#+2
   \   0000001C   0xE014             B.N      ??HAL_SRAM_Write_16b_1
   \                     ??HAL_SRAM_Write_16b_2: (+1)
   \   0000001E   0x2001             MOVS     R0,#+1
   \   00000020   0xF884 0x0044      STRB     R0,[R4, #+68]
    397            
    398            /* Update the SRAM controller state */
    399            hsram->State = HAL_SRAM_STATE_BUSY; 
   \   00000024   0x2002             MOVS     R0,#+2
   \   00000026   0xF884 0x0045      STRB     R0,[R4, #+69]
    400          
    401            /* Write data to memory */
    402            for(; BufferSize != 0; BufferSize--)
   \                     ??HAL_SRAM_Write_16b_3: (+1)
   \   0000002A   0x2B00             CMP      R3,#+0
   \   0000002C   0xD005             BEQ.N    ??HAL_SRAM_Write_16b_4
    403            {
    404              *(__IO uint16_t *)psramaddress = *pSrcBuffer; 
   \   0000002E   0x8810             LDRH     R0,[R2, #+0]
   \   00000030   0x8028             STRH     R0,[R5, #+0]
    405              pSrcBuffer++;
   \   00000032   0x1C92             ADDS     R2,R2,#+2
    406              psramaddress++;    
   \   00000034   0x1CAD             ADDS     R5,R5,#+2
    407            }    
   \   00000036   0x1E5B             SUBS     R3,R3,#+1
   \   00000038   0xE7F7             B.N      ??HAL_SRAM_Write_16b_3
    408          
    409            /* Update the SRAM controller state */
    410            hsram->State = HAL_SRAM_STATE_READY; 
   \                     ??HAL_SRAM_Write_16b_4: (+1)
   \   0000003A   0x2001             MOVS     R0,#+1
   \   0000003C   0xF884 0x0045      STRB     R0,[R4, #+69]
    411            
    412            /* Process unlocked */
    413            __HAL_UNLOCK(hsram);
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0xF884 0x0044      STRB     R0,[R4, #+68]
    414              
    415            return HAL_OK;  
   \   00000046   0x2000             MOVS     R0,#+0
   \                     ??HAL_SRAM_Write_16b_1: (+1)
   \   00000048   0xBC30             POP      {R4,R5}
   \   0000004A   0x4770             BX       LR               ;; return
    416          }
    417          
    418          /**
    419            * @brief  Reads 32-bit buffer from SRAM memory. 
    420            * @param  hsram: pointer to a SRAM_HandleTypeDef structure that contains
    421            *                the configuration information for SRAM module.
    422            * @param  pAddress: Pointer to read start address
    423            * @param  pDstBuffer: Pointer to destination buffer  
    424            * @param  BufferSize: Size of the buffer to read from memory
    425            * @retval HAL status
    426            */

   \                                 In section .text, align 2, keep-with-next
    427          HAL_StatusTypeDef HAL_SRAM_Read_32b(SRAM_HandleTypeDef *hsram, uint32_t *pAddress, uint32_t *pDstBuffer, uint32_t BufferSize)
    428          {
   \                     HAL_SRAM_Read_32b: (+1)
   \   00000000   0xB410             PUSH     {R4}
   \   00000002   0x0004             MOVS     R4,R0
    429            /* Process Locked */
    430            __HAL_LOCK(hsram);
   \   00000004   0xF894 0x0044      LDRB     R0,[R4, #+68]
   \   00000008   0x2801             CMP      R0,#+1
   \   0000000A   0xD101             BNE.N    ??HAL_SRAM_Read_32b_0
   \   0000000C   0x2002             MOVS     R0,#+2
   \   0000000E   0xE014             B.N      ??HAL_SRAM_Read_32b_1
   \                     ??HAL_SRAM_Read_32b_0: (+1)
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0xF884 0x0044      STRB     R0,[R4, #+68]
    431            
    432            /* Update the SRAM controller state */
    433            hsram->State = HAL_SRAM_STATE_BUSY;  
   \   00000016   0x2002             MOVS     R0,#+2
   \   00000018   0xF884 0x0045      STRB     R0,[R4, #+69]
    434            
    435            /* Read data from memory */
    436            for(; BufferSize != 0; BufferSize--)
   \                     ??HAL_SRAM_Read_32b_2: (+1)
   \   0000001C   0x2B00             CMP      R3,#+0
   \   0000001E   0xD005             BEQ.N    ??HAL_SRAM_Read_32b_3
    437            {
    438              *pDstBuffer = *(__IO uint32_t *)pAddress;
   \   00000020   0x6808             LDR      R0,[R1, #+0]
   \   00000022   0x6010             STR      R0,[R2, #+0]
    439              pDstBuffer++;
   \   00000024   0x1D12             ADDS     R2,R2,#+4
    440              pAddress++;
   \   00000026   0x1D09             ADDS     R1,R1,#+4
    441            }
   \   00000028   0x1E5B             SUBS     R3,R3,#+1
   \   0000002A   0xE7F7             B.N      ??HAL_SRAM_Read_32b_2
    442            
    443            /* Update the SRAM controller state */
    444            hsram->State = HAL_SRAM_STATE_READY;    
   \                     ??HAL_SRAM_Read_32b_3: (+1)
   \   0000002C   0x2001             MOVS     R0,#+1
   \   0000002E   0xF884 0x0045      STRB     R0,[R4, #+69]
    445          
    446            /* Process unlocked */
    447            __HAL_UNLOCK(hsram); 
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0xF884 0x0044      STRB     R0,[R4, #+68]
    448              
    449            return HAL_OK;  
   \   00000038   0x2000             MOVS     R0,#+0
   \                     ??HAL_SRAM_Read_32b_1: (+1)
   \   0000003A   0xBC10             POP      {R4}
   \   0000003C   0x4770             BX       LR               ;; return
    450          }
    451          
    452          /**
    453            * @brief  Writes 32-bit buffer to SRAM memory. 
    454            * @param  hsram: pointer to a SRAM_HandleTypeDef structure that contains
    455            *                the configuration information for SRAM module.
    456            * @param  pAddress: Pointer to write start address
    457            * @param  pSrcBuffer: Pointer to source buffer to write  
    458            * @param  BufferSize: Size of the buffer to write to memory
    459            * @retval HAL status
    460            */

   \                                 In section .text, align 2, keep-with-next
    461          HAL_StatusTypeDef HAL_SRAM_Write_32b(SRAM_HandleTypeDef *hsram, uint32_t *pAddress, uint32_t *pSrcBuffer, uint32_t BufferSize)
    462          {
   \                     HAL_SRAM_Write_32b: (+1)
   \   00000000   0xB410             PUSH     {R4}
   \   00000002   0x0004             MOVS     R4,R0
    463            /* Check the SRAM controller state */
    464            if(hsram->State == HAL_SRAM_STATE_PROTECTED)
   \   00000004   0xF894 0x0045      LDRB     R0,[R4, #+69]
   \   00000008   0x2804             CMP      R0,#+4
   \   0000000A   0xD101             BNE.N    ??HAL_SRAM_Write_32b_0
    465            {
    466              return  HAL_ERROR; 
   \   0000000C   0x2001             MOVS     R0,#+1
   \   0000000E   0xE01A             B.N      ??HAL_SRAM_Write_32b_1
    467            }
    468            
    469            /* Process Locked */
    470            __HAL_LOCK(hsram);
   \                     ??HAL_SRAM_Write_32b_0: (+1)
   \   00000010   0xF894 0x0044      LDRB     R0,[R4, #+68]
   \   00000014   0x2801             CMP      R0,#+1
   \   00000016   0xD101             BNE.N    ??HAL_SRAM_Write_32b_2
   \   00000018   0x2002             MOVS     R0,#+2
   \   0000001A   0xE014             B.N      ??HAL_SRAM_Write_32b_1
   \                     ??HAL_SRAM_Write_32b_2: (+1)
   \   0000001C   0x2001             MOVS     R0,#+1
   \   0000001E   0xF884 0x0044      STRB     R0,[R4, #+68]
    471            
    472            /* Update the SRAM controller state */
    473            hsram->State = HAL_SRAM_STATE_BUSY; 
   \   00000022   0x2002             MOVS     R0,#+2
   \   00000024   0xF884 0x0045      STRB     R0,[R4, #+69]
    474          
    475            /* Write data to memory */
    476            for(; BufferSize != 0; BufferSize--)
   \                     ??HAL_SRAM_Write_32b_3: (+1)
   \   00000028   0x2B00             CMP      R3,#+0
   \   0000002A   0xD005             BEQ.N    ??HAL_SRAM_Write_32b_4
    477            {
    478              *(__IO uint32_t *)pAddress = *pSrcBuffer; 
   \   0000002C   0x6810             LDR      R0,[R2, #+0]
   \   0000002E   0x6008             STR      R0,[R1, #+0]
    479              pSrcBuffer++;
   \   00000030   0x1D12             ADDS     R2,R2,#+4
    480              pAddress++;    
   \   00000032   0x1D09             ADDS     R1,R1,#+4
    481            }    
   \   00000034   0x1E5B             SUBS     R3,R3,#+1
   \   00000036   0xE7F7             B.N      ??HAL_SRAM_Write_32b_3
    482          
    483            /* Update the SRAM controller state */
    484            hsram->State = HAL_SRAM_STATE_READY; 
   \                     ??HAL_SRAM_Write_32b_4: (+1)
   \   00000038   0x2001             MOVS     R0,#+1
   \   0000003A   0xF884 0x0045      STRB     R0,[R4, #+69]
    485            
    486            /* Process unlocked */
    487            __HAL_UNLOCK(hsram);
   \   0000003E   0x2000             MOVS     R0,#+0
   \   00000040   0xF884 0x0044      STRB     R0,[R4, #+68]
    488              
    489            return HAL_OK;   
   \   00000044   0x2000             MOVS     R0,#+0
   \                     ??HAL_SRAM_Write_32b_1: (+1)
   \   00000046   0xBC10             POP      {R4}
   \   00000048   0x4770             BX       LR               ;; return
    490          }
    491          
    492          /**
    493            * @brief  Reads a Words data from the SRAM memory using DMA transfer.
    494            * @param  hsram: pointer to a SRAM_HandleTypeDef structure that contains
    495            *                the configuration information for SRAM module.
    496            * @param  pAddress: Pointer to read start address
    497            * @param  pDstBuffer: Pointer to destination buffer  
    498            * @param  BufferSize: Size of the buffer to read from memory
    499            * @retval HAL status
    500            */

   \                                 In section .text, align 2, keep-with-next
    501          HAL_StatusTypeDef HAL_SRAM_Read_DMA(SRAM_HandleTypeDef *hsram, uint32_t *pAddress, uint32_t *pDstBuffer, uint32_t BufferSize)
    502          {
   \                     HAL_SRAM_Read_DMA: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   \   00000008   0x001F             MOVS     R7,R3
    503            /* Process Locked */
    504            __HAL_LOCK(hsram);  
   \   0000000A   0xF894 0x0044      LDRB     R0,[R4, #+68]
   \   0000000E   0x2801             CMP      R0,#+1
   \   00000010   0xD101             BNE.N    ??HAL_SRAM_Read_DMA_0
   \   00000012   0x2002             MOVS     R0,#+2
   \   00000014   0xE018             B.N      ??HAL_SRAM_Read_DMA_1
   \                     ??HAL_SRAM_Read_DMA_0: (+1)
   \   00000016   0x2001             MOVS     R0,#+1
   \   00000018   0xF884 0x0044      STRB     R0,[R4, #+68]
    505            
    506            /* Update the SRAM controller state */
    507            hsram->State = HAL_SRAM_STATE_BUSY;   
   \   0000001C   0x2002             MOVS     R0,#+2
   \   0000001E   0xF884 0x0045      STRB     R0,[R4, #+69]
    508            
    509            /* Configure DMA user callbacks */
    510            hsram->hdma->XferCpltCallback  = HAL_SRAM_DMA_XferCpltCallback;
   \   00000022   0x....             LDR.N    R0,??DataTable1
   \   00000024   0x6CA1             LDR      R1,[R4, #+72]
   \   00000026   0x63C8             STR      R0,[R1, #+60]
    511            hsram->hdma->XferErrorCallback = HAL_SRAM_DMA_XferErrorCallback;
   \   00000028   0x....             LDR.N    R0,??DataTable1_1
   \   0000002A   0x6CA1             LDR      R1,[R4, #+72]
   \   0000002C   0x6488             STR      R0,[R1, #+72]
    512          
    513            /* Enable the DMA Stream */
    514            HAL_DMA_Start_IT(hsram->hdma, (uint32_t)pAddress, (uint32_t)pDstBuffer, (uint32_t)BufferSize);
   \   0000002E   0x003B             MOVS     R3,R7
   \   00000030   0x0032             MOVS     R2,R6
   \   00000032   0x0029             MOVS     R1,R5
   \   00000034   0x6CA0             LDR      R0,[R4, #+72]
   \   00000036   0x.... 0x....      BL       HAL_DMA_Start_IT
    515            
    516            /* Update the SRAM controller state */
    517            hsram->State = HAL_SRAM_STATE_READY; 
   \   0000003A   0x2001             MOVS     R0,#+1
   \   0000003C   0xF884 0x0045      STRB     R0,[R4, #+69]
    518            
    519            /* Process unlocked */
    520            __HAL_UNLOCK(hsram);  
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0xF884 0x0044      STRB     R0,[R4, #+68]
    521            
    522            return HAL_OK; 
   \   00000046   0x2000             MOVS     R0,#+0
   \                     ??HAL_SRAM_Read_DMA_1: (+1)
   \   00000048   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    523          }
    524          
    525          /**
    526            * @brief  Writes a Words data buffer to SRAM memory using DMA transfer.
    527            * @param  hsram: pointer to a SRAM_HandleTypeDef structure that contains
    528            *                the configuration information for SRAM module.
    529            * @param  pAddress: Pointer to write start address
    530            * @param  pSrcBuffer: Pointer to source buffer to write  
    531            * @param  BufferSize: Size of the buffer to write to memory
    532            * @retval HAL status
    533            */

   \                                 In section .text, align 2, keep-with-next
    534          HAL_StatusTypeDef HAL_SRAM_Write_DMA(SRAM_HandleTypeDef *hsram, uint32_t *pAddress, uint32_t *pSrcBuffer, uint32_t BufferSize)
    535          {
   \                     HAL_SRAM_Write_DMA: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   \   00000008   0x001F             MOVS     R7,R3
    536            /* Check the SRAM controller state */
    537            if(hsram->State == HAL_SRAM_STATE_PROTECTED)
   \   0000000A   0xF894 0x0045      LDRB     R0,[R4, #+69]
   \   0000000E   0x2804             CMP      R0,#+4
   \   00000010   0xD101             BNE.N    ??HAL_SRAM_Write_DMA_0
    538            {
    539              return  HAL_ERROR; 
   \   00000012   0x2001             MOVS     R0,#+1
   \   00000014   0xE01E             B.N      ??HAL_SRAM_Write_DMA_1
    540            }
    541            
    542            /* Process Locked */
    543            __HAL_LOCK(hsram);
   \                     ??HAL_SRAM_Write_DMA_0: (+1)
   \   00000016   0xF894 0x0044      LDRB     R0,[R4, #+68]
   \   0000001A   0x2801             CMP      R0,#+1
   \   0000001C   0xD101             BNE.N    ??HAL_SRAM_Write_DMA_2
   \   0000001E   0x2002             MOVS     R0,#+2
   \   00000020   0xE018             B.N      ??HAL_SRAM_Write_DMA_1
   \                     ??HAL_SRAM_Write_DMA_2: (+1)
   \   00000022   0x2001             MOVS     R0,#+1
   \   00000024   0xF884 0x0044      STRB     R0,[R4, #+68]
    544            
    545            /* Update the SRAM controller state */
    546            hsram->State = HAL_SRAM_STATE_BUSY; 
   \   00000028   0x2002             MOVS     R0,#+2
   \   0000002A   0xF884 0x0045      STRB     R0,[R4, #+69]
    547            
    548            /* Configure DMA user callbacks */
    549            hsram->hdma->XferCpltCallback  = HAL_SRAM_DMA_XferCpltCallback;
   \   0000002E   0x....             LDR.N    R0,??DataTable1
   \   00000030   0x6CA1             LDR      R1,[R4, #+72]
   \   00000032   0x63C8             STR      R0,[R1, #+60]
    550            hsram->hdma->XferErrorCallback = HAL_SRAM_DMA_XferErrorCallback;
   \   00000034   0x....             LDR.N    R0,??DataTable1_1
   \   00000036   0x6CA1             LDR      R1,[R4, #+72]
   \   00000038   0x6488             STR      R0,[R1, #+72]
    551          
    552            /* Enable the DMA Stream */
    553            HAL_DMA_Start_IT(hsram->hdma, (uint32_t)pSrcBuffer, (uint32_t)pAddress, (uint32_t)BufferSize);
   \   0000003A   0x003B             MOVS     R3,R7
   \   0000003C   0x002A             MOVS     R2,R5
   \   0000003E   0x0031             MOVS     R1,R6
   \   00000040   0x6CA0             LDR      R0,[R4, #+72]
   \   00000042   0x.... 0x....      BL       HAL_DMA_Start_IT
    554            
    555            /* Update the SRAM controller state */
    556            hsram->State = HAL_SRAM_STATE_READY;  
   \   00000046   0x2001             MOVS     R0,#+1
   \   00000048   0xF884 0x0045      STRB     R0,[R4, #+69]
    557            
    558            /* Process unlocked */
    559            __HAL_UNLOCK(hsram);  
   \   0000004C   0x2000             MOVS     R0,#+0
   \   0000004E   0xF884 0x0044      STRB     R0,[R4, #+68]
    560            
    561            return HAL_OK;
   \   00000052   0x2000             MOVS     R0,#+0
   \                     ??HAL_SRAM_Write_DMA_1: (+1)
   \   00000054   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    562          }
    563          
    564          /**
    565            * @}
    566            */
    567            
    568          /** @defgroup SRAM_Exported_Functions_Group3 Control functions 
    569           *  @brief   Control functions 
    570           *
    571          @verbatim   
    572            ==============================================================================
    573                                  ##### SRAM Control functions #####
    574            ==============================================================================  
    575            [..]
    576              This subsection provides a set of functions allowing to control dynamically
    577              the SRAM interface.
    578          
    579          @endverbatim
    580            * @{
    581            */
    582              
    583          /**
    584            * @brief  Enables dynamically SRAM write operation.
    585            * @param  hsram: pointer to a SRAM_HandleTypeDef structure that contains
    586            *                the configuration information for SRAM module.
    587            * @retval HAL status
    588            */

   \                                 In section .text, align 2, keep-with-next
    589          HAL_StatusTypeDef HAL_SRAM_WriteOperation_Enable(SRAM_HandleTypeDef *hsram)
    590          {
   \                     HAL_SRAM_WriteOperation_Enable: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    591            /* Process Locked */
    592            __HAL_LOCK(hsram);
   \   00000004   0xF894 0x0044      LDRB     R0,[R4, #+68]
   \   00000008   0x2801             CMP      R0,#+1
   \   0000000A   0xD101             BNE.N    ??HAL_SRAM_WriteOperation_Enable_0
   \   0000000C   0x2002             MOVS     R0,#+2
   \   0000000E   0xE00D             B.N      ??HAL_SRAM_WriteOperation_Enable_1
   \                     ??HAL_SRAM_WriteOperation_Enable_0: (+1)
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0xF884 0x0044      STRB     R0,[R4, #+68]
    593          
    594            /* Enable write operation */
    595            FMC_NORSRAM_WriteOperation_Enable(hsram->Instance, hsram->Init.NSBank); 
   \   00000016   0x68A1             LDR      R1,[R4, #+8]
   \   00000018   0x6820             LDR      R0,[R4, #+0]
   \   0000001A   0x.... 0x....      BL       FMC_NORSRAM_WriteOperation_Enable
    596            
    597            /* Update the SRAM controller state */
    598            hsram->State = HAL_SRAM_STATE_READY;
   \   0000001E   0x2001             MOVS     R0,#+1
   \   00000020   0xF884 0x0045      STRB     R0,[R4, #+69]
    599            
    600            /* Process unlocked */
    601            __HAL_UNLOCK(hsram); 
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0xF884 0x0044      STRB     R0,[R4, #+68]
    602            
    603            return HAL_OK;  
   \   0000002A   0x2000             MOVS     R0,#+0
   \                     ??HAL_SRAM_WriteOperation_Enable_1: (+1)
   \   0000002C   0xBD10             POP      {R4,PC}          ;; return
    604          }
    605          
    606          /**
    607            * @brief  Disables dynamically SRAM write operation.
    608            * @param  hsram: pointer to a SRAM_HandleTypeDef structure that contains
    609            *                the configuration information for SRAM module.
    610            * @retval HAL status
    611            */

   \                                 In section .text, align 2, keep-with-next
    612          HAL_StatusTypeDef HAL_SRAM_WriteOperation_Disable(SRAM_HandleTypeDef *hsram)
    613          {
   \                     HAL_SRAM_WriteOperation_Disable: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    614            /* Process Locked */
    615            __HAL_LOCK(hsram);
   \   00000004   0xF894 0x0044      LDRB     R0,[R4, #+68]
   \   00000008   0x2801             CMP      R0,#+1
   \   0000000A   0xD101             BNE.N    ??HAL_SRAM_WriteOperation_Disable_0
   \   0000000C   0x2002             MOVS     R0,#+2
   \   0000000E   0xE010             B.N      ??HAL_SRAM_WriteOperation_Disable_1
   \                     ??HAL_SRAM_WriteOperation_Disable_0: (+1)
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0xF884 0x0044      STRB     R0,[R4, #+68]
    616          
    617            /* Update the SRAM controller state */
    618            hsram->State = HAL_SRAM_STATE_BUSY;
   \   00000016   0x2002             MOVS     R0,#+2
   \   00000018   0xF884 0x0045      STRB     R0,[R4, #+69]
    619              
    620            /* Disable write operation */
    621            FMC_NORSRAM_WriteOperation_Disable(hsram->Instance, hsram->Init.NSBank); 
   \   0000001C   0x68A1             LDR      R1,[R4, #+8]
   \   0000001E   0x6820             LDR      R0,[R4, #+0]
   \   00000020   0x.... 0x....      BL       FMC_NORSRAM_WriteOperation_Disable
    622            
    623            /* Update the SRAM controller state */
    624            hsram->State = HAL_SRAM_STATE_PROTECTED;
   \   00000024   0x2004             MOVS     R0,#+4
   \   00000026   0xF884 0x0045      STRB     R0,[R4, #+69]
    625            
    626            /* Process unlocked */
    627            __HAL_UNLOCK(hsram); 
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0xF884 0x0044      STRB     R0,[R4, #+68]
    628            
    629            return HAL_OK;  
   \   00000030   0x2000             MOVS     R0,#+0
   \                     ??HAL_SRAM_WriteOperation_Disable_1: (+1)
   \   00000032   0xBD10             POP      {R4,PC}          ;; return
    630          }
    631          
    632          /**
    633            * @}
    634            */
    635          
    636          /** @defgroup SRAM_Exported_Functions_Group4 Peripheral State functions 
    637           *  @brief   Peripheral State functions 
    638           *
    639          @verbatim   
    640            ==============================================================================
    641                                ##### SRAM State functions #####
    642            ==============================================================================  
    643            [..]
    644              This subsection permits to get in run-time the status of the SRAM controller 
    645              and the data flow.
    646          
    647          @endverbatim
    648            * @{
    649            */
    650            
    651          /**
    652            * @brief  Returns the SRAM controller state
    653            * @param  hsram: pointer to a SRAM_HandleTypeDef structure that contains
    654            *                the configuration information for SRAM module.
    655            * @retval HAL state
    656            */

   \                                 In section .text, align 2, keep-with-next
    657          HAL_SRAM_StateTypeDef HAL_SRAM_GetState(SRAM_HandleTypeDef *hsram)
    658          {
    659            return hsram->State;
   \                     HAL_SRAM_GetState: (+1)
   \   00000000   0xF890 0x0045      LDRB     R0,[R0, #+69]
   \   00000004   0x4770             BX       LR               ;; return
    660          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1:
   \   00000000   0x........         DC32     HAL_SRAM_DMA_XferCpltCallback

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_1:
   \   00000000   0x........         DC32     HAL_SRAM_DMA_XferErrorCallback
    661          
    662          /**
    663            * @}
    664            */
    665          
    666          /**
    667            * @}
    668            */
    669          #endif /* HAL_SRAM_MODULE_ENABLED */
    670          /**
    671            * @}
    672            */
    673          
    674          /**
    675            * @}
    676            */
    677          
    678          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   HAL_SRAM_DMA_XferCpltCallback
       0   HAL_SRAM_DMA_XferErrorCallback
       8   HAL_SRAM_DeInit
         8   -> FMC_NORSRAM_DeInit
         8   -> HAL_SRAM_MspDeInit
       0   HAL_SRAM_GetState
      16   HAL_SRAM_Init
        16   -> FMC_NORSRAM_Extended_Timing_Init
        16   -> FMC_NORSRAM_Init
        16   -> FMC_NORSRAM_Timing_Init
        16   -> HAL_SRAM_MspInit
       0   HAL_SRAM_MspDeInit
       0   HAL_SRAM_MspInit
       8   HAL_SRAM_Read_16b
       4   HAL_SRAM_Read_32b
       8   HAL_SRAM_Read_8b
      24   HAL_SRAM_Read_DMA
        24   -> HAL_DMA_Start_IT
       8   HAL_SRAM_WriteOperation_Disable
         8   -> FMC_NORSRAM_WriteOperation_Disable
       8   HAL_SRAM_WriteOperation_Enable
         8   -> FMC_NORSRAM_WriteOperation_Enable
       8   HAL_SRAM_Write_16b
       4   HAL_SRAM_Write_32b
       8   HAL_SRAM_Write_8b
      24   HAL_SRAM_Write_DMA
        24   -> HAL_DMA_Start_IT


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable1
       4  ??DataTable1_1
       2  HAL_SRAM_DMA_XferCpltCallback
       2  HAL_SRAM_DMA_XferErrorCallback
      36  HAL_SRAM_DeInit
       6  HAL_SRAM_GetState
      92  HAL_SRAM_Init
       2  HAL_SRAM_MspDeInit
       2  HAL_SRAM_MspInit
      64  HAL_SRAM_Read_16b
      62  HAL_SRAM_Read_32b
      64  HAL_SRAM_Read_8b
      74  HAL_SRAM_Read_DMA
      52  HAL_SRAM_WriteOperation_Disable
      46  HAL_SRAM_WriteOperation_Enable
      76  HAL_SRAM_Write_16b
      74  HAL_SRAM_Write_32b
      76  HAL_SRAM_Write_8b
      86  HAL_SRAM_Write_DMA

 
 824 bytes in section .text
 
 824 bytes of CODE memory

Errors: none
Warnings: none
