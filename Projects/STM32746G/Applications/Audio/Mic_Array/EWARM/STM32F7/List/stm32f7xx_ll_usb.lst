###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.2.10312/W32 for ARM       13/Feb/2016  11:44:37
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_ll_usb.c
#    Command line =  
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_ll_usb.c
#        -D USE_HAL_DRIVER -D STM32F746xx -D USE_STM32746G_DISCO -D
#        USE_IOEXPANDER -D USE_USB_FS -lC
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
#        -lA
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
#        -o
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M7 -e --fpu=VFPv5_sp --dlib_config "D:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.3\arm\INC\c\DLib_Config_Full.h"
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\Inc\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\CMSIS\Device\ST\STM32F7xx\Include\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\STM32F7xx_HAL_Driver\Inc\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\STM32746G-Discovery\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\Components\Common\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Log\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Fonts\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\CPU\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_Device_Library\Core\Inc\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Core\Inc\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Class\MSC\Inc\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\drivers\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_Audio\Addons\PDM\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_Device_Library\Class\AUDIO\Inc\
#        -On --use_c++_inline --require_prototypes -I "D:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.3\arm\CMSIS\Include\" -D
#        ARM_MATH_CM7
#    List file    =  
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List\stm32f7xx_ll_usb.lst
#    Object file  =  
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj\stm32f7xx_ll_usb.o
#
###############################################################################

H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_ll_usb.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f7xx_ll_usb.c
      4            * @author  MCD Application Team
      5            * @version V1.0.1
      6            * @date    25-June-2015
      7            * @brief   USB Low Layer HAL module driver.
      8            *    
      9            *          This file provides firmware functions to manage the following 
     10            *          functionalities of the USB Peripheral Controller:
     11            *           + Initialization/de-initialization functions
     12            *           + I/O operation functions
     13            *           + Peripheral Control functions 
     14            *           + Peripheral State functions
     15            *         
     16            @verbatim
     17            ==============================================================================
     18                              ##### How to use this driver #####
     19            ==============================================================================
     20              [..]
     21                (#) Fill parameters of Init structure in USB_OTG_CfgTypeDef structure.
     22            
     23                (#) Call USB_CoreInit() API to initialize the USB Core peripheral.
     24          
     25                (#) The upper HAL HCD/PCD driver will call the right routines for its internal processes.
     26          
     27            @endverbatim
     28            ******************************************************************************
     29            * @attention
     30            *
     31            * <h2><center>&copy; COPYRIGHT(c) 2015 STMicroelectronics</center></h2>
     32            *
     33            * Redistribution and use in source and binary forms, with or without modification,
     34            * are permitted provided that the following conditions are met:
     35            *   1. Redistributions of source code must retain the above copyright notice,
     36            *      this list of conditions and the following disclaimer.
     37            *   2. Redistributions in binary form must reproduce the above copyright notice,
     38            *      this list of conditions and the following disclaimer in the documentation
     39            *      and/or other materials provided with the distribution.
     40            *   3. Neither the name of STMicroelectronics nor the names of its contributors
     41            *      may be used to endorse or promote products derived from this software
     42            *      without specific prior written permission.
     43            *
     44            * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
     45            * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     46            * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     47            * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
     48            * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
     49            * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
     50            * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
     51            * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
     52            * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
     53            * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     54            *
     55            ******************************************************************************
     56            */ 
     57          
     58          /* Includes ------------------------------------------------------------------*/
     59          #include "stm32f7xx_hal.h"
     60          
     61          /** @addtogroup STM32F7xx_LL_USB_DRIVER
     62            * @{
     63            */
     64          
     65          #if defined (HAL_PCD_MODULE_ENABLED) || defined (HAL_HCD_MODULE_ENABLED)
     66          
     67          /* Private typedef -----------------------------------------------------------*/
     68          /* Private define ------------------------------------------------------------*/
     69          /* Private macro -------------------------------------------------------------*/
     70          /* Private variables ---------------------------------------------------------*/
     71          /* Private function prototypes -----------------------------------------------*/
     72          /* Private functions ---------------------------------------------------------*/
     73          static HAL_StatusTypeDef USB_CoreReset(USB_OTG_GlobalTypeDef *USBx);
     74          
     75          /** @defgroup PCD_Private_Functions
     76            * @{
     77            */
     78          
     79          /** @defgroup LL_USB_Group1 Initialization/de-initialization functions 
     80           *  @brief    Initialization and Configuration functions 
     81           *
     82          @verbatim    
     83           ===============================================================================
     84                        ##### Initialization/de-initialization functions #####
     85           ===============================================================================
     86              [..]  This section provides functions allowing to:
     87           
     88          @endverbatim
     89            * @{
     90            */
     91          
     92          /**
     93            * @brief  Initializes the USB Core
     94            * @param  USBx: USB Instance
     95            * @param  cfg : pointer to a USB_OTG_CfgTypeDef structure that contains
     96            *         the configuration information for the specified USBx peripheral.
     97            * @retval HAL status
     98            */

   \                                 In section .text, align 2, keep-with-next
     99          HAL_StatusTypeDef USB_CoreInit(USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
    100          {
   \                     USB_CoreInit: (+1)
   \   00000000   0xB40E             PUSH     {R1-R3}
   \   00000002   0xB518             PUSH     {R3,R4,LR}
   \   00000004   0x0004             MOVS     R4,R0
    101            if (cfg.phy_itface == USB_OTG_ULPI_PHY)
   \   00000006   0x9808             LDR      R0,[SP, #+32]
   \   00000008   0x2801             CMP      R0,#+1
   \   0000000A   0xD117             BNE.N    ??USB_CoreInit_0
    102            {
    103              
    104              USBx->GCCFG &= ~(USB_OTG_GCCFG_PWRDWN);
   \   0000000C   0x6BA0             LDR      R0,[R4, #+56]
   \   0000000E   0xF430 0x3080      BICS     R0,R0,#0x10000
   \   00000012   0x63A0             STR      R0,[R4, #+56]
    105          
    106              /* Init The ULPI Interface */
    107              USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_TSDPS | USB_OTG_GUSBCFG_ULPIFSLS | USB_OTG_GUSBCFG_PHYSEL);
   \   00000014   0x68E0             LDR      R0,[R4, #+12]
   \   00000016   0x.... 0x....      LDR.W    R1,??DataTable5  ;; 0xffbdffbf
   \   0000001A   0x4008             ANDS     R0,R1,R0
   \   0000001C   0x60E0             STR      R0,[R4, #+12]
    108             
    109              /* Select vbus source */
    110              USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_ULPIEVBUSD | USB_OTG_GUSBCFG_ULPIEVBUSI);
   \   0000001E   0x68E0             LDR      R0,[R4, #+12]
   \   00000020   0xF430 0x1040      BICS     R0,R0,#0x300000
   \   00000024   0x60E0             STR      R0,[R4, #+12]
    111              if(cfg.use_external_vbus == 1)
   \   00000026   0x980E             LDR      R0,[SP, #+56]
   \   00000028   0x2801             CMP      R0,#+1
   \   0000002A   0xD103             BNE.N    ??USB_CoreInit_1
    112              {
    113                USBx->GUSBCFG |= USB_OTG_GUSBCFG_ULPIEVBUSD;
   \   0000002C   0x68E0             LDR      R0,[R4, #+12]
   \   0000002E   0xF450 0x1080      ORRS     R0,R0,#0x100000
   \   00000032   0x60E0             STR      R0,[R4, #+12]
    114              }
    115              /* Reset after a PHY select  */
    116              USB_CoreReset(USBx); 
   \                     ??USB_CoreInit_1: (+1)
   \   00000034   0x0020             MOVS     R0,R4
   \   00000036   0x.... 0x....      BL       USB_CoreReset
   \   0000003A   0xE009             B.N      ??USB_CoreInit_2
    117            }
    118            else /* FS interface (embedded Phy) */
    119            {
    120              
    121              /* Select FS Embedded PHY */
    122              USBx->GUSBCFG |= USB_OTG_GUSBCFG_PHYSEL;
   \                     ??USB_CoreInit_0: (+1)
   \   0000003C   0x68E0             LDR      R0,[R4, #+12]
   \   0000003E   0xF050 0x0040      ORRS     R0,R0,#0x40
   \   00000042   0x60E0             STR      R0,[R4, #+12]
    123              
    124              /* Reset after a PHY select and set Host mode */
    125              USB_CoreReset(USBx);
   \   00000044   0x0020             MOVS     R0,R4
   \   00000046   0x.... 0x....      BL       USB_CoreReset
    126              
    127              /* Deactivate the power down*/
    128              USBx->GCCFG = USB_OTG_GCCFG_PWRDWN;
   \   0000004A   0xF45F 0x3080      MOVS     R0,#+65536
   \   0000004E   0x63A0             STR      R0,[R4, #+56]
    129            }
    130           
    131            if(cfg.dma_enable == ENABLE)
   \                     ??USB_CoreInit_2: (+1)
   \   00000050   0x9806             LDR      R0,[SP, #+24]
   \   00000052   0x2801             CMP      R0,#+1
   \   00000054   0xD107             BNE.N    ??USB_CoreInit_3
    132            {
    133              USBx->GAHBCFG |= (USB_OTG_GAHBCFG_HBSTLEN_1 | USB_OTG_GAHBCFG_HBSTLEN_2);
   \   00000056   0x68A0             LDR      R0,[R4, #+8]
   \   00000058   0xF050 0x000C      ORRS     R0,R0,#0xC
   \   0000005C   0x60A0             STR      R0,[R4, #+8]
    134              USBx->GAHBCFG |= USB_OTG_GAHBCFG_DMAEN;
   \   0000005E   0x68A0             LDR      R0,[R4, #+8]
   \   00000060   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   00000064   0x60A0             STR      R0,[R4, #+8]
    135            }  
    136          
    137            return HAL_OK;
   \                     ??USB_CoreInit_3: (+1)
   \   00000066   0x2000             MOVS     R0,#+0
   \   00000068   0xBC12             POP      {R1,R4}
   \   0000006A   0xF85D 0xFB10      LDR      PC,[SP], #+16    ;; return
    138          }
    139          
    140          /**
    141            * @brief  USB_EnableGlobalInt
    142            *         Enables the controller's Global Int in the AHB Config reg
    143            * @param  USBx : Selected device
    144            * @retval HAL status
    145            */

   \                                 In section .text, align 2, keep-with-next
    146          HAL_StatusTypeDef USB_EnableGlobalInt(USB_OTG_GlobalTypeDef *USBx)
    147          {
   \                     USB_EnableGlobalInt: (+1)
   \   00000000   0x0001             MOVS     R1,R0
    148            USBx->GAHBCFG |= USB_OTG_GAHBCFG_GINT;
   \   00000002   0x6888             LDR      R0,[R1, #+8]
   \   00000004   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000008   0x6088             STR      R0,[R1, #+8]
    149            return HAL_OK;
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x4770             BX       LR               ;; return
    150          }
    151          
    152          
    153          /**
    154            * @brief  USB_DisableGlobalInt
    155            *         Disable the controller's Global Int in the AHB Config reg
    156            * @param  USBx : Selected device
    157            * @retval HAL status
    158          */

   \                                 In section .text, align 2, keep-with-next
    159          HAL_StatusTypeDef USB_DisableGlobalInt(USB_OTG_GlobalTypeDef *USBx)
    160          {
   \                     USB_DisableGlobalInt: (+1)
   \   00000000   0x0001             MOVS     R1,R0
    161            USBx->GAHBCFG &= ~USB_OTG_GAHBCFG_GINT;
   \   00000002   0x6888             LDR      R0,[R1, #+8]
   \   00000004   0x0840             LSRS     R0,R0,#+1
   \   00000006   0x0040             LSLS     R0,R0,#+1
   \   00000008   0x6088             STR      R0,[R1, #+8]
    162            return HAL_OK;
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x4770             BX       LR               ;; return
    163          }
    164             
    165          /**
    166            * @brief  USB_SetCurrentMode : Set functional mode
    167            * @param  USBx : Selected device
    168            * @param  mode :  current core mode
    169            *          This parameter can be one of the these values:
    170            *            @arg USB_OTG_DEVICE_MODE: Peripheral mode
    171            *            @arg USB_OTG_HOST_MODE: Host mode
    172            *            @arg USB_OTG_DRD_MODE: Dual Role Device mode  
    173            * @retval HAL status
    174            */

   \                                 In section .text, align 2, keep-with-next
    175          HAL_StatusTypeDef USB_SetCurrentMode(USB_OTG_GlobalTypeDef *USBx , USB_OTG_ModeTypeDef mode)
    176          {
   \                     USB_SetCurrentMode: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    177            USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_FHMOD | USB_OTG_GUSBCFG_FDMOD); 
   \   00000006   0x68E0             LDR      R0,[R4, #+12]
   \   00000008   0xF030 0x40C0      BICS     R0,R0,#0x60000000
   \   0000000C   0x60E0             STR      R0,[R4, #+12]
    178            
    179            if ( mode == USB_OTG_HOST_MODE)
   \   0000000E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000010   0x2D01             CMP      R5,#+1
   \   00000012   0xD104             BNE.N    ??USB_SetCurrentMode_0
    180            {
    181              USBx->GUSBCFG |= USB_OTG_GUSBCFG_FHMOD; 
   \   00000014   0x68E0             LDR      R0,[R4, #+12]
   \   00000016   0xF050 0x5000      ORRS     R0,R0,#0x20000000
   \   0000001A   0x60E0             STR      R0,[R4, #+12]
   \   0000001C   0xE006             B.N      ??USB_SetCurrentMode_1
    182            }
    183            else if ( mode == USB_OTG_DEVICE_MODE)
   \                     ??USB_SetCurrentMode_0: (+1)
   \   0000001E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000020   0x2D00             CMP      R5,#+0
   \   00000022   0xD103             BNE.N    ??USB_SetCurrentMode_1
    184            {
    185              USBx->GUSBCFG |= USB_OTG_GUSBCFG_FDMOD; 
   \   00000024   0x68E0             LDR      R0,[R4, #+12]
   \   00000026   0xF050 0x4080      ORRS     R0,R0,#0x40000000
   \   0000002A   0x60E0             STR      R0,[R4, #+12]
    186            }
    187            HAL_Delay(50);
   \                     ??USB_SetCurrentMode_1: (+1)
   \   0000002C   0x2032             MOVS     R0,#+50
   \   0000002E   0x.... 0x....      BL       HAL_Delay
    188            
    189            return HAL_OK;
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    190          }
    191          
    192          /**
    193            * @brief  USB_DevInit : Initializes the USB_OTG controller registers 
    194            *         for device mode
    195            * @param  USBx : Selected device
    196            * @param  cfg  : pointer to a USB_OTG_CfgTypeDef structure that contains
    197            *         the configuration information for the specified USBx peripheral.
    198            * @retval HAL status
    199            */

   \                                 In section .text, align 2, keep-with-next
    200          HAL_StatusTypeDef USB_DevInit (USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
    201          {
   \                     USB_DevInit: (+1)
   \   00000000   0xB40E             PUSH     {R1-R3}
   \   00000002   0xB530             PUSH     {R4,R5,LR}
   \   00000004   0x0004             MOVS     R4,R0
    202            uint32_t i = 0;
   \   00000006   0x2500             MOVS     R5,#+0
    203          
    204            /*Activate VBUS Sensing B */
    205            USBx->GCCFG |= USB_OTG_GCCFG_VBDEN;
   \   00000008   0x6BA0             LDR      R0,[R4, #+56]
   \   0000000A   0xF450 0x1000      ORRS     R0,R0,#0x200000
   \   0000000E   0x63A0             STR      R0,[R4, #+56]
    206            
    207            if (cfg.vbus_sensing_enable == 0)
   \   00000010   0x980C             LDR      R0,[SP, #+48]
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD10B             BNE.N    ??USB_DevInit_0
    208            {
    209              /*Desactivate VBUS Sensing B */
    210              USBx->GCCFG &= ~ USB_OTG_GCCFG_VBDEN;
   \   00000016   0x6BA0             LDR      R0,[R4, #+56]
   \   00000018   0xF430 0x1000      BICS     R0,R0,#0x200000
   \   0000001C   0x63A0             STR      R0,[R4, #+56]
    211              
    212              /* B-peripheral session valid override enable*/ 
    213              USBx->GOTGCTL |= USB_OTG_GOTGCTL_BVALOEN;
   \   0000001E   0x6820             LDR      R0,[R4, #+0]
   \   00000020   0xF050 0x0040      ORRS     R0,R0,#0x40
   \   00000024   0x6020             STR      R0,[R4, #+0]
    214              USBx->GOTGCTL |= USB_OTG_GOTGCTL_BVALOVAL;
   \   00000026   0x6820             LDR      R0,[R4, #+0]
   \   00000028   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   0000002C   0x6020             STR      R0,[R4, #+0]
    215            }
    216             
    217            /* Restart the Phy Clock */
    218            USBx_PCGCCTL = 0;
   \                     ??USB_DevInit_0: (+1)
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0xF514 0x6160      ADDS     R1,R4,#+3584
   \   00000034   0x6008             STR      R0,[R1, #+0]
    219          
    220            /* Device mode configuration */
    221            USBx_DEVICE->DCFG |= DCFG_FRAME_INTERVAL_80;
   \   00000036   0xF514 0x6000      ADDS     R0,R4,#+2048
   \   0000003A   0x6800             LDR      R0,[R0, #+0]
   \   0000003C   0xF514 0x6100      ADDS     R1,R4,#+2048
   \   00000040   0x6008             STR      R0,[R1, #+0]
    222            
    223            if(cfg.phy_itface  == USB_OTG_ULPI_PHY)
   \   00000042   0x9808             LDR      R0,[SP, #+32]
   \   00000044   0x2801             CMP      R0,#+1
   \   00000046   0xD10C             BNE.N    ??USB_DevInit_1
    224            {
    225              if(cfg.speed == USB_OTG_SPEED_HIGH)
   \   00000048   0x9805             LDR      R0,[SP, #+20]
   \   0000004A   0x2800             CMP      R0,#+0
   \   0000004C   0xD104             BNE.N    ??USB_DevInit_2
    226              {      
    227                /* Set High speed phy */
    228                USB_SetDevSpeed (USBx , USB_OTG_SPEED_HIGH);
   \   0000004E   0x2100             MOVS     R1,#+0
   \   00000050   0x0020             MOVS     R0,R4
   \   00000052   0x.... 0x....      BL       USB_SetDevSpeed
   \   00000056   0xE008             B.N      ??USB_DevInit_3
    229              }
    230              else 
    231              {
    232                /* set High speed phy in Full speed mode */
    233                USB_SetDevSpeed (USBx , USB_OTG_SPEED_HIGH_IN_FULL);
   \                     ??USB_DevInit_2: (+1)
   \   00000058   0x2101             MOVS     R1,#+1
   \   0000005A   0x0020             MOVS     R0,R4
   \   0000005C   0x.... 0x....      BL       USB_SetDevSpeed
   \   00000060   0xE003             B.N      ??USB_DevInit_3
    234              }
    235            }
    236            else
    237            {
    238              /* Set Full speed phy */
    239              USB_SetDevSpeed (USBx , USB_OTG_SPEED_FULL);
   \                     ??USB_DevInit_1: (+1)
   \   00000062   0x2103             MOVS     R1,#+3
   \   00000064   0x0020             MOVS     R0,R4
   \   00000066   0x.... 0x....      BL       USB_SetDevSpeed
    240            }
    241          
    242            /* Flush the FIFOs */
    243            USB_FlushTxFifo(USBx , 0x10); /* all Tx FIFOs */
   \                     ??USB_DevInit_3: (+1)
   \   0000006A   0x2110             MOVS     R1,#+16
   \   0000006C   0x0020             MOVS     R0,R4
   \   0000006E   0x.... 0x....      BL       USB_FlushTxFifo
    244            USB_FlushRxFifo(USBx);
   \   00000072   0x0020             MOVS     R0,R4
   \   00000074   0x.... 0x....      BL       USB_FlushRxFifo
    245          
    246            
    247            /* Clear all pending Device Interrupts */
    248            USBx_DEVICE->DIEPMSK = 0;
   \   00000078   0x2000             MOVS     R0,#+0
   \   0000007A   0xF514 0x6100      ADDS     R1,R4,#+2048
   \   0000007E   0x6108             STR      R0,[R1, #+16]
    249            USBx_DEVICE->DOEPMSK = 0;
   \   00000080   0x2000             MOVS     R0,#+0
   \   00000082   0xF514 0x6100      ADDS     R1,R4,#+2048
   \   00000086   0x6148             STR      R0,[R1, #+20]
    250            USBx_DEVICE->DAINT = 0xFFFFFFFF;
   \   00000088   0xF05F 0x30FF      MOVS     R0,#-1
   \   0000008C   0xF514 0x6100      ADDS     R1,R4,#+2048
   \   00000090   0x6188             STR      R0,[R1, #+24]
    251            USBx_DEVICE->DAINTMSK = 0;
   \   00000092   0x2000             MOVS     R0,#+0
   \   00000094   0xF514 0x6100      ADDS     R1,R4,#+2048
   \   00000098   0x61C8             STR      R0,[R1, #+28]
    252            
    253            for (i = 0; i < cfg.dev_endpoints; i++)
   \   0000009A   0x2000             MOVS     R0,#+0
   \   0000009C   0x0005             MOVS     R5,R0
   \                     ??USB_DevInit_4: (+1)
   \   0000009E   0x9803             LDR      R0,[SP, #+12]
   \   000000A0   0x4285             CMP      R5,R0
   \   000000A2   0xD222             BCS.N    ??USB_DevInit_5
    254            {
    255              if ((USBx_INEP(i)->DIEPCTL & USB_OTG_DIEPCTL_EPENA) == USB_OTG_DIEPCTL_EPENA)
   \   000000A4   0xEB14 0x1045      ADDS     R0,R4,R5, LSL #+5
   \   000000A8   0xF510 0x6010      ADDS     R0,R0,#+2304
   \   000000AC   0x6800             LDR      R0,[R0, #+0]
   \   000000AE   0x2800             CMP      R0,#+0
   \   000000B0   0xD507             BPL.N    ??USB_DevInit_6
    256              {
    257                USBx_INEP(i)->DIEPCTL = (USB_OTG_DIEPCTL_EPDIS | USB_OTG_DIEPCTL_SNAK);
   \   000000B2   0xF05F 0x4090      MOVS     R0,#+1207959552
   \   000000B6   0xEB14 0x1145      ADDS     R1,R4,R5, LSL #+5
   \   000000BA   0xF511 0x6110      ADDS     R1,R1,#+2304
   \   000000BE   0x6008             STR      R0,[R1, #+0]
   \   000000C0   0xE005             B.N      ??USB_DevInit_7
    258              }
    259              else
    260              {
    261                USBx_INEP(i)->DIEPCTL = 0;
   \                     ??USB_DevInit_6: (+1)
   \   000000C2   0x2000             MOVS     R0,#+0
   \   000000C4   0xEB14 0x1145      ADDS     R1,R4,R5, LSL #+5
   \   000000C8   0xF511 0x6110      ADDS     R1,R1,#+2304
   \   000000CC   0x6008             STR      R0,[R1, #+0]
    262              }
    263              
    264              USBx_INEP(i)->DIEPTSIZ = 0;
   \                     ??USB_DevInit_7: (+1)
   \   000000CE   0xEB14 0x1045      ADDS     R0,R4,R5, LSL #+5
   \   000000D2   0xF510 0x6010      ADDS     R0,R0,#+2304
   \   000000D6   0x2100             MOVS     R1,#+0
   \   000000D8   0x6101             STR      R1,[R0, #+16]
    265              USBx_INEP(i)->DIEPINT  = 0xFF;
   \   000000DA   0xEB14 0x1045      ADDS     R0,R4,R5, LSL #+5
   \   000000DE   0xF510 0x6010      ADDS     R0,R0,#+2304
   \   000000E2   0x21FF             MOVS     R1,#+255
   \   000000E4   0x6081             STR      R1,[R0, #+8]
    266            }
   \   000000E6   0x1C6D             ADDS     R5,R5,#+1
   \   000000E8   0xE7D9             B.N      ??USB_DevInit_4
    267            
    268            for (i = 0; i < cfg.dev_endpoints; i++)
   \                     ??USB_DevInit_5: (+1)
   \   000000EA   0x2000             MOVS     R0,#+0
   \   000000EC   0x0005             MOVS     R5,R0
   \                     ??USB_DevInit_8: (+1)
   \   000000EE   0x9803             LDR      R0,[SP, #+12]
   \   000000F0   0x4285             CMP      R5,R0
   \   000000F2   0xD222             BCS.N    ??USB_DevInit_9
    269            {
    270              if ((USBx_OUTEP(i)->DOEPCTL & USB_OTG_DOEPCTL_EPENA) == USB_OTG_DOEPCTL_EPENA)
   \   000000F4   0xEB14 0x1045      ADDS     R0,R4,R5, LSL #+5
   \   000000F8   0xF510 0x6030      ADDS     R0,R0,#+2816
   \   000000FC   0x6800             LDR      R0,[R0, #+0]
   \   000000FE   0x2800             CMP      R0,#+0
   \   00000100   0xD507             BPL.N    ??USB_DevInit_10
    271              {
    272                USBx_OUTEP(i)->DOEPCTL = (USB_OTG_DOEPCTL_EPDIS | USB_OTG_DOEPCTL_SNAK);
   \   00000102   0xF05F 0x4090      MOVS     R0,#+1207959552
   \   00000106   0xEB14 0x1145      ADDS     R1,R4,R5, LSL #+5
   \   0000010A   0xF511 0x6130      ADDS     R1,R1,#+2816
   \   0000010E   0x6008             STR      R0,[R1, #+0]
   \   00000110   0xE005             B.N      ??USB_DevInit_11
    273              }
    274              else
    275              {
    276                USBx_OUTEP(i)->DOEPCTL = 0;
   \                     ??USB_DevInit_10: (+1)
   \   00000112   0x2000             MOVS     R0,#+0
   \   00000114   0xEB14 0x1145      ADDS     R1,R4,R5, LSL #+5
   \   00000118   0xF511 0x6130      ADDS     R1,R1,#+2816
   \   0000011C   0x6008             STR      R0,[R1, #+0]
    277              }
    278              
    279              USBx_OUTEP(i)->DOEPTSIZ = 0;
   \                     ??USB_DevInit_11: (+1)
   \   0000011E   0xEB14 0x1045      ADDS     R0,R4,R5, LSL #+5
   \   00000122   0xF510 0x6030      ADDS     R0,R0,#+2816
   \   00000126   0x2100             MOVS     R1,#+0
   \   00000128   0x6101             STR      R1,[R0, #+16]
    280              USBx_OUTEP(i)->DOEPINT  = 0xFF;
   \   0000012A   0xEB14 0x1045      ADDS     R0,R4,R5, LSL #+5
   \   0000012E   0xF510 0x6030      ADDS     R0,R0,#+2816
   \   00000132   0x21FF             MOVS     R1,#+255
   \   00000134   0x6081             STR      R1,[R0, #+8]
    281            }
   \   00000136   0x1C6D             ADDS     R5,R5,#+1
   \   00000138   0xE7D9             B.N      ??USB_DevInit_8
    282            
    283            USBx_DEVICE->DIEPMSK &= ~(USB_OTG_DIEPMSK_TXFURM);
   \                     ??USB_DevInit_9: (+1)
   \   0000013A   0xF514 0x6000      ADDS     R0,R4,#+2048
   \   0000013E   0x6900             LDR      R0,[R0, #+16]
   \   00000140   0xF430 0x7080      BICS     R0,R0,#0x100
   \   00000144   0xF514 0x6100      ADDS     R1,R4,#+2048
   \   00000148   0x6108             STR      R0,[R1, #+16]
    284            
    285            if (cfg.dma_enable == 1)
   \   0000014A   0x9806             LDR      R0,[SP, #+24]
   \   0000014C   0x2801             CMP      R0,#+1
   \   0000014E   0xD112             BNE.N    ??USB_DevInit_12
    286            {
    287              /*Set threshold parameters */
    288              USBx_DEVICE->DTHRCTL = (USB_OTG_DTHRCTL_TXTHRLEN_6 | USB_OTG_DTHRCTL_RXTHRLEN_6);
   \   00000150   0x.... 0x....      LDR.W    R0,??DataTable7  ;; 0x800100
   \   00000154   0xF514 0x6100      ADDS     R1,R4,#+2048
   \   00000158   0x6308             STR      R0,[R1, #+48]
    289              USBx_DEVICE->DTHRCTL |= (USB_OTG_DTHRCTL_RXTHREN | USB_OTG_DTHRCTL_ISOTHREN | USB_OTG_DTHRCTL_NONISOTHREN);
   \   0000015A   0xF514 0x6000      ADDS     R0,R4,#+2048
   \   0000015E   0x6B00             LDR      R0,[R0, #+48]
   \   00000160   0xF440 0x3080      ORR      R0,R0,#0x10000
   \   00000164   0xF050 0x0003      ORRS     R0,R0,#0x3
   \   00000168   0xF514 0x6100      ADDS     R1,R4,#+2048
   \   0000016C   0x6308             STR      R0,[R1, #+48]
    290              
    291              i= USBx_DEVICE->DTHRCTL;
   \   0000016E   0xF514 0x6000      ADDS     R0,R4,#+2048
   \   00000172   0x6B00             LDR      R0,[R0, #+48]
   \   00000174   0x0005             MOVS     R5,R0
    292            }
    293            
    294            /* Disable all interrupts. */
    295            USBx->GINTMSK = 0;
   \                     ??USB_DevInit_12: (+1)
   \   00000176   0x2000             MOVS     R0,#+0
   \   00000178   0x61A0             STR      R0,[R4, #+24]
    296            
    297            /* Clear any pending interrupts */
    298            USBx->GINTSTS = 0xBFFFFFFF;
   \   0000017A   0xF07F 0x4080      MVNS     R0,#+1073741824
   \   0000017E   0x6160             STR      R0,[R4, #+20]
    299          
    300            /* Enable the common interrupts */
    301            if (cfg.dma_enable == DISABLE)
   \   00000180   0x9806             LDR      R0,[SP, #+24]
   \   00000182   0x2800             CMP      R0,#+0
   \   00000184   0xD103             BNE.N    ??USB_DevInit_13
    302            {
    303              USBx->GINTMSK |= USB_OTG_GINTMSK_RXFLVLM; 
   \   00000186   0x69A0             LDR      R0,[R4, #+24]
   \   00000188   0xF050 0x0010      ORRS     R0,R0,#0x10
   \   0000018C   0x61A0             STR      R0,[R4, #+24]
    304            }
    305            
    306            /* Enable interrupts matching to the Device mode ONLY */
    307            USBx->GINTMSK |= (USB_OTG_GINTMSK_USBSUSPM | USB_OTG_GINTMSK_USBRST |\
    308                              USB_OTG_GINTMSK_ENUMDNEM | USB_OTG_GINTMSK_IEPINT |\
    309                              USB_OTG_GINTMSK_OEPINT   | USB_OTG_GINTMSK_IISOIXFRM|\
    310                              USB_OTG_GINTMSK_PXFRM_IISOOXFRM | USB_OTG_GINTMSK_WUIM);
   \                     ??USB_DevInit_13: (+1)
   \   0000018E   0x69A0             LDR      R0,[R4, #+24]
   \   00000190   0x.... 0x....      LDR.W    R1,??DataTable7_1  ;; 0x803c3800
   \   00000194   0x4308             ORRS     R0,R1,R0
   \   00000196   0x61A0             STR      R0,[R4, #+24]
    311            
    312            if(cfg.Sof_enable)
   \   00000198   0x9809             LDR      R0,[SP, #+36]
   \   0000019A   0x2800             CMP      R0,#+0
   \   0000019C   0xD003             BEQ.N    ??USB_DevInit_14
    313            {
    314              USBx->GINTMSK |= USB_OTG_GINTMSK_SOFM;
   \   0000019E   0x69A0             LDR      R0,[R4, #+24]
   \   000001A0   0xF050 0x0008      ORRS     R0,R0,#0x8
   \   000001A4   0x61A0             STR      R0,[R4, #+24]
    315            }
    316          
    317            if (cfg.vbus_sensing_enable == ENABLE)
   \                     ??USB_DevInit_14: (+1)
   \   000001A6   0x980C             LDR      R0,[SP, #+48]
   \   000001A8   0x2801             CMP      R0,#+1
   \   000001AA   0xD105             BNE.N    ??USB_DevInit_15
    318            {
    319              USBx->GINTMSK |= (USB_OTG_GINTMSK_SRQIM | USB_OTG_GINTMSK_OTGINT); 
   \   000001AC   0x69A0             LDR      R0,[R4, #+24]
   \   000001AE   0xF040 0x4080      ORR      R0,R0,#0x40000000
   \   000001B2   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   000001B6   0x61A0             STR      R0,[R4, #+24]
    320            }
    321            
    322            return HAL_OK;
   \                     ??USB_DevInit_15: (+1)
   \   000001B8   0x2000             MOVS     R0,#+0
   \   000001BA   0xBC30             POP      {R4,R5}
   \   000001BC   0xF85D 0xFB10      LDR      PC,[SP], #+16    ;; return
    323          }
    324          
    325          
    326          /**
    327            * @brief  USB_OTG_FlushTxFifo : Flush a Tx FIFO
    328            * @param  USBx : Selected device
    329            * @param  num : FIFO number
    330            *         This parameter can be a value from 1 to 15
    331                      15 means Flush all Tx FIFOs
    332            * @retval HAL status
    333            */

   \                                 In section .text, align 2, keep-with-next
    334          HAL_StatusTypeDef USB_FlushTxFifo (USB_OTG_GlobalTypeDef *USBx, uint32_t num )
    335          {
   \                     USB_FlushTxFifo: (+1)
   \   00000000   0x0002             MOVS     R2,R0
    336            uint32_t count = 0;
   \   00000002   0x2300             MOVS     R3,#+0
    337           
    338            USBx->GRSTCTL = ( USB_OTG_GRSTCTL_TXFFLSH |(uint32_t)( num << 6)); 
   \   00000004   0x0188             LSLS     R0,R1,#+6
   \   00000006   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   0000000A   0x6110             STR      R0,[R2, #+16]
    339           
    340            do
    341            {
    342              if (++count > 200000)
   \                     ??USB_FlushTxFifo_0: (+1)
   \   0000000C   0x1C5B             ADDS     R3,R3,#+1
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable7_2  ;; 0x30d41
   \   00000012   0x4283             CMP      R3,R0
   \   00000014   0xD301             BCC.N    ??USB_FlushTxFifo_1
    343              {
    344                return HAL_TIMEOUT;
   \   00000016   0x2003             MOVS     R0,#+3
   \   00000018   0xE003             B.N      ??USB_FlushTxFifo_2
    345              }
    346            }
    347            while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_TXFFLSH) == USB_OTG_GRSTCTL_TXFFLSH);
   \                     ??USB_FlushTxFifo_1: (+1)
   \   0000001A   0x6910             LDR      R0,[R2, #+16]
   \   0000001C   0x0680             LSLS     R0,R0,#+26
   \   0000001E   0xD4F5             BMI.N    ??USB_FlushTxFifo_0
    348            
    349            return HAL_OK;
   \   00000020   0x2000             MOVS     R0,#+0
   \                     ??USB_FlushTxFifo_2: (+1)
   \   00000022   0x4770             BX       LR               ;; return
    350          }
    351          
    352          
    353          /**
    354            * @brief  USB_FlushRxFifo : Flush Rx FIFO
    355            * @param  USBx : Selected device
    356            * @retval HAL status
    357            */

   \                                 In section .text, align 2, keep-with-next
    358          HAL_StatusTypeDef USB_FlushRxFifo(USB_OTG_GlobalTypeDef *USBx)
    359          {
   \                     USB_FlushRxFifo: (+1)
   \   00000000   0x0001             MOVS     R1,R0
    360            uint32_t count = 0;
   \   00000002   0x2200             MOVS     R2,#+0
    361            
    362            USBx->GRSTCTL = USB_OTG_GRSTCTL_RXFFLSH;
   \   00000004   0x2010             MOVS     R0,#+16
   \   00000006   0x6108             STR      R0,[R1, #+16]
    363            
    364            do
    365            {
    366              if (++count > 200000)
   \                     ??USB_FlushRxFifo_0: (+1)
   \   00000008   0x1C52             ADDS     R2,R2,#+1
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable7_2  ;; 0x30d41
   \   0000000E   0x4282             CMP      R2,R0
   \   00000010   0xD301             BCC.N    ??USB_FlushRxFifo_1
    367              {
    368                return HAL_TIMEOUT;
   \   00000012   0x2003             MOVS     R0,#+3
   \   00000014   0xE003             B.N      ??USB_FlushRxFifo_2
    369              }
    370            }
    371            while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_RXFFLSH) == USB_OTG_GRSTCTL_RXFFLSH);
   \                     ??USB_FlushRxFifo_1: (+1)
   \   00000016   0x6908             LDR      R0,[R1, #+16]
   \   00000018   0x06C0             LSLS     R0,R0,#+27
   \   0000001A   0xD4F5             BMI.N    ??USB_FlushRxFifo_0
    372            
    373            return HAL_OK;
   \   0000001C   0x2000             MOVS     R0,#+0
   \                     ??USB_FlushRxFifo_2: (+1)
   \   0000001E   0x4770             BX       LR               ;; return
    374          }
    375          
    376          /**
    377            * @brief  USB_SetDevSpeed :Initializes the DevSpd field of DCFG register 
    378            *         depending the PHY type and the enumeration speed of the device.
    379            * @param  USBx : Selected device
    380            * @param  speed : device speed
    381            *          This parameter can be one of the these values:
    382            *            @arg USB_OTG_SPEED_HIGH: High speed mode
    383            *            @arg USB_OTG_SPEED_HIGH_IN_FULL: High speed core in Full Speed mode
    384            *            @arg USB_OTG_SPEED_FULL: Full speed mode
    385            *            @arg USB_OTG_SPEED_LOW: Low speed mode
    386            * @retval  Hal status
    387            */

   \                                 In section .text, align 2, keep-with-next
    388          HAL_StatusTypeDef USB_SetDevSpeed(USB_OTG_GlobalTypeDef *USBx , uint8_t speed)
    389          {
   \                     USB_SetDevSpeed: (+1)
   \   00000000   0x0002             MOVS     R2,R0
    390            USBx_DEVICE->DCFG |= speed;
   \   00000002   0xF512 0x6000      ADDS     R0,R2,#+2048
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000A   0x4308             ORRS     R0,R1,R0
   \   0000000C   0xF512 0x6300      ADDS     R3,R2,#+2048
   \   00000010   0x6018             STR      R0,[R3, #+0]
    391            return HAL_OK;
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0x4770             BX       LR               ;; return
    392          }
    393          
    394          /**
    395            * @brief  USB_GetDevSpeed :Return the  Dev Speed 
    396            * @param  USBx : Selected device
    397            * @retval speed : device speed
    398            *          This parameter can be one of the these values:
    399            *            @arg USB_OTG_SPEED_HIGH: High speed mode
    400            *            @arg USB_OTG_SPEED_FULL: Full speed mode
    401            *            @arg USB_OTG_SPEED_LOW: Low speed mode
    402            */

   \                                 In section .text, align 2, keep-with-next
    403          uint8_t USB_GetDevSpeed(USB_OTG_GlobalTypeDef *USBx)
    404          {
   \                     USB_GetDevSpeed: (+1)
   \   00000000   0x0001             MOVS     R1,R0
    405            uint8_t speed = 0;
   \   00000002   0x2000             MOVS     R0,#+0
    406            
    407            if((USBx_DEVICE->DSTS & USB_OTG_DSTS_ENUMSPD) == DSTS_ENUMSPD_HS_PHY_30MHZ_OR_60MHZ)
   \   00000004   0xF511 0x6200      ADDS     R2,R1,#+2048
   \   00000008   0x6892             LDR      R2,[R2, #+8]
   \   0000000A   0xF012 0x0F06      TST      R2,#0x6
   \   0000000E   0xD102             BNE.N    ??USB_GetDevSpeed_0
    408            {
    409              speed = USB_OTG_SPEED_HIGH;
   \   00000010   0x2200             MOVS     R2,#+0
   \   00000012   0x0010             MOVS     R0,R2
   \   00000014   0xE019             B.N      ??USB_GetDevSpeed_1
    410            }
    411            else if (((USBx_DEVICE->DSTS & USB_OTG_DSTS_ENUMSPD) == DSTS_ENUMSPD_FS_PHY_30MHZ_OR_60MHZ)||
    412                     ((USBx_DEVICE->DSTS & USB_OTG_DSTS_ENUMSPD) == DSTS_ENUMSPD_FS_PHY_48MHZ))
   \                     ??USB_GetDevSpeed_0: (+1)
   \   00000016   0xF511 0x6200      ADDS     R2,R1,#+2048
   \   0000001A   0x6892             LDR      R2,[R2, #+8]
   \   0000001C   0xF012 0x0206      ANDS     R2,R2,#0x6
   \   00000020   0x2A02             CMP      R2,#+2
   \   00000022   0xD006             BEQ.N    ??USB_GetDevSpeed_2
   \   00000024   0xF511 0x6200      ADDS     R2,R1,#+2048
   \   00000028   0x6892             LDR      R2,[R2, #+8]
   \   0000002A   0xF012 0x0206      ANDS     R2,R2,#0x6
   \   0000002E   0x2A06             CMP      R2,#+6
   \   00000030   0xD102             BNE.N    ??USB_GetDevSpeed_3
    413            {
    414              speed = USB_OTG_SPEED_FULL;
   \                     ??USB_GetDevSpeed_2: (+1)
   \   00000032   0x2203             MOVS     R2,#+3
   \   00000034   0x0010             MOVS     R0,R2
   \   00000036   0xE008             B.N      ??USB_GetDevSpeed_1
    415            }
    416            else if((USBx_DEVICE->DSTS & USB_OTG_DSTS_ENUMSPD) == DSTS_ENUMSPD_LS_PHY_6MHZ)
   \                     ??USB_GetDevSpeed_3: (+1)
   \   00000038   0xF511 0x6200      ADDS     R2,R1,#+2048
   \   0000003C   0x6892             LDR      R2,[R2, #+8]
   \   0000003E   0xF012 0x0206      ANDS     R2,R2,#0x6
   \   00000042   0x2A04             CMP      R2,#+4
   \   00000044   0xD101             BNE.N    ??USB_GetDevSpeed_1
    417            {
    418              speed = USB_OTG_SPEED_LOW;
   \   00000046   0x2202             MOVS     R2,#+2
   \   00000048   0x0010             MOVS     R0,R2
    419            }
    420            
    421            return speed;
   \                     ??USB_GetDevSpeed_1: (+1)
   \   0000004A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000004C   0x4770             BX       LR               ;; return
    422          }
    423          
    424          /**
    425            * @brief  Activate and configure an endpoint
    426            * @param  USBx : Selected device
    427            * @param  ep: pointer to endpoint structure
    428            * @retval HAL status
    429            */

   \                                 In section .text, align 2, keep-with-next
    430          HAL_StatusTypeDef USB_ActivateEndpoint(USB_OTG_GlobalTypeDef *USBx, USB_OTG_EPTypeDef *ep)
    431          {
   \                     USB_ActivateEndpoint: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
   \   00000002   0x0002             MOVS     R2,R0
    432            if (ep->is_in == 1)
   \   00000004   0x7848             LDRB     R0,[R1, #+1]
   \   00000006   0x2801             CMP      R0,#+1
   \   00000008   0xD12E             BNE.N    ??USB_ActivateEndpoint_0
    433            {
    434             USBx_DEVICE->DAINTMSK |= USB_OTG_DAINTMSK_IEPM & ((1 << (ep->num)));
   \   0000000A   0xF512 0x6000      ADDS     R0,R2,#+2048
   \   0000000E   0x69C0             LDR      R0,[R0, #+28]
   \   00000010   0x2301             MOVS     R3,#+1
   \   00000012   0xF991 0x4000      LDRSB    R4,[R1, #+0]
   \   00000016   0x40A3             LSLS     R3,R3,R4
   \   00000018   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   0000001A   0x4318             ORRS     R0,R3,R0
   \   0000001C   0xF512 0x6300      ADDS     R3,R2,#+2048
   \   00000020   0x61D8             STR      R0,[R3, #+28]
    435             
    436              if (((USBx_INEP(ep->num)->DIEPCTL) & USB_OTG_DIEPCTL_USBAEP) == 0)
   \   00000022   0x7808             LDRB     R0,[R1, #+0]
   \   00000024   0xEB12 0x1040      ADDS     R0,R2,R0, LSL #+5
   \   00000028   0xF510 0x6010      ADDS     R0,R0,#+2304
   \   0000002C   0x6800             LDR      R0,[R0, #+0]
   \   0000002E   0x0400             LSLS     R0,R0,#+16
   \   00000030   0xD445             BMI.N    ??USB_ActivateEndpoint_1
    437              {
    438                USBx_INEP(ep->num)->DIEPCTL |= ((ep->maxpacket & USB_OTG_DIEPCTL_MPSIZ ) | (ep->type << 18 ) |\
    439                  ((ep->num) << 22 ) | (USB_OTG_DIEPCTL_SD0PID_SEVNFRM) | (USB_OTG_DIEPCTL_USBAEP)); 
   \   00000032   0x7808             LDRB     R0,[R1, #+0]
   \   00000034   0xEB12 0x1040      ADDS     R0,R2,R0, LSL #+5
   \   00000038   0xF510 0x6010      ADDS     R0,R0,#+2304
   \   0000003C   0x780B             LDRB     R3,[R1, #+0]
   \   0000003E   0xEB12 0x1343      ADDS     R3,R2,R3, LSL #+5
   \   00000042   0xF513 0x6310      ADDS     R3,R3,#+2304
   \   00000046   0x681B             LDR      R3,[R3, #+0]
   \   00000048   0x688C             LDR      R4,[R1, #+8]
   \   0000004A   0x0564             LSLS     R4,R4,#+21       ;; ZeroExtS R4,R4,#+21,#+21
   \   0000004C   0x0D64             LSRS     R4,R4,#+21
   \   0000004E   0x78CD             LDRB     R5,[R1, #+3]
   \   00000050   0xEA54 0x4485      ORRS     R4,R4,R5, LSL #+18
   \   00000054   0x780D             LDRB     R5,[R1, #+0]
   \   00000056   0xEA54 0x5485      ORRS     R4,R4,R5, LSL #+22
   \   0000005A   0xF044 0x5480      ORR      R4,R4,#0x10000000
   \   0000005E   0xF454 0x4400      ORRS     R4,R4,#0x8000
   \   00000062   0x4323             ORRS     R3,R4,R3
   \   00000064   0x6003             STR      R3,[R0, #+0]
   \   00000066   0xE02A             B.N      ??USB_ActivateEndpoint_1
    440              } 
    441          
    442            }
    443            else
    444            {
    445               USBx_DEVICE->DAINTMSK |= USB_OTG_DAINTMSK_OEPM & ((1 << (ep->num)) << 16);
   \                     ??USB_ActivateEndpoint_0: (+1)
   \   00000068   0xF512 0x6000      ADDS     R0,R2,#+2048
   \   0000006C   0x69C0             LDR      R0,[R0, #+28]
   \   0000006E   0x2301             MOVS     R3,#+1
   \   00000070   0xF991 0x4000      LDRSB    R4,[R1, #+0]
   \   00000074   0x40A3             LSLS     R3,R3,R4
   \   00000076   0xEA50 0x4003      ORRS     R0,R0,R3, LSL #+16
   \   0000007A   0xF512 0x6300      ADDS     R3,R2,#+2048
   \   0000007E   0x61D8             STR      R0,[R3, #+28]
    446               
    447              if (((USBx_OUTEP(ep->num)->DOEPCTL) & USB_OTG_DOEPCTL_USBAEP) == 0)
   \   00000080   0x7808             LDRB     R0,[R1, #+0]
   \   00000082   0xEB12 0x1040      ADDS     R0,R2,R0, LSL #+5
   \   00000086   0xF510 0x6030      ADDS     R0,R0,#+2816
   \   0000008A   0x6800             LDR      R0,[R0, #+0]
   \   0000008C   0x0400             LSLS     R0,R0,#+16
   \   0000008E   0xD416             BMI.N    ??USB_ActivateEndpoint_1
    448              {
    449                USBx_OUTEP(ep->num)->DOEPCTL |= ((ep->maxpacket & USB_OTG_DOEPCTL_MPSIZ ) | (ep->type << 18 ) |\
    450                 (USB_OTG_DIEPCTL_SD0PID_SEVNFRM)| (USB_OTG_DOEPCTL_USBAEP));
   \   00000090   0x7808             LDRB     R0,[R1, #+0]
   \   00000092   0xEB12 0x1040      ADDS     R0,R2,R0, LSL #+5
   \   00000096   0xF510 0x6030      ADDS     R0,R0,#+2816
   \   0000009A   0x780B             LDRB     R3,[R1, #+0]
   \   0000009C   0xEB12 0x1343      ADDS     R3,R2,R3, LSL #+5
   \   000000A0   0xF513 0x6330      ADDS     R3,R3,#+2816
   \   000000A4   0x681B             LDR      R3,[R3, #+0]
   \   000000A6   0x688C             LDR      R4,[R1, #+8]
   \   000000A8   0x0564             LSLS     R4,R4,#+21       ;; ZeroExtS R4,R4,#+21,#+21
   \   000000AA   0x0D64             LSRS     R4,R4,#+21
   \   000000AC   0x78CD             LDRB     R5,[R1, #+3]
   \   000000AE   0xEA54 0x4485      ORRS     R4,R4,R5, LSL #+18
   \   000000B2   0xF044 0x5480      ORR      R4,R4,#0x10000000
   \   000000B6   0xF454 0x4400      ORRS     R4,R4,#0x8000
   \   000000BA   0x4323             ORRS     R3,R4,R3
   \   000000BC   0x6003             STR      R3,[R0, #+0]
    451              } 
    452            }
    453            return HAL_OK;
   \                     ??USB_ActivateEndpoint_1: (+1)
   \   000000BE   0x2000             MOVS     R0,#+0
   \   000000C0   0xBC30             POP      {R4,R5}
   \   000000C2   0x4770             BX       LR               ;; return
    454          }
    455          /**
    456            * @brief  Activate and configure a dedicated endpoint
    457            * @param  USBx : Selected device
    458            * @param  ep: pointer to endpoint structure
    459            * @retval HAL status
    460            */

   \                                 In section .text, align 2, keep-with-next
    461          HAL_StatusTypeDef USB_ActivateDedicatedEndpoint(USB_OTG_GlobalTypeDef *USBx, USB_OTG_EPTypeDef *ep)
    462          {
   \                     USB_ActivateDedicatedEndpoint: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
   \   00000002   0x0002             MOVS     R2,R0
    463            static __IO uint32_t debug = 0;
    464            
    465            /* Read DEPCTLn register */
    466            if (ep->is_in == 1)
   \   00000004   0x7848             LDRB     R0,[R1, #+1]
   \   00000006   0x2801             CMP      R0,#+1
   \   00000008   0xD142             BNE.N    ??USB_ActivateDedicatedEndpoint_0
    467            {
    468              if (((USBx_INEP(ep->num)->DIEPCTL) & USB_OTG_DIEPCTL_USBAEP) == 0)
   \   0000000A   0x7808             LDRB     R0,[R1, #+0]
   \   0000000C   0xEB12 0x1040      ADDS     R0,R2,R0, LSL #+5
   \   00000010   0xF510 0x6010      ADDS     R0,R0,#+2304
   \   00000014   0x6800             LDR      R0,[R0, #+0]
   \   00000016   0x0400             LSLS     R0,R0,#+16
   \   00000018   0xD419             BMI.N    ??USB_ActivateDedicatedEndpoint_1
    469              {
    470                USBx_INEP(ep->num)->DIEPCTL |= ((ep->maxpacket & USB_OTG_DIEPCTL_MPSIZ ) | (ep->type << 18 ) |\
    471                  ((ep->num) << 22 ) | (USB_OTG_DIEPCTL_SD0PID_SEVNFRM) | (USB_OTG_DIEPCTL_USBAEP)); 
   \   0000001A   0x7808             LDRB     R0,[R1, #+0]
   \   0000001C   0xEB12 0x1040      ADDS     R0,R2,R0, LSL #+5
   \   00000020   0xF510 0x6010      ADDS     R0,R0,#+2304
   \   00000024   0x780B             LDRB     R3,[R1, #+0]
   \   00000026   0xEB12 0x1343      ADDS     R3,R2,R3, LSL #+5
   \   0000002A   0xF513 0x6310      ADDS     R3,R3,#+2304
   \   0000002E   0x681B             LDR      R3,[R3, #+0]
   \   00000030   0x688C             LDR      R4,[R1, #+8]
   \   00000032   0x0564             LSLS     R4,R4,#+21       ;; ZeroExtS R4,R4,#+21,#+21
   \   00000034   0x0D64             LSRS     R4,R4,#+21
   \   00000036   0x78CD             LDRB     R5,[R1, #+3]
   \   00000038   0xEA54 0x4485      ORRS     R4,R4,R5, LSL #+18
   \   0000003C   0x780D             LDRB     R5,[R1, #+0]
   \   0000003E   0xEA54 0x5485      ORRS     R4,R4,R5, LSL #+22
   \   00000042   0xF044 0x5480      ORR      R4,R4,#0x10000000
   \   00000046   0xF454 0x4400      ORRS     R4,R4,#0x8000
   \   0000004A   0x4323             ORRS     R3,R4,R3
   \   0000004C   0x6003             STR      R3,[R0, #+0]
    472              } 
    473              
    474              
    475              debug  |= ((ep->maxpacket & USB_OTG_DIEPCTL_MPSIZ ) | (ep->type << 18 ) |\
    476                  ((ep->num) << 22 ) | (USB_OTG_DIEPCTL_SD0PID_SEVNFRM) | (USB_OTG_DIEPCTL_USBAEP)); 
   \                     ??USB_ActivateDedicatedEndpoint_1: (+1)
   \   0000004E   0x.... 0x....      LDR.W    R0,??DataTable7_3
   \   00000052   0x6800             LDR      R0,[R0, #+0]
   \   00000054   0x688B             LDR      R3,[R1, #+8]
   \   00000056   0x055B             LSLS     R3,R3,#+21       ;; ZeroExtS R3,R3,#+21,#+21
   \   00000058   0x0D5B             LSRS     R3,R3,#+21
   \   0000005A   0x78CC             LDRB     R4,[R1, #+3]
   \   0000005C   0xEA53 0x4384      ORRS     R3,R3,R4, LSL #+18
   \   00000060   0x780C             LDRB     R4,[R1, #+0]
   \   00000062   0xEA53 0x5384      ORRS     R3,R3,R4, LSL #+22
   \   00000066   0xF043 0x5380      ORR      R3,R3,#0x10000000
   \   0000006A   0xF453 0x4300      ORRS     R3,R3,#0x8000
   \   0000006E   0x4318             ORRS     R0,R3,R0
   \   00000070   0x.... 0x....      LDR.W    R3,??DataTable7_3
   \   00000074   0x6018             STR      R0,[R3, #+0]
    477              
    478             USBx_DEVICE->DEACHMSK |= USB_OTG_DAINTMSK_IEPM & ((1 << (ep->num)));
   \   00000076   0xF512 0x6000      ADDS     R0,R2,#+2048
   \   0000007A   0x6BC0             LDR      R0,[R0, #+60]
   \   0000007C   0x2301             MOVS     R3,#+1
   \   0000007E   0xF991 0x4000      LDRSB    R4,[R1, #+0]
   \   00000082   0x40A3             LSLS     R3,R3,R4
   \   00000084   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   00000086   0x4318             ORRS     R0,R3,R0
   \   00000088   0xF512 0x6300      ADDS     R3,R2,#+2048
   \   0000008C   0x63D8             STR      R0,[R3, #+60]
   \   0000008E   0xE04A             B.N      ??USB_ActivateDedicatedEndpoint_2
    479            }
    480            else
    481            {
    482              if (((USBx_OUTEP(ep->num)->DOEPCTL) & USB_OTG_DOEPCTL_USBAEP) == 0)
   \                     ??USB_ActivateDedicatedEndpoint_0: (+1)
   \   00000090   0x7808             LDRB     R0,[R1, #+0]
   \   00000092   0xEB12 0x1040      ADDS     R0,R2,R0, LSL #+5
   \   00000096   0xF510 0x6030      ADDS     R0,R0,#+2816
   \   0000009A   0x6800             LDR      R0,[R0, #+0]
   \   0000009C   0x0400             LSLS     R0,R0,#+16
   \   0000009E   0xD436             BMI.N    ??USB_ActivateDedicatedEndpoint_3
    483              {
    484                USBx_OUTEP(ep->num)->DOEPCTL |= ((ep->maxpacket & USB_OTG_DOEPCTL_MPSIZ ) | (ep->type << 18 ) |\
    485                  ((ep->num) << 22 ) | (USB_OTG_DOEPCTL_USBAEP));
   \   000000A0   0x7808             LDRB     R0,[R1, #+0]
   \   000000A2   0xEB12 0x1040      ADDS     R0,R2,R0, LSL #+5
   \   000000A6   0xF510 0x6030      ADDS     R0,R0,#+2816
   \   000000AA   0x780B             LDRB     R3,[R1, #+0]
   \   000000AC   0xEB12 0x1343      ADDS     R3,R2,R3, LSL #+5
   \   000000B0   0xF513 0x6330      ADDS     R3,R3,#+2816
   \   000000B4   0x681B             LDR      R3,[R3, #+0]
   \   000000B6   0x688C             LDR      R4,[R1, #+8]
   \   000000B8   0x0564             LSLS     R4,R4,#+21       ;; ZeroExtS R4,R4,#+21,#+21
   \   000000BA   0x0D64             LSRS     R4,R4,#+21
   \   000000BC   0x78CD             LDRB     R5,[R1, #+3]
   \   000000BE   0xEA54 0x4485      ORRS     R4,R4,R5, LSL #+18
   \   000000C2   0x780D             LDRB     R5,[R1, #+0]
   \   000000C4   0xEA54 0x5485      ORRS     R4,R4,R5, LSL #+22
   \   000000C8   0xF454 0x4400      ORRS     R4,R4,#0x8000
   \   000000CC   0x4323             ORRS     R3,R4,R3
   \   000000CE   0x6003             STR      R3,[R0, #+0]
    486                
    487                debug = (uint32_t)(((uint32_t )USBx) + USB_OTG_OUT_ENDPOINT_BASE + (0)*USB_OTG_EP_REG_SIZE);
   \   000000D0   0xF512 0x6030      ADDS     R0,R2,#+2816
   \   000000D4   0x.... 0x....      LDR.W    R3,??DataTable7_3
   \   000000D8   0x6018             STR      R0,[R3, #+0]
    488                debug = (uint32_t )&USBx_OUTEP(ep->num)->DOEPCTL;
   \   000000DA   0x7808             LDRB     R0,[R1, #+0]
   \   000000DC   0xEB12 0x1040      ADDS     R0,R2,R0, LSL #+5
   \   000000E0   0xF510 0x6030      ADDS     R0,R0,#+2816
   \   000000E4   0x.... 0x....      LDR.W    R3,??DataTable7_3
   \   000000E8   0x6018             STR      R0,[R3, #+0]
    489                debug |= ((ep->maxpacket & USB_OTG_DOEPCTL_MPSIZ ) | (ep->type << 18 ) |\
    490                  ((ep->num) << 22 ) | (USB_OTG_DOEPCTL_USBAEP)); 
   \   000000EA   0x.... 0x....      LDR.W    R0,??DataTable7_3
   \   000000EE   0x6800             LDR      R0,[R0, #+0]
   \   000000F0   0x688B             LDR      R3,[R1, #+8]
   \   000000F2   0x055B             LSLS     R3,R3,#+21       ;; ZeroExtS R3,R3,#+21,#+21
   \   000000F4   0x0D5B             LSRS     R3,R3,#+21
   \   000000F6   0x78CC             LDRB     R4,[R1, #+3]
   \   000000F8   0xEA53 0x4384      ORRS     R3,R3,R4, LSL #+18
   \   000000FC   0x780C             LDRB     R4,[R1, #+0]
   \   000000FE   0xEA53 0x5384      ORRS     R3,R3,R4, LSL #+22
   \   00000102   0xF453 0x4300      ORRS     R3,R3,#0x8000
   \   00000106   0x4318             ORRS     R0,R3,R0
   \   00000108   0x.... 0x....      LDR.W    R3,??DataTable7_3
   \   0000010C   0x6018             STR      R0,[R3, #+0]
    491              } 
    492              
    493               USBx_DEVICE->DEACHMSK |= USB_OTG_DAINTMSK_OEPM & ((1 << (ep->num)) << 16);
   \                     ??USB_ActivateDedicatedEndpoint_3: (+1)
   \   0000010E   0xF512 0x6000      ADDS     R0,R2,#+2048
   \   00000112   0x6BC0             LDR      R0,[R0, #+60]
   \   00000114   0x2301             MOVS     R3,#+1
   \   00000116   0xF991 0x4000      LDRSB    R4,[R1, #+0]
   \   0000011A   0x40A3             LSLS     R3,R3,R4
   \   0000011C   0xEA50 0x4003      ORRS     R0,R0,R3, LSL #+16
   \   00000120   0xF512 0x6300      ADDS     R3,R2,#+2048
   \   00000124   0x63D8             STR      R0,[R3, #+60]
    494            }
    495          
    496            return HAL_OK;
   \                     ??USB_ActivateDedicatedEndpoint_2: (+1)
   \   00000126   0x2000             MOVS     R0,#+0
   \   00000128   0xBC30             POP      {R4,R5}
   \   0000012A   0x4770             BX       LR               ;; return
    497          }

   \                                 In section .bss, align 4
   \                     ??debug:
   \   00000000                      DS8 4
    498          /**
    499            * @brief  De-activate and de-initialize an endpoint
    500            * @param  USBx : Selected device
    501            * @param  ep: pointer to endpoint structure
    502            * @retval HAL status
    503            */

   \                                 In section .text, align 2, keep-with-next
    504          HAL_StatusTypeDef USB_DeactivateEndpoint(USB_OTG_GlobalTypeDef *USBx, USB_OTG_EPTypeDef *ep)
    505          {
   \                     USB_DeactivateEndpoint: (+1)
   \   00000000   0xB410             PUSH     {R4}
   \   00000002   0x0002             MOVS     R2,R0
    506            /* Read DEPCTLn register */
    507            if (ep->is_in == 1)
   \   00000004   0x7848             LDRB     R0,[R1, #+1]
   \   00000006   0x2801             CMP      R0,#+1
   \   00000008   0xD126             BNE.N    ??USB_DeactivateEndpoint_0
    508            {
    509             USBx_DEVICE->DEACHMSK &= ~(USB_OTG_DAINTMSK_IEPM & ((1 << (ep->num))));
   \   0000000A   0xF512 0x6000      ADDS     R0,R2,#+2048
   \   0000000E   0x6BC0             LDR      R0,[R0, #+60]
   \   00000010   0x2301             MOVS     R3,#+1
   \   00000012   0xF991 0x4000      LDRSB    R4,[R1, #+0]
   \   00000016   0x40A3             LSLS     R3,R3,R4
   \   00000018   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   0000001A   0x4398             BICS     R0,R0,R3
   \   0000001C   0xF512 0x6300      ADDS     R3,R2,#+2048
   \   00000020   0x63D8             STR      R0,[R3, #+60]
    510             USBx_DEVICE->DAINTMSK &= ~(USB_OTG_DAINTMSK_IEPM & ((1 << (ep->num))));   
   \   00000022   0xF512 0x6000      ADDS     R0,R2,#+2048
   \   00000026   0x69C0             LDR      R0,[R0, #+28]
   \   00000028   0x2301             MOVS     R3,#+1
   \   0000002A   0xF991 0x4000      LDRSB    R4,[R1, #+0]
   \   0000002E   0x40A3             LSLS     R3,R3,R4
   \   00000030   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   00000032   0x4398             BICS     R0,R0,R3
   \   00000034   0xF512 0x6300      ADDS     R3,R2,#+2048
   \   00000038   0x61D8             STR      R0,[R3, #+28]
    511             USBx_INEP(ep->num)->DIEPCTL &= ~ USB_OTG_DIEPCTL_USBAEP;   
   \   0000003A   0x7808             LDRB     R0,[R1, #+0]
   \   0000003C   0xEB12 0x1040      ADDS     R0,R2,R0, LSL #+5
   \   00000040   0xF510 0x6010      ADDS     R0,R0,#+2304
   \   00000044   0x780B             LDRB     R3,[R1, #+0]
   \   00000046   0xEB12 0x1343      ADDS     R3,R2,R3, LSL #+5
   \   0000004A   0xF513 0x6310      ADDS     R3,R3,#+2304
   \   0000004E   0x681B             LDR      R3,[R3, #+0]
   \   00000050   0xF433 0x4300      BICS     R3,R3,#0x8000
   \   00000054   0x6003             STR      R3,[R0, #+0]
   \   00000056   0xE025             B.N      ??USB_DeactivateEndpoint_1
    512            }
    513            else
    514            {
    515          
    516               USBx_DEVICE->DEACHMSK &= ~(USB_OTG_DAINTMSK_OEPM & ((1 << (ep->num)) << 16));
   \                     ??USB_DeactivateEndpoint_0: (+1)
   \   00000058   0xF512 0x6000      ADDS     R0,R2,#+2048
   \   0000005C   0x6BC0             LDR      R0,[R0, #+60]
   \   0000005E   0x2301             MOVS     R3,#+1
   \   00000060   0xF991 0x4000      LDRSB    R4,[R1, #+0]
   \   00000064   0x40A3             LSLS     R3,R3,R4
   \   00000066   0xEA30 0x4003      BICS     R0,R0,R3, LSL #+16
   \   0000006A   0xF512 0x6300      ADDS     R3,R2,#+2048
   \   0000006E   0x63D8             STR      R0,[R3, #+60]
    517               USBx_DEVICE->DAINTMSK &= ~(USB_OTG_DAINTMSK_OEPM & ((1 << (ep->num)) << 16));     
   \   00000070   0xF512 0x6000      ADDS     R0,R2,#+2048
   \   00000074   0x69C0             LDR      R0,[R0, #+28]
   \   00000076   0x2301             MOVS     R3,#+1
   \   00000078   0xF991 0x4000      LDRSB    R4,[R1, #+0]
   \   0000007C   0x40A3             LSLS     R3,R3,R4
   \   0000007E   0xEA30 0x4003      BICS     R0,R0,R3, LSL #+16
   \   00000082   0xF512 0x6300      ADDS     R3,R2,#+2048
   \   00000086   0x61D8             STR      R0,[R3, #+28]
    518               USBx_OUTEP(ep->num)->DOEPCTL &= ~USB_OTG_DOEPCTL_USBAEP;      
   \   00000088   0x7808             LDRB     R0,[R1, #+0]
   \   0000008A   0xEB12 0x1040      ADDS     R0,R2,R0, LSL #+5
   \   0000008E   0xF510 0x6030      ADDS     R0,R0,#+2816
   \   00000092   0x780B             LDRB     R3,[R1, #+0]
   \   00000094   0xEB12 0x1343      ADDS     R3,R2,R3, LSL #+5
   \   00000098   0xF513 0x6330      ADDS     R3,R3,#+2816
   \   0000009C   0x681B             LDR      R3,[R3, #+0]
   \   0000009E   0xF433 0x4300      BICS     R3,R3,#0x8000
   \   000000A2   0x6003             STR      R3,[R0, #+0]
    519            }
    520            return HAL_OK;
   \                     ??USB_DeactivateEndpoint_1: (+1)
   \   000000A4   0x2000             MOVS     R0,#+0
   \   000000A6   0xBC10             POP      {R4}
   \   000000A8   0x4770             BX       LR               ;; return
    521          }
    522          
    523          /**
    524            * @brief  De-activate and de-initialize a dedicated endpoint
    525            * @param  USBx : Selected device
    526            * @param  ep: pointer to endpoint structure
    527            * @retval HAL status
    528            */

   \                                 In section .text, align 2, keep-with-next
    529          HAL_StatusTypeDef USB_DeactivateDedicatedEndpoint(USB_OTG_GlobalTypeDef *USBx, USB_OTG_EPTypeDef *ep)
    530          {
   \                     USB_DeactivateDedicatedEndpoint: (+1)
   \   00000000   0xB410             PUSH     {R4}
   \   00000002   0x0002             MOVS     R2,R0
    531            /* Read DEPCTLn register */
    532            if (ep->is_in == 1)
   \   00000004   0x7848             LDRB     R0,[R1, #+1]
   \   00000006   0x2801             CMP      R0,#+1
   \   00000008   0xD11A             BNE.N    ??USB_DeactivateDedicatedEndpoint_0
    533            {
    534             USBx_INEP(ep->num)->DIEPCTL &= ~ USB_OTG_DIEPCTL_USBAEP;
   \   0000000A   0x7808             LDRB     R0,[R1, #+0]
   \   0000000C   0xEB12 0x1040      ADDS     R0,R2,R0, LSL #+5
   \   00000010   0xF510 0x6010      ADDS     R0,R0,#+2304
   \   00000014   0x780B             LDRB     R3,[R1, #+0]
   \   00000016   0xEB12 0x1343      ADDS     R3,R2,R3, LSL #+5
   \   0000001A   0xF513 0x6310      ADDS     R3,R3,#+2304
   \   0000001E   0x681B             LDR      R3,[R3, #+0]
   \   00000020   0xF433 0x4300      BICS     R3,R3,#0x8000
   \   00000024   0x6003             STR      R3,[R0, #+0]
    535             USBx_DEVICE->DAINTMSK &= ~(USB_OTG_DAINTMSK_IEPM & ((1 << (ep->num))));
   \   00000026   0xF512 0x6000      ADDS     R0,R2,#+2048
   \   0000002A   0x69C0             LDR      R0,[R0, #+28]
   \   0000002C   0x2301             MOVS     R3,#+1
   \   0000002E   0xF991 0x4000      LDRSB    R4,[R1, #+0]
   \   00000032   0x40A3             LSLS     R3,R3,R4
   \   00000034   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   00000036   0x4398             BICS     R0,R0,R3
   \   00000038   0xF512 0x6300      ADDS     R3,R2,#+2048
   \   0000003C   0x61D8             STR      R0,[R3, #+28]
   \   0000003E   0xE019             B.N      ??USB_DeactivateDedicatedEndpoint_1
    536            }
    537            else
    538            {
    539               USBx_OUTEP(ep->num)->DOEPCTL &= ~USB_OTG_DOEPCTL_USBAEP; 
   \                     ??USB_DeactivateDedicatedEndpoint_0: (+1)
   \   00000040   0x7808             LDRB     R0,[R1, #+0]
   \   00000042   0xEB12 0x1040      ADDS     R0,R2,R0, LSL #+5
   \   00000046   0xF510 0x6030      ADDS     R0,R0,#+2816
   \   0000004A   0x780B             LDRB     R3,[R1, #+0]
   \   0000004C   0xEB12 0x1343      ADDS     R3,R2,R3, LSL #+5
   \   00000050   0xF513 0x6330      ADDS     R3,R3,#+2816
   \   00000054   0x681B             LDR      R3,[R3, #+0]
   \   00000056   0xF433 0x4300      BICS     R3,R3,#0x8000
   \   0000005A   0x6003             STR      R3,[R0, #+0]
    540               USBx_DEVICE->DAINTMSK &= ~(USB_OTG_DAINTMSK_OEPM & ((1 << (ep->num)) << 16));
   \   0000005C   0xF512 0x6000      ADDS     R0,R2,#+2048
   \   00000060   0x69C0             LDR      R0,[R0, #+28]
   \   00000062   0x2301             MOVS     R3,#+1
   \   00000064   0xF991 0x4000      LDRSB    R4,[R1, #+0]
   \   00000068   0x40A3             LSLS     R3,R3,R4
   \   0000006A   0xEA30 0x4003      BICS     R0,R0,R3, LSL #+16
   \   0000006E   0xF512 0x6300      ADDS     R3,R2,#+2048
   \   00000072   0x61D8             STR      R0,[R3, #+28]
    541            }
    542            return HAL_OK;
   \                     ??USB_DeactivateDedicatedEndpoint_1: (+1)
   \   00000074   0x2000             MOVS     R0,#+0
   \   00000076   0xBC10             POP      {R4}
   \   00000078   0x4770             BX       LR               ;; return
    543          }
    544          
    545          /**
    546            * @brief  USB_EPStartXfer : setup and starts a transfer over an EP
    547            * @param  USBx : Selected device
    548            * @param  ep: pointer to endpoint structure
    549            * @param  dma: USB dma enabled or disabled 
    550            *          This parameter can be one of the these values:
    551            *           0 : DMA feature not used 
    552            *           1 : DMA feature used  
    553            * @retval HAL status
    554            */

   \                                 In section .text, align 2, keep-with-next
    555          HAL_StatusTypeDef USB_EPStartXfer(USB_OTG_GlobalTypeDef *USBx , USB_OTG_EPTypeDef *ep, uint8_t dma)
    556          {
   \                     USB_EPStartXfer: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    557            uint16_t pktcnt = 0;
   \   00000008   0x2700             MOVS     R7,#+0
    558            
    559            /* IN endpoint */
    560            if (ep->is_in == 1)
   \   0000000A   0x7868             LDRB     R0,[R5, #+1]
   \   0000000C   0x2801             CMP      R0,#+1
   \   0000000E   0xF040 0x80EF      BNE.W    ??USB_EPStartXfer_0
    561            {
    562              /* Zero Length Packet? */
    563              if (ep->xfer_len == 0)
   \   00000012   0x6968             LDR      R0,[R5, #+20]
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD12A             BNE.N    ??USB_EPStartXfer_1
    564              {
    565                USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT); 
   \   00000018   0x7828             LDRB     R0,[R5, #+0]
   \   0000001A   0xEB14 0x1040      ADDS     R0,R4,R0, LSL #+5
   \   0000001E   0xF510 0x6010      ADDS     R0,R0,#+2304
   \   00000022   0x7829             LDRB     R1,[R5, #+0]
   \   00000024   0xEB14 0x1141      ADDS     R1,R4,R1, LSL #+5
   \   00000028   0xF511 0x6110      ADDS     R1,R1,#+2304
   \   0000002C   0x6909             LDR      R1,[R1, #+16]
   \   0000002E   0xF36F 0x41DC      BFC      R1,#+19,#+10
   \   00000032   0x6101             STR      R1,[R0, #+16]
    566                USBx_INEP(ep->num)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (1 << 19)) ;
   \   00000034   0x7828             LDRB     R0,[R5, #+0]
   \   00000036   0xEB14 0x1040      ADDS     R0,R4,R0, LSL #+5
   \   0000003A   0xF510 0x6010      ADDS     R0,R0,#+2304
   \   0000003E   0x7829             LDRB     R1,[R5, #+0]
   \   00000040   0xEB14 0x1141      ADDS     R1,R4,R1, LSL #+5
   \   00000044   0xF511 0x6110      ADDS     R1,R1,#+2304
   \   00000048   0x6909             LDR      R1,[R1, #+16]
   \   0000004A   0xF451 0x2100      ORRS     R1,R1,#0x80000
   \   0000004E   0x6101             STR      R1,[R0, #+16]
    567                USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ); 
   \   00000050   0x7828             LDRB     R0,[R5, #+0]
   \   00000052   0xEB14 0x1040      ADDS     R0,R4,R0, LSL #+5
   \   00000056   0xF510 0x6010      ADDS     R0,R0,#+2304
   \   0000005A   0x7829             LDRB     R1,[R5, #+0]
   \   0000005C   0xEB14 0x1141      ADDS     R1,R4,R1, LSL #+5
   \   00000060   0xF511 0x6110      ADDS     R1,R1,#+2304
   \   00000064   0x6909             LDR      R1,[R1, #+16]
   \   00000066   0x0CC9             LSRS     R1,R1,#+19
   \   00000068   0x04C9             LSLS     R1,R1,#+19
   \   0000006A   0x6101             STR      R1,[R0, #+16]
   \   0000006C   0xE062             B.N      ??USB_EPStartXfer_2
    568              }
    569              else
    570              {
    571                /* Program the transfer size and packet count
    572                * as follows: xfersize = N * maxpacket +
    573                * short_packet pktcnt = N + (short_packet
    574                * exist ? 1 : 0)
    575                */
    576                USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ);
   \                     ??USB_EPStartXfer_1: (+1)
   \   0000006E   0x7828             LDRB     R0,[R5, #+0]
   \   00000070   0xEB14 0x1040      ADDS     R0,R4,R0, LSL #+5
   \   00000074   0xF510 0x6010      ADDS     R0,R0,#+2304
   \   00000078   0x7829             LDRB     R1,[R5, #+0]
   \   0000007A   0xEB14 0x1141      ADDS     R1,R4,R1, LSL #+5
   \   0000007E   0xF511 0x6110      ADDS     R1,R1,#+2304
   \   00000082   0x6909             LDR      R1,[R1, #+16]
   \   00000084   0x0CC9             LSRS     R1,R1,#+19
   \   00000086   0x04C9             LSLS     R1,R1,#+19
   \   00000088   0x6101             STR      R1,[R0, #+16]
    577                USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT); 
   \   0000008A   0x7828             LDRB     R0,[R5, #+0]
   \   0000008C   0xEB14 0x1040      ADDS     R0,R4,R0, LSL #+5
   \   00000090   0xF510 0x6010      ADDS     R0,R0,#+2304
   \   00000094   0x7829             LDRB     R1,[R5, #+0]
   \   00000096   0xEB14 0x1141      ADDS     R1,R4,R1, LSL #+5
   \   0000009A   0xF511 0x6110      ADDS     R1,R1,#+2304
   \   0000009E   0x6909             LDR      R1,[R1, #+16]
   \   000000A0   0xF36F 0x41DC      BFC      R1,#+19,#+10
   \   000000A4   0x6101             STR      R1,[R0, #+16]
    578                USBx_INEP(ep->num)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (((ep->xfer_len + ep->maxpacket -1)/ ep->maxpacket) << 19)) ;
   \   000000A6   0x7828             LDRB     R0,[R5, #+0]
   \   000000A8   0xEB14 0x1040      ADDS     R0,R4,R0, LSL #+5
   \   000000AC   0xF510 0x6010      ADDS     R0,R0,#+2304
   \   000000B0   0x7829             LDRB     R1,[R5, #+0]
   \   000000B2   0xEB14 0x1141      ADDS     R1,R4,R1, LSL #+5
   \   000000B6   0xF511 0x6110      ADDS     R1,R1,#+2304
   \   000000BA   0x6909             LDR      R1,[R1, #+16]
   \   000000BC   0x696A             LDR      R2,[R5, #+20]
   \   000000BE   0x68AB             LDR      R3,[R5, #+8]
   \   000000C0   0x189A             ADDS     R2,R3,R2
   \   000000C2   0x1E52             SUBS     R2,R2,#+1
   \   000000C4   0x68AB             LDR      R3,[R5, #+8]
   \   000000C6   0xFBB2 0xF2F3      UDIV     R2,R2,R3
   \   000000CA   0x.... 0x....      LDR.W    R3,??DataTable8  ;; 0x1ff80000
   \   000000CE   0xEA13 0x42C2      ANDS     R2,R3,R2, LSL #+19
   \   000000D2   0x4311             ORRS     R1,R2,R1
   \   000000D4   0x6101             STR      R1,[R0, #+16]
    579                USBx_INEP(ep->num)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_XFRSIZ & ep->xfer_len); 
   \   000000D6   0x7828             LDRB     R0,[R5, #+0]
   \   000000D8   0xEB14 0x1040      ADDS     R0,R4,R0, LSL #+5
   \   000000DC   0xF510 0x6010      ADDS     R0,R0,#+2304
   \   000000E0   0x7829             LDRB     R1,[R5, #+0]
   \   000000E2   0xEB14 0x1141      ADDS     R1,R4,R1, LSL #+5
   \   000000E6   0xF511 0x6110      ADDS     R1,R1,#+2304
   \   000000EA   0x6909             LDR      R1,[R1, #+16]
   \   000000EC   0x696A             LDR      R2,[R5, #+20]
   \   000000EE   0x0352             LSLS     R2,R2,#+13       ;; ZeroExtS R2,R2,#+13,#+13
   \   000000F0   0x0B52             LSRS     R2,R2,#+13
   \   000000F2   0x4311             ORRS     R1,R2,R1
   \   000000F4   0x6101             STR      R1,[R0, #+16]
    580                
    581                if (ep->type == EP_TYPE_ISOC)
   \   000000F6   0x78E8             LDRB     R0,[R5, #+3]
   \   000000F8   0x2801             CMP      R0,#+1
   \   000000FA   0xD11B             BNE.N    ??USB_EPStartXfer_2
    582                {
    583                  USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_MULCNT); 
   \   000000FC   0x7828             LDRB     R0,[R5, #+0]
   \   000000FE   0xEB14 0x1040      ADDS     R0,R4,R0, LSL #+5
   \   00000102   0xF510 0x6010      ADDS     R0,R0,#+2304
   \   00000106   0x7829             LDRB     R1,[R5, #+0]
   \   00000108   0xEB14 0x1141      ADDS     R1,R4,R1, LSL #+5
   \   0000010C   0xF511 0x6110      ADDS     R1,R1,#+2304
   \   00000110   0x6909             LDR      R1,[R1, #+16]
   \   00000112   0xF031 0x41C0      BICS     R1,R1,#0x60000000
   \   00000116   0x6101             STR      R1,[R0, #+16]
    584                  USBx_INEP(ep->num)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_MULCNT & (1 << 29)); 
   \   00000118   0x7828             LDRB     R0,[R5, #+0]
   \   0000011A   0xEB14 0x1040      ADDS     R0,R4,R0, LSL #+5
   \   0000011E   0xF510 0x6010      ADDS     R0,R0,#+2304
   \   00000122   0x7829             LDRB     R1,[R5, #+0]
   \   00000124   0xEB14 0x1141      ADDS     R1,R4,R1, LSL #+5
   \   00000128   0xF511 0x6110      ADDS     R1,R1,#+2304
   \   0000012C   0x6909             LDR      R1,[R1, #+16]
   \   0000012E   0xF051 0x5100      ORRS     R1,R1,#0x20000000
   \   00000132   0x6101             STR      R1,[R0, #+16]
    585                }       
    586              }
    587          
    588              if (dma == 1)
   \                     ??USB_EPStartXfer_2: (+1)
   \   00000134   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000136   0x2E01             CMP      R6,#+1
   \   00000138   0xD107             BNE.N    ??USB_EPStartXfer_3
    589              {
    590                USBx_INEP(ep->num)->DIEPDMA = (uint32_t)(ep->dma_addr);
   \   0000013A   0x7828             LDRB     R0,[R5, #+0]
   \   0000013C   0xEB14 0x1040      ADDS     R0,R4,R0, LSL #+5
   \   00000140   0xF510 0x6010      ADDS     R0,R0,#+2304
   \   00000144   0x6929             LDR      R1,[R5, #+16]
   \   00000146   0x6141             STR      R1,[R0, #+20]
   \   00000148   0xE010             B.N      ??USB_EPStartXfer_4
    591              }
    592              else
    593              {
    594                if (ep->type != EP_TYPE_ISOC)
   \                     ??USB_EPStartXfer_3: (+1)
   \   0000014A   0x78E8             LDRB     R0,[R5, #+3]
   \   0000014C   0x2801             CMP      R0,#+1
   \   0000014E   0xD00D             BEQ.N    ??USB_EPStartXfer_4
    595                {
    596                  /* Enable the Tx FIFO Empty Interrupt for this EP */
    597                  if (ep->xfer_len > 0)
   \   00000150   0x6968             LDR      R0,[R5, #+20]
   \   00000152   0x2800             CMP      R0,#+0
   \   00000154   0xD00A             BEQ.N    ??USB_EPStartXfer_4
    598                  {
    599                    USBx_DEVICE->DIEPEMPMSK |= 1 << ep->num;
   \   00000156   0xF514 0x6000      ADDS     R0,R4,#+2048
   \   0000015A   0x6B40             LDR      R0,[R0, #+52]
   \   0000015C   0x2101             MOVS     R1,#+1
   \   0000015E   0xF995 0x2000      LDRSB    R2,[R5, #+0]
   \   00000162   0x4091             LSLS     R1,R1,R2
   \   00000164   0x4308             ORRS     R0,R1,R0
   \   00000166   0xF514 0x6100      ADDS     R1,R4,#+2048
   \   0000016A   0x6348             STR      R0,[R1, #+52]
    600                  }
    601                }
    602              }
    603          
    604              if (ep->type == EP_TYPE_ISOC)
   \                     ??USB_EPStartXfer_4: (+1)
   \   0000016C   0x78E8             LDRB     R0,[R5, #+3]
   \   0000016E   0x2801             CMP      R0,#+1
   \   00000170   0xD121             BNE.N    ??USB_EPStartXfer_5
    605              {
    606                if ((USBx_DEVICE->DSTS & ( 1 << 8 )) == 0)
   \   00000172   0xF514 0x6000      ADDS     R0,R4,#+2048
   \   00000176   0x6880             LDR      R0,[R0, #+8]
   \   00000178   0x05C0             LSLS     R0,R0,#+23
   \   0000017A   0xD40E             BMI.N    ??USB_EPStartXfer_6
    607                {
    608                  USBx_INEP(ep->num)->DIEPCTL |= USB_OTG_DIEPCTL_SODDFRM;
   \   0000017C   0x7828             LDRB     R0,[R5, #+0]
   \   0000017E   0xEB14 0x1040      ADDS     R0,R4,R0, LSL #+5
   \   00000182   0xF510 0x6010      ADDS     R0,R0,#+2304
   \   00000186   0x7829             LDRB     R1,[R5, #+0]
   \   00000188   0xEB14 0x1141      ADDS     R1,R4,R1, LSL #+5
   \   0000018C   0xF511 0x6110      ADDS     R1,R1,#+2304
   \   00000190   0x6809             LDR      R1,[R1, #+0]
   \   00000192   0xF051 0x5100      ORRS     R1,R1,#0x20000000
   \   00000196   0x6001             STR      R1,[R0, #+0]
   \   00000198   0xE00D             B.N      ??USB_EPStartXfer_5
    609                }
    610                else
    611                {
    612                  USBx_INEP(ep->num)->DIEPCTL |= USB_OTG_DIEPCTL_SD0PID_SEVNFRM;
   \                     ??USB_EPStartXfer_6: (+1)
   \   0000019A   0x7828             LDRB     R0,[R5, #+0]
   \   0000019C   0xEB14 0x1040      ADDS     R0,R4,R0, LSL #+5
   \   000001A0   0xF510 0x6010      ADDS     R0,R0,#+2304
   \   000001A4   0x7829             LDRB     R1,[R5, #+0]
   \   000001A6   0xEB14 0x1141      ADDS     R1,R4,R1, LSL #+5
   \   000001AA   0xF511 0x6110      ADDS     R1,R1,#+2304
   \   000001AE   0x6809             LDR      R1,[R1, #+0]
   \   000001B0   0xF051 0x5180      ORRS     R1,R1,#0x10000000
   \   000001B4   0x6001             STR      R1,[R0, #+0]
    613                }
    614              } 
    615              
    616              /* EP enable, IN data in FIFO */
    617              USBx_INEP(ep->num)->DIEPCTL |= (USB_OTG_DIEPCTL_CNAK | USB_OTG_DIEPCTL_EPENA);
   \                     ??USB_EPStartXfer_5: (+1)
   \   000001B6   0x7828             LDRB     R0,[R5, #+0]
   \   000001B8   0xEB14 0x1040      ADDS     R0,R4,R0, LSL #+5
   \   000001BC   0xF510 0x6010      ADDS     R0,R0,#+2304
   \   000001C0   0x7829             LDRB     R1,[R5, #+0]
   \   000001C2   0xEB14 0x1141      ADDS     R1,R4,R1, LSL #+5
   \   000001C6   0xF511 0x6110      ADDS     R1,R1,#+2304
   \   000001CA   0x6809             LDR      R1,[R1, #+0]
   \   000001CC   0xF051 0x4104      ORRS     R1,R1,#0x84000000
   \   000001D0   0x6001             STR      R1,[R0, #+0]
    618              
    619              if (ep->type == EP_TYPE_ISOC)
   \   000001D2   0x78E8             LDRB     R0,[R5, #+3]
   \   000001D4   0x2801             CMP      R0,#+1
   \   000001D6   0xF040 0x80B2      BNE.W    ??USB_EPStartXfer_7
    620              {
    621                USB_WritePacket(USBx, ep->xfer_buff, ep->num, ep->xfer_len, dma);   
   \   000001DA   0x0030             MOVS     R0,R6
   \   000001DC   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000001DE   0x9000             STR      R0,[SP, #+0]
   \   000001E0   0x696B             LDR      R3,[R5, #+20]
   \   000001E2   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   000001E4   0x782A             LDRB     R2,[R5, #+0]
   \   000001E6   0x68E9             LDR      R1,[R5, #+12]
   \   000001E8   0x0020             MOVS     R0,R4
   \   000001EA   0x.... 0x....      BL       USB_WritePacket
   \   000001EE   0xE0A6             B.N      ??USB_EPStartXfer_7
    622              }    
    623            }
    624            else /* OUT endpoint */
    625            {
    626              /* Program the transfer size and packet count as follows:
    627              * pktcnt = N
    628              * xfersize = N * maxpacket
    629              */  
    630              USBx_OUTEP(ep->num)->DOEPTSIZ &= ~(USB_OTG_DOEPTSIZ_XFRSIZ); 
   \                     ??USB_EPStartXfer_0: (+1)
   \   000001F0   0x7828             LDRB     R0,[R5, #+0]
   \   000001F2   0xEB14 0x1040      ADDS     R0,R4,R0, LSL #+5
   \   000001F6   0xF510 0x6030      ADDS     R0,R0,#+2816
   \   000001FA   0x7829             LDRB     R1,[R5, #+0]
   \   000001FC   0xEB14 0x1141      ADDS     R1,R4,R1, LSL #+5
   \   00000200   0xF511 0x6130      ADDS     R1,R1,#+2816
   \   00000204   0x6909             LDR      R1,[R1, #+16]
   \   00000206   0x0CC9             LSRS     R1,R1,#+19
   \   00000208   0x04C9             LSLS     R1,R1,#+19
   \   0000020A   0x6101             STR      R1,[R0, #+16]
    631              USBx_OUTEP(ep->num)->DOEPTSIZ &= ~(USB_OTG_DOEPTSIZ_PKTCNT); 
   \   0000020C   0x7828             LDRB     R0,[R5, #+0]
   \   0000020E   0xEB14 0x1040      ADDS     R0,R4,R0, LSL #+5
   \   00000212   0xF510 0x6030      ADDS     R0,R0,#+2816
   \   00000216   0x7829             LDRB     R1,[R5, #+0]
   \   00000218   0xEB14 0x1141      ADDS     R1,R4,R1, LSL #+5
   \   0000021C   0xF511 0x6130      ADDS     R1,R1,#+2816
   \   00000220   0x6909             LDR      R1,[R1, #+16]
   \   00000222   0xF36F 0x41DC      BFC      R1,#+19,#+10
   \   00000226   0x6101             STR      R1,[R0, #+16]
    632                
    633              if (ep->xfer_len == 0)
   \   00000228   0x6968             LDR      R0,[R5, #+20]
   \   0000022A   0x2800             CMP      R0,#+0
   \   0000022C   0xD11E             BNE.N    ??USB_EPStartXfer_8
    634              {
    635                USBx_OUTEP(ep->num)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_XFRSIZ & ep->maxpacket);
   \   0000022E   0x7828             LDRB     R0,[R5, #+0]
   \   00000230   0xEB14 0x1040      ADDS     R0,R4,R0, LSL #+5
   \   00000234   0xF510 0x6030      ADDS     R0,R0,#+2816
   \   00000238   0x7829             LDRB     R1,[R5, #+0]
   \   0000023A   0xEB14 0x1141      ADDS     R1,R4,R1, LSL #+5
   \   0000023E   0xF511 0x6130      ADDS     R1,R1,#+2816
   \   00000242   0x6909             LDR      R1,[R1, #+16]
   \   00000244   0x68AA             LDR      R2,[R5, #+8]
   \   00000246   0x0352             LSLS     R2,R2,#+13       ;; ZeroExtS R2,R2,#+13,#+13
   \   00000248   0x0B52             LSRS     R2,R2,#+13
   \   0000024A   0x4311             ORRS     R1,R2,R1
   \   0000024C   0x6101             STR      R1,[R0, #+16]
    636                USBx_OUTEP(ep->num)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (1 << 19)) ;      
   \   0000024E   0x7828             LDRB     R0,[R5, #+0]
   \   00000250   0xEB14 0x1040      ADDS     R0,R4,R0, LSL #+5
   \   00000254   0xF510 0x6030      ADDS     R0,R0,#+2816
   \   00000258   0x7829             LDRB     R1,[R5, #+0]
   \   0000025A   0xEB14 0x1141      ADDS     R1,R4,R1, LSL #+5
   \   0000025E   0xF511 0x6130      ADDS     R1,R1,#+2816
   \   00000262   0x6909             LDR      R1,[R1, #+16]
   \   00000264   0xF451 0x2100      ORRS     R1,R1,#0x80000
   \   00000268   0x6101             STR      R1,[R0, #+16]
   \   0000026A   0xE02B             B.N      ??USB_EPStartXfer_9
    637              }
    638              else
    639              {
    640                pktcnt = (ep->xfer_len + ep->maxpacket -1)/ ep->maxpacket; 
   \                     ??USB_EPStartXfer_8: (+1)
   \   0000026C   0x6968             LDR      R0,[R5, #+20]
   \   0000026E   0x68A9             LDR      R1,[R5, #+8]
   \   00000270   0x1808             ADDS     R0,R1,R0
   \   00000272   0x1E40             SUBS     R0,R0,#+1
   \   00000274   0x68A9             LDR      R1,[R5, #+8]
   \   00000276   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   0000027A   0x0007             MOVS     R7,R0
    641                USBx_OUTEP(ep->num)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (pktcnt << 19));
   \   0000027C   0x7828             LDRB     R0,[R5, #+0]
   \   0000027E   0xEB14 0x1040      ADDS     R0,R4,R0, LSL #+5
   \   00000282   0xF510 0x6030      ADDS     R0,R0,#+2816
   \   00000286   0x7829             LDRB     R1,[R5, #+0]
   \   00000288   0xEB14 0x1141      ADDS     R1,R4,R1, LSL #+5
   \   0000028C   0xF511 0x6130      ADDS     R1,R1,#+2816
   \   00000290   0x6909             LDR      R1,[R1, #+16]
   \   00000292   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000294   0x.... 0x....      LDR.W    R2,??DataTable8  ;; 0x1ff80000
   \   00000298   0xEA12 0x42C7      ANDS     R2,R2,R7, LSL #+19
   \   0000029C   0x4311             ORRS     R1,R2,R1
   \   0000029E   0x6101             STR      R1,[R0, #+16]
    642                USBx_OUTEP(ep->num)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_XFRSIZ & (ep->maxpacket * pktcnt)); 
   \   000002A0   0x7828             LDRB     R0,[R5, #+0]
   \   000002A2   0xEB14 0x1040      ADDS     R0,R4,R0, LSL #+5
   \   000002A6   0xF510 0x6030      ADDS     R0,R0,#+2816
   \   000002AA   0x7829             LDRB     R1,[R5, #+0]
   \   000002AC   0xEB14 0x1141      ADDS     R1,R4,R1, LSL #+5
   \   000002B0   0xF511 0x6130      ADDS     R1,R1,#+2816
   \   000002B4   0x6909             LDR      R1,[R1, #+16]
   \   000002B6   0x68AA             LDR      R2,[R5, #+8]
   \   000002B8   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   000002BA   0x437A             MULS     R2,R7,R2
   \   000002BC   0x0352             LSLS     R2,R2,#+13       ;; ZeroExtS R2,R2,#+13,#+13
   \   000002BE   0x0B52             LSRS     R2,R2,#+13
   \   000002C0   0x4311             ORRS     R1,R2,R1
   \   000002C2   0x6101             STR      R1,[R0, #+16]
    643              }
    644          
    645              if (dma == 1)
   \                     ??USB_EPStartXfer_9: (+1)
   \   000002C4   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000002C6   0x2E01             CMP      R6,#+1
   \   000002C8   0xD106             BNE.N    ??USB_EPStartXfer_10
    646              {
    647                USBx_OUTEP(ep->num)->DOEPDMA = (uint32_t)ep->xfer_buff;
   \   000002CA   0x7828             LDRB     R0,[R5, #+0]
   \   000002CC   0xEB14 0x1040      ADDS     R0,R4,R0, LSL #+5
   \   000002D0   0xF510 0x6030      ADDS     R0,R0,#+2816
   \   000002D4   0x68E9             LDR      R1,[R5, #+12]
   \   000002D6   0x6141             STR      R1,[R0, #+20]
    648              }
    649              
    650              if (ep->type == EP_TYPE_ISOC)
   \                     ??USB_EPStartXfer_10: (+1)
   \   000002D8   0x78E8             LDRB     R0,[R5, #+3]
   \   000002DA   0x2801             CMP      R0,#+1
   \   000002DC   0xD121             BNE.N    ??USB_EPStartXfer_11
    651              {
    652                if ((USBx_DEVICE->DSTS & ( 1 << 8 )) == 0)
   \   000002DE   0xF514 0x6000      ADDS     R0,R4,#+2048
   \   000002E2   0x6880             LDR      R0,[R0, #+8]
   \   000002E4   0x05C0             LSLS     R0,R0,#+23
   \   000002E6   0xD40E             BMI.N    ??USB_EPStartXfer_12
    653                {
    654                  USBx_OUTEP(ep->num)->DOEPCTL |= USB_OTG_DOEPCTL_SODDFRM;
   \   000002E8   0x7828             LDRB     R0,[R5, #+0]
   \   000002EA   0xEB14 0x1040      ADDS     R0,R4,R0, LSL #+5
   \   000002EE   0xF510 0x6030      ADDS     R0,R0,#+2816
   \   000002F2   0x7829             LDRB     R1,[R5, #+0]
   \   000002F4   0xEB14 0x1141      ADDS     R1,R4,R1, LSL #+5
   \   000002F8   0xF511 0x6130      ADDS     R1,R1,#+2816
   \   000002FC   0x6809             LDR      R1,[R1, #+0]
   \   000002FE   0xF051 0x5100      ORRS     R1,R1,#0x20000000
   \   00000302   0x6001             STR      R1,[R0, #+0]
   \   00000304   0xE00D             B.N      ??USB_EPStartXfer_11
    655                }
    656                else
    657                {
    658                  USBx_OUTEP(ep->num)->DOEPCTL |= USB_OTG_DOEPCTL_SD0PID_SEVNFRM;
   \                     ??USB_EPStartXfer_12: (+1)
   \   00000306   0x7828             LDRB     R0,[R5, #+0]
   \   00000308   0xEB14 0x1040      ADDS     R0,R4,R0, LSL #+5
   \   0000030C   0xF510 0x6030      ADDS     R0,R0,#+2816
   \   00000310   0x7829             LDRB     R1,[R5, #+0]
   \   00000312   0xEB14 0x1141      ADDS     R1,R4,R1, LSL #+5
   \   00000316   0xF511 0x6130      ADDS     R1,R1,#+2816
   \   0000031A   0x6809             LDR      R1,[R1, #+0]
   \   0000031C   0xF051 0x5180      ORRS     R1,R1,#0x10000000
   \   00000320   0x6001             STR      R1,[R0, #+0]
    659                }
    660              }
    661              /* EP enable */
    662              USBx_OUTEP(ep->num)->DOEPCTL |= (USB_OTG_DOEPCTL_CNAK | USB_OTG_DOEPCTL_EPENA);
   \                     ??USB_EPStartXfer_11: (+1)
   \   00000322   0x7828             LDRB     R0,[R5, #+0]
   \   00000324   0xEB14 0x1040      ADDS     R0,R4,R0, LSL #+5
   \   00000328   0xF510 0x6030      ADDS     R0,R0,#+2816
   \   0000032C   0x7829             LDRB     R1,[R5, #+0]
   \   0000032E   0xEB14 0x1141      ADDS     R1,R4,R1, LSL #+5
   \   00000332   0xF511 0x6130      ADDS     R1,R1,#+2816
   \   00000336   0x6809             LDR      R1,[R1, #+0]
   \   00000338   0xF051 0x4104      ORRS     R1,R1,#0x84000000
   \   0000033C   0x6001             STR      R1,[R0, #+0]
    663            }
    664            return HAL_OK;
   \                     ??USB_EPStartXfer_7: (+1)
   \   0000033E   0x2000             MOVS     R0,#+0
   \   00000340   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    665          }
    666          
    667          /**
    668            * @brief  USB_EP0StartXfer : setup and starts a transfer over the EP  0
    669            * @param  USBx : Selected device
    670            * @param  ep: pointer to endpoint structure
    671            * @param  dma: USB dma enabled or disabled 
    672            *          This parameter can be one of the these values:
    673            *           0 : DMA feature not used 
    674            *           1 : DMA feature used  
    675            * @retval HAL status
    676            */

   \                                 In section .text, align 2, keep-with-next
    677          HAL_StatusTypeDef USB_EP0StartXfer(USB_OTG_GlobalTypeDef *USBx , USB_OTG_EPTypeDef *ep, uint8_t dma)
    678          {
   \                     USB_EP0StartXfer: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
   \   00000002   0x0003             MOVS     R3,R0
    679            /* IN endpoint */
    680            if (ep->is_in == 1)
   \   00000004   0x7848             LDRB     R0,[R1, #+1]
   \   00000006   0x2801             CMP      R0,#+1
   \   00000008   0xF040 0x8096      BNE.W    ??USB_EP0StartXfer_0
    681            {
    682              /* Zero Length Packet? */
    683              if (ep->xfer_len == 0)
   \   0000000C   0x6948             LDR      R0,[R1, #+20]
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD12A             BNE.N    ??USB_EP0StartXfer_1
    684              {
    685                USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT); 
   \   00000012   0x7808             LDRB     R0,[R1, #+0]
   \   00000014   0xEB13 0x1040      ADDS     R0,R3,R0, LSL #+5
   \   00000018   0xF510 0x6010      ADDS     R0,R0,#+2304
   \   0000001C   0x780C             LDRB     R4,[R1, #+0]
   \   0000001E   0xEB13 0x1444      ADDS     R4,R3,R4, LSL #+5
   \   00000022   0xF514 0x6410      ADDS     R4,R4,#+2304
   \   00000026   0x6924             LDR      R4,[R4, #+16]
   \   00000028   0xF36F 0x44DC      BFC      R4,#+19,#+10
   \   0000002C   0x6104             STR      R4,[R0, #+16]
    686                USBx_INEP(ep->num)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (1 << 19)) ;
   \   0000002E   0x7808             LDRB     R0,[R1, #+0]
   \   00000030   0xEB13 0x1040      ADDS     R0,R3,R0, LSL #+5
   \   00000034   0xF510 0x6010      ADDS     R0,R0,#+2304
   \   00000038   0x780C             LDRB     R4,[R1, #+0]
   \   0000003A   0xEB13 0x1444      ADDS     R4,R3,R4, LSL #+5
   \   0000003E   0xF514 0x6410      ADDS     R4,R4,#+2304
   \   00000042   0x6924             LDR      R4,[R4, #+16]
   \   00000044   0xF454 0x2400      ORRS     R4,R4,#0x80000
   \   00000048   0x6104             STR      R4,[R0, #+16]
    687                USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ); 
   \   0000004A   0x7808             LDRB     R0,[R1, #+0]
   \   0000004C   0xEB13 0x1040      ADDS     R0,R3,R0, LSL #+5
   \   00000050   0xF510 0x6010      ADDS     R0,R0,#+2304
   \   00000054   0x780C             LDRB     R4,[R1, #+0]
   \   00000056   0xEB13 0x1444      ADDS     R4,R3,R4, LSL #+5
   \   0000005A   0xF514 0x6410      ADDS     R4,R4,#+2304
   \   0000005E   0x6924             LDR      R4,[R4, #+16]
   \   00000060   0x0CE4             LSRS     R4,R4,#+19
   \   00000062   0x04E4             LSLS     R4,R4,#+19
   \   00000064   0x6104             STR      R4,[R0, #+16]
   \   00000066   0xE03F             B.N      ??USB_EP0StartXfer_2
    688              }
    689              else
    690              {
    691                /* Program the transfer size and packet count
    692                * as follows: xfersize = N * maxpacket +
    693                * short_packet pktcnt = N + (short_packet
    694                * exist ? 1 : 0)
    695                */
    696                USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ);
   \                     ??USB_EP0StartXfer_1: (+1)
   \   00000068   0x7808             LDRB     R0,[R1, #+0]
   \   0000006A   0xEB13 0x1040      ADDS     R0,R3,R0, LSL #+5
   \   0000006E   0xF510 0x6010      ADDS     R0,R0,#+2304
   \   00000072   0x780C             LDRB     R4,[R1, #+0]
   \   00000074   0xEB13 0x1444      ADDS     R4,R3,R4, LSL #+5
   \   00000078   0xF514 0x6410      ADDS     R4,R4,#+2304
   \   0000007C   0x6924             LDR      R4,[R4, #+16]
   \   0000007E   0x0CE4             LSRS     R4,R4,#+19
   \   00000080   0x04E4             LSLS     R4,R4,#+19
   \   00000082   0x6104             STR      R4,[R0, #+16]
    697                USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT); 
   \   00000084   0x7808             LDRB     R0,[R1, #+0]
   \   00000086   0xEB13 0x1040      ADDS     R0,R3,R0, LSL #+5
   \   0000008A   0xF510 0x6010      ADDS     R0,R0,#+2304
   \   0000008E   0x780C             LDRB     R4,[R1, #+0]
   \   00000090   0xEB13 0x1444      ADDS     R4,R3,R4, LSL #+5
   \   00000094   0xF514 0x6410      ADDS     R4,R4,#+2304
   \   00000098   0x6924             LDR      R4,[R4, #+16]
   \   0000009A   0xF36F 0x44DC      BFC      R4,#+19,#+10
   \   0000009E   0x6104             STR      R4,[R0, #+16]
    698                
    699                if(ep->xfer_len > ep->maxpacket)
   \   000000A0   0x6888             LDR      R0,[R1, #+8]
   \   000000A2   0x694C             LDR      R4,[R1, #+20]
   \   000000A4   0x42A0             CMP      R0,R4
   \   000000A6   0xD201             BCS.N    ??USB_EP0StartXfer_3
    700                {
    701                  ep->xfer_len = ep->maxpacket;
   \   000000A8   0x6888             LDR      R0,[R1, #+8]
   \   000000AA   0x6148             STR      R0,[R1, #+20]
    702                }
    703                USBx_INEP(ep->num)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (1 << 19)) ;
   \                     ??USB_EP0StartXfer_3: (+1)
   \   000000AC   0x7808             LDRB     R0,[R1, #+0]
   \   000000AE   0xEB13 0x1040      ADDS     R0,R3,R0, LSL #+5
   \   000000B2   0xF510 0x6010      ADDS     R0,R0,#+2304
   \   000000B6   0x780C             LDRB     R4,[R1, #+0]
   \   000000B8   0xEB13 0x1444      ADDS     R4,R3,R4, LSL #+5
   \   000000BC   0xF514 0x6410      ADDS     R4,R4,#+2304
   \   000000C0   0x6924             LDR      R4,[R4, #+16]
   \   000000C2   0xF454 0x2400      ORRS     R4,R4,#0x80000
   \   000000C6   0x6104             STR      R4,[R0, #+16]
    704                USBx_INEP(ep->num)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_XFRSIZ & ep->xfer_len); 
   \   000000C8   0x7808             LDRB     R0,[R1, #+0]
   \   000000CA   0xEB13 0x1040      ADDS     R0,R3,R0, LSL #+5
   \   000000CE   0xF510 0x6010      ADDS     R0,R0,#+2304
   \   000000D2   0x780C             LDRB     R4,[R1, #+0]
   \   000000D4   0xEB13 0x1444      ADDS     R4,R3,R4, LSL #+5
   \   000000D8   0xF514 0x6410      ADDS     R4,R4,#+2304
   \   000000DC   0x6924             LDR      R4,[R4, #+16]
   \   000000DE   0x694D             LDR      R5,[R1, #+20]
   \   000000E0   0x036D             LSLS     R5,R5,#+13       ;; ZeroExtS R5,R5,#+13,#+13
   \   000000E2   0x0B6D             LSRS     R5,R5,#+13
   \   000000E4   0x432C             ORRS     R4,R5,R4
   \   000000E6   0x6104             STR      R4,[R0, #+16]
    705              
    706              }
    707              
    708              if (dma == 1)
   \                     ??USB_EP0StartXfer_2: (+1)
   \   000000E8   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   000000EA   0x2A01             CMP      R2,#+1
   \   000000EC   0xD107             BNE.N    ??USB_EP0StartXfer_4
    709              {
    710                USBx_INEP(ep->num)->DIEPDMA = (uint32_t)(ep->dma_addr);
   \   000000EE   0x7808             LDRB     R0,[R1, #+0]
   \   000000F0   0xEB13 0x1040      ADDS     R0,R3,R0, LSL #+5
   \   000000F4   0xF510 0x6010      ADDS     R0,R0,#+2304
   \   000000F8   0x690C             LDR      R4,[R1, #+16]
   \   000000FA   0x6144             STR      R4,[R0, #+20]
   \   000000FC   0xE00D             B.N      ??USB_EP0StartXfer_5
    711              }
    712              else
    713              {
    714                /* Enable the Tx FIFO Empty Interrupt for this EP */
    715                if (ep->xfer_len > 0)
   \                     ??USB_EP0StartXfer_4: (+1)
   \   000000FE   0x6948             LDR      R0,[R1, #+20]
   \   00000100   0x2800             CMP      R0,#+0
   \   00000102   0xD00A             BEQ.N    ??USB_EP0StartXfer_5
    716                {
    717                  USBx_DEVICE->DIEPEMPMSK |= 1 << (ep->num);
   \   00000104   0xF513 0x6000      ADDS     R0,R3,#+2048
   \   00000108   0x6B40             LDR      R0,[R0, #+52]
   \   0000010A   0x2401             MOVS     R4,#+1
   \   0000010C   0xF991 0x5000      LDRSB    R5,[R1, #+0]
   \   00000110   0x40AC             LSLS     R4,R4,R5
   \   00000112   0x4320             ORRS     R0,R4,R0
   \   00000114   0xF513 0x6400      ADDS     R4,R3,#+2048
   \   00000118   0x6360             STR      R0,[R4, #+52]
    718                }
    719              }
    720              
    721              /* EP enable, IN data in FIFO */
    722              USBx_INEP(ep->num)->DIEPCTL |= (USB_OTG_DIEPCTL_CNAK | USB_OTG_DIEPCTL_EPENA);   
   \                     ??USB_EP0StartXfer_5: (+1)
   \   0000011A   0x7808             LDRB     R0,[R1, #+0]
   \   0000011C   0xEB13 0x1040      ADDS     R0,R3,R0, LSL #+5
   \   00000120   0xF510 0x6010      ADDS     R0,R0,#+2304
   \   00000124   0x780C             LDRB     R4,[R1, #+0]
   \   00000126   0xEB13 0x1444      ADDS     R4,R3,R4, LSL #+5
   \   0000012A   0xF514 0x6410      ADDS     R4,R4,#+2304
   \   0000012E   0x6824             LDR      R4,[R4, #+0]
   \   00000130   0xF054 0x4404      ORRS     R4,R4,#0x84000000
   \   00000134   0x6004             STR      R4,[R0, #+0]
   \   00000136   0xE056             B.N      ??USB_EP0StartXfer_6
    723            }
    724            else /* OUT endpoint */
    725            {
    726              /* Program the transfer size and packet count as follows:
    727              * pktcnt = N
    728              * xfersize = N * maxpacket
    729              */
    730              USBx_OUTEP(ep->num)->DOEPTSIZ &= ~(USB_OTG_DOEPTSIZ_XFRSIZ); 
   \                     ??USB_EP0StartXfer_0: (+1)
   \   00000138   0x7808             LDRB     R0,[R1, #+0]
   \   0000013A   0xEB13 0x1040      ADDS     R0,R3,R0, LSL #+5
   \   0000013E   0xF510 0x6030      ADDS     R0,R0,#+2816
   \   00000142   0x780C             LDRB     R4,[R1, #+0]
   \   00000144   0xEB13 0x1444      ADDS     R4,R3,R4, LSL #+5
   \   00000148   0xF514 0x6430      ADDS     R4,R4,#+2816
   \   0000014C   0x6924             LDR      R4,[R4, #+16]
   \   0000014E   0x0CE4             LSRS     R4,R4,#+19
   \   00000150   0x04E4             LSLS     R4,R4,#+19
   \   00000152   0x6104             STR      R4,[R0, #+16]
    731              USBx_OUTEP(ep->num)->DOEPTSIZ &= ~(USB_OTG_DOEPTSIZ_PKTCNT); 
   \   00000154   0x7808             LDRB     R0,[R1, #+0]
   \   00000156   0xEB13 0x1040      ADDS     R0,R3,R0, LSL #+5
   \   0000015A   0xF510 0x6030      ADDS     R0,R0,#+2816
   \   0000015E   0x780C             LDRB     R4,[R1, #+0]
   \   00000160   0xEB13 0x1444      ADDS     R4,R3,R4, LSL #+5
   \   00000164   0xF514 0x6430      ADDS     R4,R4,#+2816
   \   00000168   0x6924             LDR      R4,[R4, #+16]
   \   0000016A   0xF36F 0x44DC      BFC      R4,#+19,#+10
   \   0000016E   0x6104             STR      R4,[R0, #+16]
    732                
    733              if (ep->xfer_len > 0)
   \   00000170   0x6948             LDR      R0,[R1, #+20]
   \   00000172   0x2800             CMP      R0,#+0
   \   00000174   0xD001             BEQ.N    ??USB_EP0StartXfer_7
    734              {
    735                ep->xfer_len = ep->maxpacket;
   \   00000176   0x6888             LDR      R0,[R1, #+8]
   \   00000178   0x6148             STR      R0,[R1, #+20]
    736              }
    737              
    738              USBx_OUTEP(ep->num)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (1 << 19));
   \                     ??USB_EP0StartXfer_7: (+1)
   \   0000017A   0x7808             LDRB     R0,[R1, #+0]
   \   0000017C   0xEB13 0x1040      ADDS     R0,R3,R0, LSL #+5
   \   00000180   0xF510 0x6030      ADDS     R0,R0,#+2816
   \   00000184   0x780C             LDRB     R4,[R1, #+0]
   \   00000186   0xEB13 0x1444      ADDS     R4,R3,R4, LSL #+5
   \   0000018A   0xF514 0x6430      ADDS     R4,R4,#+2816
   \   0000018E   0x6924             LDR      R4,[R4, #+16]
   \   00000190   0xF454 0x2400      ORRS     R4,R4,#0x80000
   \   00000194   0x6104             STR      R4,[R0, #+16]
    739              USBx_OUTEP(ep->num)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_XFRSIZ & (ep->maxpacket)); 
   \   00000196   0x7808             LDRB     R0,[R1, #+0]
   \   00000198   0xEB13 0x1040      ADDS     R0,R3,R0, LSL #+5
   \   0000019C   0xF510 0x6030      ADDS     R0,R0,#+2816
   \   000001A0   0x780C             LDRB     R4,[R1, #+0]
   \   000001A2   0xEB13 0x1444      ADDS     R4,R3,R4, LSL #+5
   \   000001A6   0xF514 0x6430      ADDS     R4,R4,#+2816
   \   000001AA   0x6924             LDR      R4,[R4, #+16]
   \   000001AC   0x688D             LDR      R5,[R1, #+8]
   \   000001AE   0x036D             LSLS     R5,R5,#+13       ;; ZeroExtS R5,R5,#+13,#+13
   \   000001B0   0x0B6D             LSRS     R5,R5,#+13
   \   000001B2   0x432C             ORRS     R4,R5,R4
   \   000001B4   0x6104             STR      R4,[R0, #+16]
    740              
    741          
    742              if (dma == 1)
   \   000001B6   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   000001B8   0x2A01             CMP      R2,#+1
   \   000001BA   0xD106             BNE.N    ??USB_EP0StartXfer_8
    743              {
    744                USBx_OUTEP(ep->num)->DOEPDMA = (uint32_t)(ep->xfer_buff);
   \   000001BC   0x7808             LDRB     R0,[R1, #+0]
   \   000001BE   0xEB13 0x1040      ADDS     R0,R3,R0, LSL #+5
   \   000001C2   0xF510 0x6030      ADDS     R0,R0,#+2816
   \   000001C6   0x68CC             LDR      R4,[R1, #+12]
   \   000001C8   0x6144             STR      R4,[R0, #+20]
    745              }
    746              
    747              /* EP enable */
    748              USBx_OUTEP(ep->num)->DOEPCTL |= (USB_OTG_DOEPCTL_CNAK | USB_OTG_DOEPCTL_EPENA);    
   \                     ??USB_EP0StartXfer_8: (+1)
   \   000001CA   0x7808             LDRB     R0,[R1, #+0]
   \   000001CC   0xEB13 0x1040      ADDS     R0,R3,R0, LSL #+5
   \   000001D0   0xF510 0x6030      ADDS     R0,R0,#+2816
   \   000001D4   0x780C             LDRB     R4,[R1, #+0]
   \   000001D6   0xEB13 0x1444      ADDS     R4,R3,R4, LSL #+5
   \   000001DA   0xF514 0x6430      ADDS     R4,R4,#+2816
   \   000001DE   0x6824             LDR      R4,[R4, #+0]
   \   000001E0   0xF054 0x4404      ORRS     R4,R4,#0x84000000
   \   000001E4   0x6004             STR      R4,[R0, #+0]
    749            }
    750            return HAL_OK;
   \                     ??USB_EP0StartXfer_6: (+1)
   \   000001E6   0x2000             MOVS     R0,#+0
   \   000001E8   0xBC30             POP      {R4,R5}
   \   000001EA   0x4770             BX       LR               ;; return
    751          }
    752          
    753          /**
    754            * @brief  USB_WritePacket : Writes a packet into the Tx FIFO associated 
    755            *         with the EP/channel
    756            * @param  USBx : Selected device           
    757            * @param  src :  pointer to source buffer
    758            * @param  ch_ep_num : endpoint or host channel number
    759            * @param  len : Number of bytes to write
    760            * @param  dma: USB dma enabled or disabled 
    761            *          This parameter can be one of the these values:
    762            *           0 : DMA feature not used 
    763            *           1 : DMA feature used  
    764            * @retval HAL status
    765            */

   \                                 In section .text, align 2, keep-with-next
    766          HAL_StatusTypeDef USB_WritePacket(USB_OTG_GlobalTypeDef *USBx, uint8_t *src, uint8_t ch_ep_num, uint16_t len, uint8_t dma)
    767          {
   \                     USB_WritePacket: (+1)
   \   00000000   0xB4F0             PUSH     {R4-R7}
   \   00000002   0x0005             MOVS     R5,R0
   \   00000004   0x9C04             LDR      R4,[SP, #+16]
    768            uint32_t count32b= 0 , i= 0;
   \   00000006   0x2600             MOVS     R6,#+0
   \   00000008   0x2700             MOVS     R7,#+0
    769            
    770            if (dma == 0)
   \   0000000A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000C   0x2C00             CMP      R4,#+0
   \   0000000E   0xD117             BNE.N    ??USB_WritePacket_0
    771            {
    772              count32b =  (len + 3) / 4;
   \   00000010   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   00000012   0x1CD8             ADDS     R0,R3,#+3
   \   00000014   0xF05F 0x0C04      MOVS     R12,#+4
   \   00000018   0xFB90 0xF0FC      SDIV     R0,R0,R12
   \   0000001C   0x0006             MOVS     R6,R0
    773              for (i = 0; i < count32b; i++, src += 4)
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0x0007             MOVS     R7,R0
   \                     ??USB_WritePacket_1: (+1)
   \   00000022   0x42B7             CMP      R7,R6
   \   00000024   0xD20C             BCS.N    ??USB_WritePacket_0
    774              {
    775                USBx_DFIFO(ch_ep_num) = *((__packed uint32_t *)src);
   \   00000026   0x6808             LDR      R0,[R1, #+0]
   \   00000028   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000002A   0xF44F 0x5C80      MOV      R12,#+4096
   \   0000002E   0xFB0C 0x5C02      MLA      R12,R12,R2,R5
   \   00000032   0xF51C 0x5C80      ADDS     R12,R12,#+4096
   \   00000036   0xF8CC 0x0000      STR      R0,[R12, #+0]
    776              }
   \   0000003A   0x1C7F             ADDS     R7,R7,#+1
   \   0000003C   0x1D09             ADDS     R1,R1,#+4
   \   0000003E   0xE7F0             B.N      ??USB_WritePacket_1
    777            }
    778            return HAL_OK;
   \                     ??USB_WritePacket_0: (+1)
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0xBCF0             POP      {R4-R7}
   \   00000044   0x4770             BX       LR               ;; return
    779          }
    780          
    781          /**
    782            * @brief  USB_ReadPacket : read a packet from the Tx FIFO associated 
    783            *         with the EP/channel
    784            * @param  USBx : Selected device  
    785            * @param  src : source pointer
    786            * @param  ch_ep_num : endpoint or host channel number
    787            * @param  len : Number of bytes to read
    788            * @param  dma: USB dma enabled or disabled 
    789            *          This parameter can be one of the these values:
    790            *           0 : DMA feature not used 
    791            *           1 : DMA feature used  
    792            * @retval pointer to destination buffer
    793            */

   \                                 In section .text, align 2, keep-with-next
    794          void *USB_ReadPacket(USB_OTG_GlobalTypeDef *USBx, uint8_t *dest, uint16_t len)
    795          {
   \                     USB_ReadPacket: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
   \   00000002   0x0003             MOVS     R3,R0
   \   00000004   0x0008             MOVS     R0,R1
    796            uint32_t i=0;
   \   00000006   0x2100             MOVS     R1,#+0
    797            uint32_t count32b = (len + 3) / 4;
   \   00000008   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   0000000A   0x1CD4             ADDS     R4,R2,#+3
   \   0000000C   0x2504             MOVS     R5,#+4
   \   0000000E   0xFB94 0xF4F5      SDIV     R4,R4,R5
    798            
    799            for ( i = 0; i < count32b; i++, dest += 4 )
   \   00000012   0x2500             MOVS     R5,#+0
   \   00000014   0x0029             MOVS     R1,R5
   \                     ??USB_ReadPacket_0: (+1)
   \   00000016   0x42A1             CMP      R1,R4
   \   00000018   0xD206             BCS.N    ??USB_ReadPacket_1
    800            {
    801              *(__packed uint32_t *)dest = USBx_DFIFO(0);
   \   0000001A   0xF513 0x5580      ADDS     R5,R3,#+4096
   \   0000001E   0x682D             LDR      R5,[R5, #+0]
   \   00000020   0x6005             STR      R5,[R0, #+0]
    802              
    803            }
   \   00000022   0x1C49             ADDS     R1,R1,#+1
   \   00000024   0x1D00             ADDS     R0,R0,#+4
   \   00000026   0xE7F6             B.N      ??USB_ReadPacket_0
    804            return ((void *)dest);
   \                     ??USB_ReadPacket_1: (+1)
   \   00000028   0xBC30             POP      {R4,R5}
   \   0000002A   0x4770             BX       LR               ;; return
    805          }
    806          
    807          /**
    808            * @brief  USB_EPSetStall : set a stall condition over an EP
    809            * @param  USBx : Selected device
    810            * @param  ep: pointer to endpoint structure   
    811            * @retval HAL status
    812            */

   \                                 In section .text, align 2, keep-with-next
    813          HAL_StatusTypeDef USB_EPSetStall(USB_OTG_GlobalTypeDef *USBx , USB_OTG_EPTypeDef *ep)
    814          {
   \                     USB_EPSetStall: (+1)
   \   00000000   0x0002             MOVS     R2,R0
    815            if (ep->is_in == 1)
   \   00000002   0x7848             LDRB     R0,[R1, #+1]
   \   00000004   0x2801             CMP      R0,#+1
   \   00000006   0xD124             BNE.N    ??USB_EPSetStall_0
    816            {
    817              if (((USBx_INEP(ep->num)->DIEPCTL) & USB_OTG_DIEPCTL_EPENA) == 0)
   \   00000008   0x7808             LDRB     R0,[R1, #+0]
   \   0000000A   0xEB12 0x1040      ADDS     R0,R2,R0, LSL #+5
   \   0000000E   0xF510 0x6010      ADDS     R0,R0,#+2304
   \   00000012   0x6800             LDR      R0,[R0, #+0]
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD40D             BMI.N    ??USB_EPSetStall_1
    818              {
    819                USBx_INEP(ep->num)->DIEPCTL &= ~(USB_OTG_DIEPCTL_EPDIS); 
   \   00000018   0x7808             LDRB     R0,[R1, #+0]
   \   0000001A   0xEB12 0x1040      ADDS     R0,R2,R0, LSL #+5
   \   0000001E   0xF510 0x6010      ADDS     R0,R0,#+2304
   \   00000022   0x780B             LDRB     R3,[R1, #+0]
   \   00000024   0xEB12 0x1343      ADDS     R3,R2,R3, LSL #+5
   \   00000028   0xF513 0x6310      ADDS     R3,R3,#+2304
   \   0000002C   0x681B             LDR      R3,[R3, #+0]
   \   0000002E   0xF033 0x4380      BICS     R3,R3,#0x40000000
   \   00000032   0x6003             STR      R3,[R0, #+0]
    820              } 
    821              USBx_INEP(ep->num)->DIEPCTL |= USB_OTG_DIEPCTL_STALL;
   \                     ??USB_EPSetStall_1: (+1)
   \   00000034   0x7808             LDRB     R0,[R1, #+0]
   \   00000036   0xEB12 0x1040      ADDS     R0,R2,R0, LSL #+5
   \   0000003A   0xF510 0x6010      ADDS     R0,R0,#+2304
   \   0000003E   0x780B             LDRB     R3,[R1, #+0]
   \   00000040   0xEB12 0x1343      ADDS     R3,R2,R3, LSL #+5
   \   00000044   0xF513 0x6310      ADDS     R3,R3,#+2304
   \   00000048   0x681B             LDR      R3,[R3, #+0]
   \   0000004A   0xF453 0x1300      ORRS     R3,R3,#0x200000
   \   0000004E   0x6003             STR      R3,[R0, #+0]
   \   00000050   0xE023             B.N      ??USB_EPSetStall_2
    822            }
    823            else
    824            {
    825              if (((USBx_OUTEP(ep->num)->DOEPCTL) & USB_OTG_DOEPCTL_EPENA) == 0)
   \                     ??USB_EPSetStall_0: (+1)
   \   00000052   0x7808             LDRB     R0,[R1, #+0]
   \   00000054   0xEB12 0x1040      ADDS     R0,R2,R0, LSL #+5
   \   00000058   0xF510 0x6030      ADDS     R0,R0,#+2816
   \   0000005C   0x6800             LDR      R0,[R0, #+0]
   \   0000005E   0x2800             CMP      R0,#+0
   \   00000060   0xD40D             BMI.N    ??USB_EPSetStall_3
    826              {
    827                USBx_OUTEP(ep->num)->DOEPCTL &= ~(USB_OTG_DOEPCTL_EPDIS); 
   \   00000062   0x7808             LDRB     R0,[R1, #+0]
   \   00000064   0xEB12 0x1040      ADDS     R0,R2,R0, LSL #+5
   \   00000068   0xF510 0x6030      ADDS     R0,R0,#+2816
   \   0000006C   0x780B             LDRB     R3,[R1, #+0]
   \   0000006E   0xEB12 0x1343      ADDS     R3,R2,R3, LSL #+5
   \   00000072   0xF513 0x6330      ADDS     R3,R3,#+2816
   \   00000076   0x681B             LDR      R3,[R3, #+0]
   \   00000078   0xF033 0x4380      BICS     R3,R3,#0x40000000
   \   0000007C   0x6003             STR      R3,[R0, #+0]
    828              } 
    829              USBx_OUTEP(ep->num)->DOEPCTL |= USB_OTG_DOEPCTL_STALL;
   \                     ??USB_EPSetStall_3: (+1)
   \   0000007E   0x7808             LDRB     R0,[R1, #+0]
   \   00000080   0xEB12 0x1040      ADDS     R0,R2,R0, LSL #+5
   \   00000084   0xF510 0x6030      ADDS     R0,R0,#+2816
   \   00000088   0x780B             LDRB     R3,[R1, #+0]
   \   0000008A   0xEB12 0x1343      ADDS     R3,R2,R3, LSL #+5
   \   0000008E   0xF513 0x6330      ADDS     R3,R3,#+2816
   \   00000092   0x681B             LDR      R3,[R3, #+0]
   \   00000094   0xF453 0x1300      ORRS     R3,R3,#0x200000
   \   00000098   0x6003             STR      R3,[R0, #+0]
    830            }
    831            return HAL_OK;
   \                     ??USB_EPSetStall_2: (+1)
   \   0000009A   0x2000             MOVS     R0,#+0
   \   0000009C   0x4770             BX       LR               ;; return
    832          }
    833          
    834          
    835          /**
    836            * @brief  USB_EPClearStall : Clear a stall condition over an EP
    837            * @param  USBx : Selected device
    838            * @param  ep: pointer to endpoint structure   
    839            * @retval HAL status
    840            */

   \                                 In section .text, align 2, keep-with-next
    841          HAL_StatusTypeDef USB_EPClearStall(USB_OTG_GlobalTypeDef *USBx, USB_OTG_EPTypeDef *ep)
    842          {
   \                     USB_EPClearStall: (+1)
   \   00000000   0x0002             MOVS     R2,R0
    843            if (ep->is_in == 1)
   \   00000002   0x7848             LDRB     R0,[R1, #+1]
   \   00000004   0x2801             CMP      R0,#+1
   \   00000006   0xD122             BNE.N    ??USB_EPClearStall_0
    844            {
    845              USBx_INEP(ep->num)->DIEPCTL &= ~USB_OTG_DIEPCTL_STALL;
   \   00000008   0x7808             LDRB     R0,[R1, #+0]
   \   0000000A   0xEB12 0x1040      ADDS     R0,R2,R0, LSL #+5
   \   0000000E   0xF510 0x6010      ADDS     R0,R0,#+2304
   \   00000012   0x780B             LDRB     R3,[R1, #+0]
   \   00000014   0xEB12 0x1343      ADDS     R3,R2,R3, LSL #+5
   \   00000018   0xF513 0x6310      ADDS     R3,R3,#+2304
   \   0000001C   0x681B             LDR      R3,[R3, #+0]
   \   0000001E   0xF433 0x1300      BICS     R3,R3,#0x200000
   \   00000022   0x6003             STR      R3,[R0, #+0]
    846              if (ep->type == EP_TYPE_INTR || ep->type == EP_TYPE_BULK)
   \   00000024   0x78C8             LDRB     R0,[R1, #+3]
   \   00000026   0x2803             CMP      R0,#+3
   \   00000028   0xD002             BEQ.N    ??USB_EPClearStall_1
   \   0000002A   0x78C8             LDRB     R0,[R1, #+3]
   \   0000002C   0x2802             CMP      R0,#+2
   \   0000002E   0xD130             BNE.N    ??USB_EPClearStall_2
    847              {
    848                 USBx_INEP(ep->num)->DIEPCTL |= USB_OTG_DIEPCTL_SD0PID_SEVNFRM; /* DATA0 */
   \                     ??USB_EPClearStall_1: (+1)
   \   00000030   0x7808             LDRB     R0,[R1, #+0]
   \   00000032   0xEB12 0x1040      ADDS     R0,R2,R0, LSL #+5
   \   00000036   0xF510 0x6010      ADDS     R0,R0,#+2304
   \   0000003A   0x780B             LDRB     R3,[R1, #+0]
   \   0000003C   0xEB12 0x1343      ADDS     R3,R2,R3, LSL #+5
   \   00000040   0xF513 0x6310      ADDS     R3,R3,#+2304
   \   00000044   0x681B             LDR      R3,[R3, #+0]
   \   00000046   0xF053 0x5380      ORRS     R3,R3,#0x10000000
   \   0000004A   0x6003             STR      R3,[R0, #+0]
   \   0000004C   0xE021             B.N      ??USB_EPClearStall_2
    849              }    
    850            }
    851            else
    852            {
    853              USBx_OUTEP(ep->num)->DOEPCTL &= ~USB_OTG_DOEPCTL_STALL;
   \                     ??USB_EPClearStall_0: (+1)
   \   0000004E   0x7808             LDRB     R0,[R1, #+0]
   \   00000050   0xEB12 0x1040      ADDS     R0,R2,R0, LSL #+5
   \   00000054   0xF510 0x6030      ADDS     R0,R0,#+2816
   \   00000058   0x780B             LDRB     R3,[R1, #+0]
   \   0000005A   0xEB12 0x1343      ADDS     R3,R2,R3, LSL #+5
   \   0000005E   0xF513 0x6330      ADDS     R3,R3,#+2816
   \   00000062   0x681B             LDR      R3,[R3, #+0]
   \   00000064   0xF433 0x1300      BICS     R3,R3,#0x200000
   \   00000068   0x6003             STR      R3,[R0, #+0]
    854              if (ep->type == EP_TYPE_INTR || ep->type == EP_TYPE_BULK)
   \   0000006A   0x78C8             LDRB     R0,[R1, #+3]
   \   0000006C   0x2803             CMP      R0,#+3
   \   0000006E   0xD002             BEQ.N    ??USB_EPClearStall_3
   \   00000070   0x78C8             LDRB     R0,[R1, #+3]
   \   00000072   0x2802             CMP      R0,#+2
   \   00000074   0xD10D             BNE.N    ??USB_EPClearStall_2
    855              {
    856                USBx_OUTEP(ep->num)->DOEPCTL |= USB_OTG_DOEPCTL_SD0PID_SEVNFRM; /* DATA0 */
   \                     ??USB_EPClearStall_3: (+1)
   \   00000076   0x7808             LDRB     R0,[R1, #+0]
   \   00000078   0xEB12 0x1040      ADDS     R0,R2,R0, LSL #+5
   \   0000007C   0xF510 0x6030      ADDS     R0,R0,#+2816
   \   00000080   0x780B             LDRB     R3,[R1, #+0]
   \   00000082   0xEB12 0x1343      ADDS     R3,R2,R3, LSL #+5
   \   00000086   0xF513 0x6330      ADDS     R3,R3,#+2816
   \   0000008A   0x681B             LDR      R3,[R3, #+0]
   \   0000008C   0xF053 0x5380      ORRS     R3,R3,#0x10000000
   \   00000090   0x6003             STR      R3,[R0, #+0]
    857              }    
    858            }
    859            return HAL_OK;
   \                     ??USB_EPClearStall_2: (+1)
   \   00000092   0x2000             MOVS     R0,#+0
   \   00000094   0x4770             BX       LR               ;; return
    860          }
    861          
    862          /**
    863            * @brief  USB_StopDevice : Stop the usb device mode
    864            * @param  USBx : Selected device
    865            * @retval HAL status
    866            */

   \                                 In section .text, align 2, keep-with-next
    867          HAL_StatusTypeDef USB_StopDevice(USB_OTG_GlobalTypeDef *USBx)
    868          {
   \                     USB_StopDevice: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    869            uint32_t i;
    870            
    871            /* Clear Pending interrupt */
    872            for (i = 0; i < 15 ; i++)
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x0005             MOVS     R5,R0
   \                     ??USB_StopDevice_0: (+1)
   \   00000008   0x2D0F             CMP      R5,#+15
   \   0000000A   0xD20D             BCS.N    ??USB_StopDevice_1
    873            {
    874              USBx_INEP(i)->DIEPINT  = 0xFF;
   \   0000000C   0xEB14 0x1045      ADDS     R0,R4,R5, LSL #+5
   \   00000010   0xF510 0x6010      ADDS     R0,R0,#+2304
   \   00000014   0x21FF             MOVS     R1,#+255
   \   00000016   0x6081             STR      R1,[R0, #+8]
    875              USBx_OUTEP(i)->DOEPINT  = 0xFF;
   \   00000018   0xEB14 0x1045      ADDS     R0,R4,R5, LSL #+5
   \   0000001C   0xF510 0x6030      ADDS     R0,R0,#+2816
   \   00000020   0x21FF             MOVS     R1,#+255
   \   00000022   0x6081             STR      R1,[R0, #+8]
    876            }
   \   00000024   0x1C6D             ADDS     R5,R5,#+1
   \   00000026   0xE7EF             B.N      ??USB_StopDevice_0
    877            USBx_DEVICE->DAINT = 0xFFFFFFFF;
   \                     ??USB_StopDevice_1: (+1)
   \   00000028   0xF05F 0x30FF      MOVS     R0,#-1
   \   0000002C   0xF514 0x6100      ADDS     R1,R4,#+2048
   \   00000030   0x6188             STR      R0,[R1, #+24]
    878            
    879            /* Clear interrupt masks */
    880            USBx_DEVICE->DIEPMSK  = 0;
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0xF514 0x6100      ADDS     R1,R4,#+2048
   \   00000038   0x6108             STR      R0,[R1, #+16]
    881            USBx_DEVICE->DOEPMSK  = 0;
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0xF514 0x6100      ADDS     R1,R4,#+2048
   \   00000040   0x6148             STR      R0,[R1, #+20]
    882            USBx_DEVICE->DAINTMSK = 0;
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0xF514 0x6100      ADDS     R1,R4,#+2048
   \   00000048   0x61C8             STR      R0,[R1, #+28]
    883            
    884            /* Flush the FIFO */
    885            USB_FlushRxFifo(USBx);
   \   0000004A   0x0020             MOVS     R0,R4
   \   0000004C   0x.... 0x....      BL       USB_FlushRxFifo
    886            USB_FlushTxFifo(USBx ,  0x10 );  
   \   00000050   0x2110             MOVS     R1,#+16
   \   00000052   0x0020             MOVS     R0,R4
   \   00000054   0x.... 0x....      BL       USB_FlushTxFifo
    887            
    888            return HAL_OK;
   \   00000058   0x2000             MOVS     R0,#+0
   \   0000005A   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    889          }
    890          
    891          /**
    892            * @brief  USB_SetDevAddress : Stop the usb device mode
    893            * @param  USBx : Selected device
    894            * @param  address : new device address to be assigned
    895            *          This parameter can be a value from 0 to 255
    896            * @retval HAL status
    897            */

   \                                 In section .text, align 2, keep-with-next
    898          HAL_StatusTypeDef  USB_SetDevAddress (USB_OTG_GlobalTypeDef *USBx, uint8_t address)
    899          {
   \                     USB_SetDevAddress: (+1)
   \   00000000   0x0002             MOVS     R2,R0
    900            USBx_DEVICE->DCFG &= ~ (USB_OTG_DCFG_DAD);
   \   00000002   0xF512 0x6000      ADDS     R0,R2,#+2048
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0xF430 0x60FE      BICS     R0,R0,#0x7F0
   \   0000000C   0xF512 0x6300      ADDS     R3,R2,#+2048
   \   00000010   0x6018             STR      R0,[R3, #+0]
    901            USBx_DEVICE->DCFG |= (address << 4) & USB_OTG_DCFG_DAD ;
   \   00000012   0xF512 0x6000      ADDS     R0,R2,#+2048
   \   00000016   0x6800             LDR      R0,[R0, #+0]
   \   00000018   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000001A   0x010B             LSLS     R3,R1,#+4
   \   0000001C   0xF413 0x63FE      ANDS     R3,R3,#0x7F0
   \   00000020   0x4318             ORRS     R0,R3,R0
   \   00000022   0xF512 0x6300      ADDS     R3,R2,#+2048
   \   00000026   0x6018             STR      R0,[R3, #+0]
    902            
    903            return HAL_OK;  
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0x4770             BX       LR               ;; return
    904          }
    905          
    906          /**
    907            * @brief  USB_DevConnect : Connect the USB device by enabling the pull-up/pull-down
    908            * @param  USBx : Selected device
    909            * @retval HAL status
    910            */

   \                                 In section .text, align 2, keep-with-next
    911          HAL_StatusTypeDef  USB_DevConnect (USB_OTG_GlobalTypeDef *USBx)
    912          {
   \                     USB_DevConnect: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    913            USBx_DEVICE->DCTL &= ~USB_OTG_DCTL_SDIS ;
   \   00000004   0xF514 0x6000      ADDS     R0,R4,#+2048
   \   00000008   0x6840             LDR      R0,[R0, #+4]
   \   0000000A   0xF030 0x0002      BICS     R0,R0,#0x2
   \   0000000E   0xF514 0x6100      ADDS     R1,R4,#+2048
   \   00000012   0x6048             STR      R0,[R1, #+4]
    914            HAL_Delay(3);
   \   00000014   0x2003             MOVS     R0,#+3
   \   00000016   0x.... 0x....      BL       HAL_Delay
    915            
    916            return HAL_OK;  
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0xBD10             POP      {R4,PC}          ;; return
    917          }
    918          
    919          /**
    920            * @brief  USB_DevDisconnect : Disconnect the USB device by disabling the pull-up/pull-down
    921            * @param  USBx : Selected device
    922            * @retval HAL status
    923            */

   \                                 In section .text, align 2, keep-with-next
    924          HAL_StatusTypeDef  USB_DevDisconnect (USB_OTG_GlobalTypeDef *USBx)
    925          {
   \                     USB_DevDisconnect: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    926            USBx_DEVICE->DCTL |= USB_OTG_DCTL_SDIS ;
   \   00000004   0xF514 0x6000      ADDS     R0,R4,#+2048
   \   00000008   0x6840             LDR      R0,[R0, #+4]
   \   0000000A   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   0000000E   0xF514 0x6100      ADDS     R1,R4,#+2048
   \   00000012   0x6048             STR      R0,[R1, #+4]
    927            HAL_Delay(3);
   \   00000014   0x2003             MOVS     R0,#+3
   \   00000016   0x.... 0x....      BL       HAL_Delay
    928            
    929            return HAL_OK;  
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0xBD10             POP      {R4,PC}          ;; return
    930          }
    931          
    932          /**
    933            * @brief  USB_ReadInterrupts: return the global USB interrupt status
    934            * @param  USBx : Selected device
    935            * @retval HAL status
    936            */

   \                                 In section .text, align 2, keep-with-next
    937          uint32_t  USB_ReadInterrupts (USB_OTG_GlobalTypeDef *USBx)
    938          {
   \                     USB_ReadInterrupts: (+1)
   \   00000000   0x0001             MOVS     R1,R0
    939            uint32_t v = 0;
   \   00000002   0x2000             MOVS     R0,#+0
    940            
    941            v = USBx->GINTSTS;
   \   00000004   0x694A             LDR      R2,[R1, #+20]
   \   00000006   0x0010             MOVS     R0,R2
    942            v &= USBx->GINTMSK;
   \   00000008   0x698A             LDR      R2,[R1, #+24]
   \   0000000A   0x4010             ANDS     R0,R2,R0
    943            return v;  
   \   0000000C   0x4770             BX       LR               ;; return
    944          }
    945          
    946          /**
    947            * @brief  USB_ReadDevAllOutEpInterrupt: return the USB device OUT endpoints interrupt status
    948            * @param  USBx : Selected device
    949            * @retval HAL status
    950            */

   \                                 In section .text, align 2, keep-with-next
    951          uint32_t USB_ReadDevAllOutEpInterrupt (USB_OTG_GlobalTypeDef *USBx)
    952          {
   \                     USB_ReadDevAllOutEpInterrupt: (+1)
   \   00000000   0x0001             MOVS     R1,R0
    953            uint32_t v;
    954            v  = USBx_DEVICE->DAINT;
   \   00000002   0xF511 0x6200      ADDS     R2,R1,#+2048
   \   00000006   0x6992             LDR      R2,[R2, #+24]
   \   00000008   0x0010             MOVS     R0,R2
    955            v &= USBx_DEVICE->DAINTMSK;
   \   0000000A   0xF511 0x6200      ADDS     R2,R1,#+2048
   \   0000000E   0x69D2             LDR      R2,[R2, #+28]
   \   00000010   0x4010             ANDS     R0,R2,R0
    956            return ((v & 0xffff0000) >> 16);
   \   00000012   0x0C00             LSRS     R0,R0,#+16
   \   00000014   0x4770             BX       LR               ;; return
    957          }
    958          
    959          /**
    960            * @brief  USB_ReadDevAllInEpInterrupt: return the USB device IN endpoints interrupt status
    961            * @param  USBx : Selected device
    962            * @retval HAL status
    963            */

   \                                 In section .text, align 2, keep-with-next
    964          uint32_t USB_ReadDevAllInEpInterrupt (USB_OTG_GlobalTypeDef *USBx)
    965          {
   \                     USB_ReadDevAllInEpInterrupt: (+1)
   \   00000000   0x0001             MOVS     R1,R0
    966            uint32_t v;
    967            v  = USBx_DEVICE->DAINT;
   \   00000002   0xF511 0x6200      ADDS     R2,R1,#+2048
   \   00000006   0x6992             LDR      R2,[R2, #+24]
   \   00000008   0x0010             MOVS     R0,R2
    968            v &= USBx_DEVICE->DAINTMSK;
   \   0000000A   0xF511 0x6200      ADDS     R2,R1,#+2048
   \   0000000E   0x69D2             LDR      R2,[R2, #+28]
   \   00000010   0x4010             ANDS     R0,R2,R0
    969            return ((v & 0xFFFF));
   \   00000012   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000014   0x4770             BX       LR               ;; return
    970          }
    971          
    972          /**
    973            * @brief  Returns Device OUT EP Interrupt register
    974            * @param  USBx : Selected device
    975            * @param  epnum : endpoint number
    976            *          This parameter can be a value from 0 to 15
    977            * @retval Device OUT EP Interrupt register
    978            */

   \                                 In section .text, align 2, keep-with-next
    979          uint32_t USB_ReadDevOutEPInterrupt (USB_OTG_GlobalTypeDef *USBx , uint8_t epnum)
    980          {
   \                     USB_ReadDevOutEPInterrupt: (+1)
   \   00000000   0x0002             MOVS     R2,R0
    981            uint32_t v;
    982            v  = USBx_OUTEP(epnum)->DOEPINT;
   \   00000002   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000004   0xEB12 0x1341      ADDS     R3,R2,R1, LSL #+5
   \   00000008   0xF513 0x6330      ADDS     R3,R3,#+2816
   \   0000000C   0x689B             LDR      R3,[R3, #+8]
   \   0000000E   0x0018             MOVS     R0,R3
    983            v &= USBx_DEVICE->DOEPMSK;
   \   00000010   0xF512 0x6300      ADDS     R3,R2,#+2048
   \   00000014   0x695B             LDR      R3,[R3, #+20]
   \   00000016   0x4018             ANDS     R0,R3,R0
    984            return v;
   \   00000018   0x4770             BX       LR               ;; return
    985          }
    986          
    987          /**
    988            * @brief  Returns Device IN EP Interrupt register
    989            * @param  USBx : Selected device
    990            * @param  epnum : endpoint number
    991            *          This parameter can be a value from 0 to 15
    992            * @retval Device IN EP Interrupt register
    993            */

   \                                 In section .text, align 2, keep-with-next
    994          uint32_t USB_ReadDevInEPInterrupt (USB_OTG_GlobalTypeDef *USBx , uint8_t epnum)
    995          {
   \                     USB_ReadDevInEPInterrupt: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
   \   00000002   0x0002             MOVS     R2,R0
    996            uint32_t v, msk, emp;
    997            
    998            msk = USBx_DEVICE->DIEPMSK;
   \   00000004   0xF512 0x6500      ADDS     R5,R2,#+2048
   \   00000008   0x692D             LDR      R5,[R5, #+16]
   \   0000000A   0x002C             MOVS     R4,R5
    999            emp = USBx_DEVICE->DIEPEMPMSK;
   \   0000000C   0xF512 0x6500      ADDS     R5,R2,#+2048
   \   00000010   0x6B6D             LDR      R5,[R5, #+52]
   \   00000012   0x002B             MOVS     R3,R5
   1000            msk |= ((emp >> epnum) & 0x1) << 7;
   \   00000014   0x001D             MOVS     R5,R3
   \   00000016   0x40CD             LSRS     R5,R5,R1
   \   00000018   0xF015 0x0501      ANDS     R5,R5,#0x1
   \   0000001C   0xEA54 0x14C5      ORRS     R4,R4,R5, LSL #+7
   1001            v = USBx_INEP(epnum)->DIEPINT & msk;
   \   00000020   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000022   0xEB12 0x1541      ADDS     R5,R2,R1, LSL #+5
   \   00000026   0xF515 0x6510      ADDS     R5,R5,#+2304
   \   0000002A   0x68AD             LDR      R5,[R5, #+8]
   \   0000002C   0x4025             ANDS     R5,R4,R5
   \   0000002E   0x0028             MOVS     R0,R5
   1002            return v;
   \   00000030   0xBC30             POP      {R4,R5}
   \   00000032   0x4770             BX       LR               ;; return
   1003          }
   1004          
   1005          /**
   1006            * @brief  USB_ClearInterrupts: clear a USB interrupt
   1007            * @param  USBx : Selected device
   1008            * @param  interrupt : interrupt flag
   1009            * @retval None
   1010            */

   \                                 In section .text, align 2, keep-with-next
   1011          void  USB_ClearInterrupts (USB_OTG_GlobalTypeDef *USBx, uint32_t interrupt)
   1012          {
   1013            USBx->GINTSTS |= interrupt; 
   \                     USB_ClearInterrupts: (+1)
   \   00000000   0x6942             LDR      R2,[R0, #+20]
   \   00000002   0x430A             ORRS     R2,R1,R2
   \   00000004   0x6142             STR      R2,[R0, #+20]
   1014          }
   \   00000006   0x4770             BX       LR               ;; return
   1015          
   1016          /**
   1017            * @brief  Returns USB core mode
   1018            * @param  USBx : Selected device
   1019            * @retval return core mode : Host or Device
   1020            *          This parameter can be one of the these values:
   1021            *           0 : Host 
   1022            *           1 : Device
   1023            */

   \                                 In section .text, align 2, keep-with-next
   1024          uint32_t USB_GetMode(USB_OTG_GlobalTypeDef *USBx)
   1025          {
   1026            return ((USBx->GINTSTS ) & 0x1);
   \                     USB_GetMode: (+1)
   \   00000000   0x6940             LDR      R0,[R0, #+20]
   \   00000002   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   00000006   0x4770             BX       LR               ;; return
   1027          }
   1028          
   1029          
   1030          /**
   1031            * @brief  Activate EP0 for Setup transactions
   1032            * @param  USBx : Selected device
   1033            * @retval HAL status
   1034            */

   \                                 In section .text, align 2, keep-with-next
   1035          HAL_StatusTypeDef  USB_ActivateSetup (USB_OTG_GlobalTypeDef *USBx)
   1036          {
   \                     USB_ActivateSetup: (+1)
   \   00000000   0x0001             MOVS     R1,R0
   1037            /* Set the MPS of the IN EP based on the enumeration speed */
   1038            USBx_INEP(0)->DIEPCTL &= ~USB_OTG_DIEPCTL_MPSIZ;
   \   00000002   0xF511 0x6010      ADDS     R0,R1,#+2304
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0x0AC0             LSRS     R0,R0,#+11
   \   0000000A   0x02C0             LSLS     R0,R0,#+11
   \   0000000C   0xF511 0x6210      ADDS     R2,R1,#+2304
   \   00000010   0x6010             STR      R0,[R2, #+0]
   1039            
   1040            if((USBx_DEVICE->DSTS & USB_OTG_DSTS_ENUMSPD) == DSTS_ENUMSPD_LS_PHY_6MHZ)
   \   00000012   0xF511 0x6000      ADDS     R0,R1,#+2048
   \   00000016   0x6880             LDR      R0,[R0, #+8]
   \   00000018   0xF010 0x0006      ANDS     R0,R0,#0x6
   \   0000001C   0x2804             CMP      R0,#+4
   \   0000001E   0xD107             BNE.N    ??USB_ActivateSetup_0
   1041            {
   1042              USBx_INEP(0)->DIEPCTL |= 3;
   \   00000020   0xF511 0x6010      ADDS     R0,R1,#+2304
   \   00000024   0x6800             LDR      R0,[R0, #+0]
   \   00000026   0xF050 0x0003      ORRS     R0,R0,#0x3
   \   0000002A   0xF511 0x6210      ADDS     R2,R1,#+2304
   \   0000002E   0x6010             STR      R0,[R2, #+0]
   1043            }
   1044            USBx_DEVICE->DCTL |= USB_OTG_DCTL_CGINAK;
   \                     ??USB_ActivateSetup_0: (+1)
   \   00000030   0xF511 0x6000      ADDS     R0,R1,#+2048
   \   00000034   0x6840             LDR      R0,[R0, #+4]
   \   00000036   0xF450 0x7080      ORRS     R0,R0,#0x100
   \   0000003A   0xF511 0x6200      ADDS     R2,R1,#+2048
   \   0000003E   0x6050             STR      R0,[R2, #+4]
   1045          
   1046            return HAL_OK;
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0x4770             BX       LR               ;; return
   1047          }
   1048          
   1049          
   1050          /**
   1051            * @brief  Prepare the EP0 to start the first control setup
   1052            * @param  USBx : Selected device
   1053            * @param  dma: USB dma enabled or disabled 
   1054            *          This parameter can be one of the these values:
   1055            *           0 : DMA feature not used 
   1056            *           1 : DMA feature used  
   1057            * @param  psetup : pointer to setup packet
   1058            * @retval HAL status
   1059            */

   \                                 In section .text, align 2, keep-with-next
   1060          HAL_StatusTypeDef USB_EP0_OutStart(USB_OTG_GlobalTypeDef *USBx, uint8_t dma, uint8_t *psetup)
   1061          {
   \                     USB_EP0_OutStart: (+1)
   \   00000000   0xB410             PUSH     {R4}
   \   00000002   0x0003             MOVS     R3,R0
   1062            USBx_OUTEP(0)->DOEPTSIZ = 0;
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0xF513 0x6430      ADDS     R4,R3,#+2816
   \   0000000A   0x6120             STR      R0,[R4, #+16]
   1063            USBx_OUTEP(0)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (1 << 19)) ;
   \   0000000C   0xF513 0x6030      ADDS     R0,R3,#+2816
   \   00000010   0x6900             LDR      R0,[R0, #+16]
   \   00000012   0xF450 0x2000      ORRS     R0,R0,#0x80000
   \   00000016   0xF513 0x6430      ADDS     R4,R3,#+2816
   \   0000001A   0x6120             STR      R0,[R4, #+16]
   1064            USBx_OUTEP(0)->DOEPTSIZ |= (3 * 8);
   \   0000001C   0xF513 0x6030      ADDS     R0,R3,#+2816
   \   00000020   0x6900             LDR      R0,[R0, #+16]
   \   00000022   0xF050 0x0018      ORRS     R0,R0,#0x18
   \   00000026   0xF513 0x6430      ADDS     R4,R3,#+2816
   \   0000002A   0x6120             STR      R0,[R4, #+16]
   1065            USBx_OUTEP(0)->DOEPTSIZ |=  USB_OTG_DOEPTSIZ_STUPCNT;  
   \   0000002C   0xF513 0x6030      ADDS     R0,R3,#+2816
   \   00000030   0x6900             LDR      R0,[R0, #+16]
   \   00000032   0xF050 0x40C0      ORRS     R0,R0,#0x60000000
   \   00000036   0xF513 0x6430      ADDS     R4,R3,#+2816
   \   0000003A   0x6120             STR      R0,[R4, #+16]
   1066            
   1067            if (dma == 1)
   \   0000003C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000003E   0x2901             CMP      R1,#+1
   \   00000040   0xD107             BNE.N    ??USB_EP0_OutStart_0
   1068            {
   1069              USBx_OUTEP(0)->DOEPDMA = (uint32_t)psetup;
   \   00000042   0xF513 0x6030      ADDS     R0,R3,#+2816
   \   00000046   0x6142             STR      R2,[R0, #+20]
   1070              /* EP enable */
   1071              USBx_OUTEP(0)->DOEPCTL = 0x80008000;
   \   00000048   0xF05F 0x2080      MOVS     R0,#-2147450880
   \   0000004C   0xF513 0x6430      ADDS     R4,R3,#+2816
   \   00000050   0x6020             STR      R0,[R4, #+0]
   1072            }
   1073            
   1074            return HAL_OK;  
   \                     ??USB_EP0_OutStart_0: (+1)
   \   00000052   0x2000             MOVS     R0,#+0
   \   00000054   0xBC10             POP      {R4}
   \   00000056   0x4770             BX       LR               ;; return
   1075          }
   1076          
   1077          
   1078          /**
   1079            * @brief  Reset the USB Core (needed after USB clock settings change)
   1080            * @param  USBx : Selected device
   1081            * @retval HAL status
   1082            */

   \                                 In section .text, align 2, keep-with-next
   1083          static HAL_StatusTypeDef USB_CoreReset(USB_OTG_GlobalTypeDef *USBx)
   1084          {
   \                     USB_CoreReset: (+1)
   \   00000000   0x0001             MOVS     R1,R0
   1085            uint32_t count = 0;
   \   00000002   0x2200             MOVS     R2,#+0
   1086          
   1087            /* Wait for AHB master IDLE state. */
   1088            do
   1089            {
   1090              if (++count > 200000)
   \                     ??USB_CoreReset_0: (+1)
   \   00000004   0x1C52             ADDS     R2,R2,#+1
   \   00000006   0x....             LDR.N    R0,??DataTable7_2  ;; 0x30d41
   \   00000008   0x4282             CMP      R2,R0
   \   0000000A   0xD301             BCC.N    ??USB_CoreReset_1
   1091              {
   1092                return HAL_TIMEOUT;
   \   0000000C   0x2003             MOVS     R0,#+3
   \   0000000E   0xE012             B.N      ??USB_CoreReset_2
   1093              }
   1094            }
   1095            while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_AHBIDL) == 0);
   \                     ??USB_CoreReset_1: (+1)
   \   00000010   0x6908             LDR      R0,[R1, #+16]
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD5F6             BPL.N    ??USB_CoreReset_0
   1096            
   1097            /* Core Soft Reset */
   1098            count = 0;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0x0002             MOVS     R2,R0
   1099            USBx->GRSTCTL |= USB_OTG_GRSTCTL_CSRST;
   \   0000001A   0x6908             LDR      R0,[R1, #+16]
   \   0000001C   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000020   0x6108             STR      R0,[R1, #+16]
   1100          
   1101            do
   1102            {
   1103              if (++count > 200000)
   \                     ??USB_CoreReset_3: (+1)
   \   00000022   0x1C52             ADDS     R2,R2,#+1
   \   00000024   0x....             LDR.N    R0,??DataTable7_2  ;; 0x30d41
   \   00000026   0x4282             CMP      R2,R0
   \   00000028   0xD301             BCC.N    ??USB_CoreReset_4
   1104              {
   1105                return HAL_TIMEOUT;
   \   0000002A   0x2003             MOVS     R0,#+3
   \   0000002C   0xE003             B.N      ??USB_CoreReset_2
   1106              }
   1107            }
   1108            while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_CSRST) == USB_OTG_GRSTCTL_CSRST);
   \                     ??USB_CoreReset_4: (+1)
   \   0000002E   0x6908             LDR      R0,[R1, #+16]
   \   00000030   0x07C0             LSLS     R0,R0,#+31
   \   00000032   0xD4F6             BMI.N    ??USB_CoreReset_3
   1109            
   1110            return HAL_OK;
   \   00000034   0x2000             MOVS     R0,#+0
   \                     ??USB_CoreReset_2: (+1)
   \   00000036   0x4770             BX       LR               ;; return
   1111          }
   1112          
   1113          
   1114          /**
   1115            * @brief  USB_HostInit : Initializes the USB OTG controller registers 
   1116            *         for Host mode 
   1117            * @param  USBx : Selected device
   1118            * @param  cfg  : pointer to a USB_OTG_CfgTypeDef structure that contains
   1119            *         the configuration information for the specified USBx peripheral.
   1120            * @retval HAL status
   1121            */

   \                                 In section .text, align 2, keep-with-next
   1122          HAL_StatusTypeDef USB_HostInit (USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
   1123          {
   \                     USB_HostInit: (+1)
   \   00000000   0xB40E             PUSH     {R1-R3}
   \   00000002   0xB530             PUSH     {R4,R5,LR}
   \   00000004   0x0004             MOVS     R4,R0
   1124            uint32_t i;
   1125            
   1126            /* Restart the Phy Clock */
   1127            USBx_PCGCCTL = 0;
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0xF514 0x6160      ADDS     R1,R4,#+3584
   \   0000000C   0x6008             STR      R0,[R1, #+0]
   1128            
   1129            /*Activate VBUS Sensing B */
   1130            USBx->GCCFG |= USB_OTG_GCCFG_VBDEN;
   \   0000000E   0x6BA0             LDR      R0,[R4, #+56]
   \   00000010   0xF450 0x1000      ORRS     R0,R0,#0x200000
   \   00000014   0x63A0             STR      R0,[R4, #+56]
   1131            
   1132            /* Disable the FS/LS support mode only */
   1133            if((cfg.speed == USB_OTG_SPEED_FULL)&&
   1134               (USBx != USB_OTG_FS))
   \   00000016   0x9805             LDR      R0,[SP, #+20]
   \   00000018   0x2803             CMP      R0,#+3
   \   0000001A   0xD10B             BNE.N    ??USB_HostInit_0
   \   0000001C   0xF1B4 0x4FA0      CMP      R4,#+1342177280
   \   00000020   0xD008             BEQ.N    ??USB_HostInit_0
   1135            {
   1136              USBx_HOST->HCFG |= USB_OTG_HCFG_FSLSS; 
   \   00000022   0xF514 0x6080      ADDS     R0,R4,#+1024
   \   00000026   0x6800             LDR      R0,[R0, #+0]
   \   00000028   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   0000002C   0xF514 0x6180      ADDS     R1,R4,#+1024
   \   00000030   0x6008             STR      R0,[R1, #+0]
   \   00000032   0xE007             B.N      ??USB_HostInit_1
   1137            }
   1138            else
   1139            {
   1140              USBx_HOST->HCFG &= ~(USB_OTG_HCFG_FSLSS);  
   \                     ??USB_HostInit_0: (+1)
   \   00000034   0xF514 0x6080      ADDS     R0,R4,#+1024
   \   00000038   0x6800             LDR      R0,[R0, #+0]
   \   0000003A   0xF030 0x0004      BICS     R0,R0,#0x4
   \   0000003E   0xF514 0x6180      ADDS     R1,R4,#+1024
   \   00000042   0x6008             STR      R0,[R1, #+0]
   1141            }
   1142          
   1143            /* Make sure the FIFOs are flushed. */
   1144            USB_FlushTxFifo(USBx, 0x10 ); /* all Tx FIFOs */
   \                     ??USB_HostInit_1: (+1)
   \   00000044   0x2110             MOVS     R1,#+16
   \   00000046   0x0020             MOVS     R0,R4
   \   00000048   0x.... 0x....      BL       USB_FlushTxFifo
   1145            USB_FlushRxFifo(USBx);
   \   0000004C   0x0020             MOVS     R0,R4
   \   0000004E   0x.... 0x....      BL       USB_FlushRxFifo
   1146          
   1147            /* Clear all pending HC Interrupts */
   1148            for (i = 0; i < cfg.Host_channels; i++)
   \   00000052   0x2000             MOVS     R0,#+0
   \   00000054   0x0005             MOVS     R5,R0
   \                     ??USB_HostInit_2: (+1)
   \   00000056   0x9804             LDR      R0,[SP, #+16]
   \   00000058   0x4285             CMP      R5,R0
   \   0000005A   0xD20E             BCS.N    ??USB_HostInit_3
   1149            {
   1150              USBx_HC(i)->HCINT = 0xFFFFFFFF;
   \   0000005C   0xEB14 0x1045      ADDS     R0,R4,R5, LSL #+5
   \   00000060   0xF510 0x60A0      ADDS     R0,R0,#+1280
   \   00000064   0xF05F 0x31FF      MOVS     R1,#-1
   \   00000068   0x6081             STR      R1,[R0, #+8]
   1151              USBx_HC(i)->HCINTMSK = 0;
   \   0000006A   0xEB14 0x1045      ADDS     R0,R4,R5, LSL #+5
   \   0000006E   0xF510 0x60A0      ADDS     R0,R0,#+1280
   \   00000072   0x2100             MOVS     R1,#+0
   \   00000074   0x60C1             STR      R1,[R0, #+12]
   1152            }
   \   00000076   0x1C6D             ADDS     R5,R5,#+1
   \   00000078   0xE7ED             B.N      ??USB_HostInit_2
   1153            
   1154            /* Enable VBUS driving */
   1155            USB_DriveVbus(USBx, 1);
   \                     ??USB_HostInit_3: (+1)
   \   0000007A   0x2101             MOVS     R1,#+1
   \   0000007C   0x0020             MOVS     R0,R4
   \   0000007E   0x.... 0x....      BL       USB_DriveVbus
   1156            
   1157            HAL_Delay(200);
   \   00000082   0x20C8             MOVS     R0,#+200
   \   00000084   0x.... 0x....      BL       HAL_Delay
   1158            
   1159            /* Disable all interrupts. */
   1160            USBx->GINTMSK = 0;
   \   00000088   0x2000             MOVS     R0,#+0
   \   0000008A   0x61A0             STR      R0,[R4, #+24]
   1161            
   1162            /* Clear any pending interrupts */
   1163            USBx->GINTSTS = 0xFFFFFFFF;
   \   0000008C   0xF05F 0x30FF      MOVS     R0,#-1
   \   00000090   0x6160             STR      R0,[R4, #+20]
   1164          
   1165            
   1166            if(USBx == USB_OTG_FS)
   \   00000092   0xF1B4 0x4FA0      CMP      R4,#+1342177280
   \   00000096   0xD109             BNE.N    ??USB_HostInit_4
   1167            {
   1168              /* set Rx FIFO size */
   1169              USBx->GRXFSIZ  = (uint32_t )0x80; 
   \   00000098   0x2080             MOVS     R0,#+128
   \   0000009A   0x6260             STR      R0,[R4, #+36]
   1170              USBx->DIEPTXF0_HNPTXFSIZ = (uint32_t )(((0x60 << 16)& USB_OTG_NPTXFD) | 0x80);
   \   0000009C   0x.... 0x....      LDR.W    R0,??DataTable8_1  ;; 0x600080
   \   000000A0   0x62A0             STR      R0,[R4, #+40]
   1171              USBx->HPTXFSIZ = (uint32_t )(((0x40 << 16)& USB_OTG_HPTXFSIZ_PTXFD) | 0xE0);
   \   000000A2   0x.... 0x....      LDR.W    R0,??DataTable8_2  ;; 0x4000e0
   \   000000A6   0xF8C4 0x0100      STR      R0,[R4, #+256]
   \   000000AA   0xE009             B.N      ??USB_HostInit_5
   1172          
   1173            }
   1174          
   1175            else
   1176            {
   1177              /* set Rx FIFO size */
   1178              USBx->GRXFSIZ  = (uint32_t )0x200; 
   \                     ??USB_HostInit_4: (+1)
   \   000000AC   0xF44F 0x7000      MOV      R0,#+512
   \   000000B0   0x6260             STR      R0,[R4, #+36]
   1179              USBx->DIEPTXF0_HNPTXFSIZ = (uint32_t )(((0x100 << 16)& USB_OTG_NPTXFD) | 0x200);
   \   000000B2   0x.... 0x....      LDR.W    R0,??DataTable8_3  ;; 0x1000200
   \   000000B6   0x62A0             STR      R0,[R4, #+40]
   1180              USBx->HPTXFSIZ = (uint32_t )(((0xE0 << 16)& USB_OTG_HPTXFSIZ_PTXFD) | 0x300);
   \   000000B8   0x.... 0x....      LDR.W    R0,??DataTable8_4  ;; 0xe00300
   \   000000BC   0xF8C4 0x0100      STR      R0,[R4, #+256]
   1181            }
   1182            
   1183            /* Enable the common interrupts */
   1184            if (cfg.dma_enable == DISABLE)
   \                     ??USB_HostInit_5: (+1)
   \   000000C0   0x9806             LDR      R0,[SP, #+24]
   \   000000C2   0x2800             CMP      R0,#+0
   \   000000C4   0xD103             BNE.N    ??USB_HostInit_6
   1185            {
   1186              USBx->GINTMSK |= USB_OTG_GINTMSK_RXFLVLM; 
   \   000000C6   0x69A0             LDR      R0,[R4, #+24]
   \   000000C8   0xF050 0x0010      ORRS     R0,R0,#0x10
   \   000000CC   0x61A0             STR      R0,[R4, #+24]
   1187            }
   1188            
   1189            /* Enable interrupts matching to the Host mode ONLY */
   1190            USBx->GINTMSK |= (USB_OTG_GINTMSK_PRTIM            | USB_OTG_GINTMSK_HCIM |\
   1191                              USB_OTG_GINTMSK_SOFM             |USB_OTG_GINTSTS_DISCINT|\
   1192                              USB_OTG_GINTMSK_PXFRM_IISOOXFRM  | USB_OTG_GINTMSK_WUIM);
   \                     ??USB_HostInit_6: (+1)
   \   000000CE   0x69A0             LDR      R0,[R4, #+24]
   \   000000D0   0x.... 0x....      LDR.W    R1,??DataTable8_5  ;; 0xa3200008
   \   000000D4   0x4308             ORRS     R0,R1,R0
   \   000000D6   0x61A0             STR      R0,[R4, #+24]
   1193          
   1194            return HAL_OK;
   \   000000D8   0x2000             MOVS     R0,#+0
   \   000000DA   0xBC30             POP      {R4,R5}
   \   000000DC   0xF85D 0xFB10      LDR      PC,[SP], #+16    ;; return
   1195          }
   1196          
   1197          /**
   1198            * @brief  USB_InitFSLSPClkSel : Initializes the FSLSPClkSel field of the 
   1199            *         HCFG register on the PHY type and set the right frame interval
   1200            * @param  USBx : Selected device
   1201            * @param  freq : clock frequency
   1202            *          This parameter can be one of the these values:
   1203            *           HCFG_48_MHZ : Full Speed 48 MHz Clock 
   1204            *           HCFG_6_MHZ : Low Speed 6 MHz Clock 
   1205            * @retval HAL status
   1206            */

   \                                 In section .text, align 2, keep-with-next
   1207          HAL_StatusTypeDef USB_InitFSLSPClkSel(USB_OTG_GlobalTypeDef *USBx , uint8_t freq)
   1208          {
   \                     USB_InitFSLSPClkSel: (+1)
   \   00000000   0x0002             MOVS     R2,R0
   1209            USBx_HOST->HCFG &= ~(USB_OTG_HCFG_FSLSPCS);
   \   00000002   0xF512 0x6080      ADDS     R0,R2,#+1024
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0x0880             LSRS     R0,R0,#+2
   \   0000000A   0x0080             LSLS     R0,R0,#+2
   \   0000000C   0xF512 0x6380      ADDS     R3,R2,#+1024
   \   00000010   0x6018             STR      R0,[R3, #+0]
   1210            USBx_HOST->HCFG |= (freq & USB_OTG_HCFG_FSLSPCS);
   \   00000012   0xF512 0x6080      ADDS     R0,R2,#+1024
   \   00000016   0x6800             LDR      R0,[R0, #+0]
   \   00000018   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000001A   0xF011 0x0303      ANDS     R3,R1,#0x3
   \   0000001E   0x4318             ORRS     R0,R3,R0
   \   00000020   0xF512 0x6380      ADDS     R3,R2,#+1024
   \   00000024   0x6018             STR      R0,[R3, #+0]
   1211            
   1212            if (freq ==  HCFG_48_MHZ)
   \   00000026   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000028   0x2901             CMP      R1,#+1
   \   0000002A   0xD105             BNE.N    ??USB_InitFSLSPClkSel_0
   1213            {
   1214              USBx_HOST->HFIR = (uint32_t)48000;
   \   0000002C   0xF64B 0x3080      MOVW     R0,#+48000
   \   00000030   0xF512 0x6380      ADDS     R3,R2,#+1024
   \   00000034   0x6058             STR      R0,[R3, #+4]
   \   00000036   0xE007             B.N      ??USB_InitFSLSPClkSel_1
   1215            }
   1216            else if (freq ==  HCFG_6_MHZ)
   \                     ??USB_InitFSLSPClkSel_0: (+1)
   \   00000038   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000003A   0x2902             CMP      R1,#+2
   \   0000003C   0xD104             BNE.N    ??USB_InitFSLSPClkSel_1
   1217            {
   1218              USBx_HOST->HFIR = (uint32_t)6000;
   \   0000003E   0xF241 0x7070      MOVW     R0,#+6000
   \   00000042   0xF512 0x6380      ADDS     R3,R2,#+1024
   \   00000046   0x6058             STR      R0,[R3, #+4]
   1219            } 
   1220            return HAL_OK;  
   \                     ??USB_InitFSLSPClkSel_1: (+1)
   \   00000048   0x2000             MOVS     R0,#+0
   \   0000004A   0x4770             BX       LR               ;; return
   1221          }
   1222          
   1223          /**
   1224          * @brief  USB_OTG_ResetPort : Reset Host Port
   1225            * @param  USBx : Selected device
   1226            * @retval HAL status
   1227            * @note : (1)The application must wait at least 10 ms
   1228            *   before clearing the reset bit.
   1229            */

   \                                 In section .text, align 2, keep-with-next
   1230          HAL_StatusTypeDef USB_ResetPort(USB_OTG_GlobalTypeDef *USBx)
   1231          {
   \                     USB_ResetPort: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0004             MOVS     R4,R0
   1232            __IO uint32_t hprt0;
   1233            
   1234            hprt0 = USBx_HPRT0;
   \   00000006   0xF514 0x6088      ADDS     R0,R4,#+1088
   \   0000000A   0x6800             LDR      R0,[R0, #+0]
   \   0000000C   0x9000             STR      R0,[SP, #+0]
   1235            
   1236            hprt0 &= ~(USB_OTG_HPRT_PENA    | USB_OTG_HPRT_PCDET |\
   1237              USB_OTG_HPRT_PENCHNG | USB_OTG_HPRT_POCCHNG );
   \   0000000E   0x9800             LDR      R0,[SP, #+0]
   \   00000010   0xF030 0x002E      BICS     R0,R0,#0x2E
   \   00000014   0x9000             STR      R0,[SP, #+0]
   1238            
   1239            USBx_HPRT0 = (USB_OTG_HPRT_PRST | hprt0);  
   \   00000016   0x9800             LDR      R0,[SP, #+0]
   \   00000018   0xF450 0x7080      ORRS     R0,R0,#0x100
   \   0000001C   0xF514 0x6188      ADDS     R1,R4,#+1088
   \   00000020   0x6008             STR      R0,[R1, #+0]
   1240            HAL_Delay (10);                                /* See Note #1 */
   \   00000022   0x200A             MOVS     R0,#+10
   \   00000024   0x.... 0x....      BL       HAL_Delay
   1241            USBx_HPRT0 = ((~USB_OTG_HPRT_PRST) & hprt0); 
   \   00000028   0x9800             LDR      R0,[SP, #+0]
   \   0000002A   0xF430 0x7080      BICS     R0,R0,#0x100
   \   0000002E   0xF514 0x6188      ADDS     R1,R4,#+1088
   \   00000032   0x6008             STR      R0,[R1, #+0]
   1242            return HAL_OK;
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0xBD16             POP      {R1,R2,R4,PC}    ;; return
   1243          }
   1244          
   1245          /**
   1246            * @brief  USB_DriveVbus : activate or de-activate vbus
   1247            * @param  state : VBUS state
   1248            *          This parameter can be one of the these values:
   1249            *           0 : VBUS Active 
   1250            *           1 : VBUS Inactive
   1251            * @retval HAL status
   1252          */

   \                                 In section .text, align 2, keep-with-next
   1253          HAL_StatusTypeDef USB_DriveVbus (USB_OTG_GlobalTypeDef *USBx, uint8_t state)
   1254          {
   \                     USB_DriveVbus: (+1)
   \   00000000   0xB081             SUB      SP,SP,#+4
   \   00000002   0x0002             MOVS     R2,R0
   1255            __IO uint32_t hprt0;
   1256          
   1257            hprt0 = USBx_HPRT0;
   \   00000004   0xF512 0x6088      ADDS     R0,R2,#+1088
   \   00000008   0x6800             LDR      R0,[R0, #+0]
   \   0000000A   0x9000             STR      R0,[SP, #+0]
   1258            hprt0 &= ~(USB_OTG_HPRT_PENA    | USB_OTG_HPRT_PCDET |\
   1259                                   USB_OTG_HPRT_PENCHNG | USB_OTG_HPRT_POCCHNG );
   \   0000000C   0x9800             LDR      R0,[SP, #+0]
   \   0000000E   0xF030 0x002E      BICS     R0,R0,#0x2E
   \   00000012   0x9000             STR      R0,[SP, #+0]
   1260            
   1261            if (((hprt0 & USB_OTG_HPRT_PPWR) == 0 ) && (state == 1 ))
   \   00000014   0x9800             LDR      R0,[SP, #+0]
   \   00000016   0x04C0             LSLS     R0,R0,#+19
   \   00000018   0xD408             BMI.N    ??USB_DriveVbus_0
   \   0000001A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000001C   0x2901             CMP      R1,#+1
   \   0000001E   0xD105             BNE.N    ??USB_DriveVbus_0
   1262            {
   1263              USBx_HPRT0 = (USB_OTG_HPRT_PPWR | hprt0); 
   \   00000020   0x9800             LDR      R0,[SP, #+0]
   \   00000022   0xF450 0x5080      ORRS     R0,R0,#0x1000
   \   00000026   0xF512 0x6388      ADDS     R3,R2,#+1088
   \   0000002A   0x6018             STR      R0,[R3, #+0]
   1264            }
   1265            if (((hprt0 & USB_OTG_HPRT_PPWR) == USB_OTG_HPRT_PPWR) && (state == 0 ))
   \                     ??USB_DriveVbus_0: (+1)
   \   0000002C   0x9800             LDR      R0,[SP, #+0]
   \   0000002E   0x04C0             LSLS     R0,R0,#+19
   \   00000030   0xD508             BPL.N    ??USB_DriveVbus_1
   \   00000032   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000034   0x2900             CMP      R1,#+0
   \   00000036   0xD105             BNE.N    ??USB_DriveVbus_1
   1266            {
   1267              USBx_HPRT0 = ((~USB_OTG_HPRT_PPWR) & hprt0); 
   \   00000038   0x9800             LDR      R0,[SP, #+0]
   \   0000003A   0xF430 0x5080      BICS     R0,R0,#0x1000
   \   0000003E   0xF512 0x6388      ADDS     R3,R2,#+1088
   \   00000042   0x6018             STR      R0,[R3, #+0]
   1268            }
   1269            return HAL_OK; 
   \                     ??USB_DriveVbus_1: (+1)
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0xB001             ADD      SP,SP,#+4
   \   00000048   0x4770             BX       LR               ;; return
   1270          }
   1271          
   1272          /**
   1273            * @brief  Return Host Core speed
   1274            * @param  USBx : Selected device
   1275            * @retval speed : Host speed
   1276            *          This parameter can be one of the these values:
   1277            *            @arg USB_OTG_SPEED_HIGH: High speed mode
   1278            *            @arg USB_OTG_SPEED_FULL: Full speed mode
   1279            *            @arg USB_OTG_SPEED_LOW: Low speed mode
   1280            */

   \                                 In section .text, align 2, keep-with-next
   1281          uint32_t USB_GetHostSpeed (USB_OTG_GlobalTypeDef *USBx)
   1282          {
   \                     USB_GetHostSpeed: (+1)
   \   00000000   0xB081             SUB      SP,SP,#+4
   \   00000002   0x0001             MOVS     R1,R0
   1283            __IO uint32_t hprt0;
   1284            
   1285            hprt0 = USBx_HPRT0;
   \   00000004   0xF511 0x6088      ADDS     R0,R1,#+1088
   \   00000008   0x6800             LDR      R0,[R0, #+0]
   \   0000000A   0x9000             STR      R0,[SP, #+0]
   1286            return ((hprt0 & USB_OTG_HPRT_PSPD) >> 17);
   \   0000000C   0x9800             LDR      R0,[SP, #+0]
   \   0000000E   0xF3C0 0x4041      UBFX     R0,R0,#+17,#+2
   \   00000012   0xB001             ADD      SP,SP,#+4
   \   00000014   0x4770             BX       LR               ;; return
   1287          }
   1288          
   1289          /**
   1290            * @brief  Return Host Current Frame number
   1291            * @param  USBx : Selected device
   1292            * @retval current frame number
   1293          */

   \                                 In section .text, align 2, keep-with-next
   1294          uint32_t USB_GetCurrentFrame (USB_OTG_GlobalTypeDef *USBx)
   1295          {
   1296            return (USBx_HOST->HFNUM & USB_OTG_HFNUM_FRNUM);
   \                     USB_GetCurrentFrame: (+1)
   \   00000000   0xF510 0x6080      ADDS     R0,R0,#+1024
   \   00000004   0x6880             LDR      R0,[R0, #+8]
   \   00000006   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000008   0x4770             BX       LR               ;; return
   1297          }
   1298          
   1299          /**
   1300            * @brief  Initialize a host channel
   1301            * @param  USBx : Selected device
   1302            * @param  ch_num : Channel number
   1303            *         This parameter can be a value from 1 to 15
   1304            * @param  epnum : Endpoint number
   1305            *          This parameter can be a value from 1 to 15
   1306            * @param  dev_address : Current device address
   1307            *          This parameter can be a value from 0 to 255
   1308            * @param  speed : Current device speed
   1309            *          This parameter can be one of the these values:
   1310            *            @arg USB_OTG_SPEED_HIGH: High speed mode
   1311            *            @arg USB_OTG_SPEED_FULL: Full speed mode
   1312            *            @arg USB_OTG_SPEED_LOW: Low speed mode
   1313            * @param  ep_type : Endpoint Type
   1314            *          This parameter can be one of the these values:
   1315            *            @arg EP_TYPE_CTRL: Control type
   1316            *            @arg EP_TYPE_ISOC: Isochronous type
   1317            *            @arg EP_TYPE_BULK: Bulk type
   1318            *            @arg EP_TYPE_INTR: Interrupt type
   1319            * @param  mps : Max Packet Size
   1320            *          This parameter can be a value from 0 to32K
   1321            * @retval HAL state
   1322            */

   \                                 In section .text, align 2, keep-with-next
   1323          HAL_StatusTypeDef USB_HC_Init(USB_OTG_GlobalTypeDef *USBx,  
   1324                                        uint8_t ch_num,
   1325                                        uint8_t epnum,
   1326                                        uint8_t dev_address,
   1327                                        uint8_t speed,
   1328                                        uint8_t ep_type,
   1329                                        uint16_t mps)
   1330          {
   \                     USB_HC_Init: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0007             MOVS     R7,R0
   \   00000006   0x9C06             LDR      R4,[SP, #+24]
   \   00000008   0x9D07             LDR      R5,[SP, #+28]
   \   0000000A   0x9E08             LDR      R6,[SP, #+32]
   1331              
   1332            /* Clear old interrupt conditions for this host channel. */
   1333            USBx_HC(ch_num)->HCINT = 0xFFFFFFFF;
   \   0000000C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000E   0xEB17 0x1041      ADDS     R0,R7,R1, LSL #+5
   \   00000012   0xF510 0x60A0      ADDS     R0,R0,#+1280
   \   00000016   0xF05F 0x3CFF      MOVS     R12,#-1
   \   0000001A   0xF8C0 0xC008      STR      R12,[R0, #+8]
   1334            
   1335            /* Enable channel interrupts required for this transfer. */
   1336            switch (ep_type) 
   \   0000001E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000020   0x2D00             CMP      R5,#+0
   \   00000022   0xD005             BEQ.N    ??USB_HC_Init_0
   \   00000024   0x2D02             CMP      R5,#+2
   \   00000026   0xD003             BEQ.N    ??USB_HC_Init_0
   \   00000028   0xD34E             BCC.N    ??USB_HC_Init_1
   \   0000002A   0x2D03             CMP      R5,#+3
   \   0000002C   0xD030             BEQ.N    ??USB_HC_Init_2
   \   0000002E   0xE066             B.N      ??USB_HC_Init_3
   1337            {
   1338            case EP_TYPE_CTRL:
   1339            case EP_TYPE_BULK:
   1340              
   1341              USBx_HC(ch_num)->HCINTMSK = USB_OTG_HCINTMSK_XFRCM  |\
   1342                                          USB_OTG_HCINTMSK_STALLM |\
   1343                                          USB_OTG_HCINTMSK_TXERRM |\
   1344                                          USB_OTG_HCINTMSK_DTERRM |\
   1345                                          USB_OTG_HCINTMSK_AHBERR |\
   1346                                          USB_OTG_HCINTMSK_NAKM ;
   \                     ??USB_HC_Init_0: (+1)
   \   00000030   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000032   0xEB17 0x1041      ADDS     R0,R7,R1, LSL #+5
   \   00000036   0xF510 0x60A0      ADDS     R0,R0,#+1280
   \   0000003A   0xF240 0x4C9D      MOVW     R12,#+1181
   \   0000003E   0xF8C0 0xC00C      STR      R12,[R0, #+12]
   1347           
   1348              if (epnum & 0x80) 
   \   00000042   0x0610             LSLS     R0,R2,#+24
   \   00000044   0xD510             BPL.N    ??USB_HC_Init_4
   1349              {
   1350                USBx_HC(ch_num)->HCINTMSK |= USB_OTG_HCINTMSK_BBERRM;
   \   00000046   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000048   0xEB17 0x1041      ADDS     R0,R7,R1, LSL #+5
   \   0000004C   0xF510 0x60A0      ADDS     R0,R0,#+1280
   \   00000050   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000052   0xEB17 0x1C41      ADDS     R12,R7,R1, LSL #+5
   \   00000056   0xF51C 0x6CA0      ADDS     R12,R12,#+1280
   \   0000005A   0xF8DC 0xC00C      LDR      R12,[R12, #+12]
   \   0000005E   0xF45C 0x7C80      ORRS     R12,R12,#0x100
   \   00000062   0xF8C0 0xC00C      STR      R12,[R0, #+12]
   \   00000066   0xE012             B.N      ??USB_HC_Init_5
   1351              } 
   1352              else 
   1353              {
   1354                if(USBx != USB_OTG_FS)
   \                     ??USB_HC_Init_4: (+1)
   \   00000068   0xF1B7 0x4FA0      CMP      R7,#+1342177280
   \   0000006C   0xD00F             BEQ.N    ??USB_HC_Init_5
   1355                {
   1356                  USBx_HC(ch_num)->HCINTMSK |= (USB_OTG_HCINTMSK_NYET | USB_OTG_HCINTMSK_ACKM);
   \   0000006E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000070   0xEB17 0x1041      ADDS     R0,R7,R1, LSL #+5
   \   00000074   0xF510 0x60A0      ADDS     R0,R0,#+1280
   \   00000078   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000007A   0xEB17 0x1C41      ADDS     R12,R7,R1, LSL #+5
   \   0000007E   0xF51C 0x6CA0      ADDS     R12,R12,#+1280
   \   00000082   0xF8DC 0xC00C      LDR      R12,[R12, #+12]
   \   00000086   0xF05C 0x0C60      ORRS     R12,R12,#0x60
   \   0000008A   0xF8C0 0xC00C      STR      R12,[R0, #+12]
   1357                }
   1358              }
   1359              break;
   \                     ??USB_HC_Init_5: (+1)
   \   0000008E   0xE036             B.N      ??USB_HC_Init_3
   1360            case EP_TYPE_INTR:
   1361              
   1362              USBx_HC(ch_num)->HCINTMSK = USB_OTG_HCINTMSK_XFRCM  |\
   1363                                          USB_OTG_HCINTMSK_STALLM |\
   1364                                          USB_OTG_HCINTMSK_TXERRM |\
   1365                                          USB_OTG_HCINTMSK_DTERRM |\
   1366                                          USB_OTG_HCINTMSK_NAKM   |\
   1367                                          USB_OTG_HCINTMSK_AHBERR |\
   1368                                          USB_OTG_HCINTMSK_FRMORM ;    
   \                     ??USB_HC_Init_2: (+1)
   \   00000090   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000092   0xEB17 0x1041      ADDS     R0,R7,R1, LSL #+5
   \   00000096   0xF510 0x60A0      ADDS     R0,R0,#+1280
   \   0000009A   0xF240 0x6C9D      MOVW     R12,#+1693
   \   0000009E   0xF8C0 0xC00C      STR      R12,[R0, #+12]
   1369              
   1370              if (epnum & 0x80) 
   \   000000A2   0x0610             LSLS     R0,R2,#+24
   \   000000A4   0xD50F             BPL.N    ??USB_HC_Init_6
   1371              {
   1372                USBx_HC(ch_num)->HCINTMSK |= USB_OTG_HCINTMSK_BBERRM;
   \   000000A6   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000A8   0xEB17 0x1041      ADDS     R0,R7,R1, LSL #+5
   \   000000AC   0xF510 0x60A0      ADDS     R0,R0,#+1280
   \   000000B0   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000B2   0xEB17 0x1C41      ADDS     R12,R7,R1, LSL #+5
   \   000000B6   0xF51C 0x6CA0      ADDS     R12,R12,#+1280
   \   000000BA   0xF8DC 0xC00C      LDR      R12,[R12, #+12]
   \   000000BE   0xF45C 0x7C80      ORRS     R12,R12,#0x100
   \   000000C2   0xF8C0 0xC00C      STR      R12,[R0, #+12]
   1373              }
   1374              
   1375              break;
   \                     ??USB_HC_Init_6: (+1)
   \   000000C6   0xE01A             B.N      ??USB_HC_Init_3
   1376            case EP_TYPE_ISOC:
   1377              
   1378              USBx_HC(ch_num)->HCINTMSK = USB_OTG_HCINTMSK_XFRCM  |\
   1379                                          USB_OTG_HCINTMSK_ACKM   |\
   1380                                          USB_OTG_HCINTMSK_AHBERR |\
   1381                                          USB_OTG_HCINTMSK_FRMORM ;   
   \                     ??USB_HC_Init_1: (+1)
   \   000000C8   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000CA   0xEB17 0x1041      ADDS     R0,R7,R1, LSL #+5
   \   000000CE   0xF510 0x60A0      ADDS     R0,R0,#+1280
   \   000000D2   0xF240 0x2C25      MOVW     R12,#+549
   \   000000D6   0xF8C0 0xC00C      STR      R12,[R0, #+12]
   1382              
   1383              if (epnum & 0x80) 
   \   000000DA   0x0610             LSLS     R0,R2,#+24
   \   000000DC   0xD50F             BPL.N    ??USB_HC_Init_7
   1384              {
   1385                USBx_HC(ch_num)->HCINTMSK |= (USB_OTG_HCINTMSK_TXERRM | USB_OTG_HCINTMSK_BBERRM);      
   \   000000DE   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000E0   0xEB17 0x1041      ADDS     R0,R7,R1, LSL #+5
   \   000000E4   0xF510 0x60A0      ADDS     R0,R0,#+1280
   \   000000E8   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000EA   0xEB17 0x1C41      ADDS     R12,R7,R1, LSL #+5
   \   000000EE   0xF51C 0x6CA0      ADDS     R12,R12,#+1280
   \   000000F2   0xF8DC 0xC00C      LDR      R12,[R12, #+12]
   \   000000F6   0xF45C 0x7CC0      ORRS     R12,R12,#0x180
   \   000000FA   0xF8C0 0xC00C      STR      R12,[R0, #+12]
   1386              }
   1387              break;
   1388            }
   1389            
   1390            /* Enable the top level host channel interrupt. */
   1391            USBx_HOST->HAINTMSK |= (1 << ch_num);
   \                     ??USB_HC_Init_7: (+1)
   \                     ??USB_HC_Init_3: (+1)
   \   000000FE   0xF517 0x6080      ADDS     R0,R7,#+1024
   \   00000102   0x6980             LDR      R0,[R0, #+24]
   \   00000104   0xF05F 0x0C01      MOVS     R12,#+1
   \   00000108   0xFA1C 0xFC01      LSLS     R12,R12,R1
   \   0000010C   0xEA5C 0x0000      ORRS     R0,R12,R0
   \   00000110   0xF517 0x6C80      ADDS     R12,R7,#+1024
   \   00000114   0xF8CC 0x0018      STR      R0,[R12, #+24]
   1392            
   1393            /* Make sure host channel interrupts are enabled. */
   1394            USBx->GINTMSK |= USB_OTG_GINTMSK_HCIM;
   \   00000118   0x69B8             LDR      R0,[R7, #+24]
   \   0000011A   0xF050 0x7000      ORRS     R0,R0,#0x2000000
   \   0000011E   0x61B8             STR      R0,[R7, #+24]
   1395            
   1396            /* Program the HCCHAR register */
   1397            USBx_HC(ch_num)->HCCHAR = (((dev_address << 22) & USB_OTG_HCCHAR_DAD)  |\
   1398                                       (((epnum & 0x7F)<< 11) & USB_OTG_HCCHAR_EPNUM)|\
   1399                                       ((((epnum & 0x80) == 0x80)<< 15) & USB_OTG_HCCHAR_EPDIR)|\
   1400                                       (((speed == HPRT0_PRTSPD_LOW_SPEED)<< 17) & USB_OTG_HCCHAR_LSDEV)|\
   1401                                       ((ep_type << 18) & USB_OTG_HCCHAR_EPTYP)|\
   1402                                       (mps & USB_OTG_HCCHAR_MPSIZ));
   \   00000120   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000122   0xF012 0x0080      ANDS     R0,R2,#0x80
   \   00000126   0xEA5F 0x1CE0      ASRS     R12,R0,#+7
   \   0000012A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000012C   0x2C02             CMP      R4,#+2
   \   0000012E   0xD101             BNE.N    ??USB_HC_Init_8
   \   00000130   0x2001             MOVS     R0,#+1
   \   00000132   0xE000             B.N      ??USB_HC_Init_9
   \                     ??USB_HC_Init_8: (+1)
   \   00000134   0x2000             MOVS     R0,#+0
   \                     ??USB_HC_Init_9: (+1)
   \   00000136   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000138   0xEA5F 0x5E83      LSLS     LR,R3,#+22
   \   0000013C   0xF01E 0x5EFE      ANDS     LR,LR,#0x1FC00000
   \   00000140   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000142   0xEA5F 0x28C2      LSLS     R8,R2,#+11
   \   00000146   0xF418 0x48F0      ANDS     R8,R8,#0x7800
   \   0000014A   0xEA58 0x0E0E      ORRS     LR,R8,LR
   \   0000014E   0xFA5F 0xFC8C      UXTB     R12,R12          ;; ZeroExt  R12,R12,#+24,#+24
   \   00000152   0xEA5E 0x3CCC      ORRS     R12,LR,R12, LSL #+15
   \   00000156   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000158   0xEA5C 0x4040      ORRS     R0,R12,R0, LSL #+17
   \   0000015C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000015E   0xEA5F 0x4C85      LSLS     R12,R5,#+18
   \   00000162   0xF41C 0x2C40      ANDS     R12,R12,#0xC0000
   \   00000166   0xEA5C 0x0000      ORRS     R0,R12,R0
   \   0000016A   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   0000016C   0xEA5F 0x5C46      LSLS     R12,R6,#+21      ;; ZeroExtS R12,R6,#+21,#+21
   \   00000170   0xEA5F 0x5C5C      LSRS     R12,R12,#+21
   \   00000174   0xEA5C 0x0000      ORRS     R0,R12,R0
   \   00000178   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000017A   0xEB17 0x1C41      ADDS     R12,R7,R1, LSL #+5
   \   0000017E   0xF51C 0x6CA0      ADDS     R12,R12,#+1280
   \   00000182   0xF8CC 0x0000      STR      R0,[R12, #+0]
   1403              
   1404            if (ep_type == EP_TYPE_INTR)
   \   00000186   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000188   0x2D03             CMP      R5,#+3
   \   0000018A   0xD10E             BNE.N    ??USB_HC_Init_10
   1405            {
   1406              USBx_HC(ch_num)->HCCHAR |= USB_OTG_HCCHAR_ODDFRM ;
   \   0000018C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000018E   0xEB17 0x1041      ADDS     R0,R7,R1, LSL #+5
   \   00000192   0xF510 0x60A0      ADDS     R0,R0,#+1280
   \   00000196   0x6800             LDR      R0,[R0, #+0]
   \   00000198   0xF050 0x5000      ORRS     R0,R0,#0x20000000
   \   0000019C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000019E   0xEB17 0x1C41      ADDS     R12,R7,R1, LSL #+5
   \   000001A2   0xF51C 0x6CA0      ADDS     R12,R12,#+1280
   \   000001A6   0xF8CC 0x0000      STR      R0,[R12, #+0]
   1407            }
   1408          
   1409            return HAL_OK; 
   \                     ??USB_HC_Init_10: (+1)
   \   000001AA   0x2000             MOVS     R0,#+0
   \   000001AC   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   1410          }
   1411          
   1412          /**
   1413            * @brief  Start a transfer over a host channel
   1414            * @param  USBx : Selected device
   1415            * @param  hc : pointer to host channel structure
   1416            * @param  dma: USB dma enabled or disabled 
   1417            *          This parameter can be one of the these values:
   1418            *           0 : DMA feature not used 
   1419            *           1 : DMA feature used  
   1420            * @retval HAL state
   1421            */
   1422          #if defined   (__CC_ARM) /*!< ARM Compiler */
   1423          #pragma O0
   1424          #elif defined (__GNUC__) /*!< GNU Compiler */
   1425          #pragma GCC optimize ("O0")
   1426          #endif /* __CC_ARM */

   \                                 In section .text, align 2, keep-with-next
   1427          HAL_StatusTypeDef USB_HC_StartXfer(USB_OTG_GlobalTypeDef *USBx, USB_OTG_HCTypeDef *hc, uint8_t dma)
   1428          {
   \                     USB_HC_StartXfer: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   1429            uint8_t  is_oddframe = 0; 
   \   0000000A   0x2700             MOVS     R7,#+0
   1430            uint16_t len_words = 0;   
   \   0000000C   0xF05F 0x0800      MOVS     R8,#+0
   1431            uint16_t num_packets = 0;
   \   00000010   0xF05F 0x0900      MOVS     R9,#+0
   1432            uint16_t max_hc_pkt_count = 256;
   \   00000014   0xF44F 0x7A80      MOV      R10,#+256
   1433            uint32_t tmpreg = 0;
   \   00000018   0xF05F 0x0B00      MOVS     R11,#+0
   1434              
   1435            if((USBx != USB_OTG_FS) && (hc->speed == USB_OTG_SPEED_HIGH))
   \   0000001C   0xF1B4 0x4FA0      CMP      R4,#+1342177280
   \   00000020   0xD021             BEQ.N    ??USB_HC_StartXfer_0
   \   00000022   0x7928             LDRB     R0,[R5, #+4]
   \   00000024   0x2800             CMP      R0,#+0
   \   00000026   0xD11E             BNE.N    ??USB_HC_StartXfer_0
   1436            {
   1437              if((dma == 0) && (hc->do_ping == 1))
   \   00000028   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000002A   0x2E00             CMP      R6,#+0
   \   0000002C   0xD108             BNE.N    ??USB_HC_StartXfer_1
   \   0000002E   0x7968             LDRB     R0,[R5, #+5]
   \   00000030   0x2801             CMP      R0,#+1
   \   00000032   0xD105             BNE.N    ??USB_HC_StartXfer_1
   1438              {
   1439                USB_DoPing(USBx, hc->ch_num);
   \   00000034   0x7869             LDRB     R1,[R5, #+1]
   \   00000036   0x0020             MOVS     R0,R4
   \   00000038   0x.... 0x....      BL       USB_DoPing
   1440                return HAL_OK;
   \   0000003C   0x2000             MOVS     R0,#+0
   \   0000003E   0xE0C8             B.N      ??USB_HC_StartXfer_2
   1441              }
   1442              else if(dma == 1)
   \                     ??USB_HC_StartXfer_1: (+1)
   \   00000040   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000042   0x2E01             CMP      R6,#+1
   \   00000044   0xD10F             BNE.N    ??USB_HC_StartXfer_0
   1443              {
   1444                USBx_HC(hc->ch_num)->HCINTMSK &= ~(USB_OTG_HCINTMSK_NYET | USB_OTG_HCINTMSK_ACKM);
   \   00000046   0x7868             LDRB     R0,[R5, #+1]
   \   00000048   0xEB14 0x1040      ADDS     R0,R4,R0, LSL #+5
   \   0000004C   0xF510 0x60A0      ADDS     R0,R0,#+1280
   \   00000050   0x7869             LDRB     R1,[R5, #+1]
   \   00000052   0xEB14 0x1141      ADDS     R1,R4,R1, LSL #+5
   \   00000056   0xF511 0x61A0      ADDS     R1,R1,#+1280
   \   0000005A   0x68C9             LDR      R1,[R1, #+12]
   \   0000005C   0xF031 0x0160      BICS     R1,R1,#0x60
   \   00000060   0x60C1             STR      R1,[R0, #+12]
   1445                hc->do_ping = 0;
   \   00000062   0x2000             MOVS     R0,#+0
   \   00000064   0x7168             STRB     R0,[R5, #+5]
   1446              }
   1447            }
   1448            
   1449            /* Compute the expected number of packets associated to the transfer */
   1450            if (hc->xfer_len > 0)
   \                     ??USB_HC_StartXfer_0: (+1)
   \   00000066   0x6928             LDR      R0,[R5, #+16]
   \   00000068   0x2800             CMP      R0,#+0
   \   0000006A   0xD016             BEQ.N    ??USB_HC_StartXfer_3
   1451            {
   1452              num_packets = (hc->xfer_len + hc->max_packet - 1) / hc->max_packet;
   \   0000006C   0x6928             LDR      R0,[R5, #+16]
   \   0000006E   0x8929             LDRH     R1,[R5, #+8]
   \   00000070   0xFA10 0xF081      UXTAH    R0,R0,R1
   \   00000074   0x1E40             SUBS     R0,R0,#+1
   \   00000076   0x8929             LDRH     R1,[R5, #+8]
   \   00000078   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   0000007C   0x4681             MOV      R9,R0
   1453              
   1454              if (num_packets > max_hc_pkt_count)
   \   0000007E   0xFA1F 0xFA8A      UXTH     R10,R10          ;; ZeroExt  R10,R10,#+16,#+16
   \   00000082   0xFA1F 0xF989      UXTH     R9,R9            ;; ZeroExt  R9,R9,#+16,#+16
   \   00000086   0x45CA             CMP      R10,R9
   \   00000088   0xD209             BCS.N    ??USB_HC_StartXfer_4
   1455              {
   1456                num_packets = max_hc_pkt_count;
   \   0000008A   0x46D1             MOV      R9,R10
   1457                hc->xfer_len = num_packets * hc->max_packet;
   \   0000008C   0xFA1F 0xF989      UXTH     R9,R9            ;; ZeroExt  R9,R9,#+16,#+16
   \   00000090   0x8928             LDRH     R0,[R5, #+8]
   \   00000092   0xFB00 0xF009      MUL      R0,R0,R9
   \   00000096   0x6128             STR      R0,[R5, #+16]
   \   00000098   0xE001             B.N      ??USB_HC_StartXfer_4
   1458              }
   1459            }
   1460            else
   1461            {
   1462              num_packets = 1;
   \                     ??USB_HC_StartXfer_3: (+1)
   \   0000009A   0x2001             MOVS     R0,#+1
   \   0000009C   0x4681             MOV      R9,R0
   1463            }
   1464            if (hc->ep_is_in)
   \                     ??USB_HC_StartXfer_4: (+1)
   \   0000009E   0x78E8             LDRB     R0,[R5, #+3]
   \   000000A0   0x2800             CMP      R0,#+0
   \   000000A2   0xD005             BEQ.N    ??USB_HC_StartXfer_5
   1465            {
   1466              hc->xfer_len = num_packets * hc->max_packet;
   \   000000A4   0xFA1F 0xF989      UXTH     R9,R9            ;; ZeroExt  R9,R9,#+16,#+16
   \   000000A8   0x8928             LDRH     R0,[R5, #+8]
   \   000000AA   0xFB00 0xF009      MUL      R0,R0,R9
   \   000000AE   0x6128             STR      R0,[R5, #+16]
   1467            }
   1468            
   1469            
   1470            
   1471            /* Initialize the HCTSIZn register */
   1472            USBx_HC(hc->ch_num)->HCTSIZ = (((hc->xfer_len) & USB_OTG_HCTSIZ_XFRSIZ)) |\
   1473              ((num_packets << 19) & USB_OTG_HCTSIZ_PKTCNT) |\
   1474                (((hc->data_pid) << 29) & USB_OTG_HCTSIZ_DPID);
   \                     ??USB_HC_StartXfer_5: (+1)
   \   000000B0   0x7868             LDRB     R0,[R5, #+1]
   \   000000B2   0xEB14 0x1040      ADDS     R0,R4,R0, LSL #+5
   \   000000B6   0xF510 0x60A0      ADDS     R0,R0,#+1280
   \   000000BA   0x6929             LDR      R1,[R5, #+16]
   \   000000BC   0x0349             LSLS     R1,R1,#+13       ;; ZeroExtS R1,R1,#+13,#+13
   \   000000BE   0x0B49             LSRS     R1,R1,#+13
   \   000000C0   0xFA1F 0xF989      UXTH     R9,R9            ;; ZeroExt  R9,R9,#+16,#+16
   \   000000C4   0x....             LDR.N    R2,??DataTable8  ;; 0x1ff80000
   \   000000C6   0xEA12 0x42C9      ANDS     R2,R2,R9, LSL #+19
   \   000000CA   0x4311             ORRS     R1,R2,R1
   \   000000CC   0x7AAA             LDRB     R2,[R5, #+10]
   \   000000CE   0x0752             LSLS     R2,R2,#+29
   \   000000D0   0xF012 0x42C0      ANDS     R2,R2,#0x60000000
   \   000000D4   0x4311             ORRS     R1,R2,R1
   \   000000D6   0x6101             STR      R1,[R0, #+16]
   1475            
   1476            if (dma)
   \   000000D8   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000DA   0x2E00             CMP      R6,#+0
   \   000000DC   0xD006             BEQ.N    ??USB_HC_StartXfer_6
   1477            {
   1478              /* xfer_buff MUST be 32-bits aligned */
   1479              USBx_HC(hc->ch_num)->HCDMA = (uint32_t)hc->xfer_buff;
   \   000000DE   0x7868             LDRB     R0,[R5, #+1]
   \   000000E0   0xEB14 0x1040      ADDS     R0,R4,R0, LSL #+5
   \   000000E4   0xF510 0x60A0      ADDS     R0,R0,#+1280
   \   000000E8   0x68E9             LDR      R1,[R5, #+12]
   \   000000EA   0x6141             STR      R1,[R0, #+20]
   1480            }
   1481            
   1482            is_oddframe = (USBx_HOST->HFNUM & 0x01) ? 0 : 1;
   \                     ??USB_HC_StartXfer_6: (+1)
   \   000000EC   0xF514 0x6080      ADDS     R0,R4,#+1024
   \   000000F0   0x6880             LDR      R0,[R0, #+8]
   \   000000F2   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   000000F6   0xF090 0x0001      EORS     R0,R0,#0x1
   \   000000FA   0x0007             MOVS     R7,R0
   1483            USBx_HC(hc->ch_num)->HCCHAR &= ~USB_OTG_HCCHAR_ODDFRM;
   \   000000FC   0x7868             LDRB     R0,[R5, #+1]
   \   000000FE   0xEB14 0x1040      ADDS     R0,R4,R0, LSL #+5
   \   00000102   0xF510 0x60A0      ADDS     R0,R0,#+1280
   \   00000106   0x7869             LDRB     R1,[R5, #+1]
   \   00000108   0xEB14 0x1141      ADDS     R1,R4,R1, LSL #+5
   \   0000010C   0xF511 0x61A0      ADDS     R1,R1,#+1280
   \   00000110   0x6809             LDR      R1,[R1, #+0]
   \   00000112   0xF031 0x5100      BICS     R1,R1,#0x20000000
   \   00000116   0x6001             STR      R1,[R0, #+0]
   1484            USBx_HC(hc->ch_num)->HCCHAR |= (is_oddframe << 29);
   \   00000118   0x7868             LDRB     R0,[R5, #+1]
   \   0000011A   0xEB14 0x1040      ADDS     R0,R4,R0, LSL #+5
   \   0000011E   0xF510 0x60A0      ADDS     R0,R0,#+1280
   \   00000122   0x7869             LDRB     R1,[R5, #+1]
   \   00000124   0xEB14 0x1141      ADDS     R1,R4,R1, LSL #+5
   \   00000128   0xF511 0x61A0      ADDS     R1,R1,#+1280
   \   0000012C   0x6809             LDR      R1,[R1, #+0]
   \   0000012E   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000130   0xEA51 0x7147      ORRS     R1,R1,R7, LSL #+29
   \   00000134   0x6001             STR      R1,[R0, #+0]
   1485            
   1486            /* Set host channel enable */
   1487            tmpreg = USBx_HC(hc->ch_num)->HCCHAR;
   \   00000136   0x7868             LDRB     R0,[R5, #+1]
   \   00000138   0xEB14 0x1040      ADDS     R0,R4,R0, LSL #+5
   \   0000013C   0xF510 0x60A0      ADDS     R0,R0,#+1280
   \   00000140   0x6800             LDR      R0,[R0, #+0]
   \   00000142   0x4683             MOV      R11,R0
   1488            tmpreg &= ~USB_OTG_HCCHAR_CHDIS;
   \   00000144   0xF03B 0x4B80      BICS     R11,R11,#0x40000000
   1489            tmpreg |= USB_OTG_HCCHAR_CHENA;
   \   00000148   0xF05B 0x4B00      ORRS     R11,R11,#0x80000000
   1490            USBx_HC(hc->ch_num)->HCCHAR = tmpreg;
   \   0000014C   0x7868             LDRB     R0,[R5, #+1]
   \   0000014E   0xEB14 0x1040      ADDS     R0,R4,R0, LSL #+5
   \   00000152   0xF510 0x60A0      ADDS     R0,R0,#+1280
   \   00000156   0xF8C0 0xB000      STR      R11,[R0, #+0]
   1491            
   1492            if (dma == 0) /* Slave mode */
   \   0000015A   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000015C   0x2E00             CMP      R6,#+0
   \   0000015E   0xD137             BNE.N    ??USB_HC_StartXfer_7
   1493            {  
   1494              if((hc->ep_is_in == 0) && (hc->xfer_len > 0))
   \   00000160   0x78E8             LDRB     R0,[R5, #+3]
   \   00000162   0x2800             CMP      R0,#+0
   \   00000164   0xD134             BNE.N    ??USB_HC_StartXfer_7
   \   00000166   0x6928             LDR      R0,[R5, #+16]
   \   00000168   0x2800             CMP      R0,#+0
   \   0000016A   0xD031             BEQ.N    ??USB_HC_StartXfer_7
   1495              {
   1496                switch(hc->ep_type) 
   \   0000016C   0x79E8             LDRB     R0,[R5, #+7]
   \   0000016E   0x2800             CMP      R0,#+0
   \   00000170   0xD005             BEQ.N    ??USB_HC_StartXfer_8
   \   00000172   0x2802             CMP      R0,#+2
   \   00000174   0xD003             BEQ.N    ??USB_HC_StartXfer_8
   \   00000176   0xD311             BCC.N    ??USB_HC_StartXfer_9
   \   00000178   0x2803             CMP      R0,#+3
   \   0000017A   0xD00F             BEQ.N    ??USB_HC_StartXfer_9
   \   0000017C   0xE01F             B.N      ??USB_HC_StartXfer_10
   1497                {
   1498                  /* Non periodic transfer */
   1499                case EP_TYPE_CTRL:
   1500                case EP_TYPE_BULK:
   1501                  
   1502                  len_words = (hc->xfer_len + 3) / 4;
   \                     ??USB_HC_StartXfer_8: (+1)
   \   0000017E   0x6928             LDR      R0,[R5, #+16]
   \   00000180   0x1CC0             ADDS     R0,R0,#+3
   \   00000182   0x0880             LSRS     R0,R0,#+2
   \   00000184   0x4680             MOV      R8,R0
   1503                  
   1504                  /* check if there is enough space in FIFO space */
   1505                  if(len_words > (USBx->HNPTXSTS & 0xFFFF))
   \   00000186   0x6AE0             LDR      R0,[R4, #+44]
   \   00000188   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000018A   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   0000018E   0x4540             CMP      R0,R8
   \   00000190   0xD203             BCS.N    ??USB_HC_StartXfer_11
   1506                  {
   1507                    /* need to process data in nptxfempty interrupt */
   1508                    USBx->GINTMSK |= USB_OTG_GINTMSK_NPTXFEM;
   \   00000192   0x69A0             LDR      R0,[R4, #+24]
   \   00000194   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   00000198   0x61A0             STR      R0,[R4, #+24]
   1509                  }
   1510                  break;
   \                     ??USB_HC_StartXfer_11: (+1)
   \   0000019A   0xE010             B.N      ??USB_HC_StartXfer_12
   1511                  /* Periodic transfer */
   1512                case EP_TYPE_INTR:
   1513                case EP_TYPE_ISOC:
   1514                  len_words = (hc->xfer_len + 3) / 4;
   \                     ??USB_HC_StartXfer_9: (+1)
   \   0000019C   0x6928             LDR      R0,[R5, #+16]
   \   0000019E   0x1CC0             ADDS     R0,R0,#+3
   \   000001A0   0x0880             LSRS     R0,R0,#+2
   \   000001A2   0x4680             MOV      R8,R0
   1515                  /* check if there is enough space in FIFO space */
   1516                  if(len_words > (USBx_HOST->HPTXSTS & 0xFFFF)) /* split the transfer */
   \   000001A4   0xF514 0x6080      ADDS     R0,R4,#+1024
   \   000001A8   0x6900             LDR      R0,[R0, #+16]
   \   000001AA   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000001AC   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   000001B0   0x4540             CMP      R0,R8
   \   000001B2   0xD203             BCS.N    ??USB_HC_StartXfer_13
   1517                  {
   1518                    /* need to process data in ptxfempty interrupt */
   1519                    USBx->GINTMSK |= USB_OTG_GINTMSK_PTXFEM;          
   \   000001B4   0x69A0             LDR      R0,[R4, #+24]
   \   000001B6   0xF050 0x6080      ORRS     R0,R0,#0x4000000
   \   000001BA   0x61A0             STR      R0,[R4, #+24]
   1520                  }
   1521                  break;
   \                     ??USB_HC_StartXfer_13: (+1)
   \   000001BC   0xE7FF             B.N      ??USB_HC_StartXfer_12
   1522                  
   1523                default:
   1524                  break;
   1525                }
   1526                
   1527                /* Write packet into the Tx FIFO. */
   1528                USB_WritePacket(USBx, hc->xfer_buff, hc->ch_num, hc->xfer_len, 0);
   \                     ??USB_HC_StartXfer_10: (+1)
   \                     ??USB_HC_StartXfer_12: (+1)
   \   000001BE   0x2000             MOVS     R0,#+0
   \   000001C0   0x9000             STR      R0,[SP, #+0]
   \   000001C2   0x692B             LDR      R3,[R5, #+16]
   \   000001C4   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   000001C6   0x786A             LDRB     R2,[R5, #+1]
   \   000001C8   0x68E9             LDR      R1,[R5, #+12]
   \   000001CA   0x0020             MOVS     R0,R4
   \   000001CC   0x.... 0x....      BL       USB_WritePacket
   1529              }
   1530            }
   1531            
   1532            return HAL_OK;
   \                     ??USB_HC_StartXfer_7: (+1)
   \   000001D0   0x2000             MOVS     R0,#+0
   \                     ??USB_HC_StartXfer_2: (+1)
   \   000001D2   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
   1533          }
   1534          
   1535          /**
   1536            * @brief Read all host channel interrupts status
   1537            * @param  USBx : Selected device
   1538            * @retval HAL state
   1539            */

   \                                 In section .text, align 2, keep-with-next
   1540          uint32_t USB_HC_ReadInterrupt (USB_OTG_GlobalTypeDef *USBx)
   1541          {
   1542            return ((USBx_HOST->HAINT) & 0xFFFF);
   \                     USB_HC_ReadInterrupt: (+1)
   \   00000000   0xF510 0x6080      ADDS     R0,R0,#+1024
   \   00000004   0x6940             LDR      R0,[R0, #+20]
   \   00000006   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000008   0x4770             BX       LR               ;; return
   1543          }
   1544          
   1545          /**
   1546            * @brief  Halt a host channel
   1547            * @param  USBx : Selected device
   1548            * @param  hc_num : Host Channel number
   1549            *         This parameter can be a value from 1 to 15
   1550            * @retval HAL state
   1551            */

   \                                 In section .text, align 2, keep-with-next
   1552          HAL_StatusTypeDef USB_HC_Halt(USB_OTG_GlobalTypeDef *USBx , uint8_t hc_num)
   1553          {
   \                     USB_HC_Halt: (+1)
   \   00000000   0xB410             PUSH     {R4}
   \   00000002   0x0002             MOVS     R2,R0
   1554            uint32_t count = 0;
   \   00000004   0x2300             MOVS     R3,#+0
   1555            
   1556            /* Check for space in the request queue to issue the halt. */
   1557            if (((USBx_HC(hc_num)->HCCHAR) & (HCCHAR_CTRL << 18)) || ((USBx_HC(hc_num)->HCCHAR) & (HCCHAR_BULK << 18)))
   \   00000006   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000008   0xEB12 0x1041      ADDS     R0,R2,R1, LSL #+5
   \   0000000C   0xF510 0x60A0      ADDS     R0,R0,#+1280
   \   00000010   0x6800             LDR      R0,[R0, #+0]
   \   00000012   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000014   0xEB12 0x1041      ADDS     R0,R2,R1, LSL #+5
   \   00000018   0xF510 0x60A0      ADDS     R0,R0,#+1280
   \   0000001C   0x6800             LDR      R0,[R0, #+0]
   \   0000001E   0x0300             LSLS     R0,R0,#+12
   \   00000020   0xD556             BPL.N    ??USB_HC_Halt_0
   1558            {
   1559              USBx_HC(hc_num)->HCCHAR |= USB_OTG_HCCHAR_CHDIS;
   \   00000022   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000024   0xEB12 0x1041      ADDS     R0,R2,R1, LSL #+5
   \   00000028   0xF510 0x60A0      ADDS     R0,R0,#+1280
   \   0000002C   0x6800             LDR      R0,[R0, #+0]
   \   0000002E   0xF050 0x4080      ORRS     R0,R0,#0x40000000
   \   00000032   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000034   0xEB12 0x1441      ADDS     R4,R2,R1, LSL #+5
   \   00000038   0xF514 0x64A0      ADDS     R4,R4,#+1280
   \   0000003C   0x6020             STR      R0,[R4, #+0]
   1560              
   1561              if ((USBx->HNPTXSTS & 0xFFFF) == 0)
   \   0000003E   0x6AD0             LDR      R0,[R2, #+44]
   \   00000040   0x0400             LSLS     R0,R0,#+16
   \   00000042   0xD136             BNE.N    ??USB_HC_Halt_1
   1562              {
   1563                USBx_HC(hc_num)->HCCHAR &= ~USB_OTG_HCCHAR_CHENA;
   \   00000044   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000046   0xEB12 0x1041      ADDS     R0,R2,R1, LSL #+5
   \   0000004A   0xF510 0x60A0      ADDS     R0,R0,#+1280
   \   0000004E   0x6800             LDR      R0,[R0, #+0]
   \   00000050   0x0040             LSLS     R0,R0,#+1        ;; ZeroExtS R0,R0,#+1,#+1
   \   00000052   0x0840             LSRS     R0,R0,#+1
   \   00000054   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000056   0xEB12 0x1441      ADDS     R4,R2,R1, LSL #+5
   \   0000005A   0xF514 0x64A0      ADDS     R4,R4,#+1280
   \   0000005E   0x6020             STR      R0,[R4, #+0]
   1564                USBx_HC(hc_num)->HCCHAR |= USB_OTG_HCCHAR_CHENA;  
   \   00000060   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000062   0xEB12 0x1041      ADDS     R0,R2,R1, LSL #+5
   \   00000066   0xF510 0x60A0      ADDS     R0,R0,#+1280
   \   0000006A   0x6800             LDR      R0,[R0, #+0]
   \   0000006C   0xF050 0x4000      ORRS     R0,R0,#0x80000000
   \   00000070   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000072   0xEB12 0x1441      ADDS     R4,R2,R1, LSL #+5
   \   00000076   0xF514 0x64A0      ADDS     R4,R4,#+1280
   \   0000007A   0x6020             STR      R0,[R4, #+0]
   1565                USBx_HC(hc_num)->HCCHAR &= ~USB_OTG_HCCHAR_EPDIR;
   \   0000007C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000007E   0xEB12 0x1041      ADDS     R0,R2,R1, LSL #+5
   \   00000082   0xF510 0x60A0      ADDS     R0,R0,#+1280
   \   00000086   0x6800             LDR      R0,[R0, #+0]
   \   00000088   0xF430 0x4000      BICS     R0,R0,#0x8000
   \   0000008C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000008E   0xEB12 0x1441      ADDS     R4,R2,R1, LSL #+5
   \   00000092   0xF514 0x64A0      ADDS     R4,R4,#+1280
   \   00000096   0x6020             STR      R0,[R4, #+0]
   1566                do 
   1567                {
   1568                  if (++count > 1000) 
   \                     ??USB_HC_Halt_2: (+1)
   \   00000098   0x1C5B             ADDS     R3,R3,#+1
   \   0000009A   0xF5B3 0x7F7A      CMP      R3,#+1000
   \   0000009E   0xD86F             BHI.N    ??USB_HC_Halt_3
   1569                  {
   1570                    break;
   1571                  }
   1572                } 
   1573                while ((USBx_HC(hc_num)->HCCHAR & USB_OTG_HCCHAR_CHENA) == USB_OTG_HCCHAR_CHENA);     
   \                     ??USB_HC_Halt_4: (+1)
   \   000000A0   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000A2   0xEB12 0x1041      ADDS     R0,R2,R1, LSL #+5
   \   000000A6   0xF510 0x60A0      ADDS     R0,R0,#+1280
   \   000000AA   0x6800             LDR      R0,[R0, #+0]
   \   000000AC   0x2800             CMP      R0,#+0
   \   000000AE   0xD4F3             BMI.N    ??USB_HC_Halt_2
   \   000000B0   0xE066             B.N      ??USB_HC_Halt_3
   1574              }
   1575              else
   1576              {
   1577                USBx_HC(hc_num)->HCCHAR |= USB_OTG_HCCHAR_CHENA; 
   \                     ??USB_HC_Halt_1: (+1)
   \   000000B2   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000B4   0xEB12 0x1041      ADDS     R0,R2,R1, LSL #+5
   \   000000B8   0xF510 0x60A0      ADDS     R0,R0,#+1280
   \   000000BC   0x6800             LDR      R0,[R0, #+0]
   \   000000BE   0xF050 0x4000      ORRS     R0,R0,#0x80000000
   \   000000C2   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000C4   0xEB12 0x1441      ADDS     R4,R2,R1, LSL #+5
   \   000000C8   0xF514 0x64A0      ADDS     R4,R4,#+1280
   \   000000CC   0x6020             STR      R0,[R4, #+0]
   \   000000CE   0xE057             B.N      ??USB_HC_Halt_3
   1578              }
   1579            }
   1580            else
   1581            {
   1582              USBx_HC(hc_num)->HCCHAR |= USB_OTG_HCCHAR_CHDIS;
   \                     ??USB_HC_Halt_0: (+1)
   \   000000D0   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000D2   0xEB12 0x1041      ADDS     R0,R2,R1, LSL #+5
   \   000000D6   0xF510 0x60A0      ADDS     R0,R0,#+1280
   \   000000DA   0x6800             LDR      R0,[R0, #+0]
   \   000000DC   0xF050 0x4080      ORRS     R0,R0,#0x40000000
   \   000000E0   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000E2   0xEB12 0x1441      ADDS     R4,R2,R1, LSL #+5
   \   000000E6   0xF514 0x64A0      ADDS     R4,R4,#+1280
   \   000000EA   0x6020             STR      R0,[R4, #+0]
   1583              
   1584              if ((USBx_HOST->HPTXSTS & 0xFFFF) == 0)
   \   000000EC   0xF512 0x6080      ADDS     R0,R2,#+1024
   \   000000F0   0x6900             LDR      R0,[R0, #+16]
   \   000000F2   0x0400             LSLS     R0,R0,#+16
   \   000000F4   0xD136             BNE.N    ??USB_HC_Halt_5
   1585              {
   1586                USBx_HC(hc_num)->HCCHAR &= ~USB_OTG_HCCHAR_CHENA;
   \   000000F6   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000F8   0xEB12 0x1041      ADDS     R0,R2,R1, LSL #+5
   \   000000FC   0xF510 0x60A0      ADDS     R0,R0,#+1280
   \   00000100   0x6800             LDR      R0,[R0, #+0]
   \   00000102   0x0040             LSLS     R0,R0,#+1        ;; ZeroExtS R0,R0,#+1,#+1
   \   00000104   0x0840             LSRS     R0,R0,#+1
   \   00000106   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000108   0xEB12 0x1441      ADDS     R4,R2,R1, LSL #+5
   \   0000010C   0xF514 0x64A0      ADDS     R4,R4,#+1280
   \   00000110   0x6020             STR      R0,[R4, #+0]
   1587                USBx_HC(hc_num)->HCCHAR |= USB_OTG_HCCHAR_CHENA;  
   \   00000112   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000114   0xEB12 0x1041      ADDS     R0,R2,R1, LSL #+5
   \   00000118   0xF510 0x60A0      ADDS     R0,R0,#+1280
   \   0000011C   0x6800             LDR      R0,[R0, #+0]
   \   0000011E   0xF050 0x4000      ORRS     R0,R0,#0x80000000
   \   00000122   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000124   0xEB12 0x1441      ADDS     R4,R2,R1, LSL #+5
   \   00000128   0xF514 0x64A0      ADDS     R4,R4,#+1280
   \   0000012C   0x6020             STR      R0,[R4, #+0]
   1588                USBx_HC(hc_num)->HCCHAR &= ~USB_OTG_HCCHAR_EPDIR;
   \   0000012E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000130   0xEB12 0x1041      ADDS     R0,R2,R1, LSL #+5
   \   00000134   0xF510 0x60A0      ADDS     R0,R0,#+1280
   \   00000138   0x6800             LDR      R0,[R0, #+0]
   \   0000013A   0xF430 0x4000      BICS     R0,R0,#0x8000
   \   0000013E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000140   0xEB12 0x1441      ADDS     R4,R2,R1, LSL #+5
   \   00000144   0xF514 0x64A0      ADDS     R4,R4,#+1280
   \   00000148   0x6020             STR      R0,[R4, #+0]
   1589                do 
   1590                {
   1591                  if (++count > 1000) 
   \                     ??USB_HC_Halt_6: (+1)
   \   0000014A   0x1C5B             ADDS     R3,R3,#+1
   \   0000014C   0xF5B3 0x7F7A      CMP      R3,#+1000
   \   00000150   0xD816             BHI.N    ??USB_HC_Halt_3
   1592                  {
   1593                    break;
   1594                  }
   1595                } 
   1596                while ((USBx_HC(hc_num)->HCCHAR & USB_OTG_HCCHAR_CHENA) == USB_OTG_HCCHAR_CHENA);     
   \                     ??USB_HC_Halt_7: (+1)
   \   00000152   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000154   0xEB12 0x1041      ADDS     R0,R2,R1, LSL #+5
   \   00000158   0xF510 0x60A0      ADDS     R0,R0,#+1280
   \   0000015C   0x6800             LDR      R0,[R0, #+0]
   \   0000015E   0x2800             CMP      R0,#+0
   \   00000160   0xD4F3             BMI.N    ??USB_HC_Halt_6
   \   00000162   0xE00D             B.N      ??USB_HC_Halt_3
   1597              }
   1598              else
   1599              {
   1600                 USBx_HC(hc_num)->HCCHAR |= USB_OTG_HCCHAR_CHENA; 
   \                     ??USB_HC_Halt_5: (+1)
   \   00000164   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000166   0xEB12 0x1041      ADDS     R0,R2,R1, LSL #+5
   \   0000016A   0xF510 0x60A0      ADDS     R0,R0,#+1280
   \   0000016E   0x6800             LDR      R0,[R0, #+0]
   \   00000170   0xF050 0x4000      ORRS     R0,R0,#0x80000000
   \   00000174   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000176   0xEB12 0x1441      ADDS     R4,R2,R1, LSL #+5
   \   0000017A   0xF514 0x64A0      ADDS     R4,R4,#+1280
   \   0000017E   0x6020             STR      R0,[R4, #+0]
   1601              }
   1602            }
   1603            
   1604            return HAL_OK;
   \                     ??USB_HC_Halt_3: (+1)
   \   00000180   0x2000             MOVS     R0,#+0
   \   00000182   0xBC10             POP      {R4}
   \   00000184   0x4770             BX       LR               ;; return
   1605          }
   1606          
   1607          /**
   1608            * @brief  Initiate Do Ping protocol
   1609            * @param  USBx : Selected device
   1610            * @param  hc_num : Host Channel number
   1611            *         This parameter can be a value from 1 to 15
   1612            * @retval HAL state
   1613            */

   \                                 In section .text, align 2, keep-with-next
   1614          HAL_StatusTypeDef USB_DoPing(USB_OTG_GlobalTypeDef *USBx , uint8_t ch_num)
   1615          {
   \                     USB_DoPing: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
   \   00000002   0x0002             MOVS     R2,R0
   1616            uint8_t  num_packets = 1;
   \   00000004   0x2301             MOVS     R3,#+1
   1617            uint32_t tmpreg = 0;
   \   00000006   0x2400             MOVS     R4,#+0
   1618          
   1619            USBx_HC(ch_num)->HCTSIZ = ((num_packets << 19) & USB_OTG_HCTSIZ_PKTCNT) |\
   1620                                          USB_OTG_HCTSIZ_DOPING;
   \   00000008   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000A   0xEB12 0x1041      ADDS     R0,R2,R1, LSL #+5
   \   0000000E   0xF510 0x60A0      ADDS     R0,R0,#+1280
   \   00000012   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000014   0x04DD             LSLS     R5,R3,#+19
   \   00000016   0xF055 0x4500      ORRS     R5,R5,#0x80000000
   \   0000001A   0x6105             STR      R5,[R0, #+16]
   1621            
   1622            /* Set host channel enable */
   1623            tmpreg = USBx_HC(ch_num)->HCCHAR;
   \   0000001C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000001E   0xEB12 0x1041      ADDS     R0,R2,R1, LSL #+5
   \   00000022   0xF510 0x60A0      ADDS     R0,R0,#+1280
   \   00000026   0x6800             LDR      R0,[R0, #+0]
   \   00000028   0x0004             MOVS     R4,R0
   1624            tmpreg &= ~USB_OTG_HCCHAR_CHDIS;
   \   0000002A   0xF034 0x4480      BICS     R4,R4,#0x40000000
   1625            tmpreg |= USB_OTG_HCCHAR_CHENA;
   \   0000002E   0xF054 0x4400      ORRS     R4,R4,#0x80000000
   1626            USBx_HC(ch_num)->HCCHAR = tmpreg;
   \   00000032   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000034   0xEB12 0x1041      ADDS     R0,R2,R1, LSL #+5
   \   00000038   0xF510 0x60A0      ADDS     R0,R0,#+1280
   \   0000003C   0x6004             STR      R4,[R0, #+0]
   1627            
   1628            return HAL_OK;  
   \   0000003E   0x2000             MOVS     R0,#+0
   \   00000040   0xBC30             POP      {R4,R5}
   \   00000042   0x4770             BX       LR               ;; return
   1629          }
   1630          
   1631          /**
   1632            * @brief  Stop Host Core
   1633            * @param  USBx : Selected device
   1634            * @retval HAL state
   1635            */

   \                                 In section .text, align 2, keep-with-next
   1636          HAL_StatusTypeDef USB_StopHost(USB_OTG_GlobalTypeDef *USBx)
   1637          {
   \                     USB_StopHost: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1638            uint8_t i;
   1639            uint32_t count = 0;
   \   00000004   0x2600             MOVS     R6,#+0
   1640            uint32_t value;
   1641            
   1642            USB_DisableGlobalInt(USBx);
   \   00000006   0x0020             MOVS     R0,R4
   \   00000008   0x.... 0x....      BL       USB_DisableGlobalInt
   1643            
   1644              /* Flush FIFO */
   1645            USB_FlushTxFifo(USBx, 0x10);
   \   0000000C   0x2110             MOVS     R1,#+16
   \   0000000E   0x0020             MOVS     R0,R4
   \   00000010   0x.... 0x....      BL       USB_FlushTxFifo
   1646            USB_FlushRxFifo(USBx);
   \   00000014   0x0020             MOVS     R0,R4
   \   00000016   0x.... 0x....      BL       USB_FlushRxFifo
   1647            
   1648            /* Flush out any leftover queued requests. */
   1649            for (i = 0; i <= 15; i++)
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0x0005             MOVS     R5,R0
   \                     ??USB_StopHost_0: (+1)
   \   0000001E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000020   0x2D10             CMP      R5,#+16
   \   00000022   0xDA14             BGE.N    ??USB_StopHost_1
   1650            {   
   1651          
   1652              value = USBx_HC(i)->HCCHAR ;
   \   00000024   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000026   0xEB14 0x1045      ADDS     R0,R4,R5, LSL #+5
   \   0000002A   0xF510 0x60A0      ADDS     R0,R0,#+1280
   \   0000002E   0x6800             LDR      R0,[R0, #+0]
   \   00000030   0x0007             MOVS     R7,R0
   1653              value |=  USB_OTG_HCCHAR_CHDIS;
   \   00000032   0xF057 0x4780      ORRS     R7,R7,#0x40000000
   1654              value &= ~USB_OTG_HCCHAR_CHENA;  
   \   00000036   0x007F             LSLS     R7,R7,#+1        ;; ZeroExtS R7,R7,#+1,#+1
   \   00000038   0x087F             LSRS     R7,R7,#+1
   1655              value &= ~USB_OTG_HCCHAR_EPDIR;
   \   0000003A   0xF437 0x4700      BICS     R7,R7,#0x8000
   1656              USBx_HC(i)->HCCHAR = value;
   \   0000003E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000040   0xEB14 0x1045      ADDS     R0,R4,R5, LSL #+5
   \   00000044   0xF510 0x60A0      ADDS     R0,R0,#+1280
   \   00000048   0x6007             STR      R7,[R0, #+0]
   1657            }
   \   0000004A   0x1C6D             ADDS     R5,R5,#+1
   \   0000004C   0xE7E7             B.N      ??USB_StopHost_0
   1658            
   1659            /* Halt all channels to put them into a known state. */  
   1660            for (i = 0; i <= 15; i++)
   \                     ??USB_StopHost_1: (+1)
   \   0000004E   0x2000             MOVS     R0,#+0
   \   00000050   0x0005             MOVS     R5,R0
   \                     ??USB_StopHost_2: (+1)
   \   00000052   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000054   0x2D10             CMP      R5,#+16
   \   00000056   0xDA20             BGE.N    ??USB_StopHost_3
   1661            {   
   1662          
   1663              value = USBx_HC(i)->HCCHAR ;
   \   00000058   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000005A   0xEB14 0x1045      ADDS     R0,R4,R5, LSL #+5
   \   0000005E   0xF510 0x60A0      ADDS     R0,R0,#+1280
   \   00000062   0x6800             LDR      R0,[R0, #+0]
   \   00000064   0x0007             MOVS     R7,R0
   1664              
   1665              value |= USB_OTG_HCCHAR_CHDIS;
   \   00000066   0xF057 0x4780      ORRS     R7,R7,#0x40000000
   1666              value |= USB_OTG_HCCHAR_CHENA;  
   \   0000006A   0xF057 0x4700      ORRS     R7,R7,#0x80000000
   1667              value &= ~USB_OTG_HCCHAR_EPDIR;
   \   0000006E   0xF437 0x4700      BICS     R7,R7,#0x8000
   1668              
   1669              USBx_HC(i)->HCCHAR = value;
   \   00000072   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000074   0xEB14 0x1045      ADDS     R0,R4,R5, LSL #+5
   \   00000078   0xF510 0x60A0      ADDS     R0,R0,#+1280
   \   0000007C   0x6007             STR      R7,[R0, #+0]
   1670              do 
   1671              {
   1672                if (++count > 1000) 
   \                     ??USB_StopHost_4: (+1)
   \   0000007E   0x1C76             ADDS     R6,R6,#+1
   \   00000080   0xF5B6 0x7F7A      CMP      R6,#+1000
   \   00000084   0xD807             BHI.N    ??USB_StopHost_5
   1673                {
   1674                  break;
   1675                }
   1676              } 
   1677              while ((USBx_HC(i)->HCCHAR & USB_OTG_HCCHAR_CHENA) == USB_OTG_HCCHAR_CHENA);
   \                     ??USB_StopHost_6: (+1)
   \   00000086   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000088   0xEB14 0x1045      ADDS     R0,R4,R5, LSL #+5
   \   0000008C   0xF510 0x60A0      ADDS     R0,R0,#+1280
   \   00000090   0x6800             LDR      R0,[R0, #+0]
   \   00000092   0x2800             CMP      R0,#+0
   \   00000094   0xD4F3             BMI.N    ??USB_StopHost_4
   1678            }
   \                     ??USB_StopHost_5: (+1)
   \   00000096   0x1C6D             ADDS     R5,R5,#+1
   \   00000098   0xE7DB             B.N      ??USB_StopHost_2
   1679          
   1680            /* Clear any pending Host interrupts */
   1681            USBx_HOST->HAINT = 0xFFFFFFFF;
   \                     ??USB_StopHost_3: (+1)
   \   0000009A   0xF05F 0x30FF      MOVS     R0,#-1
   \   0000009E   0xF514 0x6180      ADDS     R1,R4,#+1024
   \   000000A2   0x6148             STR      R0,[R1, #+20]
   1682            USBx->GINTSTS = 0xFFFFFFFF;
   \   000000A4   0xF05F 0x30FF      MOVS     R0,#-1
   \   000000A8   0x6160             STR      R0,[R4, #+20]
   1683            USB_EnableGlobalInt(USBx);
   \   000000AA   0x0020             MOVS     R0,R4
   \   000000AC   0x.... 0x....      BL       USB_EnableGlobalInt
   1684            return HAL_OK;  
   \   000000B0   0x2000             MOVS     R0,#+0
   \   000000B2   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1685          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5:
   \   00000000   0xFFBDFFBF         DC32     0xffbdffbf

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7:
   \   00000000   0x00800100         DC32     0x800100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_1:
   \   00000000   0x803C3800         DC32     0x803c3800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_2:
   \   00000000   0x00030D41         DC32     0x30d41

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_3:
   \   00000000   0x........         DC32     ??debug

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8:
   \   00000000   0x1FF80000         DC32     0x1ff80000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_1:
   \   00000000   0x00600080         DC32     0x600080

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_2:
   \   00000000   0x004000E0         DC32     0x4000e0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_3:
   \   00000000   0x01000200         DC32     0x1000200

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_4:
   \   00000000   0x00E00300         DC32     0xe00300

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_5:
   \   00000000   0xA3200008         DC32     0xa3200008
   1686          /**
   1687            * @}
   1688            */
   1689          
   1690          #endif /* defined (HAL_PCD_MODULE_ENABLED) || defined (HAL_HCD_MODULE_ENABLED) */
   1691          
   1692          /**
   1693            * @}
   1694            */
   1695          
   1696          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   USB_ActivateDedicatedEndpoint
       8   USB_ActivateEndpoint
       0   USB_ActivateSetup
       0   USB_ClearInterrupts
      24   USB_CoreInit
        24   -> USB_CoreReset
       0   USB_CoreReset
       4   USB_DeactivateDedicatedEndpoint
       4   USB_DeactivateEndpoint
       8   USB_DevConnect
         8   -> HAL_Delay
       8   USB_DevDisconnect
         8   -> HAL_Delay
      24   USB_DevInit
        24   -> USB_FlushRxFifo
        24   -> USB_FlushTxFifo
        24   -> USB_SetDevSpeed
       0   USB_DisableGlobalInt
       8   USB_DoPing
       4   USB_DriveVbus
       8   USB_EP0StartXfer
       4   USB_EP0_OutStart
       0   USB_EPClearStall
       0   USB_EPSetStall
      24   USB_EPStartXfer
        24   -> USB_WritePacket
       0   USB_EnableGlobalInt
       0   USB_FlushRxFifo
       0   USB_FlushTxFifo
       0   USB_GetCurrentFrame
       0   USB_GetDevSpeed
       4   USB_GetHostSpeed
       0   USB_GetMode
       4   USB_HC_Halt
      24   USB_HC_Init
       0   USB_HC_ReadInterrupt
      40   USB_HC_StartXfer
        40   -> USB_DoPing
        40   -> USB_WritePacket
      24   USB_HostInit
        24   -> HAL_Delay
        24   -> USB_DriveVbus
        24   -> USB_FlushRxFifo
        24   -> USB_FlushTxFifo
       0   USB_InitFSLSPClkSel
       0   USB_ReadDevAllInEpInterrupt
       0   USB_ReadDevAllOutEpInterrupt
       8   USB_ReadDevInEPInterrupt
       0   USB_ReadDevOutEPInterrupt
       0   USB_ReadInterrupts
       8   USB_ReadPacket
      16   USB_ResetPort
        16   -> HAL_Delay
      16   USB_SetCurrentMode
        16   -> HAL_Delay
       0   USB_SetDevAddress
       0   USB_SetDevSpeed
      16   USB_StopDevice
        16   -> USB_FlushRxFifo
        16   -> USB_FlushTxFifo
      24   USB_StopHost
        24   -> USB_DisableGlobalInt
        24   -> USB_EnableGlobalInt
        24   -> USB_FlushRxFifo
        24   -> USB_FlushTxFifo
      16   USB_WritePacket


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable5
       4  ??DataTable7
       4  ??DataTable7_1
       4  ??DataTable7_2
       4  ??DataTable7_3
       4  ??DataTable8
       4  ??DataTable8_1
       4  ??DataTable8_2
       4  ??DataTable8_3
       4  ??DataTable8_4
       4  ??DataTable8_5
     300  USB_ActivateDedicatedEndpoint
     196  USB_ActivateEndpoint
      68  USB_ActivateSetup
       8  USB_ClearInterrupts
     110  USB_CoreInit
      56  USB_CoreReset
     122  USB_DeactivateDedicatedEndpoint
     170  USB_DeactivateEndpoint
      30  USB_DevConnect
      30  USB_DevDisconnect
     448  USB_DevInit
      14  USB_DisableGlobalInt
      68  USB_DoPing
      74  USB_DriveVbus
     492  USB_EP0StartXfer
      88  USB_EP0_OutStart
     150  USB_EPClearStall
     158  USB_EPSetStall
     834  USB_EPStartXfer
      14  USB_EnableGlobalInt
      32  USB_FlushRxFifo
      36  USB_FlushTxFifo
      10  USB_GetCurrentFrame
      78  USB_GetDevSpeed
      22  USB_GetHostSpeed
       8  USB_GetMode
     390  USB_HC_Halt
     432  USB_HC_Init
      10  USB_HC_ReadInterrupt
     470  USB_HC_StartXfer
     224  USB_HostInit
      76  USB_InitFSLSPClkSel
      22  USB_ReadDevAllInEpInterrupt
      22  USB_ReadDevAllOutEpInterrupt
      52  USB_ReadDevInEPInterrupt
      26  USB_ReadDevOutEPInterrupt
      14  USB_ReadInterrupts
      44  USB_ReadPacket
      56  USB_ResetPort
      54  USB_SetCurrentMode
      44  USB_SetDevAddress
      22  USB_SetDevSpeed
      92  USB_StopDevice
     180  USB_StopHost
      70  USB_WritePacket
       4  debug

 
     4 bytes in section .bss
 5 960 bytes in section .text
 
 5 960 bytes of CODE memory
     4 bytes of DATA memory

Errors: none
Warnings: none
