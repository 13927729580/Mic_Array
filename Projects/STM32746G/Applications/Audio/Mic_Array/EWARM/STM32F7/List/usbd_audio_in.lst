###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.2.10312/W32 for ARM       08/Mar/2016  16:10:20
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Middlewares\ST\STM32_USB_Device_Library\Class\AUDIO\Src\usbd_audio_in.c
#    Command line =  
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Middlewares\ST\STM32_USB_Device_Library\Class\AUDIO\Src\usbd_audio_in.c
#        -D USE_HAL_DRIVER -D STM32F746xx -D USE_STM32746G_DISCO -D
#        USE_IOEXPANDER -D USE_USB_FS -lC
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
#        -lA
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
#        -o
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj
#        --no_unroll --debug --endian=little --cpu=Cortex-M7 -e --fpu=VFPv5_sp
#        --dlib_config "D:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Full.h" -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\CMSIS\Device\ST\STM32F7xx\Include\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\STM32F7xx_HAL_Driver\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\STM32746G-Discovery\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\Components\Common\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Log\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Fonts\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\CPU\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_Device_Library\Core\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Core\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Class\MSC\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\drivers\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_Audio\Addons\PDM\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_Device_Library\Class\AUDIO\Inc\
#        -Oh --use_c++_inline --require_prototypes -I "D:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.3\arm\CMSIS\Include\" -D
#        ARM_MATH_CM7 --relaxed_fp
#    List file    =  
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List\usbd_audio_in.lst
#    Object file  =  
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj\usbd_audio_in.o
#
###############################################################################

D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Middlewares\ST\STM32_USB_Device_Library\Class\AUDIO\Src\usbd_audio_in.c
      1          /**
      2          ******************************************************************************
      3          * @file    usbd_audio_in.c
      4          * @author  Central Labs
      5          * @version V2.2.0 MOD
      6          * @date    11-Jan-2016
      7          * @brief   This file provides the Audio Input core functions.
      8          ******************************************************************************
      9          * @attention
     10          *
     11          * <h2><center>&copy; COPYRIGHT(c) 2014 STMicroelectronics</center></h2>
     12          *
     13          * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
     14          * You may not use this file except in compliance with the License.
     15          * You may obtain a copy of the License at:
     16          *
     17          *        http://www.st.com/software_license_agreement_liberty_v2
     18          *
     19          * Redistribution and use in source and binary forms, with or without modification,
     20          * are permitted provided that the following conditions are met:
     21          *   1. Redistributions of source code must retain the above copyright notice,
     22          *      this list of conditions and the following disclaimer.
     23          *   2. Redistributions in binary form must reproduce the above copyright notice,
     24          *      this list of conditions and the following disclaimer in the documentation
     25          *      and/or other materials provided with the distribution.
     26          *   3. Neither the name of STMicroelectronics nor the names of its contributors
     27          *      may be used to endorse or promote products derived from this software
     28          *      without specific prior written permission.
     29          *
     30          * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
     31          * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     32          * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     33          * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
     34          * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
     35          * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
     36          * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
     37          * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
     38          * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
     39          * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     40          *
     41          ******************************************************************************
     42          */ 
     43          
     44          /* Includes ------------------------------------------------------------------*/
     45          
     46          #include "usbd_audio_in.h"
     47          #include "usbd_desc.h"
     48          #include "usbd_ctlreq.h"
     49          #include "main.h"
     50          
     51          /** @addtogroup STM32_USB_OTG_DEVICE_LIBRARY
     52          * @{
     53          */
     54          
     55          /** @defgroup USBD_AUDIO_IN 
     56          *
     57          * 	This file provides the Audio Input core functions.
     58          *
     59          *           This driver implements the following aspects:
     60          *             - Device descriptor management
     61          *             - Configuration descriptor management
     62          *             - Standard AC Interface Descriptor management
     63          *             - 1 Audio Streaming Interface
     64          *             - 1 Audio Streaming Endpoint
     65          *             - 1 Audio Terminal Input
     66          *             - Audio Class-Specific AC Interfaces
     67          *             - Audio Class-Specific AS Interfaces
     68          *             - AudioControl Requests: mute and volume control
     69          *             - Audio Synchronization type: Asynchronous
     70          *             - Multiple frequencies and channel number configurable using ad hoc
     71          *               init function
     72          *
     73          *          The current audio class version supports the following audio features:
     74          *             - Pulse Coded Modulation (PCM) format
     75          *             - Configurable sampling rate
     76          *             - Bit resolution: 16
     77          *             - Configurable Number of channels
     78          *             - Volume control
     79          *             - Mute/Unmute capability
     80          *             - Asynchronous Endpoints
     81          *
     82          * @note     This driver has been developed starting from the usbd_audio.c file
     83          *           included within the standard Cube Package for STM32F4
     84          * @{
     85          */ 
     86          
     87          /** @defgroup USBD_AUDIO_IN_Private_TypesDefinitions
     88          * @{
     89          */ 
     90          /**
     91          * @}
     92          */ 
     93          
     94          /** @defgroup USBD_AUDIO_IN_Private_Defines
     95          * @{
     96          */ 
     97          
     98          /**
     99          * @}
    100          */ 
    101          
    102          /** @defgroup USBD_AUDIO_IN_Private_Macros
    103          * @{
    104          */ 
    105          /**
    106          * @}
    107          */ 
    108          
    109          /** @defgroup USBD_AUDIO_IN_Private_FunctionPrototypes
    110          * @{
    111          */
    112          static uint8_t  USBD_AUDIO_Init (USBD_HandleTypeDef *pdev, uint8_t cfgidx); 
    113          static uint8_t  USBD_AUDIO_DeInit (USBD_HandleTypeDef *pdev, uint8_t cfgidx); 
    114          static uint8_t  USBD_AUDIO_Setup (USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req); 
    115          static uint8_t  *USBD_AUDIO_GetCfgDesc (uint16_t *length); 
    116          static uint8_t  *USBD_AUDIO_GetDeviceQualifierDesc (uint16_t *length); 
    117          static uint8_t  USBD_AUDIO_DataIn (USBD_HandleTypeDef *pdev, uint8_t epnum); 
    118          static uint8_t  USBD_AUDIO_DataOut (USBD_HandleTypeDef *pdev, uint8_t epnum); 
    119          static uint8_t  USBD_AUDIO_EP0_RxReady (USBD_HandleTypeDef *pdev); 
    120          static uint8_t  USBD_AUDIO_EP0_TxReady (USBD_HandleTypeDef *pdev); 
    121          static uint8_t  USBD_AUDIO_SOF (USBD_HandleTypeDef *pdev); 
    122          static uint8_t  USBD_AUDIO_IsoINIncomplete (USBD_HandleTypeDef *pdev, uint8_t epnum); 
    123          static uint8_t  USBD_AUDIO_IsoOutIncomplete (USBD_HandleTypeDef *pdev, uint8_t epnum); 
    124          static void AUDIO_REQ_GetCurrent(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req);
    125          static void AUDIO_REQ_SetCurrent(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req);
    126          static void AUDIO_REQ_GetMaximum(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req);
    127          static void AUDIO_REQ_GetMinimum(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req);
    128          static void AUDIO_REQ_GetResolution(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req);
    129          
    130          /**
    131          * @}
    132          */ 
    133          
    134          /** @defgroup USBD_AUDIO_Private_Variables
    135          * @{
    136          */ 
    137          /* This dummy buffer with 0 values will be sent when there is no availble data */

   \                                 In section .bss, align 4
    138          static uint8_t IsocInBuffDummy[48*4*2]; 
    139          static  int16_t VOL_CUR;
    140          static USBD_AUDIO_HandleTypeDef haudioInstance;
   \                     haudioInstance:
   \   00000000                      DS8 100
   \   00000064                      DS8 384
    141          

   \                                 In section .data, align 4
    142          USBD_ClassTypeDef  USBD_AUDIO = 
   \                     USBD_AUDIO:
   \   00000000   0x........         DC32 USBD_AUDIO_Init, USBD_AUDIO_DeInit, USBD_AUDIO_Setup
   \              0x........   
   \              0x........   
   \   0000000C   0x........         DC32 USBD_AUDIO_EP0_TxReady, USBD_AUDIO_EP0_RxReady, USBD_AUDIO_DataIn
   \              0x........   
   \              0x........   
   \   00000018   0x........         DC32 USBD_AUDIO_DataOut, USBD_AUDIO_SOF, USBD_AUDIO_IsoINIncomplete
   \              0x........   
   \              0x........   
   \   00000024   0x........         DC32 USBD_AUDIO_IsoOutIncomplete, USBD_AUDIO_GetCfgDesc
   \              0x........   
   \   0000002C   0x........         DC32 USBD_AUDIO_GetCfgDesc, USBD_AUDIO_GetCfgDesc
   \              0x........   
   \   00000034   0x........         DC32 USBD_AUDIO_GetDeviceQualifierDesc

   \                                 In section .bss, align 4
    143          {
    144            USBD_AUDIO_Init,
    145            USBD_AUDIO_DeInit,
    146            USBD_AUDIO_Setup,
    147            USBD_AUDIO_EP0_TxReady,  
    148            USBD_AUDIO_EP0_RxReady,
    149            USBD_AUDIO_DataIn,
    150            USBD_AUDIO_DataOut,
    151            USBD_AUDIO_SOF,
    152            USBD_AUDIO_IsoINIncomplete,
    153            USBD_AUDIO_IsoOutIncomplete,      
    154            USBD_AUDIO_GetCfgDesc,
    155            USBD_AUDIO_GetCfgDesc, 
    156            USBD_AUDIO_GetCfgDesc,
    157            USBD_AUDIO_GetDeviceQualifierDesc,
    158          };
    159          
    160          /* USB AUDIO device Configuration Descriptor */
    161          /* NOTE: This descriptor has to be filled using the Descriptor Initialization function */
    162          __ALIGN_BEGIN static uint8_t USBD_AUDIO_CfgDesc[USB_AUDIO_CONFIG_DESC_SIZ + 9] __ALIGN_END;
   \                     USBD_AUDIO_CfgDesc:
   \   00000000                      DS8 120
   \   00000078                      DS8 2
    163          
    164          /* USB Standard Device Descriptor */

   \                                 In section .data, align 4
    165          __ALIGN_BEGIN static uint8_t USBD_AUDIO_DeviceQualifierDesc[USB_LEN_DEV_QUALIFIER_DESC] __ALIGN_END=
   \                     USBD_AUDIO_DeviceQualifierDesc:
   \   00000000   0x0A 0x06          DC8 10, 6, 0, 2, 0, 0, 0, 64, 1, 0, 0, 0
   \              0x00 0x02    
   \              0x00 0x00    
   \              0x00 0x40    
   \              0x01 0x00    
   \              0x00 0x00    
    166          {
    167            USB_LEN_DEV_QUALIFIER_DESC,
    168            USB_DESC_TYPE_DEVICE_QUALIFIER,
    169            0x00,
    170            0x02,
    171            0x00,
    172            0x00,
    173            0x00,
    174            0x40,
    175            0x01,
    176            0x00,
    177          };
    178          
    179          /**
    180          * @}
    181          */ 
    182          
    183          /** @defgroup USBD_AUDIO_IN_Private_Functions
    184          * @{
    185          */ 
    186          
    187          /**
    188          * @brief  USBD_AUDIO_Init
    189          *         Initialize the AUDIO interface
    190          * @param  pdev: device instance
    191          * @param  cfgidx: Configuration index
    192          * @retval status
    193          */
    194          

   \                                 In section .text, align 2, keep-with-next
    195          static uint8_t  USBD_AUDIO_Init (USBD_HandleTypeDef *pdev, 
    196                                           uint8_t cfgidx)
    197          {
   \                     USBD_AUDIO_Init: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
    198            if(haudioInstance.state!=STATE_USB_WAITING_FOR_INIT)
   \   00000002   0x.... 0x....      LDR.W    R5,??DataTable8
   \   00000006   0x4604             MOV      R4,R0
   \   00000008   0x7D28             LDRB     R0,[R5, #+20]
   \   0000000A   0xB108             CBZ.N    R0,??USBD_AUDIO_Init_0
    199            {
    200              return USBD_FAIL; 
   \   0000000C   0x2002             MOVS     R0,#+2
   \   0000000E   0xBD70             POP      {R4-R6,PC}
    201            }
    202            
    203            USBD_AUDIO_HandleTypeDef   *haudio;
    204            pdev->pClassData = &haudioInstance;
   \                     ??USBD_AUDIO_Init_0: (+1)
   \   00000010   0xF504 0x7306      ADD      R3,R4,#+536
   \   00000014   0x601D             STR      R5,[R3, #+0]
    205            haudio = (USBD_AUDIO_HandleTypeDef *)pdev->pClassData;
    206            uint16_t packet_dim = haudio->paketDimension;
    207            uint16_t wr_rd_offset = (AUDIO_IN_PACKET_NUM/2) * haudio->dataAmount / haudio->paketDimension;
    208            haudio->wr_ptr=wr_rd_offset * packet_dim;
   \   00000016   0x8A29             LDRH     R1,[R5, #+16]
   \   00000018   0x8A68             LDRH     R0,[R5, #+18]
   \   0000001A   0xEB01 0x0141      ADD      R1,R1,R1, LSL #+1
   \   0000001E   0x4606             MOV      R6,R0
   \   00000020   0xFB91 0xF0F0      SDIV     R0,R1,R0
   \   00000024   0xFB10 0xF006      SMULBB   R0,R0,R6
    209            haudio->rd_ptr = 0;
    210            haudio->timeout = 0;
    211            
    212            ((USBD_AUDIO_ItfTypeDef *)pdev->pUserData)->Init(haudio->frequency,0,haudio->channels);
   \   00000028   0x2100             MOVS     R1,#+0
   \   0000002A   0x8328             STRH     R0,[R5, #+24]
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0x82E8             STRH     R0,[R5, #+22]
   \   00000030   0x81A8             STRH     R0,[R5, #+12]
   \   00000032   0x685B             LDR      R3,[R3, #+4]
   \   00000034   0x792A             LDRB     R2,[R5, #+4]
   \   00000036   0x68A8             LDR      R0,[R5, #+8]
   \   00000038   0x681B             LDR      R3,[R3, #+0]
   \   0000003A   0x4798             BLX      R3
    213            
    214            USBD_LL_OpenEP(pdev,
    215                           AUDIO_IN_EP,
    216                           USBD_EP_TYPE_ISOC,
    217                           AUDIO_IN_PACKET);
   \   0000003C   0xF44F 0x7348      MOV      R3,#+800
   \   00000040   0x2201             MOVS     R2,#+1
   \   00000042   0x2181             MOVS     R1,#+129
   \   00000044   0x4620             MOV      R0,R4
   \   00000046   0x.... 0x....      BL       USBD_LL_OpenEP
    218            
    219            USBD_LL_FlushEP(pdev, AUDIO_IN_EP);
   \   0000004A   0x2181             MOVS     R1,#+129
   \   0000004C   0x4620             MOV      R0,R4
   \   0000004E   0x.... 0x....      BL       USBD_LL_FlushEP
    220            
    221            
    222            USBD_LL_Transmit(pdev, AUDIO_IN_EP,
    223                             IsocInBuffDummy,                        
    224                             packet_dim);      
   \   00000052   0x4633             MOV      R3,R6
   \   00000054   0xF105 0x0264      ADD      R2,R5,#+100
   \   00000058   0x2181             MOVS     R1,#+129
   \   0000005A   0x4620             MOV      R0,R4
   \   0000005C   0x.... 0x....      BL       USBD_LL_Transmit
    225            
    226            haudio->state=STATE_USB_IDLE;
   \   00000060   0x2001             MOVS     R0,#+1
   \   00000062   0x7528             STRB     R0,[R5, #+20]
    227            return USBD_OK;
   \   00000064   0x2000             MOVS     R0,#+0
   \   00000066   0xBD70             POP      {R4-R6,PC}       ;; return
    228          }
    229          
    230          /**
    231          * @brief  USBD_AUDIO_Init
    232          *         DeInitialize the AUDIO layer
    233          * @param  pdev: device instance
    234          * @param  cfgidx: Configuration index
    235          * @retval status
    236          */

   \                                 In section .text, align 2, keep-with-next
    237          static uint8_t  USBD_AUDIO_DeInit (USBD_HandleTypeDef *pdev, 
    238                                             uint8_t cfgidx)
    239          {
   \                     USBD_AUDIO_DeInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    240            /* Close EP IN */
    241            USBD_LL_CloseEP(pdev,AUDIO_IN_EP);  
   \   00000004   0x2181             MOVS     R1,#+129
   \   00000006   0x.... 0x....      BL       USBD_LL_CloseEP
    242            /* DeInit  physical Interface components */
    243            if(pdev->pClassData != NULL)
   \   0000000A   0xF504 0x7106      ADD      R1,R4,#+536
   \   0000000E   0x6808             LDR      R0,[R1, #+0]
   \   00000010   0xB138             CBZ.N    R0,??USBD_AUDIO_DeInit_0
    244            {
    245              ((USBD_AUDIO_ItfTypeDef *)pdev->pUserData)->DeInit(0);
   \   00000012   0x6849             LDR      R1,[R1, #+4]
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0x6849             LDR      R1,[R1, #+4]
   \   00000018   0x4788             BLX      R1
    246              haudioInstance.state = STATE_USB_WAITING_FOR_INIT; 
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0x.... 0x....      LDR.W    R1,??DataTable8
   \   00000020   0x7508             STRB     R0,[R1, #+20]
    247            }
    248            return USBD_OK;
   \                     ??USBD_AUDIO_DeInit_0: (+1)
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0xBD10             POP      {R4,PC}          ;; return
    249          }
    250          
    251          /**
    252          * @brief  USBD_AUDIO_Setup
    253          *         Handle the AUDIO specific requests
    254          * @param  pdev: instance
    255          * @param  req: usb requests
    256          * @retval status
    257          */

   \                                 In section .text, align 2, keep-with-next
    258          static uint8_t  USBD_AUDIO_Setup (USBD_HandleTypeDef *pdev, 
    259                                            USBD_SetupReqTypedef *req)
    260          {
   \                     USBD_AUDIO_Setup: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x460C             MOV      R4,R1
    261            USBD_AUDIO_HandleTypeDef   *haudio;
    262            uint16_t len;
    263            uint8_t *pbuf;
    264            uint8_t ret = USBD_OK;
    265            haudio = pdev->pClassData;
   \   00000004   0xF8D0 0x5218      LDR      R5,[R0, #+536]
    266            
    267            switch (req->bmRequest & USB_REQ_TYPE_MASK)
   \   00000008   0x7821             LDRB     R1,[R4, #+0]
   \   0000000A   0xF011 0x0160      ANDS     R1,R1,#0x60
   \   0000000E   0xD048             BEQ.N    ??USBD_AUDIO_Setup_0
   \   00000010   0x2920             CMP      R1,#+32
   \   00000012   0xD167             BNE.N    ??USBD_AUDIO_Setup_1
    268            {
    269              /* AUDIO Class Requests -------------------------------*/
    270            case USB_REQ_TYPE_CLASS :    
    271              switch (req->bRequest)
   \   00000014   0x7861             LDRB     R1,[R4, #+1]
   \   00000016   0x2901             CMP      R1,#+1
   \   00000018   0xD016             BEQ.N    ??USBD_AUDIO_Setup_2
   \   0000001A   0x2981             CMP      R1,#+129
   \   0000001C   0xD006             BEQ.N    ??USBD_AUDIO_Setup_3
   \   0000001E   0x2982             CMP      R1,#+130
   \   00000020   0xD023             BEQ.N    ??USBD_AUDIO_Setup_4
   \   00000022   0x2983             CMP      R1,#+131
   \   00000024   0xD029             BEQ.N    ??USBD_AUDIO_Setup_5
   \   00000026   0x2984             CMP      R1,#+132
   \   00000028   0xD02E             BEQ.N    ??USBD_AUDIO_Setup_6
   \   0000002A   0xE035             B.N      ??USBD_AUDIO_Setup_7
    272              {
    273              case AUDIO_REQ_GET_CUR:
    274                AUDIO_REQ_GetCurrent(pdev, req);
   \                     ??USBD_AUDIO_Setup_3: (+1)
   \   0000002C   0x.... 0x....      LDR.W    R2,??DataTable8_1
   \   00000030   0xF105 0x011D      ADD      R1,R5,#+29
   \   00000034   0xF8B2 0x3078      LDRH     R3,[R2, #+120]
   \   00000038   0x700B             STRB     R3,[R1, #+0]
   \   0000003A   0xF9B2 0x2078      LDRSH    R2,[R2, #+120]
   \   0000003E   0x0412             LSLS     R2,R2,#+16
   \   00000040   0x0E12             LSRS     R2,R2,#+24
   \   00000042   0x704A             STRB     R2,[R1, #+1]
   \   00000044   0x88E2             LDRH     R2,[R4, #+6]
   \   00000046   0xE041             B.N      ??USBD_AUDIO_Setup_8
    275                break;
    276                
    277              case AUDIO_REQ_SET_CUR:
    278                AUDIO_REQ_SetCurrent(pdev, req);   
   \                     ??USBD_AUDIO_Setup_2: (+1)
   \   00000048   0x88E2             LDRH     R2,[R4, #+6]
   \   0000004A   0x2A00             CMP      R2,#+0
   \   0000004C   0xD04A             BEQ.N    ??USBD_AUDIO_Setup_1
   \   0000004E   0x.... 0x....      LDR.W    R1,??DataTable8_2
   \   00000052   0x.... 0x....      BL       USBD_CtlPrepareRx
   \   00000056   0x2001             MOVS     R0,#+1
   \   00000058   0x7728             STRB     R0,[R5, #+28]
   \   0000005A   0x88E1             LDRH     R1,[R4, #+6]
   \   0000005C   0xF105 0x005D      ADD      R0,R5,#+93
   \   00000060   0x7001             STRB     R1,[R0, #+0]
   \   00000062   0x88A1             LDRH     R1,[R4, #+4]
   \   00000064   0x0A09             LSRS     R1,R1,#+8
   \   00000066   0x7041             STRB     R1,[R0, #+1]
   \   00000068   0xE03C             B.N      ??USBD_AUDIO_Setup_1
    279                break;
    280                
    281              case AUDIO_REQ_GET_MIN:
    282                AUDIO_REQ_GetMinimum(pdev, req);
   \                     ??USBD_AUDIO_Setup_4: (+1)
   \   0000006A   0xF105 0x011D      ADD      R1,R5,#+29
   \   0000006E   0x22E0             MOVS     R2,#+224
   \   00000070   0x700A             STRB     R2,[R1, #+0]
   \   00000072   0x22DB             MOVS     R2,#+219
   \   00000074   0x77AA             STRB     R2,[R5, #+30]
   \   00000076   0x88E2             LDRH     R2,[R4, #+6]
   \   00000078   0xE028             B.N      ??USBD_AUDIO_Setup_8
    283                break;
    284                
    285              case AUDIO_REQ_GET_MAX:
    286                AUDIO_REQ_GetMaximum(pdev, req);
   \                     ??USBD_AUDIO_Setup_5: (+1)
   \   0000007A   0xF105 0x011D      ADD      R1,R5,#+29
   \   0000007E   0x2200             MOVS     R2,#+0
   \   00000080   0x700A             STRB     R2,[R1, #+0]
   \   00000082   0x77AA             STRB     R2,[R5, #+30]
   \   00000084   0x88E2             LDRH     R2,[R4, #+6]
   \   00000086   0xE021             B.N      ??USBD_AUDIO_Setup_8
    287                break;
    288                
    289              case AUDIO_REQ_GET_RES:
    290                AUDIO_REQ_GetResolution(pdev, req);
   \                     ??USBD_AUDIO_Setup_6: (+1)
   \   00000088   0xF105 0x011D      ADD      R1,R5,#+29
   \   0000008C   0x2223             MOVS     R2,#+35
   \   0000008E   0x700A             STRB     R2,[R1, #+0]
   \   00000090   0x2200             MOVS     R2,#+0
   \   00000092   0x77AA             STRB     R2,[R5, #+30]
   \   00000094   0x88E2             LDRH     R2,[R4, #+6]
   \   00000096   0xE019             B.N      ??USBD_AUDIO_Setup_8
    291                break;
    292                
    293              default:
    294                USBD_CtlError (pdev, req);
   \                     ??USBD_AUDIO_Setup_7: (+1)
   \   00000098   0x4621             MOV      R1,R4
   \   0000009A   0x.... 0x....      BL       USBD_CtlError
    295                return USBD_FAIL;
   \   0000009E   0x2002             MOVS     R0,#+2
   \   000000A0   0xBD32             POP      {R1,R4,R5,PC}
    296              }
    297              break; 
    298              
    299              /* Standard Requests -------------------------------*/
    300            case USB_REQ_TYPE_STANDARD:
    301              switch (req->bRequest)
   \                     ??USBD_AUDIO_Setup_0: (+1)
   \   000000A2   0x7861             LDRB     R1,[R4, #+1]
   \   000000A4   0x2906             CMP      R1,#+6
   \   000000A6   0xD004             BEQ.N    ??USBD_AUDIO_Setup_9
   \   000000A8   0x290A             CMP      R1,#+10
   \   000000AA   0xD00D             BEQ.N    ??USBD_AUDIO_Setup_10
   \   000000AC   0x290B             CMP      R1,#+11
   \   000000AE   0xD010             BEQ.N    ??USBD_AUDIO_Setup_11
   \   000000B0   0xE018             B.N      ??USBD_AUDIO_Setup_1
    302              {
    303              case USB_REQ_GET_DESCRIPTOR: 
    304                if( (req->wValue >> 8) == AUDIO_DESCRIPTOR_TYPE)
   \                     ??USBD_AUDIO_Setup_9: (+1)
   \   000000B2   0x8861             LDRH     R1,[R4, #+2]
   \   000000B4   0x0A09             LSRS     R1,R1,#+8
   \   000000B6   0x2921             CMP      R1,#+33
   \   000000B8   0xD114             BNE.N    ??USBD_AUDIO_Setup_1
    305                {
    306                  
    307                  pbuf = USBD_AUDIO_CfgDesc + 18;
    308                  len = MIN(USB_AUDIO_DESC_SIZ , req->wLength);   
   \   000000BA   0x88E2             LDRH     R2,[R4, #+6]
    309                  
    310                  USBD_CtlSendData (pdev, 
    311                                    pbuf,
    312                                    len);
   \   000000BC   0x.... 0x....      LDR.W    R1,??DataTable8_3
   \   000000C0   0x2A0A             CMP      R2,#+10
   \   000000C2   0xBFA8             IT       GE 
   \   000000C4   0x2209             MOVGE    R2,#+9
   \   000000C6   0xE001             B.N      ??USBD_AUDIO_Setup_8
    313                }
    314                break;
    315                
    316              case USB_REQ_GET_INTERFACE :
    317                USBD_CtlSendData (pdev,
    318                                  (uint8_t *)haudio->alt_setting,
    319                                  1);
   \                     ??USBD_AUDIO_Setup_10: (+1)
   \   000000C8   0x2201             MOVS     R2,#+1
   \   000000CA   0x6829             LDR      R1,[R5, #+0]
   \                     ??USBD_AUDIO_Setup_8: (+1)
   \   000000CC   0x.... 0x....      BL       USBD_CtlSendData
    320                break;
   \   000000D0   0xE008             B.N      ??USBD_AUDIO_Setup_1
    321                
    322              case USB_REQ_SET_INTERFACE :
    323                if ((uint8_t)(req->wValue) < USBD_MAX_NUM_INTERFACES)
   \                     ??USBD_AUDIO_Setup_11: (+1)
   \   000000D2   0x8861             LDRH     R1,[R4, #+2]
   \   000000D4   0xB2CA             UXTB     R2,R1
   \   000000D6   0x2A02             CMP      R2,#+2
   \   000000D8   0xBFB9             ITTEE    LT 
    324                {
    325                  haudio->alt_setting = (uint8_t)(req->wValue);
   \   000000DA   0xB2C9             UXTBLT   R1,R1
   \   000000DC   0x6029             STRLT    R1,[R5, #+0]
    326                }
    327                else
    328                {
    329                  /* Call the error management function (command will be nacked */
    330                  USBD_CtlError (pdev, req);
   \   000000DE   0x4621             MOVGE    R1,R4
   \   000000E0   0x.... 0x....      BLGE     USBD_CtlError
    331                }
    332                break;
    333              }
    334            }
    335            return ret;
   \                     ??USBD_AUDIO_Setup_1: (+1)
   \   000000E4   0x2000             MOVS     R0,#+0
   \   000000E6   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    336          }
    337          
    338          /**
    339          * @brief  USBD_AUDIO_GetCfgDesc 
    340          *         return configuration descriptor
    341          * @param  length : pointer data length
    342          * @retval pointer to descriptor buffer
    343          */

   \                                 In section .text, align 2, keep-with-next
    344          static uint8_t  *USBD_AUDIO_GetCfgDesc (uint16_t *length)
    345          {
    346            *length = sizeof (USBD_AUDIO_CfgDesc);
   \                     USBD_AUDIO_GetCfgDesc: (+1)
   \   00000000   0x2176             MOVS     R1,#+118
   \   00000002   0x8001             STRH     R1,[R0, #+0]
    347            return USBD_AUDIO_CfgDesc;
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable8_1
   \   00000008   0x4770             BX       LR               ;; return
    348          }
    349          
    350          /**
    351          * @brief  USBD_AUDIO_DataIn
    352          *         handle data IN Stage
    353          * @param  pdev: device instance
    354          * @param  epnum: endpoint index
    355          * @retval status
    356          */

   \                                 In section .text, align 2, keep-with-next
    357          static uint8_t USBD_AUDIO_DataIn (USBD_HandleTypeDef *pdev,
    358                                            uint8_t epnum)
    359          {
   \                     USBD_AUDIO_DataIn: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x4680             MOV      R8,R0
    360            
    361            USBD_AUDIO_HandleTypeDef   *haudio;
    362            haudio = pdev->pClassData;
   \   00000006   0xF508 0x7506      ADD      R5,R8,#+536
    363            uint32_t length_usb_pck;
    364            uint16_t app;
    365            uint16_t IsocInWr_app = haudio->wr_ptr;
    366            uint16_t true_dim = haudio->buffer_length;
    367            uint16_t packet_dim = haudio->paketDimension;
    368            uint16_t channels = haudio->channels;
    369            length_usb_pck = packet_dim;  
    370            haudio->timeout=0;
   \   0000000A   0x2000             MOVS     R0,#+0
    371            if (epnum == (AUDIO_IN_EP & 0x7F))
   \   0000000C   0x2901             CMP      R1,#+1
   \   0000000E   0x682E             LDR      R6,[R5, #+0]
   \   00000010   0x8A74             LDRH     R4,[R6, #+18]
   \   00000012   0x8B37             LDRH     R7,[R6, #+24]
   \   00000014   0xF8B6 0xB00E      LDRH     R11,[R6, #+14]
   \   00000018   0xF896 0x9004      LDRB     R9,[R6, #+4]
   \   0000001C   0x46A2             MOV      R10,R4
   \   0000001E   0x81B0             STRH     R0,[R6, #+12]
   \   00000020   0xD14D             BNE.N    ??USBD_AUDIO_DataIn_0
    372            {    
    373              if (haudio->state == STATE_USB_IDLE) 
   \   00000022   0x7D30             LDRB     R0,[R6, #+20]
   \   00000024   0x2801             CMP      R0,#+1
   \   00000026   0xD104             BNE.N    ??USBD_AUDIO_DataIn_1
    374              {
    375                haudio->state=STATE_USB_REQUESTS_STARTED;
   \   00000028   0x2002             MOVS     R0,#+2
   \   0000002A   0x7530             STRB     R0,[R6, #+20]
    376                ((USBD_AUDIO_ItfTypeDef *)pdev->pUserData)->Record();      
   \   0000002C   0x6868             LDR      R0,[R5, #+4]
   \   0000002E   0x6880             LDR      R0,[R0, #+8]
   \   00000030   0x4780             BLX      R0
    377              }    
    378              if (haudio->state == STATE_USB_BUFFER_WRITE_STARTED)   
   \                     ??USBD_AUDIO_DataIn_1: (+1)
   \   00000032   0x7D30             LDRB     R0,[R6, #+20]
   \   00000034   0x2803             CMP      R0,#+3
   \   00000036   0xD13B             BNE.N    ??USBD_AUDIO_DataIn_2
    379              {      
    380                haudio->rd_ptr = haudio->rd_ptr % (true_dim);              
   \   00000038   0x8AF0             LDRH     R0,[R6, #+22]
   \   0000003A   0xFB90 0xF1FB      SDIV     R1,R0,R11
   \   0000003E   0xFB0B 0x0011      MLS      R0,R11,R1,R0
   \   00000042   0x82F0             STRH     R0,[R6, #+22]
    381                if(IsocInWr_app<haudio->rd_ptr){
   \   00000044   0x8AF1             LDRH     R1,[R6, #+22]
   \   00000046   0x4608             MOV      R0,R1
   \   00000048   0x4287             CMP      R7,R0
   \   0000004A   0xBFBA             ITTE     LT 
   \   0000004C   0xEBAB 0x0101      SUBLT    R1,R11,R1
   \   00000050   0x187F             ADDLT    R7,R7,R1
   \   00000052   0x1A7F             SUBGE    R7,R7,R1
    382                  app = ((true_dim) - haudio->rd_ptr) +  IsocInWr_app;
    383                }else{
    384                  app = IsocInWr_app - haudio->rd_ptr;
    385                }        
    386                if(app >= (packet_dim*haudio->upper_treshold)){       
   \   00000054   0x7EB1             LDRB     R1,[R6, #+26]
   \   00000056   0xB2BF             UXTH     R7,R7
   \   00000058   0x4361             MULS     R1,R1,R4
   \   0000005A   0x428F             CMP      R7,R1
   \   0000005C   0xBFA8             IT       GE 
   \   0000005E   0xEB0A 0x0A49      ADDGE    R10,R10,R9, LSL #+1
    387                  length_usb_pck += channels*2;
   \   00000062   0xDA05             BGE.N    ??USBD_AUDIO_DataIn_3
    388                }else if(app <= (packet_dim*haudio->lower_treshold)){
   \   00000064   0x7EF1             LDRB     R1,[R6, #+27]
   \   00000066   0x4361             MULS     R1,R1,R4
   \   00000068   0x42B9             CMP      R1,R7
   \   0000006A   0xBFA8             IT       GE 
   \   0000006C   0xEBAA 0x0A49      SUBGE    R10,R10,R9, LSL #+1
    389                  length_usb_pck -= channels*2;
    390                }     
    391                USBD_LL_Transmit (pdev,AUDIO_IN_EP,
    392                                  (uint8_t*)(&haudio->buffer[haudio->rd_ptr]),
    393                                  length_usb_pck);      
   \                     ??USBD_AUDIO_DataIn_3: (+1)
   \   00000070   0x6E31             LDR      R1,[R6, #+96]
   \   00000072   0xFA1F 0xF38A      UXTH     R3,R10
   \   00000076   0x1842             ADDS     R2,R0,R1
   \   00000078   0x2181             MOVS     R1,#+129
   \   0000007A   0x4640             MOV      R0,R8
   \   0000007C   0x.... 0x....      BL       USBD_LL_Transmit
    394                haudio->rd_ptr += length_usb_pck;      
   \   00000080   0x8AF0             LDRH     R0,[R6, #+22]
    395          
    396                if(app < haudio->buffer_length/10)
   \   00000082   0x210A             MOVS     R1,#+10
   \   00000084   0x4450             ADD      R0,R10,R0
   \   00000086   0x82F0             STRH     R0,[R6, #+22]
   \   00000088   0x89F0             LDRH     R0,[R6, #+14]
   \   0000008A   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \   0000008E   0x4287             CMP      R7,R0
   \   00000090   0xDA15             BGE.N    ??USBD_AUDIO_DataIn_0
    397                {
    398                  ((USBD_AUDIO_ItfTypeDef *)pdev->pUserData)->Stop();
   \   00000092   0x6868             LDR      R0,[R5, #+4]
   \   00000094   0x6940             LDR      R0,[R0, #+20]
   \   00000096   0x4780             BLX      R0
    399                  haudio->state = STATE_USB_IDLE; 
   \   00000098   0x2001             MOVS     R0,#+1
   \   0000009A   0x7530             STRB     R0,[R6, #+20]
    400                  haudio->timeout=0;
   \   0000009C   0x2000             MOVS     R0,#+0
   \   0000009E   0x81B0             STRH     R0,[R6, #+12]
    401                  memset(haudio->buffer,0,(haudio->buffer_length + haudio->dataAmount));
   \   000000A0   0x89F0             LDRH     R0,[R6, #+14]
   \   000000A2   0x8A31             LDRH     R1,[R6, #+16]
   \   000000A4   0xFA11 0xF180      UXTAH    R1,R1,R0
   \   000000A8   0x6E30             LDR      R0,[R6, #+96]
   \   000000AA   0x.... 0x....      BL       __aeabi_memclr
    402                }       
    403              }
   \   000000AE   0xE006             B.N      ??USBD_AUDIO_DataIn_0
    404              else 
    405              {      
    406                USBD_LL_Transmit (pdev,AUDIO_IN_EP,
    407                                  IsocInBuffDummy,
    408                                  length_usb_pck);      
   \                     ??USBD_AUDIO_DataIn_2: (+1)
   \   000000B0   0x4653             MOV      R3,R10
   \   000000B2   0x.... 0x....      LDR.W    R2,??DataTable8_4
   \   000000B6   0x2181             MOVS     R1,#+129
   \   000000B8   0x4640             MOV      R0,R8
   \   000000BA   0x.... 0x....      BL       USBD_LL_Transmit
    409              }    
    410            }
    411            return USBD_OK;
   \                     ??USBD_AUDIO_DataIn_0: (+1)
   \   000000BE   0x2000             MOVS     R0,#+0
   \   000000C0   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
    412          }
    413          
    414          /**
    415          * @brief  USBD_AUDIO_EP0_RxReady
    416          *         handle EP0 Rx Ready event
    417          * @param  pdev: device instance
    418          * @retval status
    419          */
    420          

   \                                 In section .text, align 2, keep-with-next
    421          static uint8_t  USBD_AUDIO_EP0_RxReady (USBD_HandleTypeDef *pdev)
    422          {  
    423            USBD_AUDIO_HandleTypeDef   *haudio;
    424            haudio = pdev->pClassData;  
   \                     USBD_AUDIO_EP0_RxReady: (+1)
   \   00000000   0xF500 0x7106      ADD      R1,R0,#+536
   \   00000004   0xB538             PUSH     {R3-R5,LR}
   \   00000006   0x6808             LDR      R0,[R1, #+0]
    425            if (haudio->control.cmd == AUDIO_REQ_SET_CUR)
   \   00000008   0xF100 0x041C      ADD      R4,R0,#+28
   \   0000000C   0x7822             LDRB     R2,[R4, #+0]
   \   0000000E   0x2A01             CMP      R2,#+1
   \   00000010   0xBF02             ITTT     EQ 
   \   00000012   0xF100 0x055D      ADDEQ    R5,R0,#+93
   \   00000016   0x7868             LDRBEQ   R0,[R5, #+1]
   \   00000018   0x2802             CMPEQ    R0,#+2
    426            {    
    427              if (haudio->control.unit == AUDIO_OUT_STREAMING_CTRL)
   \   0000001A   0xD10B             BNE.N    ??USBD_AUDIO_EP0_RxReady_0
    428              {
    429                ((USBD_AUDIO_ItfTypeDef *)pdev->pUserData)->VolumeCtl(VOL_CUR);    
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable8_1
   \   00000020   0x6849             LDR      R1,[R1, #+4]
   \   00000022   0xF9B0 0x0078      LDRSH    R0,[R0, #+120]
   \   00000026   0x68C9             LDR      R1,[R1, #+12]
   \   00000028   0x4788             BLX      R1
    430                
    431                haudio->control.cmd = 0;
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0x7020             STRB     R0,[R4, #+0]
    432                haudio->control.len = 0;
   \   0000002E   0x7028             STRB     R0,[R5, #+0]
    433                haudio->control.unit = 0;
   \   00000030   0x7068             STRB     R0,[R5, #+1]
    434                haudio->control.data[0]=0;
   \   00000032   0x7060             STRB     R0,[R4, #+1]
    435                haudio->control.data[0]=0;
    436              }
    437            }    
    438            return USBD_OK;
   \                     ??USBD_AUDIO_EP0_RxReady_0: (+1)
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    439          }
    440          /**
    441          * @brief  USBD_AUDIO_EP0_TxReady
    442          *         handle EP0 TRx Ready event
    443          * @param  pdev: device instance
    444          * @retval status
    445          */

   \                                 In section .text, align 2, keep-with-next
    446          static uint8_t  USBD_AUDIO_EP0_TxReady (USBD_HandleTypeDef *pdev)
    447          {
    448            /* Only OUT control data are processed */
    449            return USBD_OK;
   \                     USBD_AUDIO_EP0_TxReady: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x4770             BX       LR               ;; return
    450          }
    451          /**
    452          * @brief  USBD_AUDIO_SOF
    453          *         handle SOF event
    454          * @param  pdev: device instance
    455          * @retval status
    456          */

   \                                 In section .text, align 2, keep-with-next
    457          static uint8_t  USBD_AUDIO_SOF (USBD_HandleTypeDef *pdev)
    458          {  
    459            return USBD_OK;
   \                     USBD_AUDIO_SOF: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x4770             BX       LR               ;; return
    460          }
    461          
    462          
    463          /**
    464          * @brief  USBD_AUDIO_IsoINIncomplete
    465          *         handle data ISO IN Incomplete event
    466          * @param  pdev: device instance
    467          * @param  epnum: endpoint index
    468          * @retval status
    469          */

   \                                 In section .text, align 2, keep-with-next
    470          static uint8_t  USBD_AUDIO_IsoINIncomplete (USBD_HandleTypeDef *pdev, uint8_t epnum)
    471          {  
    472            return USBD_OK;
   \                     USBD_AUDIO_IsoINIncomplete: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x4770             BX       LR               ;; return
    473          }
    474          /**
    475          * @brief  USBD_AUDIO_IsoOutIncomplete
    476          *         handle data ISO OUT Incomplete event
    477          * @param  pdev: device instance
    478          * @param  epnum: endpoint index
    479          * @retval status
    480          */

   \                                 In section .text, align 2, keep-with-next
    481          static uint8_t  USBD_AUDIO_IsoOutIncomplete (USBD_HandleTypeDef *pdev, uint8_t epnum)
    482          {  
    483            return USBD_OK;
   \                     USBD_AUDIO_IsoOutIncomplete: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x4770             BX       LR               ;; return
    484          }
    485          /**
    486          * @brief  USBD_AUDIO_DataOut
    487          *         handle data OUT Stage
    488          * @param  pdev: device instance
    489          * @param  epnum: endpoint index
    490          * @retval status
    491          */

   \                                 In section .text, align 2, keep-with-next
    492          static uint8_t  USBD_AUDIO_DataOut (USBD_HandleTypeDef *pdev, 
    493                                              uint8_t epnum)
    494          {  
    495            return USBD_OK;
   \                     USBD_AUDIO_DataOut: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x4770             BX       LR               ;; return
    496          }
    497          
    498          /**
    499          * @brief  DeviceQualifierDescriptor 
    500          *         return Device Qualifier descriptor
    501          * @param  length : pointer data length
    502          * @retval pointer to descriptor buffer
    503          */

   \                                 In section .text, align 2, keep-with-next
    504          static uint8_t  *USBD_AUDIO_GetDeviceQualifierDesc (uint16_t *length)
    505          {
    506            *length = sizeof (USBD_AUDIO_DeviceQualifierDesc);
   \                     USBD_AUDIO_GetDeviceQualifierDesc: (+1)
   \   00000000   0x210A             MOVS     R1,#+10
   \   00000002   0x8001             STRH     R1,[R0, #+0]
    507            return USBD_AUDIO_DeviceQualifierDesc;
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable8_5
   \   00000008   0x4770             BX       LR               ;; return
    508          }
    509          
    510          /**
    511          * @brief  AUDIO_REQ_GetMaximum
    512          *         Handles the VOL_MAX Audio control request.
    513          * @param  pdev: instance
    514          * @param  req: setup class request
    515          * @retval status
    516          */
    517          static void AUDIO_REQ_GetMaximum(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req)
    518          {
    519            USBD_AUDIO_HandleTypeDef   *haudio;
    520            haudio = pdev->pClassData;
    521            
    522            (haudio->control.data)[0] = (uint16_t)VOL_MAX & 0xFF;
    523            (haudio->control.data)[1] = ((uint16_t)VOL_MAX & 0xFF00 ) >> 8;
    524            
    525            USBD_CtlSendData (pdev, 
    526                              haudio->control.data,
    527                              req->wLength);  
    528          }
    529          
    530          /**
    531          * @brief  AUDIO_REQ_GetMinimum
    532          *         Handles the VOL_MIN Audio control request.
    533          * @param  pdev: instance
    534          * @param  req: setup class request
    535          * @retval status
    536          */
    537          static void AUDIO_REQ_GetMinimum(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req)
    538          {
    539            USBD_AUDIO_HandleTypeDef   *haudio;
    540            haudio = pdev->pClassData;  
    541            (haudio->control.data)[0] = (uint16_t)VOL_MIN & 0xFF;
    542            (haudio->control.data)[1] = ((uint16_t)VOL_MIN & 0xFF00 ) >> 8;
    543            /* Send the current mute state */
    544            USBD_CtlSendData (pdev, 
    545                              haudio->control.data,
    546                              req->wLength);   
    547          }
    548          
    549          /**
    550          * @brief  AUDIO_Req_GetResolution
    551          *         Handles the VOL_RES Audio control request.
    552          * @param  pdev: instance
    553          * @param  req: setup class request
    554          * @retval status
    555          */
    556          static void AUDIO_REQ_GetResolution(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req)
    557          {
    558            USBD_AUDIO_HandleTypeDef   *haudio;
    559            haudio = pdev->pClassData;  
    560            (haudio->control.data)[0] = (uint16_t)VOL_RES & 0xFF;
    561            (haudio->control.data)[1] = ((uint16_t)VOL_RES & 0xFF00 ) >> 8;  
    562            USBD_CtlSendData (pdev, 
    563                              haudio->control.data,
    564                              req->wLength);
    565          }
    566          
    567          /**
    568          * @brief  AUDIO_Req_GetCurrent
    569          *         Handles the GET_CUR Audio control request.
    570          * @param  pdev: instance
    571          * @param  req: setup class request
    572          * @retval status
    573          */
    574          static void AUDIO_REQ_GetCurrent(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req)
    575          {  
    576            USBD_AUDIO_HandleTypeDef   *haudio;
    577            haudio = pdev->pClassData;
    578            
    579            (haudio->control.data)[0] = (uint16_t)VOL_CUR & 0xFF;
    580            (haudio->control.data)[1] = ((uint16_t)VOL_CUR & 0xFF00 ) >> 8;
    581            
    582            USBD_CtlSendData (pdev, 
    583                              haudio->control.data,
    584                              req->wLength);  
    585          }
    586          
    587          /**
    588          * @brief  AUDIO_Req_SetCurrent
    589          *         Handles the SET_CUR Audio control request.
    590          * @param  pdev: instance
    591          * @param  req: setup class request
    592          * @retval status
    593          */
    594          static void AUDIO_REQ_SetCurrent(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req)
    595          { 
    596            USBD_AUDIO_HandleTypeDef   *haudio;
    597            haudio = pdev->pClassData;  
    598            if (req->wLength)
    599            {
    600              /* Prepare the reception of the buffer over EP0 */
    601              USBD_CtlPrepareRx (pdev,
    602                                 (uint8_t *)&VOL_CUR,
    603                                 req->wLength);
    604              
    605              haudio->control.cmd = AUDIO_REQ_SET_CUR;     /* Set the request value */
    606              haudio->control.len = req->wLength;          /* Set the request data length */
    607              haudio->control.unit = HIBYTE(req->wIndex);  /* Set the request target unit */
    608            }
    609          }
    610          
    611          
    612          /**
    613          * @}
    614          */ 
    615          
    616          /** @defgroup USBD_AUDIO_IN_Exported_Functions
    617          * @{
    618          */ 
    619          
    620          /**
    621          * @brief  USBD_AUDIO_Data_Transfer
    622          *         Fills the USB internal buffer with audio data from user
    623          * @param pdev: device instance
    624          * @param audioData: audio data to be sent via USB
    625          * @param dataAmount: number of PCM samples to be copyed
    626          * @note Depending on the calling frequency, a coherent amount of samples must be passed to 
    627          *       the function. E.g.: assuming a Sampling frequency of 16 KHz and 1 channel, 
    628          *       you can pass 16 PCM samples if the function is called each millisecond, 
    629          *       32 samples if called every 2 milliseconds and so on. 
    630          * @retval status
    631          */

   \                                 In section .text, align 2, keep-with-next
    632          uint8_t  USBD_AUDIO_Data_Transfer(USBD_HandleTypeDef *pdev, int16_t * audioData, uint16_t PCMSamples)
    633          {
   \                     USBD_AUDIO_Data_Transfer: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x460D             MOV      R5,R1
    634            
    635            USBD_AUDIO_HandleTypeDef   *haudio;
    636            haudio = (USBD_AUDIO_HandleTypeDef *)pdev->pClassData;
   \   00000004   0xF500 0x7106      ADD      R1,R0,#+536
    637            
    638            if(haudioInstance.state==STATE_USB_WAITING_FOR_INIT){    
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable8
   \   0000000C   0x680C             LDR      R4,[R1, #+0]
   \   0000000E   0x7D00             LDRB     R0,[R0, #+20]
   \   00000010   0xB908             CBNZ.N   R0,??USBD_AUDIO_Data_Transfer_0
    639              return USBD_BUSY;    
   \   00000012   0x2001             MOVS     R0,#+1
   \   00000014   0xBDF2             POP      {R1,R4-R7,PC}
    640            }  
    641            uint16_t dataAmount = PCMSamples * 2; /*Bytes*/
   \                     ??USBD_AUDIO_Data_Transfer_0: (+1)
   \   00000016   0x0056             LSLS     R6,R2,#+1
    642            uint16_t true_dim = haudio->buffer_length;
    643            uint16_t current_data_Amount = haudio->dataAmount;
    644            uint16_t packet_dim = haudio->paketDimension;
    645            
    646            if(haudio->state==STATE_USB_REQUESTS_STARTED  || current_data_Amount!=dataAmount){   
   \   00000018   0x7D22             LDRB     R2,[R4, #+20]
   \   0000001A   0xB2B6             UXTH     R6,R6
   \   0000001C   0x89E7             LDRH     R7,[R4, #+14]
   \   0000001E   0x8A60             LDRH     R0,[R4, #+18]
   \   00000020   0x2A02             CMP      R2,#+2
   \   00000022   0xD002             BEQ.N    ??USBD_AUDIO_Data_Transfer_1
   \   00000024   0x8A23             LDRH     R3,[R4, #+16]
   \   00000026   0x42B3             CMP      R3,R6
   \   00000028   0xD02D             BEQ.N    ??USBD_AUDIO_Data_Transfer_2
    647              
    648              /*USB parameters definition, based on the amount of data passed*/
    649              haudio->dataAmount=dataAmount;                  
    650              uint16_t wr_rd_offset = (AUDIO_IN_PACKET_NUM/2) * dataAmount / packet_dim; 
   \                     ??USBD_AUDIO_Data_Transfer_1: (+1)
   \   0000002A   0xEB06 0x0146      ADD      R1,R6,R6, LSL #+1
   \   0000002E   0x8226             STRH     R6,[R4, #+16]
   \   00000030   0xFB91 0xF1F0      SDIV     R1,R1,R0
   \   00000034   0xB289             UXTH     R1,R1
    651              haudio->wr_ptr=wr_rd_offset * packet_dim;
   \   00000036   0xFB11 0xF200      SMULBB   R2,R1,R0
   \   0000003A   0x8322             STRH     R2,[R4, #+24]
    652              haudio->rd_ptr = 0;
   \   0000003C   0x2200             MOVS     R2,#+0
   \   0000003E   0x82E2             STRH     R2,[R4, #+22]
    653              haudio->upper_treshold = wr_rd_offset + 1;
   \   00000040   0x1C4A             ADDS     R2,R1,#+1
    654              haudio->lower_treshold = wr_rd_offset - 1;
   \   00000042   0x1E49             SUBS     R1,R1,#+1
   \   00000044   0x76A2             STRB     R2,[R4, #+26]
   \   00000046   0x76E1             STRB     R1,[R4, #+27]
    655              haudio->buffer_length = (packet_dim * (dataAmount / packet_dim) * AUDIO_IN_PACKET_NUM);
   \   00000048   0xFB96 0xF1F0      SDIV     R1,R6,R0
   \   0000004C   0xFB10 0xF001      SMULBB   R0,R0,R1
   \   00000050   0xEB00 0x0140      ADD      R1,R0,R0, LSL #+1
   \   00000054   0x0048             LSLS     R0,R1,#+1
   \   00000056   0x81E0             STRH     R0,[R4, #+14]
    656              
    657              /*Memory allocation for data buffer, depending (also) on data amount passed to the transfer function*/
    658              if(haudio->buffer != NULL)
   \   00000058   0x6E20             LDR      R0,[R4, #+96]
   \   0000005A   0xB108             CBZ.N    R0,??USBD_AUDIO_Data_Transfer_3
    659              {
    660                USBD_free(haudio->buffer);      
   \   0000005C   0x.... 0x....      BL       free
    661              }
    662              haudio->buffer = USBD_malloc(haudio->buffer_length + haudio->dataAmount);
   \                     ??USBD_AUDIO_Data_Transfer_3: (+1)
   \   00000060   0x89E0             LDRH     R0,[R4, #+14]
   \   00000062   0x8A21             LDRH     R1,[R4, #+16]
   \   00000064   0xFA11 0xF080      UXTAH    R0,R1,R0
   \   00000068   0x.... 0x....      BL       malloc
   \   0000006C   0x6620             STR      R0,[R4, #+96]
    663              if(haudio->buffer == NULL)
   \   0000006E   0xB908             CBNZ.N   R0,??USBD_AUDIO_Data_Transfer_4
    664              {
    665                return USBD_FAIL;       
   \   00000070   0x2002             MOVS     R0,#+2
   \   00000072   0xBDF2             POP      {R1,R4-R7,PC}
    666              }
    667              memset(haudio->buffer,0,(haudio->buffer_length + haudio->dataAmount));
   \                     ??USBD_AUDIO_Data_Transfer_4: (+1)
   \   00000074   0x89E1             LDRH     R1,[R4, #+14]
   \   00000076   0x8A22             LDRH     R2,[R4, #+16]
   \   00000078   0xFA12 0xF181      UXTAH    R1,R2,R1
   \   0000007C   0x.... 0x....      BL       __aeabi_memclr
    668              haudio->state=STATE_USB_BUFFER_WRITE_STARTED;
   \   00000080   0x2003             MOVS     R0,#+3
   \   00000082   0x7520             STRB     R0,[R4, #+20]
   \   00000084   0xE026             B.N      ??USBD_AUDIO_Data_Transfer_5
    669              
    670              
    671            }else if(haudio->state==STATE_USB_BUFFER_WRITE_STARTED){
   \                     ??USBD_AUDIO_Data_Transfer_2: (+1)
   \   00000086   0x2A03             CMP      R2,#+3
   \   00000088   0xD124             BNE.N    ??USBD_AUDIO_Data_Transfer_5
    672              if(haudio->timeout++==TIMEOUT_VALUE){
   \   0000008A   0xF9B4 0x000C      LDRSH    R0,[R4, #+12]
   \   0000008E   0x1C42             ADDS     R2,R0,#+1
   \   00000090   0x28C8             CMP      R0,#+200
   \   00000092   0x81A2             STRH     R2,[R4, #+12]
   \   00000094   0xD106             BNE.N    ??USBD_AUDIO_Data_Transfer_6
    673                haudio->state=STATE_USB_IDLE;
   \   00000096   0x2001             MOVS     R0,#+1
   \   00000098   0x7520             STRB     R0,[R4, #+20]
    674                ((USBD_AUDIO_ItfTypeDef *)pdev->pUserData)->Stop();   
   \   0000009A   0x6848             LDR      R0,[R1, #+4]
   \   0000009C   0x6940             LDR      R0,[R0, #+20]
   \   0000009E   0x4780             BLX      R0
    675               haudio->timeout=0;
   \   000000A0   0x2000             MOVS     R0,#+0
   \   000000A2   0x81A0             STRH     R0,[R4, #+12]
    676              }
    677              memcpy((uint8_t * )&haudio->buffer[haudio->wr_ptr], (uint8_t *)(audioData), dataAmount);    
   \                     ??USBD_AUDIO_Data_Transfer_6: (+1)
   \   000000A4   0x8B23             LDRH     R3,[R4, #+24]
   \   000000A6   0x6E20             LDR      R0,[R4, #+96]
   \   000000A8   0x4632             MOV      R2,R6
   \   000000AA   0x4629             MOV      R1,R5
   \   000000AC   0x1818             ADDS     R0,R3,R0
   \   000000AE   0x.... 0x....      BL       __aeabi_memcpy
    678              haudio->wr_ptr += dataAmount;
   \   000000B2   0x8B20             LDRH     R0,[R4, #+24]
   \   000000B4   0x1830             ADDS     R0,R6,R0
   \   000000B6   0x8320             STRH     R0,[R4, #+24]
    679              haudio->wr_ptr = haudio->wr_ptr % (true_dim);    
   \   000000B8   0xB280             UXTH     R0,R0
   \   000000BA   0xFB90 0xF1F7      SDIV     R1,R0,R7
   \   000000BE   0xFB07 0x0011      MLS      R0,R7,R1,R0
   \   000000C2   0x8320             STRH     R0,[R4, #+24]
    680              if((haudio->wr_ptr-dataAmount) == 0){
   \   000000C4   0x8B20             LDRH     R0,[R4, #+24]
   \   000000C6   0x1B80             SUBS     R0,R0,R6
   \   000000C8   0xD104             BNE.N    ??USBD_AUDIO_Data_Transfer_5
    681                memcpy((uint8_t *)(((uint8_t *)haudio->buffer)+true_dim),(uint8_t *)haudio->buffer, dataAmount);
   \   000000CA   0x6E21             LDR      R1,[R4, #+96]
   \   000000CC   0x4632             MOV      R2,R6
   \   000000CE   0x1878             ADDS     R0,R7,R1
   \   000000D0   0x.... 0x....      BL       __aeabi_memcpy
    682              }
    683            }
    684            return USBD_OK;  
   \                     ??USBD_AUDIO_Data_Transfer_5: (+1)
   \   000000D4   0x2000             MOVS     R0,#+0
   \   000000D6   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    685          }
    686          
    687          
    688          /**
    689          * @brief  USBD_AUDIO_RegisterInterface
    690          * @param  fops: Audio interface callback
    691          * @retval status
    692          */

   \                                 In section .text, align 2, keep-with-next
    693          uint8_t  USBD_AUDIO_RegisterInterface  (USBD_HandleTypeDef   *pdev, 
    694                                                  USBD_AUDIO_ItfTypeDef *fops)
    695          {
    696            if(fops != NULL)
   \                     USBD_AUDIO_RegisterInterface: (+1)
   \   00000000   0xB109             CBZ.N    R1,??USBD_AUDIO_RegisterInterface_0
    697            {
    698              pdev->pUserData= fops;
   \   00000002   0xF8C0 0x121C      STR      R1,[R0, #+540]
    699            }
    700            return 0;}
   \                     ??USBD_AUDIO_RegisterInterface_0: (+1)
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x4770             BX       LR               ;; return
    701          
    702          /**
    703          * @brief  Configures the microphone descriptor on the base of the frequency 
    704          *         and channels number informations. These parameters will be used to
    705          *         init the audio engine, trough the USB interface functions.
    706          * @param  samplingFrequency: sampling frequency
    707          * @param  Channels: number of channels
    708          * @retval status
    709          */

   \                                 In section .text, align 2, keep-with-next
    710          void USBD_AUDIO_Init_Microphone_Descriptor(USBD_HandleTypeDef   *pdev, uint32_t samplingFrequency, uint8_t Channels)
    711          {
   \                     USBD_AUDIO_Init_Microphone_Descriptor: (+1)
   \   00000000   0xB470             PUSH     {R4-R6}
    712            uint16_t index;
    713            uint8_t AUDIO_CONTROLS;   
    714            USBD_AUDIO_CfgDesc[0] = 0x09;                                                /* bLength */
   \   00000002   0x....             LDR.N    R3,??DataTable8_1
   \   00000004   0x2009             MOVS     R0,#+9
   \   00000006   0x7018             STRB     R0,[R3, #+0]
    715            USBD_AUDIO_CfgDesc[1] = 0x02;                                                /* bDescriptorType */
   \   00000008   0x2002             MOVS     R0,#+2
   \   0000000A   0x7058             STRB     R0,[R3, #+1]
    716            USBD_AUDIO_CfgDesc[2] = ((USB_AUDIO_CONFIG_DESC_SIZ+Channels-1)&0xff);       /* wTotalLength */
   \   0000000C   0xF102 0x006C      ADD      R0,R2,#+108
   \   00000010   0x7098             STRB     R0,[R3, #+2]
    717            USBD_AUDIO_CfgDesc[3] = ((USB_AUDIO_CONFIG_DESC_SIZ+Channels-1)>>8);
   \   00000012   0x4610             MOV      R0,R2
   \   00000014   0xF100 0x046C      ADD      R4,R0,#+108
   \   00000018   0x0424             LSLS     R4,R4,#+16
   \   0000001A   0x0E24             LSRS     R4,R4,#+24
    718            USBD_AUDIO_CfgDesc[4] = 0x02;                                                /* bNumInterfaces */
    719            USBD_AUDIO_CfgDesc[5] = 0x01;                                                /* bConfigurationValue */
    720            USBD_AUDIO_CfgDesc[6] = 0x00;                                                /* iConfiguration */
    721            USBD_AUDIO_CfgDesc[7] = 0x80;                                                /* bmAttributes  BUS Powered*/
    722            USBD_AUDIO_CfgDesc[8] = 0x32;                                                /* bMaxPower = 100 mA*/   
    723            /* USB Microphone Standard interface descriptor */
    724            USBD_AUDIO_CfgDesc[9] = 9;                                                   /* bLength */
    725            USBD_AUDIO_CfgDesc[10] = USB_INTERFACE_DESCRIPTOR_TYPE;                      /* bDescriptorType */
    726            USBD_AUDIO_CfgDesc[11] = 0x00;                                               /* bInterfaceNumber */
    727            USBD_AUDIO_CfgDesc[12] = 0x00;                                               /* bAlternateSetting */
    728            USBD_AUDIO_CfgDesc[13] = 0x00;                                               /* bNumEndpoints */
    729            USBD_AUDIO_CfgDesc[14] = USB_DEVICE_CLASS_AUDIO;                             /* bInterfaceClass */
    730            USBD_AUDIO_CfgDesc[15] = AUDIO_SUBCLASS_AUDIOCONTROL;                        /* bInterfaceSubClass */
    731            USBD_AUDIO_CfgDesc[16] = AUDIO_PROTOCOL_UNDEFINED;                           /* bInterfaceProtocol */
    732            USBD_AUDIO_CfgDesc[17] = 0x00;                                               /* iInterface */   
    733            /* USB Microphone Class-specific AC Interface Descriptor */
    734            USBD_AUDIO_CfgDesc[18] = 9;                                                  /* bLength */
    735            USBD_AUDIO_CfgDesc[19] = AUDIO_INTERFACE_DESCRIPTOR_TYPE;                    /* bDescriptorType */
    736            USBD_AUDIO_CfgDesc[20] = AUDIO_CONTROL_HEADER;                               /* bDescriptorSubtype */
    737            USBD_AUDIO_CfgDesc[21] = 0x00;       /* 1.00 */                              /* bcdADC */
    738            USBD_AUDIO_CfgDesc[22] = 0x01;
    739            USBD_AUDIO_CfgDesc[23] = 0x25+Channels;                                      /* wTotalLength = 37+AUDIO_CHANNELS*/
    740            USBD_AUDIO_CfgDesc[24] = 0x00;
    741            USBD_AUDIO_CfgDesc[25] = 0x01;                                               /* bInCollection */
    742            USBD_AUDIO_CfgDesc[26] = 0x01;                                               /* baInterfaceNr */   
    743            /* USB Microphone Input Terminal Descriptor */
    744            USBD_AUDIO_CfgDesc[27] = AUDIO_INPUT_TERMINAL_DESC_SIZE;                     /* bLength */
    745            USBD_AUDIO_CfgDesc[28] = AUDIO_INTERFACE_DESCRIPTOR_TYPE;                    /* bDescriptorType */
    746            USBD_AUDIO_CfgDesc[29] = AUDIO_CONTROL_INPUT_TERMINAL;                       /* bDescriptorSubtype */
    747            USBD_AUDIO_CfgDesc[30] = 0x01;                                               /* bTerminalID */
    748            USBD_AUDIO_CfgDesc[31] = 0x01;                                               /* wTerminalType AUDIO_TERMINAL_USB_MICROPHONE   0x0201 */
    749            USBD_AUDIO_CfgDesc[32] = 0x02;
    750            USBD_AUDIO_CfgDesc[33] = 0x00;                                               /* bAssocTerminal */
   \   0000001C   0x2500             MOVS     R5,#+0
   \   0000001E   0x70DC             STRB     R4,[R3, #+3]
   \   00000020   0x2402             MOVS     R4,#+2
   \   00000022   0x711C             STRB     R4,[R3, #+4]
   \   00000024   0x2401             MOVS     R4,#+1
   \   00000026   0x715C             STRB     R4,[R3, #+5]
   \   00000028   0x2400             MOVS     R4,#+0
   \   0000002A   0x719C             STRB     R4,[R3, #+6]
   \   0000002C   0x2480             MOVS     R4,#+128
   \   0000002E   0x71DC             STRB     R4,[R3, #+7]
   \   00000030   0x2432             MOVS     R4,#+50
   \   00000032   0x721C             STRB     R4,[R3, #+8]
   \   00000034   0x2409             MOVS     R4,#+9
   \   00000036   0x725C             STRB     R4,[R3, #+9]
   \   00000038   0x2404             MOVS     R4,#+4
   \   0000003A   0x729C             STRB     R4,[R3, #+10]
   \   0000003C   0x2400             MOVS     R4,#+0
   \   0000003E   0x72DC             STRB     R4,[R3, #+11]
   \   00000040   0x819C             STRH     R4,[R3, #+12]
   \   00000042   0x2401             MOVS     R4,#+1
   \   00000044   0x739C             STRB     R4,[R3, #+14]
   \   00000046   0x73DC             STRB     R4,[R3, #+15]
   \   00000048   0x2400             MOVS     R4,#+0
   \   0000004A   0x821C             STRH     R4,[R3, #+16]
   \   0000004C   0x2409             MOVS     R4,#+9
   \   0000004E   0x749C             STRB     R4,[R3, #+18]
   \   00000050   0x2424             MOVS     R4,#+36
   \   00000052   0x74DC             STRB     R4,[R3, #+19]
   \   00000054   0x2401             MOVS     R4,#+1
   \   00000056   0x751C             STRB     R4,[R3, #+20]
   \   00000058   0x2400             MOVS     R4,#+0
   \   0000005A   0x755C             STRB     R4,[R3, #+21]
   \   0000005C   0x2401             MOVS     R4,#+1
   \   0000005E   0x759C             STRB     R4,[R3, #+22]
   \   00000060   0xF102 0x0425      ADD      R4,R2,#+37
   \   00000064   0x75DC             STRB     R4,[R3, #+23]
   \   00000066   0x2400             MOVS     R4,#+0
   \   00000068   0x761C             STRB     R4,[R3, #+24]
   \   0000006A   0x2401             MOVS     R4,#+1
   \   0000006C   0x765C             STRB     R4,[R3, #+25]
   \   0000006E   0x769C             STRB     R4,[R3, #+26]
   \   00000070   0x240C             MOVS     R4,#+12
   \   00000072   0x76DC             STRB     R4,[R3, #+27]
   \   00000074   0x2424             MOVS     R4,#+36
   \   00000076   0x771C             STRB     R4,[R3, #+28]
   \   00000078   0x2402             MOVS     R4,#+2
   \   0000007A   0x775C             STRB     R4,[R3, #+29]
   \   0000007C   0x2401             MOVS     R4,#+1
   \   0000007E   0x779C             STRB     R4,[R3, #+30]
   \   00000080   0x77DC             STRB     R4,[R3, #+31]
   \   00000082   0x2402             MOVS     R4,#+2
   \   00000084   0xF883 0x4020      STRB     R4,[R3, #+32]
   \   00000088   0xF103 0x0421      ADD      R4,R3,#+33
    751            USBD_AUDIO_CfgDesc[34] = Channels;                                           /* bNrChannels */   
    752            if(Channels != 2)
   \   0000008C   0x2A02             CMP      R2,#+2
   \   0000008E   0x7025             STRB     R5,[R4, #+0]
   \   00000090   0x7062             STRB     R2,[R4, #+1]
   \   00000092   0xD002             BEQ.N    ??USBD_AUDIO_Init_Microphone_Descriptor_0
    753            {
    754              USBD_AUDIO_CfgDesc[35] = 0x00;                                             /* wChannelConfig 0x0000  Mono */
   \   00000094   0x2600             MOVS     R6,#+0
   \   00000096   0x70A6             STRB     R6,[R4, #+2]
    755              USBD_AUDIO_CfgDesc[36] = 0x00;
   \   00000098   0xE002             B.N      ??USBD_AUDIO_Init_Microphone_Descriptor_1
    756            }
    757            else
    758            {
    759              USBD_AUDIO_CfgDesc[35] = 0x03;                                             /* wChannelConfig 0x0003  Stereo */
   \                     ??USBD_AUDIO_Init_Microphone_Descriptor_0: (+1)
   \   0000009A   0x2603             MOVS     R6,#+3
   \   0000009C   0x70A6             STRB     R6,[R4, #+2]
    760              USBD_AUDIO_CfgDesc[36] = 0x00;
   \   0000009E   0x2600             MOVS     R6,#+0
   \                     ??USBD_AUDIO_Init_Microphone_Descriptor_1: (+1)
   \   000000A0   0x70E6             STRB     R6,[R4, #+3]
    761            }   
    762            USBD_AUDIO_CfgDesc[37] = 0x00;                                               /* iChannelNames */
   \   000000A2   0x7126             STRB     R6,[R4, #+4]
    763            USBD_AUDIO_CfgDesc[38] = 0x00;                                               /* iTerminal */   
   \   000000A4   0x7166             STRB     R6,[R4, #+5]
    764            /* USB Microphone Audio Feature Unit Descriptor */
    765            USBD_AUDIO_CfgDesc[39] = 0x07+Channels+1;                                    /* bLength */
   \   000000A6   0xF102 0x0608      ADD      R6,R2,#+8
   \   000000AA   0x71A6             STRB     R6,[R4, #+6]
    766            USBD_AUDIO_CfgDesc[40] = AUDIO_INTERFACE_DESCRIPTOR_TYPE;                    /* bDescriptorType */
   \   000000AC   0x2624             MOVS     R6,#+36
   \   000000AE   0x71E6             STRB     R6,[R4, #+7]
    767            USBD_AUDIO_CfgDesc[41] = AUDIO_CONTROL_FEATURE_UNIT;                         /* bDescriptorSubtype */
   \   000000B0   0x2606             MOVS     R6,#+6
   \   000000B2   0x7226             STRB     R6,[R4, #+8]
    768            USBD_AUDIO_CfgDesc[42] = 0x02;                                               /* bUnitID */
   \   000000B4   0x2602             MOVS     R6,#+2
   \   000000B6   0x7266             STRB     R6,[R4, #+9]
    769            USBD_AUDIO_CfgDesc[43] = 0x01;                                               /* bSourceID */
   \   000000B8   0x2601             MOVS     R6,#+1
   \   000000BA   0x72A6             STRB     R6,[R4, #+10]
    770            USBD_AUDIO_CfgDesc[44] = 0x01;                                               /* bControlSize */   
   \   000000BC   0x72E6             STRB     R6,[R4, #+11]
    771            index = 47;   
   \   000000BE   0x262F             MOVS     R6,#+47
    772            if(Channels == 1)
   \   000000C0   0x2A01             CMP      R2,#+1
   \   000000C2   0xD104             BNE.N    ??USBD_AUDIO_Init_Microphone_Descriptor_2
    773            {
    774              AUDIO_CONTROLS = (0x02);     
    775              USBD_AUDIO_CfgDesc[45] = AUDIO_CONTROLS;
   \   000000C4   0x2502             MOVS     R5,#+2
   \   000000C6   0x7325             STRB     R5,[R4, #+12]
    776              USBD_AUDIO_CfgDesc[46] = 0x00;     
   \   000000C8   0x2500             MOVS     R5,#+0
   \   000000CA   0x7365             STRB     R5,[R4, #+13]
   \   000000CC   0xE026             B.N      ??USBD_AUDIO_Init_Microphone_Descriptor_3
    777            }
    778            else
    779            {
    780              AUDIO_CONTROLS = (0x02);     
    781              USBD_AUDIO_CfgDesc[45] = 0x00;
    782              USBD_AUDIO_CfgDesc[46] = AUDIO_CONTROLS;
   \                     ??USBD_AUDIO_Init_Microphone_Descriptor_2: (+1)
   \   000000CE   0x2602             MOVS     R6,#+2
   \   000000D0   0x7325             STRB     R5,[R4, #+12]
   \   000000D2   0x7366             STRB     R6,[R4, #+13]
    783              USBD_AUDIO_CfgDesc[index] = AUDIO_CONTROLS;
   \   000000D4   0x73A6             STRB     R6,[R4, #+14]
    784              index++;
   \   000000D6   0x2630             MOVS     R6,#+48
    785            }   
    786            if(Channels > 2)
   \   000000D8   0x2A03             CMP      R2,#+3
   \   000000DA   0xDB02             BLT.N    ??USBD_AUDIO_Init_Microphone_Descriptor_4
    787            {
    788              USBD_AUDIO_CfgDesc[index] = AUDIO_CONTROLS;
   \   000000DC   0x2602             MOVS     R6,#+2
   \   000000DE   0x73E6             STRB     R6,[R4, #+15]
    789              index++;
   \   000000E0   0x2631             MOVS     R6,#+49
    790            }   
    791            if(Channels > 3)
   \                     ??USBD_AUDIO_Init_Microphone_Descriptor_4: (+1)
   \   000000E2   0x2A04             CMP      R2,#+4
   \   000000E4   0xDB02             BLT.N    ??USBD_AUDIO_Init_Microphone_Descriptor_5
    792            {
    793              USBD_AUDIO_CfgDesc[index] = AUDIO_CONTROLS;
   \   000000E6   0x2402             MOVS     R4,#+2
   \   000000E8   0x54F4             STRB     R4,[R6, R3]
    794              index++;
   \   000000EA   0x1C76             ADDS     R6,R6,#+1
    795            }   
    796            if(Channels > 4)
   \                     ??USBD_AUDIO_Init_Microphone_Descriptor_5: (+1)
   \   000000EC   0x2A05             CMP      R2,#+5
   \   000000EE   0xDB03             BLT.N    ??USBD_AUDIO_Init_Microphone_Descriptor_6
    797            {
    798              USBD_AUDIO_CfgDesc[index] = AUDIO_CONTROLS;
   \   000000F0   0x2402             MOVS     R4,#+2
   \   000000F2   0xB2B6             UXTH     R6,R6
   \   000000F4   0x54F4             STRB     R4,[R6, R3]
    799              index++;
   \   000000F6   0x1C76             ADDS     R6,R6,#+1
    800            }   
    801            if(Channels > 5)
   \                     ??USBD_AUDIO_Init_Microphone_Descriptor_6: (+1)
   \   000000F8   0x2A06             CMP      R2,#+6
   \   000000FA   0xDB03             BLT.N    ??USBD_AUDIO_Init_Microphone_Descriptor_7
    802            {
    803              USBD_AUDIO_CfgDesc[index] = AUDIO_CONTROLS;
   \   000000FC   0x2402             MOVS     R4,#+2
   \   000000FE   0xB2B6             UXTH     R6,R6
   \   00000100   0x54F4             STRB     R4,[R6, R3]
    804              index++;
   \   00000102   0x1C76             ADDS     R6,R6,#+1
    805            }   
    806            if(Channels > 6)
   \                     ??USBD_AUDIO_Init_Microphone_Descriptor_7: (+1)
   \   00000104   0x2A07             CMP      R2,#+7
   \   00000106   0xDB03             BLT.N    ??USBD_AUDIO_Init_Microphone_Descriptor_8
    807            {
    808              USBD_AUDIO_CfgDesc[index] = AUDIO_CONTROLS;
   \   00000108   0x2402             MOVS     R4,#+2
   \   0000010A   0xB2B6             UXTH     R6,R6
   \   0000010C   0x54F4             STRB     R4,[R6, R3]
    809              index++;
   \   0000010E   0x1C76             ADDS     R6,R6,#+1
    810            }   
    811            if(Channels > 7)
   \                     ??USBD_AUDIO_Init_Microphone_Descriptor_8: (+1)
   \   00000110   0x2A08             CMP      R2,#+8
   \   00000112   0xDB03             BLT.N    ??USBD_AUDIO_Init_Microphone_Descriptor_3
    812            {
    813              USBD_AUDIO_CfgDesc[index] = AUDIO_CONTROLS;
   \   00000114   0x2402             MOVS     R4,#+2
   \   00000116   0xB2B6             UXTH     R6,R6
   \   00000118   0x54F4             STRB     R4,[R6, R3]
    814              index++;
   \   0000011A   0x1C76             ADDS     R6,R6,#+1
    815            }   
    816            USBD_AUDIO_CfgDesc[index] = 0x00;                                            /* iTerminal */
   \                     ??USBD_AUDIO_Init_Microphone_Descriptor_3: (+1)
   \   0000011C   0xB2B6             UXTH     R6,R6
    817            index++;   
   \   0000011E   0x1C74             ADDS     R4,R6,#+1
   \   00000120   0x54F5             STRB     R5,[R6, R3]
    818            /*USB Microphone Output Terminal Descriptor */
    819            USBD_AUDIO_CfgDesc[index++] = 0x09;                                          /* bLength */
   \   00000122   0x2509             MOVS     R5,#+9
   \   00000124   0xB2A4             UXTH     R4,R4
   \   00000126   0x54E5             STRB     R5,[R4, R3]
   \   00000128   0x1C64             ADDS     R4,R4,#+1
    820            USBD_AUDIO_CfgDesc[index++] = AUDIO_INTERFACE_DESCRIPTOR_TYPE;               /* bDescriptorType */
   \   0000012A   0x2524             MOVS     R5,#+36
   \   0000012C   0xB2A4             UXTH     R4,R4
   \   0000012E   0x54E5             STRB     R5,[R4, R3]
   \   00000130   0x1C64             ADDS     R4,R4,#+1
    821            USBD_AUDIO_CfgDesc[index++] = AUDIO_CONTROL_OUTPUT_TERMINAL;                 /* bDescriptorSubtype */
   \   00000132   0x2503             MOVS     R5,#+3
   \   00000134   0xB2A4             UXTH     R4,R4
   \   00000136   0x54E5             STRB     R5,[R4, R3]
   \   00000138   0x1C64             ADDS     R4,R4,#+1
    822            USBD_AUDIO_CfgDesc[index++] = 0x03;                                          /* bTerminalID */
   \   0000013A   0xB2A4             UXTH     R4,R4
   \   0000013C   0x54E5             STRB     R5,[R4, R3]
   \   0000013E   0x1C64             ADDS     R4,R4,#+1
    823            USBD_AUDIO_CfgDesc[index++] = 0x01;                                          /* wTerminalType AUDIO_TERMINAL_USB_STREAMING 0x0101*/
   \   00000140   0x2501             MOVS     R5,#+1
   \   00000142   0xB2A4             UXTH     R4,R4
   \   00000144   0x54E5             STRB     R5,[R4, R3]
   \   00000146   0x1C64             ADDS     R4,R4,#+1
    824            USBD_AUDIO_CfgDesc[index++] = 0x01;
   \   00000148   0xB2A4             UXTH     R4,R4
   \   0000014A   0x54E5             STRB     R5,[R4, R3]
   \   0000014C   0x1C64             ADDS     R4,R4,#+1
    825            USBD_AUDIO_CfgDesc[index++] = 0x00;
   \   0000014E   0x2500             MOVS     R5,#+0
   \   00000150   0xB2A4             UXTH     R4,R4
   \   00000152   0x54E5             STRB     R5,[R4, R3]
   \   00000154   0x1C64             ADDS     R4,R4,#+1
    826            USBD_AUDIO_CfgDesc[index++] = 0x02;
   \   00000156   0x2502             MOVS     R5,#+2
   \   00000158   0xB2A4             UXTH     R4,R4
   \   0000015A   0x54E5             STRB     R5,[R4, R3]
   \   0000015C   0x1C64             ADDS     R4,R4,#+1
    827            USBD_AUDIO_CfgDesc[index++] = 0x00;   
   \   0000015E   0x2500             MOVS     R5,#+0
   \   00000160   0xB2A4             UXTH     R4,R4
   \   00000162   0x54E5             STRB     R5,[R4, R3]
   \   00000164   0x1C64             ADDS     R4,R4,#+1
    828            /* USB Microphone Standard AS Interface Descriptor - Audio Streaming Zero Bandwith */
    829            /* Interface 1, Alternate Setting 0                                             */
    830            USBD_AUDIO_CfgDesc[index++] = 9;                                             /* bLength */
   \   00000166   0x2509             MOVS     R5,#+9
   \   00000168   0xB2A4             UXTH     R4,R4
   \   0000016A   0x54E5             STRB     R5,[R4, R3]
   \   0000016C   0x1C64             ADDS     R4,R4,#+1
    831            USBD_AUDIO_CfgDesc[index++] = USB_INTERFACE_DESCRIPTOR_TYPE;                 /* bDescriptorType */
   \   0000016E   0x2504             MOVS     R5,#+4
   \   00000170   0xB2A4             UXTH     R4,R4
   \   00000172   0x54E5             STRB     R5,[R4, R3]
   \   00000174   0x1C64             ADDS     R4,R4,#+1
    832            USBD_AUDIO_CfgDesc[index++] = 0x01;                                          /* bInterfaceNumber */
   \   00000176   0x2501             MOVS     R5,#+1
   \   00000178   0xB2A4             UXTH     R4,R4
   \   0000017A   0x54E5             STRB     R5,[R4, R3]
   \   0000017C   0x1C64             ADDS     R4,R4,#+1
    833            USBD_AUDIO_CfgDesc[index++] = 0x00;                                          /* bAlternateSetting */
   \   0000017E   0x2500             MOVS     R5,#+0
   \   00000180   0xB2A4             UXTH     R4,R4
   \   00000182   0x54E5             STRB     R5,[R4, R3]
   \   00000184   0x1C64             ADDS     R4,R4,#+1
    834            USBD_AUDIO_CfgDesc[index++] = 0x00;                                          /* bNumEndpoints */
   \   00000186   0xB2A4             UXTH     R4,R4
   \   00000188   0x54E5             STRB     R5,[R4, R3]
   \   0000018A   0x1C64             ADDS     R4,R4,#+1
    835            USBD_AUDIO_CfgDesc[index++] = USB_DEVICE_CLASS_AUDIO;                        /* bInterfaceClass */
   \   0000018C   0x2501             MOVS     R5,#+1
   \   0000018E   0xB2A4             UXTH     R4,R4
   \   00000190   0x54E5             STRB     R5,[R4, R3]
   \   00000192   0x1C64             ADDS     R4,R4,#+1
    836            USBD_AUDIO_CfgDesc[index++] = AUDIO_SUBCLASS_AUDIOSTREAMING;                 /* bInterfaceSubClass */
   \   00000194   0x2502             MOVS     R5,#+2
   \   00000196   0xB2A4             UXTH     R4,R4
   \   00000198   0x54E5             STRB     R5,[R4, R3]
   \   0000019A   0x1C64             ADDS     R4,R4,#+1
    837            USBD_AUDIO_CfgDesc[index++] = AUDIO_PROTOCOL_UNDEFINED;                      /* bInterfaceProtocol */
   \   0000019C   0x2500             MOVS     R5,#+0
   \   0000019E   0xB2A4             UXTH     R4,R4
   \   000001A0   0x54E5             STRB     R5,[R4, R3]
   \   000001A2   0x1C64             ADDS     R4,R4,#+1
    838            USBD_AUDIO_CfgDesc[index++] = 0x00;   
   \   000001A4   0xB2A4             UXTH     R4,R4
   \   000001A6   0x54E5             STRB     R5,[R4, R3]
   \   000001A8   0x1C64             ADDS     R4,R4,#+1
    839            /* USB Microphone Standard AS Interface Descriptor - Audio Streaming Operational */
    840            /* Interface 1, Alternate Setting 1                                           */
    841            USBD_AUDIO_CfgDesc[index++] = 9;                                             /* bLength */
   \   000001AA   0x2509             MOVS     R5,#+9
   \   000001AC   0xB2A4             UXTH     R4,R4
   \   000001AE   0x54E5             STRB     R5,[R4, R3]
   \   000001B0   0x1C64             ADDS     R4,R4,#+1
    842            USBD_AUDIO_CfgDesc[index++] = USB_INTERFACE_DESCRIPTOR_TYPE;                 /* bDescriptorType */
   \   000001B2   0x2504             MOVS     R5,#+4
   \   000001B4   0xB2A4             UXTH     R4,R4
   \   000001B6   0x54E5             STRB     R5,[R4, R3]
   \   000001B8   0x1C64             ADDS     R4,R4,#+1
    843            USBD_AUDIO_CfgDesc[index++] = 0x01;                                          /* bInterfaceNumber */
   \   000001BA   0x2501             MOVS     R5,#+1
   \   000001BC   0xB2A4             UXTH     R4,R4
   \   000001BE   0x54E5             STRB     R5,[R4, R3]
   \   000001C0   0x1C64             ADDS     R4,R4,#+1
    844            USBD_AUDIO_CfgDesc[index++] = 0x01;                                          /* bAlternateSetting */
   \   000001C2   0xB2A4             UXTH     R4,R4
   \   000001C4   0x54E5             STRB     R5,[R4, R3]
   \   000001C6   0x1C64             ADDS     R4,R4,#+1
    845            USBD_AUDIO_CfgDesc[index++] = 0x01;                                          /* bNumEndpoints */
   \   000001C8   0xB2A4             UXTH     R4,R4
   \   000001CA   0x54E5             STRB     R5,[R4, R3]
   \   000001CC   0x1C64             ADDS     R4,R4,#+1
    846            USBD_AUDIO_CfgDesc[index++] = USB_DEVICE_CLASS_AUDIO;                        /* bInterfaceClass */
   \   000001CE   0xB2A4             UXTH     R4,R4
   \   000001D0   0x54E5             STRB     R5,[R4, R3]
   \   000001D2   0x1C64             ADDS     R4,R4,#+1
    847            USBD_AUDIO_CfgDesc[index++] = AUDIO_SUBCLASS_AUDIOSTREAMING;                 /* bInterfaceSubClass */
   \   000001D4   0x2502             MOVS     R5,#+2
   \   000001D6   0xB2A4             UXTH     R4,R4
   \   000001D8   0x54E5             STRB     R5,[R4, R3]
   \   000001DA   0x1C64             ADDS     R4,R4,#+1
    848            USBD_AUDIO_CfgDesc[index++] = AUDIO_PROTOCOL_UNDEFINED;                      /* bInterfaceProtocol */
   \   000001DC   0x2500             MOVS     R5,#+0
   \   000001DE   0xB2A4             UXTH     R4,R4
   \   000001E0   0x54E5             STRB     R5,[R4, R3]
   \   000001E2   0x1C64             ADDS     R4,R4,#+1
    849            USBD_AUDIO_CfgDesc[index++] = 0x00;                                          /* iInterface */   
   \   000001E4   0xB2A4             UXTH     R4,R4
   \   000001E6   0x54E5             STRB     R5,[R4, R3]
   \   000001E8   0x1C64             ADDS     R4,R4,#+1
    850            /* USB Microphone Audio Streaming Interface Descriptor */
    851            USBD_AUDIO_CfgDesc[index++] = AUDIO_STREAMING_INTERFACE_DESC_SIZE;           /* bLength */
   \   000001EA   0x2507             MOVS     R5,#+7
   \   000001EC   0xB2A4             UXTH     R4,R4
   \   000001EE   0x54E5             STRB     R5,[R4, R3]
   \   000001F0   0x1C64             ADDS     R4,R4,#+1
    852            USBD_AUDIO_CfgDesc[index++] = AUDIO_INTERFACE_DESCRIPTOR_TYPE;               /* bDescriptorType */
   \   000001F2   0x2524             MOVS     R5,#+36
   \   000001F4   0xB2A4             UXTH     R4,R4
   \   000001F6   0x54E5             STRB     R5,[R4, R3]
   \   000001F8   0x1C64             ADDS     R4,R4,#+1
    853            USBD_AUDIO_CfgDesc[index++] = AUDIO_STREAMING_GENERAL;                       /* bDescriptorSubtype */
   \   000001FA   0x2501             MOVS     R5,#+1
   \   000001FC   0xB2A4             UXTH     R4,R4
   \   000001FE   0x54E5             STRB     R5,[R4, R3]
   \   00000200   0x1C64             ADDS     R4,R4,#+1
    854            USBD_AUDIO_CfgDesc[index++] = 0x03;                                          /* bTerminalLink */
   \   00000202   0x2503             MOVS     R5,#+3
   \   00000204   0xB2A4             UXTH     R4,R4
   \   00000206   0x54E5             STRB     R5,[R4, R3]
   \   00000208   0x1C64             ADDS     R4,R4,#+1
    855            USBD_AUDIO_CfgDesc[index++] = 0x01;                                          /* bDelay */
   \   0000020A   0x2501             MOVS     R5,#+1
   \   0000020C   0xB2A4             UXTH     R4,R4
   \   0000020E   0x54E5             STRB     R5,[R4, R3]
   \   00000210   0x1C64             ADDS     R4,R4,#+1
    856            USBD_AUDIO_CfgDesc[index++] = 0x01;                                          /* wFormatTag AUDIO_FORMAT_PCM  0x0001*/
   \   00000212   0xB2A4             UXTH     R4,R4
   \   00000214   0x54E5             STRB     R5,[R4, R3]
   \   00000216   0x1C64             ADDS     R4,R4,#+1
    857            USBD_AUDIO_CfgDesc[index++] = 0x00;                
   \   00000218   0x2500             MOVS     R5,#+0
   \   0000021A   0xB2A4             UXTH     R4,R4
   \   0000021C   0x54E5             STRB     R5,[R4, R3]
   \   0000021E   0x1C64             ADDS     R4,R4,#+1
    858            /* USB Microphone Audio Type I Format Interface Descriptor */                
    859            USBD_AUDIO_CfgDesc[index++] = 0x0B;                                          /* bLength */
   \   00000220   0x250B             MOVS     R5,#+11
   \   00000222   0xB2A4             UXTH     R4,R4
   \   00000224   0x54E5             STRB     R5,[R4, R3]
   \   00000226   0x1C64             ADDS     R4,R4,#+1
    860            USBD_AUDIO_CfgDesc[index++] = AUDIO_INTERFACE_DESCRIPTOR_TYPE;               /* bDescriptorType */
   \   00000228   0x2524             MOVS     R5,#+36
   \   0000022A   0xB2A4             UXTH     R4,R4
   \   0000022C   0x54E5             STRB     R5,[R4, R3]
   \   0000022E   0x1C64             ADDS     R4,R4,#+1
    861            USBD_AUDIO_CfgDesc[index++] = AUDIO_STREAMING_FORMAT_TYPE;                   /* bDescriptorSubtype */
   \   00000230   0x2502             MOVS     R5,#+2
   \   00000232   0xB2A4             UXTH     R4,R4
   \   00000234   0x54E5             STRB     R5,[R4, R3]
   \   00000236   0x1C64             ADDS     R4,R4,#+1
    862            USBD_AUDIO_CfgDesc[index++] = AUDIO_FORMAT_TYPE_I;                           /* bFormatType */
   \   00000238   0x2501             MOVS     R5,#+1
   \   0000023A   0xB2A4             UXTH     R4,R4
   \   0000023C   0x54E5             STRB     R5,[R4, R3]
   \   0000023E   0x1C64             ADDS     R4,R4,#+1
    863            USBD_AUDIO_CfgDesc[index++] = Channels;                                      /* bNrChannels */
   \   00000240   0xB2A4             UXTH     R4,R4
    864            USBD_AUDIO_CfgDesc[index++] = 0x02;                                          /* bSubFrameSize */
   \   00000242   0x2502             MOVS     R5,#+2
   \   00000244   0x54E2             STRB     R2,[R4, R3]
   \   00000246   0x1C64             ADDS     R4,R4,#+1
   \   00000248   0xB2A4             UXTH     R4,R4
   \   0000024A   0x54E5             STRB     R5,[R4, R3]
   \   0000024C   0x1C64             ADDS     R4,R4,#+1
    865            USBD_AUDIO_CfgDesc[index++] = 16;                                            /* bBitResolution */
   \   0000024E   0x2510             MOVS     R5,#+16
   \   00000250   0xB2A4             UXTH     R4,R4
   \   00000252   0x54E5             STRB     R5,[R4, R3]
   \   00000254   0x1C64             ADDS     R4,R4,#+1
    866            USBD_AUDIO_CfgDesc[index++] = 0x01;                                           /* bSamFreqType */
   \   00000256   0x2501             MOVS     R5,#+1
   \   00000258   0xB2A4             UXTH     R4,R4
   \   0000025A   0x54E5             STRB     R5,[R4, R3]
   \   0000025C   0x1C64             ADDS     R4,R4,#+1
    867            USBD_AUDIO_CfgDesc[index++] = samplingFrequency&0xff;                        /* tSamFreq 8000 = 0x1F40 */
   \   0000025E   0xB2A4             UXTH     R4,R4
    868            USBD_AUDIO_CfgDesc[index++] = (samplingFrequency>>8)&0xff;
   \   00000260   0x0A0D             LSRS     R5,R1,#+8
   \   00000262   0x54E1             STRB     R1,[R4, R3]
   \   00000264   0x1C64             ADDS     R4,R4,#+1
   \   00000266   0xB2A4             UXTH     R4,R4
   \   00000268   0x54E5             STRB     R5,[R4, R3]
   \   0000026A   0x1C64             ADDS     R4,R4,#+1
    869            USBD_AUDIO_CfgDesc[index++] = samplingFrequency>>16;   
   \   0000026C   0x0C0D             LSRS     R5,R1,#+16
   \   0000026E   0xB2A4             UXTH     R4,R4
   \   00000270   0x54E5             STRB     R5,[R4, R3]
   \   00000272   0x1C64             ADDS     R4,R4,#+1
    870            /* Endpoint 1 - Standard Descriptor */
    871            USBD_AUDIO_CfgDesc[index++] =  AUDIO_STANDARD_ENDPOINT_DESC_SIZE;            /* bLength */
   \   00000274   0x2509             MOVS     R5,#+9
   \   00000276   0xB2A4             UXTH     R4,R4
   \   00000278   0x54E5             STRB     R5,[R4, R3]
   \   0000027A   0x1C64             ADDS     R4,R4,#+1
    872            USBD_AUDIO_CfgDesc[index++] = 0x05;                                          /* bDescriptorType */
   \   0000027C   0x2505             MOVS     R5,#+5
   \   0000027E   0xB2A4             UXTH     R4,R4
   \   00000280   0x54E5             STRB     R5,[R4, R3]
   \   00000282   0x1C64             ADDS     R4,R4,#+1
    873            USBD_AUDIO_CfgDesc[index++] = AUDIO_IN_EP;                                   /* bEndpointAddress 1 in endpoint*/
   \   00000284   0x2581             MOVS     R5,#+129
   \   00000286   0xB2A4             UXTH     R4,R4
   \   00000288   0x54E5             STRB     R5,[R4, R3]
   \   0000028A   0x1C64             ADDS     R4,R4,#+1
    874            USBD_AUDIO_CfgDesc[index++] = 0x05;                                          /* bmAttributes */
   \   0000028C   0x2505             MOVS     R5,#+5
   \   0000028E   0xB2A4             UXTH     R4,R4
   \   00000290   0x54E5             STRB     R5,[R4, R3]
   \   00000292   0x1C65             ADDS     R5,R4,#+1
    875            USBD_AUDIO_CfgDesc[index++] = ((samplingFrequency/1000+2)*Channels*2)&0xFF; //(AUDIO_OUT_BUFFER_SIZE*Channels*2+2)&0xFF;// /* wMaxPacketSize */ 
   \   00000294   0xF44F 0x747A      MOV      R4,#+1000
   \   00000298   0xB2AD             UXTH     R5,R5
   \   0000029A   0xFBB1 0xF4F4      UDIV     R4,R1,R4
   \   0000029E   0x1CA6             ADDS     R6,R4,#+2
    876            USBD_AUDIO_CfgDesc[index++] = ((samplingFrequency/1000+2)*Channels*2)>>8;//(AUDIO_OUT_BUFFER_SIZE*Channels*2+2)>>8;// 
    877            USBD_AUDIO_CfgDesc[index++] = 0x01;                                          /* bInterval */
    878            USBD_AUDIO_CfgDesc[index++] = 0x00;                                          /* bRefresh */
    879            USBD_AUDIO_CfgDesc[index++] = 0x00;                                          /* bSynchAddress */   
    880            /* Endpoint - Audio Streaming Descriptor*/
    881            USBD_AUDIO_CfgDesc[index++] = AUDIO_STREAMING_ENDPOINT_DESC_SIZE;            /* bLength */
    882            USBD_AUDIO_CfgDesc[index++] = AUDIO_ENDPOINT_DESCRIPTOR_TYPE;                /* bDescriptorType */
    883            USBD_AUDIO_CfgDesc[index++] = AUDIO_ENDPOINT_GENERAL;                        /* bDescriptor */
    884            USBD_AUDIO_CfgDesc[index++] = 0x00;                                          /* bmAttributes */
    885            USBD_AUDIO_CfgDesc[index++] = 0x00;                                          /* bLockDelayUnits */
    886            USBD_AUDIO_CfgDesc[index++] = 0x00;                                          /* wLockDelay */
    887            USBD_AUDIO_CfgDesc[index++] = 0x00;    
    888              
    889            haudioInstance.paketDimension = (samplingFrequency/1000*Channels*2);//AUDIO_OUT_BUFFER_SIZE*2*Channels;//
   \   000002A0   0xFB14 0xF000      SMULBB   R0,R4,R0
   \   000002A4   0xFB16 0xF602      SMULBB   R6,R6,R2
   \   000002A8   0x0040             LSLS     R0,R0,#+1
   \   000002AA   0x0076             LSLS     R6,R6,#+1
   \   000002AC   0x54EE             STRB     R6,[R5, R3]
   \   000002AE   0x1CA6             ADDS     R6,R4,#+2
   \   000002B0   0x4356             MULS     R6,R2,R6
   \   000002B2   0x1C6D             ADDS     R5,R5,#+1
   \   000002B4   0xB2AD             UXTH     R5,R5
   \   000002B6   0x09F6             LSRS     R6,R6,#+7
   \   000002B8   0x54EE             STRB     R6,[R5, R3]
   \   000002BA   0x1C6D             ADDS     R5,R5,#+1
   \   000002BC   0x2601             MOVS     R6,#+1
   \   000002BE   0xB2AD             UXTH     R5,R5
   \   000002C0   0x54EE             STRB     R6,[R5, R3]
   \   000002C2   0x1C6D             ADDS     R5,R5,#+1
   \   000002C4   0x2600             MOVS     R6,#+0
   \   000002C6   0xB2AD             UXTH     R5,R5
   \   000002C8   0x54EE             STRB     R6,[R5, R3]
   \   000002CA   0x1C6D             ADDS     R5,R5,#+1
   \   000002CC   0xB2AD             UXTH     R5,R5
   \   000002CE   0x54EE             STRB     R6,[R5, R3]
   \   000002D0   0x1C6D             ADDS     R5,R5,#+1
   \   000002D2   0x2607             MOVS     R6,#+7
   \   000002D4   0xB2AD             UXTH     R5,R5
   \   000002D6   0x54EE             STRB     R6,[R5, R3]
   \   000002D8   0x1C6D             ADDS     R5,R5,#+1
   \   000002DA   0x2625             MOVS     R6,#+37
   \   000002DC   0xB2AD             UXTH     R5,R5
   \   000002DE   0x54EE             STRB     R6,[R5, R3]
   \   000002E0   0x1C6D             ADDS     R5,R5,#+1
   \   000002E2   0x2601             MOVS     R6,#+1
   \   000002E4   0xB2AD             UXTH     R5,R5
   \   000002E6   0x54EE             STRB     R6,[R5, R3]
   \   000002E8   0x1C6D             ADDS     R5,R5,#+1
   \   000002EA   0x2600             MOVS     R6,#+0
   \   000002EC   0xB2AD             UXTH     R5,R5
   \   000002EE   0x54EE             STRB     R6,[R5, R3]
   \   000002F0   0x1C6D             ADDS     R5,R5,#+1
   \   000002F2   0xB2AD             UXTH     R5,R5
   \   000002F4   0x54EE             STRB     R6,[R5, R3]
   \   000002F6   0x1C6D             ADDS     R5,R5,#+1
   \   000002F8   0xB2AD             UXTH     R5,R5
   \   000002FA   0x54EE             STRB     R6,[R5, R3]
   \   000002FC   0x1C6D             ADDS     R5,R5,#+1
   \   000002FE   0xB2AD             UXTH     R5,R5
   \   00000300   0x54EE             STRB     R6,[R5, R3]
   \   00000302   0x....             LDR.N    R3,??DataTable8
   \   00000304   0x8258             STRH     R0,[R3, #+18]
    890            haudioInstance.frequency=samplingFrequency;
    891            haudioInstance.buffer_length = haudioInstance.paketDimension * AUDIO_IN_PACKET_NUM;
   \   00000306   0x8A58             LDRH     R0,[R3, #+18]
   \   00000308   0x6099             STR      R1,[R3, #+8]
    892            haudioInstance.channels=Channels;  
   \   0000030A   0x711A             STRB     R2,[R3, #+4]
    893            haudioInstance.upper_treshold = 5;
    894            haudioInstance.lower_treshold = 2;
    895            haudioInstance.state = STATE_USB_WAITING_FOR_INIT;
   \   0000030C   0x751E             STRB     R6,[R3, #+20]
   \   0000030E   0xEB00 0x0140      ADD      R1,R0,R0, LSL #+1
    896            haudioInstance.wr_ptr = 3 * haudioInstance.paketDimension;
    897            haudioInstance.rd_ptr = 0;  
   \   00000312   0x82DE             STRH     R6,[R3, #+22]
    898            haudioInstance.dataAmount=0;
   \   00000314   0x821E             STRH     R6,[R3, #+16]
   \   00000316   0x0048             LSLS     R0,R1,#+1
    899            haudioInstance.buffer = 0;
   \   00000318   0x661E             STR      R6,[R3, #+96]
   \   0000031A   0x81D8             STRH     R0,[R3, #+14]
   \   0000031C   0x2005             MOVS     R0,#+5
   \   0000031E   0x7698             STRB     R0,[R3, #+26]
   \   00000320   0x2002             MOVS     R0,#+2
   \   00000322   0x76D8             STRB     R0,[R3, #+27]
   \   00000324   0x8A58             LDRH     R0,[R3, #+18]
   \   00000326   0xEB00 0x0040      ADD      R0,R0,R0, LSL #+1
   \   0000032A   0x8318             STRH     R0,[R3, #+24]
    900          }
   \   0000032C   0xBC70             POP      {R4-R6}
   \   0000032E   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8:
   \   00000000   0x........         DC32     haudioInstance

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_1:
   \   00000000   0x........         DC32     USBD_AUDIO_CfgDesc

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_2:
   \   00000000   0x........         DC32     USBD_AUDIO_CfgDesc+0x78

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_3:
   \   00000000   0x........         DC32     USBD_AUDIO_CfgDesc+0x12

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_4:
   \   00000000   0x........         DC32     haudioInstance+0x64

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_5:
   \   00000000   0x........         DC32     USBD_AUDIO_DeviceQualifierDesc
    901          
    902          /**
    903          * @}
    904          */ 
    905          
    906          
    907          /**
    908          * @}
    909          */ 
    910          
    911          
    912          /**
    913          * @}
    914          */ 
    915          
    916          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      40   USBD_AUDIO_DataIn
        40   -- Indirect call
        40   -> USBD_LL_Transmit
        40   -> __aeabi_memclr
       0   USBD_AUDIO_DataOut
      24   USBD_AUDIO_Data_Transfer
        24   -- Indirect call
        24   -> __aeabi_memclr
        24   -> __aeabi_memcpy
        24   -> free
        24   -> malloc
       8   USBD_AUDIO_DeInit
         8   -- Indirect call
         8   -> USBD_LL_CloseEP
      16   USBD_AUDIO_EP0_RxReady
        16   -- Indirect call
       0   USBD_AUDIO_EP0_TxReady
       0   USBD_AUDIO_GetCfgDesc
       0   USBD_AUDIO_GetDeviceQualifierDesc
      16   USBD_AUDIO_Init
        16   -- Indirect call
        16   -> USBD_LL_FlushEP
        16   -> USBD_LL_OpenEP
        16   -> USBD_LL_Transmit
      12   USBD_AUDIO_Init_Microphone_Descriptor
       0   USBD_AUDIO_IsoINIncomplete
       0   USBD_AUDIO_IsoOutIncomplete
       0   USBD_AUDIO_RegisterInterface
       0   USBD_AUDIO_SOF
      16   USBD_AUDIO_Setup
        16   -> USBD_CtlError
        16   -> USBD_CtlPrepareRx
        16   -> USBD_CtlSendData


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable8
       4  ??DataTable8_1
       4  ??DataTable8_2
       4  ??DataTable8_3
       4  ??DataTable8_4
       4  ??DataTable8_5
      56  USBD_AUDIO
     122  USBD_AUDIO_CfgDesc
          VOL_CUR
     196  USBD_AUDIO_DataIn
       4  USBD_AUDIO_DataOut
     216  USBD_AUDIO_Data_Transfer
      38  USBD_AUDIO_DeInit
      12  USBD_AUDIO_DeviceQualifierDesc
      56  USBD_AUDIO_EP0_RxReady
       4  USBD_AUDIO_EP0_TxReady
      10  USBD_AUDIO_GetCfgDesc
      10  USBD_AUDIO_GetDeviceQualifierDesc
     104  USBD_AUDIO_Init
     816  USBD_AUDIO_Init_Microphone_Descriptor
       4  USBD_AUDIO_IsoINIncomplete
       4  USBD_AUDIO_IsoOutIncomplete
      10  USBD_AUDIO_RegisterInterface
       4  USBD_AUDIO_SOF
     232  USBD_AUDIO_Setup
     484  haudioInstance
          IsocInBuffDummy

 
   606 bytes in section .bss
    68 bytes in section .data
 1 732 bytes in section .text
 
 1 732 bytes of CODE memory
   674 bytes of DATA memory

Errors: none
Warnings: none
