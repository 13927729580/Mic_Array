###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.2.10312/W32 for ARM       22/Feb/2016  17:57:54
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Middlewares\ST\STM32_USB_Device_Library\Class\AUDIO\Src\usbd_audio_in.c
#    Command line =  
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Middlewares\ST\STM32_USB_Device_Library\Class\AUDIO\Src\usbd_audio_in.c
#        -D USE_HAL_DRIVER -D STM32F746xx -D USE_STM32746G_DISCO -D
#        USE_IOEXPANDER -D USE_USB_FS -lC
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
#        -lA
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
#        -o
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj
#        --no_unroll --debug --endian=little --cpu=Cortex-M7 -e --fpu=VFPv5_sp
#        --dlib_config "D:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Full.h" -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\CMSIS\Device\ST\STM32F7xx\Include\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\STM32F7xx_HAL_Driver\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\STM32746G-Discovery\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\Components\Common\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Log\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Fonts\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\CPU\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_Device_Library\Core\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Core\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Class\MSC\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\drivers\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_Audio\Addons\PDM\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_Device_Library\Class\AUDIO\Inc\
#        -Ohs --use_c++_inline --require_prototypes -I "D:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.3\arm\CMSIS\Include\" -D
#        ARM_MATH_CM7
#    List file    =  
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List\usbd_audio_in.lst
#    Object file  =  
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj\usbd_audio_in.o
#
###############################################################################

D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Middlewares\ST\STM32_USB_Device_Library\Class\AUDIO\Src\usbd_audio_in.c
      1          /**
                   ^
Warning[Pa050]: non-native end of line sequence detected (this diagnostic is
          only issued once)
      2          ******************************************************************************
      3          * @file    usbd_audio_in.c
      4          * @author  Central Labs
      5          * @version V2.2.0 MOD
      6          * @date    11-Jan-2016
      7          * @brief   This file provides the Audio Input core functions.
      8          ******************************************************************************
      9          * @attention
     10          *
     11          * <h2><center>&copy; COPYRIGHT(c) 2014 STMicroelectronics</center></h2>
     12          *
     13          * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
     14          * You may not use this file except in compliance with the License.
     15          * You may obtain a copy of the License at:
     16          *
     17          *        http://www.st.com/software_license_agreement_liberty_v2
     18          *
     19          * Redistribution and use in source and binary forms, with or without modification,
     20          * are permitted provided that the following conditions are met:
     21          *   1. Redistributions of source code must retain the above copyright notice,
     22          *      this list of conditions and the following disclaimer.
     23          *   2. Redistributions in binary form must reproduce the above copyright notice,
     24          *      this list of conditions and the following disclaimer in the documentation
     25          *      and/or other materials provided with the distribution.
     26          *   3. Neither the name of STMicroelectronics nor the names of its contributors
     27          *      may be used to endorse or promote products derived from this software
     28          *      without specific prior written permission.
     29          *
     30          * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
     31          * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     32          * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     33          * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
     34          * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
     35          * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
     36          * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
     37          * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
     38          * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
     39          * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     40          *
     41          ******************************************************************************
     42          */ 
     43          
     44          /* Includes ------------------------------------------------------------------*/
     45          
     46          #include "usbd_audio_in.h"
     47          #include "usbd_desc.h"
     48          #include "usbd_ctlreq.h"
     49          #include "main.h"
     50          
     51          /** @addtogroup STM32_USB_OTG_DEVICE_LIBRARY
     52          * @{
     53          */
     54          
     55          /** @defgroup USBD_AUDIO_IN 
     56          *
     57          * 	This file provides the Audio Input core functions.
     58          *
     59          *           This driver implements the following aspects:
     60          *             - Device descriptor management
     61          *             - Configuration descriptor management
     62          *             - Standard AC Interface Descriptor management
     63          *             - 1 Audio Streaming Interface
     64          *             - 1 Audio Streaming Endpoint
     65          *             - 1 Audio Terminal Input
     66          *             - Audio Class-Specific AC Interfaces
     67          *             - Audio Class-Specific AS Interfaces
     68          *             - AudioControl Requests: mute and volume control
     69          *             - Audio Synchronization type: Asynchronous
     70          *             - Multiple frequencies and channel number configurable using ad hoc
     71          *               init function
     72          *
     73          *          The current audio class version supports the following audio features:
     74          *             - Pulse Coded Modulation (PCM) format
     75          *             - Configurable sampling rate
     76          *             - Bit resolution: 16
     77          *             - Configurable Number of channels
     78          *             - Volume control
     79          *             - Mute/Unmute capability
     80          *             - Asynchronous Endpoints
     81          *
     82          * @note     This driver has been developed starting from the usbd_audio.c file
     83          *           included within the standard Cube Package for STM32F4
     84          * @{
     85          */ 
     86          
     87          /** @defgroup USBD_AUDIO_IN_Private_TypesDefinitions
     88          * @{
     89          */ 
     90          /**
     91          * @}
     92          */ 
     93          
     94          /** @defgroup USBD_AUDIO_IN_Private_Defines
     95          * @{
     96          */ 
     97          
     98          /**
     99          * @}
    100          */ 
    101          
    102          /** @defgroup USBD_AUDIO_IN_Private_Macros
    103          * @{
    104          */ 
    105          /**
    106          * @}
    107          */ 
    108          
    109          /** @defgroup USBD_AUDIO_IN_Private_FunctionPrototypes
    110          * @{
    111          */
    112          static uint8_t  USBD_AUDIO_Init (USBD_HandleTypeDef *pdev, uint8_t cfgidx); 
    113          static uint8_t  USBD_AUDIO_DeInit (USBD_HandleTypeDef *pdev, uint8_t cfgidx); 
    114          static uint8_t  USBD_AUDIO_Setup (USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req); 
    115          static uint8_t  *USBD_AUDIO_GetCfgDesc (uint16_t *length); 
    116          static uint8_t  *USBD_AUDIO_GetDeviceQualifierDesc (uint16_t *length); 
    117          static uint8_t  USBD_AUDIO_DataIn (USBD_HandleTypeDef *pdev, uint8_t epnum); 
    118          static uint8_t  USBD_AUDIO_DataOut (USBD_HandleTypeDef *pdev, uint8_t epnum); 
    119          static uint8_t  USBD_AUDIO_EP0_RxReady (USBD_HandleTypeDef *pdev); 
    120          static uint8_t  USBD_AUDIO_EP0_TxReady (USBD_HandleTypeDef *pdev); 
    121          static uint8_t  USBD_AUDIO_SOF (USBD_HandleTypeDef *pdev); 
    122          static uint8_t  USBD_AUDIO_IsoINIncomplete (USBD_HandleTypeDef *pdev, uint8_t epnum); 
    123          static uint8_t  USBD_AUDIO_IsoOutIncomplete (USBD_HandleTypeDef *pdev, uint8_t epnum); 
    124          static void AUDIO_REQ_GetCurrent(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req);
    125          static void AUDIO_REQ_SetCurrent(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req);
    126          static void AUDIO_REQ_GetMaximum(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req);
    127          static void AUDIO_REQ_GetMinimum(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req);
    128          static void AUDIO_REQ_GetResolution(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req);
    129          
    130          /**
    131          * @}
    132          */ 
    133          
    134          /** @defgroup USBD_AUDIO_Private_Variables
    135          * @{
    136          */ 
    137          /* This dummy buffer with 0 values will be sent when there is no availble data */
    138          static uint8_t IsocInBuffDummy[48*4*2]; 
    139          static  int16_t VOL_CUR;
    140          static USBD_AUDIO_HandleTypeDef haudioInstance;
    141          

   \                                 In section .data, align 4
    142          USBD_ClassTypeDef  USBD_AUDIO = 
   \                     USBD_AUDIO:
   \   00000000   0x........         DC32 USBD_AUDIO_Init, USBD_AUDIO_DeInit, USBD_AUDIO_Setup
   \              0x........   
   \              0x........   
   \   0000000C   0x........         DC32 USBD_AUDIO_EP0_TxReady, USBD_AUDIO_EP0_RxReady, USBD_AUDIO_DataIn
   \              0x........   
   \              0x........   
   \   00000018   0x........         DC32 USBD_AUDIO_DataOut, USBD_AUDIO_SOF, USBD_AUDIO_IsoINIncomplete
   \              0x........   
   \              0x........   
   \   00000024   0x........         DC32 USBD_AUDIO_IsoOutIncomplete, USBD_AUDIO_GetCfgDesc
   \              0x........   
   \   0000002C   0x........         DC32 USBD_AUDIO_GetCfgDesc, USBD_AUDIO_GetCfgDesc
   \              0x........   
   \   00000034   0x........         DC32 USBD_AUDIO_GetDeviceQualifierDesc

   \                                 In section .bss, align 4
   \                     haudioInstance:
   \   00000000                      DS8 100
   \   00000064                      DS8 120
   \   000000DC                      DS8 2
   \   000000DE                      DS8 2
   \   000000E0                      DS8 384
    143          {
    144            USBD_AUDIO_Init,
    145            USBD_AUDIO_DeInit,
    146            USBD_AUDIO_Setup,
    147            USBD_AUDIO_EP0_TxReady,  
    148            USBD_AUDIO_EP0_RxReady,
    149            USBD_AUDIO_DataIn,
    150            USBD_AUDIO_DataOut,
    151            USBD_AUDIO_SOF,
    152            USBD_AUDIO_IsoINIncomplete,
    153            USBD_AUDIO_IsoOutIncomplete,      
    154            USBD_AUDIO_GetCfgDesc,
    155            USBD_AUDIO_GetCfgDesc, 
    156            USBD_AUDIO_GetCfgDesc,
    157            USBD_AUDIO_GetDeviceQualifierDesc,
    158          };
    159          
    160          /* USB AUDIO device Configuration Descriptor */
    161          /* NOTE: This descriptor has to be filled using the Descriptor Initialization function */
    162          __ALIGN_BEGIN static uint8_t USBD_AUDIO_CfgDesc[USB_AUDIO_CONFIG_DESC_SIZ + 9] __ALIGN_END;
    163          
    164          /* USB Standard Device Descriptor */

   \                                 In section .data, align 4
    165          __ALIGN_BEGIN static uint8_t USBD_AUDIO_DeviceQualifierDesc[USB_LEN_DEV_QUALIFIER_DESC] __ALIGN_END=
   \                     USBD_AUDIO_DeviceQualifierDesc:
   \   00000000   0x0A 0x06          DC8 10, 6, 0, 2, 0, 0, 0, 64, 1, 0, 0, 0
   \              0x00 0x02    
   \              0x00 0x00    
   \              0x00 0x40    
   \              0x01 0x00    
   \              0x00 0x00    
    166          {
    167            USB_LEN_DEV_QUALIFIER_DESC,
    168            USB_DESC_TYPE_DEVICE_QUALIFIER,
    169            0x00,
    170            0x02,
    171            0x00,
    172            0x00,
    173            0x00,
    174            0x40,
    175            0x01,
    176            0x00,
    177          };
    178          
    179          /**
    180          * @}
    181          */ 
    182          
    183          /** @defgroup USBD_AUDIO_IN_Private_Functions
    184          * @{
    185          */ 
    186          
    187          /**
    188          * @brief  USBD_AUDIO_Init
    189          *         Initialize the AUDIO interface
    190          * @param  pdev: device instance
    191          * @param  cfgidx: Configuration index
    192          * @retval status
    193          */
    194          

   \                                 In section .text, align 2, keep-with-next
    195          static uint8_t  USBD_AUDIO_Init (USBD_HandleTypeDef *pdev, 
    196                                           uint8_t cfgidx)
    197          {
   \                     USBD_AUDIO_Init: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
    198            if(haudioInstance.state!=STATE_USB_WAITING_FOR_INIT)
   \   00000002   0x.... 0x....      LDR.W    R5,??DataTable8
   \   00000006   0x4604             MOV      R4,R0
   \   00000008   0x7D28             LDRB     R0,[R5, #+20]
   \   0000000A   0xB108             CBZ.N    R0,??USBD_AUDIO_Init_0
    199            {
    200              return USBD_FAIL; 
   \   0000000C   0x2002             MOVS     R0,#+2
   \   0000000E   0xBD70             POP      {R4-R6,PC}
    201            }
    202            
    203            USBD_AUDIO_HandleTypeDef   *haudio;
    204            pdev->pClassData = &haudioInstance;
   \                     ??USBD_AUDIO_Init_0: (+1)
   \   00000010   0xF8C4 0x5218      STR      R5,[R4, #+536]
    205            haudio = (USBD_AUDIO_HandleTypeDef *)pdev->pClassData;
    206            uint16_t packet_dim = haudio->paketDimension;
    207            uint16_t wr_rd_offset = (AUDIO_IN_PACKET_NUM/2) * haudio->dataAmount / haudio->paketDimension;
    208            haudio->wr_ptr=wr_rd_offset * packet_dim;
   \   00000014   0x8A29             LDRH     R1,[R5, #+16]
   \   00000016   0x8A68             LDRH     R0,[R5, #+18]
   \   00000018   0xEB01 0x0141      ADD      R1,R1,R1, LSL #+1
   \   0000001C   0x4606             MOV      R6,R0
   \   0000001E   0xFB91 0xF0F0      SDIV     R0,R1,R0
   \   00000022   0xFB10 0xF006      SMULBB   R0,R0,R6
    209            haudio->rd_ptr = 0;
    210            haudio->timeout = 0;
    211            
    212            ((USBD_AUDIO_ItfTypeDef *)pdev->pUserData)->Init(haudio->frequency,0,haudio->channels);
   \   00000026   0x2100             MOVS     R1,#+0
   \   00000028   0x8328             STRH     R0,[R5, #+24]
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0x82E8             STRH     R0,[R5, #+22]
   \   0000002E   0x81A8             STRH     R0,[R5, #+12]
   \   00000030   0xF8D4 0x321C      LDR      R3,[R4, #+540]
   \   00000034   0x792A             LDRB     R2,[R5, #+4]
   \   00000036   0x68A8             LDR      R0,[R5, #+8]
   \   00000038   0x681B             LDR      R3,[R3, #+0]
   \   0000003A   0x4798             BLX      R3
    213            
    214            USBD_LL_OpenEP(pdev,
    215                           AUDIO_IN_EP,
    216                           USBD_EP_TYPE_ISOC,
    217                           AUDIO_IN_PACKET);
   \   0000003C   0xF44F 0x7348      MOV      R3,#+800
   \   00000040   0x2201             MOVS     R2,#+1
   \   00000042   0x2181             MOVS     R1,#+129
   \   00000044   0x4620             MOV      R0,R4
   \   00000046   0x.... 0x....      BL       USBD_LL_OpenEP
    218            
    219            USBD_LL_FlushEP(pdev, AUDIO_IN_EP);
   \   0000004A   0x2181             MOVS     R1,#+129
   \   0000004C   0x4620             MOV      R0,R4
   \   0000004E   0x.... 0x....      BL       USBD_LL_FlushEP
    220            
    221            
    222            USBD_LL_Transmit(pdev, AUDIO_IN_EP,
    223                             IsocInBuffDummy,                        
    224                             packet_dim);      
   \   00000052   0x4633             MOV      R3,R6
   \   00000054   0xF105 0x02E0      ADD      R2,R5,#+224
   \   00000058   0x2181             MOVS     R1,#+129
   \   0000005A   0x4620             MOV      R0,R4
   \   0000005C   0x.... 0x....      BL       USBD_LL_Transmit
    225            
    226            haudio->state=STATE_USB_IDLE;
   \   00000060   0x2001             MOVS     R0,#+1
   \   00000062   0x7528             STRB     R0,[R5, #+20]
    227            return USBD_OK;
   \   00000064   0x2000             MOVS     R0,#+0
   \   00000066   0xBD70             POP      {R4-R6,PC}       ;; return
    228          }
    229          
    230          /**
    231          * @brief  USBD_AUDIO_Init
    232          *         DeInitialize the AUDIO layer
    233          * @param  pdev: device instance
    234          * @param  cfgidx: Configuration index
    235          * @retval status
    236          */

   \                                 In section .text, align 2, keep-with-next
    237          static uint8_t  USBD_AUDIO_DeInit (USBD_HandleTypeDef *pdev, 
    238                                             uint8_t cfgidx)
    239          {
   \                     USBD_AUDIO_DeInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    240            /* Close EP IN */
    241            USBD_LL_CloseEP(pdev,AUDIO_IN_EP);  
   \   00000004   0x2181             MOVS     R1,#+129
   \   00000006   0x.... 0x....      BL       USBD_LL_CloseEP
    242            /* DeInit  physical Interface components */
    243            if(pdev->pClassData != NULL)
   \   0000000A   0xF8D4 0x0218      LDR      R0,[R4, #+536]
   \   0000000E   0xB140             CBZ.N    R0,??USBD_AUDIO_DeInit_0
    244            {
    245              ((USBD_AUDIO_ItfTypeDef *)pdev->pUserData)->DeInit(0);
   \   00000010   0xF8D4 0x121C      LDR      R1,[R4, #+540]
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0x6849             LDR      R1,[R1, #+4]
   \   00000018   0x4788             BLX      R1
    246              haudioInstance.state = STATE_USB_WAITING_FOR_INIT; 
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0x.... 0x....      LDR.W    R1,??DataTable8
   \   00000020   0x7508             STRB     R0,[R1, #+20]
    247            }
    248            return USBD_OK;
   \                     ??USBD_AUDIO_DeInit_0: (+1)
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0xBD10             POP      {R4,PC}          ;; return
    249          }
    250          
    251          /**
    252          * @brief  USBD_AUDIO_Setup
    253          *         Handle the AUDIO specific requests
    254          * @param  pdev: instance
    255          * @param  req: usb requests
    256          * @retval status
    257          */

   \                                 In section .text, align 2, keep-with-next
    258          static uint8_t  USBD_AUDIO_Setup (USBD_HandleTypeDef *pdev, 
    259                                            USBD_SetupReqTypedef *req)
    260          {
   \                     USBD_AUDIO_Setup: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0x460C             MOV      R4,R1
   \   00000004   0xB081             SUB      SP,SP,#+4
    261            USBD_AUDIO_HandleTypeDef   *haudio;
    262            uint16_t len;
    263            uint8_t *pbuf;
    264            uint8_t ret = USBD_OK;
    265            haudio = pdev->pClassData;
   \   00000006   0xF8D0 0x5218      LDR      R5,[R0, #+536]
    266            
    267            switch (req->bmRequest & USB_REQ_TYPE_MASK)
   \   0000000A   0x7821             LDRB     R1,[R4, #+0]
   \   0000000C   0xF011 0x0160      ANDS     R1,R1,#0x60
   \   00000010   0xD049             BEQ.N    ??USBD_AUDIO_Setup_0
   \   00000012   0x2920             CMP      R1,#+32
   \   00000014   0xD168             BNE.N    ??USBD_AUDIO_Setup_1
    268            {
    269              /* AUDIO Class Requests -------------------------------*/
    270            case USB_REQ_TYPE_CLASS :    
    271              switch (req->bRequest)
   \   00000016   0x7861             LDRB     R1,[R4, #+1]
   \   00000018   0x2901             CMP      R1,#+1
   \   0000001A   0xD016             BEQ.N    ??USBD_AUDIO_Setup_2
   \   0000001C   0x2981             CMP      R1,#+129
   \   0000001E   0xD006             BEQ.N    ??USBD_AUDIO_Setup_3
   \   00000020   0x2982             CMP      R1,#+130
   \   00000022   0xD023             BEQ.N    ??USBD_AUDIO_Setup_4
   \   00000024   0x2983             CMP      R1,#+131
   \   00000026   0xD029             BEQ.N    ??USBD_AUDIO_Setup_5
   \   00000028   0x2984             CMP      R1,#+132
   \   0000002A   0xD02E             BEQ.N    ??USBD_AUDIO_Setup_6
   \   0000002C   0xE035             B.N      ??USBD_AUDIO_Setup_7
    272              {
    273              case AUDIO_REQ_GET_CUR:
    274                AUDIO_REQ_GetCurrent(pdev, req);
   \                     ??USBD_AUDIO_Setup_3: (+1)
   \   0000002E   0x.... 0x....      LDR.W    R1,??DataTable8
   \   00000032   0xF8B1 0x20DC      LDRH     R2,[R1, #+220]
   \   00000036   0x776A             STRB     R2,[R5, #+29]
   \   00000038   0xF9B1 0x10DC      LDRSH    R1,[R1, #+220]
   \   0000003C   0x0409             LSLS     R1,R1,#+16
   \   0000003E   0x0E09             LSRS     R1,R1,#+24
   \   00000040   0x77A9             STRB     R1,[R5, #+30]
   \   00000042   0x88E2             LDRH     R2,[R4, #+6]
   \   00000044   0xF105 0x011D      ADD      R1,R5,#+29
   \   00000048   0xE042             B.N      ??USBD_AUDIO_Setup_8
    275                break;
    276                
    277              case AUDIO_REQ_SET_CUR:
    278                AUDIO_REQ_SetCurrent(pdev, req);   
   \                     ??USBD_AUDIO_Setup_2: (+1)
   \   0000004A   0x88E2             LDRH     R2,[R4, #+6]
   \   0000004C   0x2A00             CMP      R2,#+0
   \   0000004E   0xD04B             BEQ.N    ??USBD_AUDIO_Setup_1
   \   00000050   0x.... 0x....      LDR.W    R1,??DataTable8_1
   \   00000054   0x.... 0x....      BL       USBD_CtlPrepareRx
   \   00000058   0x2001             MOVS     R0,#+1
   \   0000005A   0x7728             STRB     R0,[R5, #+28]
   \   0000005C   0x88E0             LDRH     R0,[R4, #+6]
   \   0000005E   0xF885 0x005D      STRB     R0,[R5, #+93]
   \   00000062   0x88A0             LDRH     R0,[R4, #+4]
   \   00000064   0x0A00             LSRS     R0,R0,#+8
   \   00000066   0xF885 0x005E      STRB     R0,[R5, #+94]
   \   0000006A   0xE03D             B.N      ??USBD_AUDIO_Setup_1
    279                break;
    280                
    281              case AUDIO_REQ_GET_MIN:
    282                AUDIO_REQ_GetMinimum(pdev, req);
   \                     ??USBD_AUDIO_Setup_4: (+1)
   \   0000006C   0x21E0             MOVS     R1,#+224
   \   0000006E   0x7769             STRB     R1,[R5, #+29]
   \   00000070   0x21DB             MOVS     R1,#+219
   \   00000072   0x77A9             STRB     R1,[R5, #+30]
   \   00000074   0x88E2             LDRH     R2,[R4, #+6]
   \   00000076   0xF105 0x011D      ADD      R1,R5,#+29
   \   0000007A   0xE029             B.N      ??USBD_AUDIO_Setup_8
    283                break;
    284                
    285              case AUDIO_REQ_GET_MAX:
    286                AUDIO_REQ_GetMaximum(pdev, req);
   \                     ??USBD_AUDIO_Setup_5: (+1)
   \   0000007C   0x2100             MOVS     R1,#+0
   \   0000007E   0x7769             STRB     R1,[R5, #+29]
   \   00000080   0x77A9             STRB     R1,[R5, #+30]
   \   00000082   0x88E2             LDRH     R2,[R4, #+6]
   \   00000084   0xF105 0x011D      ADD      R1,R5,#+29
   \   00000088   0xE022             B.N      ??USBD_AUDIO_Setup_8
    287                break;
    288                
    289              case AUDIO_REQ_GET_RES:
    290                AUDIO_REQ_GetResolution(pdev, req);
   \                     ??USBD_AUDIO_Setup_6: (+1)
   \   0000008A   0x2123             MOVS     R1,#+35
   \   0000008C   0x7769             STRB     R1,[R5, #+29]
   \   0000008E   0x2100             MOVS     R1,#+0
   \   00000090   0x77A9             STRB     R1,[R5, #+30]
   \   00000092   0x88E2             LDRH     R2,[R4, #+6]
   \   00000094   0xF105 0x011D      ADD      R1,R5,#+29
   \   00000098   0xE01A             B.N      ??USBD_AUDIO_Setup_8
    291                break;
    292                
    293              default:
    294                USBD_CtlError (pdev, req);
   \                     ??USBD_AUDIO_Setup_7: (+1)
   \   0000009A   0x4621             MOV      R1,R4
   \   0000009C   0x.... 0x....      BL       USBD_CtlError
    295                return USBD_FAIL;
   \   000000A0   0x2002             MOVS     R0,#+2
   \   000000A2   0xB001             ADD      SP,SP,#+4
   \   000000A4   0xBD30             POP      {R4,R5,PC}
    296              }
    297              break; 
    298              
    299              /* Standard Requests -------------------------------*/
    300            case USB_REQ_TYPE_STANDARD:
    301              switch (req->bRequest)
   \                     ??USBD_AUDIO_Setup_0: (+1)
   \   000000A6   0x7861             LDRB     R1,[R4, #+1]
   \   000000A8   0x2906             CMP      R1,#+6
   \   000000AA   0xD004             BEQ.N    ??USBD_AUDIO_Setup_9
   \   000000AC   0x290A             CMP      R1,#+10
   \   000000AE   0xD00D             BEQ.N    ??USBD_AUDIO_Setup_10
   \   000000B0   0x290B             CMP      R1,#+11
   \   000000B2   0xD010             BEQ.N    ??USBD_AUDIO_Setup_11
   \   000000B4   0xE018             B.N      ??USBD_AUDIO_Setup_1
    302              {
    303              case USB_REQ_GET_DESCRIPTOR: 
    304                if( (req->wValue >> 8) == AUDIO_DESCRIPTOR_TYPE)
   \                     ??USBD_AUDIO_Setup_9: (+1)
   \   000000B6   0x8861             LDRH     R1,[R4, #+2]
   \   000000B8   0x0A09             LSRS     R1,R1,#+8
   \   000000BA   0x2921             CMP      R1,#+33
   \   000000BC   0xD114             BNE.N    ??USBD_AUDIO_Setup_1
    305                {
    306                  
    307                  pbuf = USBD_AUDIO_CfgDesc + 18;
    308                  len = MIN(USB_AUDIO_DESC_SIZ , req->wLength);   
   \   000000BE   0x88E2             LDRH     R2,[R4, #+6]
    309                  
    310                  USBD_CtlSendData (pdev, 
    311                                    pbuf,
    312                                    len);
   \   000000C0   0x.... 0x....      LDR.W    R1,??DataTable8_2
   \   000000C4   0x2A0A             CMP      R2,#+10
   \   000000C6   0xBFA8             IT       GE 
   \   000000C8   0x2209             MOVGE    R2,#+9
   \   000000CA   0xE001             B.N      ??USBD_AUDIO_Setup_8
    313                }
    314                break;
    315                
    316              case USB_REQ_GET_INTERFACE :
    317                USBD_CtlSendData (pdev,
    318                                  (uint8_t *)haudio->alt_setting,
    319                                  1);
   \                     ??USBD_AUDIO_Setup_10: (+1)
   \   000000CC   0x2201             MOVS     R2,#+1
   \   000000CE   0x6829             LDR      R1,[R5, #+0]
   \                     ??USBD_AUDIO_Setup_8: (+1)
   \   000000D0   0x.... 0x....      BL       USBD_CtlSendData
    320                break;
   \   000000D4   0xE008             B.N      ??USBD_AUDIO_Setup_1
    321                
    322              case USB_REQ_SET_INTERFACE :
    323                if ((uint8_t)(req->wValue) < USBD_MAX_NUM_INTERFACES)
   \                     ??USBD_AUDIO_Setup_11: (+1)
   \   000000D6   0x8861             LDRH     R1,[R4, #+2]
   \   000000D8   0xB2CA             UXTB     R2,R1
   \   000000DA   0x2A02             CMP      R2,#+2
   \   000000DC   0xBFB9             ITTEE    LT 
    324                {
    325                  haudio->alt_setting = (uint8_t)(req->wValue);
   \   000000DE   0xB2C9             UXTBLT   R1,R1
   \   000000E0   0x6029             STRLT    R1,[R5, #+0]
    326                }
    327                else
    328                {
    329                  /* Call the error management function (command will be nacked */
    330                  USBD_CtlError (pdev, req);
   \   000000E2   0x4621             MOVGE    R1,R4
   \   000000E4   0x.... 0x....      BLGE     USBD_CtlError
    331                }
    332                break;
    333              }
    334            }
    335            return ret;
   \                     ??USBD_AUDIO_Setup_1: (+1)
   \   000000E8   0x2000             MOVS     R0,#+0
   \   000000EA   0xB001             ADD      SP,SP,#+4
   \   000000EC   0xBD30             POP      {R4,R5,PC}       ;; return
    336          }
    337          
    338          /**
    339          * @brief  USBD_AUDIO_GetCfgDesc 
    340          *         return configuration descriptor
    341          * @param  length : pointer data length
    342          * @retval pointer to descriptor buffer
    343          */

   \                                 In section .text, align 2, keep-with-next
    344          static uint8_t  *USBD_AUDIO_GetCfgDesc (uint16_t *length)
    345          {
    346            *length = sizeof (USBD_AUDIO_CfgDesc);
   \                     USBD_AUDIO_GetCfgDesc: (+1)
   \   00000000   0x2176             MOVS     R1,#+118
   \   00000002   0x8001             STRH     R1,[R0, #+0]
    347            return USBD_AUDIO_CfgDesc;
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable8_3
   \   00000008   0x4770             BX       LR               ;; return
    348          }
    349          
    350          /**
    351          * @brief  USBD_AUDIO_DataIn
    352          *         handle data IN Stage
    353          * @param  pdev: device instance
    354          * @param  epnum: endpoint index
    355          * @retval status
    356          */

   \                                 In section .text, align 2, keep-with-next
    357          static uint8_t USBD_AUDIO_DataIn (USBD_HandleTypeDef *pdev,
    358                                            uint8_t epnum)
    359          {
   \                     USBD_AUDIO_DataIn: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0x4681             MOV      R9,R0
    360            
    361            USBD_AUDIO_HandleTypeDef   *haudio;
    362            haudio = pdev->pClassData;
    363            uint32_t length_usb_pck;
    364            uint16_t app;
    365            uint16_t IsocInWr_app = haudio->wr_ptr;
    366            uint16_t true_dim = haudio->buffer_length;
    367            uint16_t packet_dim = haudio->paketDimension;
    368            uint16_t channels = haudio->channels;
    369            length_usb_pck = packet_dim;  
    370            haudio->timeout=0;
   \   00000006   0x2000             MOVS     R0,#+0
    371            if (epnum == (AUDIO_IN_EP & 0x7F))
   \   00000008   0x2901             CMP      R1,#+1
   \   0000000A   0xF8D9 0x5218      LDR      R5,[R9, #+536]
   \   0000000E   0x8A6E             LDRH     R6,[R5, #+18]
   \   00000010   0x8B2C             LDRH     R4,[R5, #+24]
   \   00000012   0x89EF             LDRH     R7,[R5, #+14]
   \   00000014   0xF895 0xA004      LDRB     R10,[R5, #+4]
   \   00000018   0x46B0             MOV      R8,R6
   \   0000001A   0x81A8             STRH     R0,[R5, #+12]
   \   0000001C   0xD150             BNE.N    ??USBD_AUDIO_DataIn_0
    372            {    
    373              if (haudio->state == STATE_USB_IDLE) 
   \   0000001E   0x7D28             LDRB     R0,[R5, #+20]
   \   00000020   0x2801             CMP      R0,#+1
   \   00000022   0xD105             BNE.N    ??USBD_AUDIO_DataIn_1
    374              {
    375                haudio->state=STATE_USB_REQUESTS_STARTED;
   \   00000024   0x2002             MOVS     R0,#+2
   \   00000026   0x7528             STRB     R0,[R5, #+20]
    376                ((USBD_AUDIO_ItfTypeDef *)pdev->pUserData)->Record();      
   \   00000028   0xF8D9 0x021C      LDR      R0,[R9, #+540]
   \   0000002C   0x6880             LDR      R0,[R0, #+8]
   \   0000002E   0x4780             BLX      R0
    377              }    
    378              if (haudio->state == STATE_USB_BUFFER_WRITE_STARTED)   
   \                     ??USBD_AUDIO_DataIn_1: (+1)
   \   00000030   0x7D28             LDRB     R0,[R5, #+20]
   \   00000032   0x2803             CMP      R0,#+3
   \   00000034   0xD13D             BNE.N    ??USBD_AUDIO_DataIn_2
    379              {      
    380                haudio->rd_ptr = haudio->rd_ptr % (true_dim);              
   \   00000036   0x8AE8             LDRH     R0,[R5, #+22]
   \   00000038   0xFB90 0xF1F7      SDIV     R1,R0,R7
   \   0000003C   0xFB07 0x0011      MLS      R0,R7,R1,R0
   \   00000040   0x82E8             STRH     R0,[R5, #+22]
    381                if(IsocInWr_app<haudio->rd_ptr){
   \   00000042   0x8AE9             LDRH     R1,[R5, #+22]
   \   00000044   0x4608             MOV      R0,R1
   \   00000046   0x4284             CMP      R4,R0
   \   00000048   0xBFBA             ITTE     LT 
   \   0000004A   0x1A79             SUBLT    R1,R7,R1
   \   0000004C   0x1864             ADDLT    R4,R4,R1
   \   0000004E   0x1A64             SUBGE    R4,R4,R1
    382                  app = ((true_dim) - haudio->rd_ptr) +  IsocInWr_app;
    383                }else{
    384                  app = IsocInWr_app - haudio->rd_ptr;
    385                }        
    386                if(app >= (packet_dim*haudio->upper_treshold)){       
   \   00000050   0x7EA9             LDRB     R1,[R5, #+26]
   \   00000052   0xB2A4             UXTH     R4,R4
   \   00000054   0x4371             MULS     R1,R1,R6
   \   00000056   0x428C             CMP      R4,R1
   \   00000058   0xBFA8             IT       GE 
   \   0000005A   0xEB08 0x084A      ADDGE    R8,R8,R10, LSL #+1
    387                  length_usb_pck += channels*2;
   \   0000005E   0xDA05             BGE.N    ??USBD_AUDIO_DataIn_3
    388                }else if(app <= (packet_dim*haudio->lower_treshold)){
   \   00000060   0x7EE9             LDRB     R1,[R5, #+27]
   \   00000062   0x4371             MULS     R1,R1,R6
   \   00000064   0x42A1             CMP      R1,R4
   \   00000066   0xBFA8             IT       GE 
   \   00000068   0xEBA8 0x084A      SUBGE    R8,R8,R10, LSL #+1
    389                  length_usb_pck -= channels*2;
    390                }     
    391                USBD_LL_Transmit (pdev,AUDIO_IN_EP,
    392                                  (uint8_t*)(&haudio->buffer[haudio->rd_ptr]),
    393                                  length_usb_pck);      
   \                     ??USBD_AUDIO_DataIn_3: (+1)
   \   0000006C   0x6E29             LDR      R1,[R5, #+96]
   \   0000006E   0xFA1F 0xF388      UXTH     R3,R8
   \   00000072   0x1842             ADDS     R2,R0,R1
   \   00000074   0x2181             MOVS     R1,#+129
   \   00000076   0x4648             MOV      R0,R9
   \   00000078   0x.... 0x....      BL       USBD_LL_Transmit
    394                haudio->rd_ptr += length_usb_pck;      
   \   0000007C   0x8AE8             LDRH     R0,[R5, #+22]
    395          
    396                if(app < haudio->buffer_length/10)
   \   0000007E   0x210A             MOVS     R1,#+10
   \   00000080   0x4440             ADD      R0,R8,R0
   \   00000082   0x82E8             STRH     R0,[R5, #+22]
   \   00000084   0x89E8             LDRH     R0,[R5, #+14]
   \   00000086   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \   0000008A   0x4284             CMP      R4,R0
   \   0000008C   0xDA18             BGE.N    ??USBD_AUDIO_DataIn_0
    397                {
    398                  ((USBD_AUDIO_ItfTypeDef *)pdev->pUserData)->Stop();
   \   0000008E   0xF8D9 0x021C      LDR      R0,[R9, #+540]
   \   00000092   0x6940             LDR      R0,[R0, #+20]
   \   00000094   0x4780             BLX      R0
    399                  haudio->state = STATE_USB_IDLE; 
   \   00000096   0x2001             MOVS     R0,#+1
   \   00000098   0x7528             STRB     R0,[R5, #+20]
    400                  haudio->timeout=0;
   \   0000009A   0x2000             MOVS     R0,#+0
   \   0000009C   0x81A8             STRH     R0,[R5, #+12]
    401                  memset(haudio->buffer,0,(haudio->buffer_length + haudio->dataAmount));
   \   0000009E   0x89E8             LDRH     R0,[R5, #+14]
   \   000000A0   0x8A29             LDRH     R1,[R5, #+16]
   \   000000A2   0xFA11 0xF180      UXTAH    R1,R1,R0
   \   000000A6   0x6E28             LDR      R0,[R5, #+96]
   \   000000A8   0x.... 0x....      BL       __aeabi_memclr
    402                }       
    403              }
    404              else 
    405              {      
    406                USBD_LL_Transmit (pdev,AUDIO_IN_EP,
    407                                  IsocInBuffDummy,
    408                                  length_usb_pck);      
    409              }    
    410            }
    411            return USBD_OK;
   \   000000AC   0x2000             MOVS     R0,#+0
   \   000000AE   0xE8BD 0x87F0      POP      {R4-R10,PC}
   \                     ??USBD_AUDIO_DataIn_2: (+1)
   \   000000B2   0x4643             MOV      R3,R8
   \   000000B4   0x.... 0x....      LDR.W    R2,??DataTable8_4
   \   000000B8   0x2181             MOVS     R1,#+129
   \   000000BA   0x4648             MOV      R0,R9
   \   000000BC   0x.... 0x....      BL       USBD_LL_Transmit
   \                     ??USBD_AUDIO_DataIn_0: (+1)
   \   000000C0   0x2000             MOVS     R0,#+0
   \   000000C2   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
    412          }
    413          
    414          /**
    415          * @brief  USBD_AUDIO_EP0_RxReady
    416          *         handle EP0 Rx Ready event
    417          * @param  pdev: device instance
    418          * @retval status
    419          */
    420          

   \                                 In section .text, align 2, keep-with-next
    421          static uint8_t  USBD_AUDIO_EP0_RxReady (USBD_HandleTypeDef *pdev)
    422          {  
   \                     USBD_AUDIO_EP0_RxReady: (+1)
   \   00000000   0x4601             MOV      R1,R0
   \   00000002   0xB510             PUSH     {R4,LR}
    423            USBD_AUDIO_HandleTypeDef   *haudio;
    424            haudio = pdev->pClassData;  
   \   00000004   0xF8D1 0x4218      LDR      R4,[R1, #+536]
    425            if (haudio->control.cmd == AUDIO_REQ_SET_CUR)
   \   00000008   0x7F20             LDRB     R0,[R4, #+28]
   \   0000000A   0x2801             CMP      R0,#+1
   \   0000000C   0xBF04             ITT      EQ 
   \   0000000E   0xF894 0x005E      LDRBEQ   R0,[R4, #+94]
   \   00000012   0x2802             CMPEQ    R0,#+2
    426            {    
    427              if (haudio->control.unit == AUDIO_OUT_STREAMING_CTRL)
   \   00000014   0xD10E             BNE.N    ??USBD_AUDIO_EP0_RxReady_0
    428              {
    429                ((USBD_AUDIO_ItfTypeDef *)pdev->pUserData)->VolumeCtl(VOL_CUR);    
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable8
   \   0000001A   0xF8D1 0x121C      LDR      R1,[R1, #+540]
   \   0000001E   0xF9B0 0x00DC      LDRSH    R0,[R0, #+220]
   \   00000022   0x68C9             LDR      R1,[R1, #+12]
   \   00000024   0x4788             BLX      R1
    430                
    431                haudio->control.cmd = 0;
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0x7720             STRB     R0,[R4, #+28]
    432                haudio->control.len = 0;
   \   0000002A   0xF884 0x005D      STRB     R0,[R4, #+93]
    433                haudio->control.unit = 0;
   \   0000002E   0xF884 0x005E      STRB     R0,[R4, #+94]
    434                haudio->control.data[0]=0;
   \   00000032   0x7760             STRB     R0,[R4, #+29]
    435                haudio->control.data[0]=0;
    436              }
    437            }    
    438            return USBD_OK;
   \                     ??USBD_AUDIO_EP0_RxReady_0: (+1)
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0xBD10             POP      {R4,PC}          ;; return
    439          }
    440          /**
    441          * @brief  USBD_AUDIO_EP0_TxReady
    442          *         handle EP0 TRx Ready event
    443          * @param  pdev: device instance
    444          * @retval status
    445          */

   \                                 In section .text, align 2, keep-with-next
    446          static uint8_t  USBD_AUDIO_EP0_TxReady (USBD_HandleTypeDef *pdev)
    447          {
    448            /* Only OUT control data are processed */
    449            return USBD_OK;
   \                     USBD_AUDIO_EP0_TxReady: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x4770             BX       LR               ;; return
    450          }
    451          /**
    452          * @brief  USBD_AUDIO_SOF
    453          *         handle SOF event
    454          * @param  pdev: device instance
    455          * @retval status
    456          */

   \                                 In section .text, align 2, keep-with-next
    457          static uint8_t  USBD_AUDIO_SOF (USBD_HandleTypeDef *pdev)
    458          {  
    459            return USBD_OK;
   \                     USBD_AUDIO_SOF: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x4770             BX       LR               ;; return
    460          }
    461          
    462          
    463          /**
    464          * @brief  USBD_AUDIO_IsoINIncomplete
    465          *         handle data ISO IN Incomplete event
    466          * @param  pdev: device instance
    467          * @param  epnum: endpoint index
    468          * @retval status
    469          */

   \                                 In section .text, align 2, keep-with-next
    470          static uint8_t  USBD_AUDIO_IsoINIncomplete (USBD_HandleTypeDef *pdev, uint8_t epnum)
    471          {  
    472            return USBD_OK;
   \                     USBD_AUDIO_IsoINIncomplete: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x4770             BX       LR               ;; return
    473          }
    474          /**
    475          * @brief  USBD_AUDIO_IsoOutIncomplete
    476          *         handle data ISO OUT Incomplete event
    477          * @param  pdev: device instance
    478          * @param  epnum: endpoint index
    479          * @retval status
    480          */

   \                                 In section .text, align 2, keep-with-next
    481          static uint8_t  USBD_AUDIO_IsoOutIncomplete (USBD_HandleTypeDef *pdev, uint8_t epnum)
    482          {  
    483            return USBD_OK;
   \                     USBD_AUDIO_IsoOutIncomplete: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x4770             BX       LR               ;; return
    484          }
    485          /**
    486          * @brief  USBD_AUDIO_DataOut
    487          *         handle data OUT Stage
    488          * @param  pdev: device instance
    489          * @param  epnum: endpoint index
    490          * @retval status
    491          */

   \                                 In section .text, align 2, keep-with-next
    492          static uint8_t  USBD_AUDIO_DataOut (USBD_HandleTypeDef *pdev, 
    493                                              uint8_t epnum)
    494          {  
    495            return USBD_OK;
   \                     USBD_AUDIO_DataOut: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x4770             BX       LR               ;; return
    496          }
    497          
    498          /**
    499          * @brief  DeviceQualifierDescriptor 
    500          *         return Device Qualifier descriptor
    501          * @param  length : pointer data length
    502          * @retval pointer to descriptor buffer
    503          */

   \                                 In section .text, align 2, keep-with-next
    504          static uint8_t  *USBD_AUDIO_GetDeviceQualifierDesc (uint16_t *length)
    505          {
    506            *length = sizeof (USBD_AUDIO_DeviceQualifierDesc);
   \                     USBD_AUDIO_GetDeviceQualifierDesc: (+1)
   \   00000000   0x210A             MOVS     R1,#+10
   \   00000002   0x8001             STRH     R1,[R0, #+0]
    507            return USBD_AUDIO_DeviceQualifierDesc;
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable8_5
   \   00000008   0x4770             BX       LR               ;; return
    508          }
    509          
    510          /**
    511          * @brief  AUDIO_REQ_GetMaximum
    512          *         Handles the VOL_MAX Audio control request.
    513          * @param  pdev: instance
    514          * @param  req: setup class request
    515          * @retval status
    516          */
    517          static void AUDIO_REQ_GetMaximum(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req)
    518          {
    519            USBD_AUDIO_HandleTypeDef   *haudio;
    520            haudio = pdev->pClassData;
    521            
    522            (haudio->control.data)[0] = (uint16_t)VOL_MAX & 0xFF;
    523            (haudio->control.data)[1] = ((uint16_t)VOL_MAX & 0xFF00 ) >> 8;
    524            
    525            USBD_CtlSendData (pdev, 
    526                              haudio->control.data,
    527                              req->wLength);  
    528          }
    529          
    530          /**
    531          * @brief  AUDIO_REQ_GetMinimum
    532          *         Handles the VOL_MIN Audio control request.
    533          * @param  pdev: instance
    534          * @param  req: setup class request
    535          * @retval status
    536          */
    537          static void AUDIO_REQ_GetMinimum(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req)
    538          {
    539            USBD_AUDIO_HandleTypeDef   *haudio;
    540            haudio = pdev->pClassData;  
    541            (haudio->control.data)[0] = (uint16_t)VOL_MIN & 0xFF;
    542            (haudio->control.data)[1] = ((uint16_t)VOL_MIN & 0xFF00 ) >> 8;
    543            /* Send the current mute state */
    544            USBD_CtlSendData (pdev, 
    545                              haudio->control.data,
    546                              req->wLength);   
    547          }
    548          
    549          /**
    550          * @brief  AUDIO_Req_GetResolution
    551          *         Handles the VOL_RES Audio control request.
    552          * @param  pdev: instance
    553          * @param  req: setup class request
    554          * @retval status
    555          */
    556          static void AUDIO_REQ_GetResolution(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req)
    557          {
    558            USBD_AUDIO_HandleTypeDef   *haudio;
    559            haudio = pdev->pClassData;  
    560            (haudio->control.data)[0] = (uint16_t)VOL_RES & 0xFF;
    561            (haudio->control.data)[1] = ((uint16_t)VOL_RES & 0xFF00 ) >> 8;  
    562            USBD_CtlSendData (pdev, 
    563                              haudio->control.data,
    564                              req->wLength);
    565          }
    566          
    567          /**
    568          * @brief  AUDIO_Req_GetCurrent
    569          *         Handles the GET_CUR Audio control request.
    570          * @param  pdev: instance
    571          * @param  req: setup class request
    572          * @retval status
    573          */
    574          static void AUDIO_REQ_GetCurrent(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req)
    575          {  
    576            USBD_AUDIO_HandleTypeDef   *haudio;
    577            haudio = pdev->pClassData;
    578            
    579            (haudio->control.data)[0] = (uint16_t)VOL_CUR & 0xFF;
    580            (haudio->control.data)[1] = ((uint16_t)VOL_CUR & 0xFF00 ) >> 8;
    581            
    582            USBD_CtlSendData (pdev, 
    583                              haudio->control.data,
    584                              req->wLength);  
    585          }
    586          
    587          /**
    588          * @brief  AUDIO_Req_SetCurrent
    589          *         Handles the SET_CUR Audio control request.
    590          * @param  pdev: instance
    591          * @param  req: setup class request
    592          * @retval status
    593          */
    594          static void AUDIO_REQ_SetCurrent(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req)
    595          { 
    596            USBD_AUDIO_HandleTypeDef   *haudio;
    597            haudio = pdev->pClassData;  
    598            if (req->wLength)
    599            {
    600              /* Prepare the reception of the buffer over EP0 */
    601              USBD_CtlPrepareRx (pdev,
    602                                 (uint8_t *)&VOL_CUR,
    603                                 req->wLength);
    604              
    605              haudio->control.cmd = AUDIO_REQ_SET_CUR;     /* Set the request value */
    606              haudio->control.len = req->wLength;          /* Set the request data length */
    607              haudio->control.unit = HIBYTE(req->wIndex);  /* Set the request target unit */
    608            }
    609          }
    610          
    611          
    612          /**
    613          * @}
    614          */ 
    615          
    616          /** @defgroup USBD_AUDIO_IN_Exported_Functions
    617          * @{
    618          */ 
    619          
    620          /**
    621          * @brief  USBD_AUDIO_Data_Transfer
    622          *         Fills the USB internal buffer with audio data from user
    623          * @param pdev: device instance
    624          * @param audioData: audio data to be sent via USB
    625          * @param dataAmount: number of PCM samples to be copyed
    626          * @note Depending on the calling frequency, a coherent amount of samples must be passed to 
    627          *       the function. E.g.: assuming a Sampling frequency of 16 KHz and 1 channel, 
    628          *       you can pass 16 PCM samples if the function is called each millisecond, 
    629          *       32 samples if called every 2 milliseconds and so on. 
    630          * @retval status
    631          */

   \                                 In section .text, align 2, keep-with-next
    632          uint8_t  USBD_AUDIO_Data_Transfer(USBD_HandleTypeDef *pdev, int16_t * audioData, uint16_t PCMSamples)
    633          {
   \                     USBD_AUDIO_Data_Transfer: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0x460F             MOV      R7,R1
   \   00000004   0xB081             SUB      SP,SP,#+4
    634            
    635            USBD_AUDIO_HandleTypeDef   *haudio;
    636            haudio = (USBD_AUDIO_HandleTypeDef *)pdev->pClassData;
    637            
    638            if(haudioInstance.state==STATE_USB_WAITING_FOR_INIT){    
   \   00000006   0x.... 0x....      LDR.W    R1,??DataTable8
   \   0000000A   0xF8D0 0x4218      LDR      R4,[R0, #+536]
   \   0000000E   0x7D09             LDRB     R1,[R1, #+20]
   \   00000010   0xB911             CBNZ.N   R1,??USBD_AUDIO_Data_Transfer_0
    639              return USBD_BUSY;    
   \   00000012   0x2001             MOVS     R0,#+1
   \   00000014   0xB001             ADD      SP,SP,#+4
   \   00000016   0xBDF0             POP      {R4-R7,PC}
    640            }  
    641            uint16_t dataAmount = PCMSamples * 2; /*Bytes*/
   \                     ??USBD_AUDIO_Data_Transfer_0: (+1)
   \   00000018   0x0055             LSLS     R5,R2,#+1
    642            uint16_t true_dim = haudio->buffer_length;
    643            uint16_t current_data_Amount = haudio->dataAmount;
    644            uint16_t packet_dim = haudio->paketDimension;
    645            
    646            if(haudio->state==STATE_USB_REQUESTS_STARTED  || current_data_Amount!=dataAmount){   
   \   0000001A   0x7D22             LDRB     R2,[R4, #+20]
   \   0000001C   0xB2AD             UXTH     R5,R5
   \   0000001E   0x89E6             LDRH     R6,[R4, #+14]
   \   00000020   0x8A61             LDRH     R1,[R4, #+18]
   \   00000022   0x2A02             CMP      R2,#+2
   \   00000024   0xD002             BEQ.N    ??USBD_AUDIO_Data_Transfer_1
   \   00000026   0x8A23             LDRH     R3,[R4, #+16]
   \   00000028   0x42AB             CMP      R3,R5
   \   0000002A   0xD02E             BEQ.N    ??USBD_AUDIO_Data_Transfer_2
    647              
    648              /*USB parameters definition, based on the amount of data passed*/
    649              haudio->dataAmount=dataAmount;                  
    650              uint16_t wr_rd_offset = (AUDIO_IN_PACKET_NUM/2) * dataAmount / packet_dim; 
   \                     ??USBD_AUDIO_Data_Transfer_1: (+1)
   \   0000002C   0xEB05 0x0045      ADD      R0,R5,R5, LSL #+1
   \   00000030   0x8225             STRH     R5,[R4, #+16]
   \   00000032   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \   00000036   0xB280             UXTH     R0,R0
    651              haudio->wr_ptr=wr_rd_offset * packet_dim;
   \   00000038   0xFB10 0xF201      SMULBB   R2,R0,R1
   \   0000003C   0x8322             STRH     R2,[R4, #+24]
    652              haudio->rd_ptr = 0;
   \   0000003E   0x2200             MOVS     R2,#+0
   \   00000040   0x82E2             STRH     R2,[R4, #+22]
    653              haudio->upper_treshold = wr_rd_offset + 1;
   \   00000042   0x1C42             ADDS     R2,R0,#+1
    654              haudio->lower_treshold = wr_rd_offset - 1;
   \   00000044   0x1E40             SUBS     R0,R0,#+1
   \   00000046   0x76A2             STRB     R2,[R4, #+26]
   \   00000048   0x76E0             STRB     R0,[R4, #+27]
    655              haudio->buffer_length = (packet_dim * (dataAmount / packet_dim) * AUDIO_IN_PACKET_NUM);
   \   0000004A   0xFB95 0xF0F1      SDIV     R0,R5,R1
   \   0000004E   0xFB11 0xF000      SMULBB   R0,R1,R0
   \   00000052   0xEB00 0x0140      ADD      R1,R0,R0, LSL #+1
   \   00000056   0x0048             LSLS     R0,R1,#+1
   \   00000058   0x81E0             STRH     R0,[R4, #+14]
    656              
    657              /*Memory allocation for data buffer, depending (also) on data amount passed to the transfer function*/
    658              if(haudio->buffer != NULL)
   \   0000005A   0x6E20             LDR      R0,[R4, #+96]
   \   0000005C   0xB108             CBZ.N    R0,??USBD_AUDIO_Data_Transfer_3
    659              {
    660                USBD_free(haudio->buffer);      
   \   0000005E   0x.... 0x....      BL       free
    661              }
    662              haudio->buffer = USBD_malloc(haudio->buffer_length + haudio->dataAmount);
   \                     ??USBD_AUDIO_Data_Transfer_3: (+1)
   \   00000062   0x89E0             LDRH     R0,[R4, #+14]
   \   00000064   0x8A21             LDRH     R1,[R4, #+16]
   \   00000066   0xFA11 0xF080      UXTAH    R0,R1,R0
   \   0000006A   0x.... 0x....      BL       malloc
   \   0000006E   0x6620             STR      R0,[R4, #+96]
    663              if(haudio->buffer == NULL)
   \   00000070   0xB910             CBNZ.N   R0,??USBD_AUDIO_Data_Transfer_4
    664              {
    665                return USBD_FAIL;       
   \   00000072   0x2002             MOVS     R0,#+2
   \   00000074   0xB001             ADD      SP,SP,#+4
   \   00000076   0xBDF0             POP      {R4-R7,PC}
    666              }
    667              memset(haudio->buffer,0,(haudio->buffer_length + haudio->dataAmount));
   \                     ??USBD_AUDIO_Data_Transfer_4: (+1)
   \   00000078   0x89E1             LDRH     R1,[R4, #+14]
   \   0000007A   0x8A22             LDRH     R2,[R4, #+16]
   \   0000007C   0xFA12 0xF181      UXTAH    R1,R2,R1
   \   00000080   0x.... 0x....      BL       __aeabi_memclr
    668              haudio->state=STATE_USB_BUFFER_WRITE_STARTED;
   \   00000084   0x2003             MOVS     R0,#+3
   \   00000086   0x7520             STRB     R0,[R4, #+20]
   \   00000088   0xE027             B.N      ??USBD_AUDIO_Data_Transfer_5
    669              
    670              
    671            }else if(haudio->state==STATE_USB_BUFFER_WRITE_STARTED){
   \                     ??USBD_AUDIO_Data_Transfer_2: (+1)
   \   0000008A   0x2A03             CMP      R2,#+3
   \   0000008C   0xD125             BNE.N    ??USBD_AUDIO_Data_Transfer_5
    672              if(haudio->timeout++==TIMEOUT_VALUE){
   \   0000008E   0xF9B4 0x100C      LDRSH    R1,[R4, #+12]
   \   00000092   0x1C4A             ADDS     R2,R1,#+1
   \   00000094   0x29C8             CMP      R1,#+200
   \   00000096   0x81A2             STRH     R2,[R4, #+12]
   \   00000098   0xD107             BNE.N    ??USBD_AUDIO_Data_Transfer_6
    673                haudio->state=STATE_USB_IDLE;
   \   0000009A   0x2101             MOVS     R1,#+1
   \   0000009C   0x7521             STRB     R1,[R4, #+20]
    674                ((USBD_AUDIO_ItfTypeDef *)pdev->pUserData)->Stop();   
   \   0000009E   0xF8D0 0x021C      LDR      R0,[R0, #+540]
   \   000000A2   0x6940             LDR      R0,[R0, #+20]
   \   000000A4   0x4780             BLX      R0
    675               haudio->timeout=0;
   \   000000A6   0x2000             MOVS     R0,#+0
   \   000000A8   0x81A0             STRH     R0,[R4, #+12]
    676              }
    677              memcpy((uint8_t * )&haudio->buffer[haudio->wr_ptr], (uint8_t *)(audioData), dataAmount);    
   \                     ??USBD_AUDIO_Data_Transfer_6: (+1)
   \   000000AA   0x8B23             LDRH     R3,[R4, #+24]
   \   000000AC   0x6E20             LDR      R0,[R4, #+96]
   \   000000AE   0x462A             MOV      R2,R5
   \   000000B0   0x4639             MOV      R1,R7
   \   000000B2   0x1818             ADDS     R0,R3,R0
   \   000000B4   0x.... 0x....      BL       __aeabi_memcpy
    678              haudio->wr_ptr += dataAmount;
   \   000000B8   0x8B20             LDRH     R0,[R4, #+24]
   \   000000BA   0x1828             ADDS     R0,R5,R0
   \   000000BC   0x8320             STRH     R0,[R4, #+24]
    679              haudio->wr_ptr = haudio->wr_ptr % (true_dim);    
   \   000000BE   0xB280             UXTH     R0,R0
   \   000000C0   0xFB90 0xF1F6      SDIV     R1,R0,R6
   \   000000C4   0xFB06 0x0011      MLS      R0,R6,R1,R0
   \   000000C8   0x8320             STRH     R0,[R4, #+24]
    680              if((haudio->wr_ptr-dataAmount) == 0){
   \   000000CA   0x8B20             LDRH     R0,[R4, #+24]
   \   000000CC   0x1B40             SUBS     R0,R0,R5
   \   000000CE   0xD104             BNE.N    ??USBD_AUDIO_Data_Transfer_5
    681                memcpy((uint8_t *)(((uint8_t *)haudio->buffer)+true_dim),(uint8_t *)haudio->buffer, dataAmount);
   \   000000D0   0x6E21             LDR      R1,[R4, #+96]
   \   000000D2   0x462A             MOV      R2,R5
   \   000000D4   0x1870             ADDS     R0,R6,R1
   \   000000D6   0x.... 0x....      BL       __aeabi_memcpy
    682              }
    683            }
    684            return USBD_OK;  
   \                     ??USBD_AUDIO_Data_Transfer_5: (+1)
   \   000000DA   0x2000             MOVS     R0,#+0
   \   000000DC   0xB001             ADD      SP,SP,#+4
   \   000000DE   0xBDF0             POP      {R4-R7,PC}       ;; return
    685          }
    686          
    687          
    688          /**
    689          * @brief  USBD_AUDIO_RegisterInterface
    690          * @param  fops: Audio interface callback
    691          * @retval status
    692          */

   \                                 In section .text, align 2, keep-with-next
    693          uint8_t  USBD_AUDIO_RegisterInterface  (USBD_HandleTypeDef   *pdev, 
    694                                                  USBD_AUDIO_ItfTypeDef *fops)
    695          {
    696            if(fops != NULL)
   \                     USBD_AUDIO_RegisterInterface: (+1)
   \   00000000   0xB109             CBZ.N    R1,??USBD_AUDIO_RegisterInterface_0
    697            {
    698              pdev->pUserData= fops;
   \   00000002   0xF8C0 0x121C      STR      R1,[R0, #+540]
    699            }
    700            return 0;}
   \                     ??USBD_AUDIO_RegisterInterface_0: (+1)
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x4770             BX       LR               ;; return
    701          
    702          /**
    703          * @brief  Configures the microphone descriptor on the base of the frequency 
    704          *         and channels number informations. These parameters will be used to
    705          *         init the audio engine, trough the USB interface functions.
    706          * @param  samplingFrequency: sampling frequency
    707          * @param  Channels: number of channels
    708          * @retval status
    709          */

   \                                 In section .text, align 2, keep-with-next
    710          void USBD_AUDIO_Init_Microphone_Descriptor(USBD_HandleTypeDef   *pdev, uint32_t samplingFrequency, uint8_t Channels)
    711          {
   \                     USBD_AUDIO_Init_Microphone_Descriptor: (+1)
   \   00000000   0xB4F0             PUSH     {R4-R7}
    712            uint16_t index;
    713            uint8_t AUDIO_CONTROLS;   
    714            USBD_AUDIO_CfgDesc[0] = 0x09;                                                /* bLength */
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable8
   \   00000006   0x2309             MOVS     R3,#+9
   \   00000008   0xF880 0x3064      STRB     R3,[R0, #+100]
    715            USBD_AUDIO_CfgDesc[1] = 0x02;                                                /* bDescriptorType */
   \   0000000C   0x2302             MOVS     R3,#+2
   \   0000000E   0xF880 0x3065      STRB     R3,[R0, #+101]
    716            USBD_AUDIO_CfgDesc[2] = ((USB_AUDIO_CONFIG_DESC_SIZ+Channels-1)&0xff);       /* wTotalLength */
   \   00000012   0xF102 0x036C      ADD      R3,R2,#+108
   \   00000016   0xF880 0x3066      STRB     R3,[R0, #+102]
    717            USBD_AUDIO_CfgDesc[3] = ((USB_AUDIO_CONFIG_DESC_SIZ+Channels-1)>>8);
   \   0000001A   0x4613             MOV      R3,R2
   \   0000001C   0xF103 0x046C      ADD      R4,R3,#+108
   \   00000020   0x0424             LSLS     R4,R4,#+16
   \   00000022   0x0E24             LSRS     R4,R4,#+24
    718            USBD_AUDIO_CfgDesc[4] = 0x02;                                                /* bNumInterfaces */
    719            USBD_AUDIO_CfgDesc[5] = 0x01;                                                /* bConfigurationValue */
    720            USBD_AUDIO_CfgDesc[6] = 0x00;                                                /* iConfiguration */
    721            USBD_AUDIO_CfgDesc[7] = 0x80;                                                /* bmAttributes  BUS Powered*/
    722            USBD_AUDIO_CfgDesc[8] = 0x32;                                                /* bMaxPower = 100 mA*/   
    723            /* USB Microphone Standard interface descriptor */
    724            USBD_AUDIO_CfgDesc[9] = 9;                                                   /* bLength */
    725            USBD_AUDIO_CfgDesc[10] = USB_INTERFACE_DESCRIPTOR_TYPE;                      /* bDescriptorType */
    726            USBD_AUDIO_CfgDesc[11] = 0x00;                                               /* bInterfaceNumber */
    727            USBD_AUDIO_CfgDesc[12] = 0x00;                                               /* bAlternateSetting */
    728            USBD_AUDIO_CfgDesc[13] = 0x00;                                               /* bNumEndpoints */
    729            USBD_AUDIO_CfgDesc[14] = USB_DEVICE_CLASS_AUDIO;                             /* bInterfaceClass */
    730            USBD_AUDIO_CfgDesc[15] = AUDIO_SUBCLASS_AUDIOCONTROL;                        /* bInterfaceSubClass */
    731            USBD_AUDIO_CfgDesc[16] = AUDIO_PROTOCOL_UNDEFINED;                           /* bInterfaceProtocol */
    732            USBD_AUDIO_CfgDesc[17] = 0x00;                                               /* iInterface */   
    733            /* USB Microphone Class-specific AC Interface Descriptor */
    734            USBD_AUDIO_CfgDesc[18] = 9;                                                  /* bLength */
    735            USBD_AUDIO_CfgDesc[19] = AUDIO_INTERFACE_DESCRIPTOR_TYPE;                    /* bDescriptorType */
    736            USBD_AUDIO_CfgDesc[20] = AUDIO_CONTROL_HEADER;                               /* bDescriptorSubtype */
    737            USBD_AUDIO_CfgDesc[21] = 0x00;       /* 1.00 */                              /* bcdADC */
    738            USBD_AUDIO_CfgDesc[22] = 0x01;
    739            USBD_AUDIO_CfgDesc[23] = 0x25+Channels;                                      /* wTotalLength = 37+AUDIO_CHANNELS*/
    740            USBD_AUDIO_CfgDesc[24] = 0x00;
    741            USBD_AUDIO_CfgDesc[25] = 0x01;                                               /* bInCollection */
    742            USBD_AUDIO_CfgDesc[26] = 0x01;                                               /* baInterfaceNr */   
    743            /* USB Microphone Input Terminal Descriptor */
    744            USBD_AUDIO_CfgDesc[27] = AUDIO_INPUT_TERMINAL_DESC_SIZE;                     /* bLength */
    745            USBD_AUDIO_CfgDesc[28] = AUDIO_INTERFACE_DESCRIPTOR_TYPE;                    /* bDescriptorType */
    746            USBD_AUDIO_CfgDesc[29] = AUDIO_CONTROL_INPUT_TERMINAL;                       /* bDescriptorSubtype */
    747            USBD_AUDIO_CfgDesc[30] = 0x01;                                               /* bTerminalID */
    748            USBD_AUDIO_CfgDesc[31] = 0x01;                                               /* wTerminalType AUDIO_TERMINAL_USB_MICROPHONE   0x0201 */
    749            USBD_AUDIO_CfgDesc[32] = 0x02;
    750            USBD_AUDIO_CfgDesc[33] = 0x00;                                               /* bAssocTerminal */
    751            USBD_AUDIO_CfgDesc[34] = Channels;                                           /* bNrChannels */   
   \   00000024   0xF880 0x2086      STRB     R2,[R0, #+134]
   \   00000028   0xF880 0x4067      STRB     R4,[R0, #+103]
   \   0000002C   0x2402             MOVS     R4,#+2
   \   0000002E   0xF880 0x4068      STRB     R4,[R0, #+104]
   \   00000032   0x2401             MOVS     R4,#+1
   \   00000034   0xF880 0x4069      STRB     R4,[R0, #+105]
   \   00000038   0x2400             MOVS     R4,#+0
   \   0000003A   0xF880 0x406A      STRB     R4,[R0, #+106]
   \   0000003E   0x2480             MOVS     R4,#+128
   \   00000040   0xF880 0x406B      STRB     R4,[R0, #+107]
   \   00000044   0x2432             MOVS     R4,#+50
   \   00000046   0xF880 0x406C      STRB     R4,[R0, #+108]
   \   0000004A   0x2409             MOVS     R4,#+9
   \   0000004C   0xF880 0x406D      STRB     R4,[R0, #+109]
   \   00000050   0x2404             MOVS     R4,#+4
   \   00000052   0xF880 0x406E      STRB     R4,[R0, #+110]
   \   00000056   0x2400             MOVS     R4,#+0
   \   00000058   0xF880 0x406F      STRB     R4,[R0, #+111]
   \   0000005C   0xF880 0x4070      STRB     R4,[R0, #+112]
   \   00000060   0xF880 0x4071      STRB     R4,[R0, #+113]
   \   00000064   0x2401             MOVS     R4,#+1
   \   00000066   0xF880 0x4072      STRB     R4,[R0, #+114]
   \   0000006A   0xF880 0x4073      STRB     R4,[R0, #+115]
   \   0000006E   0x2400             MOVS     R4,#+0
   \   00000070   0xF880 0x4074      STRB     R4,[R0, #+116]
   \   00000074   0xF880 0x4075      STRB     R4,[R0, #+117]
   \   00000078   0x2409             MOVS     R4,#+9
   \   0000007A   0xF880 0x4076      STRB     R4,[R0, #+118]
   \   0000007E   0x2424             MOVS     R4,#+36
   \   00000080   0xF880 0x4077      STRB     R4,[R0, #+119]
   \   00000084   0x2401             MOVS     R4,#+1
   \   00000086   0xF880 0x4078      STRB     R4,[R0, #+120]
   \   0000008A   0x2400             MOVS     R4,#+0
   \   0000008C   0xF880 0x4079      STRB     R4,[R0, #+121]
   \   00000090   0x2401             MOVS     R4,#+1
   \   00000092   0xF880 0x407A      STRB     R4,[R0, #+122]
   \   00000096   0xF102 0x0425      ADD      R4,R2,#+37
   \   0000009A   0xF880 0x407B      STRB     R4,[R0, #+123]
   \   0000009E   0x2400             MOVS     R4,#+0
   \   000000A0   0xF880 0x407C      STRB     R4,[R0, #+124]
   \   000000A4   0x2401             MOVS     R4,#+1
   \   000000A6   0xF880 0x407D      STRB     R4,[R0, #+125]
   \   000000AA   0xF880 0x407E      STRB     R4,[R0, #+126]
   \   000000AE   0x240C             MOVS     R4,#+12
   \   000000B0   0xF880 0x407F      STRB     R4,[R0, #+127]
   \   000000B4   0x2424             MOVS     R4,#+36
   \   000000B6   0xF880 0x4080      STRB     R4,[R0, #+128]
   \   000000BA   0x2402             MOVS     R4,#+2
   \   000000BC   0xF880 0x4081      STRB     R4,[R0, #+129]
   \   000000C0   0x2401             MOVS     R4,#+1
   \   000000C2   0xF880 0x4082      STRB     R4,[R0, #+130]
   \   000000C6   0xF880 0x4083      STRB     R4,[R0, #+131]
   \   000000CA   0x2402             MOVS     R4,#+2
   \   000000CC   0xF880 0x4084      STRB     R4,[R0, #+132]
   \   000000D0   0x2400             MOVS     R4,#+0
    752            if(Channels != 2)
   \   000000D2   0x2A02             CMP      R2,#+2
   \   000000D4   0xF880 0x4085      STRB     R4,[R0, #+133]
   \   000000D8   0xD003             BEQ.N    ??USBD_AUDIO_Init_Microphone_Descriptor_0
    753            {
    754              USBD_AUDIO_CfgDesc[35] = 0x00;                                             /* wChannelConfig 0x0000  Mono */
   \   000000DA   0x2500             MOVS     R5,#+0
   \   000000DC   0xF880 0x5087      STRB     R5,[R0, #+135]
    755              USBD_AUDIO_CfgDesc[36] = 0x00;
   \   000000E0   0xE003             B.N      ??USBD_AUDIO_Init_Microphone_Descriptor_1
    756            }
    757            else
    758            {
    759              USBD_AUDIO_CfgDesc[35] = 0x03;                                             /* wChannelConfig 0x0003  Stereo */
   \                     ??USBD_AUDIO_Init_Microphone_Descriptor_0: (+1)
   \   000000E2   0x2503             MOVS     R5,#+3
   \   000000E4   0xF880 0x5087      STRB     R5,[R0, #+135]
    760              USBD_AUDIO_CfgDesc[36] = 0x00;
   \   000000E8   0x2500             MOVS     R5,#+0
   \                     ??USBD_AUDIO_Init_Microphone_Descriptor_1: (+1)
   \   000000EA   0xF880 0x5088      STRB     R5,[R0, #+136]
    761            }   
    762            USBD_AUDIO_CfgDesc[37] = 0x00;                                               /* iChannelNames */
   \   000000EE   0xF880 0x5089      STRB     R5,[R0, #+137]
    763            USBD_AUDIO_CfgDesc[38] = 0x00;                                               /* iTerminal */   
   \   000000F2   0xF880 0x508A      STRB     R5,[R0, #+138]
    764            /* USB Microphone Audio Feature Unit Descriptor */
    765            USBD_AUDIO_CfgDesc[39] = 0x07+Channels+1;                                    /* bLength */
   \   000000F6   0xF102 0x0508      ADD      R5,R2,#+8
   \   000000FA   0xF880 0x508B      STRB     R5,[R0, #+139]
    766            USBD_AUDIO_CfgDesc[40] = AUDIO_INTERFACE_DESCRIPTOR_TYPE;                    /* bDescriptorType */
   \   000000FE   0x2524             MOVS     R5,#+36
   \   00000100   0xF880 0x508C      STRB     R5,[R0, #+140]
    767            USBD_AUDIO_CfgDesc[41] = AUDIO_CONTROL_FEATURE_UNIT;                         /* bDescriptorSubtype */
   \   00000104   0x2506             MOVS     R5,#+6
   \   00000106   0xF880 0x508D      STRB     R5,[R0, #+141]
    768            USBD_AUDIO_CfgDesc[42] = 0x02;                                               /* bUnitID */
   \   0000010A   0x2502             MOVS     R5,#+2
   \   0000010C   0xF880 0x508E      STRB     R5,[R0, #+142]
    769            USBD_AUDIO_CfgDesc[43] = 0x01;                                               /* bSourceID */
   \   00000110   0x2501             MOVS     R5,#+1
   \   00000112   0xF880 0x508F      STRB     R5,[R0, #+143]
    770            USBD_AUDIO_CfgDesc[44] = 0x01;                                               /* bControlSize */   
   \   00000116   0xF880 0x5090      STRB     R5,[R0, #+144]
    771            index = 47;   
   \   0000011A   0x252F             MOVS     R5,#+47
    772            if(Channels == 1)
   \   0000011C   0x2A01             CMP      R2,#+1
   \   0000011E   0xD106             BNE.N    ??USBD_AUDIO_Init_Microphone_Descriptor_2
    773            {
    774              AUDIO_CONTROLS = (0x02);     
    775              USBD_AUDIO_CfgDesc[45] = AUDIO_CONTROLS;
   \   00000120   0x2402             MOVS     R4,#+2
   \   00000122   0xF880 0x4091      STRB     R4,[R0, #+145]
    776              USBD_AUDIO_CfgDesc[46] = 0x00;     
   \   00000126   0x2400             MOVS     R4,#+0
   \   00000128   0xF880 0x4092      STRB     R4,[R0, #+146]
   \   0000012C   0xE036             B.N      ??USBD_AUDIO_Init_Microphone_Descriptor_3
    777            }
    778            else
    779            {
    780              AUDIO_CONTROLS = (0x02);     
    781              USBD_AUDIO_CfgDesc[45] = 0x00;
    782              USBD_AUDIO_CfgDesc[46] = AUDIO_CONTROLS;
   \                     ??USBD_AUDIO_Init_Microphone_Descriptor_2: (+1)
   \   0000012E   0x2502             MOVS     R5,#+2
   \   00000130   0xF880 0x4091      STRB     R4,[R0, #+145]
   \   00000134   0xF880 0x5092      STRB     R5,[R0, #+146]
    783              USBD_AUDIO_CfgDesc[index] = AUDIO_CONTROLS;
   \   00000138   0xF880 0x5093      STRB     R5,[R0, #+147]
    784              index++;
   \   0000013C   0x2530             MOVS     R5,#+48
    785            }   
    786            if(Channels > 2)
   \   0000013E   0x2A03             CMP      R2,#+3
   \   00000140   0xDB05             BLT.N    ??USBD_AUDIO_Init_Microphone_Descriptor_4
    787            {
    788              USBD_AUDIO_CfgDesc[index] = AUDIO_CONTROLS;
   \   00000142   0x2502             MOVS     R5,#+2
   \   00000144   0xF100 0x0630      ADD      R6,R0,#+48
   \   00000148   0xF886 0x5064      STRB     R5,[R6, #+100]
    789              index++;
   \   0000014C   0x2531             MOVS     R5,#+49
    790            }   
    791            if(Channels > 3)
   \                     ??USBD_AUDIO_Init_Microphone_Descriptor_4: (+1)
   \   0000014E   0x2A04             CMP      R2,#+4
   \   00000150   0xDB04             BLT.N    ??USBD_AUDIO_Init_Microphone_Descriptor_5
    792            {
    793              USBD_AUDIO_CfgDesc[index] = AUDIO_CONTROLS;
   \   00000152   0x2602             MOVS     R6,#+2
   \   00000154   0x182F             ADDS     R7,R5,R0
   \   00000156   0xF887 0x6064      STRB     R6,[R7, #+100]
    794              index++;
   \   0000015A   0x1C6D             ADDS     R5,R5,#+1
    795            }   
    796            if(Channels > 4)
   \                     ??USBD_AUDIO_Init_Microphone_Descriptor_5: (+1)
   \   0000015C   0x2A05             CMP      R2,#+5
   \   0000015E   0xDB05             BLT.N    ??USBD_AUDIO_Init_Microphone_Descriptor_6
    797            {
    798              USBD_AUDIO_CfgDesc[index] = AUDIO_CONTROLS;
   \   00000160   0xB2AD             UXTH     R5,R5
   \   00000162   0x2602             MOVS     R6,#+2
   \   00000164   0x182F             ADDS     R7,R5,R0
    799              index++;
   \   00000166   0x1C6D             ADDS     R5,R5,#+1
   \   00000168   0xF887 0x6064      STRB     R6,[R7, #+100]
    800            }   
    801            if(Channels > 5)
   \                     ??USBD_AUDIO_Init_Microphone_Descriptor_6: (+1)
   \   0000016C   0x2A06             CMP      R2,#+6
   \   0000016E   0xDB05             BLT.N    ??USBD_AUDIO_Init_Microphone_Descriptor_7
    802            {
    803              USBD_AUDIO_CfgDesc[index] = AUDIO_CONTROLS;
   \   00000170   0xB2AD             UXTH     R5,R5
   \   00000172   0x2602             MOVS     R6,#+2
   \   00000174   0x182F             ADDS     R7,R5,R0
    804              index++;
   \   00000176   0x1C6D             ADDS     R5,R5,#+1
   \   00000178   0xF887 0x6064      STRB     R6,[R7, #+100]
    805            }   
    806            if(Channels > 6)
   \                     ??USBD_AUDIO_Init_Microphone_Descriptor_7: (+1)
   \   0000017C   0x2A07             CMP      R2,#+7
   \   0000017E   0xDB05             BLT.N    ??USBD_AUDIO_Init_Microphone_Descriptor_8
    807            {
    808              USBD_AUDIO_CfgDesc[index] = AUDIO_CONTROLS;
   \   00000180   0xB2AD             UXTH     R5,R5
   \   00000182   0x2602             MOVS     R6,#+2
   \   00000184   0x182F             ADDS     R7,R5,R0
    809              index++;
   \   00000186   0x1C6D             ADDS     R5,R5,#+1
   \   00000188   0xF887 0x6064      STRB     R6,[R7, #+100]
    810            }   
    811            if(Channels > 7)
   \                     ??USBD_AUDIO_Init_Microphone_Descriptor_8: (+1)
   \   0000018C   0x2A08             CMP      R2,#+8
   \   0000018E   0xDB05             BLT.N    ??USBD_AUDIO_Init_Microphone_Descriptor_3
    812            {
    813              USBD_AUDIO_CfgDesc[index] = AUDIO_CONTROLS;
   \   00000190   0xB2AD             UXTH     R5,R5
   \   00000192   0x2402             MOVS     R4,#+2
   \   00000194   0x182E             ADDS     R6,R5,R0
    814              index++;
   \   00000196   0x1C6D             ADDS     R5,R5,#+1
   \   00000198   0xF886 0x4064      STRB     R4,[R6, #+100]
    815            }   
    816            USBD_AUDIO_CfgDesc[index] = 0x00;                                            /* iTerminal */
   \                     ??USBD_AUDIO_Init_Microphone_Descriptor_3: (+1)
   \   0000019C   0xB2AD             UXTH     R5,R5
   \   0000019E   0x2400             MOVS     R4,#+0
   \   000001A0   0x182E             ADDS     R6,R5,R0
   \   000001A2   0xF886 0x4064      STRB     R4,[R6, #+100]
    817            index++;   
   \   000001A6   0x1C6C             ADDS     R4,R5,#+1
    818            /*USB Microphone Output Terminal Descriptor */
    819            USBD_AUDIO_CfgDesc[index++] = 0x09;                                          /* bLength */
   \   000001A8   0xB2A4             UXTH     R4,R4
   \   000001AA   0x2509             MOVS     R5,#+9
   \   000001AC   0x1826             ADDS     R6,R4,R0
   \   000001AE   0x1C64             ADDS     R4,R4,#+1
   \   000001B0   0xF886 0x5064      STRB     R5,[R6, #+100]
    820            USBD_AUDIO_CfgDesc[index++] = AUDIO_INTERFACE_DESCRIPTOR_TYPE;               /* bDescriptorType */
   \   000001B4   0xB2A4             UXTH     R4,R4
   \   000001B6   0x2524             MOVS     R5,#+36
   \   000001B8   0x1826             ADDS     R6,R4,R0
   \   000001BA   0x1C64             ADDS     R4,R4,#+1
   \   000001BC   0xF886 0x5064      STRB     R5,[R6, #+100]
    821            USBD_AUDIO_CfgDesc[index++] = AUDIO_CONTROL_OUTPUT_TERMINAL;                 /* bDescriptorSubtype */
   \   000001C0   0xB2A4             UXTH     R4,R4
   \   000001C2   0x2503             MOVS     R5,#+3
   \   000001C4   0x1826             ADDS     R6,R4,R0
   \   000001C6   0x1C64             ADDS     R4,R4,#+1
   \   000001C8   0xF886 0x5064      STRB     R5,[R6, #+100]
    822            USBD_AUDIO_CfgDesc[index++] = 0x03;                                          /* bTerminalID */
   \   000001CC   0xB2A4             UXTH     R4,R4
   \   000001CE   0x1826             ADDS     R6,R4,R0
   \   000001D0   0x1C64             ADDS     R4,R4,#+1
   \   000001D2   0xF886 0x5064      STRB     R5,[R6, #+100]
    823            USBD_AUDIO_CfgDesc[index++] = 0x01;                                          /* wTerminalType AUDIO_TERMINAL_USB_STREAMING 0x0101*/
   \   000001D6   0xB2A4             UXTH     R4,R4
   \   000001D8   0x2501             MOVS     R5,#+1
   \   000001DA   0x1826             ADDS     R6,R4,R0
   \   000001DC   0x1C64             ADDS     R4,R4,#+1
   \   000001DE   0xF886 0x5064      STRB     R5,[R6, #+100]
    824            USBD_AUDIO_CfgDesc[index++] = 0x01;
   \   000001E2   0xB2A4             UXTH     R4,R4
   \   000001E4   0x1826             ADDS     R6,R4,R0
   \   000001E6   0x1C64             ADDS     R4,R4,#+1
   \   000001E8   0xF886 0x5064      STRB     R5,[R6, #+100]
    825            USBD_AUDIO_CfgDesc[index++] = 0x00;
   \   000001EC   0xB2A4             UXTH     R4,R4
   \   000001EE   0x2500             MOVS     R5,#+0
   \   000001F0   0x1826             ADDS     R6,R4,R0
   \   000001F2   0x1C64             ADDS     R4,R4,#+1
   \   000001F4   0xF886 0x5064      STRB     R5,[R6, #+100]
    826            USBD_AUDIO_CfgDesc[index++] = 0x02;
   \   000001F8   0xB2A4             UXTH     R4,R4
   \   000001FA   0x2502             MOVS     R5,#+2
   \   000001FC   0x1826             ADDS     R6,R4,R0
   \   000001FE   0x1C64             ADDS     R4,R4,#+1
   \   00000200   0xF886 0x5064      STRB     R5,[R6, #+100]
    827            USBD_AUDIO_CfgDesc[index++] = 0x00;   
   \   00000204   0xB2A4             UXTH     R4,R4
   \   00000206   0x2500             MOVS     R5,#+0
   \   00000208   0x1826             ADDS     R6,R4,R0
   \   0000020A   0x1C64             ADDS     R4,R4,#+1
   \   0000020C   0xF886 0x5064      STRB     R5,[R6, #+100]
    828            /* USB Microphone Standard AS Interface Descriptor - Audio Streaming Zero Bandwith */
    829            /* Interface 1, Alternate Setting 0                                             */
    830            USBD_AUDIO_CfgDesc[index++] = 9;                                             /* bLength */
   \   00000210   0xB2A4             UXTH     R4,R4
   \   00000212   0x2509             MOVS     R5,#+9
   \   00000214   0x1826             ADDS     R6,R4,R0
   \   00000216   0x1C64             ADDS     R4,R4,#+1
   \   00000218   0xF886 0x5064      STRB     R5,[R6, #+100]
    831            USBD_AUDIO_CfgDesc[index++] = USB_INTERFACE_DESCRIPTOR_TYPE;                 /* bDescriptorType */
   \   0000021C   0xB2A4             UXTH     R4,R4
   \   0000021E   0x2504             MOVS     R5,#+4
   \   00000220   0x1826             ADDS     R6,R4,R0
   \   00000222   0x1C64             ADDS     R4,R4,#+1
   \   00000224   0xF886 0x5064      STRB     R5,[R6, #+100]
    832            USBD_AUDIO_CfgDesc[index++] = 0x01;                                          /* bInterfaceNumber */
   \   00000228   0xB2A4             UXTH     R4,R4
   \   0000022A   0x2501             MOVS     R5,#+1
   \   0000022C   0x1826             ADDS     R6,R4,R0
   \   0000022E   0x1C64             ADDS     R4,R4,#+1
   \   00000230   0xF886 0x5064      STRB     R5,[R6, #+100]
    833            USBD_AUDIO_CfgDesc[index++] = 0x00;                                          /* bAlternateSetting */
   \   00000234   0xB2A4             UXTH     R4,R4
   \   00000236   0x2500             MOVS     R5,#+0
   \   00000238   0x1826             ADDS     R6,R4,R0
   \   0000023A   0x1C64             ADDS     R4,R4,#+1
   \   0000023C   0xF886 0x5064      STRB     R5,[R6, #+100]
    834            USBD_AUDIO_CfgDesc[index++] = 0x00;                                          /* bNumEndpoints */
   \   00000240   0xB2A4             UXTH     R4,R4
   \   00000242   0x1826             ADDS     R6,R4,R0
   \   00000244   0x1C64             ADDS     R4,R4,#+1
   \   00000246   0xF886 0x5064      STRB     R5,[R6, #+100]
    835            USBD_AUDIO_CfgDesc[index++] = USB_DEVICE_CLASS_AUDIO;                        /* bInterfaceClass */
   \   0000024A   0xB2A4             UXTH     R4,R4
   \   0000024C   0x2501             MOVS     R5,#+1
   \   0000024E   0x1826             ADDS     R6,R4,R0
   \   00000250   0x1C64             ADDS     R4,R4,#+1
   \   00000252   0xF886 0x5064      STRB     R5,[R6, #+100]
    836            USBD_AUDIO_CfgDesc[index++] = AUDIO_SUBCLASS_AUDIOSTREAMING;                 /* bInterfaceSubClass */
   \   00000256   0xB2A4             UXTH     R4,R4
   \   00000258   0x2502             MOVS     R5,#+2
   \   0000025A   0x1826             ADDS     R6,R4,R0
   \   0000025C   0x1C64             ADDS     R4,R4,#+1
   \   0000025E   0xF886 0x5064      STRB     R5,[R6, #+100]
    837            USBD_AUDIO_CfgDesc[index++] = AUDIO_PROTOCOL_UNDEFINED;                      /* bInterfaceProtocol */
   \   00000262   0xB2A4             UXTH     R4,R4
   \   00000264   0x2500             MOVS     R5,#+0
   \   00000266   0x1826             ADDS     R6,R4,R0
   \   00000268   0x1C64             ADDS     R4,R4,#+1
   \   0000026A   0xF886 0x5064      STRB     R5,[R6, #+100]
    838            USBD_AUDIO_CfgDesc[index++] = 0x00;   
   \   0000026E   0xB2A4             UXTH     R4,R4
   \   00000270   0x1826             ADDS     R6,R4,R0
   \   00000272   0x1C64             ADDS     R4,R4,#+1
   \   00000274   0xF886 0x5064      STRB     R5,[R6, #+100]
    839            /* USB Microphone Standard AS Interface Descriptor - Audio Streaming Operational */
    840            /* Interface 1, Alternate Setting 1                                           */
    841            USBD_AUDIO_CfgDesc[index++] = 9;                                             /* bLength */
   \   00000278   0xB2A4             UXTH     R4,R4
   \   0000027A   0x2509             MOVS     R5,#+9
   \   0000027C   0x1826             ADDS     R6,R4,R0
   \   0000027E   0x1C64             ADDS     R4,R4,#+1
   \   00000280   0xF886 0x5064      STRB     R5,[R6, #+100]
    842            USBD_AUDIO_CfgDesc[index++] = USB_INTERFACE_DESCRIPTOR_TYPE;                 /* bDescriptorType */
   \   00000284   0xB2A4             UXTH     R4,R4
   \   00000286   0x2504             MOVS     R5,#+4
   \   00000288   0x1826             ADDS     R6,R4,R0
   \   0000028A   0x1C64             ADDS     R4,R4,#+1
   \   0000028C   0xF886 0x5064      STRB     R5,[R6, #+100]
    843            USBD_AUDIO_CfgDesc[index++] = 0x01;                                          /* bInterfaceNumber */
   \   00000290   0xB2A4             UXTH     R4,R4
   \   00000292   0x2501             MOVS     R5,#+1
   \   00000294   0x1826             ADDS     R6,R4,R0
   \   00000296   0x1C64             ADDS     R4,R4,#+1
   \   00000298   0xF886 0x5064      STRB     R5,[R6, #+100]
    844            USBD_AUDIO_CfgDesc[index++] = 0x01;                                          /* bAlternateSetting */
   \   0000029C   0xB2A4             UXTH     R4,R4
   \   0000029E   0x1826             ADDS     R6,R4,R0
   \   000002A0   0x1C64             ADDS     R4,R4,#+1
   \   000002A2   0xF886 0x5064      STRB     R5,[R6, #+100]
    845            USBD_AUDIO_CfgDesc[index++] = 0x01;                                          /* bNumEndpoints */
   \   000002A6   0xB2A4             UXTH     R4,R4
   \   000002A8   0x1826             ADDS     R6,R4,R0
   \   000002AA   0x1C64             ADDS     R4,R4,#+1
   \   000002AC   0xF886 0x5064      STRB     R5,[R6, #+100]
    846            USBD_AUDIO_CfgDesc[index++] = USB_DEVICE_CLASS_AUDIO;                        /* bInterfaceClass */
   \   000002B0   0xB2A4             UXTH     R4,R4
   \   000002B2   0x1826             ADDS     R6,R4,R0
   \   000002B4   0x1C64             ADDS     R4,R4,#+1
   \   000002B6   0xF886 0x5064      STRB     R5,[R6, #+100]
    847            USBD_AUDIO_CfgDesc[index++] = AUDIO_SUBCLASS_AUDIOSTREAMING;                 /* bInterfaceSubClass */
   \   000002BA   0xB2A4             UXTH     R4,R4
   \   000002BC   0x2502             MOVS     R5,#+2
   \   000002BE   0x1826             ADDS     R6,R4,R0
   \   000002C0   0x1C64             ADDS     R4,R4,#+1
   \   000002C2   0xF886 0x5064      STRB     R5,[R6, #+100]
    848            USBD_AUDIO_CfgDesc[index++] = AUDIO_PROTOCOL_UNDEFINED;                      /* bInterfaceProtocol */
   \   000002C6   0xB2A4             UXTH     R4,R4
   \   000002C8   0x2500             MOVS     R5,#+0
   \   000002CA   0x1826             ADDS     R6,R4,R0
   \   000002CC   0x1C64             ADDS     R4,R4,#+1
   \   000002CE   0xF886 0x5064      STRB     R5,[R6, #+100]
    849            USBD_AUDIO_CfgDesc[index++] = 0x00;                                          /* iInterface */   
   \   000002D2   0xB2A4             UXTH     R4,R4
   \   000002D4   0x1826             ADDS     R6,R4,R0
   \   000002D6   0x1C64             ADDS     R4,R4,#+1
   \   000002D8   0xF886 0x5064      STRB     R5,[R6, #+100]
    850            /* USB Microphone Audio Streaming Interface Descriptor */
    851            USBD_AUDIO_CfgDesc[index++] = AUDIO_STREAMING_INTERFACE_DESC_SIZE;           /* bLength */
   \   000002DC   0xB2A4             UXTH     R4,R4
   \   000002DE   0x2507             MOVS     R5,#+7
   \   000002E0   0x1826             ADDS     R6,R4,R0
   \   000002E2   0x1C64             ADDS     R4,R4,#+1
   \   000002E4   0xF886 0x5064      STRB     R5,[R6, #+100]
    852            USBD_AUDIO_CfgDesc[index++] = AUDIO_INTERFACE_DESCRIPTOR_TYPE;               /* bDescriptorType */
   \   000002E8   0xB2A4             UXTH     R4,R4
   \   000002EA   0x2524             MOVS     R5,#+36
   \   000002EC   0x1826             ADDS     R6,R4,R0
   \   000002EE   0x1C64             ADDS     R4,R4,#+1
   \   000002F0   0xF886 0x5064      STRB     R5,[R6, #+100]
    853            USBD_AUDIO_CfgDesc[index++] = AUDIO_STREAMING_GENERAL;                       /* bDescriptorSubtype */
   \   000002F4   0xB2A4             UXTH     R4,R4
   \   000002F6   0x2501             MOVS     R5,#+1
   \   000002F8   0x1826             ADDS     R6,R4,R0
   \   000002FA   0x1C64             ADDS     R4,R4,#+1
   \   000002FC   0xF886 0x5064      STRB     R5,[R6, #+100]
    854            USBD_AUDIO_CfgDesc[index++] = 0x03;                                          /* bTerminalLink */
   \   00000300   0xB2A4             UXTH     R4,R4
   \   00000302   0x2503             MOVS     R5,#+3
   \   00000304   0x1826             ADDS     R6,R4,R0
   \   00000306   0x1C64             ADDS     R4,R4,#+1
   \   00000308   0xF886 0x5064      STRB     R5,[R6, #+100]
    855            USBD_AUDIO_CfgDesc[index++] = 0x01;                                          /* bDelay */
   \   0000030C   0xB2A4             UXTH     R4,R4
   \   0000030E   0x2501             MOVS     R5,#+1
   \   00000310   0x1826             ADDS     R6,R4,R0
   \   00000312   0x1C64             ADDS     R4,R4,#+1
   \   00000314   0xF886 0x5064      STRB     R5,[R6, #+100]
    856            USBD_AUDIO_CfgDesc[index++] = 0x01;                                          /* wFormatTag AUDIO_FORMAT_PCM  0x0001*/
   \   00000318   0xB2A4             UXTH     R4,R4
   \   0000031A   0x1826             ADDS     R6,R4,R0
   \   0000031C   0x1C64             ADDS     R4,R4,#+1
   \   0000031E   0xF886 0x5064      STRB     R5,[R6, #+100]
    857            USBD_AUDIO_CfgDesc[index++] = 0x00;                
   \   00000322   0xB2A4             UXTH     R4,R4
   \   00000324   0x2500             MOVS     R5,#+0
   \   00000326   0x1826             ADDS     R6,R4,R0
   \   00000328   0x1C64             ADDS     R4,R4,#+1
   \   0000032A   0xF886 0x5064      STRB     R5,[R6, #+100]
    858            /* USB Microphone Audio Type I Format Interface Descriptor */                
    859            USBD_AUDIO_CfgDesc[index++] = 0x0B;                                          /* bLength */
   \   0000032E   0xB2A4             UXTH     R4,R4
   \   00000330   0x250B             MOVS     R5,#+11
   \   00000332   0x1826             ADDS     R6,R4,R0
   \   00000334   0x1C64             ADDS     R4,R4,#+1
   \   00000336   0xF886 0x5064      STRB     R5,[R6, #+100]
    860            USBD_AUDIO_CfgDesc[index++] = AUDIO_INTERFACE_DESCRIPTOR_TYPE;               /* bDescriptorType */
   \   0000033A   0xB2A4             UXTH     R4,R4
   \   0000033C   0x2524             MOVS     R5,#+36
   \   0000033E   0x1826             ADDS     R6,R4,R0
   \   00000340   0x1C64             ADDS     R4,R4,#+1
   \   00000342   0xF886 0x5064      STRB     R5,[R6, #+100]
    861            USBD_AUDIO_CfgDesc[index++] = AUDIO_STREAMING_FORMAT_TYPE;                   /* bDescriptorSubtype */
   \   00000346   0xB2A4             UXTH     R4,R4
   \   00000348   0x2502             MOVS     R5,#+2
   \   0000034A   0x1826             ADDS     R6,R4,R0
   \   0000034C   0x1C64             ADDS     R4,R4,#+1
   \   0000034E   0xF886 0x5064      STRB     R5,[R6, #+100]
    862            USBD_AUDIO_CfgDesc[index++] = AUDIO_FORMAT_TYPE_I;                           /* bFormatType */
   \   00000352   0xB2A4             UXTH     R4,R4
   \   00000354   0x2501             MOVS     R5,#+1
   \   00000356   0x1826             ADDS     R6,R4,R0
   \   00000358   0x1C64             ADDS     R4,R4,#+1
   \   0000035A   0xF886 0x5064      STRB     R5,[R6, #+100]
    863            USBD_AUDIO_CfgDesc[index++] = Channels;                                      /* bNrChannels */
   \   0000035E   0xB2A4             UXTH     R4,R4
   \   00000360   0x1825             ADDS     R5,R4,R0
   \   00000362   0x1C64             ADDS     R4,R4,#+1
   \   00000364   0xF885 0x2064      STRB     R2,[R5, #+100]
    864            USBD_AUDIO_CfgDesc[index++] = 0x02;                                          /* bSubFrameSize */
   \   00000368   0xB2A4             UXTH     R4,R4
   \   0000036A   0x2502             MOVS     R5,#+2
   \   0000036C   0x1826             ADDS     R6,R4,R0
   \   0000036E   0x1C64             ADDS     R4,R4,#+1
   \   00000370   0xF886 0x5064      STRB     R5,[R6, #+100]
    865            USBD_AUDIO_CfgDesc[index++] = 16;                                            /* bBitResolution */
   \   00000374   0xB2A4             UXTH     R4,R4
   \   00000376   0x2510             MOVS     R5,#+16
   \   00000378   0x1826             ADDS     R6,R4,R0
   \   0000037A   0x1C64             ADDS     R4,R4,#+1
   \   0000037C   0xF886 0x5064      STRB     R5,[R6, #+100]
    866            USBD_AUDIO_CfgDesc[index++] = 0x01;                                           /* bSamFreqType */
   \   00000380   0xB2A4             UXTH     R4,R4
   \   00000382   0x2501             MOVS     R5,#+1
   \   00000384   0x1826             ADDS     R6,R4,R0
   \   00000386   0x1C64             ADDS     R4,R4,#+1
   \   00000388   0xF886 0x5064      STRB     R5,[R6, #+100]
    867            USBD_AUDIO_CfgDesc[index++] = samplingFrequency&0xff;                        /* tSamFreq 8000 = 0x1F40 */
   \   0000038C   0xB2A4             UXTH     R4,R4
   \   0000038E   0x1825             ADDS     R5,R4,R0
   \   00000390   0x1C64             ADDS     R4,R4,#+1
   \   00000392   0xF885 0x1064      STRB     R1,[R5, #+100]
    868            USBD_AUDIO_CfgDesc[index++] = (samplingFrequency>>8)&0xff;
   \   00000396   0xB2A4             UXTH     R4,R4
   \   00000398   0x0A0D             LSRS     R5,R1,#+8
   \   0000039A   0x1826             ADDS     R6,R4,R0
   \   0000039C   0x1C64             ADDS     R4,R4,#+1
   \   0000039E   0xF886 0x5064      STRB     R5,[R6, #+100]
    869            USBD_AUDIO_CfgDesc[index++] = samplingFrequency>>16;   
   \   000003A2   0xB2A4             UXTH     R4,R4
   \   000003A4   0x0C0D             LSRS     R5,R1,#+16
   \   000003A6   0x1826             ADDS     R6,R4,R0
   \   000003A8   0x1C64             ADDS     R4,R4,#+1
   \   000003AA   0xF886 0x5064      STRB     R5,[R6, #+100]
    870            /* Endpoint 1 - Standard Descriptor */
    871            USBD_AUDIO_CfgDesc[index++] =  AUDIO_STANDARD_ENDPOINT_DESC_SIZE;            /* bLength */
   \   000003AE   0xB2A4             UXTH     R4,R4
   \   000003B0   0x2509             MOVS     R5,#+9
   \   000003B2   0x1826             ADDS     R6,R4,R0
   \   000003B4   0x1C64             ADDS     R4,R4,#+1
   \   000003B6   0xF886 0x5064      STRB     R5,[R6, #+100]
    872            USBD_AUDIO_CfgDesc[index++] = 0x05;                                          /* bDescriptorType */
   \   000003BA   0xB2A4             UXTH     R4,R4
   \   000003BC   0x2505             MOVS     R5,#+5
   \   000003BE   0x1826             ADDS     R6,R4,R0
   \   000003C0   0x1C64             ADDS     R4,R4,#+1
   \   000003C2   0xF886 0x5064      STRB     R5,[R6, #+100]
    873            USBD_AUDIO_CfgDesc[index++] = AUDIO_IN_EP;                                   /* bEndpointAddress 1 in endpoint*/
   \   000003C6   0xB2A4             UXTH     R4,R4
   \   000003C8   0x2581             MOVS     R5,#+129
   \   000003CA   0x1826             ADDS     R6,R4,R0
   \   000003CC   0x1C64             ADDS     R4,R4,#+1
   \   000003CE   0xF886 0x5064      STRB     R5,[R6, #+100]
    874            USBD_AUDIO_CfgDesc[index++] = 0x05;                                          /* bmAttributes */
   \   000003D2   0xB2A4             UXTH     R4,R4
   \   000003D4   0x2505             MOVS     R5,#+5
   \   000003D6   0x1826             ADDS     R6,R4,R0
   \   000003D8   0xF886 0x5064      STRB     R5,[R6, #+100]
   \   000003DC   0x1C65             ADDS     R5,R4,#+1
    875            USBD_AUDIO_CfgDesc[index++] = ((samplingFrequency/1000+2)*Channels*2)&0xFF; //(AUDIO_OUT_BUFFER_SIZE*Channels*2+2)&0xFF;// /* wMaxPacketSize */ 
   \   000003DE   0xF44F 0x747A      MOV      R4,#+1000
   \   000003E2   0xB2AD             UXTH     R5,R5
   \   000003E4   0xFBB1 0xF4F4      UDIV     R4,R1,R4
   \   000003E8   0x1CA6             ADDS     R6,R4,#+2
   \   000003EA   0x182F             ADDS     R7,R5,R0
   \   000003EC   0xFB16 0xF602      SMULBB   R6,R6,R2
   \   000003F0   0x1C6D             ADDS     R5,R5,#+1
    876            USBD_AUDIO_CfgDesc[index++] = ((samplingFrequency/1000+2)*Channels*2)>>8;//(AUDIO_OUT_BUFFER_SIZE*Channels*2+2)>>8;// 
   \   000003F2   0xB2AD             UXTH     R5,R5
   \   000003F4   0x0076             LSLS     R6,R6,#+1
   \   000003F6   0xF887 0x6064      STRB     R6,[R7, #+100]
   \   000003FA   0x1CA6             ADDS     R6,R4,#+2
   \   000003FC   0x4356             MULS     R6,R6,R2
   \   000003FE   0x182F             ADDS     R7,R5,R0
   \   00000400   0x1C6D             ADDS     R5,R5,#+1
   \   00000402   0x09F6             LSRS     R6,R6,#+7
   \   00000404   0xF887 0x6064      STRB     R6,[R7, #+100]
    877            USBD_AUDIO_CfgDesc[index++] = 0x01;                                          /* bInterval */
   \   00000408   0x2601             MOVS     R6,#+1
   \   0000040A   0xB2AD             UXTH     R5,R5
   \   0000040C   0x182F             ADDS     R7,R5,R0
   \   0000040E   0x1C6D             ADDS     R5,R5,#+1
   \   00000410   0xF887 0x6064      STRB     R6,[R7, #+100]
    878            USBD_AUDIO_CfgDesc[index++] = 0x00;                                          /* bRefresh */
   \   00000414   0xB2AD             UXTH     R5,R5
   \   00000416   0x2600             MOVS     R6,#+0
   \   00000418   0x182F             ADDS     R7,R5,R0
   \   0000041A   0x1C6D             ADDS     R5,R5,#+1
   \   0000041C   0xF887 0x6064      STRB     R6,[R7, #+100]
    879            USBD_AUDIO_CfgDesc[index++] = 0x00;                                          /* bSynchAddress */   
   \   00000420   0xB2AD             UXTH     R5,R5
   \   00000422   0x182F             ADDS     R7,R5,R0
   \   00000424   0x1C6D             ADDS     R5,R5,#+1
   \   00000426   0xF887 0x6064      STRB     R6,[R7, #+100]
    880            /* Endpoint - Audio Streaming Descriptor*/
    881            USBD_AUDIO_CfgDesc[index++] = AUDIO_STREAMING_ENDPOINT_DESC_SIZE;            /* bLength */
   \   0000042A   0xB2AD             UXTH     R5,R5
   \   0000042C   0x2607             MOVS     R6,#+7
   \   0000042E   0x182F             ADDS     R7,R5,R0
   \   00000430   0x1C6D             ADDS     R5,R5,#+1
   \   00000432   0xF887 0x6064      STRB     R6,[R7, #+100]
    882            USBD_AUDIO_CfgDesc[index++] = AUDIO_ENDPOINT_DESCRIPTOR_TYPE;                /* bDescriptorType */
   \   00000436   0xB2AD             UXTH     R5,R5
   \   00000438   0x2625             MOVS     R6,#+37
   \   0000043A   0x182F             ADDS     R7,R5,R0
   \   0000043C   0x1C6D             ADDS     R5,R5,#+1
   \   0000043E   0xF887 0x6064      STRB     R6,[R7, #+100]
    883            USBD_AUDIO_CfgDesc[index++] = AUDIO_ENDPOINT_GENERAL;                        /* bDescriptor */
   \   00000442   0xB2AD             UXTH     R5,R5
   \   00000444   0x2601             MOVS     R6,#+1
   \   00000446   0x182F             ADDS     R7,R5,R0
   \   00000448   0x1C6D             ADDS     R5,R5,#+1
   \   0000044A   0xF887 0x6064      STRB     R6,[R7, #+100]
    884            USBD_AUDIO_CfgDesc[index++] = 0x00;                                          /* bmAttributes */
   \   0000044E   0xB2AD             UXTH     R5,R5
   \   00000450   0x2600             MOVS     R6,#+0
   \   00000452   0x182F             ADDS     R7,R5,R0
   \   00000454   0x1C6D             ADDS     R5,R5,#+1
   \   00000456   0xF887 0x6064      STRB     R6,[R7, #+100]
    885            USBD_AUDIO_CfgDesc[index++] = 0x00;                                          /* bLockDelayUnits */
   \   0000045A   0xB2AD             UXTH     R5,R5
   \   0000045C   0x182F             ADDS     R7,R5,R0
   \   0000045E   0x1C6D             ADDS     R5,R5,#+1
   \   00000460   0xF887 0x6064      STRB     R6,[R7, #+100]
    886            USBD_AUDIO_CfgDesc[index++] = 0x00;                                          /* wLockDelay */
   \   00000464   0xB2AD             UXTH     R5,R5
   \   00000466   0x182F             ADDS     R7,R5,R0
    887            USBD_AUDIO_CfgDesc[index++] = 0x00;    
   \   00000468   0x1C6D             ADDS     R5,R5,#+1
   \   0000046A   0xB2AD             UXTH     R5,R5
    888              
    889            haudioInstance.paketDimension = (samplingFrequency/1000*Channels*2);//AUDIO_OUT_BUFFER_SIZE*2*Channels;//
   \   0000046C   0xFB14 0xF303      SMULBB   R3,R4,R3
   \   00000470   0xF887 0x6064      STRB     R6,[R7, #+100]
   \   00000474   0x182D             ADDS     R5,R5,R0
   \   00000476   0xF885 0x6064      STRB     R6,[R5, #+100]
   \   0000047A   0x005B             LSLS     R3,R3,#+1
   \   0000047C   0x8243             STRH     R3,[R0, #+18]
    890            haudioInstance.frequency=samplingFrequency;
   \   0000047E   0x6081             STR      R1,[R0, #+8]
    891            haudioInstance.buffer_length = haudioInstance.paketDimension * AUDIO_IN_PACKET_NUM;
   \   00000480   0x8A41             LDRH     R1,[R0, #+18]
    892            haudioInstance.channels=Channels;  
   \   00000482   0x7102             STRB     R2,[R0, #+4]
    893            haudioInstance.upper_treshold = 5;
    894            haudioInstance.lower_treshold = 2;
    895            haudioInstance.state = STATE_USB_WAITING_FOR_INIT;
   \   00000484   0x7506             STRB     R6,[R0, #+20]
   \   00000486   0xEB01 0x0341      ADD      R3,R1,R1, LSL #+1
    896            haudioInstance.wr_ptr = 3 * haudioInstance.paketDimension;
    897            haudioInstance.rd_ptr = 0;  
   \   0000048A   0x82C6             STRH     R6,[R0, #+22]
    898            haudioInstance.dataAmount=0;
   \   0000048C   0x8206             STRH     R6,[R0, #+16]
   \   0000048E   0x0059             LSLS     R1,R3,#+1
    899            haudioInstance.buffer = 0;
   \   00000490   0x6606             STR      R6,[R0, #+96]
   \   00000492   0x81C1             STRH     R1,[R0, #+14]
   \   00000494   0x2105             MOVS     R1,#+5
   \   00000496   0x7681             STRB     R1,[R0, #+26]
   \   00000498   0x2102             MOVS     R1,#+2
   \   0000049A   0x76C1             STRB     R1,[R0, #+27]
   \   0000049C   0x8A41             LDRH     R1,[R0, #+18]
   \   0000049E   0xEB01 0x0141      ADD      R1,R1,R1, LSL #+1
   \   000004A2   0x8301             STRH     R1,[R0, #+24]
    900          }
   \   000004A4   0xBCF0             POP      {R4-R7}
   \   000004A6   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8:
   \   00000000   0x........         DC32     haudioInstance

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_1:
   \   00000000   0x........         DC32     haudioInstance+0xDC

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_2:
   \   00000000   0x........         DC32     haudioInstance+0x76

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_3:
   \   00000000   0x........         DC32     haudioInstance+0x64

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_4:
   \   00000000   0x........         DC32     haudioInstance+0xE0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_5:
   \   00000000   0x........         DC32     USBD_AUDIO_DeviceQualifierDesc
    901          
    902          /**
    903          * @}
    904          */ 
    905          
    906          
    907          /**
    908          * @}
    909          */ 
    910          
    911          
    912          /**
    913          * @}
    914          */ 
    915          
    916          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      32   USBD_AUDIO_DataIn
        32   -- Indirect call
        32   -> USBD_LL_Transmit
        32   -> __aeabi_memclr
       0   USBD_AUDIO_DataOut
      24   USBD_AUDIO_Data_Transfer
        24   -- Indirect call
        24   -> __aeabi_memclr
        24   -> __aeabi_memcpy
        24   -> free
        24   -> malloc
       8   USBD_AUDIO_DeInit
         8   -- Indirect call
         8   -> USBD_LL_CloseEP
       8   USBD_AUDIO_EP0_RxReady
         8   -- Indirect call
       0   USBD_AUDIO_EP0_TxReady
       0   USBD_AUDIO_GetCfgDesc
       0   USBD_AUDIO_GetDeviceQualifierDesc
      16   USBD_AUDIO_Init
        16   -- Indirect call
        16   -> USBD_LL_FlushEP
        16   -> USBD_LL_OpenEP
        16   -> USBD_LL_Transmit
      16   USBD_AUDIO_Init_Microphone_Descriptor
       0   USBD_AUDIO_IsoINIncomplete
       0   USBD_AUDIO_IsoOutIncomplete
       0   USBD_AUDIO_RegisterInterface
       0   USBD_AUDIO_SOF
      16   USBD_AUDIO_Setup
        16   -> USBD_CtlError
        16   -> USBD_CtlPrepareRx
        16   -> USBD_CtlSendData


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable8
       4  ??DataTable8_1
       4  ??DataTable8_2
       4  ??DataTable8_3
       4  ??DataTable8_4
       4  ??DataTable8_5
      56  USBD_AUDIO
     198  USBD_AUDIO_DataIn
       4  USBD_AUDIO_DataOut
     224  USBD_AUDIO_Data_Transfer
      38  USBD_AUDIO_DeInit
      12  USBD_AUDIO_DeviceQualifierDesc
      56  USBD_AUDIO_EP0_RxReady
       4  USBD_AUDIO_EP0_TxReady
      10  USBD_AUDIO_GetCfgDesc
      10  USBD_AUDIO_GetDeviceQualifierDesc
     104  USBD_AUDIO_Init
    1192  USBD_AUDIO_Init_Microphone_Descriptor
       4  USBD_AUDIO_IsoINIncomplete
       4  USBD_AUDIO_IsoOutIncomplete
      10  USBD_AUDIO_RegisterInterface
       4  USBD_AUDIO_SOF
     238  USBD_AUDIO_Setup
     608  haudioInstance
          USBD_AUDIO_CfgDesc
          VOL_CUR
          IsocInBuffDummy

 
   608 bytes in section .bss
    68 bytes in section .data
 2 124 bytes in section .text
 
 2 124 bytes of CODE memory
   676 bytes of DATA memory

Errors: none
Warnings: 1
