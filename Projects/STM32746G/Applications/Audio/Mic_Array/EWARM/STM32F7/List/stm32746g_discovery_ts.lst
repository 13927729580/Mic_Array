###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.2.10312/W32 for ARM       13/Feb/2016  11:44:26
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Drivers\BSP\STM32746G-Discovery\stm32746g_discovery_ts.c
#    Command line =  
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Drivers\BSP\STM32746G-Discovery\stm32746g_discovery_ts.c
#        -D USE_HAL_DRIVER -D STM32F746xx -D USE_STM32746G_DISCO -D
#        USE_IOEXPANDER -D USE_USB_FS -lC
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
#        -lA
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
#        -o
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M7 -e --fpu=VFPv5_sp --dlib_config "D:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.3\arm\INC\c\DLib_Config_Full.h"
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\Inc\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\CMSIS\Device\ST\STM32F7xx\Include\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\STM32F7xx_HAL_Driver\Inc\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\STM32746G-Discovery\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\Components\Common\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Log\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Fonts\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\CPU\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_Device_Library\Core\Inc\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Core\Inc\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Class\MSC\Inc\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\drivers\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_Audio\Addons\PDM\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_Device_Library\Class\AUDIO\Inc\
#        -On --use_c++_inline --require_prototypes -I "D:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.3\arm\CMSIS\Include\" -D
#        ARM_MATH_CM7
#    List file    =  
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List\stm32746g_discovery_ts.lst
#    Object file  =  
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj\stm32746g_discovery_ts.o
#
###############################################################################

H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Drivers\BSP\STM32746G-Discovery\stm32746g_discovery_ts.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32746g_discovery_ts.c
      4            * @author  MCD Application Team
      5            * @version V1.0.0
      6            * @date    25-June-2015
      7            * @brief   This file provides a set of functions needed to manage the Touch 
      8            *          Screen on STM32746G-Discovery board.
      9            @verbatim
     10             1. How To use this driver:
     11             --------------------------
     12                - This driver is used to drive the touch screen module of the STM32746G-Discovery
     13                  board on the RK043FN48H-CT672B 480x272 LCD screen with capacitive touch screen.
     14                - The FT5336 component driver must be included in project files according to
     15                  the touch screen driver present on this board.
     16             
     17             2. Driver description:
     18             ---------------------
     19               + Initialization steps:
     20                  o Initialize the TS module using the BSP_TS_Init() function. This 
     21                    function includes the MSP layer hardware resources initialization and the
     22                    communication layer configuration to start the TS use. The LCD size properties
     23                    (x and y) are passed as parameters.
     24                  o If TS interrupt mode is desired, you must configure the TS interrupt mode
     25                    by calling the function BSP_TS_ITConfig(). The TS interrupt mode is generated
     26                    as an external interrupt whenever a touch is detected. 
     27                    The interrupt mode internally uses the IO functionalities driver driven by
     28                    the IO expander, to configure the IT line.
     29               
     30               + Touch screen use
     31                  o The touch screen state is captured whenever the function BSP_TS_GetState() is 
     32                    used. This function returns information about the last LCD touch occurred
     33                    in the TS_StateTypeDef structure.
     34                  o If TS interrupt mode is used, the function BSP_TS_ITGetStatus() is needed to get
     35                    the interrupt status. To clear the IT pending bits, you should call the 
     36                    function BSP_TS_ITClear().
     37                  o The IT is handled using the corresponding external interrupt IRQ handler,
     38                    the user IT callback treatment is implemented on the same external interrupt
     39                    callback.
     40            @endverbatim
     41            ******************************************************************************
     42            * @attention
     43            *
     44            * <h2><center>&copy; COPYRIGHT(c) 2015 STMicroelectronics</center></h2>
     45            *
     46            * Redistribution and use in source and binary forms, with or without modification,
     47            * are permitted provided that the following conditions are met:
     48            *   1. Redistributions of source code must retain the above copyright notice,
     49            *      this list of conditions and the following disclaimer.
     50            *   2. Redistributions in binary form must reproduce the above copyright notice,
     51            *      this list of conditions and the following disclaimer in the documentation
     52            *      and/or other materials provided with the distribution.
     53            *   3. Neither the name of STMicroelectronics nor the names of its contributors
     54            *      may be used to endorse or promote products derived from this software
     55            *      without specific prior written permission.
     56            *
     57            * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
     58            * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     59            * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     60            * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
     61            * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
     62            * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
     63            * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
     64            * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
     65            * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
     66            * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     67            *
     68            ******************************************************************************
     69            */ 
     70          
     71          /* Includes ------------------------------------------------------------------*/
     72          #include "stm32746g_discovery_ts.h"
     73          
     74          /** @addtogroup BSP
     75            * @{
     76            */
     77          
     78          /** @addtogroup STM32746G_DISCOVERY
     79            * @{
     80            */ 
     81            
     82          /** @defgroup STM32746G_DISCOVERY_TS STM32746G_DISCOVERY_TS
     83            * @{
     84            */   
     85          
     86          /** @defgroup STM32746G_DISCOVERY_TS_Private_Types_Definitions STM32746G_DISCOVERY_TS Types Definitions
     87            * @{
     88            */ 
     89          /**
     90            * @}
     91            */ 
     92          
     93          /** @defgroup STM32746G_DISCOVERY_TS_Private_Defines STM32746G_DISCOVERY_TS Types Defines
     94            * @{
     95            */ 
     96          /**
     97            * @}
     98            */ 
     99          
    100          /** @defgroup STM32746G_DISCOVERY_TS_Private_Macros STM32746G_DISCOVERY_TS Private Macros
    101            * @{
    102            */ 
    103          /**
    104            * @}
    105            */
    106          
    107          /** @defgroup STM32746G_DISCOVERY_TS_Imported_Variables STM32746G_DISCOVERY_TS Imported Variables
    108            * @{
    109            */
    110            /**
    111              * @}
    112              */
    113          
    114          /** @defgroup STM32746G_DISCOVERY_TS_Private_Variables STM32746G_DISCOVERY_TS Private Variables
    115            * @{
    116            */ 

   \                                 In section .bss, align 4
    117          static TS_DrvTypeDef *tsDriver;
   \                     tsDriver:
   \   00000000                      DS8 4

   \                                 In section .bss, align 2
    118          static uint16_t tsXBoundary, tsYBoundary; 
   \                     tsXBoundary:
   \   00000000                      DS8 2

   \                                 In section .bss, align 2
   \                     tsYBoundary:
   \   00000000                      DS8 2

   \                                 In section .bss, align 1
    119          static uint8_t  tsOrientation;
   \                     tsOrientation:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    120          static uint8_t  I2cAddress;
   \                     I2cAddress:
   \   00000000                      DS8 1
    121          /**
    122            * @}
    123            */ 
    124          
    125          /** @defgroup STM32746G_DISCOVERY_TS_Private_Function_Prototypes STM32746G_DISCOVERY_TS Private Function Prototypes
    126            * @{
    127            */ 
    128          /**
    129            * @}
    130            */ 
    131          
    132          /** @defgroup STM32746G_DISCOVERY_TS_Exported_Functions STM32746G_DISCOVERY_TS Exported Functions
    133            * @{
    134            */ 
    135          
    136          /**
    137            * @brief  Initializes and configures the touch screen functionalities and 
    138            *         configures all necessary hardware resources (GPIOs, I2C, clocks..).
    139            * @param  ts_SizeX: Maximum X size of the TS area on LCD
    140            * @param  ts_SizeY: Maximum Y size of the TS area on LCD
    141            * @retval TS_OK if all initializations are OK. Other value if error.
    142            */

   \                                 In section .text, align 2, keep-with-next
    143          uint8_t BSP_TS_Init(uint16_t ts_SizeX, uint16_t ts_SizeY)
    144          {
   \                     BSP_TS_Init: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    145            uint8_t status = TS_OK;
   \   00000006   0x2600             MOVS     R6,#+0
    146            tsXBoundary = ts_SizeX;
   \   00000008   0x....             LDR.N    R0,??DataTable5
   \   0000000A   0x8004             STRH     R4,[R0, #+0]
    147            tsYBoundary = ts_SizeY;
   \   0000000C   0x....             LDR.N    R0,??DataTable5_1
   \   0000000E   0x8005             STRH     R5,[R0, #+0]
    148            
    149            /* Read ID and verify if the touch screen driver is ready */
    150            ft5336_ts_drv.Init(TS_I2C_ADDRESS);
   \   00000010   0x2070             MOVS     R0,#+112
   \   00000012   0x....             LDR.N    R1,??DataTable5_2
   \   00000014   0x6809             LDR      R1,[R1, #+0]
   \   00000016   0x4788             BLX      R1
    151            if(ft5336_ts_drv.ReadID(TS_I2C_ADDRESS) == FT5336_ID_VALUE)
   \   00000018   0x2070             MOVS     R0,#+112
   \   0000001A   0x....             LDR.N    R1,??DataTable5_2
   \   0000001C   0x6849             LDR      R1,[R1, #+4]
   \   0000001E   0x4788             BLX      R1
   \   00000020   0x2851             CMP      R0,#+81
   \   00000022   0xD110             BNE.N    ??BSP_TS_Init_0
    152            { 
    153              /* Initialize the TS driver structure */
    154              tsDriver = &ft5336_ts_drv;
   \   00000024   0x....             LDR.N    R0,??DataTable5_2
   \   00000026   0x....             LDR.N    R1,??DataTable5_3
   \   00000028   0x6008             STR      R0,[R1, #+0]
    155              I2cAddress = TS_I2C_ADDRESS;
   \   0000002A   0x2070             MOVS     R0,#+112
   \   0000002C   0x....             LDR.N    R1,??DataTable5_4
   \   0000002E   0x7008             STRB     R0,[R1, #+0]
    156              tsOrientation = TS_SWAP_XY;
   \   00000030   0x2008             MOVS     R0,#+8
   \   00000032   0x....             LDR.N    R1,??DataTable5_5
   \   00000034   0x7008             STRB     R0,[R1, #+0]
    157          
    158              /* Initialize the TS driver */
    159              tsDriver->Start(I2cAddress);
   \   00000036   0x....             LDR.N    R0,??DataTable5_4
   \   00000038   0x7800             LDRB     R0,[R0, #+0]
   \   0000003A   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000003C   0x....             LDR.N    R1,??DataTable5_3
   \   0000003E   0x6809             LDR      R1,[R1, #+0]
   \   00000040   0x68C9             LDR      R1,[R1, #+12]
   \   00000042   0x4788             BLX      R1
   \   00000044   0xE001             B.N      ??BSP_TS_Init_1
    160            }
    161            else
    162            {
    163              status = TS_DEVICE_NOT_FOUND;
   \                     ??BSP_TS_Init_0: (+1)
   \   00000046   0x2003             MOVS     R0,#+3
   \   00000048   0x0006             MOVS     R6,R0
    164            }
    165          
    166            return status;
   \                     ??BSP_TS_Init_1: (+1)
   \   0000004A   0x0030             MOVS     R0,R6
   \   0000004C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000004E   0xBD70             POP      {R4-R6,PC}       ;; return
    167          }
    168          
    169          /**
    170            * @brief  DeInitializes the TouchScreen.
    171            * @retval TS state
    172            */

   \                                 In section .text, align 2, keep-with-next
    173          uint8_t BSP_TS_DeInit(void)
    174          { 
    175            /* Actually ts_driver does not provide a DeInit function */
    176            return TS_OK;
   \                     BSP_TS_DeInit: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x4770             BX       LR               ;; return
    177          }
    178          
    179          /**
    180            * @brief  Configures and enables the touch screen interrupts.
    181            * @retval TS_OK if all initializations are OK. Other value if error.
    182            */

   \                                 In section .text, align 2, keep-with-next
    183          uint8_t BSP_TS_ITConfig(void)
    184          {
   \                     BSP_TS_ITConfig: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB085             SUB      SP,SP,#+20
    185            GPIO_InitTypeDef gpio_init_structure;
    186          
    187            /* Configure Interrupt mode for SD detection pin */
    188            gpio_init_structure.Pin = TS_INT_PIN;
   \   00000004   0xF44F 0x5000      MOV      R0,#+8192
   \   00000008   0x9000             STR      R0,[SP, #+0]
    189            gpio_init_structure.Pull = GPIO_NOPULL;
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x9002             STR      R0,[SP, #+8]
    190            gpio_init_structure.Speed = GPIO_SPEED_FAST;
   \   0000000E   0x2002             MOVS     R0,#+2
   \   00000010   0x9003             STR      R0,[SP, #+12]
    191            gpio_init_structure.Mode = GPIO_MODE_IT_RISING;
   \   00000012   0x....             LDR.N    R0,??DataTable5_6  ;; 0x10110000
   \   00000014   0x9001             STR      R0,[SP, #+4]
    192            HAL_GPIO_Init(TS_INT_GPIO_PORT, &gpio_init_structure);
   \   00000016   0x4669             MOV      R1,SP
   \   00000018   0x....             LDR.N    R0,??DataTable5_7  ;; 0x40022000
   \   0000001A   0x.... 0x....      BL       HAL_GPIO_Init
    193          
    194            /* Enable and set Touch screen EXTI Interrupt to the lowest priority */
    195            HAL_NVIC_SetPriority((IRQn_Type)(TS_INT_EXTI_IRQn), 0x0F, 0x00);
   \   0000001E   0x2200             MOVS     R2,#+0
   \   00000020   0x210F             MOVS     R1,#+15
   \   00000022   0x2028             MOVS     R0,#+40
   \   00000024   0x.... 0x....      BL       HAL_NVIC_SetPriority
    196            HAL_NVIC_EnableIRQ((IRQn_Type)(TS_INT_EXTI_IRQn));
   \   00000028   0x2028             MOVS     R0,#+40
   \   0000002A   0x.... 0x....      BL       HAL_NVIC_EnableIRQ
    197          
    198            /* Enable the TS ITs */
    199            tsDriver->EnableIT(I2cAddress);
   \   0000002E   0x....             LDR.N    R0,??DataTable5_4
   \   00000030   0x7800             LDRB     R0,[R0, #+0]
   \   00000032   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000034   0x....             LDR.N    R1,??DataTable5_3
   \   00000036   0x6809             LDR      R1,[R1, #+0]
   \   00000038   0x6989             LDR      R1,[R1, #+24]
   \   0000003A   0x4788             BLX      R1
    200          
    201            return TS_OK;  
   \   0000003C   0x2000             MOVS     R0,#+0
   \   0000003E   0xB005             ADD      SP,SP,#+20
   \   00000040   0xBD00             POP      {PC}             ;; return
    202          }
    203          
    204          /**
    205            * @brief  Gets the touch screen interrupt status.
    206            * @retval TS_OK if all initializations are OK. Other value if error.
    207            */

   \                                 In section .text, align 2, keep-with-next
    208          uint8_t BSP_TS_ITGetStatus(void)
    209          {
   \                     BSP_TS_ITGetStatus: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    210            /* Return the TS IT status */
    211            return (tsDriver->GetITStatus(I2cAddress));
   \   00000002   0x....             LDR.N    R0,??DataTable5_4
   \   00000004   0x7800             LDRB     R0,[R0, #+0]
   \   00000006   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000008   0x....             LDR.N    R1,??DataTable5_3
   \   0000000A   0x6809             LDR      R1,[R1, #+0]
   \   0000000C   0x6A09             LDR      R1,[R1, #+32]
   \   0000000E   0x4788             BLX      R1
   \   00000010   0xBD02             POP      {R1,PC}          ;; return
    212          }
    213          
    214          /**
    215            * @brief  Returns status and positions of the touch screen.
    216            * @param  TS_State: Pointer to touch screen current state structure
    217            * @retval TS_OK if all initializations are OK. Other value if error.
    218            */

   \                                 In section .text, align 2, keep-with-next
    219          uint8_t BSP_TS_GetState(TS_StateTypeDef *TS_State)
    220          {
   \                     BSP_TS_GetState: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB090             SUB      SP,SP,#+64
   \   00000006   0x0004             MOVS     R4,R0
    221            static uint32_t _x[TS_MAX_NB_TOUCH] = {0, 0};
    222            static uint32_t _y[TS_MAX_NB_TOUCH] = {0, 0};
    223            uint8_t ts_status = TS_OK;
   \   00000008   0x2500             MOVS     R5,#+0
    224            uint16_t x[TS_MAX_NB_TOUCH];
    225            uint16_t y[TS_MAX_NB_TOUCH];
    226            uint16_t brute_x[TS_MAX_NB_TOUCH];
    227            uint16_t brute_y[TS_MAX_NB_TOUCH];
    228            uint16_t x_diff;
    229            uint16_t y_diff;
    230            uint32_t index;
    231          #if (TS_MULTI_TOUCH_SUPPORTED == 1)
    232            uint32_t weight = 0;
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x9003             STR      R0,[SP, #+12]
    233            uint32_t area = 0;
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0x9002             STR      R0,[SP, #+8]
    234            uint32_t event = 0;
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0x9001             STR      R0,[SP, #+4]
    235          #endif /* TS_MULTI_TOUCH_SUPPORTED == 1 */
    236          
    237            /* Check and update the number of touches active detected */
    238            TS_State->touchDetected = tsDriver->DetectTouch(I2cAddress);
   \   00000016   0x....             LDR.N    R0,??DataTable5_4
   \   00000018   0x7800             LDRB     R0,[R0, #+0]
   \   0000001A   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000001C   0x....             LDR.N    R1,??DataTable5_3
   \   0000001E   0x6809             LDR      R1,[R1, #+0]
   \   00000020   0x6909             LDR      R1,[R1, #+16]
   \   00000022   0x4788             BLX      R1
   \   00000024   0x7020             STRB     R0,[R4, #+0]
    239            
    240            if(TS_State->touchDetected)
   \   00000026   0x7820             LDRB     R0,[R4, #+0]
   \   00000028   0x2800             CMP      R0,#+0
   \   0000002A   0xF000 0x80E8      BEQ.W    ??BSP_TS_GetState_0
    241            {
    242              for(index=0; index < TS_State->touchDetected; index++)
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0x4680             MOV      R8,R0
   \                     ??BSP_TS_GetState_1: (+1)
   \   00000032   0x7820             LDRB     R0,[R4, #+0]
   \   00000034   0x4580             CMP      R8,R0
   \   00000036   0xF080 0x80DE      BCS.W    ??BSP_TS_GetState_2
    243              {
    244                /* Get each touch coordinates */
    245                tsDriver->GetXY(I2cAddress, &(brute_x[index]), &(brute_y[index]));
   \   0000003A   0xA80A             ADD      R0,SP,#+40
   \   0000003C   0xEB10 0x0248      ADDS     R2,R0,R8, LSL #+1
   \   00000040   0xA80D             ADD      R0,SP,#+52
   \   00000042   0xEB10 0x0148      ADDS     R1,R0,R8, LSL #+1
   \   00000046   0x....             LDR.N    R0,??DataTable5_4
   \   00000048   0x7800             LDRB     R0,[R0, #+0]
   \   0000004A   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000004C   0x....             LDR.N    R3,??DataTable5_3
   \   0000004E   0x681B             LDR      R3,[R3, #+0]
   \   00000050   0x695B             LDR      R3,[R3, #+20]
   \   00000052   0x4798             BLX      R3
    246          
    247                if(tsOrientation == TS_SWAP_NONE)
   \   00000054   0x....             LDR.N    R0,??DataTable5_5
   \   00000056   0x7800             LDRB     R0,[R0, #+0]
   \   00000058   0x2801             CMP      R0,#+1
   \   0000005A   0xD10B             BNE.N    ??BSP_TS_GetState_3
    248                {
    249                  x[index] = brute_x[index];
   \   0000005C   0xA80D             ADD      R0,SP,#+52
   \   0000005E   0xF830 0x0018      LDRH     R0,[R0, R8, LSL #+1]
   \   00000062   0xA907             ADD      R1,SP,#+28
   \   00000064   0xF821 0x0018      STRH     R0,[R1, R8, LSL #+1]
    250                  y[index] = brute_y[index];
   \   00000068   0xA80A             ADD      R0,SP,#+40
   \   0000006A   0xF830 0x0018      LDRH     R0,[R0, R8, LSL #+1]
   \   0000006E   0xA904             ADD      R1,SP,#+16
   \   00000070   0xF821 0x0018      STRH     R0,[R1, R8, LSL #+1]
    251                }
    252          
    253                if(tsOrientation & TS_SWAP_X)
   \                     ??BSP_TS_GetState_3: (+1)
   \   00000074   0x....             LDR.N    R0,??DataTable5_5
   \   00000076   0x7800             LDRB     R0,[R0, #+0]
   \   00000078   0x0780             LSLS     R0,R0,#+30
   \   0000007A   0xD507             BPL.N    ??BSP_TS_GetState_4
    254                {
    255                  x[index] = 4096 - brute_x[index];
   \   0000007C   0xA80D             ADD      R0,SP,#+52
   \   0000007E   0xF830 0x0018      LDRH     R0,[R0, R8, LSL #+1]
   \   00000082   0xF5D0 0x5080      RSBS     R0,R0,#+4096
   \   00000086   0xA907             ADD      R1,SP,#+28
   \   00000088   0xF821 0x0018      STRH     R0,[R1, R8, LSL #+1]
    256                }
    257          
    258                if(tsOrientation & TS_SWAP_Y)
   \                     ??BSP_TS_GetState_4: (+1)
   \   0000008C   0x....             LDR.N    R0,??DataTable5_5
   \   0000008E   0x7800             LDRB     R0,[R0, #+0]
   \   00000090   0x0740             LSLS     R0,R0,#+29
   \   00000092   0xD507             BPL.N    ??BSP_TS_GetState_5
    259                {
    260                  y[index] = 4096 - brute_y[index];
   \   00000094   0xA80A             ADD      R0,SP,#+40
   \   00000096   0xF830 0x0018      LDRH     R0,[R0, R8, LSL #+1]
   \   0000009A   0xF5D0 0x5080      RSBS     R0,R0,#+4096
   \   0000009E   0xA904             ADD      R1,SP,#+16
   \   000000A0   0xF821 0x0018      STRH     R0,[R1, R8, LSL #+1]
    261                }
    262          
    263                if(tsOrientation & TS_SWAP_XY)
   \                     ??BSP_TS_GetState_5: (+1)
   \   000000A4   0x....             LDR.N    R0,??DataTable5_5
   \   000000A6   0x7800             LDRB     R0,[R0, #+0]
   \   000000A8   0x0700             LSLS     R0,R0,#+28
   \   000000AA   0xD50B             BPL.N    ??BSP_TS_GetState_6
    264                {
    265                  y[index] = brute_x[index];
   \   000000AC   0xA80D             ADD      R0,SP,#+52
   \   000000AE   0xF830 0x0018      LDRH     R0,[R0, R8, LSL #+1]
   \   000000B2   0xA904             ADD      R1,SP,#+16
   \   000000B4   0xF821 0x0018      STRH     R0,[R1, R8, LSL #+1]
    266                  x[index] = brute_y[index];
   \   000000B8   0xA80A             ADD      R0,SP,#+40
   \   000000BA   0xF830 0x0018      LDRH     R0,[R0, R8, LSL #+1]
   \   000000BE   0xA907             ADD      R1,SP,#+28
   \   000000C0   0xF821 0x0018      STRH     R0,[R1, R8, LSL #+1]
    267                }
    268          
    269                x_diff = x[index] > _x[index]? (x[index] - _x[index]): (_x[index] - x[index]);
   \                     ??BSP_TS_GetState_6: (+1)
   \   000000C4   0x....             LDR.N    R0,??DataTable5_8
   \   000000C6   0xF850 0x0028      LDR      R0,[R0, R8, LSL #+2]
   \   000000CA   0xA907             ADD      R1,SP,#+28
   \   000000CC   0xF831 0x1018      LDRH     R1,[R1, R8, LSL #+1]
   \   000000D0   0x4288             CMP      R0,R1
   \   000000D2   0xD207             BCS.N    ??BSP_TS_GetState_7
   \   000000D4   0xA807             ADD      R0,SP,#+28
   \   000000D6   0xF830 0x0018      LDRH     R0,[R0, R8, LSL #+1]
   \   000000DA   0x....             LDR.N    R1,??DataTable5_8
   \   000000DC   0xF851 0x1028      LDR      R1,[R1, R8, LSL #+2]
   \   000000E0   0x1A46             SUBS     R6,R0,R1
   \   000000E2   0xE006             B.N      ??BSP_TS_GetState_8
   \                     ??BSP_TS_GetState_7: (+1)
   \   000000E4   0x....             LDR.N    R0,??DataTable5_8
   \   000000E6   0xF850 0x0028      LDR      R0,[R0, R8, LSL #+2]
   \   000000EA   0xA907             ADD      R1,SP,#+28
   \   000000EC   0xF831 0x1018      LDRH     R1,[R1, R8, LSL #+1]
   \   000000F0   0x1A46             SUBS     R6,R0,R1
    270                y_diff = y[index] > _y[index]? (y[index] - _y[index]): (_y[index] - y[index]);
   \                     ??BSP_TS_GetState_8: (+1)
   \   000000F2   0x....             LDR.N    R0,??DataTable5_9
   \   000000F4   0xF850 0x0028      LDR      R0,[R0, R8, LSL #+2]
   \   000000F8   0xA904             ADD      R1,SP,#+16
   \   000000FA   0xF831 0x1018      LDRH     R1,[R1, R8, LSL #+1]
   \   000000FE   0x4288             CMP      R0,R1
   \   00000100   0xD207             BCS.N    ??BSP_TS_GetState_9
   \   00000102   0xA804             ADD      R0,SP,#+16
   \   00000104   0xF830 0x0018      LDRH     R0,[R0, R8, LSL #+1]
   \   00000108   0x....             LDR.N    R1,??DataTable5_9
   \   0000010A   0xF851 0x1028      LDR      R1,[R1, R8, LSL #+2]
   \   0000010E   0x1A47             SUBS     R7,R0,R1
   \   00000110   0xE006             B.N      ??BSP_TS_GetState_10
   \                     ??BSP_TS_GetState_9: (+1)
   \   00000112   0x....             LDR.N    R0,??DataTable5_9
   \   00000114   0xF850 0x0028      LDR      R0,[R0, R8, LSL #+2]
   \   00000118   0xA904             ADD      R1,SP,#+16
   \   0000011A   0xF831 0x1018      LDRH     R1,[R1, R8, LSL #+1]
   \   0000011E   0x1A47             SUBS     R7,R0,R1
    271          
    272                if ((x_diff + y_diff) > 5)
   \                     ??BSP_TS_GetState_10: (+1)
   \   00000120   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000122   0xFA17 0xF086      UXTAH    R0,R7,R6
   \   00000126   0x2806             CMP      R0,#+6
   \   00000128   0xDB0B             BLT.N    ??BSP_TS_GetState_11
    273                {
    274                  _x[index] = x[index];
   \   0000012A   0xA807             ADD      R0,SP,#+28
   \   0000012C   0xF830 0x0018      LDRH     R0,[R0, R8, LSL #+1]
   \   00000130   0x....             LDR.N    R1,??DataTable5_8
   \   00000132   0xF841 0x0028      STR      R0,[R1, R8, LSL #+2]
    275                  _y[index] = y[index];
   \   00000136   0xA804             ADD      R0,SP,#+16
   \   00000138   0xF830 0x0018      LDRH     R0,[R0, R8, LSL #+1]
   \   0000013C   0x....             LDR.N    R1,??DataTable5_9
   \   0000013E   0xF841 0x0028      STR      R0,[R1, R8, LSL #+2]
    276                }
    277          
    278                if(I2cAddress == FT5336_I2C_SLAVE_ADDRESS)
   \                     ??BSP_TS_GetState_11: (+1)
   \   00000142   0x....             LDR.N    R0,??DataTable5_4
   \   00000144   0x7800             LDRB     R0,[R0, #+0]
   \   00000146   0x2870             CMP      R0,#+112
   \   00000148   0xD10C             BNE.N    ??BSP_TS_GetState_12
    279                {
    280                  TS_State->touchX[index] = x[index];
   \   0000014A   0xA807             ADD      R0,SP,#+28
   \   0000014C   0xF830 0x0018      LDRH     R0,[R0, R8, LSL #+1]
   \   00000150   0xEB14 0x0148      ADDS     R1,R4,R8, LSL #+1
   \   00000154   0x8048             STRH     R0,[R1, #+2]
    281                  TS_State->touchY[index] = y[index];
   \   00000156   0xA804             ADD      R0,SP,#+16
   \   00000158   0xF830 0x0018      LDRH     R0,[R0, R8, LSL #+1]
   \   0000015C   0xEB14 0x0148      ADDS     R1,R4,R8, LSL #+1
   \   00000160   0x8188             STRH     R0,[R1, #+12]
   \   00000162   0xE013             B.N      ??BSP_TS_GetState_13
    282                }
    283                else
    284                {
    285                  /* 2^12 = 4096 : indexes are expressed on a dynamic of 4096 */
    286                  TS_State->touchX[index] = (tsXBoundary * _x[index]) >> 12;
   \                     ??BSP_TS_GetState_12: (+1)
   \   00000164   0x....             LDR.N    R0,??DataTable5
   \   00000166   0x8800             LDRH     R0,[R0, #+0]
   \   00000168   0x....             LDR.N    R1,??DataTable5_8
   \   0000016A   0xF851 0x1028      LDR      R1,[R1, R8, LSL #+2]
   \   0000016E   0x4348             MULS     R0,R1,R0
   \   00000170   0x0B00             LSRS     R0,R0,#+12
   \   00000172   0xEB14 0x0148      ADDS     R1,R4,R8, LSL #+1
   \   00000176   0x8048             STRH     R0,[R1, #+2]
    287                  TS_State->touchY[index] = (tsYBoundary * _y[index]) >> 12;
   \   00000178   0x....             LDR.N    R0,??DataTable5_1
   \   0000017A   0x8800             LDRH     R0,[R0, #+0]
   \   0000017C   0x....             LDR.N    R1,??DataTable5_9
   \   0000017E   0xF851 0x1028      LDR      R1,[R1, R8, LSL #+2]
   \   00000182   0x4348             MULS     R0,R1,R0
   \   00000184   0x0B00             LSRS     R0,R0,#+12
   \   00000186   0xEB14 0x0148      ADDS     R1,R4,R8, LSL #+1
   \   0000018A   0x8188             STRH     R0,[R1, #+12]
    288                }
    289          
    290          #if (TS_MULTI_TOUCH_SUPPORTED == 1)
    291          
    292                /* Get touch info related to the current touch */
    293                ft5336_TS_GetTouchInfo(I2cAddress, index, &weight, &area, &event);
   \                     ??BSP_TS_GetState_13: (+1)
   \   0000018C   0xA801             ADD      R0,SP,#+4
   \   0000018E   0x9000             STR      R0,[SP, #+0]
   \   00000190   0xAB02             ADD      R3,SP,#+8
   \   00000192   0xAA03             ADD      R2,SP,#+12
   \   00000194   0x4641             MOV      R1,R8
   \   00000196   0x....             LDR.N    R0,??DataTable5_4
   \   00000198   0x7800             LDRB     R0,[R0, #+0]
   \   0000019A   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000019C   0x.... 0x....      BL       ft5336_TS_GetTouchInfo
    294          
    295                /* Update TS_State structure */
    296                TS_State->touchWeight[index] = weight;
   \   000001A0   0x9803             LDR      R0,[SP, #+12]
   \   000001A2   0xEB18 0x0104      ADDS     R1,R8,R4
   \   000001A6   0x7588             STRB     R0,[R1, #+22]
    297                TS_State->touchArea[index]   = area;
   \   000001A8   0x9802             LDR      R0,[SP, #+8]
   \   000001AA   0xEB18 0x0104      ADDS     R1,R8,R4
   \   000001AE   0xF881 0x0020      STRB     R0,[R1, #+32]
    298          
    299                /* Remap touch event */
    300                switch(event)
   \   000001B2   0x9801             LDR      R0,[SP, #+4]
   \   000001B4   0x2800             CMP      R0,#+0
   \   000001B6   0xD005             BEQ.N    ??BSP_TS_GetState_14
   \   000001B8   0x2802             CMP      R0,#+2
   \   000001BA   0xD00D             BEQ.N    ??BSP_TS_GetState_15
   \   000001BC   0xD307             BCC.N    ??BSP_TS_GetState_16
   \   000001BE   0x2803             CMP      R0,#+3
   \   000001C0   0xD00F             BEQ.N    ??BSP_TS_GetState_17
   \   000001C2   0xE013             B.N      ??BSP_TS_GetState_18
    301                {
    302                  case FT5336_TOUCH_EVT_FLAG_PRESS_DOWN	:
    303                    TS_State->touchEventId[index] = TOUCH_EVENT_PRESS_DOWN;
   \                     ??BSP_TS_GetState_14: (+1)
   \   000001C4   0x2001             MOVS     R0,#+1
   \   000001C6   0xEB18 0x0104      ADDS     R1,R8,R4
   \   000001CA   0x76C8             STRB     R0,[R1, #+27]
    304                    break;
   \   000001CC   0xE010             B.N      ??BSP_TS_GetState_19
    305                  case FT5336_TOUCH_EVT_FLAG_LIFT_UP :
    306                    TS_State->touchEventId[index] = TOUCH_EVENT_LIFT_UP;
   \                     ??BSP_TS_GetState_16: (+1)
   \   000001CE   0x2002             MOVS     R0,#+2
   \   000001D0   0xEB18 0x0104      ADDS     R1,R8,R4
   \   000001D4   0x76C8             STRB     R0,[R1, #+27]
    307                    break;
   \   000001D6   0xE00B             B.N      ??BSP_TS_GetState_19
    308                  case FT5336_TOUCH_EVT_FLAG_CONTACT :
    309                    TS_State->touchEventId[index] = TOUCH_EVENT_CONTACT;
   \                     ??BSP_TS_GetState_15: (+1)
   \   000001D8   0x2003             MOVS     R0,#+3
   \   000001DA   0xEB18 0x0104      ADDS     R1,R8,R4
   \   000001DE   0x76C8             STRB     R0,[R1, #+27]
    310                    break;
   \   000001E0   0xE006             B.N      ??BSP_TS_GetState_19
    311                  case FT5336_TOUCH_EVT_FLAG_NO_EVENT :
    312                    TS_State->touchEventId[index] = TOUCH_EVENT_NO_EVT;
   \                     ??BSP_TS_GetState_17: (+1)
   \   000001E2   0x2000             MOVS     R0,#+0
   \   000001E4   0xEB18 0x0104      ADDS     R1,R8,R4
   \   000001E8   0x76C8             STRB     R0,[R1, #+27]
    313                    break;
   \   000001EA   0xE001             B.N      ??BSP_TS_GetState_19
    314                  default :
    315                    ts_status = TS_ERROR;
   \                     ??BSP_TS_GetState_18: (+1)
   \   000001EC   0x2001             MOVS     R0,#+1
   \   000001EE   0x0005             MOVS     R5,R0
    316                    break;
    317                } /* of switch(event) */
    318          
    319          #endif /* TS_MULTI_TOUCH_SUPPORTED == 1 */
    320          
    321              } /* of for(index=0; index < TS_State->touchDetected; index++) */
   \                     ??BSP_TS_GetState_19: (+1)
   \   000001F0   0xF118 0x0801      ADDS     R8,R8,#+1
   \   000001F4   0xE71D             B.N      ??BSP_TS_GetState_1
    322          
    323          #if (TS_MULTI_TOUCH_SUPPORTED == 1)
    324              /* Get gesture Id */
    325              ts_status = BSP_TS_Get_GestureId(TS_State);
   \                     ??BSP_TS_GetState_2: (+1)
   \   000001F6   0x0020             MOVS     R0,R4
   \   000001F8   0x.... 0x....      BL       BSP_TS_Get_GestureId
   \   000001FC   0x0005             MOVS     R5,R0
    326          #endif /* TS_MULTI_TOUCH_SUPPORTED == 1 */
    327          
    328            } /* end of if(TS_State->touchDetected != 0) */
    329          
    330            return (ts_status);
   \                     ??BSP_TS_GetState_0: (+1)
   \   000001FE   0x0028             MOVS     R0,R5
   \   00000200   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000202   0xB010             ADD      SP,SP,#+64
   \   00000204   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    331          }

   \                                 In section .bss, align 4
   \                     ??_x:
   \   00000000                      DS8 20

   \                                 In section .bss, align 4
   \                     ??_y:
   \   00000000                      DS8 20
    332          
    333          #if (TS_MULTI_TOUCH_SUPPORTED == 1)
    334          /**
    335            * @brief  Update gesture Id following a touch detected.
    336            * @param  TS_State: Pointer to touch screen current state structure
    337            * @retval TS_OK if all initializations are OK. Other value if error.
    338            */

   \                                 In section .text, align 2, keep-with-next
    339          uint8_t BSP_TS_Get_GestureId(TS_StateTypeDef *TS_State)
    340          {
   \                     BSP_TS_Get_GestureId: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    341            uint32_t gestureId = 0;
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x9000             STR      R0,[SP, #+0]
    342            uint8_t  ts_status = TS_OK;
   \   00000008   0x2500             MOVS     R5,#+0
    343          
    344            /* Get gesture Id */
    345            ft5336_TS_GetGestureID(I2cAddress, &gestureId);
   \   0000000A   0x4669             MOV      R1,SP
   \   0000000C   0x....             LDR.N    R0,??DataTable5_4
   \   0000000E   0x7800             LDRB     R0,[R0, #+0]
   \   00000010   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000012   0x.... 0x....      BL       ft5336_TS_GetGestureID
    346          
    347            /* Remap gesture Id to a TS_GestureIdTypeDef value */
    348            switch(gestureId)
   \   00000016   0x9800             LDR      R0,[SP, #+0]
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD00C             BEQ.N    ??BSP_TS_Get_GestureId_0
   \   0000001C   0x2810             CMP      R0,#+16
   \   0000001E   0xD00D             BEQ.N    ??BSP_TS_Get_GestureId_1
   \   00000020   0x2814             CMP      R0,#+20
   \   00000022   0xD00E             BEQ.N    ??BSP_TS_Get_GestureId_2
   \   00000024   0x2818             CMP      R0,#+24
   \   00000026   0xD00F             BEQ.N    ??BSP_TS_Get_GestureId_3
   \   00000028   0x281C             CMP      R0,#+28
   \   0000002A   0xD010             BEQ.N    ??BSP_TS_Get_GestureId_4
   \   0000002C   0x2840             CMP      R0,#+64
   \   0000002E   0xD011             BEQ.N    ??BSP_TS_Get_GestureId_5
   \   00000030   0x2849             CMP      R0,#+73
   \   00000032   0xD012             BEQ.N    ??BSP_TS_Get_GestureId_6
   \   00000034   0xE014             B.N      ??BSP_TS_Get_GestureId_7
    349            {
    350              case FT5336_GEST_ID_NO_GESTURE :
    351                TS_State->gestureId = GEST_ID_NO_GESTURE;
   \                     ??BSP_TS_Get_GestureId_0: (+1)
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0x62A0             STR      R0,[R4, #+40]
    352                break;
   \   0000003A   0xE013             B.N      ??BSP_TS_Get_GestureId_8
    353              case FT5336_GEST_ID_MOVE_UP :
    354                TS_State->gestureId = GEST_ID_MOVE_UP;
   \                     ??BSP_TS_Get_GestureId_1: (+1)
   \   0000003C   0x2001             MOVS     R0,#+1
   \   0000003E   0x62A0             STR      R0,[R4, #+40]
    355                break;
   \   00000040   0xE010             B.N      ??BSP_TS_Get_GestureId_8
    356              case FT5336_GEST_ID_MOVE_RIGHT :
    357                TS_State->gestureId = GEST_ID_MOVE_RIGHT;
   \                     ??BSP_TS_Get_GestureId_2: (+1)
   \   00000042   0x2002             MOVS     R0,#+2
   \   00000044   0x62A0             STR      R0,[R4, #+40]
    358                break;
   \   00000046   0xE00D             B.N      ??BSP_TS_Get_GestureId_8
    359              case FT5336_GEST_ID_MOVE_DOWN :
    360                TS_State->gestureId = GEST_ID_MOVE_DOWN;
   \                     ??BSP_TS_Get_GestureId_3: (+1)
   \   00000048   0x2003             MOVS     R0,#+3
   \   0000004A   0x62A0             STR      R0,[R4, #+40]
    361                break;
   \   0000004C   0xE00A             B.N      ??BSP_TS_Get_GestureId_8
    362              case FT5336_GEST_ID_MOVE_LEFT :
    363                TS_State->gestureId = GEST_ID_MOVE_LEFT;
   \                     ??BSP_TS_Get_GestureId_4: (+1)
   \   0000004E   0x2004             MOVS     R0,#+4
   \   00000050   0x62A0             STR      R0,[R4, #+40]
    364                break;
   \   00000052   0xE007             B.N      ??BSP_TS_Get_GestureId_8
    365              case FT5336_GEST_ID_ZOOM_IN :
    366                TS_State->gestureId = GEST_ID_ZOOM_IN;
   \                     ??BSP_TS_Get_GestureId_5: (+1)
   \   00000054   0x2005             MOVS     R0,#+5
   \   00000056   0x62A0             STR      R0,[R4, #+40]
    367                break;
   \   00000058   0xE004             B.N      ??BSP_TS_Get_GestureId_8
    368              case FT5336_GEST_ID_ZOOM_OUT :
    369                TS_State->gestureId = GEST_ID_ZOOM_OUT;
   \                     ??BSP_TS_Get_GestureId_6: (+1)
   \   0000005A   0x2006             MOVS     R0,#+6
   \   0000005C   0x62A0             STR      R0,[R4, #+40]
    370                break;
   \   0000005E   0xE001             B.N      ??BSP_TS_Get_GestureId_8
    371              default :
    372                ts_status = TS_ERROR;
   \                     ??BSP_TS_Get_GestureId_7: (+1)
   \   00000060   0x2001             MOVS     R0,#+1
   \   00000062   0x0005             MOVS     R5,R0
    373                break;
    374            } /* of switch(gestureId) */
    375          
    376            return(ts_status);
   \                     ??BSP_TS_Get_GestureId_8: (+1)
   \   00000064   0x0028             MOVS     R0,R5
   \   00000066   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000068   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    377          }
    378          #endif /* TS_MULTI_TOUCH_SUPPORTED == 1 */
    379          
    380          /**
    381            * @brief  Clears all touch screen interrupts.
    382            */

   \                                 In section .text, align 2, keep-with-next
    383          void BSP_TS_ITClear(void)
    384          {
   \                     BSP_TS_ITClear: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    385            /* Clear TS IT pending bits */
    386            tsDriver->ClearIT(I2cAddress); 
   \   00000002   0x....             LDR.N    R0,??DataTable5_4
   \   00000004   0x7800             LDRB     R0,[R0, #+0]
   \   00000006   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000008   0x....             LDR.N    R1,??DataTable5_3
   \   0000000A   0x6809             LDR      R1,[R1, #+0]
   \   0000000C   0x69C9             LDR      R1,[R1, #+28]
   \   0000000E   0x4788             BLX      R1
    387          }
   \   00000010   0xBD01             POP      {R0,PC}          ;; return
    388          
    389          
    390          /** @defgroup STM32756G_DISCOVERY_TS_Private_Functions TS Private Functions
    391            * @{
    392            */
    393          
    394          
    395          /**
    396            * @brief  Function used to reset all touch data before a new acquisition
    397            *         of touch information.
    398            * @param  TS_State: Pointer to touch screen current state structure
    399            * @retval TS_OK if OK, TE_ERROR if problem found.
    400            */

   \                                 In section .text, align 2, keep-with-next
    401          uint8_t BSP_TS_ResetTouchData(TS_StateTypeDef *TS_State)
    402          {
   \                     BSP_TS_ResetTouchData: (+1)
   \   00000000   0xB410             PUSH     {R4}
   \   00000002   0x0001             MOVS     R1,R0
    403            uint8_t ts_status = TS_ERROR;
   \   00000004   0x2001             MOVS     R0,#+1
    404            uint32_t index;
    405          
    406            if (TS_State != (TS_StateTypeDef *)NULL)
   \   00000006   0x2900             CMP      R1,#+0
   \   00000008   0xD01D             BEQ.N    ??BSP_TS_ResetTouchData_0
    407            {
    408              TS_State->gestureId = GEST_ID_NO_GESTURE;
   \   0000000A   0x2300             MOVS     R3,#+0
   \   0000000C   0x628B             STR      R3,[R1, #+40]
    409              TS_State->touchDetected = 0;
   \   0000000E   0x2300             MOVS     R3,#+0
   \   00000010   0x700B             STRB     R3,[R1, #+0]
    410          
    411              for(index = 0; index < TS_MAX_NB_TOUCH; index++)
   \   00000012   0x2300             MOVS     R3,#+0
   \   00000014   0x001A             MOVS     R2,R3
   \                     ??BSP_TS_ResetTouchData_1: (+1)
   \   00000016   0x2A05             CMP      R2,#+5
   \   00000018   0xD213             BCS.N    ??BSP_TS_ResetTouchData_2
    412              {
    413                TS_State->touchX[index]       = 0;
   \   0000001A   0x2300             MOVS     R3,#+0
   \   0000001C   0xEB11 0x0442      ADDS     R4,R1,R2, LSL #+1
   \   00000020   0x8063             STRH     R3,[R4, #+2]
    414                TS_State->touchY[index]       = 0;
   \   00000022   0x2300             MOVS     R3,#+0
   \   00000024   0xEB11 0x0442      ADDS     R4,R1,R2, LSL #+1
   \   00000028   0x81A3             STRH     R3,[R4, #+12]
    415                TS_State->touchArea[index]    = 0;
   \   0000002A   0x2300             MOVS     R3,#+0
   \   0000002C   0x1854             ADDS     R4,R2,R1
   \   0000002E   0xF884 0x3020      STRB     R3,[R4, #+32]
    416                TS_State->touchEventId[index] = TOUCH_EVENT_NO_EVT;
   \   00000032   0x2300             MOVS     R3,#+0
   \   00000034   0x1854             ADDS     R4,R2,R1
   \   00000036   0x76E3             STRB     R3,[R4, #+27]
    417                TS_State->touchWeight[index]  = 0;
   \   00000038   0x2300             MOVS     R3,#+0
   \   0000003A   0x1854             ADDS     R4,R2,R1
   \   0000003C   0x75A3             STRB     R3,[R4, #+22]
    418              }
   \   0000003E   0x1C52             ADDS     R2,R2,#+1
   \   00000040   0xE7E9             B.N      ??BSP_TS_ResetTouchData_1
    419          
    420              ts_status = TS_OK;
   \                     ??BSP_TS_ResetTouchData_2: (+1)
   \   00000042   0x2300             MOVS     R3,#+0
   \   00000044   0x0018             MOVS     R0,R3
    421          
    422            } /* of if (TS_State != (TS_StateTypeDef *)NULL) */
    423          
    424            return (ts_status);
   \                     ??BSP_TS_ResetTouchData_0: (+1)
   \   00000046   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000048   0xBC10             POP      {R4}
   \   0000004A   0x4770             BX       LR               ;; return
    425          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5:
   \   00000000   0x........         DC32     tsXBoundary

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_1:
   \   00000000   0x........         DC32     tsYBoundary

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_2:
   \   00000000   0x........         DC32     ft5336_ts_drv

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_3:
   \   00000000   0x........         DC32     tsDriver

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_4:
   \   00000000   0x........         DC32     I2cAddress

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_5:
   \   00000000   0x........         DC32     tsOrientation

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_6:
   \   00000000   0x10110000         DC32     0x10110000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_7:
   \   00000000   0x40022000         DC32     0x40022000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_8:
   \   00000000   0x........         DC32     ??_x

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_9:
   \   00000000   0x........         DC32     ??_y
    426          
    427          /**
    428            * @}
    429            */ 
    430          
    431          /**
    432            * @}
    433            */ 
    434          
    435          /**
    436            * @}
    437            */ 
    438          
    439          /**
    440            * @}
    441            */  
    442          
    443          /**
    444            * @}
    445            */
    446          
    447          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   BSP_TS_DeInit
      88   BSP_TS_GetState
        88   -- Indirect call
        88   -> BSP_TS_Get_GestureId
        88   -> ft5336_TS_GetTouchInfo
      16   BSP_TS_Get_GestureId
        16   -> ft5336_TS_GetGestureID
       8   BSP_TS_ITClear
         8   -- Indirect call
      24   BSP_TS_ITConfig
        24   -- Indirect call
        24   -> HAL_GPIO_Init
        24   -> HAL_NVIC_EnableIRQ
        24   -> HAL_NVIC_SetPriority
       8   BSP_TS_ITGetStatus
         8   -- Indirect call
      16   BSP_TS_Init
        16   -- Indirect call
       4   BSP_TS_ResetTouchData


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable5
       4  ??DataTable5_1
       4  ??DataTable5_2
       4  ??DataTable5_3
       4  ??DataTable5_4
       4  ??DataTable5_5
       4  ??DataTable5_6
       4  ??DataTable5_7
       4  ??DataTable5_8
       4  ??DataTable5_9
       4  BSP_TS_DeInit
     520  BSP_TS_GetState
     106  BSP_TS_Get_GestureId
      18  BSP_TS_ITClear
      66  BSP_TS_ITConfig
      18  BSP_TS_ITGetStatus
      80  BSP_TS_Init
      76  BSP_TS_ResetTouchData
       1  I2cAddress
      20  _x
      20  _y
       4  tsDriver
       1  tsOrientation
       2  tsXBoundary
       2  tsYBoundary

 
  50 bytes in section .bss
 928 bytes in section .text
 
 928 bytes of CODE memory
  50 bytes of DATA memory

Errors: none
Warnings: none
