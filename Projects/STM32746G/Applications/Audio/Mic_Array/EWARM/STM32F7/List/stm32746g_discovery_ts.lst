###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.2.10312/W32 for ARM       27/Feb/2016  00:32:30
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Drivers\BSP\STM32746G-Discovery\stm32746g_discovery_ts.c
#    Command line =  
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Drivers\BSP\STM32746G-Discovery\stm32746g_discovery_ts.c
#        -D USE_HAL_DRIVER -D STM32F746xx -D USE_STM32746G_DISCO -D
#        USE_IOEXPANDER -D USE_USB_FS -lC
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
#        -lA
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
#        -o
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M7 -e --fpu=VFPv5_sp --dlib_config
#        "D:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Full.h" -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\Inc\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\CMSIS\Device\ST\STM32F7xx\Include\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\STM32F7xx_HAL_Driver\Inc\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\STM32746G-Discovery\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\Components\Common\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Log\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Fonts\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\CPU\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_Device_Library\Core\Inc\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Core\Inc\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Class\MSC\Inc\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\drivers\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_Audio\Addons\PDM\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_Device_Library\Class\AUDIO\Inc\
#        -Om --use_c++_inline --require_prototypes -I "D:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.3\arm\CMSIS\Include\" -D
#        ARM_MATH_CM7
#    List file    =  
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List\stm32746g_discovery_ts.lst
#    Object file  =  
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj\stm32746g_discovery_ts.o
#
###############################################################################

H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Drivers\BSP\STM32746G-Discovery\stm32746g_discovery_ts.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32746g_discovery_ts.c
      4            * @author  MCD Application Team
      5            * @version V1.0.0
      6            * @date    25-June-2015
      7            * @brief   This file provides a set of functions needed to manage the Touch 
      8            *          Screen on STM32746G-Discovery board.
      9            @verbatim
     10             1. How To use this driver:
     11             --------------------------
     12                - This driver is used to drive the touch screen module of the STM32746G-Discovery
     13                  board on the RK043FN48H-CT672B 480x272 LCD screen with capacitive touch screen.
     14                - The FT5336 component driver must be included in project files according to
     15                  the touch screen driver present on this board.
     16             
     17             2. Driver description:
     18             ---------------------
     19               + Initialization steps:
     20                  o Initialize the TS module using the BSP_TS_Init() function. This 
     21                    function includes the MSP layer hardware resources initialization and the
     22                    communication layer configuration to start the TS use. The LCD size properties
     23                    (x and y) are passed as parameters.
     24                  o If TS interrupt mode is desired, you must configure the TS interrupt mode
     25                    by calling the function BSP_TS_ITConfig(). The TS interrupt mode is generated
     26                    as an external interrupt whenever a touch is detected. 
     27                    The interrupt mode internally uses the IO functionalities driver driven by
     28                    the IO expander, to configure the IT line.
     29               
     30               + Touch screen use
     31                  o The touch screen state is captured whenever the function BSP_TS_GetState() is 
     32                    used. This function returns information about the last LCD touch occurred
     33                    in the TS_StateTypeDef structure.
     34                  o If TS interrupt mode is used, the function BSP_TS_ITGetStatus() is needed to get
     35                    the interrupt status. To clear the IT pending bits, you should call the 
     36                    function BSP_TS_ITClear().
     37                  o The IT is handled using the corresponding external interrupt IRQ handler,
     38                    the user IT callback treatment is implemented on the same external interrupt
     39                    callback.
     40            @endverbatim
     41            ******************************************************************************
     42            * @attention
     43            *
     44            * <h2><center>&copy; COPYRIGHT(c) 2015 STMicroelectronics</center></h2>
     45            *
     46            * Redistribution and use in source and binary forms, with or without modification,
     47            * are permitted provided that the following conditions are met:
     48            *   1. Redistributions of source code must retain the above copyright notice,
     49            *      this list of conditions and the following disclaimer.
     50            *   2. Redistributions in binary form must reproduce the above copyright notice,
     51            *      this list of conditions and the following disclaimer in the documentation
     52            *      and/or other materials provided with the distribution.
     53            *   3. Neither the name of STMicroelectronics nor the names of its contributors
     54            *      may be used to endorse or promote products derived from this software
     55            *      without specific prior written permission.
     56            *
     57            * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
     58            * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     59            * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     60            * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
     61            * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
     62            * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
     63            * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
     64            * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
     65            * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
     66            * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     67            *
     68            ******************************************************************************
     69            */ 
     70          
     71          /* Includes ------------------------------------------------------------------*/
     72          #include "stm32746g_discovery_ts.h"
     73          
     74          /** @addtogroup BSP
     75            * @{
     76            */
     77          
     78          /** @addtogroup STM32746G_DISCOVERY
     79            * @{
     80            */ 
     81            
     82          /** @defgroup STM32746G_DISCOVERY_TS STM32746G_DISCOVERY_TS
     83            * @{
     84            */   
     85          
     86          /** @defgroup STM32746G_DISCOVERY_TS_Private_Types_Definitions STM32746G_DISCOVERY_TS Types Definitions
     87            * @{
     88            */ 
     89          /**
     90            * @}
     91            */ 
     92          
     93          /** @defgroup STM32746G_DISCOVERY_TS_Private_Defines STM32746G_DISCOVERY_TS Types Defines
     94            * @{
     95            */ 
     96          /**
     97            * @}
     98            */ 
     99          
    100          /** @defgroup STM32746G_DISCOVERY_TS_Private_Macros STM32746G_DISCOVERY_TS Private Macros
    101            * @{
    102            */ 
    103          /**
    104            * @}
    105            */
    106          
    107          /** @defgroup STM32746G_DISCOVERY_TS_Imported_Variables STM32746G_DISCOVERY_TS Imported Variables
    108            * @{
    109            */
    110            /**
    111              * @}
    112              */
    113          
    114          /** @defgroup STM32746G_DISCOVERY_TS_Private_Variables STM32746G_DISCOVERY_TS Private Variables
    115            * @{
    116            */ 
    117          static TS_DrvTypeDef *tsDriver;
    118          static uint16_t tsXBoundary, tsYBoundary; 
    119          static uint8_t  tsOrientation;
    120          static uint8_t  I2cAddress;
    121          /**
    122            * @}
    123            */ 
    124          
    125          /** @defgroup STM32746G_DISCOVERY_TS_Private_Function_Prototypes STM32746G_DISCOVERY_TS Private Function Prototypes
    126            * @{
    127            */ 
    128          /**
    129            * @}
    130            */ 
    131          
    132          /** @defgroup STM32746G_DISCOVERY_TS_Exported_Functions STM32746G_DISCOVERY_TS Exported Functions
    133            * @{
    134            */ 
    135          
    136          /**
    137            * @brief  Initializes and configures the touch screen functionalities and 
    138            *         configures all necessary hardware resources (GPIOs, I2C, clocks..).
    139            * @param  ts_SizeX: Maximum X size of the TS area on LCD
    140            * @param  ts_SizeY: Maximum Y size of the TS area on LCD
    141            * @retval TS_OK if all initializations are OK. Other value if error.
    142            */

   \                                 In section .text, align 2, keep-with-next
    143          uint8_t BSP_TS_Init(uint16_t ts_SizeX, uint16_t ts_SizeY)
    144          {
   \                     BSP_TS_Init: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
    145            uint8_t status = TS_OK;
   \   00000002   0x2400             MOVS     R4,#+0
    146            tsXBoundary = ts_SizeX;
   \   00000004   0x....             LDR.N    R5,??DataTable5
   \   00000006   0x8068             STRH     R0,[R5, #+2]
    147            tsYBoundary = ts_SizeY;
   \   00000008   0x80A9             STRH     R1,[R5, #+4]
    148            
    149            /* Read ID and verify if the touch screen driver is ready */
    150            ft5336_ts_drv.Init(TS_I2C_ADDRESS);
   \   0000000A   0x....             LDR.N    R6,??DataTable5_1
   \   0000000C   0x2070             MOVS     R0,#+112
   \   0000000E   0x6831             LDR      R1,[R6, #+0]
   \   00000010   0x4788             BLX      R1
    151            if(ft5336_ts_drv.ReadID(TS_I2C_ADDRESS) == FT5336_ID_VALUE)
   \   00000012   0x2070             MOVS     R0,#+112
   \   00000014   0x6871             LDR      R1,[R6, #+4]
   \   00000016   0x4788             BLX      R1
   \   00000018   0x2851             CMP      R0,#+81
   \   0000001A   0xD108             BNE.N    ??BSP_TS_Init_0
    152            { 
    153              /* Initialize the TS driver structure */
    154              tsDriver = &ft5336_ts_drv;
   \   0000001C   0x60AE             STR      R6,[R5, #+8]
    155              I2cAddress = TS_I2C_ADDRESS;
   \   0000001E   0x2070             MOVS     R0,#+112
   \   00000020   0x7068             STRB     R0,[R5, #+1]
    156              tsOrientation = TS_SWAP_XY;
   \   00000022   0x2008             MOVS     R0,#+8
   \   00000024   0x7028             STRB     R0,[R5, #+0]
    157          
    158              /* Initialize the TS driver */
    159              tsDriver->Start(I2cAddress);
   \   00000026   0x2070             MOVS     R0,#+112
   \   00000028   0x68F1             LDR      R1,[R6, #+12]
   \   0000002A   0x4788             BLX      R1
   \   0000002C   0xE000             B.N      ??BSP_TS_Init_1
    160            }
    161            else
    162            {
    163              status = TS_DEVICE_NOT_FOUND;
   \                     ??BSP_TS_Init_0: (+1)
   \   0000002E   0x2403             MOVS     R4,#+3
    164            }
    165          
    166            return status;
   \                     ??BSP_TS_Init_1: (+1)
   \   00000030   0x4620             MOV      R0,R4
   \   00000032   0xBD70             POP      {R4-R6,PC}       ;; return
    167          }
    168          
    169          /**
    170            * @brief  DeInitializes the TouchScreen.
    171            * @retval TS state
    172            */

   \                                 In section .text, align 2, keep-with-next
    173          uint8_t BSP_TS_DeInit(void)
    174          { 
    175            /* Actually ts_driver does not provide a DeInit function */
    176            return TS_OK;
   \                     BSP_TS_DeInit: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x4770             BX       LR               ;; return
    177          }
    178          
    179          /**
    180            * @brief  Configures and enables the touch screen interrupts.
    181            * @retval TS_OK if all initializations are OK. Other value if error.
    182            */

   \                                 In section .text, align 2, keep-with-next
    183          uint8_t BSP_TS_ITConfig(void)
    184          {
   \                     BSP_TS_ITConfig: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB085             SUB      SP,SP,#+20
    185            GPIO_InitTypeDef gpio_init_structure;
    186          
    187            /* Configure Interrupt mode for SD detection pin */
    188            gpio_init_structure.Pin = TS_INT_PIN;
   \   00000004   0xF44F 0x5000      MOV      R0,#+8192
   \   00000008   0x9000             STR      R0,[SP, #+0]
    189            gpio_init_structure.Pull = GPIO_NOPULL;
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x9002             STR      R0,[SP, #+8]
    190            gpio_init_structure.Speed = GPIO_SPEED_FAST;
   \   0000000E   0x2002             MOVS     R0,#+2
   \   00000010   0x9003             STR      R0,[SP, #+12]
    191            gpio_init_structure.Mode = GPIO_MODE_IT_RISING;
   \   00000012   0x....             LDR.N    R0,??DataTable5_2  ;; 0x10110000
   \   00000014   0x9001             STR      R0,[SP, #+4]
    192            HAL_GPIO_Init(TS_INT_GPIO_PORT, &gpio_init_structure);
   \   00000016   0x4669             MOV      R1,SP
   \   00000018   0x....             LDR.N    R0,??DataTable5_3  ;; 0x40022000
   \   0000001A   0x.... 0x....      BL       HAL_GPIO_Init
    193          
    194            /* Enable and set Touch screen EXTI Interrupt to the lowest priority */
    195            HAL_NVIC_SetPriority((IRQn_Type)(TS_INT_EXTI_IRQn), 0x0F, 0x00);
   \   0000001E   0x2200             MOVS     R2,#+0
   \   00000020   0x210F             MOVS     R1,#+15
   \   00000022   0x2028             MOVS     R0,#+40
   \   00000024   0x.... 0x....      BL       HAL_NVIC_SetPriority
    196            HAL_NVIC_EnableIRQ((IRQn_Type)(TS_INT_EXTI_IRQn));
   \   00000028   0x2028             MOVS     R0,#+40
   \   0000002A   0x.... 0x....      BL       HAL_NVIC_EnableIRQ
    197          
    198            /* Enable the TS ITs */
    199            tsDriver->EnableIT(I2cAddress);
   \   0000002E   0x....             LDR.N    R1,??DataTable5
   \   00000030   0x7848             LDRB     R0,[R1, #+1]
   \   00000032   0x6889             LDR      R1,[R1, #+8]
   \   00000034   0x6989             LDR      R1,[R1, #+24]
   \   00000036   0x4788             BLX      R1
    200          
    201            return TS_OK;  
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0xB005             ADD      SP,SP,#+20
   \   0000003C   0xBD00             POP      {PC}             ;; return
    202          }
    203          
    204          /**
    205            * @brief  Gets the touch screen interrupt status.
    206            * @retval TS_OK if all initializations are OK. Other value if error.
    207            */

   \                                 In section .text, align 2, keep-with-next
    208          uint8_t BSP_TS_ITGetStatus(void)
    209          {
    210            /* Return the TS IT status */
    211            return (tsDriver->GetITStatus(I2cAddress));
   \                     BSP_TS_ITGetStatus: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable5
   \   00000002   0x7848             LDRB     R0,[R1, #+1]
   \   00000004   0x6889             LDR      R1,[R1, #+8]
   \   00000006   0x6A09             LDR      R1,[R1, #+32]
   \   00000008   0x4708             BX       R1
    212          }
    213          
    214          /**
    215            * @brief  Returns status and positions of the touch screen.
    216            * @param  TS_State: Pointer to touch screen current state structure
    217            * @retval TS_OK if all initializations are OK. Other value if error.
    218            */

   \                                 In section .text, align 4, keep-with-next
    219          uint8_t BSP_TS_GetState(TS_StateTypeDef *TS_State)
    220          {
   \                     BSP_TS_GetState: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB091             SUB      SP,SP,#+68
   \   00000004   0x4604             MOV      R4,R0
    221            static uint32_t _x[TS_MAX_NB_TOUCH] = {0, 0};
    222            static uint32_t _y[TS_MAX_NB_TOUCH] = {0, 0};
    223            uint8_t ts_status = TS_OK;
   \   00000006   0x2600             MOVS     R6,#+0
    224            uint16_t x[TS_MAX_NB_TOUCH];
    225            uint16_t y[TS_MAX_NB_TOUCH];
    226            uint16_t brute_x[TS_MAX_NB_TOUCH];
    227            uint16_t brute_y[TS_MAX_NB_TOUCH];
    228            uint16_t x_diff;
    229            uint16_t y_diff;
    230            uint32_t index;
    231          #if (TS_MULTI_TOUCH_SUPPORTED == 1)
    232            uint32_t weight = 0;
   \   00000008   0x4630             MOV      R0,R6
   \   0000000A   0x9003             STR      R0,[SP, #+12]
    233            uint32_t area = 0;
   \   0000000C   0x9002             STR      R0,[SP, #+8]
    234            uint32_t event = 0;
   \   0000000E   0x9001             STR      R0,[SP, #+4]
    235          #endif /* TS_MULTI_TOUCH_SUPPORTED == 1 */
    236          
    237            /* Check and update the number of touches active detected */
    238            TS_State->touchDetected = tsDriver->DetectTouch(I2cAddress);
   \   00000010   0x....             LDR.N    R5,??DataTable5
   \   00000012   0x7868             LDRB     R0,[R5, #+1]
   \   00000014   0x68A9             LDR      R1,[R5, #+8]
   \   00000016   0x6909             LDR      R1,[R1, #+16]
   \   00000018   0x4788             BLX      R1
   \   0000001A   0x7020             STRB     R0,[R4, #+0]
    239            
    240            if(TS_State->touchDetected)
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xF000 0x8095      BEQ.W    ??BSP_TS_GetState_1
    241            {
    242              for(index=0; index < TS_State->touchDetected; index++)
   \   00000022   0xE002             B.N      ??BSP_TS_GetState_2
    243              {
    244                /* Get each touch coordinates */
    245                tsDriver->GetXY(I2cAddress, &(brute_x[index]), &(brute_y[index]));
    246          
    247                if(tsOrientation == TS_SWAP_NONE)
    248                {
    249                  x[index] = brute_x[index];
    250                  y[index] = brute_y[index];
    251                }
    252          
    253                if(tsOrientation & TS_SWAP_X)
    254                {
    255                  x[index] = 4096 - brute_x[index];
    256                }
    257          
    258                if(tsOrientation & TS_SWAP_Y)
    259                {
    260                  y[index] = 4096 - brute_y[index];
    261                }
    262          
    263                if(tsOrientation & TS_SWAP_XY)
    264                {
    265                  y[index] = brute_x[index];
    266                  x[index] = brute_y[index];
    267                }
    268          
    269                x_diff = x[index] > _x[index]? (x[index] - _x[index]): (_x[index] - x[index]);
    270                y_diff = y[index] > _y[index]? (y[index] - _y[index]): (_y[index] - y[index]);
    271          
    272                if ((x_diff + y_diff) > 5)
    273                {
    274                  _x[index] = x[index];
    275                  _y[index] = y[index];
    276                }
    277          
    278                if(I2cAddress == FT5336_I2C_SLAVE_ADDRESS)
    279                {
    280                  TS_State->touchX[index] = x[index];
    281                  TS_State->touchY[index] = y[index];
    282                }
    283                else
    284                {
    285                  /* 2^12 = 4096 : indexes are expressed on a dynamic of 4096 */
    286                  TS_State->touchX[index] = (tsXBoundary * _x[index]) >> 12;
    287                  TS_State->touchY[index] = (tsYBoundary * _y[index]) >> 12;
    288                }
    289          
    290          #if (TS_MULTI_TOUCH_SUPPORTED == 1)
    291          
    292                /* Get touch info related to the current touch */
    293                ft5336_TS_GetTouchInfo(I2cAddress, index, &weight, &area, &event);
    294          
    295                /* Update TS_State structure */
    296                TS_State->touchWeight[index] = weight;
    297                TS_State->touchArea[index]   = area;
    298          
    299                /* Remap touch event */
    300                switch(event)
    301                {
    302                  case FT5336_TOUCH_EVT_FLAG_PRESS_DOWN	:
    303                    TS_State->touchEventId[index] = TOUCH_EVENT_PRESS_DOWN;
    304                    break;
    305                  case FT5336_TOUCH_EVT_FLAG_LIFT_UP :
    306                    TS_State->touchEventId[index] = TOUCH_EVENT_LIFT_UP;
    307                    break;
    308                  case FT5336_TOUCH_EVT_FLAG_CONTACT :
    309                    TS_State->touchEventId[index] = TOUCH_EVENT_CONTACT;
    310                    break;
    311                  case FT5336_TOUCH_EVT_FLAG_NO_EVENT :
    312                    TS_State->touchEventId[index] = TOUCH_EVENT_NO_EVT;
   \                     ??BSP_TS_GetState_3: (+1)
   \   00000024   0x2100             MOVS     R1,#+0
   \   00000026   0x76C1             STRB     R1,[R0, #+27]
    313                    break;
   \                     ??BSP_TS_GetState_4: (+1)
   \   00000028   0x1C76             ADDS     R6,R6,#+1
   \                     ??BSP_TS_GetState_2: (+1)
   \   0000002A   0x7820             LDRB     R0,[R4, #+0]
   \   0000002C   0x4286             CMP      R6,R0
   \   0000002E   0xF080 0x8089      BCS.W    ??BSP_TS_GetState_5
   \   00000032   0xA804             ADD      R0,SP,#+16
   \   00000034   0xEB00 0x0246      ADD      R2,R0,R6, LSL #+1
   \   00000038   0xA807             ADD      R0,SP,#+28
   \   0000003A   0xEB00 0x0146      ADD      R1,R0,R6, LSL #+1
   \   0000003E   0x7868             LDRB     R0,[R5, #+1]
   \   00000040   0x68AB             LDR      R3,[R5, #+8]
   \   00000042   0x695B             LDR      R3,[R3, #+20]
   \   00000044   0x4798             BLX      R3
   \   00000046   0x7829             LDRB     R1,[R5, #+0]
   \   00000048   0xA80A             ADD      R0,SP,#+40
   \   0000004A   0xAA0D             ADD      R2,SP,#+52
   \   0000004C   0x2901             CMP      R1,#+1
   \   0000004E   0xD109             BNE.N    ??BSP_TS_GetState_6
   \   00000050   0xAB07             ADD      R3,SP,#+28
   \   00000052   0xF833 0x3016      LDRH     R3,[R3, R6, LSL #+1]
   \   00000056   0xF822 0x3016      STRH     R3,[R2, R6, LSL #+1]
   \   0000005A   0xAB04             ADD      R3,SP,#+16
   \   0000005C   0xF833 0x3016      LDRH     R3,[R3, R6, LSL #+1]
   \   00000060   0xF820 0x3016      STRH     R3,[R0, R6, LSL #+1]
   \                     ??BSP_TS_GetState_6: (+1)
   \   00000064   0x078B             LSLS     R3,R1,#+30
   \   00000066   0xD506             BPL.N    ??BSP_TS_GetState_7
   \   00000068   0xAB07             ADD      R3,SP,#+28
   \   0000006A   0xF833 0x3016      LDRH     R3,[R3, R6, LSL #+1]
   \   0000006E   0xF5C3 0x5380      RSB      R3,R3,#+4096
   \   00000072   0xF822 0x3016      STRH     R3,[R2, R6, LSL #+1]
   \                     ??BSP_TS_GetState_7: (+1)
   \   00000076   0x074B             LSLS     R3,R1,#+29
   \   00000078   0xD506             BPL.N    ??BSP_TS_GetState_8
   \   0000007A   0xAB04             ADD      R3,SP,#+16
   \   0000007C   0xF833 0x3016      LDRH     R3,[R3, R6, LSL #+1]
   \   00000080   0xF5C3 0x5380      RSB      R3,R3,#+4096
   \   00000084   0xF820 0x3016      STRH     R3,[R0, R6, LSL #+1]
   \                     ??BSP_TS_GetState_8: (+1)
   \   00000088   0x0709             LSLS     R1,R1,#+28
   \   0000008A   0xD509             BPL.N    ??BSP_TS_GetState_9
   \   0000008C   0xA907             ADD      R1,SP,#+28
   \   0000008E   0xF831 0x1016      LDRH     R1,[R1, R6, LSL #+1]
   \   00000092   0xF820 0x1016      STRH     R1,[R0, R6, LSL #+1]
   \   00000096   0xA904             ADD      R1,SP,#+16
   \   00000098   0xF831 0x1016      LDRH     R1,[R1, R6, LSL #+1]
   \   0000009C   0xF822 0x1016      STRH     R1,[R2, R6, LSL #+1]
   \                     ??BSP_TS_GetState_9: (+1)
   \   000000A0   0xF832 0x1016      LDRH     R1,[R2, R6, LSL #+1]
   \   000000A4   0x460B             MOV      R3,R1
   \   000000A6   0xEB05 0x0286      ADD      R2,R5,R6, LSL #+2
   \   000000AA   0x68D7             LDR      R7,[R2, #+12]
   \   000000AC   0x429F             CMP      R7,R3
   \   000000AE   0xD201             BCS.N    ??BSP_TS_GetState_10
   \   000000B0   0x1BCF             SUBS     R7,R1,R7
   \   000000B2   0xE000             B.N      ??BSP_TS_GetState_11
   \                     ??BSP_TS_GetState_10: (+1)
   \   000000B4   0x1A7F             SUBS     R7,R7,R1
   \                     ??BSP_TS_GetState_11: (+1)
   \   000000B6   0xF830 0xC016      LDRH     R12,[R0, R6, LSL #+1]
   \   000000BA   0x4660             MOV      R0,R12
   \   000000BC   0xF8D2 0xE020      LDR      LR,[R2, #+32]
   \   000000C0   0x4586             CMP      LR,R0
   \   000000C2   0xD202             BCS.N    ??BSP_TS_GetState_12
   \   000000C4   0xEBAC 0x0E0E      SUB      LR,R12,LR
   \   000000C8   0xE001             B.N      ??BSP_TS_GetState_13
   \                     ??BSP_TS_GetState_12: (+1)
   \   000000CA   0xEBAE 0x0E0C      SUB      LR,LR,R12
   \                     ??BSP_TS_GetState_13: (+1)
   \   000000CE   0xFA1F 0xFE8E      UXTH     LR,LR
   \   000000D2   0xFA1E 0xF787      UXTAH    R7,LR,R7
   \   000000D6   0x2F06             CMP      R7,#+6
   \   000000D8   0xDB01             BLT.N    ??BSP_TS_GetState_14
   \   000000DA   0x60D3             STR      R3,[R2, #+12]
   \   000000DC   0x6210             STR      R0,[R2, #+32]
   \                     ??BSP_TS_GetState_14: (+1)
   \   000000DE   0xEB04 0x0346      ADD      R3,R4,R6, LSL #+1
   \   000000E2   0x7868             LDRB     R0,[R5, #+1]
   \   000000E4   0x2870             CMP      R0,#+112
   \   000000E6   0xD103             BNE.N    ??BSP_TS_GetState_15
   \   000000E8   0x8059             STRH     R1,[R3, #+2]
   \   000000EA   0xF8A3 0xC00C      STRH     R12,[R3, #+12]
   \   000000EE   0xE009             B.N      ??BSP_TS_GetState_16
   \                     ??BSP_TS_GetState_15: (+1)
   \   000000F0   0x8869             LDRH     R1,[R5, #+2]
   \   000000F2   0x68D7             LDR      R7,[R2, #+12]
   \   000000F4   0x4379             MULS     R1,R7,R1
   \   000000F6   0x0B09             LSRS     R1,R1,#+12
   \   000000F8   0x8059             STRH     R1,[R3, #+2]
   \   000000FA   0x88A9             LDRH     R1,[R5, #+4]
   \   000000FC   0x6A12             LDR      R2,[R2, #+32]
   \   000000FE   0x4351             MULS     R1,R2,R1
   \   00000100   0x0B09             LSRS     R1,R1,#+12
   \   00000102   0x8199             STRH     R1,[R3, #+12]
   \                     ??BSP_TS_GetState_16: (+1)
   \   00000104   0xA901             ADD      R1,SP,#+4
   \   00000106   0x9100             STR      R1,[SP, #+0]
   \   00000108   0xAB02             ADD      R3,SP,#+8
   \   0000010A   0xAA03             ADD      R2,SP,#+12
   \   0000010C   0x4631             MOV      R1,R6
   \   0000010E   0x.... 0x....      BL       ft5336_TS_GetTouchInfo
   \   00000112   0x1930             ADDS     R0,R6,R4
   \   00000114   0x9903             LDR      R1,[SP, #+12]
   \   00000116   0x7581             STRB     R1,[R0, #+22]
   \   00000118   0x9902             LDR      R1,[SP, #+8]
   \   0000011A   0xF880 0x1020      STRB     R1,[R0, #+32]
   \   0000011E   0x9901             LDR      R1,[SP, #+4]
   \   00000120   0x2903             CMP      R1,#+3
   \   00000122   0xF63F 0xAF81      BHI.W    ??BSP_TS_GetState_4
   \   00000126   0xE8DF 0xF001      TBB      [PC, R1]
   \                     ??BSP_TS_GetState_0:
   \   0000012A   0x04 0x07          DC8      0x4,0x7,0xA,0x3
   \              0x0A 0x03    
   \                     ??BSP_TS_GetState_17: (+1)
   \   0000012E   0xE77B             B.N      ??BSP_TS_GetState_4
   \                     ??BSP_TS_GetState_18: (+1)
   \   00000130   0xE778             B.N      ??BSP_TS_GetState_3
   \                     ??BSP_TS_GetState_19: (+1)
   \   00000132   0x2101             MOVS     R1,#+1
   \   00000134   0x76C1             STRB     R1,[R0, #+27]
   \   00000136   0xE777             B.N      ??BSP_TS_GetState_4
   \                     ??BSP_TS_GetState_20: (+1)
   \   00000138   0x2102             MOVS     R1,#+2
   \   0000013A   0x76C1             STRB     R1,[R0, #+27]
   \   0000013C   0xE774             B.N      ??BSP_TS_GetState_4
   \                     ??BSP_TS_GetState_21: (+1)
   \   0000013E   0x2103             MOVS     R1,#+3
   \   00000140   0x76C1             STRB     R1,[R0, #+27]
   \   00000142   0xE771             B.N      ??BSP_TS_GetState_4
    314                  default :
    315                    ts_status = TS_ERROR;
    316                    break;
    317                } /* of switch(event) */
    318          
    319          #endif /* TS_MULTI_TOUCH_SUPPORTED == 1 */
    320          
    321              } /* of for(index=0; index < TS_State->touchDetected; index++) */
    322          
    323          #if (TS_MULTI_TOUCH_SUPPORTED == 1)
    324              /* Get gesture Id */
    325              ts_status = BSP_TS_Get_GestureId(TS_State);
   \                     ??BSP_TS_GetState_5: (+1)
   \   00000144   0x4620             MOV      R0,R4
   \   00000146   0x.... 0x....      BL       BSP_TS_Get_GestureId
   \   0000014A   0x4606             MOV      R6,R0
    326          #endif /* TS_MULTI_TOUCH_SUPPORTED == 1 */
    327          
    328            } /* end of if(TS_State->touchDetected != 0) */
    329          
    330            return (ts_status);
   \                     ??BSP_TS_GetState_1: (+1)
   \   0000014C   0x4630             MOV      R0,R6
   \   0000014E   0xB011             ADD      SP,SP,#+68
   \   00000150   0xBDF0             POP      {R4-R7,PC}       ;; return
    331          }

   \                                 In section .bss, align 4
   \                     tsOrientation:
   \   00000000                      DS8 1
   \   00000001                      DS8 1
   \   00000002                      DS8 2
   \   00000004                      DS8 2
   \   00000006                      DS8 2
   \   00000008                      DS8 4
   \   0000000C                      DS8 20
   \   00000020                      DS8 20
    332          
    333          #if (TS_MULTI_TOUCH_SUPPORTED == 1)
    334          /**
    335            * @brief  Update gesture Id following a touch detected.
    336            * @param  TS_State: Pointer to touch screen current state structure
    337            * @retval TS_OK if all initializations are OK. Other value if error.
    338            */

   \                                 In section .text, align 2, keep-with-next
    339          uint8_t BSP_TS_Get_GestureId(TS_StateTypeDef *TS_State)
    340          {
   \                     BSP_TS_Get_GestureId: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
    341            uint32_t gestureId = 0;
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x9000             STR      R0,[SP, #+0]
    342            uint8_t  ts_status = TS_OK;
   \   00000008   0x4605             MOV      R5,R0
    343          
    344            /* Get gesture Id */
    345            ft5336_TS_GetGestureID(I2cAddress, &gestureId);
   \   0000000A   0x4669             MOV      R1,SP
   \   0000000C   0x....             LDR.N    R0,??DataTable5
   \   0000000E   0x7840             LDRB     R0,[R0, #+1]
   \   00000010   0x.... 0x....      BL       ft5336_TS_GetGestureID
    346          
    347            /* Remap gesture Id to a TS_GestureIdTypeDef value */
    348            switch(gestureId)
   \   00000014   0x9800             LDR      R0,[SP, #+0]
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD00C             BEQ.N    ??BSP_TS_Get_GestureId_0
   \   0000001A   0x2810             CMP      R0,#+16
   \   0000001C   0xD00D             BEQ.N    ??BSP_TS_Get_GestureId_1
   \   0000001E   0x2814             CMP      R0,#+20
   \   00000020   0xD00E             BEQ.N    ??BSP_TS_Get_GestureId_2
   \   00000022   0x2818             CMP      R0,#+24
   \   00000024   0xD00F             BEQ.N    ??BSP_TS_Get_GestureId_3
   \   00000026   0x281C             CMP      R0,#+28
   \   00000028   0xD010             BEQ.N    ??BSP_TS_Get_GestureId_4
   \   0000002A   0x2840             CMP      R0,#+64
   \   0000002C   0xD011             BEQ.N    ??BSP_TS_Get_GestureId_5
   \   0000002E   0x2849             CMP      R0,#+73
   \   00000030   0xD012             BEQ.N    ??BSP_TS_Get_GestureId_6
   \   00000032   0xE014             B.N      ??BSP_TS_Get_GestureId_7
    349            {
    350              case FT5336_GEST_ID_NO_GESTURE :
    351                TS_State->gestureId = GEST_ID_NO_GESTURE;
   \                     ??BSP_TS_Get_GestureId_0: (+1)
   \   00000034   0x4628             MOV      R0,R5
   \   00000036   0x62A0             STR      R0,[R4, #+40]
    352                break;
   \   00000038   0xE012             B.N      ??BSP_TS_Get_GestureId_8
    353              case FT5336_GEST_ID_MOVE_UP :
    354                TS_State->gestureId = GEST_ID_MOVE_UP;
   \                     ??BSP_TS_Get_GestureId_1: (+1)
   \   0000003A   0x2001             MOVS     R0,#+1
   \   0000003C   0x62A0             STR      R0,[R4, #+40]
    355                break;
   \   0000003E   0xE00F             B.N      ??BSP_TS_Get_GestureId_8
    356              case FT5336_GEST_ID_MOVE_RIGHT :
    357                TS_State->gestureId = GEST_ID_MOVE_RIGHT;
   \                     ??BSP_TS_Get_GestureId_2: (+1)
   \   00000040   0x2002             MOVS     R0,#+2
   \   00000042   0x62A0             STR      R0,[R4, #+40]
    358                break;
   \   00000044   0xE00C             B.N      ??BSP_TS_Get_GestureId_8
    359              case FT5336_GEST_ID_MOVE_DOWN :
    360                TS_State->gestureId = GEST_ID_MOVE_DOWN;
   \                     ??BSP_TS_Get_GestureId_3: (+1)
   \   00000046   0x2003             MOVS     R0,#+3
   \   00000048   0x62A0             STR      R0,[R4, #+40]
    361                break;
   \   0000004A   0xE009             B.N      ??BSP_TS_Get_GestureId_8
    362              case FT5336_GEST_ID_MOVE_LEFT :
    363                TS_State->gestureId = GEST_ID_MOVE_LEFT;
   \                     ??BSP_TS_Get_GestureId_4: (+1)
   \   0000004C   0x2004             MOVS     R0,#+4
   \   0000004E   0x62A0             STR      R0,[R4, #+40]
    364                break;
   \   00000050   0xE006             B.N      ??BSP_TS_Get_GestureId_8
    365              case FT5336_GEST_ID_ZOOM_IN :
    366                TS_State->gestureId = GEST_ID_ZOOM_IN;
   \                     ??BSP_TS_Get_GestureId_5: (+1)
   \   00000052   0x2005             MOVS     R0,#+5
   \   00000054   0x62A0             STR      R0,[R4, #+40]
    367                break;
   \   00000056   0xE003             B.N      ??BSP_TS_Get_GestureId_8
    368              case FT5336_GEST_ID_ZOOM_OUT :
    369                TS_State->gestureId = GEST_ID_ZOOM_OUT;
   \                     ??BSP_TS_Get_GestureId_6: (+1)
   \   00000058   0x2006             MOVS     R0,#+6
   \   0000005A   0x62A0             STR      R0,[R4, #+40]
    370                break;
   \   0000005C   0xE000             B.N      ??BSP_TS_Get_GestureId_8
    371              default :
    372                ts_status = TS_ERROR;
   \                     ??BSP_TS_Get_GestureId_7: (+1)
   \   0000005E   0x2501             MOVS     R5,#+1
    373                break;
    374            } /* of switch(gestureId) */
    375          
    376            return(ts_status);
   \                     ??BSP_TS_Get_GestureId_8: (+1)
   \   00000060   0x4628             MOV      R0,R5
   \   00000062   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    377          }
    378          #endif /* TS_MULTI_TOUCH_SUPPORTED == 1 */
    379          
    380          /**
    381            * @brief  Clears all touch screen interrupts.
    382            */

   \                                 In section .text, align 2, keep-with-next
    383          void BSP_TS_ITClear(void)
    384          {
    385            /* Clear TS IT pending bits */
    386            tsDriver->ClearIT(I2cAddress); 
   \                     BSP_TS_ITClear: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable5
   \   00000002   0x7848             LDRB     R0,[R1, #+1]
   \   00000004   0x6889             LDR      R1,[R1, #+8]
   \   00000006   0x69C9             LDR      R1,[R1, #+28]
   \   00000008   0x4708             BX       R1
    387          }
    388          
    389          
    390          /** @defgroup STM32756G_DISCOVERY_TS_Private_Functions TS Private Functions
    391            * @{
    392            */
    393          
    394          
    395          /**
    396            * @brief  Function used to reset all touch data before a new acquisition
    397            *         of touch information.
    398            * @param  TS_State: Pointer to touch screen current state structure
    399            * @retval TS_OK if OK, TE_ERROR if problem found.
    400            */

   \                                 In section .text, align 2, keep-with-next
    401          uint8_t BSP_TS_ResetTouchData(TS_StateTypeDef *TS_State)
    402          {
    403            uint8_t ts_status = TS_ERROR;
   \                     BSP_TS_ResetTouchData: (+1)
   \   00000000   0x2101             MOVS     R1,#+1
    404            uint32_t index;
    405          
    406            if (TS_State != (TS_StateTypeDef *)NULL)
   \   00000002   0x2800             CMP      R0,#+0
   \   00000004   0xD011             BEQ.N    ??BSP_TS_ResetTouchData_0
    407            {
    408              TS_State->gestureId = GEST_ID_NO_GESTURE;
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x6281             STR      R1,[R0, #+40]
    409              TS_State->touchDetected = 0;
   \   0000000A   0x7001             STRB     R1,[R0, #+0]
    410          
    411              for(index = 0; index < TS_MAX_NB_TOUCH; index++)
   \   0000000C   0x460B             MOV      R3,R1
   \   0000000E   0xE009             B.N      ??BSP_TS_ResetTouchData_1
    412              {
    413                TS_State->touchX[index]       = 0;
   \                     ??BSP_TS_ResetTouchData_2: (+1)
   \   00000010   0xEB00 0x0241      ADD      R2,R0,R1, LSL #+1
   \   00000014   0x8053             STRH     R3,[R2, #+2]
    414                TS_State->touchY[index]       = 0;
   \   00000016   0x8193             STRH     R3,[R2, #+12]
    415                TS_State->touchArea[index]    = 0;
   \   00000018   0x180A             ADDS     R2,R1,R0
   \   0000001A   0xF882 0x3020      STRB     R3,[R2, #+32]
    416                TS_State->touchEventId[index] = TOUCH_EVENT_NO_EVT;
   \   0000001E   0x76D3             STRB     R3,[R2, #+27]
    417                TS_State->touchWeight[index]  = 0;
   \   00000020   0x7593             STRB     R3,[R2, #+22]
    418              }
   \   00000022   0x1C49             ADDS     R1,R1,#+1
   \                     ??BSP_TS_ResetTouchData_1: (+1)
   \   00000024   0x2905             CMP      R1,#+5
   \   00000026   0xD3F3             BCC.N    ??BSP_TS_ResetTouchData_2
    419          
    420              ts_status = TS_OK;
   \   00000028   0x4619             MOV      R1,R3
    421          
    422            } /* of if (TS_State != (TS_StateTypeDef *)NULL) */
    423          
    424            return (ts_status);
   \                     ??BSP_TS_ResetTouchData_0: (+1)
   \   0000002A   0x4608             MOV      R0,R1
   \   0000002C   0x4770             BX       LR               ;; return
    425          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5:
   \   00000000   0x........         DC32     tsOrientation

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_1:
   \   00000000   0x........         DC32     ft5336_ts_drv

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_2:
   \   00000000   0x10110000         DC32     0x10110000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_3:
   \   00000000   0x40022000         DC32     0x40022000
    426          
    427          /**
    428            * @}
    429            */ 
    430          
    431          /**
    432            * @}
    433            */ 
    434          
    435          /**
    436            * @}
    437            */ 
    438          
    439          /**
    440            * @}
    441            */  
    442          
    443          /**
    444            * @}
    445            */
    446          
    447          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   BSP_TS_DeInit
      88   BSP_TS_GetState
        88   -- Indirect call
        88   -> BSP_TS_Get_GestureId
        88   -> ft5336_TS_GetTouchInfo
      16   BSP_TS_Get_GestureId
        16   -> ft5336_TS_GetGestureID
       0   BSP_TS_ITClear
         0   -- Indirect call
      24   BSP_TS_ITConfig
        24   -- Indirect call
        24   -> HAL_GPIO_Init
        24   -> HAL_NVIC_EnableIRQ
        24   -> HAL_NVIC_SetPriority
       0   BSP_TS_ITGetStatus
         0   -- Indirect call
      16   BSP_TS_Init
        16   -- Indirect call
       0   BSP_TS_ResetTouchData


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable5
       4  ??DataTable5_1
       4  ??DataTable5_2
       4  ??DataTable5_3
       4  BSP_TS_DeInit
     338  BSP_TS_GetState
     100  BSP_TS_Get_GestureId
      10  BSP_TS_ITClear
      62  BSP_TS_ITConfig
      10  BSP_TS_ITGetStatus
      52  BSP_TS_Init
      46  BSP_TS_ResetTouchData
      52  tsOrientation
          I2cAddress
          tsXBoundary
          tsYBoundary
          tsDriver
          _x
          _y

 
  52 bytes in section .bss
 638 bytes in section .text
 
 638 bytes of CODE memory
  52 bytes of DATA memory

Errors: none
Warnings: none
