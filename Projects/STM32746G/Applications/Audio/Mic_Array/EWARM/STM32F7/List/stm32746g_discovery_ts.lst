###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.2.10312/W32 for ARM       22/Dec/2015  00:06:26
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Drivers\BSP\STM32746G-Discovery\stm32746g_discovery_ts.c
#    Command line =  
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Drivers\BSP\STM32746G-Discovery\stm32746g_discovery_ts.c
#        -D USE_HAL_DRIVER -D STM32F746xx -D USE_STM32746G_DISCO -D
#        USE_IOEXPANDER -D USE_USB_FS -lC
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
#        -lA
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
#        -o
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj
#        --debug --endian=little --cpu=Cortex-M7 -e --fpu=VFPv5_sp
#        --dlib_config "D:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Full.h" -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\Inc\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\CMSIS\Device\ST\STM32F7xx\Include\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\STM32F7xx_HAL_Driver\Inc\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\STM32746G-Discovery\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\Components\Common\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Log\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Fonts\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\CPU\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_Device_Library\Core\Inc\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Core\Inc\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Class\MSC\Inc\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\drivers\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_Audio\Addons\PDM\
#        -Ohz --use_c++_inline --require_prototypes -I "D:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.3\arm\CMSIS\Include\" -D
#        ARM_MATH_CM7
#    List file    =  
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List\stm32746g_discovery_ts.lst
#    Object file  =  
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj\stm32746g_discovery_ts.o
#
###############################################################################

H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Drivers\BSP\STM32746G-Discovery\stm32746g_discovery_ts.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32746g_discovery_ts.c
      4            * @author  MCD Application Team
      5            * @version V1.0.0
      6            * @date    25-June-2015
      7            * @brief   This file provides a set of functions needed to manage the Touch 
      8            *          Screen on STM32746G-Discovery board.
      9            @verbatim
     10             1. How To use this driver:
     11             --------------------------
     12                - This driver is used to drive the touch screen module of the STM32746G-Discovery
     13                  board on the RK043FN48H-CT672B 480x272 LCD screen with capacitive touch screen.
     14                - The FT5336 component driver must be included in project files according to
     15                  the touch screen driver present on this board.
     16             
     17             2. Driver description:
     18             ---------------------
     19               + Initialization steps:
     20                  o Initialize the TS module using the BSP_TS_Init() function. This 
     21                    function includes the MSP layer hardware resources initialization and the
     22                    communication layer configuration to start the TS use. The LCD size properties
     23                    (x and y) are passed as parameters.
     24                  o If TS interrupt mode is desired, you must configure the TS interrupt mode
     25                    by calling the function BSP_TS_ITConfig(). The TS interrupt mode is generated
     26                    as an external interrupt whenever a touch is detected. 
     27                    The interrupt mode internally uses the IO functionalities driver driven by
     28                    the IO expander, to configure the IT line.
     29               
     30               + Touch screen use
     31                  o The touch screen state is captured whenever the function BSP_TS_GetState() is 
     32                    used. This function returns information about the last LCD touch occurred
     33                    in the TS_StateTypeDef structure.
     34                  o If TS interrupt mode is used, the function BSP_TS_ITGetStatus() is needed to get
     35                    the interrupt status. To clear the IT pending bits, you should call the 
     36                    function BSP_TS_ITClear().
     37                  o The IT is handled using the corresponding external interrupt IRQ handler,
     38                    the user IT callback treatment is implemented on the same external interrupt
     39                    callback.
     40            @endverbatim
     41            ******************************************************************************
     42            * @attention
     43            *
     44            * <h2><center>&copy; COPYRIGHT(c) 2015 STMicroelectronics</center></h2>
     45            *
     46            * Redistribution and use in source and binary forms, with or without modification,
     47            * are permitted provided that the following conditions are met:
     48            *   1. Redistributions of source code must retain the above copyright notice,
     49            *      this list of conditions and the following disclaimer.
     50            *   2. Redistributions in binary form must reproduce the above copyright notice,
     51            *      this list of conditions and the following disclaimer in the documentation
     52            *      and/or other materials provided with the distribution.
     53            *   3. Neither the name of STMicroelectronics nor the names of its contributors
     54            *      may be used to endorse or promote products derived from this software
     55            *      without specific prior written permission.
     56            *
     57            * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
     58            * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     59            * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     60            * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
     61            * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
     62            * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
     63            * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
     64            * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
     65            * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
     66            * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     67            *
     68            ******************************************************************************
     69            */ 
     70          
     71          /* Includes ------------------------------------------------------------------*/
     72          #include "stm32746g_discovery_ts.h"
     73          
     74          /** @addtogroup BSP
     75            * @{
     76            */
     77          
     78          /** @addtogroup STM32746G_DISCOVERY
     79            * @{
     80            */ 
     81            
     82          /** @defgroup STM32746G_DISCOVERY_TS STM32746G_DISCOVERY_TS
     83            * @{
     84            */   
     85          
     86          /** @defgroup STM32746G_DISCOVERY_TS_Private_Types_Definitions STM32746G_DISCOVERY_TS Types Definitions
     87            * @{
     88            */ 
     89          /**
     90            * @}
     91            */ 
     92          
     93          /** @defgroup STM32746G_DISCOVERY_TS_Private_Defines STM32746G_DISCOVERY_TS Types Defines
     94            * @{
     95            */ 
     96          /**
     97            * @}
     98            */ 
     99          
    100          /** @defgroup STM32746G_DISCOVERY_TS_Private_Macros STM32746G_DISCOVERY_TS Private Macros
    101            * @{
    102            */ 
    103          /**
    104            * @}
    105            */
    106          
    107          /** @defgroup STM32746G_DISCOVERY_TS_Imported_Variables STM32746G_DISCOVERY_TS Imported Variables
    108            * @{
    109            */
    110            /**
    111              * @}
    112              */
    113          
    114          /** @defgroup STM32746G_DISCOVERY_TS_Private_Variables STM32746G_DISCOVERY_TS Private Variables
    115            * @{
    116            */ 
    117          static TS_DrvTypeDef *tsDriver;
    118          static uint16_t tsXBoundary, tsYBoundary; 
    119          static uint8_t  tsOrientation;
    120          static uint8_t  I2cAddress;
    121          /**
    122            * @}
    123            */ 
    124          
    125          /** @defgroup STM32746G_DISCOVERY_TS_Private_Function_Prototypes STM32746G_DISCOVERY_TS Private Function Prototypes
    126            * @{
    127            */ 
    128          /**
    129            * @}
    130            */ 
    131          
    132          /** @defgroup STM32746G_DISCOVERY_TS_Exported_Functions STM32746G_DISCOVERY_TS Exported Functions
    133            * @{
    134            */ 
    135          
    136          /**
    137            * @brief  Initializes and configures the touch screen functionalities and 
    138            *         configures all necessary hardware resources (GPIOs, I2C, clocks..).
    139            * @param  ts_SizeX: Maximum X size of the TS area on LCD
    140            * @param  ts_SizeY: Maximum Y size of the TS area on LCD
    141            * @retval TS_OK if all initializations are OK. Other value if error.
    142            */

   \                                 In section .text, align 2, keep-with-next
    143          uint8_t BSP_TS_Init(uint16_t ts_SizeX, uint16_t ts_SizeY)
    144          {
   \                     BSP_TS_Init: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
    145            uint8_t status = TS_OK;
    146            tsXBoundary = ts_SizeX;
    147            tsYBoundary = ts_SizeY;
    148            
    149            /* Read ID and verify if the touch screen driver is ready */
    150            ft5336_ts_drv.Init(TS_I2C_ADDRESS);
   \   00000002   0x....             LDR.N    R6,??DataTable5
   \   00000004   0x....             LDR.N    R5,??DataTable5_1
   \   00000006   0x80A9             STRH     R1,[R5, #+4]
   \   00000008   0x2400             MOVS     R4,#+0
   \   0000000A   0x8068             STRH     R0,[R5, #+2]
   \   0000000C   0x6831             LDR      R1,[R6, #+0]
   \   0000000E   0x2070             MOVS     R0,#+112
   \   00000010   0x4788             BLX      R1
    151            if(ft5336_ts_drv.ReadID(TS_I2C_ADDRESS) == FT5336_ID_VALUE)
   \   00000012   0x6871             LDR      R1,[R6, #+4]
   \   00000014   0x2070             MOVS     R0,#+112
   \   00000016   0x4788             BLX      R1
   \   00000018   0x2851             CMP      R0,#+81
   \   0000001A   0xD108             BNE.N    ??BSP_TS_Init_0
    152            { 
    153              /* Initialize the TS driver structure */
    154              tsDriver = &ft5336_ts_drv;
    155              I2cAddress = TS_I2C_ADDRESS;
   \   0000001C   0x2070             MOVS     R0,#+112
   \   0000001E   0x60AE             STR      R6,[R5, #+8]
   \   00000020   0x7068             STRB     R0,[R5, #+1]
    156              tsOrientation = TS_SWAP_XY;
   \   00000022   0x2008             MOVS     R0,#+8
   \   00000024   0x7028             STRB     R0,[R5, #+0]
    157          
    158              /* Initialize the TS driver */
    159              tsDriver->Start(I2cAddress);
   \   00000026   0x68F1             LDR      R1,[R6, #+12]
   \   00000028   0x2070             MOVS     R0,#+112
   \   0000002A   0x4788             BLX      R1
   \   0000002C   0xE000             B.N      ??BSP_TS_Init_1
    160            }
    161            else
    162            {
    163              status = TS_DEVICE_NOT_FOUND;
   \                     ??BSP_TS_Init_0: (+1)
   \   0000002E   0x2403             MOVS     R4,#+3
    164            }
    165          
    166            return status;
   \                     ??BSP_TS_Init_1: (+1)
   \   00000030   0x4620             MOV      R0,R4
   \   00000032   0xBD70             POP      {R4-R6,PC}       ;; return
    167          }
    168          
    169          /**
    170            * @brief  DeInitializes the TouchScreen.
    171            * @retval TS state
    172            */

   \                                 In section .text, align 2, keep-with-next
    173          uint8_t BSP_TS_DeInit(void)
    174          { 
    175            /* Actually ts_driver does not provide a DeInit function */
    176            return TS_OK;
   \                     BSP_TS_DeInit: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x4770             BX       LR               ;; return
    177          }
    178          
    179          /**
    180            * @brief  Configures and enables the touch screen interrupts.
    181            * @retval TS_OK if all initializations are OK. Other value if error.
    182            */

   \                                 In section .text, align 2, keep-with-next
    183          uint8_t BSP_TS_ITConfig(void)
    184          {
   \                     BSP_TS_ITConfig: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB085             SUB      SP,SP,#+20
    185            GPIO_InitTypeDef gpio_init_structure;
    186          
    187            /* Configure Interrupt mode for SD detection pin */
    188            gpio_init_structure.Pin = TS_INT_PIN;
   \   00000004   0xF44F 0x5000      MOV      R0,#+8192
   \   00000008   0x9000             STR      R0,[SP, #+0]
    189            gpio_init_structure.Pull = GPIO_NOPULL;
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x9002             STR      R0,[SP, #+8]
    190            gpio_init_structure.Speed = GPIO_SPEED_FAST;
   \   0000000E   0x2002             MOVS     R0,#+2
   \   00000010   0x9003             STR      R0,[SP, #+12]
    191            gpio_init_structure.Mode = GPIO_MODE_IT_RISING;
   \   00000012   0x....             LDR.N    R0,??DataTable5_2  ;; 0x10110000
   \   00000014   0x9001             STR      R0,[SP, #+4]
    192            HAL_GPIO_Init(TS_INT_GPIO_PORT, &gpio_init_structure);
   \   00000016   0x4669             MOV      R1,SP
   \   00000018   0x....             LDR.N    R0,??DataTable5_3  ;; 0x40022000
   \   0000001A   0x.... 0x....      BL       HAL_GPIO_Init
    193          
    194            /* Enable and set Touch screen EXTI Interrupt to the lowest priority */
    195            HAL_NVIC_SetPriority((IRQn_Type)(TS_INT_EXTI_IRQn), 0x0F, 0x00);
   \   0000001E   0x2200             MOVS     R2,#+0
   \   00000020   0x210F             MOVS     R1,#+15
   \   00000022   0x2028             MOVS     R0,#+40
   \   00000024   0x.... 0x....      BL       HAL_NVIC_SetPriority
    196            HAL_NVIC_EnableIRQ((IRQn_Type)(TS_INT_EXTI_IRQn));
   \   00000028   0x2028             MOVS     R0,#+40
   \   0000002A   0x.... 0x....      BL       HAL_NVIC_EnableIRQ
    197          
    198            /* Enable the TS ITs */
    199            tsDriver->EnableIT(I2cAddress);
   \   0000002E   0x....             LDR.N    R1,??DataTable5_1
   \   00000030   0x7848             LDRB     R0,[R1, #+1]
   \   00000032   0x6889             LDR      R1,[R1, #+8]
   \   00000034   0x6989             LDR      R1,[R1, #+24]
   \   00000036   0x4788             BLX      R1
    200          
    201            return TS_OK;  
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0xB005             ADD      SP,SP,#+20
   \   0000003C   0xBD00             POP      {PC}             ;; return
    202          }
    203          
    204          /**
    205            * @brief  Gets the touch screen interrupt status.
    206            * @retval TS_OK if all initializations are OK. Other value if error.
    207            */

   \                                 In section .text, align 2, keep-with-next
    208          uint8_t BSP_TS_ITGetStatus(void)
    209          {
    210            /* Return the TS IT status */
    211            return (tsDriver->GetITStatus(I2cAddress));
   \                     BSP_TS_ITGetStatus: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable5_1
   \   00000002   0x7848             LDRB     R0,[R1, #+1]
   \   00000004   0x6889             LDR      R1,[R1, #+8]
   \   00000006   0x6A09             LDR      R1,[R1, #+32]
   \   00000008   0x4708             BX       R1
    212          }
    213          
    214          /**
    215            * @brief  Returns status and positions of the touch screen.
    216            * @param  TS_State: Pointer to touch screen current state structure
    217            * @retval TS_OK if all initializations are OK. Other value if error.
    218            */

   \                                 In section .text, align 4, keep-with-next
    219          uint8_t BSP_TS_GetState(TS_StateTypeDef *TS_State)
    220          {
   \                     BSP_TS_GetState: (+1)
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
    221            static uint32_t _x[TS_MAX_NB_TOUCH] = {0, 0};
    222            static uint32_t _y[TS_MAX_NB_TOUCH] = {0, 0};
    223            uint8_t ts_status = TS_OK;
    224            uint16_t x[TS_MAX_NB_TOUCH];
    225            uint16_t y[TS_MAX_NB_TOUCH];
    226            uint16_t brute_x[TS_MAX_NB_TOUCH];
    227            uint16_t brute_y[TS_MAX_NB_TOUCH];
    228            uint16_t x_diff;
    229            uint16_t y_diff;
    230            uint32_t index;
    231          #if (TS_MULTI_TOUCH_SUPPORTED == 1)
    232            uint32_t weight = 0;
    233            uint32_t area = 0;
    234            uint32_t event = 0;
    235          #endif /* TS_MULTI_TOUCH_SUPPORTED == 1 */
    236          
    237            /* Check and update the number of touches active detected */
    238            TS_State->touchDetected = tsDriver->DetectTouch(I2cAddress);
   \   00000004   0x....             LDR.N    R5,??DataTable5_1
   \   00000006   0xB091             SUB      SP,SP,#+68
   \   00000008   0x4604             MOV      R4,R0
   \   0000000A   0x2600             MOVS     R6,#+0
   \   0000000C   0x68A9             LDR      R1,[R5, #+8]
   \   0000000E   0x9603             STR      R6,[SP, #+12]
   \   00000010   0x9602             STR      R6,[SP, #+8]
   \   00000012   0x7868             LDRB     R0,[R5, #+1]
   \   00000014   0x9601             STR      R6,[SP, #+4]
   \   00000016   0x6909             LDR      R1,[R1, #+16]
   \   00000018   0x4788             BLX      R1
    239            
    240            if(TS_State->touchDetected)
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0x7020             STRB     R0,[R4, #+0]
   \   0000001E   0xF000 0x808C      BEQ.W    ??BSP_TS_GetState_1
    241            {
    242              for(index=0; index < TS_State->touchDetected; index++)
   \   00000022   0x46B2             MOV      R10,R6
   \   00000024   0xAE04             ADD      R6,SP,#+16
   \   00000026   0xF10D 0x0B1C      ADD      R11,SP,#+28
   \   0000002A   0xF10D 0x0828      ADD      R8,SP,#+40
   \   0000002E   0xF10D 0x0934      ADD      R9,SP,#+52
   \   00000032   0xE003             B.N      ??BSP_TS_GetState_2
    243              {
    244                /* Get each touch coordinates */
    245                tsDriver->GetXY(I2cAddress, &(brute_x[index]), &(brute_y[index]));
    246          
    247                if(tsOrientation == TS_SWAP_NONE)
    248                {
    249                  x[index] = brute_x[index];
    250                  y[index] = brute_y[index];
    251                }
    252          
    253                if(tsOrientation & TS_SWAP_X)
    254                {
    255                  x[index] = 4096 - brute_x[index];
    256                }
    257          
    258                if(tsOrientation & TS_SWAP_Y)
    259                {
    260                  y[index] = 4096 - brute_y[index];
    261                }
    262          
    263                if(tsOrientation & TS_SWAP_XY)
    264                {
    265                  y[index] = brute_x[index];
    266                  x[index] = brute_y[index];
    267                }
    268          
    269                x_diff = x[index] > _x[index]? (x[index] - _x[index]): (_x[index] - x[index]);
    270                y_diff = y[index] > _y[index]? (y[index] - _y[index]): (_y[index] - y[index]);
    271          
    272                if ((x_diff + y_diff) > 5)
    273                {
    274                  _x[index] = x[index];
    275                  _y[index] = y[index];
    276                }
    277          
    278                if(I2cAddress == FT5336_I2C_SLAVE_ADDRESS)
    279                {
    280                  TS_State->touchX[index] = x[index];
    281                  TS_State->touchY[index] = y[index];
    282                }
    283                else
    284                {
    285                  /* 2^12 = 4096 : indexes are expressed on a dynamic of 4096 */
    286                  TS_State->touchX[index] = (tsXBoundary * _x[index]) >> 12;
    287                  TS_State->touchY[index] = (tsYBoundary * _y[index]) >> 12;
    288                }
    289          
    290          #if (TS_MULTI_TOUCH_SUPPORTED == 1)
    291          
    292                /* Get touch info related to the current touch */
    293                ft5336_TS_GetTouchInfo(I2cAddress, index, &weight, &area, &event);
    294          
    295                /* Update TS_State structure */
    296                TS_State->touchWeight[index] = weight;
    297                TS_State->touchArea[index]   = area;
    298          
    299                /* Remap touch event */
    300                switch(event)
    301                {
    302                  case FT5336_TOUCH_EVT_FLAG_PRESS_DOWN	:
    303                    TS_State->touchEventId[index] = TOUCH_EVENT_PRESS_DOWN;
    304                    break;
    305                  case FT5336_TOUCH_EVT_FLAG_LIFT_UP :
    306                    TS_State->touchEventId[index] = TOUCH_EVENT_LIFT_UP;
    307                    break;
    308                  case FT5336_TOUCH_EVT_FLAG_CONTACT :
    309                    TS_State->touchEventId[index] = TOUCH_EVENT_CONTACT;
    310                    break;
    311                  case FT5336_TOUCH_EVT_FLAG_NO_EVENT :
    312                    TS_State->touchEventId[index] = TOUCH_EVENT_NO_EVT;
   \                     ??BSP_TS_GetState_3: (+1)
   \   00000034   0x2100             MOVS     R1,#+0
   \                     ??BSP_TS_GetState_4: (+1)
   \   00000036   0x76C1             STRB     R1,[R0, #+27]
    313                    break;
   \                     ??BSP_TS_GetState_5: (+1)
   \   00000038   0xF10A 0x0A01      ADD      R10,R10,#+1
   \                     ??BSP_TS_GetState_2: (+1)
   \   0000003C   0x7820             LDRB     R0,[R4, #+0]
   \   0000003E   0x4582             CMP      R10,R0
   \   00000040   0xD277             BCS.N    ??BSP_TS_GetState_6
   \   00000042   0xA804             ADD      R0,SP,#+16
   \   00000044   0x68AB             LDR      R3,[R5, #+8]
   \   00000046   0xEB00 0x024A      ADD      R2,R0,R10, LSL #+1
   \   0000004A   0xA807             ADD      R0,SP,#+28
   \   0000004C   0xEB00 0x014A      ADD      R1,R0,R10, LSL #+1
   \   00000050   0x7868             LDRB     R0,[R5, #+1]
   \   00000052   0x695B             LDR      R3,[R3, #+20]
   \   00000054   0x4798             BLX      R3
   \   00000056   0x7828             LDRB     R0,[R5, #+0]
   \   00000058   0x2801             CMP      R0,#+1
   \   0000005A   0xD107             BNE.N    ??BSP_TS_GetState_7
   \   0000005C   0xF83B 0x101A      LDRH     R1,[R11, R10, LSL #+1]
   \   00000060   0xF829 0x101A      STRH     R1,[R9, R10, LSL #+1]
   \   00000064   0xF836 0x101A      LDRH     R1,[R6, R10, LSL #+1]
   \   00000068   0xF828 0x101A      STRH     R1,[R8, R10, LSL #+1]
   \                     ??BSP_TS_GetState_7: (+1)
   \   0000006C   0x0781             LSLS     R1,R0,#+30
   \   0000006E   0xD505             BPL.N    ??BSP_TS_GetState_8
   \   00000070   0xF83B 0x101A      LDRH     R1,[R11, R10, LSL #+1]
   \   00000074   0xF5C1 0x5180      RSB      R1,R1,#+4096
   \   00000078   0xF829 0x101A      STRH     R1,[R9, R10, LSL #+1]
   \                     ??BSP_TS_GetState_8: (+1)
   \   0000007C   0x0741             LSLS     R1,R0,#+29
   \   0000007E   0xD505             BPL.N    ??BSP_TS_GetState_9
   \   00000080   0xF836 0x101A      LDRH     R1,[R6, R10, LSL #+1]
   \   00000084   0xF5C1 0x5180      RSB      R1,R1,#+4096
   \   00000088   0xF828 0x101A      STRH     R1,[R8, R10, LSL #+1]
   \                     ??BSP_TS_GetState_9: (+1)
   \   0000008C   0x0700             LSLS     R0,R0,#+28
   \   0000008E   0xD507             BPL.N    ??BSP_TS_GetState_10
   \   00000090   0xF83B 0x001A      LDRH     R0,[R11, R10, LSL #+1]
   \   00000094   0xF828 0x001A      STRH     R0,[R8, R10, LSL #+1]
   \   00000098   0xF836 0x001A      LDRH     R0,[R6, R10, LSL #+1]
   \   0000009C   0xF829 0x001A      STRH     R0,[R9, R10, LSL #+1]
   \                     ??BSP_TS_GetState_10: (+1)
   \   000000A0   0xEB05 0x028A      ADD      R2,R5,R10, LSL #+2
   \   000000A4   0xF839 0x101A      LDRH     R1,[R9, R10, LSL #+1]
   \   000000A8   0x68D3             LDR      R3,[R2, #+12]
   \   000000AA   0x428B             CMP      R3,R1
   \   000000AC   0xBF34             ITE      CC 
   \   000000AE   0xEBA1 0x0E03      SUBCC    LR,R1,R3
   \   000000B2   0xEBA3 0x0E01      SUBCS    LR,R3,R1
   \   000000B6   0xF838 0x301A      LDRH     R3,[R8, R10, LSL #+1]
   \   000000BA   0x6A17             LDR      R7,[R2, #+32]
   \   000000BC   0x429F             CMP      R7,R3
   \   000000BE   0xBF34             ITE      CC 
   \   000000C0   0x1BDF             SUBCC    R7,R3,R7
   \   000000C2   0x1AFF             SUBCS    R7,R7,R3
   \   000000C4   0xB2BF             UXTH     R7,R7
   \   000000C6   0xFA17 0xFE8E      UXTAH    LR,R7,LR
   \   000000CA   0xF1BE 0x0F06      CMP      LR,#+6
   \   000000CE   0xEB04 0x074A      ADD      R7,R4,R10, LSL #+1
   \   000000D2   0xBFA4             ITT      GE 
   \   000000D4   0x60D1             STRGE    R1,[R2, #+12]
   \   000000D6   0x6213             STRGE    R3,[R2, #+32]
   \   000000D8   0x7868             LDRB     R0,[R5, #+1]
   \   000000DA   0x2870             CMP      R0,#+112
   \   000000DC   0xD102             BNE.N    ??BSP_TS_GetState_11
   \   000000DE   0x8079             STRH     R1,[R7, #+2]
   \   000000E0   0x81BB             STRH     R3,[R7, #+12]
   \   000000E2   0xE009             B.N      ??BSP_TS_GetState_12
   \                     ??BSP_TS_GetState_11: (+1)
   \   000000E4   0x8869             LDRH     R1,[R5, #+2]
   \   000000E6   0x68D3             LDR      R3,[R2, #+12]
   \   000000E8   0x4359             MULS     R1,R3,R1
   \   000000EA   0x0B09             LSRS     R1,R1,#+12
   \   000000EC   0x8079             STRH     R1,[R7, #+2]
   \   000000EE   0x88A9             LDRH     R1,[R5, #+4]
   \   000000F0   0x6A12             LDR      R2,[R2, #+32]
   \   000000F2   0x4351             MULS     R1,R2,R1
   \   000000F4   0x0B09             LSRS     R1,R1,#+12
   \   000000F6   0x81B9             STRH     R1,[R7, #+12]
   \                     ??BSP_TS_GetState_12: (+1)
   \   000000F8   0xA901             ADD      R1,SP,#+4
   \   000000FA   0xAB02             ADD      R3,SP,#+8
   \   000000FC   0x9100             STR      R1,[SP, #+0]
   \   000000FE   0xAA03             ADD      R2,SP,#+12
   \   00000100   0x4651             MOV      R1,R10
   \   00000102   0x.... 0x....      BL       ft5336_TS_GetTouchInfo
   \   00000106   0x9903             LDR      R1,[SP, #+12]
   \   00000108   0xEB0A 0x0004      ADD      R0,R10,R4
   \   0000010C   0x7581             STRB     R1,[R0, #+22]
   \   0000010E   0x9902             LDR      R1,[SP, #+8]
   \   00000110   0xF880 0x1020      STRB     R1,[R0, #+32]
   \   00000114   0x9901             LDR      R1,[SP, #+4]
   \   00000116   0x2903             CMP      R1,#+3
   \   00000118   0xD88E             BHI.N    ??BSP_TS_GetState_5
   \   0000011A   0xE8DF 0xF001      TBB      [PC, R1]
   \                     ??BSP_TS_GetState_0:
   \   0000011E   0x04 0x06          DC8      0x4,0x6,0x8,0x3
   \              0x08 0x03    
   \                     ??BSP_TS_GetState_13: (+1)
   \   00000122   0xE789             B.N      ??BSP_TS_GetState_5
   \                     ??BSP_TS_GetState_14: (+1)
   \   00000124   0xE786             B.N      ??BSP_TS_GetState_3
   \                     ??BSP_TS_GetState_15: (+1)
   \   00000126   0x2101             MOVS     R1,#+1
   \   00000128   0xE785             B.N      ??BSP_TS_GetState_4
   \                     ??BSP_TS_GetState_16: (+1)
   \   0000012A   0x2102             MOVS     R1,#+2
   \   0000012C   0xE783             B.N      ??BSP_TS_GetState_4
   \                     ??BSP_TS_GetState_17: (+1)
   \   0000012E   0x2103             MOVS     R1,#+3
   \   00000130   0xE781             B.N      ??BSP_TS_GetState_4
    314                  default :
    315                    ts_status = TS_ERROR;
    316                    break;
    317                } /* of switch(event) */
    318          
    319          #endif /* TS_MULTI_TOUCH_SUPPORTED == 1 */
    320          
    321              } /* of for(index=0; index < TS_State->touchDetected; index++) */
    322          
    323          #if (TS_MULTI_TOUCH_SUPPORTED == 1)
    324              /* Get gesture Id */
    325              ts_status = BSP_TS_Get_GestureId(TS_State);
   \                     ??BSP_TS_GetState_6: (+1)
   \   00000132   0x4620             MOV      R0,R4
   \   00000134   0x.... 0x....      BL       BSP_TS_Get_GestureId
   \   00000138   0x4606             MOV      R6,R0
    326          #endif /* TS_MULTI_TOUCH_SUPPORTED == 1 */
    327          
    328            } /* end of if(TS_State->touchDetected != 0) */
    329          
    330            return (ts_status);
   \                     ??BSP_TS_GetState_1: (+1)
   \   0000013A   0x4630             MOV      R0,R6
   \   0000013C   0xB011             ADD      SP,SP,#+68
   \   0000013E   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    331          }

   \                                 In section .bss, align 4
   \                     tsOrientation:
   \   00000000                      DS8 1
   \   00000001                      DS8 1
   \   00000002                      DS8 2
   \   00000004                      DS8 2
   \   00000006                      DS8 2
   \   00000008                      DS8 4
   \   0000000C                      DS8 20
   \   00000020                      DS8 20
    332          
    333          #if (TS_MULTI_TOUCH_SUPPORTED == 1)
    334          /**
    335            * @brief  Update gesture Id following a touch detected.
    336            * @param  TS_State: Pointer to touch screen current state structure
    337            * @retval TS_OK if all initializations are OK. Other value if error.
    338            */

   \                                 In section .text, align 2, keep-with-next
    339          uint8_t BSP_TS_Get_GestureId(TS_StateTypeDef *TS_State)
    340          {
   \                     BSP_TS_Get_GestureId: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
    341            uint32_t gestureId = 0;
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x9000             STR      R0,[SP, #+0]
    342            uint8_t  ts_status = TS_OK;
    343          
    344            /* Get gesture Id */
    345            ft5336_TS_GetGestureID(I2cAddress, &gestureId);
   \   00000008   0x....             LDR.N    R0,??DataTable5_1
   \   0000000A   0x4669             MOV      R1,SP
   \   0000000C   0x2500             MOVS     R5,#+0
   \   0000000E   0x7840             LDRB     R0,[R0, #+1]
   \   00000010   0x.... 0x....      BL       ft5336_TS_GetGestureID
    346          
    347            /* Remap gesture Id to a TS_GestureIdTypeDef value */
    348            switch(gestureId)
   \   00000014   0x9800             LDR      R0,[SP, #+0]
   \   00000016   0xB1B8             CBZ.N    R0,??BSP_TS_Get_GestureId_0
   \   00000018   0x2810             CMP      R0,#+16
   \   0000001A   0xD00A             BEQ.N    ??BSP_TS_Get_GestureId_1
   \   0000001C   0x2814             CMP      R0,#+20
   \   0000001E   0xD00A             BEQ.N    ??BSP_TS_Get_GestureId_2
   \   00000020   0x2818             CMP      R0,#+24
   \   00000022   0xD00A             BEQ.N    ??BSP_TS_Get_GestureId_3
   \   00000024   0x281C             CMP      R0,#+28
   \   00000026   0xD00A             BEQ.N    ??BSP_TS_Get_GestureId_4
   \   00000028   0x2840             CMP      R0,#+64
   \   0000002A   0xD00A             BEQ.N    ??BSP_TS_Get_GestureId_5
   \   0000002C   0x2849             CMP      R0,#+73
   \   0000002E   0xD00A             BEQ.N    ??BSP_TS_Get_GestureId_6
   \   00000030   0xE00C             B.N      ??BSP_TS_Get_GestureId_7
    349            {
    350              case FT5336_GEST_ID_NO_GESTURE :
    351                TS_State->gestureId = GEST_ID_NO_GESTURE;
    352                break;
    353              case FT5336_GEST_ID_MOVE_UP :
    354                TS_State->gestureId = GEST_ID_MOVE_UP;
   \                     ??BSP_TS_Get_GestureId_1: (+1)
   \   00000032   0x2001             MOVS     R0,#+1
   \   00000034   0xE008             B.N      ??BSP_TS_Get_GestureId_0
    355                break;
    356              case FT5336_GEST_ID_MOVE_RIGHT :
    357                TS_State->gestureId = GEST_ID_MOVE_RIGHT;
   \                     ??BSP_TS_Get_GestureId_2: (+1)
   \   00000036   0x2002             MOVS     R0,#+2
   \   00000038   0xE006             B.N      ??BSP_TS_Get_GestureId_0
    358                break;
    359              case FT5336_GEST_ID_MOVE_DOWN :
    360                TS_State->gestureId = GEST_ID_MOVE_DOWN;
   \                     ??BSP_TS_Get_GestureId_3: (+1)
   \   0000003A   0x2003             MOVS     R0,#+3
   \   0000003C   0xE004             B.N      ??BSP_TS_Get_GestureId_0
    361                break;
    362              case FT5336_GEST_ID_MOVE_LEFT :
    363                TS_State->gestureId = GEST_ID_MOVE_LEFT;
   \                     ??BSP_TS_Get_GestureId_4: (+1)
   \   0000003E   0x2004             MOVS     R0,#+4
   \   00000040   0xE002             B.N      ??BSP_TS_Get_GestureId_0
    364                break;
    365              case FT5336_GEST_ID_ZOOM_IN :
    366                TS_State->gestureId = GEST_ID_ZOOM_IN;
   \                     ??BSP_TS_Get_GestureId_5: (+1)
   \   00000042   0x2005             MOVS     R0,#+5
   \   00000044   0xE000             B.N      ??BSP_TS_Get_GestureId_0
    367                break;
    368              case FT5336_GEST_ID_ZOOM_OUT :
    369                TS_State->gestureId = GEST_ID_ZOOM_OUT;
   \                     ??BSP_TS_Get_GestureId_6: (+1)
   \   00000046   0x2006             MOVS     R0,#+6
   \                     ??BSP_TS_Get_GestureId_0: (+1)
   \   00000048   0x62A0             STR      R0,[R4, #+40]
    370                break;
   \   0000004A   0xE000             B.N      ??BSP_TS_Get_GestureId_8
    371              default :
    372                ts_status = TS_ERROR;
   \                     ??BSP_TS_Get_GestureId_7: (+1)
   \   0000004C   0x2501             MOVS     R5,#+1
    373                break;
    374            } /* of switch(gestureId) */
    375          
    376            return(ts_status);
   \                     ??BSP_TS_Get_GestureId_8: (+1)
   \   0000004E   0x4628             MOV      R0,R5
   \   00000050   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    377          }
    378          #endif /* TS_MULTI_TOUCH_SUPPORTED == 1 */
    379          
    380          /**
    381            * @brief  Clears all touch screen interrupts.
    382            */

   \                                 In section .text, align 2, keep-with-next
    383          void BSP_TS_ITClear(void)
    384          {
    385            /* Clear TS IT pending bits */
    386            tsDriver->ClearIT(I2cAddress); 
   \                     BSP_TS_ITClear: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable5_1
   \   00000002   0x7848             LDRB     R0,[R1, #+1]
   \   00000004   0x6889             LDR      R1,[R1, #+8]
   \   00000006   0x69C9             LDR      R1,[R1, #+28]
   \   00000008   0x4708             BX       R1
    387          }
    388          
    389          
    390          /** @defgroup STM32756G_DISCOVERY_TS_Private_Functions TS Private Functions
    391            * @{
    392            */
    393          
    394          
    395          /**
    396            * @brief  Function used to reset all touch data before a new acquisition
    397            *         of touch information.
    398            * @param  TS_State: Pointer to touch screen current state structure
    399            * @retval TS_OK if OK, TE_ERROR if problem found.
    400            */

   \                                 In section .text, align 2, keep-with-next
    401          uint8_t BSP_TS_ResetTouchData(TS_StateTypeDef *TS_State)
    402          {
    403            uint8_t ts_status = TS_ERROR;
   \                     BSP_TS_ResetTouchData: (+1)
   \   00000000   0x2101             MOVS     R1,#+1
    404            uint32_t index;
    405          
    406            if (TS_State != (TS_StateTypeDef *)NULL)
   \   00000002   0xB180             CBZ.N    R0,??BSP_TS_ResetTouchData_0
    407            {
    408              TS_State->gestureId = GEST_ID_NO_GESTURE;
   \   00000004   0x2100             MOVS     R1,#+0
    409              TS_State->touchDetected = 0;
    410          
    411              for(index = 0; index < TS_MAX_NB_TOUCH; index++)
   \   00000006   0x2300             MOVS     R3,#+0
   \   00000008   0x6281             STR      R1,[R0, #+40]
   \   0000000A   0x7001             STRB     R1,[R0, #+0]
    412              {
    413                TS_State->touchX[index]       = 0;
   \                     ??BSP_TS_ResetTouchData_1: (+1)
   \   0000000C   0xEB00 0x0241      ADD      R2,R0,R1, LSL #+1
   \   00000010   0x8053             STRH     R3,[R2, #+2]
    414                TS_State->touchY[index]       = 0;
   \   00000012   0x8193             STRH     R3,[R2, #+12]
    415                TS_State->touchArea[index]    = 0;
   \   00000014   0x180A             ADDS     R2,R1,R0
    416                TS_State->touchEventId[index] = TOUCH_EVENT_NO_EVT;
    417                TS_State->touchWeight[index]  = 0;
    418              }
   \   00000016   0x1C49             ADDS     R1,R1,#+1
   \   00000018   0x2905             CMP      R1,#+5
   \   0000001A   0xF882 0x3020      STRB     R3,[R2, #+32]
   \   0000001E   0x76D3             STRB     R3,[R2, #+27]
   \   00000020   0x7593             STRB     R3,[R2, #+22]
   \   00000022   0xD3F3             BCC.N    ??BSP_TS_ResetTouchData_1
    419          
    420              ts_status = TS_OK;
   \   00000024   0x2100             MOVS     R1,#+0
    421          
    422            } /* of if (TS_State != (TS_StateTypeDef *)NULL) */
    423          
    424            return (ts_status);
   \                     ??BSP_TS_ResetTouchData_0: (+1)
   \   00000026   0x4608             MOV      R0,R1
   \   00000028   0x4770             BX       LR               ;; return
    425          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5:
   \   00000000   0x........         DC32     ft5336_ts_drv

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_1:
   \   00000000   0x........         DC32     tsOrientation

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_2:
   \   00000000   0x10110000         DC32     0x10110000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_3:
   \   00000000   0x40022000         DC32     0x40022000
    426          
    427          /**
    428            * @}
    429            */ 
    430          
    431          /**
    432            * @}
    433            */ 
    434          
    435          /**
    436            * @}
    437            */ 
    438          
    439          /**
    440            * @}
    441            */  
    442          
    443          /**
    444            * @}
    445            */
    446          
    447          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   BSP_TS_DeInit
     104   BSP_TS_GetState
       104   -- Indirect call
       104   -> BSP_TS_Get_GestureId
       104   -> ft5336_TS_GetTouchInfo
      16   BSP_TS_Get_GestureId
        16   -> ft5336_TS_GetGestureID
       0   BSP_TS_ITClear
         0   -- Indirect call
      24   BSP_TS_ITConfig
        24   -- Indirect call
        24   -> HAL_GPIO_Init
        24   -> HAL_NVIC_EnableIRQ
        24   -> HAL_NVIC_SetPriority
       0   BSP_TS_ITGetStatus
         0   -- Indirect call
      16   BSP_TS_Init
        16   -- Indirect call
       0   BSP_TS_ResetTouchData


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable5
       4  ??DataTable5_1
       4  ??DataTable5_2
       4  ??DataTable5_3
       4  BSP_TS_DeInit
     322  BSP_TS_GetState
      82  BSP_TS_Get_GestureId
      10  BSP_TS_ITClear
      62  BSP_TS_ITConfig
      10  BSP_TS_ITGetStatus
      52  BSP_TS_Init
      42  BSP_TS_ResetTouchData
      52  tsOrientation
          I2cAddress
          tsXBoundary
          tsYBoundary
          tsDriver
          _x
          _y

 
  52 bytes in section .bss
 600 bytes in section .text
 
 600 bytes of CODE memory
  52 bytes of DATA memory

Errors: none
Warnings: none
