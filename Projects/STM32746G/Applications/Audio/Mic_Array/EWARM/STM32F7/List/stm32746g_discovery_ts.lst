###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.2.10312/W32 for ARM       16/Apr/2016  18:30:59
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Drivers\BSP\STM32746G-Discovery\stm32746g_discovery_ts.c
#    Command line =  
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Drivers\BSP\STM32746G-Discovery\stm32746g_discovery_ts.c
#        -D USE_HAL_DRIVER -D STM32F746xx -D USE_STM32746G_DISCO -D
#        USE_IOEXPANDER -D USE_USB_FS -lC
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
#        -lA
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
#        -o
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj
#        --no_unroll --debug --endian=little --cpu=Cortex-M7 -e --fpu=VFPv5_sp
#        --dlib_config "D:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Full.h" -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\CMSIS\Device\ST\STM32F7xx\Include\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\STM32F7xx_HAL_Driver\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\STM32746G-Discovery\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\Components\Common\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Log\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Fonts\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\CPU\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_Device_Library\Core\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Core\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Class\MSC\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\drivers\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_Audio\Addons\PDM\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_Device_Library\Class\AUDIO\Inc\
#        -Oh --use_c++_inline --require_prototypes -I "D:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.3\arm\CMSIS\Include\" -D
#        ARM_MATH_CM7 --relaxed_fp
#    List file    =  
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List\stm32746g_discovery_ts.lst
#    Object file  =  
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj\stm32746g_discovery_ts.o
#
###############################################################################

D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Drivers\BSP\STM32746G-Discovery\stm32746g_discovery_ts.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32746g_discovery_ts.c
      4            * @author  MCD Application Team
      5            * @version V1.0.0
      6            * @date    25-June-2015
      7            * @brief   This file provides a set of functions needed to manage the Touch 
      8            *          Screen on STM32746G-Discovery board.
      9            @verbatim
     10             1. How To use this driver:
     11             --------------------------
     12                - This driver is used to drive the touch screen module of the STM32746G-Discovery
     13                  board on the RK043FN48H-CT672B 480x272 LCD screen with capacitive touch screen.
     14                - The FT5336 component driver must be included in project files according to
     15                  the touch screen driver present on this board.
     16             
     17             2. Driver description:
     18             ---------------------
     19               + Initialization steps:
     20                  o Initialize the TS module using the BSP_TS_Init() function. This 
     21                    function includes the MSP layer hardware resources initialization and the
     22                    communication layer configuration to start the TS use. The LCD size properties
     23                    (x and y) are passed as parameters.
     24                  o If TS interrupt mode is desired, you must configure the TS interrupt mode
     25                    by calling the function BSP_TS_ITConfig(). The TS interrupt mode is generated
     26                    as an external interrupt whenever a touch is detected. 
     27                    The interrupt mode internally uses the IO functionalities driver driven by
     28                    the IO expander, to configure the IT line.
     29               
     30               + Touch screen use
     31                  o The touch screen state is captured whenever the function BSP_TS_GetState() is 
     32                    used. This function returns information about the last LCD touch occurred
     33                    in the TS_StateTypeDef structure.
     34                  o If TS interrupt mode is used, the function BSP_TS_ITGetStatus() is needed to get
     35                    the interrupt status. To clear the IT pending bits, you should call the 
     36                    function BSP_TS_ITClear().
     37                  o The IT is handled using the corresponding external interrupt IRQ handler,
     38                    the user IT callback treatment is implemented on the same external interrupt
     39                    callback.
     40            @endverbatim
     41            ******************************************************************************
     42            * @attention
     43            *
     44            * <h2><center>&copy; COPYRIGHT(c) 2015 STMicroelectronics</center></h2>
     45            *
     46            * Redistribution and use in source and binary forms, with or without modification,
     47            * are permitted provided that the following conditions are met:
     48            *   1. Redistributions of source code must retain the above copyright notice,
     49            *      this list of conditions and the following disclaimer.
     50            *   2. Redistributions in binary form must reproduce the above copyright notice,
     51            *      this list of conditions and the following disclaimer in the documentation
     52            *      and/or other materials provided with the distribution.
     53            *   3. Neither the name of STMicroelectronics nor the names of its contributors
     54            *      may be used to endorse or promote products derived from this software
     55            *      without specific prior written permission.
     56            *
     57            * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
     58            * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     59            * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     60            * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
     61            * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
     62            * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
     63            * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
     64            * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
     65            * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
     66            * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     67            *
     68            ******************************************************************************
     69            */ 
     70          
     71          /* Includes ------------------------------------------------------------------*/
     72          #include "stm32746g_discovery_ts.h"
     73          
     74          /** @addtogroup BSP
     75            * @{
     76            */
     77          
     78          /** @addtogroup STM32746G_DISCOVERY
     79            * @{
     80            */ 
     81            
     82          /** @defgroup STM32746G_DISCOVERY_TS STM32746G_DISCOVERY_TS
     83            * @{
     84            */   
     85          
     86          /** @defgroup STM32746G_DISCOVERY_TS_Private_Types_Definitions STM32746G_DISCOVERY_TS Types Definitions
     87            * @{
     88            */ 
     89          /**
     90            * @}
     91            */ 
     92          
     93          /** @defgroup STM32746G_DISCOVERY_TS_Private_Defines STM32746G_DISCOVERY_TS Types Defines
     94            * @{
     95            */ 
     96          /**
     97            * @}
     98            */ 
     99          
    100          /** @defgroup STM32746G_DISCOVERY_TS_Private_Macros STM32746G_DISCOVERY_TS Private Macros
    101            * @{
    102            */ 
    103          /**
    104            * @}
    105            */
    106          
    107          /** @defgroup STM32746G_DISCOVERY_TS_Imported_Variables STM32746G_DISCOVERY_TS Imported Variables
    108            * @{
    109            */
    110            /**
    111              * @}
    112              */
    113          
    114          /** @defgroup STM32746G_DISCOVERY_TS_Private_Variables STM32746G_DISCOVERY_TS Private Variables
    115            * @{
    116            */ 
    117          static TS_DrvTypeDef *tsDriver;
    118          static uint16_t tsXBoundary, tsYBoundary; 
    119          static uint8_t  tsOrientation;
    120          static uint8_t  I2cAddress;
    121          /**
    122            * @}
    123            */ 
    124          
    125          /** @defgroup STM32746G_DISCOVERY_TS_Private_Function_Prototypes STM32746G_DISCOVERY_TS Private Function Prototypes
    126            * @{
    127            */ 
    128          /**
    129            * @}
    130            */ 
    131          
    132          /** @defgroup STM32746G_DISCOVERY_TS_Exported_Functions STM32746G_DISCOVERY_TS Exported Functions
    133            * @{
    134            */ 
    135          
    136          /**
    137            * @brief  Initializes and configures the touch screen functionalities and 
    138            *         configures all necessary hardware resources (GPIOs, I2C, clocks..).
    139            * @param  ts_SizeX: Maximum X size of the TS area on LCD
    140            * @param  ts_SizeY: Maximum Y size of the TS area on LCD
    141            * @retval TS_OK if all initializations are OK. Other value if error.
    142            */

   \                                 In section .text, align 2, keep-with-next
    143          uint8_t BSP_TS_Init(uint16_t ts_SizeX, uint16_t ts_SizeY)
    144          {
   \                     BSP_TS_Init: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
    145            uint8_t status = TS_OK;
    146            tsXBoundary = ts_SizeX;
    147            tsYBoundary = ts_SizeY;
    148            
    149            /* Read ID and verify if the touch screen driver is ready */
    150            ft5336_ts_drv.Init(TS_I2C_ADDRESS);
   \   00000002   0x....             LDR.N    R6,??DataTable5
   \   00000004   0x....             LDR.N    R5,??DataTable5_1
   \   00000006   0x80A9             STRH     R1,[R5, #+4]
   \   00000008   0x2400             MOVS     R4,#+0
   \   0000000A   0x8068             STRH     R0,[R5, #+2]
   \   0000000C   0x6831             LDR      R1,[R6, #+0]
   \   0000000E   0x2070             MOVS     R0,#+112
   \   00000010   0x4788             BLX      R1
    151            if(ft5336_ts_drv.ReadID(TS_I2C_ADDRESS) == FT5336_ID_VALUE)
   \   00000012   0x6871             LDR      R1,[R6, #+4]
   \   00000014   0x2070             MOVS     R0,#+112
   \   00000016   0x4788             BLX      R1
   \   00000018   0x2851             CMP      R0,#+81
   \   0000001A   0xD108             BNE.N    ??BSP_TS_Init_0
    152            { 
    153              /* Initialize the TS driver structure */
    154              tsDriver = &ft5336_ts_drv;
    155              I2cAddress = TS_I2C_ADDRESS;
   \   0000001C   0x2070             MOVS     R0,#+112
   \   0000001E   0x60AE             STR      R6,[R5, #+8]
   \   00000020   0x7068             STRB     R0,[R5, #+1]
    156              tsOrientation = TS_SWAP_XY;
   \   00000022   0x2008             MOVS     R0,#+8
   \   00000024   0x7028             STRB     R0,[R5, #+0]
    157          
    158              /* Initialize the TS driver */
    159              tsDriver->Start(I2cAddress);
   \   00000026   0x68F1             LDR      R1,[R6, #+12]
   \   00000028   0x2070             MOVS     R0,#+112
   \   0000002A   0x4788             BLX      R1
   \   0000002C   0xE000             B.N      ??BSP_TS_Init_1
    160            }
    161            else
    162            {
    163              status = TS_DEVICE_NOT_FOUND;
   \                     ??BSP_TS_Init_0: (+1)
   \   0000002E   0x2403             MOVS     R4,#+3
    164            }
    165          
    166            return status;
   \                     ??BSP_TS_Init_1: (+1)
   \   00000030   0x4620             MOV      R0,R4
   \   00000032   0xBD70             POP      {R4-R6,PC}       ;; return
    167          }
    168          
    169          /**
    170            * @brief  DeInitializes the TouchScreen.
    171            * @retval TS state
    172            */

   \                                 In section .text, align 2, keep-with-next
    173          uint8_t BSP_TS_DeInit(void)
    174          { 
    175            /* Actually ts_driver does not provide a DeInit function */
    176            return TS_OK;
   \                     BSP_TS_DeInit: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x4770             BX       LR               ;; return
    177          }
    178          
    179          /**
    180            * @brief  Configures and enables the touch screen interrupts.
    181            * @retval TS_OK if all initializations are OK. Other value if error.
    182            */

   \                                 In section .text, align 2, keep-with-next
    183          uint8_t BSP_TS_ITConfig(void)
    184          {
   \                     BSP_TS_ITConfig: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB085             SUB      SP,SP,#+20
    185            GPIO_InitTypeDef gpio_init_structure;
    186          
    187            /* Configure Interrupt mode for SD detection pin */
    188            gpio_init_structure.Pin = TS_INT_PIN;
   \   00000004   0xF44F 0x5000      MOV      R0,#+8192
   \   00000008   0x9000             STR      R0,[SP, #+0]
    189            gpio_init_structure.Pull = GPIO_NOPULL;
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x9002             STR      R0,[SP, #+8]
    190            gpio_init_structure.Speed = GPIO_SPEED_FAST;
   \   0000000E   0x2002             MOVS     R0,#+2
   \   00000010   0x9003             STR      R0,[SP, #+12]
    191            gpio_init_structure.Mode = GPIO_MODE_IT_RISING;
   \   00000012   0x....             LDR.N    R0,??DataTable5_2  ;; 0x10110000
   \   00000014   0x9001             STR      R0,[SP, #+4]
    192            HAL_GPIO_Init(TS_INT_GPIO_PORT, &gpio_init_structure);
   \   00000016   0x4669             MOV      R1,SP
   \   00000018   0x....             LDR.N    R0,??DataTable5_3  ;; 0x40022000
   \   0000001A   0x.... 0x....      BL       HAL_GPIO_Init
    193          
    194            /* Enable and set Touch screen EXTI Interrupt to the lowest priority */
    195            HAL_NVIC_SetPriority((IRQn_Type)(TS_INT_EXTI_IRQn), 0x0F, 0x00);
   \   0000001E   0x2200             MOVS     R2,#+0
   \   00000020   0x210F             MOVS     R1,#+15
   \   00000022   0x2028             MOVS     R0,#+40
   \   00000024   0x.... 0x....      BL       HAL_NVIC_SetPriority
    196            HAL_NVIC_EnableIRQ((IRQn_Type)(TS_INT_EXTI_IRQn));
   \   00000028   0x2028             MOVS     R0,#+40
   \   0000002A   0x.... 0x....      BL       HAL_NVIC_EnableIRQ
    197          
    198            /* Enable the TS ITs */
    199            tsDriver->EnableIT(I2cAddress);
   \   0000002E   0x....             LDR.N    R1,??DataTable5_1
   \   00000030   0x7848             LDRB     R0,[R1, #+1]
   \   00000032   0x6889             LDR      R1,[R1, #+8]
   \   00000034   0x6989             LDR      R1,[R1, #+24]
   \   00000036   0x4788             BLX      R1
    200          
    201            return TS_OK;  
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0xB005             ADD      SP,SP,#+20
   \   0000003C   0xBD00             POP      {PC}             ;; return
    202          }
    203          
    204          /**
    205            * @brief  Gets the touch screen interrupt status.
    206            * @retval TS_OK if all initializations are OK. Other value if error.
    207            */

   \                                 In section .text, align 2, keep-with-next
    208          uint8_t BSP_TS_ITGetStatus(void)
    209          {
    210            /* Return the TS IT status */
    211            return (tsDriver->GetITStatus(I2cAddress));
   \                     BSP_TS_ITGetStatus: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable5_1
   \   00000002   0x7848             LDRB     R0,[R1, #+1]
   \   00000004   0x6889             LDR      R1,[R1, #+8]
   \   00000006   0x6A09             LDR      R1,[R1, #+32]
   \   00000008   0x4708             BX       R1
    212          }
    213          
    214          /**
    215            * @brief  Returns status and positions of the touch screen.
    216            * @param  TS_State: Pointer to touch screen current state structure
    217            * @retval TS_OK if all initializations are OK. Other value if error.
    218            */

   \                                 In section .text, align 4, keep-with-next
    219          uint8_t BSP_TS_GetState(TS_StateTypeDef *TS_State)
    220          {
    221            static uint32_t _x[TS_MAX_NB_TOUCH] = {0, 0};
    222            static uint32_t _y[TS_MAX_NB_TOUCH] = {0, 0};
    223            uint8_t ts_status = TS_OK;
    224            uint16_t x[TS_MAX_NB_TOUCH];
    225            uint16_t y[TS_MAX_NB_TOUCH];
    226            uint16_t brute_x[TS_MAX_NB_TOUCH];
    227            uint16_t brute_y[TS_MAX_NB_TOUCH];
    228            uint16_t x_diff;
    229            uint16_t y_diff;
    230            uint32_t index;
    231          #if (TS_MULTI_TOUCH_SUPPORTED == 1)
    232            uint32_t weight = 0;
    233            uint32_t area = 0;
    234            uint32_t event = 0;
   \                     BSP_TS_GetState: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable5_1
   \   00000002   0xE92D 0x4FF1      PUSH     {R0,R4-R11,LR}
   \   00000006   0x....             LDR.N    R0,??DataTable5_1
   \   00000008   0xB092             SUB      SP,SP,#+72
   \   0000000A   0x6889             LDR      R1,[R1, #+8]
   \   0000000C   0x2400             MOVS     R4,#+0
   \   0000000E   0x9404             STR      R4,[SP, #+16]
   \   00000010   0x7840             LDRB     R0,[R0, #+1]
   \   00000012   0x9403             STR      R4,[SP, #+12]
   \   00000014   0x9402             STR      R4,[SP, #+8]
   \   00000016   0x6909             LDR      R1,[R1, #+16]
    235          #endif /* TS_MULTI_TOUCH_SUPPORTED == 1 */
    236          
    237            /* Check and update the number of touches active detected */
    238            TS_State->touchDetected = tsDriver->DetectTouch(I2cAddress);
   \   00000018   0x4788             BLX      R1
   \   0000001A   0x9912             LDR      R1,[SP, #+72]
    239            
    240            if(TS_State->touchDetected)
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0x7008             STRB     R0,[R1, #+0]
   \   00000020   0xF000 0x80A5      BEQ.W    ??BSP_TS_GetState_1
    241            {
    242              for(index=0; index < TS_State->touchDetected; index++)
   \   00000024   0x9812             LDR      R0,[SP, #+72]
   \   00000026   0xF10D 0x0A14      ADD      R10,SP,#+20
   \   0000002A   0xF100 0x0716      ADD      R7,R0,#+22
   \   0000002E   0xF10D 0x0920      ADD      R9,SP,#+32
   \   00000032   0x1C86             ADDS     R6,R0,#+2
   \   00000034   0x....             LDR.N    R0,??DataTable5_4
   \   00000036   0xAD0E             ADD      R5,SP,#+56
   \   00000038   0xF10D 0x0B2C      ADD      R11,SP,#+44
   \   0000003C   0x9001             STR      R0,[SP, #+4]
   \   0000003E   0x.... 0x....      LDR.W    R8,??DataTable5_5
   \   00000042   0xE010             B.N      ??BSP_TS_GetState_2
    243              {
    244                /* Get each touch coordinates */
    245                tsDriver->GetXY(I2cAddress, &(brute_x[index]), &(brute_y[index]));
    246          
    247                if(tsOrientation == TS_SWAP_NONE)
    248                {
    249                  x[index] = brute_x[index];
    250                  y[index] = brute_y[index];
    251                }
    252          
    253                if(tsOrientation & TS_SWAP_X)
    254                {
    255                  x[index] = 4096 - brute_x[index];
    256                }
    257          
    258                if(tsOrientation & TS_SWAP_Y)
    259                {
    260                  y[index] = 4096 - brute_y[index];
    261                }
    262          
    263                if(tsOrientation & TS_SWAP_XY)
    264                {
    265                  y[index] = brute_x[index];
    266                  x[index] = brute_y[index];
    267                }
    268          
    269                x_diff = x[index] > _x[index]? (x[index] - _x[index]): (_x[index] - x[index]);
    270                y_diff = y[index] > _y[index]? (y[index] - _y[index]): (_y[index] - y[index]);
    271          
    272                if ((x_diff + y_diff) > 5)
    273                {
    274                  _x[index] = x[index];
    275                  _y[index] = y[index];
    276                }
    277          
    278                if(I2cAddress == FT5336_I2C_SLAVE_ADDRESS)
    279                {
    280                  TS_State->touchX[index] = x[index];
    281                  TS_State->touchY[index] = y[index];
    282                }
    283                else
    284                {
    285                  /* 2^12 = 4096 : indexes are expressed on a dynamic of 4096 */
    286                  TS_State->touchX[index] = (tsXBoundary * _x[index]) >> 12;
    287                  TS_State->touchY[index] = (tsYBoundary * _y[index]) >> 12;
    288                }
    289          
    290          #if (TS_MULTI_TOUCH_SUPPORTED == 1)
    291          
    292                /* Get touch info related to the current touch */
    293                ft5336_TS_GetTouchInfo(I2cAddress, index, &weight, &area, &event);
    294          
    295                /* Update TS_State structure */
    296                TS_State->touchWeight[index] = weight;
    297                TS_State->touchArea[index]   = area;
    298          
    299                /* Remap touch event */
    300                switch(event)
    301                {
    302                  case FT5336_TOUCH_EVT_FLAG_PRESS_DOWN	:
    303                    TS_State->touchEventId[index] = TOUCH_EVENT_PRESS_DOWN;
    304                    break;
    305                  case FT5336_TOUCH_EVT_FLAG_LIFT_UP :
    306                    TS_State->touchEventId[index] = TOUCH_EVENT_LIFT_UP;
    307                    break;
    308                  case FT5336_TOUCH_EVT_FLAG_CONTACT :
    309                    TS_State->touchEventId[index] = TOUCH_EVENT_CONTACT;
    310                    break;
    311                  case FT5336_TOUCH_EVT_FLAG_NO_EVENT :
    312                    TS_State->touchEventId[index] = TOUCH_EVENT_NO_EVT;
   \                     ??BSP_TS_GetState_3: (+1)
   \   00000044   0x2000             MOVS     R0,#+0
   \                     ??BSP_TS_GetState_4: (+1)
   \   00000046   0x7178             STRB     R0,[R7, #+5]
    313                    break;
   \                     ??BSP_TS_GetState_5: (+1)
   \   00000048   0x9801             LDR      R0,[SP, #+4]
   \   0000004A   0x1C64             ADDS     R4,R4,#+1
   \   0000004C   0xF108 0x0804      ADD      R8,R8,#+4
   \   00000050   0x1CB6             ADDS     R6,R6,#+2
   \   00000052   0x1D00             ADDS     R0,R0,#+4
   \   00000054   0xF10B 0x0B02      ADD      R11,R11,#+2
   \   00000058   0x9001             STR      R0,[SP, #+4]
   \   0000005A   0x1CAD             ADDS     R5,R5,#+2
   \   0000005C   0xF109 0x0902      ADD      R9,R9,#+2
   \   00000060   0xF10A 0x0A02      ADD      R10,R10,#+2
   \   00000064   0x1C7F             ADDS     R7,R7,#+1
   \                     ??BSP_TS_GetState_2: (+1)
   \   00000066   0x9812             LDR      R0,[SP, #+72]
   \   00000068   0x7800             LDRB     R0,[R0, #+0]
   \   0000006A   0x4284             CMP      R4,R0
   \   0000006C   0xF080 0x807B      BCS.W    ??BSP_TS_GetState_6
   \   00000070   0x....             LDR.N    R3,??DataTable5_1
   \   00000072   0x....             LDR.N    R0,??DataTable5_1
   \   00000074   0x4652             MOV      R2,R10
   \   00000076   0x4649             MOV      R1,R9
   \   00000078   0x689B             LDR      R3,[R3, #+8]
   \   0000007A   0x7840             LDRB     R0,[R0, #+1]
   \   0000007C   0x695B             LDR      R3,[R3, #+20]
   \   0000007E   0x4798             BLX      R3
   \   00000080   0x....             LDR.N    R0,??DataTable5_1
   \   00000082   0x7800             LDRB     R0,[R0, #+0]
   \   00000084   0x2801             CMP      R0,#+1
   \   00000086   0xD106             BNE.N    ??BSP_TS_GetState_7
   \   00000088   0xF8B9 0x1000      LDRH     R1,[R9, #+0]
   \   0000008C   0x8029             STRH     R1,[R5, #+0]
   \   0000008E   0xF8BA 0x1000      LDRH     R1,[R10, #+0]
   \   00000092   0xF8AB 0x1000      STRH     R1,[R11, #+0]
   \                     ??BSP_TS_GetState_7: (+1)
   \   00000096   0x0781             LSLS     R1,R0,#+30
   \   00000098   0xD504             BPL.N    ??BSP_TS_GetState_8
   \   0000009A   0xF8B9 0x1000      LDRH     R1,[R9, #+0]
   \   0000009E   0xF5C1 0x5180      RSB      R1,R1,#+4096
   \   000000A2   0x8029             STRH     R1,[R5, #+0]
   \                     ??BSP_TS_GetState_8: (+1)
   \   000000A4   0x0741             LSLS     R1,R0,#+29
   \   000000A6   0xD505             BPL.N    ??BSP_TS_GetState_9
   \   000000A8   0xF8BA 0x1000      LDRH     R1,[R10, #+0]
   \   000000AC   0xF5C1 0x5180      RSB      R1,R1,#+4096
   \   000000B0   0xF8AB 0x1000      STRH     R1,[R11, #+0]
   \                     ??BSP_TS_GetState_9: (+1)
   \   000000B4   0x0700             LSLS     R0,R0,#+28
   \   000000B6   0xD506             BPL.N    ??BSP_TS_GetState_10
   \   000000B8   0xF8B9 0x0000      LDRH     R0,[R9, #+0]
   \   000000BC   0xF8AB 0x0000      STRH     R0,[R11, #+0]
   \   000000C0   0xF8BA 0x0000      LDRH     R0,[R10, #+0]
   \   000000C4   0x8028             STRH     R0,[R5, #+0]
   \                     ??BSP_TS_GetState_10: (+1)
   \   000000C6   0x9A01             LDR      R2,[SP, #+4]
   \   000000C8   0x8829             LDRH     R1,[R5, #+0]
   \   000000CA   0x6812             LDR      R2,[R2, #+0]
   \   000000CC   0x428A             CMP      R2,R1
   \   000000CE   0xBF34             ITE      CC 
   \   000000D0   0xEBA1 0x0C02      SUBCC    R12,R1,R2
   \   000000D4   0xEBA2 0x0C01      SUBCS    R12,R2,R1
   \   000000D8   0xF8BB 0x2000      LDRH     R2,[R11, #+0]
   \   000000DC   0xF8D8 0xE000      LDR      LR,[R8, #+0]
   \   000000E0   0x4596             CMP      LR,R2
   \   000000E2   0xBF34             ITE      CC 
   \   000000E4   0xEBA2 0x0E0E      SUBCC    LR,R2,LR
   \   000000E8   0xEBAE 0x0E02      SUBCS    LR,LR,R2
   \   000000EC   0xFA1F 0xFE8E      UXTH     LR,LR
   \   000000F0   0xFA1E 0xFC8C      UXTAH    R12,LR,R12
   \   000000F4   0xF1BC 0x0F06      CMP      R12,#+6
   \   000000F8   0xDB05             BLT.N    ??BSP_TS_GetState_11
   \   000000FA   0xF8DD 0xC004      LDR      R12,[SP, #+4]
   \   000000FE   0xF8CC 0x1000      STR      R1,[R12, #+0]
   \   00000102   0xF8C8 0x2000      STR      R2,[R8, #+0]
   \                     ??BSP_TS_GetState_11: (+1)
   \   00000106   0x....             LDR.N    R0,??DataTable5_1
   \   00000108   0x7840             LDRB     R0,[R0, #+1]
   \   0000010A   0x2870             CMP      R0,#+112
   \   0000010C   0xD102             BNE.N    ??BSP_TS_GetState_12
   \   0000010E   0x8031             STRH     R1,[R6, #+0]
   \   00000110   0x8172             STRH     R2,[R6, #+10]
   \   00000112   0xE00D             B.N      ??BSP_TS_GetState_13
   \                     ??BSP_TS_GetState_12: (+1)
   \   00000114   0x....             LDR.N    R1,??DataTable5_1
   \   00000116   0x9A01             LDR      R2,[SP, #+4]
   \   00000118   0x8849             LDRH     R1,[R1, #+2]
   \   0000011A   0x6812             LDR      R2,[R2, #+0]
   \   0000011C   0x4351             MULS     R1,R2,R1
   \   0000011E   0x0B09             LSRS     R1,R1,#+12
   \   00000120   0x8031             STRH     R1,[R6, #+0]
   \   00000122   0x....             LDR.N    R1,??DataTable5_1
   \   00000124   0xF8D8 0x2000      LDR      R2,[R8, #+0]
   \   00000128   0x8889             LDRH     R1,[R1, #+4]
   \   0000012A   0x4351             MULS     R1,R2,R1
   \   0000012C   0x0B09             LSRS     R1,R1,#+12
   \   0000012E   0x8171             STRH     R1,[R6, #+10]
   \                     ??BSP_TS_GetState_13: (+1)
   \   00000130   0xA902             ADD      R1,SP,#+8
   \   00000132   0xAB03             ADD      R3,SP,#+12
   \   00000134   0x9100             STR      R1,[SP, #+0]
   \   00000136   0xAA04             ADD      R2,SP,#+16
   \   00000138   0x4621             MOV      R1,R4
   \   0000013A   0x.... 0x....      BL       ft5336_TS_GetTouchInfo
   \   0000013E   0x9804             LDR      R0,[SP, #+16]
   \   00000140   0x7038             STRB     R0,[R7, #+0]
   \   00000142   0x9803             LDR      R0,[SP, #+12]
   \   00000144   0x72B8             STRB     R0,[R7, #+10]
   \   00000146   0x9802             LDR      R0,[SP, #+8]
   \   00000148   0x2803             CMP      R0,#+3
   \   0000014A   0xF63F 0xAF7D      BHI.W    ??BSP_TS_GetState_5
   \   0000014E   0xE8DF 0xF000      TBB      [PC, R0]
   \                     ??BSP_TS_GetState_0:
   \   00000152   0x04 0x06          DC8      0x4,0x6,0x8,0x3
   \              0x08 0x03    
   \                     ??BSP_TS_GetState_14: (+1)
   \   00000156   0xE777             B.N      ??BSP_TS_GetState_5
   \                     ??BSP_TS_GetState_15: (+1)
   \   00000158   0xE774             B.N      ??BSP_TS_GetState_3
   \                     ??BSP_TS_GetState_16: (+1)
   \   0000015A   0x2001             MOVS     R0,#+1
   \   0000015C   0xE773             B.N      ??BSP_TS_GetState_4
   \                     ??BSP_TS_GetState_17: (+1)
   \   0000015E   0x2002             MOVS     R0,#+2
   \   00000160   0xE771             B.N      ??BSP_TS_GetState_4
   \                     ??BSP_TS_GetState_18: (+1)
   \   00000162   0x2003             MOVS     R0,#+3
   \   00000164   0xE76F             B.N      ??BSP_TS_GetState_4
    314                  default :
    315                    ts_status = TS_ERROR;
    316                    break;
    317                } /* of switch(event) */
    318          
    319          #endif /* TS_MULTI_TOUCH_SUPPORTED == 1 */
    320          
    321              } /* of for(index=0; index < TS_State->touchDetected; index++) */
    322          
    323          #if (TS_MULTI_TOUCH_SUPPORTED == 1)
    324              /* Get gesture Id */
    325              ts_status = BSP_TS_Get_GestureId(TS_State);
   \                     ??BSP_TS_GetState_6: (+1)
   \   00000166   0x9812             LDR      R0,[SP, #+72]
   \   00000168   0x.... 0x....      BL       BSP_TS_Get_GestureId
   \   0000016C   0x4604             MOV      R4,R0
    326          #endif /* TS_MULTI_TOUCH_SUPPORTED == 1 */
    327          
    328            } /* end of if(TS_State->touchDetected != 0) */
    329          
    330            return (ts_status);
   \                     ??BSP_TS_GetState_1: (+1)
   \   0000016E   0x4620             MOV      R0,R4
   \   00000170   0xB013             ADD      SP,SP,#+76
   \   00000172   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    331          }

   \                                 In section .bss, align 4
   \                     tsOrientation:
   \   00000000                      DS8 1
   \   00000001                      DS8 1
   \   00000002                      DS8 2
   \   00000004                      DS8 2
   \   00000006                      DS8 2
   \   00000008                      DS8 4
   \   0000000C                      DS8 20
   \   00000020                      DS8 20
    332          
    333          #if (TS_MULTI_TOUCH_SUPPORTED == 1)
    334          /**
    335            * @brief  Update gesture Id following a touch detected.
    336            * @param  TS_State: Pointer to touch screen current state structure
    337            * @retval TS_OK if all initializations are OK. Other value if error.
    338            */

   \                                 In section .text, align 2, keep-with-next
    339          uint8_t BSP_TS_Get_GestureId(TS_StateTypeDef *TS_State)
    340          {
   \                     BSP_TS_Get_GestureId: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
    341            uint32_t gestureId = 0;
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x9000             STR      R0,[SP, #+0]
    342            uint8_t  ts_status = TS_OK;
    343          
    344            /* Get gesture Id */
    345            ft5336_TS_GetGestureID(I2cAddress, &gestureId);
   \   00000008   0x....             LDR.N    R0,??DataTable5_1
   \   0000000A   0x4669             MOV      R1,SP
   \   0000000C   0x2500             MOVS     R5,#+0
   \   0000000E   0x7840             LDRB     R0,[R0, #+1]
   \   00000010   0x.... 0x....      BL       ft5336_TS_GetGestureID
    346          
    347            /* Remap gesture Id to a TS_GestureIdTypeDef value */
    348            switch(gestureId)
   \   00000014   0x9800             LDR      R0,[SP, #+0]
   \   00000016   0xB1B8             CBZ.N    R0,??BSP_TS_Get_GestureId_0
   \   00000018   0x2810             CMP      R0,#+16
   \   0000001A   0xD00A             BEQ.N    ??BSP_TS_Get_GestureId_1
   \   0000001C   0x2814             CMP      R0,#+20
   \   0000001E   0xD00A             BEQ.N    ??BSP_TS_Get_GestureId_2
   \   00000020   0x2818             CMP      R0,#+24
   \   00000022   0xD00A             BEQ.N    ??BSP_TS_Get_GestureId_3
   \   00000024   0x281C             CMP      R0,#+28
   \   00000026   0xD00A             BEQ.N    ??BSP_TS_Get_GestureId_4
   \   00000028   0x2840             CMP      R0,#+64
   \   0000002A   0xD00A             BEQ.N    ??BSP_TS_Get_GestureId_5
   \   0000002C   0x2849             CMP      R0,#+73
   \   0000002E   0xD00A             BEQ.N    ??BSP_TS_Get_GestureId_6
   \   00000030   0xE00C             B.N      ??BSP_TS_Get_GestureId_7
    349            {
    350              case FT5336_GEST_ID_NO_GESTURE :
    351                TS_State->gestureId = GEST_ID_NO_GESTURE;
    352                break;
    353              case FT5336_GEST_ID_MOVE_UP :
    354                TS_State->gestureId = GEST_ID_MOVE_UP;
   \                     ??BSP_TS_Get_GestureId_1: (+1)
   \   00000032   0x2001             MOVS     R0,#+1
   \   00000034   0xE008             B.N      ??BSP_TS_Get_GestureId_0
    355                break;
    356              case FT5336_GEST_ID_MOVE_RIGHT :
    357                TS_State->gestureId = GEST_ID_MOVE_RIGHT;
   \                     ??BSP_TS_Get_GestureId_2: (+1)
   \   00000036   0x2002             MOVS     R0,#+2
   \   00000038   0xE006             B.N      ??BSP_TS_Get_GestureId_0
    358                break;
    359              case FT5336_GEST_ID_MOVE_DOWN :
    360                TS_State->gestureId = GEST_ID_MOVE_DOWN;
   \                     ??BSP_TS_Get_GestureId_3: (+1)
   \   0000003A   0x2003             MOVS     R0,#+3
   \   0000003C   0xE004             B.N      ??BSP_TS_Get_GestureId_0
    361                break;
    362              case FT5336_GEST_ID_MOVE_LEFT :
    363                TS_State->gestureId = GEST_ID_MOVE_LEFT;
   \                     ??BSP_TS_Get_GestureId_4: (+1)
   \   0000003E   0x2004             MOVS     R0,#+4
   \   00000040   0xE002             B.N      ??BSP_TS_Get_GestureId_0
    364                break;
    365              case FT5336_GEST_ID_ZOOM_IN :
    366                TS_State->gestureId = GEST_ID_ZOOM_IN;
   \                     ??BSP_TS_Get_GestureId_5: (+1)
   \   00000042   0x2005             MOVS     R0,#+5
   \   00000044   0xE000             B.N      ??BSP_TS_Get_GestureId_0
    367                break;
    368              case FT5336_GEST_ID_ZOOM_OUT :
    369                TS_State->gestureId = GEST_ID_ZOOM_OUT;
   \                     ??BSP_TS_Get_GestureId_6: (+1)
   \   00000046   0x2006             MOVS     R0,#+6
   \                     ??BSP_TS_Get_GestureId_0: (+1)
   \   00000048   0x62A0             STR      R0,[R4, #+40]
    370                break;
   \   0000004A   0xE000             B.N      ??BSP_TS_Get_GestureId_8
    371              default :
    372                ts_status = TS_ERROR;
   \                     ??BSP_TS_Get_GestureId_7: (+1)
   \   0000004C   0x2501             MOVS     R5,#+1
    373                break;
    374            } /* of switch(gestureId) */
    375          
    376            return(ts_status);
   \                     ??BSP_TS_Get_GestureId_8: (+1)
   \   0000004E   0x4628             MOV      R0,R5
   \   00000050   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    377          }
    378          #endif /* TS_MULTI_TOUCH_SUPPORTED == 1 */
    379          
    380          /**
    381            * @brief  Clears all touch screen interrupts.
    382            */

   \                                 In section .text, align 2, keep-with-next
    383          void BSP_TS_ITClear(void)
    384          {
    385            /* Clear TS IT pending bits */
    386            tsDriver->ClearIT(I2cAddress); 
   \                     BSP_TS_ITClear: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable5_1
   \   00000002   0x7848             LDRB     R0,[R1, #+1]
   \   00000004   0x6889             LDR      R1,[R1, #+8]
   \   00000006   0x69C9             LDR      R1,[R1, #+28]
   \   00000008   0x4708             BX       R1
    387          }
    388          
    389          
    390          /** @defgroup STM32756G_DISCOVERY_TS_Private_Functions TS Private Functions
    391            * @{
    392            */
    393          
    394          
    395          /**
    396            * @brief  Function used to reset all touch data before a new acquisition
    397            *         of touch information.
    398            * @param  TS_State: Pointer to touch screen current state structure
    399            * @retval TS_OK if OK, TE_ERROR if problem found.
    400            */

   \                                 In section .text, align 2, keep-with-next
    401          uint8_t BSP_TS_ResetTouchData(TS_StateTypeDef *TS_State)
    402          {
    403            uint8_t ts_status = TS_ERROR;
   \                     BSP_TS_ResetTouchData: (+1)
   \   00000000   0x2101             MOVS     R1,#+1
    404            uint32_t index;
    405          
    406            if (TS_State != (TS_StateTypeDef *)NULL)
   \   00000002   0xB188             CBZ.N    R0,??BSP_TS_ResetTouchData_0
    407            {
    408              TS_State->gestureId = GEST_ID_NO_GESTURE;
   \   00000004   0x2100             MOVS     R1,#+0
    409              TS_State->touchDetected = 0;
    410          
    411              for(index = 0; index < TS_MAX_NB_TOUCH; index++)
   \   00000006   0x2205             MOVS     R2,#+5
   \   00000008   0x6281             STR      R1,[R0, #+40]
   \   0000000A   0x2300             MOVS     R3,#+0
   \   0000000C   0x7001             STRB     R1,[R0, #+0]
   \   0000000E   0xF100 0x0116      ADD      R1,R0,#+22
   \   00000012   0x1C80             ADDS     R0,R0,#+2
    412              {
    413                TS_State->touchX[index]       = 0;
   \                     ??BSP_TS_ResetTouchData_1: (+1)
   \   00000014   0x8003             STRH     R3,[R0, #+0]
    414                TS_State->touchY[index]       = 0;
   \   00000016   0x8143             STRH     R3,[R0, #+10]
    415                TS_State->touchArea[index]    = 0;
    416                TS_State->touchEventId[index] = TOUCH_EVENT_NO_EVT;
    417                TS_State->touchWeight[index]  = 0;
    418              }
   \   00000018   0x1C80             ADDS     R0,R0,#+2
   \   0000001A   0x1E52             SUBS     R2,R2,#+1
   \   0000001C   0x728B             STRB     R3,[R1, #+10]
   \   0000001E   0x714B             STRB     R3,[R1, #+5]
   \   00000020   0xF801 0x3B01      STRB     R3,[R1], #+1
   \   00000024   0xD1F6             BNE.N    ??BSP_TS_ResetTouchData_1
    419          
    420              ts_status = TS_OK;
   \   00000026   0x2100             MOVS     R1,#+0
    421          
    422            } /* of if (TS_State != (TS_StateTypeDef *)NULL) */
    423          
    424            return (ts_status);
   \                     ??BSP_TS_ResetTouchData_0: (+1)
   \   00000028   0x4608             MOV      R0,R1
   \   0000002A   0x4770             BX       LR               ;; return
    425          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5:
   \   00000000   0x........         DC32     ft5336_ts_drv

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_1:
   \   00000000   0x........         DC32     tsOrientation

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_2:
   \   00000000   0x10110000         DC32     0x10110000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_3:
   \   00000000   0x40022000         DC32     0x40022000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_4:
   \   00000000   0x........         DC32     tsOrientation+0xC

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_5:
   \   00000000   0x........         DC32     tsOrientation+0x20
    426          
    427          /**
    428            * @}
    429            */ 
    430          
    431          /**
    432            * @}
    433            */ 
    434          
    435          /**
    436            * @}
    437            */ 
    438          
    439          /**
    440            * @}
    441            */  
    442          
    443          /**
    444            * @}
    445            */
    446          
    447          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   BSP_TS_DeInit
     112   BSP_TS_GetState
       112   -- Indirect call
       112   -> BSP_TS_Get_GestureId
       112   -> ft5336_TS_GetTouchInfo
      16   BSP_TS_Get_GestureId
        16   -> ft5336_TS_GetGestureID
       0   BSP_TS_ITClear
         0   -- Indirect call
      24   BSP_TS_ITConfig
        24   -- Indirect call
        24   -> HAL_GPIO_Init
        24   -> HAL_NVIC_EnableIRQ
        24   -> HAL_NVIC_SetPriority
       0   BSP_TS_ITGetStatus
         0   -- Indirect call
      16   BSP_TS_Init
        16   -- Indirect call
       0   BSP_TS_ResetTouchData


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable5
       4  ??DataTable5_1
       4  ??DataTable5_2
       4  ??DataTable5_3
       4  ??DataTable5_4
       4  ??DataTable5_5
       4  BSP_TS_DeInit
     374  BSP_TS_GetState
      82  BSP_TS_Get_GestureId
      10  BSP_TS_ITClear
      62  BSP_TS_ITConfig
      10  BSP_TS_ITGetStatus
      52  BSP_TS_Init
      44  BSP_TS_ResetTouchData
      52  tsOrientation
          I2cAddress
          tsXBoundary
          tsYBoundary
          tsDriver
          _x
          _y

 
  52 bytes in section .bss
 662 bytes in section .text
 
 662 bytes of CODE memory
  52 bytes of DATA memory

Errors: none
Warnings: none
