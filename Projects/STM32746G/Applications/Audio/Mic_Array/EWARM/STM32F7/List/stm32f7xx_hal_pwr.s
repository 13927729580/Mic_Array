///////////////////////////////////////////////////////////////////////////////
//
// IAR ANSI C/C++ Compiler V7.50.2.10312/W32 for ARM      13/Feb/2016  11:44:32
// Copyright 1999-2015 IAR Systems AB.
//
//    Cpu mode     =  thumb
//    Endian       =  little
//    Source file  =  
//        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_pwr.c
//    Command line =  
//        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_pwr.c
//        -D USE_HAL_DRIVER -D STM32F746xx -D USE_STM32746G_DISCO -D
//        USE_IOEXPANDER -D USE_USB_FS -lC
//        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
//        -lA
//        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
//        -o
//        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj
//        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
//        --no_clustering --no_scheduling --debug --endian=little
//        --cpu=Cortex-M7 -e --fpu=VFPv5_sp --dlib_config "D:\Program Files
//        (x86)\IAR Systems\Embedded Workbench
//        7.3\arm\INC\c\DLib_Config_Full.h" -I
//        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\Inc\
//        -I
//        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\CMSIS\Device\ST\STM32F7xx\Include\
//        -I
//        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\STM32F7xx_HAL_Driver\Inc\
//        -I
//        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\STM32746G-Discovery\
//        -I
//        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\Components\Common\
//        -I
//        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Log\
//        -I
//        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Fonts\
//        -I
//        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\CPU\
//        -I
//        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_Device_Library\Core\Inc\
//        -I
//        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Core\Inc\
//        -I
//        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Class\MSC\Inc\
//        -I
//        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\
//        -I
//        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\drivers\
//        -I
//        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_Audio\Addons\PDM\
//        -I
//        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_Device_Library\Class\AUDIO\Inc\
//        -On --use_c++_inline --require_prototypes -I "D:\Program Files
//        (x86)\IAR Systems\Embedded Workbench 7.3\arm\CMSIS\Include\" -D
//        ARM_MATH_CM7
//    List file    =  
//        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List\stm32f7xx_hal_pwr.s
//
///////////////////////////////////////////////////////////////////////////////

        RTMODEL "__SystemLibrary", "DLib"
        RTMODEL "__dlib_file_descriptor", "1"
        AAPCS BASE,INTERWORK,VFP
        PRESERVE8
        REQUIRE8

        #define SHT_PROGBITS 0x1

        PUBLIC HAL_PWR_ConfigPVD
        PUBLIC HAL_PWR_DeInit
        PUBLIC HAL_PWR_DisableBkUpAccess
        PUBLIC HAL_PWR_DisablePVD
        PUBLIC HAL_PWR_DisableSEVOnPend
        PUBLIC HAL_PWR_DisableSleepOnExit
        PUBLIC HAL_PWR_DisableWakeUpPin
        PUBLIC HAL_PWR_EnableBkUpAccess
        PUBLIC HAL_PWR_EnablePVD
        PUBLIC HAL_PWR_EnableSEVOnPend
        PUBLIC HAL_PWR_EnableSleepOnExit
        PUBLIC HAL_PWR_EnableWakeUpPin
        PUBLIC HAL_PWR_EnterSLEEPMode
        PUBLIC HAL_PWR_EnterSTANDBYMode
        PUBLIC HAL_PWR_EnterSTOPMode
        PUBWEAK HAL_PWR_PVDCallback
        PUBLIC HAL_PWR_PVD_IRQHandler
        
          CFI Names cfiNames0
          CFI StackFrame CFA R13 DATA
          CFI Resource R0:32, R1:32, R2:32, R3:32, R4:32, R5:32, R6:32, R7:32
          CFI Resource R8:32, R9:32, R10:32, R11:32, R12:32, R13:32, R14:32
          CFI Resource D0:64, D1:64, D2:64, D3:64, D4:64, D5:64, D6:64, D7:64
          CFI Resource D8:64, D9:64, D10:64, D11:64, D12:64, D13:64, D14:64
          CFI Resource D15:64
          CFI EndNames cfiNames0
        
          CFI Common cfiCommon0 Using cfiNames0
          CFI CodeAlign 2
          CFI DataAlign 4
          CFI ReturnAddress R14 CODE
          CFI CFA R13+0
          CFI R0 Undefined
          CFI R1 Undefined
          CFI R2 Undefined
          CFI R3 Undefined
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R8 SameValue
          CFI R9 SameValue
          CFI R10 SameValue
          CFI R11 SameValue
          CFI R12 Undefined
          CFI R14 SameValue
          CFI D0 Undefined
          CFI D1 Undefined
          CFI D2 Undefined
          CFI D3 Undefined
          CFI D4 Undefined
          CFI D5 Undefined
          CFI D6 Undefined
          CFI D7 Undefined
          CFI D8 SameValue
          CFI D9 SameValue
          CFI D10 SameValue
          CFI D11 SameValue
          CFI D12 SameValue
          CFI D13 SameValue
          CFI D14 SameValue
          CFI D15 SameValue
          CFI EndCommon cfiCommon0
        
// H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_pwr.c
//    1 /**
//    2   ******************************************************************************
//    3   * @file    stm32f7xx_hal_pwr.c
//    4   * @author  MCD Application Team
//    5   * @version V1.0.1
//    6   * @date    25-June-2015
//    7   * @brief   PWR HAL module driver.
//    8   *          This file provides firmware functions to manage the following 
//    9   *          functionalities of the Power Controller (PWR) peripheral:
//   10   *           + Initialization and de-initialization functions
//   11   *           + Peripheral Control functions 
//   12   *         
//   13   ******************************************************************************
//   14   * @attention
//   15   *
//   16   * <h2><center>&copy; COPYRIGHT(c) 2015 STMicroelectronics</center></h2>
//   17   *
//   18   * Redistribution and use in source and binary forms, with or without modification,
//   19   * are permitted provided that the following conditions are met:
//   20   *   1. Redistributions of source code must retain the above copyright notice,
//   21   *      this list of conditions and the following disclaimer.
//   22   *   2. Redistributions in binary form must reproduce the above copyright notice,
//   23   *      this list of conditions and the following disclaimer in the documentation
//   24   *      and/or other materials provided with the distribution.
//   25   *   3. Neither the name of STMicroelectronics nor the names of its contributors
//   26   *      may be used to endorse or promote products derived from this software
//   27   *      without specific prior written permission.
//   28   *
//   29   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
//   30   * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
//   31   * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
//   32   * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
//   33   * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
//   34   * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
//   35   * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
//   36   * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
//   37   * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
//   38   * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//   39   *
//   40   ******************************************************************************
//   41   */ 
//   42 
//   43 /* Includes ------------------------------------------------------------------*/
//   44 #include "stm32f7xx_hal.h"
//   45 
//   46 /** @addtogroup STM32F7xx_HAL_Driver
//   47   * @{
//   48   */
//   49 
//   50 /** @defgroup PWR PWR
//   51   * @brief PWR HAL module driver
//   52   * @{
//   53   */
//   54 
//   55 #ifdef HAL_PWR_MODULE_ENABLED
//   56 
//   57 /* Private typedef -----------------------------------------------------------*/
//   58 /* Private define ------------------------------------------------------------*/
//   59 /** @addtogroup PWR_Private_Constants
//   60   * @{
//   61   */
//   62 	
//   63 /** @defgroup PWR_PVD_Mode_Mask PWR PVD Mode Mask
//   64   * @{
//   65   */     
//   66 #define PVD_MODE_IT               ((uint32_t)0x00010000)
//   67 #define PVD_MODE_EVT              ((uint32_t)0x00020000)
//   68 #define PVD_RISING_EDGE           ((uint32_t)0x00000001)
//   69 #define PVD_FALLING_EDGE          ((uint32_t)0x00000002)
//   70 /**
//   71   * @}
//   72   */
//   73 
//   74 /** @defgroup PWR_ENABLE_WUP_Mask PWR Enable WUP Mask
//   75   * @{
//   76   */  
//   77 #define  PWR_EWUP_MASK                          ((uint32_t)0x00003F00)
//   78 /**
//   79   * @}
//   80   */
//   81 
//   82 /**
//   83   * @}
//   84   */
//   85 /* Private macro -------------------------------------------------------------*/
//   86 /* Private variables ---------------------------------------------------------*/
//   87 /* Private function prototypes -----------------------------------------------*/
//   88 /* Private functions ---------------------------------------------------------*/
//   89 
//   90 /** @defgroup PWR_Exported_Functions PWR Exported Functions
//   91   * @{
//   92   */
//   93 
//   94 /** @defgroup PWR_Exported_Functions_Group1 Initialization and de-initialization functions 
//   95   *  @brief    Initialization and de-initialization functions
//   96   *
//   97 @verbatim
//   98  ===============================================================================
//   99               ##### Initialization and de-initialization functions #####
//  100  ===============================================================================
//  101     [..]
//  102       After reset, the backup domain (RTC registers, RTC backup data 
//  103       registers and backup SRAM) is protected against possible unwanted 
//  104       write accesses. 
//  105       To enable access to the RTC Domain and RTC registers, proceed as follows:
//  106         (+) Enable the Power Controller (PWR) APB1 interface clock using the
//  107             __HAL_RCC_PWR_CLK_ENABLE() macro.
//  108         (+) Enable access to RTC domain using the HAL_PWR_EnableBkUpAccess() function.
//  109  
//  110 @endverbatim
//  111   * @{
//  112   */
//  113 
//  114 /**
//  115   * @brief Deinitializes the HAL PWR peripheral registers to their default reset values.
//  116   * @retval None
//  117   */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock0 Using cfiCommon0
          CFI Function HAL_PWR_DeInit
          CFI NoCalls
        THUMB
//  118 void HAL_PWR_DeInit(void)
//  119 {
//  120   __HAL_RCC_PWR_FORCE_RESET();
HAL_PWR_DeInit:
        LDR.N    R0,??DataTable15  ;; 0x40023820
        LDR      R0,[R0, #+0]
        ORRS     R0,R0,#0x10000000
        LDR.N    R1,??DataTable15  ;; 0x40023820
        STR      R0,[R1, #+0]
//  121   __HAL_RCC_PWR_RELEASE_RESET();
        LDR.N    R0,??DataTable15  ;; 0x40023820
        LDR      R0,[R0, #+0]
        BICS     R0,R0,#0x10000000
        LDR.N    R1,??DataTable15  ;; 0x40023820
        STR      R0,[R1, #+0]
//  122 }
        BX       LR               ;; return
          CFI EndBlock cfiBlock0
//  123 
//  124 /**
//  125   * @brief Enables access to the backup domain (RTC registers, RTC 
//  126   *         backup data registers and backup SRAM).
//  127   * @note If the HSE divided by 2, 3, ..31 is used as the RTC clock, the 
//  128   *         Backup Domain Access should be kept enabled.
//  129   * @retval None
//  130   */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock1 Using cfiCommon0
          CFI Function HAL_PWR_EnableBkUpAccess
          CFI NoCalls
        THUMB
//  131 void HAL_PWR_EnableBkUpAccess(void)
//  132 {
//  133   /* Enable access to RTC and backup registers */
//  134   SET_BIT(PWR->CR1, PWR_CR1_DBP);
HAL_PWR_EnableBkUpAccess:
        LDR.N    R0,??DataTable15_1  ;; 0x40007000
        LDR      R0,[R0, #+0]
        ORRS     R0,R0,#0x100
        LDR.N    R1,??DataTable15_1  ;; 0x40007000
        STR      R0,[R1, #+0]
//  135 }
        BX       LR               ;; return
          CFI EndBlock cfiBlock1
//  136 
//  137 /**
//  138   * @brief Disables access to the backup domain (RTC registers, RTC 
//  139   *         backup data registers and backup SRAM).
//  140   * @note If the HSE divided by 2, 3, ..31 is used as the RTC clock, the 
//  141   *         Backup Domain Access should be kept enabled.
//  142   * @retval None
//  143   */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock2 Using cfiCommon0
          CFI Function HAL_PWR_DisableBkUpAccess
          CFI NoCalls
        THUMB
//  144 void HAL_PWR_DisableBkUpAccess(void)
//  145 {
//  146   /* Disable access to RTC and backup registers */
//  147 	CLEAR_BIT(PWR->CR1, PWR_CR1_DBP);
HAL_PWR_DisableBkUpAccess:
        LDR.N    R0,??DataTable15_1  ;; 0x40007000
        LDR      R0,[R0, #+0]
        BICS     R0,R0,#0x100
        LDR.N    R1,??DataTable15_1  ;; 0x40007000
        STR      R0,[R1, #+0]
//  148 }
        BX       LR               ;; return
          CFI EndBlock cfiBlock2
//  149 
//  150 /**
//  151   * @}
//  152   */
//  153 
//  154 /** @defgroup PWR_Exported_Functions_Group2 Peripheral Control functions 
//  155   *  @brief Low Power modes configuration functions 
//  156   *
//  157 @verbatim
//  158 
//  159  ===============================================================================
//  160                  ##### Peripheral Control functions #####
//  161  ===============================================================================
//  162      
//  163     *** PVD configuration ***
//  164     =========================
//  165     [..]
//  166       (+) The PVD is used to monitor the VDD power supply by comparing it to a 
//  167           threshold selected by the PVD Level (PLS[2:0] bits in the PWR_CR).
//  168       (+) A PVDO flag is available to indicate if VDD/VDDA is higher or lower 
//  169           than the PVD threshold. This event is internally connected to the EXTI 
//  170           line16 and can generate an interrupt if enabled. This is done through
//  171           __HAL_PWR_PVD_EXTI_ENABLE_IT() macro.
//  172       (+) The PVD is stopped in Standby mode.
//  173 
//  174     *** Wake-up pin configuration ***
//  175     ================================
//  176     [..]
//  177       (+) Wake-up pin is used to wake up the system from Standby mode. This pin is 
//  178           forced in input pull-down configuration and is active on rising edges.
//  179       (+) There are to 6 Wake-up pin in the STM32F7 devices family
//  180 
//  181     *** Low Power modes configuration ***
//  182     =====================================
//  183     [..]
//  184       The devices feature 3 low-power modes:
//  185       (+) Sleep mode: Cortex-M7 core stopped, peripherals kept running.
//  186       (+) Stop mode: all clocks are stopped, regulator running, regulator 
//  187           in low power mode
//  188       (+) Standby mode: 1.2V domain powered off.
//  189    
//  190    *** Sleep mode ***
//  191    ==================
//  192     [..]
//  193       (+) Entry:
//  194         The Sleep mode is entered by using the HAL_PWR_EnterSLEEPMode(PWR_MAINREGULATOR_ON, PWR_SLEEPENTRY_WFI)
//  195               functions with
//  196           (++) PWR_SLEEPENTRY_WFI: enter SLEEP mode with WFI instruction
//  197           (++) PWR_SLEEPENTRY_WFE: enter SLEEP mode with WFE instruction
//  198       
//  199       -@@- The Regulator parameter is not used for the STM32F7 family 
//  200               and is kept as parameter just to maintain compatibility with the 
//  201               lower power families (STM32L).
//  202       (+) Exit:
//  203         Any peripheral interrupt acknowledged by the nested vectored interrupt 
//  204               controller (NVIC) can wake up the device from Sleep mode.
//  205 
//  206    *** Stop mode ***
//  207    =================
//  208     [..]
//  209       In Stop mode, all clocks in the 1.2V domain are stopped, the PLL, the HSI,
//  210       and the HSE RC oscillators are disabled. Internal SRAM and register contents 
//  211       are preserved.
//  212       The voltage regulator can be configured either in normal or low-power mode.
//  213       To minimize the consumption In Stop mode, FLASH can be powered off before 
//  214       entering the Stop mode using the HAL_PWREx_EnableFlashPowerDown() function.
//  215       It can be switched on again by software after exiting the Stop mode using
//  216       the HAL_PWREx_DisableFlashPowerDown() function. 
//  217 
//  218       (+) Entry:
//  219          The Stop mode is entered using the HAL_PWR_EnterSTOPMode(PWR_MAINREGULATOR_ON) 
//  220              function with:
//  221           (++) Main regulator ON.
//  222           (++) Low Power regulator ON.
//  223       (+) Exit:
//  224         Any EXTI Line (Internal or External) configured in Interrupt/Event mode.
//  225 
//  226    *** Standby mode ***
//  227    ====================
//  228     [..]
//  229     (+)
//  230       The Standby mode allows to achieve the lowest power consumption. It is based 
//  231       on the Cortex-M7 deep sleep mode, with the voltage regulator disabled. 
//  232       The 1.2V domain is consequently powered off. The PLL, the HSI oscillator and 
//  233       the HSE oscillator are also switched off. SRAM and register contents are lost 
//  234       except for the RTC registers, RTC backup registers, backup SRAM and Standby 
//  235       circuitry.
//  236    
//  237       The voltage regulator is OFF.
//  238       
//  239       (++) Entry:
//  240         (+++) The Standby mode is entered using the HAL_PWR_EnterSTANDBYMode() function.
//  241       (++) Exit:
//  242         (+++) WKUP pin rising or falling edge, RTC alarm (Alarm A and Alarm B), RTC
//  243              wakeup, tamper event, time stamp event, external reset in NRST pin, IWDG reset.
//  244 
//  245    *** Auto-wakeup (AWU) from low-power mode ***
//  246    =============================================
//  247     [..]
//  248     
//  249      (+) The MCU can be woken up from low-power mode by an RTC Alarm event, an RTC 
//  250       Wakeup event, a tamper event or a time-stamp event, without depending on 
//  251       an external interrupt (Auto-wakeup mode).
//  252 
//  253       (+) RTC auto-wakeup (AWU) from the Stop and Standby modes
//  254        
//  255         (++) To wake up from the Stop mode with an RTC alarm event, it is necessary to 
//  256               configure the RTC to generate the RTC alarm using the HAL_RTC_SetAlarm_IT() function.
//  257 
//  258         (++) To wake up from the Stop mode with an RTC Tamper or time stamp event, it 
//  259              is necessary to configure the RTC to detect the tamper or time stamp event using the
//  260                 HAL_RTCEx_SetTimeStamp_IT() or HAL_RTCEx_SetTamper_IT() functions.
//  261                   
//  262         (++) To wake up from the Stop mode with an RTC WakeUp event, it is necessary to
//  263               configure the RTC to generate the RTC WakeUp event using the HAL_RTCEx_SetWakeUpTimer_IT() function.
//  264 
//  265 @endverbatim
//  266   * @{
//  267   */
//  268 
//  269 /**
//  270   * @brief Configures the voltage threshold detected by the Power Voltage Detector(PVD).
//  271   * @param sConfigPVD: pointer to an PWR_PVDTypeDef structure that contains the configuration
//  272   *        information for the PVD.
//  273   * @note Refer to the electrical characteristics of your device datasheet for
//  274   *         more details about the voltage threshold corresponding to each 
//  275   *         detection level.
//  276   * @retval None
//  277   */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock3 Using cfiCommon0
          CFI Function HAL_PWR_ConfigPVD
          CFI NoCalls
        THUMB
//  278 void HAL_PWR_ConfigPVD(PWR_PVDTypeDef *sConfigPVD)
//  279 {
//  280   /* Check the parameters */
//  281   assert_param(IS_PWR_PVD_LEVEL(sConfigPVD->PVDLevel));
//  282   assert_param(IS_PWR_PVD_MODE(sConfigPVD->Mode));
//  283   
//  284   /* Set PLS[7:5] bits according to PVDLevel value */
//  285   MODIFY_REG(PWR->CR1, PWR_CR1_PLS, sConfigPVD->PVDLevel);
HAL_PWR_ConfigPVD:
        LDR.N    R1,??DataTable15_1  ;; 0x40007000
        LDR      R1,[R1, #+0]
        BICS     R1,R1,#0xE0
        LDR      R2,[R0, #+0]
        ORRS     R1,R2,R1
        LDR.N    R2,??DataTable15_1  ;; 0x40007000
        STR      R1,[R2, #+0]
//  286   
//  287   /* Clear any previous config. Keep it clear if no event or IT mode is selected */
//  288   __HAL_PWR_PVD_EXTI_DISABLE_EVENT();
        LDR.N    R1,??DataTable15_2  ;; 0x40013c04
        LDR      R1,[R1, #+0]
        BICS     R1,R1,#0x10000
        LDR.N    R2,??DataTable15_2  ;; 0x40013c04
        STR      R1,[R2, #+0]
//  289   __HAL_PWR_PVD_EXTI_DISABLE_IT();
        LDR.N    R1,??DataTable15_3  ;; 0x40013c00
        LDR      R1,[R1, #+0]
        BICS     R1,R1,#0x10000
        LDR.N    R2,??DataTable15_3  ;; 0x40013c00
        STR      R1,[R2, #+0]
//  290   __HAL_PWR_PVD_EXTI_DISABLE_RISING_EDGE();
        LDR.N    R1,??DataTable15_4  ;; 0x40013c08
        LDR      R1,[R1, #+0]
        BICS     R1,R1,#0x10000
        LDR.N    R2,??DataTable15_4  ;; 0x40013c08
        STR      R1,[R2, #+0]
//  291   __HAL_PWR_PVD_EXTI_DISABLE_FALLING_EDGE(); 
        LDR.N    R1,??DataTable15_5  ;; 0x40013c0c
        LDR      R1,[R1, #+0]
        BICS     R1,R1,#0x10000
        LDR.N    R2,??DataTable15_5  ;; 0x40013c0c
        STR      R1,[R2, #+0]
//  292 
//  293   /* Configure interrupt mode */
//  294   if((sConfigPVD->Mode & PVD_MODE_IT) == PVD_MODE_IT)
        LDR      R1,[R0, #+4]
        LSLS     R1,R1,#+15
        BPL.N    ??HAL_PWR_ConfigPVD_0
//  295   {
//  296     __HAL_PWR_PVD_EXTI_ENABLE_IT();
        LDR.N    R1,??DataTable15_3  ;; 0x40013c00
        LDR      R1,[R1, #+0]
        ORRS     R1,R1,#0x10000
        LDR.N    R2,??DataTable15_3  ;; 0x40013c00
        STR      R1,[R2, #+0]
//  297   }
//  298   
//  299   /* Configure event mode */
//  300   if((sConfigPVD->Mode & PVD_MODE_EVT) == PVD_MODE_EVT)
??HAL_PWR_ConfigPVD_0:
        LDR      R1,[R0, #+4]
        LSLS     R1,R1,#+14
        BPL.N    ??HAL_PWR_ConfigPVD_1
//  301   {
//  302     __HAL_PWR_PVD_EXTI_ENABLE_EVENT();
        LDR.N    R1,??DataTable15_2  ;; 0x40013c04
        LDR      R1,[R1, #+0]
        ORRS     R1,R1,#0x10000
        LDR.N    R2,??DataTable15_2  ;; 0x40013c04
        STR      R1,[R2, #+0]
//  303   }
//  304   
//  305   /* Configure the edge */
//  306   if((sConfigPVD->Mode & PVD_RISING_EDGE) == PVD_RISING_EDGE)
??HAL_PWR_ConfigPVD_1:
        LDRB     R1,[R0, #+4]
        LSLS     R1,R1,#+31
        BPL.N    ??HAL_PWR_ConfigPVD_2
//  307   {
//  308     __HAL_PWR_PVD_EXTI_ENABLE_RISING_EDGE();
        LDR.N    R1,??DataTable15_4  ;; 0x40013c08
        LDR      R1,[R1, #+0]
        ORRS     R1,R1,#0x10000
        LDR.N    R2,??DataTable15_4  ;; 0x40013c08
        STR      R1,[R2, #+0]
//  309   }
//  310   
//  311   if((sConfigPVD->Mode & PVD_FALLING_EDGE) == PVD_FALLING_EDGE)
??HAL_PWR_ConfigPVD_2:
        LDRB     R1,[R0, #+4]
        LSLS     R1,R1,#+30
        BPL.N    ??HAL_PWR_ConfigPVD_3
//  312   {
//  313     __HAL_PWR_PVD_EXTI_ENABLE_FALLING_EDGE();
        LDR.N    R1,??DataTable15_5  ;; 0x40013c0c
        LDR      R1,[R1, #+0]
        ORRS     R1,R1,#0x10000
        LDR.N    R2,??DataTable15_5  ;; 0x40013c0c
        STR      R1,[R2, #+0]
//  314   }
//  315 }
??HAL_PWR_ConfigPVD_3:
        BX       LR               ;; return
          CFI EndBlock cfiBlock3
//  316 
//  317 /**
//  318   * @brief Enables the Power Voltage Detector(PVD).
//  319   * @retval None
//  320   */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock4 Using cfiCommon0
          CFI Function HAL_PWR_EnablePVD
          CFI NoCalls
        THUMB
//  321 void HAL_PWR_EnablePVD(void)
//  322 {
//  323   /* Enable the power voltage detector */
//  324 	SET_BIT(PWR->CR1, PWR_CR1_PVDE);
HAL_PWR_EnablePVD:
        LDR.N    R0,??DataTable15_1  ;; 0x40007000
        LDR      R0,[R0, #+0]
        ORRS     R0,R0,#0x10
        LDR.N    R1,??DataTable15_1  ;; 0x40007000
        STR      R0,[R1, #+0]
//  325 }
        BX       LR               ;; return
          CFI EndBlock cfiBlock4
//  326 
//  327 /**
//  328   * @brief Disables the Power Voltage Detector(PVD).
//  329   * @retval None
//  330   */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock5 Using cfiCommon0
          CFI Function HAL_PWR_DisablePVD
          CFI NoCalls
        THUMB
//  331 void HAL_PWR_DisablePVD(void)
//  332 {
//  333   /* Disable the power voltage detector */
//  334 	CLEAR_BIT(PWR->CR1, PWR_CR1_PVDE);
HAL_PWR_DisablePVD:
        LDR.N    R0,??DataTable15_1  ;; 0x40007000
        LDR      R0,[R0, #+0]
        BICS     R0,R0,#0x10
        LDR.N    R1,??DataTable15_1  ;; 0x40007000
        STR      R0,[R1, #+0]
//  335 }
        BX       LR               ;; return
          CFI EndBlock cfiBlock5
//  336 
//  337 /**
//  338   * @brief Enable the WakeUp PINx functionality.
//  339   * @param WakeUpPinPolarity: Specifies which Wake-Up pin to enable.
//  340   *         This parameter can be one of the following legacy values, which sets the default polarity: 
//  341   *         detection on high level (rising edge):
//  342   *           @arg PWR_WAKEUP_PIN1, PWR_WAKEUP_PIN2, PWR_WAKEUP_PIN3, PWR_WAKEUP_PIN4, PWR_WAKEUP_PIN5, PWR_WAKEUP_PIN6 
//  343   *         or one of the following value where the user can explicitly states the enabled pin and
//  344   *         the chosen polarity  
//  345   *           @arg PWR_WAKEUP_PIN1_HIGH or PWR_WAKEUP_PIN1_LOW 
//  346   *           @arg PWR_WAKEUP_PIN2_HIGH or PWR_WAKEUP_PIN2_LOW 
//  347   *           @arg PWR_WAKEUP_PIN3_HIGH or PWR_WAKEUP_PIN3_LOW 
//  348   *           @arg PWR_WAKEUP_PIN4_HIGH or PWR_WAKEUP_PIN4_LOW
//  349   *           @arg PWR_WAKEUP_PIN5_HIGH or PWR_WAKEUP_PIN5_LOW 
//  350   *           @arg PWR_WAKEUP_PIN6_HIGH or PWR_WAKEUP_PIN6_LOW 
//  351   * @note  PWR_WAKEUP_PINx and PWR_WAKEUP_PINx_HIGH are equivalent.               
//  352   * @retval None
//  353   */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock6 Using cfiCommon0
          CFI Function HAL_PWR_EnableWakeUpPin
          CFI NoCalls
        THUMB
//  354 void HAL_PWR_EnableWakeUpPin(uint32_t WakeUpPinPolarity)
//  355 {
//  356   assert_param(IS_PWR_WAKEUP_PIN(WakeUpPinPolarity));
//  357   
//  358   /* Enable wake-up pin */
//  359   SET_BIT(PWR->CSR2, (PWR_EWUP_MASK & WakeUpPinPolarity));
HAL_PWR_EnableWakeUpPin:
        LDR.N    R1,??DataTable15_6  ;; 0x4000700c
        LDR      R1,[R1, #+0]
        ANDS     R2,R0,#0x3F00
        ORRS     R1,R2,R1
        LDR.N    R2,??DataTable15_6  ;; 0x4000700c
        STR      R1,[R2, #+0]
//  360 	
//  361   /* Specifies the Wake-Up pin polarity for the event detection
//  362     (rising or falling edge) */
//  363   MODIFY_REG(PWR->CR2, (PWR_EWUP_MASK & WakeUpPinPolarity), (WakeUpPinPolarity >> 0x06));
        LDR.N    R1,??DataTable15_7  ;; 0x40007008
        LDR      R1,[R1, #+0]
        ANDS     R2,R0,#0x3F00
        BICS     R1,R1,R2
        ORRS     R1,R1,R0, LSR #+6
        LDR.N    R2,??DataTable15_7  ;; 0x40007008
        STR      R1,[R2, #+0]
//  364 }
        BX       LR               ;; return
          CFI EndBlock cfiBlock6
//  365 
//  366 /**
//  367   * @brief Disables the WakeUp PINx functionality.
//  368   * @param WakeUpPinx: Specifies the Power Wake-Up pin to disable.
//  369   *         This parameter can be one of the following values:
//  370   *           @arg PWR_WAKEUP_PIN1
//  371   *           @arg PWR_WAKEUP_PIN2
//  372   *           @arg PWR_WAKEUP_PIN3
//  373   *           @arg PWR_WAKEUP_PIN4
//  374   *           @arg PWR_WAKEUP_PIN5
//  375   *           @arg PWR_WAKEUP_PIN6 
//  376   * @retval None
//  377   */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock7 Using cfiCommon0
          CFI Function HAL_PWR_DisableWakeUpPin
          CFI NoCalls
        THUMB
//  378 void HAL_PWR_DisableWakeUpPin(uint32_t WakeUpPinx)
//  379 {
//  380   assert_param(IS_PWR_WAKEUP_PIN(WakeUpPinx));
//  381 
//  382   CLEAR_BIT(PWR->CSR2, WakeUpPinx);
HAL_PWR_DisableWakeUpPin:
        LDR.N    R1,??DataTable15_6  ;; 0x4000700c
        LDR      R1,[R1, #+0]
        BICS     R1,R1,R0
        LDR.N    R2,??DataTable15_6  ;; 0x4000700c
        STR      R1,[R2, #+0]
//  383 }
        BX       LR               ;; return
          CFI EndBlock cfiBlock7
//  384   
//  385 /**
//  386   * @brief Enters Sleep mode.
//  387   *   
//  388   * @note In Sleep mode, all I/O pins keep the same state as in Run mode.
//  389   * 
//  390   * @note In Sleep mode, the systick is stopped to avoid exit from this mode with
//  391   *       systick interrupt when used as time base for Timeout 
//  392   *                
//  393   * @param Regulator: Specifies the regulator state in SLEEP mode.
//  394   *            This parameter can be one of the following values:
//  395   *            @arg PWR_MAINREGULATOR_ON: SLEEP mode with regulator ON
//  396   *            @arg PWR_LOWPOWERREGULATOR_ON: SLEEP mode with low power regulator ON
//  397   * @note This parameter is not used for the STM32F7 family and is kept as parameter
//  398   *       just to maintain compatibility with the lower power families.
//  399   * @param SLEEPEntry: Specifies if SLEEP mode in entered with WFI or WFE instruction.
//  400   *          This parameter can be one of the following values:
//  401   *            @arg PWR_SLEEPENTRY_WFI: enter SLEEP mode with WFI instruction
//  402   *            @arg PWR_SLEEPENTRY_WFE: enter SLEEP mode with WFE instruction
//  403   * @retval None
//  404   */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock8 Using cfiCommon0
          CFI Function HAL_PWR_EnterSLEEPMode
          CFI NoCalls
        THUMB
//  405 void HAL_PWR_EnterSLEEPMode(uint32_t Regulator, uint8_t SLEEPEntry)
//  406 {
//  407   /* Check the parameters */
//  408   assert_param(IS_PWR_REGULATOR(Regulator));
//  409   assert_param(IS_PWR_SLEEP_ENTRY(SLEEPEntry));
//  410 
//  411   /* Clear SLEEPDEEP bit of Cortex System Control Register */
//  412   CLEAR_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));
HAL_PWR_EnterSLEEPMode:
        LDR.N    R2,??DataTable15_8  ;; 0xe000ed10
        LDR      R2,[R2, #+0]
        BICS     R2,R2,#0x4
        LDR.N    R3,??DataTable15_8  ;; 0xe000ed10
        STR      R2,[R3, #+0]
//  413 
//  414   /* Select SLEEP mode entry -------------------------------------------------*/
//  415   if(SLEEPEntry == PWR_SLEEPENTRY_WFI)
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        CMP      R1,#+1
        BNE.N    ??HAL_PWR_EnterSLEEPMode_0
//  416   {   
//  417     /* Request Wait For Interrupt */
//  418     __WFI();
        WFI      
        B.N      ??HAL_PWR_EnterSLEEPMode_1
//  419   }
//  420   else
//  421   {
//  422     /* Request Wait For Event */
//  423     __SEV();
??HAL_PWR_EnterSLEEPMode_0:
        SEV      
//  424     __WFE();
        WFE      
//  425     __WFE();
        WFE      
//  426   }
//  427 }
??HAL_PWR_EnterSLEEPMode_1:
        BX       LR               ;; return
          CFI EndBlock cfiBlock8
//  428 
//  429 /**
//  430   * @brief Enters Stop mode. 
//  431   * @note In Stop mode, all I/O pins keep the same state as in Run mode.
//  432   * @note When exiting Stop mode by issuing an interrupt or a wakeup event, 
//  433   *         the HSI RC oscillator is selected as system clock.
//  434   * @note When the voltage regulator operates in low power mode, an additional 
//  435   *         startup delay is incurred when waking up from Stop mode. 
//  436   *         By keeping the internal regulator ON during Stop mode, the consumption 
//  437   *         is higher although the startup time is reduced.    
//  438   * @param Regulator: Specifies the regulator state in Stop mode.
//  439   *          This parameter can be one of the following values:
//  440   *            @arg PWR_MAINREGULATOR_ON: Stop mode with regulator ON
//  441   *            @arg PWR_LOWPOWERREGULATOR_ON: Stop mode with low power regulator ON
//  442   * @param STOPEntry: Specifies if Stop mode in entered with WFI or WFE instruction.
//  443   *          This parameter can be one of the following values:
//  444   *            @arg PWR_STOPENTRY_WFI: Enter Stop mode with WFI instruction
//  445   *            @arg PWR_STOPENTRY_WFE: Enter Stop mode with WFE instruction
//  446   * @retval None
//  447   */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock9 Using cfiCommon0
          CFI Function HAL_PWR_EnterSTOPMode
          CFI NoCalls
        THUMB
//  448 void HAL_PWR_EnterSTOPMode(uint32_t Regulator, uint8_t STOPEntry)
//  449 {
HAL_PWR_EnterSTOPMode:
        PUSH     {R4}
          CFI R4 Frame(CFA, -4)
          CFI CFA R13+4
//  450   uint32_t tmpreg = 0;
        MOVS     R2,#+0
//  451   
//  452   /* Check the parameters */
//  453   assert_param(IS_PWR_REGULATOR(Regulator));
//  454   assert_param(IS_PWR_STOP_ENTRY(STOPEntry));
//  455   
//  456   /* Select the regulator state in Stop mode ---------------------------------*/
//  457   tmpreg = PWR->CR1;
        LDR.N    R3,??DataTable15_1  ;; 0x40007000
        LDR      R3,[R3, #+0]
        MOVS     R2,R3
//  458   /* Clear PDDS and LPDS bits */
//  459   tmpreg &= (uint32_t)~(PWR_CR1_PDDS | PWR_CR1_LPDS);
        LSRS     R2,R2,#+2
        LSLS     R2,R2,#+2
//  460   
//  461   /* Set LPDS, MRLVDS and LPLVDS bits according to Regulator value */
//  462   tmpreg |= Regulator;
        ORRS     R2,R0,R2
//  463   
//  464   /* Store the new value */
//  465   PWR->CR1 = tmpreg;
        LDR.N    R3,??DataTable15_1  ;; 0x40007000
        STR      R2,[R3, #+0]
//  466   
//  467   /* Set SLEEPDEEP bit of Cortex System Control Register */
//  468   SCB->SCR |= SCB_SCR_SLEEPDEEP_Msk;
        LDR.N    R3,??DataTable15_8  ;; 0xe000ed10
        LDR      R3,[R3, #+0]
        ORRS     R3,R3,#0x4
        LDR.N    R4,??DataTable15_8  ;; 0xe000ed10
        STR      R3,[R4, #+0]
//  469   
//  470   /* Select Stop mode entry --------------------------------------------------*/
//  471   if(STOPEntry == PWR_STOPENTRY_WFI)
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        CMP      R1,#+1
        BNE.N    ??HAL_PWR_EnterSTOPMode_0
//  472   {   
//  473     /* Request Wait For Interrupt */
//  474     __WFI();
        WFI      
        B.N      ??HAL_PWR_EnterSTOPMode_1
//  475   }
//  476   else
//  477   {
//  478     /* Request Wait For Event */
//  479     __SEV();
??HAL_PWR_EnterSTOPMode_0:
        SEV      
//  480     __WFE();
        WFE      
//  481     __WFE();
        WFE      
//  482   }
//  483   /* Reset SLEEPDEEP bit of Cortex System Control Register */
//  484   SCB->SCR &= (uint32_t)~((uint32_t)SCB_SCR_SLEEPDEEP_Msk);  
??HAL_PWR_EnterSTOPMode_1:
        LDR.N    R3,??DataTable15_8  ;; 0xe000ed10
        LDR      R3,[R3, #+0]
        BICS     R3,R3,#0x4
        LDR.N    R4,??DataTable15_8  ;; 0xe000ed10
        STR      R3,[R4, #+0]
//  485 }
        POP      {R4}
          CFI R4 SameValue
          CFI CFA R13+0
        BX       LR               ;; return
          CFI EndBlock cfiBlock9
//  486 
//  487 /**
//  488   * @brief Enters Standby mode.
//  489   * @note In Standby mode, all I/O pins are high impedance except for:
//  490   *          - Reset pad (still available) 
//  491   *          - RTC_AF1 pin (PC13) if configured for tamper, time-stamp, RTC 
//  492   *            Alarm out, or RTC clock calibration out.
//  493   *          - RTC_AF2 pin (PI8) if configured for tamper or time-stamp.  
//  494   *          - WKUP pins if enabled.       
//  495   * @retval None
//  496   */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock10 Using cfiCommon0
          CFI Function HAL_PWR_EnterSTANDBYMode
          CFI NoCalls
        THUMB
//  497 void HAL_PWR_EnterSTANDBYMode(void)
//  498 {
//  499   /* Select Standby mode */
//  500   PWR->CR1 |= PWR_CR1_PDDS;
HAL_PWR_EnterSTANDBYMode:
        LDR.N    R0,??DataTable15_1  ;; 0x40007000
        LDR      R0,[R0, #+0]
        ORRS     R0,R0,#0x2
        LDR.N    R1,??DataTable15_1  ;; 0x40007000
        STR      R0,[R1, #+0]
//  501   
//  502   /* Set SLEEPDEEP bit of Cortex System Control Register */
//  503   SCB->SCR |= SCB_SCR_SLEEPDEEP_Msk;
        LDR.N    R0,??DataTable15_8  ;; 0xe000ed10
        LDR      R0,[R0, #+0]
        ORRS     R0,R0,#0x4
        LDR.N    R1,??DataTable15_8  ;; 0xe000ed10
        STR      R0,[R1, #+0]
//  504   
//  505   /* This option is used to ensure that store operations are completed */
//  506 #if defined ( __CC_ARM)
//  507   __force_stores();
//  508 #endif
//  509   /* Request Wait For Interrupt */
//  510   __WFI();
        WFI      
//  511 }
        BX       LR               ;; return
          CFI EndBlock cfiBlock10
//  512 
//  513 /**
//  514   * @brief This function handles the PWR PVD interrupt request.
//  515   * @note This API should be called under the PVD_IRQHandler().
//  516   * @retval None
//  517   */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock11 Using cfiCommon0
          CFI Function HAL_PWR_PVD_IRQHandler
        THUMB
//  518 void HAL_PWR_PVD_IRQHandler(void)
//  519 {
HAL_PWR_PVD_IRQHandler:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
//  520   /* Check PWR Exti flag */
//  521   if(__HAL_PWR_PVD_EXTI_GET_FLAG() != RESET)
        LDR.N    R0,??DataTable15_9  ;; 0x40013c14
        LDR      R0,[R0, #+0]
        LSLS     R0,R0,#+15
        BPL.N    ??HAL_PWR_PVD_IRQHandler_0
//  522   {
//  523     /* PWR PVD interrupt user callback */
//  524     HAL_PWR_PVDCallback();
          CFI FunCall HAL_PWR_PVDCallback
        BL       HAL_PWR_PVDCallback
//  525     
//  526     /* Clear PWR Exti pending bit */
//  527     __HAL_PWR_PVD_EXTI_CLEAR_FLAG();
        MOVS     R0,#+65536
        LDR.N    R1,??DataTable15_9  ;; 0x40013c14
        STR      R0,[R1, #+0]
//  528   }
//  529 }
??HAL_PWR_PVD_IRQHandler_0:
        POP      {R0,PC}          ;; return
          CFI EndBlock cfiBlock11
//  530 
//  531 /**
//  532   * @brief  PWR PVD interrupt callback
//  533   * @retval None
//  534   */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock12 Using cfiCommon0
          CFI Function HAL_PWR_PVDCallback
          CFI NoCalls
        THUMB
//  535 __weak void HAL_PWR_PVDCallback(void)
//  536 {
//  537   /* NOTE : This function Should not be modified, when the callback is needed,
//  538             the HAL_PWR_PVDCallback could be implemented in the user file
//  539    */ 
//  540 }
HAL_PWR_PVDCallback:
        BX       LR               ;; return
          CFI EndBlock cfiBlock12
//  541 
//  542 /**
//  543   * @brief Indicates Sleep-On-Exit when returning from Handler mode to Thread mode. 
//  544   * @note Set SLEEPONEXIT bit of SCR register. When this bit is set, the processor 
//  545   *       re-enters SLEEP mode when an interruption handling is over.
//  546   *       Setting this bit is useful when the processor is expected to run only on
//  547   *       interruptions handling.         
//  548   * @retval None
//  549   */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock13 Using cfiCommon0
          CFI Function HAL_PWR_EnableSleepOnExit
          CFI NoCalls
        THUMB
//  550 void HAL_PWR_EnableSleepOnExit(void)
//  551 {
//  552   /* Set SLEEPONEXIT bit of Cortex System Control Register */
//  553   SET_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPONEXIT_Msk));
HAL_PWR_EnableSleepOnExit:
        LDR.N    R0,??DataTable15_8  ;; 0xe000ed10
        LDR      R0,[R0, #+0]
        ORRS     R0,R0,#0x2
        LDR.N    R1,??DataTable15_8  ;; 0xe000ed10
        STR      R0,[R1, #+0]
//  554 }
        BX       LR               ;; return
          CFI EndBlock cfiBlock13
//  555 
//  556 /**
//  557   * @brief Disables Sleep-On-Exit feature when returning from Handler mode to Thread mode. 
//  558   * @note Clears SLEEPONEXIT bit of SCR register. When this bit is set, the processor 
//  559   *       re-enters SLEEP mode when an interruption handling is over.          
//  560   * @retval None
//  561   */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock14 Using cfiCommon0
          CFI Function HAL_PWR_DisableSleepOnExit
          CFI NoCalls
        THUMB
//  562 void HAL_PWR_DisableSleepOnExit(void)
//  563 {
//  564   /* Clear SLEEPONEXIT bit of Cortex System Control Register */
//  565   CLEAR_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPONEXIT_Msk));
HAL_PWR_DisableSleepOnExit:
        LDR.N    R0,??DataTable15_8  ;; 0xe000ed10
        LDR      R0,[R0, #+0]
        BICS     R0,R0,#0x2
        LDR.N    R1,??DataTable15_8  ;; 0xe000ed10
        STR      R0,[R1, #+0]
//  566 }
        BX       LR               ;; return
          CFI EndBlock cfiBlock14
//  567 
//  568 /**
//  569   * @brief Enables CORTEX M4 SEVONPEND bit. 
//  570   * @note Sets SEVONPEND bit of SCR register. When this bit is set, this causes 
//  571   *       WFE to wake up when an interrupt moves from inactive to pended.
//  572   * @retval None
//  573   */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock15 Using cfiCommon0
          CFI Function HAL_PWR_EnableSEVOnPend
          CFI NoCalls
        THUMB
//  574 void HAL_PWR_EnableSEVOnPend(void)
//  575 {
//  576   /* Set SEVONPEND bit of Cortex System Control Register */
//  577   SET_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SEVONPEND_Msk));
HAL_PWR_EnableSEVOnPend:
        LDR.N    R0,??DataTable15_8  ;; 0xe000ed10
        LDR      R0,[R0, #+0]
        ORRS     R0,R0,#0x10
        LDR.N    R1,??DataTable15_8  ;; 0xe000ed10
        STR      R0,[R1, #+0]
//  578 }
        BX       LR               ;; return
          CFI EndBlock cfiBlock15
//  579 
//  580 /**
//  581   * @brief Disables CORTEX M4 SEVONPEND bit. 
//  582   * @note Clears SEVONPEND bit of SCR register. When this bit is set, this causes 
//  583   *       WFE to wake up when an interrupt moves from inactive to pended.         
//  584   * @retval None
//  585   */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock16 Using cfiCommon0
          CFI Function HAL_PWR_DisableSEVOnPend
          CFI NoCalls
        THUMB
//  586 void HAL_PWR_DisableSEVOnPend(void)
//  587 {
//  588   /* Clear SEVONPEND bit of Cortex System Control Register */
//  589   CLEAR_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SEVONPEND_Msk));
HAL_PWR_DisableSEVOnPend:
        LDR.N    R0,??DataTable15_8  ;; 0xe000ed10
        LDR      R0,[R0, #+0]
        BICS     R0,R0,#0x10
        LDR.N    R1,??DataTable15_8  ;; 0xe000ed10
        STR      R0,[R1, #+0]
//  590 }
        BX       LR               ;; return
          CFI EndBlock cfiBlock16

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable15:
        DC32     0x40023820

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable15_1:
        DC32     0x40007000

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable15_2:
        DC32     0x40013c04

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable15_3:
        DC32     0x40013c00

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable15_4:
        DC32     0x40013c08

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable15_5:
        DC32     0x40013c0c

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable15_6:
        DC32     0x4000700c

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable15_7:
        DC32     0x40007008

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable15_8:
        DC32     0xe000ed10

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable15_9:
        DC32     0x40013c14

        SECTION `.iar_vfe_header`:DATA:NOALLOC:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
        DC32 0

        SECTION __DLIB_PERTHREAD:DATA:REORDER:NOROOT(0)
        SECTION_TYPE SHT_PROGBITS, 0

        SECTION __DLIB_PERTHREAD_init:DATA:REORDER:NOROOT(0)
        SECTION_TYPE SHT_PROGBITS, 0

        END
//  591 
//  592 /**
//  593   * @}
//  594   */
//  595   
//  596 /**
//  597   * @}
//  598   */
//  599 
//  600 #endif /* HAL_PWR_MODULE_ENABLED */
//  601 /**
//  602   * @}
//  603   */
//  604 
//  605 /**
//  606   * @}
//  607   */
//  608 
//  609 /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
// 
// 510 bytes in section .text
// 
// 510 bytes of CODE memory
//
//Errors: none
//Warnings: none
