###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.3.10732/W32 for ARM       15/May/2016  09:59:28
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\sop1hc\Mic\Mic_Array\Mic_Array\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_dma.c
#    Command line =  
#        D:\sop1hc\Mic\Mic_Array\Mic_Array\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_dma.c
#        -D USE_HAL_DRIVER -D STM32F746xx -D USE_STM32746G_DISCO -D
#        USE_IOEXPANDER -D USE_USB_FS -lC
#        D:\sop1hc\Mic\Mic_Array\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
#        -lA
#        D:\sop1hc\Mic\Mic_Array\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
#        -o
#        D:\sop1hc\Mic\Mic_Array\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj
#        --no_unroll --debug --endian=little --cpu=Cortex-M7 -e --fpu=VFPv5_sp
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Full.h" -I
#        D:\sop1hc\Mic\Mic_Array\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\Inc\
#        -I
#        D:\sop1hc\Mic\Mic_Array\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\CMSIS\Device\ST\STM32F7xx\Include\
#        -I
#        D:\sop1hc\Mic\Mic_Array\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\STM32F7xx_HAL_Driver\Inc\
#        -I
#        D:\sop1hc\Mic\Mic_Array\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\STM32746G-Discovery\
#        -I
#        D:\sop1hc\Mic\Mic_Array\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\Components\Common\
#        -I
#        D:\sop1hc\Mic\Mic_Array\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Log\
#        -I
#        D:\sop1hc\Mic\Mic_Array\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Fonts\
#        -I
#        D:\sop1hc\Mic\Mic_Array\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\CPU\
#        -I
#        D:\sop1hc\Mic\Mic_Array\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_Device_Library\Core\Inc\
#        -I
#        D:\sop1hc\Mic\Mic_Array\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Core\Inc\
#        -I
#        D:\sop1hc\Mic\Mic_Array\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Class\MSC\Inc\
#        -I
#        D:\sop1hc\Mic\Mic_Array\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\
#        -I
#        D:\sop1hc\Mic\Mic_Array\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\drivers\
#        -I
#        D:\sop1hc\Mic\Mic_Array\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_Audio\Addons\PDM\
#        -I
#        D:\sop1hc\Mic\Mic_Array\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_Device_Library\Class\AUDIO\Inc\
#        -Ohs --use_c++_inline --require_prototypes -I "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.3\arm\CMSIS\Include\" -D
#        ARM_MATH_CM7 --relaxed_fp
#    List file    =  
#        D:\sop1hc\Mic\Mic_Array\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List\stm32f7xx_hal_dma.lst
#    Object file  =  
#        D:\sop1hc\Mic\Mic_Array\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj\stm32f7xx_hal_dma.o
#
###############################################################################

D:\sop1hc\Mic\Mic_Array\Mic_Array\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_dma.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f7xx_hal_dma.c
      4            * @author  MCD Application Team
      5            * @version V1.0.4
      6            * @date    09-December-2015
      7            * @brief   DMA HAL module driver.
      8            *    
      9            *          This file provides firmware functions to manage the following 
     10            *          functionalities of the Direct Memory Access (DMA) peripheral:
     11            *           + Initialization and de-initialization functions
     12            *           + IO operation functions
     13            *           + Peripheral State and errors functions
     14            @verbatim     
     15            ==============================================================================      
     16                                  ##### How to use this driver #####
     17            ============================================================================== 
     18            [..]
     19             (#) Enable and configure the peripheral to be connected to the DMA Stream
     20                 (except for internal SRAM/FLASH memories: no initialization is 
     21                 necessary) please refer to Reference manual for connection between peripherals
     22                 and DMA requests . 
     23                    
     24             (#) For a given Stream, program the required configuration through the following parameters:   
     25                 Transfer Direction, Source and Destination data formats, 
     26                 Circular, Normal or peripheral flow control mode, Stream Priority level, 
     27                 Source and Destination Increment mode, FIFO mode and its Threshold (if needed), 
     28                 Burst mode for Source and/or Destination (if needed) using HAL_DMA_Init() function.
     29                               
     30               *** Polling mode IO operation ***
     31               =================================   
     32              [..] 
     33                    (+) Use HAL_DMA_Start() to start DMA transfer after the configuration of Source 
     34                        address and destination address and the Length of data to be transferred
     35                    (+) Use HAL_DMA_PollForTransfer() to poll for the end of current transfer, in this  
     36                        case a fixed Timeout can be configured by User depending from his application.
     37                         
     38               *** Interrupt mode IO operation ***    
     39               =================================== 
     40              [..]     
     41                    (+) Configure the DMA interrupt priority using HAL_NVIC_SetPriority()
     42                    (+) Enable the DMA IRQ handler using HAL_NVIC_EnableIRQ() 
     43                    (+) Use HAL_DMA_Start_IT() to start DMA transfer after the configuration of  
     44                        Source address and destination address and the Length of data to be transferred. In this 
     45                        case the DMA interrupt is configured 
     46                    (+) Use HAL_DMA_IRQHandler() called under DMA_IRQHandler() Interrupt subroutine
     47                    (+) At the end of data transfer HAL_DMA_IRQHandler() function is executed and user can 
     48                        add his own function by customization of function pointer XferCpltCallback and 
     49                        XferErrorCallback (i.e a member of DMA handle structure). 
     50              [..]                
     51               (#) Use HAL_DMA_GetState() function to return the DMA state and HAL_DMA_GetError() in case of error 
     52                   detection.
     53                   
     54               (#) Use HAL_DMA_Abort() function to abort the current transfer
     55               
     56               -@-   In Memory-to-Memory transfer mode, Circular mode is not allowed.
     57              
     58               -@-   The FIFO is used mainly to reduce bus usage and to allow data packing/unpacking: it is
     59                     possible to set different Data Sizes for the Peripheral and the Memory (ie. you can set
     60                     Half-Word data size for the peripheral to access its data register and set Word data size
     61                     for the Memory to gain in access time. Each two half words will be packed and written in
     62                     a single access to a Word in the Memory).
     63                
     64               -@-   When FIFO is disabled, it is not allowed to configure different Data Sizes for Source
     65                     and Destination. In this case the Peripheral Data Size will be applied to both Source
     66                     and Destination.               
     67            
     68               *** DMA HAL driver macros list ***
     69               ============================================= 
     70               [..]
     71                 Below the list of most used macros in DMA HAL driver.
     72                 
     73                (+) __HAL_DMA_ENABLE: Enable the specified DMA Stream.
     74                (+) __HAL_DMA_DISABLE: Disable the specified DMA Stream.
     75                (+) __HAL_DMA_GET_FS: Return the current DMA Stream FIFO filled level.
     76                (+) __HAL_DMA_ENABLE_IT: Enable the specified DMA Stream interrupts.
     77                (+) __HAL_DMA_DISABLE_IT: Disable the specified DMA Stream interrupts.
     78                (+) __HAL_DMA_GET_IT_SOURCE: Check whether the specified DMA Stream interrupt has occurred or not. 
     79               
     80               [..] 
     81                (@) You can refer to the DMA HAL driver header file for more useful macros  
     82            
     83            @endverbatim
     84            ******************************************************************************
     85            * @attention
     86            *
     87            * <h2><center>&copy; COPYRIGHT(c) 2015 STMicroelectronics</center></h2>
     88            *
     89            * Redistribution and use in source and binary forms, with or without modification,
     90            * are permitted provided that the following conditions are met:
     91            *   1. Redistributions of source code must retain the above copyright notice,
     92            *      this list of conditions and the following disclaimer.
     93            *   2. Redistributions in binary form must reproduce the above copyright notice,
     94            *      this list of conditions and the following disclaimer in the documentation
     95            *      and/or other materials provided with the distribution.
     96            *   3. Neither the name of STMicroelectronics nor the names of its contributors
     97            *      may be used to endorse or promote products derived from this software
     98            *      without specific prior written permission.
     99            *
    100            * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
    101            * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
    102            * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
    103            * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
    104            * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
    105            * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
    106            * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
    107            * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
    108            * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
    109            * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
    110            *
    111            ******************************************************************************
    112            */ 
    113          
    114          /* Includes ------------------------------------------------------------------*/
    115          #include "stm32f7xx_hal.h"
    116          
    117          /** @addtogroup STM32F7xx_HAL_Driver
    118            * @{
    119            */
    120          
    121          /** @defgroup DMA DMA
    122            * @brief DMA HAL module driver
    123            * @{
    124            */
    125          
    126          #ifdef HAL_DMA_MODULE_ENABLED
    127          
    128          /* Private types -------------------------------------------------------------*/
    129          typedef struct
    130          {
    131            __IO uint32_t ISR;   /*!< DMA interrupt status register */
    132            __IO uint32_t Reserved0;
    133            __IO uint32_t IFCR;  /*!< DMA interrupt flag clear register */
    134          } DMA_Base_Registers;
    135          
    136          /* Private variables ---------------------------------------------------------*/
    137          /* Private constants ---------------------------------------------------------*/
    138          /** @addtogroup DMA_Private_Constants
    139           * @{
    140           */
    141           #define HAL_TIMEOUT_DMA_ABORT    ((uint32_t)1000)  /* 1s */
    142          /**
    143            * @}
    144            */
    145          /* Private macros ------------------------------------------------------------*/
    146          /* Private functions ---------------------------------------------------------*/
    147          /** @addtogroup DMA_Private_Functions
    148            * @{
    149            */
    150          static void DMA_SetConfig(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength);
    151          static uint32_t DMA_CalcBaseAndBitshift(DMA_HandleTypeDef *hdma);
    152          
    153          /**
    154            * @brief  Sets the DMA Transfer parameter.
    155            * @param  hdma:       pointer to a DMA_HandleTypeDef structure that contains
    156            *                     the configuration information for the specified DMA Stream.
    157            * @param  SrcAddress: The source memory Buffer address
    158            * @param  DstAddress: The destination memory Buffer address
    159            * @param  DataLength: The length of data to be transferred from source to destination
    160            * @retval HAL status
    161            */
    162          static void DMA_SetConfig(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
    163          {
    164            /* Clear DBM bit */
    165            hdma->Instance->CR &= (uint32_t)(~DMA_SxCR_DBM);
    166          	
    167            /* Configure DMA Stream data length */
    168            hdma->Instance->NDTR = DataLength;
    169          
    170            /* Peripheral to Memory */
    171            if((hdma->Init.Direction) == DMA_MEMORY_TO_PERIPH)
    172            {
    173              /* Configure DMA Stream destination address */
    174              hdma->Instance->PAR = DstAddress;
    175          
    176              /* Configure DMA Stream source address */
    177              hdma->Instance->M0AR = SrcAddress;
    178            }
    179            /* Memory to Peripheral */
    180            else
    181            {
    182              /* Configure DMA Stream source address */
    183              hdma->Instance->PAR = SrcAddress;
    184              
    185              /* Configure DMA Stream destination address */
    186              hdma->Instance->M0AR = DstAddress;
    187            }
    188          }
    189          
    190          /**
    191            * @}
    192            */  
    193            
    194          /* Exported functions ---------------------------------------------------------*/
    195          /** @addtogroup DMA_Exported_Functions
    196            * @{
    197            */
    198          
    199          /** @addtogroup DMA_Exported_Functions_Group1
    200            *
    201          @verbatim   
    202           ===============================================================================
    203                       ##### Initialization and de-initialization functions  #####
    204           ===============================================================================  
    205              [..]
    206              This section provides functions allowing to initialize the DMA Stream source
    207              and destination addresses, incrementation and data sizes, transfer direction, 
    208              circular/normal mode selection, memory-to-memory mode selection and Stream priority value.
    209              [..]
    210              The HAL_DMA_Init() function follows the DMA configuration procedures as described in
    211              reference manual.  
    212          
    213          @endverbatim
    214            * @{
    215            */
    216            
    217          /**
    218            * @brief  Initializes the DMA according to the specified
    219            *         parameters in the DMA_InitTypeDef and create the associated handle.
    220            * @param  hdma: Pointer to a DMA_HandleTypeDef structure that contains
    221            *               the configuration information for the specified DMA Stream.  
    222            * @retval HAL status
    223            */

   \                                 In section .text, align 2, keep-with-next
    224          HAL_StatusTypeDef HAL_DMA_Init(DMA_HandleTypeDef *hdma)
    225          { 
    226            uint32_t tmp = 0;
    227            
    228            /* Check the DMA peripheral state */
    229            if(hdma == NULL)
   \                     HAL_DMA_Init: (+1)
   \   00000000   0xB908             CBNZ.N   R0,??HAL_DMA_Init_0
    230            {
    231              return HAL_ERROR;
   \   00000002   0x2001             MOVS     R0,#+1
   \   00000004   0x4770             BX       LR
    232            }
    233          
    234            /* Check the parameters */
    235            assert_param(IS_DMA_STREAM_ALL_INSTANCE(hdma->Instance));
    236            assert_param(IS_DMA_CHANNEL(hdma->Init.Channel));
    237            assert_param(IS_DMA_DIRECTION(hdma->Init.Direction));
    238            assert_param(IS_DMA_PERIPHERAL_INC_STATE(hdma->Init.PeriphInc));
    239            assert_param(IS_DMA_MEMORY_INC_STATE(hdma->Init.MemInc));
    240            assert_param(IS_DMA_PERIPHERAL_DATA_SIZE(hdma->Init.PeriphDataAlignment));
    241            assert_param(IS_DMA_MEMORY_DATA_SIZE(hdma->Init.MemDataAlignment));
    242            assert_param(IS_DMA_MODE(hdma->Init.Mode));
    243            assert_param(IS_DMA_PRIORITY(hdma->Init.Priority));
    244            assert_param(IS_DMA_FIFO_MODE_STATE(hdma->Init.FIFOMode));
    245            /* Check the memory burst, peripheral burst and FIFO threshold parameters only
    246               when FIFO mode is enabled */
    247            if(hdma->Init.FIFOMode != DMA_FIFOMODE_DISABLE)
    248            {
    249              assert_param(IS_DMA_FIFO_THRESHOLD(hdma->Init.FIFOThreshold));
    250              assert_param(IS_DMA_MEMORY_BURST(hdma->Init.MemBurst));
    251              assert_param(IS_DMA_PERIPHERAL_BURST(hdma->Init.PeriphBurst));
    252            }
    253          
    254            /* Change DMA peripheral state */
    255            hdma->State = HAL_DMA_STATE_BUSY;
   \                     ??HAL_DMA_Init_0: (+1)
   \   00000006   0x2102             MOVS     R1,#+2
    256          
    257            /* Get the CR register value */
    258            tmp = hdma->Instance->CR;
    259          
    260            /* Clear CHSEL, MBURST, PBURST, PL, MSIZE, PSIZE, MINC, PINC, CIRC, DIR, CT and DBM bits */
    261            tmp &= ((uint32_t)~(DMA_SxCR_CHSEL | DMA_SxCR_MBURST | DMA_SxCR_PBURST | \
    262                                DMA_SxCR_PL    | DMA_SxCR_MSIZE  | DMA_SxCR_PSIZE  | \
    263                                DMA_SxCR_MINC  | DMA_SxCR_PINC   | DMA_SxCR_CIRC   | \
    264                                DMA_SxCR_DIR   | DMA_SxCR_CT     | DMA_SxCR_DBM));
    265          
    266            /* Prepare the DMA Stream configuration */
    267            tmp |=  hdma->Init.Channel             | hdma->Init.Direction        |
    268                    hdma->Init.PeriphInc           | hdma->Init.MemInc           |
    269                    hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
    270                    hdma->Init.Mode                | hdma->Init.Priority;
   \   00000008   0x.... 0x....      LDR.W    R3,??DataTable3  ;; 0xf010803f
   \   0000000C   0xF880 0x1035      STRB     R1,[R0, #+53]
   \   00000010   0x6801             LDR      R1,[R0, #+0]
   \   00000012   0x680A             LDR      R2,[R1, #+0]
   \   00000014   0x401A             ANDS     R2,R3,R2
   \   00000016   0x6843             LDR      R3,[R0, #+4]
   \   00000018   0x431A             ORRS     R2,R3,R2
   \   0000001A   0x6883             LDR      R3,[R0, #+8]
   \   0000001C   0x431A             ORRS     R2,R3,R2
   \   0000001E   0x68C3             LDR      R3,[R0, #+12]
   \   00000020   0x431A             ORRS     R2,R3,R2
   \   00000022   0x6903             LDR      R3,[R0, #+16]
   \   00000024   0x431A             ORRS     R2,R3,R2
   \   00000026   0x6943             LDR      R3,[R0, #+20]
   \   00000028   0x431A             ORRS     R2,R3,R2
   \   0000002A   0x6983             LDR      R3,[R0, #+24]
   \   0000002C   0x431A             ORRS     R2,R3,R2
   \   0000002E   0x69C3             LDR      R3,[R0, #+28]
   \   00000030   0x431A             ORRS     R2,R3,R2
   \   00000032   0x6A03             LDR      R3,[R0, #+32]
   \   00000034   0x431A             ORRS     R2,R3,R2
    271          
    272            /* the Memory burst and peripheral burst are not used when the FIFO is disabled */
    273            if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)
   \   00000036   0x6A43             LDR      R3,[R0, #+36]
   \   00000038   0x2B04             CMP      R3,#+4
   \   0000003A   0xD105             BNE.N    ??HAL_DMA_Init_1
    274            {
    275              /* Get memory burst and peripheral burst */
    276              tmp |=  hdma->Init.MemBurst | hdma->Init.PeriphBurst;
   \   0000003C   0x6AC3             LDR      R3,[R0, #+44]
   \   0000003E   0xF8D0 0xC030      LDR      R12,[R0, #+48]
   \   00000042   0xEA4C 0x0303      ORR      R3,R12,R3
   \   00000046   0x431A             ORRS     R2,R3,R2
    277            }
    278            
    279            /* Write to DMA Stream CR register */
    280            hdma->Instance->CR = tmp;  
   \                     ??HAL_DMA_Init_1: (+1)
   \   00000048   0x600A             STR      R2,[R1, #+0]
    281          
    282            /* Get the FCR register value */
    283            tmp = hdma->Instance->FCR;
   \   0000004A   0x6801             LDR      R1,[R0, #+0]
   \   0000004C   0x694A             LDR      R2,[R1, #+20]
    284          
    285            /* Clear Direct mode and FIFO threshold bits */
    286            tmp &= (uint32_t)~(DMA_SxFCR_DMDIS | DMA_SxFCR_FTH);
    287          
    288            /* Prepare the DMA Stream FIFO configuration */
    289            tmp |= hdma->Init.FIFOMode;
   \   0000004E   0x6A43             LDR      R3,[R0, #+36]
   \   00000050   0x08D2             LSRS     R2,R2,#+3
    290          
    291            /* the FIFO threshold is not used when the FIFO mode is disabled */
    292            if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)
   \   00000052   0x2B04             CMP      R3,#+4
   \   00000054   0xEA43 0x02C2      ORR      R2,R3,R2, LSL #+3
   \   00000058   0xBF04             ITT      EQ 
   \   0000005A   0x6A83             LDREQ    R3,[R0, #+40]
   \   0000005C   0x431A             ORREQ    R2,R3,R2
    293            {
    294              /* Get the FIFO threshold */
    295              tmp |= hdma->Init.FIFOThreshold;
    296            }
    297            
    298            /* Write to DMA Stream FCR */
    299            hdma->Instance->FCR = tmp;
   \   0000005E   0x614A             STR      R2,[R1, #+20]
    300          
    301            /* Initialize StreamBaseAddress and StreamIndex parameters to be used to calculate
    302               DMA steam Base Address needed by HAL_DMA_IRQHandler() and HAL_DMA_PollForTransfer() */
    303            DMA_CalcBaseAndBitshift(hdma);
   \   00000060   0x6801             LDR      R1,[R0, #+0]
   \   00000062   0x2318             MOVS     R3,#+24
   \   00000064   0xB2CA             UXTB     R2,R1
   \   00000066   0x3A10             SUBS     R2,R2,#+16
   \   00000068   0xFBB2 0xF2F3      UDIV     R2,R2,R3
   \   0000006C   0x.... 0x....      ADR.W    R3,??flagBitshiftOffset
   \   00000070   0x0A89             LSRS     R1,R1,#+10
   \   00000072   0x0289             LSLS     R1,R1,#+10
   \   00000074   0x2A04             CMP      R2,#+4
   \   00000076   0x5CD3             LDRB     R3,[R2, R3]
   \   00000078   0x6543             STR      R3,[R0, #+84]
   \   0000007A   0xBF28             IT       CS 
   \   0000007C   0x1D09             ADDCS    R1,R1,#+4
   \   0000007E   0x6501             STR      R1,[R0, #+80]
    304          	
    305            /* Initialize the error code */
    306            hdma->ErrorCode = HAL_DMA_ERROR_NONE;
   \   00000080   0x2100             MOVS     R1,#+0
   \   00000082   0x64C1             STR      R1,[R0, #+76]
    307          
    308            /* Initialize the DMA state */
    309            hdma->State = HAL_DMA_STATE_READY;
   \   00000084   0x2101             MOVS     R1,#+1
   \   00000086   0xF880 0x1035      STRB     R1,[R0, #+53]
    310          
    311            return HAL_OK;
   \   0000008A   0x2000             MOVS     R0,#+0
   \   0000008C   0x4770             BX       LR               ;; return
    312          }
    313          
    314          /**
    315            * @brief  DeInitializes the DMA peripheral 
    316            * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
    317            *               the configuration information for the specified DMA Stream.  
    318            * @retval HAL status
    319            */

   \                                 In section .text, align 2, keep-with-next
    320          HAL_StatusTypeDef HAL_DMA_DeInit(DMA_HandleTypeDef *hdma)
    321          {
    322          	DMA_Base_Registers *regs;
    323          	
    324            /* Check the DMA peripheral state */
    325            if(hdma == NULL)
   \                     HAL_DMA_DeInit: (+1)
   \   00000000   0x2800             CMP      R0,#+0
   \   00000002   0xBF1C             ITT      NE 
   \   00000004   0xF890 0x1035      LDRBNE   R1,[R0, #+53]
   \   00000008   0x2902             CMPNE    R1,#+2
    326            {
    327              return HAL_ERROR;
    328            }
    329            
    330            /* Check the DMA peripheral state */
    331            if(hdma->State == HAL_DMA_STATE_BUSY)
   \   0000000A   0xD101             BNE.N    ??HAL_DMA_DeInit_0
    332            {
    333               return HAL_ERROR;
   \   0000000C   0x2001             MOVS     R0,#+1
   \   0000000E   0x4770             BX       LR
    334            }
    335          
    336            /* Disable the selected DMA Streamx */
    337            __HAL_DMA_DISABLE(hdma);
   \                     ??HAL_DMA_DeInit_0: (+1)
   \   00000010   0x6801             LDR      R1,[R0, #+0]
    338          
    339            /* Reset DMA Streamx control register */
    340            hdma->Instance->CR   = 0;
    341          
    342            /* Reset DMA Streamx number of data to transfer register */
    343            hdma->Instance->NDTR = 0;
    344          
    345            /* Reset DMA Streamx peripheral address register */
    346            hdma->Instance->PAR  = 0;
    347          
    348            /* Reset DMA Streamx memory 0 address register */
    349            hdma->Instance->M0AR = 0;
    350          
    351            /* Reset DMA Streamx memory 1 address register */
    352            hdma->Instance->M1AR = 0;
    353          
    354            /* Reset DMA Streamx FIFO control register */
    355            hdma->Instance->FCR  = (uint32_t)0x00000021;
    356          
    357            /* Get DMA steam Base Address */  
    358            regs = (DMA_Base_Registers *)DMA_CalcBaseAndBitshift(hdma);
   \   00000012   0x2318             MOVS     R3,#+24
   \   00000014   0x680A             LDR      R2,[R1, #+0]
   \   00000016   0x0852             LSRS     R2,R2,#+1
   \   00000018   0x0052             LSLS     R2,R2,#+1
   \   0000001A   0x600A             STR      R2,[R1, #+0]
   \   0000001C   0x6802             LDR      R2,[R0, #+0]
   \   0000001E   0x2100             MOVS     R1,#+0
   \   00000020   0x6011             STR      R1,[R2, #+0]
   \   00000022   0x6802             LDR      R2,[R0, #+0]
   \   00000024   0x6051             STR      R1,[R2, #+4]
   \   00000026   0x6802             LDR      R2,[R0, #+0]
   \   00000028   0x6091             STR      R1,[R2, #+8]
   \   0000002A   0x6802             LDR      R2,[R0, #+0]
   \   0000002C   0x60D1             STR      R1,[R2, #+12]
   \   0000002E   0x6802             LDR      R2,[R0, #+0]
   \   00000030   0x6111             STR      R1,[R2, #+16]
   \   00000032   0x6802             LDR      R2,[R0, #+0]
   \   00000034   0x2121             MOVS     R1,#+33
   \   00000036   0x6151             STR      R1,[R2, #+20]
   \   00000038   0x6801             LDR      R1,[R0, #+0]
   \   0000003A   0xB2CA             UXTB     R2,R1
   \   0000003C   0x3A10             SUBS     R2,R2,#+16
   \   0000003E   0xFBB2 0xF2F3      UDIV     R2,R2,R3
   \   00000042   0x.... 0x....      ADR.W    R3,??flagBitshiftOffset
   \   00000046   0x0A89             LSRS     R1,R1,#+10
   \   00000048   0x0289             LSLS     R1,R1,#+10
   \   0000004A   0x2A04             CMP      R2,#+4
   \   0000004C   0x5CD3             LDRB     R3,[R2, R3]
   \   0000004E   0x6543             STR      R3,[R0, #+84]
   \   00000050   0xBF28             IT       CS 
   \   00000052   0x1D09             ADDCS    R1,R1,#+4
   \   00000054   0x6501             STR      R1,[R0, #+80]
    359            
    360            /* Clear all interrupt flags at correct offset within the register */
    361            regs->IFCR = 0x3F << hdma->StreamIndex;
   \   00000056   0x213F             MOVS     R1,#+63
   \   00000058   0x6D02             LDR      R2,[R0, #+80]
   \   0000005A   0x4099             LSLS     R1,R1,R3
   \   0000005C   0x6091             STR      R1,[R2, #+8]
    362          
    363            /* Initialize the error code */
    364            hdma->ErrorCode = HAL_DMA_ERROR_NONE;
   \   0000005E   0x2100             MOVS     R1,#+0
   \   00000060   0x64C1             STR      R1,[R0, #+76]
    365          
    366            /* Initialize the DMA state */
    367            hdma->State = HAL_DMA_STATE_RESET;
   \   00000062   0xF880 0x1035      STRB     R1,[R0, #+53]
    368          
    369            /* Release Lock */
    370            __HAL_UNLOCK(hdma);
   \   00000066   0xF880 0x1034      STRB     R1,[R0, #+52]
    371          
    372            return HAL_OK;
   \   0000006A   0x2000             MOVS     R0,#+0
   \   0000006C   0x4770             BX       LR               ;; return
    373          }
    374          
    375          /**
    376            * @}
    377            */
    378          
    379          /** @addtogroup DMA_Exported_Functions_Group2
    380            *
    381          @verbatim   
    382           ===============================================================================
    383                                #####  IO operation functions  #####
    384           ===============================================================================  
    385              [..]  This section provides functions allowing to:
    386                (+) Configure the source, destination address and data length and Start DMA transfer
    387                (+) Configure the source, destination address and data length and 
    388                    Start DMA transfer with interrupt
    389                (+) Abort DMA transfer
    390                (+) Poll for transfer complete
    391                (+) Handle DMA interrupt request  
    392          
    393          @endverbatim
    394            * @{
    395            */
    396          
    397          /**
    398            * @brief  Starts the DMA Transfer.
    399            * @param  hdma      : pointer to a DMA_HandleTypeDef structure that contains
    400            *                     the configuration information for the specified DMA Stream.  
    401            * @param  SrcAddress: The source memory Buffer address
    402            * @param  DstAddress: The destination memory Buffer address
    403            * @param  DataLength: The length of data to be transferred from source to destination
    404            * @retval HAL status
    405            */

   \                                 In section .text, align 2, keep-with-next
    406          HAL_StatusTypeDef HAL_DMA_Start(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
    407          {
   \                     HAL_DMA_Start: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
    408            /* Process locked */
    409            __HAL_LOCK(hdma);
   \   00000002   0xF890 0x4034      LDRB     R4,[R0, #+52]
   \   00000006   0x2C01             CMP      R4,#+1
   \   00000008   0xBF08             IT       EQ 
   \   0000000A   0x2002             MOVEQ    R0,#+2
   \   0000000C   0xD022             BEQ.N    ??HAL_DMA_Start_0
   \   0000000E   0x2401             MOVS     R4,#+1
   \   00000010   0xF880 0x4034      STRB     R4,[R0, #+52]
    410          
    411            /* Change DMA peripheral state */
    412            hdma->State = HAL_DMA_STATE_BUSY;
   \   00000014   0x2402             MOVS     R4,#+2
   \   00000016   0xF880 0x4035      STRB     R4,[R0, #+53]
    413          
    414             /* Check the parameters */
    415            assert_param(IS_DMA_BUFFER_SIZE(DataLength));
    416          
    417            /* Disable the peripheral */
    418            __HAL_DMA_DISABLE(hdma);
   \   0000001A   0x6804             LDR      R4,[R0, #+0]
   \   0000001C   0x6825             LDR      R5,[R4, #+0]
   \   0000001E   0x086D             LSRS     R5,R5,#+1
   \   00000020   0x006D             LSLS     R5,R5,#+1
   \   00000022   0x6025             STR      R5,[R4, #+0]
    419          
    420            /* Configure the source, destination address and the data length */
    421            DMA_SetConfig(hdma, SrcAddress, DstAddress, DataLength);
   \   00000024   0x6804             LDR      R4,[R0, #+0]
   \   00000026   0x6825             LDR      R5,[R4, #+0]
   \   00000028   0xF425 0x2580      BIC      R5,R5,#0x40000
   \   0000002C   0x6025             STR      R5,[R4, #+0]
   \   0000002E   0x6804             LDR      R4,[R0, #+0]
   \   00000030   0x6063             STR      R3,[R4, #+4]
   \   00000032   0x6883             LDR      R3,[R0, #+8]
   \   00000034   0x2B40             CMP      R3,#+64
   \   00000036   0x6803             LDR      R3,[R0, #+0]
   \   00000038   0xD103             BNE.N    ??HAL_DMA_Start_1
   \   0000003A   0x609A             STR      R2,[R3, #+8]
   \   0000003C   0x6802             LDR      R2,[R0, #+0]
   \   0000003E   0x60D1             STR      R1,[R2, #+12]
   \   00000040   0xE002             B.N      ??HAL_DMA_Start_2
   \                     ??HAL_DMA_Start_1: (+1)
   \   00000042   0x6099             STR      R1,[R3, #+8]
   \   00000044   0x6801             LDR      R1,[R0, #+0]
   \   00000046   0x60CA             STR      R2,[R1, #+12]
    422          
    423            /* Enable the Peripheral */
    424            __HAL_DMA_ENABLE(hdma);
   \                     ??HAL_DMA_Start_2: (+1)
   \   00000048   0x6800             LDR      R0,[R0, #+0]
   \   0000004A   0x6801             LDR      R1,[R0, #+0]
   \   0000004C   0xF041 0x0101      ORR      R1,R1,#0x1
   \   00000050   0x6001             STR      R1,[R0, #+0]
    425          
    426            return HAL_OK; 
   \   00000052   0x2000             MOVS     R0,#+0
   \                     ??HAL_DMA_Start_0: (+1)
   \   00000054   0xBC30             POP      {R4,R5}
   \   00000056   0x4770             BX       LR               ;; return
    427          }
    428          
    429          /**
    430            * @brief  Start the DMA Transfer with interrupt enabled.
    431            * @param  hdma:       pointer to a DMA_HandleTypeDef structure that contains
    432            *                     the configuration information for the specified DMA Stream.  
    433            * @param  SrcAddress: The source memory Buffer address
    434            * @param  DstAddress: The destination memory Buffer address
    435            * @param  DataLength: The length of data to be transferred from source to destination
    436            * @retval HAL status
    437            */

   \                                 In section .text, align 2, keep-with-next
    438          HAL_StatusTypeDef HAL_DMA_Start_IT(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
    439          {
   \                     HAL_DMA_Start_IT: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
    440            /* Process locked */
    441            __HAL_LOCK(hdma);
   \   00000002   0xF890 0x4034      LDRB     R4,[R0, #+52]
   \   00000006   0x2C01             CMP      R4,#+1
   \   00000008   0xBF08             IT       EQ 
   \   0000000A   0x2002             MOVEQ    R0,#+2
   \   0000000C   0xD02C             BEQ.N    ??HAL_DMA_Start_IT_0
   \   0000000E   0x2401             MOVS     R4,#+1
   \   00000010   0xF880 0x4034      STRB     R4,[R0, #+52]
    442          
    443            /* Change DMA peripheral state */
    444            hdma->State = HAL_DMA_STATE_BUSY;
   \   00000014   0x2402             MOVS     R4,#+2
   \   00000016   0xF880 0x4035      STRB     R4,[R0, #+53]
    445          
    446             /* Check the parameters */
    447            assert_param(IS_DMA_BUFFER_SIZE(DataLength));
    448          
    449            /* Disable the peripheral */
    450            __HAL_DMA_DISABLE(hdma);
   \   0000001A   0x6804             LDR      R4,[R0, #+0]
   \   0000001C   0x6825             LDR      R5,[R4, #+0]
   \   0000001E   0x086D             LSRS     R5,R5,#+1
   \   00000020   0x006D             LSLS     R5,R5,#+1
   \   00000022   0x6025             STR      R5,[R4, #+0]
    451          
    452            /* Configure the source, destination address and the data length */
    453            DMA_SetConfig(hdma, SrcAddress, DstAddress, DataLength);
   \   00000024   0x6804             LDR      R4,[R0, #+0]
   \   00000026   0x6825             LDR      R5,[R4, #+0]
   \   00000028   0xF425 0x2580      BIC      R5,R5,#0x40000
   \   0000002C   0x6025             STR      R5,[R4, #+0]
   \   0000002E   0x6804             LDR      R4,[R0, #+0]
   \   00000030   0x6063             STR      R3,[R4, #+4]
   \   00000032   0x6883             LDR      R3,[R0, #+8]
   \   00000034   0x2B40             CMP      R3,#+64
   \   00000036   0x6803             LDR      R3,[R0, #+0]
   \   00000038   0xD103             BNE.N    ??HAL_DMA_Start_IT_1
   \   0000003A   0x609A             STR      R2,[R3, #+8]
   \   0000003C   0x6802             LDR      R2,[R0, #+0]
   \   0000003E   0x60D1             STR      R1,[R2, #+12]
   \   00000040   0xE002             B.N      ??HAL_DMA_Start_IT_2
   \                     ??HAL_DMA_Start_IT_1: (+1)
   \   00000042   0x6099             STR      R1,[R3, #+8]
   \   00000044   0x6801             LDR      R1,[R0, #+0]
   \   00000046   0x60CA             STR      R2,[R1, #+12]
    454          
    455            /* Enable all interrupts */
    456            hdma->Instance->CR  |= DMA_IT_TC | DMA_IT_HT | DMA_IT_TE | DMA_IT_DME;
   \                     ??HAL_DMA_Start_IT_2: (+1)
   \   00000048   0x6801             LDR      R1,[R0, #+0]
   \   0000004A   0x680A             LDR      R2,[R1, #+0]
   \   0000004C   0xF042 0x021E      ORR      R2,R2,#0x1E
   \   00000050   0x600A             STR      R2,[R1, #+0]
    457            hdma->Instance->FCR |= DMA_IT_FE;
   \   00000052   0x6801             LDR      R1,[R0, #+0]
   \   00000054   0x694A             LDR      R2,[R1, #+20]
   \   00000056   0xF042 0x0280      ORR      R2,R2,#0x80
   \   0000005A   0x614A             STR      R2,[R1, #+20]
    458          
    459             /* Enable the Peripheral */
    460            __HAL_DMA_ENABLE(hdma);
   \   0000005C   0x6800             LDR      R0,[R0, #+0]
   \   0000005E   0x6801             LDR      R1,[R0, #+0]
   \   00000060   0xF041 0x0101      ORR      R1,R1,#0x1
   \   00000064   0x6001             STR      R1,[R0, #+0]
    461          
    462            return HAL_OK;
   \   00000066   0x2000             MOVS     R0,#+0
   \                     ??HAL_DMA_Start_IT_0: (+1)
   \   00000068   0xBC30             POP      {R4,R5}
   \   0000006A   0x4770             BX       LR               ;; return
    463          } 
    464          
    465          /**
    466            * @brief  Aborts the DMA Transfer.
    467            * @param  hdma  : pointer to a DMA_HandleTypeDef structure that contains
    468            *                 the configuration information for the specified DMA Stream.
    469            *                   
    470            * @note  After disabling a DMA Stream, a check for wait until the DMA Stream is 
    471            *        effectively disabled is added. If a Stream is disabled 
    472            *        while a data transfer is ongoing, the current data will be transferred
    473            *        and the Stream will be effectively disabled only after the transfer of
    474            *        this single data is finished.  
    475            * @retval HAL status
    476            */

   \                                 In section .text, align 2, keep-with-next
    477          HAL_StatusTypeDef HAL_DMA_Abort(DMA_HandleTypeDef *hdma)
    478          {
   \                     HAL_DMA_Abort: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
    479            uint32_t tickstart = 0;
    480          
    481            /* Disable the stream */
    482            __HAL_DMA_DISABLE(hdma);
   \   00000004   0xF240 0x36E9      MOVW     R6,#+1001
   \   00000008   0x6820             LDR      R0,[R4, #+0]
   \   0000000A   0x6801             LDR      R1,[R0, #+0]
   \   0000000C   0x0849             LSRS     R1,R1,#+1
   \   0000000E   0x0049             LSLS     R1,R1,#+1
   \   00000010   0x6001             STR      R1,[R0, #+0]
    483          
    484            /* Get tick */
    485            tickstart = HAL_GetTick();
   \   00000012   0x.... 0x....      BL       HAL_GetTick
   \   00000016   0x4605             MOV      R5,R0
    486          
    487            /* Check if the DMA Stream is effectively disabled */
    488            while((hdma->Instance->CR & DMA_SxCR_EN) != 0)
   \                     ??HAL_DMA_Abort_0: (+1)
   \   00000018   0x6820             LDR      R0,[R4, #+0]
   \   0000001A   0x6800             LDR      R0,[R0, #+0]
   \   0000001C   0x07C0             LSLS     R0,R0,#+31
   \   0000001E   0xD50F             BPL.N    ??HAL_DMA_Abort_1
    489            {
    490              /* Check for the Timeout */
    491              if((HAL_GetTick() - tickstart ) > HAL_TIMEOUT_DMA_ABORT)
   \   00000020   0x.... 0x....      BL       HAL_GetTick
   \   00000024   0x1B40             SUBS     R0,R0,R5
   \   00000026   0x42B0             CMP      R0,R6
   \   00000028   0xD3F6             BCC.N    ??HAL_DMA_Abort_0
    492              {
    493                /* Update error code */
    494                hdma->ErrorCode |= HAL_DMA_ERROR_TIMEOUT;
   \   0000002A   0x6CE0             LDR      R0,[R4, #+76]
   \   0000002C   0xF040 0x0020      ORR      R0,R0,#0x20
   \   00000030   0x64E0             STR      R0,[R4, #+76]
    495                
    496                /* Process Unlocked */
    497                __HAL_UNLOCK(hdma);
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0xF884 0x0034      STRB     R0,[R4, #+52]
    498                
    499                /* Change the DMA state */
    500                hdma->State = HAL_DMA_STATE_TIMEOUT;
   \   00000038   0x2003             MOVS     R0,#+3
   \   0000003A   0xF884 0x0035      STRB     R0,[R4, #+53]
    501                
    502                return HAL_TIMEOUT;
   \   0000003E   0xBD70             POP      {R4-R6,PC}
    503              }
    504            }
    505            /* Process Unlocked */
    506            __HAL_UNLOCK(hdma);
   \                     ??HAL_DMA_Abort_1: (+1)
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0xF884 0x0034      STRB     R0,[R4, #+52]
    507          
    508            /* Change the DMA state*/
    509            hdma->State = HAL_DMA_STATE_READY;
   \   00000046   0x2001             MOVS     R0,#+1
   \   00000048   0xF884 0x0035      STRB     R0,[R4, #+53]
    510          
    511            return HAL_OK;
   \   0000004C   0x2000             MOVS     R0,#+0
   \   0000004E   0xBD70             POP      {R4-R6,PC}       ;; return
    512          }
    513          
    514          /**
    515            * @brief  Polling for transfer complete.
    516            * @param  hdma:          pointer to a DMA_HandleTypeDef structure that contains
    517            *                        the configuration information for the specified DMA Stream.
    518            * @param  CompleteLevel: Specifies the DMA level complete.  
    519            * @param  Timeout:       Timeout duration.
    520            * @retval HAL status
    521            */

   \                                 In section .text, align 2, keep-with-next
    522          HAL_StatusTypeDef HAL_DMA_PollForTransfer(DMA_HandleTypeDef *hdma, uint32_t CompleteLevel, uint32_t Timeout)
    523          {
   \                     HAL_DMA_PollForTransfer: (+1)
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0xB081             SUB      SP,SP,#+4
   \   0000000A   0x4616             MOV      R6,R2
    524            uint32_t temp, tmp, tmp1, tmp2;
    525            uint32_t tickstart = 0; 
    526          
    527            /* calculate DMA base and stream number */
    528            DMA_Base_Registers *regs;
    529            
    530            regs = (DMA_Base_Registers *)hdma->StreamBaseAddress;
   \   0000000C   0x6D27             LDR      R7,[R4, #+80]
    531          	
    532            /* Get the level transfer complete flag */
    533            if(CompleteLevel == HAL_DMA_FULL_TRANSFER)
    534            {
    535              /* Transfer Complete flag */
    536          		temp = DMA_FLAG_TCIF0_4 << hdma->StreamIndex;
    537            }
    538            else
    539            {
    540              /* Half Transfer Complete flag */
    541          		temp = DMA_FLAG_HTIF0_4 << hdma->StreamIndex;
   \   0000000E   0x.... 0x....      LDR.W    R10,??DataTable3_1  ;; 0x800004
   \   00000012   0xBF0C             ITE      EQ 
   \   00000014   0x2020             MOVEQ    R0,#+32
   \   00000016   0x2010             MOVNE    R0,#+16
   \   00000018   0x6D61             LDR      R1,[R4, #+84]
   \   0000001A   0x.... 0x....      LDR.W    R11,??DataTable3_2  ;; 0x800001
   \   0000001E   0xFA00 0xF801      LSL      R8,R0,R1
    542            }
    543          
    544            /* Get tick */
    545            tickstart = HAL_GetTick();
   \   00000022   0x.... 0x....      BL       HAL_GetTick
   \   00000026   0x4681             MOV      R9,R0
    546          
    547            while((regs->ISR & temp) == RESET)
   \                     ??HAL_DMA_PollForTransfer_0: (+1)
   \   00000028   0x6D60             LDR      R0,[R4, #+84]
   \   0000002A   0x6839             LDR      R1,[R7, #+0]
   \   0000002C   0xEA11 0x0F08      TST      R1,R8
   \   00000030   0xD14D             BNE.N    ??HAL_DMA_PollForTransfer_1
    548            {
    549              tmp  = regs->ISR & (DMA_FLAG_TEIF0_4 << hdma->StreamIndex);
    550              tmp1 = regs->ISR & (DMA_FLAG_FEIF0_4 << hdma->StreamIndex);
   \   00000032   0xFA0B 0xFC00      LSL      R12,R11,R0
   \   00000036   0x2108             MOVS     R1,#+8
   \   00000038   0x683A             LDR      R2,[R7, #+0]
   \   0000003A   0x4081             LSLS     R1,R1,R0
   \   0000003C   0x683B             LDR      R3,[R7, #+0]
    551              tmp2 = regs->ISR & (DMA_FLAG_DMEIF0_4 << hdma->StreamIndex);
   \   0000003E   0xFA0A 0xF000      LSL      R0,R10,R0
   \   00000042   0x400A             ANDS     R2,R1,R2
   \   00000044   0xEA0C 0x0303      AND      R3,R12,R3
   \   00000048   0xF8D7 0xC000      LDR      R12,[R7, #+0]
   \   0000004C   0xEA00 0x000C      AND      R0,R0,R12
    552              if((tmp != RESET) || (tmp1 != RESET) || (tmp2 != RESET))
   \   00000050   0xEA43 0x0C02      ORR      R12,R3,R2
   \   00000054   0xEA50 0x0C0C      ORRS     R12,R0,R12
   \   00000058   0xD021             BEQ.N    ??HAL_DMA_PollForTransfer_2
    553              {
    554                if(tmp != RESET)
   \   0000005A   0xB122             CBZ.N    R2,??HAL_DMA_PollForTransfer_3
    555                {
    556                  /* Update error code */
    557                  hdma->ErrorCode |= HAL_DMA_ERROR_TE;
   \   0000005C   0x6CE2             LDR      R2,[R4, #+76]
   \   0000005E   0xF042 0x0201      ORR      R2,R2,#0x1
   \   00000062   0x64E2             STR      R2,[R4, #+76]
    558          
    559                  /* Clear the transfer error flag */
    560                  regs->IFCR = DMA_FLAG_TEIF0_4 << hdma->StreamIndex;
   \   00000064   0x60B9             STR      R1,[R7, #+8]
    561                }
    562                if(tmp1 != RESET)
   \                     ??HAL_DMA_PollForTransfer_3: (+1)
   \   00000066   0xB13B             CBZ.N    R3,??HAL_DMA_PollForTransfer_4
    563                {
    564                  /* Update error code */
    565                  hdma->ErrorCode |= HAL_DMA_ERROR_FE;
   \   00000068   0x6CE1             LDR      R1,[R4, #+76]
   \   0000006A   0xF041 0x0102      ORR      R1,R1,#0x2
   \   0000006E   0x64E1             STR      R1,[R4, #+76]
    566           
    567                  /* Clear the FIFO error flag */
    568                  regs->IFCR = DMA_FLAG_FEIF0_4 << hdma->StreamIndex;
   \   00000070   0x6D61             LDR      R1,[R4, #+84]
   \   00000072   0xFA0B 0xF101      LSL      R1,R11,R1
   \   00000076   0x60B9             STR      R1,[R7, #+8]
    569                }
    570                if(tmp2 != RESET)
   \                     ??HAL_DMA_PollForTransfer_4: (+1)
   \   00000078   0xB138             CBZ.N    R0,??HAL_DMA_PollForTransfer_5
    571                {
    572                  /* Update error code */
    573                  hdma->ErrorCode |= HAL_DMA_ERROR_DME;
   \   0000007A   0x6CE0             LDR      R0,[R4, #+76]
   \   0000007C   0xF040 0x0004      ORR      R0,R0,#0x4
   \   00000080   0x64E0             STR      R0,[R4, #+76]
    574          
    575                  /* Clear the Direct Mode error flag */
    576                  regs->IFCR = DMA_FLAG_DMEIF0_4 << hdma->StreamIndex;
   \   00000082   0x6D60             LDR      R0,[R4, #+84]
   \   00000084   0xFA0A 0xF000      LSL      R0,R10,R0
   \   00000088   0x60B8             STR      R0,[R7, #+8]
    577                }
    578                /* Change the DMA state */
    579                hdma->State= HAL_DMA_STATE_ERROR;
   \                     ??HAL_DMA_PollForTransfer_5: (+1)
   \   0000008A   0x2004             MOVS     R0,#+4
   \   0000008C   0xF884 0x0035      STRB     R0,[R4, #+53]
    580                
    581                /* Process Unlocked */
    582                __HAL_UNLOCK(hdma);
   \   00000090   0x2000             MOVS     R0,#+0
   \   00000092   0xF884 0x0034      STRB     R0,[R4, #+52]
    583          
    584                return HAL_ERROR;
   \   00000096   0x2001             MOVS     R0,#+1
   \   00000098   0xB001             ADD      SP,SP,#+4
   \   0000009A   0xE8BD 0x8FF0      POP      {R4-R11,PC}
    585              }  
    586              /* Check for the Timeout */
    587              if(Timeout != HAL_MAX_DELAY)
   \                     ??HAL_DMA_PollForTransfer_2: (+1)
   \   0000009E   0xF116 0x0F01      CMN      R6,#+1
   \   000000A2   0xD0C1             BEQ.N    ??HAL_DMA_PollForTransfer_0
    588              {
    589                if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
   \   000000A4   0xB12E             CBZ.N    R6,??HAL_DMA_PollForTransfer_6
   \   000000A6   0x.... 0x....      BL       HAL_GetTick
   \   000000AA   0xEBA0 0x0009      SUB      R0,R0,R9
   \   000000AE   0x4286             CMP      R6,R0
   \   000000B0   0xD2BA             BCS.N    ??HAL_DMA_PollForTransfer_0
    590                {
    591                  /* Update error code */
    592                  hdma->ErrorCode |= HAL_DMA_ERROR_TIMEOUT;
   \                     ??HAL_DMA_PollForTransfer_6: (+1)
   \   000000B2   0x6CE0             LDR      R0,[R4, #+76]
   \   000000B4   0xF040 0x0020      ORR      R0,R0,#0x20
   \   000000B8   0x64E0             STR      R0,[R4, #+76]
    593          
    594                  /* Change the DMA state */
    595                  hdma->State = HAL_DMA_STATE_TIMEOUT;
   \   000000BA   0x2003             MOVS     R0,#+3
   \   000000BC   0xF884 0x0035      STRB     R0,[R4, #+53]
    596          
    597                  /* Process Unlocked */
    598                  __HAL_UNLOCK(hdma);
   \   000000C0   0x2000             MOVS     R0,#+0
   \   000000C2   0xF884 0x0034      STRB     R0,[R4, #+52]
    599                  
    600                  return HAL_TIMEOUT;
   \   000000C6   0x2003             MOVS     R0,#+3
   \   000000C8   0xB001             ADD      SP,SP,#+4
   \   000000CA   0xE8BD 0x8FF0      POP      {R4-R11,PC}
    601                }
    602              }
    603            }
    604          
    605            if(CompleteLevel == HAL_DMA_FULL_TRANSFER)
   \                     ??HAL_DMA_PollForTransfer_1: (+1)
   \   000000CE   0xB9B5             CBNZ.N   R5,??HAL_DMA_PollForTransfer_7
    606            {
    607              /* Clear the half transfer and transfer complete flags */
    608              regs->IFCR = (DMA_FLAG_HTIF0_4 | DMA_FLAG_TCIF0_4) << hdma->StreamIndex;
   \   000000D0   0x2130             MOVS     R1,#+48
   \   000000D2   0xFA01 0xF000      LSL      R0,R1,R0
   \   000000D6   0x60B8             STR      R0,[R7, #+8]
    609          		
    610              /* Multi_Buffering mode enabled */
    611              if(((hdma->Instance->CR) & (uint32_t)(DMA_SxCR_DBM)) != 0)
   \   000000D8   0x6820             LDR      R0,[R4, #+0]
   \   000000DA   0x6801             LDR      R1,[R0, #+0]
   \   000000DC   0x0349             LSLS     R1,R1,#+13
   \   000000DE   0xD507             BPL.N    ??HAL_DMA_PollForTransfer_8
    612              {
    613                /* Current memory buffer used is Memory 0 */
    614                if((hdma->Instance->CR & DMA_SxCR_CT) == 0)
   \   000000E0   0x6801             LDR      R1,[R0, #+0]
   \   000000E2   0x0309             LSLS     R1,R1,#+12
   \   000000E4   0xD504             BPL.N    ??HAL_DMA_PollForTransfer_8
    615                {
    616                  /* Change DMA peripheral state */
    617                  hdma->State = HAL_DMA_STATE_READY_MEM0;
    618                }
    619                /* Current memory buffer used is Memory 1 */
    620                else if((hdma->Instance->CR & DMA_SxCR_CT) != 0)
   \   000000E6   0x6800             LDR      R0,[R0, #+0]
   \   000000E8   0x0300             LSLS     R0,R0,#+12
   \   000000EA   0xD504             BPL.N    ??HAL_DMA_PollForTransfer_9
    621                {
    622                  /* Change DMA peripheral state */
    623                  hdma->State = HAL_DMA_STATE_READY_MEM1;
   \   000000EC   0x2021             MOVS     R0,#+33
   \   000000EE   0xE000             B.N      ??HAL_DMA_PollForTransfer_10
    624                }
    625              }
    626              else
    627              {
    628                /* The selected Streamx EN bit is cleared (DMA is disabled and all transfers
    629                   are complete) */
    630                hdma->State = HAL_DMA_STATE_READY_MEM0;
   \                     ??HAL_DMA_PollForTransfer_8: (+1)
   \   000000F0   0x2011             MOVS     R0,#+17
   \                     ??HAL_DMA_PollForTransfer_10: (+1)
   \   000000F2   0xF884 0x0035      STRB     R0,[R4, #+53]
    631              }
    632              /* Process Unlocked */
    633              __HAL_UNLOCK(hdma);
   \                     ??HAL_DMA_PollForTransfer_9: (+1)
   \   000000F6   0x2000             MOVS     R0,#+0
   \   000000F8   0xF884 0x0034      STRB     R0,[R4, #+52]
   \   000000FC   0xE012             B.N      ??HAL_DMA_PollForTransfer_11
    634            }
    635            else
    636            {
    637              /* Clear the half transfer complete flag */
    638              regs->IFCR = DMA_FLAG_HTIF0_4 << hdma->StreamIndex;
   \                     ??HAL_DMA_PollForTransfer_7: (+1)
   \   000000FE   0x2110             MOVS     R1,#+16
   \   00000100   0xFA01 0xF000      LSL      R0,R1,R0
   \   00000104   0x60B8             STR      R0,[R7, #+8]
    639          		
    640              /* Multi_Buffering mode enabled */
    641              if(((hdma->Instance->CR) & (uint32_t)(DMA_SxCR_DBM)) != 0)
   \   00000106   0x6820             LDR      R0,[R4, #+0]
   \   00000108   0x6801             LDR      R1,[R0, #+0]
   \   0000010A   0x0349             LSLS     R1,R1,#+13
   \   0000010C   0xD507             BPL.N    ??HAL_DMA_PollForTransfer_12
    642              {
    643                /* Current memory buffer used is Memory 0 */
    644                if((hdma->Instance->CR & DMA_SxCR_CT) == 0)
   \   0000010E   0x6801             LDR      R1,[R0, #+0]
   \   00000110   0x0309             LSLS     R1,R1,#+12
   \   00000112   0xD504             BPL.N    ??HAL_DMA_PollForTransfer_12
    645                {
    646                  /* Change DMA peripheral state */
    647                  hdma->State = HAL_DMA_STATE_READY_HALF_MEM0;
    648                }
    649                /* Current memory buffer used is Memory 1 */
    650                else if((hdma->Instance->CR & DMA_SxCR_CT) != 0)
   \   00000114   0x6800             LDR      R0,[R0, #+0]
   \   00000116   0x0300             LSLS     R0,R0,#+12
   \   00000118   0xD504             BPL.N    ??HAL_DMA_PollForTransfer_11
    651                {
    652                  /* Change DMA peripheral state */
    653                  hdma->State = HAL_DMA_STATE_READY_HALF_MEM1;
   \   0000011A   0x2041             MOVS     R0,#+65
   \   0000011C   0xE000             B.N      ??HAL_DMA_PollForTransfer_13
    654                }
    655              }
    656              else
    657              {
    658                /* Change DMA peripheral state */
    659                hdma->State = HAL_DMA_STATE_READY_HALF_MEM0;
   \                     ??HAL_DMA_PollForTransfer_12: (+1)
   \   0000011E   0x2031             MOVS     R0,#+49
   \                     ??HAL_DMA_PollForTransfer_13: (+1)
   \   00000120   0xF884 0x0035      STRB     R0,[R4, #+53]
    660              }
    661            }
    662            return HAL_OK;
   \                     ??HAL_DMA_PollForTransfer_11: (+1)
   \   00000124   0x2000             MOVS     R0,#+0
   \   00000126   0xB001             ADD      SP,SP,#+4
   \   00000128   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    663          }
    664          
    665          /**
    666            * @brief  Handles DMA interrupt request.
    667            * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
    668            *               the configuration information for the specified DMA Stream.  
    669            * @retval None
    670            */

   \                                 In section .text, align 2, keep-with-next
    671          void HAL_DMA_IRQHandler(DMA_HandleTypeDef *hdma)
    672          {
   \                     HAL_DMA_IRQHandler: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0xB081             SUB      SP,SP,#+4
    673            /* calculate DMA base and stream number */
    674            DMA_Base_Registers *regs;
    675          
    676            regs = (DMA_Base_Registers *)hdma->StreamBaseAddress;
    677          	
    678            /* Transfer Error Interrupt management ***************************************/
    679            if ((regs->ISR & (DMA_FLAG_TEIF0_4 << hdma->StreamIndex)) != RESET)
   \   00000006   0x2008             MOVS     R0,#+8
   \   00000008   0x6D25             LDR      R5,[R4, #+80]
   \   0000000A   0x6829             LDR      R1,[R5, #+0]
   \   0000000C   0x6D62             LDR      R2,[R4, #+84]
   \   0000000E   0xFA00 0xF202      LSL      R2,R0,R2
   \   00000012   0x4211             TST      R1,R2
   \   00000014   0xD019             BEQ.N    ??HAL_DMA_IRQHandler_0
    680            {
    681              if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_TE) != RESET)
   \   00000016   0x6821             LDR      R1,[R4, #+0]
   \   00000018   0x680A             LDR      R2,[R1, #+0]
   \   0000001A   0x0752             LSLS     R2,R2,#+29
   \   0000001C   0xD515             BPL.N    ??HAL_DMA_IRQHandler_0
    682              {
    683                /* Disable the transfer error interrupt */
    684                __HAL_DMA_DISABLE_IT(hdma, DMA_IT_TE);
   \   0000001E   0x680A             LDR      R2,[R1, #+0]
   \   00000020   0xF022 0x0204      BIC      R2,R2,#0x4
   \   00000024   0x600A             STR      R2,[R1, #+0]
    685          
    686                /* Clear the transfer error flag */
    687                regs->IFCR = DMA_FLAG_TEIF0_4 << hdma->StreamIndex;
   \   00000026   0x6D61             LDR      R1,[R4, #+84]
   \   00000028   0x4088             LSLS     R0,R0,R1
   \   0000002A   0x60A8             STR      R0,[R5, #+8]
    688          
    689                /* Update error code */
    690                hdma->ErrorCode |= HAL_DMA_ERROR_TE;
   \   0000002C   0x6CE0             LDR      R0,[R4, #+76]
   \   0000002E   0xF040 0x0001      ORR      R0,R0,#0x1
   \   00000032   0x64E0             STR      R0,[R4, #+76]
    691          
    692                /* Change the DMA state */
    693                hdma->State = HAL_DMA_STATE_ERROR;
   \   00000034   0x2004             MOVS     R0,#+4
   \   00000036   0xF884 0x0035      STRB     R0,[R4, #+53]
    694          
    695                /* Process Unlocked */
    696                __HAL_UNLOCK(hdma); 
   \   0000003A   0x2000             MOVS     R0,#+0
    697          
    698                if(hdma->XferErrorCallback != NULL)
   \   0000003C   0x6CA1             LDR      R1,[R4, #+72]
   \   0000003E   0xF884 0x0034      STRB     R0,[R4, #+52]
   \   00000042   0x0008             MOVS     R0,R1
   \   00000044   0xBF1C             ITT      NE 
    699                {
    700                  /* Transfer error callback */
    701                  hdma->XferErrorCallback(hdma);
   \   00000046   0x4620             MOVNE    R0,R4
   \   00000048   0x4788             BLXNE    R1
    702                }
    703              }
    704            }
    705            /* FIFO Error Interrupt management ******************************************/
    706            if ((regs->ISR & (DMA_FLAG_FEIF0_4 << hdma->StreamIndex)) != RESET)
   \                     ??HAL_DMA_IRQHandler_0: (+1)
   \   0000004A   0x6829             LDR      R1,[R5, #+0]
   \   0000004C   0x6D62             LDR      R2,[R4, #+84]
   \   0000004E   0x....             LDR.N    R0,??DataTable3_2  ;; 0x800001
   \   00000050   0xFA00 0xF202      LSL      R2,R0,R2
   \   00000054   0x4211             TST      R1,R2
   \   00000056   0xD019             BEQ.N    ??HAL_DMA_IRQHandler_1
    707            {
    708              if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_FE) != RESET)
   \   00000058   0x6821             LDR      R1,[R4, #+0]
   \   0000005A   0x694A             LDR      R2,[R1, #+20]
   \   0000005C   0x0612             LSLS     R2,R2,#+24
   \   0000005E   0xD515             BPL.N    ??HAL_DMA_IRQHandler_1
    709              {
    710                /* Disable the FIFO Error interrupt */
    711                __HAL_DMA_DISABLE_IT(hdma, DMA_IT_FE);
   \   00000060   0x694A             LDR      R2,[R1, #+20]
   \   00000062   0xF022 0x0280      BIC      R2,R2,#0x80
   \   00000066   0x614A             STR      R2,[R1, #+20]
    712          
    713                /* Clear the FIFO error flag */
    714                regs->IFCR = DMA_FLAG_FEIF0_4 << hdma->StreamIndex;
   \   00000068   0x6D61             LDR      R1,[R4, #+84]
   \   0000006A   0x4088             LSLS     R0,R0,R1
   \   0000006C   0x60A8             STR      R0,[R5, #+8]
    715          
    716                /* Update error code */
    717                hdma->ErrorCode |= HAL_DMA_ERROR_FE;
   \   0000006E   0x6CE0             LDR      R0,[R4, #+76]
   \   00000070   0xF040 0x0002      ORR      R0,R0,#0x2
   \   00000074   0x64E0             STR      R0,[R4, #+76]
    718          
    719                /* Change the DMA state */
    720                hdma->State = HAL_DMA_STATE_ERROR;
   \   00000076   0x2004             MOVS     R0,#+4
   \   00000078   0xF884 0x0035      STRB     R0,[R4, #+53]
    721          
    722                /* Process Unlocked */
    723                __HAL_UNLOCK(hdma);
   \   0000007C   0x2000             MOVS     R0,#+0
    724          
    725                if(hdma->XferErrorCallback != NULL)
   \   0000007E   0x6CA1             LDR      R1,[R4, #+72]
   \   00000080   0xF884 0x0034      STRB     R0,[R4, #+52]
   \   00000084   0x0008             MOVS     R0,R1
   \   00000086   0xBF1C             ITT      NE 
    726                {
    727                  /* Transfer error callback */
    728                  hdma->XferErrorCallback(hdma);
   \   00000088   0x4620             MOVNE    R0,R4
   \   0000008A   0x4788             BLXNE    R1
    729                }
    730              }
    731            }
    732            /* Direct Mode Error Interrupt management ***********************************/
    733            if ((regs->ISR & (DMA_FLAG_DMEIF0_4 << hdma->StreamIndex)) != RESET)
   \                     ??HAL_DMA_IRQHandler_1: (+1)
   \   0000008C   0x6829             LDR      R1,[R5, #+0]
   \   0000008E   0x6D62             LDR      R2,[R4, #+84]
   \   00000090   0x....             LDR.N    R0,??DataTable3_1  ;; 0x800004
   \   00000092   0xFA00 0xF202      LSL      R2,R0,R2
   \   00000096   0x4211             TST      R1,R2
   \   00000098   0xD019             BEQ.N    ??HAL_DMA_IRQHandler_2
    734            {
    735              if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_DME) != RESET)
   \   0000009A   0x6821             LDR      R1,[R4, #+0]
   \   0000009C   0x680A             LDR      R2,[R1, #+0]
   \   0000009E   0x0792             LSLS     R2,R2,#+30
   \   000000A0   0xD515             BPL.N    ??HAL_DMA_IRQHandler_2
    736              {
    737                /* Disable the direct mode Error interrupt */
    738                __HAL_DMA_DISABLE_IT(hdma, DMA_IT_DME);
   \   000000A2   0x680A             LDR      R2,[R1, #+0]
   \   000000A4   0xF022 0x0202      BIC      R2,R2,#0x2
   \   000000A8   0x600A             STR      R2,[R1, #+0]
    739          
    740                /* Clear the direct mode error flag */
    741                regs->IFCR = DMA_FLAG_DMEIF0_4 << hdma->StreamIndex;
   \   000000AA   0x6D61             LDR      R1,[R4, #+84]
   \   000000AC   0x4088             LSLS     R0,R0,R1
   \   000000AE   0x60A8             STR      R0,[R5, #+8]
    742          
    743                /* Update error code */
    744                hdma->ErrorCode |= HAL_DMA_ERROR_DME;
   \   000000B0   0x6CE0             LDR      R0,[R4, #+76]
   \   000000B2   0xF040 0x0004      ORR      R0,R0,#0x4
   \   000000B6   0x64E0             STR      R0,[R4, #+76]
    745          
    746                /* Change the DMA state */
    747                hdma->State = HAL_DMA_STATE_ERROR;
   \   000000B8   0x2004             MOVS     R0,#+4
   \   000000BA   0xF884 0x0035      STRB     R0,[R4, #+53]
    748          
    749                /* Process Unlocked */
    750                __HAL_UNLOCK(hdma);
   \   000000BE   0x2000             MOVS     R0,#+0
    751          
    752                if(hdma->XferErrorCallback != NULL)
   \   000000C0   0x6CA1             LDR      R1,[R4, #+72]
   \   000000C2   0xF884 0x0034      STRB     R0,[R4, #+52]
   \   000000C6   0x0008             MOVS     R0,R1
   \   000000C8   0xBF1C             ITT      NE 
    753                {
    754                  /* Transfer error callback */
    755                  hdma->XferErrorCallback(hdma);
   \   000000CA   0x4620             MOVNE    R0,R4
   \   000000CC   0x4788             BLXNE    R1
   \                     ??HAL_DMA_IRQHandler_2: (+1)
   \   000000CE   0x6D61             LDR      R1,[R4, #+84]
   \   000000D0   0x2010             MOVS     R0,#+16
   \   000000D2   0x682A             LDR      R2,[R5, #+0]
   \   000000D4   0xFA00 0xF101      LSL      R1,R0,R1
   \   000000D8   0x420A             TST      R2,R1
   \   000000DA   0xD022             BEQ.N    ??HAL_DMA_IRQHandler_3
    756                }
    757              }
    758            }
    759            /* Half Transfer Complete Interrupt management ******************************/
    760            if ((regs->ISR & (DMA_FLAG_HTIF0_4 << hdma->StreamIndex)) != RESET)
    761            {
    762              if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_HT) != RESET)
   \   000000DC   0x6822             LDR      R2,[R4, #+0]
   \   000000DE   0x6813             LDR      R3,[R2, #+0]
   \   000000E0   0x071B             LSLS     R3,R3,#+28
   \   000000E2   0xD51E             BPL.N    ??HAL_DMA_IRQHandler_3
    763              { 
    764                /* Multi_Buffering mode enabled */
    765                if(((hdma->Instance->CR) & (uint32_t)(DMA_SxCR_DBM)) != 0)
   \   000000E4   0x6813             LDR      R3,[R2, #+0]
   \   000000E6   0x035B             LSLS     R3,R3,#+13
   \   000000E8   0xD509             BPL.N    ??HAL_DMA_IRQHandler_4
    766                {
    767                  /* Clear the half transfer complete flag */
    768                  regs->IFCR = DMA_FLAG_HTIF0_4 << hdma->StreamIndex;
   \   000000EA   0x60A9             STR      R1,[R5, #+8]
    769          
    770                  /* Current memory buffer used is Memory 0 */
    771                  if((hdma->Instance->CR & DMA_SxCR_CT) == 0)
   \   000000EC   0x6820             LDR      R0,[R4, #+0]
   \   000000EE   0x6801             LDR      R1,[R0, #+0]
   \   000000F0   0x0309             LSLS     R1,R1,#+12
   \   000000F2   0xD50E             BPL.N    ??HAL_DMA_IRQHandler_5
    772                  {
    773                    /* Change DMA peripheral state */
    774                    hdma->State = HAL_DMA_STATE_READY_HALF_MEM0;
    775                  }
    776                  /* Current memory buffer used is Memory 1 */
    777                  else if((hdma->Instance->CR & DMA_SxCR_CT) != 0)
   \   000000F4   0x6800             LDR      R0,[R0, #+0]
   \   000000F6   0x0300             LSLS     R0,R0,#+12
   \   000000F8   0xD50E             BPL.N    ??HAL_DMA_IRQHandler_6
    778                  {
    779                    /* Change DMA peripheral state */
    780                    hdma->State = HAL_DMA_STATE_READY_HALF_MEM1;
   \   000000FA   0x2041             MOVS     R0,#+65
   \   000000FC   0xE00A             B.N      ??HAL_DMA_IRQHandler_7
    781                  }
    782                }
    783                else
    784                {
    785                  /* Disable the half transfer interrupt if the DMA mode is not CIRCULAR */
    786                  if((hdma->Instance->CR & DMA_SxCR_CIRC) == 0)
   \                     ??HAL_DMA_IRQHandler_4: (+1)
   \   000000FE   0x6811             LDR      R1,[R2, #+0]
   \   00000100   0x05C9             LSLS     R1,R1,#+23
   \   00000102   0xD403             BMI.N    ??HAL_DMA_IRQHandler_8
    787                  {
    788                    /* Disable the half transfer interrupt */
    789                    __HAL_DMA_DISABLE_IT(hdma, DMA_IT_HT);
   \   00000104   0x6811             LDR      R1,[R2, #+0]
   \   00000106   0xF021 0x0108      BIC      R1,R1,#0x8
   \   0000010A   0x6011             STR      R1,[R2, #+0]
    790                  }
    791                  /* Clear the half transfer complete flag */
    792                  regs->IFCR = DMA_FLAG_HTIF0_4 << hdma->StreamIndex;
   \                     ??HAL_DMA_IRQHandler_8: (+1)
   \   0000010C   0x6D61             LDR      R1,[R4, #+84]
   \   0000010E   0x4088             LSLS     R0,R0,R1
   \   00000110   0x60A8             STR      R0,[R5, #+8]
    793          
    794                  /* Change DMA peripheral state */
    795                  hdma->State = HAL_DMA_STATE_READY_HALF_MEM0;
   \                     ??HAL_DMA_IRQHandler_5: (+1)
   \   00000112   0x2031             MOVS     R0,#+49
   \                     ??HAL_DMA_IRQHandler_7: (+1)
   \   00000114   0xF884 0x0035      STRB     R0,[R4, #+53]
    796                }
    797          
    798                if(hdma->XferHalfCpltCallback != NULL)
   \                     ??HAL_DMA_IRQHandler_6: (+1)
   \   00000118   0x6C21             LDR      R1,[R4, #+64]
   \   0000011A   0x0008             MOVS     R0,R1
   \   0000011C   0xBF1C             ITT      NE 
    799                {
    800                  /* Half transfer callback */
    801                  hdma->XferHalfCpltCallback(hdma);
   \   0000011E   0x4620             MOVNE    R0,R4
   \   00000120   0x4788             BLXNE    R1
   \                     ??HAL_DMA_IRQHandler_3: (+1)
   \   00000122   0x6D61             LDR      R1,[R4, #+84]
   \   00000124   0x2020             MOVS     R0,#+32
   \   00000126   0x682A             LDR      R2,[R5, #+0]
   \   00000128   0xFA00 0xF101      LSL      R1,R0,R1
   \   0000012C   0x420A             TST      R2,R1
   \   0000012E   0xD031             BEQ.N    ??HAL_DMA_IRQHandler_9
    802                }
    803              }
    804            }
    805            /* Transfer Complete Interrupt management ***********************************/
    806            if ((regs->ISR & (DMA_FLAG_TCIF0_4 << hdma->StreamIndex)) != RESET)
    807            {
    808              if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_TC) != RESET)
   \   00000130   0x6822             LDR      R2,[R4, #+0]
   \   00000132   0x6813             LDR      R3,[R2, #+0]
   \   00000134   0x06DB             LSLS     R3,R3,#+27
   \   00000136   0xD52D             BPL.N    ??HAL_DMA_IRQHandler_9
    809              {
    810                if(((hdma->Instance->CR) & (uint32_t)(DMA_SxCR_DBM)) != 0)
   \   00000138   0x6813             LDR      R3,[R2, #+0]
   \   0000013A   0x035B             LSLS     R3,R3,#+13
   \   0000013C   0xD510             BPL.N    ??HAL_DMA_IRQHandler_10
    811                {
    812                  /* Clear the transfer complete flag */
    813                  regs->IFCR = DMA_FLAG_TCIF0_4 << hdma->StreamIndex;
   \   0000013E   0x60A9             STR      R1,[R5, #+8]
    814          
    815                  /* Current memory buffer used is Memory 1 */
    816                  if((hdma->Instance->CR & DMA_SxCR_CT) == 0)
   \   00000140   0x6820             LDR      R0,[R4, #+0]
   \   00000142   0x6801             LDR      R1,[R0, #+0]
   \   00000144   0x0309             LSLS     R1,R1,#+12
   \   00000146   0xD407             BMI.N    ??HAL_DMA_IRQHandler_11
    817                  {
    818                    if(hdma->XferM1CpltCallback != NULL)
   \   00000148   0x6C61             LDR      R1,[R4, #+68]
   \   0000014A   0x0008             MOVS     R0,R1
   \   0000014C   0xD022             BEQ.N    ??HAL_DMA_IRQHandler_9
    819                    {
    820                      /* Transfer complete Callback for memory1 */
    821                      hdma->XferM1CpltCallback(hdma);
   \   0000014E   0x4620             MOV      R0,R4
   \   00000150   0xB001             ADD      SP,SP,#+4
   \   00000152   0xE8BD 0x4030      POP      {R4,R5,LR}
   \   00000156   0x4708             BX       R1
    822                    }
    823                  }
    824                  /* Current memory buffer used is Memory 0 */
    825                  else if((hdma->Instance->CR & DMA_SxCR_CT) != 0) 
   \                     ??HAL_DMA_IRQHandler_11: (+1)
   \   00000158   0x6800             LDR      R0,[R0, #+0]
   \   0000015A   0x0300             LSLS     R0,R0,#+12
   \   0000015C   0xD51A             BPL.N    ??HAL_DMA_IRQHandler_9
    826                  {
    827                    if(hdma->XferCpltCallback != NULL)
   \   0000015E   0xE011             B.N      ??HAL_DMA_IRQHandler_12
    828                    {
    829                      /* Transfer complete Callback for memory0 */
    830                      hdma->XferCpltCallback(hdma);
    831                    }
    832                  }
    833                }
    834                /* Disable the transfer complete interrupt if the DMA mode is not CIRCULAR */
    835                else
    836                {
    837                  if((hdma->Instance->CR & DMA_SxCR_CIRC) == 0)
   \                     ??HAL_DMA_IRQHandler_10: (+1)
   \   00000160   0x6811             LDR      R1,[R2, #+0]
   \   00000162   0x05C9             LSLS     R1,R1,#+23
   \   00000164   0xD403             BMI.N    ??HAL_DMA_IRQHandler_13
    838                  {
    839                    /* Disable the transfer complete interrupt */
    840                    __HAL_DMA_DISABLE_IT(hdma, DMA_IT_TC);
   \   00000166   0x6811             LDR      R1,[R2, #+0]
   \   00000168   0xF021 0x0110      BIC      R1,R1,#0x10
   \   0000016C   0x6011             STR      R1,[R2, #+0]
    841                  }
    842                  /* Clear the transfer complete flag */
    843                  regs->IFCR = DMA_FLAG_TCIF0_4 << hdma->StreamIndex;
   \                     ??HAL_DMA_IRQHandler_13: (+1)
   \   0000016E   0x6D61             LDR      R1,[R4, #+84]
   \   00000170   0x4088             LSLS     R0,R0,R1
   \   00000172   0x60A8             STR      R0,[R5, #+8]
    844          
    845                  /* Update error code */
    846                  hdma->ErrorCode |= HAL_DMA_ERROR_NONE;
   \   00000174   0x6CE0             LDR      R0,[R4, #+76]
   \   00000176   0x64E0             STR      R0,[R4, #+76]
    847          
    848                  /* Change the DMA state */
    849                  hdma->State = HAL_DMA_STATE_READY_MEM0;
   \   00000178   0x2011             MOVS     R0,#+17
   \   0000017A   0xF884 0x0035      STRB     R0,[R4, #+53]
    850          
    851                  /* Process Unlocked */
    852                  __HAL_UNLOCK(hdma);      
   \   0000017E   0x2000             MOVS     R0,#+0
   \   00000180   0xF884 0x0034      STRB     R0,[R4, #+52]
    853          
    854                  if(hdma->XferCpltCallback != NULL)
   \                     ??HAL_DMA_IRQHandler_12: (+1)
   \   00000184   0x6BE1             LDR      R1,[R4, #+60]
   \   00000186   0x0008             MOVS     R0,R1
   \   00000188   0xD004             BEQ.N    ??HAL_DMA_IRQHandler_9
    855                  {
    856                    /* Transfer complete callback */
    857                    hdma->XferCpltCallback(hdma);
   \   0000018A   0x4620             MOV      R0,R4
   \   0000018C   0xB001             ADD      SP,SP,#+4
   \   0000018E   0xE8BD 0x4030      POP      {R4,R5,LR}
   \   00000192   0x4708             BX       R1
    858                  }
    859                }
    860              }
    861            }
    862          }
   \                     ??HAL_DMA_IRQHandler_9: (+1)
   \   00000194   0xB001             ADD      SP,SP,#+4
   \   00000196   0xBD30             POP      {R4,R5,PC}       ;; return
    863          
    864          
    865          /**
    866            * @}
    867            */
    868          
    869          /** @addtogroup DMA_Exported_Functions_Group3
    870            *
    871          @verbatim
    872           ===============================================================================
    873                              ##### State and Errors functions #####
    874           ===============================================================================
    875              [..]
    876              This subsection provides functions allowing to
    877                (+) Check the DMA state
    878                (+) Get error code
    879          
    880          @endverbatim
    881            * @{
    882            */
    883          
    884          /**
    885            * @brief  Returns the DMA state.
    886            * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
    887            *               the configuration information for the specified DMA Stream.
    888            * @retval HAL state
    889            */

   \                                 In section .text, align 2, keep-with-next
    890          HAL_DMA_StateTypeDef HAL_DMA_GetState(DMA_HandleTypeDef *hdma)
    891          {
    892            return hdma->State;
   \                     HAL_DMA_GetState: (+1)
   \   00000000   0xF890 0x0035      LDRB     R0,[R0, #+53]
   \   00000004   0x4770             BX       LR               ;; return
    893          }
    894          
    895          /**
    896            * @brief  Return the DMA error code
    897            * @param  hdma : pointer to a DMA_HandleTypeDef structure that contains
    898            *              the configuration information for the specified DMA Stream.
    899            * @retval DMA Error Code
    900            */

   \                                 In section .text, align 2, keep-with-next
    901          uint32_t HAL_DMA_GetError(DMA_HandleTypeDef *hdma)
    902          {
    903            return hdma->ErrorCode;
   \                     HAL_DMA_GetError: (+1)
   \   00000000   0x6CC0             LDR      R0,[R0, #+76]
   \   00000002   0x4770             BX       LR               ;; return
    904          }
    905          
    906          /**
    907            * @}
    908            */
    909          
    910          /**
    911            * @brief  Returns the DMA Stream base address depending on stream number
    912            * @param  hdma:       pointer to a DMA_HandleTypeDef structure that contains
    913            *                     the configuration information for the specified DMA Stream. 
    914            * @retval Stream base address
    915            */
    916          static uint32_t DMA_CalcBaseAndBitshift(DMA_HandleTypeDef *hdma)
    917          {
    918            uint32_t stream_number = (((uint32_t)hdma->Instance & 0xFF) - 16) / 24;
    919            
    920            /* lookup table for necessary bitshift of flags within status registers */

   \                                 In section .text, align 4, keep-with-next
    921            static const uint8_t flagBitshiftOffset[8] = {0, 6, 16, 22, 0, 6, 16, 22};
   \                     ??flagBitshiftOffset:
   \   00000000   0x00 0x06          DC8 0, 6, 16, 22, 0, 6, 16, 22
   \              0x10 0x16    
   \              0x00 0x06    
   \              0x10 0x16    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3:
   \   00000000   0xF010803F         DC32     0xf010803f

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_1:
   \   00000000   0x00800004         DC32     0x800004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_2:
   \   00000000   0x00800001         DC32     0x800001
    922            hdma->StreamIndex = flagBitshiftOffset[stream_number];
    923            
    924            if (stream_number > 3)
    925            {
    926              /* return pointer to HISR and HIFCR */
    927              hdma->StreamBaseAddress = (((uint32_t)hdma->Instance & (uint32_t)(~0x3FF)) + 4);
    928            }
    929            else
    930            {
    931              /* return pointer to LISR and LIFCR */
    932              hdma->StreamBaseAddress = ((uint32_t)hdma->Instance & (uint32_t)(~0x3FF));
    933            }
    934            
    935            return hdma->StreamBaseAddress;
    936          }
    937          /**
    938            * @}
    939            */
    940          
    941          #endif /* HAL_DMA_MODULE_ENABLED */
    942          /**
    943            * @}
    944            */
    945          
    946          /**
    947            * @}
    948            */
    949          
    950          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   HAL_DMA_Abort
        16   -> HAL_GetTick
       0   HAL_DMA_DeInit
       0   HAL_DMA_GetError
       0   HAL_DMA_GetState
      16   HAL_DMA_IRQHandler
         0   -- Indirect call
        16   -- Indirect call
       0   HAL_DMA_Init
      40   HAL_DMA_PollForTransfer
        40   -> HAL_GetTick
       8   HAL_DMA_Start
       8   HAL_DMA_Start_IT


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable3
       4  ??DataTable3_1
       4  ??DataTable3_2
      80  HAL_DMA_Abort
     110  HAL_DMA_DeInit
       4  HAL_DMA_GetError
       6  HAL_DMA_GetState
     408  HAL_DMA_IRQHandler
     142  HAL_DMA_Init
     300  HAL_DMA_PollForTransfer
      88  HAL_DMA_Start
     108  HAL_DMA_Start_IT
       8  flagBitshiftOffset

 
 1 266 bytes in section .text
 
 1 266 bytes of CODE memory

Errors: none
Warnings: none
