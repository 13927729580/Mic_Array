###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.2.10312/W32 for ARM       16/Apr/2016  18:30:59
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_dma.c
#    Command line =  
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_dma.c
#        -D USE_HAL_DRIVER -D STM32F746xx -D USE_STM32746G_DISCO -D
#        USE_IOEXPANDER -D USE_USB_FS -lC
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
#        -lA
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
#        -o
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj
#        --no_unroll --debug --endian=little --cpu=Cortex-M7 -e --fpu=VFPv5_sp
#        --dlib_config "D:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Full.h" -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\CMSIS\Device\ST\STM32F7xx\Include\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\STM32F7xx_HAL_Driver\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\STM32746G-Discovery\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\Components\Common\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Log\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Fonts\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\CPU\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_Device_Library\Core\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Core\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Class\MSC\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\drivers\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_Audio\Addons\PDM\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_Device_Library\Class\AUDIO\Inc\
#        -Oh --use_c++_inline --require_prototypes -I "D:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.3\arm\CMSIS\Include\" -D
#        ARM_MATH_CM7 --relaxed_fp
#    List file    =  
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List\stm32f7xx_hal_dma.lst
#    Object file  =  
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj\stm32f7xx_hal_dma.o
#
###############################################################################

D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_dma.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f7xx_hal_dma.c
      4            * @author  MCD Application Team
      5            * @version V1.0.4
      6            * @date    09-December-2015
      7            * @brief   DMA HAL module driver.
      8            *    
      9            *          This file provides firmware functions to manage the following 
     10            *          functionalities of the Direct Memory Access (DMA) peripheral:
     11            *           + Initialization and de-initialization functions
     12            *           + IO operation functions
     13            *           + Peripheral State and errors functions
     14            @verbatim     
     15            ==============================================================================      
     16                                  ##### How to use this driver #####
     17            ============================================================================== 
     18            [..]
     19             (#) Enable and configure the peripheral to be connected to the DMA Stream
     20                 (except for internal SRAM/FLASH memories: no initialization is 
     21                 necessary) please refer to Reference manual for connection between peripherals
     22                 and DMA requests . 
     23                    
     24             (#) For a given Stream, program the required configuration through the following parameters:   
     25                 Transfer Direction, Source and Destination data formats, 
     26                 Circular, Normal or peripheral flow control mode, Stream Priority level, 
     27                 Source and Destination Increment mode, FIFO mode and its Threshold (if needed), 
     28                 Burst mode for Source and/or Destination (if needed) using HAL_DMA_Init() function.
     29                               
     30               *** Polling mode IO operation ***
     31               =================================   
     32              [..] 
     33                    (+) Use HAL_DMA_Start() to start DMA transfer after the configuration of Source 
     34                        address and destination address and the Length of data to be transferred
     35                    (+) Use HAL_DMA_PollForTransfer() to poll for the end of current transfer, in this  
     36                        case a fixed Timeout can be configured by User depending from his application.
     37                         
     38               *** Interrupt mode IO operation ***    
     39               =================================== 
     40              [..]     
     41                    (+) Configure the DMA interrupt priority using HAL_NVIC_SetPriority()
     42                    (+) Enable the DMA IRQ handler using HAL_NVIC_EnableIRQ() 
     43                    (+) Use HAL_DMA_Start_IT() to start DMA transfer after the configuration of  
     44                        Source address and destination address and the Length of data to be transferred. In this 
     45                        case the DMA interrupt is configured 
     46                    (+) Use HAL_DMA_IRQHandler() called under DMA_IRQHandler() Interrupt subroutine
     47                    (+) At the end of data transfer HAL_DMA_IRQHandler() function is executed and user can 
     48                        add his own function by customization of function pointer XferCpltCallback and 
     49                        XferErrorCallback (i.e a member of DMA handle structure). 
     50              [..]                
     51               (#) Use HAL_DMA_GetState() function to return the DMA state and HAL_DMA_GetError() in case of error 
     52                   detection.
     53                   
     54               (#) Use HAL_DMA_Abort() function to abort the current transfer
     55               
     56               -@-   In Memory-to-Memory transfer mode, Circular mode is not allowed.
     57              
     58               -@-   The FIFO is used mainly to reduce bus usage and to allow data packing/unpacking: it is
     59                     possible to set different Data Sizes for the Peripheral and the Memory (ie. you can set
     60                     Half-Word data size for the peripheral to access its data register and set Word data size
     61                     for the Memory to gain in access time. Each two half words will be packed and written in
     62                     a single access to a Word in the Memory).
     63                
     64               -@-   When FIFO is disabled, it is not allowed to configure different Data Sizes for Source
     65                     and Destination. In this case the Peripheral Data Size will be applied to both Source
     66                     and Destination.               
     67            
     68               *** DMA HAL driver macros list ***
     69               ============================================= 
     70               [..]
     71                 Below the list of most used macros in DMA HAL driver.
     72                 
     73                (+) __HAL_DMA_ENABLE: Enable the specified DMA Stream.
     74                (+) __HAL_DMA_DISABLE: Disable the specified DMA Stream.
     75                (+) __HAL_DMA_GET_FS: Return the current DMA Stream FIFO filled level.
     76                (+) __HAL_DMA_ENABLE_IT: Enable the specified DMA Stream interrupts.
     77                (+) __HAL_DMA_DISABLE_IT: Disable the specified DMA Stream interrupts.
     78                (+) __HAL_DMA_GET_IT_SOURCE: Check whether the specified DMA Stream interrupt has occurred or not. 
     79               
     80               [..] 
     81                (@) You can refer to the DMA HAL driver header file for more useful macros  
     82            
     83            @endverbatim
     84            ******************************************************************************
     85            * @attention
     86            *
     87            * <h2><center>&copy; COPYRIGHT(c) 2015 STMicroelectronics</center></h2>
     88            *
     89            * Redistribution and use in source and binary forms, with or without modification,
     90            * are permitted provided that the following conditions are met:
     91            *   1. Redistributions of source code must retain the above copyright notice,
     92            *      this list of conditions and the following disclaimer.
     93            *   2. Redistributions in binary form must reproduce the above copyright notice,
     94            *      this list of conditions and the following disclaimer in the documentation
     95            *      and/or other materials provided with the distribution.
     96            *   3. Neither the name of STMicroelectronics nor the names of its contributors
     97            *      may be used to endorse or promote products derived from this software
     98            *      without specific prior written permission.
     99            *
    100            * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
    101            * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
    102            * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
    103            * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
    104            * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
    105            * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
    106            * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
    107            * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
    108            * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
    109            * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
    110            *
    111            ******************************************************************************
    112            */ 
    113          
    114          /* Includes ------------------------------------------------------------------*/
    115          #include "stm32f7xx_hal.h"
    116          
    117          /** @addtogroup STM32F7xx_HAL_Driver
    118            * @{
    119            */
    120          
    121          /** @defgroup DMA DMA
    122            * @brief DMA HAL module driver
    123            * @{
    124            */
    125          
    126          #ifdef HAL_DMA_MODULE_ENABLED
    127          
    128          /* Private types -------------------------------------------------------------*/
    129          typedef struct
    130          {
    131            __IO uint32_t ISR;   /*!< DMA interrupt status register */
    132            __IO uint32_t Reserved0;
    133            __IO uint32_t IFCR;  /*!< DMA interrupt flag clear register */
    134          } DMA_Base_Registers;
    135          
    136          /* Private variables ---------------------------------------------------------*/
    137          /* Private constants ---------------------------------------------------------*/
    138          /** @addtogroup DMA_Private_Constants
    139           * @{
    140           */
    141           #define HAL_TIMEOUT_DMA_ABORT    ((uint32_t)1000)  /* 1s */
    142          /**
    143            * @}
    144            */
    145          /* Private macros ------------------------------------------------------------*/
    146          /* Private functions ---------------------------------------------------------*/
    147          /** @addtogroup DMA_Private_Functions
    148            * @{
    149            */
    150          static void DMA_SetConfig(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength);
    151          static uint32_t DMA_CalcBaseAndBitshift(DMA_HandleTypeDef *hdma);
    152          
    153          /**
    154            * @brief  Sets the DMA Transfer parameter.
    155            * @param  hdma:       pointer to a DMA_HandleTypeDef structure that contains
    156            *                     the configuration information for the specified DMA Stream.
    157            * @param  SrcAddress: The source memory Buffer address
    158            * @param  DstAddress: The destination memory Buffer address
    159            * @param  DataLength: The length of data to be transferred from source to destination
    160            * @retval HAL status
    161            */
    162          static void DMA_SetConfig(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
    163          {
    164            /* Clear DBM bit */
    165            hdma->Instance->CR &= (uint32_t)(~DMA_SxCR_DBM);
    166          	
    167            /* Configure DMA Stream data length */
    168            hdma->Instance->NDTR = DataLength;
    169          
    170            /* Peripheral to Memory */
    171            if((hdma->Init.Direction) == DMA_MEMORY_TO_PERIPH)
    172            {
    173              /* Configure DMA Stream destination address */
    174              hdma->Instance->PAR = DstAddress;
    175          
    176              /* Configure DMA Stream source address */
    177              hdma->Instance->M0AR = SrcAddress;
    178            }
    179            /* Memory to Peripheral */
    180            else
    181            {
    182              /* Configure DMA Stream source address */
    183              hdma->Instance->PAR = SrcAddress;
    184              
    185              /* Configure DMA Stream destination address */
    186              hdma->Instance->M0AR = DstAddress;
    187            }
    188          }
    189          
    190          /**
    191            * @}
    192            */  
    193            
    194          /* Exported functions ---------------------------------------------------------*/
    195          /** @addtogroup DMA_Exported_Functions
    196            * @{
    197            */
    198          
    199          /** @addtogroup DMA_Exported_Functions_Group1
    200            *
    201          @verbatim   
    202           ===============================================================================
    203                       ##### Initialization and de-initialization functions  #####
    204           ===============================================================================  
    205              [..]
    206              This section provides functions allowing to initialize the DMA Stream source
    207              and destination addresses, incrementation and data sizes, transfer direction, 
    208              circular/normal mode selection, memory-to-memory mode selection and Stream priority value.
    209              [..]
    210              The HAL_DMA_Init() function follows the DMA configuration procedures as described in
    211              reference manual.  
    212          
    213          @endverbatim
    214            * @{
    215            */
    216            
    217          /**
    218            * @brief  Initializes the DMA according to the specified
    219            *         parameters in the DMA_InitTypeDef and create the associated handle.
    220            * @param  hdma: Pointer to a DMA_HandleTypeDef structure that contains
    221            *               the configuration information for the specified DMA Stream.  
    222            * @retval HAL status
    223            */

   \                                 In section .text, align 2, keep-with-next
    224          HAL_StatusTypeDef HAL_DMA_Init(DMA_HandleTypeDef *hdma)
    225          { 
   \                     HAL_DMA_Init: (+1)
   \   00000000   0xB410             PUSH     {R4}
    226            uint32_t tmp = 0;
    227            
    228            /* Check the DMA peripheral state */
    229            if(hdma == NULL)
   \   00000002   0xB910             CBNZ.N   R0,??HAL_DMA_Init_0
    230            {
    231              return HAL_ERROR;
   \   00000004   0x2001             MOVS     R0,#+1
   \   00000006   0xBC10             POP      {R4}
   \   00000008   0x4770             BX       LR
    232            }
    233          
    234            /* Check the parameters */
    235            assert_param(IS_DMA_STREAM_ALL_INSTANCE(hdma->Instance));
    236            assert_param(IS_DMA_CHANNEL(hdma->Init.Channel));
    237            assert_param(IS_DMA_DIRECTION(hdma->Init.Direction));
    238            assert_param(IS_DMA_PERIPHERAL_INC_STATE(hdma->Init.PeriphInc));
    239            assert_param(IS_DMA_MEMORY_INC_STATE(hdma->Init.MemInc));
    240            assert_param(IS_DMA_PERIPHERAL_DATA_SIZE(hdma->Init.PeriphDataAlignment));
    241            assert_param(IS_DMA_MEMORY_DATA_SIZE(hdma->Init.MemDataAlignment));
    242            assert_param(IS_DMA_MODE(hdma->Init.Mode));
    243            assert_param(IS_DMA_PRIORITY(hdma->Init.Priority));
    244            assert_param(IS_DMA_FIFO_MODE_STATE(hdma->Init.FIFOMode));
    245            /* Check the memory burst, peripheral burst and FIFO threshold parameters only
    246               when FIFO mode is enabled */
    247            if(hdma->Init.FIFOMode != DMA_FIFOMODE_DISABLE)
    248            {
    249              assert_param(IS_DMA_FIFO_THRESHOLD(hdma->Init.FIFOThreshold));
    250              assert_param(IS_DMA_MEMORY_BURST(hdma->Init.MemBurst));
    251              assert_param(IS_DMA_PERIPHERAL_BURST(hdma->Init.PeriphBurst));
    252            }
    253          
    254            /* Change DMA peripheral state */
    255            hdma->State = HAL_DMA_STATE_BUSY;
   \                     ??HAL_DMA_Init_0: (+1)
   \   0000000A   0x2102             MOVS     R1,#+2
    256          
    257            /* Get the CR register value */
    258            tmp = hdma->Instance->CR;
    259          
    260            /* Clear CHSEL, MBURST, PBURST, PL, MSIZE, PSIZE, MINC, PINC, CIRC, DIR, CT and DBM bits */
    261            tmp &= ((uint32_t)~(DMA_SxCR_CHSEL | DMA_SxCR_MBURST | DMA_SxCR_PBURST | \
    262                                DMA_SxCR_PL    | DMA_SxCR_MSIZE  | DMA_SxCR_PSIZE  | \
    263                                DMA_SxCR_MINC  | DMA_SxCR_PINC   | DMA_SxCR_CIRC   | \
    264                                DMA_SxCR_DIR   | DMA_SxCR_CT     | DMA_SxCR_DBM));
    265          
    266            /* Prepare the DMA Stream configuration */
    267            tmp |=  hdma->Init.Channel             | hdma->Init.Direction        |
    268                    hdma->Init.PeriphInc           | hdma->Init.MemInc           |
    269                    hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
    270                    hdma->Init.Mode                | hdma->Init.Priority;
   \   0000000C   0x.... 0x....      LDR.W    R3,??DataTable3  ;; 0xf010803f
   \   00000010   0xF880 0x1035      STRB     R1,[R0, #+53]
   \   00000014   0x6801             LDR      R1,[R0, #+0]
   \   00000016   0x680A             LDR      R2,[R1, #+0]
   \   00000018   0x401A             ANDS     R2,R3,R2
   \   0000001A   0x6843             LDR      R3,[R0, #+4]
   \   0000001C   0x431A             ORRS     R2,R3,R2
   \   0000001E   0x6883             LDR      R3,[R0, #+8]
   \   00000020   0x431A             ORRS     R2,R3,R2
   \   00000022   0x68C3             LDR      R3,[R0, #+12]
   \   00000024   0x431A             ORRS     R2,R3,R2
   \   00000026   0x6903             LDR      R3,[R0, #+16]
   \   00000028   0x431A             ORRS     R2,R3,R2
   \   0000002A   0x6943             LDR      R3,[R0, #+20]
   \   0000002C   0x431A             ORRS     R2,R3,R2
   \   0000002E   0x6983             LDR      R3,[R0, #+24]
   \   00000030   0x431A             ORRS     R2,R3,R2
   \   00000032   0x69C3             LDR      R3,[R0, #+28]
   \   00000034   0x431A             ORRS     R2,R3,R2
   \   00000036   0x6A03             LDR      R3,[R0, #+32]
   \   00000038   0x431A             ORRS     R2,R3,R2
    271          
    272            /* the Memory burst and peripheral burst are not used when the FIFO is disabled */
    273            if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)
   \   0000003A   0x6A43             LDR      R3,[R0, #+36]
   \   0000003C   0x2B04             CMP      R3,#+4
   \   0000003E   0xD103             BNE.N    ??HAL_DMA_Init_1
    274            {
    275              /* Get memory burst and peripheral burst */
    276              tmp |=  hdma->Init.MemBurst | hdma->Init.PeriphBurst;
   \   00000040   0x6AC3             LDR      R3,[R0, #+44]
   \   00000042   0x6B04             LDR      R4,[R0, #+48]
   \   00000044   0x4323             ORRS     R3,R4,R3
   \   00000046   0x431A             ORRS     R2,R3,R2
    277            }
    278            
    279            /* Write to DMA Stream CR register */
    280            hdma->Instance->CR = tmp;  
   \                     ??HAL_DMA_Init_1: (+1)
   \   00000048   0x600A             STR      R2,[R1, #+0]
    281          
    282            /* Get the FCR register value */
    283            tmp = hdma->Instance->FCR;
   \   0000004A   0x6801             LDR      R1,[R0, #+0]
    284          
    285            /* Clear Direct mode and FIFO threshold bits */
    286            tmp &= (uint32_t)~(DMA_SxFCR_DMDIS | DMA_SxFCR_FTH);
    287          
    288            /* Prepare the DMA Stream FIFO configuration */
    289            tmp |= hdma->Init.FIFOMode;
    290          
    291            /* the FIFO threshold is not used when the FIFO mode is disabled */
    292            if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)
    293            {
    294              /* Get the FIFO threshold */
    295              tmp |= hdma->Init.FIFOThreshold;
    296            }
    297            
    298            /* Write to DMA Stream FCR */
    299            hdma->Instance->FCR = tmp;
    300          
    301            /* Initialize StreamBaseAddress and StreamIndex parameters to be used to calculate
    302               DMA steam Base Address needed by HAL_DMA_IRQHandler() and HAL_DMA_PollForTransfer() */
    303            DMA_CalcBaseAndBitshift(hdma);
   \   0000004C   0x.... 0x....      ADR.W    R4,??flagBitshiftOffset
   \   00000050   0x694A             LDR      R2,[R1, #+20]
   \   00000052   0x6A43             LDR      R3,[R0, #+36]
   \   00000054   0x08D2             LSRS     R2,R2,#+3
   \   00000056   0x2B04             CMP      R3,#+4
   \   00000058   0xEA43 0x02C2      ORR      R2,R3,R2, LSL #+3
   \   0000005C   0xBF04             ITT      EQ 
   \   0000005E   0x6A83             LDREQ    R3,[R0, #+40]
   \   00000060   0x431A             ORREQ    R2,R3,R2
   \   00000062   0x614A             STR      R2,[R1, #+20]
   \   00000064   0x6801             LDR      R1,[R0, #+0]
   \   00000066   0x2318             MOVS     R3,#+24
   \   00000068   0xB2CA             UXTB     R2,R1
   \   0000006A   0x0A89             LSRS     R1,R1,#+10
   \   0000006C   0x3A10             SUBS     R2,R2,#+16
   \   0000006E   0x0289             LSLS     R1,R1,#+10
   \   00000070   0xFBB2 0xF2F3      UDIV     R2,R2,R3
   \   00000074   0x2A04             CMP      R2,#+4
   \   00000076   0xF100 0x034C      ADD      R3,R0,#+76
   \   0000007A   0x5D14             LDRB     R4,[R2, R4]
   \   0000007C   0x609C             STR      R4,[R3, #+8]
   \   0000007E   0xBF28             IT       CS 
   \   00000080   0x1D09             ADDCS    R1,R1,#+4
   \   00000082   0x6059             STR      R1,[R3, #+4]
    304          	
    305            /* Initialize the error code */
    306            hdma->ErrorCode = HAL_DMA_ERROR_NONE;
   \   00000084   0x2100             MOVS     R1,#+0
   \   00000086   0x6019             STR      R1,[R3, #+0]
    307          
    308            /* Initialize the DMA state */
    309            hdma->State = HAL_DMA_STATE_READY;
   \   00000088   0x2101             MOVS     R1,#+1
   \   0000008A   0xF880 0x1035      STRB     R1,[R0, #+53]
    310          
    311            return HAL_OK;
   \   0000008E   0x2000             MOVS     R0,#+0
   \   00000090   0xBC10             POP      {R4}
   \   00000092   0x4770             BX       LR               ;; return
    312          }
    313          
    314          /**
    315            * @brief  DeInitializes the DMA peripheral 
    316            * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
    317            *               the configuration information for the specified DMA Stream.  
    318            * @retval HAL status
    319            */

   \                                 In section .text, align 2, keep-with-next
    320          HAL_StatusTypeDef HAL_DMA_DeInit(DMA_HandleTypeDef *hdma)
    321          {
    322          	DMA_Base_Registers *regs;
    323          	
    324            /* Check the DMA peripheral state */
    325            if(hdma == NULL)
   \                     HAL_DMA_DeInit: (+1)
   \   00000000   0x2800             CMP      R0,#+0
   \   00000002   0xBF1E             ITTT     NE 
   \   00000004   0xF100 0x0134      ADDNE    R1,R0,#+52
   \   00000008   0x784A             LDRBNE   R2,[R1, #+1]
   \   0000000A   0x2A02             CMPNE    R2,#+2
    326            {
    327              return HAL_ERROR;
    328            }
    329            
    330            /* Check the DMA peripheral state */
    331            if(hdma->State == HAL_DMA_STATE_BUSY)
   \   0000000C   0xD101             BNE.N    ??HAL_DMA_DeInit_0
    332            {
    333               return HAL_ERROR;
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0x4770             BX       LR
    334            }
    335          
    336            /* Disable the selected DMA Streamx */
    337            __HAL_DMA_DISABLE(hdma);
   \                     ??HAL_DMA_DeInit_0: (+1)
   \   00000012   0x6802             LDR      R2,[R0, #+0]
   \   00000014   0x6813             LDR      R3,[R2, #+0]
   \   00000016   0x085B             LSRS     R3,R3,#+1
   \   00000018   0x005B             LSLS     R3,R3,#+1
   \   0000001A   0x6013             STR      R3,[R2, #+0]
    338          
    339            /* Reset DMA Streamx control register */
    340            hdma->Instance->CR   = 0;
   \   0000001C   0x6803             LDR      R3,[R0, #+0]
   \   0000001E   0x2200             MOVS     R2,#+0
   \   00000020   0x601A             STR      R2,[R3, #+0]
    341          
    342            /* Reset DMA Streamx number of data to transfer register */
    343            hdma->Instance->NDTR = 0;
   \   00000022   0x6803             LDR      R3,[R0, #+0]
   \   00000024   0x605A             STR      R2,[R3, #+4]
    344          
    345            /* Reset DMA Streamx peripheral address register */
    346            hdma->Instance->PAR  = 0;
   \   00000026   0x6803             LDR      R3,[R0, #+0]
   \   00000028   0x609A             STR      R2,[R3, #+8]
    347          
    348            /* Reset DMA Streamx memory 0 address register */
    349            hdma->Instance->M0AR = 0;
   \   0000002A   0x6803             LDR      R3,[R0, #+0]
   \   0000002C   0x60DA             STR      R2,[R3, #+12]
    350          
    351            /* Reset DMA Streamx memory 1 address register */
    352            hdma->Instance->M1AR = 0;
   \   0000002E   0x6803             LDR      R3,[R0, #+0]
   \   00000030   0x611A             STR      R2,[R3, #+16]
    353          
    354            /* Reset DMA Streamx FIFO control register */
    355            hdma->Instance->FCR  = (uint32_t)0x00000021;
   \   00000032   0x6803             LDR      R3,[R0, #+0]
   \   00000034   0x2221             MOVS     R2,#+33
   \   00000036   0x615A             STR      R2,[R3, #+20]
    356          
    357            /* Get DMA steam Base Address */  
    358            regs = (DMA_Base_Registers *)DMA_CalcBaseAndBitshift(hdma);
   \   00000038   0x6800             LDR      R0,[R0, #+0]
   \   0000003A   0x2318             MOVS     R3,#+24
   \   0000003C   0xB2C2             UXTB     R2,R0
   \   0000003E   0x3A10             SUBS     R2,R2,#+16
   \   00000040   0xFBB2 0xF2F3      UDIV     R2,R2,R3
   \   00000044   0x.... 0x....      ADR.W    R3,??flagBitshiftOffset
   \   00000048   0x0A80             LSRS     R0,R0,#+10
   \   0000004A   0x0280             LSLS     R0,R0,#+10
   \   0000004C   0x2A04             CMP      R2,#+4
   \   0000004E   0x5CD3             LDRB     R3,[R2, R3]
   \   00000050   0x620B             STR      R3,[R1, #+32]
   \   00000052   0xBF28             IT       CS 
   \   00000054   0x1D00             ADDCS    R0,R0,#+4
   \   00000056   0x61C8             STR      R0,[R1, #+28]
    359            
    360            /* Clear all interrupt flags at correct offset within the register */
    361            regs->IFCR = 0x3F << hdma->StreamIndex;
   \   00000058   0x203F             MOVS     R0,#+63
   \   0000005A   0x69CA             LDR      R2,[R1, #+28]
   \   0000005C   0x4098             LSLS     R0,R0,R3
   \   0000005E   0x6090             STR      R0,[R2, #+8]
    362          
    363            /* Initialize the error code */
    364            hdma->ErrorCode = HAL_DMA_ERROR_NONE;
   \   00000060   0x2000             MOVS     R0,#+0
   \   00000062   0x6188             STR      R0,[R1, #+24]
    365          
    366            /* Initialize the DMA state */
    367            hdma->State = HAL_DMA_STATE_RESET;
   \   00000064   0x7048             STRB     R0,[R1, #+1]
    368          
    369            /* Release Lock */
    370            __HAL_UNLOCK(hdma);
   \   00000066   0x7008             STRB     R0,[R1, #+0]
    371          
    372            return HAL_OK;
   \   00000068   0x4770             BX       LR               ;; return
    373          }
    374          
    375          /**
    376            * @}
    377            */
    378          
    379          /** @addtogroup DMA_Exported_Functions_Group2
    380            *
    381          @verbatim   
    382           ===============================================================================
    383                                #####  IO operation functions  #####
    384           ===============================================================================  
    385              [..]  This section provides functions allowing to:
    386                (+) Configure the source, destination address and data length and Start DMA transfer
    387                (+) Configure the source, destination address and data length and 
    388                    Start DMA transfer with interrupt
    389                (+) Abort DMA transfer
    390                (+) Poll for transfer complete
    391                (+) Handle DMA interrupt request  
    392          
    393          @endverbatim
    394            * @{
    395            */
    396          
    397          /**
    398            * @brief  Starts the DMA Transfer.
    399            * @param  hdma      : pointer to a DMA_HandleTypeDef structure that contains
    400            *                     the configuration information for the specified DMA Stream.  
    401            * @param  SrcAddress: The source memory Buffer address
    402            * @param  DstAddress: The destination memory Buffer address
    403            * @param  DataLength: The length of data to be transferred from source to destination
    404            * @retval HAL status
    405            */

   \                                 In section .text, align 2, keep-with-next
    406          HAL_StatusTypeDef HAL_DMA_Start(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
    407          {
   \                     HAL_DMA_Start: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
    408            /* Process locked */
    409            __HAL_LOCK(hdma);
   \   00000002   0xF100 0x0434      ADD      R4,R0,#+52
   \   00000006   0x7825             LDRB     R5,[R4, #+0]
   \   00000008   0x2D01             CMP      R5,#+1
   \   0000000A   0xBF08             IT       EQ 
   \   0000000C   0x2002             MOVEQ    R0,#+2
   \   0000000E   0xD020             BEQ.N    ??HAL_DMA_Start_0
   \   00000010   0x2501             MOVS     R5,#+1
   \   00000012   0x7025             STRB     R5,[R4, #+0]
    410          
    411            /* Change DMA peripheral state */
    412            hdma->State = HAL_DMA_STATE_BUSY;
   \   00000014   0x2502             MOVS     R5,#+2
   \   00000016   0x7065             STRB     R5,[R4, #+1]
    413          
    414             /* Check the parameters */
    415            assert_param(IS_DMA_BUFFER_SIZE(DataLength));
    416          
    417            /* Disable the peripheral */
    418            __HAL_DMA_DISABLE(hdma);
   \   00000018   0x6804             LDR      R4,[R0, #+0]
   \   0000001A   0x6825             LDR      R5,[R4, #+0]
   \   0000001C   0x086D             LSRS     R5,R5,#+1
   \   0000001E   0x006D             LSLS     R5,R5,#+1
   \   00000020   0x6025             STR      R5,[R4, #+0]
    419          
    420            /* Configure the source, destination address and the data length */
    421            DMA_SetConfig(hdma, SrcAddress, DstAddress, DataLength);
   \   00000022   0x6804             LDR      R4,[R0, #+0]
   \   00000024   0x6825             LDR      R5,[R4, #+0]
   \   00000026   0xF425 0x2580      BIC      R5,R5,#0x40000
   \   0000002A   0x6025             STR      R5,[R4, #+0]
   \   0000002C   0x6804             LDR      R4,[R0, #+0]
   \   0000002E   0x6063             STR      R3,[R4, #+4]
   \   00000030   0x6883             LDR      R3,[R0, #+8]
   \   00000032   0x2B40             CMP      R3,#+64
   \   00000034   0x6803             LDR      R3,[R0, #+0]
   \   00000036   0xD103             BNE.N    ??HAL_DMA_Start_1
   \   00000038   0x609A             STR      R2,[R3, #+8]
   \   0000003A   0x6802             LDR      R2,[R0, #+0]
   \   0000003C   0x60D1             STR      R1,[R2, #+12]
   \   0000003E   0xE002             B.N      ??HAL_DMA_Start_2
   \                     ??HAL_DMA_Start_1: (+1)
   \   00000040   0x6099             STR      R1,[R3, #+8]
   \   00000042   0x6801             LDR      R1,[R0, #+0]
   \   00000044   0x60CA             STR      R2,[R1, #+12]
    422          
    423            /* Enable the Peripheral */
    424            __HAL_DMA_ENABLE(hdma);
   \                     ??HAL_DMA_Start_2: (+1)
   \   00000046   0x6800             LDR      R0,[R0, #+0]
   \   00000048   0x6801             LDR      R1,[R0, #+0]
   \   0000004A   0xF041 0x0101      ORR      R1,R1,#0x1
   \   0000004E   0x6001             STR      R1,[R0, #+0]
    425          
    426            return HAL_OK; 
   \   00000050   0x2000             MOVS     R0,#+0
   \                     ??HAL_DMA_Start_0: (+1)
   \   00000052   0xBC30             POP      {R4,R5}
   \   00000054   0x4770             BX       LR               ;; return
    427          }
    428          
    429          /**
    430            * @brief  Start the DMA Transfer with interrupt enabled.
    431            * @param  hdma:       pointer to a DMA_HandleTypeDef structure that contains
    432            *                     the configuration information for the specified DMA Stream.  
    433            * @param  SrcAddress: The source memory Buffer address
    434            * @param  DstAddress: The destination memory Buffer address
    435            * @param  DataLength: The length of data to be transferred from source to destination
    436            * @retval HAL status
    437            */

   \                                 In section .text, align 2, keep-with-next
    438          HAL_StatusTypeDef HAL_DMA_Start_IT(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
    439          {
   \                     HAL_DMA_Start_IT: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
    440            /* Process locked */
    441            __HAL_LOCK(hdma);
   \   00000002   0xF100 0x0434      ADD      R4,R0,#+52
   \   00000006   0x7825             LDRB     R5,[R4, #+0]
   \   00000008   0x2D01             CMP      R5,#+1
   \   0000000A   0xBF08             IT       EQ 
   \   0000000C   0x2002             MOVEQ    R0,#+2
   \   0000000E   0xD02A             BEQ.N    ??HAL_DMA_Start_IT_0
   \   00000010   0x2501             MOVS     R5,#+1
   \   00000012   0x7025             STRB     R5,[R4, #+0]
    442          
    443            /* Change DMA peripheral state */
    444            hdma->State = HAL_DMA_STATE_BUSY;
   \   00000014   0x2502             MOVS     R5,#+2
   \   00000016   0x7065             STRB     R5,[R4, #+1]
    445          
    446             /* Check the parameters */
    447            assert_param(IS_DMA_BUFFER_SIZE(DataLength));
    448          
    449            /* Disable the peripheral */
    450            __HAL_DMA_DISABLE(hdma);
   \   00000018   0x6804             LDR      R4,[R0, #+0]
   \   0000001A   0x6825             LDR      R5,[R4, #+0]
   \   0000001C   0x086D             LSRS     R5,R5,#+1
   \   0000001E   0x006D             LSLS     R5,R5,#+1
   \   00000020   0x6025             STR      R5,[R4, #+0]
    451          
    452            /* Configure the source, destination address and the data length */
    453            DMA_SetConfig(hdma, SrcAddress, DstAddress, DataLength);
   \   00000022   0x6804             LDR      R4,[R0, #+0]
   \   00000024   0x6825             LDR      R5,[R4, #+0]
   \   00000026   0xF425 0x2580      BIC      R5,R5,#0x40000
   \   0000002A   0x6025             STR      R5,[R4, #+0]
   \   0000002C   0x6804             LDR      R4,[R0, #+0]
   \   0000002E   0x6063             STR      R3,[R4, #+4]
   \   00000030   0x6883             LDR      R3,[R0, #+8]
   \   00000032   0x2B40             CMP      R3,#+64
   \   00000034   0x6803             LDR      R3,[R0, #+0]
   \   00000036   0xD103             BNE.N    ??HAL_DMA_Start_IT_1
   \   00000038   0x609A             STR      R2,[R3, #+8]
   \   0000003A   0x6802             LDR      R2,[R0, #+0]
   \   0000003C   0x60D1             STR      R1,[R2, #+12]
   \   0000003E   0xE002             B.N      ??HAL_DMA_Start_IT_2
   \                     ??HAL_DMA_Start_IT_1: (+1)
   \   00000040   0x6099             STR      R1,[R3, #+8]
   \   00000042   0x6801             LDR      R1,[R0, #+0]
   \   00000044   0x60CA             STR      R2,[R1, #+12]
    454          
    455            /* Enable all interrupts */
    456            hdma->Instance->CR  |= DMA_IT_TC | DMA_IT_HT | DMA_IT_TE | DMA_IT_DME;
   \                     ??HAL_DMA_Start_IT_2: (+1)
   \   00000046   0x6801             LDR      R1,[R0, #+0]
   \   00000048   0x680A             LDR      R2,[R1, #+0]
   \   0000004A   0xF042 0x021E      ORR      R2,R2,#0x1E
   \   0000004E   0x600A             STR      R2,[R1, #+0]
    457            hdma->Instance->FCR |= DMA_IT_FE;
   \   00000050   0x6801             LDR      R1,[R0, #+0]
   \   00000052   0x694A             LDR      R2,[R1, #+20]
   \   00000054   0xF042 0x0280      ORR      R2,R2,#0x80
   \   00000058   0x614A             STR      R2,[R1, #+20]
    458          
    459             /* Enable the Peripheral */
    460            __HAL_DMA_ENABLE(hdma);
   \   0000005A   0x6800             LDR      R0,[R0, #+0]
   \   0000005C   0x6801             LDR      R1,[R0, #+0]
   \   0000005E   0xF041 0x0101      ORR      R1,R1,#0x1
   \   00000062   0x6001             STR      R1,[R0, #+0]
    461          
    462            return HAL_OK;
   \   00000064   0x2000             MOVS     R0,#+0
   \                     ??HAL_DMA_Start_IT_0: (+1)
   \   00000066   0xBC30             POP      {R4,R5}
   \   00000068   0x4770             BX       LR               ;; return
    463          } 
    464          
    465          /**
    466            * @brief  Aborts the DMA Transfer.
    467            * @param  hdma  : pointer to a DMA_HandleTypeDef structure that contains
    468            *                 the configuration information for the specified DMA Stream.
    469            *                   
    470            * @note  After disabling a DMA Stream, a check for wait until the DMA Stream is 
    471            *        effectively disabled is added. If a Stream is disabled 
    472            *        while a data transfer is ongoing, the current data will be transferred
    473            *        and the Stream will be effectively disabled only after the transfer of
    474            *        this single data is finished.  
    475            * @retval HAL status
    476            */

   \                                 In section .text, align 2, keep-with-next
    477          HAL_StatusTypeDef HAL_DMA_Abort(DMA_HandleTypeDef *hdma)
    478          {
   \                     HAL_DMA_Abort: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
    479            uint32_t tickstart = 0;
    480          
    481            /* Disable the stream */
    482            __HAL_DMA_DISABLE(hdma);
   \   00000004   0xF240 0x36E9      MOVW     R6,#+1001
   \   00000008   0x6820             LDR      R0,[R4, #+0]
   \   0000000A   0x6801             LDR      R1,[R0, #+0]
   \   0000000C   0x0849             LSRS     R1,R1,#+1
   \   0000000E   0x0049             LSLS     R1,R1,#+1
   \   00000010   0x6001             STR      R1,[R0, #+0]
    483          
    484            /* Get tick */
    485            tickstart = HAL_GetTick();
   \   00000012   0x.... 0x....      BL       HAL_GetTick
   \   00000016   0x4605             MOV      R5,R0
    486          
    487            /* Check if the DMA Stream is effectively disabled */
    488            while((hdma->Instance->CR & DMA_SxCR_EN) != 0)
   \                     ??HAL_DMA_Abort_0: (+1)
   \   00000018   0x6820             LDR      R0,[R4, #+0]
   \   0000001A   0x6800             LDR      R0,[R0, #+0]
   \   0000001C   0x07C0             LSLS     R0,R0,#+31
   \   0000001E   0xD510             BPL.N    ??HAL_DMA_Abort_1
    489            {
    490              /* Check for the Timeout */
    491              if((HAL_GetTick() - tickstart ) > HAL_TIMEOUT_DMA_ABORT)
   \   00000020   0x.... 0x....      BL       HAL_GetTick
   \   00000024   0x1B40             SUBS     R0,R0,R5
   \   00000026   0x42B0             CMP      R0,R6
   \   00000028   0xD3F6             BCC.N    ??HAL_DMA_Abort_0
    492              {
    493                /* Update error code */
    494                hdma->ErrorCode |= HAL_DMA_ERROR_TIMEOUT;
   \   0000002A   0xF104 0x0034      ADD      R0,R4,#+52
   \   0000002E   0x6981             LDR      R1,[R0, #+24]
   \   00000030   0xF041 0x0120      ORR      R1,R1,#0x20
   \   00000034   0x6181             STR      R1,[R0, #+24]
    495                
    496                /* Process Unlocked */
    497                __HAL_UNLOCK(hdma);
   \   00000036   0x2100             MOVS     R1,#+0
   \   00000038   0x7001             STRB     R1,[R0, #+0]
    498                
    499                /* Change the DMA state */
    500                hdma->State = HAL_DMA_STATE_TIMEOUT;
   \   0000003A   0x2103             MOVS     R1,#+3
   \   0000003C   0x7041             STRB     R1,[R0, #+1]
    501                
    502                return HAL_TIMEOUT;
   \   0000003E   0x2003             MOVS     R0,#+3
   \   00000040   0xBD70             POP      {R4-R6,PC}
    503              }
    504            }
    505            /* Process Unlocked */
    506            __HAL_UNLOCK(hdma);
   \                     ??HAL_DMA_Abort_1: (+1)
   \   00000042   0xF104 0x0034      ADD      R0,R4,#+52
   \   00000046   0x2100             MOVS     R1,#+0
   \   00000048   0x7001             STRB     R1,[R0, #+0]
    507          
    508            /* Change the DMA state*/
    509            hdma->State = HAL_DMA_STATE_READY;
   \   0000004A   0x2101             MOVS     R1,#+1
   \   0000004C   0x7041             STRB     R1,[R0, #+1]
    510          
    511            return HAL_OK;
   \   0000004E   0x2000             MOVS     R0,#+0
   \   00000050   0xBD70             POP      {R4-R6,PC}       ;; return
    512          }
    513          
    514          /**
    515            * @brief  Polling for transfer complete.
    516            * @param  hdma:          pointer to a DMA_HandleTypeDef structure that contains
    517            *                        the configuration information for the specified DMA Stream.
    518            * @param  CompleteLevel: Specifies the DMA level complete.  
    519            * @param  Timeout:       Timeout duration.
    520            * @retval HAL status
    521            */

   \                                 In section .text, align 2, keep-with-next
    522          HAL_StatusTypeDef HAL_DMA_PollForTransfer(DMA_HandleTypeDef *hdma, uint32_t CompleteLevel, uint32_t Timeout)
    523          {
   \                     HAL_DMA_PollForTransfer: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x000D             MOVS     R5,R1
    524            uint32_t temp, tmp, tmp1, tmp2;
    525            uint32_t tickstart = 0; 
    526          
    527            /* calculate DMA base and stream number */
    528            DMA_Base_Registers *regs;
    529            
    530            regs = (DMA_Base_Registers *)hdma->StreamBaseAddress;
   \   00000008   0xF104 0x0734      ADD      R7,R4,#+52
   \   0000000C   0x4690             MOV      R8,R2
    531          	
    532            /* Get the level transfer complete flag */
    533            if(CompleteLevel == HAL_DMA_FULL_TRANSFER)
    534            {
    535              /* Transfer Complete flag */
    536          		temp = DMA_FLAG_TCIF0_4 << hdma->StreamIndex;
    537            }
    538            else
    539            {
    540              /* Half Transfer Complete flag */
    541          		temp = DMA_FLAG_HTIF0_4 << hdma->StreamIndex;
   \   0000000E   0x.... 0x....      LDR.W    R10,??DataTable3_1  ;; 0x800004
   \   00000012   0x.... 0x....      LDR.W    R11,??DataTable3_2  ;; 0x800001
   \   00000016   0x69FE             LDR      R6,[R7, #+28]
   \   00000018   0xBF0C             ITE      EQ 
   \   0000001A   0x2020             MOVEQ    R0,#+32
   \   0000001C   0x2010             MOVNE    R0,#+16
   \   0000001E   0x6A39             LDR      R1,[R7, #+32]
   \   00000020   0x4088             LSLS     R0,R0,R1
   \   00000022   0x9000             STR      R0,[SP, #+0]
    542            }
    543          
    544            /* Get tick */
    545            tickstart = HAL_GetTick();
   \   00000024   0x.... 0x....      BL       HAL_GetTick
   \   00000028   0x4681             MOV      R9,R0
    546          
    547            while((regs->ISR & temp) == RESET)
   \                     ??HAL_DMA_PollForTransfer_0: (+1)
   \   0000002A   0x6A38             LDR      R0,[R7, #+32]
   \   0000002C   0x6831             LDR      R1,[R6, #+0]
   \   0000002E   0x9A00             LDR      R2,[SP, #+0]
   \   00000030   0x4211             TST      R1,R2
   \   00000032   0xD149             BNE.N    ??HAL_DMA_PollForTransfer_1
    548            {
    549              tmp  = regs->ISR & (DMA_FLAG_TEIF0_4 << hdma->StreamIndex);
    550              tmp1 = regs->ISR & (DMA_FLAG_FEIF0_4 << hdma->StreamIndex);
   \   00000034   0xFA0B 0xFC00      LSL      R12,R11,R0
   \   00000038   0x2108             MOVS     R1,#+8
   \   0000003A   0x6832             LDR      R2,[R6, #+0]
   \   0000003C   0x4081             LSLS     R1,R1,R0
   \   0000003E   0x6833             LDR      R3,[R6, #+0]
    551              tmp2 = regs->ISR & (DMA_FLAG_DMEIF0_4 << hdma->StreamIndex);
   \   00000040   0xFA0A 0xF000      LSL      R0,R10,R0
   \   00000044   0x400A             ANDS     R2,R1,R2
   \   00000046   0xEA0C 0x0303      AND      R3,R12,R3
   \   0000004A   0xF8D6 0xC000      LDR      R12,[R6, #+0]
   \   0000004E   0xEA00 0x000C      AND      R0,R0,R12
    552              if((tmp != RESET) || (tmp1 != RESET) || (tmp2 != RESET))
   \   00000052   0xEA43 0x0C02      ORR      R12,R3,R2
   \   00000056   0xEA50 0x0C0C      ORRS     R12,R0,R12
   \   0000005A   0xD01E             BEQ.N    ??HAL_DMA_PollForTransfer_2
    553              {
    554                if(tmp != RESET)
   \   0000005C   0xB122             CBZ.N    R2,??HAL_DMA_PollForTransfer_3
    555                {
    556                  /* Update error code */
    557                  hdma->ErrorCode |= HAL_DMA_ERROR_TE;
   \   0000005E   0x69BA             LDR      R2,[R7, #+24]
   \   00000060   0xF042 0x0201      ORR      R2,R2,#0x1
   \   00000064   0x61BA             STR      R2,[R7, #+24]
    558          
    559                  /* Clear the transfer error flag */
    560                  regs->IFCR = DMA_FLAG_TEIF0_4 << hdma->StreamIndex;
   \   00000066   0x60B1             STR      R1,[R6, #+8]
    561                }
    562                if(tmp1 != RESET)
   \                     ??HAL_DMA_PollForTransfer_3: (+1)
   \   00000068   0xB13B             CBZ.N    R3,??HAL_DMA_PollForTransfer_4
    563                {
    564                  /* Update error code */
    565                  hdma->ErrorCode |= HAL_DMA_ERROR_FE;
   \   0000006A   0x69B9             LDR      R1,[R7, #+24]
   \   0000006C   0xF041 0x0102      ORR      R1,R1,#0x2
   \   00000070   0x61B9             STR      R1,[R7, #+24]
    566           
    567                  /* Clear the FIFO error flag */
    568                  regs->IFCR = DMA_FLAG_FEIF0_4 << hdma->StreamIndex;
   \   00000072   0x6A39             LDR      R1,[R7, #+32]
   \   00000074   0xFA0B 0xF101      LSL      R1,R11,R1
   \   00000078   0x60B1             STR      R1,[R6, #+8]
    569                }
    570                if(tmp2 != RESET)
   \                     ??HAL_DMA_PollForTransfer_4: (+1)
   \   0000007A   0xB138             CBZ.N    R0,??HAL_DMA_PollForTransfer_5
    571                {
    572                  /* Update error code */
    573                  hdma->ErrorCode |= HAL_DMA_ERROR_DME;
   \   0000007C   0x69B8             LDR      R0,[R7, #+24]
   \   0000007E   0xF040 0x0004      ORR      R0,R0,#0x4
   \   00000082   0x61B8             STR      R0,[R7, #+24]
    574          
    575                  /* Clear the Direct Mode error flag */
    576                  regs->IFCR = DMA_FLAG_DMEIF0_4 << hdma->StreamIndex;
   \   00000084   0x6A38             LDR      R0,[R7, #+32]
   \   00000086   0xFA0A 0xF000      LSL      R0,R10,R0
   \   0000008A   0x60B0             STR      R0,[R6, #+8]
    577                }
    578                /* Change the DMA state */
    579                hdma->State= HAL_DMA_STATE_ERROR;
   \                     ??HAL_DMA_PollForTransfer_5: (+1)
   \   0000008C   0x2004             MOVS     R0,#+4
   \   0000008E   0x7078             STRB     R0,[R7, #+1]
    580                
    581                /* Process Unlocked */
    582                __HAL_UNLOCK(hdma);
   \   00000090   0x2000             MOVS     R0,#+0
   \   00000092   0x7038             STRB     R0,[R7, #+0]
    583          
    584                return HAL_ERROR;
   \   00000094   0x2001             MOVS     R0,#+1
   \   00000096   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}
    585              }  
    586              /* Check for the Timeout */
    587              if(Timeout != HAL_MAX_DELAY)
   \                     ??HAL_DMA_PollForTransfer_2: (+1)
   \   0000009A   0xF118 0x0F01      CMN      R8,#+1
   \   0000009E   0xD0C4             BEQ.N    ??HAL_DMA_PollForTransfer_0
    588              {
    589                if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
   \   000000A0   0xF1B8 0x0F00      CMP      R8,#+0
   \   000000A4   0xD005             BEQ.N    ??HAL_DMA_PollForTransfer_6
   \   000000A6   0x.... 0x....      BL       HAL_GetTick
   \   000000AA   0xEBA0 0x0009      SUB      R0,R0,R9
   \   000000AE   0x4580             CMP      R8,R0
   \   000000B0   0xD2BB             BCS.N    ??HAL_DMA_PollForTransfer_0
    590                {
    591                  /* Update error code */
    592                  hdma->ErrorCode |= HAL_DMA_ERROR_TIMEOUT;
   \                     ??HAL_DMA_PollForTransfer_6: (+1)
   \   000000B2   0x69B8             LDR      R0,[R7, #+24]
   \   000000B4   0xF040 0x0020      ORR      R0,R0,#0x20
   \   000000B8   0x61B8             STR      R0,[R7, #+24]
    593          
    594                  /* Change the DMA state */
    595                  hdma->State = HAL_DMA_STATE_TIMEOUT;
   \   000000BA   0x2003             MOVS     R0,#+3
   \   000000BC   0x7078             STRB     R0,[R7, #+1]
    596          
    597                  /* Process Unlocked */
    598                  __HAL_UNLOCK(hdma);
   \   000000BE   0x2000             MOVS     R0,#+0
   \   000000C0   0x7038             STRB     R0,[R7, #+0]
    599                  
    600                  return HAL_TIMEOUT;
   \   000000C2   0x2003             MOVS     R0,#+3
   \   000000C4   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}
    601                }
    602              }
    603            }
    604          
    605            if(CompleteLevel == HAL_DMA_FULL_TRANSFER)
   \                     ??HAL_DMA_PollForTransfer_1: (+1)
   \   000000C8   0xB9A5             CBNZ.N   R5,??HAL_DMA_PollForTransfer_7
    606            {
    607              /* Clear the half transfer and transfer complete flags */
    608              regs->IFCR = (DMA_FLAG_HTIF0_4 | DMA_FLAG_TCIF0_4) << hdma->StreamIndex;
   \   000000CA   0x2130             MOVS     R1,#+48
   \   000000CC   0xFA01 0xF000      LSL      R0,R1,R0
   \   000000D0   0x60B0             STR      R0,[R6, #+8]
    609          		
    610              /* Multi_Buffering mode enabled */
    611              if(((hdma->Instance->CR) & (uint32_t)(DMA_SxCR_DBM)) != 0)
   \   000000D2   0x6820             LDR      R0,[R4, #+0]
   \   000000D4   0x6801             LDR      R1,[R0, #+0]
   \   000000D6   0x0349             LSLS     R1,R1,#+13
   \   000000D8   0xD507             BPL.N    ??HAL_DMA_PollForTransfer_8
    612              {
    613                /* Current memory buffer used is Memory 0 */
    614                if((hdma->Instance->CR & DMA_SxCR_CT) == 0)
   \   000000DA   0x6801             LDR      R1,[R0, #+0]
   \   000000DC   0x0309             LSLS     R1,R1,#+12
   \   000000DE   0xD504             BPL.N    ??HAL_DMA_PollForTransfer_8
    615                {
    616                  /* Change DMA peripheral state */
    617                  hdma->State = HAL_DMA_STATE_READY_MEM0;
    618                }
    619                /* Current memory buffer used is Memory 1 */
    620                else if((hdma->Instance->CR & DMA_SxCR_CT) != 0)
   \   000000E0   0x6800             LDR      R0,[R0, #+0]
   \   000000E2   0x0300             LSLS     R0,R0,#+12
   \   000000E4   0xD503             BPL.N    ??HAL_DMA_PollForTransfer_9
    621                {
    622                  /* Change DMA peripheral state */
    623                  hdma->State = HAL_DMA_STATE_READY_MEM1;
   \   000000E6   0x2021             MOVS     R0,#+33
   \   000000E8   0xE000             B.N      ??HAL_DMA_PollForTransfer_10
    624                }
    625              }
    626              else
    627              {
    628                /* The selected Streamx EN bit is cleared (DMA is disabled and all transfers
    629                   are complete) */
    630                hdma->State = HAL_DMA_STATE_READY_MEM0;
   \                     ??HAL_DMA_PollForTransfer_8: (+1)
   \   000000EA   0x2011             MOVS     R0,#+17
   \                     ??HAL_DMA_PollForTransfer_10: (+1)
   \   000000EC   0x7078             STRB     R0,[R7, #+1]
    631              }
    632              /* Process Unlocked */
    633              __HAL_UNLOCK(hdma);
   \                     ??HAL_DMA_PollForTransfer_9: (+1)
   \   000000EE   0x2000             MOVS     R0,#+0
   \   000000F0   0x7038             STRB     R0,[R7, #+0]
   \   000000F2   0xE011             B.N      ??HAL_DMA_PollForTransfer_11
    634            }
    635            else
    636            {
    637              /* Clear the half transfer complete flag */
    638              regs->IFCR = DMA_FLAG_HTIF0_4 << hdma->StreamIndex;
   \                     ??HAL_DMA_PollForTransfer_7: (+1)
   \   000000F4   0x2110             MOVS     R1,#+16
   \   000000F6   0xFA01 0xF000      LSL      R0,R1,R0
   \   000000FA   0x60B0             STR      R0,[R6, #+8]
    639          		
    640              /* Multi_Buffering mode enabled */
    641              if(((hdma->Instance->CR) & (uint32_t)(DMA_SxCR_DBM)) != 0)
   \   000000FC   0x6820             LDR      R0,[R4, #+0]
   \   000000FE   0x6801             LDR      R1,[R0, #+0]
   \   00000100   0x0349             LSLS     R1,R1,#+13
   \   00000102   0xD507             BPL.N    ??HAL_DMA_PollForTransfer_12
    642              {
    643                /* Current memory buffer used is Memory 0 */
    644                if((hdma->Instance->CR & DMA_SxCR_CT) == 0)
   \   00000104   0x6801             LDR      R1,[R0, #+0]
   \   00000106   0x0309             LSLS     R1,R1,#+12
   \   00000108   0xD504             BPL.N    ??HAL_DMA_PollForTransfer_12
    645                {
    646                  /* Change DMA peripheral state */
    647                  hdma->State = HAL_DMA_STATE_READY_HALF_MEM0;
    648                }
    649                /* Current memory buffer used is Memory 1 */
    650                else if((hdma->Instance->CR & DMA_SxCR_CT) != 0)
   \   0000010A   0x6800             LDR      R0,[R0, #+0]
   \   0000010C   0x0300             LSLS     R0,R0,#+12
   \   0000010E   0xD503             BPL.N    ??HAL_DMA_PollForTransfer_11
    651                {
    652                  /* Change DMA peripheral state */
    653                  hdma->State = HAL_DMA_STATE_READY_HALF_MEM1;
   \   00000110   0x2041             MOVS     R0,#+65
   \   00000112   0xE000             B.N      ??HAL_DMA_PollForTransfer_13
    654                }
    655              }
    656              else
    657              {
    658                /* Change DMA peripheral state */
    659                hdma->State = HAL_DMA_STATE_READY_HALF_MEM0;
   \                     ??HAL_DMA_PollForTransfer_12: (+1)
   \   00000114   0x2031             MOVS     R0,#+49
   \                     ??HAL_DMA_PollForTransfer_13: (+1)
   \   00000116   0x7078             STRB     R0,[R7, #+1]
    660              }
    661            }
    662            return HAL_OK;
   \                     ??HAL_DMA_PollForTransfer_11: (+1)
   \   00000118   0x2000             MOVS     R0,#+0
   \   0000011A   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
    663          }
    664          
    665          /**
    666            * @brief  Handles DMA interrupt request.
    667            * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
    668            *               the configuration information for the specified DMA Stream.  
    669            * @retval None
    670            */

   \                                 In section .text, align 2, keep-with-next
    671          void HAL_DMA_IRQHandler(DMA_HandleTypeDef *hdma)
    672          {
   \                     HAL_DMA_IRQHandler: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
    673            /* calculate DMA base and stream number */
    674            DMA_Base_Registers *regs;
    675          
    676            regs = (DMA_Base_Registers *)hdma->StreamBaseAddress;
   \   00000004   0xF104 0x0534      ADD      R5,R4,#+52
    677          	
    678            /* Transfer Error Interrupt management ***************************************/
    679            if ((regs->ISR & (DMA_FLAG_TEIF0_4 << hdma->StreamIndex)) != RESET)
   \   00000008   0x2008             MOVS     R0,#+8
   \   0000000A   0x69EE             LDR      R6,[R5, #+28]
   \   0000000C   0x6831             LDR      R1,[R6, #+0]
   \   0000000E   0x6A2A             LDR      R2,[R5, #+32]
   \   00000010   0xFA00 0xF202      LSL      R2,R0,R2
   \   00000014   0x4211             TST      R1,R2
   \   00000016   0xD017             BEQ.N    ??HAL_DMA_IRQHandler_0
    680            {
    681              if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_TE) != RESET)
   \   00000018   0x6821             LDR      R1,[R4, #+0]
   \   0000001A   0x680A             LDR      R2,[R1, #+0]
   \   0000001C   0x0752             LSLS     R2,R2,#+29
   \   0000001E   0xD513             BPL.N    ??HAL_DMA_IRQHandler_0
    682              {
    683                /* Disable the transfer error interrupt */
    684                __HAL_DMA_DISABLE_IT(hdma, DMA_IT_TE);
   \   00000020   0x680A             LDR      R2,[R1, #+0]
   \   00000022   0xF022 0x0204      BIC      R2,R2,#0x4
   \   00000026   0x600A             STR      R2,[R1, #+0]
    685          
    686                /* Clear the transfer error flag */
    687                regs->IFCR = DMA_FLAG_TEIF0_4 << hdma->StreamIndex;
   \   00000028   0x6A29             LDR      R1,[R5, #+32]
   \   0000002A   0x4088             LSLS     R0,R0,R1
   \   0000002C   0x60B0             STR      R0,[R6, #+8]
    688          
    689                /* Update error code */
    690                hdma->ErrorCode |= HAL_DMA_ERROR_TE;
   \   0000002E   0x69A8             LDR      R0,[R5, #+24]
   \   00000030   0xF040 0x0001      ORR      R0,R0,#0x1
   \   00000034   0x61A8             STR      R0,[R5, #+24]
    691          
    692                /* Change the DMA state */
    693                hdma->State = HAL_DMA_STATE_ERROR;
   \   00000036   0x2004             MOVS     R0,#+4
   \   00000038   0x7068             STRB     R0,[R5, #+1]
    694          
    695                /* Process Unlocked */
    696                __HAL_UNLOCK(hdma); 
   \   0000003A   0x2000             MOVS     R0,#+0
    697          
    698                if(hdma->XferErrorCallback != NULL)
   \   0000003C   0x6969             LDR      R1,[R5, #+20]
   \   0000003E   0x7028             STRB     R0,[R5, #+0]
   \   00000040   0x0008             MOVS     R0,R1
   \   00000042   0xBF1C             ITT      NE 
    699                {
    700                  /* Transfer error callback */
    701                  hdma->XferErrorCallback(hdma);
   \   00000044   0x4620             MOVNE    R0,R4
   \   00000046   0x4788             BLXNE    R1
    702                }
    703              }
    704            }
    705            /* FIFO Error Interrupt management ******************************************/
    706            if ((regs->ISR & (DMA_FLAG_FEIF0_4 << hdma->StreamIndex)) != RESET)
   \                     ??HAL_DMA_IRQHandler_0: (+1)
   \   00000048   0x6831             LDR      R1,[R6, #+0]
   \   0000004A   0x6A2A             LDR      R2,[R5, #+32]
   \   0000004C   0x....             LDR.N    R0,??DataTable3_2  ;; 0x800001
   \   0000004E   0xFA00 0xF202      LSL      R2,R0,R2
   \   00000052   0x4211             TST      R1,R2
   \   00000054   0xD017             BEQ.N    ??HAL_DMA_IRQHandler_1
    707            {
    708              if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_FE) != RESET)
   \   00000056   0x6821             LDR      R1,[R4, #+0]
   \   00000058   0x694A             LDR      R2,[R1, #+20]
   \   0000005A   0x0612             LSLS     R2,R2,#+24
   \   0000005C   0xD513             BPL.N    ??HAL_DMA_IRQHandler_1
    709              {
    710                /* Disable the FIFO Error interrupt */
    711                __HAL_DMA_DISABLE_IT(hdma, DMA_IT_FE);
   \   0000005E   0x694A             LDR      R2,[R1, #+20]
   \   00000060   0xF022 0x0280      BIC      R2,R2,#0x80
   \   00000064   0x614A             STR      R2,[R1, #+20]
    712          
    713                /* Clear the FIFO error flag */
    714                regs->IFCR = DMA_FLAG_FEIF0_4 << hdma->StreamIndex;
   \   00000066   0x6A29             LDR      R1,[R5, #+32]
   \   00000068   0x4088             LSLS     R0,R0,R1
   \   0000006A   0x60B0             STR      R0,[R6, #+8]
    715          
    716                /* Update error code */
    717                hdma->ErrorCode |= HAL_DMA_ERROR_FE;
   \   0000006C   0x69A8             LDR      R0,[R5, #+24]
   \   0000006E   0xF040 0x0002      ORR      R0,R0,#0x2
   \   00000072   0x61A8             STR      R0,[R5, #+24]
    718          
    719                /* Change the DMA state */
    720                hdma->State = HAL_DMA_STATE_ERROR;
   \   00000074   0x2004             MOVS     R0,#+4
   \   00000076   0x7068             STRB     R0,[R5, #+1]
    721          
    722                /* Process Unlocked */
    723                __HAL_UNLOCK(hdma);
   \   00000078   0x2000             MOVS     R0,#+0
    724          
    725                if(hdma->XferErrorCallback != NULL)
   \   0000007A   0x6969             LDR      R1,[R5, #+20]
   \   0000007C   0x7028             STRB     R0,[R5, #+0]
   \   0000007E   0x0008             MOVS     R0,R1
   \   00000080   0xBF1C             ITT      NE 
    726                {
    727                  /* Transfer error callback */
    728                  hdma->XferErrorCallback(hdma);
   \   00000082   0x4620             MOVNE    R0,R4
   \   00000084   0x4788             BLXNE    R1
    729                }
    730              }
    731            }
    732            /* Direct Mode Error Interrupt management ***********************************/
    733            if ((regs->ISR & (DMA_FLAG_DMEIF0_4 << hdma->StreamIndex)) != RESET)
   \                     ??HAL_DMA_IRQHandler_1: (+1)
   \   00000086   0x6831             LDR      R1,[R6, #+0]
   \   00000088   0x6A2A             LDR      R2,[R5, #+32]
   \   0000008A   0x....             LDR.N    R0,??DataTable3_1  ;; 0x800004
   \   0000008C   0xFA00 0xF202      LSL      R2,R0,R2
   \   00000090   0x4211             TST      R1,R2
   \   00000092   0xD017             BEQ.N    ??HAL_DMA_IRQHandler_2
    734            {
    735              if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_DME) != RESET)
   \   00000094   0x6821             LDR      R1,[R4, #+0]
   \   00000096   0x680A             LDR      R2,[R1, #+0]
   \   00000098   0x0792             LSLS     R2,R2,#+30
   \   0000009A   0xD513             BPL.N    ??HAL_DMA_IRQHandler_2
    736              {
    737                /* Disable the direct mode Error interrupt */
    738                __HAL_DMA_DISABLE_IT(hdma, DMA_IT_DME);
   \   0000009C   0x680A             LDR      R2,[R1, #+0]
   \   0000009E   0xF022 0x0202      BIC      R2,R2,#0x2
   \   000000A2   0x600A             STR      R2,[R1, #+0]
    739          
    740                /* Clear the direct mode error flag */
    741                regs->IFCR = DMA_FLAG_DMEIF0_4 << hdma->StreamIndex;
   \   000000A4   0x6A29             LDR      R1,[R5, #+32]
   \   000000A6   0x4088             LSLS     R0,R0,R1
   \   000000A8   0x60B0             STR      R0,[R6, #+8]
    742          
    743                /* Update error code */
    744                hdma->ErrorCode |= HAL_DMA_ERROR_DME;
   \   000000AA   0x69A8             LDR      R0,[R5, #+24]
   \   000000AC   0xF040 0x0004      ORR      R0,R0,#0x4
   \   000000B0   0x61A8             STR      R0,[R5, #+24]
    745          
    746                /* Change the DMA state */
    747                hdma->State = HAL_DMA_STATE_ERROR;
   \   000000B2   0x2004             MOVS     R0,#+4
   \   000000B4   0x7068             STRB     R0,[R5, #+1]
    748          
    749                /* Process Unlocked */
    750                __HAL_UNLOCK(hdma);
   \   000000B6   0x2000             MOVS     R0,#+0
    751          
    752                if(hdma->XferErrorCallback != NULL)
   \   000000B8   0x6969             LDR      R1,[R5, #+20]
   \   000000BA   0x7028             STRB     R0,[R5, #+0]
   \   000000BC   0x0008             MOVS     R0,R1
   \   000000BE   0xBF1C             ITT      NE 
    753                {
    754                  /* Transfer error callback */
    755                  hdma->XferErrorCallback(hdma);
   \   000000C0   0x4620             MOVNE    R0,R4
   \   000000C2   0x4788             BLXNE    R1
   \                     ??HAL_DMA_IRQHandler_2: (+1)
   \   000000C4   0x6A29             LDR      R1,[R5, #+32]
   \   000000C6   0x2010             MOVS     R0,#+16
   \   000000C8   0x6832             LDR      R2,[R6, #+0]
   \   000000CA   0xFA00 0xF101      LSL      R1,R0,R1
   \   000000CE   0x420A             TST      R2,R1
   \   000000D0   0xD021             BEQ.N    ??HAL_DMA_IRQHandler_3
    756                }
    757              }
    758            }
    759            /* Half Transfer Complete Interrupt management ******************************/
    760            if ((regs->ISR & (DMA_FLAG_HTIF0_4 << hdma->StreamIndex)) != RESET)
    761            {
    762              if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_HT) != RESET)
   \   000000D2   0x6822             LDR      R2,[R4, #+0]
   \   000000D4   0x6813             LDR      R3,[R2, #+0]
   \   000000D6   0x071B             LSLS     R3,R3,#+28
   \   000000D8   0xD51D             BPL.N    ??HAL_DMA_IRQHandler_3
    763              { 
    764                /* Multi_Buffering mode enabled */
    765                if(((hdma->Instance->CR) & (uint32_t)(DMA_SxCR_DBM)) != 0)
   \   000000DA   0x6813             LDR      R3,[R2, #+0]
   \   000000DC   0x035B             LSLS     R3,R3,#+13
   \   000000DE   0xD509             BPL.N    ??HAL_DMA_IRQHandler_4
    766                {
    767                  /* Clear the half transfer complete flag */
    768                  regs->IFCR = DMA_FLAG_HTIF0_4 << hdma->StreamIndex;
   \   000000E0   0x60B1             STR      R1,[R6, #+8]
    769          
    770                  /* Current memory buffer used is Memory 0 */
    771                  if((hdma->Instance->CR & DMA_SxCR_CT) == 0)
   \   000000E2   0x6820             LDR      R0,[R4, #+0]
   \   000000E4   0x6801             LDR      R1,[R0, #+0]
   \   000000E6   0x0309             LSLS     R1,R1,#+12
   \   000000E8   0xD50E             BPL.N    ??HAL_DMA_IRQHandler_5
    772                  {
    773                    /* Change DMA peripheral state */
    774                    hdma->State = HAL_DMA_STATE_READY_HALF_MEM0;
    775                  }
    776                  /* Current memory buffer used is Memory 1 */
    777                  else if((hdma->Instance->CR & DMA_SxCR_CT) != 0)
   \   000000EA   0x6800             LDR      R0,[R0, #+0]
   \   000000EC   0x0300             LSLS     R0,R0,#+12
   \   000000EE   0xD50D             BPL.N    ??HAL_DMA_IRQHandler_6
    778                  {
    779                    /* Change DMA peripheral state */
    780                    hdma->State = HAL_DMA_STATE_READY_HALF_MEM1;
   \   000000F0   0x2041             MOVS     R0,#+65
   \   000000F2   0xE00A             B.N      ??HAL_DMA_IRQHandler_7
    781                  }
    782                }
    783                else
    784                {
    785                  /* Disable the half transfer interrupt if the DMA mode is not CIRCULAR */
    786                  if((hdma->Instance->CR & DMA_SxCR_CIRC) == 0)
   \                     ??HAL_DMA_IRQHandler_4: (+1)
   \   000000F4   0x6811             LDR      R1,[R2, #+0]
   \   000000F6   0x05C9             LSLS     R1,R1,#+23
   \   000000F8   0xD403             BMI.N    ??HAL_DMA_IRQHandler_8
    787                  {
    788                    /* Disable the half transfer interrupt */
    789                    __HAL_DMA_DISABLE_IT(hdma, DMA_IT_HT);
   \   000000FA   0x6811             LDR      R1,[R2, #+0]
   \   000000FC   0xF021 0x0108      BIC      R1,R1,#0x8
   \   00000100   0x6011             STR      R1,[R2, #+0]
    790                  }
    791                  /* Clear the half transfer complete flag */
    792                  regs->IFCR = DMA_FLAG_HTIF0_4 << hdma->StreamIndex;
   \                     ??HAL_DMA_IRQHandler_8: (+1)
   \   00000102   0x6A29             LDR      R1,[R5, #+32]
   \   00000104   0x4088             LSLS     R0,R0,R1
   \   00000106   0x60B0             STR      R0,[R6, #+8]
    793          
    794                  /* Change DMA peripheral state */
    795                  hdma->State = HAL_DMA_STATE_READY_HALF_MEM0;
   \                     ??HAL_DMA_IRQHandler_5: (+1)
   \   00000108   0x2031             MOVS     R0,#+49
   \                     ??HAL_DMA_IRQHandler_7: (+1)
   \   0000010A   0x7068             STRB     R0,[R5, #+1]
    796                }
    797          
    798                if(hdma->XferHalfCpltCallback != NULL)
   \                     ??HAL_DMA_IRQHandler_6: (+1)
   \   0000010C   0x68E9             LDR      R1,[R5, #+12]
   \   0000010E   0x0008             MOVS     R0,R1
   \   00000110   0xBF1C             ITT      NE 
    799                {
    800                  /* Half transfer callback */
    801                  hdma->XferHalfCpltCallback(hdma);
   \   00000112   0x4620             MOVNE    R0,R4
   \   00000114   0x4788             BLXNE    R1
   \                     ??HAL_DMA_IRQHandler_3: (+1)
   \   00000116   0x6A29             LDR      R1,[R5, #+32]
   \   00000118   0x2020             MOVS     R0,#+32
   \   0000011A   0x6832             LDR      R2,[R6, #+0]
   \   0000011C   0xFA00 0xF101      LSL      R1,R0,R1
   \   00000120   0x420A             TST      R2,R1
   \   00000122   0xD02D             BEQ.N    ??HAL_DMA_IRQHandler_9
    802                }
    803              }
    804            }
    805            /* Transfer Complete Interrupt management ***********************************/
    806            if ((regs->ISR & (DMA_FLAG_TCIF0_4 << hdma->StreamIndex)) != RESET)
    807            {
    808              if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_TC) != RESET)
   \   00000124   0x6822             LDR      R2,[R4, #+0]
   \   00000126   0x6813             LDR      R3,[R2, #+0]
   \   00000128   0x06DB             LSLS     R3,R3,#+27
   \   0000012A   0xD529             BPL.N    ??HAL_DMA_IRQHandler_9
    809              {
    810                if(((hdma->Instance->CR) & (uint32_t)(DMA_SxCR_DBM)) != 0)
   \   0000012C   0x6813             LDR      R3,[R2, #+0]
   \   0000012E   0x035B             LSLS     R3,R3,#+13
   \   00000130   0xD50F             BPL.N    ??HAL_DMA_IRQHandler_10
    811                {
    812                  /* Clear the transfer complete flag */
    813                  regs->IFCR = DMA_FLAG_TCIF0_4 << hdma->StreamIndex;
   \   00000132   0x60B1             STR      R1,[R6, #+8]
    814          
    815                  /* Current memory buffer used is Memory 1 */
    816                  if((hdma->Instance->CR & DMA_SxCR_CT) == 0)
   \   00000134   0x6820             LDR      R0,[R4, #+0]
   \   00000136   0x6801             LDR      R1,[R0, #+0]
   \   00000138   0x0309             LSLS     R1,R1,#+12
   \   0000013A   0xD406             BMI.N    ??HAL_DMA_IRQHandler_11
    817                  {
    818                    if(hdma->XferM1CpltCallback != NULL)
   \   0000013C   0x6929             LDR      R1,[R5, #+16]
   \   0000013E   0x0008             MOVS     R0,R1
   \   00000140   0xD01E             BEQ.N    ??HAL_DMA_IRQHandler_9
    819                    {
    820                      /* Transfer complete Callback for memory1 */
    821                      hdma->XferM1CpltCallback(hdma);
   \   00000142   0x4620             MOV      R0,R4
   \   00000144   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   00000148   0x4708             BX       R1
    822                    }
    823                  }
    824                  /* Current memory buffer used is Memory 0 */
    825                  else if((hdma->Instance->CR & DMA_SxCR_CT) != 0) 
   \                     ??HAL_DMA_IRQHandler_11: (+1)
   \   0000014A   0x6800             LDR      R0,[R0, #+0]
   \   0000014C   0x0300             LSLS     R0,R0,#+12
   \   0000014E   0xD517             BPL.N    ??HAL_DMA_IRQHandler_9
    826                  {
    827                    if(hdma->XferCpltCallback != NULL)
   \   00000150   0xE00F             B.N      ??HAL_DMA_IRQHandler_12
    828                    {
    829                      /* Transfer complete Callback for memory0 */
    830                      hdma->XferCpltCallback(hdma);
    831                    }
    832                  }
    833                }
    834                /* Disable the transfer complete interrupt if the DMA mode is not CIRCULAR */
    835                else
    836                {
    837                  if((hdma->Instance->CR & DMA_SxCR_CIRC) == 0)
   \                     ??HAL_DMA_IRQHandler_10: (+1)
   \   00000152   0x6811             LDR      R1,[R2, #+0]
   \   00000154   0x05C9             LSLS     R1,R1,#+23
   \   00000156   0xD403             BMI.N    ??HAL_DMA_IRQHandler_13
    838                  {
    839                    /* Disable the transfer complete interrupt */
    840                    __HAL_DMA_DISABLE_IT(hdma, DMA_IT_TC);
   \   00000158   0x6811             LDR      R1,[R2, #+0]
   \   0000015A   0xF021 0x0110      BIC      R1,R1,#0x10
   \   0000015E   0x6011             STR      R1,[R2, #+0]
    841                  }
    842                  /* Clear the transfer complete flag */
    843                  regs->IFCR = DMA_FLAG_TCIF0_4 << hdma->StreamIndex;
   \                     ??HAL_DMA_IRQHandler_13: (+1)
   \   00000160   0x6A29             LDR      R1,[R5, #+32]
   \   00000162   0x4088             LSLS     R0,R0,R1
   \   00000164   0x60B0             STR      R0,[R6, #+8]
    844          
    845                  /* Update error code */
    846                  hdma->ErrorCode |= HAL_DMA_ERROR_NONE;
   \   00000166   0x69A8             LDR      R0,[R5, #+24]
   \   00000168   0x61A8             STR      R0,[R5, #+24]
    847          
    848                  /* Change the DMA state */
    849                  hdma->State = HAL_DMA_STATE_READY_MEM0;
   \   0000016A   0x2011             MOVS     R0,#+17
   \   0000016C   0x7068             STRB     R0,[R5, #+1]
    850          
    851                  /* Process Unlocked */
    852                  __HAL_UNLOCK(hdma);      
   \   0000016E   0x2000             MOVS     R0,#+0
   \   00000170   0x7028             STRB     R0,[R5, #+0]
    853          
    854                  if(hdma->XferCpltCallback != NULL)
   \                     ??HAL_DMA_IRQHandler_12: (+1)
   \   00000172   0x68A9             LDR      R1,[R5, #+8]
   \   00000174   0x0008             MOVS     R0,R1
   \   00000176   0xD003             BEQ.N    ??HAL_DMA_IRQHandler_9
    855                  {
    856                    /* Transfer complete callback */
    857                    hdma->XferCpltCallback(hdma);
   \   00000178   0x4620             MOV      R0,R4
   \   0000017A   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   0000017E   0x4708             BX       R1
    858                  }
    859                }
    860              }
    861            }
    862          }
   \                     ??HAL_DMA_IRQHandler_9: (+1)
   \   00000180   0xBD70             POP      {R4-R6,PC}       ;; return
    863          
    864          
    865          /**
    866            * @}
    867            */
    868          
    869          /** @addtogroup DMA_Exported_Functions_Group3
    870            *
    871          @verbatim
    872           ===============================================================================
    873                              ##### State and Errors functions #####
    874           ===============================================================================
    875              [..]
    876              This subsection provides functions allowing to
    877                (+) Check the DMA state
    878                (+) Get error code
    879          
    880          @endverbatim
    881            * @{
    882            */
    883          
    884          /**
    885            * @brief  Returns the DMA state.
    886            * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
    887            *               the configuration information for the specified DMA Stream.
    888            * @retval HAL state
    889            */

   \                                 In section .text, align 2, keep-with-next
    890          HAL_DMA_StateTypeDef HAL_DMA_GetState(DMA_HandleTypeDef *hdma)
    891          {
    892            return hdma->State;
   \                     HAL_DMA_GetState: (+1)
   \   00000000   0xF890 0x0035      LDRB     R0,[R0, #+53]
   \   00000004   0x4770             BX       LR               ;; return
    893          }
    894          
    895          /**
    896            * @brief  Return the DMA error code
    897            * @param  hdma : pointer to a DMA_HandleTypeDef structure that contains
    898            *              the configuration information for the specified DMA Stream.
    899            * @retval DMA Error Code
    900            */

   \                                 In section .text, align 2, keep-with-next
    901          uint32_t HAL_DMA_GetError(DMA_HandleTypeDef *hdma)
    902          {
    903            return hdma->ErrorCode;
   \                     HAL_DMA_GetError: (+1)
   \   00000000   0x6CC0             LDR      R0,[R0, #+76]
   \   00000002   0x4770             BX       LR               ;; return
    904          }
    905          
    906          /**
    907            * @}
    908            */
    909          
    910          /**
    911            * @brief  Returns the DMA Stream base address depending on stream number
    912            * @param  hdma:       pointer to a DMA_HandleTypeDef structure that contains
    913            *                     the configuration information for the specified DMA Stream. 
    914            * @retval Stream base address
    915            */
    916          static uint32_t DMA_CalcBaseAndBitshift(DMA_HandleTypeDef *hdma)
    917          {
    918            uint32_t stream_number = (((uint32_t)hdma->Instance & 0xFF) - 16) / 24;
    919            
    920            /* lookup table for necessary bitshift of flags within status registers */

   \                                 In section .text, align 4, keep-with-next
    921            static const uint8_t flagBitshiftOffset[8] = {0, 6, 16, 22, 0, 6, 16, 22};
   \                     ??flagBitshiftOffset:
   \   00000000   0x00 0x06          DC8 0, 6, 16, 22, 0, 6, 16, 22
   \              0x10 0x16    
   \              0x00 0x06    
   \              0x10 0x16    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3:
   \   00000000   0xF010803F         DC32     0xf010803f

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_1:
   \   00000000   0x00800004         DC32     0x800004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_2:
   \   00000000   0x00800001         DC32     0x800001
    922            hdma->StreamIndex = flagBitshiftOffset[stream_number];
    923            
    924            if (stream_number > 3)
    925            {
    926              /* return pointer to HISR and HIFCR */
    927              hdma->StreamBaseAddress = (((uint32_t)hdma->Instance & (uint32_t)(~0x3FF)) + 4);
    928            }
    929            else
    930            {
    931              /* return pointer to LISR and LIFCR */
    932              hdma->StreamBaseAddress = ((uint32_t)hdma->Instance & (uint32_t)(~0x3FF));
    933            }
    934            
    935            return hdma->StreamBaseAddress;
    936          }
    937          /**
    938            * @}
    939            */
    940          
    941          #endif /* HAL_DMA_MODULE_ENABLED */
    942          /**
    943            * @}
    944            */
    945          
    946          /**
    947            * @}
    948            */
    949          
    950          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   HAL_DMA_Abort
        16   -> HAL_GetTick
       0   HAL_DMA_DeInit
       0   HAL_DMA_GetError
       0   HAL_DMA_GetState
      16   HAL_DMA_IRQHandler
         0   -- Indirect call
        16   -- Indirect call
       4   HAL_DMA_Init
      40   HAL_DMA_PollForTransfer
        40   -> HAL_GetTick
       8   HAL_DMA_Start
       8   HAL_DMA_Start_IT


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable3
       4  ??DataTable3_1
       4  ??DataTable3_2
      82  HAL_DMA_Abort
     106  HAL_DMA_DeInit
       4  HAL_DMA_GetError
       6  HAL_DMA_GetState
     386  HAL_DMA_IRQHandler
     148  HAL_DMA_Init
     286  HAL_DMA_PollForTransfer
      86  HAL_DMA_Start
     106  HAL_DMA_Start_IT
       8  flagBitshiftOffset

 
 1 230 bytes in section .text
 
 1 230 bytes of CODE memory

Errors: none
Warnings: none
