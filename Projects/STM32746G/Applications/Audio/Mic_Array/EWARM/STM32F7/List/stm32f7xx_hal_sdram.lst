###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.2.10312/W32 for ARM       13/Apr/2016  13:47:33
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_sdram.c
#    Command line =  
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_sdram.c
#        -D USE_HAL_DRIVER -D STM32F746xx -D USE_STM32746G_DISCO -D
#        USE_IOEXPANDER -D USE_USB_FS -lC
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
#        -lA
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
#        -o
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj
#        --no_unroll --debug --endian=little --cpu=Cortex-M7 -e --fpu=VFPv5_sp
#        --dlib_config "D:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Full.h" -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\CMSIS\Device\ST\STM32F7xx\Include\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\STM32F7xx_HAL_Driver\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\STM32746G-Discovery\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\Components\Common\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Log\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Fonts\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\CPU\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_Device_Library\Core\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Core\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Class\MSC\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\drivers\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_Audio\Addons\PDM\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_Device_Library\Class\AUDIO\Inc\
#        -Oh --use_c++_inline --require_prototypes -I "D:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.3\arm\CMSIS\Include\" -D
#        ARM_MATH_CM7 --relaxed_fp
#    List file    =  
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List\stm32f7xx_hal_sdram.lst
#    Object file  =  
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj\stm32f7xx_hal_sdram.o
#
###############################################################################

D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_sdram.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f7xx_hal_sdram.c
      4            * @author  MCD Application Team
      5            * @version V1.0.4
      6            * @date    09-December-2015
      7            * @brief   SDRAM HAL module driver.
      8            *          This file provides a generic firmware to drive SDRAM memories mounted 
      9            *          as external device.
     10            *         
     11            @verbatim
     12            ==============================================================================
     13                                 ##### How to use this driver #####
     14            ============================================================================== 
     15            [..]
     16              This driver is a generic layered driver which contains a set of APIs used to 
     17              control SDRAM memories. It uses the FMC layer functions to interface 
     18              with SDRAM devices.  
     19              The following sequence should be followed to configure the FMC to interface
     20              with SDRAM memories: 
     21                
     22             (#) Declare a SDRAM_HandleTypeDef handle structure, for example:
     23                    SDRAM_HandleTypeDef  hdsram 
     24                    
     25                 (++) Fill the SDRAM_HandleTypeDef handle "Init" field with the allowed 
     26                      values of the structure member.
     27                      
     28                 (++) Fill the SDRAM_HandleTypeDef handle "Instance" field with a predefined 
     29                      base register instance for NOR or SDRAM device 
     30                       
     31             (#) Declare a FMC_SDRAM_TimingTypeDef structure; for example:
     32                    FMC_SDRAM_TimingTypeDef  Timing;
     33                and fill its fields with the allowed values of the structure member.
     34                
     35             (#) Initialize the SDRAM Controller by calling the function HAL_SDRAM_Init(). This function
     36                 performs the following sequence:
     37                    
     38                 (##) MSP hardware layer configuration using the function HAL_SDRAM_MspInit()
     39                 (##) Control register configuration using the FMC SDRAM interface function 
     40                      FMC_SDRAM_Init()
     41                 (##) Timing register configuration using the FMC SDRAM interface function 
     42                      FMC_SDRAM_Timing_Init()
     43                 (##) Program the SDRAM external device by applying its initialization sequence
     44                      according to the device plugged in your hardware. This step is mandatory
     45                      for accessing the SDRAM device.   
     46          
     47             (#) At this stage you can perform read/write accesses from/to the memory connected 
     48                 to the SDRAM Bank. You can perform either polling or DMA transfer using the
     49                 following APIs:
     50                 (++) HAL_SDRAM_Read()/HAL_SDRAM_Write() for polling read/write access
     51                 (++) HAL_SDRAM_Read_DMA()/HAL_SDRAM_Write_DMA() for DMA read/write transfer
     52                 
     53             (#) You can also control the SDRAM device by calling the control APIs HAL_SDRAM_WriteOperation_Enable()/
     54                 HAL_SDRAM_WriteOperation_Disable() to respectively enable/disable the SDRAM write operation or 
     55                 the function HAL_SDRAM_SendCommand() to send a specified command to the SDRAM
     56                 device. The command to be sent must be configured with the FMC_SDRAM_CommandTypeDef 
     57                 structure.   
     58                 
     59             (#) You can continuously monitor the SDRAM device HAL state by calling the function
     60                 HAL_SDRAM_GetState()         
     61                
     62            @endverbatim
     63            ******************************************************************************
     64            * @attention
     65            *
     66            * <h2><center>&copy; COPYRIGHT(c) 2015 STMicroelectronics</center></h2>
     67            *
     68            * Redistribution and use in source and binary forms, with or without modification,
     69            * are permitted provided that the following conditions are met:
     70            *   1. Redistributions of source code must retain the above copyright notice,
     71            *      this list of conditions and the following disclaimer.
     72            *   2. Redistributions in binary form must reproduce the above copyright notice,
     73            *      this list of conditions and the following disclaimer in the documentation
     74            *      and/or other materials provided with the distribution.
     75            *   3. Neither the name of STMicroelectronics nor the names of its contributors
     76            *      may be used to endorse or promote products derived from this software
     77            *      without specific prior written permission.
     78            *
     79            * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
     80            * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     81            * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     82            * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
     83            * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
     84            * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
     85            * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
     86            * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
     87            * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
     88            * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     89            *
     90            ******************************************************************************
     91            */ 
     92          
     93          /* Includes ------------------------------------------------------------------*/
     94          #include "stm32f7xx_hal.h"
     95          
     96          /** @addtogroup STM32F7xx_HAL_Driver
     97            * @{
     98            */
     99          
    100          /** @defgroup SDRAM SDRAM
    101            * @brief SDRAM driver modules
    102            * @{
    103            */
    104          #ifdef HAL_SDRAM_MODULE_ENABLED
    105          
    106          /* Private typedef -----------------------------------------------------------*/
    107          /* Private define ------------------------------------------------------------*/
    108          /* Private macro -------------------------------------------------------------*/    
    109          /* Private variables ---------------------------------------------------------*/
    110          /* Private functions ---------------------------------------------------------*/
    111          /* Exported functions --------------------------------------------------------*/
    112          /** @defgroup SDRAM_Exported_Functions SDRAM Exported Functions
    113            * @{
    114            */
    115          
    116          /** @defgroup SDRAM_Exported_Functions_Group1 Initialization and de-initialization functions 
    117            * @brief    Initialization and Configuration functions 
    118            *
    119            @verbatim    
    120            ==============================================================================
    121                     ##### SDRAM Initialization and de_initialization functions #####
    122            ==============================================================================
    123            [..]  
    124              This section provides functions allowing to initialize/de-initialize
    125              the SDRAM memory
    126            
    127          @endverbatim
    128            * @{
    129            */
    130              
    131          /**
    132            * @brief  Performs the SDRAM device initialization sequence.
    133            * @param  hsdram: pointer to a SDRAM_HandleTypeDef structure that contains
    134            *                the configuration information for SDRAM module.
    135            * @param  Timing: Pointer to SDRAM control timing structure 
    136            * @retval HAL status
    137            */

   \                                 In section .text, align 2, keep-with-next
    138          HAL_StatusTypeDef HAL_SDRAM_Init(SDRAM_HandleTypeDef *hsdram, FMC_SDRAM_TimingTypeDef *Timing)
    139          {   
   \                     HAL_SDRAM_Init: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x460D             MOV      R5,R1
    140            /* Check the SDRAM handle parameter */
    141            if(hsdram == NULL)
   \   00000006   0xD101             BNE.N    ??HAL_SDRAM_Init_0
    142            {
    143              return HAL_ERROR;
   \   00000008   0x2001             MOVS     R0,#+1
   \   0000000A   0xBD70             POP      {R4-R6,PC}
    144            }
    145            
    146            if(hsdram->State == HAL_SDRAM_STATE_RESET)
   \                     ??HAL_SDRAM_Init_0: (+1)
   \   0000000C   0xF104 0x062C      ADD      R6,R4,#+44
   \   00000010   0x7830             LDRB     R0,[R6, #+0]
   \   00000012   0xB918             CBNZ.N   R0,??HAL_SDRAM_Init_1
    147            {  
    148              /* Allocate lock resource and initialize it */
    149              hsdram->Lock = HAL_UNLOCKED;
   \   00000014   0x7070             STRB     R0,[R6, #+1]
    150              /* Initialize the low level hardware (MSP) */
    151              HAL_SDRAM_MspInit(hsdram);
   \   00000016   0x4620             MOV      R0,R4
   \   00000018   0x.... 0x....      BL       HAL_SDRAM_MspInit
    152            }
    153            
    154            /* Initialize the SDRAM controller state */
    155            hsdram->State = HAL_SDRAM_STATE_BUSY;
   \                     ??HAL_SDRAM_Init_1: (+1)
   \   0000001C   0x2002             MOVS     R0,#+2
    156            
    157            /* Initialize SDRAM control Interface */
    158            FMC_SDRAM_Init(hsdram->Instance, &(hsdram->Init));
   \   0000001E   0x1D21             ADDS     R1,R4,#+4
   \   00000020   0x7030             STRB     R0,[R6, #+0]
   \   00000022   0x6820             LDR      R0,[R4, #+0]
   \   00000024   0x.... 0x....      BL       FMC_SDRAM_Init
    159            
    160            /* Initialize SDRAM timing Interface */
    161            FMC_SDRAM_Timing_Init(hsdram->Instance, Timing, hsdram->Init.SDBank); 
   \   00000028   0x6862             LDR      R2,[R4, #+4]
   \   0000002A   0x6820             LDR      R0,[R4, #+0]
   \   0000002C   0x4629             MOV      R1,R5
   \   0000002E   0x.... 0x....      BL       FMC_SDRAM_Timing_Init
    162            
    163            /* Update the SDRAM controller state */
    164            hsdram->State = HAL_SDRAM_STATE_READY;
   \   00000032   0x2001             MOVS     R0,#+1
   \   00000034   0x7030             STRB     R0,[R6, #+0]
    165            
    166            return HAL_OK;
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0xBD70             POP      {R4-R6,PC}       ;; return
    167          }
    168          
    169          /**
    170            * @brief  Perform the SDRAM device initialization sequence.
    171            * @param  hsdram: pointer to a SDRAM_HandleTypeDef structure that contains
    172            *                the configuration information for SDRAM module.
    173            * @retval HAL status
    174            */

   \                                 In section .text, align 2, keep-with-next
    175          HAL_StatusTypeDef HAL_SDRAM_DeInit(SDRAM_HandleTypeDef *hsdram)
    176          {
   \                     HAL_SDRAM_DeInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    177            /* Initialize the low level hardware (MSP) */
    178            HAL_SDRAM_MspDeInit(hsdram);
   \   00000004   0x.... 0x....      BL       HAL_SDRAM_MspDeInit
    179          
    180            /* Configure the SDRAM registers with their reset values */
    181            FMC_SDRAM_DeInit(hsdram->Instance, hsdram->Init.SDBank);
   \   00000008   0x6861             LDR      R1,[R4, #+4]
   \   0000000A   0x6820             LDR      R0,[R4, #+0]
   \   0000000C   0x.... 0x....      BL       FMC_SDRAM_DeInit
    182          
    183            /* Reset the SDRAM controller state */
    184            hsdram->State = HAL_SDRAM_STATE_RESET;
   \   00000010   0xF104 0x002C      ADD      R0,R4,#+44
   \   00000014   0x2100             MOVS     R1,#+0
   \   00000016   0x7001             STRB     R1,[R0, #+0]
    185          
    186            /* Release Lock */
    187            __HAL_UNLOCK(hsdram);
   \   00000018   0x7041             STRB     R1,[R0, #+1]
    188          
    189            return HAL_OK;
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0xBD10             POP      {R4,PC}          ;; return
    190          }
    191          
    192          /**
    193            * @brief  SDRAM MSP Init.
    194            * @param  hsdram: pointer to a SDRAM_HandleTypeDef structure that contains
    195            *                the configuration information for SDRAM module.
    196            * @retval None
    197            */

   \                                 In section .text, align 2, keep-with-next
    198          __weak void HAL_SDRAM_MspInit(SDRAM_HandleTypeDef *hsdram)
    199          {
    200            /* Prevent unused argument(s) compilation warning */
    201            UNUSED(hsdram);
    202           
    203            /* NOTE: This function Should not be modified, when the callback is needed,
    204                      the HAL_SDRAM_MspInit could be implemented in the user file
    205             */ 
    206          }
   \                     HAL_SDRAM_MspInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    207          
    208          /**
    209            * @brief  SDRAM MSP DeInit.
    210            * @param  hsdram: pointer to a SDRAM_HandleTypeDef structure that contains
    211            *                the configuration information for SDRAM module.
    212            * @retval None
    213            */

   \                                 In section .text, align 2, keep-with-next
    214          __weak void HAL_SDRAM_MspDeInit(SDRAM_HandleTypeDef *hsdram)
    215          {
    216            /* Prevent unused argument(s) compilation warning */
    217            UNUSED(hsdram);
    218           
    219            /* NOTE: This function Should not be modified, when the callback is needed,
    220                      the HAL_SDRAM_MspDeInit could be implemented in the user file
    221             */ 
    222          }
   \                     HAL_SDRAM_MspDeInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    223          
    224          /**
    225            * @brief  This function handles SDRAM refresh error interrupt request.
    226            * @param  hsdram: pointer to a SDRAM_HandleTypeDef structure that contains
    227            *                the configuration information for SDRAM module.
    228            * @retval HAL status
    229          */

   \                                 In section .text, align 2, keep-with-next
    230          void HAL_SDRAM_IRQHandler(SDRAM_HandleTypeDef *hsdram)
    231          {
   \                     HAL_SDRAM_IRQHandler: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    232            /* Check SDRAM interrupt Rising edge flag */
    233            if(__FMC_SDRAM_GET_FLAG(hsdram->Instance, FMC_SDRAM_FLAG_REFRESH_IT))
   \   00000004   0x6820             LDR      R0,[R4, #+0]
   \   00000006   0x6980             LDR      R0,[R0, #+24]
   \   00000008   0x07C0             LSLS     R0,R0,#+31
   \   0000000A   0xD507             BPL.N    ??HAL_SDRAM_IRQHandler_0
    234            {
    235              /* SDRAM refresh error interrupt callback */
    236              HAL_SDRAM_RefreshErrorCallback(hsdram);
   \   0000000C   0x4620             MOV      R0,R4
   \   0000000E   0x.... 0x....      BL       HAL_SDRAM_RefreshErrorCallback
    237              
    238              /* Clear SDRAM refresh error interrupt pending bit */
    239              __FMC_SDRAM_CLEAR_FLAG(hsdram->Instance, FMC_SDRAM_FLAG_REFRESH_ERROR);
   \   00000012   0x6820             LDR      R0,[R4, #+0]
   \   00000014   0x6941             LDR      R1,[R0, #+20]
   \   00000016   0xF041 0x0101      ORR      R1,R1,#0x1
   \   0000001A   0x6141             STR      R1,[R0, #+20]
    240            }
    241          }
   \                     ??HAL_SDRAM_IRQHandler_0: (+1)
   \   0000001C   0xBD10             POP      {R4,PC}          ;; return
    242          
    243          /**
    244            * @brief  SDRAM Refresh error callback.
    245            * @param  hsdram: pointer to a SDRAM_HandleTypeDef structure that contains
    246            *                the configuration information for SDRAM module. 
    247            * @retval None
    248            */

   \                                 In section .text, align 2, keep-with-next
    249          __weak void HAL_SDRAM_RefreshErrorCallback(SDRAM_HandleTypeDef *hsdram)
    250          {
    251            /* Prevent unused argument(s) compilation warning */
    252            UNUSED(hsdram);
    253           
    254            /* NOTE: This function Should not be modified, when the callback is needed,
    255                      the HAL_SDRAM_RefreshErrorCallback could be implemented in the user file
    256             */ 
    257          }
   \                     HAL_SDRAM_RefreshErrorCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    258          
    259          /**
    260            * @brief  DMA transfer complete callback.
    261            * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
    262            *                the configuration information for the specified DMA module.
    263            * @retval None
    264            */

   \                                 In section .text, align 2, keep-with-next
    265          __weak void HAL_SDRAM_DMA_XferCpltCallback(DMA_HandleTypeDef *hdma)
    266          {
    267            /* Prevent unused argument(s) compilation warning */
    268            UNUSED(hdma);
    269           
    270            /* NOTE: This function Should not be modified, when the callback is needed,
    271                      the HAL_SDRAM_DMA_XferCpltCallback could be implemented in the user file
    272             */ 
    273          }
   \                     HAL_SDRAM_DMA_XferCpltCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    274          
    275          /**
    276            * @brief  DMA transfer complete error callback.
    277            * @param  hdma: DMA handle
    278            * @retval None
    279            */

   \                                 In section .text, align 2, keep-with-next
    280          __weak void HAL_SDRAM_DMA_XferErrorCallback(DMA_HandleTypeDef *hdma)
    281          {
    282            /* Prevent unused argument(s) compilation warning */
    283            UNUSED(hdma);
    284           
    285            /* NOTE: This function Should not be modified, when the callback is needed,
    286                      the HAL_SDRAM_DMA_XferErrorCallback could be implemented in the user file
    287             */ 
    288          }
   \                     HAL_SDRAM_DMA_XferErrorCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    289          
    290          /**
    291            * @}
    292            */
    293          
    294          /** @defgroup SDRAM_Exported_Functions_Group2 Input and Output functions 
    295            * @brief    Input Output and memory control functions 
    296            *
    297            @verbatim    
    298            ==============================================================================
    299                              ##### SDRAM Input and Output functions #####
    300            ==============================================================================
    301            [..]  
    302              This section provides functions allowing to use and control the SDRAM memory
    303            
    304          @endverbatim
    305            * @{
    306            */
    307          
    308          /**
    309            * @brief  Reads 8-bit data buffer from the SDRAM memory.
    310            * @param  hsdram: pointer to a SDRAM_HandleTypeDef structure that contains
    311            *                the configuration information for SDRAM module.
    312            * @param  pAddress: Pointer to read start address
    313            * @param  pDstBuffer: Pointer to destination buffer  
    314            * @param  BufferSize: Size of the buffer to read from memory
    315            * @retval HAL status
    316            */

   \                                 In section .text, align 2, keep-with-next
    317          HAL_StatusTypeDef HAL_SDRAM_Read_8b(SDRAM_HandleTypeDef *hsdram, uint32_t *pAddress, uint8_t *pDstBuffer, uint32_t BufferSize)
    318          {
    319            __IO uint8_t *pSdramAddress = (uint8_t *)pAddress;
    320            
    321            /* Process Locked */
    322            __HAL_LOCK(hsdram);
   \                     HAL_SDRAM_Read_8b: (+1)
   \   00000000   0x302C             ADDS     R0,R0,#+44
   \   00000002   0xB410             PUSH     {R4}
   \   00000004   0x7844             LDRB     R4,[R0, #+1]
   \   00000006   0x2C01             CMP      R4,#+1
   \   00000008   0xBF1F             ITTTT    NE 
   \   0000000A   0x2401             MOVNE    R4,#+1
   \   0000000C   0x7044             STRBNE   R4,[R0, #+1]
   \   0000000E   0x7804             LDRBNE   R4,[R0, #+0]
   \   00000010   0x2C02             CMPNE    R4,#+2
    323            
    324            /* Check the SDRAM controller state */
    325            if(hsdram->State == HAL_SDRAM_STATE_BUSY)
   \   00000012   0xBF08             IT       EQ 
   \   00000014   0x2002             MOVEQ    R0,#+2
    326            {
    327              return HAL_BUSY;
   \   00000016   0xD00C             BEQ.N    ??HAL_SDRAM_Read_8b_0
    328            }
    329            else if(hsdram->State == HAL_SDRAM_STATE_PRECHARGED)
   \   00000018   0x7804             LDRB     R4,[R0, #+0]
   \   0000001A   0x2C05             CMP      R4,#+5
   \   0000001C   0xD00B             BEQ.N    ??HAL_SDRAM_Read_8b_1
   \   0000001E   0xB12B             CBZ.N    R3,??HAL_SDRAM_Read_8b_2
    330            {
    331              return  HAL_ERROR; 
    332            }  
    333            
    334            /* Read data from source */
    335            for(; BufferSize != 0; BufferSize--)
    336            {
    337              *pDstBuffer = *(__IO uint8_t *)pSdramAddress;  
   \                     ??HAL_SDRAM_Read_8b_3: (+1)
   \   00000020   0xF811 0x4B01      LDRB     R4,[R1], #+1
    338              pDstBuffer++;
    339              pSdramAddress++;
    340            }
   \   00000024   0x1E5B             SUBS     R3,R3,#+1
   \   00000026   0xF802 0x4B01      STRB     R4,[R2], #+1
   \   0000002A   0xD1F9             BNE.N    ??HAL_SDRAM_Read_8b_3
    341            
    342            /* Process Unlocked */
    343            __HAL_UNLOCK(hsdram);
   \                     ??HAL_SDRAM_Read_8b_2: (+1)
   \   0000002C   0x2100             MOVS     R1,#+0
   \   0000002E   0x7041             STRB     R1,[R0, #+1]
    344            
    345            return HAL_OK; 
   \   00000030   0x2000             MOVS     R0,#+0
   \                     ??HAL_SDRAM_Read_8b_0: (+1)
   \   00000032   0xBC10             POP      {R4}
   \   00000034   0x4770             BX       LR               ;; return
   \                     ??HAL_SDRAM_Read_8b_1: (+1)
   \   00000036   0x....             B.N      ?Subroutine0
    346          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \   00000000   0x2001             MOVS     R0,#+1
   \   00000002   0xBC10             POP      {R4}
   \   00000004   0x4770             BX       LR
    347          
    348          
    349          /**
    350            * @brief  Writes 8-bit data buffer to SDRAM memory.
    351            * @param  hsdram: pointer to a SDRAM_HandleTypeDef structure that contains
    352            *                the configuration information for SDRAM module.
    353            * @param  pAddress: Pointer to write start address
    354            * @param  pSrcBuffer: Pointer to source buffer to write  
    355            * @param  BufferSize: Size of the buffer to write to memory
    356            * @retval HAL status
    357            */

   \                                 In section .text, align 2, keep-with-next
    358          HAL_StatusTypeDef HAL_SDRAM_Write_8b(SDRAM_HandleTypeDef *hsdram, uint32_t *pAddress, uint8_t *pSrcBuffer, uint32_t BufferSize)
    359          {
    360            __IO uint8_t *pSdramAddress = (uint8_t *)pAddress;
    361            uint32_t tmp = 0;
    362            
    363            /* Process Locked */
    364            __HAL_LOCK(hsdram);
   \                     HAL_SDRAM_Write_8b: (+1)
   \   00000000   0x302C             ADDS     R0,R0,#+44
   \   00000002   0xB410             PUSH     {R4}
   \   00000004   0x7844             LDRB     R4,[R0, #+1]
   \   00000006   0x2C01             CMP      R4,#+1
   \   00000008   0xBF1F             ITTTT    NE 
   \   0000000A   0x2401             MOVNE    R4,#+1
   \   0000000C   0x7044             STRBNE   R4,[R0, #+1]
   \   0000000E   0x7804             LDRBNE   R4,[R0, #+0]
   \   00000010   0x2C02             CMPNE    R4,#+2
    365            
    366            /* Check the SDRAM controller state */
    367            tmp = hsdram->State;
    368            
    369            if(tmp == HAL_SDRAM_STATE_BUSY)
   \   00000012   0xBF08             IT       EQ 
   \   00000014   0x2002             MOVEQ    R0,#+2
    370            {
    371              return HAL_BUSY;
   \   00000016   0xD00D             BEQ.N    ??HAL_SDRAM_Write_8b_0
    372            }
    373            else if((tmp == HAL_SDRAM_STATE_PRECHARGED) || (tmp == HAL_SDRAM_STATE_WRITE_PROTECTED))
   \   00000018   0x2C05             CMP      R4,#+5
   \   0000001A   0xBF18             IT       NE 
   \   0000001C   0x2C04             CMPNE    R4,#+4
   \   0000001E   0xD00B             BEQ.N    ??HAL_SDRAM_Write_8b_1
   \   00000020   0xB12B             CBZ.N    R3,??HAL_SDRAM_Write_8b_2
    374            {
    375              return  HAL_ERROR; 
    376            }
    377            
    378            /* Write data to memory */
    379            for(; BufferSize != 0; BufferSize--)
    380            {
    381              *(__IO uint8_t *)pSdramAddress = *pSrcBuffer;
   \                     ??HAL_SDRAM_Write_8b_3: (+1)
   \   00000022   0xF812 0x4B01      LDRB     R4,[R2], #+1
    382              pSrcBuffer++;
    383              pSdramAddress++;
    384            }
   \   00000026   0x1E5B             SUBS     R3,R3,#+1
   \   00000028   0xF801 0x4B01      STRB     R4,[R1], #+1
   \   0000002C   0xD1F9             BNE.N    ??HAL_SDRAM_Write_8b_3
    385            
    386            /* Process Unlocked */
    387            __HAL_UNLOCK(hsdram);    
   \                     ??HAL_SDRAM_Write_8b_2: (+1)
   \   0000002E   0x2100             MOVS     R1,#+0
   \   00000030   0x7041             STRB     R1,[R0, #+1]
    388            
    389            return HAL_OK;   
   \   00000032   0x2000             MOVS     R0,#+0
   \                     ??HAL_SDRAM_Write_8b_0: (+1)
   \   00000034   0xBC10             POP      {R4}
   \   00000036   0x4770             BX       LR               ;; return
   \                     ??HAL_SDRAM_Write_8b_1: (+1)
   \   00000038                      REQUIRE ?Subroutine0
   \   00000038                      ;; // Fall through to label ?Subroutine0
    390          }
    391          
    392          
    393          /**
    394            * @brief  Reads 16-bit data buffer from the SDRAM memory. 
    395            * @param  hsdram: pointer to a SDRAM_HandleTypeDef structure that contains
    396            *                the configuration information for SDRAM module.
    397            * @param  pAddress: Pointer to read start address
    398            * @param  pDstBuffer: Pointer to destination buffer  
    399            * @param  BufferSize: Size of the buffer to read from memory
    400            * @retval HAL status
    401            */

   \                                 In section .text, align 2, keep-with-next
    402          HAL_StatusTypeDef HAL_SDRAM_Read_16b(SDRAM_HandleTypeDef *hsdram, uint32_t *pAddress, uint16_t *pDstBuffer, uint32_t BufferSize)
    403          {
    404            __IO uint16_t *pSdramAddress = (uint16_t *)pAddress;
    405            
    406            /* Process Locked */
    407            __HAL_LOCK(hsdram);
   \                     HAL_SDRAM_Read_16b: (+1)
   \   00000000   0x302C             ADDS     R0,R0,#+44
   \   00000002   0xB410             PUSH     {R4}
   \   00000004   0x7844             LDRB     R4,[R0, #+1]
   \   00000006   0x2C01             CMP      R4,#+1
   \   00000008   0xBF1F             ITTTT    NE 
   \   0000000A   0x2401             MOVNE    R4,#+1
   \   0000000C   0x7044             STRBNE   R4,[R0, #+1]
   \   0000000E   0x7804             LDRBNE   R4,[R0, #+0]
   \   00000010   0x2C02             CMPNE    R4,#+2
    408            
    409            /* Check the SDRAM controller state */
    410            if(hsdram->State == HAL_SDRAM_STATE_BUSY)
   \   00000012   0xBF08             IT       EQ 
   \   00000014   0x2002             MOVEQ    R0,#+2
    411            {
    412              return HAL_BUSY;
   \   00000016   0xD00C             BEQ.N    ??HAL_SDRAM_Read_16b_0
    413            }
    414            else if(hsdram->State == HAL_SDRAM_STATE_PRECHARGED)
   \   00000018   0x7804             LDRB     R4,[R0, #+0]
   \   0000001A   0x2C05             CMP      R4,#+5
   \   0000001C   0xD00B             BEQ.N    ??HAL_SDRAM_Read_16b_1
   \   0000001E   0xB12B             CBZ.N    R3,??HAL_SDRAM_Read_16b_2
    415            {
    416              return  HAL_ERROR; 
    417            }  
    418            
    419            /* Read data from source */
    420            for(; BufferSize != 0; BufferSize--)
    421            {
    422              *pDstBuffer = *(__IO uint16_t *)pSdramAddress;  
   \                     ??HAL_SDRAM_Read_16b_3: (+1)
   \   00000020   0xF831 0x4B02      LDRH     R4,[R1], #+2
    423              pDstBuffer++;
    424              pSdramAddress++;               
    425            }
   \   00000024   0x1E5B             SUBS     R3,R3,#+1
   \   00000026   0xF822 0x4B02      STRH     R4,[R2], #+2
   \   0000002A   0xD1F9             BNE.N    ??HAL_SDRAM_Read_16b_3
    426            
    427            /* Process Unlocked */
    428            __HAL_UNLOCK(hsdram);       
   \                     ??HAL_SDRAM_Read_16b_2: (+1)
   \   0000002C   0x2100             MOVS     R1,#+0
   \   0000002E   0x7041             STRB     R1,[R0, #+1]
    429            
    430            return HAL_OK; 
   \   00000030   0x2000             MOVS     R0,#+0
   \                     ??HAL_SDRAM_Read_16b_0: (+1)
   \   00000032   0xBC10             POP      {R4}
   \   00000034   0x4770             BX       LR               ;; return
   \                     ??HAL_SDRAM_Read_16b_1: (+1)
   \   00000036   0x....             B.N      ?Subroutine0
    431          }
    432          
    433          /**
    434            * @brief  Writes 16-bit data buffer to SDRAM memory. 
    435            * @param  hsdram: pointer to a SDRAM_HandleTypeDef structure that contains
    436            *                the configuration information for SDRAM module.
    437            * @param  pAddress: Pointer to write start address
    438            * @param  pSrcBuffer: Pointer to source buffer to write  
    439            * @param  BufferSize: Size of the buffer to write to memory
    440            * @retval HAL status
    441            */

   \                                 In section .text, align 2, keep-with-next
    442          HAL_StatusTypeDef HAL_SDRAM_Write_16b(SDRAM_HandleTypeDef *hsdram, uint32_t *pAddress, uint16_t *pSrcBuffer, uint32_t BufferSize)
    443          {
    444            __IO uint16_t *pSdramAddress = (uint16_t *)pAddress;
    445            uint32_t tmp = 0;
    446            
    447            /* Process Locked */
    448            __HAL_LOCK(hsdram);
   \                     HAL_SDRAM_Write_16b: (+1)
   \   00000000   0x302C             ADDS     R0,R0,#+44
   \   00000002   0xB410             PUSH     {R4}
   \   00000004   0x7844             LDRB     R4,[R0, #+1]
   \   00000006   0x2C01             CMP      R4,#+1
   \   00000008   0xBF1F             ITTTT    NE 
   \   0000000A   0x2401             MOVNE    R4,#+1
   \   0000000C   0x7044             STRBNE   R4,[R0, #+1]
   \   0000000E   0x7804             LDRBNE   R4,[R0, #+0]
   \   00000010   0x2C02             CMPNE    R4,#+2
    449            
    450            /* Check the SDRAM controller state */
    451            tmp = hsdram->State;
    452            
    453            if(tmp == HAL_SDRAM_STATE_BUSY)
   \   00000012   0xBF08             IT       EQ 
   \   00000014   0x2002             MOVEQ    R0,#+2
    454            {
    455              return HAL_BUSY;
   \   00000016   0xD00D             BEQ.N    ??HAL_SDRAM_Write_16b_0
    456            }
    457            else if((tmp == HAL_SDRAM_STATE_PRECHARGED) || (tmp == HAL_SDRAM_STATE_WRITE_PROTECTED))
   \   00000018   0x2C05             CMP      R4,#+5
   \   0000001A   0xBF18             IT       NE 
   \   0000001C   0x2C04             CMPNE    R4,#+4
   \   0000001E   0xD00B             BEQ.N    ??HAL_SDRAM_Write_16b_1
   \   00000020   0xB12B             CBZ.N    R3,??HAL_SDRAM_Write_16b_2
    458            {
    459              return  HAL_ERROR; 
    460            }
    461            
    462            /* Write data to memory */
    463            for(; BufferSize != 0; BufferSize--)
    464            {
    465              *(__IO uint16_t *)pSdramAddress = *pSrcBuffer;
   \                     ??HAL_SDRAM_Write_16b_3: (+1)
   \   00000022   0xF832 0x4B02      LDRH     R4,[R2], #+2
    466              pSrcBuffer++;
    467              pSdramAddress++;            
    468            }
   \   00000026   0x1E5B             SUBS     R3,R3,#+1
   \   00000028   0xF821 0x4B02      STRH     R4,[R1], #+2
   \   0000002C   0xD1F9             BNE.N    ??HAL_SDRAM_Write_16b_3
    469            
    470            /* Process Unlocked */
    471            __HAL_UNLOCK(hsdram);    
   \                     ??HAL_SDRAM_Write_16b_2: (+1)
   \   0000002E   0x2100             MOVS     R1,#+0
   \   00000030   0x7041             STRB     R1,[R0, #+1]
    472            
    473            return HAL_OK;   
   \   00000032   0x2000             MOVS     R0,#+0
   \                     ??HAL_SDRAM_Write_16b_0: (+1)
   \   00000034   0xBC10             POP      {R4}
   \   00000036   0x4770             BX       LR               ;; return
   \                     ??HAL_SDRAM_Write_16b_1: (+1)
   \   00000038   0x....             B.N      ?Subroutine0
    474          }
    475          
    476          /**
    477            * @brief  Reads 32-bit data buffer from the SDRAM memory. 
    478            * @param  hsdram: pointer to a SDRAM_HandleTypeDef structure that contains
    479            *                the configuration information for SDRAM module.
    480            * @param  pAddress: Pointer to read start address
    481            * @param  pDstBuffer: Pointer to destination buffer  
    482            * @param  BufferSize: Size of the buffer to read from memory
    483            * @retval HAL status
    484            */

   \                                 In section .text, align 2, keep-with-next
    485          HAL_StatusTypeDef HAL_SDRAM_Read_32b(SDRAM_HandleTypeDef *hsdram, uint32_t *pAddress, uint32_t *pDstBuffer, uint32_t BufferSize)
    486          {
    487            __IO uint32_t *pSdramAddress = (uint32_t *)pAddress;
    488            
    489            /* Process Locked */
    490            __HAL_LOCK(hsdram);
   \                     HAL_SDRAM_Read_32b: (+1)
   \   00000000   0x302C             ADDS     R0,R0,#+44
   \   00000002   0xB410             PUSH     {R4}
   \   00000004   0x7844             LDRB     R4,[R0, #+1]
   \   00000006   0x2C01             CMP      R4,#+1
   \   00000008   0xBF1F             ITTTT    NE 
   \   0000000A   0x2401             MOVNE    R4,#+1
   \   0000000C   0x7044             STRBNE   R4,[R0, #+1]
   \   0000000E   0x7804             LDRBNE   R4,[R0, #+0]
   \   00000010   0x2C02             CMPNE    R4,#+2
    491            
    492            /* Check the SDRAM controller state */
    493            if(hsdram->State == HAL_SDRAM_STATE_BUSY)
   \   00000012   0xBF08             IT       EQ 
   \   00000014   0x2002             MOVEQ    R0,#+2
    494            {
    495              return HAL_BUSY;
   \   00000016   0xD00C             BEQ.N    ??HAL_SDRAM_Read_32b_0
    496            }
    497            else if(hsdram->State == HAL_SDRAM_STATE_PRECHARGED)
   \   00000018   0x7804             LDRB     R4,[R0, #+0]
   \   0000001A   0x2C05             CMP      R4,#+5
   \   0000001C   0xD00B             BEQ.N    ??HAL_SDRAM_Read_32b_1
   \   0000001E   0xB12B             CBZ.N    R3,??HAL_SDRAM_Read_32b_2
    498            {
    499              return  HAL_ERROR; 
    500            }  
    501            
    502            /* Read data from source */
    503            for(; BufferSize != 0; BufferSize--)
    504            {
    505              *pDstBuffer = *(__IO uint32_t *)pSdramAddress;  
   \                     ??HAL_SDRAM_Read_32b_3: (+1)
   \   00000020   0xF851 0x4B04      LDR      R4,[R1], #+4
    506              pDstBuffer++;
    507              pSdramAddress++;               
    508            }
   \   00000024   0x1E5B             SUBS     R3,R3,#+1
   \   00000026   0xF842 0x4B04      STR      R4,[R2], #+4
   \   0000002A   0xD1F9             BNE.N    ??HAL_SDRAM_Read_32b_3
    509            
    510            /* Process Unlocked */
    511            __HAL_UNLOCK(hsdram);       
   \                     ??HAL_SDRAM_Read_32b_2: (+1)
   \   0000002C   0x2100             MOVS     R1,#+0
   \   0000002E   0x7041             STRB     R1,[R0, #+1]
    512            
    513            return HAL_OK; 
   \   00000030   0x2000             MOVS     R0,#+0
   \                     ??HAL_SDRAM_Read_32b_0: (+1)
   \   00000032   0xBC10             POP      {R4}
   \   00000034   0x4770             BX       LR               ;; return
   \                     ??HAL_SDRAM_Read_32b_1: (+1)
   \   00000036   0x....             B.N      ?Subroutine0
    514          }
    515          
    516          /**
    517            * @brief  Writes 32-bit data buffer to SDRAM memory. 
    518            * @param  hsdram: pointer to a SDRAM_HandleTypeDef structure that contains
    519            *                the configuration information for SDRAM module.
    520            * @param  pAddress: Pointer to write start address
    521            * @param  pSrcBuffer: Pointer to source buffer to write  
    522            * @param  BufferSize: Size of the buffer to write to memory
    523            * @retval HAL status
    524            */

   \                                 In section .text, align 2, keep-with-next
    525          HAL_StatusTypeDef HAL_SDRAM_Write_32b(SDRAM_HandleTypeDef *hsdram, uint32_t *pAddress, uint32_t *pSrcBuffer, uint32_t BufferSize)
    526          {
    527            __IO uint32_t *pSdramAddress = (uint32_t *)pAddress;
    528            uint32_t tmp = 0;
    529            
    530            /* Process Locked */
    531            __HAL_LOCK(hsdram);
   \                     HAL_SDRAM_Write_32b: (+1)
   \   00000000   0x302C             ADDS     R0,R0,#+44
   \   00000002   0xB410             PUSH     {R4}
   \   00000004   0x7844             LDRB     R4,[R0, #+1]
   \   00000006   0x2C01             CMP      R4,#+1
   \   00000008   0xBF1F             ITTTT    NE 
   \   0000000A   0x2401             MOVNE    R4,#+1
   \   0000000C   0x7044             STRBNE   R4,[R0, #+1]
   \   0000000E   0x7804             LDRBNE   R4,[R0, #+0]
   \   00000010   0x2C02             CMPNE    R4,#+2
    532            
    533            /* Check the SDRAM controller state */
    534            tmp = hsdram->State;
    535            
    536            if(tmp == HAL_SDRAM_STATE_BUSY)
   \   00000012   0xBF08             IT       EQ 
   \   00000014   0x2002             MOVEQ    R0,#+2
    537            {
    538              return HAL_BUSY;
   \   00000016   0xD00D             BEQ.N    ??HAL_SDRAM_Write_32b_0
    539            }
    540            else if((tmp == HAL_SDRAM_STATE_PRECHARGED) || (tmp == HAL_SDRAM_STATE_WRITE_PROTECTED))
   \   00000018   0x2C05             CMP      R4,#+5
   \   0000001A   0xBF18             IT       NE 
   \   0000001C   0x2C04             CMPNE    R4,#+4
   \   0000001E   0xD00B             BEQ.N    ??HAL_SDRAM_Write_32b_1
   \   00000020   0xB12B             CBZ.N    R3,??HAL_SDRAM_Write_32b_2
    541            {
    542              return  HAL_ERROR; 
    543            }
    544            
    545            /* Write data to memory */
    546            for(; BufferSize != 0; BufferSize--)
    547            {
    548              *(__IO uint32_t *)pSdramAddress = *pSrcBuffer;
   \                     ??HAL_SDRAM_Write_32b_3: (+1)
   \   00000022   0xF852 0x4B04      LDR      R4,[R2], #+4
    549              pSrcBuffer++;
    550              pSdramAddress++;          
    551            }
   \   00000026   0x1E5B             SUBS     R3,R3,#+1
   \   00000028   0xF841 0x4B04      STR      R4,[R1], #+4
   \   0000002C   0xD1F9             BNE.N    ??HAL_SDRAM_Write_32b_3
    552            
    553            /* Process Unlocked */
    554            __HAL_UNLOCK(hsdram);    
   \                     ??HAL_SDRAM_Write_32b_2: (+1)
   \   0000002E   0x2100             MOVS     R1,#+0
   \   00000030   0x7041             STRB     R1,[R0, #+1]
    555            
    556            return HAL_OK;  
   \   00000032   0x2000             MOVS     R0,#+0
   \                     ??HAL_SDRAM_Write_32b_0: (+1)
   \   00000034   0xBC10             POP      {R4}
   \   00000036   0x4770             BX       LR               ;; return
   \                     ??HAL_SDRAM_Write_32b_1: (+1)
   \   00000038   0x....             B.N      ?Subroutine0
    557          }
    558          
    559          /**
    560            * @brief  Reads a Words data from the SDRAM memory using DMA transfer. 
    561            * @param  hsdram: pointer to a SDRAM_HandleTypeDef structure that contains
    562            *                the configuration information for SDRAM module.
    563            * @param  pAddress: Pointer to read start address
    564            * @param  pDstBuffer: Pointer to destination buffer  
    565            * @param  BufferSize: Size of the buffer to read from memory
    566            * @retval HAL status
    567            */

   \                                 In section .text, align 2, keep-with-next
    568          HAL_StatusTypeDef HAL_SDRAM_Read_DMA(SDRAM_HandleTypeDef *hsdram, uint32_t *pAddress, uint32_t *pDstBuffer, uint32_t BufferSize)
    569          {
   \                     HAL_SDRAM_Read_DMA: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    570            uint32_t tmp = 0;
    571              
    572            /* Process Locked */
    573            __HAL_LOCK(hsdram);
   \   00000002   0xF100 0x042C      ADD      R4,R0,#+44
   \   00000006   0x7860             LDRB     R0,[R4, #+1]
   \   00000008   0x2801             CMP      R0,#+1
   \   0000000A   0xBF1F             ITTTT    NE 
   \   0000000C   0x2001             MOVNE    R0,#+1
   \   0000000E   0x7060             STRBNE   R0,[R4, #+1]
   \   00000010   0x7820             LDRBNE   R0,[R4, #+0]
   \   00000012   0x2802             CMPNE    R0,#+2
    574            
    575            /* Check the SDRAM controller state */  
    576            tmp = hsdram->State;
    577            
    578            if(tmp == HAL_SDRAM_STATE_BUSY)
   \   00000014   0xD101             BNE.N    ??HAL_SDRAM_Read_DMA_0
    579            {
    580              return HAL_BUSY;
   \   00000016   0x2002             MOVS     R0,#+2
   \   00000018   0xBD32             POP      {R1,R4,R5,PC}
    581            }
    582            else if(tmp == HAL_SDRAM_STATE_PRECHARGED)
   \                     ??HAL_SDRAM_Read_DMA_0: (+1)
   \   0000001A   0x2805             CMP      R0,#+5
   \   0000001C   0xD101             BNE.N    ??HAL_SDRAM_Read_DMA_1
    583            {
    584              return  HAL_ERROR; 
   \   0000001E   0x2001             MOVS     R0,#+1
   \   00000020   0xBD32             POP      {R1,R4,R5,PC}
    585            }  
    586            
    587            /* Configure DMA user callbacks */
    588            hsdram->hdma->XferCpltCallback  = HAL_SDRAM_DMA_XferCpltCallback;
   \                     ??HAL_SDRAM_Read_DMA_1: (+1)
   \   00000022   0x6865             LDR      R5,[R4, #+4]
   \   00000024   0x....             LDR.N    R0,??DataTable1
   \   00000026   0x63E8             STR      R0,[R5, #+60]
    589            hsdram->hdma->XferErrorCallback = HAL_SDRAM_DMA_XferErrorCallback;
   \   00000028   0x6865             LDR      R5,[R4, #+4]
   \   0000002A   0x....             LDR.N    R0,??DataTable1_1
   \   0000002C   0x64A8             STR      R0,[R5, #+72]
    590            
    591            /* Enable the DMA Stream */
    592            HAL_DMA_Start_IT(hsdram->hdma, (uint32_t)pAddress, (uint32_t)pDstBuffer, (uint32_t)BufferSize);
   \   0000002E   0x6860             LDR      R0,[R4, #+4]
   \   00000030   0x.... 0x....      BL       HAL_DMA_Start_IT
    593            
    594            /* Process Unlocked */
    595            __HAL_UNLOCK(hsdram);  
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0x7060             STRB     R0,[R4, #+1]
    596            
    597            return HAL_OK; 
   \   00000038   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    598          }
    599          
    600          /**
    601            * @brief  Writes a Words data buffer to SDRAM memory using DMA transfer.
    602            * @param  hsdram: pointer to a SDRAM_HandleTypeDef structure that contains
    603            *                the configuration information for SDRAM module.
    604            * @param  pAddress: Pointer to write start address
    605            * @param  pSrcBuffer: Pointer to source buffer to write  
    606            * @param  BufferSize: Size of the buffer to write to memory
    607            * @retval HAL status
    608            */

   \                                 In section .text, align 2, keep-with-next
    609          HAL_StatusTypeDef HAL_SDRAM_Write_DMA(SDRAM_HandleTypeDef *hsdram, uint32_t *pAddress, uint32_t *pSrcBuffer, uint32_t BufferSize)
    610          {
   \                     HAL_SDRAM_Write_DMA: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    611            uint32_t tmp = 0;
    612            
    613            /* Process Locked */
    614            __HAL_LOCK(hsdram);
   \   00000002   0xF100 0x052C      ADD      R5,R0,#+44
   \   00000006   0x4614             MOV      R4,R2
   \   00000008   0x7868             LDRB     R0,[R5, #+1]
   \   0000000A   0x2801             CMP      R0,#+1
   \   0000000C   0xBF1F             ITTTT    NE 
   \   0000000E   0x2001             MOVNE    R0,#+1
   \   00000010   0x7068             STRBNE   R0,[R5, #+1]
   \   00000012   0x7828             LDRBNE   R0,[R5, #+0]
   \   00000014   0x2802             CMPNE    R0,#+2
    615            
    616            /* Check the SDRAM controller state */  
    617            tmp = hsdram->State;
    618            
    619            if(tmp == HAL_SDRAM_STATE_BUSY)
   \   00000016   0xD101             BNE.N    ??HAL_SDRAM_Write_DMA_0
    620            {
    621              return HAL_BUSY;
   \   00000018   0x2002             MOVS     R0,#+2
   \   0000001A   0xBD32             POP      {R1,R4,R5,PC}
    622            }
    623            else if((tmp == HAL_SDRAM_STATE_PRECHARGED) || (tmp == HAL_SDRAM_STATE_WRITE_PROTECTED))
   \                     ??HAL_SDRAM_Write_DMA_0: (+1)
   \   0000001C   0x2805             CMP      R0,#+5
   \   0000001E   0xBF18             IT       NE 
   \   00000020   0x2804             CMPNE    R0,#+4
   \   00000022   0xD101             BNE.N    ??HAL_SDRAM_Write_DMA_1
    624            {
    625              return  HAL_ERROR; 
   \   00000024   0x2001             MOVS     R0,#+1
   \   00000026   0xBD32             POP      {R1,R4,R5,PC}
    626            }  
    627            
    628            /* Configure DMA user callbacks */
    629            hsdram->hdma->XferCpltCallback  = HAL_SDRAM_DMA_XferCpltCallback;
   \                     ??HAL_SDRAM_Write_DMA_1: (+1)
   \   00000028   0x686A             LDR      R2,[R5, #+4]
   \   0000002A   0x....             LDR.N    R0,??DataTable1
   \   0000002C   0x63D0             STR      R0,[R2, #+60]
    630            hsdram->hdma->XferErrorCallback = HAL_SDRAM_DMA_XferErrorCallback;
   \   0000002E   0x686A             LDR      R2,[R5, #+4]
   \   00000030   0x....             LDR.N    R0,??DataTable1_1
   \   00000032   0x6490             STR      R0,[R2, #+72]
    631            
    632            /* Enable the DMA Stream */
    633            HAL_DMA_Start_IT(hsdram->hdma, (uint32_t)pSrcBuffer, (uint32_t)pAddress, (uint32_t)BufferSize);
   \   00000034   0x460A             MOV      R2,R1
   \   00000036   0x6868             LDR      R0,[R5, #+4]
   \   00000038   0x4621             MOV      R1,R4
   \   0000003A   0x.... 0x....      BL       HAL_DMA_Start_IT
    634            
    635            /* Process Unlocked */
    636            __HAL_UNLOCK(hsdram);
   \   0000003E   0x2000             MOVS     R0,#+0
   \   00000040   0x7068             STRB     R0,[R5, #+1]
    637            
    638            return HAL_OK;
   \   00000042   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    639          }
    640          
    641          /**
    642            * @}
    643            */
    644            
    645          /** @defgroup SDRAM_Exported_Functions_Group3 Control functions 
    646           *  @brief   management functions 
    647           *
    648          @verbatim   
    649            ==============================================================================
    650                                   ##### SDRAM Control functions #####
    651            ==============================================================================  
    652            [..]
    653              This subsection provides a set of functions allowing to control dynamically
    654              the SDRAM interface.
    655          
    656          @endverbatim
    657            * @{
    658            */
    659          
    660          /**
    661            * @brief  Enables dynamically SDRAM write protection.
    662            * @param  hsdram: pointer to a SDRAM_HandleTypeDef structure that contains
    663            *                the configuration information for SDRAM module.
    664            * @retval HAL status
    665            */

   \                                 In section .text, align 2, keep-with-next
    666          HAL_StatusTypeDef HAL_SDRAM_WriteProtection_Enable(SDRAM_HandleTypeDef *hsdram)
    667          { 
   \                     HAL_SDRAM_WriteProtection_Enable: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    668            /* Check the SDRAM controller state */ 
    669            if(hsdram->State == HAL_SDRAM_STATE_BUSY)
   \   00000004   0xF894 0x002C      LDRB     R0,[R4, #+44]
   \   00000008   0x2802             CMP      R0,#+2
   \   0000000A   0xD00A             BEQ.N    ??HAL_SDRAM_WriteProtection_Enable_0
    670            {
    671              return HAL_BUSY;
    672            }
    673            
    674            /* Update the SDRAM state */
    675            hsdram->State = HAL_SDRAM_STATE_BUSY;
   \   0000000C   0x2002             MOVS     R0,#+2
   \   0000000E   0xF884 0x002C      STRB     R0,[R4, #+44]
    676            
    677            /* Enable write protection */
    678            FMC_SDRAM_WriteProtection_Enable(hsdram->Instance, hsdram->Init.SDBank);
   \   00000012   0x6861             LDR      R1,[R4, #+4]
   \   00000014   0x6820             LDR      R0,[R4, #+0]
   \   00000016   0x.... 0x....      BL       FMC_SDRAM_WriteProtection_Enable
    679            
    680            /* Update the SDRAM state */
    681            hsdram->State = HAL_SDRAM_STATE_WRITE_PROTECTED;
   \   0000001A   0x2004             MOVS     R0,#+4
   \   0000001C   0xF884 0x002C      STRB     R0,[R4, #+44]
    682            
    683            return HAL_OK;  
   \   00000020   0x2000             MOVS     R0,#+0
   \                     ??HAL_SDRAM_WriteProtection_Enable_0: (+1)
   \   00000022   0xBD10             POP      {R4,PC}          ;; return
    684          }
    685          
    686          /**
    687            * @brief  Disables dynamically SDRAM write protection.
    688            * @param  hsdram: pointer to a SDRAM_HandleTypeDef structure that contains
    689            *                the configuration information for SDRAM module.
    690            * @retval HAL status
    691            */

   \                                 In section .text, align 2, keep-with-next
    692          HAL_StatusTypeDef HAL_SDRAM_WriteProtection_Disable(SDRAM_HandleTypeDef *hsdram)
    693          {
   \                     HAL_SDRAM_WriteProtection_Disable: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    694            /* Check the SDRAM controller state */
    695            if(hsdram->State == HAL_SDRAM_STATE_BUSY)
   \   00000004   0xF894 0x002C      LDRB     R0,[R4, #+44]
   \   00000008   0x2802             CMP      R0,#+2
   \   0000000A   0xD00A             BEQ.N    ??HAL_SDRAM_WriteProtection_Disable_0
    696            {
    697              return HAL_BUSY;
    698            }
    699            
    700            /* Update the SDRAM state */
    701            hsdram->State = HAL_SDRAM_STATE_BUSY;
   \   0000000C   0x2002             MOVS     R0,#+2
   \   0000000E   0xF884 0x002C      STRB     R0,[R4, #+44]
    702            
    703            /* Disable write protection */
    704            FMC_SDRAM_WriteProtection_Disable(hsdram->Instance, hsdram->Init.SDBank);
   \   00000012   0x6861             LDR      R1,[R4, #+4]
   \   00000014   0x6820             LDR      R0,[R4, #+0]
   \   00000016   0x.... 0x....      BL       FMC_SDRAM_WriteProtection_Disable
    705            
    706            /* Update the SDRAM state */
    707            hsdram->State = HAL_SDRAM_STATE_READY;
   \   0000001A   0x2001             MOVS     R0,#+1
   \   0000001C   0xF884 0x002C      STRB     R0,[R4, #+44]
    708            
    709            return HAL_OK;
   \   00000020   0x2000             MOVS     R0,#+0
   \                     ??HAL_SDRAM_WriteProtection_Disable_0: (+1)
   \   00000022   0xBD10             POP      {R4,PC}          ;; return
    710          }
    711          
    712          /**
    713            * @brief  Sends Command to the SDRAM bank.
    714            * @param  hsdram: pointer to a SDRAM_HandleTypeDef structure that contains
    715            *                the configuration information for SDRAM module.
    716            * @param  Command: SDRAM command structure
    717            * @param  Timeout: Timeout duration
    718            * @retval HAL status
    719            */  

   \                                 In section .text, align 2, keep-with-next
    720          HAL_StatusTypeDef HAL_SDRAM_SendCommand(SDRAM_HandleTypeDef *hsdram, FMC_SDRAM_CommandTypeDef *Command, uint32_t Timeout)
    721          {
   \                     HAL_SDRAM_SendCommand: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    722            /* Check the SDRAM controller state */
    723            if(hsdram->State == HAL_SDRAM_STATE_BUSY)
   \   00000006   0xF894 0x002C      LDRB     R0,[R4, #+44]
   \   0000000A   0x2802             CMP      R0,#+2
   \   0000000C   0xD00D             BEQ.N    ??HAL_SDRAM_SendCommand_0
    724            {
    725              return HAL_BUSY;
    726            }
    727            
    728            /* Update the SDRAM state */
    729            hsdram->State = HAL_SDRAM_STATE_BUSY;
   \   0000000E   0x2002             MOVS     R0,#+2
   \   00000010   0xF884 0x002C      STRB     R0,[R4, #+44]
    730            
    731            /* Send SDRAM command */
    732            FMC_SDRAM_SendCommand(hsdram->Instance, Command, Timeout);
   \   00000014   0x6820             LDR      R0,[R4, #+0]
   \   00000016   0x.... 0x....      BL       FMC_SDRAM_SendCommand
    733            
    734            /* Update the SDRAM controller state state */
    735            if(Command->CommandMode == FMC_SDRAM_CMD_PALL)
   \   0000001A   0x6828             LDR      R0,[R5, #+0]
   \   0000001C   0x2802             CMP      R0,#+2
   \   0000001E   0xBF0C             ITE      EQ 
   \   00000020   0x2005             MOVEQ    R0,#+5
   \   00000022   0x2001             MOVNE    R0,#+1
    736            {
    737              hsdram->State = HAL_SDRAM_STATE_PRECHARGED;
    738            }
    739            else
    740            {
    741              hsdram->State = HAL_SDRAM_STATE_READY;
   \   00000024   0xF884 0x002C      STRB     R0,[R4, #+44]
    742            }
    743            
    744            return HAL_OK;  
   \   00000028   0x2000             MOVS     R0,#+0
   \                     ??HAL_SDRAM_SendCommand_0: (+1)
   \   0000002A   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    745          }
    746          
    747          /**
    748            * @brief  Programs the SDRAM Memory Refresh rate.
    749            * @param  hsdram: pointer to a SDRAM_HandleTypeDef structure that contains
    750            *                the configuration information for SDRAM module.  
    751            * @param  RefreshRate: The SDRAM refresh rate value       
    752            * @retval HAL status
    753            */

   \                                 In section .text, align 2, keep-with-next
    754          HAL_StatusTypeDef HAL_SDRAM_ProgramRefreshRate(SDRAM_HandleTypeDef *hsdram, uint32_t RefreshRate)
    755          {
   \                     HAL_SDRAM_ProgramRefreshRate: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    756            /* Check the SDRAM controller state */
    757            if(hsdram->State == HAL_SDRAM_STATE_BUSY)
   \   00000004   0xF894 0x002C      LDRB     R0,[R4, #+44]
   \   00000008   0x2802             CMP      R0,#+2
   \   0000000A   0xD009             BEQ.N    ??HAL_SDRAM_ProgramRefreshRate_0
    758            {
    759              return HAL_BUSY;
    760            } 
    761            
    762            /* Update the SDRAM state */
    763            hsdram->State = HAL_SDRAM_STATE_BUSY;
   \   0000000C   0x2002             MOVS     R0,#+2
   \   0000000E   0xF884 0x002C      STRB     R0,[R4, #+44]
    764            
    765            /* Program the refresh rate */
    766            FMC_SDRAM_ProgramRefreshRate(hsdram->Instance ,RefreshRate);
   \   00000012   0x6820             LDR      R0,[R4, #+0]
   \   00000014   0x.... 0x....      BL       FMC_SDRAM_ProgramRefreshRate
    767            
    768            /* Update the SDRAM state */
    769            hsdram->State = HAL_SDRAM_STATE_READY;
   \   00000018   0x2001             MOVS     R0,#+1
   \   0000001A   0xF884 0x002C      STRB     R0,[R4, #+44]
    770            
    771            return HAL_OK;   
   \   0000001E   0x2000             MOVS     R0,#+0
   \                     ??HAL_SDRAM_ProgramRefreshRate_0: (+1)
   \   00000020   0xBD10             POP      {R4,PC}          ;; return
    772          }
    773          
    774          /**
    775            * @brief  Sets the Number of consecutive SDRAM Memory auto Refresh commands.
    776            * @param  hsdram: pointer to a SDRAM_HandleTypeDef structure that contains
    777            *                the configuration information for SDRAM module.  
    778            * @param  AutoRefreshNumber: The SDRAM auto Refresh number       
    779            * @retval HAL status
    780            */

   \                                 In section .text, align 2, keep-with-next
    781          HAL_StatusTypeDef HAL_SDRAM_SetAutoRefreshNumber(SDRAM_HandleTypeDef *hsdram, uint32_t AutoRefreshNumber)
    782          {
   \                     HAL_SDRAM_SetAutoRefreshNumber: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    783            /* Check the SDRAM controller state */
    784            if(hsdram->State == HAL_SDRAM_STATE_BUSY)
   \   00000004   0xF894 0x002C      LDRB     R0,[R4, #+44]
   \   00000008   0x2802             CMP      R0,#+2
   \   0000000A   0xD009             BEQ.N    ??HAL_SDRAM_SetAutoRefreshNumber_0
    785            {
    786              return HAL_BUSY;
    787            } 
    788            
    789            /* Update the SDRAM state */
    790            hsdram->State = HAL_SDRAM_STATE_BUSY;
   \   0000000C   0x2002             MOVS     R0,#+2
   \   0000000E   0xF884 0x002C      STRB     R0,[R4, #+44]
    791            
    792            /* Set the Auto-Refresh number */
    793            FMC_SDRAM_SetAutoRefreshNumber(hsdram->Instance ,AutoRefreshNumber);
   \   00000012   0x6820             LDR      R0,[R4, #+0]
   \   00000014   0x.... 0x....      BL       FMC_SDRAM_SetAutoRefreshNumber
    794            
    795            /* Update the SDRAM state */
    796            hsdram->State = HAL_SDRAM_STATE_READY;
   \   00000018   0x2001             MOVS     R0,#+1
   \   0000001A   0xF884 0x002C      STRB     R0,[R4, #+44]
    797            
    798            return HAL_OK;
   \   0000001E   0x2000             MOVS     R0,#+0
   \                     ??HAL_SDRAM_SetAutoRefreshNumber_0: (+1)
   \   00000020   0xBD10             POP      {R4,PC}          ;; return
    799          }
    800          
    801          /**
    802            * @brief  Returns the SDRAM memory current mode.
    803            * @param  hsdram: pointer to a SDRAM_HandleTypeDef structure that contains
    804            *                the configuration information for SDRAM module.
    805            * @retval The SDRAM memory mode.        
    806            */

   \                                 In section .text, align 2, keep-with-next
    807          uint32_t HAL_SDRAM_GetModeStatus(SDRAM_HandleTypeDef *hsdram)
    808          {
    809            /* Return the SDRAM memory current mode */
    810            return(FMC_SDRAM_GetModeStatus(hsdram->Instance, hsdram->Init.SDBank));
   \                     HAL_SDRAM_GetModeStatus: (+1)
   \   00000000   0x6841             LDR      R1,[R0, #+4]
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x.... 0x....      B.W      FMC_SDRAM_GetModeStatus
    811          }
    812          
    813          /**
    814            * @}
    815            */
    816            
    817          /** @defgroup SDRAM_Exported_Functions_Group4 State functions 
    818           *  @brief   Peripheral State functions 
    819           *
    820          @verbatim   
    821            ==============================================================================
    822                                ##### SDRAM State functions #####
    823            ==============================================================================  
    824            [..]
    825              This subsection permits to get in run-time the status of the SDRAM controller 
    826              and the data flow.
    827          
    828          @endverbatim
    829            * @{
    830            */
    831          
    832          /**
    833            * @brief  Returns the SDRAM state.
    834            * @param  hsdram: pointer to a SDRAM_HandleTypeDef structure that contains
    835            *                the configuration information for SDRAM module.
    836            * @retval HAL state
    837            */

   \                                 In section .text, align 2, keep-with-next
    838          HAL_SDRAM_StateTypeDef HAL_SDRAM_GetState(SDRAM_HandleTypeDef *hsdram)
    839          {
    840            return hsdram->State;
   \                     HAL_SDRAM_GetState: (+1)
   \   00000000   0xF890 0x002C      LDRB     R0,[R0, #+44]
   \   00000004   0x4770             BX       LR               ;; return
    841          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1:
   \   00000000   0x........         DC32     HAL_SDRAM_DMA_XferCpltCallback

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_1:
   \   00000000   0x........         DC32     HAL_SDRAM_DMA_XferErrorCallback
    842          
    843          /**
    844            * @}
    845            */    
    846          
    847          /**
    848            * @}
    849            */
    850          #endif /* HAL_SDRAM_MODULE_ENABLED */
    851          /**
    852            * @}
    853            */
    854          
    855          /**
    856            * @}
    857            */
    858          
    859          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   HAL_SDRAM_DMA_XferCpltCallback
       0   HAL_SDRAM_DMA_XferErrorCallback
       8   HAL_SDRAM_DeInit
         8   -> FMC_SDRAM_DeInit
         8   -> HAL_SDRAM_MspDeInit
       0   HAL_SDRAM_GetModeStatus
         0   -> FMC_SDRAM_GetModeStatus
       0   HAL_SDRAM_GetState
       8   HAL_SDRAM_IRQHandler
         8   -> HAL_SDRAM_RefreshErrorCallback
      16   HAL_SDRAM_Init
        16   -> FMC_SDRAM_Init
        16   -> FMC_SDRAM_Timing_Init
        16   -> HAL_SDRAM_MspInit
       0   HAL_SDRAM_MspDeInit
       0   HAL_SDRAM_MspInit
       8   HAL_SDRAM_ProgramRefreshRate
         8   -> FMC_SDRAM_ProgramRefreshRate
       4   HAL_SDRAM_Read_16b
       4   HAL_SDRAM_Read_32b
       4   HAL_SDRAM_Read_8b
      16   HAL_SDRAM_Read_DMA
        16   -> HAL_DMA_Start_IT
       0   HAL_SDRAM_RefreshErrorCallback
      16   HAL_SDRAM_SendCommand
        16   -> FMC_SDRAM_SendCommand
       8   HAL_SDRAM_SetAutoRefreshNumber
         8   -> FMC_SDRAM_SetAutoRefreshNumber
       8   HAL_SDRAM_WriteProtection_Disable
         8   -> FMC_SDRAM_WriteProtection_Disable
       8   HAL_SDRAM_WriteProtection_Enable
         8   -> FMC_SDRAM_WriteProtection_Enable
       4   HAL_SDRAM_Write_16b
       4   HAL_SDRAM_Write_32b
       4   HAL_SDRAM_Write_8b
      16   HAL_SDRAM_Write_DMA
        16   -> HAL_DMA_Start_IT


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable1
       4  ??DataTable1_1
       6  ?Subroutine0
       2  HAL_SDRAM_DMA_XferCpltCallback
       2  HAL_SDRAM_DMA_XferErrorCallback
      30  HAL_SDRAM_DeInit
       8  HAL_SDRAM_GetModeStatus
       6  HAL_SDRAM_GetState
      30  HAL_SDRAM_IRQHandler
      58  HAL_SDRAM_Init
       2  HAL_SDRAM_MspDeInit
       2  HAL_SDRAM_MspInit
      34  HAL_SDRAM_ProgramRefreshRate
      56  HAL_SDRAM_Read_16b
      56  HAL_SDRAM_Read_32b
      56  HAL_SDRAM_Read_8b
      58  HAL_SDRAM_Read_DMA
       2  HAL_SDRAM_RefreshErrorCallback
      44  HAL_SDRAM_SendCommand
      34  HAL_SDRAM_SetAutoRefreshNumber
      36  HAL_SDRAM_WriteProtection_Disable
      36  HAL_SDRAM_WriteProtection_Enable
      58  HAL_SDRAM_Write_16b
      58  HAL_SDRAM_Write_32b
      56  HAL_SDRAM_Write_8b
      68  HAL_SDRAM_Write_DMA

 
 806 bytes in section .text
 
 806 bytes of CODE memory

Errors: none
Warnings: none
