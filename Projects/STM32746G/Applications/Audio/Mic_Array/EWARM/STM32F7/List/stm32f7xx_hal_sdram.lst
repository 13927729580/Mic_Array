###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.2.10312/W32 for ARM       12/Feb/2016  13:21:53
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_sdram.c
#    Command line =  
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_sdram.c
#        -D USE_HAL_DRIVER -D STM32F746xx -D USE_STM32746G_DISCO -D
#        USE_IOEXPANDER -D USE_USB_FS -lC
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
#        -lA
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
#        -o
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M7 -e --fpu=VFPv5_sp --dlib_config "D:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.3\arm\INC\c\DLib_Config_Full.h"
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\Inc\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\CMSIS\Device\ST\STM32F7xx\Include\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\STM32F7xx_HAL_Driver\Inc\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\STM32746G-Discovery\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\Components\Common\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Log\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Fonts\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\CPU\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_Device_Library\Core\Inc\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Core\Inc\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Class\MSC\Inc\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\drivers\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_Audio\Addons\PDM\
#        -On --use_c++_inline --require_prototypes -I "D:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.3\arm\CMSIS\Include\" -D
#        ARM_MATH_CM7
#    List file    =  
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List\stm32f7xx_hal_sdram.lst
#    Object file  =  
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj\stm32f7xx_hal_sdram.o
#
###############################################################################

H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_sdram.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f7xx_hal_sdram.c
      4            * @author  MCD Application Team
      5            * @version V1.0.1
      6            * @date    25-June-2015
      7            * @brief   SDRAM HAL module driver.
      8            *          This file provides a generic firmware to drive SDRAM memories mounted 
      9            *          as external device.
     10            *         
     11            @verbatim
     12            ==============================================================================
     13                                 ##### How to use this driver #####
     14            ============================================================================== 
     15            [..]
     16              This driver is a generic layered driver which contains a set of APIs used to 
     17              control SDRAM memories. It uses the FMC layer functions to interface 
     18              with SDRAM devices.  
     19              The following sequence should be followed to configure the FMC to interface
     20              with SDRAM memories: 
     21                
     22             (#) Declare a SDRAM_HandleTypeDef handle structure, for example:
     23                    SDRAM_HandleTypeDef  hdsram 
     24                    
     25                 (++) Fill the SDRAM_HandleTypeDef handle "Init" field with the allowed 
     26                      values of the structure member.
     27                      
     28                 (++) Fill the SDRAM_HandleTypeDef handle "Instance" field with a predefined 
     29                      base register instance for NOR or SDRAM device 
     30                       
     31             (#) Declare a FMC_SDRAM_TimingTypeDef structure; for example:
     32                    FMC_SDRAM_TimingTypeDef  Timing;
     33                and fill its fields with the allowed values of the structure member.
     34                
     35             (#) Initialize the SDRAM Controller by calling the function HAL_SDRAM_Init(). This function
     36                 performs the following sequence:
     37                    
     38                 (##) MSP hardware layer configuration using the function HAL_SDRAM_MspInit()
     39                 (##) Control register configuration using the FMC SDRAM interface function 
     40                      FMC_SDRAM_Init()
     41                 (##) Timing register configuration using the FMC SDRAM interface function 
     42                      FMC_SDRAM_Timing_Init()
     43                 (##) Program the SDRAM external device by applying its initialization sequence
     44                      according to the device plugged in your hardware. This step is mandatory
     45                      for accessing the SDRAM device.   
     46          
     47             (#) At this stage you can perform read/write accesses from/to the memory connected 
     48                 to the SDRAM Bank. You can perform either polling or DMA transfer using the
     49                 following APIs:
     50                 (++) HAL_SDRAM_Read()/HAL_SDRAM_Write() for polling read/write access
     51                 (++) HAL_SDRAM_Read_DMA()/HAL_SDRAM_Write_DMA() for DMA read/write transfer
     52                 
     53             (#) You can also control the SDRAM device by calling the control APIs HAL_SDRAM_WriteOperation_Enable()/
     54                 HAL_SDRAM_WriteOperation_Disable() to respectively enable/disable the SDRAM write operation or 
     55                 the function HAL_SDRAM_SendCommand() to send a specified command to the SDRAM
     56                 device. The command to be sent must be configured with the FMC_SDRAM_CommandTypeDef 
     57                 structure.   
     58                 
     59             (#) You can continuously monitor the SDRAM device HAL state by calling the function
     60                 HAL_SDRAM_GetState()         
     61                
     62            @endverbatim
     63            ******************************************************************************
     64            * @attention
     65            *
     66            * <h2><center>&copy; COPYRIGHT(c) 2015 STMicroelectronics</center></h2>
     67            *
     68            * Redistribution and use in source and binary forms, with or without modification,
     69            * are permitted provided that the following conditions are met:
     70            *   1. Redistributions of source code must retain the above copyright notice,
     71            *      this list of conditions and the following disclaimer.
     72            *   2. Redistributions in binary form must reproduce the above copyright notice,
     73            *      this list of conditions and the following disclaimer in the documentation
     74            *      and/or other materials provided with the distribution.
     75            *   3. Neither the name of STMicroelectronics nor the names of its contributors
     76            *      may be used to endorse or promote products derived from this software
     77            *      without specific prior written permission.
     78            *
     79            * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
     80            * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     81            * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     82            * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
     83            * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
     84            * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
     85            * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
     86            * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
     87            * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
     88            * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     89            *
     90            ******************************************************************************
     91            */ 
     92          
     93          /* Includes ------------------------------------------------------------------*/
     94          #include "stm32f7xx_hal.h"
     95          
     96          /** @addtogroup STM32F7xx_HAL_Driver
     97            * @{
     98            */
     99          
    100          /** @defgroup SDRAM SDRAM
    101            * @brief SDRAM driver modules
    102            * @{
    103            */
    104          #ifdef HAL_SDRAM_MODULE_ENABLED
    105          
    106          /* Private typedef -----------------------------------------------------------*/
    107          /* Private define ------------------------------------------------------------*/
    108          /* Private macro -------------------------------------------------------------*/    
    109          /* Private variables ---------------------------------------------------------*/
    110          /* Private functions ---------------------------------------------------------*/
    111          /* Exported functions --------------------------------------------------------*/
    112          /** @defgroup SDRAM_Exported_Functions SDRAM Exported Functions
    113            * @{
    114            */
    115          
    116          /** @defgroup SDRAM_Exported_Functions_Group1 Initialization and de-initialization functions 
    117            * @brief    Initialization and Configuration functions 
    118            *
    119            @verbatim    
    120            ==============================================================================
    121                     ##### SDRAM Initialization and de_initialization functions #####
    122            ==============================================================================
    123            [..]  
    124              This section provides functions allowing to initialize/de-initialize
    125              the SDRAM memory
    126            
    127          @endverbatim
    128            * @{
    129            */
    130              
    131          /**
    132            * @brief  Performs the SDRAM device initialization sequence.
    133            * @param  hsdram: pointer to a SDRAM_HandleTypeDef structure that contains
    134            *                the configuration information for SDRAM module.
    135            * @param  Timing: Pointer to SDRAM control timing structure 
    136            * @retval HAL status
    137            */

   \                                 In section .text, align 2, keep-with-next
    138          HAL_StatusTypeDef HAL_SDRAM_Init(SDRAM_HandleTypeDef *hsdram, FMC_SDRAM_TimingTypeDef *Timing)
    139          {   
   \                     HAL_SDRAM_Init: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    140            /* Check the SDRAM handle parameter */
    141            if(hsdram == NULL)
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD101             BNE.N    ??HAL_SDRAM_Init_0
    142            {
    143              return HAL_ERROR;
   \   0000000A   0x2001             MOVS     R0,#+1
   \   0000000C   0xE019             B.N      ??HAL_SDRAM_Init_1
    144            }
    145            
    146            if(hsdram->State == HAL_SDRAM_STATE_RESET)
   \                     ??HAL_SDRAM_Init_0: (+1)
   \   0000000E   0xF894 0x002C      LDRB     R0,[R4, #+44]
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD105             BNE.N    ??HAL_SDRAM_Init_2
    147            {  
    148              /* Allocate lock resource and initialize it */
    149              hsdram->Lock = HAL_UNLOCKED;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0xF884 0x002D      STRB     R0,[R4, #+45]
    150              /* Initialize the low level hardware (MSP) */
    151              HAL_SDRAM_MspInit(hsdram);
   \   0000001C   0x0020             MOVS     R0,R4
   \   0000001E   0x.... 0x....      BL       HAL_SDRAM_MspInit
    152            }
    153            
    154            /* Initialize the SDRAM controller state */
    155            hsdram->State = HAL_SDRAM_STATE_BUSY;
   \                     ??HAL_SDRAM_Init_2: (+1)
   \   00000022   0x2002             MOVS     R0,#+2
   \   00000024   0xF884 0x002C      STRB     R0,[R4, #+44]
    156            
    157            /* Initialize SDRAM control Interface */
    158            FMC_SDRAM_Init(hsdram->Instance, &(hsdram->Init));
   \   00000028   0x1D21             ADDS     R1,R4,#+4
   \   0000002A   0x6820             LDR      R0,[R4, #+0]
   \   0000002C   0x.... 0x....      BL       FMC_SDRAM_Init
    159            
    160            /* Initialize SDRAM timing Interface */
    161            FMC_SDRAM_Timing_Init(hsdram->Instance, Timing, hsdram->Init.SDBank); 
   \   00000030   0x6862             LDR      R2,[R4, #+4]
   \   00000032   0x0029             MOVS     R1,R5
   \   00000034   0x6820             LDR      R0,[R4, #+0]
   \   00000036   0x.... 0x....      BL       FMC_SDRAM_Timing_Init
    162            
    163            /* Update the SDRAM controller state */
    164            hsdram->State = HAL_SDRAM_STATE_READY;
   \   0000003A   0x2001             MOVS     R0,#+1
   \   0000003C   0xF884 0x002C      STRB     R0,[R4, #+44]
    165            
    166            return HAL_OK;
   \   00000040   0x2000             MOVS     R0,#+0
   \                     ??HAL_SDRAM_Init_1: (+1)
   \   00000042   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    167          }
    168          
    169          /**
    170            * @brief  Perform the SDRAM device initialization sequence.
    171            * @param  hsdram: pointer to a SDRAM_HandleTypeDef structure that contains
    172            *                the configuration information for SDRAM module.
    173            * @retval HAL status
    174            */

   \                                 In section .text, align 2, keep-with-next
    175          HAL_StatusTypeDef HAL_SDRAM_DeInit(SDRAM_HandleTypeDef *hsdram)
    176          {
   \                     HAL_SDRAM_DeInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    177            /* Initialize the low level hardware (MSP) */
    178            HAL_SDRAM_MspDeInit(hsdram);
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0x.... 0x....      BL       HAL_SDRAM_MspDeInit
    179          
    180            /* Configure the SDRAM registers with their reset values */
    181            FMC_SDRAM_DeInit(hsdram->Instance, hsdram->Init.SDBank);
   \   0000000A   0x6861             LDR      R1,[R4, #+4]
   \   0000000C   0x6820             LDR      R0,[R4, #+0]
   \   0000000E   0x.... 0x....      BL       FMC_SDRAM_DeInit
    182          
    183            /* Reset the SDRAM controller state */
    184            hsdram->State = HAL_SDRAM_STATE_RESET;
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0xF884 0x002C      STRB     R0,[R4, #+44]
    185          
    186            /* Release Lock */
    187            __HAL_UNLOCK(hsdram);
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0xF884 0x002D      STRB     R0,[R4, #+45]
    188          
    189            return HAL_OK;
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0xBD10             POP      {R4,PC}          ;; return
    190          }
    191          
    192          /**
    193            * @brief  SDRAM MSP Init.
    194            * @param  hsdram: pointer to a SDRAM_HandleTypeDef structure that contains
    195            *                the configuration information for SDRAM module.
    196            * @retval None
    197            */

   \                                 In section .text, align 2, keep-with-next
    198          __weak void HAL_SDRAM_MspInit(SDRAM_HandleTypeDef *hsdram)
    199          {
    200            /* NOTE: This function Should not be modified, when the callback is needed,
    201                      the HAL_SDRAM_MspInit could be implemented in the user file
    202             */ 
    203          }
   \                     HAL_SDRAM_MspInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    204          
    205          /**
    206            * @brief  SDRAM MSP DeInit.
    207            * @param  hsdram: pointer to a SDRAM_HandleTypeDef structure that contains
    208            *                the configuration information for SDRAM module.
    209            * @retval None
    210            */

   \                                 In section .text, align 2, keep-with-next
    211          __weak void HAL_SDRAM_MspDeInit(SDRAM_HandleTypeDef *hsdram)
    212          {
    213            /* NOTE: This function Should not be modified, when the callback is needed,
    214                      the HAL_SDRAM_MspDeInit could be implemented in the user file
    215             */ 
    216          }
   \                     HAL_SDRAM_MspDeInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    217          
    218          /**
    219            * @brief  This function handles SDRAM refresh error interrupt request.
    220            * @param  hsdram: pointer to a SDRAM_HandleTypeDef structure that contains
    221            *                the configuration information for SDRAM module.
    222            * @retval HAL status
    223          */

   \                                 In section .text, align 2, keep-with-next
    224          void HAL_SDRAM_IRQHandler(SDRAM_HandleTypeDef *hsdram)
    225          {
   \                     HAL_SDRAM_IRQHandler: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    226            /* Check SDRAM interrupt Rising edge flag */
    227            if(__FMC_SDRAM_GET_FLAG(hsdram->Instance, FMC_SDRAM_FLAG_REFRESH_IT))
   \   00000004   0x6820             LDR      R0,[R4, #+0]
   \   00000006   0x6980             LDR      R0,[R0, #+24]
   \   00000008   0x07C0             LSLS     R0,R0,#+31
   \   0000000A   0xD508             BPL.N    ??HAL_SDRAM_IRQHandler_0
    228            {
    229              /* SDRAM refresh error interrupt callback */
    230              HAL_SDRAM_RefreshErrorCallback(hsdram);
   \   0000000C   0x0020             MOVS     R0,R4
   \   0000000E   0x.... 0x....      BL       HAL_SDRAM_RefreshErrorCallback
    231              
    232              /* Clear SDRAM refresh error interrupt pending bit */
    233              __FMC_SDRAM_CLEAR_FLAG(hsdram->Instance, FMC_SDRAM_FLAG_REFRESH_ERROR);
   \   00000012   0x6820             LDR      R0,[R4, #+0]
   \   00000014   0x6940             LDR      R0,[R0, #+20]
   \   00000016   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   0000001A   0x6821             LDR      R1,[R4, #+0]
   \   0000001C   0x6148             STR      R0,[R1, #+20]
    234            }
    235          }
   \                     ??HAL_SDRAM_IRQHandler_0: (+1)
   \   0000001E   0xBD10             POP      {R4,PC}          ;; return
    236          
    237          /**
    238            * @brief  SDRAM Refresh error callback.
    239            * @param  hsdram: pointer to a SDRAM_HandleTypeDef structure that contains
    240            *                the configuration information for SDRAM module. 
    241            * @retval None
    242            */

   \                                 In section .text, align 2, keep-with-next
    243          __weak void HAL_SDRAM_RefreshErrorCallback(SDRAM_HandleTypeDef *hsdram)
    244          {
    245            /* NOTE: This function Should not be modified, when the callback is needed,
    246                      the HAL_SDRAM_RefreshErrorCallback could be implemented in the user file
    247             */ 
    248          }
   \                     HAL_SDRAM_RefreshErrorCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    249          
    250          /**
    251            * @brief  DMA transfer complete callback.
    252            * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
    253            *                the configuration information for the specified DMA module.
    254            * @retval None
    255            */

   \                                 In section .text, align 2, keep-with-next
    256          __weak void HAL_SDRAM_DMA_XferCpltCallback(DMA_HandleTypeDef *hdma)
    257          {
    258            /* NOTE: This function Should not be modified, when the callback is needed,
    259                      the HAL_SDRAM_DMA_XferCpltCallback could be implemented in the user file
    260             */ 
    261          }
   \                     HAL_SDRAM_DMA_XferCpltCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    262          
    263          /**
    264            * @brief  DMA transfer complete error callback.
    265            * @param  hdma: DMA handle
    266            * @retval None
    267            */

   \                                 In section .text, align 2, keep-with-next
    268          __weak void HAL_SDRAM_DMA_XferErrorCallback(DMA_HandleTypeDef *hdma)
    269          {
    270            /* NOTE: This function Should not be modified, when the callback is needed,
    271                      the HAL_SDRAM_DMA_XferErrorCallback could be implemented in the user file
    272             */ 
    273          }
   \                     HAL_SDRAM_DMA_XferErrorCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    274          
    275          /**
    276            * @}
    277            */
    278          
    279          /** @defgroup SDRAM_Exported_Functions_Group2 Input and Output functions 
    280            * @brief    Input Output and memory control functions 
    281            *
    282            @verbatim    
    283            ==============================================================================
    284                              ##### SDRAM Input and Output functions #####
    285            ==============================================================================
    286            [..]  
    287              This section provides functions allowing to use and control the SDRAM memory
    288            
    289          @endverbatim
    290            * @{
    291            */
    292          
    293          /**
    294            * @brief  Reads 8-bit data buffer from the SDRAM memory.
    295            * @param  hsdram: pointer to a SDRAM_HandleTypeDef structure that contains
    296            *                the configuration information for SDRAM module.
    297            * @param  pAddress: Pointer to read start address
    298            * @param  pDstBuffer: Pointer to destination buffer  
    299            * @param  BufferSize: Size of the buffer to read from memory
    300            * @retval HAL status
    301            */

   \                                 In section .text, align 2, keep-with-next
    302          HAL_StatusTypeDef HAL_SDRAM_Read_8b(SDRAM_HandleTypeDef *hsdram, uint32_t *pAddress, uint8_t *pDstBuffer, uint32_t BufferSize)
    303          {
   \                     HAL_SDRAM_Read_8b: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
   \   00000002   0x0004             MOVS     R4,R0
    304            __IO uint8_t *pSdramAddress = (uint8_t *)pAddress;
   \   00000004   0x000D             MOVS     R5,R1
    305            
    306            /* Process Locked */
    307            __HAL_LOCK(hsdram);
   \   00000006   0xF894 0x002D      LDRB     R0,[R4, #+45]
   \   0000000A   0x2801             CMP      R0,#+1
   \   0000000C   0xD101             BNE.N    ??HAL_SDRAM_Read_8b_0
   \   0000000E   0x2002             MOVS     R0,#+2
   \   00000010   0xE01A             B.N      ??HAL_SDRAM_Read_8b_1
   \                     ??HAL_SDRAM_Read_8b_0: (+1)
   \   00000012   0x2001             MOVS     R0,#+1
   \   00000014   0xF884 0x002D      STRB     R0,[R4, #+45]
    308            
    309            /* Check the SDRAM controller state */
    310            if(hsdram->State == HAL_SDRAM_STATE_BUSY)
   \   00000018   0xF894 0x002C      LDRB     R0,[R4, #+44]
   \   0000001C   0x2802             CMP      R0,#+2
   \   0000001E   0xD101             BNE.N    ??HAL_SDRAM_Read_8b_2
    311            {
    312              return HAL_BUSY;
   \   00000020   0x2002             MOVS     R0,#+2
   \   00000022   0xE011             B.N      ??HAL_SDRAM_Read_8b_1
    313            }
    314            else if(hsdram->State == HAL_SDRAM_STATE_PRECHARGED)
   \                     ??HAL_SDRAM_Read_8b_2: (+1)
   \   00000024   0xF894 0x002C      LDRB     R0,[R4, #+44]
   \   00000028   0x2805             CMP      R0,#+5
   \   0000002A   0xD101             BNE.N    ??HAL_SDRAM_Read_8b_3
    315            {
    316              return  HAL_ERROR; 
   \   0000002C   0x2001             MOVS     R0,#+1
   \   0000002E   0xE00B             B.N      ??HAL_SDRAM_Read_8b_1
    317            }  
    318            
    319            /* Read data from source */
    320            for(; BufferSize != 0; BufferSize--)
   \                     ??HAL_SDRAM_Read_8b_3: (+1)
   \   00000030   0x2B00             CMP      R3,#+0
   \   00000032   0xD005             BEQ.N    ??HAL_SDRAM_Read_8b_4
    321            {
    322              *pDstBuffer = *(__IO uint8_t *)pSdramAddress;  
   \   00000034   0x7828             LDRB     R0,[R5, #+0]
   \   00000036   0x7010             STRB     R0,[R2, #+0]
    323              pDstBuffer++;
   \   00000038   0x1C52             ADDS     R2,R2,#+1
    324              pSdramAddress++;
   \   0000003A   0x1C6D             ADDS     R5,R5,#+1
    325            }
   \   0000003C   0x1E5B             SUBS     R3,R3,#+1
   \   0000003E   0xE7F7             B.N      ??HAL_SDRAM_Read_8b_3
    326            
    327            /* Process Unlocked */
    328            __HAL_UNLOCK(hsdram);
   \                     ??HAL_SDRAM_Read_8b_4: (+1)
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0xF884 0x002D      STRB     R0,[R4, #+45]
    329            
    330            return HAL_OK; 
   \   00000046   0x2000             MOVS     R0,#+0
   \                     ??HAL_SDRAM_Read_8b_1: (+1)
   \   00000048   0xBC30             POP      {R4,R5}
   \   0000004A   0x4770             BX       LR               ;; return
    331          }
    332          
    333          
    334          /**
    335            * @brief  Writes 8-bit data buffer to SDRAM memory.
    336            * @param  hsdram: pointer to a SDRAM_HandleTypeDef structure that contains
    337            *                the configuration information for SDRAM module.
    338            * @param  pAddress: Pointer to write start address
    339            * @param  pSrcBuffer: Pointer to source buffer to write  
    340            * @param  BufferSize: Size of the buffer to write to memory
    341            * @retval HAL status
    342            */

   \                                 In section .text, align 2, keep-with-next
    343          HAL_StatusTypeDef HAL_SDRAM_Write_8b(SDRAM_HandleTypeDef *hsdram, uint32_t *pAddress, uint8_t *pSrcBuffer, uint32_t BufferSize)
    344          {
   \                     HAL_SDRAM_Write_8b: (+1)
   \   00000000   0xB470             PUSH     {R4-R6}
   \   00000002   0x0004             MOVS     R4,R0
    345            __IO uint8_t *pSdramAddress = (uint8_t *)pAddress;
   \   00000004   0x000D             MOVS     R5,R1
    346            uint32_t tmp = 0;
   \   00000006   0x2600             MOVS     R6,#+0
    347            
    348            /* Process Locked */
    349            __HAL_LOCK(hsdram);
   \   00000008   0xF894 0x002D      LDRB     R0,[R4, #+45]
   \   0000000C   0x2801             CMP      R0,#+1
   \   0000000E   0xD101             BNE.N    ??HAL_SDRAM_Write_8b_0
   \   00000010   0x2002             MOVS     R0,#+2
   \   00000012   0xE01B             B.N      ??HAL_SDRAM_Write_8b_1
   \                     ??HAL_SDRAM_Write_8b_0: (+1)
   \   00000014   0x2001             MOVS     R0,#+1
   \   00000016   0xF884 0x002D      STRB     R0,[R4, #+45]
    350            
    351            /* Check the SDRAM controller state */
    352            tmp = hsdram->State;
   \   0000001A   0xF894 0x002C      LDRB     R0,[R4, #+44]
   \   0000001E   0x0006             MOVS     R6,R0
    353            
    354            if(tmp == HAL_SDRAM_STATE_BUSY)
   \   00000020   0x2E02             CMP      R6,#+2
   \   00000022   0xD101             BNE.N    ??HAL_SDRAM_Write_8b_2
    355            {
    356              return HAL_BUSY;
   \   00000024   0x2002             MOVS     R0,#+2
   \   00000026   0xE011             B.N      ??HAL_SDRAM_Write_8b_1
    357            }
    358            else if((tmp == HAL_SDRAM_STATE_PRECHARGED) || (tmp == HAL_SDRAM_STATE_WRITE_PROTECTED))
   \                     ??HAL_SDRAM_Write_8b_2: (+1)
   \   00000028   0x2E05             CMP      R6,#+5
   \   0000002A   0xD001             BEQ.N    ??HAL_SDRAM_Write_8b_3
   \   0000002C   0x2E04             CMP      R6,#+4
   \   0000002E   0xD101             BNE.N    ??HAL_SDRAM_Write_8b_4
    359            {
    360              return  HAL_ERROR; 
   \                     ??HAL_SDRAM_Write_8b_3: (+1)
   \   00000030   0x2001             MOVS     R0,#+1
   \   00000032   0xE00B             B.N      ??HAL_SDRAM_Write_8b_1
    361            }
    362            
    363            /* Write data to memory */
    364            for(; BufferSize != 0; BufferSize--)
   \                     ??HAL_SDRAM_Write_8b_4: (+1)
   \   00000034   0x2B00             CMP      R3,#+0
   \   00000036   0xD005             BEQ.N    ??HAL_SDRAM_Write_8b_5
    365            {
    366              *(__IO uint8_t *)pSdramAddress = *pSrcBuffer;
   \   00000038   0x7810             LDRB     R0,[R2, #+0]
   \   0000003A   0x7028             STRB     R0,[R5, #+0]
    367              pSrcBuffer++;
   \   0000003C   0x1C52             ADDS     R2,R2,#+1
    368              pSdramAddress++;
   \   0000003E   0x1C6D             ADDS     R5,R5,#+1
    369            }
   \   00000040   0x1E5B             SUBS     R3,R3,#+1
   \   00000042   0xE7F7             B.N      ??HAL_SDRAM_Write_8b_4
    370            
    371            /* Process Unlocked */
    372            __HAL_UNLOCK(hsdram);    
   \                     ??HAL_SDRAM_Write_8b_5: (+1)
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0xF884 0x002D      STRB     R0,[R4, #+45]
    373            
    374            return HAL_OK;   
   \   0000004A   0x2000             MOVS     R0,#+0
   \                     ??HAL_SDRAM_Write_8b_1: (+1)
   \   0000004C   0xBC70             POP      {R4-R6}
   \   0000004E   0x4770             BX       LR               ;; return
    375          }
    376          
    377          
    378          /**
    379            * @brief  Reads 16-bit data buffer from the SDRAM memory. 
    380            * @param  hsdram: pointer to a SDRAM_HandleTypeDef structure that contains
    381            *                the configuration information for SDRAM module.
    382            * @param  pAddress: Pointer to read start address
    383            * @param  pDstBuffer: Pointer to destination buffer  
    384            * @param  BufferSize: Size of the buffer to read from memory
    385            * @retval HAL status
    386            */

   \                                 In section .text, align 2, keep-with-next
    387          HAL_StatusTypeDef HAL_SDRAM_Read_16b(SDRAM_HandleTypeDef *hsdram, uint32_t *pAddress, uint16_t *pDstBuffer, uint32_t BufferSize)
    388          {
   \                     HAL_SDRAM_Read_16b: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
   \   00000002   0x0004             MOVS     R4,R0
    389            __IO uint16_t *pSdramAddress = (uint16_t *)pAddress;
   \   00000004   0x000D             MOVS     R5,R1
    390            
    391            /* Process Locked */
    392            __HAL_LOCK(hsdram);
   \   00000006   0xF894 0x002D      LDRB     R0,[R4, #+45]
   \   0000000A   0x2801             CMP      R0,#+1
   \   0000000C   0xD101             BNE.N    ??HAL_SDRAM_Read_16b_0
   \   0000000E   0x2002             MOVS     R0,#+2
   \   00000010   0xE01A             B.N      ??HAL_SDRAM_Read_16b_1
   \                     ??HAL_SDRAM_Read_16b_0: (+1)
   \   00000012   0x2001             MOVS     R0,#+1
   \   00000014   0xF884 0x002D      STRB     R0,[R4, #+45]
    393            
    394            /* Check the SDRAM controller state */
    395            if(hsdram->State == HAL_SDRAM_STATE_BUSY)
   \   00000018   0xF894 0x002C      LDRB     R0,[R4, #+44]
   \   0000001C   0x2802             CMP      R0,#+2
   \   0000001E   0xD101             BNE.N    ??HAL_SDRAM_Read_16b_2
    396            {
    397              return HAL_BUSY;
   \   00000020   0x2002             MOVS     R0,#+2
   \   00000022   0xE011             B.N      ??HAL_SDRAM_Read_16b_1
    398            }
    399            else if(hsdram->State == HAL_SDRAM_STATE_PRECHARGED)
   \                     ??HAL_SDRAM_Read_16b_2: (+1)
   \   00000024   0xF894 0x002C      LDRB     R0,[R4, #+44]
   \   00000028   0x2805             CMP      R0,#+5
   \   0000002A   0xD101             BNE.N    ??HAL_SDRAM_Read_16b_3
    400            {
    401              return  HAL_ERROR; 
   \   0000002C   0x2001             MOVS     R0,#+1
   \   0000002E   0xE00B             B.N      ??HAL_SDRAM_Read_16b_1
    402            }  
    403            
    404            /* Read data from source */
    405            for(; BufferSize != 0; BufferSize--)
   \                     ??HAL_SDRAM_Read_16b_3: (+1)
   \   00000030   0x2B00             CMP      R3,#+0
   \   00000032   0xD005             BEQ.N    ??HAL_SDRAM_Read_16b_4
    406            {
    407              *pDstBuffer = *(__IO uint16_t *)pSdramAddress;  
   \   00000034   0x8828             LDRH     R0,[R5, #+0]
   \   00000036   0x8010             STRH     R0,[R2, #+0]
    408              pDstBuffer++;
   \   00000038   0x1C92             ADDS     R2,R2,#+2
    409              pSdramAddress++;               
   \   0000003A   0x1CAD             ADDS     R5,R5,#+2
    410            }
   \   0000003C   0x1E5B             SUBS     R3,R3,#+1
   \   0000003E   0xE7F7             B.N      ??HAL_SDRAM_Read_16b_3
    411            
    412            /* Process Unlocked */
    413            __HAL_UNLOCK(hsdram);       
   \                     ??HAL_SDRAM_Read_16b_4: (+1)
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0xF884 0x002D      STRB     R0,[R4, #+45]
    414            
    415            return HAL_OK; 
   \   00000046   0x2000             MOVS     R0,#+0
   \                     ??HAL_SDRAM_Read_16b_1: (+1)
   \   00000048   0xBC30             POP      {R4,R5}
   \   0000004A   0x4770             BX       LR               ;; return
    416          }
    417          
    418          /**
    419            * @brief  Writes 16-bit data buffer to SDRAM memory. 
    420            * @param  hsdram: pointer to a SDRAM_HandleTypeDef structure that contains
    421            *                the configuration information for SDRAM module.
    422            * @param  pAddress: Pointer to write start address
    423            * @param  pSrcBuffer: Pointer to source buffer to write  
    424            * @param  BufferSize: Size of the buffer to write to memory
    425            * @retval HAL status
    426            */

   \                                 In section .text, align 2, keep-with-next
    427          HAL_StatusTypeDef HAL_SDRAM_Write_16b(SDRAM_HandleTypeDef *hsdram, uint32_t *pAddress, uint16_t *pSrcBuffer, uint32_t BufferSize)
    428          {
   \                     HAL_SDRAM_Write_16b: (+1)
   \   00000000   0xB470             PUSH     {R4-R6}
   \   00000002   0x0004             MOVS     R4,R0
    429            __IO uint16_t *pSdramAddress = (uint16_t *)pAddress;
   \   00000004   0x000D             MOVS     R5,R1
    430            uint32_t tmp = 0;
   \   00000006   0x2600             MOVS     R6,#+0
    431            
    432            /* Process Locked */
    433            __HAL_LOCK(hsdram);
   \   00000008   0xF894 0x002D      LDRB     R0,[R4, #+45]
   \   0000000C   0x2801             CMP      R0,#+1
   \   0000000E   0xD101             BNE.N    ??HAL_SDRAM_Write_16b_0
   \   00000010   0x2002             MOVS     R0,#+2
   \   00000012   0xE01B             B.N      ??HAL_SDRAM_Write_16b_1
   \                     ??HAL_SDRAM_Write_16b_0: (+1)
   \   00000014   0x2001             MOVS     R0,#+1
   \   00000016   0xF884 0x002D      STRB     R0,[R4, #+45]
    434            
    435            /* Check the SDRAM controller state */
    436            tmp = hsdram->State;
   \   0000001A   0xF894 0x002C      LDRB     R0,[R4, #+44]
   \   0000001E   0x0006             MOVS     R6,R0
    437            
    438            if(tmp == HAL_SDRAM_STATE_BUSY)
   \   00000020   0x2E02             CMP      R6,#+2
   \   00000022   0xD101             BNE.N    ??HAL_SDRAM_Write_16b_2
    439            {
    440              return HAL_BUSY;
   \   00000024   0x2002             MOVS     R0,#+2
   \   00000026   0xE011             B.N      ??HAL_SDRAM_Write_16b_1
    441            }
    442            else if((tmp == HAL_SDRAM_STATE_PRECHARGED) || (tmp == HAL_SDRAM_STATE_WRITE_PROTECTED))
   \                     ??HAL_SDRAM_Write_16b_2: (+1)
   \   00000028   0x2E05             CMP      R6,#+5
   \   0000002A   0xD001             BEQ.N    ??HAL_SDRAM_Write_16b_3
   \   0000002C   0x2E04             CMP      R6,#+4
   \   0000002E   0xD101             BNE.N    ??HAL_SDRAM_Write_16b_4
    443            {
    444              return  HAL_ERROR; 
   \                     ??HAL_SDRAM_Write_16b_3: (+1)
   \   00000030   0x2001             MOVS     R0,#+1
   \   00000032   0xE00B             B.N      ??HAL_SDRAM_Write_16b_1
    445            }
    446            
    447            /* Write data to memory */
    448            for(; BufferSize != 0; BufferSize--)
   \                     ??HAL_SDRAM_Write_16b_4: (+1)
   \   00000034   0x2B00             CMP      R3,#+0
   \   00000036   0xD005             BEQ.N    ??HAL_SDRAM_Write_16b_5
    449            {
    450              *(__IO uint16_t *)pSdramAddress = *pSrcBuffer;
   \   00000038   0x8810             LDRH     R0,[R2, #+0]
   \   0000003A   0x8028             STRH     R0,[R5, #+0]
    451              pSrcBuffer++;
   \   0000003C   0x1C92             ADDS     R2,R2,#+2
    452              pSdramAddress++;            
   \   0000003E   0x1CAD             ADDS     R5,R5,#+2
    453            }
   \   00000040   0x1E5B             SUBS     R3,R3,#+1
   \   00000042   0xE7F7             B.N      ??HAL_SDRAM_Write_16b_4
    454            
    455            /* Process Unlocked */
    456            __HAL_UNLOCK(hsdram);    
   \                     ??HAL_SDRAM_Write_16b_5: (+1)
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0xF884 0x002D      STRB     R0,[R4, #+45]
    457            
    458            return HAL_OK;   
   \   0000004A   0x2000             MOVS     R0,#+0
   \                     ??HAL_SDRAM_Write_16b_1: (+1)
   \   0000004C   0xBC70             POP      {R4-R6}
   \   0000004E   0x4770             BX       LR               ;; return
    459          }
    460          
    461          /**
    462            * @brief  Reads 32-bit data buffer from the SDRAM memory. 
    463            * @param  hsdram: pointer to a SDRAM_HandleTypeDef structure that contains
    464            *                the configuration information for SDRAM module.
    465            * @param  pAddress: Pointer to read start address
    466            * @param  pDstBuffer: Pointer to destination buffer  
    467            * @param  BufferSize: Size of the buffer to read from memory
    468            * @retval HAL status
    469            */

   \                                 In section .text, align 2, keep-with-next
    470          HAL_StatusTypeDef HAL_SDRAM_Read_32b(SDRAM_HandleTypeDef *hsdram, uint32_t *pAddress, uint32_t *pDstBuffer, uint32_t BufferSize)
    471          {
   \                     HAL_SDRAM_Read_32b: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
   \   00000002   0x0004             MOVS     R4,R0
    472            __IO uint32_t *pSdramAddress = (uint32_t *)pAddress;
   \   00000004   0x000D             MOVS     R5,R1
    473            
    474            /* Process Locked */
    475            __HAL_LOCK(hsdram);
   \   00000006   0xF894 0x002D      LDRB     R0,[R4, #+45]
   \   0000000A   0x2801             CMP      R0,#+1
   \   0000000C   0xD101             BNE.N    ??HAL_SDRAM_Read_32b_0
   \   0000000E   0x2002             MOVS     R0,#+2
   \   00000010   0xE01A             B.N      ??HAL_SDRAM_Read_32b_1
   \                     ??HAL_SDRAM_Read_32b_0: (+1)
   \   00000012   0x2001             MOVS     R0,#+1
   \   00000014   0xF884 0x002D      STRB     R0,[R4, #+45]
    476            
    477            /* Check the SDRAM controller state */
    478            if(hsdram->State == HAL_SDRAM_STATE_BUSY)
   \   00000018   0xF894 0x002C      LDRB     R0,[R4, #+44]
   \   0000001C   0x2802             CMP      R0,#+2
   \   0000001E   0xD101             BNE.N    ??HAL_SDRAM_Read_32b_2
    479            {
    480              return HAL_BUSY;
   \   00000020   0x2002             MOVS     R0,#+2
   \   00000022   0xE011             B.N      ??HAL_SDRAM_Read_32b_1
    481            }
    482            else if(hsdram->State == HAL_SDRAM_STATE_PRECHARGED)
   \                     ??HAL_SDRAM_Read_32b_2: (+1)
   \   00000024   0xF894 0x002C      LDRB     R0,[R4, #+44]
   \   00000028   0x2805             CMP      R0,#+5
   \   0000002A   0xD101             BNE.N    ??HAL_SDRAM_Read_32b_3
    483            {
    484              return  HAL_ERROR; 
   \   0000002C   0x2001             MOVS     R0,#+1
   \   0000002E   0xE00B             B.N      ??HAL_SDRAM_Read_32b_1
    485            }  
    486            
    487            /* Read data from source */
    488            for(; BufferSize != 0; BufferSize--)
   \                     ??HAL_SDRAM_Read_32b_3: (+1)
   \   00000030   0x2B00             CMP      R3,#+0
   \   00000032   0xD005             BEQ.N    ??HAL_SDRAM_Read_32b_4
    489            {
    490              *pDstBuffer = *(__IO uint32_t *)pSdramAddress;  
   \   00000034   0x6828             LDR      R0,[R5, #+0]
   \   00000036   0x6010             STR      R0,[R2, #+0]
    491              pDstBuffer++;
   \   00000038   0x1D12             ADDS     R2,R2,#+4
    492              pSdramAddress++;               
   \   0000003A   0x1D2D             ADDS     R5,R5,#+4
    493            }
   \   0000003C   0x1E5B             SUBS     R3,R3,#+1
   \   0000003E   0xE7F7             B.N      ??HAL_SDRAM_Read_32b_3
    494            
    495            /* Process Unlocked */
    496            __HAL_UNLOCK(hsdram);       
   \                     ??HAL_SDRAM_Read_32b_4: (+1)
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0xF884 0x002D      STRB     R0,[R4, #+45]
    497            
    498            return HAL_OK; 
   \   00000046   0x2000             MOVS     R0,#+0
   \                     ??HAL_SDRAM_Read_32b_1: (+1)
   \   00000048   0xBC30             POP      {R4,R5}
   \   0000004A   0x4770             BX       LR               ;; return
    499          }
    500          
    501          /**
    502            * @brief  Writes 32-bit data buffer to SDRAM memory. 
    503            * @param  hsdram: pointer to a SDRAM_HandleTypeDef structure that contains
    504            *                the configuration information for SDRAM module.
    505            * @param  pAddress: Pointer to write start address
    506            * @param  pSrcBuffer: Pointer to source buffer to write  
    507            * @param  BufferSize: Size of the buffer to write to memory
    508            * @retval HAL status
    509            */

   \                                 In section .text, align 2, keep-with-next
    510          HAL_StatusTypeDef HAL_SDRAM_Write_32b(SDRAM_HandleTypeDef *hsdram, uint32_t *pAddress, uint32_t *pSrcBuffer, uint32_t BufferSize)
    511          {
   \                     HAL_SDRAM_Write_32b: (+1)
   \   00000000   0xB470             PUSH     {R4-R6}
   \   00000002   0x0004             MOVS     R4,R0
    512            __IO uint32_t *pSdramAddress = (uint32_t *)pAddress;
   \   00000004   0x000D             MOVS     R5,R1
    513            uint32_t tmp = 0;
   \   00000006   0x2600             MOVS     R6,#+0
    514            
    515            /* Process Locked */
    516            __HAL_LOCK(hsdram);
   \   00000008   0xF894 0x002D      LDRB     R0,[R4, #+45]
   \   0000000C   0x2801             CMP      R0,#+1
   \   0000000E   0xD101             BNE.N    ??HAL_SDRAM_Write_32b_0
   \   00000010   0x2002             MOVS     R0,#+2
   \   00000012   0xE01B             B.N      ??HAL_SDRAM_Write_32b_1
   \                     ??HAL_SDRAM_Write_32b_0: (+1)
   \   00000014   0x2001             MOVS     R0,#+1
   \   00000016   0xF884 0x002D      STRB     R0,[R4, #+45]
    517            
    518            /* Check the SDRAM controller state */
    519            tmp = hsdram->State;
   \   0000001A   0xF894 0x002C      LDRB     R0,[R4, #+44]
   \   0000001E   0x0006             MOVS     R6,R0
    520            
    521            if(tmp == HAL_SDRAM_STATE_BUSY)
   \   00000020   0x2E02             CMP      R6,#+2
   \   00000022   0xD101             BNE.N    ??HAL_SDRAM_Write_32b_2
    522            {
    523              return HAL_BUSY;
   \   00000024   0x2002             MOVS     R0,#+2
   \   00000026   0xE011             B.N      ??HAL_SDRAM_Write_32b_1
    524            }
    525            else if((tmp == HAL_SDRAM_STATE_PRECHARGED) || (tmp == HAL_SDRAM_STATE_WRITE_PROTECTED))
   \                     ??HAL_SDRAM_Write_32b_2: (+1)
   \   00000028   0x2E05             CMP      R6,#+5
   \   0000002A   0xD001             BEQ.N    ??HAL_SDRAM_Write_32b_3
   \   0000002C   0x2E04             CMP      R6,#+4
   \   0000002E   0xD101             BNE.N    ??HAL_SDRAM_Write_32b_4
    526            {
    527              return  HAL_ERROR; 
   \                     ??HAL_SDRAM_Write_32b_3: (+1)
   \   00000030   0x2001             MOVS     R0,#+1
   \   00000032   0xE00B             B.N      ??HAL_SDRAM_Write_32b_1
    528            }
    529            
    530            /* Write data to memory */
    531            for(; BufferSize != 0; BufferSize--)
   \                     ??HAL_SDRAM_Write_32b_4: (+1)
   \   00000034   0x2B00             CMP      R3,#+0
   \   00000036   0xD005             BEQ.N    ??HAL_SDRAM_Write_32b_5
    532            {
    533              *(__IO uint32_t *)pSdramAddress = *pSrcBuffer;
   \   00000038   0x6810             LDR      R0,[R2, #+0]
   \   0000003A   0x6028             STR      R0,[R5, #+0]
    534              pSrcBuffer++;
   \   0000003C   0x1D12             ADDS     R2,R2,#+4
    535              pSdramAddress++;          
   \   0000003E   0x1D2D             ADDS     R5,R5,#+4
    536            }
   \   00000040   0x1E5B             SUBS     R3,R3,#+1
   \   00000042   0xE7F7             B.N      ??HAL_SDRAM_Write_32b_4
    537            
    538            /* Process Unlocked */
    539            __HAL_UNLOCK(hsdram);    
   \                     ??HAL_SDRAM_Write_32b_5: (+1)
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0xF884 0x002D      STRB     R0,[R4, #+45]
    540            
    541            return HAL_OK;  
   \   0000004A   0x2000             MOVS     R0,#+0
   \                     ??HAL_SDRAM_Write_32b_1: (+1)
   \   0000004C   0xBC70             POP      {R4-R6}
   \   0000004E   0x4770             BX       LR               ;; return
    542          }
    543          
    544          /**
    545            * @brief  Reads a Words data from the SDRAM memory using DMA transfer. 
    546            * @param  hsdram: pointer to a SDRAM_HandleTypeDef structure that contains
    547            *                the configuration information for SDRAM module.
    548            * @param  pAddress: Pointer to read start address
    549            * @param  pDstBuffer: Pointer to destination buffer  
    550            * @param  BufferSize: Size of the buffer to read from memory
    551            * @retval HAL status
    552            */

   \                                 In section .text, align 2, keep-with-next
    553          HAL_StatusTypeDef HAL_SDRAM_Read_DMA(SDRAM_HandleTypeDef *hsdram, uint32_t *pAddress, uint32_t *pDstBuffer, uint32_t BufferSize)
    554          {
   \                     HAL_SDRAM_Read_DMA: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
    555            uint32_t tmp = 0;
   \   0000000C   0xF05F 0x0800      MOVS     R8,#+0
    556              
    557            /* Process Locked */
    558            __HAL_LOCK(hsdram);
   \   00000010   0xF894 0x002D      LDRB     R0,[R4, #+45]
   \   00000014   0x2801             CMP      R0,#+1
   \   00000016   0xD101             BNE.N    ??HAL_SDRAM_Read_DMA_0
   \   00000018   0x2002             MOVS     R0,#+2
   \   0000001A   0xE01F             B.N      ??HAL_SDRAM_Read_DMA_1
   \                     ??HAL_SDRAM_Read_DMA_0: (+1)
   \   0000001C   0x2001             MOVS     R0,#+1
   \   0000001E   0xF884 0x002D      STRB     R0,[R4, #+45]
    559            
    560            /* Check the SDRAM controller state */  
    561            tmp = hsdram->State;
   \   00000022   0xF894 0x002C      LDRB     R0,[R4, #+44]
   \   00000026   0x4680             MOV      R8,R0
    562            
    563            if(tmp == HAL_SDRAM_STATE_BUSY)
   \   00000028   0xF1B8 0x0F02      CMP      R8,#+2
   \   0000002C   0xD101             BNE.N    ??HAL_SDRAM_Read_DMA_2
    564            {
    565              return HAL_BUSY;
   \   0000002E   0x2002             MOVS     R0,#+2
   \   00000030   0xE014             B.N      ??HAL_SDRAM_Read_DMA_1
    566            }
    567            else if(tmp == HAL_SDRAM_STATE_PRECHARGED)
   \                     ??HAL_SDRAM_Read_DMA_2: (+1)
   \   00000032   0xF1B8 0x0F05      CMP      R8,#+5
   \   00000036   0xD101             BNE.N    ??HAL_SDRAM_Read_DMA_3
    568            {
    569              return  HAL_ERROR; 
   \   00000038   0x2001             MOVS     R0,#+1
   \   0000003A   0xE00F             B.N      ??HAL_SDRAM_Read_DMA_1
    570            }  
    571            
    572            /* Configure DMA user callbacks */
    573            hsdram->hdma->XferCpltCallback  = HAL_SDRAM_DMA_XferCpltCallback;
   \                     ??HAL_SDRAM_Read_DMA_3: (+1)
   \   0000003C   0x....             LDR.N    R0,??DataTable1
   \   0000003E   0x6B21             LDR      R1,[R4, #+48]
   \   00000040   0x63C8             STR      R0,[R1, #+60]
    574            hsdram->hdma->XferErrorCallback = HAL_SDRAM_DMA_XferErrorCallback;
   \   00000042   0x....             LDR.N    R0,??DataTable1_1
   \   00000044   0x6B21             LDR      R1,[R4, #+48]
   \   00000046   0x6488             STR      R0,[R1, #+72]
    575            
    576            /* Enable the DMA Stream */
    577            HAL_DMA_Start_IT(hsdram->hdma, (uint32_t)pAddress, (uint32_t)pDstBuffer, (uint32_t)BufferSize);
   \   00000048   0x003B             MOVS     R3,R7
   \   0000004A   0x0032             MOVS     R2,R6
   \   0000004C   0x0029             MOVS     R1,R5
   \   0000004E   0x6B20             LDR      R0,[R4, #+48]
   \   00000050   0x.... 0x....      BL       HAL_DMA_Start_IT
    578            
    579            /* Process Unlocked */
    580            __HAL_UNLOCK(hsdram);  
   \   00000054   0x2000             MOVS     R0,#+0
   \   00000056   0xF884 0x002D      STRB     R0,[R4, #+45]
    581            
    582            return HAL_OK; 
   \   0000005A   0x2000             MOVS     R0,#+0
   \                     ??HAL_SDRAM_Read_DMA_1: (+1)
   \   0000005C   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    583          }
    584          
    585          /**
    586            * @brief  Writes a Words data buffer to SDRAM memory using DMA transfer.
    587            * @param  hsdram: pointer to a SDRAM_HandleTypeDef structure that contains
    588            *                the configuration information for SDRAM module.
    589            * @param  pAddress: Pointer to write start address
    590            * @param  pSrcBuffer: Pointer to source buffer to write  
    591            * @param  BufferSize: Size of the buffer to write to memory
    592            * @retval HAL status
    593            */

   \                                 In section .text, align 2, keep-with-next
    594          HAL_StatusTypeDef HAL_SDRAM_Write_DMA(SDRAM_HandleTypeDef *hsdram, uint32_t *pAddress, uint32_t *pSrcBuffer, uint32_t BufferSize)
    595          {
   \                     HAL_SDRAM_Write_DMA: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
    596            uint32_t tmp = 0;
   \   0000000C   0xF05F 0x0800      MOVS     R8,#+0
    597            
    598            /* Process Locked */
    599            __HAL_LOCK(hsdram);
   \   00000010   0xF894 0x002D      LDRB     R0,[R4, #+45]
   \   00000014   0x2801             CMP      R0,#+1
   \   00000016   0xD101             BNE.N    ??HAL_SDRAM_Write_DMA_0
   \   00000018   0x2002             MOVS     R0,#+2
   \   0000001A   0xE022             B.N      ??HAL_SDRAM_Write_DMA_1
   \                     ??HAL_SDRAM_Write_DMA_0: (+1)
   \   0000001C   0x2001             MOVS     R0,#+1
   \   0000001E   0xF884 0x002D      STRB     R0,[R4, #+45]
    600            
    601            /* Check the SDRAM controller state */  
    602            tmp = hsdram->State;
   \   00000022   0xF894 0x002C      LDRB     R0,[R4, #+44]
   \   00000026   0x4680             MOV      R8,R0
    603            
    604            if(tmp == HAL_SDRAM_STATE_BUSY)
   \   00000028   0xF1B8 0x0F02      CMP      R8,#+2
   \   0000002C   0xD101             BNE.N    ??HAL_SDRAM_Write_DMA_2
    605            {
    606              return HAL_BUSY;
   \   0000002E   0x2002             MOVS     R0,#+2
   \   00000030   0xE017             B.N      ??HAL_SDRAM_Write_DMA_1
    607            }
    608            else if((tmp == HAL_SDRAM_STATE_PRECHARGED) || (tmp == HAL_SDRAM_STATE_WRITE_PROTECTED))
   \                     ??HAL_SDRAM_Write_DMA_2: (+1)
   \   00000032   0xF1B8 0x0F05      CMP      R8,#+5
   \   00000036   0xD002             BEQ.N    ??HAL_SDRAM_Write_DMA_3
   \   00000038   0xF1B8 0x0F04      CMP      R8,#+4
   \   0000003C   0xD101             BNE.N    ??HAL_SDRAM_Write_DMA_4
    609            {
    610              return  HAL_ERROR; 
   \                     ??HAL_SDRAM_Write_DMA_3: (+1)
   \   0000003E   0x2001             MOVS     R0,#+1
   \   00000040   0xE00F             B.N      ??HAL_SDRAM_Write_DMA_1
    611            }  
    612            
    613            /* Configure DMA user callbacks */
    614            hsdram->hdma->XferCpltCallback  = HAL_SDRAM_DMA_XferCpltCallback;
   \                     ??HAL_SDRAM_Write_DMA_4: (+1)
   \   00000042   0x....             LDR.N    R0,??DataTable1
   \   00000044   0x6B21             LDR      R1,[R4, #+48]
   \   00000046   0x63C8             STR      R0,[R1, #+60]
    615            hsdram->hdma->XferErrorCallback = HAL_SDRAM_DMA_XferErrorCallback;
   \   00000048   0x....             LDR.N    R0,??DataTable1_1
   \   0000004A   0x6B21             LDR      R1,[R4, #+48]
   \   0000004C   0x6488             STR      R0,[R1, #+72]
    616            
    617            /* Enable the DMA Stream */
    618            HAL_DMA_Start_IT(hsdram->hdma, (uint32_t)pSrcBuffer, (uint32_t)pAddress, (uint32_t)BufferSize);
   \   0000004E   0x003B             MOVS     R3,R7
   \   00000050   0x002A             MOVS     R2,R5
   \   00000052   0x0031             MOVS     R1,R6
   \   00000054   0x6B20             LDR      R0,[R4, #+48]
   \   00000056   0x.... 0x....      BL       HAL_DMA_Start_IT
    619            
    620            /* Process Unlocked */
    621            __HAL_UNLOCK(hsdram);
   \   0000005A   0x2000             MOVS     R0,#+0
   \   0000005C   0xF884 0x002D      STRB     R0,[R4, #+45]
    622            
    623            return HAL_OK;
   \   00000060   0x2000             MOVS     R0,#+0
   \                     ??HAL_SDRAM_Write_DMA_1: (+1)
   \   00000062   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    624          }
    625          
    626          /**
    627            * @}
    628            */
    629            
    630          /** @defgroup SDRAM_Exported_Functions_Group3 Control functions 
    631           *  @brief   management functions 
    632           *
    633          @verbatim   
    634            ==============================================================================
    635                                   ##### SDRAM Control functions #####
    636            ==============================================================================  
    637            [..]
    638              This subsection provides a set of functions allowing to control dynamically
    639              the SDRAM interface.
    640          
    641          @endverbatim
    642            * @{
    643            */
    644          
    645          /**
    646            * @brief  Enables dynamically SDRAM write protection.
    647            * @param  hsdram: pointer to a SDRAM_HandleTypeDef structure that contains
    648            *                the configuration information for SDRAM module.
    649            * @retval HAL status
    650            */

   \                                 In section .text, align 2, keep-with-next
    651          HAL_StatusTypeDef HAL_SDRAM_WriteProtection_Enable(SDRAM_HandleTypeDef *hsdram)
    652          { 
   \                     HAL_SDRAM_WriteProtection_Enable: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    653            /* Check the SDRAM controller state */ 
    654            if(hsdram->State == HAL_SDRAM_STATE_BUSY)
   \   00000004   0xF894 0x002C      LDRB     R0,[R4, #+44]
   \   00000008   0x2802             CMP      R0,#+2
   \   0000000A   0xD101             BNE.N    ??HAL_SDRAM_WriteProtection_Enable_0
    655            {
    656              return HAL_BUSY;
   \   0000000C   0x2002             MOVS     R0,#+2
   \   0000000E   0xE00A             B.N      ??HAL_SDRAM_WriteProtection_Enable_1
    657            }
    658            
    659            /* Update the SDRAM state */
    660            hsdram->State = HAL_SDRAM_STATE_BUSY;
   \                     ??HAL_SDRAM_WriteProtection_Enable_0: (+1)
   \   00000010   0x2002             MOVS     R0,#+2
   \   00000012   0xF884 0x002C      STRB     R0,[R4, #+44]
    661            
    662            /* Enable write protection */
    663            FMC_SDRAM_WriteProtection_Enable(hsdram->Instance, hsdram->Init.SDBank);
   \   00000016   0x6861             LDR      R1,[R4, #+4]
   \   00000018   0x6820             LDR      R0,[R4, #+0]
   \   0000001A   0x.... 0x....      BL       FMC_SDRAM_WriteProtection_Enable
    664            
    665            /* Update the SDRAM state */
    666            hsdram->State = HAL_SDRAM_STATE_WRITE_PROTECTED;
   \   0000001E   0x2004             MOVS     R0,#+4
   \   00000020   0xF884 0x002C      STRB     R0,[R4, #+44]
    667            
    668            return HAL_OK;  
   \   00000024   0x2000             MOVS     R0,#+0
   \                     ??HAL_SDRAM_WriteProtection_Enable_1: (+1)
   \   00000026   0xBD10             POP      {R4,PC}          ;; return
    669          }
    670          
    671          /**
    672            * @brief  Disables dynamically SDRAM write protection.
    673            * @param  hsdram: pointer to a SDRAM_HandleTypeDef structure that contains
    674            *                the configuration information for SDRAM module.
    675            * @retval HAL status
    676            */

   \                                 In section .text, align 2, keep-with-next
    677          HAL_StatusTypeDef HAL_SDRAM_WriteProtection_Disable(SDRAM_HandleTypeDef *hsdram)
    678          {
   \                     HAL_SDRAM_WriteProtection_Disable: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    679            /* Check the SDRAM controller state */
    680            if(hsdram->State == HAL_SDRAM_STATE_BUSY)
   \   00000004   0xF894 0x002C      LDRB     R0,[R4, #+44]
   \   00000008   0x2802             CMP      R0,#+2
   \   0000000A   0xD101             BNE.N    ??HAL_SDRAM_WriteProtection_Disable_0
    681            {
    682              return HAL_BUSY;
   \   0000000C   0x2002             MOVS     R0,#+2
   \   0000000E   0xE00A             B.N      ??HAL_SDRAM_WriteProtection_Disable_1
    683            }
    684            
    685            /* Update the SDRAM state */
    686            hsdram->State = HAL_SDRAM_STATE_BUSY;
   \                     ??HAL_SDRAM_WriteProtection_Disable_0: (+1)
   \   00000010   0x2002             MOVS     R0,#+2
   \   00000012   0xF884 0x002C      STRB     R0,[R4, #+44]
    687            
    688            /* Disable write protection */
    689            FMC_SDRAM_WriteProtection_Disable(hsdram->Instance, hsdram->Init.SDBank);
   \   00000016   0x6861             LDR      R1,[R4, #+4]
   \   00000018   0x6820             LDR      R0,[R4, #+0]
   \   0000001A   0x.... 0x....      BL       FMC_SDRAM_WriteProtection_Disable
    690            
    691            /* Update the SDRAM state */
    692            hsdram->State = HAL_SDRAM_STATE_READY;
   \   0000001E   0x2001             MOVS     R0,#+1
   \   00000020   0xF884 0x002C      STRB     R0,[R4, #+44]
    693            
    694            return HAL_OK;
   \   00000024   0x2000             MOVS     R0,#+0
   \                     ??HAL_SDRAM_WriteProtection_Disable_1: (+1)
   \   00000026   0xBD10             POP      {R4,PC}          ;; return
    695          }
    696          
    697          /**
    698            * @brief  Sends Command to the SDRAM bank.
    699            * @param  hsdram: pointer to a SDRAM_HandleTypeDef structure that contains
    700            *                the configuration information for SDRAM module.
    701            * @param  Command: SDRAM command structure
    702            * @param  Timeout: Timeout duration
    703            * @retval HAL status
    704            */  

   \                                 In section .text, align 2, keep-with-next
    705          HAL_StatusTypeDef HAL_SDRAM_SendCommand(SDRAM_HandleTypeDef *hsdram, FMC_SDRAM_CommandTypeDef *Command, uint32_t Timeout)
    706          {
   \                     HAL_SDRAM_SendCommand: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    707            /* Check the SDRAM controller state */
    708            if(hsdram->State == HAL_SDRAM_STATE_BUSY)
   \   00000008   0xF894 0x002C      LDRB     R0,[R4, #+44]
   \   0000000C   0x2802             CMP      R0,#+2
   \   0000000E   0xD101             BNE.N    ??HAL_SDRAM_SendCommand_0
    709            {
    710              return HAL_BUSY;
   \   00000010   0x2002             MOVS     R0,#+2
   \   00000012   0xE012             B.N      ??HAL_SDRAM_SendCommand_1
    711            }
    712            
    713            /* Update the SDRAM state */
    714            hsdram->State = HAL_SDRAM_STATE_BUSY;
   \                     ??HAL_SDRAM_SendCommand_0: (+1)
   \   00000014   0x2002             MOVS     R0,#+2
   \   00000016   0xF884 0x002C      STRB     R0,[R4, #+44]
    715            
    716            /* Send SDRAM command */
    717            FMC_SDRAM_SendCommand(hsdram->Instance, Command, Timeout);
   \   0000001A   0x0032             MOVS     R2,R6
   \   0000001C   0x0029             MOVS     R1,R5
   \   0000001E   0x6820             LDR      R0,[R4, #+0]
   \   00000020   0x.... 0x....      BL       FMC_SDRAM_SendCommand
    718            
    719            /* Update the SDRAM controller state state */
    720            if(Command->CommandMode == FMC_SDRAM_CMD_PALL)
   \   00000024   0x6828             LDR      R0,[R5, #+0]
   \   00000026   0x2802             CMP      R0,#+2
   \   00000028   0xD103             BNE.N    ??HAL_SDRAM_SendCommand_2
    721            {
    722              hsdram->State = HAL_SDRAM_STATE_PRECHARGED;
   \   0000002A   0x2005             MOVS     R0,#+5
   \   0000002C   0xF884 0x002C      STRB     R0,[R4, #+44]
   \   00000030   0xE002             B.N      ??HAL_SDRAM_SendCommand_3
    723            }
    724            else
    725            {
    726              hsdram->State = HAL_SDRAM_STATE_READY;
   \                     ??HAL_SDRAM_SendCommand_2: (+1)
   \   00000032   0x2001             MOVS     R0,#+1
   \   00000034   0xF884 0x002C      STRB     R0,[R4, #+44]
    727            }
    728            
    729            return HAL_OK;  
   \                     ??HAL_SDRAM_SendCommand_3: (+1)
   \   00000038   0x2000             MOVS     R0,#+0
   \                     ??HAL_SDRAM_SendCommand_1: (+1)
   \   0000003A   0xBD70             POP      {R4-R6,PC}       ;; return
    730          }
    731          
    732          /**
    733            * @brief  Programs the SDRAM Memory Refresh rate.
    734            * @param  hsdram: pointer to a SDRAM_HandleTypeDef structure that contains
    735            *                the configuration information for SDRAM module.  
    736            * @param  RefreshRate: The SDRAM refresh rate value       
    737            * @retval HAL status
    738            */

   \                                 In section .text, align 2, keep-with-next
    739          HAL_StatusTypeDef HAL_SDRAM_ProgramRefreshRate(SDRAM_HandleTypeDef *hsdram, uint32_t RefreshRate)
    740          {
   \                     HAL_SDRAM_ProgramRefreshRate: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    741            /* Check the SDRAM controller state */
    742            if(hsdram->State == HAL_SDRAM_STATE_BUSY)
   \   00000006   0xF894 0x002C      LDRB     R0,[R4, #+44]
   \   0000000A   0x2802             CMP      R0,#+2
   \   0000000C   0xD101             BNE.N    ??HAL_SDRAM_ProgramRefreshRate_0
    743            {
    744              return HAL_BUSY;
   \   0000000E   0x2002             MOVS     R0,#+2
   \   00000010   0xE00A             B.N      ??HAL_SDRAM_ProgramRefreshRate_1
    745            } 
    746            
    747            /* Update the SDRAM state */
    748            hsdram->State = HAL_SDRAM_STATE_BUSY;
   \                     ??HAL_SDRAM_ProgramRefreshRate_0: (+1)
   \   00000012   0x2002             MOVS     R0,#+2
   \   00000014   0xF884 0x002C      STRB     R0,[R4, #+44]
    749            
    750            /* Program the refresh rate */
    751            FMC_SDRAM_ProgramRefreshRate(hsdram->Instance ,RefreshRate);
   \   00000018   0x0029             MOVS     R1,R5
   \   0000001A   0x6820             LDR      R0,[R4, #+0]
   \   0000001C   0x.... 0x....      BL       FMC_SDRAM_ProgramRefreshRate
    752            
    753            /* Update the SDRAM state */
    754            hsdram->State = HAL_SDRAM_STATE_READY;
   \   00000020   0x2001             MOVS     R0,#+1
   \   00000022   0xF884 0x002C      STRB     R0,[R4, #+44]
    755            
    756            return HAL_OK;   
   \   00000026   0x2000             MOVS     R0,#+0
   \                     ??HAL_SDRAM_ProgramRefreshRate_1: (+1)
   \   00000028   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    757          }
    758          
    759          /**
    760            * @brief  Sets the Number of consecutive SDRAM Memory auto Refresh commands.
    761            * @param  hsdram: pointer to a SDRAM_HandleTypeDef structure that contains
    762            *                the configuration information for SDRAM module.  
    763            * @param  AutoRefreshNumber: The SDRAM auto Refresh number       
    764            * @retval HAL status
    765            */

   \                                 In section .text, align 2, keep-with-next
    766          HAL_StatusTypeDef HAL_SDRAM_SetAutoRefreshNumber(SDRAM_HandleTypeDef *hsdram, uint32_t AutoRefreshNumber)
    767          {
   \                     HAL_SDRAM_SetAutoRefreshNumber: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    768            /* Check the SDRAM controller state */
    769            if(hsdram->State == HAL_SDRAM_STATE_BUSY)
   \   00000006   0xF894 0x002C      LDRB     R0,[R4, #+44]
   \   0000000A   0x2802             CMP      R0,#+2
   \   0000000C   0xD101             BNE.N    ??HAL_SDRAM_SetAutoRefreshNumber_0
    770            {
    771              return HAL_BUSY;
   \   0000000E   0x2002             MOVS     R0,#+2
   \   00000010   0xE00A             B.N      ??HAL_SDRAM_SetAutoRefreshNumber_1
    772            } 
    773            
    774            /* Update the SDRAM state */
    775            hsdram->State = HAL_SDRAM_STATE_BUSY;
   \                     ??HAL_SDRAM_SetAutoRefreshNumber_0: (+1)
   \   00000012   0x2002             MOVS     R0,#+2
   \   00000014   0xF884 0x002C      STRB     R0,[R4, #+44]
    776            
    777            /* Set the Auto-Refresh number */
    778            FMC_SDRAM_SetAutoRefreshNumber(hsdram->Instance ,AutoRefreshNumber);
   \   00000018   0x0029             MOVS     R1,R5
   \   0000001A   0x6820             LDR      R0,[R4, #+0]
   \   0000001C   0x.... 0x....      BL       FMC_SDRAM_SetAutoRefreshNumber
    779            
    780            /* Update the SDRAM state */
    781            hsdram->State = HAL_SDRAM_STATE_READY;
   \   00000020   0x2001             MOVS     R0,#+1
   \   00000022   0xF884 0x002C      STRB     R0,[R4, #+44]
    782            
    783            return HAL_OK;
   \   00000026   0x2000             MOVS     R0,#+0
   \                     ??HAL_SDRAM_SetAutoRefreshNumber_1: (+1)
   \   00000028   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    784          }
    785          
    786          /**
    787            * @brief  Returns the SDRAM memory current mode.
    788            * @param  hsdram: pointer to a SDRAM_HandleTypeDef structure that contains
    789            *                the configuration information for SDRAM module.
    790            * @retval The SDRAM memory mode.        
    791            */

   \                                 In section .text, align 2, keep-with-next
    792          uint32_t HAL_SDRAM_GetModeStatus(SDRAM_HandleTypeDef *hsdram)
    793          {
   \                     HAL_SDRAM_GetModeStatus: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    794            /* Return the SDRAM memory current mode */
    795            return(FMC_SDRAM_GetModeStatus(hsdram->Instance, hsdram->Init.SDBank));
   \   00000004   0x6861             LDR      R1,[R4, #+4]
   \   00000006   0x6820             LDR      R0,[R4, #+0]
   \   00000008   0x.... 0x....      BL       FMC_SDRAM_GetModeStatus
   \   0000000C   0xBD10             POP      {R4,PC}          ;; return
    796          }
    797          
    798          /**
    799            * @}
    800            */
    801            
    802          /** @defgroup SDRAM_Exported_Functions_Group4 State functions 
    803           *  @brief   Peripheral State functions 
    804           *
    805          @verbatim   
    806            ==============================================================================
    807                                ##### SDRAM State functions #####
    808            ==============================================================================  
    809            [..]
    810              This subsection permits to get in run-time the status of the SDRAM controller 
    811              and the data flow.
    812          
    813          @endverbatim
    814            * @{
    815            */
    816          
    817          /**
    818            * @brief  Returns the SDRAM state.
    819            * @param  hsdram: pointer to a SDRAM_HandleTypeDef structure that contains
    820            *                the configuration information for SDRAM module.
    821            * @retval HAL state
    822            */

   \                                 In section .text, align 2, keep-with-next
    823          HAL_SDRAM_StateTypeDef HAL_SDRAM_GetState(SDRAM_HandleTypeDef *hsdram)
    824          {
    825            return hsdram->State;
   \                     HAL_SDRAM_GetState: (+1)
   \   00000000   0xF890 0x002C      LDRB     R0,[R0, #+44]
   \   00000004   0x4770             BX       LR               ;; return
    826          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1:
   \   00000000   0x........         DC32     HAL_SDRAM_DMA_XferCpltCallback

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_1:
   \   00000000   0x........         DC32     HAL_SDRAM_DMA_XferErrorCallback
    827          
    828          /**
    829            * @}
    830            */    
    831          
    832          /**
    833            * @}
    834            */
    835          #endif /* HAL_SDRAM_MODULE_ENABLED */
    836          /**
    837            * @}
    838            */
    839          
    840          /**
    841            * @}
    842            */
    843          
    844          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   HAL_SDRAM_DMA_XferCpltCallback
       0   HAL_SDRAM_DMA_XferErrorCallback
       8   HAL_SDRAM_DeInit
         8   -> FMC_SDRAM_DeInit
         8   -> HAL_SDRAM_MspDeInit
       8   HAL_SDRAM_GetModeStatus
         8   -> FMC_SDRAM_GetModeStatus
       0   HAL_SDRAM_GetState
       8   HAL_SDRAM_IRQHandler
         8   -> HAL_SDRAM_RefreshErrorCallback
      16   HAL_SDRAM_Init
        16   -> FMC_SDRAM_Init
        16   -> FMC_SDRAM_Timing_Init
        16   -> HAL_SDRAM_MspInit
       0   HAL_SDRAM_MspDeInit
       0   HAL_SDRAM_MspInit
      16   HAL_SDRAM_ProgramRefreshRate
        16   -> FMC_SDRAM_ProgramRefreshRate
       8   HAL_SDRAM_Read_16b
       8   HAL_SDRAM_Read_32b
       8   HAL_SDRAM_Read_8b
      24   HAL_SDRAM_Read_DMA
        24   -> HAL_DMA_Start_IT
       0   HAL_SDRAM_RefreshErrorCallback
      16   HAL_SDRAM_SendCommand
        16   -> FMC_SDRAM_SendCommand
      16   HAL_SDRAM_SetAutoRefreshNumber
        16   -> FMC_SDRAM_SetAutoRefreshNumber
       8   HAL_SDRAM_WriteProtection_Disable
         8   -> FMC_SDRAM_WriteProtection_Disable
       8   HAL_SDRAM_WriteProtection_Enable
         8   -> FMC_SDRAM_WriteProtection_Enable
      12   HAL_SDRAM_Write_16b
      12   HAL_SDRAM_Write_32b
      12   HAL_SDRAM_Write_8b
      24   HAL_SDRAM_Write_DMA
        24   -> HAL_DMA_Start_IT


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable1
       4  ??DataTable1_1
       2  HAL_SDRAM_DMA_XferCpltCallback
       2  HAL_SDRAM_DMA_XferErrorCallback
      34  HAL_SDRAM_DeInit
      14  HAL_SDRAM_GetModeStatus
       6  HAL_SDRAM_GetState
      32  HAL_SDRAM_IRQHandler
      68  HAL_SDRAM_Init
       2  HAL_SDRAM_MspDeInit
       2  HAL_SDRAM_MspInit
      42  HAL_SDRAM_ProgramRefreshRate
      76  HAL_SDRAM_Read_16b
      76  HAL_SDRAM_Read_32b
      76  HAL_SDRAM_Read_8b
      96  HAL_SDRAM_Read_DMA
       2  HAL_SDRAM_RefreshErrorCallback
      60  HAL_SDRAM_SendCommand
      42  HAL_SDRAM_SetAutoRefreshNumber
      40  HAL_SDRAM_WriteProtection_Disable
      40  HAL_SDRAM_WriteProtection_Enable
      80  HAL_SDRAM_Write_16b
      80  HAL_SDRAM_Write_32b
      80  HAL_SDRAM_Write_8b
     102  HAL_SDRAM_Write_DMA

 
 1 062 bytes in section .text
 
 1 062 bytes of CODE memory

Errors: none
Warnings: none
