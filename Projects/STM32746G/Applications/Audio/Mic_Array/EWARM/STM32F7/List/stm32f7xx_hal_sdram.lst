###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.2.10312/W32 for ARM       20/Dec/2015  12:46:44
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_sdram.c
#    Command line =  
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_sdram.c
#        -D USE_HAL_DRIVER -D STM32F746xx -D USE_STM32746G_DISCO -D
#        USE_IOEXPANDER -D USE_USB_FS -lC
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
#        -lA
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
#        -o
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj
#        --debug --endian=little --cpu=Cortex-M7 -e --fpu=VFPv5_sp
#        --dlib_config "D:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Full.h" -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\Inc\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\CMSIS\Device\ST\STM32F7xx\Include\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\STM32F7xx_HAL_Driver\Inc\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\STM32746G-Discovery\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\Components\Common\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Log\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Fonts\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\CPU\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_Device_Library\Core\Inc\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Core\Inc\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Class\MSC\Inc\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\drivers\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_Audio\Addons\PDM\
#        -Ohz --use_c++_inline --require_prototypes -I "D:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.3\arm\CMSIS\Include\" -D
#        ARM_MATH_CM7
#    List file    =  
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List\stm32f7xx_hal_sdram.lst
#    Object file  =  
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj\stm32f7xx_hal_sdram.o
#
###############################################################################

H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_sdram.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f7xx_hal_sdram.c
      4            * @author  MCD Application Team
      5            * @version V1.0.1
      6            * @date    25-June-2015
      7            * @brief   SDRAM HAL module driver.
      8            *          This file provides a generic firmware to drive SDRAM memories mounted 
      9            *          as external device.
     10            *         
     11            @verbatim
     12            ==============================================================================
     13                                 ##### How to use this driver #####
     14            ============================================================================== 
     15            [..]
     16              This driver is a generic layered driver which contains a set of APIs used to 
     17              control SDRAM memories. It uses the FMC layer functions to interface 
     18              with SDRAM devices.  
     19              The following sequence should be followed to configure the FMC to interface
     20              with SDRAM memories: 
     21                
     22             (#) Declare a SDRAM_HandleTypeDef handle structure, for example:
     23                    SDRAM_HandleTypeDef  hdsram 
     24                    
     25                 (++) Fill the SDRAM_HandleTypeDef handle "Init" field with the allowed 
     26                      values of the structure member.
     27                      
     28                 (++) Fill the SDRAM_HandleTypeDef handle "Instance" field with a predefined 
     29                      base register instance for NOR or SDRAM device 
     30                       
     31             (#) Declare a FMC_SDRAM_TimingTypeDef structure; for example:
     32                    FMC_SDRAM_TimingTypeDef  Timing;
     33                and fill its fields with the allowed values of the structure member.
     34                
     35             (#) Initialize the SDRAM Controller by calling the function HAL_SDRAM_Init(). This function
     36                 performs the following sequence:
     37                    
     38                 (##) MSP hardware layer configuration using the function HAL_SDRAM_MspInit()
     39                 (##) Control register configuration using the FMC SDRAM interface function 
     40                      FMC_SDRAM_Init()
     41                 (##) Timing register configuration using the FMC SDRAM interface function 
     42                      FMC_SDRAM_Timing_Init()
     43                 (##) Program the SDRAM external device by applying its initialization sequence
     44                      according to the device plugged in your hardware. This step is mandatory
     45                      for accessing the SDRAM device.   
     46          
     47             (#) At this stage you can perform read/write accesses from/to the memory connected 
     48                 to the SDRAM Bank. You can perform either polling or DMA transfer using the
     49                 following APIs:
     50                 (++) HAL_SDRAM_Read()/HAL_SDRAM_Write() for polling read/write access
     51                 (++) HAL_SDRAM_Read_DMA()/HAL_SDRAM_Write_DMA() for DMA read/write transfer
     52                 
     53             (#) You can also control the SDRAM device by calling the control APIs HAL_SDRAM_WriteOperation_Enable()/
     54                 HAL_SDRAM_WriteOperation_Disable() to respectively enable/disable the SDRAM write operation or 
     55                 the function HAL_SDRAM_SendCommand() to send a specified command to the SDRAM
     56                 device. The command to be sent must be configured with the FMC_SDRAM_CommandTypeDef 
     57                 structure.   
     58                 
     59             (#) You can continuously monitor the SDRAM device HAL state by calling the function
     60                 HAL_SDRAM_GetState()         
     61                
     62            @endverbatim
     63            ******************************************************************************
     64            * @attention
     65            *
     66            * <h2><center>&copy; COPYRIGHT(c) 2015 STMicroelectronics</center></h2>
     67            *
     68            * Redistribution and use in source and binary forms, with or without modification,
     69            * are permitted provided that the following conditions are met:
     70            *   1. Redistributions of source code must retain the above copyright notice,
     71            *      this list of conditions and the following disclaimer.
     72            *   2. Redistributions in binary form must reproduce the above copyright notice,
     73            *      this list of conditions and the following disclaimer in the documentation
     74            *      and/or other materials provided with the distribution.
     75            *   3. Neither the name of STMicroelectronics nor the names of its contributors
     76            *      may be used to endorse or promote products derived from this software
     77            *      without specific prior written permission.
     78            *
     79            * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
     80            * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     81            * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     82            * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
     83            * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
     84            * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
     85            * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
     86            * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
     87            * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
     88            * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     89            *
     90            ******************************************************************************
     91            */ 
     92          
     93          /* Includes ------------------------------------------------------------------*/
     94          #include "stm32f7xx_hal.h"
     95          
     96          /** @addtogroup STM32F7xx_HAL_Driver
     97            * @{
     98            */
     99          
    100          /** @defgroup SDRAM SDRAM
    101            * @brief SDRAM driver modules
    102            * @{
    103            */
    104          #ifdef HAL_SDRAM_MODULE_ENABLED
    105          
    106          /* Private typedef -----------------------------------------------------------*/
    107          /* Private define ------------------------------------------------------------*/
    108          /* Private macro -------------------------------------------------------------*/    
    109          /* Private variables ---------------------------------------------------------*/
    110          /* Private functions ---------------------------------------------------------*/
    111          /* Exported functions --------------------------------------------------------*/
    112          /** @defgroup SDRAM_Exported_Functions SDRAM Exported Functions
    113            * @{
    114            */
    115          
    116          /** @defgroup SDRAM_Exported_Functions_Group1 Initialization and de-initialization functions 
    117            * @brief    Initialization and Configuration functions 
    118            *
    119            @verbatim    
    120            ==============================================================================
    121                     ##### SDRAM Initialization and de_initialization functions #####
    122            ==============================================================================
    123            [..]  
    124              This section provides functions allowing to initialize/de-initialize
    125              the SDRAM memory
    126            
    127          @endverbatim
    128            * @{
    129            */
    130              
    131          /**
    132            * @brief  Performs the SDRAM device initialization sequence.
    133            * @param  hsdram: pointer to a SDRAM_HandleTypeDef structure that contains
    134            *                the configuration information for SDRAM module.
    135            * @param  Timing: Pointer to SDRAM control timing structure 
    136            * @retval HAL status
    137            */

   \                                 In section .text, align 2, keep-with-next
    138          HAL_StatusTypeDef HAL_SDRAM_Init(SDRAM_HandleTypeDef *hsdram, FMC_SDRAM_TimingTypeDef *Timing)
    139          {   
   \                     HAL_SDRAM_Init: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x460D             MOV      R5,R1
    140            /* Check the SDRAM handle parameter */
    141            if(hsdram == NULL)
   \   00000006   0xD101             BNE.N    ??HAL_SDRAM_Init_0
    142            {
    143              return HAL_ERROR;
   \   00000008   0x2001             MOVS     R0,#+1
   \   0000000A   0xBD70             POP      {R4-R6,PC}
    144            }
    145            
    146            if(hsdram->State == HAL_SDRAM_STATE_RESET)
   \                     ??HAL_SDRAM_Init_0: (+1)
   \   0000000C   0xF104 0x062C      ADD      R6,R4,#+44
   \   00000010   0x7830             LDRB     R0,[R6, #+0]
   \   00000012   0xB918             CBNZ.N   R0,??HAL_SDRAM_Init_1
    147            {  
    148              /* Allocate lock resource and initialize it */
    149              hsdram->Lock = HAL_UNLOCKED;
   \   00000014   0x7070             STRB     R0,[R6, #+1]
    150              /* Initialize the low level hardware (MSP) */
    151              HAL_SDRAM_MspInit(hsdram);
   \   00000016   0x4620             MOV      R0,R4
   \   00000018   0x.... 0x....      BL       HAL_SDRAM_MspInit
    152            }
    153            
    154            /* Initialize the SDRAM controller state */
    155            hsdram->State = HAL_SDRAM_STATE_BUSY;
   \                     ??HAL_SDRAM_Init_1: (+1)
   \   0000001C   0x2002             MOVS     R0,#+2
    156            
    157            /* Initialize SDRAM control Interface */
    158            FMC_SDRAM_Init(hsdram->Instance, &(hsdram->Init));
   \   0000001E   0x1D21             ADDS     R1,R4,#+4
   \   00000020   0x7030             STRB     R0,[R6, #+0]
   \   00000022   0x6820             LDR      R0,[R4, #+0]
   \   00000024   0x.... 0x....      BL       FMC_SDRAM_Init
    159            
    160            /* Initialize SDRAM timing Interface */
    161            FMC_SDRAM_Timing_Init(hsdram->Instance, Timing, hsdram->Init.SDBank); 
   \   00000028   0x6862             LDR      R2,[R4, #+4]
   \   0000002A   0x6820             LDR      R0,[R4, #+0]
   \   0000002C   0x4629             MOV      R1,R5
   \   0000002E   0x.... 0x....      BL       FMC_SDRAM_Timing_Init
    162            
    163            /* Update the SDRAM controller state */
    164            hsdram->State = HAL_SDRAM_STATE_READY;
   \   00000032   0x2001             MOVS     R0,#+1
   \   00000034   0x7030             STRB     R0,[R6, #+0]
    165            
    166            return HAL_OK;
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0xBD70             POP      {R4-R6,PC}       ;; return
    167          }
    168          
    169          /**
    170            * @brief  Perform the SDRAM device initialization sequence.
    171            * @param  hsdram: pointer to a SDRAM_HandleTypeDef structure that contains
    172            *                the configuration information for SDRAM module.
    173            * @retval HAL status
    174            */

   \                                 In section .text, align 2, keep-with-next
    175          HAL_StatusTypeDef HAL_SDRAM_DeInit(SDRAM_HandleTypeDef *hsdram)
    176          {
   \                     HAL_SDRAM_DeInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    177            /* Initialize the low level hardware (MSP) */
    178            HAL_SDRAM_MspDeInit(hsdram);
   \   00000004   0x.... 0x....      BL       HAL_SDRAM_MspDeInit
    179          
    180            /* Configure the SDRAM registers with their reset values */
    181            FMC_SDRAM_DeInit(hsdram->Instance, hsdram->Init.SDBank);
   \   00000008   0x6861             LDR      R1,[R4, #+4]
   \   0000000A   0x6820             LDR      R0,[R4, #+0]
   \   0000000C   0x.... 0x....      BL       FMC_SDRAM_DeInit
    182          
    183            /* Reset the SDRAM controller state */
    184            hsdram->State = HAL_SDRAM_STATE_RESET;
   \   00000010   0xF104 0x002C      ADD      R0,R4,#+44
   \   00000014   0x2100             MOVS     R1,#+0
   \   00000016   0x7001             STRB     R1,[R0, #+0]
    185          
    186            /* Release Lock */
    187            __HAL_UNLOCK(hsdram);
   \   00000018   0x....             B.N      ??Subroutine0_0
    188          
    189            return HAL_OK;
    190          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \                     ??Subroutine0_0: (+1)
   \   00000002   0x7041             STRB     R1,[R0, #+1]
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0xBD10             POP      {R4,PC}          ;; return
    191          
    192          /**
    193            * @brief  SDRAM MSP Init.
    194            * @param  hsdram: pointer to a SDRAM_HandleTypeDef structure that contains
    195            *                the configuration information for SDRAM module.
    196            * @retval None
    197            */

   \                                 In section .text, align 2, keep-with-next
    198          __weak void HAL_SDRAM_MspInit(SDRAM_HandleTypeDef *hsdram)
    199          {
    200            /* NOTE: This function Should not be modified, when the callback is needed,
    201                      the HAL_SDRAM_MspInit could be implemented in the user file
    202             */ 
    203          }
   \                     HAL_SDRAM_MspInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    204          
    205          /**
    206            * @brief  SDRAM MSP DeInit.
    207            * @param  hsdram: pointer to a SDRAM_HandleTypeDef structure that contains
    208            *                the configuration information for SDRAM module.
    209            * @retval None
    210            */

   \                                 In section .text, align 2, keep-with-next
    211          __weak void HAL_SDRAM_MspDeInit(SDRAM_HandleTypeDef *hsdram)
    212          {
    213            /* NOTE: This function Should not be modified, when the callback is needed,
    214                      the HAL_SDRAM_MspDeInit could be implemented in the user file
    215             */ 
    216          }
   \                     HAL_SDRAM_MspDeInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    217          
    218          /**
    219            * @brief  This function handles SDRAM refresh error interrupt request.
    220            * @param  hsdram: pointer to a SDRAM_HandleTypeDef structure that contains
    221            *                the configuration information for SDRAM module.
    222            * @retval HAL status
    223          */

   \                                 In section .text, align 2, keep-with-next
    224          void HAL_SDRAM_IRQHandler(SDRAM_HandleTypeDef *hsdram)
    225          {
   \                     HAL_SDRAM_IRQHandler: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    226            /* Check SDRAM interrupt Rising edge flag */
    227            if(__FMC_SDRAM_GET_FLAG(hsdram->Instance, FMC_SDRAM_FLAG_REFRESH_IT))
   \   00000004   0x6820             LDR      R0,[R4, #+0]
   \   00000006   0x6980             LDR      R0,[R0, #+24]
   \   00000008   0x07C0             LSLS     R0,R0,#+31
   \   0000000A   0xD507             BPL.N    ??HAL_SDRAM_IRQHandler_0
    228            {
    229              /* SDRAM refresh error interrupt callback */
    230              HAL_SDRAM_RefreshErrorCallback(hsdram);
   \   0000000C   0x4620             MOV      R0,R4
   \   0000000E   0x.... 0x....      BL       HAL_SDRAM_RefreshErrorCallback
    231              
    232              /* Clear SDRAM refresh error interrupt pending bit */
    233              __FMC_SDRAM_CLEAR_FLAG(hsdram->Instance, FMC_SDRAM_FLAG_REFRESH_ERROR);
   \   00000012   0x6820             LDR      R0,[R4, #+0]
   \   00000014   0x6941             LDR      R1,[R0, #+20]
   \   00000016   0xF041 0x0101      ORR      R1,R1,#0x1
   \   0000001A   0x6141             STR      R1,[R0, #+20]
    234            }
    235          }
   \                     ??HAL_SDRAM_IRQHandler_0: (+1)
   \   0000001C   0xBD10             POP      {R4,PC}          ;; return
    236          
    237          /**
    238            * @brief  SDRAM Refresh error callback.
    239            * @param  hsdram: pointer to a SDRAM_HandleTypeDef structure that contains
    240            *                the configuration information for SDRAM module. 
    241            * @retval None
    242            */

   \                                 In section .text, align 2, keep-with-next
    243          __weak void HAL_SDRAM_RefreshErrorCallback(SDRAM_HandleTypeDef *hsdram)
    244          {
    245            /* NOTE: This function Should not be modified, when the callback is needed,
    246                      the HAL_SDRAM_RefreshErrorCallback could be implemented in the user file
    247             */ 
    248          }
   \                     HAL_SDRAM_RefreshErrorCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    249          
    250          /**
    251            * @brief  DMA transfer complete callback.
    252            * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
    253            *                the configuration information for the specified DMA module.
    254            * @retval None
    255            */

   \                                 In section .text, align 2, keep-with-next
    256          __weak void HAL_SDRAM_DMA_XferCpltCallback(DMA_HandleTypeDef *hdma)
    257          {
    258            /* NOTE: This function Should not be modified, when the callback is needed,
    259                      the HAL_SDRAM_DMA_XferCpltCallback could be implemented in the user file
    260             */ 
    261          }
   \                     HAL_SDRAM_DMA_XferCpltCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    262          
    263          /**
    264            * @brief  DMA transfer complete error callback.
    265            * @param  hdma: DMA handle
    266            * @retval None
    267            */

   \                                 In section .text, align 2, keep-with-next
    268          __weak void HAL_SDRAM_DMA_XferErrorCallback(DMA_HandleTypeDef *hdma)
    269          {
    270            /* NOTE: This function Should not be modified, when the callback is needed,
    271                      the HAL_SDRAM_DMA_XferErrorCallback could be implemented in the user file
    272             */ 
    273          }
   \                     HAL_SDRAM_DMA_XferErrorCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    274          
    275          /**
    276            * @}
    277            */
    278          
    279          /** @defgroup SDRAM_Exported_Functions_Group2 Input and Output functions 
    280            * @brief    Input Output and memory control functions 
    281            *
    282            @verbatim    
    283            ==============================================================================
    284                              ##### SDRAM Input and Output functions #####
    285            ==============================================================================
    286            [..]  
    287              This section provides functions allowing to use and control the SDRAM memory
    288            
    289          @endverbatim
    290            * @{
    291            */
    292          
    293          /**
    294            * @brief  Reads 8-bit data buffer from the SDRAM memory.
    295            * @param  hsdram: pointer to a SDRAM_HandleTypeDef structure that contains
    296            *                the configuration information for SDRAM module.
    297            * @param  pAddress: Pointer to read start address
    298            * @param  pDstBuffer: Pointer to destination buffer  
    299            * @param  BufferSize: Size of the buffer to read from memory
    300            * @retval HAL status
    301            */

   \                                 In section .text, align 2, keep-with-next
    302          HAL_StatusTypeDef HAL_SDRAM_Read_8b(SDRAM_HandleTypeDef *hsdram, uint32_t *pAddress, uint8_t *pDstBuffer, uint32_t BufferSize)
    303          {
    304            __IO uint8_t *pSdramAddress = (uint8_t *)pAddress;
    305            
    306            /* Process Locked */
    307            __HAL_LOCK(hsdram);
   \                     HAL_SDRAM_Read_8b: (+1)
   \   00000000   0x302C             ADDS     R0,R0,#+44
   \   00000002   0xB510             PUSH     {R4,LR}
   \   00000004   0x7844             LDRB     R4,[R0, #+1]
   \   00000006   0x2C01             CMP      R4,#+1
   \   00000008   0xBF1F             ITTTT    NE 
   \   0000000A   0x2401             MOVNE    R4,#+1
   \   0000000C   0x7044             STRBNE   R4,[R0, #+1]
   \   0000000E   0x7804             LDRBNE   R4,[R0, #+0]
   \   00000010   0x2C02             CMPNE    R4,#+2
    308            
    309            /* Check the SDRAM controller state */
    310            if(hsdram->State == HAL_SDRAM_STATE_BUSY)
   \   00000012   0xD101             BNE.N    ??HAL_SDRAM_Read_8b_0
    311            {
    312              return HAL_BUSY;
   \   00000014   0x2002             MOVS     R0,#+2
   \   00000016   0xBD10             POP      {R4,PC}
    313            }
    314            else if(hsdram->State == HAL_SDRAM_STATE_PRECHARGED)
   \                     ??HAL_SDRAM_Read_8b_0: (+1)
   \   00000018   0x7804             LDRB     R4,[R0, #+0]
   \   0000001A   0x2C05             CMP      R4,#+5
   \   0000001C   0xD106             BNE.N    ??HAL_SDRAM_Read_8b_1
    315            {
    316              return  HAL_ERROR; 
   \   0000001E   0x2001             MOVS     R0,#+1
   \   00000020   0xBD10             POP      {R4,PC}
    317            }  
    318            
    319            /* Read data from source */
    320            for(; BufferSize != 0; BufferSize--)
    321            {
    322              *pDstBuffer = *(__IO uint8_t *)pSdramAddress;  
   \                     ??HAL_SDRAM_Read_8b_2: (+1)
   \   00000022   0xF811 0x4B01      LDRB     R4,[R1], #+1
    323              pDstBuffer++;
    324              pSdramAddress++;
    325            }
   \   00000026   0x1E5B             SUBS     R3,R3,#+1
   \   00000028   0xF802 0x4B01      STRB     R4,[R2], #+1
   \                     ??HAL_SDRAM_Read_8b_1: (+1)
   \   0000002C   0x2B00             CMP      R3,#+0
   \   0000002E   0xD1F8             BNE.N    ??HAL_SDRAM_Read_8b_2
    326            
    327            /* Process Unlocked */
    328            __HAL_UNLOCK(hsdram);
   \   00000030   0x....             B.N      ?Subroutine0
    329            
    330            return HAL_OK; 
    331          }
    332          
    333          
    334          /**
    335            * @brief  Writes 8-bit data buffer to SDRAM memory.
    336            * @param  hsdram: pointer to a SDRAM_HandleTypeDef structure that contains
    337            *                the configuration information for SDRAM module.
    338            * @param  pAddress: Pointer to write start address
    339            * @param  pSrcBuffer: Pointer to source buffer to write  
    340            * @param  BufferSize: Size of the buffer to write to memory
    341            * @retval HAL status
    342            */

   \                                 In section .text, align 2, keep-with-next
    343          HAL_StatusTypeDef HAL_SDRAM_Write_8b(SDRAM_HandleTypeDef *hsdram, uint32_t *pAddress, uint8_t *pSrcBuffer, uint32_t BufferSize)
    344          {
    345            __IO uint8_t *pSdramAddress = (uint8_t *)pAddress;
    346            uint32_t tmp = 0;
    347            
    348            /* Process Locked */
    349            __HAL_LOCK(hsdram);
   \                     HAL_SDRAM_Write_8b: (+1)
   \   00000000   0x302C             ADDS     R0,R0,#+44
   \   00000002   0xB510             PUSH     {R4,LR}
   \   00000004   0x7844             LDRB     R4,[R0, #+1]
   \   00000006   0x2C01             CMP      R4,#+1
   \   00000008   0xBF1F             ITTTT    NE 
   \   0000000A   0x2401             MOVNE    R4,#+1
   \   0000000C   0x7044             STRBNE   R4,[R0, #+1]
   \   0000000E   0x7804             LDRBNE   R4,[R0, #+0]
   \   00000010   0x2C02             CMPNE    R4,#+2
    350            
    351            /* Check the SDRAM controller state */
    352            tmp = hsdram->State;
    353            
    354            if(tmp == HAL_SDRAM_STATE_BUSY)
   \   00000012   0xD101             BNE.N    ??HAL_SDRAM_Write_8b_0
    355            {
    356              return HAL_BUSY;
   \   00000014   0x2002             MOVS     R0,#+2
   \   00000016   0xBD10             POP      {R4,PC}
    357            }
    358            else if((tmp == HAL_SDRAM_STATE_PRECHARGED) || (tmp == HAL_SDRAM_STATE_WRITE_PROTECTED))
   \                     ??HAL_SDRAM_Write_8b_0: (+1)
   \   00000018   0x2C05             CMP      R4,#+5
   \   0000001A   0xBF18             IT       NE 
   \   0000001C   0x2C04             CMPNE    R4,#+4
   \   0000001E   0xD106             BNE.N    ??HAL_SDRAM_Write_8b_1
    359            {
    360              return  HAL_ERROR; 
   \   00000020   0x2001             MOVS     R0,#+1
   \   00000022   0xBD10             POP      {R4,PC}
    361            }
    362            
    363            /* Write data to memory */
    364            for(; BufferSize != 0; BufferSize--)
    365            {
    366              *(__IO uint8_t *)pSdramAddress = *pSrcBuffer;
   \                     ??HAL_SDRAM_Write_8b_2: (+1)
   \   00000024   0xF812 0x4B01      LDRB     R4,[R2], #+1
    367              pSrcBuffer++;
    368              pSdramAddress++;
    369            }
   \   00000028   0x1E5B             SUBS     R3,R3,#+1
   \   0000002A   0xF801 0x4B01      STRB     R4,[R1], #+1
   \                     ??HAL_SDRAM_Write_8b_1: (+1)
   \   0000002E   0x2B00             CMP      R3,#+0
   \   00000030   0xD1F8             BNE.N    ??HAL_SDRAM_Write_8b_2
    370            
    371            /* Process Unlocked */
    372            __HAL_UNLOCK(hsdram);    
   \   00000032                      REQUIRE ?Subroutine0
   \   00000032                      ;; // Fall through to label ?Subroutine0
    373            
    374            return HAL_OK;   
    375          }
    376          
    377          
    378          /**
    379            * @brief  Reads 16-bit data buffer from the SDRAM memory. 
    380            * @param  hsdram: pointer to a SDRAM_HandleTypeDef structure that contains
    381            *                the configuration information for SDRAM module.
    382            * @param  pAddress: Pointer to read start address
    383            * @param  pDstBuffer: Pointer to destination buffer  
    384            * @param  BufferSize: Size of the buffer to read from memory
    385            * @retval HAL status
    386            */

   \                                 In section .text, align 2, keep-with-next
    387          HAL_StatusTypeDef HAL_SDRAM_Read_16b(SDRAM_HandleTypeDef *hsdram, uint32_t *pAddress, uint16_t *pDstBuffer, uint32_t BufferSize)
    388          {
    389            __IO uint16_t *pSdramAddress = (uint16_t *)pAddress;
    390            
    391            /* Process Locked */
    392            __HAL_LOCK(hsdram);
   \                     HAL_SDRAM_Read_16b: (+1)
   \   00000000   0x302C             ADDS     R0,R0,#+44
   \   00000002   0xB510             PUSH     {R4,LR}
   \   00000004   0x7844             LDRB     R4,[R0, #+1]
   \   00000006   0x2C01             CMP      R4,#+1
   \   00000008   0xBF1F             ITTTT    NE 
   \   0000000A   0x2401             MOVNE    R4,#+1
   \   0000000C   0x7044             STRBNE   R4,[R0, #+1]
   \   0000000E   0x7804             LDRBNE   R4,[R0, #+0]
   \   00000010   0x2C02             CMPNE    R4,#+2
    393            
    394            /* Check the SDRAM controller state */
    395            if(hsdram->State == HAL_SDRAM_STATE_BUSY)
   \   00000012   0xD101             BNE.N    ??HAL_SDRAM_Read_16b_0
    396            {
    397              return HAL_BUSY;
   \   00000014   0x2002             MOVS     R0,#+2
   \   00000016   0xBD10             POP      {R4,PC}
    398            }
    399            else if(hsdram->State == HAL_SDRAM_STATE_PRECHARGED)
   \                     ??HAL_SDRAM_Read_16b_0: (+1)
   \   00000018   0x7804             LDRB     R4,[R0, #+0]
   \   0000001A   0x2C05             CMP      R4,#+5
   \   0000001C   0xD106             BNE.N    ??HAL_SDRAM_Read_16b_1
    400            {
    401              return  HAL_ERROR; 
   \   0000001E   0x2001             MOVS     R0,#+1
   \   00000020   0xBD10             POP      {R4,PC}
    402            }  
    403            
    404            /* Read data from source */
    405            for(; BufferSize != 0; BufferSize--)
    406            {
    407              *pDstBuffer = *(__IO uint16_t *)pSdramAddress;  
   \                     ??HAL_SDRAM_Read_16b_2: (+1)
   \   00000022   0xF831 0x4B02      LDRH     R4,[R1], #+2
    408              pDstBuffer++;
    409              pSdramAddress++;               
    410            }
   \   00000026   0x1E5B             SUBS     R3,R3,#+1
   \   00000028   0xF822 0x4B02      STRH     R4,[R2], #+2
   \                     ??HAL_SDRAM_Read_16b_1: (+1)
   \   0000002C   0x2B00             CMP      R3,#+0
   \   0000002E   0xD1F8             BNE.N    ??HAL_SDRAM_Read_16b_2
    411            
    412            /* Process Unlocked */
    413            __HAL_UNLOCK(hsdram);       
   \   00000030   0x....             B.N      ?Subroutine0
    414            
    415            return HAL_OK; 
    416          }
    417          
    418          /**
    419            * @brief  Writes 16-bit data buffer to SDRAM memory. 
    420            * @param  hsdram: pointer to a SDRAM_HandleTypeDef structure that contains
    421            *                the configuration information for SDRAM module.
    422            * @param  pAddress: Pointer to write start address
    423            * @param  pSrcBuffer: Pointer to source buffer to write  
    424            * @param  BufferSize: Size of the buffer to write to memory
    425            * @retval HAL status
    426            */

   \                                 In section .text, align 2, keep-with-next
    427          HAL_StatusTypeDef HAL_SDRAM_Write_16b(SDRAM_HandleTypeDef *hsdram, uint32_t *pAddress, uint16_t *pSrcBuffer, uint32_t BufferSize)
    428          {
    429            __IO uint16_t *pSdramAddress = (uint16_t *)pAddress;
    430            uint32_t tmp = 0;
    431            
    432            /* Process Locked */
    433            __HAL_LOCK(hsdram);
   \                     HAL_SDRAM_Write_16b: (+1)
   \   00000000   0x302C             ADDS     R0,R0,#+44
   \   00000002   0xB510             PUSH     {R4,LR}
   \   00000004   0x7844             LDRB     R4,[R0, #+1]
   \   00000006   0x2C01             CMP      R4,#+1
   \   00000008   0xBF1F             ITTTT    NE 
   \   0000000A   0x2401             MOVNE    R4,#+1
   \   0000000C   0x7044             STRBNE   R4,[R0, #+1]
   \   0000000E   0x7804             LDRBNE   R4,[R0, #+0]
   \   00000010   0x2C02             CMPNE    R4,#+2
    434            
    435            /* Check the SDRAM controller state */
    436            tmp = hsdram->State;
    437            
    438            if(tmp == HAL_SDRAM_STATE_BUSY)
   \   00000012   0xD101             BNE.N    ??HAL_SDRAM_Write_16b_0
    439            {
    440              return HAL_BUSY;
   \   00000014   0x2002             MOVS     R0,#+2
   \   00000016   0xBD10             POP      {R4,PC}
    441            }
    442            else if((tmp == HAL_SDRAM_STATE_PRECHARGED) || (tmp == HAL_SDRAM_STATE_WRITE_PROTECTED))
   \                     ??HAL_SDRAM_Write_16b_0: (+1)
   \   00000018   0x2C05             CMP      R4,#+5
   \   0000001A   0xBF18             IT       NE 
   \   0000001C   0x2C04             CMPNE    R4,#+4
   \   0000001E   0xD106             BNE.N    ??HAL_SDRAM_Write_16b_1
    443            {
    444              return  HAL_ERROR; 
   \   00000020   0x2001             MOVS     R0,#+1
   \   00000022   0xBD10             POP      {R4,PC}
    445            }
    446            
    447            /* Write data to memory */
    448            for(; BufferSize != 0; BufferSize--)
    449            {
    450              *(__IO uint16_t *)pSdramAddress = *pSrcBuffer;
   \                     ??HAL_SDRAM_Write_16b_2: (+1)
   \   00000024   0xF832 0x4B02      LDRH     R4,[R2], #+2
    451              pSrcBuffer++;
    452              pSdramAddress++;            
    453            }
   \   00000028   0x1E5B             SUBS     R3,R3,#+1
   \   0000002A   0xF821 0x4B02      STRH     R4,[R1], #+2
   \                     ??HAL_SDRAM_Write_16b_1: (+1)
   \   0000002E   0x2B00             CMP      R3,#+0
   \   00000030   0xD1F8             BNE.N    ??HAL_SDRAM_Write_16b_2
    454            
    455            /* Process Unlocked */
    456            __HAL_UNLOCK(hsdram);    
   \   00000032   0x....             B.N      ?Subroutine0
    457            
    458            return HAL_OK;   
    459          }
    460          
    461          /**
    462            * @brief  Reads 32-bit data buffer from the SDRAM memory. 
    463            * @param  hsdram: pointer to a SDRAM_HandleTypeDef structure that contains
    464            *                the configuration information for SDRAM module.
    465            * @param  pAddress: Pointer to read start address
    466            * @param  pDstBuffer: Pointer to destination buffer  
    467            * @param  BufferSize: Size of the buffer to read from memory
    468            * @retval HAL status
    469            */

   \                                 In section .text, align 2, keep-with-next
    470          HAL_StatusTypeDef HAL_SDRAM_Read_32b(SDRAM_HandleTypeDef *hsdram, uint32_t *pAddress, uint32_t *pDstBuffer, uint32_t BufferSize)
    471          {
    472            __IO uint32_t *pSdramAddress = (uint32_t *)pAddress;
    473            
    474            /* Process Locked */
    475            __HAL_LOCK(hsdram);
   \                     HAL_SDRAM_Read_32b: (+1)
   \   00000000   0x302C             ADDS     R0,R0,#+44
   \   00000002   0xB510             PUSH     {R4,LR}
   \   00000004   0x7844             LDRB     R4,[R0, #+1]
   \   00000006   0x2C01             CMP      R4,#+1
   \   00000008   0xBF1F             ITTTT    NE 
   \   0000000A   0x2401             MOVNE    R4,#+1
   \   0000000C   0x7044             STRBNE   R4,[R0, #+1]
   \   0000000E   0x7804             LDRBNE   R4,[R0, #+0]
   \   00000010   0x2C02             CMPNE    R4,#+2
    476            
    477            /* Check the SDRAM controller state */
    478            if(hsdram->State == HAL_SDRAM_STATE_BUSY)
   \   00000012   0xD101             BNE.N    ??HAL_SDRAM_Read_32b_0
    479            {
    480              return HAL_BUSY;
   \   00000014   0x2002             MOVS     R0,#+2
   \   00000016   0xBD10             POP      {R4,PC}
    481            }
    482            else if(hsdram->State == HAL_SDRAM_STATE_PRECHARGED)
   \                     ??HAL_SDRAM_Read_32b_0: (+1)
   \   00000018   0x7804             LDRB     R4,[R0, #+0]
   \   0000001A   0x2C05             CMP      R4,#+5
   \   0000001C   0xD106             BNE.N    ??HAL_SDRAM_Read_32b_1
    483            {
    484              return  HAL_ERROR; 
   \   0000001E   0x2001             MOVS     R0,#+1
   \   00000020   0xBD10             POP      {R4,PC}
    485            }  
    486            
    487            /* Read data from source */
    488            for(; BufferSize != 0; BufferSize--)
    489            {
    490              *pDstBuffer = *(__IO uint32_t *)pSdramAddress;  
   \                     ??HAL_SDRAM_Read_32b_2: (+1)
   \   00000022   0xF851 0x4B04      LDR      R4,[R1], #+4
    491              pDstBuffer++;
    492              pSdramAddress++;               
    493            }
   \   00000026   0x1E5B             SUBS     R3,R3,#+1
   \   00000028   0xF842 0x4B04      STR      R4,[R2], #+4
   \                     ??HAL_SDRAM_Read_32b_1: (+1)
   \   0000002C   0x2B00             CMP      R3,#+0
   \   0000002E   0xD1F8             BNE.N    ??HAL_SDRAM_Read_32b_2
    494            
    495            /* Process Unlocked */
    496            __HAL_UNLOCK(hsdram);       
   \   00000030   0x....             B.N      ?Subroutine0
    497            
    498            return HAL_OK; 
    499          }
    500          
    501          /**
    502            * @brief  Writes 32-bit data buffer to SDRAM memory. 
    503            * @param  hsdram: pointer to a SDRAM_HandleTypeDef structure that contains
    504            *                the configuration information for SDRAM module.
    505            * @param  pAddress: Pointer to write start address
    506            * @param  pSrcBuffer: Pointer to source buffer to write  
    507            * @param  BufferSize: Size of the buffer to write to memory
    508            * @retval HAL status
    509            */

   \                                 In section .text, align 2, keep-with-next
    510          HAL_StatusTypeDef HAL_SDRAM_Write_32b(SDRAM_HandleTypeDef *hsdram, uint32_t *pAddress, uint32_t *pSrcBuffer, uint32_t BufferSize)
    511          {
    512            __IO uint32_t *pSdramAddress = (uint32_t *)pAddress;
    513            uint32_t tmp = 0;
    514            
    515            /* Process Locked */
    516            __HAL_LOCK(hsdram);
   \                     HAL_SDRAM_Write_32b: (+1)
   \   00000000   0x302C             ADDS     R0,R0,#+44
   \   00000002   0xB510             PUSH     {R4,LR}
   \   00000004   0x7844             LDRB     R4,[R0, #+1]
   \   00000006   0x2C01             CMP      R4,#+1
   \   00000008   0xBF1F             ITTTT    NE 
   \   0000000A   0x2401             MOVNE    R4,#+1
   \   0000000C   0x7044             STRBNE   R4,[R0, #+1]
   \   0000000E   0x7804             LDRBNE   R4,[R0, #+0]
   \   00000010   0x2C02             CMPNE    R4,#+2
    517            
    518            /* Check the SDRAM controller state */
    519            tmp = hsdram->State;
    520            
    521            if(tmp == HAL_SDRAM_STATE_BUSY)
   \   00000012   0xD101             BNE.N    ??HAL_SDRAM_Write_32b_0
    522            {
    523              return HAL_BUSY;
   \   00000014   0x2002             MOVS     R0,#+2
   \   00000016   0xBD10             POP      {R4,PC}
    524            }
    525            else if((tmp == HAL_SDRAM_STATE_PRECHARGED) || (tmp == HAL_SDRAM_STATE_WRITE_PROTECTED))
   \                     ??HAL_SDRAM_Write_32b_0: (+1)
   \   00000018   0x2C05             CMP      R4,#+5
   \   0000001A   0xBF18             IT       NE 
   \   0000001C   0x2C04             CMPNE    R4,#+4
   \   0000001E   0xD106             BNE.N    ??HAL_SDRAM_Write_32b_1
    526            {
    527              return  HAL_ERROR; 
   \   00000020   0x2001             MOVS     R0,#+1
   \   00000022   0xBD10             POP      {R4,PC}
    528            }
    529            
    530            /* Write data to memory */
    531            for(; BufferSize != 0; BufferSize--)
    532            {
    533              *(__IO uint32_t *)pSdramAddress = *pSrcBuffer;
   \                     ??HAL_SDRAM_Write_32b_2: (+1)
   \   00000024   0xF852 0x4B04      LDR      R4,[R2], #+4
    534              pSrcBuffer++;
    535              pSdramAddress++;          
    536            }
   \   00000028   0x1E5B             SUBS     R3,R3,#+1
   \   0000002A   0xF841 0x4B04      STR      R4,[R1], #+4
   \                     ??HAL_SDRAM_Write_32b_1: (+1)
   \   0000002E   0x2B00             CMP      R3,#+0
   \   00000030   0xD1F8             BNE.N    ??HAL_SDRAM_Write_32b_2
    537            
    538            /* Process Unlocked */
    539            __HAL_UNLOCK(hsdram);    
   \   00000032   0x....             B.N      ?Subroutine0
    540            
    541            return HAL_OK;  
    542          }
    543          
    544          /**
    545            * @brief  Reads a Words data from the SDRAM memory using DMA transfer. 
    546            * @param  hsdram: pointer to a SDRAM_HandleTypeDef structure that contains
    547            *                the configuration information for SDRAM module.
    548            * @param  pAddress: Pointer to read start address
    549            * @param  pDstBuffer: Pointer to destination buffer  
    550            * @param  BufferSize: Size of the buffer to read from memory
    551            * @retval HAL status
    552            */

   \                                 In section .text, align 2, keep-with-next
    553          HAL_StatusTypeDef HAL_SDRAM_Read_DMA(SDRAM_HandleTypeDef *hsdram, uint32_t *pAddress, uint32_t *pDstBuffer, uint32_t BufferSize)
    554          {
   \                     HAL_SDRAM_Read_DMA: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    555            uint32_t tmp = 0;
    556              
    557            /* Process Locked */
    558            __HAL_LOCK(hsdram);
   \   00000002   0xF100 0x042C      ADD      R4,R0,#+44
   \   00000006   0x7860             LDRB     R0,[R4, #+1]
   \   00000008   0x2801             CMP      R0,#+1
   \   0000000A   0xBF1F             ITTTT    NE 
   \   0000000C   0x2001             MOVNE    R0,#+1
   \   0000000E   0x7060             STRBNE   R0,[R4, #+1]
   \   00000010   0x7820             LDRBNE   R0,[R4, #+0]
   \   00000012   0x2802             CMPNE    R0,#+2
    559            
    560            /* Check the SDRAM controller state */  
    561            tmp = hsdram->State;
    562            
    563            if(tmp == HAL_SDRAM_STATE_BUSY)
   \   00000014   0xD101             BNE.N    ??HAL_SDRAM_Read_DMA_0
    564            {
    565              return HAL_BUSY;
   \   00000016   0x2002             MOVS     R0,#+2
   \   00000018   0xBD32             POP      {R1,R4,R5,PC}
    566            }
    567            else if(tmp == HAL_SDRAM_STATE_PRECHARGED)
   \                     ??HAL_SDRAM_Read_DMA_0: (+1)
   \   0000001A   0x2805             CMP      R0,#+5
   \   0000001C   0xD101             BNE.N    ??HAL_SDRAM_Read_DMA_1
    568            {
    569              return  HAL_ERROR; 
   \   0000001E   0x2001             MOVS     R0,#+1
   \   00000020   0xBD32             POP      {R1,R4,R5,PC}
    570            }  
    571            
    572            /* Configure DMA user callbacks */
    573            hsdram->hdma->XferCpltCallback  = HAL_SDRAM_DMA_XferCpltCallback;
   \                     ??HAL_SDRAM_Read_DMA_1: (+1)
   \   00000022   0x6865             LDR      R5,[R4, #+4]
   \   00000024   0x....             LDR.N    R0,??DataTable1
   \   00000026   0x63E8             STR      R0,[R5, #+60]
    574            hsdram->hdma->XferErrorCallback = HAL_SDRAM_DMA_XferErrorCallback;
   \   00000028   0x6865             LDR      R5,[R4, #+4]
   \   0000002A   0x....             LDR.N    R0,??DataTable1_1
   \   0000002C   0x64A8             STR      R0,[R5, #+72]
    575            
    576            /* Enable the DMA Stream */
    577            HAL_DMA_Start_IT(hsdram->hdma, (uint32_t)pAddress, (uint32_t)pDstBuffer, (uint32_t)BufferSize);
   \   0000002E   0x6860             LDR      R0,[R4, #+4]
   \   00000030   0x.... 0x....      BL       HAL_DMA_Start_IT
    578            
    579            /* Process Unlocked */
    580            __HAL_UNLOCK(hsdram);  
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0x7060             STRB     R0,[R4, #+1]
    581            
    582            return HAL_OK; 
   \   00000038   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    583          }
    584          
    585          /**
    586            * @brief  Writes a Words data buffer to SDRAM memory using DMA transfer.
    587            * @param  hsdram: pointer to a SDRAM_HandleTypeDef structure that contains
    588            *                the configuration information for SDRAM module.
    589            * @param  pAddress: Pointer to write start address
    590            * @param  pSrcBuffer: Pointer to source buffer to write  
    591            * @param  BufferSize: Size of the buffer to write to memory
    592            * @retval HAL status
    593            */

   \                                 In section .text, align 2, keep-with-next
    594          HAL_StatusTypeDef HAL_SDRAM_Write_DMA(SDRAM_HandleTypeDef *hsdram, uint32_t *pAddress, uint32_t *pSrcBuffer, uint32_t BufferSize)
    595          {
   \                     HAL_SDRAM_Write_DMA: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    596            uint32_t tmp = 0;
    597            
    598            /* Process Locked */
    599            __HAL_LOCK(hsdram);
   \   00000002   0xF100 0x052C      ADD      R5,R0,#+44
   \   00000006   0x4614             MOV      R4,R2
   \   00000008   0x7868             LDRB     R0,[R5, #+1]
   \   0000000A   0x2801             CMP      R0,#+1
   \   0000000C   0xBF1F             ITTTT    NE 
   \   0000000E   0x2001             MOVNE    R0,#+1
   \   00000010   0x7068             STRBNE   R0,[R5, #+1]
   \   00000012   0x7828             LDRBNE   R0,[R5, #+0]
   \   00000014   0x2802             CMPNE    R0,#+2
    600            
    601            /* Check the SDRAM controller state */  
    602            tmp = hsdram->State;
    603            
    604            if(tmp == HAL_SDRAM_STATE_BUSY)
   \   00000016   0xD101             BNE.N    ??HAL_SDRAM_Write_DMA_0
    605            {
    606              return HAL_BUSY;
   \   00000018   0x2002             MOVS     R0,#+2
   \   0000001A   0xBD32             POP      {R1,R4,R5,PC}
    607            }
    608            else if((tmp == HAL_SDRAM_STATE_PRECHARGED) || (tmp == HAL_SDRAM_STATE_WRITE_PROTECTED))
   \                     ??HAL_SDRAM_Write_DMA_0: (+1)
   \   0000001C   0x2805             CMP      R0,#+5
   \   0000001E   0xBF18             IT       NE 
   \   00000020   0x2804             CMPNE    R0,#+4
   \   00000022   0xD101             BNE.N    ??HAL_SDRAM_Write_DMA_1
    609            {
    610              return  HAL_ERROR; 
   \   00000024   0x2001             MOVS     R0,#+1
   \   00000026   0xBD32             POP      {R1,R4,R5,PC}
    611            }  
    612            
    613            /* Configure DMA user callbacks */
    614            hsdram->hdma->XferCpltCallback  = HAL_SDRAM_DMA_XferCpltCallback;
   \                     ??HAL_SDRAM_Write_DMA_1: (+1)
   \   00000028   0x686A             LDR      R2,[R5, #+4]
   \   0000002A   0x....             LDR.N    R0,??DataTable1
   \   0000002C   0x63D0             STR      R0,[R2, #+60]
    615            hsdram->hdma->XferErrorCallback = HAL_SDRAM_DMA_XferErrorCallback;
   \   0000002E   0x686A             LDR      R2,[R5, #+4]
   \   00000030   0x....             LDR.N    R0,??DataTable1_1
   \   00000032   0x6490             STR      R0,[R2, #+72]
    616            
    617            /* Enable the DMA Stream */
    618            HAL_DMA_Start_IT(hsdram->hdma, (uint32_t)pSrcBuffer, (uint32_t)pAddress, (uint32_t)BufferSize);
   \   00000034   0x460A             MOV      R2,R1
   \   00000036   0x6868             LDR      R0,[R5, #+4]
   \   00000038   0x4621             MOV      R1,R4
   \   0000003A   0x.... 0x....      BL       HAL_DMA_Start_IT
    619            
    620            /* Process Unlocked */
    621            __HAL_UNLOCK(hsdram);
   \   0000003E   0x2000             MOVS     R0,#+0
   \   00000040   0x7068             STRB     R0,[R5, #+1]
    622            
    623            return HAL_OK;
   \   00000042   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    624          }
    625          
    626          /**
    627            * @}
    628            */
    629            
    630          /** @defgroup SDRAM_Exported_Functions_Group3 Control functions 
    631           *  @brief   management functions 
    632           *
    633          @verbatim   
    634            ==============================================================================
    635                                   ##### SDRAM Control functions #####
    636            ==============================================================================  
    637            [..]
    638              This subsection provides a set of functions allowing to control dynamically
    639              the SDRAM interface.
    640          
    641          @endverbatim
    642            * @{
    643            */
    644          
    645          /**
    646            * @brief  Enables dynamically SDRAM write protection.
    647            * @param  hsdram: pointer to a SDRAM_HandleTypeDef structure that contains
    648            *                the configuration information for SDRAM module.
    649            * @retval HAL status
    650            */

   \                                 In section .text, align 2, keep-with-next
    651          HAL_StatusTypeDef HAL_SDRAM_WriteProtection_Enable(SDRAM_HandleTypeDef *hsdram)
    652          { 
   \                     HAL_SDRAM_WriteProtection_Enable: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x.... 0x....      BL       ?Subroutine1
    653            /* Check the SDRAM controller state */ 
    654            if(hsdram->State == HAL_SDRAM_STATE_BUSY)
   \                     ??CrossCallReturnLabel_0: (+1)
   \   00000006   0xD007             BEQ.N    ??HAL_SDRAM_WriteProtection_Enable_0
    655            {
    656              return HAL_BUSY;
    657            }
    658            
    659            /* Update the SDRAM state */
    660            hsdram->State = HAL_SDRAM_STATE_BUSY;
   \   00000008   0x.... 0x....      BL       ?Subroutine4
    661            
    662            /* Enable write protection */
    663            FMC_SDRAM_WriteProtection_Enable(hsdram->Instance, hsdram->Init.SDBank);
   \                     ??CrossCallReturnLabel_10: (+1)
   \   0000000C   0x.... 0x....      BL       FMC_SDRAM_WriteProtection_Enable
    664            
    665            /* Update the SDRAM state */
    666            hsdram->State = HAL_SDRAM_STATE_WRITE_PROTECTED;
   \   00000010   0x2004             MOVS     R0,#+4
   \   00000012   0xF884 0x002C      STRB     R0,[R4, #+44]
    667            
    668            return HAL_OK;  
   \   00000016   0x2000             MOVS     R0,#+0
   \                     ??HAL_SDRAM_WriteProtection_Enable_0: (+1)
   \   00000018   0xBD10             POP      {R4,PC}          ;; return
    669          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine4: (+1)
   \   00000000   0x2002             MOVS     R0,#+2
   \   00000002   0xF884 0x002C      STRB     R0,[R4, #+44]
   \   00000006   0x6861             LDR      R1,[R4, #+4]
   \   00000008   0x6820             LDR      R0,[R4, #+0]
   \   0000000A   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \   00000000   0x4604             MOV      R4,R0
   \   00000002   0xF894 0x002C      LDRB     R0,[R4, #+44]
   \   00000006   0x2802             CMP      R0,#+2
   \   00000008   0x4770             BX       LR
    670          
    671          /**
    672            * @brief  Disables dynamically SDRAM write protection.
    673            * @param  hsdram: pointer to a SDRAM_HandleTypeDef structure that contains
    674            *                the configuration information for SDRAM module.
    675            * @retval HAL status
    676            */

   \                                 In section .text, align 2, keep-with-next
    677          HAL_StatusTypeDef HAL_SDRAM_WriteProtection_Disable(SDRAM_HandleTypeDef *hsdram)
    678          {
   \                     HAL_SDRAM_WriteProtection_Disable: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x.... 0x....      BL       ?Subroutine1
    679            /* Check the SDRAM controller state */
    680            if(hsdram->State == HAL_SDRAM_STATE_BUSY)
   \                     ??CrossCallReturnLabel_1: (+1)
   \   00000006   0xD005             BEQ.N    ??CrossCallReturnLabel_4
    681            {
    682              return HAL_BUSY;
    683            }
    684            
    685            /* Update the SDRAM state */
    686            hsdram->State = HAL_SDRAM_STATE_BUSY;
   \   00000008   0x.... 0x....      BL       ?Subroutine4
    687            
    688            /* Disable write protection */
    689            FMC_SDRAM_WriteProtection_Disable(hsdram->Instance, hsdram->Init.SDBank);
   \                     ??CrossCallReturnLabel_11: (+1)
   \   0000000C   0x.... 0x....      BL       FMC_SDRAM_WriteProtection_Disable
    690            
    691            /* Update the SDRAM state */
    692            hsdram->State = HAL_SDRAM_STATE_READY;
   \   00000010   0x.... 0x....      BL       ?Subroutine2
    693            
    694            return HAL_OK;
   \                     ??CrossCallReturnLabel_4: (+1)
   \   00000014   0xBD10             POP      {R4,PC}          ;; return
    695          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine2: (+1)
   \   00000000   0x2001             MOVS     R0,#+1
   \   00000002   0xF884 0x002C      STRB     R0,[R4, #+44]
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x4770             BX       LR
    696          
    697          /**
    698            * @brief  Sends Command to the SDRAM bank.
    699            * @param  hsdram: pointer to a SDRAM_HandleTypeDef structure that contains
    700            *                the configuration information for SDRAM module.
    701            * @param  Command: SDRAM command structure
    702            * @param  Timeout: Timeout duration
    703            * @retval HAL status
    704            */  

   \                                 In section .text, align 2, keep-with-next
    705          HAL_StatusTypeDef HAL_SDRAM_SendCommand(SDRAM_HandleTypeDef *hsdram, FMC_SDRAM_CommandTypeDef *Command, uint32_t Timeout)
    706          {
   \                     HAL_SDRAM_SendCommand: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    707            /* Check the SDRAM controller state */
    708            if(hsdram->State == HAL_SDRAM_STATE_BUSY)
   \   00000006   0xF894 0x002C      LDRB     R0,[R4, #+44]
   \   0000000A   0x2802             CMP      R0,#+2
   \   0000000C   0xD00B             BEQ.N    ??HAL_SDRAM_SendCommand_0
    709            {
    710              return HAL_BUSY;
    711            }
    712            
    713            /* Update the SDRAM state */
    714            hsdram->State = HAL_SDRAM_STATE_BUSY;
   \   0000000E   0x.... 0x....      BL       ?Subroutine3
    715            
    716            /* Send SDRAM command */
    717            FMC_SDRAM_SendCommand(hsdram->Instance, Command, Timeout);
   \                     ??CrossCallReturnLabel_7: (+1)
   \   00000012   0x.... 0x....      BL       FMC_SDRAM_SendCommand
    718            
    719            /* Update the SDRAM controller state state */
    720            if(Command->CommandMode == FMC_SDRAM_CMD_PALL)
   \   00000016   0x6828             LDR      R0,[R5, #+0]
   \   00000018   0x2802             CMP      R0,#+2
   \   0000001A   0xBF0C             ITE      EQ 
   \   0000001C   0x2005             MOVEQ    R0,#+5
   \   0000001E   0x2001             MOVNE    R0,#+1
    721            {
    722              hsdram->State = HAL_SDRAM_STATE_PRECHARGED;
    723            }
    724            else
    725            {
    726              hsdram->State = HAL_SDRAM_STATE_READY;
   \   00000020   0xF884 0x002C      STRB     R0,[R4, #+44]
    727            }
    728            
    729            return HAL_OK;  
   \   00000024   0x2000             MOVS     R0,#+0
   \                     ??HAL_SDRAM_SendCommand_0: (+1)
   \   00000026   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    730          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine3: (+1)
   \   00000000   0x2002             MOVS     R0,#+2
   \   00000002   0xF884 0x002C      STRB     R0,[R4, #+44]
   \   00000006   0x6820             LDR      R0,[R4, #+0]
   \   00000008   0x4770             BX       LR
    731          
    732          /**
    733            * @brief  Programs the SDRAM Memory Refresh rate.
    734            * @param  hsdram: pointer to a SDRAM_HandleTypeDef structure that contains
    735            *                the configuration information for SDRAM module.  
    736            * @param  RefreshRate: The SDRAM refresh rate value       
    737            * @retval HAL status
    738            */

   \                                 In section .text, align 2, keep-with-next
    739          HAL_StatusTypeDef HAL_SDRAM_ProgramRefreshRate(SDRAM_HandleTypeDef *hsdram, uint32_t RefreshRate)
    740          {
   \                     HAL_SDRAM_ProgramRefreshRate: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x.... 0x....      BL       ?Subroutine1
    741            /* Check the SDRAM controller state */
    742            if(hsdram->State == HAL_SDRAM_STATE_BUSY)
   \                     ??CrossCallReturnLabel_2: (+1)
   \   00000006   0xD005             BEQ.N    ??CrossCallReturnLabel_5
    743            {
    744              return HAL_BUSY;
    745            } 
    746            
    747            /* Update the SDRAM state */
    748            hsdram->State = HAL_SDRAM_STATE_BUSY;
   \   00000008   0x.... 0x....      BL       ?Subroutine3
    749            
    750            /* Program the refresh rate */
    751            FMC_SDRAM_ProgramRefreshRate(hsdram->Instance ,RefreshRate);
   \                     ??CrossCallReturnLabel_8: (+1)
   \   0000000C   0x.... 0x....      BL       FMC_SDRAM_ProgramRefreshRate
    752            
    753            /* Update the SDRAM state */
    754            hsdram->State = HAL_SDRAM_STATE_READY;
   \   00000010   0x.... 0x....      BL       ?Subroutine2
    755            
    756            return HAL_OK;   
   \                     ??CrossCallReturnLabel_5: (+1)
   \   00000014   0xBD10             POP      {R4,PC}          ;; return
    757          }
    758          
    759          /**
    760            * @brief  Sets the Number of consecutive SDRAM Memory auto Refresh commands.
    761            * @param  hsdram: pointer to a SDRAM_HandleTypeDef structure that contains
    762            *                the configuration information for SDRAM module.  
    763            * @param  AutoRefreshNumber: The SDRAM auto Refresh number       
    764            * @retval HAL status
    765            */

   \                                 In section .text, align 2, keep-with-next
    766          HAL_StatusTypeDef HAL_SDRAM_SetAutoRefreshNumber(SDRAM_HandleTypeDef *hsdram, uint32_t AutoRefreshNumber)
    767          {
   \                     HAL_SDRAM_SetAutoRefreshNumber: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x.... 0x....      BL       ?Subroutine1
    768            /* Check the SDRAM controller state */
    769            if(hsdram->State == HAL_SDRAM_STATE_BUSY)
   \                     ??CrossCallReturnLabel_3: (+1)
   \   00000006   0xD005             BEQ.N    ??CrossCallReturnLabel_6
    770            {
    771              return HAL_BUSY;
    772            } 
    773            
    774            /* Update the SDRAM state */
    775            hsdram->State = HAL_SDRAM_STATE_BUSY;
   \   00000008   0x.... 0x....      BL       ?Subroutine3
    776            
    777            /* Set the Auto-Refresh number */
    778            FMC_SDRAM_SetAutoRefreshNumber(hsdram->Instance ,AutoRefreshNumber);
   \                     ??CrossCallReturnLabel_9: (+1)
   \   0000000C   0x.... 0x....      BL       FMC_SDRAM_SetAutoRefreshNumber
    779            
    780            /* Update the SDRAM state */
    781            hsdram->State = HAL_SDRAM_STATE_READY;
   \   00000010   0x.... 0x....      BL       ?Subroutine2
    782            
    783            return HAL_OK;
   \                     ??CrossCallReturnLabel_6: (+1)
   \   00000014   0xBD10             POP      {R4,PC}          ;; return
    784          }
    785          
    786          /**
    787            * @brief  Returns the SDRAM memory current mode.
    788            * @param  hsdram: pointer to a SDRAM_HandleTypeDef structure that contains
    789            *                the configuration information for SDRAM module.
    790            * @retval The SDRAM memory mode.        
    791            */

   \                                 In section .text, align 2, keep-with-next
    792          uint32_t HAL_SDRAM_GetModeStatus(SDRAM_HandleTypeDef *hsdram)
    793          {
    794            /* Return the SDRAM memory current mode */
    795            return(FMC_SDRAM_GetModeStatus(hsdram->Instance, hsdram->Init.SDBank));
   \                     HAL_SDRAM_GetModeStatus: (+1)
   \   00000000   0x6841             LDR      R1,[R0, #+4]
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x.... 0x....      B.W      FMC_SDRAM_GetModeStatus
    796          }
    797          
    798          /**
    799            * @}
    800            */
    801            
    802          /** @defgroup SDRAM_Exported_Functions_Group4 State functions 
    803           *  @brief   Peripheral State functions 
    804           *
    805          @verbatim   
    806            ==============================================================================
    807                                ##### SDRAM State functions #####
    808            ==============================================================================  
    809            [..]
    810              This subsection permits to get in run-time the status of the SDRAM controller 
    811              and the data flow.
    812          
    813          @endverbatim
    814            * @{
    815            */
    816          
    817          /**
    818            * @brief  Returns the SDRAM state.
    819            * @param  hsdram: pointer to a SDRAM_HandleTypeDef structure that contains
    820            *                the configuration information for SDRAM module.
    821            * @retval HAL state
    822            */

   \                                 In section .text, align 2, keep-with-next
    823          HAL_SDRAM_StateTypeDef HAL_SDRAM_GetState(SDRAM_HandleTypeDef *hsdram)
    824          {
    825            return hsdram->State;
   \                     HAL_SDRAM_GetState: (+1)
   \   00000000   0xF890 0x002C      LDRB     R0,[R0, #+44]
   \   00000004   0x4770             BX       LR               ;; return
    826          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1:
   \   00000000   0x........         DC32     HAL_SDRAM_DMA_XferCpltCallback

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_1:
   \   00000000   0x........         DC32     HAL_SDRAM_DMA_XferErrorCallback
    827          
    828          /**
    829            * @}
    830            */    
    831          
    832          /**
    833            * @}
    834            */
    835          #endif /* HAL_SDRAM_MODULE_ENABLED */
    836          /**
    837            * @}
    838            */
    839          
    840          /**
    841            * @}
    842            */
    843          
    844          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   HAL_SDRAM_DMA_XferCpltCallback
       0   HAL_SDRAM_DMA_XferErrorCallback
       8   HAL_SDRAM_DeInit
         8   -> FMC_SDRAM_DeInit
         8   -> HAL_SDRAM_MspDeInit
       0   HAL_SDRAM_GetModeStatus
         0   -> FMC_SDRAM_GetModeStatus
       0   HAL_SDRAM_GetState
       8   HAL_SDRAM_IRQHandler
         8   -> HAL_SDRAM_RefreshErrorCallback
      16   HAL_SDRAM_Init
        16   -> FMC_SDRAM_Init
        16   -> FMC_SDRAM_Timing_Init
        16   -> HAL_SDRAM_MspInit
       0   HAL_SDRAM_MspDeInit
       0   HAL_SDRAM_MspInit
       8   HAL_SDRAM_ProgramRefreshRate
         8   -> FMC_SDRAM_ProgramRefreshRate
       8   HAL_SDRAM_Read_16b
       8   HAL_SDRAM_Read_32b
       8   HAL_SDRAM_Read_8b
      16   HAL_SDRAM_Read_DMA
        16   -> HAL_DMA_Start_IT
       0   HAL_SDRAM_RefreshErrorCallback
      16   HAL_SDRAM_SendCommand
        16   -> FMC_SDRAM_SendCommand
       8   HAL_SDRAM_SetAutoRefreshNumber
         8   -> FMC_SDRAM_SetAutoRefreshNumber
       8   HAL_SDRAM_WriteProtection_Disable
         8   -> FMC_SDRAM_WriteProtection_Disable
       8   HAL_SDRAM_WriteProtection_Enable
         8   -> FMC_SDRAM_WriteProtection_Enable
       8   HAL_SDRAM_Write_16b
       8   HAL_SDRAM_Write_32b
       8   HAL_SDRAM_Write_8b
      16   HAL_SDRAM_Write_DMA
        16   -> HAL_DMA_Start_IT


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable1
       4  ??DataTable1_1
       8  ?Subroutine0
      10  ?Subroutine1
      10  ?Subroutine2
      10  ?Subroutine3
      12  ?Subroutine4
       2  HAL_SDRAM_DMA_XferCpltCallback
       2  HAL_SDRAM_DMA_XferErrorCallback
      26  HAL_SDRAM_DeInit
       8  HAL_SDRAM_GetModeStatus
       6  HAL_SDRAM_GetState
      30  HAL_SDRAM_IRQHandler
      58  HAL_SDRAM_Init
       2  HAL_SDRAM_MspDeInit
       2  HAL_SDRAM_MspInit
      22  HAL_SDRAM_ProgramRefreshRate
      50  HAL_SDRAM_Read_16b
      50  HAL_SDRAM_Read_32b
      50  HAL_SDRAM_Read_8b
      58  HAL_SDRAM_Read_DMA
       2  HAL_SDRAM_RefreshErrorCallback
      40  HAL_SDRAM_SendCommand
      22  HAL_SDRAM_SetAutoRefreshNumber
      22  HAL_SDRAM_WriteProtection_Disable
      26  HAL_SDRAM_WriteProtection_Enable
      52  HAL_SDRAM_Write_16b
      52  HAL_SDRAM_Write_32b
      50  HAL_SDRAM_Write_8b
      68  HAL_SDRAM_Write_DMA

 
 758 bytes in section .text
 
 758 bytes of CODE memory

Errors: none
Warnings: none
