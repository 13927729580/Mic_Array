###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.2.10312/W32 for ARM       25/Feb/2016  15:20:37
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_dma2d.c
#    Command line =  
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_dma2d.c
#        -D USE_HAL_DRIVER -D STM32F746xx -D USE_STM32746G_DISCO -D
#        USE_IOEXPANDER -D USE_USB_FS -lC
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
#        -lA
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
#        -o
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M7 -e --fpu=VFPv5_sp --dlib_config "D:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.3\arm\INC\c\DLib_Config_Full.h"
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\CMSIS\Device\ST\STM32F7xx\Include\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\STM32F7xx_HAL_Driver\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\STM32746G-Discovery\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\Components\Common\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Log\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Fonts\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\CPU\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_Device_Library\Core\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Core\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Class\MSC\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\drivers\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_Audio\Addons\PDM\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_Device_Library\Class\AUDIO\Inc\
#        -On --use_c++_inline --require_prototypes -I "D:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.3\arm\CMSIS\Include\" -D
#        ARM_MATH_CM7
#    List file    =  
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List\stm32f7xx_hal_dma2d.lst
#    Object file  =  
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj\stm32f7xx_hal_dma2d.o
#
###############################################################################

D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_dma2d.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f7xx_hal_dma2d.c
      4            * @author  MCD Application Team
      5            * @version V1.0.1
      6            * @date    25-June-2015
      7            * @brief   DMA2D HAL module driver.
      8            *          This file provides firmware functions to manage the following 
      9            *          functionalities of the DMA2D peripheral:
     10            *           + Initialization and de-initialization functions
     11            *           + IO operation functions
     12            *           + Peripheral Control functions 
     13            *           + Peripheral State and Errors functions
     14            *
     15            @verbatim
     16            ==============================================================================
     17                                  ##### How to use this driver #####
     18            ==============================================================================
     19              [..]
     20                (#) Program the required configuration through following parameters:   
     21                    the Transfer Mode, the output color mode and the output offset using 
     22                    HAL_DMA2D_Init() function.
     23          
     24                (#) Program the required configuration through following parameters:   
     25                    the input color mode, the input color, input alpha value, alpha mode 
     26                    and the input offset using HAL_DMA2D_ConfigLayer() function for foreground
     27                    or/and background layer.
     28                    
     29               *** Polling mode IO operation ***
     30               =================================   
     31              [..]        
     32                 (+) Configure the pdata, Destination and data length and Enable 
     33                     the transfer using HAL_DMA2D_Start() 
     34                 (+) Wait for end of transfer using HAL_DMA2D_PollForTransfer(), at this stage
     35                     user can specify the value of timeout according to his end application.
     36                         
     37               *** Interrupt mode IO operation ***    
     38               ===================================
     39               [..] 
     40                 (#) Configure the pdata, Destination and data length and Enable 
     41                     the transfer using HAL_DMA2D_Start_IT() 
     42                 (#) Use HAL_DMA2D_IRQHandler() called under DMA2D_IRQHandler() Interrupt subroutine
     43                 (#) At the end of data transfer HAL_DMA2D_IRQHandler() function is executed and user can 
     44                     add his own function by customization of function pointer XferCpltCallback and 
     45                     XferErrorCallback (i.e a member of DMA2D handle structure). 
     46          
     47                   -@-   In Register-to-Memory transfer mode, the pdata parameter is the register
     48                         color, in Memory-to-memory or memory-to-memory with pixel format
     49                         conversion the pdata is the source address.
     50          
     51                   -@-   Configure the foreground source address, the background source address, 
     52                         the Destination and data length and Enable the transfer using 
     53                         HAL_DMA2D_BlendingStart() in polling mode and HAL_DMA2D_BlendingStart_IT()
     54                         in interrupt mode.
     55                         
     56                   -@-   HAL_DMA2D_BlendingStart() and HAL_DMA2D_BlendingStart_IT() functions
     57                         are used if the memory to memory with blending transfer mode is selected.
     58                             
     59                (#) Optionally, configure and enable the CLUT using HAL_DMA2D_ConfigCLUT()
     60                    HAL_DMA2D_EnableCLUT() functions.
     61          
     62                (#) Optionally, configure and enable LineInterrupt using the following function:
     63                    HAL_DMA2D_ProgramLineEvent().
     64             
     65                (#) The transfer can be suspended, continued and aborted using the following
     66                    functions: HAL_DMA2D_Suspend(), HAL_DMA2D_Resume(), HAL_DMA2D_Abort().
     67                               
     68                (#) To control DMA2D state you can use the following function: HAL_DMA2D_GetState()                   
     69          
     70               *** DMA2D HAL driver macros list ***
     71               ============================================= 
     72               [..]
     73                 Below the list of most used macros in DMA2D HAL driver :
     74                 
     75                (+) __HAL_DMA2D_ENABLE: Enable the DMA2D peripheral.
     76                (+) __HAL_DMA2D_DISABLE: Disable the DMA2D peripheral.
     77                (+) __HAL_DMA2D_GET_FLAG: Get the DMA2D pending flags.
     78                (+) __HAL_DMA2D_CLEAR_FLAG: Clear the DMA2D pending flags.
     79                (+) __HAL_DMA2D_ENABLE_IT: Enable the specified DMA2D interrupts.
     80                (+) __HAL_DMA2D_DISABLE_IT: Disable the specified DMA2D interrupts.
     81                (+) __HAL_DMA2D_GET_IT_SOURCE: Check whether the specified DMA2D interrupt has occurred or not.
     82               
     83               [..] 
     84                (@) You can refer to the DMA2D HAL driver header file for more useful macros
     85                                            
     86            @endverbatim
     87            ******************************************************************************
     88            * @attention
     89            *
     90            * <h2><center>&copy; COPYRIGHT(c) 2015 STMicroelectronics</center></h2>
     91            *
     92            * Redistribution and use in source and binary forms, with or without modification,
     93            * are permitted provided that the following conditions are met:
     94            *   1. Redistributions of source code must retain the above copyright notice,
     95            *      this list of conditions and the following disclaimer.
     96            *   2. Redistributions in binary form must reproduce the above copyright notice,
     97            *      this list of conditions and the following disclaimer in the documentation
     98            *      and/or other materials provided with the distribution.
     99            *   3. Neither the name of STMicroelectronics nor the names of its contributors
    100            *      may be used to endorse or promote products derived from this software
    101            *      without specific prior written permission.
    102            *
    103            * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
    104            * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
    105            * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
    106            * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
    107            * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
    108            * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
    109            * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
    110            * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
    111            * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
    112            * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
    113            *
    114            ******************************************************************************
    115            */ 
    116          
    117          /* Includes ------------------------------------------------------------------*/
    118          #include "stm32f7xx_hal.h"
    119          
    120          /** @addtogroup STM32F7xx_HAL_Driver
    121            * @{
    122            */
    123          /** @addtogroup DMA2D
    124            * @brief DMA2D HAL module driver
    125            * @{
    126            */
    127          
    128          #ifdef HAL_DMA2D_MODULE_ENABLED
    129          
    130          /* Private types -------------------------------------------------------------*/
    131          /* Private define ------------------------------------------------------------*/
    132          /** @addtogroup DMA2D_Private_Defines
    133            * @{
    134            */
    135          #define HAL_TIMEOUT_DMA2D_ABORT      ((uint32_t)1000)  /* 1s  */
    136          #define HAL_TIMEOUT_DMA2D_SUSPEND    ((uint32_t)1000)  /* 1s  */
    137          /**
    138            * @}
    139            */
    140          
    141          /* Private variables ---------------------------------------------------------*/
    142          /* Private constants ---------------------------------------------------------*/
    143          /* Private macro -------------------------------------------------------------*/
    144          /* Private function prototypes -----------------------------------------------*/
    145          /** @addtogroup DMA2D_Private_Functions_Prototypes
    146            * @{
    147            */
    148          static void DMA2D_SetConfig(DMA2D_HandleTypeDef *hdma2d, uint32_t pdata, uint32_t DstAddress, uint32_t Width, uint32_t Height);
    149          /**
    150            * @}
    151            */
    152          
    153          /* Private functions ---------------------------------------------------------*/
    154          /* Exported functions --------------------------------------------------------*/
    155          /** @addtogroup DMA2D_Exported_Functions
    156            * @{
    157            */
    158          
    159          /** @defgroup DMA2D_Group1 Initialization and Configuration functions
    160           *  @brief   Initialization and Configuration functions
    161           *
    162          @verbatim   
    163           ===============================================================================
    164                          ##### Initialization and Configuration functions #####
    165           ===============================================================================  
    166              [..]  This section provides functions allowing to:
    167                (+) Initialize and configure the DMA2D
    168                (+) De-initialize the DMA2D 
    169          
    170          @endverbatim
    171            * @{
    172            */
    173              
    174          /**
    175            * @brief  Initializes the DMA2D according to the specified
    176            *         parameters in the DMA2D_InitTypeDef and create the associated handle.
    177            * @param  hdma2d: pointer to a DMA2D_HandleTypeDef structure that contains
    178            *                 the configuration information for the DMA2D.
    179            * @retval HAL status
    180            */

   \                                 In section .text, align 2, keep-with-next
    181          HAL_StatusTypeDef HAL_DMA2D_Init(DMA2D_HandleTypeDef *hdma2d)
    182          { 
   \                     HAL_DMA2D_Init: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    183            uint32_t tmp = 0;
   \   00000004   0x2500             MOVS     R5,#+0
    184          
    185            /* Check the DMA2D peripheral state */
    186            if(hdma2d == NULL)
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD101             BNE.N    ??HAL_DMA2D_Init_0
    187            {
    188               return HAL_ERROR;
   \   0000000A   0x2001             MOVS     R0,#+1
   \   0000000C   0xE02D             B.N      ??HAL_DMA2D_Init_1
    189            }
    190          
    191            /* Check the parameters */
    192            assert_param(IS_DMA2D_ALL_INSTANCE(hdma2d->Instance));
    193            assert_param(IS_DMA2D_MODE(hdma2d->Init.Mode));
    194            assert_param(IS_DMA2D_CMODE(hdma2d->Init.ColorMode));
    195            assert_param(IS_DMA2D_OFFSET(hdma2d->Init.OutputOffset));
    196          
    197            if(hdma2d->State == HAL_DMA2D_STATE_RESET)
   \                     ??HAL_DMA2D_Init_0: (+1)
   \   0000000E   0xF894 0x0039      LDRB     R0,[R4, #+57]
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD105             BNE.N    ??HAL_DMA2D_Init_2
    198            {
    199              /* Allocate lock resource and initialize it */
    200              hdma2d->Lock = HAL_UNLOCKED;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0xF884 0x0038      STRB     R0,[R4, #+56]
    201              /* Init the low level hardware */
    202              HAL_DMA2D_MspInit(hdma2d);
   \   0000001C   0x0020             MOVS     R0,R4
   \   0000001E   0x.... 0x....      BL       HAL_DMA2D_MspInit
    203            }
    204            
    205            /* Change DMA2D peripheral state */
    206            hdma2d->State = HAL_DMA2D_STATE_BUSY;  
   \                     ??HAL_DMA2D_Init_2: (+1)
   \   00000022   0x2002             MOVS     R0,#+2
   \   00000024   0xF884 0x0039      STRB     R0,[R4, #+57]
    207          
    208          /* DMA2D CR register configuration -------------------------------------------*/
    209            /* Get the CR register value */
    210            tmp = hdma2d->Instance->CR;
   \   00000028   0x6820             LDR      R0,[R4, #+0]
   \   0000002A   0x6800             LDR      R0,[R0, #+0]
   \   0000002C   0x0005             MOVS     R5,R0
    211          
    212            /* Clear Mode bits */
    213            tmp &= (uint32_t)~DMA2D_CR_MODE;
   \   0000002E   0xF435 0x3540      BICS     R5,R5,#0x30000
    214          
    215            /* Prepare the value to be wrote to the CR register */
    216            tmp |= hdma2d->Init.Mode;
   \   00000032   0x6860             LDR      R0,[R4, #+4]
   \   00000034   0x4305             ORRS     R5,R0,R5
    217          
    218            /* Write to DMA2D CR register */
    219            hdma2d->Instance->CR = tmp;
   \   00000036   0x6820             LDR      R0,[R4, #+0]
   \   00000038   0x6005             STR      R5,[R0, #+0]
    220          
    221          /* DMA2D OPFCCR register configuration ---------------------------------------*/
    222            /* Get the OPFCCR register value */
    223            tmp = hdma2d->Instance->OPFCCR;
   \   0000003A   0x6820             LDR      R0,[R4, #+0]
   \   0000003C   0x6B40             LDR      R0,[R0, #+52]
   \   0000003E   0x0005             MOVS     R5,R0
    224          
    225            /* Clear Color Mode bits */
    226            tmp &= (uint32_t)~DMA2D_OPFCCR_CM;
   \   00000040   0x08ED             LSRS     R5,R5,#+3
   \   00000042   0x00ED             LSLS     R5,R5,#+3
    227          
    228            /* Prepare the value to be wrote to the OPFCCR register */
    229            tmp |= hdma2d->Init.ColorMode;
   \   00000044   0x68A0             LDR      R0,[R4, #+8]
   \   00000046   0x4305             ORRS     R5,R0,R5
    230          
    231            /* Write to DMA2D OPFCCR register */
    232            hdma2d->Instance->OPFCCR = tmp;
   \   00000048   0x6820             LDR      R0,[R4, #+0]
   \   0000004A   0x6345             STR      R5,[R0, #+52]
    233          
    234          /* DMA2D OOR register configuration ------------------------------------------*/  
    235            /* Get the OOR register value */
    236            tmp = hdma2d->Instance->OOR;
   \   0000004C   0x6820             LDR      R0,[R4, #+0]
   \   0000004E   0x6C00             LDR      R0,[R0, #+64]
   \   00000050   0x0005             MOVS     R5,R0
    237          
    238            /* Clear Offset bits */
    239            tmp &= (uint32_t)~DMA2D_OOR_LO;
   \   00000052   0x0BAD             LSRS     R5,R5,#+14
   \   00000054   0x03AD             LSLS     R5,R5,#+14
    240          
    241            /* Prepare the value to be wrote to the OOR register */
    242            tmp |= hdma2d->Init.OutputOffset;
   \   00000056   0x68E0             LDR      R0,[R4, #+12]
   \   00000058   0x4305             ORRS     R5,R0,R5
    243          
    244            /* Write to DMA2D OOR register */
    245            hdma2d->Instance->OOR = tmp;
   \   0000005A   0x6820             LDR      R0,[R4, #+0]
   \   0000005C   0x6405             STR      R5,[R0, #+64]
    246          
    247            /* Update error code */
    248            hdma2d->ErrorCode = HAL_DMA2D_ERROR_NONE;
   \   0000005E   0x2000             MOVS     R0,#+0
   \   00000060   0x63E0             STR      R0,[R4, #+60]
    249          
    250            /* Initialize the DMA2D state*/
    251            hdma2d->State  = HAL_DMA2D_STATE_READY;
   \   00000062   0x2001             MOVS     R0,#+1
   \   00000064   0xF884 0x0039      STRB     R0,[R4, #+57]
    252          
    253            return HAL_OK;
   \   00000068   0x2000             MOVS     R0,#+0
   \                     ??HAL_DMA2D_Init_1: (+1)
   \   0000006A   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    254          }
    255          
    256          /**
    257            * @brief  Deinitializes the DMA2D peripheral registers to their default reset
    258            *         values.
    259            * @param  hdma2d: pointer to a DMA2D_HandleTypeDef structure that contains
    260            *                 the configuration information for the DMA2D.
    261            * @retval None
    262            */
    263          

   \                                 In section .text, align 2, keep-with-next
    264          HAL_StatusTypeDef HAL_DMA2D_DeInit(DMA2D_HandleTypeDef *hdma2d)
    265          {
   \                     HAL_DMA2D_DeInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    266            /* Check the DMA2D peripheral state */
    267            if(hdma2d == NULL)
   \   00000004   0x2C00             CMP      R4,#+0
   \   00000006   0xD101             BNE.N    ??HAL_DMA2D_DeInit_0
    268            {
    269               return HAL_ERROR;
   \   00000008   0x2001             MOVS     R0,#+1
   \   0000000A   0xE00B             B.N      ??HAL_DMA2D_DeInit_1
    270            }
    271          
    272            /* DeInit the low level hardware */
    273            HAL_DMA2D_MspDeInit(hdma2d);
   \                     ??HAL_DMA2D_DeInit_0: (+1)
   \   0000000C   0x0020             MOVS     R0,R4
   \   0000000E   0x.... 0x....      BL       HAL_DMA2D_MspDeInit
    274          
    275            /* Update error code */
    276            hdma2d->ErrorCode = HAL_DMA2D_ERROR_NONE;
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0x63E0             STR      R0,[R4, #+60]
    277          
    278            /* Initialize the DMA2D state*/
    279            hdma2d->State  = HAL_DMA2D_STATE_RESET;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0xF884 0x0039      STRB     R0,[R4, #+57]
    280          
    281            /* Release Lock */
    282            __HAL_UNLOCK(hdma2d);
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0xF884 0x0038      STRB     R0,[R4, #+56]
    283          
    284            return HAL_OK;
   \   00000022   0x2000             MOVS     R0,#+0
   \                     ??HAL_DMA2D_DeInit_1: (+1)
   \   00000024   0xBD10             POP      {R4,PC}          ;; return
    285          }
    286          
    287          /**
    288            * @brief  Initializes the DMA2D MSP.
    289            * @param  hdma2d: pointer to a DMA2D_HandleTypeDef structure that contains
    290            *                 the configuration information for the DMA2D.
    291            * @retval None
    292            */

   \                                 In section .text, align 2, keep-with-next
    293          __weak void HAL_DMA2D_MspInit(DMA2D_HandleTypeDef* hdma2d)
    294          {
    295            /* NOTE : This function Should not be modified, when the callback is needed,
    296                      the HAL_DMA2D_MspInit could be implemented in the user file
    297             */ 
    298          }
   \                     HAL_DMA2D_MspInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    299          
    300          /**
    301            * @brief  DeInitializes the DMA2D MSP.
    302            * @param  hdma2d: pointer to a DMA2D_HandleTypeDef structure that contains
    303            *                 the configuration information for the DMA2D.
    304            * @retval None
    305            */

   \                                 In section .text, align 2, keep-with-next
    306          __weak void HAL_DMA2D_MspDeInit(DMA2D_HandleTypeDef* hdma2d)
    307          {
    308            /* NOTE : This function Should not be modified, when the callback is needed,
    309                      the HAL_DMA2D_MspDeInit could be implemented in the user file
    310             */ 
    311          }
   \                     HAL_DMA2D_MspDeInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    312          
    313          /**
    314            * @}
    315            */
    316          
    317          /** @defgroup DMA2D_Group2 IO operation functions 
    318           *  @brief   IO operation functions  
    319           *
    320          @verbatim   
    321           ===============================================================================
    322                                #####  IO operation functions  #####
    323           ===============================================================================  
    324              [..]  This section provides functions allowing to:
    325                (+) Configure the pdata, destination address and data size and 
    326                    Start DMA2D transfer.
    327                (+) Configure the source for foreground and background, destination address 
    328                    and data size and Start MultiBuffer DMA2D transfer.
    329                (+) Configure the pdata, destination address and data size and 
    330                    Start DMA2D transfer with interrupt.
    331                (+) Configure the source for foreground and background, destination address 
    332                    and data size and Start MultiBuffer DMA2D transfer with interrupt.
    333                (+) Abort DMA2D transfer.
    334                (+) Suspend DMA2D transfer.
    335                (+) Continue DMA2D transfer. 
    336                (+) Poll for transfer complete.
    337                (+) handle DMA2D interrupt request.
    338                  
    339          @endverbatim
    340            * @{
    341            */
    342          
    343          /**
    344            * @brief  Start the DMA2D Transfer.
    345            * @param  hdma2d:     pointer to a DMA2D_HandleTypeDef structure that contains
    346            *                     the configuration information for the DMA2D.  
    347            * @param  pdata:      Configure the source memory Buffer address if 
    348            *                     the memory to memory or memory to memory with pixel format 
    349            *                     conversion DMA2D mode is selected, and configure 
    350            *                     the color value if register to memory DMA2D mode is selected.
    351            * @param  DstAddress: The destination memory Buffer address.
    352            * @param  Width:      The width of data to be transferred from source to destination.
    353            * @param  Height:      The height of data to be transferred from source to destination.
    354            * @retval HAL status
    355            */

   \                                 In section .text, align 2, keep-with-next
    356          HAL_StatusTypeDef HAL_DMA2D_Start(DMA2D_HandleTypeDef *hdma2d, uint32_t pdata, uint32_t DstAddress, uint32_t Width,  uint32_t Height)
    357          {
   \                     HAL_DMA2D_Start: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB082             SUB      SP,SP,#+8
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
   \   0000000A   0x0016             MOVS     R6,R2
   \   0000000C   0x001F             MOVS     R7,R3
   \   0000000E   0xF8DD 0x8020      LDR      R8,[SP, #+32]
    358            /* Process locked */
    359            __HAL_LOCK(hdma2d);
   \   00000012   0xF894 0x0038      LDRB     R0,[R4, #+56]
   \   00000016   0x2801             CMP      R0,#+1
   \   00000018   0xD101             BNE.N    ??HAL_DMA2D_Start_0
   \   0000001A   0x2002             MOVS     R0,#+2
   \   0000001C   0xE01A             B.N      ??HAL_DMA2D_Start_1
   \                     ??HAL_DMA2D_Start_0: (+1)
   \   0000001E   0x2001             MOVS     R0,#+1
   \   00000020   0xF884 0x0038      STRB     R0,[R4, #+56]
    360          
    361            /* Change DMA2D peripheral state */
    362            hdma2d->State = HAL_DMA2D_STATE_BUSY;
   \   00000024   0x2002             MOVS     R0,#+2
   \   00000026   0xF884 0x0039      STRB     R0,[R4, #+57]
    363          
    364            /* Check the parameters */
    365            assert_param(IS_DMA2D_LINE(Height));
    366            assert_param(IS_DMA2D_PIXEL(Width));
    367          
    368            /* Disable the Peripheral */
    369            __HAL_DMA2D_DISABLE(hdma2d);
   \   0000002A   0x6820             LDR      R0,[R4, #+0]
   \   0000002C   0x6800             LDR      R0,[R0, #+0]
   \   0000002E   0x0840             LSRS     R0,R0,#+1
   \   00000030   0x0040             LSLS     R0,R0,#+1
   \   00000032   0x6821             LDR      R1,[R4, #+0]
   \   00000034   0x6008             STR      R0,[R1, #+0]
    370          
    371            /* Configure the source, destination address and the data size */
    372            DMA2D_SetConfig(hdma2d, pdata, DstAddress, Width, Height);
   \   00000036   0xF8CD 0x8000      STR      R8,[SP, #+0]
   \   0000003A   0x003B             MOVS     R3,R7
   \   0000003C   0x0032             MOVS     R2,R6
   \   0000003E   0x0029             MOVS     R1,R5
   \   00000040   0x0020             MOVS     R0,R4
   \   00000042   0x.... 0x....      BL       DMA2D_SetConfig
    373          
    374            /* Enable the Peripheral */
    375            __HAL_DMA2D_ENABLE(hdma2d);
   \   00000046   0x6820             LDR      R0,[R4, #+0]
   \   00000048   0x6800             LDR      R0,[R0, #+0]
   \   0000004A   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   0000004E   0x6821             LDR      R1,[R4, #+0]
   \   00000050   0x6008             STR      R0,[R1, #+0]
    376          
    377            return HAL_OK;
   \   00000052   0x2000             MOVS     R0,#+0
   \                     ??HAL_DMA2D_Start_1: (+1)
   \   00000054   0xE8BD 0x81F6      POP      {R1,R2,R4-R8,PC}  ;; return
    378          }
    379          
    380          /**
    381            * @brief  Start the DMA2D Transfer with interrupt enabled.
    382            * @param  hdma2d:     pointer to a DMA2D_HandleTypeDef structure that contains
    383            *                     the configuration information for the DMA2D.  
    384            * @param  pdata:      Configure the source memory Buffer address if 
    385            *                     the memory to memory or memory to memory with pixel format 
    386            *                     conversion DMA2D mode is selected, and configure 
    387            *                     the color value if register to memory DMA2D mode is selected.
    388            * @param  DstAddress: The destination memory Buffer address.
    389            * @param  Width:      The width of data to be transferred from source to destination.
    390            * @param  Height:     The height of data to be transferred from source to destination.
    391            * @retval HAL status
    392            */

   \                                 In section .text, align 2, keep-with-next
    393          HAL_StatusTypeDef HAL_DMA2D_Start_IT(DMA2D_HandleTypeDef *hdma2d, uint32_t pdata, uint32_t DstAddress, uint32_t Width,  uint32_t Height)
    394          {
   \                     HAL_DMA2D_Start_IT: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB082             SUB      SP,SP,#+8
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
   \   0000000A   0x0016             MOVS     R6,R2
   \   0000000C   0x001F             MOVS     R7,R3
   \   0000000E   0xF8DD 0x8020      LDR      R8,[SP, #+32]
    395            /* Process locked */
    396            __HAL_LOCK(hdma2d);
   \   00000012   0xF894 0x0038      LDRB     R0,[R4, #+56]
   \   00000016   0x2801             CMP      R0,#+1
   \   00000018   0xD101             BNE.N    ??HAL_DMA2D_Start_IT_0
   \   0000001A   0x2002             MOVS     R0,#+2
   \   0000001C   0xE02C             B.N      ??HAL_DMA2D_Start_IT_1
   \                     ??HAL_DMA2D_Start_IT_0: (+1)
   \   0000001E   0x2001             MOVS     R0,#+1
   \   00000020   0xF884 0x0038      STRB     R0,[R4, #+56]
    397          
    398            /* Change DMA2D peripheral state */
    399            hdma2d->State = HAL_DMA2D_STATE_BUSY;
   \   00000024   0x2002             MOVS     R0,#+2
   \   00000026   0xF884 0x0039      STRB     R0,[R4, #+57]
    400          
    401            /* Check the parameters */
    402            assert_param(IS_DMA2D_LINE(Height));
    403            assert_param(IS_DMA2D_PIXEL(Width));
    404          
    405            /* Disable the Peripheral */
    406            __HAL_DMA2D_DISABLE(hdma2d);
   \   0000002A   0x6820             LDR      R0,[R4, #+0]
   \   0000002C   0x6800             LDR      R0,[R0, #+0]
   \   0000002E   0x0840             LSRS     R0,R0,#+1
   \   00000030   0x0040             LSLS     R0,R0,#+1
   \   00000032   0x6821             LDR      R1,[R4, #+0]
   \   00000034   0x6008             STR      R0,[R1, #+0]
    407          
    408            /* Configure the source, destination address and the data size */
    409            DMA2D_SetConfig(hdma2d, pdata, DstAddress, Width, Height);
   \   00000036   0xF8CD 0x8000      STR      R8,[SP, #+0]
   \   0000003A   0x003B             MOVS     R3,R7
   \   0000003C   0x0032             MOVS     R2,R6
   \   0000003E   0x0029             MOVS     R1,R5
   \   00000040   0x0020             MOVS     R0,R4
   \   00000042   0x.... 0x....      BL       DMA2D_SetConfig
    410          
    411            /* Enable the transfer complete interrupt */
    412            __HAL_DMA2D_ENABLE_IT(hdma2d, DMA2D_IT_TC);
   \   00000046   0x6820             LDR      R0,[R4, #+0]
   \   00000048   0x6800             LDR      R0,[R0, #+0]
   \   0000004A   0xF450 0x7000      ORRS     R0,R0,#0x200
   \   0000004E   0x6821             LDR      R1,[R4, #+0]
   \   00000050   0x6008             STR      R0,[R1, #+0]
    413          
    414            /* Enable the transfer Error interrupt */
    415            __HAL_DMA2D_ENABLE_IT(hdma2d, DMA2D_IT_TE);
   \   00000052   0x6820             LDR      R0,[R4, #+0]
   \   00000054   0x6800             LDR      R0,[R0, #+0]
   \   00000056   0xF450 0x7080      ORRS     R0,R0,#0x100
   \   0000005A   0x6821             LDR      R1,[R4, #+0]
   \   0000005C   0x6008             STR      R0,[R1, #+0]
    416          
    417            /* Enable the Peripheral */
    418            __HAL_DMA2D_ENABLE(hdma2d);
   \   0000005E   0x6820             LDR      R0,[R4, #+0]
   \   00000060   0x6800             LDR      R0,[R0, #+0]
   \   00000062   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000066   0x6821             LDR      R1,[R4, #+0]
   \   00000068   0x6008             STR      R0,[R1, #+0]
    419          
    420            /* Enable the configuration error interrupt */
    421            __HAL_DMA2D_ENABLE_IT(hdma2d, DMA2D_IT_CE);
   \   0000006A   0x6820             LDR      R0,[R4, #+0]
   \   0000006C   0x6800             LDR      R0,[R0, #+0]
   \   0000006E   0xF450 0x5000      ORRS     R0,R0,#0x2000
   \   00000072   0x6821             LDR      R1,[R4, #+0]
   \   00000074   0x6008             STR      R0,[R1, #+0]
    422          
    423            return HAL_OK;
   \   00000076   0x2000             MOVS     R0,#+0
   \                     ??HAL_DMA2D_Start_IT_1: (+1)
   \   00000078   0xE8BD 0x81F6      POP      {R1,R2,R4-R8,PC}  ;; return
    424          }
    425          
    426          /**
    427            * @brief  Start the multi-source DMA2D Transfer.
    428            * @param  hdma2d:      pointer to a DMA2D_HandleTypeDef structure that contains
    429            *                      the configuration information for the DMA2D.  
    430            * @param  SrcAddress1: The source memory Buffer address of the foreground layer.
    431            * @param  SrcAddress2: The source memory Buffer address of the background layer.
    432            * @param  DstAddress:  The destination memory Buffer address
    433            * @param  Width:       The width of data to be transferred from source to destination.
    434            * @param  Height:      The height of data to be transferred from source to destination.
    435            * @retval HAL status
    436            */

   \                                 In section .text, align 2, keep-with-next
    437          HAL_StatusTypeDef HAL_DMA2D_BlendingStart(DMA2D_HandleTypeDef *hdma2d, uint32_t SrcAddress1, uint32_t  SrcAddress2, uint32_t DstAddress, uint32_t Width,  uint32_t Height)
    438          {
   \                     HAL_DMA2D_BlendingStart: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
   \   0000000C   0xF8DD 0x8020      LDR      R8,[SP, #+32]
   \   00000010   0xF8DD 0x9024      LDR      R9,[SP, #+36]
    439            /* Process locked */
    440            __HAL_LOCK(hdma2d);
   \   00000014   0xF894 0x0038      LDRB     R0,[R4, #+56]
   \   00000018   0x2801             CMP      R0,#+1
   \   0000001A   0xD101             BNE.N    ??HAL_DMA2D_BlendingStart_0
   \   0000001C   0x2002             MOVS     R0,#+2
   \   0000001E   0xE01C             B.N      ??HAL_DMA2D_BlendingStart_1
   \                     ??HAL_DMA2D_BlendingStart_0: (+1)
   \   00000020   0x2001             MOVS     R0,#+1
   \   00000022   0xF884 0x0038      STRB     R0,[R4, #+56]
    441          
    442            /* Change DMA2D peripheral state */
    443            hdma2d->State = HAL_DMA2D_STATE_BUSY; 
   \   00000026   0x2002             MOVS     R0,#+2
   \   00000028   0xF884 0x0039      STRB     R0,[R4, #+57]
    444          
    445            /* Check the parameters */
    446            assert_param(IS_DMA2D_LINE(Height));
    447            assert_param(IS_DMA2D_PIXEL(Width));
    448          
    449            /* Disable the Peripheral */
    450            __HAL_DMA2D_DISABLE(hdma2d);
   \   0000002C   0x6820             LDR      R0,[R4, #+0]
   \   0000002E   0x6800             LDR      R0,[R0, #+0]
   \   00000030   0x0840             LSRS     R0,R0,#+1
   \   00000032   0x0040             LSLS     R0,R0,#+1
   \   00000034   0x6821             LDR      R1,[R4, #+0]
   \   00000036   0x6008             STR      R0,[R1, #+0]
    451          
    452            /* Configure DMA2D Stream source2 address */
    453            hdma2d->Instance->BGMAR = SrcAddress2;
   \   00000038   0x6820             LDR      R0,[R4, #+0]
   \   0000003A   0x6146             STR      R6,[R0, #+20]
    454          
    455            /* Configure the source, destination address and the data size */
    456            DMA2D_SetConfig(hdma2d, SrcAddress1, DstAddress, Width, Height);
   \   0000003C   0xF8CD 0x9000      STR      R9,[SP, #+0]
   \   00000040   0x4643             MOV      R3,R8
   \   00000042   0x003A             MOVS     R2,R7
   \   00000044   0x0029             MOVS     R1,R5
   \   00000046   0x0020             MOVS     R0,R4
   \   00000048   0x.... 0x....      BL       DMA2D_SetConfig
    457          
    458            /* Enable the Peripheral */
    459            __HAL_DMA2D_ENABLE(hdma2d);
   \   0000004C   0x6820             LDR      R0,[R4, #+0]
   \   0000004E   0x6800             LDR      R0,[R0, #+0]
   \   00000050   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000054   0x6821             LDR      R1,[R4, #+0]
   \   00000056   0x6008             STR      R0,[R1, #+0]
    460          
    461            return HAL_OK;
   \   00000058   0x2000             MOVS     R0,#+0
   \                     ??HAL_DMA2D_BlendingStart_1: (+1)
   \   0000005A   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    462          }
    463          
    464          /**
    465            * @brief  Start the multi-source DMA2D Transfer with interrupt enabled.
    466            * @param  hdma2d:     pointer to a DMA2D_HandleTypeDef structure that contains
    467            *                     the configuration information for the DMA2D.  
    468            * @param  SrcAddress1: The source memory Buffer address of the foreground layer.
    469            * @param  SrcAddress2: The source memory Buffer address of the background layer.
    470            * @param  DstAddress:  The destination memory Buffer address.
    471            * @param  Width:       The width of data to be transferred from source to destination.
    472            * @param  Height:      The height of data to be transferred from source to destination.
    473            * @retval HAL status
    474            */

   \                                 In section .text, align 2, keep-with-next
    475          HAL_StatusTypeDef HAL_DMA2D_BlendingStart_IT(DMA2D_HandleTypeDef *hdma2d, uint32_t SrcAddress1, uint32_t  SrcAddress2, uint32_t DstAddress, uint32_t Width,  uint32_t Height)
    476          {
   \                     HAL_DMA2D_BlendingStart_IT: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
   \   0000000C   0xF8DD 0x8020      LDR      R8,[SP, #+32]
   \   00000010   0xF8DD 0x9024      LDR      R9,[SP, #+36]
    477            /* Process locked */
    478            __HAL_LOCK(hdma2d);
   \   00000014   0xF894 0x0038      LDRB     R0,[R4, #+56]
   \   00000018   0x2801             CMP      R0,#+1
   \   0000001A   0xD101             BNE.N    ??HAL_DMA2D_BlendingStart_IT_0
   \   0000001C   0x2002             MOVS     R0,#+2
   \   0000001E   0xE02E             B.N      ??HAL_DMA2D_BlendingStart_IT_1
   \                     ??HAL_DMA2D_BlendingStart_IT_0: (+1)
   \   00000020   0x2001             MOVS     R0,#+1
   \   00000022   0xF884 0x0038      STRB     R0,[R4, #+56]
    479          
    480            /* Change DMA2D peripheral state */
    481            hdma2d->State = HAL_DMA2D_STATE_BUSY;
   \   00000026   0x2002             MOVS     R0,#+2
   \   00000028   0xF884 0x0039      STRB     R0,[R4, #+57]
    482          
    483            /* Check the parameters */
    484            assert_param(IS_DMA2D_LINE(Height));
    485            assert_param(IS_DMA2D_PIXEL(Width));
    486          
    487            /* Disable the Peripheral */
    488            __HAL_DMA2D_DISABLE(hdma2d);
   \   0000002C   0x6820             LDR      R0,[R4, #+0]
   \   0000002E   0x6800             LDR      R0,[R0, #+0]
   \   00000030   0x0840             LSRS     R0,R0,#+1
   \   00000032   0x0040             LSLS     R0,R0,#+1
   \   00000034   0x6821             LDR      R1,[R4, #+0]
   \   00000036   0x6008             STR      R0,[R1, #+0]
    489           
    490            /* Configure DMA2D Stream source2 address */
    491            hdma2d->Instance->BGMAR = SrcAddress2;
   \   00000038   0x6820             LDR      R0,[R4, #+0]
   \   0000003A   0x6146             STR      R6,[R0, #+20]
    492          
    493            /* Configure the source, destination address and the data size */
    494            DMA2D_SetConfig(hdma2d, SrcAddress1, DstAddress, Width, Height);
   \   0000003C   0xF8CD 0x9000      STR      R9,[SP, #+0]
   \   00000040   0x4643             MOV      R3,R8
   \   00000042   0x003A             MOVS     R2,R7
   \   00000044   0x0029             MOVS     R1,R5
   \   00000046   0x0020             MOVS     R0,R4
   \   00000048   0x.... 0x....      BL       DMA2D_SetConfig
    495          
    496            /* Enable the configuration error interrupt */
    497            __HAL_DMA2D_ENABLE_IT(hdma2d, DMA2D_IT_CE);
   \   0000004C   0x6820             LDR      R0,[R4, #+0]
   \   0000004E   0x6800             LDR      R0,[R0, #+0]
   \   00000050   0xF450 0x5000      ORRS     R0,R0,#0x2000
   \   00000054   0x6821             LDR      R1,[R4, #+0]
   \   00000056   0x6008             STR      R0,[R1, #+0]
    498          
    499            /* Enable the transfer complete interrupt */
    500            __HAL_DMA2D_ENABLE_IT(hdma2d, DMA2D_IT_TC);
   \   00000058   0x6820             LDR      R0,[R4, #+0]
   \   0000005A   0x6800             LDR      R0,[R0, #+0]
   \   0000005C   0xF450 0x7000      ORRS     R0,R0,#0x200
   \   00000060   0x6821             LDR      R1,[R4, #+0]
   \   00000062   0x6008             STR      R0,[R1, #+0]
    501          
    502            /* Enable the transfer Error interrupt */
    503            __HAL_DMA2D_ENABLE_IT(hdma2d, DMA2D_IT_TE);
   \   00000064   0x6820             LDR      R0,[R4, #+0]
   \   00000066   0x6800             LDR      R0,[R0, #+0]
   \   00000068   0xF450 0x7080      ORRS     R0,R0,#0x100
   \   0000006C   0x6821             LDR      R1,[R4, #+0]
   \   0000006E   0x6008             STR      R0,[R1, #+0]
    504          
    505            /* Enable the Peripheral */
    506            __HAL_DMA2D_ENABLE(hdma2d);
   \   00000070   0x6820             LDR      R0,[R4, #+0]
   \   00000072   0x6800             LDR      R0,[R0, #+0]
   \   00000074   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000078   0x6821             LDR      R1,[R4, #+0]
   \   0000007A   0x6008             STR      R0,[R1, #+0]
    507          
    508            return HAL_OK;
   \   0000007C   0x2000             MOVS     R0,#+0
   \                     ??HAL_DMA2D_BlendingStart_IT_1: (+1)
   \   0000007E   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    509          }
    510          
    511          /**
    512            * @brief  Abort the DMA2D Transfer.
    513            * @param  hdma2d : pointer to a DMA2D_HandleTypeDef structure that contains
    514            *                  the configuration information for the DMA2D.
    515            * @retval HAL status
    516            */

   \                                 In section .text, align 2, keep-with-next
    517          HAL_StatusTypeDef HAL_DMA2D_Abort(DMA2D_HandleTypeDef *hdma2d)
    518          {
   \                     HAL_DMA2D_Abort: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    519            uint32_t tickstart = 0;
   \   00000004   0x2500             MOVS     R5,#+0
    520          
    521            /* Disable the DMA2D */
    522            __HAL_DMA2D_DISABLE(hdma2d);
   \   00000006   0x6820             LDR      R0,[R4, #+0]
   \   00000008   0x6800             LDR      R0,[R0, #+0]
   \   0000000A   0x0840             LSRS     R0,R0,#+1
   \   0000000C   0x0040             LSLS     R0,R0,#+1
   \   0000000E   0x6821             LDR      R1,[R4, #+0]
   \   00000010   0x6008             STR      R0,[R1, #+0]
    523          
    524            /* Get tick */
    525            tickstart = HAL_GetTick();
   \   00000012   0x.... 0x....      BL       HAL_GetTick
   \   00000016   0x0005             MOVS     R5,R0
    526          
    527            /* Check if the DMA2D is effectively disabled */
    528            while((hdma2d->Instance->CR & DMA2D_CR_START) != 0)
   \                     ??HAL_DMA2D_Abort_0: (+1)
   \   00000018   0x6820             LDR      R0,[R4, #+0]
   \   0000001A   0x6800             LDR      R0,[R0, #+0]
   \   0000001C   0x07C0             LSLS     R0,R0,#+31
   \   0000001E   0xD511             BPL.N    ??HAL_DMA2D_Abort_1
    529            {
    530              if((HAL_GetTick() - tickstart ) > HAL_TIMEOUT_DMA2D_ABORT)
   \   00000020   0x.... 0x....      BL       HAL_GetTick
   \   00000024   0x1B40             SUBS     R0,R0,R5
   \   00000026   0xF5B0 0x7F7A      CMP      R0,#+1000
   \   0000002A   0xD9F5             BLS.N    ??HAL_DMA2D_Abort_0
    531              {
    532                /* Update error code */
    533                hdma2d->ErrorCode |= HAL_DMA2D_ERROR_TIMEOUT;
   \   0000002C   0x6BE0             LDR      R0,[R4, #+60]
   \   0000002E   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   00000032   0x63E0             STR      R0,[R4, #+60]
    534                
    535                /* Change the DMA2D state */
    536                hdma2d->State= HAL_DMA2D_STATE_TIMEOUT;
   \   00000034   0x2003             MOVS     R0,#+3
   \   00000036   0xF884 0x0039      STRB     R0,[R4, #+57]
    537                
    538                /* Process Unlocked */
    539                __HAL_UNLOCK(hdma2d);
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0xF884 0x0038      STRB     R0,[R4, #+56]
    540                
    541                return HAL_TIMEOUT;
   \   00000040   0x2003             MOVS     R0,#+3
   \   00000042   0xE006             B.N      ??HAL_DMA2D_Abort_2
    542              }
    543            }
    544            /* Process Unlocked */
    545            __HAL_UNLOCK(hdma2d);
   \                     ??HAL_DMA2D_Abort_1: (+1)
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0xF884 0x0038      STRB     R0,[R4, #+56]
    546          
    547            /* Change the DMA2D state*/
    548            hdma2d->State = HAL_DMA2D_STATE_READY;
   \   0000004A   0x2001             MOVS     R0,#+1
   \   0000004C   0xF884 0x0039      STRB     R0,[R4, #+57]
    549          
    550            return HAL_OK;
   \   00000050   0x2000             MOVS     R0,#+0
   \                     ??HAL_DMA2D_Abort_2: (+1)
   \   00000052   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    551          }
    552          
    553          /**
    554            * @brief  Suspend the DMA2D Transfer.
    555            * @param  hdma2d: pointer to a DMA2D_HandleTypeDef structure that contains
    556            *                 the configuration information for the DMA2D. 
    557            * @retval HAL status
    558            */

   \                                 In section .text, align 2, keep-with-next
    559          HAL_StatusTypeDef HAL_DMA2D_Suspend(DMA2D_HandleTypeDef *hdma2d)
    560          {
   \                     HAL_DMA2D_Suspend: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    561            uint32_t tickstart = 0;
   \   00000004   0x2500             MOVS     R5,#+0
    562          
    563            /* Suspend the DMA2D transfer */
    564            hdma2d->Instance->CR |= DMA2D_CR_SUSP;
   \   00000006   0x6820             LDR      R0,[R4, #+0]
   \   00000008   0x6800             LDR      R0,[R0, #+0]
   \   0000000A   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   0000000E   0x6821             LDR      R1,[R4, #+0]
   \   00000010   0x6008             STR      R0,[R1, #+0]
    565          
    566            /* Get tick */
    567            tickstart = HAL_GetTick();
   \   00000012   0x.... 0x....      BL       HAL_GetTick
   \   00000016   0x0005             MOVS     R5,R0
    568          
    569            /* Check if the DMA2D is effectively suspended */
    570            while((hdma2d->Instance->CR & DMA2D_CR_SUSP) != DMA2D_CR_SUSP)
   \                     ??HAL_DMA2D_Suspend_0: (+1)
   \   00000018   0x6820             LDR      R0,[R4, #+0]
   \   0000001A   0x6800             LDR      R0,[R0, #+0]
   \   0000001C   0x0780             LSLS     R0,R0,#+30
   \   0000001E   0xD40E             BMI.N    ??HAL_DMA2D_Suspend_1
    571            {
    572              if((HAL_GetTick() - tickstart ) > HAL_TIMEOUT_DMA2D_SUSPEND)
   \   00000020   0x.... 0x....      BL       HAL_GetTick
   \   00000024   0x1B40             SUBS     R0,R0,R5
   \   00000026   0xF5B0 0x7F7A      CMP      R0,#+1000
   \   0000002A   0xD9F5             BLS.N    ??HAL_DMA2D_Suspend_0
    573              {
    574                /* Update error code */
    575                hdma2d->ErrorCode |= HAL_DMA2D_ERROR_TIMEOUT;
   \   0000002C   0x6BE0             LDR      R0,[R4, #+60]
   \   0000002E   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   00000032   0x63E0             STR      R0,[R4, #+60]
    576                
    577                /* Change the DMA2D state */
    578                hdma2d->State= HAL_DMA2D_STATE_TIMEOUT;
   \   00000034   0x2003             MOVS     R0,#+3
   \   00000036   0xF884 0x0039      STRB     R0,[R4, #+57]
    579                
    580                return HAL_TIMEOUT;
   \   0000003A   0x2003             MOVS     R0,#+3
   \   0000003C   0xE003             B.N      ??HAL_DMA2D_Suspend_2
    581              }
    582            }
    583            /* Change the DMA2D state*/
    584            hdma2d->State = HAL_DMA2D_STATE_SUSPEND;
   \                     ??HAL_DMA2D_Suspend_1: (+1)
   \   0000003E   0x2005             MOVS     R0,#+5
   \   00000040   0xF884 0x0039      STRB     R0,[R4, #+57]
    585          
    586            return HAL_OK;
   \   00000044   0x2000             MOVS     R0,#+0
   \                     ??HAL_DMA2D_Suspend_2: (+1)
   \   00000046   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    587          }
    588          
    589          /**
    590            * @brief  Resume the DMA2D Transfer.
    591            * @param  hdma2d: pointer to a DMA2D_HandleTypeDef structure that contains
    592            *                 the configuration information for the DMA2D.  
    593            * @retval HAL status
    594            */

   \                                 In section .text, align 2, keep-with-next
    595          HAL_StatusTypeDef HAL_DMA2D_Resume(DMA2D_HandleTypeDef *hdma2d)
    596          {
   \                     HAL_DMA2D_Resume: (+1)
   \   00000000   0x0001             MOVS     R1,R0
    597            /* Resume the DMA2D transfer */
    598            hdma2d->Instance->CR &= ~DMA2D_CR_SUSP;
   \   00000002   0x6808             LDR      R0,[R1, #+0]
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0xF030 0x0002      BICS     R0,R0,#0x2
   \   0000000A   0x680A             LDR      R2,[R1, #+0]
   \   0000000C   0x6010             STR      R0,[R2, #+0]
    599          
    600            /* Change the DMA2D state*/
    601            hdma2d->State = HAL_DMA2D_STATE_BUSY;
   \   0000000E   0x2002             MOVS     R0,#+2
   \   00000010   0xF881 0x0039      STRB     R0,[R1, #+57]
    602          
    603            return HAL_OK;
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0x4770             BX       LR               ;; return
    604          }
    605          
    606          /**
    607            * @brief  Polling for transfer complete or CLUT loading.
    608            * @param  hdma2d: pointer to a DMA2D_HandleTypeDef structure that contains
    609            *                 the configuration information for the DMA2D. 
    610            * @param  Timeout: Timeout duration
    611            * @retval HAL status
    612            */

   \                                 In section .text, align 2, keep-with-next
    613          HAL_StatusTypeDef HAL_DMA2D_PollForTransfer(DMA2D_HandleTypeDef *hdma2d, uint32_t Timeout)
    614          {
   \                     HAL_DMA2D_PollForTransfer: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
    615            uint32_t tmp, tmp1;
    616            uint32_t tickstart = 0;
   \   00000008   0xF05F 0x0800      MOVS     R8,#+0
    617          
    618            /* Polling for DMA2D transfer */
    619            if((hdma2d->Instance->CR & DMA2D_CR_START) != 0)
   \   0000000C   0x6820             LDR      R0,[R4, #+0]
   \   0000000E   0x6800             LDR      R0,[R0, #+0]
   \   00000010   0x07C0             LSLS     R0,R0,#+31
   \   00000012   0xD539             BPL.N    ??HAL_DMA2D_PollForTransfer_0
    620            {
    621             /* Get tick */
    622             tickstart = HAL_GetTick();
   \   00000014   0x.... 0x....      BL       HAL_GetTick
   \   00000018   0x4680             MOV      R8,R0
    623          
    624              while(__HAL_DMA2D_GET_FLAG(hdma2d, DMA2D_FLAG_TC) == RESET)
   \                     ??HAL_DMA2D_PollForTransfer_1: (+1)
   \   0000001A   0x6820             LDR      R0,[R4, #+0]
   \   0000001C   0x6840             LDR      R0,[R0, #+4]
   \   0000001E   0x0780             LSLS     R0,R0,#+30
   \   00000020   0xD432             BMI.N    ??HAL_DMA2D_PollForTransfer_0
    625              {
    626                tmp  = __HAL_DMA2D_GET_FLAG(hdma2d, DMA2D_FLAG_CE);
   \   00000022   0x6820             LDR      R0,[R4, #+0]
   \   00000024   0x6840             LDR      R0,[R0, #+4]
   \   00000026   0xF010 0x0020      ANDS     R0,R0,#0x20
   \   0000002A   0x0006             MOVS     R6,R0
    627                tmp1 = __HAL_DMA2D_GET_FLAG(hdma2d, DMA2D_FLAG_TE);
   \   0000002C   0x6820             LDR      R0,[R4, #+0]
   \   0000002E   0x6840             LDR      R0,[R0, #+4]
   \   00000030   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   00000034   0x0007             MOVS     R7,R0
    628          
    629                if((tmp != RESET) || (tmp1 != RESET))
   \   00000036   0xEA57 0x0006      ORRS     R0,R7,R6
   \   0000003A   0x2800             CMP      R0,#+0
   \   0000003C   0xD00D             BEQ.N    ??HAL_DMA2D_PollForTransfer_2
    630                {
    631                  /* Clear the transfer and configuration error flags */
    632                  __HAL_DMA2D_CLEAR_FLAG(hdma2d, DMA2D_FLAG_CE);
   \   0000003E   0x2020             MOVS     R0,#+32
   \   00000040   0x6821             LDR      R1,[R4, #+0]
   \   00000042   0x6088             STR      R0,[R1, #+8]
    633                  __HAL_DMA2D_CLEAR_FLAG(hdma2d, DMA2D_FLAG_TE);
   \   00000044   0x2001             MOVS     R0,#+1
   \   00000046   0x6821             LDR      R1,[R4, #+0]
   \   00000048   0x6088             STR      R0,[R1, #+8]
    634          
    635                  /* Change DMA2D state */
    636                  hdma2d->State= HAL_DMA2D_STATE_ERROR;
   \   0000004A   0x2004             MOVS     R0,#+4
   \   0000004C   0xF884 0x0039      STRB     R0,[R4, #+57]
    637          
    638                  /* Process unlocked */
    639                  __HAL_UNLOCK(hdma2d);
   \   00000050   0x2000             MOVS     R0,#+0
   \   00000052   0xF884 0x0038      STRB     R0,[R4, #+56]
    640                  
    641                  return HAL_ERROR;
   \   00000056   0x2001             MOVS     R0,#+1
   \   00000058   0xE04E             B.N      ??HAL_DMA2D_PollForTransfer_3
    642                }
    643                /* Check for the Timeout */
    644                if(Timeout != HAL_MAX_DELAY)
   \                     ??HAL_DMA2D_PollForTransfer_2: (+1)
   \   0000005A   0xF115 0x0F01      CMN      R5,#+1
   \   0000005E   0xD0DC             BEQ.N    ??HAL_DMA2D_PollForTransfer_1
    645                {
    646                  if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
   \   00000060   0x2D00             CMP      R5,#+0
   \   00000062   0xD005             BEQ.N    ??HAL_DMA2D_PollForTransfer_4
   \   00000064   0x.... 0x....      BL       HAL_GetTick
   \   00000068   0xEBB0 0x0008      SUBS     R0,R0,R8
   \   0000006C   0x4285             CMP      R5,R0
   \   0000006E   0xD2D4             BCS.N    ??HAL_DMA2D_PollForTransfer_1
    647                  {
    648                    /* Process unlocked */
    649                    __HAL_UNLOCK(hdma2d);
   \                     ??HAL_DMA2D_PollForTransfer_4: (+1)
   \   00000070   0x2000             MOVS     R0,#+0
   \   00000072   0xF884 0x0038      STRB     R0,[R4, #+56]
    650                  
    651                    /* Update error code */
    652                    hdma2d->ErrorCode |= HAL_DMA2D_ERROR_TIMEOUT;
   \   00000076   0x6BE0             LDR      R0,[R4, #+60]
   \   00000078   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   0000007C   0x63E0             STR      R0,[R4, #+60]
    653          
    654                    /* Change the DMA2D state */
    655                    hdma2d->State= HAL_DMA2D_STATE_TIMEOUT;
   \   0000007E   0x2003             MOVS     R0,#+3
   \   00000080   0xF884 0x0039      STRB     R0,[R4, #+57]
    656                    
    657                    return HAL_TIMEOUT;
   \   00000084   0x2003             MOVS     R0,#+3
   \   00000086   0xE037             B.N      ??HAL_DMA2D_PollForTransfer_3
    658                  }
    659                }        
    660              }
    661            }
    662            /* Polling for CLUT loading */
    663            if((hdma2d->Instance->FGPFCCR & DMA2D_FGPFCCR_START) != 0)
   \                     ??HAL_DMA2D_PollForTransfer_0: (+1)
   \   00000088   0x6820             LDR      R0,[R4, #+0]
   \   0000008A   0x69C0             LDR      R0,[R0, #+28]
   \   0000008C   0x0680             LSLS     R0,R0,#+26
   \   0000008E   0xD526             BPL.N    ??HAL_DMA2D_PollForTransfer_5
    664            {
    665              /* Get tick */
    666              tickstart = HAL_GetTick();
   \   00000090   0x.... 0x....      BL       HAL_GetTick
   \   00000094   0x4680             MOV      R8,R0
    667             
    668              while(__HAL_DMA2D_GET_FLAG(hdma2d, DMA2D_FLAG_CTC) == RESET)
   \                     ??HAL_DMA2D_PollForTransfer_6: (+1)
   \   00000096   0x6820             LDR      R0,[R4, #+0]
   \   00000098   0x6840             LDR      R0,[R0, #+4]
   \   0000009A   0x06C0             LSLS     R0,R0,#+27
   \   0000009C   0xD41F             BMI.N    ??HAL_DMA2D_PollForTransfer_5
    669              {
    670                if((__HAL_DMA2D_GET_FLAG(hdma2d, DMA2D_FLAG_CAE) != RESET))
   \   0000009E   0x6820             LDR      R0,[R4, #+0]
   \   000000A0   0x6840             LDR      R0,[R0, #+4]
   \   000000A2   0x0700             LSLS     R0,R0,#+28
   \   000000A4   0xD507             BPL.N    ??HAL_DMA2D_PollForTransfer_7
    671                {      
    672                  /* Clear the transfer and configuration error flags */
    673                  __HAL_DMA2D_CLEAR_FLAG(hdma2d, DMA2D_FLAG_CAE);
   \   000000A6   0x2008             MOVS     R0,#+8
   \   000000A8   0x6821             LDR      R1,[R4, #+0]
   \   000000AA   0x6088             STR      R0,[R1, #+8]
    674                  
    675                  /* Change DMA2D state */
    676                  hdma2d->State= HAL_DMA2D_STATE_ERROR;
   \   000000AC   0x2004             MOVS     R0,#+4
   \   000000AE   0xF884 0x0039      STRB     R0,[R4, #+57]
    677                  
    678                  return HAL_ERROR;      
   \   000000B2   0x2001             MOVS     R0,#+1
   \   000000B4   0xE020             B.N      ??HAL_DMA2D_PollForTransfer_3
    679                }      
    680                /* Check for the Timeout */
    681                if(Timeout != HAL_MAX_DELAY)
   \                     ??HAL_DMA2D_PollForTransfer_7: (+1)
   \   000000B6   0xF115 0x0F01      CMN      R5,#+1
   \   000000BA   0xD0EC             BEQ.N    ??HAL_DMA2D_PollForTransfer_6
    682                {
    683                  if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
   \   000000BC   0x2D00             CMP      R5,#+0
   \   000000BE   0xD005             BEQ.N    ??HAL_DMA2D_PollForTransfer_8
   \   000000C0   0x.... 0x....      BL       HAL_GetTick
   \   000000C4   0xEBB0 0x0008      SUBS     R0,R0,R8
   \   000000C8   0x4285             CMP      R5,R0
   \   000000CA   0xD2E4             BCS.N    ??HAL_DMA2D_PollForTransfer_6
    684                  {
    685                    /* Update error code */
    686                    hdma2d->ErrorCode |= HAL_DMA2D_ERROR_TIMEOUT;
   \                     ??HAL_DMA2D_PollForTransfer_8: (+1)
   \   000000CC   0x6BE0             LDR      R0,[R4, #+60]
   \   000000CE   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   000000D2   0x63E0             STR      R0,[R4, #+60]
    687              
    688                    /* Change the DMA2D state */
    689                    hdma2d->State= HAL_DMA2D_STATE_TIMEOUT;
   \   000000D4   0x2003             MOVS     R0,#+3
   \   000000D6   0xF884 0x0039      STRB     R0,[R4, #+57]
    690                    
    691                    return HAL_TIMEOUT;
   \   000000DA   0x2003             MOVS     R0,#+3
   \   000000DC   0xE00C             B.N      ??HAL_DMA2D_PollForTransfer_3
    692                  }
    693                }      
    694              }
    695            }
    696            /* Clear the transfer complete flag */
    697            __HAL_DMA2D_CLEAR_FLAG(hdma2d, DMA2D_FLAG_TC);
   \                     ??HAL_DMA2D_PollForTransfer_5: (+1)
   \   000000DE   0x2002             MOVS     R0,#+2
   \   000000E0   0x6821             LDR      R1,[R4, #+0]
   \   000000E2   0x6088             STR      R0,[R1, #+8]
    698            
    699            /* Clear the CLUT loading flag */
    700            __HAL_DMA2D_CLEAR_FLAG(hdma2d, DMA2D_FLAG_CTC);  
   \   000000E4   0x2010             MOVS     R0,#+16
   \   000000E6   0x6821             LDR      R1,[R4, #+0]
   \   000000E8   0x6088             STR      R0,[R1, #+8]
    701            
    702            /* Change DMA2D state */
    703            hdma2d->State = HAL_DMA2D_STATE_READY;
   \   000000EA   0x2001             MOVS     R0,#+1
   \   000000EC   0xF884 0x0039      STRB     R0,[R4, #+57]
    704            
    705            /* Process unlocked */
    706            __HAL_UNLOCK(hdma2d);
   \   000000F0   0x2000             MOVS     R0,#+0
   \   000000F2   0xF884 0x0038      STRB     R0,[R4, #+56]
    707            
    708            return HAL_OK;
   \   000000F6   0x2000             MOVS     R0,#+0
   \                     ??HAL_DMA2D_PollForTransfer_3: (+1)
   \   000000F8   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    709          }
    710          /**
    711            * @brief  Handles DMA2D interrupt request.
    712            * @param  hdma2d: pointer to a DMA2D_HandleTypeDef structure that contains
    713            *                 the configuration information for the DMA2D.  
    714            * @retval HAL status
    715            */

   \                                 In section .text, align 2, keep-with-next
    716          void HAL_DMA2D_IRQHandler(DMA2D_HandleTypeDef *hdma2d)
    717          {    
   \                     HAL_DMA2D_IRQHandler: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    718            /* Transfer Error Interrupt management ***************************************/
    719            if(__HAL_DMA2D_GET_FLAG(hdma2d, DMA2D_FLAG_TE) != RESET)
   \   00000004   0x6820             LDR      R0,[R4, #+0]
   \   00000006   0x6840             LDR      R0,[R0, #+4]
   \   00000008   0x07C0             LSLS     R0,R0,#+31
   \   0000000A   0xD51C             BPL.N    ??HAL_DMA2D_IRQHandler_0
    720            {
    721              if(__HAL_DMA2D_GET_IT_SOURCE(hdma2d, DMA2D_IT_TE) != RESET)
   \   0000000C   0x6820             LDR      R0,[R4, #+0]
   \   0000000E   0x6800             LDR      R0,[R0, #+0]
   \   00000010   0x05C0             LSLS     R0,R0,#+23
   \   00000012   0xD518             BPL.N    ??HAL_DMA2D_IRQHandler_0
    722              {
    723                /* Disable the transfer Error interrupt */
    724                __HAL_DMA2D_DISABLE_IT(hdma2d, DMA2D_IT_TE);  
   \   00000014   0x6820             LDR      R0,[R4, #+0]
   \   00000016   0x6800             LDR      R0,[R0, #+0]
   \   00000018   0xF430 0x7080      BICS     R0,R0,#0x100
   \   0000001C   0x6821             LDR      R1,[R4, #+0]
   \   0000001E   0x6008             STR      R0,[R1, #+0]
    725          
    726                /* Update error code */
    727                hdma2d->ErrorCode |= HAL_DMA2D_ERROR_TE;
   \   00000020   0x6BE0             LDR      R0,[R4, #+60]
   \   00000022   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000026   0x63E0             STR      R0,[R4, #+60]
    728              
    729                /* Clear the transfer error flag */
    730                __HAL_DMA2D_CLEAR_FLAG(hdma2d, DMA2D_FLAG_TE);
   \   00000028   0x2001             MOVS     R0,#+1
   \   0000002A   0x6821             LDR      R1,[R4, #+0]
   \   0000002C   0x6088             STR      R0,[R1, #+8]
    731          
    732                /* Change DMA2D state */
    733                hdma2d->State = HAL_DMA2D_STATE_ERROR;
   \   0000002E   0x2004             MOVS     R0,#+4
   \   00000030   0xF884 0x0039      STRB     R0,[R4, #+57]
    734          
    735                /* Process Unlocked */
    736                __HAL_UNLOCK(hdma2d);       
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0xF884 0x0038      STRB     R0,[R4, #+56]
    737                
    738                if(hdma2d->XferErrorCallback != NULL)
   \   0000003A   0x6960             LDR      R0,[R4, #+20]
   \   0000003C   0x2800             CMP      R0,#+0
   \   0000003E   0xD002             BEQ.N    ??HAL_DMA2D_IRQHandler_0
    739                {
    740                  /* Transfer error Callback */
    741                  hdma2d->XferErrorCallback(hdma2d);
   \   00000040   0x0020             MOVS     R0,R4
   \   00000042   0x6961             LDR      R1,[R4, #+20]
   \   00000044   0x4788             BLX      R1
    742                }
    743              }
    744            }
    745            /* Configuration Error Interrupt management **********************************/
    746            if(__HAL_DMA2D_GET_FLAG(hdma2d, DMA2D_FLAG_CE) != RESET)
   \                     ??HAL_DMA2D_IRQHandler_0: (+1)
   \   00000046   0x6820             LDR      R0,[R4, #+0]
   \   00000048   0x6840             LDR      R0,[R0, #+4]
   \   0000004A   0x0680             LSLS     R0,R0,#+26
   \   0000004C   0xD51C             BPL.N    ??HAL_DMA2D_IRQHandler_1
    747            {
    748              if(__HAL_DMA2D_GET_IT_SOURCE(hdma2d, DMA2D_IT_CE) != RESET)
   \   0000004E   0x6820             LDR      R0,[R4, #+0]
   \   00000050   0x6800             LDR      R0,[R0, #+0]
   \   00000052   0x0480             LSLS     R0,R0,#+18
   \   00000054   0xD518             BPL.N    ??HAL_DMA2D_IRQHandler_1
    749              {
    750                /* Disable the Configuration Error interrupt */
    751                __HAL_DMA2D_DISABLE_IT(hdma2d, DMA2D_IT_CE);
   \   00000056   0x6820             LDR      R0,[R4, #+0]
   \   00000058   0x6800             LDR      R0,[R0, #+0]
   \   0000005A   0xF430 0x5000      BICS     R0,R0,#0x2000
   \   0000005E   0x6821             LDR      R1,[R4, #+0]
   \   00000060   0x6008             STR      R0,[R1, #+0]
    752            
    753                /* Clear the Configuration error flag */
    754                __HAL_DMA2D_CLEAR_FLAG(hdma2d, DMA2D_FLAG_CE);
   \   00000062   0x2020             MOVS     R0,#+32
   \   00000064   0x6821             LDR      R1,[R4, #+0]
   \   00000066   0x6088             STR      R0,[R1, #+8]
    755          
    756                /* Update error code */
    757                hdma2d->ErrorCode |= HAL_DMA2D_ERROR_CE;    
   \   00000068   0x6BE0             LDR      R0,[R4, #+60]
   \   0000006A   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   0000006E   0x63E0             STR      R0,[R4, #+60]
    758              
    759                /* Change DMA2D state */
    760                hdma2d->State = HAL_DMA2D_STATE_ERROR;
   \   00000070   0x2004             MOVS     R0,#+4
   \   00000072   0xF884 0x0039      STRB     R0,[R4, #+57]
    761          
    762                /* Process Unlocked */
    763                __HAL_UNLOCK(hdma2d);       
   \   00000076   0x2000             MOVS     R0,#+0
   \   00000078   0xF884 0x0038      STRB     R0,[R4, #+56]
    764                
    765                if(hdma2d->XferErrorCallback != NULL)
   \   0000007C   0x6960             LDR      R0,[R4, #+20]
   \   0000007E   0x2800             CMP      R0,#+0
   \   00000080   0xD002             BEQ.N    ??HAL_DMA2D_IRQHandler_1
    766                {
    767                  /* Transfer error Callback */
    768                  hdma2d->XferErrorCallback(hdma2d);
   \   00000082   0x0020             MOVS     R0,R4
   \   00000084   0x6961             LDR      R1,[R4, #+20]
   \   00000086   0x4788             BLX      R1
    769                }
    770              }
    771            }
    772            /* Transfer Complete Interrupt management ************************************/
    773            if(__HAL_DMA2D_GET_FLAG(hdma2d, DMA2D_FLAG_TC) != RESET)
   \                     ??HAL_DMA2D_IRQHandler_1: (+1)
   \   00000088   0x6820             LDR      R0,[R4, #+0]
   \   0000008A   0x6840             LDR      R0,[R0, #+4]
   \   0000008C   0x0780             LSLS     R0,R0,#+30
   \   0000008E   0xD51A             BPL.N    ??HAL_DMA2D_IRQHandler_2
    774            {
    775              if(__HAL_DMA2D_GET_IT_SOURCE(hdma2d, DMA2D_IT_TC) != RESET)
   \   00000090   0x6820             LDR      R0,[R4, #+0]
   \   00000092   0x6800             LDR      R0,[R0, #+0]
   \   00000094   0x0580             LSLS     R0,R0,#+22
   \   00000096   0xD516             BPL.N    ??HAL_DMA2D_IRQHandler_2
    776              { 
    777                /* Disable the transfer complete interrupt */
    778                __HAL_DMA2D_DISABLE_IT(hdma2d, DMA2D_IT_TC);
   \   00000098   0x6820             LDR      R0,[R4, #+0]
   \   0000009A   0x6800             LDR      R0,[R0, #+0]
   \   0000009C   0xF430 0x7000      BICS     R0,R0,#0x200
   \   000000A0   0x6821             LDR      R1,[R4, #+0]
   \   000000A2   0x6008             STR      R0,[R1, #+0]
    779            
    780                /* Clear the transfer complete flag */  
    781                __HAL_DMA2D_CLEAR_FLAG(hdma2d, DMA2D_FLAG_TC);
   \   000000A4   0x2002             MOVS     R0,#+2
   \   000000A6   0x6821             LDR      R1,[R4, #+0]
   \   000000A8   0x6088             STR      R0,[R1, #+8]
    782          
    783                /* Update error code */
    784                hdma2d->ErrorCode |= HAL_DMA2D_ERROR_NONE;    
   \   000000AA   0x6BE0             LDR      R0,[R4, #+60]
   \   000000AC   0x63E0             STR      R0,[R4, #+60]
    785              
    786                /* Change DMA2D state */
    787                hdma2d->State = HAL_DMA2D_STATE_READY;
   \   000000AE   0x2001             MOVS     R0,#+1
   \   000000B0   0xF884 0x0039      STRB     R0,[R4, #+57]
    788              
    789                /* Process Unlocked */
    790                __HAL_UNLOCK(hdma2d);       
   \   000000B4   0x2000             MOVS     R0,#+0
   \   000000B6   0xF884 0x0038      STRB     R0,[R4, #+56]
    791                
    792                if(hdma2d->XferCpltCallback != NULL)
   \   000000BA   0x6920             LDR      R0,[R4, #+16]
   \   000000BC   0x2800             CMP      R0,#+0
   \   000000BE   0xD002             BEQ.N    ??HAL_DMA2D_IRQHandler_2
    793                {
    794                  /* Transfer complete Callback */
    795                  hdma2d->XferCpltCallback(hdma2d);
   \   000000C0   0x0020             MOVS     R0,R4
   \   000000C2   0x6921             LDR      R1,[R4, #+16]
   \   000000C4   0x4788             BLX      R1
    796                }         
    797              }
    798            }
    799          } 
   \                     ??HAL_DMA2D_IRQHandler_2: (+1)
   \   000000C6   0xBD10             POP      {R4,PC}          ;; return
    800          
    801          /**
    802            * @}
    803            */
    804          
    805          /** @defgroup DMA2D_Group3 Peripheral Control functions
    806           *  @brief    Peripheral Control functions 
    807           *
    808          @verbatim   
    809           ===============================================================================
    810                              ##### Peripheral Control functions #####
    811           ===============================================================================  
    812              [..]  This section provides functions allowing to:
    813                (+) Configure the DMA2D foreground or/and background parameters.
    814                (+) Configure the DMA2D CLUT transfer.
    815                (+) Enable DMA2D CLUT.
    816                (+) Disable DMA2D CLUT.
    817                (+) Configure the line watermark
    818          
    819          @endverbatim
    820            * @{
    821            */
    822          /**
    823            * @brief  Configure the DMA2D Layer according to the specified
    824            *         parameters in the DMA2D_InitTypeDef and create the associated handle.
    825            * @param  hdma2d: pointer to a DMA2D_HandleTypeDef structure that contains
    826            *                 the configuration information for the DMA2D.
    827            * @param  LayerIdx: DMA2D Layer index.
    828            *                   This parameter can be one of the following values:
    829            *                   0(background) / 1(foreground)
    830            * @retval HAL status
    831            */

   \                                 In section .text, align 2, keep-with-next
    832          HAL_StatusTypeDef HAL_DMA2D_ConfigLayer(DMA2D_HandleTypeDef *hdma2d, uint32_t LayerIdx)
    833          { 
   \                     HAL_DMA2D_ConfigLayer: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
   \   00000002   0x0002             MOVS     R2,R0
    834            DMA2D_LayerCfgTypeDef *pLayerCfg = &hdma2d->LayerCfg[LayerIdx];
   \   00000004   0xEB12 0x1001      ADDS     R0,R2,R1, LSL #+4
   \   00000008   0xF110 0x0318      ADDS     R3,R0,#+24
    835            
    836            uint32_t tmp = 0;
   \   0000000C   0x2400             MOVS     R4,#+0
    837            
    838            /* Process locked */
    839            __HAL_LOCK(hdma2d);
   \   0000000E   0xF892 0x0038      LDRB     R0,[R2, #+56]
   \   00000012   0x2801             CMP      R0,#+1
   \   00000014   0xD101             BNE.N    ??HAL_DMA2D_ConfigLayer_0
   \   00000016   0x2002             MOVS     R0,#+2
   \   00000018   0xE07D             B.N      ??HAL_DMA2D_ConfigLayer_1
   \                     ??HAL_DMA2D_ConfigLayer_0: (+1)
   \   0000001A   0x2001             MOVS     R0,#+1
   \   0000001C   0xF882 0x0038      STRB     R0,[R2, #+56]
    840            
    841            /* Change DMA2D peripheral state */
    842            hdma2d->State = HAL_DMA2D_STATE_BUSY; 
   \   00000020   0x2002             MOVS     R0,#+2
   \   00000022   0xF882 0x0039      STRB     R0,[R2, #+57]
    843            
    844            /* Check the parameters */
    845            assert_param(IS_DMA2D_LAYER(LayerIdx));  
    846            assert_param(IS_DMA2D_OFFSET(pLayerCfg->InputOffset));  
    847            if(hdma2d->Init.Mode != DMA2D_R2M)
   \   00000026   0x6850             LDR      R0,[R2, #+4]
   \   00000028   0xF5B0 0x3F40      CMP      R0,#+196608
   \   0000002C   0xD001             BEQ.N    ??HAL_DMA2D_ConfigLayer_2
    848            {  
    849              assert_param(IS_DMA2D_INPUT_COLOR_MODE(pLayerCfg->InputColorMode));
    850              if(hdma2d->Init.Mode != DMA2D_M2M)
   \   0000002E   0x6850             LDR      R0,[R2, #+4]
   \   00000030   0x2800             CMP      R0,#+0
    851              {
    852                assert_param(IS_DMA2D_ALPHA_MODE(pLayerCfg->AlphaMode));
    853              }
    854            }
    855            
    856            /* Configure the background DMA2D layer */
    857            if(LayerIdx == 0)
   \                     ??HAL_DMA2D_ConfigLayer_2: (+1)
   \   00000032   0x2900             CMP      R1,#+0
   \   00000034   0xD134             BNE.N    ??HAL_DMA2D_ConfigLayer_3
    858            {
    859              /* DMA2D BGPFCR register configuration -----------------------------------*/
    860              /* Get the BGPFCCR register value */
    861              tmp = hdma2d->Instance->BGPFCCR;
   \   00000036   0x6810             LDR      R0,[R2, #+0]
   \   00000038   0x6A40             LDR      R0,[R0, #+36]
   \   0000003A   0x0004             MOVS     R4,R0
    862              
    863              /* Clear Input color mode, alpha value and alpha mode bits */
    864              tmp &= (uint32_t)~(DMA2D_BGPFCCR_CM | DMA2D_BGPFCCR_AM | DMA2D_BGPFCCR_ALPHA); 
   \   0000003C   0x....             LDR.N    R0,??DataTable2  ;; 0xfcfff0
   \   0000003E   0x4004             ANDS     R4,R0,R4
    865              
    866              if ((pLayerCfg->InputColorMode == CM_A4) || (pLayerCfg->InputColorMode == CM_A8))
   \   00000040   0x6858             LDR      R0,[R3, #+4]
   \   00000042   0x280A             CMP      R0,#+10
   \   00000044   0xD002             BEQ.N    ??HAL_DMA2D_ConfigLayer_4
   \   00000046   0x6858             LDR      R0,[R3, #+4]
   \   00000048   0x2809             CMP      R0,#+9
   \   0000004A   0xD109             BNE.N    ??HAL_DMA2D_ConfigLayer_5
    867              {
    868                /* Prepare the value to be wrote to the BGPFCCR register */
    869                tmp |= (pLayerCfg->InputColorMode | (pLayerCfg->AlphaMode << 16) | ((pLayerCfg->InputAlpha) & 0xFF000000));
   \                     ??HAL_DMA2D_ConfigLayer_4: (+1)
   \   0000004C   0x6858             LDR      R0,[R3, #+4]
   \   0000004E   0x689D             LDR      R5,[R3, #+8]
   \   00000050   0xEA50 0x4005      ORRS     R0,R0,R5, LSL #+16
   \   00000054   0x68DD             LDR      R5,[R3, #+12]
   \   00000056   0xF015 0x457F      ANDS     R5,R5,#0xFF000000
   \   0000005A   0x4328             ORRS     R0,R5,R0
   \   0000005C   0x4304             ORRS     R4,R0,R4
   \   0000005E   0xE007             B.N      ??HAL_DMA2D_ConfigLayer_6
    870              }
    871              else
    872              {
    873                /* Prepare the value to be wrote to the BGPFCCR register */
    874                tmp |= (pLayerCfg->InputColorMode | (pLayerCfg->AlphaMode << 16) | (pLayerCfg->InputAlpha << 24));
   \                     ??HAL_DMA2D_ConfigLayer_5: (+1)
   \   00000060   0x6858             LDR      R0,[R3, #+4]
   \   00000062   0x689D             LDR      R5,[R3, #+8]
   \   00000064   0xEA50 0x4005      ORRS     R0,R0,R5, LSL #+16
   \   00000068   0x68DD             LDR      R5,[R3, #+12]
   \   0000006A   0xEA50 0x6005      ORRS     R0,R0,R5, LSL #+24
   \   0000006E   0x4304             ORRS     R4,R0,R4
    875              }
    876              
    877              /* Write to DMA2D BGPFCCR register */
    878              hdma2d->Instance->BGPFCCR = tmp; 
   \                     ??HAL_DMA2D_ConfigLayer_6: (+1)
   \   00000070   0x6810             LDR      R0,[R2, #+0]
   \   00000072   0x6244             STR      R4,[R0, #+36]
    879              
    880              /* DMA2D BGOR register configuration -------------------------------------*/  
    881              /* Get the BGOR register value */
    882              tmp = hdma2d->Instance->BGOR;
   \   00000074   0x6810             LDR      R0,[R2, #+0]
   \   00000076   0x6980             LDR      R0,[R0, #+24]
   \   00000078   0x0004             MOVS     R4,R0
    883              
    884              /* Clear colors bits */
    885              tmp &= (uint32_t)~DMA2D_BGOR_LO; 
   \   0000007A   0x0BA4             LSRS     R4,R4,#+14
   \   0000007C   0x03A4             LSLS     R4,R4,#+14
    886              
    887              /* Prepare the value to be wrote to the BGOR register */
    888              tmp |= pLayerCfg->InputOffset;
   \   0000007E   0x6818             LDR      R0,[R3, #+0]
   \   00000080   0x4304             ORRS     R4,R0,R4
    889              
    890              /* Write to DMA2D BGOR register */
    891              hdma2d->Instance->BGOR = tmp;
   \   00000082   0x6810             LDR      R0,[R2, #+0]
   \   00000084   0x6184             STR      R4,[R0, #+24]
    892              
    893              if ((pLayerCfg->InputColorMode == CM_A4) || (pLayerCfg->InputColorMode == CM_A8))
   \   00000086   0x6858             LDR      R0,[R3, #+4]
   \   00000088   0x280A             CMP      R0,#+10
   \   0000008A   0xD002             BEQ.N    ??HAL_DMA2D_ConfigLayer_7
   \   0000008C   0x6858             LDR      R0,[R3, #+4]
   \   0000008E   0x2809             CMP      R0,#+9
   \   00000090   0xD13A             BNE.N    ??HAL_DMA2D_ConfigLayer_8
    894              {
    895                /* Prepare the value to be wrote to the BGCOLR register */
    896                tmp = ((pLayerCfg->InputAlpha) & 0x00FFFFFF);
   \                     ??HAL_DMA2D_ConfigLayer_7: (+1)
   \   00000092   0x68D8             LDR      R0,[R3, #+12]
   \   00000094   0x0200             LSLS     R0,R0,#+8        ;; ZeroExtS R0,R0,#+8,#+8
   \   00000096   0x0A00             LSRS     R0,R0,#+8
   \   00000098   0x0004             MOVS     R4,R0
    897              
    898                /* Write to DMA2D BGCOLR register */
    899                hdma2d->Instance->BGCOLR = tmp;
   \   0000009A   0x6810             LDR      R0,[R2, #+0]
   \   0000009C   0x6284             STR      R4,[R0, #+40]
   \   0000009E   0xE033             B.N      ??HAL_DMA2D_ConfigLayer_8
    900              }    
    901            }
    902            /* Configure the foreground DMA2D layer */
    903            else
    904            {
    905              /* DMA2D FGPFCR register configuration -----------------------------------*/
    906              /* Get the FGPFCCR register value */
    907              tmp = hdma2d->Instance->FGPFCCR;
   \                     ??HAL_DMA2D_ConfigLayer_3: (+1)
   \   000000A0   0x6810             LDR      R0,[R2, #+0]
   \   000000A2   0x69C0             LDR      R0,[R0, #+28]
   \   000000A4   0x0004             MOVS     R4,R0
    908              
    909              /* Clear Input color mode, alpha value and alpha mode bits */
    910              tmp &= (uint32_t)~(DMA2D_FGPFCCR_CM | DMA2D_FGPFCCR_AM | DMA2D_FGPFCCR_ALPHA); 
   \   000000A6   0x....             LDR.N    R0,??DataTable2  ;; 0xfcfff0
   \   000000A8   0x4004             ANDS     R4,R0,R4
    911              
    912              if ((pLayerCfg->InputColorMode == CM_A4) || (pLayerCfg->InputColorMode == CM_A8))
   \   000000AA   0x6858             LDR      R0,[R3, #+4]
   \   000000AC   0x280A             CMP      R0,#+10
   \   000000AE   0xD002             BEQ.N    ??HAL_DMA2D_ConfigLayer_9
   \   000000B0   0x6858             LDR      R0,[R3, #+4]
   \   000000B2   0x2809             CMP      R0,#+9
   \   000000B4   0xD109             BNE.N    ??HAL_DMA2D_ConfigLayer_10
    913              {
    914                /* Prepare the value to be wrote to the FGPFCCR register */
    915                tmp |= (pLayerCfg->InputColorMode | (pLayerCfg->AlphaMode << 16) | ((pLayerCfg->InputAlpha) & 0xFF000000));
   \                     ??HAL_DMA2D_ConfigLayer_9: (+1)
   \   000000B6   0x6858             LDR      R0,[R3, #+4]
   \   000000B8   0x689D             LDR      R5,[R3, #+8]
   \   000000BA   0xEA50 0x4005      ORRS     R0,R0,R5, LSL #+16
   \   000000BE   0x68DD             LDR      R5,[R3, #+12]
   \   000000C0   0xF015 0x457F      ANDS     R5,R5,#0xFF000000
   \   000000C4   0x4328             ORRS     R0,R5,R0
   \   000000C6   0x4304             ORRS     R4,R0,R4
   \   000000C8   0xE007             B.N      ??HAL_DMA2D_ConfigLayer_11
    916              }
    917              else
    918              {
    919                /* Prepare the value to be wrote to the FGPFCCR register */
    920                tmp |= (pLayerCfg->InputColorMode | (pLayerCfg->AlphaMode << 16) | (pLayerCfg->InputAlpha << 24));
   \                     ??HAL_DMA2D_ConfigLayer_10: (+1)
   \   000000CA   0x6858             LDR      R0,[R3, #+4]
   \   000000CC   0x689D             LDR      R5,[R3, #+8]
   \   000000CE   0xEA50 0x4005      ORRS     R0,R0,R5, LSL #+16
   \   000000D2   0x68DD             LDR      R5,[R3, #+12]
   \   000000D4   0xEA50 0x6005      ORRS     R0,R0,R5, LSL #+24
   \   000000D8   0x4304             ORRS     R4,R0,R4
    921              }
    922              
    923              /* Write to DMA2D FGPFCCR register */
    924              hdma2d->Instance->FGPFCCR = tmp; 
   \                     ??HAL_DMA2D_ConfigLayer_11: (+1)
   \   000000DA   0x6810             LDR      R0,[R2, #+0]
   \   000000DC   0x61C4             STR      R4,[R0, #+28]
    925              
    926              /* DMA2D FGOR register configuration -------------------------------------*/  
    927              /* Get the FGOR register value */
    928              tmp = hdma2d->Instance->FGOR;
   \   000000DE   0x6810             LDR      R0,[R2, #+0]
   \   000000E0   0x6900             LDR      R0,[R0, #+16]
   \   000000E2   0x0004             MOVS     R4,R0
    929              
    930              /* Clear colors bits */
    931              tmp &= (uint32_t)~DMA2D_FGOR_LO; 
   \   000000E4   0x0BA4             LSRS     R4,R4,#+14
   \   000000E6   0x03A4             LSLS     R4,R4,#+14
    932              
    933              /* Prepare the value to be wrote to the FGOR register */
    934              tmp |= pLayerCfg->InputOffset;
   \   000000E8   0x6818             LDR      R0,[R3, #+0]
   \   000000EA   0x4304             ORRS     R4,R0,R4
    935              
    936              /* Write to DMA2D FGOR register */
    937              hdma2d->Instance->FGOR = tmp;
   \   000000EC   0x6810             LDR      R0,[R2, #+0]
   \   000000EE   0x6104             STR      R4,[R0, #+16]
    938             
    939              if ((pLayerCfg->InputColorMode == CM_A4) || (pLayerCfg->InputColorMode == CM_A8))
   \   000000F0   0x6858             LDR      R0,[R3, #+4]
   \   000000F2   0x280A             CMP      R0,#+10
   \   000000F4   0xD002             BEQ.N    ??HAL_DMA2D_ConfigLayer_12
   \   000000F6   0x6858             LDR      R0,[R3, #+4]
   \   000000F8   0x2809             CMP      R0,#+9
   \   000000FA   0xD105             BNE.N    ??HAL_DMA2D_ConfigLayer_8
    940              {
    941                /* Prepare the value to be wrote to the FGCOLR register */
    942                tmp = ((pLayerCfg->InputAlpha) & 0x00FFFFFF);
   \                     ??HAL_DMA2D_ConfigLayer_12: (+1)
   \   000000FC   0x68D8             LDR      R0,[R3, #+12]
   \   000000FE   0x0200             LSLS     R0,R0,#+8        ;; ZeroExtS R0,R0,#+8,#+8
   \   00000100   0x0A00             LSRS     R0,R0,#+8
   \   00000102   0x0004             MOVS     R4,R0
    943              
    944                /* Write to DMA2D FGCOLR register */
    945                hdma2d->Instance->FGCOLR = tmp;
   \   00000104   0x6810             LDR      R0,[R2, #+0]
   \   00000106   0x6204             STR      R4,[R0, #+32]
    946              }   
    947            }    
    948            /* Initialize the DMA2D state*/
    949            hdma2d->State  = HAL_DMA2D_STATE_READY;
   \                     ??HAL_DMA2D_ConfigLayer_8: (+1)
   \   00000108   0x2001             MOVS     R0,#+1
   \   0000010A   0xF882 0x0039      STRB     R0,[R2, #+57]
    950            
    951            /* Process unlocked */
    952            __HAL_UNLOCK(hdma2d);  
   \   0000010E   0x2000             MOVS     R0,#+0
   \   00000110   0xF882 0x0038      STRB     R0,[R2, #+56]
    953            
    954            return HAL_OK;
   \   00000114   0x2000             MOVS     R0,#+0
   \                     ??HAL_DMA2D_ConfigLayer_1: (+1)
   \   00000116   0xBC30             POP      {R4,R5}
   \   00000118   0x4770             BX       LR               ;; return
    955          }
    956          
    957          /**
    958            * @brief  Configure the DMA2D CLUT Transfer.
    959            * @param  hdma2d:   pointer to a DMA2D_HandleTypeDef structure that contains
    960            *                   the configuration information for the DMA2D.
    961            * @param  CLUTCfg:  pointer to a DMA2D_CLUTCfgTypeDef structure that contains
    962            *                   the configuration information for the color look up table.
    963            * @param  LayerIdx: DMA2D Layer index.
    964            *                   This parameter can be one of the following values:
    965            *                   0(background) / 1(foreground)
    966            * @retval HAL status
    967            */

   \                                 In section .text, align 2, keep-with-next
    968          HAL_StatusTypeDef HAL_DMA2D_ConfigCLUT(DMA2D_HandleTypeDef *hdma2d, DMA2D_CLUTCfgTypeDef CLUTCfg, uint32_t LayerIdx)
    969          {
   \                     HAL_DMA2D_ConfigCLUT: (+1)
   \   00000000   0xB4F0             PUSH     {R4-R7}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x9D04             LDR      R5,[SP, #+16]
    970            uint32_t tmp = 0, tmp1 = 0;
   \   00000006   0x2700             MOVS     R7,#+0
   \   00000008   0x2600             MOVS     R6,#+0
    971          
    972            /* Check the parameters */
    973            assert_param(IS_DMA2D_LAYER(LayerIdx));   
    974            assert_param(IS_DMA2D_CLUT_CM(CLUTCfg.CLUTColorMode));
    975            assert_param(IS_DMA2D_CLUT_SIZE(CLUTCfg.Size));
    976            
    977            /* Configure the CLUT of the background DMA2D layer */
    978            if(LayerIdx == 0)
   \   0000000A   0x2D00             CMP      R5,#+0
   \   0000000C   0xD116             BNE.N    ??HAL_DMA2D_ConfigCLUT_0
    979            {
    980              /* Get the BGCMAR register value */
    981              tmp = hdma2d->Instance->BGCMAR;
   \   0000000E   0x6820             LDR      R0,[R4, #+0]
   \   00000010   0x6B00             LDR      R0,[R0, #+48]
   \   00000012   0x0007             MOVS     R7,R0
    982          
    983              /* Clear CLUT address bits */
    984              tmp &= (uint32_t)~DMA2D_BGCMAR_MA; 
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0x0007             MOVS     R7,R0
    985            
    986              /* Prepare the value to be wrote to the BGCMAR register */
    987              tmp |= (uint32_t)CLUTCfg.pCLUT;
   \   00000018   0x0008             MOVS     R0,R1
   \   0000001A   0x4307             ORRS     R7,R0,R7
    988            
    989              /* Write to DMA2D BGCMAR register */
    990              hdma2d->Instance->BGCMAR = tmp;
   \   0000001C   0x6820             LDR      R0,[R4, #+0]
   \   0000001E   0x6307             STR      R7,[R0, #+48]
    991              
    992              /* Get the BGPFCCR register value */
    993              tmp = hdma2d->Instance->BGPFCCR;
   \   00000020   0x6820             LDR      R0,[R4, #+0]
   \   00000022   0x6A40             LDR      R0,[R0, #+36]
   \   00000024   0x0007             MOVS     R7,R0
    994          
    995              /* Clear CLUT size and CLUT address bits */
    996              tmp &= (uint32_t)~(DMA2D_BGPFCCR_CS | DMA2D_BGPFCCR_CCM); 
   \   00000026   0x....             LDR.N    R0,??DataTable2_1  ;; 0xffff00ef
   \   00000028   0x4007             ANDS     R7,R0,R7
    997          
    998              /* Get the CLUT size */
    999              tmp1 = CLUTCfg.Size << 16;
   \   0000002A   0x0018             MOVS     R0,R3
   \   0000002C   0x0400             LSLS     R0,R0,#+16
   \   0000002E   0x0006             MOVS     R6,R0
   1000              
   1001              /* Prepare the value to be wrote to the BGPFCCR register */
   1002              tmp |= (CLUTCfg.CLUTColorMode | tmp1);
   \   00000030   0x0010             MOVS     R0,R2
   \   00000032   0x4330             ORRS     R0,R6,R0
   \   00000034   0x4307             ORRS     R7,R0,R7
   1003            
   1004              /* Write to DMA2D BGPFCCR register */
   1005              hdma2d->Instance->BGPFCCR = tmp;       
   \   00000036   0x6820             LDR      R0,[R4, #+0]
   \   00000038   0x6247             STR      R7,[R0, #+36]
   \   0000003A   0xE015             B.N      ??HAL_DMA2D_ConfigCLUT_1
   1006            }
   1007            /* Configure the CLUT of the foreground DMA2D layer */
   1008            else
   1009            {
   1010              /* Get the FGCMAR register value */
   1011              tmp = hdma2d->Instance->FGCMAR;
   \                     ??HAL_DMA2D_ConfigCLUT_0: (+1)
   \   0000003C   0x6820             LDR      R0,[R4, #+0]
   \   0000003E   0x6AC0             LDR      R0,[R0, #+44]
   \   00000040   0x0007             MOVS     R7,R0
   1012          
   1013              /* Clear CLUT address bits */
   1014              tmp &= (uint32_t)~DMA2D_FGCMAR_MA; 
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0x0007             MOVS     R7,R0
   1015            
   1016              /* Prepare the value to be wrote to the FGCMAR register */
   1017              tmp |= (uint32_t)CLUTCfg.pCLUT;
   \   00000046   0x0008             MOVS     R0,R1
   \   00000048   0x4307             ORRS     R7,R0,R7
   1018            
   1019              /* Write to DMA2D FGCMAR register */
   1020              hdma2d->Instance->FGCMAR = tmp;
   \   0000004A   0x6820             LDR      R0,[R4, #+0]
   \   0000004C   0x62C7             STR      R7,[R0, #+44]
   1021              
   1022              /* Get the FGPFCCR register value */
   1023              tmp = hdma2d->Instance->FGPFCCR;
   \   0000004E   0x6820             LDR      R0,[R4, #+0]
   \   00000050   0x69C0             LDR      R0,[R0, #+28]
   \   00000052   0x0007             MOVS     R7,R0
   1024          
   1025              /* Clear CLUT size and CLUT address bits */
   1026              tmp &= (uint32_t)~(DMA2D_FGPFCCR_CS | DMA2D_FGPFCCR_CCM); 
   \   00000054   0x....             LDR.N    R0,??DataTable2_1  ;; 0xffff00ef
   \   00000056   0x4007             ANDS     R7,R0,R7
   1027          
   1028              /* Get the CLUT size */
   1029              tmp1 = CLUTCfg.Size << 8;
   \   00000058   0x0018             MOVS     R0,R3
   \   0000005A   0x0200             LSLS     R0,R0,#+8
   \   0000005C   0x0006             MOVS     R6,R0
   1030              
   1031              /* Prepare the value to be wrote to the FGPFCCR register */
   1032              tmp |= (CLUTCfg.CLUTColorMode | tmp1);
   \   0000005E   0x0010             MOVS     R0,R2
   \   00000060   0x4330             ORRS     R0,R6,R0
   \   00000062   0x4307             ORRS     R7,R0,R7
   1033            
   1034              /* Write to DMA2D FGPFCCR register */
   1035              hdma2d->Instance->FGPFCCR = tmp;    
   \   00000064   0x6820             LDR      R0,[R4, #+0]
   \   00000066   0x61C7             STR      R7,[R0, #+28]
   1036            }
   1037            
   1038            return HAL_OK;
   \                     ??HAL_DMA2D_ConfigCLUT_1: (+1)
   \   00000068   0x2000             MOVS     R0,#+0
   \   0000006A   0xBCF0             POP      {R4-R7}
   \   0000006C   0x4770             BX       LR               ;; return
   1039          }
   1040          
   1041          /**
   1042            * @brief  Enable the DMA2D CLUT Transfer.
   1043            * @param  hdma2d:   pointer to a DMA2D_HandleTypeDef structure that contains
   1044            *                   the configuration information for the DMA2D.
   1045            * @param  LayerIdx: DMA2D Layer index.
   1046            *                   This parameter can be one of the following values:
   1047            *                   0(background) / 1(foreground)
   1048            * @retval HAL status
   1049            */

   \                                 In section .text, align 2, keep-with-next
   1050          HAL_StatusTypeDef HAL_DMA2D_EnableCLUT(DMA2D_HandleTypeDef *hdma2d, uint32_t LayerIdx)
   1051          {  
   \                     HAL_DMA2D_EnableCLUT: (+1)
   \   00000000   0x0002             MOVS     R2,R0
   1052            /* Check the parameters */
   1053            assert_param(IS_DMA2D_LAYER(LayerIdx));
   1054            
   1055            if(LayerIdx == 0)
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xD106             BNE.N    ??HAL_DMA2D_EnableCLUT_0
   1056            {
   1057              /* Enable the CLUT loading for the background */
   1058              hdma2d->Instance->BGPFCCR |= DMA2D_BGPFCCR_START;
   \   00000006   0x6810             LDR      R0,[R2, #+0]
   \   00000008   0x6A40             LDR      R0,[R0, #+36]
   \   0000000A   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   0000000E   0x6813             LDR      R3,[R2, #+0]
   \   00000010   0x6258             STR      R0,[R3, #+36]
   \   00000012   0xE005             B.N      ??HAL_DMA2D_EnableCLUT_1
   1059            }
   1060            else
   1061            {
   1062              /* Enable the CLUT loading for the foreground */
   1063              hdma2d->Instance->FGPFCCR |= DMA2D_FGPFCCR_START;
   \                     ??HAL_DMA2D_EnableCLUT_0: (+1)
   \   00000014   0x6810             LDR      R0,[R2, #+0]
   \   00000016   0x69C0             LDR      R0,[R0, #+28]
   \   00000018   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   0000001C   0x6813             LDR      R3,[R2, #+0]
   \   0000001E   0x61D8             STR      R0,[R3, #+28]
   1064            }
   1065            
   1066            return HAL_OK;
   \                     ??HAL_DMA2D_EnableCLUT_1: (+1)
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0x4770             BX       LR               ;; return
   1067          }
   1068          
   1069          /**
   1070            * @brief  Disable the DMA2D CLUT Transfer.
   1071            * @param  hdma2d:   pointer to a DMA2D_HandleTypeDef structure that contains
   1072            *                   the configuration information for the DMA2D.
   1073            * @param  LayerIdx: DMA2D Layer index.
   1074            *                   This parameter can be one of the following values:
   1075            *                   0(background) / 1(foreground)
   1076            * @retval HAL status
   1077            */

   \                                 In section .text, align 2, keep-with-next
   1078          HAL_StatusTypeDef HAL_DMA2D_DisableCLUT(DMA2D_HandleTypeDef *hdma2d, uint32_t LayerIdx)
   1079          {
   \                     HAL_DMA2D_DisableCLUT: (+1)
   \   00000000   0x0002             MOVS     R2,R0
   1080            /* Check the parameters */
   1081            assert_param(IS_DMA2D_LAYER(LayerIdx));
   1082            
   1083            if(LayerIdx == 0)
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xD106             BNE.N    ??HAL_DMA2D_DisableCLUT_0
   1084            {
   1085              /* Disable the CLUT loading for the background */
   1086              hdma2d->Instance->BGPFCCR &= ~DMA2D_BGPFCCR_START;
   \   00000006   0x6810             LDR      R0,[R2, #+0]
   \   00000008   0x6A40             LDR      R0,[R0, #+36]
   \   0000000A   0xF030 0x0020      BICS     R0,R0,#0x20
   \   0000000E   0x6813             LDR      R3,[R2, #+0]
   \   00000010   0x6258             STR      R0,[R3, #+36]
   \   00000012   0xE005             B.N      ??HAL_DMA2D_DisableCLUT_1
   1087            }
   1088            else
   1089            {
   1090              /* Disable the CLUT loading for the foreground */
   1091              hdma2d->Instance->FGPFCCR &= ~DMA2D_FGPFCCR_START;
   \                     ??HAL_DMA2D_DisableCLUT_0: (+1)
   \   00000014   0x6810             LDR      R0,[R2, #+0]
   \   00000016   0x69C0             LDR      R0,[R0, #+28]
   \   00000018   0xF030 0x0020      BICS     R0,R0,#0x20
   \   0000001C   0x6813             LDR      R3,[R2, #+0]
   \   0000001E   0x61D8             STR      R0,[R3, #+28]
   1092            } 
   1093            
   1094            return HAL_OK;
   \                     ??HAL_DMA2D_DisableCLUT_1: (+1)
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0x4770             BX       LR               ;; return
   1095          }
   1096          
   1097          /**
   1098            * @brief  Define the configuration of the line watermark .
   1099            * @param  hdma2d: pointer to a DMA2D_HandleTypeDef structure that contains
   1100            *                 the configuration information for the DMA2D.
   1101            * @param  Line:   Line Watermark configuration.
   1102            * @retval HAL status
   1103            */
   1104          

   \                                 In section .text, align 2, keep-with-next
   1105          HAL_StatusTypeDef HAL_DMA2D_ProgramLineEvent(DMA2D_HandleTypeDef *hdma2d, uint32_t Line)
   1106          {
   \                     HAL_DMA2D_ProgramLineEvent: (+1)
   \   00000000   0x0002             MOVS     R2,R0
   1107            /* Process locked */
   1108            __HAL_LOCK(hdma2d);
   \   00000002   0xF892 0x0038      LDRB     R0,[R2, #+56]
   \   00000006   0x2801             CMP      R0,#+1
   \   00000008   0xD101             BNE.N    ??HAL_DMA2D_ProgramLineEvent_0
   \   0000000A   0x2002             MOVS     R0,#+2
   \   0000000C   0xE00E             B.N      ??HAL_DMA2D_ProgramLineEvent_1
   \                     ??HAL_DMA2D_ProgramLineEvent_0: (+1)
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0xF882 0x0038      STRB     R0,[R2, #+56]
   1109            
   1110            /* Change DMA2D peripheral state */
   1111            hdma2d->State = HAL_DMA2D_STATE_BUSY;
   \   00000014   0x2002             MOVS     R0,#+2
   \   00000016   0xF882 0x0039      STRB     R0,[R2, #+57]
   1112            
   1113            /* Check the parameters */
   1114            assert_param(IS_DMA2D_LineWatermark(Line));
   1115          
   1116            /* Sets the Line watermark configuration */
   1117            DMA2D->LWR = (uint32_t)Line;
   \   0000001A   0x....             LDR.N    R0,??DataTable2_2  ;; 0x4002b048
   \   0000001C   0x6001             STR      R1,[R0, #+0]
   1118            
   1119            /* Initialize the DMA2D state*/
   1120            hdma2d->State = HAL_DMA2D_STATE_READY;
   \   0000001E   0x2001             MOVS     R0,#+1
   \   00000020   0xF882 0x0039      STRB     R0,[R2, #+57]
   1121            
   1122            /* Process unlocked */
   1123            __HAL_UNLOCK(hdma2d);  
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0xF882 0x0038      STRB     R0,[R2, #+56]
   1124            
   1125            return HAL_OK;  
   \   0000002A   0x2000             MOVS     R0,#+0
   \                     ??HAL_DMA2D_ProgramLineEvent_1: (+1)
   \   0000002C   0x4770             BX       LR               ;; return
   1126          }
   1127          
   1128          /**
   1129            * @}
   1130            */
   1131          
   1132          /** @defgroup DMA2D_Group4 Peripheral State functions
   1133           *  @brief    Peripheral State functions 
   1134           *
   1135          @verbatim   
   1136           ===============================================================================
   1137                            ##### Peripheral State and Errors functions #####
   1138           ===============================================================================  
   1139              [..]
   1140              This subsection provides functions allowing to :
   1141                (+) Check the DMA2D state
   1142                (+) Get error code  
   1143          
   1144          @endverbatim
   1145            * @{
   1146            */ 
   1147          
   1148          /**
   1149            * @brief  Return the DMA2D state
   1150            * @param  hdma2d: pointer to a DMA2D_HandleTypeDef structure that contains
   1151            *                 the configuration information for the DMA2D.  
   1152            * @retval HAL state
   1153            */

   \                                 In section .text, align 2, keep-with-next
   1154          HAL_DMA2D_StateTypeDef HAL_DMA2D_GetState(DMA2D_HandleTypeDef *hdma2d)
   1155          {  
   1156            return hdma2d->State;
   \                     HAL_DMA2D_GetState: (+1)
   \   00000000   0xF890 0x0039      LDRB     R0,[R0, #+57]
   \   00000004   0x4770             BX       LR               ;; return
   1157          }
   1158          
   1159          /**
   1160            * @brief  Return the DMA2D error code
   1161            * @param  hdma2d : pointer to a DMA2D_HandleTypeDef structure that contains
   1162            *               the configuration information for DMA2D.
   1163            * @retval DMA2D Error Code
   1164            */

   \                                 In section .text, align 2, keep-with-next
   1165          uint32_t HAL_DMA2D_GetError(DMA2D_HandleTypeDef *hdma2d)
   1166          {
   1167            return hdma2d->ErrorCode;
   \                     HAL_DMA2D_GetError: (+1)
   \   00000000   0x6BC0             LDR      R0,[R0, #+60]
   \   00000002   0x4770             BX       LR               ;; return
   1168          }
   1169          
   1170          /**
   1171            * @}
   1172            */
   1173          
   1174          
   1175          /**
   1176            * @brief  Set the DMA2D Transfer parameter.
   1177            * @param  hdma2d:     pointer to a DMA2D_HandleTypeDef structure that contains
   1178            *                     the configuration information for the specified DMA2D.  
   1179            * @param  pdata:      The source memory Buffer address
   1180            * @param  DstAddress: The destination memory Buffer address
   1181            * @param  Width:      The width of data to be transferred from source to destination.
   1182            * @param  Height:     The height of data to be transferred from source to destination.
   1183            * @retval HAL status
   1184            */

   \                                 In section .text, align 2, keep-with-next
   1185          static void DMA2D_SetConfig(DMA2D_HandleTypeDef *hdma2d, uint32_t pdata, uint32_t DstAddress, uint32_t Width, uint32_t Height)
   1186          {  
   \                     DMA2D_SetConfig: (+1)
   \   00000000   0xE92D 0x43F0      PUSH     {R4-R9,LR}
   \   00000004   0x9C07             LDR      R4,[SP, #+28]
   1187            uint32_t tmp = 0;
   \   00000006   0x2500             MOVS     R5,#+0
   1188            uint32_t tmp1 = 0;
   \   00000008   0x2600             MOVS     R6,#+0
   1189            uint32_t tmp2 = 0;
   \   0000000A   0x2700             MOVS     R7,#+0
   1190            uint32_t tmp3 = 0;
   \   0000000C   0xF05F 0x0C00      MOVS     R12,#+0
   1191            uint32_t tmp4 = 0;
   \   00000010   0xF05F 0x0E00      MOVS     LR,#+0
   1192            
   1193            tmp = Width << 16;
   \   00000014   0xEA5F 0x4803      LSLS     R8,R3,#+16
   \   00000018   0x4645             MOV      R5,R8
   1194            
   1195            /* Configure DMA2D data size */
   1196            hdma2d->Instance->NLR = (Height | tmp);
   \   0000001A   0xEA55 0x0804      ORRS     R8,R5,R4
   \   0000001E   0xF8D0 0x9000      LDR      R9,[R0, #+0]
   \   00000022   0xF8C9 0x8044      STR      R8,[R9, #+68]
   1197            
   1198            /* Configure DMA2D destination address */
   1199            hdma2d->Instance->OMAR = DstAddress;
   \   00000026   0xF8D0 0x8000      LDR      R8,[R0, #+0]
   \   0000002A   0xF8C8 0x203C      STR      R2,[R8, #+60]
   1200           
   1201            /* Register to memory DMA2D mode selected */
   1202            if (hdma2d->Init.Mode == DMA2D_R2M)
   \   0000002E   0xF8D0 0x8004      LDR      R8,[R0, #+4]
   \   00000032   0xF5B8 0x3F40      CMP      R8,#+196608
   \   00000036   0xD15E             BNE.N    ??DMA2D_SetConfig_0
   1203            {    
   1204              tmp1 = pdata & DMA2D_OCOLR_ALPHA_1;
   \   00000038   0xF011 0x487F      ANDS     R8,R1,#0xFF000000
   \   0000003C   0x4646             MOV      R6,R8
   1205              tmp2 = pdata & DMA2D_OCOLR_RED_1;
   \   0000003E   0xF411 0x087F      ANDS     R8,R1,#0xFF0000
   \   00000042   0x4647             MOV      R7,R8
   1206              tmp3 = pdata & DMA2D_OCOLR_GREEN_1;
   \   00000044   0xF411 0x487F      ANDS     R8,R1,#0xFF00
   \   00000048   0x46C4             MOV      R12,R8
   1207              tmp4 = pdata & DMA2D_OCOLR_BLUE_1;
   \   0000004A   0xFA5F 0xF881      UXTB     R8,R1            ;; ZeroExt  R8,R1,#+24,#+24
   \   0000004E   0x46C6             MOV      LR,R8
   1208              
   1209              /* Prepare the value to be wrote to the OCOLR register according to the color mode */
   1210              if (hdma2d->Init.ColorMode == DMA2D_ARGB8888)
   \   00000050   0xF8D0 0x8008      LDR      R8,[R0, #+8]
   \   00000054   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000058   0xD107             BNE.N    ??DMA2D_SetConfig_1
   1211              {
   1212                tmp = (tmp3 | tmp2 | tmp1| tmp4);
   \   0000005A   0xEA57 0x080C      ORRS     R8,R7,R12
   \   0000005E   0xEA56 0x0808      ORRS     R8,R6,R8
   \   00000062   0xEA5E 0x0808      ORRS     R8,LR,R8
   \   00000066   0x4645             MOV      R5,R8
   \   00000068   0xE040             B.N      ??DMA2D_SetConfig_2
   1213              }
   1214              else if (hdma2d->Init.ColorMode == DMA2D_RGB888)
   \                     ??DMA2D_SetConfig_1: (+1)
   \   0000006A   0xF8D0 0x8008      LDR      R8,[R0, #+8]
   \   0000006E   0xF1B8 0x0F01      CMP      R8,#+1
   \   00000072   0xD105             BNE.N    ??DMA2D_SetConfig_3
   1215              {
   1216                tmp = (tmp3 | tmp2 | tmp4);  
   \   00000074   0xEA57 0x080C      ORRS     R8,R7,R12
   \   00000078   0xEA5E 0x0808      ORRS     R8,LR,R8
   \   0000007C   0x4645             MOV      R5,R8
   \   0000007E   0xE035             B.N      ??DMA2D_SetConfig_2
   1217              }
   1218              else if (hdma2d->Init.ColorMode == DMA2D_RGB565)
   \                     ??DMA2D_SetConfig_3: (+1)
   \   00000080   0xF8D0 0x8008      LDR      R8,[R0, #+8]
   \   00000084   0xF1B8 0x0F02      CMP      R8,#+2
   \   00000088   0xD10C             BNE.N    ??DMA2D_SetConfig_4
   1219              {
   1220                tmp2 = (tmp2 >> 19);
   \   0000008A   0x0CFF             LSRS     R7,R7,#+19
   1221                tmp3 = (tmp3 >> 10);
   \   0000008C   0xEA5F 0x2C9C      LSRS     R12,R12,#+10
   1222                tmp4 = (tmp4 >> 3 );
   \   00000090   0xEA5F 0x0EDE      LSRS     LR,LR,#+3
   1223                tmp  = ((tmp3 << 5) | (tmp2 << 11) | tmp4); 
   \   00000094   0xEA5F 0x28C7      LSLS     R8,R7,#+11
   \   00000098   0xEA58 0x184C      ORRS     R8,R8,R12, LSL #+5
   \   0000009C   0xEA5E 0x0808      ORRS     R8,LR,R8
   \   000000A0   0x4645             MOV      R5,R8
   \   000000A2   0xE023             B.N      ??DMA2D_SetConfig_2
   1224              }
   1225              else if (hdma2d->Init.ColorMode == DMA2D_ARGB1555)
   \                     ??DMA2D_SetConfig_4: (+1)
   \   000000A4   0xF8D0 0x8008      LDR      R8,[R0, #+8]
   \   000000A8   0xF1B8 0x0F03      CMP      R8,#+3
   \   000000AC   0xD10F             BNE.N    ??DMA2D_SetConfig_5
   1226              { 
   1227                tmp1 = (tmp1 >> 31);
   \   000000AE   0x0FF6             LSRS     R6,R6,#+31
   1228                tmp2 = (tmp2 >> 19);
   \   000000B0   0x0CFF             LSRS     R7,R7,#+19
   1229                tmp3 = (tmp3 >> 11);
   \   000000B2   0xEA5F 0x2CDC      LSRS     R12,R12,#+11
   1230                tmp4 = (tmp4 >> 3 );      
   \   000000B6   0xEA5F 0x0EDE      LSRS     LR,LR,#+3
   1231                tmp  = ((tmp3 << 5) | (tmp2 << 10) | (tmp1 << 15) | tmp4);    
   \   000000BA   0xEA5F 0x2887      LSLS     R8,R7,#+10
   \   000000BE   0xEA58 0x184C      ORRS     R8,R8,R12, LSL #+5
   \   000000C2   0xEA58 0x38C6      ORRS     R8,R8,R6, LSL #+15
   \   000000C6   0xEA5E 0x0808      ORRS     R8,LR,R8
   \   000000CA   0x4645             MOV      R5,R8
   \   000000CC   0xE00E             B.N      ??DMA2D_SetConfig_2
   1232              } 
   1233              else /* DMA2D_CMode = DMA2D_ARGB4444 */
   1234              {
   1235                tmp1 = (tmp1 >> 28);
   \                     ??DMA2D_SetConfig_5: (+1)
   \   000000CE   0x0F36             LSRS     R6,R6,#+28
   1236                tmp2 = (tmp2 >> 20);
   \   000000D0   0x0D3F             LSRS     R7,R7,#+20
   1237                tmp3 = (tmp3 >> 12);
   \   000000D2   0xEA5F 0x3C1C      LSRS     R12,R12,#+12
   1238                tmp4 = (tmp4 >> 4 );
   \   000000D6   0xEA5F 0x1E1E      LSRS     LR,LR,#+4
   1239                tmp  = ((tmp3 << 4) | (tmp2 << 8) | (tmp1 << 12) | tmp4);
   \   000000DA   0xEA5F 0x2807      LSLS     R8,R7,#+8
   \   000000DE   0xEA58 0x180C      ORRS     R8,R8,R12, LSL #+4
   \   000000E2   0xEA58 0x3806      ORRS     R8,R8,R6, LSL #+12
   \   000000E6   0xEA5E 0x0808      ORRS     R8,LR,R8
   \   000000EA   0x4645             MOV      R5,R8
   1240              }    
   1241              /* Write to DMA2D OCOLR register */
   1242              hdma2d->Instance->OCOLR = tmp;
   \                     ??DMA2D_SetConfig_2: (+1)
   \   000000EC   0xF8D0 0x8000      LDR      R8,[R0, #+0]
   \   000000F0   0xF8C8 0x5038      STR      R5,[R8, #+56]
   \   000000F4   0xE003             B.N      ??DMA2D_SetConfig_6
   1243            } 
   1244            else /* M2M, M2M_PFC or M2M_Blending DMA2D Mode */
   1245            {
   1246              /* Configure DMA2D source address */
   1247              hdma2d->Instance->FGMAR = pdata;
   \                     ??DMA2D_SetConfig_0: (+1)
   \   000000F6   0xF8D0 0x8000      LDR      R8,[R0, #+0]
   \   000000FA   0xF8C8 0x100C      STR      R1,[R8, #+12]
   1248            }
   1249          }
   \                     ??DMA2D_SetConfig_6: (+1)
   \   000000FE   0xE8BD 0x83F0      POP      {R4-R9,PC}       ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2:
   \   00000000   0x00FCFFF0         DC32     0xfcfff0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_1:
   \   00000000   0xFFFF00EF         DC32     0xffff00ef

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_2:
   \   00000000   0x4002B048         DC32     0x4002b048
   1250          
   1251          /**
   1252            * @}
   1253            */
   1254          #endif /* HAL_DMA2D_MODULE_ENABLED */
   1255          /**
   1256            * @}
   1257            */
   1258          
   1259          /**
   1260            * @}
   1261            */
   1262          
   1263          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      28   DMA2D_SetConfig
      16   HAL_DMA2D_Abort
        16   -> HAL_GetTick
      32   HAL_DMA2D_BlendingStart
        32   -> DMA2D_SetConfig
      32   HAL_DMA2D_BlendingStart_IT
        32   -> DMA2D_SetConfig
      16   HAL_DMA2D_ConfigCLUT
       8   HAL_DMA2D_ConfigLayer
       8   HAL_DMA2D_DeInit
         8   -> HAL_DMA2D_MspDeInit
       0   HAL_DMA2D_DisableCLUT
       0   HAL_DMA2D_EnableCLUT
       0   HAL_DMA2D_GetError
       0   HAL_DMA2D_GetState
       8   HAL_DMA2D_IRQHandler
         8   -- Indirect call
      16   HAL_DMA2D_Init
        16   -> HAL_DMA2D_MspInit
       0   HAL_DMA2D_MspDeInit
       0   HAL_DMA2D_MspInit
      24   HAL_DMA2D_PollForTransfer
        24   -> HAL_GetTick
       0   HAL_DMA2D_ProgramLineEvent
       0   HAL_DMA2D_Resume
      32   HAL_DMA2D_Start
        32   -> DMA2D_SetConfig
      32   HAL_DMA2D_Start_IT
        32   -> DMA2D_SetConfig
      16   HAL_DMA2D_Suspend
        16   -> HAL_GetTick


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable2
       4  ??DataTable2_1
       4  ??DataTable2_2
     258  DMA2D_SetConfig
      84  HAL_DMA2D_Abort
      94  HAL_DMA2D_BlendingStart
     130  HAL_DMA2D_BlendingStart_IT
     110  HAL_DMA2D_ConfigCLUT
     282  HAL_DMA2D_ConfigLayer
      38  HAL_DMA2D_DeInit
      36  HAL_DMA2D_DisableCLUT
      36  HAL_DMA2D_EnableCLUT
       4  HAL_DMA2D_GetError
       6  HAL_DMA2D_GetState
     200  HAL_DMA2D_IRQHandler
     108  HAL_DMA2D_Init
       2  HAL_DMA2D_MspDeInit
       2  HAL_DMA2D_MspInit
     252  HAL_DMA2D_PollForTransfer
      46  HAL_DMA2D_ProgramLineEvent
      24  HAL_DMA2D_Resume
      88  HAL_DMA2D_Start
     124  HAL_DMA2D_Start_IT
      72  HAL_DMA2D_Suspend

 
 2 008 bytes in section .text
 
 2 008 bytes of CODE memory

Errors: none
Warnings: none
