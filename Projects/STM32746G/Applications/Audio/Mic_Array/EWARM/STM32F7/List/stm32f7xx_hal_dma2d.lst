###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.2.10312/W32 for ARM       22/Dec/2015  00:06:28
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_dma2d.c
#    Command line =  
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_dma2d.c
#        -D USE_HAL_DRIVER -D STM32F746xx -D USE_STM32746G_DISCO -D
#        USE_IOEXPANDER -D USE_USB_FS -lC
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
#        -lA
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
#        -o
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj
#        --debug --endian=little --cpu=Cortex-M7 -e --fpu=VFPv5_sp
#        --dlib_config "D:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Full.h" -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\Inc\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\CMSIS\Device\ST\STM32F7xx\Include\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\STM32F7xx_HAL_Driver\Inc\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\STM32746G-Discovery\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\Components\Common\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Log\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Fonts\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\CPU\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_Device_Library\Core\Inc\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Core\Inc\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Class\MSC\Inc\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\drivers\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_Audio\Addons\PDM\
#        -Ohz --use_c++_inline --require_prototypes -I "D:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.3\arm\CMSIS\Include\" -D
#        ARM_MATH_CM7
#    List file    =  
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List\stm32f7xx_hal_dma2d.lst
#    Object file  =  
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj\stm32f7xx_hal_dma2d.o
#
###############################################################################

H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_dma2d.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f7xx_hal_dma2d.c
      4            * @author  MCD Application Team
      5            * @version V1.0.1
      6            * @date    25-June-2015
      7            * @brief   DMA2D HAL module driver.
      8            *          This file provides firmware functions to manage the following 
      9            *          functionalities of the DMA2D peripheral:
     10            *           + Initialization and de-initialization functions
     11            *           + IO operation functions
     12            *           + Peripheral Control functions 
     13            *           + Peripheral State and Errors functions
     14            *
     15            @verbatim
     16            ==============================================================================
     17                                  ##### How to use this driver #####
     18            ==============================================================================
     19              [..]
     20                (#) Program the required configuration through following parameters:   
     21                    the Transfer Mode, the output color mode and the output offset using 
     22                    HAL_DMA2D_Init() function.
     23          
     24                (#) Program the required configuration through following parameters:   
     25                    the input color mode, the input color, input alpha value, alpha mode 
     26                    and the input offset using HAL_DMA2D_ConfigLayer() function for foreground
     27                    or/and background layer.
     28                    
     29               *** Polling mode IO operation ***
     30               =================================   
     31              [..]        
     32                 (+) Configure the pdata, Destination and data length and Enable 
     33                     the transfer using HAL_DMA2D_Start() 
     34                 (+) Wait for end of transfer using HAL_DMA2D_PollForTransfer(), at this stage
     35                     user can specify the value of timeout according to his end application.
     36                         
     37               *** Interrupt mode IO operation ***    
     38               ===================================
     39               [..] 
     40                 (#) Configure the pdata, Destination and data length and Enable 
     41                     the transfer using HAL_DMA2D_Start_IT() 
     42                 (#) Use HAL_DMA2D_IRQHandler() called under DMA2D_IRQHandler() Interrupt subroutine
     43                 (#) At the end of data transfer HAL_DMA2D_IRQHandler() function is executed and user can 
     44                     add his own function by customization of function pointer XferCpltCallback and 
     45                     XferErrorCallback (i.e a member of DMA2D handle structure). 
     46          
     47                   -@-   In Register-to-Memory transfer mode, the pdata parameter is the register
     48                         color, in Memory-to-memory or memory-to-memory with pixel format
     49                         conversion the pdata is the source address.
     50          
     51                   -@-   Configure the foreground source address, the background source address, 
     52                         the Destination and data length and Enable the transfer using 
     53                         HAL_DMA2D_BlendingStart() in polling mode and HAL_DMA2D_BlendingStart_IT()
     54                         in interrupt mode.
     55                         
     56                   -@-   HAL_DMA2D_BlendingStart() and HAL_DMA2D_BlendingStart_IT() functions
     57                         are used if the memory to memory with blending transfer mode is selected.
     58                             
     59                (#) Optionally, configure and enable the CLUT using HAL_DMA2D_ConfigCLUT()
     60                    HAL_DMA2D_EnableCLUT() functions.
     61          
     62                (#) Optionally, configure and enable LineInterrupt using the following function:
     63                    HAL_DMA2D_ProgramLineEvent().
     64             
     65                (#) The transfer can be suspended, continued and aborted using the following
     66                    functions: HAL_DMA2D_Suspend(), HAL_DMA2D_Resume(), HAL_DMA2D_Abort().
     67                               
     68                (#) To control DMA2D state you can use the following function: HAL_DMA2D_GetState()                   
     69          
     70               *** DMA2D HAL driver macros list ***
     71               ============================================= 
     72               [..]
     73                 Below the list of most used macros in DMA2D HAL driver :
     74                 
     75                (+) __HAL_DMA2D_ENABLE: Enable the DMA2D peripheral.
     76                (+) __HAL_DMA2D_DISABLE: Disable the DMA2D peripheral.
     77                (+) __HAL_DMA2D_GET_FLAG: Get the DMA2D pending flags.
     78                (+) __HAL_DMA2D_CLEAR_FLAG: Clear the DMA2D pending flags.
     79                (+) __HAL_DMA2D_ENABLE_IT: Enable the specified DMA2D interrupts.
     80                (+) __HAL_DMA2D_DISABLE_IT: Disable the specified DMA2D interrupts.
     81                (+) __HAL_DMA2D_GET_IT_SOURCE: Check whether the specified DMA2D interrupt has occurred or not.
     82               
     83               [..] 
     84                (@) You can refer to the DMA2D HAL driver header file for more useful macros
     85                                            
     86            @endverbatim
     87            ******************************************************************************
     88            * @attention
     89            *
     90            * <h2><center>&copy; COPYRIGHT(c) 2015 STMicroelectronics</center></h2>
     91            *
     92            * Redistribution and use in source and binary forms, with or without modification,
     93            * are permitted provided that the following conditions are met:
     94            *   1. Redistributions of source code must retain the above copyright notice,
     95            *      this list of conditions and the following disclaimer.
     96            *   2. Redistributions in binary form must reproduce the above copyright notice,
     97            *      this list of conditions and the following disclaimer in the documentation
     98            *      and/or other materials provided with the distribution.
     99            *   3. Neither the name of STMicroelectronics nor the names of its contributors
    100            *      may be used to endorse or promote products derived from this software
    101            *      without specific prior written permission.
    102            *
    103            * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
    104            * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
    105            * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
    106            * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
    107            * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
    108            * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
    109            * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
    110            * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
    111            * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
    112            * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
    113            *
    114            ******************************************************************************
    115            */ 
    116          
    117          /* Includes ------------------------------------------------------------------*/
    118          #include "stm32f7xx_hal.h"
    119          
    120          /** @addtogroup STM32F7xx_HAL_Driver
    121            * @{
    122            */
    123          /** @addtogroup DMA2D
    124            * @brief DMA2D HAL module driver
    125            * @{
    126            */
    127          
    128          #ifdef HAL_DMA2D_MODULE_ENABLED
    129          
    130          /* Private types -------------------------------------------------------------*/
    131          /* Private define ------------------------------------------------------------*/
    132          /** @addtogroup DMA2D_Private_Defines
    133            * @{
    134            */
    135          #define HAL_TIMEOUT_DMA2D_ABORT      ((uint32_t)1000)  /* 1s  */
    136          #define HAL_TIMEOUT_DMA2D_SUSPEND    ((uint32_t)1000)  /* 1s  */
    137          /**
    138            * @}
    139            */
    140          
    141          /* Private variables ---------------------------------------------------------*/
    142          /* Private constants ---------------------------------------------------------*/
    143          /* Private macro -------------------------------------------------------------*/
    144          /* Private function prototypes -----------------------------------------------*/
    145          /** @addtogroup DMA2D_Private_Functions_Prototypes
    146            * @{
    147            */
    148          static void DMA2D_SetConfig(DMA2D_HandleTypeDef *hdma2d, uint32_t pdata, uint32_t DstAddress, uint32_t Width, uint32_t Height);
    149          /**
    150            * @}
    151            */
    152          
    153          /* Private functions ---------------------------------------------------------*/
    154          /* Exported functions --------------------------------------------------------*/
    155          /** @addtogroup DMA2D_Exported_Functions
    156            * @{
    157            */
    158          
    159          /** @defgroup DMA2D_Group1 Initialization and Configuration functions
    160           *  @brief   Initialization and Configuration functions
    161           *
    162          @verbatim   
    163           ===============================================================================
    164                          ##### Initialization and Configuration functions #####
    165           ===============================================================================  
    166              [..]  This section provides functions allowing to:
    167                (+) Initialize and configure the DMA2D
    168                (+) De-initialize the DMA2D 
    169          
    170          @endverbatim
    171            * @{
    172            */
    173              
    174          /**
    175            * @brief  Initializes the DMA2D according to the specified
    176            *         parameters in the DMA2D_InitTypeDef and create the associated handle.
    177            * @param  hdma2d: pointer to a DMA2D_HandleTypeDef structure that contains
    178            *                 the configuration information for the DMA2D.
    179            * @retval HAL status
    180            */

   \                                 In section .text, align 2, keep-with-next
    181          HAL_StatusTypeDef HAL_DMA2D_Init(DMA2D_HandleTypeDef *hdma2d)
    182          { 
   \                     HAL_DMA2D_Init: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    183            uint32_t tmp = 0;
    184          
    185            /* Check the DMA2D peripheral state */
    186            if(hdma2d == NULL)
   \   00000004   0xD101             BNE.N    ??HAL_DMA2D_Init_0
    187            {
    188               return HAL_ERROR;
   \   00000006   0x2001             MOVS     R0,#+1
   \   00000008   0xBD32             POP      {R1,R4,R5,PC}
    189            }
    190          
    191            /* Check the parameters */
    192            assert_param(IS_DMA2D_ALL_INSTANCE(hdma2d->Instance));
    193            assert_param(IS_DMA2D_MODE(hdma2d->Init.Mode));
    194            assert_param(IS_DMA2D_CMODE(hdma2d->Init.ColorMode));
    195            assert_param(IS_DMA2D_OFFSET(hdma2d->Init.OutputOffset));
    196          
    197            if(hdma2d->State == HAL_DMA2D_STATE_RESET)
   \                     ??HAL_DMA2D_Init_0: (+1)
   \   0000000A   0xF104 0x0538      ADD      R5,R4,#+56
   \   0000000E   0x7868             LDRB     R0,[R5, #+1]
   \   00000010   0xB918             CBNZ.N   R0,??HAL_DMA2D_Init_1
    198            {
    199              /* Allocate lock resource and initialize it */
    200              hdma2d->Lock = HAL_UNLOCKED;
   \   00000012   0x7028             STRB     R0,[R5, #+0]
    201              /* Init the low level hardware */
    202              HAL_DMA2D_MspInit(hdma2d);
   \   00000014   0x4620             MOV      R0,R4
   \   00000016   0x.... 0x....      BL       HAL_DMA2D_MspInit
    203            }
    204            
    205            /* Change DMA2D peripheral state */
    206            hdma2d->State = HAL_DMA2D_STATE_BUSY;  
   \                     ??HAL_DMA2D_Init_1: (+1)
   \   0000001A   0x2002             MOVS     R0,#+2
   \   0000001C   0x7068             STRB     R0,[R5, #+1]
    207          
    208          /* DMA2D CR register configuration -------------------------------------------*/
    209            /* Get the CR register value */
    210            tmp = hdma2d->Instance->CR;
   \   0000001E   0x6820             LDR      R0,[R4, #+0]
   \   00000020   0x6801             LDR      R1,[R0, #+0]
    211          
    212            /* Clear Mode bits */
    213            tmp &= (uint32_t)~DMA2D_CR_MODE;
    214          
    215            /* Prepare the value to be wrote to the CR register */
    216            tmp |= hdma2d->Init.Mode;
    217          
    218            /* Write to DMA2D CR register */
    219            hdma2d->Instance->CR = tmp;
   \   00000022   0x6862             LDR      R2,[R4, #+4]
   \   00000024   0xF421 0x3140      BIC      R1,R1,#0x30000
   \   00000028   0x4311             ORRS     R1,R2,R1
   \   0000002A   0x6001             STR      R1,[R0, #+0]
    220          
    221          /* DMA2D OPFCCR register configuration ---------------------------------------*/
    222            /* Get the OPFCCR register value */
    223            tmp = hdma2d->Instance->OPFCCR;
   \   0000002C   0x6820             LDR      R0,[R4, #+0]
   \   0000002E   0x6B41             LDR      R1,[R0, #+52]
    224          
    225            /* Clear Color Mode bits */
    226            tmp &= (uint32_t)~DMA2D_OPFCCR_CM;
    227          
    228            /* Prepare the value to be wrote to the OPFCCR register */
    229            tmp |= hdma2d->Init.ColorMode;
    230          
    231            /* Write to DMA2D OPFCCR register */
    232            hdma2d->Instance->OPFCCR = tmp;
   \   00000030   0x68A2             LDR      R2,[R4, #+8]
   \   00000032   0x08C9             LSRS     R1,R1,#+3
   \   00000034   0xEA42 0x01C1      ORR      R1,R2,R1, LSL #+3
   \   00000038   0x6341             STR      R1,[R0, #+52]
    233          
    234          /* DMA2D OOR register configuration ------------------------------------------*/  
    235            /* Get the OOR register value */
    236            tmp = hdma2d->Instance->OOR;
   \   0000003A   0x6820             LDR      R0,[R4, #+0]
   \   0000003C   0x6C01             LDR      R1,[R0, #+64]
    237          
    238            /* Clear Offset bits */
    239            tmp &= (uint32_t)~DMA2D_OOR_LO;
    240          
    241            /* Prepare the value to be wrote to the OOR register */
    242            tmp |= hdma2d->Init.OutputOffset;
    243          
    244            /* Write to DMA2D OOR register */
    245            hdma2d->Instance->OOR = tmp;
   \   0000003E   0x68E2             LDR      R2,[R4, #+12]
   \   00000040   0x0B89             LSRS     R1,R1,#+14
   \   00000042   0xEA42 0x3181      ORR      R1,R2,R1, LSL #+14
   \   00000046   0x6401             STR      R1,[R0, #+64]
    246          
    247            /* Update error code */
    248            hdma2d->ErrorCode = HAL_DMA2D_ERROR_NONE;
   \   00000048   0x2000             MOVS     R0,#+0
   \   0000004A   0x6068             STR      R0,[R5, #+4]
    249          
    250            /* Initialize the DMA2D state*/
    251            hdma2d->State  = HAL_DMA2D_STATE_READY;
   \   0000004C   0x2001             MOVS     R0,#+1
   \   0000004E   0x7068             STRB     R0,[R5, #+1]
    252          
    253            return HAL_OK;
   \   00000050   0x2000             MOVS     R0,#+0
   \   00000052   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    254          }
    255          
    256          /**
    257            * @brief  Deinitializes the DMA2D peripheral registers to their default reset
    258            *         values.
    259            * @param  hdma2d: pointer to a DMA2D_HandleTypeDef structure that contains
    260            *                 the configuration information for the DMA2D.
    261            * @retval None
    262            */
    263          

   \                                 In section .text, align 2, keep-with-next
    264          HAL_StatusTypeDef HAL_DMA2D_DeInit(DMA2D_HandleTypeDef *hdma2d)
    265          {
   \                     HAL_DMA2D_DeInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    266            /* Check the DMA2D peripheral state */
    267            if(hdma2d == NULL)
   \   00000004   0xD101             BNE.N    ??HAL_DMA2D_DeInit_0
    268            {
    269               return HAL_ERROR;
   \   00000006   0x2001             MOVS     R0,#+1
   \   00000008   0xBD10             POP      {R4,PC}
    270            }
    271          
    272            /* DeInit the low level hardware */
    273            HAL_DMA2D_MspDeInit(hdma2d);
   \                     ??HAL_DMA2D_DeInit_0: (+1)
   \   0000000A   0x.... 0x....      BL       HAL_DMA2D_MspDeInit
    274          
    275            /* Update error code */
    276            hdma2d->ErrorCode = HAL_DMA2D_ERROR_NONE;
   \   0000000E   0xF104 0x0038      ADD      R0,R4,#+56
   \   00000012   0x2100             MOVS     R1,#+0
   \   00000014   0x6041             STR      R1,[R0, #+4]
    277          
    278            /* Initialize the DMA2D state*/
    279            hdma2d->State  = HAL_DMA2D_STATE_RESET;
   \   00000016   0x7041             STRB     R1,[R0, #+1]
    280          
    281            /* Release Lock */
    282            __HAL_UNLOCK(hdma2d);
   \   00000018   0x7001             STRB     R1,[R0, #+0]
    283          
    284            return HAL_OK;
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0xBD10             POP      {R4,PC}          ;; return
    285          }
    286          
    287          /**
    288            * @brief  Initializes the DMA2D MSP.
    289            * @param  hdma2d: pointer to a DMA2D_HandleTypeDef structure that contains
    290            *                 the configuration information for the DMA2D.
    291            * @retval None
    292            */

   \                                 In section .text, align 2, keep-with-next
    293          __weak void HAL_DMA2D_MspInit(DMA2D_HandleTypeDef* hdma2d)
    294          {
    295            /* NOTE : This function Should not be modified, when the callback is needed,
    296                      the HAL_DMA2D_MspInit could be implemented in the user file
    297             */ 
    298          }
   \                     HAL_DMA2D_MspInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    299          
    300          /**
    301            * @brief  DeInitializes the DMA2D MSP.
    302            * @param  hdma2d: pointer to a DMA2D_HandleTypeDef structure that contains
    303            *                 the configuration information for the DMA2D.
    304            * @retval None
    305            */

   \                                 In section .text, align 2, keep-with-next
    306          __weak void HAL_DMA2D_MspDeInit(DMA2D_HandleTypeDef* hdma2d)
    307          {
    308            /* NOTE : This function Should not be modified, when the callback is needed,
    309                      the HAL_DMA2D_MspDeInit could be implemented in the user file
    310             */ 
    311          }
   \                     HAL_DMA2D_MspDeInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    312          
    313          /**
    314            * @}
    315            */
    316          
    317          /** @defgroup DMA2D_Group2 IO operation functions 
    318           *  @brief   IO operation functions  
    319           *
    320          @verbatim   
    321           ===============================================================================
    322                                #####  IO operation functions  #####
    323           ===============================================================================  
    324              [..]  This section provides functions allowing to:
    325                (+) Configure the pdata, destination address and data size and 
    326                    Start DMA2D transfer.
    327                (+) Configure the source for foreground and background, destination address 
    328                    and data size and Start MultiBuffer DMA2D transfer.
    329                (+) Configure the pdata, destination address and data size and 
    330                    Start DMA2D transfer with interrupt.
    331                (+) Configure the source for foreground and background, destination address 
    332                    and data size and Start MultiBuffer DMA2D transfer with interrupt.
    333                (+) Abort DMA2D transfer.
    334                (+) Suspend DMA2D transfer.
    335                (+) Continue DMA2D transfer. 
    336                (+) Poll for transfer complete.
    337                (+) handle DMA2D interrupt request.
    338                  
    339          @endverbatim
    340            * @{
    341            */
    342          
    343          /**
    344            * @brief  Start the DMA2D Transfer.
    345            * @param  hdma2d:     pointer to a DMA2D_HandleTypeDef structure that contains
    346            *                     the configuration information for the DMA2D.  
    347            * @param  pdata:      Configure the source memory Buffer address if 
    348            *                     the memory to memory or memory to memory with pixel format 
    349            *                     conversion DMA2D mode is selected, and configure 
    350            *                     the color value if register to memory DMA2D mode is selected.
    351            * @param  DstAddress: The destination memory Buffer address.
    352            * @param  Width:      The width of data to be transferred from source to destination.
    353            * @param  Height:      The height of data to be transferred from source to destination.
    354            * @retval HAL status
    355            */

   \                                 In section .text, align 2, keep-with-next
    356          HAL_StatusTypeDef HAL_DMA2D_Start(DMA2D_HandleTypeDef *hdma2d, uint32_t pdata, uint32_t DstAddress, uint32_t Width,  uint32_t Height)
    357          {
   \                     HAL_DMA2D_Start: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x.... 0x....      BL       ?Subroutine7
    358            /* Process locked */
    359            __HAL_LOCK(hdma2d);
   \                     ??CrossCallReturnLabel_12: (+1)
   \   00000006   0xD101             BNE.N    ??HAL_DMA2D_Start_0
   \   00000008   0x2002             MOVS     R0,#+2
   \   0000000A   0xBD32             POP      {R1,R4,R5,PC}
   \                     ??HAL_DMA2D_Start_0: (+1)
   \   0000000C   0x.... 0x....      BL       ?Subroutine3
    360          
    361            /* Change DMA2D peripheral state */
    362            hdma2d->State = HAL_DMA2D_STATE_BUSY;
    363          
    364            /* Check the parameters */
    365            assert_param(IS_DMA2D_LINE(Height));
    366            assert_param(IS_DMA2D_PIXEL(Width));
    367          
    368            /* Disable the Peripheral */
    369            __HAL_DMA2D_DISABLE(hdma2d);
    370          
    371            /* Configure the source, destination address and the data size */
    372            DMA2D_SetConfig(hdma2d, pdata, DstAddress, Width, Height);
   \                     ??CrossCallReturnLabel_4: (+1)
   \   00000010   0x....             B.N      ?Subroutine0
    373          
    374            /* Enable the Peripheral */
    375            __HAL_DMA2D_ENABLE(hdma2d);
    376          
    377            return HAL_OK;
    378          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine7: (+1)
   \   00000000   0x4604             MOV      R4,R0
   \   00000002   0xF104 0x0038      ADD      R0,R4,#+56
   \   00000006   0x7805             LDRB     R5,[R0, #+0]
   \   00000008   0x2D01             CMP      R5,#+1
   \   0000000A   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine3: (+1)
   \   00000000   0x2501             MOVS     R5,#+1
   \   00000002   0x7005             STRB     R5,[R0, #+0]
   \   00000004   0x2502             MOVS     R5,#+2
   \   00000006   0x7045             STRB     R5,[R0, #+1]
   \   00000008   0x6820             LDR      R0,[R4, #+0]
   \   0000000A   0x6805             LDR      R5,[R0, #+0]
   \   0000000C   0x086D             LSRS     R5,R5,#+1
   \   0000000E   0x006D             LSLS     R5,R5,#+1
   \   00000010   0x6005             STR      R5,[R0, #+0]
   \   00000012   0x9804             LDR      R0,[SP, #+16]
   \   00000014   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \   00000000   0x.... 0x....      BL       ?Subroutine6
   \                     ??Subroutine0_0: (+1)
   \   00000004   0x6820             LDR      R0,[R4, #+0]
   \   00000006   0x6801             LDR      R1,[R0, #+0]
   \   00000008   0xF041 0x0101      ORR      R1,R1,#0x1
   \   0000000C                      REQUIRE ??Subroutine8_0
   \   0000000C                      ;; // Fall through to label ??Subroutine8_0

   \                                 In section .text, align 2, keep-with-next
   \                     ??Subroutine8_0: (+1)
   \   00000000   0x6001             STR      R1,[R0, #+0]
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0xBD32             POP      {R1,R4,R5,PC}    ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine6: (+1)
   \   00000000   0x9000             STR      R0,[SP, #+0]
   \   00000002   0x4620             MOV      R0,R4
   \   00000004   0x....             B.N      DMA2D_SetConfig
    379          
    380          /**
    381            * @brief  Start the DMA2D Transfer with interrupt enabled.
    382            * @param  hdma2d:     pointer to a DMA2D_HandleTypeDef structure that contains
    383            *                     the configuration information for the DMA2D.  
    384            * @param  pdata:      Configure the source memory Buffer address if 
    385            *                     the memory to memory or memory to memory with pixel format 
    386            *                     conversion DMA2D mode is selected, and configure 
    387            *                     the color value if register to memory DMA2D mode is selected.
    388            * @param  DstAddress: The destination memory Buffer address.
    389            * @param  Width:      The width of data to be transferred from source to destination.
    390            * @param  Height:     The height of data to be transferred from source to destination.
    391            * @retval HAL status
    392            */

   \                                 In section .text, align 2, keep-with-next
    393          HAL_StatusTypeDef HAL_DMA2D_Start_IT(DMA2D_HandleTypeDef *hdma2d, uint32_t pdata, uint32_t DstAddress, uint32_t Width,  uint32_t Height)
    394          {
   \                     HAL_DMA2D_Start_IT: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x.... 0x....      BL       ?Subroutine7
    395            /* Process locked */
    396            __HAL_LOCK(hdma2d);
   \                     ??CrossCallReturnLabel_13: (+1)
   \   00000006   0xD101             BNE.N    ??HAL_DMA2D_Start_IT_0
   \   00000008   0x2002             MOVS     R0,#+2
   \   0000000A   0xBD32             POP      {R1,R4,R5,PC}
   \                     ??HAL_DMA2D_Start_IT_0: (+1)
   \   0000000C   0x.... 0x....      BL       ?Subroutine3
    397          
    398            /* Change DMA2D peripheral state */
    399            hdma2d->State = HAL_DMA2D_STATE_BUSY;
    400          
    401            /* Check the parameters */
    402            assert_param(IS_DMA2D_LINE(Height));
    403            assert_param(IS_DMA2D_PIXEL(Width));
    404          
    405            /* Disable the Peripheral */
    406            __HAL_DMA2D_DISABLE(hdma2d);
    407          
    408            /* Configure the source, destination address and the data size */
    409            DMA2D_SetConfig(hdma2d, pdata, DstAddress, Width, Height);
   \                     ??CrossCallReturnLabel_5: (+1)
   \   00000010   0x.... 0x....      BL       ?Subroutine6
    410          
    411            /* Enable the transfer complete interrupt */
    412            __HAL_DMA2D_ENABLE_IT(hdma2d, DMA2D_IT_TC);
   \                     ??CrossCallReturnLabel_11: (+1)
   \   00000014   0x.... 0x....      BL       ?Subroutine2
    413          
    414            /* Enable the transfer Error interrupt */
    415            __HAL_DMA2D_ENABLE_IT(hdma2d, DMA2D_IT_TE);
    416          
    417            /* Enable the Peripheral */
    418            __HAL_DMA2D_ENABLE(hdma2d);
   \                     ??CrossCallReturnLabel_2: (+1)
   \   00000018   0x6820             LDR      R0,[R4, #+0]
   \   0000001A   0x6801             LDR      R1,[R0, #+0]
   \   0000001C   0xF041 0x0101      ORR      R1,R1,#0x1
   \   00000020   0x6001             STR      R1,[R0, #+0]
    419          
    420            /* Enable the configuration error interrupt */
    421            __HAL_DMA2D_ENABLE_IT(hdma2d, DMA2D_IT_CE);
   \   00000022   0x6820             LDR      R0,[R4, #+0]
   \   00000024   0x6801             LDR      R1,[R0, #+0]
   \   00000026   0xF441 0x5100      ORR      R1,R1,#0x2000
   \   0000002A   0x....             B.N      ??Subroutine8_0
    422          
    423            return HAL_OK;
    424          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine2: (+1)
   \   00000000   0x6820             LDR      R0,[R4, #+0]
   \   00000002   0x6801             LDR      R1,[R0, #+0]
   \   00000004   0xF441 0x7100      ORR      R1,R1,#0x200
   \   00000008   0x6001             STR      R1,[R0, #+0]
   \   0000000A   0x6820             LDR      R0,[R4, #+0]
   \   0000000C   0x6801             LDR      R1,[R0, #+0]
   \   0000000E   0xF441 0x7180      ORR      R1,R1,#0x100
   \   00000012   0x6001             STR      R1,[R0, #+0]
   \   00000014   0x4770             BX       LR
    425          
    426          /**
    427            * @brief  Start the multi-source DMA2D Transfer.
    428            * @param  hdma2d:      pointer to a DMA2D_HandleTypeDef structure that contains
    429            *                      the configuration information for the DMA2D.  
    430            * @param  SrcAddress1: The source memory Buffer address of the foreground layer.
    431            * @param  SrcAddress2: The source memory Buffer address of the background layer.
    432            * @param  DstAddress:  The destination memory Buffer address
    433            * @param  Width:       The width of data to be transferred from source to destination.
    434            * @param  Height:      The height of data to be transferred from source to destination.
    435            * @retval HAL status
    436            */

   \                                 In section .text, align 2, keep-with-next
    437          HAL_StatusTypeDef HAL_DMA2D_BlendingStart(DMA2D_HandleTypeDef *hdma2d, uint32_t SrcAddress1, uint32_t  SrcAddress2, uint32_t DstAddress, uint32_t Width,  uint32_t Height)
    438          {
   \                     HAL_DMA2D_BlendingStart: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x.... 0x....      BL       ?Subroutine5
    439            /* Process locked */
    440            __HAL_LOCK(hdma2d);
   \                     ??CrossCallReturnLabel_8: (+1)
   \   00000006   0xD101             BNE.N    ??HAL_DMA2D_BlendingStart_0
   \   00000008   0x2002             MOVS     R0,#+2
   \   0000000A   0xBD32             POP      {R1,R4,R5,PC}
   \                     ??HAL_DMA2D_BlendingStart_0: (+1)
   \   0000000C   0x.... 0x....      BL       ?Subroutine4
    441          
    442            /* Change DMA2D peripheral state */
    443            hdma2d->State = HAL_DMA2D_STATE_BUSY; 
    444          
    445            /* Check the parameters */
    446            assert_param(IS_DMA2D_LINE(Height));
    447            assert_param(IS_DMA2D_PIXEL(Width));
    448          
    449            /* Disable the Peripheral */
    450            __HAL_DMA2D_DISABLE(hdma2d);
    451          
    452            /* Configure DMA2D Stream source2 address */
    453            hdma2d->Instance->BGMAR = SrcAddress2;
    454          
    455            /* Configure the source, destination address and the data size */
    456            DMA2D_SetConfig(hdma2d, SrcAddress1, DstAddress, Width, Height);
   \                     ??CrossCallReturnLabel_6: (+1)
   \   00000010                      REQUIRE ?Subroutine0
   \   00000010                      ;; // Fall through to label ?Subroutine0
    457          
    458            /* Enable the Peripheral */
    459            __HAL_DMA2D_ENABLE(hdma2d);
    460          
    461            return HAL_OK;
    462          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine5: (+1)
   \   00000000   0x4604             MOV      R4,R0
   \   00000002   0x4610             MOV      R0,R2
   \   00000004   0x461A             MOV      R2,R3
   \   00000006   0xF104 0x0338      ADD      R3,R4,#+56
   \   0000000A   0x781D             LDRB     R5,[R3, #+0]
   \   0000000C   0x2D01             CMP      R5,#+1
   \   0000000E   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine4: (+1)
   \   00000000   0x2501             MOVS     R5,#+1
   \   00000002   0x701D             STRB     R5,[R3, #+0]
   \   00000004   0x2502             MOVS     R5,#+2
   \   00000006   0x705D             STRB     R5,[R3, #+1]
   \   00000008   0x6823             LDR      R3,[R4, #+0]
   \   0000000A   0x681D             LDR      R5,[R3, #+0]
   \   0000000C   0x086D             LSRS     R5,R5,#+1
   \   0000000E   0x006D             LSLS     R5,R5,#+1
   \   00000010   0x601D             STR      R5,[R3, #+0]
   \   00000012   0x6823             LDR      R3,[R4, #+0]
   \   00000014   0x6158             STR      R0,[R3, #+20]
   \   00000016   0x9805             LDR      R0,[SP, #+20]
   \   00000018   0x9B04             LDR      R3,[SP, #+16]
   \   0000001A   0x4770             BX       LR
    463          
    464          /**
    465            * @brief  Start the multi-source DMA2D Transfer with interrupt enabled.
    466            * @param  hdma2d:     pointer to a DMA2D_HandleTypeDef structure that contains
    467            *                     the configuration information for the DMA2D.  
    468            * @param  SrcAddress1: The source memory Buffer address of the foreground layer.
    469            * @param  SrcAddress2: The source memory Buffer address of the background layer.
    470            * @param  DstAddress:  The destination memory Buffer address.
    471            * @param  Width:       The width of data to be transferred from source to destination.
    472            * @param  Height:      The height of data to be transferred from source to destination.
    473            * @retval HAL status
    474            */

   \                                 In section .text, align 2, keep-with-next
    475          HAL_StatusTypeDef HAL_DMA2D_BlendingStart_IT(DMA2D_HandleTypeDef *hdma2d, uint32_t SrcAddress1, uint32_t  SrcAddress2, uint32_t DstAddress, uint32_t Width,  uint32_t Height)
    476          {
   \                     HAL_DMA2D_BlendingStart_IT: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x.... 0x....      BL       ?Subroutine5
    477            /* Process locked */
    478            __HAL_LOCK(hdma2d);
   \                     ??CrossCallReturnLabel_9: (+1)
   \   00000006   0xD101             BNE.N    ??HAL_DMA2D_BlendingStart_IT_0
   \   00000008   0x2002             MOVS     R0,#+2
   \   0000000A   0xBD32             POP      {R1,R4,R5,PC}
   \                     ??HAL_DMA2D_BlendingStart_IT_0: (+1)
   \   0000000C   0x.... 0x....      BL       ?Subroutine4
    479          
    480            /* Change DMA2D peripheral state */
    481            hdma2d->State = HAL_DMA2D_STATE_BUSY;
    482          
    483            /* Check the parameters */
    484            assert_param(IS_DMA2D_LINE(Height));
    485            assert_param(IS_DMA2D_PIXEL(Width));
    486          
    487            /* Disable the Peripheral */
    488            __HAL_DMA2D_DISABLE(hdma2d);
    489           
    490            /* Configure DMA2D Stream source2 address */
    491            hdma2d->Instance->BGMAR = SrcAddress2;
    492          
    493            /* Configure the source, destination address and the data size */
    494            DMA2D_SetConfig(hdma2d, SrcAddress1, DstAddress, Width, Height);
   \                     ??CrossCallReturnLabel_7: (+1)
   \   00000010   0x.... 0x....      BL       ?Subroutine6
    495          
    496            /* Enable the configuration error interrupt */
    497            __HAL_DMA2D_ENABLE_IT(hdma2d, DMA2D_IT_CE);
   \                     ??CrossCallReturnLabel_10: (+1)
   \   00000014   0x6820             LDR      R0,[R4, #+0]
   \   00000016   0x6801             LDR      R1,[R0, #+0]
   \   00000018   0xF441 0x5100      ORR      R1,R1,#0x2000
   \   0000001C   0x6001             STR      R1,[R0, #+0]
    498          
    499            /* Enable the transfer complete interrupt */
    500            __HAL_DMA2D_ENABLE_IT(hdma2d, DMA2D_IT_TC);
   \   0000001E   0x.... 0x....      BL       ?Subroutine2
    501          
    502            /* Enable the transfer Error interrupt */
    503            __HAL_DMA2D_ENABLE_IT(hdma2d, DMA2D_IT_TE);
    504          
    505            /* Enable the Peripheral */
    506            __HAL_DMA2D_ENABLE(hdma2d);
   \                     ??CrossCallReturnLabel_3: (+1)
   \   00000022   0x....             B.N      ??Subroutine0_0
    507          
    508            return HAL_OK;
    509          }
    510          
    511          /**
    512            * @brief  Abort the DMA2D Transfer.
    513            * @param  hdma2d : pointer to a DMA2D_HandleTypeDef structure that contains
    514            *                  the configuration information for the DMA2D.
    515            * @retval HAL status
    516            */

   \                                 In section .text, align 2, keep-with-next
    517          HAL_StatusTypeDef HAL_DMA2D_Abort(DMA2D_HandleTypeDef *hdma2d)
    518          {
   \                     HAL_DMA2D_Abort: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
    519            uint32_t tickstart = 0;
    520          
    521            /* Disable the DMA2D */
    522            __HAL_DMA2D_DISABLE(hdma2d);
   \   00000004   0x6820             LDR      R0,[R4, #+0]
   \   00000006   0x6801             LDR      R1,[R0, #+0]
   \   00000008   0x0849             LSRS     R1,R1,#+1
   \   0000000A   0x0049             LSLS     R1,R1,#+1
   \   0000000C   0x6001             STR      R1,[R0, #+0]
    523          
    524            /* Get tick */
    525            tickstart = HAL_GetTick();
   \   0000000E   0x.... 0x....      BL       HAL_GetTick
   \   00000012   0x4605             MOV      R5,R0
    526          
    527            /* Check if the DMA2D is effectively disabled */
    528            while((hdma2d->Instance->CR & DMA2D_CR_START) != 0)
   \                     ??HAL_DMA2D_Abort_0: (+1)
   \   00000014   0x6820             LDR      R0,[R4, #+0]
   \   00000016   0x6800             LDR      R0,[R0, #+0]
   \   00000018   0x07C0             LSLS     R0,R0,#+31
   \   0000001A   0xD511             BPL.N    ??HAL_DMA2D_Abort_1
    529            {
    530              if((HAL_GetTick() - tickstart ) > HAL_TIMEOUT_DMA2D_ABORT)
   \   0000001C   0x.... 0x....      BL       HAL_GetTick
   \   00000020   0x1B40             SUBS     R0,R0,R5
   \   00000022   0xF5B0 0x7F7A      CMP      R0,#+1000
   \   00000026   0xD9F5             BLS.N    ??HAL_DMA2D_Abort_0
    531              {
    532                /* Update error code */
    533                hdma2d->ErrorCode |= HAL_DMA2D_ERROR_TIMEOUT;
   \   00000028   0xF104 0x0038      ADD      R0,R4,#+56
   \   0000002C   0x6841             LDR      R1,[R0, #+4]
   \   0000002E   0xF041 0x0120      ORR      R1,R1,#0x20
   \   00000032   0x6041             STR      R1,[R0, #+4]
    534                
    535                /* Change the DMA2D state */
    536                hdma2d->State= HAL_DMA2D_STATE_TIMEOUT;
   \   00000034   0x2103             MOVS     R1,#+3
   \   00000036   0x7041             STRB     R1,[R0, #+1]
    537                
    538                /* Process Unlocked */
    539                __HAL_UNLOCK(hdma2d);
   \   00000038   0x2100             MOVS     R1,#+0
   \   0000003A   0x7001             STRB     R1,[R0, #+0]
    540                
    541                return HAL_TIMEOUT;
   \   0000003C   0x2003             MOVS     R0,#+3
   \   0000003E   0xBD32             POP      {R1,R4,R5,PC}
    542              }
    543            }
    544            /* Process Unlocked */
    545            __HAL_UNLOCK(hdma2d);
   \                     ??HAL_DMA2D_Abort_1: (+1)
   \   00000040   0xF104 0x0038      ADD      R0,R4,#+56
   \   00000044   0x2100             MOVS     R1,#+0
   \   00000046   0x7001             STRB     R1,[R0, #+0]
    546          
    547            /* Change the DMA2D state*/
    548            hdma2d->State = HAL_DMA2D_STATE_READY;
   \   00000048   0x2101             MOVS     R1,#+1
   \   0000004A   0x7041             STRB     R1,[R0, #+1]
    549          
    550            return HAL_OK;
   \   0000004C   0x2000             MOVS     R0,#+0
   \   0000004E   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    551          }
    552          
    553          /**
    554            * @brief  Suspend the DMA2D Transfer.
    555            * @param  hdma2d: pointer to a DMA2D_HandleTypeDef structure that contains
    556            *                 the configuration information for the DMA2D. 
    557            * @retval HAL status
    558            */

   \                                 In section .text, align 2, keep-with-next
    559          HAL_StatusTypeDef HAL_DMA2D_Suspend(DMA2D_HandleTypeDef *hdma2d)
    560          {
   \                     HAL_DMA2D_Suspend: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
    561            uint32_t tickstart = 0;
    562          
    563            /* Suspend the DMA2D transfer */
    564            hdma2d->Instance->CR |= DMA2D_CR_SUSP;
   \   00000004   0x6820             LDR      R0,[R4, #+0]
   \   00000006   0x6801             LDR      R1,[R0, #+0]
   \   00000008   0xF041 0x0102      ORR      R1,R1,#0x2
   \   0000000C   0x6001             STR      R1,[R0, #+0]
    565          
    566            /* Get tick */
    567            tickstart = HAL_GetTick();
   \   0000000E   0x.... 0x....      BL       HAL_GetTick
   \   00000012   0x4605             MOV      R5,R0
    568          
    569            /* Check if the DMA2D is effectively suspended */
    570            while((hdma2d->Instance->CR & DMA2D_CR_SUSP) != DMA2D_CR_SUSP)
   \                     ??HAL_DMA2D_Suspend_0: (+1)
   \   00000014   0x6820             LDR      R0,[R4, #+0]
   \   00000016   0x6800             LDR      R0,[R0, #+0]
   \   00000018   0x0780             LSLS     R0,R0,#+30
   \   0000001A   0xD40D             BMI.N    ??HAL_DMA2D_Suspend_1
    571            {
    572              if((HAL_GetTick() - tickstart ) > HAL_TIMEOUT_DMA2D_SUSPEND)
   \   0000001C   0x.... 0x....      BL       HAL_GetTick
   \   00000020   0x1B40             SUBS     R0,R0,R5
   \   00000022   0xF5B0 0x7F7A      CMP      R0,#+1000
   \   00000026   0xD9F5             BLS.N    ??HAL_DMA2D_Suspend_0
    573              {
    574                /* Update error code */
    575                hdma2d->ErrorCode |= HAL_DMA2D_ERROR_TIMEOUT;
   \   00000028   0x6BE0             LDR      R0,[R4, #+60]
   \   0000002A   0xF040 0x0020      ORR      R0,R0,#0x20
   \   0000002E   0x63E0             STR      R0,[R4, #+60]
    576                
    577                /* Change the DMA2D state */
    578                hdma2d->State= HAL_DMA2D_STATE_TIMEOUT;
   \   00000030   0x2003             MOVS     R0,#+3
   \   00000032   0xF884 0x0039      STRB     R0,[R4, #+57]
    579                
    580                return HAL_TIMEOUT;
   \   00000036   0xBD32             POP      {R1,R4,R5,PC}
    581              }
    582            }
    583            /* Change the DMA2D state*/
    584            hdma2d->State = HAL_DMA2D_STATE_SUSPEND;
   \                     ??HAL_DMA2D_Suspend_1: (+1)
   \   00000038   0x2005             MOVS     R0,#+5
   \   0000003A   0xF884 0x0039      STRB     R0,[R4, #+57]
    585          
    586            return HAL_OK;
   \   0000003E   0x2000             MOVS     R0,#+0
   \   00000040   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    587          }
    588          
    589          /**
    590            * @brief  Resume the DMA2D Transfer.
    591            * @param  hdma2d: pointer to a DMA2D_HandleTypeDef structure that contains
    592            *                 the configuration information for the DMA2D.  
    593            * @retval HAL status
    594            */

   \                                 In section .text, align 2, keep-with-next
    595          HAL_StatusTypeDef HAL_DMA2D_Resume(DMA2D_HandleTypeDef *hdma2d)
    596          {
    597            /* Resume the DMA2D transfer */
    598            hdma2d->Instance->CR &= ~DMA2D_CR_SUSP;
   \                     HAL_DMA2D_Resume: (+1)
   \   00000000   0x6801             LDR      R1,[R0, #+0]
   \   00000002   0x680A             LDR      R2,[R1, #+0]
   \   00000004   0xF022 0x0202      BIC      R2,R2,#0x2
   \   00000008   0x600A             STR      R2,[R1, #+0]
    599          
    600            /* Change the DMA2D state*/
    601            hdma2d->State = HAL_DMA2D_STATE_BUSY;
   \   0000000A   0x2102             MOVS     R1,#+2
   \   0000000C   0xF880 0x1039      STRB     R1,[R0, #+57]
    602          
    603            return HAL_OK;
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0x4770             BX       LR               ;; return
    604          }
    605          
    606          /**
    607            * @brief  Polling for transfer complete or CLUT loading.
    608            * @param  hdma2d: pointer to a DMA2D_HandleTypeDef structure that contains
    609            *                 the configuration information for the DMA2D. 
    610            * @param  Timeout: Timeout duration
    611            * @retval HAL status
    612            */

   \                                 In section .text, align 2, keep-with-next
    613          HAL_StatusTypeDef HAL_DMA2D_PollForTransfer(DMA2D_HandleTypeDef *hdma2d, uint32_t Timeout)
    614          {
   \                     HAL_DMA2D_PollForTransfer: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    615            uint32_t tmp, tmp1;
    616            uint32_t tickstart = 0;
    617          
    618            /* Polling for DMA2D transfer */
    619            if((hdma2d->Instance->CR & DMA2D_CR_START) != 0)
   \   00000006   0xF104 0x0638      ADD      R6,R4,#+56
   \   0000000A   0x6820             LDR      R0,[R4, #+0]
   \   0000000C   0x6800             LDR      R0,[R0, #+0]
   \   0000000E   0x07C0             LSLS     R0,R0,#+31
   \   00000010   0xD522             BPL.N    ??HAL_DMA2D_PollForTransfer_0
    620            {
    621             /* Get tick */
    622             tickstart = HAL_GetTick();
   \   00000012   0x.... 0x....      BL       HAL_GetTick
   \   00000016   0x4607             MOV      R7,R0
    623          
    624              while(__HAL_DMA2D_GET_FLAG(hdma2d, DMA2D_FLAG_TC) == RESET)
   \                     ??HAL_DMA2D_PollForTransfer_1: (+1)
   \   00000018   0x6820             LDR      R0,[R4, #+0]
   \   0000001A   0x6841             LDR      R1,[R0, #+4]
   \   0000001C   0x0789             LSLS     R1,R1,#+30
   \   0000001E   0xD41B             BMI.N    ??HAL_DMA2D_PollForTransfer_0
    625              {
    626                tmp  = __HAL_DMA2D_GET_FLAG(hdma2d, DMA2D_FLAG_CE);
   \   00000020   0x6841             LDR      R1,[R0, #+4]
    627                tmp1 = __HAL_DMA2D_GET_FLAG(hdma2d, DMA2D_FLAG_TE);
   \   00000022   0x6842             LDR      R2,[R0, #+4]
    628          
    629                if((tmp != RESET) || (tmp1 != RESET))
   \   00000024   0x0689             LSLS     R1,R1,#+26
   \   00000026   0xD401             BMI.N    ??HAL_DMA2D_PollForTransfer_2
   \   00000028   0x07D1             LSLS     R1,R2,#+31
   \   0000002A   0xD509             BPL.N    ??HAL_DMA2D_PollForTransfer_3
    630                {
    631                  /* Clear the transfer and configuration error flags */
    632                  __HAL_DMA2D_CLEAR_FLAG(hdma2d, DMA2D_FLAG_CE);
   \                     ??HAL_DMA2D_PollForTransfer_2: (+1)
   \   0000002C   0x2120             MOVS     R1,#+32
   \   0000002E   0x6081             STR      R1,[R0, #+8]
    633                  __HAL_DMA2D_CLEAR_FLAG(hdma2d, DMA2D_FLAG_TE);
   \   00000030   0x6821             LDR      R1,[R4, #+0]
   \   00000032   0x2001             MOVS     R0,#+1
   \   00000034   0x6088             STR      R0,[R1, #+8]
    634          
    635                  /* Change DMA2D state */
    636                  hdma2d->State= HAL_DMA2D_STATE_ERROR;
   \   00000036   0x2004             MOVS     R0,#+4
   \   00000038   0x7070             STRB     R0,[R6, #+1]
    637          
    638                  /* Process unlocked */
    639                  __HAL_UNLOCK(hdma2d);
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0x7030             STRB     R0,[R6, #+0]
    640                  
    641                  return HAL_ERROR;
   \   0000003E   0xE01D             B.N      ??HAL_DMA2D_PollForTransfer_4
    642                }
    643                /* Check for the Timeout */
    644                if(Timeout != HAL_MAX_DELAY)
   \                     ??HAL_DMA2D_PollForTransfer_3: (+1)
   \   00000040   0xF115 0x0F01      CMN      R5,#+1
   \   00000044   0xD0E8             BEQ.N    ??HAL_DMA2D_PollForTransfer_1
    645                {
    646                  if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
   \   00000046   0xB125             CBZ.N    R5,??HAL_DMA2D_PollForTransfer_5
   \   00000048   0x.... 0x....      BL       HAL_GetTick
   \   0000004C   0x1BC0             SUBS     R0,R0,R7
   \   0000004E   0x4285             CMP      R5,R0
   \   00000050   0xD2E2             BCS.N    ??HAL_DMA2D_PollForTransfer_1
    647                  {
    648                    /* Process unlocked */
    649                    __HAL_UNLOCK(hdma2d);
   \                     ??HAL_DMA2D_PollForTransfer_5: (+1)
   \   00000052   0x2000             MOVS     R0,#+0
   \   00000054   0x7030             STRB     R0,[R6, #+0]
    650                  
    651                    /* Update error code */
    652                    hdma2d->ErrorCode |= HAL_DMA2D_ERROR_TIMEOUT;
   \   00000056   0xE01C             B.N      ??HAL_DMA2D_PollForTransfer_6
    653          
    654                    /* Change the DMA2D state */
    655                    hdma2d->State= HAL_DMA2D_STATE_TIMEOUT;
    656                    
    657                    return HAL_TIMEOUT;
    658                  }
    659                }        
    660              }
    661            }
    662            /* Polling for CLUT loading */
    663            if((hdma2d->Instance->FGPFCCR & DMA2D_FGPFCCR_START) != 0)
   \                     ??HAL_DMA2D_PollForTransfer_0: (+1)
   \   00000058   0x6820             LDR      R0,[R4, #+0]
   \   0000005A   0x69C0             LDR      R0,[R0, #+28]
   \   0000005C   0x0680             LSLS     R0,R0,#+26
   \   0000005E   0xD51F             BPL.N    ??HAL_DMA2D_PollForTransfer_7
    664            {
    665              /* Get tick */
    666              tickstart = HAL_GetTick();
   \   00000060   0x.... 0x....      BL       HAL_GetTick
   \   00000064   0x4607             MOV      R7,R0
    667             
    668              while(__HAL_DMA2D_GET_FLAG(hdma2d, DMA2D_FLAG_CTC) == RESET)
   \                     ??HAL_DMA2D_PollForTransfer_8: (+1)
   \   00000066   0x6820             LDR      R0,[R4, #+0]
   \   00000068   0x6841             LDR      R1,[R0, #+4]
   \   0000006A   0x06C9             LSLS     R1,R1,#+27
   \   0000006C   0xD418             BMI.N    ??HAL_DMA2D_PollForTransfer_7
    669              {
    670                if((__HAL_DMA2D_GET_FLAG(hdma2d, DMA2D_FLAG_CAE) != RESET))
   \   0000006E   0x6841             LDR      R1,[R0, #+4]
   \   00000070   0x0709             LSLS     R1,R1,#+28
   \   00000072   0xD505             BPL.N    ??HAL_DMA2D_PollForTransfer_9
    671                {      
    672                  /* Clear the transfer and configuration error flags */
    673                  __HAL_DMA2D_CLEAR_FLAG(hdma2d, DMA2D_FLAG_CAE);
   \   00000074   0x2108             MOVS     R1,#+8
   \   00000076   0x6081             STR      R1,[R0, #+8]
    674                  
    675                  /* Change DMA2D state */
    676                  hdma2d->State= HAL_DMA2D_STATE_ERROR;
   \   00000078   0x2004             MOVS     R0,#+4
   \   0000007A   0x7070             STRB     R0,[R6, #+1]
    677                  
    678                  return HAL_ERROR;      
   \                     ??HAL_DMA2D_PollForTransfer_4: (+1)
   \   0000007C   0x2001             MOVS     R0,#+1
   \   0000007E   0xBDF2             POP      {R1,R4-R7,PC}
    679                }      
    680                /* Check for the Timeout */
    681                if(Timeout != HAL_MAX_DELAY)
   \                     ??HAL_DMA2D_PollForTransfer_9: (+1)
   \   00000080   0xF115 0x0F01      CMN      R5,#+1
   \   00000084   0xD0EF             BEQ.N    ??HAL_DMA2D_PollForTransfer_8
    682                {
    683                  if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
   \   00000086   0xB125             CBZ.N    R5,??HAL_DMA2D_PollForTransfer_6
   \   00000088   0x.... 0x....      BL       HAL_GetTick
   \   0000008C   0x1BC0             SUBS     R0,R0,R7
   \   0000008E   0x4285             CMP      R5,R0
   \   00000090   0xD2E9             BCS.N    ??HAL_DMA2D_PollForTransfer_8
    684                  {
    685                    /* Update error code */
    686                    hdma2d->ErrorCode |= HAL_DMA2D_ERROR_TIMEOUT;
   \                     ??HAL_DMA2D_PollForTransfer_6: (+1)
   \   00000092   0x6870             LDR      R0,[R6, #+4]
   \   00000094   0xF040 0x0020      ORR      R0,R0,#0x20
   \   00000098   0x6070             STR      R0,[R6, #+4]
    687              
    688                    /* Change the DMA2D state */
    689                    hdma2d->State= HAL_DMA2D_STATE_TIMEOUT;
   \   0000009A   0x2003             MOVS     R0,#+3
   \   0000009C   0x7070             STRB     R0,[R6, #+1]
    690                    
    691                    return HAL_TIMEOUT;
   \   0000009E   0xBDF2             POP      {R1,R4-R7,PC}
    692                  }
    693                }      
    694              }
    695            }
    696            /* Clear the transfer complete flag */
    697            __HAL_DMA2D_CLEAR_FLAG(hdma2d, DMA2D_FLAG_TC);
   \                     ??HAL_DMA2D_PollForTransfer_7: (+1)
   \   000000A0   0x6821             LDR      R1,[R4, #+0]
   \   000000A2   0x2002             MOVS     R0,#+2
   \   000000A4   0x6088             STR      R0,[R1, #+8]
    698            
    699            /* Clear the CLUT loading flag */
    700            __HAL_DMA2D_CLEAR_FLAG(hdma2d, DMA2D_FLAG_CTC);  
   \   000000A6   0x6821             LDR      R1,[R4, #+0]
   \   000000A8   0x2010             MOVS     R0,#+16
   \   000000AA   0x6088             STR      R0,[R1, #+8]
    701            
    702            /* Change DMA2D state */
    703            hdma2d->State = HAL_DMA2D_STATE_READY;
   \   000000AC   0x2001             MOVS     R0,#+1
   \   000000AE   0x7070             STRB     R0,[R6, #+1]
    704            
    705            /* Process unlocked */
    706            __HAL_UNLOCK(hdma2d);
   \   000000B0   0x2000             MOVS     R0,#+0
   \   000000B2   0x7030             STRB     R0,[R6, #+0]
    707            
    708            return HAL_OK;
   \   000000B4   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    709          }
    710          /**
    711            * @brief  Handles DMA2D interrupt request.
    712            * @param  hdma2d: pointer to a DMA2D_HandleTypeDef structure that contains
    713            *                 the configuration information for the DMA2D.  
    714            * @retval HAL status
    715            */

   \                                 In section .text, align 2, keep-with-next
    716          void HAL_DMA2D_IRQHandler(DMA2D_HandleTypeDef *hdma2d)
    717          {    
   \                     HAL_DMA2D_IRQHandler: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
    718            /* Transfer Error Interrupt management ***************************************/
    719            if(__HAL_DMA2D_GET_FLAG(hdma2d, DMA2D_FLAG_TE) != RESET)
   \   00000004   0xF104 0x0538      ADD      R5,R4,#+56
   \   00000008   0x6820             LDR      R0,[R4, #+0]
   \   0000000A   0x6841             LDR      R1,[R0, #+4]
   \   0000000C   0x07C9             LSLS     R1,R1,#+31
   \   0000000E   0xD516             BPL.N    ??HAL_DMA2D_IRQHandler_0
    720            {
    721              if(__HAL_DMA2D_GET_IT_SOURCE(hdma2d, DMA2D_IT_TE) != RESET)
   \   00000010   0x6801             LDR      R1,[R0, #+0]
   \   00000012   0x05C9             LSLS     R1,R1,#+23
   \   00000014   0xD513             BPL.N    ??HAL_DMA2D_IRQHandler_0
    722              {
    723                /* Disable the transfer Error interrupt */
    724                __HAL_DMA2D_DISABLE_IT(hdma2d, DMA2D_IT_TE);  
   \   00000016   0x6801             LDR      R1,[R0, #+0]
   \   00000018   0xF421 0x7180      BIC      R1,R1,#0x100
   \   0000001C   0x6001             STR      R1,[R0, #+0]
    725          
    726                /* Update error code */
    727                hdma2d->ErrorCode |= HAL_DMA2D_ERROR_TE;
   \   0000001E   0x6868             LDR      R0,[R5, #+4]
   \   00000020   0xF040 0x0001      ORR      R0,R0,#0x1
   \   00000024   0x6068             STR      R0,[R5, #+4]
    728              
    729                /* Clear the transfer error flag */
    730                __HAL_DMA2D_CLEAR_FLAG(hdma2d, DMA2D_FLAG_TE);
   \   00000026   0x6821             LDR      R1,[R4, #+0]
   \   00000028   0x2001             MOVS     R0,#+1
   \   0000002A   0x6088             STR      R0,[R1, #+8]
    731          
    732                /* Change DMA2D state */
    733                hdma2d->State = HAL_DMA2D_STATE_ERROR;
   \   0000002C   0x2004             MOVS     R0,#+4
   \   0000002E   0x7068             STRB     R0,[R5, #+1]
    734          
    735                /* Process Unlocked */
    736                __HAL_UNLOCK(hdma2d);       
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0x7028             STRB     R0,[R5, #+0]
    737                
    738                if(hdma2d->XferErrorCallback != NULL)
   \   00000034   0x6961             LDR      R1,[R4, #+20]
   \   00000036   0x0008             MOVS     R0,R1
   \   00000038   0xBF1C             ITT      NE 
    739                {
    740                  /* Transfer error Callback */
    741                  hdma2d->XferErrorCallback(hdma2d);
   \   0000003A   0x4620             MOVNE    R0,R4
   \   0000003C   0x4788             BLXNE    R1
    742                }
    743              }
    744            }
    745            /* Configuration Error Interrupt management **********************************/
    746            if(__HAL_DMA2D_GET_FLAG(hdma2d, DMA2D_FLAG_CE) != RESET)
   \                     ??HAL_DMA2D_IRQHandler_0: (+1)
   \   0000003E   0x6820             LDR      R0,[R4, #+0]
   \   00000040   0x6841             LDR      R1,[R0, #+4]
   \   00000042   0x0689             LSLS     R1,R1,#+26
   \   00000044   0xD516             BPL.N    ??HAL_DMA2D_IRQHandler_1
    747            {
    748              if(__HAL_DMA2D_GET_IT_SOURCE(hdma2d, DMA2D_IT_CE) != RESET)
   \   00000046   0x6801             LDR      R1,[R0, #+0]
   \   00000048   0x0489             LSLS     R1,R1,#+18
   \   0000004A   0xD513             BPL.N    ??HAL_DMA2D_IRQHandler_1
    749              {
    750                /* Disable the Configuration Error interrupt */
    751                __HAL_DMA2D_DISABLE_IT(hdma2d, DMA2D_IT_CE);
   \   0000004C   0x6801             LDR      R1,[R0, #+0]
   \   0000004E   0xF421 0x5100      BIC      R1,R1,#0x2000
   \   00000052   0x6001             STR      R1,[R0, #+0]
    752            
    753                /* Clear the Configuration error flag */
    754                __HAL_DMA2D_CLEAR_FLAG(hdma2d, DMA2D_FLAG_CE);
   \   00000054   0x6821             LDR      R1,[R4, #+0]
   \   00000056   0x2020             MOVS     R0,#+32
   \   00000058   0x6088             STR      R0,[R1, #+8]
    755          
    756                /* Update error code */
    757                hdma2d->ErrorCode |= HAL_DMA2D_ERROR_CE;    
   \   0000005A   0x6868             LDR      R0,[R5, #+4]
   \   0000005C   0xF040 0x0002      ORR      R0,R0,#0x2
   \   00000060   0x6068             STR      R0,[R5, #+4]
    758              
    759                /* Change DMA2D state */
    760                hdma2d->State = HAL_DMA2D_STATE_ERROR;
   \   00000062   0x2004             MOVS     R0,#+4
   \   00000064   0x7068             STRB     R0,[R5, #+1]
    761          
    762                /* Process Unlocked */
    763                __HAL_UNLOCK(hdma2d);       
   \   00000066   0x2000             MOVS     R0,#+0
   \   00000068   0x7028             STRB     R0,[R5, #+0]
    764                
    765                if(hdma2d->XferErrorCallback != NULL)
   \   0000006A   0x6961             LDR      R1,[R4, #+20]
   \   0000006C   0x0008             MOVS     R0,R1
   \   0000006E   0xBF1C             ITT      NE 
    766                {
    767                  /* Transfer error Callback */
    768                  hdma2d->XferErrorCallback(hdma2d);
   \   00000070   0x4620             MOVNE    R0,R4
   \   00000072   0x4788             BLXNE    R1
    769                }
    770              }
    771            }
    772            /* Transfer Complete Interrupt management ************************************/
    773            if(__HAL_DMA2D_GET_FLAG(hdma2d, DMA2D_FLAG_TC) != RESET)
   \                     ??HAL_DMA2D_IRQHandler_1: (+1)
   \   00000074   0x6820             LDR      R0,[R4, #+0]
   \   00000076   0x6841             LDR      R1,[R0, #+4]
   \   00000078   0x0789             LSLS     R1,R1,#+30
   \   0000007A   0xD516             BPL.N    ??HAL_DMA2D_IRQHandler_2
    774            {
    775              if(__HAL_DMA2D_GET_IT_SOURCE(hdma2d, DMA2D_IT_TC) != RESET)
   \   0000007C   0x6801             LDR      R1,[R0, #+0]
   \   0000007E   0x0589             LSLS     R1,R1,#+22
   \   00000080   0xD513             BPL.N    ??HAL_DMA2D_IRQHandler_2
    776              { 
    777                /* Disable the transfer complete interrupt */
    778                __HAL_DMA2D_DISABLE_IT(hdma2d, DMA2D_IT_TC);
   \   00000082   0x6801             LDR      R1,[R0, #+0]
   \   00000084   0xF421 0x7100      BIC      R1,R1,#0x200
   \   00000088   0x6001             STR      R1,[R0, #+0]
    779            
    780                /* Clear the transfer complete flag */  
    781                __HAL_DMA2D_CLEAR_FLAG(hdma2d, DMA2D_FLAG_TC);
   \   0000008A   0x6821             LDR      R1,[R4, #+0]
   \   0000008C   0x2002             MOVS     R0,#+2
   \   0000008E   0x6088             STR      R0,[R1, #+8]
    782          
    783                /* Update error code */
    784                hdma2d->ErrorCode |= HAL_DMA2D_ERROR_NONE;    
   \   00000090   0x6868             LDR      R0,[R5, #+4]
   \   00000092   0x6068             STR      R0,[R5, #+4]
    785              
    786                /* Change DMA2D state */
    787                hdma2d->State = HAL_DMA2D_STATE_READY;
   \   00000094   0x2001             MOVS     R0,#+1
   \   00000096   0x7068             STRB     R0,[R5, #+1]
    788              
    789                /* Process Unlocked */
    790                __HAL_UNLOCK(hdma2d);       
   \   00000098   0x2000             MOVS     R0,#+0
   \   0000009A   0x7028             STRB     R0,[R5, #+0]
    791                
    792                if(hdma2d->XferCpltCallback != NULL)
   \   0000009C   0x6921             LDR      R1,[R4, #+16]
   \   0000009E   0x0008             MOVS     R0,R1
   \   000000A0   0xD003             BEQ.N    ??HAL_DMA2D_IRQHandler_2
    793                {
    794                  /* Transfer complete Callback */
    795                  hdma2d->XferCpltCallback(hdma2d);
   \   000000A2   0x4620             MOV      R0,R4
   \   000000A4   0xE8BD 0x4034      POP      {R2,R4,R5,LR}
   \   000000A8   0x4708             BX       R1
    796                }         
    797              }
    798            }
    799          } 
   \                     ??HAL_DMA2D_IRQHandler_2: (+1)
   \   000000AA   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    800          
    801          /**
    802            * @}
    803            */
    804          
    805          /** @defgroup DMA2D_Group3 Peripheral Control functions
    806           *  @brief    Peripheral Control functions 
    807           *
    808          @verbatim   
    809           ===============================================================================
    810                              ##### Peripheral Control functions #####
    811           ===============================================================================  
    812              [..]  This section provides functions allowing to:
    813                (+) Configure the DMA2D foreground or/and background parameters.
    814                (+) Configure the DMA2D CLUT transfer.
    815                (+) Enable DMA2D CLUT.
    816                (+) Disable DMA2D CLUT.
    817                (+) Configure the line watermark
    818          
    819          @endverbatim
    820            * @{
    821            */
    822          /**
    823            * @brief  Configure the DMA2D Layer according to the specified
    824            *         parameters in the DMA2D_InitTypeDef and create the associated handle.
    825            * @param  hdma2d: pointer to a DMA2D_HandleTypeDef structure that contains
    826            *                 the configuration information for the DMA2D.
    827            * @param  LayerIdx: DMA2D Layer index.
    828            *                   This parameter can be one of the following values:
    829            *                   0(background) / 1(foreground)
    830            * @retval HAL status
    831            */

   \                                 In section .text, align 2, keep-with-next
    832          HAL_StatusTypeDef HAL_DMA2D_ConfigLayer(DMA2D_HandleTypeDef *hdma2d, uint32_t LayerIdx)
    833          { 
    834            DMA2D_LayerCfgTypeDef *pLayerCfg = &hdma2d->LayerCfg[LayerIdx];
   \                     HAL_DMA2D_ConfigLayer: (+1)
   \   00000000   0xEB00 0x1201      ADD      R2,R0,R1, LSL #+4
   \   00000004   0xB570             PUSH     {R4-R6,LR}
   \   00000006   0xF102 0x0318      ADD      R3,R2,#+24
    835            
    836            uint32_t tmp = 0;
    837            
    838            /* Process locked */
    839            __HAL_LOCK(hdma2d);
   \   0000000A   0xF100 0x0238      ADD      R2,R0,#+56
   \   0000000E   0x7814             LDRB     R4,[R2, #+0]
   \   00000010   0x2C01             CMP      R4,#+1
   \   00000012   0xD101             BNE.N    ??HAL_DMA2D_ConfigLayer_0
   \   00000014   0x2002             MOVS     R0,#+2
   \   00000016   0xBD70             POP      {R4-R6,PC}
   \                     ??HAL_DMA2D_ConfigLayer_0: (+1)
   \   00000018   0x2401             MOVS     R4,#+1
    840            
    841            /* Change DMA2D peripheral state */
    842            hdma2d->State = HAL_DMA2D_STATE_BUSY; 
    843            
    844            /* Check the parameters */
    845            assert_param(IS_DMA2D_LAYER(LayerIdx));  
    846            assert_param(IS_DMA2D_OFFSET(pLayerCfg->InputOffset));  
    847            if(hdma2d->Init.Mode != DMA2D_R2M)
    848            {  
    849              assert_param(IS_DMA2D_INPUT_COLOR_MODE(pLayerCfg->InputColorMode));
    850              if(hdma2d->Init.Mode != DMA2D_M2M)
    851              {
    852                assert_param(IS_DMA2D_ALPHA_MODE(pLayerCfg->AlphaMode));
    853              }
    854            }
    855            
    856            /* Configure the background DMA2D layer */
    857            if(LayerIdx == 0)
   \   0000001A   0x....             LDR.N    R6,??DataTable2  ;; 0xfcfff0
   \   0000001C   0x7014             STRB     R4,[R2, #+0]
   \   0000001E   0x2402             MOVS     R4,#+2
   \   00000020   0x7054             STRB     R4,[R2, #+1]
   \   00000022   0x685D             LDR      R5,[R3, #+4]
   \   00000024   0x6804             LDR      R4,[R0, #+0]
   \   00000026   0xB9C9             CBNZ.N   R1,??HAL_DMA2D_ConfigLayer_1
    858            {
    859              /* DMA2D BGPFCR register configuration -----------------------------------*/
    860              /* Get the BGPFCCR register value */
    861              tmp = hdma2d->Instance->BGPFCCR;
   \   00000028   0x6A61             LDR      R1,[R4, #+36]
    862              
    863              /* Clear Input color mode, alpha value and alpha mode bits */
    864              tmp &= (uint32_t)~(DMA2D_BGPFCCR_CM | DMA2D_BGPFCCR_AM | DMA2D_BGPFCCR_ALPHA); 
   \   0000002A   0x4031             ANDS     R1,R6,R1
    865              
    866              if ((pLayerCfg->InputColorMode == CM_A4) || (pLayerCfg->InputColorMode == CM_A8))
   \   0000002C   0x2D0A             CMP      R5,#+10
   \   0000002E   0xBF18             IT       NE 
   \   00000030   0x2D09             CMPNE    R5,#+9
   \   00000032   0x.... 0x....      BL       ?Subroutine1
    867              {
    868                /* Prepare the value to be wrote to the BGPFCCR register */
    869                tmp |= (pLayerCfg->InputColorMode | (pLayerCfg->AlphaMode << 16) | ((pLayerCfg->InputAlpha) & 0xFF000000));
    870              }
    871              else
    872              {
    873                /* Prepare the value to be wrote to the BGPFCCR register */
    874                tmp |= (pLayerCfg->InputColorMode | (pLayerCfg->AlphaMode << 16) | (pLayerCfg->InputAlpha << 24));
    875              }
    876              
    877              /* Write to DMA2D BGPFCCR register */
    878              hdma2d->Instance->BGPFCCR = tmp; 
   \                     ??CrossCallReturnLabel_0: (+1)
   \   00000036   0x6261             STR      R1,[R4, #+36]
    879              
    880              /* DMA2D BGOR register configuration -------------------------------------*/  
    881              /* Get the BGOR register value */
    882              tmp = hdma2d->Instance->BGOR;
   \   00000038   0x6801             LDR      R1,[R0, #+0]
   \   0000003A   0x698C             LDR      R4,[R1, #+24]
    883              
    884              /* Clear colors bits */
    885              tmp &= (uint32_t)~DMA2D_BGOR_LO; 
    886              
    887              /* Prepare the value to be wrote to the BGOR register */
    888              tmp |= pLayerCfg->InputOffset;
    889              
    890              /* Write to DMA2D BGOR register */
    891              hdma2d->Instance->BGOR = tmp;
   \   0000003C   0x681D             LDR      R5,[R3, #+0]
   \   0000003E   0x0BA4             LSRS     R4,R4,#+14
   \   00000040   0xEA45 0x3484      ORR      R4,R5,R4, LSL #+14
   \   00000044   0x618C             STR      R4,[R1, #+24]
    892              
    893              if ((pLayerCfg->InputColorMode == CM_A4) || (pLayerCfg->InputColorMode == CM_A8))
   \   00000046   0x6859             LDR      R1,[R3, #+4]
   \   00000048   0x290A             CMP      R1,#+10
   \   0000004A   0xBF18             IT       NE 
   \   0000004C   0x2909             CMPNE    R1,#+9
   \   0000004E   0xD11E             BNE.N    ??HAL_DMA2D_ConfigLayer_2
    894              {
    895                /* Prepare the value to be wrote to the BGCOLR register */
    896                tmp = ((pLayerCfg->InputAlpha) & 0x00FFFFFF);
    897              
    898                /* Write to DMA2D BGCOLR register */
    899                hdma2d->Instance->BGCOLR = tmp;
   \   00000050   0x68D9             LDR      R1,[R3, #+12]
   \   00000052   0x6800             LDR      R0,[R0, #+0]
   \   00000054   0x0209             LSLS     R1,R1,#+8
   \   00000056   0x0A09             LSRS     R1,R1,#+8
   \   00000058   0x6281             STR      R1,[R0, #+40]
   \   0000005A   0xE018             B.N      ??HAL_DMA2D_ConfigLayer_2
    900              }    
    901            }
    902            /* Configure the foreground DMA2D layer */
    903            else
    904            {
    905              /* DMA2D FGPFCR register configuration -----------------------------------*/
    906              /* Get the FGPFCCR register value */
    907              tmp = hdma2d->Instance->FGPFCCR;
   \                     ??HAL_DMA2D_ConfigLayer_1: (+1)
   \   0000005C   0x69E1             LDR      R1,[R4, #+28]
    908              
    909              /* Clear Input color mode, alpha value and alpha mode bits */
    910              tmp &= (uint32_t)~(DMA2D_FGPFCCR_CM | DMA2D_FGPFCCR_AM | DMA2D_FGPFCCR_ALPHA); 
   \   0000005E   0x4031             ANDS     R1,R6,R1
    911              
    912              if ((pLayerCfg->InputColorMode == CM_A4) || (pLayerCfg->InputColorMode == CM_A8))
   \   00000060   0x2D0A             CMP      R5,#+10
   \   00000062   0xBF18             IT       NE 
   \   00000064   0x2D09             CMPNE    R5,#+9
   \   00000066   0x.... 0x....      BL       ?Subroutine1
    913              {
    914                /* Prepare the value to be wrote to the FGPFCCR register */
    915                tmp |= (pLayerCfg->InputColorMode | (pLayerCfg->AlphaMode << 16) | ((pLayerCfg->InputAlpha) & 0xFF000000));
    916              }
    917              else
    918              {
    919                /* Prepare the value to be wrote to the FGPFCCR register */
    920                tmp |= (pLayerCfg->InputColorMode | (pLayerCfg->AlphaMode << 16) | (pLayerCfg->InputAlpha << 24));
    921              }
    922              
    923              /* Write to DMA2D FGPFCCR register */
    924              hdma2d->Instance->FGPFCCR = tmp; 
   \                     ??CrossCallReturnLabel_1: (+1)
   \   0000006A   0x61E1             STR      R1,[R4, #+28]
    925              
    926              /* DMA2D FGOR register configuration -------------------------------------*/  
    927              /* Get the FGOR register value */
    928              tmp = hdma2d->Instance->FGOR;
   \   0000006C   0x6801             LDR      R1,[R0, #+0]
   \   0000006E   0x690C             LDR      R4,[R1, #+16]
    929              
    930              /* Clear colors bits */
    931              tmp &= (uint32_t)~DMA2D_FGOR_LO; 
    932              
    933              /* Prepare the value to be wrote to the FGOR register */
    934              tmp |= pLayerCfg->InputOffset;
    935              
    936              /* Write to DMA2D FGOR register */
    937              hdma2d->Instance->FGOR = tmp;
   \   00000070   0x681D             LDR      R5,[R3, #+0]
   \   00000072   0x0BA4             LSRS     R4,R4,#+14
   \   00000074   0xEA45 0x3484      ORR      R4,R5,R4, LSL #+14
   \   00000078   0x610C             STR      R4,[R1, #+16]
    938             
    939              if ((pLayerCfg->InputColorMode == CM_A4) || (pLayerCfg->InputColorMode == CM_A8))
   \   0000007A   0x6859             LDR      R1,[R3, #+4]
   \   0000007C   0x290A             CMP      R1,#+10
   \   0000007E   0xBF18             IT       NE 
   \   00000080   0x2909             CMPNE    R1,#+9
   \   00000082   0xD104             BNE.N    ??HAL_DMA2D_ConfigLayer_2
    940              {
    941                /* Prepare the value to be wrote to the FGCOLR register */
    942                tmp = ((pLayerCfg->InputAlpha) & 0x00FFFFFF);
    943              
    944                /* Write to DMA2D FGCOLR register */
    945                hdma2d->Instance->FGCOLR = tmp;
   \   00000084   0x68D9             LDR      R1,[R3, #+12]
   \   00000086   0x6800             LDR      R0,[R0, #+0]
   \   00000088   0x0209             LSLS     R1,R1,#+8
   \   0000008A   0x0A09             LSRS     R1,R1,#+8
   \   0000008C   0x6201             STR      R1,[R0, #+32]
    946              }   
    947            }    
    948            /* Initialize the DMA2D state*/
    949            hdma2d->State  = HAL_DMA2D_STATE_READY;
   \                     ??HAL_DMA2D_ConfigLayer_2: (+1)
   \   0000008E   0x2001             MOVS     R0,#+1
   \   00000090   0x7050             STRB     R0,[R2, #+1]
    950            
    951            /* Process unlocked */
    952            __HAL_UNLOCK(hdma2d);  
   \   00000092   0x2000             MOVS     R0,#+0
   \   00000094   0x7010             STRB     R0,[R2, #+0]
    953            
    954            return HAL_OK;
   \   00000096   0xBD70             POP      {R4-R6,PC}       ;; return
    955          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \   00000000   0xD107             BNE.N    ??Subroutine1_0
   \   00000002   0x689E             LDR      R6,[R3, #+8]
   \   00000004   0xEA45 0x4506      ORR      R5,R5,R6, LSL #+16
   \   00000008   0x68DE             LDR      R6,[R3, #+12]
   \   0000000A   0xF006 0x467F      AND      R6,R6,#0xFF000000
   \   0000000E   0x4335             ORRS     R5,R6,R5
   \   00000010   0xE005             B.N      ??Subroutine1_1
   \                     ??Subroutine1_0: (+1)
   \   00000012   0x689E             LDR      R6,[R3, #+8]
   \   00000014   0xEA45 0x4506      ORR      R5,R5,R6, LSL #+16
   \   00000018   0x68DE             LDR      R6,[R3, #+12]
   \   0000001A   0xEA45 0x6506      ORR      R5,R5,R6, LSL #+24
   \                     ??Subroutine1_1: (+1)
   \   0000001E   0x4329             ORRS     R1,R5,R1
   \   00000020   0x4770             BX       LR
    956          
    957          /**
    958            * @brief  Configure the DMA2D CLUT Transfer.
    959            * @param  hdma2d:   pointer to a DMA2D_HandleTypeDef structure that contains
    960            *                   the configuration information for the DMA2D.
    961            * @param  CLUTCfg:  pointer to a DMA2D_CLUTCfgTypeDef structure that contains
    962            *                   the configuration information for the color look up table.
    963            * @param  LayerIdx: DMA2D Layer index.
    964            *                   This parameter can be one of the following values:
    965            *                   0(background) / 1(foreground)
    966            * @retval HAL status
    967            */

   \                                 In section .text, align 2, keep-with-next
    968          HAL_StatusTypeDef HAL_DMA2D_ConfigCLUT(DMA2D_HandleTypeDef *hdma2d, DMA2D_CLUTCfgTypeDef CLUTCfg, uint32_t LayerIdx)
    969          {
   \                     HAL_DMA2D_ConfigCLUT: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
    970            uint32_t tmp = 0, tmp1 = 0;
    971          
    972            /* Check the parameters */
    973            assert_param(IS_DMA2D_LAYER(LayerIdx));   
    974            assert_param(IS_DMA2D_CLUT_CM(CLUTCfg.CLUTColorMode));
    975            assert_param(IS_DMA2D_CLUT_SIZE(CLUTCfg.Size));
    976            
    977            /* Configure the CLUT of the background DMA2D layer */
    978            if(LayerIdx == 0)
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x....             LDR.N    R4,??DataTable2_1  ;; 0xffff00ef
   \   00000006   0x9D03             LDR      R5,[SP, #+12]
   \   00000008   0xB945             CBNZ.N   R5,??HAL_DMA2D_ConfigCLUT_0
    979            {
    980              /* Get the BGCMAR register value */
    981              tmp = hdma2d->Instance->BGCMAR;
   \   0000000A   0x6B05             LDR      R5,[R0, #+48]
    982          
    983              /* Clear CLUT address bits */
    984              tmp &= (uint32_t)~DMA2D_BGCMAR_MA; 
    985            
    986              /* Prepare the value to be wrote to the BGCMAR register */
    987              tmp |= (uint32_t)CLUTCfg.pCLUT;
    988            
    989              /* Write to DMA2D BGCMAR register */
    990              hdma2d->Instance->BGCMAR = tmp;
   \   0000000C   0x6301             STR      R1,[R0, #+48]
    991              
    992              /* Get the BGPFCCR register value */
    993              tmp = hdma2d->Instance->BGPFCCR;
   \   0000000E   0x6A41             LDR      R1,[R0, #+36]
    994          
    995              /* Clear CLUT size and CLUT address bits */
    996              tmp &= (uint32_t)~(DMA2D_BGPFCCR_CS | DMA2D_BGPFCCR_CCM); 
    997          
    998              /* Get the CLUT size */
    999              tmp1 = CLUTCfg.Size << 16;
   1000              
   1001              /* Prepare the value to be wrote to the BGPFCCR register */
   1002              tmp |= (CLUTCfg.CLUTColorMode | tmp1);
   1003            
   1004              /* Write to DMA2D BGPFCCR register */
   1005              hdma2d->Instance->BGPFCCR = tmp;       
   \   00000010   0x4021             ANDS     R1,R4,R1
   \   00000012   0x4311             ORRS     R1,R2,R1
   \   00000014   0xEA41 0x4103      ORR      R1,R1,R3, LSL #+16
   \   00000018   0x6241             STR      R1,[R0, #+36]
   \   0000001A   0xE007             B.N      ??HAL_DMA2D_ConfigCLUT_1
   1006            }
   1007            /* Configure the CLUT of the foreground DMA2D layer */
   1008            else
   1009            {
   1010              /* Get the FGCMAR register value */
   1011              tmp = hdma2d->Instance->FGCMAR;
   \                     ??HAL_DMA2D_ConfigCLUT_0: (+1)
   \   0000001C   0x6AC5             LDR      R5,[R0, #+44]
   1012          
   1013              /* Clear CLUT address bits */
   1014              tmp &= (uint32_t)~DMA2D_FGCMAR_MA; 
   1015            
   1016              /* Prepare the value to be wrote to the FGCMAR register */
   1017              tmp |= (uint32_t)CLUTCfg.pCLUT;
   1018            
   1019              /* Write to DMA2D FGCMAR register */
   1020              hdma2d->Instance->FGCMAR = tmp;
   \   0000001E   0x62C1             STR      R1,[R0, #+44]
   1021              
   1022              /* Get the FGPFCCR register value */
   1023              tmp = hdma2d->Instance->FGPFCCR;
   \   00000020   0x69C1             LDR      R1,[R0, #+28]
   1024          
   1025              /* Clear CLUT size and CLUT address bits */
   1026              tmp &= (uint32_t)~(DMA2D_FGPFCCR_CS | DMA2D_FGPFCCR_CCM); 
   1027          
   1028              /* Get the CLUT size */
   1029              tmp1 = CLUTCfg.Size << 8;
   1030              
   1031              /* Prepare the value to be wrote to the FGPFCCR register */
   1032              tmp |= (CLUTCfg.CLUTColorMode | tmp1);
   1033            
   1034              /* Write to DMA2D FGPFCCR register */
   1035              hdma2d->Instance->FGPFCCR = tmp;    
   \   00000022   0x4021             ANDS     R1,R4,R1
   \   00000024   0x4311             ORRS     R1,R2,R1
   \   00000026   0xEA41 0x2103      ORR      R1,R1,R3, LSL #+8
   \   0000002A   0x61C1             STR      R1,[R0, #+28]
   1036            }
   1037            
   1038            return HAL_OK;
   \                     ??HAL_DMA2D_ConfigCLUT_1: (+1)
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0xBD30             POP      {R4,R5,PC}       ;; return
   1039          }
   1040          
   1041          /**
   1042            * @brief  Enable the DMA2D CLUT Transfer.
   1043            * @param  hdma2d:   pointer to a DMA2D_HandleTypeDef structure that contains
   1044            *                   the configuration information for the DMA2D.
   1045            * @param  LayerIdx: DMA2D Layer index.
   1046            *                   This parameter can be one of the following values:
   1047            *                   0(background) / 1(foreground)
   1048            * @retval HAL status
   1049            */

   \                                 In section .text, align 2, keep-with-next
   1050          HAL_StatusTypeDef HAL_DMA2D_EnableCLUT(DMA2D_HandleTypeDef *hdma2d, uint32_t LayerIdx)
   1051          {  
   1052            /* Check the parameters */
   1053            assert_param(IS_DMA2D_LAYER(LayerIdx));
   1054            
   1055            if(LayerIdx == 0)
   \                     HAL_DMA2D_EnableCLUT: (+1)
   \   00000000   0x6800             LDR      R0,[R0, #+0]
   \   00000002   0xB921             CBNZ.N   R1,??HAL_DMA2D_EnableCLUT_0
   1056            {
   1057              /* Enable the CLUT loading for the background */
   1058              hdma2d->Instance->BGPFCCR |= DMA2D_BGPFCCR_START;
   \   00000004   0x6A41             LDR      R1,[R0, #+36]
   \   00000006   0xF041 0x0120      ORR      R1,R1,#0x20
   \   0000000A   0x6241             STR      R1,[R0, #+36]
   \   0000000C   0xE003             B.N      ??HAL_DMA2D_EnableCLUT_1
   1059            }
   1060            else
   1061            {
   1062              /* Enable the CLUT loading for the foreground */
   1063              hdma2d->Instance->FGPFCCR |= DMA2D_FGPFCCR_START;
   \                     ??HAL_DMA2D_EnableCLUT_0: (+1)
   \   0000000E   0x69C1             LDR      R1,[R0, #+28]
   \   00000010   0xF041 0x0120      ORR      R1,R1,#0x20
   \   00000014   0x61C1             STR      R1,[R0, #+28]
   1064            }
   1065            
   1066            return HAL_OK;
   \                     ??HAL_DMA2D_EnableCLUT_1: (+1)
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0x4770             BX       LR               ;; return
   1067          }
   1068          
   1069          /**
   1070            * @brief  Disable the DMA2D CLUT Transfer.
   1071            * @param  hdma2d:   pointer to a DMA2D_HandleTypeDef structure that contains
   1072            *                   the configuration information for the DMA2D.
   1073            * @param  LayerIdx: DMA2D Layer index.
   1074            *                   This parameter can be one of the following values:
   1075            *                   0(background) / 1(foreground)
   1076            * @retval HAL status
   1077            */

   \                                 In section .text, align 2, keep-with-next
   1078          HAL_StatusTypeDef HAL_DMA2D_DisableCLUT(DMA2D_HandleTypeDef *hdma2d, uint32_t LayerIdx)
   1079          {
   1080            /* Check the parameters */
   1081            assert_param(IS_DMA2D_LAYER(LayerIdx));
   1082            
   1083            if(LayerIdx == 0)
   \                     HAL_DMA2D_DisableCLUT: (+1)
   \   00000000   0x6800             LDR      R0,[R0, #+0]
   \   00000002   0xB921             CBNZ.N   R1,??HAL_DMA2D_DisableCLUT_0
   1084            {
   1085              /* Disable the CLUT loading for the background */
   1086              hdma2d->Instance->BGPFCCR &= ~DMA2D_BGPFCCR_START;
   \   00000004   0x6A41             LDR      R1,[R0, #+36]
   \   00000006   0xF021 0x0120      BIC      R1,R1,#0x20
   \   0000000A   0x6241             STR      R1,[R0, #+36]
   \   0000000C   0xE003             B.N      ??HAL_DMA2D_DisableCLUT_1
   1087            }
   1088            else
   1089            {
   1090              /* Disable the CLUT loading for the foreground */
   1091              hdma2d->Instance->FGPFCCR &= ~DMA2D_FGPFCCR_START;
   \                     ??HAL_DMA2D_DisableCLUT_0: (+1)
   \   0000000E   0x69C1             LDR      R1,[R0, #+28]
   \   00000010   0xF021 0x0120      BIC      R1,R1,#0x20
   \   00000014   0x61C1             STR      R1,[R0, #+28]
   1092            } 
   1093            
   1094            return HAL_OK;
   \                     ??HAL_DMA2D_DisableCLUT_1: (+1)
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0x4770             BX       LR               ;; return
   1095          }
   1096          
   1097          /**
   1098            * @brief  Define the configuration of the line watermark .
   1099            * @param  hdma2d: pointer to a DMA2D_HandleTypeDef structure that contains
   1100            *                 the configuration information for the DMA2D.
   1101            * @param  Line:   Line Watermark configuration.
   1102            * @retval HAL status
   1103            */
   1104          

   \                                 In section .text, align 2, keep-with-next
   1105          HAL_StatusTypeDef HAL_DMA2D_ProgramLineEvent(DMA2D_HandleTypeDef *hdma2d, uint32_t Line)
   1106          {
   1107            /* Process locked */
   1108            __HAL_LOCK(hdma2d);
   \                     HAL_DMA2D_ProgramLineEvent: (+1)
   \   00000000   0xF810 0x2F38      LDRB     R2,[R0, #+56]!
   \   00000004   0x2A01             CMP      R2,#+1
   \   00000006   0xD101             BNE.N    ??HAL_DMA2D_ProgramLineEvent_0
   \   00000008   0x2002             MOVS     R0,#+2
   \   0000000A   0x4770             BX       LR
   \                     ??HAL_DMA2D_ProgramLineEvent_0: (+1)
   \   0000000C   0x2201             MOVS     R2,#+1
   \   0000000E   0x7002             STRB     R2,[R0, #+0]
   1109            
   1110            /* Change DMA2D peripheral state */
   1111            hdma2d->State = HAL_DMA2D_STATE_BUSY;
   \   00000010   0x2202             MOVS     R2,#+2
   \   00000012   0x7042             STRB     R2,[R0, #+1]
   1112            
   1113            /* Check the parameters */
   1114            assert_param(IS_DMA2D_LineWatermark(Line));
   1115          
   1116            /* Sets the Line watermark configuration */
   1117            DMA2D->LWR = (uint32_t)Line;
   \   00000014   0x....             LDR.N    R2,??DataTable2_2  ;; 0x4002b048
   \   00000016   0x6011             STR      R1,[R2, #+0]
   1118            
   1119            /* Initialize the DMA2D state*/
   1120            hdma2d->State = HAL_DMA2D_STATE_READY;
   \   00000018   0x2101             MOVS     R1,#+1
   \   0000001A   0x7041             STRB     R1,[R0, #+1]
   1121            
   1122            /* Process unlocked */
   1123            __HAL_UNLOCK(hdma2d);  
   \   0000001C   0x2100             MOVS     R1,#+0
   \   0000001E   0x7001             STRB     R1,[R0, #+0]
   1124            
   1125            return HAL_OK;  
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0x4770             BX       LR               ;; return
   1126          }
   1127          
   1128          /**
   1129            * @}
   1130            */
   1131          
   1132          /** @defgroup DMA2D_Group4 Peripheral State functions
   1133           *  @brief    Peripheral State functions 
   1134           *
   1135          @verbatim   
   1136           ===============================================================================
   1137                            ##### Peripheral State and Errors functions #####
   1138           ===============================================================================  
   1139              [..]
   1140              This subsection provides functions allowing to :
   1141                (+) Check the DMA2D state
   1142                (+) Get error code  
   1143          
   1144          @endverbatim
   1145            * @{
   1146            */ 
   1147          
   1148          /**
   1149            * @brief  Return the DMA2D state
   1150            * @param  hdma2d: pointer to a DMA2D_HandleTypeDef structure that contains
   1151            *                 the configuration information for the DMA2D.  
   1152            * @retval HAL state
   1153            */

   \                                 In section .text, align 2, keep-with-next
   1154          HAL_DMA2D_StateTypeDef HAL_DMA2D_GetState(DMA2D_HandleTypeDef *hdma2d)
   1155          {  
   1156            return hdma2d->State;
   \                     HAL_DMA2D_GetState: (+1)
   \   00000000   0xF890 0x0039      LDRB     R0,[R0, #+57]
   \   00000004   0x4770             BX       LR               ;; return
   1157          }
   1158          
   1159          /**
   1160            * @brief  Return the DMA2D error code
   1161            * @param  hdma2d : pointer to a DMA2D_HandleTypeDef structure that contains
   1162            *               the configuration information for DMA2D.
   1163            * @retval DMA2D Error Code
   1164            */

   \                                 In section .text, align 2, keep-with-next
   1165          uint32_t HAL_DMA2D_GetError(DMA2D_HandleTypeDef *hdma2d)
   1166          {
   1167            return hdma2d->ErrorCode;
   \                     HAL_DMA2D_GetError: (+1)
   \   00000000   0x6BC0             LDR      R0,[R0, #+60]
   \   00000002   0x4770             BX       LR               ;; return
   1168          }
   1169          
   1170          /**
   1171            * @}
   1172            */
   1173          
   1174          
   1175          /**
   1176            * @brief  Set the DMA2D Transfer parameter.
   1177            * @param  hdma2d:     pointer to a DMA2D_HandleTypeDef structure that contains
   1178            *                     the configuration information for the specified DMA2D.  
   1179            * @param  pdata:      The source memory Buffer address
   1180            * @param  DstAddress: The destination memory Buffer address
   1181            * @param  Width:      The width of data to be transferred from source to destination.
   1182            * @param  Height:     The height of data to be transferred from source to destination.
   1183            * @retval HAL status
   1184            */

   \                                 In section .text, align 2, keep-with-next
   1185          static void DMA2D_SetConfig(DMA2D_HandleTypeDef *hdma2d, uint32_t pdata, uint32_t DstAddress, uint32_t Width, uint32_t Height)
   1186          {  
   \                     DMA2D_SetConfig: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   1187            uint32_t tmp = 0;
   1188            uint32_t tmp1 = 0;
   1189            uint32_t tmp2 = 0;
   1190            uint32_t tmp3 = 0;
   1191            uint32_t tmp4 = 0;
   1192            
   1193            tmp = Width << 16;
   1194            
   1195            /* Configure DMA2D data size */
   1196            hdma2d->Instance->NLR = (Height | tmp);
   \   00000002   0x6804             LDR      R4,[R0, #+0]
   \   00000004   0x9D05             LDR      R5,[SP, #+20]
   \   00000006   0xEA45 0x4303      ORR      R3,R5,R3, LSL #+16
   \   0000000A   0x6463             STR      R3,[R4, #+68]
   1197            
   1198            /* Configure DMA2D destination address */
   1199            hdma2d->Instance->OMAR = DstAddress;
   \   0000000C   0x63E2             STR      R2,[R4, #+60]
   1200           
   1201            /* Register to memory DMA2D mode selected */
   1202            if (hdma2d->Init.Mode == DMA2D_R2M)
   \   0000000E   0x6842             LDR      R2,[R0, #+4]
   \   00000010   0xF5B2 0x3F40      CMP      R2,#+196608
   \   00000014   0xD133             BNE.N    ??DMA2D_SetConfig_0
   1203            {    
   1204              tmp1 = pdata & DMA2D_OCOLR_ALPHA_1;
   1205              tmp2 = pdata & DMA2D_OCOLR_RED_1;
   1206              tmp3 = pdata & DMA2D_OCOLR_GREEN_1;
   1207              tmp4 = pdata & DMA2D_OCOLR_BLUE_1;
   1208              
   1209              /* Prepare the value to be wrote to the OCOLR register according to the color mode */
   1210              if (hdma2d->Init.ColorMode == DMA2D_ARGB8888)
   \   00000016   0x6887             LDR      R7,[R0, #+8]
   \   00000018   0xF001 0x427F      AND      R2,R1,#0xFF000000
   \   0000001C   0xF401 0x037F      AND      R3,R1,#0xFF0000
   \   00000020   0xF401 0x457F      AND      R5,R1,#0xFF00
   \   00000024   0xB2C9             UXTB     R1,R1
   \   00000026   0xEA43 0x0605      ORR      R6,R3,R5
   \   0000002A   0xB91F             CBNZ.N   R7,??DMA2D_SetConfig_1
   1211              {
   1212                tmp = (tmp3 | tmp2 | tmp1| tmp4);
   \   0000002C   0xEA42 0x0006      ORR      R0,R2,R6
   \   00000030   0x4308             ORRS     R0,R1,R0
   \   00000032   0xE022             B.N      ??DMA2D_SetConfig_2
   1213              }
   1214              else if (hdma2d->Init.ColorMode == DMA2D_RGB888)
   \                     ??DMA2D_SetConfig_1: (+1)
   \   00000034   0x2F01             CMP      R7,#+1
   \   00000036   0xBF08             IT       EQ 
   \   00000038   0xEA41 0x0006      ORREQ    R0,R1,R6
   1215              {
   1216                tmp = (tmp3 | tmp2 | tmp4);  
   \   0000003C   0xD01D             BEQ.N    ??DMA2D_SetConfig_2
   1217              }
   1218              else if (hdma2d->Init.ColorMode == DMA2D_RGB565)
   \   0000003E   0x08C8             LSRS     R0,R1,#+3
   \   00000040   0x0CDE             LSRS     R6,R3,#+19
   \   00000042   0x2F02             CMP      R7,#+2
   \   00000044   0xD104             BNE.N    ??DMA2D_SetConfig_3
   1219              {
   1220                tmp2 = (tmp2 >> 19);
   1221                tmp3 = (tmp3 >> 10);
   1222                tmp4 = (tmp4 >> 3 );
   1223                tmp  = ((tmp3 << 5) | (tmp2 << 11) | tmp4); 
   \   00000046   0x0AA9             LSRS     R1,R5,#+10
   \   00000048   0x02F2             LSLS     R2,R6,#+11
   \   0000004A   0xEA42 0x1141      ORR      R1,R2,R1, LSL #+5
   \   0000004E   0xE008             B.N      ??DMA2D_SetConfig_4
   1224              }
   1225              else if (hdma2d->Init.ColorMode == DMA2D_ARGB1555)
   \                     ??DMA2D_SetConfig_3: (+1)
   \   00000050   0x2F03             CMP      R7,#+3
   \   00000052   0xD108             BNE.N    ??DMA2D_SetConfig_5
   1226              { 
   1227                tmp1 = (tmp1 >> 31);
   1228                tmp2 = (tmp2 >> 19);
   1229                tmp3 = (tmp3 >> 11);
   1230                tmp4 = (tmp4 >> 3 );      
   1231                tmp  = ((tmp3 << 5) | (tmp2 << 10) | (tmp1 << 15) | tmp4);    
   \   00000054   0x0AE9             LSRS     R1,R5,#+11
   \   00000056   0x02B3             LSLS     R3,R6,#+10
   \   00000058   0xEA43 0x1141      ORR      R1,R3,R1, LSL #+5
   \   0000005C   0x0FD2             LSRS     R2,R2,#+31
   \   0000005E   0xEA41 0x31C2      ORR      R1,R1,R2, LSL #+15
   \                     ??DMA2D_SetConfig_4: (+1)
   \   00000062   0x4308             ORRS     R0,R0,R1
   \   00000064   0xE009             B.N      ??DMA2D_SetConfig_2
   1232              } 
   1233              else /* DMA2D_CMode = DMA2D_ARGB4444 */
   1234              {
   1235                tmp1 = (tmp1 >> 28);
   1236                tmp2 = (tmp2 >> 20);
   1237                tmp3 = (tmp3 >> 12);
   1238                tmp4 = (tmp4 >> 4 );
   1239                tmp  = ((tmp3 << 4) | (tmp2 << 8) | (tmp1 << 12) | tmp4);
   \                     ??DMA2D_SetConfig_5: (+1)
   \   00000066   0x0D1B             LSRS     R3,R3,#+20
   \   00000068   0x0B28             LSRS     R0,R5,#+12
   \   0000006A   0x021B             LSLS     R3,R3,#+8
   \   0000006C   0x0F12             LSRS     R2,R2,#+28
   \   0000006E   0xEA43 0x1000      ORR      R0,R3,R0, LSL #+4
   \   00000072   0xEA40 0x3002      ORR      R0,R0,R2, LSL #+12
   \   00000076   0xEA40 0x1011      ORR      R0,R0,R1, LSR #+4
   1240              }    
   1241              /* Write to DMA2D OCOLR register */
   1242              hdma2d->Instance->OCOLR = tmp;
   \                     ??DMA2D_SetConfig_2: (+1)
   \   0000007A   0x63A0             STR      R0,[R4, #+56]
   \   0000007C   0xBDF0             POP      {R4-R7,PC}
   1243            } 
   1244            else /* M2M, M2M_PFC or M2M_Blending DMA2D Mode */
   1245            {
   1246              /* Configure DMA2D source address */
   1247              hdma2d->Instance->FGMAR = pdata;
   \                     ??DMA2D_SetConfig_0: (+1)
   \   0000007E   0x60E1             STR      R1,[R4, #+12]
   1248            }
   1249          }
   \   00000080   0xBDF0             POP      {R4-R7,PC}       ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2:
   \   00000000   0x00FCFFF0         DC32     0xfcfff0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_1:
   \   00000000   0xFFFF00EF         DC32     0xffff00ef

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_2:
   \   00000000   0x4002B048         DC32     0x4002b048
   1250          
   1251          /**
   1252            * @}
   1253            */
   1254          #endif /* HAL_DMA2D_MODULE_ENABLED */
   1255          /**
   1256            * @}
   1257            */
   1258          
   1259          /**
   1260            * @}
   1261            */
   1262          
   1263          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      20   DMA2D_SetConfig
      16   HAL_DMA2D_Abort
        16   -> HAL_GetTick
      16   HAL_DMA2D_BlendingStart
        16   -> DMA2D_SetConfig
      16   HAL_DMA2D_BlendingStart_IT
        16   -> DMA2D_SetConfig
      12   HAL_DMA2D_ConfigCLUT
      16   HAL_DMA2D_ConfigLayer
       8   HAL_DMA2D_DeInit
         8   -> HAL_DMA2D_MspDeInit
       0   HAL_DMA2D_DisableCLUT
       0   HAL_DMA2D_EnableCLUT
       0   HAL_DMA2D_GetError
       0   HAL_DMA2D_GetState
      16   HAL_DMA2D_IRQHandler
         0   -- Indirect call
        16   -- Indirect call
      16   HAL_DMA2D_Init
        16   -> HAL_DMA2D_MspInit
       0   HAL_DMA2D_MspDeInit
       0   HAL_DMA2D_MspInit
      24   HAL_DMA2D_PollForTransfer
        24   -> HAL_GetTick
       0   HAL_DMA2D_ProgramLineEvent
       0   HAL_DMA2D_Resume
      16   HAL_DMA2D_Start
        16   -> DMA2D_SetConfig
      16   HAL_DMA2D_Start_IT
        16   -> DMA2D_SetConfig
      16   HAL_DMA2D_Suspend
        16   -> HAL_GetTick


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable2
       4  ??DataTable2_1
       4  ??DataTable2_2
       6  ??Subroutine8_0
      12  ?Subroutine0
      34  ?Subroutine1
      22  ?Subroutine2
      22  ?Subroutine3
      28  ?Subroutine4
      16  ?Subroutine5
       6  ?Subroutine6
      12  ?Subroutine7
     130  DMA2D_SetConfig
      80  HAL_DMA2D_Abort
      16  HAL_DMA2D_BlendingStart
      36  HAL_DMA2D_BlendingStart_IT
      48  HAL_DMA2D_ConfigCLUT
     152  HAL_DMA2D_ConfigLayer
      30  HAL_DMA2D_DeInit
      26  HAL_DMA2D_DisableCLUT
      26  HAL_DMA2D_EnableCLUT
       4  HAL_DMA2D_GetError
       6  HAL_DMA2D_GetState
     172  HAL_DMA2D_IRQHandler
      84  HAL_DMA2D_Init
       2  HAL_DMA2D_MspDeInit
       2  HAL_DMA2D_MspInit
     182  HAL_DMA2D_PollForTransfer
      36  HAL_DMA2D_ProgramLineEvent
      20  HAL_DMA2D_Resume
      18  HAL_DMA2D_Start
      44  HAL_DMA2D_Start_IT
      66  HAL_DMA2D_Suspend

 
 1 350 bytes in section .text
 
 1 350 bytes of CODE memory

Errors: none
Warnings: none
