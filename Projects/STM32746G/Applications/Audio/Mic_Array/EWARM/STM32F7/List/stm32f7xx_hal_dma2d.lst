###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.2.10312/W32 for ARM       27/Apr/2016  12:04:27
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_dma2d.c
#    Command line =  
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_dma2d.c
#        -D USE_HAL_DRIVER -D STM32F746xx -D USE_STM32746G_DISCO -D
#        USE_IOEXPANDER -D USE_USB_FS -lC
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
#        -lA
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
#        -o
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj
#        --no_unroll --debug --endian=little --cpu=Cortex-M7 -e --fpu=VFPv5_sp
#        --dlib_config "D:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Full.h" -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\CMSIS\Device\ST\STM32F7xx\Include\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\STM32F7xx_HAL_Driver\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\STM32746G-Discovery\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\Components\Common\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Log\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Fonts\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\CPU\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_Device_Library\Core\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Core\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Class\MSC\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\drivers\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_Audio\Addons\PDM\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_Device_Library\Class\AUDIO\Inc\
#        -Ohs --use_c++_inline --require_prototypes -I "D:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.3\arm\CMSIS\Include\" -D
#        ARM_MATH_CM7 --relaxed_fp
#    List file    =  
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List\stm32f7xx_hal_dma2d.lst
#    Object file  =  
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj\stm32f7xx_hal_dma2d.o
#
###############################################################################

D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_dma2d.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f7xx_hal_dma2d.c
      4            * @author  MCD Application Team
      5            * @version V1.0.4
      6            * @date    09-December-2015
      7            * @brief   DMA2D HAL module driver.
      8            *          This file provides firmware functions to manage the following 
      9            *          functionalities of the DMA2D peripheral:
     10            *           + Initialization and de-initialization functions
     11            *           + IO operation functions
     12            *           + Peripheral Control functions 
     13            *           + Peripheral State and Errors functions
     14            *
     15            @verbatim
     16            ==============================================================================
     17                                  ##### How to use this driver #####
     18            ==============================================================================
     19              [..]
     20                (#) Program the required configuration through following parameters:   
     21                    the Transfer Mode, the output color mode and the output offset using 
     22                    HAL_DMA2D_Init() function.
     23          
     24                (#) Program the required configuration through following parameters:   
     25                    the input color mode, the input color, input alpha value, alpha mode 
     26                    and the input offset using HAL_DMA2D_ConfigLayer() function for foreground
     27                    or/and background layer.
     28                    
     29               *** Polling mode IO operation ***
     30               =================================   
     31              [..]        
     32                 (+) Configure the pdata, Destination and data length and Enable 
     33                     the transfer using HAL_DMA2D_Start() 
     34                 (+) Wait for end of transfer using HAL_DMA2D_PollForTransfer(), at this stage
     35                     user can specify the value of timeout according to his end application.
     36                         
     37               *** Interrupt mode IO operation ***    
     38               ===================================
     39               [..] 
     40                 (#) Configure the pdata, Destination and data length and Enable 
     41                     the transfer using HAL_DMA2D_Start_IT() 
     42                 (#) Use HAL_DMA2D_IRQHandler() called under DMA2D_IRQHandler() Interrupt subroutine
     43                 (#) At the end of data transfer HAL_DMA2D_IRQHandler() function is executed and user can 
     44                     add his own function by customization of function pointer XferCpltCallback and 
     45                     XferErrorCallback (i.e a member of DMA2D handle structure). 
     46          
     47                   -@-   In Register-to-Memory transfer mode, the pdata parameter is the register
     48                         color, in Memory-to-memory or memory-to-memory with pixel format
     49                         conversion the pdata is the source address.
     50          
     51                   -@-   Configure the foreground source address, the background source address, 
     52                         the Destination and data length and Enable the transfer using 
     53                         HAL_DMA2D_BlendingStart() in polling mode and HAL_DMA2D_BlendingStart_IT()
     54                         in interrupt mode.
     55                         
     56                   -@-   HAL_DMA2D_BlendingStart() and HAL_DMA2D_BlendingStart_IT() functions
     57                         are used if the memory to memory with blending transfer mode is selected.
     58                             
     59                (#) Optionally, configure and enable the CLUT using HAL_DMA2D_ConfigCLUT()
     60                    HAL_DMA2D_EnableCLUT() functions.
     61          
     62                (#) Optionally, configure and enable LineInterrupt using the following function:
     63                    HAL_DMA2D_ProgramLineEvent().
     64             
     65                (#) The transfer can be suspended, continued and aborted using the following
     66                    functions: HAL_DMA2D_Suspend(), HAL_DMA2D_Resume(), HAL_DMA2D_Abort().
     67                               
     68                (#) To control DMA2D state you can use the following function: HAL_DMA2D_GetState()                   
     69          
     70               *** DMA2D HAL driver macros list ***
     71               ============================================= 
     72               [..]
     73                 Below the list of most used macros in DMA2D HAL driver :
     74                 
     75                (+) __HAL_DMA2D_ENABLE: Enable the DMA2D peripheral.
     76                (+) __HAL_DMA2D_DISABLE: Disable the DMA2D peripheral.
     77                (+) __HAL_DMA2D_GET_FLAG: Get the DMA2D pending flags.
     78                (+) __HAL_DMA2D_CLEAR_FLAG: Clear the DMA2D pending flags.
     79                (+) __HAL_DMA2D_ENABLE_IT: Enable the specified DMA2D interrupts.
     80                (+) __HAL_DMA2D_DISABLE_IT: Disable the specified DMA2D interrupts.
     81                (+) __HAL_DMA2D_GET_IT_SOURCE: Check whether the specified DMA2D interrupt has occurred or not.
     82               
     83               [..] 
     84                (@) You can refer to the DMA2D HAL driver header file for more useful macros
     85                                            
     86            @endverbatim
     87            ******************************************************************************
     88            * @attention
     89            *
     90            * <h2><center>&copy; COPYRIGHT(c) 2015 STMicroelectronics</center></h2>
     91            *
     92            * Redistribution and use in source and binary forms, with or without modification,
     93            * are permitted provided that the following conditions are met:
     94            *   1. Redistributions of source code must retain the above copyright notice,
     95            *      this list of conditions and the following disclaimer.
     96            *   2. Redistributions in binary form must reproduce the above copyright notice,
     97            *      this list of conditions and the following disclaimer in the documentation
     98            *      and/or other materials provided with the distribution.
     99            *   3. Neither the name of STMicroelectronics nor the names of its contributors
    100            *      may be used to endorse or promote products derived from this software
    101            *      without specific prior written permission.
    102            *
    103            * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
    104            * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
    105            * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
    106            * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
    107            * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
    108            * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
    109            * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
    110            * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
    111            * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
    112            * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
    113            *
    114            ******************************************************************************
    115            */ 
    116          
    117          /* Includes ------------------------------------------------------------------*/
    118          #include "stm32f7xx_hal.h"
    119          
    120          /** @addtogroup STM32F7xx_HAL_Driver
    121            * @{
    122            */
    123          /** @addtogroup DMA2D
    124            * @brief DMA2D HAL module driver
    125            * @{
    126            */
    127          
    128          #ifdef HAL_DMA2D_MODULE_ENABLED
    129          
    130          /* Private types -------------------------------------------------------------*/
    131          /* Private define ------------------------------------------------------------*/
    132          /** @addtogroup DMA2D_Private_Defines
    133            * @{
    134            */
    135          #define HAL_TIMEOUT_DMA2D_ABORT      ((uint32_t)1000)  /* 1s  */
    136          #define HAL_TIMEOUT_DMA2D_SUSPEND    ((uint32_t)1000)  /* 1s  */
    137          /**
    138            * @}
    139            */
    140          
    141          /* Private variables ---------------------------------------------------------*/
    142          /* Private constants ---------------------------------------------------------*/
    143          /* Private macro -------------------------------------------------------------*/
    144          /* Private function prototypes -----------------------------------------------*/
    145          /** @addtogroup DMA2D_Private_Functions_Prototypes
    146            * @{
    147            */
    148          static void DMA2D_SetConfig(DMA2D_HandleTypeDef *hdma2d, uint32_t pdata, uint32_t DstAddress, uint32_t Width, uint32_t Height);
    149          /**
    150            * @}
    151            */
    152          
    153          /* Private functions ---------------------------------------------------------*/
    154          /* Exported functions --------------------------------------------------------*/
    155          /** @addtogroup DMA2D_Exported_Functions
    156            * @{
    157            */
    158          
    159          /** @defgroup DMA2D_Group1 Initialization and Configuration functions
    160           *  @brief   Initialization and Configuration functions
    161           *
    162          @verbatim   
    163           ===============================================================================
    164                          ##### Initialization and Configuration functions #####
    165           ===============================================================================  
    166              [..]  This section provides functions allowing to:
    167                (+) Initialize and configure the DMA2D
    168                (+) De-initialize the DMA2D 
    169          
    170          @endverbatim
    171            * @{
    172            */
    173              
    174          /**
    175            * @brief  Initializes the DMA2D according to the specified
    176            *         parameters in the DMA2D_InitTypeDef and create the associated handle.
    177            * @param  hdma2d: pointer to a DMA2D_HandleTypeDef structure that contains
    178            *                 the configuration information for the DMA2D.
    179            * @retval HAL status
    180            */

   \                                 In section .text, align 2, keep-with-next
    181          HAL_StatusTypeDef HAL_DMA2D_Init(DMA2D_HandleTypeDef *hdma2d)
    182          { 
   \                     HAL_DMA2D_Init: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    183            uint32_t tmp = 0;
    184          
    185            /* Check the DMA2D peripheral state */
    186            if(hdma2d == NULL)
   \   00000004   0xD101             BNE.N    ??HAL_DMA2D_Init_0
    187            {
    188               return HAL_ERROR;
   \   00000006   0x2001             MOVS     R0,#+1
   \   00000008   0xBD10             POP      {R4,PC}
    189            }
    190          
    191            /* Check the parameters */
    192            assert_param(IS_DMA2D_ALL_INSTANCE(hdma2d->Instance));
    193            assert_param(IS_DMA2D_MODE(hdma2d->Init.Mode));
    194            assert_param(IS_DMA2D_CMODE(hdma2d->Init.ColorMode));
    195            assert_param(IS_DMA2D_OFFSET(hdma2d->Init.OutputOffset));
    196          
    197            if(hdma2d->State == HAL_DMA2D_STATE_RESET)
   \                     ??HAL_DMA2D_Init_0: (+1)
   \   0000000A   0xF894 0x0039      LDRB     R0,[R4, #+57]
   \   0000000E   0xB920             CBNZ.N   R0,??HAL_DMA2D_Init_1
    198            {
    199              /* Allocate lock resource and initialize it */
    200              hdma2d->Lock = HAL_UNLOCKED;
   \   00000010   0xF884 0x0038      STRB     R0,[R4, #+56]
    201              /* Init the low level hardware */
    202              HAL_DMA2D_MspInit(hdma2d);
   \   00000014   0x4620             MOV      R0,R4
   \   00000016   0x.... 0x....      BL       HAL_DMA2D_MspInit
    203            }
    204            
    205            /* Change DMA2D peripheral state */
    206            hdma2d->State = HAL_DMA2D_STATE_BUSY;  
   \                     ??HAL_DMA2D_Init_1: (+1)
   \   0000001A   0x2002             MOVS     R0,#+2
   \   0000001C   0xF884 0x0039      STRB     R0,[R4, #+57]
    207          
    208          /* DMA2D CR register configuration -------------------------------------------*/
    209            /* Get the CR register value */
    210            tmp = hdma2d->Instance->CR;
   \   00000020   0x6820             LDR      R0,[R4, #+0]
   \   00000022   0x6801             LDR      R1,[R0, #+0]
    211          
    212            /* Clear Mode bits */
    213            tmp &= (uint32_t)~DMA2D_CR_MODE;
    214          
    215            /* Prepare the value to be wrote to the CR register */
    216            tmp |= hdma2d->Init.Mode;
    217          
    218            /* Write to DMA2D CR register */
    219            hdma2d->Instance->CR = tmp;
   \   00000024   0x6862             LDR      R2,[R4, #+4]
   \   00000026   0xF421 0x3140      BIC      R1,R1,#0x30000
   \   0000002A   0x4311             ORRS     R1,R2,R1
   \   0000002C   0x6001             STR      R1,[R0, #+0]
    220          
    221          /* DMA2D OPFCCR register configuration ---------------------------------------*/
    222            /* Get the OPFCCR register value */
    223            tmp = hdma2d->Instance->OPFCCR;
   \   0000002E   0x6820             LDR      R0,[R4, #+0]
   \   00000030   0x6B41             LDR      R1,[R0, #+52]
    224          
    225            /* Clear Color Mode bits */
    226            tmp &= (uint32_t)~DMA2D_OPFCCR_CM;
    227          
    228            /* Prepare the value to be wrote to the OPFCCR register */
    229            tmp |= hdma2d->Init.ColorMode;
    230          
    231            /* Write to DMA2D OPFCCR register */
    232            hdma2d->Instance->OPFCCR = tmp;
   \   00000032   0x68A2             LDR      R2,[R4, #+8]
   \   00000034   0x08C9             LSRS     R1,R1,#+3
   \   00000036   0xEA42 0x01C1      ORR      R1,R2,R1, LSL #+3
   \   0000003A   0x6341             STR      R1,[R0, #+52]
    233          
    234          /* DMA2D OOR register configuration ------------------------------------------*/  
    235            /* Get the OOR register value */
    236            tmp = hdma2d->Instance->OOR;
   \   0000003C   0x6820             LDR      R0,[R4, #+0]
   \   0000003E   0x6C01             LDR      R1,[R0, #+64]
    237          
    238            /* Clear Offset bits */
    239            tmp &= (uint32_t)~DMA2D_OOR_LO;
    240          
    241            /* Prepare the value to be wrote to the OOR register */
    242            tmp |= hdma2d->Init.OutputOffset;
    243          
    244            /* Write to DMA2D OOR register */
    245            hdma2d->Instance->OOR = tmp;
   \   00000040   0x68E2             LDR      R2,[R4, #+12]
   \   00000042   0x0B89             LSRS     R1,R1,#+14
   \   00000044   0xEA42 0x3181      ORR      R1,R2,R1, LSL #+14
   \   00000048   0x6401             STR      R1,[R0, #+64]
    246          
    247            /* Update error code */
    248            hdma2d->ErrorCode = HAL_DMA2D_ERROR_NONE;
   \   0000004A   0x2000             MOVS     R0,#+0
   \   0000004C   0x63E0             STR      R0,[R4, #+60]
    249          
    250            /* Initialize the DMA2D state*/
    251            hdma2d->State  = HAL_DMA2D_STATE_READY;
   \   0000004E   0x2001             MOVS     R0,#+1
   \   00000050   0xF884 0x0039      STRB     R0,[R4, #+57]
    252          
    253            return HAL_OK;
   \   00000054   0x2000             MOVS     R0,#+0
   \   00000056   0xBD10             POP      {R4,PC}          ;; return
    254          }
    255          
    256          /**
    257            * @brief  Deinitializes the DMA2D peripheral registers to their default reset
    258            *         values.
    259            * @param  hdma2d: pointer to a DMA2D_HandleTypeDef structure that contains
    260            *                 the configuration information for the DMA2D.
    261            * @retval None
    262            */
    263          

   \                                 In section .text, align 2, keep-with-next
    264          HAL_StatusTypeDef HAL_DMA2D_DeInit(DMA2D_HandleTypeDef *hdma2d)
    265          {
   \                     HAL_DMA2D_DeInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    266            /* Check the DMA2D peripheral state */
    267            if(hdma2d == NULL)
   \   00000004   0xD101             BNE.N    ??HAL_DMA2D_DeInit_0
    268            {
    269               return HAL_ERROR;
   \   00000006   0x2001             MOVS     R0,#+1
   \   00000008   0xBD10             POP      {R4,PC}
    270            }
    271          
    272            /* DeInit the low level hardware */
    273            HAL_DMA2D_MspDeInit(hdma2d);
   \                     ??HAL_DMA2D_DeInit_0: (+1)
   \   0000000A   0x.... 0x....      BL       HAL_DMA2D_MspDeInit
    274          
    275            /* Update error code */
    276            hdma2d->ErrorCode = HAL_DMA2D_ERROR_NONE;
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0x63E0             STR      R0,[R4, #+60]
    277          
    278            /* Initialize the DMA2D state*/
    279            hdma2d->State  = HAL_DMA2D_STATE_RESET;
   \   00000012   0xF884 0x0039      STRB     R0,[R4, #+57]
    280          
    281            /* Release Lock */
    282            __HAL_UNLOCK(hdma2d);
   \   00000016   0xF884 0x0038      STRB     R0,[R4, #+56]
    283          
    284            return HAL_OK;
   \   0000001A   0xBD10             POP      {R4,PC}          ;; return
    285          }
    286          
    287          /**
    288            * @brief  Initializes the DMA2D MSP.
    289            * @param  hdma2d: pointer to a DMA2D_HandleTypeDef structure that contains
    290            *                 the configuration information for the DMA2D.
    291            * @retval None
    292            */

   \                                 In section .text, align 2, keep-with-next
    293          __weak void HAL_DMA2D_MspInit(DMA2D_HandleTypeDef* hdma2d)
    294          {
    295            /* Prevent unused argument(s) compilation warning */
    296            UNUSED(hdma2d);
    297           
    298            /* NOTE : This function Should not be modified, when the callback is needed,
    299                      the HAL_DMA2D_MspInit could be implemented in the user file
    300             */ 
    301          }
   \                     HAL_DMA2D_MspInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    302          
    303          /**
    304            * @brief  DeInitializes the DMA2D MSP.
    305            * @param  hdma2d: pointer to a DMA2D_HandleTypeDef structure that contains
    306            *                 the configuration information for the DMA2D.
    307            * @retval None
    308            */

   \                                 In section .text, align 2, keep-with-next
    309          __weak void HAL_DMA2D_MspDeInit(DMA2D_HandleTypeDef* hdma2d)
    310          {
    311            /* Prevent unused argument(s) compilation warning */
    312            UNUSED(hdma2d);
    313           
    314            /* NOTE : This function Should not be modified, when the callback is needed,
    315                      the HAL_DMA2D_MspDeInit could be implemented in the user file
    316             */ 
    317          }
   \                     HAL_DMA2D_MspDeInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    318          
    319          /**
    320            * @}
    321            */
    322          
    323          /** @defgroup DMA2D_Group2 IO operation functions 
    324           *  @brief   IO operation functions  
    325           *
    326          @verbatim   
    327           ===============================================================================
    328                                #####  IO operation functions  #####
    329           ===============================================================================  
    330              [..]  This section provides functions allowing to:
    331                (+) Configure the pdata, destination address and data size and 
    332                    Start DMA2D transfer.
    333                (+) Configure the source for foreground and background, destination address 
    334                    and data size and Start MultiBuffer DMA2D transfer.
    335                (+) Configure the pdata, destination address and data size and 
    336                    Start DMA2D transfer with interrupt.
    337                (+) Configure the source for foreground and background, destination address 
    338                    and data size and Start MultiBuffer DMA2D transfer with interrupt.
    339                (+) Abort DMA2D transfer.
    340                (+) Suspend DMA2D transfer.
    341                (+) Continue DMA2D transfer. 
    342                (+) Poll for transfer complete.
    343                (+) handle DMA2D interrupt request.
    344                  
    345          @endverbatim
    346            * @{
    347            */
    348          
    349          /**
    350            * @brief  Start the DMA2D Transfer.
    351            * @param  hdma2d:     pointer to a DMA2D_HandleTypeDef structure that contains
    352            *                     the configuration information for the DMA2D.  
    353            * @param  pdata:      Configure the source memory Buffer address if 
    354            *                     the memory to memory or memory to memory with pixel format 
    355            *                     conversion DMA2D mode is selected, and configure 
    356            *                     the color value if register to memory DMA2D mode is selected.
    357            * @param  DstAddress: The destination memory Buffer address.
    358            * @param  Width:      The width of data to be transferred from source to destination.
    359            * @param  Height:      The height of data to be transferred from source to destination.
    360            * @retval HAL status
    361            */

   \                                 In section .text, align 2, keep-with-next
    362          HAL_StatusTypeDef HAL_DMA2D_Start(DMA2D_HandleTypeDef *hdma2d, uint32_t pdata, uint32_t DstAddress, uint32_t Width,  uint32_t Height)
    363          {
   \                     HAL_DMA2D_Start: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0xB081             SUB      SP,SP,#+4
    364            /* Process locked */
    365            __HAL_LOCK(hdma2d);
   \   00000006   0xF894 0x0038      LDRB     R0,[R4, #+56]
   \   0000000A   0x2801             CMP      R0,#+1
   \   0000000C   0xBF08             IT       EQ 
   \   0000000E   0x2002             MOVEQ    R0,#+2
   \   00000010   0xD015             BEQ.N    ??HAL_DMA2D_Start_0
   \   00000012   0x2001             MOVS     R0,#+1
   \   00000014   0xF884 0x0038      STRB     R0,[R4, #+56]
    366          
    367            /* Change DMA2D peripheral state */
    368            hdma2d->State = HAL_DMA2D_STATE_BUSY;
   \   00000018   0x2002             MOVS     R0,#+2
   \   0000001A   0xF884 0x0039      STRB     R0,[R4, #+57]
    369          
    370            /* Check the parameters */
    371            assert_param(IS_DMA2D_LINE(Height));
    372            assert_param(IS_DMA2D_PIXEL(Width));
    373          
    374            /* Disable the Peripheral */
    375            __HAL_DMA2D_DISABLE(hdma2d);
   \   0000001E   0x6820             LDR      R0,[R4, #+0]
   \   00000020   0x6805             LDR      R5,[R0, #+0]
   \   00000022   0x086D             LSRS     R5,R5,#+1
   \   00000024   0x006D             LSLS     R5,R5,#+1
   \   00000026   0x6005             STR      R5,[R0, #+0]
    376          
    377            /* Configure the source, destination address and the data size */
    378            DMA2D_SetConfig(hdma2d, pdata, DstAddress, Width, Height);
   \   00000028   0x9804             LDR      R0,[SP, #+16]
   \   0000002A   0x9000             STR      R0,[SP, #+0]
   \   0000002C   0x4620             MOV      R0,R4
   \   0000002E   0x.... 0x....      BL       DMA2D_SetConfig
    379          
    380            /* Enable the Peripheral */
    381            __HAL_DMA2D_ENABLE(hdma2d);
   \   00000032   0x6820             LDR      R0,[R4, #+0]
   \   00000034   0x6801             LDR      R1,[R0, #+0]
   \   00000036   0xF041 0x0101      ORR      R1,R1,#0x1
   \   0000003A   0x6001             STR      R1,[R0, #+0]
    382          
    383            return HAL_OK;
   \   0000003C   0x2000             MOVS     R0,#+0
   \                     ??HAL_DMA2D_Start_0: (+1)
   \   0000003E   0xB001             ADD      SP,SP,#+4
   \   00000040   0xBD30             POP      {R4,R5,PC}       ;; return
    384          }
    385          
    386          /**
    387            * @brief  Start the DMA2D Transfer with interrupt enabled.
    388            * @param  hdma2d:     pointer to a DMA2D_HandleTypeDef structure that contains
    389            *                     the configuration information for the DMA2D.  
    390            * @param  pdata:      Configure the source memory Buffer address if 
    391            *                     the memory to memory or memory to memory with pixel format 
    392            *                     conversion DMA2D mode is selected, and configure 
    393            *                     the color value if register to memory DMA2D mode is selected.
    394            * @param  DstAddress: The destination memory Buffer address.
    395            * @param  Width:      The width of data to be transferred from source to destination.
    396            * @param  Height:     The height of data to be transferred from source to destination.
    397            * @retval HAL status
    398            */

   \                                 In section .text, align 2, keep-with-next
    399          HAL_StatusTypeDef HAL_DMA2D_Start_IT(DMA2D_HandleTypeDef *hdma2d, uint32_t pdata, uint32_t DstAddress, uint32_t Width,  uint32_t Height)
    400          {
   \                     HAL_DMA2D_Start_IT: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0xB081             SUB      SP,SP,#+4
    401            /* Process locked */
    402            __HAL_LOCK(hdma2d);
   \   00000006   0xF894 0x0038      LDRB     R0,[R4, #+56]
   \   0000000A   0x2801             CMP      R0,#+1
   \   0000000C   0xBF08             IT       EQ 
   \   0000000E   0x2002             MOVEQ    R0,#+2
   \   00000010   0xD024             BEQ.N    ??HAL_DMA2D_Start_IT_0
   \   00000012   0x2001             MOVS     R0,#+1
   \   00000014   0xF884 0x0038      STRB     R0,[R4, #+56]
    403          
    404            /* Change DMA2D peripheral state */
    405            hdma2d->State = HAL_DMA2D_STATE_BUSY;
   \   00000018   0x2002             MOVS     R0,#+2
   \   0000001A   0xF884 0x0039      STRB     R0,[R4, #+57]
    406          
    407            /* Check the parameters */
    408            assert_param(IS_DMA2D_LINE(Height));
    409            assert_param(IS_DMA2D_PIXEL(Width));
    410          
    411            /* Disable the Peripheral */
    412            __HAL_DMA2D_DISABLE(hdma2d);
   \   0000001E   0x6820             LDR      R0,[R4, #+0]
   \   00000020   0x6805             LDR      R5,[R0, #+0]
   \   00000022   0x086D             LSRS     R5,R5,#+1
   \   00000024   0x006D             LSLS     R5,R5,#+1
   \   00000026   0x6005             STR      R5,[R0, #+0]
    413          
    414            /* Configure the source, destination address and the data size */
    415            DMA2D_SetConfig(hdma2d, pdata, DstAddress, Width, Height);
   \   00000028   0x9804             LDR      R0,[SP, #+16]
   \   0000002A   0x9000             STR      R0,[SP, #+0]
   \   0000002C   0x4620             MOV      R0,R4
   \   0000002E   0x.... 0x....      BL       DMA2D_SetConfig
    416          
    417            /* Enable the transfer complete interrupt */
    418            __HAL_DMA2D_ENABLE_IT(hdma2d, DMA2D_IT_TC);
   \   00000032   0x6820             LDR      R0,[R4, #+0]
   \   00000034   0x6801             LDR      R1,[R0, #+0]
   \   00000036   0xF441 0x7100      ORR      R1,R1,#0x200
   \   0000003A   0x6001             STR      R1,[R0, #+0]
    419          
    420            /* Enable the transfer Error interrupt */
    421            __HAL_DMA2D_ENABLE_IT(hdma2d, DMA2D_IT_TE);
   \   0000003C   0x6820             LDR      R0,[R4, #+0]
   \   0000003E   0x6801             LDR      R1,[R0, #+0]
   \   00000040   0xF441 0x7180      ORR      R1,R1,#0x100
   \   00000044   0x6001             STR      R1,[R0, #+0]
    422          
    423            /* Enable the Peripheral */
    424            __HAL_DMA2D_ENABLE(hdma2d);
   \   00000046   0x6820             LDR      R0,[R4, #+0]
   \   00000048   0x6801             LDR      R1,[R0, #+0]
   \   0000004A   0xF041 0x0101      ORR      R1,R1,#0x1
   \   0000004E   0x6001             STR      R1,[R0, #+0]
    425          
    426            /* Enable the configuration error interrupt */
    427            __HAL_DMA2D_ENABLE_IT(hdma2d, DMA2D_IT_CE);
   \   00000050   0x6820             LDR      R0,[R4, #+0]
   \   00000052   0x6801             LDR      R1,[R0, #+0]
   \   00000054   0xF441 0x5100      ORR      R1,R1,#0x2000
   \   00000058   0x6001             STR      R1,[R0, #+0]
    428          
    429            return HAL_OK;
   \   0000005A   0x2000             MOVS     R0,#+0
   \                     ??HAL_DMA2D_Start_IT_0: (+1)
   \   0000005C   0xB001             ADD      SP,SP,#+4
   \   0000005E   0xBD30             POP      {R4,R5,PC}       ;; return
    430          }
    431          
    432          /**
    433            * @brief  Start the multi-source DMA2D Transfer.
    434            * @param  hdma2d:      pointer to a DMA2D_HandleTypeDef structure that contains
    435            *                      the configuration information for the DMA2D.  
    436            * @param  SrcAddress1: The source memory Buffer address of the foreground layer.
    437            * @param  SrcAddress2: The source memory Buffer address of the background layer.
    438            * @param  DstAddress:  The destination memory Buffer address
    439            * @param  Width:       The width of data to be transferred from source to destination.
    440            * @param  Height:      The height of data to be transferred from source to destination.
    441            * @retval HAL status
    442            */

   \                                 In section .text, align 2, keep-with-next
    443          HAL_StatusTypeDef HAL_DMA2D_BlendingStart(DMA2D_HandleTypeDef *hdma2d, uint32_t SrcAddress1, uint32_t  SrcAddress2, uint32_t DstAddress, uint32_t Width,  uint32_t Height)
    444          {
   \                     HAL_DMA2D_BlendingStart: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x4610             MOV      R0,R2
   \   00000006   0xB081             SUB      SP,SP,#+4
   \   00000008   0x461A             MOV      R2,R3
    445            /* Process locked */
    446            __HAL_LOCK(hdma2d);
   \   0000000A   0xF894 0x3038      LDRB     R3,[R4, #+56]
   \   0000000E   0x2B01             CMP      R3,#+1
   \   00000010   0xBF08             IT       EQ 
   \   00000012   0x2002             MOVEQ    R0,#+2
   \   00000014   0xD018             BEQ.N    ??HAL_DMA2D_BlendingStart_0
   \   00000016   0x2301             MOVS     R3,#+1
   \   00000018   0xF884 0x3038      STRB     R3,[R4, #+56]
    447          
    448            /* Change DMA2D peripheral state */
    449            hdma2d->State = HAL_DMA2D_STATE_BUSY; 
   \   0000001C   0x2302             MOVS     R3,#+2
   \   0000001E   0xF884 0x3039      STRB     R3,[R4, #+57]
    450          
    451            /* Check the parameters */
    452            assert_param(IS_DMA2D_LINE(Height));
    453            assert_param(IS_DMA2D_PIXEL(Width));
    454          
    455            /* Disable the Peripheral */
    456            __HAL_DMA2D_DISABLE(hdma2d);
   \   00000022   0x6823             LDR      R3,[R4, #+0]
   \   00000024   0x681D             LDR      R5,[R3, #+0]
   \   00000026   0x086D             LSRS     R5,R5,#+1
   \   00000028   0x006D             LSLS     R5,R5,#+1
   \   0000002A   0x601D             STR      R5,[R3, #+0]
    457          
    458            /* Configure DMA2D Stream source2 address */
    459            hdma2d->Instance->BGMAR = SrcAddress2;
   \   0000002C   0x6823             LDR      R3,[R4, #+0]
   \   0000002E   0x6158             STR      R0,[R3, #+20]
    460          
    461            /* Configure the source, destination address and the data size */
    462            DMA2D_SetConfig(hdma2d, SrcAddress1, DstAddress, Width, Height);
   \   00000030   0x9805             LDR      R0,[SP, #+20]
   \   00000032   0x9B04             LDR      R3,[SP, #+16]
   \   00000034   0x9000             STR      R0,[SP, #+0]
   \   00000036   0x4620             MOV      R0,R4
   \   00000038   0x.... 0x....      BL       DMA2D_SetConfig
    463          
    464            /* Enable the Peripheral */
    465            __HAL_DMA2D_ENABLE(hdma2d);
   \   0000003C   0x6820             LDR      R0,[R4, #+0]
   \   0000003E   0x6801             LDR      R1,[R0, #+0]
   \   00000040   0xF041 0x0101      ORR      R1,R1,#0x1
   \   00000044   0x6001             STR      R1,[R0, #+0]
    466          
    467            return HAL_OK;
   \   00000046   0x2000             MOVS     R0,#+0
   \                     ??HAL_DMA2D_BlendingStart_0: (+1)
   \   00000048   0xB001             ADD      SP,SP,#+4
   \   0000004A   0xBD30             POP      {R4,R5,PC}       ;; return
    468          }
    469          
    470          /**
    471            * @brief  Start the multi-source DMA2D Transfer with interrupt enabled.
    472            * @param  hdma2d:     pointer to a DMA2D_HandleTypeDef structure that contains
    473            *                     the configuration information for the DMA2D.  
    474            * @param  SrcAddress1: The source memory Buffer address of the foreground layer.
    475            * @param  SrcAddress2: The source memory Buffer address of the background layer.
    476            * @param  DstAddress:  The destination memory Buffer address.
    477            * @param  Width:       The width of data to be transferred from source to destination.
    478            * @param  Height:      The height of data to be transferred from source to destination.
    479            * @retval HAL status
    480            */

   \                                 In section .text, align 2, keep-with-next
    481          HAL_StatusTypeDef HAL_DMA2D_BlendingStart_IT(DMA2D_HandleTypeDef *hdma2d, uint32_t SrcAddress1, uint32_t  SrcAddress2, uint32_t DstAddress, uint32_t Width,  uint32_t Height)
    482          {
   \                     HAL_DMA2D_BlendingStart_IT: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x4610             MOV      R0,R2
   \   00000006   0xB081             SUB      SP,SP,#+4
   \   00000008   0x461A             MOV      R2,R3
    483            /* Process locked */
    484            __HAL_LOCK(hdma2d);
   \   0000000A   0xF894 0x3038      LDRB     R3,[R4, #+56]
   \   0000000E   0x2B01             CMP      R3,#+1
   \   00000010   0xBF08             IT       EQ 
   \   00000012   0x2002             MOVEQ    R0,#+2
   \   00000014   0xD027             BEQ.N    ??HAL_DMA2D_BlendingStart_IT_0
   \   00000016   0x2301             MOVS     R3,#+1
   \   00000018   0xF884 0x3038      STRB     R3,[R4, #+56]
    485          
    486            /* Change DMA2D peripheral state */
    487            hdma2d->State = HAL_DMA2D_STATE_BUSY;
   \   0000001C   0x2302             MOVS     R3,#+2
   \   0000001E   0xF884 0x3039      STRB     R3,[R4, #+57]
    488          
    489            /* Check the parameters */
    490            assert_param(IS_DMA2D_LINE(Height));
    491            assert_param(IS_DMA2D_PIXEL(Width));
    492          
    493            /* Disable the Peripheral */
    494            __HAL_DMA2D_DISABLE(hdma2d);
   \   00000022   0x6823             LDR      R3,[R4, #+0]
   \   00000024   0x681D             LDR      R5,[R3, #+0]
   \   00000026   0x086D             LSRS     R5,R5,#+1
   \   00000028   0x006D             LSLS     R5,R5,#+1
   \   0000002A   0x601D             STR      R5,[R3, #+0]
    495           
    496            /* Configure DMA2D Stream source2 address */
    497            hdma2d->Instance->BGMAR = SrcAddress2;
   \   0000002C   0x6823             LDR      R3,[R4, #+0]
   \   0000002E   0x6158             STR      R0,[R3, #+20]
    498          
    499            /* Configure the source, destination address and the data size */
    500            DMA2D_SetConfig(hdma2d, SrcAddress1, DstAddress, Width, Height);
   \   00000030   0x9805             LDR      R0,[SP, #+20]
   \   00000032   0x9B04             LDR      R3,[SP, #+16]
   \   00000034   0x9000             STR      R0,[SP, #+0]
   \   00000036   0x4620             MOV      R0,R4
   \   00000038   0x.... 0x....      BL       DMA2D_SetConfig
    501          
    502            /* Enable the configuration error interrupt */
    503            __HAL_DMA2D_ENABLE_IT(hdma2d, DMA2D_IT_CE);
   \   0000003C   0x6820             LDR      R0,[R4, #+0]
   \   0000003E   0x6801             LDR      R1,[R0, #+0]
   \   00000040   0xF441 0x5100      ORR      R1,R1,#0x2000
   \   00000044   0x6001             STR      R1,[R0, #+0]
    504          
    505            /* Enable the transfer complete interrupt */
    506            __HAL_DMA2D_ENABLE_IT(hdma2d, DMA2D_IT_TC);
   \   00000046   0x6820             LDR      R0,[R4, #+0]
   \   00000048   0x6801             LDR      R1,[R0, #+0]
   \   0000004A   0xF441 0x7100      ORR      R1,R1,#0x200
   \   0000004E   0x6001             STR      R1,[R0, #+0]
    507          
    508            /* Enable the transfer Error interrupt */
    509            __HAL_DMA2D_ENABLE_IT(hdma2d, DMA2D_IT_TE);
   \   00000050   0x6820             LDR      R0,[R4, #+0]
   \   00000052   0x6801             LDR      R1,[R0, #+0]
   \   00000054   0xF441 0x7180      ORR      R1,R1,#0x100
   \   00000058   0x6001             STR      R1,[R0, #+0]
    510          
    511            /* Enable the Peripheral */
    512            __HAL_DMA2D_ENABLE(hdma2d);
   \   0000005A   0x6820             LDR      R0,[R4, #+0]
   \   0000005C   0x6801             LDR      R1,[R0, #+0]
   \   0000005E   0xF041 0x0101      ORR      R1,R1,#0x1
   \   00000062   0x6001             STR      R1,[R0, #+0]
    513          
    514            return HAL_OK;
   \   00000064   0x2000             MOVS     R0,#+0
   \                     ??HAL_DMA2D_BlendingStart_IT_0: (+1)
   \   00000066   0xB001             ADD      SP,SP,#+4
   \   00000068   0xBD30             POP      {R4,R5,PC}       ;; return
    515          }
    516          
    517          /**
    518            * @brief  Abort the DMA2D Transfer.
    519            * @param  hdma2d : pointer to a DMA2D_HandleTypeDef structure that contains
    520            *                  the configuration information for the DMA2D.
    521            * @retval HAL status
    522            */

   \                                 In section .text, align 2, keep-with-next
    523          HAL_StatusTypeDef HAL_DMA2D_Abort(DMA2D_HandleTypeDef *hdma2d)
    524          {
   \                     HAL_DMA2D_Abort: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
    525            uint32_t tickstart = 0;
    526          
    527            /* Disable the DMA2D */
    528            __HAL_DMA2D_DISABLE(hdma2d);
   \   00000004   0xF240 0x36E9      MOVW     R6,#+1001
   \   00000008   0x6820             LDR      R0,[R4, #+0]
   \   0000000A   0x6801             LDR      R1,[R0, #+0]
   \   0000000C   0x0849             LSRS     R1,R1,#+1
   \   0000000E   0x0049             LSLS     R1,R1,#+1
   \   00000010   0x6001             STR      R1,[R0, #+0]
    529          
    530            /* Get tick */
    531            tickstart = HAL_GetTick();
   \   00000012   0x.... 0x....      BL       HAL_GetTick
   \   00000016   0x4605             MOV      R5,R0
    532          
    533            /* Check if the DMA2D is effectively disabled */
    534            while((hdma2d->Instance->CR & DMA2D_CR_START) != 0)
   \                     ??HAL_DMA2D_Abort_0: (+1)
   \   00000018   0x6820             LDR      R0,[R4, #+0]
   \   0000001A   0x6800             LDR      R0,[R0, #+0]
   \   0000001C   0x07C0             LSLS     R0,R0,#+31
   \   0000001E   0xD510             BPL.N    ??HAL_DMA2D_Abort_1
    535            {
    536              if((HAL_GetTick() - tickstart ) > HAL_TIMEOUT_DMA2D_ABORT)
   \   00000020   0x.... 0x....      BL       HAL_GetTick
   \   00000024   0x1B40             SUBS     R0,R0,R5
   \   00000026   0x42B0             CMP      R0,R6
   \   00000028   0xD3F6             BCC.N    ??HAL_DMA2D_Abort_0
    537              {
    538                /* Update error code */
    539                hdma2d->ErrorCode |= HAL_DMA2D_ERROR_TIMEOUT;
   \   0000002A   0x6BE0             LDR      R0,[R4, #+60]
   \   0000002C   0xF040 0x0020      ORR      R0,R0,#0x20
   \   00000030   0x63E0             STR      R0,[R4, #+60]
    540                
    541                /* Change the DMA2D state */
    542                hdma2d->State= HAL_DMA2D_STATE_TIMEOUT;
   \   00000032   0x2003             MOVS     R0,#+3
   \   00000034   0xF884 0x0039      STRB     R0,[R4, #+57]
    543                
    544                /* Process Unlocked */
    545                __HAL_UNLOCK(hdma2d);
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0xF884 0x0038      STRB     R0,[R4, #+56]
    546                
    547                return HAL_TIMEOUT;
   \   0000003E   0x2003             MOVS     R0,#+3
   \   00000040   0xBD70             POP      {R4-R6,PC}
    548              }
    549            }
    550            /* Process Unlocked */
    551            __HAL_UNLOCK(hdma2d);
   \                     ??HAL_DMA2D_Abort_1: (+1)
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0xF884 0x0038      STRB     R0,[R4, #+56]
    552          
    553            /* Change the DMA2D state*/
    554            hdma2d->State = HAL_DMA2D_STATE_READY;
   \   00000048   0x2001             MOVS     R0,#+1
   \   0000004A   0xF884 0x0039      STRB     R0,[R4, #+57]
    555          
    556            return HAL_OK;
   \   0000004E   0x2000             MOVS     R0,#+0
   \   00000050   0xBD70             POP      {R4-R6,PC}       ;; return
    557          }
    558          
    559          /**
    560            * @brief  Suspend the DMA2D Transfer.
    561            * @param  hdma2d: pointer to a DMA2D_HandleTypeDef structure that contains
    562            *                 the configuration information for the DMA2D. 
    563            * @retval HAL status
    564            */

   \                                 In section .text, align 2, keep-with-next
    565          HAL_StatusTypeDef HAL_DMA2D_Suspend(DMA2D_HandleTypeDef *hdma2d)
    566          {
   \                     HAL_DMA2D_Suspend: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
    567            uint32_t tickstart = 0;
    568          
    569            /* Suspend the DMA2D transfer */
    570            hdma2d->Instance->CR |= DMA2D_CR_SUSP;
   \   00000004   0xF240 0x36E9      MOVW     R6,#+1001
   \   00000008   0x6820             LDR      R0,[R4, #+0]
   \   0000000A   0x6801             LDR      R1,[R0, #+0]
   \   0000000C   0xF041 0x0102      ORR      R1,R1,#0x2
   \   00000010   0x6001             STR      R1,[R0, #+0]
    571          
    572            /* Get tick */
    573            tickstart = HAL_GetTick();
   \   00000012   0x.... 0x....      BL       HAL_GetTick
   \   00000016   0x4605             MOV      R5,R0
    574          
    575            /* Check if the DMA2D is effectively suspended */
    576            while((hdma2d->Instance->CR & DMA2D_CR_SUSP) != DMA2D_CR_SUSP)
   \                     ??HAL_DMA2D_Suspend_0: (+1)
   \   00000018   0x6820             LDR      R0,[R4, #+0]
   \   0000001A   0x6800             LDR      R0,[R0, #+0]
   \   0000001C   0x0780             LSLS     R0,R0,#+30
   \   0000001E   0xD40C             BMI.N    ??HAL_DMA2D_Suspend_1
    577            {
    578              if((HAL_GetTick() - tickstart ) > HAL_TIMEOUT_DMA2D_SUSPEND)
   \   00000020   0x.... 0x....      BL       HAL_GetTick
   \   00000024   0x1B40             SUBS     R0,R0,R5
   \   00000026   0x42B0             CMP      R0,R6
   \   00000028   0xD3F6             BCC.N    ??HAL_DMA2D_Suspend_0
    579              {
    580                /* Update error code */
    581                hdma2d->ErrorCode |= HAL_DMA2D_ERROR_TIMEOUT;
   \   0000002A   0x6BE0             LDR      R0,[R4, #+60]
   \   0000002C   0xF040 0x0020      ORR      R0,R0,#0x20
   \   00000030   0x63E0             STR      R0,[R4, #+60]
    582                
    583                /* Change the DMA2D state */
    584                hdma2d->State= HAL_DMA2D_STATE_TIMEOUT;
   \   00000032   0x2003             MOVS     R0,#+3
   \   00000034   0xF884 0x0039      STRB     R0,[R4, #+57]
    585                
    586                return HAL_TIMEOUT;
   \   00000038   0xBD70             POP      {R4-R6,PC}
    587              }
    588            }
    589            /* Change the DMA2D state*/
    590            hdma2d->State = HAL_DMA2D_STATE_SUSPEND;
   \                     ??HAL_DMA2D_Suspend_1: (+1)
   \   0000003A   0x2005             MOVS     R0,#+5
   \   0000003C   0xF884 0x0039      STRB     R0,[R4, #+57]
    591          
    592            return HAL_OK;
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0xBD70             POP      {R4-R6,PC}       ;; return
    593          }
    594          
    595          /**
    596            * @brief  Resume the DMA2D Transfer.
    597            * @param  hdma2d: pointer to a DMA2D_HandleTypeDef structure that contains
    598            *                 the configuration information for the DMA2D.  
    599            * @retval HAL status
    600            */

   \                                 In section .text, align 2, keep-with-next
    601          HAL_StatusTypeDef HAL_DMA2D_Resume(DMA2D_HandleTypeDef *hdma2d)
    602          {
    603            /* Resume the DMA2D transfer */
    604            hdma2d->Instance->CR &= ~DMA2D_CR_SUSP;
   \                     HAL_DMA2D_Resume: (+1)
   \   00000000   0x6801             LDR      R1,[R0, #+0]
   \   00000002   0x680A             LDR      R2,[R1, #+0]
   \   00000004   0xF022 0x0202      BIC      R2,R2,#0x2
   \   00000008   0x600A             STR      R2,[R1, #+0]
    605          
    606            /* Change the DMA2D state*/
    607            hdma2d->State = HAL_DMA2D_STATE_BUSY;
   \   0000000A   0x2102             MOVS     R1,#+2
   \   0000000C   0xF880 0x1039      STRB     R1,[R0, #+57]
    608          
    609            return HAL_OK;
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0x4770             BX       LR               ;; return
    610          }
    611          
    612          /**
    613            * @brief  Polling for transfer complete or CLUT loading.
    614            * @param  hdma2d: pointer to a DMA2D_HandleTypeDef structure that contains
    615            *                 the configuration information for the DMA2D. 
    616            * @param  Timeout: Timeout duration
    617            * @retval HAL status
    618            */

   \                                 In section .text, align 2, keep-with-next
    619          HAL_StatusTypeDef HAL_DMA2D_PollForTransfer(DMA2D_HandleTypeDef *hdma2d, uint32_t Timeout)
    620          {
   \                     HAL_DMA2D_PollForTransfer: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    621            uint32_t tmp, tmp1;
    622            uint32_t tickstart = 0;
    623          
    624            /* Polling for DMA2D transfer */
    625            if((hdma2d->Instance->CR & DMA2D_CR_START) != 0)
   \   00000006   0x6820             LDR      R0,[R4, #+0]
   \   00000008   0x6800             LDR      R0,[R0, #+0]
   \   0000000A   0x07C0             LSLS     R0,R0,#+31
   \   0000000C   0xD526             BPL.N    ??HAL_DMA2D_PollForTransfer_0
    626            {
    627             /* Get tick */
    628             tickstart = HAL_GetTick();
   \   0000000E   0x.... 0x....      BL       HAL_GetTick
   \   00000012   0x4606             MOV      R6,R0
    629          
    630              while(__HAL_DMA2D_GET_FLAG(hdma2d, DMA2D_FLAG_TC) == RESET)
   \                     ??HAL_DMA2D_PollForTransfer_1: (+1)
   \   00000014   0x6820             LDR      R0,[R4, #+0]
   \   00000016   0x6841             LDR      R1,[R0, #+4]
   \   00000018   0x0789             LSLS     R1,R1,#+30
   \   0000001A   0xD41F             BMI.N    ??HAL_DMA2D_PollForTransfer_0
    631              {
    632                tmp  = __HAL_DMA2D_GET_FLAG(hdma2d, DMA2D_FLAG_CE);
   \   0000001C   0x6841             LDR      R1,[R0, #+4]
    633                tmp1 = __HAL_DMA2D_GET_FLAG(hdma2d, DMA2D_FLAG_TE);
   \   0000001E   0x6842             LDR      R2,[R0, #+4]
    634          
    635                if((tmp != RESET) || (tmp1 != RESET))
   \   00000020   0x0689             LSLS     R1,R1,#+26
   \   00000022   0xD401             BMI.N    ??HAL_DMA2D_PollForTransfer_2
   \   00000024   0x07D1             LSLS     R1,R2,#+31
   \   00000026   0xD50C             BPL.N    ??HAL_DMA2D_PollForTransfer_3
    636                {
    637                  /* Clear the transfer and configuration error flags */
    638                  __HAL_DMA2D_CLEAR_FLAG(hdma2d, DMA2D_FLAG_CE);
   \                     ??HAL_DMA2D_PollForTransfer_2: (+1)
   \   00000028   0x2120             MOVS     R1,#+32
   \   0000002A   0x6081             STR      R1,[R0, #+8]
    639                  __HAL_DMA2D_CLEAR_FLAG(hdma2d, DMA2D_FLAG_TE);
   \   0000002C   0x6821             LDR      R1,[R4, #+0]
   \   0000002E   0x2001             MOVS     R0,#+1
   \   00000030   0x6088             STR      R0,[R1, #+8]
    640          
    641                  /* Change DMA2D state */
    642                  hdma2d->State= HAL_DMA2D_STATE_ERROR;
   \   00000032   0x2004             MOVS     R0,#+4
   \   00000034   0xF884 0x0039      STRB     R0,[R4, #+57]
    643          
    644                  /* Process unlocked */
    645                  __HAL_UNLOCK(hdma2d);
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0xF884 0x0038      STRB     R0,[R4, #+56]
    646                  
    647                  return HAL_ERROR;
    648                }
    649                /* Check for the Timeout */
    650                if(Timeout != HAL_MAX_DELAY)
    651                {
    652                  if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
    653                  {
    654                    /* Process unlocked */
    655                    __HAL_UNLOCK(hdma2d);
    656                  
    657                    /* Update error code */
    658                    hdma2d->ErrorCode |= HAL_DMA2D_ERROR_TIMEOUT;
    659          
    660                    /* Change the DMA2D state */
    661                    hdma2d->State= HAL_DMA2D_STATE_TIMEOUT;
    662                    
    663                    return HAL_TIMEOUT;
    664                  }
    665                }        
    666              }
    667            }
    668            /* Polling for CLUT loading */
    669            if((hdma2d->Instance->FGPFCCR & DMA2D_FGPFCCR_START) != 0)
    670            {
    671              /* Get tick */
    672              tickstart = HAL_GetTick();
    673             
    674              while(__HAL_DMA2D_GET_FLAG(hdma2d, DMA2D_FLAG_CTC) == RESET)
    675              {
    676                if((__HAL_DMA2D_GET_FLAG(hdma2d, DMA2D_FLAG_CAE) != RESET))
    677                {      
    678                  /* Clear the transfer and configuration error flags */
    679                  __HAL_DMA2D_CLEAR_FLAG(hdma2d, DMA2D_FLAG_CAE);
    680                  
    681                  /* Change DMA2D state */
    682                  hdma2d->State= HAL_DMA2D_STATE_ERROR;
    683                  
    684                  return HAL_ERROR;      
   \   0000003E   0x2001             MOVS     R0,#+1
   \   00000040   0xBD70             POP      {R4-R6,PC}
   \                     ??HAL_DMA2D_PollForTransfer_3: (+1)
   \   00000042   0xF115 0x0F01      CMN      R5,#+1
   \   00000046   0xD0E5             BEQ.N    ??HAL_DMA2D_PollForTransfer_1
   \   00000048   0xB125             CBZ.N    R5,??HAL_DMA2D_PollForTransfer_4
   \   0000004A   0x.... 0x....      BL       HAL_GetTick
   \   0000004E   0x1B80             SUBS     R0,R0,R6
   \   00000050   0x4285             CMP      R5,R0
   \   00000052   0xD2DF             BCS.N    ??HAL_DMA2D_PollForTransfer_1
   \                     ??HAL_DMA2D_PollForTransfer_4: (+1)
   \   00000054   0x2000             MOVS     R0,#+0
   \   00000056   0xF884 0x0038      STRB     R0,[R4, #+56]
   \   0000005A   0xE01D             B.N      ??HAL_DMA2D_PollForTransfer_5
   \                     ??HAL_DMA2D_PollForTransfer_0: (+1)
   \   0000005C   0x6820             LDR      R0,[R4, #+0]
   \   0000005E   0x69C0             LDR      R0,[R0, #+28]
   \   00000060   0x0680             LSLS     R0,R0,#+26
   \   00000062   0xD521             BPL.N    ??HAL_DMA2D_PollForTransfer_6
   \   00000064   0x.... 0x....      BL       HAL_GetTick
   \   00000068   0x4606             MOV      R6,R0
   \                     ??HAL_DMA2D_PollForTransfer_7: (+1)
   \   0000006A   0x6820             LDR      R0,[R4, #+0]
   \   0000006C   0x6841             LDR      R1,[R0, #+4]
   \   0000006E   0x06C9             LSLS     R1,R1,#+27
   \   00000070   0xD41A             BMI.N    ??HAL_DMA2D_PollForTransfer_6
   \   00000072   0x6841             LDR      R1,[R0, #+4]
   \   00000074   0x0709             LSLS     R1,R1,#+28
   \   00000076   0xD506             BPL.N    ??HAL_DMA2D_PollForTransfer_8
   \   00000078   0x2108             MOVS     R1,#+8
   \   0000007A   0x6081             STR      R1,[R0, #+8]
   \   0000007C   0x2004             MOVS     R0,#+4
   \   0000007E   0xF884 0x0039      STRB     R0,[R4, #+57]
   \   00000082   0x2001             MOVS     R0,#+1
   \   00000084   0xBD70             POP      {R4-R6,PC}
    685                }      
    686                /* Check for the Timeout */
    687                if(Timeout != HAL_MAX_DELAY)
   \                     ??HAL_DMA2D_PollForTransfer_8: (+1)
   \   00000086   0xF115 0x0F01      CMN      R5,#+1
   \   0000008A   0xD0EE             BEQ.N    ??HAL_DMA2D_PollForTransfer_7
    688                {
    689                  if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
   \   0000008C   0xB125             CBZ.N    R5,??HAL_DMA2D_PollForTransfer_5
   \   0000008E   0x.... 0x....      BL       HAL_GetTick
   \   00000092   0x1B80             SUBS     R0,R0,R6
   \   00000094   0x4285             CMP      R5,R0
   \   00000096   0xD2E8             BCS.N    ??HAL_DMA2D_PollForTransfer_7
    690                  {
    691                    /* Update error code */
    692                    hdma2d->ErrorCode |= HAL_DMA2D_ERROR_TIMEOUT;
   \                     ??HAL_DMA2D_PollForTransfer_5: (+1)
   \   00000098   0x6BE0             LDR      R0,[R4, #+60]
   \   0000009A   0xF040 0x0020      ORR      R0,R0,#0x20
   \   0000009E   0x63E0             STR      R0,[R4, #+60]
    693              
    694                    /* Change the DMA2D state */
    695                    hdma2d->State= HAL_DMA2D_STATE_TIMEOUT;
   \   000000A0   0x2003             MOVS     R0,#+3
   \   000000A2   0xF884 0x0039      STRB     R0,[R4, #+57]
    696                    
    697                    return HAL_TIMEOUT;
   \   000000A6   0xBD70             POP      {R4-R6,PC}
    698                  }
    699                }      
    700              }
    701            }
    702            /* Clear the transfer complete flag */
    703            __HAL_DMA2D_CLEAR_FLAG(hdma2d, DMA2D_FLAG_TC);
   \                     ??HAL_DMA2D_PollForTransfer_6: (+1)
   \   000000A8   0x6821             LDR      R1,[R4, #+0]
   \   000000AA   0x2002             MOVS     R0,#+2
   \   000000AC   0x6088             STR      R0,[R1, #+8]
    704            
    705            /* Clear the CLUT loading flag */
    706            __HAL_DMA2D_CLEAR_FLAG(hdma2d, DMA2D_FLAG_CTC);  
   \   000000AE   0x6821             LDR      R1,[R4, #+0]
   \   000000B0   0x2010             MOVS     R0,#+16
   \   000000B2   0x6088             STR      R0,[R1, #+8]
    707            
    708            /* Change DMA2D state */
    709            hdma2d->State = HAL_DMA2D_STATE_READY;
   \   000000B4   0x2001             MOVS     R0,#+1
   \   000000B6   0xF884 0x0039      STRB     R0,[R4, #+57]
    710            
    711            /* Process unlocked */
    712            __HAL_UNLOCK(hdma2d);
   \   000000BA   0x2000             MOVS     R0,#+0
   \   000000BC   0xF884 0x0038      STRB     R0,[R4, #+56]
    713            
    714            return HAL_OK;
   \   000000C0   0xBD70             POP      {R4-R6,PC}       ;; return
    715          }
    716          /**
    717            * @brief  Handles DMA2D interrupt request.
    718            * @param  hdma2d: pointer to a DMA2D_HandleTypeDef structure that contains
    719            *                 the configuration information for the DMA2D.  
    720            * @retval HAL status
    721            */

   \                                 In section .text, align 2, keep-with-next
    722          void HAL_DMA2D_IRQHandler(DMA2D_HandleTypeDef *hdma2d)
    723          {    
   \                     HAL_DMA2D_IRQHandler: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    724            /* Transfer Error Interrupt management ***************************************/
    725            if(__HAL_DMA2D_GET_FLAG(hdma2d, DMA2D_FLAG_TE) != RESET)
   \   00000004   0x6820             LDR      R0,[R4, #+0]
   \   00000006   0x6841             LDR      R1,[R0, #+4]
   \   00000008   0x07C9             LSLS     R1,R1,#+31
   \   0000000A   0xD518             BPL.N    ??HAL_DMA2D_IRQHandler_0
    726            {
    727              if(__HAL_DMA2D_GET_IT_SOURCE(hdma2d, DMA2D_IT_TE) != RESET)
   \   0000000C   0x6801             LDR      R1,[R0, #+0]
   \   0000000E   0x05C9             LSLS     R1,R1,#+23
   \   00000010   0xD515             BPL.N    ??HAL_DMA2D_IRQHandler_0
    728              {
    729                /* Disable the transfer Error interrupt */
    730                __HAL_DMA2D_DISABLE_IT(hdma2d, DMA2D_IT_TE);  
   \   00000012   0x6801             LDR      R1,[R0, #+0]
   \   00000014   0xF421 0x7180      BIC      R1,R1,#0x100
   \   00000018   0x6001             STR      R1,[R0, #+0]
    731          
    732                /* Update error code */
    733                hdma2d->ErrorCode |= HAL_DMA2D_ERROR_TE;
   \   0000001A   0x6BE0             LDR      R0,[R4, #+60]
   \   0000001C   0xF040 0x0001      ORR      R0,R0,#0x1
   \   00000020   0x63E0             STR      R0,[R4, #+60]
    734              
    735                /* Clear the transfer error flag */
    736                __HAL_DMA2D_CLEAR_FLAG(hdma2d, DMA2D_FLAG_TE);
   \   00000022   0x6821             LDR      R1,[R4, #+0]
   \   00000024   0x2001             MOVS     R0,#+1
   \   00000026   0x6088             STR      R0,[R1, #+8]
    737          
    738                /* Change DMA2D state */
    739                hdma2d->State = HAL_DMA2D_STATE_ERROR;
   \   00000028   0x2004             MOVS     R0,#+4
   \   0000002A   0xF884 0x0039      STRB     R0,[R4, #+57]
    740          
    741                /* Process Unlocked */
    742                __HAL_UNLOCK(hdma2d);       
   \   0000002E   0x2000             MOVS     R0,#+0
    743                
    744                if(hdma2d->XferErrorCallback != NULL)
   \   00000030   0x6961             LDR      R1,[R4, #+20]
   \   00000032   0xF884 0x0038      STRB     R0,[R4, #+56]
   \   00000036   0x0008             MOVS     R0,R1
   \   00000038   0xBF1C             ITT      NE 
    745                {
    746                  /* Transfer error Callback */
    747                  hdma2d->XferErrorCallback(hdma2d);
   \   0000003A   0x4620             MOVNE    R0,R4
   \   0000003C   0x4788             BLXNE    R1
    748                }
    749              }
    750            }
    751            /* Configuration Error Interrupt management **********************************/
    752            if(__HAL_DMA2D_GET_FLAG(hdma2d, DMA2D_FLAG_CE) != RESET)
   \                     ??HAL_DMA2D_IRQHandler_0: (+1)
   \   0000003E   0x6820             LDR      R0,[R4, #+0]
   \   00000040   0x6841             LDR      R1,[R0, #+4]
   \   00000042   0x0689             LSLS     R1,R1,#+26
   \   00000044   0xD518             BPL.N    ??HAL_DMA2D_IRQHandler_1
    753            {
    754              if(__HAL_DMA2D_GET_IT_SOURCE(hdma2d, DMA2D_IT_CE) != RESET)
   \   00000046   0x6801             LDR      R1,[R0, #+0]
   \   00000048   0x0489             LSLS     R1,R1,#+18
   \   0000004A   0xD515             BPL.N    ??HAL_DMA2D_IRQHandler_1
    755              {
    756                /* Disable the Configuration Error interrupt */
    757                __HAL_DMA2D_DISABLE_IT(hdma2d, DMA2D_IT_CE);
   \   0000004C   0x6801             LDR      R1,[R0, #+0]
   \   0000004E   0xF421 0x5100      BIC      R1,R1,#0x2000
   \   00000052   0x6001             STR      R1,[R0, #+0]
    758            
    759                /* Clear the Configuration error flag */
    760                __HAL_DMA2D_CLEAR_FLAG(hdma2d, DMA2D_FLAG_CE);
   \   00000054   0x6821             LDR      R1,[R4, #+0]
   \   00000056   0x2020             MOVS     R0,#+32
   \   00000058   0x6088             STR      R0,[R1, #+8]
    761          
    762                /* Update error code */
    763                hdma2d->ErrorCode |= HAL_DMA2D_ERROR_CE;    
   \   0000005A   0x6BE0             LDR      R0,[R4, #+60]
   \   0000005C   0xF040 0x0002      ORR      R0,R0,#0x2
   \   00000060   0x63E0             STR      R0,[R4, #+60]
    764              
    765                /* Change DMA2D state */
    766                hdma2d->State = HAL_DMA2D_STATE_ERROR;
   \   00000062   0x2004             MOVS     R0,#+4
   \   00000064   0xF884 0x0039      STRB     R0,[R4, #+57]
    767          
    768                /* Process Unlocked */
    769                __HAL_UNLOCK(hdma2d);       
   \   00000068   0x2000             MOVS     R0,#+0
    770                
    771                if(hdma2d->XferErrorCallback != NULL)
   \   0000006A   0x6961             LDR      R1,[R4, #+20]
   \   0000006C   0xF884 0x0038      STRB     R0,[R4, #+56]
   \   00000070   0x0008             MOVS     R0,R1
   \   00000072   0xBF1C             ITT      NE 
    772                {
    773                  /* Transfer error Callback */
    774                  hdma2d->XferErrorCallback(hdma2d);
   \   00000074   0x4620             MOVNE    R0,R4
   \   00000076   0x4788             BLXNE    R1
    775                }
    776              }
    777            }
    778            /* Transfer Complete Interrupt management ************************************/
    779            if(__HAL_DMA2D_GET_FLAG(hdma2d, DMA2D_FLAG_TC) != RESET)
   \                     ??HAL_DMA2D_IRQHandler_1: (+1)
   \   00000078   0x6820             LDR      R0,[R4, #+0]
   \   0000007A   0x6841             LDR      R1,[R0, #+4]
   \   0000007C   0x0789             LSLS     R1,R1,#+30
   \   0000007E   0xD518             BPL.N    ??HAL_DMA2D_IRQHandler_2
    780            {
    781              if(__HAL_DMA2D_GET_IT_SOURCE(hdma2d, DMA2D_IT_TC) != RESET)
   \   00000080   0x6801             LDR      R1,[R0, #+0]
   \   00000082   0x0589             LSLS     R1,R1,#+22
   \   00000084   0xD515             BPL.N    ??HAL_DMA2D_IRQHandler_2
    782              { 
    783                /* Disable the transfer complete interrupt */
    784                __HAL_DMA2D_DISABLE_IT(hdma2d, DMA2D_IT_TC);
   \   00000086   0x6801             LDR      R1,[R0, #+0]
   \   00000088   0xF421 0x7100      BIC      R1,R1,#0x200
   \   0000008C   0x6001             STR      R1,[R0, #+0]
    785            
    786                /* Clear the transfer complete flag */  
    787                __HAL_DMA2D_CLEAR_FLAG(hdma2d, DMA2D_FLAG_TC);
   \   0000008E   0x6821             LDR      R1,[R4, #+0]
   \   00000090   0x2002             MOVS     R0,#+2
   \   00000092   0x6088             STR      R0,[R1, #+8]
    788          
    789                /* Update error code */
    790                hdma2d->ErrorCode |= HAL_DMA2D_ERROR_NONE;    
   \   00000094   0x6BE0             LDR      R0,[R4, #+60]
   \   00000096   0x63E0             STR      R0,[R4, #+60]
    791              
    792                /* Change DMA2D state */
    793                hdma2d->State = HAL_DMA2D_STATE_READY;
   \   00000098   0x2001             MOVS     R0,#+1
   \   0000009A   0xF884 0x0039      STRB     R0,[R4, #+57]
    794              
    795                /* Process Unlocked */
    796                __HAL_UNLOCK(hdma2d);       
   \   0000009E   0x2000             MOVS     R0,#+0
    797                
    798                if(hdma2d->XferCpltCallback != NULL)
   \   000000A0   0x6921             LDR      R1,[R4, #+16]
   \   000000A2   0xF884 0x0038      STRB     R0,[R4, #+56]
   \   000000A6   0x0008             MOVS     R0,R1
   \   000000A8   0xD003             BEQ.N    ??HAL_DMA2D_IRQHandler_2
    799                {
    800                  /* Transfer complete Callback */
    801                  hdma2d->XferCpltCallback(hdma2d);
   \   000000AA   0x4620             MOV      R0,R4
   \   000000AC   0xE8BD 0x4010      POP      {R4,LR}
   \   000000B0   0x4708             BX       R1
    802                }         
    803              }
    804            }
    805          } 
   \                     ??HAL_DMA2D_IRQHandler_2: (+1)
   \   000000B2   0xBD10             POP      {R4,PC}          ;; return
    806          
    807          /**
    808            * @}
    809            */
    810          
    811          /** @defgroup DMA2D_Group3 Peripheral Control functions
    812           *  @brief    Peripheral Control functions 
    813           *
    814          @verbatim   
    815           ===============================================================================
    816                              ##### Peripheral Control functions #####
    817           ===============================================================================  
    818              [..]  This section provides functions allowing to:
    819                (+) Configure the DMA2D foreground or/and background parameters.
    820                (+) Configure the DMA2D CLUT transfer.
    821                (+) Enable DMA2D CLUT.
    822                (+) Disable DMA2D CLUT.
    823                (+) Configure the line watermark
    824          
    825          @endverbatim
    826            * @{
    827            */
    828          /**
    829            * @brief  Configure the DMA2D Layer according to the specified
    830            *         parameters in the DMA2D_InitTypeDef and create the associated handle.
    831            * @param  hdma2d: pointer to a DMA2D_HandleTypeDef structure that contains
    832            *                 the configuration information for the DMA2D.
    833            * @param  LayerIdx: DMA2D Layer index.
    834            *                   This parameter can be one of the following values:
    835            *                   0(background) / 1(foreground)
    836            * @retval HAL status
    837            */

   \                                 In section .text, align 2, keep-with-next
    838          HAL_StatusTypeDef HAL_DMA2D_ConfigLayer(DMA2D_HandleTypeDef *hdma2d, uint32_t LayerIdx)
    839          { 
   \                     HAL_DMA2D_ConfigLayer: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
    840            DMA2D_LayerCfgTypeDef *pLayerCfg = &hdma2d->LayerCfg[LayerIdx];
   \   00000002   0xEB00 0x1201      ADD      R2,R0,R1, LSL #+4
    841            
    842            uint32_t tmp = 0;
    843            
    844            /* Process locked */
    845            __HAL_LOCK(hdma2d);
   \   00000006   0xF890 0x3038      LDRB     R3,[R0, #+56]
   \   0000000A   0x3218             ADDS     R2,R2,#+24
   \   0000000C   0x2B01             CMP      R3,#+1
   \   0000000E   0xBF08             IT       EQ 
   \   00000010   0x2002             MOVEQ    R0,#+2
   \   00000012   0xD05F             BEQ.N    ??HAL_DMA2D_ConfigLayer_0
   \   00000014   0x2301             MOVS     R3,#+1
    846            
    847            /* Change DMA2D peripheral state */
    848            hdma2d->State = HAL_DMA2D_STATE_BUSY; 
    849            
    850            /* Check the parameters */
    851            assert_param(IS_DMA2D_LAYER(LayerIdx));  
    852            assert_param(IS_DMA2D_OFFSET(pLayerCfg->InputOffset));  
    853            if(hdma2d->Init.Mode != DMA2D_R2M)
    854            {  
    855              assert_param(IS_DMA2D_INPUT_COLOR_MODE(pLayerCfg->InputColorMode));
    856              if(hdma2d->Init.Mode != DMA2D_M2M)
    857              {
    858                assert_param(IS_DMA2D_ALPHA_MODE(pLayerCfg->AlphaMode));
    859              }
    860            }
    861            
    862            /* Configure the background DMA2D layer */
    863            if(LayerIdx == 0)
   \   00000016   0x....             LDR.N    R5,??DataTable2  ;; 0xfcfff0
   \   00000018   0xF880 0x3038      STRB     R3,[R0, #+56]
   \   0000001C   0x2302             MOVS     R3,#+2
   \   0000001E   0xF880 0x3039      STRB     R3,[R0, #+57]
   \   00000022   0x6854             LDR      R4,[R2, #+4]
   \   00000024   0x6803             LDR      R3,[R0, #+0]
   \   00000026   0xBB39             CBNZ.N   R1,??HAL_DMA2D_ConfigLayer_1
    864            {
    865              /* DMA2D BGPFCR register configuration -----------------------------------*/
    866              /* Get the BGPFCCR register value */
    867              tmp = hdma2d->Instance->BGPFCCR;
   \   00000028   0x6A59             LDR      R1,[R3, #+36]
    868              
    869              /* Clear Input color mode, alpha value and alpha mode bits */
    870              tmp &= (uint32_t)~(DMA2D_BGPFCCR_CM | DMA2D_BGPFCCR_AM | DMA2D_BGPFCCR_ALPHA); 
   \   0000002A   0x4029             ANDS     R1,R5,R1
    871              
    872              if ((pLayerCfg->InputColorMode == CM_A4) || (pLayerCfg->InputColorMode == CM_A8))
   \   0000002C   0x2C0A             CMP      R4,#+10
   \   0000002E   0xBF18             IT       NE 
   \   00000030   0x2C09             CMPNE    R4,#+9
   \   00000032   0xD107             BNE.N    ??HAL_DMA2D_ConfigLayer_2
    873              {
    874                /* Prepare the value to be wrote to the BGPFCCR register */
    875                tmp |= (pLayerCfg->InputColorMode | (pLayerCfg->AlphaMode << 16) | ((pLayerCfg->InputAlpha) & 0xFF000000));
   \   00000034   0x6895             LDR      R5,[R2, #+8]
   \   00000036   0xEA44 0x4405      ORR      R4,R4,R5, LSL #+16
   \   0000003A   0x68D5             LDR      R5,[R2, #+12]
   \   0000003C   0xF005 0x457F      AND      R5,R5,#0xFF000000
   \   00000040   0x432C             ORRS     R4,R5,R4
   \   00000042   0xE005             B.N      ??HAL_DMA2D_ConfigLayer_3
    876              }
    877              else
    878              {
    879                /* Prepare the value to be wrote to the BGPFCCR register */
    880                tmp |= (pLayerCfg->InputColorMode | (pLayerCfg->AlphaMode << 16) | (pLayerCfg->InputAlpha << 24));
   \                     ??HAL_DMA2D_ConfigLayer_2: (+1)
   \   00000044   0x6895             LDR      R5,[R2, #+8]
   \   00000046   0xEA44 0x4405      ORR      R4,R4,R5, LSL #+16
   \   0000004A   0x68D5             LDR      R5,[R2, #+12]
   \   0000004C   0xEA44 0x6405      ORR      R4,R4,R5, LSL #+24
   \                     ??HAL_DMA2D_ConfigLayer_3: (+1)
   \   00000050   0x4321             ORRS     R1,R4,R1
    881              }
    882              
    883              /* Write to DMA2D BGPFCCR register */
    884              hdma2d->Instance->BGPFCCR = tmp; 
   \   00000052   0x6259             STR      R1,[R3, #+36]
    885              
    886              /* DMA2D BGOR register configuration -------------------------------------*/  
    887              /* Get the BGOR register value */
    888              tmp = hdma2d->Instance->BGOR;
   \   00000054   0x6801             LDR      R1,[R0, #+0]
   \   00000056   0x698B             LDR      R3,[R1, #+24]
    889              
    890              /* Clear colors bits */
    891              tmp &= (uint32_t)~DMA2D_BGOR_LO; 
    892              
    893              /* Prepare the value to be wrote to the BGOR register */
    894              tmp |= pLayerCfg->InputOffset;
    895              
    896              /* Write to DMA2D BGOR register */
    897              hdma2d->Instance->BGOR = tmp;
   \   00000058   0x6814             LDR      R4,[R2, #+0]
   \   0000005A   0x0B9B             LSRS     R3,R3,#+14
   \   0000005C   0xEA44 0x3383      ORR      R3,R4,R3, LSL #+14
   \   00000060   0x618B             STR      R3,[R1, #+24]
    898              
    899              if ((pLayerCfg->InputColorMode == CM_A4) || (pLayerCfg->InputColorMode == CM_A8))
   \   00000062   0x6851             LDR      R1,[R2, #+4]
   \   00000064   0x290A             CMP      R1,#+10
   \   00000066   0xBF18             IT       NE 
   \   00000068   0x2909             CMPNE    R1,#+9
   \   0000006A   0xD12C             BNE.N    ??HAL_DMA2D_ConfigLayer_4
    900              {
    901                /* Prepare the value to be wrote to the BGCOLR register */
    902                tmp = ((pLayerCfg->InputAlpha) & 0x00FFFFFF);
    903              
    904                /* Write to DMA2D BGCOLR register */
    905                hdma2d->Instance->BGCOLR = tmp;
   \   0000006C   0x68D1             LDR      R1,[R2, #+12]
   \   0000006E   0x6802             LDR      R2,[R0, #+0]
   \   00000070   0x0209             LSLS     R1,R1,#+8
   \   00000072   0x0A09             LSRS     R1,R1,#+8
   \   00000074   0x6291             STR      R1,[R2, #+40]
   \   00000076   0xE026             B.N      ??HAL_DMA2D_ConfigLayer_4
    906              }    
    907            }
    908            /* Configure the foreground DMA2D layer */
    909            else
    910            {
    911              /* DMA2D FGPFCR register configuration -----------------------------------*/
    912              /* Get the FGPFCCR register value */
    913              tmp = hdma2d->Instance->FGPFCCR;
   \                     ??HAL_DMA2D_ConfigLayer_1: (+1)
   \   00000078   0x69D9             LDR      R1,[R3, #+28]
    914              
    915              /* Clear Input color mode, alpha value and alpha mode bits */
    916              tmp &= (uint32_t)~(DMA2D_FGPFCCR_CM | DMA2D_FGPFCCR_AM | DMA2D_FGPFCCR_ALPHA); 
   \   0000007A   0x4029             ANDS     R1,R5,R1
    917              
    918              if ((pLayerCfg->InputColorMode == CM_A4) || (pLayerCfg->InputColorMode == CM_A8))
   \   0000007C   0x2C0A             CMP      R4,#+10
   \   0000007E   0xBF18             IT       NE 
   \   00000080   0x2C09             CMPNE    R4,#+9
   \   00000082   0xD107             BNE.N    ??HAL_DMA2D_ConfigLayer_5
    919              {
    920                /* Prepare the value to be wrote to the FGPFCCR register */
    921                tmp |= (pLayerCfg->InputColorMode | (pLayerCfg->AlphaMode << 16) | ((pLayerCfg->InputAlpha) & 0xFF000000));
   \   00000084   0x6895             LDR      R5,[R2, #+8]
   \   00000086   0xEA44 0x4405      ORR      R4,R4,R5, LSL #+16
   \   0000008A   0x68D5             LDR      R5,[R2, #+12]
   \   0000008C   0xF005 0x457F      AND      R5,R5,#0xFF000000
   \   00000090   0x432C             ORRS     R4,R5,R4
   \   00000092   0xE005             B.N      ??HAL_DMA2D_ConfigLayer_6
    922              }
    923              else
    924              {
    925                /* Prepare the value to be wrote to the FGPFCCR register */
    926                tmp |= (pLayerCfg->InputColorMode | (pLayerCfg->AlphaMode << 16) | (pLayerCfg->InputAlpha << 24));
   \                     ??HAL_DMA2D_ConfigLayer_5: (+1)
   \   00000094   0x6895             LDR      R5,[R2, #+8]
   \   00000096   0xEA44 0x4405      ORR      R4,R4,R5, LSL #+16
   \   0000009A   0x68D5             LDR      R5,[R2, #+12]
   \   0000009C   0xEA44 0x6405      ORR      R4,R4,R5, LSL #+24
   \                     ??HAL_DMA2D_ConfigLayer_6: (+1)
   \   000000A0   0x4321             ORRS     R1,R4,R1
    927              }
    928              
    929              /* Write to DMA2D FGPFCCR register */
    930              hdma2d->Instance->FGPFCCR = tmp; 
   \   000000A2   0x61D9             STR      R1,[R3, #+28]
    931              
    932              /* DMA2D FGOR register configuration -------------------------------------*/  
    933              /* Get the FGOR register value */
    934              tmp = hdma2d->Instance->FGOR;
   \   000000A4   0x6801             LDR      R1,[R0, #+0]
   \   000000A6   0x690B             LDR      R3,[R1, #+16]
    935              
    936              /* Clear colors bits */
    937              tmp &= (uint32_t)~DMA2D_FGOR_LO; 
    938              
    939              /* Prepare the value to be wrote to the FGOR register */
    940              tmp |= pLayerCfg->InputOffset;
    941              
    942              /* Write to DMA2D FGOR register */
    943              hdma2d->Instance->FGOR = tmp;
   \   000000A8   0x6814             LDR      R4,[R2, #+0]
   \   000000AA   0x0B9B             LSRS     R3,R3,#+14
   \   000000AC   0xEA44 0x3383      ORR      R3,R4,R3, LSL #+14
   \   000000B0   0x610B             STR      R3,[R1, #+16]
    944             
    945              if ((pLayerCfg->InputColorMode == CM_A4) || (pLayerCfg->InputColorMode == CM_A8))
   \   000000B2   0x6851             LDR      R1,[R2, #+4]
   \   000000B4   0x290A             CMP      R1,#+10
   \   000000B6   0xBF18             IT       NE 
   \   000000B8   0x2909             CMPNE    R1,#+9
   \   000000BA   0xD104             BNE.N    ??HAL_DMA2D_ConfigLayer_4
    946              {
    947                /* Prepare the value to be wrote to the FGCOLR register */
    948                tmp = ((pLayerCfg->InputAlpha) & 0x00FFFFFF);
    949              
    950                /* Write to DMA2D FGCOLR register */
    951                hdma2d->Instance->FGCOLR = tmp;
   \   000000BC   0x68D1             LDR      R1,[R2, #+12]
   \   000000BE   0x6802             LDR      R2,[R0, #+0]
   \   000000C0   0x0209             LSLS     R1,R1,#+8
   \   000000C2   0x0A09             LSRS     R1,R1,#+8
   \   000000C4   0x6211             STR      R1,[R2, #+32]
    952              }   
    953            }    
    954            /* Initialize the DMA2D state*/
    955            hdma2d->State  = HAL_DMA2D_STATE_READY;
   \                     ??HAL_DMA2D_ConfigLayer_4: (+1)
   \   000000C6   0x2101             MOVS     R1,#+1
   \   000000C8   0xF880 0x1039      STRB     R1,[R0, #+57]
    956            
    957            /* Process unlocked */
    958            __HAL_UNLOCK(hdma2d);  
   \   000000CC   0x2100             MOVS     R1,#+0
   \   000000CE   0xF880 0x1038      STRB     R1,[R0, #+56]
    959            
    960            return HAL_OK;
   \   000000D2   0x2000             MOVS     R0,#+0
   \                     ??HAL_DMA2D_ConfigLayer_0: (+1)
   \   000000D4   0xBC30             POP      {R4,R5}
   \   000000D6   0x4770             BX       LR               ;; return
    961          }
    962          
    963          /**
    964            * @brief  Configure the DMA2D CLUT Transfer.
    965            * @param  hdma2d:   pointer to a DMA2D_HandleTypeDef structure that contains
    966            *                   the configuration information for the DMA2D.
    967            * @param  CLUTCfg:  pointer to a DMA2D_CLUTCfgTypeDef structure that contains
    968            *                   the configuration information for the color look up table.
    969            * @param  LayerIdx: DMA2D Layer index.
    970            *                   This parameter can be one of the following values:
    971            *                   0(background) / 1(foreground)
    972            * @retval HAL status
    973            */

   \                                 In section .text, align 2, keep-with-next
    974          HAL_StatusTypeDef HAL_DMA2D_ConfigCLUT(DMA2D_HandleTypeDef *hdma2d, DMA2D_CLUTCfgTypeDef CLUTCfg, uint32_t LayerIdx)
    975          {
   \                     HAL_DMA2D_ConfigCLUT: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
    976            uint32_t tmp = 0, tmp1 = 0;
    977          
    978            /* Check the parameters */
    979            assert_param(IS_DMA2D_LAYER(LayerIdx));   
    980            assert_param(IS_DMA2D_CLUT_CM(CLUTCfg.CLUTColorMode));
    981            assert_param(IS_DMA2D_CLUT_SIZE(CLUTCfg.Size));
    982            
    983            /* Configure the CLUT of the background DMA2D layer */
    984            if(LayerIdx == 0)
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x....             LDR.N    R4,??DataTable2_1  ;; 0xffff00ef
   \   00000006   0x9D02             LDR      R5,[SP, #+8]
   \   00000008   0xB955             CBNZ.N   R5,??HAL_DMA2D_ConfigCLUT_0
    985            {
    986              /* Get the BGCMAR register value */
    987              tmp = hdma2d->Instance->BGCMAR;
   \   0000000A   0x6B05             LDR      R5,[R0, #+48]
    988          
    989              /* Clear CLUT address bits */
    990              tmp &= (uint32_t)~DMA2D_BGCMAR_MA; 
    991            
    992              /* Prepare the value to be wrote to the BGCMAR register */
    993              tmp |= (uint32_t)CLUTCfg.pCLUT;
    994            
    995              /* Write to DMA2D BGCMAR register */
    996              hdma2d->Instance->BGCMAR = tmp;
   \   0000000C   0x6301             STR      R1,[R0, #+48]
    997              
    998              /* Get the BGPFCCR register value */
    999              tmp = hdma2d->Instance->BGPFCCR;
   \   0000000E   0x6A41             LDR      R1,[R0, #+36]
   1000          
   1001              /* Clear CLUT size and CLUT address bits */
   1002              tmp &= (uint32_t)~(DMA2D_BGPFCCR_CS | DMA2D_BGPFCCR_CCM); 
   1003          
   1004              /* Get the CLUT size */
   1005              tmp1 = CLUTCfg.Size << 16;
   1006              
   1007              /* Prepare the value to be wrote to the BGPFCCR register */
   1008              tmp |= (CLUTCfg.CLUTColorMode | tmp1);
   1009            
   1010              /* Write to DMA2D BGPFCCR register */
   1011              hdma2d->Instance->BGPFCCR = tmp;       
   \   00000010   0x4021             ANDS     R1,R4,R1
   \   00000012   0x4311             ORRS     R1,R2,R1
   \   00000014   0xEA41 0x4103      ORR      R1,R1,R3, LSL #+16
   \   00000018   0x6241             STR      R1,[R0, #+36]
   1012            }
   1013            /* Configure the CLUT of the foreground DMA2D layer */
   1014            else
   1015            {
   1016              /* Get the FGCMAR register value */
   1017              tmp = hdma2d->Instance->FGCMAR;
   1018          
   1019              /* Clear CLUT address bits */
   1020              tmp &= (uint32_t)~DMA2D_FGCMAR_MA; 
   1021            
   1022              /* Prepare the value to be wrote to the FGCMAR register */
   1023              tmp |= (uint32_t)CLUTCfg.pCLUT;
   1024            
   1025              /* Write to DMA2D FGCMAR register */
   1026              hdma2d->Instance->FGCMAR = tmp;
   1027              
   1028              /* Get the FGPFCCR register value */
   1029              tmp = hdma2d->Instance->FGPFCCR;
   1030          
   1031              /* Clear CLUT size and CLUT address bits */
   1032              tmp &= (uint32_t)~(DMA2D_FGPFCCR_CS | DMA2D_FGPFCCR_CCM); 
   1033          
   1034              /* Get the CLUT size */
   1035              tmp1 = CLUTCfg.Size << 8;
   1036              
   1037              /* Prepare the value to be wrote to the FGPFCCR register */
   1038              tmp |= (CLUTCfg.CLUTColorMode | tmp1);
   1039            
   1040              /* Write to DMA2D FGPFCCR register */
   1041              hdma2d->Instance->FGPFCCR = tmp;    
   1042            }
   1043            
   1044            return HAL_OK;
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0xBC30             POP      {R4,R5}
   \   0000001E   0x4770             BX       LR
   \                     ??HAL_DMA2D_ConfigCLUT_0: (+1)
   \   00000020   0x6AC5             LDR      R5,[R0, #+44]
   \   00000022   0x62C1             STR      R1,[R0, #+44]
   \   00000024   0x69C1             LDR      R1,[R0, #+28]
   \   00000026   0x4021             ANDS     R1,R4,R1
   \   00000028   0x4311             ORRS     R1,R2,R1
   \   0000002A   0xEA41 0x2103      ORR      R1,R1,R3, LSL #+8
   \   0000002E   0x61C1             STR      R1,[R0, #+28]
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0xBC30             POP      {R4,R5}
   \   00000034   0x4770             BX       LR               ;; return
   1045          }
   1046          
   1047          /**
   1048            * @brief  Enable the DMA2D CLUT Transfer.
   1049            * @param  hdma2d:   pointer to a DMA2D_HandleTypeDef structure that contains
   1050            *                   the configuration information for the DMA2D.
   1051            * @param  LayerIdx: DMA2D Layer index.
   1052            *                   This parameter can be one of the following values:
   1053            *                   0(background) / 1(foreground)
   1054            * @retval HAL status
   1055            */

   \                                 In section .text, align 2, keep-with-next
   1056          HAL_StatusTypeDef HAL_DMA2D_EnableCLUT(DMA2D_HandleTypeDef *hdma2d, uint32_t LayerIdx)
   1057          {  
   1058            /* Check the parameters */
   1059            assert_param(IS_DMA2D_LAYER(LayerIdx));
   1060            
   1061            if(LayerIdx == 0)
   \                     HAL_DMA2D_EnableCLUT: (+1)
   \   00000000   0x6800             LDR      R0,[R0, #+0]
   \   00000002   0xB929             CBNZ.N   R1,??HAL_DMA2D_EnableCLUT_0
   1062            {
   1063              /* Enable the CLUT loading for the background */
   1064              hdma2d->Instance->BGPFCCR |= DMA2D_BGPFCCR_START;
   \   00000004   0x6A41             LDR      R1,[R0, #+36]
   \   00000006   0xF041 0x0120      ORR      R1,R1,#0x20
   \   0000000A   0x6241             STR      R1,[R0, #+36]
   1065            }
   1066            else
   1067            {
   1068              /* Enable the CLUT loading for the foreground */
   1069              hdma2d->Instance->FGPFCCR |= DMA2D_FGPFCCR_START;
   1070            }
   1071            
   1072            return HAL_OK;
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x4770             BX       LR
   \                     ??HAL_DMA2D_EnableCLUT_0: (+1)
   \   00000010   0x69C1             LDR      R1,[R0, #+28]
   \   00000012   0xF041 0x0120      ORR      R1,R1,#0x20
   \   00000016   0x61C1             STR      R1,[R0, #+28]
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x4770             BX       LR               ;; return
   1073          }
   1074          
   1075          /**
   1076            * @brief  Disable the DMA2D CLUT Transfer.
   1077            * @param  hdma2d:   pointer to a DMA2D_HandleTypeDef structure that contains
   1078            *                   the configuration information for the DMA2D.
   1079            * @param  LayerIdx: DMA2D Layer index.
   1080            *                   This parameter can be one of the following values:
   1081            *                   0(background) / 1(foreground)
   1082            * @retval HAL status
   1083            */

   \                                 In section .text, align 2, keep-with-next
   1084          HAL_StatusTypeDef HAL_DMA2D_DisableCLUT(DMA2D_HandleTypeDef *hdma2d, uint32_t LayerIdx)
   1085          {
   1086            /* Check the parameters */
   1087            assert_param(IS_DMA2D_LAYER(LayerIdx));
   1088            
   1089            if(LayerIdx == 0)
   \                     HAL_DMA2D_DisableCLUT: (+1)
   \   00000000   0x6800             LDR      R0,[R0, #+0]
   \   00000002   0xB929             CBNZ.N   R1,??HAL_DMA2D_DisableCLUT_0
   1090            {
   1091              /* Disable the CLUT loading for the background */
   1092              hdma2d->Instance->BGPFCCR &= ~DMA2D_BGPFCCR_START;
   \   00000004   0x6A41             LDR      R1,[R0, #+36]
   \   00000006   0xF021 0x0120      BIC      R1,R1,#0x20
   \   0000000A   0x6241             STR      R1,[R0, #+36]
   1093            }
   1094            else
   1095            {
   1096              /* Disable the CLUT loading for the foreground */
   1097              hdma2d->Instance->FGPFCCR &= ~DMA2D_FGPFCCR_START;
   1098            } 
   1099            
   1100            return HAL_OK;
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x4770             BX       LR
   \                     ??HAL_DMA2D_DisableCLUT_0: (+1)
   \   00000010   0x69C1             LDR      R1,[R0, #+28]
   \   00000012   0xF021 0x0120      BIC      R1,R1,#0x20
   \   00000016   0x61C1             STR      R1,[R0, #+28]
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x4770             BX       LR               ;; return
   1101          }
   1102          
   1103          /**
   1104            * @brief  Define the configuration of the line watermark .
   1105            * @param  hdma2d: pointer to a DMA2D_HandleTypeDef structure that contains
   1106            *                 the configuration information for the DMA2D.
   1107            * @param  Line:   Line Watermark configuration.
   1108            * @retval HAL status
   1109            */
   1110          

   \                                 In section .text, align 2, keep-with-next
   1111          HAL_StatusTypeDef HAL_DMA2D_ProgramLineEvent(DMA2D_HandleTypeDef *hdma2d, uint32_t Line)
   1112          {
   1113            /* Process locked */
   1114            __HAL_LOCK(hdma2d);
   \                     HAL_DMA2D_ProgramLineEvent: (+1)
   \   00000000   0xF890 0x2038      LDRB     R2,[R0, #+56]
   \   00000004   0x2A01             CMP      R2,#+1
   \   00000006   0xD101             BNE.N    ??HAL_DMA2D_ProgramLineEvent_0
   \   00000008   0x2002             MOVS     R0,#+2
   \   0000000A   0x4770             BX       LR
   \                     ??HAL_DMA2D_ProgramLineEvent_0: (+1)
   \   0000000C   0x2201             MOVS     R2,#+1
   \   0000000E   0xF880 0x2038      STRB     R2,[R0, #+56]
   1115            
   1116            /* Change DMA2D peripheral state */
   1117            hdma2d->State = HAL_DMA2D_STATE_BUSY;
   \   00000012   0x2202             MOVS     R2,#+2
   \   00000014   0xF880 0x2039      STRB     R2,[R0, #+57]
   1118            
   1119            /* Check the parameters */
   1120            assert_param(IS_DMA2D_LineWatermark(Line));
   1121          
   1122            /* Sets the Line watermark configuration */
   1123            DMA2D->LWR = (uint32_t)Line;
   \   00000018   0x....             LDR.N    R2,??DataTable2_2  ;; 0x4002b048
   \   0000001A   0x6011             STR      R1,[R2, #+0]
   1124            
   1125            /* Initialize the DMA2D state*/
   1126            hdma2d->State = HAL_DMA2D_STATE_READY;
   \   0000001C   0x2101             MOVS     R1,#+1
   \   0000001E   0xF880 0x1039      STRB     R1,[R0, #+57]
   1127            
   1128            /* Process unlocked */
   1129            __HAL_UNLOCK(hdma2d);  
   \   00000022   0x2100             MOVS     R1,#+0
   \   00000024   0xF880 0x1038      STRB     R1,[R0, #+56]
   1130            
   1131            return HAL_OK;  
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0x4770             BX       LR               ;; return
   1132          }
   1133          
   1134          /**
   1135            * @}
   1136            */
   1137          
   1138          /** @defgroup DMA2D_Group4 Peripheral State functions
   1139           *  @brief    Peripheral State functions 
   1140           *
   1141          @verbatim   
   1142           ===============================================================================
   1143                            ##### Peripheral State and Errors functions #####
   1144           ===============================================================================  
   1145              [..]
   1146              This subsection provides functions allowing to :
   1147                (+) Check the DMA2D state
   1148                (+) Get error code  
   1149          
   1150          @endverbatim
   1151            * @{
   1152            */ 
   1153          
   1154          /**
   1155            * @brief  Return the DMA2D state
   1156            * @param  hdma2d: pointer to a DMA2D_HandleTypeDef structure that contains
   1157            *                 the configuration information for the DMA2D.  
   1158            * @retval HAL state
   1159            */

   \                                 In section .text, align 2, keep-with-next
   1160          HAL_DMA2D_StateTypeDef HAL_DMA2D_GetState(DMA2D_HandleTypeDef *hdma2d)
   1161          {  
   1162            return hdma2d->State;
   \                     HAL_DMA2D_GetState: (+1)
   \   00000000   0xF890 0x0039      LDRB     R0,[R0, #+57]
   \   00000004   0x4770             BX       LR               ;; return
   1163          }
   1164          
   1165          /**
   1166            * @brief  Return the DMA2D error code
   1167            * @param  hdma2d : pointer to a DMA2D_HandleTypeDef structure that contains
   1168            *               the configuration information for DMA2D.
   1169            * @retval DMA2D Error Code
   1170            */

   \                                 In section .text, align 2, keep-with-next
   1171          uint32_t HAL_DMA2D_GetError(DMA2D_HandleTypeDef *hdma2d)
   1172          {
   1173            return hdma2d->ErrorCode;
   \                     HAL_DMA2D_GetError: (+1)
   \   00000000   0x6BC0             LDR      R0,[R0, #+60]
   \   00000002   0x4770             BX       LR               ;; return
   1174          }
   1175          
   1176          /**
   1177            * @}
   1178            */
   1179          
   1180          
   1181          /**
   1182            * @brief  Set the DMA2D Transfer parameter.
   1183            * @param  hdma2d:     pointer to a DMA2D_HandleTypeDef structure that contains
   1184            *                     the configuration information for the specified DMA2D.  
   1185            * @param  pdata:      The source memory Buffer address
   1186            * @param  DstAddress: The destination memory Buffer address
   1187            * @param  Width:      The width of data to be transferred from source to destination.
   1188            * @param  Height:     The height of data to be transferred from source to destination.
   1189            * @retval HAL status
   1190            */

   \                                 In section .text, align 2, keep-with-next
   1191          static void DMA2D_SetConfig(DMA2D_HandleTypeDef *hdma2d, uint32_t pdata, uint32_t DstAddress, uint32_t Width, uint32_t Height)
   1192          {  
   \                     DMA2D_SetConfig: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
   1193            uint32_t tmp = 0;
   1194            uint32_t tmp1 = 0;
   1195            uint32_t tmp2 = 0;
   1196            uint32_t tmp3 = 0;
   1197            uint32_t tmp4 = 0;
   1198            
   1199            tmp = Width << 16;
   1200            
   1201            /* Configure DMA2D data size */
   1202            hdma2d->Instance->NLR = (Height | tmp);
   \   00000002   0x6804             LDR      R4,[R0, #+0]
   \   00000004   0x9D02             LDR      R5,[SP, #+8]
   \   00000006   0xEA45 0x4303      ORR      R3,R5,R3, LSL #+16
   \   0000000A   0x6463             STR      R3,[R4, #+68]
   1203            
   1204            /* Configure DMA2D destination address */
   1205            hdma2d->Instance->OMAR = DstAddress;
   \   0000000C   0x63E2             STR      R2,[R4, #+60]
   1206           
   1207            /* Register to memory DMA2D mode selected */
   1208            if (hdma2d->Init.Mode == DMA2D_R2M)
   \   0000000E   0x6842             LDR      R2,[R0, #+4]
   \   00000010   0xF5B2 0x3F40      CMP      R2,#+196608
   \   00000014   0xD13F             BNE.N    ??DMA2D_SetConfig_0
   1209            {    
   1210              tmp1 = pdata & DMA2D_OCOLR_ALPHA_1;
   1211              tmp2 = pdata & DMA2D_OCOLR_RED_1;
   1212              tmp3 = pdata & DMA2D_OCOLR_GREEN_1;
   1213              tmp4 = pdata & DMA2D_OCOLR_BLUE_1;
   1214              
   1215              /* Prepare the value to be wrote to the OCOLR register according to the color mode */
   1216              if (hdma2d->Init.ColorMode == DMA2D_ARGB8888)
   \   00000016   0x6880             LDR      R0,[R0, #+8]
   \   00000018   0xF001 0x427F      AND      R2,R1,#0xFF000000
   \   0000001C   0xF401 0x037F      AND      R3,R1,#0xFF0000
   \   00000020   0xF401 0x457F      AND      R5,R1,#0xFF00
   \   00000024   0xB2C9             UXTB     R1,R1
   \   00000026   0xB930             CBNZ.N   R0,??DMA2D_SetConfig_1
   1217              {
   1218                tmp = (tmp3 | tmp2 | tmp1| tmp4);
   \   00000028   0xEA43 0x0005      ORR      R0,R3,R5
   \   0000002C   0x4310             ORRS     R0,R2,R0
   \   0000002E   0x4308             ORRS     R0,R1,R0
   1219              }
   1220              else if (hdma2d->Init.ColorMode == DMA2D_RGB888)
   1221              {
   1222                tmp = (tmp3 | tmp2 | tmp4);  
   1223              }
   1224              else if (hdma2d->Init.ColorMode == DMA2D_RGB565)
   1225              {
   1226                tmp2 = (tmp2 >> 19);
   1227                tmp3 = (tmp3 >> 10);
   1228                tmp4 = (tmp4 >> 3 );
   1229                tmp  = ((tmp3 << 5) | (tmp2 << 11) | tmp4); 
   1230              }
   1231              else if (hdma2d->Init.ColorMode == DMA2D_ARGB1555)
   1232              { 
   1233                tmp1 = (tmp1 >> 31);
   1234                tmp2 = (tmp2 >> 19);
   1235                tmp3 = (tmp3 >> 11);
   1236                tmp4 = (tmp4 >> 3 );      
   1237                tmp  = ((tmp3 << 5) | (tmp2 << 10) | (tmp1 << 15) | tmp4);    
   1238              } 
   1239              else /* DMA2D_CMode = DMA2D_ARGB4444 */
   1240              {
   1241                tmp1 = (tmp1 >> 28);
   1242                tmp2 = (tmp2 >> 20);
   1243                tmp3 = (tmp3 >> 12);
   1244                tmp4 = (tmp4 >> 4 );
   1245                tmp  = ((tmp3 << 4) | (tmp2 << 8) | (tmp1 << 12) | tmp4);
   1246              }    
   1247              /* Write to DMA2D OCOLR register */
   1248              hdma2d->Instance->OCOLR = tmp;
   \   00000030   0x63A0             STR      R0,[R4, #+56]
   1249            } 
   1250            else /* M2M, M2M_PFC or M2M_Blending DMA2D Mode */
   1251            {
   1252              /* Configure DMA2D source address */
   1253              hdma2d->Instance->FGMAR = pdata;
   1254            }
   1255          }
   \   00000032   0xBC30             POP      {R4,R5}
   \   00000034   0x4770             BX       LR
   \                     ??DMA2D_SetConfig_1: (+1)
   \   00000036   0x2801             CMP      R0,#+1
   \   00000038   0xD105             BNE.N    ??DMA2D_SetConfig_2
   \   0000003A   0xEA43 0x0005      ORR      R0,R3,R5
   \   0000003E   0x4308             ORRS     R0,R1,R0
   \   00000040   0x63A0             STR      R0,[R4, #+56]
   \   00000042   0xBC30             POP      {R4,R5}
   \   00000044   0x4770             BX       LR
   \                     ??DMA2D_SetConfig_2: (+1)
   \   00000046   0x2802             CMP      R0,#+2
   \   00000048   0xD109             BNE.N    ??DMA2D_SetConfig_3
   \   0000004A   0x0CDA             LSRS     R2,R3,#+19
   \   0000004C   0x0AA8             LSRS     R0,R5,#+10
   \   0000004E   0x02D2             LSLS     R2,R2,#+11
   \   00000050   0xEA42 0x1040      ORR      R0,R2,R0, LSL #+5
   \   00000054   0xEA40 0x00D1      ORR      R0,R0,R1, LSR #+3
   \   00000058   0x63A0             STR      R0,[R4, #+56]
   \   0000005A   0xBC30             POP      {R4,R5}
   \   0000005C   0x4770             BX       LR
   \                     ??DMA2D_SetConfig_3: (+1)
   \   0000005E   0x2803             CMP      R0,#+3
   \   00000060   0xD10C             BNE.N    ??DMA2D_SetConfig_4
   \   00000062   0x0CDB             LSRS     R3,R3,#+19
   \   00000064   0x0AE8             LSRS     R0,R5,#+11
   \   00000066   0x029B             LSLS     R3,R3,#+10
   \   00000068   0x0FD2             LSRS     R2,R2,#+31
   \   0000006A   0xEA43 0x1040      ORR      R0,R3,R0, LSL #+5
   \   0000006E   0xEA40 0x30C2      ORR      R0,R0,R2, LSL #+15
   \   00000072   0xEA40 0x00D1      ORR      R0,R0,R1, LSR #+3
   \   00000076   0x63A0             STR      R0,[R4, #+56]
   \   00000078   0xBC30             POP      {R4,R5}
   \   0000007A   0x4770             BX       LR
   \                     ??DMA2D_SetConfig_4: (+1)
   \   0000007C   0x0D1B             LSRS     R3,R3,#+20
   \   0000007E   0x0B28             LSRS     R0,R5,#+12
   \   00000080   0x021B             LSLS     R3,R3,#+8
   \   00000082   0x0F12             LSRS     R2,R2,#+28
   \   00000084   0xEA43 0x1000      ORR      R0,R3,R0, LSL #+4
   \   00000088   0xEA40 0x3002      ORR      R0,R0,R2, LSL #+12
   \   0000008C   0xEA40 0x1011      ORR      R0,R0,R1, LSR #+4
   \   00000090   0x63A0             STR      R0,[R4, #+56]
   \   00000092   0xBC30             POP      {R4,R5}
   \   00000094   0x4770             BX       LR
   \                     ??DMA2D_SetConfig_0: (+1)
   \   00000096   0x60E1             STR      R1,[R4, #+12]
   \   00000098   0xBC30             POP      {R4,R5}
   \   0000009A   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2:
   \   00000000   0x00FCFFF0         DC32     0xfcfff0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_1:
   \   00000000   0xFFFF00EF         DC32     0xffff00ef

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_2:
   \   00000000   0x4002B048         DC32     0x4002b048
   1256          
   1257          /**
   1258            * @}
   1259            */
   1260          #endif /* HAL_DMA2D_MODULE_ENABLED */
   1261          /**
   1262            * @}
   1263            */
   1264          
   1265          /**
   1266            * @}
   1267            */
   1268          
   1269          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   DMA2D_SetConfig
      16   HAL_DMA2D_Abort
        16   -> HAL_GetTick
      16   HAL_DMA2D_BlendingStart
        16   -> DMA2D_SetConfig
      16   HAL_DMA2D_BlendingStart_IT
        16   -> DMA2D_SetConfig
       8   HAL_DMA2D_ConfigCLUT
       8   HAL_DMA2D_ConfigLayer
       8   HAL_DMA2D_DeInit
         8   -> HAL_DMA2D_MspDeInit
       0   HAL_DMA2D_DisableCLUT
       0   HAL_DMA2D_EnableCLUT
       0   HAL_DMA2D_GetError
       0   HAL_DMA2D_GetState
       8   HAL_DMA2D_IRQHandler
         0   -- Indirect call
         8   -- Indirect call
       8   HAL_DMA2D_Init
         8   -> HAL_DMA2D_MspInit
       0   HAL_DMA2D_MspDeInit
       0   HAL_DMA2D_MspInit
      16   HAL_DMA2D_PollForTransfer
        16   -> HAL_GetTick
       0   HAL_DMA2D_ProgramLineEvent
       0   HAL_DMA2D_Resume
      16   HAL_DMA2D_Start
        16   -> DMA2D_SetConfig
      16   HAL_DMA2D_Start_IT
        16   -> DMA2D_SetConfig
      16   HAL_DMA2D_Suspend
        16   -> HAL_GetTick


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable2
       4  ??DataTable2_1
       4  ??DataTable2_2
     156  DMA2D_SetConfig
      82  HAL_DMA2D_Abort
      76  HAL_DMA2D_BlendingStart
     106  HAL_DMA2D_BlendingStart_IT
      54  HAL_DMA2D_ConfigCLUT
     216  HAL_DMA2D_ConfigLayer
      28  HAL_DMA2D_DeInit
      28  HAL_DMA2D_DisableCLUT
      28  HAL_DMA2D_EnableCLUT
       4  HAL_DMA2D_GetError
       6  HAL_DMA2D_GetState
     180  HAL_DMA2D_IRQHandler
      88  HAL_DMA2D_Init
       2  HAL_DMA2D_MspDeInit
       2  HAL_DMA2D_MspInit
     194  HAL_DMA2D_PollForTransfer
      44  HAL_DMA2D_ProgramLineEvent
      20  HAL_DMA2D_Resume
      66  HAL_DMA2D_Start
      96  HAL_DMA2D_Start_IT
      68  HAL_DMA2D_Suspend

 
 1 556 bytes in section .text
 
 1 556 bytes of CODE memory

Errors: none
Warnings: none
