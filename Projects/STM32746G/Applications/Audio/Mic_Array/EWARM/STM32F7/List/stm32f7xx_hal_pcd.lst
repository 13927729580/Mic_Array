###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.2.10312/W32 for ARM       27/Feb/2016  00:32:37
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_pcd.c
#    Command line =  
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_pcd.c
#        -D USE_HAL_DRIVER -D STM32F746xx -D USE_STM32746G_DISCO -D
#        USE_IOEXPANDER -D USE_USB_FS -lC
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
#        -lA
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
#        -o
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M7 -e --fpu=VFPv5_sp --dlib_config
#        "D:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Full.h" -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\Inc\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\CMSIS\Device\ST\STM32F7xx\Include\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\STM32F7xx_HAL_Driver\Inc\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\STM32746G-Discovery\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\Components\Common\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Log\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Fonts\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\CPU\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_Device_Library\Core\Inc\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Core\Inc\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Class\MSC\Inc\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\drivers\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_Audio\Addons\PDM\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_Device_Library\Class\AUDIO\Inc\
#        -Om --use_c++_inline --require_prototypes -I "D:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.3\arm\CMSIS\Include\" -D
#        ARM_MATH_CM7
#    List file    =  
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List\stm32f7xx_hal_pcd.lst
#    Object file  =  
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj\stm32f7xx_hal_pcd.o
#
###############################################################################

H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_pcd.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f7xx_hal_pcd.c
      4            * @author  MCD Application Team
      5            * @version V1.0.1
      6            * @date    25-June-2015
      7            * @brief   PCD HAL module driver.
      8            *          This file provides firmware functions to manage the following 
      9            *          functionalities of the USB Peripheral Controller:
     10            *           + Initialization and de-initialization functions
     11            *           + IO operation functions
     12            *           + Peripheral Control functions 
     13            *           + Peripheral State functions
     14            *         
     15            @verbatim
     16            ==============================================================================
     17                              ##### How to use this driver #####
     18            ==============================================================================
     19              [..]
     20                The PCD HAL driver can be used as follows:
     21          
     22               (#) Declare a PCD_HandleTypeDef handle structure, for example:
     23                   PCD_HandleTypeDef  hpcd;
     24                  
     25               (#) Fill parameters of Init structure in HCD handle
     26            
     27               (#) Call HAL_PCD_Init() API to initialize the HCD peripheral (Core, Device core, ...) 
     28          
     29               (#) Initialize the PCD low level resources through the HAL_PCD_MspInit() API:
     30                   (##) Enable the PCD/USB Low Level interface clock using 
     31                        (+++) __OTGFS-OTG_CLK_ENABLE()/__OTGHS-OTG_CLK_ENABLE();
     32                        (+++) __OTGHSULPI_CLK_ENABLE(); (For High Speed Mode)
     33                     
     34                   (##) Initialize the related GPIO clocks
     35                   (##) Configure PCD pin-out
     36                   (##) Configure PCD NVIC interrupt
     37              
     38               (#)Associate the Upper USB device stack to the HAL PCD Driver:
     39                   (##) hpcd.pData = pdev;
     40          
     41               (#)Enable HCD transmission and reception:
     42                   (##) HAL_PCD_Start();
     43          
     44            @endverbatim
     45            ******************************************************************************
     46            * @attention
     47            *
     48            * <h2><center>&copy; COPYRIGHT(c) 2015 STMicroelectronics</center></h2>
     49            *
     50            * Redistribution and use in source and binary forms, with or without modification,
     51            * are permitted provided that the following conditions are met:
     52            *   1. Redistributions of source code must retain the above copyright notice,
     53            *      this list of conditions and the following disclaimer.
     54            *   2. Redistributions in binary form must reproduce the above copyright notice,
     55            *      this list of conditions and the following disclaimer in the documentation
     56            *      and/or other materials provided with the distribution.
     57            *   3. Neither the name of STMicroelectronics nor the names of its contributors
     58            *      may be used to endorse or promote products derived from this software
     59            *      without specific prior written permission.
     60            *
     61            * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
     62            * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     63            * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     64            * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
     65            * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
     66            * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
     67            * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
     68            * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
     69            * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
     70            * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     71            *
     72            ******************************************************************************
     73            */ 
     74          
     75          /* Includes ------------------------------------------------------------------*/
     76          #include "stm32f7xx_hal.h"
     77          
     78          /** @addtogroup STM32F7xx_HAL_Driver
     79            * @{
     80            */
     81          
     82          /** @defgroup PCD PCD
     83            * @brief PCD HAL module driver
     84            * @{
     85            */
     86          
     87          #ifdef HAL_PCD_MODULE_ENABLED
     88          
     89          /* Private types -------------------------------------------------------------*/
     90          /* Private variables ---------------------------------------------------------*/
     91          /* Private constants ---------------------------------------------------------*/
     92          /* Private macros ------------------------------------------------------------*/
     93          /** @defgroup PCD_Private_Macros PCD Private Macros
     94            * @{
     95            */ 
     96          #define PCD_MIN(a, b)  (((a) < (b)) ? (a) : (b))
     97          #define PCD_MAX(a, b)  (((a) > (b)) ? (a) : (b))
     98          /**
     99            * @}
    100            */
    101          
    102          /* Private functions prototypes ----------------------------------------------*/
    103          /** @defgroup PCD_Private_Functions PCD Private Functions
    104            * @{
    105            */
    106          static HAL_StatusTypeDef PCD_WriteEmptyTxFifo(PCD_HandleTypeDef *hpcd, uint32_t epnum);
    107          /**
    108            * @}
    109            */
    110          
    111          /* Exported functions --------------------------------------------------------*/
    112          /** @defgroup PCD_Exported_Functions PCD Exported Functions
    113            * @{
    114            */
    115          
    116          /** @defgroup PCD_Exported_Functions_Group1 Initialization and de-initialization functions 
    117           *  @brief    Initialization and Configuration functions 
    118           *
    119          @verbatim    
    120           ===============================================================================
    121                      ##### Initialization and de-initialization functions #####
    122           ===============================================================================
    123              [..]  This section provides functions allowing to:
    124           
    125          @endverbatim
    126            * @{
    127            */
    128          
    129          /**
    130            * @brief  Initializes the PCD according to the specified
    131            *         parameters in the PCD_InitTypeDef and create the associated handle.
    132            * @param  hpcd: PCD handle
    133            * @retval HAL status
    134            */

   \                                 In section .text, align 2, keep-with-next
    135          HAL_StatusTypeDef HAL_PCD_Init(PCD_HandleTypeDef *hpcd)
    136          { 
   \                     HAL_PCD_Init: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB089             SUB      SP,SP,#+36
   \   00000004   0x4605             MOV      R5,R0
    137            uint32_t i = 0;
   \   00000006   0x2400             MOVS     R4,#+0
    138            
    139            /* Check the PCD handle allocation */
    140            if(hpcd == NULL)
   \   00000008   0x2D00             CMP      R5,#+0
   \   0000000A   0xD101             BNE.N    ??HAL_PCD_Init_0
    141            {
    142              return HAL_ERROR;
   \   0000000C   0x2001             MOVS     R0,#+1
   \   0000000E   0xE056             B.N      ??HAL_PCD_Init_1
    143            }
    144            
    145            /* Check the parameters */
    146            assert_param(IS_PCD_ALL_INSTANCE(hpcd->Instance));
    147          
    148            hpcd->State = HAL_PCD_STATE_BUSY;
   \                     ??HAL_PCD_Init_0: (+1)
   \   00000010   0x2003             MOVS     R0,#+3
   \   00000012   0xF885 0x037D      STRB     R0,[R5, #+893]
    149            
    150            /* Init the low level hardware : GPIO, CLOCK, NVIC... */
    151            HAL_PCD_MspInit(hpcd);
   \   00000016   0x4628             MOV      R0,R5
   \   00000018   0x.... 0x....      BL       HAL_PCD_MspInit
    152          
    153            /* Disable the Interrupts */
    154           __HAL_PCD_DISABLE(hpcd);
   \   0000001C   0x6828             LDR      R0,[R5, #+0]
   \   0000001E   0x.... 0x....      BL       USB_DisableGlobalInt
    155           
    156           /*Init the Core (common init.) */
    157           USB_CoreInit(hpcd->Instance, hpcd->Init);
   \   00000022   0x1D29             ADDS     R1,R5,#+4
   \   00000024   0xB083             SUB      SP,SP,#+12
   \   00000026   0x4668             MOV      R0,SP
   \   00000028   0x2230             MOVS     R2,#+48
   \   0000002A   0x.... 0x....      BL       __aeabi_memcpy4
   \   0000002E   0xBC0E             POP      {R1-R3}
   \   00000030   0x6828             LDR      R0,[R5, #+0]
   \   00000032   0x.... 0x....      BL       USB_CoreInit
    158           
    159           /* Force Device Mode*/
    160           USB_SetCurrentMode(hpcd->Instance , USB_OTG_DEVICE_MODE);
   \   00000036   0x4621             MOV      R1,R4
   \   00000038   0x6828             LDR      R0,[R5, #+0]
   \   0000003A   0x.... 0x....      BL       USB_SetCurrentMode
    161           
    162           /* Init endpoints structures */
    163           for (i = 0; i < 15 ; i++)
   \   0000003E   0xE00D             B.N      ??HAL_PCD_Init_2
    164           {
    165             /* Init ep structure */
    166             hpcd->IN_ep[i].is_in = 1;
   \                     ??HAL_PCD_Init_3: (+1)
   \   00000040   0x201C             MOVS     R0,#+28
   \   00000042   0xFB00 0x5004      MLA      R0,R0,R4,R5
   \   00000046   0x3034             ADDS     R0,R0,#+52
   \   00000048   0x2101             MOVS     R1,#+1
   \   0000004A   0x7041             STRB     R1,[R0, #+1]
    167             hpcd->IN_ep[i].num = i;
   \   0000004C   0x7004             STRB     R4,[R0, #+0]
    168             hpcd->IN_ep[i].tx_fifo_num = i;
   \   0000004E   0x80C4             STRH     R4,[R0, #+6]
    169             /* Control until ep is activated */
    170             hpcd->IN_ep[i].type = EP_TYPE_CTRL;
   \   00000050   0x2100             MOVS     R1,#+0
   \   00000052   0x70C1             STRB     R1,[R0, #+3]
    171             hpcd->IN_ep[i].maxpacket =  0;
   \   00000054   0x6081             STR      R1,[R0, #+8]
    172             hpcd->IN_ep[i].xfer_buff = 0;
   \   00000056   0x60C1             STR      R1,[R0, #+12]
    173             hpcd->IN_ep[i].xfer_len = 0;
   \   00000058   0x6141             STR      R1,[R0, #+20]
    174           }
   \   0000005A   0x1C64             ADDS     R4,R4,#+1
   \                     ??HAL_PCD_Init_2: (+1)
   \   0000005C   0x2C0F             CMP      R4,#+15
   \   0000005E   0xD3EF             BCC.N    ??HAL_PCD_Init_3
    175           
    176           for (i = 0; i < 15 ; i++)
   \   00000060   0x2400             MOVS     R4,#+0
   \   00000062   0x4622             MOV      R2,R4
   \   00000064   0xE012             B.N      ??HAL_PCD_Init_4
    177           {
    178             hpcd->OUT_ep[i].is_in = 0;
   \                     ??HAL_PCD_Init_5: (+1)
   \   00000066   0x201C             MOVS     R0,#+28
   \   00000068   0xFB00 0x5004      MLA      R0,R0,R4,R5
   \   0000006C   0xF500 0x71EC      ADD      R1,R0,#+472
   \   00000070   0x704A             STRB     R2,[R1, #+1]
    179             hpcd->OUT_ep[i].num = i;
   \   00000072   0x700C             STRB     R4,[R1, #+0]
    180             hpcd->IN_ep[i].tx_fifo_num = i;
   \   00000074   0x8744             STRH     R4,[R0, #+58]
    181             /* Control until ep is activated */
    182             hpcd->OUT_ep[i].type = EP_TYPE_CTRL;
   \   00000076   0x4610             MOV      R0,R2
   \   00000078   0x70C8             STRB     R0,[R1, #+3]
    183             hpcd->OUT_ep[i].maxpacket = 0;
   \   0000007A   0x6088             STR      R0,[R1, #+8]
    184             hpcd->OUT_ep[i].xfer_buff = 0;
   \   0000007C   0x60C8             STR      R0,[R1, #+12]
    185             hpcd->OUT_ep[i].xfer_len = 0;
   \   0000007E   0x6148             STR      R0,[R1, #+20]
    186             
    187             hpcd->Instance->DIEPTXF[i] = 0;
   \   00000080   0x6829             LDR      R1,[R5, #+0]
   \   00000082   0xEB01 0x0184      ADD      R1,R1,R4, LSL #+2
   \   00000086   0xF8C1 0x0104      STR      R0,[R1, #+260]
    188           }
   \   0000008A   0x1C64             ADDS     R4,R4,#+1
   \                     ??HAL_PCD_Init_4: (+1)
   \   0000008C   0x2C0F             CMP      R4,#+15
   \   0000008E   0xD3EA             BCC.N    ??HAL_PCD_Init_5
    189           
    190           /* Init Device */
    191           USB_DevInit(hpcd->Instance, hpcd->Init);
   \   00000090   0x1D29             ADDS     R1,R5,#+4
   \   00000092   0xB083             SUB      SP,SP,#+12
   \   00000094   0x4668             MOV      R0,SP
   \   00000096   0x2230             MOVS     R2,#+48
   \   00000098   0x.... 0x....      BL       __aeabi_memcpy4
   \   0000009C   0xBC0E             POP      {R1-R3}
   \   0000009E   0x6828             LDR      R0,[R5, #+0]
   \   000000A0   0x.... 0x....      BL       USB_DevInit
    192           
    193           hpcd->State= HAL_PCD_STATE_READY;
   \   000000A4   0x2001             MOVS     R0,#+1
   \   000000A6   0xF885 0x037D      STRB     R0,[R5, #+893]
    194           
    195           /* Activate LPM */
    196           if (hpcd->Init.lpm_enable == 1)
   \   000000AA   0x6A68             LDR      R0,[R5, #+36]
   \   000000AC   0x2801             CMP      R0,#+1
   \   000000AE   0xD102             BNE.N    ??HAL_PCD_Init_6
    197           {
    198             HAL_PCDEx_ActivateLPM(hpcd);
   \   000000B0   0x4628             MOV      R0,R5
   \   000000B2   0x.... 0x....      BL       HAL_PCDEx_ActivateLPM
    199           }
    200           
    201           USB_DevDisconnect (hpcd->Instance);  
   \                     ??HAL_PCD_Init_6: (+1)
   \   000000B6   0x6828             LDR      R0,[R5, #+0]
   \   000000B8   0x.... 0x....      BL       USB_DevDisconnect
    202           return HAL_OK;
   \   000000BC   0x2000             MOVS     R0,#+0
   \                     ??HAL_PCD_Init_1: (+1)
   \   000000BE   0xB009             ADD      SP,SP,#+36
   \   000000C0   0xBD30             POP      {R4,R5,PC}       ;; return
    203          }
    204          
    205          /**
    206            * @brief  DeInitializes the PCD peripheral 
    207            * @param  hpcd: PCD handle
    208            * @retval HAL status
    209            */

   \                                 In section .text, align 2, keep-with-next
    210          HAL_StatusTypeDef HAL_PCD_DeInit(PCD_HandleTypeDef *hpcd)
    211          {
   \                     HAL_PCD_DeInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    212            /* Check the PCD handle allocation */
    213            if(hpcd == NULL)
   \   00000004   0xD101             BNE.N    ??HAL_PCD_DeInit_0
    214            {
    215              return HAL_ERROR;
   \   00000006   0x2001             MOVS     R0,#+1
   \   00000008   0xBD10             POP      {R4,PC}
    216            }
    217          
    218            hpcd->State = HAL_PCD_STATE_BUSY;
   \                     ??HAL_PCD_DeInit_0: (+1)
   \   0000000A   0x2003             MOVS     R0,#+3
   \   0000000C   0xF884 0x037D      STRB     R0,[R4, #+893]
    219            
    220            /* Stop Device */
    221            HAL_PCD_Stop(hpcd);
   \   00000010   0x4620             MOV      R0,R4
   \   00000012   0x.... 0x....      BL       HAL_PCD_Stop
    222              
    223            /* DeInit the low level hardware */
    224            HAL_PCD_MspDeInit(hpcd);
   \   00000016   0x4620             MOV      R0,R4
   \   00000018   0x.... 0x....      BL       HAL_PCD_MspDeInit
    225            
    226            hpcd->State = HAL_PCD_STATE_RESET; 
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0xF884 0x037D      STRB     R0,[R4, #+893]
    227            
    228            return HAL_OK;
   \   00000022   0xBD10             POP      {R4,PC}          ;; return
    229          }
    230          
    231          /**
    232            * @brief  Initializes the PCD MSP.
    233            * @param  hpcd: PCD handle
    234            * @retval None
    235            */

   \                                 In section .text, align 2, keep-with-next
    236          __weak void HAL_PCD_MspInit(PCD_HandleTypeDef *hpcd)
    237          {
    238            /* NOTE : This function Should not be modified, when the callback is needed,
    239                      the HAL_PCD_MspInit could be implemented in the user file
    240             */
    241          }
   \                     HAL_PCD_MspInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    242          
    243          /**
    244            * @brief  DeInitializes PCD MSP.
    245            * @param  hpcd: PCD handle
    246            * @retval None
    247            */

   \                                 In section .text, align 2, keep-with-next
    248          __weak void HAL_PCD_MspDeInit(PCD_HandleTypeDef *hpcd)
    249          {
    250            /* NOTE : This function Should not be modified, when the callback is needed,
    251                      the HAL_PCD_MspDeInit could be implemented in the user file
    252             */
    253          }
   \                     HAL_PCD_MspDeInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    254          
    255          /**
    256            * @}
    257            */
    258          
    259          /** @defgroup PCD_Exported_Functions_Group2 IO operation functions 
    260           *  @brief   Data transfers functions 
    261           *
    262          @verbatim   
    263           ===============================================================================
    264                                ##### IO operation functions #####
    265           ===============================================================================  
    266              [..]
    267              This subsection provides a set of functions allowing to manage the PCD data 
    268              transfers.
    269          
    270          @endverbatim
    271            * @{
    272            */
    273            
    274          /**
    275            * @brief  Start The USB OTG Device.
    276            * @param  hpcd: PCD handle
    277            * @retval HAL status
    278            */

   \                                 In section .text, align 2, keep-with-next
    279          HAL_StatusTypeDef HAL_PCD_Start(PCD_HandleTypeDef *hpcd)
    280          { 
   \                     HAL_PCD_Start: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    281            __HAL_LOCK(hpcd); 
   \   00000004   0xF894 0x037C      LDRB     R0,[R4, #+892]
   \   00000008   0x2801             CMP      R0,#+1
   \   0000000A   0xD101             BNE.N    ??HAL_PCD_Start_0
   \   0000000C   0x2002             MOVS     R0,#+2
   \   0000000E   0xBD10             POP      {R4,PC}
   \                     ??HAL_PCD_Start_0: (+1)
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0xF884 0x037C      STRB     R0,[R4, #+892]
    282            USB_DevConnect (hpcd->Instance);  
   \   00000016   0x6820             LDR      R0,[R4, #+0]
   \   00000018   0x.... 0x....      BL       USB_DevConnect
    283            __HAL_PCD_ENABLE(hpcd);
   \   0000001C   0x6820             LDR      R0,[R4, #+0]
   \   0000001E   0x.... 0x....      BL       USB_EnableGlobalInt
    284            __HAL_UNLOCK(hpcd); 
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0xF884 0x037C      STRB     R0,[R4, #+892]
    285            return HAL_OK;
   \   00000028   0xBD10             POP      {R4,PC}          ;; return
    286          }
    287          
    288          /**
    289            * @brief  Stop The USB OTG Device.
    290            * @param  hpcd: PCD handle
    291            * @retval HAL status
    292            */

   \                                 In section .text, align 2, keep-with-next
    293          HAL_StatusTypeDef HAL_PCD_Stop(PCD_HandleTypeDef *hpcd)
    294          { 
   \                     HAL_PCD_Stop: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    295            __HAL_LOCK(hpcd); 
   \   00000004   0xF894 0x037C      LDRB     R0,[R4, #+892]
   \   00000008   0x2801             CMP      R0,#+1
   \   0000000A   0xD101             BNE.N    ??HAL_PCD_Stop_0
   \   0000000C   0x2002             MOVS     R0,#+2
   \   0000000E   0xBD10             POP      {R4,PC}
   \                     ??HAL_PCD_Stop_0: (+1)
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0xF884 0x037C      STRB     R0,[R4, #+892]
    296            __HAL_PCD_DISABLE(hpcd);
   \   00000016   0x6820             LDR      R0,[R4, #+0]
   \   00000018   0x.... 0x....      BL       USB_DisableGlobalInt
    297            USB_StopDevice(hpcd->Instance);
   \   0000001C   0x6820             LDR      R0,[R4, #+0]
   \   0000001E   0x.... 0x....      BL       USB_StopDevice
    298            USB_DevDisconnect (hpcd->Instance);
   \   00000022   0x6820             LDR      R0,[R4, #+0]
   \   00000024   0x.... 0x....      BL       USB_DevDisconnect
    299            __HAL_UNLOCK(hpcd); 
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0xF884 0x037C      STRB     R0,[R4, #+892]
    300            return HAL_OK;
   \   0000002E   0xBD10             POP      {R4,PC}          ;; return
    301          }
    302          
    303          /**
    304            * @brief  This function handles PCD interrupt request.
    305            * @param  hpcd: PCD handle
    306            * @retval HAL status
    307            */

   \                                 In section .text, align 2, keep-with-next
    308          void HAL_PCD_IRQHandler(PCD_HandleTypeDef *hpcd)
    309          {
   \                     HAL_PCD_IRQHandler: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x4604             MOV      R4,R0
    310            USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
   \   00000006   0x6820             LDR      R0,[R4, #+0]
   \   00000008   0x9000             STR      R0,[SP, #+0]
    311            uint32_t i = 0, ep_intr = 0, epint = 0, epnum = 0;
   \   0000000A   0x2600             MOVS     R6,#+0
   \   0000000C   0x4635             MOV      R5,R6
    312            uint32_t fifoemptymsk = 0, temp = 0;
    313            USB_OTG_EPTypeDef *ep;
    314              
    315            /* ensure that we are in device mode */
    316            if (USB_GetMode(hpcd->Instance) == USB_OTG_MODE_DEVICE)
   \   0000000E   0x.... 0x....      BL       USB_GetMode
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xF040 0x8228      BNE.W    ??HAL_PCD_IRQHandler_0
    317            {
    318              /* avoid spurious interrupt */
    319              if(__HAL_PCD_IS_INVALID_INTERRUPT(hpcd)) 
   \   00000018   0x6820             LDR      R0,[R4, #+0]
   \   0000001A   0x.... 0x....      BL       USB_ReadInterrupts
   \   0000001E   0x2800             CMP      R0,#+0
   \   00000020   0xF000 0x8222      BEQ.W    ??HAL_PCD_IRQHandler_0
    320              {
    321                return;
    322              }
    323              
    324              if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_MMIS))
   \   00000024   0x6820             LDR      R0,[R4, #+0]
   \   00000026   0x.... 0x....      BL       USB_ReadInterrupts
   \   0000002A   0x0780             LSLS     R0,R0,#+30
   \   0000002C   0xD502             BPL.N    ??HAL_PCD_IRQHandler_1
    325              {
    326               /* incorrect mode, acknowledge the interrupt */
    327                __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_MMIS);
   \   0000002E   0x2002             MOVS     R0,#+2
   \   00000030   0x6821             LDR      R1,[R4, #+0]
   \   00000032   0x6148             STR      R0,[R1, #+20]
   \                     ??HAL_PCD_IRQHandler_1: (+1)
   \   00000034   0x6820             LDR      R0,[R4, #+0]
    328              }
    329              
    330              if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_OEPINT))
   \   00000036   0x.... 0x....      BL       USB_ReadInterrupts
   \   0000003A   0x0300             LSLS     R0,R0,#+12
   \   0000003C   0xD556             BPL.N    ??HAL_PCD_IRQHandler_2
    331              {
    332                epnum = 0;
    333                
    334                /* Read in the device interrupt bits */
    335                ep_intr = USB_ReadDevAllOutEpInterrupt(hpcd->Instance);
   \   0000003E   0x6820             LDR      R0,[R4, #+0]
   \   00000040   0x.... 0x....      BL       USB_ReadDevAllOutEpInterrupt
   \   00000044   0x0007             MOVS     R7,R0
   \   00000046   0xE050             B.N      ??HAL_PCD_IRQHandler_3
    336                
    337                while ( ep_intr )
    338                {
    339                  if (ep_intr & 0x1)
   \                     ??HAL_PCD_IRQHandler_4: (+1)
   \   00000048   0x07F8             LSLS     R0,R7,#+31
   \   0000004A   0xD54C             BPL.N    ??HAL_PCD_IRQHandler_5
    340                  {
    341                    epint = USB_ReadDevOutEPInterrupt(hpcd->Instance, epnum);
   \   0000004C   0x4629             MOV      R1,R5
   \   0000004E   0xB2C9             UXTB     R1,R1
   \   00000050   0x6820             LDR      R0,[R4, #+0]
   \   00000052   0x.... 0x....      BL       USB_ReadDevOutEPInterrupt
   \   00000056   0x4680             MOV      R8,R0
    342                    
    343                    if(( epint & USB_OTG_DOEPINT_XFRC) == USB_OTG_DOEPINT_XFRC)
   \   00000058   0xEA5F 0x70C8      LSLS     R0,R8,#+31
   \   0000005C   0xD52C             BPL.N    ??HAL_PCD_IRQHandler_6
    344                    {
    345                      CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_XFRC);
   \   0000005E   0x9800             LDR      R0,[SP, #+0]
   \   00000060   0xEB00 0x1045      ADD      R0,R0,R5, LSL #+5
   \   00000064   0xF500 0x6030      ADD      R0,R0,#+2816
   \   00000068   0x2101             MOVS     R1,#+1
   \   0000006A   0x6081             STR      R1,[R0, #+8]
    346                      
    347                      if(hpcd->Init.dma_enable == 1)
   \   0000006C   0x6921             LDR      R1,[R4, #+16]
   \   0000006E   0x2901             CMP      R1,#+1
   \   00000070   0xD10E             BNE.N    ??HAL_PCD_IRQHandler_7
    348                      {
    349                        hpcd->OUT_ep[epnum].xfer_count = hpcd->OUT_ep[epnum].maxpacket- (USBx_OUTEP(epnum)->DOEPTSIZ & USB_OTG_DOEPTSIZ_XFRSIZ); 
   \   00000072   0x211C             MOVS     R1,#+28
   \   00000074   0xFB01 0x4105      MLA      R1,R1,R5,R4
   \   00000078   0xF501 0x71F0      ADD      R1,R1,#+480
   \   0000007C   0x680A             LDR      R2,[R1, #+0]
   \   0000007E   0x6900             LDR      R0,[R0, #+16]
   \   00000080   0x0340             LSLS     R0,R0,#+13
   \   00000082   0xEBB2 0x3050      SUBS     R0,R2,R0, LSR #+13
   \   00000086   0x6108             STR      R0,[R1, #+16]
    350                        hpcd->OUT_ep[epnum].xfer_buff += hpcd->OUT_ep[epnum].maxpacket;            
   \   00000088   0x6848             LDR      R0,[R1, #+4]
   \   0000008A   0x680A             LDR      R2,[R1, #+0]
   \   0000008C   0x1810             ADDS     R0,R2,R0
   \   0000008E   0x6048             STR      R0,[R1, #+4]
    351                      }
    352                      
    353                      HAL_PCD_DataOutStageCallback(hpcd, epnum);
   \                     ??HAL_PCD_IRQHandler_7: (+1)
   \   00000090   0x4629             MOV      R1,R5
   \   00000092   0xB2C9             UXTB     R1,R1
   \   00000094   0x4620             MOV      R0,R4
   \   00000096   0x.... 0x....      BL       HAL_PCD_DataOutStageCallback
    354                      if(hpcd->Init.dma_enable == 1)
   \   0000009A   0x6920             LDR      R0,[R4, #+16]
   \   0000009C   0x2801             CMP      R0,#+1
   \   0000009E   0xD10B             BNE.N    ??HAL_PCD_IRQHandler_6
    355                      {
    356                        if((epnum == 0) && (hpcd->OUT_ep[epnum].xfer_len == 0))
   \   000000A0   0x2D00             CMP      R5,#+0
   \   000000A2   0xD109             BNE.N    ??HAL_PCD_IRQHandler_6
   \   000000A4   0xF8D4 0x01EC      LDR      R0,[R4, #+492]
   \   000000A8   0x2800             CMP      R0,#+0
   \   000000AA   0xD105             BNE.N    ??HAL_PCD_IRQHandler_6
    357                        {
    358                           /* this is ZLP, so prepare EP0 for next setup */
    359                          USB_EP0_OutStart(hpcd->Instance, 1, (uint8_t *)hpcd->Setup);
   \   000000AC   0xF504 0x7260      ADD      R2,R4,#+896
   \   000000B0   0x2101             MOVS     R1,#+1
   \   000000B2   0x6820             LDR      R0,[R4, #+0]
   \   000000B4   0x.... 0x....      BL       USB_EP0_OutStart
    360                        }              
    361                      }
    362                    }
    363                    
    364                    if(( epint & USB_OTG_DOEPINT_STUP) == USB_OTG_DOEPINT_STUP)
   \                     ??HAL_PCD_IRQHandler_6: (+1)
   \   000000B8   0xEA5F 0x7008      LSLS     R0,R8,#+28
   \   000000BC   0xD509             BPL.N    ??HAL_PCD_IRQHandler_8
    365                    {
    366                      /* Inform the upper layer that a setup packet is available */
    367                      HAL_PCD_SetupStageCallback(hpcd);
   \   000000BE   0x4620             MOV      R0,R4
   \   000000C0   0x.... 0x....      BL       HAL_PCD_SetupStageCallback
    368                      CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_STUP);
   \   000000C4   0x9800             LDR      R0,[SP, #+0]
   \   000000C6   0xEB00 0x1045      ADD      R0,R0,R5, LSL #+5
   \   000000CA   0xF500 0x6030      ADD      R0,R0,#+2816
   \   000000CE   0x2108             MOVS     R1,#+8
   \   000000D0   0x6081             STR      R1,[R0, #+8]
    369                    }
    370                    
    371                    if(( epint & USB_OTG_DOEPINT_OTEPDIS) == USB_OTG_DOEPINT_OTEPDIS)
   \                     ??HAL_PCD_IRQHandler_8: (+1)
   \   000000D2   0xEA5F 0x60C8      LSLS     R0,R8,#+27
   \   000000D6   0xD506             BPL.N    ??HAL_PCD_IRQHandler_5
    372                    {
    373                      CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_OTEPDIS);
   \   000000D8   0x9800             LDR      R0,[SP, #+0]
   \   000000DA   0xEB00 0x1045      ADD      R0,R0,R5, LSL #+5
   \   000000DE   0xF500 0x6030      ADD      R0,R0,#+2816
   \   000000E2   0x2110             MOVS     R1,#+16
   \   000000E4   0x6081             STR      R1,[R0, #+8]
    374                    }
    375                  }
    376                  epnum++;
   \                     ??HAL_PCD_IRQHandler_5: (+1)
   \   000000E6   0x1C6D             ADDS     R5,R5,#+1
    377                  ep_intr >>= 1;
   \   000000E8   0x087F             LSRS     R7,R7,#+1
    378                }
   \                     ??HAL_PCD_IRQHandler_3: (+1)
   \   000000EA   0xD1AD             BNE.N    ??HAL_PCD_IRQHandler_4
    379              }
    380              
    381              if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_IEPINT))
   \                     ??HAL_PCD_IRQHandler_2: (+1)
   \   000000EC   0x6820             LDR      R0,[R4, #+0]
   \   000000EE   0x.... 0x....      BL       USB_ReadInterrupts
   \   000000F2   0x0340             LSLS     R0,R0,#+13
   \   000000F4   0xD564             BPL.N    ??HAL_PCD_IRQHandler_9
    382              {
    383                /* Read in the device interrupt bits */
    384                ep_intr = USB_ReadDevAllInEpInterrupt(hpcd->Instance);
   \   000000F6   0x6820             LDR      R0,[R4, #+0]
   \   000000F8   0x.... 0x....      BL       USB_ReadDevAllInEpInterrupt
   \   000000FC   0x4607             MOV      R7,R0
    385                
    386                epnum = 0;
   \   000000FE   0x4635             MOV      R5,R6
   \   00000100   0x2F00             CMP      R7,#+0
   \   00000102   0xE05C             B.N      ??HAL_PCD_IRQHandler_10
    387                
    388                while ( ep_intr )
    389                {
    390                  if (ep_intr & 0x1) /* In ITR */
   \                     ??HAL_PCD_IRQHandler_11: (+1)
   \   00000104   0x07F8             LSLS     R0,R7,#+31
   \   00000106   0xD558             BPL.N    ??HAL_PCD_IRQHandler_12
    391                  {
    392                    epint = USB_ReadDevInEPInterrupt(hpcd->Instance, epnum);
   \   00000108   0x4629             MOV      R1,R5
   \   0000010A   0xB2C9             UXTB     R1,R1
   \   0000010C   0x6820             LDR      R0,[R4, #+0]
   \   0000010E   0x.... 0x....      BL       USB_ReadDevInEPInterrupt
   \   00000112   0x4680             MOV      R8,R0
    393          
    394                     if(( epint & USB_OTG_DIEPINT_XFRC) == USB_OTG_DIEPINT_XFRC)
   \   00000114   0x9800             LDR      R0,[SP, #+0]
   \   00000116   0xEB00 0x1045      ADD      R0,R0,R5, LSL #+5
   \   0000011A   0xF500 0x6910      ADD      R9,R0,#+2304
   \   0000011E   0xEA5F 0x70C8      LSLS     R0,R8,#+31
   \   00000122   0xD52B             BPL.N    ??HAL_PCD_IRQHandler_13
    395                    {
    396                      fifoemptymsk = 0x1 << epnum;
    397                      USBx_DEVICE->DIEPEMPMSK &= ~fifoemptymsk;
   \   00000124   0x9800             LDR      R0,[SP, #+0]
   \   00000126   0xF500 0x6A00      ADD      R10,R0,#+2048
   \   0000012A   0xF10A 0x0B04      ADD      R11,R10,#+4
   \   0000012E   0xF8DB 0x0030      LDR      R0,[R11, #+48]
   \   00000132   0x2101             MOVS     R1,#+1
   \   00000134   0x40A9             LSLS     R1,R1,R5
   \   00000136   0x4388             BICS     R0,R0,R1
   \   00000138   0xF8CB 0x0030      STR      R0,[R11, #+48]
    398                      
    399                      CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_XFRC);
   \   0000013C   0x2001             MOVS     R0,#+1
   \   0000013E   0xF8C9 0x0008      STR      R0,[R9, #+8]
    400                      
    401                      if (hpcd->Init.dma_enable == 1)
   \   00000142   0x6920             LDR      R0,[R4, #+16]
   \   00000144   0x2801             CMP      R0,#+1
   \   00000146   0xD106             BNE.N    ??HAL_PCD_IRQHandler_14
    402                      {
    403                        hpcd->IN_ep[epnum].xfer_buff += hpcd->IN_ep[epnum].maxpacket; 
   \   00000148   0x211C             MOVS     R1,#+28
   \   0000014A   0xFB01 0x4005      MLA      R0,R1,R5,R4
   \   0000014E   0x6C01             LDR      R1,[R0, #+64]
   \   00000150   0x6BC2             LDR      R2,[R0, #+60]
   \   00000152   0x1851             ADDS     R1,R2,R1
   \   00000154   0x6401             STR      R1,[R0, #+64]
    404                      }
    405                                                
    406                      HAL_PCD_DataInStageCallback(hpcd, epnum);
   \                     ??HAL_PCD_IRQHandler_14: (+1)
   \   00000156   0x4629             MOV      R1,R5
   \   00000158   0xB2C9             UXTB     R1,R1
   \   0000015A   0x4620             MOV      R0,R4
   \   0000015C   0x.... 0x....      BL       HAL_PCD_DataInStageCallback
    407          
    408                      if (hpcd->Init.dma_enable == 1)
   \   00000160   0x6920             LDR      R0,[R4, #+16]
   \   00000162   0x2801             CMP      R0,#+1
   \   00000164   0xD10A             BNE.N    ??HAL_PCD_IRQHandler_13
    409                      {
    410                        /* this is ZLP, so prepare EP0 for next setup */
    411                        if((epnum == 0) && (hpcd->IN_ep[epnum].xfer_len == 0))
   \   00000166   0x2D00             CMP      R5,#+0
   \   00000168   0xD108             BNE.N    ??HAL_PCD_IRQHandler_13
   \   0000016A   0x6CA0             LDR      R0,[R4, #+72]
   \   0000016C   0x2800             CMP      R0,#+0
   \   0000016E   0xD105             BNE.N    ??HAL_PCD_IRQHandler_13
    412                        {
    413                          /* prepare to rx more setup packets */
    414                          USB_EP0_OutStart(hpcd->Instance, 1, (uint8_t *)hpcd->Setup);
   \   00000170   0xF504 0x7260      ADD      R2,R4,#+896
   \   00000174   0x2101             MOVS     R1,#+1
   \   00000176   0x6820             LDR      R0,[R4, #+0]
   \   00000178   0x.... 0x....      BL       USB_EP0_OutStart
    415                        }
    416                      }           
    417                    }
    418                     if(( epint & USB_OTG_DIEPINT_TOC) == USB_OTG_DIEPINT_TOC)
   \                     ??HAL_PCD_IRQHandler_13: (+1)
   \   0000017C   0xEA5F 0x7008      LSLS     R0,R8,#+28
   \   00000180   0xD502             BPL.N    ??HAL_PCD_IRQHandler_15
    419                    {
    420                      CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_TOC);
   \   00000182   0x2008             MOVS     R0,#+8
   \   00000184   0xF8C9 0x0008      STR      R0,[R9, #+8]
    421                    }
    422                    if(( epint & USB_OTG_DIEPINT_ITTXFE) == USB_OTG_DIEPINT_ITTXFE)
   \                     ??HAL_PCD_IRQHandler_15: (+1)
   \   00000188   0xEA5F 0x60C8      LSLS     R0,R8,#+27
   \   0000018C   0xD502             BPL.N    ??HAL_PCD_IRQHandler_16
    423                    {
    424                      CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_ITTXFE);
   \   0000018E   0x2010             MOVS     R0,#+16
   \   00000190   0xF8C9 0x0008      STR      R0,[R9, #+8]
    425                    }
    426                    if(( epint & USB_OTG_DIEPINT_INEPNE) == USB_OTG_DIEPINT_INEPNE)
   \                     ??HAL_PCD_IRQHandler_16: (+1)
   \   00000194   0xEA5F 0x6048      LSLS     R0,R8,#+25
   \   00000198   0xD502             BPL.N    ??HAL_PCD_IRQHandler_17
    427                    {
    428                      CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_INEPNE);
   \   0000019A   0x2040             MOVS     R0,#+64
   \   0000019C   0xF8C9 0x0008      STR      R0,[R9, #+8]
    429                    }
    430                    if(( epint & USB_OTG_DIEPINT_EPDISD) == USB_OTG_DIEPINT_EPDISD)
   \                     ??HAL_PCD_IRQHandler_17: (+1)
   \   000001A0   0xEA5F 0x7088      LSLS     R0,R8,#+30
   \   000001A4   0xD502             BPL.N    ??HAL_PCD_IRQHandler_18
    431                    {
    432                      CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_EPDISD);
   \   000001A6   0x2002             MOVS     R0,#+2
   \   000001A8   0xF8C9 0x0008      STR      R0,[R9, #+8]
    433                    }       
    434                    if(( epint & USB_OTG_DIEPINT_TXFE) == USB_OTG_DIEPINT_TXFE)
   \                     ??HAL_PCD_IRQHandler_18: (+1)
   \   000001AC   0xEA5F 0x6008      LSLS     R0,R8,#+24
   \   000001B0   0xD503             BPL.N    ??HAL_PCD_IRQHandler_12
    435                    {
    436                      PCD_WriteEmptyTxFifo(hpcd , epnum);
   \   000001B2   0x4629             MOV      R1,R5
   \   000001B4   0x4620             MOV      R0,R4
   \   000001B6   0x.... 0x....      BL       PCD_WriteEmptyTxFifo
    437                    }
    438                  }
    439                  epnum++;
   \                     ??HAL_PCD_IRQHandler_12: (+1)
   \   000001BA   0x1C6D             ADDS     R5,R5,#+1
    440                  ep_intr >>= 1;
   \   000001BC   0x087F             LSRS     R7,R7,#+1
    441                }
   \                     ??HAL_PCD_IRQHandler_10: (+1)
   \   000001BE   0xD1A1             BNE.N    ??HAL_PCD_IRQHandler_11
    442              }
    443              
    444              /* Handle Resume Interrupt */
    445              if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_WKUINT))
   \                     ??HAL_PCD_IRQHandler_9: (+1)
   \   000001C0   0x9800             LDR      R0,[SP, #+0]
   \   000001C2   0xF500 0x6A00      ADD      R10,R0,#+2048
   \   000001C6   0x6820             LDR      R0,[R4, #+0]
   \   000001C8   0x.... 0x....      BL       USB_ReadInterrupts
   \   000001CC   0x2800             CMP      R0,#+0
   \   000001CE   0xD519             BPL.N    ??HAL_PCD_IRQHandler_19
    446              {
    447                /* Clear the Remote Wake-up Signaling */
    448                USBx_DEVICE->DCTL &= ~USB_OTG_DCTL_RWUSIG;
   \   000001D0   0xF10A 0x0B04      ADD      R11,R10,#+4
   \   000001D4   0xF8DB 0x0000      LDR      R0,[R11, #+0]
   \   000001D8   0x0840             LSRS     R0,R0,#+1
   \   000001DA   0x0040             LSLS     R0,R0,#+1
   \   000001DC   0xF8CB 0x0000      STR      R0,[R11, #+0]
    449                
    450                if(hpcd->LPM_State == LPM_L1)
   \   000001E0   0xF504 0x706C      ADD      R0,R4,#+944
   \   000001E4   0x7801             LDRB     R1,[R0, #+0]
   \   000001E6   0x2901             CMP      R1,#+1
   \   000001E8   0xD105             BNE.N    ??HAL_PCD_IRQHandler_20
    451                {
    452                  hpcd->LPM_State = LPM_L0;
   \   000001EA   0x4631             MOV      R1,R6
   \   000001EC   0x7001             STRB     R1,[R0, #+0]
    453                  HAL_PCDEx_LPM_Callback(hpcd, PCD_LPM_L0_ACTIVE);
   \   000001EE   0x4620             MOV      R0,R4
   \   000001F0   0x.... 0x....      BL       HAL_PCDEx_LPM_Callback
   \   000001F4   0xE002             B.N      ??HAL_PCD_IRQHandler_21
    454                }
    455                else
    456                {
    457                  HAL_PCD_ResumeCallback(hpcd);
   \                     ??HAL_PCD_IRQHandler_20: (+1)
   \   000001F6   0x4620             MOV      R0,R4
   \   000001F8   0x.... 0x....      BL       HAL_PCD_ResumeCallback
    458                }
    459                __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_WKUINT);
   \                     ??HAL_PCD_IRQHandler_21: (+1)
   \   000001FC   0xF04F 0x4000      MOV      R0,#-2147483648
   \   00000200   0x6821             LDR      R1,[R4, #+0]
   \   00000202   0x6148             STR      R0,[R1, #+20]
    460              }
    461              
    462              /* Handle Suspend Interrupt */
    463              if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_USBSUSP))
   \                     ??HAL_PCD_IRQHandler_19: (+1)
   \   00000204   0x6820             LDR      R0,[R4, #+0]
   \   00000206   0x.... 0x....      BL       USB_ReadInterrupts
   \   0000020A   0x0500             LSLS     R0,R0,#+20
   \   0000020C   0xD50B             BPL.N    ??HAL_PCD_IRQHandler_22
    464              {
    465          
    466                if((USBx_DEVICE->DSTS & USB_OTG_DSTS_SUSPSTS) == USB_OTG_DSTS_SUSPSTS)
   \   0000020E   0xF10A 0x0004      ADD      R0,R10,#+4
   \   00000212   0x6840             LDR      R0,[R0, #+4]
   \   00000214   0x07C0             LSLS     R0,R0,#+31
   \   00000216   0xD502             BPL.N    ??HAL_PCD_IRQHandler_23
    467                {
    468                  
    469                  HAL_PCD_SuspendCallback(hpcd);
   \   00000218   0x4620             MOV      R0,R4
   \   0000021A   0x.... 0x....      BL       HAL_PCD_SuspendCallback
    470                }
    471                __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_USBSUSP);
   \                     ??HAL_PCD_IRQHandler_23: (+1)
   \   0000021E   0xF44F 0x6000      MOV      R0,#+2048
   \   00000222   0x6821             LDR      R1,[R4, #+0]
   \   00000224   0x6148             STR      R0,[R1, #+20]
    472              }
    473              
    474              /* Handle LPM Interrupt */ 
    475              if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_LPMINT))
   \                     ??HAL_PCD_IRQHandler_22: (+1)
   \   00000226   0x6820             LDR      R0,[R4, #+0]
   \   00000228   0x.... 0x....      BL       USB_ReadInterrupts
   \   0000022C   0x0100             LSLS     R0,R0,#+4
   \   0000022E   0xD517             BPL.N    ??HAL_PCD_IRQHandler_24
    476              {
    477                __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_LPMINT);      
   \   00000230   0xF04F 0x6000      MOV      R0,#+134217728
   \   00000234   0x6821             LDR      R1,[R4, #+0]
   \   00000236   0x6148             STR      R0,[R1, #+20]
    478                if( hpcd->LPM_State == LPM_L0)
   \   00000238   0xF504 0x706C      ADD      R0,R4,#+944
   \   0000023C   0x7801             LDRB     R1,[R0, #+0]
   \   0000023E   0x2900             CMP      R1,#+0
   \   00000240   0xD10B             BNE.N    ??HAL_PCD_IRQHandler_25
    479                {
    480                  hpcd->LPM_State = LPM_L1;
   \   00000242   0x2101             MOVS     R1,#+1
   \   00000244   0x7001             STRB     R1,[R0, #+0]
    481                  hpcd->BESL = (hpcd->Instance->GLPMCFG & USB_OTG_GLPMCFG_BESL) >>2 ;
   \   00000246   0x6821             LDR      R1,[R4, #+0]
   \   00000248   0x6D49             LDR      R1,[R1, #+84]
   \   0000024A   0xF3C1 0x0183      UBFX     R1,R1,#+2,#+4
   \   0000024E   0x6041             STR      R1,[R0, #+4]
    482                  HAL_PCDEx_LPM_Callback(hpcd, PCD_LPM_L1_ACTIVE);
   \   00000250   0x2101             MOVS     R1,#+1
   \   00000252   0x4620             MOV      R0,R4
   \   00000254   0x.... 0x....      BL       HAL_PCDEx_LPM_Callback
   \   00000258   0xE002             B.N      ??HAL_PCD_IRQHandler_24
    483                }
    484                else
    485                {
    486                  HAL_PCD_SuspendCallback(hpcd);
   \                     ??HAL_PCD_IRQHandler_25: (+1)
   \   0000025A   0x4620             MOV      R0,R4
   \   0000025C   0x.... 0x....      BL       HAL_PCD_SuspendCallback
    487                }
    488              }
    489              
    490              /* Handle Reset Interrupt */
    491              if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_USBRST))
   \                     ??HAL_PCD_IRQHandler_24: (+1)
   \   00000260   0x6820             LDR      R0,[R4, #+0]
   \   00000262   0x.... 0x....      BL       USB_ReadInterrupts
   \   00000266   0x04C0             LSLS     R0,R0,#+19
   \   00000268   0xD551             BPL.N    ??HAL_PCD_IRQHandler_26
    492              {
    493                USBx_DEVICE->DCTL &= ~USB_OTG_DCTL_RWUSIG; 
   \   0000026A   0xF10A 0x0B04      ADD      R11,R10,#+4
   \   0000026E   0xF8DB 0x0000      LDR      R0,[R11, #+0]
   \   00000272   0x0840             LSRS     R0,R0,#+1
   \   00000274   0x0040             LSLS     R0,R0,#+1
   \   00000276   0xF8CB 0x0000      STR      R0,[R11, #+0]
    494                USB_FlushTxFifo(hpcd->Instance ,  0 );
   \   0000027A   0x4631             MOV      R1,R6
   \   0000027C   0x6820             LDR      R0,[R4, #+0]
   \   0000027E   0x.... 0x....      BL       USB_FlushTxFifo
    495                
    496                for (i = 0; i < hpcd->Init.dev_endpoints ; i++)
   \   00000282   0x21FF             MOVS     R1,#+255
   \   00000284   0xE009             B.N      ??HAL_PCD_IRQHandler_27
    497                {
    498                  USBx_INEP(i)->DIEPINT = 0xFF;
   \                     ??HAL_PCD_IRQHandler_28: (+1)
   \   00000286   0x9800             LDR      R0,[SP, #+0]
   \   00000288   0xEB00 0x1046      ADD      R0,R0,R6, LSL #+5
   \   0000028C   0xF500 0x6210      ADD      R2,R0,#+2304
   \   00000290   0x6091             STR      R1,[R2, #+8]
    499                  USBx_OUTEP(i)->DOEPINT = 0xFF;
   \   00000292   0xF500 0x6030      ADD      R0,R0,#+2816
   \   00000296   0x6081             STR      R1,[R0, #+8]
    500                }
   \   00000298   0x1C76             ADDS     R6,R6,#+1
   \                     ??HAL_PCD_IRQHandler_27: (+1)
   \   0000029A   0x6860             LDR      R0,[R4, #+4]
   \   0000029C   0x4286             CMP      R6,R0
   \   0000029E   0xD3F2             BCC.N    ??HAL_PCD_IRQHandler_28
    501                USBx_DEVICE->DAINT = 0xFFFFFFFF;
   \   000002A0   0xF04F 0x30FF      MOV      R0,#-1
   \   000002A4   0xF8CB 0x0014      STR      R0,[R11, #+20]
    502                USBx_DEVICE->DAINTMSK |= 0x10001;
   \   000002A8   0xF8DB 0x0018      LDR      R0,[R11, #+24]
   \   000002AC   0xF040 0x1001      ORR      R0,R0,#0x10001
   \   000002B0   0xF8CB 0x0018      STR      R0,[R11, #+24]
    503                
    504                if(hpcd->Init.use_dedicated_ep1)
   \   000002B4   0x6AE0             LDR      R0,[R4, #+44]
   \   000002B6   0x2800             CMP      R0,#+0
   \   000002B8   0xD00C             BEQ.N    ??HAL_PCD_IRQHandler_29
    505                {
    506                  USBx_DEVICE->DOUTEP1MSK |= (USB_OTG_DOEPMSK_STUPM | USB_OTG_DOEPMSK_XFRCM | USB_OTG_DOEPMSK_EPDM); 
   \   000002BA   0xF8DA 0x0084      LDR      R0,[R10, #+132]
   \   000002BE   0xF040 0x000B      ORR      R0,R0,#0xB
   \   000002C2   0xF8CA 0x0084      STR      R0,[R10, #+132]
    507                  USBx_DEVICE->DINEP1MSK |= (USB_OTG_DIEPMSK_TOM | USB_OTG_DIEPMSK_XFRCM | USB_OTG_DIEPMSK_EPDM);  
   \   000002C6   0xF8DB 0x0040      LDR      R0,[R11, #+64]
   \   000002CA   0xF040 0x000B      ORR      R0,R0,#0xB
   \   000002CE   0xF8CB 0x0040      STR      R0,[R11, #+64]
   \   000002D2   0xE00B             B.N      ??HAL_PCD_IRQHandler_30
    508                }
    509                else
    510                {
    511                  USBx_DEVICE->DOEPMSK |= (USB_OTG_DOEPMSK_STUPM | USB_OTG_DOEPMSK_XFRCM | USB_OTG_DOEPMSK_EPDM);
   \                     ??HAL_PCD_IRQHandler_29: (+1)
   \   000002D4   0xF8DB 0x0010      LDR      R0,[R11, #+16]
   \   000002D8   0xF040 0x000B      ORR      R0,R0,#0xB
   \   000002DC   0xF8CB 0x0010      STR      R0,[R11, #+16]
    512                  USBx_DEVICE->DIEPMSK |= (USB_OTG_DIEPMSK_TOM | USB_OTG_DIEPMSK_XFRCM | USB_OTG_DIEPMSK_EPDM);
   \   000002E0   0xF8DB 0x000C      LDR      R0,[R11, #+12]
   \   000002E4   0xF040 0x000B      ORR      R0,R0,#0xB
   \   000002E8   0xF8CB 0x000C      STR      R0,[R11, #+12]
    513                }
    514                
    515                /* Set Default Address to 0 */
    516                USBx_DEVICE->DCFG &= ~USB_OTG_DCFG_DAD;
   \                     ??HAL_PCD_IRQHandler_30: (+1)
   \   000002EC   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \   000002F0   0xF420 0x60FE      BIC      R0,R0,#0x7F0
   \   000002F4   0xF8CA 0x0000      STR      R0,[R10, #+0]
    517                
    518                /* setup EP0 to receive SETUP packets */
    519                USB_EP0_OutStart(hpcd->Instance, hpcd->Init.dma_enable, (uint8_t *)hpcd->Setup);
   \   000002F8   0xF504 0x7260      ADD      R2,R4,#+896
   \   000002FC   0x6921             LDR      R1,[R4, #+16]
   \   000002FE   0xB2C9             UXTB     R1,R1
   \   00000300   0x6820             LDR      R0,[R4, #+0]
   \   00000302   0x.... 0x....      BL       USB_EP0_OutStart
    520                  
    521                __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_USBRST);
   \   00000306   0xF44F 0x5080      MOV      R0,#+4096
   \   0000030A   0x6821             LDR      R1,[R4, #+0]
   \   0000030C   0x6148             STR      R0,[R1, #+20]
    522              }
    523              
    524              /* Handle Enumeration done Interrupt */
    525              if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_ENUMDNE))
   \                     ??HAL_PCD_IRQHandler_26: (+1)
   \   0000030E   0x6820             LDR      R0,[R4, #+0]
   \   00000310   0x.... 0x....      BL       USB_ReadInterrupts
   \   00000314   0x0480             LSLS     R0,R0,#+18
   \   00000316   0xD527             BPL.N    ??HAL_PCD_IRQHandler_31
    526              {
    527                USB_ActivateSetup(hpcd->Instance);
   \   00000318   0x6820             LDR      R0,[R4, #+0]
   \   0000031A   0x.... 0x....      BL       USB_ActivateSetup
    528                hpcd->Instance->GUSBCFG &= ~USB_OTG_GUSBCFG_TRDT;
   \   0000031E   0x6820             LDR      R0,[R4, #+0]
   \   00000320   0x68C1             LDR      R1,[R0, #+12]
   \   00000322   0xF421 0x5170      BIC      R1,R1,#0x3C00
   \   00000326   0x60C1             STR      R1,[R0, #+12]
    529                
    530                if ( USB_GetDevSpeed(hpcd->Instance) == USB_OTG_SPEED_HIGH)
   \   00000328   0x6820             LDR      R0,[R4, #+0]
   \   0000032A   0x.... 0x....      BL       USB_GetDevSpeed
   \   0000032E   0x2800             CMP      R0,#+0
   \   00000330   0xD10A             BNE.N    ??HAL_PCD_IRQHandler_32
    531                {
    532                  hpcd->Init.speed            = USB_OTG_SPEED_HIGH;
   \   00000332   0x2000             MOVS     R0,#+0
   \   00000334   0x60E0             STR      R0,[R4, #+12]
    533                  hpcd->Init.ep0_mps          = USB_OTG_HS_MAX_PACKET_SIZE ;
   \   00000336   0xF44F 0x7000      MOV      R0,#+512
   \   0000033A   0x6160             STR      R0,[R4, #+20]
    534                  hpcd->Instance->GUSBCFG |= (uint32_t)((USBD_HS_TRDT_VALUE << 10) & USB_OTG_GUSBCFG_TRDT);
   \   0000033C   0x6820             LDR      R0,[R4, #+0]
   \   0000033E   0x68C1             LDR      R1,[R0, #+12]
   \   00000340   0xF441 0x5110      ORR      R1,R1,#0x2400
   \   00000344   0x60C1             STR      R1,[R0, #+12]
   \   00000346   0xE008             B.N      ??HAL_PCD_IRQHandler_33
    535                }
    536                else
    537                {
    538                  hpcd->Init.speed            = USB_OTG_SPEED_FULL;
   \                     ??HAL_PCD_IRQHandler_32: (+1)
   \   00000348   0x2003             MOVS     R0,#+3
   \   0000034A   0x60E0             STR      R0,[R4, #+12]
    539                  hpcd->Init.ep0_mps          = USB_OTG_FS_MAX_PACKET_SIZE ;  
   \   0000034C   0x2040             MOVS     R0,#+64
   \   0000034E   0x6160             STR      R0,[R4, #+20]
    540                  hpcd->Instance->GUSBCFG |= (uint32_t)((USBD_FS_TRDT_VALUE << 10) & USB_OTG_GUSBCFG_TRDT);
   \   00000350   0x6820             LDR      R0,[R4, #+0]
   \   00000352   0x68C1             LDR      R1,[R0, #+12]
   \   00000354   0xF441 0x51A0      ORR      R1,R1,#0x1400
   \   00000358   0x60C1             STR      R1,[R0, #+12]
    541                }
    542                
    543                HAL_PCD_ResetCallback(hpcd);
   \                     ??HAL_PCD_IRQHandler_33: (+1)
   \   0000035A   0x4620             MOV      R0,R4
   \   0000035C   0x.... 0x....      BL       HAL_PCD_ResetCallback
    544                
    545                __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_ENUMDNE);
   \   00000360   0xF44F 0x5000      MOV      R0,#+8192
   \   00000364   0x6821             LDR      R1,[R4, #+0]
   \   00000366   0x6148             STR      R0,[R1, #+20]
    546              }
    547              
    548              /* Handle RxQLevel Interrupt */
    549              if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_RXFLVL))
   \                     ??HAL_PCD_IRQHandler_31: (+1)
   \   00000368   0x6820             LDR      R0,[R4, #+0]
   \   0000036A   0x.... 0x....      BL       USB_ReadInterrupts
   \   0000036E   0x06C0             LSLS     R0,R0,#+27
   \   00000370   0xD537             BPL.N    ??HAL_PCD_IRQHandler_34
    550              {
    551                USB_MASK_INTERRUPT(hpcd->Instance, USB_OTG_GINTSTS_RXFLVL);
   \   00000372   0x6820             LDR      R0,[R4, #+0]
   \   00000374   0x6981             LDR      R1,[R0, #+24]
   \   00000376   0xF021 0x0110      BIC      R1,R1,#0x10
   \   0000037A   0x6181             STR      R1,[R0, #+24]
    552                temp = USBx->GRXSTSP;
   \   0000037C   0x9800             LDR      R0,[SP, #+0]
   \   0000037E   0x6A06             LDR      R6,[R0, #+32]
    553                ep = &hpcd->OUT_ep[temp & USB_OTG_GRXSTSP_EPNUM];
   \   00000380   0xF006 0x000F      AND      R0,R6,#0xF
   \   00000384   0xEBC0 0x01C0      RSB      R1,R0,R0, LSL #+3
   \   00000388   0xEB04 0x0081      ADD      R0,R4,R1, LSL #+2
   \   0000038C   0xF500 0x77EC      ADD      R7,R0,#+472
    554                
    555                if(((temp & USB_OTG_GRXSTSP_PKTSTS) >> 17) ==  STS_DATA_UPDT)
   \   00000390   0xF3C6 0x4043      UBFX     R0,R6,#+17,#+4
   \   00000394   0x2802             CMP      R0,#+2
   \   00000396   0xD112             BNE.N    ??HAL_PCD_IRQHandler_35
    556                {
    557                  if((temp & USB_OTG_GRXSTSP_BCNT) != 0)
   \   00000398   0xF647 0x70F0      MOVW     R0,#+32752
   \   0000039C   0x4206             TST      R6,R0
   \   0000039E   0xD01B             BEQ.N    ??HAL_PCD_IRQHandler_36
    558                  {
    559                    USB_ReadPacket(USBx, ep->xfer_buff, (temp & USB_OTG_GRXSTSP_BCNT) >> 4);
   \   000003A0   0xF3C6 0x120A      UBFX     R2,R6,#+4,#+11
   \   000003A4   0x68F9             LDR      R1,[R7, #+12]
   \   000003A6   0x9800             LDR      R0,[SP, #+0]
   \   000003A8   0x.... 0x....      BL       USB_ReadPacket
    560                    ep->xfer_buff += (temp & USB_OTG_GRXSTSP_BCNT) >> 4;
   \   000003AC   0xF3C6 0x100A      UBFX     R0,R6,#+4,#+11
   \   000003B0   0x68F9             LDR      R1,[R7, #+12]
   \   000003B2   0x1841             ADDS     R1,R0,R1
   \   000003B4   0x60F9             STR      R1,[R7, #+12]
    561                    ep->xfer_count += (temp & USB_OTG_GRXSTSP_BCNT) >> 4;
   \   000003B6   0x69B9             LDR      R1,[R7, #+24]
   \   000003B8   0x1840             ADDS     R0,R0,R1
   \   000003BA   0x61B8             STR      R0,[R7, #+24]
   \   000003BC   0xE00C             B.N      ??HAL_PCD_IRQHandler_36
    562                  }
    563                }
    564                else if (((temp & USB_OTG_GRXSTSP_PKTSTS) >> 17) ==  STS_SETUP_UPDT)
   \                     ??HAL_PCD_IRQHandler_35: (+1)
   \   000003BE   0x2806             CMP      R0,#+6
   \   000003C0   0xD10A             BNE.N    ??HAL_PCD_IRQHandler_36
    565                {
    566                  USB_ReadPacket(USBx, (uint8_t *)hpcd->Setup, 8);
   \   000003C2   0x2208             MOVS     R2,#+8
   \   000003C4   0xF504 0x7160      ADD      R1,R4,#+896
   \   000003C8   0x9800             LDR      R0,[SP, #+0]
   \   000003CA   0x.... 0x....      BL       USB_ReadPacket
    567                  ep->xfer_count += (temp & USB_OTG_GRXSTSP_BCNT) >> 4;
   \   000003CE   0x69B8             LDR      R0,[R7, #+24]
   \   000003D0   0xF3C6 0x110A      UBFX     R1,R6,#+4,#+11
   \   000003D4   0x1808             ADDS     R0,R1,R0
   \   000003D6   0x61B8             STR      R0,[R7, #+24]
    568                }
    569                USB_UNMASK_INTERRUPT(hpcd->Instance, USB_OTG_GINTSTS_RXFLVL);
   \                     ??HAL_PCD_IRQHandler_36: (+1)
   \   000003D8   0x6820             LDR      R0,[R4, #+0]
   \   000003DA   0x6981             LDR      R1,[R0, #+24]
   \   000003DC   0xF041 0x0110      ORR      R1,R1,#0x10
   \   000003E0   0x6181             STR      R1,[R0, #+24]
    570              }
    571              
    572              /* Handle SOF Interrupt */
    573              if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_SOF))
   \                     ??HAL_PCD_IRQHandler_34: (+1)
   \   000003E2   0x6820             LDR      R0,[R4, #+0]
   \   000003E4   0x.... 0x....      BL       USB_ReadInterrupts
   \   000003E8   0x0700             LSLS     R0,R0,#+28
   \   000003EA   0xD505             BPL.N    ??HAL_PCD_IRQHandler_37
    574              {
    575                HAL_PCD_SOFCallback(hpcd);
   \   000003EC   0x4620             MOV      R0,R4
   \   000003EE   0x.... 0x....      BL       HAL_PCD_SOFCallback
    576                __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_SOF);
   \   000003F2   0x2008             MOVS     R0,#+8
   \   000003F4   0x6821             LDR      R1,[R4, #+0]
   \   000003F6   0x6148             STR      R0,[R1, #+20]
    577              }
    578              
    579              /* Handle Incomplete ISO IN Interrupt */
    580              if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_IISOIXFR))
   \                     ??HAL_PCD_IRQHandler_37: (+1)
   \   000003F8   0x6820             LDR      R0,[R4, #+0]
   \   000003FA   0x.... 0x....      BL       USB_ReadInterrupts
   \   000003FE   0x02C0             LSLS     R0,R0,#+11
   \   00000400   0xD508             BPL.N    ??HAL_PCD_IRQHandler_38
    581              {
    582                HAL_PCD_ISOINIncompleteCallback(hpcd, epnum);
   \   00000402   0x4629             MOV      R1,R5
   \   00000404   0xB2C9             UXTB     R1,R1
   \   00000406   0x4620             MOV      R0,R4
   \   00000408   0x.... 0x....      BL       HAL_PCD_ISOINIncompleteCallback
    583                __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_IISOIXFR);
   \   0000040C   0xF44F 0x1080      MOV      R0,#+1048576
   \   00000410   0x6821             LDR      R1,[R4, #+0]
   \   00000412   0x6148             STR      R0,[R1, #+20]
    584              } 
    585              
    586              /* Handle Incomplete ISO OUT Interrupt */
    587              if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_PXFR_INCOMPISOOUT))
   \                     ??HAL_PCD_IRQHandler_38: (+1)
   \   00000414   0x6820             LDR      R0,[R4, #+0]
   \   00000416   0x.... 0x....      BL       USB_ReadInterrupts
   \   0000041A   0x0280             LSLS     R0,R0,#+10
   \   0000041C   0xD508             BPL.N    ??HAL_PCD_IRQHandler_39
    588              {
    589                HAL_PCD_ISOOUTIncompleteCallback(hpcd, epnum);
   \   0000041E   0x4629             MOV      R1,R5
   \   00000420   0xB2C9             UXTB     R1,R1
   \   00000422   0x4620             MOV      R0,R4
   \   00000424   0x.... 0x....      BL       HAL_PCD_ISOOUTIncompleteCallback
    590                __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_PXFR_INCOMPISOOUT);
   \   00000428   0xF44F 0x1000      MOV      R0,#+2097152
   \   0000042C   0x6821             LDR      R1,[R4, #+0]
   \   0000042E   0x6148             STR      R0,[R1, #+20]
    591              } 
    592              
    593              /* Handle Connection event Interrupt */
    594              if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_SRQINT))
   \                     ??HAL_PCD_IRQHandler_39: (+1)
   \   00000430   0x6820             LDR      R0,[R4, #+0]
   \   00000432   0x.... 0x....      BL       USB_ReadInterrupts
   \   00000436   0x0040             LSLS     R0,R0,#+1
   \   00000438   0xD506             BPL.N    ??HAL_PCD_IRQHandler_40
    595              {
    596                HAL_PCD_ConnectCallback(hpcd);
   \   0000043A   0x4620             MOV      R0,R4
   \   0000043C   0x.... 0x....      BL       HAL_PCD_ConnectCallback
    597                __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_SRQINT);
   \   00000440   0xF04F 0x4080      MOV      R0,#+1073741824
   \   00000444   0x6821             LDR      R1,[R4, #+0]
   \   00000446   0x6148             STR      R0,[R1, #+20]
    598              } 
    599              
    600              /* Handle Disconnection event Interrupt */
    601              if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_OTGINT))
   \                     ??HAL_PCD_IRQHandler_40: (+1)
   \   00000448   0x6820             LDR      R0,[R4, #+0]
   \   0000044A   0x.... 0x....      BL       USB_ReadInterrupts
   \   0000044E   0x0740             LSLS     R0,R0,#+29
   \   00000450   0xD50A             BPL.N    ??HAL_PCD_IRQHandler_0
    602              {
    603                temp = hpcd->Instance->GOTGINT;
   \   00000452   0x6820             LDR      R0,[R4, #+0]
   \   00000454   0x6846             LDR      R6,[R0, #+4]
    604                
    605                if((temp & USB_OTG_GOTGINT_SEDET) == USB_OTG_GOTGINT_SEDET)
   \   00000456   0x0770             LSLS     R0,R6,#+29
   \   00000458   0xD502             BPL.N    ??HAL_PCD_IRQHandler_41
    606                {
    607                  HAL_PCD_DisconnectCallback(hpcd);
   \   0000045A   0x4620             MOV      R0,R4
   \   0000045C   0x.... 0x....      BL       HAL_PCD_DisconnectCallback
    608                }
    609                hpcd->Instance->GOTGINT |= temp;
   \                     ??HAL_PCD_IRQHandler_41: (+1)
   \   00000460   0x6820             LDR      R0,[R4, #+0]
   \   00000462   0x6841             LDR      R1,[R0, #+4]
   \   00000464   0x4331             ORRS     R1,R6,R1
   \   00000466   0x6041             STR      R1,[R0, #+4]
    610              }
    611            }
    612          }
   \                     ??HAL_PCD_IRQHandler_0: (+1)
   \   00000468   0xE8BD 0x8FF1      POP      {R0,R4-R11,PC}   ;; return
    613          
    614          /**
    615            * @brief  Data out stage callbacks
    616            * @param  hpcd: PCD handle
    617            * @param  epnum: endpoint number  
    618            * @retval None
    619            */

   \                                 In section .text, align 2, keep-with-next
    620           __weak void HAL_PCD_DataOutStageCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
    621          {
    622            /* NOTE : This function Should not be modified, when the callback is needed,
    623                      the HAL_PCD_DataOutStageCallback could be implemented in the user file
    624             */ 
    625          }
   \                     HAL_PCD_DataOutStageCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    626          
    627          /**
    628            * @brief  Data IN stage callbacks
    629            * @param  hpcd: PCD handle
    630            * @param  epnum: endpoint number  
    631            * @retval None
    632            */

   \                                 In section .text, align 2, keep-with-next
    633           __weak void HAL_PCD_DataInStageCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
    634          {
    635            /* NOTE : This function Should not be modified, when the callback is needed,
    636                      the HAL_PCD_DataInStageCallback could be implemented in the user file
    637             */ 
    638          }
   \                     HAL_PCD_DataInStageCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    639          /**
    640            * @brief  Setup stage callback
    641            * @param  hpcd: PCD handle
    642            * @retval None
    643            */

   \                                 In section .text, align 2, keep-with-next
    644           __weak void HAL_PCD_SetupStageCallback(PCD_HandleTypeDef *hpcd)
    645          {
    646            /* NOTE : This function Should not be modified, when the callback is needed,
    647                      the HAL_PCD_SetupStageCallback could be implemented in the user file
    648             */ 
    649          }
   \                     HAL_PCD_SetupStageCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    650          
    651          /**
    652            * @brief  USB Start Of Frame callbacks
    653            * @param  hpcd: PCD handle
    654            * @retval None
    655            */

   \                                 In section .text, align 2, keep-with-next
    656           __weak void HAL_PCD_SOFCallback(PCD_HandleTypeDef *hpcd)
    657          {
    658            /* NOTE : This function Should not be modified, when the callback is needed,
    659                      the HAL_PCD_SOFCallback could be implemented in the user file
    660             */ 
    661          }
   \                     HAL_PCD_SOFCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    662          
    663          /**
    664            * @brief  USB Reset callbacks
    665            * @param  hpcd: PCD handle
    666            * @retval None
    667            */

   \                                 In section .text, align 2, keep-with-next
    668           __weak void HAL_PCD_ResetCallback(PCD_HandleTypeDef *hpcd)
    669          {
    670            /* NOTE : This function Should not be modified, when the callback is needed,
    671                      the HAL_PCD_ResetCallback could be implemented in the user file
    672             */ 
    673          }
   \                     HAL_PCD_ResetCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    674          
    675          
    676          /**
    677            * @brief  Suspend event callbacks
    678            * @param  hpcd: PCD handle
    679            * @retval None
    680            */

   \                                 In section .text, align 2, keep-with-next
    681           __weak void HAL_PCD_SuspendCallback(PCD_HandleTypeDef *hpcd)
    682          {
    683            /* NOTE : This function Should not be modified, when the callback is needed,
    684                      the HAL_PCD_SuspendCallback could be implemented in the user file
    685             */ 
    686          }
   \                     HAL_PCD_SuspendCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    687          
    688          /**
    689            * @brief  Resume event callbacks
    690            * @param  hpcd: PCD handle
    691            * @retval None
    692            */

   \                                 In section .text, align 2, keep-with-next
    693           __weak void HAL_PCD_ResumeCallback(PCD_HandleTypeDef *hpcd)
    694          {
    695            /* NOTE : This function Should not be modified, when the callback is needed,
    696                      the HAL_PCD_ResumeCallback could be implemented in the user file
    697             */ 
    698          }
   \                     HAL_PCD_ResumeCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    699          
    700          /**
    701            * @brief  Incomplete ISO OUT callbacks
    702            * @param  hpcd: PCD handle
    703            * @param  epnum: endpoint number
    704            * @retval None
    705            */

   \                                 In section .text, align 2, keep-with-next
    706           __weak void HAL_PCD_ISOOUTIncompleteCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
    707          {
    708            /* NOTE : This function Should not be modified, when the callback is needed,
    709                      the HAL_PCD_ISOOUTIncompleteCallback could be implemented in the user file
    710             */ 
    711          }
   \                     HAL_PCD_ISOOUTIncompleteCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    712          
    713          /**
    714            * @brief  Incomplete ISO IN  callbacks
    715            * @param  hpcd: PCD handle
    716            * @param  epnum: endpoint number  
    717            * @retval None
    718            */

   \                                 In section .text, align 2, keep-with-next
    719           __weak void HAL_PCD_ISOINIncompleteCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
    720          {
    721            /* NOTE : This function Should not be modified, when the callback is needed,
    722                      the HAL_PCD_ISOINIncompleteCallback could be implemented in the user file
    723             */ 
    724          }
   \                     HAL_PCD_ISOINIncompleteCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    725          
    726          /**
    727            * @brief  Connection event callbacks
    728            * @param  hpcd: PCD handle
    729            * @retval None
    730            */

   \                                 In section .text, align 2, keep-with-next
    731           __weak void HAL_PCD_ConnectCallback(PCD_HandleTypeDef *hpcd)
    732          {
    733            /* NOTE : This function Should not be modified, when the callback is needed,
    734                      the HAL_PCD_ConnectCallback could be implemented in the user file
    735             */ 
    736          }
   \                     HAL_PCD_ConnectCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    737          
    738          /**
    739            * @brief  Disconnection event callbacks
    740            * @param  hpcd: PCD handle
    741            * @retval None
    742            */

   \                                 In section .text, align 2, keep-with-next
    743           __weak void HAL_PCD_DisconnectCallback(PCD_HandleTypeDef *hpcd)
    744          {
    745            /* NOTE : This function Should not be modified, when the callback is needed,
    746                      the HAL_PCD_DisconnectCallback could be implemented in the user file
    747             */ 
    748          }
   \                     HAL_PCD_DisconnectCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    749          
    750          /**
    751            * @}
    752            */
    753            
    754          /** @defgroup PCD_Exported_Functions_Group3 Peripheral Control functions
    755           *  @brief   management functions 
    756           *
    757          @verbatim   
    758           ===============================================================================
    759                                ##### Peripheral Control functions #####
    760           ===============================================================================  
    761              [..]
    762              This subsection provides a set of functions allowing to control the PCD data 
    763              transfers.
    764          
    765          @endverbatim
    766            * @{
    767            */
    768          
    769          /**
    770            * @brief  Connect the USB device
    771            * @param  hpcd: PCD handle
    772            * @retval HAL status
    773            */

   \                                 In section .text, align 2, keep-with-next
    774          HAL_StatusTypeDef HAL_PCD_DevConnect(PCD_HandleTypeDef *hpcd)
    775          {
   \                     HAL_PCD_DevConnect: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    776            __HAL_LOCK(hpcd); 
   \   00000004   0xF894 0x037C      LDRB     R0,[R4, #+892]
   \   00000008   0x2801             CMP      R0,#+1
   \   0000000A   0xD101             BNE.N    ??HAL_PCD_DevConnect_0
   \   0000000C   0x2002             MOVS     R0,#+2
   \   0000000E   0xBD10             POP      {R4,PC}
   \                     ??HAL_PCD_DevConnect_0: (+1)
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0xF884 0x037C      STRB     R0,[R4, #+892]
    777            USB_DevConnect(hpcd->Instance);
   \   00000016   0x6820             LDR      R0,[R4, #+0]
   \   00000018   0x.... 0x....      BL       USB_DevConnect
    778            __HAL_UNLOCK(hpcd); 
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0xF884 0x037C      STRB     R0,[R4, #+892]
    779            return HAL_OK;
   \   00000022   0xBD10             POP      {R4,PC}          ;; return
    780          }
    781          
    782          /**
    783            * @brief  Disconnect the USB device
    784            * @param  hpcd: PCD handle
    785            * @retval HAL status
    786            */

   \                                 In section .text, align 2, keep-with-next
    787          HAL_StatusTypeDef HAL_PCD_DevDisconnect(PCD_HandleTypeDef *hpcd)
    788          {
   \                     HAL_PCD_DevDisconnect: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    789            __HAL_LOCK(hpcd); 
   \   00000004   0xF894 0x037C      LDRB     R0,[R4, #+892]
   \   00000008   0x2801             CMP      R0,#+1
   \   0000000A   0xD101             BNE.N    ??HAL_PCD_DevDisconnect_0
   \   0000000C   0x2002             MOVS     R0,#+2
   \   0000000E   0xBD10             POP      {R4,PC}
   \                     ??HAL_PCD_DevDisconnect_0: (+1)
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0xF884 0x037C      STRB     R0,[R4, #+892]
    790            USB_DevDisconnect(hpcd->Instance);
   \   00000016   0x6820             LDR      R0,[R4, #+0]
   \   00000018   0x.... 0x....      BL       USB_DevDisconnect
    791            __HAL_UNLOCK(hpcd); 
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0xF884 0x037C      STRB     R0,[R4, #+892]
    792            return HAL_OK;
   \   00000022   0xBD10             POP      {R4,PC}          ;; return
    793          }
    794          
    795          /**
    796            * @brief  Set the USB Device address 
    797            * @param  hpcd: PCD handle
    798            * @param  address: new device address
    799            * @retval HAL status
    800            */

   \                                 In section .text, align 2, keep-with-next
    801          HAL_StatusTypeDef HAL_PCD_SetAddress(PCD_HandleTypeDef *hpcd, uint8_t address)
    802          {
   \                     HAL_PCD_SetAddress: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    803            __HAL_LOCK(hpcd); 
   \   00000004   0xF894 0x037C      LDRB     R0,[R4, #+892]
   \   00000008   0x2801             CMP      R0,#+1
   \   0000000A   0xD101             BNE.N    ??HAL_PCD_SetAddress_0
   \   0000000C   0x2002             MOVS     R0,#+2
   \   0000000E   0xBD10             POP      {R4,PC}
   \                     ??HAL_PCD_SetAddress_0: (+1)
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0xF884 0x037C      STRB     R0,[R4, #+892]
    804            USB_SetDevAddress(hpcd->Instance, address);
   \   00000016   0x6820             LDR      R0,[R4, #+0]
   \   00000018   0x.... 0x....      BL       USB_SetDevAddress
    805            __HAL_UNLOCK(hpcd);   
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0xF884 0x037C      STRB     R0,[R4, #+892]
    806            return HAL_OK;
   \   00000022   0xBD10             POP      {R4,PC}          ;; return
    807          }
    808          /**
    809            * @brief  Open and configure an endpoint
    810            * @param  hpcd: PCD handle
    811            * @param  ep_addr: endpoint address
    812            * @param  ep_mps: endpoint max packet size
    813            * @param  ep_type: endpoint type   
    814            * @retval HAL status
    815            */

   \                                 In section .text, align 2, keep-with-next
    816          HAL_StatusTypeDef HAL_PCD_EP_Open(PCD_HandleTypeDef *hpcd, uint8_t ep_addr, uint16_t ep_mps, uint8_t ep_type)
    817          {
   \                     HAL_PCD_EP_Open: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
    818            HAL_StatusTypeDef  ret = HAL_OK;
    819            USB_OTG_EPTypeDef *ep;
    820            
    821            if ((ep_addr & 0x80) == 0x80)
   \   00000004   0xF001 0x007F      AND      R0,R1,#0x7F
   \   00000008   0xEBC0 0x05C0      RSB      R5,R0,R0, LSL #+3
   \   0000000C   0xEB04 0x0085      ADD      R0,R4,R5, LSL #+2
   \   00000010   0x060D             LSLS     R5,R1,#+24
   \   00000012   0xD501             BPL.N    ??HAL_PCD_EP_Open_0
    822            {
    823              ep = &hpcd->IN_ep[ep_addr & 0x7F];
   \   00000014   0x3034             ADDS     R0,R0,#+52
   \   00000016   0xE001             B.N      ??HAL_PCD_EP_Open_1
    824            }
    825            else
    826            {
    827              ep = &hpcd->OUT_ep[ep_addr & 0x7F];
   \                     ??HAL_PCD_EP_Open_0: (+1)
   \   00000018   0xF500 0x70EC      ADD      R0,R0,#+472
    828            }
    829            ep->num   = ep_addr & 0x7F;
   \                     ??HAL_PCD_EP_Open_1: (+1)
   \   0000001C   0xF001 0x057F      AND      R5,R1,#0x7F
   \   00000020   0x7005             STRB     R5,[R0, #+0]
    830            
    831            ep->is_in = (0x80 & ep_addr) != 0;
   \   00000022   0x09C9             LSRS     R1,R1,#+7
   \   00000024   0x7041             STRB     R1,[R0, #+1]
    832            ep->maxpacket = ep_mps;
   \   00000026   0x6082             STR      R2,[R0, #+8]
    833            ep->type = ep_type;
   \   00000028   0x70C3             STRB     R3,[R0, #+3]
    834            if (ep->is_in)
   \   0000002A   0x7841             LDRB     R1,[R0, #+1]
   \   0000002C   0x2900             CMP      R1,#+0
   \   0000002E   0xD001             BEQ.N    ??HAL_PCD_EP_Open_2
    835            {
    836              /* Assign a Tx FIFO */
    837              ep->tx_fifo_num = ep->num;
   \   00000030   0x7801             LDRB     R1,[R0, #+0]
   \   00000032   0x80C1             STRH     R1,[R0, #+6]
    838            }
    839            /* Set initial data PID. */
    840            if (ep_type == EP_TYPE_BULK )
   \                     ??HAL_PCD_EP_Open_2: (+1)
   \   00000034   0x2B02             CMP      R3,#+2
   \   00000036   0xD101             BNE.N    ??HAL_PCD_EP_Open_3
    841            {
    842              ep->data_pid_start = 0;
   \   00000038   0x2100             MOVS     R1,#+0
   \   0000003A   0x7101             STRB     R1,[R0, #+4]
    843            }
    844            
    845            __HAL_LOCK(hpcd); 
   \                     ??HAL_PCD_EP_Open_3: (+1)
   \   0000003C   0xF894 0x137C      LDRB     R1,[R4, #+892]
   \   00000040   0x2901             CMP      R1,#+1
   \   00000042   0xD101             BNE.N    ??HAL_PCD_EP_Open_4
   \   00000044   0x2002             MOVS     R0,#+2
   \   00000046   0xBD32             POP      {R1,R4,R5,PC}
   \                     ??HAL_PCD_EP_Open_4: (+1)
   \   00000048   0x2101             MOVS     R1,#+1
   \   0000004A   0xF884 0x137C      STRB     R1,[R4, #+892]
    846            USB_ActivateEndpoint(hpcd->Instance , ep);
   \   0000004E   0x4601             MOV      R1,R0
   \   00000050   0x6820             LDR      R0,[R4, #+0]
   \   00000052   0x.... 0x....      BL       USB_ActivateEndpoint
    847            __HAL_UNLOCK(hpcd);   
   \   00000056   0x2000             MOVS     R0,#+0
   \   00000058   0xF884 0x037C      STRB     R0,[R4, #+892]
    848            return ret;
   \   0000005C   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    849          }
    850          
    851          
    852          /**
    853            * @brief  Deactivate an endpoint
    854            * @param  hpcd: PCD handle
    855            * @param  ep_addr: endpoint address
    856            * @retval HAL status
    857            */

   \                                 In section .text, align 2, keep-with-next
    858          HAL_StatusTypeDef HAL_PCD_EP_Close(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)
    859          {  
   \                     HAL_PCD_EP_Close: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    860            USB_OTG_EPTypeDef *ep;
    861            
    862            if ((ep_addr & 0x80) == 0x80)
   \   00000004   0xF001 0x007F      AND      R0,R1,#0x7F
   \   00000008   0xEBC0 0x02C0      RSB      R2,R0,R0, LSL #+3
   \   0000000C   0xEB04 0x0082      ADD      R0,R4,R2, LSL #+2
   \   00000010   0x060A             LSLS     R2,R1,#+24
   \   00000012   0xD501             BPL.N    ??HAL_PCD_EP_Close_0
    863            {
    864              ep = &hpcd->IN_ep[ep_addr & 0x7F];
   \   00000014   0x3034             ADDS     R0,R0,#+52
   \   00000016   0xE001             B.N      ??HAL_PCD_EP_Close_1
    865            }
    866            else
    867            {
    868              ep = &hpcd->OUT_ep[ep_addr & 0x7F];
   \                     ??HAL_PCD_EP_Close_0: (+1)
   \   00000018   0xF500 0x70EC      ADD      R0,R0,#+472
    869            }
    870            ep->num   = ep_addr & 0x7F;
   \                     ??HAL_PCD_EP_Close_1: (+1)
   \   0000001C   0xF001 0x027F      AND      R2,R1,#0x7F
   \   00000020   0x7002             STRB     R2,[R0, #+0]
    871            
    872            ep->is_in = (0x80 & ep_addr) != 0;
   \   00000022   0x09C9             LSRS     R1,R1,#+7
   \   00000024   0x7041             STRB     R1,[R0, #+1]
    873            
    874            __HAL_LOCK(hpcd); 
   \   00000026   0xF894 0x137C      LDRB     R1,[R4, #+892]
   \   0000002A   0x2901             CMP      R1,#+1
   \   0000002C   0xD101             BNE.N    ??HAL_PCD_EP_Close_2
   \   0000002E   0x2002             MOVS     R0,#+2
   \   00000030   0xBD10             POP      {R4,PC}
   \                     ??HAL_PCD_EP_Close_2: (+1)
   \   00000032   0x2101             MOVS     R1,#+1
   \   00000034   0xF884 0x137C      STRB     R1,[R4, #+892]
    875            USB_DeactivateEndpoint(hpcd->Instance , ep);
   \   00000038   0x4601             MOV      R1,R0
   \   0000003A   0x6820             LDR      R0,[R4, #+0]
   \   0000003C   0x.... 0x....      BL       USB_DeactivateEndpoint
    876            __HAL_UNLOCK(hpcd);   
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0xF884 0x037C      STRB     R0,[R4, #+892]
    877            return HAL_OK;
   \   00000046   0xBD10             POP      {R4,PC}          ;; return
    878          }
    879          
    880          
    881          /**
    882            * @brief  Receive an amount of data  
    883            * @param  hpcd: PCD handle
    884            * @param  ep_addr: endpoint address
    885            * @param  pBuf: pointer to the reception buffer   
    886            * @param  len: amount of data to be received
    887            * @retval HAL status
    888            */

   \                                 In section .text, align 2, keep-with-next
    889          HAL_StatusTypeDef HAL_PCD_EP_Receive(PCD_HandleTypeDef *hpcd, uint8_t ep_addr, uint8_t *pBuf, uint32_t len)
    890          {
   \                     HAL_PCD_EP_Receive: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x4608             MOV      R0,R1
    891            USB_OTG_EPTypeDef *ep;
    892            
    893            ep = &hpcd->OUT_ep[ep_addr & 0x7F];
   \   00000006   0xF000 0x017F      AND      R1,R0,#0x7F
   \   0000000A   0xEBC1 0x05C1      RSB      R5,R1,R1, LSL #+3
   \   0000000E   0xEB04 0x0185      ADD      R1,R4,R5, LSL #+2
   \   00000012   0xF501 0x71EC      ADD      R1,R1,#+472
    894            
    895            /*setup and start the Xfer */
    896            ep->xfer_buff = pBuf;  
   \   00000016   0x60CA             STR      R2,[R1, #+12]
    897            ep->xfer_len = len;
   \   00000018   0x614B             STR      R3,[R1, #+20]
    898            ep->xfer_count = 0;
   \   0000001A   0x2300             MOVS     R3,#+0
   \   0000001C   0x618B             STR      R3,[R1, #+24]
    899            ep->is_in = 0;
   \   0000001E   0x704B             STRB     R3,[R1, #+1]
    900            ep->num = ep_addr & 0x7F;
   \   00000020   0xF000 0x037F      AND      R3,R0,#0x7F
   \   00000024   0x700B             STRB     R3,[R1, #+0]
    901            
    902            if (hpcd->Init.dma_enable == 1)
   \   00000026   0x6920             LDR      R0,[R4, #+16]
   \   00000028   0x2801             CMP      R0,#+1
   \   0000002A   0xD100             BNE.N    ??HAL_PCD_EP_Receive_0
    903            {
    904              ep->dma_addr = (uint32_t)pBuf;  
   \   0000002C   0x610A             STR      R2,[R1, #+16]
    905            }
    906            
    907            __HAL_LOCK(hpcd); 
   \                     ??HAL_PCD_EP_Receive_0: (+1)
   \   0000002E   0xF894 0x037C      LDRB     R0,[R4, #+892]
   \   00000032   0x2801             CMP      R0,#+1
   \   00000034   0xD101             BNE.N    ??HAL_PCD_EP_Receive_1
   \   00000036   0x2002             MOVS     R0,#+2
   \   00000038   0xBD32             POP      {R1,R4,R5,PC}
   \                     ??HAL_PCD_EP_Receive_1: (+1)
   \   0000003A   0x2001             MOVS     R0,#+1
   \   0000003C   0xF884 0x037C      STRB     R0,[R4, #+892]
    908            
    909            if ((ep_addr & 0x7F) == 0 )
   \   00000040   0x6922             LDR      R2,[R4, #+16]
   \   00000042   0x6820             LDR      R0,[R4, #+0]
   \   00000044   0x2B00             CMP      R3,#+0
   \   00000046   0xB2D2             UXTB     R2,R2
   \   00000048   0xD102             BNE.N    ??HAL_PCD_EP_Receive_2
    910            {
    911              USB_EP0StartXfer(hpcd->Instance , ep, hpcd->Init.dma_enable);
   \   0000004A   0x.... 0x....      BL       USB_EP0StartXfer
   \   0000004E   0xE001             B.N      ??HAL_PCD_EP_Receive_3
    912            }
    913            else
    914            {
    915              USB_EPStartXfer(hpcd->Instance , ep, hpcd->Init.dma_enable);
   \                     ??HAL_PCD_EP_Receive_2: (+1)
   \   00000050   0x.... 0x....      BL       USB_EPStartXfer
    916            }
    917            __HAL_UNLOCK(hpcd); 
   \                     ??HAL_PCD_EP_Receive_3: (+1)
   \   00000054   0x2000             MOVS     R0,#+0
   \   00000056   0xF884 0x037C      STRB     R0,[R4, #+892]
    918            
    919            return HAL_OK;
   \   0000005A   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    920          }
    921          
    922          /**
    923            * @brief  Get Received Data Size
    924            * @param  hpcd: PCD handle
    925            * @param  ep_addr: endpoint address
    926            * @retval Data Size
    927            */

   \                                 In section .text, align 2, keep-with-next
    928          uint16_t HAL_PCD_EP_GetRxCount(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)
    929          {
    930            return hpcd->OUT_ep[ep_addr & 0x7F].xfer_count;
   \                     HAL_PCD_EP_GetRxCount: (+1)
   \   00000000   0xF001 0x017F      AND      R1,R1,#0x7F
   \   00000004   0xEBC1 0x02C1      RSB      R2,R1,R1, LSL #+3
   \   00000008   0xEB00 0x0082      ADD      R0,R0,R2, LSL #+2
   \   0000000C   0xF8D0 0x01F0      LDR      R0,[R0, #+496]
   \   00000010   0xB280             UXTH     R0,R0
   \   00000012   0x4770             BX       LR               ;; return
    931          }
    932          /**
    933            * @brief  Send an amount of data  
    934            * @param  hpcd: PCD handle
    935            * @param  ep_addr: endpoint address
    936            * @param  pBuf: pointer to the transmission buffer   
    937            * @param  len: amount of data to be sent
    938            * @retval HAL status
    939            */

   \                                 In section .text, align 2, keep-with-next
    940          HAL_StatusTypeDef HAL_PCD_EP_Transmit(PCD_HandleTypeDef *hpcd, uint8_t ep_addr, uint8_t *pBuf, uint32_t len)
    941          {
   \                     HAL_PCD_EP_Transmit: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x4608             MOV      R0,R1
    942            USB_OTG_EPTypeDef *ep;
    943            
    944            ep = &hpcd->IN_ep[ep_addr & 0x7F];
   \   00000006   0xF000 0x017F      AND      R1,R0,#0x7F
   \   0000000A   0xEBC1 0x05C1      RSB      R5,R1,R1, LSL #+3
   \   0000000E   0xEB04 0x0185      ADD      R1,R4,R5, LSL #+2
   \   00000012   0x3134             ADDS     R1,R1,#+52
    945            
    946            /*setup and start the Xfer */
    947            ep->xfer_buff = pBuf;  
   \   00000014   0x60CA             STR      R2,[R1, #+12]
    948            ep->xfer_len = len;
   \   00000016   0x614B             STR      R3,[R1, #+20]
    949            ep->xfer_count = 0;
   \   00000018   0x2300             MOVS     R3,#+0
   \   0000001A   0x618B             STR      R3,[R1, #+24]
    950            ep->is_in = 1;
   \   0000001C   0x2301             MOVS     R3,#+1
   \   0000001E   0x704B             STRB     R3,[R1, #+1]
    951            ep->num = ep_addr & 0x7F;
   \   00000020   0xF000 0x037F      AND      R3,R0,#0x7F
   \   00000024   0x700B             STRB     R3,[R1, #+0]
    952            
    953            if (hpcd->Init.dma_enable == 1)
   \   00000026   0x6920             LDR      R0,[R4, #+16]
   \   00000028   0x2801             CMP      R0,#+1
   \   0000002A   0xD100             BNE.N    ??HAL_PCD_EP_Transmit_0
    954            {
    955              ep->dma_addr = (uint32_t)pBuf;  
   \   0000002C   0x610A             STR      R2,[R1, #+16]
    956            }
    957            
    958            __HAL_LOCK(hpcd); 
   \                     ??HAL_PCD_EP_Transmit_0: (+1)
   \   0000002E   0xF894 0x037C      LDRB     R0,[R4, #+892]
   \   00000032   0x2801             CMP      R0,#+1
   \   00000034   0xD101             BNE.N    ??HAL_PCD_EP_Transmit_1
   \   00000036   0x2002             MOVS     R0,#+2
   \   00000038   0xBD32             POP      {R1,R4,R5,PC}
   \                     ??HAL_PCD_EP_Transmit_1: (+1)
   \   0000003A   0x2001             MOVS     R0,#+1
   \   0000003C   0xF884 0x037C      STRB     R0,[R4, #+892]
    959            
    960            if ((ep_addr & 0x7F) == 0 )
   \   00000040   0x6922             LDR      R2,[R4, #+16]
   \   00000042   0x6820             LDR      R0,[R4, #+0]
   \   00000044   0x2B00             CMP      R3,#+0
   \   00000046   0xB2D2             UXTB     R2,R2
   \   00000048   0xD102             BNE.N    ??HAL_PCD_EP_Transmit_2
    961            {
    962              USB_EP0StartXfer(hpcd->Instance , ep, hpcd->Init.dma_enable);
   \   0000004A   0x.... 0x....      BL       USB_EP0StartXfer
   \   0000004E   0xE001             B.N      ??HAL_PCD_EP_Transmit_3
    963            }
    964            else
    965            {
    966              USB_EPStartXfer(hpcd->Instance , ep, hpcd->Init.dma_enable);
   \                     ??HAL_PCD_EP_Transmit_2: (+1)
   \   00000050   0x.... 0x....      BL       USB_EPStartXfer
    967            }
    968            
    969            __HAL_UNLOCK(hpcd);
   \                     ??HAL_PCD_EP_Transmit_3: (+1)
   \   00000054   0x2000             MOVS     R0,#+0
   \   00000056   0xF884 0x037C      STRB     R0,[R4, #+892]
    970               
    971            return HAL_OK;
   \   0000005A   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    972          }
    973          
    974          /**
    975            * @brief  Set a STALL condition over an endpoint
    976            * @param  hpcd: PCD handle
    977            * @param  ep_addr: endpoint address
    978            * @retval HAL status
    979            */

   \                                 In section .text, align 2, keep-with-next
    980          HAL_StatusTypeDef HAL_PCD_EP_SetStall(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)
    981          {
   \                     HAL_PCD_EP_SetStall: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
    982            USB_OTG_EPTypeDef *ep;
    983            
    984            if ((0x80 & ep_addr) == 0x80)
   \   00000004   0x4608             MOV      R0,R1
   \   00000006   0x221C             MOVS     R2,#+28
   \   00000008   0x060B             LSLS     R3,R1,#+24
   \   0000000A   0xD505             BPL.N    ??HAL_PCD_EP_SetStall_0
    985            {
    986              ep = &hpcd->IN_ep[ep_addr & 0x7F];
   \   0000000C   0xF000 0x007F      AND      R0,R0,#0x7F
   \   00000010   0xFB12 0x4000      SMLABB   R0,R2,R0,R4
   \   00000014   0x3034             ADDS     R0,R0,#+52
   \   00000016   0xE003             B.N      ??HAL_PCD_EP_SetStall_1
    987            }
    988            else
    989            {
    990              ep = &hpcd->OUT_ep[ep_addr];
   \                     ??HAL_PCD_EP_SetStall_0: (+1)
   \   00000018   0xFB12 0x4000      SMLABB   R0,R2,R0,R4
   \   0000001C   0xF500 0x70EC      ADD      R0,R0,#+472
    991            }
    992            
    993            ep->is_stall = 1;
   \                     ??HAL_PCD_EP_SetStall_1: (+1)
   \   00000020   0x2201             MOVS     R2,#+1
   \   00000022   0x7082             STRB     R2,[R0, #+2]
    994            ep->num   = ep_addr & 0x7F;
   \   00000024   0xF001 0x057F      AND      R5,R1,#0x7F
   \   00000028   0x7005             STRB     R5,[R0, #+0]
    995            ep->is_in = ((ep_addr & 0x80) == 0x80);
   \   0000002A   0x09C9             LSRS     R1,R1,#+7
   \   0000002C   0x7041             STRB     R1,[R0, #+1]
    996            
    997            
    998            __HAL_LOCK(hpcd); 
   \   0000002E   0xF894 0x137C      LDRB     R1,[R4, #+892]
   \   00000032   0x2901             CMP      R1,#+1
   \   00000034   0xD101             BNE.N    ??HAL_PCD_EP_SetStall_2
   \   00000036   0x2002             MOVS     R0,#+2
   \   00000038   0xBD32             POP      {R1,R4,R5,PC}
   \                     ??HAL_PCD_EP_SetStall_2: (+1)
   \   0000003A   0x4611             MOV      R1,R2
   \   0000003C   0xF884 0x137C      STRB     R1,[R4, #+892]
    999            USB_EPSetStall(hpcd->Instance , ep);
   \   00000040   0x4601             MOV      R1,R0
   \   00000042   0x6820             LDR      R0,[R4, #+0]
   \   00000044   0x.... 0x....      BL       USB_EPSetStall
   1000            if((ep_addr & 0x7F) == 0)
   \   00000048   0x2D00             CMP      R5,#+0
   \   0000004A   0xD106             BNE.N    ??HAL_PCD_EP_SetStall_3
   1001            {
   1002              USB_EP0_OutStart(hpcd->Instance, hpcd->Init.dma_enable, (uint8_t *)hpcd->Setup);
   \   0000004C   0xF504 0x7260      ADD      R2,R4,#+896
   \   00000050   0x6921             LDR      R1,[R4, #+16]
   \   00000052   0xB2C9             UXTB     R1,R1
   \   00000054   0x6820             LDR      R0,[R4, #+0]
   \   00000056   0x.... 0x....      BL       USB_EP0_OutStart
   1003            }
   1004            __HAL_UNLOCK(hpcd); 
   \                     ??HAL_PCD_EP_SetStall_3: (+1)
   \   0000005A   0x2000             MOVS     R0,#+0
   \   0000005C   0xF884 0x037C      STRB     R0,[R4, #+892]
   1005            
   1006            return HAL_OK;
   \   00000060   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1007          }
   1008          
   1009          /**
   1010            * @brief  Clear a STALL condition over in an endpoint
   1011            * @param  hpcd: PCD handle
   1012            * @param  ep_addr: endpoint address
   1013            * @retval HAL status
   1014            */

   \                                 In section .text, align 2, keep-with-next
   1015          HAL_StatusTypeDef HAL_PCD_EP_ClrStall(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)
   1016          {
   \                     HAL_PCD_EP_ClrStall: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   1017            USB_OTG_EPTypeDef *ep;
   1018            
   1019            if ((0x80 & ep_addr) == 0x80)
   \   00000004   0x4608             MOV      R0,R1
   \   00000006   0x221C             MOVS     R2,#+28
   \   00000008   0x060B             LSLS     R3,R1,#+24
   \   0000000A   0xD505             BPL.N    ??HAL_PCD_EP_ClrStall_0
   1020            {
   1021              ep = &hpcd->IN_ep[ep_addr & 0x7F];
   \   0000000C   0xF000 0x007F      AND      R0,R0,#0x7F
   \   00000010   0xFB12 0x4000      SMLABB   R0,R2,R0,R4
   \   00000014   0x3034             ADDS     R0,R0,#+52
   \   00000016   0xE003             B.N      ??HAL_PCD_EP_ClrStall_1
   1022            }
   1023            else
   1024            {
   1025              ep = &hpcd->OUT_ep[ep_addr];
   \                     ??HAL_PCD_EP_ClrStall_0: (+1)
   \   00000018   0xFB12 0x4000      SMLABB   R0,R2,R0,R4
   \   0000001C   0xF500 0x70EC      ADD      R0,R0,#+472
   1026            }
   1027            
   1028            ep->is_stall = 0;
   \                     ??HAL_PCD_EP_ClrStall_1: (+1)
   \   00000020   0x2200             MOVS     R2,#+0
   \   00000022   0x7082             STRB     R2,[R0, #+2]
   1029            ep->num   = ep_addr & 0x7F;
   \   00000024   0xF001 0x027F      AND      R2,R1,#0x7F
   \   00000028   0x7002             STRB     R2,[R0, #+0]
   1030            ep->is_in = ((ep_addr & 0x80) == 0x80);
   \   0000002A   0x09C9             LSRS     R1,R1,#+7
   \   0000002C   0x7041             STRB     R1,[R0, #+1]
   1031            
   1032            __HAL_LOCK(hpcd); 
   \   0000002E   0xF894 0x137C      LDRB     R1,[R4, #+892]
   \   00000032   0x2901             CMP      R1,#+1
   \   00000034   0xD101             BNE.N    ??HAL_PCD_EP_ClrStall_2
   \   00000036   0x2002             MOVS     R0,#+2
   \   00000038   0xBD10             POP      {R4,PC}
   \                     ??HAL_PCD_EP_ClrStall_2: (+1)
   \   0000003A   0x2101             MOVS     R1,#+1
   \   0000003C   0xF884 0x137C      STRB     R1,[R4, #+892]
   1033            USB_EPClearStall(hpcd->Instance , ep);
   \   00000040   0x4601             MOV      R1,R0
   \   00000042   0x6820             LDR      R0,[R4, #+0]
   \   00000044   0x.... 0x....      BL       USB_EPClearStall
   1034            __HAL_UNLOCK(hpcd); 
   \   00000048   0x2000             MOVS     R0,#+0
   \   0000004A   0xF884 0x037C      STRB     R0,[R4, #+892]
   1035              
   1036            return HAL_OK;
   \   0000004E   0xBD10             POP      {R4,PC}          ;; return
   1037          }
   1038          
   1039          /**
   1040            * @brief  Flush an endpoint
   1041            * @param  hpcd: PCD handle
   1042            * @param  ep_addr: endpoint address
   1043            * @retval HAL status
   1044            */

   \                                 In section .text, align 2, keep-with-next
   1045          HAL_StatusTypeDef HAL_PCD_EP_Flush(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)
   1046          {
   \                     HAL_PCD_EP_Flush: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   1047            __HAL_LOCK(hpcd); 
   \   00000004   0xF894 0x037C      LDRB     R0,[R4, #+892]
   \   00000008   0x2801             CMP      R0,#+1
   \   0000000A   0xD101             BNE.N    ??HAL_PCD_EP_Flush_0
   \   0000000C   0x2002             MOVS     R0,#+2
   \   0000000E   0xBD10             POP      {R4,PC}
   \                     ??HAL_PCD_EP_Flush_0: (+1)
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0xF884 0x037C      STRB     R0,[R4, #+892]
   1048            
   1049            if ((ep_addr & 0x80) == 0x80)
   \   00000016   0x6820             LDR      R0,[R4, #+0]
   \   00000018   0x060A             LSLS     R2,R1,#+24
   \   0000001A   0xD504             BPL.N    ??HAL_PCD_EP_Flush_1
   1050            {
   1051              USB_FlushTxFifo(hpcd->Instance, ep_addr & 0x7F);
   \   0000001C   0xF001 0x017F      AND      R1,R1,#0x7F
   \   00000020   0x.... 0x....      BL       USB_FlushTxFifo
   \   00000024   0xE001             B.N      ??HAL_PCD_EP_Flush_2
   1052            }
   1053            else
   1054            {
   1055              USB_FlushRxFifo(hpcd->Instance);
   \                     ??HAL_PCD_EP_Flush_1: (+1)
   \   00000026   0x.... 0x....      BL       USB_FlushRxFifo
   1056            }
   1057            
   1058            __HAL_UNLOCK(hpcd); 
   \                     ??HAL_PCD_EP_Flush_2: (+1)
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0xF884 0x037C      STRB     R0,[R4, #+892]
   1059              
   1060            return HAL_OK;
   \   00000030   0xBD10             POP      {R4,PC}          ;; return
   1061          }
   1062          
   1063          /**
   1064            * @brief  HAL_PCD_ActivateRemoteWakeup : Active remote wake-up signalling
   1065            * @param  hpcd: PCD handle
   1066            * @retval HAL status
   1067            */

   \                                 In section .text, align 2, keep-with-next
   1068          HAL_StatusTypeDef HAL_PCD_ActivateRemoteWakeup(PCD_HandleTypeDef *hpcd)
   1069          {
   1070            USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;  
   \                     HAL_PCD_ActivateRemoteWakeup: (+1)
   \   00000000   0x6800             LDR      R0,[R0, #+0]
   1071              
   1072            if((USBx_DEVICE->DSTS & USB_OTG_DSTS_SUSPSTS) == USB_OTG_DSTS_SUSPSTS)
   \   00000002   0xF500 0x6000      ADD      R0,R0,#+2048
   \   00000006   0x6881             LDR      R1,[R0, #+8]
   \   00000008   0x07C9             LSLS     R1,R1,#+31
   \   0000000A   0xD503             BPL.N    ??HAL_PCD_ActivateRemoteWakeup_0
   1073            {
   1074              /* Activate Remote wake-up signaling */
   1075              USBx_DEVICE->DCTL |= USB_OTG_DCTL_RWUSIG;
   \   0000000C   0x6841             LDR      R1,[R0, #+4]
   \   0000000E   0xF041 0x0101      ORR      R1,R1,#0x1
   \   00000012   0x6041             STR      R1,[R0, #+4]
   1076            }
   1077            return HAL_OK;  
   \                     ??HAL_PCD_ActivateRemoteWakeup_0: (+1)
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0x4770             BX       LR               ;; return
   1078          }
   1079          
   1080          /**
   1081            * @brief  HAL_PCD_DeActivateRemoteWakeup : de-active remote wake-up signalling
   1082            * @param  hpcd: PCD handle
   1083            * @retval HAL status
   1084            */

   \                                 In section .text, align 2, keep-with-next
   1085          HAL_StatusTypeDef HAL_PCD_DeActivateRemoteWakeup(PCD_HandleTypeDef *hpcd)
   1086          {
   1087            USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;  
   \                     HAL_PCD_DeActivateRemoteWakeup: (+1)
   \   00000000   0x6800             LDR      R0,[R0, #+0]
   1088            
   1089            /* De-activate Remote wake-up signaling */
   1090             USBx_DEVICE->DCTL &= ~(USB_OTG_DCTL_RWUSIG);
   \   00000002   0xF500 0x6000      ADD      R0,R0,#+2048
   \   00000006   0x6841             LDR      R1,[R0, #+4]
   \   00000008   0x0849             LSRS     R1,R1,#+1
   \   0000000A   0x0049             LSLS     R1,R1,#+1
   \   0000000C   0x6041             STR      R1,[R0, #+4]
   1091            return HAL_OK;  
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0x4770             BX       LR               ;; return
   1092          }
   1093          /**
   1094            * @}
   1095            */
   1096            
   1097          /** @defgroup PCD_Exported_Functions_Group4 Peripheral State functions 
   1098           *  @brief   Peripheral State functions 
   1099           *
   1100          @verbatim   
   1101           ===============================================================================
   1102                                ##### Peripheral State functions #####
   1103           ===============================================================================  
   1104              [..]
   1105              This subsection permits to get in run-time the status of the peripheral 
   1106              and the data flow.
   1107          
   1108          @endverbatim
   1109            * @{
   1110            */
   1111          
   1112          /**
   1113            * @brief  Return the PCD state
   1114            * @param  hpcd: PCD handle
   1115            * @retval HAL state
   1116            */

   \                                 In section .text, align 2, keep-with-next
   1117          PCD_StateTypeDef HAL_PCD_GetState(PCD_HandleTypeDef *hpcd)
   1118          {
   1119            return hpcd->State;
   \                     HAL_PCD_GetState: (+1)
   \   00000000   0xF890 0x037D      LDRB     R0,[R0, #+893]
   \   00000004   0x4770             BX       LR               ;; return
   1120          }
   1121          /**
   1122            * @}
   1123            */
   1124          
   1125          /**
   1126            * @}
   1127            */
   1128          
   1129          /* Private functions ---------------------------------------------------------*/
   1130          /** @addtogroup PCD_Private_Functions
   1131            * @{
   1132            */
   1133          
   1134          /**
   1135            * @brief  DCD_WriteEmptyTxFifo
   1136            *         check FIFO for the next packet to be loaded
   1137            * @param  hpcd: PCD handle
   1138            * @param  epnum : endpoint number   
   1139            * @retval HAL status
   1140            */

   \                                 In section .text, align 2, keep-with-next
   1141          static HAL_StatusTypeDef PCD_WriteEmptyTxFifo(PCD_HandleTypeDef *hpcd, uint32_t epnum)
   1142          {
   \                     PCD_WriteEmptyTxFifo: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
   1143            USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;  
   \   00000008   0x6826             LDR      R6,[R4, #+0]
   1144            USB_OTG_EPTypeDef *ep;
   1145            int32_t len = 0;
   1146            uint32_t len32b;
   1147            uint32_t fifoemptymsk = 0;
   1148          
   1149            ep = &hpcd->IN_ep[epnum];
   \   0000000A   0xEBC5 0x00C5      RSB      R0,R5,R5, LSL #+3
   \   0000000E   0xEB04 0x0080      ADD      R0,R4,R0, LSL #+2
   \   00000012   0xF100 0x0734      ADD      R7,R0,#+52
   1150            len = ep->xfer_len - ep->xfer_count;
   \   00000016   0x6978             LDR      R0,[R7, #+20]
   \   00000018   0x69B9             LDR      R1,[R7, #+24]
   \   0000001A   0xEBA0 0x0801      SUB      R8,R0,R1
   1151            
   1152            if (len > ep->maxpacket)
   \   0000001E   0x68B8             LDR      R0,[R7, #+8]
   \   00000020   0x4540             CMP      R0,R8
   \   00000022   0xD200             BCS.N    ??PCD_WriteEmptyTxFifo_0
   1153            {
   1154              len = ep->maxpacket;
   \   00000024   0x4680             MOV      R8,R0
   1155            }
   1156            
   1157            
   1158            len32b = (len + 3) / 4;
   \                     ??PCD_WriteEmptyTxFifo_0: (+1)
   \   00000026   0xF108 0x0003      ADD      R0,R8,#+3
   \   0000002A   0x1041             ASRS     R1,R0,#+1
   \   0000002C   0xEB00 0x7091      ADD      R0,R0,R1, LSR #+30
   \   00000030   0xEA4F 0x09A0      ASR      R9,R0,#+2
   \   00000034   0xE01E             B.N      ??PCD_WriteEmptyTxFifo_1
   1159           
   1160            while  ( (USBx_INEP(epnum)->DTXFSTS & USB_OTG_DTXFSTS_INEPTFSAV) > len32b &&
   1161                    ep->xfer_count < ep->xfer_len &&
   1162                      ep->xfer_len != 0)
   1163            {
   1164              /* Write the FIFO */
   1165              len = ep->xfer_len - ep->xfer_count;
   \                     ??PCD_WriteEmptyTxFifo_2: (+1)
   \   00000036   0xEBA0 0x0801      SUB      R8,R0,R1
   1166              
   1167              if (len > ep->maxpacket)
   \   0000003A   0x68B8             LDR      R0,[R7, #+8]
   \   0000003C   0x4540             CMP      R0,R8
   \   0000003E   0xD200             BCS.N    ??PCD_WriteEmptyTxFifo_3
   1168              {
   1169                len = ep->maxpacket;
   \   00000040   0x4680             MOV      R8,R0
   1170              }
   1171              len32b = (len + 3) / 4;
   \                     ??PCD_WriteEmptyTxFifo_3: (+1)
   \   00000042   0xF108 0x0003      ADD      R0,R8,#+3
   \   00000046   0x1041             ASRS     R1,R0,#+1
   \   00000048   0xEB00 0x7091      ADD      R0,R0,R1, LSR #+30
   \   0000004C   0xEA4F 0x09A0      ASR      R9,R0,#+2
   1172              
   1173              USB_WritePacket(USBx, ep->xfer_buff, epnum, len, hpcd->Init.dma_enable); 
   \   00000050   0x6920             LDR      R0,[R4, #+16]
   \   00000052   0xB2C0             UXTB     R0,R0
   \   00000054   0x9000             STR      R0,[SP, #+0]
   \   00000056   0x4640             MOV      R0,R8
   \   00000058   0x4603             MOV      R3,R0
   \   0000005A   0xB29B             UXTH     R3,R3
   \   0000005C   0x462A             MOV      R2,R5
   \   0000005E   0xB2D2             UXTB     R2,R2
   \   00000060   0x68F9             LDR      R1,[R7, #+12]
   \   00000062   0x4630             MOV      R0,R6
   \   00000064   0x.... 0x....      BL       USB_WritePacket
   1174              
   1175              ep->xfer_buff  += len;
   \   00000068   0x68F8             LDR      R0,[R7, #+12]
   \   0000006A   0x4440             ADD      R0,R8,R0
   \   0000006C   0x60F8             STR      R0,[R7, #+12]
   1176              ep->xfer_count += len;
   \   0000006E   0x69B8             LDR      R0,[R7, #+24]
   \   00000070   0x4440             ADD      R0,R8,R0
   \   00000072   0x61B8             STR      R0,[R7, #+24]
   1177            }
   \                     ??PCD_WriteEmptyTxFifo_1: (+1)
   \   00000074   0x4632             MOV      R2,R6
   \   00000076   0xEB02 0x1045      ADD      R0,R2,R5, LSL #+5
   \   0000007A   0xF500 0x6010      ADD      R0,R0,#+2304
   \   0000007E   0x6980             LDR      R0,[R0, #+24]
   \   00000080   0xB280             UXTH     R0,R0
   \   00000082   0x4581             CMP      R9,R0
   \   00000084   0xD205             BCS.N    ??PCD_WriteEmptyTxFifo_4
   \   00000086   0x6978             LDR      R0,[R7, #+20]
   \   00000088   0x69B9             LDR      R1,[R7, #+24]
   \   0000008A   0x4281             CMP      R1,R0
   \   0000008C   0xD201             BCS.N    ??PCD_WriteEmptyTxFifo_4
   \   0000008E   0x2800             CMP      R0,#+0
   \   00000090   0xD1D1             BNE.N    ??PCD_WriteEmptyTxFifo_2
   1178            
   1179            if(len <= 0)
   \                     ??PCD_WriteEmptyTxFifo_4: (+1)
   \   00000092   0xF1B8 0x0F01      CMP      R8,#+1
   \   00000096   0xDA06             BGE.N    ??PCD_WriteEmptyTxFifo_5
   1180            {
   1181              fifoemptymsk = 0x1 << epnum;
   1182              USBx_DEVICE->DIEPEMPMSK &= ~fifoemptymsk;
   \   00000098   0xF502 0x6000      ADD      R0,R2,#+2048
   \   0000009C   0x6B41             LDR      R1,[R0, #+52]
   \   0000009E   0x2201             MOVS     R2,#+1
   \   000000A0   0x40AA             LSLS     R2,R2,R5
   \   000000A2   0x4391             BICS     R1,R1,R2
   \   000000A4   0x6341             STR      R1,[R0, #+52]
   1183              
   1184            }
   1185            
   1186            return HAL_OK;  
   \                     ??PCD_WriteEmptyTxFifo_5: (+1)
   \   000000A6   0x2000             MOVS     R0,#+0
   \   000000A8   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
   1187          }
   1188          
   1189          /**
   1190            * @}
   1191            */
   1192          
   1193          #endif /* HAL_PCD_MODULE_ENABLED */
   1194          /**
   1195            * @}
   1196            */
   1197          
   1198          /**
   1199            * @}
   1200            */
   1201          
   1202          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   HAL_PCD_ActivateRemoteWakeup
       0   HAL_PCD_ConnectCallback
       0   HAL_PCD_DataInStageCallback
       0   HAL_PCD_DataOutStageCallback
       0   HAL_PCD_DeActivateRemoteWakeup
       8   HAL_PCD_DeInit
         8   -> HAL_PCD_MspDeInit
         8   -> HAL_PCD_Stop
       8   HAL_PCD_DevConnect
         8   -> USB_DevConnect
       8   HAL_PCD_DevDisconnect
         8   -> USB_DevDisconnect
       0   HAL_PCD_DisconnectCallback
       8   HAL_PCD_EP_Close
         8   -> USB_DeactivateEndpoint
       8   HAL_PCD_EP_ClrStall
         8   -> USB_EPClearStall
       8   HAL_PCD_EP_Flush
         8   -> USB_FlushRxFifo
         8   -> USB_FlushTxFifo
       0   HAL_PCD_EP_GetRxCount
      16   HAL_PCD_EP_Open
        16   -> USB_ActivateEndpoint
      16   HAL_PCD_EP_Receive
        16   -> USB_EP0StartXfer
        16   -> USB_EPStartXfer
      16   HAL_PCD_EP_SetStall
        16   -> USB_EP0_OutStart
        16   -> USB_EPSetStall
      16   HAL_PCD_EP_Transmit
        16   -> USB_EP0StartXfer
        16   -> USB_EPStartXfer
       0   HAL_PCD_GetState
      40   HAL_PCD_IRQHandler
        40   -> HAL_PCDEx_LPM_Callback
        40   -> HAL_PCD_ConnectCallback
        40   -> HAL_PCD_DataInStageCallback
        40   -> HAL_PCD_DataOutStageCallback
        40   -> HAL_PCD_DisconnectCallback
        40   -> HAL_PCD_ISOINIncompleteCallback
        40   -> HAL_PCD_ISOOUTIncompleteCallback
        40   -> HAL_PCD_ResetCallback
        40   -> HAL_PCD_ResumeCallback
        40   -> HAL_PCD_SOFCallback
        40   -> HAL_PCD_SetupStageCallback
        40   -> HAL_PCD_SuspendCallback
        40   -> PCD_WriteEmptyTxFifo
        40   -> USB_ActivateSetup
        40   -> USB_EP0_OutStart
        40   -> USB_FlushTxFifo
        40   -> USB_GetDevSpeed
        40   -> USB_GetMode
        40   -> USB_ReadDevAllInEpInterrupt
        40   -> USB_ReadDevAllOutEpInterrupt
        40   -> USB_ReadDevInEPInterrupt
        40   -> USB_ReadDevOutEPInterrupt
        40   -> USB_ReadInterrupts
        40   -> USB_ReadPacket
       0   HAL_PCD_ISOINIncompleteCallback
       0   HAL_PCD_ISOOUTIncompleteCallback
      60   HAL_PCD_Init
        48   -> HAL_PCDEx_ActivateLPM
        48   -> HAL_PCD_MspInit
        48   -> USB_CoreInit
        48   -> USB_DevDisconnect
        48   -> USB_DevInit
        48   -> USB_DisableGlobalInt
        48   -> USB_SetCurrentMode
        60   -> __aeabi_memcpy4
       0   HAL_PCD_MspDeInit
       0   HAL_PCD_MspInit
       0   HAL_PCD_ResetCallback
       0   HAL_PCD_ResumeCallback
       0   HAL_PCD_SOFCallback
       8   HAL_PCD_SetAddress
         8   -> USB_SetDevAddress
       0   HAL_PCD_SetupStageCallback
       8   HAL_PCD_Start
         8   -> USB_DevConnect
         8   -> USB_EnableGlobalInt
       8   HAL_PCD_Stop
         8   -> USB_DevDisconnect
         8   -> USB_DisableGlobalInt
         8   -> USB_StopDevice
       0   HAL_PCD_SuspendCallback
      32   PCD_WriteEmptyTxFifo
        32   -> USB_WritePacket


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      24  HAL_PCD_ActivateRemoteWakeup
       2  HAL_PCD_ConnectCallback
       2  HAL_PCD_DataInStageCallback
       2  HAL_PCD_DataOutStageCallback
      18  HAL_PCD_DeActivateRemoteWakeup
      36  HAL_PCD_DeInit
      36  HAL_PCD_DevConnect
      36  HAL_PCD_DevDisconnect
       2  HAL_PCD_DisconnectCallback
      72  HAL_PCD_EP_Close
      80  HAL_PCD_EP_ClrStall
      50  HAL_PCD_EP_Flush
      20  HAL_PCD_EP_GetRxCount
      94  HAL_PCD_EP_Open
      92  HAL_PCD_EP_Receive
      98  HAL_PCD_EP_SetStall
      92  HAL_PCD_EP_Transmit
       6  HAL_PCD_GetState
    1132  HAL_PCD_IRQHandler
       2  HAL_PCD_ISOINIncompleteCallback
       2  HAL_PCD_ISOOUTIncompleteCallback
     194  HAL_PCD_Init
       2  HAL_PCD_MspDeInit
       2  HAL_PCD_MspInit
       2  HAL_PCD_ResetCallback
       2  HAL_PCD_ResumeCallback
       2  HAL_PCD_SOFCallback
      36  HAL_PCD_SetAddress
       2  HAL_PCD_SetupStageCallback
      42  HAL_PCD_Start
      48  HAL_PCD_Stop
       2  HAL_PCD_SuspendCallback
     172  PCD_WriteEmptyTxFifo

 
 2 404 bytes in section .text
 
 2 404 bytes of CODE memory

Errors: none
Warnings: none
