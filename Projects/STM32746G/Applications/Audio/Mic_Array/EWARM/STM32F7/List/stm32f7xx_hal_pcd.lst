###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.2.10312/W32 for ARM       08/Apr/2016  18:41:54
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_pcd.c
#    Command line =  
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_pcd.c
#        -D USE_HAL_DRIVER -D STM32F746xx -D USE_STM32746G_DISCO -D
#        USE_IOEXPANDER -D USE_USB_FS -lC
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
#        -lA
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
#        -o
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj
#        --no_unroll --debug --endian=little --cpu=Cortex-M7 -e --fpu=VFPv5_sp
#        --dlib_config "D:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Full.h" -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\CMSIS\Device\ST\STM32F7xx\Include\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\STM32F7xx_HAL_Driver\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\STM32746G-Discovery\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\Components\Common\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Log\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Fonts\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\CPU\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_Device_Library\Core\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Core\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Class\MSC\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\drivers\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_Audio\Addons\PDM\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_Device_Library\Class\AUDIO\Inc\
#        -Ohs --use_c++_inline --require_prototypes -I "D:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.3\arm\CMSIS\Include\" -D
#        ARM_MATH_CM7 --relaxed_fp
#    List file    =  
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List\stm32f7xx_hal_pcd.lst
#    Object file  =  
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj\stm32f7xx_hal_pcd.o
#
###############################################################################

D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_pcd.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f7xx_hal_pcd.c
      4            * @author  MCD Application Team
      5            * @version V1.0.4
      6            * @date    09-December-2015
      7            * @brief   PCD HAL module driver.
      8            *          This file provides firmware functions to manage the following 
      9            *          functionalities of the USB Peripheral Controller:
     10            *           + Initialization and de-initialization functions
     11            *           + IO operation functions
     12            *           + Peripheral Control functions 
     13            *           + Peripheral State functions
     14            *         
     15            @verbatim
     16            ==============================================================================
     17                              ##### How to use this driver #####
     18            ==============================================================================
     19              [..]
     20                The PCD HAL driver can be used as follows:
     21          
     22               (#) Declare a PCD_HandleTypeDef handle structure, for example:
     23                   PCD_HandleTypeDef  hpcd;
     24                  
     25               (#) Fill parameters of Init structure in HCD handle
     26            
     27               (#) Call HAL_PCD_Init() API to initialize the PCD peripheral (Core, Device core, ...) 
     28          
     29               (#) Initialize the PCD low level resources through the HAL_PCD_MspInit() API:
     30                   (##) Enable the PCD/USB Low Level interface clock using 
     31                        (+++) __HAL_RCC_USB_OTG_FS_CLK_ENABLE();
     32                        (+++) __HAL_RCC_USB_OTG_HS_CLK_ENABLE(); (For High Speed Mode)
     33                     
     34                   (##) Initialize the related GPIO clocks
     35                   (##) Configure PCD pin-out
     36                   (##) Configure PCD NVIC interrupt
     37              
     38               (#)Associate the Upper USB device stack to the HAL PCD Driver:
     39                   (##) hpcd.pData = pdev;
     40          
     41               (#)Enable PCD transmission and reception:
     42                   (##) HAL_PCD_Start();
     43          
     44            @endverbatim
     45            ******************************************************************************
     46            * @attention
     47            *
     48            * <h2><center>&copy; COPYRIGHT(c) 2015 STMicroelectronics</center></h2>
     49            *
     50            * Redistribution and use in source and binary forms, with or without modification,
     51            * are permitted provided that the following conditions are met:
     52            *   1. Redistributions of source code must retain the above copyright notice,
     53            *      this list of conditions and the following disclaimer.
     54            *   2. Redistributions in binary form must reproduce the above copyright notice,
     55            *      this list of conditions and the following disclaimer in the documentation
     56            *      and/or other materials provided with the distribution.
     57            *   3. Neither the name of STMicroelectronics nor the names of its contributors
     58            *      may be used to endorse or promote products derived from this software
     59            *      without specific prior written permission.
     60            *
     61            * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
     62            * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     63            * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     64            * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
     65            * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
     66            * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
     67            * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
     68            * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
     69            * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
     70            * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     71            *
     72            ******************************************************************************
     73            */ 
     74          
     75          /* Includes ------------------------------------------------------------------*/
     76          #include "stm32f7xx_hal.h"
     77          
     78          /** @addtogroup STM32F7xx_HAL_Driver
     79            * @{
     80            */
     81          
     82          /** @defgroup PCD PCD
     83            * @brief PCD HAL module driver
     84            * @{
     85            */
     86          
     87          #ifdef HAL_PCD_MODULE_ENABLED
     88          
     89          /* Private types -------------------------------------------------------------*/
     90          /* Private variables ---------------------------------------------------------*/
     91          /* Private constants ---------------------------------------------------------*/
     92          /* Private macros ------------------------------------------------------------*/
     93          /** @defgroup PCD_Private_Macros PCD Private Macros
     94            * @{
     95            */ 
     96          #define PCD_MIN(a, b)  (((a) < (b)) ? (a) : (b))
     97          #define PCD_MAX(a, b)  (((a) > (b)) ? (a) : (b))
     98          /**
     99            * @}
    100            */
    101          
    102          /* Private functions prototypes ----------------------------------------------*/
    103          /** @defgroup PCD_Private_Functions PCD Private Functions
    104            * @{
    105            */
    106          static HAL_StatusTypeDef PCD_WriteEmptyTxFifo(PCD_HandleTypeDef *hpcd, uint32_t epnum);
    107          /**
    108            * @}
    109            */
    110          
    111          /* Exported functions --------------------------------------------------------*/
    112          /** @defgroup PCD_Exported_Functions PCD Exported Functions
    113            * @{
    114            */
    115          
    116          /** @defgroup PCD_Exported_Functions_Group1 Initialization and de-initialization functions 
    117           *  @brief    Initialization and Configuration functions 
    118           *
    119          @verbatim    
    120           ===============================================================================
    121                      ##### Initialization and de-initialization functions #####
    122           ===============================================================================
    123              [..]  This section provides functions allowing to:
    124           
    125          @endverbatim
    126            * @{
    127            */
    128          
    129          /**
    130            * @brief  Initializes the PCD according to the specified
    131            *         parameters in the PCD_InitTypeDef and create the associated handle.
    132            * @param  hpcd: PCD handle
    133            * @retval HAL status
    134            */

   \                                 In section .text, align 2, keep-with-next
    135          HAL_StatusTypeDef HAL_PCD_Init(PCD_HandleTypeDef *hpcd)
    136          { 
   \                     HAL_PCD_Init: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0x4605             MOV      R5,R0
   \   00000004   0xB089             SUB      SP,SP,#+36
    137            uint32_t i = 0;
   \   00000006   0x2400             MOVS     R4,#+0
    138            
    139            /* Check the PCD handle allocation */
    140            if(hpcd == NULL)
   \   00000008   0xB915             CBNZ.N   R5,??HAL_PCD_Init_0
    141            {
    142              return HAL_ERROR;
   \   0000000A   0x2001             MOVS     R0,#+1
   \   0000000C   0xB009             ADD      SP,SP,#+36
   \   0000000E   0xBD30             POP      {R4,R5,PC}
    143            }
    144            
    145            /* Check the parameters */
    146            assert_param(IS_PCD_ALL_INSTANCE(hpcd->Instance));
    147          
    148            hpcd->State = HAL_PCD_STATE_BUSY;
   \                     ??HAL_PCD_Init_0: (+1)
   \   00000010   0x2003             MOVS     R0,#+3
   \   00000012   0xF885 0x037D      STRB     R0,[R5, #+893]
    149            
    150            /* Init the low level hardware : GPIO, CLOCK, NVIC... */
    151            HAL_PCD_MspInit(hpcd);
   \   00000016   0x4628             MOV      R0,R5
   \   00000018   0x.... 0x....      BL       HAL_PCD_MspInit
    152          
    153            /* Disable the Interrupts */
    154           __HAL_PCD_DISABLE(hpcd);
   \   0000001C   0x6828             LDR      R0,[R5, #+0]
   \   0000001E   0x.... 0x....      BL       USB_DisableGlobalInt
    155           
    156           /*Init the Core (common init.) */
    157           USB_CoreInit(hpcd->Instance, hpcd->Init);
   \   00000022   0xB083             SUB      SP,SP,#+12
   \   00000024   0x1D29             ADDS     R1,R5,#+4
   \   00000026   0x4668             MOV      R0,SP
   \   00000028   0x2230             MOVS     R2,#+48
   \   0000002A   0x.... 0x....      BL       __aeabi_memcpy4
   \   0000002E   0x6828             LDR      R0,[R5, #+0]
   \   00000030   0xBC0E             POP      {R1-R3}
   \   00000032   0x.... 0x....      BL       USB_CoreInit
    158           
    159           /* Force Device Mode*/
    160           USB_SetCurrentMode(hpcd->Instance , USB_OTG_DEVICE_MODE);
   \   00000036   0x6828             LDR      R0,[R5, #+0]
   \   00000038   0x2100             MOVS     R1,#+0
   \   0000003A   0x.... 0x....      BL       USB_SetCurrentMode
    161           
    162           /* Init endpoints structures */
    163           for (i = 0; i < 15 ; i++)
   \   0000003E   0xF105 0x0034      ADD      R0,R5,#+52
    164           {
    165             /* Init ep structure */
    166             hpcd->IN_ep[i].is_in = 1;
   \                     ??HAL_PCD_Init_1: (+1)
   \   00000042   0x2101             MOVS     R1,#+1
   \   00000044   0x7041             STRB     R1,[R0, #+1]
    167             hpcd->IN_ep[i].num = i;
    168             hpcd->IN_ep[i].tx_fifo_num = i;
    169             /* Control until ep is activated */
    170             hpcd->IN_ep[i].type = EP_TYPE_CTRL;
   \   00000046   0x2100             MOVS     R1,#+0
   \   00000048   0x7004             STRB     R4,[R0, #+0]
   \   0000004A   0x80C4             STRH     R4,[R0, #+6]
    171             hpcd->IN_ep[i].maxpacket =  0;
    172             hpcd->IN_ep[i].xfer_buff = 0;
    173             hpcd->IN_ep[i].xfer_len = 0;
    174           }
   \   0000004C   0x1C64             ADDS     R4,R4,#+1
   \   0000004E   0x70C1             STRB     R1,[R0, #+3]
   \   00000050   0x6081             STR      R1,[R0, #+8]
   \   00000052   0x60C1             STR      R1,[R0, #+12]
   \   00000054   0x6141             STR      R1,[R0, #+20]
   \   00000056   0x301C             ADDS     R0,R0,#+28
   \   00000058   0x2C0F             CMP      R4,#+15
   \   0000005A   0xD3F2             BCC.N    ??HAL_PCD_Init_1
    175           
    176           for (i = 0; i < 15 ; i++)
   \   0000005C   0x2400             MOVS     R4,#+0
   \   0000005E   0x2000             MOVS     R0,#+0
   \   00000060   0xF505 0x71EC      ADD      R1,R5,#+472
    177           {
    178             hpcd->OUT_ep[i].is_in = 0;
   \                     ??HAL_PCD_Init_2: (+1)
   \   00000064   0x2200             MOVS     R2,#+0
   \   00000066   0x704A             STRB     R2,[R1, #+1]
    179             hpcd->OUT_ep[i].num = i;
    180             hpcd->IN_ep[i].tx_fifo_num = i;
   \   00000068   0xF5A1 0x72CF      SUB      R2,R1,#+414
   \   0000006C   0x700C             STRB     R4,[R1, #+0]
   \   0000006E   0x8014             STRH     R4,[R2, #+0]
    181             /* Control until ep is activated */
    182             hpcd->OUT_ep[i].type = EP_TYPE_CTRL;
   \   00000070   0x2200             MOVS     R2,#+0
   \   00000072   0x70CA             STRB     R2,[R1, #+3]
    183             hpcd->OUT_ep[i].maxpacket = 0;
    184             hpcd->OUT_ep[i].xfer_buff = 0;
    185             hpcd->OUT_ep[i].xfer_len = 0;
    186             
    187             hpcd->Instance->DIEPTXF[i] = 0;
    188           }
   \   00000074   0x1C64             ADDS     R4,R4,#+1
   \   00000076   0x608A             STR      R2,[R1, #+8]
   \   00000078   0x60CA             STR      R2,[R1, #+12]
   \   0000007A   0x614A             STR      R2,[R1, #+20]
   \   0000007C   0x682B             LDR      R3,[R5, #+0]
   \   0000007E   0x311C             ADDS     R1,R1,#+28
   \   00000080   0x18C3             ADDS     R3,R0,R3
   \   00000082   0x1D00             ADDS     R0,R0,#+4
   \   00000084   0x2C0F             CMP      R4,#+15
   \   00000086   0xF8C3 0x2104      STR      R2,[R3, #+260]
   \   0000008A   0xD3EB             BCC.N    ??HAL_PCD_Init_2
    189           
    190           /* Init Device */
    191           USB_DevInit(hpcd->Instance, hpcd->Init);
   \   0000008C   0xB083             SUB      SP,SP,#+12
   \   0000008E   0x1D29             ADDS     R1,R5,#+4
   \   00000090   0x4668             MOV      R0,SP
   \   00000092   0x2230             MOVS     R2,#+48
   \   00000094   0x.... 0x....      BL       __aeabi_memcpy4
   \   00000098   0x6828             LDR      R0,[R5, #+0]
   \   0000009A   0xBC0E             POP      {R1-R3}
   \   0000009C   0x.... 0x....      BL       USB_DevInit
    192           
    193           hpcd->State= HAL_PCD_STATE_READY;
   \   000000A0   0x2001             MOVS     R0,#+1
   \   000000A2   0xF885 0x037D      STRB     R0,[R5, #+893]
    194           
    195           /* Activate LPM */
    196           if (hpcd->Init.lpm_enable == 1)
   \   000000A6   0x6A68             LDR      R0,[R5, #+36]
   \   000000A8   0x2801             CMP      R0,#+1
   \   000000AA   0xBF04             ITT      EQ 
    197           {
    198             HAL_PCDEx_ActivateLPM(hpcd);
   \   000000AC   0x4628             MOVEQ    R0,R5
   \   000000AE   0x.... 0x....      BLEQ     HAL_PCDEx_ActivateLPM
    199           }
    200           
    201           USB_DevDisconnect (hpcd->Instance);  
   \   000000B2   0x6828             LDR      R0,[R5, #+0]
   \   000000B4   0x.... 0x....      BL       USB_DevDisconnect
    202           return HAL_OK;
   \   000000B8   0x2000             MOVS     R0,#+0
   \   000000BA   0xB009             ADD      SP,SP,#+36
   \   000000BC   0xBD30             POP      {R4,R5,PC}       ;; return
    203          }
    204          
    205          /**
    206            * @brief  DeInitializes the PCD peripheral. 
    207            * @param  hpcd: PCD handle
    208            * @retval HAL status
    209            */

   \                                 In section .text, align 2, keep-with-next
    210          HAL_StatusTypeDef HAL_PCD_DeInit(PCD_HandleTypeDef *hpcd)
    211          {
   \                     HAL_PCD_DeInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    212            /* Check the PCD handle allocation */
    213            if(hpcd == NULL)
   \   00000004   0xD101             BNE.N    ??HAL_PCD_DeInit_0
    214            {
    215              return HAL_ERROR;
   \   00000006   0x2001             MOVS     R0,#+1
   \   00000008   0xBD10             POP      {R4,PC}
    216            }
    217          
    218            hpcd->State = HAL_PCD_STATE_BUSY;
   \                     ??HAL_PCD_DeInit_0: (+1)
   \   0000000A   0x2003             MOVS     R0,#+3
   \   0000000C   0xF884 0x037D      STRB     R0,[R4, #+893]
    219            
    220            /* Stop Device */
    221            HAL_PCD_Stop(hpcd);
   \   00000010   0xF894 0x037C      LDRB     R0,[R4, #+892]
   \   00000014   0x2801             CMP      R0,#+1
   \   00000016   0xD00E             BEQ.N    ??HAL_PCD_DeInit_1
   \   00000018   0x2001             MOVS     R0,#+1
   \   0000001A   0xF884 0x037C      STRB     R0,[R4, #+892]
   \   0000001E   0x6820             LDR      R0,[R4, #+0]
   \   00000020   0x.... 0x....      BL       USB_DisableGlobalInt
   \   00000024   0x6820             LDR      R0,[R4, #+0]
   \   00000026   0x.... 0x....      BL       USB_StopDevice
   \   0000002A   0x6820             LDR      R0,[R4, #+0]
   \   0000002C   0x.... 0x....      BL       USB_DevDisconnect
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0xF884 0x037C      STRB     R0,[R4, #+892]
    222              
    223            /* DeInit the low level hardware */
    224            HAL_PCD_MspDeInit(hpcd);
   \                     ??HAL_PCD_DeInit_1: (+1)
   \   00000036   0x4620             MOV      R0,R4
   \   00000038   0x.... 0x....      BL       HAL_PCD_MspDeInit
    225            
    226            hpcd->State = HAL_PCD_STATE_RESET; 
   \   0000003C   0x2000             MOVS     R0,#+0
   \   0000003E   0xF884 0x037D      STRB     R0,[R4, #+893]
    227            
    228            return HAL_OK;
   \   00000042   0xBD10             POP      {R4,PC}          ;; return
    229          }
    230          
    231          /**
    232            * @brief  Initializes the PCD MSP.
    233            * @param  hpcd: PCD handle
    234            * @retval None
    235            */

   \                                 In section .text, align 2, keep-with-next
    236          __weak void HAL_PCD_MspInit(PCD_HandleTypeDef *hpcd)
    237          {
    238            /* Prevent unused argument(s) compilation warning */
    239            UNUSED(hpcd);
    240            
    241            /* NOTE : This function Should not be modified, when the callback is needed,
    242                      the HAL_PCD_MspInit could be implemented in the user file
    243             */
    244          }
   \                     HAL_PCD_MspInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    245          
    246          /**
    247            * @brief  DeInitializes PCD MSP.
    248            * @param  hpcd: PCD handle
    249            * @retval None
    250            */

   \                                 In section .text, align 2, keep-with-next
    251          __weak void HAL_PCD_MspDeInit(PCD_HandleTypeDef *hpcd)
    252          {
    253            /* Prevent unused argument(s) compilation warning */
    254            UNUSED(hpcd);
    255            
    256            /* NOTE : This function Should not be modified, when the callback is needed,
    257                      the HAL_PCD_MspDeInit could be implemented in the user file
    258             */
    259          }
   \                     HAL_PCD_MspDeInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    260          
    261          /**
    262            * @}
    263            */
    264          
    265          /** @defgroup PCD_Exported_Functions_Group2 Input and Output operation functions
    266           *  @brief   Data transfers functions 
    267           *
    268          @verbatim   
    269           ===============================================================================
    270                                ##### IO operation functions #####
    271           ===============================================================================  
    272              [..]
    273              This subsection provides a set of functions allowing to manage the PCD data 
    274              transfers.
    275          
    276          @endverbatim
    277            * @{
    278            */
    279            
    280          /**
    281            * @brief  Start The USB OTG Device.
    282            * @param  hpcd: PCD handle
    283            * @retval HAL status
    284            */

   \                                 In section .text, align 2, keep-with-next
    285          HAL_StatusTypeDef HAL_PCD_Start(PCD_HandleTypeDef *hpcd)
    286          { 
   \                     HAL_PCD_Start: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    287            __HAL_LOCK(hpcd); 
   \   00000004   0xF894 0x037C      LDRB     R0,[R4, #+892]
   \   00000008   0x2801             CMP      R0,#+1
   \   0000000A   0xD101             BNE.N    ??HAL_PCD_Start_0
   \   0000000C   0x2002             MOVS     R0,#+2
   \   0000000E   0xBD10             POP      {R4,PC}
   \                     ??HAL_PCD_Start_0: (+1)
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0xF884 0x037C      STRB     R0,[R4, #+892]
    288            USB_DevConnect (hpcd->Instance);  
   \   00000016   0x6820             LDR      R0,[R4, #+0]
   \   00000018   0x.... 0x....      BL       USB_DevConnect
    289            __HAL_PCD_ENABLE(hpcd);
   \   0000001C   0x6820             LDR      R0,[R4, #+0]
   \   0000001E   0x.... 0x....      BL       USB_EnableGlobalInt
    290            __HAL_UNLOCK(hpcd); 
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0xF884 0x037C      STRB     R0,[R4, #+892]
    291            return HAL_OK;
   \   00000028   0xBD10             POP      {R4,PC}          ;; return
    292          }
    293          
    294          /**
    295            * @brief  Stop The USB OTG Device.
    296            * @param  hpcd: PCD handle
    297            * @retval HAL status
    298            */

   \                                 In section .text, align 2, keep-with-next
    299          HAL_StatusTypeDef HAL_PCD_Stop(PCD_HandleTypeDef *hpcd)
    300          { 
   \                     HAL_PCD_Stop: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    301            __HAL_LOCK(hpcd); 
   \   00000004   0xF894 0x037C      LDRB     R0,[R4, #+892]
   \   00000008   0x2801             CMP      R0,#+1
   \   0000000A   0xD101             BNE.N    ??HAL_PCD_Stop_0
   \   0000000C   0x2002             MOVS     R0,#+2
   \   0000000E   0xBD10             POP      {R4,PC}
   \                     ??HAL_PCD_Stop_0: (+1)
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0xF884 0x037C      STRB     R0,[R4, #+892]
    302            __HAL_PCD_DISABLE(hpcd);
   \   00000016   0x6820             LDR      R0,[R4, #+0]
   \   00000018   0x.... 0x....      BL       USB_DisableGlobalInt
    303            USB_StopDevice(hpcd->Instance);
   \   0000001C   0x6820             LDR      R0,[R4, #+0]
   \   0000001E   0x.... 0x....      BL       USB_StopDevice
    304            USB_DevDisconnect (hpcd->Instance);
   \   00000022   0x6820             LDR      R0,[R4, #+0]
   \   00000024   0x.... 0x....      BL       USB_DevDisconnect
    305            __HAL_UNLOCK(hpcd); 
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0xF884 0x037C      STRB     R0,[R4, #+892]
    306            return HAL_OK;
   \   0000002E   0xBD10             POP      {R4,PC}          ;; return
    307          }
    308          
    309          /**
    310            * @brief  Handle PCD interrupt request.
    311            * @param  hpcd: PCD handle
    312            * @retval HAL status
    313            */

   \                                 In section .text, align 2, keep-with-next
    314          void HAL_PCD_IRQHandler(PCD_HandleTypeDef *hpcd)
    315          {
   \                     HAL_PCD_IRQHandler: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0xB082             SUB      SP,SP,#+8
    316            USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
    317            uint32_t i = 0, ep_intr = 0, epint = 0, epnum = 0;
   \   00000008   0x2500             MOVS     R5,#+0
   \   0000000A   0xF04F 0x0A00      MOV      R10,#+0
   \   0000000E   0x6820             LDR      R0,[R4, #+0]
   \   00000010   0x9001             STR      R0,[SP, #+4]
    318            uint32_t fifoemptymsk = 0, temp = 0;
    319            USB_OTG_EPTypeDef *ep;
    320              
    321            /* ensure that we are in device mode */
    322            if (USB_GetMode(hpcd->Instance) == USB_OTG_MODE_DEVICE)
   \   00000012   0x.... 0x....      BL       USB_GetMode
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xF040 0x820F      BNE.W    ??HAL_PCD_IRQHandler_0
    323            {
    324              /* avoid spurious interrupt */
    325              if(__HAL_PCD_IS_INVALID_INTERRUPT(hpcd)) 
   \   0000001C   0x6820             LDR      R0,[R4, #+0]
   \   0000001E   0x.... 0x....      BL       USB_ReadInterrupts
   \   00000022   0x2800             CMP      R0,#+0
   \   00000024   0xF000 0x8209      BEQ.W    ??HAL_PCD_IRQHandler_0
    326              {
    327                return;
    328              }
    329              
    330              if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_MMIS))
   \   00000028   0x6820             LDR      R0,[R4, #+0]
   \   0000002A   0x.... 0x....      BL       USB_ReadInterrupts
   \   0000002E   0x0780             LSLS     R0,R0,#+30
   \   00000030   0xD502             BPL.N    ??HAL_PCD_IRQHandler_1
    331              {
    332               /* incorrect mode, acknowledge the interrupt */
    333                __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_MMIS);
   \   00000032   0x6821             LDR      R1,[R4, #+0]
   \   00000034   0x2002             MOVS     R0,#+2
   \   00000036   0x6148             STR      R0,[R1, #+20]
   \                     ??HAL_PCD_IRQHandler_1: (+1)
   \   00000038   0x6820             LDR      R0,[R4, #+0]
    334              }
    335              
    336              if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_OEPINT))
   \   0000003A   0x.... 0x....      BL       USB_ReadInterrupts
   \   0000003E   0x0300             LSLS     R0,R0,#+12
   \   00000040   0xD550             BPL.N    ??HAL_PCD_IRQHandler_2
    337              {
    338                epnum = 0;
    339                
    340                /* Read in the device interrupt bits */
    341                ep_intr = USB_ReadDevAllOutEpInterrupt(hpcd->Instance);
   \   00000042   0x6820             LDR      R0,[R4, #+0]
   \   00000044   0xF504 0x79F0      ADD      R9,R4,#+480
   \   00000048   0x.... 0x....      BL       USB_ReadDevAllOutEpInterrupt
   \   0000004C   0x0007             MOVS     R7,R0
   \   0000004E   0x9801             LDR      R0,[SP, #+4]
   \   00000050   0xF500 0x6630      ADD      R6,R0,#+2816
    342                
    343                while ( ep_intr )
   \   00000054   0xD046             BEQ.N    ??HAL_PCD_IRQHandler_2
    344                {
    345                  if (ep_intr & 0x1)
   \                     ??HAL_PCD_IRQHandler_3: (+1)
   \   00000056   0x07F8             LSLS     R0,R7,#+31
   \   00000058   0xD53D             BPL.N    ??HAL_PCD_IRQHandler_4
    346                  {
    347                    epint = USB_ReadDevOutEPInterrupt(hpcd->Instance, epnum);
   \   0000005A   0x6820             LDR      R0,[R4, #+0]
   \   0000005C   0xB2E9             UXTB     R1,R5
   \   0000005E   0x.... 0x....      BL       USB_ReadDevOutEPInterrupt
   \   00000062   0x4680             MOV      R8,R0
    348                    
    349                    if(( epint & USB_OTG_DOEPINT_XFRC) == USB_OTG_DOEPINT_XFRC)
   \   00000064   0xEA5F 0x70C8      LSLS     R0,R8,#+31
   \   00000068   0xD523             BPL.N    ??HAL_PCD_IRQHandler_5
    350                    {
    351                      CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_XFRC);
   \   0000006A   0x2101             MOVS     R1,#+1
   \   0000006C   0x60B1             STR      R1,[R6, #+8]
    352                      
    353                      if(hpcd->Init.dma_enable == 1)
   \   0000006E   0x6921             LDR      R1,[R4, #+16]
   \   00000070   0x2901             CMP      R1,#+1
   \   00000072   0xD10C             BNE.N    ??HAL_PCD_IRQHandler_6
    354                      {
    355                        hpcd->OUT_ep[epnum].xfer_count = hpcd->OUT_ep[epnum].maxpacket- (USBx_OUTEP(epnum)->DOEPTSIZ & USB_OTG_DOEPTSIZ_XFRSIZ); 
   \   00000074   0xF8D9 0x1000      LDR      R1,[R9, #+0]
   \   00000078   0x6930             LDR      R0,[R6, #+16]
   \   0000007A   0x0340             LSLS     R0,R0,#+13
   \   0000007C   0xEBB1 0x3050      SUBS     R0,R1,R0, LSR #+13
   \   00000080   0xF8C9 0x0010      STR      R0,[R9, #+16]
    356                        hpcd->OUT_ep[epnum].xfer_buff += hpcd->OUT_ep[epnum].maxpacket;            
   \   00000084   0xF8D9 0x0004      LDR      R0,[R9, #+4]
   \   00000088   0x1808             ADDS     R0,R1,R0
   \   0000008A   0xF8C9 0x0004      STR      R0,[R9, #+4]
    357                      }
    358                      
    359                      HAL_PCD_DataOutStageCallback(hpcd, epnum);
   \                     ??HAL_PCD_IRQHandler_6: (+1)
   \   0000008E   0xB2E9             UXTB     R1,R5
   \   00000090   0x4620             MOV      R0,R4
   \   00000092   0x.... 0x....      BL       HAL_PCD_DataOutStageCallback
    360                      if(hpcd->Init.dma_enable == 1)
   \   00000096   0x6920             LDR      R0,[R4, #+16]
   \   00000098   0x2801             CMP      R0,#+1
   \   0000009A   0xBF08             IT       EQ 
   \   0000009C   0x2D00             CMPEQ    R5,#+0
    361                      {
    362                        if((epnum == 0) && (hpcd->OUT_ep[epnum].xfer_len == 0))
   \   0000009E   0xD108             BNE.N    ??HAL_PCD_IRQHandler_5
   \   000000A0   0xF8D4 0x01EC      LDR      R0,[R4, #+492]
   \   000000A4   0xB928             CBNZ.N   R0,??HAL_PCD_IRQHandler_5
    363                        {
    364                           /* this is ZLP, so prepare EP0 for next setup */
    365                          USB_EP0_OutStart(hpcd->Instance, 1, (uint8_t *)hpcd->Setup);
   \   000000A6   0x6820             LDR      R0,[R4, #+0]
   \   000000A8   0xF504 0x7260      ADD      R2,R4,#+896
   \   000000AC   0x2101             MOVS     R1,#+1
   \   000000AE   0x.... 0x....      BL       USB_EP0_OutStart
    366                        }              
    367                      }
    368                    }
    369                    
    370                    if(( epint & USB_OTG_DOEPINT_STUP) == USB_OTG_DOEPINT_STUP)
   \                     ??HAL_PCD_IRQHandler_5: (+1)
   \   000000B2   0xEA5F 0x7008      LSLS     R0,R8,#+28
   \   000000B6   0xD504             BPL.N    ??HAL_PCD_IRQHandler_7
    371                    {
    372                      /* Inform the upper layer that a setup packet is available */
    373                      HAL_PCD_SetupStageCallback(hpcd);
   \   000000B8   0x4620             MOV      R0,R4
   \   000000BA   0x.... 0x....      BL       HAL_PCD_SetupStageCallback
    374                      CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_STUP);
   \   000000BE   0x2008             MOVS     R0,#+8
   \   000000C0   0x60B0             STR      R0,[R6, #+8]
    375                    }
    376                    
    377                    if(( epint & USB_OTG_DOEPINT_OTEPDIS) == USB_OTG_DOEPINT_OTEPDIS)
   \                     ??HAL_PCD_IRQHandler_7: (+1)
   \   000000C2   0xEA5F 0x60C8      LSLS     R0,R8,#+27
   \   000000C6   0xBF44             ITT      MI 
   \   000000C8   0x2010             MOVMI    R0,#+16
   \   000000CA   0x60B0             STRMI    R0,[R6, #+8]
    378                    {
    379                      CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_OTEPDIS);
    380                    }
    381                    /* Clear Status Phase Received interrupt */
    382                    if(( epint & USB_OTG_DOEPINT_OTEPSPR) == USB_OTG_DOEPINT_OTEPSPR)
   \   000000CC   0xEA5F 0x6088      LSLS     R0,R8,#+26
   \   000000D0   0xBF44             ITT      MI 
   \   000000D2   0x2020             MOVMI    R0,#+32
   \   000000D4   0x60B0             STRMI    R0,[R6, #+8]
    383                    {
    384                      CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_OTEPSPR);
    385                    }
    386                  }
    387                  epnum++;
   \                     ??HAL_PCD_IRQHandler_4: (+1)
   \   000000D6   0x1C6D             ADDS     R5,R5,#+1
    388                  ep_intr >>= 1;
   \   000000D8   0x087F             LSRS     R7,R7,#+1
   \   000000DA   0x3620             ADDS     R6,R6,#+32
   \   000000DC   0x2F00             CMP      R7,#+0
   \   000000DE   0xF109 0x091C      ADD      R9,R9,#+28
   \   000000E2   0xD1B8             BNE.N    ??HAL_PCD_IRQHandler_3
    389                }
    390              }
    391              
    392              if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_IEPINT))
   \                     ??HAL_PCD_IRQHandler_2: (+1)
   \   000000E4   0x9801             LDR      R0,[SP, #+4]
   \   000000E6   0xF500 0x6000      ADD      R0,R0,#+2048
   \   000000EA   0x9000             STR      R0,[SP, #+0]
   \   000000EC   0x6820             LDR      R0,[R4, #+0]
   \   000000EE   0x.... 0x....      BL       USB_ReadInterrupts
   \   000000F2   0x0340             LSLS     R0,R0,#+13
   \   000000F4   0xD55A             BPL.N    ??HAL_PCD_IRQHandler_8
    393              {
    394                /* Read in the device interrupt bits */
    395                ep_intr = USB_ReadDevAllInEpInterrupt(hpcd->Instance);
   \   000000F6   0x6820             LDR      R0,[R4, #+0]
   \   000000F8   0x4655             MOV      R5,R10
   \   000000FA   0xF104 0x0940      ADD      R9,R4,#+64
   \   000000FE   0x.... 0x....      BL       USB_ReadDevAllInEpInterrupt
   \   00000102   0x0007             MOVS     R7,R0
    396                
    397                epnum = 0;
   \   00000104   0x9801             LDR      R0,[SP, #+4]
   \   00000106   0xF500 0x6610      ADD      R6,R0,#+2304
    398                
    399                while ( ep_intr )
   \   0000010A   0xD04F             BEQ.N    ??HAL_PCD_IRQHandler_8
    400                {
    401                  if (ep_intr & 0x1) /* In ITR */
   \                     ??HAL_PCD_IRQHandler_9: (+1)
   \   0000010C   0x07F8             LSLS     R0,R7,#+31
   \   0000010E   0xD546             BPL.N    ??HAL_PCD_IRQHandler_10
    402                  {
    403                    epint = USB_ReadDevInEPInterrupt(hpcd->Instance, epnum);
   \   00000110   0x6820             LDR      R0,[R4, #+0]
   \   00000112   0xB2E9             UXTB     R1,R5
   \   00000114   0x.... 0x....      BL       USB_ReadDevInEPInterrupt
   \   00000118   0x4680             MOV      R8,R0
    404          
    405                     if(( epint & USB_OTG_DIEPINT_XFRC) == USB_OTG_DIEPINT_XFRC)
   \   0000011A   0xEA5F 0x70C8      LSLS     R0,R8,#+31
   \   0000011E   0xD523             BPL.N    ??HAL_PCD_IRQHandler_11
    406                    {
    407                      fifoemptymsk = 0x1 << epnum;
    408                      USBx_DEVICE->DIEPEMPMSK &= ~fifoemptymsk;
   \   00000120   0x9800             LDR      R0,[SP, #+0]
   \   00000122   0x2101             MOVS     R1,#+1
   \   00000124   0x40A9             LSLS     R1,R1,R5
   \   00000126   0x6B40             LDR      R0,[R0, #+52]
   \   00000128   0x4388             BICS     R0,R0,R1
   \   0000012A   0x9900             LDR      R1,[SP, #+0]
   \   0000012C   0x6348             STR      R0,[R1, #+52]
    409                      
    410                      CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_XFRC);
   \   0000012E   0x2001             MOVS     R0,#+1
   \   00000130   0x60B0             STR      R0,[R6, #+8]
    411                      
    412                      if (hpcd->Init.dma_enable == 1)
   \   00000132   0x6920             LDR      R0,[R4, #+16]
   \   00000134   0x2801             CMP      R0,#+1
   \   00000136   0xD106             BNE.N    ??HAL_PCD_IRQHandler_12
    413                      {
    414                        hpcd->IN_ep[epnum].xfer_buff += hpcd->IN_ep[epnum].maxpacket; 
   \   00000138   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \   0000013C   0xF859 0x1C04      LDR      R1,[R9, #-4]
   \   00000140   0x1808             ADDS     R0,R1,R0
   \   00000142   0xF8C9 0x0000      STR      R0,[R9, #+0]
    415                      }
    416                                                
    417                      HAL_PCD_DataInStageCallback(hpcd, epnum);
   \                     ??HAL_PCD_IRQHandler_12: (+1)
   \   00000146   0xB2E9             UXTB     R1,R5
   \   00000148   0x4620             MOV      R0,R4
   \   0000014A   0x.... 0x....      BL       HAL_PCD_DataInStageCallback
    418          
    419                      if (hpcd->Init.dma_enable == 1)
   \   0000014E   0x6920             LDR      R0,[R4, #+16]
   \   00000150   0x2801             CMP      R0,#+1
   \   00000152   0xBF08             IT       EQ 
   \   00000154   0x2D00             CMPEQ    R5,#+0
    420                      {
    421                        /* this is ZLP, so prepare EP0 for next setup */
    422                        if((epnum == 0) && (hpcd->IN_ep[epnum].xfer_len == 0))
   \   00000156   0xD107             BNE.N    ??HAL_PCD_IRQHandler_11
   \   00000158   0x6CA0             LDR      R0,[R4, #+72]
   \   0000015A   0xB928             CBNZ.N   R0,??HAL_PCD_IRQHandler_11
    423                        {
    424                          /* prepare to rx more setup packets */
    425                          USB_EP0_OutStart(hpcd->Instance, 1, (uint8_t *)hpcd->Setup);
   \   0000015C   0x6820             LDR      R0,[R4, #+0]
   \   0000015E   0xF504 0x7260      ADD      R2,R4,#+896
   \   00000162   0x2101             MOVS     R1,#+1
   \   00000164   0x.... 0x....      BL       USB_EP0_OutStart
    426                        }
    427                      }           
    428                    }
    429                     if(( epint & USB_OTG_DIEPINT_TOC) == USB_OTG_DIEPINT_TOC)
   \                     ??HAL_PCD_IRQHandler_11: (+1)
   \   00000168   0xEA5F 0x7008      LSLS     R0,R8,#+28
   \   0000016C   0xBF44             ITT      MI 
   \   0000016E   0x2008             MOVMI    R0,#+8
   \   00000170   0x60B0             STRMI    R0,[R6, #+8]
    430                    {
    431                      CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_TOC);
    432                    }
    433                    if(( epint & USB_OTG_DIEPINT_ITTXFE) == USB_OTG_DIEPINT_ITTXFE)
   \   00000172   0xEA5F 0x60C8      LSLS     R0,R8,#+27
   \   00000176   0xBF44             ITT      MI 
   \   00000178   0x2010             MOVMI    R0,#+16
   \   0000017A   0x60B0             STRMI    R0,[R6, #+8]
    434                    {
    435                      CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_ITTXFE);
    436                    }
    437                    if(( epint & USB_OTG_DIEPINT_INEPNE) == USB_OTG_DIEPINT_INEPNE)
   \   0000017C   0xEA5F 0x6048      LSLS     R0,R8,#+25
   \   00000180   0xBF44             ITT      MI 
   \   00000182   0x2040             MOVMI    R0,#+64
   \   00000184   0x60B0             STRMI    R0,[R6, #+8]
    438                    {
    439                      CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_INEPNE);
    440                    }
    441                    if(( epint & USB_OTG_DIEPINT_EPDISD) == USB_OTG_DIEPINT_EPDISD)
   \   00000186   0xEA5F 0x7088      LSLS     R0,R8,#+30
   \   0000018A   0xBF44             ITT      MI 
   \   0000018C   0x2002             MOVMI    R0,#+2
   \   0000018E   0x60B0             STRMI    R0,[R6, #+8]
    442                    {
    443                      CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_EPDISD);
    444                    }       
    445                    if(( epint & USB_OTG_DIEPINT_TXFE) == USB_OTG_DIEPINT_TXFE)
   \   00000190   0xEA5F 0x6008      LSLS     R0,R8,#+24
   \   00000194   0xD503             BPL.N    ??HAL_PCD_IRQHandler_10
    446                    {
    447                      PCD_WriteEmptyTxFifo(hpcd , epnum);
   \   00000196   0x4629             MOV      R1,R5
   \   00000198   0x4620             MOV      R0,R4
   \   0000019A   0x.... 0x....      BL       PCD_WriteEmptyTxFifo
    448                    }
    449                  }
    450                  epnum++;
   \                     ??HAL_PCD_IRQHandler_10: (+1)
   \   0000019E   0x1C6D             ADDS     R5,R5,#+1
    451                  ep_intr >>= 1;
   \   000001A0   0x087F             LSRS     R7,R7,#+1
   \   000001A2   0x3620             ADDS     R6,R6,#+32
   \   000001A4   0x2F00             CMP      R7,#+0
   \   000001A6   0xF109 0x091C      ADD      R9,R9,#+28
   \   000001AA   0xD1AF             BNE.N    ??HAL_PCD_IRQHandler_9
    452                }
    453              }
    454              
    455              /* Handle Resume Interrupt */
    456              if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_WKUINT))
   \                     ??HAL_PCD_IRQHandler_8: (+1)
   \   000001AC   0x6820             LDR      R0,[R4, #+0]
   \   000001AE   0x.... 0x....      BL       USB_ReadInterrupts
   \   000001B2   0x2800             CMP      R0,#+0
   \   000001B4   0xD517             BPL.N    ??HAL_PCD_IRQHandler_13
    457              {
    458                /* Clear the Remote Wake-up Signaling */
    459                USBx_DEVICE->DCTL &= ~USB_OTG_DCTL_RWUSIG;
   \   000001B6   0x9800             LDR      R0,[SP, #+0]
   \   000001B8   0x6840             LDR      R0,[R0, #+4]
   \   000001BA   0x9900             LDR      R1,[SP, #+0]
   \   000001BC   0x0840             LSRS     R0,R0,#+1
   \   000001BE   0x0040             LSLS     R0,R0,#+1
   \   000001C0   0x6048             STR      R0,[R1, #+4]
    460                
    461                if(hpcd->LPM_State == LPM_L1)
   \   000001C2   0xF894 0x03B0      LDRB     R0,[R4, #+944]
   \   000001C6   0x2801             CMP      R0,#+1
   \   000001C8   0xD106             BNE.N    ??HAL_PCD_IRQHandler_14
    462                {
    463                  hpcd->LPM_State = LPM_L0;
   \   000001CA   0xF884 0xA3B0      STRB     R10,[R4, #+944]
    464                  HAL_PCDEx_LPM_Callback(hpcd, PCD_LPM_L0_ACTIVE);
   \   000001CE   0x2100             MOVS     R1,#+0
   \   000001D0   0x4620             MOV      R0,R4
   \   000001D2   0x.... 0x....      BL       HAL_PCDEx_LPM_Callback
   \   000001D6   0xE002             B.N      ??HAL_PCD_IRQHandler_15
    465                }
    466                else
    467                {
    468                  HAL_PCD_ResumeCallback(hpcd);
   \                     ??HAL_PCD_IRQHandler_14: (+1)
   \   000001D8   0x4620             MOV      R0,R4
   \   000001DA   0x.... 0x....      BL       HAL_PCD_ResumeCallback
    469                }
    470                __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_WKUINT);
   \                     ??HAL_PCD_IRQHandler_15: (+1)
   \   000001DE   0x6821             LDR      R1,[R4, #+0]
   \   000001E0   0xF04F 0x4000      MOV      R0,#-2147483648
   \   000001E4   0x6148             STR      R0,[R1, #+20]
    471              }
    472              
    473              /* Handle Suspend Interrupt */
    474              if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_USBSUSP))
   \                     ??HAL_PCD_IRQHandler_13: (+1)
   \   000001E6   0x6820             LDR      R0,[R4, #+0]
   \   000001E8   0x.... 0x....      BL       USB_ReadInterrupts
   \   000001EC   0x0500             LSLS     R0,R0,#+20
   \   000001EE   0xD50A             BPL.N    ??HAL_PCD_IRQHandler_16
    475              {
    476                if((USBx_DEVICE->DSTS & USB_OTG_DSTS_SUSPSTS) == USB_OTG_DSTS_SUSPSTS)
   \   000001F0   0x9800             LDR      R0,[SP, #+0]
   \   000001F2   0x6880             LDR      R0,[R0, #+8]
   \   000001F4   0x07C0             LSLS     R0,R0,#+31
   \   000001F6   0xBF44             ITT      MI 
    477                {
    478                  
    479                  HAL_PCD_SuspendCallback(hpcd);
   \   000001F8   0x4620             MOVMI    R0,R4
   \   000001FA   0x.... 0x....      BLMI     HAL_PCD_SuspendCallback
    480                }
    481                __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_USBSUSP);
   \   000001FE   0x6821             LDR      R1,[R4, #+0]
   \   00000200   0xF44F 0x6000      MOV      R0,#+2048
   \   00000204   0x6148             STR      R0,[R1, #+20]
    482              }
    483              
    484              /* Handle LPM Interrupt */ 
    485              if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_LPMINT))
   \                     ??HAL_PCD_IRQHandler_16: (+1)
   \   00000206   0x6820             LDR      R0,[R4, #+0]
   \   00000208   0x.... 0x....      BL       USB_ReadInterrupts
   \   0000020C   0x0100             LSLS     R0,R0,#+4
   \   0000020E   0xD515             BPL.N    ??HAL_PCD_IRQHandler_17
    486              {
    487                __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_LPMINT);      
   \   00000210   0x6820             LDR      R0,[R4, #+0]
   \   00000212   0xF04F 0x6100      MOV      R1,#+134217728
   \   00000216   0x6141             STR      R1,[R0, #+20]
    488                if( hpcd->LPM_State == LPM_L0)
   \   00000218   0xF894 0x13B0      LDRB     R1,[R4, #+944]
   \   0000021C   0xB959             CBNZ.N   R1,??HAL_PCD_IRQHandler_18
    489                {
    490                  hpcd->LPM_State = LPM_L1;
   \   0000021E   0x2101             MOVS     R1,#+1
   \   00000220   0xF884 0x13B0      STRB     R1,[R4, #+944]
    491                  hpcd->BESL = (hpcd->Instance->GLPMCFG & USB_OTG_GLPMCFG_BESL) >>2 ;
   \   00000224   0x6D40             LDR      R0,[R0, #+84]
   \   00000226   0xF3C0 0x0083      UBFX     R0,R0,#+2,#+4
   \   0000022A   0xF8C4 0x03B4      STR      R0,[R4, #+948]
    492                  HAL_PCDEx_LPM_Callback(hpcd, PCD_LPM_L1_ACTIVE);
   \   0000022E   0x4620             MOV      R0,R4
   \   00000230   0x.... 0x....      BL       HAL_PCDEx_LPM_Callback
   \   00000234   0xE002             B.N      ??HAL_PCD_IRQHandler_17
    493                }
    494                else
    495                {
    496                  HAL_PCD_SuspendCallback(hpcd);
   \                     ??HAL_PCD_IRQHandler_18: (+1)
   \   00000236   0x4620             MOV      R0,R4
   \   00000238   0x.... 0x....      BL       HAL_PCD_SuspendCallback
    497                }
    498              }
    499              
    500              /* Handle Reset Interrupt */
    501              if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_USBRST))
   \                     ??HAL_PCD_IRQHandler_17: (+1)
   \   0000023C   0x6820             LDR      R0,[R4, #+0]
   \   0000023E   0x.... 0x....      BL       USB_ReadInterrupts
   \   00000242   0x04C0             LSLS     R0,R0,#+19
   \   00000244   0xD551             BPL.N    ??HAL_PCD_IRQHandler_19
    502              {
    503                USBx_DEVICE->DCTL &= ~USB_OTG_DCTL_RWUSIG; 
   \   00000246   0x9800             LDR      R0,[SP, #+0]
   \   00000248   0x6840             LDR      R0,[R0, #+4]
   \   0000024A   0x9900             LDR      R1,[SP, #+0]
   \   0000024C   0x0840             LSRS     R0,R0,#+1
   \   0000024E   0x0040             LSLS     R0,R0,#+1
   \   00000250   0x6048             STR      R0,[R1, #+4]
    504                USB_FlushTxFifo(hpcd->Instance ,  0 );
   \   00000252   0x6820             LDR      R0,[R4, #+0]
   \   00000254   0x2100             MOVS     R1,#+0
   \   00000256   0x.... 0x....      BL       USB_FlushTxFifo
    505                
    506                for (i = 0; i < hpcd->Init.dev_endpoints ; i++)
   \   0000025A   0x9801             LDR      R0,[SP, #+4]
   \   0000025C   0x6862             LDR      R2,[R4, #+4]
   \   0000025E   0x21FF             MOVS     R1,#+255
   \   00000260   0xF500 0x6010      ADD      R0,R0,#+2304
   \   00000264   0xB14A             CBZ.N    R2,??HAL_PCD_IRQHandler_20
    507                {
    508                  USBx_INEP(i)->DIEPINT = 0xFF;
   \                     ??HAL_PCD_IRQHandler_21: (+1)
   \   00000266   0x6081             STR      R1,[R0, #+8]
    509                  USBx_OUTEP(i)->DOEPINT = 0xFF;
   \   00000268   0xF500 0x7200      ADD      R2,R0,#+512
   \   0000026C   0x6091             STR      R1,[R2, #+8]
    510                }
   \   0000026E   0x6862             LDR      R2,[R4, #+4]
   \   00000270   0xF10A 0x0A01      ADD      R10,R10,#+1
   \   00000274   0x3020             ADDS     R0,R0,#+32
   \   00000276   0x4592             CMP      R10,R2
   \   00000278   0xD3F5             BCC.N    ??HAL_PCD_IRQHandler_21
    511                USBx_DEVICE->DAINT = 0xFFFFFFFF;
   \                     ??HAL_PCD_IRQHandler_20: (+1)
   \   0000027A   0x9900             LDR      R1,[SP, #+0]
   \   0000027C   0xF04F 0x30FF      MOV      R0,#-1
   \   00000280   0x6188             STR      R0,[R1, #+24]
    512                USBx_DEVICE->DAINTMSK |= 0x10001;
   \   00000282   0x9800             LDR      R0,[SP, #+0]
   \   00000284   0x69C0             LDR      R0,[R0, #+28]
   \   00000286   0x9900             LDR      R1,[SP, #+0]
   \   00000288   0xF040 0x1001      ORR      R0,R0,#0x10001
   \   0000028C   0x61C8             STR      R0,[R1, #+28]
    513                
    514                if(hpcd->Init.use_dedicated_ep1)
   \   0000028E   0x6AE0             LDR      R0,[R4, #+44]
   \   00000290   0x2800             CMP      R0,#+0
   \   00000292   0x9800             LDR      R0,[SP, #+0]
   \   00000294   0xD00D             BEQ.N    ??HAL_PCD_IRQHandler_22
    515                {
    516                  USBx_DEVICE->DOUTEP1MSK |= (USB_OTG_DOEPMSK_STUPM | USB_OTG_DOEPMSK_XFRCM | USB_OTG_DOEPMSK_EPDM); 
   \   00000296   0xF8D0 0x0084      LDR      R0,[R0, #+132]
   \   0000029A   0x9900             LDR      R1,[SP, #+0]
   \   0000029C   0xF040 0x000B      ORR      R0,R0,#0xB
   \   000002A0   0xF8C1 0x0084      STR      R0,[R1, #+132]
    517                  USBx_DEVICE->DINEP1MSK |= (USB_OTG_DIEPMSK_TOM | USB_OTG_DIEPMSK_XFRCM | USB_OTG_DIEPMSK_EPDM);  
   \   000002A4   0x9800             LDR      R0,[SP, #+0]
   \   000002A6   0x6C40             LDR      R0,[R0, #+68]
   \   000002A8   0x9900             LDR      R1,[SP, #+0]
   \   000002AA   0xF040 0x000B      ORR      R0,R0,#0xB
   \   000002AE   0x6448             STR      R0,[R1, #+68]
   \   000002B0   0xE00A             B.N      ??HAL_PCD_IRQHandler_23
    518                }
    519                else
    520                {
    521                  USBx_DEVICE->DOEPMSK |= (USB_OTG_DOEPMSK_STUPM | USB_OTG_DOEPMSK_XFRCM | USB_OTG_DOEPMSK_EPDM | USB_OTG_DOEPMSK_OTEPSPRM);
   \                     ??HAL_PCD_IRQHandler_22: (+1)
   \   000002B2   0x6940             LDR      R0,[R0, #+20]
   \   000002B4   0x9900             LDR      R1,[SP, #+0]
   \   000002B6   0xF040 0x002B      ORR      R0,R0,#0x2B
   \   000002BA   0x6148             STR      R0,[R1, #+20]
    522                  USBx_DEVICE->DIEPMSK |= (USB_OTG_DIEPMSK_TOM | USB_OTG_DIEPMSK_XFRCM | USB_OTG_DIEPMSK_EPDM);
   \   000002BC   0x9800             LDR      R0,[SP, #+0]
   \   000002BE   0x6900             LDR      R0,[R0, #+16]
   \   000002C0   0x9900             LDR      R1,[SP, #+0]
   \   000002C2   0xF040 0x000B      ORR      R0,R0,#0xB
   \   000002C6   0x6108             STR      R0,[R1, #+16]
    523                }
    524                
    525                /* Set Default Address to 0 */
    526                USBx_DEVICE->DCFG &= ~USB_OTG_DCFG_DAD;
   \                     ??HAL_PCD_IRQHandler_23: (+1)
   \   000002C8   0x9800             LDR      R0,[SP, #+0]
    527                
    528                /* setup EP0 to receive SETUP packets */
    529                USB_EP0_OutStart(hpcd->Instance, hpcd->Init.dma_enable, (uint8_t *)hpcd->Setup);
   \   000002CA   0xF504 0x7260      ADD      R2,R4,#+896
   \   000002CE   0x6800             LDR      R0,[R0, #+0]
   \   000002D0   0x9900             LDR      R1,[SP, #+0]
   \   000002D2   0xF420 0x60FE      BIC      R0,R0,#0x7F0
   \   000002D6   0x6008             STR      R0,[R1, #+0]
   \   000002D8   0x6921             LDR      R1,[R4, #+16]
   \   000002DA   0x6820             LDR      R0,[R4, #+0]
   \   000002DC   0xB2C9             UXTB     R1,R1
   \   000002DE   0x.... 0x....      BL       USB_EP0_OutStart
    530                  
    531                __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_USBRST);
   \   000002E2   0x6821             LDR      R1,[R4, #+0]
   \   000002E4   0xF44F 0x5080      MOV      R0,#+4096
   \   000002E8   0x6148             STR      R0,[R1, #+20]
    532              }
    533              
    534              /* Handle Enumeration done Interrupt */
    535              if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_ENUMDNE))
   \                     ??HAL_PCD_IRQHandler_19: (+1)
   \   000002EA   0x6820             LDR      R0,[R4, #+0]
   \   000002EC   0x.... 0x....      BL       USB_ReadInterrupts
   \   000002F0   0x0480             LSLS     R0,R0,#+18
   \   000002F2   0xD523             BPL.N    ??HAL_PCD_IRQHandler_24
    536              {
    537                USB_ActivateSetup(hpcd->Instance);
   \   000002F4   0x6820             LDR      R0,[R4, #+0]
   \   000002F6   0x.... 0x....      BL       USB_ActivateSetup
    538                hpcd->Instance->GUSBCFG &= ~USB_OTG_GUSBCFG_TRDT;
   \   000002FA   0x6820             LDR      R0,[R4, #+0]
   \   000002FC   0x68C1             LDR      R1,[R0, #+12]
   \   000002FE   0xF421 0x5170      BIC      R1,R1,#0x3C00
   \   00000302   0x60C1             STR      R1,[R0, #+12]
    539                
    540                if ( USB_GetDevSpeed(hpcd->Instance) == USB_OTG_SPEED_HIGH)
   \   00000304   0x.... 0x....      BL       USB_GetDevSpeed
   \   00000308   0xB940             CBNZ.N   R0,??HAL_PCD_IRQHandler_25
    541                {
    542                  hpcd->Init.speed            = USB_OTG_SPEED_HIGH;
   \   0000030A   0x60E0             STR      R0,[R4, #+12]
    543                  hpcd->Init.ep0_mps          = USB_OTG_HS_MAX_PACKET_SIZE ;
   \   0000030C   0xF44F 0x7000      MOV      R0,#+512
   \   00000310   0x6160             STR      R0,[R4, #+20]
    544                  hpcd->Instance->GUSBCFG |= (uint32_t)((USBD_HS_TRDT_VALUE << 10) & USB_OTG_GUSBCFG_TRDT);
   \   00000312   0x6820             LDR      R0,[R4, #+0]
   \   00000314   0x68C1             LDR      R1,[R0, #+12]
   \   00000316   0xF441 0x5110      ORR      R1,R1,#0x2400
   \   0000031A   0xE007             B.N      ??HAL_PCD_IRQHandler_26
    545                }
    546                else
    547                {
    548                  hpcd->Init.speed            = USB_OTG_SPEED_FULL;
   \                     ??HAL_PCD_IRQHandler_25: (+1)
   \   0000031C   0x2003             MOVS     R0,#+3
   \   0000031E   0x60E0             STR      R0,[R4, #+12]
    549                  hpcd->Init.ep0_mps          = USB_OTG_FS_MAX_PACKET_SIZE ;  
   \   00000320   0x2040             MOVS     R0,#+64
   \   00000322   0x6160             STR      R0,[R4, #+20]
    550                  hpcd->Instance->GUSBCFG |= (uint32_t)((USBD_FS_TRDT_VALUE << 10) & USB_OTG_GUSBCFG_TRDT);
   \   00000324   0x6820             LDR      R0,[R4, #+0]
   \   00000326   0x68C1             LDR      R1,[R0, #+12]
   \   00000328   0xF441 0x51A0      ORR      R1,R1,#0x1400
   \                     ??HAL_PCD_IRQHandler_26: (+1)
   \   0000032C   0x60C1             STR      R1,[R0, #+12]
    551                }
    552                
    553                HAL_PCD_ResetCallback(hpcd);
   \   0000032E   0x4620             MOV      R0,R4
   \   00000330   0x.... 0x....      BL       HAL_PCD_ResetCallback
    554                
    555                __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_ENUMDNE);
   \   00000334   0x6821             LDR      R1,[R4, #+0]
   \   00000336   0xF44F 0x5000      MOV      R0,#+8192
   \   0000033A   0x6148             STR      R0,[R1, #+20]
    556              }
    557              
    558              /* Handle RxQLevel Interrupt */
    559              if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_RXFLVL))
   \                     ??HAL_PCD_IRQHandler_24: (+1)
   \   0000033C   0x6820             LDR      R0,[R4, #+0]
   \   0000033E   0x.... 0x....      BL       USB_ReadInterrupts
   \   00000342   0x06C0             LSLS     R0,R0,#+27
   \   00000344   0xD538             BPL.N    ??HAL_PCD_IRQHandler_27
    560              {
    561                USB_MASK_INTERRUPT(hpcd->Instance, USB_OTG_GINTSTS_RXFLVL);
   \   00000346   0x6820             LDR      R0,[R4, #+0]
   \   00000348   0x6981             LDR      R1,[R0, #+24]
   \   0000034A   0xF021 0x0110      BIC      R1,R1,#0x10
   \   0000034E   0x6181             STR      R1,[R0, #+24]
    562                temp = USBx->GRXSTSP;
   \   00000350   0x9801             LDR      R0,[SP, #+4]
   \   00000352   0xF8D0 0xA020      LDR      R10,[R0, #+32]
    563                ep = &hpcd->OUT_ep[temp & USB_OTG_GRXSTSP_EPNUM];
   \   00000356   0xF00A 0x000F      AND      R0,R10,#0xF
   \   0000035A   0xEBC0 0x01C0      RSB      R1,R0,R0, LSL #+3
   \   0000035E   0xEB04 0x0081      ADD      R0,R4,R1, LSL #+2
   \   00000362   0xF500 0x77EC      ADD      R7,R0,#+472
    564                
    565                if(((temp & USB_OTG_GRXSTSP_PKTSTS) >> 17) ==  STS_DATA_UPDT)
   \   00000366   0xF3CA 0x4043      UBFX     R0,R10,#+17,#+4
   \   0000036A   0x2802             CMP      R0,#+2
   \   0000036C   0xD112             BNE.N    ??HAL_PCD_IRQHandler_28
    566                {
    567                  if((temp & USB_OTG_GRXSTSP_BCNT) != 0)
   \   0000036E   0xF647 0x70F0      MOVW     R0,#+32752
   \   00000372   0xEA1A 0x0F00      TST      R10,R0
   \   00000376   0xD01A             BEQ.N    ??HAL_PCD_IRQHandler_29
    568                  {
    569                    USB_ReadPacket(USBx, ep->xfer_buff, (temp & USB_OTG_GRXSTSP_BCNT) >> 4);
   \   00000378   0x68F9             LDR      R1,[R7, #+12]
   \   0000037A   0x9801             LDR      R0,[SP, #+4]
   \   0000037C   0xF3CA 0x120A      UBFX     R2,R10,#+4,#+11
   \   00000380   0x.... 0x....      BL       USB_ReadPacket
    570                    ep->xfer_buff += (temp & USB_OTG_GRXSTSP_BCNT) >> 4;
   \   00000384   0x68F9             LDR      R1,[R7, #+12]
   \   00000386   0xF3CA 0x100A      UBFX     R0,R10,#+4,#+11
   \   0000038A   0x1841             ADDS     R1,R0,R1
   \   0000038C   0x60F9             STR      R1,[R7, #+12]
    571                    ep->xfer_count += (temp & USB_OTG_GRXSTSP_BCNT) >> 4;
   \   0000038E   0x69B9             LDR      R1,[R7, #+24]
   \   00000390   0x1840             ADDS     R0,R0,R1
   \   00000392   0xE00B             B.N      ??HAL_PCD_IRQHandler_30
    572                  }
    573                }
    574                else if (((temp & USB_OTG_GRXSTSP_PKTSTS) >> 17) ==  STS_SETUP_UPDT)
   \                     ??HAL_PCD_IRQHandler_28: (+1)
   \   00000394   0x2806             CMP      R0,#+6
   \   00000396   0xD10A             BNE.N    ??HAL_PCD_IRQHandler_29
    575                {
    576                  USB_ReadPacket(USBx, (uint8_t *)hpcd->Setup, 8);
   \   00000398   0x9801             LDR      R0,[SP, #+4]
   \   0000039A   0x2208             MOVS     R2,#+8
   \   0000039C   0xF504 0x7160      ADD      R1,R4,#+896
   \   000003A0   0x.... 0x....      BL       USB_ReadPacket
    577                  ep->xfer_count += (temp & USB_OTG_GRXSTSP_BCNT) >> 4;
   \   000003A4   0x69B8             LDR      R0,[R7, #+24]
   \   000003A6   0xF3CA 0x110A      UBFX     R1,R10,#+4,#+11
   \   000003AA   0x1808             ADDS     R0,R1,R0
   \                     ??HAL_PCD_IRQHandler_30: (+1)
   \   000003AC   0x61B8             STR      R0,[R7, #+24]
    578                }
    579                USB_UNMASK_INTERRUPT(hpcd->Instance, USB_OTG_GINTSTS_RXFLVL);
   \                     ??HAL_PCD_IRQHandler_29: (+1)
   \   000003AE   0x6820             LDR      R0,[R4, #+0]
   \   000003B0   0x6981             LDR      R1,[R0, #+24]
   \   000003B2   0xF041 0x0110      ORR      R1,R1,#0x10
   \   000003B6   0x6181             STR      R1,[R0, #+24]
    580              }
    581              
    582              /* Handle SOF Interrupt */
    583              if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_SOF))
   \                     ??HAL_PCD_IRQHandler_27: (+1)
   \   000003B8   0x6820             LDR      R0,[R4, #+0]
   \   000003BA   0x.... 0x....      BL       USB_ReadInterrupts
   \   000003BE   0x0700             LSLS     R0,R0,#+28
   \   000003C0   0xD505             BPL.N    ??HAL_PCD_IRQHandler_31
    584              {
    585                HAL_PCD_SOFCallback(hpcd);
   \   000003C2   0x4620             MOV      R0,R4
   \   000003C4   0x.... 0x....      BL       HAL_PCD_SOFCallback
    586                __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_SOF);
   \   000003C8   0x6821             LDR      R1,[R4, #+0]
   \   000003CA   0x2008             MOVS     R0,#+8
   \   000003CC   0x6148             STR      R0,[R1, #+20]
    587              }
    588              
    589              /* Handle Incomplete ISO IN Interrupt */
    590              if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_IISOIXFR))
   \                     ??HAL_PCD_IRQHandler_31: (+1)
   \   000003CE   0x6820             LDR      R0,[R4, #+0]
   \   000003D0   0x.... 0x....      BL       USB_ReadInterrupts
   \   000003D4   0x02C0             LSLS     R0,R0,#+11
   \   000003D6   0xD507             BPL.N    ??HAL_PCD_IRQHandler_32
    591              {
    592                HAL_PCD_ISOINIncompleteCallback(hpcd, epnum);
   \   000003D8   0xB2E9             UXTB     R1,R5
   \   000003DA   0x4620             MOV      R0,R4
   \   000003DC   0x.... 0x....      BL       HAL_PCD_ISOINIncompleteCallback
    593                __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_IISOIXFR);
   \   000003E0   0x6821             LDR      R1,[R4, #+0]
   \   000003E2   0xF44F 0x1080      MOV      R0,#+1048576
   \   000003E6   0x6148             STR      R0,[R1, #+20]
    594              } 
    595              
    596              /* Handle Incomplete ISO OUT Interrupt */
    597              if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_PXFR_INCOMPISOOUT))
   \                     ??HAL_PCD_IRQHandler_32: (+1)
   \   000003E8   0x6820             LDR      R0,[R4, #+0]
   \   000003EA   0x.... 0x....      BL       USB_ReadInterrupts
   \   000003EE   0x0280             LSLS     R0,R0,#+10
   \   000003F0   0xD507             BPL.N    ??HAL_PCD_IRQHandler_33
    598              {
    599                HAL_PCD_ISOOUTIncompleteCallback(hpcd, epnum);
   \   000003F2   0xB2E9             UXTB     R1,R5
   \   000003F4   0x4620             MOV      R0,R4
   \   000003F6   0x.... 0x....      BL       HAL_PCD_ISOOUTIncompleteCallback
    600                __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_PXFR_INCOMPISOOUT);
   \   000003FA   0x6821             LDR      R1,[R4, #+0]
   \   000003FC   0xF44F 0x1000      MOV      R0,#+2097152
   \   00000400   0x6148             STR      R0,[R1, #+20]
    601              } 
    602              
    603              /* Handle Connection event Interrupt */
    604              if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_SRQINT))
   \                     ??HAL_PCD_IRQHandler_33: (+1)
   \   00000402   0x6820             LDR      R0,[R4, #+0]
   \   00000404   0x.... 0x....      BL       USB_ReadInterrupts
   \   00000408   0x0040             LSLS     R0,R0,#+1
   \   0000040A   0xD506             BPL.N    ??HAL_PCD_IRQHandler_34
    605              {
    606                HAL_PCD_ConnectCallback(hpcd);
   \   0000040C   0x4620             MOV      R0,R4
   \   0000040E   0x.... 0x....      BL       HAL_PCD_ConnectCallback
    607                __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_SRQINT);
   \   00000412   0x6821             LDR      R1,[R4, #+0]
   \   00000414   0xF04F 0x4080      MOV      R0,#+1073741824
   \   00000418   0x6148             STR      R0,[R1, #+20]
    608              } 
    609              
    610              /* Handle Disconnection event Interrupt */
    611              if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_OTGINT))
   \                     ??HAL_PCD_IRQHandler_34: (+1)
   \   0000041A   0x6820             LDR      R0,[R4, #+0]
   \   0000041C   0x.... 0x....      BL       USB_ReadInterrupts
   \   00000420   0x0740             LSLS     R0,R0,#+29
   \   00000422   0xD50A             BPL.N    ??HAL_PCD_IRQHandler_0
    612              {
    613                temp = hpcd->Instance->GOTGINT;
   \   00000424   0x6820             LDR      R0,[R4, #+0]
   \   00000426   0x6845             LDR      R5,[R0, #+4]
    614                
    615                if((temp & USB_OTG_GOTGINT_SEDET) == USB_OTG_GOTGINT_SEDET)
   \   00000428   0x0768             LSLS     R0,R5,#+29
   \   0000042A   0xBF44             ITT      MI 
    616                {
    617                  HAL_PCD_DisconnectCallback(hpcd);
   \   0000042C   0x4620             MOVMI    R0,R4
   \   0000042E   0x.... 0x....      BLMI     HAL_PCD_DisconnectCallback
    618                }
    619                hpcd->Instance->GOTGINT |= temp;
   \   00000432   0x6820             LDR      R0,[R4, #+0]
   \   00000434   0x6841             LDR      R1,[R0, #+4]
   \   00000436   0x4329             ORRS     R1,R5,R1
   \   00000438   0x6041             STR      R1,[R0, #+4]
    620              }
    621            }
    622          }
   \                     ??HAL_PCD_IRQHandler_0: (+1)
   \   0000043A   0xB002             ADD      SP,SP,#+8
   \   0000043C   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
    623          
    624          /**
    625            * @brief  Data OUT stage callback.
    626            * @param  hpcd: PCD handle
    627            * @param  epnum: endpoint number  
    628            * @retval None
    629            */

   \                                 In section .text, align 2, keep-with-next
    630           __weak void HAL_PCD_DataOutStageCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
    631          {
    632            /* Prevent unused argument(s) compilation warning */
    633            UNUSED(hpcd);
    634            UNUSED(epnum);  
    635            /* NOTE : This function Should not be modified, when the callback is needed,
    636                      the HAL_PCD_DataOutStageCallback could be implemented in the user file
    637             */ 
    638          }
   \                     HAL_PCD_DataOutStageCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    639          
    640          /**
    641            * @brief  Data IN stage callback.
    642            * @param  hpcd: PCD handle
    643            * @param  epnum: endpoint number  
    644            * @retval None
    645            */

   \                                 In section .text, align 2, keep-with-next
    646           __weak void HAL_PCD_DataInStageCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
    647          {
    648            /* Prevent unused argument(s) compilation warning */
    649            UNUSED(hpcd);
    650            UNUSED(epnum); 
    651            /* NOTE : This function Should not be modified, when the callback is needed,
    652                      the HAL_PCD_DataInStageCallback could be implemented in the user file
    653             */ 
    654          }
   \                     HAL_PCD_DataInStageCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    655          /**
    656            * @brief  Setup stage callback.
    657            * @param  hpcd: PCD handle
    658            * @retval None
    659            */

   \                                 In section .text, align 2, keep-with-next
    660           __weak void HAL_PCD_SetupStageCallback(PCD_HandleTypeDef *hpcd)
    661          {
    662            /* Prevent unused argument(s) compilation warning */
    663            UNUSED(hpcd);
    664            
    665            /* NOTE : This function Should not be modified, when the callback is needed,
    666                      the HAL_PCD_SetupStageCallback could be implemented in the user file
    667             */ 
    668          }
   \                     HAL_PCD_SetupStageCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    669          
    670          /**
    671            * @brief  USB Start Of Frame callback.
    672            * @param  hpcd: PCD handle
    673            * @retval None
    674            */

   \                                 In section .text, align 2, keep-with-next
    675           __weak void HAL_PCD_SOFCallback(PCD_HandleTypeDef *hpcd)
    676          {
    677            /* Prevent unused argument(s) compilation warning */
    678            UNUSED(hpcd);
    679            
    680            /* NOTE : This function Should not be modified, when the callback is needed,
    681                      the HAL_PCD_SOFCallback could be implemented in the user file
    682             */ 
    683          }
   \                     HAL_PCD_SOFCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    684          
    685          /**
    686            * @brief  USB Reset callback.
    687            * @param  hpcd: PCD handle
    688            * @retval None
    689            */

   \                                 In section .text, align 2, keep-with-next
    690           __weak void HAL_PCD_ResetCallback(PCD_HandleTypeDef *hpcd)
    691          {
    692            /* Prevent unused argument(s) compilation warning */
    693            UNUSED(hpcd);
    694            
    695            /* NOTE : This function Should not be modified, when the callback is needed,
    696                      the HAL_PCD_ResetCallback could be implemented in the user file
    697             */ 
    698          }
   \                     HAL_PCD_ResetCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    699          
    700          /**
    701            * @brief  Suspend event callback.
    702            * @param  hpcd: PCD handle
    703            * @retval None
    704            */

   \                                 In section .text, align 2, keep-with-next
    705           __weak void HAL_PCD_SuspendCallback(PCD_HandleTypeDef *hpcd)
    706          {
    707            /* Prevent unused argument(s) compilation warning */
    708            UNUSED(hpcd);
    709            
    710            /* NOTE : This function Should not be modified, when the callback is needed,
    711                      the HAL_PCD_SuspendCallback could be implemented in the user file
    712             */ 
    713          }
   \                     HAL_PCD_SuspendCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    714          
    715          /**
    716            * @brief  Resume event callback.
    717            * @param  hpcd: PCD handle
    718            * @retval None
    719            */

   \                                 In section .text, align 2, keep-with-next
    720           __weak void HAL_PCD_ResumeCallback(PCD_HandleTypeDef *hpcd)
    721          {
    722            /* Prevent unused argument(s) compilation warning */
    723            UNUSED(hpcd);
    724            
    725            /* NOTE : This function Should not be modified, when the callback is needed,
    726                      the HAL_PCD_ResumeCallback could be implemented in the user file
    727             */ 
    728          }
   \                     HAL_PCD_ResumeCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    729          
    730          /**
    731            * @brief  Incomplete ISO OUT callback.
    732            * @param  hpcd: PCD handle
    733            * @param  epnum: endpoint number
    734            * @retval None
    735            */

   \                                 In section .text, align 2, keep-with-next
    736           __weak void HAL_PCD_ISOOUTIncompleteCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
    737          {
    738            /* Prevent unused argument(s) compilation warning */
    739            UNUSED(hpcd);
    740            UNUSED(epnum);  
    741            /* NOTE : This function Should not be modified, when the callback is needed,
    742                      the HAL_PCD_ISOOUTIncompleteCallback could be implemented in the user file
    743             */ 
    744          }
   \                     HAL_PCD_ISOOUTIncompleteCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    745          
    746          /**
    747            * @brief  Incomplete ISO IN  callback.
    748            * @param  hpcd: PCD handle
    749            * @param  epnum: endpoint number  
    750            * @retval None
    751            */

   \                                 In section .text, align 2, keep-with-next
    752           __weak void HAL_PCD_ISOINIncompleteCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
    753          {
    754            /* Prevent unused argument(s) compilation warning */
    755            UNUSED(hpcd);
    756            UNUSED(epnum);  
    757            /* NOTE : This function Should not be modified, when the callback is needed,
    758                      the HAL_PCD_ISOINIncompleteCallback could be implemented in the user file
    759             */ 
    760          }
   \                     HAL_PCD_ISOINIncompleteCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    761          
    762          /**
    763            * @brief  Connection event callback.
    764            * @param  hpcd: PCD handle
    765            * @retval None
    766            */

   \                                 In section .text, align 2, keep-with-next
    767           __weak void HAL_PCD_ConnectCallback(PCD_HandleTypeDef *hpcd)
    768          {
    769            /* Prevent unused argument(s) compilation warning */
    770            UNUSED(hpcd);
    771            
    772            /* NOTE : This function Should not be modified, when the callback is needed,
    773                      the HAL_PCD_ConnectCallback could be implemented in the user file
    774             */ 
    775          }
   \                     HAL_PCD_ConnectCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    776          
    777          /**
    778            * @brief  Disconnection event callback.
    779            * @param  hpcd: PCD handle
    780            * @retval None
    781            */

   \                                 In section .text, align 2, keep-with-next
    782           __weak void HAL_PCD_DisconnectCallback(PCD_HandleTypeDef *hpcd)
    783          {
    784            /* Prevent unused argument(s) compilation warning */
    785            UNUSED(hpcd);
    786            
    787            /* NOTE : This function Should not be modified, when the callback is needed,
    788                      the HAL_PCD_DisconnectCallback could be implemented in the user file
    789             */ 
    790          }
   \                     HAL_PCD_DisconnectCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    791          
    792          /**
    793            * @}
    794            */
    795            
    796          /** @defgroup PCD_Exported_Functions_Group3 Peripheral Control functions
    797           *  @brief   management functions 
    798           *
    799          @verbatim   
    800           ===============================================================================
    801                                ##### Peripheral Control functions #####
    802           ===============================================================================  
    803              [..]
    804              This subsection provides a set of functions allowing to control the PCD data 
    805              transfers.
    806          
    807          @endverbatim
    808            * @{
    809            */
    810          
    811          /**
    812            * @brief  Connect the USB device.
    813            * @param  hpcd: PCD handle
    814            * @retval HAL status
    815            */

   \                                 In section .text, align 2, keep-with-next
    816          HAL_StatusTypeDef HAL_PCD_DevConnect(PCD_HandleTypeDef *hpcd)
    817          {
   \                     HAL_PCD_DevConnect: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    818            __HAL_LOCK(hpcd); 
   \   00000004   0xF894 0x037C      LDRB     R0,[R4, #+892]
   \   00000008   0x2801             CMP      R0,#+1
   \   0000000A   0xD101             BNE.N    ??HAL_PCD_DevConnect_0
   \   0000000C   0x2002             MOVS     R0,#+2
   \   0000000E   0xBD10             POP      {R4,PC}
   \                     ??HAL_PCD_DevConnect_0: (+1)
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0xF884 0x037C      STRB     R0,[R4, #+892]
    819            USB_DevConnect(hpcd->Instance);
   \   00000016   0x6820             LDR      R0,[R4, #+0]
   \   00000018   0x.... 0x....      BL       USB_DevConnect
    820            __HAL_UNLOCK(hpcd); 
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0xF884 0x037C      STRB     R0,[R4, #+892]
    821            return HAL_OK;
   \   00000022   0xBD10             POP      {R4,PC}          ;; return
    822          }
    823          
    824          /**
    825            * @brief  Disconnect the USB device.
    826            * @param  hpcd: PCD handle
    827            * @retval HAL status
    828            */

   \                                 In section .text, align 2, keep-with-next
    829          HAL_StatusTypeDef HAL_PCD_DevDisconnect(PCD_HandleTypeDef *hpcd)
    830          {
   \                     HAL_PCD_DevDisconnect: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    831            __HAL_LOCK(hpcd); 
   \   00000004   0xF894 0x037C      LDRB     R0,[R4, #+892]
   \   00000008   0x2801             CMP      R0,#+1
   \   0000000A   0xD101             BNE.N    ??HAL_PCD_DevDisconnect_0
   \   0000000C   0x2002             MOVS     R0,#+2
   \   0000000E   0xBD10             POP      {R4,PC}
   \                     ??HAL_PCD_DevDisconnect_0: (+1)
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0xF884 0x037C      STRB     R0,[R4, #+892]
    832            USB_DevDisconnect(hpcd->Instance);
   \   00000016   0x6820             LDR      R0,[R4, #+0]
   \   00000018   0x.... 0x....      BL       USB_DevDisconnect
    833            __HAL_UNLOCK(hpcd); 
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0xF884 0x037C      STRB     R0,[R4, #+892]
    834            return HAL_OK;
   \   00000022   0xBD10             POP      {R4,PC}          ;; return
    835          }
    836          
    837          /**
    838            * @brief  Set the USB Device address. 
    839            * @param  hpcd: PCD handle
    840            * @param  address: new device address
    841            * @retval HAL status
    842            */

   \                                 In section .text, align 2, keep-with-next
    843          HAL_StatusTypeDef HAL_PCD_SetAddress(PCD_HandleTypeDef *hpcd, uint8_t address)
    844          {
   \                     HAL_PCD_SetAddress: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    845            __HAL_LOCK(hpcd); 
   \   00000004   0xF894 0x037C      LDRB     R0,[R4, #+892]
   \   00000008   0x2801             CMP      R0,#+1
   \   0000000A   0xD101             BNE.N    ??HAL_PCD_SetAddress_0
   \   0000000C   0x2002             MOVS     R0,#+2
   \   0000000E   0xBD10             POP      {R4,PC}
   \                     ??HAL_PCD_SetAddress_0: (+1)
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0xF884 0x037C      STRB     R0,[R4, #+892]
    846            USB_SetDevAddress(hpcd->Instance, address);
   \   00000016   0x6820             LDR      R0,[R4, #+0]
   \   00000018   0x.... 0x....      BL       USB_SetDevAddress
    847            __HAL_UNLOCK(hpcd);   
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0xF884 0x037C      STRB     R0,[R4, #+892]
    848            return HAL_OK;
   \   00000022   0xBD10             POP      {R4,PC}          ;; return
    849          }
    850          /**
    851            * @brief  Open and configure an endpoint.
    852            * @param  hpcd: PCD handle
    853            * @param  ep_addr: endpoint address
    854            * @param  ep_mps: endpoint max packet size
    855            * @param  ep_type: endpoint type   
    856            * @retval HAL status
    857            */

   \                                 In section .text, align 2, keep-with-next
    858          HAL_StatusTypeDef HAL_PCD_EP_Open(PCD_HandleTypeDef *hpcd, uint8_t ep_addr, uint16_t ep_mps, uint8_t ep_type)
    859          {
   \                     HAL_PCD_EP_Open: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0x4604             MOV      R4,R0
    860            HAL_StatusTypeDef  ret = HAL_OK;
    861            USB_OTG_EPTypeDef *ep;
    862            
    863            if ((ep_addr & 0x80) == 0x80)
   \   00000004   0xF001 0x007F      AND      R0,R1,#0x7F
   \   00000008   0xEBC0 0x05C0      RSB      R5,R0,R0, LSL #+3
   \   0000000C   0xB081             SUB      SP,SP,#+4
   \   0000000E   0xEB04 0x0085      ADD      R0,R4,R5, LSL #+2
   \   00000012   0x060D             LSLS     R5,R1,#+24
    864            {
    865              ep = &hpcd->IN_ep[ep_addr & 0x7F];
    866            }
    867            else
    868            {
    869              ep = &hpcd->OUT_ep[ep_addr & 0x7F];
    870            }
    871            ep->num   = ep_addr & 0x7F;
   \   00000014   0xF001 0x057F      AND      R5,R1,#0x7F
   \   00000018   0xBF4C             ITE      MI 
   \   0000001A   0x3034             ADDMI    R0,R0,#+52
   \   0000001C   0xF500 0x70EC      ADDPL    R0,R0,#+472
   \   00000020   0x7005             STRB     R5,[R0, #+0]
    872            
    873            ep->is_in = (0x80 & ep_addr) != 0;
   \   00000022   0x09C9             LSRS     R1,R1,#+7
   \   00000024   0x7041             STRB     R1,[R0, #+1]
    874            ep->maxpacket = ep_mps;
    875            ep->type = ep_type;
    876            if (ep->is_in)
   \   00000026   0x7841             LDRB     R1,[R0, #+1]
   \   00000028   0x6082             STR      R2,[R0, #+8]
   \   0000002A   0x70C3             STRB     R3,[R0, #+3]
   \   0000002C   0xB109             CBZ.N    R1,??HAL_PCD_EP_Open_0
    877            {
    878              /* Assign a Tx FIFO */
    879              ep->tx_fifo_num = ep->num;
   \   0000002E   0x7801             LDRB     R1,[R0, #+0]
   \   00000030   0x80C1             STRH     R1,[R0, #+6]
    880            }
    881            /* Set initial data PID. */
    882            if (ep_type == EP_TYPE_BULK )
   \                     ??HAL_PCD_EP_Open_0: (+1)
   \   00000032   0x2B02             CMP      R3,#+2
   \   00000034   0xBF04             ITT      EQ 
   \   00000036   0x2100             MOVEQ    R1,#+0
   \   00000038   0x7101             STRBEQ   R1,[R0, #+4]
    883            {
    884              ep->data_pid_start = 0;
    885            }
    886            
    887            __HAL_LOCK(hpcd); 
   \   0000003A   0xF894 0x137C      LDRB     R1,[R4, #+892]
   \   0000003E   0x2901             CMP      R1,#+1
   \   00000040   0xBF08             IT       EQ 
   \   00000042   0x2002             MOVEQ    R0,#+2
   \   00000044   0xD009             BEQ.N    ??HAL_PCD_EP_Open_1
   \   00000046   0x2101             MOVS     R1,#+1
   \   00000048   0xF884 0x137C      STRB     R1,[R4, #+892]
    888            USB_ActivateEndpoint(hpcd->Instance , ep);
   \   0000004C   0x4601             MOV      R1,R0
   \   0000004E   0x6820             LDR      R0,[R4, #+0]
   \   00000050   0x.... 0x....      BL       USB_ActivateEndpoint
    889            __HAL_UNLOCK(hpcd);   
   \   00000054   0x2000             MOVS     R0,#+0
   \   00000056   0xF884 0x037C      STRB     R0,[R4, #+892]
    890            return ret;
   \                     ??HAL_PCD_EP_Open_1: (+1)
   \   0000005A   0xB001             ADD      SP,SP,#+4
   \   0000005C   0xBD30             POP      {R4,R5,PC}       ;; return
    891          }
    892          
    893          
    894          /**
    895            * @brief  Deactivate an endpoint.
    896            * @param  hpcd: PCD handle
    897            * @param  ep_addr: endpoint address
    898            * @retval HAL status
    899            */

   \                                 In section .text, align 2, keep-with-next
    900          HAL_StatusTypeDef HAL_PCD_EP_Close(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)
    901          {  
   \                     HAL_PCD_EP_Close: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    902            USB_OTG_EPTypeDef *ep;
    903            
    904            if ((ep_addr & 0x80) == 0x80)
   \   00000004   0xF001 0x007F      AND      R0,R1,#0x7F
   \   00000008   0xEBC0 0x02C0      RSB      R2,R0,R0, LSL #+3
   \   0000000C   0xEB04 0x0082      ADD      R0,R4,R2, LSL #+2
   \   00000010   0x060A             LSLS     R2,R1,#+24
    905            {
    906              ep = &hpcd->IN_ep[ep_addr & 0x7F];
    907            }
    908            else
    909            {
    910              ep = &hpcd->OUT_ep[ep_addr & 0x7F];
    911            }
    912            ep->num   = ep_addr & 0x7F;
   \   00000012   0xF001 0x027F      AND      R2,R1,#0x7F
   \   00000016   0xBF4C             ITE      MI 
   \   00000018   0x3034             ADDMI    R0,R0,#+52
   \   0000001A   0xF500 0x70EC      ADDPL    R0,R0,#+472
   \   0000001E   0x7002             STRB     R2,[R0, #+0]
    913            
    914            ep->is_in = (0x80 & ep_addr) != 0;
   \   00000020   0x09C9             LSRS     R1,R1,#+7
   \   00000022   0x7041             STRB     R1,[R0, #+1]
    915            
    916            __HAL_LOCK(hpcd); 
   \   00000024   0xF894 0x137C      LDRB     R1,[R4, #+892]
   \   00000028   0x2901             CMP      R1,#+1
   \   0000002A   0xD101             BNE.N    ??HAL_PCD_EP_Close_0
   \   0000002C   0x2002             MOVS     R0,#+2
   \   0000002E   0xBD10             POP      {R4,PC}
   \                     ??HAL_PCD_EP_Close_0: (+1)
   \   00000030   0x2101             MOVS     R1,#+1
   \   00000032   0xF884 0x137C      STRB     R1,[R4, #+892]
    917            USB_DeactivateEndpoint(hpcd->Instance , ep);
   \   00000036   0x4601             MOV      R1,R0
   \   00000038   0x6820             LDR      R0,[R4, #+0]
   \   0000003A   0x.... 0x....      BL       USB_DeactivateEndpoint
    918            __HAL_UNLOCK(hpcd);   
   \   0000003E   0x2000             MOVS     R0,#+0
   \   00000040   0xF884 0x037C      STRB     R0,[R4, #+892]
    919            return HAL_OK;
   \   00000044   0xBD10             POP      {R4,PC}          ;; return
    920          }
    921          
    922          
    923          /**
    924            * @brief  Receive an amount of data.  
    925            * @param  hpcd: PCD handle
    926            * @param  ep_addr: endpoint address
    927            * @param  pBuf: pointer to the reception buffer   
    928            * @param  len: amount of data to be received
    929            * @retval HAL status
    930            */

   \                                 In section .text, align 2, keep-with-next
    931          HAL_StatusTypeDef HAL_PCD_EP_Receive(PCD_HandleTypeDef *hpcd, uint8_t ep_addr, uint8_t *pBuf, uint32_t len)
    932          {
   \                     HAL_PCD_EP_Receive: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x4608             MOV      R0,R1
    933            USB_OTG_EPTypeDef *ep;
    934            
    935            ep = &hpcd->OUT_ep[ep_addr & 0x7F];
   \   00000006   0xF000 0x017F      AND      R1,R0,#0x7F
   \   0000000A   0xB081             SUB      SP,SP,#+4
   \   0000000C   0xEBC1 0x05C1      RSB      R5,R1,R1, LSL #+3
   \   00000010   0xEB04 0x0185      ADD      R1,R4,R5, LSL #+2
   \   00000014   0xF501 0x71EC      ADD      R1,R1,#+472
    936            
    937            /*setup and start the Xfer */
    938            ep->xfer_buff = pBuf;  
    939            ep->xfer_len = len;
   \   00000018   0x614B             STR      R3,[R1, #+20]
    940            ep->xfer_count = 0;
   \   0000001A   0x2300             MOVS     R3,#+0
   \   0000001C   0x618B             STR      R3,[R1, #+24]
    941            ep->is_in = 0;
   \   0000001E   0x704B             STRB     R3,[R1, #+1]
    942            ep->num = ep_addr & 0x7F;
   \   00000020   0xF000 0x037F      AND      R3,R0,#0x7F
   \   00000024   0x60CA             STR      R2,[R1, #+12]
   \   00000026   0x700B             STRB     R3,[R1, #+0]
    943            
    944            if (hpcd->Init.dma_enable == 1)
   \   00000028   0x6920             LDR      R0,[R4, #+16]
   \   0000002A   0x2801             CMP      R0,#+1
   \   0000002C   0xBF08             IT       EQ 
   \   0000002E   0x610A             STREQ    R2,[R1, #+16]
    945            {
    946              ep->dma_addr = (uint32_t)pBuf;  
    947            }
    948            
    949            __HAL_LOCK(hpcd); 
   \   00000030   0xF894 0x037C      LDRB     R0,[R4, #+892]
   \   00000034   0x2801             CMP      R0,#+1
   \   00000036   0xBF08             IT       EQ 
   \   00000038   0x2002             MOVEQ    R0,#+2
   \   0000003A   0xD00F             BEQ.N    ??HAL_PCD_EP_Receive_0
   \   0000003C   0x2001             MOVS     R0,#+1
    950            
    951            if ((ep_addr & 0x7F) == 0 )
   \   0000003E   0x6922             LDR      R2,[R4, #+16]
   \   00000040   0x2B00             CMP      R3,#+0
   \   00000042   0xF884 0x037C      STRB     R0,[R4, #+892]
   \   00000046   0x6820             LDR      R0,[R4, #+0]
   \   00000048   0xB2D2             UXTB     R2,R2
   \   0000004A   0xD102             BNE.N    ??HAL_PCD_EP_Receive_1
    952            {
    953              USB_EP0StartXfer(hpcd->Instance , ep, hpcd->Init.dma_enable);
   \   0000004C   0x.... 0x....      BL       USB_EP0StartXfer
   \   00000050   0xE001             B.N      ??HAL_PCD_EP_Receive_2
    954            }
    955            else
    956            {
    957              USB_EPStartXfer(hpcd->Instance , ep, hpcd->Init.dma_enable);
   \                     ??HAL_PCD_EP_Receive_1: (+1)
   \   00000052   0x.... 0x....      BL       USB_EPStartXfer
    958            }
    959            __HAL_UNLOCK(hpcd); 
   \                     ??HAL_PCD_EP_Receive_2: (+1)
   \   00000056   0x2000             MOVS     R0,#+0
   \   00000058   0xF884 0x037C      STRB     R0,[R4, #+892]
    960            
    961            return HAL_OK;
   \                     ??HAL_PCD_EP_Receive_0: (+1)
   \   0000005C   0xB001             ADD      SP,SP,#+4
   \   0000005E   0xBD30             POP      {R4,R5,PC}       ;; return
    962          }
    963          
    964          /**
    965            * @brief  Get Received Data Size.
    966            * @param  hpcd: PCD handle
    967            * @param  ep_addr: endpoint address
    968            * @retval Data Size
    969            */

   \                                 In section .text, align 2, keep-with-next
    970          uint16_t HAL_PCD_EP_GetRxCount(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)
    971          {
    972            return hpcd->OUT_ep[ep_addr & 0x7F].xfer_count;
   \                     HAL_PCD_EP_GetRxCount: (+1)
   \   00000000   0xF001 0x017F      AND      R1,R1,#0x7F
   \   00000004   0xEBC1 0x02C1      RSB      R2,R1,R1, LSL #+3
   \   00000008   0xEB00 0x0082      ADD      R0,R0,R2, LSL #+2
   \   0000000C   0xF8D0 0x01F0      LDR      R0,[R0, #+496]
   \   00000010   0xB280             UXTH     R0,R0
   \   00000012   0x4770             BX       LR               ;; return
    973          }
    974          /**
    975            * @brief  Send an amount of data.  
    976            * @param  hpcd: PCD handle
    977            * @param  ep_addr: endpoint address
    978            * @param  pBuf: pointer to the transmission buffer   
    979            * @param  len: amount of data to be sent
    980            * @retval HAL status
    981            */

   \                                 In section .text, align 2, keep-with-next
    982          HAL_StatusTypeDef HAL_PCD_EP_Transmit(PCD_HandleTypeDef *hpcd, uint8_t ep_addr, uint8_t *pBuf, uint32_t len)
    983          {
   \                     HAL_PCD_EP_Transmit: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x4608             MOV      R0,R1
    984            USB_OTG_EPTypeDef *ep;
    985            
    986            ep = &hpcd->IN_ep[ep_addr & 0x7F];
   \   00000006   0xF000 0x017F      AND      R1,R0,#0x7F
   \   0000000A   0xB081             SUB      SP,SP,#+4
   \   0000000C   0xEBC1 0x05C1      RSB      R5,R1,R1, LSL #+3
   \   00000010   0xEB04 0x0185      ADD      R1,R4,R5, LSL #+2
   \   00000014   0x3134             ADDS     R1,R1,#+52
    987            
    988            /*setup and start the Xfer */
    989            ep->xfer_buff = pBuf;  
    990            ep->xfer_len = len;
   \   00000016   0x614B             STR      R3,[R1, #+20]
    991            ep->xfer_count = 0;
   \   00000018   0x2300             MOVS     R3,#+0
   \   0000001A   0x618B             STR      R3,[R1, #+24]
    992            ep->is_in = 1;
   \   0000001C   0x2301             MOVS     R3,#+1
   \   0000001E   0x704B             STRB     R3,[R1, #+1]
    993            ep->num = ep_addr & 0x7F;
   \   00000020   0xF000 0x037F      AND      R3,R0,#0x7F
   \   00000024   0x60CA             STR      R2,[R1, #+12]
   \   00000026   0x700B             STRB     R3,[R1, #+0]
    994            
    995            if (hpcd->Init.dma_enable == 1)
   \   00000028   0x6920             LDR      R0,[R4, #+16]
   \   0000002A   0x2801             CMP      R0,#+1
   \   0000002C   0xBF08             IT       EQ 
   \   0000002E   0x610A             STREQ    R2,[R1, #+16]
    996            {
    997              ep->dma_addr = (uint32_t)pBuf;  
    998            }
    999            
   1000            __HAL_LOCK(hpcd); 
   \   00000030   0xF894 0x037C      LDRB     R0,[R4, #+892]
   \   00000034   0x2801             CMP      R0,#+1
   \   00000036   0xBF08             IT       EQ 
   \   00000038   0x2002             MOVEQ    R0,#+2
   \   0000003A   0xD00F             BEQ.N    ??HAL_PCD_EP_Transmit_0
   \   0000003C   0x2001             MOVS     R0,#+1
   1001            
   1002            if ((ep_addr & 0x7F) == 0 )
   \   0000003E   0x6922             LDR      R2,[R4, #+16]
   \   00000040   0x2B00             CMP      R3,#+0
   \   00000042   0xF884 0x037C      STRB     R0,[R4, #+892]
   \   00000046   0x6820             LDR      R0,[R4, #+0]
   \   00000048   0xB2D2             UXTB     R2,R2
   \   0000004A   0xD102             BNE.N    ??HAL_PCD_EP_Transmit_1
   1003            {
   1004              USB_EP0StartXfer(hpcd->Instance , ep, hpcd->Init.dma_enable);
   \   0000004C   0x.... 0x....      BL       USB_EP0StartXfer
   \   00000050   0xE001             B.N      ??HAL_PCD_EP_Transmit_2
   1005            }
   1006            else
   1007            {
   1008              USB_EPStartXfer(hpcd->Instance , ep, hpcd->Init.dma_enable);
   \                     ??HAL_PCD_EP_Transmit_1: (+1)
   \   00000052   0x.... 0x....      BL       USB_EPStartXfer
   1009            }
   1010            
   1011            __HAL_UNLOCK(hpcd);
   \                     ??HAL_PCD_EP_Transmit_2: (+1)
   \   00000056   0x2000             MOVS     R0,#+0
   \   00000058   0xF884 0x037C      STRB     R0,[R4, #+892]
   1012               
   1013            return HAL_OK;
   \                     ??HAL_PCD_EP_Transmit_0: (+1)
   \   0000005C   0xB001             ADD      SP,SP,#+4
   \   0000005E   0xBD30             POP      {R4,R5,PC}       ;; return
   1014          }
   1015          
   1016          /**
   1017            * @brief  Set a STALL condition over an endpoint.
   1018            * @param  hpcd: PCD handle
   1019            * @param  ep_addr: endpoint address
   1020            * @retval HAL status
   1021            */

   \                                 In section .text, align 2, keep-with-next
   1022          HAL_StatusTypeDef HAL_PCD_EP_SetStall(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)
   1023          {
   1024            USB_OTG_EPTypeDef *ep;
   1025            
   1026            if ((0x80 & ep_addr) == 0x80)
   \                     HAL_PCD_EP_SetStall: (+1)
   \   00000000   0x060A             LSLS     R2,R1,#+24
   \   00000002   0xB530             PUSH     {R4,R5,LR}
   \   00000004   0xB081             SUB      SP,SP,#+4
   \   00000006   0x4604             MOV      R4,R0
   \   00000008   0xD507             BPL.N    ??HAL_PCD_EP_SetStall_0
   1027            {
   1028              ep = &hpcd->IN_ep[ep_addr & 0x7F];
   \   0000000A   0xF001 0x007F      AND      R0,R1,#0x7F
   \   0000000E   0xEBC0 0x02C0      RSB      R2,R0,R0, LSL #+3
   \   00000012   0xEB04 0x0082      ADD      R0,R4,R2, LSL #+2
   \   00000016   0x3034             ADDS     R0,R0,#+52
   \   00000018   0xE005             B.N      ??HAL_PCD_EP_SetStall_1
   1029            }
   1030            else
   1031            {
   1032              ep = &hpcd->OUT_ep[ep_addr];
   \                     ??HAL_PCD_EP_SetStall_0: (+1)
   \   0000001A   0xEBC1 0x02C1      RSB      R2,R1,R1, LSL #+3
   \   0000001E   0xEB04 0x0082      ADD      R0,R4,R2, LSL #+2
   \   00000022   0xF500 0x70EC      ADD      R0,R0,#+472
   1033            }
   1034            
   1035            ep->is_stall = 1;
   \                     ??HAL_PCD_EP_SetStall_1: (+1)
   \   00000026   0x2201             MOVS     R2,#+1
   1036            ep->num   = ep_addr & 0x7F;
   \   00000028   0xF001 0x057F      AND      R5,R1,#0x7F
   \   0000002C   0x7082             STRB     R2,[R0, #+2]
   1037            ep->is_in = ((ep_addr & 0x80) == 0x80);
   \   0000002E   0x09C9             LSRS     R1,R1,#+7
   \   00000030   0x7005             STRB     R5,[R0, #+0]
   \   00000032   0x7041             STRB     R1,[R0, #+1]
   1038            
   1039            
   1040            __HAL_LOCK(hpcd); 
   \   00000034   0xF894 0x137C      LDRB     R1,[R4, #+892]
   \   00000038   0x2901             CMP      R1,#+1
   \   0000003A   0xBF08             IT       EQ 
   \   0000003C   0x2002             MOVEQ    R0,#+2
   \   0000003E   0xD010             BEQ.N    ??HAL_PCD_EP_SetStall_2
   \   00000040   0xF884 0x237C      STRB     R2,[R4, #+892]
   1041            USB_EPSetStall(hpcd->Instance , ep);
   \   00000044   0x4601             MOV      R1,R0
   \   00000046   0x6820             LDR      R0,[R4, #+0]
   \   00000048   0x.... 0x....      BL       USB_EPSetStall
   1042            if((ep_addr & 0x7F) == 0)
   \   0000004C   0xB935             CBNZ.N   R5,??HAL_PCD_EP_SetStall_3
   1043            {
   1044              USB_EP0_OutStart(hpcd->Instance, hpcd->Init.dma_enable, (uint8_t *)hpcd->Setup);
   \   0000004E   0x6921             LDR      R1,[R4, #+16]
   \   00000050   0x6820             LDR      R0,[R4, #+0]
   \   00000052   0xF504 0x7260      ADD      R2,R4,#+896
   \   00000056   0xB2C9             UXTB     R1,R1
   \   00000058   0x.... 0x....      BL       USB_EP0_OutStart
   1045            }
   1046            __HAL_UNLOCK(hpcd); 
   \                     ??HAL_PCD_EP_SetStall_3: (+1)
   \   0000005C   0x2000             MOVS     R0,#+0
   \   0000005E   0xF884 0x037C      STRB     R0,[R4, #+892]
   1047            
   1048            return HAL_OK;
   \                     ??HAL_PCD_EP_SetStall_2: (+1)
   \   00000062   0xB001             ADD      SP,SP,#+4
   \   00000064   0xBD30             POP      {R4,R5,PC}       ;; return
   1049          }
   1050          
   1051          /**
   1052            * @brief  Clear a STALL condition over in an endpoint.
   1053            * @param  hpcd: PCD handle
   1054            * @param  ep_addr: endpoint address
   1055            * @retval HAL status
   1056            */

   \                                 In section .text, align 2, keep-with-next
   1057          HAL_StatusTypeDef HAL_PCD_EP_ClrStall(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)
   1058          {
   1059            USB_OTG_EPTypeDef *ep;
   1060            
   1061            if ((0x80 & ep_addr) == 0x80)
   \                     HAL_PCD_EP_ClrStall: (+1)
   \   00000000   0x060A             LSLS     R2,R1,#+24
   \   00000002   0xB510             PUSH     {R4,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0xD507             BPL.N    ??HAL_PCD_EP_ClrStall_0
   1062            {
   1063              ep = &hpcd->IN_ep[ep_addr & 0x7F];
   \   00000008   0xF001 0x007F      AND      R0,R1,#0x7F
   \   0000000C   0xEBC0 0x02C0      RSB      R2,R0,R0, LSL #+3
   \   00000010   0xEB04 0x0082      ADD      R0,R4,R2, LSL #+2
   \   00000014   0x3034             ADDS     R0,R0,#+52
   \   00000016   0xE005             B.N      ??HAL_PCD_EP_ClrStall_1
   1064            }
   1065            else
   1066            {
   1067              ep = &hpcd->OUT_ep[ep_addr];
   \                     ??HAL_PCD_EP_ClrStall_0: (+1)
   \   00000018   0xEBC1 0x02C1      RSB      R2,R1,R1, LSL #+3
   \   0000001C   0xEB04 0x0082      ADD      R0,R4,R2, LSL #+2
   \   00000020   0xF500 0x70EC      ADD      R0,R0,#+472
   1068            }
   1069            
   1070            ep->is_stall = 0;
   \                     ??HAL_PCD_EP_ClrStall_1: (+1)
   \   00000024   0x2200             MOVS     R2,#+0
   \   00000026   0x7082             STRB     R2,[R0, #+2]
   1071            ep->num   = ep_addr & 0x7F;
   \   00000028   0xF001 0x027F      AND      R2,R1,#0x7F
   \   0000002C   0x7002             STRB     R2,[R0, #+0]
   1072            ep->is_in = ((ep_addr & 0x80) == 0x80);
   \   0000002E   0x09C9             LSRS     R1,R1,#+7
   \   00000030   0x7041             STRB     R1,[R0, #+1]
   1073            
   1074            __HAL_LOCK(hpcd); 
   \   00000032   0xF894 0x137C      LDRB     R1,[R4, #+892]
   \   00000036   0x2901             CMP      R1,#+1
   \   00000038   0xD101             BNE.N    ??HAL_PCD_EP_ClrStall_2
   \   0000003A   0x2002             MOVS     R0,#+2
   \   0000003C   0xBD10             POP      {R4,PC}
   \                     ??HAL_PCD_EP_ClrStall_2: (+1)
   \   0000003E   0x2101             MOVS     R1,#+1
   \   00000040   0xF884 0x137C      STRB     R1,[R4, #+892]
   1075            USB_EPClearStall(hpcd->Instance , ep);
   \   00000044   0x4601             MOV      R1,R0
   \   00000046   0x6820             LDR      R0,[R4, #+0]
   \   00000048   0x.... 0x....      BL       USB_EPClearStall
   1076            __HAL_UNLOCK(hpcd); 
   \   0000004C   0x2000             MOVS     R0,#+0
   \   0000004E   0xF884 0x037C      STRB     R0,[R4, #+892]
   1077              
   1078            return HAL_OK;
   \   00000052   0xBD10             POP      {R4,PC}          ;; return
   1079          }
   1080          
   1081          /**
   1082            * @brief  Flush an endpoint.
   1083            * @param  hpcd: PCD handle
   1084            * @param  ep_addr: endpoint address
   1085            * @retval HAL status
   1086            */

   \                                 In section .text, align 2, keep-with-next
   1087          HAL_StatusTypeDef HAL_PCD_EP_Flush(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)
   1088          {
   \                     HAL_PCD_EP_Flush: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   1089            __HAL_LOCK(hpcd); 
   \   00000004   0xF894 0x037C      LDRB     R0,[R4, #+892]
   \   00000008   0x2801             CMP      R0,#+1
   \   0000000A   0xD101             BNE.N    ??HAL_PCD_EP_Flush_0
   \   0000000C   0x2002             MOVS     R0,#+2
   \   0000000E   0xBD10             POP      {R4,PC}
   \                     ??HAL_PCD_EP_Flush_0: (+1)
   \   00000010   0x2001             MOVS     R0,#+1
   1090            
   1091            if ((ep_addr & 0x80) == 0x80)
   \   00000012   0x060A             LSLS     R2,R1,#+24
   \   00000014   0xF884 0x037C      STRB     R0,[R4, #+892]
   \   00000018   0x6820             LDR      R0,[R4, #+0]
   \   0000001A   0xD507             BPL.N    ??HAL_PCD_EP_Flush_1
   1092            {
   1093              USB_FlushTxFifo(hpcd->Instance, ep_addr & 0x7F);
   \   0000001C   0xF001 0x017F      AND      R1,R1,#0x7F
   \   00000020   0x.... 0x....      BL       USB_FlushTxFifo
   1094            }
   1095            else
   1096            {
   1097              USB_FlushRxFifo(hpcd->Instance);
   1098            }
   1099            
   1100            __HAL_UNLOCK(hpcd); 
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0xF884 0x037C      STRB     R0,[R4, #+892]
   1101              
   1102            return HAL_OK;
   \   0000002A   0xBD10             POP      {R4,PC}
   \                     ??HAL_PCD_EP_Flush_1: (+1)
   \   0000002C   0x.... 0x....      BL       USB_FlushRxFifo
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0xF884 0x037C      STRB     R0,[R4, #+892]
   \   00000036   0xBD10             POP      {R4,PC}          ;; return
   1103          }
   1104          
   1105          /**
   1106            * @brief  Activate remote wakeup signalling.
   1107            * @param  hpcd: PCD handle
   1108            * @retval HAL status
   1109            */

   \                                 In section .text, align 2, keep-with-next
   1110          HAL_StatusTypeDef HAL_PCD_ActivateRemoteWakeup(PCD_HandleTypeDef *hpcd)
   1111          {
   1112            USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;  
   \                     HAL_PCD_ActivateRemoteWakeup: (+1)
   \   00000000   0x6800             LDR      R0,[R0, #+0]
   1113              
   1114            if((USBx_DEVICE->DSTS & USB_OTG_DSTS_SUSPSTS) == USB_OTG_DSTS_SUSPSTS)
   \   00000002   0xF500 0x6000      ADD      R0,R0,#+2048
   \   00000006   0x6881             LDR      R1,[R0, #+8]
   \   00000008   0x07C9             LSLS     R1,R1,#+31
   \   0000000A   0xD503             BPL.N    ??HAL_PCD_ActivateRemoteWakeup_0
   1115            {
   1116              /* Activate Remote wakeup signaling */
   1117              USBx_DEVICE->DCTL |= USB_OTG_DCTL_RWUSIG;
   \   0000000C   0x6841             LDR      R1,[R0, #+4]
   \   0000000E   0xF041 0x0101      ORR      R1,R1,#0x1
   \   00000012   0x6041             STR      R1,[R0, #+4]
   1118            }
   1119            return HAL_OK;  
   \                     ??HAL_PCD_ActivateRemoteWakeup_0: (+1)
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0x4770             BX       LR               ;; return
   1120          }
   1121          
   1122          /**
   1123            * @brief  De-activate remote wakeup signalling.
   1124            * @param  hpcd: PCD handle
   1125            * @retval HAL status
   1126            */

   \                                 In section .text, align 2, keep-with-next
   1127          HAL_StatusTypeDef HAL_PCD_DeActivateRemoteWakeup(PCD_HandleTypeDef *hpcd)
   1128          {
   1129            USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;  
   \                     HAL_PCD_DeActivateRemoteWakeup: (+1)
   \   00000000   0x6800             LDR      R0,[R0, #+0]
   1130            
   1131            /* De-activate Remote wakeup signaling */
   1132             USBx_DEVICE->DCTL &= ~(USB_OTG_DCTL_RWUSIG);
   \   00000002   0xF500 0x6000      ADD      R0,R0,#+2048
   \   00000006   0x6841             LDR      R1,[R0, #+4]
   \   00000008   0x0849             LSRS     R1,R1,#+1
   \   0000000A   0x0049             LSLS     R1,R1,#+1
   \   0000000C   0x6041             STR      R1,[R0, #+4]
   1133            return HAL_OK;  
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0x4770             BX       LR               ;; return
   1134          }
   1135          /**
   1136            * @}
   1137            */
   1138            
   1139          /** @defgroup PCD_Exported_Functions_Group4 Peripheral State functions 
   1140           *  @brief   Peripheral State functions 
   1141           *
   1142          @verbatim   
   1143           ===============================================================================
   1144                                ##### Peripheral State functions #####
   1145           ===============================================================================  
   1146              [..]
   1147              This subsection permits to get in run-time the status of the peripheral 
   1148              and the data flow.
   1149          
   1150          @endverbatim
   1151            * @{
   1152            */
   1153          
   1154          /**
   1155            * @brief  Return the PCD handle state.
   1156            * @param  hpcd: PCD handle
   1157            * @retval HAL state
   1158            */

   \                                 In section .text, align 2, keep-with-next
   1159          PCD_StateTypeDef HAL_PCD_GetState(PCD_HandleTypeDef *hpcd)
   1160          {
   1161            return hpcd->State;
   \                     HAL_PCD_GetState: (+1)
   \   00000000   0xF890 0x037D      LDRB     R0,[R0, #+893]
   \   00000004   0x4770             BX       LR               ;; return
   1162          }
   1163          /**
   1164            * @}
   1165            */
   1166          
   1167          /**
   1168            * @}
   1169            */
   1170          
   1171          /* Private functions ---------------------------------------------------------*/
   1172          /** @addtogroup PCD_Private_Functions
   1173            * @{
   1174            */
   1175          
   1176          /**
   1177            * @brief  Check FIFO for the next packet to be loaded.
   1178            * @param  hpcd: PCD handle
   1179            * @param  epnum : endpoint number   
   1180            * @retval HAL status
   1181            */

   \                                 In section .text, align 2, keep-with-next
   1182          static HAL_StatusTypeDef PCD_WriteEmptyTxFifo(PCD_HandleTypeDef *hpcd, uint32_t epnum)
   1183          {
   \                     PCD_WriteEmptyTxFifo: (+1)
   \   00000000   0xE92D 0x4DF0      PUSH     {R4-R8,R10,R11,LR}
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x4680             MOV      R8,R0
   1184            USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;  
   1185            USB_OTG_EPTypeDef *ep;
   1186            int32_t len = 0;
   1187            uint32_t len32b;
   1188            uint32_t fifoemptymsk = 0;
   1189          
   1190            ep = &hpcd->IN_ep[epnum];
   \   00000008   0xEBC5 0x00C5      RSB      R0,R5,R5, LSL #+3
   \   0000000C   0xB082             SUB      SP,SP,#+8
   \   0000000E   0xF8D8 0xB000      LDR      R11,[R8, #+0]
   \   00000012   0xEB08 0x0080      ADD      R0,R8,R0, LSL #+2
   \   00000016   0xF100 0x0734      ADD      R7,R0,#+52
   1191            len = ep->xfer_len - ep->xfer_count;
   \   0000001A   0x6978             LDR      R0,[R7, #+20]
   \   0000001C   0x69B9             LDR      R1,[R7, #+24]
   \   0000001E   0x1A44             SUBS     R4,R0,R1
   1192            
   1193            if (len > ep->maxpacket)
   \   00000020   0x68B8             LDR      R0,[R7, #+8]
   \   00000022   0x42A0             CMP      R0,R4
   \   00000024   0xBF38             IT       CC 
   \   00000026   0x4604             MOVCC    R4,R0
   1194            {
   1195              len = ep->maxpacket;
   1196            }
   1197            
   1198            
   1199            len32b = (len + 3) / 4;
   \   00000028   0x1CE0             ADDS     R0,R4,#+3
   \   0000002A   0x1041             ASRS     R1,R0,#+1
   \   0000002C   0xEB00 0x7091      ADD      R0,R0,R1, LSR #+30
   \   00000030   0x1086             ASRS     R6,R0,#+2
   \   00000032   0xEB0B 0x1045      ADD      R0,R11,R5, LSL #+5
   \   00000036   0xF500 0x6A10      ADD      R10,R0,#+2304
   \   0000003A   0xE019             B.N      ??PCD_WriteEmptyTxFifo_0
   1200           
   1201            while  ( (USBx_INEP(epnum)->DTXFSTS & USB_OTG_DTXFSTS_INEPTFSAV) > len32b &&
   1202                    ep->xfer_count < ep->xfer_len &&
   1203                      ep->xfer_len != 0)
   1204            {
   1205              /* Write the FIFO */
   1206              len = ep->xfer_len - ep->xfer_count;
   \                     ??PCD_WriteEmptyTxFifo_1: (+1)
   \   0000003C   0x1A44             SUBS     R4,R0,R1
   1207              
   1208              if (len > ep->maxpacket)
   \   0000003E   0x68B8             LDR      R0,[R7, #+8]
   1209              {
   1210                len = ep->maxpacket;
   1211              }
   1212              len32b = (len + 3) / 4;
   1213              
   1214              USB_WritePacket(USBx, ep->xfer_buff, epnum, len, hpcd->Init.dma_enable); 
   \   00000040   0xB2EA             UXTB     R2,R5
   \   00000042   0x42A0             CMP      R0,R4
   \   00000044   0xBF38             IT       CC 
   \   00000046   0x4604             MOVCC    R4,R0
   \   00000048   0x1CE0             ADDS     R0,R4,#+3
   \   0000004A   0x1041             ASRS     R1,R0,#+1
   \   0000004C   0xEB00 0x7091      ADD      R0,R0,R1, LSR #+30
   \   00000050   0xB2A3             UXTH     R3,R4
   \   00000052   0x1086             ASRS     R6,R0,#+2
   \   00000054   0xF8D8 0x0010      LDR      R0,[R8, #+16]
   \   00000058   0xB2C0             UXTB     R0,R0
   \   0000005A   0x9000             STR      R0,[SP, #+0]
   \   0000005C   0x68F9             LDR      R1,[R7, #+12]
   \   0000005E   0x4658             MOV      R0,R11
   \   00000060   0x.... 0x....      BL       USB_WritePacket
   1215              
   1216              ep->xfer_buff  += len;
   \   00000064   0x68F8             LDR      R0,[R7, #+12]
   \   00000066   0x1820             ADDS     R0,R4,R0
   \   00000068   0x60F8             STR      R0,[R7, #+12]
   1217              ep->xfer_count += len;
   \   0000006A   0x69B8             LDR      R0,[R7, #+24]
   \   0000006C   0x1820             ADDS     R0,R4,R0
   \   0000006E   0x61B8             STR      R0,[R7, #+24]
   1218            }
   \                     ??PCD_WriteEmptyTxFifo_0: (+1)
   \   00000070   0xF8DA 0x0018      LDR      R0,[R10, #+24]
   \   00000074   0xB280             UXTH     R0,R0
   \   00000076   0x4286             CMP      R6,R0
   \   00000078   0xBF3E             ITTT     CC 
   \   0000007A   0x6978             LDRCC    R0,[R7, #+20]
   \   0000007C   0x69B9             LDRCC    R1,[R7, #+24]
   \   0000007E   0x4281             CMPCC    R1,R0
   \   00000080   0xD201             BCS.N    ??PCD_WriteEmptyTxFifo_2
   \   00000082   0x2800             CMP      R0,#+0
   \   00000084   0xD1DA             BNE.N    ??PCD_WriteEmptyTxFifo_1
   1219            
   1220            if(len <= 0)
   \                     ??PCD_WriteEmptyTxFifo_2: (+1)
   \   00000086   0x2C01             CMP      R4,#+1
   \   00000088   0xDA06             BGE.N    ??PCD_WriteEmptyTxFifo_3
   1221            {
   1222              fifoemptymsk = 0x1 << epnum;
   1223              USBx_DEVICE->DIEPEMPMSK &= ~fifoemptymsk;
   \   0000008A   0xF50B 0x6000      ADD      R0,R11,#+2048
   \   0000008E   0x2201             MOVS     R2,#+1
   \   00000090   0x40AA             LSLS     R2,R2,R5
   \   00000092   0x6B41             LDR      R1,[R0, #+52]
   \   00000094   0x4391             BICS     R1,R1,R2
   \   00000096   0x6341             STR      R1,[R0, #+52]
   1224              
   1225            }
   1226            
   1227            return HAL_OK;  
   \                     ??PCD_WriteEmptyTxFifo_3: (+1)
   \   00000098   0x2000             MOVS     R0,#+0
   \   0000009A   0xB002             ADD      SP,SP,#+8
   \   0000009C   0xE8BD 0x8DF0      POP      {R4-R8,R10,R11,PC}  ;; return
   1228          }
   1229          
   1230          /**
   1231            * @}
   1232            */
   1233          
   1234          #endif /* HAL_PCD_MODULE_ENABLED */
   1235          /**
   1236            * @}
   1237            */
   1238          
   1239          /**
   1240            * @}
   1241            */
   1242          
   1243          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   HAL_PCD_ActivateRemoteWakeup
       0   HAL_PCD_ConnectCallback
       0   HAL_PCD_DataInStageCallback
       0   HAL_PCD_DataOutStageCallback
       0   HAL_PCD_DeActivateRemoteWakeup
       8   HAL_PCD_DeInit
         8   -> HAL_PCD_MspDeInit
         8   -> USB_DevDisconnect
         8   -> USB_DisableGlobalInt
         8   -> USB_StopDevice
       8   HAL_PCD_DevConnect
         8   -> USB_DevConnect
       8   HAL_PCD_DevDisconnect
         8   -> USB_DevDisconnect
       0   HAL_PCD_DisconnectCallback
       8   HAL_PCD_EP_Close
         8   -> USB_DeactivateEndpoint
       8   HAL_PCD_EP_ClrStall
         8   -> USB_EPClearStall
       8   HAL_PCD_EP_Flush
         8   -> USB_FlushRxFifo
         8   -> USB_FlushTxFifo
       0   HAL_PCD_EP_GetRxCount
      16   HAL_PCD_EP_Open
        16   -> USB_ActivateEndpoint
      16   HAL_PCD_EP_Receive
        16   -> USB_EP0StartXfer
        16   -> USB_EPStartXfer
      16   HAL_PCD_EP_SetStall
        16   -> USB_EP0_OutStart
        16   -> USB_EPSetStall
      16   HAL_PCD_EP_Transmit
        16   -> USB_EP0StartXfer
        16   -> USB_EPStartXfer
       0   HAL_PCD_GetState
      40   HAL_PCD_IRQHandler
        40   -> HAL_PCDEx_LPM_Callback
        40   -> HAL_PCD_ConnectCallback
        40   -> HAL_PCD_DataInStageCallback
        40   -> HAL_PCD_DataOutStageCallback
        40   -> HAL_PCD_DisconnectCallback
        40   -> HAL_PCD_ISOINIncompleteCallback
        40   -> HAL_PCD_ISOOUTIncompleteCallback
        40   -> HAL_PCD_ResetCallback
        40   -> HAL_PCD_ResumeCallback
        40   -> HAL_PCD_SOFCallback
        40   -> HAL_PCD_SetupStageCallback
        40   -> HAL_PCD_SuspendCallback
        40   -> PCD_WriteEmptyTxFifo
        40   -> USB_ActivateSetup
        40   -> USB_EP0_OutStart
        40   -> USB_FlushTxFifo
        40   -> USB_GetDevSpeed
        40   -> USB_GetMode
        40   -> USB_ReadDevAllInEpInterrupt
        40   -> USB_ReadDevAllOutEpInterrupt
        40   -> USB_ReadDevInEPInterrupt
        40   -> USB_ReadDevOutEPInterrupt
        40   -> USB_ReadInterrupts
        40   -> USB_ReadPacket
       0   HAL_PCD_ISOINIncompleteCallback
       0   HAL_PCD_ISOOUTIncompleteCallback
      60   HAL_PCD_Init
        48   -> HAL_PCDEx_ActivateLPM
        48   -> HAL_PCD_MspInit
        48   -> USB_CoreInit
        48   -> USB_DevDisconnect
        48   -> USB_DevInit
        48   -> USB_DisableGlobalInt
        48   -> USB_SetCurrentMode
        60   -> __aeabi_memcpy4
       0   HAL_PCD_MspDeInit
       0   HAL_PCD_MspInit
       0   HAL_PCD_ResetCallback
       0   HAL_PCD_ResumeCallback
       0   HAL_PCD_SOFCallback
       8   HAL_PCD_SetAddress
         8   -> USB_SetDevAddress
       0   HAL_PCD_SetupStageCallback
       8   HAL_PCD_Start
         8   -> USB_DevConnect
         8   -> USB_EnableGlobalInt
       8   HAL_PCD_Stop
         8   -> USB_DevDisconnect
         8   -> USB_DisableGlobalInt
         8   -> USB_StopDevice
       0   HAL_PCD_SuspendCallback
      40   PCD_WriteEmptyTxFifo
        40   -> USB_WritePacket


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      24  HAL_PCD_ActivateRemoteWakeup
       2  HAL_PCD_ConnectCallback
       2  HAL_PCD_DataInStageCallback
       2  HAL_PCD_DataOutStageCallback
      18  HAL_PCD_DeActivateRemoteWakeup
      68  HAL_PCD_DeInit
      36  HAL_PCD_DevConnect
      36  HAL_PCD_DevDisconnect
       2  HAL_PCD_DisconnectCallback
      70  HAL_PCD_EP_Close
      84  HAL_PCD_EP_ClrStall
      56  HAL_PCD_EP_Flush
      20  HAL_PCD_EP_GetRxCount
      94  HAL_PCD_EP_Open
      96  HAL_PCD_EP_Receive
     102  HAL_PCD_EP_SetStall
      96  HAL_PCD_EP_Transmit
       6  HAL_PCD_GetState
    1088  HAL_PCD_IRQHandler
       2  HAL_PCD_ISOINIncompleteCallback
       2  HAL_PCD_ISOOUTIncompleteCallback
     190  HAL_PCD_Init
       2  HAL_PCD_MspDeInit
       2  HAL_PCD_MspInit
       2  HAL_PCD_ResetCallback
       2  HAL_PCD_ResumeCallback
       2  HAL_PCD_SOFCallback
      36  HAL_PCD_SetAddress
       2  HAL_PCD_SetupStageCallback
      42  HAL_PCD_Start
      48  HAL_PCD_Stop
       2  HAL_PCD_SuspendCallback
     160  PCD_WriteEmptyTxFifo

 
 2 396 bytes in section .text
 
 2 396 bytes of CODE memory

Errors: none
Warnings: none
