###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.2.10312/W32 for ARM       28/Feb/2016  13:28:41
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_pcd.c
#    Command line =  
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_pcd.c
#        -D USE_HAL_DRIVER -D STM32F746xx -D USE_STM32746G_DISCO -D
#        USE_IOEXPANDER -D USE_USB_FS -lC
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
#        -lA
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
#        -o
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M7 -e --fpu=VFPv5_sp --dlib_config "D:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.3\arm\INC\c\DLib_Config_Full.h"
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\Inc\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\CMSIS\Device\ST\STM32F7xx\Include\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\STM32F7xx_HAL_Driver\Inc\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\STM32746G-Discovery\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\Components\Common\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Log\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Fonts\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\CPU\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_Device_Library\Core\Inc\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Core\Inc\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Class\MSC\Inc\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\drivers\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_Audio\Addons\PDM\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_Device_Library\Class\AUDIO\Inc\
#        -On --use_c++_inline --require_prototypes -I "D:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.3\arm\CMSIS\Include\" -D
#        ARM_MATH_CM7
#    List file    =  
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List\stm32f7xx_hal_pcd.lst
#    Object file  =  
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj\stm32f7xx_hal_pcd.o
#
###############################################################################

H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_pcd.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f7xx_hal_pcd.c
      4            * @author  MCD Application Team
      5            * @version V1.0.1
      6            * @date    25-June-2015
      7            * @brief   PCD HAL module driver.
      8            *          This file provides firmware functions to manage the following 
      9            *          functionalities of the USB Peripheral Controller:
     10            *           + Initialization and de-initialization functions
     11            *           + IO operation functions
     12            *           + Peripheral Control functions 
     13            *           + Peripheral State functions
     14            *         
     15            @verbatim
     16            ==============================================================================
     17                              ##### How to use this driver #####
     18            ==============================================================================
     19              [..]
     20                The PCD HAL driver can be used as follows:
     21          
     22               (#) Declare a PCD_HandleTypeDef handle structure, for example:
     23                   PCD_HandleTypeDef  hpcd;
     24                  
     25               (#) Fill parameters of Init structure in HCD handle
     26            
     27               (#) Call HAL_PCD_Init() API to initialize the HCD peripheral (Core, Device core, ...) 
     28          
     29               (#) Initialize the PCD low level resources through the HAL_PCD_MspInit() API:
     30                   (##) Enable the PCD/USB Low Level interface clock using 
     31                        (+++) __OTGFS-OTG_CLK_ENABLE()/__OTGHS-OTG_CLK_ENABLE();
     32                        (+++) __OTGHSULPI_CLK_ENABLE(); (For High Speed Mode)
     33                     
     34                   (##) Initialize the related GPIO clocks
     35                   (##) Configure PCD pin-out
     36                   (##) Configure PCD NVIC interrupt
     37              
     38               (#)Associate the Upper USB device stack to the HAL PCD Driver:
     39                   (##) hpcd.pData = pdev;
     40          
     41               (#)Enable HCD transmission and reception:
     42                   (##) HAL_PCD_Start();
     43          
     44            @endverbatim
     45            ******************************************************************************
     46            * @attention
     47            *
     48            * <h2><center>&copy; COPYRIGHT(c) 2015 STMicroelectronics</center></h2>
     49            *
     50            * Redistribution and use in source and binary forms, with or without modification,
     51            * are permitted provided that the following conditions are met:
     52            *   1. Redistributions of source code must retain the above copyright notice,
     53            *      this list of conditions and the following disclaimer.
     54            *   2. Redistributions in binary form must reproduce the above copyright notice,
     55            *      this list of conditions and the following disclaimer in the documentation
     56            *      and/or other materials provided with the distribution.
     57            *   3. Neither the name of STMicroelectronics nor the names of its contributors
     58            *      may be used to endorse or promote products derived from this software
     59            *      without specific prior written permission.
     60            *
     61            * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
     62            * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     63            * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     64            * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
     65            * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
     66            * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
     67            * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
     68            * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
     69            * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
     70            * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     71            *
     72            ******************************************************************************
     73            */ 
     74          
     75          /* Includes ------------------------------------------------------------------*/
     76          #include "stm32f7xx_hal.h"
     77          
     78          /** @addtogroup STM32F7xx_HAL_Driver
     79            * @{
     80            */
     81          
     82          /** @defgroup PCD PCD
     83            * @brief PCD HAL module driver
     84            * @{
     85            */
     86          
     87          #ifdef HAL_PCD_MODULE_ENABLED
     88          
     89          /* Private types -------------------------------------------------------------*/
     90          /* Private variables ---------------------------------------------------------*/
     91          /* Private constants ---------------------------------------------------------*/
     92          /* Private macros ------------------------------------------------------------*/
     93          /** @defgroup PCD_Private_Macros PCD Private Macros
     94            * @{
     95            */ 
     96          #define PCD_MIN(a, b)  (((a) < (b)) ? (a) : (b))
     97          #define PCD_MAX(a, b)  (((a) > (b)) ? (a) : (b))
     98          /**
     99            * @}
    100            */
    101          
    102          /* Private functions prototypes ----------------------------------------------*/
    103          /** @defgroup PCD_Private_Functions PCD Private Functions
    104            * @{
    105            */
    106          static HAL_StatusTypeDef PCD_WriteEmptyTxFifo(PCD_HandleTypeDef *hpcd, uint32_t epnum);
    107          /**
    108            * @}
    109            */
    110          
    111          /* Exported functions --------------------------------------------------------*/
    112          /** @defgroup PCD_Exported_Functions PCD Exported Functions
    113            * @{
    114            */
    115          
    116          /** @defgroup PCD_Exported_Functions_Group1 Initialization and de-initialization functions 
    117           *  @brief    Initialization and Configuration functions 
    118           *
    119          @verbatim    
    120           ===============================================================================
    121                      ##### Initialization and de-initialization functions #####
    122           ===============================================================================
    123              [..]  This section provides functions allowing to:
    124           
    125          @endverbatim
    126            * @{
    127            */
    128          
    129          /**
    130            * @brief  Initializes the PCD according to the specified
    131            *         parameters in the PCD_InitTypeDef and create the associated handle.
    132            * @param  hpcd: PCD handle
    133            * @retval HAL status
    134            */

   \                                 In section .text, align 2, keep-with-next
    135          HAL_StatusTypeDef HAL_PCD_Init(PCD_HandleTypeDef *hpcd)
    136          { 
   \                     HAL_PCD_Init: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB089             SUB      SP,SP,#+36
   \   00000004   0x0005             MOVS     R5,R0
    137            uint32_t i = 0;
   \   00000006   0x2400             MOVS     R4,#+0
    138            
    139            /* Check the PCD handle allocation */
    140            if(hpcd == NULL)
   \   00000008   0x2D00             CMP      R5,#+0
   \   0000000A   0xD101             BNE.N    ??HAL_PCD_Init_0
    141            {
    142              return HAL_ERROR;
   \   0000000C   0x2001             MOVS     R0,#+1
   \   0000000E   0xE08A             B.N      ??HAL_PCD_Init_1
    143            }
    144            
    145            /* Check the parameters */
    146            assert_param(IS_PCD_ALL_INSTANCE(hpcd->Instance));
    147          
    148            hpcd->State = HAL_PCD_STATE_BUSY;
   \                     ??HAL_PCD_Init_0: (+1)
   \   00000010   0x2003             MOVS     R0,#+3
   \   00000012   0xF885 0x037D      STRB     R0,[R5, #+893]
    149            
    150            /* Init the low level hardware : GPIO, CLOCK, NVIC... */
    151            HAL_PCD_MspInit(hpcd);
   \   00000016   0x0028             MOVS     R0,R5
   \   00000018   0x.... 0x....      BL       HAL_PCD_MspInit
    152          
    153            /* Disable the Interrupts */
    154           __HAL_PCD_DISABLE(hpcd);
   \   0000001C   0x6828             LDR      R0,[R5, #+0]
   \   0000001E   0x.... 0x....      BL       USB_DisableGlobalInt
    155           
    156           /*Init the Core (common init.) */
    157           USB_CoreInit(hpcd->Instance, hpcd->Init);
   \   00000022   0x1D29             ADDS     R1,R5,#+4
   \   00000024   0xB083             SUB      SP,SP,#+12
   \   00000026   0x4668             MOV      R0,SP
   \   00000028   0x2230             MOVS     R2,#+48
   \   0000002A   0x.... 0x....      BL       __aeabi_memcpy4
   \   0000002E   0xBC0E             POP      {R1-R3}
   \   00000030   0x6828             LDR      R0,[R5, #+0]
   \   00000032   0x.... 0x....      BL       USB_CoreInit
    158           
    159           /* Force Device Mode*/
    160           USB_SetCurrentMode(hpcd->Instance , USB_OTG_DEVICE_MODE);
   \   00000036   0x2100             MOVS     R1,#+0
   \   00000038   0x6828             LDR      R0,[R5, #+0]
   \   0000003A   0x.... 0x....      BL       USB_SetCurrentMode
    161           
    162           /* Init endpoints structures */
    163           for (i = 0; i < 15 ; i++)
   \   0000003E   0x2000             MOVS     R0,#+0
   \   00000040   0x0004             MOVS     R4,R0
   \                     ??HAL_PCD_Init_2: (+1)
   \   00000042   0x2C0F             CMP      R4,#+15
   \   00000044   0xD225             BCS.N    ??HAL_PCD_Init_3
    164           {
    165             /* Init ep structure */
    166             hpcd->IN_ep[i].is_in = 1;
   \   00000046   0x2001             MOVS     R0,#+1
   \   00000048   0x211C             MOVS     R1,#+28
   \   0000004A   0xFB01 0x5104      MLA      R1,R1,R4,R5
   \   0000004E   0xF881 0x0035      STRB     R0,[R1, #+53]
    167             hpcd->IN_ep[i].num = i;
   \   00000052   0x201C             MOVS     R0,#+28
   \   00000054   0xFB00 0x5004      MLA      R0,R0,R4,R5
   \   00000058   0xF880 0x4034      STRB     R4,[R0, #+52]
    168             hpcd->IN_ep[i].tx_fifo_num = i;
   \   0000005C   0x201C             MOVS     R0,#+28
   \   0000005E   0xFB00 0x5004      MLA      R0,R0,R4,R5
   \   00000062   0x8744             STRH     R4,[R0, #+58]
    169             /* Control until ep is activated */
    170             hpcd->IN_ep[i].type = EP_TYPE_CTRL;
   \   00000064   0x2000             MOVS     R0,#+0
   \   00000066   0x211C             MOVS     R1,#+28
   \   00000068   0xFB01 0x5104      MLA      R1,R1,R4,R5
   \   0000006C   0xF881 0x0037      STRB     R0,[R1, #+55]
    171             hpcd->IN_ep[i].maxpacket =  0;
   \   00000070   0x2000             MOVS     R0,#+0
   \   00000072   0x211C             MOVS     R1,#+28
   \   00000074   0xFB01 0x5104      MLA      R1,R1,R4,R5
   \   00000078   0x63C8             STR      R0,[R1, #+60]
    172             hpcd->IN_ep[i].xfer_buff = 0;
   \   0000007A   0x2000             MOVS     R0,#+0
   \   0000007C   0x211C             MOVS     R1,#+28
   \   0000007E   0xFB01 0x5104      MLA      R1,R1,R4,R5
   \   00000082   0x6408             STR      R0,[R1, #+64]
    173             hpcd->IN_ep[i].xfer_len = 0;
   \   00000084   0x2000             MOVS     R0,#+0
   \   00000086   0x211C             MOVS     R1,#+28
   \   00000088   0xFB01 0x5104      MLA      R1,R1,R4,R5
   \   0000008C   0x6488             STR      R0,[R1, #+72]
    174           }
   \   0000008E   0x1C64             ADDS     R4,R4,#+1
   \   00000090   0xE7D7             B.N      ??HAL_PCD_Init_2
    175           
    176           for (i = 0; i < 15 ; i++)
   \                     ??HAL_PCD_Init_3: (+1)
   \   00000092   0x2000             MOVS     R0,#+0
   \   00000094   0x0004             MOVS     R4,R0
   \                     ??HAL_PCD_Init_4: (+1)
   \   00000096   0x2C0F             CMP      R4,#+15
   \   00000098   0xD22E             BCS.N    ??HAL_PCD_Init_5
    177           {
    178             hpcd->OUT_ep[i].is_in = 0;
   \   0000009A   0x2000             MOVS     R0,#+0
   \   0000009C   0x211C             MOVS     R1,#+28
   \   0000009E   0xFB01 0x5104      MLA      R1,R1,R4,R5
   \   000000A2   0xF881 0x01D9      STRB     R0,[R1, #+473]
    179             hpcd->OUT_ep[i].num = i;
   \   000000A6   0x201C             MOVS     R0,#+28
   \   000000A8   0xFB00 0x5004      MLA      R0,R0,R4,R5
   \   000000AC   0xF880 0x41D8      STRB     R4,[R0, #+472]
    180             hpcd->IN_ep[i].tx_fifo_num = i;
   \   000000B0   0x201C             MOVS     R0,#+28
   \   000000B2   0xFB00 0x5004      MLA      R0,R0,R4,R5
   \   000000B6   0x8744             STRH     R4,[R0, #+58]
    181             /* Control until ep is activated */
    182             hpcd->OUT_ep[i].type = EP_TYPE_CTRL;
   \   000000B8   0x2000             MOVS     R0,#+0
   \   000000BA   0x211C             MOVS     R1,#+28
   \   000000BC   0xFB01 0x5104      MLA      R1,R1,R4,R5
   \   000000C0   0xF881 0x01DB      STRB     R0,[R1, #+475]
    183             hpcd->OUT_ep[i].maxpacket = 0;
   \   000000C4   0x2000             MOVS     R0,#+0
   \   000000C6   0x211C             MOVS     R1,#+28
   \   000000C8   0xFB01 0x5104      MLA      R1,R1,R4,R5
   \   000000CC   0xF8C1 0x01E0      STR      R0,[R1, #+480]
    184             hpcd->OUT_ep[i].xfer_buff = 0;
   \   000000D0   0x2000             MOVS     R0,#+0
   \   000000D2   0x211C             MOVS     R1,#+28
   \   000000D4   0xFB01 0x5104      MLA      R1,R1,R4,R5
   \   000000D8   0xF8C1 0x01E4      STR      R0,[R1, #+484]
    185             hpcd->OUT_ep[i].xfer_len = 0;
   \   000000DC   0x2000             MOVS     R0,#+0
   \   000000DE   0x211C             MOVS     R1,#+28
   \   000000E0   0xFB01 0x5104      MLA      R1,R1,R4,R5
   \   000000E4   0xF8C1 0x01EC      STR      R0,[R1, #+492]
    186             
    187             hpcd->Instance->DIEPTXF[i] = 0;
   \   000000E8   0x2000             MOVS     R0,#+0
   \   000000EA   0x6829             LDR      R1,[R5, #+0]
   \   000000EC   0xEB11 0x0184      ADDS     R1,R1,R4, LSL #+2
   \   000000F0   0xF8C1 0x0104      STR      R0,[R1, #+260]
    188           }
   \   000000F4   0x1C64             ADDS     R4,R4,#+1
   \   000000F6   0xE7CE             B.N      ??HAL_PCD_Init_4
    189           
    190           /* Init Device */
    191           USB_DevInit(hpcd->Instance, hpcd->Init);
   \                     ??HAL_PCD_Init_5: (+1)
   \   000000F8   0x1D29             ADDS     R1,R5,#+4
   \   000000FA   0xB083             SUB      SP,SP,#+12
   \   000000FC   0x4668             MOV      R0,SP
   \   000000FE   0x2230             MOVS     R2,#+48
   \   00000100   0x.... 0x....      BL       __aeabi_memcpy4
   \   00000104   0xBC0E             POP      {R1-R3}
   \   00000106   0x6828             LDR      R0,[R5, #+0]
   \   00000108   0x.... 0x....      BL       USB_DevInit
    192           
    193           hpcd->State= HAL_PCD_STATE_READY;
   \   0000010C   0x2001             MOVS     R0,#+1
   \   0000010E   0xF885 0x037D      STRB     R0,[R5, #+893]
    194           
    195           /* Activate LPM */
    196           if (hpcd->Init.lpm_enable == 1)
   \   00000112   0x6A68             LDR      R0,[R5, #+36]
   \   00000114   0x2801             CMP      R0,#+1
   \   00000116   0xD102             BNE.N    ??HAL_PCD_Init_6
    197           {
    198             HAL_PCDEx_ActivateLPM(hpcd);
   \   00000118   0x0028             MOVS     R0,R5
   \   0000011A   0x.... 0x....      BL       HAL_PCDEx_ActivateLPM
    199           }
    200           
    201           USB_DevDisconnect (hpcd->Instance);  
   \                     ??HAL_PCD_Init_6: (+1)
   \   0000011E   0x6828             LDR      R0,[R5, #+0]
   \   00000120   0x.... 0x....      BL       USB_DevDisconnect
    202           return HAL_OK;
   \   00000124   0x2000             MOVS     R0,#+0
   \                     ??HAL_PCD_Init_1: (+1)
   \   00000126   0xB009             ADD      SP,SP,#+36
   \   00000128   0xBD30             POP      {R4,R5,PC}       ;; return
    203          }
    204          
    205          /**
    206            * @brief  DeInitializes the PCD peripheral 
    207            * @param  hpcd: PCD handle
    208            * @retval HAL status
    209            */

   \                                 In section .text, align 2, keep-with-next
    210          HAL_StatusTypeDef HAL_PCD_DeInit(PCD_HandleTypeDef *hpcd)
    211          {
   \                     HAL_PCD_DeInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    212            /* Check the PCD handle allocation */
    213            if(hpcd == NULL)
   \   00000004   0x2C00             CMP      R4,#+0
   \   00000006   0xD101             BNE.N    ??HAL_PCD_DeInit_0
    214            {
    215              return HAL_ERROR;
   \   00000008   0x2001             MOVS     R0,#+1
   \   0000000A   0xE00C             B.N      ??HAL_PCD_DeInit_1
    216            }
    217          
    218            hpcd->State = HAL_PCD_STATE_BUSY;
   \                     ??HAL_PCD_DeInit_0: (+1)
   \   0000000C   0x2003             MOVS     R0,#+3
   \   0000000E   0xF884 0x037D      STRB     R0,[R4, #+893]
    219            
    220            /* Stop Device */
    221            HAL_PCD_Stop(hpcd);
   \   00000012   0x0020             MOVS     R0,R4
   \   00000014   0x.... 0x....      BL       HAL_PCD_Stop
    222              
    223            /* DeInit the low level hardware */
    224            HAL_PCD_MspDeInit(hpcd);
   \   00000018   0x0020             MOVS     R0,R4
   \   0000001A   0x.... 0x....      BL       HAL_PCD_MspDeInit
    225            
    226            hpcd->State = HAL_PCD_STATE_RESET; 
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0xF884 0x037D      STRB     R0,[R4, #+893]
    227            
    228            return HAL_OK;
   \   00000024   0x2000             MOVS     R0,#+0
   \                     ??HAL_PCD_DeInit_1: (+1)
   \   00000026   0xBD10             POP      {R4,PC}          ;; return
    229          }
    230          
    231          /**
    232            * @brief  Initializes the PCD MSP.
    233            * @param  hpcd: PCD handle
    234            * @retval None
    235            */

   \                                 In section .text, align 2, keep-with-next
    236          __weak void HAL_PCD_MspInit(PCD_HandleTypeDef *hpcd)
    237          {
    238            /* NOTE : This function Should not be modified, when the callback is needed,
    239                      the HAL_PCD_MspInit could be implemented in the user file
    240             */
    241          }
   \                     HAL_PCD_MspInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    242          
    243          /**
    244            * @brief  DeInitializes PCD MSP.
    245            * @param  hpcd: PCD handle
    246            * @retval None
    247            */

   \                                 In section .text, align 2, keep-with-next
    248          __weak void HAL_PCD_MspDeInit(PCD_HandleTypeDef *hpcd)
    249          {
    250            /* NOTE : This function Should not be modified, when the callback is needed,
    251                      the HAL_PCD_MspDeInit could be implemented in the user file
    252             */
    253          }
   \                     HAL_PCD_MspDeInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    254          
    255          /**
    256            * @}
    257            */
    258          
    259          /** @defgroup PCD_Exported_Functions_Group2 IO operation functions 
    260           *  @brief   Data transfers functions 
    261           *
    262          @verbatim   
    263           ===============================================================================
    264                                ##### IO operation functions #####
    265           ===============================================================================  
    266              [..]
    267              This subsection provides a set of functions allowing to manage the PCD data 
    268              transfers.
    269          
    270          @endverbatim
    271            * @{
    272            */
    273            
    274          /**
    275            * @brief  Start The USB OTG Device.
    276            * @param  hpcd: PCD handle
    277            * @retval HAL status
    278            */

   \                                 In section .text, align 2, keep-with-next
    279          HAL_StatusTypeDef HAL_PCD_Start(PCD_HandleTypeDef *hpcd)
    280          { 
   \                     HAL_PCD_Start: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    281            __HAL_LOCK(hpcd); 
   \   00000004   0xF894 0x037C      LDRB     R0,[R4, #+892]
   \   00000008   0x2801             CMP      R0,#+1
   \   0000000A   0xD101             BNE.N    ??HAL_PCD_Start_0
   \   0000000C   0x2002             MOVS     R0,#+2
   \   0000000E   0xE00C             B.N      ??HAL_PCD_Start_1
   \                     ??HAL_PCD_Start_0: (+1)
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0xF884 0x037C      STRB     R0,[R4, #+892]
    282            USB_DevConnect (hpcd->Instance);  
   \   00000016   0x6820             LDR      R0,[R4, #+0]
   \   00000018   0x.... 0x....      BL       USB_DevConnect
    283            __HAL_PCD_ENABLE(hpcd);
   \   0000001C   0x6820             LDR      R0,[R4, #+0]
   \   0000001E   0x.... 0x....      BL       USB_EnableGlobalInt
    284            __HAL_UNLOCK(hpcd); 
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0xF884 0x037C      STRB     R0,[R4, #+892]
    285            return HAL_OK;
   \   00000028   0x2000             MOVS     R0,#+0
   \                     ??HAL_PCD_Start_1: (+1)
   \   0000002A   0xBD10             POP      {R4,PC}          ;; return
    286          }
    287          
    288          /**
    289            * @brief  Stop The USB OTG Device.
    290            * @param  hpcd: PCD handle
    291            * @retval HAL status
    292            */

   \                                 In section .text, align 2, keep-with-next
    293          HAL_StatusTypeDef HAL_PCD_Stop(PCD_HandleTypeDef *hpcd)
    294          { 
   \                     HAL_PCD_Stop: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    295            __HAL_LOCK(hpcd); 
   \   00000004   0xF894 0x037C      LDRB     R0,[R4, #+892]
   \   00000008   0x2801             CMP      R0,#+1
   \   0000000A   0xD101             BNE.N    ??HAL_PCD_Stop_0
   \   0000000C   0x2002             MOVS     R0,#+2
   \   0000000E   0xE00F             B.N      ??HAL_PCD_Stop_1
   \                     ??HAL_PCD_Stop_0: (+1)
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0xF884 0x037C      STRB     R0,[R4, #+892]
    296            __HAL_PCD_DISABLE(hpcd);
   \   00000016   0x6820             LDR      R0,[R4, #+0]
   \   00000018   0x.... 0x....      BL       USB_DisableGlobalInt
    297            USB_StopDevice(hpcd->Instance);
   \   0000001C   0x6820             LDR      R0,[R4, #+0]
   \   0000001E   0x.... 0x....      BL       USB_StopDevice
    298            USB_DevDisconnect (hpcd->Instance);
   \   00000022   0x6820             LDR      R0,[R4, #+0]
   \   00000024   0x.... 0x....      BL       USB_DevDisconnect
    299            __HAL_UNLOCK(hpcd); 
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0xF884 0x037C      STRB     R0,[R4, #+892]
    300            return HAL_OK;
   \   0000002E   0x2000             MOVS     R0,#+0
   \                     ??HAL_PCD_Stop_1: (+1)
   \   00000030   0xBD10             POP      {R4,PC}          ;; return
    301          }
    302          
    303          /**
    304            * @brief  This function handles PCD interrupt request.
    305            * @param  hpcd: PCD handle
    306            * @retval HAL status
    307            */

   \                                 In section .text, align 2, keep-with-next
    308          void HAL_PCD_IRQHandler(PCD_HandleTypeDef *hpcd)
    309          {
   \                     HAL_PCD_IRQHandler: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x0004             MOVS     R4,R0
    310            USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
   \   00000006   0x6825             LDR      R5,[R4, #+0]
    311            uint32_t i = 0, ep_intr = 0, epint = 0, epnum = 0;
   \   00000008   0xF05F 0x0B00      MOVS     R11,#+0
   \   0000000C   0xF05F 0x0A00      MOVS     R10,#+0
   \   00000010   0x2600             MOVS     R6,#+0
   \   00000012   0xF05F 0x0900      MOVS     R9,#+0
    312            uint32_t fifoemptymsk = 0, temp = 0;
   \   00000016   0x2700             MOVS     R7,#+0
   \   00000018   0xF05F 0x0800      MOVS     R8,#+0
    313            USB_OTG_EPTypeDef *ep;
    314              
    315            /* ensure that we are in device mode */
    316            if (USB_GetMode(hpcd->Instance) == USB_OTG_MODE_DEVICE)
   \   0000001C   0x6820             LDR      R0,[R4, #+0]
   \   0000001E   0x.... 0x....      BL       USB_GetMode
   \   00000022   0x2800             CMP      R0,#+0
   \   00000024   0xF040 0x827B      BNE.W    ??HAL_PCD_IRQHandler_0
    317            {
    318              /* avoid spurious interrupt */
    319              if(__HAL_PCD_IS_INVALID_INTERRUPT(hpcd)) 
   \   00000028   0x6820             LDR      R0,[R4, #+0]
   \   0000002A   0x.... 0x....      BL       USB_ReadInterrupts
   \   0000002E   0x2800             CMP      R0,#+0
   \   00000030   0xF000 0x8275      BEQ.W    ??HAL_PCD_IRQHandler_1
    320              {
    321                return;
    322              }
    323              
    324              if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_MMIS))
   \                     ??HAL_PCD_IRQHandler_2: (+1)
   \   00000034   0x6820             LDR      R0,[R4, #+0]
   \   00000036   0x.... 0x....      BL       USB_ReadInterrupts
   \   0000003A   0x0780             LSLS     R0,R0,#+30
   \   0000003C   0xD502             BPL.N    ??HAL_PCD_IRQHandler_3
    325              {
    326               /* incorrect mode, acknowledge the interrupt */
    327                __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_MMIS);
   \   0000003E   0x2002             MOVS     R0,#+2
   \   00000040   0x6821             LDR      R1,[R4, #+0]
   \   00000042   0x6148             STR      R0,[R1, #+20]
    328              }
    329              
    330              if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_OEPINT))
   \                     ??HAL_PCD_IRQHandler_3: (+1)
   \   00000044   0x6820             LDR      R0,[R4, #+0]
   \   00000046   0x.... 0x....      BL       USB_ReadInterrupts
   \   0000004A   0x0300             LSLS     R0,R0,#+12
   \   0000004C   0xD56E             BPL.N    ??HAL_PCD_IRQHandler_4
    331              {
    332                epnum = 0;
   \   0000004E   0x2000             MOVS     R0,#+0
   \   00000050   0x4681             MOV      R9,R0
    333                
    334                /* Read in the device interrupt bits */
    335                ep_intr = USB_ReadDevAllOutEpInterrupt(hpcd->Instance);
   \   00000052   0x6820             LDR      R0,[R4, #+0]
   \   00000054   0x.... 0x....      BL       USB_ReadDevAllOutEpInterrupt
   \   00000058   0x4682             MOV      R10,R0
    336                
    337                while ( ep_intr )
   \                     ??HAL_PCD_IRQHandler_5: (+1)
   \   0000005A   0xF1BA 0x0F00      CMP      R10,#+0
   \   0000005E   0xD065             BEQ.N    ??HAL_PCD_IRQHandler_4
    338                {
    339                  if (ep_intr & 0x1)
   \   00000060   0xEA5F 0x70CA      LSLS     R0,R10,#+31
   \   00000064   0xD55D             BPL.N    ??HAL_PCD_IRQHandler_6
    340                  {
    341                    epint = USB_ReadDevOutEPInterrupt(hpcd->Instance, epnum);
   \   00000066   0x4649             MOV      R1,R9
   \   00000068   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000006A   0x6820             LDR      R0,[R4, #+0]
   \   0000006C   0x.... 0x....      BL       USB_ReadDevOutEPInterrupt
   \   00000070   0x0006             MOVS     R6,R0
    342                    
    343                    if(( epint & USB_OTG_DOEPINT_XFRC) == USB_OTG_DOEPINT_XFRC)
   \   00000072   0x07F0             LSLS     R0,R6,#+31
   \   00000074   0xD542             BPL.N    ??HAL_PCD_IRQHandler_7
    344                    {
    345                      CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_XFRC);
   \   00000076   0xEB15 0x1049      ADDS     R0,R5,R9, LSL #+5
   \   0000007A   0xF510 0x6030      ADDS     R0,R0,#+2816
   \   0000007E   0x2101             MOVS     R1,#+1
   \   00000080   0x6081             STR      R1,[R0, #+8]
    346                      
    347                      if(hpcd->Init.dma_enable == 1)
   \   00000082   0x6920             LDR      R0,[R4, #+16]
   \   00000084   0x2801             CMP      R0,#+1
   \   00000086   0xD121             BNE.N    ??HAL_PCD_IRQHandler_8
    348                      {
    349                        hpcd->OUT_ep[epnum].xfer_count = hpcd->OUT_ep[epnum].maxpacket- (USBx_OUTEP(epnum)->DOEPTSIZ & USB_OTG_DOEPTSIZ_XFRSIZ); 
   \   00000088   0x201C             MOVS     R0,#+28
   \   0000008A   0xFB00 0x4009      MLA      R0,R0,R9,R4
   \   0000008E   0xF8D0 0x01E0      LDR      R0,[R0, #+480]
   \   00000092   0xEB15 0x1149      ADDS     R1,R5,R9, LSL #+5
   \   00000096   0xF511 0x6130      ADDS     R1,R1,#+2816
   \   0000009A   0x6909             LDR      R1,[R1, #+16]
   \   0000009C   0x0349             LSLS     R1,R1,#+13       ;; ZeroExtS R1,R1,#+13,#+13
   \   0000009E   0x0B49             LSRS     R1,R1,#+13
   \   000000A0   0x1A40             SUBS     R0,R0,R1
   \   000000A2   0x211C             MOVS     R1,#+28
   \   000000A4   0xFB01 0x4109      MLA      R1,R1,R9,R4
   \   000000A8   0xF8C1 0x01F0      STR      R0,[R1, #+496]
    350                        hpcd->OUT_ep[epnum].xfer_buff += hpcd->OUT_ep[epnum].maxpacket;            
   \   000000AC   0x201C             MOVS     R0,#+28
   \   000000AE   0xFB00 0x4009      MLA      R0,R0,R9,R4
   \   000000B2   0xF8D0 0x01E4      LDR      R0,[R0, #+484]
   \   000000B6   0x211C             MOVS     R1,#+28
   \   000000B8   0xFB01 0x4109      MLA      R1,R1,R9,R4
   \   000000BC   0xF8D1 0x11E0      LDR      R1,[R1, #+480]
   \   000000C0   0x1808             ADDS     R0,R1,R0
   \   000000C2   0x211C             MOVS     R1,#+28
   \   000000C4   0xFB01 0x4109      MLA      R1,R1,R9,R4
   \   000000C8   0xF8C1 0x01E4      STR      R0,[R1, #+484]
    351                      }
    352                      
    353                      HAL_PCD_DataOutStageCallback(hpcd, epnum);
   \                     ??HAL_PCD_IRQHandler_8: (+1)
   \   000000CC   0x4649             MOV      R1,R9
   \   000000CE   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000D0   0x0020             MOVS     R0,R4
   \   000000D2   0x.... 0x....      BL       HAL_PCD_DataOutStageCallback
    354                      if(hpcd->Init.dma_enable == 1)
   \   000000D6   0x6920             LDR      R0,[R4, #+16]
   \   000000D8   0x2801             CMP      R0,#+1
   \   000000DA   0xD10F             BNE.N    ??HAL_PCD_IRQHandler_7
    355                      {
    356                        if((epnum == 0) && (hpcd->OUT_ep[epnum].xfer_len == 0))
   \   000000DC   0xF1B9 0x0F00      CMP      R9,#+0
   \   000000E0   0xD10C             BNE.N    ??HAL_PCD_IRQHandler_7
   \   000000E2   0x201C             MOVS     R0,#+28
   \   000000E4   0xFB00 0x4009      MLA      R0,R0,R9,R4
   \   000000E8   0xF8D0 0x01EC      LDR      R0,[R0, #+492]
   \   000000EC   0x2800             CMP      R0,#+0
   \   000000EE   0xD105             BNE.N    ??HAL_PCD_IRQHandler_7
    357                        {
    358                           /* this is ZLP, so prepare EP0 for next setup */
    359                          USB_EP0_OutStart(hpcd->Instance, 1, (uint8_t *)hpcd->Setup);
   \   000000F0   0xF514 0x7260      ADDS     R2,R4,#+896
   \   000000F4   0x2101             MOVS     R1,#+1
   \   000000F6   0x6820             LDR      R0,[R4, #+0]
   \   000000F8   0x.... 0x....      BL       USB_EP0_OutStart
    360                        }              
    361                      }
    362                    }
    363                    
    364                    if(( epint & USB_OTG_DOEPINT_STUP) == USB_OTG_DOEPINT_STUP)
   \                     ??HAL_PCD_IRQHandler_7: (+1)
   \   000000FC   0x0730             LSLS     R0,R6,#+28
   \   000000FE   0xD508             BPL.N    ??HAL_PCD_IRQHandler_9
    365                    {
    366                      /* Inform the upper layer that a setup packet is available */
    367                      HAL_PCD_SetupStageCallback(hpcd);
   \   00000100   0x0020             MOVS     R0,R4
   \   00000102   0x.... 0x....      BL       HAL_PCD_SetupStageCallback
    368                      CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_STUP);
   \   00000106   0xEB15 0x1049      ADDS     R0,R5,R9, LSL #+5
   \   0000010A   0xF510 0x6030      ADDS     R0,R0,#+2816
   \   0000010E   0x2108             MOVS     R1,#+8
   \   00000110   0x6081             STR      R1,[R0, #+8]
    369                    }
    370                    
    371                    if(( epint & USB_OTG_DOEPINT_OTEPDIS) == USB_OTG_DOEPINT_OTEPDIS)
   \                     ??HAL_PCD_IRQHandler_9: (+1)
   \   00000112   0x06F0             LSLS     R0,R6,#+27
   \   00000114   0xD505             BPL.N    ??HAL_PCD_IRQHandler_6
    372                    {
    373                      CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_OTEPDIS);
   \   00000116   0xEB15 0x1049      ADDS     R0,R5,R9, LSL #+5
   \   0000011A   0xF510 0x6030      ADDS     R0,R0,#+2816
   \   0000011E   0x2110             MOVS     R1,#+16
   \   00000120   0x6081             STR      R1,[R0, #+8]
    374                    }
    375                  }
    376                  epnum++;
   \                     ??HAL_PCD_IRQHandler_6: (+1)
   \   00000122   0xF119 0x0901      ADDS     R9,R9,#+1
    377                  ep_intr >>= 1;
   \   00000126   0xEA5F 0x0A5A      LSRS     R10,R10,#+1
   \   0000012A   0xE796             B.N      ??HAL_PCD_IRQHandler_5
    378                }
    379              }
    380              
    381              if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_IEPINT))
   \                     ??HAL_PCD_IRQHandler_4: (+1)
   \   0000012C   0x6820             LDR      R0,[R4, #+0]
   \   0000012E   0x.... 0x....      BL       USB_ReadInterrupts
   \   00000132   0x0340             LSLS     R0,R0,#+13
   \   00000134   0xD576             BPL.N    ??HAL_PCD_IRQHandler_10
    382              {
    383                /* Read in the device interrupt bits */
    384                ep_intr = USB_ReadDevAllInEpInterrupt(hpcd->Instance);
   \   00000136   0x6820             LDR      R0,[R4, #+0]
   \   00000138   0x.... 0x....      BL       USB_ReadDevAllInEpInterrupt
   \   0000013C   0x4682             MOV      R10,R0
    385                
    386                epnum = 0;
   \   0000013E   0x2000             MOVS     R0,#+0
   \   00000140   0x4681             MOV      R9,R0
    387                
    388                while ( ep_intr )
   \                     ??HAL_PCD_IRQHandler_11: (+1)
   \   00000142   0xF1BA 0x0F00      CMP      R10,#+0
   \   00000146   0xD06D             BEQ.N    ??HAL_PCD_IRQHandler_10
    389                {
    390                  if (ep_intr & 0x1) /* In ITR */
   \   00000148   0xEA5F 0x70CA      LSLS     R0,R10,#+31
   \   0000014C   0xD565             BPL.N    ??HAL_PCD_IRQHandler_12
    391                  {
    392                    epint = USB_ReadDevInEPInterrupt(hpcd->Instance, epnum);
   \   0000014E   0x4649             MOV      R1,R9
   \   00000150   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000152   0x6820             LDR      R0,[R4, #+0]
   \   00000154   0x.... 0x....      BL       USB_ReadDevInEPInterrupt
   \   00000158   0x0006             MOVS     R6,R0
    393          
    394                     if(( epint & USB_OTG_DIEPINT_XFRC) == USB_OTG_DIEPINT_XFRC)
   \   0000015A   0x07F0             LSLS     R0,R6,#+31
   \   0000015C   0xD537             BPL.N    ??HAL_PCD_IRQHandler_13
    395                    {
    396                      fifoemptymsk = 0x1 << epnum;
   \   0000015E   0x2001             MOVS     R0,#+1
   \   00000160   0xFA10 0xF009      LSLS     R0,R0,R9
   \   00000164   0x0007             MOVS     R7,R0
    397                      USBx_DEVICE->DIEPEMPMSK &= ~fifoemptymsk;
   \   00000166   0xF515 0x6000      ADDS     R0,R5,#+2048
   \   0000016A   0x6B40             LDR      R0,[R0, #+52]
   \   0000016C   0x43B8             BICS     R0,R0,R7
   \   0000016E   0xF515 0x6100      ADDS     R1,R5,#+2048
   \   00000172   0x6348             STR      R0,[R1, #+52]
    398                      
    399                      CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_XFRC);
   \   00000174   0xEB15 0x1049      ADDS     R0,R5,R9, LSL #+5
   \   00000178   0xF510 0x6010      ADDS     R0,R0,#+2304
   \   0000017C   0x2101             MOVS     R1,#+1
   \   0000017E   0x6081             STR      R1,[R0, #+8]
    400                      
    401                      if (hpcd->Init.dma_enable == 1)
   \   00000180   0x6920             LDR      R0,[R4, #+16]
   \   00000182   0x2801             CMP      R0,#+1
   \   00000184   0xD10C             BNE.N    ??HAL_PCD_IRQHandler_14
    402                      {
    403                        hpcd->IN_ep[epnum].xfer_buff += hpcd->IN_ep[epnum].maxpacket; 
   \   00000186   0x201C             MOVS     R0,#+28
   \   00000188   0xFB00 0x4009      MLA      R0,R0,R9,R4
   \   0000018C   0x6C00             LDR      R0,[R0, #+64]
   \   0000018E   0x211C             MOVS     R1,#+28
   \   00000190   0xFB01 0x4109      MLA      R1,R1,R9,R4
   \   00000194   0x6BC9             LDR      R1,[R1, #+60]
   \   00000196   0x1808             ADDS     R0,R1,R0
   \   00000198   0x211C             MOVS     R1,#+28
   \   0000019A   0xFB01 0x4109      MLA      R1,R1,R9,R4
   \   0000019E   0x6408             STR      R0,[R1, #+64]
    404                      }
    405                                                
    406                      HAL_PCD_DataInStageCallback(hpcd, epnum);
   \                     ??HAL_PCD_IRQHandler_14: (+1)
   \   000001A0   0x4649             MOV      R1,R9
   \   000001A2   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000001A4   0x0020             MOVS     R0,R4
   \   000001A6   0x.... 0x....      BL       HAL_PCD_DataInStageCallback
    407          
    408                      if (hpcd->Init.dma_enable == 1)
   \   000001AA   0x6920             LDR      R0,[R4, #+16]
   \   000001AC   0x2801             CMP      R0,#+1
   \   000001AE   0xD10E             BNE.N    ??HAL_PCD_IRQHandler_13
    409                      {
    410                        /* this is ZLP, so prepare EP0 for next setup */
    411                        if((epnum == 0) && (hpcd->IN_ep[epnum].xfer_len == 0))
   \   000001B0   0xF1B9 0x0F00      CMP      R9,#+0
   \   000001B4   0xD10B             BNE.N    ??HAL_PCD_IRQHandler_13
   \   000001B6   0x201C             MOVS     R0,#+28
   \   000001B8   0xFB00 0x4009      MLA      R0,R0,R9,R4
   \   000001BC   0x6C80             LDR      R0,[R0, #+72]
   \   000001BE   0x2800             CMP      R0,#+0
   \   000001C0   0xD105             BNE.N    ??HAL_PCD_IRQHandler_13
    412                        {
    413                          /* prepare to rx more setup packets */
    414                          USB_EP0_OutStart(hpcd->Instance, 1, (uint8_t *)hpcd->Setup);
   \   000001C2   0xF514 0x7260      ADDS     R2,R4,#+896
   \   000001C6   0x2101             MOVS     R1,#+1
   \   000001C8   0x6820             LDR      R0,[R4, #+0]
   \   000001CA   0x.... 0x....      BL       USB_EP0_OutStart
    415                        }
    416                      }           
    417                    }
    418                     if(( epint & USB_OTG_DIEPINT_TOC) == USB_OTG_DIEPINT_TOC)
   \                     ??HAL_PCD_IRQHandler_13: (+1)
   \   000001CE   0x0730             LSLS     R0,R6,#+28
   \   000001D0   0xD505             BPL.N    ??HAL_PCD_IRQHandler_15
    419                    {
    420                      CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_TOC);
   \   000001D2   0xEB15 0x1049      ADDS     R0,R5,R9, LSL #+5
   \   000001D6   0xF510 0x6010      ADDS     R0,R0,#+2304
   \   000001DA   0x2108             MOVS     R1,#+8
   \   000001DC   0x6081             STR      R1,[R0, #+8]
    421                    }
    422                    if(( epint & USB_OTG_DIEPINT_ITTXFE) == USB_OTG_DIEPINT_ITTXFE)
   \                     ??HAL_PCD_IRQHandler_15: (+1)
   \   000001DE   0x06F0             LSLS     R0,R6,#+27
   \   000001E0   0xD505             BPL.N    ??HAL_PCD_IRQHandler_16
    423                    {
    424                      CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_ITTXFE);
   \   000001E2   0xEB15 0x1049      ADDS     R0,R5,R9, LSL #+5
   \   000001E6   0xF510 0x6010      ADDS     R0,R0,#+2304
   \   000001EA   0x2110             MOVS     R1,#+16
   \   000001EC   0x6081             STR      R1,[R0, #+8]
    425                    }
    426                    if(( epint & USB_OTG_DIEPINT_INEPNE) == USB_OTG_DIEPINT_INEPNE)
   \                     ??HAL_PCD_IRQHandler_16: (+1)
   \   000001EE   0x0670             LSLS     R0,R6,#+25
   \   000001F0   0xD505             BPL.N    ??HAL_PCD_IRQHandler_17
    427                    {
    428                      CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_INEPNE);
   \   000001F2   0xEB15 0x1049      ADDS     R0,R5,R9, LSL #+5
   \   000001F6   0xF510 0x6010      ADDS     R0,R0,#+2304
   \   000001FA   0x2140             MOVS     R1,#+64
   \   000001FC   0x6081             STR      R1,[R0, #+8]
    429                    }
    430                    if(( epint & USB_OTG_DIEPINT_EPDISD) == USB_OTG_DIEPINT_EPDISD)
   \                     ??HAL_PCD_IRQHandler_17: (+1)
   \   000001FE   0x07B0             LSLS     R0,R6,#+30
   \   00000200   0xD505             BPL.N    ??HAL_PCD_IRQHandler_18
    431                    {
    432                      CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_EPDISD);
   \   00000202   0xEB15 0x1049      ADDS     R0,R5,R9, LSL #+5
   \   00000206   0xF510 0x6010      ADDS     R0,R0,#+2304
   \   0000020A   0x2102             MOVS     R1,#+2
   \   0000020C   0x6081             STR      R1,[R0, #+8]
    433                    }       
    434                    if(( epint & USB_OTG_DIEPINT_TXFE) == USB_OTG_DIEPINT_TXFE)
   \                     ??HAL_PCD_IRQHandler_18: (+1)
   \   0000020E   0x0630             LSLS     R0,R6,#+24
   \   00000210   0xD503             BPL.N    ??HAL_PCD_IRQHandler_12
    435                    {
    436                      PCD_WriteEmptyTxFifo(hpcd , epnum);
   \   00000212   0x4649             MOV      R1,R9
   \   00000214   0x0020             MOVS     R0,R4
   \   00000216   0x.... 0x....      BL       PCD_WriteEmptyTxFifo
    437                    }
    438                  }
    439                  epnum++;
   \                     ??HAL_PCD_IRQHandler_12: (+1)
   \   0000021A   0xF119 0x0901      ADDS     R9,R9,#+1
    440                  ep_intr >>= 1;
   \   0000021E   0xEA5F 0x0A5A      LSRS     R10,R10,#+1
   \   00000222   0xE78E             B.N      ??HAL_PCD_IRQHandler_11
    441                }
    442              }
    443              
    444              /* Handle Resume Interrupt */
    445              if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_WKUINT))
   \                     ??HAL_PCD_IRQHandler_10: (+1)
   \   00000224   0x6820             LDR      R0,[R4, #+0]
   \   00000226   0x.... 0x....      BL       USB_ReadInterrupts
   \   0000022A   0x2800             CMP      R0,#+0
   \   0000022C   0xD51A             BPL.N    ??HAL_PCD_IRQHandler_19
    446              {
    447                /* Clear the Remote Wake-up Signaling */
    448                USBx_DEVICE->DCTL &= ~USB_OTG_DCTL_RWUSIG;
   \   0000022E   0xF515 0x6000      ADDS     R0,R5,#+2048
   \   00000232   0x6840             LDR      R0,[R0, #+4]
   \   00000234   0x0840             LSRS     R0,R0,#+1
   \   00000236   0x0040             LSLS     R0,R0,#+1
   \   00000238   0xF515 0x6100      ADDS     R1,R5,#+2048
   \   0000023C   0x6048             STR      R0,[R1, #+4]
    449                
    450                if(hpcd->LPM_State == LPM_L1)
   \   0000023E   0xF894 0x03B0      LDRB     R0,[R4, #+944]
   \   00000242   0x2801             CMP      R0,#+1
   \   00000244   0xD107             BNE.N    ??HAL_PCD_IRQHandler_20
    451                {
    452                  hpcd->LPM_State = LPM_L0;
   \   00000246   0x2000             MOVS     R0,#+0
   \   00000248   0xF884 0x03B0      STRB     R0,[R4, #+944]
    453                  HAL_PCDEx_LPM_Callback(hpcd, PCD_LPM_L0_ACTIVE);
   \   0000024C   0x2100             MOVS     R1,#+0
   \   0000024E   0x0020             MOVS     R0,R4
   \   00000250   0x.... 0x....      BL       HAL_PCDEx_LPM_Callback
   \   00000254   0xE002             B.N      ??HAL_PCD_IRQHandler_21
    454                }
    455                else
    456                {
    457                  HAL_PCD_ResumeCallback(hpcd);
   \                     ??HAL_PCD_IRQHandler_20: (+1)
   \   00000256   0x0020             MOVS     R0,R4
   \   00000258   0x.... 0x....      BL       HAL_PCD_ResumeCallback
    458                }
    459                __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_WKUINT);
   \                     ??HAL_PCD_IRQHandler_21: (+1)
   \   0000025C   0xF05F 0x4000      MOVS     R0,#-2147483648
   \   00000260   0x6821             LDR      R1,[R4, #+0]
   \   00000262   0x6148             STR      R0,[R1, #+20]
    460              }
    461              
    462              /* Handle Suspend Interrupt */
    463              if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_USBSUSP))
   \                     ??HAL_PCD_IRQHandler_19: (+1)
   \   00000264   0x6820             LDR      R0,[R4, #+0]
   \   00000266   0x.... 0x....      BL       USB_ReadInterrupts
   \   0000026A   0x0500             LSLS     R0,R0,#+20
   \   0000026C   0xD50B             BPL.N    ??HAL_PCD_IRQHandler_22
    464              {
    465          
    466                if((USBx_DEVICE->DSTS & USB_OTG_DSTS_SUSPSTS) == USB_OTG_DSTS_SUSPSTS)
   \   0000026E   0xF515 0x6000      ADDS     R0,R5,#+2048
   \   00000272   0x6880             LDR      R0,[R0, #+8]
   \   00000274   0x07C0             LSLS     R0,R0,#+31
   \   00000276   0xD502             BPL.N    ??HAL_PCD_IRQHandler_23
    467                {
    468                  
    469                  HAL_PCD_SuspendCallback(hpcd);
   \   00000278   0x0020             MOVS     R0,R4
   \   0000027A   0x.... 0x....      BL       HAL_PCD_SuspendCallback
    470                }
    471                __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_USBSUSP);
   \                     ??HAL_PCD_IRQHandler_23: (+1)
   \   0000027E   0xF44F 0x6000      MOV      R0,#+2048
   \   00000282   0x6821             LDR      R1,[R4, #+0]
   \   00000284   0x6148             STR      R0,[R1, #+20]
    472              }
    473              
    474              /* Handle LPM Interrupt */ 
    475              if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_LPMINT))
   \                     ??HAL_PCD_IRQHandler_22: (+1)
   \   00000286   0x6820             LDR      R0,[R4, #+0]
   \   00000288   0x.... 0x....      BL       USB_ReadInterrupts
   \   0000028C   0x0100             LSLS     R0,R0,#+4
   \   0000028E   0xD518             BPL.N    ??HAL_PCD_IRQHandler_24
    476              {
    477                __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_LPMINT);      
   \   00000290   0xF05F 0x6000      MOVS     R0,#+134217728
   \   00000294   0x6821             LDR      R1,[R4, #+0]
   \   00000296   0x6148             STR      R0,[R1, #+20]
    478                if( hpcd->LPM_State == LPM_L0)
   \   00000298   0xF894 0x03B0      LDRB     R0,[R4, #+944]
   \   0000029C   0x2800             CMP      R0,#+0
   \   0000029E   0xD10D             BNE.N    ??HAL_PCD_IRQHandler_25
    479                {
    480                  hpcd->LPM_State = LPM_L1;
   \   000002A0   0x2001             MOVS     R0,#+1
   \   000002A2   0xF884 0x03B0      STRB     R0,[R4, #+944]
    481                  hpcd->BESL = (hpcd->Instance->GLPMCFG & USB_OTG_GLPMCFG_BESL) >>2 ;
   \   000002A6   0x6820             LDR      R0,[R4, #+0]
   \   000002A8   0x6D40             LDR      R0,[R0, #+84]
   \   000002AA   0xF3C0 0x0083      UBFX     R0,R0,#+2,#+4
   \   000002AE   0xF8C4 0x03B4      STR      R0,[R4, #+948]
    482                  HAL_PCDEx_LPM_Callback(hpcd, PCD_LPM_L1_ACTIVE);
   \   000002B2   0x2101             MOVS     R1,#+1
   \   000002B4   0x0020             MOVS     R0,R4
   \   000002B6   0x.... 0x....      BL       HAL_PCDEx_LPM_Callback
   \   000002BA   0xE002             B.N      ??HAL_PCD_IRQHandler_24
    483                }
    484                else
    485                {
    486                  HAL_PCD_SuspendCallback(hpcd);
   \                     ??HAL_PCD_IRQHandler_25: (+1)
   \   000002BC   0x0020             MOVS     R0,R4
   \   000002BE   0x.... 0x....      BL       HAL_PCD_SuspendCallback
    487                }
    488              }
    489              
    490              /* Handle Reset Interrupt */
    491              if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_USBRST))
   \                     ??HAL_PCD_IRQHandler_24: (+1)
   \   000002C2   0x6820             LDR      R0,[R4, #+0]
   \   000002C4   0x.... 0x....      BL       USB_ReadInterrupts
   \   000002C8   0x04C0             LSLS     R0,R0,#+19
   \   000002CA   0xD565             BPL.N    ??HAL_PCD_IRQHandler_26
    492              {
    493                USBx_DEVICE->DCTL &= ~USB_OTG_DCTL_RWUSIG; 
   \   000002CC   0xF515 0x6000      ADDS     R0,R5,#+2048
   \   000002D0   0x6840             LDR      R0,[R0, #+4]
   \   000002D2   0x0840             LSRS     R0,R0,#+1
   \   000002D4   0x0040             LSLS     R0,R0,#+1
   \   000002D6   0xF515 0x6100      ADDS     R1,R5,#+2048
   \   000002DA   0x6048             STR      R0,[R1, #+4]
    494                USB_FlushTxFifo(hpcd->Instance ,  0 );
   \   000002DC   0x2100             MOVS     R1,#+0
   \   000002DE   0x6820             LDR      R0,[R4, #+0]
   \   000002E0   0x.... 0x....      BL       USB_FlushTxFifo
    495                
    496                for (i = 0; i < hpcd->Init.dev_endpoints ; i++)
   \   000002E4   0x2000             MOVS     R0,#+0
   \   000002E6   0x4683             MOV      R11,R0
   \                     ??HAL_PCD_IRQHandler_27: (+1)
   \   000002E8   0x6860             LDR      R0,[R4, #+4]
   \   000002EA   0x4583             CMP      R11,R0
   \   000002EC   0xD20E             BCS.N    ??HAL_PCD_IRQHandler_28
    497                {
    498                  USBx_INEP(i)->DIEPINT = 0xFF;
   \   000002EE   0xEB15 0x104B      ADDS     R0,R5,R11, LSL #+5
   \   000002F2   0xF510 0x6010      ADDS     R0,R0,#+2304
   \   000002F6   0x21FF             MOVS     R1,#+255
   \   000002F8   0x6081             STR      R1,[R0, #+8]
    499                  USBx_OUTEP(i)->DOEPINT = 0xFF;
   \   000002FA   0xEB15 0x104B      ADDS     R0,R5,R11, LSL #+5
   \   000002FE   0xF510 0x6030      ADDS     R0,R0,#+2816
   \   00000302   0x21FF             MOVS     R1,#+255
   \   00000304   0x6081             STR      R1,[R0, #+8]
    500                }
   \   00000306   0xF11B 0x0B01      ADDS     R11,R11,#+1
   \   0000030A   0xE7ED             B.N      ??HAL_PCD_IRQHandler_27
    501                USBx_DEVICE->DAINT = 0xFFFFFFFF;
   \                     ??HAL_PCD_IRQHandler_28: (+1)
   \   0000030C   0xF05F 0x30FF      MOVS     R0,#-1
   \   00000310   0xF515 0x6100      ADDS     R1,R5,#+2048
   \   00000314   0x6188             STR      R0,[R1, #+24]
    502                USBx_DEVICE->DAINTMSK |= 0x10001;
   \   00000316   0xF515 0x6000      ADDS     R0,R5,#+2048
   \   0000031A   0x69C0             LDR      R0,[R0, #+28]
   \   0000031C   0xF050 0x1001      ORRS     R0,R0,#0x10001
   \   00000320   0xF515 0x6100      ADDS     R1,R5,#+2048
   \   00000324   0x61C8             STR      R0,[R1, #+28]
    503                
    504                if(hpcd->Init.use_dedicated_ep1)
   \   00000326   0x6AE0             LDR      R0,[R4, #+44]
   \   00000328   0x2800             CMP      R0,#+0
   \   0000032A   0xD012             BEQ.N    ??HAL_PCD_IRQHandler_29
    505                {
    506                  USBx_DEVICE->DOUTEP1MSK |= (USB_OTG_DOEPMSK_STUPM | USB_OTG_DOEPMSK_XFRCM | USB_OTG_DOEPMSK_EPDM); 
   \   0000032C   0xF515 0x6000      ADDS     R0,R5,#+2048
   \   00000330   0xF8D0 0x0084      LDR      R0,[R0, #+132]
   \   00000334   0xF050 0x000B      ORRS     R0,R0,#0xB
   \   00000338   0xF515 0x6100      ADDS     R1,R5,#+2048
   \   0000033C   0xF8C1 0x0084      STR      R0,[R1, #+132]
    507                  USBx_DEVICE->DINEP1MSK |= (USB_OTG_DIEPMSK_TOM | USB_OTG_DIEPMSK_XFRCM | USB_OTG_DIEPMSK_EPDM);  
   \   00000340   0xF515 0x6000      ADDS     R0,R5,#+2048
   \   00000344   0x6C40             LDR      R0,[R0, #+68]
   \   00000346   0xF050 0x000B      ORRS     R0,R0,#0xB
   \   0000034A   0xF515 0x6100      ADDS     R1,R5,#+2048
   \   0000034E   0x6448             STR      R0,[R1, #+68]
   \   00000350   0xE00F             B.N      ??HAL_PCD_IRQHandler_30
    508                }
    509                else
    510                {
    511                  USBx_DEVICE->DOEPMSK |= (USB_OTG_DOEPMSK_STUPM | USB_OTG_DOEPMSK_XFRCM | USB_OTG_DOEPMSK_EPDM);
   \                     ??HAL_PCD_IRQHandler_29: (+1)
   \   00000352   0xF515 0x6000      ADDS     R0,R5,#+2048
   \   00000356   0x6940             LDR      R0,[R0, #+20]
   \   00000358   0xF050 0x000B      ORRS     R0,R0,#0xB
   \   0000035C   0xF515 0x6100      ADDS     R1,R5,#+2048
   \   00000360   0x6148             STR      R0,[R1, #+20]
    512                  USBx_DEVICE->DIEPMSK |= (USB_OTG_DIEPMSK_TOM | USB_OTG_DIEPMSK_XFRCM | USB_OTG_DIEPMSK_EPDM);
   \   00000362   0xF515 0x6000      ADDS     R0,R5,#+2048
   \   00000366   0x6900             LDR      R0,[R0, #+16]
   \   00000368   0xF050 0x000B      ORRS     R0,R0,#0xB
   \   0000036C   0xF515 0x6100      ADDS     R1,R5,#+2048
   \   00000370   0x6108             STR      R0,[R1, #+16]
    513                }
    514                
    515                /* Set Default Address to 0 */
    516                USBx_DEVICE->DCFG &= ~USB_OTG_DCFG_DAD;
   \                     ??HAL_PCD_IRQHandler_30: (+1)
   \   00000372   0xF515 0x6000      ADDS     R0,R5,#+2048
   \   00000376   0x6800             LDR      R0,[R0, #+0]
   \   00000378   0xF430 0x60FE      BICS     R0,R0,#0x7F0
   \   0000037C   0xF515 0x6100      ADDS     R1,R5,#+2048
   \   00000380   0x6008             STR      R0,[R1, #+0]
    517                
    518                /* setup EP0 to receive SETUP packets */
    519                USB_EP0_OutStart(hpcd->Instance, hpcd->Init.dma_enable, (uint8_t *)hpcd->Setup);
   \   00000382   0xF514 0x7260      ADDS     R2,R4,#+896
   \   00000386   0x6921             LDR      R1,[R4, #+16]
   \   00000388   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000038A   0x6820             LDR      R0,[R4, #+0]
   \   0000038C   0x.... 0x....      BL       USB_EP0_OutStart
    520                  
    521                __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_USBRST);
   \   00000390   0xF44F 0x5080      MOV      R0,#+4096
   \   00000394   0x6821             LDR      R1,[R4, #+0]
   \   00000396   0x6148             STR      R0,[R1, #+20]
    522              }
    523              
    524              /* Handle Enumeration done Interrupt */
    525              if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_ENUMDNE))
   \                     ??HAL_PCD_IRQHandler_26: (+1)
   \   00000398   0x6820             LDR      R0,[R4, #+0]
   \   0000039A   0x.... 0x....      BL       USB_ReadInterrupts
   \   0000039E   0x0480             LSLS     R0,R0,#+18
   \   000003A0   0xD52A             BPL.N    ??HAL_PCD_IRQHandler_31
    526              {
    527                USB_ActivateSetup(hpcd->Instance);
   \   000003A2   0x6820             LDR      R0,[R4, #+0]
   \   000003A4   0x.... 0x....      BL       USB_ActivateSetup
    528                hpcd->Instance->GUSBCFG &= ~USB_OTG_GUSBCFG_TRDT;
   \   000003A8   0x6820             LDR      R0,[R4, #+0]
   \   000003AA   0x68C0             LDR      R0,[R0, #+12]
   \   000003AC   0xF430 0x5070      BICS     R0,R0,#0x3C00
   \   000003B0   0x6821             LDR      R1,[R4, #+0]
   \   000003B2   0x60C8             STR      R0,[R1, #+12]
    529                
    530                if ( USB_GetDevSpeed(hpcd->Instance) == USB_OTG_SPEED_HIGH)
   \   000003B4   0x6820             LDR      R0,[R4, #+0]
   \   000003B6   0x.... 0x....      BL       USB_GetDevSpeed
   \   000003BA   0x2800             CMP      R0,#+0
   \   000003BC   0xD10B             BNE.N    ??HAL_PCD_IRQHandler_32
    531                {
    532                  hpcd->Init.speed            = USB_OTG_SPEED_HIGH;
   \   000003BE   0x2000             MOVS     R0,#+0
   \   000003C0   0x60E0             STR      R0,[R4, #+12]
    533                  hpcd->Init.ep0_mps          = USB_OTG_HS_MAX_PACKET_SIZE ;
   \   000003C2   0xF44F 0x7000      MOV      R0,#+512
   \   000003C6   0x6160             STR      R0,[R4, #+20]
    534                  hpcd->Instance->GUSBCFG |= (uint32_t)((USBD_HS_TRDT_VALUE << 10) & USB_OTG_GUSBCFG_TRDT);
   \   000003C8   0x6820             LDR      R0,[R4, #+0]
   \   000003CA   0x68C0             LDR      R0,[R0, #+12]
   \   000003CC   0xF450 0x5010      ORRS     R0,R0,#0x2400
   \   000003D0   0x6821             LDR      R1,[R4, #+0]
   \   000003D2   0x60C8             STR      R0,[R1, #+12]
   \   000003D4   0xE009             B.N      ??HAL_PCD_IRQHandler_33
    535                }
    536                else
    537                {
    538                  hpcd->Init.speed            = USB_OTG_SPEED_FULL;
   \                     ??HAL_PCD_IRQHandler_32: (+1)
   \   000003D6   0x2003             MOVS     R0,#+3
   \   000003D8   0x60E0             STR      R0,[R4, #+12]
    539                  hpcd->Init.ep0_mps          = USB_OTG_FS_MAX_PACKET_SIZE ;  
   \   000003DA   0x2040             MOVS     R0,#+64
   \   000003DC   0x6160             STR      R0,[R4, #+20]
    540                  hpcd->Instance->GUSBCFG |= (uint32_t)((USBD_FS_TRDT_VALUE << 10) & USB_OTG_GUSBCFG_TRDT);
   \   000003DE   0x6820             LDR      R0,[R4, #+0]
   \   000003E0   0x68C0             LDR      R0,[R0, #+12]
   \   000003E2   0xF450 0x50A0      ORRS     R0,R0,#0x1400
   \   000003E6   0x6821             LDR      R1,[R4, #+0]
   \   000003E8   0x60C8             STR      R0,[R1, #+12]
    541                }
    542                
    543                HAL_PCD_ResetCallback(hpcd);
   \                     ??HAL_PCD_IRQHandler_33: (+1)
   \   000003EA   0x0020             MOVS     R0,R4
   \   000003EC   0x.... 0x....      BL       HAL_PCD_ResetCallback
    544                
    545                __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_ENUMDNE);
   \   000003F0   0xF44F 0x5000      MOV      R0,#+8192
   \   000003F4   0x6821             LDR      R1,[R4, #+0]
   \   000003F6   0x6148             STR      R0,[R1, #+20]
    546              }
    547              
    548              /* Handle RxQLevel Interrupt */
    549              if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_RXFLVL))
   \                     ??HAL_PCD_IRQHandler_31: (+1)
   \   000003F8   0x6820             LDR      R0,[R4, #+0]
   \   000003FA   0x.... 0x....      BL       USB_ReadInterrupts
   \   000003FE   0x06C0             LSLS     R0,R0,#+27
   \   00000400   0xD546             BPL.N    ??HAL_PCD_IRQHandler_34
    550              {
    551                USB_MASK_INTERRUPT(hpcd->Instance, USB_OTG_GINTSTS_RXFLVL);
   \   00000402   0x6820             LDR      R0,[R4, #+0]
   \   00000404   0x6980             LDR      R0,[R0, #+24]
   \   00000406   0xF030 0x0010      BICS     R0,R0,#0x10
   \   0000040A   0x6821             LDR      R1,[R4, #+0]
   \   0000040C   0x6188             STR      R0,[R1, #+24]
    552                temp = USBx->GRXSTSP;
   \   0000040E   0x6A28             LDR      R0,[R5, #+32]
   \   00000410   0x4680             MOV      R8,R0
    553                ep = &hpcd->OUT_ep[temp & USB_OTG_GRXSTSP_EPNUM];
   \   00000412   0xF018 0x000F      ANDS     R0,R8,#0xF
   \   00000416   0x211C             MOVS     R1,#+28
   \   00000418   0xFB01 0x4000      MLA      R0,R1,R0,R4
   \   0000041C   0xF510 0x70EC      ADDS     R0,R0,#+472
   \   00000420   0x9000             STR      R0,[SP, #+0]
    554                
    555                if(((temp & USB_OTG_GRXSTSP_PKTSTS) >> 17) ==  STS_DATA_UPDT)
   \   00000422   0xF3C8 0x4043      UBFX     R0,R8,#+17,#+4
   \   00000426   0x2802             CMP      R0,#+2
   \   00000428   0xD11B             BNE.N    ??HAL_PCD_IRQHandler_35
    556                {
    557                  if((temp & USB_OTG_GRXSTSP_BCNT) != 0)
   \   0000042A   0xF647 0x70F0      MOVW     R0,#+32752
   \   0000042E   0xEA18 0x0F00      TST      R8,R0
   \   00000432   0xD027             BEQ.N    ??HAL_PCD_IRQHandler_36
    558                  {
    559                    USB_ReadPacket(USBx, ep->xfer_buff, (temp & USB_OTG_GRXSTSP_BCNT) >> 4);
   \   00000434   0xF3C8 0x120A      UBFX     R2,R8,#+4,#+11
   \   00000438   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   0000043A   0x9800             LDR      R0,[SP, #+0]
   \   0000043C   0x68C1             LDR      R1,[R0, #+12]
   \   0000043E   0x0028             MOVS     R0,R5
   \   00000440   0x.... 0x....      BL       USB_ReadPacket
    560                    ep->xfer_buff += (temp & USB_OTG_GRXSTSP_BCNT) >> 4;
   \   00000444   0x9800             LDR      R0,[SP, #+0]
   \   00000446   0x68C0             LDR      R0,[R0, #+12]
   \   00000448   0xF3C8 0x110A      UBFX     R1,R8,#+4,#+11
   \   0000044C   0x1808             ADDS     R0,R1,R0
   \   0000044E   0x9900             LDR      R1,[SP, #+0]
   \   00000450   0x60C8             STR      R0,[R1, #+12]
    561                    ep->xfer_count += (temp & USB_OTG_GRXSTSP_BCNT) >> 4;
   \   00000452   0x9800             LDR      R0,[SP, #+0]
   \   00000454   0x6980             LDR      R0,[R0, #+24]
   \   00000456   0xF3C8 0x110A      UBFX     R1,R8,#+4,#+11
   \   0000045A   0x1808             ADDS     R0,R1,R0
   \   0000045C   0x9900             LDR      R1,[SP, #+0]
   \   0000045E   0x6188             STR      R0,[R1, #+24]
   \   00000460   0xE010             B.N      ??HAL_PCD_IRQHandler_36
    562                  }
    563                }
    564                else if (((temp & USB_OTG_GRXSTSP_PKTSTS) >> 17) ==  STS_SETUP_UPDT)
   \                     ??HAL_PCD_IRQHandler_35: (+1)
   \   00000462   0xF3C8 0x4043      UBFX     R0,R8,#+17,#+4
   \   00000466   0x2806             CMP      R0,#+6
   \   00000468   0xD10C             BNE.N    ??HAL_PCD_IRQHandler_36
    565                {
    566                  USB_ReadPacket(USBx, (uint8_t *)hpcd->Setup, 8);
   \   0000046A   0x2208             MOVS     R2,#+8
   \   0000046C   0xF514 0x7160      ADDS     R1,R4,#+896
   \   00000470   0x0028             MOVS     R0,R5
   \   00000472   0x.... 0x....      BL       USB_ReadPacket
    567                  ep->xfer_count += (temp & USB_OTG_GRXSTSP_BCNT) >> 4;
   \   00000476   0x9800             LDR      R0,[SP, #+0]
   \   00000478   0x6980             LDR      R0,[R0, #+24]
   \   0000047A   0xF3C8 0x110A      UBFX     R1,R8,#+4,#+11
   \   0000047E   0x1808             ADDS     R0,R1,R0
   \   00000480   0x9900             LDR      R1,[SP, #+0]
   \   00000482   0x6188             STR      R0,[R1, #+24]
    568                }
    569                USB_UNMASK_INTERRUPT(hpcd->Instance, USB_OTG_GINTSTS_RXFLVL);
   \                     ??HAL_PCD_IRQHandler_36: (+1)
   \   00000484   0x6820             LDR      R0,[R4, #+0]
   \   00000486   0x6980             LDR      R0,[R0, #+24]
   \   00000488   0xF050 0x0010      ORRS     R0,R0,#0x10
   \   0000048C   0x6821             LDR      R1,[R4, #+0]
   \   0000048E   0x6188             STR      R0,[R1, #+24]
    570              }
    571              
    572              /* Handle SOF Interrupt */
    573              if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_SOF))
   \                     ??HAL_PCD_IRQHandler_34: (+1)
   \   00000490   0x6820             LDR      R0,[R4, #+0]
   \   00000492   0x.... 0x....      BL       USB_ReadInterrupts
   \   00000496   0x0700             LSLS     R0,R0,#+28
   \   00000498   0xD505             BPL.N    ??HAL_PCD_IRQHandler_37
    574              {
    575                HAL_PCD_SOFCallback(hpcd);
   \   0000049A   0x0020             MOVS     R0,R4
   \   0000049C   0x.... 0x....      BL       HAL_PCD_SOFCallback
    576                __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_SOF);
   \   000004A0   0x2008             MOVS     R0,#+8
   \   000004A2   0x6821             LDR      R1,[R4, #+0]
   \   000004A4   0x6148             STR      R0,[R1, #+20]
    577              }
    578              
    579              /* Handle Incomplete ISO IN Interrupt */
    580              if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_IISOIXFR))
   \                     ??HAL_PCD_IRQHandler_37: (+1)
   \   000004A6   0x6820             LDR      R0,[R4, #+0]
   \   000004A8   0x.... 0x....      BL       USB_ReadInterrupts
   \   000004AC   0x02C0             LSLS     R0,R0,#+11
   \   000004AE   0xD508             BPL.N    ??HAL_PCD_IRQHandler_38
    581              {
    582                HAL_PCD_ISOINIncompleteCallback(hpcd, epnum);
   \   000004B0   0x4649             MOV      R1,R9
   \   000004B2   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000004B4   0x0020             MOVS     R0,R4
   \   000004B6   0x.... 0x....      BL       HAL_PCD_ISOINIncompleteCallback
    583                __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_IISOIXFR);
   \   000004BA   0xF45F 0x1080      MOVS     R0,#+1048576
   \   000004BE   0x6821             LDR      R1,[R4, #+0]
   \   000004C0   0x6148             STR      R0,[R1, #+20]
    584              } 
    585              
    586              /* Handle Incomplete ISO OUT Interrupt */
    587              if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_PXFR_INCOMPISOOUT))
   \                     ??HAL_PCD_IRQHandler_38: (+1)
   \   000004C2   0x6820             LDR      R0,[R4, #+0]
   \   000004C4   0x.... 0x....      BL       USB_ReadInterrupts
   \   000004C8   0x0280             LSLS     R0,R0,#+10
   \   000004CA   0xD508             BPL.N    ??HAL_PCD_IRQHandler_39
    588              {
    589                HAL_PCD_ISOOUTIncompleteCallback(hpcd, epnum);
   \   000004CC   0x4649             MOV      R1,R9
   \   000004CE   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000004D0   0x0020             MOVS     R0,R4
   \   000004D2   0x.... 0x....      BL       HAL_PCD_ISOOUTIncompleteCallback
    590                __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_PXFR_INCOMPISOOUT);
   \   000004D6   0xF45F 0x1000      MOVS     R0,#+2097152
   \   000004DA   0x6821             LDR      R1,[R4, #+0]
   \   000004DC   0x6148             STR      R0,[R1, #+20]
    591              } 
    592              
    593              /* Handle Connection event Interrupt */
    594              if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_SRQINT))
   \                     ??HAL_PCD_IRQHandler_39: (+1)
   \   000004DE   0x6820             LDR      R0,[R4, #+0]
   \   000004E0   0x.... 0x....      BL       USB_ReadInterrupts
   \   000004E4   0x0040             LSLS     R0,R0,#+1
   \   000004E6   0xD506             BPL.N    ??HAL_PCD_IRQHandler_40
    595              {
    596                HAL_PCD_ConnectCallback(hpcd);
   \   000004E8   0x0020             MOVS     R0,R4
   \   000004EA   0x.... 0x....      BL       HAL_PCD_ConnectCallback
    597                __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_SRQINT);
   \   000004EE   0xF05F 0x4080      MOVS     R0,#+1073741824
   \   000004F2   0x6821             LDR      R1,[R4, #+0]
   \   000004F4   0x6148             STR      R0,[R1, #+20]
    598              } 
    599              
    600              /* Handle Disconnection event Interrupt */
    601              if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_OTGINT))
   \                     ??HAL_PCD_IRQHandler_40: (+1)
   \   000004F6   0x6820             LDR      R0,[R4, #+0]
   \   000004F8   0x.... 0x....      BL       USB_ReadInterrupts
   \   000004FC   0x0740             LSLS     R0,R0,#+29
   \   000004FE   0xD50E             BPL.N    ??HAL_PCD_IRQHandler_0
    602              {
    603                temp = hpcd->Instance->GOTGINT;
   \   00000500   0x6820             LDR      R0,[R4, #+0]
   \   00000502   0x6840             LDR      R0,[R0, #+4]
   \   00000504   0x4680             MOV      R8,R0
    604                
    605                if((temp & USB_OTG_GOTGINT_SEDET) == USB_OTG_GOTGINT_SEDET)
   \   00000506   0xEA5F 0x7048      LSLS     R0,R8,#+29
   \   0000050A   0xD502             BPL.N    ??HAL_PCD_IRQHandler_41
    606                {
    607                  HAL_PCD_DisconnectCallback(hpcd);
   \   0000050C   0x0020             MOVS     R0,R4
   \   0000050E   0x.... 0x....      BL       HAL_PCD_DisconnectCallback
    608                }
    609                hpcd->Instance->GOTGINT |= temp;
   \                     ??HAL_PCD_IRQHandler_41: (+1)
   \   00000512   0x6820             LDR      R0,[R4, #+0]
   \   00000514   0x6840             LDR      R0,[R0, #+4]
   \   00000516   0xEA58 0x0000      ORRS     R0,R8,R0
   \   0000051A   0x6821             LDR      R1,[R4, #+0]
   \   0000051C   0x6048             STR      R0,[R1, #+4]
    610              }
    611            }
    612          }
   \                     ??HAL_PCD_IRQHandler_0: (+1)
   \                     ??HAL_PCD_IRQHandler_1: (+1)
   \   0000051E   0xE8BD 0x8FF1      POP      {R0,R4-R11,PC}   ;; return
    613          
    614          /**
    615            * @brief  Data out stage callbacks
    616            * @param  hpcd: PCD handle
    617            * @param  epnum: endpoint number  
    618            * @retval None
    619            */

   \                                 In section .text, align 2, keep-with-next
    620           __weak void HAL_PCD_DataOutStageCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
    621          {
    622            /* NOTE : This function Should not be modified, when the callback is needed,
    623                      the HAL_PCD_DataOutStageCallback could be implemented in the user file
    624             */ 
    625          }
   \                     HAL_PCD_DataOutStageCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    626          
    627          /**
    628            * @brief  Data IN stage callbacks
    629            * @param  hpcd: PCD handle
    630            * @param  epnum: endpoint number  
    631            * @retval None
    632            */

   \                                 In section .text, align 2, keep-with-next
    633           __weak void HAL_PCD_DataInStageCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
    634          {
    635            /* NOTE : This function Should not be modified, when the callback is needed,
    636                      the HAL_PCD_DataInStageCallback could be implemented in the user file
    637             */ 
    638          }
   \                     HAL_PCD_DataInStageCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    639          /**
    640            * @brief  Setup stage callback
    641            * @param  hpcd: PCD handle
    642            * @retval None
    643            */

   \                                 In section .text, align 2, keep-with-next
    644           __weak void HAL_PCD_SetupStageCallback(PCD_HandleTypeDef *hpcd)
    645          {
    646            /* NOTE : This function Should not be modified, when the callback is needed,
    647                      the HAL_PCD_SetupStageCallback could be implemented in the user file
    648             */ 
    649          }
   \                     HAL_PCD_SetupStageCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    650          
    651          /**
    652            * @brief  USB Start Of Frame callbacks
    653            * @param  hpcd: PCD handle
    654            * @retval None
    655            */

   \                                 In section .text, align 2, keep-with-next
    656           __weak void HAL_PCD_SOFCallback(PCD_HandleTypeDef *hpcd)
    657          {
    658            /* NOTE : This function Should not be modified, when the callback is needed,
    659                      the HAL_PCD_SOFCallback could be implemented in the user file
    660             */ 
    661          }
   \                     HAL_PCD_SOFCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    662          
    663          /**
    664            * @brief  USB Reset callbacks
    665            * @param  hpcd: PCD handle
    666            * @retval None
    667            */

   \                                 In section .text, align 2, keep-with-next
    668           __weak void HAL_PCD_ResetCallback(PCD_HandleTypeDef *hpcd)
    669          {
    670            /* NOTE : This function Should not be modified, when the callback is needed,
    671                      the HAL_PCD_ResetCallback could be implemented in the user file
    672             */ 
    673          }
   \                     HAL_PCD_ResetCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    674          
    675          
    676          /**
    677            * @brief  Suspend event callbacks
    678            * @param  hpcd: PCD handle
    679            * @retval None
    680            */

   \                                 In section .text, align 2, keep-with-next
    681           __weak void HAL_PCD_SuspendCallback(PCD_HandleTypeDef *hpcd)
    682          {
    683            /* NOTE : This function Should not be modified, when the callback is needed,
    684                      the HAL_PCD_SuspendCallback could be implemented in the user file
    685             */ 
    686          }
   \                     HAL_PCD_SuspendCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    687          
    688          /**
    689            * @brief  Resume event callbacks
    690            * @param  hpcd: PCD handle
    691            * @retval None
    692            */

   \                                 In section .text, align 2, keep-with-next
    693           __weak void HAL_PCD_ResumeCallback(PCD_HandleTypeDef *hpcd)
    694          {
    695            /* NOTE : This function Should not be modified, when the callback is needed,
    696                      the HAL_PCD_ResumeCallback could be implemented in the user file
    697             */ 
    698          }
   \                     HAL_PCD_ResumeCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    699          
    700          /**
    701            * @brief  Incomplete ISO OUT callbacks
    702            * @param  hpcd: PCD handle
    703            * @param  epnum: endpoint number
    704            * @retval None
    705            */

   \                                 In section .text, align 2, keep-with-next
    706           __weak void HAL_PCD_ISOOUTIncompleteCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
    707          {
    708            /* NOTE : This function Should not be modified, when the callback is needed,
    709                      the HAL_PCD_ISOOUTIncompleteCallback could be implemented in the user file
    710             */ 
    711          }
   \                     HAL_PCD_ISOOUTIncompleteCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    712          
    713          /**
    714            * @brief  Incomplete ISO IN  callbacks
    715            * @param  hpcd: PCD handle
    716            * @param  epnum: endpoint number  
    717            * @retval None
    718            */

   \                                 In section .text, align 2, keep-with-next
    719           __weak void HAL_PCD_ISOINIncompleteCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
    720          {
    721            /* NOTE : This function Should not be modified, when the callback is needed,
    722                      the HAL_PCD_ISOINIncompleteCallback could be implemented in the user file
    723             */ 
    724          }
   \                     HAL_PCD_ISOINIncompleteCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    725          
    726          /**
    727            * @brief  Connection event callbacks
    728            * @param  hpcd: PCD handle
    729            * @retval None
    730            */

   \                                 In section .text, align 2, keep-with-next
    731           __weak void HAL_PCD_ConnectCallback(PCD_HandleTypeDef *hpcd)
    732          {
    733            /* NOTE : This function Should not be modified, when the callback is needed,
    734                      the HAL_PCD_ConnectCallback could be implemented in the user file
    735             */ 
    736          }
   \                     HAL_PCD_ConnectCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    737          
    738          /**
    739            * @brief  Disconnection event callbacks
    740            * @param  hpcd: PCD handle
    741            * @retval None
    742            */

   \                                 In section .text, align 2, keep-with-next
    743           __weak void HAL_PCD_DisconnectCallback(PCD_HandleTypeDef *hpcd)
    744          {
    745            /* NOTE : This function Should not be modified, when the callback is needed,
    746                      the HAL_PCD_DisconnectCallback could be implemented in the user file
    747             */ 
    748          }
   \                     HAL_PCD_DisconnectCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    749          
    750          /**
    751            * @}
    752            */
    753            
    754          /** @defgroup PCD_Exported_Functions_Group3 Peripheral Control functions
    755           *  @brief   management functions 
    756           *
    757          @verbatim   
    758           ===============================================================================
    759                                ##### Peripheral Control functions #####
    760           ===============================================================================  
    761              [..]
    762              This subsection provides a set of functions allowing to control the PCD data 
    763              transfers.
    764          
    765          @endverbatim
    766            * @{
    767            */
    768          
    769          /**
    770            * @brief  Connect the USB device
    771            * @param  hpcd: PCD handle
    772            * @retval HAL status
    773            */

   \                                 In section .text, align 2, keep-with-next
    774          HAL_StatusTypeDef HAL_PCD_DevConnect(PCD_HandleTypeDef *hpcd)
    775          {
   \                     HAL_PCD_DevConnect: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    776            __HAL_LOCK(hpcd); 
   \   00000004   0xF894 0x037C      LDRB     R0,[R4, #+892]
   \   00000008   0x2801             CMP      R0,#+1
   \   0000000A   0xD101             BNE.N    ??HAL_PCD_DevConnect_0
   \   0000000C   0x2002             MOVS     R0,#+2
   \   0000000E   0xE009             B.N      ??HAL_PCD_DevConnect_1
   \                     ??HAL_PCD_DevConnect_0: (+1)
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0xF884 0x037C      STRB     R0,[R4, #+892]
    777            USB_DevConnect(hpcd->Instance);
   \   00000016   0x6820             LDR      R0,[R4, #+0]
   \   00000018   0x.... 0x....      BL       USB_DevConnect
    778            __HAL_UNLOCK(hpcd); 
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0xF884 0x037C      STRB     R0,[R4, #+892]
    779            return HAL_OK;
   \   00000022   0x2000             MOVS     R0,#+0
   \                     ??HAL_PCD_DevConnect_1: (+1)
   \   00000024   0xBD10             POP      {R4,PC}          ;; return
    780          }
    781          
    782          /**
    783            * @brief  Disconnect the USB device
    784            * @param  hpcd: PCD handle
    785            * @retval HAL status
    786            */

   \                                 In section .text, align 2, keep-with-next
    787          HAL_StatusTypeDef HAL_PCD_DevDisconnect(PCD_HandleTypeDef *hpcd)
    788          {
   \                     HAL_PCD_DevDisconnect: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    789            __HAL_LOCK(hpcd); 
   \   00000004   0xF894 0x037C      LDRB     R0,[R4, #+892]
   \   00000008   0x2801             CMP      R0,#+1
   \   0000000A   0xD101             BNE.N    ??HAL_PCD_DevDisconnect_0
   \   0000000C   0x2002             MOVS     R0,#+2
   \   0000000E   0xE009             B.N      ??HAL_PCD_DevDisconnect_1
   \                     ??HAL_PCD_DevDisconnect_0: (+1)
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0xF884 0x037C      STRB     R0,[R4, #+892]
    790            USB_DevDisconnect(hpcd->Instance);
   \   00000016   0x6820             LDR      R0,[R4, #+0]
   \   00000018   0x.... 0x....      BL       USB_DevDisconnect
    791            __HAL_UNLOCK(hpcd); 
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0xF884 0x037C      STRB     R0,[R4, #+892]
    792            return HAL_OK;
   \   00000022   0x2000             MOVS     R0,#+0
   \                     ??HAL_PCD_DevDisconnect_1: (+1)
   \   00000024   0xBD10             POP      {R4,PC}          ;; return
    793          }
    794          
    795          /**
    796            * @brief  Set the USB Device address 
    797            * @param  hpcd: PCD handle
    798            * @param  address: new device address
    799            * @retval HAL status
    800            */

   \                                 In section .text, align 2, keep-with-next
    801          HAL_StatusTypeDef HAL_PCD_SetAddress(PCD_HandleTypeDef *hpcd, uint8_t address)
    802          {
   \                     HAL_PCD_SetAddress: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    803            __HAL_LOCK(hpcd); 
   \   00000006   0xF894 0x037C      LDRB     R0,[R4, #+892]
   \   0000000A   0x2801             CMP      R0,#+1
   \   0000000C   0xD101             BNE.N    ??HAL_PCD_SetAddress_0
   \   0000000E   0x2002             MOVS     R0,#+2
   \   00000010   0xE00B             B.N      ??HAL_PCD_SetAddress_1
   \                     ??HAL_PCD_SetAddress_0: (+1)
   \   00000012   0x2001             MOVS     R0,#+1
   \   00000014   0xF884 0x037C      STRB     R0,[R4, #+892]
    804            USB_SetDevAddress(hpcd->Instance, address);
   \   00000018   0x0029             MOVS     R1,R5
   \   0000001A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000001C   0x6820             LDR      R0,[R4, #+0]
   \   0000001E   0x.... 0x....      BL       USB_SetDevAddress
    805            __HAL_UNLOCK(hpcd);   
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0xF884 0x037C      STRB     R0,[R4, #+892]
    806            return HAL_OK;
   \   00000028   0x2000             MOVS     R0,#+0
   \                     ??HAL_PCD_SetAddress_1: (+1)
   \   0000002A   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    807          }
    808          /**
    809            * @brief  Open and configure an endpoint
    810            * @param  hpcd: PCD handle
    811            * @param  ep_addr: endpoint address
    812            * @param  ep_mps: endpoint max packet size
    813            * @param  ep_type: endpoint type   
    814            * @retval HAL status
    815            */

   \                                 In section .text, align 2, keep-with-next
    816          HAL_StatusTypeDef HAL_PCD_EP_Open(PCD_HandleTypeDef *hpcd, uint8_t ep_addr, uint16_t ep_mps, uint8_t ep_type)
    817          {
   \                     HAL_PCD_EP_Open: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
    818            HAL_StatusTypeDef  ret = HAL_OK;
   \   0000000C   0xF05F 0x0800      MOVS     R8,#+0
    819            USB_OTG_EPTypeDef *ep;
    820            
    821            if ((ep_addr & 0x80) == 0x80)
   \   00000010   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000012   0x0628             LSLS     R0,R5,#+24
   \   00000014   0xD508             BPL.N    ??HAL_PCD_EP_Open_0
    822            {
    823              ep = &hpcd->IN_ep[ep_addr & 0x7F];
   \   00000016   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000018   0xF015 0x007F      ANDS     R0,R5,#0x7F
   \   0000001C   0x211C             MOVS     R1,#+28
   \   0000001E   0xFB01 0x4000      MLA      R0,R1,R0,R4
   \   00000022   0x3034             ADDS     R0,R0,#+52
   \   00000024   0x4681             MOV      R9,R0
   \   00000026   0xE008             B.N      ??HAL_PCD_EP_Open_1
    824            }
    825            else
    826            {
    827              ep = &hpcd->OUT_ep[ep_addr & 0x7F];
   \                     ??HAL_PCD_EP_Open_0: (+1)
   \   00000028   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000002A   0xF015 0x007F      ANDS     R0,R5,#0x7F
   \   0000002E   0x211C             MOVS     R1,#+28
   \   00000030   0xFB01 0x4000      MLA      R0,R1,R0,R4
   \   00000034   0xF510 0x70EC      ADDS     R0,R0,#+472
   \   00000038   0x4681             MOV      R9,R0
    828            }
    829            ep->num   = ep_addr & 0x7F;
   \                     ??HAL_PCD_EP_Open_1: (+1)
   \   0000003A   0xF015 0x007F      ANDS     R0,R5,#0x7F
   \   0000003E   0xF889 0x0000      STRB     R0,[R9, #+0]
    830            
    831            ep->is_in = (0x80 & ep_addr) != 0;
   \   00000042   0x0028             MOVS     R0,R5
   \   00000044   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000046   0x09C0             LSRS     R0,R0,#+7
   \   00000048   0xF889 0x0001      STRB     R0,[R9, #+1]
    832            ep->maxpacket = ep_mps;
   \   0000004C   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   0000004E   0xF8C9 0x6008      STR      R6,[R9, #+8]
    833            ep->type = ep_type;
   \   00000052   0xF889 0x7003      STRB     R7,[R9, #+3]
    834            if (ep->is_in)
   \   00000056   0xF899 0x0001      LDRB     R0,[R9, #+1]
   \   0000005A   0x2800             CMP      R0,#+0
   \   0000005C   0xD003             BEQ.N    ??HAL_PCD_EP_Open_2
    835            {
    836              /* Assign a Tx FIFO */
    837              ep->tx_fifo_num = ep->num;
   \   0000005E   0xF899 0x0000      LDRB     R0,[R9, #+0]
   \   00000062   0xF8A9 0x0006      STRH     R0,[R9, #+6]
    838            }
    839            /* Set initial data PID. */
    840            if (ep_type == EP_TYPE_BULK )
   \                     ??HAL_PCD_EP_Open_2: (+1)
   \   00000066   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000068   0x2F02             CMP      R7,#+2
   \   0000006A   0xD102             BNE.N    ??HAL_PCD_EP_Open_3
    841            {
    842              ep->data_pid_start = 0;
   \   0000006C   0x2000             MOVS     R0,#+0
   \   0000006E   0xF889 0x0004      STRB     R0,[R9, #+4]
    843            }
    844            
    845            __HAL_LOCK(hpcd); 
   \                     ??HAL_PCD_EP_Open_3: (+1)
   \   00000072   0xF894 0x037C      LDRB     R0,[R4, #+892]
   \   00000076   0x2801             CMP      R0,#+1
   \   00000078   0xD101             BNE.N    ??HAL_PCD_EP_Open_4
   \   0000007A   0x2002             MOVS     R0,#+2
   \   0000007C   0xE00B             B.N      ??HAL_PCD_EP_Open_5
   \                     ??HAL_PCD_EP_Open_4: (+1)
   \   0000007E   0x2001             MOVS     R0,#+1
   \   00000080   0xF884 0x037C      STRB     R0,[R4, #+892]
    846            USB_ActivateEndpoint(hpcd->Instance , ep);
   \   00000084   0x4649             MOV      R1,R9
   \   00000086   0x6820             LDR      R0,[R4, #+0]
   \   00000088   0x.... 0x....      BL       USB_ActivateEndpoint
    847            __HAL_UNLOCK(hpcd);   
   \   0000008C   0x2000             MOVS     R0,#+0
   \   0000008E   0xF884 0x037C      STRB     R0,[R4, #+892]
    848            return ret;
   \   00000092   0x4640             MOV      R0,R8
   \   00000094   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??HAL_PCD_EP_Open_5: (+1)
   \   00000096   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    849          }
    850          
    851          
    852          /**
    853            * @brief  Deactivate an endpoint
    854            * @param  hpcd: PCD handle
    855            * @param  ep_addr: endpoint address
    856            * @retval HAL status
    857            */

   \                                 In section .text, align 2, keep-with-next
    858          HAL_StatusTypeDef HAL_PCD_EP_Close(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)
    859          {  
   \                     HAL_PCD_EP_Close: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    860            USB_OTG_EPTypeDef *ep;
    861            
    862            if ((ep_addr & 0x80) == 0x80)
   \   00000006   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000008   0x0628             LSLS     R0,R5,#+24
   \   0000000A   0xD508             BPL.N    ??HAL_PCD_EP_Close_0
    863            {
    864              ep = &hpcd->IN_ep[ep_addr & 0x7F];
   \   0000000C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000000E   0xF015 0x007F      ANDS     R0,R5,#0x7F
   \   00000012   0x211C             MOVS     R1,#+28
   \   00000014   0xFB01 0x4000      MLA      R0,R1,R0,R4
   \   00000018   0x3034             ADDS     R0,R0,#+52
   \   0000001A   0x0006             MOVS     R6,R0
   \   0000001C   0xE008             B.N      ??HAL_PCD_EP_Close_1
    865            }
    866            else
    867            {
    868              ep = &hpcd->OUT_ep[ep_addr & 0x7F];
   \                     ??HAL_PCD_EP_Close_0: (+1)
   \   0000001E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000020   0xF015 0x007F      ANDS     R0,R5,#0x7F
   \   00000024   0x211C             MOVS     R1,#+28
   \   00000026   0xFB01 0x4000      MLA      R0,R1,R0,R4
   \   0000002A   0xF510 0x70EC      ADDS     R0,R0,#+472
   \   0000002E   0x0006             MOVS     R6,R0
    869            }
    870            ep->num   = ep_addr & 0x7F;
   \                     ??HAL_PCD_EP_Close_1: (+1)
   \   00000030   0xF015 0x007F      ANDS     R0,R5,#0x7F
   \   00000034   0x7030             STRB     R0,[R6, #+0]
    871            
    872            ep->is_in = (0x80 & ep_addr) != 0;
   \   00000036   0x0028             MOVS     R0,R5
   \   00000038   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000003A   0x09C0             LSRS     R0,R0,#+7
   \   0000003C   0x7070             STRB     R0,[R6, #+1]
    873            
    874            __HAL_LOCK(hpcd); 
   \   0000003E   0xF894 0x037C      LDRB     R0,[R4, #+892]
   \   00000042   0x2801             CMP      R0,#+1
   \   00000044   0xD101             BNE.N    ??HAL_PCD_EP_Close_2
   \   00000046   0x2002             MOVS     R0,#+2
   \   00000048   0xE00A             B.N      ??HAL_PCD_EP_Close_3
   \                     ??HAL_PCD_EP_Close_2: (+1)
   \   0000004A   0x2001             MOVS     R0,#+1
   \   0000004C   0xF884 0x037C      STRB     R0,[R4, #+892]
    875            USB_DeactivateEndpoint(hpcd->Instance , ep);
   \   00000050   0x0031             MOVS     R1,R6
   \   00000052   0x6820             LDR      R0,[R4, #+0]
   \   00000054   0x.... 0x....      BL       USB_DeactivateEndpoint
    876            __HAL_UNLOCK(hpcd);   
   \   00000058   0x2000             MOVS     R0,#+0
   \   0000005A   0xF884 0x037C      STRB     R0,[R4, #+892]
    877            return HAL_OK;
   \   0000005E   0x2000             MOVS     R0,#+0
   \                     ??HAL_PCD_EP_Close_3: (+1)
   \   00000060   0xBD70             POP      {R4-R6,PC}       ;; return
    878          }
    879          
    880          
    881          /**
    882            * @brief  Receive an amount of data  
    883            * @param  hpcd: PCD handle
    884            * @param  ep_addr: endpoint address
    885            * @param  pBuf: pointer to the reception buffer   
    886            * @param  len: amount of data to be received
    887            * @retval HAL status
    888            */

   \                                 In section .text, align 2, keep-with-next
    889          HAL_StatusTypeDef HAL_PCD_EP_Receive(PCD_HandleTypeDef *hpcd, uint8_t ep_addr, uint8_t *pBuf, uint32_t len)
    890          {
   \                     HAL_PCD_EP_Receive: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
    891            USB_OTG_EPTypeDef *ep;
    892            
    893            ep = &hpcd->OUT_ep[ep_addr & 0x7F];
   \   0000000C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000000E   0xF015 0x007F      ANDS     R0,R5,#0x7F
   \   00000012   0x211C             MOVS     R1,#+28
   \   00000014   0xFB01 0x4000      MLA      R0,R1,R0,R4
   \   00000018   0xF510 0x70EC      ADDS     R0,R0,#+472
   \   0000001C   0x4680             MOV      R8,R0
    894            
    895            /*setup and start the Xfer */
    896            ep->xfer_buff = pBuf;  
   \   0000001E   0xF8C8 0x600C      STR      R6,[R8, #+12]
    897            ep->xfer_len = len;
   \   00000022   0xF8C8 0x7014      STR      R7,[R8, #+20]
    898            ep->xfer_count = 0;
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0xF8C8 0x0018      STR      R0,[R8, #+24]
    899            ep->is_in = 0;
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0xF888 0x0001      STRB     R0,[R8, #+1]
    900            ep->num = ep_addr & 0x7F;
   \   00000032   0xF015 0x007F      ANDS     R0,R5,#0x7F
   \   00000036   0xF888 0x0000      STRB     R0,[R8, #+0]
    901            
    902            if (hpcd->Init.dma_enable == 1)
   \   0000003A   0x6920             LDR      R0,[R4, #+16]
   \   0000003C   0x2801             CMP      R0,#+1
   \   0000003E   0xD101             BNE.N    ??HAL_PCD_EP_Receive_0
    903            {
    904              ep->dma_addr = (uint32_t)pBuf;  
   \   00000040   0xF8C8 0x6010      STR      R6,[R8, #+16]
    905            }
    906            
    907            __HAL_LOCK(hpcd); 
   \                     ??HAL_PCD_EP_Receive_0: (+1)
   \   00000044   0xF894 0x037C      LDRB     R0,[R4, #+892]
   \   00000048   0x2801             CMP      R0,#+1
   \   0000004A   0xD101             BNE.N    ??HAL_PCD_EP_Receive_1
   \   0000004C   0x2002             MOVS     R0,#+2
   \   0000004E   0xE016             B.N      ??HAL_PCD_EP_Receive_2
   \                     ??HAL_PCD_EP_Receive_1: (+1)
   \   00000050   0x2001             MOVS     R0,#+1
   \   00000052   0xF884 0x037C      STRB     R0,[R4, #+892]
    908            
    909            if ((ep_addr & 0x7F) == 0 )
   \   00000056   0x207F             MOVS     R0,#+127
   \   00000058   0x4205             TST      R5,R0
   \   0000005A   0xD106             BNE.N    ??HAL_PCD_EP_Receive_3
    910            {
    911              USB_EP0StartXfer(hpcd->Instance , ep, hpcd->Init.dma_enable);
   \   0000005C   0x6922             LDR      R2,[R4, #+16]
   \   0000005E   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000060   0x4641             MOV      R1,R8
   \   00000062   0x6820             LDR      R0,[R4, #+0]
   \   00000064   0x.... 0x....      BL       USB_EP0StartXfer
   \   00000068   0xE005             B.N      ??HAL_PCD_EP_Receive_4
    912            }
    913            else
    914            {
    915              USB_EPStartXfer(hpcd->Instance , ep, hpcd->Init.dma_enable);
   \                     ??HAL_PCD_EP_Receive_3: (+1)
   \   0000006A   0x6922             LDR      R2,[R4, #+16]
   \   0000006C   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000006E   0x4641             MOV      R1,R8
   \   00000070   0x6820             LDR      R0,[R4, #+0]
   \   00000072   0x.... 0x....      BL       USB_EPStartXfer
    916            }
    917            __HAL_UNLOCK(hpcd); 
   \                     ??HAL_PCD_EP_Receive_4: (+1)
   \   00000076   0x2000             MOVS     R0,#+0
   \   00000078   0xF884 0x037C      STRB     R0,[R4, #+892]
    918            
    919            return HAL_OK;
   \   0000007C   0x2000             MOVS     R0,#+0
   \                     ??HAL_PCD_EP_Receive_2: (+1)
   \   0000007E   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    920          }
    921          
    922          /**
    923            * @brief  Get Received Data Size
    924            * @param  hpcd: PCD handle
    925            * @param  ep_addr: endpoint address
    926            * @retval Data Size
    927            */

   \                                 In section .text, align 2, keep-with-next
    928          uint16_t HAL_PCD_EP_GetRxCount(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)
    929          {
    930            return hpcd->OUT_ep[ep_addr & 0x7F].xfer_count;
   \                     HAL_PCD_EP_GetRxCount: (+1)
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0xF011 0x017F      ANDS     R1,R1,#0x7F
   \   00000006   0x221C             MOVS     R2,#+28
   \   00000008   0xFB02 0x0001      MLA      R0,R2,R1,R0
   \   0000000C   0xF8D0 0x01F0      LDR      R0,[R0, #+496]
   \   00000010   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000012   0x4770             BX       LR               ;; return
    931          }
    932          /**
    933            * @brief  Send an amount of data  
    934            * @param  hpcd: PCD handle
    935            * @param  ep_addr: endpoint address
    936            * @param  pBuf: pointer to the transmission buffer   
    937            * @param  len: amount of data to be sent
    938            * @retval HAL status
    939            */

   \                                 In section .text, align 2, keep-with-next
    940          HAL_StatusTypeDef HAL_PCD_EP_Transmit(PCD_HandleTypeDef *hpcd, uint8_t ep_addr, uint8_t *pBuf, uint32_t len)
    941          {
   \                     HAL_PCD_EP_Transmit: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
    942            USB_OTG_EPTypeDef *ep;
    943            
    944            ep = &hpcd->IN_ep[ep_addr & 0x7F];
   \   0000000C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000000E   0xF015 0x007F      ANDS     R0,R5,#0x7F
   \   00000012   0x211C             MOVS     R1,#+28
   \   00000014   0xFB01 0x4000      MLA      R0,R1,R0,R4
   \   00000018   0x3034             ADDS     R0,R0,#+52
   \   0000001A   0x4680             MOV      R8,R0
    945            
    946            /*setup and start the Xfer */
    947            ep->xfer_buff = pBuf;  
   \   0000001C   0xF8C8 0x600C      STR      R6,[R8, #+12]
    948            ep->xfer_len = len;
   \   00000020   0xF8C8 0x7014      STR      R7,[R8, #+20]
    949            ep->xfer_count = 0;
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0xF8C8 0x0018      STR      R0,[R8, #+24]
    950            ep->is_in = 1;
   \   0000002A   0x2001             MOVS     R0,#+1
   \   0000002C   0xF888 0x0001      STRB     R0,[R8, #+1]
    951            ep->num = ep_addr & 0x7F;
   \   00000030   0xF015 0x007F      ANDS     R0,R5,#0x7F
   \   00000034   0xF888 0x0000      STRB     R0,[R8, #+0]
    952            
    953            if (hpcd->Init.dma_enable == 1)
   \   00000038   0x6920             LDR      R0,[R4, #+16]
   \   0000003A   0x2801             CMP      R0,#+1
   \   0000003C   0xD101             BNE.N    ??HAL_PCD_EP_Transmit_0
    954            {
    955              ep->dma_addr = (uint32_t)pBuf;  
   \   0000003E   0xF8C8 0x6010      STR      R6,[R8, #+16]
    956            }
    957            
    958            __HAL_LOCK(hpcd); 
   \                     ??HAL_PCD_EP_Transmit_0: (+1)
   \   00000042   0xF894 0x037C      LDRB     R0,[R4, #+892]
   \   00000046   0x2801             CMP      R0,#+1
   \   00000048   0xD101             BNE.N    ??HAL_PCD_EP_Transmit_1
   \   0000004A   0x2002             MOVS     R0,#+2
   \   0000004C   0xE016             B.N      ??HAL_PCD_EP_Transmit_2
   \                     ??HAL_PCD_EP_Transmit_1: (+1)
   \   0000004E   0x2001             MOVS     R0,#+1
   \   00000050   0xF884 0x037C      STRB     R0,[R4, #+892]
    959            
    960            if ((ep_addr & 0x7F) == 0 )
   \   00000054   0x207F             MOVS     R0,#+127
   \   00000056   0x4205             TST      R5,R0
   \   00000058   0xD106             BNE.N    ??HAL_PCD_EP_Transmit_3
    961            {
    962              USB_EP0StartXfer(hpcd->Instance , ep, hpcd->Init.dma_enable);
   \   0000005A   0x6922             LDR      R2,[R4, #+16]
   \   0000005C   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000005E   0x4641             MOV      R1,R8
   \   00000060   0x6820             LDR      R0,[R4, #+0]
   \   00000062   0x.... 0x....      BL       USB_EP0StartXfer
   \   00000066   0xE005             B.N      ??HAL_PCD_EP_Transmit_4
    963            }
    964            else
    965            {
    966              USB_EPStartXfer(hpcd->Instance , ep, hpcd->Init.dma_enable);
   \                     ??HAL_PCD_EP_Transmit_3: (+1)
   \   00000068   0x6922             LDR      R2,[R4, #+16]
   \   0000006A   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000006C   0x4641             MOV      R1,R8
   \   0000006E   0x6820             LDR      R0,[R4, #+0]
   \   00000070   0x.... 0x....      BL       USB_EPStartXfer
    967            }
    968            
    969            __HAL_UNLOCK(hpcd);
   \                     ??HAL_PCD_EP_Transmit_4: (+1)
   \   00000074   0x2000             MOVS     R0,#+0
   \   00000076   0xF884 0x037C      STRB     R0,[R4, #+892]
    970               
    971            return HAL_OK;
   \   0000007A   0x2000             MOVS     R0,#+0
   \                     ??HAL_PCD_EP_Transmit_2: (+1)
   \   0000007C   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    972          }
    973          
    974          /**
    975            * @brief  Set a STALL condition over an endpoint
    976            * @param  hpcd: PCD handle
    977            * @param  ep_addr: endpoint address
    978            * @retval HAL status
    979            */

   \                                 In section .text, align 2, keep-with-next
    980          HAL_StatusTypeDef HAL_PCD_EP_SetStall(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)
    981          {
   \                     HAL_PCD_EP_SetStall: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    982            USB_OTG_EPTypeDef *ep;
    983            
    984            if ((0x80 & ep_addr) == 0x80)
   \   00000006   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000008   0x0628             LSLS     R0,R5,#+24
   \   0000000A   0xD508             BPL.N    ??HAL_PCD_EP_SetStall_0
    985            {
    986              ep = &hpcd->IN_ep[ep_addr & 0x7F];
   \   0000000C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000000E   0xF015 0x007F      ANDS     R0,R5,#0x7F
   \   00000012   0x211C             MOVS     R1,#+28
   \   00000014   0xFB01 0x4000      MLA      R0,R1,R0,R4
   \   00000018   0x3034             ADDS     R0,R0,#+52
   \   0000001A   0x0006             MOVS     R6,R0
   \   0000001C   0xE006             B.N      ??HAL_PCD_EP_SetStall_1
    987            }
    988            else
    989            {
    990              ep = &hpcd->OUT_ep[ep_addr];
   \                     ??HAL_PCD_EP_SetStall_0: (+1)
   \   0000001E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000020   0x201C             MOVS     R0,#+28
   \   00000022   0xFB00 0x4005      MLA      R0,R0,R5,R4
   \   00000026   0xF510 0x70EC      ADDS     R0,R0,#+472
   \   0000002A   0x0006             MOVS     R6,R0
    991            }
    992            
    993            ep->is_stall = 1;
   \                     ??HAL_PCD_EP_SetStall_1: (+1)
   \   0000002C   0x2001             MOVS     R0,#+1
   \   0000002E   0x70B0             STRB     R0,[R6, #+2]
    994            ep->num   = ep_addr & 0x7F;
   \   00000030   0xF015 0x007F      ANDS     R0,R5,#0x7F
   \   00000034   0x7030             STRB     R0,[R6, #+0]
    995            ep->is_in = ((ep_addr & 0x80) == 0x80);
   \   00000036   0x0028             MOVS     R0,R5
   \   00000038   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000003A   0x09C0             LSRS     R0,R0,#+7
   \   0000003C   0x7070             STRB     R0,[R6, #+1]
    996            
    997            
    998            __HAL_LOCK(hpcd); 
   \   0000003E   0xF894 0x037C      LDRB     R0,[R4, #+892]
   \   00000042   0x2801             CMP      R0,#+1
   \   00000044   0xD101             BNE.N    ??HAL_PCD_EP_SetStall_2
   \   00000046   0x2002             MOVS     R0,#+2
   \   00000048   0xE014             B.N      ??HAL_PCD_EP_SetStall_3
   \                     ??HAL_PCD_EP_SetStall_2: (+1)
   \   0000004A   0x2001             MOVS     R0,#+1
   \   0000004C   0xF884 0x037C      STRB     R0,[R4, #+892]
    999            USB_EPSetStall(hpcd->Instance , ep);
   \   00000050   0x0031             MOVS     R1,R6
   \   00000052   0x6820             LDR      R0,[R4, #+0]
   \   00000054   0x.... 0x....      BL       USB_EPSetStall
   1000            if((ep_addr & 0x7F) == 0)
   \   00000058   0x207F             MOVS     R0,#+127
   \   0000005A   0x4205             TST      R5,R0
   \   0000005C   0xD106             BNE.N    ??HAL_PCD_EP_SetStall_4
   1001            {
   1002              USB_EP0_OutStart(hpcd->Instance, hpcd->Init.dma_enable, (uint8_t *)hpcd->Setup);
   \   0000005E   0xF514 0x7260      ADDS     R2,R4,#+896
   \   00000062   0x6921             LDR      R1,[R4, #+16]
   \   00000064   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000066   0x6820             LDR      R0,[R4, #+0]
   \   00000068   0x.... 0x....      BL       USB_EP0_OutStart
   1003            }
   1004            __HAL_UNLOCK(hpcd); 
   \                     ??HAL_PCD_EP_SetStall_4: (+1)
   \   0000006C   0x2000             MOVS     R0,#+0
   \   0000006E   0xF884 0x037C      STRB     R0,[R4, #+892]
   1005            
   1006            return HAL_OK;
   \   00000072   0x2000             MOVS     R0,#+0
   \                     ??HAL_PCD_EP_SetStall_3: (+1)
   \   00000074   0xBD70             POP      {R4-R6,PC}       ;; return
   1007          }
   1008          
   1009          /**
   1010            * @brief  Clear a STALL condition over in an endpoint
   1011            * @param  hpcd: PCD handle
   1012            * @param  ep_addr: endpoint address
   1013            * @retval HAL status
   1014            */

   \                                 In section .text, align 2, keep-with-next
   1015          HAL_StatusTypeDef HAL_PCD_EP_ClrStall(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)
   1016          {
   \                     HAL_PCD_EP_ClrStall: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1017            USB_OTG_EPTypeDef *ep;
   1018            
   1019            if ((0x80 & ep_addr) == 0x80)
   \   00000006   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000008   0x0628             LSLS     R0,R5,#+24
   \   0000000A   0xD508             BPL.N    ??HAL_PCD_EP_ClrStall_0
   1020            {
   1021              ep = &hpcd->IN_ep[ep_addr & 0x7F];
   \   0000000C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000000E   0xF015 0x007F      ANDS     R0,R5,#0x7F
   \   00000012   0x211C             MOVS     R1,#+28
   \   00000014   0xFB01 0x4000      MLA      R0,R1,R0,R4
   \   00000018   0x3034             ADDS     R0,R0,#+52
   \   0000001A   0x0006             MOVS     R6,R0
   \   0000001C   0xE006             B.N      ??HAL_PCD_EP_ClrStall_1
   1022            }
   1023            else
   1024            {
   1025              ep = &hpcd->OUT_ep[ep_addr];
   \                     ??HAL_PCD_EP_ClrStall_0: (+1)
   \   0000001E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000020   0x201C             MOVS     R0,#+28
   \   00000022   0xFB00 0x4005      MLA      R0,R0,R5,R4
   \   00000026   0xF510 0x70EC      ADDS     R0,R0,#+472
   \   0000002A   0x0006             MOVS     R6,R0
   1026            }
   1027            
   1028            ep->is_stall = 0;
   \                     ??HAL_PCD_EP_ClrStall_1: (+1)
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0x70B0             STRB     R0,[R6, #+2]
   1029            ep->num   = ep_addr & 0x7F;
   \   00000030   0xF015 0x007F      ANDS     R0,R5,#0x7F
   \   00000034   0x7030             STRB     R0,[R6, #+0]
   1030            ep->is_in = ((ep_addr & 0x80) == 0x80);
   \   00000036   0x0028             MOVS     R0,R5
   \   00000038   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000003A   0x09C0             LSRS     R0,R0,#+7
   \   0000003C   0x7070             STRB     R0,[R6, #+1]
   1031            
   1032            __HAL_LOCK(hpcd); 
   \   0000003E   0xF894 0x037C      LDRB     R0,[R4, #+892]
   \   00000042   0x2801             CMP      R0,#+1
   \   00000044   0xD101             BNE.N    ??HAL_PCD_EP_ClrStall_2
   \   00000046   0x2002             MOVS     R0,#+2
   \   00000048   0xE00A             B.N      ??HAL_PCD_EP_ClrStall_3
   \                     ??HAL_PCD_EP_ClrStall_2: (+1)
   \   0000004A   0x2001             MOVS     R0,#+1
   \   0000004C   0xF884 0x037C      STRB     R0,[R4, #+892]
   1033            USB_EPClearStall(hpcd->Instance , ep);
   \   00000050   0x0031             MOVS     R1,R6
   \   00000052   0x6820             LDR      R0,[R4, #+0]
   \   00000054   0x.... 0x....      BL       USB_EPClearStall
   1034            __HAL_UNLOCK(hpcd); 
   \   00000058   0x2000             MOVS     R0,#+0
   \   0000005A   0xF884 0x037C      STRB     R0,[R4, #+892]
   1035              
   1036            return HAL_OK;
   \   0000005E   0x2000             MOVS     R0,#+0
   \                     ??HAL_PCD_EP_ClrStall_3: (+1)
   \   00000060   0xBD70             POP      {R4-R6,PC}       ;; return
   1037          }
   1038          
   1039          /**
   1040            * @brief  Flush an endpoint
   1041            * @param  hpcd: PCD handle
   1042            * @param  ep_addr: endpoint address
   1043            * @retval HAL status
   1044            */

   \                                 In section .text, align 2, keep-with-next
   1045          HAL_StatusTypeDef HAL_PCD_EP_Flush(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)
   1046          {
   \                     HAL_PCD_EP_Flush: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1047            __HAL_LOCK(hpcd); 
   \   00000006   0xF894 0x037C      LDRB     R0,[R4, #+892]
   \   0000000A   0x2801             CMP      R0,#+1
   \   0000000C   0xD101             BNE.N    ??HAL_PCD_EP_Flush_0
   \   0000000E   0x2002             MOVS     R0,#+2
   \   00000010   0xE013             B.N      ??HAL_PCD_EP_Flush_1
   \                     ??HAL_PCD_EP_Flush_0: (+1)
   \   00000012   0x2001             MOVS     R0,#+1
   \   00000014   0xF884 0x037C      STRB     R0,[R4, #+892]
   1048            
   1049            if ((ep_addr & 0x80) == 0x80)
   \   00000018   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000001A   0x0628             LSLS     R0,R5,#+24
   \   0000001C   0xD506             BPL.N    ??HAL_PCD_EP_Flush_2
   1050            {
   1051              USB_FlushTxFifo(hpcd->Instance, ep_addr & 0x7F);
   \   0000001E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000020   0xF015 0x017F      ANDS     R1,R5,#0x7F
   \   00000024   0x6820             LDR      R0,[R4, #+0]
   \   00000026   0x.... 0x....      BL       USB_FlushTxFifo
   \   0000002A   0xE002             B.N      ??HAL_PCD_EP_Flush_3
   1052            }
   1053            else
   1054            {
   1055              USB_FlushRxFifo(hpcd->Instance);
   \                     ??HAL_PCD_EP_Flush_2: (+1)
   \   0000002C   0x6820             LDR      R0,[R4, #+0]
   \   0000002E   0x.... 0x....      BL       USB_FlushRxFifo
   1056            }
   1057            
   1058            __HAL_UNLOCK(hpcd); 
   \                     ??HAL_PCD_EP_Flush_3: (+1)
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0xF884 0x037C      STRB     R0,[R4, #+892]
   1059              
   1060            return HAL_OK;
   \   00000038   0x2000             MOVS     R0,#+0
   \                     ??HAL_PCD_EP_Flush_1: (+1)
   \   0000003A   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1061          }
   1062          
   1063          /**
   1064            * @brief  HAL_PCD_ActivateRemoteWakeup : Active remote wake-up signalling
   1065            * @param  hpcd: PCD handle
   1066            * @retval HAL status
   1067            */

   \                                 In section .text, align 2, keep-with-next
   1068          HAL_StatusTypeDef HAL_PCD_ActivateRemoteWakeup(PCD_HandleTypeDef *hpcd)
   1069          {
   \                     HAL_PCD_ActivateRemoteWakeup: (+1)
   \   00000000   0x0001             MOVS     R1,R0
   1070            USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;  
   \   00000002   0x680A             LDR      R2,[R1, #+0]
   1071              
   1072            if((USBx_DEVICE->DSTS & USB_OTG_DSTS_SUSPSTS) == USB_OTG_DSTS_SUSPSTS)
   \   00000004   0xF512 0x6000      ADDS     R0,R2,#+2048
   \   00000008   0x6880             LDR      R0,[R0, #+8]
   \   0000000A   0x07C0             LSLS     R0,R0,#+31
   \   0000000C   0xD507             BPL.N    ??HAL_PCD_ActivateRemoteWakeup_0
   1073            {
   1074              /* Activate Remote wake-up signaling */
   1075              USBx_DEVICE->DCTL |= USB_OTG_DCTL_RWUSIG;
   \   0000000E   0xF512 0x6000      ADDS     R0,R2,#+2048
   \   00000012   0x6840             LDR      R0,[R0, #+4]
   \   00000014   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000018   0xF512 0x6300      ADDS     R3,R2,#+2048
   \   0000001C   0x6058             STR      R0,[R3, #+4]
   1076            }
   1077            return HAL_OK;  
   \                     ??HAL_PCD_ActivateRemoteWakeup_0: (+1)
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0x4770             BX       LR               ;; return
   1078          }
   1079          
   1080          /**
   1081            * @brief  HAL_PCD_DeActivateRemoteWakeup : de-active remote wake-up signalling
   1082            * @param  hpcd: PCD handle
   1083            * @retval HAL status
   1084            */

   \                                 In section .text, align 2, keep-with-next
   1085          HAL_StatusTypeDef HAL_PCD_DeActivateRemoteWakeup(PCD_HandleTypeDef *hpcd)
   1086          {
   \                     HAL_PCD_DeActivateRemoteWakeup: (+1)
   \   00000000   0x0001             MOVS     R1,R0
   1087            USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;  
   \   00000002   0x680A             LDR      R2,[R1, #+0]
   1088            
   1089            /* De-activate Remote wake-up signaling */
   1090             USBx_DEVICE->DCTL &= ~(USB_OTG_DCTL_RWUSIG);
   \   00000004   0xF512 0x6000      ADDS     R0,R2,#+2048
   \   00000008   0x6840             LDR      R0,[R0, #+4]
   \   0000000A   0x0840             LSRS     R0,R0,#+1
   \   0000000C   0x0040             LSLS     R0,R0,#+1
   \   0000000E   0xF512 0x6300      ADDS     R3,R2,#+2048
   \   00000012   0x6058             STR      R0,[R3, #+4]
   1091            return HAL_OK;  
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0x4770             BX       LR               ;; return
   1092          }
   1093          /**
   1094            * @}
   1095            */
   1096            
   1097          /** @defgroup PCD_Exported_Functions_Group4 Peripheral State functions 
   1098           *  @brief   Peripheral State functions 
   1099           *
   1100          @verbatim   
   1101           ===============================================================================
   1102                                ##### Peripheral State functions #####
   1103           ===============================================================================  
   1104              [..]
   1105              This subsection permits to get in run-time the status of the peripheral 
   1106              and the data flow.
   1107          
   1108          @endverbatim
   1109            * @{
   1110            */
   1111          
   1112          /**
   1113            * @brief  Return the PCD state
   1114            * @param  hpcd: PCD handle
   1115            * @retval HAL state
   1116            */

   \                                 In section .text, align 2, keep-with-next
   1117          PCD_StateTypeDef HAL_PCD_GetState(PCD_HandleTypeDef *hpcd)
   1118          {
   1119            return hpcd->State;
   \                     HAL_PCD_GetState: (+1)
   \   00000000   0xF890 0x037D      LDRB     R0,[R0, #+893]
   \   00000004   0x4770             BX       LR               ;; return
   1120          }
   1121          /**
   1122            * @}
   1123            */
   1124          
   1125          /**
   1126            * @}
   1127            */
   1128          
   1129          /* Private functions ---------------------------------------------------------*/
   1130          /** @addtogroup PCD_Private_Functions
   1131            * @{
   1132            */
   1133          
   1134          /**
   1135            * @brief  DCD_WriteEmptyTxFifo
   1136            *         check FIFO for the next packet to be loaded
   1137            * @param  hpcd: PCD handle
   1138            * @param  epnum : endpoint number   
   1139            * @retval HAL status
   1140            */

   \                                 In section .text, align 2, keep-with-next
   1141          static HAL_StatusTypeDef PCD_WriteEmptyTxFifo(PCD_HandleTypeDef *hpcd, uint32_t epnum)
   1142          {
   \                     PCD_WriteEmptyTxFifo: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0xB082             SUB      SP,SP,#+8
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
   1143            USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;  
   \   0000000A   0x6826             LDR      R6,[R4, #+0]
   1144            USB_OTG_EPTypeDef *ep;
   1145            int32_t len = 0;
   \   0000000C   0xF05F 0x0800      MOVS     R8,#+0
   1146            uint32_t len32b;
   1147            uint32_t fifoemptymsk = 0;
   \   00000010   0xF05F 0x0A00      MOVS     R10,#+0
   1148          
   1149            ep = &hpcd->IN_ep[epnum];
   \   00000014   0x201C             MOVS     R0,#+28
   \   00000016   0xFB00 0x4005      MLA      R0,R0,R5,R4
   \   0000001A   0x3034             ADDS     R0,R0,#+52
   \   0000001C   0x0007             MOVS     R7,R0
   1150            len = ep->xfer_len - ep->xfer_count;
   \   0000001E   0x6978             LDR      R0,[R7, #+20]
   \   00000020   0x69B9             LDR      R1,[R7, #+24]
   \   00000022   0x1A40             SUBS     R0,R0,R1
   \   00000024   0x4680             MOV      R8,R0
   1151            
   1152            if (len > ep->maxpacket)
   \   00000026   0x68B8             LDR      R0,[R7, #+8]
   \   00000028   0x4540             CMP      R0,R8
   \   0000002A   0xD201             BCS.N    ??PCD_WriteEmptyTxFifo_0
   1153            {
   1154              len = ep->maxpacket;
   \   0000002C   0x68B8             LDR      R0,[R7, #+8]
   \   0000002E   0x4680             MOV      R8,R0
   1155            }
   1156            
   1157            
   1158            len32b = (len + 3) / 4;
   \                     ??PCD_WriteEmptyTxFifo_0: (+1)
   \   00000030   0xF118 0x0003      ADDS     R0,R8,#+3
   \   00000034   0x2104             MOVS     R1,#+4
   \   00000036   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \   0000003A   0x4681             MOV      R9,R0
   1159           
   1160            while  ( (USBx_INEP(epnum)->DTXFSTS & USB_OTG_DTXFSTS_INEPTFSAV) > len32b &&
   1161                    ep->xfer_count < ep->xfer_len &&
   1162                      ep->xfer_len != 0)
   \                     ??PCD_WriteEmptyTxFifo_1: (+1)
   \   0000003C   0xEB16 0x1045      ADDS     R0,R6,R5, LSL #+5
   \   00000040   0xF510 0x6010      ADDS     R0,R0,#+2304
   \   00000044   0x6980             LDR      R0,[R0, #+24]
   \   00000046   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000048   0x4581             CMP      R9,R0
   \   0000004A   0xD22A             BCS.N    ??PCD_WriteEmptyTxFifo_2
   \   0000004C   0x69B8             LDR      R0,[R7, #+24]
   \   0000004E   0x6979             LDR      R1,[R7, #+20]
   \   00000050   0x4288             CMP      R0,R1
   \   00000052   0xD226             BCS.N    ??PCD_WriteEmptyTxFifo_2
   \   00000054   0x6978             LDR      R0,[R7, #+20]
   \   00000056   0x2800             CMP      R0,#+0
   \   00000058   0xD023             BEQ.N    ??PCD_WriteEmptyTxFifo_2
   1163            {
   1164              /* Write the FIFO */
   1165              len = ep->xfer_len - ep->xfer_count;
   \   0000005A   0x6978             LDR      R0,[R7, #+20]
   \   0000005C   0x69B9             LDR      R1,[R7, #+24]
   \   0000005E   0x1A40             SUBS     R0,R0,R1
   \   00000060   0x4680             MOV      R8,R0
   1166              
   1167              if (len > ep->maxpacket)
   \   00000062   0x68B8             LDR      R0,[R7, #+8]
   \   00000064   0x4540             CMP      R0,R8
   \   00000066   0xD201             BCS.N    ??PCD_WriteEmptyTxFifo_3
   1168              {
   1169                len = ep->maxpacket;
   \   00000068   0x68B8             LDR      R0,[R7, #+8]
   \   0000006A   0x4680             MOV      R8,R0
   1170              }
   1171              len32b = (len + 3) / 4;
   \                     ??PCD_WriteEmptyTxFifo_3: (+1)
   \   0000006C   0xF118 0x0003      ADDS     R0,R8,#+3
   \   00000070   0x2104             MOVS     R1,#+4
   \   00000072   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \   00000076   0x4681             MOV      R9,R0
   1172              
   1173              USB_WritePacket(USBx, ep->xfer_buff, epnum, len, hpcd->Init.dma_enable); 
   \   00000078   0x6920             LDR      R0,[R4, #+16]
   \   0000007A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000007C   0x9000             STR      R0,[SP, #+0]
   \   0000007E   0x4640             MOV      R0,R8
   \   00000080   0x0003             MOVS     R3,R0
   \   00000082   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   00000084   0x002A             MOVS     R2,R5
   \   00000086   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000088   0x68F9             LDR      R1,[R7, #+12]
   \   0000008A   0x0030             MOVS     R0,R6
   \   0000008C   0x.... 0x....      BL       USB_WritePacket
   1174              
   1175              ep->xfer_buff  += len;
   \   00000090   0x68F8             LDR      R0,[R7, #+12]
   \   00000092   0xEB18 0x0000      ADDS     R0,R8,R0
   \   00000096   0x60F8             STR      R0,[R7, #+12]
   1176              ep->xfer_count += len;
   \   00000098   0x69B8             LDR      R0,[R7, #+24]
   \   0000009A   0xEB18 0x0000      ADDS     R0,R8,R0
   \   0000009E   0x61B8             STR      R0,[R7, #+24]
   \   000000A0   0xE7CC             B.N      ??PCD_WriteEmptyTxFifo_1
   1177            }
   1178            
   1179            if(len <= 0)
   \                     ??PCD_WriteEmptyTxFifo_2: (+1)
   \   000000A2   0xF1B8 0x0F01      CMP      R8,#+1
   \   000000A6   0xDA0A             BGE.N    ??PCD_WriteEmptyTxFifo_4
   1180            {
   1181              fifoemptymsk = 0x1 << epnum;
   \   000000A8   0x2001             MOVS     R0,#+1
   \   000000AA   0x40A8             LSLS     R0,R0,R5
   \   000000AC   0x4682             MOV      R10,R0
   1182              USBx_DEVICE->DIEPEMPMSK &= ~fifoemptymsk;
   \   000000AE   0xF516 0x6000      ADDS     R0,R6,#+2048
   \   000000B2   0x6B40             LDR      R0,[R0, #+52]
   \   000000B4   0xEA30 0x000A      BICS     R0,R0,R10
   \   000000B8   0xF516 0x6100      ADDS     R1,R6,#+2048
   \   000000BC   0x6348             STR      R0,[R1, #+52]
   1183              
   1184            }
   1185            
   1186            return HAL_OK;  
   \                     ??PCD_WriteEmptyTxFifo_4: (+1)
   \   000000BE   0x2000             MOVS     R0,#+0
   \   000000C0   0xE8BD 0x87F6      POP      {R1,R2,R4-R10,PC}  ;; return
   1187          }
   1188          
   1189          /**
   1190            * @}
   1191            */
   1192          
   1193          #endif /* HAL_PCD_MODULE_ENABLED */
   1194          /**
   1195            * @}
   1196            */
   1197          
   1198          /**
   1199            * @}
   1200            */
   1201          
   1202          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   HAL_PCD_ActivateRemoteWakeup
       0   HAL_PCD_ConnectCallback
       0   HAL_PCD_DataInStageCallback
       0   HAL_PCD_DataOutStageCallback
       0   HAL_PCD_DeActivateRemoteWakeup
       8   HAL_PCD_DeInit
         8   -> HAL_PCD_MspDeInit
         8   -> HAL_PCD_Stop
       8   HAL_PCD_DevConnect
         8   -> USB_DevConnect
       8   HAL_PCD_DevDisconnect
         8   -> USB_DevDisconnect
       0   HAL_PCD_DisconnectCallback
      16   HAL_PCD_EP_Close
        16   -> USB_DeactivateEndpoint
      16   HAL_PCD_EP_ClrStall
        16   -> USB_EPClearStall
      16   HAL_PCD_EP_Flush
        16   -> USB_FlushRxFifo
        16   -> USB_FlushTxFifo
       0   HAL_PCD_EP_GetRxCount
      32   HAL_PCD_EP_Open
        32   -> USB_ActivateEndpoint
      24   HAL_PCD_EP_Receive
        24   -> USB_EP0StartXfer
        24   -> USB_EPStartXfer
      16   HAL_PCD_EP_SetStall
        16   -> USB_EP0_OutStart
        16   -> USB_EPSetStall
      24   HAL_PCD_EP_Transmit
        24   -> USB_EP0StartXfer
        24   -> USB_EPStartXfer
       0   HAL_PCD_GetState
      40   HAL_PCD_IRQHandler
        40   -> HAL_PCDEx_LPM_Callback
        40   -> HAL_PCD_ConnectCallback
        40   -> HAL_PCD_DataInStageCallback
        40   -> HAL_PCD_DataOutStageCallback
        40   -> HAL_PCD_DisconnectCallback
        40   -> HAL_PCD_ISOINIncompleteCallback
        40   -> HAL_PCD_ISOOUTIncompleteCallback
        40   -> HAL_PCD_ResetCallback
        40   -> HAL_PCD_ResumeCallback
        40   -> HAL_PCD_SOFCallback
        40   -> HAL_PCD_SetupStageCallback
        40   -> HAL_PCD_SuspendCallback
        40   -> PCD_WriteEmptyTxFifo
        40   -> USB_ActivateSetup
        40   -> USB_EP0_OutStart
        40   -> USB_FlushTxFifo
        40   -> USB_GetDevSpeed
        40   -> USB_GetMode
        40   -> USB_ReadDevAllInEpInterrupt
        40   -> USB_ReadDevAllOutEpInterrupt
        40   -> USB_ReadDevInEPInterrupt
        40   -> USB_ReadDevOutEPInterrupt
        40   -> USB_ReadInterrupts
        40   -> USB_ReadPacket
       0   HAL_PCD_ISOINIncompleteCallback
       0   HAL_PCD_ISOOUTIncompleteCallback
      60   HAL_PCD_Init
        48   -> HAL_PCDEx_ActivateLPM
        48   -> HAL_PCD_MspInit
        48   -> USB_CoreInit
        48   -> USB_DevDisconnect
        48   -> USB_DevInit
        48   -> USB_DisableGlobalInt
        48   -> USB_SetCurrentMode
        60   -> __aeabi_memcpy4
       0   HAL_PCD_MspDeInit
       0   HAL_PCD_MspInit
       0   HAL_PCD_ResetCallback
       0   HAL_PCD_ResumeCallback
       0   HAL_PCD_SOFCallback
      16   HAL_PCD_SetAddress
        16   -> USB_SetDevAddress
       0   HAL_PCD_SetupStageCallback
       8   HAL_PCD_Start
         8   -> USB_DevConnect
         8   -> USB_EnableGlobalInt
       8   HAL_PCD_Stop
         8   -> USB_DevDisconnect
         8   -> USB_DisableGlobalInt
         8   -> USB_StopDevice
       0   HAL_PCD_SuspendCallback
      40   PCD_WriteEmptyTxFifo
        40   -> USB_WritePacket


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      34  HAL_PCD_ActivateRemoteWakeup
       2  HAL_PCD_ConnectCallback
       2  HAL_PCD_DataInStageCallback
       2  HAL_PCD_DataOutStageCallback
      24  HAL_PCD_DeActivateRemoteWakeup
      40  HAL_PCD_DeInit
      38  HAL_PCD_DevConnect
      38  HAL_PCD_DevDisconnect
       2  HAL_PCD_DisconnectCallback
      98  HAL_PCD_EP_Close
      98  HAL_PCD_EP_ClrStall
      60  HAL_PCD_EP_Flush
      20  HAL_PCD_EP_GetRxCount
     154  HAL_PCD_EP_Open
     130  HAL_PCD_EP_Receive
     118  HAL_PCD_EP_SetStall
     128  HAL_PCD_EP_Transmit
       6  HAL_PCD_GetState
    1314  HAL_PCD_IRQHandler
       2  HAL_PCD_ISOINIncompleteCallback
       2  HAL_PCD_ISOOUTIncompleteCallback
     298  HAL_PCD_Init
       2  HAL_PCD_MspDeInit
       2  HAL_PCD_MspInit
       2  HAL_PCD_ResetCallback
       2  HAL_PCD_ResumeCallback
       2  HAL_PCD_SOFCallback
      44  HAL_PCD_SetAddress
       2  HAL_PCD_SetupStageCallback
      44  HAL_PCD_Start
      50  HAL_PCD_Stop
       2  HAL_PCD_SuspendCallback
     196  PCD_WriteEmptyTxFifo

 
 2 958 bytes in section .text
 
 2 958 bytes of CODE memory

Errors: none
Warnings: none
