###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.2.10312/W32 for ARM       27/Feb/2016  00:32:46
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Middlewares\ST\STM32_USB_Device_Library\Core\Src\usbd_ctlreq.c
#    Command line =  
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Middlewares\ST\STM32_USB_Device_Library\Core\Src\usbd_ctlreq.c
#        -D USE_HAL_DRIVER -D STM32F746xx -D USE_STM32746G_DISCO -D
#        USE_IOEXPANDER -D USE_USB_FS -lC
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
#        -lA
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
#        -o
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M7 -e --fpu=VFPv5_sp --dlib_config
#        "D:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Full.h" -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\Inc\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\CMSIS\Device\ST\STM32F7xx\Include\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\STM32F7xx_HAL_Driver\Inc\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\STM32746G-Discovery\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\Components\Common\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Log\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Fonts\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\CPU\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_Device_Library\Core\Inc\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Core\Inc\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Class\MSC\Inc\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\drivers\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_Audio\Addons\PDM\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_Device_Library\Class\AUDIO\Inc\
#        -Om --use_c++_inline --require_prototypes -I "D:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.3\arm\CMSIS\Include\" -D
#        ARM_MATH_CM7
#    List file    =  
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List\usbd_ctlreq.lst
#    Object file  =  
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj\usbd_ctlreq.o
#
###############################################################################

H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Middlewares\ST\STM32_USB_Device_Library\Core\Src\usbd_ctlreq.c
      1          /**
      2            ******************************************************************************
      3            * @file    usbd_req.c
      4            * @author  MCD Application Team
      5            * @version V2.4.1
      6            * @date    19-June-2015 
      7            * @brief   This file provides the standard USB requests following chapter 9.
      8            ******************************************************************************
      9            * @attention
     10            *
     11            * <h2><center>&copy; COPYRIGHT 2015 STMicroelectronics</center></h2>
     12            *
     13            * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
     14            * You may not use this file except in compliance with the License.
     15            * You may obtain a copy of the License at:
     16            *
     17            *        http://www.st.com/software_license_agreement_liberty_v2
     18            *
     19            * Unless required by applicable law or agreed to in writing, software 
     20            * distributed under the License is distributed on an "AS IS" BASIS, 
     21            * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     22            * See the License for the specific language governing permissions and
     23            * limitations under the License.
     24            *
     25            ******************************************************************************
     26            */ 
     27          
     28          /* Includes ------------------------------------------------------------------*/
     29          #include "usbd_ctlreq.h"
     30          #include "usbd_ioreq.h"
     31          
     32          
     33          /** @addtogroup STM32_USBD_STATE_DEVICE_LIBRARY
     34            * @{
     35            */
     36          
     37          
     38          /** @defgroup USBD_REQ 
     39            * @brief USB standard requests module
     40            * @{
     41            */ 
     42          
     43          /** @defgroup USBD_REQ_Private_TypesDefinitions
     44            * @{
     45            */ 
     46          /**
     47            * @}
     48            */ 
     49          
     50          
     51          /** @defgroup USBD_REQ_Private_Defines
     52            * @{
     53            */ 
     54          
     55          /**
     56            * @}
     57            */ 
     58          
     59          
     60          /** @defgroup USBD_REQ_Private_Macros
     61            * @{
     62            */ 
     63          /**
     64            * @}
     65            */ 
     66          
     67          
     68          /** @defgroup USBD_REQ_Private_Variables
     69            * @{
     70            */ 
     71          /**
     72            * @}
     73            */ 
     74          
     75          
     76          /** @defgroup USBD_REQ_Private_FunctionPrototypes
     77            * @{
     78            */ 
     79          static void USBD_GetDescriptor(USBD_HandleTypeDef *pdev , 
     80                                         USBD_SetupReqTypedef *req);
     81          
     82          static void USBD_SetAddress(USBD_HandleTypeDef *pdev , 
     83                                      USBD_SetupReqTypedef *req);
     84          
     85          static void USBD_SetConfig(USBD_HandleTypeDef *pdev , 
     86                                     USBD_SetupReqTypedef *req);
     87          
     88          static void USBD_GetConfig(USBD_HandleTypeDef *pdev , 
     89                                     USBD_SetupReqTypedef *req);
     90          
     91          static void USBD_GetStatus(USBD_HandleTypeDef *pdev , 
     92                                     USBD_SetupReqTypedef *req);
     93          
     94          static void USBD_SetFeature(USBD_HandleTypeDef *pdev , 
     95                                      USBD_SetupReqTypedef *req);
     96          
     97          static void USBD_ClrFeature(USBD_HandleTypeDef *pdev , 
     98                                      USBD_SetupReqTypedef *req);
     99          
    100          static uint8_t USBD_GetLen(uint8_t *buf);
    101          
    102          /**
    103            * @}
    104            */ 
    105          
    106          
    107          /** @defgroup USBD_REQ_Private_Functions
    108            * @{
    109            */ 
    110          
    111          
    112          /**
    113          * @brief  USBD_StdDevReq
    114          *         Handle standard usb device requests
    115          * @param  pdev: device instance
    116          * @param  req: usb request
    117          * @retval status
    118          */

   \                                 In section .text, align 4, keep-with-next
    119          USBD_StatusTypeDef  USBD_StdDevReq (USBD_HandleTypeDef *pdev , USBD_SetupReqTypedef  *req)
    120          {
   \                     USBD_StdDevReq: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    121            USBD_StatusTypeDef ret = USBD_OK;  
    122            
    123            switch (req->bRequest) 
   \   00000002   0x784A             LDRB     R2,[R1, #+1]
   \   00000004   0x2A09             CMP      R2,#+9
   \   00000006   0xD81B             BHI.N    ??USBD_StdDevReq_1
   \   00000008   0xE8DF 0xF002      TBB      [PC, R2]
   \                     ??USBD_StdDevReq_0:
   \   0000000C   0x11 0x17          DC8      0x11,0x17,0x1A,0x14
   \              0x1A 0x14    
   \   00000010   0x1A 0x08          DC8      0x1A,0x8,0x5,0x1A
   \              0x05 0x1A    
   \   00000014   0x0E 0x0B          DC8      0xE,0xB
    124            {
    125            case USB_REQ_GET_DESCRIPTOR: 
    126              
    127              USBD_GetDescriptor (pdev, req) ;
   \                     ??USBD_StdDevReq_2: (+1)
   \   00000016   0x.... 0x....      BL       USBD_GetDescriptor
    128              break;
   \   0000001A   0xE013             B.N      ??USBD_StdDevReq_3
    129              
    130            case USB_REQ_SET_ADDRESS:                      
    131              USBD_SetAddress(pdev, req);
   \                     ??USBD_StdDevReq_4: (+1)
   \   0000001C   0x.... 0x....      BL       USBD_SetAddress
    132              break;
   \   00000020   0xE010             B.N      ??USBD_StdDevReq_3
    133              
    134            case USB_REQ_SET_CONFIGURATION:                    
    135              USBD_SetConfig (pdev , req);
   \                     ??USBD_StdDevReq_5: (+1)
   \   00000022   0x.... 0x....      BL       USBD_SetConfig
    136              break;
   \   00000026   0xE00D             B.N      ??USBD_StdDevReq_3
    137              
    138            case USB_REQ_GET_CONFIGURATION:                 
    139              USBD_GetConfig (pdev , req);
   \                     ??USBD_StdDevReq_6: (+1)
   \   00000028   0x.... 0x....      BL       USBD_GetConfig
    140              break;
   \   0000002C   0xE00A             B.N      ??USBD_StdDevReq_3
    141              
    142            case USB_REQ_GET_STATUS:                                  
    143              USBD_GetStatus (pdev , req);
   \                     ??USBD_StdDevReq_7: (+1)
   \   0000002E   0x.... 0x....      BL       USBD_GetStatus
    144              break;
   \   00000032   0xE007             B.N      ??USBD_StdDevReq_3
    145              
    146              
    147            case USB_REQ_SET_FEATURE:   
    148              USBD_SetFeature (pdev , req);    
   \                     ??USBD_StdDevReq_8: (+1)
   \   00000034   0x.... 0x....      BL       USBD_SetFeature
    149              break;
   \   00000038   0xE004             B.N      ??USBD_StdDevReq_3
    150              
    151            case USB_REQ_CLEAR_FEATURE:                                   
    152              USBD_ClrFeature (pdev , req);
   \                     ??USBD_StdDevReq_9: (+1)
   \   0000003A   0x.... 0x....      BL       USBD_ClrFeature
    153              break;
   \   0000003E   0xE001             B.N      ??USBD_StdDevReq_3
    154              
    155            default:  
    156              USBD_CtlError(pdev , req);
   \                     ??USBD_StdDevReq_1: (+1)
   \   00000040   0x.... 0x....      BL       USBD_CtlError
    157              break;
    158            }
    159            
    160            return ret;
   \                     ??USBD_StdDevReq_3: (+1)
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0xBD02             POP      {R1,PC}          ;; return
    161          }
    162          
    163          /**
    164          * @brief  USBD_StdItfReq
    165          *         Handle standard usb interface requests
    166          * @param  pdev: device instance
    167          * @param  req: usb request
    168          * @retval status
    169          */

   \                                 In section .text, align 2, keep-with-next
    170          USBD_StatusTypeDef  USBD_StdItfReq (USBD_HandleTypeDef *pdev , USBD_SetupReqTypedef  *req)
    171          {
   \                     USBD_StdItfReq: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    172            USBD_StatusTypeDef ret = USBD_OK; 
    173            
    174            switch (pdev->dev_state) 
   \   00000006   0xF504 0x72FE      ADD      R2,R4,#+508
   \   0000000A   0x7810             LDRB     R0,[R2, #+0]
   \   0000000C   0x2803             CMP      R0,#+3
   \   0000000E   0xD10D             BNE.N    ??USBD_StdItfReq_0
    175            {
    176            case USBD_STATE_CONFIGURED:
    177              
    178              if (LOBYTE(req->wIndex) <= USBD_MAX_NUM_INTERFACES) 
   \   00000010   0x7928             LDRB     R0,[R5, #+4]
   \   00000012   0x2803             CMP      R0,#+3
   \   00000014   0xDA0A             BGE.N    ??USBD_StdItfReq_0
    179              {
    180                pdev->pClass->Setup (pdev, req); 
   \   00000016   0x4620             MOV      R0,R4
   \   00000018   0x6992             LDR      R2,[R2, #+24]
   \   0000001A   0x6892             LDR      R2,[R2, #+8]
   \   0000001C   0x4790             BLX      R2
    181                
    182                if((req->wLength == 0)&& (ret == USBD_OK))
   \   0000001E   0x88E8             LDRH     R0,[R5, #+6]
   \   00000020   0x2800             CMP      R0,#+0
   \   00000022   0xD106             BNE.N    ??USBD_StdItfReq_1
    183                {
    184                   USBD_CtlSendStatus(pdev);
   \   00000024   0x4620             MOV      R0,R4
   \   00000026   0x.... 0x....      BL       USBD_CtlSendStatus
   \   0000002A   0xE002             B.N      ??USBD_StdItfReq_1
    185                }
    186              } 
    187              else 
    188              {                                               
    189                 USBD_CtlError(pdev , req);
    190              }
    191              break;
    192              
    193            default:
    194               USBD_CtlError(pdev , req);
   \                     ??USBD_StdItfReq_0: (+1)
   \   0000002C   0x4620             MOV      R0,R4
   \   0000002E   0x.... 0x....      BL       USBD_CtlError
    195              break;
    196            }
    197            return USBD_OK;
   \                     ??USBD_StdItfReq_1: (+1)
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    198          }
    199          
    200          /**
    201          * @brief  USBD_StdEPReq
    202          *         Handle standard usb endpoint requests
    203          * @param  pdev: device instance
    204          * @param  req: usb request
    205          * @retval status
    206          */

   \                                 In section .text, align 2, keep-with-next
    207          USBD_StatusTypeDef  USBD_StdEPReq (USBD_HandleTypeDef *pdev , USBD_SetupReqTypedef  *req)
    208          {
   \                     USBD_StdEPReq: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    209            
    210            uint8_t   ep_addr;
    211            USBD_StatusTypeDef ret = USBD_OK; 
    212            USBD_EndpointTypeDef   *pep;
    213            ep_addr  = LOBYTE(req->wIndex);   
   \   00000006   0x7929             LDRB     R1,[R5, #+4]
    214            
    215            /* Check if it is a class request */
    216            if ((req->bmRequest & 0x60) == 0x20)
   \   00000008   0x7828             LDRB     R0,[R5, #+0]
   \   0000000A   0xF000 0x0060      AND      R0,R0,#0x60
   \   0000000E   0x2820             CMP      R0,#+32
   \   00000010   0xD108             BNE.N    ??USBD_StdEPReq_0
    217            {
    218              pdev->pClass->Setup (pdev, req);
   \   00000012   0x4629             MOV      R1,R5
   \   00000014   0x4620             MOV      R0,R4
   \   00000016   0xF504 0x72FE      ADD      R2,R4,#+508
   \   0000001A   0x6992             LDR      R2,[R2, #+24]
   \   0000001C   0x6892             LDR      R2,[R2, #+8]
   \   0000001E   0x4790             BLX      R2
    219              
    220              return USBD_OK;
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0xBD70             POP      {R4-R6,PC}
    221            }
    222            
    223            switch (req->bRequest) 
   \                     ??USBD_StdEPReq_0: (+1)
   \   00000024   0x7868             LDRB     R0,[R5, #+1]
   \   00000026   0x2800             CMP      R0,#+0
   \   00000028   0xD048             BEQ.N    ??USBD_StdEPReq_1
   \   0000002A   0x2801             CMP      R0,#+1
   \   0000002C   0xD024             BEQ.N    ??USBD_StdEPReq_2
   \   0000002E   0x2803             CMP      R0,#+3
   \   00000030   0xD170             BNE.N    ??USBD_StdEPReq_3
    224            {
    225              
    226            case USB_REQ_SET_FEATURE :
    227              
    228              switch (pdev->dev_state) 
   \   00000032   0xF504 0x76FE      ADD      R6,R4,#+508
   \   00000036   0x7830             LDRB     R0,[R6, #+0]
   \   00000038   0x2802             CMP      R0,#+2
   \   0000003A   0xD002             BEQ.N    ??USBD_StdEPReq_4
   \   0000003C   0x2803             CMP      R0,#+3
   \   0000003E   0xD008             BEQ.N    ??USBD_StdEPReq_5
   \   00000040   0xE064             B.N      ??USBD_StdEPReq_6
    229              {
    230              case USBD_STATE_ADDRESSED:          
    231                if ((ep_addr != 0x00) && (ep_addr != 0x80)) 
   \                     ??USBD_StdEPReq_4: (+1)
   \   00000042   0x2900             CMP      R1,#+0
   \   00000044   0xD066             BEQ.N    ??USBD_StdEPReq_3
   \   00000046   0x2980             CMP      R1,#+128
   \   00000048   0xD064             BEQ.N    ??USBD_StdEPReq_3
    232                {
    233                  USBD_LL_StallEP(pdev , ep_addr);
   \   0000004A   0x4620             MOV      R0,R4
   \   0000004C   0x.... 0x....      BL       USBD_LL_StallEP
   \   00000050   0xE060             B.N      ??USBD_StdEPReq_3
    234                }
    235                break;	
    236                
    237              case USBD_STATE_CONFIGURED:   
    238                if (req->wValue == USB_FEATURE_EP_HALT)
   \                     ??USBD_StdEPReq_5: (+1)
   \   00000052   0x8868             LDRH     R0,[R5, #+2]
   \   00000054   0x2800             CMP      R0,#+0
   \   00000056   0xD106             BNE.N    ??USBD_StdEPReq_7
    239                {
    240                  if ((ep_addr != 0x00) && (ep_addr != 0x80)) 
   \   00000058   0x2900             CMP      R1,#+0
   \   0000005A   0xD004             BEQ.N    ??USBD_StdEPReq_7
   \   0000005C   0x2980             CMP      R1,#+128
   \   0000005E   0xD002             BEQ.N    ??USBD_StdEPReq_7
    241                  { 
    242                    USBD_LL_StallEP(pdev , ep_addr);
   \   00000060   0x4620             MOV      R0,R4
   \   00000062   0x.... 0x....      BL       USBD_LL_StallEP
    243                    
    244                  }
    245                }
    246                pdev->pClass->Setup (pdev, req);   
   \                     ??USBD_StdEPReq_7: (+1)
   \   00000066   0x4629             MOV      R1,R5
   \   00000068   0x4620             MOV      R0,R4
   \   0000006A   0x69B2             LDR      R2,[R6, #+24]
   \   0000006C   0x6892             LDR      R2,[R2, #+8]
   \   0000006E   0x4790             BLX      R2
    247                USBD_CtlSendStatus(pdev);
   \   00000070   0x4620             MOV      R0,R4
   \   00000072   0x.... 0x....      BL       USBD_CtlSendStatus
    248                
    249                break;
   \   00000076   0xE04D             B.N      ??USBD_StdEPReq_3
    250                
    251              default:                         
    252                USBD_CtlError(pdev , req);
    253                break;    
    254              }
    255              break;
    256              
    257            case USB_REQ_CLEAR_FEATURE :
    258              
    259              switch (pdev->dev_state) 
   \                     ??USBD_StdEPReq_2: (+1)
   \   00000078   0xF504 0x76FE      ADD      R6,R4,#+508
   \   0000007C   0x7830             LDRB     R0,[R6, #+0]
   \   0000007E   0x2802             CMP      R0,#+2
   \   00000080   0xD002             BEQ.N    ??USBD_StdEPReq_8
   \   00000082   0x2803             CMP      R0,#+3
   \   00000084   0xD008             BEQ.N    ??USBD_StdEPReq_9
   \   00000086   0xE041             B.N      ??USBD_StdEPReq_6
    260              {
    261              case USBD_STATE_ADDRESSED:          
    262                if ((ep_addr != 0x00) && (ep_addr != 0x80)) 
   \                     ??USBD_StdEPReq_8: (+1)
   \   00000088   0x2900             CMP      R1,#+0
   \   0000008A   0xD043             BEQ.N    ??USBD_StdEPReq_3
   \   0000008C   0x2980             CMP      R1,#+128
   \   0000008E   0xD041             BEQ.N    ??USBD_StdEPReq_3
    263                {
    264                  USBD_LL_StallEP(pdev , ep_addr);
   \   00000090   0x4620             MOV      R0,R4
   \   00000092   0x.... 0x....      BL       USBD_LL_StallEP
   \   00000096   0xE03D             B.N      ??USBD_StdEPReq_3
    265                }
    266                break;	
    267                
    268              case USBD_STATE_CONFIGURED:   
    269                if (req->wValue == USB_FEATURE_EP_HALT)
   \                     ??USBD_StdEPReq_9: (+1)
   \   00000098   0x8868             LDRH     R0,[R5, #+2]
   \   0000009A   0x2800             CMP      R0,#+0
   \   0000009C   0xD13A             BNE.N    ??USBD_StdEPReq_3
    270                {
    271                  if ((ep_addr & 0x7F) != 0x00) 
   \   0000009E   0xF011 0x007F      ANDS     R0,R1,#0x7F
   \   000000A2   0xD007             BEQ.N    ??USBD_StdEPReq_10
    272                  {        
    273                    USBD_LL_ClearStallEP(pdev , ep_addr);
   \   000000A4   0x4620             MOV      R0,R4
   \   000000A6   0x.... 0x....      BL       USBD_LL_ClearStallEP
    274                    pdev->pClass->Setup (pdev, req);
   \   000000AA   0x4629             MOV      R1,R5
   \   000000AC   0x4620             MOV      R0,R4
   \   000000AE   0x69B2             LDR      R2,[R6, #+24]
   \   000000B0   0x6892             LDR      R2,[R2, #+8]
   \   000000B2   0x4790             BLX      R2
    275                  }
    276                  USBD_CtlSendStatus(pdev);
   \                     ??USBD_StdEPReq_10: (+1)
   \   000000B4   0x4620             MOV      R0,R4
   \   000000B6   0x.... 0x....      BL       USBD_CtlSendStatus
   \   000000BA   0xE02B             B.N      ??USBD_StdEPReq_3
    277                }
    278                break;
    279                
    280              default:                         
    281                USBD_CtlError(pdev , req);
    282                break;    
    283              }
    284              break;
    285              
    286            case USB_REQ_GET_STATUS:                  
    287              switch (pdev->dev_state) 
   \                     ??USBD_StdEPReq_1: (+1)
   \   000000BC   0xF894 0x01FC      LDRB     R0,[R4, #+508]
   \   000000C0   0x2802             CMP      R0,#+2
   \   000000C2   0xD002             BEQ.N    ??USBD_StdEPReq_11
   \   000000C4   0x2803             CMP      R0,#+3
   \   000000C6   0xD007             BEQ.N    ??USBD_StdEPReq_12
   \   000000C8   0xE020             B.N      ??USBD_StdEPReq_6
    288              {
    289              case USBD_STATE_ADDRESSED:          
    290                if ((ep_addr & 0x7F) != 0x00) 
   \                     ??USBD_StdEPReq_11: (+1)
   \   000000CA   0xF011 0x007F      ANDS     R0,R1,#0x7F
   \   000000CE   0xD021             BEQ.N    ??USBD_StdEPReq_3
    291                {
    292                  USBD_LL_StallEP(pdev , ep_addr);
   \   000000D0   0x4620             MOV      R0,R4
   \   000000D2   0x.... 0x....      BL       USBD_LL_StallEP
   \   000000D6   0xE01D             B.N      ??USBD_StdEPReq_3
    293                }
    294                break;	
    295                
    296              case USBD_STATE_CONFIGURED:
    297                pep = ((ep_addr & 0x80) == 0x80) ? &pdev->ep_in[ep_addr & 0x7F]:\
    298                                                   &pdev->ep_out[ep_addr & 0x7F];
   \                     ??USBD_StdEPReq_12: (+1)
   \   000000D8   0xF001 0x007F      AND      R0,R1,#0x7F
   \   000000DC   0xEB04 0x1000      ADD      R0,R4,R0, LSL #+4
   \   000000E0   0x460A             MOV      R2,R1
   \   000000E2   0x0612             LSLS     R2,R2,#+24
   \   000000E4   0xD502             BPL.N    ??USBD_StdEPReq_13
   \   000000E6   0xF100 0x0514      ADD      R5,R0,#+20
   \   000000EA   0xE001             B.N      ??USBD_StdEPReq_14
   \                     ??USBD_StdEPReq_13: (+1)
   \   000000EC   0xF500 0x7582      ADD      R5,R0,#+260
    299                if(USBD_LL_IsStallEP(pdev, ep_addr))
   \                     ??USBD_StdEPReq_14: (+1)
   \   000000F0   0x4620             MOV      R0,R4
   \   000000F2   0x.... 0x....      BL       USBD_LL_IsStallEP
   \   000000F6   0x1E40             SUBS     R0,R0,#+1
   \   000000F8   0x4180             SBCS     R0,R0,R0
   \   000000FA   0x43C0             MVNS     R0,R0
   \   000000FC   0x0FC0             LSRS     R0,R0,#+31
   \   000000FE   0x6028             STR      R0,[R5, #+0]
    300                {
    301                  pep->status = 0x0001;     
    302                }
    303                else
    304                {
    305                  pep->status = 0x0000;  
    306                }
    307                
    308                USBD_CtlSendData (pdev,
    309                                  (uint8_t *)&pep->status,
    310                                  2);
   \   00000100   0x2202             MOVS     R2,#+2
   \   00000102   0x4629             MOV      R1,R5
   \   00000104   0x4620             MOV      R0,R4
   \   00000106   0x.... 0x....      BL       USBD_CtlSendData
    311                break;
   \   0000010A   0xE003             B.N      ??USBD_StdEPReq_3
    312                
    313              default:                         
    314                USBD_CtlError(pdev , req);
   \                     ??USBD_StdEPReq_6: (+1)
   \   0000010C   0x4629             MOV      R1,R5
   \   0000010E   0x4620             MOV      R0,R4
   \   00000110   0x.... 0x....      BL       USBD_CtlError
    315                break;
    316              }
    317              break;
    318              
    319            default:
    320              break;
    321            }
    322            return ret;
   \                     ??USBD_StdEPReq_3: (+1)
   \   00000114   0x2000             MOVS     R0,#+0
   \   00000116   0xBD70             POP      {R4-R6,PC}       ;; return
    323          }
    324          /**
    325          * @brief  USBD_GetDescriptor
    326          *         Handle Get Descriptor requests
    327          * @param  pdev: device instance
    328          * @param  req: usb request
    329          * @retval status
    330          */

   \                                 In section .text, align 4, keep-with-next
    331          static void USBD_GetDescriptor(USBD_HandleTypeDef *pdev , 
    332                                         USBD_SetupReqTypedef *req)
    333          {
   \                     USBD_GetDescriptor: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    334            uint16_t len;
    335            uint8_t *pbuf;
    336            
    337              
    338            switch (req->wValue >> 8)
   \   00000006   0x8869             LDRH     R1,[R5, #+2]
   \   00000008   0x4608             MOV      R0,R1
   \   0000000A   0x0A00             LSRS     R0,R0,#+8
   \   0000000C   0x1E40             SUBS     R0,R0,#+1
   \   0000000E   0x2806             CMP      R0,#+6
   \   00000010   0xF200 0x807A      BHI.W    ??USBD_GetDescriptor_2
   \   00000014   0xE8DF 0xF000      TBB      [PC, R0]
   \                     ??USBD_GetDescriptor_0:
   \   00000018   0x04 0x1F          DC8      0x4,0x1F,0x30,0x78
   \              0x30 0x78    
   \   0000001C   0x78 0x62          DC8      0x78,0x62,0x6C,0x0
   \              0x6C 0x00    
    339            { 
    340          #if (USBD_LPM_ENABLED == 1)
    341            case USB_DESC_TYPE_BOS:
    342              pbuf = pdev->pDesc->GetBOSDescriptor(pdev->dev_speed, &len);
    343              break;
    344          #endif    
    345            case USB_DESC_TYPE_DEVICE:
    346              pbuf = pdev->pDesc->GetDeviceDescriptor(pdev->dev_speed, &len);
   \                     ??USBD_GetDescriptor_3: (+1)
   \   00000020   0x4669             MOV      R1,SP
   \   00000022   0x7C20             LDRB     R0,[R4, #+16]
   \   00000024   0xF8D4 0x2210      LDR      R2,[R4, #+528]
   \   00000028   0x6812             LDR      R2,[R2, #+0]
   \   0000002A   0x4790             BLX      R2
    347              break;
    348              
    349            case USB_DESC_TYPE_CONFIGURATION:     
    350              if(pdev->dev_speed == USBD_SPEED_HIGH )   
    351              {
    352                pbuf   = (uint8_t *)pdev->pClass->GetHSConfigDescriptor(&len);
    353                pbuf[1] = USB_DESC_TYPE_CONFIGURATION;
    354              }
    355              else
    356              {
    357                pbuf   = (uint8_t *)pdev->pClass->GetFSConfigDescriptor(&len);
    358                pbuf[1] = USB_DESC_TYPE_CONFIGURATION;
    359              }
    360              break;
    361              
    362            case USB_DESC_TYPE_STRING:
    363              switch ((uint8_t)(req->wValue))
    364              {
    365              case USBD_IDX_LANGID_STR:
    366               pbuf = pdev->pDesc->GetLangIDStrDescriptor(pdev->dev_speed, &len);        
    367                break;
    368                
    369              case USBD_IDX_MFC_STR:
    370                pbuf = pdev->pDesc->GetManufacturerStrDescriptor(pdev->dev_speed, &len);
    371                break;
    372                
    373              case USBD_IDX_PRODUCT_STR:
    374                pbuf = pdev->pDesc->GetProductStrDescriptor(pdev->dev_speed, &len);
    375                break;
    376                
    377              case USBD_IDX_SERIAL_STR:
    378                pbuf = pdev->pDesc->GetSerialStrDescriptor(pdev->dev_speed, &len);
    379                break;
    380                
    381              case USBD_IDX_CONFIG_STR:
    382                pbuf = pdev->pDesc->GetConfigurationStrDescriptor(pdev->dev_speed, &len);
    383                break;
    384                
    385              case USBD_IDX_INTERFACE_STR:
    386                pbuf = pdev->pDesc->GetInterfaceStrDescriptor(pdev->dev_speed, &len);
    387                break;
    388                
    389              default:
    390          #if (USBD_SUPPORT_USER_STRING == 1)
    391                pbuf = pdev->pClass->GetUsrStrDescriptor(pdev, (req->wValue) , &len);
    392                break;
    393          #else      
    394                 USBD_CtlError(pdev , req);
    395                return;
    396          #endif   
    397              }
    398              break;
    399            case USB_DESC_TYPE_DEVICE_QUALIFIER:                   
    400          
    401              if(pdev->dev_speed == USBD_SPEED_HIGH  )   
    402              {
    403                pbuf   = (uint8_t *)pdev->pClass->GetDeviceQualifierDescriptor(&len);
    404                break;
    405              }
    406              else
    407              {
    408                USBD_CtlError(pdev , req);
    409                return;
    410              } 
    411          
    412            case USB_DESC_TYPE_OTHER_SPEED_CONFIGURATION:
    413              if(pdev->dev_speed == USBD_SPEED_HIGH  )   
    414              {
    415                pbuf   = (uint8_t *)pdev->pClass->GetOtherSpeedConfigDescriptor(&len);
    416                pbuf[1] = USB_DESC_TYPE_OTHER_SPEED_CONFIGURATION;
    417                break; 
    418              }
    419              else
    420              {
    421                USBD_CtlError(pdev , req);
    422                return;
    423              }
    424          
    425            default: 
    426               USBD_CtlError(pdev , req);
    427              return;
    428            }
    429            
    430            if((len != 0)&& (req->wLength != 0))
   \                     ??USBD_GetDescriptor_4: (+1)
   \   0000002C   0xF8BD 0x1000      LDRH     R1,[SP, #+0]
   \   00000030   0x2900             CMP      R1,#+0
   \   00000032   0xD00F             BEQ.N    ??USBD_GetDescriptor_5
   \   00000034   0x88E9             LDRH     R1,[R5, #+6]
   \   00000036   0x2900             CMP      R1,#+0
   \   00000038   0xD00C             BEQ.N    ??USBD_GetDescriptor_5
    431            {
    432              
    433              len = MIN(len , req->wLength);
   \   0000003A   0xF8BD 0x2000      LDRH     R2,[SP, #+0]
   \   0000003E   0x428A             CMP      R2,R1
   \   00000040   0xD900             BLS.N    ??USBD_GetDescriptor_6
   \   00000042   0x460A             MOV      R2,R1
   \                     ??USBD_GetDescriptor_6: (+1)
   \   00000044   0xF8AD 0x2000      STRH     R2,[SP, #+0]
    434              
    435              USBD_CtlSendData (pdev, 
    436                                pbuf,
    437                                len);
   \   00000048   0xF8BD 0x2000      LDRH     R2,[SP, #+0]
   \   0000004C   0x4601             MOV      R1,R0
   \   0000004E   0x4620             MOV      R0,R4
   \   00000050   0x.... 0x....      BL       USBD_CtlSendData
    438            }
    439            
    440          }
   \                     ??USBD_GetDescriptor_5: (+1)
   \   00000054   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   \                     ??USBD_GetDescriptor_7: (+1)
   \   00000056   0xF504 0x7004      ADD      R0,R4,#+528
   \   0000005A   0x6841             LDR      R1,[R0, #+4]
   \   0000005C   0x7C20             LDRB     R0,[R4, #+16]
   \   0000005E   0x2800             CMP      R0,#+0
   \   00000060   0x4668             MOV      R0,SP
   \   00000062   0xD104             BNE.N    ??USBD_GetDescriptor_8
   \   00000064   0x6A89             LDR      R1,[R1, #+40]
   \   00000066   0x4788             BLX      R1
   \   00000068   0x2102             MOVS     R1,#+2
   \   0000006A   0x7041             STRB     R1,[R0, #+1]
   \   0000006C   0xE7DE             B.N      ??USBD_GetDescriptor_4
   \                     ??USBD_GetDescriptor_8: (+1)
   \   0000006E   0x6AC9             LDR      R1,[R1, #+44]
   \   00000070   0x4788             BLX      R1
   \   00000072   0x2102             MOVS     R1,#+2
   \   00000074   0x7041             STRB     R1,[R0, #+1]
   \   00000076   0xE7D9             B.N      ??USBD_GetDescriptor_4
   \                     ??USBD_GetDescriptor_9: (+1)
   \   00000078   0xB2C9             UXTB     R1,R1
   \   0000007A   0x2905             CMP      R1,#+5
   \   0000007C   0xD844             BHI.N    ??USBD_GetDescriptor_2
   \   0000007E   0xE8DF 0xF001      TBB      [PC, R1]
   \                     ??USBD_GetDescriptor_1:
   \   00000082   0x03 0x0A          DC8      0x3,0xA,0x11,0x18
   \              0x11 0x18    
   \   00000086   0x1F 0x26          DC8      0x1F,0x26
   \                     ??USBD_GetDescriptor_10: (+1)
   \   00000088   0x4669             MOV      R1,SP
   \   0000008A   0x7C20             LDRB     R0,[R4, #+16]
   \   0000008C   0xF8D4 0x2210      LDR      R2,[R4, #+528]
   \   00000090   0x6852             LDR      R2,[R2, #+4]
   \   00000092   0x4790             BLX      R2
   \   00000094   0xE7CA             B.N      ??USBD_GetDescriptor_4
   \                     ??USBD_GetDescriptor_11: (+1)
   \   00000096   0x4669             MOV      R1,SP
   \   00000098   0x7C20             LDRB     R0,[R4, #+16]
   \   0000009A   0xF8D4 0x2210      LDR      R2,[R4, #+528]
   \   0000009E   0x6892             LDR      R2,[R2, #+8]
   \   000000A0   0x4790             BLX      R2
   \   000000A2   0xE7C3             B.N      ??USBD_GetDescriptor_4
   \                     ??USBD_GetDescriptor_12: (+1)
   \   000000A4   0x4669             MOV      R1,SP
   \   000000A6   0x7C20             LDRB     R0,[R4, #+16]
   \   000000A8   0xF8D4 0x2210      LDR      R2,[R4, #+528]
   \   000000AC   0x68D2             LDR      R2,[R2, #+12]
   \   000000AE   0x4790             BLX      R2
   \   000000B0   0xE7BC             B.N      ??USBD_GetDescriptor_4
   \                     ??USBD_GetDescriptor_13: (+1)
   \   000000B2   0x4669             MOV      R1,SP
   \   000000B4   0x7C20             LDRB     R0,[R4, #+16]
   \   000000B6   0xF8D4 0x2210      LDR      R2,[R4, #+528]
   \   000000BA   0x6912             LDR      R2,[R2, #+16]
   \   000000BC   0x4790             BLX      R2
   \   000000BE   0xE7B5             B.N      ??USBD_GetDescriptor_4
   \                     ??USBD_GetDescriptor_14: (+1)
   \   000000C0   0x4669             MOV      R1,SP
   \   000000C2   0x7C20             LDRB     R0,[R4, #+16]
   \   000000C4   0xF8D4 0x2210      LDR      R2,[R4, #+528]
   \   000000C8   0x6952             LDR      R2,[R2, #+20]
   \   000000CA   0x4790             BLX      R2
   \   000000CC   0xE7AE             B.N      ??USBD_GetDescriptor_4
   \                     ??USBD_GetDescriptor_15: (+1)
   \   000000CE   0x4669             MOV      R1,SP
   \   000000D0   0x7C20             LDRB     R0,[R4, #+16]
   \   000000D2   0xF8D4 0x2210      LDR      R2,[R4, #+528]
   \   000000D6   0x6992             LDR      R2,[R2, #+24]
   \   000000D8   0x4790             BLX      R2
   \   000000DA   0xE7A7             B.N      ??USBD_GetDescriptor_4
   \                     ??USBD_GetDescriptor_16: (+1)
   \   000000DC   0x7C20             LDRB     R0,[R4, #+16]
   \   000000DE   0x2800             CMP      R0,#+0
   \   000000E0   0xD112             BNE.N    ??USBD_GetDescriptor_2
   \   000000E2   0x4668             MOV      R0,SP
   \   000000E4   0xF504 0x7104      ADD      R1,R4,#+528
   \   000000E8   0x6849             LDR      R1,[R1, #+4]
   \   000000EA   0x6B49             LDR      R1,[R1, #+52]
   \   000000EC   0x4788             BLX      R1
   \   000000EE   0xE79D             B.N      ??USBD_GetDescriptor_4
   \                     ??USBD_GetDescriptor_17: (+1)
   \   000000F0   0x7C20             LDRB     R0,[R4, #+16]
   \   000000F2   0x2800             CMP      R0,#+0
   \   000000F4   0xD108             BNE.N    ??USBD_GetDescriptor_2
   \   000000F6   0x4668             MOV      R0,SP
   \   000000F8   0xF504 0x7104      ADD      R1,R4,#+528
   \   000000FC   0x6849             LDR      R1,[R1, #+4]
   \   000000FE   0x6B09             LDR      R1,[R1, #+48]
   \   00000100   0x4788             BLX      R1
   \   00000102   0x2107             MOVS     R1,#+7
   \   00000104   0x7041             STRB     R1,[R0, #+1]
   \   00000106   0xE791             B.N      ??USBD_GetDescriptor_4
   \                     ??USBD_GetDescriptor_2: (+1)
   \   00000108   0x4629             MOV      R1,R5
   \   0000010A   0x4620             MOV      R0,R4
   \   0000010C   0x.... 0x....      BL       USBD_CtlError
   \   00000110   0xBD31             POP      {R0,R4,R5,PC}
    441          
    442          /**
    443          * @brief  USBD_SetAddress
    444          *         Set device address
    445          * @param  pdev: device instance
    446          * @param  req: usb request
    447          * @retval status
    448          */

   \                                 In section .text, align 2, keep-with-next
    449          static void USBD_SetAddress(USBD_HandleTypeDef *pdev , 
    450                                      USBD_SetupReqTypedef *req)
    451          {
   \                     USBD_SetAddress: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
    452            uint8_t  dev_addr; 
    453            
    454            if ((req->wIndex == 0) && (req->wLength == 0)) 
   \   00000004   0x8888             LDRH     R0,[R1, #+4]
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD11A             BNE.N    ??USBD_SetAddress_0
   \   0000000A   0x88C8             LDRH     R0,[R1, #+6]
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD117             BNE.N    ??USBD_SetAddress_0
    455            {
    456              dev_addr = (uint8_t)(req->wValue) & 0x7F;     
   \   00000010   0x7888             LDRB     R0,[R1, #+2]
   \   00000012   0xF000 0x057F      AND      R5,R0,#0x7F
    457              
    458              if (pdev->dev_state == USBD_STATE_CONFIGURED) 
   \   00000016   0xF504 0x76FE      ADD      R6,R4,#+508
   \   0000001A   0x7830             LDRB     R0,[R6, #+0]
   \   0000001C   0x2803             CMP      R0,#+3
   \   0000001E   0xD00F             BEQ.N    ??USBD_SetAddress_0
    459              {
    460                USBD_CtlError(pdev , req);
    461              } 
    462              else 
    463              {
    464                pdev->dev_address = dev_addr;
   \   00000020   0x70B5             STRB     R5,[R6, #+2]
    465                USBD_LL_SetUSBAddress(pdev, dev_addr);               
   \   00000022   0x4629             MOV      R1,R5
   \   00000024   0x4620             MOV      R0,R4
   \   00000026   0x.... 0x....      BL       USBD_LL_SetUSBAddress
    466                USBD_CtlSendStatus(pdev);                         
   \   0000002A   0x4620             MOV      R0,R4
   \   0000002C   0x.... 0x....      BL       USBD_CtlSendStatus
    467                
    468                if (dev_addr != 0) 
   \   00000030   0x2D00             CMP      R5,#+0
   \   00000032   0xD002             BEQ.N    ??USBD_SetAddress_1
    469                {
    470                  pdev->dev_state  = USBD_STATE_ADDRESSED;
   \   00000034   0x2002             MOVS     R0,#+2
   \   00000036   0x7030             STRB     R0,[R6, #+0]
   \   00000038   0xBD70             POP      {R4-R6,PC}
    471                } 
    472                else 
    473                {
    474                  pdev->dev_state  = USBD_STATE_DEFAULT; 
   \                     ??USBD_SetAddress_1: (+1)
   \   0000003A   0x2001             MOVS     R0,#+1
   \   0000003C   0x7030             STRB     R0,[R6, #+0]
   \   0000003E   0xBD70             POP      {R4-R6,PC}
    475                }
    476              }
    477            } 
    478            else 
    479            {
    480               USBD_CtlError(pdev , req);                        
   \                     ??USBD_SetAddress_0: (+1)
   \   00000040   0x4620             MOV      R0,R4
   \   00000042   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   00000046   0x....             B.N      USBD_CtlError
    481            } 
    482          }
    483          
    484          /**
    485          * @brief  USBD_SetConfig
    486          *         Handle Set device configuration request
    487          * @param  pdev: device instance
    488          * @param  req: usb request
    489          * @retval status
    490          */

   \                                 In section .text, align 2, keep-with-next
    491          static void USBD_SetConfig(USBD_HandleTypeDef *pdev , 
    492                                     USBD_SetupReqTypedef *req)
    493          {
   \                     USBD_SetConfig: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    494            
    495            static uint8_t  cfgidx;
    496            
    497            cfgidx = (uint8_t)(req->wValue);                 
   \   00000006   0x....             LDR.N    R6,??DataTable0
   \   00000008   0x8868             LDRH     R0,[R5, #+2]
   \   0000000A   0x7030             STRB     R0,[R6, #+0]
    498            
    499            if (cfgidx > USBD_MAX_NUM_CONFIGURATION ) 
   \   0000000C   0x7831             LDRB     R1,[R6, #+0]
   \   0000000E   0x2902             CMP      R1,#+2
   \   00000010   0xDA3A             BGE.N    ??USBD_SetConfig_0
    500            {            
    501               USBD_CtlError(pdev , req);                              
    502            } 
    503            else 
    504            {
    505              switch (pdev->dev_state) 
   \   00000012   0xF894 0x01FC      LDRB     R0,[R4, #+508]
   \   00000016   0x2802             CMP      R0,#+2
   \   00000018   0xD002             BEQ.N    ??USBD_SetConfig_1
   \   0000001A   0x2803             CMP      R0,#+3
   \   0000001C   0xD010             BEQ.N    ??USBD_SetConfig_2
   \   0000001E   0xE033             B.N      ??USBD_SetConfig_0
    506              {
    507              case USBD_STATE_ADDRESSED:
    508                if (cfgidx) 
   \                     ??USBD_SetConfig_1: (+1)
   \   00000020   0x2900             CMP      R1,#+0
   \   00000022   0xD008             BEQ.N    ??USBD_SetConfig_3
    509                {                                			   							   							   				
    510                  pdev->dev_config = cfgidx;
   \   00000024   0x6061             STR      R1,[R4, #+4]
    511                  pdev->dev_state = USBD_STATE_CONFIGURED;
   \   00000026   0x2003             MOVS     R0,#+3
   \   00000028   0xF884 0x01FC      STRB     R0,[R4, #+508]
    512                  if(USBD_SetClassConfig(pdev , cfgidx) == USBD_FAIL)
   \   0000002C   0x4620             MOV      R0,R4
   \   0000002E   0x.... 0x....      BL       USBD_SetClassConfig
   \   00000032   0x2802             CMP      R0,#+2
   \   00000034   0xD023             BEQ.N    ??USBD_SetConfig_4
    513                  {
    514                    USBD_CtlError(pdev , req);  
    515                    return;
    516                  }
    517                  USBD_CtlSendStatus(pdev);
    518                }
    519                else 
    520                {
    521                   USBD_CtlSendStatus(pdev);
    522                }
    523                break;
    524                
    525              case USBD_STATE_CONFIGURED:
    526                if (cfgidx == 0) 
    527                {                           
    528                  pdev->dev_state = USBD_STATE_ADDRESSED;
    529                  pdev->dev_config = cfgidx;          
    530                  USBD_ClrClassConfig(pdev , cfgidx);
    531                  USBD_CtlSendStatus(pdev);
    532                  
    533                } 
    534                else  if (cfgidx != pdev->dev_config) 
    535                {
    536                  /* Clear old configuration */
    537                  USBD_ClrClassConfig(pdev , pdev->dev_config);
    538                  
    539                  /* set new configuration */
    540                  pdev->dev_config = cfgidx;
    541                  if(USBD_SetClassConfig(pdev , cfgidx) == USBD_FAIL)
    542                  {
    543                    USBD_CtlError(pdev , req);  
    544                    return;
    545                  }
    546                  USBD_CtlSendStatus(pdev);
    547                }
    548                else
    549                {
    550                  USBD_CtlSendStatus(pdev);
   \                     ??USBD_SetConfig_3: (+1)
   \   00000036   0x4620             MOV      R0,R4
   \   00000038   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   0000003C   0x.... 0x....      B.W      USBD_CtlSendStatus
    551                }
   \                     ??USBD_SetConfig_2: (+1)
   \   00000040   0x2900             CMP      R1,#+0
   \   00000042   0xD10D             BNE.N    ??USBD_SetConfig_5
   \   00000044   0x2002             MOVS     R0,#+2
   \   00000046   0xF884 0x01FC      STRB     R0,[R4, #+508]
   \   0000004A   0x2000             MOVS     R0,#+0
   \   0000004C   0x6060             STR      R0,[R4, #+4]
   \   0000004E   0x4601             MOV      R1,R0
   \   00000050   0x4620             MOV      R0,R4
   \   00000052   0x.... 0x....      BL       USBD_ClrClassConfig
   \   00000056   0x4620             MOV      R0,R4
   \   00000058   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   0000005C   0x.... 0x....      B.W      USBD_CtlSendStatus
   \                     ??USBD_SetConfig_5: (+1)
   \   00000060   0x6860             LDR      R0,[R4, #+4]
   \   00000062   0x4281             CMP      R1,R0
   \   00000064   0xD0E7             BEQ.N    ??USBD_SetConfig_3
   \   00000066   0x4601             MOV      R1,R0
   \   00000068   0xB2C9             UXTB     R1,R1
   \   0000006A   0x4620             MOV      R0,R4
   \   0000006C   0x.... 0x....      BL       USBD_ClrClassConfig
   \   00000070   0x7831             LDRB     R1,[R6, #+0]
   \   00000072   0x6061             STR      R1,[R4, #+4]
   \   00000074   0x4620             MOV      R0,R4
   \   00000076   0x.... 0x....      BL       USBD_SetClassConfig
   \   0000007A   0x2802             CMP      R0,#+2
   \   0000007C   0xD1DB             BNE.N    ??USBD_SetConfig_3
   \                     ??USBD_SetConfig_4: (+1)
   \   0000007E   0x4629             MOV      R1,R5
   \   00000080   0x4620             MOV      R0,R4
   \   00000082   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   00000086   0x....             B.N      USBD_CtlError
    552                break;
    553                
    554              default:					
    555                 USBD_CtlError(pdev , req);                     
   \                     ??USBD_SetConfig_0: (+1)
   \   00000088   0x4629             MOV      R1,R5
   \   0000008A   0x4620             MOV      R0,R4
   \   0000008C   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   00000090   0x....             B.N      USBD_CtlError
    556                break;
    557              }
    558            }
    559          }

   \                                 In section .bss, align 1
   \                     ??cfgidx:
   \   00000000                      DS8 1
    560          
    561          /**
    562          * @brief  USBD_GetConfig
    563          *         Handle Get device configuration request
    564          * @param  pdev: device instance
    565          * @param  req: usb request
    566          * @retval status
    567          */

   \                                 In section .text, align 2, keep-with-next
    568          static void USBD_GetConfig(USBD_HandleTypeDef *pdev , 
    569                                     USBD_SetupReqTypedef *req)
    570          {
    571          
    572            if (req->wLength != 1) 
   \                     USBD_GetConfig: (+1)
   \   00000000   0x88CA             LDRH     R2,[R1, #+6]
   \   00000002   0x2A01             CMP      R2,#+1
   \   00000004   0xD111             BNE.N    ??USBD_GetConfig_0
    573            {                   
    574               USBD_CtlError(pdev , req);
    575            }
    576            else 
    577            {
    578              switch (pdev->dev_state )  
   \   00000006   0xF890 0x21FC      LDRB     R2,[R0, #+508]
   \   0000000A   0x2A02             CMP      R2,#+2
   \   0000000C   0xD002             BEQ.N    ??USBD_GetConfig_1
   \   0000000E   0x2A03             CMP      R2,#+3
   \   00000010   0xD007             BEQ.N    ??USBD_GetConfig_2
   \   00000012   0xE00A             B.N      ??USBD_GetConfig_0
    579              {
    580              case USBD_STATE_ADDRESSED:                     
    581                pdev->dev_default_config = 0;
   \                     ??USBD_GetConfig_1: (+1)
   \   00000014   0x2100             MOVS     R1,#+0
   \   00000016   0x6081             STR      R1,[R0, #+8]
    582                USBD_CtlSendData (pdev, 
    583                                  (uint8_t *)&pdev->dev_default_config,
    584                                  1);
   \   00000018   0x2201             MOVS     R2,#+1
   \   0000001A   0xF100 0x0108      ADD      R1,R0,#+8
   \   0000001E   0x.... 0x....      B.W      USBD_CtlSendData
    585                break;
    586                
    587              case USBD_STATE_CONFIGURED:   
    588                
    589                USBD_CtlSendData (pdev, 
    590                                  (uint8_t *)&pdev->dev_config,
    591                                  1);
   \                     ??USBD_GetConfig_2: (+1)
   \   00000022   0x2201             MOVS     R2,#+1
   \   00000024   0x1D01             ADDS     R1,R0,#+4
   \   00000026   0x.... 0x....      B.W      USBD_CtlSendData
    592                break;
    593                
    594              default:
    595                 USBD_CtlError(pdev , req);
   \                     ??USBD_GetConfig_0: (+1)
   \   0000002A   0x....             B.N      USBD_CtlError
    596                break;
    597              }
    598            }
    599          }
    600          
    601          /**
    602          * @brief  USBD_GetStatus
    603          *         Handle Get Status request
    604          * @param  pdev: device instance
    605          * @param  req: usb request
    606          * @retval status
    607          */

   \                                 In section .text, align 2, keep-with-next
    608          static void USBD_GetStatus(USBD_HandleTypeDef *pdev , 
    609                                     USBD_SetupReqTypedef *req)
    610          {
    611            
    612              
    613            switch (pdev->dev_state) 
   \                     USBD_GetStatus: (+1)
   \   00000000   0xF500 0x72FE      ADD      R2,R0,#+508
   \   00000004   0x7813             LDRB     R3,[R2, #+0]
   \   00000006   0x1E9B             SUBS     R3,R3,#+2
   \   00000008   0x2B01             CMP      R3,#+1
   \   0000000A   0xD80B             BHI.N    ??USBD_GetStatus_0
    614            {
    615            case USBD_STATE_ADDRESSED:
    616            case USBD_STATE_CONFIGURED:
    617              
    618          #if ( USBD_SELF_POWERED == 1)
    619              pdev->dev_config_status = USB_CONFIG_SELF_POWERED;                                  
   \   0000000C   0x2101             MOVS     R1,#+1
   \   0000000E   0x60C1             STR      R1,[R0, #+12]
    620          #else
    621              pdev->dev_config_status = 0;                                   
    622          #endif
    623                                
    624              if (pdev->dev_remote_wakeup) 
   \   00000010   0x6891             LDR      R1,[R2, #+8]
   \   00000012   0x2900             CMP      R1,#+0
   \   00000014   0xD001             BEQ.N    ??USBD_GetStatus_1
    625              {
    626                 pdev->dev_config_status |= USB_CONFIG_REMOTE_WAKEUP;                                
   \   00000016   0x2103             MOVS     R1,#+3
   \   00000018   0x60C1             STR      R1,[R0, #+12]
    627              }
    628              
    629              USBD_CtlSendData (pdev, 
    630                                (uint8_t *)& pdev->dev_config_status,
    631                                2);
   \                     ??USBD_GetStatus_1: (+1)
   \   0000001A   0x2202             MOVS     R2,#+2
   \   0000001C   0xF100 0x010C      ADD      R1,R0,#+12
   \   00000020   0x.... 0x....      B.W      USBD_CtlSendData
    632              break;
    633              
    634            default :
    635              USBD_CtlError(pdev , req);                        
   \                     ??USBD_GetStatus_0: (+1)
   \   00000024   0x....             B.N      USBD_CtlError
    636              break;
    637            }
    638          }
    639          
    640          
    641          /**
    642          * @brief  USBD_SetFeature
    643          *         Handle Set device feature request
    644          * @param  pdev: device instance
    645          * @param  req: usb request
    646          * @retval status
    647          */

   \                                 In section .text, align 2, keep-with-next
    648          static void USBD_SetFeature(USBD_HandleTypeDef *pdev , 
    649                                      USBD_SetupReqTypedef *req)
    650          {
   \                     USBD_SetFeature: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    651          
    652            if (req->wValue == USB_FEATURE_REMOTE_WAKEUP)
   \   00000004   0x8848             LDRH     R0,[R1, #+2]
   \   00000006   0x2801             CMP      R0,#+1
   \   00000008   0xD10C             BNE.N    ??USBD_SetFeature_0
    653            {
    654              pdev->dev_remote_wakeup = 1;  
   \   0000000A   0xF504 0x7201      ADD      R2,R4,#+516
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0x6010             STR      R0,[R2, #+0]
    655              pdev->pClass->Setup (pdev, req);   
   \   00000012   0x4620             MOV      R0,R4
   \   00000014   0x6912             LDR      R2,[R2, #+16]
   \   00000016   0x6892             LDR      R2,[R2, #+8]
   \   00000018   0x4790             BLX      R2
    656              USBD_CtlSendStatus(pdev);
   \   0000001A   0x4620             MOV      R0,R4
   \   0000001C   0xE8BD 0x4010      POP      {R4,LR}
   \   00000020   0x.... 0x....      B.W      USBD_CtlSendStatus
    657            }
    658          
    659          }
   \                     ??USBD_SetFeature_0: (+1)
   \   00000024   0xBD10             POP      {R4,PC}          ;; return
    660          
    661          
    662          /**
    663          * @brief  USBD_ClrFeature
    664          *         Handle clear device feature request
    665          * @param  pdev: device instance
    666          * @param  req: usb request
    667          * @retval status
    668          */

   \                                 In section .text, align 2, keep-with-next
    669          static void USBD_ClrFeature(USBD_HandleTypeDef *pdev , 
    670                                      USBD_SetupReqTypedef *req)
    671          {
   \                     USBD_ClrFeature: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    672            switch (pdev->dev_state)
   \   00000004   0xF504 0x72FE      ADD      R2,R4,#+508
   \   00000008   0x7810             LDRB     R0,[R2, #+0]
   \   0000000A   0x1E80             SUBS     R0,R0,#+2
   \   0000000C   0x2801             CMP      R0,#+1
   \   0000000E   0xD80D             BHI.N    ??USBD_ClrFeature_0
    673            {
    674            case USBD_STATE_ADDRESSED:
    675            case USBD_STATE_CONFIGURED:
    676              if (req->wValue == USB_FEATURE_REMOTE_WAKEUP) 
   \   00000010   0x8848             LDRH     R0,[R1, #+2]
   \   00000012   0x2801             CMP      R0,#+1
   \   00000014   0xD10E             BNE.N    ??USBD_ClrFeature_1
    677              {
    678                pdev->dev_remote_wakeup = 0; 
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0x6090             STR      R0,[R2, #+8]
    679                pdev->pClass->Setup (pdev, req);   
   \   0000001A   0x4620             MOV      R0,R4
   \   0000001C   0x6992             LDR      R2,[R2, #+24]
   \   0000001E   0x6892             LDR      R2,[R2, #+8]
   \   00000020   0x4790             BLX      R2
    680                USBD_CtlSendStatus(pdev);
   \   00000022   0x4620             MOV      R0,R4
   \   00000024   0xE8BD 0x4010      POP      {R4,LR}
   \   00000028   0x.... 0x....      B.W      USBD_CtlSendStatus
    681              }
    682              break;
    683              
    684            default :
    685               USBD_CtlError(pdev , req);
   \                     ??USBD_ClrFeature_0: (+1)
   \   0000002C   0x4620             MOV      R0,R4
   \   0000002E   0xE8BD 0x4010      POP      {R4,LR}
   \   00000032   0x....             B.N      USBD_CtlError
    686              break;
    687            }
    688          }
   \                     ??USBD_ClrFeature_1: (+1)
   \   00000034   0xBD10             POP      {R4,PC}          ;; return
    689          
    690          /**
    691          * @brief  USBD_ParseSetupRequest 
    692          *         Copy buffer into setup structure
    693          * @param  pdev: device instance
    694          * @param  req: usb request
    695          * @retval None
    696          */
    697          

   \                                 In section .text, align 2, keep-with-next
    698          void USBD_ParseSetupRequest(USBD_SetupReqTypedef *req, uint8_t *pdata)
    699          {
    700            req->bmRequest     = *(uint8_t *)  (pdata);
   \                     USBD_ParseSetupRequest: (+1)
   \   00000000   0x780A             LDRB     R2,[R1, #+0]
   \   00000002   0x7002             STRB     R2,[R0, #+0]
    701            req->bRequest      = *(uint8_t *)  (pdata +  1);
   \   00000004   0x784A             LDRB     R2,[R1, #+1]
   \   00000006   0x7042             STRB     R2,[R0, #+1]
    702            req->wValue        = SWAPBYTE      (pdata +  2);
   \   00000008   0x788A             LDRB     R2,[R1, #+2]
   \   0000000A   0x78CB             LDRB     R3,[R1, #+3]
   \   0000000C   0xEB12 0x2203      ADDS     R2,R2,R3, LSL #+8
   \   00000010   0x8042             STRH     R2,[R0, #+2]
    703            req->wIndex        = SWAPBYTE      (pdata +  4);
   \   00000012   0x790A             LDRB     R2,[R1, #+4]
   \   00000014   0x794B             LDRB     R3,[R1, #+5]
   \   00000016   0xEB12 0x2203      ADDS     R2,R2,R3, LSL #+8
   \   0000001A   0x8082             STRH     R2,[R0, #+4]
    704            req->wLength       = SWAPBYTE      (pdata +  6);
   \   0000001C   0x798A             LDRB     R2,[R1, #+6]
   \   0000001E   0x79C9             LDRB     R1,[R1, #+7]
   \   00000020   0xEB12 0x2101      ADDS     R1,R2,R1, LSL #+8
   \   00000024   0x80C1             STRH     R1,[R0, #+6]
    705          
    706          }
   \   00000026   0x4770             BX       LR               ;; return
    707          
    708          /**
    709          * @brief  USBD_CtlError 
    710          *         Handle USB low level Error
    711          * @param  pdev: device instance
    712          * @param  req: usb request
    713          * @retval None
    714          */
    715          

   \                                 In section .text, align 2, keep-with-next
    716          void USBD_CtlError( USBD_HandleTypeDef *pdev ,
    717                                      USBD_SetupReqTypedef *req)
    718          {
   \                     USBD_CtlError: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    719            USBD_LL_StallEP(pdev , 0x80);
   \   00000004   0x2180             MOVS     R1,#+128
   \   00000006   0x.... 0x....      BL       USBD_LL_StallEP
    720            USBD_LL_StallEP(pdev , 0);
   \   0000000A   0x2100             MOVS     R1,#+0
   \   0000000C   0x4620             MOV      R0,R4
   \   0000000E   0xE8BD 0x4010      POP      {R4,LR}
   \   00000012   0x.... 0x....      B.W      USBD_LL_StallEP
    721          }
    722          
    723          
    724          /**
    725            * @brief  USBD_GetString
    726            *         Convert Ascii string into unicode one
    727            * @param  desc : descriptor buffer
    728            * @param  unicode : Formatted string buffer (unicode)
    729            * @param  len : descriptor length
    730            * @retval None
    731            */

   \                                 In section .text, align 2, keep-with-next
    732          void USBD_GetString(uint8_t *desc, uint8_t *unicode, uint16_t *len)
    733          {
   \                     USBD_GetString: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x4616             MOV      R6,R2
    734            uint8_t idx = 0;
    735            
    736            if (desc != NULL) 
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD016             BEQ.N    ??USBD_GetString_0
    737            {
    738              *len =  USBD_GetLen(desc) * 2 + 2;    
   \   0000000C   0x.... 0x....      BL       USBD_GetLen
   \   00000010   0x0040             LSLS     R0,R0,#+1
   \   00000012   0x1C80             ADDS     R0,R0,#+2
   \   00000014   0x8030             STRH     R0,[R6, #+0]
    739              unicode[idx++] = *len;
   \   00000016   0x8830             LDRH     R0,[R6, #+0]
   \   00000018   0x7028             STRB     R0,[R5, #+0]
    740              unicode[idx++] =  USB_DESC_TYPE_STRING;
   \   0000001A   0x2003             MOVS     R0,#+3
   \   0000001C   0x7068             STRB     R0,[R5, #+1]
   \   0000001E   0x2002             MOVS     R0,#+2
   \   00000020   0xE008             B.N      ??USBD_GetString_1
    741              
    742              while (*desc != '\0') 
    743              {
    744                unicode[idx++] = *desc++;
   \                     ??USBD_GetString_2: (+1)
   \   00000022   0xF814 0x1B01      LDRB     R1,[R4], #+1
   \   00000026   0xB2C0             UXTB     R0,R0
   \   00000028   0x5541             STRB     R1,[R0, R5]
   \   0000002A   0x1C40             ADDS     R0,R0,#+1
    745                unicode[idx++] =  0x00;
   \   0000002C   0x2100             MOVS     R1,#+0
   \   0000002E   0xB2C0             UXTB     R0,R0
   \   00000030   0x5541             STRB     R1,[R0, R5]
   \   00000032   0x1C40             ADDS     R0,R0,#+1
    746              }
   \                     ??USBD_GetString_1: (+1)
   \   00000034   0x7821             LDRB     R1,[R4, #+0]
   \   00000036   0x2900             CMP      R1,#+0
   \   00000038   0xD1F3             BNE.N    ??USBD_GetString_2
    747            } 
    748          }
   \                     ??USBD_GetString_0: (+1)
   \   0000003A   0xBD70             POP      {R4-R6,PC}       ;; return
    749          
    750          /**
    751            * @brief  USBD_GetLen
    752            *         return the string length
    753             * @param  buf : pointer to the ascii string buffer
    754            * @retval string length
    755            */

   \                                 In section .text, align 2, keep-with-next
    756          static uint8_t USBD_GetLen(uint8_t *buf)
    757          {
    758              uint8_t  len = 0;
   \                     USBD_GetLen: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0xE001             B.N      ??USBD_GetLen_0
    759          
    760              while (*buf != '\0') 
    761              {
    762                  len++;
   \                     ??USBD_GetLen_1: (+1)
   \   00000004   0x1C49             ADDS     R1,R1,#+1
    763                  buf++;
   \   00000006   0x1C40             ADDS     R0,R0,#+1
    764              }
   \                     ??USBD_GetLen_0: (+1)
   \   00000008   0x7802             LDRB     R2,[R0, #+0]
   \   0000000A   0x2A00             CMP      R2,#+0
   \   0000000C   0xD1FA             BNE.N    ??USBD_GetLen_1
    765          
    766              return len;
   \   0000000E   0x4608             MOV      R0,R1
   \   00000010   0xB2C0             UXTB     R0,R0
   \   00000012   0x4770             BX       LR               ;; return
    767          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0:
   \   00000000   0x........         DC32     ??cfgidx
    768          /**
    769            * @}
    770            */ 
    771          
    772          
    773          /**
    774            * @}
    775            */ 
    776          
    777          
    778          /**
    779            * @}
    780            */ 
    781          
    782          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   USBD_ClrFeature
         8   -- Indirect call
         0   -> USBD_CtlError
         0   -> USBD_CtlSendStatus
       8   USBD_CtlError
         0   -> USBD_LL_StallEP
         8   -> USBD_LL_StallEP
       0   USBD_GetConfig
         0   -> USBD_CtlError
         0   -> USBD_CtlSendData
      16   USBD_GetDescriptor
        16   -- Indirect call
        16   -> USBD_CtlError
        16   -> USBD_CtlSendData
       0   USBD_GetLen
       0   USBD_GetStatus
         0   -> USBD_CtlError
         0   -> USBD_CtlSendData
      16   USBD_GetString
        16   -> USBD_GetLen
       0   USBD_ParseSetupRequest
      16   USBD_SetAddress
         0   -> USBD_CtlError
        16   -> USBD_CtlSendStatus
        16   -> USBD_LL_SetUSBAddress
      16   USBD_SetConfig
        16   -> USBD_ClrClassConfig
         0   -> USBD_CtlError
         0   -> USBD_CtlSendStatus
        16   -> USBD_SetClassConfig
       8   USBD_SetFeature
         8   -- Indirect call
         0   -> USBD_CtlSendStatus
       8   USBD_StdDevReq
         8   -> USBD_ClrFeature
         8   -> USBD_CtlError
         8   -> USBD_GetConfig
         8   -> USBD_GetDescriptor
         8   -> USBD_GetStatus
         8   -> USBD_SetAddress
         8   -> USBD_SetConfig
         8   -> USBD_SetFeature
      16   USBD_StdEPReq
        16   -- Indirect call
        16   -> USBD_CtlError
        16   -> USBD_CtlSendData
        16   -> USBD_CtlSendStatus
        16   -> USBD_LL_ClearStallEP
        16   -> USBD_LL_IsStallEP
        16   -> USBD_LL_StallEP
      16   USBD_StdItfReq
        16   -- Indirect call
        16   -> USBD_CtlError
        16   -> USBD_CtlSendStatus


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable0
      54  USBD_ClrFeature
      22  USBD_CtlError
      44  USBD_GetConfig
     274  USBD_GetDescriptor
      20  USBD_GetLen
      38  USBD_GetStatus
      60  USBD_GetString
      40  USBD_ParseSetupRequest
      72  USBD_SetAddress
     146  USBD_SetConfig
      38  USBD_SetFeature
      72  USBD_StdDevReq
     280  USBD_StdEPReq
      54  USBD_StdItfReq
       1  cfgidx

 
     1 byte  in section .bss
 1 218 bytes in section .text
 
 1 218 bytes of CODE memory
     1 byte  of DATA memory

Errors: none
Warnings: none
