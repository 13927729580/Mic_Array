###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.2.10312/W32 for ARM       22/Feb/2016  17:57:55
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Middlewares\ST\STM32_USB_Device_Library\Core\Src\usbd_ctlreq.c
#    Command line =  
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Middlewares\ST\STM32_USB_Device_Library\Core\Src\usbd_ctlreq.c
#        -D USE_HAL_DRIVER -D STM32F746xx -D USE_STM32746G_DISCO -D
#        USE_IOEXPANDER -D USE_USB_FS -lC
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
#        -lA
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
#        -o
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj
#        --no_unroll --debug --endian=little --cpu=Cortex-M7 -e --fpu=VFPv5_sp
#        --dlib_config "D:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Full.h" -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\CMSIS\Device\ST\STM32F7xx\Include\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\STM32F7xx_HAL_Driver\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\STM32746G-Discovery\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\Components\Common\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Log\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Fonts\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\CPU\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_Device_Library\Core\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Core\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Class\MSC\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\drivers\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_Audio\Addons\PDM\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_Device_Library\Class\AUDIO\Inc\
#        -Ohs --use_c++_inline --require_prototypes -I "D:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.3\arm\CMSIS\Include\" -D
#        ARM_MATH_CM7
#    List file    =  
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List\usbd_ctlreq.lst
#    Object file  =  
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj\usbd_ctlreq.o
#
###############################################################################

D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Middlewares\ST\STM32_USB_Device_Library\Core\Src\usbd_ctlreq.c
      1          /**
                   ^
Warning[Pa050]: non-native end of line sequence detected (this diagnostic is
          only issued once)
      2            ******************************************************************************
      3            * @file    usbd_req.c
      4            * @author  MCD Application Team
      5            * @version V2.4.1
      6            * @date    19-June-2015 
      7            * @brief   This file provides the standard USB requests following chapter 9.
      8            ******************************************************************************
      9            * @attention
     10            *
     11            * <h2><center>&copy; COPYRIGHT 2015 STMicroelectronics</center></h2>
     12            *
     13            * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
     14            * You may not use this file except in compliance with the License.
     15            * You may obtain a copy of the License at:
     16            *
     17            *        http://www.st.com/software_license_agreement_liberty_v2
     18            *
     19            * Unless required by applicable law or agreed to in writing, software 
     20            * distributed under the License is distributed on an "AS IS" BASIS, 
     21            * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     22            * See the License for the specific language governing permissions and
     23            * limitations under the License.
     24            *
     25            ******************************************************************************
     26            */ 
     27          
     28          /* Includes ------------------------------------------------------------------*/
     29          #include "usbd_ctlreq.h"
     30          #include "usbd_ioreq.h"
     31          
     32          
     33          /** @addtogroup STM32_USBD_STATE_DEVICE_LIBRARY
     34            * @{
     35            */
     36          
     37          
     38          /** @defgroup USBD_REQ 
     39            * @brief USB standard requests module
     40            * @{
     41            */ 
     42          
     43          /** @defgroup USBD_REQ_Private_TypesDefinitions
     44            * @{
     45            */ 
     46          /**
     47            * @}
     48            */ 
     49          
     50          
     51          /** @defgroup USBD_REQ_Private_Defines
     52            * @{
     53            */ 
     54          
     55          /**
     56            * @}
     57            */ 
     58          
     59          
     60          /** @defgroup USBD_REQ_Private_Macros
     61            * @{
     62            */ 
     63          /**
     64            * @}
     65            */ 
     66          
     67          
     68          /** @defgroup USBD_REQ_Private_Variables
     69            * @{
     70            */ 
     71          /**
     72            * @}
     73            */ 
     74          
     75          
     76          /** @defgroup USBD_REQ_Private_FunctionPrototypes
     77            * @{
     78            */ 
     79          static void USBD_GetDescriptor(USBD_HandleTypeDef *pdev , 
     80                                         USBD_SetupReqTypedef *req);
     81          
     82          static void USBD_SetAddress(USBD_HandleTypeDef *pdev , 
     83                                      USBD_SetupReqTypedef *req);
     84          
     85          static void USBD_SetConfig(USBD_HandleTypeDef *pdev , 
     86                                     USBD_SetupReqTypedef *req);
     87          
     88          static void USBD_GetConfig(USBD_HandleTypeDef *pdev , 
     89                                     USBD_SetupReqTypedef *req);
     90          
     91          static void USBD_GetStatus(USBD_HandleTypeDef *pdev , 
     92                                     USBD_SetupReqTypedef *req);
     93          
     94          static void USBD_SetFeature(USBD_HandleTypeDef *pdev , 
     95                                      USBD_SetupReqTypedef *req);
     96          
     97          static void USBD_ClrFeature(USBD_HandleTypeDef *pdev , 
     98                                      USBD_SetupReqTypedef *req);
     99          
    100          static uint8_t USBD_GetLen(uint8_t *buf);
    101          
    102          /**
    103            * @}
    104            */ 
    105          
    106          
    107          /** @defgroup USBD_REQ_Private_Functions
    108            * @{
    109            */ 
    110          
    111          
    112          /**
    113          * @brief  USBD_StdDevReq
    114          *         Handle standard usb device requests
    115          * @param  pdev: device instance
    116          * @param  req: usb request
    117          * @retval status
    118          */

   \                                 In section .text, align 4, keep-with-next
    119          USBD_StatusTypeDef  USBD_StdDevReq (USBD_HandleTypeDef *pdev , USBD_SetupReqTypedef  *req)
    120          {
   \                     USBD_StdDevReq: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB081             SUB      SP,SP,#+4
   \   00000004   0x4604             MOV      R4,R0
    121            USBD_StatusTypeDef ret = USBD_OK;  
    122            
    123            switch (req->bRequest) 
   \   00000006   0x7848             LDRB     R0,[R1, #+1]
   \   00000008   0x2809             CMP      R0,#+9
   \   0000000A   0xD850             BHI.N    ??USBD_StdDevReq_1
   \   0000000C   0xE8DF 0xF000      TBB      [PC, R0]
   \                     ??USBD_StdDevReq_0:
   \   00000010   0x79 0x91          DC8      0x79,0x91,0x4F,0x8D
   \              0x4F 0x8D    
   \   00000014   0x4F 0x0B          DC8      0x4F,0xB,0x5,0x4F
   \              0x05 0x4F    
   \   00000018   0x67 0x2A          DC8      0x67,0x2A
    124            {
    125            case USB_REQ_GET_DESCRIPTOR: 
    126              
    127              USBD_GetDescriptor (pdev, req) ;
   \                     ??USBD_StdDevReq_2: (+1)
   \   0000001A   0x4620             MOV      R0,R4
   \   0000001C   0x.... 0x....      BL       USBD_GetDescriptor
    128              break;
    129              
    130            case USB_REQ_SET_ADDRESS:                      
    131              USBD_SetAddress(pdev, req);
    132              break;
    133              
    134            case USB_REQ_SET_CONFIGURATION:                    
    135              USBD_SetConfig (pdev , req);
    136              break;
    137              
    138            case USB_REQ_GET_CONFIGURATION:                 
    139              USBD_GetConfig (pdev , req);
    140              break;
    141              
    142            case USB_REQ_GET_STATUS:                                  
    143              USBD_GetStatus (pdev , req);
    144              break;
    145              
    146              
    147            case USB_REQ_SET_FEATURE:   
    148              USBD_SetFeature (pdev , req);    
    149              break;
    150              
    151            case USB_REQ_CLEAR_FEATURE:                                   
    152              USBD_ClrFeature (pdev , req);
    153              break;
    154              
    155            default:  
    156              USBD_CtlError(pdev , req);
    157              break;
    158            }
    159            
    160            return ret;
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0xB001             ADD      SP,SP,#+4
   \   00000024   0xBD30             POP      {R4,R5,PC}
   \                     ??USBD_StdDevReq_3: (+1)
   \   00000026   0x8888             LDRH     R0,[R1, #+4]
   \   00000028   0x2800             CMP      R0,#+0
   \   0000002A   0xBF04             ITT      EQ 
   \   0000002C   0x88C8             LDRHEQ   R0,[R1, #+6]
   \   0000002E   0x2800             CMPEQ    R0,#+0
   \   00000030   0xD13D             BNE.N    ??USBD_StdDevReq_1
   \   00000032   0x7888             LDRB     R0,[R1, #+2]
   \   00000034   0xF000 0x057F      AND      R5,R0,#0x7F
   \   00000038   0xF894 0x01FC      LDRB     R0,[R4, #+508]
   \   0000003C   0x2803             CMP      R0,#+3
   \   0000003E   0xD036             BEQ.N    ??USBD_StdDevReq_1
   \   00000040   0xF884 0x51FE      STRB     R5,[R4, #+510]
   \   00000044   0x4629             MOV      R1,R5
   \   00000046   0x4620             MOV      R0,R4
   \   00000048   0x.... 0x....      BL       USBD_LL_SetUSBAddress
   \   0000004C   0x4620             MOV      R0,R4
   \   0000004E   0x.... 0x....      BL       USBD_CtlSendStatus
   \   00000052   0x2D00             CMP      R5,#+0
   \   00000054   0xBF14             ITE      NE 
   \   00000056   0x2002             MOVNE    R0,#+2
   \   00000058   0x2001             MOVEQ    R0,#+1
   \   0000005A   0xF884 0x01FC      STRB     R0,[R4, #+508]
   \   0000005E   0x2000             MOVS     R0,#+0
   \   00000060   0xB001             ADD      SP,SP,#+4
   \   00000062   0xBD30             POP      {R4,R5,PC}
   \                     ??USBD_StdDevReq_4: (+1)
   \   00000064   0x8848             LDRH     R0,[R1, #+2]
   \   00000066   0x....             LDR.N    R5,??DataTable0
   \   00000068   0x7028             STRB     R0,[R5, #+0]
   \   0000006A   0x7828             LDRB     R0,[R5, #+0]
   \   0000006C   0x2802             CMP      R0,#+2
   \   0000006E   0xDA1E             BGE.N    ??USBD_StdDevReq_1
   \   00000070   0xF894 0x11FC      LDRB     R1,[R4, #+508]
   \   00000074   0x2902             CMP      R1,#+2
   \   00000076   0xD025             BEQ.N    ??USBD_StdDevReq_5
   \   00000078   0x2903             CMP      R1,#+3
   \   0000007A   0xD118             BNE.N    ??USBD_StdDevReq_1
   \   0000007C   0xB948             CBNZ.N   R0,??USBD_StdDevReq_6
   \   0000007E   0x2002             MOVS     R0,#+2
   \   00000080   0x2100             MOVS     R1,#+0
   \   00000082   0xF884 0x01FC      STRB     R0,[R4, #+508]
   \   00000086   0x2000             MOVS     R0,#+0
   \   00000088   0x6060             STR      R0,[R4, #+4]
   \   0000008A   0x4620             MOV      R0,R4
   \   0000008C   0x.... 0x....      BL       USBD_ClrClassConfig
   \   00000090   0xE05F             B.N      ??USBD_StdDevReq_7
   \                     ??USBD_StdDevReq_6: (+1)
   \   00000092   0x6861             LDR      R1,[R4, #+4]
   \   00000094   0x4288             CMP      R0,R1
   \   00000096   0xD05C             BEQ.N    ??USBD_StdDevReq_7
   \   00000098   0xB2C9             UXTB     R1,R1
   \   0000009A   0x4620             MOV      R0,R4
   \   0000009C   0x.... 0x....      BL       USBD_ClrClassConfig
   \   000000A0   0x7829             LDRB     R1,[R5, #+0]
   \   000000A2   0x4620             MOV      R0,R4
   \   000000A4   0x6061             STR      R1,[R4, #+4]
   \   000000A6   0x.... 0x....      BL       USBD_SetClassConfig
   \   000000AA   0x2802             CMP      R0,#+2
   \   000000AC   0xD151             BNE.N    ??USBD_StdDevReq_7
   \                     ??USBD_StdDevReq_1: (+1)
   \   000000AE   0x2180             MOVS     R1,#+128
   \   000000B0   0x4620             MOV      R0,R4
   \   000000B2   0x.... 0x....      BL       USBD_LL_StallEP
   \   000000B6   0x2100             MOVS     R1,#+0
   \   000000B8   0x4620             MOV      R0,R4
   \   000000BA   0x.... 0x....      BL       USBD_LL_StallEP
   \   000000BE   0x2000             MOVS     R0,#+0
   \   000000C0   0xB001             ADD      SP,SP,#+4
   \   000000C2   0xBD30             POP      {R4,R5,PC}
   \                     ??USBD_StdDevReq_5: (+1)
   \   000000C4   0x2800             CMP      R0,#+0
   \   000000C6   0xD044             BEQ.N    ??USBD_StdDevReq_7
   \   000000C8   0x2103             MOVS     R1,#+3
   \   000000CA   0x6060             STR      R0,[R4, #+4]
   \   000000CC   0xF884 0x11FC      STRB     R1,[R4, #+508]
   \   000000D0   0x4601             MOV      R1,R0
   \   000000D2   0x4620             MOV      R0,R4
   \   000000D4   0x.... 0x....      BL       USBD_SetClassConfig
   \   000000D8   0x2802             CMP      R0,#+2
   \   000000DA   0xD0E8             BEQ.N    ??USBD_StdDevReq_1
   \   000000DC   0xE039             B.N      ??USBD_StdDevReq_7
   \                     ??USBD_StdDevReq_8: (+1)
   \   000000DE   0x88C8             LDRH     R0,[R1, #+6]
   \   000000E0   0x2801             CMP      R0,#+1
   \   000000E2   0xD1E4             BNE.N    ??USBD_StdDevReq_1
   \   000000E4   0xF894 0x01FC      LDRB     R0,[R4, #+508]
   \   000000E8   0x2802             CMP      R0,#+2
   \   000000EA   0xD004             BEQ.N    ??USBD_StdDevReq_9
   \   000000EC   0x2803             CMP      R0,#+3
   \   000000EE   0xD1DE             BNE.N    ??USBD_StdDevReq_1
   \   000000F0   0x2201             MOVS     R2,#+1
   \   000000F2   0x1D21             ADDS     R1,R4,#+4
   \   000000F4   0xE013             B.N      ??USBD_StdDevReq_10
   \                     ??USBD_StdDevReq_9: (+1)
   \   000000F6   0x2000             MOVS     R0,#+0
   \   000000F8   0x2201             MOVS     R2,#+1
   \   000000FA   0x60A0             STR      R0,[R4, #+8]
   \   000000FC   0xF104 0x0108      ADD      R1,R4,#+8
   \   00000100   0xE00D             B.N      ??USBD_StdDevReq_10
   \                     ??USBD_StdDevReq_11: (+1)
   \   00000102   0xF894 0x01FC      LDRB     R0,[R4, #+508]
   \   00000106   0x1E80             SUBS     R0,R0,#+2
   \   00000108   0x2801             CMP      R0,#+1
   \   0000010A   0xD8D0             BHI.N    ??USBD_StdDevReq_1
   \   0000010C   0xF8D4 0x1204      LDR      R1,[R4, #+516]
   \   00000110   0x2001             MOVS     R0,#+1
   \   00000112   0xB101             CBZ.N    R1,??USBD_StdDevReq_12
   \   00000114   0x2003             MOVS     R0,#+3
   \                     ??USBD_StdDevReq_12: (+1)
   \   00000116   0x60E0             STR      R0,[R4, #+12]
   \   00000118   0x2202             MOVS     R2,#+2
   \   0000011A   0xF104 0x010C      ADD      R1,R4,#+12
   \                     ??USBD_StdDevReq_10: (+1)
   \   0000011E   0x4620             MOV      R0,R4
   \   00000120   0x.... 0x....      BL       USBD_CtlSendData
   \   00000124   0x2000             MOVS     R0,#+0
   \   00000126   0xB001             ADD      SP,SP,#+4
   \   00000128   0xBD30             POP      {R4,R5,PC}
   \                     ??USBD_StdDevReq_13: (+1)
   \   0000012A   0x8848             LDRH     R0,[R1, #+2]
   \   0000012C   0x2801             CMP      R0,#+1
   \   0000012E   0xD113             BNE.N    ??USBD_StdDevReq_14
   \   00000130   0xE008             B.N      ??USBD_StdDevReq_15
   \                     ??USBD_StdDevReq_16: (+1)
   \   00000132   0xF894 0x01FC      LDRB     R0,[R4, #+508]
   \   00000136   0x1E80             SUBS     R0,R0,#+2
   \   00000138   0x2801             CMP      R0,#+1
   \   0000013A   0xD8B8             BHI.N    ??USBD_StdDevReq_1
   \   0000013C   0x8848             LDRH     R0,[R1, #+2]
   \   0000013E   0x2801             CMP      R0,#+1
   \   00000140   0xD10A             BNE.N    ??USBD_StdDevReq_14
   \   00000142   0x2000             MOVS     R0,#+0
   \                     ??USBD_StdDevReq_15: (+1)
   \   00000144   0xF8D4 0x2214      LDR      R2,[R4, #+532]
   \   00000148   0xF8C4 0x0204      STR      R0,[R4, #+516]
   \   0000014C   0x4620             MOV      R0,R4
   \   0000014E   0x6892             LDR      R2,[R2, #+8]
   \   00000150   0x4790             BLX      R2
   \                     ??USBD_StdDevReq_7: (+1)
   \   00000152   0x4620             MOV      R0,R4
   \   00000154   0x.... 0x....      BL       USBD_CtlSendStatus
   \                     ??USBD_StdDevReq_14: (+1)
   \   00000158   0x2000             MOVS     R0,#+0
   \   0000015A   0xB001             ADD      SP,SP,#+4
   \   0000015C   0xBD30             POP      {R4,R5,PC}       ;; return
    161          }
    162          
    163          /**
    164          * @brief  USBD_StdItfReq
    165          *         Handle standard usb interface requests
    166          * @param  pdev: device instance
    167          * @param  req: usb request
    168          * @retval status
    169          */

   \                                 In section .text, align 2, keep-with-next
    170          USBD_StatusTypeDef  USBD_StdItfReq (USBD_HandleTypeDef *pdev , USBD_SetupReqTypedef  *req)
    171          {
   \                     USBD_StdItfReq: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0xB081             SUB      SP,SP,#+4
   \   00000006   0x460D             MOV      R5,R1
    172            USBD_StatusTypeDef ret = USBD_OK; 
    173            
    174            switch (pdev->dev_state) 
   \   00000008   0xF894 0x01FC      LDRB     R0,[R4, #+508]
   \   0000000C   0x2803             CMP      R0,#+3
   \   0000000E   0xD10F             BNE.N    ??USBD_StdItfReq_0
    175            {
    176            case USBD_STATE_CONFIGURED:
    177              
    178              if (LOBYTE(req->wIndex) <= USBD_MAX_NUM_INTERFACES) 
   \   00000010   0x7928             LDRB     R0,[R5, #+4]
   \   00000012   0x2803             CMP      R0,#+3
   \   00000014   0xDA0C             BGE.N    ??USBD_StdItfReq_0
    179              {
    180                pdev->pClass->Setup (pdev, req); 
   \   00000016   0xF8D4 0x2214      LDR      R2,[R4, #+532]
   \   0000001A   0x4620             MOV      R0,R4
   \   0000001C   0x6892             LDR      R2,[R2, #+8]
   \   0000001E   0x4790             BLX      R2
    181                
    182                if((req->wLength == 0)&& (ret == USBD_OK))
   \   00000020   0x88E8             LDRH     R0,[R5, #+6]
   \   00000022   0xB968             CBNZ.N   R0,??USBD_StdItfReq_1
    183                {
    184                   USBD_CtlSendStatus(pdev);
   \   00000024   0x4620             MOV      R0,R4
   \   00000026   0x.... 0x....      BL       USBD_CtlSendStatus
    185                }
    186              } 
    187              else 
    188              {                                               
    189                 USBD_CtlError(pdev , req);
    190              }
    191              break;
    192              
    193            default:
    194               USBD_CtlError(pdev , req);
    195              break;
    196            }
    197            return USBD_OK;
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0xB001             ADD      SP,SP,#+4
   \   0000002E   0xBD30             POP      {R4,R5,PC}
   \                     ??USBD_StdItfReq_0: (+1)
   \   00000030   0x2180             MOVS     R1,#+128
   \   00000032   0x4620             MOV      R0,R4
   \   00000034   0x.... 0x....      BL       USBD_LL_StallEP
   \   00000038   0x2100             MOVS     R1,#+0
   \   0000003A   0x4620             MOV      R0,R4
   \   0000003C   0x.... 0x....      BL       USBD_LL_StallEP
   \                     ??USBD_StdItfReq_1: (+1)
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0xB001             ADD      SP,SP,#+4
   \   00000044   0xBD30             POP      {R4,R5,PC}       ;; return
    198          }
    199          
    200          /**
    201          * @brief  USBD_StdEPReq
    202          *         Handle standard usb endpoint requests
    203          * @param  pdev: device instance
    204          * @param  req: usb request
    205          * @retval status
    206          */

   \                                 In section .text, align 4, keep-with-next
    207          USBD_StatusTypeDef  USBD_StdEPReq (USBD_HandleTypeDef *pdev , USBD_SetupReqTypedef  *req)
    208          {
   \                     USBD_StdEPReq: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0xB081             SUB      SP,SP,#+4
    209            
    210            uint8_t   ep_addr;
    211            USBD_StatusTypeDef ret = USBD_OK; 
    212            USBD_EndpointTypeDef   *pep;
    213            ep_addr  = LOBYTE(req->wIndex);   
    214            
    215            /* Check if it is a class request */
    216            if ((req->bmRequest & 0x60) == 0x20)
   \   00000008   0x7828             LDRB     R0,[R5, #+0]
   \   0000000A   0x7929             LDRB     R1,[R5, #+4]
   \   0000000C   0xF000 0x0060      AND      R0,R0,#0x60
   \   00000010   0x2820             CMP      R0,#+32
   \   00000012   0xD108             BNE.N    ??USBD_StdEPReq_1
    217            {
    218              pdev->pClass->Setup (pdev, req);
   \   00000014   0xF8D4 0x2214      LDR      R2,[R4, #+532]
   \   00000018   0x4629             MOV      R1,R5
   \   0000001A   0x4620             MOV      R0,R4
   \   0000001C   0x6892             LDR      R2,[R2, #+8]
   \   0000001E   0x4790             BLX      R2
    219              
    220              return USBD_OK;
    221            }
    222            
    223            switch (req->bRequest) 
    224            {
    225              
    226            case USB_REQ_SET_FEATURE :
    227              
    228              switch (pdev->dev_state) 
    229              {
    230              case USBD_STATE_ADDRESSED:          
    231                if ((ep_addr != 0x00) && (ep_addr != 0x80)) 
    232                {
    233                  USBD_LL_StallEP(pdev , ep_addr);
    234                }
    235                break;	
    236                
    237              case USBD_STATE_CONFIGURED:   
    238                if (req->wValue == USB_FEATURE_EP_HALT)
    239                {
    240                  if ((ep_addr != 0x00) && (ep_addr != 0x80)) 
    241                  { 
    242                    USBD_LL_StallEP(pdev , ep_addr);
    243                    
    244                  }
    245                }
    246                pdev->pClass->Setup (pdev, req);   
    247                USBD_CtlSendStatus(pdev);
    248                
    249                break;
    250                
    251              default:                         
    252                USBD_CtlError(pdev , req);
    253                break;    
    254              }
    255              break;
    256              
    257            case USB_REQ_CLEAR_FEATURE :
    258              
    259              switch (pdev->dev_state) 
    260              {
    261              case USBD_STATE_ADDRESSED:          
    262                if ((ep_addr != 0x00) && (ep_addr != 0x80)) 
    263                {
    264                  USBD_LL_StallEP(pdev , ep_addr);
    265                }
    266                break;	
    267                
    268              case USBD_STATE_CONFIGURED:   
    269                if (req->wValue == USB_FEATURE_EP_HALT)
    270                {
    271                  if ((ep_addr & 0x7F) != 0x00) 
    272                  {        
    273                    USBD_LL_ClearStallEP(pdev , ep_addr);
    274                    pdev->pClass->Setup (pdev, req);
    275                  }
    276                  USBD_CtlSendStatus(pdev);
    277                }
    278                break;
    279                
    280              default:                         
    281                USBD_CtlError(pdev , req);
    282                break;    
    283              }
    284              break;
    285              
    286            case USB_REQ_GET_STATUS:                  
    287              switch (pdev->dev_state) 
    288              {
    289              case USBD_STATE_ADDRESSED:          
    290                if ((ep_addr & 0x7F) != 0x00) 
    291                {
    292                  USBD_LL_StallEP(pdev , ep_addr);
    293                }
    294                break;	
    295                
    296              case USBD_STATE_CONFIGURED:
    297                pep = ((ep_addr & 0x80) == 0x80) ? &pdev->ep_in[ep_addr & 0x7F]:\
    298                                                   &pdev->ep_out[ep_addr & 0x7F];
    299                if(USBD_LL_IsStallEP(pdev, ep_addr))
    300                {
    301                  pep->status = 0x0001;     
    302                }
    303                else
    304                {
    305                  pep->status = 0x0000;  
    306                }
    307                
    308                USBD_CtlSendData (pdev,
    309                                  (uint8_t *)&pep->status,
    310                                  2);
    311                break;
    312                
    313              default:                         
    314                USBD_CtlError(pdev , req);
    315                break;
    316              }
    317              break;
    318              
    319            default:
    320              break;
    321            }
    322            return ret;
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0xB001             ADD      SP,SP,#+4
   \   00000024   0xBD30             POP      {R4,R5,PC}
   \                     ??USBD_StdEPReq_1: (+1)
   \   00000026   0x7868             LDRB     R0,[R5, #+1]
   \   00000028   0x2803             CMP      R0,#+3
   \   0000002A   0xD86C             BHI.N    ??USBD_StdEPReq_2
   \   0000002C   0xE8DF 0xF000      TBB      [PC, R0]
   \                     ??USBD_StdEPReq_0:
   \   00000030   0x3E 0x1D          DC8      0x3E,0x1D,0x6B,0x2
   \              0x6B 0x02    
   \                     ??USBD_StdEPReq_3: (+1)
   \   00000034   0xF894 0x01FC      LDRB     R0,[R4, #+508]
   \   00000038   0x2802             CMP      R0,#+2
   \   0000003A   0xD002             BEQ.N    ??USBD_StdEPReq_4
   \   0000003C   0x2803             CMP      R0,#+3
   \   0000003E   0xD005             BEQ.N    ??USBD_StdEPReq_5
   \   00000040   0xE059             B.N      ??USBD_StdEPReq_6
   \                     ??USBD_StdEPReq_4: (+1)
   \   00000042   0x2900             CMP      R1,#+0
   \   00000044   0xBF18             IT       NE 
   \   00000046   0x2980             CMPNE    R1,#+128
   \   00000048   0xD05D             BEQ.N    ??USBD_StdEPReq_2
   \   0000004A   0xE059             B.N      ??USBD_StdEPReq_7
   \                     ??USBD_StdEPReq_5: (+1)
   \   0000004C   0x8868             LDRH     R0,[R5, #+2]
   \   0000004E   0xB928             CBNZ.N   R0,??USBD_StdEPReq_8
   \   00000050   0x2900             CMP      R1,#+0
   \   00000052   0xBF1E             ITTT     NE 
   \   00000054   0x2980             CMPNE    R1,#+128
   \   00000056   0x4620             MOVNE    R0,R4
   \   00000058   0x.... 0x....      BLNE     USBD_LL_StallEP
   \                     ??USBD_StdEPReq_8: (+1)
   \   0000005C   0xF8D4 0x2214      LDR      R2,[R4, #+532]
   \   00000060   0x4629             MOV      R1,R5
   \   00000062   0x4620             MOV      R0,R4
   \   00000064   0x6892             LDR      R2,[R2, #+8]
   \   00000066   0x4790             BLX      R2
   \   00000068   0xE01A             B.N      ??USBD_StdEPReq_9
   \                     ??USBD_StdEPReq_10: (+1)
   \   0000006A   0xF894 0x01FC      LDRB     R0,[R4, #+508]
   \   0000006E   0x2802             CMP      R0,#+2
   \   00000070   0xD002             BEQ.N    ??USBD_StdEPReq_11
   \   00000072   0x2803             CMP      R0,#+3
   \   00000074   0xD005             BEQ.N    ??USBD_StdEPReq_12
   \   00000076   0xE03E             B.N      ??USBD_StdEPReq_6
   \                     ??USBD_StdEPReq_11: (+1)
   \   00000078   0x2900             CMP      R1,#+0
   \   0000007A   0xBF18             IT       NE 
   \   0000007C   0x2980             CMPNE    R1,#+128
   \   0000007E   0xD042             BEQ.N    ??USBD_StdEPReq_2
   \   00000080   0xE03E             B.N      ??USBD_StdEPReq_7
   \                     ??USBD_StdEPReq_12: (+1)
   \   00000082   0x8868             LDRH     R0,[R5, #+2]
   \   00000084   0x2800             CMP      R0,#+0
   \   00000086   0xD13E             BNE.N    ??USBD_StdEPReq_2
   \   00000088   0xF011 0x007F      ANDS     R0,R1,#0x7F
   \   0000008C   0xD008             BEQ.N    ??USBD_StdEPReq_9
   \   0000008E   0x4620             MOV      R0,R4
   \   00000090   0x.... 0x....      BL       USBD_LL_ClearStallEP
   \   00000094   0xF8D4 0x2214      LDR      R2,[R4, #+532]
   \   00000098   0x4629             MOV      R1,R5
   \   0000009A   0x4620             MOV      R0,R4
   \   0000009C   0x6892             LDR      R2,[R2, #+8]
   \   0000009E   0x4790             BLX      R2
   \                     ??USBD_StdEPReq_9: (+1)
   \   000000A0   0x4620             MOV      R0,R4
   \   000000A2   0x.... 0x....      BL       USBD_CtlSendStatus
   \   000000A6   0x2000             MOVS     R0,#+0
   \   000000A8   0xB001             ADD      SP,SP,#+4
   \   000000AA   0xBD30             POP      {R4,R5,PC}
   \                     ??USBD_StdEPReq_13: (+1)
   \   000000AC   0xF894 0x01FC      LDRB     R0,[R4, #+508]
   \   000000B0   0x2802             CMP      R0,#+2
   \   000000B2   0xD002             BEQ.N    ??USBD_StdEPReq_14
   \   000000B4   0x2803             CMP      R0,#+3
   \   000000B6   0xD004             BEQ.N    ??USBD_StdEPReq_15
   \   000000B8   0xE01D             B.N      ??USBD_StdEPReq_6
   \                     ??USBD_StdEPReq_14: (+1)
   \   000000BA   0xF011 0x007F      ANDS     R0,R1,#0x7F
   \   000000BE   0xD022             BEQ.N    ??USBD_StdEPReq_2
   \   000000C0   0xE01E             B.N      ??USBD_StdEPReq_7
   \                     ??USBD_StdEPReq_15: (+1)
   \   000000C2   0xF001 0x007F      AND      R0,R1,#0x7F
   \   000000C6   0x060A             LSLS     R2,R1,#+24
   \   000000C8   0xEB04 0x1000      ADD      R0,R4,R0, LSL #+4
   \   000000CC   0xBF4C             ITE      MI 
   \   000000CE   0xF100 0x0514      ADDMI    R5,R0,#+20
   \   000000D2   0xF500 0x7582      ADDPL    R5,R0,#+260
   \   000000D6   0x4620             MOV      R0,R4
   \   000000D8   0x.... 0x....      BL       USBD_LL_IsStallEP
   \   000000DC   0x1E40             SUBS     R0,R0,#+1
   \   000000DE   0x4180             SBCS     R0,R0,R0
   \   000000E0   0x43C0             MVNS     R0,R0
   \   000000E2   0x0FC0             LSRS     R0,R0,#+31
   \   000000E4   0x6028             STR      R0,[R5, #+0]
   \   000000E6   0x2202             MOVS     R2,#+2
   \   000000E8   0x4629             MOV      R1,R5
   \   000000EA   0x4620             MOV      R0,R4
   \   000000EC   0x.... 0x....      BL       USBD_CtlSendData
   \   000000F0   0x2000             MOVS     R0,#+0
   \   000000F2   0xB001             ADD      SP,SP,#+4
   \   000000F4   0xBD30             POP      {R4,R5,PC}
   \                     ??USBD_StdEPReq_6: (+1)
   \   000000F6   0x2180             MOVS     R1,#+128
   \   000000F8   0x4620             MOV      R0,R4
   \   000000FA   0x.... 0x....      BL       USBD_LL_StallEP
   \   000000FE   0x2100             MOVS     R1,#+0
   \                     ??USBD_StdEPReq_7: (+1)
   \   00000100   0x4620             MOV      R0,R4
   \   00000102   0x.... 0x....      BL       USBD_LL_StallEP
   \                     ??USBD_StdEPReq_2: (+1)
   \   00000106   0x2000             MOVS     R0,#+0
   \   00000108   0xB001             ADD      SP,SP,#+4
   \   0000010A   0xBD30             POP      {R4,R5,PC}       ;; return
    323          }
    324          /**
    325          * @brief  USBD_GetDescriptor
    326          *         Handle Get Descriptor requests
    327          * @param  pdev: device instance
    328          * @param  req: usb request
    329          * @retval status
    330          */

   \                                 In section .text, align 4, keep-with-next
    331          static void USBD_GetDescriptor(USBD_HandleTypeDef *pdev , 
    332                                         USBD_SetupReqTypedef *req)
    333          {
   \                     USBD_GetDescriptor: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0x460D             MOV      R5,R1
   \   00000004   0xB081             SUB      SP,SP,#+4
   \   00000006   0x4604             MOV      R4,R0
    334            uint16_t len;
    335            uint8_t *pbuf;
    336            
    337              
    338            switch (req->wValue >> 8)
   \   00000008   0x8869             LDRH     R1,[R5, #+2]
   \   0000000A   0x0A08             LSRS     R0,R1,#+8
   \   0000000C   0x1E40             SUBS     R0,R0,#+1
   \   0000000E   0x2806             CMP      R0,#+6
   \   00000010   0xF200 0x8074      BHI.W    ??USBD_GetDescriptor_2
   \   00000014   0xE8DF 0xF000      TBB      [PC, R0]
   \                     ??USBD_GetDescriptor_0:
   \   00000018   0x04 0x20          DC8      0x4,0x20,0x2E,0x72
   \              0x2E 0x72    
   \   0000001C   0x72 0x60          DC8      0x72,0x60,0x68,0x0
   \              0x68 0x00    
    339            { 
    340          #if (USBD_LPM_ENABLED == 1)
    341            case USB_DESC_TYPE_BOS:
    342              pbuf = pdev->pDesc->GetBOSDescriptor(pdev->dev_speed, &len);
    343              break;
    344          #endif    
    345            case USB_DESC_TYPE_DEVICE:
    346              pbuf = pdev->pDesc->GetDeviceDescriptor(pdev->dev_speed, &len);
   \                     ??USBD_GetDescriptor_3: (+1)
   \   00000020   0xF8D4 0x2210      LDR      R2,[R4, #+528]
   \   00000024   0x7C20             LDRB     R0,[R4, #+16]
   \   00000026   0x4669             MOV      R1,SP
   \   00000028   0x6812             LDR      R2,[R2, #+0]
   \   0000002A   0x4790             BLX      R2
    347              break;
    348              
    349            case USB_DESC_TYPE_CONFIGURATION:     
    350              if(pdev->dev_speed == USBD_SPEED_HIGH )   
    351              {
    352                pbuf   = (uint8_t *)pdev->pClass->GetHSConfigDescriptor(&len);
    353                pbuf[1] = USB_DESC_TYPE_CONFIGURATION;
    354              }
    355              else
    356              {
    357                pbuf   = (uint8_t *)pdev->pClass->GetFSConfigDescriptor(&len);
    358                pbuf[1] = USB_DESC_TYPE_CONFIGURATION;
    359              }
    360              break;
    361              
    362            case USB_DESC_TYPE_STRING:
    363              switch ((uint8_t)(req->wValue))
    364              {
    365              case USBD_IDX_LANGID_STR:
    366               pbuf = pdev->pDesc->GetLangIDStrDescriptor(pdev->dev_speed, &len);        
    367                break;
    368                
    369              case USBD_IDX_MFC_STR:
    370                pbuf = pdev->pDesc->GetManufacturerStrDescriptor(pdev->dev_speed, &len);
    371                break;
    372                
    373              case USBD_IDX_PRODUCT_STR:
    374                pbuf = pdev->pDesc->GetProductStrDescriptor(pdev->dev_speed, &len);
    375                break;
    376                
    377              case USBD_IDX_SERIAL_STR:
    378                pbuf = pdev->pDesc->GetSerialStrDescriptor(pdev->dev_speed, &len);
    379                break;
    380                
    381              case USBD_IDX_CONFIG_STR:
    382                pbuf = pdev->pDesc->GetConfigurationStrDescriptor(pdev->dev_speed, &len);
    383                break;
    384                
    385              case USBD_IDX_INTERFACE_STR:
    386                pbuf = pdev->pDesc->GetInterfaceStrDescriptor(pdev->dev_speed, &len);
    387                break;
    388                
    389              default:
    390          #if (USBD_SUPPORT_USER_STRING == 1)
    391                pbuf = pdev->pClass->GetUsrStrDescriptor(pdev, (req->wValue) , &len);
    392                break;
    393          #else      
    394                 USBD_CtlError(pdev , req);
    395                return;
    396          #endif   
    397              }
    398              break;
    399            case USB_DESC_TYPE_DEVICE_QUALIFIER:                   
    400          
    401              if(pdev->dev_speed == USBD_SPEED_HIGH  )   
    402              {
    403                pbuf   = (uint8_t *)pdev->pClass->GetDeviceQualifierDescriptor(&len);
    404                break;
    405              }
    406              else
    407              {
    408                USBD_CtlError(pdev , req);
    409                return;
    410              } 
    411          
    412            case USB_DESC_TYPE_OTHER_SPEED_CONFIGURATION:
    413              if(pdev->dev_speed == USBD_SPEED_HIGH  )   
    414              {
    415                pbuf   = (uint8_t *)pdev->pClass->GetOtherSpeedConfigDescriptor(&len);
    416                pbuf[1] = USB_DESC_TYPE_OTHER_SPEED_CONFIGURATION;
    417                break; 
    418              }
    419              else
    420              {
    421                USBD_CtlError(pdev , req);
    422                return;
    423              }
    424          
    425            default: 
    426               USBD_CtlError(pdev , req);
    427              return;
    428            }
    429            
    430            if((len != 0)&& (req->wLength != 0))
   \                     ??USBD_GetDescriptor_4: (+1)
   \   0000002C   0xF8BD 0x1000      LDRH     R1,[SP, #+0]
   \   00000030   0x2900             CMP      R1,#+0
   \   00000032   0xBF1C             ITT      NE 
   \   00000034   0x88E9             LDRHNE   R1,[R5, #+6]
   \   00000036   0x2900             CMPNE    R1,#+0
   \   00000038   0xD00C             BEQ.N    ??USBD_GetDescriptor_5
    431            {
    432              
    433              len = MIN(len , req->wLength);
   \   0000003A   0xF8BD 0x2000      LDRH     R2,[SP, #+0]
   \   0000003E   0x428A             CMP      R2,R1
   \   00000040   0xBF88             IT       HI 
   \   00000042   0x460A             MOVHI    R2,R1
   \   00000044   0xF8AD 0x2000      STRH     R2,[SP, #+0]
    434              
    435              USBD_CtlSendData (pdev, 
    436                                pbuf,
    437                                len);
   \   00000048   0xF8BD 0x2000      LDRH     R2,[SP, #+0]
   \   0000004C   0x4601             MOV      R1,R0
   \   0000004E   0x4620             MOV      R0,R4
   \   00000050   0x.... 0x....      BL       USBD_CtlSendData
    438            }
    439            
    440          }
   \                     ??USBD_GetDescriptor_5: (+1)
   \   00000054   0xB001             ADD      SP,SP,#+4
   \   00000056   0xBD30             POP      {R4,R5,PC}       ;; return
   \                     ??USBD_GetDescriptor_6: (+1)
   \   00000058   0x7C20             LDRB     R0,[R4, #+16]
   \   0000005A   0xF8D4 0x1214      LDR      R1,[R4, #+532]
   \   0000005E   0x2800             CMP      R0,#+0
   \   00000060   0x4668             MOV      R0,SP
   \   00000062   0xD104             BNE.N    ??USBD_GetDescriptor_7
   \   00000064   0x6A89             LDR      R1,[R1, #+40]
   \   00000066   0x4788             BLX      R1
   \                     ??USBD_GetDescriptor_8: (+1)
   \   00000068   0x2102             MOVS     R1,#+2
   \   0000006A   0x7041             STRB     R1,[R0, #+1]
   \   0000006C   0xE7DE             B.N      ??USBD_GetDescriptor_4
   \                     ??USBD_GetDescriptor_7: (+1)
   \   0000006E   0x6AC9             LDR      R1,[R1, #+44]
   \   00000070   0x4788             BLX      R1
   \   00000072   0xE7F9             B.N      ??USBD_GetDescriptor_8
   \                     ??USBD_GetDescriptor_9: (+1)
   \   00000074   0xB2C9             UXTB     R1,R1
   \   00000076   0x2905             CMP      R1,#+5
   \   00000078   0xD840             BHI.N    ??USBD_GetDescriptor_2
   \   0000007A   0xE8DF 0xF001      TBB      [PC, R1]
   \                     ??USBD_GetDescriptor_1:
   \   0000007E   0x03 0x0A          DC8      0x3,0xA,0x11,0x18
   \              0x11 0x18    
   \   00000082   0x1F 0x26          DC8      0x1F,0x26
   \                     ??USBD_GetDescriptor_10: (+1)
   \   00000084   0xF8D4 0x2210      LDR      R2,[R4, #+528]
   \   00000088   0x7C20             LDRB     R0,[R4, #+16]
   \   0000008A   0x4669             MOV      R1,SP
   \   0000008C   0x6852             LDR      R2,[R2, #+4]
   \   0000008E   0x4790             BLX      R2
   \   00000090   0xE7CC             B.N      ??USBD_GetDescriptor_4
   \                     ??USBD_GetDescriptor_11: (+1)
   \   00000092   0xF8D4 0x2210      LDR      R2,[R4, #+528]
   \   00000096   0x7C20             LDRB     R0,[R4, #+16]
   \   00000098   0x4669             MOV      R1,SP
   \   0000009A   0x6892             LDR      R2,[R2, #+8]
   \   0000009C   0x4790             BLX      R2
   \   0000009E   0xE7C5             B.N      ??USBD_GetDescriptor_4
   \                     ??USBD_GetDescriptor_12: (+1)
   \   000000A0   0xF8D4 0x2210      LDR      R2,[R4, #+528]
   \   000000A4   0x7C20             LDRB     R0,[R4, #+16]
   \   000000A6   0x4669             MOV      R1,SP
   \   000000A8   0x68D2             LDR      R2,[R2, #+12]
   \   000000AA   0x4790             BLX      R2
   \   000000AC   0xE7BE             B.N      ??USBD_GetDescriptor_4
   \                     ??USBD_GetDescriptor_13: (+1)
   \   000000AE   0xF8D4 0x2210      LDR      R2,[R4, #+528]
   \   000000B2   0x7C20             LDRB     R0,[R4, #+16]
   \   000000B4   0x4669             MOV      R1,SP
   \   000000B6   0x6912             LDR      R2,[R2, #+16]
   \   000000B8   0x4790             BLX      R2
   \   000000BA   0xE7B7             B.N      ??USBD_GetDescriptor_4
   \                     ??USBD_GetDescriptor_14: (+1)
   \   000000BC   0xF8D4 0x2210      LDR      R2,[R4, #+528]
   \   000000C0   0x7C20             LDRB     R0,[R4, #+16]
   \   000000C2   0x4669             MOV      R1,SP
   \   000000C4   0x6952             LDR      R2,[R2, #+20]
   \   000000C6   0x4790             BLX      R2
   \   000000C8   0xE7B0             B.N      ??USBD_GetDescriptor_4
   \                     ??USBD_GetDescriptor_15: (+1)
   \   000000CA   0xF8D4 0x2210      LDR      R2,[R4, #+528]
   \   000000CE   0x7C20             LDRB     R0,[R4, #+16]
   \   000000D0   0x4669             MOV      R1,SP
   \   000000D2   0x6992             LDR      R2,[R2, #+24]
   \   000000D4   0x4790             BLX      R2
   \   000000D6   0xE7A9             B.N      ??USBD_GetDescriptor_4
   \                     ??USBD_GetDescriptor_16: (+1)
   \   000000D8   0x7C20             LDRB     R0,[R4, #+16]
   \   000000DA   0xB978             CBNZ.N   R0,??USBD_GetDescriptor_2
   \   000000DC   0xF8D4 0x1214      LDR      R1,[R4, #+532]
   \   000000E0   0x4668             MOV      R0,SP
   \   000000E2   0x6B49             LDR      R1,[R1, #+52]
   \   000000E4   0x4788             BLX      R1
   \   000000E6   0xE7A1             B.N      ??USBD_GetDescriptor_4
   \                     ??USBD_GetDescriptor_17: (+1)
   \   000000E8   0x7C20             LDRB     R0,[R4, #+16]
   \   000000EA   0xB938             CBNZ.N   R0,??USBD_GetDescriptor_2
   \   000000EC   0xF8D4 0x1214      LDR      R1,[R4, #+532]
   \   000000F0   0x4668             MOV      R0,SP
   \   000000F2   0x6B09             LDR      R1,[R1, #+48]
   \   000000F4   0x4788             BLX      R1
   \   000000F6   0x2107             MOVS     R1,#+7
   \   000000F8   0x7041             STRB     R1,[R0, #+1]
   \   000000FA   0xE797             B.N      ??USBD_GetDescriptor_4
   \                     ??USBD_GetDescriptor_2: (+1)
   \   000000FC   0x2180             MOVS     R1,#+128
   \   000000FE   0x4620             MOV      R0,R4
   \   00000100   0x.... 0x....      BL       USBD_LL_StallEP
   \   00000104   0x2100             MOVS     R1,#+0
   \   00000106   0x4620             MOV      R0,R4
   \   00000108   0x.... 0x....      BL       USBD_LL_StallEP
   \   0000010C   0xB001             ADD      SP,SP,#+4
   \   0000010E   0xBD30             POP      {R4,R5,PC}
    441          
    442          /**
    443          * @brief  USBD_SetAddress
    444          *         Set device address
    445          * @param  pdev: device instance
    446          * @param  req: usb request
    447          * @retval status
    448          */
    449          static void USBD_SetAddress(USBD_HandleTypeDef *pdev , 
    450                                      USBD_SetupReqTypedef *req)
    451          {
    452            uint8_t  dev_addr; 
    453            
    454            if ((req->wIndex == 0) && (req->wLength == 0)) 
    455            {
    456              dev_addr = (uint8_t)(req->wValue) & 0x7F;     
    457              
    458              if (pdev->dev_state == USBD_STATE_CONFIGURED) 
    459              {
    460                USBD_CtlError(pdev , req);
    461              } 
    462              else 
    463              {
    464                pdev->dev_address = dev_addr;
    465                USBD_LL_SetUSBAddress(pdev, dev_addr);               
    466                USBD_CtlSendStatus(pdev);                         
    467                
    468                if (dev_addr != 0) 
    469                {
    470                  pdev->dev_state  = USBD_STATE_ADDRESSED;
    471                } 
    472                else 
    473                {
    474                  pdev->dev_state  = USBD_STATE_DEFAULT; 
    475                }
    476              }
    477            } 
    478            else 
    479            {
    480               USBD_CtlError(pdev , req);                        
    481            } 
    482          }
    483          
    484          /**
    485          * @brief  USBD_SetConfig
    486          *         Handle Set device configuration request
    487          * @param  pdev: device instance
    488          * @param  req: usb request
    489          * @retval status
    490          */
    491          static void USBD_SetConfig(USBD_HandleTypeDef *pdev , 
    492                                     USBD_SetupReqTypedef *req)
    493          {
    494            

   \                                 In section .bss, align 1
    495            static uint8_t  cfgidx;
   \                     ??cfgidx:
   \   00000000                      DS8 1
    496            
    497            cfgidx = (uint8_t)(req->wValue);                 
    498            
    499            if (cfgidx > USBD_MAX_NUM_CONFIGURATION ) 
    500            {            
    501               USBD_CtlError(pdev , req);                              
    502            } 
    503            else 
    504            {
    505              switch (pdev->dev_state) 
    506              {
    507              case USBD_STATE_ADDRESSED:
    508                if (cfgidx) 
    509                {                                			   							   							   				
    510                  pdev->dev_config = cfgidx;
    511                  pdev->dev_state = USBD_STATE_CONFIGURED;
    512                  if(USBD_SetClassConfig(pdev , cfgidx) == USBD_FAIL)
    513                  {
    514                    USBD_CtlError(pdev , req);  
    515                    return;
    516                  }
    517                  USBD_CtlSendStatus(pdev);
    518                }
    519                else 
    520                {
    521                   USBD_CtlSendStatus(pdev);
    522                }
    523                break;
    524                
    525              case USBD_STATE_CONFIGURED:
    526                if (cfgidx == 0) 
    527                {                           
    528                  pdev->dev_state = USBD_STATE_ADDRESSED;
    529                  pdev->dev_config = cfgidx;          
    530                  USBD_ClrClassConfig(pdev , cfgidx);
    531                  USBD_CtlSendStatus(pdev);
    532                  
    533                } 
    534                else  if (cfgidx != pdev->dev_config) 
    535                {
    536                  /* Clear old configuration */
    537                  USBD_ClrClassConfig(pdev , pdev->dev_config);
    538                  
    539                  /* set new configuration */
    540                  pdev->dev_config = cfgidx;
    541                  if(USBD_SetClassConfig(pdev , cfgidx) == USBD_FAIL)
    542                  {
    543                    USBD_CtlError(pdev , req);  
    544                    return;
    545                  }
    546                  USBD_CtlSendStatus(pdev);
    547                }
    548                else
    549                {
    550                  USBD_CtlSendStatus(pdev);
    551                }
    552                break;
    553                
    554              default:					
    555                 USBD_CtlError(pdev , req);                     
    556                break;
    557              }
    558            }
    559          }
    560          
    561          /**
    562          * @brief  USBD_GetConfig
    563          *         Handle Get device configuration request
    564          * @param  pdev: device instance
    565          * @param  req: usb request
    566          * @retval status
    567          */
    568          static void USBD_GetConfig(USBD_HandleTypeDef *pdev , 
    569                                     USBD_SetupReqTypedef *req)
    570          {
    571          
    572            if (req->wLength != 1) 
    573            {                   
    574               USBD_CtlError(pdev , req);
    575            }
    576            else 
    577            {
    578              switch (pdev->dev_state )  
    579              {
    580              case USBD_STATE_ADDRESSED:                     
    581                pdev->dev_default_config = 0;
    582                USBD_CtlSendData (pdev, 
    583                                  (uint8_t *)&pdev->dev_default_config,
    584                                  1);
    585                break;
    586                
    587              case USBD_STATE_CONFIGURED:   
    588                
    589                USBD_CtlSendData (pdev, 
    590                                  (uint8_t *)&pdev->dev_config,
    591                                  1);
    592                break;
    593                
    594              default:
    595                 USBD_CtlError(pdev , req);
    596                break;
    597              }
    598            }
    599          }
    600          
    601          /**
    602          * @brief  USBD_GetStatus
    603          *         Handle Get Status request
    604          * @param  pdev: device instance
    605          * @param  req: usb request
    606          * @retval status
    607          */
    608          static void USBD_GetStatus(USBD_HandleTypeDef *pdev , 
    609                                     USBD_SetupReqTypedef *req)
    610          {
    611            
    612              
    613            switch (pdev->dev_state) 
    614            {
    615            case USBD_STATE_ADDRESSED:
    616            case USBD_STATE_CONFIGURED:
    617              
    618          #if ( USBD_SELF_POWERED == 1)
    619              pdev->dev_config_status = USB_CONFIG_SELF_POWERED;                                  
    620          #else
    621              pdev->dev_config_status = 0;                                   
    622          #endif
    623                                
    624              if (pdev->dev_remote_wakeup) 
    625              {
    626                 pdev->dev_config_status |= USB_CONFIG_REMOTE_WAKEUP;                                
    627              }
    628              
    629              USBD_CtlSendData (pdev, 
    630                                (uint8_t *)& pdev->dev_config_status,
    631                                2);
    632              break;
    633              
    634            default :
    635              USBD_CtlError(pdev , req);                        
    636              break;
    637            }
    638          }
    639          
    640          
    641          /**
    642          * @brief  USBD_SetFeature
    643          *         Handle Set device feature request
    644          * @param  pdev: device instance
    645          * @param  req: usb request
    646          * @retval status
    647          */
    648          static void USBD_SetFeature(USBD_HandleTypeDef *pdev , 
    649                                      USBD_SetupReqTypedef *req)
    650          {
    651          
    652            if (req->wValue == USB_FEATURE_REMOTE_WAKEUP)
    653            {
    654              pdev->dev_remote_wakeup = 1;  
    655              pdev->pClass->Setup (pdev, req);   
    656              USBD_CtlSendStatus(pdev);
    657            }
    658          
    659          }
    660          
    661          
    662          /**
    663          * @brief  USBD_ClrFeature
    664          *         Handle clear device feature request
    665          * @param  pdev: device instance
    666          * @param  req: usb request
    667          * @retval status
    668          */
    669          static void USBD_ClrFeature(USBD_HandleTypeDef *pdev , 
    670                                      USBD_SetupReqTypedef *req)
    671          {
    672            switch (pdev->dev_state)
    673            {
    674            case USBD_STATE_ADDRESSED:
    675            case USBD_STATE_CONFIGURED:
    676              if (req->wValue == USB_FEATURE_REMOTE_WAKEUP) 
    677              {
    678                pdev->dev_remote_wakeup = 0; 
    679                pdev->pClass->Setup (pdev, req);   
    680                USBD_CtlSendStatus(pdev);
    681              }
    682              break;
    683              
    684            default :
    685               USBD_CtlError(pdev , req);
    686              break;
    687            }
    688          }
    689          
    690          /**
    691          * @brief  USBD_ParseSetupRequest 
    692          *         Copy buffer into setup structure
    693          * @param  pdev: device instance
    694          * @param  req: usb request
    695          * @retval None
    696          */
    697          

   \                                 In section .text, align 2, keep-with-next
    698          void USBD_ParseSetupRequest(USBD_SetupReqTypedef *req, uint8_t *pdata)
    699          {
    700            req->bmRequest     = *(uint8_t *)  (pdata);
   \                     USBD_ParseSetupRequest: (+1)
   \   00000000   0x780A             LDRB     R2,[R1, #+0]
   \   00000002   0x7002             STRB     R2,[R0, #+0]
    701            req->bRequest      = *(uint8_t *)  (pdata +  1);
   \   00000004   0x784A             LDRB     R2,[R1, #+1]
   \   00000006   0x7042             STRB     R2,[R0, #+1]
    702            req->wValue        = SWAPBYTE      (pdata +  2);
   \   00000008   0x788A             LDRB     R2,[R1, #+2]
   \   0000000A   0x78CB             LDRB     R3,[R1, #+3]
   \   0000000C   0xEB02 0x2203      ADD      R2,R2,R3, LSL #+8
   \   00000010   0x8042             STRH     R2,[R0, #+2]
    703            req->wIndex        = SWAPBYTE      (pdata +  4);
   \   00000012   0x790A             LDRB     R2,[R1, #+4]
   \   00000014   0x794B             LDRB     R3,[R1, #+5]
   \   00000016   0xEB02 0x2203      ADD      R2,R2,R3, LSL #+8
   \   0000001A   0x8082             STRH     R2,[R0, #+4]
    704            req->wLength       = SWAPBYTE      (pdata +  6);
   \   0000001C   0x798A             LDRB     R2,[R1, #+6]
   \   0000001E   0x79C9             LDRB     R1,[R1, #+7]
   \   00000020   0xEB02 0x2101      ADD      R1,R2,R1, LSL #+8
   \   00000024   0x80C1             STRH     R1,[R0, #+6]
    705          
    706          }
   \   00000026   0x4770             BX       LR               ;; return
    707          
    708          /**
    709          * @brief  USBD_CtlError 
    710          *         Handle USB low level Error
    711          * @param  pdev: device instance
    712          * @param  req: usb request
    713          * @retval None
    714          */
    715          

   \                                 In section .text, align 2, keep-with-next
    716          void USBD_CtlError( USBD_HandleTypeDef *pdev ,
    717                                      USBD_SetupReqTypedef *req)
    718          {
   \                     USBD_CtlError: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    719            USBD_LL_StallEP(pdev , 0x80);
   \   00000004   0x2180             MOVS     R1,#+128
   \   00000006   0x.... 0x....      BL       USBD_LL_StallEP
    720            USBD_LL_StallEP(pdev , 0);
   \   0000000A   0x4620             MOV      R0,R4
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0xE8BD 0x4010      POP      {R4,LR}
   \   00000012   0x.... 0x....      B.W      USBD_LL_StallEP
    721          }
    722          
    723          
    724          /**
    725            * @brief  USBD_GetString
    726            *         Convert Ascii string into unicode one
    727            * @param  desc : descriptor buffer
    728            * @param  unicode : Formatted string buffer (unicode)
    729            * @param  len : descriptor length
    730            * @retval None
    731            */

   \                                 In section .text, align 4, keep-with-next
    732          void USBD_GetString(uint8_t *desc, uint8_t *unicode, uint16_t *len)
    733          {
    734            uint8_t idx = 0;
    735            
    736            if (desc != NULL) 
   \                     USBD_GetString: (+1)
   \   00000000   0xB900             CBNZ.N   R0,??USBD_GetString_0
   \   00000002   0x4770             BX       LR
    737            {
    738              *len =  USBD_GetLen(desc) * 2 + 2;    
   \                     ??USBD_GetString_0: (+1)
   \   00000004   0x4603             MOV      R3,R0
   \   00000006   0xB430             PUSH     {R4,R5}
   \   00000008   0x781D             LDRB     R5,[R3, #+0]
   \   0000000A   0xF05F 0x0400      MOVS.W   R4,#+0
   \   0000000E   0xB125             CBZ.N    R5,??USBD_GetString_1
   \                     ??USBD_GetString_2: (+1)
   \   00000010   0xF813 0x5F01      LDRB     R5,[R3, #+1]!
   \   00000014   0x1C64             ADDS     R4,R4,#+1
   \   00000016   0x2D00             CMP      R5,#+0
   \   00000018   0xD1FA             BNE.N    ??USBD_GetString_2
   \                     ??USBD_GetString_1: (+1)
   \   0000001A   0x0624             LSLS     R4,R4,#+24
   \   0000001C   0x0DE3             LSRS     R3,R4,#+23
   \   0000001E   0x1C9B             ADDS     R3,R3,#+2
   \   00000020   0x8013             STRH     R3,[R2, #+0]
    739              unicode[idx++] = *len;
   \   00000022   0x8812             LDRH     R2,[R2, #+0]
   \   00000024   0x700A             STRB     R2,[R1, #+0]
    740              unicode[idx++] =  USB_DESC_TYPE_STRING;
   \   00000026   0x2203             MOVS     R2,#+3
   \   00000028   0x704A             STRB     R2,[R1, #+1]
   \   0000002A   0x2202             MOVS     R2,#+2
   \   0000002C   0xE009             B.N      ??USBD_GetString_3
   \   0000002E   0xBF00             Nop      
    741              
    742              while (*desc != '\0') 
    743              {
    744                unicode[idx++] = *desc++;
   \                     ??USBD_GetString_4: (+1)
   \   00000030   0xF810 0x3B01      LDRB     R3,[R0], #+1
   \   00000034   0xB2D2             UXTB     R2,R2
   \   00000036   0x5453             STRB     R3,[R2, R1]
   \   00000038   0x1C52             ADDS     R2,R2,#+1
    745                unicode[idx++] =  0x00;
   \   0000003A   0x2300             MOVS     R3,#+0
   \   0000003C   0xB2D2             UXTB     R2,R2
   \   0000003E   0x5453             STRB     R3,[R2, R1]
   \   00000040   0x1C52             ADDS     R2,R2,#+1
    746              }
   \                     ??USBD_GetString_3: (+1)
   \   00000042   0x7803             LDRB     R3,[R0, #+0]
   \   00000044   0x2B00             CMP      R3,#+0
   \   00000046   0xD1F3             BNE.N    ??USBD_GetString_4
    747            } 
    748          }
   \   00000048   0xBC30             POP      {R4,R5}
   \   0000004A   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0:
   \   00000000   0x........         DC32     ??cfgidx
    749          
    750          /**
    751            * @brief  USBD_GetLen
    752            *         return the string length
    753             * @param  buf : pointer to the ascii string buffer
    754            * @retval string length
    755            */
    756          static uint8_t USBD_GetLen(uint8_t *buf)
    757          {
    758              uint8_t  len = 0;
    759          
    760              while (*buf != '\0') 
    761              {
    762                  len++;
    763                  buf++;
    764              }
    765          
    766              return len;
    767          }
    768          /**
    769            * @}
    770            */ 
    771          
    772          
    773          /**
    774            * @}
    775            */ 
    776          
    777          
    778          /**
    779            * @}
    780            */ 
    781          
    782          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   USBD_CtlError
         0   -> USBD_LL_StallEP
         8   -> USBD_LL_StallEP
      16   USBD_GetDescriptor
        16   -- Indirect call
        16   -> USBD_CtlSendData
        16   -> USBD_LL_StallEP
       8   USBD_GetString
       0   USBD_ParseSetupRequest
      16   USBD_StdDevReq
        16   -- Indirect call
        16   -> USBD_ClrClassConfig
        16   -> USBD_CtlSendData
        16   -> USBD_CtlSendStatus
        16   -> USBD_GetDescriptor
        16   -> USBD_LL_SetUSBAddress
        16   -> USBD_LL_StallEP
        16   -> USBD_SetClassConfig
      16   USBD_StdEPReq
        16   -- Indirect call
        16   -> USBD_CtlSendData
        16   -> USBD_CtlSendStatus
        16   -> USBD_LL_ClearStallEP
        16   -> USBD_LL_IsStallEP
        16   -> USBD_LL_StallEP
      16   USBD_StdItfReq
        16   -- Indirect call
        16   -> USBD_CtlSendStatus
        16   -> USBD_LL_StallEP


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable0
      22  USBD_CtlError
     272  USBD_GetDescriptor
      76  USBD_GetString
      40  USBD_ParseSetupRequest
     350  USBD_StdDevReq
     268  USBD_StdEPReq
      70  USBD_StdItfReq
       1  cfgidx

 
     1 byte  in section .bss
 1 102 bytes in section .text
 
 1 102 bytes of CODE memory
     1 byte  of DATA memory

Errors: none
Warnings: 1
