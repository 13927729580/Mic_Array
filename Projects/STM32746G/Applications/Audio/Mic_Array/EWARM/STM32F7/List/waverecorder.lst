###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.2.10312/W32 for ARM       22/Feb/2016  17:57:56
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\Src\waverecorder.c
#    Command line =  
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\Src\waverecorder.c
#        -D USE_HAL_DRIVER -D STM32F746xx -D USE_STM32746G_DISCO -D
#        USE_IOEXPANDER -D USE_USB_FS -lC
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
#        -lA
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
#        -o
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj
#        --no_unroll --debug --endian=little --cpu=Cortex-M7 -e --fpu=VFPv5_sp
#        --dlib_config "D:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Full.h" -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\CMSIS\Device\ST\STM32F7xx\Include\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\STM32F7xx_HAL_Driver\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\STM32746G-Discovery\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\Components\Common\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Log\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Fonts\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\CPU\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_Device_Library\Core\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Core\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Class\MSC\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\drivers\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_Audio\Addons\PDM\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_Device_Library\Class\AUDIO\Inc\
#        -Ohs --use_c++_inline --require_prototypes -I "D:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.3\arm\CMSIS\Include\" -D
#        ARM_MATH_CM7
#    List file    =  
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List\waverecorder.lst
#    Object file  =  
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj\waverecorder.o
#
###############################################################################

D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\Src\waverecorder.c
      1          
      2          /* Includes ------------------------------------------------------------------*/
      3          #include "waverecorder.h" 

    
   ^
"D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\Inc\waverecorder.h",2  Warning[Pa050]: 
          non-native end of line sequence detected (this diagnostic is only
          issued once)
      4          #include "string.h"
      5          //#include "stm32f7xx_hal_spi.h"
      6          #include "stm32f7xx_hal.h"
      7          #include "pdm_filter.h"
      8          
      9          
     10          /* Private typedef -----------------------------------------------------------*/
     11          /* Private define ------------------------------------------------------------*/
     12          #define TOUCH_RECORD_XMIN       300
     13          #define TOUCH_RECORD_XMAX       340
     14          #define TOUCH_RECORD_YMIN       212
     15          #define TOUCH_RECORD_YMAX       252
     16          
     17          #define TOUCH_STOP_XMIN         205
     18          #define TOUCH_STOP_XMAX         245
     19          #define TOUCH_STOP_YMIN         212
     20          #define TOUCH_STOP_YMAX         252
     21          
     22          #define TOUCH_PAUSE_XMIN        125
     23          #define TOUCH_PAUSE_XMAX        149
     24          #define TOUCH_PAUSE_YMIN        212
     25          #define TOUCH_PAUSE_YMAX        252
     26          
     27          #define TOUCH_VOL_MINUS_XMIN    20
     28          #define TOUCH_VOL_MINUS_XMAX    70
     29          #define TOUCH_VOL_MINUS_YMIN    212
     30          #define TOUCH_VOL_MINUS_YMAX    252
     31          
     32          #define TOUCH_VOL_PLUS_XMIN     402
     33          #define TOUCH_VOL_PLUS_XMAX     452
     34          #define TOUCH_VOL_PLUS_YMIN     212
     35          #define TOUCH_VOL_PLUS_YMAX     252
     36          
     37          
     38          
     39          /* SPI Configuration defines */
     40          #define SPI_SCK_PIN                       GPIO_PIN_10
     41          #define SPI_SCK_GPIO_PORT                 GPIOB
     42          #define SPI_SCK_GPIO_CLK                  1
     43          #define SPI_SCK_SOURCE                    1
     44          #define SPI_SCK_AF                        GPIO_AF5_SPI2
     45          
     46          #define SPI_MOSI_PIN                      GPIO_PIN_3
     47          #define SPI_MOSI_GPIO_PORT                GPIOC
     48          #define SPI_MOSI_GPIO_CLK                 1
     49          #define SPI_MOSI_SOURCE                   1
     50          #define SPI_MOSI_AF                       GPIO_AF5_SPI2
     51          
     52          
     53          /* sop1hc */
     54          #define SPI1_SCK_PIN                       GPIO_PIN_5
     55          #define SPI1_SCK_GPIO_PORT                 GPIOA
     56          #define SPI1_SCK_GPIO_CLK                  1
     57          #define SPI1_SCK_SOURCE                    1
     58          #define SPI1_SCK_AF                        GPIO_AF5_SPI1
     59          
     60          #define SPI1_MOSI_PIN                      GPIO_PIN_7
     61          #define SPI1_MOSI_GPIO_PORT                GPIOA
     62          #define SPI1_MOSI_GPIO_CLK                 1
     63          #define SPI1_MOSI_SOURCE                   1
     64          #define SPI1_MOSI_AF                       GPIO_AF5_SPI1
     65          
     66          #define SPI1_MISO_PIN                      GPIO_PIN_6
     67          #define SPI1_MISO_GPIO_PORT                GPIOA
     68          #define SPI1_MISO_GPIO_CLK                 1
     69          #define SPI1_MISO_SOURCE                   1
     70          #define SPI1_MISO_AF                       GPIO_AF5_SPI1
     71          
     72          
     73          
     74          

   \                                 In section .bss, align 4
     75          uint16_t idxMic8=0;
     76          uint16_t idxMic7=0;
     77          uint8_t pHeaderBuff[44];
     78          //uint16_t Buffer1[AUDIO_IN_PCM_BUFFER_SIZE];
     79          uint16_t volatile cntTransFinish;
     80          
     81          /* Private macro -------------------------------------------------------------*/
     82          /* Private variables ---------------------------------------------------------*/
     83          extern  AUDIO_IN_BufferTypeDef  stkBufferCtlRecIn,stkBuffer1, stkBuffer2;
     84          extern AUDIO_OUT_BufferTypeDef  BufferCtlPlayOut;
     85          extern uint16_t __IO idxSPI5DataBuf1, idxSPI5DataBuf2;
     86          extern WAVE_FormatTypeDef WaveFormat;
     87          extern FIL WavFile;
     88          extern AUDIO_DEMO_StateMachine AudioDemo;
     89          extern AUDIO_PLAYBACK_StateTypeDef AudioState;
     90          extern __IO uint8_t buffer_switch;
     91          extern __IO uint8_t volume;
     92          extern SPI_HandleTypeDef hspi4,hspi1;
     93          extern __IO uint16_t  WaveRec_idxSens1,WaveRec_idxSens2;
     94          extern __IO uint16_t  WaveRec_idxSens3,WaveRec_idxSens4;
     95          extern __IO uint16_t  WaveRec_idxSens5,WaveRec_idxSens6;
     96          extern __IO uint16_t  I2S2_idxTmp;
     97          extern SPI_HandleTypeDef     hspi4;
     98          extern DMA_HandleTypeDef     DmaHandle;
     99          
    100          #ifndef CS43L22_PLAY
    101          extern __IO uint8_t flgDlyUpd; 
    102          extern __IO uint32_t XferCplt;
    103          extern __IO uint16_t  idxSPI5DataBuf3;
    104          #endif
    105          
    106          __IO int16_t TestSDO12[4*AUDIO_OUT_BUFFER_SIZE];
    107          __IO int16_t TestSDO34[4*AUDIO_OUT_BUFFER_SIZE];
    108          __IO int16_t TestSDO56[4*AUDIO_OUT_BUFFER_SIZE];
    109          __IO uint16_t TestSDO7[4*AUDIO_OUT_BUFFER_SIZE];
    110          __IO uint16_t TestSDO8[4*AUDIO_OUT_BUFFER_SIZE];
    111          __IO uint16_t TestSDO7_1[4*AUDIO_OUT_BUFFER_SIZE];
    112          __IO uint16_t TestSDO8_1[4*AUDIO_OUT_BUFFER_SIZE];
    113          
    114          
    115          SPI_HandleTypeDef hspi1,hspi2;
    116          SPI_HandleTypeDef spi1_ins,spi2_ins;
    117          I2S_HandleTypeDef hi2s1;
    118          I2S_HandleTypeDef hi2s2;
    119          SPI_HandleTypeDef hspi5,hspi6;
   \                     hspi5:
   \   00000000                      DS8 100
   \                     hspi6:
   \   00000064                      DS8 100
   \                     hi2s1:
   \   000000C8                      DS8 64
   \                     hi2s2:
   \   00000108                      DS8 64
    120          DMA_HandleTypeDef hdma_spi2_tx;
    121          DMA_HandleTypeDef hdma_spi3_tx;
    122          DMA_HandleTypeDef     hdma_spi5_rx,hdma_spi6_rx;
    123          
    124          #if USB_STREAMING
    125          __IO uint16_t idxFrmPDMMic8;
    126          #endif
    127          
    128          uint16_t *bufPCMSens7;
    129          uint16_t *bufPCMSens8;
    130          __IO uint16_t cntPos;
    131          __IO uint16_t cntPos7;
    132          __IO static uint16_t iBuff;
    133          __IO static uint32_t uwVolume = 70;
    134          __IO PDMFilter_InitStruct Filter[2];
   \                     Filter:
   \   00000148                      DS8 104
    135          __IO uint16_t  pDataMic8[64];//INTERNAL_BUFF_SIZE
    136          __IO uint16_t  pDataMic7[64];//INTERNAL_BUFF_SIZE
    137          __IO uint16_t cntStrt;
    138          __IO uint8_t WaveRecord_flgInt;
    139          uint8_t WaveRecord_flgIni;
    140          
    141          uint16_t vRawSens1,vRawSens2,vRawSens4,vRawSens3,vRawSens5,vRawSens6;  
    142          __IO int16_t SPI1_stNipple,I2S1_stNipple, I2S2_stNipple;
    143          __IO uint16_t iSDO12,iSDO34,iSDO56;
    144          __IO uint8_t swtSDO7,swtSDO8;
   \                     swtSDO7:
   \   000001B0                      DS8 1
   \                     swtSDO8:
   \   000001B1                      DS8 1
    145          __IO uint8_t WaveRecord_flgSDO7Finish,WaveRecord_flgSDO8Finish;
   \                     WaveRecord_flgSDO7Finish:
   \   000001B2                      DS8 1
   \   000001B3                      DS8 1
   \                     idxMic8:
   \   000001B4                      DS8 2
   \                     idxMic7:
   \   000001B6                      DS8 2
   \                     idxFrmPDMMic8:
   \   000001B8                      DS8 2
   \                     cntPos:
   \   000001BA                      DS8 2
   \                     cntPos7:
   \   000001BC                      DS8 2
   \                     cntStrt:
   \   000001BE                      DS8 2
   \                     bufPCMSens7:
   \   000001C0                      DS8 4
   \                     bufPCMSens8:
   \   000001C4                      DS8 4
   \                     pDataMic8:
   \   000001C8                      DS8 128
   \                     pDataMic7:
   \   00000248                      DS8 128

   \                                 In section .bss, align 4
   \                     pHeaderBuff:
   \   00000000                      DS8 44

   \                                 In section .bss, align 2
   \                     cntTransFinish:
   \   00000000                      DS8 2
    146          __IO uint8_t I2S1_stPosShft,I2S2_stPosShft,SPI4_stPosShft;
    147          
    148          /* Private function prototypes -----------------------------------------------*/
    149          static void SPI_I2S_SendData(SPI_TypeDef* SPIx, uint16_t Data);
    150          static uint16_t SPI_I2S_ReceiveData(SPI_TypeDef* SPIx);
    151          static void I2S1_Init(void);
    152          static void I2S2_Init(void);
    153          
    154          #pragma location=SDRAM_BANK_ADDR
    155          Mic_Array_Data Buffer1;
    156          #pragma location= (SDRAM_BANK_ADDR+ BUFFER_SIZE_BYTE)
    157          Mic_Array_Data Buffer2;
    158          #pragma location= (SDRAM_BANK_ADDR+ BUFFER_SIZE_BYTE + BUFFER_SIZE_BYTE)
    159          Mic_Array_Data Buffer3;
    160          

   \                                 In section .text, align 2, keep-with-next
    161          void SPI1_Ini(void)
    162          {
   \                     SPI1_Ini: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    163            GPIO_InitTypeDef GPIO_InitStructure;
    164          
    165           
    166             	 
    167            /* Enable SCK, MOSI and MISO GPIO clocks */
    168            __HAL_RCC_SPI1_CLK_ENABLE();
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable12  ;; 0x40023830
   \   00000006   0xB086             SUB      SP,SP,#+24
    169            __HAL_RCC_GPIOA_CLK_ENABLE();
    170          
    171            
    172            GPIO_InitStructure.Mode = GPIO_MODE_AF_PP;
    173            GPIO_InitStructure.Pull  = GPIO_PULLDOWN;
    174            GPIO_InitStructure.Speed = GPIO_SPEED_HIGH;
    175          
    176            /* SPI SCK pin configuration */
    177            GPIO_InitStructure.Alternate = SPI1_SCK_AF;
    178            GPIO_InitStructure.Pin = SPI1_SCK_PIN;
    179            HAL_GPIO_Init(SPI1_SCK_GPIO_PORT,&GPIO_InitStructure);
   \   00000008   0x.... 0x....      LDR.W    R4,??DataTable12_1  ;; 0x40020000
   \   0000000C   0x6941             LDR      R1,[R0, #+20]
   \   0000000E   0xF441 0x5180      ORR      R1,R1,#0x1000
   \   00000012   0x6141             STR      R1,[R0, #+20]
   \   00000014   0x6941             LDR      R1,[R0, #+20]
   \   00000016   0xF401 0x5180      AND      R1,R1,#0x1000
   \   0000001A   0x9100             STR      R1,[SP, #+0]
   \   0000001C   0x9900             LDR      R1,[SP, #+0]
   \   0000001E   0x6801             LDR      R1,[R0, #+0]
   \   00000020   0xF041 0x0101      ORR      R1,R1,#0x1
   \   00000024   0x6001             STR      R1,[R0, #+0]
   \   00000026   0x6800             LDR      R0,[R0, #+0]
   \   00000028   0xA901             ADD      R1,SP,#+4
   \   0000002A   0xF000 0x0001      AND      R0,R0,#0x1
   \   0000002E   0x9000             STR      R0,[SP, #+0]
   \   00000030   0x9800             LDR      R0,[SP, #+0]
   \   00000032   0x2002             MOVS     R0,#+2
   \   00000034   0x9002             STR      R0,[SP, #+8]
   \   00000036   0x9003             STR      R0,[SP, #+12]
   \   00000038   0x2003             MOVS     R0,#+3
   \   0000003A   0x9004             STR      R0,[SP, #+16]
   \   0000003C   0x2005             MOVS     R0,#+5
   \   0000003E   0x9005             STR      R0,[SP, #+20]
   \   00000040   0x2020             MOVS     R0,#+32
   \   00000042   0x9001             STR      R0,[SP, #+4]
   \   00000044   0x4620             MOV      R0,R4
   \   00000046   0x.... 0x....      BL       HAL_GPIO_Init
    180          
    181            /* SPI  MOSI pin configuration */
    182            GPIO_InitStructure.Alternate = SPI1_MOSI_SOURCE;
   \   0000004A   0x2001             MOVS     R0,#+1
    183            GPIO_InitStructure.Pin =  SPI1_MOSI_PIN;
    184            HAL_GPIO_Init(SPI1_MOSI_GPIO_PORT, &GPIO_InitStructure);
   \   0000004C   0xA901             ADD      R1,SP,#+4
   \   0000004E   0x9005             STR      R0,[SP, #+20]
   \   00000050   0x2080             MOVS     R0,#+128
   \   00000052   0x9001             STR      R0,[SP, #+4]
   \   00000054   0x4620             MOV      R0,R4
   \   00000056   0x.... 0x....      BL       HAL_GPIO_Init
    185          
    186            /* SPI MISO pin configuration */
    187            GPIO_InitStructure.Alternate = SPI1_MISO_SOURCE;
   \   0000005A   0x2001             MOVS     R0,#+1
    188            GPIO_InitStructure.Pin = SPI1_MISO_PIN;
    189            HAL_GPIO_Init(SPI1_MISO_GPIO_PORT, &GPIO_InitStructure);
   \   0000005C   0xA901             ADD      R1,SP,#+4
   \   0000005E   0x9005             STR      R0,[SP, #+20]
   \   00000060   0x2040             MOVS     R0,#+64
   \   00000062   0x9001             STR      R0,[SP, #+4]
   \   00000064   0x4620             MOV      R0,R4
   \   00000066   0x.... 0x....      BL       HAL_GPIO_Init
    190          
    191            /* SPI configuration -------------------------------------------------------*/
    192            //SPI_I2S_DeInit(SPI1);
    193            
    194            spi1_ins.Init.Direction = SPI_DIRECTION_2LINES_RXONLY;
   \   0000006A   0x.... 0x....      LDR.W    R0,??DataTable12_2
   \   0000006E   0xF44F 0x6180      MOV      R1,#+1024
   \   00000072   0x6081             STR      R1,[R0, #+8]
    195            spi1_ins.Init.DataSize = SPI_DATASIZE_16BIT;
   \   00000074   0xF44F 0x6170      MOV      R1,#+3840
   \   00000078   0x60C1             STR      R1,[R0, #+12]
    196            spi1_ins.Init.CLKPolarity = SPI_POLARITY_LOW;
   \   0000007A   0x2100             MOVS     R1,#+0
   \   0000007C   0x6101             STR      R1,[R0, #+16]
    197            spi1_ins.Init.CLKPhase = SPI_PHASE_1EDGE;
    198            spi1_ins.Init.NSS = SPI_NSS_SOFT;
    199            spi1_ins.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_64;
    200            spi1_ins.Init.FirstBit = SPI_FIRSTBIT_MSB;
    201            spi1_ins.Init.CRCPolynomial = 7;
    202            spi1_ins.Init.Mode = SPI_MODE_SLAVE;
   \   0000007E   0x.... 0x....      LDR.W    R4,??DataTable15  ;; 0x40021000
   \   00000082   0x6141             STR      R1,[R0, #+20]
   \   00000084   0xF44F 0x7100      MOV      R1,#+512
   \   00000088   0x6181             STR      R1,[R0, #+24]
   \   0000008A   0x2128             MOVS     R1,#+40
   \   0000008C   0x61C1             STR      R1,[R0, #+28]
   \   0000008E   0x2100             MOVS     R1,#+0
   \   00000090   0x6201             STR      R1,[R0, #+32]
   \   00000092   0x2107             MOVS     R1,#+7
   \   00000094   0x62C1             STR      R1,[R0, #+44]
   \   00000096   0x2100             MOVS     R1,#+0
   \   00000098   0x6041             STR      R1,[R0, #+4]
    203            if(HAL_SPI_Init(&spi1_ins) != HAL_OK)
   \   0000009A   0x.... 0x....      BL       HAL_SPI_Init
    204            {
    205              /* Initialization Error */
    206              //Error_Handler();
    207            }
    208            
    209           
    210            GPIO_InitStructure.Pin = GPIO_PIN_3;
   \   0000009E   0x2008             MOVS     R0,#+8
    211            GPIO_InitStructure.Mode = GPIO_MODE_OUTPUT_PP;
    212            GPIO_InitStructure.Speed = GPIO_SPEED_FAST;
    213            GPIO_InitStructure.Pull = GPIO_PULLUP;
    214            //GPIO_InitStructure.Alternate 
    215            HAL_GPIO_Init(GPIOE, &GPIO_InitStructure);
   \   000000A0   0xA901             ADD      R1,SP,#+4
   \   000000A2   0x9001             STR      R0,[SP, #+4]
   \   000000A4   0x2001             MOVS     R0,#+1
   \   000000A6   0x9002             STR      R0,[SP, #+8]
   \   000000A8   0x2002             MOVS     R0,#+2
   \   000000AA   0x9004             STR      R0,[SP, #+16]
   \   000000AC   0x2001             MOVS     R0,#+1
   \   000000AE   0x9003             STR      R0,[SP, #+12]
   \   000000B0   0x4620             MOV      R0,R4
   \   000000B2   0x.... 0x....      BL       HAL_GPIO_Init
    216          
    217            /* Deselect : Chip Select high */
    218            HAL_GPIO_WritePin(GPIOE,GPIO_PIN_3,GPIO_PIN_SET);
   \   000000B6   0x2201             MOVS     R2,#+1
   \   000000B8   0x2108             MOVS     R1,#+8
   \   000000BA   0x4620             MOV      R0,R4
   \   000000BC   0x.... 0x....      BL       HAL_GPIO_WritePin
    219             /* sop1hc */
    220            /* Configure the SPI interrupt priority */
    221            HAL_NVIC_SetPriority(SPI1_IRQn, INTERRUPT_PRI_SDO12, 0);
   \   000000C0   0x2200             MOVS     R2,#+0
   \   000000C2   0x2100             MOVS     R1,#+0
   \   000000C4   0x2023             MOVS     R0,#+35
   \   000000C6   0x.... 0x....      BL       HAL_NVIC_SetPriority
    222          
    223            HAL_NVIC_EnableIRQ(SPI1_IRQn);
   \   000000CA   0x2023             MOVS     R0,#+35
   \   000000CC   0x.... 0x....      BL       HAL_NVIC_EnableIRQ
    224            //SPI_I2S_ITConfig(SPI1, SPI_I2S_IT_RXNE, ENABLE);
    225            //__HAL_SPI_ENABLE_IT(SPI1,SPI_IT_TXE);
    226          
    227            /* Enable SPI1  */
    228            //__HAL_SPI_ENABLE(SPI1);
    229          
    230          }
   \   000000D0   0xB006             ADD      SP,SP,#+24
   \   000000D2   0xBD10             POP      {R4,PC}          ;; return
    231          

   \                                 In section .text, align 2, keep-with-next
    232          void mySPI_SendData(uint8_t adress, uint8_t data)
    233          {
   \                     mySPI_SendData: (+1)
   \   00000000   0x.... 0x....      LDR.W    R2,??DataTable12_2
   \   00000004   0x6812             LDR      R2,[R2, #+0]
    234           
    235          while(!__HAL_SPI_GET_FLAG(&spi1_ins, SPI_FLAG_TXE)); 
   \                     ??mySPI_SendData_0: (+1)
   \   00000006   0x6893             LDR      R3,[R2, #+8]
   \   00000008   0x079B             LSLS     R3,R3,#+30
   \   0000000A   0xD5FC             BPL.N    ??mySPI_SendData_0
    236          SPI_I2S_SendData(SPI1, adress);
   \   0000000C   0x.... 0x....      LDR.W    R3,??DataTable15_1  ;; 0x4001300c
   \   00000010   0x6018             STR      R0,[R3, #+0]
    237          
    238          while(!__HAL_SPI_GET_FLAG(&spi1_ins, SPI_FLAG_RXNE));
   \                     ??mySPI_SendData_1: (+1)
   \   00000012   0x6890             LDR      R0,[R2, #+8]
   \   00000014   0x07C0             LSLS     R0,R0,#+31
   \   00000016   0xD5FC             BPL.N    ??mySPI_SendData_1
    239          SPI_I2S_ReceiveData(SPI1);
   \   00000018   0x6818             LDR      R0,[R3, #+0]
    240          
    241          while(!!__HAL_SPI_GET_FLAG(&spi1_ins, SPI_FLAG_TXE)); 
   \                     ??mySPI_SendData_2: (+1)
   \   0000001A   0x6890             LDR      R0,[R2, #+8]
   \   0000001C   0x0780             LSLS     R0,R0,#+30
   \   0000001E   0xD4FC             BMI.N    ??mySPI_SendData_2
    242          SPI_I2S_SendData(SPI1, data);
   \   00000020   0x6019             STR      R1,[R3, #+0]
    243          
    244          while(!!__HAL_SPI_GET_FLAG(&spi1_ins, SPI_FLAG_RXNE));
   \                     ??mySPI_SendData_3: (+1)
   \   00000022   0x6890             LDR      R0,[R2, #+8]
   \   00000024   0x07C0             LSLS     R0,R0,#+31
   \   00000026   0xD4FC             BMI.N    ??mySPI_SendData_3
    245          SPI_I2S_ReceiveData(SPI1);
   \   00000028   0x6818             LDR      R0,[R3, #+0]
    246           
    247          }
   \   0000002A   0x4770             BX       LR               ;; return
    248          
    249          /**
    250            * @brief  This function handles AUDIO_REC_SPI global interrupt request.
    251            * @param  None
    252            * @retval None
    253          */
    254          

   \                                 In section .text, align 2, keep-with-next
    255          void SPI1_IRQHandler(void)
    256          {  
    257          
    258          
    259          	  static uint8_t stLR,stLROld;
    260          
    261          	  /* USER CODE BEGIN SPI5_IRQn 0 */
    262          	
    263          	  /* USER CODE END SPI5_IRQn 0 */
    264          	  //HAL_SPI_IRQHandler(&hspi5);
    265          	  /* USER CODE BEGIN SPI5_IRQn 1 */
    266          	
    267          	  /* USER CODE END SPI5_IRQn 1 */
    268          		/* Check if data are available in SPI Data register */
    269          	  /* SPI in mode Receiver ----------------------------------------------------*/
    270          	  if(
    271          //	     (__HAL_SPI_GET_FLAG(&hi2s1, SPI_FLAG_OVR) == RESET)&&
    272          //	     (__HAL_SPI_GET_FLAG(&hi2s1, SPI_FLAG_RXNE) != RESET)&&
    273          		 (__HAL_I2S_GET_IT_SOURCE(&hi2s1, SPI_IT_RXNE) != RESET))
   \                     SPI1_IRQHandler: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable15_2
   \   00000004   0xF8D0 0x00C8      LDR      R0,[R0, #+200]
   \   00000008   0x6840             LDR      R0,[R0, #+4]
   \   0000000A   0x0640             LSLS     R0,R0,#+25
   \   0000000C   0xD400             BMI.N    ??SPI1_IRQHandler_0
   \   0000000E   0x4770             BX       LR
    274          	  {
    275          	
    276          	   uint16_t test;
    277          	   test =  SPI_I2S_ReceiveData(SPI1);
   \                     ??SPI1_IRQHandler_0: (+1)
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable15_1  ;; 0x4001300c
    278          	
    279          	   /* Left-Right Mic data */
    280          	   stLR= HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_4);
   \   00000014   0x2110             MOVS     R1,#+16
   \   00000016   0xB570             PUSH     {R4-R6,LR}
   \   00000018   0x6804             LDR      R4,[R0, #+0]
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable12_1  ;; 0x40020000
   \   0000001E   0x.... 0x....      BL       HAL_GPIO_ReadPin
    281          	
    282          		if (stLR==GPIO_PIN_SET)
   \   00000022   0x.... 0x....      LDR.W    R1,??DataTable15_3
   \   00000026   0x2801             CMP      R0,#+1
   \   00000028   0xB2A4             UXTH     R4,R4
   \   0000002A   0x78CA             LDRB     R2,[R1, #+3]
   \   0000002C   0xD10D             BNE.N    ??SPI1_IRQHandler_1
    283          		{
    284          				if (stLROld==GPIO_PIN_RESET)
   \   0000002E   0xB172             CBZ.N    R2,??SPI1_IRQHandler_2
    285          				{
    286          					SPI1_stNipple = (test);
    287          
    288          				}
    289          				else
    290          				{
    291          					 vRawSens1 =((test>>I2S1_stPosShft)|(SPI1_stNipple<<(SDOLEN-I2S1_stPosShft)));	
                 					 ^
Warning[Pa082]: undefined behavior: the order of volatile accesses is
          undefined in this statement
   \   00000030   0x784A             LDRB     R2,[R1, #+1]
   \   00000032   0xF9B1 0x3012      LDRSH    R3,[R1, #+18]
   \   00000036   0xFA24 0xF502      LSR      R5,R4,R2
   \   0000003A   0x784A             LDRB     R2,[R1, #+1]
   \   0000003C   0xF1C2 0x0210      RSB      R2,R2,#+16
   \   00000040   0xFA03 0xF202      LSL      R2,R3,R2
   \   00000044   0x432A             ORRS     R2,R2,R5
   \   00000046   0x80CA             STRH     R2,[R1, #+6]
   \   00000048   0xE00F             B.N      ??SPI1_IRQHandler_3
    292          				   
    293          				}
    294          		}
    295          		else
    296          		{
    297          			  if (stLROld==GPIO_PIN_SET)
   \                     ??SPI1_IRQHandler_1: (+1)
   \   0000004A   0x2A01             CMP      R2,#+1
   \   0000004C   0xD101             BNE.N    ??SPI1_IRQHandler_4
    298          			  {
    299          				  SPI1_stNipple = (test);  
   \                     ??SPI1_IRQHandler_2: (+1)
   \   0000004E   0x824C             STRH     R4,[R1, #+18]
   \   00000050   0xE00B             B.N      ??SPI1_IRQHandler_3
    300          
    301          			  }
    302          			  else
    303          			  {
    304          				  vRawSens2 =((test>>I2S1_stPosShft)|(SPI1_stNipple<<(SDOLEN-I2S1_stPosShft)));
                 				  ^
Warning[Pa082]: undefined behavior: the order of volatile accesses is
          undefined in this statement
   \                     ??SPI1_IRQHandler_4: (+1)
   \   00000052   0x784A             LDRB     R2,[R1, #+1]
   \   00000054   0xF9B1 0x3012      LDRSH    R3,[R1, #+18]
   \   00000058   0xFA24 0xF502      LSR      R5,R4,R2
   \   0000005C   0x784A             LDRB     R2,[R1, #+1]
   \   0000005E   0xF1C2 0x0210      RSB      R2,R2,#+16
   \   00000062   0xFA03 0xF202      LSL      R2,R3,R2
   \   00000066   0x432A             ORRS     R2,R2,R5
   \   00000068   0x810A             STRH     R2,[R1, #+8]
    305          
    306          			  } 	
    307          		}
    308          	   
    309          	   if (iSDO12<4*AUDIO_OUT_BUFFER_SIZE)
   \                     ??SPI1_IRQHandler_3: (+1)
   \   0000006A   0x8ACA             LDRH     R2,[R1, #+22]
   \   0000006C   0xF5B2 0x5F80      CMP      R2,#+4096
   \   00000070   0xDA06             BGE.N    ??SPI1_IRQHandler_5
    310          	   {
    311                     TestSDO12[iSDO12++]=test;
   \   00000072   0x8ACA             LDRH     R2,[R1, #+22]
   \   00000074   0x1C53             ADDS     R3,R2,#+1
   \   00000076   0xEB01 0x0242      ADD      R2,R1,R2, LSL #+1
   \   0000007A   0x82CB             STRH     R3,[R1, #+22]
   \   0000007C   0x8314             STRH     R4,[R2, #+24]
   \   0000007E   0xE001             B.N      ??SPI1_IRQHandler_6
    312          	   }
    313          	   else
    314          	   {
    315                     iSDO12=0;
   \                     ??SPI1_IRQHandler_5: (+1)
   \   00000080   0x2200             MOVS     R2,#+0
   \   00000082   0x82CA             STRH     R2,[R1, #+22]
    316          	   }
    317          #if 1
    318          		if ((WaveRec_idxSens1 < (2*AUDIO_OUT_BUFFER_SIZE-1))&&(WaveRec_idxSens2 < (2*AUDIO_OUT_BUFFER_SIZE-1)))
   \                     ??SPI1_IRQHandler_6: (+1)
   \   00000084   0x.... 0x....      LDR.W    R2,??DataTable15_4
   \   00000088   0xF240 0x74FF      MOVW     R4,#+2047
   \   0000008C   0x8813             LDRH     R3,[R2, #+0]
   \   0000008E   0x42A3             CMP      R3,R4
   \   00000090   0xBFBE             ITTT     LT 
   \   00000092   0x.... 0x....      LDRLT.W  R3,??DataTable15_5
   \   00000096   0x881D             LDRHLT   R5,[R3, #+0]
   \   00000098   0x42A5             CMPLT    R5,R4
   \   0000009A   0xDA29             BGE.N    ??SPI1_IRQHandler_7
    319          	//			  &&(stLR!=stLROld))
    320          		{
    321          	/*-------------------------------------------------------------------------------------------------------------
    322          				  
    323          		Sequence  Record Data					  Processing Data				  Player Data
    324          				  
    325          		1-------  Buffer1						  Buffer2						  Buffer3 BUF3_PLAY)
    326          				  
    327          		2-------  Buffer3						  Buffer1						  Buffer2 (BUF2_PLAY)		  
    328          				  
    329          		3-------  Buffer2						  Buffer3						  Buffer1 (BUF1_PLAY)
    330          	 ---------------------------------------------------------------------------------------------------------------*/
    331          				  /* Recording Audio Data */						 
    332          				   switch (buffer_switch)
   \   0000009C   0x.... 0x....      LDR.W    R4,??DataTable15_6
   \   000000A0   0x7824             LDRB     R4,[R4, #+0]
   \   000000A2   0xB124             CBZ.N    R4,??SPI1_IRQHandler_8
   \   000000A4   0x2C02             CMP      R4,#+2
   \   000000A6   0xD00A             BEQ.N    ??SPI1_IRQHandler_9
   \   000000A8   0xD305             BCC.N    ??SPI1_IRQHandler_10
    333          				   {
    334          							case BUF1_PLAY:
    335          #if MAIN_FFT
    336          									//Data is updated to Buffer2
    337          									if ((stLR==GPIO_PIN_SET)&&(stLROld==GPIO_PIN_RESET))
    338          										Buffer2.bufMIC1[WaveRec_idxSens1++] = vRawSens1;
    339          									if ((stLR==GPIO_PIN_RESET)&&(stLROld==GPIO_PIN_SET))
    340          										Buffer2.bufMIC2[WaveRec_idxSens2++] = vRawSens2;
    341          	
    342          #else
    343                                          if (WaveRec_idxSens1<=WaveRec_idxSens2)
                                                 ^
Warning[Pa082]: undefined behavior: the order of volatile accesses is
          undefined in this statement
    344          									Buffer2.bufMIC1[WaveRec_idxSens1++] = vRawSens1;
    345          							    else
    346          									Buffer2.bufMIC2[WaveRec_idxSens2++] = vRawSens2;									
    347          #endif
    348          	
    349          									break;
    350          							case BUF2_PLAY:
    351          #if MAIN_FFT
    352          									//Data is updated to Buffer3				 
    353          									if ((stLR==GPIO_PIN_SET)&&(stLROld==GPIO_PIN_RESET))
    354          										Buffer3.bufMIC1[WaveRec_idxSens1++] = vRawSens1;
    355          									if ((stLR==GPIO_PIN_RESET)&&(stLROld==GPIO_PIN_SET))
    356          										Buffer3.bufMIC2[WaveRec_idxSens2++] = vRawSens2;
    357          #else
    358                                          if (WaveRec_idxSens1<=WaveRec_idxSens2)
                                                 ^
Warning[Pa082]: undefined behavior: the order of volatile accesses is
          undefined in this statement
    359          									Buffer3.bufMIC1[WaveRec_idxSens1++] = vRawSens1;
    360          							    else
    361          									Buffer3.bufMIC2[WaveRec_idxSens2++] = vRawSens2;	
    362          #endif
    363          									break;
    364          							case BUF3_PLAY:
    365          #if MAIN_FFT
    366          	
    367          									//Data is update to Buffer1 	 
    368          									if ((stLR==GPIO_PIN_SET)&&(stLROld==GPIO_PIN_RESET))
    369          										Buffer1.bufMIC1[WaveRec_idxSens1++] = vRawSens1;
    370          									if ((stLR==GPIO_PIN_RESET)&&(stLROld==GPIO_PIN_SET))
    371          										Buffer1.bufMIC2[ WaveRec_idxSens2++] = vRawSens2;
    372          #else
    373                                          if (WaveRec_idxSens1<=WaveRec_idxSens2)
                                                 ^
Warning[Pa082]: undefined behavior: the order of volatile accesses is
          undefined in this statement
    374          									Buffer1.bufMIC1[WaveRec_idxSens1++] = vRawSens1;
    375          							    else
    376          									Buffer1.bufMIC2[WaveRec_idxSens2++] = vRawSens2;									
    377          #endif
    378          									break;
    379          							default:
    380          									break; 
    381          				   }
    382          			
    383          		 } 
    384          #endif		
    385          		/* Update Old value */	  
    386          		stLROld=stLR;	  
   \   000000AA   0x70C8             STRB     R0,[R1, #+3]
    387          		 
    388          	  } 	 
    389          
    390          }
   \   000000AC   0xBD70             POP      {R4-R6,PC}
   \                     ??SPI1_IRQHandler_8: (+1)
   \   000000AE   0x881C             LDRH     R4,[R3, #+0]
   \   000000B0   0x.... 0x....      LDR.W    R5,??DataTable15_7  ;; 0xc00080a0
   \   000000B4   0xE006             B.N      ??SPI1_IRQHandler_11
   \                     ??SPI1_IRQHandler_10: (+1)
   \   000000B6   0x881C             LDRH     R4,[R3, #+0]
   \   000000B8   0x.... 0x....      LDR.W    R5,??DataTable15_8  ;; 0xc0010140
   \   000000BC   0xE002             B.N      ??SPI1_IRQHandler_11
   \                     ??SPI1_IRQHandler_9: (+1)
   \   000000BE   0x881C             LDRH     R4,[R3, #+0]
   \   000000C0   0xF04F 0x4540      MOV      R5,#-1073741824
   \                     ??SPI1_IRQHandler_11: (+1)
   \   000000C4   0x8816             LDRH     R6,[R2, #+0]
   \   000000C6   0x42B4             CMP      R4,R6
   \   000000C8   0xD308             BCC.N    ??SPI1_IRQHandler_12
   \   000000CA   0x8813             LDRH     R3,[R2, #+0]
   \   000000CC   0x1C5C             ADDS     R4,R3,#+1
   \   000000CE   0x8014             STRH     R4,[R2, #+0]
   \   000000D0   0xF9B1 0x2006      LDRSH    R2,[R1, #+6]
   \   000000D4   0xF825 0x2013      STRH     R2,[R5, R3, LSL #+1]
   \   000000D8   0x70C8             STRB     R0,[R1, #+3]
   \   000000DA   0xBD70             POP      {R4-R6,PC}
   \                     ??SPI1_IRQHandler_12: (+1)
   \   000000DC   0x881A             LDRH     R2,[R3, #+0]
   \   000000DE   0x1C54             ADDS     R4,R2,#+1
   \   000000E0   0xEB05 0x0242      ADD      R2,R5,R2, LSL #+1
   \   000000E4   0x801C             STRH     R4,[R3, #+0]
   \   000000E6   0xF9B1 0x3008      LDRSH    R3,[R1, #+8]
   \   000000EA   0xF241 0x0414      MOVW     R4,#+4116
   \   000000EE   0x52A3             STRH     R3,[R4, R2]
   \                     ??SPI1_IRQHandler_7: (+1)
   \   000000F0   0x70C8             STRB     R0,[R1, #+3]
   \   000000F2   0xBD70             POP      {R4-R6,PC}       ;; return
   \   000000F4                      REQUIRE Buffer2
   \   000000F4                      REQUIRE Buffer3
   \   000000F4                      REQUIRE Buffer1
    391          
    392          
    393          /**
    394            * @brief  This function handles AUDIO_REC_SPI global interrupt request.
    395            * @param  None
    396            * @retval None
    397          */
    398          

   \                                 In section .text, align 2, keep-with-next
    399          void SPI2_IRQHandler(void)
    400          {      
    401              uint16_t app;
    402              static uint8_t I2S2_stLR, I2S2_stLROld;
    403          
    404            /* Check if data are available in SPI Data register */
    405             if (
    406          //	   (__HAL_SPI_GET_FLAG(&hi2s2, SPI_FLAG_OVR) == RESET)&&
    407          //   	    (__HAL_SPI_GET_FLAG(&hi2s2, SPI_FLAG_RXNE) != RESET)&&
    408             	    (__HAL_I2S_GET_IT_SOURCE(&hi2s2, SPI_IT_RXNE)!=RESET)
    409             	  )
   \                     SPI2_IRQHandler: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable15_2
   \   00000004   0xF8D0 0x0108      LDR      R0,[R0, #+264]
   \   00000008   0x6840             LDR      R0,[R0, #+4]
   \   0000000A   0x0640             LSLS     R0,R0,#+25
   \   0000000C   0xD400             BMI.N    ??SPI2_IRQHandler_0
   \   0000000E   0x4770             BX       LR
    410             {
    411              
    412               app = SPI_I2S_ReceiveData(SPI2);   
   \                     ??SPI2_IRQHandler_0: (+1)
   \   00000010   0xB5F0             PUSH     {R4-R7,LR}
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable15_9  ;; 0x4000380c
   \   00000016   0xB081             SUB      SP,SP,#+4
    413               //SPI_I2S_SendData(SPI2, 3333);
    414          
    415          	 I2S2_stLR= HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_4);
   \   00000018   0x2110             MOVS     R1,#+16
   \   0000001A   0x6804             LDR      R4,[R0, #+0]
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable12_1  ;; 0x40020000
   \   00000020   0x.... 0x....      BL       HAL_GPIO_ReadPin
    416          
    417          	 if (I2S2_stLR==GPIO_PIN_SET)
   \   00000024   0x.... 0x....      LDR.W    R1,??DataTable15_10
   \   00000028   0x2801             CMP      R0,#+1
   \   0000002A   0xB2A4             UXTH     R4,R4
   \   0000002C   0x784A             LDRB     R2,[R1, #+1]
   \   0000002E   0xD110             BNE.N    ??SPI2_IRQHandler_1
    418          	 {
    419                  if (I2S2_stLROld==GPIO_PIN_SET)
   \   00000030   0x2A01             CMP      R2,#+1
   \   00000032   0xD00F             BEQ.N    ??SPI2_IRQHandler_2
    420                  {
    421                      I2S2_stNipple = app;           
    422                  }
    423          		else
    424          		{
    425          
    426          			 vRawSens3 = ((app>>I2S2_stPosShft)|(I2S2_stNipple<<(SDOLEN-I2S2_stPosShft)));
                 			 ^
Warning[Pa082]: undefined behavior: the order of volatile accesses is
          undefined in this statement
   \   00000034   0x780A             LDRB     R2,[R1, #+0]
   \   00000036   0xF9B1 0x3002      LDRSH    R3,[R1, #+2]
   \   0000003A   0xFA24 0xF502      LSR      R5,R4,R2
   \   0000003E   0x780A             LDRB     R2,[R1, #+0]
   \   00000040   0xF1C2 0x0210      RSB      R2,R2,#+16
   \   00000044   0xFA03 0xF202      LSL      R2,R3,R2
   \   00000048   0x432A             ORRS     R2,R2,R5
   \   0000004A   0x.... 0x....      LDR.W    R3,??DataTable15_3
   \   0000004E   0x819A             STRH     R2,[R3, #+12]
   \   00000050   0xE010             B.N      ??SPI2_IRQHandler_3
    427          
    428          		}
    429          	 }
    430          	 else
    431          	 {
    432                  if (I2S2_stLROld==GPIO_PIN_RESET)
   \                     ??SPI2_IRQHandler_1: (+1)
   \   00000052   0xB90A             CBNZ.N   R2,??SPI2_IRQHandler_4
    433                  {
    434                      I2S2_stNipple = app;
   \                     ??SPI2_IRQHandler_2: (+1)
   \   00000054   0x804C             STRH     R4,[R1, #+2]
   \   00000056   0xE00D             B.N      ??SPI2_IRQHandler_3
    435          
    436                  }
    437          		else
    438          		{
    439                      vRawSens4 =((app>>I2S2_stPosShft)|(I2S2_stNipple<<(SDOLEN-I2S2_stPosShft)));
                             ^
Warning[Pa082]: undefined behavior: the order of volatile accesses is
          undefined in this statement
   \                     ??SPI2_IRQHandler_4: (+1)
   \   00000058   0x780A             LDRB     R2,[R1, #+0]
   \   0000005A   0xF9B1 0x3002      LDRSH    R3,[R1, #+2]
   \   0000005E   0xFA24 0xF502      LSR      R5,R4,R2
   \   00000062   0x780A             LDRB     R2,[R1, #+0]
   \   00000064   0xF1C2 0x0210      RSB      R2,R2,#+16
   \   00000068   0xFA03 0xF202      LSL      R2,R3,R2
   \   0000006C   0x432A             ORRS     R2,R2,R5
   \   0000006E   0x.... 0x....      LDR.W    R3,??DataTable15_3
   \   00000072   0x815A             STRH     R2,[R3, #+10]
    440          		
    441          		}
    442          	 }
    443          
    444          	 	if (iSDO34<4*AUDIO_OUT_BUFFER_SIZE)
   \                     ??SPI2_IRQHandler_3: (+1)
   \   00000074   0x888A             LDRH     R2,[R1, #+4]
   \   00000076   0xF5B2 0x5F80      CMP      R2,#+4096
   \   0000007A   0xDA06             BGE.N    ??SPI2_IRQHandler_5
    445          	   {
    446                     TestSDO34[iSDO34++]=app;
   \   0000007C   0x888A             LDRH     R2,[R1, #+4]
   \   0000007E   0x1C53             ADDS     R3,R2,#+1
   \   00000080   0xEB01 0x0242      ADD      R2,R1,R2, LSL #+1
   \   00000084   0x808B             STRH     R3,[R1, #+4]
   \   00000086   0x8114             STRH     R4,[R2, #+8]
   \   00000088   0xE001             B.N      ??SPI2_IRQHandler_6
    447          	   }
    448          	   else
    449          	   {
    450                     iSDO34=0;
   \                     ??SPI2_IRQHandler_5: (+1)
   \   0000008A   0x2200             MOVS     R2,#+0
   \   0000008C   0x808A             STRH     R2,[R1, #+4]
    451          	   }
    452          	 
    453          #if 1
    454          	 if ((WaveRec_idxSens3 < (2*AUDIO_OUT_BUFFER_SIZE-1))&&(WaveRec_idxSens4 < (2*AUDIO_OUT_BUFFER_SIZE-1)))
   \                     ??SPI2_IRQHandler_6: (+1)
   \   0000008E   0x.... 0x....      LDR.W    R3,??DataTable15_11
   \   00000092   0xF240 0x72FF      MOVW     R2,#+2047
   \   00000096   0x881C             LDRH     R4,[R3, #+0]
   \   00000098   0x4294             CMP      R4,R2
   \   0000009A   0xBFBE             ITTT     LT 
   \   0000009C   0x.... 0x....      LDRLT.W  R4,??DataTable15_12
   \   000000A0   0x8825             LDRHLT   R5,[R4, #+0]
   \   000000A2   0x4295             CMPLT    R5,R2
   \   000000A4   0xDA30             BGE.N    ??SPI2_IRQHandler_7
    455          //             &&(I2S2_stLR!=I2S2_stLROld))
    456          	 {
    457          /*-------------------------------------------------------------------------------------------------------------
    458          			  
    459          	Sequence  Record Data                     Processing Data                 Player Data
    460          			  
    461          	1-------  Buffer1                         Buffer2                         Buffer3 (BUF3_PLAY)
    462          			  
    463          	2-------  Buffer3                         Buffer1                         Buffer2 (BUF2_PLAY)		  
    464          			  
    465          	3-------  Buffer2                         Buffer3                         Buffer1 (BUF1_PLAY)
    466           ---------------------------------------------------------------------------------------------------------------*/
    467          		/* Recording Audio Data */			             
    468          		 switch (buffer_switch)
   \   000000A6   0x.... 0x....      LDR.W    R2,??DataTable15_6
   \   000000AA   0x7812             LDRB     R2,[R2, #+0]
   \   000000AC   0xB12A             CBZ.N    R2,??SPI2_IRQHandler_8
   \   000000AE   0x2A02             CMP      R2,#+2
   \   000000B0   0xD00B             BEQ.N    ??SPI2_IRQHandler_9
   \   000000B2   0xD306             BCC.N    ??SPI2_IRQHandler_10
    469          		 {
    470          			  case BUF1_PLAY:
    471          				  //Data is updated to Buffer2
    472          				  //PDM_Filter_64_LSB((uint8_t *)InternalBuffer, (uint16_t *)(buffer2+cntPos*PCM_OUT_SIZE), volume , (PDMFilter_InitStruct *)&Filter[0]);
    473          #if MAIN_FFT
    474          				  if ((I2S2_stLR==GPIO_PIN_SET)&&(I2S2_stLROld==GPIO_PIN_RESET))
    475          				      Buffer2.bufMIC3[WaveRec_idxSens3++] = vRawSens3;
    476          				  if ((I2S2_stLR==GPIO_PIN_RESET)&&(I2S2_stLROld==GPIO_PIN_SET))
    477          				      Buffer2.bufMIC4[WaveRec_idxSens4++] = vRawSens4;
    478          #else
    479                            if (WaveRec_idxSens3<=WaveRec_idxSens4) 
                                   ^
Warning[Pa082]: undefined behavior: the order of volatile accesses is
          undefined in this statement
    480                                Buffer2.bufMIC3[WaveRec_idxSens3++] = vRawSens3;
    481          				  else
    482                                Buffer2.bufMIC4[WaveRec_idxSens4++] = vRawSens4;			  
    483          #endif 
    484          				  break;
    485          			  case BUF2_PLAY:
    486          				  //Data is updated to Buffer3
    487          				  //PDM_Filter_64_LSB((uint8_t *)InternalBuffer, (uint16_t *)(buffer3+cntPos*PCM_OUT_SIZE), volume , (PDMFilter_InitStruct *)&Filter[0]);
    488          #if MAIN_FFT
    489          				  if ((I2S2_stLR==GPIO_PIN_SET)&&(I2S2_stLROld==GPIO_PIN_RESET))
    490          				      Buffer3.bufMIC3[WaveRec_idxSens3++] = vRawSens3;
    491          				  if ((I2S2_stLR==GPIO_PIN_RESET)&&(I2S2_stLROld==GPIO_PIN_SET))
    492          				      Buffer3.bufMIC4[WaveRec_idxSens4++] = vRawSens4;
    493          #else
    494                            if (WaveRec_idxSens3<=WaveRec_idxSens4) 
                                   ^
Warning[Pa082]: undefined behavior: the order of volatile accesses is
          undefined in this statement
    495                                Buffer3.bufMIC3[WaveRec_idxSens3++] = vRawSens3;
    496          				  else
    497                                Buffer3.bufMIC4[WaveRec_idxSens4++] = vRawSens4;			   
    498          #endif
    499          				  break;
    500          			  case BUF3_PLAY:
    501          				  //Data is update to Buffer1
    502          				  //PDM_Filter_64_LSB((uint8_t *)InternalBuffer, (uint16_t *)(buffer1+cntPos*PCM_OUT_SIZE), volume , (PDMFilter_InitStruct *)&Filter[0]);
    503          #if MAIN_FFT
    504          				  if ((I2S2_stLR==GPIO_PIN_SET)&&(I2S2_stLROld==GPIO_PIN_RESET))
    505               				  Buffer1.bufMIC3[WaveRec_idxSens3++] = vRawSens3;
    506            				  if ((I2S2_stLR==GPIO_PIN_RESET)&&(I2S2_stLROld==GPIO_PIN_SET))
    507               				  Buffer1.bufMIC4[ WaveRec_idxSens4++] = vRawSens4;
    508          #else
    509                            if (WaveRec_idxSens3<=WaveRec_idxSens4) 
                                   ^
Warning[Pa082]: undefined behavior: the order of volatile accesses is
          undefined in this statement
    510                                Buffer1.bufMIC3[WaveRec_idxSens3++] = vRawSens3;
    511          				  else
    512                                Buffer1.bufMIC4[WaveRec_idxSens4++] = vRawSens4;
    513          
    514          
    515          #endif
    516          				  break;
    517          			  default:
    518          				  break; 
    519          		 }
    520          		
    521          	 }          
    522          #endif		  
    523          	 I2S2_stLROld = I2S2_stLR;
   \   000000B4   0x7048             STRB     R0,[R1, #+1]
    524          
    525             }
    526          
    527          }
   \   000000B6   0xB001             ADD      SP,SP,#+4
   \   000000B8   0xBDF0             POP      {R4-R7,PC}
   \                     ??SPI2_IRQHandler_8: (+1)
   \   000000BA   0x8825             LDRH     R5,[R4, #+0]
   \   000000BC   0x.... 0x....      LDR.W    R6,??DataTable15_7  ;; 0xc00080a0
   \   000000C0   0xE006             B.N      ??SPI2_IRQHandler_11
   \                     ??SPI2_IRQHandler_10: (+1)
   \   000000C2   0x8825             LDRH     R5,[R4, #+0]
   \   000000C4   0x.... 0x....      LDR.W    R6,??DataTable15_8  ;; 0xc0010140
   \   000000C8   0xE002             B.N      ??SPI2_IRQHandler_11
   \                     ??SPI2_IRQHandler_9: (+1)
   \   000000CA   0x8825             LDRH     R5,[R4, #+0]
   \   000000CC   0xF04F 0x4640      MOV      R6,#-1073741824
   \                     ??SPI2_IRQHandler_11: (+1)
   \   000000D0   0x881F             LDRH     R7,[R3, #+0]
   \   000000D2   0x.... 0x....      LDR.W    R2,??DataTable15_3
   \   000000D6   0x42BD             CMP      R5,R7
   \   000000D8   0xD30C             BCC.N    ??SPI2_IRQHandler_12
   \   000000DA   0x881C             LDRH     R4,[R3, #+0]
   \   000000DC   0x1C65             ADDS     R5,R4,#+1
   \   000000DE   0x801D             STRH     R5,[R3, #+0]
   \   000000E0   0xF9B2 0x200C      LDRSH    R2,[R2, #+12]
   \   000000E4   0xEB06 0x0344      ADD      R3,R6,R4, LSL #+1
   \   000000E8   0xF242 0x0428      MOVW     R4,#+8232
   \   000000EC   0x52E2             STRH     R2,[R4, R3]
   \   000000EE   0x7048             STRB     R0,[R1, #+1]
   \   000000F0   0xB001             ADD      SP,SP,#+4
   \   000000F2   0xBDF0             POP      {R4-R7,PC}
   \                     ??SPI2_IRQHandler_12: (+1)
   \   000000F4   0x8823             LDRH     R3,[R4, #+0]
   \   000000F6   0x1C5D             ADDS     R5,R3,#+1
   \   000000F8   0xEB06 0x0343      ADD      R3,R6,R3, LSL #+1
   \   000000FC   0x8025             STRH     R5,[R4, #+0]
   \   000000FE   0xF9B2 0x200A      LDRSH    R2,[R2, #+10]
   \   00000102   0xF243 0x043C      MOVW     R4,#+12348
   \   00000106   0x52E2             STRH     R2,[R4, R3]
   \                     ??SPI2_IRQHandler_7: (+1)
   \   00000108   0x7048             STRB     R0,[R1, #+1]
   \   0000010A   0xB001             ADD      SP,SP,#+4
   \   0000010C   0xBDF0             POP      {R4-R7,PC}       ;; return
   \   0000010E                      REQUIRE Buffer2
   \   0000010E                      REQUIRE Buffer3
   \   0000010E                      REQUIRE Buffer1
    528          
    529          

   \                                 In section .text, align 2, keep-with-next
    530          void SPI4_IRQHandler(void)
    531          {
    532            static uint8_t Main_stLR, Main_stLROld;
    533          
    534          
    535          
    536            /* USER CODE BEGIN SPI5_IRQn 0 */
    537          
    538            /* USER CODE END SPI5_IRQn 0 */
    539            //HAL_SPI_IRQHandler(&hspi5);
    540            /* USER CODE BEGIN SPI5_IRQn 1 */
    541          
    542            /* USER CODE END SPI5_IRQn 1 */
    543              /* Check if data are available in SPI Data register */
    544            /* SPI in mode Receiver ----------------------------------------------------*/
    545            if(
    546          //    (__HAL_SPI_GET_FLAG(&hspi4, SPI_FLAG_OVR) == RESET)&&
    547          //    (__HAL_SPI_GET_FLAG(&hspi4, SPI_FLAG_RXNE) != RESET)&&
    548               (__HAL_SPI_GET_IT_SOURCE(&hspi4, SPI_IT_RXNE) != RESET))
   \                     SPI4_IRQHandler: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable15_13
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x6840             LDR      R0,[R0, #+4]
   \   00000008   0x0640             LSLS     R0,R0,#+25
   \   0000000A   0xD400             BMI.N    ??SPI4_IRQHandler_0
   \   0000000C   0x4770             BX       LR
    549            {
    550          
    551                  uint16_t test;
    552                  test =  SPI_I2S_ReceiveData(SPI4);
   \                     ??SPI4_IRQHandler_0: (+1)
   \   0000000E   0xB5F0             PUSH     {R4-R7,LR}
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable15_14  ;; 0x4001340c
   \   00000014   0xB081             SUB      SP,SP,#+4
    553          
    554                  /* Left-Right Mic data */
    555                  Main_stLR= HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_4);
   \   00000016   0x2110             MOVS     R1,#+16
   \   00000018   0x6804             LDR      R4,[R0, #+0]
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable12_1  ;; 0x40020000
   \   0000001E   0x.... 0x....      BL       HAL_GPIO_ReadPin
    556          
    557                  /* STM32F746 read data from STA321MP, the data is shifted few bit     */
    558                  /* Data from STA321MP is 32bit formart                                */
    559                  /* SPI is just able to read 16 bit format                             */
    560                  /* Therefore, it needs to correct                                     */
    561                  
    562                  /* ---------------------------+++++++++++++++++++++++++++++++---------*/
    563                  /*                  ______DATAL_____              ______DATAR_____    */
    564                  /*                  _____vRawSens5__              ______vRawSens6_    */       
    565          	if (Main_stLR==GPIO_PIN_SET)
   \   00000022   0x.... 0x....      LDR.W    R1,??DataTable15_3
   \   00000026   0x2801             CMP      R0,#+1
   \   00000028   0xB2A4             UXTH     R4,R4
   \   0000002A   0x790A             LDRB     R2,[R1, #+4]
   \   0000002C   0xD133             BNE.N    ??SPI4_IRQHandler_1
    566          	{
    567                      if (Main_stLROld==GPIO_PIN_SET)
   \   0000002E   0x2A01             CMP      R2,#+1
   \   00000030   0xD032             BEQ.N    ??SPI4_IRQHandler_2
    568                      {
    569                         I2S1_stNipple = (test);    
    570                      }
    571                      else
    572                      {
    573                         vRawSens5 =((test>>SPI4_stPosShft)|(I2S1_stNipple<<(SDOLEN-SPI4_stPosShft)));	
                                ^
Warning[Pa082]: undefined behavior: the order of volatile accesses is
          undefined in this statement
   \   00000032   0x788A             LDRB     R2,[R1, #+2]
   \   00000034   0xF9B1 0x3014      LDRSH    R3,[R1, #+20]
    574                         if (WaveRec_idxSens5 < (2*AUDIO_OUT_BUFFER_SIZE-2))
   \   00000038   0xF240 0x75FE      MOVW     R5,#+2046
   \   0000003C   0x40D4             LSRS     R4,R4,R2
   \   0000003E   0x788A             LDRB     R2,[R1, #+2]
   \   00000040   0xF1C2 0x0210      RSB      R2,R2,#+16
   \   00000044   0xFA03 0xF202      LSL      R2,R3,R2
   \   00000048   0x4322             ORRS     R2,R2,R4
   \   0000004A   0x.... 0x....      LDR.W    R3,??DataTable15_15
   \   0000004E   0x81CA             STRH     R2,[R1, #+14]
   \   00000050   0x881C             LDRH     R4,[R3, #+0]
   \   00000052   0x42AC             CMP      R4,R5
   \   00000054   0xDA60             BGE.N    ??SPI4_IRQHandler_3
    575                         {
    576                              /*-------------------------------------------------------------------------------------------------------------                                             
    577                              Sequence  Record Data                     Processing Data                 Player Data
    578                                                
    579                              1-------  Buffer1                         Buffer2                         Buffer3 BUF3_PLAY)
    580                                                
    581                              2-------  Buffer3                         Buffer1                         Buffer2 (BUF2_PLAY)		  
    582                                                
    583                              3-------  Buffer2                         Buffer3                         Buffer1 (BUF1_PLAY)
    584                               ---------------------------------------------------------------------------------------------------------------*/                     
    585                               /* Recording Audio Data */			             
    586                               switch (buffer_switch)
   \   00000056   0x.... 0x....      LDR.W    R4,??DataTable15_6
   \   0000005A   0x7824             LDRB     R4,[R4, #+0]
   \   0000005C   0xB12C             CBZ.N    R4,??SPI4_IRQHandler_4
   \   0000005E   0x2C02             CMP      R4,#+2
   \   00000060   0xD013             BEQ.N    ??SPI4_IRQHandler_5
   \   00000062   0xD30A             BCC.N    ??SPI4_IRQHandler_6
    587                               {
    588                                   case BUF1_PLAY:
    589                                       Buffer2.bufMIC5[WaveRec_idxSens5++] = vRawSens5;
    590                                       Buffer2.bufMIC5[WaveRec_idxSens5++] = vRawSens5;
    591                                       break;
    592                                   case BUF2_PLAY:
    593                                       Buffer3.bufMIC5[WaveRec_idxSens5++] = vRawSens5;
    594                                       Buffer3.bufMIC5[WaveRec_idxSens5++] = vRawSens5;
    595                                       break;
    596                                   case BUF3_PLAY:
    597                                       Buffer1.bufMIC5[WaveRec_idxSens5++] = vRawSens5;
    598                                       Buffer1.bufMIC5[WaveRec_idxSens5++] = vRawSens5;
    599                                       break;                          
    600                                   default:
    601                                       break;
    602                               }
    603                         }
    604          	   }
    605                  }
    606          	else
    607          	{
    608                    if (Main_stLROld==GPIO_PIN_RESET)
    609                    {
    610                        I2S1_stNipple = (test);	  
    611          
    612                    }
    613                    else
    614                    {
    615                         vRawSens6 =((test>>SPI4_stPosShft)|(I2S1_stNipple<<(SDOLEN-SPI4_stPosShft)));
                                ^
Warning[Pa082]: undefined behavior: the order of volatile accesses is
          undefined in this statement
    616                         if (WaveRec_idxSens6 < (2*AUDIO_OUT_BUFFER_SIZE-2))
    617                         {
    618                              /*-------------------------------------------------------------------------------------------------------------                                             
    619                              Sequence  Record Data                     Processing Data                 Player Data
    620                                                
    621                              1-------  Buffer1                         Buffer2                         Buffer3 BUF3_PLAY)
    622                                                
    623                              2-------  Buffer3                         Buffer1                         Buffer2 (BUF2_PLAY)		  
    624                                                
    625                              3-------  Buffer2                         Buffer3                         Buffer1 (BUF1_PLAY)
    626                               ---------------------------------------------------------------------------------------------------------------*/                 
    627                                /* Recording Audio Data */			             
    628                               switch (buffer_switch)
    629                               {
    630                                   case BUF1_PLAY:
    631                                       Buffer2.bufMIC6[WaveRec_idxSens6++] = vRawSens6;
    632                                       Buffer2.bufMIC6[WaveRec_idxSens6++] = vRawSens6;
    633                                       break;
    634                                   case BUF2_PLAY:
    635                                       Buffer3.bufMIC6[WaveRec_idxSens6++] = vRawSens6;
    636                                       Buffer3.bufMIC6[WaveRec_idxSens6++] = vRawSens6;
    637                                       break;
    638                                   case BUF3_PLAY:
    639                                       Buffer1.bufMIC6[WaveRec_idxSens6++] = vRawSens6;
    640                                       Buffer1.bufMIC6[WaveRec_idxSens6++] = vRawSens6;
    641                                       break;                          
    642                                   default:
    643                                       break;
    644                               }
    645                         }
    646                    }		
    647          	}
    648          
    649          	/* The code to store data in to buffer for testing purpose */
    650          	//if (iSDO56<4*AUDIO_OUT_BUFFER_SIZE)
    651          	//{
    652          	//	TestSDO56[iSDO56++]=test;
    653          	//}
    654          	//else
    655          	//{
    656          	//	iSDO56=0;
    657          	//}
    658          
    659          
    660          	/* Update Old value */	  
    661          	Main_stLROld=Main_stLR;	  
   \   00000064   0x7108             STRB     R0,[R1, #+4]
    662               
    663            }      
    664          }
   \   00000066   0xB001             ADD      SP,SP,#+4
   \   00000068   0xBDF0             POP      {R4-R7,PC}
   \                     ??SPI4_IRQHandler_4: (+1)
   \   0000006A   0x881E             LDRH     R6,[R3, #+0]
   \   0000006C   0x.... 0x....      LDR.W    R5,??DataTable15_7  ;; 0xc00080a0
   \   00000070   0x1C74             ADDS     R4,R6,#+1
   \   00000072   0x801C             STRH     R4,[R3, #+0]
   \   00000074   0xF244 0x0450      MOVW     R4,#+16464
   \   00000078   0xE045             B.N      ??SPI4_IRQHandler_7
   \                     ??SPI4_IRQHandler_6: (+1)
   \   0000007A   0x881E             LDRH     R6,[R3, #+0]
   \   0000007C   0x.... 0x....      LDR.W    R5,??DataTable15_8  ;; 0xc0010140
   \   00000080   0x1C74             ADDS     R4,R6,#+1
   \   00000082   0x801C             STRH     R4,[R3, #+0]
   \   00000084   0xF244 0x0450      MOVW     R4,#+16464
   \   00000088   0xE03D             B.N      ??SPI4_IRQHandler_7
   \                     ??SPI4_IRQHandler_5: (+1)
   \   0000008A   0x881E             LDRH     R6,[R3, #+0]
   \   0000008C   0x1C74             ADDS     R4,R6,#+1
   \   0000008E   0x801C             STRH     R4,[R3, #+0]
   \   00000090   0xF244 0x0450      MOVW     R4,#+16464
   \   00000094   0xE035             B.N      ??SPI4_IRQHandler_8
   \                     ??SPI4_IRQHandler_1: (+1)
   \   00000096   0xB91A             CBNZ.N   R2,??SPI4_IRQHandler_9
   \                     ??SPI4_IRQHandler_2: (+1)
   \   00000098   0x828C             STRH     R4,[R1, #+20]
   \   0000009A   0x7108             STRB     R0,[R1, #+4]
   \   0000009C   0xB001             ADD      SP,SP,#+4
   \   0000009E   0xBDF0             POP      {R4-R7,PC}
   \                     ??SPI4_IRQHandler_9: (+1)
   \   000000A0   0x788A             LDRB     R2,[R1, #+2]
   \   000000A2   0xF9B1 0x3014      LDRSH    R3,[R1, #+20]
   \   000000A6   0xF240 0x75FE      MOVW     R5,#+2046
   \   000000AA   0x40D4             LSRS     R4,R4,R2
   \   000000AC   0x788A             LDRB     R2,[R1, #+2]
   \   000000AE   0xF1C2 0x0210      RSB      R2,R2,#+16
   \   000000B2   0xFA03 0xF202      LSL      R2,R3,R2
   \   000000B6   0x4322             ORRS     R2,R2,R4
   \   000000B8   0x.... 0x....      LDR.W    R3,??DataTable16
   \   000000BC   0x820A             STRH     R2,[R1, #+16]
   \   000000BE   0x881C             LDRH     R4,[R3, #+0]
   \   000000C0   0x42AC             CMP      R4,R5
   \   000000C2   0xDA29             BGE.N    ??SPI4_IRQHandler_3
   \   000000C4   0x.... 0x....      LDR.W    R4,??DataTable15_6
   \   000000C8   0x7824             LDRB     R4,[R4, #+0]
   \   000000CA   0xB12C             CBZ.N    R4,??SPI4_IRQHandler_10
   \   000000CC   0x2C02             CMP      R4,#+2
   \   000000CE   0xD013             BEQ.N    ??SPI4_IRQHandler_11
   \   000000D0   0xD30A             BCC.N    ??SPI4_IRQHandler_12
   \   000000D2   0x7108             STRB     R0,[R1, #+4]
   \   000000D4   0xB001             ADD      SP,SP,#+4
   \   000000D6   0xBDF0             POP      {R4-R7,PC}
   \                     ??SPI4_IRQHandler_10: (+1)
   \   000000D8   0x881E             LDRH     R6,[R3, #+0]
   \   000000DA   0x.... 0x....      LDR.W    R5,??DataTable15_7  ;; 0xc00080a0
   \   000000DE   0x1C74             ADDS     R4,R6,#+1
   \   000000E0   0x801C             STRH     R4,[R3, #+0]
   \   000000E2   0xF245 0x0464      MOVW     R4,#+20580
   \   000000E6   0xE00E             B.N      ??SPI4_IRQHandler_7
   \                     ??SPI4_IRQHandler_12: (+1)
   \   000000E8   0x881E             LDRH     R6,[R3, #+0]
   \   000000EA   0x.... 0x....      LDR.W    R5,??DataTable15_8  ;; 0xc0010140
   \   000000EE   0x1C74             ADDS     R4,R6,#+1
   \   000000F0   0x801C             STRH     R4,[R3, #+0]
   \   000000F2   0xF245 0x0464      MOVW     R4,#+20580
   \   000000F6   0xE006             B.N      ??SPI4_IRQHandler_7
   \                     ??SPI4_IRQHandler_11: (+1)
   \   000000F8   0x881E             LDRH     R6,[R3, #+0]
   \   000000FA   0x1C74             ADDS     R4,R6,#+1
   \   000000FC   0x801C             STRH     R4,[R3, #+0]
   \   000000FE   0xF245 0x0464      MOVW     R4,#+20580
   \                     ??SPI4_IRQHandler_8: (+1)
   \   00000102   0xF04F 0x4540      MOV      R5,#-1073741824
   \                     ??SPI4_IRQHandler_7: (+1)
   \   00000106   0xEB05 0x0646      ADD      R6,R5,R6, LSL #+1
   \   0000010A   0x53A2             STRH     R2,[R4, R6]
   \   0000010C   0x881E             LDRH     R6,[R3, #+0]
   \   0000010E   0x1C77             ADDS     R7,R6,#+1
   \   00000110   0x801F             STRH     R7,[R3, #+0]
   \   00000112   0xEB05 0x0346      ADD      R3,R5,R6, LSL #+1
   \   00000116   0x52E2             STRH     R2,[R4, R3]
   \                     ??SPI4_IRQHandler_3: (+1)
   \   00000118   0x7108             STRB     R0,[R1, #+4]
   \   0000011A   0xB001             ADD      SP,SP,#+4
   \   0000011C   0xBDF0             POP      {R4-R7,PC}       ;; return
   \   0000011E                      REQUIRE Buffer2
   \   0000011E                      REQUIRE Buffer3
   \   0000011E                      REQUIRE Buffer1

   \                                 In section .bss, align 4
   \                     WaveRecord_flgInt:
   \   00000000                      DS8 1
   \                     I2S1_stPosShft:
   \   00000001                      DS8 1
   \                     SPI4_stPosShft:
   \   00000002                      DS8 1
   \   00000003                      DS8 1
   \   00000004                      DS8 1
   \   00000005                      DS8 1
   \                     vRawSens1:
   \   00000006                      DS8 2
   \                     vRawSens2:
   \   00000008                      DS8 2
   \                     vRawSens4:
   \   0000000A                      DS8 2
   \                     vRawSens3:
   \   0000000C                      DS8 2
   \                     vRawSens5:
   \   0000000E                      DS8 2
   \                     vRawSens6:
   \   00000010                      DS8 2
   \                     SPI1_stNipple:
   \   00000012                      DS8 2
   \                     I2S1_stNipple:
   \   00000014                      DS8 2
   \                     iSDO12:
   \   00000016                      DS8 2
   \                     TestSDO12:
   \   00000018                      DS8 8192

   \                                 In section .bss, align 4
   \                     I2S2_stPosShft:
   \   00000000                      DS8 1
   \   00000001                      DS8 1
   \                     I2S2_stNipple:
   \   00000002                      DS8 2
   \                     iSDO34:
   \   00000004                      DS8 2
   \   00000006                      DS8 2
   \                     TestSDO34:
   \   00000008                      DS8 8192

   \                                 In section .bss, align 4
   \                     TestSDO56:
   \   00000000                      DS8 8192

   \                                 In section .bss, align 4
   \                     TestSDO7:
   \   00000000                      DS8 8192

   \                                 In section .bss, align 4
   \                     TestSDO8:
   \   00000000                      DS8 8192

   \                                 In section .bss, align 4
   \                     TestSDO7_1:
   \   00000000                      DS8 8192

   \                                 In section .bss, align 4
   \                     WaveRecord_flgSDO8Finish:
   \   00000000                      DS8 1
   \   00000001                      DS8 3
   \                     TestSDO8_1:
   \   00000004                      DS8 8192

   \                                 In section .bss, align 4
   \                     hspi1:
   \   00000000                      DS8 100

   \                                 In section .bss, align 4
   \                     hspi2:
   \   00000000                      DS8 100

   \                                 In section .bss, align 4
   \                     spi1_ins:
   \   00000000                      DS8 100

   \                                 In section .bss, align 4
   \                     spi2_ins:
   \   00000000                      DS8 100

   \                                 In section .bss, align 4
   \                     hdma_spi2_tx:
   \   00000000                      DS8 80

   \                                 In section .bss, align 4
   \                     hdma_spi3_tx:
   \   00000000                      DS8 80

   \                                 In section .bss, align 4
   \                     hdma_spi5_rx:
   \   00000000                      DS8 80
   \                     hdma_spi6_rx:
   \   00000050                      DS8 80

   \                                 In section .bss, align 1
   \                     WaveRecord_flgIni:
   \   00000000                      DS8 1

   \                                 In section .bss, align 2
   \                     iSDO56:
   \   00000000                      DS8 2

   \                                 In section .bss, at 0xc0000000
   \                     Buffer1:
   \   00000000                      DS8 32928

   \                                 In section .bss, at 0xc00080a0
   \                     Buffer2:
   \   00000000                      DS8 32928

   \                                 In section .bss, at 0xc0010140
   \                     Buffer3:
   \   00000000                      DS8 32928

   \                                 In section .bss, align 1
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
   \   00000000                      DS8 1
    665          
    666          
    667          
    668          

   \                                 In section .text, align 2, keep-with-next
    669          void SPI5_IRQHandler(void)
    670          {
   \                     SPI5_IRQHandler: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    671            //static uint16_t stNipple;
    672            //static uint8_t stLR, stOder;
    673          
    674            /* USER CODE BEGIN SPI5_IRQn 0 */
    675          
    676            /* USER CODE END SPI5_IRQn 0 */
    677            //HAL_SPI_IRQHandler(&hspi5);
    678            /* USER CODE BEGIN SPI5_IRQn 1 */
    679          
    680            /* USER CODE END SPI5_IRQn 1 */
    681              /* Check if data are available in SPI Data register */
    682            /* SPI in mode Receiver ----------------------------------------------------*/
    683            if(
    684               (__HAL_SPI_GET_FLAG(&hspi5, SPI_FLAG_OVR) == RESET)&&
    685               (__HAL_SPI_GET_FLAG(&hspi5, SPI_FLAG_RXNE) != RESET)&&
    686               (__HAL_SPI_GET_IT_SOURCE(&hspi5, SPI_IT_RXNE) != RESET))
   \   00000002   0x.... 0x....      LDR.W    R4,??DataTable15_2
   \   00000006   0x6820             LDR      R0,[R4, #+0]
   \   00000008   0x6881             LDR      R1,[R0, #+8]
   \   0000000A   0x0649             LSLS     R1,R1,#+25
   \   0000000C   0xD43C             BMI.N    ??SPI5_IRQHandler_0
   \   0000000E   0x6881             LDR      R1,[R0, #+8]
   \   00000010   0x07C9             LSLS     R1,R1,#+31
   \   00000012   0xD539             BPL.N    ??SPI5_IRQHandler_0
   \   00000014   0x6840             LDR      R0,[R0, #+4]
   \   00000016   0x0640             LSLS     R0,R0,#+25
   \   00000018   0xD536             BPL.N    ??SPI5_IRQHandler_0
    687            {
    688          
    689          
    690             uint16_t test;
    691             test =  SPI_I2S_ReceiveData(SPI5);
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable16_1  ;; 0x4001500c
    692             SPI5->DR = 3333;
   \   0000001E   0xF640 0x5205      MOVW     R2,#+3333
   \   00000022   0x6801             LDR      R1,[R0, #+0]
   \   00000024   0x6002             STR      R2,[R0, #+0]
    693          
    694            pDataMic8[idxMic8++] =	HTONS(test);
   \   00000026   0xF8B4 0x01B4      LDRH     R0,[R4, #+436]
   \   0000002A   0xB28A             UXTH     R2,R1
   \   0000002C   0x0209             LSLS     R1,R1,#+8
   \   0000002E   0xEA41 0x2112      ORR      R1,R1,R2, LSR #+8
   \   00000032   0xEB04 0x0240      ADD      R2,R4,R0, LSL #+1
   \   00000036   0x1C40             ADDS     R0,R0,#+1
   \   00000038   0xF8A2 0x11C8      STRH     R1,[R2, #+456]
   \   0000003C   0xF8A4 0x01B4      STRH     R0,[R4, #+436]
    695            
    696            //volume = 64;
    697            
    698            if (idxMic8>=64)
   \   00000040   0xB280             UXTH     R0,R0
   \   00000042   0x2840             CMP      R0,#+64
   \   00000044   0xDB20             BLT.N    ??SPI5_IRQHandler_0
    699            {
    700          	if (buffer_switch != 1)
   \   00000046   0x.... 0x....      LDR.W    R2,??DataTable15_6
   \   0000004A   0xF8D4 0x01C4      LDR      R0,[R4, #+452]
   \   0000004E   0x.... 0x....      LDR.W    R1,??DataTable17
   \   00000052   0xF504 0x73A4      ADD      R3,R4,#+328
   \   00000056   0x7812             LDRB     R2,[R2, #+0]
   \   00000058   0x780A             LDRB     R2,[R1, #+0]
   \   0000005A   0xF8B4 0x11BA      LDRH     R1,[R4, #+442]
   \   0000005E   0xEB00 0x1141      ADD      R1,R0,R1, LSL #+5
   \   00000062   0xF504 0x70E4      ADD      R0,R4,#+456
    701          	{
    702          		PDM_Filter_64_LSB((uint8_t *)pDataMic8,(uint16_t *)(bufPCMSens8 + cntPos*16), volume ,
                 		^
Warning[Pa082]: undefined behavior: the order of volatile accesses is
          undefined in this statement
    703          						  (PDMFilter_InitStruct *)&Filter[0]);
    704          	}
    705          	else
    706          	{
    707          		PDM_Filter_64_LSB((uint8_t *)pDataMic8,(uint16_t *)(bufPCMSens8 + cntPos*16), volume , 
                 		^
Warning[Pa082]: undefined behavior: the order of volatile accesses is
          undefined in this statement
    708          						  (PDMFilter_InitStruct *)&Filter[0]);   
   \   00000066   0x.... 0x....      BL       PDM_Filter_64_LSB
    709          	}
    710          	idxMic8=0;
   \   0000006A   0x2000             MOVS     R0,#+0
   \   0000006C   0xF8A4 0x01B4      STRH     R0,[R4, #+436]
    711          	cntPos++;
   \   00000070   0xF8B4 0x01BA      LDRH     R0,[R4, #+442]
   \   00000074   0x1C40             ADDS     R0,R0,#+1
   \   00000076   0xF8A4 0x01BA      STRH     R0,[R4, #+442]
    712          	if (cntPos>=256) cntPos=0;
   \   0000007A   0xF8B4 0x01BA      LDRH     R0,[R4, #+442]
   \   0000007E   0x28FF             CMP      R0,#+255
   \   00000080   0xBFC4             ITT      GT 
   \   00000082   0x2000             MOVGT    R0,#+0
   \   00000084   0xF8A4 0x01BA      STRHGT   R0,[R4, #+442]
    713            }
    714              
    715            }
    716            
    717          }
   \                     ??SPI5_IRQHandler_0: (+1)
   \   00000088   0xBD10             POP      {R4,PC}          ;; return
    718          
    719          /* SPI5 init function */
    720          
    721          

   \                                 In section .text, align 2, keep-with-next
    722          void SPI6_IRQHandler(void)
    723          {
   \                     SPI6_IRQHandler: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    724            /* SPI in mode Receiver ----------------------------------------------------*/
    725            if(
    726          //     (__HAL_SPI_GET_FLAG(&hspi6, SPI_FLAG_OVR) == RESET)&&
    727               (__HAL_SPI_GET_FLAG(&hspi6, SPI_FLAG_TXE) != RESET)&&
    728               (__HAL_SPI_GET_IT_SOURCE(&hspi6, SPI_IT_TXE) != RESET))
   \   00000002   0x.... 0x....      LDR.W    R4,??DataTable15_2
   \   00000006   0x6E60             LDR      R0,[R4, #+100]
   \   00000008   0x6881             LDR      R1,[R0, #+8]
   \   0000000A   0x0789             LSLS     R1,R1,#+30
   \   0000000C   0xD539             BPL.N    ??SPI6_IRQHandler_0
   \   0000000E   0x6840             LDR      R0,[R0, #+4]
   \   00000010   0x0600             LSLS     R0,R0,#+24
   \   00000012   0xD536             BPL.N    ??SPI6_IRQHandler_0
    729            {
    730          
    731          
    732               uint16_t test;
    733               test =  SPI_I2S_ReceiveData(SPI6);
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable16_2  ;; 0x4001540c
    734               SPI6->DR = 3333;
   \   00000018   0xF640 0x5205      MOVW     R2,#+3333
   \   0000001C   0x6801             LDR      R1,[R0, #+0]
   \   0000001E   0x6002             STR      R2,[R0, #+0]
    735          
    736              pDataMic7[idxMic7++] =	HTONS(test);
   \   00000020   0xF8B4 0x01B6      LDRH     R0,[R4, #+438]
   \   00000024   0xB28A             UXTH     R2,R1
   \   00000026   0x0209             LSLS     R1,R1,#+8
   \   00000028   0xEA41 0x2112      ORR      R1,R1,R2, LSR #+8
   \   0000002C   0xEB04 0x0240      ADD      R2,R4,R0, LSL #+1
   \   00000030   0x1C40             ADDS     R0,R0,#+1
   \   00000032   0xF8A2 0x1248      STRH     R1,[R2, #+584]
   \   00000036   0xF8A4 0x01B6      STRH     R0,[R4, #+438]
    737          
    738              //volume = 64;
    739          
    740              if (idxMic7>=64)
   \   0000003A   0xB280             UXTH     R0,R0
   \   0000003C   0x2840             CMP      R0,#+64
   \   0000003E   0xDB20             BLT.N    ??SPI6_IRQHandler_0
    741              {
    742                if (buffer_switch != 1)
   \   00000040   0x.... 0x....      LDR.W    R2,??DataTable15_6
   \   00000044   0xF8D4 0x01C0      LDR      R0,[R4, #+448]
   \   00000048   0x.... 0x....      LDR.W    R1,??DataTable17
   \   0000004C   0xF504 0x73BE      ADD      R3,R4,#+380
   \   00000050   0x7812             LDRB     R2,[R2, #+0]
   \   00000052   0x780A             LDRB     R2,[R1, #+0]
   \   00000054   0xF8B4 0x11BC      LDRH     R1,[R4, #+444]
   \   00000058   0xEB00 0x1141      ADD      R1,R0,R1, LSL #+5
   \   0000005C   0xF504 0x7012      ADD      R0,R4,#+584
    743                {
    744                        PDM_Filter_64_LSB((uint8_t *)pDataMic7,(uint16_t *)(bufPCMSens7 + cntPos7*16), volume ,
                               ^
Warning[Pa082]: undefined behavior: the order of volatile accesses is
          undefined in this statement
    745                                                          (PDMFilter_InitStruct *)&Filter[1]);
    746                }
    747                else
    748                {
    749                        PDM_Filter_64_LSB((uint8_t *)pDataMic7,(uint16_t *)(bufPCMSens7 + cntPos7*16), volume , 
                               ^
Warning[Pa082]: undefined behavior: the order of volatile accesses is
          undefined in this statement
    750                                                          (PDMFilter_InitStruct *)&Filter[1]);   
   \   00000060   0x.... 0x....      BL       PDM_Filter_64_LSB
    751                }
    752                idxMic7=0;
   \   00000064   0x2000             MOVS     R0,#+0
   \   00000066   0xF8A4 0x01B6      STRH     R0,[R4, #+438]
    753                cntPos7++;
   \   0000006A   0xF8B4 0x01BC      LDRH     R0,[R4, #+444]
   \   0000006E   0x1C40             ADDS     R0,R0,#+1
   \   00000070   0xF8A4 0x01BC      STRH     R0,[R4, #+444]
    754                if (cntPos7>=256) cntPos7=0;
   \   00000074   0xF8B4 0x01BC      LDRH     R0,[R4, #+444]
   \   00000078   0x28FF             CMP      R0,#+255
   \   0000007A   0xBFC4             ITT      GT 
   \   0000007C   0x2000             MOVGT    R0,#+0
   \   0000007E   0xF8A4 0x01BC      STRHGT   R0,[R4, #+444]
    755              }
    756              
    757            }
    758          }
   \                     ??SPI6_IRQHandler_0: (+1)
   \   00000082   0xBD10             POP      {R4,PC}          ;; return
    759          
    760          
    761          

   \                                 In section .text, align 2, keep-with-next
    762          void MIC1TO6_Init(void)
    763          {
   \                     MIC1TO6_Init: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x.... 0x....      LDR.W    R4,??DataTable12_1  ;; 0x40020000
    764            while(HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_4)==GPIO_PIN_SET);
   \                     ??MIC1TO6_Init_0: (+1)
   \   00000006   0x2110             MOVS     R1,#+16
   \   00000008   0x4620             MOV      R0,R4
   \   0000000A   0x.... 0x....      BL       HAL_GPIO_ReadPin
   \   0000000E   0x2801             CMP      R0,#+1
   \   00000010   0xD0F9             BEQ.N    ??MIC1TO6_Init_0
    765            while(HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_4)==GPIO_PIN_RESET);
   \                     ??MIC1TO6_Init_1: (+1)
   \   00000012   0x2110             MOVS     R1,#+16
   \   00000014   0x4620             MOV      R0,R4
   \   00000016   0x.... 0x....      BL       HAL_GPIO_ReadPin
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD0F9             BEQ.N    ??MIC1TO6_Init_1
    766            I2S1_Init(); /* I2S1   --> SDO12 */
   \   0000001E   0x.... 0x....      LDR.W    R5,??DataTable15_2
   \   00000022   0x.... 0x....      LDR.W    R0,??DataTable16_3  ;; 0x40013000
   \   00000026   0xF8C5 0x00C8      STR      R0,[R5, #+200]
   \   0000002A   0x2010             MOVS     R0,#+16
   \   0000002C   0xF8C5 0x00D0      STR      R0,[R5, #+208]
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0xF8C5 0x00D4      STR      R0,[R5, #+212]
   \   00000036   0xF44F 0x7000      MOV      R0,#+512
   \   0000003A   0xF8C5 0x00D8      STR      R0,[R5, #+216]
   \   0000003E   0xF64B 0x3080      MOVW     R0,#+48000
   \   00000042   0xF8C5 0x00DC      STR      R0,[R5, #+220]
   \   00000046   0x2000             MOVS     R0,#+0
   \   00000048   0xF8C5 0x00E0      STR      R0,[R5, #+224]
   \   0000004C   0x2002             MOVS     R0,#+2
   \   0000004E   0xF44F 0x7680      MOV      R6,#+256
   \   00000052   0xF8C5 0x00E4      STR      R0,[R5, #+228]
   \   00000056   0xF8C5 0x60CC      STR      R6,[R5, #+204]
   \   0000005A   0xF105 0x00C8      ADD      R0,R5,#+200
   \   0000005E   0x.... 0x....      BL       HAL_I2S_Init
   \   00000062   0xF8D5 0x00C8      LDR      R0,[R5, #+200]
   \   00000066   0x6841             LDR      R1,[R0, #+4]
   \   00000068   0xF041 0x0140      ORR      R1,R1,#0x40
   \   0000006C   0x6041             STR      R1,[R0, #+4]
   \   0000006E   0x69C1             LDR      R1,[R0, #+28]
   \   00000070   0xF441 0x6180      ORR      R1,R1,#0x400
   \   00000074   0x61C1             STR      R1,[R0, #+28]
    767            while(HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_4)==GPIO_PIN_SET);
   \                     ??MIC1TO6_Init_2: (+1)
   \   00000076   0x2110             MOVS     R1,#+16
   \   00000078   0x4620             MOV      R0,R4
   \   0000007A   0x.... 0x....      BL       HAL_GPIO_ReadPin
   \   0000007E   0x2801             CMP      R0,#+1
   \   00000080   0xD0F9             BEQ.N    ??MIC1TO6_Init_2
    768            while(HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_4)==GPIO_PIN_RESET);
   \                     ??MIC1TO6_Init_3: (+1)
   \   00000082   0x2110             MOVS     R1,#+16
   \   00000084   0x4620             MOV      R0,R4
   \   00000086   0x.... 0x....      BL       HAL_GPIO_ReadPin
   \   0000008A   0x2800             CMP      R0,#+0
   \   0000008C   0xD0F9             BEQ.N    ??MIC1TO6_Init_3
    769            I2S2_Init(); /* I2S2   --> SDO34 */
   \   0000008E   0x.... 0x....      LDR.W    R0,??DataTable17_1  ;; 0x40003800
   \   00000092   0xF8C5 0x610C      STR      R6,[R5, #+268]
   \   00000096   0xF8C5 0x0108      STR      R0,[R5, #+264]
   \   0000009A   0x2020             MOVS     R0,#+32
   \   0000009C   0xF8C5 0x0110      STR      R0,[R5, #+272]
   \   000000A0   0x2000             MOVS     R0,#+0
   \   000000A2   0xF8C5 0x0114      STR      R0,[R5, #+276]
   \   000000A6   0xF8C5 0x0118      STR      R0,[R5, #+280]
   \   000000AA   0xF44F 0x507A      MOV      R0,#+16000
   \   000000AE   0xF8C5 0x011C      STR      R0,[R5, #+284]
   \   000000B2   0x2000             MOVS     R0,#+0
   \   000000B4   0xF8C5 0x0120      STR      R0,[R5, #+288]
   \   000000B8   0x2001             MOVS     R0,#+1
   \   000000BA   0xF8C5 0x0124      STR      R0,[R5, #+292]
   \   000000BE   0xF505 0x7084      ADD      R0,R5,#+264
   \   000000C2   0x.... 0x....      BL       HAL_I2S_Init
   \   000000C6   0xF8D5 0x0108      LDR      R0,[R5, #+264]
   \   000000CA   0x6841             LDR      R1,[R0, #+4]
   \   000000CC   0xF041 0x0140      ORR      R1,R1,#0x40
   \   000000D0   0x6041             STR      R1,[R0, #+4]
   \   000000D2   0x69C1             LDR      R1,[R0, #+28]
   \   000000D4   0xF441 0x6180      ORR      R1,R1,#0x400
   \   000000D8   0x61C1             STR      R1,[R0, #+28]
    770            while(HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_4)==GPIO_PIN_SET);
   \                     ??MIC1TO6_Init_4: (+1)
   \   000000DA   0x2110             MOVS     R1,#+16
   \   000000DC   0x4620             MOV      R0,R4
   \   000000DE   0x.... 0x....      BL       HAL_GPIO_ReadPin
   \   000000E2   0x2801             CMP      R0,#+1
   \   000000E4   0xD0F9             BEQ.N    ??MIC1TO6_Init_4
    771            while(HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_4)==GPIO_PIN_RESET);
   \                     ??MIC1TO6_Init_5: (+1)
   \   000000E6   0x2110             MOVS     R1,#+16
   \   000000E8   0x4620             MOV      R0,R4
   \   000000EA   0x.... 0x....      BL       HAL_GPIO_ReadPin
   \   000000EE   0x2800             CMP      R0,#+0
   \   000000F0   0xD0F9             BEQ.N    ??MIC1TO6_Init_5
    772            SPI4_Init(); /* SPI4   --> SDO56 */
   \   000000F2   0x.... 0x....      BL       SPI4_Init
    773          
    774            SPI5_Init();
   \   000000F6   0x.... 0x....      BL       SPI5_Init
    775            SPI6_Init();
   \   000000FA   0x.... 0x....      BL       SPI6_Init
    776          
    777            HAL_SPI_Receive_DMA(&hspi5,( uint8_t *)TestSDO7,4*AUDIO_OUT_BUFFER_SIZE);
   \   000000FE   0xF44F 0x5280      MOV      R2,#+4096
   \   00000102   0x.... 0x....      LDR.W    R1,??DataTable17_2
   \   00000106   0x4628             MOV      R0,R5
   \   00000108   0x.... 0x....      BL       HAL_SPI_Receive_DMA
    778          #if (USB_STREAMING)
    779            HAL_SPI_Receive_DMA(&hspi6,( uint8_t *)TestSDO8,4*(AUDIO_SAMPLING_FREQUENCY/1000));
   \   0000010C   0x2240             MOVS     R2,#+64
   \   0000010E   0x.... 0x....      LDR.W    R1,??DataTable17_3
   \   00000112   0xF105 0x0064      ADD      R0,R5,#+100
   \   00000116   0x.... 0x....      BL       HAL_SPI_Receive_DMA
    780          #else
    781            HAL_SPI_Receive_DMA(&hspi6,( uint8_t *)TestSDO8,4*AUDIO_OUT_BUFFER_SIZE);
    782          #endif
    783            swtSDO7 = 0;
   \   0000011A   0x2000             MOVS     R0,#+0
   \   0000011C   0xF885 0x01B0      STRB     R0,[R5, #+432]
    784            swtSDO8 = 0;
   \   00000120   0xF885 0x01B1      STRB     R0,[R5, #+433]
    785          }
   \   00000124   0xBD70             POP      {R4-R6,PC}       ;; return
    786          
    787          
    788          
    789          /* I2S1 init function */
    790          /* Read data of MIC12 */
    791          static void I2S1_Init(void)
    792          {
    793          #if 1
    794            hi2s1.Instance = SPI1;
    795            hi2s1.Init.Mode = I2S_MODE_SLAVE_RX;
    796            hi2s1.Init.Standard = I2S_STANDARD_MSB;
    797            hi2s1.Init.DataFormat = I2S_DATAFORMAT_16B;
    798            hi2s1.Init.MCLKOutput = I2S_MCLKOUTPUT_ENABLE;
    799            hi2s1.Init.AudioFreq = I2S_AUDIOFREQ_48K;
    800            hi2s1.Init.CPOL = I2S_CPOL_LOW;
    801            hi2s1.Init.ClockSource = I2S_CLOCK_SYSCLK;
    802            HAL_I2S_Init(&hi2s1);
    803          
    804               /* Enable TXE and ERR interrupt */
    805           __HAL_I2S_ENABLE_IT(&hi2s1, (I2S_IT_RXNE));
    806           
    807           __HAL_I2S_ENABLE(&hi2s1);
    808          #else
    809          	hspi1.Instance = SPI1;
    810          	hspi1.Init.Mode = SPI_MODE_SLAVE;
    811          	hspi1.Init.Direction = SPI_DIRECTION_2LINES;//SPI_DIRECTION_2LINES_RXONLY
    812          	hspi1.Init.DataSize = SPI_DATASIZE_16BIT;
    813          	hspi1.Init.CLKPolarity = SPI_POLARITY_HIGH;
    814          	hspi1.Init.CLKPhase = SPI_PHASE_1EDGE;
    815          	hspi1.Init.NSS = SPI_NSS_SOFT;//SPI_NSS_HARD_INPUT
    816          	hspi1.Init.FirstBit = SPI_FIRSTBIT_MSB;
    817          	hspi1.Init.TIMode = SPI_TIMODE_DISABLE;
    818          	hspi1.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLED;
    819          	hspi1.Init.CRCPolynomial = 7;
    820          	hspi1.Init.CRCLength = SPI_CRC_LENGTH_DATASIZE;
    821          	hspi1.Init.NSSPMode = SPI_NSS_PULSE_DISABLE;
    822          	//hspi4.RxISR = SPI5_CallBack;
    823          	HAL_SPI_Init(&hspi1);
    824          
    825          	  //HAL_GPIO_WritePin(GPIOF,GPIO_PIN_6,GPIO_PIN_SET);
    826            /* Enable TXE, RXNE and ERR interrupt */
    827           __HAL_SPI_ENABLE_IT(&hspi1, (SPI_IT_RXNE| SPI_IT_ERR));
    828          
    829           __HAL_SPI_ENABLE(&hspi1);
    830          
    831          #endif
    832          }
    833          
    834          /* I2S2 init function */
    835          /* Read data of MIC34 */
    836          
    837          static void I2S2_Init(void)
    838          {
    839          
    840          #if 1
    841           //HAL_I2S_DeInit(&hi2s2);
    842           hi2s2.Instance = SPI2;
    843           hi2s2.Init.Mode = I2S_MODE_SLAVE_RX;//I2S_MODE_MASTER_RX
    844           hi2s2.Init.Standard = I2S_STANDARD_LSB;//I2S_STANDARD_LSB
    845           hi2s2.Init.DataFormat = I2S_DATAFORMAT_16B;
    846           hi2s2.Init.MCLKOutput = I2S_MCLKOUTPUT_DISABLE;
    847           hi2s2.Init.AudioFreq = I2S_AUDIOFREQ_16K;
    848           hi2s2.Init.CPOL = I2S_CPOL_LOW;
    849           hi2s2.Init.ClockSource = I2S_CLOCK_EXTERNAL;
    850          
    851           HAL_I2S_Init(&hi2s2);
    852            /* Enable TXE and ERR interrupt */
    853          __HAL_I2S_ENABLE_IT(&hi2s2, (I2S_IT_RXNE));
    854          __HAL_I2S_ENABLE(&hi2s2);
    855          
    856          #else
    857             hspi2.Instance = SPI2;
    858             hspi2.Init.Mode = SPI_MODE_SLAVE;
    859             hspi2.Init.Direction = SPI_DIRECTION_2LINES;//SPI_DIRECTION_2LINES_RXONLY
    860             hspi2.Init.DataSize = SPI_DATASIZE_16BIT;
    861             hspi2.Init.CLKPolarity = SPI_POLARITY_HIGH;
    862             hspi2.Init.CLKPhase = SPI_PHASE_1EDGE;
    863             hspi2.Init.NSS = SPI_NSS_SOFT;//SPI_NSS_HARD_INPUT
    864             hspi2.Init.FirstBit = SPI_FIRSTBIT_MSB;
    865             hspi2.Init.TIMode = SPI_TIMODE_DISABLE;
    866             hspi2.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLED;
    867             hspi2.Init.CRCPolynomial = 7;
    868             hspi2.Init.CRCLength = SPI_CRC_LENGTH_DATASIZE;
    869             hspi2.Init.NSSPMode = SPI_NSS_PULSE_DISABLE;
    870             HAL_SPI_Init(&hspi2);
    871          
    872          	 //HAL_GPIO_WritePin(GPIOF,GPIO_PIN_6,GPIO_PIN_SET);
    873           /* Enable TXE, RXNE and ERR interrupt */
    874          __HAL_SPI_ENABLE_IT(&hspi2, (SPI_IT_RXNE| SPI_IT_ERR));
    875          
    876          __HAL_SPI_ENABLE(&hspi2);
    877          
    878          #endif
    879          
    880          
    881          }
    882          
    883          /* SPI5 init function */

   \                                 In section .text, align 2, keep-with-next
    884          void SPI4_Init(void)
    885          {
   \                     SPI4_Init: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    886          
    887            hspi4.Instance = SPI4;
   \   00000002   0x.... 0x....      LDR.W    R4,??DataTable15_13
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable17_4  ;; 0x40013400
   \   0000000A   0x6020             STR      R0,[R4, #+0]
    888            hspi4.Init.Mode = SPI_MODE_SLAVE;
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x6060             STR      R0,[R4, #+4]
    889            hspi4.Init.Direction = SPI_DIRECTION_2LINES;//SPI_DIRECTION_2LINES_RXONLY
   \   00000010   0x60A0             STR      R0,[R4, #+8]
    890            hspi4.Init.DataSize = SPI_DATASIZE_16BIT;
   \   00000012   0xF44F 0x6070      MOV      R0,#+3840
   \   00000016   0x60E0             STR      R0,[R4, #+12]
    891            hspi4.Init.CLKPolarity = SPI_POLARITY_HIGH;
   \   00000018   0x2002             MOVS     R0,#+2
   \   0000001A   0x6120             STR      R0,[R4, #+16]
    892            hspi4.Init.CLKPhase = SPI_PHASE_1EDGE;
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0x6160             STR      R0,[R4, #+20]
    893            hspi4.Init.NSS = SPI_NSS_SOFT;//SPI_NSS_HARD_INPUT
   \   00000020   0xF44F 0x7000      MOV      R0,#+512
   \   00000024   0x61A0             STR      R0,[R4, #+24]
    894            hspi4.Init.FirstBit = SPI_FIRSTBIT_MSB;
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0x6220             STR      R0,[R4, #+32]
    895            hspi4.Init.TIMode = SPI_TIMODE_DISABLE;
   \   0000002A   0x6260             STR      R0,[R4, #+36]
    896            hspi4.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLED;
   \   0000002C   0x62A0             STR      R0,[R4, #+40]
    897            hspi4.Init.CRCPolynomial = 7;
   \   0000002E   0x2007             MOVS     R0,#+7
   \   00000030   0x62E0             STR      R0,[R4, #+44]
    898            hspi4.Init.CRCLength = SPI_CRC_LENGTH_DATASIZE;
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0x6320             STR      R0,[R4, #+48]
    899            hspi4.Init.NSSPMode = SPI_NSS_PULSE_DISABLE;
   \   00000036   0x6360             STR      R0,[R4, #+52]
    900            HAL_SPI_Init(&hspi4);
   \   00000038   0x4620             MOV      R0,R4
   \   0000003A   0x.... 0x....      BL       HAL_SPI_Init
    901          
    902            /* Enable TXE, RXNE and ERR interrupt */
    903           __HAL_SPI_ENABLE_IT(&hspi4, (SPI_IT_RXNE| SPI_IT_ERR));
   \   0000003E   0x6820             LDR      R0,[R4, #+0]
   \   00000040   0x6841             LDR      R1,[R0, #+4]
   \   00000042   0xF041 0x0160      ORR      R1,R1,#0x60
   \   00000046   0x6041             STR      R1,[R0, #+4]
    904          
    905           __HAL_SPI_ENABLE(&hspi4);
   \   00000048   0x6801             LDR      R1,[R0, #+0]
   \   0000004A   0xF041 0x0140      ORR      R1,R1,#0x40
   \   0000004E   0x6001             STR      R1,[R0, #+0]
    906          }
   \   00000050   0xBD10             POP      {R4,PC}          ;; return
    907          
    908          

   \                                 In section .text, align 2, keep-with-next
    909          void Mic7Rec(void)
    910          {
    911              SPI5_Init();
   \                     Mic7Rec: (+1)
   \   00000000   0x....             B.N      SPI5_Init
    912          }
    913          

   \                                 In section .text, align 2, keep-with-next
    914          void Mic8Rec(void)
    915          {
    916              SPI6_Init();
   \                     Mic8Rec: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable15_2
   \   00000004   0x.... 0x....      LDR.W    R1,??DataTable17_5  ;; 0x40015400
   \   00000008   0x6641             STR      R1,[R0, #+100]
   \   0000000A   0x2100             MOVS     R1,#+0
   \   0000000C   0x6681             STR      R1,[R0, #+104]
   \   0000000E   0xF44F 0x6180      MOV      R1,#+1024
   \   00000012   0x66C1             STR      R1,[R0, #+108]
   \   00000014   0xF44F 0x6170      MOV      R1,#+3840
   \   00000018   0x6701             STR      R1,[R0, #+112]
   \   0000001A   0x2100             MOVS     R1,#+0
   \   0000001C   0x6741             STR      R1,[R0, #+116]
   \   0000001E   0x6781             STR      R1,[R0, #+120]
   \   00000020   0xF44F 0x7100      MOV      R1,#+512
   \   00000024   0x67C1             STR      R1,[R0, #+124]
   \   00000026   0x2100             MOVS     R1,#+0
   \   00000028   0xF8C0 0x1084      STR      R1,[R0, #+132]
   \   0000002C   0xF8C0 0x1088      STR      R1,[R0, #+136]
   \   00000030   0xF8C0 0x108C      STR      R1,[R0, #+140]
   \   00000034   0x2107             MOVS     R1,#+7
   \   00000036   0xF8C0 0x1090      STR      R1,[R0, #+144]
   \   0000003A   0x2100             MOVS     R1,#+0
   \   0000003C   0xF8C0 0x1094      STR      R1,[R0, #+148]
   \   00000040   0xF8C0 0x1098      STR      R1,[R0, #+152]
   \   00000044   0x3064             ADDS     R0,R0,#+100
   \   00000046   0x.... 0x....      B.W      HAL_SPI_Init
    917          }
    918          
    919          
    920          /* SPI5 init function */

   \                                 In section .text, align 4, keep-with-next
    921          void SPI5_Init(void)
    922          {
   \                     SPI5_Init: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB081             SUB      SP,SP,#+4
    923          	
    924              /* Enable CRC module */
    925              RCC->AHB1ENR |= RCC_AHB1ENR_CRCEN;
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable12  ;; 0x40023830
    926          	for (char i=0; i< 2; i++)
   \   00000008   0x.... 0x....      LDR.W    R4,??DataTable15_2
   \   0000000C   0x2602             MOVS     R6,#+2
   \   0000000E   0xED2D 0x8B02      VPUSH    {D8}
   \   00000012   0x6801             LDR      R1,[R0, #+0]
   \   00000014   0xF504 0x75A4      ADD      R5,R4,#+328
   \   00000018   0xF44F 0x577A      MOV      R7,#+16000
   \   0000001C   0xEEB2 0x8A04      VMOV.F32 S16,#10.0
   \   00000020   0xF441 0x5180      ORR      R1,R1,#0x1000
   \   00000024   0xEDDF 0x....      VLDR.W   S17,??DataTable11  ;; 0x45fa0000
   \   00000028   0xF8C0 0x1000      STR.W    R1,[R0, #+0]
    927          	{
    928          		/* Filter LP & HP Init */
    929          		Filter[i].LP_HZ = 8000;   //sop1hc 8000
   \                     ??SPI5_Init_0: (+1)
   \   0000002C   0xEDC5 0x8A01      VSTR     S17,[R5, #+4]
    930          		Filter[i].HP_HZ = 10;
    931          		Filter[i].Fs = 16000;    //sop1hc: 16000
    932          		Filter[i].Out_MicChannels = 1;
   \   00000030   0x2001             MOVS     R0,#+1
   \   00000032   0xED85 0x8A02      VSTR     S16,[R5, #+8]
   \   00000036   0x802F             STRH     R7,[R5, #+0]
   \   00000038   0x81E8             STRH     R0,[R5, #+14]
    933          		Filter[i].In_MicChannels = 1;
   \   0000003A   0x81A8             STRH     R0,[R5, #+12]
    934          		PDM_Filter_Init((PDMFilter_InitStruct *)&Filter[i]);
   \   0000003C   0x4628             MOV      R0,R5
   \   0000003E   0x.... 0x....      BL       PDM_Filter_Init
    935          	}
   \   00000042   0x3534             ADDS     R5,R5,#+52
   \   00000044   0x1E76             SUBS     R6,R6,#+1
   \   00000046   0xD1F1             BNE.N    ??SPI5_Init_0
    936          
    937          
    938            hspi5.Instance = SPI5;
   \   00000048   0x.... 0x....      LDR.W    R0,??DataTable17_6  ;; 0x40015000
   \   0000004C   0x6020             STR      R0,[R4, #+0]
    939            hspi5.Init.Mode = SPI_MODE_SLAVE;
   \   0000004E   0x2000             MOVS     R0,#+0
   \   00000050   0x6060             STR      R0,[R4, #+4]
    940            hspi5.Init.Direction = SPI_DIRECTION_2LINES_RXONLY;//SPI_DIRECTION_2LINES_RXONLY
   \   00000052   0xF44F 0x6080      MOV      R0,#+1024
   \   00000056   0x60A0             STR      R0,[R4, #+8]
    941            hspi5.Init.DataSize = SPI_DATASIZE_16BIT;
   \   00000058   0xF44F 0x6070      MOV      R0,#+3840
   \   0000005C   0x60E0             STR      R0,[R4, #+12]
    942            hspi5.Init.CLKPolarity = SPI_POLARITY_LOW;
   \   0000005E   0x2000             MOVS     R0,#+0
   \   00000060   0x6120             STR      R0,[R4, #+16]
    943            hspi5.Init.CLKPhase = SPI_PHASE_1EDGE;
   \   00000062   0x6160             STR      R0,[R4, #+20]
    944            hspi5.Init.NSS = SPI_NSS_SOFT;//SPI_NSS_HARD_INPUT
   \   00000064   0xF44F 0x7000      MOV      R0,#+512
   \   00000068   0x61A0             STR      R0,[R4, #+24]
    945            hspi5.Init.FirstBit = SPI_FIRSTBIT_MSB;
   \   0000006A   0x2000             MOVS     R0,#+0
   \   0000006C   0x6220             STR      R0,[R4, #+32]
    946            hspi5.Init.TIMode = SPI_TIMODE_DISABLE;
   \   0000006E   0x6260             STR      R0,[R4, #+36]
    947            hspi5.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLED;
   \   00000070   0x62A0             STR      R0,[R4, #+40]
    948            hspi5.Init.CRCPolynomial = 7;
   \   00000072   0x2007             MOVS     R0,#+7
   \   00000074   0x62E0             STR      R0,[R4, #+44]
    949            hspi5.Init.CRCLength = SPI_CRC_LENGTH_DATASIZE;
   \   00000076   0x2000             MOVS     R0,#+0
   \   00000078   0x6320             STR      R0,[R4, #+48]
    950            hspi5.Init.NSSPMode = SPI_NSS_PULSE_DISABLE;
   \   0000007A   0x6360             STR      R0,[R4, #+52]
    951            //hspi5.RxISR = SPI5_CallBack;
    952            HAL_SPI_Init(&hspi5);
   \   0000007C   0x4620             MOV      R0,R4
   \   0000007E   0xECBD 0x8B02      VPOP     {D8}
   \   00000082   0xB001             ADD      SP,SP,#+4
   \   00000084   0xE8BD 0x40F0      POP      {R4-R7,LR}
   \   00000088   0x.... 0x....      B.W      HAL_SPI_Init
    953          
    954          
    955            //HAL_GPIO_WritePin(GPIOF,GPIO_PIN_6,GPIO_PIN_SET);
    956            /* Enable TXE, RXNE and ERR interrupt */
    957           //__HAL_SPI_ENABLE_IT(&hspi5, (SPI_IT_RXNE| SPI_IT_ERR));
    958          
    959           //__HAL_SPI_ENABLE(&hspi5);
    960          
    961          }
    962          

   \                                 In section .text, align 2, keep-with-next
    963          void SPI6_Init(void)
    964          {
    965          	
    966            hspi6.Instance = SPI6;
   \                     SPI6_Init: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable15_2
   \   00000004   0x.... 0x....      LDR.W    R1,??DataTable17_5  ;; 0x40015400
   \   00000008   0x6641             STR      R1,[R0, #+100]
    967            hspi6.Init.Mode = SPI_MODE_SLAVE;
   \   0000000A   0x2100             MOVS     R1,#+0
   \   0000000C   0x6681             STR      R1,[R0, #+104]
    968            hspi6.Init.Direction = SPI_DIRECTION_2LINES_RXONLY;//SPI_DIRECTION_2LINES_RXONLY
   \   0000000E   0xF44F 0x6180      MOV      R1,#+1024
   \   00000012   0x66C1             STR      R1,[R0, #+108]
    969            hspi6.Init.DataSize = SPI_DATASIZE_16BIT;
   \   00000014   0xF44F 0x6170      MOV      R1,#+3840
   \   00000018   0x6701             STR      R1,[R0, #+112]
    970            hspi6.Init.CLKPolarity = SPI_POLARITY_LOW;
   \   0000001A   0x2100             MOVS     R1,#+0
   \   0000001C   0x6741             STR      R1,[R0, #+116]
    971            hspi6.Init.CLKPhase = SPI_PHASE_1EDGE;
   \   0000001E   0x6781             STR      R1,[R0, #+120]
    972            hspi6.Init.NSS = SPI_NSS_SOFT;//SPI_NSS_HARD_INPUT
   \   00000020   0xF44F 0x7100      MOV      R1,#+512
   \   00000024   0x67C1             STR      R1,[R0, #+124]
    973            hspi6.Init.FirstBit = SPI_FIRSTBIT_MSB;
   \   00000026   0x2100             MOVS     R1,#+0
   \   00000028   0xF8C0 0x1084      STR      R1,[R0, #+132]
    974            hspi6.Init.TIMode = SPI_TIMODE_DISABLE;
   \   0000002C   0xF8C0 0x1088      STR      R1,[R0, #+136]
    975            hspi6.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLED;
   \   00000030   0xF8C0 0x108C      STR      R1,[R0, #+140]
    976            hspi6.Init.CRCPolynomial = 7;
   \   00000034   0x2107             MOVS     R1,#+7
   \   00000036   0xF8C0 0x1090      STR      R1,[R0, #+144]
    977            hspi6.Init.CRCLength = SPI_CRC_LENGTH_DATASIZE;
   \   0000003A   0x2100             MOVS     R1,#+0
   \   0000003C   0xF8C0 0x1094      STR      R1,[R0, #+148]
    978            hspi6.Init.NSSPMode = SPI_NSS_PULSE_DISABLE;
   \   00000040   0xF8C0 0x1098      STR      R1,[R0, #+152]
    979            //hspi6.RxISR = SPI6_CallBack;
    980            HAL_SPI_Init(&hspi6);
   \   00000044   0x3064             ADDS     R0,R0,#+100
   \   00000046   0x.... 0x....      B.W      HAL_SPI_Init
    981          
    982          
    983            //HAL_GPIO_WritePin(GPIOF,GPIO_PIN_6,GPIO_PIN_SET);
    984            /* Enable TXE, RXNE and ERR interrupt */
    985           //__HAL_SPI_ENABLE_IT(&hspi6, (SPI_IT_RXNE| SPI_IT_ERR));
    986          
    987           //__HAL_SPI_ENABLE(&hspi6);
    988          
    989          }
    990          
    991          
    992          
    993          

   \                                 In section .text, align 2, keep-with-next
    994          void HAL_SPI_MspInit(SPI_HandleTypeDef* hspi)
    995          {
   \                     HAL_SPI_MspInit: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0xB087             SUB      SP,SP,#+28
    996          
    997            GPIO_InitTypeDef GPIO_InitStruct;
    998            if (hspi->Instance==SPI1)
   \   00000006   0x.... 0x....      LDR.W    R1,??DataTable16_3  ;; 0x40013000
   \   0000000A   0x6820             LDR      R0,[R4, #+0]
   \   0000000C   0x4288             CMP      R0,R1
   \   0000000E   0xD131             BNE.N    ??HAL_SPI_MspInit_0
    999            {
   1000          	  /* USER CODE BEGIN SPI1_MspInit 0 */
   1001          	  
   1002          	  /* USER CODE END SPI1_MspInit 0 */
   1003          	  /* Peripheral clock enable */
   1004          	  __SPI1_CLK_ENABLE();
   \   00000010   0x.... 0x....      LDR.W    R5,??DataTable12  ;; 0x40023830
   1005          	  __GPIOA_CLK_ENABLE();
   1006          	  __GPIOC_CLK_ENABLE();
   1007          	  
   1008          	  /**I2S1 GPIO Configuration	
   1009          		PA4 	------> I2S1_WS --> LRCKO
   1010          		PA5 	------> I2S1_CK --> BICKO
   1011          		PA7 	------> I2S1_SD --> SDO12
   1012          		PC4 	------> I2S1_MCK
   1013          		*/
   1014          		GPIO_InitStruct.Pin =  GPIO_PIN_4|GPIO_PIN_5|GPIO_PIN_6|GPIO_PIN_7;
   1015          		GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
   1016          		GPIO_InitStruct.Pull = GPIO_NOPULL;
   1017          		GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
   1018          		GPIO_InitStruct.Alternate = GPIO_AF5_SPI1;
   1019          		HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
   \   00000014   0xA901             ADD      R1,SP,#+4
   \   00000016   0x6968             LDR      R0,[R5, #+20]
   \   00000018   0xF440 0x5080      ORR      R0,R0,#0x1000
   \   0000001C   0x6168             STR      R0,[R5, #+20]
   \   0000001E   0x6968             LDR      R0,[R5, #+20]
   \   00000020   0xF400 0x5080      AND      R0,R0,#0x1000
   \   00000024   0x9000             STR      R0,[SP, #+0]
   \   00000026   0x9800             LDR      R0,[SP, #+0]
   \   00000028   0x6828             LDR      R0,[R5, #+0]
   \   0000002A   0xF040 0x0001      ORR      R0,R0,#0x1
   \   0000002E   0x6028             STR      R0,[R5, #+0]
   \   00000030   0x6828             LDR      R0,[R5, #+0]
   \   00000032   0xF000 0x0001      AND      R0,R0,#0x1
   \   00000036   0x9000             STR      R0,[SP, #+0]
   \   00000038   0x9800             LDR      R0,[SP, #+0]
   \   0000003A   0x6828             LDR      R0,[R5, #+0]
   \   0000003C   0xF040 0x0004      ORR      R0,R0,#0x4
   \   00000040   0x6028             STR      R0,[R5, #+0]
   \   00000042   0x6828             LDR      R0,[R5, #+0]
   \   00000044   0xF000 0x0004      AND      R0,R0,#0x4
   \   00000048   0x9000             STR      R0,[SP, #+0]
   \   0000004A   0x9800             LDR      R0,[SP, #+0]
   \   0000004C   0x20F0             MOVS     R0,#+240
   \   0000004E   0x9001             STR      R0,[SP, #+4]
   \   00000050   0x2002             MOVS     R0,#+2
   \   00000052   0x9002             STR      R0,[SP, #+8]
   \   00000054   0x2000             MOVS     R0,#+0
   \   00000056   0x9003             STR      R0,[SP, #+12]
   \   00000058   0x2003             MOVS     R0,#+3
   \   0000005A   0x9004             STR      R0,[SP, #+16]
   \   0000005C   0x2005             MOVS     R0,#+5
   \   0000005E   0x9005             STR      R0,[SP, #+20]
   \   00000060   0x....             LDR.N    R0,??DataTable12_1  ;; 0x40020000
   \   00000062   0x.... 0x....      BL       HAL_GPIO_Init
   1020          	  
   1021          		//GPIO_InitStruct.Pin = GPIO_PIN_4;
   1022          		//GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
   1023          		//GPIO_InitStruct.Pull = GPIO_NOPULL;
   1024          		//GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
   1025          		//GPIO_InitStruct.Alternate = GPIO_AF5_SPI1;
   1026          		//HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
   1027          		
   1028          	  /* Peripheral interrupt init*/
   1029          		HAL_NVIC_SetPriority(SPI1_IRQn, INTERRUPT_PRI_SDO12, 0);
   \   00000066   0x2200             MOVS     R2,#+0
   \   00000068   0x2100             MOVS     R1,#+0
   \   0000006A   0x2023             MOVS     R0,#+35
   \   0000006C   0x.... 0x....      BL       HAL_NVIC_SetPriority
   1030          		HAL_NVIC_EnableIRQ(SPI1_IRQn);
   \   00000070   0x2023             MOVS     R0,#+35
   \   00000072   0xE1CA             B.N      ??HAL_SPI_MspInit_1
   1031          	  /* USER CODE BEGIN SPI1_MspInit 1 */
   1032          	  
   1033          	  /* USER CODE END SPI1_MspInit 1 */
   1034          
   1035            }
   1036            else if (hspi->Instance==SPI2)
   \                     ??HAL_SPI_MspInit_0: (+1)
   \   00000074   0x.... 0x....      LDR.W    R1,??DataTable17_1  ;; 0x40003800
   \   00000078   0x4288             CMP      R0,R1
   \   0000007A   0xD149             BNE.N    ??HAL_SPI_MspInit_2
   1037            {
   1038          	  /* USER CODE BEGIN SPI2_MspInit 0 */
   1039          	  
   1040          	  /* USER CODE END SPI2_MspInit 0 */
   1041          		/* Peripheral clock enable */
   1042          		__SPI2_CLK_ENABLE();
   \   0000007C   0x....             LDR.N    R5,??DataTable12  ;; 0x40023830
   1043          		__GPIOI_CLK_ENABLE();
   1044          		__GPIOB_CLK_ENABLE();
   1045          		__GPIOC_CLK_ENABLE();
   1046          	  
   1047          		/**I2S2 GPIO Configuration	   
   1048          		PC1 	------> I2S2_SD  : PI3 PC1 PC3 PB15 	
   1049          		PB13	 ------> I2S2_CK :PD3 PB10 PB13 PA9 PI1 
   1050          		PB12	 ------> I2S2_WS : PB12 PI0 PB4 PB9  
   1051          	  
   1052          	  
   1053          		*/
   1054          		GPIO_InitStruct.Pin = GPIO_PIN_1; //SD
   1055          		GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
   1056          		GPIO_InitStruct.Pull = GPIO_NOPULL;
   1057          		GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
   1058          		GPIO_InitStruct.Alternate = GPIO_AF5_SPI2;
   1059          		HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
   \   0000007E   0xA901             ADD      R1,SP,#+4
   \   00000080   0x6928             LDR      R0,[R5, #+16]
   \   00000082   0xF440 0x4080      ORR      R0,R0,#0x4000
   \   00000086   0x6128             STR      R0,[R5, #+16]
   \   00000088   0x6928             LDR      R0,[R5, #+16]
   \   0000008A   0xF400 0x4080      AND      R0,R0,#0x4000
   \   0000008E   0x9000             STR      R0,[SP, #+0]
   \   00000090   0x9800             LDR      R0,[SP, #+0]
   \   00000092   0x6828             LDR      R0,[R5, #+0]
   \   00000094   0xF440 0x7080      ORR      R0,R0,#0x100
   \   00000098   0x6028             STR      R0,[R5, #+0]
   \   0000009A   0x6828             LDR      R0,[R5, #+0]
   \   0000009C   0xF400 0x7080      AND      R0,R0,#0x100
   \   000000A0   0x9000             STR      R0,[SP, #+0]
   \   000000A2   0x9800             LDR      R0,[SP, #+0]
   \   000000A4   0x6828             LDR      R0,[R5, #+0]
   \   000000A6   0xF040 0x0002      ORR      R0,R0,#0x2
   \   000000AA   0x6028             STR      R0,[R5, #+0]
   \   000000AC   0x6828             LDR      R0,[R5, #+0]
   \   000000AE   0xF000 0x0002      AND      R0,R0,#0x2
   \   000000B2   0x9000             STR      R0,[SP, #+0]
   \   000000B4   0x9800             LDR      R0,[SP, #+0]
   \   000000B6   0x6828             LDR      R0,[R5, #+0]
   \   000000B8   0xF040 0x0004      ORR      R0,R0,#0x4
   \   000000BC   0x6028             STR      R0,[R5, #+0]
   \   000000BE   0x6828             LDR      R0,[R5, #+0]
   \   000000C0   0xF000 0x0004      AND      R0,R0,#0x4
   \   000000C4   0x9000             STR      R0,[SP, #+0]
   \   000000C6   0x9800             LDR      R0,[SP, #+0]
   \   000000C8   0x2002             MOVS     R0,#+2
   \   000000CA   0x9001             STR      R0,[SP, #+4]
   \   000000CC   0x9002             STR      R0,[SP, #+8]
   \   000000CE   0x2000             MOVS     R0,#+0
   \   000000D0   0x9003             STR      R0,[SP, #+12]
   \   000000D2   0x2003             MOVS     R0,#+3
   \   000000D4   0x9004             STR      R0,[SP, #+16]
   \   000000D6   0x2005             MOVS     R0,#+5
   \   000000D8   0x9005             STR      R0,[SP, #+20]
   \   000000DA   0x.... 0x....      LDR.W    R0,??DataTable17_7  ;; 0x40020800
   \   000000DE   0x.... 0x....      BL       HAL_GPIO_Init
   1060          	  
   1061          		GPIO_InitStruct.Pin = GPIO_PIN_12|GPIO_PIN_13;//WS --> GPIO_PIN_12
   \   000000E2   0xF44F 0x5040      MOV      R0,#+12288
   1062          		GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
   1063          		GPIO_InitStruct.Pull = GPIO_NOPULL;
   1064          		GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
   1065          		GPIO_InitStruct.Alternate = GPIO_AF5_SPI2;
   1066          		HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
   \   000000E6   0xA901             ADD      R1,SP,#+4
   \   000000E8   0x9001             STR      R0,[SP, #+4]
   \   000000EA   0x2002             MOVS     R0,#+2
   \   000000EC   0x9002             STR      R0,[SP, #+8]
   \   000000EE   0x2000             MOVS     R0,#+0
   \   000000F0   0x9003             STR      R0,[SP, #+12]
   \   000000F2   0x2003             MOVS     R0,#+3
   \   000000F4   0x9004             STR      R0,[SP, #+16]
   \   000000F6   0x2005             MOVS     R0,#+5
   \   000000F8   0x9005             STR      R0,[SP, #+20]
   \   000000FA   0x.... 0x....      LDR.W    R0,??DataTable17_8  ;; 0x40020400
   \   000000FE   0x.... 0x....      BL       HAL_GPIO_Init
   1067          	  
   1068          	  
   1069          		/* Peripheral interrupt init*/
   1070          		HAL_NVIC_SetPriority(SPI2_IRQn, INTERRUPT_PRI_SDO34, 0);
   \   00000102   0x2200             MOVS     R2,#+0
   \   00000104   0x2101             MOVS     R1,#+1
   \   00000106   0x2024             MOVS     R0,#+36
   \   00000108   0x.... 0x....      BL       HAL_NVIC_SetPriority
   1071          		HAL_NVIC_EnableIRQ(SPI2_IRQn);
   \   0000010C   0x2024             MOVS     R0,#+36
   \   0000010E   0xE17C             B.N      ??HAL_SPI_MspInit_1
   1072          		/* USER CODE BEGIN SPI2_MspInit 1 */
   1073          	  
   1074          	  /* USER CODE END SPI2_MspInit 1 */
   1075          
   1076          
   1077            }
   1078            else if (hspi->Instance==SPI3)
   \                     ??HAL_SPI_MspInit_2: (+1)
   \   00000110   0x.... 0x....      LDR.W    R1,??DataTable17_9  ;; 0x40003c00
   \   00000114   0x4288             CMP      R0,R1
   \   00000116   0xF040 0x808E      BNE.W    ??HAL_SPI_MspInit_3
   1079            {
   1080          	  
   1081              /**I2S3 GPIO Configuration    
   1082                 PB2     ------> I2S3_SD
   1083                 PA15     ------> I2S3_WS (LRCK)
   1084                 PB3     ------> I2S3_CK 
   1085          	   PC7    ------> MCLK
   1086              */
   1087           
   1088            /* USER CODE BEGIN SPI3_MspInit 1 */
   1089            __SPI3_CLK_ENABLE();
   \   0000011A   0x....             LDR.N    R5,??DataTable12  ;; 0x40023830
   1090            __GPIOA_CLK_ENABLE();
   1091            __GPIOB_CLK_ENABLE();
   1092          
   1093            GPIO_InitStruct.Pin = GPIO_PIN_3 | GPIO_PIN_2; 
   1094            GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
   1095            GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
   1096            GPIO_InitStruct.Pull = GPIO_NOPULL;
   1097            GPIO_InitStruct.Alternate = GPIO_AF6_SPI3;
   1098            HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
   \   0000011C   0xA901             ADD      R1,SP,#+4
   \   0000011E   0x6928             LDR      R0,[R5, #+16]
   \   00000120   0xF440 0x4000      ORR      R0,R0,#0x8000
   \   00000124   0x6128             STR      R0,[R5, #+16]
   \   00000126   0x6928             LDR      R0,[R5, #+16]
   \   00000128   0xF400 0x4000      AND      R0,R0,#0x8000
   \   0000012C   0x9000             STR      R0,[SP, #+0]
   \   0000012E   0x9800             LDR      R0,[SP, #+0]
   \   00000130   0x6828             LDR      R0,[R5, #+0]
   \   00000132   0xF040 0x0001      ORR      R0,R0,#0x1
   \   00000136   0x6028             STR      R0,[R5, #+0]
   \   00000138   0x6828             LDR      R0,[R5, #+0]
   \   0000013A   0xF000 0x0001      AND      R0,R0,#0x1
   \   0000013E   0x9000             STR      R0,[SP, #+0]
   \   00000140   0x9800             LDR      R0,[SP, #+0]
   \   00000142   0x6828             LDR      R0,[R5, #+0]
   \   00000144   0xF040 0x0002      ORR      R0,R0,#0x2
   \   00000148   0x6028             STR      R0,[R5, #+0]
   \   0000014A   0x6828             LDR      R0,[R5, #+0]
   \   0000014C   0xF000 0x0002      AND      R0,R0,#0x2
   \   00000150   0x9000             STR      R0,[SP, #+0]
   \   00000152   0x9800             LDR      R0,[SP, #+0]
   \   00000154   0x200C             MOVS     R0,#+12
   \   00000156   0x9001             STR      R0,[SP, #+4]
   \   00000158   0x2002             MOVS     R0,#+2
   \   0000015A   0x9002             STR      R0,[SP, #+8]
   \   0000015C   0x2003             MOVS     R0,#+3
   \   0000015E   0x9004             STR      R0,[SP, #+16]
   \   00000160   0x2000             MOVS     R0,#+0
   \   00000162   0x9003             STR      R0,[SP, #+12]
   \   00000164   0x2006             MOVS     R0,#+6
   \   00000166   0x9005             STR      R0,[SP, #+20]
   \   00000168   0x.... 0x....      LDR.W    R0,??DataTable17_8  ;; 0x40020400
   \   0000016C   0x.... 0x....      BL       HAL_GPIO_Init
   1099          
   1100          
   1101            GPIO_InitStruct.Pin = GPIO_PIN_15;
   \   00000170   0xF44F 0x4000      MOV      R0,#+32768
   1102            GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
   1103            GPIO_InitStruct.Alternate = GPIO_AF6_SPI3;
   1104            HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
   \   00000174   0xA901             ADD      R1,SP,#+4
   \   00000176   0x9001             STR      R0,[SP, #+4]
   \   00000178   0x2002             MOVS     R0,#+2
   \   0000017A   0x9002             STR      R0,[SP, #+8]
   \   0000017C   0x2006             MOVS     R0,#+6
   \   0000017E   0x9005             STR      R0,[SP, #+20]
   \   00000180   0x....             LDR.N    R0,??DataTable12_1  ;; 0x40020000
   \   00000182   0x.... 0x....      BL       HAL_GPIO_Init
   1105          
   1106          #ifdef CODEC_MCLK_ENABLED
   1107            __GPIOC_CLK_ENABLE();
   \   00000186   0x6828             LDR      R0,[R5, #+0]
   1108            GPIO_InitStruct.Pin = GPIO_PIN_7; 
   1109            GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
   1110            GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
   1111            GPIO_InitStruct.Pull = GPIO_NOPULL;
   1112            GPIO_InitStruct.Alternate = GPIO_AF6_SPI3;
   1113            HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
   \   00000188   0xA901             ADD      R1,SP,#+4
   \   0000018A   0xF040 0x0004      ORR      R0,R0,#0x4
   \   0000018E   0x6028             STR      R0,[R5, #+0]
   \   00000190   0x6828             LDR      R0,[R5, #+0]
   \   00000192   0xF000 0x0004      AND      R0,R0,#0x4
   \   00000196   0x9000             STR      R0,[SP, #+0]
   \   00000198   0x9800             LDR      R0,[SP, #+0]
   \   0000019A   0x2080             MOVS     R0,#+128
   \   0000019C   0x9001             STR      R0,[SP, #+4]
   \   0000019E   0x2002             MOVS     R0,#+2
   \   000001A0   0x9002             STR      R0,[SP, #+8]
   \   000001A2   0x2003             MOVS     R0,#+3
   \   000001A4   0x9004             STR      R0,[SP, #+16]
   \   000001A6   0x2000             MOVS     R0,#+0
   \   000001A8   0x9003             STR      R0,[SP, #+12]
   \   000001AA   0x2006             MOVS     R0,#+6
   \   000001AC   0x9005             STR      R0,[SP, #+20]
   \   000001AE   0x.... 0x....      LDR.W    R0,??DataTable17_7  ;; 0x40020800
   \   000001B2   0x.... 0x....      BL       HAL_GPIO_Init
   1114          
   1115          #endif /* CODEC_MCLK_ENABLED */ 
   1116          
   1117          #ifdef I2S_INTERRUPT   
   1118               /* Enable and set Button EXTI Interrupt to the lowest priority */
   1119               //HAL_NVIC_SetPriority((IRQn_Type)SPI3_IRQn, 0x00, 0x01);
   1120               //HAL_NVIC_EnableIRQ((IRQn_Type)SPI3_IRQn);
   1121          
   1122               /* Enable the I2S DMA request */
   1123               //__HAL_I2S_ENABLE_IT(&hi2s3, SPI_I2S_DMAReq_Tx);
   1124               //__HAL_I2S_ENABLE(&hi2s3);
   1125            	    /* Peripheral interrupt init*/
   1126          		HAL_NVIC_SetPriority(SPI3_IRQn, 3, 0);
   1127          		HAL_NVIC_EnableIRQ(SPI3_IRQn);
   1128          #endif
   1129          
   1130                /* Enable the DMA clock */ 
   1131          	  __HAL_RCC_DMA1_CLK_ENABLE();
   \   000001B6   0x6828             LDR      R0,[R5, #+0]
   \   000001B8   0xF440 0x1000      ORR      R0,R0,#0x200000
   \   000001BC   0x6028             STR      R0,[R5, #+0]
   \   000001BE   0x6828             LDR      R0,[R5, #+0]
   1132          
   1133                /* Configure the DMA Stream */
   1134                //HAL_DMA_DeInit(&DmaHandle);
   1135          
   1136                /* Set the parameters to be configured */ 
   1137          	  DmaHandle.Instance = DMA1_Stream7;
   \   000001C0   0x.... 0x....      LDR.W    R5,??DataTable17_10
   \   000001C4   0xF400 0x1000      AND      R0,R0,#0x200000
   \   000001C8   0x9000             STR      R0,[SP, #+0]
   \   000001CA   0x9800             LDR      R0,[SP, #+0]
   \   000001CC   0x.... 0x....      LDR.W    R0,??DataTable17_11  ;; 0x400260b8
   \   000001D0   0x6028             STR      R0,[R5, #+0]
   1138                DmaHandle.Init.Channel = DMA_CHANNEL_0;
   \   000001D2   0x2000             MOVS     R0,#+0
   \   000001D4   0x6068             STR      R0,[R5, #+4]
   1139          	  DmaHandle.Init.Direction = DMA_MEMORY_TO_PERIPH;
   \   000001D6   0x2040             MOVS     R0,#+64
   \   000001D8   0x60A8             STR      R0,[R5, #+8]
   1140          	  DmaHandle.Init.PeriphInc = DMA_PINC_DISABLE;
   \   000001DA   0x2000             MOVS     R0,#+0
   \   000001DC   0x60E8             STR      R0,[R5, #+12]
   1141          	  DmaHandle.Init.MemInc = DMA_MINC_ENABLE;
   \   000001DE   0xF44F 0x6080      MOV      R0,#+1024
   \   000001E2   0x6128             STR      R0,[R5, #+16]
   1142          	  DmaHandle.Init.PeriphDataAlignment = DMA_PDATAALIGN_HALFWORD;
   \   000001E4   0xF44F 0x6000      MOV      R0,#+2048
   \   000001E8   0x6168             STR      R0,[R5, #+20]
   1143                DmaHandle.Init.MemDataAlignment = DMA_MDATAALIGN_HALFWORD; 
   \   000001EA   0xF44F 0x5000      MOV      R0,#+8192
   \   000001EE   0x61A8             STR      R0,[R5, #+24]
   1144          	  DmaHandle.Init.Mode = DMA_NORMAL;
   \   000001F0   0x2000             MOVS     R0,#+0
   \   000001F2   0x61E8             STR      R0,[R5, #+28]
   1145                DmaHandle.Init.Priority = DMA_PRIORITY_HIGH; 
   \   000001F4   0xF44F 0x3000      MOV      R0,#+131072
   \   000001F8   0x6228             STR      R0,[R5, #+32]
   1146          	  DmaHandle.Init.FIFOMode = DMA_FIFOMODE_ENABLE;//DMA_FIFOMODE_DISABLE
   \   000001FA   0x2004             MOVS     R0,#+4
   \   000001FC   0x6268             STR      R0,[R5, #+36]
   1147                DmaHandle.Init.FIFOThreshold = DMA_FIFO_THRESHOLD_FULL;
   \   000001FE   0x2003             MOVS     R0,#+3
   \   00000200   0x62A8             STR      R0,[R5, #+40]
   1148                DmaHandle.Init.MemBurst = DMA_MBURST_SINGLE;
   \   00000202   0x2000             MOVS     R0,#+0
   \   00000204   0x62E8             STR      R0,[R5, #+44]
   1149                DmaHandle.Init.PeriphBurst = DMA_PBURST_SINGLE;	  
   \   00000206   0x6328             STR      R0,[R5, #+48]
   1150                //DmaHandle.Instance->PAR =(uint32_t)&SPI3->DR;//CODEC_I2S_ADDRESS
   1151                //DmaHandle.Instance->M0AR = (uint32_t)0;
   1152                //DmaHandle.Instance->NDTR = (uint32_t)0xFFFE;
   1153                //DmaHandle.XferCpltCallback = &TC_Callback;
   1154           
   1155          
   1156                /* Associate the initialized DMA handle to the the SPI handle */
   1157                __HAL_LINKDMA(hspi, hdmatx, DmaHandle);
   1158                //__HAL_DMA_ENABLE_IT(&DmaHandle, DMA_IT_TC);
   1159          
   1160          	   /* Deinitialize the Stream for new transfer */
   1161                 HAL_DMA_DeInit(&DmaHandle);
   \   00000208   0x4628             MOV      R0,R5
   \   0000020A   0x6565             STR      R5,[R4, #+84]
   \   0000020C   0x63AC             STR      R4,[R5, #+56]
   \   0000020E   0x.... 0x....      BL       HAL_DMA_DeInit
   1162                 /* Configure the DMA Stream */
   1163          	   HAL_DMA_Init(&DmaHandle);
   \   00000212   0x4628             MOV      R0,R5
   \   00000214   0x.... 0x....      BL       HAL_DMA_Init
   1164          
   1165                /* Set Interrupt Group Priority */
   1166                HAL_NVIC_SetPriority(DMA1_Stream7_IRQn, INTERRUPT_PRI_DMA, 0);
   \   00000218   0x2200             MOVS     R2,#+0
   \   0000021A   0x2105             MOVS     R1,#+5
   \   0000021C   0x202F             MOVS     R0,#+47
   \   0000021E   0x.... 0x....      BL       HAL_NVIC_SetPriority
   1167                /* Enable the DMA STREAM global Interrupt */
   1168                HAL_NVIC_EnableIRQ(DMA1_Stream7_IRQn);    
   \   00000222   0x202F             MOVS     R0,#+47
   \   00000224   0x.... 0x....      BL       HAL_NVIC_EnableIRQ
   1169          
   1170          	  __HAL_DMA_ENABLE_IT(&DmaHandle, DMA_IT_TC);
   \   00000228   0x6828             LDR      R0,[R5, #+0]
   \   0000022A   0x6801             LDR      R1,[R0, #+0]
   \   0000022C   0xF041 0x0110      ORR      R1,R1,#0x10
   \   00000230   0x6001             STR      R1,[R0, #+0]
   1171          	    
   1172            }
   1173            else if(hspi->Instance==SPI4)
   1174            {
   1175            /* USER CODE BEGIN SPI4_MspInit 0 */
   1176          
   1177            /* USER CODE END SPI4_MspInit 0 */
   1178              /* Peripheral clock enable */
   1179              __SPI4_CLK_ENABLE();
   1180              __HAL_RCC_GPIOE_CLK_ENABLE();
   1181            
   1182            
   1183              /**SPI4 GPIO Configuration    
   1184              PE2     ------> SPI4_SCK
   1185              PE4     ------> SPI4_NSS
   1186              PE5     ------> SPI4_MISO
   1187              PE6     ------> SPI4_MOSI 
   1188              */
   1189              GPIO_InitStruct.Pin = GPIO_PIN_2|GPIO_PIN_4|GPIO_PIN_5|GPIO_PIN_6;
   1190              GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
   1191              GPIO_InitStruct.Pull = GPIO_NOPULL;
   1192              GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
   1193              GPIO_InitStruct.Alternate = GPIO_AF5_SPI4;
   1194              HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
   1195          
   1196          	/* Peripheral interrupt init*/
   1197              HAL_NVIC_SetPriority(SPI4_IRQn, INTERRUPT_PRI_SDO56, 0);
   1198              HAL_NVIC_EnableIRQ(SPI4_IRQn);
   1199          
   1200            /* USER CODE BEGIN SPI4_MspInit 1 */
   1201          
   1202            /* USER CODE END SPI4_MspInit 1 */
   1203            }
   1204            else if(hspi->Instance==SPI5)
   1205            {
   1206            /* USER CODE BEGIN SPI5_MspInit 0 */
   1207          
   1208            /* USER CODE END SPI5_MspInit 0 */
   1209              /* Peripheral clock enable */
   1210              __HAL_RCC_SPI5_CLK_ENABLE();
   1211              __HAL_RCC_GPIOF_CLK_ENABLE();
   1212            
   1213              /**SPI5 GPIO Configuration    
   1214              PF7     ------> SPI5_SCK  --> PF7
   1215              PF11     ------> SPI5_MOSI --> PF9
   1216                               SPI5_MISO --> PF8
   1217                                    NSS   -->  PF6
   1218              */
   1219              GPIO_InitStruct.Pin = GPIO_PIN_6|GPIO_PIN_7|GPIO_PIN_9|GPIO_PIN_8;
   1220              GPIO_InitStruct.Mode = GPIO_MODE_AF_OD;
   1221              GPIO_InitStruct.Pull = GPIO_PULLUP;
   1222              GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
   1223              GPIO_InitStruct.Alternate = GPIO_AF5_SPI5;
   1224              HAL_GPIO_Init(GPIOF, &GPIO_InitStruct);
   1225          
   1226          #if 0
   1227            /* Peripheral interrupt init*/
   1228              HAL_NVIC_SetPriority(SPI5_IRQn, INTERRUPT_PRI_SDO7, 0);
   1229              HAL_NVIC_EnableIRQ(SPI5_IRQn);
   1230          
   1231          #else
   1232          	/* Peripheral DMA init*/
   1233              __HAL_RCC_DMA2_CLK_ENABLE();
   1234          	hdma_spi5_rx.Instance = DMA2_Stream5;
   1235          	hdma_spi5_rx.Init.Channel = DMA_CHANNEL_7;
   1236          	hdma_spi5_rx.Init.Direction = DMA_PERIPH_TO_MEMORY;
   1237          	hdma_spi5_rx.Init.PeriphInc = DMA_PINC_DISABLE;
   1238          	hdma_spi5_rx.Init.MemInc = DMA_MINC_ENABLE;
   1239          	hdma_spi5_rx.Init.PeriphDataAlignment = DMA_PDATAALIGN_HALFWORD;
   1240          	hdma_spi5_rx.Init.MemDataAlignment = DMA_MDATAALIGN_HALFWORD;
   1241          	hdma_spi5_rx.Init.Mode = DMA_NORMAL;
   1242          	hdma_spi5_rx.Init.Priority = DMA_PRIORITY_HIGH;
   1243          	hdma_spi5_rx.Init.FIFOMode = DMA_FIFOMODE_DISABLE;
   1244          	hdma_spi5_rx.Init.FIFOThreshold = DMA_FIFO_THRESHOLD_FULL;
   1245          	hdma_spi5_rx.Init.MemBurst = DMA_MBURST_SINGLE;
   1246          	hdma_spi5_rx.Init.PeriphBurst = DMA_PBURST_SINGLE;
   1247          	HAL_DMA_Init(&hdma_spi5_rx);
   1248          
   1249              __HAL_LINKDMA(hspi,hdmarx,hdma_spi5_rx);
   1250          
   1251          	HAL_NVIC_SetPriority(DMA2_Stream5_IRQn, INTERRUPT_PRI_SDO7, 0);
   1252          	HAL_NVIC_EnableIRQ(DMA2_Stream5_IRQn);
   1253          
   1254          #endif
   1255            /* USER CODE END SPI5_MspInit 1 */
   1256            }
   1257            else if(hspi->Instance==SPI6)
   1258            {
   1259            /* USER CODE BEGIN SPI6_MspInit 0 */
   1260          
   1261            /* USER CODE END SPI6_MspInit 0 */
   1262              /* Peripheral clock enable */
   1263              __SPI6_CLK_ENABLE();
   1264              __HAL_RCC_GPIOG_CLK_ENABLE();
   1265            
   1266              /**SPI6 GPIO Configuration    
   1267              PG13     ------> SPI6_SCK
   1268              PG14     ------> SPI6_MOSI 
   1269              */
   1270              GPIO_InitStruct.Pin = GPIO_PIN_13|GPIO_PIN_14;
   1271              GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
   1272              GPIO_InitStruct.Pull = GPIO_NOPULL;
   1273              GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
   1274              GPIO_InitStruct.Alternate = GPIO_AF5_SPI6;
   1275              HAL_GPIO_Init(GPIOG, &GPIO_InitStruct);
   1276          
   1277          #if 0
   1278          	  /* Peripheral interrupt init*/
   1279              HAL_NVIC_SetPriority(SPI6_IRQn, INTERRUPT_PRI_SDO8, 1);
   1280              HAL_NVIC_EnableIRQ(SPI6_IRQn);
   1281          #else
   1282          	/* Peripheral DMA init*/
   1283          	__HAL_RCC_DMA2_CLK_ENABLE();
   1284          	hdma_spi6_rx.Instance = DMA2_Stream6;
   1285          	hdma_spi6_rx.Init.Channel = DMA_CHANNEL_1;
   1286          	hdma_spi6_rx.Init.Direction = DMA_PERIPH_TO_MEMORY;
   1287          	hdma_spi6_rx.Init.PeriphInc = DMA_PINC_DISABLE;
   1288          	hdma_spi6_rx.Init.MemInc = DMA_MINC_ENABLE;
   1289          	hdma_spi6_rx.Init.PeriphDataAlignment = DMA_PDATAALIGN_HALFWORD;
   1290          	hdma_spi6_rx.Init.MemDataAlignment = DMA_PDATAALIGN_HALFWORD;
   1291          	hdma_spi6_rx.Init.Mode = DMA_NORMAL;
   1292          	hdma_spi6_rx.Init.Priority = DMA_PRIORITY_HIGH;
   1293          	hdma_spi6_rx.Init.FIFOMode = DMA_FIFOMODE_DISABLE;
   1294          	hdma_spi6_rx.Init.FIFOThreshold = DMA_FIFO_THRESHOLD_FULL;
   1295          	hdma_spi6_rx.Init.MemBurst = DMA_MBURST_SINGLE;
   1296          	hdma_spi6_rx.Init.PeriphBurst = DMA_PBURST_SINGLE;
   1297          	HAL_DMA_Init(&hdma_spi6_rx);
   1298          
   1299          	__HAL_LINKDMA(hspi,hdmarx,hdma_spi6_rx);
   1300          
   1301          	HAL_NVIC_SetPriority(DMA2_Stream6_IRQn, INTERRUPT_PRI_SDO8, 0);
   1302          	HAL_NVIC_EnableIRQ(DMA2_Stream6_IRQn);
   1303          
   1304          #endif
   1305            }
   1306          
   1307          }
   \   00000232   0xB007             ADD      SP,SP,#+28
   \   00000234   0xBD30             POP      {R4,R5,PC}
   \                     ??HAL_SPI_MspInit_3: (+1)
   \   00000236   0x.... 0x....      LDR.W    R1,??DataTable17_4  ;; 0x40013400
   \   0000023A   0x4288             CMP      R0,R1
   \   0000023C   0xD127             BNE.N    ??HAL_SPI_MspInit_4
   \   0000023E   0x....             LDR.N    R5,??DataTable12  ;; 0x40023830
   \   00000240   0xA901             ADD      R1,SP,#+4
   \   00000242   0x6968             LDR      R0,[R5, #+20]
   \   00000244   0xF440 0x5000      ORR      R0,R0,#0x2000
   \   00000248   0x6168             STR      R0,[R5, #+20]
   \   0000024A   0x6968             LDR      R0,[R5, #+20]
   \   0000024C   0xF400 0x5000      AND      R0,R0,#0x2000
   \   00000250   0x9000             STR      R0,[SP, #+0]
   \   00000252   0x9800             LDR      R0,[SP, #+0]
   \   00000254   0x6828             LDR      R0,[R5, #+0]
   \   00000256   0xF040 0x0010      ORR      R0,R0,#0x10
   \   0000025A   0x6028             STR      R0,[R5, #+0]
   \   0000025C   0x6828             LDR      R0,[R5, #+0]
   \   0000025E   0xF000 0x0010      AND      R0,R0,#0x10
   \   00000262   0x9000             STR      R0,[SP, #+0]
   \   00000264   0x9800             LDR      R0,[SP, #+0]
   \   00000266   0x2074             MOVS     R0,#+116
   \   00000268   0x9001             STR      R0,[SP, #+4]
   \   0000026A   0x2002             MOVS     R0,#+2
   \   0000026C   0x9002             STR      R0,[SP, #+8]
   \   0000026E   0x2000             MOVS     R0,#+0
   \   00000270   0x9003             STR      R0,[SP, #+12]
   \   00000272   0x2003             MOVS     R0,#+3
   \   00000274   0x9004             STR      R0,[SP, #+16]
   \   00000276   0x2005             MOVS     R0,#+5
   \   00000278   0x9005             STR      R0,[SP, #+20]
   \   0000027A   0x....             LDR.N    R0,??DataTable15  ;; 0x40021000
   \   0000027C   0x.... 0x....      BL       HAL_GPIO_Init
   \   00000280   0x2200             MOVS     R2,#+0
   \   00000282   0x2102             MOVS     R1,#+2
   \   00000284   0x2054             MOVS     R0,#+84
   \   00000286   0x.... 0x....      BL       HAL_NVIC_SetPriority
   \   0000028A   0x2054             MOVS     R0,#+84
   \   0000028C   0xE0BD             B.N      ??HAL_SPI_MspInit_1
   \                     ??HAL_SPI_MspInit_4: (+1)
   \   0000028E   0x.... 0x....      LDR.W    R1,??DataTable17_6  ;; 0x40015000
   \   00000292   0x4288             CMP      R0,R1
   \   00000294   0xD159             BNE.N    ??HAL_SPI_MspInit_5
   \   00000296   0x....             LDR.N    R5,??DataTable12  ;; 0x40023830
   \   00000298   0xA901             ADD      R1,SP,#+4
   \   0000029A   0x6968             LDR      R0,[R5, #+20]
   \   0000029C   0xF440 0x1080      ORR      R0,R0,#0x100000
   \   000002A0   0x6168             STR      R0,[R5, #+20]
   \   000002A2   0x6968             LDR      R0,[R5, #+20]
   \   000002A4   0xF400 0x1080      AND      R0,R0,#0x100000
   \   000002A8   0x9000             STR      R0,[SP, #+0]
   \   000002AA   0x9800             LDR      R0,[SP, #+0]
   \   000002AC   0x6828             LDR      R0,[R5, #+0]
   \   000002AE   0xF040 0x0020      ORR      R0,R0,#0x20
   \   000002B2   0x6028             STR      R0,[R5, #+0]
   \   000002B4   0x6828             LDR      R0,[R5, #+0]
   \   000002B6   0xF000 0x0020      AND      R0,R0,#0x20
   \   000002BA   0x9000             STR      R0,[SP, #+0]
   \   000002BC   0x9800             LDR      R0,[SP, #+0]
   \   000002BE   0xF44F 0x7070      MOV      R0,#+960
   \   000002C2   0x9001             STR      R0,[SP, #+4]
   \   000002C4   0x2012             MOVS     R0,#+18
   \   000002C6   0x9002             STR      R0,[SP, #+8]
   \   000002C8   0x2001             MOVS     R0,#+1
   \   000002CA   0x9003             STR      R0,[SP, #+12]
   \   000002CC   0x2003             MOVS     R0,#+3
   \   000002CE   0x9004             STR      R0,[SP, #+16]
   \   000002D0   0x2005             MOVS     R0,#+5
   \   000002D2   0x9005             STR      R0,[SP, #+20]
   \   000002D4   0x.... 0x....      LDR.W    R0,??DataTable17_12  ;; 0x40021400
   \   000002D8   0x.... 0x....      BL       HAL_GPIO_Init
   \   000002DC   0x6828             LDR      R0,[R5, #+0]
   \   000002DE   0xF440 0x0080      ORR      R0,R0,#0x400000
   \   000002E2   0x6028             STR      R0,[R5, #+0]
   \   000002E4   0x6828             LDR      R0,[R5, #+0]
   \   000002E6   0x.... 0x....      LDR.W    R5,??DataTable17_13
   \   000002EA   0xF400 0x0080      AND      R0,R0,#0x400000
   \   000002EE   0x9000             STR      R0,[SP, #+0]
   \   000002F0   0x9800             LDR      R0,[SP, #+0]
   \   000002F2   0x.... 0x....      LDR.W    R0,??DataTable17_11  ;; 0x400260b8
   \   000002F6   0xF500 0x7074      ADD      R0,R0,#+976
   \   000002FA   0x6028             STR      R0,[R5, #+0]
   \   000002FC   0xF04F 0x6060      MOV      R0,#+234881024
   \   00000300   0x6068             STR      R0,[R5, #+4]
   \   00000302   0x2000             MOVS     R0,#+0
   \   00000304   0x60A8             STR      R0,[R5, #+8]
   \   00000306   0x60E8             STR      R0,[R5, #+12]
   \   00000308   0xF44F 0x6080      MOV      R0,#+1024
   \   0000030C   0x6128             STR      R0,[R5, #+16]
   \   0000030E   0xF44F 0x6000      MOV      R0,#+2048
   \   00000312   0x6168             STR      R0,[R5, #+20]
   \   00000314   0xF44F 0x5000      MOV      R0,#+8192
   \   00000318   0x61A8             STR      R0,[R5, #+24]
   \   0000031A   0x2000             MOVS     R0,#+0
   \   0000031C   0x61E8             STR      R0,[R5, #+28]
   \   0000031E   0xF44F 0x3000      MOV      R0,#+131072
   \   00000322   0x6228             STR      R0,[R5, #+32]
   \   00000324   0x2000             MOVS     R0,#+0
   \   00000326   0x6268             STR      R0,[R5, #+36]
   \   00000328   0x2003             MOVS     R0,#+3
   \   0000032A   0x62A8             STR      R0,[R5, #+40]
   \   0000032C   0x2000             MOVS     R0,#+0
   \   0000032E   0x62E8             STR      R0,[R5, #+44]
   \   00000330   0x6328             STR      R0,[R5, #+48]
   \   00000332   0x4628             MOV      R0,R5
   \   00000334   0x.... 0x....      BL       HAL_DMA_Init
   \   00000338   0x65A5             STR      R5,[R4, #+88]
   \   0000033A   0x2200             MOVS     R2,#+0
   \   0000033C   0x63AC             STR      R4,[R5, #+56]
   \   0000033E   0x2104             MOVS     R1,#+4
   \   00000340   0x2044             MOVS     R0,#+68
   \   00000342   0x.... 0x....      BL       HAL_NVIC_SetPriority
   \   00000346   0x2044             MOVS     R0,#+68
   \   00000348   0xE05F             B.N      ??HAL_SPI_MspInit_1
   \                     ??HAL_SPI_MspInit_5: (+1)
   \   0000034A   0x.... 0x....      LDR.W    R1,??DataTable17_5  ;; 0x40015400
   \   0000034E   0x4288             CMP      R0,R1
   \   00000350   0xD15D             BNE.N    ??HAL_SPI_MspInit_6
   \   00000352   0x....             LDR.N    R5,??DataTable12  ;; 0x40023830
   \   00000354   0xA901             ADD      R1,SP,#+4
   \   00000356   0x6968             LDR      R0,[R5, #+20]
   \   00000358   0xF440 0x1000      ORR      R0,R0,#0x200000
   \   0000035C   0x6168             STR      R0,[R5, #+20]
   \   0000035E   0x6968             LDR      R0,[R5, #+20]
   \   00000360   0xF400 0x1000      AND      R0,R0,#0x200000
   \   00000364   0x9000             STR      R0,[SP, #+0]
   \   00000366   0x9800             LDR      R0,[SP, #+0]
   \   00000368   0x6828             LDR      R0,[R5, #+0]
   \   0000036A   0xF040 0x0040      ORR      R0,R0,#0x40
   \   0000036E   0x6028             STR      R0,[R5, #+0]
   \   00000370   0x6828             LDR      R0,[R5, #+0]
   \   00000372   0xF000 0x0040      AND      R0,R0,#0x40
   \   00000376   0x9000             STR      R0,[SP, #+0]
   \   00000378   0x9800             LDR      R0,[SP, #+0]
   \   0000037A   0xF44F 0x40C0      MOV      R0,#+24576
   \   0000037E   0x9001             STR      R0,[SP, #+4]
   \   00000380   0x2002             MOVS     R0,#+2
   \   00000382   0x9002             STR      R0,[SP, #+8]
   \   00000384   0x2000             MOVS     R0,#+0
   \   00000386   0x9003             STR      R0,[SP, #+12]
   \   00000388   0x2003             MOVS     R0,#+3
   \   0000038A   0x9004             STR      R0,[SP, #+16]
   \   0000038C   0x2005             MOVS     R0,#+5
   \   0000038E   0x9005             STR      R0,[SP, #+20]
   \   00000390   0x.... 0x....      LDR.W    R0,??DataTable17_14  ;; 0x40021800
   \   00000394   0x.... 0x....      BL       HAL_GPIO_Init
   \   00000398   0x6828             LDR      R0,[R5, #+0]
   \   0000039A   0xF440 0x0080      ORR      R0,R0,#0x400000
   \   0000039E   0x6028             STR      R0,[R5, #+0]
   \   000003A0   0x6828             LDR      R0,[R5, #+0]
   \   000003A2   0x.... 0x....      LDR.W    R5,??DataTable17_13
   \   000003A6   0xF400 0x0080      AND      R0,R0,#0x400000
   \   000003AA   0x9000             STR      R0,[SP, #+0]
   \   000003AC   0x9800             LDR      R0,[SP, #+0]
   \   000003AE   0x.... 0x....      LDR.W    R0,??DataTable17_11  ;; 0x400260b8
   \   000003B2   0xF500 0x707A      ADD      R0,R0,#+1000
   \   000003B6   0x6528             STR      R0,[R5, #+80]
   \   000003B8   0xF04F 0x7000      MOV      R0,#+33554432
   \   000003BC   0x6568             STR      R0,[R5, #+84]
   \   000003BE   0x2000             MOVS     R0,#+0
   \   000003C0   0x65A8             STR      R0,[R5, #+88]
   \   000003C2   0x65E8             STR      R0,[R5, #+92]
   \   000003C4   0xF44F 0x6080      MOV      R0,#+1024
   \   000003C8   0x6628             STR      R0,[R5, #+96]
   \   000003CA   0xF44F 0x6000      MOV      R0,#+2048
   \   000003CE   0x6668             STR      R0,[R5, #+100]
   \   000003D0   0x66A8             STR      R0,[R5, #+104]
   \   000003D2   0x2000             MOVS     R0,#+0
   \   000003D4   0x66E8             STR      R0,[R5, #+108]
   \   000003D6   0xF44F 0x3000      MOV      R0,#+131072
   \   000003DA   0x6728             STR      R0,[R5, #+112]
   \   000003DC   0x2000             MOVS     R0,#+0
   \   000003DE   0x6768             STR      R0,[R5, #+116]
   \   000003E0   0x2003             MOVS     R0,#+3
   \   000003E2   0x67A8             STR      R0,[R5, #+120]
   \   000003E4   0x2000             MOVS     R0,#+0
   \   000003E6   0x67E8             STR      R0,[R5, #+124]
   \   000003E8   0xF8C5 0x0080      STR      R0,[R5, #+128]
   \   000003EC   0xF105 0x0050      ADD      R0,R5,#+80
   \   000003F0   0x.... 0x....      BL       HAL_DMA_Init
   \   000003F4   0xF105 0x0050      ADD      R0,R5,#+80
   \   000003F8   0x2200             MOVS     R2,#+0
   \   000003FA   0x65A0             STR      R0,[R4, #+88]
   \   000003FC   0x2104             MOVS     R1,#+4
   \   000003FE   0xF8C5 0x4088      STR      R4,[R5, #+136]
   \   00000402   0x2045             MOVS     R0,#+69
   \   00000404   0x.... 0x....      BL       HAL_NVIC_SetPriority
   \   00000408   0x2045             MOVS     R0,#+69
   \                     ??HAL_SPI_MspInit_1: (+1)
   \   0000040A   0x.... 0x....      BL       HAL_NVIC_EnableIRQ
   \                     ??HAL_SPI_MspInit_6: (+1)
   \   0000040E   0xB007             ADD      SP,SP,#+28
   \   00000410   0xBD30             POP      {R4,R5,PC}       ;; return
   1308          
   1309          
   1310          
   1311          
   1312          static void SPI_I2S_SendData(SPI_TypeDef* SPIx, uint16_t Data)
   1313          {
   1314            /* Check the parameters */
   1315            assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
   1316            
   1317            /* Write in the DR register the data to be sent */
   1318            SPIx->DR = Data;
   1319          }
   1320          
   1321          
   1322          static uint16_t SPI_I2S_ReceiveData(SPI_TypeDef* SPIx)
   1323          {
   1324            /* Check the parameters */
   1325            assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
   1326            
   1327            /* Return the data in the DR register */
   1328            return SPIx->DR;
   1329          }
   1330          
   1331          

   \                                 In section .text, align 2, keep-with-next
   1332          void RecordUpdBuf(void)
   1333          {
   1334          
   1335               if (WaveRecord_flgInt==2)
   \                     RecordUpdBuf: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable15_3
   \   00000002   0x7801             LDRB     R1,[R0, #+0]
   \   00000004   0x2902             CMP      R1,#+2
   \   00000006   0xD16F             BNE.N    ??RecordUpdBuf_0
   1336               {
   1337                  WaveRecord_flgInt=0;
   \   00000008   0x2100             MOVS     R1,#+0
   1338          			if ((WaveRec_idxSens1 < (AUDIO_OUT_BUFFER_SIZE))&&(WaveRec_idxSens2 < (AUDIO_OUT_BUFFER_SIZE)))
   \   0000000A   0x....             LDR.N    R2,??DataTable15_4
   \   0000000C   0x7001             STRB     R1,[R0, #+0]
   \   0000000E   0x8811             LDRH     R1,[R2, #+0]
   \   00000010   0xF5B1 0x6F80      CMP      R1,#+1024
   \   00000014   0xBFBE             ITTT     LT 
   \   00000016   0x....             LDRLT.N  R1,??DataTable15_5
   \   00000018   0x880B             LDRHLT   R3,[R1, #+0]
   \   0000001A   0xF5B3 0x6F80      CMPLT    R3,#+1024
   \   0000001E   0xDA63             BGE.N    ??RecordUpdBuf_0
   1339          		//			  &&(stLR!=stLROld))
   1340          			{
   1341          		/*-------------------------------------------------------------------------------------------------------------
   1342          					  
   1343          			Sequence  Record Data					  Processing Data				  Player Data
   1344          					  
   1345          			1-------  Buffer1						  Buffer2						  Buffer3 BUF3_PLAY)
   1346          					  
   1347          			2-------  Buffer3						  Buffer1						  Buffer2 (BUF2_PLAY)		  
   1348          					  
   1349          			3-------  Buffer2						  Buffer3						  Buffer1 (BUF1_PLAY)
   1350          		 ---------------------------------------------------------------------------------------------------------------*/
   1351          					  /* Recording Audio Data */						 
   1352          					   switch (buffer_switch)
   \   00000020   0x....             LDR.N    R3,??DataTable15_6
   \   00000022   0x781B             LDRB     R3,[R3, #+0]
   \   00000024   0xB11B             CBZ.N    R3,??RecordUpdBuf_1
   \   00000026   0x2B02             CMP      R3,#+2
   \   00000028   0xD00F             BEQ.N    ??RecordUpdBuf_2
   \   0000002A   0xD307             BCC.N    ??RecordUpdBuf_3
   \   0000002C   0x4770             BX       LR
   1353          					   {
   1354          								case BUF1_PLAY:
   1355          
   1356          										Buffer2.bufMIC1[WaveRec_idxSens1++] = vRawSens1;
   \                     ??RecordUpdBuf_1: (+1)
   \   0000002E   0x8813             LDRH     R3,[R2, #+0]
   \   00000030   0xF103 0x0C01      ADD      R12,R3,#+1
   \   00000034   0xF8A2 0xC000      STRH     R12,[R2, #+0]
   \   00000038   0x....             LDR.N    R2,??DataTable15_7  ;; 0xc00080a0
   \   0000003A   0xE00D             B.N      ??RecordUpdBuf_4
   1357          										Buffer2.bufMIC2[WaveRec_idxSens2++] = vRawSens2;
   1358          										Buffer2.bufMIC3[WaveRec_idxSens3++] = vRawSens3;
   1359          										Buffer2.bufMIC4[WaveRec_idxSens4++] = vRawSens4;
   1360          										Buffer2.bufMIC5[WaveRec_idxSens5++] = vRawSens5;
   1361          										Buffer2.bufMIC6[WaveRec_idxSens6++] = vRawSens6;
   1362          	
   1363          										break;
   1364          								case BUF2_PLAY:
   1365          
   1366          										Buffer3.bufMIC1[WaveRec_idxSens1++] = vRawSens1;
   \                     ??RecordUpdBuf_3: (+1)
   \   0000003C   0x8813             LDRH     R3,[R2, #+0]
   \   0000003E   0xF103 0x0C01      ADD      R12,R3,#+1
   \   00000042   0xF8A2 0xC000      STRH     R12,[R2, #+0]
   \   00000046   0x....             LDR.N    R2,??DataTable15_8  ;; 0xc0010140
   \   00000048   0xE006             B.N      ??RecordUpdBuf_4
   1367          										Buffer3.bufMIC2[WaveRec_idxSens2++] = vRawSens2;
   1368          										Buffer3.bufMIC3[WaveRec_idxSens3++] = vRawSens3;
   1369          										Buffer3.bufMIC4[WaveRec_idxSens4++] = vRawSens4;
   1370          										Buffer3.bufMIC5[WaveRec_idxSens5++] = vRawSens5;
   1371          										Buffer3.bufMIC6[WaveRec_idxSens6++] = vRawSens6;
   1372          		
   1373          
   1374          										break;
   1375          								case BUF3_PLAY:
   1376          
   1377          										Buffer1.bufMIC1[WaveRec_idxSens1++] = vRawSens1;
   \                     ??RecordUpdBuf_2: (+1)
   \   0000004A   0x8813             LDRH     R3,[R2, #+0]
   \   0000004C   0xF103 0x0C01      ADD      R12,R3,#+1
   \   00000050   0xF8A2 0xC000      STRH     R12,[R2, #+0]
   \   00000054   0xF04F 0x4240      MOV      R2,#-1073741824
   \                     ??RecordUpdBuf_4: (+1)
   \   00000058   0xF9B0 0xC006      LDRSH    R12,[R0, #+6]
   \   0000005C   0xF822 0xC013      STRH     R12,[R2, R3, LSL #+1]
   1378          										Buffer1.bufMIC2[ WaveRec_idxSens2++] = vRawSens2;
   \   00000060   0x880B             LDRH     R3,[R1, #+0]
   \   00000062   0xF103 0x0C01      ADD      R12,R3,#+1
   \   00000066   0xEB02 0x0343      ADD      R3,R2,R3, LSL #+1
   \   0000006A   0xF8A1 0xC000      STRH     R12,[R1, #+0]
   \   0000006E   0xF9B0 0x1008      LDRSH    R1,[R0, #+8]
   \   00000072   0xF241 0x0C14      MOVW     R12,#+4116
   \   00000076   0xF82C 0x1003      STRH     R1,[R12, R3]
   1379          										Buffer1.bufMIC3[WaveRec_idxSens3++] = vRawSens3;
   \   0000007A   0x....             LDR.N    R1,??DataTable15_11
   \   0000007C   0x880B             LDRH     R3,[R1, #+0]
   \   0000007E   0xF103 0x0C01      ADD      R12,R3,#+1
   \   00000082   0xEB02 0x0343      ADD      R3,R2,R3, LSL #+1
   \   00000086   0xF8A1 0xC000      STRH     R12,[R1, #+0]
   \   0000008A   0xF9B0 0x100C      LDRSH    R1,[R0, #+12]
   \   0000008E   0xF242 0x0C28      MOVW     R12,#+8232
   \   00000092   0xF82C 0x1003      STRH     R1,[R12, R3]
   1380          										Buffer1.bufMIC4[ WaveRec_idxSens4++] = vRawSens4;
   \   00000096   0x....             LDR.N    R1,??DataTable15_12
   \   00000098   0x880B             LDRH     R3,[R1, #+0]
   \   0000009A   0xF103 0x0C01      ADD      R12,R3,#+1
   \   0000009E   0xEB02 0x0343      ADD      R3,R2,R3, LSL #+1
   \   000000A2   0xF8A1 0xC000      STRH     R12,[R1, #+0]
   \   000000A6   0xF9B0 0x100A      LDRSH    R1,[R0, #+10]
   \   000000AA   0xF243 0x0C3C      MOVW     R12,#+12348
   \   000000AE   0xF82C 0x1003      STRH     R1,[R12, R3]
   1381          										Buffer1.bufMIC5[WaveRec_idxSens5++] = vRawSens5;
   \   000000B2   0x....             LDR.N    R1,??DataTable15_15
   \   000000B4   0x880B             LDRH     R3,[R1, #+0]
   \   000000B6   0xF103 0x0C01      ADD      R12,R3,#+1
   \   000000BA   0xEB02 0x0343      ADD      R3,R2,R3, LSL #+1
   \   000000BE   0xF8A1 0xC000      STRH     R12,[R1, #+0]
   \   000000C2   0xF9B0 0x100E      LDRSH    R1,[R0, #+14]
   \   000000C6   0xF244 0x0C50      MOVW     R12,#+16464
   \   000000CA   0xF82C 0x1003      STRH     R1,[R12, R3]
   1382          										Buffer1.bufMIC6[ WaveRec_idxSens6++] = vRawSens6;
   \   000000CE   0x....             LDR.N    R1,??DataTable16
   \   000000D0   0x880B             LDRH     R3,[R1, #+0]
   \   000000D2   0xF103 0x0C01      ADD      R12,R3,#+1
   \   000000D6   0xF8A1 0xC000      STRH     R12,[R1, #+0]
   \   000000DA   0xF9B0 0x0010      LDRSH    R0,[R0, #+16]
   \   000000DE   0xEB02 0x0143      ADD      R1,R2,R3, LSL #+1
   \   000000E2   0xF245 0x0264      MOVW     R2,#+20580
   \   000000E6   0x5250             STRH     R0,[R2, R1]
   1383          										break;
   1384          								default:
   1385          										break; 
   1386          					   }
   1387          				
   1388          				}
   1389                               
   1390               	}
   1391          }
   \                     ??RecordUpdBuf_0: (+1)
   \   000000E8   0x4770             BX       LR               ;; return
   \   000000EA                      REQUIRE Buffer2
   \   000000EA                      REQUIRE Buffer3
   \   000000EA                      REQUIRE Buffer1
   1392          
   1393          

   \                                 In section .text, align 2, keep-with-next
   1394          void DMA2_Stream5_IRQHandler(void)
   1395          {
   1396            /* USER CODE BEGIN DMA2_Stream5_IRQn 0 */
   1397          
   1398            /* USER CODE END DMA2_Stream5_IRQn 0 */
   1399            HAL_DMA_IRQHandler(&hdma_spi5_rx);
   \                     DMA2_Stream5_IRQHandler: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable17_13
   \   00000004   0x.... 0x....      B.W      HAL_DMA_IRQHandler
   1400            /* USER CODE BEGIN DMA2_Stream5_IRQn 1 */
   1401          
   1402            /* USER CODE END DMA2_Stream5_IRQn 1 */
   1403          }
   1404          
   1405          /**
   1406          * @brief This function handles DMA2 stream6 global interrupt.
   1407          */

   \                                 In section .text, align 2, keep-with-next
   1408          void DMA2_Stream6_IRQHandler(void)
   1409          {
   1410            /* USER CODE BEGIN DMA2_Stream6_IRQn 0 */
   1411          
   1412            /* USER CODE END DMA2_Stream6_IRQn 0 */
   1413            HAL_DMA_IRQHandler(&hdma_spi6_rx);
   \                     DMA2_Stream6_IRQHandler: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable17_15
   \   00000004   0x.... 0x....      B.W      HAL_DMA_IRQHandler
   1414            /* USER CODE BEGIN DMA2_Stream6_IRQn 1 */
   1415          
   1416            /* USER CODE END DMA2_Stream6_IRQn 1 */
   1417          }
   1418          

   \                                 In section .text, align 4, keep-with-next
   1419          void HAL_SPI_RxCpltCallback(SPI_HandleTypeDef *hspi)
   1420          {
   \                     HAL_SPI_RxCpltCallback: (+1)
   \   00000000   0xE92D 0x43F0      PUSH     {R4-R9,LR}
   \   00000004   0x4680             MOV      R8,R0
   \   00000006   0xB081             SUB      SP,SP,#+4
   1421              if(hspi->Instance==SPI1)
   \   00000008   0x....             LDR.N    R1,??DataTable16_3  ;; 0x40013000
   \   0000000A   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \   0000000E   0x4288             CMP      R0,R1
   \   00000010   0xBF1F             ITTTT    NE 
   \   00000012   0x.... 0x....      LDRNE.W  R1,??DataTable17_1  ;; 0x40003800
   \   00000016   0x4288             CMPNE    R0,R1
   \   00000018   0x.... 0x....      LDRNE.W  R1,??DataTable17_4  ;; 0x40013400
   \   0000001C   0x4288             CMPNE    R0,R1
   1422              {
   1423                  /* Copy Data to Record Buffer */
   1424          		//RecordUpdBuf();
   1425          		//XferCplt = 1;
   1426                  //Audio_Play_Out();
   1427              }
   1428          	else if (hspi->Instance==SPI2)
   1429          	{
   1430          
   1431          	}
   1432          	else if (hspi->Instance==SPI4)
   \   0000001E   0xF000 0x8121      BEQ.W    ??HAL_SPI_RxCpltCallback_0
   1433              {
   1434          
   1435          	}
   1436          	else if (hspi->Instance==SPI5)
   \   00000022   0x.... 0x....      LDR.W    R1,??DataTable17_6  ;; 0x40015000
   \   00000026   0x4288             CMP      R0,R1
   \   00000028   0xD117             BNE.N    ??HAL_SPI_RxCpltCallback_1
   1437              {
   1438                  swtSDO7^=0x01;
   \   0000002A   0x.... 0x....      LDR.W    R9,??DataTable17_16
   1439          		WaveRecord_flgSDO7Finish = 1;
   1440          		if (swtSDO7==0x01)
   \   0000002E   0xF44F 0x5280      MOV      R2,#+4096
   \   00000032   0xF899 0x01B0      LDRB     R0,[R9, #+432]
   \   00000036   0xF080 0x0001      EOR      R0,R0,#0x1
   \   0000003A   0xF889 0x01B0      STRB     R0,[R9, #+432]
   \   0000003E   0x2001             MOVS     R0,#+1
   \   00000040   0xF889 0x01B2      STRB     R0,[R9, #+434]
   \   00000044   0xF899 0x01B0      LDRB     R0,[R9, #+432]
   \   00000048   0x2801             CMP      R0,#+1
   1441          		{
   1442          		    HAL_SPI_Receive_DMA(&hspi5,( uint8_t *)TestSDO7_1,4*AUDIO_OUT_BUFFER_SIZE);
   1443          		}
   1444          	    else
   1445          	    {
   1446          			HAL_SPI_Receive_DMA(&hspi5,( uint8_t *)TestSDO7,4*AUDIO_OUT_BUFFER_SIZE);
   \   0000004A   0x4648             MOV      R0,R9
   \   0000004C   0xBF0C             ITE      EQ 
   \   0000004E   0x.... 0x....      LDREQ.W  R1,??DataTable17_17
   \   00000052   0x.... 0x....      LDRNE.W  R1,??DataTable17_2
   \   00000056   0x.... 0x....      BL       HAL_SPI_Receive_DMA
   1447          
   1448          	    }
   1449          
   1450          	}
   1451          	else
   1452                  {
   1453                    
   1454                  }
   1455              
   1456              if (hspi->Instance==SPI6)
   \                     ??HAL_SPI_RxCpltCallback_1: (+1)
   \   0000005A   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \   0000005E   0x.... 0x....      LDR.W    R1,??DataTable17_5  ;; 0x40015400
   \   00000062   0x4288             CMP      R0,R1
   \   00000064   0xF040 0x80FE      BNE.W    ??HAL_SPI_RxCpltCallback_0
   1457              {
   1458          #if USB_STREAMING
   1459             /* Swapping bytes to prepare to PDM conversion */
   1460             for (uint16_t i=0; i< 4*(AUDIO_SAMPLING_FREQUENCY/1000);i++)
   \   00000068   0x.... 0x....      LDR.W    R8,??DataTable17_3
   \   0000006C   0x2000             MOVS     R0,#+0
   \   0000006E   0x4641             MOV      R1,R8
   \   00000070   0x.... 0x....      LDR.W    R9,??DataTable17_16
   1461             {
   1462                 pDataMic8[i%64] = HTONS(TestSDO8[i]);     		
                        ^
Warning[Pa082]: undefined behavior: the order of volatile accesses is
          undefined in this statement
   \                     ??HAL_SPI_RxCpltCallback_2: (+1)
   \   00000074   0x1146             ASRS     R6,R0,#+5
   \   00000076   0x880A             LDRH     R2,[R1, #+0]
   \   00000078   0xEB00 0x6696      ADD      R6,R0,R6, LSR #+26
   \   0000007C   0xF831 0x3B02      LDRH     R3,[R1], #+2
   \   00000080   0x11B6             ASRS     R6,R6,#+6
   \   00000082   0xEBA0 0x1686      SUB      R6,R0,R6, LSL #+6
   1463             }
   \   00000086   0x1C40             ADDS     R0,R0,#+1
   \   00000088   0x021B             LSLS     R3,R3,#+8
   \   0000008A   0x2840             CMP      R0,#+64
   \   0000008C   0xEB09 0x0646      ADD      R6,R9,R6, LSL #+1
   \   00000090   0xEA43 0x2212      ORR      R2,R3,R2, LSR #+8
   \   00000094   0xF8A6 0x21C8      STRH     R2,[R6, #+456]
   \   00000098   0xDBEC             BLT.N    ??HAL_SPI_RxCpltCallback_2
   1464             
   1465              /* PDM conversion for frame of 64 inputs, 16 outputs */
   1466              /* Recording Audio Data */						 
   1467              switch (buffer_switch)
   \   0000009A   0x.... 0x....      LDR.W    R6,??DataTable17_18
   \   0000009E   0x7830             LDRB     R0,[R6, #+0]
   \   000000A0   0xB118             CBZ.N    R0,??HAL_SPI_RxCpltCallback_3
   \   000000A2   0x2802             CMP      R0,#+2
   \   000000A4   0xD015             BEQ.N    ??HAL_SPI_RxCpltCallback_4
   \   000000A6   0xD30A             BCC.N    ??HAL_SPI_RxCpltCallback_5
   \   000000A8   0xE022             B.N      ??HAL_SPI_RxCpltCallback_6
   1468              {
   1469                  case BUF1_PLAY: 							
   1470                          PDM_Filter_64_LSB((uint8_t *)pDataMic8,(uint16_t *)(Buffer2.bufMIC8 + idxFrmPDMMic8*32), 64 ,
   1471                          (PDMFilter_InitStruct *)&Filter[1]);
   \                     ??HAL_SPI_RxCpltCallback_3: (+1)
   \   000000AA   0xF8B9 0x11B8      LDRH     R1,[R9, #+440]
   \   000000AE   0x.... 0x....      LDR.W    R0,??DataTable17_19  ;; 0xc00080a0
   \   000000B2   0xF509 0x73BE      ADD      R3,R9,#+380
   \   000000B6   0x2240             MOVS     R2,#+64
   \   000000B8   0xEB00 0x1081      ADD      R0,R0,R1, LSL #+6
   \   000000BC   0xE011             B.N      ??HAL_SPI_RxCpltCallback_7
   1472                          break;
   1473                  case BUF2_PLAY:
   1474                          PDM_Filter_64_LSB((uint8_t *)pDataMic8,(uint16_t *)(Buffer3.bufMIC8 + idxFrmPDMMic8*32), 64 ,
   1475                          (PDMFilter_InitStruct *)&Filter[1]);	
   \                     ??HAL_SPI_RxCpltCallback_5: (+1)
   \   000000BE   0xF8B9 0x11B8      LDRH     R1,[R9, #+440]
   \   000000C2   0x.... 0x....      LDR.W    R0,??DataTable17_20  ;; 0xc0010140
   \   000000C6   0xF509 0x73BE      ADD      R3,R9,#+380
   \   000000CA   0x2240             MOVS     R2,#+64
   \   000000CC   0xEB00 0x1081      ADD      R0,R0,R1, LSL #+6
   \   000000D0   0xE007             B.N      ??HAL_SPI_RxCpltCallback_7
   1476                          break;
   1477                  case BUF3_PLAY:
   1478                          PDM_Filter_64_LSB((uint8_t *)pDataMic8,(uint16_t *)(Buffer1.bufMIC8 + idxFrmPDMMic8*32), 64 ,
   1479                          (PDMFilter_InitStruct *)&Filter[1]);									
   \                     ??HAL_SPI_RxCpltCallback_4: (+1)
   \   000000D2   0xF8B9 0x01B8      LDRH     R0,[R9, #+440]
   \   000000D6   0xF509 0x73BE      ADD      R3,R9,#+380
   \   000000DA   0x2240             MOVS     R2,#+64
   \   000000DC   0x0180             LSLS     R0,R0,#+6
   \   000000DE   0xF1A0 0x4080      SUB      R0,R0,#+1073741824
   \                     ??HAL_SPI_RxCpltCallback_7: (+1)
   \   000000E2   0xF500 0x41E0      ADD      R1,R0,#+28672
   \   000000E6   0x318C             ADDS     R1,R1,#+140
   \   000000E8   0xF509 0x70E4      ADD      R0,R9,#+456
   \   000000EC   0x.... 0x....      BL       PDM_Filter_64_LSB
   1480                           break;
   1481                  default:
   1482                           break; 
   1483              }
   1484          
   1485             
   1486              /* Update for left-right channel */
   1487              for (int16_t i=31; i>=0; i=i-2)
   \                     ??HAL_SPI_RxCpltCallback_6: (+1)
   \   000000F0   0xF05F 0x001F      MOVS.W   R0,#+31
   \   000000F4   0xF247 0x018A      MOVW     R1,#+28810
   \   000000F8   0x.... 0x....      LDR.W    R2,??DataTable17_19  ;; 0xc00080a0
   \   000000FC   0x.... 0x....      LDR.W    R3,??DataTable17_20  ;; 0xc0010140
   \   00000100   0xF247 0x078C      MOVW     R7,#+28812
   \   00000104   0xF04F 0x4C40      MOV      R12,#-1073741824
   1488              {
   1489                /* Recording Audio Data */						
   1490                switch (buffer_switch)
   \                     ??HAL_SPI_RxCpltCallback_8: (+1)
   \   00000108   0xF896 0xE000      LDRB     LR,[R6, #+0]
   \   0000010C   0xF1BE 0x0F00      CMP      LR,#+0
   \   00000110   0xD004             BEQ.N    ??HAL_SPI_RxCpltCallback_9
   \   00000112   0xF1BE 0x0F02      CMP      LR,#+2
   \   00000116   0xD03F             BEQ.N    ??HAL_SPI_RxCpltCallback_10
   \   00000118   0xD31F             BCC.N    ??HAL_SPI_RxCpltCallback_11
   \   0000011A   0xE05F             B.N      ??HAL_SPI_RxCpltCallback_12
   1491                {
   1492                   case BUF1_PLAY:							   
   1493                     Buffer2.bufMIC8[idxFrmPDMMic8*32+i]  = Buffer2.bufMIC8[idxFrmPDMMic8*32+i/2];
                            ^
Warning[Pa082]: undefined behavior: the order of volatile accesses is
          undefined in this statement
   \                     ??HAL_SPI_RxCpltCallback_9: (+1)
   \   0000011C   0xEB00 0x7ED0      ADD      LR,R0,R0, LSR #+31
   \   00000120   0xF8B9 0x41B8      LDRH     R4,[R9, #+440]
   \   00000124   0xF8B9 0x51B8      LDRH     R5,[R9, #+440]
   \   00000128   0xEA4F 0x0E6E      ASR      LR,LR,#+1
   \   0000012C   0xEB00 0x1444      ADD      R4,R0,R4, LSL #+5
   \   00000130   0xEB0E 0x1545      ADD      R5,LR,R5, LSL #+5
   \   00000134   0xEB02 0x0444      ADD      R4,R2,R4, LSL #+1
   \   00000138   0xEB02 0x0545      ADD      R5,R2,R5, LSL #+1
   \   0000013C   0x5B7D             LDRH     R5,[R7, R5]
   \   0000013E   0x533D             STRH     R5,[R7, R4]
   1494                     Buffer2.bufMIC8[idxFrmPDMMic8*32+i-1]= Buffer2.bufMIC8[idxFrmPDMMic8*32+i/2];
                            ^
Warning[Pa082]: undefined behavior: the order of volatile accesses is
          undefined in this statement
   \   00000140   0xF8B9 0x41B8      LDRH     R4,[R9, #+440]
   \   00000144   0xF8B9 0x51B8      LDRH     R5,[R9, #+440]
   \   00000148   0xEB00 0x1444      ADD      R4,R0,R4, LSL #+5
   \   0000014C   0xEB0E 0x1E45      ADD      LR,LR,R5, LSL #+5
   \   00000150   0xEB02 0x0444      ADD      R4,R2,R4, LSL #+1
   \   00000154   0xEB02 0x0E4E      ADD      LR,R2,LR, LSL #+1
   \   00000158   0xE03C             B.N      ??HAL_SPI_RxCpltCallback_13
   1495                     break;
   1496                   case BUF2_PLAY:
   1497                     Buffer3.bufMIC8[idxFrmPDMMic8*32+i]  = Buffer3.bufMIC8[idxFrmPDMMic8*32+i/2];
                            ^
Warning[Pa082]: undefined behavior: the order of volatile accesses is
          undefined in this statement
   \                     ??HAL_SPI_RxCpltCallback_11: (+1)
   \   0000015A   0xEB00 0x7ED0      ADD      LR,R0,R0, LSR #+31
   \   0000015E   0xF8B9 0x41B8      LDRH     R4,[R9, #+440]
   \   00000162   0xF8B9 0x51B8      LDRH     R5,[R9, #+440]
   \   00000166   0xEA4F 0x0E6E      ASR      LR,LR,#+1
   \   0000016A   0xEB00 0x1444      ADD      R4,R0,R4, LSL #+5
   \   0000016E   0xEB0E 0x1545      ADD      R5,LR,R5, LSL #+5
   \   00000172   0xEB03 0x0444      ADD      R4,R3,R4, LSL #+1
   \   00000176   0xEB03 0x0545      ADD      R5,R3,R5, LSL #+1
   \   0000017A   0x5B7D             LDRH     R5,[R7, R5]
   \   0000017C   0x533D             STRH     R5,[R7, R4]
   1498                     Buffer3.bufMIC8[idxFrmPDMMic8*32+i-1]= Buffer3.bufMIC8[idxFrmPDMMic8*32+i/2]; 
                            ^
Warning[Pa082]: undefined behavior: the order of volatile accesses is
          undefined in this statement
   \   0000017E   0xF8B9 0x41B8      LDRH     R4,[R9, #+440]
   \   00000182   0xF8B9 0x51B8      LDRH     R5,[R9, #+440]
   \   00000186   0xEB00 0x1444      ADD      R4,R0,R4, LSL #+5
   \   0000018A   0xEB0E 0x1E45      ADD      LR,LR,R5, LSL #+5
   \   0000018E   0xEB03 0x0444      ADD      R4,R3,R4, LSL #+1
   \   00000192   0xEB03 0x0E4E      ADD      LR,R3,LR, LSL #+1
   \   00000196   0xE01D             B.N      ??HAL_SPI_RxCpltCallback_13
   1499                     break;
   1500                   case BUF3_PLAY:
   1501                     Buffer1.bufMIC8[idxFrmPDMMic8*32+i]  = Buffer1.bufMIC8[idxFrmPDMMic8*32+i/2];
                            ^
Warning[Pa082]: undefined behavior: the order of volatile accesses is
          undefined in this statement
   \                     ??HAL_SPI_RxCpltCallback_10: (+1)
   \   00000198   0xEB00 0x7ED0      ADD      LR,R0,R0, LSR #+31
   \   0000019C   0xF8B9 0x41B8      LDRH     R4,[R9, #+440]
   \   000001A0   0xF8B9 0x51B8      LDRH     R5,[R9, #+440]
   \   000001A4   0xEA4F 0x0E6E      ASR      LR,LR,#+1
   \   000001A8   0xEB00 0x1444      ADD      R4,R0,R4, LSL #+5
   \   000001AC   0xEB0E 0x1545      ADD      R5,LR,R5, LSL #+5
   \   000001B0   0xEB0C 0x0444      ADD      R4,R12,R4, LSL #+1
   \   000001B4   0xEB0C 0x0545      ADD      R5,R12,R5, LSL #+1
   \   000001B8   0x5B7D             LDRH     R5,[R7, R5]
   \   000001BA   0x533D             STRH     R5,[R7, R4]
   1502                     Buffer1.bufMIC8[idxFrmPDMMic8*32+i-1]= Buffer1.bufMIC8[idxFrmPDMMic8*32+i/2];
                            ^
Warning[Pa082]: undefined behavior: the order of volatile accesses is
          undefined in this statement
   \   000001BC   0xF8B9 0x41B8      LDRH     R4,[R9, #+440]
   \   000001C0   0xF8B9 0x51B8      LDRH     R5,[R9, #+440]
   \   000001C4   0xEB00 0x1444      ADD      R4,R0,R4, LSL #+5
   \   000001C8   0xEB0E 0x1E45      ADD      LR,LR,R5, LSL #+5
   \   000001CC   0xEB0C 0x0444      ADD      R4,R12,R4, LSL #+1
   \   000001D0   0xEB0C 0x0E4E      ADD      LR,R12,LR, LSL #+1
   \                     ??HAL_SPI_RxCpltCallback_13: (+1)
   \   000001D4   0xF837 0xE00E      LDRH     LR,[R7, LR]
   \   000001D8   0xF821 0xE004      STRH     LR,[R1, R4]
   1503                     break;
   1504                   default:
   1505                     break; 
   1506                }
   1507              }
   \                     ??HAL_SPI_RxCpltCallback_12: (+1)
   \   000001DC   0x1E80             SUBS     R0,R0,#+2
   \   000001DE   0xD593             BPL.N    ??HAL_SPI_RxCpltCallback_8
   1508             AudioProcess(idxFrmPDMMic8);
   \   000001E0   0xF8B9 0x01B8      LDRH     R0,[R9, #+440]
   \   000001E4   0x.... 0x....      BL       AudioProcess
   1509             idxFrmPDMMic8++;
   \   000001E8   0xF8B9 0x01B8      LDRH     R0,[R9, #+440]
   \   000001EC   0x1C40             ADDS     R0,R0,#+1
   \   000001EE   0xF8A9 0x01B8      STRH     R0,[R9, #+440]
   1510             if(idxFrmPDMMic8==(4*AUDIO_OUT_BUFFER_SIZE/64))
   \   000001F2   0xF8B9 0x01B8      LDRH     R0,[R9, #+440]
   \   000001F6   0x2840             CMP      R0,#+64
   \   000001F8   0xD12B             BNE.N    ??HAL_SPI_RxCpltCallback_14
   1511             {
   1512                 idxFrmPDMMic8 = 0;
   \   000001FA   0x2000             MOVS     R0,#+0
   1513          #ifndef CS43L22_PLAY	  
   1514                 RESET_IDX
   \   000001FC   0x....             LDR.N    R1,??DataTable17_21
   \   000001FE   0xF8A9 0x01B8      STRH     R0,[R9, #+440]
   \   00000202   0x8008             STRH     R0,[R1, #+0]
   \   00000204   0x....             LDR.N    R1,??DataTable17_22
   \   00000206   0x8008             STRH     R0,[R1, #+0]
   \   00000208   0x....             LDR.N    R1,??DataTable17_23
   \   0000020A   0x8008             STRH     R0,[R1, #+0]
   \   0000020C   0x....             LDR.N    R1,??DataTable17_24
   \   0000020E   0x8008             STRH     R0,[R1, #+0]
   \   00000210   0x....             LDR.N    R1,??DataTable17_25
   \   00000212   0x8008             STRH     R0,[R1, #+0]
   \   00000214   0x....             LDR.N    R1,??DataTable17_26
   \   00000216   0x8008             STRH     R0,[R1, #+0]
   \   00000218   0x....             LDR.N    R1,??DataTable17_27
   \   0000021A   0x8008             STRH     R0,[R1, #+0]
   \   0000021C   0x....             LDR.N    R1,??DataTable16
   \   0000021E   0x8008             STRH     R0,[R1, #+0]
   \   00000220   0x....             LDR.N    R1,??DataTable17_28
   \   00000222   0x7008             STRB     R0,[R1, #+0]
   1515                 XferCplt = 0; // clear DMA interrupt flag
   \   00000224   0x....             LDR.N    R1,??DataTable17_29
   \   00000226   0x6008             STR      R0,[R1, #+0]
   1516          
   1517          	   /*-------------------------------------------------------------------------------------------------------------		  
   1518          		Sequence  Record Data                     Processing Data                 Player Data
   1519          				  
   1520          		1-------  Buffer1                         Buffer2                          Buffer3
   1521          				  
   1522          		2-------  Buffer3                         Buffer1                           Buffer2		  
   1523          				  
   1524          		3-------  Buffer2                         Buffer3                           Buffer1 
   1525          	    ---------------------------------------------------------------------------------------------------------------*/
   1526          	    switch (buffer_switch)
   \   00000228   0x7830             LDRB     R0,[R6, #+0]
   \   0000022A   0xB118             CBZ.N    R0,??HAL_SPI_RxCpltCallback_15
   \   0000022C   0x2802             CMP      R0,#+2
   \   0000022E   0xD005             BEQ.N    ??HAL_SPI_RxCpltCallback_16
   \   00000230   0xD302             BCC.N    ??HAL_SPI_RxCpltCallback_17
   \   00000232   0xE005             B.N      ??HAL_SPI_RxCpltCallback_18
   1527          	    {
   1528          	      case BUF1_PLAY:
   1529          			/* set flag for switch buffer */		  
   1530          	        buffer_switch = BUF3_PLAY;
   \                     ??HAL_SPI_RxCpltCallback_15: (+1)
   \   00000234   0x2002             MOVS     R0,#+2
   \   00000236   0xE002             B.N      ??HAL_SPI_RxCpltCallback_19
   1531          
   1532          	        break;
   1533          	      case BUF2_PLAY:
   1534          			/* set flag for switch buffer */
   1535          	        buffer_switch = BUF1_PLAY;
   \                     ??HAL_SPI_RxCpltCallback_17: (+1)
   \   00000238   0x2000             MOVS     R0,#+0
   \   0000023A   0xE000             B.N      ??HAL_SPI_RxCpltCallback_19
   1536          	        
   1537          	        break;
   1538          	      case BUF3_PLAY:
   1539          	        /* set flag for switch buffer */		  
   1540          	        buffer_switch = BUF2_PLAY;
   \                     ??HAL_SPI_RxCpltCallback_16: (+1)
   \   0000023C   0x2001             MOVS     R0,#+1
   \                     ??HAL_SPI_RxCpltCallback_19: (+1)
   \   0000023E   0x7030             STRB     R0,[R6, #+0]
   1541          
   1542          	        break;
   1543          	      default:
   1544          	        break;
   1545          	    }
   1546          			   
   1547          
   1548          	  if (cntStrt<100) cntStrt++;
   \                     ??HAL_SPI_RxCpltCallback_18: (+1)
   \   00000240   0xF8B9 0x01BE      LDRH     R0,[R9, #+446]
   \   00000244   0x2864             CMP      R0,#+100
   \   00000246   0xDA04             BGE.N    ??HAL_SPI_RxCpltCallback_14
   \   00000248   0xF8B9 0x01BE      LDRH     R0,[R9, #+446]
   \   0000024C   0x1C40             ADDS     R0,R0,#+1
   \   0000024E   0xF8A9 0x01BE      STRH     R0,[R9, #+446]
   1549          #endif
   1550             }
   1551             
   1552             HAL_SPI_Receive_DMA(&hspi6,( uint8_t *)TestSDO8,4*(AUDIO_SAMPLING_FREQUENCY/1000));
   \                     ??HAL_SPI_RxCpltCallback_14: (+1)
   \   00000252   0x4641             MOV      R1,R8
   \   00000254   0xF109 0x0064      ADD      R0,R9,#+100
   \   00000258   0xB001             ADD      SP,SP,#+4
   \   0000025A   0x2240             MOVS     R2,#+64
   \   0000025C   0xE8BD 0x43F0      POP      {R4-R9,LR}
   \   00000260   0x.... 0x....      B.W      HAL_SPI_Receive_DMA
   1553          
   1554          
   1555          #else
   1556              swtSDO8^=0x01;
   1557              WaveRecord_flgSDO8Finish = 1;
   1558              if (swtSDO8==0x01)
   1559              {
   1560                  HAL_SPI_Receive_DMA(&hspi6,( uint8_t *)TestSDO8_1,4*AUDIO_OUT_BUFFER_SIZE);
   1561              }
   1562              else
   1563              {
   1564                  HAL_SPI_Receive_DMA(&hspi6,( uint8_t *)TestSDO8,4*AUDIO_OUT_BUFFER_SIZE);
   1565          
   1566              }
   1567          #endif
   1568          
   1569             }
   1570          
   1571          }
   \                     ??HAL_SPI_RxCpltCallback_0: (+1)
   \   00000264   0xB001             ADD      SP,SP,#+4
   \   00000266   0xE8BD 0x83F0      POP      {R4-R9,PC}       ;; return
   \   0000026A                      REQUIRE Buffer2
   \   0000026A                      REQUIRE Buffer3
   \   0000026A                      REQUIRE Buffer1
   1572          

   \                                 In section .text, align 4, keep-with-next
   1573          void PDM2PCMSDO78(void)
   1574          {
   \                     PDM2PCMSDO78: (+1)
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   1575          /*-------------------------------------------------------------------------------------------------------------
   1576          			  
   1577          	Sequence  Record Data					  Processing Data				  Player Data
   1578          			  
   1579          	1-------  Buffer1						  Buffer2						  Buffer3 BUF3_PLAY)
   1580          			  
   1581          	2-------  Buffer3						  Buffer1						  Buffer2 (BUF2_PLAY)		  
   1582          			  
   1583          	3-------  Buffer2						  Buffer3						  Buffer1 (BUF1_PLAY)
   1584           ---------------------------------------------------------------------------------------------------------------*/
   1585          
   1586              /* Data in Mic7 finished recording */
   1587              if (WaveRecord_flgSDO7Finish==1)
   \   00000004   0x.... 0x....      LDR.W    R11,??DataTable17_16
   \   00000008   0xB081             SUB      SP,SP,#+4
   \   0000000A   0xF89B 0x01B2      LDRB     R0,[R11, #+434]
   \   0000000E   0x2801             CMP      R0,#+1
   \   00000010   0xF040 0x8089      BNE.W    ??PDM2PCMSDO78_0
   1588              {
   1589                  WaveRecord_flgSDO7Finish=0;
   \   00000014   0x2000             MOVS     R0,#+0
   1590          
   1591          		for (uint16_t i=0; i< 4*AUDIO_OUT_BUFFER_SIZE;i++)
   \   00000016   0x2400             MOVS     R4,#+0
   \   00000018   0xF88B 0x01B2      STRB     R0,[R11, #+434]
   \   0000001C   0x....             LDR.N    R5,??DataTable17_2
   \   0000001E   0x....             LDR.N    R6,??DataTable17_17
   \   00000020   0x.... 0x....      LDR.W    R7,??DataTable17_19
   \   00000024   0x.... 0x....      LDR.W    R8,??DataTable17_20  ;; 0xc0010140
   \   00000028   0xF04F 0x4940      MOV      R9,#-1073741824
   \   0000002C   0x.... 0x....      LDR.W    R10,??DataTable17_18
   1592          		{
   1593                      if(swtSDO7==0x01)
   \                     ??PDM2PCMSDO78_1: (+1)
   \   00000030   0xF89B 0x01B0      LDRB     R0,[R11, #+432]
   \   00000034   0x2801             CMP      R0,#+1
   \   00000036   0xBF07             ITTEE    EQ 
   \   00000038   0x8828             LDRHEQ   R0,[R5, #+0]
   \   0000003A   0x8829             LDRHEQ   R1,[R5, #+0]
   \   0000003C   0x8830             LDRHNE   R0,[R6, #+0]
   \   0000003E   0x8831             LDRHNE   R1,[R6, #+0]
   1594                      {
   1595                        pDataMic7[i%64] =	HTONS(TestSDO7[i]);
                               ^
Warning[Pa082]: undefined behavior: the order of volatile accesses is
          undefined in this statement
   1596                      }
   1597          			else
   1598          			{
   1599          			   pDataMic7[i%64] = HTONS(TestSDO7_1[i]);
                 			   ^
Warning[Pa082]: undefined behavior: the order of volatile accesses is
          undefined in this statement
   \   00000040   0x1162             ASRS     R2,R4,#+5
   \   00000042   0x0209             LSLS     R1,R1,#+8
   \   00000044   0xEB04 0x6292      ADD      R2,R4,R2, LSR #+26
   \   00000048   0xEA41 0x2010      ORR      R0,R1,R0, LSR #+8
   \   0000004C   0x1192             ASRS     R2,R2,#+6
   \   0000004E   0xEBA4 0x1282      SUB      R2,R4,R2, LSL #+6
   \   00000052   0xEB0B 0x0242      ADD      R2,R11,R2, LSL #+1
   \   00000056   0xF8A2 0x0248      STRH     R0,[R2, #+584]
   1600          
   1601          			}
   1602          
   1603          			/* PDM conversion for frame of 64 inputs, 16 outputs */
   1604          			if (i%64==63)
   \   0000005A   0x1160             ASRS     R0,R4,#+5
   \   0000005C   0xEB04 0x6090      ADD      R0,R4,R0, LSR #+26
   \   00000060   0x1180             ASRS     R0,R0,#+6
   \   00000062   0xEBA4 0x1180      SUB      R1,R4,R0, LSL #+6
   \   00000066   0x293F             CMP      R1,#+63
   \   00000068   0xD11E             BNE.N    ??PDM2PCMSDO78_2
   1605          			{
   1606          				/* Recording Audio Data */						 
   1607          				switch (buffer_switch)
   \   0000006A   0xF89A 0x1000      LDRB     R1,[R10, #+0]
   \   0000006E   0xB119             CBZ.N    R1,??PDM2PCMSDO78_3
   \   00000070   0x2902             CMP      R1,#+2
   \   00000072   0xD00D             BEQ.N    ??PDM2PCMSDO78_4
   \   00000074   0xD306             BCC.N    ??PDM2PCMSDO78_5
   \   00000076   0xE017             B.N      ??PDM2PCMSDO78_2
   1608          				{
   1609          					case BUF1_PLAY:								
   1610          						PDM_Filter_64_LSB((uint8_t *)pDataMic7,(uint16_t *)(Buffer2.bufMIC7 + (i/64)*16), 64 ,
   1611          						(PDMFilter_InitStruct *)&Filter[0]);
   \                     ??PDM2PCMSDO78_3: (+1)
   \   00000078   0xF50B 0x73A4      ADD      R3,R11,#+328
   \   0000007C   0x2240             MOVS     R2,#+64
   \   0000007E   0xEB07 0x1040      ADD      R0,R7,R0, LSL #+5
   \   00000082   0xE00A             B.N      ??PDM2PCMSDO78_6
   1612          						break;
   1613          					case BUF2_PLAY:
   1614          						PDM_Filter_64_LSB((uint8_t *)pDataMic7,(uint16_t *)(Buffer3.bufMIC7 + (i/64)*16), 64 ,
   1615          						(PDMFilter_InitStruct *)&Filter[0]);	
   \                     ??PDM2PCMSDO78_5: (+1)
   \   00000084   0xF50B 0x73A4      ADD      R3,R11,#+328
   \   00000088   0x2240             MOVS     R2,#+64
   \   0000008A   0xEB08 0x1040      ADD      R0,R8,R0, LSL #+5
   \   0000008E   0xE004             B.N      ??PDM2PCMSDO78_6
   1616          						break;
   1617          					case BUF3_PLAY:
   1618          						PDM_Filter_64_LSB((uint8_t *)pDataMic7,(uint16_t *)(Buffer1.bufMIC7 + (i/64)*16), 64 ,
   1619          						(PDMFilter_InitStruct *)&Filter[0]);									
   \                     ??PDM2PCMSDO78_4: (+1)
   \   00000090   0xF50B 0x73A4      ADD      R3,R11,#+328
   \   00000094   0x2240             MOVS     R2,#+64
   \   00000096   0xEB09 0x1040      ADD      R0,R9,R0, LSL #+5
   \                     ??PDM2PCMSDO78_6: (+1)
   \   0000009A   0xF500 0x41C0      ADD      R1,R0,#+24576
   \   0000009E   0x3178             ADDS     R1,R1,#+120
   \   000000A0   0xF50B 0x7012      ADD      R0,R11,#+584
   \   000000A4   0x.... 0x....      BL       PDM_Filter_64_LSB
   1620          						 break;
   1621          					default:
   1622          						 break; 
   1623          			    }
   1624          
   1625          			}
   1626          
   1627                  }
   \                     ??PDM2PCMSDO78_2: (+1)
   \   000000A8   0x1C64             ADDS     R4,R4,#+1
   \   000000AA   0x1CB6             ADDS     R6,R6,#+2
   \   000000AC   0x1CAD             ADDS     R5,R5,#+2
   \   000000AE   0xF5B4 0x5F80      CMP      R4,#+4096
   \   000000B2   0xDBBD             BLT.N    ??PDM2PCMSDO78_1
   1628          
   1629          		/* Update for left-right channel */
   1630          		for (int16_t i=AUDIO_OUT_BUFFER_SIZE-1; i>=0;i--)
   \   000000B4   0xF646 0x0276      MOVW     R2,#+26742
   \   000000B8   0xF247 0x0674      MOVW     R6,#+28788
   \   000000BC   0x19D0             ADDS     R0,R2,R7
   \   000000BE   0xEB02 0x0108      ADD      R1,R2,R8
   \   000000C2   0x19F3             ADDS     R3,R6,R7
   \   000000C4   0xEB06 0x0508      ADD      R5,R6,R8
   \   000000C8   0x444A             ADD      R2,R2,R9
   \   000000CA   0x444E             ADD      R6,R6,R9
   \   000000CC   0xF44F 0x6780      MOV      R7,#+1024
   1631          		{
   1632                         /* Recording Audio Data */						 
   1633          				switch (buffer_switch)
   \                     ??PDM2PCMSDO78_7: (+1)
   \   000000D0   0xF89A 0xC000      LDRB     R12,[R10, #+0]
   \   000000D4   0xF1BC 0x0F00      CMP      R12,#+0
   \   000000D8   0xD00C             BEQ.N    ??PDM2PCMSDO78_8
   \   000000DA   0xF1BC 0x0F02      CMP      R12,#+2
   \   000000DE   0xD012             BEQ.N    ??PDM2PCMSDO78_9
   \   000000E0   0xBF3F             ITTTT    CC 
   \   000000E2   0xF8B1 0xC000      LDRHCC   R12,[R1, #+0]
   \   000000E6   0xF8A5 0xC002      STRHCC   R12,[R5, #+2]
   \   000000EA   0xF8B1 0xC000      LDRHCC   R12,[R1, #+0]
   \   000000EE   0xF8A5 0xC000      STRHCC   R12,[R5, #+0]
   1634          				{
   1635          					case BUF1_PLAY:								
   1636                                  Buffer2.bufMIC7[2*i+1]=  Buffer2.bufMIC7[i];
   1637          						Buffer2.bufMIC7[2*i] = Buffer2.bufMIC7[i];
   1638          						break;
   1639          					case BUF2_PLAY:
   1640          	                    Buffer3.bufMIC7[2*i+1]= Buffer3.bufMIC7[i];
   1641          						Buffer3.bufMIC7[2*i]= Buffer3.bufMIC7[i];;	
   \   000000F2   0xE010             B.N      ??PDM2PCMSDO78_10
   \                     ??PDM2PCMSDO78_8: (+1)
   \   000000F4   0xF8B0 0xC000      LDRH     R12,[R0, #+0]
   \   000000F8   0xF8A3 0xC002      STRH     R12,[R3, #+2]
   \   000000FC   0xF8B0 0xC000      LDRH     R12,[R0, #+0]
   \   00000100   0xF8A3 0xC000      STRH     R12,[R3, #+0]
   \   00000104   0xE007             B.N      ??PDM2PCMSDO78_10
   1642          						break;
   1643          					case BUF3_PLAY:
   1644          						Buffer1.bufMIC7[2*i+1]= Buffer1.bufMIC7[i];
   \                     ??PDM2PCMSDO78_9: (+1)
   \   00000106   0xF8B2 0xC000      LDRH     R12,[R2, #+0]
   \   0000010A   0xF8A6 0xC002      STRH     R12,[R6, #+2]
   1645          						Buffer1.bufMIC7[2*i]= Buffer1.bufMIC7[i];;	
   \   0000010E   0xF8B2 0xC000      LDRH     R12,[R2, #+0]
   \   00000112   0xF8A6 0xC000      STRH     R12,[R6, #+0]
   1646          						break;
   1647          					default:
   1648          						 break; 
   1649          			    }
   1650          		}
   \                     ??PDM2PCMSDO78_10: (+1)
   \   00000116   0x1F36             SUBS     R6,R6,#+4
   \   00000118   0x1F2D             SUBS     R5,R5,#+4
   \   0000011A   0x1F1B             SUBS     R3,R3,#+4
   \   0000011C   0x1E92             SUBS     R2,R2,#+2
   \   0000011E   0x1E89             SUBS     R1,R1,#+2
   \   00000120   0x1E80             SUBS     R0,R0,#+2
   \   00000122   0x1E7F             SUBS     R7,R7,#+1
   \   00000124   0xD1D4             BNE.N    ??PDM2PCMSDO78_7
   1651          
   1652          	}
   1653              
   1654          
   1655          	/* Data in Mic8 finished recording */
   1656          	if (WaveRecord_flgSDO8Finish==1)
   \                     ??PDM2PCMSDO78_0: (+1)
   \   00000126   0x....             LDR.N    R0,??DataTable17_30
   \   00000128   0x7801             LDRB     R1,[R0, #+0]
   \   0000012A   0x2901             CMP      R1,#+1
   \   0000012C   0xF040 0x807B      BNE.W    ??PDM2PCMSDO78_11
   1657          	{
   1658          		WaveRecord_flgSDO8Finish=0;
   \   00000130   0x2100             MOVS     R1,#+0
   1659          		
   1660          		for (uint16_t i=0; i< 4*AUDIO_OUT_BUFFER_SIZE;i++)
   \   00000132   0x2400             MOVS     R4,#+0
   \   00000134   0x7001             STRB     R1,[R0, #+0]
   \   00000136   0x....             LDR.N    R5,??DataTable17_3
   \   00000138   0x1D06             ADDS     R6,R0,#+4
   \   0000013A   0x....             LDR.N    R7,??DataTable17_19  ;; 0xc00080a0
   \   0000013C   0x.... 0x....      LDR.W    R8,??DataTable17_20  ;; 0xc0010140
   \   00000140   0xF04F 0x4940      MOV      R9,#-1073741824
   \   00000144   0x.... 0x....      LDR.W    R10,??DataTable17_18
   1661          		{
   1662          					if(swtSDO8==0x01)
   \                     ??PDM2PCMSDO78_12: (+1)
   \   00000148   0xF89B 0x01B1      LDRB     R0,[R11, #+433]
   \   0000014C   0x2801             CMP      R0,#+1
   \   0000014E   0xBF07             ITTEE    EQ 
   \   00000150   0x8828             LDRHEQ   R0,[R5, #+0]
   \   00000152   0x8829             LDRHEQ   R1,[R5, #+0]
   \   00000154   0x8830             LDRHNE   R0,[R6, #+0]
   \   00000156   0x8831             LDRHNE   R1,[R6, #+0]
   1663          					{
   1664          					  pDataMic8[i%64] = HTONS(TestSDO8[i]);
                 					  ^
Warning[Pa082]: undefined behavior: the order of volatile accesses is
          undefined in this statement
   1665          					}
   1666          					else
   1667          					{
   1668          					   pDataMic8[i%64] = HTONS(TestSDO8_1[i]);
                 					   ^
Warning[Pa082]: undefined behavior: the order of volatile accesses is
          undefined in this statement
   \   00000158   0x1162             ASRS     R2,R4,#+5
   \   0000015A   0x0209             LSLS     R1,R1,#+8
   \   0000015C   0xEB04 0x6292      ADD      R2,R4,R2, LSR #+26
   \   00000160   0xEA41 0x2010      ORR      R0,R1,R0, LSR #+8
   \   00000164   0x1192             ASRS     R2,R2,#+6
   \   00000166   0xEBA4 0x1282      SUB      R2,R4,R2, LSL #+6
   \   0000016A   0xEB0B 0x0242      ADD      R2,R11,R2, LSL #+1
   \   0000016E   0xF8A2 0x01C8      STRH     R0,[R2, #+456]
   1669          		
   1670          					}
   1671          		
   1672          					/* PDM conversion for frame of 64 inputs, 16 outputs */
   1673          				  if (i%64==63)
   \   00000172   0x1160             ASRS     R0,R4,#+5
   \   00000174   0xEB04 0x6090      ADD      R0,R4,R0, LSR #+26
   \   00000178   0x1180             ASRS     R0,R0,#+6
   \   0000017A   0xEBA4 0x1180      SUB      R1,R4,R0, LSL #+6
   \   0000017E   0x293F             CMP      R1,#+63
   \   00000180   0xD11E             BNE.N    ??PDM2PCMSDO78_13
   1674          				  {
   1675          						/* Recording Audio Data */						 
   1676          						switch (buffer_switch)
   \   00000182   0xF89A 0x1000      LDRB     R1,[R10, #+0]
   \   00000186   0xB119             CBZ.N    R1,??PDM2PCMSDO78_14
   \   00000188   0x2902             CMP      R1,#+2
   \   0000018A   0xD00D             BEQ.N    ??PDM2PCMSDO78_15
   \   0000018C   0xD306             BCC.N    ??PDM2PCMSDO78_16
   \   0000018E   0xE017             B.N      ??PDM2PCMSDO78_13
   1677          						{
   1678          							case BUF1_PLAY: 							
   1679          								PDM_Filter_64_LSB((uint8_t *)pDataMic8,(uint16_t *)(Buffer2.bufMIC8 + (i/64)*16), 64 ,
   1680          								(PDMFilter_InitStruct *)&Filter[1]);
   \                     ??PDM2PCMSDO78_14: (+1)
   \   00000190   0xF50B 0x73BE      ADD      R3,R11,#+380
   \   00000194   0x2240             MOVS     R2,#+64
   \   00000196   0xEB07 0x1040      ADD      R0,R7,R0, LSL #+5
   \   0000019A   0xE00A             B.N      ??PDM2PCMSDO78_17
   1681          								break;
   1682          							case BUF2_PLAY:
   1683          								PDM_Filter_64_LSB((uint8_t *)pDataMic8,(uint16_t *)(Buffer3.bufMIC8 + (i/64)*16), 64 ,
   1684          								(PDMFilter_InitStruct *)&Filter[1]);	
   \                     ??PDM2PCMSDO78_16: (+1)
   \   0000019C   0xF50B 0x73BE      ADD      R3,R11,#+380
   \   000001A0   0x2240             MOVS     R2,#+64
   \   000001A2   0xEB08 0x1040      ADD      R0,R8,R0, LSL #+5
   \   000001A6   0xE004             B.N      ??PDM2PCMSDO78_17
   1685          								break;
   1686          							case BUF3_PLAY:
   1687          								PDM_Filter_64_LSB((uint8_t *)pDataMic8,(uint16_t *)(Buffer1.bufMIC8 + (i/64)*16), 64 ,
   1688          								(PDMFilter_InitStruct *)&Filter[1]);									
   \                     ??PDM2PCMSDO78_15: (+1)
   \   000001A8   0xF50B 0x73BE      ADD      R3,R11,#+380
   \   000001AC   0x2240             MOVS     R2,#+64
   \   000001AE   0xEB09 0x1040      ADD      R0,R9,R0, LSL #+5
   \                     ??PDM2PCMSDO78_17: (+1)
   \   000001B2   0xF500 0x41E0      ADD      R1,R0,#+28672
   \   000001B6   0x318C             ADDS     R1,R1,#+140
   \   000001B8   0xF50B 0x70E4      ADD      R0,R11,#+456
   \   000001BC   0x.... 0x....      BL       PDM_Filter_64_LSB
   1689          								 break;
   1690          							default:
   1691          								 break; 
   1692          						}
   1693          		
   1694          					}
   1695          					 
   1696          		}
   \                     ??PDM2PCMSDO78_13: (+1)
   \   000001C0   0x1C64             ADDS     R4,R4,#+1
   \   000001C2   0x1CB6             ADDS     R6,R6,#+2
   \   000001C4   0x1CAD             ADDS     R5,R5,#+2
   \   000001C6   0xF5B4 0x5F80      CMP      R4,#+4096
   \   000001CA   0xDBBD             BLT.N    ??PDM2PCMSDO78_12
   1697          
   1698          		/* Update for left-right channel */
   1699          		for (int16_t i=AUDIO_OUT_BUFFER_SIZE-1; i>=0;i--)
   \   000001CC   0xF647 0x028A      MOVW     R2,#+30858
   \   000001D0   0xF248 0x0588      MOVW     R5,#+32904
   \   000001D4   0x19D0             ADDS     R0,R2,R7
   \   000001D6   0xEB02 0x0108      ADD      R1,R2,R8
   \   000001DA   0x19EB             ADDS     R3,R5,R7
   \   000001DC   0xEB05 0x0B08      ADD      R11,R5,R8
   \   000001E0   0x444A             ADD      R2,R2,R9
   \   000001E2   0x444D             ADD      R5,R5,R9
   \   000001E4   0xF44F 0x6680      MOV      R6,#+1024
   1700          		{
   1701          			   /* Recording Audio Data */						 
   1702          				switch (buffer_switch)
   \                     ??PDM2PCMSDO78_18: (+1)
   \   000001E8   0xF89A 0x7000      LDRB     R7,[R10, #+0]
   \   000001EC   0xB14F             CBZ.N    R7,??PDM2PCMSDO78_19
   \   000001EE   0x2F02             CMP      R7,#+2
   \   000001F0   0xD00C             BEQ.N    ??PDM2PCMSDO78_20
   \   000001F2   0xBF3F             ITTTT    CC 
   \   000001F4   0x880F             LDRHCC   R7,[R1, #+0]
   \   000001F6   0xF8AB 0x7002      STRHCC   R7,[R11, #+2]
   \   000001FA   0x880F             LDRHCC   R7,[R1, #+0]
   \   000001FC   0xF8AB 0x7000      STRHCC   R7,[R11, #+0]
   1703          				{
   1704          					case BUF1_PLAY: 							
   1705          						Buffer2.bufMIC8[2*i+1]=  Buffer2.bufMIC8[i];
   1706          						Buffer2.bufMIC8[2*i] = Buffer2.bufMIC8[i];
   1707          						break;
   1708          					case BUF2_PLAY:
   1709          						Buffer3.bufMIC8[2*i+1]= Buffer3.bufMIC8[i];
   1710          						Buffer3.bufMIC8[2*i]= Buffer3.bufMIC8[i];;	
   \   00000200   0xE008             B.N      ??PDM2PCMSDO78_21
   \                     ??PDM2PCMSDO78_19: (+1)
   \   00000202   0x8807             LDRH     R7,[R0, #+0]
   \   00000204   0x805F             STRH     R7,[R3, #+2]
   \   00000206   0x8807             LDRH     R7,[R0, #+0]
   \   00000208   0x801F             STRH     R7,[R3, #+0]
   \   0000020A   0xE003             B.N      ??PDM2PCMSDO78_21
   1711          						break;
   1712          					case BUF3_PLAY:
   1713          						Buffer1.bufMIC8[2*i+1]= Buffer1.bufMIC8[i];
   \                     ??PDM2PCMSDO78_20: (+1)
   \   0000020C   0x8817             LDRH     R7,[R2, #+0]
   \   0000020E   0x806F             STRH     R7,[R5, #+2]
   1714          						Buffer1.bufMIC8[2*i]= Buffer1.bufMIC8[i];;	
   \   00000210   0x8817             LDRH     R7,[R2, #+0]
   \   00000212   0x802F             STRH     R7,[R5, #+0]
   1715          						break;
   1716          					default:
   1717          						 break; 
   1718          				}
   1719          		}
   \                     ??PDM2PCMSDO78_21: (+1)
   \   00000214   0x1F2D             SUBS     R5,R5,#+4
   \   00000216   0x1F1B             SUBS     R3,R3,#+4
   \   00000218   0x1E92             SUBS     R2,R2,#+2
   \   0000021A   0x1E89             SUBS     R1,R1,#+2
   \   0000021C   0x1E80             SUBS     R0,R0,#+2
   \   0000021E   0x1E76             SUBS     R6,R6,#+1
   \   00000220   0xF1AB 0x0B04      SUB      R11,R11,#+4
   \   00000224   0xD1E0             BNE.N    ??PDM2PCMSDO78_18
   1720          
   1721          
   1722          	}
   1723          
   1724          
   1725          }
   \                     ??PDM2PCMSDO78_11: (+1)
   \   00000226   0xB001             ADD      SP,SP,#+4
   \   00000228   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
   \   0000022C                      REQUIRE Buffer2
   \   0000022C                      REQUIRE Buffer3
   \   0000022C                      REQUIRE Buffer1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11:
   \   00000000   0x45FA0000         DC32     0x45fa0000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12:
   \   00000000   0x40023830         DC32     0x40023830

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_1:
   \   00000000   0x40020000         DC32     0x40020000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_2:
   \   00000000   0x........         DC32     spi1_ins

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15:
   \   00000000   0x40021000         DC32     0x40021000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_1:
   \   00000000   0x4001300C         DC32     0x4001300c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_2:
   \   00000000   0x........         DC32     hspi5

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_3:
   \   00000000   0x........         DC32     WaveRecord_flgInt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_4:
   \   00000000   0x........         DC32     WaveRec_idxSens1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_5:
   \   00000000   0x........         DC32     WaveRec_idxSens2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_6:
   \   00000000   0x........         DC32     buffer_switch

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_7:
   \   00000000   0xC00080A0         DC32     0xc00080a0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_8:
   \   00000000   0xC0010140         DC32     0xc0010140

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_9:
   \   00000000   0x4000380C         DC32     0x4000380c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_10:
   \   00000000   0x........         DC32     I2S2_stPosShft

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_11:
   \   00000000   0x........         DC32     WaveRec_idxSens3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_12:
   \   00000000   0x........         DC32     WaveRec_idxSens4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_13:
   \   00000000   0x........         DC32     hspi4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_14:
   \   00000000   0x4001340C         DC32     0x4001340c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_15:
   \   00000000   0x........         DC32     WaveRec_idxSens5

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16:
   \   00000000   0x........         DC32     WaveRec_idxSens6

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_1:
   \   00000000   0x4001500C         DC32     0x4001500c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_2:
   \   00000000   0x4001540C         DC32     0x4001540c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_3:
   \   00000000   0x40013000         DC32     0x40013000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17:
   \   00000000   0x........         DC32     volume

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_1:
   \   00000000   0x40003800         DC32     0x40003800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_2:
   \   00000000   0x........         DC32     TestSDO7

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_3:
   \   00000000   0x........         DC32     TestSDO8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_4:
   \   00000000   0x40013400         DC32     0x40013400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_5:
   \   00000000   0x40015400         DC32     0x40015400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_6:
   \   00000000   0x40015000         DC32     0x40015000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_7:
   \   00000000   0x40020800         DC32     0x40020800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_8:
   \   00000000   0x40020400         DC32     0x40020400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_9:
   \   00000000   0x40003C00         DC32     0x40003c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_10:
   \   00000000   0x........         DC32     DmaHandle

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_11:
   \   00000000   0x400260B8         DC32     0x400260b8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_12:
   \   00000000   0x40021400         DC32     0x40021400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_13:
   \   00000000   0x........         DC32     hdma_spi5_rx

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_14:
   \   00000000   0x40021800         DC32     0x40021800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_15:
   \   00000000   0x........         DC32     hdma_spi5_rx+0x50

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_16:
   \   00000000   0x........         DC32     hspi5

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_17:
   \   00000000   0x........         DC32     TestSDO7_1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_18:
   \   00000000   0x........         DC32     buffer_switch

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_19:
   \   00000000   0xC00080A0         DC32     0xc00080a0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_20:
   \   00000000   0xC0010140         DC32     0xc0010140

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_21:
   \   00000000   0x........         DC32     WaveRec_idxSens1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_22:
   \   00000000   0x........         DC32     WaveRec_idxSens2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_23:
   \   00000000   0x........         DC32     idxSPI5DataBuf3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_24:
   \   00000000   0x........         DC32     WaveRec_idxSens3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_25:
   \   00000000   0x........         DC32     WaveRec_idxSens4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_26:
   \   00000000   0x........         DC32     I2S2_idxTmp

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_27:
   \   00000000   0x........         DC32     WaveRec_idxSens5

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_28:
   \   00000000   0x........         DC32     flgDlyUpd

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_29:
   \   00000000   0x........         DC32     XferCplt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_30:
   \   00000000   0x........         DC32     WaveRecord_flgSDO8Finish
   1726          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   DMA2_Stream5_IRQHandler
         0   -> HAL_DMA_IRQHandler
       0   DMA2_Stream6_IRQHandler
         0   -> HAL_DMA_IRQHandler
      40   HAL_SPI_MspInit
        40   -> HAL_DMA_DeInit
        40   -> HAL_DMA_Init
        40   -> HAL_GPIO_Init
        40   -> HAL_NVIC_EnableIRQ
        40   -> HAL_NVIC_SetPriority
      32   HAL_SPI_RxCpltCallback
        32   -> AudioProcess
         0   -> HAL_SPI_Receive_DMA
        32   -> HAL_SPI_Receive_DMA
        32   -> PDM_Filter_64_LSB
      16   MIC1TO6_Init
        16   -> HAL_GPIO_ReadPin
        16   -> HAL_I2S_Init
        16   -> HAL_SPI_Receive_DMA
        16   -> SPI4_Init
        16   -> SPI5_Init
        16   -> SPI6_Init
       0   Mic7Rec
         0   -> SPI5_Init
       0   Mic8Rec
         0   -> HAL_SPI_Init
      40   PDM2PCMSDO78
        40   -> PDM_Filter_64_LSB
       0   RecordUpdBuf
      16   SPI1_IRQHandler
        16   -> HAL_GPIO_ReadPin
      32   SPI1_Ini
        32   -> HAL_GPIO_Init
        32   -> HAL_GPIO_WritePin
        32   -> HAL_NVIC_EnableIRQ
        32   -> HAL_NVIC_SetPriority
        32   -> HAL_SPI_Init
      24   SPI2_IRQHandler
        24   -> HAL_GPIO_ReadPin
      24   SPI4_IRQHandler
        24   -> HAL_GPIO_ReadPin
       8   SPI4_Init
         8   -> HAL_SPI_Init
       8   SPI5_IRQHandler
         8   -> PDM_Filter_64_LSB
      32   SPI5_Init
         0   -> HAL_SPI_Init
        32   -> PDM_Filter_Init
       8   SPI6_IRQHandler
         8   -> PDM_Filter_64_LSB
       0   SPI6_Init
         0   -> HAL_SPI_Init
       0   mySPI_SendData


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable11
       4  ??DataTable12
       4  ??DataTable12_1
       4  ??DataTable12_2
       4  ??DataTable15
       4  ??DataTable15_1
       4  ??DataTable15_10
       4  ??DataTable15_11
       4  ??DataTable15_12
       4  ??DataTable15_13
       4  ??DataTable15_14
       4  ??DataTable15_15
       4  ??DataTable15_2
       4  ??DataTable15_3
       4  ??DataTable15_4
       4  ??DataTable15_5
       4  ??DataTable15_6
       4  ??DataTable15_7
       4  ??DataTable15_8
       4  ??DataTable15_9
       4  ??DataTable16
       4  ??DataTable16_1
       4  ??DataTable16_2
       4  ??DataTable16_3
       4  ??DataTable17
       4  ??DataTable17_1
       4  ??DataTable17_10
       4  ??DataTable17_11
       4  ??DataTable17_12
       4  ??DataTable17_13
       4  ??DataTable17_14
       4  ??DataTable17_15
       4  ??DataTable17_16
       4  ??DataTable17_17
       4  ??DataTable17_18
       4  ??DataTable17_19
       4  ??DataTable17_2
       4  ??DataTable17_20
       4  ??DataTable17_21
       4  ??DataTable17_22
       4  ??DataTable17_23
       4  ??DataTable17_24
       4  ??DataTable17_25
       4  ??DataTable17_26
       4  ??DataTable17_27
       4  ??DataTable17_28
       4  ??DataTable17_29
       4  ??DataTable17_3
       4  ??DataTable17_30
       4  ??DataTable17_4
       4  ??DataTable17_5
       4  ??DataTable17_6
       4  ??DataTable17_7
       4  ??DataTable17_8
       4  ??DataTable17_9
   32928  Buffer1
   32928  Buffer2
   32928  Buffer3
       8  DMA2_Stream5_IRQHandler
       8  DMA2_Stream6_IRQHandler
    1042  HAL_SPI_MspInit
     618  HAL_SPI_RxCpltCallback
       1  I2S2_stLR
    8200  I2S2_stPosShft
          I2S2_stLROld
          I2S2_stNipple
          iSDO34
          TestSDO34
     294  MIC1TO6_Init
       1  Main_stLR
       2  Mic7Rec
      74  Mic8Rec
     556  PDM2PCMSDO78
     234  RecordUpdBuf
     244  SPI1_IRQHandler
     212  SPI1_Ini
     270  SPI2_IRQHandler
     286  SPI4_IRQHandler
      82  SPI4_Init
     138  SPI5_IRQHandler
     140  SPI5_Init
     132  SPI6_IRQHandler
      74  SPI6_Init
    8192  TestSDO56
    8192  TestSDO7
    8192  TestSDO7_1
    8192  TestSDO8
       1  WaveRecord_flgIni
    8216  WaveRecord_flgInt
          I2S1_stPosShft
          SPI4_stPosShft
          stLROld
          Main_stLROld
          vRawSens1
          vRawSens2
          vRawSens4
          vRawSens3
          vRawSens5
          vRawSens6
          SPI1_stNipple
          I2S1_stNipple
          iSDO12
          TestSDO12
    8196  WaveRecord_flgSDO8Finish
          TestSDO8_1
       2  cntTransFinish
      80  hdma_spi2_tx
      80  hdma_spi3_tx
     160  hdma_spi5_rx
          hdma_spi6_rx
     100  hspi1
     100  hspi2
     712  hspi5
          hspi6
          hi2s1
          hi2s2
          Filter
          swtSDO7
          swtSDO8
          WaveRecord_flgSDO7Finish
          idxMic8
          idxMic7
          idxFrmPDMMic8
          cntPos
          cntPos7
          cntStrt
          bufPCMSens7
          bufPCMSens8
          pDataMic8
          pDataMic7
       2  iSDO56
      44  mySPI_SendData
      44  pHeaderBuff
     100  spi1_ins
     100  spi2_ins
       1  stLR

 
 58 864 bytes in section .bss
 98 784 bytes in section .bss  (abs)
  4 678 bytes in section .text
 
   4 678 bytes of CODE memory
 157 648 bytes of DATA memory

Errors: none
Warnings: 28
