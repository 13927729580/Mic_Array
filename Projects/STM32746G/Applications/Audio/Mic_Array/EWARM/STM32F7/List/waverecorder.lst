###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.2.10312/W32 for ARM       05/Mar/2016  17:13:58
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\Src\waverecorder.c
#    Command line =  
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\Src\waverecorder.c
#        -D USE_HAL_DRIVER -D STM32F746xx -D USE_STM32746G_DISCO -D
#        USE_IOEXPANDER -D USE_USB_FS -lC
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
#        -lA
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
#        -o
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj
#        --no_unroll --debug --endian=little --cpu=Cortex-M7 -e --fpu=VFPv5_sp
#        --dlib_config "D:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Full.h" -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\Inc\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\CMSIS\Device\ST\STM32F7xx\Include\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\STM32F7xx_HAL_Driver\Inc\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\STM32746G-Discovery\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\Components\Common\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Log\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Fonts\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\CPU\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_Device_Library\Core\Inc\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Core\Inc\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Class\MSC\Inc\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\drivers\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_Audio\Addons\PDM\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_Device_Library\Class\AUDIO\Inc\
#        -Oh --use_c++_inline --require_prototypes -I "D:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.3\arm\CMSIS\Include\" -D
#        ARM_MATH_CM7 --relaxed_fp
#    List file    =  
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List\waverecorder.lst
#    Object file  =  
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj\waverecorder.o
#
###############################################################################

H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\Src\waverecorder.c
      1          
      2          /* Includes ------------------------------------------------------------------*/
      3          #include "waverecorder.h" 
      4          #include "string.h"
      5          //#include "stm32f7xx_hal_spi.h"
      6          #include "stm32f7xx_hal.h"
      7          #include "pdm_filter.h"
      8          #include "DSP.h"
      9          
     10          
     11          /* Private typedef -----------------------------------------------------------*/
     12          /* Private define ------------------------------------------------------------*/
     13          
     14          
     15          /* SPI Configuration defines */
     16          #define SPI_SCK_PIN                       GPIO_PIN_10
     17          #define SPI_SCK_GPIO_PORT                 GPIOB
     18          #define SPI_SCK_GPIO_CLK                  1
     19          #define SPI_SCK_SOURCE                    1
     20          #define SPI_SCK_AF                        GPIO_AF5_SPI2
     21          
     22          #define SPI_MOSI_PIN                      GPIO_PIN_3
     23          #define SPI_MOSI_GPIO_PORT                GPIOC
     24          #define SPI_MOSI_GPIO_CLK                 1
     25          #define SPI_MOSI_SOURCE                   1
     26          #define SPI_MOSI_AF                       GPIO_AF5_SPI2
     27          
     28          
     29          /* sop1hc */
     30          #define SPI1_SCK_PIN                       GPIO_PIN_5
     31          #define SPI1_SCK_GPIO_PORT                 GPIOA
     32          #define SPI1_SCK_GPIO_CLK                  1
     33          #define SPI1_SCK_SOURCE                    1
     34          #define SPI1_SCK_AF                        GPIO_AF5_SPI1
     35          
     36          #define SPI1_MOSI_PIN                      GPIO_PIN_7
     37          #define SPI1_MOSI_GPIO_PORT                GPIOA
     38          #define SPI1_MOSI_GPIO_CLK                 1
     39          #define SPI1_MOSI_SOURCE                   1
     40          #define SPI1_MOSI_AF                       GPIO_AF5_SPI1
     41          
     42          #define SPI1_MISO_PIN                      GPIO_PIN_6
     43          #define SPI1_MISO_GPIO_PORT                GPIOA
     44          #define SPI1_MISO_GPIO_CLK                 1
     45          #define SPI1_MISO_SOURCE                   1
     46          #define SPI1_MISO_AF                       GPIO_AF5_SPI1
     47          
     48          
     49          
     50          

   \                                 In section .bss, align 4
     51          uint16_t idxMic8=0;
   \                     idxMic8:
   \   00000000                      DS8 2
     52          uint16_t idxMic7=0;
     53          uint8_t pHeaderBuff[44];
     54          //uint16_t Buffer1[AUDIO_IN_PCM_BUFFER_SIZE];
     55          uint16_t volatile cntTransFinish;
     56          
     57          /* Private macro -------------------------------------------------------------*/
     58          /* Private variables ---------------------------------------------------------*/
     59          extern  AUDIO_IN_BufferTypeDef  stkBufferCtlRecIn,stkBuffer1, stkBuffer2;
     60          extern AUDIO_OUT_BufferTypeDef  BufferCtlPlayOut;
     61          extern uint16_t __IO idxSPI5DataBuf1, idxSPI5DataBuf2;
     62          extern WAVE_FormatTypeDef WaveFormat;
     63          extern FIL WavFile;
     64          extern AUDIO_DEMO_StateMachine AudioDemo;
     65          extern AUDIO_PLAYBACK_StateTypeDef AudioState;
     66          extern __IO uint8_t buffer_switch;
     67          extern __IO uint8_t volume;
     68          extern SPI_HandleTypeDef hspi4,hspi1;
     69          extern __IO uint16_t  WaveRec_idxSens1,WaveRec_idxSens2;
     70          extern __IO uint16_t  WaveRec_idxSens3,WaveRec_idxSens4;
     71          extern __IO uint16_t  WaveRec_idxSens5,WaveRec_idxSens6;
     72          extern __IO uint16_t  I2S2_idxTmp;
     73          extern SPI_HandleTypeDef     hspi4;
     74          extern DMA_HandleTypeDef     DmaHandle;
     75          
     76          #ifndef CS43L22_PLAY
     77          extern __IO uint8_t flgDlyUpd; 
     78          extern __IO uint32_t XferCplt;
     79          extern __IO uint16_t  idxSPI5DataBuf3;
     80          #endif
     81          
     82          __IO int16_t TestSDO12[4*AUDIO_OUT_BUFFER_SIZE];
     83          __IO int16_t TestSDO34[4*AUDIO_OUT_BUFFER_SIZE];
     84          __IO int16_t TestSDO56[4*AUDIO_OUT_BUFFER_SIZE];
     85          __IO uint16_t TestSDO7[4*AUDIO_OUT_BUFFER_SIZE];
     86          __IO uint16_t TestSDO8[4*AUDIO_OUT_BUFFER_SIZE];
     87          __IO uint16_t TestSDO7_1[4*AUDIO_OUT_BUFFER_SIZE];
     88          __IO uint16_t TestSDO8_1[4*AUDIO_OUT_BUFFER_SIZE];
     89          __IO uint16_t  WaveRec_idxTest;
     90          
     91          
     92          SPI_HandleTypeDef hspi1,hspi2;
     93          SPI_HandleTypeDef spi1_ins,spi2_ins;
     94          I2S_HandleTypeDef hi2s1;
     95          I2S_HandleTypeDef hi2s2;
     96          SPI_HandleTypeDef hspi5,hspi6;
     97          DMA_HandleTypeDef hdma_spi2_tx;
     98          DMA_HandleTypeDef hdma_spi3_tx;
     99          DMA_HandleTypeDef     hdma_spi5_rx,hdma_spi6_rx;
    100          
    101          #if USB_STREAMING
    102          __IO uint16_t idxFrmPDMMic8;
    103          #endif
    104          
    105          uint16_t *bufPCMSens7;
    106          uint16_t *bufPCMSens8;
    107          __IO uint16_t cntPos;
   \                     cntPos:
   \   00000002                      DS8 2
   \                     hspi5:
   \   00000004                      DS8 100
   \                     bufPCMSens8:
   \   00000068                      DS8 4

   \                                 In section .bss, align 4
   \                     idxMic7:
   \   00000000                      DS8 2
    108          __IO uint16_t cntPos7;
   \                     cntPos7:
   \   00000002                      DS8 2
   \                     hspi6:
   \   00000004                      DS8 100
   \                     bufPCMSens7:
   \   00000068                      DS8 4

   \                                 In section .bss, align 4
   \                     pHeaderBuff:
   \   00000000                      DS8 44

   \                                 In section .bss, align 2
   \                     cntTransFinish:
   \   00000000                      DS8 2

   \                                 In section .bss, align 4
   \                     TestSDO12:
   \   00000000                      DS8 8192

   \                                 In section .bss, align 4
   \                     TestSDO34:
   \   00000000                      DS8 8192

   \                                 In section .bss, align 4
   \                     TestSDO56:
   \   00000000                      DS8 8192

   \                                 In section .bss, align 4
   \                     TestSDO7:
   \   00000000                      DS8 8192

   \                                 In section .bss, align 4
   \                     TestSDO8:
   \   00000000                      DS8 8192

   \                                 In section .bss, align 4
   \                     TestSDO7_1:
   \   00000000                      DS8 8192

   \                                 In section .bss, align 4
   \                     TestSDO8_1:
   \   00000000                      DS8 8192
    109          __IO static uint16_t iBuff;
    110          __IO static uint32_t uwVolume = 70;
    111          __IO PDMFilter_InitStruct Filter[2];
    112          __IO uint16_t  pDataMic8[64];//INTERNAL_BUFF_SIZE
    113          __IO uint16_t  pDataMic7[64];//INTERNAL_BUFF_SIZE
    114          __IO int16_t   pPDM2PCM[16];
    115          __IO uint16_t cntStrt;
    116          __IO uint8_t WaveRecord_flgInt;
    117          uint8_t WaveRecord_flgIni;
    118          
    119          uint16_t vRawSens1,vRawSens2,vRawSens4,vRawSens3,vRawSens5,vRawSens6;  
    120          __IO int16_t SPI1_stNipple,I2S1_stNipple, I2S2_stNipple,SPI4_stNipple;
    121          __IO uint16_t iSDO12,iSDO34,iSDO56;
    122          __IO uint8_t swtSDO7,swtSDO8;
    123          __IO uint8_t WaveRecord_flgSDO7Finish, WaveRecord_flgSDO8Finish;
    124          __IO uint8_t I2S1_stPosShft,I2S2_stPosShft,SPI4_stPosShft;
    125          __IO uint8_t I2S2_stLR, I2S2_stLROld;
    126          
    127          /* Private function prototypes -----------------------------------------------*/
    128          static void SPI_I2S_SendData(SPI_TypeDef* SPIx, uint16_t Data);
    129          static uint16_t SPI_I2S_ReceiveData(SPI_TypeDef* SPIx);
    130          static void I2S1_Init(void);
    131          static void I2S2_Init(void);
    132          
    133          #pragma location=SDRAM_BANK_ADDR
    134          Mic_Array_Data Buffer1;
    135          #pragma location= (SDRAM_BANK_ADDR+ BUFFER_SIZE_BYTE)
    136          Mic_Array_Data Buffer2;
    137          #pragma location= (SDRAM_BANK_ADDR+ BUFFER_SIZE_BYTE + BUFFER_SIZE_BYTE)
    138          Mic_Array_Data Buffer3;
    139          

   \                                 In section .text, align 2, keep-with-next
    140          void SPI1_Ini(void)
    141          {
   \                     SPI1_Ini: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    142            GPIO_InitTypeDef GPIO_InitStructure;
    143          
    144           
    145             	 
    146            /* Enable SCK, MOSI and MISO GPIO clocks */
    147            __HAL_RCC_SPI1_CLK_ENABLE();
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable12  ;; 0x40023830
   \   00000006   0xB086             SUB      SP,SP,#+24
    148            __HAL_RCC_GPIOA_CLK_ENABLE();
    149          
    150            
    151            GPIO_InitStructure.Mode = GPIO_MODE_AF_PP;
    152            GPIO_InitStructure.Pull  = GPIO_PULLDOWN;
    153            GPIO_InitStructure.Speed = GPIO_SPEED_HIGH;
    154          
    155            /* SPI SCK pin configuration */
    156            GPIO_InitStructure.Alternate = SPI1_SCK_AF;
    157            GPIO_InitStructure.Pin = SPI1_SCK_PIN;
    158            HAL_GPIO_Init(SPI1_SCK_GPIO_PORT,&GPIO_InitStructure);
   \   00000008   0x.... 0x....      LDR.W    R4,??DataTable12_1  ;; 0x40020000
   \   0000000C   0x6941             LDR      R1,[R0, #+20]
   \   0000000E   0xF441 0x5180      ORR      R1,R1,#0x1000
   \   00000012   0x6141             STR      R1,[R0, #+20]
   \   00000014   0x6941             LDR      R1,[R0, #+20]
   \   00000016   0xF401 0x5180      AND      R1,R1,#0x1000
   \   0000001A   0x9100             STR      R1,[SP, #+0]
   \   0000001C   0x9900             LDR      R1,[SP, #+0]
   \   0000001E   0x6801             LDR      R1,[R0, #+0]
   \   00000020   0xF041 0x0101      ORR      R1,R1,#0x1
   \   00000024   0x6001             STR      R1,[R0, #+0]
   \   00000026   0x6800             LDR      R0,[R0, #+0]
   \   00000028   0xA901             ADD      R1,SP,#+4
   \   0000002A   0xF000 0x0001      AND      R0,R0,#0x1
   \   0000002E   0x9000             STR      R0,[SP, #+0]
   \   00000030   0x9800             LDR      R0,[SP, #+0]
   \   00000032   0x2002             MOVS     R0,#+2
   \   00000034   0x9002             STR      R0,[SP, #+8]
   \   00000036   0x9003             STR      R0,[SP, #+12]
   \   00000038   0x2003             MOVS     R0,#+3
   \   0000003A   0x9004             STR      R0,[SP, #+16]
   \   0000003C   0x2005             MOVS     R0,#+5
   \   0000003E   0x9005             STR      R0,[SP, #+20]
   \   00000040   0x2020             MOVS     R0,#+32
   \   00000042   0x9001             STR      R0,[SP, #+4]
   \   00000044   0x4620             MOV      R0,R4
   \   00000046   0x.... 0x....      BL       HAL_GPIO_Init
    159          
    160            /* SPI  MOSI pin configuration */
    161            GPIO_InitStructure.Alternate = SPI1_MOSI_SOURCE;
   \   0000004A   0x2001             MOVS     R0,#+1
    162            GPIO_InitStructure.Pin =  SPI1_MOSI_PIN;
    163            HAL_GPIO_Init(SPI1_MOSI_GPIO_PORT, &GPIO_InitStructure);
   \   0000004C   0xA901             ADD      R1,SP,#+4
   \   0000004E   0x9005             STR      R0,[SP, #+20]
   \   00000050   0x2080             MOVS     R0,#+128
   \   00000052   0x9001             STR      R0,[SP, #+4]
   \   00000054   0x4620             MOV      R0,R4
   \   00000056   0x.... 0x....      BL       HAL_GPIO_Init
    164          
    165            /* SPI MISO pin configuration */
    166            GPIO_InitStructure.Alternate = SPI1_MISO_SOURCE;
   \   0000005A   0x2001             MOVS     R0,#+1
    167            GPIO_InitStructure.Pin = SPI1_MISO_PIN;
    168            HAL_GPIO_Init(SPI1_MISO_GPIO_PORT, &GPIO_InitStructure);
   \   0000005C   0xA901             ADD      R1,SP,#+4
   \   0000005E   0x9005             STR      R0,[SP, #+20]
   \   00000060   0x2040             MOVS     R0,#+64
   \   00000062   0x9001             STR      R0,[SP, #+4]
   \   00000064   0x4620             MOV      R0,R4
   \   00000066   0x.... 0x....      BL       HAL_GPIO_Init
    169          
    170            /* SPI configuration -------------------------------------------------------*/
    171            //SPI_I2S_DeInit(SPI1);
    172            
    173            spi1_ins.Init.Direction = SPI_DIRECTION_2LINES_RXONLY;
   \   0000006A   0x.... 0x....      LDR.W    R0,??DataTable12_2
   \   0000006E   0xF44F 0x6180      MOV      R1,#+1024
   \   00000072   0x6081             STR      R1,[R0, #+8]
    174            spi1_ins.Init.DataSize = SPI_DATASIZE_16BIT;
   \   00000074   0xF44F 0x6170      MOV      R1,#+3840
   \   00000078   0x60C1             STR      R1,[R0, #+12]
    175            spi1_ins.Init.CLKPolarity = SPI_POLARITY_LOW;
   \   0000007A   0x2100             MOVS     R1,#+0
   \   0000007C   0x6101             STR      R1,[R0, #+16]
    176            spi1_ins.Init.CLKPhase = SPI_PHASE_1EDGE;
    177            spi1_ins.Init.NSS = SPI_NSS_SOFT;
    178            spi1_ins.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_64;
    179            spi1_ins.Init.FirstBit = SPI_FIRSTBIT_MSB;
    180            spi1_ins.Init.CRCPolynomial = 7;
    181            spi1_ins.Init.Mode = SPI_MODE_SLAVE;
   \   0000007E   0x.... 0x....      LDR.W    R4,??DataTable16  ;; 0x40021000
   \   00000082   0x6141             STR      R1,[R0, #+20]
   \   00000084   0xF44F 0x7100      MOV      R1,#+512
   \   00000088   0x6181             STR      R1,[R0, #+24]
   \   0000008A   0x2128             MOVS     R1,#+40
   \   0000008C   0x61C1             STR      R1,[R0, #+28]
   \   0000008E   0x2100             MOVS     R1,#+0
   \   00000090   0x6201             STR      R1,[R0, #+32]
   \   00000092   0x2107             MOVS     R1,#+7
   \   00000094   0x62C1             STR      R1,[R0, #+44]
   \   00000096   0x2100             MOVS     R1,#+0
   \   00000098   0x6041             STR      R1,[R0, #+4]
    182            if(HAL_SPI_Init(&spi1_ins) != HAL_OK)
   \   0000009A   0x.... 0x....      BL       HAL_SPI_Init
    183            {
    184              /* Initialization Error */
    185              //Error_Handler();
    186            }
    187            
    188           
    189            GPIO_InitStructure.Pin = GPIO_PIN_3;
   \   0000009E   0x2008             MOVS     R0,#+8
    190            GPIO_InitStructure.Mode = GPIO_MODE_OUTPUT_PP;
    191            GPIO_InitStructure.Speed = GPIO_SPEED_FAST;
    192            GPIO_InitStructure.Pull = GPIO_PULLUP;
    193            //GPIO_InitStructure.Alternate 
    194            HAL_GPIO_Init(GPIOE, &GPIO_InitStructure);
   \   000000A0   0xA901             ADD      R1,SP,#+4
   \   000000A2   0x9001             STR      R0,[SP, #+4]
   \   000000A4   0x2001             MOVS     R0,#+1
   \   000000A6   0x9002             STR      R0,[SP, #+8]
   \   000000A8   0x2002             MOVS     R0,#+2
   \   000000AA   0x9004             STR      R0,[SP, #+16]
   \   000000AC   0x2001             MOVS     R0,#+1
   \   000000AE   0x9003             STR      R0,[SP, #+12]
   \   000000B0   0x4620             MOV      R0,R4
   \   000000B2   0x.... 0x....      BL       HAL_GPIO_Init
    195          
    196            /* Deselect : Chip Select high */
    197            HAL_GPIO_WritePin(GPIOE,GPIO_PIN_3,GPIO_PIN_SET);
   \   000000B6   0x2201             MOVS     R2,#+1
   \   000000B8   0x2108             MOVS     R1,#+8
   \   000000BA   0x4620             MOV      R0,R4
   \   000000BC   0x.... 0x....      BL       HAL_GPIO_WritePin
    198             /* sop1hc */
    199            /* Configure the SPI interrupt priority */
    200            HAL_NVIC_SetPriority(SPI1_IRQn, INTERRUPT_PRI_SDO12, 0);
   \   000000C0   0x2200             MOVS     R2,#+0
   \   000000C2   0x2101             MOVS     R1,#+1
   \   000000C4   0x2023             MOVS     R0,#+35
   \   000000C6   0x.... 0x....      BL       HAL_NVIC_SetPriority
    201          
    202            HAL_NVIC_EnableIRQ(SPI1_IRQn);
   \   000000CA   0x2023             MOVS     R0,#+35
   \   000000CC   0x.... 0x....      BL       HAL_NVIC_EnableIRQ
    203            //SPI_I2S_ITConfig(SPI1, SPI_I2S_IT_RXNE, ENABLE);
    204            //__HAL_SPI_ENABLE_IT(SPI1,SPI_IT_TXE);
    205          
    206            /* Enable SPI1  */
    207            //__HAL_SPI_ENABLE(SPI1);
    208          
    209          }
   \   000000D0   0xB006             ADD      SP,SP,#+24
   \   000000D2   0xBD10             POP      {R4,PC}          ;; return
    210          

   \                                 In section .text, align 2, keep-with-next
    211          void mySPI_SendData(uint8_t adress, uint8_t data)
    212          {
   \                     mySPI_SendData: (+1)
   \   00000000   0x.... 0x....      LDR.W    R2,??DataTable12_2
   \   00000004   0x6812             LDR      R2,[R2, #+0]
    213           
    214          while(!__HAL_SPI_GET_FLAG(&spi1_ins, SPI_FLAG_TXE)); 
   \                     ??mySPI_SendData_0: (+1)
   \   00000006   0x6893             LDR      R3,[R2, #+8]
   \   00000008   0x079B             LSLS     R3,R3,#+30
   \   0000000A   0xD5FC             BPL.N    ??mySPI_SendData_0
    215          SPI_I2S_SendData(SPI1, adress);
   \   0000000C   0x.... 0x....      LDR.W    R3,??DataTable15  ;; 0x4001300c
   \   00000010   0x6018             STR      R0,[R3, #+0]
    216          
    217          while(!__HAL_SPI_GET_FLAG(&spi1_ins, SPI_FLAG_RXNE));
   \                     ??mySPI_SendData_1: (+1)
   \   00000012   0x6890             LDR      R0,[R2, #+8]
   \   00000014   0x07C0             LSLS     R0,R0,#+31
   \   00000016   0xD5FC             BPL.N    ??mySPI_SendData_1
    218          SPI_I2S_ReceiveData(SPI1);
   \   00000018   0x6818             LDR      R0,[R3, #+0]
    219          
    220          while(!!__HAL_SPI_GET_FLAG(&spi1_ins, SPI_FLAG_TXE)); 
   \                     ??mySPI_SendData_2: (+1)
   \   0000001A   0x6890             LDR      R0,[R2, #+8]
   \   0000001C   0x0780             LSLS     R0,R0,#+30
   \   0000001E   0xD4FC             BMI.N    ??mySPI_SendData_2
    221          SPI_I2S_SendData(SPI1, data);
   \   00000020   0x6019             STR      R1,[R3, #+0]
    222          
    223          while(!!__HAL_SPI_GET_FLAG(&spi1_ins, SPI_FLAG_RXNE));
   \                     ??mySPI_SendData_3: (+1)
   \   00000022   0x6890             LDR      R0,[R2, #+8]
   \   00000024   0x07C0             LSLS     R0,R0,#+31
   \   00000026   0xD4FC             BMI.N    ??mySPI_SendData_3
    224          SPI_I2S_ReceiveData(SPI1);
   \   00000028   0x6818             LDR      R0,[R3, #+0]
    225           
    226          }
   \   0000002A   0x4770             BX       LR               ;; return
    227          
    228          /**
    229            * @brief  This function handles AUDIO_REC_SPI global interrupt request.
    230            * @param  None
    231            * @retval None
    232          */
    233          

   \                                 In section .text, align 2, keep-with-next
    234          void SPI1_IRQHandler(void)
    235          {  
    236                uint16_t tmpTest;
    237          	  static uint8_t stLR,stLROld;
                 	                 ^
Warning[Pe177]: variable "stLR" was declared but never referenced
    238          	
    239          	  /* SPI in mode Receiver ----------------------------------------------------*/
    240          	  if(
    241          //	     (__HAL_SPI_GET_FLAG(&hi2s1, SPI_FLAG_OVR) == RESET)&&
    242          //	     (__HAL_SPI_GET_FLAG(&hi2s1, SPI_FLAG_RXNE) != RESET)&&
    243          		 (__HAL_I2S_GET_IT_SOURCE(&hi2s1, SPI_IT_RXNE) != RESET))
   \                     SPI1_IRQHandler: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable15_1
   \   00000004   0x69C1             LDR      R1,[R0, #+28]
   \   00000006   0x6849             LDR      R1,[R1, #+4]
   \   00000008   0x0649             LSLS     R1,R1,#+25
   \   0000000A   0xD56A             BPL.N    ??SPI1_IRQHandler_0
    244          	  {
    245          	
    246          
    247          	   tmpTest =  SPI_I2S_ReceiveData(SPI1);
   \   0000000C   0x.... 0x....      LDR.W    R1,??DataTable15  ;; 0x4001300c
   \   00000010   0x6809             LDR      R1,[R1, #+0]
    248          	
    249          	   /* Left-Right Mic data */
    250          	   //stLR= HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_4);
    251          	
    252          		if (I2S2_stLR==GPIO_PIN_SET)
   \   00000012   0x7902             LDRB     R2,[R0, #+4]
   \   00000014   0x7883             LDRB     R3,[R0, #+2]
   \   00000016   0x2B01             CMP      R3,#+1
   \   00000018   0xD12E             BNE.N    ??SPI1_IRQHandler_1
    253          		{
    254          			if (stLROld==GPIO_PIN_RESET)
   \   0000001A   0xB37A             CBZ.N    R2,??SPI1_IRQHandler_2
    255          			{
    256          				SPI1_stNipple = (tmpTest);
    257          
    258          			}
    259          			else
    260          			{
    261          				 vRawSens1 = (tmpTest);
   \   0000001C   0x8101             STRH     R1,[R0, #+8]
    262             		         WaveRec_idxTest++;
   \   0000001E   0x88C1             LDRH     R1,[R0, #+6]
   \   00000020   0x1C49             ADDS     R1,R1,#+1
   \   00000022   0x80C1             STRH     R1,[R0, #+6]
    263          				   /* Recording Audio Data */						 
    264          				   switch (buffer_switch)
   \   00000024   0x.... 0x....      LDR.W    R1,??DataTable15_2
   \   00000028   0x7809             LDRB     R1,[R1, #+0]
   \   0000002A   0xB119             CBZ.N    R1,??SPI1_IRQHandler_3
   \   0000002C   0x2902             CMP      R1,#+2
   \   0000002E   0xD017             BEQ.N    ??SPI1_IRQHandler_4
   \   00000030   0xD30A             BCC.N    ??SPI1_IRQHandler_5
   \   00000032   0xE056             B.N      ??SPI1_IRQHandler_0
    265          				   {
    266          							case BUF1_PLAY:
    267          									Buffer2.bufMIC1[WaveRec_idxSens1++] = vRawSens1;								
   \                     ??SPI1_IRQHandler_3: (+1)
   \   00000034   0x.... 0x....      LDR.W    R1,??DataTable15_3
   \   00000038   0x880A             LDRH     R2,[R1, #+0]
   \   0000003A   0x1C53             ADDS     R3,R2,#+1
   \   0000003C   0x800B             STRH     R3,[R1, #+0]
   \   0000003E   0xF9B0 0x1008      LDRSH    R1,[R0, #+8]
   \   00000042   0x.... 0x....      LDR.W    R3,??DataTable15_4  ;; 0xc00080a0
   \   00000046   0xE008             B.N      ??SPI1_IRQHandler_6
    268          									break;
    269          							case BUF2_PLAY:
    270          									Buffer3.bufMIC1[WaveRec_idxSens1++] = vRawSens1;
   \                     ??SPI1_IRQHandler_5: (+1)
   \   00000048   0x.... 0x....      LDR.W    R1,??DataTable15_3
   \   0000004C   0x880A             LDRH     R2,[R1, #+0]
   \   0000004E   0x1C53             ADDS     R3,R2,#+1
   \   00000050   0x800B             STRH     R3,[R1, #+0]
   \   00000052   0xF9B0 0x1008      LDRSH    R1,[R0, #+8]
   \   00000056   0x.... 0x....      LDR.W    R3,??DataTable15_5  ;; 0xc0010140
   \                     ??SPI1_IRQHandler_6: (+1)
   \   0000005A   0xF823 0x1012      STRH     R1,[R3, R2, LSL #+1]
    271          									break;
   \   0000005E   0xE040             B.N      ??SPI1_IRQHandler_0
    272          							case BUF3_PLAY:
    273          									Buffer1.bufMIC1[WaveRec_idxSens1++] = vRawSens1;									
   \                     ??SPI1_IRQHandler_4: (+1)
   \   00000060   0x.... 0x....      LDR.W    R1,??DataTable15_3
   \   00000064   0x880A             LDRH     R2,[R1, #+0]
   \   00000066   0x1C53             ADDS     R3,R2,#+1
   \   00000068   0x0052             LSLS     R2,R2,#+1
   \   0000006A   0x800B             STRH     R3,[R1, #+0]
   \   0000006C   0xF9B0 0x1008      LDRSH    R1,[R0, #+8]
   \   00000070   0xF1A2 0x4280      SUB      R2,R2,#+1073741824
   \   00000074   0x8011             STRH     R1,[R2, #+0]
    274          									break;
   \   00000076   0xE034             B.N      ??SPI1_IRQHandler_0
    275          							default:
    276          									break; 
    277          				   
    278          				   	}
    279          			}
    280          		}
    281          		else
    282          		{
    283          			if (stLROld==GPIO_PIN_SET)
   \                     ??SPI1_IRQHandler_1: (+1)
   \   00000078   0x2A01             CMP      R2,#+1
   \   0000007A   0xD101             BNE.N    ??SPI1_IRQHandler_7
    284          			{
    285          			  SPI1_stNipple = (tmpTest);  
   \                     ??SPI1_IRQHandler_2: (+1)
   \   0000007C   0x8281             STRH     R1,[R0, #+20]
   \   0000007E   0xE030             B.N      ??SPI1_IRQHandler_0
    286          
    287          			}
    288          			else
    289          			{
    290          			  vRawSens2 = (tmpTest);
   \                     ??SPI1_IRQHandler_7: (+1)
   \   00000080   0x8141             STRH     R1,[R0, #+10]
    291           	          WaveRec_idxTest++;
   \   00000082   0x88C1             LDRH     R1,[R0, #+6]
   \   00000084   0x1C49             ADDS     R1,R1,#+1
   \   00000086   0x80C1             STRH     R1,[R0, #+6]
    292          			  	   /* Recording Audio Data */						 
    293          				   switch (buffer_switch)
   \   00000088   0x.... 0x....      LDR.W    R1,??DataTable15_2
   \   0000008C   0x7809             LDRB     R1,[R1, #+0]
   \   0000008E   0xB119             CBZ.N    R1,??SPI1_IRQHandler_8
   \   00000090   0x2902             CMP      R1,#+2
   \   00000092   0xD019             BEQ.N    ??SPI1_IRQHandler_9
   \   00000094   0xD30C             BCC.N    ??SPI1_IRQHandler_10
   \   00000096   0xE024             B.N      ??SPI1_IRQHandler_0
    294          				   {
    295          							case BUF1_PLAY:
    296          									Buffer2.bufMIC2[WaveRec_idxSens2++] = vRawSens2;								
   \                     ??SPI1_IRQHandler_8: (+1)
   \   00000098   0x.... 0x....      LDR.W    R1,??DataTable16_1
   \   0000009C   0x880A             LDRH     R2,[R1, #+0]
   \   0000009E   0x1C53             ADDS     R3,R2,#+1
   \   000000A0   0x800B             STRH     R3,[R1, #+0]
   \   000000A2   0x.... 0x....      LDR.W    R3,??DataTable15_4  ;; 0xc00080a0
   \   000000A6   0xF9B0 0x100A      LDRSH    R1,[R0, #+10]
   \   000000AA   0xEB03 0x0242      ADD      R2,R3,R2, LSL #+1
   \   000000AE   0xE015             B.N      ??SPI1_IRQHandler_11
    297          									break;
    298          							case BUF2_PLAY:
    299          									Buffer3.bufMIC2[WaveRec_idxSens2++] = vRawSens2;
   \                     ??SPI1_IRQHandler_10: (+1)
   \   000000B0   0x.... 0x....      LDR.W    R1,??DataTable16_1
   \   000000B4   0x880A             LDRH     R2,[R1, #+0]
   \   000000B6   0x1C53             ADDS     R3,R2,#+1
   \   000000B8   0x800B             STRH     R3,[R1, #+0]
   \   000000BA   0x.... 0x....      LDR.W    R3,??DataTable15_5  ;; 0xc0010140
   \   000000BE   0xF9B0 0x100A      LDRSH    R1,[R0, #+10]
   \   000000C2   0xEB03 0x0242      ADD      R2,R3,R2, LSL #+1
   \   000000C6   0xE009             B.N      ??SPI1_IRQHandler_11
    300          									break;
    301          							case BUF3_PLAY:
    302          									Buffer1.bufMIC2[WaveRec_idxSens2++] = vRawSens2;									
   \                     ??SPI1_IRQHandler_9: (+1)
   \   000000C8   0x.... 0x....      LDR.W    R1,??DataTable16_1
   \   000000CC   0x880A             LDRH     R2,[R1, #+0]
   \   000000CE   0x1C53             ADDS     R3,R2,#+1
   \   000000D0   0x0052             LSLS     R2,R2,#+1
   \   000000D2   0x800B             STRH     R3,[R1, #+0]
   \   000000D4   0xF9B0 0x100A      LDRSH    R1,[R0, #+10]
   \   000000D8   0xF1A2 0x4280      SUB      R2,R2,#+1073741824
   \                     ??SPI1_IRQHandler_11: (+1)
   \   000000DC   0xF241 0x0314      MOVW     R3,#+4116
   \   000000E0   0x5299             STRH     R1,[R3, R2]
    303          									break;
    304          							default:
    305          									break; 
    306          				   
    307          				   	}
    308          			  }
    309          
    310          			} 	
    311          		}
    312          	   
    313          
    314          #if 0
    315                 if (iSDO12<4*AUDIO_OUT_BUFFER_SIZE)
    316          	   {
    317                     TestSDO12[iSDO12++]=tmpTest;
    318          	   }
    319          	   else
    320          	   {
    321                     iSDO12=0;
    322          	   }
    323          		if ((WaveRec_idxSens1 < (2*AUDIO_OUT_BUFFER_SIZE+5))&&(WaveRec_idxSens2 < (2*AUDIO_OUT_BUFFER_SIZE+5)))
    324          	//			  &&(stLR!=stLROld))
    325          		{
    326          	/*-------------------------------------------------------------------------------------------------------------
    327          				  
    328          		Sequence  Record Data					  Processing Data				  Player Data
    329          				  
    330          		1-------  Buffer1						  Buffer2						  Buffer3 BUF3_PLAY)
    331          				  
    332          		2-------  Buffer3						  Buffer1						  Buffer2 (BUF2_PLAY)		  
    333          				  
    334          		3-------  Buffer2						  Buffer3						  Buffer1 (BUF1_PLAY)
    335          	 ---------------------------------------------------------------------------------------------------------------*/
    336          				  /* Recording Audio Data */						 
    337          				   switch (buffer_switch)
    338          				   {
    339          							case BUF1_PLAY:
    340          
    341                                          if (WaveRec_idxSens1<=WaveRec_idxSens2)
    342          									Buffer2.bufMIC1[WaveRec_idxSens1++] = vRawSens1;
    343          							    else
    344          									Buffer2.bufMIC2[WaveRec_idxSens2++] = vRawSens2;									
    345          
    346          	
    347          									break;
    348          							case BUF2_PLAY:
    349                                          if (WaveRec_idxSens1<=WaveRec_idxSens2)
    350          									Buffer3.bufMIC1[WaveRec_idxSens1++] = vRawSens1;
    351          							    else
    352          									Buffer3.bufMIC2[WaveRec_idxSens2++] = vRawSens2;	
    353          
    354          									break;
    355          							case BUF3_PLAY:
    356                                          if (WaveRec_idxSens1<=WaveRec_idxSens2)
    357          									Buffer1.bufMIC1[WaveRec_idxSens1++] = vRawSens1;
    358          							    else
    359          									Buffer1.bufMIC2[WaveRec_idxSens2++] = vRawSens2;									
    360          
    361          									break;
    362          							default:
    363          									break; 
    364          				   }
    365          			
    366          		 } 
    367          #endif		
    368          
    369          		/* Update Old value */	  
    370          		stLROld=I2S2_stLR;
   \                     ??SPI1_IRQHandler_0: (+1)
   \   000000E2   0x7881             LDRB     R1,[R0, #+2]
   \   000000E4   0x7101             STRB     R1,[R0, #+4]
    371          
    372          				 
    373          } 	 
   \   000000E6   0x4770             BX       LR               ;; return
   \   000000E8                      REQUIRE Buffer2
   \   000000E8                      REQUIRE Buffer3
   \   000000E8                      REQUIRE Buffer1
    374          
    375          
    376          
    377          
    378          /**
    379            * @brief  This function handles AUDIO_REC_SPI global interrupt request.
    380            * @param  None
    381            * @retval None
    382          */
    383          

   \                                 In section .text, align 2, keep-with-next
    384          void SPI2_IRQHandler(void)
    385          {      
    386              uint16_t app;
    387              
    388          
    389            /* Check if data are available in SPI Data register */
    390             if (
    391          //	   (__HAL_SPI_GET_FLAG(&hi2s2, SPI_FLAG_OVR) == RESET)&&
    392          //   	    (__HAL_SPI_GET_FLAG(&hi2s2, SPI_FLAG_RXNE) != RESET)&&
    393             	    (__HAL_I2S_GET_IT_SOURCE(&hi2s2, SPI_IT_RXNE)!=RESET)
    394             	  )
   \                     SPI2_IRQHandler: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable16_2
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x6840             LDR      R0,[R0, #+4]
   \   00000008   0x0640             LSLS     R0,R0,#+25
   \   0000000A   0xD400             BMI.N    ??SPI2_IRQHandler_0
   \   0000000C   0x4770             BX       LR
    395             {
    396              
    397               app = SPI_I2S_ReceiveData(SPI2);   
   \                     ??SPI2_IRQHandler_0: (+1)
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable16_3  ;; 0x4000380c
    398               //SPI_I2S_SendData(SPI2, 3333);
    399          
    400          	 I2S2_stLR= HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_4);
   \   00000012   0x2110             MOVS     R1,#+16
   \   00000014   0xB538             PUSH     {R3-R5,LR}
   \   00000016   0x6805             LDR      R5,[R0, #+0]
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable12_1  ;; 0x40020000
   \   0000001C   0x.... 0x....      LDR.W    R4,??DataTable15_1
   \   00000020   0x.... 0x....      BL       HAL_GPIO_ReadPin
   \   00000024   0x70A0             STRB     R0,[R4, #+2]
    401          
    402          	 if (I2S2_stLR==GPIO_PIN_SET)
   \   00000026   0x78A0             LDRB     R0,[R4, #+2]
   \   00000028   0x2801             CMP      R0,#+1
   \   0000002A   0x78E0             LDRB     R0,[R4, #+3]
   \   0000002C   0xD133             BNE.N    ??SPI2_IRQHandler_1
    403          	 {
    404                  if (I2S2_stLROld==GPIO_PIN_SET)
   \   0000002E   0x2801             CMP      R0,#+1
   \   00000030   0xD032             BEQ.N    ??SPI2_IRQHandler_2
    405                  {
    406                      I2S2_stNipple = app;           
    407                  }
    408          		else
    409          		{
    410          
    411          			 vRawSens3 = app;
    412          			switch (buffer_switch)
   \   00000032   0x.... 0x....      LDR.W    R0,??DataTable15_2
   \   00000036   0x81E5             STRH     R5,[R4, #+14]
   \   00000038   0x7800             LDRB     R0,[R0, #+0]
   \   0000003A   0xB118             CBZ.N    R0,??SPI2_IRQHandler_3
   \   0000003C   0x2802             CMP      R0,#+2
   \   0000003E   0xD01D             BEQ.N    ??SPI2_IRQHandler_4
   \   00000040   0xD30E             BCC.N    ??SPI2_IRQHandler_5
   \   00000042   0xE059             B.N      ??SPI2_IRQHandler_6
    413          			{
    414          				case BUF1_PLAY:
    415          					Buffer2.bufMIC3[WaveRec_idxSens3++] = vRawSens3;								
   \                     ??SPI2_IRQHandler_3: (+1)
   \   00000044   0x.... 0x....      LDR.W    R0,??DataTable16_4
   \   00000048   0x8801             LDRH     R1,[R0, #+0]
   \   0000004A   0x1C4A             ADDS     R2,R1,#+1
   \   0000004C   0x8002             STRH     R2,[R0, #+0]
   \   0000004E   0x.... 0x....      LDR.W    R2,??DataTable15_4  ;; 0xc00080a0
   \   00000052   0xEB02 0x0141      ADD      R1,R2,R1, LSL #+1
   \   00000056   0xF9B4 0x000E      LDRSH    R0,[R4, #+14]
   \   0000005A   0xF242 0x0228      MOVW     R2,#+8232
   \   0000005E   0xE04A             B.N      ??SPI2_IRQHandler_7
    416          					break;
    417          				case BUF2_PLAY:
    418          					Buffer3.bufMIC3[WaveRec_idxSens3++] = vRawSens3;
   \                     ??SPI2_IRQHandler_5: (+1)
   \   00000060   0x.... 0x....      LDR.W    R0,??DataTable16_4
   \   00000064   0x8801             LDRH     R1,[R0, #+0]
   \   00000066   0x1C4A             ADDS     R2,R1,#+1
   \   00000068   0x8002             STRH     R2,[R0, #+0]
   \   0000006A   0x.... 0x....      LDR.W    R2,??DataTable15_5  ;; 0xc0010140
   \   0000006E   0xEB02 0x0141      ADD      R1,R2,R1, LSL #+1
   \   00000072   0xF9B4 0x000E      LDRSH    R0,[R4, #+14]
   \   00000076   0xF242 0x0228      MOVW     R2,#+8232
   \   0000007A   0xE03C             B.N      ??SPI2_IRQHandler_7
    419          					break;
    420          				case BUF3_PLAY:
    421          					Buffer1.bufMIC3[WaveRec_idxSens3++] = vRawSens3;									
   \                     ??SPI2_IRQHandler_4: (+1)
   \   0000007C   0x.... 0x....      LDR.W    R0,??DataTable16_4
   \   00000080   0x8801             LDRH     R1,[R0, #+0]
   \   00000082   0x1C4A             ADDS     R2,R1,#+1
   \   00000084   0x0049             LSLS     R1,R1,#+1
   \   00000086   0x8002             STRH     R2,[R0, #+0]
   \   00000088   0xF9B4 0x000E      LDRSH    R0,[R4, #+14]
   \   0000008C   0xF1A1 0x4180      SUB      R1,R1,#+1073741824
   \   00000090   0xF242 0x0228      MOVW     R2,#+8232
   \   00000094   0xE02F             B.N      ??SPI2_IRQHandler_7
    422          					break;
    423          				default:
    424          					break; 
    425          			}
    426          
    427          		}
    428          	 }
    429          	 else
    430          	 {
    431                  if (I2S2_stLROld==GPIO_PIN_RESET)
   \                     ??SPI2_IRQHandler_1: (+1)
   \   00000096   0xB908             CBNZ.N   R0,??SPI2_IRQHandler_8
    432                  {
    433                      I2S2_stNipple = app;
   \                     ??SPI2_IRQHandler_2: (+1)
   \   00000098   0x82E5             STRH     R5,[R4, #+22]
   \   0000009A   0xE02D             B.N      ??SPI2_IRQHandler_6
    434          
    435                  }
    436          		else
    437          		{
    438                      vRawSens4 =app;
    439          			switch (buffer_switch)
   \                     ??SPI2_IRQHandler_8: (+1)
   \   0000009C   0x.... 0x....      LDR.W    R0,??DataTable15_2
   \   000000A0   0x81A5             STRH     R5,[R4, #+12]
   \   000000A2   0x7800             LDRB     R0,[R0, #+0]
   \   000000A4   0xB118             CBZ.N    R0,??SPI2_IRQHandler_9
   \   000000A6   0x2802             CMP      R0,#+2
   \   000000A8   0xD019             BEQ.N    ??SPI2_IRQHandler_10
   \   000000AA   0xD30C             BCC.N    ??SPI2_IRQHandler_11
   \   000000AC   0xE024             B.N      ??SPI2_IRQHandler_6
    440          			{	 
    441          				case BUF1_PLAY:
    442          					Buffer2.bufMIC4[WaveRec_idxSens4++] = vRawSens4;								
   \                     ??SPI2_IRQHandler_9: (+1)
   \   000000AE   0x.... 0x....      LDR.W    R0,??DataTable17
   \   000000B2   0x8801             LDRH     R1,[R0, #+0]
   \   000000B4   0x1C4A             ADDS     R2,R1,#+1
   \   000000B6   0x8002             STRH     R2,[R0, #+0]
   \   000000B8   0x.... 0x....      LDR.W    R2,??DataTable15_4  ;; 0xc00080a0
   \   000000BC   0xF9B4 0x000C      LDRSH    R0,[R4, #+12]
   \   000000C0   0xEB02 0x0141      ADD      R1,R2,R1, LSL #+1
   \   000000C4   0xE015             B.N      ??SPI2_IRQHandler_12
    443          					break;
    444          				case BUF2_PLAY:
    445          					Buffer3.bufMIC4[WaveRec_idxSens4++] = vRawSens4;
   \                     ??SPI2_IRQHandler_11: (+1)
   \   000000C6   0x.... 0x....      LDR.W    R0,??DataTable17
   \   000000CA   0x8801             LDRH     R1,[R0, #+0]
   \   000000CC   0x1C4A             ADDS     R2,R1,#+1
   \   000000CE   0x8002             STRH     R2,[R0, #+0]
   \   000000D0   0x.... 0x....      LDR.W    R2,??DataTable15_5  ;; 0xc0010140
   \   000000D4   0xF9B4 0x000C      LDRSH    R0,[R4, #+12]
   \   000000D8   0xEB02 0x0141      ADD      R1,R2,R1, LSL #+1
   \   000000DC   0xE009             B.N      ??SPI2_IRQHandler_12
    446          					break;
    447          				case BUF3_PLAY:
    448          					Buffer1.bufMIC4[WaveRec_idxSens4++] = vRawSens4;									
   \                     ??SPI2_IRQHandler_10: (+1)
   \   000000DE   0x.... 0x....      LDR.W    R0,??DataTable17
   \   000000E2   0x8801             LDRH     R1,[R0, #+0]
   \   000000E4   0x1C4A             ADDS     R2,R1,#+1
   \   000000E6   0x0049             LSLS     R1,R1,#+1
   \   000000E8   0x8002             STRH     R2,[R0, #+0]
   \   000000EA   0xF9B4 0x000C      LDRSH    R0,[R4, #+12]
   \   000000EE   0xF1A1 0x4180      SUB      R1,R1,#+1073741824
   \                     ??SPI2_IRQHandler_12: (+1)
   \   000000F2   0xF243 0x023C      MOVW     R2,#+12348
   \                     ??SPI2_IRQHandler_7: (+1)
   \   000000F6   0x5250             STRH     R0,[R2, R1]
    449          					break;
    450          				default:
    451          					break; 
    452          			}
    453          		}
    454          	 }
    455          
    456          
    457          	 
    458          #if 0
    459          	  if (iSDO34<4*AUDIO_OUT_BUFFER_SIZE)
    460          	 {
    461          		 TestSDO34[iSDO34++]=app;
    462          	 }
    463          	 else
    464          	 {
    465          		 iSDO34=0;
    466          	 }
    467          
    468          	 if ((WaveRec_idxSens3 < (2*AUDIO_OUT_BUFFER_SIZE+5))&&(WaveRec_idxSens4 < (2*AUDIO_OUT_BUFFER_SIZE+5)))
    469          //             &&(I2S2_stLR!=I2S2_stLROld))
    470          	 {
    471          /*-------------------------------------------------------------------------------------------------------------
    472          			  
    473          	Sequence  Record Data                     Processing Data                 Player Data
    474          			  
    475          	1-------  Buffer1                         Buffer2                         Buffer3 (BUF3_PLAY)
    476          			  
    477          	2-------  Buffer3                         Buffer1                         Buffer2 (BUF2_PLAY)		  
    478          			  
    479          	3-------  Buffer2                         Buffer3                         Buffer1 (BUF1_PLAY)
    480           ---------------------------------------------------------------------------------------------------------------*/
    481          		/* Recording Audio Data */			             
    482          		 switch (buffer_switch)
    483          		 {
    484          			  case BUF1_PLAY:
    485                            if (WaveRec_idxSens3<=WaveRec_idxSens4) 
    486                                Buffer2.bufMIC3[WaveRec_idxSens3++] = vRawSens3;
    487          				  else
    488                                Buffer2.bufMIC4[WaveRec_idxSens4++] = vRawSens4;			  
    489          
    490          				  break;
    491          			  case BUF2_PLAY:
    492                            if (WaveRec_idxSens3<=WaveRec_idxSens4) 
    493                                Buffer3.bufMIC3[WaveRec_idxSens3++] = vRawSens3;
    494          				  else
    495                                Buffer3.bufMIC4[WaveRec_idxSens4++] = vRawSens4;			   
    496          				  break;
    497          			  case BUF3_PLAY:
    498                            if (WaveRec_idxSens3<=WaveRec_idxSens4) 
    499                                Buffer1.bufMIC3[WaveRec_idxSens3++] = vRawSens3;
    500          				  else
    501                                Buffer1.bufMIC4[WaveRec_idxSens4++] = vRawSens4;
    502          				  break;
    503          			  default:
    504          				  break; 
    505          		 }
    506          		
    507          	 }          
    508          #endif		  
    509          	 I2S2_stLROld = I2S2_stLR;
   \                     ??SPI2_IRQHandler_6: (+1)
   \   000000F8   0x78A0             LDRB     R0,[R4, #+2]
   \   000000FA   0x70E0             STRB     R0,[R4, #+3]
    510          
    511             }
    512          
    513          }
   \   000000FC   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   \   000000FE                      REQUIRE Buffer2
   \   000000FE                      REQUIRE Buffer3
   \   000000FE                      REQUIRE Buffer1
    514          
    515          

   \                                 In section .text, align 2, keep-with-next
    516          void SPI4_IRQHandler(void)
    517          {
    518            static uint8_t Main_stLR, Main_stLROld;
                                  ^
Warning[Pe177]: variable "Main_stLR" was declared but never referenced
    519          
    520          
    521            /* SPI in mode Receiver ----------------------------------------------------*/
    522            if(
    523          //    (__HAL_SPI_GET_FLAG(&hspi4, SPI_FLAG_OVR) == RESET)&&
    524          //    (__HAL_SPI_GET_FLAG(&hspi4, SPI_FLAG_RXNE) != RESET)&&
    525               (__HAL_SPI_GET_IT_SOURCE(&hspi4, SPI_IT_RXNE) != RESET))
   \                     SPI4_IRQHandler: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable16_5
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x6840             LDR      R0,[R0, #+4]
   \   00000008   0x0640             LSLS     R0,R0,#+25
   \   0000000A   0xD400             BMI.N    ??SPI4_IRQHandler_0
   \   0000000C   0x4770             BX       LR
    526            {
    527          
    528                  uint16_t test;
    529                  test =  SPI_I2S_ReceiveData(SPI4);
   \                     ??SPI4_IRQHandler_0: (+1)
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable16_6  ;; 0x4001340c
   \   00000012   0xB410             PUSH     {R4}
   \   00000014   0x6801             LDR      R1,[R0, #+0]
    530          
    531                  /* Left-Right Mic data */
    532                  //Main_stLR= HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_4);
    533          
    534                  /* STM32F746 read data from STA321MP, the data is shifted few bit     */
    535                  /* Data from STA321MP is 32bit formart                                */
    536                  /* SPI is just able to read 16 bit format                             */
    537                  /* Therefore, it needs to correct                                     */
    538                  
    539                  /* ---------------------------+++++++++++++++++++++++++++++++---------*/
    540                  /*                  ______DATAL_____              ______DATAR_____    */
    541                  /*                  _____vRawSens5__              ______vRawSens6_    */       
    542          	if (I2S2_stLR==GPIO_PIN_SET)
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable15_1
   \   0000001A   0x7942             LDRB     R2,[R0, #+5]
   \   0000001C   0x7883             LDRB     R3,[R0, #+2]
   \   0000001E   0xB289             UXTH     R1,R1
   \   00000020   0x2B01             CMP      R3,#+1
   \   00000022   0xD138             BNE.N    ??SPI4_IRQHandler_1
    543          	{
    544                      if (Main_stLROld==GPIO_PIN_SET)
   \   00000024   0x2A01             CMP      R2,#+1
   \   00000026   0xD037             BEQ.N    ??SPI4_IRQHandler_2
    545                      {
    546                         SPI4_stNipple = (test);    
    547                      }
    548                      else
    549                      {
    550                         vRawSens5 =((test>>SPI4_stPosShft)|(SPI4_stNipple<<(SDOLEN-SPI4_stPosShft)));	
                                ^
Warning[Pa082]: undefined behavior: the order of volatile accesses is
          undefined in this statement
   \   00000028   0x7842             LDRB     R2,[R0, #+1]
   \   0000002A   0xF9B0 0x3018      LDRSH    R3,[R0, #+24]
    551                         if (WaveRec_idxSens5 < (2*AUDIO_OUT_BUFFER_SIZE+5))
   \   0000002E   0xF640 0x0405      MOVW     R4,#+2053
   \   00000032   0x40D1             LSRS     R1,R1,R2
   \   00000034   0x7842             LDRB     R2,[R0, #+1]
   \   00000036   0xF1C2 0x0210      RSB      R2,R2,#+16
   \   0000003A   0xFA03 0xF202      LSL      R2,R3,R2
   \   0000003E   0x4311             ORRS     R1,R2,R1
   \   00000040   0x.... 0x....      LDR.W    R2,??DataTable16_7
   \   00000044   0x8201             STRH     R1,[R0, #+16]
   \   00000046   0x8813             LDRH     R3,[R2, #+0]
   \   00000048   0x42A3             CMP      R3,R4
   \   0000004A   0xDA5A             BGE.N    ??SPI4_IRQHandler_3
    552                         {
    553                              /*-------------------------------------------------------------------------------------------------------------                                             
    554                              Sequence  Record Data                     Processing Data                 Player Data
    555                                                
    556                              1-------  Buffer1                         Buffer2                         Buffer3 BUF3_PLAY)
    557                                                
    558                              2-------  Buffer3                         Buffer1                         Buffer2 (BUF2_PLAY)		  
    559                                                
    560                              3-------  Buffer2                         Buffer3                         Buffer1 (BUF1_PLAY)
    561                               ---------------------------------------------------------------------------------------------------------------*/                     
    562                               /* Recording Audio Data */			             
    563                               switch (buffer_switch)
   \   0000004C   0x.... 0x....      LDR.W    R3,??DataTable15_2
   \   00000050   0x781B             LDRB     R3,[R3, #+0]
   \   00000052   0xB11B             CBZ.N    R3,??SPI4_IRQHandler_4
   \   00000054   0x2B02             CMP      R3,#+2
   \   00000056   0xD015             BEQ.N    ??SPI4_IRQHandler_5
   \   00000058   0xD30A             BCC.N    ??SPI4_IRQHandler_6
   \   0000005A   0xE052             B.N      ??SPI4_IRQHandler_3
    564                               {
    565                                   case BUF1_PLAY:
    566                                       Buffer2.bufMIC5[WaveRec_idxSens5++] = vRawSens5;
   \                     ??SPI4_IRQHandler_4: (+1)
   \   0000005C   0x8813             LDRH     R3,[R2, #+0]
   \   0000005E   0x1C5C             ADDS     R4,R3,#+1
   \   00000060   0x8014             STRH     R4,[R2, #+0]
   \   00000062   0x.... 0x....      LDR.W    R2,??DataTable15_4  ;; 0xc00080a0
   \   00000066   0xEB02 0x0243      ADD      R2,R2,R3, LSL #+1
   \   0000006A   0xF244 0x0350      MOVW     R3,#+16464
   \   0000006E   0xE047             B.N      ??SPI4_IRQHandler_7
    567          
    568                                       break;
    569                                   case BUF2_PLAY:
    570                                       Buffer3.bufMIC5[WaveRec_idxSens5++] = vRawSens5;
   \                     ??SPI4_IRQHandler_6: (+1)
   \   00000070   0x8813             LDRH     R3,[R2, #+0]
   \   00000072   0x1C5C             ADDS     R4,R3,#+1
   \   00000074   0x8014             STRH     R4,[R2, #+0]
   \   00000076   0x.... 0x....      LDR.W    R2,??DataTable17_1  ;; 0xc0010140
   \   0000007A   0xEB02 0x0243      ADD      R2,R2,R3, LSL #+1
   \   0000007E   0xF244 0x0350      MOVW     R3,#+16464
   \   00000082   0xE03D             B.N      ??SPI4_IRQHandler_7
    571          
    572                                       break;
    573                                   case BUF3_PLAY:
    574                                       Buffer1.bufMIC5[WaveRec_idxSens5++] = vRawSens5;
   \                     ??SPI4_IRQHandler_5: (+1)
   \   00000084   0x8813             LDRH     R3,[R2, #+0]
   \   00000086   0x1C5C             ADDS     R4,R3,#+1
   \   00000088   0x8014             STRH     R4,[R2, #+0]
   \   0000008A   0x005A             LSLS     R2,R3,#+1
   \   0000008C   0xF1A2 0x4280      SUB      R2,R2,#+1073741824
   \   00000090   0xF244 0x0350      MOVW     R3,#+16464
   \   00000094   0xE034             B.N      ??SPI4_IRQHandler_7
    575          
    576                                       break;                          
    577                                   default:
    578                                       break;
    579                               }
    580                         }
    581          	   }
    582                  }
    583          	else
    584          	{
    585                    if (Main_stLROld==GPIO_PIN_RESET)
   \                     ??SPI4_IRQHandler_1: (+1)
   \   00000096   0xB90A             CBNZ.N   R2,??SPI4_IRQHandler_8
    586                    {
    587                        SPI4_stNipple = (test);	  
   \                     ??SPI4_IRQHandler_2: (+1)
   \   00000098   0x8301             STRH     R1,[R0, #+24]
   \   0000009A   0xE032             B.N      ??SPI4_IRQHandler_3
    588          
    589                    }
    590                    else
    591                    {
    592                         vRawSens6 =((test>>SPI4_stPosShft)|(SPI4_stNipple<<(SDOLEN-SPI4_stPosShft)));
                                ^
Warning[Pa082]: undefined behavior: the order of volatile accesses is
          undefined in this statement
   \                     ??SPI4_IRQHandler_8: (+1)
   \   0000009C   0x7842             LDRB     R2,[R0, #+1]
   \   0000009E   0xF9B0 0x3018      LDRSH    R3,[R0, #+24]
    593                         if (WaveRec_idxSens6 < (2*AUDIO_OUT_BUFFER_SIZE+5))
   \   000000A2   0xF640 0x0405      MOVW     R4,#+2053
   \   000000A6   0x40D1             LSRS     R1,R1,R2
   \   000000A8   0x7842             LDRB     R2,[R0, #+1]
   \   000000AA   0xF1C2 0x0210      RSB      R2,R2,#+16
   \   000000AE   0xFA03 0xF202      LSL      R2,R3,R2
   \   000000B2   0x4311             ORRS     R1,R2,R1
   \   000000B4   0x.... 0x....      LDR.W    R2,??DataTable16_8
   \   000000B8   0x8241             STRH     R1,[R0, #+18]
   \   000000BA   0x8813             LDRH     R3,[R2, #+0]
   \   000000BC   0x42A3             CMP      R3,R4
   \   000000BE   0xDA20             BGE.N    ??SPI4_IRQHandler_3
    594                         {
    595                              /*-------------------------------------------------------------------------------------------------------------                                             
    596                              Sequence  Record Data                     Processing Data                 Player Data
    597                                                
    598                              1-------  Buffer1                         Buffer2                         Buffer3 BUF3_PLAY)
    599                                                
    600                              2-------  Buffer3                         Buffer1                         Buffer2 (BUF2_PLAY)		  
    601                                                
    602                              3-------  Buffer2                         Buffer3                         Buffer1 (BUF1_PLAY)
    603                               ---------------------------------------------------------------------------------------------------------------*/                 
    604                                /* Recording Audio Data */			             
    605                               switch (buffer_switch)
   \   000000C0   0x.... 0x....      LDR.W    R3,??DataTable15_2
   \   000000C4   0x781B             LDRB     R3,[R3, #+0]
   \   000000C6   0xB11B             CBZ.N    R3,??SPI4_IRQHandler_9
   \   000000C8   0x2B02             CMP      R3,#+2
   \   000000CA   0xD011             BEQ.N    ??SPI4_IRQHandler_10
   \   000000CC   0xD308             BCC.N    ??SPI4_IRQHandler_11
   \   000000CE   0xE018             B.N      ??SPI4_IRQHandler_3
    606                               {
    607                                   case BUF1_PLAY:
    608                                       Buffer2.bufMIC6[WaveRec_idxSens6++] = vRawSens6;
   \                     ??SPI4_IRQHandler_9: (+1)
   \   000000D0   0x8813             LDRH     R3,[R2, #+0]
   \   000000D2   0x1C5C             ADDS     R4,R3,#+1
   \   000000D4   0x8014             STRH     R4,[R2, #+0]
   \   000000D6   0x.... 0x....      LDR.W    R2,??DataTable15_4  ;; 0xc00080a0
   \   000000DA   0xEB02 0x0243      ADD      R2,R2,R3, LSL #+1
   \   000000DE   0xE00D             B.N      ??SPI4_IRQHandler_12
    609           
    610                                       break;
    611                                   case BUF2_PLAY:
    612                                       Buffer3.bufMIC6[WaveRec_idxSens6++] = vRawSens6;
   \                     ??SPI4_IRQHandler_11: (+1)
   \   000000E0   0x8813             LDRH     R3,[R2, #+0]
   \   000000E2   0x1C5C             ADDS     R4,R3,#+1
   \   000000E4   0x8014             STRH     R4,[R2, #+0]
   \   000000E6   0x.... 0x....      LDR.W    R2,??DataTable17_1  ;; 0xc0010140
   \   000000EA   0xEB02 0x0243      ADD      R2,R2,R3, LSL #+1
   \   000000EE   0xE005             B.N      ??SPI4_IRQHandler_12
    613                 
    614                                       break;
    615                                   case BUF3_PLAY:
    616                                       Buffer1.bufMIC6[WaveRec_idxSens6++] = vRawSens6;
   \                     ??SPI4_IRQHandler_10: (+1)
   \   000000F0   0x8813             LDRH     R3,[R2, #+0]
   \   000000F2   0x1C5C             ADDS     R4,R3,#+1
   \   000000F4   0x8014             STRH     R4,[R2, #+0]
   \   000000F6   0x005A             LSLS     R2,R3,#+1
   \   000000F8   0xF1A2 0x4280      SUB      R2,R2,#+1073741824
   \                     ??SPI4_IRQHandler_12: (+1)
   \   000000FC   0xF245 0x0364      MOVW     R3,#+20580
   \                     ??SPI4_IRQHandler_7: (+1)
   \   00000100   0x5299             STRH     R1,[R3, R2]
    617           
    618                                       break;                          
    619                                   default:
    620                                       break;
    621                               }
    622                         }
    623                    }		
    624          	}
    625          #if 0
    626          	/* The code to store data in to buffer for testing purpose */
    627          	if (iSDO56<4*AUDIO_OUT_BUFFER_SIZE)
    628          	{
    629          		TestSDO56[iSDO56++]=test;
    630          	}
    631          	else
    632          	{
    633          		iSDO56=0;
    634          	}
    635          #endif
    636          
    637          	/* Update Old value */	  
    638          	Main_stLROld=I2S2_stLR;	  
   \                     ??SPI4_IRQHandler_3: (+1)
   \   00000102   0x7881             LDRB     R1,[R0, #+2]
   \   00000104   0x7141             STRB     R1,[R0, #+5]
    639               
    640            }      
    641          }
   \   00000106   0xBC10             POP      {R4}
   \   00000108   0x4770             BX       LR               ;; return
   \   0000010A                      REQUIRE Buffer2
   \   0000010A                      REQUIRE Buffer3
   \   0000010A                      REQUIRE Buffer1

   \                                 In section .bss, align 4
   \                     WaveRecord_flgInt:
   \   00000000                      DS8 1
   \                     SPI4_stPosShft:
   \   00000001                      DS8 1
   \                     I2S2_stLR:
   \   00000002                      DS8 1
   \                     I2S2_stLROld:
   \   00000003                      DS8 1
   \   00000004                      DS8 1
   \   00000005                      DS8 1
   \                     WaveRec_idxTest:
   \   00000006                      DS8 2
   \                     vRawSens1:
   \   00000008                      DS8 2
   \                     vRawSens2:
   \   0000000A                      DS8 2
   \                     vRawSens4:
   \   0000000C                      DS8 2
   \                     vRawSens3:
   \   0000000E                      DS8 2
   \                     vRawSens5:
   \   00000010                      DS8 2
   \                     vRawSens6:
   \   00000012                      DS8 2
   \                     SPI1_stNipple:
   \   00000014                      DS8 2
   \                     I2S2_stNipple:
   \   00000016                      DS8 2
   \                     SPI4_stNipple:
   \   00000018                      DS8 2
   \   0000001A                      DS8 2
   \                     hi2s1:
   \   0000001C                      DS8 64

   \                                 In section .bss, align 4
   \                     hspi1:
   \   00000000                      DS8 100

   \                                 In section .bss, align 4
   \                     hspi2:
   \   00000000                      DS8 100

   \                                 In section .bss, align 4
   \                     spi1_ins:
   \   00000000                      DS8 100

   \                                 In section .bss, align 4
   \                     spi2_ins:
   \   00000000                      DS8 100

   \                                 In section .bss, align 4
   \                     hi2s2:
   \   00000000                      DS8 64

   \                                 In section .bss, align 4
   \                     hdma_spi2_tx:
   \   00000000                      DS8 80

   \                                 In section .bss, align 4
   \                     hdma_spi3_tx:
   \   00000000                      DS8 80

   \                                 In section .bss, align 4
   \                     hdma_spi5_rx:
   \   00000000                      DS8 80

   \                                 In section .bss, align 4
   \                     hdma_spi6_rx:
   \   00000000                      DS8 80

   \                                 In section .bss, align 2
   \                     idxFrmPDMMic8:
   \   00000000                      DS8 2
    642          
    643          
    644          
    645          

   \                                 In section .text, align 2, keep-with-next
    646          void SPI5_IRQHandler(void)
    647          {
   \                     SPI5_IRQHandler: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    648            //static uint16_t stNipple;
    649            //static uint8_t stLR, stOder;
    650          
    651            /* USER CODE BEGIN SPI5_IRQn 0 */
    652          
    653            /* USER CODE END SPI5_IRQn 0 */
    654            //HAL_SPI_IRQHandler(&hspi5);
    655            /* USER CODE BEGIN SPI5_IRQn 1 */
    656          
    657            /* USER CODE END SPI5_IRQn 1 */
    658              /* Check if data are available in SPI Data register */
    659            /* SPI in mode Receiver ----------------------------------------------------*/
    660            if(
    661               (__HAL_SPI_GET_FLAG(&hspi5, SPI_FLAG_OVR) == RESET)&&
    662               (__HAL_SPI_GET_FLAG(&hspi5, SPI_FLAG_RXNE) != RESET)&&
    663               (__HAL_SPI_GET_IT_SOURCE(&hspi5, SPI_IT_RXNE) != RESET))
   \   00000002   0x.... 0x....      LDR.W    R4,??DataTable17_2
   \   00000006   0x6860             LDR      R0,[R4, #+4]
   \   00000008   0x6881             LDR      R1,[R0, #+8]
   \   0000000A   0x0649             LSLS     R1,R1,#+25
   \   0000000C   0xD432             BMI.N    ??SPI5_IRQHandler_0
   \   0000000E   0x6881             LDR      R1,[R0, #+8]
   \   00000010   0x07C9             LSLS     R1,R1,#+31
   \   00000012   0xD52F             BPL.N    ??SPI5_IRQHandler_0
   \   00000014   0x6840             LDR      R0,[R0, #+4]
   \   00000016   0x0640             LSLS     R0,R0,#+25
   \   00000018   0xD52C             BPL.N    ??SPI5_IRQHandler_0
    664            {
    665          
    666          
    667             uint16_t test;
    668             test =  SPI_I2S_ReceiveData(SPI5);
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable17_3  ;; 0x4001500c
    669             SPI5->DR = 3333;
   \   0000001E   0xF640 0x5205      MOVW     R2,#+3333
   \   00000022   0x6801             LDR      R1,[R0, #+0]
   \   00000024   0x6002             STR      R2,[R0, #+0]
    670          
    671            pDataMic8[idxMic8++] =	HTONS(test);
   \   00000026   0x8822             LDRH     R2,[R4, #+0]
   \   00000028   0x.... 0x....      LDR.W    R0,??DataTable17_4
   \   0000002C   0xB28B             UXTH     R3,R1
   \   0000002E   0x0209             LSLS     R1,R1,#+8
   \   00000030   0xEA41 0x2113      ORR      R1,R1,R3, LSR #+8
   \   00000034   0xF820 0x1012      STRH     R1,[R0, R2, LSL #+1]
   \   00000038   0x1C51             ADDS     R1,R2,#+1
   \   0000003A   0x8021             STRH     R1,[R4, #+0]
    672            
    673            //volume = 64;
    674            
    675            if (idxMic8>=64)
   \   0000003C   0xB289             UXTH     R1,R1
   \   0000003E   0x2940             CMP      R1,#+64
   \   00000040   0xDB18             BLT.N    ??SPI5_IRQHandler_0
    676            {
    677          	if (buffer_switch != 1)
   \   00000042   0x.... 0x....      LDR.W    R5,??DataTable15_2
   \   00000046   0x6EA1             LDR      R1,[R4, #+104]
   \   00000048   0x.... 0x....      LDR.W    R2,??DataTable17_5
   \   0000004C   0x.... 0x....      LDR.W    R3,??DataTable17_6
   \   00000050   0x782D             LDRB     R5,[R5, #+0]
    678          	{
    679          		PDM_Filter_64_LSB((uint8_t *)pDataMic8,(uint16_t *)(bufPCMSens8 + cntPos*16), volume ,
                 		^
Warning[Pa082]: undefined behavior: the order of volatile accesses is
          undefined in this statement
    680          						  (PDMFilter_InitStruct *)&Filter[0]);
    681          	}
    682          	else
    683          	{
    684          		PDM_Filter_64_LSB((uint8_t *)pDataMic8,(uint16_t *)(bufPCMSens8 + cntPos*16), volume , 
                 		^
Warning[Pa082]: undefined behavior: the order of volatile accesses is
          undefined in this statement
    685          						  (PDMFilter_InitStruct *)&Filter[0]);   
   \   00000052   0x1D1B             ADDS     R3,R3,#+4
   \   00000054   0x7812             LDRB     R2,[R2, #+0]
   \   00000056   0x8865             LDRH     R5,[R4, #+2]
   \   00000058   0xEB01 0x1145      ADD      R1,R1,R5, LSL #+5
   \   0000005C   0x.... 0x....      BL       PDM_Filter_64_LSB
    686          	}
    687          	idxMic8=0;
   \   00000060   0x2000             MOVS     R0,#+0
   \   00000062   0x8020             STRH     R0,[R4, #+0]
    688          	cntPos++;
   \   00000064   0x8860             LDRH     R0,[R4, #+2]
   \   00000066   0x1C40             ADDS     R0,R0,#+1
   \   00000068   0x8060             STRH     R0,[R4, #+2]
    689          	if (cntPos>=256) cntPos=0;
   \   0000006A   0x8860             LDRH     R0,[R4, #+2]
   \   0000006C   0x28FF             CMP      R0,#+255
   \   0000006E   0xBFC4             ITT      GT 
   \   00000070   0x2000             MOVGT    R0,#+0
   \   00000072   0x8060             STRHGT   R0,[R4, #+2]
    690            }
    691              
    692            }
    693            
    694          }
   \                     ??SPI5_IRQHandler_0: (+1)
   \   00000074   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    695          
    696          /* SPI5 init function */
    697          
    698          

   \                                 In section .text, align 2, keep-with-next
    699          void SPI6_IRQHandler(void)
    700          {
   \                     SPI6_IRQHandler: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    701            /* SPI in mode Receiver ----------------------------------------------------*/
    702            if(
    703          //     (__HAL_SPI_GET_FLAG(&hspi6, SPI_FLAG_OVR) == RESET)&&
    704               (__HAL_SPI_GET_FLAG(&hspi6, SPI_FLAG_TXE) != RESET)&&
    705               (__HAL_SPI_GET_IT_SOURCE(&hspi6, SPI_IT_TXE) != RESET))
   \   00000002   0x.... 0x....      LDR.W    R4,??DataTable17_7
   \   00000006   0x6860             LDR      R0,[R4, #+4]
   \   00000008   0x6881             LDR      R1,[R0, #+8]
   \   0000000A   0x0789             LSLS     R1,R1,#+30
   \   0000000C   0xD52F             BPL.N    ??SPI6_IRQHandler_0
   \   0000000E   0x6840             LDR      R0,[R0, #+4]
   \   00000010   0x0600             LSLS     R0,R0,#+24
   \   00000012   0xD52C             BPL.N    ??SPI6_IRQHandler_0
    706            {
    707          
    708          
    709               uint16_t test;
    710               test =  SPI_I2S_ReceiveData(SPI6);
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable17_8  ;; 0x4001540c
    711               SPI6->DR = 3333;
   \   00000018   0xF640 0x5205      MOVW     R2,#+3333
   \   0000001C   0x6801             LDR      R1,[R0, #+0]
   \   0000001E   0x6002             STR      R2,[R0, #+0]
    712          
    713              pDataMic7[idxMic7++] =	HTONS(test);
   \   00000020   0x8822             LDRH     R2,[R4, #+0]
   \   00000022   0x.... 0x....      LDR.W    R0,??DataTable17_9
   \   00000026   0xB28B             UXTH     R3,R1
   \   00000028   0x0209             LSLS     R1,R1,#+8
   \   0000002A   0xEA41 0x2113      ORR      R1,R1,R3, LSR #+8
   \   0000002E   0xF820 0x1012      STRH     R1,[R0, R2, LSL #+1]
   \   00000032   0x1C51             ADDS     R1,R2,#+1
   \   00000034   0x8021             STRH     R1,[R4, #+0]
    714          
    715              //volume = 64;
    716          
    717              if (idxMic7>=64)
   \   00000036   0xB289             UXTH     R1,R1
   \   00000038   0x2940             CMP      R1,#+64
   \   0000003A   0xDB18             BLT.N    ??SPI6_IRQHandler_0
    718              {
    719                if (buffer_switch != 1)
   \   0000003C   0x.... 0x....      LDR.W    R5,??DataTable15_2
   \   00000040   0x6EA1             LDR      R1,[R4, #+104]
   \   00000042   0x.... 0x....      LDR.W    R2,??DataTable17_5
   \   00000046   0x.... 0x....      LDR.W    R3,??DataTable17_6
   \   0000004A   0x782D             LDRB     R5,[R5, #+0]
    720                {
    721                        PDM_Filter_64_LSB((uint8_t *)pDataMic7,(uint16_t *)(bufPCMSens7 + cntPos7*16), volume ,
                               ^
Warning[Pa082]: undefined behavior: the order of volatile accesses is
          undefined in this statement
    722                                                          (PDMFilter_InitStruct *)&Filter[1]);
    723                }
    724                else
    725                {
    726                        PDM_Filter_64_LSB((uint8_t *)pDataMic7,(uint16_t *)(bufPCMSens7 + cntPos7*16), volume , 
                               ^
Warning[Pa082]: undefined behavior: the order of volatile accesses is
          undefined in this statement
    727                                                          (PDMFilter_InitStruct *)&Filter[1]);   
   \   0000004C   0x3338             ADDS     R3,R3,#+56
   \   0000004E   0x7812             LDRB     R2,[R2, #+0]
   \   00000050   0x8865             LDRH     R5,[R4, #+2]
   \   00000052   0xEB01 0x1145      ADD      R1,R1,R5, LSL #+5
   \   00000056   0x.... 0x....      BL       PDM_Filter_64_LSB
    728                }
    729                idxMic7=0;
   \   0000005A   0x2000             MOVS     R0,#+0
   \   0000005C   0x8020             STRH     R0,[R4, #+0]
    730                cntPos7++;
   \   0000005E   0x8860             LDRH     R0,[R4, #+2]
   \   00000060   0x1C40             ADDS     R0,R0,#+1
   \   00000062   0x8060             STRH     R0,[R4, #+2]
    731                if (cntPos7>=256) cntPos7=0;
   \   00000064   0x8860             LDRH     R0,[R4, #+2]
   \   00000066   0x28FF             CMP      R0,#+255
   \   00000068   0xBFC4             ITT      GT 
   \   0000006A   0x2000             MOVGT    R0,#+0
   \   0000006C   0x8060             STRHGT   R0,[R4, #+2]
    732              }
    733              
    734            }
    735          }
   \                     ??SPI6_IRQHandler_0: (+1)
   \   0000006E   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    736          
    737          
    738          

   \                                 In section .text, align 2, keep-with-next
    739          void MIC1TO6_Init(void)
    740          {
   \                     MIC1TO6_Init: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
    741          	SPI5_Init();
   \   00000002   0x.... 0x....      BL       SPI5_Init
    742          	SPI6_Init();
   \   00000006   0x.... 0x....      BL       SPI6_Init
    743          	StartRecMic7_8();
   \   0000000A   0xF44F 0x5280      MOV      R2,#+4096
   \   0000000E   0x.... 0x....      LDR.W    R1,??DataTable17_10
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable17_11
   \   00000016   0x.... 0x....      LDR.W    R4,??DataTable12_1  ;; 0x40020000
   \   0000001A   0x.... 0x....      BL       HAL_SPI_Receive_DMA
   \   0000001E   0xF44F 0x5280      MOV      R2,#+4096
   \   00000022   0x.... 0x....      LDR.W    R1,??DataTable17_12
   \   00000026   0x.... 0x....      LDR.W    R0,??DataTable17_13
   \   0000002A   0x.... 0x....      BL       HAL_SPI_Receive_DMA
   \   0000002E   0x.... 0x....      LDR.W    R0,??DataTable17_6
   \   00000032   0x2100             MOVS     R1,#+0
   \   00000034   0x7001             STRB     R1,[R0, #+0]
   \   00000036   0x7041             STRB     R1,[R0, #+1]
    744          	while(HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_4)==GPIO_PIN_SET);
   \                     ??MIC1TO6_Init_0: (+1)
   \   00000038   0x2110             MOVS     R1,#+16
   \   0000003A   0x4620             MOV      R0,R4
   \   0000003C   0x.... 0x....      BL       HAL_GPIO_ReadPin
   \   00000040   0x2801             CMP      R0,#+1
   \   00000042   0xD0F9             BEQ.N    ??MIC1TO6_Init_0
    745          	while(HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_4)==GPIO_PIN_SET);
   \                     ??MIC1TO6_Init_1: (+1)
   \   00000044   0x2110             MOVS     R1,#+16
   \   00000046   0x4620             MOV      R0,R4
   \   00000048   0x.... 0x....      BL       HAL_GPIO_ReadPin
   \   0000004C   0x2801             CMP      R0,#+1
   \   0000004E   0xD0F9             BEQ.N    ??MIC1TO6_Init_1
    746          	while(HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_4)==GPIO_PIN_RESET);
   \                     ??MIC1TO6_Init_2: (+1)
   \   00000050   0x2110             MOVS     R1,#+16
   \   00000052   0x4620             MOV      R0,R4
   \   00000054   0x.... 0x....      BL       HAL_GPIO_ReadPin
   \   00000058   0x2800             CMP      R0,#+0
   \   0000005A   0xD0F9             BEQ.N    ??MIC1TO6_Init_2
    747          	while(HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_4)==GPIO_PIN_SET);
   \                     ??MIC1TO6_Init_3: (+1)
   \   0000005C   0x2110             MOVS     R1,#+16
   \   0000005E   0x4620             MOV      R0,R4
   \   00000060   0x.... 0x....      BL       HAL_GPIO_ReadPin
   \   00000064   0x2801             CMP      R0,#+1
   \   00000066   0xD0F9             BEQ.N    ??MIC1TO6_Init_3
    748              HAL_Delay(2);
   \   00000068   0x2002             MOVS     R0,#+2
   \   0000006A   0x.... 0x....      BL       HAL_Delay
    749          
    750          
    751            while(HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_4)==GPIO_PIN_SET);
   \                     ??MIC1TO6_Init_4: (+1)
   \   0000006E   0x2110             MOVS     R1,#+16
   \   00000070   0x4620             MOV      R0,R4
   \   00000072   0x.... 0x....      BL       HAL_GPIO_ReadPin
   \   00000076   0x2801             CMP      R0,#+1
   \   00000078   0xD0F9             BEQ.N    ??MIC1TO6_Init_4
    752            while(HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_4)==GPIO_PIN_RESET);
   \                     ??MIC1TO6_Init_5: (+1)
   \   0000007A   0x2110             MOVS     R1,#+16
   \   0000007C   0x4620             MOV      R0,R4
   \   0000007E   0x.... 0x....      BL       HAL_GPIO_ReadPin
   \   00000082   0x2800             CMP      R0,#+0
   \   00000084   0xD0F9             BEQ.N    ??MIC1TO6_Init_5
    753            I2S1_Init(); /* I2S1   --> SDO12 */
   \   00000086   0x.... 0x....      LDR.W    R6,??DataTable15_1
   \   0000008A   0x.... 0x....      LDR.W    R0,??DataTable17_14  ;; 0x40013000
   \   0000008E   0x61F0             STR      R0,[R6, #+28]
   \   00000090   0x2020             MOVS     R0,#+32
   \   00000092   0x6270             STR      R0,[R6, #+36]
   \   00000094   0x2000             MOVS     R0,#+0
   \   00000096   0x62B0             STR      R0,[R6, #+40]
   \   00000098   0xF44F 0x7580      MOV      R5,#+256
   \   0000009C   0x62F0             STR      R0,[R6, #+44]
   \   0000009E   0x2008             MOVS     R0,#+8
   \   000000A0   0x6370             STR      R0,[R6, #+52]
   \   000000A2   0x2001             MOVS     R0,#+1
   \   000000A4   0xF44F 0x577A      MOV      R7,#+16000
   \   000000A8   0x63B0             STR      R0,[R6, #+56]
   \   000000AA   0x6235             STR      R5,[R6, #+32]
   \   000000AC   0xF106 0x001C      ADD      R0,R6,#+28
   \   000000B0   0x6337             STR      R7,[R6, #+48]
   \   000000B2   0x.... 0x....      BL       HAL_I2S_Init
   \   000000B6   0x69F0             LDR      R0,[R6, #+28]
   \   000000B8   0x6841             LDR      R1,[R0, #+4]
   \   000000BA   0xF041 0x0140      ORR      R1,R1,#0x40
   \   000000BE   0x6041             STR      R1,[R0, #+4]
   \   000000C0   0x69C1             LDR      R1,[R0, #+28]
   \   000000C2   0xF441 0x6180      ORR      R1,R1,#0x400
   \   000000C6   0x61C1             STR      R1,[R0, #+28]
    754            while(HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_4)==GPIO_PIN_SET);
   \                     ??MIC1TO6_Init_6: (+1)
   \   000000C8   0x2110             MOVS     R1,#+16
   \   000000CA   0x4620             MOV      R0,R4
   \   000000CC   0x.... 0x....      BL       HAL_GPIO_ReadPin
   \   000000D0   0x2801             CMP      R0,#+1
   \   000000D2   0xD0F9             BEQ.N    ??MIC1TO6_Init_6
    755            while(HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_4)==GPIO_PIN_RESET);
   \                     ??MIC1TO6_Init_7: (+1)
   \   000000D4   0x2110             MOVS     R1,#+16
   \   000000D6   0x4620             MOV      R0,R4
   \   000000D8   0x.... 0x....      BL       HAL_GPIO_ReadPin
   \   000000DC   0x2800             CMP      R0,#+0
   \   000000DE   0xD0F9             BEQ.N    ??MIC1TO6_Init_7
    756            I2S2_Init(); /* I2S2   --> SDO34 */
   \   000000E0   0x.... 0x....      LDR.W    R6,??DataTable16_2
   \   000000E4   0x.... 0x....      LDR.W    R0,??DataTable17_15  ;; 0x40003800
   \   000000E8   0x6030             STR      R0,[R6, #+0]
   \   000000EA   0x2020             MOVS     R0,#+32
   \   000000EC   0x60B0             STR      R0,[R6, #+8]
   \   000000EE   0x2000             MOVS     R0,#+0
   \   000000F0   0x60F0             STR      R0,[R6, #+12]
   \   000000F2   0x6130             STR      R0,[R6, #+16]
   \   000000F4   0x61B0             STR      R0,[R6, #+24]
   \   000000F6   0x2001             MOVS     R0,#+1
   \   000000F8   0x61F0             STR      R0,[R6, #+28]
   \   000000FA   0x4630             MOV      R0,R6
   \   000000FC   0x6075             STR      R5,[R6, #+4]
   \   000000FE   0x6177             STR      R7,[R6, #+20]
   \   00000100   0x.... 0x....      BL       HAL_I2S_Init
   \   00000104   0x6830             LDR      R0,[R6, #+0]
   \   00000106   0x6841             LDR      R1,[R0, #+4]
   \   00000108   0xF041 0x0140      ORR      R1,R1,#0x40
   \   0000010C   0x6041             STR      R1,[R0, #+4]
   \   0000010E   0x69C1             LDR      R1,[R0, #+28]
   \   00000110   0xF441 0x6180      ORR      R1,R1,#0x400
   \   00000114   0x61C1             STR      R1,[R0, #+28]
    757            while(HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_4)==GPIO_PIN_SET);
   \                     ??MIC1TO6_Init_8: (+1)
   \   00000116   0x2110             MOVS     R1,#+16
   \   00000118   0x4620             MOV      R0,R4
   \   0000011A   0x.... 0x....      BL       HAL_GPIO_ReadPin
   \   0000011E   0x2801             CMP      R0,#+1
   \   00000120   0xD0F9             BEQ.N    ??MIC1TO6_Init_8
    758            while(HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_4)==GPIO_PIN_RESET);
   \                     ??MIC1TO6_Init_9: (+1)
   \   00000122   0x2110             MOVS     R1,#+16
   \   00000124   0x4620             MOV      R0,R4
   \   00000126   0x.... 0x....      BL       HAL_GPIO_ReadPin
   \   0000012A   0x2800             CMP      R0,#+0
   \   0000012C   0xD0F9             BEQ.N    ??MIC1TO6_Init_9
    759            SPI4_Init(); /* SPI4   --> SDO56 */
   \   0000012E   0xE8BD 0x40F1      POP      {R0,R4-R7,LR}
   \   00000132   0x....             B.N      SPI4_Init
    760          
    761          
    762          }
    763          

   \                                 In section .text, align 2, keep-with-next
    764          void StartRecMic7_8 (void)
    765          {
   \                     StartRecMic7_8: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    766          	  HAL_SPI_Receive_DMA(&hspi5,( uint8_t *)TestSDO7,4*AUDIO_OUT_BUFFER_SIZE);
   \   00000002   0xF44F 0x5280      MOV      R2,#+4096
   \   00000006   0x.... 0x....      LDR.W    R1,??DataTable17_10
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable17_11
   \   0000000E   0x.... 0x....      BL       HAL_SPI_Receive_DMA
    767          #if (0)
    768          	  HAL_SPI_Receive_DMA(&hspi6,( uint8_t *)TestSDO8,4*(AUDIO_SAMPLING_FREQUENCY/1000));
    769          #else
    770          	  HAL_SPI_Receive_DMA(&hspi6,( uint8_t *)TestSDO8,4*AUDIO_OUT_BUFFER_SIZE);
   \   00000012   0xF44F 0x5280      MOV      R2,#+4096
   \   00000016   0x.... 0x....      LDR.W    R1,??DataTable17_12
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable17_13
   \   0000001E   0x.... 0x....      BL       HAL_SPI_Receive_DMA
    771          #endif
    772          	  swtSDO7 = 0;
   \   00000022   0x.... 0x....      LDR.W    R0,??DataTable17_6
   \   00000026   0x2100             MOVS     R1,#+0
   \   00000028   0x7001             STRB     R1,[R0, #+0]
    773          	  swtSDO8 = 0;
   \   0000002A   0x7041             STRB     R1,[R0, #+1]
    774          
    775          }
   \   0000002C   0xBD01             POP      {R0,PC}          ;; return
    776          
    777          /* I2S1 init function */
    778          /* Read data of MIC12 */
    779          static void I2S1_Init(void)
    780          {
    781          #if 1
    782            hi2s1.Instance = SPI1;
    783            hi2s1.Init.Mode = I2S_MODE_SLAVE_RX;
    784            hi2s1.Init.Standard = I2S_STANDARD_LSB;
    785            hi2s1.Init.DataFormat = I2S_DATAFORMAT_16B;
    786            hi2s1.Init.MCLKOutput = I2S_MCLKOUTPUT_DISABLE;
    787            hi2s1.Init.AudioFreq = I2S_AUDIOFREQ_16K;
    788            hi2s1.Init.CPOL = I2S_CPOL_HIGH;
    789            hi2s1.Init.ClockSource = I2S_CLOCK_EXTERNAL;
    790            HAL_I2S_Init(&hi2s1);
    791          
    792            /* Enable TXE and ERR interrupt */
    793           __HAL_I2S_ENABLE_IT(&hi2s1, (I2S_IT_RXNE));
    794           
    795           __HAL_I2S_ENABLE(&hi2s1);
    796          #else
    797          	hspi1.Instance = SPI1;
    798          	hspi1.Init.Mode = SPI_MODE_SLAVE;
    799          	hspi1.Init.Direction = SPI_DIRECTION_2LINES;//SPI_DIRECTION_2LINES_RXONLY
    800          	hspi1.Init.DataSize = SPI_DATASIZE_16BIT;
    801          	hspi1.Init.CLKPolarity = SPI_POLARITY_HIGH;
    802          	hspi1.Init.CLKPhase = SPI_PHASE_1EDGE;
    803          	hspi1.Init.NSS = SPI_NSS_SOFT;//SPI_NSS_HARD_INPUT
    804          	hspi1.Init.FirstBit = SPI_FIRSTBIT_MSB;
    805          	hspi1.Init.TIMode = SPI_TIMODE_DISABLE;
    806          	hspi1.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLED;
    807          	hspi1.Init.CRCPolynomial = 7;
    808          	hspi1.Init.CRCLength = SPI_CRC_LENGTH_DATASIZE;
    809          	hspi1.Init.NSSPMode = SPI_NSS_PULSE_DISABLE;
    810          	//hspi4.RxISR = SPI5_CallBack;
    811          	HAL_SPI_Init(&hspi1);
    812          
    813          	  //HAL_GPIO_WritePin(GPIOF,GPIO_PIN_6,GPIO_PIN_SET);
    814            /* Enable TXE, RXNE and ERR interrupt */
    815           __HAL_SPI_ENABLE_IT(&hspi1, (SPI_IT_RXNE| SPI_IT_ERR));
    816          
    817           __HAL_SPI_ENABLE(&hspi1);
    818          
    819          #endif
    820          }
    821          
    822          /* I2S2 init function */
    823          /* Read data of MIC34 */
    824          
    825          static void I2S2_Init(void)
    826          {
    827          
    828          #if 1
    829           //HAL_I2S_DeInit(&hi2s2);
    830           hi2s2.Instance = SPI2;
    831           hi2s2.Init.Mode = I2S_MODE_SLAVE_RX;//I2S_MODE_MASTER_RX
    832           hi2s2.Init.Standard = I2S_STANDARD_LSB;//I2S_STANDARD_LSB
    833           hi2s2.Init.DataFormat = I2S_DATAFORMAT_16B;
    834           hi2s2.Init.MCLKOutput = I2S_MCLKOUTPUT_DISABLE;
    835           hi2s2.Init.AudioFreq = I2S_AUDIOFREQ_16K;
    836           hi2s2.Init.CPOL = I2S_CPOL_LOW;
    837           hi2s2.Init.ClockSource = I2S_CLOCK_EXTERNAL;
    838          
    839           HAL_I2S_Init(&hi2s2);
    840           /* Enable TXE and ERR interrupt */
    841           __HAL_I2S_ENABLE_IT(&hi2s2, (I2S_IT_RXNE));
    842           __HAL_I2S_ENABLE(&hi2s2);
    843          
    844          #else
    845             hspi2.Instance = SPI2;
    846             hspi2.Init.Mode = SPI_MODE_SLAVE;
    847             hspi2.Init.Direction = SPI_DIRECTION_2LINES;//SPI_DIRECTION_2LINES_RXONLY
    848             hspi2.Init.DataSize = SPI_DATASIZE_16BIT;
    849             hspi2.Init.CLKPolarity = SPI_POLARITY_HIGH;
    850             hspi2.Init.CLKPhase = SPI_PHASE_1EDGE;
    851             hspi2.Init.NSS = SPI_NSS_SOFT;//SPI_NSS_HARD_INPUT
    852             hspi2.Init.FirstBit = SPI_FIRSTBIT_MSB;
    853             hspi2.Init.TIMode = SPI_TIMODE_DISABLE;
    854             hspi2.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLED;
    855             hspi2.Init.CRCPolynomial = 7;
    856             hspi2.Init.CRCLength = SPI_CRC_LENGTH_DATASIZE;
    857             hspi2.Init.NSSPMode = SPI_NSS_PULSE_DISABLE;
    858             HAL_SPI_Init(&hspi2);
    859          
    860          	 //HAL_GPIO_WritePin(GPIOF,GPIO_PIN_6,GPIO_PIN_SET);
    861           /* Enable TXE, RXNE and ERR interrupt */
    862          __HAL_SPI_ENABLE_IT(&hspi2, (SPI_IT_RXNE| SPI_IT_ERR));
    863          
    864          __HAL_SPI_ENABLE(&hspi2);
    865          
    866          #endif
    867          
    868          
    869          }
    870          
    871          /* SPI5 init function */

   \                                 In section .text, align 2, keep-with-next
    872          void SPI4_Init(void)
    873          {
   \                     SPI4_Init: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    874          
    875            hspi4.Instance = SPI4;
   \   00000002   0x.... 0x....      LDR.W    R4,??DataTable16_5
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable17_16  ;; 0x40013400
   \   0000000A   0x6020             STR      R0,[R4, #+0]
    876            hspi4.Init.Mode = SPI_MODE_SLAVE;
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x6060             STR      R0,[R4, #+4]
    877            hspi4.Init.Direction = SPI_DIRECTION_2LINES_RXONLY;//SPI_DIRECTION_2LINES_RXONLY
   \   00000010   0xF44F 0x6080      MOV      R0,#+1024
   \   00000014   0x60A0             STR      R0,[R4, #+8]
    878            hspi4.Init.DataSize = SPI_DATASIZE_16BIT;
   \   00000016   0xF44F 0x6070      MOV      R0,#+3840
   \   0000001A   0x60E0             STR      R0,[R4, #+12]
    879            hspi4.Init.CLKPolarity = SPI_POLARITY_HIGH;
   \   0000001C   0x2002             MOVS     R0,#+2
   \   0000001E   0x6120             STR      R0,[R4, #+16]
    880            hspi4.Init.CLKPhase = SPI_PHASE_1EDGE;
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0x6160             STR      R0,[R4, #+20]
    881            hspi4.Init.NSS = SPI_NSS_SOFT;//SPI_NSS_HARD_INPUT
   \   00000024   0xF44F 0x7000      MOV      R0,#+512
   \   00000028   0x61A0             STR      R0,[R4, #+24]
    882            hspi4.Init.FirstBit = SPI_FIRSTBIT_MSB;
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0x6220             STR      R0,[R4, #+32]
    883            hspi4.Init.TIMode = SPI_TIMODE_DISABLE;
   \   0000002E   0x6260             STR      R0,[R4, #+36]
    884            hspi4.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLED;
   \   00000030   0x62A0             STR      R0,[R4, #+40]
    885            hspi4.Init.CRCPolynomial = 7;
   \   00000032   0x2007             MOVS     R0,#+7
   \   00000034   0x62E0             STR      R0,[R4, #+44]
    886            hspi4.Init.CRCLength = SPI_CRC_LENGTH_DATASIZE;
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0x6320             STR      R0,[R4, #+48]
    887            hspi4.Init.NSSPMode = SPI_NSS_PULSE_DISABLE;
   \   0000003A   0x6360             STR      R0,[R4, #+52]
    888            HAL_SPI_Init(&hspi4);
   \   0000003C   0x4620             MOV      R0,R4
   \   0000003E   0x.... 0x....      BL       HAL_SPI_Init
    889          
    890            /* Enable TXE, RXNE and ERR interrupt */
    891           __HAL_SPI_ENABLE_IT(&hspi4, (SPI_IT_RXNE| SPI_IT_ERR));
   \   00000042   0x6820             LDR      R0,[R4, #+0]
   \   00000044   0x6841             LDR      R1,[R0, #+4]
   \   00000046   0xF041 0x0160      ORR      R1,R1,#0x60
   \   0000004A   0x6041             STR      R1,[R0, #+4]
    892          
    893           __HAL_SPI_ENABLE(&hspi4);
   \   0000004C   0x6801             LDR      R1,[R0, #+0]
   \   0000004E   0xF041 0x0140      ORR      R1,R1,#0x40
   \   00000052   0x6001             STR      R1,[R0, #+0]
    894          }
   \   00000054   0xBD10             POP      {R4,PC}          ;; return
    895          
    896          

   \                                 In section .text, align 2, keep-with-next
    897          void Mic7Rec(void)
    898          {
    899              SPI5_Init();
   \                     Mic7Rec: (+1)
   \   00000000   0x....             B.N      SPI5_Init
    900          }
    901          

   \                                 In section .text, align 2, keep-with-next
    902          void Mic8Rec(void)
    903          {
    904              SPI6_Init();
   \                     Mic8Rec: (+1)
   \   00000000   0x....             B.N      ?Subroutine0
    905          }
    906          
    907          
    908          /* SPI5 init function */

   \                                 In section .text, align 4, keep-with-next
    909          void SPI5_Init(void)
    910          {
   \                     SPI5_Init: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
    911          	
    912              /* Enable CRC module */
    913              RCC->AHB1ENR |= RCC_AHB1ENR_CRCEN;
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable12  ;; 0x40023830
    914          	for (char i=0; i< 2; i++)
   \   00000006   0x.... 0x....      LDR.W    R4,??DataTable17_17
   \   0000000A   0xED2D 0x8B02      VPUSH    {D8}
   \   0000000E   0x6801             LDR      R1,[R0, #+0]
   \   00000010   0x2502             MOVS     R5,#+2
   \   00000012   0xF44F 0x567A      MOV      R6,#+16000
   \   00000016   0xEEB2 0x8A04      VMOV.F32 S16,#10.0
   \   0000001A   0xF441 0x5180      ORR      R1,R1,#0x1000
   \   0000001E   0xEDDF 0x....      VLDR.W   S17,??DataTable11  ;; 0x45fa0000
   \   00000022   0x6001             STR      R1,[R0, #+0]
    915          	{
    916          		/* Filter LP & HP Init */
    917          		Filter[i].LP_HZ = 8000;   //sop1hc 8000
   \                     ??SPI5_Init_0: (+1)
   \   00000024   0xEDC4 0x8A01      VSTR     S17,[R4, #+4]
    918          		Filter[i].HP_HZ = 10;
    919          		Filter[i].Fs = 16000;    //sop1hc: 16000
    920          		Filter[i].Out_MicChannels = 1;
   \   00000028   0x2001             MOVS     R0,#+1
   \   0000002A   0xED84 0x8A02      VSTR     S16,[R4, #+8]
   \   0000002E   0x8026             STRH     R6,[R4, #+0]
   \   00000030   0x81E0             STRH     R0,[R4, #+14]
    921          		Filter[i].In_MicChannels = 1;
   \   00000032   0x81A0             STRH     R0,[R4, #+12]
    922          		PDM_Filter_Init((PDMFilter_InitStruct *)&Filter[i]);
   \   00000034   0x4620             MOV      R0,R4
   \   00000036   0x.... 0x....      BL       PDM_Filter_Init
    923          	}
   \   0000003A   0x3434             ADDS     R4,R4,#+52
   \   0000003C   0x1E6D             SUBS     R5,R5,#+1
   \   0000003E   0xD1F1             BNE.N    ??SPI5_Init_0
    924          
    925          
    926            hspi5.Instance = SPI5;
   \   00000040   0x.... 0x....      LDR.W    R0,??DataTable17_2
   \   00000044   0x.... 0x....      LDR.W    R1,??DataTable17_18  ;; 0x40015000
   \   00000048   0x6041             STR      R1,[R0, #+4]
    927            hspi5.Init.Mode = SPI_MODE_SLAVE;
   \   0000004A   0x2100             MOVS     R1,#+0
   \   0000004C   0x6081             STR      R1,[R0, #+8]
    928            hspi5.Init.Direction = SPI_DIRECTION_2LINES_RXONLY;//SPI_DIRECTION_2LINES_RXONLY
   \   0000004E   0xF44F 0x6180      MOV      R1,#+1024
   \   00000052   0x60C1             STR      R1,[R0, #+12]
    929            hspi5.Init.DataSize = SPI_DATASIZE_16BIT;
   \   00000054   0xF44F 0x6170      MOV      R1,#+3840
   \   00000058   0x6101             STR      R1,[R0, #+16]
    930            hspi5.Init.CLKPolarity = SPI_POLARITY_HIGH;
   \   0000005A   0x2102             MOVS     R1,#+2
   \   0000005C   0x6141             STR      R1,[R0, #+20]
    931            hspi5.Init.CLKPhase = SPI_PHASE_1EDGE;
   \   0000005E   0x2100             MOVS     R1,#+0
   \   00000060   0x6181             STR      R1,[R0, #+24]
    932            hspi5.Init.NSS = SPI_NSS_SOFT;//SPI_NSS_HARD_INPUT
   \   00000062   0xF44F 0x7100      MOV      R1,#+512
   \   00000066   0x61C1             STR      R1,[R0, #+28]
    933            hspi5.Init.FirstBit = SPI_FIRSTBIT_MSB;
   \   00000068   0x2100             MOVS     R1,#+0
   \   0000006A   0x6241             STR      R1,[R0, #+36]
    934            hspi5.Init.TIMode = SPI_TIMODE_DISABLE;
   \   0000006C   0x6281             STR      R1,[R0, #+40]
    935            hspi5.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLED;
   \   0000006E   0x62C1             STR      R1,[R0, #+44]
    936            hspi5.Init.CRCPolynomial = 7;
   \   00000070   0x2107             MOVS     R1,#+7
   \   00000072   0x6301             STR      R1,[R0, #+48]
    937            hspi5.Init.CRCLength = SPI_CRC_LENGTH_DATASIZE;
   \   00000074   0x2100             MOVS     R1,#+0
   \   00000076   0x6341             STR      R1,[R0, #+52]
    938            hspi5.Init.NSSPMode = SPI_NSS_PULSE_DISABLE;
   \   00000078   0x6381             STR      R1,[R0, #+56]
    939            //hspi5.RxISR = SPI5_CallBack;
    940            HAL_SPI_Init(&hspi5);
   \   0000007A   0x1D00             ADDS     R0,R0,#+4
   \   0000007C   0xECBD 0x8B02      VPOP     {D8}
   \   00000080   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   00000084   0x.... 0x....      B.W      HAL_SPI_Init
    941          
    942          
    943            //HAL_GPIO_WritePin(GPIOF,GPIO_PIN_6,GPIO_PIN_SET);
    944            /* Enable TXE, RXNE and ERR interrupt */
    945           //__HAL_SPI_ENABLE_IT(&hspi5, (SPI_IT_RXNE| SPI_IT_ERR));
    946          
    947           //__HAL_SPI_ENABLE(&hspi5);
    948          
    949          }
    950          

   \                                 In section .text, align 2, keep-with-next
    951          void SPI6_Init(void)
   \                     SPI6_Init: (+1)
   \   00000000   0xBF00             Nop      
    952          {
    953          	
    954            hspi6.Instance = SPI6;
   \   00000002                      REQUIRE ?Subroutine0
   \   00000002                      ;; // Fall through to label ?Subroutine0

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable17_7
   \   00000004   0x.... 0x....      LDR.W    R1,??DataTable17_19  ;; 0x40015400
   \   00000008   0x6041             STR      R1,[R0, #+4]
    955            hspi6.Init.Mode = SPI_MODE_SLAVE;
   \   0000000A   0x2100             MOVS     R1,#+0
   \   0000000C   0x6081             STR      R1,[R0, #+8]
    956            hspi6.Init.Direction = SPI_DIRECTION_2LINES_RXONLY;//SPI_DIRECTION_2LINES_RXONLY
   \   0000000E   0xF44F 0x6180      MOV      R1,#+1024
   \   00000012   0x60C1             STR      R1,[R0, #+12]
    957            hspi6.Init.DataSize = SPI_DATASIZE_16BIT;
   \   00000014   0xF44F 0x6170      MOV      R1,#+3840
   \   00000018   0x6101             STR      R1,[R0, #+16]
    958            hspi6.Init.CLKPolarity = SPI_POLARITY_HIGH;
   \   0000001A   0x2102             MOVS     R1,#+2
   \   0000001C   0x6141             STR      R1,[R0, #+20]
    959            hspi6.Init.CLKPhase = SPI_PHASE_1EDGE;
   \   0000001E   0x2100             MOVS     R1,#+0
   \   00000020   0x6181             STR      R1,[R0, #+24]
    960            hspi6.Init.NSS = SPI_NSS_SOFT;//SPI_NSS_HARD_INPUT
   \   00000022   0xF44F 0x7100      MOV      R1,#+512
   \   00000026   0x61C1             STR      R1,[R0, #+28]
    961            hspi6.Init.FirstBit = SPI_FIRSTBIT_MSB;
   \   00000028   0x2100             MOVS     R1,#+0
   \   0000002A   0x6241             STR      R1,[R0, #+36]
    962            hspi6.Init.TIMode = SPI_TIMODE_DISABLE;
   \   0000002C   0x6281             STR      R1,[R0, #+40]
    963            hspi6.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLED;
   \   0000002E   0x62C1             STR      R1,[R0, #+44]
    964            hspi6.Init.CRCPolynomial = 7;
   \   00000030   0x2107             MOVS     R1,#+7
   \   00000032   0x6301             STR      R1,[R0, #+48]
    965            hspi6.Init.CRCLength = SPI_CRC_LENGTH_DATASIZE;
   \   00000034   0x2100             MOVS     R1,#+0
   \   00000036   0x6341             STR      R1,[R0, #+52]
    966            hspi6.Init.NSSPMode = SPI_NSS_PULSE_DISABLE;
   \   00000038   0x6381             STR      R1,[R0, #+56]
    967            //hspi6.RxISR = SPI6_CallBack;
    968            HAL_SPI_Init(&hspi6);
   \   0000003A   0x1D00             ADDS     R0,R0,#+4
   \   0000003C   0x.... 0x....      B.W      HAL_SPI_Init
    969          
    970          
    971            //HAL_GPIO_WritePin(GPIOF,GPIO_PIN_6,GPIO_PIN_SET);
    972            /* Enable TXE, RXNE and ERR interrupt */
    973           //__HAL_SPI_ENABLE_IT(&hspi6, (SPI_IT_RXNE| SPI_IT_ERR));
    974          
    975           //__HAL_SPI_ENABLE(&hspi6);
    976          
    977          }
    978          
    979          
    980          
    981          

   \                                 In section .text, align 2, keep-with-next
    982          void HAL_SPI_MspInit(SPI_HandleTypeDef* hspi)
    983          {
   \                     HAL_SPI_MspInit: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0xB087             SUB      SP,SP,#+28
    984          
    985            GPIO_InitTypeDef GPIO_InitStruct;
    986            if (hspi->Instance==SPI1)
   \   00000006   0x.... 0x....      LDR.W    R1,??DataTable17_14  ;; 0x40013000
   \   0000000A   0x6820             LDR      R0,[R4, #+0]
   \   0000000C   0x4288             CMP      R0,R1
   \   0000000E   0xD131             BNE.N    ??HAL_SPI_MspInit_0
    987            {
    988          	  /* USER CODE BEGIN SPI1_MspInit 0 */
    989          	  
    990          	  /* USER CODE END SPI1_MspInit 0 */
    991          	  /* Peripheral clock enable */
    992          	  __SPI1_CLK_ENABLE();
   \   00000010   0x.... 0x....      LDR.W    R5,??DataTable12  ;; 0x40023830
    993          	  __GPIOA_CLK_ENABLE();
    994          	  __GPIOC_CLK_ENABLE();
    995          	  
    996          	  /**I2S1 GPIO Configuration	
    997          		PA4 	------> I2S1_WS --> LRCKO
    998          		PA5 	------> I2S1_CK --> BICKO
    999          		PA7 	------> I2S1_SD --> SDO12
   1000          		PC4 	------> I2S1_MCK
   1001          		*/
   1002          		GPIO_InitStruct.Pin =  GPIO_PIN_4|GPIO_PIN_5|GPIO_PIN_6|GPIO_PIN_7;
   1003          		GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
   1004          		GPIO_InitStruct.Pull = GPIO_NOPULL;
   1005          		GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
   1006          		GPIO_InitStruct.Alternate = GPIO_AF5_SPI1;
   1007          		HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
   \   00000014   0xA901             ADD      R1,SP,#+4
   \   00000016   0x6968             LDR      R0,[R5, #+20]
   \   00000018   0xF440 0x5080      ORR      R0,R0,#0x1000
   \   0000001C   0x6168             STR      R0,[R5, #+20]
   \   0000001E   0x6968             LDR      R0,[R5, #+20]
   \   00000020   0xF400 0x5080      AND      R0,R0,#0x1000
   \   00000024   0x9000             STR      R0,[SP, #+0]
   \   00000026   0x9800             LDR      R0,[SP, #+0]
   \   00000028   0x6828             LDR      R0,[R5, #+0]
   \   0000002A   0xF040 0x0001      ORR      R0,R0,#0x1
   \   0000002E   0x6028             STR      R0,[R5, #+0]
   \   00000030   0x6828             LDR      R0,[R5, #+0]
   \   00000032   0xF000 0x0001      AND      R0,R0,#0x1
   \   00000036   0x9000             STR      R0,[SP, #+0]
   \   00000038   0x9800             LDR      R0,[SP, #+0]
   \   0000003A   0x6828             LDR      R0,[R5, #+0]
   \   0000003C   0xF040 0x0004      ORR      R0,R0,#0x4
   \   00000040   0x6028             STR      R0,[R5, #+0]
   \   00000042   0x6828             LDR      R0,[R5, #+0]
   \   00000044   0xF000 0x0004      AND      R0,R0,#0x4
   \   00000048   0x9000             STR      R0,[SP, #+0]
   \   0000004A   0x9800             LDR      R0,[SP, #+0]
   \   0000004C   0x20F0             MOVS     R0,#+240
   \   0000004E   0x9001             STR      R0,[SP, #+4]
   \   00000050   0x2002             MOVS     R0,#+2
   \   00000052   0x9002             STR      R0,[SP, #+8]
   \   00000054   0x2000             MOVS     R0,#+0
   \   00000056   0x9003             STR      R0,[SP, #+12]
   \   00000058   0x2003             MOVS     R0,#+3
   \   0000005A   0x9004             STR      R0,[SP, #+16]
   \   0000005C   0x2005             MOVS     R0,#+5
   \   0000005E   0x9005             STR      R0,[SP, #+20]
   \   00000060   0x....             LDR.N    R0,??DataTable12_1  ;; 0x40020000
   \   00000062   0x.... 0x....      BL       HAL_GPIO_Init
   1008          	  
   1009          		//GPIO_InitStruct.Pin = GPIO_PIN_4;
   1010          		//GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
   1011          		//GPIO_InitStruct.Pull = GPIO_NOPULL;
   1012          		//GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
   1013          		//GPIO_InitStruct.Alternate = GPIO_AF5_SPI1;
   1014          		//HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
   1015          		
   1016          	  /* Peripheral interrupt init*/
   1017          		HAL_NVIC_SetPriority(SPI1_IRQn, INTERRUPT_PRI_SDO12, 0);
   \   00000066   0x2200             MOVS     R2,#+0
   \   00000068   0x2101             MOVS     R1,#+1
   \   0000006A   0x2023             MOVS     R0,#+35
   \   0000006C   0x.... 0x....      BL       HAL_NVIC_SetPriority
   1018          		HAL_NVIC_EnableIRQ(SPI1_IRQn);
   \   00000070   0x2023             MOVS     R0,#+35
   \   00000072   0xE1C2             B.N      ??HAL_SPI_MspInit_1
   1019          	  /* USER CODE BEGIN SPI1_MspInit 1 */
   1020          	  
   1021          	  /* USER CODE END SPI1_MspInit 1 */
   1022          
   1023            }
   1024            else if (hspi->Instance==SPI2)
   \                     ??HAL_SPI_MspInit_0: (+1)
   \   00000074   0x.... 0x....      LDR.W    R1,??DataTable17_15  ;; 0x40003800
   \   00000078   0x4288             CMP      R0,R1
   \   0000007A   0xD149             BNE.N    ??HAL_SPI_MspInit_2
   1025            {
   1026          	  /* USER CODE BEGIN SPI2_MspInit 0 */
   1027          	  
   1028          	  /* USER CODE END SPI2_MspInit 0 */
   1029          		/* Peripheral clock enable */
   1030          		__SPI2_CLK_ENABLE();
   \   0000007C   0x....             LDR.N    R5,??DataTable12  ;; 0x40023830
   1031          		__GPIOI_CLK_ENABLE();
   1032          		__GPIOB_CLK_ENABLE();
   1033          		__GPIOC_CLK_ENABLE();
   1034          	  
   1035          		/**I2S2 GPIO Configuration	   
   1036          		PC1 	------> I2S2_SD  : PI3 PC1 PC3 PB15 	
   1037          		PB13	 ------> I2S2_CK :PD3 PB10 PB13 PA9 PI1 
   1038          		PB12	 ------> I2S2_WS : PB12 PI0 PB4 PB9  
   1039          	  
   1040          	  
   1041          		*/
   1042          		GPIO_InitStruct.Pin = GPIO_PIN_1; //SD
   1043          		GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
   1044          		GPIO_InitStruct.Pull = GPIO_NOPULL;
   1045          		GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
   1046          		GPIO_InitStruct.Alternate = GPIO_AF5_SPI2;
   1047          		HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
   \   0000007E   0xA901             ADD      R1,SP,#+4
   \   00000080   0x6928             LDR      R0,[R5, #+16]
   \   00000082   0xF440 0x4080      ORR      R0,R0,#0x4000
   \   00000086   0x6128             STR      R0,[R5, #+16]
   \   00000088   0x6928             LDR      R0,[R5, #+16]
   \   0000008A   0xF400 0x4080      AND      R0,R0,#0x4000
   \   0000008E   0x9000             STR      R0,[SP, #+0]
   \   00000090   0x9800             LDR      R0,[SP, #+0]
   \   00000092   0x6828             LDR      R0,[R5, #+0]
   \   00000094   0xF440 0x7080      ORR      R0,R0,#0x100
   \   00000098   0x6028             STR      R0,[R5, #+0]
   \   0000009A   0x6828             LDR      R0,[R5, #+0]
   \   0000009C   0xF400 0x7080      AND      R0,R0,#0x100
   \   000000A0   0x9000             STR      R0,[SP, #+0]
   \   000000A2   0x9800             LDR      R0,[SP, #+0]
   \   000000A4   0x6828             LDR      R0,[R5, #+0]
   \   000000A6   0xF040 0x0002      ORR      R0,R0,#0x2
   \   000000AA   0x6028             STR      R0,[R5, #+0]
   \   000000AC   0x6828             LDR      R0,[R5, #+0]
   \   000000AE   0xF000 0x0002      AND      R0,R0,#0x2
   \   000000B2   0x9000             STR      R0,[SP, #+0]
   \   000000B4   0x9800             LDR      R0,[SP, #+0]
   \   000000B6   0x6828             LDR      R0,[R5, #+0]
   \   000000B8   0xF040 0x0004      ORR      R0,R0,#0x4
   \   000000BC   0x6028             STR      R0,[R5, #+0]
   \   000000BE   0x6828             LDR      R0,[R5, #+0]
   \   000000C0   0xF000 0x0004      AND      R0,R0,#0x4
   \   000000C4   0x9000             STR      R0,[SP, #+0]
   \   000000C6   0x9800             LDR      R0,[SP, #+0]
   \   000000C8   0x2002             MOVS     R0,#+2
   \   000000CA   0x9001             STR      R0,[SP, #+4]
   \   000000CC   0x9002             STR      R0,[SP, #+8]
   \   000000CE   0x2000             MOVS     R0,#+0
   \   000000D0   0x9003             STR      R0,[SP, #+12]
   \   000000D2   0x2003             MOVS     R0,#+3
   \   000000D4   0x9004             STR      R0,[SP, #+16]
   \   000000D6   0x2005             MOVS     R0,#+5
   \   000000D8   0x9005             STR      R0,[SP, #+20]
   \   000000DA   0x.... 0x....      LDR.W    R0,??DataTable17_20  ;; 0x40020800
   \   000000DE   0x.... 0x....      BL       HAL_GPIO_Init
   1048          	  
   1049          		GPIO_InitStruct.Pin = GPIO_PIN_12|GPIO_PIN_13;//WS --> GPIO_PIN_12
   \   000000E2   0xF44F 0x5040      MOV      R0,#+12288
   1050          		GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
   1051          		GPIO_InitStruct.Pull = GPIO_NOPULL;
   1052          		GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
   1053          		GPIO_InitStruct.Alternate = GPIO_AF5_SPI2;
   1054          		HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
   \   000000E6   0xA901             ADD      R1,SP,#+4
   \   000000E8   0x9001             STR      R0,[SP, #+4]
   \   000000EA   0x2002             MOVS     R0,#+2
   \   000000EC   0x9002             STR      R0,[SP, #+8]
   \   000000EE   0x2000             MOVS     R0,#+0
   \   000000F0   0x9003             STR      R0,[SP, #+12]
   \   000000F2   0x2003             MOVS     R0,#+3
   \   000000F4   0x9004             STR      R0,[SP, #+16]
   \   000000F6   0x2005             MOVS     R0,#+5
   \   000000F8   0x9005             STR      R0,[SP, #+20]
   \   000000FA   0x.... 0x....      LDR.W    R0,??DataTable17_21  ;; 0x40020400
   \   000000FE   0x.... 0x....      BL       HAL_GPIO_Init
   1055          	  
   1056          	  
   1057          		/* Peripheral interrupt init*/
   1058          		HAL_NVIC_SetPriority(SPI2_IRQn, INTERRUPT_PRI_SDO34, 0);
   \   00000102   0x2200             MOVS     R2,#+0
   \   00000104   0x2101             MOVS     R1,#+1
   \   00000106   0x2024             MOVS     R0,#+36
   \   00000108   0x.... 0x....      BL       HAL_NVIC_SetPriority
   1059          		HAL_NVIC_EnableIRQ(SPI2_IRQn);
   \   0000010C   0x2024             MOVS     R0,#+36
   \   0000010E   0xE174             B.N      ??HAL_SPI_MspInit_1
   1060          		/* USER CODE BEGIN SPI2_MspInit 1 */
   1061          	  
   1062          	  /* USER CODE END SPI2_MspInit 1 */
   1063          
   1064          
   1065            }
   1066            else if (hspi->Instance==SPI3)
   \                     ??HAL_SPI_MspInit_2: (+1)
   \   00000110   0x.... 0x....      LDR.W    R1,??DataTable17_22  ;; 0x40003c00
   \   00000114   0x4288             CMP      R0,R1
   \   00000116   0xF040 0x808E      BNE.W    ??HAL_SPI_MspInit_3
   1067            {
   1068          	  
   1069              /**I2S3 GPIO Configuration    
   1070                 PB2     ------> I2S3_SD
   1071                 PA15     ------> I2S3_WS (LRCK)
   1072                 PB3     ------> I2S3_CK 
   1073          	   PC7    ------> MCLK
   1074              */
   1075           
   1076            /* USER CODE BEGIN SPI3_MspInit 1 */
   1077            __SPI3_CLK_ENABLE();
   \   0000011A   0x....             LDR.N    R5,??DataTable12  ;; 0x40023830
   1078            __GPIOA_CLK_ENABLE();
   1079            __GPIOB_CLK_ENABLE();
   1080          
   1081            GPIO_InitStruct.Pin = GPIO_PIN_3 | GPIO_PIN_2; 
   1082            GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
   1083            GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
   1084            GPIO_InitStruct.Pull = GPIO_NOPULL;
   1085            GPIO_InitStruct.Alternate = GPIO_AF6_SPI3;
   1086            HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
   \   0000011C   0xA901             ADD      R1,SP,#+4
   \   0000011E   0x6928             LDR      R0,[R5, #+16]
   \   00000120   0xF440 0x4000      ORR      R0,R0,#0x8000
   \   00000124   0x6128             STR      R0,[R5, #+16]
   \   00000126   0x6928             LDR      R0,[R5, #+16]
   \   00000128   0xF400 0x4000      AND      R0,R0,#0x8000
   \   0000012C   0x9000             STR      R0,[SP, #+0]
   \   0000012E   0x9800             LDR      R0,[SP, #+0]
   \   00000130   0x6828             LDR      R0,[R5, #+0]
   \   00000132   0xF040 0x0001      ORR      R0,R0,#0x1
   \   00000136   0x6028             STR      R0,[R5, #+0]
   \   00000138   0x6828             LDR      R0,[R5, #+0]
   \   0000013A   0xF000 0x0001      AND      R0,R0,#0x1
   \   0000013E   0x9000             STR      R0,[SP, #+0]
   \   00000140   0x9800             LDR      R0,[SP, #+0]
   \   00000142   0x6828             LDR      R0,[R5, #+0]
   \   00000144   0xF040 0x0002      ORR      R0,R0,#0x2
   \   00000148   0x6028             STR      R0,[R5, #+0]
   \   0000014A   0x6828             LDR      R0,[R5, #+0]
   \   0000014C   0xF000 0x0002      AND      R0,R0,#0x2
   \   00000150   0x9000             STR      R0,[SP, #+0]
   \   00000152   0x9800             LDR      R0,[SP, #+0]
   \   00000154   0x200C             MOVS     R0,#+12
   \   00000156   0x9001             STR      R0,[SP, #+4]
   \   00000158   0x2002             MOVS     R0,#+2
   \   0000015A   0x9002             STR      R0,[SP, #+8]
   \   0000015C   0x2003             MOVS     R0,#+3
   \   0000015E   0x9004             STR      R0,[SP, #+16]
   \   00000160   0x2000             MOVS     R0,#+0
   \   00000162   0x9003             STR      R0,[SP, #+12]
   \   00000164   0x2006             MOVS     R0,#+6
   \   00000166   0x9005             STR      R0,[SP, #+20]
   \   00000168   0x.... 0x....      LDR.W    R0,??DataTable17_21  ;; 0x40020400
   \   0000016C   0x.... 0x....      BL       HAL_GPIO_Init
   1087          
   1088          
   1089            GPIO_InitStruct.Pin = GPIO_PIN_15;
   \   00000170   0xF44F 0x4000      MOV      R0,#+32768
   1090            GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
   1091            GPIO_InitStruct.Alternate = GPIO_AF6_SPI3;
   1092            HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
   \   00000174   0xA901             ADD      R1,SP,#+4
   \   00000176   0x9001             STR      R0,[SP, #+4]
   \   00000178   0x2002             MOVS     R0,#+2
   \   0000017A   0x9002             STR      R0,[SP, #+8]
   \   0000017C   0x2006             MOVS     R0,#+6
   \   0000017E   0x9005             STR      R0,[SP, #+20]
   \   00000180   0x....             LDR.N    R0,??DataTable12_1  ;; 0x40020000
   \   00000182   0x.... 0x....      BL       HAL_GPIO_Init
   1093          
   1094          #ifdef CODEC_MCLK_ENABLED
   1095            __GPIOC_CLK_ENABLE();
   \   00000186   0x6828             LDR      R0,[R5, #+0]
   1096            GPIO_InitStruct.Pin = GPIO_PIN_7; 
   1097            GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
   1098            GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
   1099            GPIO_InitStruct.Pull = GPIO_NOPULL;
   1100            GPIO_InitStruct.Alternate = GPIO_AF6_SPI3;
   1101            HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
   \   00000188   0xA901             ADD      R1,SP,#+4
   \   0000018A   0xF040 0x0004      ORR      R0,R0,#0x4
   \   0000018E   0x6028             STR      R0,[R5, #+0]
   \   00000190   0x6828             LDR      R0,[R5, #+0]
   \   00000192   0xF000 0x0004      AND      R0,R0,#0x4
   \   00000196   0x9000             STR      R0,[SP, #+0]
   \   00000198   0x9800             LDR      R0,[SP, #+0]
   \   0000019A   0x2080             MOVS     R0,#+128
   \   0000019C   0x9001             STR      R0,[SP, #+4]
   \   0000019E   0x2002             MOVS     R0,#+2
   \   000001A0   0x9002             STR      R0,[SP, #+8]
   \   000001A2   0x2003             MOVS     R0,#+3
   \   000001A4   0x9004             STR      R0,[SP, #+16]
   \   000001A6   0x2000             MOVS     R0,#+0
   \   000001A8   0x9003             STR      R0,[SP, #+12]
   \   000001AA   0x2006             MOVS     R0,#+6
   \   000001AC   0x9005             STR      R0,[SP, #+20]
   \   000001AE   0x.... 0x....      LDR.W    R0,??DataTable17_20  ;; 0x40020800
   \   000001B2   0x.... 0x....      BL       HAL_GPIO_Init
   1102          
   1103          #endif /* CODEC_MCLK_ENABLED */ 
   1104          
   1105          #ifdef I2S_INTERRUPT   
   1106               /* Enable and set Button EXTI Interrupt to the lowest priority */
   1107               //HAL_NVIC_SetPriority((IRQn_Type)SPI3_IRQn, 0x00, 0x01);
   1108               //HAL_NVIC_EnableIRQ((IRQn_Type)SPI3_IRQn);
   1109          
   1110               /* Enable the I2S DMA request */
   1111               //__HAL_I2S_ENABLE_IT(&hi2s3, SPI_I2S_DMAReq_Tx);
   1112               //__HAL_I2S_ENABLE(&hi2s3);
   1113            	    /* Peripheral interrupt init*/
   1114          		HAL_NVIC_SetPriority(SPI3_IRQn, 3, 0);
   1115          		HAL_NVIC_EnableIRQ(SPI3_IRQn);
   1116          #endif
   1117          
   1118                /* Enable the DMA clock */ 
   1119          	  __HAL_RCC_DMA1_CLK_ENABLE();
   \   000001B6   0x6828             LDR      R0,[R5, #+0]
   \   000001B8   0xF440 0x1000      ORR      R0,R0,#0x200000
   \   000001BC   0x6028             STR      R0,[R5, #+0]
   \   000001BE   0x6828             LDR      R0,[R5, #+0]
   1120          
   1121                /* Configure the DMA Stream */
   1122                //HAL_DMA_DeInit(&DmaHandle);
   1123          
   1124                /* Set the parameters to be configured */ 
   1125          	  DmaHandle.Instance = DMA1_Stream7;
   \   000001C0   0x.... 0x....      LDR.W    R5,??DataTable17_23
   \   000001C4   0xF400 0x1000      AND      R0,R0,#0x200000
   \   000001C8   0x9000             STR      R0,[SP, #+0]
   \   000001CA   0x9800             LDR      R0,[SP, #+0]
   \   000001CC   0x.... 0x....      LDR.W    R0,??DataTable17_24  ;; 0x400260b8
   \   000001D0   0x6028             STR      R0,[R5, #+0]
   1126                DmaHandle.Init.Channel = DMA_CHANNEL_0;
   \   000001D2   0x2000             MOVS     R0,#+0
   \   000001D4   0x6068             STR      R0,[R5, #+4]
   1127          	  DmaHandle.Init.Direction = DMA_MEMORY_TO_PERIPH;
   \   000001D6   0x2040             MOVS     R0,#+64
   \   000001D8   0x60A8             STR      R0,[R5, #+8]
   1128          	  DmaHandle.Init.PeriphInc = DMA_PINC_DISABLE;
   \   000001DA   0x2000             MOVS     R0,#+0
   \   000001DC   0x60E8             STR      R0,[R5, #+12]
   1129          	  DmaHandle.Init.MemInc = DMA_MINC_ENABLE;
   \   000001DE   0xF44F 0x6080      MOV      R0,#+1024
   \   000001E2   0x6128             STR      R0,[R5, #+16]
   1130          	  DmaHandle.Init.PeriphDataAlignment = DMA_PDATAALIGN_HALFWORD;
   \   000001E4   0xF44F 0x6000      MOV      R0,#+2048
   \   000001E8   0x6168             STR      R0,[R5, #+20]
   1131                DmaHandle.Init.MemDataAlignment = DMA_MDATAALIGN_HALFWORD; 
   \   000001EA   0xF44F 0x5000      MOV      R0,#+8192
   \   000001EE   0x61A8             STR      R0,[R5, #+24]
   1132          	  DmaHandle.Init.Mode = DMA_NORMAL;
   \   000001F0   0x2000             MOVS     R0,#+0
   \   000001F2   0x61E8             STR      R0,[R5, #+28]
   1133                DmaHandle.Init.Priority = DMA_PRIORITY_HIGH; 
   \   000001F4   0xF44F 0x3000      MOV      R0,#+131072
   \   000001F8   0x6228             STR      R0,[R5, #+32]
   1134          	  DmaHandle.Init.FIFOMode = DMA_FIFOMODE_ENABLE;//DMA_FIFOMODE_DISABLE
   \   000001FA   0x2004             MOVS     R0,#+4
   \   000001FC   0x6268             STR      R0,[R5, #+36]
   1135                DmaHandle.Init.FIFOThreshold = DMA_FIFO_THRESHOLD_FULL;
   \   000001FE   0x2003             MOVS     R0,#+3
   \   00000200   0x62A8             STR      R0,[R5, #+40]
   1136                DmaHandle.Init.MemBurst = DMA_MBURST_SINGLE;
   \   00000202   0x2000             MOVS     R0,#+0
   \   00000204   0x62E8             STR      R0,[R5, #+44]
   1137                DmaHandle.Init.PeriphBurst = DMA_PBURST_SINGLE;	  
   \   00000206   0x6328             STR      R0,[R5, #+48]
   1138                //DmaHandle.Instance->PAR =(uint32_t)&SPI3->DR;//CODEC_I2S_ADDRESS
   1139                //DmaHandle.Instance->M0AR = (uint32_t)0;
   1140                //DmaHandle.Instance->NDTR = (uint32_t)0xFFFE;
   1141                //DmaHandle.XferCpltCallback = &TC_Callback;
   1142           
   1143          
   1144                /* Associate the initialized DMA handle to the the SPI handle */
   1145                __HAL_LINKDMA(hspi, hdmatx, DmaHandle);
   1146                //__HAL_DMA_ENABLE_IT(&DmaHandle, DMA_IT_TC);
   1147          
   1148          	   /* Deinitialize the Stream for new transfer */
   1149                 HAL_DMA_DeInit(&DmaHandle);
   \   00000208   0x4628             MOV      R0,R5
   \   0000020A   0x6565             STR      R5,[R4, #+84]
   \   0000020C   0x63AC             STR      R4,[R5, #+56]
   \   0000020E   0x.... 0x....      BL       HAL_DMA_DeInit
   1150                 /* Configure the DMA Stream */
   1151          	   HAL_DMA_Init(&DmaHandle);
   \   00000212   0x4628             MOV      R0,R5
   \   00000214   0x.... 0x....      BL       HAL_DMA_Init
   1152          
   1153                /* Set Interrupt Group Priority */
   1154                HAL_NVIC_SetPriority(DMA1_Stream7_IRQn, INTERRUPT_PRI_DMA, 0);
   \   00000218   0x2200             MOVS     R2,#+0
   \   0000021A   0x2100             MOVS     R1,#+0
   \   0000021C   0x202F             MOVS     R0,#+47
   \   0000021E   0x.... 0x....      BL       HAL_NVIC_SetPriority
   1155                /* Enable the DMA STREAM global Interrupt */
   1156                HAL_NVIC_EnableIRQ(DMA1_Stream7_IRQn);    
   \   00000222   0x202F             MOVS     R0,#+47
   \   00000224   0x.... 0x....      BL       HAL_NVIC_EnableIRQ
   1157          
   1158          	  __HAL_DMA_ENABLE_IT(&DmaHandle, DMA_IT_TC);
   \   00000228   0x6828             LDR      R0,[R5, #+0]
   \   0000022A   0x6801             LDR      R1,[R0, #+0]
   \   0000022C   0xF041 0x0110      ORR      R1,R1,#0x10
   \   00000230   0x6001             STR      R1,[R0, #+0]
   1159          	    
   1160            }
   1161            else if(hspi->Instance==SPI4)
   1162            {
   1163            /* USER CODE BEGIN SPI4_MspInit 0 */
   1164          
   1165            /* USER CODE END SPI4_MspInit 0 */
   1166              /* Peripheral clock enable */
   1167              __SPI4_CLK_ENABLE();
   1168              __HAL_RCC_GPIOE_CLK_ENABLE();
   1169            
   1170            
   1171              /**SPI4 GPIO Configuration    
   1172              PE2     ------> SPI4_SCK
   1173              PE4     ------> SPI4_NSS
   1174              PE5     ------> SPI4_MISO
   1175              PE6     ------> SPI4_MOSI 
   1176              */
   1177              GPIO_InitStruct.Pin = GPIO_PIN_2|GPIO_PIN_4|GPIO_PIN_5|GPIO_PIN_6;
   1178              GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
   1179              GPIO_InitStruct.Pull = GPIO_NOPULL;
   1180              GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
   1181              GPIO_InitStruct.Alternate = GPIO_AF5_SPI4;
   1182              HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
   1183          
   1184          	/* Peripheral interrupt init*/
   1185              HAL_NVIC_SetPriority(SPI4_IRQn, INTERRUPT_PRI_SDO56, 0);
   1186              HAL_NVIC_EnableIRQ(SPI4_IRQn);
   1187          
   1188            /* USER CODE BEGIN SPI4_MspInit 1 */
   1189          
   1190            /* USER CODE END SPI4_MspInit 1 */
   1191            }
   1192            else if(hspi->Instance==SPI5)
   1193            {
   1194            /* USER CODE BEGIN SPI5_MspInit 0 */
   1195          
   1196            /* USER CODE END SPI5_MspInit 0 */
   1197              /* Peripheral clock enable */
   1198              __HAL_RCC_SPI5_CLK_ENABLE();
   1199              __HAL_RCC_GPIOF_CLK_ENABLE();
   1200            
   1201              /**SPI5 GPIO Configuration    
   1202              PF7     ------> SPI5_SCK  --> PF7
   1203              PF11     ------> SPI5_MOSI --> PF9
   1204                               SPI5_MISO --> PF8
   1205                                    NSS   -->  PF6
   1206              */
   1207              GPIO_InitStruct.Pin = GPIO_PIN_6|GPIO_PIN_7|GPIO_PIN_9|GPIO_PIN_8;
   1208              GPIO_InitStruct.Mode = GPIO_MODE_AF_OD;
   1209              GPIO_InitStruct.Pull = GPIO_PULLUP;
   1210              GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
   1211              GPIO_InitStruct.Alternate = GPIO_AF5_SPI5;
   1212              HAL_GPIO_Init(GPIOF, &GPIO_InitStruct);
   1213          
   1214          #if 0
   1215            /* Peripheral interrupt init*/
   1216              HAL_NVIC_SetPriority(SPI5_IRQn, INTERRUPT_PRI_SDO7, 0);
   1217              HAL_NVIC_EnableIRQ(SPI5_IRQn);
   1218          
   1219          #else
   1220          	/* Peripheral DMA init*/
   1221              __HAL_RCC_DMA2_CLK_ENABLE();
   1222          	hdma_spi5_rx.Instance = DMA2_Stream5;
   1223          	hdma_spi5_rx.Init.Channel = DMA_CHANNEL_7;
   1224          	hdma_spi5_rx.Init.Direction = DMA_PERIPH_TO_MEMORY;
   1225          	hdma_spi5_rx.Init.PeriphInc = DMA_PINC_DISABLE;
   1226          	hdma_spi5_rx.Init.MemInc = DMA_MINC_ENABLE;
   1227          	hdma_spi5_rx.Init.PeriphDataAlignment = DMA_PDATAALIGN_HALFWORD;
   1228          	hdma_spi5_rx.Init.MemDataAlignment = DMA_MDATAALIGN_HALFWORD;
   1229          	hdma_spi5_rx.Init.Mode = DMA_NORMAL;
   1230          	hdma_spi5_rx.Init.Priority = DMA_PRIORITY_HIGH;
   1231          	hdma_spi5_rx.Init.FIFOMode = DMA_FIFOMODE_DISABLE;
   1232          	hdma_spi5_rx.Init.FIFOThreshold = DMA_FIFO_THRESHOLD_FULL;
   1233          	hdma_spi5_rx.Init.MemBurst = DMA_MBURST_SINGLE;
   1234          	hdma_spi5_rx.Init.PeriphBurst = DMA_PBURST_SINGLE;
   1235          	HAL_DMA_Init(&hdma_spi5_rx);
   1236          
   1237              __HAL_LINKDMA(hspi,hdmarx,hdma_spi5_rx);
   1238          
   1239          	HAL_NVIC_SetPriority(DMA2_Stream5_IRQn, INTERRUPT_PRI_SDO7, 0);
   1240          	HAL_NVIC_EnableIRQ(DMA2_Stream5_IRQn);
   1241          
   1242          #endif
   1243            /* USER CODE END SPI5_MspInit 1 */
   1244            }
   1245            else if(hspi->Instance==SPI6)
   1246            {
   1247            /* USER CODE BEGIN SPI6_MspInit 0 */
   1248          
   1249            /* USER CODE END SPI6_MspInit 0 */
   1250              /* Peripheral clock enable */
   1251              __SPI6_CLK_ENABLE();
   1252              __HAL_RCC_GPIOG_CLK_ENABLE();
   1253            
   1254              /**SPI6 GPIO Configuration    
   1255              PG13     ------> SPI6_SCK
   1256              PG14     ------> SPI6_MOSI 
   1257              */
   1258              GPIO_InitStruct.Pin = GPIO_PIN_13|GPIO_PIN_14;
   1259              GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
   1260              GPIO_InitStruct.Pull = GPIO_NOPULL;
   1261              GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
   1262              GPIO_InitStruct.Alternate = GPIO_AF5_SPI6;
   1263              HAL_GPIO_Init(GPIOG, &GPIO_InitStruct);
   1264          
   1265          #if 0
   1266          	  /* Peripheral interrupt init*/
   1267              HAL_NVIC_SetPriority(SPI6_IRQn, INTERRUPT_PRI_SDO8, 1);
   1268              HAL_NVIC_EnableIRQ(SPI6_IRQn);
   1269          #else
   1270          	/* Peripheral DMA init*/
   1271          	__HAL_RCC_DMA2_CLK_ENABLE();
   1272          	hdma_spi6_rx.Instance = DMA2_Stream6;
   1273          	hdma_spi6_rx.Init.Channel = DMA_CHANNEL_1;
   1274          	hdma_spi6_rx.Init.Direction = DMA_PERIPH_TO_MEMORY;
   1275          	hdma_spi6_rx.Init.PeriphInc = DMA_PINC_DISABLE;
   1276          	hdma_spi6_rx.Init.MemInc = DMA_MINC_ENABLE;
   1277          	hdma_spi6_rx.Init.PeriphDataAlignment = DMA_PDATAALIGN_HALFWORD;
   1278          	hdma_spi6_rx.Init.MemDataAlignment = DMA_PDATAALIGN_HALFWORD;
   1279          	hdma_spi6_rx.Init.Mode = DMA_NORMAL;
   1280          	hdma_spi6_rx.Init.Priority = DMA_PRIORITY_HIGH;
   1281          	hdma_spi6_rx.Init.FIFOMode = DMA_FIFOMODE_DISABLE;
   1282          	hdma_spi6_rx.Init.FIFOThreshold = DMA_FIFO_THRESHOLD_FULL;
   1283          	hdma_spi6_rx.Init.MemBurst = DMA_MBURST_SINGLE;
   1284          	hdma_spi6_rx.Init.PeriphBurst = DMA_PBURST_SINGLE;
   1285          	HAL_DMA_Init(&hdma_spi6_rx);
   1286          
   1287          	__HAL_LINKDMA(hspi,hdmarx,hdma_spi6_rx);
   1288          
   1289          	HAL_NVIC_SetPriority(DMA2_Stream6_IRQn, INTERRUPT_PRI_SDO8, 1);
   1290          	HAL_NVIC_EnableIRQ(DMA2_Stream6_IRQn);
   1291          
   1292          #endif
   1293            }
   1294          
   1295          }
   \   00000232   0xB007             ADD      SP,SP,#+28
   \   00000234   0xBD30             POP      {R4,R5,PC}
   \                     ??HAL_SPI_MspInit_3: (+1)
   \   00000236   0x.... 0x....      LDR.W    R1,??DataTable17_16  ;; 0x40013400
   \   0000023A   0x4288             CMP      R0,R1
   \   0000023C   0xD127             BNE.N    ??HAL_SPI_MspInit_4
   \   0000023E   0x....             LDR.N    R5,??DataTable12  ;; 0x40023830
   \   00000240   0xA901             ADD      R1,SP,#+4
   \   00000242   0x6968             LDR      R0,[R5, #+20]
   \   00000244   0xF440 0x5000      ORR      R0,R0,#0x2000
   \   00000248   0x6168             STR      R0,[R5, #+20]
   \   0000024A   0x6968             LDR      R0,[R5, #+20]
   \   0000024C   0xF400 0x5000      AND      R0,R0,#0x2000
   \   00000250   0x9000             STR      R0,[SP, #+0]
   \   00000252   0x9800             LDR      R0,[SP, #+0]
   \   00000254   0x6828             LDR      R0,[R5, #+0]
   \   00000256   0xF040 0x0010      ORR      R0,R0,#0x10
   \   0000025A   0x6028             STR      R0,[R5, #+0]
   \   0000025C   0x6828             LDR      R0,[R5, #+0]
   \   0000025E   0xF000 0x0010      AND      R0,R0,#0x10
   \   00000262   0x9000             STR      R0,[SP, #+0]
   \   00000264   0x9800             LDR      R0,[SP, #+0]
   \   00000266   0x2074             MOVS     R0,#+116
   \   00000268   0x9001             STR      R0,[SP, #+4]
   \   0000026A   0x2002             MOVS     R0,#+2
   \   0000026C   0x9002             STR      R0,[SP, #+8]
   \   0000026E   0x2000             MOVS     R0,#+0
   \   00000270   0x9003             STR      R0,[SP, #+12]
   \   00000272   0x2003             MOVS     R0,#+3
   \   00000274   0x9004             STR      R0,[SP, #+16]
   \   00000276   0x2005             MOVS     R0,#+5
   \   00000278   0x9005             STR      R0,[SP, #+20]
   \   0000027A   0x....             LDR.N    R0,??DataTable16  ;; 0x40021000
   \   0000027C   0x.... 0x....      BL       HAL_GPIO_Init
   \   00000280   0x2200             MOVS     R2,#+0
   \   00000282   0x2102             MOVS     R1,#+2
   \   00000284   0x2054             MOVS     R0,#+84
   \   00000286   0x.... 0x....      BL       HAL_NVIC_SetPriority
   \   0000028A   0x2054             MOVS     R0,#+84
   \   0000028C   0xE0B5             B.N      ??HAL_SPI_MspInit_1
   \                     ??HAL_SPI_MspInit_4: (+1)
   \   0000028E   0x.... 0x....      LDR.W    R1,??DataTable17_18  ;; 0x40015000
   \   00000292   0x4288             CMP      R0,R1
   \   00000294   0xD157             BNE.N    ??HAL_SPI_MspInit_5
   \   00000296   0x....             LDR.N    R5,??DataTable12  ;; 0x40023830
   \   00000298   0xA901             ADD      R1,SP,#+4
   \   0000029A   0x6968             LDR      R0,[R5, #+20]
   \   0000029C   0xF440 0x1080      ORR      R0,R0,#0x100000
   \   000002A0   0x6168             STR      R0,[R5, #+20]
   \   000002A2   0x6968             LDR      R0,[R5, #+20]
   \   000002A4   0xF400 0x1080      AND      R0,R0,#0x100000
   \   000002A8   0x9000             STR      R0,[SP, #+0]
   \   000002AA   0x9800             LDR      R0,[SP, #+0]
   \   000002AC   0x6828             LDR      R0,[R5, #+0]
   \   000002AE   0xF040 0x0020      ORR      R0,R0,#0x20
   \   000002B2   0x6028             STR      R0,[R5, #+0]
   \   000002B4   0x6828             LDR      R0,[R5, #+0]
   \   000002B6   0xF000 0x0020      AND      R0,R0,#0x20
   \   000002BA   0x9000             STR      R0,[SP, #+0]
   \   000002BC   0x9800             LDR      R0,[SP, #+0]
   \   000002BE   0xF44F 0x7070      MOV      R0,#+960
   \   000002C2   0x9001             STR      R0,[SP, #+4]
   \   000002C4   0x2012             MOVS     R0,#+18
   \   000002C6   0x9002             STR      R0,[SP, #+8]
   \   000002C8   0x2001             MOVS     R0,#+1
   \   000002CA   0x9003             STR      R0,[SP, #+12]
   \   000002CC   0x2003             MOVS     R0,#+3
   \   000002CE   0x9004             STR      R0,[SP, #+16]
   \   000002D0   0x2005             MOVS     R0,#+5
   \   000002D2   0x9005             STR      R0,[SP, #+20]
   \   000002D4   0x.... 0x....      LDR.W    R0,??DataTable17_25  ;; 0x40021400
   \   000002D8   0x.... 0x....      BL       HAL_GPIO_Init
   \   000002DC   0x6828             LDR      R0,[R5, #+0]
   \   000002DE   0xF440 0x0080      ORR      R0,R0,#0x400000
   \   000002E2   0x6028             STR      R0,[R5, #+0]
   \   000002E4   0x6828             LDR      R0,[R5, #+0]
   \   000002E6   0x.... 0x....      LDR.W    R5,??DataTable17_26
   \   000002EA   0xF400 0x0080      AND      R0,R0,#0x400000
   \   000002EE   0x9000             STR      R0,[SP, #+0]
   \   000002F0   0x9800             LDR      R0,[SP, #+0]
   \   000002F2   0x.... 0x....      LDR.W    R0,??DataTable17_27  ;; 0x40026488
   \   000002F6   0x6028             STR      R0,[R5, #+0]
   \   000002F8   0xF04F 0x6060      MOV      R0,#+234881024
   \   000002FC   0x6068             STR      R0,[R5, #+4]
   \   000002FE   0x2000             MOVS     R0,#+0
   \   00000300   0x60A8             STR      R0,[R5, #+8]
   \   00000302   0x60E8             STR      R0,[R5, #+12]
   \   00000304   0xF44F 0x6080      MOV      R0,#+1024
   \   00000308   0x6128             STR      R0,[R5, #+16]
   \   0000030A   0xF44F 0x6000      MOV      R0,#+2048
   \   0000030E   0x6168             STR      R0,[R5, #+20]
   \   00000310   0xF44F 0x5000      MOV      R0,#+8192
   \   00000314   0x61A8             STR      R0,[R5, #+24]
   \   00000316   0x2000             MOVS     R0,#+0
   \   00000318   0x61E8             STR      R0,[R5, #+28]
   \   0000031A   0xF44F 0x3000      MOV      R0,#+131072
   \   0000031E   0x6228             STR      R0,[R5, #+32]
   \   00000320   0x2000             MOVS     R0,#+0
   \   00000322   0x6268             STR      R0,[R5, #+36]
   \   00000324   0x2003             MOVS     R0,#+3
   \   00000326   0x62A8             STR      R0,[R5, #+40]
   \   00000328   0x2000             MOVS     R0,#+0
   \   0000032A   0x62E8             STR      R0,[R5, #+44]
   \   0000032C   0x6328             STR      R0,[R5, #+48]
   \   0000032E   0x4628             MOV      R0,R5
   \   00000330   0x.... 0x....      BL       HAL_DMA_Init
   \   00000334   0x65A5             STR      R5,[R4, #+88]
   \   00000336   0x2200             MOVS     R2,#+0
   \   00000338   0x63AC             STR      R4,[R5, #+56]
   \   0000033A   0x2104             MOVS     R1,#+4
   \   0000033C   0x2044             MOVS     R0,#+68
   \   0000033E   0x.... 0x....      BL       HAL_NVIC_SetPriority
   \   00000342   0x2044             MOVS     R0,#+68
   \   00000344   0xE059             B.N      ??HAL_SPI_MspInit_1
   \                     ??HAL_SPI_MspInit_5: (+1)
   \   00000346   0x.... 0x....      LDR.W    R1,??DataTable17_19  ;; 0x40015400
   \   0000034A   0x4288             CMP      R0,R1
   \   0000034C   0xD157             BNE.N    ??HAL_SPI_MspInit_6
   \   0000034E   0x....             LDR.N    R5,??DataTable12  ;; 0x40023830
   \   00000350   0xA901             ADD      R1,SP,#+4
   \   00000352   0x6968             LDR      R0,[R5, #+20]
   \   00000354   0xF440 0x1000      ORR      R0,R0,#0x200000
   \   00000358   0x6168             STR      R0,[R5, #+20]
   \   0000035A   0x6968             LDR      R0,[R5, #+20]
   \   0000035C   0xF400 0x1000      AND      R0,R0,#0x200000
   \   00000360   0x9000             STR      R0,[SP, #+0]
   \   00000362   0x9800             LDR      R0,[SP, #+0]
   \   00000364   0x6828             LDR      R0,[R5, #+0]
   \   00000366   0xF040 0x0040      ORR      R0,R0,#0x40
   \   0000036A   0x6028             STR      R0,[R5, #+0]
   \   0000036C   0x6828             LDR      R0,[R5, #+0]
   \   0000036E   0xF000 0x0040      AND      R0,R0,#0x40
   \   00000372   0x9000             STR      R0,[SP, #+0]
   \   00000374   0x9800             LDR      R0,[SP, #+0]
   \   00000376   0xF44F 0x40C0      MOV      R0,#+24576
   \   0000037A   0x9001             STR      R0,[SP, #+4]
   \   0000037C   0x2002             MOVS     R0,#+2
   \   0000037E   0x9002             STR      R0,[SP, #+8]
   \   00000380   0x2000             MOVS     R0,#+0
   \   00000382   0x9003             STR      R0,[SP, #+12]
   \   00000384   0x2003             MOVS     R0,#+3
   \   00000386   0x9004             STR      R0,[SP, #+16]
   \   00000388   0x2005             MOVS     R0,#+5
   \   0000038A   0x9005             STR      R0,[SP, #+20]
   \   0000038C   0x.... 0x....      LDR.W    R0,??DataTable17_28  ;; 0x40021800
   \   00000390   0x.... 0x....      BL       HAL_GPIO_Init
   \   00000394   0x6828             LDR      R0,[R5, #+0]
   \   00000396   0xF440 0x0080      ORR      R0,R0,#0x400000
   \   0000039A   0x6028             STR      R0,[R5, #+0]
   \   0000039C   0x6828             LDR      R0,[R5, #+0]
   \   0000039E   0x.... 0x....      LDR.W    R5,??DataTable17_29
   \   000003A2   0xF400 0x0080      AND      R0,R0,#0x400000
   \   000003A6   0x9000             STR      R0,[SP, #+0]
   \   000003A8   0x9800             LDR      R0,[SP, #+0]
   \   000003AA   0x.... 0x....      LDR.W    R0,??DataTable17_27  ;; 0x40026488
   \   000003AE   0x3018             ADDS     R0,R0,#+24
   \   000003B0   0x6028             STR      R0,[R5, #+0]
   \   000003B2   0xF04F 0x7000      MOV      R0,#+33554432
   \   000003B6   0x6068             STR      R0,[R5, #+4]
   \   000003B8   0x2000             MOVS     R0,#+0
   \   000003BA   0x60A8             STR      R0,[R5, #+8]
   \   000003BC   0x60E8             STR      R0,[R5, #+12]
   \   000003BE   0xF44F 0x6080      MOV      R0,#+1024
   \   000003C2   0x6128             STR      R0,[R5, #+16]
   \   000003C4   0xF44F 0x6000      MOV      R0,#+2048
   \   000003C8   0x6168             STR      R0,[R5, #+20]
   \   000003CA   0x61A8             STR      R0,[R5, #+24]
   \   000003CC   0x2000             MOVS     R0,#+0
   \   000003CE   0x61E8             STR      R0,[R5, #+28]
   \   000003D0   0xF44F 0x3000      MOV      R0,#+131072
   \   000003D4   0x6228             STR      R0,[R5, #+32]
   \   000003D6   0x2000             MOVS     R0,#+0
   \   000003D8   0x6268             STR      R0,[R5, #+36]
   \   000003DA   0x2003             MOVS     R0,#+3
   \   000003DC   0x62A8             STR      R0,[R5, #+40]
   \   000003DE   0x2000             MOVS     R0,#+0
   \   000003E0   0x62E8             STR      R0,[R5, #+44]
   \   000003E2   0x6328             STR      R0,[R5, #+48]
   \   000003E4   0x4628             MOV      R0,R5
   \   000003E6   0x.... 0x....      BL       HAL_DMA_Init
   \   000003EA   0x65A5             STR      R5,[R4, #+88]
   \   000003EC   0x2201             MOVS     R2,#+1
   \   000003EE   0x63AC             STR      R4,[R5, #+56]
   \   000003F0   0x2107             MOVS     R1,#+7
   \   000003F2   0x2045             MOVS     R0,#+69
   \   000003F4   0x.... 0x....      BL       HAL_NVIC_SetPriority
   \   000003F8   0x2045             MOVS     R0,#+69
   \                     ??HAL_SPI_MspInit_1: (+1)
   \   000003FA   0x.... 0x....      BL       HAL_NVIC_EnableIRQ
   \                     ??HAL_SPI_MspInit_6: (+1)
   \   000003FE   0xB007             ADD      SP,SP,#+28
   \   00000400   0xBD30             POP      {R4,R5,PC}       ;; return
   1296          
   1297          
   1298          
   1299          
   1300          static void SPI_I2S_SendData(SPI_TypeDef* SPIx, uint16_t Data)
   1301          {
   1302            /* Check the parameters */
   1303            assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
   1304            
   1305            /* Write in the DR register the data to be sent */
   1306            SPIx->DR = Data;
   1307          }
   1308          
   1309          
   1310          static uint16_t SPI_I2S_ReceiveData(SPI_TypeDef* SPIx)
   1311          {
   1312            /* Check the parameters */
   1313            assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
   1314            
   1315            /* Return the data in the DR register */
   1316            return SPIx->DR;
   1317          }
   1318          
   1319          

   \                                 In section .text, align 2, keep-with-next
   1320          void RecordUpdBuf(void)
   1321          {
   1322          
   1323               if (WaveRecord_flgInt==2)
   \                     RecordUpdBuf: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable15_1
   \   00000002   0x7801             LDRB     R1,[R0, #+0]
   \   00000004   0x2902             CMP      R1,#+2
   \   00000006   0xD000             BEQ.N    ??RecordUpdBuf_0
   \   00000008   0x4770             BX       LR
   1324               {
   1325                  WaveRecord_flgInt=0;
   \                     ??RecordUpdBuf_0: (+1)
   \   0000000A   0xB410             PUSH     {R4}
   \   0000000C   0x2100             MOVS     R1,#+0
   1326          			if ((WaveRec_idxSens1 < (AUDIO_OUT_BUFFER_SIZE))&&(WaveRec_idxSens2 < (AUDIO_OUT_BUFFER_SIZE)))
   \   0000000E   0x....             LDR.N    R2,??DataTable15_3
   \   00000010   0x7001             STRB     R1,[R0, #+0]
   \   00000012   0x8811             LDRH     R1,[R2, #+0]
   \   00000014   0xF5B1 0x6F80      CMP      R1,#+1024
   \   00000018   0xBFBE             ITTT     LT 
   \   0000001A   0x....             LDRLT.N  R1,??DataTable16_1
   \   0000001C   0x880B             LDRHLT   R3,[R1, #+0]
   \   0000001E   0xF5B3 0x6F80      CMPLT    R3,#+1024
   \   00000022   0xDA50             BGE.N    ??RecordUpdBuf_1
   1327          		//			  &&(stLR!=stLROld))
   1328          			{
   1329          		/*-------------------------------------------------------------------------------------------------------------
   1330          					  
   1331          			Sequence  Record Data					  Processing Data				  Player Data
   1332          					  
   1333          			1-------  Buffer1						  Buffer2						  Buffer3 BUF3_PLAY)
   1334          					  
   1335          			2-------  Buffer3						  Buffer1						  Buffer2 (BUF2_PLAY)		  
   1336          					  
   1337          			3-------  Buffer2						  Buffer3						  Buffer1 (BUF1_PLAY)
   1338          		 ---------------------------------------------------------------------------------------------------------------*/
   1339          					  /* Recording Audio Data */						 
   1340          					   switch (buffer_switch)
   \   00000024   0x....             LDR.N    R3,??DataTable15_2
   \   00000026   0x781B             LDRB     R3,[R3, #+0]
   \   00000028   0xB123             CBZ.N    R3,??RecordUpdBuf_2
   \   0000002A   0x2B02             CMP      R3,#+2
   \   0000002C   0xD00C             BEQ.N    ??RecordUpdBuf_3
   \   0000002E   0xD306             BCC.N    ??RecordUpdBuf_4
   1341          					   {
   1342          								case BUF1_PLAY:
   1343          
   1344          										Buffer2.bufMIC1[WaveRec_idxSens1++] = vRawSens1;
   1345          										Buffer2.bufMIC2[WaveRec_idxSens2++] = vRawSens2;
   1346          										Buffer2.bufMIC3[WaveRec_idxSens3++] = vRawSens3;
   1347          										Buffer2.bufMIC4[WaveRec_idxSens4++] = vRawSens4;
   1348          										Buffer2.bufMIC5[WaveRec_idxSens5++] = vRawSens5;
   1349          										Buffer2.bufMIC6[WaveRec_idxSens6++] = vRawSens6;
   1350          	
   1351          										break;
   1352          								case BUF2_PLAY:
   1353          
   1354          										Buffer3.bufMIC1[WaveRec_idxSens1++] = vRawSens1;
   1355          										Buffer3.bufMIC2[WaveRec_idxSens2++] = vRawSens2;
   1356          										Buffer3.bufMIC3[WaveRec_idxSens3++] = vRawSens3;
   1357          										Buffer3.bufMIC4[WaveRec_idxSens4++] = vRawSens4;
   1358          										Buffer3.bufMIC5[WaveRec_idxSens5++] = vRawSens5;
   1359          										Buffer3.bufMIC6[WaveRec_idxSens6++] = vRawSens6;
   1360          		
   1361          
   1362          										break;
   1363          								case BUF3_PLAY:
   1364          
   1365          										Buffer1.bufMIC1[WaveRec_idxSens1++] = vRawSens1;
   1366          										Buffer1.bufMIC2[ WaveRec_idxSens2++] = vRawSens2;
   1367          										Buffer1.bufMIC3[WaveRec_idxSens3++] = vRawSens3;
   1368          										Buffer1.bufMIC4[ WaveRec_idxSens4++] = vRawSens4;
   1369          										Buffer1.bufMIC5[WaveRec_idxSens5++] = vRawSens5;
   1370          										Buffer1.bufMIC6[ WaveRec_idxSens6++] = vRawSens6;
   1371          										break;
   1372          								default:
   1373          										break; 
   1374          					   }
   1375          				
   1376          				}
   1377                               
   1378               	}
   1379          }
   \   00000030   0xBC10             POP      {R4}
   \   00000032   0x4770             BX       LR
   \                     ??RecordUpdBuf_2: (+1)
   \   00000034   0x8813             LDRH     R3,[R2, #+0]
   \   00000036   0x1C5C             ADDS     R4,R3,#+1
   \   00000038   0x8014             STRH     R4,[R2, #+0]
   \   0000003A   0x....             LDR.N    R2,??DataTable15_4  ;; 0xc00080a0
   \   0000003C   0xE009             B.N      ??RecordUpdBuf_5
   \                     ??RecordUpdBuf_4: (+1)
   \   0000003E   0x8813             LDRH     R3,[R2, #+0]
   \   00000040   0x1C5C             ADDS     R4,R3,#+1
   \   00000042   0x8014             STRH     R4,[R2, #+0]
   \   00000044   0x....             LDR.N    R2,??DataTable15_5  ;; 0xc0010140
   \   00000046   0xE004             B.N      ??RecordUpdBuf_5
   \                     ??RecordUpdBuf_3: (+1)
   \   00000048   0x8813             LDRH     R3,[R2, #+0]
   \   0000004A   0x1C5C             ADDS     R4,R3,#+1
   \   0000004C   0x8014             STRH     R4,[R2, #+0]
   \   0000004E   0xF04F 0x4240      MOV      R2,#-1073741824
   \                     ??RecordUpdBuf_5: (+1)
   \   00000052   0xF9B0 0x4008      LDRSH    R4,[R0, #+8]
   \   00000056   0xF822 0x4013      STRH     R4,[R2, R3, LSL #+1]
   \   0000005A   0x880B             LDRH     R3,[R1, #+0]
   \   0000005C   0x1C5C             ADDS     R4,R3,#+1
   \   0000005E   0xEB02 0x0343      ADD      R3,R2,R3, LSL #+1
   \   00000062   0x800C             STRH     R4,[R1, #+0]
   \   00000064   0xF9B0 0x100A      LDRSH    R1,[R0, #+10]
   \   00000068   0xF241 0x0414      MOVW     R4,#+4116
   \   0000006C   0x52E1             STRH     R1,[R4, R3]
   \   0000006E   0x....             LDR.N    R1,??DataTable16_4
   \   00000070   0x880B             LDRH     R3,[R1, #+0]
   \   00000072   0x1C5C             ADDS     R4,R3,#+1
   \   00000074   0xEB02 0x0343      ADD      R3,R2,R3, LSL #+1
   \   00000078   0x800C             STRH     R4,[R1, #+0]
   \   0000007A   0xF9B0 0x100E      LDRSH    R1,[R0, #+14]
   \   0000007E   0xF242 0x0428      MOVW     R4,#+8232
   \   00000082   0x52E1             STRH     R1,[R4, R3]
   \   00000084   0x....             LDR.N    R1,??DataTable17
   \   00000086   0x880B             LDRH     R3,[R1, #+0]
   \   00000088   0x1C5C             ADDS     R4,R3,#+1
   \   0000008A   0xEB02 0x0343      ADD      R3,R2,R3, LSL #+1
   \   0000008E   0x800C             STRH     R4,[R1, #+0]
   \   00000090   0xF9B0 0x100C      LDRSH    R1,[R0, #+12]
   \   00000094   0xF243 0x043C      MOVW     R4,#+12348
   \   00000098   0x52E1             STRH     R1,[R4, R3]
   \   0000009A   0x....             LDR.N    R1,??DataTable16_7
   \   0000009C   0x880B             LDRH     R3,[R1, #+0]
   \   0000009E   0x1C5C             ADDS     R4,R3,#+1
   \   000000A0   0xEB02 0x0343      ADD      R3,R2,R3, LSL #+1
   \   000000A4   0x800C             STRH     R4,[R1, #+0]
   \   000000A6   0xF9B0 0x1010      LDRSH    R1,[R0, #+16]
   \   000000AA   0xF244 0x0450      MOVW     R4,#+16464
   \   000000AE   0x52E1             STRH     R1,[R4, R3]
   \   000000B0   0x....             LDR.N    R1,??DataTable16_8
   \   000000B2   0x880B             LDRH     R3,[R1, #+0]
   \   000000B4   0x1C5C             ADDS     R4,R3,#+1
   \   000000B6   0x800C             STRH     R4,[R1, #+0]
   \   000000B8   0xF9B0 0x0012      LDRSH    R0,[R0, #+18]
   \   000000BC   0xEB02 0x0143      ADD      R1,R2,R3, LSL #+1
   \   000000C0   0xF245 0x0264      MOVW     R2,#+20580
   \   000000C4   0x5250             STRH     R0,[R2, R1]
   \                     ??RecordUpdBuf_1: (+1)
   \   000000C6   0xBC10             POP      {R4}
   \   000000C8   0x4770             BX       LR               ;; return
   \   000000CA                      REQUIRE Buffer2
   \   000000CA                      REQUIRE Buffer3
   \   000000CA                      REQUIRE Buffer1
   1380          
   1381          

   \                                 In section .text, align 2, keep-with-next
   1382          void DMA2_Stream5_IRQHandler(void)
   1383          {
   1384            /* USER CODE BEGIN DMA2_Stream5_IRQn 0 */
   1385          
   1386            /* USER CODE END DMA2_Stream5_IRQn 0 */
   1387            HAL_DMA_IRQHandler(&hdma_spi5_rx);
   \                     DMA2_Stream5_IRQHandler: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable17_26
   \   00000004   0x.... 0x....      B.W      HAL_DMA_IRQHandler
   1388            /* USER CODE BEGIN DMA2_Stream5_IRQn 1 */
   1389          
   1390            /* USER CODE END DMA2_Stream5_IRQn 1 */
   1391          }
   1392          
   1393          /**
   1394          * @brief This function handles DMA2 stream6 global interrupt.
   1395          */

   \                                 In section .text, align 2, keep-with-next
   1396          void DMA2_Stream6_IRQHandler(void)
   1397          {
   1398            /* USER CODE BEGIN DMA2_Stream6_IRQn 0 */
   1399          
   1400            /* USER CODE END DMA2_Stream6_IRQn 0 */
   1401            HAL_DMA_IRQHandler(&hdma_spi6_rx);
   \                     DMA2_Stream6_IRQHandler: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable17_29
   \   00000004   0x.... 0x....      B.W      HAL_DMA_IRQHandler
   1402            /* USER CODE BEGIN DMA2_Stream6_IRQn 1 */
   1403          
   1404            /* USER CODE END DMA2_Stream6_IRQn 1 */
   1405          }
   1406          

   \                                 In section .text, align 2, keep-with-next
   1407          void HAL_SPI_RxCpltCallback(SPI_HandleTypeDef *hspi)
   1408          {
   \                     HAL_SPI_RxCpltCallback: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   1409              if(hspi->Instance==SPI1)
   1410              {
   1411                  /* Copy Data to Record Buffer */
   1412          		//RecordUpdBuf();
   1413          		//XferCplt = 1;
   1414                  //Audio_Play_Out();
   1415              }
   1416              else if (hspi->Instance==SPI2)
   1417              {
   1418          
   1419              }
   1420              else if (hspi->Instance==SPI4)
   1421              {
   1422          
   1423              }
   1424          	else
   1425          	{
   1426          
   1427          	}
   1428          
   1429              if (hspi->Instance==SPI5)
   \   00000004   0x....             LDR.N    R1,??DataTable17_18  ;; 0x40015000
   \   00000006   0x6820             LDR      R0,[R4, #+0]
   \   00000008   0x4288             CMP      R0,R1
   \   0000000A   0xD111             BNE.N    ??HAL_SPI_RxCpltCallback_0
   1430              {
   1431                  MIC7Rec();
   \   0000000C   0x....             LDR.N    R0,??DataTable17_6
   \   0000000E   0x....             LDR.N    R3,??DataTable17_2
   \   00000010   0xF44F 0x5280      MOV      R2,#+4096
   \   00000014   0x7801             LDRB     R1,[R0, #+0]
   \   00000016   0xF081 0x0101      EOR      R1,R1,#0x1
   \   0000001A   0x7001             STRB     R1,[R0, #+0]
   \   0000001C   0x2101             MOVS     R1,#+1
   \   0000001E   0x7081             STRB     R1,[R0, #+2]
   \   00000020   0x7800             LDRB     R0,[R0, #+0]
   \   00000022   0x2801             CMP      R0,#+1
   \   00000024   0xBF0C             ITE      EQ 
   \   00000026   0x....             LDREQ.N  R1,??DataTable17_30
   \   00000028   0x....             LDRNE.N  R1,??DataTable17_10
   \   0000002A   0x1D18             ADDS     R0,R3,#+4
   \   0000002C   0x.... 0x....      BL       HAL_SPI_Receive_DMA
   1432              }
   1433              else
   1434              {
   1435                
   1436              }
   1437              
   1438              if (hspi->Instance==SPI6) //MIC8
   \                     ??HAL_SPI_RxCpltCallback_0: (+1)
   \   00000030   0x6820             LDR      R0,[R4, #+0]
   \   00000032   0x....             LDR.N    R1,??DataTable17_19  ;; 0x40015400
   \   00000034   0x4288             CMP      R0,R1
   \   00000036   0xD113             BNE.N    ??HAL_SPI_RxCpltCallback_1
   1439              {
   1440          #if 0							
   1441          
   1442              if (swtSDO8==0x01)
   1443             {
   1444                 HAL_SPI_Receive_DMA(&hspi6,( uint8_t *)&TestSDO8_1[64*idxFrmPDMMic8],4*(AUDIO_SAMPLING_FREQUENCY/1000));
   1445             }
   1446             else
   1447             {
   1448          	   HAL_SPI_Receive_DMA(&hspi6,( uint8_t *)&TestSDO8[64*idxFrmPDMMic8],4*(AUDIO_SAMPLING_FREQUENCY/1000));
   1449             }      
   1450             AudioUSBSend(idxFrmPDMMic8++);
   1451          
   1452             if(idxFrmPDMMic8==(4*AUDIO_OUT_BUFFER_SIZE/64))
   1453             {
   1454                 swtSDO8^=0x01;
   1455                 WaveRecord_flgSDO8Finish = 1;
   1456                 idxFrmPDMMic8 = 0;
   1457          		RESET_IDX
   1458          		XferCplt = 0; // clear DMA interrupt flag
   1459          		switch (buffer_switch)
   1460          		{
   1461          	        case BUF1_PLAY: 		
   1462          	          buffer_switch = BUF3_PLAY;
   1463          	          break;
   1464          	        case BUF2_PLAY: 
   1465          	          buffer_switch = BUF1_PLAY;		
   1466          	          break;
   1467          	        case BUF3_PLAY: 	
   1468          	          buffer_switch = BUF2_PLAY;
   1469          	          break;
   1470          	        default:
   1471          	          break;
   1472          		}
   1473          
   1474          		/* Last player Frame is finished */
   1475          		AudioPlayerUpd(); 		
   1476          		
   1477          		if (cntStrt<100) cntStrt++;		   
   1478                  
   1479             }
   1480          
   1481          
   1482          #else
   1483              MIC8Rec();
   \   00000038   0x....             LDR.N    R0,??DataTable17_6
   \   0000003A   0x....             LDR.N    R3,??DataTable17_7
   \   0000003C   0xF44F 0x5280      MOV      R2,#+4096
   \   00000040   0x7841             LDRB     R1,[R0, #+1]
   \   00000042   0xF081 0x0101      EOR      R1,R1,#0x1
   \   00000046   0x7041             STRB     R1,[R0, #+1]
   \   00000048   0x2101             MOVS     R1,#+1
   \   0000004A   0x70C1             STRB     R1,[R0, #+3]
   \   0000004C   0x7840             LDRB     R0,[R0, #+1]
   \   0000004E   0x2801             CMP      R0,#+1
   \   00000050   0xBF0C             ITE      EQ 
   \   00000052   0x....             LDREQ.N  R1,??DataTable17_31
   \   00000054   0x....             LDRNE.N  R1,??DataTable17_12
   \   00000056   0x1D18             ADDS     R0,R3,#+4
   \   00000058   0xE8BD 0x4010      POP      {R4,LR}
   \   0000005C   0x.... 0x....      B.W      HAL_SPI_Receive_DMA
   1484          	
   1485          #endif
   1486          
   1487            }
   1488          }
   \                     ??HAL_SPI_RxCpltCallback_1: (+1)
   \   00000060   0xBD10             POP      {R4,PC}          ;; return
   1489          

   \                                 In section .text, align 2, keep-with-next
   1490          void PDM2PCMSDO78(void)
   1491          {
   \                     PDM2PCMSDO78: (+1)
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0x....             LDR.N    R0,??DataTable17_32
   \   00000006   0xB083             SUB      SP,SP,#+12
   1492          static int16_t Mic7LPOld,Mic8LPOld;
   1493          uint8_t buffer_switch_tmp;
   1494          
   1495          buffer_switch_tmp = buffer_switch;
   1496          
   1497          /*-------------------------------------------------------------------------------------------------------------
   1498          			  
   1499          	Sequence  Record Data					  Processing Data				  Player Data
   1500          			  
   1501          	1-------  Buffer1						  Buffer2				  Buffer3 BUF3_PLAY)
   1502          			  
   1503          	2-------  Buffer3						  Buffer1				  Buffer2 (BUF2_PLAY)		  
   1504          			  
   1505          	3-------  Buffer2						  Buffer3				  Buffer1 (BUF1_PLAY)
   1506           ---------------------------------------------------------------------------------------------------------------*/
   1507          
   1508              /* Data in Mic7 finished recording */
   1509              if (WaveRecord_flgSDO7Finish==1)
   \   00000008   0x....             LDR.N    R4,??DataTable17_6
   \   0000000A   0x7800             LDRB     R0,[R0, #+0]
   \   0000000C   0x9001             STR      R0,[SP, #+4]
   \   0000000E   0x78A0             LDRB     R0,[R4, #+2]
   \   00000010   0x2801             CMP      R0,#+1
   \   00000012   0xF040 0x8086      BNE.W    ??PDM2PCMSDO78_0
   1510              {
   1511                  WaveRecord_flgSDO7Finish=0;
   \   00000016   0x2000             MOVS     R0,#+0
   1512          
   1513                  uint8_t swtSDO7_tmp;
   1514                  swtSDO7_tmp = swtSDO7;
   1515          		for (uint16_t i=0; i< 4*AUDIO_OUT_BUFFER_SIZE;i++)
   \   00000018   0x2700             MOVS     R7,#+0
   \   0000001A   0x70A0             STRB     R0,[R4, #+2]
   \   0000001C   0x7820             LDRB     R0,[R4, #+0]
   \   0000001E   0x....             LDR.N    R5,??DataTable17_10
   \   00000020   0x....             LDR.N    R6,??DataTable17_30
   \   00000022   0x.... 0x....      LDR.W    R8,??DataTable17_33  ;; 0xc00080a0
   \   00000026   0x.... 0x....      LDR.W    R9,??DataTable17_1  ;; 0xc0010140
   \   0000002A   0x9000             STR      R0,[SP, #+0]
   \   0000002C   0xF246 0x0B78      MOVW     R11,#+24696
   \   00000030   0xF04F 0x4A40      MOV      R10,#-1073741824
   1516          		{
   1517          	        if(swtSDO7_tmp==0x01)
   \                     ??PDM2PCMSDO78_1: (+1)
   \   00000034   0x9800             LDR      R0,[SP, #+0]
   1518          	        {
   1519          	            pDataMic7[i%64] = HTONS(TestSDO7[i]);					
                 	            ^
Warning[Pa082]: undefined behavior: the order of volatile accesses is
          undefined in this statement
   1520          	        }
   1521          	        else
   1522          	        {
   1523          	           pDataMic7[i%64] = HTONS(TestSDO7_1[i]);
                 	           ^
Warning[Pa082]: undefined behavior: the order of volatile accesses is
          undefined in this statement
   \   00000036   0x....             LDR.N    R2,??DataTable17_9
   \   00000038   0x2801             CMP      R0,#+1
   \   0000003A   0xBF07             ITTEE    EQ 
   \   0000003C   0x8828             LDRHEQ   R0,[R5, #+0]
   \   0000003E   0x8829             LDRHEQ   R1,[R5, #+0]
   \   00000040   0x8830             LDRHNE   R0,[R6, #+0]
   \   00000042   0x8831             LDRHNE   R1,[R6, #+0]
   \   00000044   0x117B             ASRS     R3,R7,#+5
   \   00000046   0x0209             LSLS     R1,R1,#+8
   \   00000048   0xEB07 0x6393      ADD      R3,R7,R3, LSR #+26
   \   0000004C   0xEA41 0x2010      ORR      R0,R1,R0, LSR #+8
   \   00000050   0x119B             ASRS     R3,R3,#+6
   \   00000052   0xEBA7 0x1383      SUB      R3,R7,R3, LSL #+6
   \   00000056   0xF822 0x0013      STRH     R0,[R2, R3, LSL #+1]
   1524          	        }
   1525          
   1526          	        /* PDM conversion for frame of 64 inputs, 16 outputs */
   1527          	        if (i%64==63)
   \   0000005A   0x1178             ASRS     R0,R7,#+5
   \   0000005C   0xEB07 0x6090      ADD      R0,R7,R0, LSR #+26
   \   00000060   0x1180             ASRS     R0,R0,#+6
   \   00000062   0xEBA7 0x1180      SUB      R1,R7,R0, LSL #+6
   \   00000066   0x293F             CMP      R1,#+63
   \   00000068   0xD118             BNE.N    ??PDM2PCMSDO78_2
   1528          	        {
   1529          				/* Put them in processing phase */
   1530          	          /* Recording Audio Data */						 
   1531          	          switch (buffer_switch_tmp)
   \   0000006A   0x9901             LDR      R1,[SP, #+4]
   \   0000006C   0xB119             CBZ.N    R1,??PDM2PCMSDO78_3
   \   0000006E   0x2902             CMP      R1,#+2
   \   00000070   0xD00B             BEQ.N    ??PDM2PCMSDO78_4
   \   00000072   0xD305             BCC.N    ??PDM2PCMSDO78_5
   \   00000074   0xE012             B.N      ??PDM2PCMSDO78_2
   1532          	          {
   1533          			    case BUF1_PLAY:								
   1534                            PDM_Filter_64_LSB((uint8_t *)pDataMic7,(uint16_t *)(Buffer2.bufMIC7 + (i/64)*16), 150 ,
   1535                            (PDMFilter_InitStruct *)&Filter[0]);						  
   \                     ??PDM2PCMSDO78_3: (+1)
   \   00000076   0x1D23             ADDS     R3,R4,#+4
   \   00000078   0x2296             MOVS     R2,#+150
   \   0000007A   0xEB08 0x1040      ADD      R0,R8,R0, LSL #+5
   \   0000007E   0xE008             B.N      ??PDM2PCMSDO78_6
   1536                            break;	              
   1537          	            case BUF2_PLAY:
   1538          					PDM_Filter_64_LSB((uint8_t *)pDataMic7,(uint16_t *)(Buffer3.bufMIC7 + (i/64)*16), 150 ,
   1539          					(PDMFilter_InitStruct *)&Filter[0]);							
   \                     ??PDM2PCMSDO78_5: (+1)
   \   00000080   0x1D23             ADDS     R3,R4,#+4
   \   00000082   0x2296             MOVS     R2,#+150
   \   00000084   0xEB09 0x1040      ADD      R0,R9,R0, LSL #+5
   \   00000088   0xE003             B.N      ??PDM2PCMSDO78_6
   1540          					break;
   1541          	            case BUF3_PLAY:
   1542          					PDM_Filter_64_LSB((uint8_t *)pDataMic7,(uint16_t *)(Buffer1.bufMIC7 + (i/64)*16), 150 ,
   1543          					(PDMFilter_InitStruct *)&Filter[0]);		
   \                     ??PDM2PCMSDO78_4: (+1)
   \   0000008A   0x1D23             ADDS     R3,R4,#+4
   \   0000008C   0x2296             MOVS     R2,#+150
   \   0000008E   0xEB0A 0x1040      ADD      R0,R10,R0, LSL #+5
   \                     ??PDM2PCMSDO78_6: (+1)
   \   00000092   0xEB0B 0x0100      ADD      R1,R11,R0
   \   00000096   0x....             LDR.N    R0,??DataTable17_9
   \   00000098   0x.... 0x....      BL       PDM_Filter_64_LSB
   1544          					break;
   1545          	            default:
   1546          	                break; 
   1547          	          }
   1548          	        }
   1549          	     }
   \                     ??PDM2PCMSDO78_2: (+1)
   \   0000009C   0x1C7F             ADDS     R7,R7,#+1
   \   0000009E   0x1CB6             ADDS     R6,R6,#+2
   \   000000A0   0x1CAD             ADDS     R5,R5,#+2
   \   000000A2   0xF5B7 0x5F80      CMP      R7,#+4096
   \   000000A6   0xDBC5             BLT.N    ??PDM2PCMSDO78_1
   1550                  /* LowPass Filter 
   1551                        dT = 1/16000
   1552                        K = T/dT  => T = dT*K = 1/16000*2 = 1/fc => fc = 8000
   1553          		*/						 
   1554          		switch (buffer_switch)
   \   000000A8   0x....             LDR.N    R0,??DataTable17_32
   \   000000AA   0x7800             LDRB     R0,[R0, #+0]
   \   000000AC   0xB118             CBZ.N    R0,??PDM2PCMSDO78_7
   \   000000AE   0x2802             CMP      R0,#+2
   \   000000B0   0xD00E             BEQ.N    ??PDM2PCMSDO78_8
   \   000000B2   0xD30A             BCC.N    ??PDM2PCMSDO78_9
   \   000000B4   0xE017             B.N      ??PDM2PCMSDO78_10
   1555          		{
   1556          			case BUF1_PLAY: 
   1557          				LowPassIIR(Buffer2.bufMIC7 ,Buffer2.bufMIC7 ,&Mic7LPOld,AUDIO_OUT_BUFFER_SIZE,4);
   \                     ??PDM2PCMSDO78_7: (+1)
   \   000000B6   0x2004             MOVS     R0,#+4
   \   000000B8   0xEB0B 0x0108      ADD      R1,R11,R8
   \   000000BC   0x9000             STR      R0,[SP, #+0]
   \   000000BE   0xF44F 0x6380      MOV      R3,#+1024
   \   000000C2   0xF104 0x026C      ADD      R2,R4,#+108
   \   000000C6   0x4608             MOV      R0,R1
   \   000000C8   0xE00B             B.N      ??PDM2PCMSDO78_11
   1558          			    break;
   1559          			case BUF2_PLAY:
   1560          				LowPassIIR(Buffer3.bufMIC7 ,Buffer3.bufMIC7 ,&Mic7LPOld,AUDIO_OUT_BUFFER_SIZE,4);
   \                     ??PDM2PCMSDO78_9: (+1)
   \   000000CA   0xEB0B 0x0009      ADD      R0,R11,R9
   \   000000CE   0xE001             B.N      ??PDM2PCMSDO78_12
   1561          			    break;
   1562          			case BUF3_PLAY:
   1563          			    LowPassIIR(Buffer1.bufMIC7 ,Buffer1.bufMIC7 ,&Mic7LPOld,AUDIO_OUT_BUFFER_SIZE,4);						
   \                     ??PDM2PCMSDO78_8: (+1)
   \   000000D0   0xEB0B 0x000A      ADD      R0,R11,R10
   \                     ??PDM2PCMSDO78_12: (+1)
   \   000000D4   0x2104             MOVS     R1,#+4
   \   000000D6   0xF44F 0x6380      MOV      R3,#+1024
   \   000000DA   0x9100             STR      R1,[SP, #+0]
   \   000000DC   0xF104 0x026C      ADD      R2,R4,#+108
   \   000000E0   0x4601             MOV      R1,R0
   \                     ??PDM2PCMSDO78_11: (+1)
   \   000000E2   0x.... 0x....      BL       LowPassIIR
   1564          			    break;
   1565          			default:
   1566          			break; 
   1567          		}
   1568          
   1569             switch (buffer_switch_tmp)
   \                     ??PDM2PCMSDO78_10: (+1)
   \   000000E6   0x9801             LDR      R0,[SP, #+4]
   \   000000E8   0xB118             CBZ.N    R0,??PDM2PCMSDO78_13
   \   000000EA   0x2802             CMP      R0,#+2
   \   000000EC   0xD00F             BEQ.N    ??PDM2PCMSDO78_14
   \   000000EE   0xD30B             BCC.N    ??PDM2PCMSDO78_15
   \   000000F0   0xE017             B.N      ??PDM2PCMSDO78_0
   1570            {
   1571          	case BUF1_PLAY:								
   1572          		Buffer2.bufMIC7[0]=Buffer2.bufMIC7[4];
   \                     ??PDM2PCMSDO78_13: (+1)
   \   000000F2   0xEB0B 0x0108      ADD      R1,R11,R8
   \   000000F6   0x8908             LDRH     R0,[R1, #+8]
   \   000000F8   0x8008             STRH     R0,[R1, #+0]
   1573          		Buffer2.bufMIC7[1]=Buffer2.bufMIC7[5];
   \   000000FA   0x8948             LDRH     R0,[R1, #+10]
   \   000000FC   0x8048             STRH     R0,[R1, #+2]
   1574          		Buffer2.bufMIC7[2]=Buffer2.bufMIC7[6];
   \   000000FE   0x8988             LDRH     R0,[R1, #+12]
   \   00000100   0x8088             STRH     R0,[R1, #+4]
   1575          		Buffer2.bufMIC7[3]=Buffer2.bufMIC7[7];								
   \   00000102   0x89C8             LDRH     R0,[R1, #+14]
   \   00000104   0x80C8             STRH     R0,[R1, #+6]
   1576          	    break;	              
   \   00000106   0xE00C             B.N      ??PDM2PCMSDO78_0
   1577          	case BUF2_PLAY:	
   1578          		Buffer3.bufMIC7[0]=Buffer3.bufMIC7[4];
   \                     ??PDM2PCMSDO78_15: (+1)
   \   00000108   0xEB0B 0x0009      ADD      R0,R11,R9
   \   0000010C   0xE001             B.N      ??PDM2PCMSDO78_16
   1579          		Buffer3.bufMIC7[1]=Buffer3.bufMIC7[5];
   1580          		Buffer3.bufMIC7[2]=Buffer3.bufMIC7[6];
   1581          		Buffer3.bufMIC7[3]=Buffer3.bufMIC7[7];				
   1582          	    break;
   1583          	case BUF3_PLAY:
   1584          		Buffer1.bufMIC7[0]=Buffer1.bufMIC7[4];
   \                     ??PDM2PCMSDO78_14: (+1)
   \   0000010E   0xEB0B 0x000A      ADD      R0,R11,R10
   \                     ??PDM2PCMSDO78_16: (+1)
   \   00000112   0x8901             LDRH     R1,[R0, #+8]
   \   00000114   0x8001             STRH     R1,[R0, #+0]
   1585          		Buffer1.bufMIC7[1]=Buffer1.bufMIC7[5];
   \   00000116   0x8941             LDRH     R1,[R0, #+10]
   \   00000118   0x8041             STRH     R1,[R0, #+2]
   1586          		Buffer1.bufMIC7[2]=Buffer1.bufMIC7[6];
   \   0000011A   0x8981             LDRH     R1,[R0, #+12]
   \   0000011C   0x8081             STRH     R1,[R0, #+4]
   1587          		Buffer1.bufMIC7[3]=Buffer1.bufMIC7[7];				
   \   0000011E   0x89C1             LDRH     R1,[R0, #+14]
   \   00000120   0x80C1             STRH     R1,[R0, #+6]
   1588          	    break;
   1589          	default:
   1590          	         break; 
   1591            }
   1592          
   1593          	}
   1594          #if 0
   1595                      /* Recording Audio Data */						 
   1596          		    switch (buffer_switch)//buffer_switch
   1597          		    {
   1598          		        case BUF1_PLAY:								
   1599          					        /* Update for left-right channel */
   1600          			        for (int16_t i=AUDIO_OUT_BUFFER_SIZE-1; i>1;i--)
   1601          			        {
   1602          	                    Buffer2.bufMIC7[2*i+1]=  Buffer2.bufMIC7[i];
   1603                                  Buffer2.bufMIC7[2*i] = Buffer2.bufMIC7[i];
   1604          			        }
   1605          					  Buffer2.bufMIC7[0] = Buffer2.bufMIC7[4];
   1606          					  Buffer2.bufMIC7[1] = Buffer2.bufMIC7[5];
   1607          					  Buffer2.bufMIC7[2] = Buffer2.bufMIC7[6];
   1608          					  Buffer2.bufMIC7[3] = Buffer2.bufMIC7[7];
   1609          			            break;
   1610          			     case BUF2_PLAY:
   1611          			        /* Update for left-right channel */
   1612          			        for (int16_t i=AUDIO_OUT_BUFFER_SIZE-1; i>1;i--)
   1613          			        {				 	
   1614          		                Buffer3.bufMIC7[2*i+1]= Buffer3.bufMIC7[i];
   1615          		                Buffer3.bufMIC7[2*i]= Buffer3.bufMIC7[i];;	
   1616          			        }
   1617          					  Buffer3.bufMIC7[0] = Buffer3.bufMIC7[4];
   1618          					  Buffer3.bufMIC7[1] = Buffer3.bufMIC7[5];
   1619          					  Buffer3.bufMIC7[2] = Buffer3.bufMIC7[6];
   1620          					  Buffer3.bufMIC7[3] = Buffer3.bufMIC7[7];					
   1621          	                break;
   1622          	            case BUF3_PLAY:
   1623          			        /* Update for left-right channel */
   1624          			        for (int16_t i=AUDIO_OUT_BUFFER_SIZE-1; i>1;i--)
   1625          			        {					
   1626          	                    Buffer1.bufMIC7[2*i+1]= Buffer1.bufMIC7[i];
   1627          	                    Buffer1.bufMIC7[2*i]= Buffer1.bufMIC7[i];;	
   1628          			        }
   1629          					  Buffer1.bufMIC7[0] = Buffer1.bufMIC7[4];
   1630          					  Buffer1.bufMIC7[1] = Buffer1.bufMIC7[5];
   1631          					  Buffer1.bufMIC7[2] = Buffer1.bufMIC7[6];
   1632          					  Buffer1.bufMIC7[3] = Buffer1.bufMIC7[7];						
   1633          	                break;
   1634          	            default:
   1635          	                break; 
   1636          	        }
   1637          	    
   1638          
   1639               }
   1640              
   1641          #endif	
   1642          
   1643          	/* Data in Mic8 finished recording */
   1644          	if (WaveRecord_flgSDO8Finish==1)
   \                     ??PDM2PCMSDO78_0: (+1)
   \   00000122   0x78E0             LDRB     R0,[R4, #+3]
   \   00000124   0x2801             CMP      R0,#+1
   \   00000126   0xD17B             BNE.N    ??PDM2PCMSDO78_17
   1645          	{
   1646          		WaveRecord_flgSDO8Finish=0;
   \   00000128   0x2000             MOVS     R0,#+0
   1647          		uint8_t swtSDO8_tmp;
   1648          		swtSDO8_tmp = swtSDO8;
   1649          		for (uint16_t i=0; i< 4*AUDIO_OUT_BUFFER_SIZE;i++)
   \   0000012A   0x2700             MOVS     R7,#+0
   \   0000012C   0x70E0             STRB     R0,[R4, #+3]
   \   0000012E   0x7860             LDRB     R0,[R4, #+1]
   \   00000130   0x....             LDR.N    R5,??DataTable17_12
   \   00000132   0x....             LDR.N    R6,??DataTable17_31
   \   00000134   0xF247 0x0B8C      MOVW     R11,#+28812
   \   00000138   0x.... 0x....      LDR.W    R8,??DataTable17_33  ;; 0xc00080a0
   \   0000013C   0x9000             STR      R0,[SP, #+0]
   \   0000013E   0x.... 0x....      LDR.W    R9,??DataTable17_1  ;; 0xc0010140
   \   00000142   0xF04F 0x4A40      MOV      R10,#-1073741824
   1650          		{
   1651                            if(swtSDO8_tmp==0x01)
   \                     ??PDM2PCMSDO78_18: (+1)
   \   00000146   0x9800             LDR      R0,[SP, #+0]
   1652                            {
   1653                               pDataMic8[i%64] = HTONS(TestSDO8[i]);
                                      ^
Warning[Pa082]: undefined behavior: the order of volatile accesses is
          undefined in this statement
   1654                            }
   1655                            else
   1656                            {
   1657                               pDataMic8[i%64] = HTONS(TestSDO8_1[i]);
                                      ^
Warning[Pa082]: undefined behavior: the order of volatile accesses is
          undefined in this statement
   \   00000148   0x....             LDR.N    R2,??DataTable17_4
   \   0000014A   0x2801             CMP      R0,#+1
   \   0000014C   0xBF07             ITTEE    EQ 
   \   0000014E   0x8828             LDRHEQ   R0,[R5, #+0]
   \   00000150   0x8829             LDRHEQ   R1,[R5, #+0]
   \   00000152   0x8830             LDRHNE   R0,[R6, #+0]
   \   00000154   0x8831             LDRHNE   R1,[R6, #+0]
   \   00000156   0x117B             ASRS     R3,R7,#+5
   \   00000158   0x0209             LSLS     R1,R1,#+8
   \   0000015A   0xEB07 0x6393      ADD      R3,R7,R3, LSR #+26
   \   0000015E   0xEA41 0x2010      ORR      R0,R1,R0, LSR #+8
   \   00000162   0x119B             ASRS     R3,R3,#+6
   \   00000164   0xEBA7 0x1383      SUB      R3,R7,R3, LSL #+6
   \   00000168   0xF822 0x0013      STRH     R0,[R2, R3, LSL #+1]
   1658                            }
   1659          		
   1660                            /* PDM conversion for frame of 64 inputs, 16 outputs */
   1661                            if (i%64==63)
   \   0000016C   0x1178             ASRS     R0,R7,#+5
   \   0000016E   0xEB07 0x6090      ADD      R0,R7,R0, LSR #+26
   \   00000172   0x1180             ASRS     R0,R0,#+6
   \   00000174   0xEBA7 0x1180      SUB      R1,R7,R0, LSL #+6
   \   00000178   0x293F             CMP      R1,#+63
   \   0000017A   0xD11C             BNE.N    ??PDM2PCMSDO78_19
   1662                            {
   1663                                /* Recording Audio Data */						 
   1664                                switch (buffer_switch)
   \   0000017C   0x....             LDR.N    R1,??DataTable17_32
   \   0000017E   0x7809             LDRB     R1,[R1, #+0]
   \   00000180   0xB119             CBZ.N    R1,??PDM2PCMSDO78_20
   \   00000182   0x2902             CMP      R1,#+2
   \   00000184   0xD00D             BEQ.N    ??PDM2PCMSDO78_21
   \   00000186   0xD306             BCC.N    ??PDM2PCMSDO78_22
   \   00000188   0xE015             B.N      ??PDM2PCMSDO78_19
   1665                                {
   1666                                        case BUF1_PLAY: 							
   1667                                                PDM_Filter_64_LSB((uint8_t *)pDataMic8,(uint16_t *)(Buffer2.bufMIC8 + (i/64)*16), 150 ,
   1668                                                (PDMFilter_InitStruct *)&Filter[1]);
   \                     ??PDM2PCMSDO78_20: (+1)
   \   0000018A   0xF104 0x0338      ADD      R3,R4,#+56
   \   0000018E   0x2296             MOVS     R2,#+150
   \   00000190   0xEB08 0x1040      ADD      R0,R8,R0, LSL #+5
   \   00000194   0xE00A             B.N      ??PDM2PCMSDO78_23
   1669                                                break;
   1670                                        case BUF2_PLAY:
   1671                                                PDM_Filter_64_LSB((uint8_t *)pDataMic8,(uint16_t *)(Buffer3.bufMIC8 + (i/64)*16), 150 ,
   1672                                                (PDMFilter_InitStruct *)&Filter[1]);	
   \                     ??PDM2PCMSDO78_22: (+1)
   \   00000196   0xF104 0x0338      ADD      R3,R4,#+56
   \   0000019A   0x2296             MOVS     R2,#+150
   \   0000019C   0xEB09 0x1040      ADD      R0,R9,R0, LSL #+5
   \   000001A0   0xE004             B.N      ??PDM2PCMSDO78_23
   1673                                                break;
   1674                                        case BUF3_PLAY:
   1675                                                PDM_Filter_64_LSB((uint8_t *)pDataMic8,(uint16_t *)(Buffer1.bufMIC8 + (i/64)*16), 150 ,
   1676                                                (PDMFilter_InitStruct *)&Filter[1]);									
   \                     ??PDM2PCMSDO78_21: (+1)
   \   000001A2   0xF104 0x0338      ADD      R3,R4,#+56
   \   000001A6   0x2296             MOVS     R2,#+150
   \   000001A8   0xEB0A 0x1040      ADD      R0,R10,R0, LSL #+5
   \                     ??PDM2PCMSDO78_23: (+1)
   \   000001AC   0xEB0B 0x0100      ADD      R1,R11,R0
   \   000001B0   0x....             LDR.N    R0,??DataTable17_4
   \   000001B2   0x.... 0x....      BL       PDM_Filter_64_LSB
   1677                                                 break;
   1678                                        default:
   1679                                                 break; 
   1680                                }		
   1681                             }					 
   1682          		}
   \                     ??PDM2PCMSDO78_19: (+1)
   \   000001B6   0x1C7F             ADDS     R7,R7,#+1
   \   000001B8   0x1CB6             ADDS     R6,R6,#+2
   \   000001BA   0x1CAD             ADDS     R5,R5,#+2
   \   000001BC   0xF5B7 0x5F80      CMP      R7,#+4096
   \   000001C0   0xDBC1             BLT.N    ??PDM2PCMSDO78_18
   1683          
   1684                  /* LowPass Filter 
   1685                        dT = 1/16000
   1686                        K = T/dT  => T = dT*K = 1/16000*2 = 1/fc => fc = 8000
   1687          		*/						 
   1688          		switch (buffer_switch)
   \   000001C2   0x....             LDR.N    R0,??DataTable17_32
   \   000001C4   0x7800             LDRB     R0,[R0, #+0]
   \   000001C6   0xB118             CBZ.N    R0,??PDM2PCMSDO78_24
   \   000001C8   0x2802             CMP      R0,#+2
   \   000001CA   0xD007             BEQ.N    ??PDM2PCMSDO78_25
   \   000001CC   0xD303             BCC.N    ??PDM2PCMSDO78_26
   \   000001CE   0xE010             B.N      ??PDM2PCMSDO78_27
   1689          		{
   1690          			case BUF1_PLAY: 
   1691          				LowPassIIR(Buffer2.bufMIC8 ,Buffer2.bufMIC8 ,&Mic8LPOld,AUDIO_OUT_BUFFER_SIZE,4);
   \                     ??PDM2PCMSDO78_24: (+1)
   \   000001D0   0xEB0B 0x0008      ADD      R0,R11,R8
   \   000001D4   0xE004             B.N      ??PDM2PCMSDO78_28
   1692          			    break;
   1693          			case BUF2_PLAY:
   1694          				LowPassIIR(Buffer3.bufMIC8 ,Buffer3.bufMIC8 ,&Mic8LPOld,AUDIO_OUT_BUFFER_SIZE,4);
   \                     ??PDM2PCMSDO78_26: (+1)
   \   000001D6   0xEB0B 0x0009      ADD      R0,R11,R9
   \   000001DA   0xE001             B.N      ??PDM2PCMSDO78_28
   1695          			    break;
   1696          			case BUF3_PLAY:
   1697          			    LowPassIIR(Buffer1.bufMIC8 ,Buffer1.bufMIC8 ,&Mic8LPOld,AUDIO_OUT_BUFFER_SIZE,4);						
   \                     ??PDM2PCMSDO78_25: (+1)
   \   000001DC   0xEB0B 0x000A      ADD      R0,R11,R10
   \                     ??PDM2PCMSDO78_28: (+1)
   \   000001E0   0x2104             MOVS     R1,#+4
   \   000001E2   0xF44F 0x6380      MOV      R3,#+1024
   \   000001E6   0x9100             STR      R1,[SP, #+0]
   \   000001E8   0xF104 0x026E      ADD      R2,R4,#+110
   \   000001EC   0x4601             MOV      R1,R0
   \   000001EE   0x.... 0x....      BL       LowPassIIR
   1698          			    break;
   1699          			default:
   1700          			break; 
   1701          		}
   1702                    					 
   1703                    switch (buffer_switch)
   \                     ??PDM2PCMSDO78_27: (+1)
   \   000001F2   0x....             LDR.N    R0,??DataTable17_32
   \   000001F4   0x7800             LDRB     R0,[R0, #+0]
   \   000001F6   0xB118             CBZ.N    R0,??PDM2PCMSDO78_29
   \   000001F8   0x2802             CMP      R0,#+2
   \   000001FA   0xD007             BEQ.N    ??PDM2PCMSDO78_30
   \   000001FC   0xD303             BCC.N    ??PDM2PCMSDO78_31
   1704                    {
   1705                        case BUF1_PLAY: 	
   1706          					  Buffer2.bufMIC8[0] = Buffer2.bufMIC8[4];
   1707          					  Buffer2.bufMIC8[1] = Buffer2.bufMIC8[5];
   1708          					  Buffer2.bufMIC8[2] = Buffer2.bufMIC8[6];
   1709          					  Buffer2.bufMIC8[3] = Buffer2.bufMIC8[7];
   1710                                break;
   1711                        case BUF2_PLAY:
   1712            					  Buffer3.bufMIC8[0] = Buffer3.bufMIC8[4];
   1713          					  Buffer3.bufMIC8[1] = Buffer3.bufMIC8[5];
   1714          					  Buffer3.bufMIC8[2] = Buffer3.bufMIC8[6];
   1715          					  Buffer3.bufMIC8[3] = Buffer3.bufMIC8[7];
   1716                                break;
   1717                        case BUF3_PLAY:
   1718            					  Buffer1.bufMIC8[0] = Buffer1.bufMIC8[4];
   1719          					  Buffer1.bufMIC8[1] = Buffer1.bufMIC8[5];
   1720          					  Buffer1.bufMIC8[2] = Buffer1.bufMIC8[6];
   1721          					  Buffer1.bufMIC8[3] = Buffer1.bufMIC8[7];
   1722                              break;
   1723                        default:
   1724                              break; 
   1725                    }                	  
   1726             }//if (WaveRecord_flgSDO8Finish==1)
   1727          }
   \   000001FE   0x....             B.N      ?Subroutine2
   \                     ??PDM2PCMSDO78_29: (+1)
   \   00000200   0xEB0B 0x0008      ADD      R0,R11,R8
   \   00000204   0xE004             B.N      ??PDM2PCMSDO78_32
   \                     ??PDM2PCMSDO78_31: (+1)
   \   00000206   0xEB0B 0x0009      ADD      R0,R11,R9
   \   0000020A   0xE001             B.N      ??PDM2PCMSDO78_32
   \                     ??PDM2PCMSDO78_30: (+1)
   \   0000020C   0xEB0B 0x000A      ADD      R0,R11,R10
   \                     ??PDM2PCMSDO78_32: (+1)
   \   00000210   0x8901             LDRH     R1,[R0, #+8]
   \   00000212   0x8001             STRH     R1,[R0, #+0]
   \   00000214   0x8941             LDRH     R1,[R0, #+10]
   \   00000216   0x8041             STRH     R1,[R0, #+2]
   \   00000218   0x8981             LDRH     R1,[R0, #+12]
   \   0000021A   0x8081             STRH     R1,[R0, #+4]
   \   0000021C   0x89C1             LDRH     R1,[R0, #+14]
   \   0000021E   0x80C1             STRH     R1,[R0, #+6]
   \                     ??PDM2PCMSDO78_17: (+1)
   \   00000220                      REQUIRE ?Subroutine2
   \   00000220                      REQUIRE Buffer2
   \   00000220                      REQUIRE Buffer3
   \   00000220                      REQUIRE Buffer1
   \   00000220                      ;; // Fall through to label ?Subroutine2

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine2: (+1)
   \   00000000   0xB003             ADD      SP,SP,#+12
   \   00000002   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return

   \                                 In section .bss, align 4
   \                     swtSDO7:
   \   00000000                      DS8 1
   \                     swtSDO8:
   \   00000001                      DS8 1
   \                     WaveRecord_flgSDO7Finish:
   \   00000002                      DS8 1
   \                     WaveRecord_flgSDO8Finish:
   \   00000003                      DS8 1
   \                     Filter:
   \   00000004                      DS8 104
   \   0000006C                      DS8 2
   \   0000006E                      DS8 2

   \                                 In section .bss, align 4
   \                     pDataMic8:
   \   00000000                      DS8 128

   \                                 In section .bss, align 4
   \                     pDataMic7:
   \   00000000                      DS8 128

   \                                 In section .bss, align 4
   \                     pPDM2PCM:
   \   00000000                      DS8 32

   \                                 In section .bss, align 2
   \                     cntStrt:
   \   00000000                      DS8 2

   \                                 In section .bss, align 1
   \                     WaveRecord_flgIni:
   \   00000000                      DS8 1

   \                                 In section .bss, align 2
   \                     I2S1_stNipple:
   \   00000000                      DS8 2

   \                                 In section .bss, align 2
   \                     iSDO12:
   \   00000000                      DS8 2

   \                                 In section .bss, align 2
   \                     iSDO34:
   \   00000000                      DS8 2

   \                                 In section .bss, align 2
   \                     iSDO56:
   \   00000000                      DS8 2

   \                                 In section .bss, align 1
   \                     I2S1_stPosShft:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
   \                     I2S2_stPosShft:
   \   00000000                      DS8 1

   \                                 In section .bss, at 0xc0000000
   \                     Buffer1:
   \   00000000                      DS8 32928

   \                                 In section .bss, at 0xc00080a0
   \                     Buffer2:
   \   00000000                      DS8 32928

   \                                 In section .bss, at 0xc0010140
   \                     Buffer3:
   \   00000000                      DS8 32928
   1728          

   \                                 In section .text, align 2, keep-with-next
   1729          void MIC7Rec (void)
   1730          {
   1731          	swtSDO7^=0x01;
   \                     MIC7Rec: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable17_6
   1732          	WaveRecord_flgSDO7Finish = 1;
   1733          	if (swtSDO7==0x01)
   \   00000002   0x....             LDR.N    R3,??DataTable17_2
   \   00000004   0xF44F 0x5280      MOV      R2,#+4096
   \   00000008   0x7801             LDRB     R1,[R0, #+0]
   \   0000000A   0xF081 0x0101      EOR      R1,R1,#0x1
   \   0000000E   0x7001             STRB     R1,[R0, #+0]
   \   00000010   0x2101             MOVS     R1,#+1
   \   00000012   0x7081             STRB     R1,[R0, #+2]
   \   00000014   0x7800             LDRB     R0,[R0, #+0]
   \   00000016   0x2801             CMP      R0,#+1
   \   00000018   0xBF0C             ITE      EQ 
   \   0000001A   0x....             LDREQ.N  R1,??DataTable17_30
   \   0000001C   0x....             LDRNE.N  R1,??DataTable17_10
   1734          	{
   1735          		HAL_SPI_Receive_DMA(&hspi5,( uint8_t *)TestSDO7_1,4*AUDIO_OUT_BUFFER_SIZE);
   1736          	}
   1737          	else
   1738          	{
   1739          		HAL_SPI_Receive_DMA(&hspi5,( uint8_t *)TestSDO7,4*AUDIO_OUT_BUFFER_SIZE);
   \   0000001E   0x....             B.N      ?Subroutine1
   1740          	} 
   1741          
   1742          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \   00000000   0x1D18             ADDS     R0,R3,#+4
   \   00000002   0x.... 0x....      B.W      HAL_SPI_Receive_DMA
   1743          

   \                                 In section .text, align 4, keep-with-next
   1744          void MIC8Rec (void)
   1745          {
   1746               swtSDO8^=0x01;
   \                     MIC8Rec: (+1)
   \   00000000   0x4808             LDR.N    R0,??MIC8Rec_0+0x4
   1747              WaveRecord_flgSDO8Finish = 1;
   1748              if (swtSDO8==0x01)
   \   00000002   0x4B07             LDR.N    R3,??MIC8Rec_0
   \   00000004   0xF44F 0x5280      MOV      R2,#+4096
   \   00000008   0x7841             LDRB     R1,[R0, #+1]
   \   0000000A   0xF081 0x0101      EOR      R1,R1,#0x1
   \   0000000E   0x7041             STRB     R1,[R0, #+1]
   \   00000010   0x2101             MOVS     R1,#+1
   \   00000012   0x70C1             STRB     R1,[R0, #+3]
   \   00000014   0x7840             LDRB     R0,[R0, #+1]
   \   00000016   0x2801             CMP      R0,#+1
   \   00000018   0xBF0C             ITE      EQ 
   \   0000001A   0x4903             LDREQ.N  R1,??MIC8Rec_0+0x8
   \   0000001C   0x4903             LDRNE.N  R1,??MIC8Rec_0+0xC
   \   0000001E   0xE007             B.N      ??MIC8Rec_1
   \                     ??MIC8Rec_0:
   \   00000020   0x........         DC32     idxMic7
   \   00000024   0x........         DC32     swtSDO7
   \   00000028   0x........         DC32     TestSDO8_1
   \   0000002C   0x........         DC32     TestSDO8
   1749              {
   1750                  HAL_SPI_Receive_DMA(&hspi6,( uint8_t *)TestSDO8_1,4*AUDIO_OUT_BUFFER_SIZE);
   1751              }
   1752              else
   1753              {
   1754                  HAL_SPI_Receive_DMA(&hspi6,( uint8_t *)TestSDO8,4*AUDIO_OUT_BUFFER_SIZE);
   \                     ??MIC8Rec_1: (+1)
   \   00000030                      REQUIRE ?Subroutine1
   \   00000030                      ;; // Fall through to label ?Subroutine1
   1755          
   1756              }
   1757          
   1758          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11:
   \   00000000   0x45FA0000         DC32     0x45fa0000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12:
   \   00000000   0x40023830         DC32     0x40023830

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_1:
   \   00000000   0x40020000         DC32     0x40020000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_2:
   \   00000000   0x........         DC32     spi1_ins

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15:
   \   00000000   0x4001300C         DC32     0x4001300c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_1:
   \   00000000   0x........         DC32     WaveRecord_flgInt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_2:
   \   00000000   0x........         DC32     buffer_switch

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_3:
   \   00000000   0x........         DC32     WaveRec_idxSens1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_4:
   \   00000000   0xC00080A0         DC32     0xc00080a0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_5:
   \   00000000   0xC0010140         DC32     0xc0010140

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16:
   \   00000000   0x40021000         DC32     0x40021000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_1:
   \   00000000   0x........         DC32     WaveRec_idxSens2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_2:
   \   00000000   0x........         DC32     hi2s2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_3:
   \   00000000   0x4000380C         DC32     0x4000380c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_4:
   \   00000000   0x........         DC32     WaveRec_idxSens3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_5:
   \   00000000   0x........         DC32     hspi4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_6:
   \   00000000   0x4001340C         DC32     0x4001340c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_7:
   \   00000000   0x........         DC32     WaveRec_idxSens5

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_8:
   \   00000000   0x........         DC32     WaveRec_idxSens6

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17:
   \   00000000   0x........         DC32     WaveRec_idxSens4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_1:
   \   00000000   0xC0010140         DC32     0xc0010140

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_2:
   \   00000000   0x........         DC32     idxMic8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_3:
   \   00000000   0x4001500C         DC32     0x4001500c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_4:
   \   00000000   0x........         DC32     pDataMic8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_5:
   \   00000000   0x........         DC32     volume

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_6:
   \   00000000   0x........         DC32     swtSDO7

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_7:
   \   00000000   0x........         DC32     idxMic7

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_8:
   \   00000000   0x4001540C         DC32     0x4001540c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_9:
   \   00000000   0x........         DC32     pDataMic7

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_10:
   \   00000000   0x........         DC32     TestSDO7

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_11:
   \   00000000   0x........         DC32     idxMic8+0x4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_12:
   \   00000000   0x........         DC32     TestSDO8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_13:
   \   00000000   0x........         DC32     idxMic7+0x4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_14:
   \   00000000   0x40013000         DC32     0x40013000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_15:
   \   00000000   0x40003800         DC32     0x40003800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_16:
   \   00000000   0x40013400         DC32     0x40013400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_17:
   \   00000000   0x........         DC32     swtSDO7+0x4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_18:
   \   00000000   0x40015000         DC32     0x40015000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_19:
   \   00000000   0x40015400         DC32     0x40015400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_20:
   \   00000000   0x40020800         DC32     0x40020800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_21:
   \   00000000   0x40020400         DC32     0x40020400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_22:
   \   00000000   0x40003C00         DC32     0x40003c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_23:
   \   00000000   0x........         DC32     DmaHandle

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_24:
   \   00000000   0x400260B8         DC32     0x400260b8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_25:
   \   00000000   0x40021400         DC32     0x40021400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_26:
   \   00000000   0x........         DC32     hdma_spi5_rx

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_27:
   \   00000000   0x40026488         DC32     0x40026488

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_28:
   \   00000000   0x40021800         DC32     0x40021800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_29:
   \   00000000   0x........         DC32     hdma_spi6_rx

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_30:
   \   00000000   0x........         DC32     TestSDO7_1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_31:
   \   00000000   0x........         DC32     TestSDO8_1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_32:
   \   00000000   0x........         DC32     buffer_switch

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_33:
   \   00000000   0xC00080A0         DC32     0xc00080a0
   1759          
   1760          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   DMA2_Stream5_IRQHandler
         0   -> HAL_DMA_IRQHandler
       0   DMA2_Stream6_IRQHandler
         0   -> HAL_DMA_IRQHandler
      40   HAL_SPI_MspInit
        40   -> HAL_DMA_DeInit
        40   -> HAL_DMA_Init
        40   -> HAL_GPIO_Init
        40   -> HAL_NVIC_EnableIRQ
        40   -> HAL_NVIC_SetPriority
       8   HAL_SPI_RxCpltCallback
         0   -> HAL_SPI_Receive_DMA
         8   -> HAL_SPI_Receive_DMA
      24   MIC1TO6_Init
        24   -> HAL_Delay
        24   -> HAL_GPIO_ReadPin
        24   -> HAL_I2S_Init
        24   -> HAL_SPI_Receive_DMA
         0   -> SPI4_Init
        24   -> SPI5_Init
        24   -> SPI6_Init
       0   MIC7Rec
         0   -> HAL_SPI_Receive_DMA
       0   MIC8Rec
         0   -> HAL_SPI_Receive_DMA
       0   Mic7Rec
         0   -> SPI5_Init
       0   Mic8Rec
         0   -> HAL_SPI_Init
      48   PDM2PCMSDO78
        48   -> LowPassIIR
        48   -> PDM_Filter_64_LSB
       4   RecordUpdBuf
       0   SPI1_IRQHandler
      32   SPI1_Ini
        32   -> HAL_GPIO_Init
        32   -> HAL_GPIO_WritePin
        32   -> HAL_NVIC_EnableIRQ
        32   -> HAL_NVIC_SetPriority
        32   -> HAL_SPI_Init
      16   SPI2_IRQHandler
        16   -> HAL_GPIO_ReadPin
       4   SPI4_IRQHandler
       8   SPI4_Init
         8   -> HAL_SPI_Init
      16   SPI5_IRQHandler
        16   -> PDM_Filter_64_LSB
      24   SPI5_Init
         0   -> HAL_SPI_Init
        24   -> PDM_Filter_Init
      16   SPI6_IRQHandler
        16   -> PDM_Filter_64_LSB
       0   SPI6_Init
         0   -> HAL_SPI_Init
       8   StartRecMic7_8
         8   -> HAL_SPI_Receive_DMA
       0   mySPI_SendData


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable11
       4  ??DataTable12
       4  ??DataTable12_1
       4  ??DataTable12_2
       4  ??DataTable15
       4  ??DataTable15_1
       4  ??DataTable15_2
       4  ??DataTable15_3
       4  ??DataTable15_4
       4  ??DataTable15_5
       4  ??DataTable16
       4  ??DataTable16_1
       4  ??DataTable16_2
       4  ??DataTable16_3
       4  ??DataTable16_4
       4  ??DataTable16_5
       4  ??DataTable16_6
       4  ??DataTable16_7
       4  ??DataTable16_8
       4  ??DataTable17
       4  ??DataTable17_1
       4  ??DataTable17_10
       4  ??DataTable17_11
       4  ??DataTable17_12
       4  ??DataTable17_13
       4  ??DataTable17_14
       4  ??DataTable17_15
       4  ??DataTable17_16
       4  ??DataTable17_17
       4  ??DataTable17_18
       4  ??DataTable17_19
       4  ??DataTable17_2
       4  ??DataTable17_20
       4  ??DataTable17_21
       4  ??DataTable17_22
       4  ??DataTable17_23
       4  ??DataTable17_24
       4  ??DataTable17_25
       4  ??DataTable17_26
       4  ??DataTable17_27
       4  ??DataTable17_28
       4  ??DataTable17_29
       4  ??DataTable17_3
       4  ??DataTable17_30
       4  ??DataTable17_31
       4  ??DataTable17_32
       4  ??DataTable17_33
       4  ??DataTable17_4
       4  ??DataTable17_5
       4  ??DataTable17_6
       4  ??DataTable17_7
       4  ??DataTable17_8
       4  ??DataTable17_9
      64  ?Subroutine0
       6  ?Subroutine1
       6  ?Subroutine2
   32928  Buffer1
   32928  Buffer2
   32928  Buffer3
       8  DMA2_Stream5_IRQHandler
       8  DMA2_Stream6_IRQHandler
    1026  HAL_SPI_MspInit
      98  HAL_SPI_RxCpltCallback
       2  I2S1_stNipple
       1  I2S1_stPosShft
       1  I2S2_stPosShft
     308  MIC1TO6_Init
      32  MIC7Rec
      48  MIC8Rec
       2  Mic7Rec
       2  Mic8Rec
     544  PDM2PCMSDO78
     202  RecordUpdBuf
     232  SPI1_IRQHandler
     212  SPI1_Ini
     254  SPI2_IRQHandler
     266  SPI4_IRQHandler
      86  SPI4_Init
     118  SPI5_IRQHandler
     136  SPI5_Init
     112  SPI6_IRQHandler
       2  SPI6_Init
      46  StartRecMic7_8
    8192  TestSDO12
    8192  TestSDO34
    8192  TestSDO56
    8192  TestSDO7
    8192  TestSDO7_1
    8192  TestSDO8
    8192  TestSDO8_1
       1  WaveRecord_flgIni
      92  WaveRecord_flgInt
          SPI4_stPosShft
          I2S2_stLR
          I2S2_stLROld
          stLROld
          Main_stLROld
          WaveRec_idxTest
          vRawSens1
          vRawSens2
          vRawSens4
          vRawSens3
          vRawSens5
          vRawSens6
          SPI1_stNipple
          I2S2_stNipple
          SPI4_stNipple
          hi2s1
       2  cntStrt
       2  cntTransFinish
      80  hdma_spi2_tx
      80  hdma_spi3_tx
      80  hdma_spi5_rx
      80  hdma_spi6_rx
      64  hi2s2
     100  hspi1
     100  hspi2
       2  iSDO12
       2  iSDO34
       2  iSDO56
       2  idxFrmPDMMic8
     108  idxMic7
          cntPos7
          hspi6
          bufPCMSens7
     108  idxMic8
          cntPos
          hspi5
          bufPCMSens8
      44  mySPI_SendData
     128  pDataMic7
     128  pDataMic8
      44  pHeaderBuff
      32  pPDM2PCM
     100  spi1_ins
     100  spi2_ins
     112  swtSDO7
          swtSDO8
          WaveRecord_flgSDO7Finish
          WaveRecord_flgSDO8Finish
          Filter
          Mic7LPOld
          Mic8LPOld

 
 58 897 bytes in section .bss
 98 784 bytes in section .bss  (abs)
  4 074 bytes in section .text
 
   4 074 bytes of CODE memory
 157 681 bytes of DATA memory

Errors: none
Warnings: 12
