###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.2.10312/W32 for ARM       19/Feb/2016  17:44:14
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_i2s.c
#    Command line =  
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_i2s.c
#        -D USE_HAL_DRIVER -D STM32F746xx -D USE_STM32746G_DISCO -D
#        USE_IOEXPANDER -D USE_USB_FS -lC
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
#        -lA
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
#        -o
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M7 -e --fpu=VFPv5_sp --dlib_config "D:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.3\arm\INC\c\DLib_Config_Full.h"
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\CMSIS\Device\ST\STM32F7xx\Include\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\STM32F7xx_HAL_Driver\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\STM32746G-Discovery\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\Components\Common\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Log\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Fonts\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\CPU\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_Device_Library\Core\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Core\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Class\MSC\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\drivers\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_Audio\Addons\PDM\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_Device_Library\Class\AUDIO\Inc\
#        -On --use_c++_inline --require_prototypes -I "D:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.3\arm\CMSIS\Include\" -D
#        ARM_MATH_CM7
#    List file    =  
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List\stm32f7xx_hal_i2s.lst
#    Object file  =  
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj\stm32f7xx_hal_i2s.o
#
###############################################################################

D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_i2s.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f7xx_hal_i2s.c
      4            * @author  MCD Application Team
      5            * @version V1.0.1
      6            * @date    25-June-2015
      7            * @brief   I2S HAL module driver.
      8            *          This file provides firmware functions to manage the following 
      9            *          functionalities of the Integrated Interchip Sound (I2S) peripheral:
     10            *           + Initialization and de-initialization functions
     11            *           + IO operation functions
     12            *           + Peripheral State and Errors functions
     13            @verbatim
     14           ===============================================================================
     15                            ##### How to use this driver #####
     16           ===============================================================================
     17           [..]
     18              The I2S HAL driver can be used as follows:
     19              
     20              (#) Declare a I2S_HandleTypeDef handle structure.
     21              (#) Initialize the I2S low level resources by implement the HAL_I2S_MspInit() API:
     22                  (##) Enable the SPIx interface clock.                      
     23                  (##) I2S pins configuration:
     24                      (+++) Enable the clock for the I2S GPIOs.
     25                      (+++) Configure these I2S pins as alternate function pull-up.
     26                  (##) NVIC configuration if you need to use interrupt process (HAL_I2S_Transmit_IT()
     27                       and HAL_I2S_Receive_IT() APIs).
     28                      (+++) Configure the I2Sx interrupt priority.
     29                      (+++) Enable the NVIC I2S IRQ handle.
     30                  (##) DMA Configuration if you need to use DMA process (HAL_I2S_Transmit_DMA()
     31                       and HAL_I2S_Receive_DMA() APIs:
     32                      (+++) Declare a DMA handle structure for the Tx/Rx channel.
     33                      (+++) Enable the DMAx interface clock.
     34                      (+++) Configure the declared DMA handle structure with the required Tx/Rx parameters.                
     35                      (+++) Configure the DMA Tx/Rx Channel.
     36                      (+++) Associate the initialized DMA handle to the I2S DMA Tx/Rx handle.
     37                      (+++) Configure the priority and enable the NVIC for the transfer complete interrupt on the 
     38                          DMA Tx/Rx Channel.
     39            
     40             (#) Program the Mode, Standard, Data Format, MCLK Output, Audio frequency and Polarity
     41                 using HAL_I2S_Init() function.
     42          
     43             -@- The specific I2S interrupts (Transmission complete interrupt, 
     44                 RXNE interrupt and Error Interrupts) will be managed using the macros
     45                 __HAL_I2S_ENABLE_IT() and __HAL_I2S_DISABLE_IT() inside the transmit and receive process.
     46             -@- Make sure that either:
     47                 (+@) I2S clock is configured based on SYSCLK or 
     48                 (+@) External clock source is configured after setting correctly 
     49                      the define constant EXTERNAL_CLOCK_VALUE in the stm32f3xx_hal_conf.h file. 
     50          
     51             (#) Three mode of operations are available within this driver :     
     52            
     53             *** Polling mode IO operation ***
     54             =================================
     55             [..]    
     56               (+) Send an amount of data in blocking mode using HAL_I2S_Transmit() 
     57               (+) Receive an amount of data in blocking mode using HAL_I2S_Receive()
     58             
     59             *** Interrupt mode IO operation ***    
     60             ===================================
     61             [..]    
     62               (+) Send an amount of data in non blocking mode using HAL_I2S_Transmit_IT() 
     63               (+) At transmission end of half transfer HAL_I2S_TxHalfCpltCallback is executed and user can 
     64                   add his own code by customization of function pointer HAL_I2S_TxHalfCpltCallback 
     65               (+) At transmission end of transfer HAL_I2S_TxCpltCallback is executed and user can 
     66                   add his own code by customization of function pointer HAL_I2S_TxCpltCallback
     67               (+) Receive an amount of data in non blocking mode using HAL_I2S_Receive_IT() 
     68               (+) At reception end of half transfer HAL_I2S_RxHalfCpltCallback is executed and user can 
     69                   add his own code by customization of function pointer HAL_I2S_RxHalfCpltCallback 
     70               (+) At reception end of transfer HAL_I2S_RxCpltCallback is executed and user can 
     71                   add his own code by customization of function pointer HAL_I2S_RxCpltCallback                                      
     72               (+) In case of transfer Error, HAL_I2S_ErrorCallback() function is executed and user can 
     73                   add his own code by customization of function pointer HAL_I2S_ErrorCallback
     74          
     75             *** DMA mode IO operation ***    
     76             ==============================
     77             [..] 
     78               (+) Send an amount of data in non blocking mode (DMA) using HAL_I2S_Transmit_DMA() 
     79               (+) At transmission end of half transfer HAL_I2S_TxHalfCpltCallback is executed and user can 
     80                   add his own code by customization of function pointer HAL_I2S_TxHalfCpltCallback 
     81               (+) At transmission end of transfer HAL_I2S_TxCpltCallback is executed and user can 
     82                   add his own code by customization of function pointer HAL_I2S_TxCpltCallback
     83               (+) Receive an amount of data in non blocking mode (DMA) using HAL_I2S_Receive_DMA() 
     84               (+) At reception end of half transfer HAL_I2S_RxHalfCpltCallback is executed and user can 
     85                   add his own code by customization of function pointer HAL_I2S_RxHalfCpltCallback 
     86               (+) At reception end of transfer HAL_I2S_RxCpltCallback is executed and user can 
     87                   add his own code by customization of function pointer HAL_I2S_RxCpltCallback                                     
     88               (+) In case of transfer Error, HAL_I2S_ErrorCallback() function is executed and user can 
     89                   add his own code by customization of function pointer HAL_I2S_ErrorCallback
     90               (+) Pause the DMA Transfer using HAL_I2S_DMAPause()      
     91               (+) Resume the DMA Transfer using HAL_I2S_DMAResume()  
     92               (+) Stop the DMA Transfer using HAL_I2S_DMAStop()      
     93             
     94             *** I2S HAL driver macros list ***
     95             ============================================= 
     96             [..]
     97               Below the list of most used macros in I2S HAL driver.
     98                 
     99                (+) __HAL_I2S_ENABLE: Enable the specified SPI peripheral (in I2S mode) 
    100                (+) __HAL_I2S_DISABLE: Disable the specified SPI peripheral (in I2S mode)    
    101                (+) __HAL_I2S_ENABLE_IT : Enable the specified I2S interrupts
    102                (+) __HAL_I2S_DISABLE_IT : Disable the specified I2S interrupts
    103                (+) __HAL_I2S_GET_FLAG: Check whether the specified I2S flag is set or not
    104                
    105              [..]  
    106                (@) You can refer to the I2S HAL driver header file for more useful macros
    107          
    108            @endverbatim
    109            ******************************************************************************
    110            * @attention
    111            *
    112            * <h2><center>&copy; COPYRIGHT(c) 2015 STMicroelectronics</center></h2>
    113            *
    114            * Redistribution and use in source and binary forms, with or without modification,
    115            * are permitted provided that the following conditions are met:
    116            *   1. Redistributions of source code must retain the above copyright notice,
    117            *      this list of conditions and the following disclaimer.
    118            *   2. Redistributions in binary form must reproduce the above copyright notice,
    119            *      this list of conditions and the following disclaimer in the documentation
    120            *      and/or other materials provided with the distribution.
    121            *   3. Neither the name of STMicroelectronics nor the names of its contributors
    122            *      may be used to endorse or promote products derived from this software
    123            *      without specific prior written permission.
    124            *
    125            * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
    126            * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
    127            * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
    128            * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
    129            * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
    130            * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
    131            * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
    132            * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
    133            * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
    134            * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
    135            *
    136            ******************************************************************************
    137            */ 
    138          
    139          /* Includes ------------------------------------------------------------------*/
    140          #include "stm32f7xx_hal.h"
    141          
    142          /** @addtogroup STM32F7xx_HAL_Driver
    143            * @{
    144            */
    145          
    146          /** @defgroup I2S I2S
    147            * @brief I2S HAL module driver
    148            * @{
    149            */
    150          
    151          #ifdef HAL_I2S_MODULE_ENABLED
    152          
    153          /* Private typedef -----------------------------------------------------------*/
    154          /* Private define ------------------------------------------------------------*/
    155          /* Private macro -------------------------------------------------------------*/
    156          /* Private variables ---------------------------------------------------------*/
    157          /* Private function prototypes -----------------------------------------------*/
    158          /** @defgroup I2S_Private_Functions I2S Private Functions
    159            * @{
    160            */
    161          static void I2S_DMATxCplt(DMA_HandleTypeDef *hdma);
    162          static void I2S_DMATxHalfCplt(DMA_HandleTypeDef *hdma);
    163          static void I2S_DMARxCplt(DMA_HandleTypeDef *hdma);
    164          static void I2S_DMARxHalfCplt(DMA_HandleTypeDef *hdma);
    165          static void I2S_DMAError(DMA_HandleTypeDef *hdma);
    166          static void I2S_Transmit_IT(I2S_HandleTypeDef *hi2s);
    167          static void I2S_Receive_IT(I2S_HandleTypeDef *hi2s);
    168          static uint32_t I2S_GetClockFreq(I2S_HandleTypeDef *hi2s);
    169          static HAL_StatusTypeDef I2S_WaitFlagStateUntilTimeout(I2S_HandleTypeDef *hi2s, uint32_t Flag, uint32_t State, uint32_t Timeout);
    170          /**
    171            * @}
    172            */
    173          
    174          /* Exported functions ---------------------------------------------------------*/
    175          
    176          /** @defgroup I2S_Exported_Functions I2S Exported Functions
    177            * @{
    178            */
    179          
    180          /** @defgroup  I2S_Exported_Functions_Group1 Initialization and de-initialization functions 
    181            *  @brief    Initialization and Configuration functions 
    182            *
    183          @verbatim    
    184           ===============================================================================
    185                        ##### Initialization and de-initialization functions #####
    186           ===============================================================================
    187              [..]  This subsection provides a set of functions allowing to initialize and 
    188                    de-initialize the I2Sx peripheral in simplex mode:
    189          
    190                (+) User must Implement HAL_I2S_MspInit() function in which he configures 
    191                    all related peripherals resources (CLOCK, GPIO, DMA, IT and NVIC ).
    192          
    193                (+) Call the function HAL_I2S_Init() to configure the selected device with 
    194                    the selected configuration:
    195                  (++) Mode
    196                  (++) Standard 
    197                  (++) Data Format
    198                  (++) MCLK Output
    199                  (++) Audio frequency
    200                  (++) Polarity
    201                  (++) Full duplex mode
    202          
    203                (+) Call the function HAL_I2S_DeInit() to restore the default configuration 
    204                    of the selected I2Sx peripheral. 
    205          @endverbatim
    206            * @{
    207            */
    208          
    209          /**
    210            * @brief Initializes the I2S according to the specified parameters 
    211            *         in the I2S_InitTypeDef and create the associated handle.
    212            * @param  hi2s: pointer to a I2S_HandleTypeDef structure that contains
    213            *         the configuration information for I2S module
    214            * @retval HAL status
    215            */

   \                                 In section .text, align 2, keep-with-next
    216          HAL_StatusTypeDef HAL_I2S_Init(I2S_HandleTypeDef *hi2s)
    217          {
   \                     HAL_I2S_Init: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0x0004             MOVS     R4,R0
    218            uint16_t tmpreg = 0, i2sdiv = 2, i2sodd = 0, packetlength = 1;
   \   00000006   0x2500             MOVS     R5,#+0
   \   00000008   0x2602             MOVS     R6,#+2
   \   0000000A   0x2700             MOVS     R7,#+0
   \   0000000C   0xF05F 0x0801      MOVS     R8,#+1
    219            uint32_t tmp = 0, i2sclk = 0;
   \   00000010   0xF05F 0x0900      MOVS     R9,#+0
   \   00000014   0xF05F 0x0A00      MOVS     R10,#+0
    220           
    221            /* Check the I2S handle allocation */
    222            if(hi2s == NULL)
   \   00000018   0x2C00             CMP      R4,#+0
   \   0000001A   0xD101             BNE.N    ??HAL_I2S_Init_0
    223            {
    224              return HAL_ERROR;
   \   0000001C   0x2001             MOVS     R0,#+1
   \   0000001E   0xE080             B.N      ??HAL_I2S_Init_1
    225            }
    226            
    227            /* Check the parameters */
    228            assert_param(IS_I2S_ALL_INSTANCE(hi2s->Instance));
    229            assert_param(IS_I2S_MODE(hi2s->Init.Mode));
    230            assert_param(IS_I2S_STANDARD(hi2s->Init.Standard));
    231            assert_param(IS_I2S_DATA_FORMAT(hi2s->Init.DataFormat));
    232            assert_param(IS_I2S_MCLK_OUTPUT(hi2s->Init.MCLKOutput));
    233            assert_param(IS_I2S_AUDIO_FREQ(hi2s->Init.AudioFreq));
    234            assert_param(IS_I2S_CPOL(hi2s->Init.CPOL));  
    235            assert_param(IS_I2S_CLOCKSOURCE(hi2s->Init.ClockSource));
    236            
    237            if(hi2s->State == HAL_I2S_STATE_RESET)
   \                     ??HAL_I2S_Init_0: (+1)
   \   00000020   0xF894 0x0039      LDRB     R0,[R4, #+57]
   \   00000024   0x2800             CMP      R0,#+0
   \   00000026   0xD105             BNE.N    ??HAL_I2S_Init_2
    238            {
    239              /* Allocate lock resource and initialize it */
    240              hi2s->Lock = HAL_UNLOCKED;
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0xF884 0x0038      STRB     R0,[R4, #+56]
    241              /* Init the low level hardware : GPIO, CLOCK, CORTEX...etc */
    242              HAL_I2S_MspInit(hi2s);
   \   0000002E   0x0020             MOVS     R0,R4
   \   00000030   0x.... 0x....      BL       HAL_I2S_MspInit
    243            }
    244            
    245            hi2s->State = HAL_I2S_STATE_BUSY;
   \                     ??HAL_I2S_Init_2: (+1)
   \   00000034   0x2002             MOVS     R0,#+2
   \   00000036   0xF884 0x0039      STRB     R0,[R4, #+57]
    246              
    247            /*----------------------- SPIx I2SCFGR & I2SPR Configuration -----------------*/
    248            /* Clear I2SMOD, I2SE, I2SCFG, PCMSYNC, I2SSTD, CKPOL, DATLEN and CHLEN bits */
    249            hi2s->Instance->I2SCFGR &= ~(SPI_I2SCFGR_CHLEN | SPI_I2SCFGR_DATLEN | SPI_I2SCFGR_CKPOL | \
    250                                         SPI_I2SCFGR_I2SSTD | SPI_I2SCFGR_PCMSYNC | SPI_I2SCFGR_I2SCFG | \
    251                                         SPI_I2SCFGR_I2SE | SPI_I2SCFGR_I2SMOD); 
   \   0000003A   0x6820             LDR      R0,[R4, #+0]
   \   0000003C   0x69C0             LDR      R0,[R0, #+28]
   \   0000003E   0x.... 0x....      LDR.W    R1,??DataTable1  ;; 0xfffff040
   \   00000042   0x4008             ANDS     R0,R1,R0
   \   00000044   0x6821             LDR      R1,[R4, #+0]
   \   00000046   0x61C8             STR      R0,[R1, #+28]
    252            hi2s->Instance->I2SPR = 0x0002;
   \   00000048   0x2002             MOVS     R0,#+2
   \   0000004A   0x6821             LDR      R1,[R4, #+0]
   \   0000004C   0x6208             STR      R0,[R1, #+32]
    253            
    254            /* Get the I2SCFGR register value */
    255            tmpreg = hi2s->Instance->I2SCFGR;
   \   0000004E   0x6820             LDR      R0,[R4, #+0]
   \   00000050   0x69C0             LDR      R0,[R0, #+28]
   \   00000052   0x0005             MOVS     R5,R0
    256            
    257            /* If the default value has to be written, reinitialize i2sdiv and i2sodd*/
    258            if(hi2s->Init.AudioFreq == I2S_AUDIOFREQ_DEFAULT)
   \   00000054   0x6960             LDR      R0,[R4, #+20]
   \   00000056   0x2802             CMP      R0,#+2
   \   00000058   0xD104             BNE.N    ??HAL_I2S_Init_3
    259            {
    260              i2sodd = (uint16_t)0;
   \   0000005A   0x2000             MOVS     R0,#+0
   \   0000005C   0x0007             MOVS     R7,R0
    261              i2sdiv = (uint16_t)2;   
   \   0000005E   0x2002             MOVS     R0,#+2
   \   00000060   0x0006             MOVS     R6,R0
   \   00000062   0xE03B             B.N      ??HAL_I2S_Init_4
    262            }
    263            /* If the requested audio frequency is not the default, compute the prescaler */
    264            else
    265            {
    266              /* Check the frame length (For the Prescaler computing) *******************/
    267              if(hi2s->Init.DataFormat == I2S_DATAFORMAT_16B)
   \                     ??HAL_I2S_Init_3: (+1)
   \   00000064   0x68E0             LDR      R0,[R4, #+12]
   \   00000066   0x2800             CMP      R0,#+0
   \   00000068   0xD102             BNE.N    ??HAL_I2S_Init_5
    268              {
    269                /* Packet length is 16 bits */
    270                packetlength = 1;
   \   0000006A   0x2001             MOVS     R0,#+1
   \   0000006C   0x4680             MOV      R8,R0
   \   0000006E   0xE001             B.N      ??HAL_I2S_Init_6
    271              }
    272              else
    273              {
    274                /* Packet length is 32 bits */
    275                packetlength = 2;
   \                     ??HAL_I2S_Init_5: (+1)
   \   00000070   0x2002             MOVS     R0,#+2
   \   00000072   0x4680             MOV      R8,R0
    276              }
    277              
    278              /* Get I2S source Clock frequency  ****************************************/
    279          
    280              /* If an external I2S clock has to be used, the specific define should be set  
    281              in the project configuration or in the stm32f3xx_conf.h file */
    282              if(hi2s->Init.ClockSource == I2S_CLOCK_EXTERNAL)
   \                     ??HAL_I2S_Init_6: (+1)
   \   00000074   0x69E0             LDR      R0,[R4, #+28]
   \   00000076   0x2801             CMP      R0,#+1
   \   00000078   0xD103             BNE.N    ??HAL_I2S_Init_7
    283              {    
    284                /* Set the I2S clock to the external clock  value */
    285                i2sclk = EXTERNAL_CLOCK_VALUE;
   \   0000007A   0x.... 0x....      LDR.W    R0,??DataTable1_1  ;; 0xbb8000
   \   0000007E   0x4682             MOV      R10,R0
   \   00000080   0xE003             B.N      ??HAL_I2S_Init_8
    286              }
    287              else
    288              {
    289                /* Get the I2S source clock value */
    290          			i2sclk = I2S_GetClockFreq(hi2s);
   \                     ??HAL_I2S_Init_7: (+1)
   \   00000082   0x0020             MOVS     R0,R4
   \   00000084   0x.... 0x....      BL       I2S_GetClockFreq
   \   00000088   0x4682             MOV      R10,R0
    291              }
    292              
    293              /* Compute the Real divider depending on the MCLK output state, with a floating point */
    294              if(hi2s->Init.MCLKOutput == I2S_MCLKOUTPUT_ENABLE)
   \                     ??HAL_I2S_Init_8: (+1)
   \   0000008A   0x6920             LDR      R0,[R4, #+16]
   \   0000008C   0xF5B0 0x7F00      CMP      R0,#+512
   \   00000090   0xD10A             BNE.N    ??HAL_I2S_Init_9
    295              {
    296                /* MCLK output is enabled */
    297                tmp = (uint16_t)(((((i2sclk / 256) * 10) / hi2s->Init.AudioFreq)) + 5);
   \   00000092   0xEA5F 0x201A      LSRS     R0,R10,#+8
   \   00000096   0x210A             MOVS     R1,#+10
   \   00000098   0x4348             MULS     R0,R1,R0
   \   0000009A   0x6961             LDR      R1,[R4, #+20]
   \   0000009C   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   000000A0   0x1D40             ADDS     R0,R0,#+5
   \   000000A2   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000A4   0x4681             MOV      R9,R0
   \   000000A6   0xE00D             B.N      ??HAL_I2S_Init_10
    298              }
    299              else
    300              {
    301                /* MCLK output is disabled */
    302                tmp = (uint16_t)(((((i2sclk / (32 * packetlength)) *10 ) / hi2s->Init.AudioFreq)) + 5);
   \                     ??HAL_I2S_Init_9: (+1)
   \   000000A8   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   000000AC   0xEA5F 0x1048      LSLS     R0,R8,#+5
   \   000000B0   0xFBBA 0xF0F0      UDIV     R0,R10,R0
   \   000000B4   0x210A             MOVS     R1,#+10
   \   000000B6   0x4348             MULS     R0,R1,R0
   \   000000B8   0x6961             LDR      R1,[R4, #+20]
   \   000000BA   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   000000BE   0x1D40             ADDS     R0,R0,#+5
   \   000000C0   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000C2   0x4681             MOV      R9,R0
    303              }
    304              
    305              /* Remove the flatting point */
    306              tmp = tmp / 10;  
   \                     ??HAL_I2S_Init_10: (+1)
   \   000000C4   0x200A             MOVS     R0,#+10
   \   000000C6   0xFBB9 0xF9F0      UDIV     R9,R9,R0
    307              
    308              /* Check the parity of the divider */
    309              i2sodd = (uint16_t)(tmp & (uint16_t)0x0001);
   \   000000CA   0xF019 0x0001      ANDS     R0,R9,#0x1
   \   000000CE   0x0007             MOVS     R7,R0
    310              
    311              /* Compute the i2sdiv prescaler */
    312              i2sdiv = (uint16_t)((tmp - i2sodd) / 2);
   \   000000D0   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   000000D2   0xEBB9 0x0007      SUBS     R0,R9,R7
   \   000000D6   0x0840             LSRS     R0,R0,#+1
   \   000000D8   0x0006             MOVS     R6,R0
    313              
    314              /* Get the Mask for the Odd bit (SPI_I2SPR[8]) register */
    315              i2sodd = (uint16_t) (i2sodd << 8);
   \   000000DA   0x023F             LSLS     R7,R7,#+8
    316            }
    317            
    318            /* Test if the divider is 1 or 0 or greater than 0xFF */
    319            if((i2sdiv < 2) || (i2sdiv > 0xFF))
   \                     ??HAL_I2S_Init_4: (+1)
   \   000000DC   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   000000DE   0x2E02             CMP      R6,#+2
   \   000000E0   0xDB02             BLT.N    ??HAL_I2S_Init_11
   \   000000E2   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   000000E4   0x2EFF             CMP      R6,#+255
   \   000000E6   0xDD03             BLE.N    ??HAL_I2S_Init_12
    320            {
    321              /* Set the default values */
    322              i2sdiv = 2;
   \                     ??HAL_I2S_Init_11: (+1)
   \   000000E8   0x2002             MOVS     R0,#+2
   \   000000EA   0x0006             MOVS     R6,R0
    323              i2sodd = 0;
   \   000000EC   0x2000             MOVS     R0,#+0
   \   000000EE   0x0007             MOVS     R7,R0
    324            }
    325            
    326            /* Write to SPIx I2SPR register the computed value */
    327            hi2s->Instance->I2SPR = (uint16_t)((uint16_t)i2sdiv | (uint16_t)(i2sodd | (uint16_t)hi2s->Init.MCLKOutput));
   \                     ??HAL_I2S_Init_12: (+1)
   \   000000F0   0x6920             LDR      R0,[R4, #+16]
   \   000000F2   0x4338             ORRS     R0,R0,R7
   \   000000F4   0x4330             ORRS     R0,R0,R6
   \   000000F6   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000F8   0x6821             LDR      R1,[R4, #+0]
   \   000000FA   0x6208             STR      R0,[R1, #+32]
    328            
    329            /* Configure the I2S with the I2S_InitStruct values */
    330            tmpreg |= (uint16_t)((uint16_t)SPI_I2SCFGR_I2SMOD | (uint16_t)(hi2s->Init.Mode | \
    331                                 (uint16_t)(hi2s->Init.Standard | (uint16_t)(hi2s->Init.DataFormat | \
    332                                 (uint16_t)hi2s->Init.CPOL))));
   \   000000FC   0x6860             LDR      R0,[R4, #+4]
   \   000000FE   0x68A1             LDR      R1,[R4, #+8]
   \   00000100   0x68E2             LDR      R2,[R4, #+12]
   \   00000102   0x69A3             LDR      R3,[R4, #+24]
   \   00000104   0x431A             ORRS     R2,R3,R2
   \   00000106   0x4311             ORRS     R1,R2,R1
   \   00000108   0x4308             ORRS     R0,R1,R0
   \   0000010A   0xF450 0x6000      ORRS     R0,R0,#0x800
   \   0000010E   0x4305             ORRS     R5,R0,R5
    333            
    334            /* Write to SPIx I2SCFGR */  
    335            hi2s->Instance->I2SCFGR = tmpreg;
   \   00000110   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000112   0x6820             LDR      R0,[R4, #+0]
   \   00000114   0x61C5             STR      R5,[R0, #+28]
    336            
    337            hi2s->ErrorCode = HAL_I2S_ERROR_NONE;
   \   00000116   0x2000             MOVS     R0,#+0
   \   00000118   0x63E0             STR      R0,[R4, #+60]
    338            hi2s->State= HAL_I2S_STATE_READY;
   \   0000011A   0x2001             MOVS     R0,#+1
   \   0000011C   0xF884 0x0039      STRB     R0,[R4, #+57]
    339            
    340            return HAL_OK;
   \   00000120   0x2000             MOVS     R0,#+0
   \                     ??HAL_I2S_Init_1: (+1)
   \   00000122   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
    341          }
    342                     
    343          /**
    344            * @brief DeInitializes the I2S peripheral 
    345            * @param  hi2s: pointer to a I2S_HandleTypeDef structure that contains
    346            *         the configuration information for I2S module
    347            * @retval HAL status
    348            */

   \                                 In section .text, align 2, keep-with-next
    349          HAL_StatusTypeDef HAL_I2S_DeInit(I2S_HandleTypeDef *hi2s)
    350          {
   \                     HAL_I2S_DeInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    351            /* Check the I2S handle allocation */
    352            if(hi2s == NULL)
   \   00000004   0x2C00             CMP      R4,#+0
   \   00000006   0xD101             BNE.N    ??HAL_I2S_DeInit_0
    353            {
    354              return HAL_ERROR;
   \   00000008   0x2001             MOVS     R0,#+1
   \   0000000A   0xE00E             B.N      ??HAL_I2S_DeInit_1
    355            }
    356            
    357            /* Check the parameters */
    358            assert_param(IS_I2S_ALL_INSTANCE(hi2s->Instance));
    359          
    360            hi2s->State = HAL_I2S_STATE_BUSY;
   \                     ??HAL_I2S_DeInit_0: (+1)
   \   0000000C   0x2002             MOVS     R0,#+2
   \   0000000E   0xF884 0x0039      STRB     R0,[R4, #+57]
    361            
    362            /* DeInit the low level hardware: GPIO, CLOCK, NVIC... */
    363            HAL_I2S_MspDeInit(hi2s);
   \   00000012   0x0020             MOVS     R0,R4
   \   00000014   0x.... 0x....      BL       HAL_I2S_MspDeInit
    364            
    365            hi2s->ErrorCode = HAL_I2S_ERROR_NONE;
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x63E0             STR      R0,[R4, #+60]
    366            hi2s->State = HAL_I2S_STATE_RESET;
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0xF884 0x0039      STRB     R0,[R4, #+57]
    367            
    368            /* Release Lock */
    369            __HAL_UNLOCK(hi2s);
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0xF884 0x0038      STRB     R0,[R4, #+56]
    370          
    371            return HAL_OK;
   \   00000028   0x2000             MOVS     R0,#+0
   \                     ??HAL_I2S_DeInit_1: (+1)
   \   0000002A   0xBD10             POP      {R4,PC}          ;; return
    372          }
    373          
    374          /**
    375            * @brief I2S MSP Init
    376            * @param  hi2s: pointer to a I2S_HandleTypeDef structure that contains
    377            *         the configuration information for I2S module
    378            * @retval None
    379            */

   \                                 In section .text, align 2, keep-with-next
    380           __weak void HAL_I2S_MspInit(I2S_HandleTypeDef *hi2s)
    381          {
    382            /* NOTE : This function Should not be modified, when the callback is needed,
    383                      the HAL_I2S_MspInit could be implemented in the user file
    384             */ 
    385          }
   \                     HAL_I2S_MspInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    386          
    387          /**
    388            * @brief I2S MSP DeInit
    389            * @param  hi2s: pointer to a I2S_HandleTypeDef structure that contains
    390            *         the configuration information for I2S module
    391            * @retval None
    392            */

   \                                 In section .text, align 2, keep-with-next
    393           __weak void HAL_I2S_MspDeInit(I2S_HandleTypeDef *hi2s)
    394          {
    395            /* NOTE : This function Should not be modified, when the callback is needed,
    396                      the HAL_I2S_MspDeInit could be implemented in the user file
    397             */ 
    398          }
   \                     HAL_I2S_MspDeInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    399          
    400          /**
    401            * @}
    402            */
    403          
    404          /** @defgroup I2S_Exported_Functions_Group2 Input and Output operation functions 
    405            *  @brief Data transfers functions 
    406            *
    407          @verbatim   
    408           ===============================================================================
    409                                ##### IO operation functions #####
    410           ===============================================================================  
    411              [..]
    412              This subsection provides a set of functions allowing to manage the I2S data 
    413              transfers.
    414          
    415              (#) There are two modes of transfer:
    416                 (++) Blocking mode : The communication is performed in the polling mode. 
    417                      The status of all data processing is returned by the same function 
    418                      after finishing transfer.  
    419                 (++) No-Blocking mode : The communication is performed using Interrupts 
    420                      or DMA. These functions return the status of the transfer startup.
    421                      The end of the data processing will be indicated through the 
    422                      dedicated I2S IRQ when using Interrupt mode or the DMA IRQ when 
    423                      using DMA mode.
    424          
    425              (#) Blocking mode functions are :
    426                  (++) HAL_I2S_Transmit()
    427                  (++) HAL_I2S_Receive()
    428                  
    429              (#) No-Blocking mode functions with Interrupt are :
    430                  (++) HAL_I2S_Transmit_IT()
    431                  (++) HAL_I2S_Receive_IT()
    432          
    433              (#) No-Blocking mode functions with DMA are :
    434                  (++) HAL_I2S_Transmit_DMA()
    435                  (++) HAL_I2S_Receive_DMA()
    436          
    437              (#) A set of Transfer Complete Callbacks are provided in non Blocking mode:
    438                  (++) HAL_I2S_TxCpltCallback()
    439                  (++) HAL_I2S_RxCpltCallback()
    440                  (++) HAL_I2S_ErrorCallback()
    441          
    442          @endverbatim
    443            * @{
    444            */
    445          
    446          /**
    447            * @brief Transmit an amount of data in blocking mode
    448            * @param  hi2s: pointer to a I2S_HandleTypeDef structure that contains
    449            *         the configuration information for I2S module
    450            * @param pData: a 16-bit pointer to data buffer.
    451            * @param Size: number of data sample to be sent:
    452            * @note When a 16-bit data frame or a 16-bit data frame extended is selected during the I2S
    453            *       configuration phase, the Size parameter means the number of 16-bit data length 
    454            *       in the transaction and when a 24-bit data frame or a 32-bit data frame is selected 
    455            *       the Size parameter means the number of 16-bit data length. 
    456            * @param  Timeout: Timeout duration
    457            * @note The I2S is kept enabled at the end of transaction to avoid the clock de-synchronization 
    458            *       between Master and Slave(example: audio streaming).
    459            * @retval HAL status
    460            */

   \                                 In section .text, align 2, keep-with-next
    461          HAL_StatusTypeDef HAL_I2S_Transmit(I2S_HandleTypeDef *hi2s, uint16_t *pData, uint16_t Size, uint32_t Timeout)
    462          {
   \                     HAL_I2S_Transmit: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   \   00000008   0x001F             MOVS     R7,R3
    463            if((pData == NULL ) || (Size == 0)) 
   \   0000000A   0x2D00             CMP      R5,#+0
   \   0000000C   0xD002             BEQ.N    ??HAL_I2S_Transmit_0
   \   0000000E   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000010   0x2E00             CMP      R6,#+0
   \   00000012   0xD101             BNE.N    ??HAL_I2S_Transmit_1
    464            {
    465              return  HAL_ERROR;                                    
   \                     ??HAL_I2S_Transmit_0: (+1)
   \   00000014   0x2001             MOVS     R0,#+1
   \   00000016   0xE082             B.N      ??HAL_I2S_Transmit_2
    466            }
    467            
    468            if(hi2s->State == HAL_I2S_STATE_READY)
   \                     ??HAL_I2S_Transmit_1: (+1)
   \   00000018   0xF894 0x0039      LDRB     R0,[R4, #+57]
   \   0000001C   0x2801             CMP      R0,#+1
   \   0000001E   0xD17D             BNE.N    ??HAL_I2S_Transmit_3
    469            { 
    470              if(((hi2s->Instance->I2SCFGR & (SPI_I2SCFGR_DATLEN | SPI_I2SCFGR_CHLEN)) == I2S_DATAFORMAT_24B)||\
    471                 ((hi2s->Instance->I2SCFGR & (SPI_I2SCFGR_DATLEN | SPI_I2SCFGR_CHLEN)) == I2S_DATAFORMAT_32B))
   \   00000020   0x6820             LDR      R0,[R4, #+0]
   \   00000022   0x69C0             LDR      R0,[R0, #+28]
   \   00000024   0xF010 0x0007      ANDS     R0,R0,#0x7
   \   00000028   0x2803             CMP      R0,#+3
   \   0000002A   0xD005             BEQ.N    ??HAL_I2S_Transmit_4
   \   0000002C   0x6820             LDR      R0,[R4, #+0]
   \   0000002E   0x69C0             LDR      R0,[R0, #+28]
   \   00000030   0xF010 0x0007      ANDS     R0,R0,#0x7
   \   00000034   0x2805             CMP      R0,#+5
   \   00000036   0xD104             BNE.N    ??HAL_I2S_Transmit_5
    472              {
    473                hi2s->TxXferSize = (Size << 1);
   \                     ??HAL_I2S_Transmit_4: (+1)
   \   00000038   0x0070             LSLS     R0,R6,#+1
   \   0000003A   0x84A0             STRH     R0,[R4, #+36]
    474                hi2s->TxXferCount = (Size << 1);
   \   0000003C   0x0070             LSLS     R0,R6,#+1
   \   0000003E   0x84E0             STRH     R0,[R4, #+38]
   \   00000040   0xE001             B.N      ??HAL_I2S_Transmit_6
    475              }
    476              else
    477              {
    478                hi2s->TxXferSize = Size;
   \                     ??HAL_I2S_Transmit_5: (+1)
   \   00000042   0x84A6             STRH     R6,[R4, #+36]
    479                hi2s->TxXferCount = Size;
   \   00000044   0x84E6             STRH     R6,[R4, #+38]
    480              }
    481              
    482              /* Process Locked */
    483              __HAL_LOCK(hi2s);
   \                     ??HAL_I2S_Transmit_6: (+1)
   \   00000046   0xF894 0x0038      LDRB     R0,[R4, #+56]
   \   0000004A   0x2801             CMP      R0,#+1
   \   0000004C   0xD101             BNE.N    ??HAL_I2S_Transmit_7
   \   0000004E   0x2002             MOVS     R0,#+2
   \   00000050   0xE065             B.N      ??HAL_I2S_Transmit_2
   \                     ??HAL_I2S_Transmit_7: (+1)
   \   00000052   0x2001             MOVS     R0,#+1
   \   00000054   0xF884 0x0038      STRB     R0,[R4, #+56]
    484              
    485              hi2s->ErrorCode = HAL_I2S_ERROR_NONE;
   \   00000058   0x2000             MOVS     R0,#+0
   \   0000005A   0x63E0             STR      R0,[R4, #+60]
    486              hi2s->State = HAL_I2S_STATE_BUSY_TX;
   \   0000005C   0x2003             MOVS     R0,#+3
   \   0000005E   0xF884 0x0039      STRB     R0,[R4, #+57]
    487             
    488              /* Check if the I2S is already enabled */ 
    489              if((hi2s->Instance->I2SCFGR &SPI_I2SCFGR_I2SE) != SPI_I2SCFGR_I2SE)
   \   00000062   0x6820             LDR      R0,[R4, #+0]
   \   00000064   0x69C0             LDR      R0,[R0, #+28]
   \   00000066   0x0540             LSLS     R0,R0,#+21
   \   00000068   0xD405             BMI.N    ??HAL_I2S_Transmit_8
    490              {
    491                /* Enable I2S peripheral */    
    492                __HAL_I2S_ENABLE(hi2s);
   \   0000006A   0x6820             LDR      R0,[R4, #+0]
   \   0000006C   0x69C0             LDR      R0,[R0, #+28]
   \   0000006E   0xF450 0x6080      ORRS     R0,R0,#0x400
   \   00000072   0x6821             LDR      R1,[R4, #+0]
   \   00000074   0x61C8             STR      R0,[R1, #+28]
    493              }
    494              
    495              while(hi2s->TxXferCount > 0)
   \                     ??HAL_I2S_Transmit_8: (+1)
   \   00000076   0x8CE0             LDRH     R0,[R4, #+38]
   \   00000078   0x2800             CMP      R0,#+0
   \   0000007A   0xD02A             BEQ.N    ??HAL_I2S_Transmit_9
    496              {
    497                hi2s->Instance->DR = (*pData++);
   \   0000007C   0x8828             LDRH     R0,[R5, #+0]
   \   0000007E   0x6821             LDR      R1,[R4, #+0]
   \   00000080   0x60C8             STR      R0,[R1, #+12]
   \   00000082   0x1CAD             ADDS     R5,R5,#+2
    498                hi2s->TxXferCount--;   
   \   00000084   0x8CE0             LDRH     R0,[R4, #+38]
   \   00000086   0x1E40             SUBS     R0,R0,#+1
   \   00000088   0x84E0             STRH     R0,[R4, #+38]
    499                /* Wait until TXE flag is set */
    500                if (I2S_WaitFlagStateUntilTimeout(hi2s, I2S_FLAG_TXE, SET, Timeout) != HAL_OK)
   \   0000008A   0x003B             MOVS     R3,R7
   \   0000008C   0x2201             MOVS     R2,#+1
   \   0000008E   0x2102             MOVS     R1,#+2
   \   00000090   0x0020             MOVS     R0,R4
   \   00000092   0x.... 0x....      BL       I2S_WaitFlagStateUntilTimeout
   \   00000096   0x2800             CMP      R0,#+0
   \   00000098   0xD008             BEQ.N    ??HAL_I2S_Transmit_10
    501                {
    502                  /* Set the error code and execute error callback*/
    503                  hi2s->ErrorCode |= HAL_I2S_ERROR_TIMEOUT;
   \   0000009A   0x6BE0             LDR      R0,[R4, #+60]
   \   0000009C   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   000000A0   0x63E0             STR      R0,[R4, #+60]
    504                  HAL_I2S_ErrorCallback(hi2s);
   \   000000A2   0x0020             MOVS     R0,R4
   \   000000A4   0x.... 0x....      BL       HAL_I2S_ErrorCallback
    505                  return HAL_TIMEOUT;
   \   000000A8   0x2003             MOVS     R0,#+3
   \   000000AA   0xE038             B.N      ??HAL_I2S_Transmit_2
    506                }
    507          
    508                /* Check if an underrun occurs */
    509                if(__HAL_I2S_GET_FLAG(hi2s, I2S_FLAG_UDR) == SET) 
   \                     ??HAL_I2S_Transmit_10: (+1)
   \   000000AC   0x6820             LDR      R0,[R4, #+0]
   \   000000AE   0x6880             LDR      R0,[R0, #+8]
   \   000000B0   0x0700             LSLS     R0,R0,#+28
   \   000000B2   0xD5E0             BPL.N    ??HAL_I2S_Transmit_8
    510                {
    511                  /* Set the I2S State ready */
    512                  hi2s->State = HAL_I2S_STATE_READY; 
   \   000000B4   0x2001             MOVS     R0,#+1
   \   000000B6   0xF884 0x0039      STRB     R0,[R4, #+57]
    513          
    514                  /* Process Unlocked */
    515                  __HAL_UNLOCK(hi2s);
   \   000000BA   0x2000             MOVS     R0,#+0
   \   000000BC   0xF884 0x0038      STRB     R0,[R4, #+56]
    516          
    517                  /* Set the error code and execute error callback*/
    518                  hi2s->ErrorCode |= HAL_I2S_ERROR_UDR;
   \   000000C0   0x6BE0             LDR      R0,[R4, #+60]
   \   000000C2   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   000000C6   0x63E0             STR      R0,[R4, #+60]
    519                  HAL_I2S_ErrorCallback(hi2s);
   \   000000C8   0x0020             MOVS     R0,R4
   \   000000CA   0x.... 0x....      BL       HAL_I2S_ErrorCallback
    520          
    521                  return HAL_ERROR;
   \   000000CE   0x2001             MOVS     R0,#+1
   \   000000D0   0xE025             B.N      ??HAL_I2S_Transmit_2
    522                }
    523              }      
    524              
    525              /* Check if Slave mode is selected */
    526              if(((hi2s->Instance->I2SCFGR & SPI_I2SCFGR_I2SCFG) == I2S_MODE_SLAVE_TX) || ((hi2s->Instance->I2SCFGR & SPI_I2SCFGR_I2SCFG) == I2S_MODE_SLAVE_RX))
   \                     ??HAL_I2S_Transmit_9: (+1)
   \   000000D2   0x6820             LDR      R0,[R4, #+0]
   \   000000D4   0x69C0             LDR      R0,[R0, #+28]
   \   000000D6   0xF410 0x7F40      TST      R0,#0x300
   \   000000DA   0xD006             BEQ.N    ??HAL_I2S_Transmit_11
   \   000000DC   0x6820             LDR      R0,[R4, #+0]
   \   000000DE   0x69C0             LDR      R0,[R0, #+28]
   \   000000E0   0xF410 0x7040      ANDS     R0,R0,#0x300
   \   000000E4   0xF5B0 0x7F80      CMP      R0,#+256
   \   000000E8   0xD110             BNE.N    ??HAL_I2S_Transmit_12
    527              {
    528                /* Wait until Busy flag is reset */
    529                if (I2S_WaitFlagStateUntilTimeout(hi2s, I2S_FLAG_BSY, RESET, Timeout) != HAL_OK) 
   \                     ??HAL_I2S_Transmit_11: (+1)
   \   000000EA   0x003B             MOVS     R3,R7
   \   000000EC   0x2200             MOVS     R2,#+0
   \   000000EE   0x2180             MOVS     R1,#+128
   \   000000F0   0x0020             MOVS     R0,R4
   \   000000F2   0x.... 0x....      BL       I2S_WaitFlagStateUntilTimeout
   \   000000F6   0x2800             CMP      R0,#+0
   \   000000F8   0xD008             BEQ.N    ??HAL_I2S_Transmit_12
    530                {
    531                  /* Set the error code and execute error callback*/
    532                  hi2s->ErrorCode |= HAL_I2S_ERROR_TIMEOUT;
   \   000000FA   0x6BE0             LDR      R0,[R4, #+60]
   \   000000FC   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000100   0x63E0             STR      R0,[R4, #+60]
    533                  HAL_I2S_ErrorCallback(hi2s);
   \   00000102   0x0020             MOVS     R0,R4
   \   00000104   0x.... 0x....      BL       HAL_I2S_ErrorCallback
    534                  return HAL_TIMEOUT;
   \   00000108   0x2003             MOVS     R0,#+3
   \   0000010A   0xE008             B.N      ??HAL_I2S_Transmit_2
    535                }
    536              }
    537              
    538              hi2s->State = HAL_I2S_STATE_READY; 
   \                     ??HAL_I2S_Transmit_12: (+1)
   \   0000010C   0x2001             MOVS     R0,#+1
   \   0000010E   0xF884 0x0039      STRB     R0,[R4, #+57]
    539              
    540              /* Process Unlocked */
    541              __HAL_UNLOCK(hi2s);
   \   00000112   0x2000             MOVS     R0,#+0
   \   00000114   0xF884 0x0038      STRB     R0,[R4, #+56]
    542              
    543              return HAL_OK;
   \   00000118   0x2000             MOVS     R0,#+0
   \   0000011A   0xE000             B.N      ??HAL_I2S_Transmit_2
    544            }
    545            else
    546            {
    547              return HAL_BUSY;
   \                     ??HAL_I2S_Transmit_3: (+1)
   \   0000011C   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2S_Transmit_2: (+1)
   \   0000011E   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    548            }
    549          }
    550          
    551          /**
    552            * @brief Receive an amount of data in blocking mode 
    553            * @param  hi2s: pointer to a I2S_HandleTypeDef structure that contains
    554            *         the configuration information for I2S module
    555            * @param pData: a 16-bit pointer to data buffer.
    556            * @param Size: number of data sample to be sent:
    557            * @note When a 16-bit data frame or a 16-bit data frame extended is selected during the I2S
    558            *       configuration phase, the Size parameter means the number of 16-bit data length 
    559            *       in the transaction and when a 24-bit data frame or a 32-bit data frame is selected 
    560            *       the Size parameter means the number of 16-bit data length. 
    561            * @param Timeout: Timeout duration
    562            * @note The I2S is kept enabled at the end of transaction to avoid the clock de-synchronization 
    563            *       between Master and Slave(example: audio streaming).
    564            * @note In I2S Master Receiver mode, just after enabling the peripheral the clock will be generate
    565            *       in continuous way and as the I2S is not disabled at the end of the I2S transaction.
    566            * @retval HAL status
    567            */

   \                                 In section .text, align 2, keep-with-next
    568          HAL_StatusTypeDef HAL_I2S_Receive(I2S_HandleTypeDef *hi2s, uint16_t *pData, uint16_t Size, uint32_t Timeout)
    569          {
   \                     HAL_I2S_Receive: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   \   00000008   0x001F             MOVS     R7,R3
    570            if((pData == NULL ) || (Size == 0)) 
   \   0000000A   0x2D00             CMP      R5,#+0
   \   0000000C   0xD002             BEQ.N    ??HAL_I2S_Receive_0
   \   0000000E   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000010   0x2E00             CMP      R6,#+0
   \   00000012   0xD101             BNE.N    ??HAL_I2S_Receive_1
    571            {
    572              return  HAL_ERROR;                                    
   \                     ??HAL_I2S_Receive_0: (+1)
   \   00000014   0x2001             MOVS     R0,#+1
   \   00000016   0xE074             B.N      ??HAL_I2S_Receive_2
    573            }
    574            
    575            if(hi2s->State == HAL_I2S_STATE_READY)
   \                     ??HAL_I2S_Receive_1: (+1)
   \   00000018   0xF894 0x0039      LDRB     R0,[R4, #+57]
   \   0000001C   0x2801             CMP      R0,#+1
   \   0000001E   0xD16F             BNE.N    ??HAL_I2S_Receive_3
    576            { 
    577              if(((hi2s->Instance->I2SCFGR & (SPI_I2SCFGR_DATLEN | SPI_I2SCFGR_CHLEN)) == I2S_DATAFORMAT_24B)||\
    578                 ((hi2s->Instance->I2SCFGR & (SPI_I2SCFGR_DATLEN | SPI_I2SCFGR_CHLEN)) == I2S_DATAFORMAT_32B))
   \   00000020   0x6820             LDR      R0,[R4, #+0]
   \   00000022   0x69C0             LDR      R0,[R0, #+28]
   \   00000024   0xF010 0x0007      ANDS     R0,R0,#0x7
   \   00000028   0x2803             CMP      R0,#+3
   \   0000002A   0xD005             BEQ.N    ??HAL_I2S_Receive_4
   \   0000002C   0x6820             LDR      R0,[R4, #+0]
   \   0000002E   0x69C0             LDR      R0,[R0, #+28]
   \   00000030   0xF010 0x0007      ANDS     R0,R0,#0x7
   \   00000034   0x2805             CMP      R0,#+5
   \   00000036   0xD104             BNE.N    ??HAL_I2S_Receive_5
    579              {
    580                hi2s->RxXferSize = (Size << 1);
   \                     ??HAL_I2S_Receive_4: (+1)
   \   00000038   0x0070             LSLS     R0,R6,#+1
   \   0000003A   0x85A0             STRH     R0,[R4, #+44]
    581                hi2s->RxXferCount = (Size << 1);
   \   0000003C   0x0070             LSLS     R0,R6,#+1
   \   0000003E   0x85E0             STRH     R0,[R4, #+46]
   \   00000040   0xE001             B.N      ??HAL_I2S_Receive_6
    582              }
    583              else
    584              {
    585                hi2s->RxXferSize = Size;
   \                     ??HAL_I2S_Receive_5: (+1)
   \   00000042   0x85A6             STRH     R6,[R4, #+44]
    586                hi2s->RxXferCount = Size;
   \   00000044   0x85E6             STRH     R6,[R4, #+46]
    587              }
    588              /* Process Locked */
    589              __HAL_LOCK(hi2s);
   \                     ??HAL_I2S_Receive_6: (+1)
   \   00000046   0xF894 0x0038      LDRB     R0,[R4, #+56]
   \   0000004A   0x2801             CMP      R0,#+1
   \   0000004C   0xD101             BNE.N    ??HAL_I2S_Receive_7
   \   0000004E   0x2002             MOVS     R0,#+2
   \   00000050   0xE057             B.N      ??HAL_I2S_Receive_2
   \                     ??HAL_I2S_Receive_7: (+1)
   \   00000052   0x2001             MOVS     R0,#+1
   \   00000054   0xF884 0x0038      STRB     R0,[R4, #+56]
    590              
    591              hi2s->ErrorCode = HAL_I2S_ERROR_NONE;
   \   00000058   0x2000             MOVS     R0,#+0
   \   0000005A   0x63E0             STR      R0,[R4, #+60]
    592              hi2s->State = HAL_I2S_STATE_BUSY_RX;
   \   0000005C   0x2004             MOVS     R0,#+4
   \   0000005E   0xF884 0x0039      STRB     R0,[R4, #+57]
    593                  
    594              /* Check if the I2S is already enabled */ 
    595              if((hi2s->Instance->I2SCFGR & SPI_I2SCFGR_I2SE) != SPI_I2SCFGR_I2SE)
   \   00000062   0x6820             LDR      R0,[R4, #+0]
   \   00000064   0x69C0             LDR      R0,[R0, #+28]
   \   00000066   0x0540             LSLS     R0,R0,#+21
   \   00000068   0xD405             BMI.N    ??HAL_I2S_Receive_8
    596              {
    597                /* Enable I2S peripheral */    
    598                __HAL_I2S_ENABLE(hi2s);
   \   0000006A   0x6820             LDR      R0,[R4, #+0]
   \   0000006C   0x69C0             LDR      R0,[R0, #+28]
   \   0000006E   0xF450 0x6080      ORRS     R0,R0,#0x400
   \   00000072   0x6821             LDR      R1,[R4, #+0]
   \   00000074   0x61C8             STR      R0,[R1, #+28]
    599              }
    600              
    601              /* Check if Master Receiver mode is selected */
    602              if((hi2s->Instance->I2SCFGR & SPI_I2SCFGR_I2SCFG) == I2S_MODE_MASTER_RX)
   \                     ??HAL_I2S_Receive_8: (+1)
   \   00000076   0x6820             LDR      R0,[R4, #+0]
   \   00000078   0x69C0             LDR      R0,[R0, #+28]
   \   0000007A   0xF410 0x7040      ANDS     R0,R0,#0x300
   \   0000007E   0xF5B0 0x7F40      CMP      R0,#+768
   \   00000082   0xD106             BNE.N    ??HAL_I2S_Receive_9
    603              {
    604                /* Clear the Overrun Flag by a read operation on the SPI_DR register followed by a read
    605                access to the SPI_SR register. */ 
    606                __HAL_I2S_CLEAR_OVRFLAG(hi2s);        
   \   00000084   0x6820             LDR      R0,[R4, #+0]
   \   00000086   0x68C0             LDR      R0,[R0, #+12]
   \   00000088   0x9000             STR      R0,[SP, #+0]
   \   0000008A   0x6820             LDR      R0,[R4, #+0]
   \   0000008C   0x6880             LDR      R0,[R0, #+8]
   \   0000008E   0x9000             STR      R0,[SP, #+0]
   \   00000090   0x9800             LDR      R0,[SP, #+0]
    607              }
    608              
    609              /* Receive data */
    610              while(hi2s->RxXferCount > 0)
   \                     ??HAL_I2S_Receive_9: (+1)
   \   00000092   0x8DE0             LDRH     R0,[R4, #+46]
   \   00000094   0x2800             CMP      R0,#+0
   \   00000096   0xD02B             BEQ.N    ??HAL_I2S_Receive_10
    611              {
    612                /* Wait until RXNE flag is set */
    613                if (I2S_WaitFlagStateUntilTimeout(hi2s, I2S_FLAG_RXNE, SET, Timeout) != HAL_OK) 
   \   00000098   0x003B             MOVS     R3,R7
   \   0000009A   0x2201             MOVS     R2,#+1
   \   0000009C   0x2101             MOVS     R1,#+1
   \   0000009E   0x0020             MOVS     R0,R4
   \   000000A0   0x.... 0x....      BL       I2S_WaitFlagStateUntilTimeout
   \   000000A4   0x2800             CMP      R0,#+0
   \   000000A6   0xD008             BEQ.N    ??HAL_I2S_Receive_11
    614                {
    615                  /* Set the error code and execute error callback*/
    616                  hi2s->ErrorCode |= HAL_I2S_ERROR_TIMEOUT;
   \   000000A8   0x6BE0             LDR      R0,[R4, #+60]
   \   000000AA   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   000000AE   0x63E0             STR      R0,[R4, #+60]
    617                  HAL_I2S_ErrorCallback(hi2s);
   \   000000B0   0x0020             MOVS     R0,R4
   \   000000B2   0x.... 0x....      BL       HAL_I2S_ErrorCallback
    618                  return HAL_TIMEOUT;
   \   000000B6   0x2003             MOVS     R0,#+3
   \   000000B8   0xE023             B.N      ??HAL_I2S_Receive_2
    619                }
    620                
    621                /* Check if an overrun occurs */
    622                if(__HAL_I2S_GET_FLAG(hi2s, I2S_FLAG_OVR) == SET) 
   \                     ??HAL_I2S_Receive_11: (+1)
   \   000000BA   0x6820             LDR      R0,[R4, #+0]
   \   000000BC   0x6880             LDR      R0,[R0, #+8]
   \   000000BE   0x0640             LSLS     R0,R0,#+25
   \   000000C0   0xD50E             BPL.N    ??HAL_I2S_Receive_12
    623                {
    624                  /* Set the I2S State ready */
    625                  hi2s->State = HAL_I2S_STATE_READY; 
   \   000000C2   0x2001             MOVS     R0,#+1
   \   000000C4   0xF884 0x0039      STRB     R0,[R4, #+57]
    626          
    627                  /* Process Unlocked */
    628                  __HAL_UNLOCK(hi2s);
   \   000000C8   0x2000             MOVS     R0,#+0
   \   000000CA   0xF884 0x0038      STRB     R0,[R4, #+56]
    629          
    630                  /* Set the error code and execute error callback*/
    631                  hi2s->ErrorCode |= HAL_I2S_ERROR_OVR;
   \   000000CE   0x6BE0             LDR      R0,[R4, #+60]
   \   000000D0   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   000000D4   0x63E0             STR      R0,[R4, #+60]
    632                  HAL_I2S_ErrorCallback(hi2s);
   \   000000D6   0x0020             MOVS     R0,R4
   \   000000D8   0x.... 0x....      BL       HAL_I2S_ErrorCallback
    633          
    634                  return HAL_ERROR;
   \   000000DC   0x2001             MOVS     R0,#+1
   \   000000DE   0xE010             B.N      ??HAL_I2S_Receive_2
    635                }
    636          
    637                (*pData++) = hi2s->Instance->DR;
   \                     ??HAL_I2S_Receive_12: (+1)
   \   000000E0   0x6820             LDR      R0,[R4, #+0]
   \   000000E2   0x68C0             LDR      R0,[R0, #+12]
   \   000000E4   0x8028             STRH     R0,[R5, #+0]
   \   000000E6   0x1CAD             ADDS     R5,R5,#+2
    638                hi2s->RxXferCount--;
   \   000000E8   0x8DE0             LDRH     R0,[R4, #+46]
   \   000000EA   0x1E40             SUBS     R0,R0,#+1
   \   000000EC   0x85E0             STRH     R0,[R4, #+46]
   \   000000EE   0xE7D0             B.N      ??HAL_I2S_Receive_9
    639              }      
    640          
    641              hi2s->State = HAL_I2S_STATE_READY; 
   \                     ??HAL_I2S_Receive_10: (+1)
   \   000000F0   0x2001             MOVS     R0,#+1
   \   000000F2   0xF884 0x0039      STRB     R0,[R4, #+57]
    642              
    643              /* Process Unlocked */
    644              __HAL_UNLOCK(hi2s);
   \   000000F6   0x2000             MOVS     R0,#+0
   \   000000F8   0xF884 0x0038      STRB     R0,[R4, #+56]
    645              
    646              return HAL_OK;
   \   000000FC   0x2000             MOVS     R0,#+0
   \   000000FE   0xE000             B.N      ??HAL_I2S_Receive_2
    647            }
    648            else
    649            {
    650              return HAL_BUSY;
   \                     ??HAL_I2S_Receive_3: (+1)
   \   00000100   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2S_Receive_2: (+1)
   \   00000102   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    651            }
    652          }
    653          
    654          /**
    655            * @brief Transmit an amount of data in non-blocking mode with Interrupt
    656            * @param  hi2s: pointer to a I2S_HandleTypeDef structure that contains
    657            *         the configuration information for I2S module
    658            * @param pData: a 16-bit pointer to data buffer.
    659            * @param Size: number of data sample to be sent:
    660            * @note When a 16-bit data frame or a 16-bit data frame extended is selected during the I2S
    661            *       configuration phase, the Size parameter means the number of 16-bit data length 
    662            *       in the transaction and when a 24-bit data frame or a 32-bit data frame is selected 
    663            *       the Size parameter means the number of 16-bit data length. 
    664            * @note The I2S is kept enabled at the end of transaction to avoid the clock de-synchronization 
    665            *       between Master and Slave(example: audio streaming).
    666            * @retval HAL status
    667            */

   \                                 In section .text, align 2, keep-with-next
    668          HAL_StatusTypeDef HAL_I2S_Transmit_IT(I2S_HandleTypeDef *hi2s, uint16_t *pData, uint16_t Size)
    669          {
   \                     HAL_I2S_Transmit_IT: (+1)
   \   00000000   0xB410             PUSH     {R4}
   \   00000002   0x0003             MOVS     R3,R0
    670            if(hi2s->State == HAL_I2S_STATE_READY)
   \   00000004   0xF893 0x0039      LDRB     R0,[R3, #+57]
   \   00000008   0x2801             CMP      R0,#+1
   \   0000000A   0xD13D             BNE.N    ??HAL_I2S_Transmit_IT_0
    671            {
    672              if((pData == NULL) || (Size == 0)) 
   \   0000000C   0x2900             CMP      R1,#+0
   \   0000000E   0xD002             BEQ.N    ??HAL_I2S_Transmit_IT_1
   \   00000010   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000012   0x2A00             CMP      R2,#+0
   \   00000014   0xD101             BNE.N    ??HAL_I2S_Transmit_IT_2
    673              {
    674                return  HAL_ERROR;                                    
   \                     ??HAL_I2S_Transmit_IT_1: (+1)
   \   00000016   0x2001             MOVS     R0,#+1
   \   00000018   0xE037             B.N      ??HAL_I2S_Transmit_IT_3
    675              }
    676              
    677              hi2s->pTxBuffPtr = pData;
   \                     ??HAL_I2S_Transmit_IT_2: (+1)
   \   0000001A   0x6219             STR      R1,[R3, #+32]
    678              if(((hi2s->Instance->I2SCFGR & (SPI_I2SCFGR_DATLEN | SPI_I2SCFGR_CHLEN)) == I2S_DATAFORMAT_24B)||\
    679                ((hi2s->Instance->I2SCFGR & (SPI_I2SCFGR_DATLEN | SPI_I2SCFGR_CHLEN)) == I2S_DATAFORMAT_32B))
   \   0000001C   0x6818             LDR      R0,[R3, #+0]
   \   0000001E   0x69C0             LDR      R0,[R0, #+28]
   \   00000020   0xF010 0x0007      ANDS     R0,R0,#0x7
   \   00000024   0x2803             CMP      R0,#+3
   \   00000026   0xD005             BEQ.N    ??HAL_I2S_Transmit_IT_4
   \   00000028   0x6818             LDR      R0,[R3, #+0]
   \   0000002A   0x69C0             LDR      R0,[R0, #+28]
   \   0000002C   0xF010 0x0007      ANDS     R0,R0,#0x7
   \   00000030   0x2805             CMP      R0,#+5
   \   00000032   0xD104             BNE.N    ??HAL_I2S_Transmit_IT_5
    680              {
    681                hi2s->TxXferSize = (Size << 1);
   \                     ??HAL_I2S_Transmit_IT_4: (+1)
   \   00000034   0x0050             LSLS     R0,R2,#+1
   \   00000036   0x8498             STRH     R0,[R3, #+36]
    682                hi2s->TxXferCount = (Size << 1);
   \   00000038   0x0050             LSLS     R0,R2,#+1
   \   0000003A   0x84D8             STRH     R0,[R3, #+38]
   \   0000003C   0xE001             B.N      ??HAL_I2S_Transmit_IT_6
    683              }  
    684              else
    685              {
    686                hi2s->TxXferSize = Size;
   \                     ??HAL_I2S_Transmit_IT_5: (+1)
   \   0000003E   0x849A             STRH     R2,[R3, #+36]
    687                hi2s->TxXferCount = Size;
   \   00000040   0x84DA             STRH     R2,[R3, #+38]
    688              }
    689              
    690              /* Process Locked */
    691              __HAL_LOCK(hi2s);
   \                     ??HAL_I2S_Transmit_IT_6: (+1)
   \   00000042   0xF893 0x0038      LDRB     R0,[R3, #+56]
   \   00000046   0x2801             CMP      R0,#+1
   \   00000048   0xD101             BNE.N    ??HAL_I2S_Transmit_IT_7
   \   0000004A   0x2002             MOVS     R0,#+2
   \   0000004C   0xE01D             B.N      ??HAL_I2S_Transmit_IT_3
   \                     ??HAL_I2S_Transmit_IT_7: (+1)
   \   0000004E   0x2001             MOVS     R0,#+1
   \   00000050   0xF883 0x0038      STRB     R0,[R3, #+56]
    692              
    693              hi2s->ErrorCode = HAL_I2S_ERROR_NONE;
   \   00000054   0x2000             MOVS     R0,#+0
   \   00000056   0x63D8             STR      R0,[R3, #+60]
    694              hi2s->State = HAL_I2S_STATE_BUSY_TX;
   \   00000058   0x2003             MOVS     R0,#+3
   \   0000005A   0xF883 0x0039      STRB     R0,[R3, #+57]
    695          
    696              /* Enable TXE and ERR interrupt */
    697              __HAL_I2S_ENABLE_IT(hi2s, (I2S_IT_TXE | I2S_IT_ERR));
   \   0000005E   0x6818             LDR      R0,[R3, #+0]
   \   00000060   0x6840             LDR      R0,[R0, #+4]
   \   00000062   0xF050 0x00A0      ORRS     R0,R0,#0xA0
   \   00000066   0x681C             LDR      R4,[R3, #+0]
   \   00000068   0x6060             STR      R0,[R4, #+4]
    698              
    699              /* Check if the I2S is already enabled */ 
    700              if((hi2s->Instance->I2SCFGR &SPI_I2SCFGR_I2SE) != SPI_I2SCFGR_I2SE)
   \   0000006A   0x6818             LDR      R0,[R3, #+0]
   \   0000006C   0x69C0             LDR      R0,[R0, #+28]
   \   0000006E   0x0540             LSLS     R0,R0,#+21
   \   00000070   0xD405             BMI.N    ??HAL_I2S_Transmit_IT_8
    701              {
    702                /* Enable I2S peripheral */    
    703                __HAL_I2S_ENABLE(hi2s);
   \   00000072   0x6818             LDR      R0,[R3, #+0]
   \   00000074   0x69C0             LDR      R0,[R0, #+28]
   \   00000076   0xF450 0x6080      ORRS     R0,R0,#0x400
   \   0000007A   0x681C             LDR      R4,[R3, #+0]
   \   0000007C   0x61E0             STR      R0,[R4, #+28]
    704              }
    705              
    706              /* Process Unlocked */
    707              __HAL_UNLOCK(hi2s);
   \                     ??HAL_I2S_Transmit_IT_8: (+1)
   \   0000007E   0x2000             MOVS     R0,#+0
   \   00000080   0xF883 0x0038      STRB     R0,[R3, #+56]
    708              
    709              return HAL_OK;
   \   00000084   0x2000             MOVS     R0,#+0
   \   00000086   0xE000             B.N      ??HAL_I2S_Transmit_IT_3
    710            }
    711            else
    712            {
    713              return HAL_BUSY;
   \                     ??HAL_I2S_Transmit_IT_0: (+1)
   \   00000088   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2S_Transmit_IT_3: (+1)
   \   0000008A   0xBC10             POP      {R4}
   \   0000008C   0x4770             BX       LR               ;; return
    714            }
    715          }
    716          
    717          /**
    718            * @brief Receive an amount of data in non-blocking mode with Interrupt
    719            * @param  hi2s: pointer to a I2S_HandleTypeDef structure that contains
    720            *         the configuration information for I2S module
    721            * @param pData: a 16-bit pointer to the Receive data buffer.
    722            * @param Size: number of data sample to be sent:
    723            * @note When a 16-bit data frame or a 16-bit data frame extended is selected during the I2S
    724            *       configuration phase, the Size parameter means the number of 16-bit data length 
    725            *       in the transaction and when a 24-bit data frame or a 32-bit data frame is selected 
    726            *       the Size parameter means the number of 16-bit data length. 
    727            * @note The I2S is kept enabled at the end of transaction to avoid the clock de-synchronization 
    728            *       between Master and Slave(example: audio streaming).
    729            * @note It is recommended to use DMA for the I2S receiver to avoid de-synchronisation 
    730            * between Master and Slave otherwise the I2S interrupt should be optimized. 
    731            * @retval HAL status
    732            */

   \                                 In section .text, align 2, keep-with-next
    733          HAL_StatusTypeDef HAL_I2S_Receive_IT(I2S_HandleTypeDef *hi2s, uint16_t *pData, uint16_t Size)
    734          {
   \                     HAL_I2S_Receive_IT: (+1)
   \   00000000   0xB410             PUSH     {R4}
   \   00000002   0x0003             MOVS     R3,R0
    735            if(hi2s->State == HAL_I2S_STATE_READY)
   \   00000004   0xF893 0x0039      LDRB     R0,[R3, #+57]
   \   00000008   0x2801             CMP      R0,#+1
   \   0000000A   0xD13D             BNE.N    ??HAL_I2S_Receive_IT_0
    736            {
    737              if((pData == NULL) || (Size == 0)) 
   \   0000000C   0x2900             CMP      R1,#+0
   \   0000000E   0xD002             BEQ.N    ??HAL_I2S_Receive_IT_1
   \   00000010   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000012   0x2A00             CMP      R2,#+0
   \   00000014   0xD101             BNE.N    ??HAL_I2S_Receive_IT_2
    738              {
    739                return  HAL_ERROR;                                    
   \                     ??HAL_I2S_Receive_IT_1: (+1)
   \   00000016   0x2001             MOVS     R0,#+1
   \   00000018   0xE037             B.N      ??HAL_I2S_Receive_IT_3
    740              }
    741              
    742              hi2s->pRxBuffPtr = pData;
   \                     ??HAL_I2S_Receive_IT_2: (+1)
   \   0000001A   0x6299             STR      R1,[R3, #+40]
    743              if(((hi2s->Instance->I2SCFGR & (SPI_I2SCFGR_DATLEN | SPI_I2SCFGR_CHLEN)) == I2S_DATAFORMAT_24B)||\
    744                ((hi2s->Instance->I2SCFGR & (SPI_I2SCFGR_DATLEN | SPI_I2SCFGR_CHLEN)) == I2S_DATAFORMAT_32B))
   \   0000001C   0x6818             LDR      R0,[R3, #+0]
   \   0000001E   0x69C0             LDR      R0,[R0, #+28]
   \   00000020   0xF010 0x0007      ANDS     R0,R0,#0x7
   \   00000024   0x2803             CMP      R0,#+3
   \   00000026   0xD005             BEQ.N    ??HAL_I2S_Receive_IT_4
   \   00000028   0x6818             LDR      R0,[R3, #+0]
   \   0000002A   0x69C0             LDR      R0,[R0, #+28]
   \   0000002C   0xF010 0x0007      ANDS     R0,R0,#0x7
   \   00000030   0x2805             CMP      R0,#+5
   \   00000032   0xD104             BNE.N    ??HAL_I2S_Receive_IT_5
    745              {
    746                hi2s->RxXferSize = (Size << 1);
   \                     ??HAL_I2S_Receive_IT_4: (+1)
   \   00000034   0x0050             LSLS     R0,R2,#+1
   \   00000036   0x8598             STRH     R0,[R3, #+44]
    747                hi2s->RxXferCount = (Size << 1);
   \   00000038   0x0050             LSLS     R0,R2,#+1
   \   0000003A   0x85D8             STRH     R0,[R3, #+46]
   \   0000003C   0xE001             B.N      ??HAL_I2S_Receive_IT_6
    748              }  
    749              else
    750              {
    751                hi2s->RxXferSize = Size;
   \                     ??HAL_I2S_Receive_IT_5: (+1)
   \   0000003E   0x859A             STRH     R2,[R3, #+44]
    752                hi2s->RxXferCount = Size;
   \   00000040   0x85DA             STRH     R2,[R3, #+46]
    753              }
    754              /* Process Locked */
    755              __HAL_LOCK(hi2s);
   \                     ??HAL_I2S_Receive_IT_6: (+1)
   \   00000042   0xF893 0x0038      LDRB     R0,[R3, #+56]
   \   00000046   0x2801             CMP      R0,#+1
   \   00000048   0xD101             BNE.N    ??HAL_I2S_Receive_IT_7
   \   0000004A   0x2002             MOVS     R0,#+2
   \   0000004C   0xE01D             B.N      ??HAL_I2S_Receive_IT_3
   \                     ??HAL_I2S_Receive_IT_7: (+1)
   \   0000004E   0x2001             MOVS     R0,#+1
   \   00000050   0xF883 0x0038      STRB     R0,[R3, #+56]
    756              
    757              hi2s->ErrorCode = HAL_I2S_ERROR_NONE;
   \   00000054   0x2000             MOVS     R0,#+0
   \   00000056   0x63D8             STR      R0,[R3, #+60]
    758              hi2s->State = HAL_I2S_STATE_BUSY_RX;
   \   00000058   0x2004             MOVS     R0,#+4
   \   0000005A   0xF883 0x0039      STRB     R0,[R3, #+57]
    759          
    760              /* Enable TXE and ERR interrupt */
    761              __HAL_I2S_ENABLE_IT(hi2s, (I2S_IT_RXNE | I2S_IT_ERR));
   \   0000005E   0x6818             LDR      R0,[R3, #+0]
   \   00000060   0x6840             LDR      R0,[R0, #+4]
   \   00000062   0xF050 0x0060      ORRS     R0,R0,#0x60
   \   00000066   0x681C             LDR      R4,[R3, #+0]
   \   00000068   0x6060             STR      R0,[R4, #+4]
    762              
    763              /* Check if the I2S is already enabled */ 
    764              if((hi2s->Instance->I2SCFGR &SPI_I2SCFGR_I2SE) != SPI_I2SCFGR_I2SE)
   \   0000006A   0x6818             LDR      R0,[R3, #+0]
   \   0000006C   0x69C0             LDR      R0,[R0, #+28]
   \   0000006E   0x0540             LSLS     R0,R0,#+21
   \   00000070   0xD405             BMI.N    ??HAL_I2S_Receive_IT_8
    765              {
    766                /* Enable I2S peripheral */    
    767                __HAL_I2S_ENABLE(hi2s);
   \   00000072   0x6818             LDR      R0,[R3, #+0]
   \   00000074   0x69C0             LDR      R0,[R0, #+28]
   \   00000076   0xF450 0x6080      ORRS     R0,R0,#0x400
   \   0000007A   0x681C             LDR      R4,[R3, #+0]
   \   0000007C   0x61E0             STR      R0,[R4, #+28]
    768              }
    769              
    770              /* Process Unlocked */
    771              __HAL_UNLOCK(hi2s);
   \                     ??HAL_I2S_Receive_IT_8: (+1)
   \   0000007E   0x2000             MOVS     R0,#+0
   \   00000080   0xF883 0x0038      STRB     R0,[R3, #+56]
    772              
    773              return HAL_OK;
   \   00000084   0x2000             MOVS     R0,#+0
   \   00000086   0xE000             B.N      ??HAL_I2S_Receive_IT_3
    774            }
    775            else
    776            {
    777              return HAL_BUSY; 
   \                     ??HAL_I2S_Receive_IT_0: (+1)
   \   00000088   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2S_Receive_IT_3: (+1)
   \   0000008A   0xBC10             POP      {R4}
   \   0000008C   0x4770             BX       LR               ;; return
    778            } 
    779          }
    780          
    781          /**
    782            * @brief Transmit an amount of data in non-blocking mode with DMA
    783            * @param  hi2s: pointer to a I2S_HandleTypeDef structure that contains
    784            *         the configuration information for I2S module
    785            * @param pData: a 16-bit pointer to the Transmit data buffer.
    786            * @param Size: number of data sample to be sent:
    787            * @note When a 16-bit data frame or a 16-bit data frame extended is selected during the I2S
    788            *       configuration phase, the Size parameter means the number of 16-bit data length 
    789            *       in the transaction and when a 24-bit data frame or a 32-bit data frame is selected 
    790            *       the Size parameter means the number of 16-bit data length. 
    791            * @note The I2S is kept enabled at the end of transaction to avoid the clock de-synchronization 
    792            *       between Master and Slave(example: audio streaming).
    793            * @retval HAL status
    794            */

   \                                 In section .text, align 2, keep-with-next
    795          HAL_StatusTypeDef HAL_I2S_Transmit_DMA(I2S_HandleTypeDef *hi2s, uint16_t *pData, uint16_t Size)
    796          {
   \                     HAL_I2S_Transmit_DMA: (+1)
   \   00000000   0xB573             PUSH     {R0,R1,R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x0015             MOVS     R5,R2
    797            uint32_t *tmp;
    798            
    799            if((pData == NULL) || (Size == 0)) 
   \   00000006   0x9801             LDR      R0,[SP, #+4]
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD002             BEQ.N    ??HAL_I2S_Transmit_DMA_0
   \   0000000C   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000000E   0x2D00             CMP      R5,#+0
   \   00000010   0xD101             BNE.N    ??HAL_I2S_Transmit_DMA_1
    800            {
    801              return  HAL_ERROR;                                    
   \                     ??HAL_I2S_Transmit_DMA_0: (+1)
   \   00000012   0x2001             MOVS     R0,#+1
   \   00000014   0xE052             B.N      ??HAL_I2S_Transmit_DMA_2
    802            }
    803            
    804            if(hi2s->State == HAL_I2S_STATE_READY)
   \                     ??HAL_I2S_Transmit_DMA_1: (+1)
   \   00000016   0xF894 0x0039      LDRB     R0,[R4, #+57]
   \   0000001A   0x2801             CMP      R0,#+1
   \   0000001C   0xD14D             BNE.N    ??HAL_I2S_Transmit_DMA_3
    805            {  
    806              hi2s->pTxBuffPtr = pData;
   \   0000001E   0x9801             LDR      R0,[SP, #+4]
   \   00000020   0x6220             STR      R0,[R4, #+32]
    807              if(((hi2s->Instance->I2SCFGR & (SPI_I2SCFGR_DATLEN | SPI_I2SCFGR_CHLEN)) == I2S_DATAFORMAT_24B)||\
    808                ((hi2s->Instance->I2SCFGR & (SPI_I2SCFGR_DATLEN | SPI_I2SCFGR_CHLEN)) == I2S_DATAFORMAT_32B))
   \   00000022   0x6820             LDR      R0,[R4, #+0]
   \   00000024   0x69C0             LDR      R0,[R0, #+28]
   \   00000026   0xF010 0x0007      ANDS     R0,R0,#0x7
   \   0000002A   0x2803             CMP      R0,#+3
   \   0000002C   0xD005             BEQ.N    ??HAL_I2S_Transmit_DMA_4
   \   0000002E   0x6820             LDR      R0,[R4, #+0]
   \   00000030   0x69C0             LDR      R0,[R0, #+28]
   \   00000032   0xF010 0x0007      ANDS     R0,R0,#0x7
   \   00000036   0x2805             CMP      R0,#+5
   \   00000038   0xD104             BNE.N    ??HAL_I2S_Transmit_DMA_5
    809              {
    810                hi2s->TxXferSize = (Size << 1);
   \                     ??HAL_I2S_Transmit_DMA_4: (+1)
   \   0000003A   0x0068             LSLS     R0,R5,#+1
   \   0000003C   0x84A0             STRH     R0,[R4, #+36]
    811                hi2s->TxXferCount = (Size << 1);
   \   0000003E   0x0068             LSLS     R0,R5,#+1
   \   00000040   0x84E0             STRH     R0,[R4, #+38]
   \   00000042   0xE001             B.N      ??HAL_I2S_Transmit_DMA_6
    812              }  
    813              else
    814              {
    815                hi2s->TxXferSize = Size;
   \                     ??HAL_I2S_Transmit_DMA_5: (+1)
   \   00000044   0x84A5             STRH     R5,[R4, #+36]
    816                hi2s->TxXferCount = Size;
   \   00000046   0x84E5             STRH     R5,[R4, #+38]
    817              }  
    818              
    819              /* Process Locked */
    820              __HAL_LOCK(hi2s);
   \                     ??HAL_I2S_Transmit_DMA_6: (+1)
   \   00000048   0xF894 0x0038      LDRB     R0,[R4, #+56]
   \   0000004C   0x2801             CMP      R0,#+1
   \   0000004E   0xD101             BNE.N    ??HAL_I2S_Transmit_DMA_7
   \   00000050   0x2002             MOVS     R0,#+2
   \   00000052   0xE033             B.N      ??HAL_I2S_Transmit_DMA_2
   \                     ??HAL_I2S_Transmit_DMA_7: (+1)
   \   00000054   0x2001             MOVS     R0,#+1
   \   00000056   0xF884 0x0038      STRB     R0,[R4, #+56]
    821              
    822              hi2s->ErrorCode = HAL_I2S_ERROR_NONE;
   \   0000005A   0x2000             MOVS     R0,#+0
   \   0000005C   0x63E0             STR      R0,[R4, #+60]
    823              hi2s->State = HAL_I2S_STATE_BUSY_TX;
   \   0000005E   0x2003             MOVS     R0,#+3
   \   00000060   0xF884 0x0039      STRB     R0,[R4, #+57]
    824          
    825              /* Set the I2S Tx DMA Half transfer complete callback */
    826              hi2s->hdmatx->XferHalfCpltCallback = I2S_DMATxHalfCplt;
   \   00000064   0x.... 0x....      ADR.W    R0,I2S_DMATxHalfCplt
   \   00000068   0x6B21             LDR      R1,[R4, #+48]
   \   0000006A   0x6408             STR      R0,[R1, #+64]
    827          
    828              /* Set the I2S TxDMA transfer complete callback */
    829              hi2s->hdmatx->XferCpltCallback = I2S_DMATxCplt;
   \   0000006C   0x.... 0x....      ADR.W    R0,I2S_DMATxCplt
   \   00000070   0x6B21             LDR      R1,[R4, #+48]
   \   00000072   0x63C8             STR      R0,[R1, #+60]
    830              
    831              /* Set the DMA error callback */
    832              hi2s->hdmatx->XferErrorCallback = I2S_DMAError;
   \   00000074   0x.... 0x....      ADR.W    R0,I2S_DMAError
   \   00000078   0x6B21             LDR      R1,[R4, #+48]
   \   0000007A   0x6488             STR      R0,[R1, #+72]
    833              
    834              /* Enable the Tx DMA Channel */
    835              tmp = (uint32_t*)&pData;
   \   0000007C   0xA801             ADD      R0,SP,#+4
   \   0000007E   0x0006             MOVS     R6,R0
    836              HAL_DMA_Start_IT(hi2s->hdmatx, *(uint32_t*)tmp, (uint32_t)&hi2s->Instance->DR, hi2s->TxXferSize);
   \   00000080   0x8CA3             LDRH     R3,[R4, #+36]
   \   00000082   0x6820             LDR      R0,[R4, #+0]
   \   00000084   0xF110 0x020C      ADDS     R2,R0,#+12
   \   00000088   0x6831             LDR      R1,[R6, #+0]
   \   0000008A   0x6B20             LDR      R0,[R4, #+48]
   \   0000008C   0x.... 0x....      BL       HAL_DMA_Start_IT
    837              
    838              /* Check if the I2S is already enabled */ 
    839              if((hi2s->Instance->I2SCFGR &SPI_I2SCFGR_I2SE) != SPI_I2SCFGR_I2SE)
   \   00000090   0x6820             LDR      R0,[R4, #+0]
   \   00000092   0x69C0             LDR      R0,[R0, #+28]
   \   00000094   0x0540             LSLS     R0,R0,#+21
   \   00000096   0xD405             BMI.N    ??HAL_I2S_Transmit_DMA_8
    840              {
    841                /* Enable I2S peripheral */    
    842                __HAL_I2S_ENABLE(hi2s);
   \   00000098   0x6820             LDR      R0,[R4, #+0]
   \   0000009A   0x69C0             LDR      R0,[R0, #+28]
   \   0000009C   0xF450 0x6080      ORRS     R0,R0,#0x400
   \   000000A0   0x6821             LDR      R1,[R4, #+0]
   \   000000A2   0x61C8             STR      R0,[R1, #+28]
    843              }
    844              
    845              /* Enable Tx DMA Request */  
    846              hi2s->Instance->CR2 |= SPI_CR2_TXDMAEN;
   \                     ??HAL_I2S_Transmit_DMA_8: (+1)
   \   000000A4   0x6820             LDR      R0,[R4, #+0]
   \   000000A6   0x6840             LDR      R0,[R0, #+4]
   \   000000A8   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   000000AC   0x6821             LDR      R1,[R4, #+0]
   \   000000AE   0x6048             STR      R0,[R1, #+4]
    847          
    848              /* Process Unlocked */
    849              __HAL_UNLOCK(hi2s);
   \   000000B0   0x2000             MOVS     R0,#+0
   \   000000B2   0xF884 0x0038      STRB     R0,[R4, #+56]
    850              
    851              return HAL_OK;
   \   000000B6   0x2000             MOVS     R0,#+0
   \   000000B8   0xE000             B.N      ??HAL_I2S_Transmit_DMA_2
    852            }
    853            else
    854            {
    855              return HAL_BUSY;
   \                     ??HAL_I2S_Transmit_DMA_3: (+1)
   \   000000BA   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2S_Transmit_DMA_2: (+1)
   \   000000BC   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
    856            }
    857          }
    858          
    859          /**
    860            * @brief Receive an amount of data in non-blocking mode with DMA 
    861            * @param  hi2s: pointer to a I2S_HandleTypeDef structure that contains
    862            *         the configuration information for I2S module
    863            * @param pData: a 16-bit pointer to the Receive data buffer.
    864            * @param Size: number of data sample to be sent:
    865            * @note When a 16-bit data frame or a 16-bit data frame extended is selected during the I2S
    866            *       configuration phase, the Size parameter means the number of 16-bit data length 
    867            *       in the transaction and when a 24-bit data frame or a 32-bit data frame is selected 
    868            *       the Size parameter means the number of 16-bit data length. 
    869            * @note The I2S is kept enabled at the end of transaction to avoid the clock de-synchronization 
    870            *       between Master and Slave(example: audio streaming).
    871            * @retval HAL status
    872            */

   \                                 In section .text, align 2, keep-with-next
    873          HAL_StatusTypeDef HAL_I2S_Receive_DMA(I2S_HandleTypeDef *hi2s, uint16_t *pData, uint16_t Size)
    874          {
   \                     HAL_I2S_Receive_DMA: (+1)
   \   00000000   0xB573             PUSH     {R0,R1,R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x0015             MOVS     R5,R2
    875            uint32_t *tmp;
    876            
    877            if((pData == NULL) || (Size == 0)) 
   \   00000006   0x9801             LDR      R0,[SP, #+4]
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD002             BEQ.N    ??HAL_I2S_Receive_DMA_0
   \   0000000C   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000000E   0x2D00             CMP      R5,#+0
   \   00000010   0xD101             BNE.N    ??HAL_I2S_Receive_DMA_1
    878            {
    879              return  HAL_ERROR;                                    
   \                     ??HAL_I2S_Receive_DMA_0: (+1)
   \   00000012   0x2001             MOVS     R0,#+1
   \   00000014   0xE060             B.N      ??HAL_I2S_Receive_DMA_2
    880            } 
    881              
    882            if(hi2s->State == HAL_I2S_STATE_READY)
   \                     ??HAL_I2S_Receive_DMA_1: (+1)
   \   00000016   0xF894 0x0039      LDRB     R0,[R4, #+57]
   \   0000001A   0x2801             CMP      R0,#+1
   \   0000001C   0xD15B             BNE.N    ??HAL_I2S_Receive_DMA_3
    883            {    
    884              hi2s->pRxBuffPtr = pData;
   \   0000001E   0x9801             LDR      R0,[SP, #+4]
   \   00000020   0x62A0             STR      R0,[R4, #+40]
    885              if(((hi2s->Instance->I2SCFGR & (SPI_I2SCFGR_DATLEN | SPI_I2SCFGR_CHLEN)) == I2S_DATAFORMAT_24B)||\
    886                ((hi2s->Instance->I2SCFGR & (SPI_I2SCFGR_DATLEN | SPI_I2SCFGR_CHLEN)) == I2S_DATAFORMAT_32B))
   \   00000022   0x6820             LDR      R0,[R4, #+0]
   \   00000024   0x69C0             LDR      R0,[R0, #+28]
   \   00000026   0xF010 0x0007      ANDS     R0,R0,#0x7
   \   0000002A   0x2803             CMP      R0,#+3
   \   0000002C   0xD005             BEQ.N    ??HAL_I2S_Receive_DMA_4
   \   0000002E   0x6820             LDR      R0,[R4, #+0]
   \   00000030   0x69C0             LDR      R0,[R0, #+28]
   \   00000032   0xF010 0x0007      ANDS     R0,R0,#0x7
   \   00000036   0x2805             CMP      R0,#+5
   \   00000038   0xD104             BNE.N    ??HAL_I2S_Receive_DMA_5
    887              {
    888                hi2s->RxXferSize = (Size << 1);
   \                     ??HAL_I2S_Receive_DMA_4: (+1)
   \   0000003A   0x0068             LSLS     R0,R5,#+1
   \   0000003C   0x85A0             STRH     R0,[R4, #+44]
    889                hi2s->RxXferCount = (Size << 1);
   \   0000003E   0x0068             LSLS     R0,R5,#+1
   \   00000040   0x85E0             STRH     R0,[R4, #+46]
   \   00000042   0xE001             B.N      ??HAL_I2S_Receive_DMA_6
    890              }  
    891              else
    892              {
    893                hi2s->RxXferSize = Size;
   \                     ??HAL_I2S_Receive_DMA_5: (+1)
   \   00000044   0x85A5             STRH     R5,[R4, #+44]
    894                hi2s->RxXferCount = Size;
   \   00000046   0x85E5             STRH     R5,[R4, #+46]
    895              }
    896              /* Process Locked */
    897              __HAL_LOCK(hi2s);
   \                     ??HAL_I2S_Receive_DMA_6: (+1)
   \   00000048   0xF894 0x0038      LDRB     R0,[R4, #+56]
   \   0000004C   0x2801             CMP      R0,#+1
   \   0000004E   0xD101             BNE.N    ??HAL_I2S_Receive_DMA_7
   \   00000050   0x2002             MOVS     R0,#+2
   \   00000052   0xE041             B.N      ??HAL_I2S_Receive_DMA_2
   \                     ??HAL_I2S_Receive_DMA_7: (+1)
   \   00000054   0x2001             MOVS     R0,#+1
   \   00000056   0xF884 0x0038      STRB     R0,[R4, #+56]
    898              
    899              hi2s->ErrorCode = HAL_I2S_ERROR_NONE;
   \   0000005A   0x2000             MOVS     R0,#+0
   \   0000005C   0x63E0             STR      R0,[R4, #+60]
    900              hi2s->State = HAL_I2S_STATE_BUSY_RX;
   \   0000005E   0x2004             MOVS     R0,#+4
   \   00000060   0xF884 0x0039      STRB     R0,[R4, #+57]
    901             
    902              /* Set the I2S Rx DMA Half transfer complete callback */
    903              hi2s->hdmarx->XferHalfCpltCallback = I2S_DMARxHalfCplt;
   \   00000064   0x.... 0x....      ADR.W    R0,I2S_DMARxHalfCplt
   \   00000068   0x6B61             LDR      R1,[R4, #+52]
   \   0000006A   0x6408             STR      R0,[R1, #+64]
    904          
    905              /* Set the I2S Rx DMA transfer complete callback */
    906              hi2s->hdmarx->XferCpltCallback = I2S_DMARxCplt;
   \   0000006C   0x.... 0x....      ADR.W    R0,I2S_DMARxCplt
   \   00000070   0x6B61             LDR      R1,[R4, #+52]
   \   00000072   0x63C8             STR      R0,[R1, #+60]
    907              
    908              /* Set the DMA error callback */
    909              hi2s->hdmarx->XferErrorCallback = I2S_DMAError;
   \   00000074   0x.... 0x....      ADR.W    R0,I2S_DMAError
   \   00000078   0x6B61             LDR      R1,[R4, #+52]
   \   0000007A   0x6488             STR      R0,[R1, #+72]
    910              
    911              /* Check if Master Receiver mode is selected */
    912              if((hi2s->Instance->I2SCFGR & SPI_I2SCFGR_I2SCFG) == I2S_MODE_MASTER_RX)
   \   0000007C   0x6820             LDR      R0,[R4, #+0]
   \   0000007E   0x69C0             LDR      R0,[R0, #+28]
   \   00000080   0xF410 0x7040      ANDS     R0,R0,#0x300
   \   00000084   0xF5B0 0x7F40      CMP      R0,#+768
   \   00000088   0xD106             BNE.N    ??HAL_I2S_Receive_DMA_8
    913              {
    914                /* Clear the Overrun Flag by a read operation to the SPI_DR register followed by a read
    915                access to the SPI_SR register. */ 
    916                __HAL_I2S_CLEAR_OVRFLAG(hi2s);        
   \   0000008A   0x6820             LDR      R0,[R4, #+0]
   \   0000008C   0x68C0             LDR      R0,[R0, #+12]
   \   0000008E   0x9000             STR      R0,[SP, #+0]
   \   00000090   0x6820             LDR      R0,[R4, #+0]
   \   00000092   0x6880             LDR      R0,[R0, #+8]
   \   00000094   0x9000             STR      R0,[SP, #+0]
   \   00000096   0x9800             LDR      R0,[SP, #+0]
    917              }
    918              
    919              /* Enable the Rx DMA Channel */
    920              tmp = (uint32_t*)&pData;        
   \                     ??HAL_I2S_Receive_DMA_8: (+1)
   \   00000098   0xA801             ADD      R0,SP,#+4
   \   0000009A   0x0006             MOVS     R6,R0
    921              HAL_DMA_Start_IT(hi2s->hdmarx, (uint32_t)&hi2s->Instance->DR, *(uint32_t*)tmp, hi2s->RxXferSize);
   \   0000009C   0x8DA3             LDRH     R3,[R4, #+44]
   \   0000009E   0x6832             LDR      R2,[R6, #+0]
   \   000000A0   0x6820             LDR      R0,[R4, #+0]
   \   000000A2   0xF110 0x010C      ADDS     R1,R0,#+12
   \   000000A6   0x6B60             LDR      R0,[R4, #+52]
   \   000000A8   0x.... 0x....      BL       HAL_DMA_Start_IT
    922              
    923              /* Check if the I2S is already enabled */ 
    924              if((hi2s->Instance->I2SCFGR &SPI_I2SCFGR_I2SE) != SPI_I2SCFGR_I2SE)
   \   000000AC   0x6820             LDR      R0,[R4, #+0]
   \   000000AE   0x69C0             LDR      R0,[R0, #+28]
   \   000000B0   0x0540             LSLS     R0,R0,#+21
   \   000000B2   0xD405             BMI.N    ??HAL_I2S_Receive_DMA_9
    925              {
    926                /* Enable I2S peripheral */    
    927                __HAL_I2S_ENABLE(hi2s);
   \   000000B4   0x6820             LDR      R0,[R4, #+0]
   \   000000B6   0x69C0             LDR      R0,[R0, #+28]
   \   000000B8   0xF450 0x6080      ORRS     R0,R0,#0x400
   \   000000BC   0x6821             LDR      R1,[R4, #+0]
   \   000000BE   0x61C8             STR      R0,[R1, #+28]
    928              }
    929              
    930              /* Enable Rx DMA Request */  
    931              hi2s->Instance->CR2 |= SPI_CR2_RXDMAEN;
   \                     ??HAL_I2S_Receive_DMA_9: (+1)
   \   000000C0   0x6820             LDR      R0,[R4, #+0]
   \   000000C2   0x6840             LDR      R0,[R0, #+4]
   \   000000C4   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   000000C8   0x6821             LDR      R1,[R4, #+0]
   \   000000CA   0x6048             STR      R0,[R1, #+4]
    932              
    933              /* Process Unlocked */
    934              __HAL_UNLOCK(hi2s);
   \   000000CC   0x2000             MOVS     R0,#+0
   \   000000CE   0xF884 0x0038      STRB     R0,[R4, #+56]
    935          
    936              return HAL_OK;
   \   000000D2   0x2000             MOVS     R0,#+0
   \   000000D4   0xE000             B.N      ??HAL_I2S_Receive_DMA_2
    937            }
    938            else
    939            {
    940              return HAL_BUSY;
   \                     ??HAL_I2S_Receive_DMA_3: (+1)
   \   000000D6   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2S_Receive_DMA_2: (+1)
   \   000000D8   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
    941            }
    942          }
    943          
    944          /**
    945            * @brief Pauses the audio stream playing from the Media.
    946            * @param  hi2s: pointer to a I2S_HandleTypeDef structure that contains
    947            *         the configuration information for I2S module
    948            * @retval HAL status
    949            */

   \                                 In section .text, align 2, keep-with-next
    950          HAL_StatusTypeDef HAL_I2S_DMAPause(I2S_HandleTypeDef *hi2s)
    951          {
   \                     HAL_I2S_DMAPause: (+1)
   \   00000000   0x0001             MOVS     R1,R0
    952            /* Process Locked */
    953            __HAL_LOCK(hi2s);
   \   00000002   0xF891 0x0038      LDRB     R0,[R1, #+56]
   \   00000006   0x2801             CMP      R0,#+1
   \   00000008   0xD101             BNE.N    ??HAL_I2S_DMAPause_0
   \   0000000A   0x2002             MOVS     R0,#+2
   \   0000000C   0xE034             B.N      ??HAL_I2S_DMAPause_1
   \                     ??HAL_I2S_DMAPause_0: (+1)
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0xF881 0x0038      STRB     R0,[R1, #+56]
    954          
    955            if(hi2s->State == HAL_I2S_STATE_BUSY_TX)
   \   00000014   0xF891 0x0039      LDRB     R0,[R1, #+57]
   \   00000018   0x2803             CMP      R0,#+3
   \   0000001A   0xD106             BNE.N    ??HAL_I2S_DMAPause_2
    956            {
    957              /* Disable the I2S DMA Tx request */
    958              hi2s->Instance->CR2 &= (uint32_t)(~SPI_CR2_TXDMAEN);
   \   0000001C   0x6808             LDR      R0,[R1, #+0]
   \   0000001E   0x6840             LDR      R0,[R0, #+4]
   \   00000020   0xF030 0x0002      BICS     R0,R0,#0x2
   \   00000024   0x680A             LDR      R2,[R1, #+0]
   \   00000026   0x6050             STR      R0,[R2, #+4]
   \   00000028   0xE022             B.N      ??HAL_I2S_DMAPause_3
    959            }
    960            else if(hi2s->State == HAL_I2S_STATE_BUSY_RX)
   \                     ??HAL_I2S_DMAPause_2: (+1)
   \   0000002A   0xF891 0x0039      LDRB     R0,[R1, #+57]
   \   0000002E   0x2804             CMP      R0,#+4
   \   00000030   0xD106             BNE.N    ??HAL_I2S_DMAPause_4
    961            {
    962              /* Disable the I2S DMA Rx request */
    963              hi2s->Instance->CR2 &= (uint32_t)(~SPI_CR2_RXDMAEN);
   \   00000032   0x6808             LDR      R0,[R1, #+0]
   \   00000034   0x6840             LDR      R0,[R0, #+4]
   \   00000036   0x0840             LSRS     R0,R0,#+1
   \   00000038   0x0040             LSLS     R0,R0,#+1
   \   0000003A   0x680A             LDR      R2,[R1, #+0]
   \   0000003C   0x6050             STR      R0,[R2, #+4]
   \   0000003E   0xE017             B.N      ??HAL_I2S_DMAPause_3
    964            }
    965            else if(hi2s->State == HAL_I2S_STATE_BUSY_TX_RX)
   \                     ??HAL_I2S_DMAPause_4: (+1)
   \   00000040   0xF891 0x0039      LDRB     R0,[R1, #+57]
   \   00000044   0x2805             CMP      R0,#+5
   \   00000046   0xD113             BNE.N    ??HAL_I2S_DMAPause_3
    966            {
    967              if((hi2s->Init.Mode == I2S_MODE_SLAVE_TX)||(hi2s->Init.Mode == I2S_MODE_MASTER_TX))
   \   00000048   0x6848             LDR      R0,[R1, #+4]
   \   0000004A   0x2800             CMP      R0,#+0
   \   0000004C   0xD003             BEQ.N    ??HAL_I2S_DMAPause_5
   \   0000004E   0x6848             LDR      R0,[R1, #+4]
   \   00000050   0xF5B0 0x7F00      CMP      R0,#+512
   \   00000054   0xD106             BNE.N    ??HAL_I2S_DMAPause_6
    968              {
    969                /* Disable the I2S DMA Tx request */
    970                hi2s->Instance->CR2 &= (uint32_t)(~SPI_CR2_TXDMAEN);
   \                     ??HAL_I2S_DMAPause_5: (+1)
   \   00000056   0x6808             LDR      R0,[R1, #+0]
   \   00000058   0x6840             LDR      R0,[R0, #+4]
   \   0000005A   0xF030 0x0002      BICS     R0,R0,#0x2
   \   0000005E   0x680A             LDR      R2,[R1, #+0]
   \   00000060   0x6050             STR      R0,[R2, #+4]
   \   00000062   0xE005             B.N      ??HAL_I2S_DMAPause_3
    971              }
    972              else
    973              {
    974                /* Disable the I2S DMA Rx request */
    975                hi2s->Instance->CR2 &= (uint32_t)(~SPI_CR2_RXDMAEN);
   \                     ??HAL_I2S_DMAPause_6: (+1)
   \   00000064   0x6808             LDR      R0,[R1, #+0]
   \   00000066   0x6840             LDR      R0,[R0, #+4]
   \   00000068   0x0840             LSRS     R0,R0,#+1
   \   0000006A   0x0040             LSLS     R0,R0,#+1
   \   0000006C   0x680A             LDR      R2,[R1, #+0]
   \   0000006E   0x6050             STR      R0,[R2, #+4]
    976              }
    977            }
    978          
    979            /* Process Unlocked */
    980            __HAL_UNLOCK(hi2s);
   \                     ??HAL_I2S_DMAPause_3: (+1)
   \   00000070   0x2000             MOVS     R0,#+0
   \   00000072   0xF881 0x0038      STRB     R0,[R1, #+56]
    981            
    982            return HAL_OK; 
   \   00000076   0x2000             MOVS     R0,#+0
   \                     ??HAL_I2S_DMAPause_1: (+1)
   \   00000078   0x4770             BX       LR               ;; return
    983          }
    984          
    985          /**
    986            * @brief Resumes the audio stream playing from the Media.
    987            * @param  hi2s: pointer to a I2S_HandleTypeDef structure that contains
    988            *         the configuration information for I2S module
    989            * @retval HAL status
    990            */

   \                                 In section .text, align 2, keep-with-next
    991          HAL_StatusTypeDef HAL_I2S_DMAResume(I2S_HandleTypeDef *hi2s)
    992          {
   \                     HAL_I2S_DMAResume: (+1)
   \   00000000   0x0001             MOVS     R1,R0
    993            /* Process Locked */
    994            __HAL_LOCK(hi2s);
   \   00000002   0xF891 0x0038      LDRB     R0,[R1, #+56]
   \   00000006   0x2801             CMP      R0,#+1
   \   00000008   0xD101             BNE.N    ??HAL_I2S_DMAResume_0
   \   0000000A   0x2002             MOVS     R0,#+2
   \   0000000C   0xE025             B.N      ??HAL_I2S_DMAResume_1
   \                     ??HAL_I2S_DMAResume_0: (+1)
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0xF881 0x0038      STRB     R0,[R1, #+56]
    995            
    996            if(hi2s->State == HAL_I2S_STATE_BUSY_TX)
   \   00000014   0xF891 0x0039      LDRB     R0,[R1, #+57]
   \   00000018   0x2803             CMP      R0,#+3
   \   0000001A   0xD106             BNE.N    ??HAL_I2S_DMAResume_2
    997            {
    998              /* Enable the I2S DMA Tx request */
    999              SET_BIT(hi2s->Instance->CR2, SPI_CR2_TXDMAEN);
   \   0000001C   0x6808             LDR      R0,[R1, #+0]
   \   0000001E   0x6840             LDR      R0,[R0, #+4]
   \   00000020   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   00000024   0x680A             LDR      R2,[R1, #+0]
   \   00000026   0x6050             STR      R0,[R2, #+4]
   \   00000028   0xE009             B.N      ??HAL_I2S_DMAResume_3
   1000            }
   1001            else if(hi2s->State == HAL_I2S_STATE_BUSY_RX)
   \                     ??HAL_I2S_DMAResume_2: (+1)
   \   0000002A   0xF891 0x0039      LDRB     R0,[R1, #+57]
   \   0000002E   0x2804             CMP      R0,#+4
   \   00000030   0xD105             BNE.N    ??HAL_I2S_DMAResume_3
   1002            {
   1003              /* Enable the I2S DMA Rx request */
   1004              SET_BIT(hi2s->Instance->CR2, SPI_CR2_RXDMAEN);
   \   00000032   0x6808             LDR      R0,[R1, #+0]
   \   00000034   0x6840             LDR      R0,[R0, #+4]
   \   00000036   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   0000003A   0x680A             LDR      R2,[R1, #+0]
   \   0000003C   0x6050             STR      R0,[R2, #+4]
   1005            }
   1006            
   1007            /* If the I2S peripheral is still not enabled, enable it */
   1008            if(HAL_IS_BIT_CLR(hi2s->Instance->I2SCFGR, SPI_I2SCFGR_I2SE))
   \                     ??HAL_I2S_DMAResume_3: (+1)
   \   0000003E   0x6808             LDR      R0,[R1, #+0]
   \   00000040   0x69C0             LDR      R0,[R0, #+28]
   \   00000042   0x0540             LSLS     R0,R0,#+21
   \   00000044   0xD405             BMI.N    ??HAL_I2S_DMAResume_4
   1009            {
   1010              /* Enable I2S peripheral */    
   1011              __HAL_I2S_ENABLE(hi2s);
   \   00000046   0x6808             LDR      R0,[R1, #+0]
   \   00000048   0x69C0             LDR      R0,[R0, #+28]
   \   0000004A   0xF450 0x6080      ORRS     R0,R0,#0x400
   \   0000004E   0x680A             LDR      R2,[R1, #+0]
   \   00000050   0x61D0             STR      R0,[R2, #+28]
   1012            }
   1013            
   1014            /* Process Unlocked */
   1015            __HAL_UNLOCK(hi2s);
   \                     ??HAL_I2S_DMAResume_4: (+1)
   \   00000052   0x2000             MOVS     R0,#+0
   \   00000054   0xF881 0x0038      STRB     R0,[R1, #+56]
   1016            
   1017            return HAL_OK;
   \   00000058   0x2000             MOVS     R0,#+0
   \                     ??HAL_I2S_DMAResume_1: (+1)
   \   0000005A   0x4770             BX       LR               ;; return
   1018          }
   1019          
   1020          /**
   1021            * @brief Stops the audio stream playing from the Media.
   1022            * @param  hi2s: pointer to a I2S_HandleTypeDef structure that contains
   1023            *         the configuration information for I2S module
   1024            * @retval HAL status
   1025            */

   \                                 In section .text, align 2, keep-with-next
   1026          HAL_StatusTypeDef HAL_I2S_DMAStop(I2S_HandleTypeDef *hi2s)
   1027          {
   \                     HAL_I2S_DMAStop: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1028            /* Process Locked */
   1029            __HAL_LOCK(hi2s);
   \   00000004   0xF894 0x0038      LDRB     R0,[R4, #+56]
   \   00000008   0x2801             CMP      R0,#+1
   \   0000000A   0xD101             BNE.N    ??HAL_I2S_DMAStop_0
   \   0000000C   0x2002             MOVS     R0,#+2
   \   0000000E   0xE037             B.N      ??HAL_I2S_DMAStop_1
   \                     ??HAL_I2S_DMAStop_0: (+1)
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0xF884 0x0038      STRB     R0,[R4, #+56]
   1030            
   1031            /* Disable the I2S Tx/Rx DMA requests */
   1032            CLEAR_BIT(hi2s->Instance->CR2, SPI_CR2_TXDMAEN);
   \   00000016   0x6820             LDR      R0,[R4, #+0]
   \   00000018   0x6840             LDR      R0,[R0, #+4]
   \   0000001A   0xF030 0x0002      BICS     R0,R0,#0x2
   \   0000001E   0x6821             LDR      R1,[R4, #+0]
   \   00000020   0x6048             STR      R0,[R1, #+4]
   1033            CLEAR_BIT(hi2s->Instance->CR2, SPI_CR2_RXDMAEN);
   \   00000022   0x6820             LDR      R0,[R4, #+0]
   \   00000024   0x6840             LDR      R0,[R0, #+4]
   \   00000026   0x0840             LSRS     R0,R0,#+1
   \   00000028   0x0040             LSLS     R0,R0,#+1
   \   0000002A   0x6821             LDR      R1,[R4, #+0]
   \   0000002C   0x6048             STR      R0,[R1, #+4]
   1034            
   1035            /* Abort the I2S DMA Channel tx */
   1036            if(hi2s->hdmatx != NULL)
   \   0000002E   0x6B20             LDR      R0,[R4, #+48]
   \   00000030   0x2800             CMP      R0,#+0
   \   00000032   0xD00A             BEQ.N    ??HAL_I2S_DMAStop_2
   1037            {
   1038              /* Disable the I2S DMA channel */
   1039              __HAL_DMA_DISABLE(hi2s->hdmatx);
   \   00000034   0x6B20             LDR      R0,[R4, #+48]
   \   00000036   0x6800             LDR      R0,[R0, #+0]
   \   00000038   0x6800             LDR      R0,[R0, #+0]
   \   0000003A   0x0840             LSRS     R0,R0,#+1
   \   0000003C   0x0040             LSLS     R0,R0,#+1
   \   0000003E   0x6B21             LDR      R1,[R4, #+48]
   \   00000040   0x6809             LDR      R1,[R1, #+0]
   \   00000042   0x6008             STR      R0,[R1, #+0]
   1040              HAL_DMA_Abort(hi2s->hdmatx);
   \   00000044   0x6B20             LDR      R0,[R4, #+48]
   \   00000046   0x.... 0x....      BL       HAL_DMA_Abort
   1041            }
   1042            /* Abort the I2S DMA Channel rx */
   1043            if(hi2s->hdmarx != NULL)
   \                     ??HAL_I2S_DMAStop_2: (+1)
   \   0000004A   0x6B60             LDR      R0,[R4, #+52]
   \   0000004C   0x2800             CMP      R0,#+0
   \   0000004E   0xD00A             BEQ.N    ??HAL_I2S_DMAStop_3
   1044            {
   1045              /* Disable the I2S DMA channel */
   1046              __HAL_DMA_DISABLE(hi2s->hdmarx);
   \   00000050   0x6B60             LDR      R0,[R4, #+52]
   \   00000052   0x6800             LDR      R0,[R0, #+0]
   \   00000054   0x6800             LDR      R0,[R0, #+0]
   \   00000056   0x0840             LSRS     R0,R0,#+1
   \   00000058   0x0040             LSLS     R0,R0,#+1
   \   0000005A   0x6B61             LDR      R1,[R4, #+52]
   \   0000005C   0x6809             LDR      R1,[R1, #+0]
   \   0000005E   0x6008             STR      R0,[R1, #+0]
   1047              HAL_DMA_Abort(hi2s->hdmarx);
   \   00000060   0x6B60             LDR      R0,[R4, #+52]
   \   00000062   0x.... 0x....      BL       HAL_DMA_Abort
   1048            }
   1049          
   1050            /* Disable I2S peripheral */
   1051            __HAL_I2S_DISABLE(hi2s);
   \                     ??HAL_I2S_DMAStop_3: (+1)
   \   00000066   0x6820             LDR      R0,[R4, #+0]
   \   00000068   0x69C0             LDR      R0,[R0, #+28]
   \   0000006A   0xF430 0x6080      BICS     R0,R0,#0x400
   \   0000006E   0x6821             LDR      R1,[R4, #+0]
   \   00000070   0x61C8             STR      R0,[R1, #+28]
   1052            
   1053            hi2s->State = HAL_I2S_STATE_READY;
   \   00000072   0x2001             MOVS     R0,#+1
   \   00000074   0xF884 0x0039      STRB     R0,[R4, #+57]
   1054            
   1055            /* Process Unlocked */
   1056            __HAL_UNLOCK(hi2s);
   \   00000078   0x2000             MOVS     R0,#+0
   \   0000007A   0xF884 0x0038      STRB     R0,[R4, #+56]
   1057            
   1058            return HAL_OK;
   \   0000007E   0x2000             MOVS     R0,#+0
   \                     ??HAL_I2S_DMAStop_1: (+1)
   \   00000080   0xBD10             POP      {R4,PC}          ;; return
   1059          }
   1060          
   1061          /**
   1062            * @brief  This function handles I2S interrupt request.
   1063            * @param  hi2s: pointer to a I2S_HandleTypeDef structure that contains
   1064            *         the configuration information for I2S module
   1065            * @retval HAL status
   1066            */

   \                                 In section .text, align 2, keep-with-next
   1067          void HAL_I2S_IRQHandler(I2S_HandleTypeDef *hi2s)
   1068          {  
   \                     HAL_I2S_IRQHandler: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0004             MOVS     R4,R0
   1069            __IO uint32_t i2ssr = hi2s->Instance->SR;
   \   00000006   0x6820             LDR      R0,[R4, #+0]
   \   00000008   0x6880             LDR      R0,[R0, #+8]
   \   0000000A   0x9000             STR      R0,[SP, #+0]
   1070          
   1071            if(hi2s->State == HAL_I2S_STATE_BUSY_RX)
   \   0000000C   0xF894 0x0039      LDRB     R0,[R4, #+57]
   \   00000010   0x2804             CMP      R0,#+4
   \   00000012   0xD121             BNE.N    ??HAL_I2S_IRQHandler_0
   1072            {  
   1073              /* I2S in mode Receiver ----------------------------------------------------*/
   1074              if(((i2ssr & I2S_FLAG_RXNE) == I2S_FLAG_RXNE) && (__HAL_I2S_GET_IT_SOURCE(hi2s, I2S_IT_RXNE) != RESET))
   \   00000014   0x9800             LDR      R0,[SP, #+0]
   \   00000016   0x07C0             LSLS     R0,R0,#+31
   \   00000018   0xD506             BPL.N    ??HAL_I2S_IRQHandler_1
   \   0000001A   0x6820             LDR      R0,[R4, #+0]
   \   0000001C   0x6840             LDR      R0,[R0, #+4]
   \   0000001E   0x0640             LSLS     R0,R0,#+25
   \   00000020   0xD502             BPL.N    ??HAL_I2S_IRQHandler_1
   1075              {
   1076                I2S_Receive_IT(hi2s);
   \   00000022   0x0020             MOVS     R0,R4
   \   00000024   0x.... 0x....      BL       I2S_Receive_IT
   1077              }
   1078          
   1079              /* I2S Overrun error interrupt occurred -------------------------------------*/
   1080              if(((i2ssr & I2S_FLAG_OVR) == I2S_FLAG_OVR) && (__HAL_I2S_GET_IT_SOURCE(hi2s, I2S_IT_ERR) != RESET))
   \                     ??HAL_I2S_IRQHandler_1: (+1)
   \   00000028   0x9800             LDR      R0,[SP, #+0]
   \   0000002A   0x0640             LSLS     R0,R0,#+25
   \   0000002C   0xD539             BPL.N    ??HAL_I2S_IRQHandler_2
   \   0000002E   0x6820             LDR      R0,[R4, #+0]
   \   00000030   0x6840             LDR      R0,[R0, #+4]
   \   00000032   0x0680             LSLS     R0,R0,#+26
   \   00000034   0xD535             BPL.N    ??HAL_I2S_IRQHandler_2
   1081              {
   1082                /* Disable RXNE and ERR interrupt */
   1083                __HAL_I2S_DISABLE_IT(hi2s, (I2S_IT_RXNE | I2S_IT_ERR));
   \   00000036   0x6820             LDR      R0,[R4, #+0]
   \   00000038   0x6840             LDR      R0,[R0, #+4]
   \   0000003A   0xF030 0x0060      BICS     R0,R0,#0x60
   \   0000003E   0x6821             LDR      R1,[R4, #+0]
   \   00000040   0x6048             STR      R0,[R1, #+4]
   1084          
   1085                /* Set the I2S State ready */
   1086                hi2s->State = HAL_I2S_STATE_READY; 
   \   00000042   0x2001             MOVS     R0,#+1
   \   00000044   0xF884 0x0039      STRB     R0,[R4, #+57]
   1087          
   1088                /* Set the error code and execute error callback*/
   1089                hi2s->ErrorCode |= HAL_I2S_ERROR_OVR;
   \   00000048   0x6BE0             LDR      R0,[R4, #+60]
   \   0000004A   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   0000004E   0x63E0             STR      R0,[R4, #+60]
   1090                HAL_I2S_ErrorCallback(hi2s);
   \   00000050   0x0020             MOVS     R0,R4
   \   00000052   0x.... 0x....      BL       HAL_I2S_ErrorCallback
   \   00000056   0xE024             B.N      ??HAL_I2S_IRQHandler_2
   1091              }  
   1092            }
   1093            else if(hi2s->State == HAL_I2S_STATE_BUSY_TX)
   \                     ??HAL_I2S_IRQHandler_0: (+1)
   \   00000058   0xF894 0x0039      LDRB     R0,[R4, #+57]
   \   0000005C   0x2803             CMP      R0,#+3
   \   0000005E   0xD120             BNE.N    ??HAL_I2S_IRQHandler_2
   1094            {  
   1095              /* I2S in mode Transmitter ---------------------------------------------------*/
   1096              if(((i2ssr & I2S_FLAG_TXE) == I2S_FLAG_TXE) && (__HAL_I2S_GET_IT_SOURCE(hi2s, I2S_IT_TXE) != RESET))
   \   00000060   0x9800             LDR      R0,[SP, #+0]
   \   00000062   0x0780             LSLS     R0,R0,#+30
   \   00000064   0xD506             BPL.N    ??HAL_I2S_IRQHandler_3
   \   00000066   0x6820             LDR      R0,[R4, #+0]
   \   00000068   0x6840             LDR      R0,[R0, #+4]
   \   0000006A   0x0600             LSLS     R0,R0,#+24
   \   0000006C   0xD502             BPL.N    ??HAL_I2S_IRQHandler_3
   1097              {     
   1098                I2S_Transmit_IT(hi2s);
   \   0000006E   0x0020             MOVS     R0,R4
   \   00000070   0x.... 0x....      BL       I2S_Transmit_IT
   1099              } 
   1100              
   1101              /* I2S Underrun error interrupt occurred ------------------------------------*/
   1102              if(((i2ssr & I2S_FLAG_UDR) == I2S_FLAG_UDR) && (__HAL_I2S_GET_IT_SOURCE(hi2s, I2S_IT_ERR) != RESET))
   \                     ??HAL_I2S_IRQHandler_3: (+1)
   \   00000074   0x9800             LDR      R0,[SP, #+0]
   \   00000076   0x0700             LSLS     R0,R0,#+28
   \   00000078   0xD513             BPL.N    ??HAL_I2S_IRQHandler_2
   \   0000007A   0x6820             LDR      R0,[R4, #+0]
   \   0000007C   0x6840             LDR      R0,[R0, #+4]
   \   0000007E   0x0680             LSLS     R0,R0,#+26
   \   00000080   0xD50F             BPL.N    ??HAL_I2S_IRQHandler_2
   1103              {
   1104                /* Disable TXE and ERR interrupt */
   1105                __HAL_I2S_DISABLE_IT(hi2s, (I2S_IT_TXE | I2S_IT_ERR));
   \   00000082   0x6820             LDR      R0,[R4, #+0]
   \   00000084   0x6840             LDR      R0,[R0, #+4]
   \   00000086   0xF030 0x00A0      BICS     R0,R0,#0xA0
   \   0000008A   0x6821             LDR      R1,[R4, #+0]
   \   0000008C   0x6048             STR      R0,[R1, #+4]
   1106          
   1107                /* Set the I2S State ready */
   1108                hi2s->State = HAL_I2S_STATE_READY; 
   \   0000008E   0x2001             MOVS     R0,#+1
   \   00000090   0xF884 0x0039      STRB     R0,[R4, #+57]
   1109          
   1110                /* Set the error code and execute error callback*/
   1111                hi2s->ErrorCode |= HAL_I2S_ERROR_UDR;
   \   00000094   0x6BE0             LDR      R0,[R4, #+60]
   \   00000096   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   0000009A   0x63E0             STR      R0,[R4, #+60]
   1112                HAL_I2S_ErrorCallback(hi2s);
   \   0000009C   0x0020             MOVS     R0,R4
   \   0000009E   0x.... 0x....      BL       HAL_I2S_ErrorCallback
   1113              }
   1114            }
   1115          }
   \                     ??HAL_I2S_IRQHandler_2: (+1)
   \   000000A2   0xBD13             POP      {R0,R1,R4,PC}    ;; return
   1116          
   1117          /**
   1118            * @}
   1119            */
   1120          
   1121          /**
   1122            * @}
   1123            */
   1124          
   1125          /** @addtogroup I2S_Private_Functions I2S Private Functions
   1126            * @{
   1127            */
   1128          /**
   1129            * @brief This function handles I2S Communication Timeout.
   1130            * @param  hi2s: pointer to a I2S_HandleTypeDef structure that contains
   1131            *         the configuration information for I2S module
   1132            * @param Flag: Flag checked
   1133            * @param State: Value of the flag expected
   1134            * @param Timeout: Duration of the timeout
   1135            * @retval HAL status
   1136            */

   \                                 In section .text, align 2, keep-with-next
   1137          static HAL_StatusTypeDef I2S_WaitFlagStateUntilTimeout(I2S_HandleTypeDef *hi2s, uint32_t Flag, 
   1138                                                                 uint32_t State, uint32_t Timeout)
   1139          {
   \                     I2S_WaitFlagStateUntilTimeout: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
   1140            uint32_t tickstart = 0;
   \   0000000C   0xF05F 0x0800      MOVS     R8,#+0
   1141            
   1142            /* Get tick */
   1143            tickstart = HAL_GetTick();
   \   00000010   0x.... 0x....      BL       HAL_GetTick
   \   00000014   0x4680             MOV      R8,R0
   1144            
   1145            /* Wait until flag is set */
   1146            if(State == RESET)
   \   00000016   0x2E00             CMP      R6,#+0
   \   00000018   0xD117             BNE.N    ??I2S_WaitFlagStateUntilTimeout_0
   1147            {
   1148              while(__HAL_I2S_GET_FLAG(hi2s, Flag) == RESET)
   \                     ??I2S_WaitFlagStateUntilTimeout_1: (+1)
   \   0000001A   0x6820             LDR      R0,[R4, #+0]
   \   0000001C   0x6880             LDR      R0,[R0, #+8]
   \   0000001E   0x4028             ANDS     R0,R5,R0
   \   00000020   0x42A8             CMP      R0,R5
   \   00000022   0xD02A             BEQ.N    ??I2S_WaitFlagStateUntilTimeout_2
   1149              {
   1150                if(Timeout != HAL_MAX_DELAY)
   \   00000024   0xF117 0x0F01      CMN      R7,#+1
   \   00000028   0xD0F7             BEQ.N    ??I2S_WaitFlagStateUntilTimeout_1
   1151                {
   1152                  if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
   \   0000002A   0x2F00             CMP      R7,#+0
   \   0000002C   0xD005             BEQ.N    ??I2S_WaitFlagStateUntilTimeout_3
   \   0000002E   0x.... 0x....      BL       HAL_GetTick
   \   00000032   0xEBB0 0x0008      SUBS     R0,R0,R8
   \   00000036   0x4287             CMP      R7,R0
   \   00000038   0xD2EF             BCS.N    ??I2S_WaitFlagStateUntilTimeout_1
   1153                  {
   1154                    /* Set the I2S State ready */
   1155                    hi2s->State= HAL_I2S_STATE_READY;
   \                     ??I2S_WaitFlagStateUntilTimeout_3: (+1)
   \   0000003A   0x2001             MOVS     R0,#+1
   \   0000003C   0xF884 0x0039      STRB     R0,[R4, #+57]
   1156          
   1157                    /* Process Unlocked */
   1158                    __HAL_UNLOCK(hi2s);
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0xF884 0x0038      STRB     R0,[R4, #+56]
   1159          
   1160                    return HAL_TIMEOUT;
   \   00000046   0x2003             MOVS     R0,#+3
   \   00000048   0xE018             B.N      ??I2S_WaitFlagStateUntilTimeout_4
   1161                  }
   1162                }
   1163              }
   1164            }
   1165            else
   1166            {
   1167              while(__HAL_I2S_GET_FLAG(hi2s, Flag) != RESET)
   \                     ??I2S_WaitFlagStateUntilTimeout_0: (+1)
   \   0000004A   0x6820             LDR      R0,[R4, #+0]
   \   0000004C   0x6880             LDR      R0,[R0, #+8]
   \   0000004E   0x4028             ANDS     R0,R5,R0
   \   00000050   0x42A8             CMP      R0,R5
   \   00000052   0xD112             BNE.N    ??I2S_WaitFlagStateUntilTimeout_2
   1168              {
   1169                if(Timeout != HAL_MAX_DELAY)
   \   00000054   0xF117 0x0F01      CMN      R7,#+1
   \   00000058   0xD0F7             BEQ.N    ??I2S_WaitFlagStateUntilTimeout_0
   1170                {
   1171                  if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
   \   0000005A   0x2F00             CMP      R7,#+0
   \   0000005C   0xD005             BEQ.N    ??I2S_WaitFlagStateUntilTimeout_5
   \   0000005E   0x.... 0x....      BL       HAL_GetTick
   \   00000062   0xEBB0 0x0008      SUBS     R0,R0,R8
   \   00000066   0x4287             CMP      R7,R0
   \   00000068   0xD2EF             BCS.N    ??I2S_WaitFlagStateUntilTimeout_0
   1172                  {
   1173                    /* Set the I2S State ready */
   1174                    hi2s->State= HAL_I2S_STATE_READY;
   \                     ??I2S_WaitFlagStateUntilTimeout_5: (+1)
   \   0000006A   0x2001             MOVS     R0,#+1
   \   0000006C   0xF884 0x0039      STRB     R0,[R4, #+57]
   1175          
   1176                    /* Process Unlocked */
   1177                    __HAL_UNLOCK(hi2s);
   \   00000070   0x2000             MOVS     R0,#+0
   \   00000072   0xF884 0x0038      STRB     R0,[R4, #+56]
   1178          
   1179                    return HAL_TIMEOUT;
   \   00000076   0x2003             MOVS     R0,#+3
   \   00000078   0xE000             B.N      ??I2S_WaitFlagStateUntilTimeout_4
   1180                  }
   1181                }
   1182              }
   1183            }
   1184            return HAL_OK;    
   \                     ??I2S_WaitFlagStateUntilTimeout_2: (+1)
   \   0000007A   0x2000             MOVS     R0,#+0
   \                     ??I2S_WaitFlagStateUntilTimeout_4: (+1)
   \   0000007C   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   1185          }
   1186          /**
   1187            * @}
   1188            */
   1189          
   1190          /** @addtogroup I2S_Exported_Functions I2S Exported Functions
   1191            * @{
   1192            */
   1193          
   1194          /** @addtogroup  I2S_Exported_Functions_Group2 Input and Output operation functions 
   1195            * @{
   1196            */
   1197          /**
   1198            * @brief Tx Transfer Half completed callbacks
   1199            * @param  hi2s: pointer to a I2S_HandleTypeDef structure that contains
   1200            *         the configuration information for I2S module
   1201            * @retval None
   1202            */

   \                                 In section .text, align 2, keep-with-next
   1203           __weak void HAL_I2S_TxHalfCpltCallback(I2S_HandleTypeDef *hi2s)
   1204          {
   1205            /* NOTE : This function Should not be modified, when the callback is needed,
   1206                      the HAL_I2S_TxHalfCpltCallback could be implemented in the user file
   1207             */ 
   1208          }
   \                     HAL_I2S_TxHalfCpltCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1209          
   1210          /**
   1211            * @brief Tx Transfer completed callbacks
   1212            * @param  hi2s: pointer to a I2S_HandleTypeDef structure that contains
   1213            *         the configuration information for I2S module
   1214            * @retval None
   1215            */

   \                                 In section .text, align 2, keep-with-next
   1216           __weak void HAL_I2S_TxCpltCallback(I2S_HandleTypeDef *hi2s)
   1217          {
   1218            /* NOTE : This function Should not be modified, when the callback is needed,
   1219                      the HAL_I2S_TxCpltCallback could be implemented in the user file
   1220             */ 
   1221          }
   \                     HAL_I2S_TxCpltCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1222          
   1223          /**
   1224            * @brief Rx Transfer half completed callbacks
   1225            * @param  hi2s: pointer to a I2S_HandleTypeDef structure that contains
   1226            *         the configuration information for I2S module
   1227            * @retval None
   1228            */

   \                                 In section .text, align 2, keep-with-next
   1229          __weak void HAL_I2S_RxHalfCpltCallback(I2S_HandleTypeDef *hi2s)
   1230          {
   1231            /* NOTE : This function Should not be modified, when the callback is needed,
   1232                      the HAL_I2S_RxCpltCallback could be implemented in the user file
   1233             */
   1234          }
   \                     HAL_I2S_RxHalfCpltCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1235          
   1236          /**
   1237            * @brief Rx Transfer completed callbacks
   1238            * @param  hi2s: pointer to a I2S_HandleTypeDef structure that contains
   1239            *         the configuration information for I2S module
   1240            * @retval None
   1241            */

   \                                 In section .text, align 2, keep-with-next
   1242          __weak void HAL_I2S_RxCpltCallback(I2S_HandleTypeDef *hi2s)
   1243          {
   1244            /* NOTE : This function Should not be modified, when the callback is needed,
   1245                      the HAL_I2S_RxCpltCallback could be implemented in the user file
   1246             */
   1247          }
   \                     HAL_I2S_RxCpltCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1248          
   1249          /**
   1250            * @brief I2S error callbacks
   1251            * @param  hi2s: pointer to a I2S_HandleTypeDef structure that contains
   1252            *         the configuration information for I2S module
   1253            * @retval None
   1254            */

   \                                 In section .text, align 2, keep-with-next
   1255           __weak void HAL_I2S_ErrorCallback(I2S_HandleTypeDef *hi2s)
   1256          {
   1257            /* NOTE : This function Should not be modified, when the callback is needed,
   1258                      the HAL_I2S_ErrorCallback could be implemented in the user file
   1259             */ 
   1260          }
   \                     HAL_I2S_ErrorCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1261          
   1262          /**
   1263            * @}
   1264            */
   1265          
   1266          /** @defgroup I2S_Exported_Functions_Group3 Peripheral State and Errors functions 
   1267            *  @brief   Peripheral State functions 
   1268            *
   1269          @verbatim   
   1270           ===============================================================================
   1271                                ##### Peripheral State and Errors functions #####
   1272           ===============================================================================  
   1273              [..]
   1274              This subsection permits to get in run-time the status of the peripheral 
   1275              and the data flow.
   1276          
   1277          @endverbatim
   1278            * @{
   1279            */
   1280          
   1281          /**
   1282            * @brief  Return the I2S state
   1283            * @param  hi2s: pointer to a I2S_HandleTypeDef structure that contains
   1284            *         the configuration information for I2S module
   1285            * @retval HAL state
   1286            */

   \                                 In section .text, align 2, keep-with-next
   1287          HAL_I2S_StateTypeDef HAL_I2S_GetState(I2S_HandleTypeDef *hi2s)
   1288          {
   1289            return hi2s->State;
   \                     HAL_I2S_GetState: (+1)
   \   00000000   0xF890 0x0039      LDRB     R0,[R0, #+57]
   \   00000004   0x4770             BX       LR               ;; return
   1290          }
   1291          
   1292          /**
   1293            * @brief  Return the I2S error code
   1294            * @param  hi2s: pointer to a I2S_HandleTypeDef structure that contains
   1295            *         the configuration information for I2S module
   1296            * @retval I2S Error Code
   1297            */

   \                                 In section .text, align 2, keep-with-next
   1298          uint32_t HAL_I2S_GetError(I2S_HandleTypeDef *hi2s)
   1299          {
   1300            return hi2s->ErrorCode;
   \                     HAL_I2S_GetError: (+1)
   \   00000000   0x6BC0             LDR      R0,[R0, #+60]
   \   00000002   0x4770             BX       LR               ;; return
   1301          }
   1302          /**
   1303            * @}
   1304            */  
   1305          
   1306          /**
   1307            * @}
   1308            */
   1309          
   1310            /**
   1311            * @brief  Get I2S Input Clock based on I2S source clock selection
   1312            * @param  hi2s: pointer to a I2S_HandleTypeDef structure that contains
   1313            *               the configuration information for I2S module.   
   1314            * @retval I2S Clock Input 
   1315            */

   \                                 In section .text, align 2, keep-with-next
   1316          static uint32_t I2S_GetClockFreq(I2S_HandleTypeDef *hi2s)   
   1317          {
   \                     I2S_GetClockFreq: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
   \   00000002   0x0001             MOVS     R1,R0
   1318            uint32_t tmpreg = 0;
   \   00000004   0x2200             MOVS     R2,#+0
   1319            /* This variable used to store the VCO Input (value in Hz) */
   1320            uint32_t vcoinput = 0;
   \   00000006   0x2300             MOVS     R3,#+0
   1321            /* This variable used to store the I2S_CK_x (value in Hz) */
   1322            uint32_t i2sclocksource = 0;
   \   00000008   0x2000             MOVS     R0,#+0
   1323          
   1324            /* Configure I2S Clock based on I2S source clock selection */ 
   1325            
   1326            /* I2S_CLK_x : I2S Block Clock configuration for different clock sources selected */
   1327            switch(hi2s->Init.ClockSource)
   \   0000000A   0x69CC             LDR      R4,[R1, #+28]
   \   0000000C   0x2C01             CMP      R4,#+1
   \   0000000E   0xD025             BEQ.N    ??I2S_GetClockFreq_0
   \   00000010   0x2C02             CMP      R4,#+2
   \   00000012   0xD126             BNE.N    ??I2S_GetClockFreq_1
   1328            {
   1329              case I2S_CLOCK_SYSCLK :
   1330              {
   1331                /* Configure the PLLI2S division factor */
   1332                /* PLLI2S_VCO Input  = PLL_SOURCE/PLLI2SM */ 
   1333                if((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLSOURCE_HSI)
   \                     ??I2S_GetClockFreq_2: (+1)
   \   00000014   0x....             LDR.N    R4,??DataTable1_2  ;; 0x40023804
   \   00000016   0x6824             LDR      R4,[R4, #+0]
   \   00000018   0x0264             LSLS     R4,R4,#+9
   \   0000001A   0xD408             BMI.N    ??I2S_GetClockFreq_3
   1334                {
   1335                  /* In Case the PLL Source is HSI (Internal Clock) */
   1336                  vcoinput = (HSI_VALUE / (uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLM));
   \   0000001C   0x....             LDR.N    R4,??DataTable1_3  ;; 0xf42400
   \   0000001E   0x....             LDR.N    R5,??DataTable1_2  ;; 0x40023804
   \   00000020   0x682D             LDR      R5,[R5, #+0]
   \   00000022   0xF015 0x053F      ANDS     R5,R5,#0x3F
   \   00000026   0xFBB4 0xF4F5      UDIV     R4,R4,R5
   \   0000002A   0x0023             MOVS     R3,R4
   \   0000002C   0xE007             B.N      ??I2S_GetClockFreq_4
   1337                }
   1338                else
   1339                {
   1340                  /* In Case the PLL Source is HSE (External Clock) */
   1341                  vcoinput = ((HSE_VALUE / (uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLM)));
   \                     ??I2S_GetClockFreq_3: (+1)
   \   0000002E   0x....             LDR.N    R4,??DataTable1_4  ;; 0x17d7840
   \   00000030   0x....             LDR.N    R5,??DataTable1_2  ;; 0x40023804
   \   00000032   0x682D             LDR      R5,[R5, #+0]
   \   00000034   0xF015 0x053F      ANDS     R5,R5,#0x3F
   \   00000038   0xFBB4 0xF4F5      UDIV     R4,R4,R5
   \   0000003C   0x0023             MOVS     R3,R4
   1342                }
   1343          
   1344                /* PLLI2S_VCO Output = PLLI2S_VCO Input * PLLI2SN */
   1345                /* I2S_CLK(first level) = PLLI2S_VCO Output/PLLI2SR */
   1346                tmpreg = (RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SR) >> 28;
   \                     ??I2S_GetClockFreq_4: (+1)
   \   0000003E   0x....             LDR.N    R4,??DataTable1_5  ;; 0x40023884
   \   00000040   0x6824             LDR      R4,[R4, #+0]
   \   00000042   0xF3C4 0x7402      UBFX     R4,R4,#+28,#+3
   \   00000046   0x0022             MOVS     R2,R4
   1347                i2sclocksource = (vcoinput * ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SN) >> 6))/(tmpreg);
   \   00000048   0x....             LDR.N    R4,??DataTable1_5  ;; 0x40023884
   \   0000004A   0x6824             LDR      R4,[R4, #+0]
   \   0000004C   0xF3C4 0x1488      UBFX     R4,R4,#+6,#+9
   \   00000050   0xFB04 0xF403      MUL      R4,R4,R3
   \   00000054   0xFBB4 0xF4F2      UDIV     R4,R4,R2
   \   00000058   0x0020             MOVS     R0,R4
   1348              
   1349                break;
   \   0000005A   0xE002             B.N      ??I2S_GetClockFreq_5
   1350              }
   1351              case I2S_CLOCK_EXTERNAL :
   1352              {
   1353                i2sclocksource = EXTERNAL_CLOCK_VALUE;
   \                     ??I2S_GetClockFreq_0: (+1)
   \   0000005C   0x....             LDR.N    R4,??DataTable1_1  ;; 0xbb8000
   \   0000005E   0x0020             MOVS     R0,R4
   1354                break;
   \   00000060   0xE7FF             B.N      ??I2S_GetClockFreq_5
   1355              }
   1356              default :
   1357              {
   1358                break;
   1359              }
   1360            }
   1361          
   1362            /* the return result is the value of I2S clock */
   1363            return i2sclocksource; 
   \                     ??I2S_GetClockFreq_1: (+1)
   \                     ??I2S_GetClockFreq_5: (+1)
   \   00000062   0xBC30             POP      {R4,R5}
   \   00000064   0x4770             BX       LR               ;; return
   1364          }
   1365          
   1366          /** @addtogroup I2S_Private_Functions I2S Private Functions
   1367            * @{
   1368            */
   1369          /**
   1370            * @brief DMA I2S transmit process complete callback 
   1371            * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
   1372            *                the configuration information for the specified DMA module.
   1373            * @retval None
   1374            */

   \                                 In section .text, align 4, keep-with-next
   1375          static void I2S_DMATxCplt(DMA_HandleTypeDef *hdma)   
   1376          {
   \                     I2S_DMATxCplt: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1377            I2S_HandleTypeDef* hi2s = (I2S_HandleTypeDef*)((DMA_HandleTypeDef*)hdma)->Parent;
   \   00000004   0x6BA5             LDR      R5,[R4, #+56]
   1378            
   1379            if((hdma->Instance->CR & DMA_SxCR_CIRC) == 0)
   \   00000006   0x6820             LDR      R0,[R4, #+0]
   \   00000008   0x6800             LDR      R0,[R0, #+0]
   \   0000000A   0x05C0             LSLS     R0,R0,#+23
   \   0000000C   0xD415             BMI.N    ??I2S_DMATxCplt_0
   1380            {
   1381              hi2s->TxXferCount = 0;
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0x84E8             STRH     R0,[R5, #+38]
   1382          
   1383              /* Disable Tx DMA Request */
   1384              hi2s->Instance->CR2 &= (uint32_t)(~SPI_CR2_TXDMAEN);
   \   00000012   0x6828             LDR      R0,[R5, #+0]
   \   00000014   0x6840             LDR      R0,[R0, #+4]
   \   00000016   0xF030 0x0002      BICS     R0,R0,#0x2
   \   0000001A   0x6829             LDR      R1,[R5, #+0]
   \   0000001C   0x6048             STR      R0,[R1, #+4]
   1385              
   1386              if(hi2s->State == HAL_I2S_STATE_BUSY_TX_RX)
   \   0000001E   0xF895 0x0039      LDRB     R0,[R5, #+57]
   \   00000022   0x2805             CMP      R0,#+5
   \   00000024   0xD106             BNE.N    ??I2S_DMATxCplt_1
   1387              {
   1388                if(hi2s->RxXferCount == 0)
   \   00000026   0x8DE8             LDRH     R0,[R5, #+46]
   \   00000028   0x2800             CMP      R0,#+0
   \   0000002A   0xD106             BNE.N    ??I2S_DMATxCplt_0
   1389                {
   1390                  hi2s->State = HAL_I2S_STATE_READY;
   \   0000002C   0x2001             MOVS     R0,#+1
   \   0000002E   0xF885 0x0039      STRB     R0,[R5, #+57]
   \   00000032   0xE002             B.N      ??I2S_DMATxCplt_0
   1391                }
   1392              }
   1393              else
   1394              {
   1395                hi2s->State = HAL_I2S_STATE_READY; 
   \                     ??I2S_DMATxCplt_1: (+1)
   \   00000034   0x2001             MOVS     R0,#+1
   \   00000036   0xF885 0x0039      STRB     R0,[R5, #+57]
   1396              }
   1397            }
   1398            HAL_I2S_TxCpltCallback(hi2s);
   \                     ??I2S_DMATxCplt_0: (+1)
   \   0000003A   0x0028             MOVS     R0,R5
   \   0000003C   0x.... 0x....      BL       HAL_I2S_TxCpltCallback
   1399          }
   \   00000040   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1400          
   1401          /**
   1402            * @brief DMA I2S transmit process half complete callback 
   1403            * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
   1404            *                the configuration information for the specified DMA module.
   1405            * @retval None
   1406            */

   \                                 In section .text, align 4, keep-with-next
   1407          static void I2S_DMATxHalfCplt(DMA_HandleTypeDef *hdma)
   1408          {
   \                     I2S_DMATxHalfCplt: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1409            I2S_HandleTypeDef* hi2s = (I2S_HandleTypeDef*)((DMA_HandleTypeDef*)hdma)->Parent;
   \   00000004   0x6BA5             LDR      R5,[R4, #+56]
   1410          
   1411            HAL_I2S_TxHalfCpltCallback(hi2s);
   \   00000006   0x0028             MOVS     R0,R5
   \   00000008   0x.... 0x....      BL       HAL_I2S_TxHalfCpltCallback
   1412          }
   \   0000000C   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1413          
   1414          /**
   1415            * @brief DMA I2S receive process complete callback 
   1416            * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
   1417            *                the configuration information for the specified DMA module.
   1418            * @retval None
   1419            */

   \                                 In section .text, align 4, keep-with-next
   1420          static void I2S_DMARxCplt(DMA_HandleTypeDef *hdma)   
   1421          {
   \                     I2S_DMARxCplt: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1422            I2S_HandleTypeDef* hi2s = (I2S_HandleTypeDef*)((DMA_HandleTypeDef*)hdma)->Parent;
   \   00000004   0x6BA5             LDR      R5,[R4, #+56]
   1423          
   1424            if((hdma->Instance->CR & DMA_SxCR_CIRC) == 0)
   \   00000006   0x6820             LDR      R0,[R4, #+0]
   \   00000008   0x6800             LDR      R0,[R0, #+0]
   \   0000000A   0x05C0             LSLS     R0,R0,#+23
   \   0000000C   0xD415             BMI.N    ??I2S_DMARxCplt_0
   1425            {
   1426              /* Disable Rx DMA Request */
   1427              hi2s->Instance->CR2 &= (uint32_t)(~SPI_CR2_RXDMAEN);
   \   0000000E   0x6828             LDR      R0,[R5, #+0]
   \   00000010   0x6840             LDR      R0,[R0, #+4]
   \   00000012   0x0840             LSRS     R0,R0,#+1
   \   00000014   0x0040             LSLS     R0,R0,#+1
   \   00000016   0x6829             LDR      R1,[R5, #+0]
   \   00000018   0x6048             STR      R0,[R1, #+4]
   1428          
   1429              hi2s->RxXferCount = 0;
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0x85E8             STRH     R0,[R5, #+46]
   1430              if(hi2s->State == HAL_I2S_STATE_BUSY_TX_RX)
   \   0000001E   0xF895 0x0039      LDRB     R0,[R5, #+57]
   \   00000022   0x2805             CMP      R0,#+5
   \   00000024   0xD106             BNE.N    ??I2S_DMARxCplt_1
   1431              {
   1432                if(hi2s->TxXferCount == 0)
   \   00000026   0x8CE8             LDRH     R0,[R5, #+38]
   \   00000028   0x2800             CMP      R0,#+0
   \   0000002A   0xD106             BNE.N    ??I2S_DMARxCplt_0
   1433                {
   1434                  hi2s->State = HAL_I2S_STATE_READY;
   \   0000002C   0x2001             MOVS     R0,#+1
   \   0000002E   0xF885 0x0039      STRB     R0,[R5, #+57]
   \   00000032   0xE002             B.N      ??I2S_DMARxCplt_0
   1435                }
   1436              }
   1437              else
   1438              {
   1439                hi2s->State = HAL_I2S_STATE_READY; 
   \                     ??I2S_DMARxCplt_1: (+1)
   \   00000034   0x2001             MOVS     R0,#+1
   \   00000036   0xF885 0x0039      STRB     R0,[R5, #+57]
   1440              }
   1441            }
   1442            HAL_I2S_RxCpltCallback(hi2s); 
   \                     ??I2S_DMARxCplt_0: (+1)
   \   0000003A   0x0028             MOVS     R0,R5
   \   0000003C   0x.... 0x....      BL       HAL_I2S_RxCpltCallback
   1443          }
   \   00000040   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1444                
   1445          /**
   1446            * @brief DMA I2S receive process half complete callback 
   1447            * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
   1448            *                the configuration information for the specified DMA module.
   1449            * @retval None
   1450            */

   \                                 In section .text, align 4, keep-with-next
   1451          static void I2S_DMARxHalfCplt(DMA_HandleTypeDef *hdma)
   1452          {
   \                     I2S_DMARxHalfCplt: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1453            I2S_HandleTypeDef* hi2s = (I2S_HandleTypeDef*)((DMA_HandleTypeDef*)hdma)->Parent;
   \   00000004   0x6BA5             LDR      R5,[R4, #+56]
   1454          
   1455            HAL_I2S_RxHalfCpltCallback(hi2s); 
   \   00000006   0x0028             MOVS     R0,R5
   \   00000008   0x.... 0x....      BL       HAL_I2S_RxHalfCpltCallback
   1456          }
   \   0000000C   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1457          
   1458          /**
   1459            * @brief DMA I2S communication error callback 
   1460            * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
   1461            *                the configuration information for the specified DMA module.
   1462            * @retval None
   1463            */

   \                                 In section .text, align 4, keep-with-next
   1464          static void I2S_DMAError(DMA_HandleTypeDef *hdma)   
   1465          {
   \                     I2S_DMAError: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1466            I2S_HandleTypeDef* hi2s = ( I2S_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   \   00000004   0x6BA5             LDR      R5,[R4, #+56]
   1467            
   1468            /* Disable Rx and Tx DMA Request */
   1469            hi2s->Instance->CR2 &= (uint32_t)(~(SPI_CR2_RXDMAEN | SPI_CR2_TXDMAEN));
   \   00000006   0x6828             LDR      R0,[R5, #+0]
   \   00000008   0x6840             LDR      R0,[R0, #+4]
   \   0000000A   0x0880             LSRS     R0,R0,#+2
   \   0000000C   0x0080             LSLS     R0,R0,#+2
   \   0000000E   0x6829             LDR      R1,[R5, #+0]
   \   00000010   0x6048             STR      R0,[R1, #+4]
   1470            hi2s->TxXferCount = 0;
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0x84E8             STRH     R0,[R5, #+38]
   1471            hi2s->RxXferCount = 0;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0x85E8             STRH     R0,[R5, #+46]
   1472            
   1473            hi2s->State= HAL_I2S_STATE_READY;
   \   0000001A   0x2001             MOVS     R0,#+1
   \   0000001C   0xF885 0x0039      STRB     R0,[R5, #+57]
   1474          
   1475            /* Set the error code and execute error callback*/
   1476            hi2s->ErrorCode |= HAL_I2S_ERROR_DMA;
   \   00000020   0x6BE8             LDR      R0,[R5, #+60]
   \   00000022   0xF050 0x0008      ORRS     R0,R0,#0x8
   \   00000026   0x63E8             STR      R0,[R5, #+60]
   1477            HAL_I2S_ErrorCallback(hi2s);
   \   00000028   0x0028             MOVS     R0,R5
   \   0000002A   0x.... 0x....      BL       HAL_I2S_ErrorCallback
   1478          }
   \   0000002E   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1479          
   1480          /**
   1481            * @brief Transmit an amount of data in non-blocking mode with Interrupt
   1482            * @param  hi2s: pointer to a I2S_HandleTypeDef structure that contains
   1483            *         the configuration information for I2S module
   1484            * @retval None
   1485            */

   \                                 In section .text, align 2, keep-with-next
   1486          static void I2S_Transmit_IT(I2S_HandleTypeDef *hi2s)
   1487          {
   \                     I2S_Transmit_IT: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1488            /* Transmit data */
   1489            hi2s->Instance->DR = (*hi2s->pTxBuffPtr++);
   \   00000004   0x6A20             LDR      R0,[R4, #+32]
   \   00000006   0x1C81             ADDS     R1,R0,#+2
   \   00000008   0x6221             STR      R1,[R4, #+32]
   \   0000000A   0x8800             LDRH     R0,[R0, #+0]
   \   0000000C   0x6821             LDR      R1,[R4, #+0]
   \   0000000E   0x60C8             STR      R0,[R1, #+12]
   1490            hi2s->TxXferCount--;	
   \   00000010   0x8CE0             LDRH     R0,[R4, #+38]
   \   00000012   0x1E40             SUBS     R0,R0,#+1
   \   00000014   0x84E0             STRH     R0,[R4, #+38]
   1491          
   1492            if(hi2s->TxXferCount == 0)
   \   00000016   0x8CE0             LDRH     R0,[R4, #+38]
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD10B             BNE.N    ??I2S_Transmit_IT_0
   1493            {
   1494              /* Disable TXE and ERR interrupt */
   1495              __HAL_I2S_DISABLE_IT(hi2s, (I2S_IT_TXE | I2S_IT_ERR));
   \   0000001C   0x6820             LDR      R0,[R4, #+0]
   \   0000001E   0x6840             LDR      R0,[R0, #+4]
   \   00000020   0xF030 0x00A0      BICS     R0,R0,#0xA0
   \   00000024   0x6821             LDR      R1,[R4, #+0]
   \   00000026   0x6048             STR      R0,[R1, #+4]
   1496          
   1497              hi2s->State = HAL_I2S_STATE_READY;
   \   00000028   0x2001             MOVS     R0,#+1
   \   0000002A   0xF884 0x0039      STRB     R0,[R4, #+57]
   1498              HAL_I2S_TxCpltCallback(hi2s);
   \   0000002E   0x0020             MOVS     R0,R4
   \   00000030   0x.... 0x....      BL       HAL_I2S_TxCpltCallback
   1499            }
   1500          }
   \                     ??I2S_Transmit_IT_0: (+1)
   \   00000034   0xBD10             POP      {R4,PC}          ;; return
   1501          
   1502          /**
   1503            * @brief Receive an amount of data in non-blocking mode with Interrupt
   1504            * @param hi2s: I2S handle
   1505            * @retval None
   1506            */

   \                                 In section .text, align 2, keep-with-next
   1507          static void I2S_Receive_IT(I2S_HandleTypeDef *hi2s)
   1508          {
   \                     I2S_Receive_IT: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1509            /* Receive data */    
   1510            (*hi2s->pRxBuffPtr++) = hi2s->Instance->DR;
   \   00000004   0x6AA0             LDR      R0,[R4, #+40]
   \   00000006   0x1C81             ADDS     R1,R0,#+2
   \   00000008   0x62A1             STR      R1,[R4, #+40]
   \   0000000A   0x6821             LDR      R1,[R4, #+0]
   \   0000000C   0x68C9             LDR      R1,[R1, #+12]
   \   0000000E   0x8001             STRH     R1,[R0, #+0]
   1511            hi2s->RxXferCount--;
   \   00000010   0x8DE0             LDRH     R0,[R4, #+46]
   \   00000012   0x1E40             SUBS     R0,R0,#+1
   \   00000014   0x85E0             STRH     R0,[R4, #+46]
   1512          
   1513            if(hi2s->RxXferCount == 0)
   \   00000016   0x8DE0             LDRH     R0,[R4, #+46]
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD10B             BNE.N    ??I2S_Receive_IT_0
   1514            {    
   1515              /* Disable RXNE and ERR interrupt */
   1516              __HAL_I2S_DISABLE_IT(hi2s, (I2S_IT_RXNE | I2S_IT_ERR));
   \   0000001C   0x6820             LDR      R0,[R4, #+0]
   \   0000001E   0x6840             LDR      R0,[R0, #+4]
   \   00000020   0xF030 0x0060      BICS     R0,R0,#0x60
   \   00000024   0x6821             LDR      R1,[R4, #+0]
   \   00000026   0x6048             STR      R0,[R1, #+4]
   1517          
   1518              hi2s->State = HAL_I2S_STATE_READY;     
   \   00000028   0x2001             MOVS     R0,#+1
   \   0000002A   0xF884 0x0039      STRB     R0,[R4, #+57]
   1519              HAL_I2S_RxCpltCallback(hi2s); 
   \   0000002E   0x0020             MOVS     R0,R4
   \   00000030   0x.... 0x....      BL       HAL_I2S_RxCpltCallback
   1520            }
   1521          }
   \                     ??I2S_Receive_IT_0: (+1)
   \   00000034   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1:
   \   00000000   0xFFFFF040         DC32     0xfffff040

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_1:
   \   00000000   0x00BB8000         DC32     0xbb8000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_2:
   \   00000000   0x40023804         DC32     0x40023804

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_3:
   \   00000000   0x00F42400         DC32     0xf42400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_4:
   \   00000000   0x017D7840         DC32     0x17d7840

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_5:
   \   00000000   0x40023884         DC32     0x40023884
   1522          /**
   1523            * @}
   1524            */
   1525            
   1526          #endif /* HAL_I2S_MODULE_ENABLED */
   1527          /**
   1528            * @}
   1529            */
   1530          
   1531          /**
   1532            * @}
   1533            */
   1534          
   1535          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   HAL_I2S_DMAPause
       0   HAL_I2S_DMAResume
       8   HAL_I2S_DMAStop
         8   -> HAL_DMA_Abort
       8   HAL_I2S_DeInit
         8   -> HAL_I2S_MspDeInit
       0   HAL_I2S_ErrorCallback
       0   HAL_I2S_GetError
       0   HAL_I2S_GetState
      16   HAL_I2S_IRQHandler
        16   -> HAL_I2S_ErrorCallback
        16   -> I2S_Receive_IT
        16   -> I2S_Transmit_IT
      32   HAL_I2S_Init
        32   -> HAL_I2S_MspInit
        32   -> I2S_GetClockFreq
       0   HAL_I2S_MspDeInit
       0   HAL_I2S_MspInit
      24   HAL_I2S_Receive
        24   -> HAL_I2S_ErrorCallback
        24   -> I2S_WaitFlagStateUntilTimeout
      24   HAL_I2S_Receive_DMA
        24   -> HAL_DMA_Start_IT
       4   HAL_I2S_Receive_IT
       0   HAL_I2S_RxCpltCallback
       0   HAL_I2S_RxHalfCpltCallback
      24   HAL_I2S_Transmit
        24   -> HAL_I2S_ErrorCallback
        24   -> I2S_WaitFlagStateUntilTimeout
      24   HAL_I2S_Transmit_DMA
        24   -> HAL_DMA_Start_IT
       4   HAL_I2S_Transmit_IT
       0   HAL_I2S_TxCpltCallback
       0   HAL_I2S_TxHalfCpltCallback
      16   I2S_DMAError
        16   -> HAL_I2S_ErrorCallback
      16   I2S_DMARxCplt
        16   -> HAL_I2S_RxCpltCallback
      16   I2S_DMARxHalfCplt
        16   -> HAL_I2S_RxHalfCpltCallback
      16   I2S_DMATxCplt
        16   -> HAL_I2S_TxCpltCallback
      16   I2S_DMATxHalfCplt
        16   -> HAL_I2S_TxHalfCpltCallback
       8   I2S_GetClockFreq
       8   I2S_Receive_IT
         8   -> HAL_I2S_RxCpltCallback
       8   I2S_Transmit_IT
         8   -> HAL_I2S_TxCpltCallback
      24   I2S_WaitFlagStateUntilTimeout
        24   -> HAL_GetTick


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable1
       4  ??DataTable1_1
       4  ??DataTable1_2
       4  ??DataTable1_3
       4  ??DataTable1_4
       4  ??DataTable1_5
     122  HAL_I2S_DMAPause
      92  HAL_I2S_DMAResume
     130  HAL_I2S_DMAStop
      44  HAL_I2S_DeInit
       2  HAL_I2S_ErrorCallback
       4  HAL_I2S_GetError
       6  HAL_I2S_GetState
     164  HAL_I2S_IRQHandler
     294  HAL_I2S_Init
       2  HAL_I2S_MspDeInit
       2  HAL_I2S_MspInit
     260  HAL_I2S_Receive
     218  HAL_I2S_Receive_DMA
     142  HAL_I2S_Receive_IT
       2  HAL_I2S_RxCpltCallback
       2  HAL_I2S_RxHalfCpltCallback
     288  HAL_I2S_Transmit
     190  HAL_I2S_Transmit_DMA
     142  HAL_I2S_Transmit_IT
       2  HAL_I2S_TxCpltCallback
       2  HAL_I2S_TxHalfCpltCallback
      48  I2S_DMAError
      66  I2S_DMARxCplt
      14  I2S_DMARxHalfCplt
      66  I2S_DMATxCplt
      14  I2S_DMATxHalfCplt
     102  I2S_GetClockFreq
      54  I2S_Receive_IT
      54  I2S_Transmit_IT
     128  I2S_WaitFlagStateUntilTimeout

 
 2 680 bytes in section .text
 
 2 680 bytes of CODE memory

Errors: none
Warnings: none
