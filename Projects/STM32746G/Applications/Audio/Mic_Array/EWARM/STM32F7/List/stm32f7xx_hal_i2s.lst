###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.2.10312/W32 for ARM       21/Jan/2016  18:08:43
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\sop1hc\Github\data\Mic_Array_V00\Mic_Array\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_i2s.c
#    Command line =  
#        D:\sop1hc\Github\data\Mic_Array_V00\Mic_Array\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_i2s.c
#        -D USE_HAL_DRIVER -D STM32F746xx -D USE_STM32746G_DISCO -D
#        USE_IOEXPANDER -D USE_USB_FS -lC
#        D:\sop1hc\Github\data\Mic_Array_V00\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
#        -lA
#        D:\sop1hc\Github\data\Mic_Array_V00\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
#        -o
#        D:\sop1hc\Github\data\Mic_Array_V00\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj
#        --no_unroll --debug --endian=little --cpu=Cortex-M7 -e --fpu=VFPv5_sp
#        --dlib_config "D:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Full.h" -I
#        D:\sop1hc\Github\data\Mic_Array_V00\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\CMSIS\Device\ST\STM32F7xx\Include\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\STM32F7xx_HAL_Driver\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\STM32746G-Discovery\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\Components\Common\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Log\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Fonts\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\CPU\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_Device_Library\Core\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Core\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Class\MSC\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\drivers\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_Audio\Addons\PDM\
#        -Ohz --use_c++_inline --require_prototypes -I "D:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.3\arm\CMSIS\Include\" -D
#        ARM_MATH_CM7
#    List file    =  
#        D:\sop1hc\Github\data\Mic_Array_V00\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List\stm32f7xx_hal_i2s.lst
#    Object file  =  
#        D:\sop1hc\Github\data\Mic_Array_V00\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj\stm32f7xx_hal_i2s.o
#
###############################################################################

D:\sop1hc\Github\data\Mic_Array_V00\Mic_Array\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_i2s.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f7xx_hal_i2s.c
      4            * @author  MCD Application Team
      5            * @version V1.0.1
      6            * @date    25-June-2015
      7            * @brief   I2S HAL module driver.
      8            *          This file provides firmware functions to manage the following 
      9            *          functionalities of the Integrated Interchip Sound (I2S) peripheral:
     10            *           + Initialization and de-initialization functions
     11            *           + IO operation functions
     12            *           + Peripheral State and Errors functions
     13            @verbatim
     14           ===============================================================================
     15                            ##### How to use this driver #####
     16           ===============================================================================
     17           [..]
     18              The I2S HAL driver can be used as follows:
     19              
     20              (#) Declare a I2S_HandleTypeDef handle structure.
     21              (#) Initialize the I2S low level resources by implement the HAL_I2S_MspInit() API:
     22                  (##) Enable the SPIx interface clock.                      
     23                  (##) I2S pins configuration:
     24                      (+++) Enable the clock for the I2S GPIOs.
     25                      (+++) Configure these I2S pins as alternate function pull-up.
     26                  (##) NVIC configuration if you need to use interrupt process (HAL_I2S_Transmit_IT()
     27                       and HAL_I2S_Receive_IT() APIs).
     28                      (+++) Configure the I2Sx interrupt priority.
     29                      (+++) Enable the NVIC I2S IRQ handle.
     30                  (##) DMA Configuration if you need to use DMA process (HAL_I2S_Transmit_DMA()
     31                       and HAL_I2S_Receive_DMA() APIs:
     32                      (+++) Declare a DMA handle structure for the Tx/Rx channel.
     33                      (+++) Enable the DMAx interface clock.
     34                      (+++) Configure the declared DMA handle structure with the required Tx/Rx parameters.                
     35                      (+++) Configure the DMA Tx/Rx Channel.
     36                      (+++) Associate the initialized DMA handle to the I2S DMA Tx/Rx handle.
     37                      (+++) Configure the priority and enable the NVIC for the transfer complete interrupt on the 
     38                          DMA Tx/Rx Channel.
     39            
     40             (#) Program the Mode, Standard, Data Format, MCLK Output, Audio frequency and Polarity
     41                 using HAL_I2S_Init() function.
     42          
     43             -@- The specific I2S interrupts (Transmission complete interrupt, 
     44                 RXNE interrupt and Error Interrupts) will be managed using the macros
     45                 __HAL_I2S_ENABLE_IT() and __HAL_I2S_DISABLE_IT() inside the transmit and receive process.
     46             -@- Make sure that either:
     47                 (+@) I2S clock is configured based on SYSCLK or 
     48                 (+@) External clock source is configured after setting correctly 
     49                      the define constant EXTERNAL_CLOCK_VALUE in the stm32f3xx_hal_conf.h file. 
     50          
     51             (#) Three mode of operations are available within this driver :     
     52            
     53             *** Polling mode IO operation ***
     54             =================================
     55             [..]    
     56               (+) Send an amount of data in blocking mode using HAL_I2S_Transmit() 
     57               (+) Receive an amount of data in blocking mode using HAL_I2S_Receive()
     58             
     59             *** Interrupt mode IO operation ***    
     60             ===================================
     61             [..]    
     62               (+) Send an amount of data in non blocking mode using HAL_I2S_Transmit_IT() 
     63               (+) At transmission end of half transfer HAL_I2S_TxHalfCpltCallback is executed and user can 
     64                   add his own code by customization of function pointer HAL_I2S_TxHalfCpltCallback 
     65               (+) At transmission end of transfer HAL_I2S_TxCpltCallback is executed and user can 
     66                   add his own code by customization of function pointer HAL_I2S_TxCpltCallback
     67               (+) Receive an amount of data in non blocking mode using HAL_I2S_Receive_IT() 
     68               (+) At reception end of half transfer HAL_I2S_RxHalfCpltCallback is executed and user can 
     69                   add his own code by customization of function pointer HAL_I2S_RxHalfCpltCallback 
     70               (+) At reception end of transfer HAL_I2S_RxCpltCallback is executed and user can 
     71                   add his own code by customization of function pointer HAL_I2S_RxCpltCallback                                      
     72               (+) In case of transfer Error, HAL_I2S_ErrorCallback() function is executed and user can 
     73                   add his own code by customization of function pointer HAL_I2S_ErrorCallback
     74          
     75             *** DMA mode IO operation ***    
     76             ==============================
     77             [..] 
     78               (+) Send an amount of data in non blocking mode (DMA) using HAL_I2S_Transmit_DMA() 
     79               (+) At transmission end of half transfer HAL_I2S_TxHalfCpltCallback is executed and user can 
     80                   add his own code by customization of function pointer HAL_I2S_TxHalfCpltCallback 
     81               (+) At transmission end of transfer HAL_I2S_TxCpltCallback is executed and user can 
     82                   add his own code by customization of function pointer HAL_I2S_TxCpltCallback
     83               (+) Receive an amount of data in non blocking mode (DMA) using HAL_I2S_Receive_DMA() 
     84               (+) At reception end of half transfer HAL_I2S_RxHalfCpltCallback is executed and user can 
     85                   add his own code by customization of function pointer HAL_I2S_RxHalfCpltCallback 
     86               (+) At reception end of transfer HAL_I2S_RxCpltCallback is executed and user can 
     87                   add his own code by customization of function pointer HAL_I2S_RxCpltCallback                                     
     88               (+) In case of transfer Error, HAL_I2S_ErrorCallback() function is executed and user can 
     89                   add his own code by customization of function pointer HAL_I2S_ErrorCallback
     90               (+) Pause the DMA Transfer using HAL_I2S_DMAPause()      
     91               (+) Resume the DMA Transfer using HAL_I2S_DMAResume()  
     92               (+) Stop the DMA Transfer using HAL_I2S_DMAStop()      
     93             
     94             *** I2S HAL driver macros list ***
     95             ============================================= 
     96             [..]
     97               Below the list of most used macros in I2S HAL driver.
     98                 
     99                (+) __HAL_I2S_ENABLE: Enable the specified SPI peripheral (in I2S mode) 
    100                (+) __HAL_I2S_DISABLE: Disable the specified SPI peripheral (in I2S mode)    
    101                (+) __HAL_I2S_ENABLE_IT : Enable the specified I2S interrupts
    102                (+) __HAL_I2S_DISABLE_IT : Disable the specified I2S interrupts
    103                (+) __HAL_I2S_GET_FLAG: Check whether the specified I2S flag is set or not
    104                
    105              [..]  
    106                (@) You can refer to the I2S HAL driver header file for more useful macros
    107          
    108            @endverbatim
    109            ******************************************************************************
    110            * @attention
    111            *
    112            * <h2><center>&copy; COPYRIGHT(c) 2015 STMicroelectronics</center></h2>
    113            *
    114            * Redistribution and use in source and binary forms, with or without modification,
    115            * are permitted provided that the following conditions are met:
    116            *   1. Redistributions of source code must retain the above copyright notice,
    117            *      this list of conditions and the following disclaimer.
    118            *   2. Redistributions in binary form must reproduce the above copyright notice,
    119            *      this list of conditions and the following disclaimer in the documentation
    120            *      and/or other materials provided with the distribution.
    121            *   3. Neither the name of STMicroelectronics nor the names of its contributors
    122            *      may be used to endorse or promote products derived from this software
    123            *      without specific prior written permission.
    124            *
    125            * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
    126            * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
    127            * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
    128            * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
    129            * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
    130            * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
    131            * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
    132            * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
    133            * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
    134            * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
    135            *
    136            ******************************************************************************
    137            */ 
    138          
    139          /* Includes ------------------------------------------------------------------*/
    140          #include "stm32f7xx_hal.h"
    141          
    142          /** @addtogroup STM32F7xx_HAL_Driver
    143            * @{
    144            */
    145          
    146          /** @defgroup I2S I2S
    147            * @brief I2S HAL module driver
    148            * @{
    149            */
    150          
    151          #ifdef HAL_I2S_MODULE_ENABLED
    152          
    153          /* Private typedef -----------------------------------------------------------*/
    154          /* Private define ------------------------------------------------------------*/
    155          /* Private macro -------------------------------------------------------------*/
    156          /* Private variables ---------------------------------------------------------*/
    157          /* Private function prototypes -----------------------------------------------*/
    158          /** @defgroup I2S_Private_Functions I2S Private Functions
    159            * @{
    160            */
    161          static void I2S_DMATxCplt(DMA_HandleTypeDef *hdma);
    162          static void I2S_DMATxHalfCplt(DMA_HandleTypeDef *hdma);
    163          static void I2S_DMARxCplt(DMA_HandleTypeDef *hdma);
    164          static void I2S_DMARxHalfCplt(DMA_HandleTypeDef *hdma);
    165          static void I2S_DMAError(DMA_HandleTypeDef *hdma);
    166          static void I2S_Transmit_IT(I2S_HandleTypeDef *hi2s);
    167          static void I2S_Receive_IT(I2S_HandleTypeDef *hi2s);
    168          static uint32_t I2S_GetClockFreq(I2S_HandleTypeDef *hi2s);
    169          static HAL_StatusTypeDef I2S_WaitFlagStateUntilTimeout(I2S_HandleTypeDef *hi2s, uint32_t Flag, uint32_t State, uint32_t Timeout);
    170          /**
    171            * @}
    172            */
    173          
    174          /* Exported functions ---------------------------------------------------------*/
    175          
    176          /** @defgroup I2S_Exported_Functions I2S Exported Functions
    177            * @{
    178            */
    179          
    180          /** @defgroup  I2S_Exported_Functions_Group1 Initialization and de-initialization functions 
    181            *  @brief    Initialization and Configuration functions 
    182            *
    183          @verbatim    
    184           ===============================================================================
    185                        ##### Initialization and de-initialization functions #####
    186           ===============================================================================
    187              [..]  This subsection provides a set of functions allowing to initialize and 
    188                    de-initialize the I2Sx peripheral in simplex mode:
    189          
    190                (+) User must Implement HAL_I2S_MspInit() function in which he configures 
    191                    all related peripherals resources (CLOCK, GPIO, DMA, IT and NVIC ).
    192          
    193                (+) Call the function HAL_I2S_Init() to configure the selected device with 
    194                    the selected configuration:
    195                  (++) Mode
    196                  (++) Standard 
    197                  (++) Data Format
    198                  (++) MCLK Output
    199                  (++) Audio frequency
    200                  (++) Polarity
    201                  (++) Full duplex mode
    202          
    203                (+) Call the function HAL_I2S_DeInit() to restore the default configuration 
    204                    of the selected I2Sx peripheral. 
    205          @endverbatim
    206            * @{
    207            */
    208          
    209          /**
    210            * @brief Initializes the I2S according to the specified parameters 
    211            *         in the I2S_InitTypeDef and create the associated handle.
    212            * @param  hi2s: pointer to a I2S_HandleTypeDef structure that contains
    213            *         the configuration information for I2S module
    214            * @retval HAL status
    215            */

   \                                 In section .text, align 2, keep-with-next
    216          HAL_StatusTypeDef HAL_I2S_Init(I2S_HandleTypeDef *hi2s)
    217          {
   \                     HAL_I2S_Init: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
    218            uint16_t tmpreg = 0, i2sdiv = 2, i2sodd = 0, packetlength = 1;
   \   00000004   0x2601             MOVS     R6,#+1
    219            uint32_t tmp = 0, i2sclk = 0;
    220           
    221            /* Check the I2S handle allocation */
    222            if(hi2s == NULL)
   \   00000006   0xB90C             CBNZ.N   R4,??HAL_I2S_Init_0
    223            {
    224              return HAL_ERROR;
   \   00000008   0x2001             MOVS     R0,#+1
   \   0000000A   0xBDF2             POP      {R1,R4-R7,PC}
    225            }
    226            
    227            /* Check the parameters */
    228            assert_param(IS_I2S_ALL_INSTANCE(hi2s->Instance));
    229            assert_param(IS_I2S_MODE(hi2s->Init.Mode));
    230            assert_param(IS_I2S_STANDARD(hi2s->Init.Standard));
    231            assert_param(IS_I2S_DATA_FORMAT(hi2s->Init.DataFormat));
    232            assert_param(IS_I2S_MCLK_OUTPUT(hi2s->Init.MCLKOutput));
    233            assert_param(IS_I2S_AUDIO_FREQ(hi2s->Init.AudioFreq));
    234            assert_param(IS_I2S_CPOL(hi2s->Init.CPOL));  
    235            assert_param(IS_I2S_CLOCKSOURCE(hi2s->Init.ClockSource));
    236            
    237            if(hi2s->State == HAL_I2S_STATE_RESET)
   \                     ??HAL_I2S_Init_0: (+1)
   \   0000000C   0xF104 0x0538      ADD      R5,R4,#+56
   \   00000010   0x7868             LDRB     R0,[R5, #+1]
   \   00000012   0xB918             CBNZ.N   R0,??HAL_I2S_Init_1
    238            {
    239              /* Allocate lock resource and initialize it */
    240              hi2s->Lock = HAL_UNLOCKED;
   \   00000014   0x7028             STRB     R0,[R5, #+0]
    241              /* Init the low level hardware : GPIO, CLOCK, CORTEX...etc */
    242              HAL_I2S_MspInit(hi2s);
   \   00000016   0x4620             MOV      R0,R4
   \   00000018   0x.... 0x....      BL       HAL_I2S_MspInit
    243            }
    244            
    245            hi2s->State = HAL_I2S_STATE_BUSY;
   \                     ??HAL_I2S_Init_1: (+1)
   \   0000001C   0x2002             MOVS     R0,#+2
    246              
    247            /*----------------------- SPIx I2SCFGR & I2SPR Configuration -----------------*/
    248            /* Clear I2SMOD, I2SE, I2SCFG, PCMSYNC, I2SSTD, CKPOL, DATLEN and CHLEN bits */
    249            hi2s->Instance->I2SCFGR &= ~(SPI_I2SCFGR_CHLEN | SPI_I2SCFGR_DATLEN | SPI_I2SCFGR_CKPOL | \
    250                                         SPI_I2SCFGR_I2SSTD | SPI_I2SCFGR_PCMSYNC | SPI_I2SCFGR_I2SCFG | \
    251                                         SPI_I2SCFGR_I2SE | SPI_I2SCFGR_I2SMOD); 
   \   0000001E   0x....             LDR.N    R2,??DataTable0  ;; 0xfffff040
   \   00000020   0x7068             STRB     R0,[R5, #+1]
   \   00000022   0x6820             LDR      R0,[R4, #+0]
   \   00000024   0x69C1             LDR      R1,[R0, #+28]
   \   00000026   0x4011             ANDS     R1,R2,R1
   \   00000028   0x61C1             STR      R1,[R0, #+28]
    252            hi2s->Instance->I2SPR = 0x0002;
   \   0000002A   0x6821             LDR      R1,[R4, #+0]
   \   0000002C   0x2002             MOVS     R0,#+2
   \   0000002E   0x6208             STR      R0,[R1, #+32]
    253            
    254            /* Get the I2SCFGR register value */
    255            tmpreg = hi2s->Instance->I2SCFGR;
   \   00000030   0x6820             LDR      R0,[R4, #+0]
   \   00000032   0x69C1             LDR      R1,[R0, #+28]
    256            
    257            /* If the default value has to be written, reinitialize i2sdiv and i2sodd*/
    258            if(hi2s->Init.AudioFreq == I2S_AUDIOFREQ_DEFAULT)
   \   00000034   0x6962             LDR      R2,[R4, #+20]
   \   00000036   0x2A02             CMP      R2,#+2
   \   00000038   0xD102             BNE.N    ??HAL_I2S_Init_2
    259            {
    260              i2sodd = (uint16_t)0;
   \   0000003A   0x2200             MOVS     R2,#+0
    261              i2sdiv = (uint16_t)2;   
   \   0000003C   0x2302             MOVS     R3,#+2
   \   0000003E   0xE03D             B.N      ??HAL_I2S_Init_3
    262            }
    263            /* If the requested audio frequency is not the default, compute the prescaler */
    264            else
    265            {
    266              /* Check the frame length (For the Prescaler computing) *******************/
    267              if(hi2s->Init.DataFormat == I2S_DATAFORMAT_16B)
   \                     ??HAL_I2S_Init_2: (+1)
   \   00000040   0x68E3             LDR      R3,[R4, #+12]
   \   00000042   0xB103             CBZ.N    R3,??HAL_I2S_Init_4
    268              {
    269                /* Packet length is 16 bits */
    270                packetlength = 1;
    271              }
    272              else
    273              {
    274                /* Packet length is 32 bits */
    275                packetlength = 2;
   \   00000044   0x2602             MOVS     R6,#+2
    276              }
    277              
    278              /* Get I2S source Clock frequency  ****************************************/
    279          
    280              /* If an external I2S clock has to be used, the specific define should be set  
    281              in the project configuration or in the stm32f3xx_conf.h file */
    282              if(hi2s->Init.ClockSource == I2S_CLOCK_EXTERNAL)
   \                     ??HAL_I2S_Init_4: (+1)
   \   00000046   0x69E3             LDR      R3,[R4, #+28]
   \   00000048   0x....             LDR.N    R7,??DataTable0_1  ;; 0xbb8000
   \   0000004A   0x2B01             CMP      R3,#+1
   \   0000004C   0xD01E             BEQ.N    ??HAL_I2S_Init_5
    283              {    
    284                /* Set the I2S clock to the external clock  value */
    285                i2sclk = EXTERNAL_CLOCK_VALUE;
    286              }
    287              else
    288              {
    289                /* Get the I2S source clock value */
    290          			i2sclk = I2S_GetClockFreq(hi2s);
   \   0000004E   0xF04F 0x0C00      MOV      R12,#+0
   \   00000052   0xD002             BEQ.N    ??HAL_I2S_Init_6
   \   00000054   0x2B02             CMP      R3,#+2
   \   00000056   0xD002             BEQ.N    ??HAL_I2S_Init_7
   \   00000058   0xE017             B.N      ??HAL_I2S_Init_8
   \                     ??HAL_I2S_Init_6: (+1)
   \   0000005A   0x46BC             MOV      R12,R7
   \   0000005C   0xE015             B.N      ??HAL_I2S_Init_8
   \                     ??HAL_I2S_Init_7: (+1)
   \   0000005E   0x....             LDR.N    R3,??DataTable0_2  ;; 0x40023804
   \   00000060   0x681F             LDR      R7,[R3, #+0]
   \   00000062   0x027F             LSLS     R7,R7,#+9
   \   00000064   0xBF54             ITE      PL 
   \   00000066   0x....             LDRPL.N  R7,??DataTable0_3  ;; 0xf42400
   \   00000068   0x....             LDRMI.N  R7,??DataTable0_4  ;; 0x17d7840
   \   0000006A   0x681B             LDR      R3,[R3, #+0]
   \   0000006C   0xF003 0x033F      AND      R3,R3,#0x3F
   \   00000070   0xFBB7 0xF3F3      UDIV     R3,R7,R3
   \   00000074   0x....             LDR.N    R7,??DataTable0_5  ;; 0x40023884
   \   00000076   0xF8D7 0xC000      LDR      R12,[R7, #+0]
   \   0000007A   0x683F             LDR      R7,[R7, #+0]
   \   0000007C   0xF3C7 0x1788      UBFX     R7,R7,#+6,#+9
   \   00000080   0x437B             MULS     R3,R7,R3
   \   00000082   0xF3CC 0x7702      UBFX     R7,R12,#+28,#+3
   \   00000086   0xFBB3 0xFCF7      UDIV     R12,R3,R7
    291              }
   \                     ??HAL_I2S_Init_8: (+1)
   \   0000008A   0x4667             MOV      R7,R12
    292              
    293              /* Compute the Real divider depending on the MCLK output state, with a floating point */
    294              if(hi2s->Init.MCLKOutput == I2S_MCLKOUTPUT_ENABLE)
   \                     ??HAL_I2S_Init_5: (+1)
   \   0000008C   0xF8D4 0xC010      LDR      R12,[R4, #+16]
   \   00000090   0x230A             MOVS     R3,#+10
   \   00000092   0xF5BC 0x7F00      CMP      R12,#+512
   \   00000096   0xBF0E             ITEE     EQ 
   \   00000098   0x0A3E             LSREQ    R6,R7,#+8
   \   0000009A   0x0176             LSLNE    R6,R6,#+5
   \   0000009C   0xFBB7 0xF6F6      UDIVNE   R6,R7,R6
    295              {
    296                /* MCLK output is enabled */
    297                tmp = (uint16_t)(((((i2sclk / 256) * 10) / hi2s->Init.AudioFreq)) + 5);
    298              }
    299              else
    300              {
    301                /* MCLK output is disabled */
    302                tmp = (uint16_t)(((((i2sclk / (32 * packetlength)) *10 ) / hi2s->Init.AudioFreq)) + 5);
   \   000000A0   0x4373             MULS     R3,R3,R6
   \   000000A2   0xFBB3 0xF2F2      UDIV     R2,R3,R2
   \   000000A6   0x1D52             ADDS     R2,R2,#+5
   \   000000A8   0xB292             UXTH     R2,R2
    303              }
    304              
    305              /* Remove the flatting point */
    306              tmp = tmp / 10;  
   \   000000AA   0x230A             MOVS     R3,#+10
   \   000000AC   0xFBB2 0xF2F3      UDIV     R2,R2,R3
    307              
    308              /* Check the parity of the divider */
    309              i2sodd = (uint16_t)(tmp & (uint16_t)0x0001);
   \   000000B0   0xF002 0x0601      AND      R6,R2,#0x1
    310              
    311              /* Compute the i2sdiv prescaler */
    312              i2sdiv = (uint16_t)((tmp - i2sodd) / 2);
   \   000000B4   0x1B92             SUBS     R2,R2,R6
   \   000000B6   0x03D3             LSLS     R3,R2,#+15
   \   000000B8   0x0C1B             LSRS     R3,R3,#+16
    313              
    314              /* Get the Mask for the Odd bit (SPI_I2SPR[8]) register */
    315              i2sodd = (uint16_t) (i2sodd << 8);
   \   000000BA   0x0232             LSLS     R2,R6,#+8
    316            }
    317            
    318            /* Test if the divider is 1 or 0 or greater than 0xFF */
    319            if((i2sdiv < 2) || (i2sdiv > 0xFF))
   \                     ??HAL_I2S_Init_3: (+1)
   \   000000BC   0x1E9E             SUBS     R6,R3,#+2
   \   000000BE   0x2EFE             CMP      R6,#+254
   \   000000C0   0xBF24             ITT      CS 
   \   000000C2   0x2302             MOVCS    R3,#+2
   \   000000C4   0x2200             MOVCS    R2,#+0
    320            {
    321              /* Set the default values */
    322              i2sdiv = 2;
    323              i2sodd = 0;
    324            }
    325            
    326            /* Write to SPIx I2SPR register the computed value */
    327            hi2s->Instance->I2SPR = (uint16_t)((uint16_t)i2sdiv | (uint16_t)(i2sodd | (uint16_t)hi2s->Init.MCLKOutput));
   \   000000C6   0x431A             ORRS     R2,R2,R3
   \   000000C8   0x6923             LDR      R3,[R4, #+16]
   \   000000CA   0x431A             ORRS     R2,R3,R2
   \   000000CC   0xB292             UXTH     R2,R2
   \   000000CE   0x6202             STR      R2,[R0, #+32]
    328            
    329            /* Configure the I2S with the I2S_InitStruct values */
    330            tmpreg |= (uint16_t)((uint16_t)SPI_I2SCFGR_I2SMOD | (uint16_t)(hi2s->Init.Mode | \
    331                                 (uint16_t)(hi2s->Init.Standard | (uint16_t)(hi2s->Init.DataFormat | \
    332                                 (uint16_t)hi2s->Init.CPOL))));
    333            
    334            /* Write to SPIx I2SCFGR */  
    335            hi2s->Instance->I2SCFGR = tmpreg;
   \   000000D0   0x6860             LDR      R0,[R4, #+4]
   \   000000D2   0x4308             ORRS     R0,R0,R1
   \   000000D4   0x68A1             LDR      R1,[R4, #+8]
   \   000000D6   0x4308             ORRS     R0,R1,R0
   \   000000D8   0x68E1             LDR      R1,[R4, #+12]
   \   000000DA   0x4308             ORRS     R0,R1,R0
   \   000000DC   0x69A1             LDR      R1,[R4, #+24]
   \   000000DE   0x4308             ORRS     R0,R1,R0
   \   000000E0   0xF440 0x6000      ORR      R0,R0,#0x800
   \   000000E4   0x6821             LDR      R1,[R4, #+0]
   \   000000E6   0xB280             UXTH     R0,R0
   \   000000E8   0x61C8             STR      R0,[R1, #+28]
    336            
    337            hi2s->ErrorCode = HAL_I2S_ERROR_NONE;
   \   000000EA   0x2000             MOVS     R0,#+0
   \   000000EC   0x6068             STR      R0,[R5, #+4]
    338            hi2s->State= HAL_I2S_STATE_READY;
   \   000000EE   0x2001             MOVS     R0,#+1
   \   000000F0   0x7068             STRB     R0,[R5, #+1]
    339            
    340            return HAL_OK;
   \   000000F2   0x2000             MOVS     R0,#+0
   \   000000F4   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    341          }
    342                     
    343          /**
    344            * @brief DeInitializes the I2S peripheral 
    345            * @param  hi2s: pointer to a I2S_HandleTypeDef structure that contains
    346            *         the configuration information for I2S module
    347            * @retval HAL status
    348            */

   \                                 In section .text, align 2, keep-with-next
    349          HAL_StatusTypeDef HAL_I2S_DeInit(I2S_HandleTypeDef *hi2s)
    350          {
   \                     HAL_I2S_DeInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    351            /* Check the I2S handle allocation */
    352            if(hi2s == NULL)
   \   00000002   0xB908             CBNZ.N   R0,??HAL_I2S_DeInit_0
    353            {
    354              return HAL_ERROR;
   \   00000004   0x2001             MOVS     R0,#+1
   \   00000006   0xBD10             POP      {R4,PC}
    355            }
    356            
    357            /* Check the parameters */
    358            assert_param(IS_I2S_ALL_INSTANCE(hi2s->Instance));
    359          
    360            hi2s->State = HAL_I2S_STATE_BUSY;
   \                     ??HAL_I2S_DeInit_0: (+1)
   \   00000008   0xF100 0x0438      ADD      R4,R0,#+56
   \   0000000C   0x2102             MOVS     R1,#+2
   \   0000000E   0x7061             STRB     R1,[R4, #+1]
    361            
    362            /* DeInit the low level hardware: GPIO, CLOCK, NVIC... */
    363            HAL_I2S_MspDeInit(hi2s);
   \   00000010   0x.... 0x....      BL       HAL_I2S_MspDeInit
    364            
    365            hi2s->ErrorCode = HAL_I2S_ERROR_NONE;
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0x6060             STR      R0,[R4, #+4]
    366            hi2s->State = HAL_I2S_STATE_RESET;
   \   00000018   0x7060             STRB     R0,[R4, #+1]
    367            
    368            /* Release Lock */
    369            __HAL_UNLOCK(hi2s);
   \   0000001A   0x7020             STRB     R0,[R4, #+0]
    370          
    371            return HAL_OK;
   \   0000001C   0xBD10             POP      {R4,PC}          ;; return
    372          }
    373          
    374          /**
    375            * @brief I2S MSP Init
    376            * @param  hi2s: pointer to a I2S_HandleTypeDef structure that contains
    377            *         the configuration information for I2S module
    378            * @retval None
    379            */

   \                                 In section .text, align 2, keep-with-next
    380           __weak void HAL_I2S_MspInit(I2S_HandleTypeDef *hi2s)
    381          {
    382            /* NOTE : This function Should not be modified, when the callback is needed,
    383                      the HAL_I2S_MspInit could be implemented in the user file
    384             */ 
    385          }
   \                     HAL_I2S_MspInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    386          
    387          /**
    388            * @brief I2S MSP DeInit
    389            * @param  hi2s: pointer to a I2S_HandleTypeDef structure that contains
    390            *         the configuration information for I2S module
    391            * @retval None
    392            */

   \                                 In section .text, align 2, keep-with-next
    393           __weak void HAL_I2S_MspDeInit(I2S_HandleTypeDef *hi2s)
    394          {
    395            /* NOTE : This function Should not be modified, when the callback is needed,
    396                      the HAL_I2S_MspDeInit could be implemented in the user file
    397             */ 
    398          }
   \                     HAL_I2S_MspDeInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    399          
    400          /**
    401            * @}
    402            */
    403          
    404          /** @defgroup I2S_Exported_Functions_Group2 Input and Output operation functions 
    405            *  @brief Data transfers functions 
    406            *
    407          @verbatim   
    408           ===============================================================================
    409                                ##### IO operation functions #####
    410           ===============================================================================  
    411              [..]
    412              This subsection provides a set of functions allowing to manage the I2S data 
    413              transfers.
    414          
    415              (#) There are two modes of transfer:
    416                 (++) Blocking mode : The communication is performed in the polling mode. 
    417                      The status of all data processing is returned by the same function 
    418                      after finishing transfer.  
    419                 (++) No-Blocking mode : The communication is performed using Interrupts 
    420                      or DMA. These functions return the status of the transfer startup.
    421                      The end of the data processing will be indicated through the 
    422                      dedicated I2S IRQ when using Interrupt mode or the DMA IRQ when 
    423                      using DMA mode.
    424          
    425              (#) Blocking mode functions are :
    426                  (++) HAL_I2S_Transmit()
    427                  (++) HAL_I2S_Receive()
    428                  
    429              (#) No-Blocking mode functions with Interrupt are :
    430                  (++) HAL_I2S_Transmit_IT()
    431                  (++) HAL_I2S_Receive_IT()
    432          
    433              (#) No-Blocking mode functions with DMA are :
    434                  (++) HAL_I2S_Transmit_DMA()
    435                  (++) HAL_I2S_Receive_DMA()
    436          
    437              (#) A set of Transfer Complete Callbacks are provided in non Blocking mode:
    438                  (++) HAL_I2S_TxCpltCallback()
    439                  (++) HAL_I2S_RxCpltCallback()
    440                  (++) HAL_I2S_ErrorCallback()
    441          
    442          @endverbatim
    443            * @{
    444            */
    445          
    446          /**
    447            * @brief Transmit an amount of data in blocking mode
    448            * @param  hi2s: pointer to a I2S_HandleTypeDef structure that contains
    449            *         the configuration information for I2S module
    450            * @param pData: a 16-bit pointer to data buffer.
    451            * @param Size: number of data sample to be sent:
    452            * @note When a 16-bit data frame or a 16-bit data frame extended is selected during the I2S
    453            *       configuration phase, the Size parameter means the number of 16-bit data length 
    454            *       in the transaction and when a 24-bit data frame or a 32-bit data frame is selected 
    455            *       the Size parameter means the number of 16-bit data length. 
    456            * @param  Timeout: Timeout duration
    457            * @note The I2S is kept enabled at the end of transaction to avoid the clock de-synchronization 
    458            *       between Master and Slave(example: audio streaming).
    459            * @retval HAL status
    460            */

   \                                 In section .text, align 2, keep-with-next
    461          HAL_StatusTypeDef HAL_I2S_Transmit(I2S_HandleTypeDef *hi2s, uint16_t *pData, uint16_t Size, uint32_t Timeout)
    462          {
   \                     HAL_I2S_Transmit: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x000D             MOVS     R5,R1
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x461E             MOV      R6,R3
    463            if((pData == NULL ) || (Size == 0)) 
   \   00000008   0xBF18             IT       NE 
   \   0000000A   0x2A00             CMPNE    R2,#+0
   \   0000000C   0xD03C             BEQ.N    ??HAL_I2S_Transmit_0
    464            {
    465              return  HAL_ERROR;                                    
    466            }
    467            
    468            if(hi2s->State == HAL_I2S_STATE_READY)
   \   0000000E   0xF104 0x0738      ADD      R7,R4,#+56
   \   00000012   0x7878             LDRB     R0,[R7, #+1]
   \   00000014   0x2801             CMP      R0,#+1
   \   00000016   0xD14C             BNE.N    ??HAL_I2S_Transmit_1
    469            { 
    470              if(((hi2s->Instance->I2SCFGR & (SPI_I2SCFGR_DATLEN | SPI_I2SCFGR_CHLEN)) == I2S_DATAFORMAT_24B)||\
    471                 ((hi2s->Instance->I2SCFGR & (SPI_I2SCFGR_DATLEN | SPI_I2SCFGR_CHLEN)) == I2S_DATAFORMAT_32B))
   \   00000018   0x.... 0x....      BL       ?Subroutine8
   \                     ??CrossCallReturnLabel_11: (+1)
   \   0000001C   0xBF1E             ITTT     NE 
   \   0000001E   0x69C1             LDRNE    R1,[R0, #+28]
   \   00000020   0xF001 0x0107      ANDNE    R1,R1,#0x7
   \   00000024   0x2905             CMPNE    R1,#+5
   \   00000026   0xD103             BNE.N    ??HAL_I2S_Transmit_2
    472              {
    473                hi2s->TxXferSize = (Size << 1);
   \   00000028   0x0051             LSLS     R1,R2,#+1
   \   0000002A   0x84A1             STRH     R1,[R4, #+36]
    474                hi2s->TxXferCount = (Size << 1);
   \   0000002C   0x84E1             STRH     R1,[R4, #+38]
   \   0000002E   0xE001             B.N      ??HAL_I2S_Transmit_3
    475              }
    476              else
    477              {
    478                hi2s->TxXferSize = Size;
   \                     ??HAL_I2S_Transmit_2: (+1)
   \   00000030   0x84A2             STRH     R2,[R4, #+36]
    479                hi2s->TxXferCount = Size;
   \   00000032   0x84E2             STRH     R2,[R4, #+38]
    480              }
    481              
    482              /* Process Locked */
    483              __HAL_LOCK(hi2s);
   \                     ??HAL_I2S_Transmit_3: (+1)
   \   00000034   0x7839             LDRB     R1,[R7, #+0]
   \   00000036   0x2901             CMP      R1,#+1
   \   00000038   0xD03B             BEQ.N    ??HAL_I2S_Transmit_1
   \   0000003A   0x2101             MOVS     R1,#+1
   \   0000003C   0x7039             STRB     R1,[R7, #+0]
    484              
    485              hi2s->ErrorCode = HAL_I2S_ERROR_NONE;
   \   0000003E   0x2100             MOVS     R1,#+0
   \   00000040   0x6079             STR      R1,[R7, #+4]
    486              hi2s->State = HAL_I2S_STATE_BUSY_TX;
   \   00000042   0x2103             MOVS     R1,#+3
   \   00000044   0x7079             STRB     R1,[R7, #+1]
    487             
    488              /* Check if the I2S is already enabled */ 
    489              if((hi2s->Instance->I2SCFGR &SPI_I2SCFGR_I2SE) != SPI_I2SCFGR_I2SE)
   \   00000046   0x69C1             LDR      R1,[R0, #+28]
   \   00000048   0x0549             LSLS     R1,R1,#+21
   \   0000004A   0xD401             BMI.N    ??CrossCallReturnLabel_0
    490              {
    491                /* Enable I2S peripheral */    
    492                __HAL_I2S_ENABLE(hi2s);
   \   0000004C   0x.... 0x....      BL       ?Subroutine5
    493              }
    494              
    495              while(hi2s->TxXferCount > 0)
   \                     ??CrossCallReturnLabel_0: (+1)
   \   00000050   0x6820             LDR      R0,[R4, #+0]
   \   00000052   0x8CE1             LDRH     R1,[R4, #+38]
   \   00000054   0xB1D1             CBZ.N    R1,??HAL_I2S_Transmit_4
    496              {
    497                hi2s->Instance->DR = (*pData++);
   \   00000056   0xF835 0x1B02      LDRH     R1,[R5], #+2
    498                hi2s->TxXferCount--;   
    499                /* Wait until TXE flag is set */
    500                if (I2S_WaitFlagStateUntilTimeout(hi2s, I2S_FLAG_TXE, SET, Timeout) != HAL_OK)
   \   0000005A   0x4633             MOV      R3,R6
   \   0000005C   0x2201             MOVS     R2,#+1
   \   0000005E   0x60C1             STR      R1,[R0, #+12]
   \   00000060   0x8CE0             LDRH     R0,[R4, #+38]
   \   00000062   0x2102             MOVS     R1,#+2
   \   00000064   0x1E40             SUBS     R0,R0,#+1
   \   00000066   0x84E0             STRH     R0,[R4, #+38]
   \   00000068   0x4620             MOV      R0,R4
   \   0000006A   0x.... 0x....      BL       I2S_WaitFlagStateUntilTimeout
   \   0000006E   0xB9F0             CBNZ.N   R0,??HAL_I2S_Transmit_5
    501                {
    502                  /* Set the error code and execute error callback*/
    503                  hi2s->ErrorCode |= HAL_I2S_ERROR_TIMEOUT;
    504                  HAL_I2S_ErrorCallback(hi2s);
    505                  return HAL_TIMEOUT;
    506                }
    507          
    508                /* Check if an underrun occurs */
    509                if(__HAL_I2S_GET_FLAG(hi2s, I2S_FLAG_UDR) == SET) 
   \   00000070   0x6820             LDR      R0,[R4, #+0]
   \   00000072   0x6880             LDR      R0,[R0, #+8]
   \   00000074   0x0700             LSLS     R0,R0,#+28
   \   00000076   0xD5EB             BPL.N    ??CrossCallReturnLabel_0
    510                {
    511                  /* Set the I2S State ready */
    512                  hi2s->State = HAL_I2S_STATE_READY; 
   \   00000078   0x.... 0x....      BL       ?Subroutine6
    513          
    514                  /* Process Unlocked */
    515                  __HAL_UNLOCK(hi2s);
    516          
    517                  /* Set the error code and execute error callback*/
    518                  hi2s->ErrorCode |= HAL_I2S_ERROR_UDR;
   \                     ??CrossCallReturnLabel_5: (+1)
   \   0000007C   0xF040 0x0004      ORR      R0,R0,#0x4
   \   00000080   0x6078             STR      R0,[R7, #+4]
    519                  HAL_I2S_ErrorCallback(hi2s);
   \   00000082   0x4620             MOV      R0,R4
   \   00000084   0x.... 0x....      BL       HAL_I2S_ErrorCallback
    520          
    521                  return HAL_ERROR;
   \                     ??HAL_I2S_Transmit_0: (+1)
   \   00000088   0x2001             MOVS     R0,#+1
   \   0000008A   0xBDF2             POP      {R1,R4-R7,PC}
    522                }
    523              }      
    524              
    525              /* Check if Slave mode is selected */
    526              if(((hi2s->Instance->I2SCFGR & SPI_I2SCFGR_I2SCFG) == I2S_MODE_SLAVE_TX) || ((hi2s->Instance->I2SCFGR & SPI_I2SCFGR_I2SCFG) == I2S_MODE_SLAVE_RX))
   \                     ??HAL_I2S_Transmit_4: (+1)
   \   0000008C   0x69C1             LDR      R1,[R0, #+28]
   \   0000008E   0xF411 0x7F40      TST      R1,#0x300
   \   00000092   0xBF1E             ITTT     NE 
   \   00000094   0x69C0             LDRNE    R0,[R0, #+28]
   \   00000096   0xF400 0x7040      ANDNE    R0,R0,#0x300
   \   0000009A   0xF5B0 0x7F80      CMPNE    R0,#+256
   \   0000009E   0xD107             BNE.N    ??HAL_I2S_Transmit_6
    527              {
    528                /* Wait until Busy flag is reset */
    529                if (I2S_WaitFlagStateUntilTimeout(hi2s, I2S_FLAG_BSY, RESET, Timeout) != HAL_OK) 
   \   000000A0   0x4633             MOV      R3,R6
   \   000000A2   0x2200             MOVS     R2,#+0
   \   000000A4   0x2180             MOVS     R1,#+128
   \   000000A6   0x4620             MOV      R0,R4
   \   000000A8   0x.... 0x....      BL       I2S_WaitFlagStateUntilTimeout
   \   000000AC   0xB100             CBZ.N    R0,??HAL_I2S_Transmit_6
    530                {
    531                  /* Set the error code and execute error callback*/
    532                  hi2s->ErrorCode |= HAL_I2S_ERROR_TIMEOUT;
    533                  HAL_I2S_ErrorCallback(hi2s);
    534                  return HAL_TIMEOUT;
    535                }
    536              }
   \                     ??HAL_I2S_Transmit_5: (+1)
   \   000000AE   0x....             B.N      ?Subroutine0
    537              
    538              hi2s->State = HAL_I2S_STATE_READY; 
   \                     ??HAL_I2S_Transmit_6: (+1)
   \   000000B0   0x....             B.N      ?Subroutine1
    539              
    540              /* Process Unlocked */
    541              __HAL_UNLOCK(hi2s);
    542              
    543              return HAL_OK;
    544            }
    545            else
    546            {
    547              return HAL_BUSY;
   \                     ??HAL_I2S_Transmit_1: (+1)
   \   000000B2   0x2002             MOVS     R0,#+2
   \   000000B4   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    548            }
    549          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine8: (+1)
   \   00000000   0x6820             LDR      R0,[R4, #+0]
   \   00000002   0x69C1             LDR      R1,[R0, #+28]
   \   00000004   0xF001 0x0107      AND      R1,R1,#0x7
   \   00000008   0x2903             CMP      R1,#+3
   \   0000000A   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine6: (+1)
   \   00000000   0x2001             MOVS     R0,#+1
   \   00000002   0x7078             STRB     R0,[R7, #+1]
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x7038             STRB     R0,[R7, #+0]
   \   00000008   0x6878             LDR      R0,[R7, #+4]
   \   0000000A   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \   00000000   0x2001             MOVS     R0,#+1
   \   00000002   0x7078             STRB     R0,[R7, #+1]
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x7038             STRB     R0,[R7, #+0]
   \   00000008   0xBDF2             POP      {R1,R4-R7,PC}

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \   00000000   0x6878             LDR      R0,[R7, #+4]
   \   00000002   0xF040 0x0001      ORR      R0,R0,#0x1
   \   00000006   0x6078             STR      R0,[R7, #+4]
   \   00000008   0x4620             MOV      R0,R4
   \   0000000A   0x.... 0x....      BL       HAL_I2S_ErrorCallback
   \   0000000E   0x2003             MOVS     R0,#+3
   \   00000010   0xBDF2             POP      {R1,R4-R7,PC}

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine5: (+1)
   \   00000000   0x69C1             LDR      R1,[R0, #+28]
   \   00000002   0xF441 0x6180      ORR      R1,R1,#0x400
   \   00000006   0x61C1             STR      R1,[R0, #+28]
   \   00000008   0x4770             BX       LR
    550          
    551          /**
    552            * @brief Receive an amount of data in blocking mode 
    553            * @param  hi2s: pointer to a I2S_HandleTypeDef structure that contains
    554            *         the configuration information for I2S module
    555            * @param pData: a 16-bit pointer to data buffer.
    556            * @param Size: number of data sample to be sent:
    557            * @note When a 16-bit data frame or a 16-bit data frame extended is selected during the I2S
    558            *       configuration phase, the Size parameter means the number of 16-bit data length 
    559            *       in the transaction and when a 24-bit data frame or a 32-bit data frame is selected 
    560            *       the Size parameter means the number of 16-bit data length. 
    561            * @param Timeout: Timeout duration
    562            * @note The I2S is kept enabled at the end of transaction to avoid the clock de-synchronization 
    563            *       between Master and Slave(example: audio streaming).
    564            * @note In I2S Master Receiver mode, just after enabling the peripheral the clock will be generate
    565            *       in continuous way and as the I2S is not disabled at the end of the I2S transaction.
    566            * @retval HAL status
    567            */

   \                                 In section .text, align 2, keep-with-next
    568          HAL_StatusTypeDef HAL_I2S_Receive(I2S_HandleTypeDef *hi2s, uint16_t *pData, uint16_t Size, uint32_t Timeout)
    569          {
   \                     HAL_I2S_Receive: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x000D             MOVS     R5,R1
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x461E             MOV      R6,R3
    570            if((pData == NULL ) || (Size == 0)) 
   \   00000008   0xBF18             IT       NE 
   \   0000000A   0x2A00             CMPNE    R2,#+0
   \   0000000C   0xD049             BEQ.N    ??HAL_I2S_Receive_0
    571            {
    572              return  HAL_ERROR;                                    
    573            }
    574            
    575            if(hi2s->State == HAL_I2S_STATE_READY)
   \   0000000E   0xF104 0x0738      ADD      R7,R4,#+56
   \   00000012   0x7878             LDRB     R0,[R7, #+1]
   \   00000014   0x2801             CMP      R0,#+1
   \   00000016   0xD147             BNE.N    ??HAL_I2S_Receive_1
    576            { 
    577              if(((hi2s->Instance->I2SCFGR & (SPI_I2SCFGR_DATLEN | SPI_I2SCFGR_CHLEN)) == I2S_DATAFORMAT_24B)||\
    578                 ((hi2s->Instance->I2SCFGR & (SPI_I2SCFGR_DATLEN | SPI_I2SCFGR_CHLEN)) == I2S_DATAFORMAT_32B))
   \   00000018   0x.... 0x....      BL       ?Subroutine8
   \                     ??CrossCallReturnLabel_12: (+1)
   \   0000001C   0xBF1E             ITTT     NE 
   \   0000001E   0x69C1             LDRNE    R1,[R0, #+28]
   \   00000020   0xF001 0x0107      ANDNE    R1,R1,#0x7
   \   00000024   0x2905             CMPNE    R1,#+5
   \   00000026   0xD103             BNE.N    ??HAL_I2S_Receive_2
    579              {
    580                hi2s->RxXferSize = (Size << 1);
   \   00000028   0x0051             LSLS     R1,R2,#+1
   \   0000002A   0x85A1             STRH     R1,[R4, #+44]
    581                hi2s->RxXferCount = (Size << 1);
   \   0000002C   0x85E1             STRH     R1,[R4, #+46]
   \   0000002E   0xE001             B.N      ??HAL_I2S_Receive_3
    582              }
    583              else
    584              {
    585                hi2s->RxXferSize = Size;
   \                     ??HAL_I2S_Receive_2: (+1)
   \   00000030   0x85A2             STRH     R2,[R4, #+44]
    586                hi2s->RxXferCount = Size;
   \   00000032   0x85E2             STRH     R2,[R4, #+46]
    587              }
    588              /* Process Locked */
    589              __HAL_LOCK(hi2s);
   \                     ??HAL_I2S_Receive_3: (+1)
   \   00000034   0x7839             LDRB     R1,[R7, #+0]
   \   00000036   0x2901             CMP      R1,#+1
   \   00000038   0xD036             BEQ.N    ??HAL_I2S_Receive_1
   \   0000003A   0x2101             MOVS     R1,#+1
   \   0000003C   0x7039             STRB     R1,[R7, #+0]
    590              
    591              hi2s->ErrorCode = HAL_I2S_ERROR_NONE;
   \   0000003E   0x2100             MOVS     R1,#+0
   \   00000040   0x6079             STR      R1,[R7, #+4]
    592              hi2s->State = HAL_I2S_STATE_BUSY_RX;
   \   00000042   0x2104             MOVS     R1,#+4
   \   00000044   0x7079             STRB     R1,[R7, #+1]
    593                  
    594              /* Check if the I2S is already enabled */ 
    595              if((hi2s->Instance->I2SCFGR & SPI_I2SCFGR_I2SE) != SPI_I2SCFGR_I2SE)
   \   00000046   0x69C1             LDR      R1,[R0, #+28]
   \   00000048   0x0549             LSLS     R1,R1,#+21
   \   0000004A   0xD401             BMI.N    ??CrossCallReturnLabel_1
    596              {
    597                /* Enable I2S peripheral */    
    598                __HAL_I2S_ENABLE(hi2s);
   \   0000004C   0x.... 0x....      BL       ?Subroutine5
    599              }
    600              
    601              /* Check if Master Receiver mode is selected */
    602              if((hi2s->Instance->I2SCFGR & SPI_I2SCFGR_I2SCFG) == I2S_MODE_MASTER_RX)
   \                     ??CrossCallReturnLabel_1: (+1)
   \   00000050   0x6820             LDR      R0,[R4, #+0]
   \   00000052   0x69C1             LDR      R1,[R0, #+28]
   \   00000054   0xF401 0x7140      AND      R1,R1,#0x300
   \   00000058   0xF5B1 0x7F40      CMP      R1,#+768
   \   0000005C   0xD10B             BNE.N    ??HAL_I2S_Receive_4
    603              {
    604                /* Clear the Overrun Flag by a read operation on the SPI_DR register followed by a read
    605                access to the SPI_SR register. */ 
    606                __HAL_I2S_CLEAR_OVRFLAG(hi2s);        
   \   0000005E   0x68C1             LDR      R1,[R0, #+12]
   \   00000060   0x9100             STR      R1,[SP, #+0]
   \   00000062   0x6880             LDR      R0,[R0, #+8]
   \   00000064   0x9000             STR      R0,[SP, #+0]
   \   00000066   0x9800             LDR      R0,[SP, #+0]
   \   00000068   0xE005             B.N      ??HAL_I2S_Receive_4
    607              }
    608              
    609              /* Receive data */
    610              while(hi2s->RxXferCount > 0)
    611              {
    612                /* Wait until RXNE flag is set */
    613                if (I2S_WaitFlagStateUntilTimeout(hi2s, I2S_FLAG_RXNE, SET, Timeout) != HAL_OK) 
    614                {
    615                  /* Set the error code and execute error callback*/
    616                  hi2s->ErrorCode |= HAL_I2S_ERROR_TIMEOUT;
    617                  HAL_I2S_ErrorCallback(hi2s);
    618                  return HAL_TIMEOUT;
    619                }
    620                
    621                /* Check if an overrun occurs */
    622                if(__HAL_I2S_GET_FLAG(hi2s, I2S_FLAG_OVR) == SET) 
    623                {
    624                  /* Set the I2S State ready */
    625                  hi2s->State = HAL_I2S_STATE_READY; 
    626          
    627                  /* Process Unlocked */
    628                  __HAL_UNLOCK(hi2s);
    629          
    630                  /* Set the error code and execute error callback*/
    631                  hi2s->ErrorCode |= HAL_I2S_ERROR_OVR;
    632                  HAL_I2S_ErrorCallback(hi2s);
    633          
    634                  return HAL_ERROR;
    635                }
    636          
    637                (*pData++) = hi2s->Instance->DR;
   \                     ??HAL_I2S_Receive_5: (+1)
   \   0000006A   0x68C0             LDR      R0,[R0, #+12]
   \   0000006C   0xF825 0x0B02      STRH     R0,[R5], #+2
    638                hi2s->RxXferCount--;
   \   00000070   0x8DE0             LDRH     R0,[R4, #+46]
   \   00000072   0x1E40             SUBS     R0,R0,#+1
   \   00000074   0x85E0             STRH     R0,[R4, #+46]
   \                     ??HAL_I2S_Receive_4: (+1)
   \   00000076   0x8DE0             LDRH     R0,[R4, #+46]
   \   00000078   0xB1A8             CBZ.N    R0,??HAL_I2S_Receive_6
   \   0000007A   0x4633             MOV      R3,R6
   \   0000007C   0x2201             MOVS     R2,#+1
   \   0000007E   0x2101             MOVS     R1,#+1
   \   00000080   0x4620             MOV      R0,R4
   \   00000082   0x.... 0x....      BL       I2S_WaitFlagStateUntilTimeout
   \   00000086   0xB100             CBZ.N    R0,??HAL_I2S_Receive_7
   \   00000088   0x....             B.N      ?Subroutine0
   \                     ??HAL_I2S_Receive_7: (+1)
   \   0000008A   0x6820             LDR      R0,[R4, #+0]
   \   0000008C   0x6881             LDR      R1,[R0, #+8]
   \   0000008E   0x0649             LSLS     R1,R1,#+25
   \   00000090   0xD5EB             BPL.N    ??HAL_I2S_Receive_5
   \   00000092   0x.... 0x....      BL       ?Subroutine6
   \                     ??CrossCallReturnLabel_6: (+1)
   \   00000096   0xF040 0x0002      ORR      R0,R0,#0x2
   \   0000009A   0x6078             STR      R0,[R7, #+4]
   \   0000009C   0x4620             MOV      R0,R4
   \   0000009E   0x.... 0x....      BL       HAL_I2S_ErrorCallback
   \                     ??HAL_I2S_Receive_0: (+1)
   \   000000A2   0x2001             MOVS     R0,#+1
   \   000000A4   0xBDF2             POP      {R1,R4-R7,PC}
    639              }      
    640          
    641              hi2s->State = HAL_I2S_STATE_READY; 
   \                     ??HAL_I2S_Receive_6: (+1)
   \   000000A6   0x....             B.N      ?Subroutine1
    642              
    643              /* Process Unlocked */
    644              __HAL_UNLOCK(hi2s);
    645              
    646              return HAL_OK;
    647            }
    648            else
    649            {
    650              return HAL_BUSY;
   \                     ??HAL_I2S_Receive_1: (+1)
   \   000000A8   0x2002             MOVS     R0,#+2
   \   000000AA   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    651            }
    652          }
    653          
    654          /**
    655            * @brief Transmit an amount of data in non-blocking mode with Interrupt
    656            * @param  hi2s: pointer to a I2S_HandleTypeDef structure that contains
    657            *         the configuration information for I2S module
    658            * @param pData: a 16-bit pointer to data buffer.
    659            * @param Size: number of data sample to be sent:
    660            * @note When a 16-bit data frame or a 16-bit data frame extended is selected during the I2S
    661            *       configuration phase, the Size parameter means the number of 16-bit data length 
    662            *       in the transaction and when a 24-bit data frame or a 32-bit data frame is selected 
    663            *       the Size parameter means the number of 16-bit data length. 
    664            * @note The I2S is kept enabled at the end of transaction to avoid the clock de-synchronization 
    665            *       between Master and Slave(example: audio streaming).
    666            * @retval HAL status
    667            */

   \                                 In section .text, align 2, keep-with-next
    668          HAL_StatusTypeDef HAL_I2S_Transmit_IT(I2S_HandleTypeDef *hi2s, uint16_t *pData, uint16_t Size)
    669          {
    670            if(hi2s->State == HAL_I2S_STATE_READY)
   \                     HAL_I2S_Transmit_IT: (+1)
   \   00000000   0xF100 0x0338      ADD      R3,R0,#+56
   \   00000004   0xB510             PUSH     {R4,LR}
   \   00000006   0x785C             LDRB     R4,[R3, #+1]
   \   00000008   0x2C01             CMP      R4,#+1
   \   0000000A   0xD11D             BNE.N    ??HAL_I2S_Transmit_IT_0
    671            {
    672              if((pData == NULL) || (Size == 0)) 
   \   0000000C   0x2900             CMP      R1,#+0
   \   0000000E   0xBF18             IT       NE 
   \   00000010   0x2A00             CMPNE    R2,#+0
   \   00000012   0xD101             BNE.N    ??HAL_I2S_Transmit_IT_1
    673              {
    674                return  HAL_ERROR;                                    
   \   00000014   0x2001             MOVS     R0,#+1
   \   00000016   0xBD10             POP      {R4,PC}
    675              }
    676              
    677              hi2s->pTxBuffPtr = pData;
   \                     ??HAL_I2S_Transmit_IT_1: (+1)
   \   00000018   0x6201             STR      R1,[R0, #+32]
    678              if(((hi2s->Instance->I2SCFGR & (SPI_I2SCFGR_DATLEN | SPI_I2SCFGR_CHLEN)) == I2S_DATAFORMAT_24B)||\
    679                ((hi2s->Instance->I2SCFGR & (SPI_I2SCFGR_DATLEN | SPI_I2SCFGR_CHLEN)) == I2S_DATAFORMAT_32B))
   \   0000001A   0x.... 0x....      BL       ?Subroutine9
   \                     ??CrossCallReturnLabel_13: (+1)
   \   0000001E   0xBF1D             ITTTE    NE 
   \   00000020   0x69CC             LDRNE    R4,[R1, #+28]
   \   00000022   0xF004 0x0407      ANDNE    R4,R4,#0x7
   \   00000026   0x2C05             CMPNE    R4,#+5
   \   00000028   0x0052             LSLEQ    R2,R2,#+1
    680              {
    681                hi2s->TxXferSize = (Size << 1);
    682                hi2s->TxXferCount = (Size << 1);
    683              }  
    684              else
    685              {
    686                hi2s->TxXferSize = Size;
   \   0000002A   0x8482             STRH     R2,[R0, #+36]
    687                hi2s->TxXferCount = Size;
   \   0000002C   0x84C2             STRH     R2,[R0, #+38]
    688              }
    689              
    690              /* Process Locked */
    691              __HAL_LOCK(hi2s);
   \   0000002E   0x781A             LDRB     R2,[R3, #+0]
   \   00000030   0x2A01             CMP      R2,#+1
   \   00000032   0xD009             BEQ.N    ??HAL_I2S_Transmit_IT_0
   \   00000034   0x2201             MOVS     R2,#+1
   \   00000036   0x701A             STRB     R2,[R3, #+0]
    692              
    693              hi2s->ErrorCode = HAL_I2S_ERROR_NONE;
   \   00000038   0x2200             MOVS     R2,#+0
   \   0000003A   0x605A             STR      R2,[R3, #+4]
    694              hi2s->State = HAL_I2S_STATE_BUSY_TX;
   \   0000003C   0x2203             MOVS     R2,#+3
   \   0000003E   0x705A             STRB     R2,[R3, #+1]
    695          
    696              /* Enable TXE and ERR interrupt */
    697              __HAL_I2S_ENABLE_IT(hi2s, (I2S_IT_TXE | I2S_IT_ERR));
   \   00000040   0x684A             LDR      R2,[R1, #+4]
   \   00000042   0xF042 0x02A0      ORR      R2,R2,#0xA0
   \   00000046   0x....             B.N      ?Subroutine2
    698              
    699              /* Check if the I2S is already enabled */ 
    700              if((hi2s->Instance->I2SCFGR &SPI_I2SCFGR_I2SE) != SPI_I2SCFGR_I2SE)
    701              {
    702                /* Enable I2S peripheral */    
    703                __HAL_I2S_ENABLE(hi2s);
    704              }
    705              
    706              /* Process Unlocked */
    707              __HAL_UNLOCK(hi2s);
    708              
    709              return HAL_OK;
    710            }
    711            else
    712            {
    713              return HAL_BUSY;
   \                     ??HAL_I2S_Transmit_IT_0: (+1)
   \   00000048   0x2002             MOVS     R0,#+2
   \   0000004A   0xBD10             POP      {R4,PC}          ;; return
    714            }
    715          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine9: (+1)
   \   00000000   0x6801             LDR      R1,[R0, #+0]
   \   00000002   0x69CC             LDR      R4,[R1, #+28]
   \   00000004   0xF004 0x0407      AND      R4,R4,#0x7
   \   00000008   0x2C03             CMP      R4,#+3
   \   0000000A   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine2: (+1)
   \   00000000   0x604A             STR      R2,[R1, #+4]
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x69C1             LDR      R1,[R0, #+28]
   \   00000006   0x0549             LSLS     R1,R1,#+21
   \   00000008   0xD401             BMI.N    ??CrossCallReturnLabel_4
   \   0000000A   0x.... 0x....      BL       ?Subroutine5
   \                     ??CrossCallReturnLabel_4: (+1)
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0x7018             STRB     R0,[R3, #+0]
   \   00000012   0xBD10             POP      {R4,PC}
    716          
    717          /**
    718            * @brief Receive an amount of data in non-blocking mode with Interrupt
    719            * @param  hi2s: pointer to a I2S_HandleTypeDef structure that contains
    720            *         the configuration information for I2S module
    721            * @param pData: a 16-bit pointer to the Receive data buffer.
    722            * @param Size: number of data sample to be sent:
    723            * @note When a 16-bit data frame or a 16-bit data frame extended is selected during the I2S
    724            *       configuration phase, the Size parameter means the number of 16-bit data length 
    725            *       in the transaction and when a 24-bit data frame or a 32-bit data frame is selected 
    726            *       the Size parameter means the number of 16-bit data length. 
    727            * @note The I2S is kept enabled at the end of transaction to avoid the clock de-synchronization 
    728            *       between Master and Slave(example: audio streaming).
    729            * @note It is recommended to use DMA for the I2S receiver to avoid de-synchronisation 
    730            * between Master and Slave otherwise the I2S interrupt should be optimized. 
    731            * @retval HAL status
    732            */

   \                                 In section .text, align 2, keep-with-next
    733          HAL_StatusTypeDef HAL_I2S_Receive_IT(I2S_HandleTypeDef *hi2s, uint16_t *pData, uint16_t Size)
    734          {
    735            if(hi2s->State == HAL_I2S_STATE_READY)
   \                     HAL_I2S_Receive_IT: (+1)
   \   00000000   0xF100 0x0338      ADD      R3,R0,#+56
   \   00000004   0xB510             PUSH     {R4,LR}
   \   00000006   0x785C             LDRB     R4,[R3, #+1]
   \   00000008   0x2C01             CMP      R4,#+1
   \   0000000A   0xD11D             BNE.N    ??HAL_I2S_Receive_IT_0
    736            {
    737              if((pData == NULL) || (Size == 0)) 
   \   0000000C   0x2900             CMP      R1,#+0
   \   0000000E   0xBF18             IT       NE 
   \   00000010   0x2A00             CMPNE    R2,#+0
   \   00000012   0xD101             BNE.N    ??HAL_I2S_Receive_IT_1
    738              {
    739                return  HAL_ERROR;                                    
   \   00000014   0x2001             MOVS     R0,#+1
   \   00000016   0xBD10             POP      {R4,PC}
    740              }
    741              
    742              hi2s->pRxBuffPtr = pData;
   \                     ??HAL_I2S_Receive_IT_1: (+1)
   \   00000018   0x6281             STR      R1,[R0, #+40]
    743              if(((hi2s->Instance->I2SCFGR & (SPI_I2SCFGR_DATLEN | SPI_I2SCFGR_CHLEN)) == I2S_DATAFORMAT_24B)||\
    744                ((hi2s->Instance->I2SCFGR & (SPI_I2SCFGR_DATLEN | SPI_I2SCFGR_CHLEN)) == I2S_DATAFORMAT_32B))
   \   0000001A   0x.... 0x....      BL       ?Subroutine9
   \                     ??CrossCallReturnLabel_14: (+1)
   \   0000001E   0xBF1D             ITTTE    NE 
   \   00000020   0x69CC             LDRNE    R4,[R1, #+28]
   \   00000022   0xF004 0x0407      ANDNE    R4,R4,#0x7
   \   00000026   0x2C05             CMPNE    R4,#+5
   \   00000028   0x0052             LSLEQ    R2,R2,#+1
    745              {
    746                hi2s->RxXferSize = (Size << 1);
    747                hi2s->RxXferCount = (Size << 1);
    748              }  
    749              else
    750              {
    751                hi2s->RxXferSize = Size;
   \   0000002A   0x8582             STRH     R2,[R0, #+44]
    752                hi2s->RxXferCount = Size;
   \   0000002C   0x85C2             STRH     R2,[R0, #+46]
    753              }
    754              /* Process Locked */
    755              __HAL_LOCK(hi2s);
   \   0000002E   0x781A             LDRB     R2,[R3, #+0]
   \   00000030   0x2A01             CMP      R2,#+1
   \   00000032   0xD009             BEQ.N    ??HAL_I2S_Receive_IT_0
   \   00000034   0x2201             MOVS     R2,#+1
   \   00000036   0x701A             STRB     R2,[R3, #+0]
    756              
    757              hi2s->ErrorCode = HAL_I2S_ERROR_NONE;
   \   00000038   0x2200             MOVS     R2,#+0
   \   0000003A   0x605A             STR      R2,[R3, #+4]
    758              hi2s->State = HAL_I2S_STATE_BUSY_RX;
   \   0000003C   0x2204             MOVS     R2,#+4
   \   0000003E   0x705A             STRB     R2,[R3, #+1]
    759          
    760              /* Enable TXE and ERR interrupt */
    761              __HAL_I2S_ENABLE_IT(hi2s, (I2S_IT_RXNE | I2S_IT_ERR));
   \   00000040   0x684A             LDR      R2,[R1, #+4]
   \   00000042   0xF042 0x0260      ORR      R2,R2,#0x60
   \   00000046   0x....             B.N      ?Subroutine2
    762              
    763              /* Check if the I2S is already enabled */ 
    764              if((hi2s->Instance->I2SCFGR &SPI_I2SCFGR_I2SE) != SPI_I2SCFGR_I2SE)
    765              {
    766                /* Enable I2S peripheral */    
    767                __HAL_I2S_ENABLE(hi2s);
    768              }
    769              
    770              /* Process Unlocked */
    771              __HAL_UNLOCK(hi2s);
    772              
    773              return HAL_OK;
    774            }
    775            else
    776            {
    777              return HAL_BUSY; 
   \                     ??HAL_I2S_Receive_IT_0: (+1)
   \   00000048   0x2002             MOVS     R0,#+2
   \   0000004A   0xBD10             POP      {R4,PC}          ;; return
    778            } 
    779          }
    780          
    781          /**
    782            * @brief Transmit an amount of data in non-blocking mode with DMA
    783            * @param  hi2s: pointer to a I2S_HandleTypeDef structure that contains
    784            *         the configuration information for I2S module
    785            * @param pData: a 16-bit pointer to the Transmit data buffer.
    786            * @param Size: number of data sample to be sent:
    787            * @note When a 16-bit data frame or a 16-bit data frame extended is selected during the I2S
    788            *       configuration phase, the Size parameter means the number of 16-bit data length 
    789            *       in the transaction and when a 24-bit data frame or a 32-bit data frame is selected 
    790            *       the Size parameter means the number of 16-bit data length. 
    791            * @note The I2S is kept enabled at the end of transaction to avoid the clock de-synchronization 
    792            *       between Master and Slave(example: audio streaming).
    793            * @retval HAL status
    794            */

   \                                 In section .text, align 2, keep-with-next
    795          HAL_StatusTypeDef HAL_I2S_Transmit_DMA(I2S_HandleTypeDef *hi2s, uint16_t *pData, uint16_t Size)
    796          {
    797            uint32_t *tmp;
    798            
    799            if((pData == NULL) || (Size == 0)) 
   \                     HAL_I2S_Transmit_DMA: (+1)
   \   00000000   0x2900             CMP      R1,#+0
   \   00000002   0xB538             PUSH     {R3-R5,LR}
   \   00000004   0x4605             MOV      R5,R0
   \   00000006   0xBF18             IT       NE 
   \   00000008   0x2A00             CMPNE    R2,#+0
   \   0000000A   0xD101             BNE.N    ??HAL_I2S_Transmit_DMA_0
    800            {
    801              return  HAL_ERROR;                                    
   \   0000000C   0x2001             MOVS     R0,#+1
   \   0000000E   0xBD32             POP      {R1,R4,R5,PC}
    802            }
    803            
    804            if(hi2s->State == HAL_I2S_STATE_READY)
   \                     ??HAL_I2S_Transmit_DMA_0: (+1)
   \   00000010   0xF105 0x0438      ADD      R4,R5,#+56
   \   00000014   0x7860             LDRB     R0,[R4, #+1]
   \   00000016   0x2801             CMP      R0,#+1
   \   00000018   0xD139             BNE.N    ??HAL_I2S_Transmit_DMA_1
    805            {  
    806              hi2s->pTxBuffPtr = pData;
   \   0000001A   0x6229             STR      R1,[R5, #+32]
    807              if(((hi2s->Instance->I2SCFGR & (SPI_I2SCFGR_DATLEN | SPI_I2SCFGR_CHLEN)) == I2S_DATAFORMAT_24B)||\
    808                ((hi2s->Instance->I2SCFGR & (SPI_I2SCFGR_DATLEN | SPI_I2SCFGR_CHLEN)) == I2S_DATAFORMAT_32B))
   \   0000001C   0x6828             LDR      R0,[R5, #+0]
   \   0000001E   0x69C3             LDR      R3,[R0, #+28]
   \   00000020   0xF003 0x0307      AND      R3,R3,#0x7
   \   00000024   0x2B03             CMP      R3,#+3
   \   00000026   0xBF1E             ITTT     NE 
   \   00000028   0x69C0             LDRNE    R0,[R0, #+28]
   \   0000002A   0xF000 0x0007      ANDNE    R0,R0,#0x7
   \   0000002E   0x2805             CMPNE    R0,#+5
   \   00000030   0xD103             BNE.N    ??HAL_I2S_Transmit_DMA_2
    809              {
    810                hi2s->TxXferSize = (Size << 1);
   \   00000032   0x0050             LSLS     R0,R2,#+1
   \   00000034   0x84A8             STRH     R0,[R5, #+36]
    811                hi2s->TxXferCount = (Size << 1);
   \   00000036   0x84E8             STRH     R0,[R5, #+38]
   \   00000038   0xE001             B.N      ??HAL_I2S_Transmit_DMA_3
    812              }  
    813              else
    814              {
    815                hi2s->TxXferSize = Size;
   \                     ??HAL_I2S_Transmit_DMA_2: (+1)
   \   0000003A   0x84AA             STRH     R2,[R5, #+36]
    816                hi2s->TxXferCount = Size;
   \   0000003C   0x84EA             STRH     R2,[R5, #+38]
    817              }  
    818              
    819              /* Process Locked */
    820              __HAL_LOCK(hi2s);
   \                     ??HAL_I2S_Transmit_DMA_3: (+1)
   \   0000003E   0x7820             LDRB     R0,[R4, #+0]
   \   00000040   0x2801             CMP      R0,#+1
   \   00000042   0xD024             BEQ.N    ??HAL_I2S_Transmit_DMA_1
   \   00000044   0x2001             MOVS     R0,#+1
   \   00000046   0x7020             STRB     R0,[R4, #+0]
    821              
    822              hi2s->ErrorCode = HAL_I2S_ERROR_NONE;
   \   00000048   0x2000             MOVS     R0,#+0
   \   0000004A   0x6060             STR      R0,[R4, #+4]
    823              hi2s->State = HAL_I2S_STATE_BUSY_TX;
   \   0000004C   0x2003             MOVS     R0,#+3
   \   0000004E   0x7060             STRB     R0,[R4, #+1]
    824          
    825              /* Set the I2S Tx DMA Half transfer complete callback */
    826              hi2s->hdmatx->XferHalfCpltCallback = I2S_DMATxHalfCplt;
   \   00000050   0x6B2A             LDR      R2,[R5, #+48]
   \   00000052   0x.... 0x....      ADR.W    R0,I2S_DMATxHalfCplt
   \   00000056   0x6410             STR      R0,[R2, #+64]
    827          
    828              /* Set the I2S TxDMA transfer complete callback */
    829              hi2s->hdmatx->XferCpltCallback = I2S_DMATxCplt;
   \   00000058   0x6B2A             LDR      R2,[R5, #+48]
   \   0000005A   0x.... 0x....      ADR.W    R0,I2S_DMATxCplt
   \   0000005E   0x63D0             STR      R0,[R2, #+60]
    830              
    831              /* Set the DMA error callback */
    832              hi2s->hdmatx->XferErrorCallback = I2S_DMAError;
   \   00000060   0x6B2A             LDR      R2,[R5, #+48]
   \   00000062   0x.... 0x....      ADR.W    R0,I2S_DMAError
   \   00000066   0x6490             STR      R0,[R2, #+72]
    833              
    834              /* Enable the Tx DMA Channel */
    835              tmp = (uint32_t*)&pData;
    836              HAL_DMA_Start_IT(hi2s->hdmatx, *(uint32_t*)tmp, (uint32_t)&hi2s->Instance->DR, hi2s->TxXferSize);
   \   00000068   0x8CAB             LDRH     R3,[R5, #+36]
   \   0000006A   0x6828             LDR      R0,[R5, #+0]
   \   0000006C   0xF100 0x020C      ADD      R2,R0,#+12
   \   00000070   0x6B28             LDR      R0,[R5, #+48]
   \   00000072   0x.... 0x....      BL       HAL_DMA_Start_IT
    837              
    838              /* Check if the I2S is already enabled */ 
    839              if((hi2s->Instance->I2SCFGR &SPI_I2SCFGR_I2SE) != SPI_I2SCFGR_I2SE)
   \   00000076   0x6828             LDR      R0,[R5, #+0]
   \   00000078   0x69C1             LDR      R1,[R0, #+28]
   \   0000007A   0x0549             LSLS     R1,R1,#+21
   \   0000007C   0xD401             BMI.N    ??CrossCallReturnLabel_2
    840              {
    841                /* Enable I2S peripheral */    
    842                __HAL_I2S_ENABLE(hi2s);
   \   0000007E   0x.... 0x....      BL       ?Subroutine5
    843              }
    844              
    845              /* Enable Tx DMA Request */  
    846              hi2s->Instance->CR2 |= SPI_CR2_TXDMAEN;
   \                     ??CrossCallReturnLabel_2: (+1)
   \   00000082   0x6828             LDR      R0,[R5, #+0]
   \   00000084   0x6841             LDR      R1,[R0, #+4]
   \   00000086   0xF041 0x0102      ORR      R1,R1,#0x2
   \   0000008A   0x6041             STR      R1,[R0, #+4]
    847          
    848              /* Process Unlocked */
    849              __HAL_UNLOCK(hi2s);
   \   0000008C   0x....             B.N      ?Subroutine3
    850              
    851              return HAL_OK;
    852            }
    853            else
    854            {
    855              return HAL_BUSY;
   \                     ??HAL_I2S_Transmit_DMA_1: (+1)
   \   0000008E   0x2002             MOVS     R0,#+2
   \   00000090   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    856            }
    857          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine3: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x7020             STRB     R0,[R4, #+0]
   \   00000004   0xBD32             POP      {R1,R4,R5,PC}
    858          
    859          /**
    860            * @brief Receive an amount of data in non-blocking mode with DMA 
    861            * @param  hi2s: pointer to a I2S_HandleTypeDef structure that contains
    862            *         the configuration information for I2S module
    863            * @param pData: a 16-bit pointer to the Receive data buffer.
    864            * @param Size: number of data sample to be sent:
    865            * @note When a 16-bit data frame or a 16-bit data frame extended is selected during the I2S
    866            *       configuration phase, the Size parameter means the number of 16-bit data length 
    867            *       in the transaction and when a 24-bit data frame or a 32-bit data frame is selected 
    868            *       the Size parameter means the number of 16-bit data length. 
    869            * @note The I2S is kept enabled at the end of transaction to avoid the clock de-synchronization 
    870            *       between Master and Slave(example: audio streaming).
    871            * @retval HAL status
    872            */

   \                                 In section .text, align 2, keep-with-next
    873          HAL_StatusTypeDef HAL_I2S_Receive_DMA(I2S_HandleTypeDef *hi2s, uint16_t *pData, uint16_t Size)
    874          {
    875            uint32_t *tmp;
    876            
    877            if((pData == NULL) || (Size == 0)) 
   \                     HAL_I2S_Receive_DMA: (+1)
   \   00000000   0x2900             CMP      R1,#+0
   \   00000002   0xB538             PUSH     {R3-R5,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0xBF18             IT       NE 
   \   00000008   0x2A00             CMPNE    R2,#+0
   \   0000000A   0xD101             BNE.N    ??HAL_I2S_Receive_DMA_0
    878            {
    879              return  HAL_ERROR;                                    
   \   0000000C   0x2001             MOVS     R0,#+1
   \   0000000E   0xBD32             POP      {R1,R4,R5,PC}
    880            } 
    881              
    882            if(hi2s->State == HAL_I2S_STATE_READY)
   \                     ??HAL_I2S_Receive_DMA_0: (+1)
   \   00000010   0xF104 0x0538      ADD      R5,R4,#+56
   \   00000014   0x7868             LDRB     R0,[R5, #+1]
   \   00000016   0x2801             CMP      R0,#+1
   \   00000018   0xD147             BNE.N    ??HAL_I2S_Receive_DMA_1
    883            {    
    884              hi2s->pRxBuffPtr = pData;
   \   0000001A   0x62A1             STR      R1,[R4, #+40]
    885              if(((hi2s->Instance->I2SCFGR & (SPI_I2SCFGR_DATLEN | SPI_I2SCFGR_CHLEN)) == I2S_DATAFORMAT_24B)||\
    886                ((hi2s->Instance->I2SCFGR & (SPI_I2SCFGR_DATLEN | SPI_I2SCFGR_CHLEN)) == I2S_DATAFORMAT_32B))
   \   0000001C   0x6820             LDR      R0,[R4, #+0]
   \   0000001E   0x69C3             LDR      R3,[R0, #+28]
   \   00000020   0xF003 0x0307      AND      R3,R3,#0x7
   \   00000024   0x2B03             CMP      R3,#+3
   \   00000026   0xBF1E             ITTT     NE 
   \   00000028   0x69C0             LDRNE    R0,[R0, #+28]
   \   0000002A   0xF000 0x0007      ANDNE    R0,R0,#0x7
   \   0000002E   0x2805             CMPNE    R0,#+5
   \   00000030   0xD103             BNE.N    ??HAL_I2S_Receive_DMA_2
    887              {
    888                hi2s->RxXferSize = (Size << 1);
   \   00000032   0x0050             LSLS     R0,R2,#+1
   \   00000034   0x85A0             STRH     R0,[R4, #+44]
    889                hi2s->RxXferCount = (Size << 1);
   \   00000036   0x85E0             STRH     R0,[R4, #+46]
   \   00000038   0xE001             B.N      ??HAL_I2S_Receive_DMA_3
    890              }  
    891              else
    892              {
    893                hi2s->RxXferSize = Size;
   \                     ??HAL_I2S_Receive_DMA_2: (+1)
   \   0000003A   0x85A2             STRH     R2,[R4, #+44]
    894                hi2s->RxXferCount = Size;
   \   0000003C   0x85E2             STRH     R2,[R4, #+46]
    895              }
    896              /* Process Locked */
    897              __HAL_LOCK(hi2s);
   \                     ??HAL_I2S_Receive_DMA_3: (+1)
   \   0000003E   0x7828             LDRB     R0,[R5, #+0]
   \   00000040   0x2801             CMP      R0,#+1
   \   00000042   0xD032             BEQ.N    ??HAL_I2S_Receive_DMA_1
   \   00000044   0x2001             MOVS     R0,#+1
   \   00000046   0x7028             STRB     R0,[R5, #+0]
    898              
    899              hi2s->ErrorCode = HAL_I2S_ERROR_NONE;
   \   00000048   0x2000             MOVS     R0,#+0
   \   0000004A   0x6068             STR      R0,[R5, #+4]
    900              hi2s->State = HAL_I2S_STATE_BUSY_RX;
   \   0000004C   0x2004             MOVS     R0,#+4
   \   0000004E   0x7068             STRB     R0,[R5, #+1]
    901             
    902              /* Set the I2S Rx DMA Half transfer complete callback */
    903              hi2s->hdmarx->XferHalfCpltCallback = I2S_DMARxHalfCplt;
   \   00000050   0x6B62             LDR      R2,[R4, #+52]
   \   00000052   0x.... 0x....      ADR.W    R0,I2S_DMARxHalfCplt
   \   00000056   0x6410             STR      R0,[R2, #+64]
    904          
    905              /* Set the I2S Rx DMA transfer complete callback */
    906              hi2s->hdmarx->XferCpltCallback = I2S_DMARxCplt;
   \   00000058   0x6B62             LDR      R2,[R4, #+52]
   \   0000005A   0x.... 0x....      ADR.W    R0,I2S_DMARxCplt
   \   0000005E   0x63D0             STR      R0,[R2, #+60]
    907              
    908              /* Set the DMA error callback */
    909              hi2s->hdmarx->XferErrorCallback = I2S_DMAError;
   \   00000060   0x6B62             LDR      R2,[R4, #+52]
   \   00000062   0x.... 0x....      ADR.W    R0,I2S_DMAError
   \   00000066   0x6490             STR      R0,[R2, #+72]
    910              
    911              /* Check if Master Receiver mode is selected */
    912              if((hi2s->Instance->I2SCFGR & SPI_I2SCFGR_I2SCFG) == I2S_MODE_MASTER_RX)
   \   00000068   0x6820             LDR      R0,[R4, #+0]
   \   0000006A   0x69C2             LDR      R2,[R0, #+28]
   \   0000006C   0xF402 0x7240      AND      R2,R2,#0x300
   \   00000070   0xF5B2 0x7F40      CMP      R2,#+768
   \   00000074   0xD104             BNE.N    ??HAL_I2S_Receive_DMA_4
    913              {
    914                /* Clear the Overrun Flag by a read operation to the SPI_DR register followed by a read
    915                access to the SPI_SR register. */ 
    916                __HAL_I2S_CLEAR_OVRFLAG(hi2s);        
   \   00000076   0x68C2             LDR      R2,[R0, #+12]
   \   00000078   0x9200             STR      R2,[SP, #+0]
   \   0000007A   0x6882             LDR      R2,[R0, #+8]
   \   0000007C   0x9200             STR      R2,[SP, #+0]
   \   0000007E   0x9A00             LDR      R2,[SP, #+0]
    917              }
    918              
    919              /* Enable the Rx DMA Channel */
    920              tmp = (uint32_t*)&pData;        
    921              HAL_DMA_Start_IT(hi2s->hdmarx, (uint32_t)&hi2s->Instance->DR, *(uint32_t*)tmp, hi2s->RxXferSize);
   \                     ??HAL_I2S_Receive_DMA_4: (+1)
   \   00000080   0x460A             MOV      R2,R1
   \   00000082   0x8DA3             LDRH     R3,[R4, #+44]
   \   00000084   0xF100 0x010C      ADD      R1,R0,#+12
   \   00000088   0x6B60             LDR      R0,[R4, #+52]
   \   0000008A   0x.... 0x....      BL       HAL_DMA_Start_IT
    922              
    923              /* Check if the I2S is already enabled */ 
    924              if((hi2s->Instance->I2SCFGR &SPI_I2SCFGR_I2SE) != SPI_I2SCFGR_I2SE)
   \   0000008E   0x6820             LDR      R0,[R4, #+0]
   \   00000090   0x69C1             LDR      R1,[R0, #+28]
   \   00000092   0x0549             LSLS     R1,R1,#+21
   \   00000094   0xD401             BMI.N    ??CrossCallReturnLabel_3
    925              {
    926                /* Enable I2S peripheral */    
    927                __HAL_I2S_ENABLE(hi2s);
   \   00000096   0x.... 0x....      BL       ?Subroutine5
    928              }
    929              
    930              /* Enable Rx DMA Request */  
    931              hi2s->Instance->CR2 |= SPI_CR2_RXDMAEN;
   \                     ??CrossCallReturnLabel_3: (+1)
   \   0000009A   0x6820             LDR      R0,[R4, #+0]
   \   0000009C   0x6841             LDR      R1,[R0, #+4]
   \   0000009E   0xF041 0x0101      ORR      R1,R1,#0x1
   \   000000A2   0x6041             STR      R1,[R0, #+4]
    932              
    933              /* Process Unlocked */
    934              __HAL_UNLOCK(hi2s);
   \   000000A4   0x2000             MOVS     R0,#+0
   \   000000A6   0x7028             STRB     R0,[R5, #+0]
    935          
    936              return HAL_OK;
   \   000000A8   0xBD32             POP      {R1,R4,R5,PC}
    937            }
    938            else
    939            {
    940              return HAL_BUSY;
   \                     ??HAL_I2S_Receive_DMA_1: (+1)
   \   000000AA   0x2002             MOVS     R0,#+2
   \   000000AC   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    941            }
    942          }
    943          
    944          /**
    945            * @brief Pauses the audio stream playing from the Media.
    946            * @param  hi2s: pointer to a I2S_HandleTypeDef structure that contains
    947            *         the configuration information for I2S module
    948            * @retval HAL status
    949            */

   \                                 In section .text, align 2, keep-with-next
    950          HAL_StatusTypeDef HAL_I2S_DMAPause(I2S_HandleTypeDef *hi2s)
    951          {
    952            /* Process Locked */
    953            __HAL_LOCK(hi2s);
   \                     HAL_I2S_DMAPause: (+1)
   \   00000000   0xF100 0x0138      ADD      R1,R0,#+56
   \   00000004   0x780A             LDRB     R2,[R1, #+0]
   \   00000006   0x2A01             CMP      R2,#+1
   \   00000008   0xD101             BNE.N    ??HAL_I2S_DMAPause_0
   \   0000000A   0x2002             MOVS     R0,#+2
   \   0000000C   0x4770             BX       LR
   \                     ??HAL_I2S_DMAPause_0: (+1)
   \   0000000E   0x2201             MOVS     R2,#+1
   \   00000010   0x700A             STRB     R2,[R1, #+0]
    954          
    955            if(hi2s->State == HAL_I2S_STATE_BUSY_TX)
   \   00000012   0x784A             LDRB     R2,[R1, #+1]
   \   00000014   0x2A03             CMP      R2,#+3
   \   00000016   0xD00B             BEQ.N    ??HAL_I2S_DMAPause_1
    956            {
    957              /* Disable the I2S DMA Tx request */
    958              hi2s->Instance->CR2 &= (uint32_t)(~SPI_CR2_TXDMAEN);
    959            }
    960            else if(hi2s->State == HAL_I2S_STATE_BUSY_RX)
   \   00000018   0x784A             LDRB     R2,[R1, #+1]
   \   0000001A   0x2A04             CMP      R2,#+4
   \   0000001C   0xD00D             BEQ.N    ??HAL_I2S_DMAPause_2
    961            {
    962              /* Disable the I2S DMA Rx request */
    963              hi2s->Instance->CR2 &= (uint32_t)(~SPI_CR2_RXDMAEN);
    964            }
    965            else if(hi2s->State == HAL_I2S_STATE_BUSY_TX_RX)
   \   0000001E   0x784A             LDRB     R2,[R1, #+1]
   \   00000020   0x2A05             CMP      R2,#+5
   \   00000022   0xD10F             BNE.N    ??HAL_I2S_DMAPause_3
    966            {
    967              if((hi2s->Init.Mode == I2S_MODE_SLAVE_TX)||(hi2s->Init.Mode == I2S_MODE_MASTER_TX))
   \   00000024   0x6842             LDR      R2,[R0, #+4]
   \   00000026   0x2A00             CMP      R2,#+0
   \   00000028   0xBF18             IT       NE 
   \   0000002A   0xF5B2 0x7F00      CMPNE    R2,#+512
   \   0000002E   0xD104             BNE.N    ??HAL_I2S_DMAPause_2
    968              {
    969                /* Disable the I2S DMA Tx request */
    970                hi2s->Instance->CR2 &= (uint32_t)(~SPI_CR2_TXDMAEN);
   \                     ??HAL_I2S_DMAPause_1: (+1)
   \   00000030   0x6800             LDR      R0,[R0, #+0]
   \   00000032   0x6842             LDR      R2,[R0, #+4]
   \   00000034   0xF022 0x0202      BIC      R2,R2,#0x2
   \   00000038   0xE003             B.N      ??HAL_I2S_DMAPause_4
    971              }
    972              else
    973              {
    974                /* Disable the I2S DMA Rx request */
    975                hi2s->Instance->CR2 &= (uint32_t)(~SPI_CR2_RXDMAEN);
   \                     ??HAL_I2S_DMAPause_2: (+1)
   \   0000003A   0x6800             LDR      R0,[R0, #+0]
   \   0000003C   0x6842             LDR      R2,[R0, #+4]
   \   0000003E   0x0852             LSRS     R2,R2,#+1
   \   00000040   0x0052             LSLS     R2,R2,#+1
   \                     ??HAL_I2S_DMAPause_4: (+1)
   \   00000042   0x6042             STR      R2,[R0, #+4]
    976              }
    977            }
    978          
    979            /* Process Unlocked */
    980            __HAL_UNLOCK(hi2s);
   \                     ??HAL_I2S_DMAPause_3: (+1)
   \   00000044   0x....             B.N      ?Subroutine4
    981            
    982            return HAL_OK; 
    983          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine4: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x7008             STRB     R0,[R1, #+0]
   \   00000004   0x4770             BX       LR               ;; return
    984          
    985          /**
    986            * @brief Resumes the audio stream playing from the Media.
    987            * @param  hi2s: pointer to a I2S_HandleTypeDef structure that contains
    988            *         the configuration information for I2S module
    989            * @retval HAL status
    990            */

   \                                 In section .text, align 2, keep-with-next
    991          HAL_StatusTypeDef HAL_I2S_DMAResume(I2S_HandleTypeDef *hi2s)
    992          {
    993            /* Process Locked */
    994            __HAL_LOCK(hi2s);
   \                     HAL_I2S_DMAResume: (+1)
   \   00000000   0xF100 0x0138      ADD      R1,R0,#+56
   \   00000004   0x780A             LDRB     R2,[R1, #+0]
   \   00000006   0x2A01             CMP      R2,#+1
   \   00000008   0xD101             BNE.N    ??HAL_I2S_DMAResume_0
   \   0000000A   0x2002             MOVS     R0,#+2
   \   0000000C   0x4770             BX       LR
   \                     ??HAL_I2S_DMAResume_0: (+1)
   \   0000000E   0x2201             MOVS     R2,#+1
   \   00000010   0x700A             STRB     R2,[R1, #+0]
    995            
    996            if(hi2s->State == HAL_I2S_STATE_BUSY_TX)
   \   00000012   0x784A             LDRB     R2,[R1, #+1]
   \   00000014   0x2A03             CMP      R2,#+3
   \   00000016   0xD104             BNE.N    ??HAL_I2S_DMAResume_1
    997            {
    998              /* Enable the I2S DMA Tx request */
    999              SET_BIT(hi2s->Instance->CR2, SPI_CR2_TXDMAEN);
   \   00000018   0x6802             LDR      R2,[R0, #+0]
   \   0000001A   0x6853             LDR      R3,[R2, #+4]
   \   0000001C   0xF043 0x0302      ORR      R3,R3,#0x2
   \   00000020   0xE006             B.N      ??HAL_I2S_DMAResume_2
   1000            }
   1001            else if(hi2s->State == HAL_I2S_STATE_BUSY_RX)
   \                     ??HAL_I2S_DMAResume_1: (+1)
   \   00000022   0x784A             LDRB     R2,[R1, #+1]
   \   00000024   0x2A04             CMP      R2,#+4
   \   00000026   0xD104             BNE.N    ??HAL_I2S_DMAResume_3
   1002            {
   1003              /* Enable the I2S DMA Rx request */
   1004              SET_BIT(hi2s->Instance->CR2, SPI_CR2_RXDMAEN);
   \   00000028   0x6802             LDR      R2,[R0, #+0]
   \   0000002A   0x6853             LDR      R3,[R2, #+4]
   \   0000002C   0xF043 0x0301      ORR      R3,R3,#0x1
   \                     ??HAL_I2S_DMAResume_2: (+1)
   \   00000030   0x6053             STR      R3,[R2, #+4]
   1005            }
   1006            
   1007            /* If the I2S peripheral is still not enabled, enable it */
   1008            if(HAL_IS_BIT_CLR(hi2s->Instance->I2SCFGR, SPI_I2SCFGR_I2SE))
   \                     ??HAL_I2S_DMAResume_3: (+1)
   \   00000032   0x6800             LDR      R0,[R0, #+0]
   \   00000034   0x69C2             LDR      R2,[R0, #+28]
   \   00000036   0x0552             LSLS     R2,R2,#+21
   \   00000038   0xD403             BMI.N    ??HAL_I2S_DMAResume_4
   1009            {
   1010              /* Enable I2S peripheral */    
   1011              __HAL_I2S_ENABLE(hi2s);
   \   0000003A   0x69C2             LDR      R2,[R0, #+28]
   \   0000003C   0xF442 0x6280      ORR      R2,R2,#0x400
   \   00000040   0x61C2             STR      R2,[R0, #+28]
   1012            }
   1013            
   1014            /* Process Unlocked */
   1015            __HAL_UNLOCK(hi2s);
   \                     ??HAL_I2S_DMAResume_4: (+1)
   \   00000042                      REQUIRE ?Subroutine4
   \   00000042                      ;; // Fall through to label ?Subroutine4
   1016            
   1017            return HAL_OK;
   1018          }
   1019          
   1020          /**
   1021            * @brief Stops the audio stream playing from the Media.
   1022            * @param  hi2s: pointer to a I2S_HandleTypeDef structure that contains
   1023            *         the configuration information for I2S module
   1024            * @retval HAL status
   1025            */

   \                                 In section .text, align 2, keep-with-next
   1026          HAL_StatusTypeDef HAL_I2S_DMAStop(I2S_HandleTypeDef *hi2s)
   1027          {
   \                     HAL_I2S_DMAStop: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4605             MOV      R5,R0
   1028            /* Process Locked */
   1029            __HAL_LOCK(hi2s);
   \   00000004   0xF105 0x0438      ADD      R4,R5,#+56
   \   00000008   0x7820             LDRB     R0,[R4, #+0]
   \   0000000A   0x2801             CMP      R0,#+1
   \   0000000C   0xD101             BNE.N    ??HAL_I2S_DMAStop_0
   \   0000000E   0x2002             MOVS     R0,#+2
   \   00000010   0xBD32             POP      {R1,R4,R5,PC}
   \                     ??HAL_I2S_DMAStop_0: (+1)
   \   00000012   0x2001             MOVS     R0,#+1
   \   00000014   0x7020             STRB     R0,[R4, #+0]
   1030            
   1031            /* Disable the I2S Tx/Rx DMA requests */
   1032            CLEAR_BIT(hi2s->Instance->CR2, SPI_CR2_TXDMAEN);
   \   00000016   0x6828             LDR      R0,[R5, #+0]
   \   00000018   0x6841             LDR      R1,[R0, #+4]
   \   0000001A   0xF021 0x0102      BIC      R1,R1,#0x2
   \   0000001E   0x6041             STR      R1,[R0, #+4]
   1033            CLEAR_BIT(hi2s->Instance->CR2, SPI_CR2_RXDMAEN);
   \   00000020   0x6828             LDR      R0,[R5, #+0]
   \   00000022   0x6841             LDR      R1,[R0, #+4]
   \   00000024   0x0849             LSRS     R1,R1,#+1
   \   00000026   0x0049             LSLS     R1,R1,#+1
   \   00000028   0x6041             STR      R1,[R0, #+4]
   1034            
   1035            /* Abort the I2S DMA Channel tx */
   1036            if(hi2s->hdmatx != NULL)
   \   0000002A   0x6B28             LDR      R0,[R5, #+48]
   \   0000002C   0xB120             CBZ.N    R0,??HAL_I2S_DMAStop_1
   1037            {
   1038              /* Disable the I2S DMA channel */
   1039              __HAL_DMA_DISABLE(hi2s->hdmatx);
   \   0000002E   0x.... 0x....      BL       ?Subroutine10
   1040              HAL_DMA_Abort(hi2s->hdmatx);
   \                     ??CrossCallReturnLabel_15: (+1)
   \   00000032   0x6B28             LDR      R0,[R5, #+48]
   \   00000034   0x.... 0x....      BL       HAL_DMA_Abort
   1041            }
   1042            /* Abort the I2S DMA Channel rx */
   1043            if(hi2s->hdmarx != NULL)
   \                     ??HAL_I2S_DMAStop_1: (+1)
   \   00000038   0x6B68             LDR      R0,[R5, #+52]
   \   0000003A   0xB120             CBZ.N    R0,??HAL_I2S_DMAStop_2
   1044            {
   1045              /* Disable the I2S DMA channel */
   1046              __HAL_DMA_DISABLE(hi2s->hdmarx);
   \   0000003C   0x.... 0x....      BL       ?Subroutine10
   1047              HAL_DMA_Abort(hi2s->hdmarx);
   \                     ??CrossCallReturnLabel_16: (+1)
   \   00000040   0x6B68             LDR      R0,[R5, #+52]
   \   00000042   0x.... 0x....      BL       HAL_DMA_Abort
   1048            }
   1049          
   1050            /* Disable I2S peripheral */
   1051            __HAL_I2S_DISABLE(hi2s);
   \                     ??HAL_I2S_DMAStop_2: (+1)
   \   00000046   0x6828             LDR      R0,[R5, #+0]
   \   00000048   0x69C1             LDR      R1,[R0, #+28]
   \   0000004A   0xF421 0x6180      BIC      R1,R1,#0x400
   \   0000004E   0x61C1             STR      R1,[R0, #+28]
   1052            
   1053            hi2s->State = HAL_I2S_STATE_READY;
   \   00000050   0x2001             MOVS     R0,#+1
   \   00000052   0x7060             STRB     R0,[R4, #+1]
   1054            
   1055            /* Process Unlocked */
   1056            __HAL_UNLOCK(hi2s);
   \   00000054                      REQUIRE ?Subroutine3
   \   00000054                      ;; // Fall through to label ?Subroutine3
   1057            
   1058            return HAL_OK;
   1059          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine10: (+1)
   \   00000000   0x6800             LDR      R0,[R0, #+0]
   \   00000002   0x6801             LDR      R1,[R0, #+0]
   \   00000004   0x0849             LSRS     R1,R1,#+1
   \   00000006   0x0049             LSLS     R1,R1,#+1
   \   00000008   0x6001             STR      R1,[R0, #+0]
   \   0000000A   0x4770             BX       LR
   1060          
   1061          /**
   1062            * @brief  This function handles I2S interrupt request.
   1063            * @param  hi2s: pointer to a I2S_HandleTypeDef structure that contains
   1064            *         the configuration information for I2S module
   1065            * @retval HAL status
   1066            */

   \                                 In section .text, align 2, keep-with-next
   1067          void HAL_I2S_IRQHandler(I2S_HandleTypeDef *hi2s)
   1068          {  
   \                     HAL_I2S_IRQHandler: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0xB082             SUB      SP,SP,#+8
   1069            __IO uint32_t i2ssr = hi2s->Instance->SR;
   \   00000006   0x6820             LDR      R0,[R4, #+0]
   \   00000008   0x6881             LDR      R1,[R0, #+8]
   \   0000000A   0x9100             STR      R1,[SP, #+0]
   1070          
   1071            if(hi2s->State == HAL_I2S_STATE_BUSY_RX)
   \   0000000C   0xF894 0x1039      LDRB     R1,[R4, #+57]
   \   00000010   0x2904             CMP      R1,#+4
   \   00000012   0xD122             BNE.N    ??HAL_I2S_IRQHandler_0
   1072            {  
   1073              /* I2S in mode Receiver ----------------------------------------------------*/
   1074              if(((i2ssr & I2S_FLAG_RXNE) == I2S_FLAG_RXNE) && (__HAL_I2S_GET_IT_SOURCE(hi2s, I2S_IT_RXNE) != RESET))
   \   00000014   0x9900             LDR      R1,[SP, #+0]
   \   00000016   0x07C9             LSLS     R1,R1,#+31
   \   00000018   0xD512             BPL.N    ??HAL_I2S_IRQHandler_1
   \   0000001A   0x6841             LDR      R1,[R0, #+4]
   \   0000001C   0x0649             LSLS     R1,R1,#+25
   \   0000001E   0xD50F             BPL.N    ??HAL_I2S_IRQHandler_1
   1075              {
   1076                I2S_Receive_IT(hi2s);
   \   00000020   0x6AA1             LDR      R1,[R4, #+40]
   \   00000022   0x1C8A             ADDS     R2,R1,#+2
   \   00000024   0x62A2             STR      R2,[R4, #+40]
   \   00000026   0x68C0             LDR      R0,[R0, #+12]
   \   00000028   0x8008             STRH     R0,[R1, #+0]
   \   0000002A   0x8DE0             LDRH     R0,[R4, #+46]
   \   0000002C   0x1E40             SUBS     R0,R0,#+1
   \   0000002E   0x85E0             STRH     R0,[R4, #+46]
   \   00000030   0x8DE0             LDRH     R0,[R4, #+46]
   \   00000032   0xB928             CBNZ.N   R0,??HAL_I2S_IRQHandler_1
   \   00000034   0x6820             LDR      R0,[R4, #+0]
   \   00000036   0x.... 0x....      BL       ?Subroutine7
   1077              }
   \                     ??CrossCallReturnLabel_9: (+1)
   \   0000003A   0x4620             MOV      R0,R4
   \   0000003C   0x.... 0x....      BL       HAL_I2S_RxCpltCallback
   1078          
   1079              /* I2S Overrun error interrupt occurred -------------------------------------*/
   1080              if(((i2ssr & I2S_FLAG_OVR) == I2S_FLAG_OVR) && (__HAL_I2S_GET_IT_SOURCE(hi2s, I2S_IT_ERR) != RESET))
   \                     ??HAL_I2S_IRQHandler_1: (+1)
   \   00000040   0x9800             LDR      R0,[SP, #+0]
   \   00000042   0x0640             LSLS     R0,R0,#+25
   \   00000044   0xD539             BPL.N    ??HAL_I2S_IRQHandler_2
   \   00000046   0x6820             LDR      R0,[R4, #+0]
   \   00000048   0x6841             LDR      R1,[R0, #+4]
   \   0000004A   0x0689             LSLS     R1,R1,#+26
   \   0000004C   0xD535             BPL.N    ??HAL_I2S_IRQHandler_2
   1081              {
   1082                /* Disable RXNE and ERR interrupt */
   1083                __HAL_I2S_DISABLE_IT(hi2s, (I2S_IT_RXNE | I2S_IT_ERR));
   \   0000004E   0x.... 0x....      BL       ?Subroutine7
   1084          
   1085                /* Set the I2S State ready */
   1086                hi2s->State = HAL_I2S_STATE_READY; 
   1087          
   1088                /* Set the error code and execute error callback*/
   1089                hi2s->ErrorCode |= HAL_I2S_ERROR_OVR;
   \                     ??CrossCallReturnLabel_7: (+1)
   \   00000052   0x6BE0             LDR      R0,[R4, #+60]
   \   00000054   0xF040 0x0002      ORR      R0,R0,#0x2
   \   00000058   0xE02B             B.N      ??HAL_I2S_IRQHandler_3
   1090                HAL_I2S_ErrorCallback(hi2s);
   1091              }  
   1092            }
   1093            else if(hi2s->State == HAL_I2S_STATE_BUSY_TX)
   \                     ??HAL_I2S_IRQHandler_0: (+1)
   \   0000005A   0xF894 0x1039      LDRB     R1,[R4, #+57]
   \   0000005E   0x2903             CMP      R1,#+3
   \   00000060   0xD12B             BNE.N    ??HAL_I2S_IRQHandler_2
   1094            {  
   1095              /* I2S in mode Transmitter ---------------------------------------------------*/
   1096              if(((i2ssr & I2S_FLAG_TXE) == I2S_FLAG_TXE) && (__HAL_I2S_GET_IT_SOURCE(hi2s, I2S_IT_TXE) != RESET))
   \   00000062   0x9900             LDR      R1,[SP, #+0]
   \   00000064   0x0789             LSLS     R1,R1,#+30
   \   00000066   0xD515             BPL.N    ??HAL_I2S_IRQHandler_4
   \   00000068   0x6841             LDR      R1,[R0, #+4]
   \   0000006A   0x0609             LSLS     R1,R1,#+24
   \   0000006C   0xD512             BPL.N    ??HAL_I2S_IRQHandler_4
   1097              {     
   1098                I2S_Transmit_IT(hi2s);
   \   0000006E   0x6A21             LDR      R1,[R4, #+32]
   \   00000070   0x1C8A             ADDS     R2,R1,#+2
   \   00000072   0x6222             STR      R2,[R4, #+32]
   \   00000074   0x8809             LDRH     R1,[R1, #+0]
   \   00000076   0x60C1             STR      R1,[R0, #+12]
   \   00000078   0x8CE0             LDRH     R0,[R4, #+38]
   \   0000007A   0x1E40             SUBS     R0,R0,#+1
   \   0000007C   0x84E0             STRH     R0,[R4, #+38]
   \   0000007E   0x8CE0             LDRH     R0,[R4, #+38]
   \   00000080   0xB940             CBNZ.N   R0,??HAL_I2S_IRQHandler_4
   \   00000082   0x6820             LDR      R0,[R4, #+0]
   \   00000084   0x6841             LDR      R1,[R0, #+4]
   \   00000086   0xF021 0x01A0      BIC      R1,R1,#0xA0
   \   0000008A   0x.... 0x....      BL       ??Subroutine7_0
   1099              } 
   \                     ??CrossCallReturnLabel_10: (+1)
   \   0000008E   0x4620             MOV      R0,R4
   \   00000090   0x.... 0x....      BL       HAL_I2S_TxCpltCallback
   1100              
   1101              /* I2S Underrun error interrupt occurred ------------------------------------*/
   1102              if(((i2ssr & I2S_FLAG_UDR) == I2S_FLAG_UDR) && (__HAL_I2S_GET_IT_SOURCE(hi2s, I2S_IT_ERR) != RESET))
   \                     ??HAL_I2S_IRQHandler_4: (+1)
   \   00000094   0x9800             LDR      R0,[SP, #+0]
   \   00000096   0x0700             LSLS     R0,R0,#+28
   \   00000098   0xD50F             BPL.N    ??HAL_I2S_IRQHandler_2
   \   0000009A   0x6820             LDR      R0,[R4, #+0]
   \   0000009C   0x6841             LDR      R1,[R0, #+4]
   \   0000009E   0x0689             LSLS     R1,R1,#+26
   \   000000A0   0xD50B             BPL.N    ??HAL_I2S_IRQHandler_2
   1103              {
   1104                /* Disable TXE and ERR interrupt */
   1105                __HAL_I2S_DISABLE_IT(hi2s, (I2S_IT_TXE | I2S_IT_ERR));
   \   000000A2   0x6841             LDR      R1,[R0, #+4]
   \   000000A4   0xF021 0x01A0      BIC      R1,R1,#0xA0
   \   000000A8   0x.... 0x....      BL       ??Subroutine7_0
   1106          
   1107                /* Set the I2S State ready */
   1108                hi2s->State = HAL_I2S_STATE_READY; 
   1109          
   1110                /* Set the error code and execute error callback*/
   1111                hi2s->ErrorCode |= HAL_I2S_ERROR_UDR;
   \                     ??CrossCallReturnLabel_8: (+1)
   \   000000AC   0x6BE0             LDR      R0,[R4, #+60]
   \   000000AE   0xF040 0x0004      ORR      R0,R0,#0x4
   \                     ??HAL_I2S_IRQHandler_3: (+1)
   \   000000B2   0x63E0             STR      R0,[R4, #+60]
   1112                HAL_I2S_ErrorCallback(hi2s);
   \   000000B4   0x4620             MOV      R0,R4
   \   000000B6   0x.... 0x....      BL       HAL_I2S_ErrorCallback
   1113              }
   1114            }
   1115          }
   \                     ??HAL_I2S_IRQHandler_2: (+1)
   \   000000BA   0xBD13             POP      {R0,R1,R4,PC}    ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine7: (+1)
   \   00000000   0x6841             LDR      R1,[R0, #+4]
   \   00000002   0xF021 0x0160      BIC      R1,R1,#0x60
   \                     ??Subroutine7_0: (+1)
   \   00000006   0x6041             STR      R1,[R0, #+4]
   \   00000008   0x2001             MOVS     R0,#+1
   \   0000000A   0xF884 0x0039      STRB     R0,[R4, #+57]
   \   0000000E   0x4770             BX       LR
   1116          
   1117          /**
   1118            * @}
   1119            */
   1120          
   1121          /**
   1122            * @}
   1123            */
   1124          
   1125          /** @addtogroup I2S_Private_Functions I2S Private Functions
   1126            * @{
   1127            */
   1128          /**
   1129            * @brief This function handles I2S Communication Timeout.
   1130            * @param  hi2s: pointer to a I2S_HandleTypeDef structure that contains
   1131            *         the configuration information for I2S module
   1132            * @param Flag: Flag checked
   1133            * @param State: Value of the flag expected
   1134            * @param Timeout: Duration of the timeout
   1135            * @retval HAL status
   1136            */

   \                                 In section .text, align 2, keep-with-next
   1137          static HAL_StatusTypeDef I2S_WaitFlagStateUntilTimeout(I2S_HandleTypeDef *hi2s, uint32_t Flag, 
   1138                                                                 uint32_t State, uint32_t Timeout)
   1139          {
   \                     I2S_WaitFlagStateUntilTimeout: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
   \   00000008   0x4690             MOV      R8,R2
   \   0000000A   0x461E             MOV      R6,R3
   1140            uint32_t tickstart = 0;
   1141            
   1142            /* Get tick */
   1143            tickstart = HAL_GetTick();
   \   0000000C   0x.... 0x....      BL       HAL_GetTick
   1144            
   1145            /* Wait until flag is set */
   1146            if(State == RESET)
   \   00000010   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000014   0x4607             MOV      R7,R0
   \   00000016   0xD10E             BNE.N    ??I2S_WaitFlagStateUntilTimeout_0
   1147            {
   1148              while(__HAL_I2S_GET_FLAG(hi2s, Flag) == RESET)
   \                     ??I2S_WaitFlagStateUntilTimeout_1: (+1)
   \   00000018   0x6820             LDR      R0,[R4, #+0]
   \   0000001A   0x6880             LDR      R0,[R0, #+8]
   \   0000001C   0x4028             ANDS     R0,R5,R0
   \   0000001E   0x42A8             CMP      R0,R5
   \   00000020   0xD01F             BEQ.N    ??I2S_WaitFlagStateUntilTimeout_2
   1149              {
   1150                if(Timeout != HAL_MAX_DELAY)
   \   00000022   0xF116 0x0F01      CMN      R6,#+1
   \   00000026   0xD0F7             BEQ.N    ??I2S_WaitFlagStateUntilTimeout_1
   1151                {
   1152                  if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
   \   00000028   0xB19E             CBZ.N    R6,??I2S_WaitFlagStateUntilTimeout_3
   \   0000002A   0x.... 0x....      BL       HAL_GetTick
   \   0000002E   0x1BC0             SUBS     R0,R0,R7
   \   00000030   0x4286             CMP      R6,R0
   \   00000032   0xD2F1             BCS.N    ??I2S_WaitFlagStateUntilTimeout_1
   \   00000034   0xE00D             B.N      ??I2S_WaitFlagStateUntilTimeout_3
   1153                  {
   1154                    /* Set the I2S State ready */
   1155                    hi2s->State= HAL_I2S_STATE_READY;
   1156          
   1157                    /* Process Unlocked */
   1158                    __HAL_UNLOCK(hi2s);
   1159          
   1160                    return HAL_TIMEOUT;
   1161                  }
   1162                }
   1163              }
   1164            }
   1165            else
   1166            {
   1167              while(__HAL_I2S_GET_FLAG(hi2s, Flag) != RESET)
   \                     ??I2S_WaitFlagStateUntilTimeout_0: (+1)
   \   00000036   0x6820             LDR      R0,[R4, #+0]
   \   00000038   0x6880             LDR      R0,[R0, #+8]
   \   0000003A   0x4028             ANDS     R0,R5,R0
   \   0000003C   0x42A8             CMP      R0,R5
   \   0000003E   0xD110             BNE.N    ??I2S_WaitFlagStateUntilTimeout_2
   1168              {
   1169                if(Timeout != HAL_MAX_DELAY)
   \   00000040   0xF116 0x0F01      CMN      R6,#+1
   \   00000044   0xD0F7             BEQ.N    ??I2S_WaitFlagStateUntilTimeout_0
   1170                {
   1171                  if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
   \   00000046   0xB126             CBZ.N    R6,??I2S_WaitFlagStateUntilTimeout_3
   \   00000048   0x.... 0x....      BL       HAL_GetTick
   \   0000004C   0x1BC0             SUBS     R0,R0,R7
   \   0000004E   0x4286             CMP      R6,R0
   \   00000050   0xD2F1             BCS.N    ??I2S_WaitFlagStateUntilTimeout_0
   1172                  {
   1173                    /* Set the I2S State ready */
   1174                    hi2s->State= HAL_I2S_STATE_READY;
   \                     ??I2S_WaitFlagStateUntilTimeout_3: (+1)
   \   00000052   0xF104 0x0038      ADD      R0,R4,#+56
   \   00000056   0x2101             MOVS     R1,#+1
   \   00000058   0x7041             STRB     R1,[R0, #+1]
   1175          
   1176                    /* Process Unlocked */
   1177                    __HAL_UNLOCK(hi2s);
   \   0000005A   0x2100             MOVS     R1,#+0
   \   0000005C   0x7001             STRB     R1,[R0, #+0]
   1178          
   1179                    return HAL_TIMEOUT;
   \   0000005E   0x2003             MOVS     R0,#+3
   \   00000060   0xE000             B.N      ??I2S_WaitFlagStateUntilTimeout_4
   1180                  }
   1181                }
   1182              }
   1183            }
   1184            return HAL_OK;    
   \                     ??I2S_WaitFlagStateUntilTimeout_2: (+1)
   \   00000062   0x2000             MOVS     R0,#+0
   \                     ??I2S_WaitFlagStateUntilTimeout_4: (+1)
   \   00000064   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   1185          }
   1186          /**
   1187            * @}
   1188            */
   1189          
   1190          /** @addtogroup I2S_Exported_Functions I2S Exported Functions
   1191            * @{
   1192            */
   1193          
   1194          /** @addtogroup  I2S_Exported_Functions_Group2 Input and Output operation functions 
   1195            * @{
   1196            */
   1197          /**
   1198            * @brief Tx Transfer Half completed callbacks
   1199            * @param  hi2s: pointer to a I2S_HandleTypeDef structure that contains
   1200            *         the configuration information for I2S module
   1201            * @retval None
   1202            */

   \                                 In section .text, align 2, keep-with-next
   1203           __weak void HAL_I2S_TxHalfCpltCallback(I2S_HandleTypeDef *hi2s)
   1204          {
   1205            /* NOTE : This function Should not be modified, when the callback is needed,
   1206                      the HAL_I2S_TxHalfCpltCallback could be implemented in the user file
   1207             */ 
   1208          }
   \                     HAL_I2S_TxHalfCpltCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1209          
   1210          /**
   1211            * @brief Tx Transfer completed callbacks
   1212            * @param  hi2s: pointer to a I2S_HandleTypeDef structure that contains
   1213            *         the configuration information for I2S module
   1214            * @retval None
   1215            */

   \                                 In section .text, align 2, keep-with-next
   1216           __weak void HAL_I2S_TxCpltCallback(I2S_HandleTypeDef *hi2s)
   1217          {
   1218            /* NOTE : This function Should not be modified, when the callback is needed,
   1219                      the HAL_I2S_TxCpltCallback could be implemented in the user file
   1220             */ 
   1221          }
   \                     HAL_I2S_TxCpltCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1222          
   1223          /**
   1224            * @brief Rx Transfer half completed callbacks
   1225            * @param  hi2s: pointer to a I2S_HandleTypeDef structure that contains
   1226            *         the configuration information for I2S module
   1227            * @retval None
   1228            */

   \                                 In section .text, align 2, keep-with-next
   1229          __weak void HAL_I2S_RxHalfCpltCallback(I2S_HandleTypeDef *hi2s)
   1230          {
   1231            /* NOTE : This function Should not be modified, when the callback is needed,
   1232                      the HAL_I2S_RxCpltCallback could be implemented in the user file
   1233             */
   1234          }
   \                     HAL_I2S_RxHalfCpltCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1235          
   1236          /**
   1237            * @brief Rx Transfer completed callbacks
   1238            * @param  hi2s: pointer to a I2S_HandleTypeDef structure that contains
   1239            *         the configuration information for I2S module
   1240            * @retval None
   1241            */

   \                                 In section .text, align 2, keep-with-next
   1242          __weak void HAL_I2S_RxCpltCallback(I2S_HandleTypeDef *hi2s)
   1243          {
   1244            /* NOTE : This function Should not be modified, when the callback is needed,
   1245                      the HAL_I2S_RxCpltCallback could be implemented in the user file
   1246             */
   1247          }
   \                     HAL_I2S_RxCpltCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1248          
   1249          /**
   1250            * @brief I2S error callbacks
   1251            * @param  hi2s: pointer to a I2S_HandleTypeDef structure that contains
   1252            *         the configuration information for I2S module
   1253            * @retval None
   1254            */

   \                                 In section .text, align 2, keep-with-next
   1255           __weak void HAL_I2S_ErrorCallback(I2S_HandleTypeDef *hi2s)
   1256          {
   1257            /* NOTE : This function Should not be modified, when the callback is needed,
   1258                      the HAL_I2S_ErrorCallback could be implemented in the user file
   1259             */ 
   1260          }
   \                     HAL_I2S_ErrorCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1261          
   1262          /**
   1263            * @}
   1264            */
   1265          
   1266          /** @defgroup I2S_Exported_Functions_Group3 Peripheral State and Errors functions 
   1267            *  @brief   Peripheral State functions 
   1268            *
   1269          @verbatim   
   1270           ===============================================================================
   1271                                ##### Peripheral State and Errors functions #####
   1272           ===============================================================================  
   1273              [..]
   1274              This subsection permits to get in run-time the status of the peripheral 
   1275              and the data flow.
   1276          
   1277          @endverbatim
   1278            * @{
   1279            */
   1280          
   1281          /**
   1282            * @brief  Return the I2S state
   1283            * @param  hi2s: pointer to a I2S_HandleTypeDef structure that contains
   1284            *         the configuration information for I2S module
   1285            * @retval HAL state
   1286            */

   \                                 In section .text, align 2, keep-with-next
   1287          HAL_I2S_StateTypeDef HAL_I2S_GetState(I2S_HandleTypeDef *hi2s)
   1288          {
   1289            return hi2s->State;
   \                     HAL_I2S_GetState: (+1)
   \   00000000   0xF890 0x0039      LDRB     R0,[R0, #+57]
   \   00000004   0x4770             BX       LR               ;; return
   1290          }
   1291          
   1292          /**
   1293            * @brief  Return the I2S error code
   1294            * @param  hi2s: pointer to a I2S_HandleTypeDef structure that contains
   1295            *         the configuration information for I2S module
   1296            * @retval I2S Error Code
   1297            */

   \                                 In section .text, align 2, keep-with-next
   1298          uint32_t HAL_I2S_GetError(I2S_HandleTypeDef *hi2s)
   1299          {
   1300            return hi2s->ErrorCode;
   \                     HAL_I2S_GetError: (+1)
   \   00000000   0x6BC0             LDR      R0,[R0, #+60]
   \   00000002   0x4770             BX       LR               ;; return
   1301          }
   1302          /**
   1303            * @}
   1304            */  
   1305          
   1306          /**
   1307            * @}
   1308            */
   1309          
   1310            /**
   1311            * @brief  Get I2S Input Clock based on I2S source clock selection
   1312            * @param  hi2s: pointer to a I2S_HandleTypeDef structure that contains
   1313            *               the configuration information for I2S module.   
   1314            * @retval I2S Clock Input 
   1315            */
   1316          static uint32_t I2S_GetClockFreq(I2S_HandleTypeDef *hi2s)   
   1317          {
   1318            uint32_t tmpreg = 0;
   1319            /* This variable used to store the VCO Input (value in Hz) */
   1320            uint32_t vcoinput = 0;
   1321            /* This variable used to store the I2S_CK_x (value in Hz) */
   1322            uint32_t i2sclocksource = 0;
   1323          
   1324            /* Configure I2S Clock based on I2S source clock selection */ 
   1325            
   1326            /* I2S_CLK_x : I2S Block Clock configuration for different clock sources selected */
   1327            switch(hi2s->Init.ClockSource)
   1328            {
   1329              case I2S_CLOCK_SYSCLK :
   1330              {
   1331                /* Configure the PLLI2S division factor */
   1332                /* PLLI2S_VCO Input  = PLL_SOURCE/PLLI2SM */ 
   1333                if((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLSOURCE_HSI)
   1334                {
   1335                  /* In Case the PLL Source is HSI (Internal Clock) */
   1336                  vcoinput = (HSI_VALUE / (uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLM));
   1337                }
   1338                else
   1339                {
   1340                  /* In Case the PLL Source is HSE (External Clock) */
   1341                  vcoinput = ((HSE_VALUE / (uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLM)));
   1342                }
   1343          
   1344                /* PLLI2S_VCO Output = PLLI2S_VCO Input * PLLI2SN */
   1345                /* I2S_CLK(first level) = PLLI2S_VCO Output/PLLI2SR */
   1346                tmpreg = (RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SR) >> 28;
   1347                i2sclocksource = (vcoinput * ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SN) >> 6))/(tmpreg);
   1348              
   1349                break;
   1350              }
   1351              case I2S_CLOCK_EXTERNAL :
   1352              {
   1353                i2sclocksource = EXTERNAL_CLOCK_VALUE;
   1354                break;
   1355              }
   1356              default :
   1357              {
   1358                break;
   1359              }
   1360            }
   1361          
   1362            /* the return result is the value of I2S clock */
   1363            return i2sclocksource; 
   1364          }
   1365          
   1366          /** @addtogroup I2S_Private_Functions I2S Private Functions
   1367            * @{
   1368            */
   1369          /**
   1370            * @brief DMA I2S transmit process complete callback 
   1371            * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
   1372            *                the configuration information for the specified DMA module.
   1373            * @retval None
   1374            */

   \                                 In section .text, align 4, keep-with-next
   1375          static void I2S_DMATxCplt(DMA_HandleTypeDef *hdma)   
   1376          {
   \                     I2S_DMATxCplt: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1377            I2S_HandleTypeDef* hi2s = (I2S_HandleTypeDef*)((DMA_HandleTypeDef*)hdma)->Parent;
   \   00000002   0x6B81             LDR      R1,[R0, #+56]
   1378            
   1379            if((hdma->Instance->CR & DMA_SxCR_CIRC) == 0)
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0x05C0             LSLS     R0,R0,#+23
   \   0000000A   0xD40F             BMI.N    ??I2S_DMATxCplt_0
   1380            {
   1381              hi2s->TxXferCount = 0;
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x84C8             STRH     R0,[R1, #+38]
   1382          
   1383              /* Disable Tx DMA Request */
   1384              hi2s->Instance->CR2 &= (uint32_t)(~SPI_CR2_TXDMAEN);
   \   00000010   0x6808             LDR      R0,[R1, #+0]
   \   00000012   0x6842             LDR      R2,[R0, #+4]
   \   00000014   0xF022 0x0202      BIC      R2,R2,#0x2
   \   00000018   0x6042             STR      R2,[R0, #+4]
   1385              
   1386              if(hi2s->State == HAL_I2S_STATE_BUSY_TX_RX)
   \   0000001A   0xF891 0x0039      LDRB     R0,[R1, #+57]
   \   0000001E   0x2805             CMP      R0,#+5
   \   00000020   0xD101             BNE.N    ??I2S_DMATxCplt_1
   1387              {
   1388                if(hi2s->RxXferCount == 0)
   \   00000022   0x8DC8             LDRH     R0,[R1, #+46]
   \   00000024   0xB910             CBNZ.N   R0,??I2S_DMATxCplt_0
   1389                {
   1390                  hi2s->State = HAL_I2S_STATE_READY;
   1391                }
   1392              }
   1393              else
   1394              {
   1395                hi2s->State = HAL_I2S_STATE_READY; 
   \                     ??I2S_DMATxCplt_1: (+1)
   \   00000026   0x2001             MOVS     R0,#+1
   \   00000028   0xF881 0x0039      STRB     R0,[R1, #+57]
   1396              }
   1397            }
   1398            HAL_I2S_TxCpltCallback(hi2s);
   \                     ??I2S_DMATxCplt_0: (+1)
   \   0000002C   0x4608             MOV      R0,R1
   \   0000002E   0x.... 0x....      BL       HAL_I2S_TxCpltCallback
   1399          }
   \   00000032   0xBD01             POP      {R0,PC}          ;; return
   1400          
   1401          /**
   1402            * @brief DMA I2S transmit process half complete callback 
   1403            * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
   1404            *                the configuration information for the specified DMA module.
   1405            * @retval None
   1406            */

   \                                 In section .text, align 4, keep-with-next
   1407          static void I2S_DMATxHalfCplt(DMA_HandleTypeDef *hdma)
   1408          {
   \                     I2S_DMATxHalfCplt: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1409            I2S_HandleTypeDef* hi2s = (I2S_HandleTypeDef*)((DMA_HandleTypeDef*)hdma)->Parent;
   1410          
   1411            HAL_I2S_TxHalfCpltCallback(hi2s);
   \   00000002   0x6B80             LDR      R0,[R0, #+56]
   \   00000004   0x.... 0x....      BL       HAL_I2S_TxHalfCpltCallback
   1412          }
   \   00000008   0xBD01             POP      {R0,PC}          ;; return
   1413          
   1414          /**
   1415            * @brief DMA I2S receive process complete callback 
   1416            * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
   1417            *                the configuration information for the specified DMA module.
   1418            * @retval None
   1419            */

   \                                 In section .text, align 4, keep-with-next
   1420          static void I2S_DMARxCplt(DMA_HandleTypeDef *hdma)   
   1421          {
   \                     I2S_DMARxCplt: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1422            I2S_HandleTypeDef* hi2s = (I2S_HandleTypeDef*)((DMA_HandleTypeDef*)hdma)->Parent;
   \   00000002   0x6B81             LDR      R1,[R0, #+56]
   1423          
   1424            if((hdma->Instance->CR & DMA_SxCR_CIRC) == 0)
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0x05C0             LSLS     R0,R0,#+23
   \   0000000A   0xD40F             BMI.N    ??I2S_DMARxCplt_0
   1425            {
   1426              /* Disable Rx DMA Request */
   1427              hi2s->Instance->CR2 &= (uint32_t)(~SPI_CR2_RXDMAEN);
   \   0000000C   0x6808             LDR      R0,[R1, #+0]
   \   0000000E   0x6842             LDR      R2,[R0, #+4]
   \   00000010   0x0852             LSRS     R2,R2,#+1
   \   00000012   0x0052             LSLS     R2,R2,#+1
   \   00000014   0x6042             STR      R2,[R0, #+4]
   1428          
   1429              hi2s->RxXferCount = 0;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0x85C8             STRH     R0,[R1, #+46]
   1430              if(hi2s->State == HAL_I2S_STATE_BUSY_TX_RX)
   \   0000001A   0xF891 0x0039      LDRB     R0,[R1, #+57]
   \   0000001E   0x2805             CMP      R0,#+5
   \   00000020   0xD101             BNE.N    ??I2S_DMARxCplt_1
   1431              {
   1432                if(hi2s->TxXferCount == 0)
   \   00000022   0x8CC8             LDRH     R0,[R1, #+38]
   \   00000024   0xB910             CBNZ.N   R0,??I2S_DMARxCplt_0
   1433                {
   1434                  hi2s->State = HAL_I2S_STATE_READY;
   1435                }
   1436              }
   1437              else
   1438              {
   1439                hi2s->State = HAL_I2S_STATE_READY; 
   \                     ??I2S_DMARxCplt_1: (+1)
   \   00000026   0x2001             MOVS     R0,#+1
   \   00000028   0xF881 0x0039      STRB     R0,[R1, #+57]
   1440              }
   1441            }
   1442            HAL_I2S_RxCpltCallback(hi2s); 
   \                     ??I2S_DMARxCplt_0: (+1)
   \   0000002C   0x4608             MOV      R0,R1
   \   0000002E   0x.... 0x....      BL       HAL_I2S_RxCpltCallback
   1443          }
   \   00000032   0xBD01             POP      {R0,PC}          ;; return
   1444                
   1445          /**
   1446            * @brief DMA I2S receive process half complete callback 
   1447            * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
   1448            *                the configuration information for the specified DMA module.
   1449            * @retval None
   1450            */

   \                                 In section .text, align 4, keep-with-next
   1451          static void I2S_DMARxHalfCplt(DMA_HandleTypeDef *hdma)
   1452          {
   \                     I2S_DMARxHalfCplt: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1453            I2S_HandleTypeDef* hi2s = (I2S_HandleTypeDef*)((DMA_HandleTypeDef*)hdma)->Parent;
   1454          
   1455            HAL_I2S_RxHalfCpltCallback(hi2s); 
   \   00000002   0x6B80             LDR      R0,[R0, #+56]
   \   00000004   0x.... 0x....      BL       HAL_I2S_RxHalfCpltCallback
   1456          }
   \   00000008   0xBD01             POP      {R0,PC}          ;; return
   1457          
   1458          /**
   1459            * @brief DMA I2S communication error callback 
   1460            * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
   1461            *                the configuration information for the specified DMA module.
   1462            * @retval None
   1463            */

   \                                 In section .text, align 4, keep-with-next
   1464          static void I2S_DMAError(DMA_HandleTypeDef *hdma)   
   1465          {
   \                     I2S_DMAError: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1466            I2S_HandleTypeDef* hi2s = ( I2S_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   \   00000002   0x6B80             LDR      R0,[R0, #+56]
   1467            
   1468            /* Disable Rx and Tx DMA Request */
   1469            hi2s->Instance->CR2 &= (uint32_t)(~(SPI_CR2_RXDMAEN | SPI_CR2_TXDMAEN));
   \   00000004   0x6801             LDR      R1,[R0, #+0]
   \   00000006   0x684A             LDR      R2,[R1, #+4]
   \   00000008   0x0892             LSRS     R2,R2,#+2
   \   0000000A   0x0092             LSLS     R2,R2,#+2
   \   0000000C   0x604A             STR      R2,[R1, #+4]
   1470            hi2s->TxXferCount = 0;
   \   0000000E   0x2100             MOVS     R1,#+0
   \   00000010   0x84C1             STRH     R1,[R0, #+38]
   1471            hi2s->RxXferCount = 0;
   \   00000012   0x85C1             STRH     R1,[R0, #+46]
   1472            
   1473            hi2s->State= HAL_I2S_STATE_READY;
   \   00000014   0x2101             MOVS     R1,#+1
   \   00000016   0xF880 0x1039      STRB     R1,[R0, #+57]
   1474          
   1475            /* Set the error code and execute error callback*/
   1476            hi2s->ErrorCode |= HAL_I2S_ERROR_DMA;
   \   0000001A   0x6BC1             LDR      R1,[R0, #+60]
   \   0000001C   0xF041 0x0108      ORR      R1,R1,#0x8
   \   00000020   0x63C1             STR      R1,[R0, #+60]
   1477            HAL_I2S_ErrorCallback(hi2s);
   \   00000022   0x.... 0x....      BL       HAL_I2S_ErrorCallback
   1478          }
   \   00000026   0xBD01             POP      {R0,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0:
   \   00000000   0xFFFFF040         DC32     0xfffff040

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_1:
   \   00000000   0x00BB8000         DC32     0xbb8000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_2:
   \   00000000   0x40023804         DC32     0x40023804

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_3:
   \   00000000   0x00F42400         DC32     0xf42400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_4:
   \   00000000   0x017D7840         DC32     0x17d7840

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_5:
   \   00000000   0x40023884         DC32     0x40023884
   1479          
   1480          /**
   1481            * @brief Transmit an amount of data in non-blocking mode with Interrupt
   1482            * @param  hi2s: pointer to a I2S_HandleTypeDef structure that contains
   1483            *         the configuration information for I2S module
   1484            * @retval None
   1485            */
   1486          static void I2S_Transmit_IT(I2S_HandleTypeDef *hi2s)
   1487          {
   1488            /* Transmit data */
   1489            hi2s->Instance->DR = (*hi2s->pTxBuffPtr++);
   1490            hi2s->TxXferCount--;	
   1491          
   1492            if(hi2s->TxXferCount == 0)
   1493            {
   1494              /* Disable TXE and ERR interrupt */
   1495              __HAL_I2S_DISABLE_IT(hi2s, (I2S_IT_TXE | I2S_IT_ERR));
   1496          
   1497              hi2s->State = HAL_I2S_STATE_READY;
   1498              HAL_I2S_TxCpltCallback(hi2s);
   1499            }
   1500          }
   1501          
   1502          /**
   1503            * @brief Receive an amount of data in non-blocking mode with Interrupt
   1504            * @param hi2s: I2S handle
   1505            * @retval None
   1506            */
   1507          static void I2S_Receive_IT(I2S_HandleTypeDef *hi2s)
   1508          {
   1509            /* Receive data */    
   1510            (*hi2s->pRxBuffPtr++) = hi2s->Instance->DR;
   1511            hi2s->RxXferCount--;
   1512          
   1513            if(hi2s->RxXferCount == 0)
   1514            {    
   1515              /* Disable RXNE and ERR interrupt */
   1516              __HAL_I2S_DISABLE_IT(hi2s, (I2S_IT_RXNE | I2S_IT_ERR));
   1517          
   1518              hi2s->State = HAL_I2S_STATE_READY;     
   1519              HAL_I2S_RxCpltCallback(hi2s); 
   1520            }
   1521          }
   1522          /**
   1523            * @}
   1524            */
   1525            
   1526          #endif /* HAL_I2S_MODULE_ENABLED */
   1527          /**
   1528            * @}
   1529            */
   1530          
   1531          /**
   1532            * @}
   1533            */
   1534          
   1535          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   HAL_I2S_DMAPause
       0   HAL_I2S_DMAResume
      16   HAL_I2S_DMAStop
        16   -> HAL_DMA_Abort
       8   HAL_I2S_DeInit
         8   -> HAL_I2S_MspDeInit
       0   HAL_I2S_ErrorCallback
       0   HAL_I2S_GetError
       0   HAL_I2S_GetState
      16   HAL_I2S_IRQHandler
        16   -> HAL_I2S_ErrorCallback
        16   -> HAL_I2S_RxCpltCallback
        16   -> HAL_I2S_TxCpltCallback
      24   HAL_I2S_Init
        24   -> HAL_I2S_MspInit
       0   HAL_I2S_MspDeInit
       0   HAL_I2S_MspInit
      24   HAL_I2S_Receive
        24   -> HAL_I2S_ErrorCallback
        24   -> I2S_WaitFlagStateUntilTimeout
      16   HAL_I2S_Receive_DMA
        16   -> HAL_DMA_Start_IT
       8   HAL_I2S_Receive_IT
       0   HAL_I2S_RxCpltCallback
       0   HAL_I2S_RxHalfCpltCallback
      24   HAL_I2S_Transmit
        24   -> HAL_I2S_ErrorCallback
        24   -> I2S_WaitFlagStateUntilTimeout
      16   HAL_I2S_Transmit_DMA
        16   -> HAL_DMA_Start_IT
       8   HAL_I2S_Transmit_IT
       0   HAL_I2S_TxCpltCallback
       0   HAL_I2S_TxHalfCpltCallback
       8   I2S_DMAError
         8   -> HAL_I2S_ErrorCallback
       8   I2S_DMARxCplt
         8   -> HAL_I2S_RxCpltCallback
       8   I2S_DMARxHalfCplt
         8   -> HAL_I2S_RxHalfCpltCallback
       8   I2S_DMATxCplt
         8   -> HAL_I2S_TxCpltCallback
       8   I2S_DMATxHalfCplt
         8   -> HAL_I2S_TxHalfCpltCallback
      24   I2S_WaitFlagStateUntilTimeout
        24   -> HAL_GetTick


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable0
       4  ??DataTable0_1
       4  ??DataTable0_2
       4  ??DataTable0_3
       4  ??DataTable0_4
       4  ??DataTable0_5
      18  ?Subroutine0
      10  ?Subroutine1
      12  ?Subroutine10
      20  ?Subroutine2
       6  ?Subroutine3
       6  ?Subroutine4
      10  ?Subroutine5
      12  ?Subroutine6
      16  ?Subroutine7
      12  ?Subroutine8
      12  ?Subroutine9
      70  HAL_I2S_DMAPause
      66  HAL_I2S_DMAResume
      84  HAL_I2S_DMAStop
      30  HAL_I2S_DeInit
       2  HAL_I2S_ErrorCallback
       4  HAL_I2S_GetError
       6  HAL_I2S_GetState
     188  HAL_I2S_IRQHandler
     246  HAL_I2S_Init
       2  HAL_I2S_MspDeInit
       2  HAL_I2S_MspInit
     172  HAL_I2S_Receive
     174  HAL_I2S_Receive_DMA
      76  HAL_I2S_Receive_IT
       2  HAL_I2S_RxCpltCallback
       2  HAL_I2S_RxHalfCpltCallback
     182  HAL_I2S_Transmit
     146  HAL_I2S_Transmit_DMA
      76  HAL_I2S_Transmit_IT
       2  HAL_I2S_TxCpltCallback
       2  HAL_I2S_TxHalfCpltCallback
      40  I2S_DMAError
      52  I2S_DMARxCplt
      10  I2S_DMARxHalfCplt
      52  I2S_DMATxCplt
      10  I2S_DMATxHalfCplt
     104  I2S_WaitFlagStateUntilTimeout

 
 1 960 bytes in section .text
 
 1 960 bytes of CODE memory

Errors: none
Warnings: none
