###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.2.10312/W32 for ARM       22/Feb/2016  19:58:45
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Middlewares\ST\STM32_USB_Host_Library\Class\MSC\Src\usbh_msc_scsi.c
#    Command line =  
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Middlewares\ST\STM32_USB_Host_Library\Class\MSC\Src\usbh_msc_scsi.c
#        -D USE_HAL_DRIVER -D STM32F746xx -D USE_STM32746G_DISCO -D
#        USE_IOEXPANDER -D USE_USB_FS -lC
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
#        -lA
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
#        -o
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M7 -e --fpu=VFPv5_sp --dlib_config "D:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.3\arm\INC\c\DLib_Config_Full.h"
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\CMSIS\Device\ST\STM32F7xx\Include\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\STM32F7xx_HAL_Driver\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\STM32746G-Discovery\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\Components\Common\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Log\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Fonts\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\CPU\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_Device_Library\Core\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Core\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Class\MSC\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\drivers\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_Audio\Addons\PDM\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_Device_Library\Class\AUDIO\Inc\
#        -On --use_c++_inline --require_prototypes -I "D:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.3\arm\CMSIS\Include\" -D
#        ARM_MATH_CM7
#    List file    =  
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List\usbh_msc_scsi.lst
#    Object file  =  
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj\usbh_msc_scsi.o
#
###############################################################################

D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Middlewares\ST\STM32_USB_Host_Library\Class\MSC\Src\usbh_msc_scsi.c
      1          /**
                   ^
Warning[Pa050]: non-native end of line sequence detected (this diagnostic is
          only issued once)
      2            ******************************************************************************
      3            * @file    usbh_msc_scsi.c 
      4            * @author  MCD Application Team
      5            * @version V3.2.1
      6            * @date    26-June-2015
      7            * @brief   This file implements the SCSI commands
      8            ******************************************************************************
      9            * @attention
     10            *
     11            * <h2><center>&copy; COPYRIGHT 2015 STMicroelectronics</center></h2>
     12            *
     13            * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
     14            * You may not use this file except in compliance with the License.
     15            * You may obtain a copy of the License at:
     16            *
     17            *        http://www.st.com/software_license_agreement_liberty_v2
     18            *
     19            * Unless required by applicable law or agreed to in writing, software 
     20            * distributed under the License is distributed on an "AS IS" BASIS, 
     21            * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     22            * See the License for the specific language governing permissions and
     23            * limitations under the License.
     24            *
     25            ******************************************************************************
     26            */ 
     27          
     28          /* Includes ------------------------------------------------------------------*/
     29          #include "usbh_msc.h"
     30          #include "usbh_msc_scsi.h"
     31          #include "usbh_msc_bot.h"
     32          
     33          
     34          /** @addtogroup USBH_LIB
     35            * @{
     36            */
     37          
     38          /** @addtogroup USBH_CLASS
     39            * @{
     40            */
     41          
     42          /** @addtogroup USBH_MSC_CLASS
     43            * @{
     44            */
     45            
     46          /** @defgroup USBH_MSC_SCSI 
     47            * @brief    This file includes the mass storage related functions
     48            * @{
     49            */ 
     50          
     51          
     52          /** @defgroup USBH_MSC_SCSI_Private_TypesDefinitions
     53            * @{
     54            */ 
     55          
     56          /**
     57            * @}
     58            */ 
     59          
     60          /** @defgroup USBH_MSC_SCSI_Private_Defines
     61            * @{
     62            */ 
     63          /**
     64            * @}
     65            */ 
     66          
     67          /** @defgroup USBH_MSC_SCSI_Private_Macros
     68            * @{
     69            */ 
     70          /**
     71            * @}
     72            */ 
     73          
     74          
     75          /** @defgroup USBH_MSC_SCSI_Private_FunctionPrototypes
     76            * @{
     77            */ 
     78          /**
     79            * @}
     80            */ 
     81          
     82          
     83          /** @defgroup USBH_MSC_SCSI_Exported_Variables
     84            * @{
     85            */ 
     86          
     87          /**
     88            * @}
     89            */ 
     90          
     91          
     92          /** @defgroup USBH_MSC_SCSI_Private_Functions
     93            * @{
     94            */ 
     95          
     96          
     97          /**
     98            * @brief  USBH_MSC_SCSI_TestUnitReady 
     99            *         Issue TestUnitReady command.
    100            * @param  phost: Host handle
    101            * @param  lun: Logical Unit Number
    102            * @retval USBH Status
    103            */

   \                                 In section .text, align 2, keep-with-next
    104          USBH_StatusTypeDef USBH_MSC_SCSI_TestUnitReady (USBH_HandleTypeDef *phost, 
    105                                                          uint8_t lun)
    106          {
   \                     USBH_MSC_SCSI_TestUnitReady: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
    107            USBH_StatusTypeDef    error = USBH_FAIL ;
   \   00000008   0x2602             MOVS     R6,#+2
    108            MSC_HandleTypeDef *MSC_Handle =  (MSC_HandleTypeDef *) phost->pActiveClass->pData;
   \   0000000A   0xF8D4 0x0264      LDR      R0,[R4, #+612]
   \   0000000E   0x69C7             LDR      R7,[R0, #+28]
    109            
    110            switch(MSC_Handle->hbot.cmd_state)
   \   00000010   0xF897 0x0052      LDRB     R0,[R7, #+82]
   \   00000014   0x2801             CMP      R0,#+1
   \   00000016   0xD002             BEQ.N    ??USBH_MSC_SCSI_TestUnitReady_0
   \   00000018   0x2802             CMP      R0,#+2
   \   0000001A   0xD01F             BEQ.N    ??USBH_MSC_SCSI_TestUnitReady_1
   \   0000001C   0xE025             B.N      ??USBH_MSC_SCSI_TestUnitReady_2
    111            {
    112            case BOT_CMD_SEND:  
    113              
    114              /*Prepare the CBW and relevent field*/
    115              MSC_Handle->hbot.cbw.field.DataTransferLength = DATA_LEN_MODE_TEST_UNIT_READY;     
   \                     ??USBH_MSC_SCSI_TestUnitReady_0: (+1)
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0x65F8             STR      R0,[R7, #+92]
    116              MSC_Handle->hbot.cbw.field.Flags = USB_EP_DIR_OUT;
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0xF887 0x0060      STRB     R0,[R7, #+96]
    117              MSC_Handle->hbot.cbw.field.CBLength = CBW_LENGTH;
   \   00000028   0x200A             MOVS     R0,#+10
   \   0000002A   0xF887 0x0062      STRB     R0,[R7, #+98]
    118              
    119              USBH_memset(MSC_Handle->hbot.cbw.field.CB, 0, CBW_CB_LENGTH);
   \   0000002E   0xF05F 0x0810      MOVS     R8,#+16
   \   00000032   0xF05F 0x0900      MOVS     R9,#+0
   \   00000036   0xF117 0x0A63      ADDS     R10,R7,#+99
   \   0000003A   0x464A             MOV      R2,R9
   \   0000003C   0x4641             MOV      R1,R8
   \   0000003E   0x4650             MOV      R0,R10
   \   00000040   0x.... 0x....      BL       __aeabi_memset
    120              MSC_Handle->hbot.cbw.field.CB[0]  = OPCODE_TEST_UNIT_READY; 
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0xF887 0x0063      STRB     R0,[R7, #+99]
    121              
    122              MSC_Handle->hbot.state = BOT_SEND_CBW;
   \   0000004A   0x2001             MOVS     R0,#+1
   \   0000004C   0xF887 0x0050      STRB     R0,[R7, #+80]
    123              MSC_Handle->hbot.cmd_state = BOT_CMD_WAIT;
   \   00000050   0x2002             MOVS     R0,#+2
   \   00000052   0xF887 0x0052      STRB     R0,[R7, #+82]
    124              error = USBH_BUSY; 
   \   00000056   0x2001             MOVS     R0,#+1
   \   00000058   0x0006             MOVS     R6,R0
    125              break;
   \   0000005A   0xE006             B.N      ??USBH_MSC_SCSI_TestUnitReady_3
    126              
    127            case BOT_CMD_WAIT: 
    128              error = USBH_MSC_BOT_Process(phost, lun);
   \                     ??USBH_MSC_SCSI_TestUnitReady_1: (+1)
   \   0000005C   0x0029             MOVS     R1,R5
   \   0000005E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000060   0x0020             MOVS     R0,R4
   \   00000062   0x.... 0x....      BL       USBH_MSC_BOT_Process
   \   00000066   0x0006             MOVS     R6,R0
    129              break;
   \   00000068   0xE7FF             B.N      ??USBH_MSC_SCSI_TestUnitReady_3
    130              
    131            default:
    132              break;
    133            }
    134            
    135            return error;
   \                     ??USBH_MSC_SCSI_TestUnitReady_2: (+1)
   \                     ??USBH_MSC_SCSI_TestUnitReady_3: (+1)
   \   0000006A   0x0030             MOVS     R0,R6
   \   0000006C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000006E   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
    136          }
    137          
    138          /**
    139            * @brief  USBH_MSC_SCSI_ReadCapacity 
    140            *         Issue Read Capacity command.
    141            * @param  phost: Host handle
    142            * @param  lun: Logical Unit Number
    143            * @param  capacity: pointer to the capacity structure
    144            * @retval USBH Status
    145            */

   \                                 In section .text, align 2, keep-with-next
    146          USBH_StatusTypeDef USBH_MSC_SCSI_ReadCapacity (USBH_HandleTypeDef *phost, 
    147                                                         uint8_t lun,
    148                                                         SCSI_CapacityTypeDef *capacity)
    149          {
   \                     USBH_MSC_SCSI_ReadCapacity: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
    150            USBH_StatusTypeDef    error = USBH_BUSY ;
   \   0000000A   0x2701             MOVS     R7,#+1
    151            MSC_HandleTypeDef *MSC_Handle =  (MSC_HandleTypeDef *) phost->pActiveClass->pData;
   \   0000000C   0xF8D4 0x0264      LDR      R0,[R4, #+612]
   \   00000010   0xF8D0 0x801C      LDR      R8,[R0, #+28]
    152            
    153            switch(MSC_Handle->hbot.cmd_state)
   \   00000014   0xF898 0x0052      LDRB     R0,[R8, #+82]
   \   00000018   0x2801             CMP      R0,#+1
   \   0000001A   0xD002             BEQ.N    ??USBH_MSC_SCSI_ReadCapacity_0
   \   0000001C   0x2802             CMP      R0,#+2
   \   0000001E   0xD024             BEQ.N    ??USBH_MSC_SCSI_ReadCapacity_1
   \   00000020   0xE049             B.N      ??USBH_MSC_SCSI_ReadCapacity_2
    154            {
    155            case BOT_CMD_SEND:  
    156              
    157              /*Prepare the CBW and relevent field*/
    158              MSC_Handle->hbot.cbw.field.DataTransferLength = DATA_LEN_READ_CAPACITY10;
   \                     ??USBH_MSC_SCSI_ReadCapacity_0: (+1)
   \   00000022   0x2008             MOVS     R0,#+8
   \   00000024   0xF8C8 0x005C      STR      R0,[R8, #+92]
    159              MSC_Handle->hbot.cbw.field.Flags = USB_EP_DIR_IN;
   \   00000028   0x2080             MOVS     R0,#+128
   \   0000002A   0xF888 0x0060      STRB     R0,[R8, #+96]
    160              MSC_Handle->hbot.cbw.field.CBLength = CBW_LENGTH;
   \   0000002E   0x200A             MOVS     R0,#+10
   \   00000030   0xF888 0x0062      STRB     R0,[R8, #+98]
    161              
    162              USBH_memset(MSC_Handle->hbot.cbw.field.CB, 0, CBW_CB_LENGTH);
   \   00000034   0xF05F 0x0910      MOVS     R9,#+16
   \   00000038   0xF05F 0x0A00      MOVS     R10,#+0
   \   0000003C   0xF118 0x0B63      ADDS     R11,R8,#+99
   \   00000040   0x4652             MOV      R2,R10
   \   00000042   0x4649             MOV      R1,R9
   \   00000044   0x4658             MOV      R0,R11
   \   00000046   0x.... 0x....      BL       __aeabi_memset
    163              MSC_Handle->hbot.cbw.field.CB[0]  = OPCODE_READ_CAPACITY10; 
   \   0000004A   0x2025             MOVS     R0,#+37
   \   0000004C   0xF888 0x0063      STRB     R0,[R8, #+99]
    164              
    165              MSC_Handle->hbot.state = BOT_SEND_CBW;
   \   00000050   0x2001             MOVS     R0,#+1
   \   00000052   0xF888 0x0050      STRB     R0,[R8, #+80]
    166              
    167              MSC_Handle->hbot.cmd_state = BOT_CMD_WAIT;
   \   00000056   0x2002             MOVS     R0,#+2
   \   00000058   0xF888 0x0052      STRB     R0,[R8, #+82]
    168              MSC_Handle->hbot.pbuf = (uint8_t *)MSC_Handle->hbot.data;
   \   0000005C   0xF118 0x0010      ADDS     R0,R8,#+16
   \   00000060   0xF8C8 0x008C      STR      R0,[R8, #+140]
    169              error = USBH_BUSY; 
   \   00000064   0x2001             MOVS     R0,#+1
   \   00000066   0x0007             MOVS     R7,R0
    170              break;
   \   00000068   0xE025             B.N      ??USBH_MSC_SCSI_ReadCapacity_3
    171              
    172            case BOT_CMD_WAIT: 
    173              
    174              error = USBH_MSC_BOT_Process(phost, lun);
   \                     ??USBH_MSC_SCSI_ReadCapacity_1: (+1)
   \   0000006A   0x0029             MOVS     R1,R5
   \   0000006C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000006E   0x0020             MOVS     R0,R4
   \   00000070   0x.... 0x....      BL       USBH_MSC_BOT_Process
   \   00000074   0x0007             MOVS     R7,R0
    175              
    176              if(error == USBH_OK)
   \   00000076   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000078   0x2F00             CMP      R7,#+0
   \   0000007A   0xD11B             BNE.N    ??USBH_MSC_SCSI_ReadCapacity_4
    177              {
    178                /*assign the capacity*/
    179                capacity->block_nbr = MSC_Handle->hbot.pbuf[3] | (MSC_Handle->hbot.pbuf[2] << 8) |\
    180                                     (MSC_Handle->hbot.pbuf[1] << 16) | (MSC_Handle->hbot.pbuf[0] << 24);
   \   0000007C   0xF8D8 0x008C      LDR      R0,[R8, #+140]
   \   00000080   0x78C0             LDRB     R0,[R0, #+3]
   \   00000082   0xF8D8 0x108C      LDR      R1,[R8, #+140]
   \   00000086   0x7889             LDRB     R1,[R1, #+2]
   \   00000088   0xEA50 0x2001      ORRS     R0,R0,R1, LSL #+8
   \   0000008C   0xF8D8 0x108C      LDR      R1,[R8, #+140]
   \   00000090   0x7849             LDRB     R1,[R1, #+1]
   \   00000092   0xEA50 0x4001      ORRS     R0,R0,R1, LSL #+16
   \   00000096   0xF8D8 0x108C      LDR      R1,[R8, #+140]
   \   0000009A   0x7809             LDRB     R1,[R1, #+0]
   \   0000009C   0xEA50 0x6001      ORRS     R0,R0,R1, LSL #+24
   \   000000A0   0x6030             STR      R0,[R6, #+0]
    181          
    182                /*assign the page length*/
    183                capacity->block_size = MSC_Handle->hbot.pbuf[7] | (MSC_Handle->hbot.pbuf[6] << 8); 
   \   000000A2   0xF8D8 0x008C      LDR      R0,[R8, #+140]
   \   000000A6   0x79C0             LDRB     R0,[R0, #+7]
   \   000000A8   0xF8D8 0x108C      LDR      R1,[R8, #+140]
   \   000000AC   0x7989             LDRB     R1,[R1, #+6]
   \   000000AE   0xEA50 0x2001      ORRS     R0,R0,R1, LSL #+8
   \   000000B2   0x80B0             STRH     R0,[R6, #+4]
    184              }
    185              break;
   \                     ??USBH_MSC_SCSI_ReadCapacity_4: (+1)
   \   000000B4   0xE7FF             B.N      ??USBH_MSC_SCSI_ReadCapacity_3
    186              
    187            default:
    188              break;
    189            }
    190            
    191            return error;
   \                     ??USBH_MSC_SCSI_ReadCapacity_2: (+1)
   \                     ??USBH_MSC_SCSI_ReadCapacity_3: (+1)
   \   000000B6   0x0038             MOVS     R0,R7
   \   000000B8   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000BA   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
    192          }
    193          
    194          /**
    195            * @brief  USBH_MSC_SCSI_Inquiry 
    196            *         Issue Inquiry command.
    197            * @param  phost: Host handle
    198            * @param  lun: Logical Unit Number
    199            * @param  capacity: pointer to the inquiry structure
    200            * @retval USBH Status
    201            */

   \                                 In section .text, align 2, keep-with-next
    202          USBH_StatusTypeDef USBH_MSC_SCSI_Inquiry (USBH_HandleTypeDef *phost, 
    203                                                         uint8_t lun, 
    204                                                         SCSI_StdInquiryDataTypeDef *inquiry)
    205          {
   \                     USBH_MSC_SCSI_Inquiry: (+1)
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0xB087             SUB      SP,SP,#+28
   \   00000006   0x0005             MOVS     R5,R0
   \   00000008   0x000E             MOVS     R6,R1
   \   0000000A   0x0014             MOVS     R4,R2
    206            USBH_StatusTypeDef    error = USBH_FAIL ;
   \   0000000C   0x2702             MOVS     R7,#+2
    207            MSC_HandleTypeDef *MSC_Handle =  (MSC_HandleTypeDef *) phost->pActiveClass->pData;
   \   0000000E   0xF8D5 0x0264      LDR      R0,[R5, #+612]
   \   00000012   0xF8D0 0x801C      LDR      R8,[R0, #+28]
    208            switch(MSC_Handle->hbot.cmd_state)
   \   00000016   0xF898 0x0052      LDRB     R0,[R8, #+82]
   \   0000001A   0x2801             CMP      R0,#+1
   \   0000001C   0xD002             BEQ.N    ??USBH_MSC_SCSI_Inquiry_0
   \   0000001E   0x2802             CMP      R0,#+2
   \   00000020   0xD033             BEQ.N    ??USBH_MSC_SCSI_Inquiry_1
   \   00000022   0xE07E             B.N      ??USBH_MSC_SCSI_Inquiry_2
    209            {
    210            case BOT_CMD_SEND:  
    211              
    212              /*Prepare the CBW and relevent field*/
    213              MSC_Handle->hbot.cbw.field.DataTransferLength = DATA_LEN_INQUIRY;
   \                     ??USBH_MSC_SCSI_Inquiry_0: (+1)
   \   00000024   0x2024             MOVS     R0,#+36
   \   00000026   0xF8C8 0x005C      STR      R0,[R8, #+92]
    214              MSC_Handle->hbot.cbw.field.Flags = USB_EP_DIR_IN;
   \   0000002A   0x2080             MOVS     R0,#+128
   \   0000002C   0xF888 0x0060      STRB     R0,[R8, #+96]
    215              MSC_Handle->hbot.cbw.field.CBLength = CBW_LENGTH;
   \   00000030   0x200A             MOVS     R0,#+10
   \   00000032   0xF888 0x0062      STRB     R0,[R8, #+98]
    216              
    217              USBH_memset(MSC_Handle->hbot.cbw.field.CB, 0, CBW_LENGTH);
   \   00000036   0xF05F 0x090A      MOVS     R9,#+10
   \   0000003A   0xF05F 0x0A00      MOVS     R10,#+0
   \   0000003E   0xF118 0x0B63      ADDS     R11,R8,#+99
   \   00000042   0x4652             MOV      R2,R10
   \   00000044   0x4649             MOV      R1,R9
   \   00000046   0x4658             MOV      R0,R11
   \   00000048   0x.... 0x....      BL       __aeabi_memset
    218              MSC_Handle->hbot.cbw.field.CB[0]  = OPCODE_INQUIRY; 
   \   0000004C   0x2012             MOVS     R0,#+18
   \   0000004E   0xF888 0x0063      STRB     R0,[R8, #+99]
    219              MSC_Handle->hbot.cbw.field.CB[1]  = (lun << 5);    
   \   00000052   0x0170             LSLS     R0,R6,#+5
   \   00000054   0xF888 0x0064      STRB     R0,[R8, #+100]
    220              MSC_Handle->hbot.cbw.field.CB[2]  = 0;    
   \   00000058   0x2000             MOVS     R0,#+0
   \   0000005A   0xF888 0x0065      STRB     R0,[R8, #+101]
    221              MSC_Handle->hbot.cbw.field.CB[3]  = 0;    
   \   0000005E   0x2000             MOVS     R0,#+0
   \   00000060   0xF888 0x0066      STRB     R0,[R8, #+102]
    222              MSC_Handle->hbot.cbw.field.CB[4]  = 0x24;    
   \   00000064   0x2024             MOVS     R0,#+36
   \   00000066   0xF888 0x0067      STRB     R0,[R8, #+103]
    223              MSC_Handle->hbot.cbw.field.CB[5]  = 0;    
   \   0000006A   0x2000             MOVS     R0,#+0
   \   0000006C   0xF888 0x0068      STRB     R0,[R8, #+104]
    224                  
    225              MSC_Handle->hbot.state = BOT_SEND_CBW;
   \   00000070   0x2001             MOVS     R0,#+1
   \   00000072   0xF888 0x0050      STRB     R0,[R8, #+80]
    226          
    227              MSC_Handle->hbot.cmd_state = BOT_CMD_WAIT;
   \   00000076   0x2002             MOVS     R0,#+2
   \   00000078   0xF888 0x0052      STRB     R0,[R8, #+82]
    228              MSC_Handle->hbot.pbuf = (uint8_t *)MSC_Handle->hbot.data;
   \   0000007C   0xF118 0x0010      ADDS     R0,R8,#+16
   \   00000080   0xF8C8 0x008C      STR      R0,[R8, #+140]
    229              error = USBH_BUSY; 
   \   00000084   0x2001             MOVS     R0,#+1
   \   00000086   0x0007             MOVS     R7,R0
    230              break;
   \   00000088   0xE04B             B.N      ??USBH_MSC_SCSI_Inquiry_3
    231              
    232            case BOT_CMD_WAIT: 
    233              
    234              error = USBH_MSC_BOT_Process(phost, lun);
   \                     ??USBH_MSC_SCSI_Inquiry_1: (+1)
   \   0000008A   0x0031             MOVS     R1,R6
   \   0000008C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000008E   0x0028             MOVS     R0,R5
   \   00000090   0x.... 0x....      BL       USBH_MSC_BOT_Process
   \   00000094   0x0007             MOVS     R7,R0
    235              
    236              if(error == USBH_OK)
   \   00000096   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000098   0x2F00             CMP      R7,#+0
   \   0000009A   0xD141             BNE.N    ??USBH_MSC_SCSI_Inquiry_4
    237              {
    238                USBH_memset(inquiry, 0, sizeof(SCSI_StdInquiryDataTypeDef));
   \   0000009C   0x2022             MOVS     R0,#+34
   \   0000009E   0x9005             STR      R0,[SP, #+20]
   \   000000A0   0x2000             MOVS     R0,#+0
   \   000000A2   0x9004             STR      R0,[SP, #+16]
   \   000000A4   0x9A04             LDR      R2,[SP, #+16]
   \   000000A6   0x9905             LDR      R1,[SP, #+20]
   \   000000A8   0x0020             MOVS     R0,R4
   \   000000AA   0x.... 0x....      BL       __aeabi_memset
    239                /*assign Inquiry Data */
    240                inquiry->DeviceType = MSC_Handle->hbot.pbuf[0] & 0x1F;
   \   000000AE   0xF8D8 0x008C      LDR      R0,[R8, #+140]
   \   000000B2   0x7800             LDRB     R0,[R0, #+0]
   \   000000B4   0xF010 0x001F      ANDS     R0,R0,#0x1F
   \   000000B8   0x7060             STRB     R0,[R4, #+1]
    241                inquiry->PeripheralQualifier = MSC_Handle->hbot.pbuf[0] >> 5;  
   \   000000BA   0xF8D8 0x008C      LDR      R0,[R8, #+140]
   \   000000BE   0x7800             LDRB     R0,[R0, #+0]
   \   000000C0   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000C2   0x0940             LSRS     R0,R0,#+5
   \   000000C4   0x7020             STRB     R0,[R4, #+0]
    242                inquiry->RemovableMedia = (MSC_Handle->hbot.pbuf[1] & 0x80)== 0x80;
   \   000000C6   0xF8D8 0x008C      LDR      R0,[R8, #+140]
   \   000000CA   0x7840             LDRB     R0,[R0, #+1]
   \   000000CC   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000CE   0x09C0             LSRS     R0,R0,#+7
   \   000000D0   0x70A0             STRB     R0,[R4, #+2]
    243                USBH_memcpy (inquiry->vendor_id, &MSC_Handle->hbot.pbuf[8], 8);
   \   000000D2   0x2008             MOVS     R0,#+8
   \   000000D4   0x9003             STR      R0,[SP, #+12]
   \   000000D6   0xF8D8 0x008C      LDR      R0,[R8, #+140]
   \   000000DA   0x3008             ADDS     R0,R0,#+8
   \   000000DC   0x9002             STR      R0,[SP, #+8]
   \   000000DE   0xF114 0x0903      ADDS     R9,R4,#+3
   \   000000E2   0x9A03             LDR      R2,[SP, #+12]
   \   000000E4   0x9902             LDR      R1,[SP, #+8]
   \   000000E6   0x4648             MOV      R0,R9
   \   000000E8   0x.... 0x....      BL       __aeabi_memcpy
    244                USBH_memcpy (inquiry->product_id, &MSC_Handle->hbot.pbuf[16], 16);
   \   000000EC   0xF05F 0x0910      MOVS     R9,#+16
   \   000000F0   0xF8D8 0x008C      LDR      R0,[R8, #+140]
   \   000000F4   0x3010             ADDS     R0,R0,#+16
   \   000000F6   0x9001             STR      R0,[SP, #+4]
   \   000000F8   0xF114 0x0A0C      ADDS     R10,R4,#+12
   \   000000FC   0x464A             MOV      R2,R9
   \   000000FE   0x9901             LDR      R1,[SP, #+4]
   \   00000100   0x4650             MOV      R0,R10
   \   00000102   0x.... 0x....      BL       __aeabi_memcpy
    245                USBH_memcpy (inquiry->revision_id, &MSC_Handle->hbot.pbuf[32], 4);    
   \   00000106   0xF05F 0x0A04      MOVS     R10,#+4
   \   0000010A   0xF8D8 0x008C      LDR      R0,[R8, #+140]
   \   0000010E   0x3020             ADDS     R0,R0,#+32
   \   00000110   0x9000             STR      R0,[SP, #+0]
   \   00000112   0xF114 0x0B1D      ADDS     R11,R4,#+29
   \   00000116   0x4652             MOV      R2,R10
   \   00000118   0x9900             LDR      R1,[SP, #+0]
   \   0000011A   0x4658             MOV      R0,R11
   \   0000011C   0x.... 0x....      BL       __aeabi_memcpy
    246              }
    247              break;
   \                     ??USBH_MSC_SCSI_Inquiry_4: (+1)
   \   00000120   0xE7FF             B.N      ??USBH_MSC_SCSI_Inquiry_3
    248              
    249            default:
    250              break;
    251            }
    252            
    253            return error;
   \                     ??USBH_MSC_SCSI_Inquiry_2: (+1)
   \                     ??USBH_MSC_SCSI_Inquiry_3: (+1)
   \   00000122   0x0038             MOVS     R0,R7
   \   00000124   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000126   0xB007             ADD      SP,SP,#+28
   \   00000128   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    254          }
    255          
    256          /**
    257            * @brief  USBH_MSC_SCSI_RequestSense 
    258            *         Issue RequestSense command.
    259            * @param  phost: Host handle
    260            * @param  lun: Logical Unit Number
    261            * @param  capacity: pointer to the sense data structure
    262            * @retval USBH Status
    263            */

   \                                 In section .text, align 2, keep-with-next
    264          USBH_StatusTypeDef USBH_MSC_SCSI_RequestSense (USBH_HandleTypeDef *phost, 
    265                                                         uint8_t lun, 
    266                                                         SCSI_SenseTypeDef *sense_data)
    267          {
   \                     USBH_MSC_SCSI_RequestSense: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
    268            USBH_StatusTypeDef    error = USBH_FAIL ;
   \   0000000A   0x2702             MOVS     R7,#+2
    269            MSC_HandleTypeDef *MSC_Handle =  (MSC_HandleTypeDef *) phost->pActiveClass->pData;
   \   0000000C   0xF8D4 0x0264      LDR      R0,[R4, #+612]
   \   00000010   0xF8D0 0x801C      LDR      R8,[R0, #+28]
    270            
    271            switch(MSC_Handle->hbot.cmd_state)
   \   00000014   0xF898 0x0052      LDRB     R0,[R8, #+82]
   \   00000018   0x2801             CMP      R0,#+1
   \   0000001A   0xD002             BEQ.N    ??USBH_MSC_SCSI_RequestSense_0
   \   0000001C   0x2802             CMP      R0,#+2
   \   0000001E   0xD033             BEQ.N    ??USBH_MSC_SCSI_RequestSense_1
   \   00000020   0xE04A             B.N      ??USBH_MSC_SCSI_RequestSense_2
    272            {
    273            case BOT_CMD_SEND:  
    274              
    275              /*Prepare the CBW and relevent field*/
    276              MSC_Handle->hbot.cbw.field.DataTransferLength = DATA_LEN_REQUEST_SENSE;
   \                     ??USBH_MSC_SCSI_RequestSense_0: (+1)
   \   00000022   0x200E             MOVS     R0,#+14
   \   00000024   0xF8C8 0x005C      STR      R0,[R8, #+92]
    277              MSC_Handle->hbot.cbw.field.Flags = USB_EP_DIR_IN;
   \   00000028   0x2080             MOVS     R0,#+128
   \   0000002A   0xF888 0x0060      STRB     R0,[R8, #+96]
    278              MSC_Handle->hbot.cbw.field.CBLength = CBW_LENGTH;
   \   0000002E   0x200A             MOVS     R0,#+10
   \   00000030   0xF888 0x0062      STRB     R0,[R8, #+98]
    279              
    280              USBH_memset(MSC_Handle->hbot.cbw.field.CB, 0, CBW_CB_LENGTH);
   \   00000034   0xF05F 0x0910      MOVS     R9,#+16
   \   00000038   0xF05F 0x0A00      MOVS     R10,#+0
   \   0000003C   0xF118 0x0B63      ADDS     R11,R8,#+99
   \   00000040   0x4652             MOV      R2,R10
   \   00000042   0x4649             MOV      R1,R9
   \   00000044   0x4658             MOV      R0,R11
   \   00000046   0x.... 0x....      BL       __aeabi_memset
    281              MSC_Handle->hbot.cbw.field.CB[0]  = OPCODE_REQUEST_SENSE; 
   \   0000004A   0x2003             MOVS     R0,#+3
   \   0000004C   0xF888 0x0063      STRB     R0,[R8, #+99]
    282              MSC_Handle->hbot.cbw.field.CB[1]  = (lun << 5); 
   \   00000050   0x0168             LSLS     R0,R5,#+5
   \   00000052   0xF888 0x0064      STRB     R0,[R8, #+100]
    283              MSC_Handle->hbot.cbw.field.CB[2]  = 0; 
   \   00000056   0x2000             MOVS     R0,#+0
   \   00000058   0xF888 0x0065      STRB     R0,[R8, #+101]
    284              MSC_Handle->hbot.cbw.field.CB[3]  = 0; 
   \   0000005C   0x2000             MOVS     R0,#+0
   \   0000005E   0xF888 0x0066      STRB     R0,[R8, #+102]
    285              MSC_Handle->hbot.cbw.field.CB[4]  = DATA_LEN_REQUEST_SENSE;
   \   00000062   0x200E             MOVS     R0,#+14
   \   00000064   0xF888 0x0067      STRB     R0,[R8, #+103]
    286              MSC_Handle->hbot.cbw.field.CB[5]  = 0;       
   \   00000068   0x2000             MOVS     R0,#+0
   \   0000006A   0xF888 0x0068      STRB     R0,[R8, #+104]
    287              
    288              MSC_Handle->hbot.state = BOT_SEND_CBW;
   \   0000006E   0x2001             MOVS     R0,#+1
   \   00000070   0xF888 0x0050      STRB     R0,[R8, #+80]
    289              MSC_Handle->hbot.cmd_state = BOT_CMD_WAIT;
   \   00000074   0x2002             MOVS     R0,#+2
   \   00000076   0xF888 0x0052      STRB     R0,[R8, #+82]
    290              MSC_Handle->hbot.pbuf = (uint8_t *)MSC_Handle->hbot.data;
   \   0000007A   0xF118 0x0010      ADDS     R0,R8,#+16
   \   0000007E   0xF8C8 0x008C      STR      R0,[R8, #+140]
    291              error = USBH_BUSY; 
   \   00000082   0x2001             MOVS     R0,#+1
   \   00000084   0x0007             MOVS     R7,R0
    292              break;
   \   00000086   0xE017             B.N      ??USBH_MSC_SCSI_RequestSense_3
    293              
    294            case BOT_CMD_WAIT: 
    295              
    296              error = USBH_MSC_BOT_Process(phost, lun);
   \                     ??USBH_MSC_SCSI_RequestSense_1: (+1)
   \   00000088   0x0029             MOVS     R1,R5
   \   0000008A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000008C   0x0020             MOVS     R0,R4
   \   0000008E   0x.... 0x....      BL       USBH_MSC_BOT_Process
   \   00000092   0x0007             MOVS     R7,R0
    297              
    298              if(error == USBH_OK)
   \   00000094   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000096   0x2F00             CMP      R7,#+0
   \   00000098   0xD10D             BNE.N    ??USBH_MSC_SCSI_RequestSense_4
    299              {
    300                sense_data->key  = MSC_Handle->hbot.pbuf[2] & 0x0F;  
   \   0000009A   0xF8D8 0x008C      LDR      R0,[R8, #+140]
   \   0000009E   0x7880             LDRB     R0,[R0, #+2]
   \   000000A0   0xF010 0x000F      ANDS     R0,R0,#0xF
   \   000000A4   0x7030             STRB     R0,[R6, #+0]
    301                sense_data->asc  = MSC_Handle->hbot.pbuf[12];
   \   000000A6   0xF8D8 0x008C      LDR      R0,[R8, #+140]
   \   000000AA   0x7B00             LDRB     R0,[R0, #+12]
   \   000000AC   0x7070             STRB     R0,[R6, #+1]
    302                sense_data->ascq = MSC_Handle->hbot.pbuf[13];
   \   000000AE   0xF8D8 0x008C      LDR      R0,[R8, #+140]
   \   000000B2   0x7B40             LDRB     R0,[R0, #+13]
   \   000000B4   0x70B0             STRB     R0,[R6, #+2]
    303              }
    304              break;
   \                     ??USBH_MSC_SCSI_RequestSense_4: (+1)
   \   000000B6   0xE7FF             B.N      ??USBH_MSC_SCSI_RequestSense_3
    305              
    306            default:
    307              break;
    308            }
    309            
    310            return error;
   \                     ??USBH_MSC_SCSI_RequestSense_2: (+1)
   \                     ??USBH_MSC_SCSI_RequestSense_3: (+1)
   \   000000B8   0x0038             MOVS     R0,R7
   \   000000BA   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000BC   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
    311          }
    312          
    313          /**
    314            * @brief  USBH_MSC_SCSI_Write 
    315            *         Issue write10 command.
    316            * @param  phost: Host handle
    317            * @param  lun: Logical Unit Number
    318            * @param  address: sector address
    319            * @param  pbuf: pointer to data
    320            * @param  length: number of sector to write
    321            * @retval USBH Status
    322            */

   \                                 In section .text, align 2, keep-with-next
    323          USBH_StatusTypeDef USBH_MSC_SCSI_Write(USBH_HandleTypeDef *phost,
    324                                               uint8_t lun,
    325                                               uint32_t address,
    326                                               uint8_t *pbuf,
    327                                               uint32_t length)
    328          {
   \                     USBH_MSC_SCSI_Write: (+1)
   \   00000000   0xE92D 0x4FF4      PUSH     {R2,R4-R11,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x001E             MOVS     R6,R3
    329            USBH_StatusTypeDef    error = USBH_FAIL ;
   \   0000000A   0x2702             MOVS     R7,#+2
    330          
    331            MSC_HandleTypeDef *MSC_Handle =  (MSC_HandleTypeDef *) phost->pActiveClass->pData;
   \   0000000C   0xF8D4 0x0264      LDR      R0,[R4, #+612]
   \   00000010   0xF8D0 0x801C      LDR      R8,[R0, #+28]
    332            
    333            switch(MSC_Handle->hbot.cmd_state)
   \   00000014   0xF898 0x0052      LDRB     R0,[R8, #+82]
   \   00000018   0x2801             CMP      R0,#+1
   \   0000001A   0xD002             BEQ.N    ??USBH_MSC_SCSI_Write_0
   \   0000001C   0x2802             CMP      R0,#+2
   \   0000001E   0xD03D             BEQ.N    ??USBH_MSC_SCSI_Write_1
   \   00000020   0xE043             B.N      ??USBH_MSC_SCSI_Write_2
    334            {
    335            case BOT_CMD_SEND:  
    336              
    337              /*Prepare the CBW and relevent field*/
    338              MSC_Handle->hbot.cbw.field.DataTransferLength = length * 512;
   \                     ??USBH_MSC_SCSI_Write_0: (+1)
   \   00000022   0x980A             LDR      R0,[SP, #+40]
   \   00000024   0xF44F 0x7100      MOV      R1,#+512
   \   00000028   0x4348             MULS     R0,R1,R0
   \   0000002A   0xF8C8 0x005C      STR      R0,[R8, #+92]
    339              MSC_Handle->hbot.cbw.field.Flags = USB_EP_DIR_OUT;
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0xF888 0x0060      STRB     R0,[R8, #+96]
    340              MSC_Handle->hbot.cbw.field.CBLength = CBW_LENGTH;
   \   00000034   0x200A             MOVS     R0,#+10
   \   00000036   0xF888 0x0062      STRB     R0,[R8, #+98]
    341              
    342              USBH_memset(MSC_Handle->hbot.cbw.field.CB, 0, CBW_CB_LENGTH);
   \   0000003A   0xF05F 0x0910      MOVS     R9,#+16
   \   0000003E   0xF05F 0x0A00      MOVS     R10,#+0
   \   00000042   0xF118 0x0B63      ADDS     R11,R8,#+99
   \   00000046   0x4652             MOV      R2,R10
   \   00000048   0x4649             MOV      R1,R9
   \   0000004A   0x4658             MOV      R0,R11
   \   0000004C   0x.... 0x....      BL       __aeabi_memset
    343              MSC_Handle->hbot.cbw.field.CB[0]  = OPCODE_WRITE10; 
   \   00000050   0x202A             MOVS     R0,#+42
   \   00000052   0xF888 0x0063      STRB     R0,[R8, #+99]
    344              
    345              /*logical block address*/
    346              MSC_Handle->hbot.cbw.field.CB[2]  = (((uint8_t*)&address)[3]);
   \   00000056   0xF89D 0x0003      LDRB     R0,[SP, #+3]
   \   0000005A   0xF888 0x0065      STRB     R0,[R8, #+101]
    347              MSC_Handle->hbot.cbw.field.CB[3]  = (((uint8_t*)&address)[2]);
   \   0000005E   0xF89D 0x0002      LDRB     R0,[SP, #+2]
   \   00000062   0xF888 0x0066      STRB     R0,[R8, #+102]
    348              MSC_Handle->hbot.cbw.field.CB[4]  = (((uint8_t*)&address)[1]);
   \   00000066   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \   0000006A   0xF888 0x0067      STRB     R0,[R8, #+103]
    349              MSC_Handle->hbot.cbw.field.CB[5]  = (((uint8_t*)&address)[0]);
   \   0000006E   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000072   0xF888 0x0068      STRB     R0,[R8, #+104]
    350              
    351              
    352              /*Transfer length */
    353              MSC_Handle->hbot.cbw.field.CB[7]  = (((uint8_t *)&length)[1]) ; 
   \   00000076   0xF89D 0x0029      LDRB     R0,[SP, #+41]
   \   0000007A   0xF888 0x006A      STRB     R0,[R8, #+106]
    354              MSC_Handle->hbot.cbw.field.CB[8]  = (((uint8_t *)&length)[0]) ; 
   \   0000007E   0xF89D 0x0028      LDRB     R0,[SP, #+40]
   \   00000082   0xF888 0x006B      STRB     R0,[R8, #+107]
    355          
    356              
    357              MSC_Handle->hbot.state = BOT_SEND_CBW;
   \   00000086   0x2001             MOVS     R0,#+1
   \   00000088   0xF888 0x0050      STRB     R0,[R8, #+80]
    358              MSC_Handle->hbot.cmd_state = BOT_CMD_WAIT;
   \   0000008C   0x2002             MOVS     R0,#+2
   \   0000008E   0xF888 0x0052      STRB     R0,[R8, #+82]
    359              MSC_Handle->hbot.pbuf = pbuf;
   \   00000092   0xF8C8 0x608C      STR      R6,[R8, #+140]
    360              error = USBH_BUSY; 
   \   00000096   0x2001             MOVS     R0,#+1
   \   00000098   0x0007             MOVS     R7,R0
    361              break;
   \   0000009A   0xE006             B.N      ??USBH_MSC_SCSI_Write_3
    362              
    363            case BOT_CMD_WAIT: 
    364              error = USBH_MSC_BOT_Process(phost, lun);
   \                     ??USBH_MSC_SCSI_Write_1: (+1)
   \   0000009C   0x0029             MOVS     R1,R5
   \   0000009E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000A0   0x0020             MOVS     R0,R4
   \   000000A2   0x.... 0x....      BL       USBH_MSC_BOT_Process
   \   000000A6   0x0007             MOVS     R7,R0
    365              break;
   \   000000A8   0xE7FF             B.N      ??USBH_MSC_SCSI_Write_3
    366              
    367            default:
    368              break;
    369            }
    370            
    371            return error;
   \                     ??USBH_MSC_SCSI_Write_2: (+1)
   \                     ??USBH_MSC_SCSI_Write_3: (+1)
   \   000000AA   0x0038             MOVS     R0,R7
   \   000000AC   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000AE   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
    372          }
    373          
    374          /**
    375            * @brief  USBH_MSC_SCSI_Read 
    376            *         Issue Read10 command.
    377            * @param  phost: Host handle
    378            * @param  lun: Logical Unit Number
    379            * @param  address: sector address
    380            * @param  pbuf: pointer to data
    381            * @param  length: number of sector to read
    382            * @retval USBH Status
    383            */

   \                                 In section .text, align 2, keep-with-next
    384          USBH_StatusTypeDef USBH_MSC_SCSI_Read(USBH_HandleTypeDef *phost,
    385                                               uint8_t lun,
    386                                               uint32_t address,
    387                                               uint8_t *pbuf,
    388                                               uint32_t length)
    389          {
   \                     USBH_MSC_SCSI_Read: (+1)
   \   00000000   0xE92D 0x4FF4      PUSH     {R2,R4-R11,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x001E             MOVS     R6,R3
    390            USBH_StatusTypeDef    error = USBH_FAIL ;
   \   0000000A   0x2702             MOVS     R7,#+2
    391            MSC_HandleTypeDef *MSC_Handle = (MSC_HandleTypeDef *) phost->pActiveClass->pData;
   \   0000000C   0xF8D4 0x0264      LDR      R0,[R4, #+612]
   \   00000010   0xF8D0 0x801C      LDR      R8,[R0, #+28]
    392            
    393            switch(MSC_Handle->hbot.cmd_state)
   \   00000014   0xF898 0x0052      LDRB     R0,[R8, #+82]
   \   00000018   0x2801             CMP      R0,#+1
   \   0000001A   0xD002             BEQ.N    ??USBH_MSC_SCSI_Read_0
   \   0000001C   0x2802             CMP      R0,#+2
   \   0000001E   0xD03D             BEQ.N    ??USBH_MSC_SCSI_Read_1
   \   00000020   0xE043             B.N      ??USBH_MSC_SCSI_Read_2
    394            {
    395            case BOT_CMD_SEND:  
    396              
    397              /*Prepare the CBW and relevent field*/
    398              MSC_Handle->hbot.cbw.field.DataTransferLength = length * 512;
   \                     ??USBH_MSC_SCSI_Read_0: (+1)
   \   00000022   0x980A             LDR      R0,[SP, #+40]
   \   00000024   0xF44F 0x7100      MOV      R1,#+512
   \   00000028   0x4348             MULS     R0,R1,R0
   \   0000002A   0xF8C8 0x005C      STR      R0,[R8, #+92]
    399              MSC_Handle->hbot.cbw.field.Flags = USB_EP_DIR_IN;
   \   0000002E   0x2080             MOVS     R0,#+128
   \   00000030   0xF888 0x0060      STRB     R0,[R8, #+96]
    400              MSC_Handle->hbot.cbw.field.CBLength = CBW_LENGTH;
   \   00000034   0x200A             MOVS     R0,#+10
   \   00000036   0xF888 0x0062      STRB     R0,[R8, #+98]
    401              
    402              USBH_memset(MSC_Handle->hbot.cbw.field.CB, 0, CBW_CB_LENGTH);
   \   0000003A   0xF05F 0x0910      MOVS     R9,#+16
   \   0000003E   0xF05F 0x0A00      MOVS     R10,#+0
   \   00000042   0xF118 0x0B63      ADDS     R11,R8,#+99
   \   00000046   0x4652             MOV      R2,R10
   \   00000048   0x4649             MOV      R1,R9
   \   0000004A   0x4658             MOV      R0,R11
   \   0000004C   0x.... 0x....      BL       __aeabi_memset
    403              MSC_Handle->hbot.cbw.field.CB[0]  = OPCODE_READ10; 
   \   00000050   0x2028             MOVS     R0,#+40
   \   00000052   0xF888 0x0063      STRB     R0,[R8, #+99]
    404              
    405              /*logical block address*/
    406              MSC_Handle->hbot.cbw.field.CB[2]  = (((uint8_t*)&address)[3]);
   \   00000056   0xF89D 0x0003      LDRB     R0,[SP, #+3]
   \   0000005A   0xF888 0x0065      STRB     R0,[R8, #+101]
    407              MSC_Handle->hbot.cbw.field.CB[3]  = (((uint8_t*)&address)[2]);
   \   0000005E   0xF89D 0x0002      LDRB     R0,[SP, #+2]
   \   00000062   0xF888 0x0066      STRB     R0,[R8, #+102]
    408              MSC_Handle->hbot.cbw.field.CB[4]  = (((uint8_t*)&address)[1]);
   \   00000066   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \   0000006A   0xF888 0x0067      STRB     R0,[R8, #+103]
    409              MSC_Handle->hbot.cbw.field.CB[5]  = (((uint8_t*)&address)[0]);
   \   0000006E   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000072   0xF888 0x0068      STRB     R0,[R8, #+104]
    410              
    411              
    412              /*Transfer length */
    413              MSC_Handle->hbot.cbw.field.CB[7]  = (((uint8_t *)&length)[1]) ; 
   \   00000076   0xF89D 0x0029      LDRB     R0,[SP, #+41]
   \   0000007A   0xF888 0x006A      STRB     R0,[R8, #+106]
    414              MSC_Handle->hbot.cbw.field.CB[8]  = (((uint8_t *)&length)[0]) ; 
   \   0000007E   0xF89D 0x0028      LDRB     R0,[SP, #+40]
   \   00000082   0xF888 0x006B      STRB     R0,[R8, #+107]
    415          
    416              
    417              MSC_Handle->hbot.state = BOT_SEND_CBW;
   \   00000086   0x2001             MOVS     R0,#+1
   \   00000088   0xF888 0x0050      STRB     R0,[R8, #+80]
    418              MSC_Handle->hbot.cmd_state = BOT_CMD_WAIT;
   \   0000008C   0x2002             MOVS     R0,#+2
   \   0000008E   0xF888 0x0052      STRB     R0,[R8, #+82]
    419              MSC_Handle->hbot.pbuf = pbuf;
   \   00000092   0xF8C8 0x608C      STR      R6,[R8, #+140]
    420              error = USBH_BUSY; 
   \   00000096   0x2001             MOVS     R0,#+1
   \   00000098   0x0007             MOVS     R7,R0
    421              break;
   \   0000009A   0xE006             B.N      ??USBH_MSC_SCSI_Read_3
    422              
    423            case BOT_CMD_WAIT: 
    424              error = USBH_MSC_BOT_Process(phost, lun);
   \                     ??USBH_MSC_SCSI_Read_1: (+1)
   \   0000009C   0x0029             MOVS     R1,R5
   \   0000009E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000A0   0x0020             MOVS     R0,R4
   \   000000A2   0x.... 0x....      BL       USBH_MSC_BOT_Process
   \   000000A6   0x0007             MOVS     R7,R0
    425              break;
   \   000000A8   0xE7FF             B.N      ??USBH_MSC_SCSI_Read_3
    426              
    427            default:
    428              break;
    429            }
    430            
    431            return error;
   \                     ??USBH_MSC_SCSI_Read_2: (+1)
   \                     ??USBH_MSC_SCSI_Read_3: (+1)
   \   000000AA   0x0038             MOVS     R0,R7
   \   000000AC   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000AE   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
    432          }
    433          
    434          
    435          /**
    436            * @}
    437            */ 
    438          
    439          /**
    440            * @}
    441            */ 
    442          
    443          /**
    444            * @}
    445            */
    446          
    447          /**
    448            * @}
    449            */ 
    450          
    451          /**
    452            * @}
    453            */
    454          
    455          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
    456          
    457          
    458          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      64   USBH_MSC_SCSI_Inquiry
        64   -> USBH_MSC_BOT_Process
        64   -> __aeabi_memcpy
        64   -> __aeabi_memset
      40   USBH_MSC_SCSI_Read
        40   -> USBH_MSC_BOT_Process
        40   -> __aeabi_memset
      40   USBH_MSC_SCSI_ReadCapacity
        40   -> USBH_MSC_BOT_Process
        40   -> __aeabi_memset
      40   USBH_MSC_SCSI_RequestSense
        40   -> USBH_MSC_BOT_Process
        40   -> __aeabi_memset
      32   USBH_MSC_SCSI_TestUnitReady
        32   -> USBH_MSC_BOT_Process
        32   -> __aeabi_memset
      40   USBH_MSC_SCSI_Write
        40   -> USBH_MSC_BOT_Process
        40   -> __aeabi_memset


   Section sizes:

   Bytes  Function/Label
   -----  --------------
     300  USBH_MSC_SCSI_Inquiry
     178  USBH_MSC_SCSI_Read
     190  USBH_MSC_SCSI_ReadCapacity
     192  USBH_MSC_SCSI_RequestSense
     114  USBH_MSC_SCSI_TestUnitReady
     178  USBH_MSC_SCSI_Write

 
 1 152 bytes in section .text
 
 1 152 bytes of CODE memory

Errors: none
Warnings: 1
