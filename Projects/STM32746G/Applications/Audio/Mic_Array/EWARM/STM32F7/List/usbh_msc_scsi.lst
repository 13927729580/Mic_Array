###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.2.10312/W32 for ARM       06/Apr/2016  18:05:35
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Middlewares\ST\STM32_USB_Host_Library\Class\MSC\Src\usbh_msc_scsi.c
#    Command line =  
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Middlewares\ST\STM32_USB_Host_Library\Class\MSC\Src\usbh_msc_scsi.c
#        -D USE_HAL_DRIVER -D STM32F746xx -D USE_STM32746G_DISCO -D
#        USE_IOEXPANDER -D USE_USB_FS -lC
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
#        -lA
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
#        -o
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj
#        --no_unroll --debug --endian=little --cpu=Cortex-M7 -e --fpu=VFPv5_sp
#        --dlib_config "D:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Full.h" -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\CMSIS\Device\ST\STM32F7xx\Include\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\STM32F7xx_HAL_Driver\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\STM32746G-Discovery\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\Components\Common\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Log\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Fonts\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\CPU\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_Device_Library\Core\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Core\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Class\MSC\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\drivers\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_Audio\Addons\PDM\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_Device_Library\Class\AUDIO\Inc\
#        -Ohs --use_c++_inline --require_prototypes -I "D:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.3\arm\CMSIS\Include\" -D
#        ARM_MATH_CM7 --relaxed_fp
#    List file    =  
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List\usbh_msc_scsi.lst
#    Object file  =  
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj\usbh_msc_scsi.o
#
###############################################################################

D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Middlewares\ST\STM32_USB_Host_Library\Class\MSC\Src\usbh_msc_scsi.c
      1          /**
      2            ******************************************************************************
      3            * @file    usbh_msc_scsi.c 
      4            * @author  MCD Application Team
      5            * @version V3.2.1
      6            * @date    26-June-2015
      7            * @brief   This file implements the SCSI commands
      8            ******************************************************************************
      9            * @attention
     10            *
     11            * <h2><center>&copy; COPYRIGHT 2015 STMicroelectronics</center></h2>
     12            *
     13            * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
     14            * You may not use this file except in compliance with the License.
     15            * You may obtain a copy of the License at:
     16            *
     17            *        http://www.st.com/software_license_agreement_liberty_v2
     18            *
     19            * Unless required by applicable law or agreed to in writing, software 
     20            * distributed under the License is distributed on an "AS IS" BASIS, 
     21            * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     22            * See the License for the specific language governing permissions and
     23            * limitations under the License.
     24            *
     25            ******************************************************************************
     26            */ 
     27          
     28          /* Includes ------------------------------------------------------------------*/
     29          #include "usbh_msc.h"
     30          #include "usbh_msc_scsi.h"
     31          #include "usbh_msc_bot.h"
     32          
     33          
     34          /** @addtogroup USBH_LIB
     35            * @{
     36            */
     37          
     38          /** @addtogroup USBH_CLASS
     39            * @{
     40            */
     41          
     42          /** @addtogroup USBH_MSC_CLASS
     43            * @{
     44            */
     45            
     46          /** @defgroup USBH_MSC_SCSI 
     47            * @brief    This file includes the mass storage related functions
     48            * @{
     49            */ 
     50          
     51          
     52          /** @defgroup USBH_MSC_SCSI_Private_TypesDefinitions
     53            * @{
     54            */ 
     55          
     56          /**
     57            * @}
     58            */ 
     59          
     60          /** @defgroup USBH_MSC_SCSI_Private_Defines
     61            * @{
     62            */ 
     63          /**
     64            * @}
     65            */ 
     66          
     67          /** @defgroup USBH_MSC_SCSI_Private_Macros
     68            * @{
     69            */ 
     70          /**
     71            * @}
     72            */ 
     73          
     74          
     75          /** @defgroup USBH_MSC_SCSI_Private_FunctionPrototypes
     76            * @{
     77            */ 
     78          /**
     79            * @}
     80            */ 
     81          
     82          
     83          /** @defgroup USBH_MSC_SCSI_Exported_Variables
     84            * @{
     85            */ 
     86          
     87          /**
     88            * @}
     89            */ 
     90          
     91          
     92          /** @defgroup USBH_MSC_SCSI_Private_Functions
     93            * @{
     94            */ 
     95          
     96          
     97          /**
     98            * @brief  USBH_MSC_SCSI_TestUnitReady 
     99            *         Issue TestUnitReady command.
    100            * @param  phost: Host handle
    101            * @param  lun: Logical Unit Number
    102            * @retval USBH Status
    103            */

   \                                 In section .text, align 2, keep-with-next
    104          USBH_StatusTypeDef USBH_MSC_SCSI_TestUnitReady (USBH_HandleTypeDef *phost, 
    105                                                          uint8_t lun)
    106          {
   \                     USBH_MSC_SCSI_TestUnitReady: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4602             MOV      R2,R0
    107            USBH_StatusTypeDef    error = USBH_FAIL ;
   \   00000004   0x2002             MOVS     R0,#+2
    108            MSC_HandleTypeDef *MSC_Handle =  (MSC_HandleTypeDef *) phost->pActiveClass->pData;
   \   00000006   0xF8D2 0x3264      LDR      R3,[R2, #+612]
   \   0000000A   0x69DC             LDR      R4,[R3, #+28]
    109            
    110            switch(MSC_Handle->hbot.cmd_state)
   \   0000000C   0xF894 0x3052      LDRB     R3,[R4, #+82]
   \   00000010   0x2B01             CMP      R3,#+1
   \   00000012   0xD002             BEQ.N    ??USBH_MSC_SCSI_TestUnitReady_0
   \   00000014   0x2B02             CMP      R3,#+2
   \   00000016   0xD017             BEQ.N    ??USBH_MSC_SCSI_TestUnitReady_1
   \   00000018   0xBD10             POP      {R4,PC}
    111            {
    112            case BOT_CMD_SEND:  
    113              
    114              /*Prepare the CBW and relevent field*/
    115              MSC_Handle->hbot.cbw.field.DataTransferLength = DATA_LEN_MODE_TEST_UNIT_READY;     
   \                     ??USBH_MSC_SCSI_TestUnitReady_0: (+1)
   \   0000001A   0x2000             MOVS     R0,#+0
    116              MSC_Handle->hbot.cbw.field.Flags = USB_EP_DIR_OUT;
    117              MSC_Handle->hbot.cbw.field.CBLength = CBW_LENGTH;
    118              
    119              USBH_memset(MSC_Handle->hbot.cbw.field.CB, 0, CBW_CB_LENGTH);
   \   0000001C   0x2110             MOVS     R1,#+16
   \   0000001E   0x65E0             STR      R0,[R4, #+92]
   \   00000020   0xF884 0x0060      STRB     R0,[R4, #+96]
   \   00000024   0x200A             MOVS     R0,#+10
   \   00000026   0xF884 0x0062      STRB     R0,[R4, #+98]
   \   0000002A   0xF104 0x0063      ADD      R0,R4,#+99
   \   0000002E   0x.... 0x....      BL       __aeabi_memclr
    120              MSC_Handle->hbot.cbw.field.CB[0]  = OPCODE_TEST_UNIT_READY; 
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0xF884 0x0063      STRB     R0,[R4, #+99]
    121              
    122              MSC_Handle->hbot.state = BOT_SEND_CBW;
   \   00000038   0x2001             MOVS     R0,#+1
   \   0000003A   0xF884 0x0050      STRB     R0,[R4, #+80]
    123              MSC_Handle->hbot.cmd_state = BOT_CMD_WAIT;
   \   0000003E   0x2002             MOVS     R0,#+2
   \   00000040   0xF884 0x0052      STRB     R0,[R4, #+82]
    124              error = USBH_BUSY; 
   \   00000044   0x2001             MOVS     R0,#+1
    125              break;
   \   00000046   0xBD10             POP      {R4,PC}
    126              
    127            case BOT_CMD_WAIT: 
    128              error = USBH_MSC_BOT_Process(phost, lun);
   \                     ??USBH_MSC_SCSI_TestUnitReady_1: (+1)
   \   00000048   0x4610             MOV      R0,R2
   \   0000004A   0xE8BD 0x4010      POP      {R4,LR}
   \   0000004E   0x.... 0x....      B.W      USBH_MSC_BOT_Process
    129              break;
    130              
    131            default:
    132              break;
    133            }
    134            
    135            return error;
    136          }
    137          
    138          /**
    139            * @brief  USBH_MSC_SCSI_ReadCapacity 
    140            *         Issue Read Capacity command.
    141            * @param  phost: Host handle
    142            * @param  lun: Logical Unit Number
    143            * @param  capacity: pointer to the capacity structure
    144            * @retval USBH Status
    145            */

   \                                 In section .text, align 2, keep-with-next
    146          USBH_StatusTypeDef USBH_MSC_SCSI_ReadCapacity (USBH_HandleTypeDef *phost, 
    147                                                         uint8_t lun,
    148                                                         SCSI_CapacityTypeDef *capacity)
    149          {
   \                     USBH_MSC_SCSI_ReadCapacity: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4616             MOV      R6,R2
    150            USBH_StatusTypeDef    error = USBH_BUSY ;
    151            MSC_HandleTypeDef *MSC_Handle =  (MSC_HandleTypeDef *) phost->pActiveClass->pData;
   \   00000004   0xF8D0 0x2264      LDR      R2,[R0, #+612]
   \   00000008   0x2401             MOVS     R4,#+1
   \   0000000A   0x69D5             LDR      R5,[R2, #+28]
    152            
    153            switch(MSC_Handle->hbot.cmd_state)
   \   0000000C   0xF895 0x2052      LDRB     R2,[R5, #+82]
   \   00000010   0x2A01             CMP      R2,#+1
   \   00000012   0xD003             BEQ.N    ??USBH_MSC_SCSI_ReadCapacity_0
   \   00000014   0x2A02             CMP      R2,#+2
   \   00000016   0xD01C             BEQ.N    ??USBH_MSC_SCSI_ReadCapacity_1
    154            {
    155            case BOT_CMD_SEND:  
    156              
    157              /*Prepare the CBW and relevent field*/
    158              MSC_Handle->hbot.cbw.field.DataTransferLength = DATA_LEN_READ_CAPACITY10;
    159              MSC_Handle->hbot.cbw.field.Flags = USB_EP_DIR_IN;
    160              MSC_Handle->hbot.cbw.field.CBLength = CBW_LENGTH;
    161              
    162              USBH_memset(MSC_Handle->hbot.cbw.field.CB, 0, CBW_CB_LENGTH);
    163              MSC_Handle->hbot.cbw.field.CB[0]  = OPCODE_READ_CAPACITY10; 
    164              
    165              MSC_Handle->hbot.state = BOT_SEND_CBW;
    166              
    167              MSC_Handle->hbot.cmd_state = BOT_CMD_WAIT;
    168              MSC_Handle->hbot.pbuf = (uint8_t *)MSC_Handle->hbot.data;
    169              error = USBH_BUSY; 
    170              break;
    171              
    172            case BOT_CMD_WAIT: 
    173              
    174              error = USBH_MSC_BOT_Process(phost, lun);
    175              
    176              if(error == USBH_OK)
    177              {
    178                /*assign the capacity*/
    179                capacity->block_nbr = MSC_Handle->hbot.pbuf[3] | (MSC_Handle->hbot.pbuf[2] << 8) |\
    180                                     (MSC_Handle->hbot.pbuf[1] << 16) | (MSC_Handle->hbot.pbuf[0] << 24);
    181          
    182                /*assign the page length*/
    183                capacity->block_size = MSC_Handle->hbot.pbuf[7] | (MSC_Handle->hbot.pbuf[6] << 8); 
    184              }
    185              break;
    186              
    187            default:
    188              break;
    189            }
    190            
    191            return error;
   \   00000018   0x4620             MOV      R0,R4
   \   0000001A   0xBD70             POP      {R4-R6,PC}
   \                     ??USBH_MSC_SCSI_ReadCapacity_0: (+1)
   \   0000001C   0x2008             MOVS     R0,#+8
   \   0000001E   0x2110             MOVS     R1,#+16
   \   00000020   0x65E8             STR      R0,[R5, #+92]
   \   00000022   0x2080             MOVS     R0,#+128
   \   00000024   0xF885 0x0060      STRB     R0,[R5, #+96]
   \   00000028   0x200A             MOVS     R0,#+10
   \   0000002A   0xF885 0x0062      STRB     R0,[R5, #+98]
   \   0000002E   0xF105 0x0063      ADD      R0,R5,#+99
   \   00000032   0x.... 0x....      BL       __aeabi_memclr
   \   00000036   0x2025             MOVS     R0,#+37
   \   00000038   0xF885 0x4050      STRB     R4,[R5, #+80]
   \   0000003C   0xF885 0x0063      STRB     R0,[R5, #+99]
   \   00000040   0x2002             MOVS     R0,#+2
   \   00000042   0xF885 0x0052      STRB     R0,[R5, #+82]
   \   00000046   0xF105 0x0010      ADD      R0,R5,#+16
   \   0000004A   0xF8C5 0x008C      STR      R0,[R5, #+140]
   \   0000004E   0x4620             MOV      R0,R4
   \   00000050   0xBD70             POP      {R4-R6,PC}
   \                     ??USBH_MSC_SCSI_ReadCapacity_1: (+1)
   \   00000052   0x.... 0x....      BL       USBH_MSC_BOT_Process
   \   00000056   0x0004             MOVS     R4,R0
   \   00000058   0xD113             BNE.N    ??USBH_MSC_SCSI_ReadCapacity_2
   \   0000005A   0xF8D5 0x008C      LDR      R0,[R5, #+140]
   \   0000005E   0x78C1             LDRB     R1,[R0, #+3]
   \   00000060   0x7882             LDRB     R2,[R0, #+2]
   \   00000062   0xEA41 0x2102      ORR      R1,R1,R2, LSL #+8
   \   00000066   0x7842             LDRB     R2,[R0, #+1]
   \   00000068   0x7800             LDRB     R0,[R0, #+0]
   \   0000006A   0xEA41 0x4102      ORR      R1,R1,R2, LSL #+16
   \   0000006E   0xEA41 0x6000      ORR      R0,R1,R0, LSL #+24
   \   00000072   0x6030             STR      R0,[R6, #+0]
   \   00000074   0xF8D5 0x008C      LDR      R0,[R5, #+140]
   \   00000078   0x79C1             LDRB     R1,[R0, #+7]
   \   0000007A   0x7980             LDRB     R0,[R0, #+6]
   \   0000007C   0xEA41 0x2000      ORR      R0,R1,R0, LSL #+8
   \   00000080   0x80B0             STRH     R0,[R6, #+4]
   \                     ??USBH_MSC_SCSI_ReadCapacity_2: (+1)
   \   00000082   0x4620             MOV      R0,R4
   \   00000084   0xBD70             POP      {R4-R6,PC}       ;; return
    192          }
    193          
    194          /**
    195            * @brief  USBH_MSC_SCSI_Inquiry 
    196            *         Issue Inquiry command.
    197            * @param  phost: Host handle
    198            * @param  lun: Logical Unit Number
    199            * @param  capacity: pointer to the inquiry structure
    200            * @retval USBH Status
    201            */

   \                                 In section .text, align 2, keep-with-next
    202          USBH_StatusTypeDef USBH_MSC_SCSI_Inquiry (USBH_HandleTypeDef *phost, 
    203                                                         uint8_t lun, 
    204                                                         SCSI_StdInquiryDataTypeDef *inquiry)
    205          {
   \                     USBH_MSC_SCSI_Inquiry: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB081             SUB      SP,SP,#+4
   \   00000004   0x460C             MOV      R4,R1
    206            USBH_StatusTypeDef    error = USBH_FAIL ;
    207            MSC_HandleTypeDef *MSC_Handle =  (MSC_HandleTypeDef *) phost->pActiveClass->pData;
   \   00000006   0xF8D0 0x1264      LDR      R1,[R0, #+612]
   \   0000000A   0x2702             MOVS     R7,#+2
   \   0000000C   0x4616             MOV      R6,R2
   \   0000000E   0x69CD             LDR      R5,[R1, #+28]
    208            switch(MSC_Handle->hbot.cmd_state)
   \   00000010   0xF895 0x1052      LDRB     R1,[R5, #+82]
   \   00000014   0x2901             CMP      R1,#+1
   \   00000016   0xD004             BEQ.N    ??USBH_MSC_SCSI_Inquiry_0
   \   00000018   0x2902             CMP      R1,#+2
   \   0000001A   0xD02D             BEQ.N    ??USBH_MSC_SCSI_Inquiry_1
    209            {
    210            case BOT_CMD_SEND:  
    211              
    212              /*Prepare the CBW and relevent field*/
    213              MSC_Handle->hbot.cbw.field.DataTransferLength = DATA_LEN_INQUIRY;
    214              MSC_Handle->hbot.cbw.field.Flags = USB_EP_DIR_IN;
    215              MSC_Handle->hbot.cbw.field.CBLength = CBW_LENGTH;
    216              
    217              USBH_memset(MSC_Handle->hbot.cbw.field.CB, 0, CBW_LENGTH);
    218              MSC_Handle->hbot.cbw.field.CB[0]  = OPCODE_INQUIRY; 
    219              MSC_Handle->hbot.cbw.field.CB[1]  = (lun << 5);    
    220              MSC_Handle->hbot.cbw.field.CB[2]  = 0;    
    221              MSC_Handle->hbot.cbw.field.CB[3]  = 0;    
    222              MSC_Handle->hbot.cbw.field.CB[4]  = 0x24;    
    223              MSC_Handle->hbot.cbw.field.CB[5]  = 0;    
    224                  
    225              MSC_Handle->hbot.state = BOT_SEND_CBW;
    226          
    227              MSC_Handle->hbot.cmd_state = BOT_CMD_WAIT;
    228              MSC_Handle->hbot.pbuf = (uint8_t *)MSC_Handle->hbot.data;
    229              error = USBH_BUSY; 
    230              break;
    231              
    232            case BOT_CMD_WAIT: 
    233              
    234              error = USBH_MSC_BOT_Process(phost, lun);
    235              
    236              if(error == USBH_OK)
    237              {
    238                USBH_memset(inquiry, 0, sizeof(SCSI_StdInquiryDataTypeDef));
    239                /*assign Inquiry Data */
    240                inquiry->DeviceType = MSC_Handle->hbot.pbuf[0] & 0x1F;
    241                inquiry->PeripheralQualifier = MSC_Handle->hbot.pbuf[0] >> 5;  
    242                inquiry->RemovableMedia = (MSC_Handle->hbot.pbuf[1] & 0x80)== 0x80;
    243                USBH_memcpy (inquiry->vendor_id, &MSC_Handle->hbot.pbuf[8], 8);
    244                USBH_memcpy (inquiry->product_id, &MSC_Handle->hbot.pbuf[16], 16);
    245                USBH_memcpy (inquiry->revision_id, &MSC_Handle->hbot.pbuf[32], 4);    
    246              }
    247              break;
    248              
    249            default:
    250              break;
    251            }
    252            
    253            return error;
   \   0000001C   0x4638             MOV      R0,R7
   \   0000001E   0xB001             ADD      SP,SP,#+4
   \   00000020   0xBDF0             POP      {R4-R7,PC}
   \                     ??USBH_MSC_SCSI_Inquiry_0: (+1)
   \   00000022   0x2024             MOVS     R0,#+36
   \   00000024   0x210A             MOVS     R1,#+10
   \   00000026   0x65E8             STR      R0,[R5, #+92]
   \   00000028   0x2080             MOVS     R0,#+128
   \   0000002A   0xF885 0x0060      STRB     R0,[R5, #+96]
   \   0000002E   0x200A             MOVS     R0,#+10
   \   00000030   0xF885 0x0062      STRB     R0,[R5, #+98]
   \   00000034   0xF105 0x0063      ADD      R0,R5,#+99
   \   00000038   0x.... 0x....      BL       __aeabi_memclr
   \   0000003C   0x2012             MOVS     R0,#+18
   \   0000003E   0xF885 0x7052      STRB     R7,[R5, #+82]
   \   00000042   0xF885 0x0063      STRB     R0,[R5, #+99]
   \   00000046   0x0160             LSLS     R0,R4,#+5
   \   00000048   0xF885 0x0064      STRB     R0,[R5, #+100]
   \   0000004C   0x2000             MOVS     R0,#+0
   \   0000004E   0xF885 0x0065      STRB     R0,[R5, #+101]
   \   00000052   0x2701             MOVS     R7,#+1
   \   00000054   0xF885 0x0066      STRB     R0,[R5, #+102]
   \   00000058   0x2024             MOVS     R0,#+36
   \   0000005A   0xF885 0x0067      STRB     R0,[R5, #+103]
   \   0000005E   0x2000             MOVS     R0,#+0
   \   00000060   0xF885 0x0068      STRB     R0,[R5, #+104]
   \   00000064   0x2001             MOVS     R0,#+1
   \   00000066   0xF885 0x0050      STRB     R0,[R5, #+80]
   \   0000006A   0xF105 0x0010      ADD      R0,R5,#+16
   \   0000006E   0xF8C5 0x008C      STR      R0,[R5, #+140]
   \   00000072   0x4638             MOV      R0,R7
   \   00000074   0xB001             ADD      SP,SP,#+4
   \   00000076   0xBDF0             POP      {R4-R7,PC}
   \                     ??USBH_MSC_SCSI_Inquiry_1: (+1)
   \   00000078   0x4621             MOV      R1,R4
   \   0000007A   0x.... 0x....      BL       USBH_MSC_BOT_Process
   \   0000007E   0x0007             MOVS     R7,R0
   \   00000080   0xD12D             BNE.N    ??USBH_MSC_SCSI_Inquiry_2
   \   00000082   0x2122             MOVS     R1,#+34
   \   00000084   0x4630             MOV      R0,R6
   \   00000086   0x.... 0x....      BL       __aeabi_memclr
   \   0000008A   0xF8D5 0x008C      LDR      R0,[R5, #+140]
   \   0000008E   0x2208             MOVS     R2,#+8
   \   00000090   0x7800             LDRB     R0,[R0, #+0]
   \   00000092   0xF000 0x001F      AND      R0,R0,#0x1F
   \   00000096   0x7070             STRB     R0,[R6, #+1]
   \   00000098   0xF8D5 0x008C      LDR      R0,[R5, #+140]
   \   0000009C   0x7800             LDRB     R0,[R0, #+0]
   \   0000009E   0x0940             LSRS     R0,R0,#+5
   \   000000A0   0x7030             STRB     R0,[R6, #+0]
   \   000000A2   0xF8D5 0x008C      LDR      R0,[R5, #+140]
   \   000000A6   0x7840             LDRB     R0,[R0, #+1]
   \   000000A8   0x09C0             LSRS     R0,R0,#+7
   \   000000AA   0x70B0             STRB     R0,[R6, #+2]
   \   000000AC   0xF8D5 0x008C      LDR      R0,[R5, #+140]
   \   000000B0   0xF100 0x0108      ADD      R1,R0,#+8
   \   000000B4   0x1CF0             ADDS     R0,R6,#+3
   \   000000B6   0x.... 0x....      BL       __aeabi_memcpy
   \   000000BA   0xF8D5 0x008C      LDR      R0,[R5, #+140]
   \   000000BE   0x2210             MOVS     R2,#+16
   \   000000C0   0xF100 0x0110      ADD      R1,R0,#+16
   \   000000C4   0xF106 0x000C      ADD      R0,R6,#+12
   \   000000C8   0x.... 0x....      BL       __aeabi_memcpy
   \   000000CC   0xF8D5 0x008C      LDR      R0,[R5, #+140]
   \   000000D0   0x2204             MOVS     R2,#+4
   \   000000D2   0xF100 0x0120      ADD      R1,R0,#+32
   \   000000D6   0xF106 0x001D      ADD      R0,R6,#+29
   \   000000DA   0x.... 0x....      BL       __aeabi_memcpy
   \                     ??USBH_MSC_SCSI_Inquiry_2: (+1)
   \   000000DE   0x4638             MOV      R0,R7
   \   000000E0   0xB001             ADD      SP,SP,#+4
   \   000000E2   0xBDF0             POP      {R4-R7,PC}       ;; return
    254          }
    255          
    256          /**
    257            * @brief  USBH_MSC_SCSI_RequestSense 
    258            *         Issue RequestSense command.
    259            * @param  phost: Host handle
    260            * @param  lun: Logical Unit Number
    261            * @param  capacity: pointer to the sense data structure
    262            * @retval USBH Status
    263            */

   \                                 In section .text, align 2, keep-with-next
    264          USBH_StatusTypeDef USBH_MSC_SCSI_RequestSense (USBH_HandleTypeDef *phost, 
    265                                                         uint8_t lun, 
    266                                                         SCSI_SenseTypeDef *sense_data)
    267          {
   \                     USBH_MSC_SCSI_RequestSense: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x460C             MOV      R4,R1
   \   00000004   0x4603             MOV      R3,R0
    268            USBH_StatusTypeDef    error = USBH_FAIL ;
   \   00000006   0x2002             MOVS     R0,#+2
   \   00000008   0x4616             MOV      R6,R2
    269            MSC_HandleTypeDef *MSC_Handle =  (MSC_HandleTypeDef *) phost->pActiveClass->pData;
   \   0000000A   0xF8D3 0x1264      LDR      R1,[R3, #+612]
   \   0000000E   0x69CD             LDR      R5,[R1, #+28]
    270            
    271            switch(MSC_Handle->hbot.cmd_state)
   \   00000010   0xF895 0x1052      LDRB     R1,[R5, #+82]
   \   00000014   0x2901             CMP      R1,#+1
   \   00000016   0xD002             BEQ.N    ??USBH_MSC_SCSI_RequestSense_0
   \   00000018   0x2902             CMP      R1,#+2
   \   0000001A   0xD02A             BEQ.N    ??USBH_MSC_SCSI_RequestSense_1
   \   0000001C   0xBD70             POP      {R4-R6,PC}
    272            {
    273            case BOT_CMD_SEND:  
    274              
    275              /*Prepare the CBW and relevent field*/
    276              MSC_Handle->hbot.cbw.field.DataTransferLength = DATA_LEN_REQUEST_SENSE;
   \                     ??USBH_MSC_SCSI_RequestSense_0: (+1)
   \   0000001E   0x200E             MOVS     R0,#+14
    277              MSC_Handle->hbot.cbw.field.Flags = USB_EP_DIR_IN;
    278              MSC_Handle->hbot.cbw.field.CBLength = CBW_LENGTH;
    279              
    280              USBH_memset(MSC_Handle->hbot.cbw.field.CB, 0, CBW_CB_LENGTH);
   \   00000020   0x2110             MOVS     R1,#+16
   \   00000022   0x65E8             STR      R0,[R5, #+92]
   \   00000024   0x2080             MOVS     R0,#+128
   \   00000026   0xF885 0x0060      STRB     R0,[R5, #+96]
   \   0000002A   0x200A             MOVS     R0,#+10
   \   0000002C   0xF885 0x0062      STRB     R0,[R5, #+98]
   \   00000030   0xF105 0x0063      ADD      R0,R5,#+99
   \   00000034   0x.... 0x....      BL       __aeabi_memclr
    281              MSC_Handle->hbot.cbw.field.CB[0]  = OPCODE_REQUEST_SENSE; 
   \   00000038   0x2003             MOVS     R0,#+3
   \   0000003A   0xF885 0x0063      STRB     R0,[R5, #+99]
    282              MSC_Handle->hbot.cbw.field.CB[1]  = (lun << 5); 
   \   0000003E   0x0160             LSLS     R0,R4,#+5
   \   00000040   0xF885 0x0064      STRB     R0,[R5, #+100]
    283              MSC_Handle->hbot.cbw.field.CB[2]  = 0; 
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0xF885 0x0065      STRB     R0,[R5, #+101]
    284              MSC_Handle->hbot.cbw.field.CB[3]  = 0; 
   \   0000004A   0xF885 0x0066      STRB     R0,[R5, #+102]
    285              MSC_Handle->hbot.cbw.field.CB[4]  = DATA_LEN_REQUEST_SENSE;
   \   0000004E   0x200E             MOVS     R0,#+14
   \   00000050   0xF885 0x0067      STRB     R0,[R5, #+103]
    286              MSC_Handle->hbot.cbw.field.CB[5]  = 0;       
   \   00000054   0x2000             MOVS     R0,#+0
   \   00000056   0xF885 0x0068      STRB     R0,[R5, #+104]
    287              
    288              MSC_Handle->hbot.state = BOT_SEND_CBW;
   \   0000005A   0x2001             MOVS     R0,#+1
   \   0000005C   0xF885 0x0050      STRB     R0,[R5, #+80]
    289              MSC_Handle->hbot.cmd_state = BOT_CMD_WAIT;
   \   00000060   0x2002             MOVS     R0,#+2
   \   00000062   0xF885 0x0052      STRB     R0,[R5, #+82]
    290              MSC_Handle->hbot.pbuf = (uint8_t *)MSC_Handle->hbot.data;
   \   00000066   0xF105 0x0010      ADD      R0,R5,#+16
   \   0000006A   0xF8C5 0x008C      STR      R0,[R5, #+140]
    291              error = USBH_BUSY; 
   \   0000006E   0x2001             MOVS     R0,#+1
    292              break;
   \   00000070   0xBD70             POP      {R4-R6,PC}
    293              
    294            case BOT_CMD_WAIT: 
    295              
    296              error = USBH_MSC_BOT_Process(phost, lun);
   \                     ??USBH_MSC_SCSI_RequestSense_1: (+1)
   \   00000072   0x4621             MOV      R1,R4
   \   00000074   0x4618             MOV      R0,R3
   \   00000076   0x.... 0x....      BL       USBH_MSC_BOT_Process
    297              
    298              if(error == USBH_OK)
   \   0000007A   0xB968             CBNZ.N   R0,??USBH_MSC_SCSI_RequestSense_2
    299              {
    300                sense_data->key  = MSC_Handle->hbot.pbuf[2] & 0x0F;  
   \   0000007C   0xF8D5 0x108C      LDR      R1,[R5, #+140]
   \   00000080   0x7889             LDRB     R1,[R1, #+2]
   \   00000082   0xF001 0x010F      AND      R1,R1,#0xF
   \   00000086   0x7031             STRB     R1,[R6, #+0]
    301                sense_data->asc  = MSC_Handle->hbot.pbuf[12];
   \   00000088   0xF8D5 0x108C      LDR      R1,[R5, #+140]
   \   0000008C   0x7B09             LDRB     R1,[R1, #+12]
   \   0000008E   0x7071             STRB     R1,[R6, #+1]
    302                sense_data->ascq = MSC_Handle->hbot.pbuf[13];
   \   00000090   0xF8D5 0x108C      LDR      R1,[R5, #+140]
   \   00000094   0x7B49             LDRB     R1,[R1, #+13]
   \   00000096   0x70B1             STRB     R1,[R6, #+2]
    303              }
    304              break;
    305              
    306            default:
    307              break;
    308            }
    309            
    310            return error;
   \                     ??USBH_MSC_SCSI_RequestSense_2: (+1)
   \   00000098   0xBD70             POP      {R4-R6,PC}       ;; return
    311          }
    312          
    313          /**
    314            * @brief  USBH_MSC_SCSI_Write 
    315            *         Issue write10 command.
    316            * @param  phost: Host handle
    317            * @param  lun: Logical Unit Number
    318            * @param  address: sector address
    319            * @param  pbuf: pointer to data
    320            * @param  length: number of sector to write
    321            * @retval USBH Status
    322            */

   \                                 In section .text, align 2, keep-with-next
    323          USBH_StatusTypeDef USBH_MSC_SCSI_Write(USBH_HandleTypeDef *phost,
    324                                               uint8_t lun,
    325                                               uint32_t address,
    326                                               uint8_t *pbuf,
    327                                               uint32_t length)
    328          {
   \                     USBH_MSC_SCSI_Write: (+1)
   \   00000000   0xB534             PUSH     {R2,R4,R5,LR}
   \   00000002   0x461C             MOV      R4,R3
   \   00000004   0x4602             MOV      R2,R0
    329            USBH_StatusTypeDef    error = USBH_FAIL ;
   \   00000006   0x2002             MOVS     R0,#+2
    330          
    331            MSC_HandleTypeDef *MSC_Handle =  (MSC_HandleTypeDef *) phost->pActiveClass->pData;
   \   00000008   0xF8D2 0x3264      LDR      R3,[R2, #+612]
   \   0000000C   0x69DD             LDR      R5,[R3, #+28]
    332            
    333            switch(MSC_Handle->hbot.cmd_state)
   \   0000000E   0xF895 0x3052      LDRB     R3,[R5, #+82]
   \   00000012   0x2B01             CMP      R3,#+1
   \   00000014   0xD003             BEQ.N    ??USBH_MSC_SCSI_Write_0
   \   00000016   0x2B02             CMP      R3,#+2
   \   00000018   0xD035             BEQ.N    ??USBH_MSC_SCSI_Write_1
    334            {
    335            case BOT_CMD_SEND:  
    336              
    337              /*Prepare the CBW and relevent field*/
    338              MSC_Handle->hbot.cbw.field.DataTransferLength = length * 512;
    339              MSC_Handle->hbot.cbw.field.Flags = USB_EP_DIR_OUT;
    340              MSC_Handle->hbot.cbw.field.CBLength = CBW_LENGTH;
    341              
    342              USBH_memset(MSC_Handle->hbot.cbw.field.CB, 0, CBW_CB_LENGTH);
    343              MSC_Handle->hbot.cbw.field.CB[0]  = OPCODE_WRITE10; 
    344              
    345              /*logical block address*/
    346              MSC_Handle->hbot.cbw.field.CB[2]  = (((uint8_t*)&address)[3]);
    347              MSC_Handle->hbot.cbw.field.CB[3]  = (((uint8_t*)&address)[2]);
    348              MSC_Handle->hbot.cbw.field.CB[4]  = (((uint8_t*)&address)[1]);
    349              MSC_Handle->hbot.cbw.field.CB[5]  = (((uint8_t*)&address)[0]);
    350              
    351              
    352              /*Transfer length */
    353              MSC_Handle->hbot.cbw.field.CB[7]  = (((uint8_t *)&length)[1]) ; 
    354              MSC_Handle->hbot.cbw.field.CB[8]  = (((uint8_t *)&length)[0]) ; 
    355          
    356              
    357              MSC_Handle->hbot.state = BOT_SEND_CBW;
    358              MSC_Handle->hbot.cmd_state = BOT_CMD_WAIT;
    359              MSC_Handle->hbot.pbuf = pbuf;
    360              error = USBH_BUSY; 
    361              break;
    362              
    363            case BOT_CMD_WAIT: 
    364              error = USBH_MSC_BOT_Process(phost, lun);
    365              break;
    366              
    367            default:
    368              break;
    369            }
    370            
    371            return error;
   \   0000001A   0xB001             ADD      SP,SP,#+4
   \   0000001C   0xBD30             POP      {R4,R5,PC}
   \                     ??USBH_MSC_SCSI_Write_0: (+1)
   \   0000001E   0x9804             LDR      R0,[SP, #+16]
   \   00000020   0x2110             MOVS     R1,#+16
   \   00000022   0x0240             LSLS     R0,R0,#+9
   \   00000024   0x65E8             STR      R0,[R5, #+92]
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0xF885 0x0060      STRB     R0,[R5, #+96]
   \   0000002C   0x200A             MOVS     R0,#+10
   \   0000002E   0xF885 0x0062      STRB     R0,[R5, #+98]
   \   00000032   0xF105 0x0063      ADD      R0,R5,#+99
   \   00000036   0x.... 0x....      BL       __aeabi_memclr
   \   0000003A   0x202A             MOVS     R0,#+42
   \   0000003C   0xF885 0x0063      STRB     R0,[R5, #+99]
   \   00000040   0xF89D 0x0003      LDRB     R0,[SP, #+3]
   \   00000044   0xF885 0x0065      STRB     R0,[R5, #+101]
   \   00000048   0xF89D 0x0002      LDRB     R0,[SP, #+2]
   \   0000004C   0xF885 0x0066      STRB     R0,[R5, #+102]
   \   00000050   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \   00000054   0xF885 0x0067      STRB     R0,[R5, #+103]
   \   00000058   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000005C   0xF885 0x0068      STRB     R0,[R5, #+104]
   \   00000060   0xF89D 0x0011      LDRB     R0,[SP, #+17]
   \   00000064   0xF885 0x006A      STRB     R0,[R5, #+106]
   \   00000068   0xF89D 0x0010      LDRB     R0,[SP, #+16]
   \   0000006C   0xF8C5 0x408C      STR      R4,[R5, #+140]
   \   00000070   0xF885 0x006B      STRB     R0,[R5, #+107]
   \   00000074   0x2001             MOVS     R0,#+1
   \   00000076   0xF885 0x0050      STRB     R0,[R5, #+80]
   \   0000007A   0x2002             MOVS     R0,#+2
   \   0000007C   0xF885 0x0052      STRB     R0,[R5, #+82]
   \   00000080   0x2001             MOVS     R0,#+1
   \   00000082   0xB001             ADD      SP,SP,#+4
   \   00000084   0xBD30             POP      {R4,R5,PC}
   \                     ??USBH_MSC_SCSI_Write_1: (+1)
   \   00000086   0xB001             ADD      SP,SP,#+4
   \   00000088   0x4610             MOV      R0,R2
   \   0000008A   0xE8BD 0x4030      POP      {R4,R5,LR}
   \   0000008E   0x.... 0x....      B.W      USBH_MSC_BOT_Process
    372          }
    373          
    374          /**
    375            * @brief  USBH_MSC_SCSI_Read 
    376            *         Issue Read10 command.
    377            * @param  phost: Host handle
    378            * @param  lun: Logical Unit Number
    379            * @param  address: sector address
    380            * @param  pbuf: pointer to data
    381            * @param  length: number of sector to read
    382            * @retval USBH Status
    383            */

   \                                 In section .text, align 2, keep-with-next
    384          USBH_StatusTypeDef USBH_MSC_SCSI_Read(USBH_HandleTypeDef *phost,
    385                                               uint8_t lun,
    386                                               uint32_t address,
    387                                               uint8_t *pbuf,
    388                                               uint32_t length)
    389          {
   \                     USBH_MSC_SCSI_Read: (+1)
   \   00000000   0xB534             PUSH     {R2,R4,R5,LR}
   \   00000002   0x461C             MOV      R4,R3
   \   00000004   0x4602             MOV      R2,R0
    390            USBH_StatusTypeDef    error = USBH_FAIL ;
   \   00000006   0x2002             MOVS     R0,#+2
    391            MSC_HandleTypeDef *MSC_Handle = (MSC_HandleTypeDef *) phost->pActiveClass->pData;
   \   00000008   0xF8D2 0x3264      LDR      R3,[R2, #+612]
   \   0000000C   0x69DD             LDR      R5,[R3, #+28]
    392            
    393            switch(MSC_Handle->hbot.cmd_state)
   \   0000000E   0xF895 0x3052      LDRB     R3,[R5, #+82]
   \   00000012   0x2B01             CMP      R3,#+1
   \   00000014   0xD003             BEQ.N    ??USBH_MSC_SCSI_Read_0
   \   00000016   0x2B02             CMP      R3,#+2
   \   00000018   0xD035             BEQ.N    ??USBH_MSC_SCSI_Read_1
    394            {
    395            case BOT_CMD_SEND:  
    396              
    397              /*Prepare the CBW and relevent field*/
    398              MSC_Handle->hbot.cbw.field.DataTransferLength = length * 512;
    399              MSC_Handle->hbot.cbw.field.Flags = USB_EP_DIR_IN;
    400              MSC_Handle->hbot.cbw.field.CBLength = CBW_LENGTH;
    401              
    402              USBH_memset(MSC_Handle->hbot.cbw.field.CB, 0, CBW_CB_LENGTH);
    403              MSC_Handle->hbot.cbw.field.CB[0]  = OPCODE_READ10; 
    404              
    405              /*logical block address*/
    406              MSC_Handle->hbot.cbw.field.CB[2]  = (((uint8_t*)&address)[3]);
    407              MSC_Handle->hbot.cbw.field.CB[3]  = (((uint8_t*)&address)[2]);
    408              MSC_Handle->hbot.cbw.field.CB[4]  = (((uint8_t*)&address)[1]);
    409              MSC_Handle->hbot.cbw.field.CB[5]  = (((uint8_t*)&address)[0]);
    410              
    411              
    412              /*Transfer length */
    413              MSC_Handle->hbot.cbw.field.CB[7]  = (((uint8_t *)&length)[1]) ; 
    414              MSC_Handle->hbot.cbw.field.CB[8]  = (((uint8_t *)&length)[0]) ; 
    415          
    416              
    417              MSC_Handle->hbot.state = BOT_SEND_CBW;
    418              MSC_Handle->hbot.cmd_state = BOT_CMD_WAIT;
    419              MSC_Handle->hbot.pbuf = pbuf;
    420              error = USBH_BUSY; 
    421              break;
    422              
    423            case BOT_CMD_WAIT: 
    424              error = USBH_MSC_BOT_Process(phost, lun);
    425              break;
    426              
    427            default:
    428              break;
    429            }
    430            
    431            return error;
   \   0000001A   0xB001             ADD      SP,SP,#+4
   \   0000001C   0xBD30             POP      {R4,R5,PC}
   \                     ??USBH_MSC_SCSI_Read_0: (+1)
   \   0000001E   0x9804             LDR      R0,[SP, #+16]
   \   00000020   0x2110             MOVS     R1,#+16
   \   00000022   0x0240             LSLS     R0,R0,#+9
   \   00000024   0x65E8             STR      R0,[R5, #+92]
   \   00000026   0x2080             MOVS     R0,#+128
   \   00000028   0xF885 0x0060      STRB     R0,[R5, #+96]
   \   0000002C   0x200A             MOVS     R0,#+10
   \   0000002E   0xF885 0x0062      STRB     R0,[R5, #+98]
   \   00000032   0xF105 0x0063      ADD      R0,R5,#+99
   \   00000036   0x.... 0x....      BL       __aeabi_memclr
   \   0000003A   0x2028             MOVS     R0,#+40
   \   0000003C   0xF885 0x0063      STRB     R0,[R5, #+99]
   \   00000040   0xF89D 0x0003      LDRB     R0,[SP, #+3]
   \   00000044   0xF885 0x0065      STRB     R0,[R5, #+101]
   \   00000048   0xF89D 0x0002      LDRB     R0,[SP, #+2]
   \   0000004C   0xF885 0x0066      STRB     R0,[R5, #+102]
   \   00000050   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \   00000054   0xF885 0x0067      STRB     R0,[R5, #+103]
   \   00000058   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000005C   0xF885 0x0068      STRB     R0,[R5, #+104]
   \   00000060   0xF89D 0x0011      LDRB     R0,[SP, #+17]
   \   00000064   0xF885 0x006A      STRB     R0,[R5, #+106]
   \   00000068   0xF89D 0x0010      LDRB     R0,[SP, #+16]
   \   0000006C   0xF8C5 0x408C      STR      R4,[R5, #+140]
   \   00000070   0xF885 0x006B      STRB     R0,[R5, #+107]
   \   00000074   0x2001             MOVS     R0,#+1
   \   00000076   0xF885 0x0050      STRB     R0,[R5, #+80]
   \   0000007A   0x2002             MOVS     R0,#+2
   \   0000007C   0xF885 0x0052      STRB     R0,[R5, #+82]
   \   00000080   0x2001             MOVS     R0,#+1
   \   00000082   0xB001             ADD      SP,SP,#+4
   \   00000084   0xBD30             POP      {R4,R5,PC}
   \                     ??USBH_MSC_SCSI_Read_1: (+1)
   \   00000086   0xB001             ADD      SP,SP,#+4
   \   00000088   0x4610             MOV      R0,R2
   \   0000008A   0xE8BD 0x4030      POP      {R4,R5,LR}
   \   0000008E   0x.... 0x....      B.W      USBH_MSC_BOT_Process
    432          }
    433          
    434          
    435          /**
    436            * @}
    437            */ 
    438          
    439          /**
    440            * @}
    441            */ 
    442          
    443          /**
    444            * @}
    445            */
    446          
    447          /**
    448            * @}
    449            */ 
    450          
    451          /**
    452            * @}
    453            */
    454          
    455          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
    456          
    457          
    458          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   USBH_MSC_SCSI_Inquiry
        24   -> USBH_MSC_BOT_Process
        24   -> __aeabi_memclr
        24   -> __aeabi_memcpy
      16   USBH_MSC_SCSI_Read
         0   -> USBH_MSC_BOT_Process
        16   -> __aeabi_memclr
      16   USBH_MSC_SCSI_ReadCapacity
        16   -> USBH_MSC_BOT_Process
        16   -> __aeabi_memclr
      16   USBH_MSC_SCSI_RequestSense
        16   -> USBH_MSC_BOT_Process
        16   -> __aeabi_memclr
       8   USBH_MSC_SCSI_TestUnitReady
         0   -> USBH_MSC_BOT_Process
         8   -> __aeabi_memclr
      16   USBH_MSC_SCSI_Write
         0   -> USBH_MSC_BOT_Process
        16   -> __aeabi_memclr


   Section sizes:

   Bytes  Function/Label
   -----  --------------
     228  USBH_MSC_SCSI_Inquiry
     146  USBH_MSC_SCSI_Read
     134  USBH_MSC_SCSI_ReadCapacity
     154  USBH_MSC_SCSI_RequestSense
      82  USBH_MSC_SCSI_TestUnitReady
     146  USBH_MSC_SCSI_Write

 
 890 bytes in section .text
 
 890 bytes of CODE memory

Errors: none
Warnings: none
