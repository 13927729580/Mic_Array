###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.2.10312/W32 for ARM       28/Feb/2016  17:26:23
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_flash.c
#    Command line =  
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_flash.c
#        -D USE_HAL_DRIVER -D STM32F746xx -D USE_STM32746G_DISCO -D
#        USE_IOEXPANDER -D USE_USB_FS -lC
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
#        -lA
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
#        -o
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M7 -e --fpu=VFPv5_sp --dlib_config "D:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.3\arm\INC\c\DLib_Config_Full.h"
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\Inc\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\CMSIS\Device\ST\STM32F7xx\Include\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\STM32F7xx_HAL_Driver\Inc\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\STM32746G-Discovery\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\Components\Common\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Log\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Fonts\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\CPU\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_Device_Library\Core\Inc\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Core\Inc\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Class\MSC\Inc\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\drivers\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_Audio\Addons\PDM\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_Device_Library\Class\AUDIO\Inc\
#        -On --use_c++_inline --require_prototypes -I "D:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.3\arm\CMSIS\Include\" -D
#        ARM_MATH_CM7
#    List file    =  
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List\stm32f7xx_hal_flash.lst
#    Object file  =  
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj\stm32f7xx_hal_flash.o
#
###############################################################################

H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_flash.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f7xx_hal_flash.c
      4            * @author  MCD Application Team
      5            * @version V1.0.1
      6            * @date    25-June-2015
      7            * @brief   FLASH HAL module driver.
      8            *          This file provides firmware functions to manage the following 
      9            *          functionalities of the internal FLASH memory:
     10            *           + Program operations functions
     11            *           + Memory Control functions 
     12            *           + Peripheral Errors functions
     13            *         
     14            @verbatim
     15            ==============================================================================
     16                                  ##### FLASH peripheral features #####
     17            ==============================================================================
     18                     
     19            [..] The Flash memory interface manages CPU AHB I-Code and D-Code accesses 
     20                 to the Flash memory. It implements the erase and program Flash memory operations 
     21                 and the read and write protection mechanisms.
     22                
     23            [..] The Flash memory interface accelerates code execution with a system of instruction
     24                 prefetch and cache lines. 
     25          
     26            [..] The FLASH main features are:
     27                (+) Flash memory read operations
     28                (+) Flash memory program/erase operations
     29                (+) Read / write protections
     30                (+) Prefetch on I-Code
     31                (+) 64 cache lines of 128 bits on I-Code
     32                (+) 8 cache lines of 128 bits on D-Code
     33                
     34                               ##### How to use this driver #####
     35            ==============================================================================
     36              [..]                             
     37                This driver provides functions and macros to configure and program the FLASH 
     38                memory of all STM32F7xx devices.
     39              
     40                (#) FLASH Memory IO Programming functions: 
     41                     (++) Lock and Unlock the FLASH interface using HAL_FLASH_Unlock() and 
     42                          HAL_FLASH_Lock() functions
     43                     (++) Program functions: byte, half word, word and double word
     44                     (++) There Two modes of programming :
     45                      (+++) Polling mode using HAL_FLASH_Program() function
     46                      (+++) Interrupt mode using HAL_FLASH_Program_IT() function
     47              
     48                (#) Interrupts and flags management functions : 
     49                     (++) Handle FLASH interrupts by calling HAL_FLASH_IRQHandler()
     50                     (++) Wait for last FLASH operation according to its status
     51                     (++) Get error flag status by calling HAL_SetErrorCode()          
     52              [..] 
     53                In addition to these functions, this driver includes a set of macros allowing
     54                to handle the following operations:
     55                 (+) Set the latency
     56                 (+) Enable/Disable the prefetch buffer
     57                 (+) Enable/Disable the Instruction cache and the Data cache
     58                 (+) Reset the Instruction cache and the Data cache
     59                 (+) Enable/Disable the FLASH interrupts
     60                 (+) Monitor the FLASH flags status
     61              [..]	   
     62          	(@) For any Flash memory program operation (erase or program), the CPU clock frequency
     63                  (HCLK) must be at least 1MHz. 
     64          	(@) The contents of the Flash memory are not guaranteed if a device reset occurs during 
     65          	    a Flash memory operation.
     66              (@) Any attempt to read the Flash memory while it is being written or erased, causes the 
     67          	    bus to stall. Read operations are processed correctly once the program operation has 
     68          		completed. This means that code or data fetches cannot be performed while a write/erase 
     69          		operation is ongoing.
     70                    
     71            @endverbatim
     72            ******************************************************************************
     73            * @attention
     74            *
     75            * <h2><center>&copy; COPYRIGHT(c) 2015 STMicroelectronics</center></h2>
     76            *
     77            * Redistribution and use in source and binary forms, with or without modification,
     78            * are permitted provided that the following conditions are met:
     79            *   1. Redistributions of source code must retain the above copyright notice,
     80            *      this list of conditions and the following disclaimer.
     81            *   2. Redistributions in binary form must reproduce the above copyright notice,
     82            *      this list of conditions and the following disclaimer in the documentation
     83            *      and/or other materials provided with the distribution.
     84            *   3. Neither the name of STMicroelectronics nor the names of its contributors
     85            *      may be used to endorse or promote products derived from this software
     86            *      without specific prior written permission.
     87            *
     88            * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
     89            * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     90            * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     91            * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
     92            * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
     93            * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
     94            * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
     95            * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
     96            * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
     97            * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     98            *
     99            ******************************************************************************
    100            */ 
    101          
    102          /* Includes ------------------------------------------------------------------*/
    103          #include "stm32f7xx_hal.h"
    104          
    105          /** @addtogroup STM32F7xx_HAL_Driver
    106            * @{
    107            */
    108          
    109          /** @defgroup FLASH FLASH
    110            * @brief FLASH HAL module driver
    111            * @{
    112            */
    113          
    114          #ifdef HAL_FLASH_MODULE_ENABLED
    115          
    116          /* Private typedef -----------------------------------------------------------*/
    117          /* Private define ------------------------------------------------------------*/
    118          /** @addtogroup FLASH_Private_Constants
    119            * @{
    120            */
    121          #define SECTOR_MASK               ((uint32_t)0xFFFFFF07)
    122          #define FLASH_TIMEOUT_VALUE       ((uint32_t)50000)/* 50 s */
    123          /**
    124            * @}
    125            */         
    126          /* Private macro -------------------------------------------------------------*/
    127          /* Private variables ---------------------------------------------------------*/
    128          /** @addtogroup FLASH_Private_Variables
    129            * @{
    130            */
    131          /* Variable used for Erase sectors under interruption */

   \                                 In section .bss, align 4
    132          FLASH_ProcessTypeDef pFlash;
   \                     pFlash:
   \   00000000                      DS8 28
    133          /**
    134            * @}
    135            */
    136          
    137          /* Private function prototypes -----------------------------------------------*/
    138          /** @addtogroup FLASH_Private_Functions
    139            * @{
    140            */
    141          /* Program operations */
    142          static void   FLASH_Program_DoubleWord(uint32_t Address, uint64_t Data);
    143          static void   FLASH_Program_Word(uint32_t Address, uint32_t Data);
    144          static void   FLASH_Program_HalfWord(uint32_t Address, uint16_t Data);
    145          static void   FLASH_Program_Byte(uint32_t Address, uint8_t Data);
    146          static void   FLASH_SetErrorCode(void);
    147          
    148          HAL_StatusTypeDef FLASH_WaitForLastOperation(uint32_t Timeout);
    149          /**
    150            * @}
    151            */
    152          
    153          /* Exported functions --------------------------------------------------------*/
    154          /** @defgroup FLASH_Exported_Functions FLASH Exported Functions
    155            * @{
    156            */
    157            
    158          /** @defgroup FLASH_Exported_Functions_Group1 Programming operation functions 
    159           *  @brief   Programming operation functions 
    160           *
    161          @verbatim   
    162           ===============================================================================
    163                            ##### Programming operation functions #####
    164           ===============================================================================  
    165              [..]
    166              This subsection provides a set of functions allowing to manage the FLASH 
    167              program operations.
    168          
    169          @endverbatim
    170            * @{
    171            */
    172          
    173          /**
    174            * @brief  Program byte, halfword, word or double word at a specified address
    175            * @param  TypeProgram:  Indicate the way to program at a specified address.
    176            *                           This parameter can be a value of @ref FLASH_Type_Program
    177            * @param  Address:  specifies the address to be programmed.
    178            * @param  Data: specifies the data to be programmed
    179            * 
    180            * @retval HAL_StatusTypeDef HAL Status
    181            */

   \                                 In section .text, align 2, keep-with-next
    182          HAL_StatusTypeDef HAL_FLASH_Program(uint32_t TypeProgram, uint32_t Address, uint64_t Data)
    183          {
   \                     HAL_FLASH_Program: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0006             MOVS     R6,R0
   \   00000006   0x000F             MOVS     R7,R1
   \   00000008   0x0014             MOVS     R4,R2
   \   0000000A   0x001D             MOVS     R5,R3
    184            HAL_StatusTypeDef status = HAL_ERROR;
   \   0000000C   0xF05F 0x0801      MOVS     R8,#+1
    185            
    186            /* Process Locked */
    187            __HAL_LOCK(&pFlash);
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable14
   \   00000014   0x7D00             LDRB     R0,[R0, #+20]
   \   00000016   0x2801             CMP      R0,#+1
   \   00000018   0xD101             BNE.N    ??HAL_FLASH_Program_0
   \   0000001A   0x2002             MOVS     R0,#+2
   \   0000001C   0xE03F             B.N      ??HAL_FLASH_Program_1
   \                     ??HAL_FLASH_Program_0: (+1)
   \   0000001E   0x2001             MOVS     R0,#+1
   \   00000020   0x.... 0x....      LDR.W    R1,??DataTable14
   \   00000024   0x7508             STRB     R0,[R1, #+20]
    188          
    189            /* Check the parameters */
    190            assert_param(IS_FLASH_TYPEPROGRAM(TypeProgram));
    191          
    192            /* Wait for last operation to be completed */
    193            status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
   \   00000026   0xF24C 0x3050      MOVW     R0,#+50000
   \   0000002A   0x.... 0x....      BL       FLASH_WaitForLastOperation
   \   0000002E   0x4680             MOV      R8,R0
    194            
    195            if(status == HAL_OK)
   \   00000030   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000034   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000038   0xD12B             BNE.N    ??HAL_FLASH_Program_2
    196            {
    197              switch(TypeProgram)
   \   0000003A   0x2E00             CMP      R6,#+0
   \   0000003C   0xD005             BEQ.N    ??HAL_FLASH_Program_3
   \   0000003E   0x2E02             CMP      R6,#+2
   \   00000040   0xD00F             BEQ.N    ??HAL_FLASH_Program_4
   \   00000042   0xD308             BCC.N    ??HAL_FLASH_Program_5
   \   00000044   0x2E03             CMP      R6,#+3
   \   00000046   0xD011             BEQ.N    ??HAL_FLASH_Program_6
   \   00000048   0xE016             B.N      ??HAL_FLASH_Program_7
    198              {
    199                case FLASH_TYPEPROGRAM_BYTE :
    200                {
    201                  /*Program byte (8-bit) at a specified address.*/
    202                  FLASH_Program_Byte(Address, (uint8_t) Data);
   \                     ??HAL_FLASH_Program_3: (+1)
   \   0000004A   0x0021             MOVS     R1,R4
   \   0000004C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000004E   0x0038             MOVS     R0,R7
   \   00000050   0x.... 0x....      BL       FLASH_Program_Byte
    203                  break;
   \   00000054   0xE010             B.N      ??HAL_FLASH_Program_8
    204                }
    205                
    206                case FLASH_TYPEPROGRAM_HALFWORD :
    207                {
    208                  /*Program halfword (16-bit) at a specified address.*/
    209                  FLASH_Program_HalfWord(Address, (uint16_t) Data);
   \                     ??HAL_FLASH_Program_5: (+1)
   \   00000056   0x0021             MOVS     R1,R4
   \   00000058   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000005A   0x0038             MOVS     R0,R7
   \   0000005C   0x.... 0x....      BL       FLASH_Program_HalfWord
    210                  break;
   \   00000060   0xE00A             B.N      ??HAL_FLASH_Program_8
    211                }
    212                
    213                case FLASH_TYPEPROGRAM_WORD :
    214                {
    215                  /*Program word (32-bit) at a specified address.*/
    216                  FLASH_Program_Word(Address, (uint32_t) Data);
   \                     ??HAL_FLASH_Program_4: (+1)
   \   00000062   0x0021             MOVS     R1,R4
   \   00000064   0x0038             MOVS     R0,R7
   \   00000066   0x.... 0x....      BL       FLASH_Program_Word
    217                  break;
   \   0000006A   0xE005             B.N      ??HAL_FLASH_Program_8
    218                }
    219                
    220                case FLASH_TYPEPROGRAM_DOUBLEWORD :
    221                {
    222                  /*Program double word (64-bit) at a specified address.*/
    223                  FLASH_Program_DoubleWord(Address, Data);
   \                     ??HAL_FLASH_Program_6: (+1)
   \   0000006C   0x0022             MOVS     R2,R4
   \   0000006E   0x002B             MOVS     R3,R5
   \   00000070   0x0038             MOVS     R0,R7
   \   00000072   0x.... 0x....      BL       FLASH_Program_DoubleWord
    224                  break;
   \   00000076   0xE7FF             B.N      ??HAL_FLASH_Program_8
    225                }
    226                default :
    227                  break;
    228              }
    229              /* Wait for last operation to be completed */
    230              status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
   \                     ??HAL_FLASH_Program_7: (+1)
   \                     ??HAL_FLASH_Program_8: (+1)
   \   00000078   0xF24C 0x3050      MOVW     R0,#+50000
   \   0000007C   0x.... 0x....      BL       FLASH_WaitForLastOperation
   \   00000080   0x4680             MOV      R8,R0
    231              
    232              /* If the program operation is completed, disable the PG Bit */
    233              FLASH->CR &= (~FLASH_CR_PG);
   \   00000082   0x.... 0x....      LDR.W    R0,??DataTable14_1  ;; 0x40023c10
   \   00000086   0x6800             LDR      R0,[R0, #+0]
   \   00000088   0x0840             LSRS     R0,R0,#+1
   \   0000008A   0x0040             LSLS     R0,R0,#+1
   \   0000008C   0x.... 0x....      LDR.W    R1,??DataTable14_1  ;; 0x40023c10
   \   00000090   0x6008             STR      R0,[R1, #+0]
    234            }
    235          
    236            /* Process Unlocked */
    237            __HAL_UNLOCK(&pFlash);
   \                     ??HAL_FLASH_Program_2: (+1)
   \   00000092   0x2000             MOVS     R0,#+0
   \   00000094   0x.... 0x....      LDR.W    R1,??DataTable14
   \   00000098   0x7508             STRB     R0,[R1, #+20]
    238          
    239            return status;
   \   0000009A   0x4640             MOV      R0,R8
   \   0000009C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??HAL_FLASH_Program_1: (+1)
   \   0000009E   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    240          }
    241          
    242          /**
    243            * @brief   Program byte, halfword, word or double word at a specified address  with interrupt enabled.
    244            * @param  TypeProgram:  Indicate the way to program at a specified address.
    245            *                           This parameter can be a value of @ref FLASH_Type_Program
    246            * @param  Address:  specifies the address to be programmed.
    247            * @param  Data: specifies the data to be programmed
    248            * 
    249            * @retval HAL Status
    250            */

   \                                 In section .text, align 2, keep-with-next
    251          HAL_StatusTypeDef HAL_FLASH_Program_IT(uint32_t TypeProgram, uint32_t Address, uint64_t Data)
    252          {
   \                     HAL_FLASH_Program_IT: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0006             MOVS     R6,R0
   \   00000006   0x000F             MOVS     R7,R1
   \   00000008   0x0014             MOVS     R4,R2
   \   0000000A   0x001D             MOVS     R5,R3
    253            HAL_StatusTypeDef status = HAL_OK;
   \   0000000C   0xF05F 0x0800      MOVS     R8,#+0
    254            
    255            /* Process Locked */
    256            __HAL_LOCK(&pFlash);
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable14
   \   00000014   0x7D00             LDRB     R0,[R0, #+20]
   \   00000016   0x2801             CMP      R0,#+1
   \   00000018   0xD101             BNE.N    ??HAL_FLASH_Program_IT_0
   \   0000001A   0x2002             MOVS     R0,#+2
   \   0000001C   0xE03F             B.N      ??HAL_FLASH_Program_IT_1
   \                     ??HAL_FLASH_Program_IT_0: (+1)
   \   0000001E   0x2001             MOVS     R0,#+1
   \   00000020   0x.... 0x....      LDR.W    R1,??DataTable14
   \   00000024   0x7508             STRB     R0,[R1, #+20]
    257          
    258            /* Check the parameters */
    259            assert_param(IS_FLASH_TYPEPROGRAM(TypeProgram));
    260          
    261            /* Enable End of FLASH Operation interrupt */
    262            __HAL_FLASH_ENABLE_IT(FLASH_IT_EOP);
   \   00000026   0x.... 0x....      LDR.W    R0,??DataTable14_1  ;; 0x40023c10
   \   0000002A   0x6800             LDR      R0,[R0, #+0]
   \   0000002C   0xF050 0x7080      ORRS     R0,R0,#0x1000000
   \   00000030   0x.... 0x....      LDR.W    R1,??DataTable14_1  ;; 0x40023c10
   \   00000034   0x6008             STR      R0,[R1, #+0]
    263            
    264            /* Enable Error source interrupt */
    265            __HAL_FLASH_ENABLE_IT(FLASH_IT_ERR);
   \   00000036   0x.... 0x....      LDR.W    R0,??DataTable14_1  ;; 0x40023c10
   \   0000003A   0x6800             LDR      R0,[R0, #+0]
   \   0000003C   0xF050 0x7000      ORRS     R0,R0,#0x2000000
   \   00000040   0x.... 0x....      LDR.W    R1,??DataTable14_1  ;; 0x40023c10
   \   00000044   0x6008             STR      R0,[R1, #+0]
    266            
    267            /* Clear pending flags (if any) */  
    268            __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_EOP    | FLASH_FLAG_OPERR | FLASH_FLAG_WRPERR |\
    269                                   FLASH_FLAG_PGAERR | FLASH_FLAG_PGPERR| FLASH_FLAG_ERSERR);  
   \   00000046   0x20F3             MOVS     R0,#+243
   \   00000048   0x.... 0x....      LDR.W    R1,??DataTable14_2  ;; 0x40023c0c
   \   0000004C   0x6008             STR      R0,[R1, #+0]
    270          
    271            pFlash.ProcedureOnGoing = FLASH_PROC_PROGRAM;
   \   0000004E   0x2003             MOVS     R0,#+3
   \   00000050   0x.... 0x....      LDR.W    R1,??DataTable14
   \   00000054   0x7008             STRB     R0,[R1, #+0]
    272            pFlash.Address = Address;
   \   00000056   0x.... 0x....      LDR.W    R0,??DataTable14
   \   0000005A   0x6107             STR      R7,[R0, #+16]
    273            
    274            switch(TypeProgram)
   \   0000005C   0x2E00             CMP      R6,#+0
   \   0000005E   0xD005             BEQ.N    ??HAL_FLASH_Program_IT_2
   \   00000060   0x2E02             CMP      R6,#+2
   \   00000062   0xD00F             BEQ.N    ??HAL_FLASH_Program_IT_3
   \   00000064   0xD308             BCC.N    ??HAL_FLASH_Program_IT_4
   \   00000066   0x2E03             CMP      R6,#+3
   \   00000068   0xD011             BEQ.N    ??HAL_FLASH_Program_IT_5
   \   0000006A   0xE016             B.N      ??HAL_FLASH_Program_IT_6
    275            {
    276              case FLASH_TYPEPROGRAM_BYTE :
    277              {
    278                /*Program byte (8-bit) at a specified address.*/
    279                FLASH_Program_Byte(Address, (uint8_t) Data);
   \                     ??HAL_FLASH_Program_IT_2: (+1)
   \   0000006C   0x0021             MOVS     R1,R4
   \   0000006E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000070   0x0038             MOVS     R0,R7
   \   00000072   0x.... 0x....      BL       FLASH_Program_Byte
    280                break;
   \   00000076   0xE010             B.N      ??HAL_FLASH_Program_IT_7
    281              }
    282              
    283              case FLASH_TYPEPROGRAM_HALFWORD :
    284              {
    285                /*Program halfword (16-bit) at a specified address.*/
    286                FLASH_Program_HalfWord(Address, (uint16_t) Data);
   \                     ??HAL_FLASH_Program_IT_4: (+1)
   \   00000078   0x0021             MOVS     R1,R4
   \   0000007A   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000007C   0x0038             MOVS     R0,R7
   \   0000007E   0x.... 0x....      BL       FLASH_Program_HalfWord
    287                break;
   \   00000082   0xE00A             B.N      ??HAL_FLASH_Program_IT_7
    288              }
    289              
    290              case FLASH_TYPEPROGRAM_WORD :
    291              {
    292                /*Program word (32-bit) at a specified address.*/
    293                FLASH_Program_Word(Address, (uint32_t) Data);
   \                     ??HAL_FLASH_Program_IT_3: (+1)
   \   00000084   0x0021             MOVS     R1,R4
   \   00000086   0x0038             MOVS     R0,R7
   \   00000088   0x.... 0x....      BL       FLASH_Program_Word
    294                break;
   \   0000008C   0xE005             B.N      ??HAL_FLASH_Program_IT_7
    295              }
    296              
    297              case FLASH_TYPEPROGRAM_DOUBLEWORD :
    298              {
    299                /*Program double word (64-bit) at a specified address.*/
    300                FLASH_Program_DoubleWord(Address, Data);
   \                     ??HAL_FLASH_Program_IT_5: (+1)
   \   0000008E   0x0022             MOVS     R2,R4
   \   00000090   0x002B             MOVS     R3,R5
   \   00000092   0x0038             MOVS     R0,R7
   \   00000094   0x.... 0x....      BL       FLASH_Program_DoubleWord
    301                break;
   \   00000098   0xE7FF             B.N      ??HAL_FLASH_Program_IT_7
    302              }
    303              default :
    304                break;
    305            }
    306            return status;
   \                     ??HAL_FLASH_Program_IT_6: (+1)
   \                     ??HAL_FLASH_Program_IT_7: (+1)
   \   0000009A   0x4640             MOV      R0,R8
   \   0000009C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??HAL_FLASH_Program_IT_1: (+1)
   \   0000009E   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    307          }
    308          
    309          /**
    310            * @brief This function handles FLASH interrupt request.
    311            * @retval None
    312            */

   \                                 In section .text, align 2, keep-with-next
    313          void HAL_FLASH_IRQHandler(void)
    314          {
   \                     HAL_FLASH_IRQHandler: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    315            uint32_t temp = 0;
   \   00000002   0x2400             MOVS     R4,#+0
    316            
    317            /* If the program operation is completed, disable the PG Bit */
    318            FLASH->CR &= (~FLASH_CR_PG);
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable14_1  ;; 0x40023c10
   \   00000008   0x6800             LDR      R0,[R0, #+0]
   \   0000000A   0x0840             LSRS     R0,R0,#+1
   \   0000000C   0x0040             LSLS     R0,R0,#+1
   \   0000000E   0x.... 0x....      LDR.W    R1,??DataTable14_1  ;; 0x40023c10
   \   00000012   0x6008             STR      R0,[R1, #+0]
    319          
    320            /* If the erase operation is completed, disable the SER Bit */
    321            FLASH->CR &= (~FLASH_CR_SER);
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable14_1  ;; 0x40023c10
   \   00000018   0x6800             LDR      R0,[R0, #+0]
   \   0000001A   0xF030 0x0002      BICS     R0,R0,#0x2
   \   0000001E   0x.... 0x....      LDR.W    R1,??DataTable14_1  ;; 0x40023c10
   \   00000022   0x6008             STR      R0,[R1, #+0]
    322            FLASH->CR &= SECTOR_MASK; 
   \   00000024   0x.... 0x....      LDR.W    R0,??DataTable14_1  ;; 0x40023c10
   \   00000028   0x6800             LDR      R0,[R0, #+0]
   \   0000002A   0xF030 0x00F8      BICS     R0,R0,#0xF8
   \   0000002E   0x.... 0x....      LDR.W    R1,??DataTable14_1  ;; 0x40023c10
   \   00000032   0x6008             STR      R0,[R1, #+0]
    323          
    324            /* if the erase operation is completed, disable the MER Bit */
    325            FLASH->CR &= (~FLASH_MER_BIT);
   \   00000034   0x.... 0x....      LDR.W    R0,??DataTable14_1  ;; 0x40023c10
   \   00000038   0x6800             LDR      R0,[R0, #+0]
   \   0000003A   0xF030 0x0004      BICS     R0,R0,#0x4
   \   0000003E   0x.... 0x....      LDR.W    R1,??DataTable14_1  ;; 0x40023c10
   \   00000042   0x6008             STR      R0,[R1, #+0]
    326          
    327            /* Check FLASH End of Operation flag  */
    328            if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_EOP) != RESET)
   \   00000044   0x.... 0x....      LDR.W    R0,??DataTable14_2  ;; 0x40023c0c
   \   00000048   0x6800             LDR      R0,[R0, #+0]
   \   0000004A   0x07C0             LSLS     R0,R0,#+31
   \   0000004C   0xD54B             BPL.N    ??HAL_FLASH_IRQHandler_0
    329            {
    330              switch (pFlash.ProcedureOnGoing)
   \   0000004E   0x.... 0x....      LDR.W    R0,??DataTable14
   \   00000052   0x7800             LDRB     R0,[R0, #+0]
   \   00000054   0x2801             CMP      R0,#+1
   \   00000056   0xD004             BEQ.N    ??HAL_FLASH_IRQHandler_1
   \   00000058   0xD345             BCC.N    ??HAL_FLASH_IRQHandler_2
   \   0000005A   0x2803             CMP      R0,#+3
   \   0000005C   0xD038             BEQ.N    ??HAL_FLASH_IRQHandler_3
   \   0000005E   0xD32D             BCC.N    ??HAL_FLASH_IRQHandler_4
   \   00000060   0xE041             B.N      ??HAL_FLASH_IRQHandler_2
    331              {
    332                case FLASH_PROC_SECTERASE :
    333                {
    334                  /* Nb of sector to erased can be decreased */
    335                  pFlash.NbSectorsToErase--;
   \                     ??HAL_FLASH_IRQHandler_1: (+1)
   \   00000062   0x....             LDR.N    R0,??DataTable14
   \   00000064   0x6840             LDR      R0,[R0, #+4]
   \   00000066   0x1E40             SUBS     R0,R0,#+1
   \   00000068   0x....             LDR.N    R1,??DataTable14
   \   0000006A   0x6048             STR      R0,[R1, #+4]
    336          
    337                  /* Check if there are still sectors to erase */
    338                  if(pFlash.NbSectorsToErase != 0)
   \   0000006C   0x....             LDR.N    R0,??DataTable14
   \   0000006E   0x6840             LDR      R0,[R0, #+4]
   \   00000070   0x2800             CMP      R0,#+0
   \   00000072   0xD014             BEQ.N    ??HAL_FLASH_IRQHandler_5
    339                  {
    340                    temp = pFlash.Sector;
   \   00000074   0x....             LDR.N    R0,??DataTable14
   \   00000076   0x68C0             LDR      R0,[R0, #+12]
   \   00000078   0x0004             MOVS     R4,R0
    341                    /* Indicate user which sector has been erased */
    342                    HAL_FLASH_EndOfOperationCallback(temp);
   \   0000007A   0x0020             MOVS     R0,R4
   \   0000007C   0x.... 0x....      BL       HAL_FLASH_EndOfOperationCallback
    343          
    344                    /* Clear pending flags (if any) */  
    345                    __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_EOP);  
   \   00000080   0x2001             MOVS     R0,#+1
   \   00000082   0x....             LDR.N    R1,??DataTable14_2  ;; 0x40023c0c
   \   00000084   0x6008             STR      R0,[R1, #+0]
    346          
    347                    /* Increment sector number */
    348                    temp = ++pFlash.Sector;
   \   00000086   0x....             LDR.N    R0,??DataTable14
   \   00000088   0x68C0             LDR      R0,[R0, #+12]
   \   0000008A   0x1C40             ADDS     R0,R0,#+1
   \   0000008C   0x....             LDR.N    R1,??DataTable14
   \   0000008E   0x60C8             STR      R0,[R1, #+12]
   \   00000090   0x0004             MOVS     R4,R0
    349                    FLASH_Erase_Sector(temp, pFlash.VoltageForErase);
   \   00000092   0x....             LDR.N    R0,??DataTable14
   \   00000094   0x7A01             LDRB     R1,[R0, #+8]
   \   00000096   0x0020             MOVS     R0,R4
   \   00000098   0x.... 0x....      BL       FLASH_Erase_Sector
   \   0000009C   0xE00D             B.N      ??HAL_FLASH_IRQHandler_6
    350                  }
    351                  else
    352                  {
    353                    /* No more sectors to Erase, user callback can be called.*/
    354                    /* Reset Sector and stop Erase sectors procedure */
    355                    pFlash.Sector = temp = 0xFFFFFFFF;
   \                     ??HAL_FLASH_IRQHandler_5: (+1)
   \   0000009E   0xF05F 0x30FF      MOVS     R0,#-1
   \   000000A2   0x0004             MOVS     R4,R0
   \   000000A4   0x....             LDR.N    R0,??DataTable14
   \   000000A6   0x60C4             STR      R4,[R0, #+12]
    356                    /* FLASH EOP interrupt user callback */
    357                    HAL_FLASH_EndOfOperationCallback(temp);
   \   000000A8   0x0020             MOVS     R0,R4
   \   000000AA   0x.... 0x....      BL       HAL_FLASH_EndOfOperationCallback
    358                    /* Sector Erase procedure is completed */
    359                    pFlash.ProcedureOnGoing = FLASH_PROC_NONE;
   \   000000AE   0x2000             MOVS     R0,#+0
   \   000000B0   0x....             LDR.N    R1,??DataTable14
   \   000000B2   0x7008             STRB     R0,[R1, #+0]
    360                    /* Clear FLASH End of Operation pending bit */
    361                    __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_EOP);
   \   000000B4   0x2001             MOVS     R0,#+1
   \   000000B6   0x....             LDR.N    R1,??DataTable14_2  ;; 0x40023c0c
   \   000000B8   0x6008             STR      R0,[R1, #+0]
    362                  }
    363                  break;
   \                     ??HAL_FLASH_IRQHandler_6: (+1)
   \   000000BA   0xE014             B.N      ??HAL_FLASH_IRQHandler_0
    364                }
    365              
    366                case FLASH_PROC_MASSERASE :
    367                {
    368                  /* MassErase ended. Return the selected bank : in this product we don't have Banks */
    369                  /* FLASH EOP interrupt user callback */
    370                  HAL_FLASH_EndOfOperationCallback(0);
   \                     ??HAL_FLASH_IRQHandler_4: (+1)
   \   000000BC   0x2000             MOVS     R0,#+0
   \   000000BE   0x.... 0x....      BL       HAL_FLASH_EndOfOperationCallback
    371                  /* MAss Erase procedure is completed */
    372                  pFlash.ProcedureOnGoing = FLASH_PROC_NONE;
   \   000000C2   0x2000             MOVS     R0,#+0
   \   000000C4   0x....             LDR.N    R1,??DataTable14
   \   000000C6   0x7008             STRB     R0,[R1, #+0]
    373                  /* Clear FLASH End of Operation pending bit */
    374                  __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_EOP);
   \   000000C8   0x2001             MOVS     R0,#+1
   \   000000CA   0x....             LDR.N    R1,??DataTable14_2  ;; 0x40023c0c
   \   000000CC   0x6008             STR      R0,[R1, #+0]
    375                  break;
   \   000000CE   0xE00A             B.N      ??HAL_FLASH_IRQHandler_0
    376                }
    377          
    378                case FLASH_PROC_PROGRAM :
    379                {
    380                  /*Program ended. Return the selected address*/
    381                  /* FLASH EOP interrupt user callback */
    382                  HAL_FLASH_EndOfOperationCallback(pFlash.Address);
   \                     ??HAL_FLASH_IRQHandler_3: (+1)
   \   000000D0   0x....             LDR.N    R0,??DataTable14
   \   000000D2   0x6900             LDR      R0,[R0, #+16]
   \   000000D4   0x.... 0x....      BL       HAL_FLASH_EndOfOperationCallback
    383                  /* Programming procedure is completed */
    384                  pFlash.ProcedureOnGoing = FLASH_PROC_NONE;
   \   000000D8   0x2000             MOVS     R0,#+0
   \   000000DA   0x....             LDR.N    R1,??DataTable14
   \   000000DC   0x7008             STRB     R0,[R1, #+0]
    385                  /* Clear FLASH End of Operation pending bit */
    386                  __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_EOP);
   \   000000DE   0x2001             MOVS     R0,#+1
   \   000000E0   0x....             LDR.N    R1,??DataTable14_2  ;; 0x40023c0c
   \   000000E2   0x6008             STR      R0,[R1, #+0]
    387                  break;
   \   000000E4   0xE7FF             B.N      ??HAL_FLASH_IRQHandler_0
    388                }
    389                default :
    390                  break;
    391              }
    392            }
    393            
    394            /* Check FLASH operation error flags */
    395            if(__HAL_FLASH_GET_FLAG((FLASH_FLAG_OPERR  | FLASH_FLAG_WRPERR | FLASH_FLAG_PGAERR | FLASH_FLAG_PGPERR | FLASH_FLAG_ERSERR )) != RESET)
   \                     ??HAL_FLASH_IRQHandler_2: (+1)
   \                     ??HAL_FLASH_IRQHandler_0: (+1)
   \   000000E6   0x....             LDR.N    R0,??DataTable14_2  ;; 0x40023c0c
   \   000000E8   0x6800             LDR      R0,[R0, #+0]
   \   000000EA   0xF010 0x0FF2      TST      R0,#0xF2
   \   000000EE   0xD022             BEQ.N    ??HAL_FLASH_IRQHandler_7
    396            {
    397              switch (pFlash.ProcedureOnGoing)
   \   000000F0   0x....             LDR.N    R0,??DataTable14
   \   000000F2   0x7800             LDRB     R0,[R0, #+0]
   \   000000F4   0x2801             CMP      R0,#+1
   \   000000F6   0xD004             BEQ.N    ??HAL_FLASH_IRQHandler_8
   \   000000F8   0xD312             BCC.N    ??HAL_FLASH_IRQHandler_9
   \   000000FA   0x2803             CMP      R0,#+3
   \   000000FC   0xD00C             BEQ.N    ??HAL_FLASH_IRQHandler_10
   \   000000FE   0xD308             BCC.N    ??HAL_FLASH_IRQHandler_11
   \   00000100   0xE00E             B.N      ??HAL_FLASH_IRQHandler_9
    398              {
    399                case FLASH_PROC_SECTERASE :
    400                {
    401                  /* return the faulty sector */
    402                  temp = pFlash.Sector;
   \                     ??HAL_FLASH_IRQHandler_8: (+1)
   \   00000102   0x....             LDR.N    R0,??DataTable14
   \   00000104   0x68C0             LDR      R0,[R0, #+12]
   \   00000106   0x0004             MOVS     R4,R0
    403                  pFlash.Sector = 0xFFFFFFFF;
   \   00000108   0xF05F 0x30FF      MOVS     R0,#-1
   \   0000010C   0x....             LDR.N    R1,??DataTable14
   \   0000010E   0x60C8             STR      R0,[R1, #+12]
    404                  break;
   \   00000110   0xE006             B.N      ??HAL_FLASH_IRQHandler_12
    405                }
    406                case FLASH_PROC_MASSERASE :
    407                {
    408                  /* No return in case of Mass Erase */
    409                  temp = 0;
   \                     ??HAL_FLASH_IRQHandler_11: (+1)
   \   00000112   0x2000             MOVS     R0,#+0
   \   00000114   0x0004             MOVS     R4,R0
    410                  break;
   \   00000116   0xE003             B.N      ??HAL_FLASH_IRQHandler_12
    411                }
    412                case FLASH_PROC_PROGRAM :
    413                {
    414                  /*return the faulty address*/
    415                  temp = pFlash.Address;
   \                     ??HAL_FLASH_IRQHandler_10: (+1)
   \   00000118   0x....             LDR.N    R0,??DataTable14
   \   0000011A   0x6900             LDR      R0,[R0, #+16]
   \   0000011C   0x0004             MOVS     R4,R0
    416                  break;
   \   0000011E   0xE7FF             B.N      ??HAL_FLASH_IRQHandler_12
    417                }
    418          			default :
    419          				break;
    420              }
    421              /*Save the Error code*/
    422              FLASH_SetErrorCode();
   \                     ??HAL_FLASH_IRQHandler_9: (+1)
   \                     ??HAL_FLASH_IRQHandler_12: (+1)
   \   00000120   0x.... 0x....      BL       FLASH_SetErrorCode
    423          
    424              /* FLASH error interrupt user callback */
    425              HAL_FLASH_OperationErrorCallback(temp);
   \   00000124   0x0020             MOVS     R0,R4
   \   00000126   0x.... 0x....      BL       HAL_FLASH_OperationErrorCallback
    426              /* Clear FLASH error pending bits */
    427              __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_OPERR  | FLASH_FLAG_WRPERR | FLASH_FLAG_PGAERR | FLASH_FLAG_PGPERR | FLASH_FLAG_ERSERR );
   \   0000012A   0x20F2             MOVS     R0,#+242
   \   0000012C   0x....             LDR.N    R1,??DataTable14_2  ;; 0x40023c0c
   \   0000012E   0x6008             STR      R0,[R1, #+0]
    428          
    429              /*Stop the procedure ongoing */
    430              pFlash.ProcedureOnGoing = FLASH_PROC_NONE;
   \   00000130   0x2000             MOVS     R0,#+0
   \   00000132   0x....             LDR.N    R1,??DataTable14
   \   00000134   0x7008             STRB     R0,[R1, #+0]
    431            }
    432            
    433            if(pFlash.ProcedureOnGoing == FLASH_PROC_NONE)
   \                     ??HAL_FLASH_IRQHandler_7: (+1)
   \   00000136   0x....             LDR.N    R0,??DataTable14
   \   00000138   0x7800             LDRB     R0,[R0, #+0]
   \   0000013A   0x2800             CMP      R0,#+0
   \   0000013C   0xD10E             BNE.N    ??HAL_FLASH_IRQHandler_13
    434            {
    435              /* Disable End of FLASH Operation interrupt */
    436              __HAL_FLASH_DISABLE_IT(FLASH_IT_EOP);
   \   0000013E   0x....             LDR.N    R0,??DataTable14_1  ;; 0x40023c10
   \   00000140   0x6800             LDR      R0,[R0, #+0]
   \   00000142   0xF030 0x7080      BICS     R0,R0,#0x1000000
   \   00000146   0x....             LDR.N    R1,??DataTable14_1  ;; 0x40023c10
   \   00000148   0x6008             STR      R0,[R1, #+0]
    437          
    438              /* Disable Error source interrupt */
    439              __HAL_FLASH_DISABLE_IT(FLASH_IT_ERR);
   \   0000014A   0x....             LDR.N    R0,??DataTable14_1  ;; 0x40023c10
   \   0000014C   0x6800             LDR      R0,[R0, #+0]
   \   0000014E   0xF030 0x7000      BICS     R0,R0,#0x2000000
   \   00000152   0x....             LDR.N    R1,??DataTable14_1  ;; 0x40023c10
   \   00000154   0x6008             STR      R0,[R1, #+0]
    440          
    441              /* Process Unlocked */
    442              __HAL_UNLOCK(&pFlash);
   \   00000156   0x2000             MOVS     R0,#+0
   \   00000158   0x....             LDR.N    R1,??DataTable14
   \   0000015A   0x7508             STRB     R0,[R1, #+20]
    443            }
    444            
    445          }
   \                     ??HAL_FLASH_IRQHandler_13: (+1)
   \   0000015C   0xBD10             POP      {R4,PC}          ;; return
    446          
    447          /**
    448            * @brief  FLASH end of operation interrupt callback
    449            * @param  ReturnValue: The value saved in this parameter depends on the ongoing procedure
    450            *                 - Sectors Erase: Sector which has been erased (if 0xFFFFFFFF, it means that 
    451            *                                  all the selected sectors have been erased)
    452            *                 - Program      : Address which was selected for data program
    453            *                 - Mass Erase   : No return value expected
    454            * @retval None
    455            */

   \                                 In section .text, align 2, keep-with-next
    456          __weak void HAL_FLASH_EndOfOperationCallback(uint32_t ReturnValue)
    457          {
    458            /* NOTE : This function Should not be modified, when the callback is needed,
    459                      the HAL_FLASH_EndOfOperationCallback could be implemented in the user file
    460             */ 
    461          }
   \                     HAL_FLASH_EndOfOperationCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    462          
    463          /**
    464            * @brief  FLASH operation error interrupt callback
    465            * @param  ReturnValue: The value saved in this parameter depends on the ongoing procedure
    466            *                 - Sectors Erase: Sector which has been erased (if 0xFFFFFFFF, it means that 
    467            *                                  all the selected sectors have been erased)
    468            *                 - Program      : Address which was selected for data program
    469            *                 - Mass Erase   : No return value expected
    470            * @retval None
    471            */

   \                                 In section .text, align 2, keep-with-next
    472          __weak void HAL_FLASH_OperationErrorCallback(uint32_t ReturnValue)
    473          {
    474            /* NOTE : This function Should not be modified, when the callback is needed,
    475                      the HAL_FLASH_OperationErrorCallback could be implemented in the user file
    476             */ 
    477          }
   \                     HAL_FLASH_OperationErrorCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    478          
    479          /**
    480            * @}
    481            */
    482          
    483          /** @defgroup FLASH_Exported_Functions_Group2 Peripheral Control functions 
    484           *  @brief   management functions 
    485           *
    486          @verbatim   
    487           ===============================================================================
    488                                ##### Peripheral Control functions #####
    489           ===============================================================================  
    490              [..]
    491              This subsection provides a set of functions allowing to control the FLASH 
    492              memory operations.
    493          
    494          @endverbatim
    495            * @{
    496            */
    497          
    498          /**
    499            * @brief  Unlock the FLASH control register access
    500            * @retval HAL Status
    501            */

   \                                 In section .text, align 2, keep-with-next
    502          HAL_StatusTypeDef HAL_FLASH_Unlock(void)
    503          {
    504            if((FLASH->CR & FLASH_CR_LOCK) != RESET)
   \                     HAL_FLASH_Unlock: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable14_1  ;; 0x40023c10
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x2800             CMP      R0,#+0
   \   00000006   0xD507             BPL.N    ??HAL_FLASH_Unlock_0
    505            {
    506              /* Authorize the FLASH Registers access */
    507              FLASH->KEYR = FLASH_KEY1;
   \   00000008   0x....             LDR.N    R0,??DataTable14_3  ;; 0x45670123
   \   0000000A   0x....             LDR.N    R1,??DataTable14_4  ;; 0x40023c04
   \   0000000C   0x6008             STR      R0,[R1, #+0]
    508              FLASH->KEYR = FLASH_KEY2;
   \   0000000E   0x....             LDR.N    R0,??DataTable14_5  ;; 0xcdef89ab
   \   00000010   0x....             LDR.N    R1,??DataTable14_4  ;; 0x40023c04
   \   00000012   0x6008             STR      R0,[R1, #+0]
    509            }
    510            else
    511            {
    512              return HAL_ERROR;
    513            }
    514            
    515            return HAL_OK; 
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0xE000             B.N      ??HAL_FLASH_Unlock_1
   \                     ??HAL_FLASH_Unlock_0: (+1)
   \   00000018   0x2001             MOVS     R0,#+1
   \                     ??HAL_FLASH_Unlock_1: (+1)
   \   0000001A   0x4770             BX       LR               ;; return
    516          }
    517          
    518          /**
    519            * @brief  Locks the FLASH control register access
    520            * @retval HAL Status
    521            */

   \                                 In section .text, align 2, keep-with-next
    522          HAL_StatusTypeDef HAL_FLASH_Lock(void)
    523          {
    524            /* Set the LOCK Bit to lock the FLASH Registers access */
    525            FLASH->CR |= FLASH_CR_LOCK;
   \                     HAL_FLASH_Lock: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable14_1  ;; 0x40023c10
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0xF050 0x4000      ORRS     R0,R0,#0x80000000
   \   00000008   0x....             LDR.N    R1,??DataTable14_1  ;; 0x40023c10
   \   0000000A   0x6008             STR      R0,[R1, #+0]
    526            
    527            return HAL_OK;  
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x4770             BX       LR               ;; return
    528          }
    529          
    530          /**
    531            * @brief  Unlock the FLASH Option Control Registers access.
    532            * @retval HAL Status
    533            */

   \                                 In section .text, align 2, keep-with-next
    534          HAL_StatusTypeDef HAL_FLASH_OB_Unlock(void)
    535          {
    536            if((FLASH->OPTCR & FLASH_OPTCR_OPTLOCK) != RESET)
   \                     HAL_FLASH_OB_Unlock: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable14_6  ;; 0x40023c14
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x07C0             LSLS     R0,R0,#+31
   \   00000006   0xD507             BPL.N    ??HAL_FLASH_OB_Unlock_0
    537            {
    538              /* Authorizes the Option Byte register programming */
    539              FLASH->OPTKEYR = FLASH_OPT_KEY1;
   \   00000008   0x....             LDR.N    R0,??DataTable14_7  ;; 0x8192a3b
   \   0000000A   0x....             LDR.N    R1,??DataTable14_8  ;; 0x40023c08
   \   0000000C   0x6008             STR      R0,[R1, #+0]
    540              FLASH->OPTKEYR = FLASH_OPT_KEY2;
   \   0000000E   0x....             LDR.N    R0,??DataTable14_9  ;; 0x4c5d6e7f
   \   00000010   0x....             LDR.N    R1,??DataTable14_8  ;; 0x40023c08
   \   00000012   0x6008             STR      R0,[R1, #+0]
    541            }
    542            else
    543            {
    544              return HAL_ERROR;
    545            }  
    546            
    547            return HAL_OK;  
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0xE000             B.N      ??HAL_FLASH_OB_Unlock_1
   \                     ??HAL_FLASH_OB_Unlock_0: (+1)
   \   00000018   0x2001             MOVS     R0,#+1
   \                     ??HAL_FLASH_OB_Unlock_1: (+1)
   \   0000001A   0x4770             BX       LR               ;; return
    548          }
    549          
    550          /**
    551            * @brief  Lock the FLASH Option Control Registers access.
    552            * @retval HAL Status 
    553            */

   \                                 In section .text, align 2, keep-with-next
    554          HAL_StatusTypeDef HAL_FLASH_OB_Lock(void)
    555          {
    556            /* Set the OPTLOCK Bit to lock the FLASH Option Byte Registers access */
    557            FLASH->OPTCR |= FLASH_OPTCR_OPTLOCK;
   \                     HAL_FLASH_OB_Lock: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable14_6  ;; 0x40023c14
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000008   0x....             LDR.N    R1,??DataTable14_6  ;; 0x40023c14
   \   0000000A   0x6008             STR      R0,[R1, #+0]
    558            
    559            return HAL_OK;  
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x4770             BX       LR               ;; return
    560          }
    561          
    562          /**
    563            * @brief  Launch the option byte loading.
    564            * @retval HAL Status
    565            */

   \                                 In section .text, align 2, keep-with-next
    566          HAL_StatusTypeDef HAL_FLASH_OB_Launch(void)
    567          {
   \                     HAL_FLASH_OB_Launch: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    568            /* Set the OPTSTRT bit in OPTCR register */
    569            FLASH->OPTCR |= FLASH_OPTCR_OPTSTRT;
   \   00000002   0x....             LDR.N    R0,??DataTable14_6  ;; 0x40023c14
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   0000000A   0x....             LDR.N    R1,??DataTable14_6  ;; 0x40023c14
   \   0000000C   0x6008             STR      R0,[R1, #+0]
    570          
    571            /* Wait for last operation to be completed */
    572            return(FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE)); 
   \   0000000E   0xF24C 0x3050      MOVW     R0,#+50000
   \   00000012   0x.... 0x....      BL       FLASH_WaitForLastOperation
   \   00000016   0xBD02             POP      {R1,PC}          ;; return
    573          }
    574          
    575          /**
    576            * @}
    577            */
    578          
    579          /** @defgroup FLASH_Exported_Functions_Group3 Peripheral State and Errors functions 
    580           *  @brief   Peripheral Errors functions 
    581           *
    582          @verbatim   
    583           ===============================================================================
    584                          ##### Peripheral Errors functions #####
    585           ===============================================================================  
    586              [..]
    587              This subsection permits to get in run-time Errors of the FLASH peripheral.
    588          
    589          @endverbatim
    590            * @{
    591            */
    592          
    593          /**
    594            * @brief  Get the specific FLASH error flag.
    595            * @retval FLASH_ErrorCode: The returned value can be:
    596            *            @arg FLASH_ERROR_ERS: FLASH Erasing Sequence error flag 
    597            *            @arg FLASH_ERROR_PGP: FLASH Programming Parallelism error flag  
    598            *            @arg FLASH_ERROR_PGA: FLASH Programming Alignment error flag
    599            *            @arg FLASH_ERROR_WRP: FLASH Write protected error flag
    600            *            @arg FLASH_ERROR_OPERATION: FLASH operation Error flag 
    601            */

   \                                 In section .text, align 2, keep-with-next
    602          uint32_t HAL_FLASH_GetError(void)
    603          { 
    604             return pFlash.ErrorCode;
   \                     HAL_FLASH_GetError: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable14
   \   00000002   0x6980             LDR      R0,[R0, #+24]
   \   00000004   0x4770             BX       LR               ;; return
    605          }  
    606            
    607          /**
    608            * @}
    609            */    
    610          
    611          /**
    612            * @brief  Wait for a FLASH operation to complete.
    613            * @param  Timeout: maximum flash operationtimeout
    614            * @retval HAL Status
    615            */

   \                                 In section .text, align 2, keep-with-next
    616          HAL_StatusTypeDef FLASH_WaitForLastOperation(uint32_t Timeout)
    617          { 
   \                     FLASH_WaitForLastOperation: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    618            uint32_t tickstart = 0;
   \   00000004   0x2500             MOVS     R5,#+0
    619            
    620            /* Clear Error Code */
    621            pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x....             LDR.N    R1,??DataTable14
   \   0000000A   0x6188             STR      R0,[R1, #+24]
    622            
    623            /* Wait for the FLASH operation to complete by polling on BUSY flag to be reset.
    624               Even if the FLASH operation fails, the BUSY flag will be reset and an error
    625               flag will be set */
    626            /* Get tick */
    627            tickstart = HAL_GetTick();
   \   0000000C   0x.... 0x....      BL       HAL_GetTick
   \   00000010   0x0005             MOVS     R5,R0
    628          
    629            while(__HAL_FLASH_GET_FLAG(FLASH_FLAG_BSY) != RESET) 
   \                     ??FLASH_WaitForLastOperation_0: (+1)
   \   00000012   0x....             LDR.N    R0,??DataTable14_2  ;; 0x40023c0c
   \   00000014   0x6800             LDR      R0,[R0, #+0]
   \   00000016   0x03C0             LSLS     R0,R0,#+15
   \   00000018   0xD50B             BPL.N    ??FLASH_WaitForLastOperation_1
    630            { 
    631              if(Timeout != HAL_MAX_DELAY)
   \   0000001A   0xF114 0x0F01      CMN      R4,#+1
   \   0000001E   0xD0F8             BEQ.N    ??FLASH_WaitForLastOperation_0
    632              {
    633                if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
   \   00000020   0x2C00             CMP      R4,#+0
   \   00000022   0xD004             BEQ.N    ??FLASH_WaitForLastOperation_2
   \   00000024   0x.... 0x....      BL       HAL_GetTick
   \   00000028   0x1B40             SUBS     R0,R0,R5
   \   0000002A   0x4284             CMP      R4,R0
   \   0000002C   0xD2F1             BCS.N    ??FLASH_WaitForLastOperation_0
    634                {
    635                  return HAL_TIMEOUT;
   \                     ??FLASH_WaitForLastOperation_2: (+1)
   \   0000002E   0x2003             MOVS     R0,#+3
   \   00000030   0xE009             B.N      ??FLASH_WaitForLastOperation_3
    636                }
    637              } 
    638            }
    639            
    640            if(__HAL_FLASH_GET_FLAG((FLASH_FLAG_OPERR | FLASH_FLAG_WRPERR | FLASH_FLAG_PGAERR | \
    641                                     FLASH_FLAG_PGPERR | FLASH_FLAG_ERSERR )) != RESET)
   \                     ??FLASH_WaitForLastOperation_1: (+1)
   \   00000032   0x....             LDR.N    R0,??DataTable14_2  ;; 0x40023c0c
   \   00000034   0x6800             LDR      R0,[R0, #+0]
   \   00000036   0xF010 0x0FF2      TST      R0,#0xF2
   \   0000003A   0xD003             BEQ.N    ??FLASH_WaitForLastOperation_4
    642            {
    643              /*Save the error code*/
    644              FLASH_SetErrorCode();
   \   0000003C   0x.... 0x....      BL       FLASH_SetErrorCode
    645              return HAL_ERROR;
   \   00000040   0x2001             MOVS     R0,#+1
   \   00000042   0xE000             B.N      ??FLASH_WaitForLastOperation_3
    646            }
    647          
    648            /* If there is an error flag set */
    649            return HAL_OK;
   \                     ??FLASH_WaitForLastOperation_4: (+1)
   \   00000044   0x2000             MOVS     R0,#+0
   \                     ??FLASH_WaitForLastOperation_3: (+1)
   \   00000046   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    650            
    651          }  
    652          
    653          /**
    654            * @brief  Program a double word (64-bit) at a specified address.
    655            * @note   This function must be used when the device voltage range is from
    656            *         2.7V to 3.6V and an External Vpp is present.
    657            *
    658            * @note   If an erase and a program operations are requested simultaneously,    
    659            *         the erase operation is performed before the program one.
    660            *  
    661            * @param  Address: specifies the address to be programmed.
    662            * @param  Data: specifies the data to be programmed.
    663            * @retval None
    664            */

   \                                 In section .text, align 2, keep-with-next
    665          static void FLASH_Program_DoubleWord(uint32_t Address, uint64_t Data)
    666          {
   \                     FLASH_Program_DoubleWord: (+1)
   \   00000000   0xB410             PUSH     {R4}
    667            /* Check the parameters */
    668            assert_param(IS_FLASH_ADDRESS(Address));
    669            
    670            /* If the previous operation is completed, proceed to program the new data */
    671            FLASH->CR &= CR_PSIZE_MASK;
   \   00000002   0x....             LDR.N    R1,??DataTable14_1  ;; 0x40023c10
   \   00000004   0x6809             LDR      R1,[R1, #+0]
   \   00000006   0xF431 0x7140      BICS     R1,R1,#0x300
   \   0000000A   0x....             LDR.N    R4,??DataTable14_1  ;; 0x40023c10
   \   0000000C   0x6021             STR      R1,[R4, #+0]
    672            FLASH->CR |= FLASH_PSIZE_DOUBLE_WORD;
   \   0000000E   0x....             LDR.N    R1,??DataTable14_1  ;; 0x40023c10
   \   00000010   0x6809             LDR      R1,[R1, #+0]
   \   00000012   0xF451 0x7140      ORRS     R1,R1,#0x300
   \   00000016   0x....             LDR.N    R4,??DataTable14_1  ;; 0x40023c10
   \   00000018   0x6021             STR      R1,[R4, #+0]
    673            FLASH->CR |= FLASH_CR_PG;
   \   0000001A   0x....             LDR.N    R1,??DataTable14_1  ;; 0x40023c10
   \   0000001C   0x6809             LDR      R1,[R1, #+0]
   \   0000001E   0xF051 0x0101      ORRS     R1,R1,#0x1
   \   00000022   0x....             LDR.N    R4,??DataTable14_1  ;; 0x40023c10
   \   00000024   0x6021             STR      R1,[R4, #+0]
    674            
    675            *(__IO uint64_t*)Address = Data;
   \   00000026   0xE9C0 0x2300      STRD     R2,R3,[R0, #+0]
    676            
    677            /* Data synchronous Barrier (DSB) Just after the write operation
    678               This will force the CPU to respect the sequence of instruction (no optimization).*/
    679            __DSB();
   \   0000002A   0xF3BF 0x8F4F      DSB      
    680          }
   \   0000002E   0xBC10             POP      {R4}
   \   00000030   0x4770             BX       LR               ;; return
    681          
    682          
    683          /**
    684            * @brief  Program word (32-bit) at a specified address.
    685            * @note   This function must be used when the device voltage range is from
    686            *         2.7V to 3.6V.
    687            *
    688            * @note   If an erase and a program operations are requested simultaneously,    
    689            *         the erase operation is performed before the program one.
    690            *  
    691            * @param  Address: specifies the address to be programmed.
    692            * @param  Data: specifies the data to be programmed.
    693            * @retval None
    694            */

   \                                 In section .text, align 2, keep-with-next
    695          static void FLASH_Program_Word(uint32_t Address, uint32_t Data)
    696          {
    697            /* Check the parameters */
    698            assert_param(IS_FLASH_ADDRESS(Address));
    699            
    700            /* If the previous operation is completed, proceed to program the new data */
    701            FLASH->CR &= CR_PSIZE_MASK;
   \                     FLASH_Program_Word: (+1)
   \   00000000   0x....             LDR.N    R2,??DataTable14_1  ;; 0x40023c10
   \   00000002   0x6812             LDR      R2,[R2, #+0]
   \   00000004   0xF432 0x7240      BICS     R2,R2,#0x300
   \   00000008   0x....             LDR.N    R3,??DataTable14_1  ;; 0x40023c10
   \   0000000A   0x601A             STR      R2,[R3, #+0]
    702            FLASH->CR |= FLASH_PSIZE_WORD;
   \   0000000C   0x....             LDR.N    R2,??DataTable14_1  ;; 0x40023c10
   \   0000000E   0x6812             LDR      R2,[R2, #+0]
   \   00000010   0xF452 0x7200      ORRS     R2,R2,#0x200
   \   00000014   0x....             LDR.N    R3,??DataTable14_1  ;; 0x40023c10
   \   00000016   0x601A             STR      R2,[R3, #+0]
    703            FLASH->CR |= FLASH_CR_PG;
   \   00000018   0x....             LDR.N    R2,??DataTable14_1  ;; 0x40023c10
   \   0000001A   0x6812             LDR      R2,[R2, #+0]
   \   0000001C   0xF052 0x0201      ORRS     R2,R2,#0x1
   \   00000020   0x....             LDR.N    R3,??DataTable14_1  ;; 0x40023c10
   \   00000022   0x601A             STR      R2,[R3, #+0]
    704          
    705            *(__IO uint32_t*)Address = Data;
   \   00000024   0x6001             STR      R1,[R0, #+0]
    706            
    707            /* Data synchronous Barrier (DSB) Just after the write operation
    708               This will force the CPU to respect the sequence of instruction (no optimization).*/
    709            __DSB();
   \   00000026   0xF3BF 0x8F4F      DSB      
    710          }
   \   0000002A   0x4770             BX       LR               ;; return
    711          
    712          /**
    713            * @brief  Program a half-word (16-bit) at a specified address.
    714            * @note   This function must be used when the device voltage range is from
    715            *         2.7V to 3.6V.
    716            *
    717            * @note   If an erase and a program operations are requested simultaneously,    
    718            *         the erase operation is performed before the program one.
    719            *  
    720            * @param  Address: specifies the address to be programmed.
    721            * @param  Data: specifies the data to be programmed.
    722            * @retval None
    723            */

   \                                 In section .text, align 2, keep-with-next
    724          static void FLASH_Program_HalfWord(uint32_t Address, uint16_t Data)
    725          {
    726            /* Check the parameters */
    727            assert_param(IS_FLASH_ADDRESS(Address));
    728            
    729            /* If the previous operation is completed, proceed to program the new data */
    730            FLASH->CR &= CR_PSIZE_MASK;
   \                     FLASH_Program_HalfWord: (+1)
   \   00000000   0x....             LDR.N    R2,??DataTable14_1  ;; 0x40023c10
   \   00000002   0x6812             LDR      R2,[R2, #+0]
   \   00000004   0xF432 0x7240      BICS     R2,R2,#0x300
   \   00000008   0x....             LDR.N    R3,??DataTable14_1  ;; 0x40023c10
   \   0000000A   0x601A             STR      R2,[R3, #+0]
    731            FLASH->CR |= FLASH_PSIZE_HALF_WORD;
   \   0000000C   0x....             LDR.N    R2,??DataTable14_1  ;; 0x40023c10
   \   0000000E   0x6812             LDR      R2,[R2, #+0]
   \   00000010   0xF452 0x7280      ORRS     R2,R2,#0x100
   \   00000014   0x....             LDR.N    R3,??DataTable14_1  ;; 0x40023c10
   \   00000016   0x601A             STR      R2,[R3, #+0]
    732            FLASH->CR |= FLASH_CR_PG;
   \   00000018   0x....             LDR.N    R2,??DataTable14_1  ;; 0x40023c10
   \   0000001A   0x6812             LDR      R2,[R2, #+0]
   \   0000001C   0xF052 0x0201      ORRS     R2,R2,#0x1
   \   00000020   0x....             LDR.N    R3,??DataTable14_1  ;; 0x40023c10
   \   00000022   0x601A             STR      R2,[R3, #+0]
    733          
    734            *(__IO uint16_t*)Address = Data;
   \   00000024   0x8001             STRH     R1,[R0, #+0]
    735          
    736            /* Data synchronous Barrier (DSB) Just after the write operation
    737               This will force the CPU to respect the sequence of instruction (no optimization).*/
    738            __DSB();
   \   00000026   0xF3BF 0x8F4F      DSB      
    739            
    740          }
   \   0000002A   0x4770             BX       LR               ;; return
    741          
    742          /**
    743            * @brief  Program byte (8-bit) at a specified address.
    744            * @note   This function must be used when the device voltage range is from
    745            *         2.7V to 3.6V.
    746            *
    747            * @note   If an erase and a program operations are requested simultaneously,    
    748            *         the erase operation is performed before the program one.
    749            *  
    750            * @param  Address: specifies the address to be programmed.
    751            * @param  Data: specifies the data to be programmed.
    752            * @retval None
    753            */

   \                                 In section .text, align 2, keep-with-next
    754          static void FLASH_Program_Byte(uint32_t Address, uint8_t Data)
    755          {
    756            /* Check the parameters */
    757            assert_param(IS_FLASH_ADDRESS(Address));
    758            
    759            /* If the previous operation is completed, proceed to program the new data */
    760            FLASH->CR &= CR_PSIZE_MASK;
   \                     FLASH_Program_Byte: (+1)
   \   00000000   0x....             LDR.N    R2,??DataTable14_1  ;; 0x40023c10
   \   00000002   0x6812             LDR      R2,[R2, #+0]
   \   00000004   0xF432 0x7240      BICS     R2,R2,#0x300
   \   00000008   0x....             LDR.N    R3,??DataTable14_1  ;; 0x40023c10
   \   0000000A   0x601A             STR      R2,[R3, #+0]
    761            FLASH->CR |= FLASH_PSIZE_BYTE;
   \   0000000C   0x....             LDR.N    R2,??DataTable14_1  ;; 0x40023c10
   \   0000000E   0x6812             LDR      R2,[R2, #+0]
   \   00000010   0x....             LDR.N    R3,??DataTable14_1  ;; 0x40023c10
   \   00000012   0x601A             STR      R2,[R3, #+0]
    762            FLASH->CR |= FLASH_CR_PG;
   \   00000014   0x....             LDR.N    R2,??DataTable14_1  ;; 0x40023c10
   \   00000016   0x6812             LDR      R2,[R2, #+0]
   \   00000018   0xF052 0x0201      ORRS     R2,R2,#0x1
   \   0000001C   0x....             LDR.N    R3,??DataTable14_1  ;; 0x40023c10
   \   0000001E   0x601A             STR      R2,[R3, #+0]
    763          
    764            *(__IO uint8_t*)Address = Data;
   \   00000020   0x7001             STRB     R1,[R0, #+0]
    765          
    766            /* Data synchronous Barrier (DSB) Just after the write operation
    767               This will force the CPU to respect the sequence of instruction (no optimization).*/
    768            __DSB();
   \   00000022   0xF3BF 0x8F4F      DSB      
    769          }
   \   00000026   0x4770             BX       LR               ;; return
    770          
    771          /**
    772            * @brief  Set the specific FLASH error flag.
    773            * @retval None
    774            */

   \                                 In section .text, align 2, keep-with-next
    775          static void FLASH_SetErrorCode(void)
    776          { 
    777            if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_WRPERR) != RESET)
   \                     FLASH_SetErrorCode: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable14_2  ;; 0x40023c0c
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x06C0             LSLS     R0,R0,#+27
   \   00000006   0xD505             BPL.N    ??FLASH_SetErrorCode_0
    778            {
    779             pFlash.ErrorCode |= HAL_FLASH_ERROR_WRP;
   \   00000008   0x....             LDR.N    R0,??DataTable14
   \   0000000A   0x6980             LDR      R0,[R0, #+24]
   \   0000000C   0xF050 0x0010      ORRS     R0,R0,#0x10
   \   00000010   0x....             LDR.N    R1,??DataTable14
   \   00000012   0x6188             STR      R0,[R1, #+24]
    780            }
    781            
    782            if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_PGAERR) != RESET)
   \                     ??FLASH_SetErrorCode_0: (+1)
   \   00000014   0x....             LDR.N    R0,??DataTable14_2  ;; 0x40023c0c
   \   00000016   0x6800             LDR      R0,[R0, #+0]
   \   00000018   0x0680             LSLS     R0,R0,#+26
   \   0000001A   0xD505             BPL.N    ??FLASH_SetErrorCode_1
    783            {
    784             pFlash.ErrorCode |= HAL_FLASH_ERROR_PGA;
   \   0000001C   0x....             LDR.N    R0,??DataTable14
   \   0000001E   0x6980             LDR      R0,[R0, #+24]
   \   00000020   0xF050 0x0008      ORRS     R0,R0,#0x8
   \   00000024   0x....             LDR.N    R1,??DataTable14
   \   00000026   0x6188             STR      R0,[R1, #+24]
    785            }
    786            
    787            if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_PGPERR) != RESET)
   \                     ??FLASH_SetErrorCode_1: (+1)
   \   00000028   0x....             LDR.N    R0,??DataTable14_2  ;; 0x40023c0c
   \   0000002A   0x6800             LDR      R0,[R0, #+0]
   \   0000002C   0x0640             LSLS     R0,R0,#+25
   \   0000002E   0xD505             BPL.N    ??FLASH_SetErrorCode_2
    788            {
    789              pFlash.ErrorCode |= HAL_FLASH_ERROR_PGP;
   \   00000030   0x....             LDR.N    R0,??DataTable14
   \   00000032   0x6980             LDR      R0,[R0, #+24]
   \   00000034   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   00000038   0x....             LDR.N    R1,??DataTable14
   \   0000003A   0x6188             STR      R0,[R1, #+24]
    790            }
    791            
    792            if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_ERSERR) != RESET)
   \                     ??FLASH_SetErrorCode_2: (+1)
   \   0000003C   0x....             LDR.N    R0,??DataTable14_2  ;; 0x40023c0c
   \   0000003E   0x6800             LDR      R0,[R0, #+0]
   \   00000040   0x0600             LSLS     R0,R0,#+24
   \   00000042   0xD505             BPL.N    ??FLASH_SetErrorCode_3
    793            {
    794              pFlash.ErrorCode |= HAL_FLASH_ERROR_ERS;
   \   00000044   0x....             LDR.N    R0,??DataTable14
   \   00000046   0x6980             LDR      R0,[R0, #+24]
   \   00000048   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   0000004C   0x....             LDR.N    R1,??DataTable14
   \   0000004E   0x6188             STR      R0,[R1, #+24]
    795            }
    796            
    797            if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_OPERR) != RESET)
   \                     ??FLASH_SetErrorCode_3: (+1)
   \   00000050   0x....             LDR.N    R0,??DataTable14_2  ;; 0x40023c0c
   \   00000052   0x6800             LDR      R0,[R0, #+0]
   \   00000054   0x0780             LSLS     R0,R0,#+30
   \   00000056   0xD505             BPL.N    ??FLASH_SetErrorCode_4
    798            {
    799              pFlash.ErrorCode |= HAL_FLASH_ERROR_OPERATION;
   \   00000058   0x....             LDR.N    R0,??DataTable14
   \   0000005A   0x6980             LDR      R0,[R0, #+24]
   \   0000005C   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   00000060   0x....             LDR.N    R1,??DataTable14
   \   00000062   0x6188             STR      R0,[R1, #+24]
    800            }
    801          }
   \                     ??FLASH_SetErrorCode_4: (+1)
   \   00000064   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14:
   \   00000000   0x........         DC32     pFlash

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_1:
   \   00000000   0x40023C10         DC32     0x40023c10

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_2:
   \   00000000   0x40023C0C         DC32     0x40023c0c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_3:
   \   00000000   0x45670123         DC32     0x45670123

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_4:
   \   00000000   0x40023C04         DC32     0x40023c04

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_5:
   \   00000000   0xCDEF89AB         DC32     0xcdef89ab

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_6:
   \   00000000   0x40023C14         DC32     0x40023c14

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_7:
   \   00000000   0x08192A3B         DC32     0x8192a3b

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_8:
   \   00000000   0x40023C08         DC32     0x40023c08

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_9:
   \   00000000   0x4C5D6E7F         DC32     0x4c5d6e7f
    802          
    803          /**
    804            * @}
    805            */
    806          
    807          #endif /* HAL_FLASH_MODULE_ENABLED */
    808          
    809          /**
    810            * @}
    811            */
    812          
    813          /**
    814            * @}
    815            */
    816          
    817          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   FLASH_Program_Byte
       4   FLASH_Program_DoubleWord
       0   FLASH_Program_HalfWord
       0   FLASH_Program_Word
       0   FLASH_SetErrorCode
      16   FLASH_WaitForLastOperation
        16   -> FLASH_SetErrorCode
        16   -> HAL_GetTick
       0   HAL_FLASH_EndOfOperationCallback
       0   HAL_FLASH_GetError
       8   HAL_FLASH_IRQHandler
         8   -> FLASH_Erase_Sector
         8   -> FLASH_SetErrorCode
         8   -> HAL_FLASH_EndOfOperationCallback
         8   -> HAL_FLASH_OperationErrorCallback
       0   HAL_FLASH_Lock
       8   HAL_FLASH_OB_Launch
         8   -> FLASH_WaitForLastOperation
       0   HAL_FLASH_OB_Lock
       0   HAL_FLASH_OB_Unlock
       0   HAL_FLASH_OperationErrorCallback
      24   HAL_FLASH_Program
        24   -> FLASH_Program_Byte
        24   -> FLASH_Program_DoubleWord
        24   -> FLASH_Program_HalfWord
        24   -> FLASH_Program_Word
        24   -> FLASH_WaitForLastOperation
      24   HAL_FLASH_Program_IT
        24   -> FLASH_Program_Byte
        24   -> FLASH_Program_DoubleWord
        24   -> FLASH_Program_HalfWord
        24   -> FLASH_Program_Word
       0   HAL_FLASH_Unlock


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable14
       4  ??DataTable14_1
       4  ??DataTable14_2
       4  ??DataTable14_3
       4  ??DataTable14_4
       4  ??DataTable14_5
       4  ??DataTable14_6
       4  ??DataTable14_7
       4  ??DataTable14_8
       4  ??DataTable14_9
      40  FLASH_Program_Byte
      50  FLASH_Program_DoubleWord
      44  FLASH_Program_HalfWord
      44  FLASH_Program_Word
     102  FLASH_SetErrorCode
      72  FLASH_WaitForLastOperation
       2  HAL_FLASH_EndOfOperationCallback
       6  HAL_FLASH_GetError
     350  HAL_FLASH_IRQHandler
      16  HAL_FLASH_Lock
      24  HAL_FLASH_OB_Launch
      16  HAL_FLASH_OB_Lock
      28  HAL_FLASH_OB_Unlock
       2  HAL_FLASH_OperationErrorCallback
     162  HAL_FLASH_Program
     162  HAL_FLASH_Program_IT
      28  HAL_FLASH_Unlock
      28  pFlash

 
    28 bytes in section .bss
 1 188 bytes in section .text
 
 1 188 bytes of CODE memory
    28 bytes of DATA memory

Errors: none
Warnings: none
