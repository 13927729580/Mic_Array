###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.2.10312/W32 for ARM       12/Apr/2016  09:55:48
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_flash.c
#    Command line =  
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_flash.c
#        -D USE_HAL_DRIVER -D STM32F746xx -D USE_STM32746G_DISCO -D
#        USE_IOEXPANDER -D USE_USB_FS -lC
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
#        -lA
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
#        -o
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj
#        --no_unroll --debug --endian=little --cpu=Cortex-M7 -e --fpu=VFPv5_sp
#        --dlib_config "D:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Full.h" -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\CMSIS\Device\ST\STM32F7xx\Include\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\STM32F7xx_HAL_Driver\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\STM32746G-Discovery\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\Components\Common\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Log\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Fonts\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\CPU\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_Device_Library\Core\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Core\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Class\MSC\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\drivers\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_Audio\Addons\PDM\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_Device_Library\Class\AUDIO\Inc\
#        -Ohs --use_c++_inline --require_prototypes -I "D:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.3\arm\CMSIS\Include\" -D
#        ARM_MATH_CM7 --relaxed_fp
#    List file    =  
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List\stm32f7xx_hal_flash.lst
#    Object file  =  
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj\stm32f7xx_hal_flash.o
#
###############################################################################

D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_flash.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f7xx_hal_flash.c
      4            * @author  MCD Application Team
      5            * @version V1.0.4
      6            * @date    09-December-2015
      7            * @brief   FLASH HAL module driver.
      8            *          This file provides firmware functions to manage the following 
      9            *          functionalities of the internal FLASH memory:
     10            *           + Program operations functions
     11            *           + Memory Control functions 
     12            *           + Peripheral Errors functions
     13            *         
     14            @verbatim
     15            ==============================================================================
     16                                  ##### FLASH peripheral features #####
     17            ==============================================================================
     18                     
     19            [..] The Flash memory interface manages CPU AHB I-Code and D-Code accesses 
     20                 to the Flash memory. It implements the erase and program Flash memory operations 
     21                 and the read and write protection mechanisms.
     22                
     23            [..] The Flash memory interface accelerates code execution with a system of instruction
     24                 prefetch and cache lines. 
     25          
     26            [..] The FLASH main features are:
     27                (+) Flash memory read operations
     28                (+) Flash memory program/erase operations
     29                (+) Read / write protections
     30                (+) Prefetch on I-Code
     31                (+) 64 cache lines of 128 bits on I-Code
     32                (+) 8 cache lines of 128 bits on D-Code
     33                
     34                               ##### How to use this driver #####
     35            ==============================================================================
     36              [..]                             
     37                This driver provides functions and macros to configure and program the FLASH 
     38                memory of all STM32F7xx devices.
     39              
     40                (#) FLASH Memory IO Programming functions: 
     41                     (++) Lock and Unlock the FLASH interface using HAL_FLASH_Unlock() and 
     42                          HAL_FLASH_Lock() functions
     43                     (++) Program functions: byte, half word, word and double word
     44                     (++) There Two modes of programming :
     45                      (+++) Polling mode using HAL_FLASH_Program() function
     46                      (+++) Interrupt mode using HAL_FLASH_Program_IT() function
     47              
     48                (#) Interrupts and flags management functions : 
     49                     (++) Handle FLASH interrupts by calling HAL_FLASH_IRQHandler()
     50                     (++) Wait for last FLASH operation according to its status
     51                     (++) Get error flag status by calling HAL_SetErrorCode()          
     52              [..] 
     53                In addition to these functions, this driver includes a set of macros allowing
     54                to handle the following operations:
     55                 (+) Set the latency
     56                 (+) Enable/Disable the prefetch buffer
     57                 (+) Enable/Disable the Instruction cache and the Data cache
     58                 (+) Reset the Instruction cache and the Data cache
     59                 (+) Enable/Disable the FLASH interrupts
     60                 (+) Monitor the FLASH flags status
     61              [..]	   
     62          	(@) For any Flash memory program operation (erase or program), the CPU clock frequency
     63                  (HCLK) must be at least 1MHz. 
     64          	(@) The contents of the Flash memory are not guaranteed if a device reset occurs during 
     65          	    a Flash memory operation.
     66              (@) Any attempt to read the Flash memory while it is being written or erased, causes the 
     67          	    bus to stall. Read operations are processed correctly once the program operation has 
     68          		completed. This means that code or data fetches cannot be performed while a write/erase 
     69          		operation is ongoing.
     70                    
     71            @endverbatim
     72            ******************************************************************************
     73            * @attention
     74            *
     75            * <h2><center>&copy; COPYRIGHT(c) 2015 STMicroelectronics</center></h2>
     76            *
     77            * Redistribution and use in source and binary forms, with or without modification,
     78            * are permitted provided that the following conditions are met:
     79            *   1. Redistributions of source code must retain the above copyright notice,
     80            *      this list of conditions and the following disclaimer.
     81            *   2. Redistributions in binary form must reproduce the above copyright notice,
     82            *      this list of conditions and the following disclaimer in the documentation
     83            *      and/or other materials provided with the distribution.
     84            *   3. Neither the name of STMicroelectronics nor the names of its contributors
     85            *      may be used to endorse or promote products derived from this software
     86            *      without specific prior written permission.
     87            *
     88            * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
     89            * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     90            * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     91            * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
     92            * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
     93            * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
     94            * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
     95            * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
     96            * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
     97            * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     98            *
     99            ******************************************************************************
    100            */ 
    101          
    102          /* Includes ------------------------------------------------------------------*/
    103          #include "stm32f7xx_hal.h"
    104          
    105          /** @addtogroup STM32F7xx_HAL_Driver
    106            * @{
    107            */
    108          
    109          /** @defgroup FLASH FLASH
    110            * @brief FLASH HAL module driver
    111            * @{
    112            */
    113          
    114          #ifdef HAL_FLASH_MODULE_ENABLED
    115          
    116          /* Private typedef -----------------------------------------------------------*/
    117          /* Private define ------------------------------------------------------------*/
    118          /** @addtogroup FLASH_Private_Constants
    119            * @{
    120            */
    121          #define SECTOR_MASK               ((uint32_t)0xFFFFFF07)
    122          #define FLASH_TIMEOUT_VALUE       ((uint32_t)50000)/* 50 s */
    123          /**
    124            * @}
    125            */         
    126          /* Private macro -------------------------------------------------------------*/
    127          /* Private variables ---------------------------------------------------------*/
    128          /** @addtogroup FLASH_Private_Variables
    129            * @{
    130            */
    131          /* Variable used for Erase sectors under interruption */

   \                                 In section .bss, align 4
    132          FLASH_ProcessTypeDef pFlash;
   \                     pFlash:
   \   00000000                      DS8 28
    133          /**
    134            * @}
    135            */
    136          
    137          /* Private function prototypes -----------------------------------------------*/
    138          /** @addtogroup FLASH_Private_Functions
    139            * @{
    140            */
    141          /* Program operations */
    142          static void   FLASH_Program_DoubleWord(uint32_t Address, uint64_t Data);
    143          static void   FLASH_Program_Word(uint32_t Address, uint32_t Data);
    144          static void   FLASH_Program_HalfWord(uint32_t Address, uint16_t Data);
    145          static void   FLASH_Program_Byte(uint32_t Address, uint8_t Data);
    146          static void   FLASH_SetErrorCode(void);
    147          
    148          HAL_StatusTypeDef FLASH_WaitForLastOperation(uint32_t Timeout);
    149          /**
    150            * @}
    151            */
    152          
    153          /* Exported functions --------------------------------------------------------*/
    154          /** @defgroup FLASH_Exported_Functions FLASH Exported Functions
    155            * @{
    156            */
    157            
    158          /** @defgroup FLASH_Exported_Functions_Group1 Programming operation functions 
    159           *  @brief   Programming operation functions 
    160           *
    161          @verbatim   
    162           ===============================================================================
    163                            ##### Programming operation functions #####
    164           ===============================================================================  
    165              [..]
    166              This subsection provides a set of functions allowing to manage the FLASH 
    167              program operations.
    168          
    169          @endverbatim
    170            * @{
    171            */
    172          
    173          /**
    174            * @brief  Program byte, halfword, word or double word at a specified address
    175            * @param  TypeProgram:  Indicate the way to program at a specified address.
    176            *                           This parameter can be a value of @ref FLASH_Type_Program
    177            * @param  Address:  specifies the address to be programmed.
    178            * @param  Data: specifies the data to be programmed
    179            * 
    180            * @retval HAL_StatusTypeDef HAL Status
    181            */

   \                                 In section .text, align 4, keep-with-next
    182          HAL_StatusTypeDef HAL_FLASH_Program(uint32_t TypeProgram, uint32_t Address, uint64_t Data)
    183          {
   \                     HAL_FLASH_Program: (+1)
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
    184            HAL_StatusTypeDef status = HAL_ERROR;
    185            
    186            /* Process Locked */
    187            __HAL_LOCK(&pFlash);
   \   00000004   0x.... 0x....      LDR.W    R5,??DataTable10
   \   00000008   0xB081             SUB      SP,SP,#+4
   \   0000000A   0x4682             MOV      R10,R0
   \   0000000C   0x4689             MOV      R9,R1
   \   0000000E   0x7D28             LDRB     R0,[R5, #+20]
   \   00000010   0x4614             MOV      R4,R2
   \   00000012   0x4698             MOV      R8,R3
   \   00000014   0x2801             CMP      R0,#+1
   \   00000016   0xBF08             IT       EQ 
   \   00000018   0x2002             MOVEQ    R0,#+2
   \   0000001A   0xF000 0x807C      BEQ.W    ??HAL_FLASH_Program_1
   \   0000001E   0x2001             MOVS     R0,#+1
    188          
    189            /* Check the parameters */
    190            assert_param(IS_FLASH_TYPEPROGRAM(TypeProgram));
    191          
    192            /* Wait for last operation to be completed */
    193            status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
   \   00000020   0xF24C 0x3B51      MOVW     R11,#+50001
   \   00000024   0x7528             STRB     R0,[R5, #+20]
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0x61A8             STR      R0,[R5, #+24]
   \   0000002A   0x.... 0x....      LDR.W    R6,??DataTable10_1  ;; 0x40023c0c
   \   0000002E   0x.... 0x....      BL       HAL_GetTick
   \   00000032   0x4607             MOV      R7,R0
   \                     ??HAL_FLASH_Program_2: (+1)
   \   00000034   0x6830             LDR      R0,[R6, #+0]
   \   00000036   0x03C0             LSLS     R0,R0,#+15
   \   00000038   0xD506             BPL.N    ??HAL_FLASH_Program_3
   \   0000003A   0x.... 0x....      BL       HAL_GetTick
   \   0000003E   0x1BC0             SUBS     R0,R0,R7
   \   00000040   0x4558             CMP      R0,R11
   \   00000042   0xD3F7             BCC.N    ??HAL_FLASH_Program_2
   \   00000044   0x2703             MOVS     R7,#+3
   \   00000046   0xE063             B.N      ??HAL_FLASH_Program_4
   \                     ??HAL_FLASH_Program_3: (+1)
   \   00000048   0x6830             LDR      R0,[R6, #+0]
   \   0000004A   0xF010 0x0FF2      TST      R0,#0xF2
   \   0000004E   0xD003             BEQ.N    ??HAL_FLASH_Program_5
   \   00000050   0x.... 0x....      BL       FLASH_SetErrorCode
   \   00000054   0x2701             MOVS     R7,#+1
   \   00000056   0xE05B             B.N      ??HAL_FLASH_Program_4
   \                     ??HAL_FLASH_Program_5: (+1)
   \   00000058   0x2700             MOVS     R7,#+0
    194            
    195            if(status == HAL_OK)
    196            {
    197              switch(TypeProgram)
   \   0000005A   0xF1BA 0x0F03      CMP      R10,#+3
   \   0000005E   0xD83E             BHI.N    ??HAL_FLASH_Program_6
   \   00000060   0xE8DF 0xF00A      TBB      [PC, R10]
   \                     ??HAL_FLASH_Program_0:
   \   00000064   0x02 0x0F          DC8      0x2,0xF,0x1E,0x2D
   \              0x1E 0x2D    
    198              {
    199                case FLASH_TYPEPROGRAM_BYTE :
    200                {
    201                  /*Program byte (8-bit) at a specified address.*/
    202                  FLASH_Program_Byte(Address, (uint8_t) Data);
   \                     ??HAL_FLASH_Program_7: (+1)
   \   00000068   0x6870             LDR      R0,[R6, #+4]
   \   0000006A   0xF420 0x7040      BIC      R0,R0,#0x300
   \   0000006E   0x6070             STR      R0,[R6, #+4]
   \   00000070   0x6870             LDR      R0,[R6, #+4]
   \   00000072   0x6070             STR      R0,[R6, #+4]
   \   00000074   0x6870             LDR      R0,[R6, #+4]
   \   00000076   0xF040 0x0001      ORR      R0,R0,#0x1
   \   0000007A   0x6070             STR      R0,[R6, #+4]
   \   0000007C   0xF889 0x4000      STRB     R4,[R9, #+0]
   \   00000080   0xE02B             B.N      ??HAL_FLASH_Program_8
    203                  break;
    204                }
    205                
    206                case FLASH_TYPEPROGRAM_HALFWORD :
    207                {
    208                  /*Program halfword (16-bit) at a specified address.*/
    209                  FLASH_Program_HalfWord(Address, (uint16_t) Data);
   \                     ??HAL_FLASH_Program_9: (+1)
   \   00000082   0x6870             LDR      R0,[R6, #+4]
   \   00000084   0xF420 0x7040      BIC      R0,R0,#0x300
   \   00000088   0x6070             STR      R0,[R6, #+4]
   \   0000008A   0x6870             LDR      R0,[R6, #+4]
   \   0000008C   0xF440 0x7080      ORR      R0,R0,#0x100
   \   00000090   0x6070             STR      R0,[R6, #+4]
   \   00000092   0x6870             LDR      R0,[R6, #+4]
   \   00000094   0xF040 0x0001      ORR      R0,R0,#0x1
   \   00000098   0x6070             STR      R0,[R6, #+4]
   \   0000009A   0xF8A9 0x4000      STRH     R4,[R9, #+0]
   \   0000009E   0xE01C             B.N      ??HAL_FLASH_Program_8
    210                  break;
    211                }
    212                
    213                case FLASH_TYPEPROGRAM_WORD :
    214                {
    215                  /*Program word (32-bit) at a specified address.*/
    216                  FLASH_Program_Word(Address, (uint32_t) Data);
   \                     ??HAL_FLASH_Program_10: (+1)
   \   000000A0   0x6870             LDR      R0,[R6, #+4]
   \   000000A2   0xF420 0x7040      BIC      R0,R0,#0x300
   \   000000A6   0x6070             STR      R0,[R6, #+4]
   \   000000A8   0x6870             LDR      R0,[R6, #+4]
   \   000000AA   0xF440 0x7000      ORR      R0,R0,#0x200
   \   000000AE   0x6070             STR      R0,[R6, #+4]
   \   000000B0   0x6870             LDR      R0,[R6, #+4]
   \   000000B2   0xF040 0x0001      ORR      R0,R0,#0x1
   \   000000B6   0x6070             STR      R0,[R6, #+4]
   \   000000B8   0xF8C9 0x4000      STR      R4,[R9, #+0]
   \   000000BC   0xE00D             B.N      ??HAL_FLASH_Program_8
    217                  break;
    218                }
    219                
    220                case FLASH_TYPEPROGRAM_DOUBLEWORD :
    221                {
    222                  /*Program double word (64-bit) at a specified address.*/
    223                  FLASH_Program_DoubleWord(Address, Data);
   \                     ??HAL_FLASH_Program_11: (+1)
   \   000000BE   0x6870             LDR      R0,[R6, #+4]
   \   000000C0   0xF420 0x7040      BIC      R0,R0,#0x300
   \   000000C4   0x6070             STR      R0,[R6, #+4]
   \   000000C6   0x6870             LDR      R0,[R6, #+4]
   \   000000C8   0xF440 0x7040      ORR      R0,R0,#0x300
   \   000000CC   0x6070             STR      R0,[R6, #+4]
   \   000000CE   0x6870             LDR      R0,[R6, #+4]
   \   000000D0   0xF040 0x0001      ORR      R0,R0,#0x1
   \   000000D4   0x6070             STR      R0,[R6, #+4]
   \   000000D6   0xE9C9 0x4800      STRD     R4,R8,[R9, #+0]
   \                     ??HAL_FLASH_Program_8: (+1)
   \   000000DA   0xF3BF 0x8F4F      DSB      
    224                  break;
    225                }
    226                default :
    227                  break;
    228              }
    229              /* Wait for last operation to be completed */
    230              status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
   \                     ??HAL_FLASH_Program_6: (+1)
   \   000000DE   0x61AF             STR      R7,[R5, #+24]
   \   000000E0   0x.... 0x....      BL       HAL_GetTick
   \   000000E4   0x4604             MOV      R4,R0
   \                     ??HAL_FLASH_Program_12: (+1)
   \   000000E6   0x6830             LDR      R0,[R6, #+0]
   \   000000E8   0x03C0             LSLS     R0,R0,#+15
   \   000000EA   0xD506             BPL.N    ??HAL_FLASH_Program_13
   \   000000EC   0x.... 0x....      BL       HAL_GetTick
   \   000000F0   0x1B00             SUBS     R0,R0,R4
   \   000000F2   0x4558             CMP      R0,R11
   \   000000F4   0xD3F7             BCC.N    ??HAL_FLASH_Program_12
   \   000000F6   0x2703             MOVS     R7,#+3
   \   000000F8   0xE006             B.N      ??HAL_FLASH_Program_14
   \                     ??HAL_FLASH_Program_13: (+1)
   \   000000FA   0x6830             LDR      R0,[R6, #+0]
   \   000000FC   0xF010 0x0FF2      TST      R0,#0xF2
   \   00000100   0xD002             BEQ.N    ??HAL_FLASH_Program_14
   \   00000102   0x.... 0x....      BL       FLASH_SetErrorCode
   \   00000106   0x2701             MOVS     R7,#+1
    231              
    232              /* If the program operation is completed, disable the PG Bit */
    233              FLASH->CR &= (~FLASH_CR_PG);
   \                     ??HAL_FLASH_Program_14: (+1)
   \   00000108   0x6870             LDR      R0,[R6, #+4]
   \   0000010A   0x0840             LSRS     R0,R0,#+1
   \   0000010C   0x0040             LSLS     R0,R0,#+1
   \   0000010E   0x6070             STR      R0,[R6, #+4]
    234            }
    235          
    236            /* Process Unlocked */
    237            __HAL_UNLOCK(&pFlash);
   \                     ??HAL_FLASH_Program_4: (+1)
   \   00000110   0x2000             MOVS     R0,#+0
   \   00000112   0x7528             STRB     R0,[R5, #+20]
    238          
    239            return status;
   \   00000114   0x4638             MOV      R0,R7
   \                     ??HAL_FLASH_Program_1: (+1)
   \   00000116   0xB001             ADD      SP,SP,#+4
   \   00000118   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    240          }
    241          
    242          /**
    243            * @brief   Program byte, halfword, word or double word at a specified address  with interrupt enabled.
    244            * @param  TypeProgram:  Indicate the way to program at a specified address.
    245            *                           This parameter can be a value of @ref FLASH_Type_Program
    246            * @param  Address:  specifies the address to be programmed.
    247            * @param  Data: specifies the data to be programmed
    248            * 
    249            * @retval HAL Status
    250            */

   \                                 In section .text, align 4, keep-with-next
    251          HAL_StatusTypeDef HAL_FLASH_Program_IT(uint32_t TypeProgram, uint32_t Address, uint64_t Data)
    252          {
   \                     HAL_FLASH_Program_IT: (+1)
   \   00000000   0xB470             PUSH     {R4-R6}
    253            HAL_StatusTypeDef status = HAL_OK;
    254            
    255            /* Process Locked */
    256            __HAL_LOCK(&pFlash);
   \   00000002   0x....             LDR.N    R5,??DataTable10
   \   00000004   0x7D2C             LDRB     R4,[R5, #+20]
   \   00000006   0x2C01             CMP      R4,#+1
   \   00000008   0xBF08             IT       EQ 
   \   0000000A   0x2002             MOVEQ    R0,#+2
   \   0000000C   0xD04E             BEQ.N    ??HAL_FLASH_Program_IT_1
   \   0000000E   0x2401             MOVS     R4,#+1
   \   00000010   0x752C             STRB     R4,[R5, #+20]
    257          
    258            /* Check the parameters */
    259            assert_param(IS_FLASH_TYPEPROGRAM(TypeProgram));
    260          
    261            /* Enable End of FLASH Operation interrupt */
    262            __HAL_FLASH_ENABLE_IT(FLASH_IT_EOP);
   \   00000012   0x....             LDR.N    R4,??DataTable10_1  ;; 0x40023c0c
   \   00000014   0x6866             LDR      R6,[R4, #+4]
   \   00000016   0xF046 0x7680      ORR      R6,R6,#0x1000000
   \   0000001A   0x6066             STR      R6,[R4, #+4]
    263            
    264            /* Enable Error source interrupt */
    265            __HAL_FLASH_ENABLE_IT(FLASH_IT_ERR);
   \   0000001C   0x6866             LDR      R6,[R4, #+4]
   \   0000001E   0xF046 0x7600      ORR      R6,R6,#0x2000000
   \   00000022   0x6066             STR      R6,[R4, #+4]
    266            
    267            /* Clear pending flags (if any) */  
    268            __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_EOP    | FLASH_FLAG_OPERR | FLASH_FLAG_WRPERR |\
    269                                   FLASH_FLAG_PGAERR | FLASH_FLAG_PGPERR| FLASH_FLAG_ERSERR);  
   \   00000024   0x26F3             MOVS     R6,#+243
   \   00000026   0x6026             STR      R6,[R4, #+0]
    270          
    271            pFlash.ProcedureOnGoing = FLASH_PROC_PROGRAM;
   \   00000028   0x2603             MOVS     R6,#+3
    272            pFlash.Address = Address;
    273            
    274            switch(TypeProgram)
   \   0000002A   0x2803             CMP      R0,#+3
   \   0000002C   0x702E             STRB     R6,[R5, #+0]
   \   0000002E   0x6129             STR      R1,[R5, #+16]
   \   00000030   0xD83B             BHI.N    ??HAL_FLASH_Program_IT_2
   \   00000032   0xE8DF 0xF000      TBB      [PC, R0]
   \                     ??HAL_FLASH_Program_IT_0:
   \   00000036   0x02 0x0E          DC8      0x2,0xE,0x1C,0x2A
   \              0x1C 0x2A    
    275            {
    276              case FLASH_TYPEPROGRAM_BYTE :
    277              {
    278                /*Program byte (8-bit) at a specified address.*/
    279                FLASH_Program_Byte(Address, (uint8_t) Data);
   \                     ??HAL_FLASH_Program_IT_3: (+1)
   \   0000003A   0x6860             LDR      R0,[R4, #+4]
   \   0000003C   0xF420 0x7040      BIC      R0,R0,#0x300
   \   00000040   0x6060             STR      R0,[R4, #+4]
   \   00000042   0x6860             LDR      R0,[R4, #+4]
   \   00000044   0x6060             STR      R0,[R4, #+4]
   \   00000046   0x6860             LDR      R0,[R4, #+4]
   \   00000048   0xF040 0x0001      ORR      R0,R0,#0x1
   \   0000004C   0x6060             STR      R0,[R4, #+4]
   \   0000004E   0x700A             STRB     R2,[R1, #+0]
   \   00000050   0xE029             B.N      ??HAL_FLASH_Program_IT_4
    280                break;
    281              }
    282              
    283              case FLASH_TYPEPROGRAM_HALFWORD :
    284              {
    285                /*Program halfword (16-bit) at a specified address.*/
    286                FLASH_Program_HalfWord(Address, (uint16_t) Data);
   \                     ??HAL_FLASH_Program_IT_5: (+1)
   \   00000052   0x6860             LDR      R0,[R4, #+4]
   \   00000054   0xF420 0x7040      BIC      R0,R0,#0x300
   \   00000058   0x6060             STR      R0,[R4, #+4]
   \   0000005A   0x6860             LDR      R0,[R4, #+4]
   \   0000005C   0xF440 0x7080      ORR      R0,R0,#0x100
   \   00000060   0x6060             STR      R0,[R4, #+4]
   \   00000062   0x6860             LDR      R0,[R4, #+4]
   \   00000064   0xF040 0x0001      ORR      R0,R0,#0x1
   \   00000068   0x6060             STR      R0,[R4, #+4]
   \   0000006A   0x800A             STRH     R2,[R1, #+0]
   \   0000006C   0xE01B             B.N      ??HAL_FLASH_Program_IT_4
    287                break;
    288              }
    289              
    290              case FLASH_TYPEPROGRAM_WORD :
    291              {
    292                /*Program word (32-bit) at a specified address.*/
    293                FLASH_Program_Word(Address, (uint32_t) Data);
   \                     ??HAL_FLASH_Program_IT_6: (+1)
   \   0000006E   0x6860             LDR      R0,[R4, #+4]
   \   00000070   0xF420 0x7040      BIC      R0,R0,#0x300
   \   00000074   0x6060             STR      R0,[R4, #+4]
   \   00000076   0x6860             LDR      R0,[R4, #+4]
   \   00000078   0xF440 0x7000      ORR      R0,R0,#0x200
   \   0000007C   0x6060             STR      R0,[R4, #+4]
   \   0000007E   0x6860             LDR      R0,[R4, #+4]
   \   00000080   0xF040 0x0001      ORR      R0,R0,#0x1
   \   00000084   0x6060             STR      R0,[R4, #+4]
   \   00000086   0x600A             STR      R2,[R1, #+0]
   \   00000088   0xE00D             B.N      ??HAL_FLASH_Program_IT_4
    294                break;
    295              }
    296              
    297              case FLASH_TYPEPROGRAM_DOUBLEWORD :
    298              {
    299                /*Program double word (64-bit) at a specified address.*/
    300                FLASH_Program_DoubleWord(Address, Data);
   \                     ??HAL_FLASH_Program_IT_7: (+1)
   \   0000008A   0x6860             LDR      R0,[R4, #+4]
   \   0000008C   0xF420 0x7040      BIC      R0,R0,#0x300
   \   00000090   0x6060             STR      R0,[R4, #+4]
   \   00000092   0x6860             LDR      R0,[R4, #+4]
   \   00000094   0xF440 0x7040      ORR      R0,R0,#0x300
   \   00000098   0x6060             STR      R0,[R4, #+4]
   \   0000009A   0x6860             LDR      R0,[R4, #+4]
   \   0000009C   0xF040 0x0001      ORR      R0,R0,#0x1
   \   000000A0   0x6060             STR      R0,[R4, #+4]
   \   000000A2   0xE9C1 0x2300      STRD     R2,R3,[R1, #+0]
   \                     ??HAL_FLASH_Program_IT_4: (+1)
   \   000000A6   0xF3BF 0x8F4F      DSB      
    301                break;
    302              }
    303              default :
    304                break;
    305            }
    306            return status;
   \                     ??HAL_FLASH_Program_IT_2: (+1)
   \   000000AA   0x2000             MOVS     R0,#+0
   \                     ??HAL_FLASH_Program_IT_1: (+1)
   \   000000AC   0xBC70             POP      {R4-R6}
   \   000000AE   0x4770             BX       LR               ;; return
    307          }
    308          
    309          /**
    310            * @brief This function handles FLASH interrupt request.
    311            * @retval None
    312            */

   \                                 In section .text, align 2, keep-with-next
    313          void HAL_FLASH_IRQHandler(void)
    314          {
   \                     HAL_FLASH_IRQHandler: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
    315            uint32_t temp = 0;
    316            
    317            /* If the program operation is completed, disable the PG Bit */
    318            FLASH->CR &= (~FLASH_CR_PG);
   \   00000002   0x....             LDR.N    R5,??DataTable10_1  ;; 0x40023c0c
   \   00000004   0x2400             MOVS     R4,#+0
    319          
    320            /* If the erase operation is completed, disable the SER Bit */
    321            FLASH->CR &= (~FLASH_CR_SER);
    322            FLASH->CR &= SECTOR_MASK; 
    323          
    324            /* if the erase operation is completed, disable the MER Bit */
    325            FLASH->CR &= (~FLASH_MER_BIT);
    326          
    327            /* Check FLASH End of Operation flag  */
    328            if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_EOP) != RESET)
   \   00000006   0x....             LDR.N    R6,??DataTable10
   \   00000008   0x6868             LDR      R0,[R5, #+4]
   \   0000000A   0x0840             LSRS     R0,R0,#+1
   \   0000000C   0x0040             LSLS     R0,R0,#+1
   \   0000000E   0x6068             STR      R0,[R5, #+4]
   \   00000010   0x6868             LDR      R0,[R5, #+4]
   \   00000012   0xF020 0x0002      BIC      R0,R0,#0x2
   \   00000016   0x6068             STR      R0,[R5, #+4]
   \   00000018   0x6868             LDR      R0,[R5, #+4]
   \   0000001A   0xF020 0x00F8      BIC      R0,R0,#0xF8
   \   0000001E   0x6068             STR      R0,[R5, #+4]
   \   00000020   0x6868             LDR      R0,[R5, #+4]
   \   00000022   0xF020 0x0004      BIC      R0,R0,#0x4
   \   00000026   0x6068             STR      R0,[R5, #+4]
   \   00000028   0x6828             LDR      R0,[R5, #+0]
   \   0000002A   0x07C0             LSLS     R0,R0,#+31
   \   0000002C   0xD52A             BPL.N    ??HAL_FLASH_IRQHandler_0
    329            {
    330              switch (pFlash.ProcedureOnGoing)
   \   0000002E   0x7830             LDRB     R0,[R6, #+0]
   \   00000030   0x2801             CMP      R0,#+1
   \   00000032   0xD004             BEQ.N    ??HAL_FLASH_IRQHandler_1
   \   00000034   0xD326             BCC.N    ??HAL_FLASH_IRQHandler_0
   \   00000036   0x2803             CMP      R0,#+3
   \   00000038   0xD01E             BEQ.N    ??HAL_FLASH_IRQHandler_2
   \   0000003A   0xD31B             BCC.N    ??HAL_FLASH_IRQHandler_3
   \   0000003C   0xE022             B.N      ??HAL_FLASH_IRQHandler_0
    331              {
    332                case FLASH_PROC_SECTERASE :
    333                {
    334                  /* Nb of sector to erased can be decreased */
    335                  pFlash.NbSectorsToErase--;
   \                     ??HAL_FLASH_IRQHandler_1: (+1)
   \   0000003E   0x6870             LDR      R0,[R6, #+4]
   \   00000040   0x1E40             SUBS     R0,R0,#+1
   \   00000042   0x6070             STR      R0,[R6, #+4]
    336          
    337                  /* Check if there are still sectors to erase */
    338                  if(pFlash.NbSectorsToErase != 0)
   \   00000044   0x6870             LDR      R0,[R6, #+4]
   \   00000046   0xB160             CBZ.N    R0,??HAL_FLASH_IRQHandler_4
    339                  {
    340                    temp = pFlash.Sector;
   \   00000048   0x68F0             LDR      R0,[R6, #+12]
    341                    /* Indicate user which sector has been erased */
    342                    HAL_FLASH_EndOfOperationCallback(temp);
   \   0000004A   0x.... 0x....      BL       HAL_FLASH_EndOfOperationCallback
    343          
    344                    /* Clear pending flags (if any) */  
    345                    __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_EOP);  
   \   0000004E   0x2001             MOVS     R0,#+1
   \   00000050   0x6028             STR      R0,[R5, #+0]
    346          
    347                    /* Increment sector number */
    348                    temp = ++pFlash.Sector;
   \   00000052   0x68F0             LDR      R0,[R6, #+12]
   \   00000054   0x1C44             ADDS     R4,R0,#+1
    349                    FLASH_Erase_Sector(temp, pFlash.VoltageForErase);
   \   00000056   0x4620             MOV      R0,R4
   \   00000058   0x60F4             STR      R4,[R6, #+12]
   \   0000005A   0x7A31             LDRB     R1,[R6, #+8]
   \   0000005C   0x.... 0x....      BL       FLASH_Erase_Sector
   \   00000060   0xE010             B.N      ??HAL_FLASH_IRQHandler_0
    350                  }
    351                  else
    352                  {
    353                    /* No more sectors to Erase, user callback can be called.*/
    354                    /* Reset Sector and stop Erase sectors procedure */
    355                    pFlash.Sector = temp = 0xFFFFFFFF;
   \                     ??HAL_FLASH_IRQHandler_4: (+1)
   \   00000062   0xF04F 0x34FF      MOV      R4,#-1
    356                    /* FLASH EOP interrupt user callback */
    357                    HAL_FLASH_EndOfOperationCallback(temp);
   \   00000066   0x4620             MOV      R0,R4
   \   00000068   0x60F4             STR      R4,[R6, #+12]
   \   0000006A   0x.... 0x....      BL       HAL_FLASH_EndOfOperationCallback
    358                    /* Sector Erase procedure is completed */
    359                    pFlash.ProcedureOnGoing = FLASH_PROC_NONE;
   \   0000006E   0x2000             MOVS     R0,#+0
   \   00000070   0x7030             STRB     R0,[R6, #+0]
    360                    /* Clear FLASH End of Operation pending bit */
    361                    __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_EOP);
   \   00000072   0xE005             B.N      ??HAL_FLASH_IRQHandler_5
    362                  }
    363                  break;
    364                }
    365              
    366                case FLASH_PROC_MASSERASE :
    367                {
    368                  /* MassErase ended. Return the selected bank : in this product we don't have Banks */
    369                  /* FLASH EOP interrupt user callback */
    370                  HAL_FLASH_EndOfOperationCallback(0);
   \                     ??HAL_FLASH_IRQHandler_3: (+1)
   \   00000074   0x2000             MOVS     R0,#+0
   \   00000076   0xE000             B.N      ??HAL_FLASH_IRQHandler_6
    371                  /* MAss Erase procedure is completed */
    372                  pFlash.ProcedureOnGoing = FLASH_PROC_NONE;
    373                  /* Clear FLASH End of Operation pending bit */
    374                  __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_EOP);
    375                  break;
    376                }
    377          
    378                case FLASH_PROC_PROGRAM :
    379                {
    380                  /*Program ended. Return the selected address*/
    381                  /* FLASH EOP interrupt user callback */
    382                  HAL_FLASH_EndOfOperationCallback(pFlash.Address);
   \                     ??HAL_FLASH_IRQHandler_2: (+1)
   \   00000078   0x6930             LDR      R0,[R6, #+16]
   \                     ??HAL_FLASH_IRQHandler_6: (+1)
   \   0000007A   0x.... 0x....      BL       HAL_FLASH_EndOfOperationCallback
    383                  /* Programming procedure is completed */
    384                  pFlash.ProcedureOnGoing = FLASH_PROC_NONE;
   \   0000007E   0x7034             STRB     R4,[R6, #+0]
    385                  /* Clear FLASH End of Operation pending bit */
    386                  __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_EOP);
   \                     ??HAL_FLASH_IRQHandler_5: (+1)
   \   00000080   0x2001             MOVS     R0,#+1
   \   00000082   0x6028             STR      R0,[R5, #+0]
    387                  break;
    388                }
    389                default :
    390                  break;
    391              }
    392            }
    393            
    394            /* Check FLASH operation error flags */
    395            if(__HAL_FLASH_GET_FLAG((FLASH_FLAG_OPERR  | FLASH_FLAG_WRPERR | FLASH_FLAG_PGAERR | FLASH_FLAG_PGPERR | FLASH_FLAG_ERSERR )) != RESET)
   \                     ??HAL_FLASH_IRQHandler_0: (+1)
   \   00000084   0x6828             LDR      R0,[R5, #+0]
   \   00000086   0xF010 0x0FF2      TST      R0,#0xF2
   \   0000008A   0xD017             BEQ.N    ??HAL_FLASH_IRQHandler_7
    396            {
    397              switch (pFlash.ProcedureOnGoing)
   \   0000008C   0x7830             LDRB     R0,[R6, #+0]
   \   0000008E   0x2801             CMP      R0,#+1
   \   00000090   0xD005             BEQ.N    ??HAL_FLASH_IRQHandler_8
   \   00000092   0xD30A             BCC.N    ??HAL_FLASH_IRQHandler_9
   \   00000094   0x2803             CMP      R0,#+3
   \   00000096   0xD007             BEQ.N    ??HAL_FLASH_IRQHandler_10
   \   00000098   0xBF38             IT       CC 
   \   0000009A   0x2400             MOVCC    R4,#+0
    398              {
    399                case FLASH_PROC_SECTERASE :
    400                {
    401                  /* return the faulty sector */
    402                  temp = pFlash.Sector;
    403                  pFlash.Sector = 0xFFFFFFFF;
    404                  break;
    405                }
    406                case FLASH_PROC_MASSERASE :
    407                {
    408                  /* No return in case of Mass Erase */
    409                  temp = 0;
   \   0000009C   0xE005             B.N      ??HAL_FLASH_IRQHandler_9
    410                  break;
    411                }
   \                     ??HAL_FLASH_IRQHandler_8: (+1)
   \   0000009E   0x68F4             LDR      R4,[R6, #+12]
   \   000000A0   0xF04F 0x30FF      MOV      R0,#-1
   \   000000A4   0x60F0             STR      R0,[R6, #+12]
   \   000000A6   0xE000             B.N      ??HAL_FLASH_IRQHandler_9
    412                case FLASH_PROC_PROGRAM :
    413                {
    414                  /*return the faulty address*/
    415                  temp = pFlash.Address;
   \                     ??HAL_FLASH_IRQHandler_10: (+1)
   \   000000A8   0x6934             LDR      R4,[R6, #+16]
    416                  break;
    417                }
    418              default :
    419                break;
    420              }
    421              /*Save the Error code*/
    422              FLASH_SetErrorCode();
   \                     ??HAL_FLASH_IRQHandler_9: (+1)
   \   000000AA   0x.... 0x....      BL       FLASH_SetErrorCode
    423          
    424              /* FLASH error interrupt user callback */
    425              HAL_FLASH_OperationErrorCallback(temp);
   \   000000AE   0x4620             MOV      R0,R4
   \   000000B0   0x.... 0x....      BL       HAL_FLASH_OperationErrorCallback
    426              /* Clear FLASH error pending bits */
    427              __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_OPERR  | FLASH_FLAG_WRPERR | FLASH_FLAG_PGAERR | FLASH_FLAG_PGPERR | FLASH_FLAG_ERSERR );
   \   000000B4   0x20F2             MOVS     R0,#+242
   \   000000B6   0x6028             STR      R0,[R5, #+0]
    428          
    429              /*Stop the procedure ongoing */
    430              pFlash.ProcedureOnGoing = FLASH_PROC_NONE;
   \   000000B8   0x2000             MOVS     R0,#+0
   \   000000BA   0x7030             STRB     R0,[R6, #+0]
    431            }
    432            
    433            if(pFlash.ProcedureOnGoing == FLASH_PROC_NONE)
   \                     ??HAL_FLASH_IRQHandler_7: (+1)
   \   000000BC   0x7830             LDRB     R0,[R6, #+0]
   \   000000BE   0xB948             CBNZ.N   R0,??HAL_FLASH_IRQHandler_11
    434            {
    435              /* Disable End of FLASH Operation interrupt */
    436              __HAL_FLASH_DISABLE_IT(FLASH_IT_EOP);
   \   000000C0   0x6868             LDR      R0,[R5, #+4]
   \   000000C2   0xF020 0x7080      BIC      R0,R0,#0x1000000
   \   000000C6   0x6068             STR      R0,[R5, #+4]
    437          
    438              /* Disable Error source interrupt */
    439              __HAL_FLASH_DISABLE_IT(FLASH_IT_ERR);
   \   000000C8   0x6868             LDR      R0,[R5, #+4]
   \   000000CA   0xF020 0x7000      BIC      R0,R0,#0x2000000
   \   000000CE   0x6068             STR      R0,[R5, #+4]
    440          
    441              /* Process Unlocked */
    442              __HAL_UNLOCK(&pFlash);
   \   000000D0   0x2000             MOVS     R0,#+0
   \   000000D2   0x7530             STRB     R0,[R6, #+20]
    443            }
    444            
    445          }
   \                     ??HAL_FLASH_IRQHandler_11: (+1)
   \   000000D4   0xBD70             POP      {R4-R6,PC}       ;; return
    446          
    447          /**
    448            * @brief  FLASH end of operation interrupt callback
    449            * @param  ReturnValue: The value saved in this parameter depends on the ongoing procedure
    450            *                 - Sectors Erase: Sector which has been erased (if 0xFFFFFFFF, it means that 
    451            *                                  all the selected sectors have been erased)
    452            *                 - Program      : Address which was selected for data program
    453            *                 - Mass Erase   : No return value expected
    454            * @retval None
    455            */

   \                                 In section .text, align 2, keep-with-next
    456          __weak void HAL_FLASH_EndOfOperationCallback(uint32_t ReturnValue)
    457          {
    458            /* Prevent unused argument(s) compilation warning */
    459            UNUSED(ReturnValue);
    460            /* NOTE : This function Should not be modified, when the callback is needed,
    461            the HAL_FLASH_EndOfOperationCallback could be implemented in the user file
    462            */ 
    463          }
   \                     HAL_FLASH_EndOfOperationCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    464          
    465          /**
    466            * @brief  FLASH operation error interrupt callback
    467            * @param  ReturnValue: The value saved in this parameter depends on the ongoing procedure
    468            *                 - Sectors Erase: Sector which has been erased (if 0xFFFFFFFF, it means that 
    469            *                                  all the selected sectors have been erased)
    470            *                 - Program      : Address which was selected for data program
    471            *                 - Mass Erase   : No return value expected
    472            * @retval None
    473            */

   \                                 In section .text, align 2, keep-with-next
    474          __weak void HAL_FLASH_OperationErrorCallback(uint32_t ReturnValue)
    475          {
    476            /* Prevent unused argument(s) compilation warning */
    477            UNUSED(ReturnValue);
    478            /* NOTE : This function Should not be modified, when the callback is needed,
    479            the HAL_FLASH_OperationErrorCallback could be implemented in the user file
    480             */ 
    481          }
   \                     HAL_FLASH_OperationErrorCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    482          
    483          /**
    484            * @}
    485            */
    486          
    487          /** @defgroup FLASH_Exported_Functions_Group2 Peripheral Control functions 
    488           *  @brief   management functions 
    489           *
    490          @verbatim   
    491           ===============================================================================
    492                                ##### Peripheral Control functions #####
    493           ===============================================================================  
    494              [..]
    495              This subsection provides a set of functions allowing to control the FLASH 
    496              memory operations.
    497          
    498          @endverbatim
    499            * @{
    500            */
    501          
    502          /**
    503            * @brief  Unlock the FLASH control register access
    504            * @retval HAL Status
    505            */

   \                                 In section .text, align 2, keep-with-next
    506          HAL_StatusTypeDef HAL_FLASH_Unlock(void)
    507          {
    508            if((FLASH->CR & FLASH_CR_LOCK) != RESET)
   \                     HAL_FLASH_Unlock: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable10_2  ;; 0x40023c04
   \   00000002   0x68C1             LDR      R1,[R0, #+12]
   \   00000004   0x2900             CMP      R1,#+0
   \   00000006   0xD505             BPL.N    ??HAL_FLASH_Unlock_0
    509            {
    510              /* Authorize the FLASH Registers access */
    511              FLASH->KEYR = FLASH_KEY1;
   \   00000008   0x....             LDR.N    R1,??DataTable10_3  ;; 0x45670123
   \   0000000A   0x6001             STR      R1,[R0, #+0]
    512              FLASH->KEYR = FLASH_KEY2;
   \   0000000C   0x....             LDR.N    R1,??DataTable10_4  ;; 0xcdef89ab
   \   0000000E   0x6001             STR      R1,[R0, #+0]
    513            }
    514            else
    515            {
    516              return HAL_ERROR;
    517            }
    518            
    519            return HAL_OK; 
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0x4770             BX       LR
   \                     ??HAL_FLASH_Unlock_0: (+1)
   \   00000014   0x2001             MOVS     R0,#+1
   \   00000016   0x4770             BX       LR               ;; return
    520          }
    521          
    522          /**
    523            * @brief  Locks the FLASH control register access
    524            * @retval HAL Status
    525            */

   \                                 In section .text, align 2, keep-with-next
    526          HAL_StatusTypeDef HAL_FLASH_Lock(void)
    527          {
    528            /* Set the LOCK Bit to lock the FLASH Registers access */
    529            FLASH->CR |= FLASH_CR_LOCK;
   \                     HAL_FLASH_Lock: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable10_5  ;; 0x40023c10
   \   00000002   0x6801             LDR      R1,[R0, #+0]
   \   00000004   0xF041 0x4100      ORR      R1,R1,#0x80000000
   \   00000008   0x6001             STR      R1,[R0, #+0]
    530            
    531            return HAL_OK;  
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x4770             BX       LR               ;; return
    532          }
    533          
    534          /**
    535            * @brief  Unlock the FLASH Option Control Registers access.
    536            * @retval HAL Status
    537            */

   \                                 In section .text, align 2, keep-with-next
    538          HAL_StatusTypeDef HAL_FLASH_OB_Unlock(void)
    539          {
    540            if((FLASH->OPTCR & FLASH_OPTCR_OPTLOCK) != RESET)
   \                     HAL_FLASH_OB_Unlock: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable10_6  ;; 0x40023c08
   \   00000002   0x68C1             LDR      R1,[R0, #+12]
   \   00000004   0x07C9             LSLS     R1,R1,#+31
   \   00000006   0xD505             BPL.N    ??HAL_FLASH_OB_Unlock_0
    541            {
    542              /* Authorizes the Option Byte register programming */
    543              FLASH->OPTKEYR = FLASH_OPT_KEY1;
   \   00000008   0x....             LDR.N    R1,??DataTable10_7  ;; 0x8192a3b
   \   0000000A   0x6001             STR      R1,[R0, #+0]
    544              FLASH->OPTKEYR = FLASH_OPT_KEY2;
   \   0000000C   0x....             LDR.N    R1,??DataTable10_8  ;; 0x4c5d6e7f
   \   0000000E   0x6001             STR      R1,[R0, #+0]
    545            }
    546            else
    547            {
    548              return HAL_ERROR;
    549            }  
    550            
    551            return HAL_OK;  
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0x4770             BX       LR
   \                     ??HAL_FLASH_OB_Unlock_0: (+1)
   \   00000014   0x2001             MOVS     R0,#+1
   \   00000016   0x4770             BX       LR               ;; return
    552          }
    553          
    554          /**
    555            * @brief  Lock the FLASH Option Control Registers access.
    556            * @retval HAL Status 
    557            */

   \                                 In section .text, align 2, keep-with-next
    558          HAL_StatusTypeDef HAL_FLASH_OB_Lock(void)
    559          {
    560            /* Set the OPTLOCK Bit to lock the FLASH Option Byte Registers access */
    561            FLASH->OPTCR |= FLASH_OPTCR_OPTLOCK;
   \                     HAL_FLASH_OB_Lock: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable10_9  ;; 0x40023c14
   \   00000002   0x6801             LDR      R1,[R0, #+0]
   \   00000004   0xF041 0x0101      ORR      R1,R1,#0x1
   \   00000008   0x6001             STR      R1,[R0, #+0]
    562            
    563            return HAL_OK;  
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x4770             BX       LR               ;; return
    564          }
    565          
    566          /**
    567            * @brief  Launch the option byte loading.
    568            * @retval HAL Status
    569            */

   \                                 In section .text, align 2, keep-with-next
    570          HAL_StatusTypeDef HAL_FLASH_OB_Launch(void)
    571          {
   \                     HAL_FLASH_OB_Launch: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
    572            /* Set the OPTSTRT bit in OPTCR register */
    573            FLASH->OPTCR |= FLASH_OPTCR_OPTSTRT;
   \   00000002   0x....             LDR.N    R4,??DataTable10_1  ;; 0x40023c0c
    574          
    575            /* Wait for last operation to be completed */
    576            return(FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE)); 
   \   00000004   0x....             LDR.N    R1,??DataTable10
   \   00000006   0xF24C 0x3651      MOVW     R6,#+50001
   \   0000000A   0x68A0             LDR      R0,[R4, #+8]
   \   0000000C   0xF040 0x0002      ORR      R0,R0,#0x2
   \   00000010   0x60A0             STR      R0,[R4, #+8]
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0x6188             STR      R0,[R1, #+24]
   \   00000016   0x.... 0x....      BL       HAL_GetTick
   \   0000001A   0x4605             MOV      R5,R0
   \                     ??HAL_FLASH_OB_Launch_0: (+1)
   \   0000001C   0x6820             LDR      R0,[R4, #+0]
   \   0000001E   0x03C0             LSLS     R0,R0,#+15
   \   00000020   0xD506             BPL.N    ??HAL_FLASH_OB_Launch_1
   \   00000022   0x.... 0x....      BL       HAL_GetTick
   \   00000026   0x1B40             SUBS     R0,R0,R5
   \   00000028   0x42B0             CMP      R0,R6
   \   0000002A   0xD3F7             BCC.N    ??HAL_FLASH_OB_Launch_0
   \   0000002C   0x2003             MOVS     R0,#+3
   \   0000002E   0xBD70             POP      {R4-R6,PC}
   \                     ??HAL_FLASH_OB_Launch_1: (+1)
   \   00000030   0x6820             LDR      R0,[R4, #+0]
   \   00000032   0xF010 0x0FF2      TST      R0,#0xF2
   \   00000036   0xD003             BEQ.N    ??HAL_FLASH_OB_Launch_2
   \   00000038   0x.... 0x....      BL       FLASH_SetErrorCode
   \   0000003C   0x2001             MOVS     R0,#+1
   \   0000003E   0xBD70             POP      {R4-R6,PC}
   \                     ??HAL_FLASH_OB_Launch_2: (+1)
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0xBD70             POP      {R4-R6,PC}       ;; return
    577          }
    578          
    579          /**
    580            * @}
    581            */
    582          
    583          /** @defgroup FLASH_Exported_Functions_Group3 Peripheral State and Errors functions 
    584           *  @brief   Peripheral Errors functions 
    585           *
    586          @verbatim   
    587           ===============================================================================
    588                          ##### Peripheral Errors functions #####
    589           ===============================================================================  
    590              [..]
    591              This subsection permits to get in run-time Errors of the FLASH peripheral.
    592          
    593          @endverbatim
    594            * @{
    595            */
    596          
    597          /**
    598            * @brief  Get the specific FLASH error flag.
    599            * @retval FLASH_ErrorCode: The returned value can be:
    600            *            @arg FLASH_ERROR_ERS: FLASH Erasing Sequence error flag 
    601            *            @arg FLASH_ERROR_PGP: FLASH Programming Parallelism error flag  
    602            *            @arg FLASH_ERROR_PGA: FLASH Programming Alignment error flag
    603            *            @arg FLASH_ERROR_WRP: FLASH Write protected error flag
    604            *            @arg FLASH_ERROR_OPERATION: FLASH operation Error flag 
    605            */

   \                                 In section .text, align 2, keep-with-next
    606          uint32_t HAL_FLASH_GetError(void)
    607          { 
    608             return pFlash.ErrorCode;
   \                     HAL_FLASH_GetError: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable10
   \   00000002   0x6980             LDR      R0,[R0, #+24]
   \   00000004   0x4770             BX       LR               ;; return
    609          }  
    610            
    611          /**
    612            * @}
    613            */    
    614          
    615          /**
    616            * @brief  Wait for a FLASH operation to complete.
    617            * @param  Timeout: maximum flash operationtimeout
    618            * @retval HAL Status
    619            */

   \                                 In section .text, align 2, keep-with-next
    620          HAL_StatusTypeDef FLASH_WaitForLastOperation(uint32_t Timeout)
    621          { 
   \                     FLASH_WaitForLastOperation: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
    622            uint32_t tickstart = 0;
    623            
    624            /* Clear Error Code */
    625            pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x....             LDR.N    R1,??DataTable10
   \   00000008   0x....             LDR.N    R6,??DataTable10_1  ;; 0x40023c0c
   \   0000000A   0x6188             STR      R0,[R1, #+24]
    626            
    627            /* Wait for the FLASH operation to complete by polling on BUSY flag to be reset.
    628               Even if the FLASH operation fails, the BUSY flag will be reset and an error
    629               flag will be set */
    630            /* Get tick */
    631            tickstart = HAL_GetTick();
   \   0000000C   0x.... 0x....      BL       HAL_GetTick
   \   00000010   0x4605             MOV      R5,R0
    632          
    633            while(__HAL_FLASH_GET_FLAG(FLASH_FLAG_BSY) != RESET) 
   \                     ??FLASH_WaitForLastOperation_0: (+1)
   \   00000012   0x6830             LDR      R0,[R6, #+0]
   \   00000014   0x03C0             LSLS     R0,R0,#+15
   \   00000016   0xD50A             BPL.N    ??FLASH_WaitForLastOperation_1
    634            { 
    635              if(Timeout != HAL_MAX_DELAY)
   \   00000018   0xF114 0x0F01      CMN      R4,#+1
   \   0000001C   0xD0F9             BEQ.N    ??FLASH_WaitForLastOperation_0
    636              {
    637                if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
   \   0000001E   0xB124             CBZ.N    R4,??FLASH_WaitForLastOperation_2
   \   00000020   0x.... 0x....      BL       HAL_GetTick
   \   00000024   0x1B40             SUBS     R0,R0,R5
   \   00000026   0x4284             CMP      R4,R0
   \   00000028   0xD2F3             BCS.N    ??FLASH_WaitForLastOperation_0
    638                {
    639                  return HAL_TIMEOUT;
   \                     ??FLASH_WaitForLastOperation_2: (+1)
   \   0000002A   0x2003             MOVS     R0,#+3
   \   0000002C   0xBD70             POP      {R4-R6,PC}
    640                }
    641              } 
    642            }
    643            
    644            if(__HAL_FLASH_GET_FLAG((FLASH_FLAG_OPERR | FLASH_FLAG_WRPERR | FLASH_FLAG_PGAERR | \
    645                                     FLASH_FLAG_PGPERR | FLASH_FLAG_ERSERR )) != RESET)
   \                     ??FLASH_WaitForLastOperation_1: (+1)
   \   0000002E   0x6830             LDR      R0,[R6, #+0]
   \   00000030   0xF010 0x0FF2      TST      R0,#0xF2
   \   00000034   0xD003             BEQ.N    ??FLASH_WaitForLastOperation_3
    646            {
    647              /*Save the error code*/
    648              FLASH_SetErrorCode();
   \   00000036   0x.... 0x....      BL       FLASH_SetErrorCode
    649              return HAL_ERROR;
   \   0000003A   0x2001             MOVS     R0,#+1
   \   0000003C   0xBD70             POP      {R4-R6,PC}
    650            }
    651          
    652            /* If there is an error flag set */
    653            return HAL_OK;
   \                     ??FLASH_WaitForLastOperation_3: (+1)
   \   0000003E   0x2000             MOVS     R0,#+0
   \   00000040   0xBD70             POP      {R4-R6,PC}       ;; return
    654            
    655          }  
    656          
    657          /**
    658            * @brief  Program a double word (64-bit) at a specified address.
    659            * @note   This function must be used when the device voltage range is from
    660            *         2.7V to 3.6V and an External Vpp is present.
    661            *
    662            * @note   If an erase and a program operations are requested simultaneously,    
    663            *         the erase operation is performed before the program one.
    664            *  
    665            * @param  Address: specifies the address to be programmed.
    666            * @param  Data: specifies the data to be programmed.
    667            * @retval None
    668            */
    669          static void FLASH_Program_DoubleWord(uint32_t Address, uint64_t Data)
    670          {
    671            /* Check the parameters */
    672            assert_param(IS_FLASH_ADDRESS(Address));
    673            
    674            /* If the previous operation is completed, proceed to program the new data */
    675            FLASH->CR &= CR_PSIZE_MASK;
    676            FLASH->CR |= FLASH_PSIZE_DOUBLE_WORD;
    677            FLASH->CR |= FLASH_CR_PG;
    678            
    679            *(__IO uint64_t*)Address = Data;
    680            
    681            /* Data synchronous Barrier (DSB) Just after the write operation
    682               This will force the CPU to respect the sequence of instruction (no optimization).*/
    683            __DSB();
    684          }
    685          
    686          
    687          /**
    688            * @brief  Program word (32-bit) at a specified address.
    689            * @note   This function must be used when the device voltage range is from
    690            *         2.7V to 3.6V.
    691            *
    692            * @note   If an erase and a program operations are requested simultaneously,    
    693            *         the erase operation is performed before the program one.
    694            *  
    695            * @param  Address: specifies the address to be programmed.
    696            * @param  Data: specifies the data to be programmed.
    697            * @retval None
    698            */
    699          static void FLASH_Program_Word(uint32_t Address, uint32_t Data)
    700          {
    701            /* Check the parameters */
    702            assert_param(IS_FLASH_ADDRESS(Address));
    703            
    704            /* If the previous operation is completed, proceed to program the new data */
    705            FLASH->CR &= CR_PSIZE_MASK;
    706            FLASH->CR |= FLASH_PSIZE_WORD;
    707            FLASH->CR |= FLASH_CR_PG;
    708          
    709            *(__IO uint32_t*)Address = Data;
    710            
    711            /* Data synchronous Barrier (DSB) Just after the write operation
    712               This will force the CPU to respect the sequence of instruction (no optimization).*/
    713            __DSB();
    714          }
    715          
    716          /**
    717            * @brief  Program a half-word (16-bit) at a specified address.
    718            * @note   This function must be used when the device voltage range is from
    719            *         2.7V to 3.6V.
    720            *
    721            * @note   If an erase and a program operations are requested simultaneously,    
    722            *         the erase operation is performed before the program one.
    723            *  
    724            * @param  Address: specifies the address to be programmed.
    725            * @param  Data: specifies the data to be programmed.
    726            * @retval None
    727            */
    728          static void FLASH_Program_HalfWord(uint32_t Address, uint16_t Data)
    729          {
    730            /* Check the parameters */
    731            assert_param(IS_FLASH_ADDRESS(Address));
    732            
    733            /* If the previous operation is completed, proceed to program the new data */
    734            FLASH->CR &= CR_PSIZE_MASK;
    735            FLASH->CR |= FLASH_PSIZE_HALF_WORD;
    736            FLASH->CR |= FLASH_CR_PG;
    737          
    738            *(__IO uint16_t*)Address = Data;
    739          
    740            /* Data synchronous Barrier (DSB) Just after the write operation
    741               This will force the CPU to respect the sequence of instruction (no optimization).*/
    742            __DSB();
    743            
    744          }
    745          
    746          /**
    747            * @brief  Program byte (8-bit) at a specified address.
    748            * @note   This function must be used when the device voltage range is from
    749            *         2.7V to 3.6V.
    750            *
    751            * @note   If an erase and a program operations are requested simultaneously,    
    752            *         the erase operation is performed before the program one.
    753            *  
    754            * @param  Address: specifies the address to be programmed.
    755            * @param  Data: specifies the data to be programmed.
    756            * @retval None
    757            */
    758          static void FLASH_Program_Byte(uint32_t Address, uint8_t Data)
    759          {
    760            /* Check the parameters */
    761            assert_param(IS_FLASH_ADDRESS(Address));
    762            
    763            /* If the previous operation is completed, proceed to program the new data */
    764            FLASH->CR &= CR_PSIZE_MASK;
    765            FLASH->CR |= FLASH_PSIZE_BYTE;
    766            FLASH->CR |= FLASH_CR_PG;
    767          
    768            *(__IO uint8_t*)Address = Data;
    769          
    770            /* Data synchronous Barrier (DSB) Just after the write operation
    771               This will force the CPU to respect the sequence of instruction (no optimization).*/
    772            __DSB();
    773          }
    774          
    775          /**
    776            * @brief  Set the specific FLASH error flag.
    777            * @retval None
    778            */

   \                                 In section .text, align 2, keep-with-next
    779          static void FLASH_SetErrorCode(void)
    780          { 
    781            if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_WRPERR) != RESET)
   \                     FLASH_SetErrorCode: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable10_1  ;; 0x40023c0c
   \   00000002   0x....             LDR.N    R0,??DataTable10
   \   00000004   0x680A             LDR      R2,[R1, #+0]
   \   00000006   0x06D2             LSLS     R2,R2,#+27
   \   00000008   0xD503             BPL.N    ??FLASH_SetErrorCode_0
    782            {
    783             pFlash.ErrorCode |= HAL_FLASH_ERROR_WRP;
   \   0000000A   0x6982             LDR      R2,[R0, #+24]
   \   0000000C   0xF042 0x0210      ORR      R2,R2,#0x10
   \   00000010   0x6182             STR      R2,[R0, #+24]
    784            }
    785            
    786            if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_PGAERR) != RESET)
   \                     ??FLASH_SetErrorCode_0: (+1)
   \   00000012   0x680A             LDR      R2,[R1, #+0]
   \   00000014   0x0692             LSLS     R2,R2,#+26
   \   00000016   0xD503             BPL.N    ??FLASH_SetErrorCode_1
    787            {
    788             pFlash.ErrorCode |= HAL_FLASH_ERROR_PGA;
   \   00000018   0x6982             LDR      R2,[R0, #+24]
   \   0000001A   0xF042 0x0208      ORR      R2,R2,#0x8
   \   0000001E   0x6182             STR      R2,[R0, #+24]
    789            }
    790            
    791            if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_PGPERR) != RESET)
   \                     ??FLASH_SetErrorCode_1: (+1)
   \   00000020   0x680A             LDR      R2,[R1, #+0]
   \   00000022   0x0652             LSLS     R2,R2,#+25
   \   00000024   0xD503             BPL.N    ??FLASH_SetErrorCode_2
    792            {
    793              pFlash.ErrorCode |= HAL_FLASH_ERROR_PGP;
   \   00000026   0x6982             LDR      R2,[R0, #+24]
   \   00000028   0xF042 0x0204      ORR      R2,R2,#0x4
   \   0000002C   0x6182             STR      R2,[R0, #+24]
    794            }
    795            
    796            if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_ERSERR) != RESET)
   \                     ??FLASH_SetErrorCode_2: (+1)
   \   0000002E   0x680A             LDR      R2,[R1, #+0]
   \   00000030   0x0612             LSLS     R2,R2,#+24
   \   00000032   0xD503             BPL.N    ??FLASH_SetErrorCode_3
    797            {
    798              pFlash.ErrorCode |= HAL_FLASH_ERROR_ERS;
   \   00000034   0x6982             LDR      R2,[R0, #+24]
   \   00000036   0xF042 0x0202      ORR      R2,R2,#0x2
   \   0000003A   0x6182             STR      R2,[R0, #+24]
    799            }
    800            
    801            if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_OPERR) != RESET)
   \                     ??FLASH_SetErrorCode_3: (+1)
   \   0000003C   0x6809             LDR      R1,[R1, #+0]
   \   0000003E   0x0789             LSLS     R1,R1,#+30
   \   00000040   0xD503             BPL.N    ??FLASH_SetErrorCode_4
    802            {
    803              pFlash.ErrorCode |= HAL_FLASH_ERROR_OPERATION;
   \   00000042   0x6981             LDR      R1,[R0, #+24]
   \   00000044   0xF041 0x0120      ORR      R1,R1,#0x20
   \   00000048   0x6181             STR      R1,[R0, #+24]
    804            }
    805          }
   \                     ??FLASH_SetErrorCode_4: (+1)
   \   0000004A   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10:
   \   00000000   0x........         DC32     pFlash

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_1:
   \   00000000   0x40023C0C         DC32     0x40023c0c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_2:
   \   00000000   0x40023C04         DC32     0x40023c04

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_3:
   \   00000000   0x45670123         DC32     0x45670123

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_4:
   \   00000000   0xCDEF89AB         DC32     0xcdef89ab

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_5:
   \   00000000   0x40023C10         DC32     0x40023c10

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_6:
   \   00000000   0x40023C08         DC32     0x40023c08

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_7:
   \   00000000   0x08192A3B         DC32     0x8192a3b

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_8:
   \   00000000   0x4C5D6E7F         DC32     0x4c5d6e7f

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_9:
   \   00000000   0x40023C14         DC32     0x40023c14
    806          
    807          /**
    808            * @}
    809            */
    810          
    811          #endif /* HAL_FLASH_MODULE_ENABLED */
    812          
    813          /**
    814            * @}
    815            */
    816          
    817          /**
    818            * @}
    819            */
    820          
    821          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   FLASH_SetErrorCode
      16   FLASH_WaitForLastOperation
        16   -> FLASH_SetErrorCode
        16   -> HAL_GetTick
       0   HAL_FLASH_EndOfOperationCallback
       0   HAL_FLASH_GetError
      16   HAL_FLASH_IRQHandler
        16   -> FLASH_Erase_Sector
        16   -> FLASH_SetErrorCode
        16   -> HAL_FLASH_EndOfOperationCallback
        16   -> HAL_FLASH_OperationErrorCallback
       0   HAL_FLASH_Lock
      16   HAL_FLASH_OB_Launch
        16   -> FLASH_SetErrorCode
        16   -> HAL_GetTick
       0   HAL_FLASH_OB_Lock
       0   HAL_FLASH_OB_Unlock
       0   HAL_FLASH_OperationErrorCallback
      40   HAL_FLASH_Program
        40   -> FLASH_SetErrorCode
        40   -> HAL_GetTick
      12   HAL_FLASH_Program_IT
       0   HAL_FLASH_Unlock


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable10
       4  ??DataTable10_1
       4  ??DataTable10_2
       4  ??DataTable10_3
       4  ??DataTable10_4
       4  ??DataTable10_5
       4  ??DataTable10_6
       4  ??DataTable10_7
       4  ??DataTable10_8
       4  ??DataTable10_9
      76  FLASH_SetErrorCode
      66  FLASH_WaitForLastOperation
       2  HAL_FLASH_EndOfOperationCallback
       6  HAL_FLASH_GetError
     214  HAL_FLASH_IRQHandler
      14  HAL_FLASH_Lock
      68  HAL_FLASH_OB_Launch
      14  HAL_FLASH_OB_Lock
      24  HAL_FLASH_OB_Unlock
       2  HAL_FLASH_OperationErrorCallback
     284  HAL_FLASH_Program
     176  HAL_FLASH_Program_IT
      24  HAL_FLASH_Unlock
      28  pFlash

 
    28 bytes in section .bss
 1 010 bytes in section .text
 
 1 010 bytes of CODE memory
    28 bytes of DATA memory

Errors: none
Warnings: none
