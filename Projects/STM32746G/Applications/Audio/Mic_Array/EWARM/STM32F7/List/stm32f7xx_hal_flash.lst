###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.2.10312/W32 for ARM       20/Dec/2015  03:50:30
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_flash.c
#    Command line =  
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_flash.c
#        -D USE_HAL_DRIVER -D STM32F746xx -D USE_STM32746G_DISCO -D
#        USE_IOEXPANDER -D USE_USB_FS -lC
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
#        -lA
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
#        -o
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj
#        --debug --endian=little --cpu=Cortex-M7 -e --fpu=VFPv5_sp
#        --dlib_config "D:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Full.h" -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\Inc\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\CMSIS\Device\ST\STM32F7xx\Include\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\STM32F7xx_HAL_Driver\Inc\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\STM32746G-Discovery\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\Components\Common\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Log\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Fonts\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\CPU\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_Device_Library\Core\Inc\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Core\Inc\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Class\MSC\Inc\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\drivers\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_Audio\Addons\PDM\
#        -Ohz --use_c++_inline --require_prototypes -I "D:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.3\arm\CMSIS\Include\" -D
#        ARM_MATH_CM7
#    List file    =  
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List\stm32f7xx_hal_flash.lst
#    Object file  =  
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj\stm32f7xx_hal_flash.o
#
###############################################################################

H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_flash.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f7xx_hal_flash.c
      4            * @author  MCD Application Team
      5            * @version V1.0.1
      6            * @date    25-June-2015
      7            * @brief   FLASH HAL module driver.
      8            *          This file provides firmware functions to manage the following 
      9            *          functionalities of the internal FLASH memory:
     10            *           + Program operations functions
     11            *           + Memory Control functions 
     12            *           + Peripheral Errors functions
     13            *         
     14            @verbatim
     15            ==============================================================================
     16                                  ##### FLASH peripheral features #####
     17            ==============================================================================
     18                     
     19            [..] The Flash memory interface manages CPU AHB I-Code and D-Code accesses 
     20                 to the Flash memory. It implements the erase and program Flash memory operations 
     21                 and the read and write protection mechanisms.
     22                
     23            [..] The Flash memory interface accelerates code execution with a system of instruction
     24                 prefetch and cache lines. 
     25          
     26            [..] The FLASH main features are:
     27                (+) Flash memory read operations
     28                (+) Flash memory program/erase operations
     29                (+) Read / write protections
     30                (+) Prefetch on I-Code
     31                (+) 64 cache lines of 128 bits on I-Code
     32                (+) 8 cache lines of 128 bits on D-Code
     33                
     34                               ##### How to use this driver #####
     35            ==============================================================================
     36              [..]                             
     37                This driver provides functions and macros to configure and program the FLASH 
     38                memory of all STM32F7xx devices.
     39              
     40                (#) FLASH Memory IO Programming functions: 
     41                     (++) Lock and Unlock the FLASH interface using HAL_FLASH_Unlock() and 
     42                          HAL_FLASH_Lock() functions
     43                     (++) Program functions: byte, half word, word and double word
     44                     (++) There Two modes of programming :
     45                      (+++) Polling mode using HAL_FLASH_Program() function
     46                      (+++) Interrupt mode using HAL_FLASH_Program_IT() function
     47              
     48                (#) Interrupts and flags management functions : 
     49                     (++) Handle FLASH interrupts by calling HAL_FLASH_IRQHandler()
     50                     (++) Wait for last FLASH operation according to its status
     51                     (++) Get error flag status by calling HAL_SetErrorCode()          
     52              [..] 
     53                In addition to these functions, this driver includes a set of macros allowing
     54                to handle the following operations:
     55                 (+) Set the latency
     56                 (+) Enable/Disable the prefetch buffer
     57                 (+) Enable/Disable the Instruction cache and the Data cache
     58                 (+) Reset the Instruction cache and the Data cache
     59                 (+) Enable/Disable the FLASH interrupts
     60                 (+) Monitor the FLASH flags status
     61              [..]	   
     62          	(@) For any Flash memory program operation (erase or program), the CPU clock frequency
     63                  (HCLK) must be at least 1MHz. 
     64          	(@) The contents of the Flash memory are not guaranteed if a device reset occurs during 
     65          	    a Flash memory operation.
     66              (@) Any attempt to read the Flash memory while it is being written or erased, causes the 
     67          	    bus to stall. Read operations are processed correctly once the program operation has 
     68          		completed. This means that code or data fetches cannot be performed while a write/erase 
     69          		operation is ongoing.
     70                    
     71            @endverbatim
     72            ******************************************************************************
     73            * @attention
     74            *
     75            * <h2><center>&copy; COPYRIGHT(c) 2015 STMicroelectronics</center></h2>
     76            *
     77            * Redistribution and use in source and binary forms, with or without modification,
     78            * are permitted provided that the following conditions are met:
     79            *   1. Redistributions of source code must retain the above copyright notice,
     80            *      this list of conditions and the following disclaimer.
     81            *   2. Redistributions in binary form must reproduce the above copyright notice,
     82            *      this list of conditions and the following disclaimer in the documentation
     83            *      and/or other materials provided with the distribution.
     84            *   3. Neither the name of STMicroelectronics nor the names of its contributors
     85            *      may be used to endorse or promote products derived from this software
     86            *      without specific prior written permission.
     87            *
     88            * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
     89            * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     90            * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     91            * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
     92            * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
     93            * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
     94            * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
     95            * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
     96            * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
     97            * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     98            *
     99            ******************************************************************************
    100            */ 
    101          
    102          /* Includes ------------------------------------------------------------------*/
    103          #include "stm32f7xx_hal.h"
    104          
    105          /** @addtogroup STM32F7xx_HAL_Driver
    106            * @{
    107            */
    108          
    109          /** @defgroup FLASH FLASH
    110            * @brief FLASH HAL module driver
    111            * @{
    112            */
    113          
    114          #ifdef HAL_FLASH_MODULE_ENABLED
    115          
    116          /* Private typedef -----------------------------------------------------------*/
    117          /* Private define ------------------------------------------------------------*/
    118          /** @addtogroup FLASH_Private_Constants
    119            * @{
    120            */
    121          #define SECTOR_MASK               ((uint32_t)0xFFFFFF07)
    122          #define FLASH_TIMEOUT_VALUE       ((uint32_t)50000)/* 50 s */
    123          /**
    124            * @}
    125            */         
    126          /* Private macro -------------------------------------------------------------*/
    127          /* Private variables ---------------------------------------------------------*/
    128          /** @addtogroup FLASH_Private_Variables
    129            * @{
    130            */
    131          /* Variable used for Erase sectors under interruption */

   \                                 In section .bss, align 4
    132          FLASH_ProcessTypeDef pFlash;
   \                     pFlash:
   \   00000000                      DS8 28
    133          /**
    134            * @}
    135            */
    136          
    137          /* Private function prototypes -----------------------------------------------*/
    138          /** @addtogroup FLASH_Private_Functions
    139            * @{
    140            */
    141          /* Program operations */
    142          static void   FLASH_Program_DoubleWord(uint32_t Address, uint64_t Data);
    143          static void   FLASH_Program_Word(uint32_t Address, uint32_t Data);
    144          static void   FLASH_Program_HalfWord(uint32_t Address, uint16_t Data);
    145          static void   FLASH_Program_Byte(uint32_t Address, uint8_t Data);
    146          static void   FLASH_SetErrorCode(void);
    147          
    148          HAL_StatusTypeDef FLASH_WaitForLastOperation(uint32_t Timeout);
    149          /**
    150            * @}
    151            */
    152          
    153          /* Exported functions --------------------------------------------------------*/
    154          /** @defgroup FLASH_Exported_Functions FLASH Exported Functions
    155            * @{
    156            */
    157            
    158          /** @defgroup FLASH_Exported_Functions_Group1 Programming operation functions 
    159           *  @brief   Programming operation functions 
    160           *
    161          @verbatim   
    162           ===============================================================================
    163                            ##### Programming operation functions #####
    164           ===============================================================================  
    165              [..]
    166              This subsection provides a set of functions allowing to manage the FLASH 
    167              program operations.
    168          
    169          @endverbatim
    170            * @{
    171            */
    172          
    173          /**
    174            * @brief  Program byte, halfword, word or double word at a specified address
    175            * @param  TypeProgram:  Indicate the way to program at a specified address.
    176            *                           This parameter can be a value of @ref FLASH_Type_Program
    177            * @param  Address:  specifies the address to be programmed.
    178            * @param  Data: specifies the data to be programmed
    179            * 
    180            * @retval HAL_StatusTypeDef HAL Status
    181            */

   \                                 In section .text, align 4, keep-with-next
    182          HAL_StatusTypeDef HAL_FLASH_Program(uint32_t TypeProgram, uint32_t Address, uint64_t Data)
    183          {
   \                     HAL_FLASH_Program: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
    184            HAL_StatusTypeDef status = HAL_ERROR;
    185            
    186            /* Process Locked */
    187            __HAL_LOCK(&pFlash);
   \   00000004   0x....             LDR.N    R7,??DataTable12
   \   00000006   0x4606             MOV      R6,R0
   \   00000008   0x4689             MOV      R9,R1
   \   0000000A   0x4614             MOV      R4,R2
   \   0000000C   0x7D38             LDRB     R0,[R7, #+20]
   \   0000000E   0x461D             MOV      R5,R3
   \   00000010   0x2801             CMP      R0,#+1
   \   00000012   0xBF08             IT       EQ 
   \   00000014   0x2002             MOVEQ    R0,#+2
   \   00000016   0xD02B             BEQ.N    ??HAL_FLASH_Program_1
   \   00000018   0x2001             MOVS     R0,#+1
    188          
    189            /* Check the parameters */
    190            assert_param(IS_FLASH_TYPEPROGRAM(TypeProgram));
    191          
    192            /* Wait for last operation to be completed */
    193            status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
   \   0000001A   0xF24C 0x3850      MOVW     R8,#+50000
   \   0000001E   0x7538             STRB     R0,[R7, #+20]
   \   00000020   0x4640             MOV      R0,R8
   \   00000022   0x.... 0x....      BL       FLASH_WaitForLastOperation
    194            
    195            if(status == HAL_OK)
   \   00000026   0xBB08             CBNZ.N   R0,??HAL_FLASH_Program_2
    196            {
    197              switch(TypeProgram)
   \   00000028   0x2E03             CMP      R6,#+3
   \   0000002A   0xD817             BHI.N    ??HAL_FLASH_Program_3
   \   0000002C   0xE8DF 0xF006      TBB      [PC, R6]
   \                     ??HAL_FLASH_Program_0:
   \   00000030   0x02 0x07          DC8      0x2,0x7,0xC,0x11
   \              0x0C 0x11    
    198              {
    199                case FLASH_TYPEPROGRAM_BYTE :
    200                {
    201                  /*Program byte (8-bit) at a specified address.*/
    202                  FLASH_Program_Byte(Address, (uint8_t) Data);
   \                     ??HAL_FLASH_Program_4: (+1)
   \   00000034   0xB2E1             UXTB     R1,R4
   \   00000036   0x4648             MOV      R0,R9
   \   00000038   0x.... 0x....      BL       FLASH_Program_Byte
    203                  break;
   \   0000003C   0xE00E             B.N      ??HAL_FLASH_Program_3
    204                }
    205                
    206                case FLASH_TYPEPROGRAM_HALFWORD :
    207                {
    208                  /*Program halfword (16-bit) at a specified address.*/
    209                  FLASH_Program_HalfWord(Address, (uint16_t) Data);
   \                     ??HAL_FLASH_Program_5: (+1)
   \   0000003E   0xB2A1             UXTH     R1,R4
   \   00000040   0x4648             MOV      R0,R9
   \   00000042   0x.... 0x....      BL       FLASH_Program_HalfWord
    210                  break;
   \   00000046   0xE009             B.N      ??HAL_FLASH_Program_3
    211                }
    212                
    213                case FLASH_TYPEPROGRAM_WORD :
    214                {
    215                  /*Program word (32-bit) at a specified address.*/
    216                  FLASH_Program_Word(Address, (uint32_t) Data);
   \                     ??HAL_FLASH_Program_6: (+1)
   \   00000048   0x4621             MOV      R1,R4
   \   0000004A   0x4648             MOV      R0,R9
   \   0000004C   0x.... 0x....      BL       FLASH_Program_Word
    217                  break;
   \   00000050   0xE004             B.N      ??HAL_FLASH_Program_3
    218                }
    219                
    220                case FLASH_TYPEPROGRAM_DOUBLEWORD :
    221                {
    222                  /*Program double word (64-bit) at a specified address.*/
    223                  FLASH_Program_DoubleWord(Address, Data);
   \                     ??HAL_FLASH_Program_7: (+1)
   \   00000052   0x4622             MOV      R2,R4
   \   00000054   0x462B             MOV      R3,R5
   \   00000056   0x4648             MOV      R0,R9
   \   00000058   0x.... 0x....      BL       FLASH_Program_DoubleWord
    224                  break;
    225                }
    226                default :
    227                  break;
    228              }
    229              /* Wait for last operation to be completed */
    230              status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
   \                     ??HAL_FLASH_Program_3: (+1)
   \   0000005C   0x4640             MOV      R0,R8
   \   0000005E   0x.... 0x....      BL       FLASH_WaitForLastOperation
    231              
    232              /* If the program operation is completed, disable the PG Bit */
    233              FLASH->CR &= (~FLASH_CR_PG);
   \   00000062   0x....             LDR.N    R1,??DataTable12_1  ;; 0x40023c10
   \   00000064   0x680A             LDR      R2,[R1, #+0]
   \   00000066   0x0852             LSRS     R2,R2,#+1
   \   00000068   0x0052             LSLS     R2,R2,#+1
   \   0000006A   0x600A             STR      R2,[R1, #+0]
    234            }
    235          
    236            /* Process Unlocked */
    237            __HAL_UNLOCK(&pFlash);
   \                     ??HAL_FLASH_Program_2: (+1)
   \   0000006C   0x2100             MOVS     R1,#+0
   \   0000006E   0x7539             STRB     R1,[R7, #+20]
    238          
    239            return status;
   \                     ??HAL_FLASH_Program_1: (+1)
   \   00000070   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    240          }
    241          
    242          /**
    243            * @brief   Program byte, halfword, word or double word at a specified address  with interrupt enabled.
    244            * @param  TypeProgram:  Indicate the way to program at a specified address.
    245            *                           This parameter can be a value of @ref FLASH_Type_Program
    246            * @param  Address:  specifies the address to be programmed.
    247            * @param  Data: specifies the data to be programmed
    248            * 
    249            * @retval HAL Status
    250            */

   \                                 In section .text, align 4, keep-with-next
    251          HAL_StatusTypeDef HAL_FLASH_Program_IT(uint32_t TypeProgram, uint32_t Address, uint64_t Data)
    252          {
   \                     HAL_FLASH_Program_IT: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x4608             MOV      R0,R1
    253            HAL_StatusTypeDef status = HAL_OK;
    254            
    255            /* Process Locked */
    256            __HAL_LOCK(&pFlash);
   \   00000006   0x....             LDR.N    R1,??DataTable12
   \   00000008   0x7D0D             LDRB     R5,[R1, #+20]
   \   0000000A   0x2D01             CMP      R5,#+1
   \   0000000C   0xD101             BNE.N    ??HAL_FLASH_Program_IT_1
   \   0000000E   0x2002             MOVS     R0,#+2
   \   00000010   0xBD70             POP      {R4-R6,PC}
   \                     ??HAL_FLASH_Program_IT_1: (+1)
   \   00000012   0x2501             MOVS     R5,#+1
   \   00000014   0x750D             STRB     R5,[R1, #+20]
    257          
    258            /* Check the parameters */
    259            assert_param(IS_FLASH_TYPEPROGRAM(TypeProgram));
    260          
    261            /* Enable End of FLASH Operation interrupt */
    262            __HAL_FLASH_ENABLE_IT(FLASH_IT_EOP);
   \   00000016   0x....             LDR.N    R5,??DataTable12_2  ;; 0x40023c0c
   \   00000018   0x686E             LDR      R6,[R5, #+4]
   \   0000001A   0xF046 0x7680      ORR      R6,R6,#0x1000000
   \   0000001E   0x606E             STR      R6,[R5, #+4]
    263            
    264            /* Enable Error source interrupt */
    265            __HAL_FLASH_ENABLE_IT(FLASH_IT_ERR);
   \   00000020   0x686E             LDR      R6,[R5, #+4]
   \   00000022   0xF046 0x7600      ORR      R6,R6,#0x2000000
   \   00000026   0x606E             STR      R6,[R5, #+4]
    266            
    267            /* Clear pending flags (if any) */  
    268            __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_EOP    | FLASH_FLAG_OPERR | FLASH_FLAG_WRPERR |\
    269                                   FLASH_FLAG_PGAERR | FLASH_FLAG_PGPERR| FLASH_FLAG_ERSERR);  
   \   00000028   0x26F3             MOVS     R6,#+243
   \   0000002A   0x602E             STR      R6,[R5, #+0]
    270          
    271            pFlash.ProcedureOnGoing = FLASH_PROC_PROGRAM;
   \   0000002C   0x2503             MOVS     R5,#+3
    272            pFlash.Address = Address;
    273            
    274            switch(TypeProgram)
   \   0000002E   0x2C03             CMP      R4,#+3
   \   00000030   0x700D             STRB     R5,[R1, #+0]
   \   00000032   0x6108             STR      R0,[R1, #+16]
   \   00000034   0xD811             BHI.N    ??HAL_FLASH_Program_IT_2
   \   00000036   0xE8DF 0xF004      TBB      [PC, R4]
   \                     ??HAL_FLASH_Program_IT_0:
   \   0000003A   0x02 0x06          DC8      0x2,0x6,0xA,0xE
   \              0x0A 0x0E    
    275            {
    276              case FLASH_TYPEPROGRAM_BYTE :
    277              {
    278                /*Program byte (8-bit) at a specified address.*/
    279                FLASH_Program_Byte(Address, (uint8_t) Data);
   \                     ??HAL_FLASH_Program_IT_3: (+1)
   \   0000003E   0xB2D1             UXTB     R1,R2
   \   00000040   0x.... 0x....      BL       FLASH_Program_Byte
    280                break;
   \   00000044   0xE009             B.N      ??HAL_FLASH_Program_IT_2
    281              }
    282              
    283              case FLASH_TYPEPROGRAM_HALFWORD :
    284              {
    285                /*Program halfword (16-bit) at a specified address.*/
    286                FLASH_Program_HalfWord(Address, (uint16_t) Data);
   \                     ??HAL_FLASH_Program_IT_4: (+1)
   \   00000046   0xB291             UXTH     R1,R2
   \   00000048   0x.... 0x....      BL       FLASH_Program_HalfWord
    287                break;
   \   0000004C   0xE005             B.N      ??HAL_FLASH_Program_IT_2
    288              }
    289              
    290              case FLASH_TYPEPROGRAM_WORD :
    291              {
    292                /*Program word (32-bit) at a specified address.*/
    293                FLASH_Program_Word(Address, (uint32_t) Data);
   \                     ??HAL_FLASH_Program_IT_5: (+1)
   \   0000004E   0x4611             MOV      R1,R2
   \   00000050   0x.... 0x....      BL       FLASH_Program_Word
    294                break;
   \   00000054   0xE001             B.N      ??HAL_FLASH_Program_IT_2
    295              }
    296              
    297              case FLASH_TYPEPROGRAM_DOUBLEWORD :
    298              {
    299                /*Program double word (64-bit) at a specified address.*/
    300                FLASH_Program_DoubleWord(Address, Data);
   \                     ??HAL_FLASH_Program_IT_6: (+1)
   \   00000056   0x.... 0x....      BL       FLASH_Program_DoubleWord
    301                break;
    302              }
    303              default :
    304                break;
    305            }
    306            return status;
   \                     ??HAL_FLASH_Program_IT_2: (+1)
   \   0000005A   0x2000             MOVS     R0,#+0
   \   0000005C   0xBD70             POP      {R4-R6,PC}       ;; return
    307          }
    308          
    309          /**
    310            * @brief This function handles FLASH interrupt request.
    311            * @retval None
    312            */

   \                                 In section .text, align 2, keep-with-next
    313          void HAL_FLASH_IRQHandler(void)
    314          {
   \                     HAL_FLASH_IRQHandler: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
    315            uint32_t temp = 0;
    316            
    317            /* If the program operation is completed, disable the PG Bit */
    318            FLASH->CR &= (~FLASH_CR_PG);
   \   00000002   0x....             LDR.N    R5,??DataTable12_2  ;; 0x40023c0c
   \   00000004   0x2400             MOVS     R4,#+0
    319          
    320            /* If the erase operation is completed, disable the SER Bit */
    321            FLASH->CR &= (~FLASH_CR_SER);
    322            FLASH->CR &= SECTOR_MASK; 
    323          
    324            /* if the erase operation is completed, disable the MER Bit */
    325            FLASH->CR &= (~FLASH_MER_BIT);
    326          
    327            /* Check FLASH End of Operation flag  */
    328            if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_EOP) != RESET)
   \   00000006   0xF04F 0x36FF      MOV      R6,#-1
   \   0000000A   0x....             LDR.N    R7,??DataTable12
   \   0000000C   0x6868             LDR      R0,[R5, #+4]
   \   0000000E   0x0840             LSRS     R0,R0,#+1
   \   00000010   0x0040             LSLS     R0,R0,#+1
   \   00000012   0x6068             STR      R0,[R5, #+4]
   \   00000014   0x6868             LDR      R0,[R5, #+4]
   \   00000016   0xF020 0x0002      BIC      R0,R0,#0x2
   \   0000001A   0x6068             STR      R0,[R5, #+4]
   \   0000001C   0x6868             LDR      R0,[R5, #+4]
   \   0000001E   0xF020 0x00F8      BIC      R0,R0,#0xF8
   \   00000022   0x6068             STR      R0,[R5, #+4]
   \   00000024   0x6868             LDR      R0,[R5, #+4]
   \   00000026   0xF020 0x0004      BIC      R0,R0,#0x4
   \   0000002A   0x6068             STR      R0,[R5, #+4]
   \   0000002C   0x6828             LDR      R0,[R5, #+0]
   \   0000002E   0x07C0             LSLS     R0,R0,#+31
   \   00000030   0xD529             BPL.N    ??HAL_FLASH_IRQHandler_0
    329            {
    330              switch (pFlash.ProcedureOnGoing)
   \   00000032   0x7838             LDRB     R0,[R7, #+0]
   \   00000034   0x2801             CMP      R0,#+1
   \   00000036   0xD004             BEQ.N    ??HAL_FLASH_IRQHandler_1
   \   00000038   0xD325             BCC.N    ??HAL_FLASH_IRQHandler_0
   \   0000003A   0x2803             CMP      R0,#+3
   \   0000003C   0xD01D             BEQ.N    ??HAL_FLASH_IRQHandler_2
   \   0000003E   0xD31A             BCC.N    ??HAL_FLASH_IRQHandler_3
   \   00000040   0xE021             B.N      ??HAL_FLASH_IRQHandler_0
    331              {
    332                case FLASH_PROC_SECTERASE :
    333                {
    334                  /* Nb of sector to erased can be decreased */
    335                  pFlash.NbSectorsToErase--;
   \                     ??HAL_FLASH_IRQHandler_1: (+1)
   \   00000042   0x6878             LDR      R0,[R7, #+4]
   \   00000044   0x1E40             SUBS     R0,R0,#+1
   \   00000046   0x6078             STR      R0,[R7, #+4]
    336          
    337                  /* Check if there are still sectors to erase */
    338                  if(pFlash.NbSectorsToErase != 0)
   \   00000048   0x6878             LDR      R0,[R7, #+4]
   \   0000004A   0xB160             CBZ.N    R0,??HAL_FLASH_IRQHandler_4
    339                  {
    340                    temp = pFlash.Sector;
   \   0000004C   0x68F8             LDR      R0,[R7, #+12]
    341                    /* Indicate user which sector has been erased */
    342                    HAL_FLASH_EndOfOperationCallback(temp);
   \   0000004E   0x.... 0x....      BL       HAL_FLASH_EndOfOperationCallback
    343          
    344                    /* Clear pending flags (if any) */  
    345                    __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_EOP);  
   \   00000052   0x2001             MOVS     R0,#+1
   \   00000054   0x6028             STR      R0,[R5, #+0]
    346          
    347                    /* Increment sector number */
    348                    temp = ++pFlash.Sector;
   \   00000056   0x68F8             LDR      R0,[R7, #+12]
   \   00000058   0x1C44             ADDS     R4,R0,#+1
    349                    FLASH_Erase_Sector(temp, pFlash.VoltageForErase);
   \   0000005A   0x4620             MOV      R0,R4
   \   0000005C   0x60FC             STR      R4,[R7, #+12]
   \   0000005E   0x7A39             LDRB     R1,[R7, #+8]
   \   00000060   0x.... 0x....      BL       FLASH_Erase_Sector
   \   00000064   0xE00F             B.N      ??HAL_FLASH_IRQHandler_0
    350                  }
    351                  else
    352                  {
    353                    /* No more sectors to Erase, user callback can be called.*/
    354                    /* Reset Sector and stop Erase sectors procedure */
    355                    pFlash.Sector = temp = 0xFFFFFFFF;
   \                     ??HAL_FLASH_IRQHandler_4: (+1)
   \   00000066   0x4634             MOV      R4,R6
   \   00000068   0x60FE             STR      R6,[R7, #+12]
    356                    /* FLASH EOP interrupt user callback */
    357                    HAL_FLASH_EndOfOperationCallback(temp);
   \   0000006A   0x4620             MOV      R0,R4
   \   0000006C   0x.... 0x....      BL       HAL_FLASH_EndOfOperationCallback
    358                    /* Sector Erase procedure is completed */
    359                    pFlash.ProcedureOnGoing = FLASH_PROC_NONE;
   \   00000070   0x2000             MOVS     R0,#+0
   \   00000072   0x7038             STRB     R0,[R7, #+0]
    360                    /* Clear FLASH End of Operation pending bit */
    361                    __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_EOP);
   \   00000074   0xE005             B.N      ??HAL_FLASH_IRQHandler_5
    362                  }
    363                  break;
    364                }
    365              
    366                case FLASH_PROC_MASSERASE :
    367                {
    368                  /* MassErase ended. Return the selected bank : in this product we don't have Banks */
    369                  /* FLASH EOP interrupt user callback */
    370                  HAL_FLASH_EndOfOperationCallback(0);
   \                     ??HAL_FLASH_IRQHandler_3: (+1)
   \   00000076   0x2000             MOVS     R0,#+0
   \   00000078   0xE000             B.N      ??HAL_FLASH_IRQHandler_6
    371                  /* MAss Erase procedure is completed */
    372                  pFlash.ProcedureOnGoing = FLASH_PROC_NONE;
    373                  /* Clear FLASH End of Operation pending bit */
    374                  __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_EOP);
    375                  break;
    376                }
    377          
    378                case FLASH_PROC_PROGRAM :
    379                {
    380                  /*Program ended. Return the selected address*/
    381                  /* FLASH EOP interrupt user callback */
    382                  HAL_FLASH_EndOfOperationCallback(pFlash.Address);
   \                     ??HAL_FLASH_IRQHandler_2: (+1)
   \   0000007A   0x6938             LDR      R0,[R7, #+16]
   \                     ??HAL_FLASH_IRQHandler_6: (+1)
   \   0000007C   0x.... 0x....      BL       HAL_FLASH_EndOfOperationCallback
    383                  /* Programming procedure is completed */
    384                  pFlash.ProcedureOnGoing = FLASH_PROC_NONE;
   \   00000080   0x703C             STRB     R4,[R7, #+0]
    385                  /* Clear FLASH End of Operation pending bit */
    386                  __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_EOP);
   \                     ??HAL_FLASH_IRQHandler_5: (+1)
   \   00000082   0x2001             MOVS     R0,#+1
   \   00000084   0x6028             STR      R0,[R5, #+0]
    387                  break;
    388                }
    389                default :
    390                  break;
    391              }
    392            }
    393            
    394            /* Check FLASH operation error flags */
    395            if(__HAL_FLASH_GET_FLAG((FLASH_FLAG_OPERR  | FLASH_FLAG_WRPERR | FLASH_FLAG_PGAERR | FLASH_FLAG_PGPERR | FLASH_FLAG_ERSERR )) != RESET)
   \                     ??HAL_FLASH_IRQHandler_0: (+1)
   \   00000086   0x6828             LDR      R0,[R5, #+0]
   \   00000088   0xF010 0x0FF2      TST      R0,#0xF2
   \   0000008C   0xD015             BEQ.N    ??HAL_FLASH_IRQHandler_7
    396            {
    397              switch (pFlash.ProcedureOnGoing)
   \   0000008E   0x7838             LDRB     R0,[R7, #+0]
   \   00000090   0x2801             CMP      R0,#+1
   \   00000092   0xD005             BEQ.N    ??HAL_FLASH_IRQHandler_8
   \   00000094   0xD308             BCC.N    ??HAL_FLASH_IRQHandler_9
   \   00000096   0x2803             CMP      R0,#+3
   \   00000098   0xD005             BEQ.N    ??HAL_FLASH_IRQHandler_10
   \   0000009A   0xBF38             IT       CC 
   \   0000009C   0x2400             MOVCC    R4,#+0
    398              {
    399                case FLASH_PROC_SECTERASE :
    400                {
    401                  /* return the faulty sector */
    402                  temp = pFlash.Sector;
    403                  pFlash.Sector = 0xFFFFFFFF;
    404                  break;
    405                }
    406                case FLASH_PROC_MASSERASE :
    407                {
    408                  /* No return in case of Mass Erase */
    409                  temp = 0;
   \   0000009E   0xE003             B.N      ??HAL_FLASH_IRQHandler_9
    410                  break;
    411                }
   \                     ??HAL_FLASH_IRQHandler_8: (+1)
   \   000000A0   0x68FC             LDR      R4,[R7, #+12]
   \   000000A2   0x60FE             STR      R6,[R7, #+12]
   \   000000A4   0xE000             B.N      ??HAL_FLASH_IRQHandler_9
    412                case FLASH_PROC_PROGRAM :
    413                {
    414                  /*return the faulty address*/
    415                  temp = pFlash.Address;
   \                     ??HAL_FLASH_IRQHandler_10: (+1)
   \   000000A6   0x693C             LDR      R4,[R7, #+16]
    416                  break;
    417                }
    418          			default :
    419          				break;
    420              }
    421              /*Save the Error code*/
    422              FLASH_SetErrorCode();
   \                     ??HAL_FLASH_IRQHandler_9: (+1)
   \   000000A8   0x.... 0x....      BL       FLASH_SetErrorCode
    423          
    424              /* FLASH error interrupt user callback */
    425              HAL_FLASH_OperationErrorCallback(temp);
   \   000000AC   0x4620             MOV      R0,R4
   \   000000AE   0x.... 0x....      BL       HAL_FLASH_OperationErrorCallback
    426              /* Clear FLASH error pending bits */
    427              __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_OPERR  | FLASH_FLAG_WRPERR | FLASH_FLAG_PGAERR | FLASH_FLAG_PGPERR | FLASH_FLAG_ERSERR );
   \   000000B2   0x20F2             MOVS     R0,#+242
   \   000000B4   0x6028             STR      R0,[R5, #+0]
    428          
    429              /*Stop the procedure ongoing */
    430              pFlash.ProcedureOnGoing = FLASH_PROC_NONE;
   \   000000B6   0x2000             MOVS     R0,#+0
   \   000000B8   0x7038             STRB     R0,[R7, #+0]
    431            }
    432            
    433            if(pFlash.ProcedureOnGoing == FLASH_PROC_NONE)
   \                     ??HAL_FLASH_IRQHandler_7: (+1)
   \   000000BA   0x7838             LDRB     R0,[R7, #+0]
   \   000000BC   0xB948             CBNZ.N   R0,??HAL_FLASH_IRQHandler_11
    434            {
    435              /* Disable End of FLASH Operation interrupt */
    436              __HAL_FLASH_DISABLE_IT(FLASH_IT_EOP);
   \   000000BE   0x6868             LDR      R0,[R5, #+4]
   \   000000C0   0xF020 0x7080      BIC      R0,R0,#0x1000000
   \   000000C4   0x6068             STR      R0,[R5, #+4]
    437          
    438              /* Disable Error source interrupt */
    439              __HAL_FLASH_DISABLE_IT(FLASH_IT_ERR);
   \   000000C6   0x6868             LDR      R0,[R5, #+4]
   \   000000C8   0xF020 0x7000      BIC      R0,R0,#0x2000000
   \   000000CC   0x6068             STR      R0,[R5, #+4]
    440          
    441              /* Process Unlocked */
    442              __HAL_UNLOCK(&pFlash);
   \   000000CE   0x2000             MOVS     R0,#+0
   \   000000D0   0x7538             STRB     R0,[R7, #+20]
    443            }
    444            
    445          }
   \                     ??HAL_FLASH_IRQHandler_11: (+1)
   \   000000D2   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    446          
    447          /**
    448            * @brief  FLASH end of operation interrupt callback
    449            * @param  ReturnValue: The value saved in this parameter depends on the ongoing procedure
    450            *                 - Sectors Erase: Sector which has been erased (if 0xFFFFFFFF, it means that 
    451            *                                  all the selected sectors have been erased)
    452            *                 - Program      : Address which was selected for data program
    453            *                 - Mass Erase   : No return value expected
    454            * @retval None
    455            */

   \                                 In section .text, align 2, keep-with-next
    456          __weak void HAL_FLASH_EndOfOperationCallback(uint32_t ReturnValue)
    457          {
    458            /* NOTE : This function Should not be modified, when the callback is needed,
    459                      the HAL_FLASH_EndOfOperationCallback could be implemented in the user file
    460             */ 
    461          }
   \                     HAL_FLASH_EndOfOperationCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    462          
    463          /**
    464            * @brief  FLASH operation error interrupt callback
    465            * @param  ReturnValue: The value saved in this parameter depends on the ongoing procedure
    466            *                 - Sectors Erase: Sector which has been erased (if 0xFFFFFFFF, it means that 
    467            *                                  all the selected sectors have been erased)
    468            *                 - Program      : Address which was selected for data program
    469            *                 - Mass Erase   : No return value expected
    470            * @retval None
    471            */

   \                                 In section .text, align 2, keep-with-next
    472          __weak void HAL_FLASH_OperationErrorCallback(uint32_t ReturnValue)
    473          {
    474            /* NOTE : This function Should not be modified, when the callback is needed,
    475                      the HAL_FLASH_OperationErrorCallback could be implemented in the user file
    476             */ 
    477          }
   \                     HAL_FLASH_OperationErrorCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    478          
    479          /**
    480            * @}
    481            */
    482          
    483          /** @defgroup FLASH_Exported_Functions_Group2 Peripheral Control functions 
    484           *  @brief   management functions 
    485           *
    486          @verbatim   
    487           ===============================================================================
    488                                ##### Peripheral Control functions #####
    489           ===============================================================================  
    490              [..]
    491              This subsection provides a set of functions allowing to control the FLASH 
    492              memory operations.
    493          
    494          @endverbatim
    495            * @{
    496            */
    497          
    498          /**
    499            * @brief  Unlock the FLASH control register access
    500            * @retval HAL Status
    501            */

   \                                 In section .text, align 2, keep-with-next
    502          HAL_StatusTypeDef HAL_FLASH_Unlock(void)
    503          {
    504            if((FLASH->CR & FLASH_CR_LOCK) != RESET)
   \                     HAL_FLASH_Unlock: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable12_3  ;; 0x40023c04
   \   00000002   0x68C1             LDR      R1,[R0, #+12]
   \   00000004   0x2900             CMP      R1,#+0
   \   00000006   0xD503             BPL.N    ??HAL_FLASH_Unlock_0
    505            {
    506              /* Authorize the FLASH Registers access */
    507              FLASH->KEYR = FLASH_KEY1;
   \   00000008   0x....             LDR.N    R1,??DataTable12_4  ;; 0x45670123
   \   0000000A   0x6001             STR      R1,[R0, #+0]
    508              FLASH->KEYR = FLASH_KEY2;
   \   0000000C   0x....             LDR.N    R1,??DataTable12_5  ;; 0xcdef89ab
   \   0000000E   0x....             B.N      ?Subroutine0
    509            }
    510            else
    511            {
    512              return HAL_ERROR;
   \                     ??HAL_FLASH_Unlock_0: (+1)
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0x4770             BX       LR               ;; return
    513            }
    514            
    515            return HAL_OK; 
    516          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \   00000000   0x6001             STR      R1,[R0, #+0]
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0x4770             BX       LR
    517          
    518          /**
    519            * @brief  Locks the FLASH control register access
    520            * @retval HAL Status
    521            */

   \                                 In section .text, align 2, keep-with-next
    522          HAL_StatusTypeDef HAL_FLASH_Lock(void)
    523          {
    524            /* Set the LOCK Bit to lock the FLASH Registers access */
    525            FLASH->CR |= FLASH_CR_LOCK;
   \                     HAL_FLASH_Lock: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable12_1  ;; 0x40023c10
   \   00000002   0x6801             LDR      R1,[R0, #+0]
   \   00000004   0xF041 0x4100      ORR      R1,R1,#0x80000000
   \   00000008                      REQUIRE ?Subroutine0
   \   00000008                      ;; // Fall through to label ?Subroutine0
    526            
    527            return HAL_OK;  
    528          }
    529          
    530          /**
    531            * @brief  Unlock the FLASH Option Control Registers access.
    532            * @retval HAL Status
    533            */

   \                                 In section .text, align 2, keep-with-next
    534          HAL_StatusTypeDef HAL_FLASH_OB_Unlock(void)
    535          {
    536            if((FLASH->OPTCR & FLASH_OPTCR_OPTLOCK) != RESET)
   \                     HAL_FLASH_OB_Unlock: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable12_6  ;; 0x40023c08
   \   00000002   0x68C1             LDR      R1,[R0, #+12]
   \   00000004   0x07C9             LSLS     R1,R1,#+31
   \   00000006   0xD503             BPL.N    ??HAL_FLASH_OB_Unlock_0
    537            {
    538              /* Authorizes the Option Byte register programming */
    539              FLASH->OPTKEYR = FLASH_OPT_KEY1;
   \   00000008   0x....             LDR.N    R1,??DataTable12_7  ;; 0x8192a3b
   \   0000000A   0x6001             STR      R1,[R0, #+0]
    540              FLASH->OPTKEYR = FLASH_OPT_KEY2;
   \   0000000C   0x....             LDR.N    R1,??DataTable12_8  ;; 0x4c5d6e7f
   \   0000000E   0x....             B.N      ?Subroutine0
    541            }
    542            else
    543            {
    544              return HAL_ERROR;
   \                     ??HAL_FLASH_OB_Unlock_0: (+1)
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0x4770             BX       LR               ;; return
    545            }  
    546            
    547            return HAL_OK;  
    548          }
    549          
    550          /**
    551            * @brief  Lock the FLASH Option Control Registers access.
    552            * @retval HAL Status 
    553            */

   \                                 In section .text, align 2, keep-with-next
    554          HAL_StatusTypeDef HAL_FLASH_OB_Lock(void)
    555          {
    556            /* Set the OPTLOCK Bit to lock the FLASH Option Byte Registers access */
    557            FLASH->OPTCR |= FLASH_OPTCR_OPTLOCK;
   \                     HAL_FLASH_OB_Lock: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable12_9  ;; 0x40023c14
   \   00000002   0x6801             LDR      R1,[R0, #+0]
   \   00000004   0xF041 0x0101      ORR      R1,R1,#0x1
   \   00000008   0x....             B.N      ?Subroutine0
    558            
    559            return HAL_OK;  
    560          }
    561          
    562          /**
    563            * @brief  Launch the option byte loading.
    564            * @retval HAL Status
    565            */

   \                                 In section .text, align 2, keep-with-next
    566          HAL_StatusTypeDef HAL_FLASH_OB_Launch(void)
    567          {
    568            /* Set the OPTSTRT bit in OPTCR register */
    569            FLASH->OPTCR |= FLASH_OPTCR_OPTSTRT;
   \                     HAL_FLASH_OB_Launch: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable12_9  ;; 0x40023c14
   \   00000002   0x6801             LDR      R1,[R0, #+0]
   \   00000004   0xF041 0x0102      ORR      R1,R1,#0x2
   \   00000008   0x6001             STR      R1,[R0, #+0]
    570          
    571            /* Wait for last operation to be completed */
    572            return(FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE)); 
   \   0000000A   0xF24C 0x3050      MOVW     R0,#+50000
   \   0000000E   0x....             B.N      FLASH_WaitForLastOperation
    573          }
    574          
    575          /**
    576            * @}
    577            */
    578          
    579          /** @defgroup FLASH_Exported_Functions_Group3 Peripheral State and Errors functions 
    580           *  @brief   Peripheral Errors functions 
    581           *
    582          @verbatim   
    583           ===============================================================================
    584                          ##### Peripheral Errors functions #####
    585           ===============================================================================  
    586              [..]
    587              This subsection permits to get in run-time Errors of the FLASH peripheral.
    588          
    589          @endverbatim
    590            * @{
    591            */
    592          
    593          /**
    594            * @brief  Get the specific FLASH error flag.
    595            * @retval FLASH_ErrorCode: The returned value can be:
    596            *            @arg FLASH_ERROR_ERS: FLASH Erasing Sequence error flag 
    597            *            @arg FLASH_ERROR_PGP: FLASH Programming Parallelism error flag  
    598            *            @arg FLASH_ERROR_PGA: FLASH Programming Alignment error flag
    599            *            @arg FLASH_ERROR_WRP: FLASH Write protected error flag
    600            *            @arg FLASH_ERROR_OPERATION: FLASH operation Error flag 
    601            */

   \                                 In section .text, align 2, keep-with-next
    602          uint32_t HAL_FLASH_GetError(void)
    603          { 
    604             return pFlash.ErrorCode;
   \                     HAL_FLASH_GetError: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable12
   \   00000002   0x6980             LDR      R0,[R0, #+24]
   \   00000004   0x4770             BX       LR               ;; return
    605          }  
    606            
    607          /**
    608            * @}
    609            */    
    610          
    611          /**
    612            * @brief  Wait for a FLASH operation to complete.
    613            * @param  Timeout: maximum flash operationtimeout
    614            * @retval HAL Status
    615            */

   \                                 In section .text, align 2, keep-with-next
    616          HAL_StatusTypeDef FLASH_WaitForLastOperation(uint32_t Timeout)
    617          { 
   \                     FLASH_WaitForLastOperation: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
    618            uint32_t tickstart = 0;
    619            
    620            /* Clear Error Code */
    621            pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x....             LDR.N    R1,??DataTable12
   \   00000008   0x....             LDR.N    R6,??DataTable12_2  ;; 0x40023c0c
   \   0000000A   0x6188             STR      R0,[R1, #+24]
    622            
    623            /* Wait for the FLASH operation to complete by polling on BUSY flag to be reset.
    624               Even if the FLASH operation fails, the BUSY flag will be reset and an error
    625               flag will be set */
    626            /* Get tick */
    627            tickstart = HAL_GetTick();
   \   0000000C   0x.... 0x....      BL       HAL_GetTick
   \   00000010   0x4605             MOV      R5,R0
    628          
    629            while(__HAL_FLASH_GET_FLAG(FLASH_FLAG_BSY) != RESET) 
   \                     ??FLASH_WaitForLastOperation_0: (+1)
   \   00000012   0x6830             LDR      R0,[R6, #+0]
   \   00000014   0x03C0             LSLS     R0,R0,#+15
   \   00000016   0xD50A             BPL.N    ??FLASH_WaitForLastOperation_1
    630            { 
    631              if(Timeout != HAL_MAX_DELAY)
   \   00000018   0xF114 0x0F01      CMN      R4,#+1
   \   0000001C   0xD0F9             BEQ.N    ??FLASH_WaitForLastOperation_0
    632              {
    633                if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
   \   0000001E   0xB124             CBZ.N    R4,??FLASH_WaitForLastOperation_2
   \   00000020   0x.... 0x....      BL       HAL_GetTick
   \   00000024   0x1B40             SUBS     R0,R0,R5
   \   00000026   0x4284             CMP      R4,R0
   \   00000028   0xD2F3             BCS.N    ??FLASH_WaitForLastOperation_0
    634                {
    635                  return HAL_TIMEOUT;
   \                     ??FLASH_WaitForLastOperation_2: (+1)
   \   0000002A   0x2003             MOVS     R0,#+3
   \   0000002C   0xBD70             POP      {R4-R6,PC}
    636                }
    637              } 
    638            }
    639            
    640            if(__HAL_FLASH_GET_FLAG((FLASH_FLAG_OPERR | FLASH_FLAG_WRPERR | FLASH_FLAG_PGAERR | \
    641                                     FLASH_FLAG_PGPERR | FLASH_FLAG_ERSERR )) != RESET)
   \                     ??FLASH_WaitForLastOperation_1: (+1)
   \   0000002E   0x6830             LDR      R0,[R6, #+0]
   \   00000030   0xF010 0x0FF2      TST      R0,#0xF2
   \   00000034   0xD003             BEQ.N    ??FLASH_WaitForLastOperation_3
    642            {
    643              /*Save the error code*/
    644              FLASH_SetErrorCode();
   \   00000036   0x.... 0x....      BL       FLASH_SetErrorCode
    645              return HAL_ERROR;
   \   0000003A   0x2001             MOVS     R0,#+1
   \   0000003C   0xBD70             POP      {R4-R6,PC}
    646            }
    647          
    648            /* If there is an error flag set */
    649            return HAL_OK;
   \                     ??FLASH_WaitForLastOperation_3: (+1)
   \   0000003E   0x2000             MOVS     R0,#+0
   \   00000040   0xBD70             POP      {R4-R6,PC}       ;; return
    650            
    651          }  
    652          
    653          /**
    654            * @brief  Program a double word (64-bit) at a specified address.
    655            * @note   This function must be used when the device voltage range is from
    656            *         2.7V to 3.6V and an External Vpp is present.
    657            *
    658            * @note   If an erase and a program operations are requested simultaneously,    
    659            *         the erase operation is performed before the program one.
    660            *  
    661            * @param  Address: specifies the address to be programmed.
    662            * @param  Data: specifies the data to be programmed.
    663            * @retval None
    664            */

   \                                 In section .text, align 2, keep-with-next
    665          static void FLASH_Program_DoubleWord(uint32_t Address, uint64_t Data)
    666          {
    667            /* Check the parameters */
    668            assert_param(IS_FLASH_ADDRESS(Address));
    669            
    670            /* If the previous operation is completed, proceed to program the new data */
    671            FLASH->CR &= CR_PSIZE_MASK;
   \                     FLASH_Program_DoubleWord: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable12_1  ;; 0x40023c10
   \   00000002   0xB510             PUSH     {R4,LR}
   \   00000004   0x680C             LDR      R4,[R1, #+0]
   \   00000006   0xF424 0x7440      BIC      R4,R4,#0x300
   \   0000000A   0x600C             STR      R4,[R1, #+0]
    672            FLASH->CR |= FLASH_PSIZE_DOUBLE_WORD;
   \   0000000C   0x680C             LDR      R4,[R1, #+0]
   \   0000000E   0xF444 0x7440      ORR      R4,R4,#0x300
   \   00000012   0x600C             STR      R4,[R1, #+0]
    673            FLASH->CR |= FLASH_CR_PG;
   \   00000014   0x680C             LDR      R4,[R1, #+0]
   \   00000016   0xF044 0x0401      ORR      R4,R4,#0x1
   \   0000001A   0x600C             STR      R4,[R1, #+0]
    674            
    675            *(__IO uint64_t*)Address = Data;
   \   0000001C   0xE9C0 0x2300      STRD     R2,R3,[R0, #+0]
    676            
    677            /* Data synchronous Barrier (DSB) Just after the write operation
    678               This will force the CPU to respect the sequence of instruction (no optimization).*/
    679            __DSB();
   \   00000020   0xF3BF 0x8F4F      DSB      
    680          }
   \   00000024   0xBD10             POP      {R4,PC}          ;; return
    681          
    682          
    683          /**
    684            * @brief  Program word (32-bit) at a specified address.
    685            * @note   This function must be used when the device voltage range is from
    686            *         2.7V to 3.6V.
    687            *
    688            * @note   If an erase and a program operations are requested simultaneously,    
    689            *         the erase operation is performed before the program one.
    690            *  
    691            * @param  Address: specifies the address to be programmed.
    692            * @param  Data: specifies the data to be programmed.
    693            * @retval None
    694            */

   \                                 In section .text, align 2, keep-with-next
    695          static void FLASH_Program_Word(uint32_t Address, uint32_t Data)
    696          {
    697            /* Check the parameters */
    698            assert_param(IS_FLASH_ADDRESS(Address));
    699            
    700            /* If the previous operation is completed, proceed to program the new data */
    701            FLASH->CR &= CR_PSIZE_MASK;
   \                     FLASH_Program_Word: (+1)
   \   00000000   0x....             LDR.N    R2,??DataTable12_1  ;; 0x40023c10
   \   00000002   0x6813             LDR      R3,[R2, #+0]
   \   00000004   0xF423 0x7340      BIC      R3,R3,#0x300
   \   00000008   0x6013             STR      R3,[R2, #+0]
    702            FLASH->CR |= FLASH_PSIZE_WORD;
   \   0000000A   0x6813             LDR      R3,[R2, #+0]
   \   0000000C   0xF443 0x7300      ORR      R3,R3,#0x200
   \   00000010   0x6013             STR      R3,[R2, #+0]
    703            FLASH->CR |= FLASH_CR_PG;
   \   00000012   0x6813             LDR      R3,[R2, #+0]
   \   00000014   0xF043 0x0301      ORR      R3,R3,#0x1
   \   00000018   0x6013             STR      R3,[R2, #+0]
    704          
    705            *(__IO uint32_t*)Address = Data;
   \   0000001A   0x6001             STR      R1,[R0, #+0]
    706            
    707            /* Data synchronous Barrier (DSB) Just after the write operation
    708               This will force the CPU to respect the sequence of instruction (no optimization).*/
    709            __DSB();
   \   0000001C   0x....             B.N      ?Subroutine1
    710          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \   00000000   0xF3BF 0x8F4F      DSB      
   \   00000004   0x4770             BX       LR               ;; return
    711          
    712          /**
    713            * @brief  Program a half-word (16-bit) at a specified address.
    714            * @note   This function must be used when the device voltage range is from
    715            *         2.7V to 3.6V.
    716            *
    717            * @note   If an erase and a program operations are requested simultaneously,    
    718            *         the erase operation is performed before the program one.
    719            *  
    720            * @param  Address: specifies the address to be programmed.
    721            * @param  Data: specifies the data to be programmed.
    722            * @retval None
    723            */

   \                                 In section .text, align 2, keep-with-next
    724          static void FLASH_Program_HalfWord(uint32_t Address, uint16_t Data)
    725          {
    726            /* Check the parameters */
    727            assert_param(IS_FLASH_ADDRESS(Address));
    728            
    729            /* If the previous operation is completed, proceed to program the new data */
    730            FLASH->CR &= CR_PSIZE_MASK;
   \                     FLASH_Program_HalfWord: (+1)
   \   00000000   0x....             LDR.N    R2,??DataTable12_1  ;; 0x40023c10
   \   00000002   0x6813             LDR      R3,[R2, #+0]
   \   00000004   0xF423 0x7340      BIC      R3,R3,#0x300
   \   00000008   0x6013             STR      R3,[R2, #+0]
    731            FLASH->CR |= FLASH_PSIZE_HALF_WORD;
   \   0000000A   0x6813             LDR      R3,[R2, #+0]
   \   0000000C   0xF443 0x7380      ORR      R3,R3,#0x100
   \   00000010   0x6013             STR      R3,[R2, #+0]
    732            FLASH->CR |= FLASH_CR_PG;
   \   00000012   0x6813             LDR      R3,[R2, #+0]
   \   00000014   0xF043 0x0301      ORR      R3,R3,#0x1
   \   00000018   0x6013             STR      R3,[R2, #+0]
    733          
    734            *(__IO uint16_t*)Address = Data;
   \   0000001A   0x8001             STRH     R1,[R0, #+0]
    735          
    736            /* Data synchronous Barrier (DSB) Just after the write operation
    737               This will force the CPU to respect the sequence of instruction (no optimization).*/
    738            __DSB();
   \   0000001C                      REQUIRE ?Subroutine1
   \   0000001C                      ;; // Fall through to label ?Subroutine1
    739            
    740          }
    741          
    742          /**
    743            * @brief  Program byte (8-bit) at a specified address.
    744            * @note   This function must be used when the device voltage range is from
    745            *         2.7V to 3.6V.
    746            *
    747            * @note   If an erase and a program operations are requested simultaneously,    
    748            *         the erase operation is performed before the program one.
    749            *  
    750            * @param  Address: specifies the address to be programmed.
    751            * @param  Data: specifies the data to be programmed.
    752            * @retval None
    753            */

   \                                 In section .text, align 2, keep-with-next
    754          static void FLASH_Program_Byte(uint32_t Address, uint8_t Data)
    755          {
    756            /* Check the parameters */
    757            assert_param(IS_FLASH_ADDRESS(Address));
    758            
    759            /* If the previous operation is completed, proceed to program the new data */
    760            FLASH->CR &= CR_PSIZE_MASK;
   \                     FLASH_Program_Byte: (+1)
   \   00000000   0x....             LDR.N    R2,??DataTable12_1  ;; 0x40023c10
   \   00000002   0x6813             LDR      R3,[R2, #+0]
   \   00000004   0xF423 0x7340      BIC      R3,R3,#0x300
   \   00000008   0x6013             STR      R3,[R2, #+0]
    761            FLASH->CR |= FLASH_PSIZE_BYTE;
   \   0000000A   0x6813             LDR      R3,[R2, #+0]
   \   0000000C   0x6013             STR      R3,[R2, #+0]
    762            FLASH->CR |= FLASH_CR_PG;
   \   0000000E   0x6813             LDR      R3,[R2, #+0]
   \   00000010   0xF043 0x0301      ORR      R3,R3,#0x1
   \   00000014   0x6013             STR      R3,[R2, #+0]
    763          
    764            *(__IO uint8_t*)Address = Data;
   \   00000016   0x7001             STRB     R1,[R0, #+0]
    765          
    766            /* Data synchronous Barrier (DSB) Just after the write operation
    767               This will force the CPU to respect the sequence of instruction (no optimization).*/
    768            __DSB();
   \   00000018   0x....             B.N      ?Subroutine1
    769          }
    770          
    771          /**
    772            * @brief  Set the specific FLASH error flag.
    773            * @retval None
    774            */

   \                                 In section .text, align 2, keep-with-next
    775          static void FLASH_SetErrorCode(void)
    776          { 
    777            if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_WRPERR) != RESET)
   \                     FLASH_SetErrorCode: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable12_2  ;; 0x40023c0c
   \   00000002   0x....             LDR.N    R0,??DataTable12
   \   00000004   0x680A             LDR      R2,[R1, #+0]
   \   00000006   0x06D2             LSLS     R2,R2,#+27
   \   00000008   0xD503             BPL.N    ??FLASH_SetErrorCode_0
    778            {
    779             pFlash.ErrorCode |= HAL_FLASH_ERROR_WRP;
   \   0000000A   0x6982             LDR      R2,[R0, #+24]
   \   0000000C   0xF042 0x0210      ORR      R2,R2,#0x10
   \   00000010   0x6182             STR      R2,[R0, #+24]
    780            }
    781            
    782            if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_PGAERR) != RESET)
   \                     ??FLASH_SetErrorCode_0: (+1)
   \   00000012   0x680A             LDR      R2,[R1, #+0]
   \   00000014   0x0692             LSLS     R2,R2,#+26
   \   00000016   0xD503             BPL.N    ??FLASH_SetErrorCode_1
    783            {
    784             pFlash.ErrorCode |= HAL_FLASH_ERROR_PGA;
   \   00000018   0x6982             LDR      R2,[R0, #+24]
   \   0000001A   0xF042 0x0208      ORR      R2,R2,#0x8
   \   0000001E   0x6182             STR      R2,[R0, #+24]
    785            }
    786            
    787            if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_PGPERR) != RESET)
   \                     ??FLASH_SetErrorCode_1: (+1)
   \   00000020   0x680A             LDR      R2,[R1, #+0]
   \   00000022   0x0652             LSLS     R2,R2,#+25
   \   00000024   0xD503             BPL.N    ??FLASH_SetErrorCode_2
    788            {
    789              pFlash.ErrorCode |= HAL_FLASH_ERROR_PGP;
   \   00000026   0x6982             LDR      R2,[R0, #+24]
   \   00000028   0xF042 0x0204      ORR      R2,R2,#0x4
   \   0000002C   0x6182             STR      R2,[R0, #+24]
    790            }
    791            
    792            if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_ERSERR) != RESET)
   \                     ??FLASH_SetErrorCode_2: (+1)
   \   0000002E   0x680A             LDR      R2,[R1, #+0]
   \   00000030   0x0612             LSLS     R2,R2,#+24
   \   00000032   0xD503             BPL.N    ??FLASH_SetErrorCode_3
    793            {
    794              pFlash.ErrorCode |= HAL_FLASH_ERROR_ERS;
   \   00000034   0x6982             LDR      R2,[R0, #+24]
   \   00000036   0xF042 0x0202      ORR      R2,R2,#0x2
   \   0000003A   0x6182             STR      R2,[R0, #+24]
    795            }
    796            
    797            if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_OPERR) != RESET)
   \                     ??FLASH_SetErrorCode_3: (+1)
   \   0000003C   0x6809             LDR      R1,[R1, #+0]
   \   0000003E   0x0789             LSLS     R1,R1,#+30
   \   00000040   0xD503             BPL.N    ??FLASH_SetErrorCode_4
    798            {
    799              pFlash.ErrorCode |= HAL_FLASH_ERROR_OPERATION;
   \   00000042   0x6981             LDR      R1,[R0, #+24]
   \   00000044   0xF041 0x0120      ORR      R1,R1,#0x20
   \   00000048   0x6181             STR      R1,[R0, #+24]
    800            }
    801          }
   \                     ??FLASH_SetErrorCode_4: (+1)
   \   0000004A   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12:
   \   00000000   0x........         DC32     pFlash

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_1:
   \   00000000   0x40023C10         DC32     0x40023c10

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_2:
   \   00000000   0x40023C0C         DC32     0x40023c0c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_3:
   \   00000000   0x40023C04         DC32     0x40023c04

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_4:
   \   00000000   0x45670123         DC32     0x45670123

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_5:
   \   00000000   0xCDEF89AB         DC32     0xcdef89ab

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_6:
   \   00000000   0x40023C08         DC32     0x40023c08

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_7:
   \   00000000   0x08192A3B         DC32     0x8192a3b

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_8:
   \   00000000   0x4C5D6E7F         DC32     0x4c5d6e7f

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_9:
   \   00000000   0x40023C14         DC32     0x40023c14
    802          
    803          /**
    804            * @}
    805            */
    806          
    807          #endif /* HAL_FLASH_MODULE_ENABLED */
    808          
    809          /**
    810            * @}
    811            */
    812          
    813          /**
    814            * @}
    815            */
    816          
    817          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   FLASH_Program_Byte
       8   FLASH_Program_DoubleWord
       0   FLASH_Program_HalfWord
       0   FLASH_Program_Word
       0   FLASH_SetErrorCode
      16   FLASH_WaitForLastOperation
        16   -> FLASH_SetErrorCode
        16   -> HAL_GetTick
       0   HAL_FLASH_EndOfOperationCallback
       0   HAL_FLASH_GetError
      24   HAL_FLASH_IRQHandler
        24   -> FLASH_Erase_Sector
        24   -> FLASH_SetErrorCode
        24   -> HAL_FLASH_EndOfOperationCallback
        24   -> HAL_FLASH_OperationErrorCallback
       0   HAL_FLASH_Lock
       0   HAL_FLASH_OB_Launch
         0   -> FLASH_WaitForLastOperation
       0   HAL_FLASH_OB_Lock
       0   HAL_FLASH_OB_Unlock
       0   HAL_FLASH_OperationErrorCallback
      32   HAL_FLASH_Program
        32   -> FLASH_Program_Byte
        32   -> FLASH_Program_DoubleWord
        32   -> FLASH_Program_HalfWord
        32   -> FLASH_Program_Word
        32   -> FLASH_WaitForLastOperation
      16   HAL_FLASH_Program_IT
        16   -> FLASH_Program_Byte
        16   -> FLASH_Program_DoubleWord
        16   -> FLASH_Program_HalfWord
        16   -> FLASH_Program_Word
       0   HAL_FLASH_Unlock


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable12
       4  ??DataTable12_1
       4  ??DataTable12_2
       4  ??DataTable12_3
       4  ??DataTable12_4
       4  ??DataTable12_5
       4  ??DataTable12_6
       4  ??DataTable12_7
       4  ??DataTable12_8
       4  ??DataTable12_9
       6  ?Subroutine0
       6  ?Subroutine1
      26  FLASH_Program_Byte
      38  FLASH_Program_DoubleWord
      28  FLASH_Program_HalfWord
      30  FLASH_Program_Word
      76  FLASH_SetErrorCode
      66  FLASH_WaitForLastOperation
       2  HAL_FLASH_EndOfOperationCallback
       6  HAL_FLASH_GetError
     212  HAL_FLASH_IRQHandler
       8  HAL_FLASH_Lock
      16  HAL_FLASH_OB_Launch
      10  HAL_FLASH_OB_Lock
      20  HAL_FLASH_OB_Unlock
       2  HAL_FLASH_OperationErrorCallback
     116  HAL_FLASH_Program
      94  HAL_FLASH_Program_IT
      20  HAL_FLASH_Unlock
      28  pFlash

 
  28 bytes in section .bss
 822 bytes in section .text
 
 822 bytes of CODE memory
  28 bytes of DATA memory

Errors: none
Warnings: none
