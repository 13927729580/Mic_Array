###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.2.10312/W32 for ARM       21/Dec/2015  22:48:32
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\Src\waveplayer
#        _CS43L22.c
#    Command line =  
#        "H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\Src\waveplayer
#        _CS43L22.c" -D USE_HAL_DRIVER -D STM32F746xx -D USE_STM32746G_DISCO -D
#        USE_IOEXPANDER -D USE_USB_FS -lC
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
#        -lA
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
#        -o
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj
#        --debug --endian=little --cpu=Cortex-M7 -e --fpu=VFPv5_sp
#        --dlib_config "D:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Full.h" -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\Inc\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\CMSIS\Device\ST\STM32F7xx\Include\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\STM32F7xx_HAL_Driver\Inc\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\STM32746G-Discovery\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\Components\Common\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Log\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Fonts\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\CPU\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_Device_Library\Core\Inc\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Core\Inc\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Class\MSC\Inc\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\drivers\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_Audio\Addons\PDM\
#        -Ohz --use_c++_inline --require_prototypes -I "D:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.3\arm\CMSIS\Include\" -D
#        ARM_MATH_CM7
#    List file    =  
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List\waveplayer
#        _CS43L22.lst
#    Object file  =  
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj\waveplayer
#        _CS43L22.o
#
###############################################################################

H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\Src\waveplayer _CS43L22.c
      1          /* Includes ------------------------------------------------------------------*/
      2          #include "main.h"
      3          
      4          /** @addtogroup STM32F4-Discovery_Audio_Player_Recorder
      5          * @{
      6          */ 
      7          
      8          /* Private typedef -----------------------------------------------------------*/
      9          /* Private define ------------------------------------------------------------*/
     10          
     11          
     12          
     13          
     14          /* Private macro -------------------------------------------------------------*/
     15          /* Private variables ---------------------------------------------------------*/
     16          #if defined MEDIA_USB_KEY
     17           extern __IO uint8_t Command_index;
     18           static uint32_t wavelen = 0;
     19           static char* WaveFileName ;
     20           static __IO uint32_t SpeechDataOffset = 0x00;
     21           __IO ErrorCode WaveFileStatus = Unvalid_RIFF_ID;
     22           UINT BytesRead;
     23           WAVE_FormatTypeDef WAVE_Format;
     24           uint16_t buffer1[2*_MAX_SS] ={0x00};
     25           uint16_t buffer2[2*_MAX_SS] ={0x00};
     26          
     27           uint16_t buffer1_1[_MAX_SS] ={0x00};
     28           uint16_t buffer2_1[_MAX_SS] ={0x00};
     29          
     30          
     31           uint8_t buffer_switch = 1;
     32           extern FATFS fatfs;
     33           extern FIL file;
     34           extern FIL fileR;
     35           extern DIR dir;
     36           extern FILINFO fno;
     37           extern uint16_t *CurrentPos;
     38           extern USB_OTG_CORE_HANDLE USB_OTG_Core;
     39           extern uint8_t WaveRecStatus;
     40          #endif
     41          

   \                                 In section .bss, align 4
     42          __IO uint32_t XferCplt = 0;
   \                     XferCplt:
   \   00000000                      DS8 4

   \                                 In section .data, align 1
     43          __IO uint8_t volume = 80, AudioPlayStart = 0; //sop1hc: 70
   \                     volume:
   \   00000000   0x50               DC8 80

   \                                 In section .bss, align 1
   \                     AudioPlayStart:
   \   00000000                      DS8 1

   \                                 In section .bss, align 4
     44          __IO uint32_t WaveCounter;
   \                     WaveCounter:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     45          uint8_t Buffer[6];
   \                     Buffer:
   \   00000000                      DS8 8

   \                                 In section .bss, align 4
     46          __IO uint32_t WaveDataLength = 0;
   \                     WaveDataLength:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     47          static __IO uint32_t TimingDelay;
   \                     TimingDelay:
   \   00000000                      DS8 4
     48          
     49          /* Private function prototypes -----------------------------------------------*/
     50          static void EXTILine_Config(void);
     51          
     52          /* Private functions ---------------------------------------------------------*/
     53          
     54          /**
     55            * @brief  Play wave from a mass storge
     56            * @param  AudioFreq: Audio Sampling Frequency
     57            * @retval None
     58          */
     59          

   \                                 In section .text, align 2, keep-with-next
     60          void WavePlayBack(uint32_t AudioFreq)
     61          { 
     62            /* 
     63            Normal mode description:
     64            Start playing the audio file (using DMA stream) .
     65            Using this mode, the application can run other tasks in parallel since 
     66            the DMA is handling the Audio Transfer instead of the CPU.
     67            The only task remaining for the CPU will be the management of the DMA 
     68            Transfer Complete interrupt or the Half Transfer Complete interrupt in 
     69            order to load again the buffer and to calculate the remaining data.  
     70            Circular mode description:
     71            Start playing the file from a circular buffer, once the DMA is enabled it 
     72            always run. User has to fill periodically the buffer with the audio data 
     73            using Transfer complete and/or half transfer complete interrupts callbacks 
     74            (EVAL_AUDIO_TransferComplete_CallBack() or EVAL_AUDIO_HalfTransfer_CallBack()...
     75            In this case the audio data file is smaller than the DMA max buffer 
     76            size 65535 so there is no need to load buffer continuously or manage the 
     77            transfer complete or Half transfer interrupts callbacks. */  
     78            
     79            /* Start playing */
     80            AudioPlayStart = 1;
   \                     WavePlayBack: (+1)
   \   00000000   0x2001             MOVS     R0,#+1
   \   00000002   0x....             LDR.N    R1,??DataTable3
   \   00000004   0x7008             STRB     R0,[R1, #+0]
     81          
     82          #if defined MEDIA_IntFLASH 
     83            
     84            /* Initialize wave player (Codec, DMA, I2C) */
     85            WavePlayerInit(AudioFreq); //1 sop1hc: Audio Sampling Frequency: 48000??
     86            
     87            /* Play on */
     88            //AudioFlashPlay((uint16_t*)(AUDIO_SAMPLE + AUIDO_START_ADDRESS),AUDIO_FILE_SZE,AUIDO_START_ADDRESS);
     89            // AUDIO_SAMPLE: Data
     90            //AUIDO_START_ADDRESS = 58: Offset ralative to audio file header size
     91            //AUDIO_FILE_SZE = 990000
     92            
     93            
     94            /* LED Blue Start toggling */
     95            LED_Toggle = 6;
     96            
     97            /* Infinite loop */
     98            while(1)
     99            { 
    100              /* check on the repeate status */
    101              if (RepeatState == 0)
    102              {
    103                if (PauseResumeStatus == 0)
    104                {
    105                  /* LED Blue Stop Toggling */
    106                  LED_Toggle = 0;
    107                  /* Pause playing */
    108                  WavePlayerPauseResume(PauseResumeStatus);
    109                  PauseResumeStatus = 2;
    110                }
    111                else if (PauseResumeStatus == 1)
    112                {
    113                  /* LED Blue Toggling */
    114                  LED_Toggle = 6;
    115                  /* Resume playing */
    116                  WavePlayerPauseResume(PauseResumeStatus);
    117                  PauseResumeStatus = 2;
    118                }
    119              }
    120              else
    121              {
    122                /* Stop playing */
    123                WavePlayerStop();
    124                /* Green LED toggling */
    125                LED_Toggle = 4;
    126              }
    127            }
    128            
    129          #elif defined MEDIA_USB_KEY
    130            /* Initialize wave player (Codec, DMA, I2C) */
    131            WavePlayerInit(AudioFreq);
    132            AudioRemSize   = 0; 
    133          
    134            /* Get Data from USB Key */
    135            f_lseek(&fileR, WaveCounter);
    136            f_read (&fileR, buffer1, _MAX_SS, &BytesRead); 
    137            f_read (&fileR, buffer2, _MAX_SS, &BytesRead);
    138           
    139            /* Start playing wave */
    140            Audio_MAL_Play((uint16_t *)buffer1, _MAX_SS);
    141            buffer_switch = 1;
    142            XferCplt = 0;
    143            LED_Toggle = 6;
    144            PauseResumeStatus = 1;
    145            Count = 0;
    146           
    147            while((WaveDataLength != 0) &&  HCD_IsDeviceConnected(&USB_OTG_Core))
    148            { 
    149              /* Test on the command: Playing */
    150              if (Command_index == 0)
    151              { 
    152                /* wait for DMA transfert complete */
    153                while((XferCplt == 0) &&  HCD_IsDeviceConnected(&USB_OTG_Core))
    154                {
    155                  if (PauseResumeStatus == 0)
    156                  {
    157                    /* Pause Playing wave */
    158                    LED_Toggle = 0;
    159                    WavePlayerPauseResume(PauseResumeStatus);
    160                    PauseResumeStatus = 2;
    161                  }
    162                  else if (PauseResumeStatus == 1)
    163                  {
    164                    LED_Toggle = 6;
    165                    /* Resume Playing wave */
    166                    WavePlayerPauseResume(PauseResumeStatus);
    167                    PauseResumeStatus = 2;
    168                  }  
    169                }
    170                XferCplt = 0;
    171          
    172                if(buffer_switch == 0)
    173                {
    174                  /* Play data from buffer1 */
    175                  Audio_MAL_Play((uint16_t)buffer1, _MAX_SS);
    176                  /* Store data in buffer2 */
    177                  f_read (&fileR, buffer2, _MAX_SS, &BytesRead);
    178                  buffer_switch = 1;
    179                }
    180                else 
    181                {   
    182                  /* Play data from buffer2 */
    183                  Audio_MAL_Play((uint16_t)buffer2, _MAX_SS);
    184                  /* Store data in buffer1 */
    185                  f_read (&fileR, buffer1, _MAX_SS, &BytesRead);
    186                  buffer_switch = 0;
    187                } 
    188              }
    189              else 
    190              {
    191                WavePlayerStop();
    192                WaveDataLength = 0;
    193                RepeatState =0;
    194                break;
    195              }
    196            }
    197          #if defined PLAY_REPEAT_OFF 
    198            RepeatState = 1;
    199            WavePlayerStop();
    200            if (Command_index == 0)
    201              LED_Toggle = 4;
    202          #else 
    203            LED_Toggle = 7;
    204            RepeatState = 0;
    205            AudioPlayStart = 0;
    206            WavePlayerStop();
    207          #endif
    208          #endif 
    209          
    210          }
   \   00000006   0x4770             BX       LR               ;; return
    211          
    212          /**
    213            * @brief  Pause or Resume a played wave
    214            * @param  state: if it is equal to 0 pause Playing else resume playing
    215            * @retval None
    216            */

   \                                 In section .text, align 2, keep-with-next
    217          void WavePlayerPauseResume(uint8_t state)
    218          { 
    219            AUDIO_PauseResume(state);   
   \                     WavePlayerPauseResume: (+1)
   \   00000000   0x.... 0x....      B.W      AUDIO_PauseResume
    220          }
    221          
    222          /**
    223            * @brief  Configure the volune
    224            * @param  vol: volume value
    225            * @retval None
    226            */

   \                                 In section .text, align 2, keep-with-next
    227          uint8_t WaveplayerCtrlVolume(uint8_t vol)
    228          { 
   \                     WaveplayerCtrlVolume: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    229            AUDIO_VolumeCtl(vol);
   \   00000002   0x.... 0x....      BL       AUDIO_VolumeCtl
    230            return 0;
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0xBD02             POP      {R1,PC}          ;; return
    231          }
    232          
    233          
    234          /**
    235            * @brief  Stop playing wave
    236            * @param  None
    237            * @retval None
    238            */

   \                                 In section .text, align 2, keep-with-next
    239          void WavePlayerStop(void)
    240          { 
    241            AUDIO_Stop(CODEC_PDWN_SW);
   \                     WavePlayerStop: (+1)
   \   00000000   0x2002             MOVS     R0,#+2
   \   00000002   0x.... 0x....      B.W      AUDIO_Stop
    242          }
    243           
    244          /**
    245          * @brief  Initializes the wave player
    246          * @param  AudioFreq: Audio sampling frequency
    247          * @retval None
    248          */

   \                                 In section .text, align 2, keep-with-next
    249          int WavePlayerInit(uint32_t AudioFreq)
    250          { 
    251             
    252            /* Initialize the Audio codec and all related peripherals (I2S, I2C, IOExpander, IOs...) */  
    253            AUDIO_Init(OUTPUT_DEVICE_AUTO, volume, AudioFreq );  
   \                     WavePlayerInit: (+1)
   \   00000000   0x4602             MOV      R2,R0
   \   00000002   0x....             LDR.N    R0,??DataTable3_1
   \   00000004   0xB580             PUSH     {R7,LR}
   \   00000006   0x7801             LDRB     R1,[R0, #+0]
   \   00000008   0x2004             MOVS     R0,#+4
   \   0000000A   0x.... 0x....      BL       AUDIO_Init
    254            
    255            return 0;
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0xBD02             POP      {R1,PC}          ;; return
    256          }
    257          
    258          
    259          /**
    260          * @brief  Play wave file from internal Flash
    261          * @param  None
    262          * @retval None
    263          */

   \                                 In section .text, align 2, keep-with-next
    264          uint32_t AudioFlashPlay(uint16_t* pBuffer, uint32_t FullSize, uint32_t StartAdd)
    265          { 
   \                     AudioFlashPlay: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    266            AUDIO_Play((uint16_t*)pBuffer, (FullSize - StartAdd));
   \   00000002   0x1A89             SUBS     R1,R1,R2
   \   00000004   0x.... 0x....      BL       AUDIO_Play
    267            return 0;
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0xBD02             POP      {R1,PC}          ;; return
    268          }
    269          
    270          /*--------------------------------
    271          Callbacks implementation:
    272          the callbacks prototypes are defined in the stm324xg_eval_audio_codec.h file
    273          and their implementation should be done in the user code if they are needed.
    274          Below some examples of callback implementations.
    275          --------------------------------------------------------*/
    276          /**
    277          * @brief  Calculates the remaining file size and new position of the pointer.
    278          * @param  None
    279          * @retval None
    280          */

   \                                 In section .text, align 2, keep-with-next
    281          void  AUDIO_TransferComplete_CallBack(uint32_t pBuffer, uint32_t Size)
    282          {
    283            /* Calculate the remaining audio data in the file and the new size 
    284            for the DMA transfer. If the Audio files size is less than the DMA max 
    285            data transfer size, so there is no calculation to be done, just restart 
    286            from the beginning of the file ... */
    287            /* Check if the end of file has been reached */
    288          
    289          #if defined PLAY_REPEAT_OFF
    290            LED_Toggle = 4;
    291            RepeatState = 1;
    292            EVAL_AUDIO_Stop(CODEC_PDWN_HW);
    293          #else
    294            /* Replay from the beginning */
    295           // AudioFlashPlay((uint16_t*)(AUDIO_SAMPLE + AUIDO_START_ADDRESS),AUDIO_FILE_SZE,AUIDO_START_ADDRESS);
    296          #endif  
    297            
    298          #if defined MEDIA_USB_KEY  
    299            XferCplt = 1;
    300            if (WaveDataLength>=_MAX_SS) WaveDataLength -= _MAX_SS;//sop1hc: WaveDataLength>=_MAX_SS
    301            if (WaveDataLength < _MAX_SS) WaveDataLength = 0;
    302              
    303          #endif 
    304              
    305          
    306          }
   \                     AUDIO_TransferComplete_CallBack: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    307          

   \                                 In section .text, align 2, keep-with-next
    308          void TC_Callback(struct __DMA_HandleTypeDef * hdma)
    309          {	
    310                /* Replay from the beginning */
    311             
    312          }
   \                     TC_Callback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    313          
    314          /**
    315          * @brief  Manages the DMA Half Transfer complete interrupt.
    316          * @param  None
    317          * @retval None
    318          */

   \                                 In section .text, align 2, keep-with-next
    319          void AUDIO_HalfTransfer_CallBack(uint32_t pBuffer, uint32_t Size)
    320          {  
    321          
    322          }
   \                     AUDIO_HalfTransfer_CallBack: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    323          
    324          
    325          
    326          #ifndef USE_DEFAULT_TIMEOUT_CALLBACK
    327          /**
    328            * @brief  Basic management of the timeout situation.
    329            * @param  None.
    330            * @retval None.
    331            */

   \                                 In section .text, align 2, keep-with-next
    332          uint32_t Codec_TIMEOUT_UserCallback(void)
    333          {   
    334            return (0);
   \                     Codec_TIMEOUT_UserCallback: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x4770             BX       LR               ;; return
    335          }
    336          #endif /* USE_DEFAULT_TIMEOUT_CALLBACK */
    337          /*----------------------------------------------------------------------------*/
    338          
    339          /**
    340            * @brief  Inserts a delay time.
    341            * @param  nTime: specifies the delay time length, in 10 ms.
    342            * @retval None
    343            */

   \                                 In section .text, align 2, keep-with-next
    344          void Delay(__IO uint32_t nTime)
    345          {
   \                     Delay: (+1)
   \   00000000   0xB401             PUSH     {R0}
    346            TimingDelay = nTime;
   \   00000002   0x....             LDR.N    R0,??DataTable3_2
   \   00000004   0x9900             LDR      R1,[SP, #+0]
   \   00000006   0x6001             STR      R1,[R0, #+0]
    347            
    348            while(TimingDelay != 0);
   \                     ??Delay_0: (+1)
   \   00000008   0x6801             LDR      R1,[R0, #+0]
   \   0000000A   0x2900             CMP      R1,#+0
   \   0000000C   0xD1FC             BNE.N    ??Delay_0
    349          }
   \   0000000E   0xB001             ADD      SP,SP,#+4
   \   00000010   0x4770             BX       LR               ;; return
    350          
    351          /**
    352            * @brief  Decrements the TimingDelay variable.
    353            * @param  None
    354            * @retval None
    355            */

   \                                 In section .text, align 2, keep-with-next
    356          void TimingDelay_Decrement(void)
    357          {
    358            if (TimingDelay != 0x00)
   \                     TimingDelay_Decrement: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable3_2
   \   00000002   0x6801             LDR      R1,[R0, #+0]
   \   00000004   0xB111             CBZ.N    R1,??TimingDelay_Decrement_0
    359            { 
    360              TimingDelay--;
   \   00000006   0x6801             LDR      R1,[R0, #+0]
   \   00000008   0x1E49             SUBS     R1,R1,#+1
   \   0000000A   0x6001             STR      R1,[R0, #+0]
    361            }
    362          }
   \                     ??TimingDelay_Decrement_0: (+1)
   \   0000000C   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3:
   \   00000000   0x........         DC32     AudioPlayStart

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_1:
   \   00000000   0x........         DC32     volume

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_2:
   \   00000000   0x........         DC32     TimingDelay
    363          
    364          /**
    365            * @brief  Configures EXTI Line0 (connected to PA0 pin) in interrupt mode
    366            * @param  None
    367            * @retval None
    368            */
    369          static void EXTILine_Config(void)
                             ^
Warning[Pe177]: function "EXTILine_Config" was declared but never referenced
    370          {
    371            GPIO_InitTypeDef   GPIO_InitStructure;
    372            
    373            /* Enable GPIOA clock */
    374            __GPIOE_CLK_ENABLE();
    375            /* Enable SYSCFG clock */
    376            __SYSCFG_CLK_ENABLE();
    377           
    378            /* Configure PE0 and PE1 pins as input floating */
    379            GPIO_InitStructure.Mode = GPIO_MODE_IT_RISING;
    380            GPIO_InitStructure.Pull = GPIO_NOPULL;
    381            GPIO_InitStructure.Pin = GPIO_PIN_0|GPIO_PIN_1;
    382            HAL_GPIO_Init(GPIOE, &GPIO_InitStructure);
    383          
    384            /* Connect EXTI Line to PE1 pins */
    385            //SYSCFG_EXTILineConfig(EXTI_PortSourceGPIOE, EXTI_PinSource1);
    386            
    387            HAL_NVIC_SetPriority((IRQn_Type)EXTI1_IRQn, 0x00, 0x00);
    388            HAL_NVIC_EnableIRQ((IRQn_Type)EXTI1_IRQn);
    389          
    390          }
    391          
    392          #ifdef  USE_FULL_ASSERT
    393          
    394          /**
    395          * @brief  Reports the name of the source file and the source line number
    396          *   where the assert_param error has occurred.
    397          * @param  file: pointer to the source file name
    398          * @param  line: assert_param error line source number
    399          * @retval None
    400          */
    401          void assert_failed(uint8_t* file, uint32_t line)
    402          { 
    403            /* User can add his own implementation to report the file name and line number,
    404            ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
    405            
    406            /* Infinite loop */
    407            while (1)
    408            {
    409            }
    410          }
    411          #endif
    412          
    413          /**
    414          * @}
    415          */ 
    416          
    417          
    418          /******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   AUDIO_HalfTransfer_CallBack
       0   AUDIO_TransferComplete_CallBack
       8   AudioFlashPlay
         8   -> AUDIO_Play
       0   Codec_TIMEOUT_UserCallback
       4   Delay
       0   TC_Callback
       0   TimingDelay_Decrement
       0   WavePlayBack
       8   WavePlayerInit
         8   -> AUDIO_Init
       0   WavePlayerPauseResume
         0   -> AUDIO_PauseResume
       0   WavePlayerStop
         0   -> AUDIO_Stop
       8   WaveplayerCtrlVolume
         8   -> AUDIO_VolumeCtl


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable3
       4  ??DataTable3_1
       4  ??DataTable3_2
       2  AUDIO_HalfTransfer_CallBack
       2  AUDIO_TransferComplete_CallBack
      12  AudioFlashPlay
       1  AudioPlayStart
       8  Buffer
       4  Codec_TIMEOUT_UserCallback
      18  Delay
       2  TC_Callback
       4  TimingDelay
      14  TimingDelay_Decrement
       4  WaveCounter
       4  WaveDataLength
       8  WavePlayBack
      18  WavePlayerInit
       4  WavePlayerPauseResume
       6  WavePlayerStop
      10  WaveplayerCtrlVolume
       4  XferCplt
       1  volume

 
  25 bytes in section .bss
   1 byte  in section .data
 112 bytes in section .text
 
 112 bytes of CODE memory
  26 bytes of DATA memory

Errors: none
Warnings: 1
