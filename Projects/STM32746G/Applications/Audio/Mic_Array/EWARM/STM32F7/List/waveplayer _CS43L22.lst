###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.2.10312/W32 for ARM       21/Jan/2016  18:08:46
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\sop1hc\Github\data\Mic_Array_V00\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\Src\waveplayer
#        _CS43L22.c
#    Command line =  
#        "D:\sop1hc\Github\data\Mic_Array_V00\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\Src\waveplayer
#        _CS43L22.c" -D USE_HAL_DRIVER -D STM32F746xx -D USE_STM32746G_DISCO -D
#        USE_IOEXPANDER -D USE_USB_FS -lC
#        D:\sop1hc\Github\data\Mic_Array_V00\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
#        -lA
#        D:\sop1hc\Github\data\Mic_Array_V00\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
#        -o
#        D:\sop1hc\Github\data\Mic_Array_V00\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj
#        --no_unroll --debug --endian=little --cpu=Cortex-M7 -e --fpu=VFPv5_sp
#        --dlib_config "D:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Full.h" -I
#        D:\sop1hc\Github\data\Mic_Array_V00\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\CMSIS\Device\ST\STM32F7xx\Include\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\STM32F7xx_HAL_Driver\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\STM32746G-Discovery\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\Components\Common\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Log\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Fonts\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\CPU\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_Device_Library\Core\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Core\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Class\MSC\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\drivers\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_Audio\Addons\PDM\
#        -Ohz --use_c++_inline --require_prototypes -I "D:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.3\arm\CMSIS\Include\" -D
#        ARM_MATH_CM7
#    List file    =  
#        D:\sop1hc\Github\data\Mic_Array_V00\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List\waveplayer
#        _CS43L22.lst
#    Object file  =  
#        D:\sop1hc\Github\data\Mic_Array_V00\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj\waveplayer
#        _CS43L22.o
#
###############################################################################

D:\sop1hc\Github\data\Mic_Array_V00\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\Src\waveplayer _CS43L22.c
      1          /* Includes ------------------------------------------------------------------*/
      2          #include "main.h"
      3          
      4          /** @addtogroup STM32F4-Discovery_Audio_Player_Recorder
      5          * @{
      6          */ 
      7          
      8          /* Private typedef -----------------------------------------------------------*/
      9          /* Private define ------------------------------------------------------------*/
     10          /* Private macro -------------------------------------------------------------*/
     11          /* Private variables ---------------------------------------------------------*/
     12          #if defined MEDIA_USB_KEY
     13           extern __IO uint8_t Command_index;
     14           static uint32_t wavelen = 0;
     15           static char* WaveFileName ;
     16           static __IO uint32_t SpeechDataOffset = 0x00;
     17          
     18           __IO ErrorCode WaveFileStatus = Unvalid_RIFF_ID;
     19           UINT BytesRead;
     20           WAVE_FormatTypeDef WAVE_Format;
     21           uint16_t buffer1[2*_MAX_SS] ={0x00};
     22           uint16_t buffer2[2*_MAX_SS] ={0x00};
     23          
     24          
     25          
     26          
     27           extern FATFS fatfs;
     28           extern FIL file;
     29           extern FIL fileR;
     30           extern DIR dir;
     31           extern FILINFO fno;
     32           extern uint16_t *CurrentPos;
     33           extern USB_OTG_CORE_HANDLE USB_OTG_Core;
     34           extern uint8_t WaveRecStatus;
     35          #endif
     36          extern uint8_t buffer_switch;

   \                                 In section .bss, align 4
     37          __IO uint32_t XferCplt = 0;
   \                     XferCplt:
   \   00000000                      DS8 4

   \                                 In section .data, align 1
     38          __IO uint8_t volume = 80, AudioPlayStart = 0; //sop1hc: 70
   \                     volume:
   \   00000000   0x50               DC8 80

   \                                 In section .bss, align 1
   \                     AudioPlayStart:
   \   00000000                      DS8 1

   \                                 In section .bss, align 4
     39          __IO uint32_t WaveCounter;
   \                     WaveCounter:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     40          uint8_t Buffer[6];
   \                     Buffer:
   \   00000000                      DS8 8

   \                                 In section .bss, align 4
     41          __IO uint32_t WaveDataLength = 0;
   \                     WaveDataLength:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     42          I2S_HandleTypeDef     hi2s3;
   \                     hi2s3:
   \   00000000                      DS8 64

   \                                 In section .bss, align 4
     43          static __IO uint32_t TimingDelay;
   \                     TimingDelay:
   \   00000000                      DS8 4
     44          
     45          /* Private function prototypes -----------------------------------------------*/
     46          static void EXTILine_Config(void);
     47          
     48          /* Private functions ---------------------------------------------------------*/
     49          
     50          /**
     51            * @brief  Play wave from a mass storge
     52            * @param  AudioFreq: Audio Sampling Frequency
     53            * @retval None
     54          */
     55          

   \                                 In section .text, align 2, keep-with-next
     56          void WavePlayBack(uint32_t AudioFreq)
     57          { 
     58            /* 
     59            Normal mode description:
     60            Start playing the audio file (using DMA stream) .
     61            Using this mode, the application can run other tasks in parallel since 
     62            the DMA is handling the Audio Transfer instead of the CPU.
     63            The only task remaining for the CPU will be the management of the DMA 
     64            Transfer Complete interrupt or the Half Transfer Complete interrupt in 
     65            order to load again the buffer and to calculate the remaining data.  
     66            Circular mode description:
     67            Start playing the file from a circular buffer, once the DMA is enabled it 
     68            always run. User has to fill periodically the buffer with the audio data 
     69            using Transfer complete and/or half transfer complete interrupts callbacks 
     70            (EVAL_AUDIO_TransferComplete_CallBack() or EVAL_AUDIO_HalfTransfer_CallBack()...
     71            In this case the audio data file is smaller than the DMA max buffer 
     72            size 65535 so there is no need to load buffer continuously or manage the 
     73            transfer complete or Half transfer interrupts callbacks. */  
     74            
     75            /* Start playing */
     76            AudioPlayStart = 1;
   \                     WavePlayBack: (+1)
   \   00000000   0x2001             MOVS     R0,#+1
   \   00000002   0x....             LDR.N    R1,??DataTable4
   \   00000004   0x7008             STRB     R0,[R1, #+0]
     77          
     78          #if defined MEDIA_IntFLASH 
     79            
     80            /* Initialize wave player (Codec, DMA, I2C) */
     81            WavePlayerInit(AudioFreq); //1 sop1hc: Audio Sampling Frequency: 48000??
     82            
     83            /* Play on */
     84            //AudioFlashPlay((uint16_t*)(AUDIO_SAMPLE + AUIDO_START_ADDRESS),AUDIO_FILE_SZE,AUIDO_START_ADDRESS);
     85            // AUDIO_SAMPLE: Data
     86            //AUIDO_START_ADDRESS = 58: Offset ralative to audio file header size
     87            //AUDIO_FILE_SZE = 990000
     88            
     89            
     90            /* LED Blue Start toggling */
     91            LED_Toggle = 6;
     92            
     93            /* Infinite loop */
     94            while(1)
     95            { 
     96              /* check on the repeate status */
     97              if (RepeatState == 0)
     98              {
     99                if (PauseResumeStatus == 0)
    100                {
    101                  /* LED Blue Stop Toggling */
    102                  LED_Toggle = 0;
    103                  /* Pause playing */
    104                  WavePlayerPauseResume(PauseResumeStatus);
    105                  PauseResumeStatus = 2;
    106                }
    107                else if (PauseResumeStatus == 1)
    108                {
    109                  /* LED Blue Toggling */
    110                  LED_Toggle = 6;
    111                  /* Resume playing */
    112                  WavePlayerPauseResume(PauseResumeStatus);
    113                  PauseResumeStatus = 2;
    114                }
    115              }
    116              else
    117              {
    118                /* Stop playing */
    119                WavePlayerStop();
    120                /* Green LED toggling */
    121                LED_Toggle = 4;
    122              }
    123            }
    124            
    125          #elif defined MEDIA_USB_KEY
    126            /* Initialize wave player (Codec, DMA, I2C) */
    127            WavePlayerInit(AudioFreq);
    128            AudioRemSize   = 0; 
    129          
    130            /* Get Data from USB Key */
    131            f_lseek(&fileR, WaveCounter);
    132            f_read (&fileR, buffer1, _MAX_SS, &BytesRead); 
    133            f_read (&fileR, buffer2, _MAX_SS, &BytesRead);
    134           
    135            /* Start playing wave */
    136            Audio_MAL_Play((uint16_t *)buffer1, _MAX_SS);
    137            buffer_switch = 1;
    138            XferCplt = 0;
    139            LED_Toggle = 6;
    140            PauseResumeStatus = 1;
    141            Count = 0;
    142           
    143            while((WaveDataLength != 0) &&  HCD_IsDeviceConnected(&USB_OTG_Core))
    144            { 
    145              /* Test on the command: Playing */
    146              if (Command_index == 0)
    147              { 
    148                /* wait for DMA transfert complete */
    149                while((XferCplt == 0) &&  HCD_IsDeviceConnected(&USB_OTG_Core))
    150                {
    151                  if (PauseResumeStatus == 0)
    152                  {
    153                    /* Pause Playing wave */
    154                    LED_Toggle = 0;
    155                    WavePlayerPauseResume(PauseResumeStatus);
    156                    PauseResumeStatus = 2;
    157                  }
    158                  else if (PauseResumeStatus == 1)
    159                  {
    160                    LED_Toggle = 6;
    161                    /* Resume Playing wave */
    162                    WavePlayerPauseResume(PauseResumeStatus);
    163                    PauseResumeStatus = 2;
    164                  }  
    165                }
    166                XferCplt = 0;
    167          
    168                if(buffer_switch == 0)
    169                {
    170                  /* Play data from buffer1 */
    171                  Audio_MAL_Play((uint16_t)buffer1, _MAX_SS);
    172                  /* Store data in buffer2 */
    173                  f_read (&fileR, buffer2, _MAX_SS, &BytesRead);
    174                  buffer_switch = 1;
    175                }
    176                else 
    177                {   
    178                  /* Play data from buffer2 */
    179                  Audio_MAL_Play((uint16_t)buffer2, _MAX_SS);
    180                  /* Store data in buffer1 */
    181                  f_read (&fileR, buffer1, _MAX_SS, &BytesRead);
    182                  buffer_switch = 0;
    183                } 
    184              }
    185              else 
    186              {
    187                WavePlayerStop();
    188                WaveDataLength = 0;
    189                RepeatState =0;
    190                break;
    191              }
    192            }
    193          #if defined PLAY_REPEAT_OFF 
    194            RepeatState = 1;
    195            WavePlayerStop();
    196            if (Command_index == 0)
    197              LED_Toggle = 4;
    198          #else 
    199            LED_Toggle = 7;
    200            RepeatState = 0;
    201            AudioPlayStart = 0;
    202            WavePlayerStop();
    203          #endif
    204          #endif 
    205          
    206          }
   \   00000006   0x4770             BX       LR               ;; return
    207          
    208          /**
    209            * @brief  Pause or Resume a played wave
    210            * @param  state: if it is equal to 0 pause Playing else resume playing
    211            * @retval None
    212            */

   \                                 In section .text, align 2, keep-with-next
    213          void WavePlayerPauseResume(uint8_t state)
    214          { 
    215            AUDIO_PauseResume(state);   
   \                     WavePlayerPauseResume: (+1)
   \   00000000   0x.... 0x....      B.W      AUDIO_PauseResume
    216          }
    217          
    218          /**
    219            * @brief  Configure the volune
    220            * @param  vol: volume value
    221            * @retval None
    222            */

   \                                 In section .text, align 2, keep-with-next
    223          uint8_t WaveplayerCtrlVolume(uint8_t vol)
    224          { 
   \                     WaveplayerCtrlVolume: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    225            AUDIO_VolumeCtl(vol);
   \   00000002   0x.... 0x....      BL       AUDIO_VolumeCtl
    226            return 0;
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0xBD02             POP      {R1,PC}          ;; return
    227          }
    228          
    229          
    230          /**
    231            * @brief  Stop playing wave
    232            * @param  None
    233            * @retval None
    234            */

   \                                 In section .text, align 2, keep-with-next
    235          void WavePlayerStop(void)
    236          { 
    237            AUDIO_Stop(CODEC_PDWN_SW);
   \                     WavePlayerStop: (+1)
   \   00000000   0x2002             MOVS     R0,#+2
   \   00000002   0x.... 0x....      B.W      AUDIO_Stop
    238          }
    239           
    240          /**
    241          * @brief  Initializes the wave player
    242          * @param  AudioFreq: Audio sampling frequency
    243          * @retval None
    244          */

   \                                 In section .text, align 2, keep-with-next
    245          int WavePlayerInit(uint32_t AudioFreq)
    246          { 
    247          
    248            
    249            /* Initialize the Audio codec and all related peripherals (I2S, I2C, IOExpander, IOs...) */  
    250            AUDIO_Init(OUTPUT_DEVICE_AUTO, volume, AudioFreq );  
   \                     WavePlayerInit: (+1)
   \   00000000   0x4602             MOV      R2,R0
   \   00000002   0x....             LDR.N    R0,??DataTable4_1
   \   00000004   0xB580             PUSH     {R7,LR}
   \   00000006   0x7801             LDRB     R1,[R0, #+0]
   \   00000008   0x2004             MOVS     R0,#+4
   \   0000000A   0x.... 0x....      BL       AUDIO_Init
    251            
    252            return 0;
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0xBD02             POP      {R1,PC}          ;; return
    253          }
    254          
    255          
    256          /**
    257          * @brief  Play wave file from internal Flash
    258          * @param  None
    259          * @retval None
    260          */

   \                                 In section .text, align 2, keep-with-next
    261          uint32_t AudioFlashPlay(uint16_t* pBuffer, uint32_t FullSize, uint32_t StartAdd)
    262          { 
   \                     AudioFlashPlay: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    263            AUDIO_Play((uint16_t*)pBuffer, (FullSize - StartAdd));
   \   00000002   0x1A89             SUBS     R1,R1,R2
   \   00000004   0x.... 0x....      BL       AUDIO_Play
    264            return 0;
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0xBD02             POP      {R1,PC}          ;; return
    265          }
    266          

   \                                 In section .text, align 2, keep-with-next
    267          void TC_Callback(struct __DMA_HandleTypeDef * hdma)
    268          {	
    269                /* Replay from the beginning */
    270             
    271          }
   \                     TC_Callback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    272          
    273          /**
    274          * @brief  Manages the DMA Half Transfer complete interrupt.
    275          * @param  None
    276          * @retval None
    277          */

   \                                 In section .text, align 2, keep-with-next
    278          void AUDIO_HalfTransfer_CallBack(uint32_t pBuffer, uint32_t Size)
    279          {  
    280          
    281          }
   \                     AUDIO_HalfTransfer_CallBack: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    282          
    283          
    284          
    285          #ifndef USE_DEFAULT_TIMEOUT_CALLBACK
    286          /**
    287            * @brief  Basic management of the timeout situation.
    288            * @param  None.
    289            * @retval None.
    290            */

   \                                 In section .text, align 2, keep-with-next
    291          uint32_t Codec_TIMEOUT_UserCallback(void)
    292          {   
    293            return (0);
   \                     Codec_TIMEOUT_UserCallback: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x4770             BX       LR               ;; return
    294          }
    295          #endif /* USE_DEFAULT_TIMEOUT_CALLBACK */
    296          /*----------------------------------------------------------------------------*/
    297          
    298          /**
    299            * @brief  Inserts a delay time.
    300            * @param  nTime: specifies the delay time length, in 10 ms.
    301            * @retval None
    302            */

   \                                 In section .text, align 2, keep-with-next
    303          void Delay(__IO uint32_t nTime)
    304          {
   \                     Delay: (+1)
   \   00000000   0xB401             PUSH     {R0}
    305            TimingDelay = nTime;
   \   00000002   0x....             LDR.N    R0,??DataTable4_2
   \   00000004   0x9900             LDR      R1,[SP, #+0]
   \   00000006   0x6001             STR      R1,[R0, #+0]
    306            
    307            while(TimingDelay != 0);
   \                     ??Delay_0: (+1)
   \   00000008   0x6801             LDR      R1,[R0, #+0]
   \   0000000A   0x2900             CMP      R1,#+0
   \   0000000C   0xD1FC             BNE.N    ??Delay_0
    308          }
   \   0000000E   0xB001             ADD      SP,SP,#+4
   \   00000010   0x4770             BX       LR               ;; return
    309          
    310          /**
    311            * @brief  Decrements the TimingDelay variable.
    312            * @param  None
    313            * @retval None
    314            */

   \                                 In section .text, align 2, keep-with-next
    315          void TimingDelay_Decrement(void)
    316          {
    317            if (TimingDelay != 0x00)
   \                     TimingDelay_Decrement: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable4_2
   \   00000002   0x6801             LDR      R1,[R0, #+0]
   \   00000004   0xB111             CBZ.N    R1,??TimingDelay_Decrement_0
    318            { 
    319              TimingDelay--;
   \   00000006   0x6801             LDR      R1,[R0, #+0]
   \   00000008   0x1E49             SUBS     R1,R1,#+1
   \   0000000A   0x6001             STR      R1,[R0, #+0]
    320            }
    321          }
   \                     ??TimingDelay_Decrement_0: (+1)
   \   0000000C   0x4770             BX       LR               ;; return
    322          
    323          /**
    324            * @brief  Configures EXTI Line0 (connected to PA0 pin) in interrupt mode
    325            * @param  None
    326            * @retval None
    327            */
    328          static void EXTILine_Config(void)
                             ^
Warning[Pe177]: function "EXTILine_Config" was declared but never referenced
    329          {
    330            GPIO_InitTypeDef   GPIO_InitStructure;
    331            
    332            /* Enable GPIOA clock */
    333            __GPIOE_CLK_ENABLE();
    334            /* Enable SYSCFG clock */
    335            __SYSCFG_CLK_ENABLE();
    336           
    337            /* Configure PE0 and PE1 pins as input floating */
    338            GPIO_InitStructure.Mode = GPIO_MODE_IT_RISING;
    339            GPIO_InitStructure.Pull = GPIO_NOPULL;
    340            GPIO_InitStructure.Pin = GPIO_PIN_0|GPIO_PIN_1;
    341            HAL_GPIO_Init(GPIOE, &GPIO_InitStructure);
    342          
    343            /* Connect EXTI Line to PE1 pins */
    344            //SYSCFG_EXTILineConfig(EXTI_PortSourceGPIOE, EXTI_PinSource1);
    345            
    346            HAL_NVIC_SetPriority((IRQn_Type)EXTI1_IRQn, 0x00, 0x00);
    347            HAL_NVIC_EnableIRQ((IRQn_Type)EXTI1_IRQn);
    348          
    349          }
    350          
    351          
    352          

   \                                 In section .text, align 2, keep-with-next
    353          void I2S3_Init(uint32_t AudioFreq)
    354          {
    355          
    356            // static I2S_HandleTypeDef hi2s3;
    357            /* Enable the CODEC_I2S peripheral clock */
    358            __SPI3_CLK_ENABLE();
   \                     I2S3_Init: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable4_3  ;; 0x40023840
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x680A             LDR      R2,[R1, #+0]
   \   00000006   0xF442 0x4200      ORR      R2,R2,#0x8000
   \   0000000A   0x600A             STR      R2,[R1, #+0]
   \   0000000C   0x6809             LDR      R1,[R1, #+0]
    359          
    360            hi2s3.Instance = SPI3;
   \   0000000E   0x....             LDR.N    R2,??DataTable4_4  ;; 0x40003c00
   \   00000010   0xF401 0x4100      AND      R1,R1,#0x8000
   \   00000014   0x9100             STR      R1,[SP, #+0]
   \   00000016   0x9900             LDR      R1,[SP, #+0]
   \   00000018   0x....             LDR.N    R1,??DataTable4_5
   \   0000001A   0x600A             STR      R2,[R1, #+0]
    361            /* Disable I2S3 peripheral to allow access to I2S internal registers */
    362            __HAL_I2S_DISABLE(&hi2s3);
   \   0000001C   0x69D3             LDR      R3,[R2, #+28]
   \   0000001E   0xF423 0x6380      BIC      R3,R3,#0x400
   \   00000022   0x61D3             STR      R3,[R2, #+28]
    363            
    364            hi2s3.Init.Standard = I2S_STANDARD_MSB;//I2S_STANDARD_PHILIPS
   \   00000024   0x2210             MOVS     R2,#+16
    365            hi2s3.Init.DataFormat = I2S_DATAFORMAT_16B;
    366            hi2s3.Init.AudioFreq = AudioFreq;
   \   00000026   0x6148             STR      R0,[R1, #+20]
    367            hi2s3.Init.CPOL = I2S_CPOL_LOW;
    368            hi2s3.Init.ClockSource = I2S_CLOCK_SYSCLK;
   \   00000028   0x2002             MOVS     R0,#+2
   \   0000002A   0x608A             STR      R2,[R1, #+8]
   \   0000002C   0x2200             MOVS     R2,#+0
   \   0000002E   0x61C8             STR      R0,[R1, #+28]
    369            hi2s3.Init.Mode = I2S_MODE_MASTER_TX;
   \   00000030   0xF44F 0x7000      MOV      R0,#+512
   \   00000034   0x60CA             STR      R2,[R1, #+12]
   \   00000036   0x618A             STR      R2,[R1, #+24]
   \   00000038   0x6048             STR      R0,[R1, #+4]
    370          
    371          #ifdef CODEC_MCLK_ENABLED
    372            hi2s3.Init.MCLKOutput = I2S_MCLKOUTPUT_ENABLE;
   \   0000003A   0x6108             STR      R0,[R1, #+16]
    373          #elif defined(CODEC_MCLK_DISABLED)
    374            hi2s3.Init.MCLKOutput = I2S_MCLKOUTPUT_DISABLE;
    375          #else
    376          #error "No selection for the MCLK output has been defined !"
    377          #endif /* CODEC_MCLK_ENABLED */
    378            
    379            /* Initialize the I2S peripheral with the structure above */
    380            HAL_I2S_Init(&hi2s3);
   \   0000003C   0x4608             MOV      R0,R1
   \   0000003E   0xB002             ADD      SP,SP,#+8
   \   00000040   0x.... 0x....      B.W      HAL_I2S_Init
    381           
    382           // __HAL_I2S_ENABLE(&hi2s3);
    383            
    384          
    385            /* The I2S peripheral will be enabled only in the AUDIO_Play() function 
    386                 or by user functions if DMA mode not enabled */
    387          
    388          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4:
   \   00000000   0x........         DC32     AudioPlayStart

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_1:
   \   00000000   0x........         DC32     volume

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_2:
   \   00000000   0x........         DC32     TimingDelay

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_3:
   \   00000000   0x40023840         DC32     0x40023840

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_4:
   \   00000000   0x40003C00         DC32     0x40003c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_5:
   \   00000000   0x........         DC32     hi2s3
    389          
    390          
    391          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   AUDIO_HalfTransfer_CallBack
       8   AudioFlashPlay
         8   -> AUDIO_Play
       0   Codec_TIMEOUT_UserCallback
       4   Delay
       8   I2S3_Init
         0   -> HAL_I2S_Init
       0   TC_Callback
       0   TimingDelay_Decrement
       0   WavePlayBack
       8   WavePlayerInit
         8   -> AUDIO_Init
       0   WavePlayerPauseResume
         0   -> AUDIO_PauseResume
       0   WavePlayerStop
         0   -> AUDIO_Stop
       8   WaveplayerCtrlVolume
         8   -> AUDIO_VolumeCtl


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable4
       4  ??DataTable4_1
       4  ??DataTable4_2
       4  ??DataTable4_3
       4  ??DataTable4_4
       4  ??DataTable4_5
       2  AUDIO_HalfTransfer_CallBack
      12  AudioFlashPlay
       1  AudioPlayStart
       8  Buffer
       4  Codec_TIMEOUT_UserCallback
      18  Delay
      68  I2S3_Init
       2  TC_Callback
       4  TimingDelay
      14  TimingDelay_Decrement
       4  WaveCounter
       4  WaveDataLength
       8  WavePlayBack
      18  WavePlayerInit
       4  WavePlayerPauseResume
       6  WavePlayerStop
      10  WaveplayerCtrlVolume
       4  XferCplt
      64  hi2s3
       1  volume

 
  89 bytes in section .bss
   1 byte  in section .data
 190 bytes in section .text
 
 190 bytes of CODE memory
  90 bytes of DATA memory

Errors: none
Warnings: 1
