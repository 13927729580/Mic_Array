###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.2.10312/W32 for ARM       12/Apr/2016  09:55:48
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_dma_ex.c
#    Command line =  
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_dma_ex.c
#        -D USE_HAL_DRIVER -D STM32F746xx -D USE_STM32746G_DISCO -D
#        USE_IOEXPANDER -D USE_USB_FS -lC
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
#        -lA
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
#        -o
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj
#        --no_unroll --debug --endian=little --cpu=Cortex-M7 -e --fpu=VFPv5_sp
#        --dlib_config "D:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Full.h" -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\CMSIS\Device\ST\STM32F7xx\Include\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\STM32F7xx_HAL_Driver\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\STM32746G-Discovery\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\Components\Common\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Log\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Fonts\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\CPU\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_Device_Library\Core\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Core\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Class\MSC\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\drivers\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_Audio\Addons\PDM\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_Device_Library\Class\AUDIO\Inc\
#        -Ohs --use_c++_inline --require_prototypes -I "D:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.3\arm\CMSIS\Include\" -D
#        ARM_MATH_CM7 --relaxed_fp
#    List file    =  
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List\stm32f7xx_hal_dma_ex.lst
#    Object file  =  
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj\stm32f7xx_hal_dma_ex.o
#
###############################################################################

D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_dma_ex.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f7xx_hal_dma_ex.c
      4            * @author  MCD Application Team
      5            * @version V1.0.4
      6            * @date    09-December-2015
      7            * @brief   DMA Extension HAL module driver
      8            *         This file provides firmware functions to manage the following 
      9            *         functionalities of the DMA Extension peripheral:
     10            *           + Extended features functions
     11            *
     12            @verbatim
     13            ==============================================================================
     14                                  ##### How to use this driver #####
     15            ==============================================================================
     16            [..]
     17            The DMA Extension HAL driver can be used as follows:
     18             (+) Start a multi buffer transfer using the HAL_DMA_MultiBufferStart() function
     19                 for polling mode or HAL_DMA_MultiBufferStart_IT() for interrupt mode.
     20                             
     21               -@-  In Memory-to-Memory transfer mode, Multi (Double) Buffer mode is not allowed.
     22               -@-  When Multi (Double) Buffer mode is enabled the, transfer is circular by default.
     23               -@-  In Multi (Double) buffer mode, it is possible to update the base address for 
     24                    the AHB memory port on the fly (DMA_SxM0AR or DMA_SxM1AR) when the stream is enabled. 
     25            
     26            @endverbatim
     27            ******************************************************************************
     28            * @attention
     29            *
     30            * <h2><center>&copy; COPYRIGHT(c) 2015 STMicroelectronics</center></h2>
     31            *
     32            * Redistribution and use in source and binary forms, with or without modification,
     33            * are permitted provided that the following conditions are met:
     34            *   1. Redistributions of source code must retain the above copyright notice,
     35            *      this list of conditions and the following disclaimer.
     36            *   2. Redistributions in binary form must reproduce the above copyright notice,
     37            *      this list of conditions and the following disclaimer in the documentation
     38            *      and/or other materials provided with the distribution.
     39            *   3. Neither the name of STMicroelectronics nor the names of its contributors
     40            *      may be used to endorse or promote products derived from this software
     41            *      without specific prior written permission.
     42            *
     43            * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
     44            * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     45            * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     46            * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
     47            * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
     48            * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
     49            * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
     50            * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
     51            * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
     52            * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     53            *
     54            ******************************************************************************
     55            */
     56          
     57          /* Includes ------------------------------------------------------------------*/
     58          #include "stm32f7xx_hal.h"
     59          
     60          /** @addtogroup STM32F7xx_HAL_Driver
     61            * @{
     62            */
     63          
     64          /** @defgroup DMAEx DMAEx
     65            * @brief DMA Extended HAL module driver
     66            * @{
     67            */
     68          
     69          #ifdef HAL_DMA_MODULE_ENABLED
     70          
     71          /* Private types -------------------------------------------------------------*/
     72          /* Private variables ---------------------------------------------------------*/
     73          /* Private Constants ---------------------------------------------------------*/
     74          /* Private macros ------------------------------------------------------------*/
     75          /* Private functions ---------------------------------------------------------*/
     76          /** @addtogroup DMAEx_Private_Functions
     77            * @{
     78            */
     79          
     80          static void DMA_MultiBufferSetConfig(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength);
     81          
     82          /**
     83            * @brief  Set the DMA Transfer parameter.
     84            * @param  hdma:       pointer to a DMA_HandleTypeDef structure that contains
     85            *                     the configuration information for the specified DMA Stream.  
     86            * @param  SrcAddress: The source memory Buffer address
     87            * @param  DstAddress: The destination memory Buffer address
     88            * @param  DataLength: The length of data to be transferred from source to destination
     89            * @retval HAL status
     90            */
     91          static void DMA_MultiBufferSetConfig(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
     92          {  
     93            /* Configure DMA Stream data length */
     94            hdma->Instance->NDTR = DataLength;
     95            
     96            /* Peripheral to Memory */
     97            if((hdma->Init.Direction) == DMA_MEMORY_TO_PERIPH)
     98            {   
     99              /* Configure DMA Stream destination address */
    100              hdma->Instance->PAR = DstAddress;
    101              
    102              /* Configure DMA Stream source address */
    103              hdma->Instance->M0AR = SrcAddress;
    104            }
    105            /* Memory to Peripheral */
    106            else
    107            {
    108              /* Configure DMA Stream source address */
    109              hdma->Instance->PAR = SrcAddress;
    110              
    111              /* Configure DMA Stream destination address */
    112              hdma->Instance->M0AR = DstAddress;
    113            }
    114          }
    115          
    116          /**
    117            * @}
    118            */
    119          
    120          /* Exported functions ---------------------------------------------------------*/
    121          
    122          /** @addtogroup DMAEx_Exported_Functions
    123            * @{
    124            */
    125          
    126          
    127          /** @addtogroup DMAEx_Exported_Functions_Group1
    128            *
    129          @verbatim   
    130           ===============================================================================
    131                          #####  Extended features functions  #####
    132           ===============================================================================  
    133              [..]  This section provides functions allowing to:
    134                (+) Configure the source, destination address and data length and 
    135                    Start MultiBuffer DMA transfer
    136                (+) Configure the source, destination address and data length and 
    137                    Start MultiBuffer DMA transfer with interrupt
    138                (+) Change on the fly the memory0 or memory1 address.
    139                
    140          @endverbatim
    141            * @{
    142            */
    143          
    144          
    145          /**
    146            * @brief  Starts the multi_buffer DMA Transfer.
    147            * @param  hdma      : pointer to a DMA_HandleTypeDef structure that contains
    148            *                     the configuration information for the specified DMA Stream.  
    149            * @param  SrcAddress: The source memory Buffer address
    150            * @param  DstAddress: The destination memory Buffer address
    151            * @param  SecondMemAddress: The second memory Buffer address in case of multi buffer Transfer  
    152            * @param  DataLength: The length of data to be transferred from source to destination
    153            * @retval HAL status
    154            */

   \                                 In section .text, align 2, keep-with-next
    155          HAL_StatusTypeDef HAL_DMAEx_MultiBufferStart(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t SecondMemAddress, uint32_t DataLength)
    156          {
   \                     HAL_DMAEx_MultiBufferStart: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
    157            /* Process Locked */
    158            __HAL_LOCK(hdma);
   \   00000002   0xF890 0x4034      LDRB     R4,[R0, #+52]
   \   00000006   0x2C01             CMP      R4,#+1
   \   00000008   0xBF08             IT       EQ 
   \   0000000A   0x2002             MOVEQ    R0,#+2
   \   0000000C   0xD02D             BEQ.N    ??HAL_DMAEx_MultiBufferStart_0
   \   0000000E   0x2401             MOVS     R4,#+1
   \   00000010   0xF880 0x4034      STRB     R4,[R0, #+52]
    159          
    160            /* Current memory buffer used is Memory 0 */
    161            if((hdma->Instance->CR & DMA_SxCR_CT) == 0)
   \   00000014   0x6804             LDR      R4,[R0, #+0]
   \   00000016   0x6825             LDR      R5,[R4, #+0]
   \   00000018   0x032D             LSLS     R5,R5,#+12
   \   0000001A   0xBF58             IT       PL 
   \   0000001C   0x2512             MOVPL    R5,#+18
    162            {
    163              hdma->State = HAL_DMA_STATE_BUSY_MEM0;
   \   0000001E   0xD503             BPL.N    ??HAL_DMAEx_MultiBufferStart_1
    164            }
    165            /* Current memory buffer used is Memory 1 */
    166            else if((hdma->Instance->CR & DMA_SxCR_CT) != 0)
   \   00000020   0x6825             LDR      R5,[R4, #+0]
   \   00000022   0x032D             LSLS     R5,R5,#+12
   \   00000024   0xD502             BPL.N    ??HAL_DMAEx_MultiBufferStart_2
    167            {
    168              hdma->State = HAL_DMA_STATE_BUSY_MEM1;
   \   00000026   0x2522             MOVS     R5,#+34
   \                     ??HAL_DMAEx_MultiBufferStart_1: (+1)
   \   00000028   0xF880 0x5035      STRB     R5,[R0, #+53]
    169            }
    170          
    171             /* Check the parameters */
    172            assert_param(IS_DMA_BUFFER_SIZE(DataLength));
    173          
    174            /* Disable the peripheral */
    175            __HAL_DMA_DISABLE(hdma);  
   \                     ??HAL_DMAEx_MultiBufferStart_2: (+1)
   \   0000002C   0x6825             LDR      R5,[R4, #+0]
   \   0000002E   0x086D             LSRS     R5,R5,#+1
   \   00000030   0x006D             LSLS     R5,R5,#+1
   \   00000032   0x6025             STR      R5,[R4, #+0]
    176          
    177            /* Enable the double buffer mode */
    178            hdma->Instance->CR |= (uint32_t)DMA_SxCR_DBM;
   \   00000034   0x6804             LDR      R4,[R0, #+0]
   \   00000036   0x6825             LDR      R5,[R4, #+0]
   \   00000038   0xF445 0x2580      ORR      R5,R5,#0x40000
   \   0000003C   0x6025             STR      R5,[R4, #+0]
    179          
    180            /* Configure DMA Stream destination address */
    181            hdma->Instance->M1AR = SecondMemAddress;
   \   0000003E   0x6804             LDR      R4,[R0, #+0]
   \   00000040   0x6123             STR      R3,[R4, #+16]
    182          
    183            /* Configure the source, destination address and the data length */
    184            DMA_MultiBufferSetConfig(hdma, SrcAddress, DstAddress, DataLength);
   \   00000042   0x9B02             LDR      R3,[SP, #+8]
   \   00000044   0x6804             LDR      R4,[R0, #+0]
   \   00000046   0x6063             STR      R3,[R4, #+4]
   \   00000048   0x6883             LDR      R3,[R0, #+8]
   \   0000004A   0x2B40             CMP      R3,#+64
   \   0000004C   0x6803             LDR      R3,[R0, #+0]
   \   0000004E   0xD103             BNE.N    ??HAL_DMAEx_MultiBufferStart_3
   \   00000050   0x609A             STR      R2,[R3, #+8]
   \   00000052   0x6802             LDR      R2,[R0, #+0]
   \   00000054   0x60D1             STR      R1,[R2, #+12]
   \   00000056   0xE002             B.N      ??HAL_DMAEx_MultiBufferStart_4
   \                     ??HAL_DMAEx_MultiBufferStart_3: (+1)
   \   00000058   0x6099             STR      R1,[R3, #+8]
   \   0000005A   0x6801             LDR      R1,[R0, #+0]
   \   0000005C   0x60CA             STR      R2,[R1, #+12]
    185          
    186            /* Enable the peripheral */
    187            __HAL_DMA_ENABLE(hdma);
   \                     ??HAL_DMAEx_MultiBufferStart_4: (+1)
   \   0000005E   0x6800             LDR      R0,[R0, #+0]
   \   00000060   0x6801             LDR      R1,[R0, #+0]
   \   00000062   0xF041 0x0101      ORR      R1,R1,#0x1
   \   00000066   0x6001             STR      R1,[R0, #+0]
    188          
    189            return HAL_OK;
   \   00000068   0x2000             MOVS     R0,#+0
   \                     ??HAL_DMAEx_MultiBufferStart_0: (+1)
   \   0000006A   0xBC30             POP      {R4,R5}
   \   0000006C   0x4770             BX       LR               ;; return
    190          }
    191          
    192          /**
    193            * @brief  Starts the multi_buffer DMA Transfer with interrupt enabled.
    194            * @param  hdma:       pointer to a DMA_HandleTypeDef structure that contains
    195            *                     the configuration information for the specified DMA Stream.  
    196            * @param  SrcAddress: The source memory Buffer address
    197            * @param  DstAddress: The destination memory Buffer address
    198            * @param  SecondMemAddress: The second memory Buffer address in case of multi buffer Transfer  
    199            * @param  DataLength: The length of data to be transferred from source to destination
    200            * @retval HAL status
    201            */

   \                                 In section .text, align 2, keep-with-next
    202          HAL_StatusTypeDef HAL_DMAEx_MultiBufferStart_IT(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t SecondMemAddress, uint32_t DataLength)
    203          {
   \                     HAL_DMAEx_MultiBufferStart_IT: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
    204            /* Process Locked */
    205            __HAL_LOCK(hdma);
   \   00000002   0xF890 0x4034      LDRB     R4,[R0, #+52]
   \   00000006   0x2C01             CMP      R4,#+1
   \   00000008   0xBF08             IT       EQ 
   \   0000000A   0x2002             MOVEQ    R0,#+2
   \   0000000C   0xD046             BEQ.N    ??HAL_DMAEx_MultiBufferStart_IT_0
   \   0000000E   0x2401             MOVS     R4,#+1
   \   00000010   0xF880 0x4034      STRB     R4,[R0, #+52]
    206          
    207            /* Current memory buffer used is Memory 0 */
    208            if((hdma->Instance->CR & DMA_SxCR_CT) == 0)
   \   00000014   0x6804             LDR      R4,[R0, #+0]
   \   00000016   0x6825             LDR      R5,[R4, #+0]
   \   00000018   0x032D             LSLS     R5,R5,#+12
   \   0000001A   0xBF58             IT       PL 
   \   0000001C   0x2512             MOVPL    R5,#+18
    209            {
    210              hdma->State = HAL_DMA_STATE_BUSY_MEM0;
   \   0000001E   0xD503             BPL.N    ??HAL_DMAEx_MultiBufferStart_IT_1
    211            }
    212            /* Current memory buffer used is Memory 1 */
    213            else if((hdma->Instance->CR & DMA_SxCR_CT) != 0)
   \   00000020   0x6825             LDR      R5,[R4, #+0]
   \   00000022   0x032D             LSLS     R5,R5,#+12
   \   00000024   0xD502             BPL.N    ??HAL_DMAEx_MultiBufferStart_IT_2
    214            {
    215              hdma->State = HAL_DMA_STATE_BUSY_MEM1;
   \   00000026   0x2522             MOVS     R5,#+34
   \                     ??HAL_DMAEx_MultiBufferStart_IT_1: (+1)
   \   00000028   0xF880 0x5035      STRB     R5,[R0, #+53]
    216            }
    217          
    218            /* Check the parameters */
    219            assert_param(IS_DMA_BUFFER_SIZE(DataLength));
    220          
    221            /* Disable the peripheral */
    222            __HAL_DMA_DISABLE(hdma);  
   \                     ??HAL_DMAEx_MultiBufferStart_IT_2: (+1)
   \   0000002C   0x6825             LDR      R5,[R4, #+0]
   \   0000002E   0x086D             LSRS     R5,R5,#+1
   \   00000030   0x006D             LSLS     R5,R5,#+1
   \   00000032   0x6025             STR      R5,[R4, #+0]
    223          
    224            /* Enable the Double buffer mode */
    225            hdma->Instance->CR |= (uint32_t)DMA_SxCR_DBM;
   \   00000034   0x6804             LDR      R4,[R0, #+0]
   \   00000036   0x6825             LDR      R5,[R4, #+0]
   \   00000038   0xF445 0x2580      ORR      R5,R5,#0x40000
   \   0000003C   0x6025             STR      R5,[R4, #+0]
    226          
    227            /* Configure DMA Stream destination address */
    228            hdma->Instance->M1AR = SecondMemAddress;
   \   0000003E   0x6804             LDR      R4,[R0, #+0]
   \   00000040   0x6123             STR      R3,[R4, #+16]
    229          
    230            /* Configure the source, destination address and the data length */
    231            DMA_MultiBufferSetConfig(hdma, SrcAddress, DstAddress, DataLength); 
   \   00000042   0x9B02             LDR      R3,[SP, #+8]
   \   00000044   0x6804             LDR      R4,[R0, #+0]
   \   00000046   0x6063             STR      R3,[R4, #+4]
   \   00000048   0x6883             LDR      R3,[R0, #+8]
   \   0000004A   0x2B40             CMP      R3,#+64
   \   0000004C   0x6803             LDR      R3,[R0, #+0]
   \   0000004E   0xD103             BNE.N    ??HAL_DMAEx_MultiBufferStart_IT_3
   \   00000050   0x609A             STR      R2,[R3, #+8]
   \   00000052   0x6802             LDR      R2,[R0, #+0]
   \   00000054   0x60D1             STR      R1,[R2, #+12]
   \   00000056   0xE002             B.N      ??HAL_DMAEx_MultiBufferStart_IT_4
   \                     ??HAL_DMAEx_MultiBufferStart_IT_3: (+1)
   \   00000058   0x6099             STR      R1,[R3, #+8]
   \   0000005A   0x6801             LDR      R1,[R0, #+0]
   \   0000005C   0x60CA             STR      R2,[R1, #+12]
    232          
    233            /* Enable the transfer complete interrupt */
    234            __HAL_DMA_ENABLE_IT(hdma, DMA_IT_TC);
   \                     ??HAL_DMAEx_MultiBufferStart_IT_4: (+1)
   \   0000005E   0x6801             LDR      R1,[R0, #+0]
   \   00000060   0x680A             LDR      R2,[R1, #+0]
   \   00000062   0xF042 0x0210      ORR      R2,R2,#0x10
   \   00000066   0x600A             STR      R2,[R1, #+0]
    235          
    236            /* Enable the Half transfer interrupt */
    237            __HAL_DMA_ENABLE_IT(hdma, DMA_IT_HT);
   \   00000068   0x6801             LDR      R1,[R0, #+0]
   \   0000006A   0x680A             LDR      R2,[R1, #+0]
   \   0000006C   0xF042 0x0208      ORR      R2,R2,#0x8
   \   00000070   0x600A             STR      R2,[R1, #+0]
    238          
    239            /* Enable the transfer Error interrupt */
    240            __HAL_DMA_ENABLE_IT(hdma, DMA_IT_TE);
   \   00000072   0x6801             LDR      R1,[R0, #+0]
   \   00000074   0x680A             LDR      R2,[R1, #+0]
   \   00000076   0xF042 0x0204      ORR      R2,R2,#0x4
   \   0000007A   0x600A             STR      R2,[R1, #+0]
    241          
    242            /* Enable the fifo Error interrupt */
    243            __HAL_DMA_ENABLE_IT(hdma, DMA_IT_FE);  
   \   0000007C   0x6801             LDR      R1,[R0, #+0]
   \   0000007E   0x694A             LDR      R2,[R1, #+20]
   \   00000080   0xF042 0x0280      ORR      R2,R2,#0x80
   \   00000084   0x614A             STR      R2,[R1, #+20]
    244          
    245            /* Enable the direct mode Error interrupt */
    246            __HAL_DMA_ENABLE_IT(hdma, DMA_IT_DME); 
   \   00000086   0x6801             LDR      R1,[R0, #+0]
   \   00000088   0x680A             LDR      R2,[R1, #+0]
   \   0000008A   0xF042 0x0202      ORR      R2,R2,#0x2
   \   0000008E   0x600A             STR      R2,[R1, #+0]
    247          
    248            /* Enable the peripheral */
    249            __HAL_DMA_ENABLE(hdma); 
   \   00000090   0x6800             LDR      R0,[R0, #+0]
   \   00000092   0x6801             LDR      R1,[R0, #+0]
   \   00000094   0xF041 0x0101      ORR      R1,R1,#0x1
   \   00000098   0x6001             STR      R1,[R0, #+0]
    250          
    251            return HAL_OK; 
   \   0000009A   0x2000             MOVS     R0,#+0
   \                     ??HAL_DMAEx_MultiBufferStart_IT_0: (+1)
   \   0000009C   0xBC30             POP      {R4,R5}
   \   0000009E   0x4770             BX       LR               ;; return
    252          }
    253          
    254          /**
    255            * @brief  Change the memory0 or memory1 address on the fly.
    256            * @param  hdma:       pointer to a DMA_HandleTypeDef structure that contains
    257            *                     the configuration information for the specified DMA Stream.  
    258            * @param  Address:    The new address
    259            * @param  memory:     the memory to be changed, This parameter can be one of 
    260            *                     the following values:
    261            *                      MEMORY0 /
    262            *                      MEMORY1
    263            * @note   The MEMORY0 address can be changed only when the current transfer use
    264            *         MEMORY1 and the MEMORY1 address can be changed only when the current 
    265            *         transfer use MEMORY0.
    266            * @retval HAL status
    267            */

   \                                 In section .text, align 2, keep-with-next
    268          HAL_StatusTypeDef HAL_DMAEx_ChangeMemory(DMA_HandleTypeDef *hdma, uint32_t Address, HAL_DMA_MemoryTypeDef memory)
    269          {
    270            if(memory == MEMORY0)
   \                     HAL_DMAEx_ChangeMemory: (+1)
   \   00000000   0x6800             LDR      R0,[R0, #+0]
   \   00000002   0x2A00             CMP      R2,#+0
   \   00000004   0xBF0C             ITE      EQ 
   \   00000006   0x60C1             STREQ    R1,[R0, #+12]
   \   00000008   0x6101             STRNE    R1,[R0, #+16]
    271            {
    272              /* change the memory0 address */
    273              hdma->Instance->M0AR = Address;
    274            }
    275            else
    276            {
    277              /* change the memory1 address */
    278              hdma->Instance->M1AR = Address;
    279            }
    280          
    281            return HAL_OK;
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x4770             BX       LR               ;; return
    282          }
    283          
    284          /**
    285            * @}
    286            */
    287          
    288          /**
    289            * @}
    290            */
    291          
    292          #endif /* HAL_DMA_MODULE_ENABLED */
    293          /**
    294            * @}
    295            */
    296          
    297          /**
    298            * @}
    299            */
    300          
    301          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   HAL_DMAEx_ChangeMemory
       8   HAL_DMAEx_MultiBufferStart
       8   HAL_DMAEx_MultiBufferStart_IT


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      14  HAL_DMAEx_ChangeMemory
     110  HAL_DMAEx_MultiBufferStart
     160  HAL_DMAEx_MultiBufferStart_IT

 
 284 bytes in section .text
 
 284 bytes of CODE memory

Errors: none
Warnings: none
