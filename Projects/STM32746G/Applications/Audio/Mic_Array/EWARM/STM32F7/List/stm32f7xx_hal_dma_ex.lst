###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.2.10312/W32 for ARM       22/Dec/2015  23:09:57
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_dma_ex.c
#    Command line =  
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_dma_ex.c
#        -D USE_HAL_DRIVER -D STM32F746xx -D USE_STM32746G_DISCO -D
#        USE_IOEXPANDER -D USE_USB_FS -lC
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
#        -lA
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
#        -o
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj
#        --debug --endian=little --cpu=Cortex-M7 -e --fpu=VFPv5_sp
#        --dlib_config "D:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Full.h" -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\Inc\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\CMSIS\Device\ST\STM32F7xx\Include\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\STM32F7xx_HAL_Driver\Inc\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\STM32746G-Discovery\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\Components\Common\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Log\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Fonts\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\CPU\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_Device_Library\Core\Inc\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Core\Inc\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Class\MSC\Inc\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\drivers\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_Audio\Addons\PDM\
#        -Ohz --use_c++_inline --require_prototypes -I "D:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.3\arm\CMSIS\Include\" -D
#        ARM_MATH_CM7
#    List file    =  
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List\stm32f7xx_hal_dma_ex.lst
#    Object file  =  
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj\stm32f7xx_hal_dma_ex.o
#
###############################################################################

H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_dma_ex.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f7xx_hal_dma_ex.c
      4            * @author  MCD Application Team
      5            * @version V1.0.1
      6            * @date    25-June-2015
      7            * @brief   DMA Extension HAL module driver
      8            *         This file provides firmware functions to manage the following 
      9            *         functionalities of the DMA Extension peripheral:
     10            *           + Extended features functions
     11            *
     12            @verbatim
     13            ==============================================================================
     14                                  ##### How to use this driver #####
     15            ==============================================================================
     16            [..]
     17            The DMA Extension HAL driver can be used as follows:
     18             (+) Start a multi buffer transfer using the HAL_DMA_MultiBufferStart() function
     19                 for polling mode or HAL_DMA_MultiBufferStart_IT() for interrupt mode.
     20                             
     21               -@-  In Memory-to-Memory transfer mode, Multi (Double) Buffer mode is not allowed.
     22               -@-  When Multi (Double) Buffer mode is enabled the, transfer is circular by default.
     23               -@-  In Multi (Double) buffer mode, it is possible to update the base address for 
     24                    the AHB memory port on the fly (DMA_SxM0AR or DMA_SxM1AR) when the stream is enabled. 
     25            
     26            @endverbatim
     27            ******************************************************************************
     28            * @attention
     29            *
     30            * <h2><center>&copy; COPYRIGHT(c) 2015 STMicroelectronics</center></h2>
     31            *
     32            * Redistribution and use in source and binary forms, with or without modification,
     33            * are permitted provided that the following conditions are met:
     34            *   1. Redistributions of source code must retain the above copyright notice,
     35            *      this list of conditions and the following disclaimer.
     36            *   2. Redistributions in binary form must reproduce the above copyright notice,
     37            *      this list of conditions and the following disclaimer in the documentation
     38            *      and/or other materials provided with the distribution.
     39            *   3. Neither the name of STMicroelectronics nor the names of its contributors
     40            *      may be used to endorse or promote products derived from this software
     41            *      without specific prior written permission.
     42            *
     43            * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
     44            * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     45            * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     46            * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
     47            * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
     48            * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
     49            * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
     50            * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
     51            * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
     52            * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     53            *
     54            ******************************************************************************
     55            */
     56          
     57          /* Includes ------------------------------------------------------------------*/
     58          #include "stm32f7xx_hal.h"
     59          
     60          /** @addtogroup STM32F7xx_HAL_Driver
     61            * @{
     62            */
     63          
     64          /** @defgroup DMAEx DMAEx
     65            * @brief DMA Extended HAL module driver
     66            * @{
     67            */
     68          
     69          #ifdef HAL_DMA_MODULE_ENABLED
     70          
     71          /* Private types -------------------------------------------------------------*/
     72          /* Private variables ---------------------------------------------------------*/
     73          /* Private Constants ---------------------------------------------------------*/
     74          /* Private macros ------------------------------------------------------------*/
     75          /* Private functions ---------------------------------------------------------*/
     76          /** @addtogroup DMAEx_Private_Functions
     77            * @{
     78            */
     79          
     80          static void DMA_MultiBufferSetConfig(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength);
     81          
     82          /**
     83            * @brief  Set the DMA Transfer parameter.
     84            * @param  hdma:       pointer to a DMA_HandleTypeDef structure that contains
     85            *                     the configuration information for the specified DMA Stream.  
     86            * @param  SrcAddress: The source memory Buffer address
     87            * @param  DstAddress: The destination memory Buffer address
     88            * @param  DataLength: The length of data to be transferred from source to destination
     89            * @retval HAL status
     90            */

   \                                 In section .text, align 2, keep-with-next
     91          static void DMA_MultiBufferSetConfig(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
     92          {  
   \                     DMA_MultiBufferSetConfig: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
     93            /* Configure DMA Stream data length */
     94            hdma->Instance->NDTR = DataLength;
   \   00000002   0x6804             LDR      R4,[R0, #+0]
   \   00000004   0x6063             STR      R3,[R4, #+4]
     95            
     96            /* Peripheral to Memory */
     97            if((hdma->Init.Direction) == DMA_MEMORY_TO_PERIPH)
   \   00000006   0x6880             LDR      R0,[R0, #+8]
   \   00000008   0x2840             CMP      R0,#+64
   \   0000000A   0xBF07             ITTEE    EQ 
   \   0000000C   0x60A2             STREQ    R2,[R4, #+8]
   \   0000000E   0x60E1             STREQ    R1,[R4, #+12]
   \   00000010   0x60A1             STRNE    R1,[R4, #+8]
   \   00000012   0x60E2             STRNE    R2,[R4, #+12]
     98            {   
     99              /* Configure DMA Stream destination address */
    100              hdma->Instance->PAR = DstAddress;
    101              
    102              /* Configure DMA Stream source address */
    103              hdma->Instance->M0AR = SrcAddress;
    104            }
    105            /* Memory to Peripheral */
    106            else
    107            {
    108              /* Configure DMA Stream source address */
    109              hdma->Instance->PAR = SrcAddress;
    110              
    111              /* Configure DMA Stream destination address */
    112              hdma->Instance->M0AR = DstAddress;
   \   00000014   0xBD10             POP      {R4,PC}
    113            }
    114          }
    115          
    116          /**
    117            * @}
    118            */
    119          
    120          /* Exported functions ---------------------------------------------------------*/
    121          
    122          /** @addtogroup DMAEx_Exported_Functions
    123            * @{
    124            */
    125          
    126          
    127          /** @addtogroup DMAEx_Exported_Functions_Group1
    128            *
    129          @verbatim   
    130           ===============================================================================
    131                          #####  Extended features functions  #####
    132           ===============================================================================  
    133              [..]  This section provides functions allowing to:
    134                (+) Configure the source, destination address and data length and 
    135                    Start MultiBuffer DMA transfer
    136                (+) Configure the source, destination address and data length and 
    137                    Start MultiBuffer DMA transfer with interrupt
    138                (+) Change on the fly the memory0 or memory1 address.
    139                
    140          @endverbatim
    141            * @{
    142            */
    143          
    144          
    145          /**
    146            * @brief  Starts the multi_buffer DMA Transfer.
    147            * @param  hdma      : pointer to a DMA_HandleTypeDef structure that contains
    148            *                     the configuration information for the specified DMA Stream.  
    149            * @param  SrcAddress: The source memory Buffer address
    150            * @param  DstAddress: The destination memory Buffer address
    151            * @param  SecondMemAddress: The second memory Buffer address in case of multi buffer Transfer  
    152            * @param  DataLength: The length of data to be transferred from source to destination
    153            * @retval HAL status
    154            */

   \                                 In section .text, align 2, keep-with-next
    155          HAL_StatusTypeDef HAL_DMAEx_MultiBufferStart(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t SecondMemAddress, uint32_t DataLength)
    156          {
   \                     HAL_DMAEx_MultiBufferStart: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x.... 0x....      BL       ?Subroutine2
    157            /* Process Locked */
    158            __HAL_LOCK(hdma);
   \                     ??CrossCallReturnLabel_2: (+1)
   \   00000006   0xD101             BNE.N    ??HAL_DMAEx_MultiBufferStart_0
   \   00000008   0x2002             MOVS     R0,#+2
   \   0000000A   0xBD70             POP      {R4-R6,PC}
   \                     ??HAL_DMAEx_MultiBufferStart_0: (+1)
   \   0000000C   0x.... 0x....      BL       ?Subroutine3
    159          
    160            /* Current memory buffer used is Memory 0 */
    161            if((hdma->Instance->CR & DMA_SxCR_CT) == 0)
   \                     ??CrossCallReturnLabel_4: (+1)
   \   00000010   0xBF58             IT       PL 
   \   00000012   0x2612             MOVPL    R6,#+18
    162            {
    163              hdma->State = HAL_DMA_STATE_BUSY_MEM0;
   \   00000014   0x.... 0x....      BL       ?Subroutine1
    164            }
    165            /* Current memory buffer used is Memory 1 */
    166            else if((hdma->Instance->CR & DMA_SxCR_CT) != 0)
    167            {
    168              hdma->State = HAL_DMA_STATE_BUSY_MEM1;
    169            }
    170          
    171             /* Check the parameters */
    172            assert_param(IS_DMA_BUFFER_SIZE(DataLength));
    173          
    174            /* Disable the peripheral */
    175            __HAL_DMA_DISABLE(hdma);  
    176          
    177            /* Enable the double buffer mode */
    178            hdma->Instance->CR |= (uint32_t)DMA_SxCR_DBM;
    179          
    180            /* Configure DMA Stream destination address */
    181            hdma->Instance->M1AR = SecondMemAddress;
    182          
    183            /* Configure the source, destination address and the data length */
    184            DMA_MultiBufferSetConfig(hdma, SrcAddress, DstAddress, DataLength);
    185          
    186            /* Enable the peripheral */
    187            __HAL_DMA_ENABLE(hdma);
   \                     ??CrossCallReturnLabel_1: (+1)
   \   00000018   0x....             B.N      ?Subroutine0
    188          
    189            return HAL_OK;
    190          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \   00000000   0x6820             LDR      R0,[R4, #+0]
   \   00000002   0x6801             LDR      R1,[R0, #+0]
   \   00000004   0xF041 0x0101      ORR      R1,R1,#0x1
   \   00000008   0x6001             STR      R1,[R0, #+0]
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0xBD70             POP      {R4-R6,PC}       ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine3: (+1)
   \   00000000   0x2501             MOVS     R5,#+1
   \   00000002   0x7005             STRB     R5,[R0, #+0]
   \   00000004   0x6825             LDR      R5,[R4, #+0]
   \   00000006   0x682E             LDR      R6,[R5, #+0]
   \   00000008   0x0336             LSLS     R6,R6,#+12
   \   0000000A   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine2: (+1)
   \   00000000   0x4604             MOV      R4,R0
   \   00000002   0xF104 0x0034      ADD      R0,R4,#+52
   \   00000006   0x7805             LDRB     R5,[R0, #+0]
   \   00000008   0x2D01             CMP      R5,#+1
   \   0000000A   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \   00000000   0xD503             BPL.N    ??Subroutine1_0
   \   00000002   0x682E             LDR      R6,[R5, #+0]
   \   00000004   0x0336             LSLS     R6,R6,#+12
   \   00000006   0xD501             BPL.N    ??Subroutine1_1
   \   00000008   0x2622             MOVS     R6,#+34
   \                     ??Subroutine1_0: (+1)
   \   0000000A   0x7046             STRB     R6,[R0, #+1]
   \                     ??Subroutine1_1: (+1)
   \   0000000C   0x6828             LDR      R0,[R5, #+0]
   \   0000000E   0x0840             LSRS     R0,R0,#+1
   \   00000010   0x0040             LSLS     R0,R0,#+1
   \   00000012   0x6028             STR      R0,[R5, #+0]
   \   00000014   0x6820             LDR      R0,[R4, #+0]
   \   00000016   0x6805             LDR      R5,[R0, #+0]
   \   00000018   0xF445 0x2580      ORR      R5,R5,#0x40000
   \   0000001C   0x6005             STR      R5,[R0, #+0]
   \   0000001E   0x6820             LDR      R0,[R4, #+0]
   \   00000020   0x6103             STR      R3,[R0, #+16]
   \   00000022   0x9B04             LDR      R3,[SP, #+16]
   \   00000024   0x4620             MOV      R0,R4
   \   00000026   0x....             B.N      DMA_MultiBufferSetConfig
    191          
    192          /**
    193            * @brief  Starts the multi_buffer DMA Transfer with interrupt enabled.
    194            * @param  hdma:       pointer to a DMA_HandleTypeDef structure that contains
    195            *                     the configuration information for the specified DMA Stream.  
    196            * @param  SrcAddress: The source memory Buffer address
    197            * @param  DstAddress: The destination memory Buffer address
    198            * @param  SecondMemAddress: The second memory Buffer address in case of multi buffer Transfer  
    199            * @param  DataLength: The length of data to be transferred from source to destination
    200            * @retval HAL status
    201            */

   \                                 In section .text, align 2, keep-with-next
    202          HAL_StatusTypeDef HAL_DMAEx_MultiBufferStart_IT(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t SecondMemAddress, uint32_t DataLength)
    203          {
   \                     HAL_DMAEx_MultiBufferStart_IT: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x.... 0x....      BL       ?Subroutine2
    204            /* Process Locked */
    205            __HAL_LOCK(hdma);
   \                     ??CrossCallReturnLabel_3: (+1)
   \   00000006   0xD101             BNE.N    ??HAL_DMAEx_MultiBufferStart_IT_0
   \   00000008   0x2002             MOVS     R0,#+2
   \   0000000A   0xBD70             POP      {R4-R6,PC}
   \                     ??HAL_DMAEx_MultiBufferStart_IT_0: (+1)
   \   0000000C   0x.... 0x....      BL       ?Subroutine3
    206          
    207            /* Current memory buffer used is Memory 0 */
    208            if((hdma->Instance->CR & DMA_SxCR_CT) == 0)
   \                     ??CrossCallReturnLabel_5: (+1)
   \   00000010   0xBF58             IT       PL 
   \   00000012   0x2612             MOVPL    R6,#+18
    209            {
    210              hdma->State = HAL_DMA_STATE_BUSY_MEM0;
   \   00000014   0x.... 0x....      BL       ?Subroutine1
    211            }
    212            /* Current memory buffer used is Memory 1 */
    213            else if((hdma->Instance->CR & DMA_SxCR_CT) != 0)
    214            {
    215              hdma->State = HAL_DMA_STATE_BUSY_MEM1;
    216            }
    217          
    218            /* Check the parameters */
    219            assert_param(IS_DMA_BUFFER_SIZE(DataLength));
    220          
    221            /* Disable the peripheral */
    222            __HAL_DMA_DISABLE(hdma);  
    223          
    224            /* Enable the Double buffer mode */
    225            hdma->Instance->CR |= (uint32_t)DMA_SxCR_DBM;
    226          
    227            /* Configure DMA Stream destination address */
    228            hdma->Instance->M1AR = SecondMemAddress;
    229          
    230            /* Configure the source, destination address and the data length */
    231            DMA_MultiBufferSetConfig(hdma, SrcAddress, DstAddress, DataLength); 
    232          
    233            /* Enable the transfer complete interrupt */
    234            __HAL_DMA_ENABLE_IT(hdma, DMA_IT_TC);
   \                     ??CrossCallReturnLabel_0: (+1)
   \   00000018   0x6820             LDR      R0,[R4, #+0]
   \   0000001A   0x6801             LDR      R1,[R0, #+0]
   \   0000001C   0xF041 0x0110      ORR      R1,R1,#0x10
   \   00000020   0x6001             STR      R1,[R0, #+0]
    235          
    236            /* Enable the Half transfer interrupt */
    237            __HAL_DMA_ENABLE_IT(hdma, DMA_IT_HT);
   \   00000022   0x6820             LDR      R0,[R4, #+0]
   \   00000024   0x6801             LDR      R1,[R0, #+0]
   \   00000026   0xF041 0x0108      ORR      R1,R1,#0x8
   \   0000002A   0x6001             STR      R1,[R0, #+0]
    238          
    239            /* Enable the transfer Error interrupt */
    240            __HAL_DMA_ENABLE_IT(hdma, DMA_IT_TE);
   \   0000002C   0x6820             LDR      R0,[R4, #+0]
   \   0000002E   0x6801             LDR      R1,[R0, #+0]
   \   00000030   0xF041 0x0104      ORR      R1,R1,#0x4
   \   00000034   0x6001             STR      R1,[R0, #+0]
    241          
    242            /* Enable the fifo Error interrupt */
    243            __HAL_DMA_ENABLE_IT(hdma, DMA_IT_FE);  
   \   00000036   0x6820             LDR      R0,[R4, #+0]
   \   00000038   0x6941             LDR      R1,[R0, #+20]
   \   0000003A   0xF041 0x0180      ORR      R1,R1,#0x80
   \   0000003E   0x6141             STR      R1,[R0, #+20]
    244          
    245            /* Enable the direct mode Error interrupt */
    246            __HAL_DMA_ENABLE_IT(hdma, DMA_IT_DME); 
   \   00000040   0x6820             LDR      R0,[R4, #+0]
   \   00000042   0x6801             LDR      R1,[R0, #+0]
   \   00000044   0xF041 0x0102      ORR      R1,R1,#0x2
   \   00000048   0x6001             STR      R1,[R0, #+0]
    247          
    248            /* Enable the peripheral */
    249            __HAL_DMA_ENABLE(hdma); 
   \   0000004A                      REQUIRE ?Subroutine0
   \   0000004A                      ;; // Fall through to label ?Subroutine0
    250          
    251            return HAL_OK; 
    252          }
    253          
    254          /**
    255            * @brief  Change the memory0 or memory1 address on the fly.
    256            * @param  hdma:       pointer to a DMA_HandleTypeDef structure that contains
    257            *                     the configuration information for the specified DMA Stream.  
    258            * @param  Address:    The new address
    259            * @param  memory:     the memory to be changed, This parameter can be one of 
    260            *                     the following values:
    261            *                      MEMORY0 /
    262            *                      MEMORY1
    263            * @note   The MEMORY0 address can be changed only when the current transfer use
    264            *         MEMORY1 and the MEMORY1 address can be changed only when the current 
    265            *         transfer use MEMORY0.
    266            * @retval HAL status
    267            */

   \                                 In section .text, align 2, keep-with-next
    268          HAL_StatusTypeDef HAL_DMAEx_ChangeMemory(DMA_HandleTypeDef *hdma, uint32_t Address, HAL_DMA_MemoryTypeDef memory)
    269          {
    270            if(memory == MEMORY0)
   \                     HAL_DMAEx_ChangeMemory: (+1)
   \   00000000   0x6800             LDR      R0,[R0, #+0]
   \   00000002   0x2A00             CMP      R2,#+0
   \   00000004   0xBF0C             ITE      EQ 
   \   00000006   0x60C1             STREQ    R1,[R0, #+12]
   \   00000008   0x6101             STRNE    R1,[R0, #+16]
    271            {
    272              /* change the memory0 address */
    273              hdma->Instance->M0AR = Address;
    274            }
    275            else
    276            {
    277              /* change the memory1 address */
    278              hdma->Instance->M1AR = Address;
    279            }
    280          
    281            return HAL_OK;
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x4770             BX       LR               ;; return
    282          }
    283          
    284          /**
    285            * @}
    286            */
    287          
    288          /**
    289            * @}
    290            */
    291          
    292          #endif /* HAL_DMA_MODULE_ENABLED */
    293          /**
    294            * @}
    295            */
    296          
    297          /**
    298            * @}
    299            */
    300          
    301          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   DMA_MultiBufferSetConfig
       0   HAL_DMAEx_ChangeMemory
      16   HAL_DMAEx_MultiBufferStart
        16   -> DMA_MultiBufferSetConfig
      16   HAL_DMAEx_MultiBufferStart_IT
        16   -> DMA_MultiBufferSetConfig


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      14  ?Subroutine0
      40  ?Subroutine1
      12  ?Subroutine2
      12  ?Subroutine3
      22  DMA_MultiBufferSetConfig
      14  HAL_DMAEx_ChangeMemory
      26  HAL_DMAEx_MultiBufferStart
      74  HAL_DMAEx_MultiBufferStart_IT

 
 214 bytes in section .text
 
 214 bytes of CODE memory

Errors: none
Warnings: none
