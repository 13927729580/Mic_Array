###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.2.10312/W32 for ARM       29/Mar/2016  20:10:36
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Drivers\BSP\STM32746G-Discovery\stm32746g_discovery_sdram.c
#    Command line =  
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Drivers\BSP\STM32746G-Discovery\stm32746g_discovery_sdram.c
#        -D USE_HAL_DRIVER -D STM32F746xx -D USE_STM32746G_DISCO -D
#        USE_IOEXPANDER -D USE_USB_FS -lC
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
#        -lA
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
#        -o
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M7 -e --fpu=VFPv5_sp --dlib_config "D:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.3\arm\INC\c\DLib_Config_Full.h"
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\CMSIS\Device\ST\STM32F7xx\Include\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\STM32F7xx_HAL_Driver\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\STM32746G-Discovery\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\Components\Common\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Log\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Fonts\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\CPU\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_Device_Library\Core\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Core\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Class\MSC\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\drivers\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_Audio\Addons\PDM\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_Device_Library\Class\AUDIO\Inc\
#        -On --use_c++_inline --require_prototypes -I "D:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.3\arm\CMSIS\Include\" -D
#        ARM_MATH_CM7 --relaxed_fp
#    List file    =  
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List\stm32746g_discovery_sdram.lst
#    Object file  =  
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj\stm32746g_discovery_sdram.o
#
###############################################################################

D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Drivers\BSP\STM32746G-Discovery\stm32746g_discovery_sdram.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32746g_discovery_sdram.c
      4            * @author  MCD Application Team
      5            * @version V1.0.0
      6            * @date    25-June-2015
      7            * @brief   This file includes the SDRAM driver for the MT48LC4M32B2B5-7 memory 
      8            *          device mounted on STM32746G-Discovery board.
      9            @verbatim
     10             1. How To use this driver:
     11             --------------------------
     12                - This driver is used to drive the MT48LC4M32B2B5-7 SDRAM external memory mounted
     13                  on STM32746G-Discovery board.
     14                - This driver does not need a specific component driver for the SDRAM device
     15                  to be included with.
     16             
     17             2. Driver description:
     18             ---------------------
     19               + Initialization steps:
     20                  o Initialize the SDRAM external memory using the BSP_SDRAM_Init() function. This 
     21                    function includes the MSP layer hardware resources initialization and the
     22                    FMC controller configuration to interface with the external SDRAM memory.
     23                  o It contains the SDRAM initialization sequence to program the SDRAM external 
     24                    device using the function BSP_SDRAM_Initialization_sequence(). Note that this 
     25                    sequence is standard for all SDRAM devices, but can include some differences
     26                    from a device to another. If it is the case, the right sequence should be 
     27                    implemented separately.
     28               
     29               + SDRAM read/write operations
     30                  o SDRAM external memory can be accessed with read/write operations once it is
     31                    initialized.
     32                    Read/write operation can be performed with AHB access using the functions
     33                    BSP_SDRAM_ReadData()/BSP_SDRAM_WriteData(), or by DMA transfer using the functions
     34                    BSP_SDRAM_ReadData_DMA()/BSP_SDRAM_WriteData_DMA().
     35                  o The AHB access is performed with 32-bit width transaction, the DMA transfer
     36                    configuration is fixed at single (no burst) word transfer (see the 
     37                    SDRAM_MspInit() static function).
     38                  o User can implement his own functions for read/write access with his desired 
     39                    configurations.
     40                  o If interrupt mode is used for DMA transfer, the function BSP_SDRAM_DMA_IRQHandler()
     41                    is called in IRQ handler file, to serve the generated interrupt once the DMA 
     42                    transfer is complete.
     43                  o You can send a command to the SDRAM device in runtime using the function 
     44                    BSP_SDRAM_Sendcmd(), and giving the desired command as parameter chosen between 
     45                    the predefined commands of the "FMC_SDRAM_CommandTypeDef" structure. 
     46           
     47            @endverbatim
     48            ******************************************************************************
     49            * @attention
     50            *
     51            * <h2><center>&copy; COPYRIGHT(c) 2015 STMicroelectronics</center></h2>
     52            *
     53            * Redistribution and use in source and binary forms, with or without modification,
     54            * are permitted provided that the following conditions are met:
     55            *   1. Redistributions of source code must retain the above copyright notice,
     56            *      this list of conditions and the following disclaimer.
     57            *   2. Redistributions in binary form must reproduce the above copyright notice,
     58            *      this list of conditions and the following disclaimer in the documentation
     59            *      and/or other materials provided with the distribution.
     60            *   3. Neither the name of STMicroelectronics nor the names of its contributors
     61            *      may be used to endorse or promote products derived from this software
     62            *      without specific prior written permission.
     63            *
     64            * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
     65            * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     66            * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     67            * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
     68            * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
     69            * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
     70            * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
     71            * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
     72            * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
     73            * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     74            *
     75            ******************************************************************************
     76            */
     77          
     78          /* Includes ------------------------------------------------------------------*/
     79          #include "stm32746g_discovery_sdram.h"
     80          
     81          /** @addtogroup BSP
     82            * @{
     83            */
     84          
     85          /** @addtogroup STM32746G_DISCOVERY
     86            * @{
     87            */ 
     88            
     89          /** @defgroup STM32746G_DISCOVERY_SDRAM STM32746G_DISCOVERY_SDRAM
     90            * @{
     91            */ 
     92          
     93          /** @defgroup STM32746G_DISCOVERY_SDRAM_Private_Types_Definitions STM32746G_DISCOVERY_SDRAM Private Types Definitions
     94            * @{
     95            */ 
     96          /**
     97            * @}
     98            */
     99          
    100          /** @defgroup STM32746G_DISCOVERY_SDRAM_Private_Defines STM32746G_DISCOVERY_SDRAM Private Defines
    101            * @{
    102            */
    103          /**
    104            * @}
    105            */
    106          
    107          /** @defgroup STM32746G_DISCOVERY_SDRAM_Private_Macros STM32746G_DISCOVERY_SDRAM Private Macros
    108            * @{
    109            */  
    110          /**
    111            * @}
    112            */
    113          
    114          /** @defgroup STM32746G_DISCOVERY_SDRAM_Private_Variables STM32746G_DISCOVERY_SDRAM Private Variables
    115            * @{
    116            */       

   \                                 In section .bss, align 4
    117          static SDRAM_HandleTypeDef sdramHandle;
   \                     sdramHandle:
   \   00000000                      DS8 52

   \                                 In section .bss, align 4
    118          static FMC_SDRAM_TimingTypeDef Timing;
   \                     Timing:
   \   00000000                      DS8 28

   \                                 In section .bss, align 4
    119          static FMC_SDRAM_CommandTypeDef Command;
   \                     Command:
   \   00000000                      DS8 16
    120          /**
    121            * @}
    122            */ 
    123          
    124          /** @defgroup STM32746G_DISCOVERY_SDRAM_Private_Function_Prototypes STM32746G_DISCOVERY_SDRAM Private Function Prototypes
    125            * @{
    126            */ 
    127          /**
    128            * @}
    129            */
    130              
    131          /** @defgroup STM32746G_DISCOVERY_SDRAM_Exported_Functions STM32746G_DISCOVERY_SDRAM Exported Functions
    132            * @{
    133            */ 
    134          
    135          /**
    136            * @brief  Initializes the SDRAM device.
    137            * @retval SDRAM status
    138            */

   \                                 In section .text, align 2, keep-with-next
    139          uint8_t BSP_SDRAM_Init(void)
    140          { 
   \                     BSP_SDRAM_Init: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    141            static uint8_t sdramstatus = SDRAM_ERROR;
    142            /* SDRAM device configuration */
    143            sdramHandle.Instance = FMC_SDRAM_DEVICE;
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable10  ;; 0xa0000140
   \   00000006   0x.... 0x....      LDR.W    R1,??DataTable10_1
   \   0000000A   0x6008             STR      R0,[R1, #+0]
    144              
    145            /* Timing configuration for 100Mhz as SD clock frequency (System clock is up to 200Mhz) */
    146            Timing.LoadToActiveDelay    = 2;
   \   0000000C   0x2002             MOVS     R0,#+2
   \   0000000E   0x.... 0x....      LDR.W    R1,??DataTable10_2
   \   00000012   0x6008             STR      R0,[R1, #+0]
    147            Timing.ExitSelfRefreshDelay = 7;
   \   00000014   0x2007             MOVS     R0,#+7
   \   00000016   0x.... 0x....      LDR.W    R1,??DataTable10_2
   \   0000001A   0x6048             STR      R0,[R1, #+4]
    148            Timing.SelfRefreshTime      = 4;
   \   0000001C   0x2004             MOVS     R0,#+4
   \   0000001E   0x.... 0x....      LDR.W    R1,??DataTable10_2
   \   00000022   0x6088             STR      R0,[R1, #+8]
    149            Timing.RowCycleDelay        = 7;
   \   00000024   0x2007             MOVS     R0,#+7
   \   00000026   0x.... 0x....      LDR.W    R1,??DataTable10_2
   \   0000002A   0x60C8             STR      R0,[R1, #+12]
    150            Timing.WriteRecoveryTime    = 2;
   \   0000002C   0x2002             MOVS     R0,#+2
   \   0000002E   0x.... 0x....      LDR.W    R1,??DataTable10_2
   \   00000032   0x6108             STR      R0,[R1, #+16]
    151            Timing.RPDelay              = 2;
   \   00000034   0x2002             MOVS     R0,#+2
   \   00000036   0x.... 0x....      LDR.W    R1,??DataTable10_2
   \   0000003A   0x6148             STR      R0,[R1, #+20]
    152            Timing.RCDDelay             = 2;
   \   0000003C   0x2002             MOVS     R0,#+2
   \   0000003E   0x.... 0x....      LDR.W    R1,??DataTable10_2
   \   00000042   0x6188             STR      R0,[R1, #+24]
    153            
    154            sdramHandle.Init.SDBank             = FMC_SDRAM_BANK1;
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0x.... 0x....      LDR.W    R1,??DataTable10_1
   \   0000004A   0x6048             STR      R0,[R1, #+4]
    155            sdramHandle.Init.ColumnBitsNumber   = FMC_SDRAM_COLUMN_BITS_NUM_8;
   \   0000004C   0x2000             MOVS     R0,#+0
   \   0000004E   0x.... 0x....      LDR.W    R1,??DataTable10_1
   \   00000052   0x6088             STR      R0,[R1, #+8]
    156            sdramHandle.Init.RowBitsNumber      = FMC_SDRAM_ROW_BITS_NUM_12;
   \   00000054   0x2004             MOVS     R0,#+4
   \   00000056   0x.... 0x....      LDR.W    R1,??DataTable10_1
   \   0000005A   0x60C8             STR      R0,[R1, #+12]
    157            sdramHandle.Init.MemoryDataWidth    = SDRAM_MEMORY_WIDTH;
   \   0000005C   0x2010             MOVS     R0,#+16
   \   0000005E   0x.... 0x....      LDR.W    R1,??DataTable10_1
   \   00000062   0x6108             STR      R0,[R1, #+16]
    158            sdramHandle.Init.InternalBankNumber = FMC_SDRAM_INTERN_BANKS_NUM_4;
   \   00000064   0x2040             MOVS     R0,#+64
   \   00000066   0x.... 0x....      LDR.W    R1,??DataTable10_1
   \   0000006A   0x6148             STR      R0,[R1, #+20]
    159            sdramHandle.Init.CASLatency         = FMC_SDRAM_CAS_LATENCY_2;
   \   0000006C   0xF44F 0x7080      MOV      R0,#+256
   \   00000070   0x.... 0x....      LDR.W    R1,??DataTable10_1
   \   00000074   0x6188             STR      R0,[R1, #+24]
    160            sdramHandle.Init.WriteProtection    = FMC_SDRAM_WRITE_PROTECTION_DISABLE;
   \   00000076   0x2000             MOVS     R0,#+0
   \   00000078   0x.... 0x....      LDR.W    R1,??DataTable10_1
   \   0000007C   0x61C8             STR      R0,[R1, #+28]
    161            sdramHandle.Init.SDClockPeriod      = SDCLOCK_PERIOD;
   \   0000007E   0xF44F 0x6000      MOV      R0,#+2048
   \   00000082   0x.... 0x....      LDR.W    R1,??DataTable10_1
   \   00000086   0x6208             STR      R0,[R1, #+32]
    162            sdramHandle.Init.ReadBurst          = FMC_SDRAM_RBURST_ENABLE;
   \   00000088   0xF44F 0x5080      MOV      R0,#+4096
   \   0000008C   0x.... 0x....      LDR.W    R1,??DataTable10_1
   \   00000090   0x6248             STR      R0,[R1, #+36]
    163            sdramHandle.Init.ReadPipeDelay      = FMC_SDRAM_RPIPE_DELAY_0;
   \   00000092   0x2000             MOVS     R0,#+0
   \   00000094   0x.... 0x....      LDR.W    R1,??DataTable10_1
   \   00000098   0x6288             STR      R0,[R1, #+40]
    164            
    165            /* SDRAM controller initialization */
    166          
    167            BSP_SDRAM_MspInit(&sdramHandle, NULL); /* __weak function can be rewritten by the application */
   \   0000009A   0x2100             MOVS     R1,#+0
   \   0000009C   0x.... 0x....      LDR.W    R0,??DataTable10_1
   \   000000A0   0x.... 0x....      BL       BSP_SDRAM_MspInit
    168          
    169            if(HAL_SDRAM_Init(&sdramHandle, &Timing) != HAL_OK)
   \   000000A4   0x.... 0x....      LDR.W    R1,??DataTable10_2
   \   000000A8   0x.... 0x....      LDR.W    R0,??DataTable10_1
   \   000000AC   0x.... 0x....      BL       HAL_SDRAM_Init
   \   000000B0   0x2800             CMP      R0,#+0
   \   000000B2   0xD004             BEQ.N    ??BSP_SDRAM_Init_0
    170            {
    171              sdramstatus = SDRAM_ERROR;
   \   000000B4   0x2001             MOVS     R0,#+1
   \   000000B6   0x.... 0x....      LDR.W    R1,??DataTable10_3
   \   000000BA   0x7008             STRB     R0,[R1, #+0]
   \   000000BC   0xE003             B.N      ??BSP_SDRAM_Init_1
    172            }
    173            else
    174            {
    175              sdramstatus = SDRAM_OK;
   \                     ??BSP_SDRAM_Init_0: (+1)
   \   000000BE   0x2000             MOVS     R0,#+0
   \   000000C0   0x.... 0x....      LDR.W    R1,??DataTable10_3
   \   000000C4   0x7008             STRB     R0,[R1, #+0]
    176            }
    177            
    178            /* SDRAM initialization sequence */
    179            BSP_SDRAM_Initialization_sequence(REFRESH_COUNT);
   \                     ??BSP_SDRAM_Init_1: (+1)
   \   000000C6   0xF240 0x6003      MOVW     R0,#+1539
   \   000000CA   0x.... 0x....      BL       BSP_SDRAM_Initialization_sequence
    180            
    181            return sdramstatus;
   \   000000CE   0x.... 0x....      LDR.W    R0,??DataTable10_3
   \   000000D2   0x7800             LDRB     R0,[R0, #+0]
   \   000000D4   0xBD02             POP      {R1,PC}          ;; return
    182          }

   \                                 In section .data, align 1
   \                     ??sdramstatus:
   \   00000000   0x01               DC8 1
    183          
    184          /**
    185            * @brief  DeInitializes the SDRAM device.
    186            * @retval SDRAM status
    187            */

   \                                 In section .text, align 2, keep-with-next
    188          uint8_t BSP_SDRAM_DeInit(void)
    189          { 
   \                     BSP_SDRAM_DeInit: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    190            static uint8_t sdramstatus = SDRAM_ERROR;
    191            /* SDRAM device de-initialization */
    192            sdramHandle.Instance = FMC_SDRAM_DEVICE;
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable10  ;; 0xa0000140
   \   00000006   0x.... 0x....      LDR.W    R1,??DataTable10_1
   \   0000000A   0x6008             STR      R0,[R1, #+0]
    193          
    194            if(HAL_SDRAM_DeInit(&sdramHandle) != HAL_OK)
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable10_1
   \   00000010   0x.... 0x....      BL       HAL_SDRAM_DeInit
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD004             BEQ.N    ??BSP_SDRAM_DeInit_0
    195            {
    196              sdramstatus = SDRAM_ERROR;
   \   00000018   0x2001             MOVS     R0,#+1
   \   0000001A   0x.... 0x....      LDR.W    R1,??DataTable10_4
   \   0000001E   0x7008             STRB     R0,[R1, #+0]
   \   00000020   0xE003             B.N      ??BSP_SDRAM_DeInit_1
    197            }
    198            else
    199            {
    200              sdramstatus = SDRAM_OK;
   \                     ??BSP_SDRAM_DeInit_0: (+1)
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0x.... 0x....      LDR.W    R1,??DataTable10_4
   \   00000028   0x7008             STRB     R0,[R1, #+0]
    201            }
    202            
    203            /* SDRAM controller de-initialization */
    204            BSP_SDRAM_MspDeInit(&sdramHandle, NULL);
   \                     ??BSP_SDRAM_DeInit_1: (+1)
   \   0000002A   0x2100             MOVS     R1,#+0
   \   0000002C   0x.... 0x....      LDR.W    R0,??DataTable10_1
   \   00000030   0x.... 0x....      BL       BSP_SDRAM_MspDeInit
    205            
    206            return sdramstatus;
   \   00000034   0x.... 0x....      LDR.W    R0,??DataTable10_4
   \   00000038   0x7800             LDRB     R0,[R0, #+0]
   \   0000003A   0xBD02             POP      {R1,PC}          ;; return
    207          }

   \                                 In section .data, align 1
   \                     ??sdramstatus_1:
   \   00000000   0x01               DC8 1
    208          
    209          /**
    210            * @brief  Programs the SDRAM device.
    211            * @param  RefreshCount: SDRAM refresh counter value 
    212            * @retval None
    213            */

   \                                 In section .text, align 2, keep-with-next
    214          void BSP_SDRAM_Initialization_sequence(uint32_t RefreshCount)
    215          {
   \                     BSP_SDRAM_Initialization_sequence: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0004             MOVS     R4,R0
    216            __IO uint32_t tmpmrd = 0;
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x9000             STR      R0,[SP, #+0]
    217            
    218            /* Step 1: Configure a clock configuration enable command */
    219            Command.CommandMode            = FMC_SDRAM_CMD_CLK_ENABLE;
   \   0000000A   0x2001             MOVS     R0,#+1
   \   0000000C   0x....             LDR.N    R1,??DataTable10_5
   \   0000000E   0x6008             STR      R0,[R1, #+0]
    220            Command.CommandTarget          = FMC_SDRAM_CMD_TARGET_BANK1;
   \   00000010   0x2010             MOVS     R0,#+16
   \   00000012   0x....             LDR.N    R1,??DataTable10_5
   \   00000014   0x6048             STR      R0,[R1, #+4]
    221            Command.AutoRefreshNumber      = 1;
   \   00000016   0x2001             MOVS     R0,#+1
   \   00000018   0x....             LDR.N    R1,??DataTable10_5
   \   0000001A   0x6088             STR      R0,[R1, #+8]
    222            Command.ModeRegisterDefinition = 0;
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0x....             LDR.N    R1,??DataTable10_5
   \   00000020   0x60C8             STR      R0,[R1, #+12]
    223          
    224            /* Send the command */
    225            HAL_SDRAM_SendCommand(&sdramHandle, &Command, SDRAM_TIMEOUT);
   \   00000022   0xF64F 0x72FF      MOVW     R2,#+65535
   \   00000026   0x....             LDR.N    R1,??DataTable10_5
   \   00000028   0x....             LDR.N    R0,??DataTable10_1
   \   0000002A   0x.... 0x....      BL       HAL_SDRAM_SendCommand
    226          
    227            /* Step 2: Insert 100 us minimum delay */ 
    228            /* Inserted delay is equal to 1 ms due to systick time base unit (ms) */
    229            HAL_Delay(1);
   \   0000002E   0x2001             MOVS     R0,#+1
   \   00000030   0x.... 0x....      BL       HAL_Delay
    230              
    231            /* Step 3: Configure a PALL (precharge all) command */ 
    232            Command.CommandMode            = FMC_SDRAM_CMD_PALL;
   \   00000034   0x2002             MOVS     R0,#+2
   \   00000036   0x....             LDR.N    R1,??DataTable10_5
   \   00000038   0x6008             STR      R0,[R1, #+0]
    233            Command.CommandTarget          = FMC_SDRAM_CMD_TARGET_BANK1;
   \   0000003A   0x2010             MOVS     R0,#+16
   \   0000003C   0x....             LDR.N    R1,??DataTable10_5
   \   0000003E   0x6048             STR      R0,[R1, #+4]
    234            Command.AutoRefreshNumber      = 1;
   \   00000040   0x2001             MOVS     R0,#+1
   \   00000042   0x....             LDR.N    R1,??DataTable10_5
   \   00000044   0x6088             STR      R0,[R1, #+8]
    235            Command.ModeRegisterDefinition = 0;
   \   00000046   0x2000             MOVS     R0,#+0
   \   00000048   0x....             LDR.N    R1,??DataTable10_5
   \   0000004A   0x60C8             STR      R0,[R1, #+12]
    236          
    237            /* Send the command */
    238            HAL_SDRAM_SendCommand(&sdramHandle, &Command, SDRAM_TIMEOUT);  
   \   0000004C   0xF64F 0x72FF      MOVW     R2,#+65535
   \   00000050   0x....             LDR.N    R1,??DataTable10_5
   \   00000052   0x....             LDR.N    R0,??DataTable10_1
   \   00000054   0x.... 0x....      BL       HAL_SDRAM_SendCommand
    239            
    240            /* Step 4: Configure an Auto Refresh command */ 
    241            Command.CommandMode            = FMC_SDRAM_CMD_AUTOREFRESH_MODE;
   \   00000058   0x2003             MOVS     R0,#+3
   \   0000005A   0x....             LDR.N    R1,??DataTable10_5
   \   0000005C   0x6008             STR      R0,[R1, #+0]
    242            Command.CommandTarget          = FMC_SDRAM_CMD_TARGET_BANK1;
   \   0000005E   0x2010             MOVS     R0,#+16
   \   00000060   0x....             LDR.N    R1,??DataTable10_5
   \   00000062   0x6048             STR      R0,[R1, #+4]
    243            Command.AutoRefreshNumber      = 8;
   \   00000064   0x2008             MOVS     R0,#+8
   \   00000066   0x....             LDR.N    R1,??DataTable10_5
   \   00000068   0x6088             STR      R0,[R1, #+8]
    244            Command.ModeRegisterDefinition = 0;
   \   0000006A   0x2000             MOVS     R0,#+0
   \   0000006C   0x....             LDR.N    R1,??DataTable10_5
   \   0000006E   0x60C8             STR      R0,[R1, #+12]
    245          
    246            /* Send the command */
    247            HAL_SDRAM_SendCommand(&sdramHandle, &Command, SDRAM_TIMEOUT);
   \   00000070   0xF64F 0x72FF      MOVW     R2,#+65535
   \   00000074   0x....             LDR.N    R1,??DataTable10_5
   \   00000076   0x....             LDR.N    R0,??DataTable10_1
   \   00000078   0x.... 0x....      BL       HAL_SDRAM_SendCommand
    248            
    249            /* Step 5: Program the external memory mode register */
    250            tmpmrd = (uint32_t)SDRAM_MODEREG_BURST_LENGTH_1          |\
    251                               SDRAM_MODEREG_BURST_TYPE_SEQUENTIAL   |\
    252                               SDRAM_MODEREG_CAS_LATENCY_2           |\
    253                               SDRAM_MODEREG_OPERATING_MODE_STANDARD |\
    254                               SDRAM_MODEREG_WRITEBURST_MODE_SINGLE;
   \   0000007C   0xF44F 0x7008      MOV      R0,#+544
   \   00000080   0x9000             STR      R0,[SP, #+0]
    255            
    256            Command.CommandMode            = FMC_SDRAM_CMD_LOAD_MODE;
   \   00000082   0x2004             MOVS     R0,#+4
   \   00000084   0x....             LDR.N    R1,??DataTable10_5
   \   00000086   0x6008             STR      R0,[R1, #+0]
    257            Command.CommandTarget          = FMC_SDRAM_CMD_TARGET_BANK1;
   \   00000088   0x2010             MOVS     R0,#+16
   \   0000008A   0x....             LDR.N    R1,??DataTable10_5
   \   0000008C   0x6048             STR      R0,[R1, #+4]
    258            Command.AutoRefreshNumber      = 1;
   \   0000008E   0x2001             MOVS     R0,#+1
   \   00000090   0x....             LDR.N    R1,??DataTable10_5
   \   00000092   0x6088             STR      R0,[R1, #+8]
    259            Command.ModeRegisterDefinition = tmpmrd;
   \   00000094   0x9800             LDR      R0,[SP, #+0]
   \   00000096   0x....             LDR.N    R1,??DataTable10_5
   \   00000098   0x60C8             STR      R0,[R1, #+12]
    260          
    261            /* Send the command */
    262            HAL_SDRAM_SendCommand(&sdramHandle, &Command, SDRAM_TIMEOUT);
   \   0000009A   0xF64F 0x72FF      MOVW     R2,#+65535
   \   0000009E   0x....             LDR.N    R1,??DataTable10_5
   \   000000A0   0x....             LDR.N    R0,??DataTable10_1
   \   000000A2   0x.... 0x....      BL       HAL_SDRAM_SendCommand
    263            
    264            /* Step 6: Set the refresh rate counter */
    265            /* Set the device refresh rate */
    266            HAL_SDRAM_ProgramRefreshRate(&sdramHandle, RefreshCount); 
   \   000000A6   0x0021             MOVS     R1,R4
   \   000000A8   0x....             LDR.N    R0,??DataTable10_1
   \   000000AA   0x.... 0x....      BL       HAL_SDRAM_ProgramRefreshRate
    267          }
   \   000000AE   0xBD13             POP      {R0,R1,R4,PC}    ;; return
    268          
    269          /**
    270            * @brief  Reads an amount of data from the SDRAM memory in polling mode.
    271            * @param  uwStartAddress: Read start address
    272            * @param  pData: Pointer to data to be read  
    273            * @param  uwDataSize: Size of read data from the memory
    274            * @retval SDRAM status
    275            */

   \                                 In section .text, align 2, keep-with-next
    276          uint8_t BSP_SDRAM_ReadData(uint32_t uwStartAddress, uint32_t *pData, uint32_t uwDataSize)
    277          {
   \                     BSP_SDRAM_ReadData: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    278            if(HAL_SDRAM_Read_32b(&sdramHandle, (uint32_t *)uwStartAddress, pData, uwDataSize) != HAL_OK)
   \   00000008   0x0033             MOVS     R3,R6
   \   0000000A   0x002A             MOVS     R2,R5
   \   0000000C   0x0021             MOVS     R1,R4
   \   0000000E   0x....             LDR.N    R0,??DataTable10_1
   \   00000010   0x.... 0x....      BL       HAL_SDRAM_Read_32b
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD001             BEQ.N    ??BSP_SDRAM_ReadData_0
    279            {
    280              return SDRAM_ERROR;
   \   00000018   0x2001             MOVS     R0,#+1
   \   0000001A   0xE000             B.N      ??BSP_SDRAM_ReadData_1
    281            }
    282            else
    283            {
    284              return SDRAM_OK;
   \                     ??BSP_SDRAM_ReadData_0: (+1)
   \   0000001C   0x2000             MOVS     R0,#+0
   \                     ??BSP_SDRAM_ReadData_1: (+1)
   \   0000001E   0xBD70             POP      {R4-R6,PC}       ;; return
    285            } 
    286          }
    287          
    288          /**
    289            * @brief  Reads an amount of data from the SDRAM memory in DMA mode.
    290            * @param  uwStartAddress: Read start address
    291            * @param  pData: Pointer to data to be read  
    292            * @param  uwDataSize: Size of read data from the memory
    293            * @retval SDRAM status
    294            */

   \                                 In section .text, align 2, keep-with-next
    295          uint8_t BSP_SDRAM_ReadData_DMA(uint32_t uwStartAddress, uint32_t *pData, uint32_t uwDataSize)
    296          {
   \                     BSP_SDRAM_ReadData_DMA: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    297            if(HAL_SDRAM_Read_DMA(&sdramHandle, (uint32_t *)uwStartAddress, pData, uwDataSize) != HAL_OK)
   \   00000008   0x0033             MOVS     R3,R6
   \   0000000A   0x002A             MOVS     R2,R5
   \   0000000C   0x0021             MOVS     R1,R4
   \   0000000E   0x....             LDR.N    R0,??DataTable10_1
   \   00000010   0x.... 0x....      BL       HAL_SDRAM_Read_DMA
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD001             BEQ.N    ??BSP_SDRAM_ReadData_DMA_0
    298            {
    299              return SDRAM_ERROR;
   \   00000018   0x2001             MOVS     R0,#+1
   \   0000001A   0xE000             B.N      ??BSP_SDRAM_ReadData_DMA_1
    300            }
    301            else
    302            {
    303              return SDRAM_OK;
   \                     ??BSP_SDRAM_ReadData_DMA_0: (+1)
   \   0000001C   0x2000             MOVS     R0,#+0
   \                     ??BSP_SDRAM_ReadData_DMA_1: (+1)
   \   0000001E   0xBD70             POP      {R4-R6,PC}       ;; return
    304            }     
    305          }
    306          
    307          /**
    308            * @brief  Writes an amount of data to the SDRAM memory in polling mode.
    309            * @param  uwStartAddress: Write start address
    310            * @param  pData: Pointer to data to be written  
    311            * @param  uwDataSize: Size of written data from the memory
    312            * @retval SDRAM status
    313            */

   \                                 In section .text, align 2, keep-with-next
    314          uint8_t BSP_SDRAM_WriteData(uint32_t uwStartAddress, uint32_t *pData, uint32_t uwDataSize) 
    315          {
   \                     BSP_SDRAM_WriteData: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    316            if(HAL_SDRAM_Write_32b(&sdramHandle, (uint32_t *)uwStartAddress, pData, uwDataSize) != HAL_OK)
   \   00000008   0x0033             MOVS     R3,R6
   \   0000000A   0x002A             MOVS     R2,R5
   \   0000000C   0x0021             MOVS     R1,R4
   \   0000000E   0x....             LDR.N    R0,??DataTable10_1
   \   00000010   0x.... 0x....      BL       HAL_SDRAM_Write_32b
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD001             BEQ.N    ??BSP_SDRAM_WriteData_0
    317            {
    318              return SDRAM_ERROR;
   \   00000018   0x2001             MOVS     R0,#+1
   \   0000001A   0xE000             B.N      ??BSP_SDRAM_WriteData_1
    319            }
    320            else
    321            {
    322              return SDRAM_OK;
   \                     ??BSP_SDRAM_WriteData_0: (+1)
   \   0000001C   0x2000             MOVS     R0,#+0
   \                     ??BSP_SDRAM_WriteData_1: (+1)
   \   0000001E   0xBD70             POP      {R4-R6,PC}       ;; return
    323            }
    324          }
    325          
    326          /**
    327            * @brief  Writes an amount of data to the SDRAM memory in DMA mode.
    328            * @param  uwStartAddress: Write start address
    329            * @param  pData: Pointer to data to be written  
    330            * @param  uwDataSize: Size of written data from the memory
    331            * @retval SDRAM status
    332            */

   \                                 In section .text, align 2, keep-with-next
    333          uint8_t BSP_SDRAM_WriteData_DMA(uint32_t uwStartAddress, uint32_t *pData, uint32_t uwDataSize) 
    334          {
   \                     BSP_SDRAM_WriteData_DMA: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    335            if(HAL_SDRAM_Write_DMA(&sdramHandle, (uint32_t *)uwStartAddress, pData, uwDataSize) != HAL_OK)
   \   00000008   0x0033             MOVS     R3,R6
   \   0000000A   0x002A             MOVS     R2,R5
   \   0000000C   0x0021             MOVS     R1,R4
   \   0000000E   0x....             LDR.N    R0,??DataTable10_1
   \   00000010   0x.... 0x....      BL       HAL_SDRAM_Write_DMA
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD001             BEQ.N    ??BSP_SDRAM_WriteData_DMA_0
    336            {
    337              return SDRAM_ERROR;
   \   00000018   0x2001             MOVS     R0,#+1
   \   0000001A   0xE000             B.N      ??BSP_SDRAM_WriteData_DMA_1
    338            }
    339            else
    340            {
    341              return SDRAM_OK;
   \                     ??BSP_SDRAM_WriteData_DMA_0: (+1)
   \   0000001C   0x2000             MOVS     R0,#+0
   \                     ??BSP_SDRAM_WriteData_DMA_1: (+1)
   \   0000001E   0xBD70             POP      {R4-R6,PC}       ;; return
    342            } 
    343          }
    344          
    345          /**
    346            * @brief  Sends command to the SDRAM bank.
    347            * @param  SdramCmd: Pointer to SDRAM command structure 
    348            * @retval SDRAM status
    349            */  

   \                                 In section .text, align 2, keep-with-next
    350          uint8_t BSP_SDRAM_Sendcmd(FMC_SDRAM_CommandTypeDef *SdramCmd)
    351          {
   \                     BSP_SDRAM_Sendcmd: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    352            if(HAL_SDRAM_SendCommand(&sdramHandle, SdramCmd, SDRAM_TIMEOUT) != HAL_OK)
   \   00000004   0xF64F 0x72FF      MOVW     R2,#+65535
   \   00000008   0x0021             MOVS     R1,R4
   \   0000000A   0x....             LDR.N    R0,??DataTable10_1
   \   0000000C   0x.... 0x....      BL       HAL_SDRAM_SendCommand
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD001             BEQ.N    ??BSP_SDRAM_Sendcmd_0
    353            {
    354              return SDRAM_ERROR;
   \   00000014   0x2001             MOVS     R0,#+1
   \   00000016   0xE000             B.N      ??BSP_SDRAM_Sendcmd_1
    355            }
    356            else
    357            {
    358              return SDRAM_OK;
   \                     ??BSP_SDRAM_Sendcmd_0: (+1)
   \   00000018   0x2000             MOVS     R0,#+0
   \                     ??BSP_SDRAM_Sendcmd_1: (+1)
   \   0000001A   0xBD10             POP      {R4,PC}          ;; return
    359            }
    360          }
    361          
    362          /**
    363            * @brief  Handles SDRAM DMA transfer interrupt request.
    364            * @retval None
    365            */

   \                                 In section .text, align 2, keep-with-next
    366          void BSP_SDRAM_DMA_IRQHandler(void)
    367          {
   \                     BSP_SDRAM_DMA_IRQHandler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    368            HAL_DMA_IRQHandler(sdramHandle.hdma); 
   \   00000002   0x....             LDR.N    R0,??DataTable10_1
   \   00000004   0x6B00             LDR      R0,[R0, #+48]
   \   00000006   0x.... 0x....      BL       HAL_DMA_IRQHandler
    369          }
   \   0000000A   0xBD01             POP      {R0,PC}          ;; return
    370          
    371          /**
    372            * @brief  Initializes SDRAM MSP.
    373            * @param  hsdram: SDRAM handle
    374            * @param  Params
    375            * @retval None
    376            */

   \                                 In section .text, align 2, keep-with-next
    377          __weak void BSP_SDRAM_MspInit(SDRAM_HandleTypeDef  *hsdram, void *Params)
    378          {  
   \                     BSP_SDRAM_MspInit: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB087             SUB      SP,SP,#+28
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
    379            static DMA_HandleTypeDef dma_handle;
    380            GPIO_InitTypeDef gpio_init_structure;
    381            
    382            /* Enable FMC clock */
    383            __HAL_RCC_FMC_CLK_ENABLE();
   \   00000008   0x....             LDR.N    R0,??DataTable10_6  ;; 0x40023838
   \   0000000A   0x6800             LDR      R0,[R0, #+0]
   \   0000000C   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000010   0x....             LDR.N    R1,??DataTable10_6  ;; 0x40023838
   \   00000012   0x6008             STR      R0,[R1, #+0]
   \   00000014   0x....             LDR.N    R0,??DataTable10_6  ;; 0x40023838
   \   00000016   0x6800             LDR      R0,[R0, #+0]
   \   00000018   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   0000001C   0x9000             STR      R0,[SP, #+0]
   \   0000001E   0x9800             LDR      R0,[SP, #+0]
    384            
    385            /* Enable chosen DMAx clock */
    386            __DMAx_CLK_ENABLE();
   \   00000020   0x....             LDR.N    R0,??DataTable10_7  ;; 0x40023830
   \   00000022   0x6800             LDR      R0,[R0, #+0]
   \   00000024   0xF450 0x0080      ORRS     R0,R0,#0x400000
   \   00000028   0x....             LDR.N    R1,??DataTable10_7  ;; 0x40023830
   \   0000002A   0x6008             STR      R0,[R1, #+0]
   \   0000002C   0x....             LDR.N    R0,??DataTable10_7  ;; 0x40023830
   \   0000002E   0x6800             LDR      R0,[R0, #+0]
   \   00000030   0xF410 0x0080      ANDS     R0,R0,#0x400000
   \   00000034   0x9000             STR      R0,[SP, #+0]
   \   00000036   0x9800             LDR      R0,[SP, #+0]
    387          
    388            /* Enable GPIOs clock */
    389            __HAL_RCC_GPIOC_CLK_ENABLE();
   \   00000038   0x....             LDR.N    R0,??DataTable10_7  ;; 0x40023830
   \   0000003A   0x6800             LDR      R0,[R0, #+0]
   \   0000003C   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   00000040   0x....             LDR.N    R1,??DataTable10_7  ;; 0x40023830
   \   00000042   0x6008             STR      R0,[R1, #+0]
   \   00000044   0x....             LDR.N    R0,??DataTable10_7  ;; 0x40023830
   \   00000046   0x6800             LDR      R0,[R0, #+0]
   \   00000048   0xF010 0x0004      ANDS     R0,R0,#0x4
   \   0000004C   0x9000             STR      R0,[SP, #+0]
   \   0000004E   0x9800             LDR      R0,[SP, #+0]
    390            __HAL_RCC_GPIOD_CLK_ENABLE();
   \   00000050   0x....             LDR.N    R0,??DataTable10_7  ;; 0x40023830
   \   00000052   0x6800             LDR      R0,[R0, #+0]
   \   00000054   0xF050 0x0008      ORRS     R0,R0,#0x8
   \   00000058   0x....             LDR.N    R1,??DataTable10_7  ;; 0x40023830
   \   0000005A   0x6008             STR      R0,[R1, #+0]
   \   0000005C   0x....             LDR.N    R0,??DataTable10_7  ;; 0x40023830
   \   0000005E   0x6800             LDR      R0,[R0, #+0]
   \   00000060   0xF010 0x0008      ANDS     R0,R0,#0x8
   \   00000064   0x9000             STR      R0,[SP, #+0]
   \   00000066   0x9800             LDR      R0,[SP, #+0]
    391            __HAL_RCC_GPIOE_CLK_ENABLE();
   \   00000068   0x....             LDR.N    R0,??DataTable10_7  ;; 0x40023830
   \   0000006A   0x6800             LDR      R0,[R0, #+0]
   \   0000006C   0xF050 0x0010      ORRS     R0,R0,#0x10
   \   00000070   0x....             LDR.N    R1,??DataTable10_7  ;; 0x40023830
   \   00000072   0x6008             STR      R0,[R1, #+0]
   \   00000074   0x....             LDR.N    R0,??DataTable10_7  ;; 0x40023830
   \   00000076   0x6800             LDR      R0,[R0, #+0]
   \   00000078   0xF010 0x0010      ANDS     R0,R0,#0x10
   \   0000007C   0x9000             STR      R0,[SP, #+0]
   \   0000007E   0x9800             LDR      R0,[SP, #+0]
    392            __HAL_RCC_GPIOF_CLK_ENABLE();
   \   00000080   0x....             LDR.N    R0,??DataTable10_7  ;; 0x40023830
   \   00000082   0x6800             LDR      R0,[R0, #+0]
   \   00000084   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   00000088   0x....             LDR.N    R1,??DataTable10_7  ;; 0x40023830
   \   0000008A   0x6008             STR      R0,[R1, #+0]
   \   0000008C   0x....             LDR.N    R0,??DataTable10_7  ;; 0x40023830
   \   0000008E   0x6800             LDR      R0,[R0, #+0]
   \   00000090   0xF010 0x0020      ANDS     R0,R0,#0x20
   \   00000094   0x9000             STR      R0,[SP, #+0]
   \   00000096   0x9800             LDR      R0,[SP, #+0]
    393            __HAL_RCC_GPIOG_CLK_ENABLE();
   \   00000098   0x....             LDR.N    R0,??DataTable10_7  ;; 0x40023830
   \   0000009A   0x6800             LDR      R0,[R0, #+0]
   \   0000009C   0xF050 0x0040      ORRS     R0,R0,#0x40
   \   000000A0   0x....             LDR.N    R1,??DataTable10_7  ;; 0x40023830
   \   000000A2   0x6008             STR      R0,[R1, #+0]
   \   000000A4   0x....             LDR.N    R0,??DataTable10_7  ;; 0x40023830
   \   000000A6   0x6800             LDR      R0,[R0, #+0]
   \   000000A8   0xF010 0x0040      ANDS     R0,R0,#0x40
   \   000000AC   0x9000             STR      R0,[SP, #+0]
   \   000000AE   0x9800             LDR      R0,[SP, #+0]
    394            __HAL_RCC_GPIOH_CLK_ENABLE();
   \   000000B0   0x....             LDR.N    R0,??DataTable10_7  ;; 0x40023830
   \   000000B2   0x6800             LDR      R0,[R0, #+0]
   \   000000B4   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   000000B8   0x....             LDR.N    R1,??DataTable10_7  ;; 0x40023830
   \   000000BA   0x6008             STR      R0,[R1, #+0]
   \   000000BC   0x....             LDR.N    R0,??DataTable10_7  ;; 0x40023830
   \   000000BE   0x6800             LDR      R0,[R0, #+0]
   \   000000C0   0xF010 0x0080      ANDS     R0,R0,#0x80
   \   000000C4   0x9000             STR      R0,[SP, #+0]
   \   000000C6   0x9800             LDR      R0,[SP, #+0]
    395            
    396            /* Common GPIO configuration */
    397            gpio_init_structure.Mode      = GPIO_MODE_AF_PP;
   \   000000C8   0x2002             MOVS     R0,#+2
   \   000000CA   0x9002             STR      R0,[SP, #+8]
    398            gpio_init_structure.Pull      = GPIO_PULLUP;
   \   000000CC   0x2001             MOVS     R0,#+1
   \   000000CE   0x9003             STR      R0,[SP, #+12]
    399            gpio_init_structure.Speed     = GPIO_SPEED_FAST;
   \   000000D0   0x2002             MOVS     R0,#+2
   \   000000D2   0x9004             STR      R0,[SP, #+16]
    400            gpio_init_structure.Alternate = GPIO_AF12_FMC;
   \   000000D4   0x200C             MOVS     R0,#+12
   \   000000D6   0x9005             STR      R0,[SP, #+20]
    401            
    402            /* GPIOC configuration */
    403            gpio_init_structure.Pin   = GPIO_PIN_3;
   \   000000D8   0x2008             MOVS     R0,#+8
   \   000000DA   0x9001             STR      R0,[SP, #+4]
    404            HAL_GPIO_Init(GPIOC, &gpio_init_structure);
   \   000000DC   0xA901             ADD      R1,SP,#+4
   \   000000DE   0x....             LDR.N    R0,??DataTable10_8  ;; 0x40020800
   \   000000E0   0x.... 0x....      BL       HAL_GPIO_Init
    405          
    406            /* GPIOD configuration */
    407            gpio_init_structure.Pin   = GPIO_PIN_0 | GPIO_PIN_1 | GPIO_PIN_3 | GPIO_PIN_8 | GPIO_PIN_9 |
    408                                        GPIO_PIN_10 | GPIO_PIN_14 | GPIO_PIN_15;
   \   000000E4   0xF24C 0x700B      MOVW     R0,#+50955
   \   000000E8   0x9001             STR      R0,[SP, #+4]
    409            HAL_GPIO_Init(GPIOD, &gpio_init_structure);
   \   000000EA   0xA901             ADD      R1,SP,#+4
   \   000000EC   0x....             LDR.N    R0,??DataTable10_9  ;; 0x40020c00
   \   000000EE   0x.... 0x....      BL       HAL_GPIO_Init
    410          
    411            /* GPIOE configuration */  
    412            gpio_init_structure.Pin   = GPIO_PIN_0 | GPIO_PIN_1 | GPIO_PIN_7| GPIO_PIN_8 | GPIO_PIN_9 |\
    413                                        GPIO_PIN_10 | GPIO_PIN_11 | GPIO_PIN_12 | GPIO_PIN_13 | GPIO_PIN_14 |\
    414                                        GPIO_PIN_15;
   \   000000F2   0xF64F 0x7083      MOVW     R0,#+65411
   \   000000F6   0x9001             STR      R0,[SP, #+4]
    415            HAL_GPIO_Init(GPIOE, &gpio_init_structure);
   \   000000F8   0xA901             ADD      R1,SP,#+4
   \   000000FA   0x....             LDR.N    R0,??DataTable10_10  ;; 0x40021000
   \   000000FC   0x.... 0x....      BL       HAL_GPIO_Init
    416            
    417            /* GPIOF configuration */  
    418            gpio_init_structure.Pin   = GPIO_PIN_0 | GPIO_PIN_1 | GPIO_PIN_2| GPIO_PIN_3 | GPIO_PIN_4 |\
    419                                        GPIO_PIN_5 | GPIO_PIN_11 | GPIO_PIN_12 | GPIO_PIN_13 | GPIO_PIN_14 |\
    420                                        GPIO_PIN_15;
   \   00000100   0xF64F 0x003F      MOVW     R0,#+63551
   \   00000104   0x9001             STR      R0,[SP, #+4]
    421            HAL_GPIO_Init(GPIOF, &gpio_init_structure);
   \   00000106   0xA901             ADD      R1,SP,#+4
   \   00000108   0x....             LDR.N    R0,??DataTable10_11  ;; 0x40021400
   \   0000010A   0x.... 0x....      BL       HAL_GPIO_Init
    422            
    423            /* GPIOG configuration */  
    424            gpio_init_structure.Pin   = GPIO_PIN_0 | GPIO_PIN_1 | GPIO_PIN_4| GPIO_PIN_5 | GPIO_PIN_8 |\
    425                                        GPIO_PIN_15;
   \   0000010E   0xF248 0x1033      MOVW     R0,#+33075
   \   00000112   0x9001             STR      R0,[SP, #+4]
    426            HAL_GPIO_Init(GPIOG, &gpio_init_structure);
   \   00000114   0xA901             ADD      R1,SP,#+4
   \   00000116   0x....             LDR.N    R0,??DataTable10_12  ;; 0x40021800
   \   00000118   0x.... 0x....      BL       HAL_GPIO_Init
    427          
    428            /* GPIOH configuration */  
    429            gpio_init_structure.Pin   = GPIO_PIN_3 | GPIO_PIN_5;
   \   0000011C   0x2028             MOVS     R0,#+40
   \   0000011E   0x9001             STR      R0,[SP, #+4]
    430            HAL_GPIO_Init(GPIOH, &gpio_init_structure); 
   \   00000120   0xA901             ADD      R1,SP,#+4
   \   00000122   0x....             LDR.N    R0,??DataTable10_13  ;; 0x40021c00
   \   00000124   0x.... 0x....      BL       HAL_GPIO_Init
    431            
    432            /* Configure common DMA parameters */
    433            dma_handle.Init.Channel             = SDRAM_DMAx_CHANNEL;
   \   00000128   0x2000             MOVS     R0,#+0
   \   0000012A   0x....             LDR.N    R1,??DataTable10_14
   \   0000012C   0x6048             STR      R0,[R1, #+4]
    434            dma_handle.Init.Direction           = DMA_MEMORY_TO_MEMORY;
   \   0000012E   0x2080             MOVS     R0,#+128
   \   00000130   0x....             LDR.N    R1,??DataTable10_14
   \   00000132   0x6088             STR      R0,[R1, #+8]
    435            dma_handle.Init.PeriphInc           = DMA_PINC_ENABLE;
   \   00000134   0xF44F 0x7000      MOV      R0,#+512
   \   00000138   0x....             LDR.N    R1,??DataTable10_14
   \   0000013A   0x60C8             STR      R0,[R1, #+12]
    436            dma_handle.Init.MemInc              = DMA_MINC_ENABLE;
   \   0000013C   0xF44F 0x6080      MOV      R0,#+1024
   \   00000140   0x....             LDR.N    R1,??DataTable10_14
   \   00000142   0x6108             STR      R0,[R1, #+16]
    437            dma_handle.Init.PeriphDataAlignment = DMA_PDATAALIGN_WORD;
   \   00000144   0xF44F 0x5080      MOV      R0,#+4096
   \   00000148   0x....             LDR.N    R1,??DataTable10_14
   \   0000014A   0x6148             STR      R0,[R1, #+20]
    438            dma_handle.Init.MemDataAlignment    = DMA_MDATAALIGN_WORD;
   \   0000014C   0xF44F 0x4080      MOV      R0,#+16384
   \   00000150   0x....             LDR.N    R1,??DataTable10_14
   \   00000152   0x6188             STR      R0,[R1, #+24]
    439            dma_handle.Init.Mode                = DMA_NORMAL;
   \   00000154   0x2000             MOVS     R0,#+0
   \   00000156   0x....             LDR.N    R1,??DataTable10_14
   \   00000158   0x61C8             STR      R0,[R1, #+28]
    440            dma_handle.Init.Priority            = DMA_PRIORITY_HIGH;
   \   0000015A   0xF45F 0x3000      MOVS     R0,#+131072
   \   0000015E   0x....             LDR.N    R1,??DataTable10_14
   \   00000160   0x6208             STR      R0,[R1, #+32]
    441            dma_handle.Init.FIFOMode            = DMA_FIFOMODE_DISABLE;         
   \   00000162   0x2000             MOVS     R0,#+0
   \   00000164   0x....             LDR.N    R1,??DataTable10_14
   \   00000166   0x6248             STR      R0,[R1, #+36]
    442            dma_handle.Init.FIFOThreshold       = DMA_FIFO_THRESHOLD_FULL;
   \   00000168   0x2003             MOVS     R0,#+3
   \   0000016A   0x....             LDR.N    R1,??DataTable10_14
   \   0000016C   0x6288             STR      R0,[R1, #+40]
    443            dma_handle.Init.MemBurst            = DMA_MBURST_SINGLE;
   \   0000016E   0x2000             MOVS     R0,#+0
   \   00000170   0x....             LDR.N    R1,??DataTable10_14
   \   00000172   0x62C8             STR      R0,[R1, #+44]
    444            dma_handle.Init.PeriphBurst         = DMA_PBURST_SINGLE; 
   \   00000174   0x2000             MOVS     R0,#+0
   \   00000176   0x....             LDR.N    R1,??DataTable10_14
   \   00000178   0x6308             STR      R0,[R1, #+48]
    445            
    446            dma_handle.Instance = SDRAM_DMAx_STREAM;
   \   0000017A   0x....             LDR.N    R0,??DataTable10_15  ;; 0x40026410
   \   0000017C   0x....             LDR.N    R1,??DataTable10_14
   \   0000017E   0x6008             STR      R0,[R1, #+0]
    447            
    448             /* Associate the DMA handle */
    449            __HAL_LINKDMA(hsdram, hdma, dma_handle);
   \   00000180   0x....             LDR.N    R0,??DataTable10_14
   \   00000182   0x6320             STR      R0,[R4, #+48]
   \   00000184   0x....             LDR.N    R0,??DataTable10_14
   \   00000186   0x6384             STR      R4,[R0, #+56]
    450            
    451            /* Deinitialize the stream for new transfer */
    452            HAL_DMA_DeInit(&dma_handle);
   \   00000188   0x....             LDR.N    R0,??DataTable10_14
   \   0000018A   0x.... 0x....      BL       HAL_DMA_DeInit
    453            
    454            /* Configure the DMA stream */
    455            HAL_DMA_Init(&dma_handle); 
   \   0000018E   0x....             LDR.N    R0,??DataTable10_14
   \   00000190   0x.... 0x....      BL       HAL_DMA_Init
    456            
    457            /* NVIC configuration for DMA transfer complete interrupt */
    458            HAL_NVIC_SetPriority(SDRAM_DMAx_IRQn, 5, 0);
   \   00000194   0x2200             MOVS     R2,#+0
   \   00000196   0x2105             MOVS     R1,#+5
   \   00000198   0x2038             MOVS     R0,#+56
   \   0000019A   0x.... 0x....      BL       HAL_NVIC_SetPriority
    459            HAL_NVIC_EnableIRQ(SDRAM_DMAx_IRQn);
   \   0000019E   0x2038             MOVS     R0,#+56
   \   000001A0   0x.... 0x....      BL       HAL_NVIC_EnableIRQ
    460          }
   \   000001A4   0xB007             ADD      SP,SP,#+28
   \   000001A6   0xBD30             POP      {R4,R5,PC}       ;; return

   \                                 In section .bss, align 4
   \                     ??dma_handle:
   \   00000000                      DS8 80
    461          
    462          /**
    463            * @brief  DeInitializes SDRAM MSP.
    464            * @param  hsdram: SDRAM handle
    465            * @param  Params
    466            * @retval None
    467            */

   \                                 In section .text, align 2, keep-with-next
    468          __weak void BSP_SDRAM_MspDeInit(SDRAM_HandleTypeDef  *hsdram, void *Params)
    469          {  
   \                     BSP_SDRAM_MspDeInit: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    470              static DMA_HandleTypeDef dma_handle;
    471            
    472              /* Disable NVIC configuration for DMA interrupt */
    473              HAL_NVIC_DisableIRQ(SDRAM_DMAx_IRQn);
   \   00000006   0x2038             MOVS     R0,#+56
   \   00000008   0x.... 0x....      BL       HAL_NVIC_DisableIRQ
    474          
    475              /* Deinitialize the stream for new transfer */
    476              dma_handle.Instance = SDRAM_DMAx_STREAM;
   \   0000000C   0x....             LDR.N    R0,??DataTable10_15  ;; 0x40026410
   \   0000000E   0x....             LDR.N    R1,??DataTable10_16
   \   00000010   0x6008             STR      R0,[R1, #+0]
    477              HAL_DMA_DeInit(&dma_handle);
   \   00000012   0x....             LDR.N    R0,??DataTable10_16
   \   00000014   0x.... 0x....      BL       HAL_DMA_DeInit
    478          
    479              /* GPIO pins clock, FMC clock and DMA clock can be shut down in the applications
    480                 by surcharging this __weak function */ 
    481          }
   \   00000018   0xBD31             POP      {R0,R4,R5,PC}    ;; return

   \                                 In section .bss, align 4
   \                     ??dma_handle_1:
   \   00000000                      DS8 80

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10:
   \   00000000   0xA0000140         DC32     0xa0000140

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_1:
   \   00000000   0x........         DC32     sdramHandle

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_2:
   \   00000000   0x........         DC32     Timing

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_3:
   \   00000000   0x........         DC32     ??sdramstatus

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_4:
   \   00000000   0x........         DC32     ??sdramstatus_1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_5:
   \   00000000   0x........         DC32     Command

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_6:
   \   00000000   0x40023838         DC32     0x40023838

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_7:
   \   00000000   0x40023830         DC32     0x40023830

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_8:
   \   00000000   0x40020800         DC32     0x40020800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_9:
   \   00000000   0x40020C00         DC32     0x40020c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_10:
   \   00000000   0x40021000         DC32     0x40021000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_11:
   \   00000000   0x40021400         DC32     0x40021400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_12:
   \   00000000   0x40021800         DC32     0x40021800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_13:
   \   00000000   0x40021C00         DC32     0x40021c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_14:
   \   00000000   0x........         DC32     ??dma_handle

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_15:
   \   00000000   0x40026410         DC32     0x40026410

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_16:
   \   00000000   0x........         DC32     ??dma_handle_1
    482          
    483          /**
    484            * @}
    485            */  
    486            
    487          /**
    488            * @}
    489            */ 
    490            
    491          /**
    492            * @}
    493            */ 
    494            
    495          /**
    496            * @}
    497            */ 
    498          
    499          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   BSP_SDRAM_DMA_IRQHandler
         8   -> HAL_DMA_IRQHandler
       8   BSP_SDRAM_DeInit
         8   -> BSP_SDRAM_MspDeInit
         8   -> HAL_SDRAM_DeInit
       8   BSP_SDRAM_Init
         8   -> BSP_SDRAM_Initialization_sequence
         8   -> BSP_SDRAM_MspInit
         8   -> HAL_SDRAM_Init
      16   BSP_SDRAM_Initialization_sequence
        16   -> HAL_Delay
        16   -> HAL_SDRAM_ProgramRefreshRate
        16   -> HAL_SDRAM_SendCommand
      16   BSP_SDRAM_MspDeInit
        16   -> HAL_DMA_DeInit
        16   -> HAL_NVIC_DisableIRQ
      40   BSP_SDRAM_MspInit
        40   -> HAL_DMA_DeInit
        40   -> HAL_DMA_Init
        40   -> HAL_GPIO_Init
        40   -> HAL_NVIC_EnableIRQ
        40   -> HAL_NVIC_SetPriority
      16   BSP_SDRAM_ReadData
        16   -> HAL_SDRAM_Read_32b
      16   BSP_SDRAM_ReadData_DMA
        16   -> HAL_SDRAM_Read_DMA
       8   BSP_SDRAM_Sendcmd
         8   -> HAL_SDRAM_SendCommand
      16   BSP_SDRAM_WriteData
        16   -> HAL_SDRAM_Write_32b
      16   BSP_SDRAM_WriteData_DMA
        16   -> HAL_SDRAM_Write_DMA


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable10
       4  ??DataTable10_1
       4  ??DataTable10_10
       4  ??DataTable10_11
       4  ??DataTable10_12
       4  ??DataTable10_13
       4  ??DataTable10_14
       4  ??DataTable10_15
       4  ??DataTable10_16
       4  ??DataTable10_2
       4  ??DataTable10_3
       4  ??DataTable10_4
       4  ??DataTable10_5
       4  ??DataTable10_6
       4  ??DataTable10_7
       4  ??DataTable10_8
       4  ??DataTable10_9
      12  BSP_SDRAM_DMA_IRQHandler
      60  BSP_SDRAM_DeInit
     214  BSP_SDRAM_Init
     176  BSP_SDRAM_Initialization_sequence
      26  BSP_SDRAM_MspDeInit
     424  BSP_SDRAM_MspInit
      32  BSP_SDRAM_ReadData
      32  BSP_SDRAM_ReadData_DMA
      28  BSP_SDRAM_Sendcmd
      32  BSP_SDRAM_WriteData
      32  BSP_SDRAM_WriteData_DMA
      16  Command
      28  Timing
      80  dma_handle
      80  dma_handle
      52  sdramHandle
       1  sdramstatus
       1  sdramstatus

 
   256 bytes in section .bss
     2 bytes in section .data
 1 136 bytes in section .text
 
 1 136 bytes of CODE memory
   258 bytes of DATA memory

Errors: none
Warnings: none
