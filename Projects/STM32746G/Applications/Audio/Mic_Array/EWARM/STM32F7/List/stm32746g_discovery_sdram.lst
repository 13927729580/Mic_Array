###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.2.10312/W32 for ARM       08/Apr/2016  18:41:52
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Drivers\BSP\STM32746G-Discovery\stm32746g_discovery_sdram.c
#    Command line =  
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Drivers\BSP\STM32746G-Discovery\stm32746g_discovery_sdram.c
#        -D USE_HAL_DRIVER -D STM32F746xx -D USE_STM32746G_DISCO -D
#        USE_IOEXPANDER -D USE_USB_FS -lC
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
#        -lA
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
#        -o
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj
#        --no_unroll --debug --endian=little --cpu=Cortex-M7 -e --fpu=VFPv5_sp
#        --dlib_config "D:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Full.h" -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\CMSIS\Device\ST\STM32F7xx\Include\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\STM32F7xx_HAL_Driver\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\STM32746G-Discovery\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\Components\Common\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Log\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Fonts\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\CPU\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_Device_Library\Core\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Core\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Class\MSC\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\drivers\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_Audio\Addons\PDM\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_Device_Library\Class\AUDIO\Inc\
#        -Ohs --use_c++_inline --require_prototypes -I "D:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.3\arm\CMSIS\Include\" -D
#        ARM_MATH_CM7 --relaxed_fp
#    List file    =  
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List\stm32746g_discovery_sdram.lst
#    Object file  =  
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj\stm32746g_discovery_sdram.o
#
###############################################################################

D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Drivers\BSP\STM32746G-Discovery\stm32746g_discovery_sdram.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32746g_discovery_sdram.c
      4            * @author  MCD Application Team
      5            * @version V1.0.0
      6            * @date    25-June-2015
      7            * @brief   This file includes the SDRAM driver for the MT48LC4M32B2B5-7 memory 
      8            *          device mounted on STM32746G-Discovery board.
      9            @verbatim
     10             1. How To use this driver:
     11             --------------------------
     12                - This driver is used to drive the MT48LC4M32B2B5-7 SDRAM external memory mounted
     13                  on STM32746G-Discovery board.
     14                - This driver does not need a specific component driver for the SDRAM device
     15                  to be included with.
     16             
     17             2. Driver description:
     18             ---------------------
     19               + Initialization steps:
     20                  o Initialize the SDRAM external memory using the BSP_SDRAM_Init() function. This 
     21                    function includes the MSP layer hardware resources initialization and the
     22                    FMC controller configuration to interface with the external SDRAM memory.
     23                  o It contains the SDRAM initialization sequence to program the SDRAM external 
     24                    device using the function BSP_SDRAM_Initialization_sequence(). Note that this 
     25                    sequence is standard for all SDRAM devices, but can include some differences
     26                    from a device to another. If it is the case, the right sequence should be 
     27                    implemented separately.
     28               
     29               + SDRAM read/write operations
     30                  o SDRAM external memory can be accessed with read/write operations once it is
     31                    initialized.
     32                    Read/write operation can be performed with AHB access using the functions
     33                    BSP_SDRAM_ReadData()/BSP_SDRAM_WriteData(), or by DMA transfer using the functions
     34                    BSP_SDRAM_ReadData_DMA()/BSP_SDRAM_WriteData_DMA().
     35                  o The AHB access is performed with 32-bit width transaction, the DMA transfer
     36                    configuration is fixed at single (no burst) word transfer (see the 
     37                    SDRAM_MspInit() static function).
     38                  o User can implement his own functions for read/write access with his desired 
     39                    configurations.
     40                  o If interrupt mode is used for DMA transfer, the function BSP_SDRAM_DMA_IRQHandler()
     41                    is called in IRQ handler file, to serve the generated interrupt once the DMA 
     42                    transfer is complete.
     43                  o You can send a command to the SDRAM device in runtime using the function 
     44                    BSP_SDRAM_Sendcmd(), and giving the desired command as parameter chosen between 
     45                    the predefined commands of the "FMC_SDRAM_CommandTypeDef" structure. 
     46           
     47            @endverbatim
     48            ******************************************************************************
     49            * @attention
     50            *
     51            * <h2><center>&copy; COPYRIGHT(c) 2015 STMicroelectronics</center></h2>
     52            *
     53            * Redistribution and use in source and binary forms, with or without modification,
     54            * are permitted provided that the following conditions are met:
     55            *   1. Redistributions of source code must retain the above copyright notice,
     56            *      this list of conditions and the following disclaimer.
     57            *   2. Redistributions in binary form must reproduce the above copyright notice,
     58            *      this list of conditions and the following disclaimer in the documentation
     59            *      and/or other materials provided with the distribution.
     60            *   3. Neither the name of STMicroelectronics nor the names of its contributors
     61            *      may be used to endorse or promote products derived from this software
     62            *      without specific prior written permission.
     63            *
     64            * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
     65            * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     66            * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     67            * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
     68            * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
     69            * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
     70            * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
     71            * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
     72            * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
     73            * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     74            *
     75            ******************************************************************************
     76            */
     77          
     78          /* Includes ------------------------------------------------------------------*/
     79          #include "stm32746g_discovery_sdram.h"
     80          
     81          /** @addtogroup BSP
     82            * @{
     83            */
     84          
     85          /** @addtogroup STM32746G_DISCOVERY
     86            * @{
     87            */ 
     88            
     89          /** @defgroup STM32746G_DISCOVERY_SDRAM STM32746G_DISCOVERY_SDRAM
     90            * @{
     91            */ 
     92          
     93          /** @defgroup STM32746G_DISCOVERY_SDRAM_Private_Types_Definitions STM32746G_DISCOVERY_SDRAM Private Types Definitions
     94            * @{
     95            */ 
     96          /**
     97            * @}
     98            */
     99          
    100          /** @defgroup STM32746G_DISCOVERY_SDRAM_Private_Defines STM32746G_DISCOVERY_SDRAM Private Defines
    101            * @{
    102            */
    103          /**
    104            * @}
    105            */
    106          
    107          /** @defgroup STM32746G_DISCOVERY_SDRAM_Private_Macros STM32746G_DISCOVERY_SDRAM Private Macros
    108            * @{
    109            */  
    110          /**
    111            * @}
    112            */
    113          
    114          /** @defgroup STM32746G_DISCOVERY_SDRAM_Private_Variables STM32746G_DISCOVERY_SDRAM Private Variables
    115            * @{
    116            */       
    117          static SDRAM_HandleTypeDef sdramHandle;
    118          static FMC_SDRAM_TimingTypeDef Timing;
    119          static FMC_SDRAM_CommandTypeDef Command;
    120          /**
    121            * @}
    122            */ 
    123          
    124          /** @defgroup STM32746G_DISCOVERY_SDRAM_Private_Function_Prototypes STM32746G_DISCOVERY_SDRAM Private Function Prototypes
    125            * @{
    126            */ 
    127          /**
    128            * @}
    129            */
    130              
    131          /** @defgroup STM32746G_DISCOVERY_SDRAM_Exported_Functions STM32746G_DISCOVERY_SDRAM Exported Functions
    132            * @{
    133            */ 
    134          
    135          /**
    136            * @brief  Initializes the SDRAM device.
    137            * @retval SDRAM status
    138            */

   \                                 In section .text, align 2, keep-with-next
    139          uint8_t BSP_SDRAM_Init(void)
    140          { 
   \                     BSP_SDRAM_Init: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB081             SUB      SP,SP,#+4
    141            static uint8_t sdramstatus = SDRAM_ERROR;
    142            /* SDRAM device configuration */
    143            sdramHandle.Instance = FMC_SDRAM_DEVICE;
   \   00000004   0x.... 0x....      LDR.W    R4,??DataTable10
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable10_1  ;; 0xa0000140
    144              
    145            /* Timing configuration for 100Mhz as SD clock frequency (System clock is up to 200Mhz) */
    146            Timing.LoadToActiveDelay    = 2;
    147            Timing.ExitSelfRefreshDelay = 7;
    148            Timing.SelfRefreshTime      = 4;
    149            Timing.RowCycleDelay        = 7;
    150            Timing.WriteRecoveryTime    = 2;
    151            Timing.RPDelay              = 2;
    152            Timing.RCDDelay             = 2;
    153            
    154            sdramHandle.Init.SDBank             = FMC_SDRAM_BANK1;
    155            sdramHandle.Init.ColumnBitsNumber   = FMC_SDRAM_COLUMN_BITS_NUM_8;
    156            sdramHandle.Init.RowBitsNumber      = FMC_SDRAM_ROW_BITS_NUM_12;
    157            sdramHandle.Init.MemoryDataWidth    = SDRAM_MEMORY_WIDTH;
    158            sdramHandle.Init.InternalBankNumber = FMC_SDRAM_INTERN_BANKS_NUM_4;
    159            sdramHandle.Init.CASLatency         = FMC_SDRAM_CAS_LATENCY_2;
    160            sdramHandle.Init.WriteProtection    = FMC_SDRAM_WRITE_PROTECTION_DISABLE;
    161            sdramHandle.Init.SDClockPeriod      = SDCLOCK_PERIOD;
    162            sdramHandle.Init.ReadBurst          = FMC_SDRAM_RBURST_ENABLE;
    163            sdramHandle.Init.ReadPipeDelay      = FMC_SDRAM_RPIPE_DELAY_0;
    164            
    165            /* SDRAM controller initialization */
    166          
    167            BSP_SDRAM_MspInit(&sdramHandle, NULL); /* __weak function can be rewritten by the application */
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0x6020             STR      R0,[R4, #+0]
   \   00000010   0x2002             MOVS     R0,#+2
   \   00000012   0x6360             STR      R0,[R4, #+52]
   \   00000014   0x2007             MOVS     R0,#+7
   \   00000016   0x63A0             STR      R0,[R4, #+56]
   \   00000018   0x2004             MOVS     R0,#+4
   \   0000001A   0x63E0             STR      R0,[R4, #+60]
   \   0000001C   0x2007             MOVS     R0,#+7
   \   0000001E   0x6420             STR      R0,[R4, #+64]
   \   00000020   0x2002             MOVS     R0,#+2
   \   00000022   0x6460             STR      R0,[R4, #+68]
   \   00000024   0xF64F 0x75FF      MOVW     R5,#+65535
   \   00000028   0x64A0             STR      R0,[R4, #+72]
   \   0000002A   0x64E0             STR      R0,[R4, #+76]
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0x6060             STR      R0,[R4, #+4]
   \   00000030   0x60A0             STR      R0,[R4, #+8]
   \   00000032   0x2004             MOVS     R0,#+4
   \   00000034   0x60E0             STR      R0,[R4, #+12]
   \   00000036   0x2010             MOVS     R0,#+16
   \   00000038   0x6120             STR      R0,[R4, #+16]
   \   0000003A   0x2040             MOVS     R0,#+64
   \   0000003C   0x6160             STR      R0,[R4, #+20]
   \   0000003E   0xF44F 0x7080      MOV      R0,#+256
   \   00000042   0x61A0             STR      R0,[R4, #+24]
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0x61E0             STR      R0,[R4, #+28]
   \   00000048   0xF44F 0x6000      MOV      R0,#+2048
   \   0000004C   0x6220             STR      R0,[R4, #+32]
   \   0000004E   0xF44F 0x5080      MOV      R0,#+4096
   \   00000052   0x6260             STR      R0,[R4, #+36]
   \   00000054   0x2000             MOVS     R0,#+0
   \   00000056   0x62A0             STR      R0,[R4, #+40]
   \   00000058   0x4620             MOV      R0,R4
   \   0000005A   0x.... 0x....      BL       BSP_SDRAM_MspInit
    168          
    169            if(HAL_SDRAM_Init(&sdramHandle, &Timing) != HAL_OK)
   \   0000005E   0xF104 0x0134      ADD      R1,R4,#+52
   \   00000062   0x4620             MOV      R0,R4
   \   00000064   0x.... 0x....      BL       HAL_SDRAM_Init
   \   00000068   0x1E40             SUBS     R0,R0,#+1
   \   0000006A   0x4180             SBCS     R0,R0,R0
   \   0000006C   0x43C0             MVNS     R0,R0
   \   0000006E   0x0FC0             LSRS     R0,R0,#+31
   \   00000070   0xF884 0x0060      STRB     R0,[R4, #+96]
    170            {
    171              sdramstatus = SDRAM_ERROR;
    172            }
    173            else
    174            {
    175              sdramstatus = SDRAM_OK;
    176            }
    177            
    178            /* SDRAM initialization sequence */
    179            BSP_SDRAM_Initialization_sequence(REFRESH_COUNT);
   \   00000074   0x2000             MOVS     R0,#+0
   \   00000076   0x9000             STR      R0,[SP, #+0]
   \   00000078   0x2001             MOVS     R0,#+1
   \   0000007A   0x6520             STR      R0,[R4, #+80]
   \   0000007C   0x2010             MOVS     R0,#+16
   \   0000007E   0x6560             STR      R0,[R4, #+84]
   \   00000080   0x2001             MOVS     R0,#+1
   \   00000082   0x65A0             STR      R0,[R4, #+88]
   \   00000084   0x2000             MOVS     R0,#+0
   \   00000086   0x65E0             STR      R0,[R4, #+92]
   \   00000088   0x462A             MOV      R2,R5
   \   0000008A   0xF104 0x0150      ADD      R1,R4,#+80
   \   0000008E   0x4620             MOV      R0,R4
   \   00000090   0x.... 0x....      BL       HAL_SDRAM_SendCommand
   \   00000094   0x2001             MOVS     R0,#+1
   \   00000096   0x.... 0x....      BL       HAL_Delay
   \   0000009A   0x2002             MOVS     R0,#+2
   \   0000009C   0x462A             MOV      R2,R5
   \   0000009E   0x6520             STR      R0,[R4, #+80]
   \   000000A0   0x2010             MOVS     R0,#+16
   \   000000A2   0x6560             STR      R0,[R4, #+84]
   \   000000A4   0x2001             MOVS     R0,#+1
   \   000000A6   0x65A0             STR      R0,[R4, #+88]
   \   000000A8   0x2000             MOVS     R0,#+0
   \   000000AA   0x65E0             STR      R0,[R4, #+92]
   \   000000AC   0xF104 0x0150      ADD      R1,R4,#+80
   \   000000B0   0x4620             MOV      R0,R4
   \   000000B2   0x.... 0x....      BL       HAL_SDRAM_SendCommand
   \   000000B6   0x2003             MOVS     R0,#+3
   \   000000B8   0x462A             MOV      R2,R5
   \   000000BA   0x6520             STR      R0,[R4, #+80]
   \   000000BC   0x2010             MOVS     R0,#+16
   \   000000BE   0x6560             STR      R0,[R4, #+84]
   \   000000C0   0x2008             MOVS     R0,#+8
   \   000000C2   0x65A0             STR      R0,[R4, #+88]
   \   000000C4   0x2000             MOVS     R0,#+0
   \   000000C6   0x65E0             STR      R0,[R4, #+92]
   \   000000C8   0xF104 0x0150      ADD      R1,R4,#+80
   \   000000CC   0x4620             MOV      R0,R4
   \   000000CE   0x.... 0x....      BL       HAL_SDRAM_SendCommand
   \   000000D2   0xF44F 0x7008      MOV      R0,#+544
   \   000000D6   0x462A             MOV      R2,R5
   \   000000D8   0x9000             STR      R0,[SP, #+0]
   \   000000DA   0x2004             MOVS     R0,#+4
   \   000000DC   0x6520             STR      R0,[R4, #+80]
   \   000000DE   0x2010             MOVS     R0,#+16
   \   000000E0   0x6560             STR      R0,[R4, #+84]
   \   000000E2   0x2001             MOVS     R0,#+1
   \   000000E4   0x65A0             STR      R0,[R4, #+88]
   \   000000E6   0x9800             LDR      R0,[SP, #+0]
   \   000000E8   0xF104 0x0150      ADD      R1,R4,#+80
   \   000000EC   0x65E0             STR      R0,[R4, #+92]
   \   000000EE   0x4620             MOV      R0,R4
   \   000000F0   0x.... 0x....      BL       HAL_SDRAM_SendCommand
   \   000000F4   0xF240 0x6103      MOVW     R1,#+1539
   \   000000F8   0x4620             MOV      R0,R4
   \   000000FA   0x.... 0x....      BL       HAL_SDRAM_ProgramRefreshRate
    180            
    181            return sdramstatus;
   \   000000FE   0xF894 0x0060      LDRB     R0,[R4, #+96]
   \   00000102   0xB001             ADD      SP,SP,#+4
   \   00000104   0xBD30             POP      {R4,R5,PC}       ;; return
    182          }
    183          
    184          /**
    185            * @brief  DeInitializes the SDRAM device.
    186            * @retval SDRAM status
    187            */

   \                                 In section .text, align 2, keep-with-next
    188          uint8_t BSP_SDRAM_DeInit(void)
    189          { 
   \                     BSP_SDRAM_DeInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    190            static uint8_t sdramstatus = SDRAM_ERROR;
    191            /* SDRAM device de-initialization */
    192            sdramHandle.Instance = FMC_SDRAM_DEVICE;
   \   00000002   0x....             LDR.N    R4,??DataTable10
   \   00000004   0x....             LDR.N    R0,??DataTable10_1  ;; 0xa0000140
   \   00000006   0x6020             STR      R0,[R4, #+0]
    193          
    194            if(HAL_SDRAM_DeInit(&sdramHandle) != HAL_OK)
   \   00000008   0x4620             MOV      R0,R4
   \   0000000A   0x.... 0x....      BL       HAL_SDRAM_DeInit
   \   0000000E   0x1E40             SUBS     R0,R0,#+1
   \   00000010   0x4180             SBCS     R0,R0,R0
   \   00000012   0x43C0             MVNS     R0,R0
   \   00000014   0x0FC0             LSRS     R0,R0,#+31
   \   00000016   0xF884 0x0061      STRB     R0,[R4, #+97]
    195            {
    196              sdramstatus = SDRAM_ERROR;
    197            }
    198            else
    199            {
    200              sdramstatus = SDRAM_OK;
    201            }
    202            
    203            /* SDRAM controller de-initialization */
    204            BSP_SDRAM_MspDeInit(&sdramHandle, NULL);
   \   0000001A   0x2100             MOVS     R1,#+0
   \   0000001C   0x4620             MOV      R0,R4
   \   0000001E   0x.... 0x....      BL       BSP_SDRAM_MspDeInit
    205            
    206            return sdramstatus;
   \   00000022   0xF894 0x0061      LDRB     R0,[R4, #+97]
   \   00000026   0xBD10             POP      {R4,PC}          ;; return
    207          }

   \                                 In section .data, align 4
   \                     sdramHandle:
   \   00000000   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000010   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000020   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000034   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000044   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000050   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000060   0x01               DC8 1
   \   00000061   0x01               DC8 1
    208          
    209          /**
    210            * @brief  Programs the SDRAM device.
    211            * @param  RefreshCount: SDRAM refresh counter value 
    212            * @retval None
    213            */

   \                                 In section .text, align 2, keep-with-next
    214          void BSP_SDRAM_Initialization_sequence(uint32_t RefreshCount)
    215          {
   \                     BSP_SDRAM_Initialization_sequence: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0xB082             SUB      SP,SP,#+8
    216            __IO uint32_t tmpmrd = 0;
   \   00000006   0x2000             MOVS     R0,#+0
    217            
    218            /* Step 1: Configure a clock configuration enable command */
    219            Command.CommandMode            = FMC_SDRAM_CMD_CLK_ENABLE;
   \   00000008   0x....             LDR.N    R5,??DataTable10
   \   0000000A   0x9000             STR      R0,[SP, #+0]
   \   0000000C   0x2001             MOVS     R0,#+1
   \   0000000E   0x6528             STR      R0,[R5, #+80]
    220            Command.CommandTarget          = FMC_SDRAM_CMD_TARGET_BANK1;
   \   00000010   0x2010             MOVS     R0,#+16
   \   00000012   0x6568             STR      R0,[R5, #+84]
    221            Command.AutoRefreshNumber      = 1;
   \   00000014   0x2001             MOVS     R0,#+1
   \   00000016   0x65A8             STR      R0,[R5, #+88]
    222            Command.ModeRegisterDefinition = 0;
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x65E8             STR      R0,[R5, #+92]
    223          
    224            /* Send the command */
    225            HAL_SDRAM_SendCommand(&sdramHandle, &Command, SDRAM_TIMEOUT);
   \   0000001C   0xF64F 0x76FF      MOVW     R6,#+65535
   \   00000020   0x4632             MOV      R2,R6
   \   00000022   0xF105 0x0150      ADD      R1,R5,#+80
   \   00000026   0x4628             MOV      R0,R5
   \   00000028   0x.... 0x....      BL       HAL_SDRAM_SendCommand
    226          
    227            /* Step 2: Insert 100 us minimum delay */ 
    228            /* Inserted delay is equal to 1 ms due to systick time base unit (ms) */
    229            HAL_Delay(1);
   \   0000002C   0x2001             MOVS     R0,#+1
   \   0000002E   0x.... 0x....      BL       HAL_Delay
    230              
    231            /* Step 3: Configure a PALL (precharge all) command */ 
    232            Command.CommandMode            = FMC_SDRAM_CMD_PALL;
   \   00000032   0x2002             MOVS     R0,#+2
    233            Command.CommandTarget          = FMC_SDRAM_CMD_TARGET_BANK1;
    234            Command.AutoRefreshNumber      = 1;
    235            Command.ModeRegisterDefinition = 0;
    236          
    237            /* Send the command */
    238            HAL_SDRAM_SendCommand(&sdramHandle, &Command, SDRAM_TIMEOUT);  
   \   00000034   0x4632             MOV      R2,R6
   \   00000036   0x6528             STR      R0,[R5, #+80]
   \   00000038   0x2010             MOVS     R0,#+16
   \   0000003A   0x6568             STR      R0,[R5, #+84]
   \   0000003C   0x2001             MOVS     R0,#+1
   \   0000003E   0x65A8             STR      R0,[R5, #+88]
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0x65E8             STR      R0,[R5, #+92]
   \   00000044   0xF105 0x0150      ADD      R1,R5,#+80
   \   00000048   0x4628             MOV      R0,R5
   \   0000004A   0x.... 0x....      BL       HAL_SDRAM_SendCommand
    239            
    240            /* Step 4: Configure an Auto Refresh command */ 
    241            Command.CommandMode            = FMC_SDRAM_CMD_AUTOREFRESH_MODE;
   \   0000004E   0x2003             MOVS     R0,#+3
    242            Command.CommandTarget          = FMC_SDRAM_CMD_TARGET_BANK1;
    243            Command.AutoRefreshNumber      = 8;
    244            Command.ModeRegisterDefinition = 0;
    245          
    246            /* Send the command */
    247            HAL_SDRAM_SendCommand(&sdramHandle, &Command, SDRAM_TIMEOUT);
   \   00000050   0x4632             MOV      R2,R6
   \   00000052   0x6528             STR      R0,[R5, #+80]
   \   00000054   0x2010             MOVS     R0,#+16
   \   00000056   0x6568             STR      R0,[R5, #+84]
   \   00000058   0x2008             MOVS     R0,#+8
   \   0000005A   0x65A8             STR      R0,[R5, #+88]
   \   0000005C   0x2000             MOVS     R0,#+0
   \   0000005E   0x65E8             STR      R0,[R5, #+92]
   \   00000060   0xF105 0x0150      ADD      R1,R5,#+80
   \   00000064   0x4628             MOV      R0,R5
   \   00000066   0x.... 0x....      BL       HAL_SDRAM_SendCommand
    248            
    249            /* Step 5: Program the external memory mode register */
    250            tmpmrd = (uint32_t)SDRAM_MODEREG_BURST_LENGTH_1          |\
    251                               SDRAM_MODEREG_BURST_TYPE_SEQUENTIAL   |\
    252                               SDRAM_MODEREG_CAS_LATENCY_2           |\
    253                               SDRAM_MODEREG_OPERATING_MODE_STANDARD |\
    254                               SDRAM_MODEREG_WRITEBURST_MODE_SINGLE;
   \   0000006A   0xF44F 0x7008      MOV      R0,#+544
    255            
    256            Command.CommandMode            = FMC_SDRAM_CMD_LOAD_MODE;
    257            Command.CommandTarget          = FMC_SDRAM_CMD_TARGET_BANK1;
    258            Command.AutoRefreshNumber      = 1;
    259            Command.ModeRegisterDefinition = tmpmrd;
    260          
    261            /* Send the command */
    262            HAL_SDRAM_SendCommand(&sdramHandle, &Command, SDRAM_TIMEOUT);
   \   0000006E   0x4632             MOV      R2,R6
   \   00000070   0x9000             STR      R0,[SP, #+0]
   \   00000072   0x2004             MOVS     R0,#+4
   \   00000074   0x6528             STR      R0,[R5, #+80]
   \   00000076   0x2010             MOVS     R0,#+16
   \   00000078   0x6568             STR      R0,[R5, #+84]
   \   0000007A   0x2001             MOVS     R0,#+1
   \   0000007C   0x65A8             STR      R0,[R5, #+88]
   \   0000007E   0x9800             LDR      R0,[SP, #+0]
   \   00000080   0xF105 0x0150      ADD      R1,R5,#+80
   \   00000084   0x65E8             STR      R0,[R5, #+92]
   \   00000086   0x4628             MOV      R0,R5
   \   00000088   0x.... 0x....      BL       HAL_SDRAM_SendCommand
    263            
    264            /* Step 6: Set the refresh rate counter */
    265            /* Set the device refresh rate */
    266            HAL_SDRAM_ProgramRefreshRate(&sdramHandle, RefreshCount); 
   \   0000008C   0x4621             MOV      R1,R4
   \   0000008E   0x4628             MOV      R0,R5
   \   00000090   0xB002             ADD      SP,SP,#+8
   \   00000092   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   00000096   0x.... 0x....      B.W      HAL_SDRAM_ProgramRefreshRate
    267          }
    268          
    269          /**
    270            * @brief  Reads an amount of data from the SDRAM memory in polling mode.
    271            * @param  uwStartAddress: Read start address
    272            * @param  pData: Pointer to data to be read  
    273            * @param  uwDataSize: Size of read data from the memory
    274            * @retval SDRAM status
    275            */

   \                                 In section .text, align 2, keep-with-next
    276          uint8_t BSP_SDRAM_ReadData(uint32_t uwStartAddress, uint32_t *pData, uint32_t uwDataSize)
    277          {
    278            if(HAL_SDRAM_Read_32b(&sdramHandle, (uint32_t *)uwStartAddress, pData, uwDataSize) != HAL_OK)
   \                     BSP_SDRAM_ReadData: (+1)
   \   00000000   0x4613             MOV      R3,R2
   \   00000002   0x460A             MOV      R2,R1
   \   00000004   0xB500             PUSH     {LR}
   \   00000006   0x4601             MOV      R1,R0
   \   00000008   0xB081             SUB      SP,SP,#+4
   \   0000000A   0x....             LDR.N    R0,??DataTable10
   \   0000000C   0x.... 0x....      BL       HAL_SDRAM_Read_32b
   \   00000010   0x1E40             SUBS     R0,R0,#+1
   \   00000012   0x4180             SBCS     R0,R0,R0
   \   00000014   0x43C0             MVNS     R0,R0
   \   00000016   0x0FC0             LSRS     R0,R0,#+31
    279            {
    280              return SDRAM_ERROR;
    281            }
    282            else
    283            {
    284              return SDRAM_OK;
   \   00000018   0xB001             ADD      SP,SP,#+4
   \   0000001A   0xBD00             POP      {PC}             ;; return
    285            } 
    286          }
    287          
    288          /**
    289            * @brief  Reads an amount of data from the SDRAM memory in DMA mode.
    290            * @param  uwStartAddress: Read start address
    291            * @param  pData: Pointer to data to be read  
    292            * @param  uwDataSize: Size of read data from the memory
    293            * @retval SDRAM status
    294            */

   \                                 In section .text, align 2, keep-with-next
    295          uint8_t BSP_SDRAM_ReadData_DMA(uint32_t uwStartAddress, uint32_t *pData, uint32_t uwDataSize)
    296          {
    297            if(HAL_SDRAM_Read_DMA(&sdramHandle, (uint32_t *)uwStartAddress, pData, uwDataSize) != HAL_OK)
   \                     BSP_SDRAM_ReadData_DMA: (+1)
   \   00000000   0x4613             MOV      R3,R2
   \   00000002   0x460A             MOV      R2,R1
   \   00000004   0xB500             PUSH     {LR}
   \   00000006   0x4601             MOV      R1,R0
   \   00000008   0xB081             SUB      SP,SP,#+4
   \   0000000A   0x....             LDR.N    R0,??DataTable10
   \   0000000C   0x.... 0x....      BL       HAL_SDRAM_Read_DMA
   \   00000010   0x1E40             SUBS     R0,R0,#+1
   \   00000012   0x4180             SBCS     R0,R0,R0
   \   00000014   0x43C0             MVNS     R0,R0
   \   00000016   0x0FC0             LSRS     R0,R0,#+31
    298            {
    299              return SDRAM_ERROR;
    300            }
    301            else
    302            {
    303              return SDRAM_OK;
   \   00000018   0xB001             ADD      SP,SP,#+4
   \   0000001A   0xBD00             POP      {PC}             ;; return
    304            }     
    305          }
    306          
    307          /**
    308            * @brief  Writes an amount of data to the SDRAM memory in polling mode.
    309            * @param  uwStartAddress: Write start address
    310            * @param  pData: Pointer to data to be written  
    311            * @param  uwDataSize: Size of written data from the memory
    312            * @retval SDRAM status
    313            */

   \                                 In section .text, align 2, keep-with-next
    314          uint8_t BSP_SDRAM_WriteData(uint32_t uwStartAddress, uint32_t *pData, uint32_t uwDataSize) 
    315          {
    316            if(HAL_SDRAM_Write_32b(&sdramHandle, (uint32_t *)uwStartAddress, pData, uwDataSize) != HAL_OK)
   \                     BSP_SDRAM_WriteData: (+1)
   \   00000000   0x4613             MOV      R3,R2
   \   00000002   0x460A             MOV      R2,R1
   \   00000004   0xB500             PUSH     {LR}
   \   00000006   0x4601             MOV      R1,R0
   \   00000008   0xB081             SUB      SP,SP,#+4
   \   0000000A   0x....             LDR.N    R0,??DataTable10
   \   0000000C   0x.... 0x....      BL       HAL_SDRAM_Write_32b
   \   00000010   0x1E40             SUBS     R0,R0,#+1
   \   00000012   0x4180             SBCS     R0,R0,R0
   \   00000014   0x43C0             MVNS     R0,R0
   \   00000016   0x0FC0             LSRS     R0,R0,#+31
    317            {
    318              return SDRAM_ERROR;
    319            }
    320            else
    321            {
    322              return SDRAM_OK;
   \   00000018   0xB001             ADD      SP,SP,#+4
   \   0000001A   0xBD00             POP      {PC}             ;; return
    323            }
    324          }
    325          
    326          /**
    327            * @brief  Writes an amount of data to the SDRAM memory in DMA mode.
    328            * @param  uwStartAddress: Write start address
    329            * @param  pData: Pointer to data to be written  
    330            * @param  uwDataSize: Size of written data from the memory
    331            * @retval SDRAM status
    332            */

   \                                 In section .text, align 2, keep-with-next
    333          uint8_t BSP_SDRAM_WriteData_DMA(uint32_t uwStartAddress, uint32_t *pData, uint32_t uwDataSize) 
    334          {
    335            if(HAL_SDRAM_Write_DMA(&sdramHandle, (uint32_t *)uwStartAddress, pData, uwDataSize) != HAL_OK)
   \                     BSP_SDRAM_WriteData_DMA: (+1)
   \   00000000   0x4613             MOV      R3,R2
   \   00000002   0x460A             MOV      R2,R1
   \   00000004   0xB500             PUSH     {LR}
   \   00000006   0x4601             MOV      R1,R0
   \   00000008   0xB081             SUB      SP,SP,#+4
   \   0000000A   0x....             LDR.N    R0,??DataTable10
   \   0000000C   0x.... 0x....      BL       HAL_SDRAM_Write_DMA
   \   00000010   0x1E40             SUBS     R0,R0,#+1
   \   00000012   0x4180             SBCS     R0,R0,R0
   \   00000014   0x43C0             MVNS     R0,R0
   \   00000016   0x0FC0             LSRS     R0,R0,#+31
    336            {
    337              return SDRAM_ERROR;
    338            }
    339            else
    340            {
    341              return SDRAM_OK;
   \   00000018   0xB001             ADD      SP,SP,#+4
   \   0000001A   0xBD00             POP      {PC}             ;; return
    342            } 
    343          }
    344          
    345          /**
    346            * @brief  Sends command to the SDRAM bank.
    347            * @param  SdramCmd: Pointer to SDRAM command structure 
    348            * @retval SDRAM status
    349            */  

   \                                 In section .text, align 2, keep-with-next
    350          uint8_t BSP_SDRAM_Sendcmd(FMC_SDRAM_CommandTypeDef *SdramCmd)
    351          {
   \                     BSP_SDRAM_Sendcmd: (+1)
   \   00000000   0xB500             PUSH     {LR}
    352            if(HAL_SDRAM_SendCommand(&sdramHandle, SdramCmd, SDRAM_TIMEOUT) != HAL_OK)
   \   00000002   0x4601             MOV      R1,R0
   \   00000004   0xB081             SUB      SP,SP,#+4
   \   00000006   0xF64F 0x72FF      MOVW     R2,#+65535
   \   0000000A   0x....             LDR.N    R0,??DataTable10
   \   0000000C   0x.... 0x....      BL       HAL_SDRAM_SendCommand
   \   00000010   0x1E40             SUBS     R0,R0,#+1
   \   00000012   0x4180             SBCS     R0,R0,R0
   \   00000014   0x43C0             MVNS     R0,R0
   \   00000016   0x0FC0             LSRS     R0,R0,#+31
    353            {
    354              return SDRAM_ERROR;
    355            }
    356            else
    357            {
    358              return SDRAM_OK;
   \   00000018   0xB001             ADD      SP,SP,#+4
   \   0000001A   0xBD00             POP      {PC}             ;; return
    359            }
    360          }
    361          
    362          /**
    363            * @brief  Handles SDRAM DMA transfer interrupt request.
    364            * @retval None
    365            */

   \                                 In section .text, align 2, keep-with-next
    366          void BSP_SDRAM_DMA_IRQHandler(void)
    367          {
    368            HAL_DMA_IRQHandler(sdramHandle.hdma); 
   \                     BSP_SDRAM_DMA_IRQHandler: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable10
   \   00000002   0x6B00             LDR      R0,[R0, #+48]
   \   00000004   0x.... 0x....      B.W      HAL_DMA_IRQHandler
    369          }
    370          
    371          /**
    372            * @brief  Initializes SDRAM MSP.
    373            * @param  hsdram: SDRAM handle
    374            * @param  Params
    375            * @retval None
    376            */

   \                                 In section .text, align 2, keep-with-next
    377          __weak void BSP_SDRAM_MspInit(SDRAM_HandleTypeDef  *hsdram, void *Params)
    378          {  
   \                     BSP_SDRAM_MspInit: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0xB087             SUB      SP,SP,#+28
    379            static DMA_HandleTypeDef dma_handle;
    380            GPIO_InitTypeDef gpio_init_structure;
    381            
    382            /* Enable FMC clock */
    383            __HAL_RCC_FMC_CLK_ENABLE();
   \   00000006   0x2000             MOVS     R0,#+0
    384            
    385            /* Enable chosen DMAx clock */
    386            __DMAx_CLK_ENABLE();
    387          
    388            /* Enable GPIOs clock */
    389            __HAL_RCC_GPIOC_CLK_ENABLE();
    390            __HAL_RCC_GPIOD_CLK_ENABLE();
    391            __HAL_RCC_GPIOE_CLK_ENABLE();
    392            __HAL_RCC_GPIOF_CLK_ENABLE();
    393            __HAL_RCC_GPIOG_CLK_ENABLE();
    394            __HAL_RCC_GPIOH_CLK_ENABLE();
    395            
    396            /* Common GPIO configuration */
    397            gpio_init_structure.Mode      = GPIO_MODE_AF_PP;
    398            gpio_init_structure.Pull      = GPIO_PULLUP;
    399            gpio_init_structure.Speed     = GPIO_SPEED_FAST;
    400            gpio_init_structure.Alternate = GPIO_AF12_FMC;
    401            
    402            /* GPIOC configuration */
    403            gpio_init_structure.Pin   = GPIO_PIN_3;
    404            HAL_GPIO_Init(GPIOC, &gpio_init_structure);
   \   00000008   0x....             LDR.N    R5,??DataTable10_2
   \   0000000A   0x9000             STR      R0,[SP, #+0]
   \   0000000C   0x....             LDR.N    R0,??DataTable10_3  ;; 0x40023830
   \   0000000E   0x6881             LDR      R1,[R0, #+8]
   \   00000010   0xF041 0x0101      ORR      R1,R1,#0x1
   \   00000014   0x6081             STR      R1,[R0, #+8]
   \   00000016   0x6881             LDR      R1,[R0, #+8]
   \   00000018   0xF001 0x0101      AND      R1,R1,#0x1
   \   0000001C   0x9100             STR      R1,[SP, #+0]
   \   0000001E   0x9900             LDR      R1,[SP, #+0]
   \   00000020   0x2100             MOVS     R1,#+0
   \   00000022   0x9100             STR      R1,[SP, #+0]
   \   00000024   0x6801             LDR      R1,[R0, #+0]
   \   00000026   0xF441 0x0180      ORR      R1,R1,#0x400000
   \   0000002A   0x6001             STR      R1,[R0, #+0]
   \   0000002C   0x6801             LDR      R1,[R0, #+0]
   \   0000002E   0xF401 0x0180      AND      R1,R1,#0x400000
   \   00000032   0x9100             STR      R1,[SP, #+0]
   \   00000034   0x9900             LDR      R1,[SP, #+0]
   \   00000036   0x2100             MOVS     R1,#+0
   \   00000038   0x9100             STR      R1,[SP, #+0]
   \   0000003A   0x6801             LDR      R1,[R0, #+0]
   \   0000003C   0xF041 0x0104      ORR      R1,R1,#0x4
   \   00000040   0x6001             STR      R1,[R0, #+0]
   \   00000042   0x6801             LDR      R1,[R0, #+0]
   \   00000044   0xF001 0x0104      AND      R1,R1,#0x4
   \   00000048   0x9100             STR      R1,[SP, #+0]
   \   0000004A   0x9900             LDR      R1,[SP, #+0]
   \   0000004C   0x2100             MOVS     R1,#+0
   \   0000004E   0x9100             STR      R1,[SP, #+0]
   \   00000050   0x6801             LDR      R1,[R0, #+0]
   \   00000052   0xF041 0x0108      ORR      R1,R1,#0x8
   \   00000056   0x6001             STR      R1,[R0, #+0]
   \   00000058   0x6801             LDR      R1,[R0, #+0]
   \   0000005A   0xF001 0x0108      AND      R1,R1,#0x8
   \   0000005E   0x9100             STR      R1,[SP, #+0]
   \   00000060   0x9900             LDR      R1,[SP, #+0]
   \   00000062   0x2100             MOVS     R1,#+0
   \   00000064   0x9100             STR      R1,[SP, #+0]
   \   00000066   0x6801             LDR      R1,[R0, #+0]
   \   00000068   0xF041 0x0110      ORR      R1,R1,#0x10
   \   0000006C   0x6001             STR      R1,[R0, #+0]
   \   0000006E   0x6801             LDR      R1,[R0, #+0]
   \   00000070   0xF001 0x0110      AND      R1,R1,#0x10
   \   00000074   0x9100             STR      R1,[SP, #+0]
   \   00000076   0x9900             LDR      R1,[SP, #+0]
   \   00000078   0x2100             MOVS     R1,#+0
   \   0000007A   0x9100             STR      R1,[SP, #+0]
   \   0000007C   0x6801             LDR      R1,[R0, #+0]
   \   0000007E   0xF041 0x0120      ORR      R1,R1,#0x20
   \   00000082   0x6001             STR      R1,[R0, #+0]
   \   00000084   0x6801             LDR      R1,[R0, #+0]
   \   00000086   0xF001 0x0120      AND      R1,R1,#0x20
   \   0000008A   0x9100             STR      R1,[SP, #+0]
   \   0000008C   0x9900             LDR      R1,[SP, #+0]
   \   0000008E   0x2100             MOVS     R1,#+0
   \   00000090   0x9100             STR      R1,[SP, #+0]
   \   00000092   0x6801             LDR      R1,[R0, #+0]
   \   00000094   0xF041 0x0140      ORR      R1,R1,#0x40
   \   00000098   0x6001             STR      R1,[R0, #+0]
   \   0000009A   0x6801             LDR      R1,[R0, #+0]
   \   0000009C   0xF001 0x0140      AND      R1,R1,#0x40
   \   000000A0   0x9100             STR      R1,[SP, #+0]
   \   000000A2   0x9900             LDR      R1,[SP, #+0]
   \   000000A4   0x2100             MOVS     R1,#+0
   \   000000A6   0x9100             STR      R1,[SP, #+0]
   \   000000A8   0x6801             LDR      R1,[R0, #+0]
   \   000000AA   0xF041 0x0180      ORR      R1,R1,#0x80
   \   000000AE   0x6001             STR      R1,[R0, #+0]
   \   000000B0   0x6800             LDR      R0,[R0, #+0]
   \   000000B2   0xA901             ADD      R1,SP,#+4
   \   000000B4   0xF000 0x0080      AND      R0,R0,#0x80
   \   000000B8   0x9000             STR      R0,[SP, #+0]
   \   000000BA   0x9800             LDR      R0,[SP, #+0]
   \   000000BC   0x2002             MOVS     R0,#+2
   \   000000BE   0x9002             STR      R0,[SP, #+8]
   \   000000C0   0x2001             MOVS     R0,#+1
   \   000000C2   0x9003             STR      R0,[SP, #+12]
   \   000000C4   0x2002             MOVS     R0,#+2
   \   000000C6   0x9004             STR      R0,[SP, #+16]
   \   000000C8   0x200C             MOVS     R0,#+12
   \   000000CA   0x9005             STR      R0,[SP, #+20]
   \   000000CC   0x2008             MOVS     R0,#+8
   \   000000CE   0x9001             STR      R0,[SP, #+4]
   \   000000D0   0x....             LDR.N    R0,??DataTable10_4  ;; 0x40020800
   \   000000D2   0x.... 0x....      BL       HAL_GPIO_Init
    405          
    406            /* GPIOD configuration */
    407            gpio_init_structure.Pin   = GPIO_PIN_0 | GPIO_PIN_1 | GPIO_PIN_3 | GPIO_PIN_8 | GPIO_PIN_9 |
    408                                        GPIO_PIN_10 | GPIO_PIN_14 | GPIO_PIN_15;
   \   000000D6   0xF24C 0x700B      MOVW     R0,#+50955
    409            HAL_GPIO_Init(GPIOD, &gpio_init_structure);
   \   000000DA   0xA901             ADD      R1,SP,#+4
   \   000000DC   0x9001             STR      R0,[SP, #+4]
   \   000000DE   0x....             LDR.N    R0,??DataTable10_5  ;; 0x40020c00
   \   000000E0   0x.... 0x....      BL       HAL_GPIO_Init
    410          
    411            /* GPIOE configuration */  
    412            gpio_init_structure.Pin   = GPIO_PIN_0 | GPIO_PIN_1 | GPIO_PIN_7| GPIO_PIN_8 | GPIO_PIN_9 |\
    413                                        GPIO_PIN_10 | GPIO_PIN_11 | GPIO_PIN_12 | GPIO_PIN_13 | GPIO_PIN_14 |\
    414                                        GPIO_PIN_15;
   \   000000E4   0xF64F 0x7083      MOVW     R0,#+65411
    415            HAL_GPIO_Init(GPIOE, &gpio_init_structure);
   \   000000E8   0xA901             ADD      R1,SP,#+4
   \   000000EA   0x9001             STR      R0,[SP, #+4]
   \   000000EC   0x....             LDR.N    R0,??DataTable10_6  ;; 0x40021000
   \   000000EE   0x.... 0x....      BL       HAL_GPIO_Init
    416            
    417            /* GPIOF configuration */  
    418            gpio_init_structure.Pin   = GPIO_PIN_0 | GPIO_PIN_1 | GPIO_PIN_2| GPIO_PIN_3 | GPIO_PIN_4 |\
    419                                        GPIO_PIN_5 | GPIO_PIN_11 | GPIO_PIN_12 | GPIO_PIN_13 | GPIO_PIN_14 |\
    420                                        GPIO_PIN_15;
   \   000000F2   0xF64F 0x003F      MOVW     R0,#+63551
    421            HAL_GPIO_Init(GPIOF, &gpio_init_structure);
   \   000000F6   0xA901             ADD      R1,SP,#+4
   \   000000F8   0x9001             STR      R0,[SP, #+4]
   \   000000FA   0x....             LDR.N    R0,??DataTable10_7  ;; 0x40021400
   \   000000FC   0x.... 0x....      BL       HAL_GPIO_Init
    422            
    423            /* GPIOG configuration */  
    424            gpio_init_structure.Pin   = GPIO_PIN_0 | GPIO_PIN_1 | GPIO_PIN_4| GPIO_PIN_5 | GPIO_PIN_8 |\
    425                                        GPIO_PIN_15;
   \   00000100   0xF248 0x1033      MOVW     R0,#+33075
    426            HAL_GPIO_Init(GPIOG, &gpio_init_structure);
   \   00000104   0xA901             ADD      R1,SP,#+4
   \   00000106   0x9001             STR      R0,[SP, #+4]
   \   00000108   0x....             LDR.N    R0,??DataTable10_8  ;; 0x40021800
   \   0000010A   0x.... 0x....      BL       HAL_GPIO_Init
    427          
    428            /* GPIOH configuration */  
    429            gpio_init_structure.Pin   = GPIO_PIN_3 | GPIO_PIN_5;
   \   0000010E   0x2028             MOVS     R0,#+40
    430            HAL_GPIO_Init(GPIOH, &gpio_init_structure); 
   \   00000110   0xA901             ADD      R1,SP,#+4
   \   00000112   0x9001             STR      R0,[SP, #+4]
   \   00000114   0x....             LDR.N    R0,??DataTable10_9  ;; 0x40021c00
   \   00000116   0x.... 0x....      BL       HAL_GPIO_Init
    431            
    432            /* Configure common DMA parameters */
    433            dma_handle.Init.Channel             = SDRAM_DMAx_CHANNEL;
   \   0000011A   0x2000             MOVS     R0,#+0
   \   0000011C   0x6068             STR      R0,[R5, #+4]
    434            dma_handle.Init.Direction           = DMA_MEMORY_TO_MEMORY;
   \   0000011E   0x2080             MOVS     R0,#+128
   \   00000120   0x60A8             STR      R0,[R5, #+8]
    435            dma_handle.Init.PeriphInc           = DMA_PINC_ENABLE;
   \   00000122   0xF44F 0x7000      MOV      R0,#+512
   \   00000126   0x60E8             STR      R0,[R5, #+12]
    436            dma_handle.Init.MemInc              = DMA_MINC_ENABLE;
   \   00000128   0xF44F 0x6080      MOV      R0,#+1024
   \   0000012C   0x6128             STR      R0,[R5, #+16]
    437            dma_handle.Init.PeriphDataAlignment = DMA_PDATAALIGN_WORD;
   \   0000012E   0xF44F 0x5080      MOV      R0,#+4096
   \   00000132   0x6168             STR      R0,[R5, #+20]
    438            dma_handle.Init.MemDataAlignment    = DMA_MDATAALIGN_WORD;
   \   00000134   0xF44F 0x4080      MOV      R0,#+16384
   \   00000138   0x61A8             STR      R0,[R5, #+24]
    439            dma_handle.Init.Mode                = DMA_NORMAL;
   \   0000013A   0x2000             MOVS     R0,#+0
   \   0000013C   0x61E8             STR      R0,[R5, #+28]
    440            dma_handle.Init.Priority            = DMA_PRIORITY_HIGH;
   \   0000013E   0xF44F 0x3000      MOV      R0,#+131072
   \   00000142   0x6228             STR      R0,[R5, #+32]
    441            dma_handle.Init.FIFOMode            = DMA_FIFOMODE_DISABLE;         
   \   00000144   0x2000             MOVS     R0,#+0
   \   00000146   0x6268             STR      R0,[R5, #+36]
    442            dma_handle.Init.FIFOThreshold       = DMA_FIFO_THRESHOLD_FULL;
   \   00000148   0x2003             MOVS     R0,#+3
   \   0000014A   0x62A8             STR      R0,[R5, #+40]
    443            dma_handle.Init.MemBurst            = DMA_MBURST_SINGLE;
   \   0000014C   0x2000             MOVS     R0,#+0
   \   0000014E   0x62E8             STR      R0,[R5, #+44]
    444            dma_handle.Init.PeriphBurst         = DMA_PBURST_SINGLE; 
   \   00000150   0x6328             STR      R0,[R5, #+48]
    445            
    446            dma_handle.Instance = SDRAM_DMAx_STREAM;
   \   00000152   0x....             LDR.N    R0,??DataTable10_10  ;; 0x40026410
   \   00000154   0x6028             STR      R0,[R5, #+0]
    447            
    448             /* Associate the DMA handle */
    449            __HAL_LINKDMA(hsdram, hdma, dma_handle);
    450            
    451            /* Deinitialize the stream for new transfer */
    452            HAL_DMA_DeInit(&dma_handle);
   \   00000156   0x4628             MOV      R0,R5
   \   00000158   0x6325             STR      R5,[R4, #+48]
   \   0000015A   0x63AC             STR      R4,[R5, #+56]
   \   0000015C   0x.... 0x....      BL       HAL_DMA_DeInit
    453            
    454            /* Configure the DMA stream */
    455            HAL_DMA_Init(&dma_handle); 
   \   00000160   0x4628             MOV      R0,R5
   \   00000162   0x.... 0x....      BL       HAL_DMA_Init
    456            
    457            /* NVIC configuration for DMA transfer complete interrupt */
    458            HAL_NVIC_SetPriority(SDRAM_DMAx_IRQn, 5, 0);
   \   00000166   0x2200             MOVS     R2,#+0
   \   00000168   0x2105             MOVS     R1,#+5
   \   0000016A   0x2038             MOVS     R0,#+56
   \   0000016C   0x.... 0x....      BL       HAL_NVIC_SetPriority
    459            HAL_NVIC_EnableIRQ(SDRAM_DMAx_IRQn);
   \   00000170   0x2038             MOVS     R0,#+56
   \   00000172   0x.... 0x....      BL       HAL_NVIC_EnableIRQ
    460          }
   \   00000176   0xB007             ADD      SP,SP,#+28
   \   00000178   0xBD30             POP      {R4,R5,PC}       ;; return

   \                                 In section .bss, align 4
   \                     ??dma_handle:
   \   00000000                      DS8 88
    461          
    462          /**
    463            * @brief  DeInitializes SDRAM MSP.
    464            * @param  hsdram: SDRAM handle
    465            * @param  Params
    466            * @retval None
    467            */

   \                                 In section .text, align 2, keep-with-next
    468          __weak void BSP_SDRAM_MspDeInit(SDRAM_HandleTypeDef  *hsdram, void *Params)
    469          {  
   \                     BSP_SDRAM_MspDeInit: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB081             SUB      SP,SP,#+4
    470              static DMA_HandleTypeDef dma_handle;
    471            
    472              /* Disable NVIC configuration for DMA interrupt */
    473              HAL_NVIC_DisableIRQ(SDRAM_DMAx_IRQn);
   \   00000004   0x2038             MOVS     R0,#+56
   \   00000006   0x.... 0x....      BL       HAL_NVIC_DisableIRQ
    474          
    475              /* Deinitialize the stream for new transfer */
    476              dma_handle.Instance = SDRAM_DMAx_STREAM;
   \   0000000A   0x....             LDR.N    R0,??DataTable10_11
   \   0000000C   0x....             LDR.N    R1,??DataTable10_10  ;; 0x40026410
   \   0000000E   0x6001             STR      R1,[R0, #+0]
    477              HAL_DMA_DeInit(&dma_handle);
   \   00000010   0xB001             ADD      SP,SP,#+4
   \   00000012   0xF85D 0xEB04      POP      {LR}
   \   00000016   0x.... 0x....      B.W      HAL_DMA_DeInit
    478          
    479              /* GPIO pins clock, FMC clock and DMA clock can be shut down in the applications
    480                 by surcharging this __weak function */ 
    481          }

   \                                 In section .bss, align 4
   \                     ??dma_handle_1:
   \   00000000                      DS8 88

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10:
   \   00000000   0x........         DC32     sdramHandle

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_1:
   \   00000000   0xA0000140         DC32     0xa0000140

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_2:
   \   00000000   0x........         DC32     ??dma_handle

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_3:
   \   00000000   0x40023830         DC32     0x40023830

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_4:
   \   00000000   0x40020800         DC32     0x40020800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_5:
   \   00000000   0x40020C00         DC32     0x40020c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_6:
   \   00000000   0x40021000         DC32     0x40021000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_7:
   \   00000000   0x40021400         DC32     0x40021400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_8:
   \   00000000   0x40021800         DC32     0x40021800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_9:
   \   00000000   0x40021C00         DC32     0x40021c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_10:
   \   00000000   0x40026410         DC32     0x40026410

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_11:
   \   00000000   0x........         DC32     ??dma_handle_1
    482          
    483          /**
    484            * @}
    485            */  
    486            
    487          /**
    488            * @}
    489            */ 
    490            
    491          /**
    492            * @}
    493            */ 
    494            
    495          /**
    496            * @}
    497            */ 
    498          
    499          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   BSP_SDRAM_DMA_IRQHandler
         0   -> HAL_DMA_IRQHandler
       8   BSP_SDRAM_DeInit
         8   -> BSP_SDRAM_MspDeInit
         8   -> HAL_SDRAM_DeInit
      16   BSP_SDRAM_Init
        16   -> BSP_SDRAM_MspInit
        16   -> HAL_Delay
        16   -> HAL_SDRAM_Init
        16   -> HAL_SDRAM_ProgramRefreshRate
        16   -> HAL_SDRAM_SendCommand
      24   BSP_SDRAM_Initialization_sequence
        24   -> HAL_Delay
         0   -> HAL_SDRAM_ProgramRefreshRate
        24   -> HAL_SDRAM_SendCommand
       8   BSP_SDRAM_MspDeInit
         0   -> HAL_DMA_DeInit
         8   -> HAL_NVIC_DisableIRQ
      40   BSP_SDRAM_MspInit
        40   -> HAL_DMA_DeInit
        40   -> HAL_DMA_Init
        40   -> HAL_GPIO_Init
        40   -> HAL_NVIC_EnableIRQ
        40   -> HAL_NVIC_SetPriority
       8   BSP_SDRAM_ReadData
         8   -> HAL_SDRAM_Read_32b
       8   BSP_SDRAM_ReadData_DMA
         8   -> HAL_SDRAM_Read_DMA
       8   BSP_SDRAM_Sendcmd
         8   -> HAL_SDRAM_SendCommand
       8   BSP_SDRAM_WriteData
         8   -> HAL_SDRAM_Write_32b
       8   BSP_SDRAM_WriteData_DMA
         8   -> HAL_SDRAM_Write_DMA


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable10
       4  ??DataTable10_1
       4  ??DataTable10_10
       4  ??DataTable10_11
       4  ??DataTable10_2
       4  ??DataTable10_3
       4  ??DataTable10_4
       4  ??DataTable10_5
       4  ??DataTable10_6
       4  ??DataTable10_7
       4  ??DataTable10_8
       4  ??DataTable10_9
       8  BSP_SDRAM_DMA_IRQHandler
      40  BSP_SDRAM_DeInit
     262  BSP_SDRAM_Init
     154  BSP_SDRAM_Initialization_sequence
      26  BSP_SDRAM_MspDeInit
     378  BSP_SDRAM_MspInit
      28  BSP_SDRAM_ReadData
      28  BSP_SDRAM_ReadData_DMA
      28  BSP_SDRAM_Sendcmd
      28  BSP_SDRAM_WriteData
      28  BSP_SDRAM_WriteData_DMA
      88  dma_handle
      88  dma_handle
      98  sdramHandle
          Timing
          Command
          sdramstatus
          sdramstatus

 
   176 bytes in section .bss
    98 bytes in section .data
 1 056 bytes in section .text
 
 1 056 bytes of CODE memory
   274 bytes of DATA memory

Errors: none
Warnings: none
