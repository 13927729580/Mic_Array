###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.2.10312/W32 for ARM       22/Dec/2015  15:52:40
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\sop1hc\Github\data\Mic_Array_V00\Mic_Array\Drivers\BSP\STM32746G-Discovery\stm32746g_discovery_sdram.c
#    Command line =  
#        D:\sop1hc\Github\data\Mic_Array_V00\Mic_Array\Drivers\BSP\STM32746G-Discovery\stm32746g_discovery_sdram.c
#        -D USE_HAL_DRIVER -D STM32F746xx -D USE_STM32746G_DISCO -D
#        USE_IOEXPANDER -D USE_USB_FS -lC
#        D:\sop1hc\Github\data\Mic_Array_V00\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
#        -lA
#        D:\sop1hc\Github\data\Mic_Array_V00\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
#        -o
#        D:\sop1hc\Github\data\Mic_Array_V00\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj
#        --debug --endian=little --cpu=Cortex-M7 -e --fpu=VFPv5_sp
#        --dlib_config "D:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Full.h" -I
#        D:\sop1hc\Github\data\Mic_Array_V00\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\CMSIS\Device\ST\STM32F7xx\Include\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\STM32F7xx_HAL_Driver\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\STM32746G-Discovery\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\Components\Common\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Log\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Fonts\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\CPU\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_Device_Library\Core\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Core\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Class\MSC\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\drivers\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_Audio\Addons\PDM\
#        -Ohz --use_c++_inline --require_prototypes -I "D:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.3\arm\CMSIS\Include\" -D
#        ARM_MATH_CM7
#    List file    =  
#        D:\sop1hc\Github\data\Mic_Array_V00\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List\stm32746g_discovery_sdram.lst
#    Object file  =  
#        D:\sop1hc\Github\data\Mic_Array_V00\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj\stm32746g_discovery_sdram.o
#
###############################################################################

D:\sop1hc\Github\data\Mic_Array_V00\Mic_Array\Drivers\BSP\STM32746G-Discovery\stm32746g_discovery_sdram.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32746g_discovery_sdram.c
      4            * @author  MCD Application Team
      5            * @version V1.0.0
      6            * @date    25-June-2015
      7            * @brief   This file includes the SDRAM driver for the MT48LC4M32B2B5-7 memory 
      8            *          device mounted on STM32746G-Discovery board.
      9            @verbatim
     10             1. How To use this driver:
     11             --------------------------
     12                - This driver is used to drive the MT48LC4M32B2B5-7 SDRAM external memory mounted
     13                  on STM32746G-Discovery board.
     14                - This driver does not need a specific component driver for the SDRAM device
     15                  to be included with.
     16             
     17             2. Driver description:
     18             ---------------------
     19               + Initialization steps:
     20                  o Initialize the SDRAM external memory using the BSP_SDRAM_Init() function. This 
     21                    function includes the MSP layer hardware resources initialization and the
     22                    FMC controller configuration to interface with the external SDRAM memory.
     23                  o It contains the SDRAM initialization sequence to program the SDRAM external 
     24                    device using the function BSP_SDRAM_Initialization_sequence(). Note that this 
     25                    sequence is standard for all SDRAM devices, but can include some differences
     26                    from a device to another. If it is the case, the right sequence should be 
     27                    implemented separately.
     28               
     29               + SDRAM read/write operations
     30                  o SDRAM external memory can be accessed with read/write operations once it is
     31                    initialized.
     32                    Read/write operation can be performed with AHB access using the functions
     33                    BSP_SDRAM_ReadData()/BSP_SDRAM_WriteData(), or by DMA transfer using the functions
     34                    BSP_SDRAM_ReadData_DMA()/BSP_SDRAM_WriteData_DMA().
     35                  o The AHB access is performed with 32-bit width transaction, the DMA transfer
     36                    configuration is fixed at single (no burst) word transfer (see the 
     37                    SDRAM_MspInit() static function).
     38                  o User can implement his own functions for read/write access with his desired 
     39                    configurations.
     40                  o If interrupt mode is used for DMA transfer, the function BSP_SDRAM_DMA_IRQHandler()
     41                    is called in IRQ handler file, to serve the generated interrupt once the DMA 
     42                    transfer is complete.
     43                  o You can send a command to the SDRAM device in runtime using the function 
     44                    BSP_SDRAM_Sendcmd(), and giving the desired command as parameter chosen between 
     45                    the predefined commands of the "FMC_SDRAM_CommandTypeDef" structure. 
     46           
     47            @endverbatim
     48            ******************************************************************************
     49            * @attention
     50            *
     51            * <h2><center>&copy; COPYRIGHT(c) 2015 STMicroelectronics</center></h2>
     52            *
     53            * Redistribution and use in source and binary forms, with or without modification,
     54            * are permitted provided that the following conditions are met:
     55            *   1. Redistributions of source code must retain the above copyright notice,
     56            *      this list of conditions and the following disclaimer.
     57            *   2. Redistributions in binary form must reproduce the above copyright notice,
     58            *      this list of conditions and the following disclaimer in the documentation
     59            *      and/or other materials provided with the distribution.
     60            *   3. Neither the name of STMicroelectronics nor the names of its contributors
     61            *      may be used to endorse or promote products derived from this software
     62            *      without specific prior written permission.
     63            *
     64            * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
     65            * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     66            * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     67            * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
     68            * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
     69            * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
     70            * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
     71            * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
     72            * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
     73            * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     74            *
     75            ******************************************************************************
     76            */
     77          
     78          /* Includes ------------------------------------------------------------------*/
     79          #include "stm32746g_discovery_sdram.h"
     80          
     81          /** @addtogroup BSP
     82            * @{
     83            */
     84          
     85          /** @addtogroup STM32746G_DISCOVERY
     86            * @{
     87            */ 
     88            
     89          /** @defgroup STM32746G_DISCOVERY_SDRAM STM32746G_DISCOVERY_SDRAM
     90            * @{
     91            */ 
     92          
     93          /** @defgroup STM32746G_DISCOVERY_SDRAM_Private_Types_Definitions STM32746G_DISCOVERY_SDRAM Private Types Definitions
     94            * @{
     95            */ 
     96          /**
     97            * @}
     98            */
     99          
    100          /** @defgroup STM32746G_DISCOVERY_SDRAM_Private_Defines STM32746G_DISCOVERY_SDRAM Private Defines
    101            * @{
    102            */
    103          /**
    104            * @}
    105            */
    106          
    107          /** @defgroup STM32746G_DISCOVERY_SDRAM_Private_Macros STM32746G_DISCOVERY_SDRAM Private Macros
    108            * @{
    109            */  
    110          /**
    111            * @}
    112            */
    113          
    114          /** @defgroup STM32746G_DISCOVERY_SDRAM_Private_Variables STM32746G_DISCOVERY_SDRAM Private Variables
    115            * @{
    116            */       
    117          static SDRAM_HandleTypeDef sdramHandle;
    118          static FMC_SDRAM_TimingTypeDef Timing;
    119          static FMC_SDRAM_CommandTypeDef Command;
    120          /**
    121            * @}
    122            */ 
    123          
    124          /** @defgroup STM32746G_DISCOVERY_SDRAM_Private_Function_Prototypes STM32746G_DISCOVERY_SDRAM Private Function Prototypes
    125            * @{
    126            */ 
    127          /**
    128            * @}
    129            */
    130              
    131          /** @defgroup STM32746G_DISCOVERY_SDRAM_Exported_Functions STM32746G_DISCOVERY_SDRAM Exported Functions
    132            * @{
    133            */ 
    134          
    135          /**
    136            * @brief  Initializes the SDRAM device.
    137            * @retval SDRAM status
    138            */

   \                                 In section .text, align 2, keep-with-next
    139          uint8_t BSP_SDRAM_Init(void)
    140          { 
   \                     BSP_SDRAM_Init: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    141            static uint8_t sdramstatus = SDRAM_ERROR;
    142            /* SDRAM device configuration */
    143            sdramHandle.Instance = FMC_SDRAM_DEVICE;
   \   00000002   0x.... 0x....      BL       ?Subroutine2
    144              
    145            /* Timing configuration for 100Mhz as SD clock frequency (System clock is up to 200Mhz) */
    146            Timing.LoadToActiveDelay    = 2;
   \                     ??CrossCallReturnLabel_2: (+1)
   \   00000006   0x2002             MOVS     R0,#+2
   \   00000008   0x63A0             STR      R0,[R4, #+56]
    147            Timing.ExitSelfRefreshDelay = 7;
   \   0000000A   0x2007             MOVS     R0,#+7
   \   0000000C   0x63E0             STR      R0,[R4, #+60]
    148            Timing.SelfRefreshTime      = 4;
   \   0000000E   0x2004             MOVS     R0,#+4
   \   00000010   0x6420             STR      R0,[R4, #+64]
    149            Timing.RowCycleDelay        = 7;
   \   00000012   0x2007             MOVS     R0,#+7
   \   00000014   0x6460             STR      R0,[R4, #+68]
    150            Timing.WriteRecoveryTime    = 2;
   \   00000016   0x2002             MOVS     R0,#+2
   \   00000018   0x64A0             STR      R0,[R4, #+72]
    151            Timing.RPDelay              = 2;
    152            Timing.RCDDelay             = 2;
    153            
    154            sdramHandle.Init.SDBank             = FMC_SDRAM_BANK1;
    155            sdramHandle.Init.ColumnBitsNumber   = FMC_SDRAM_COLUMN_BITS_NUM_8;
    156            sdramHandle.Init.RowBitsNumber      = FMC_SDRAM_ROW_BITS_NUM_12;
    157            sdramHandle.Init.MemoryDataWidth    = SDRAM_MEMORY_WIDTH;
    158            sdramHandle.Init.InternalBankNumber = FMC_SDRAM_INTERN_BANKS_NUM_4;
    159            sdramHandle.Init.CASLatency         = FMC_SDRAM_CAS_LATENCY_2;
    160            sdramHandle.Init.WriteProtection    = FMC_SDRAM_WRITE_PROTECTION_DISABLE;
    161            sdramHandle.Init.SDClockPeriod      = SDCLOCK_PERIOD;
    162            sdramHandle.Init.ReadBurst          = FMC_SDRAM_RBURST_ENABLE;
    163            sdramHandle.Init.ReadPipeDelay      = FMC_SDRAM_RPIPE_DELAY_0;
    164            
    165            /* SDRAM controller initialization */
    166          
    167            BSP_SDRAM_MspInit(&sdramHandle, NULL); /* __weak function can be rewritten by the application */
   \   0000001A   0x2100             MOVS     R1,#+0
   \   0000001C   0x64E0             STR      R0,[R4, #+76]
   \   0000001E   0x6520             STR      R0,[R4, #+80]
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0x60A0             STR      R0,[R4, #+8]
   \   00000024   0x60E0             STR      R0,[R4, #+12]
   \   00000026   0x2004             MOVS     R0,#+4
   \   00000028   0x6120             STR      R0,[R4, #+16]
   \   0000002A   0x2010             MOVS     R0,#+16
   \   0000002C   0x6160             STR      R0,[R4, #+20]
   \   0000002E   0x2040             MOVS     R0,#+64
   \   00000030   0x61A0             STR      R0,[R4, #+24]
   \   00000032   0xF44F 0x7080      MOV      R0,#+256
   \   00000036   0x61E0             STR      R0,[R4, #+28]
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0x6220             STR      R0,[R4, #+32]
   \   0000003C   0xF44F 0x6000      MOV      R0,#+2048
   \   00000040   0x6260             STR      R0,[R4, #+36]
   \   00000042   0xF44F 0x5080      MOV      R0,#+4096
   \   00000046   0x62A0             STR      R0,[R4, #+40]
   \   00000048   0x2000             MOVS     R0,#+0
   \   0000004A   0x62E0             STR      R0,[R4, #+44]
   \   0000004C   0x1D20             ADDS     R0,R4,#+4
   \   0000004E   0x.... 0x....      BL       BSP_SDRAM_MspInit
    168          
    169            if(HAL_SDRAM_Init(&sdramHandle, &Timing) != HAL_OK)
   \   00000052   0xF104 0x0138      ADD      R1,R4,#+56
   \   00000056   0x1D20             ADDS     R0,R4,#+4
   \   00000058   0x.... 0x....      BL       HAL_SDRAM_Init
   \   0000005C   0xB100             CBZ.N    R0,??BSP_SDRAM_Init_0
   \   0000005E   0x2001             MOVS     R0,#+1
   \                     ??BSP_SDRAM_Init_0: (+1)
   \   00000060   0x7020             STRB     R0,[R4, #+0]
    170            {
    171              sdramstatus = SDRAM_ERROR;
    172            }
    173            else
    174            {
    175              sdramstatus = SDRAM_OK;
    176            }
    177            
    178            /* SDRAM initialization sequence */
    179            BSP_SDRAM_Initialization_sequence(REFRESH_COUNT);
   \   00000062   0xF240 0x6003      MOVW     R0,#+1539
   \   00000066   0x.... 0x....      BL       BSP_SDRAM_Initialization_sequence
    180            
    181            return sdramstatus;
   \   0000006A   0x7820             LDRB     R0,[R4, #+0]
   \   0000006C   0xBD10             POP      {R4,PC}          ;; return
    182          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine2: (+1)
   \   00000000   0x....             LDR.N    R4,??DataTable8
   \   00000002   0x....             LDR.N    R0,??DataTable8_1  ;; 0xa0000140
   \   00000004   0x6060             STR      R0,[R4, #+4]
   \   00000006   0x4770             BX       LR
    183          
    184          /**
    185            * @brief  DeInitializes the SDRAM device.
    186            * @retval SDRAM status
    187            */

   \                                 In section .text, align 2, keep-with-next
    188          uint8_t BSP_SDRAM_DeInit(void)
    189          { 
   \                     BSP_SDRAM_DeInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    190            static uint8_t sdramstatus = SDRAM_ERROR;
    191            /* SDRAM device de-initialization */
    192            sdramHandle.Instance = FMC_SDRAM_DEVICE;
   \   00000002   0x.... 0x....      BL       ?Subroutine2
    193          
    194            if(HAL_SDRAM_DeInit(&sdramHandle) != HAL_OK)
   \                     ??CrossCallReturnLabel_3: (+1)
   \   00000006   0x1D20             ADDS     R0,R4,#+4
   \   00000008   0x.... 0x....      BL       HAL_SDRAM_DeInit
   \   0000000C   0xB100             CBZ.N    R0,??BSP_SDRAM_DeInit_0
   \   0000000E   0x2001             MOVS     R0,#+1
   \                     ??BSP_SDRAM_DeInit_0: (+1)
   \   00000010   0x7060             STRB     R0,[R4, #+1]
    195            {
    196              sdramstatus = SDRAM_ERROR;
    197            }
    198            else
    199            {
    200              sdramstatus = SDRAM_OK;
    201            }
    202            
    203            /* SDRAM controller de-initialization */
    204            BSP_SDRAM_MspDeInit(&sdramHandle, NULL);
   \   00000012   0x2100             MOVS     R1,#+0
   \   00000014   0x1D20             ADDS     R0,R4,#+4
   \   00000016   0x.... 0x....      BL       BSP_SDRAM_MspDeInit
    205            
    206            return sdramstatus;
   \   0000001A   0x7860             LDRB     R0,[R4, #+1]
   \   0000001C   0xBD10             POP      {R4,PC}          ;; return
    207          }

   \                                 In section .data, align 4
   \                     ??sdramstatus:
   \   00000000   0x01               DC8 1
   \   00000001   0x01               DC8 1
   \   00000002   0x00 0x00          DC8 0, 0
   \   00000004   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000014   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000024   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000038   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000048   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000054   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
    208          
    209          /**
    210            * @brief  Programs the SDRAM device.
    211            * @param  RefreshCount: SDRAM refresh counter value 
    212            * @retval None
    213            */

   \                                 In section .text, align 2, keep-with-next
    214          void BSP_SDRAM_Initialization_sequence(uint32_t RefreshCount)
    215          {
   \                     BSP_SDRAM_Initialization_sequence: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0xB082             SUB      SP,SP,#+8
    216            __IO uint32_t tmpmrd = 0;
   \   00000006   0x2000             MOVS     R0,#+0
    217            
    218            /* Step 1: Configure a clock configuration enable command */
    219            Command.CommandMode            = FMC_SDRAM_CMD_CLK_ENABLE;
   \   00000008   0x....             LDR.N    R5,??DataTable8
   \   0000000A   0x9000             STR      R0,[SP, #+0]
   \   0000000C   0x2001             MOVS     R0,#+1
   \   0000000E   0x.... 0x....      BL       ?Subroutine3
    220            Command.CommandTarget          = FMC_SDRAM_CMD_TARGET_BANK1;
    221            Command.AutoRefreshNumber      = 1;
    222            Command.ModeRegisterDefinition = 0;
   \                     ??CrossCallReturnLabel_4: (+1)
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0x6628             STR      R0,[R5, #+96]
    223          
    224            /* Send the command */
    225            HAL_SDRAM_SendCommand(&sdramHandle, &Command, SDRAM_TIMEOUT);
   \   00000016   0xF64F 0x76FF      MOVW     R6,#+65535
   \   0000001A   0x4632             MOV      R2,R6
   \   0000001C   0xF105 0x0154      ADD      R1,R5,#+84
   \   00000020   0x1D28             ADDS     R0,R5,#+4
   \   00000022   0x.... 0x....      BL       HAL_SDRAM_SendCommand
    226          
    227            /* Step 2: Insert 100 us minimum delay */ 
    228            /* Inserted delay is equal to 1 ms due to systick time base unit (ms) */
    229            HAL_Delay(1);
   \   00000026   0x2001             MOVS     R0,#+1
   \   00000028   0x.... 0x....      BL       HAL_Delay
    230              
    231            /* Step 3: Configure a PALL (precharge all) command */ 
    232            Command.CommandMode            = FMC_SDRAM_CMD_PALL;
   \   0000002C   0x2002             MOVS     R0,#+2
    233            Command.CommandTarget          = FMC_SDRAM_CMD_TARGET_BANK1;
    234            Command.AutoRefreshNumber      = 1;
    235            Command.ModeRegisterDefinition = 0;
    236          
    237            /* Send the command */
    238            HAL_SDRAM_SendCommand(&sdramHandle, &Command, SDRAM_TIMEOUT);  
   \   0000002E   0x4632             MOV      R2,R6
   \   00000030   0x6568             STR      R0,[R5, #+84]
   \   00000032   0x2010             MOVS     R0,#+16
   \   00000034   0x65A8             STR      R0,[R5, #+88]
   \   00000036   0x2001             MOVS     R0,#+1
   \   00000038   0x.... 0x....      BL       ?Subroutine1
    239            
    240            /* Step 4: Configure an Auto Refresh command */ 
    241            Command.CommandMode            = FMC_SDRAM_CMD_AUTOREFRESH_MODE;
   \                     ??CrossCallReturnLabel_1: (+1)
   \   0000003C   0x2003             MOVS     R0,#+3
    242            Command.CommandTarget          = FMC_SDRAM_CMD_TARGET_BANK1;
    243            Command.AutoRefreshNumber      = 8;
    244            Command.ModeRegisterDefinition = 0;
    245          
    246            /* Send the command */
    247            HAL_SDRAM_SendCommand(&sdramHandle, &Command, SDRAM_TIMEOUT);
   \   0000003E   0x4632             MOV      R2,R6
   \   00000040   0x6568             STR      R0,[R5, #+84]
   \   00000042   0x2010             MOVS     R0,#+16
   \   00000044   0x65A8             STR      R0,[R5, #+88]
   \   00000046   0x2008             MOVS     R0,#+8
   \   00000048   0x.... 0x....      BL       ?Subroutine1
    248            
    249            /* Step 5: Program the external memory mode register */
    250            tmpmrd = (uint32_t)SDRAM_MODEREG_BURST_LENGTH_1          |\
    251                               SDRAM_MODEREG_BURST_TYPE_SEQUENTIAL   |\
    252                               SDRAM_MODEREG_CAS_LATENCY_2           |\
    253                               SDRAM_MODEREG_OPERATING_MODE_STANDARD |\
    254                               SDRAM_MODEREG_WRITEBURST_MODE_SINGLE;
   \                     ??CrossCallReturnLabel_0: (+1)
   \   0000004C   0xF44F 0x7008      MOV      R0,#+544
    255            
    256            Command.CommandMode            = FMC_SDRAM_CMD_LOAD_MODE;
    257            Command.CommandTarget          = FMC_SDRAM_CMD_TARGET_BANK1;
    258            Command.AutoRefreshNumber      = 1;
    259            Command.ModeRegisterDefinition = tmpmrd;
    260          
    261            /* Send the command */
    262            HAL_SDRAM_SendCommand(&sdramHandle, &Command, SDRAM_TIMEOUT);
   \   00000050   0x4632             MOV      R2,R6
   \   00000052   0x9000             STR      R0,[SP, #+0]
   \   00000054   0x2004             MOVS     R0,#+4
   \   00000056   0x.... 0x....      BL       ?Subroutine3
   \                     ??CrossCallReturnLabel_5: (+1)
   \   0000005A   0x9800             LDR      R0,[SP, #+0]
   \   0000005C   0xF105 0x0154      ADD      R1,R5,#+84
   \   00000060   0x6628             STR      R0,[R5, #+96]
   \   00000062   0x1D28             ADDS     R0,R5,#+4
   \   00000064   0x.... 0x....      BL       HAL_SDRAM_SendCommand
    263            
    264            /* Step 6: Set the refresh rate counter */
    265            /* Set the device refresh rate */
    266            HAL_SDRAM_ProgramRefreshRate(&sdramHandle, RefreshCount); 
   \   00000068   0x4621             MOV      R1,R4
   \   0000006A   0x1D28             ADDS     R0,R5,#+4
   \   0000006C   0xE8BD 0x407C      POP      {R2-R6,LR}
   \   00000070   0x.... 0x....      B.W      HAL_SDRAM_ProgramRefreshRate
    267          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine3: (+1)
   \   00000000   0x6568             STR      R0,[R5, #+84]
   \   00000002   0x2010             MOVS     R0,#+16
   \   00000004   0x65A8             STR      R0,[R5, #+88]
   \   00000006   0x2001             MOVS     R0,#+1
   \   00000008   0x65E8             STR      R0,[R5, #+92]
   \   0000000A   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \   00000000   0x65E8             STR      R0,[R5, #+92]
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0x6628             STR      R0,[R5, #+96]
   \   00000006   0xF105 0x0154      ADD      R1,R5,#+84
   \   0000000A   0x1D28             ADDS     R0,R5,#+4
   \   0000000C   0x.... 0x....      B.W      HAL_SDRAM_SendCommand
    268          
    269          /**
    270            * @brief  Reads an amount of data from the SDRAM memory in polling mode.
    271            * @param  uwStartAddress: Read start address
    272            * @param  pData: Pointer to data to be read  
    273            * @param  uwDataSize: Size of read data from the memory
    274            * @retval SDRAM status
    275            */

   \                                 In section .text, align 2, keep-with-next
    276          uint8_t BSP_SDRAM_ReadData(uint32_t uwStartAddress, uint32_t *pData, uint32_t uwDataSize)
    277          {
    278            if(HAL_SDRAM_Read_32b(&sdramHandle, (uint32_t *)uwStartAddress, pData, uwDataSize) != HAL_OK)
   \                     BSP_SDRAM_ReadData: (+1)
   \   00000000   0x4613             MOV      R3,R2
   \   00000002   0x460A             MOV      R2,R1
   \   00000004   0x4601             MOV      R1,R0
   \   00000006   0x....             LDR.N    R0,??DataTable8_2
   \   00000008   0xB580             PUSH     {R7,LR}
   \   0000000A   0x.... 0x....      BL       HAL_SDRAM_Read_32b
   \   0000000E   0x....             B.N      ?Subroutine0
    279            {
    280              return SDRAM_ERROR;
    281            }
    282            else
    283            {
    284              return SDRAM_OK;
    285            } 
    286          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \   00000000   0xB100             CBZ.N    R0,??Subroutine0_0
   \   00000002   0x2001             MOVS     R0,#+1
   \                     ??Subroutine0_0: (+1)
   \   00000004   0xBD02             POP      {R1,PC}          ;; return
    287          
    288          /**
    289            * @brief  Reads an amount of data from the SDRAM memory in DMA mode.
    290            * @param  uwStartAddress: Read start address
    291            * @param  pData: Pointer to data to be read  
    292            * @param  uwDataSize: Size of read data from the memory
    293            * @retval SDRAM status
    294            */

   \                                 In section .text, align 2, keep-with-next
    295          uint8_t BSP_SDRAM_ReadData_DMA(uint32_t uwStartAddress, uint32_t *pData, uint32_t uwDataSize)
    296          {
    297            if(HAL_SDRAM_Read_DMA(&sdramHandle, (uint32_t *)uwStartAddress, pData, uwDataSize) != HAL_OK)
   \                     BSP_SDRAM_ReadData_DMA: (+1)
   \   00000000   0x4613             MOV      R3,R2
   \   00000002   0x460A             MOV      R2,R1
   \   00000004   0x4601             MOV      R1,R0
   \   00000006   0x....             LDR.N    R0,??DataTable8_2
   \   00000008   0xB580             PUSH     {R7,LR}
   \   0000000A   0x.... 0x....      BL       HAL_SDRAM_Read_DMA
   \   0000000E                      REQUIRE ?Subroutine0
   \   0000000E                      ;; // Fall through to label ?Subroutine0
    298            {
    299              return SDRAM_ERROR;
    300            }
    301            else
    302            {
    303              return SDRAM_OK;
    304            }     
    305          }
    306          
    307          /**
    308            * @brief  Writes an amount of data to the SDRAM memory in polling mode.
    309            * @param  uwStartAddress: Write start address
    310            * @param  pData: Pointer to data to be written  
    311            * @param  uwDataSize: Size of written data from the memory
    312            * @retval SDRAM status
    313            */

   \                                 In section .text, align 2, keep-with-next
    314          uint8_t BSP_SDRAM_WriteData(uint32_t uwStartAddress, uint32_t *pData, uint32_t uwDataSize) 
    315          {
    316            if(HAL_SDRAM_Write_32b(&sdramHandle, (uint32_t *)uwStartAddress, pData, uwDataSize) != HAL_OK)
   \                     BSP_SDRAM_WriteData: (+1)
   \   00000000   0x4613             MOV      R3,R2
   \   00000002   0x460A             MOV      R2,R1
   \   00000004   0x4601             MOV      R1,R0
   \   00000006   0x....             LDR.N    R0,??DataTable8_2
   \   00000008   0xB580             PUSH     {R7,LR}
   \   0000000A   0x.... 0x....      BL       HAL_SDRAM_Write_32b
   \   0000000E   0x....             B.N      ?Subroutine0
    317            {
    318              return SDRAM_ERROR;
    319            }
    320            else
    321            {
    322              return SDRAM_OK;
    323            }
    324          }
    325          
    326          /**
    327            * @brief  Writes an amount of data to the SDRAM memory in DMA mode.
    328            * @param  uwStartAddress: Write start address
    329            * @param  pData: Pointer to data to be written  
    330            * @param  uwDataSize: Size of written data from the memory
    331            * @retval SDRAM status
    332            */

   \                                 In section .text, align 2, keep-with-next
    333          uint8_t BSP_SDRAM_WriteData_DMA(uint32_t uwStartAddress, uint32_t *pData, uint32_t uwDataSize) 
    334          {
    335            if(HAL_SDRAM_Write_DMA(&sdramHandle, (uint32_t *)uwStartAddress, pData, uwDataSize) != HAL_OK)
   \                     BSP_SDRAM_WriteData_DMA: (+1)
   \   00000000   0x4613             MOV      R3,R2
   \   00000002   0x460A             MOV      R2,R1
   \   00000004   0x4601             MOV      R1,R0
   \   00000006   0x....             LDR.N    R0,??DataTable8_2
   \   00000008   0xB580             PUSH     {R7,LR}
   \   0000000A   0x.... 0x....      BL       HAL_SDRAM_Write_DMA
   \   0000000E   0x....             B.N      ?Subroutine0
    336            {
    337              return SDRAM_ERROR;
    338            }
    339            else
    340            {
    341              return SDRAM_OK;
    342            } 
    343          }
    344          
    345          /**
    346            * @brief  Sends command to the SDRAM bank.
    347            * @param  SdramCmd: Pointer to SDRAM command structure 
    348            * @retval SDRAM status
    349            */  

   \                                 In section .text, align 2, keep-with-next
    350          uint8_t BSP_SDRAM_Sendcmd(FMC_SDRAM_CommandTypeDef *SdramCmd)
    351          {
    352            if(HAL_SDRAM_SendCommand(&sdramHandle, SdramCmd, SDRAM_TIMEOUT) != HAL_OK)
   \                     BSP_SDRAM_Sendcmd: (+1)
   \   00000000   0x4601             MOV      R1,R0
   \   00000002   0xF64F 0x72FF      MOVW     R2,#+65535
   \   00000006   0xB580             PUSH     {R7,LR}
   \   00000008   0x....             LDR.N    R0,??DataTable8_2
   \   0000000A   0x.... 0x....      BL       HAL_SDRAM_SendCommand
   \   0000000E   0x....             B.N      ?Subroutine0
    353            {
    354              return SDRAM_ERROR;
    355            }
    356            else
    357            {
    358              return SDRAM_OK;
    359            }
    360          }
    361          
    362          /**
    363            * @brief  Handles SDRAM DMA transfer interrupt request.
    364            * @retval None
    365            */

   \                                 In section .text, align 2, keep-with-next
    366          void BSP_SDRAM_DMA_IRQHandler(void)
    367          {
    368            HAL_DMA_IRQHandler(sdramHandle.hdma); 
   \                     BSP_SDRAM_DMA_IRQHandler: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable8
   \   00000002   0x6B40             LDR      R0,[R0, #+52]
   \   00000004   0x.... 0x....      B.W      HAL_DMA_IRQHandler
    369          }
    370          
    371          /**
    372            * @brief  Initializes SDRAM MSP.
    373            * @param  hsdram: SDRAM handle
    374            * @param  Params
    375            * @retval None
    376            */

   \                                 In section .text, align 2, keep-with-next
    377          __weak void BSP_SDRAM_MspInit(SDRAM_HandleTypeDef  *hsdram, void *Params)
    378          {  
   \                     BSP_SDRAM_MspInit: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0x4604             MOV      R4,R0
    379            static DMA_HandleTypeDef dma_handle;
    380            GPIO_InitTypeDef gpio_init_structure;
    381            
    382            /* Enable FMC clock */
    383            __HAL_RCC_FMC_CLK_ENABLE();
   \   00000004   0x....             LDR.N    R0,??DataTable8_3  ;; 0x40023830
   \   00000006   0xB087             SUB      SP,SP,#+28
    384            
    385            /* Enable chosen DMAx clock */
    386            __DMAx_CLK_ENABLE();
    387          
    388            /* Enable GPIOs clock */
    389            __HAL_RCC_GPIOC_CLK_ENABLE();
    390            __HAL_RCC_GPIOD_CLK_ENABLE();
    391            __HAL_RCC_GPIOE_CLK_ENABLE();
    392            __HAL_RCC_GPIOF_CLK_ENABLE();
    393            __HAL_RCC_GPIOG_CLK_ENABLE();
    394            __HAL_RCC_GPIOH_CLK_ENABLE();
    395            
    396            /* Common GPIO configuration */
    397            gpio_init_structure.Mode      = GPIO_MODE_AF_PP;
    398            gpio_init_structure.Pull      = GPIO_PULLUP;
    399            gpio_init_structure.Speed     = GPIO_SPEED_FAST;
    400            gpio_init_structure.Alternate = GPIO_AF12_FMC;
    401            
    402            /* GPIOC configuration */
    403            gpio_init_structure.Pin   = GPIO_PIN_3;
    404            HAL_GPIO_Init(GPIOC, &gpio_init_structure);
   \   00000008   0x....             LDR.N    R5,??DataTable8_4
   \   0000000A   0x6881             LDR      R1,[R0, #+8]
   \   0000000C   0xF041 0x0101      ORR      R1,R1,#0x1
   \   00000010   0x6081             STR      R1,[R0, #+8]
   \   00000012   0x6881             LDR      R1,[R0, #+8]
   \   00000014   0xF001 0x0101      AND      R1,R1,#0x1
   \   00000018   0x.... 0x....      BL       ?Subroutine4
   \                     ??CrossCallReturnLabel_6: (+1)
   \   0000001C   0xF441 0x0180      ORR      R1,R1,#0x400000
   \   00000020   0x6001             STR      R1,[R0, #+0]
   \   00000022   0x6801             LDR      R1,[R0, #+0]
   \   00000024   0xF401 0x0180      AND      R1,R1,#0x400000
   \   00000028   0x.... 0x....      BL       ?Subroutine4
   \                     ??CrossCallReturnLabel_7: (+1)
   \   0000002C   0xF041 0x0104      ORR      R1,R1,#0x4
   \   00000030   0x6001             STR      R1,[R0, #+0]
   \   00000032   0x6801             LDR      R1,[R0, #+0]
   \   00000034   0xF001 0x0104      AND      R1,R1,#0x4
   \   00000038   0x.... 0x....      BL       ?Subroutine4
   \                     ??CrossCallReturnLabel_8: (+1)
   \   0000003C   0xF041 0x0108      ORR      R1,R1,#0x8
   \   00000040   0x6001             STR      R1,[R0, #+0]
   \   00000042   0x6801             LDR      R1,[R0, #+0]
   \   00000044   0xF001 0x0108      AND      R1,R1,#0x8
   \   00000048   0x.... 0x....      BL       ?Subroutine4
   \                     ??CrossCallReturnLabel_9: (+1)
   \   0000004C   0xF041 0x0110      ORR      R1,R1,#0x10
   \   00000050   0x6001             STR      R1,[R0, #+0]
   \   00000052   0x6801             LDR      R1,[R0, #+0]
   \   00000054   0xF001 0x0110      AND      R1,R1,#0x10
   \   00000058   0x.... 0x....      BL       ?Subroutine4
   \                     ??CrossCallReturnLabel_10: (+1)
   \   0000005C   0xF041 0x0120      ORR      R1,R1,#0x20
   \   00000060   0x6001             STR      R1,[R0, #+0]
   \   00000062   0x6801             LDR      R1,[R0, #+0]
   \   00000064   0xF001 0x0120      AND      R1,R1,#0x20
   \   00000068   0x.... 0x....      BL       ?Subroutine4
   \                     ??CrossCallReturnLabel_11: (+1)
   \   0000006C   0xF041 0x0140      ORR      R1,R1,#0x40
   \   00000070   0x6001             STR      R1,[R0, #+0]
   \   00000072   0x6801             LDR      R1,[R0, #+0]
   \   00000074   0xF001 0x0140      AND      R1,R1,#0x40
   \   00000078   0x.... 0x....      BL       ?Subroutine4
   \                     ??CrossCallReturnLabel_12: (+1)
   \   0000007C   0xF041 0x0180      ORR      R1,R1,#0x80
   \   00000080   0x6001             STR      R1,[R0, #+0]
   \   00000082   0x6800             LDR      R0,[R0, #+0]
   \   00000084   0xA901             ADD      R1,SP,#+4
   \   00000086   0xF000 0x0080      AND      R0,R0,#0x80
   \   0000008A   0x9000             STR      R0,[SP, #+0]
   \   0000008C   0x9800             LDR      R0,[SP, #+0]
   \   0000008E   0x2002             MOVS     R0,#+2
   \   00000090   0x9002             STR      R0,[SP, #+8]
   \   00000092   0x2001             MOVS     R0,#+1
   \   00000094   0x9003             STR      R0,[SP, #+12]
   \   00000096   0x2002             MOVS     R0,#+2
   \   00000098   0x9004             STR      R0,[SP, #+16]
   \   0000009A   0x200C             MOVS     R0,#+12
   \   0000009C   0x9005             STR      R0,[SP, #+20]
   \   0000009E   0x2008             MOVS     R0,#+8
   \   000000A0   0x9001             STR      R0,[SP, #+4]
   \   000000A2   0x....             LDR.N    R0,??DataTable8_5  ;; 0x40020800
   \   000000A4   0x.... 0x....      BL       HAL_GPIO_Init
    405          
    406            /* GPIOD configuration */
    407            gpio_init_structure.Pin   = GPIO_PIN_0 | GPIO_PIN_1 | GPIO_PIN_3 | GPIO_PIN_8 | GPIO_PIN_9 |
    408                                        GPIO_PIN_10 | GPIO_PIN_14 | GPIO_PIN_15;
   \   000000A8   0xF24C 0x700B      MOVW     R0,#+50955
    409            HAL_GPIO_Init(GPIOD, &gpio_init_structure);
   \   000000AC   0xA901             ADD      R1,SP,#+4
   \   000000AE   0x9001             STR      R0,[SP, #+4]
   \   000000B0   0x....             LDR.N    R0,??DataTable8_6  ;; 0x40020c00
   \   000000B2   0x.... 0x....      BL       HAL_GPIO_Init
    410          
    411            /* GPIOE configuration */  
    412            gpio_init_structure.Pin   = GPIO_PIN_0 | GPIO_PIN_1 | GPIO_PIN_7| GPIO_PIN_8 | GPIO_PIN_9 |\
    413                                        GPIO_PIN_10 | GPIO_PIN_11 | GPIO_PIN_12 | GPIO_PIN_13 | GPIO_PIN_14 |\
    414                                        GPIO_PIN_15;
   \   000000B6   0xF64F 0x7083      MOVW     R0,#+65411
    415            HAL_GPIO_Init(GPIOE, &gpio_init_structure);
   \   000000BA   0xA901             ADD      R1,SP,#+4
   \   000000BC   0x9001             STR      R0,[SP, #+4]
   \   000000BE   0x....             LDR.N    R0,??DataTable8_7  ;; 0x40021000
   \   000000C0   0x.... 0x....      BL       HAL_GPIO_Init
    416            
    417            /* GPIOF configuration */  
    418            gpio_init_structure.Pin   = GPIO_PIN_0 | GPIO_PIN_1 | GPIO_PIN_2| GPIO_PIN_3 | GPIO_PIN_4 |\
    419                                        GPIO_PIN_5 | GPIO_PIN_11 | GPIO_PIN_12 | GPIO_PIN_13 | GPIO_PIN_14 |\
    420                                        GPIO_PIN_15;
   \   000000C4   0xF64F 0x003F      MOVW     R0,#+63551
    421            HAL_GPIO_Init(GPIOF, &gpio_init_structure);
   \   000000C8   0xA901             ADD      R1,SP,#+4
   \   000000CA   0x9001             STR      R0,[SP, #+4]
   \   000000CC   0x....             LDR.N    R0,??DataTable8_8  ;; 0x40021400
   \   000000CE   0x.... 0x....      BL       HAL_GPIO_Init
    422            
    423            /* GPIOG configuration */  
    424            gpio_init_structure.Pin   = GPIO_PIN_0 | GPIO_PIN_1 | GPIO_PIN_4| GPIO_PIN_5 | GPIO_PIN_8 |\
    425                                        GPIO_PIN_15;
   \   000000D2   0xF248 0x1033      MOVW     R0,#+33075
    426            HAL_GPIO_Init(GPIOG, &gpio_init_structure);
   \   000000D6   0xA901             ADD      R1,SP,#+4
   \   000000D8   0x9001             STR      R0,[SP, #+4]
   \   000000DA   0x....             LDR.N    R0,??DataTable8_9  ;; 0x40021800
   \   000000DC   0x.... 0x....      BL       HAL_GPIO_Init
    427          
    428            /* GPIOH configuration */  
    429            gpio_init_structure.Pin   = GPIO_PIN_3 | GPIO_PIN_5;
   \   000000E0   0x2028             MOVS     R0,#+40
    430            HAL_GPIO_Init(GPIOH, &gpio_init_structure); 
   \   000000E2   0xA901             ADD      R1,SP,#+4
   \   000000E4   0x9001             STR      R0,[SP, #+4]
   \   000000E6   0x....             LDR.N    R0,??DataTable8_10  ;; 0x40021c00
   \   000000E8   0x.... 0x....      BL       HAL_GPIO_Init
    431            
    432            /* Configure common DMA parameters */
    433            dma_handle.Init.Channel             = SDRAM_DMAx_CHANNEL;
   \   000000EC   0x2000             MOVS     R0,#+0
   \   000000EE   0x6068             STR      R0,[R5, #+4]
    434            dma_handle.Init.Direction           = DMA_MEMORY_TO_MEMORY;
   \   000000F0   0x2080             MOVS     R0,#+128
   \   000000F2   0x60A8             STR      R0,[R5, #+8]
    435            dma_handle.Init.PeriphInc           = DMA_PINC_ENABLE;
   \   000000F4   0xF44F 0x7000      MOV      R0,#+512
   \   000000F8   0x60E8             STR      R0,[R5, #+12]
    436            dma_handle.Init.MemInc              = DMA_MINC_ENABLE;
   \   000000FA   0xF44F 0x6080      MOV      R0,#+1024
   \   000000FE   0x6128             STR      R0,[R5, #+16]
    437            dma_handle.Init.PeriphDataAlignment = DMA_PDATAALIGN_WORD;
   \   00000100   0xF44F 0x5080      MOV      R0,#+4096
   \   00000104   0x6168             STR      R0,[R5, #+20]
    438            dma_handle.Init.MemDataAlignment    = DMA_MDATAALIGN_WORD;
   \   00000106   0xF44F 0x4080      MOV      R0,#+16384
   \   0000010A   0x61A8             STR      R0,[R5, #+24]
    439            dma_handle.Init.Mode                = DMA_NORMAL;
   \   0000010C   0x2000             MOVS     R0,#+0
   \   0000010E   0x61E8             STR      R0,[R5, #+28]
    440            dma_handle.Init.Priority            = DMA_PRIORITY_HIGH;
   \   00000110   0xF44F 0x3000      MOV      R0,#+131072
   \   00000114   0x6228             STR      R0,[R5, #+32]
    441            dma_handle.Init.FIFOMode            = DMA_FIFOMODE_DISABLE;         
   \   00000116   0x2000             MOVS     R0,#+0
   \   00000118   0x6268             STR      R0,[R5, #+36]
    442            dma_handle.Init.FIFOThreshold       = DMA_FIFO_THRESHOLD_FULL;
   \   0000011A   0x2003             MOVS     R0,#+3
   \   0000011C   0x62A8             STR      R0,[R5, #+40]
    443            dma_handle.Init.MemBurst            = DMA_MBURST_SINGLE;
   \   0000011E   0x2000             MOVS     R0,#+0
   \   00000120   0x62E8             STR      R0,[R5, #+44]
    444            dma_handle.Init.PeriphBurst         = DMA_PBURST_SINGLE; 
   \   00000122   0x6328             STR      R0,[R5, #+48]
    445            
    446            dma_handle.Instance = SDRAM_DMAx_STREAM;
   \   00000124   0x....             LDR.N    R0,??DataTable8_11  ;; 0x40026410
   \   00000126   0x6028             STR      R0,[R5, #+0]
    447            
    448             /* Associate the DMA handle */
    449            __HAL_LINKDMA(hsdram, hdma, dma_handle);
    450            
    451            /* Deinitialize the stream for new transfer */
    452            HAL_DMA_DeInit(&dma_handle);
   \   00000128   0x4628             MOV      R0,R5
   \   0000012A   0x6325             STR      R5,[R4, #+48]
   \   0000012C   0x63AC             STR      R4,[R5, #+56]
   \   0000012E   0x.... 0x....      BL       HAL_DMA_DeInit
    453            
    454            /* Configure the DMA stream */
    455            HAL_DMA_Init(&dma_handle); 
   \   00000132   0x4628             MOV      R0,R5
   \   00000134   0x.... 0x....      BL       HAL_DMA_Init
    456            
    457            /* NVIC configuration for DMA transfer complete interrupt */
    458            HAL_NVIC_SetPriority(SDRAM_DMAx_IRQn, 5, 0);
   \   00000138   0x2200             MOVS     R2,#+0
   \   0000013A   0x2105             MOVS     R1,#+5
   \   0000013C   0x2038             MOVS     R0,#+56
   \   0000013E   0x.... 0x....      BL       HAL_NVIC_SetPriority
    459            HAL_NVIC_EnableIRQ(SDRAM_DMAx_IRQn);
   \   00000142   0x2038             MOVS     R0,#+56
   \   00000144   0x.... 0x....      BL       HAL_NVIC_EnableIRQ
    460          }
   \   00000148   0xB007             ADD      SP,SP,#+28
   \   0000014A   0xBD30             POP      {R4,R5,PC}       ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine4: (+1)
   \   00000000   0x9100             STR      R1,[SP, #+0]
   \   00000002   0x9900             LDR      R1,[SP, #+0]
   \   00000004   0x6801             LDR      R1,[R0, #+0]
   \   00000006   0x4770             BX       LR

   \                                 In section .bss, align 4
   \                     ??dma_handle:
   \   00000000                      DS8 80
    461          
    462          /**
    463            * @brief  DeInitializes SDRAM MSP.
    464            * @param  hsdram: SDRAM handle
    465            * @param  Params
    466            * @retval None
    467            */

   \                                 In section .text, align 2, keep-with-next
    468          __weak void BSP_SDRAM_MspDeInit(SDRAM_HandleTypeDef  *hsdram, void *Params)
    469          {  
   \                     BSP_SDRAM_MspDeInit: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    470              static DMA_HandleTypeDef dma_handle;
    471            
    472              /* Disable NVIC configuration for DMA interrupt */
    473              HAL_NVIC_DisableIRQ(SDRAM_DMAx_IRQn);
   \   00000002   0x2038             MOVS     R0,#+56
   \   00000004   0x.... 0x....      BL       HAL_NVIC_DisableIRQ
    474          
    475              /* Deinitialize the stream for new transfer */
    476              dma_handle.Instance = SDRAM_DMAx_STREAM;
   \   00000008   0x....             LDR.N    R0,??DataTable8_12
   \   0000000A   0x....             LDR.N    R1,??DataTable8_11  ;; 0x40026410
   \   0000000C   0x6001             STR      R1,[R0, #+0]
    477              HAL_DMA_DeInit(&dma_handle);
   \   0000000E   0xE8BD 0x4002      POP      {R1,LR}
   \   00000012   0x.... 0x....      B.W      HAL_DMA_DeInit
    478          
    479              /* GPIO pins clock, FMC clock and DMA clock can be shut down in the applications
    480                 by surcharging this __weak function */ 
    481          }

   \                                 In section .bss, align 4
   \                     ??dma_handle_1:
   \   00000000                      DS8 80

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8:
   \   00000000   0x........         DC32     ??sdramstatus

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_1:
   \   00000000   0xA0000140         DC32     0xa0000140

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_2:
   \   00000000   0x........         DC32     ??sdramstatus+0x4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_3:
   \   00000000   0x40023830         DC32     0x40023830

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_4:
   \   00000000   0x........         DC32     ??dma_handle

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_5:
   \   00000000   0x40020800         DC32     0x40020800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_6:
   \   00000000   0x40020C00         DC32     0x40020c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_7:
   \   00000000   0x40021000         DC32     0x40021000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_8:
   \   00000000   0x40021400         DC32     0x40021400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_9:
   \   00000000   0x40021800         DC32     0x40021800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_10:
   \   00000000   0x40021C00         DC32     0x40021c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_11:
   \   00000000   0x40026410         DC32     0x40026410

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_12:
   \   00000000   0x........         DC32     ??dma_handle_1
    482          
    483          /**
    484            * @}
    485            */  
    486            
    487          /**
    488            * @}
    489            */ 
    490            
    491          /**
    492            * @}
    493            */ 
    494            
    495          /**
    496            * @}
    497            */ 
    498          
    499          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   BSP_SDRAM_DMA_IRQHandler
         0   -> HAL_DMA_IRQHandler
       8   BSP_SDRAM_DeInit
         8   -> BSP_SDRAM_MspDeInit
         8   -> HAL_SDRAM_DeInit
       8   BSP_SDRAM_Init
         8   -> BSP_SDRAM_Initialization_sequence
         8   -> BSP_SDRAM_MspInit
         8   -> HAL_SDRAM_Init
      24   BSP_SDRAM_Initialization_sequence
        24   -> HAL_Delay
         0   -> HAL_SDRAM_ProgramRefreshRate
        24   -> HAL_SDRAM_SendCommand
       8   BSP_SDRAM_MspDeInit
         0   -> HAL_DMA_DeInit
         8   -> HAL_NVIC_DisableIRQ
      40   BSP_SDRAM_MspInit
        40   -> HAL_DMA_DeInit
        40   -> HAL_DMA_Init
        40   -> HAL_GPIO_Init
        40   -> HAL_NVIC_EnableIRQ
        40   -> HAL_NVIC_SetPriority
       8   BSP_SDRAM_ReadData
         8   -> HAL_SDRAM_Read_32b
       8   BSP_SDRAM_ReadData_DMA
         8   -> HAL_SDRAM_Read_DMA
       8   BSP_SDRAM_Sendcmd
         8   -> HAL_SDRAM_SendCommand
       8   BSP_SDRAM_WriteData
         8   -> HAL_SDRAM_Write_32b
       8   BSP_SDRAM_WriteData_DMA
         8   -> HAL_SDRAM_Write_DMA


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable8
       4  ??DataTable8_1
       4  ??DataTable8_10
       4  ??DataTable8_11
       4  ??DataTable8_12
       4  ??DataTable8_2
       4  ??DataTable8_3
       4  ??DataTable8_4
       4  ??DataTable8_5
       4  ??DataTable8_6
       4  ??DataTable8_7
       4  ??DataTable8_8
       4  ??DataTable8_9
       6  ?Subroutine0
      16  ?Subroutine1
       8  ?Subroutine2
      12  ?Subroutine3
       8  ?Subroutine4
       8  BSP_SDRAM_DMA_IRQHandler
      30  BSP_SDRAM_DeInit
     110  BSP_SDRAM_Init
     116  BSP_SDRAM_Initialization_sequence
      22  BSP_SDRAM_MspDeInit
     332  BSP_SDRAM_MspInit
      16  BSP_SDRAM_ReadData
      14  BSP_SDRAM_ReadData_DMA
      16  BSP_SDRAM_Sendcmd
      16  BSP_SDRAM_WriteData
      16  BSP_SDRAM_WriteData_DMA
      80  dma_handle
      80  dma_handle
     100  sdramstatus
          sdramstatus
          sdramHandle
          Timing
          Command

 
 160 bytes in section .bss
 100 bytes in section .data
 798 bytes in section .text
 
 798 bytes of CODE memory
 260 bytes of DATA memory

Errors: none
Warnings: none
