###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.2.10312/W32 for ARM       12/Feb/2016  13:21:53
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_rcc.c
#    Command line =  
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_rcc.c
#        -D USE_HAL_DRIVER -D STM32F746xx -D USE_STM32746G_DISCO -D
#        USE_IOEXPANDER -D USE_USB_FS -lC
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
#        -lA
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
#        -o
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M7 -e --fpu=VFPv5_sp --dlib_config "D:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.3\arm\INC\c\DLib_Config_Full.h"
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\Inc\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\CMSIS\Device\ST\STM32F7xx\Include\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\STM32F7xx_HAL_Driver\Inc\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\STM32746G-Discovery\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\Components\Common\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Log\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Fonts\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\CPU\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_Device_Library\Core\Inc\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Core\Inc\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Class\MSC\Inc\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\drivers\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_Audio\Addons\PDM\
#        -On --use_c++_inline --require_prototypes -I "D:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.3\arm\CMSIS\Include\" -D
#        ARM_MATH_CM7
#    List file    =  
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List\stm32f7xx_hal_rcc.lst
#    Object file  =  
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj\stm32f7xx_hal_rcc.o
#
###############################################################################

H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_rcc.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f7xx_hal_rcc.c
      4            * @author  MCD Application Team
      5            * @version V1.0.1
      6            * @date    25-June-2015
      7            * @brief   RCC HAL module driver.
      8            *          This file provides firmware functions to manage the following 
      9            *          functionalities of the Reset and Clock Control (RCC) peripheral:
     10            *           + Initialization and de-initialization functions
     11            *           + Peripheral Control functions
     12            *       
     13            @verbatim                
     14            ==============================================================================
     15                                ##### RCC specific features #####
     16            ==============================================================================
     17              [..]  
     18                After reset the device is running from Internal High Speed oscillator 
     19                (HSI 16MHz) with Flash 0 wait state, Flash prefetch buffer, D-Cache 
     20                and I-Cache are disabled, and all peripherals are off except internal
     21                SRAM, Flash and JTAG.
     22                (+) There is no prescaler on High speed (AHB) and Low speed (APB) busses;
     23                    all peripherals mapped on these busses are running at HSI speed.
     24                (+) The clock for all peripherals is switched off, except the SRAM and FLASH.
     25                (+) All GPIOs are in input floating state, except the JTAG pins which
     26                    are assigned to be used for debug purpose.
     27              
     28              [..]          
     29                Once the device started from reset, the user application has to:        
     30                (+) Configure the clock source to be used to drive the System clock
     31                    (if the application needs higher frequency/performance)
     32                (+) Configure the System clock frequency and Flash settings  
     33                (+) Configure the AHB and APB busses prescalers
     34                (+) Enable the clock for the peripheral(s) to be used
     35                (+) Configure the clock source(s) for peripherals which clocks are not
     36                    derived from the System clock (I2S, RTC, ADC, USB OTG FS/SDIO/RNG)
     37          
     38                                ##### RCC Limitations #####
     39            ==============================================================================
     40              [..]  
     41                A delay between an RCC peripheral clock enable and the effective peripheral 
     42                enabling should be taken into account in order to manage the peripheral read/write 
     43                from/to registers.
     44                (+) This delay depends on the peripheral mapping.
     45                (+) If peripheral is mapped on AHB: the delay is 2 AHB clock cycle 
     46                    after the clock enable bit is set on the hardware register
     47                (+) If peripheral is mapped on APB: the delay is 2 APB clock cycle 
     48                    after the clock enable bit is set on the hardware register
     49          
     50              [..]  
     51                Implemented Workaround:
     52                (+) For AHB & APB peripherals, a dummy read to the peripheral register has been
     53                    inserted in each __HAL_RCC_PPP_CLK_ENABLE() macro.
     54          
     55            @endverbatim
     56            ******************************************************************************
     57            * @attention
     58            *
     59            * <h2><center>&copy; COPYRIGHT(c) 2015 STMicroelectronics</center></h2>
     60            *
     61            * Redistribution and use in source and binary forms, with or without modification,
     62            * are permitted provided that the following conditions are met:
     63            *   1. Redistributions of source code must retain the above copyright notice,
     64            *      this list of conditions and the following disclaimer.
     65            *   2. Redistributions in binary form must reproduce the above copyright notice,
     66            *      this list of conditions and the following disclaimer in the documentation
     67            *      and/or other materials provided with the distribution.
     68            *   3. Neither the name of STMicroelectronics nor the names of its contributors
     69            *      may be used to endorse or promote products derived from this software
     70            *      without specific prior written permission.
     71            *
     72            * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
     73            * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     74            * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     75            * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
     76            * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
     77            * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
     78            * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
     79            * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
     80            * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
     81            * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     82            *
     83            ******************************************************************************
     84            */ 
     85          
     86          /* Includes ------------------------------------------------------------------*/
     87          #include "stm32f7xx_hal.h"
     88          
     89          /** @addtogroup STM32F7xx_HAL_Driver
     90            * @{
     91            */
     92          
     93          /** @defgroup RCC RCC
     94            * @brief RCC HAL module driver
     95            * @{
     96            */
     97          
     98          #ifdef HAL_RCC_MODULE_ENABLED
     99          
    100          /* Private typedef -----------------------------------------------------------*/
    101          /* Private define ------------------------------------------------------------*/
    102          /* Private macro -------------------------------------------------------------*/
    103          /** @defgroup RCC_Private_Macros RCC Private Macros
    104            * @{
    105            */
    106          
    107          #define MCO1_CLK_ENABLE()   __HAL_RCC_GPIOA_CLK_ENABLE()
    108          #define MCO1_GPIO_PORT        GPIOA
    109          #define MCO1_PIN              GPIO_PIN_8
    110          
    111          #define MCO2_CLK_ENABLE()   __HAL_RCC_GPIOC_CLK_ENABLE()
    112          #define MCO2_GPIO_PORT         GPIOC
    113          #define MCO2_PIN               GPIO_PIN_9
    114          
    115          /**
    116            * @}
    117            */
    118          /* Private variables ---------------------------------------------------------*/
    119          /** @defgroup RCC_Private_Variables RCC Private Variables
    120            * @{
    121            */

   \                                 In section .rodata, align 4
    122          const uint8_t APBAHBPrescTable[16] = {0, 0, 0, 0, 1, 2, 3, 4, 1, 2, 3, 4, 6, 7, 8, 9};
   \                     APBAHBPrescTable:
   \   00000000   0x00 0x00          DC8 0, 0, 0, 0, 1, 2, 3, 4, 1, 2, 3, 4, 6, 7, 8, 9
   \              0x00 0x00    
   \              0x01 0x02    
   \              0x03 0x04    
   \              0x01 0x02    
   \              0x03 0x04    
   \              0x06 0x07    
   \              0x08 0x09    
    123          
    124          /**
    125            * @}
    126            */
    127          
    128          /* Private function prototypes -----------------------------------------------*/
    129          /* Exported functions ---------------------------------------------------------*/
    130          
    131          /** @defgroup RCC_Exported_Functions RCC Exported Functions
    132            * @{
    133            */
    134          
    135          /** @defgroup RCC_Exported_Functions_Group1 Initialization and de-initialization functions 
    136            *  @brief    Initialization and Configuration functions 
    137            *
    138            @verbatim    
    139            ===============================================================================
    140          ##### Initialization and de-initialization functions #####
    141            ===============================================================================
    142              [..]
    143                This section provides functions allowing to configure the internal/external oscillators
    144                (HSE, HSI, LSE, LSI, PLL, CSS and MCO) and the System buses clocks (SYSCLK, AHB, APB1 
    145                and APB2).
    146          
    147              [..] Internal/external clock and PLL configuration
    148                (#) HSI (high-speed internal), 16 MHz factory-trimmed RC used directly or through
    149                    the PLL as System clock source.
    150          
    151                (#) LSI (low-speed internal), 32 KHz low consumption RC used as IWDG and/or RTC
    152                    clock source.
    153          
    154                (#) HSE (high-speed external), 4 to 26 MHz crystal oscillator used directly or
    155                    through the PLL as System clock source. Can be used also as RTC clock source.
    156          
    157                (#) LSE (low-speed external), 32 KHz oscillator used as RTC clock source.   
    158          
    159                (#) PLL (clocked by HSI or HSE), featuring two different output clocks:
    160                  (++) The first output is used to generate the high speed system clock (up to 216 MHz)
    161                  (++) The second output is used to generate the clock for the USB OTG FS (48 MHz),
    162                       the random analog generator (<=48 MHz) and the SDIO (<= 48 MHz).
    163          
    164                (#) CSS (Clock security system), once enable using the function HAL_RCC_EnableCSS()
    165                    and if a HSE clock failure occurs(HSE used directly or through PLL as System 
    166                    clock source), the System clock is automatically switched to HSI and an interrupt
    167                    is generated if enabled. The interrupt is linked to the Cortex-M7 NMI 
    168                    (Non-Maskable Interrupt) exception vector.   
    169          
    170                (#) MCO1 (microcontroller clock output), used to output HSI, LSE, HSE or PLL
    171                    clock (through a configurable prescaler) on PA8 pin.
    172          
    173                (#) MCO2 (microcontroller clock output), used to output HSE, PLL, SYSCLK or PLLI2S
    174                    clock (through a configurable prescaler) on PC9 pin.
    175          
    176              [..] System, AHB and APB busses clocks configuration  
    177                (#) Several clock sources can be used to drive the System clock (SYSCLK): HSI,
    178                    HSE and PLL.
    179                    The AHB clock (HCLK) is derived from System clock through configurable 
    180                    prescaler and used to clock the CPU, memory and peripherals mapped 
    181                    on AHB bus (DMA, GPIO...). APB1 (PCLK1) and APB2 (PCLK2) clocks are derived 
    182                    from AHB clock through configurable prescalers and used to clock 
    183                    the peripherals mapped on these busses. You can use 
    184                    "HAL_RCC_GetSysClockFreq()" function to retrieve the frequencies of these clocks.  
    185          
    186                -@- All the peripheral clocks are derived from the System clock (SYSCLK) except:
    187                    (+@) I2S: the I2S clock can be derived either from a specific PLL (PLLI2S) or
    188                        from an external clock mapped on the I2S_CKIN pin. 
    189                        You have to use __HAL_RCC_PLLI2S_CONFIG() macro to configure this clock.
    190                    (+@)  SAI: the SAI clock can be derived either from a specific PLL (PLLI2S) or (PLLSAI) or
    191                        from an external clock mapped on the I2S_CKIN pin. 
    192                         You have to use __HAL_RCC_PLLI2S_CONFIG() macro to configure this clock. 
    193                    (+@) RTC: the RTC clock can be derived either from the LSI, LSE or HSE clock
    194                        divided by 2 to 31. You have to use __HAL_RCC_RTC_CONFIG() and __HAL_RCC_RTC_ENABLE()
    195                        macros to configure this clock. 
    196                    (+@) USB OTG FS, SDIO and RTC: USB OTG FS require a frequency equal to 48 MHz
    197                        to work correctly, while the SDIO require a frequency equal or lower than
    198                        to 48. This clock is derived of the main PLL through PLLQ divider.
    199                    (+@) IWDG clock which is always the LSI clock.
    200          @endverbatim
    201            * @{
    202            */
    203          
    204          /**
    205            * @brief  Resets the RCC clock configuration to the default reset state.
    206            * @note   The default reset state of the clock configuration is given below:
    207            *            - HSI ON and used as system clock source
    208            *            - HSE, PLL and PLLI2S OFF
    209            *            - AHB, APB1 and APB2 prescaler set to 1.
    210            *            - CSS, MCO1 and MCO2 OFF
    211            *            - All interrupts disabled
    212            * @note   This function doesn't modify the configuration of the
    213            *            - Peripheral clocks  
    214            *            - LSI, LSE and RTC clocks 
    215            * @retval None
    216            */

   \                                 In section .text, align 2, keep-with-next
    217          void HAL_RCC_DeInit(void)
    218          {
    219            /* Set HSION bit */
    220            SET_BIT(RCC->CR, RCC_CR_HSION | RCC_CR_HSITRIM_4); 
   \                     HAL_RCC_DeInit: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable12  ;; 0x40023800
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0xF050 0x0081      ORRS     R0,R0,#0x81
   \   0000000A   0x.... 0x....      LDR.W    R1,??DataTable12  ;; 0x40023800
   \   0000000E   0x6008             STR      R0,[R1, #+0]
    221            
    222            /* Reset CFGR register */
    223            CLEAR_REG(RCC->CFGR);
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0x.... 0x....      LDR.W    R1,??DataTable12_1  ;; 0x40023808
   \   00000016   0x6008             STR      R0,[R1, #+0]
    224            
    225            /* Reset HSEON, CSSON, PLLON, PLLI2S */
    226            CLEAR_BIT(RCC->CR, RCC_CR_HSEON | RCC_CR_CSSON | RCC_CR_PLLON| RCC_CR_PLLI2SON); 
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable12  ;; 0x40023800
   \   0000001C   0x6800             LDR      R0,[R0, #+0]
   \   0000001E   0x.... 0x....      LDR.W    R1,??DataTable12_2  ;; 0xfaf6ffff
   \   00000022   0x4008             ANDS     R0,R1,R0
   \   00000024   0x.... 0x....      LDR.W    R1,??DataTable12  ;; 0x40023800
   \   00000028   0x6008             STR      R0,[R1, #+0]
    227            
    228            /* Reset PLLCFGR register */
    229            CLEAR_REG(RCC->PLLCFGR);
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0x.... 0x....      LDR.W    R1,??DataTable12_3  ;; 0x40023804
   \   00000030   0x6008             STR      R0,[R1, #+0]
    230            SET_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM_4 | RCC_PLLCFGR_PLLN_6 | RCC_PLLCFGR_PLLN_7 | RCC_PLLCFGR_PLLQ_2); 
   \   00000032   0x.... 0x....      LDR.W    R0,??DataTable12_3  ;; 0x40023804
   \   00000036   0x6800             LDR      R0,[R0, #+0]
   \   00000038   0x.... 0x....      LDR.W    R1,??DataTable12_4  ;; 0x4003010
   \   0000003C   0x4308             ORRS     R0,R1,R0
   \   0000003E   0x.... 0x....      LDR.W    R1,??DataTable12_3  ;; 0x40023804
   \   00000042   0x6008             STR      R0,[R1, #+0]
    231            
    232            /* Reset PLLI2SCFGR register */
    233            CLEAR_REG(RCC->PLLI2SCFGR);
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0x.... 0x....      LDR.W    R1,??DataTable12_5  ;; 0x40023884
   \   0000004A   0x6008             STR      R0,[R1, #+0]
    234            SET_BIT(RCC->PLLI2SCFGR,  RCC_PLLI2SCFGR_PLLI2SN_6 | RCC_PLLI2SCFGR_PLLI2SN_7 | RCC_PLLI2SCFGR_PLLI2SR_1);
   \   0000004C   0x.... 0x....      LDR.W    R0,??DataTable12_5  ;; 0x40023884
   \   00000050   0x6800             LDR      R0,[R0, #+0]
   \   00000052   0xF040 0x5000      ORR      R0,R0,#0x20000000
   \   00000056   0xF450 0x5040      ORRS     R0,R0,#0x3000
   \   0000005A   0x.... 0x....      LDR.W    R1,??DataTable12_5  ;; 0x40023884
   \   0000005E   0x6008             STR      R0,[R1, #+0]
    235            
    236            /* Reset HSEBYP bit */
    237            CLEAR_BIT(RCC->CR, RCC_CR_HSEBYP);
   \   00000060   0x.... 0x....      LDR.W    R0,??DataTable12  ;; 0x40023800
   \   00000064   0x6800             LDR      R0,[R0, #+0]
   \   00000066   0xF430 0x2080      BICS     R0,R0,#0x40000
   \   0000006A   0x.... 0x....      LDR.W    R1,??DataTable12  ;; 0x40023800
   \   0000006E   0x6008             STR      R0,[R1, #+0]
    238            
    239            /* Disable all interrupts */
    240            CLEAR_REG(RCC->CIR);
   \   00000070   0x2000             MOVS     R0,#+0
   \   00000072   0x.... 0x....      LDR.W    R1,??DataTable12_6  ;; 0x4002380c
   \   00000076   0x6008             STR      R0,[R1, #+0]
    241          }
   \   00000078   0x4770             BX       LR               ;; return
    242          
    243          /**
    244            * @brief  Initializes the RCC Oscillators according to the specified parameters in the
    245            *         RCC_OscInitTypeDef.
    246            * @param  RCC_OscInitStruct: pointer to an RCC_OscInitTypeDef structure that
    247            *         contains the configuration information for the RCC Oscillators.
    248            * @note   The PLL is not disabled when used as system clock.
    249            * @retval HAL status
    250            */

   \                                 In section .text, align 2, keep-with-next
    251          HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
    252          {
   \                     HAL_RCC_OscConfig: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0004             MOVS     R4,R0
    253            uint32_t tickstart = 0;  
   \   00000006   0x2500             MOVS     R5,#+0
    254           
    255            /* Check the parameters */
    256            assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));
    257            
    258            /*------------------------------- HSE Configuration ------------------------*/ 
    259            if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
   \   00000008   0x7820             LDRB     R0,[R4, #+0]
   \   0000000A   0x07C0             LSLS     R0,R0,#+31
   \   0000000C   0xF140 0x80AF      BPL.W    ??HAL_RCC_OscConfig_0
    260            {
    261              /* Check the parameters */
    262              assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));
    263              /* When the HSE is used as system clock or clock source for PLL, It can not be disabled */
    264              if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSE) 
    265                 || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)))
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable12_1  ;; 0x40023808
   \   00000014   0x6800             LDR      R0,[R0, #+0]
   \   00000016   0xF010 0x000C      ANDS     R0,R0,#0xC
   \   0000001A   0x2804             CMP      R0,#+4
   \   0000001C   0xD00B             BEQ.N    ??HAL_RCC_OscConfig_1
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable12_1  ;; 0x40023808
   \   00000022   0x6800             LDR      R0,[R0, #+0]
   \   00000024   0xF010 0x000C      ANDS     R0,R0,#0xC
   \   00000028   0x2808             CMP      R0,#+8
   \   0000002A   0xD110             BNE.N    ??HAL_RCC_OscConfig_2
   \   0000002C   0x.... 0x....      LDR.W    R0,??DataTable12_3  ;; 0x40023804
   \   00000030   0x6800             LDR      R0,[R0, #+0]
   \   00000032   0x0240             LSLS     R0,R0,#+9
   \   00000034   0xD50B             BPL.N    ??HAL_RCC_OscConfig_2
    266              {
    267          	  if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
   \                     ??HAL_RCC_OscConfig_1: (+1)
   \   00000036   0x.... 0x....      LDR.W    R0,??DataTable12  ;; 0x40023800
   \   0000003A   0x6800             LDR      R0,[R0, #+0]
   \   0000003C   0x0380             LSLS     R0,R0,#+14
   \   0000003E   0xF140 0x8096      BPL.W    ??HAL_RCC_OscConfig_0
   \   00000042   0x6860             LDR      R0,[R4, #+4]
   \   00000044   0x2800             CMP      R0,#+0
   \   00000046   0xF040 0x8092      BNE.W    ??HAL_RCC_OscConfig_0
    268                {
    269                  return HAL_ERROR;
   \   0000004A   0x2001             MOVS     R0,#+1
   \   0000004C   0xE263             B.N      ??HAL_RCC_OscConfig_3
    270                }
    271              }
    272              else
    273              {
    274                /* Reset HSEON and HSEBYP bits before configuring the HSE --------------*/
    275                __HAL_RCC_HSE_CONFIG(RCC_HSE_OFF);
   \                     ??HAL_RCC_OscConfig_2: (+1)
   \   0000004E   0x.... 0x....      LDR.W    R0,??DataTable12  ;; 0x40023800
   \   00000052   0x6800             LDR      R0,[R0, #+0]
   \   00000054   0xF430 0x3080      BICS     R0,R0,#0x10000
   \   00000058   0x.... 0x....      LDR.W    R1,??DataTable12  ;; 0x40023800
   \   0000005C   0x6008             STR      R0,[R1, #+0]
   \   0000005E   0x.... 0x....      LDR.W    R0,??DataTable12  ;; 0x40023800
   \   00000062   0x6800             LDR      R0,[R0, #+0]
   \   00000064   0xF430 0x2080      BICS     R0,R0,#0x40000
   \   00000068   0x.... 0x....      LDR.W    R1,??DataTable12  ;; 0x40023800
   \   0000006C   0x6008             STR      R0,[R1, #+0]
   \   0000006E   0x.... 0x....      LDR.W    R0,??DataTable12  ;; 0x40023800
   \   00000072   0x6800             LDR      R0,[R0, #+0]
   \   00000074   0xF430 0x3080      BICS     R0,R0,#0x10000
   \   00000078   0x.... 0x....      LDR.W    R1,??DataTable12  ;; 0x40023800
   \   0000007C   0x6008             STR      R0,[R1, #+0]
    276                
    277                /* Get Start Tick*/
    278                tickstart = HAL_GetTick();
   \   0000007E   0x.... 0x....      BL       HAL_GetTick
   \   00000082   0x0005             MOVS     R5,R0
    279                
    280                /* Wait till HSE is disabled */  
    281                while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
   \                     ??HAL_RCC_OscConfig_4: (+1)
   \   00000084   0x.... 0x....      LDR.W    R0,??DataTable12  ;; 0x40023800
   \   00000088   0x6800             LDR      R0,[R0, #+0]
   \   0000008A   0x0380             LSLS     R0,R0,#+14
   \   0000008C   0xD508             BPL.N    ??HAL_RCC_OscConfig_5
    282                {
    283                  if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
   \   0000008E   0x.... 0x....      BL       HAL_GetTick
   \   00000092   0x1B40             SUBS     R0,R0,R5
   \   00000094   0xF241 0x3189      MOVW     R1,#+5001
   \   00000098   0x4288             CMP      R0,R1
   \   0000009A   0xD3F3             BCC.N    ??HAL_RCC_OscConfig_4
    284                  {
    285                    return HAL_TIMEOUT;
   \   0000009C   0x2003             MOVS     R0,#+3
   \   0000009E   0xE23A             B.N      ??HAL_RCC_OscConfig_3
    286                  }
    287                }
    288                
    289                /* Set the new HSE configuration ---------------------------------------*/
    290                __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
   \                     ??HAL_RCC_OscConfig_5: (+1)
   \   000000A0   0x.... 0x....      LDR.W    R0,??DataTable12  ;; 0x40023800
   \   000000A4   0x6800             LDR      R0,[R0, #+0]
   \   000000A6   0xF430 0x3080      BICS     R0,R0,#0x10000
   \   000000AA   0x.... 0x....      LDR.W    R1,??DataTable12  ;; 0x40023800
   \   000000AE   0x6008             STR      R0,[R1, #+0]
   \   000000B0   0x6860             LDR      R0,[R4, #+4]
   \   000000B2   0xF5B0 0x3F80      CMP      R0,#+65536
   \   000000B6   0xD110             BNE.N    ??HAL_RCC_OscConfig_6
   \   000000B8   0x.... 0x....      LDR.W    R0,??DataTable12  ;; 0x40023800
   \   000000BC   0x6800             LDR      R0,[R0, #+0]
   \   000000BE   0xF430 0x2080      BICS     R0,R0,#0x40000
   \   000000C2   0x.... 0x....      LDR.W    R1,??DataTable12  ;; 0x40023800
   \   000000C6   0x6008             STR      R0,[R1, #+0]
   \   000000C8   0x.... 0x....      LDR.W    R0,??DataTable12  ;; 0x40023800
   \   000000CC   0x6800             LDR      R0,[R0, #+0]
   \   000000CE   0xF450 0x3080      ORRS     R0,R0,#0x10000
   \   000000D2   0x.... 0x....      LDR.W    R1,??DataTable12  ;; 0x40023800
   \   000000D6   0x6008             STR      R0,[R1, #+0]
   \   000000D8   0xE024             B.N      ??HAL_RCC_OscConfig_7
   \                     ??HAL_RCC_OscConfig_6: (+1)
   \   000000DA   0x6860             LDR      R0,[R4, #+4]
   \   000000DC   0xF5B0 0x2FA0      CMP      R0,#+327680
   \   000000E0   0xD110             BNE.N    ??HAL_RCC_OscConfig_8
   \   000000E2   0x.... 0x....      LDR.W    R0,??DataTable12  ;; 0x40023800
   \   000000E6   0x6800             LDR      R0,[R0, #+0]
   \   000000E8   0xF450 0x2080      ORRS     R0,R0,#0x40000
   \   000000EC   0x.... 0x....      LDR.W    R1,??DataTable12  ;; 0x40023800
   \   000000F0   0x6008             STR      R0,[R1, #+0]
   \   000000F2   0x.... 0x....      LDR.W    R0,??DataTable12  ;; 0x40023800
   \   000000F6   0x6800             LDR      R0,[R0, #+0]
   \   000000F8   0xF450 0x3080      ORRS     R0,R0,#0x10000
   \   000000FC   0x.... 0x....      LDR.W    R1,??DataTable12  ;; 0x40023800
   \   00000100   0x6008             STR      R0,[R1, #+0]
   \   00000102   0xE00F             B.N      ??HAL_RCC_OscConfig_7
   \                     ??HAL_RCC_OscConfig_8: (+1)
   \   00000104   0x.... 0x....      LDR.W    R0,??DataTable12  ;; 0x40023800
   \   00000108   0x6800             LDR      R0,[R0, #+0]
   \   0000010A   0xF430 0x2080      BICS     R0,R0,#0x40000
   \   0000010E   0x.... 0x....      LDR.W    R1,??DataTable12  ;; 0x40023800
   \   00000112   0x6008             STR      R0,[R1, #+0]
   \   00000114   0x.... 0x....      LDR.W    R0,??DataTable12  ;; 0x40023800
   \   00000118   0x6800             LDR      R0,[R0, #+0]
   \   0000011A   0xF430 0x3080      BICS     R0,R0,#0x10000
   \   0000011E   0x.... 0x....      LDR.W    R1,??DataTable12  ;; 0x40023800
   \   00000122   0x6008             STR      R0,[R1, #+0]
    291                
    292                /* Check the HSE State */
    293                if(RCC_OscInitStruct->HSEState != RCC_HSE_OFF)
   \                     ??HAL_RCC_OscConfig_7: (+1)
   \   00000124   0x6860             LDR      R0,[R4, #+4]
   \   00000126   0x2800             CMP      R0,#+0
   \   00000128   0xD010             BEQ.N    ??HAL_RCC_OscConfig_9
    294                {
    295                  /* Get Start Tick*/
    296                  tickstart = HAL_GetTick();
   \   0000012A   0x.... 0x....      BL       HAL_GetTick
   \   0000012E   0x0005             MOVS     R5,R0
    297                  
    298                  /* Wait till HSE is ready */  
    299                  while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
   \                     ??HAL_RCC_OscConfig_10: (+1)
   \   00000130   0x.... 0x....      LDR.W    R0,??DataTable12  ;; 0x40023800
   \   00000134   0x6800             LDR      R0,[R0, #+0]
   \   00000136   0x0380             LSLS     R0,R0,#+14
   \   00000138   0xD419             BMI.N    ??HAL_RCC_OscConfig_0
    300                  {
    301                    if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
   \   0000013A   0x.... 0x....      BL       HAL_GetTick
   \   0000013E   0x1B40             SUBS     R0,R0,R5
   \   00000140   0xF241 0x3189      MOVW     R1,#+5001
   \   00000144   0x4288             CMP      R0,R1
   \   00000146   0xD3F3             BCC.N    ??HAL_RCC_OscConfig_10
    302                    {
    303                      return HAL_TIMEOUT;
   \   00000148   0x2003             MOVS     R0,#+3
   \   0000014A   0xE1E4             B.N      ??HAL_RCC_OscConfig_3
    304                    }
    305                  }
    306                }
    307                else
    308                {
    309                  /* Get Start Tick*/
    310                  tickstart = HAL_GetTick();
   \                     ??HAL_RCC_OscConfig_9: (+1)
   \   0000014C   0x.... 0x....      BL       HAL_GetTick
   \   00000150   0x0005             MOVS     R5,R0
    311                  
    312                  /* Wait till HSE is bypassed or disabled */
    313                  while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
   \                     ??HAL_RCC_OscConfig_11: (+1)
   \   00000152   0x.... 0x....      LDR.W    R0,??DataTable12  ;; 0x40023800
   \   00000156   0x6800             LDR      R0,[R0, #+0]
   \   00000158   0x0380             LSLS     R0,R0,#+14
   \   0000015A   0xD508             BPL.N    ??HAL_RCC_OscConfig_0
    314                  {
    315                     if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
   \   0000015C   0x.... 0x....      BL       HAL_GetTick
   \   00000160   0x1B40             SUBS     R0,R0,R5
   \   00000162   0xF241 0x3189      MOVW     R1,#+5001
   \   00000166   0x4288             CMP      R0,R1
   \   00000168   0xD3F3             BCC.N    ??HAL_RCC_OscConfig_11
    316                    {
    317                      return HAL_TIMEOUT;
   \   0000016A   0x2003             MOVS     R0,#+3
   \   0000016C   0xE1D3             B.N      ??HAL_RCC_OscConfig_3
    318                    }
    319                  }
    320                }
    321              }
    322            }
    323            /*----------------------------- HSI Configuration --------------------------*/ 
    324            if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
   \                     ??HAL_RCC_OscConfig_0: (+1)
   \   0000016E   0x7820             LDRB     R0,[R4, #+0]
   \   00000170   0x0780             LSLS     R0,R0,#+30
   \   00000172   0xD56E             BPL.N    ??HAL_RCC_OscConfig_12
    325            {
    326              /* Check the parameters */
    327              assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
    328              assert_param(IS_RCC_CALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));
    329              
    330              /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */ 
    331              if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSI) 
    332                 || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))
   \   00000174   0x.... 0x....      LDR.W    R0,??DataTable12_1  ;; 0x40023808
   \   00000178   0x6800             LDR      R0,[R0, #+0]
   \   0000017A   0xF010 0x0F0C      TST      R0,#0xC
   \   0000017E   0xD00B             BEQ.N    ??HAL_RCC_OscConfig_13
   \   00000180   0x.... 0x....      LDR.W    R0,??DataTable12_1  ;; 0x40023808
   \   00000184   0x6800             LDR      R0,[R0, #+0]
   \   00000186   0xF010 0x000C      ANDS     R0,R0,#0xC
   \   0000018A   0x2808             CMP      R0,#+8
   \   0000018C   0xD11F             BNE.N    ??HAL_RCC_OscConfig_14
   \   0000018E   0x.... 0x....      LDR.W    R0,??DataTable12_3  ;; 0x40023804
   \   00000192   0x6800             LDR      R0,[R0, #+0]
   \   00000194   0x0240             LSLS     R0,R0,#+9
   \   00000196   0xD41A             BMI.N    ??HAL_RCC_OscConfig_14
    333              {
    334                /* When HSI is used as system clock it will not disabled */
    335                if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
   \                     ??HAL_RCC_OscConfig_13: (+1)
   \   00000198   0x.... 0x....      LDR.W    R0,??DataTable12  ;; 0x40023800
   \   0000019C   0x6800             LDR      R0,[R0, #+0]
   \   0000019E   0x0780             LSLS     R0,R0,#+30
   \   000001A0   0xD504             BPL.N    ??HAL_RCC_OscConfig_15
   \   000001A2   0x68E0             LDR      R0,[R4, #+12]
   \   000001A4   0x2801             CMP      R0,#+1
   \   000001A6   0xD001             BEQ.N    ??HAL_RCC_OscConfig_15
    336                {
    337                  return HAL_ERROR;
   \   000001A8   0x2001             MOVS     R0,#+1
   \   000001AA   0xE1B4             B.N      ??HAL_RCC_OscConfig_3
    338                }
    339                /* Otherwise, just the calibration is allowed */
    340                else
    341                {
    342                  /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
    343                  __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
   \                     ??HAL_RCC_OscConfig_15: (+1)
   \   000001AC   0x.... 0x....      LDR.W    R0,??DataTable12  ;; 0x40023800
   \   000001B0   0x6800             LDR      R0,[R0, #+0]
   \   000001B2   0xF05F 0x51F8      MOVS     R1,#+520093696
   \   000001B6   0xFAB1 0xF181      CLZ      R1,R1
   \   000001BA   0xF030 0x00F8      BICS     R0,R0,#0xF8
   \   000001BE   0x6922             LDR      R2,[R4, #+16]
   \   000001C0   0xFA12 0xF101      LSLS     R1,R2,R1
   \   000001C4   0x4308             ORRS     R0,R1,R0
   \   000001C6   0x.... 0x....      LDR.W    R1,??DataTable12  ;; 0x40023800
   \   000001CA   0x6008             STR      R0,[R1, #+0]
   \   000001CC   0xE041             B.N      ??HAL_RCC_OscConfig_12
    344                }
    345              }
    346              else
    347              {
    348                /* Check the HSI State */
    349                if((RCC_OscInitStruct->HSIState)!= RCC_HSI_OFF)
   \                     ??HAL_RCC_OscConfig_14: (+1)
   \   000001CE   0x68E0             LDR      R0,[R4, #+12]
   \   000001D0   0x2800             CMP      R0,#+0
   \   000001D2   0xD027             BEQ.N    ??HAL_RCC_OscConfig_16
    350                {
    351                  /* Enable the Internal High Speed oscillator (HSI). */
    352                  __HAL_RCC_HSI_ENABLE();
   \   000001D4   0x.... 0x....      LDR.W    R0,??DataTable12  ;; 0x40023800
   \   000001D8   0x6800             LDR      R0,[R0, #+0]
   \   000001DA   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   000001DE   0x.... 0x....      LDR.W    R1,??DataTable12  ;; 0x40023800
   \   000001E2   0x6008             STR      R0,[R1, #+0]
    353          
    354                  /* Get Start Tick*/
    355                  tickstart = HAL_GetTick();
   \   000001E4   0x.... 0x....      BL       HAL_GetTick
   \   000001E8   0x0005             MOVS     R5,R0
    356          
    357                  /* Wait till HSI is ready */  
    358                  while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
   \                     ??HAL_RCC_OscConfig_17: (+1)
   \   000001EA   0x.... 0x....      LDR.W    R0,??DataTable12  ;; 0x40023800
   \   000001EE   0x6800             LDR      R0,[R0, #+0]
   \   000001F0   0x0780             LSLS     R0,R0,#+30
   \   000001F2   0xD406             BMI.N    ??HAL_RCC_OscConfig_18
    359                  {
    360                    if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
   \   000001F4   0x.... 0x....      BL       HAL_GetTick
   \   000001F8   0x1B40             SUBS     R0,R0,R5
   \   000001FA   0x2865             CMP      R0,#+101
   \   000001FC   0xD3F5             BCC.N    ??HAL_RCC_OscConfig_17
    361                    {
    362                      return HAL_TIMEOUT;
   \   000001FE   0x2003             MOVS     R0,#+3
   \   00000200   0xE189             B.N      ??HAL_RCC_OscConfig_3
    363                    }
    364                  }
    365                          
    366                  /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
    367                  __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
   \                     ??HAL_RCC_OscConfig_18: (+1)
   \   00000202   0x.... 0x....      LDR.W    R0,??DataTable12  ;; 0x40023800
   \   00000206   0x6800             LDR      R0,[R0, #+0]
   \   00000208   0xF05F 0x51F8      MOVS     R1,#+520093696
   \   0000020C   0xFAB1 0xF181      CLZ      R1,R1
   \   00000210   0xF030 0x00F8      BICS     R0,R0,#0xF8
   \   00000214   0x6922             LDR      R2,[R4, #+16]
   \   00000216   0xFA12 0xF101      LSLS     R1,R2,R1
   \   0000021A   0x4308             ORRS     R0,R1,R0
   \   0000021C   0x.... 0x....      LDR.W    R1,??DataTable12  ;; 0x40023800
   \   00000220   0x6008             STR      R0,[R1, #+0]
   \   00000222   0xE016             B.N      ??HAL_RCC_OscConfig_12
    368                }
    369                else
    370                {
    371                  /* Disable the Internal High Speed oscillator (HSI). */
    372                  __HAL_RCC_HSI_DISABLE();
   \                     ??HAL_RCC_OscConfig_16: (+1)
   \   00000224   0x.... 0x....      LDR.W    R0,??DataTable12  ;; 0x40023800
   \   00000228   0x6800             LDR      R0,[R0, #+0]
   \   0000022A   0x0840             LSRS     R0,R0,#+1
   \   0000022C   0x0040             LSLS     R0,R0,#+1
   \   0000022E   0x.... 0x....      LDR.W    R1,??DataTable12  ;; 0x40023800
   \   00000232   0x6008             STR      R0,[R1, #+0]
    373          
    374                  /* Get Start Tick*/
    375                  tickstart = HAL_GetTick();
   \   00000234   0x.... 0x....      BL       HAL_GetTick
   \   00000238   0x0005             MOVS     R5,R0
    376                
    377                  /* Wait till HSI is ready */  
    378                  while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
   \                     ??HAL_RCC_OscConfig_19: (+1)
   \   0000023A   0x.... 0x....      LDR.W    R0,??DataTable12  ;; 0x40023800
   \   0000023E   0x6800             LDR      R0,[R0, #+0]
   \   00000240   0x0780             LSLS     R0,R0,#+30
   \   00000242   0xD506             BPL.N    ??HAL_RCC_OscConfig_12
    379                  {
    380                    if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
   \   00000244   0x.... 0x....      BL       HAL_GetTick
   \   00000248   0x1B40             SUBS     R0,R0,R5
   \   0000024A   0x2865             CMP      R0,#+101
   \   0000024C   0xD3F5             BCC.N    ??HAL_RCC_OscConfig_19
    381                    {
    382                      return HAL_TIMEOUT;
   \   0000024E   0x2003             MOVS     R0,#+3
   \   00000250   0xE161             B.N      ??HAL_RCC_OscConfig_3
    383                    } 
    384                  } 
    385                }
    386              }
    387            }
    388            /*------------------------------ LSI Configuration -------------------------*/
    389            if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
   \                     ??HAL_RCC_OscConfig_12: (+1)
   \   00000252   0x7820             LDRB     R0,[R4, #+0]
   \   00000254   0x0700             LSLS     R0,R0,#+28
   \   00000256   0xD530             BPL.N    ??HAL_RCC_OscConfig_20
    390            {
    391              /* Check the parameters */
    392              assert_param(IS_RCC_LSI(RCC_OscInitStruct->LSIState));
    393          
    394              /* Check the LSI State */
    395              if((RCC_OscInitStruct->LSIState)!= RCC_LSI_OFF)
   \   00000258   0x6960             LDR      R0,[R4, #+20]
   \   0000025A   0x2800             CMP      R0,#+0
   \   0000025C   0xD016             BEQ.N    ??HAL_RCC_OscConfig_21
    396              {
    397                /* Enable the Internal Low Speed oscillator (LSI). */
    398                __HAL_RCC_LSI_ENABLE();
   \   0000025E   0x.... 0x....      LDR.W    R0,??DataTable12_7  ;; 0x40023874
   \   00000262   0x6800             LDR      R0,[R0, #+0]
   \   00000264   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000268   0x.... 0x....      LDR.W    R1,??DataTable12_7  ;; 0x40023874
   \   0000026C   0x6008             STR      R0,[R1, #+0]
    399                
    400                /* Get Start Tick*/
    401                tickstart = HAL_GetTick();
   \   0000026E   0x.... 0x....      BL       HAL_GetTick
   \   00000272   0x0005             MOVS     R5,R0
    402                
    403                /* Wait till LSI is ready */
    404                while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
   \                     ??HAL_RCC_OscConfig_22: (+1)
   \   00000274   0x.... 0x....      LDR.W    R0,??DataTable12_7  ;; 0x40023874
   \   00000278   0x6800             LDR      R0,[R0, #+0]
   \   0000027A   0x0780             LSLS     R0,R0,#+30
   \   0000027C   0xD41D             BMI.N    ??HAL_RCC_OscConfig_20
    405                {
    406                  if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
   \   0000027E   0x.... 0x....      BL       HAL_GetTick
   \   00000282   0x1B40             SUBS     R0,R0,R5
   \   00000284   0x2865             CMP      R0,#+101
   \   00000286   0xD3F5             BCC.N    ??HAL_RCC_OscConfig_22
    407                  {
    408                    return HAL_TIMEOUT;
   \   00000288   0x2003             MOVS     R0,#+3
   \   0000028A   0xE144             B.N      ??HAL_RCC_OscConfig_3
    409                  }
    410                }
    411              }
    412              else
    413              {
    414                /* Disable the Internal Low Speed oscillator (LSI). */
    415                __HAL_RCC_LSI_DISABLE();
   \                     ??HAL_RCC_OscConfig_21: (+1)
   \   0000028C   0x.... 0x....      LDR.W    R0,??DataTable12_7  ;; 0x40023874
   \   00000290   0x6800             LDR      R0,[R0, #+0]
   \   00000292   0x0840             LSRS     R0,R0,#+1
   \   00000294   0x0040             LSLS     R0,R0,#+1
   \   00000296   0x.... 0x....      LDR.W    R1,??DataTable12_7  ;; 0x40023874
   \   0000029A   0x6008             STR      R0,[R1, #+0]
    416                
    417                /* Get Start Tick*/
    418                tickstart = HAL_GetTick();
   \   0000029C   0x.... 0x....      BL       HAL_GetTick
   \   000002A0   0x0005             MOVS     R5,R0
    419                
    420                /* Wait till LSI is ready */  
    421                while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
   \                     ??HAL_RCC_OscConfig_23: (+1)
   \   000002A2   0x.... 0x....      LDR.W    R0,??DataTable12_7  ;; 0x40023874
   \   000002A6   0x6800             LDR      R0,[R0, #+0]
   \   000002A8   0x0780             LSLS     R0,R0,#+30
   \   000002AA   0xD506             BPL.N    ??HAL_RCC_OscConfig_20
    422                {
    423                  if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
   \   000002AC   0x.... 0x....      BL       HAL_GetTick
   \   000002B0   0x1B40             SUBS     R0,R0,R5
   \   000002B2   0x2865             CMP      R0,#+101
   \   000002B4   0xD3F5             BCC.N    ??HAL_RCC_OscConfig_23
    424                  {
    425                    return HAL_TIMEOUT;
   \   000002B6   0x2003             MOVS     R0,#+3
   \   000002B8   0xE12D             B.N      ??HAL_RCC_OscConfig_3
    426                  }
    427                }
    428              }
    429            }
    430            /*------------------------------ LSE Configuration -------------------------*/ 
    431            if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
   \                     ??HAL_RCC_OscConfig_20: (+1)
   \   000002BA   0x7820             LDRB     R0,[R4, #+0]
   \   000002BC   0x0740             LSLS     R0,R0,#+29
   \   000002BE   0xF140 0x80B4      BPL.W    ??HAL_RCC_OscConfig_24
    432            {
    433              /* Check the parameters */
    434              assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));
    435              
    436              /* Enable Power Clock*/
    437              __HAL_RCC_PWR_CLK_ENABLE();
   \   000002C2   0x.... 0x....      LDR.W    R0,??DataTable12_8  ;; 0x40023840
   \   000002C6   0x6800             LDR      R0,[R0, #+0]
   \   000002C8   0xF050 0x5080      ORRS     R0,R0,#0x10000000
   \   000002CC   0x.... 0x....      LDR.W    R1,??DataTable12_8  ;; 0x40023840
   \   000002D0   0x6008             STR      R0,[R1, #+0]
   \   000002D2   0x.... 0x....      LDR.W    R0,??DataTable12_8  ;; 0x40023840
   \   000002D6   0x6800             LDR      R0,[R0, #+0]
   \   000002D8   0xF010 0x5080      ANDS     R0,R0,#0x10000000
   \   000002DC   0x9000             STR      R0,[SP, #+0]
   \   000002DE   0x9800             LDR      R0,[SP, #+0]
    438              
    439              /* Enable write access to Backup domain */
    440              PWR->CR1 |= PWR_CR1_DBP;
   \   000002E0   0x.... 0x....      LDR.W    R0,??DataTable12_9  ;; 0x40007000
   \   000002E4   0x6800             LDR      R0,[R0, #+0]
   \   000002E6   0xF450 0x7080      ORRS     R0,R0,#0x100
   \   000002EA   0x.... 0x....      LDR.W    R1,??DataTable12_9  ;; 0x40007000
   \   000002EE   0x6008             STR      R0,[R1, #+0]
    441              
    442              /* Wait for Backup domain Write protection disable */
    443              tickstart = HAL_GetTick();
   \   000002F0   0x.... 0x....      BL       HAL_GetTick
   \   000002F4   0x0005             MOVS     R5,R0
    444              
    445              while((PWR->CR1 & PWR_CR1_DBP) == RESET)
   \                     ??HAL_RCC_OscConfig_25: (+1)
   \   000002F6   0x.... 0x....      LDR.W    R0,??DataTable12_9  ;; 0x40007000
   \   000002FA   0x6800             LDR      R0,[R0, #+0]
   \   000002FC   0x05C0             LSLS     R0,R0,#+23
   \   000002FE   0xD406             BMI.N    ??HAL_RCC_OscConfig_26
    446              {
    447                if((HAL_GetTick() - tickstart ) > RCC_DBP_TIMEOUT_VALUE)
   \   00000300   0x.... 0x....      BL       HAL_GetTick
   \   00000304   0x1B40             SUBS     R0,R0,R5
   \   00000306   0x2865             CMP      R0,#+101
   \   00000308   0xD3F5             BCC.N    ??HAL_RCC_OscConfig_25
    448                {
    449                  return HAL_TIMEOUT;
   \   0000030A   0x2003             MOVS     R0,#+3
   \   0000030C   0xE103             B.N      ??HAL_RCC_OscConfig_3
    450                }      
    451              }
    452              
    453              /* Reset LSEON and LSEBYP bits before configuring the LSE ----------------*/
    454              __HAL_RCC_LSE_CONFIG(RCC_LSE_OFF);
   \                     ??HAL_RCC_OscConfig_26: (+1)
   \   0000030E   0x.... 0x....      LDR.W    R0,??DataTable12_10  ;; 0x40023870
   \   00000312   0x6800             LDR      R0,[R0, #+0]
   \   00000314   0x0840             LSRS     R0,R0,#+1
   \   00000316   0x0040             LSLS     R0,R0,#+1
   \   00000318   0x.... 0x....      LDR.W    R1,??DataTable12_10  ;; 0x40023870
   \   0000031C   0x6008             STR      R0,[R1, #+0]
   \   0000031E   0x.... 0x....      LDR.W    R0,??DataTable12_10  ;; 0x40023870
   \   00000322   0x6800             LDR      R0,[R0, #+0]
   \   00000324   0xF030 0x0004      BICS     R0,R0,#0x4
   \   00000328   0x.... 0x....      LDR.W    R1,??DataTable12_10  ;; 0x40023870
   \   0000032C   0x6008             STR      R0,[R1, #+0]
   \   0000032E   0x.... 0x....      LDR.W    R0,??DataTable12_10  ;; 0x40023870
   \   00000332   0x6800             LDR      R0,[R0, #+0]
   \   00000334   0x0840             LSRS     R0,R0,#+1
   \   00000336   0x0040             LSLS     R0,R0,#+1
   \   00000338   0x.... 0x....      LDR.W    R1,??DataTable12_10  ;; 0x40023870
   \   0000033C   0x6008             STR      R0,[R1, #+0]
    455              
    456              /* Get Start Tick*/
    457              tickstart = HAL_GetTick();
   \   0000033E   0x.... 0x....      BL       HAL_GetTick
   \   00000342   0x0005             MOVS     R5,R0
    458              
    459              /* Wait till LSE is ready */  
    460              while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
   \                     ??HAL_RCC_OscConfig_27: (+1)
   \   00000344   0x.... 0x....      LDR.W    R0,??DataTable12_10  ;; 0x40023870
   \   00000348   0x6800             LDR      R0,[R0, #+0]
   \   0000034A   0x0780             LSLS     R0,R0,#+30
   \   0000034C   0xD508             BPL.N    ??HAL_RCC_OscConfig_28
    461              {
    462                if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
   \   0000034E   0x.... 0x....      BL       HAL_GetTick
   \   00000352   0x1B40             SUBS     R0,R0,R5
   \   00000354   0xF241 0x3189      MOVW     R1,#+5001
   \   00000358   0x4288             CMP      R0,R1
   \   0000035A   0xD3F3             BCC.N    ??HAL_RCC_OscConfig_27
    463                {
    464                  return HAL_TIMEOUT;
   \   0000035C   0x2003             MOVS     R0,#+3
   \   0000035E   0xE0DA             B.N      ??HAL_RCC_OscConfig_3
    465                }    
    466              } 
    467              
    468              /* Set the new LSE configuration -----------------------------------------*/
    469              __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
   \                     ??HAL_RCC_OscConfig_28: (+1)
   \   00000360   0x.... 0x....      LDR.W    R0,??DataTable12_10  ;; 0x40023870
   \   00000364   0x6800             LDR      R0,[R0, #+0]
   \   00000366   0x0840             LSRS     R0,R0,#+1
   \   00000368   0x0040             LSLS     R0,R0,#+1
   \   0000036A   0x.... 0x....      LDR.W    R1,??DataTable12_10  ;; 0x40023870
   \   0000036E   0x6008             STR      R0,[R1, #+0]
   \   00000370   0x68A0             LDR      R0,[R4, #+8]
   \   00000372   0x2801             CMP      R0,#+1
   \   00000374   0xD110             BNE.N    ??HAL_RCC_OscConfig_29
   \   00000376   0x.... 0x....      LDR.W    R0,??DataTable12_10  ;; 0x40023870
   \   0000037A   0x6800             LDR      R0,[R0, #+0]
   \   0000037C   0xF030 0x0004      BICS     R0,R0,#0x4
   \   00000380   0x.... 0x....      LDR.W    R1,??DataTable12_10  ;; 0x40023870
   \   00000384   0x6008             STR      R0,[R1, #+0]
   \   00000386   0x.... 0x....      LDR.W    R0,??DataTable12_10  ;; 0x40023870
   \   0000038A   0x6800             LDR      R0,[R0, #+0]
   \   0000038C   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000390   0x.... 0x....      LDR.W    R1,??DataTable12_10  ;; 0x40023870
   \   00000394   0x6008             STR      R0,[R1, #+0]
   \   00000396   0xE023             B.N      ??HAL_RCC_OscConfig_30
   \                     ??HAL_RCC_OscConfig_29: (+1)
   \   00000398   0x68A0             LDR      R0,[R4, #+8]
   \   0000039A   0x2805             CMP      R0,#+5
   \   0000039C   0xD110             BNE.N    ??HAL_RCC_OscConfig_31
   \   0000039E   0x.... 0x....      LDR.W    R0,??DataTable12_10  ;; 0x40023870
   \   000003A2   0x6800             LDR      R0,[R0, #+0]
   \   000003A4   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   000003A8   0x.... 0x....      LDR.W    R1,??DataTable12_10  ;; 0x40023870
   \   000003AC   0x6008             STR      R0,[R1, #+0]
   \   000003AE   0x.... 0x....      LDR.W    R0,??DataTable12_10  ;; 0x40023870
   \   000003B2   0x6800             LDR      R0,[R0, #+0]
   \   000003B4   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   000003B8   0x.... 0x....      LDR.W    R1,??DataTable12_10  ;; 0x40023870
   \   000003BC   0x6008             STR      R0,[R1, #+0]
   \   000003BE   0xE00F             B.N      ??HAL_RCC_OscConfig_30
   \                     ??HAL_RCC_OscConfig_31: (+1)
   \   000003C0   0x.... 0x....      LDR.W    R0,??DataTable12_10  ;; 0x40023870
   \   000003C4   0x6800             LDR      R0,[R0, #+0]
   \   000003C6   0xF030 0x0004      BICS     R0,R0,#0x4
   \   000003CA   0x.... 0x....      LDR.W    R1,??DataTable12_10  ;; 0x40023870
   \   000003CE   0x6008             STR      R0,[R1, #+0]
   \   000003D0   0x.... 0x....      LDR.W    R0,??DataTable12_10  ;; 0x40023870
   \   000003D4   0x6800             LDR      R0,[R0, #+0]
   \   000003D6   0x0840             LSRS     R0,R0,#+1
   \   000003D8   0x0040             LSLS     R0,R0,#+1
   \   000003DA   0x.... 0x....      LDR.W    R1,??DataTable12_10  ;; 0x40023870
   \   000003DE   0x6008             STR      R0,[R1, #+0]
    470              /* Check the LSE State */
    471              if((RCC_OscInitStruct->LSEState) != RCC_LSE_OFF)
   \                     ??HAL_RCC_OscConfig_30: (+1)
   \   000003E0   0x68A0             LDR      R0,[R4, #+8]
   \   000003E2   0x2800             CMP      R0,#+0
   \   000003E4   0xD010             BEQ.N    ??HAL_RCC_OscConfig_32
    472              {
    473                /* Get Start Tick*/
    474                tickstart = HAL_GetTick();
   \   000003E6   0x.... 0x....      BL       HAL_GetTick
   \   000003EA   0x0005             MOVS     R5,R0
    475                
    476                /* Wait till LSE is ready */  
    477                while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
   \                     ??HAL_RCC_OscConfig_33: (+1)
   \   000003EC   0x.... 0x....      LDR.W    R0,??DataTable12_10  ;; 0x40023870
   \   000003F0   0x6800             LDR      R0,[R0, #+0]
   \   000003F2   0x0780             LSLS     R0,R0,#+30
   \   000003F4   0xD419             BMI.N    ??HAL_RCC_OscConfig_24
    478                {
    479                  if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
   \   000003F6   0x.... 0x....      BL       HAL_GetTick
   \   000003FA   0x1B40             SUBS     R0,R0,R5
   \   000003FC   0xF241 0x3189      MOVW     R1,#+5001
   \   00000400   0x4288             CMP      R0,R1
   \   00000402   0xD3F3             BCC.N    ??HAL_RCC_OscConfig_33
    480                  {
    481                    return HAL_TIMEOUT;
   \   00000404   0x2003             MOVS     R0,#+3
   \   00000406   0xE086             B.N      ??HAL_RCC_OscConfig_3
    482                  }       
    483                }
    484              }
    485              else
    486              {
    487                /* Get Start Tick*/
    488                tickstart = HAL_GetTick();
   \                     ??HAL_RCC_OscConfig_32: (+1)
   \   00000408   0x.... 0x....      BL       HAL_GetTick
   \   0000040C   0x0005             MOVS     R5,R0
    489                
    490                /* Wait till LSE is ready */  
    491                while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
   \                     ??HAL_RCC_OscConfig_34: (+1)
   \   0000040E   0x.... 0x....      LDR.W    R0,??DataTable12_10  ;; 0x40023870
   \   00000412   0x6800             LDR      R0,[R0, #+0]
   \   00000414   0x0780             LSLS     R0,R0,#+30
   \   00000416   0xD508             BPL.N    ??HAL_RCC_OscConfig_24
    492                {
    493                  if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
   \   00000418   0x.... 0x....      BL       HAL_GetTick
   \   0000041C   0x1B40             SUBS     R0,R0,R5
   \   0000041E   0xF241 0x3189      MOVW     R1,#+5001
   \   00000422   0x4288             CMP      R0,R1
   \   00000424   0xD3F3             BCC.N    ??HAL_RCC_OscConfig_34
    494                  {
    495                    return HAL_TIMEOUT;
   \   00000426   0x2003             MOVS     R0,#+3
   \   00000428   0xE075             B.N      ??HAL_RCC_OscConfig_3
    496                  }       
    497                }
    498              }
    499            }
    500            /*-------------------------------- PLL Configuration -----------------------*/
    501            /* Check the parameters */
    502            assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));
    503            if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
   \                     ??HAL_RCC_OscConfig_24: (+1)
   \   0000042A   0x69A0             LDR      R0,[R4, #+24]
   \   0000042C   0x2800             CMP      R0,#+0
   \   0000042E   0xD071             BEQ.N    ??HAL_RCC_OscConfig_35
    504            {
    505              /* Check if the PLL is used as system clock or not */
    506              if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
   \   00000430   0x.... 0x....      LDR.W    R0,??DataTable12_1  ;; 0x40023808
   \   00000434   0x6800             LDR      R0,[R0, #+0]
   \   00000436   0xF010 0x000C      ANDS     R0,R0,#0xC
   \   0000043A   0x2808             CMP      R0,#+8
   \   0000043C   0xD068             BEQ.N    ??HAL_RCC_OscConfig_36
    507              { 
    508                if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
   \   0000043E   0x69A0             LDR      R0,[R4, #+24]
   \   00000440   0x2802             CMP      R0,#+2
   \   00000442   0xD14E             BNE.N    ??HAL_RCC_OscConfig_37
    509                {
    510                  /* Check the parameters */
    511                  assert_param(IS_RCC_PLLSOURCE(RCC_OscInitStruct->PLL.PLLSource));
    512                  assert_param(IS_RCC_PLLM_VALUE(RCC_OscInitStruct->PLL.PLLM));
    513                  assert_param(IS_RCC_PLLN_VALUE(RCC_OscInitStruct->PLL.PLLN));
    514                  assert_param(IS_RCC_PLLP_VALUE(RCC_OscInitStruct->PLL.PLLP));
    515                  assert_param(IS_RCC_PLLQ_VALUE(RCC_OscInitStruct->PLL.PLLQ));
    516                  
    517                  /* Disable the main PLL. */
    518                  __HAL_RCC_PLL_DISABLE();
   \   00000444   0x.... 0x....      LDR.W    R0,??DataTable12  ;; 0x40023800
   \   00000448   0x6800             LDR      R0,[R0, #+0]
   \   0000044A   0xF030 0x7080      BICS     R0,R0,#0x1000000
   \   0000044E   0x.... 0x....      LDR.W    R1,??DataTable12  ;; 0x40023800
   \   00000452   0x6008             STR      R0,[R1, #+0]
    519                  
    520                  /* Get Start Tick*/
    521                  tickstart = HAL_GetTick();
   \   00000454   0x.... 0x....      BL       HAL_GetTick
   \   00000458   0x0005             MOVS     R5,R0
    522                  
    523                  /* Wait till PLL is ready */  
    524                  while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
   \                     ??HAL_RCC_OscConfig_38: (+1)
   \   0000045A   0x.... 0x....      LDR.W    R0,??DataTable12  ;; 0x40023800
   \   0000045E   0x6800             LDR      R0,[R0, #+0]
   \   00000460   0x0180             LSLS     R0,R0,#+6
   \   00000462   0xD506             BPL.N    ??HAL_RCC_OscConfig_39
    525                  {
    526                    if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
   \   00000464   0x.... 0x....      BL       HAL_GetTick
   \   00000468   0x1B40             SUBS     R0,R0,R5
   \   0000046A   0x2865             CMP      R0,#+101
   \   0000046C   0xD3F5             BCC.N    ??HAL_RCC_OscConfig_38
    527                    {
    528                      return HAL_TIMEOUT;
   \   0000046E   0x2003             MOVS     R0,#+3
   \   00000470   0xE051             B.N      ??HAL_RCC_OscConfig_3
    529                    }
    530                  }
    531                  
    532                  /* Configure the main PLL clock source, multiplication and division factors. */
    533                  __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
    534                                       RCC_OscInitStruct->PLL.PLLM,
    535                                       RCC_OscInitStruct->PLL.PLLN,
    536                                       RCC_OscInitStruct->PLL.PLLP,
    537                                       RCC_OscInitStruct->PLL.PLLQ);
   \                     ??HAL_RCC_OscConfig_39: (+1)
   \   00000472   0x.... 0x....      LDR.W    R0,??DataTable12_11  ;; 0x3fe0000
   \   00000476   0xFAB0 0xF180      CLZ      R1,R0
   \   0000047A   0xF44F 0x4040      MOV      R0,#+49152
   \   0000047E   0xFAB0 0xF280      CLZ      R2,R0
   \   00000482   0x20F0             MOVS     R0,#+240
   \   00000484   0xFAB0 0xF080      CLZ      R0,R0
   \   00000488   0x6A23             LDR      R3,[R4, #+32]
   \   0000048A   0x6A66             LDR      R6,[R4, #+36]
   \   0000048C   0xFA16 0xF101      LSLS     R1,R6,R1
   \   00000490   0x4319             ORRS     R1,R1,R3
   \   00000492   0x6AA3             LDR      R3,[R4, #+40]
   \   00000494   0x085B             LSRS     R3,R3,#+1
   \   00000496   0x1E5B             SUBS     R3,R3,#+1
   \   00000498   0xFA13 0xF202      LSLS     R2,R3,R2
   \   0000049C   0x4311             ORRS     R1,R2,R1
   \   0000049E   0x69E2             LDR      R2,[R4, #+28]
   \   000004A0   0x4311             ORRS     R1,R2,R1
   \   000004A2   0x6AE2             LDR      R2,[R4, #+44]
   \   000004A4   0xFA12 0xF000      LSLS     R0,R2,R0
   \   000004A8   0x4308             ORRS     R0,R0,R1
   \   000004AA   0xF050 0x5000      ORRS     R0,R0,#0x20000000
   \   000004AE   0x.... 0x....      LDR.W    R1,??DataTable12_3  ;; 0x40023804
   \   000004B2   0x6008             STR      R0,[R1, #+0]
    538                  /* Enable the main PLL. */
    539                  __HAL_RCC_PLL_ENABLE();
   \   000004B4   0x.... 0x....      LDR.W    R0,??DataTable12  ;; 0x40023800
   \   000004B8   0x6800             LDR      R0,[R0, #+0]
   \   000004BA   0xF050 0x7080      ORRS     R0,R0,#0x1000000
   \   000004BE   0x.... 0x....      LDR.W    R1,??DataTable12  ;; 0x40023800
   \   000004C2   0x6008             STR      R0,[R1, #+0]
    540          
    541                  /* Get Start Tick*/
    542                  tickstart = HAL_GetTick();
   \   000004C4   0x.... 0x....      BL       HAL_GetTick
   \   000004C8   0x0005             MOVS     R5,R0
    543                  
    544                  /* Wait till PLL is ready */  
    545                  while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
   \                     ??HAL_RCC_OscConfig_40: (+1)
   \   000004CA   0x.... 0x....      LDR.W    R0,??DataTable12  ;; 0x40023800
   \   000004CE   0x6800             LDR      R0,[R0, #+0]
   \   000004D0   0x0180             LSLS     R0,R0,#+6
   \   000004D2   0xD41F             BMI.N    ??HAL_RCC_OscConfig_35
    546                  {
    547                    if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
   \   000004D4   0x.... 0x....      BL       HAL_GetTick
   \   000004D8   0x1B40             SUBS     R0,R0,R5
   \   000004DA   0x2865             CMP      R0,#+101
   \   000004DC   0xD3F5             BCC.N    ??HAL_RCC_OscConfig_40
    548                    {
    549                      return HAL_TIMEOUT;
   \   000004DE   0x2003             MOVS     R0,#+3
   \   000004E0   0xE019             B.N      ??HAL_RCC_OscConfig_3
    550                    } 
    551                  }
    552                }
    553                else
    554                {
    555                  /* Disable the main PLL. */
    556                  __HAL_RCC_PLL_DISABLE();
   \                     ??HAL_RCC_OscConfig_37: (+1)
   \   000004E2   0x.... 0x....      LDR.W    R0,??DataTable12  ;; 0x40023800
   \   000004E6   0x6800             LDR      R0,[R0, #+0]
   \   000004E8   0xF030 0x7080      BICS     R0,R0,#0x1000000
   \   000004EC   0x.... 0x....      LDR.W    R1,??DataTable12  ;; 0x40023800
   \   000004F0   0x6008             STR      R0,[R1, #+0]
    557           
    558                  /* Get Start Tick*/
    559                  tickstart = HAL_GetTick();
   \   000004F2   0x.... 0x....      BL       HAL_GetTick
   \   000004F6   0x0005             MOVS     R5,R0
    560                  
    561                  /* Wait till PLL is ready */  
    562                  while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
   \                     ??HAL_RCC_OscConfig_41: (+1)
   \   000004F8   0x.... 0x....      LDR.W    R0,??DataTable12  ;; 0x40023800
   \   000004FC   0x6800             LDR      R0,[R0, #+0]
   \   000004FE   0x0180             LSLS     R0,R0,#+6
   \   00000500   0xD508             BPL.N    ??HAL_RCC_OscConfig_35
    563                  {
    564                    if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
   \   00000502   0x.... 0x....      BL       HAL_GetTick
   \   00000506   0x1B40             SUBS     R0,R0,R5
   \   00000508   0x2865             CMP      R0,#+101
   \   0000050A   0xD3F5             BCC.N    ??HAL_RCC_OscConfig_41
    565                    {
    566                      return HAL_TIMEOUT;
   \   0000050C   0x2003             MOVS     R0,#+3
   \   0000050E   0xE002             B.N      ??HAL_RCC_OscConfig_3
    567                    }
    568                  }
    569                }
    570              }
    571              else
    572              {
    573                return HAL_ERROR;
   \                     ??HAL_RCC_OscConfig_36: (+1)
   \   00000510   0x2001             MOVS     R0,#+1
   \   00000512   0xE000             B.N      ??HAL_RCC_OscConfig_3
    574              }
    575            }
    576            return HAL_OK;
   \                     ??HAL_RCC_OscConfig_35: (+1)
   \   00000514   0x2000             MOVS     R0,#+0
   \                     ??HAL_RCC_OscConfig_3: (+1)
   \   00000516   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
    577          }
    578           
    579          /**
    580            * @brief  Initializes the CPU, AHB and APB busses clocks according to the specified 
    581            *         parameters in the RCC_ClkInitStruct.
    582            * @param  RCC_ClkInitStruct: pointer to an RCC_OscInitTypeDef structure that
    583            *         contains the configuration information for the RCC peripheral.
    584            * @param  FLatency: FLASH Latency, this parameter depend on device selected
    585            * 
    586            * @note   The SystemCoreClock CMSIS variable is used to store System Clock Frequency 
    587            *         and updated by HAL_RCC_GetHCLKFreq() function called within this function
    588            *
    589            * @note   The HSI is used (enabled by hardware) as system clock source after
    590            *         startup from Reset, wake-up from STOP and STANDBY mode, or in case
    591            *         of failure of the HSE used directly or indirectly as system clock
    592            *         (if the Clock Security System CSS is enabled).
    593            *           
    594            * @note   A switch from one clock source to another occurs only if the target
    595            *         clock source is ready (clock stable after startup delay or PLL locked). 
    596            *         If a clock source which is not yet ready is selected, the switch will
    597            *         occur when the clock source will be ready. 
    598            *         You can use HAL_RCC_GetClockConfig() function to know which clock is
    599            *         currently used as system clock source.
    600            * @note   Depending on the device voltage range, the software has to set correctly
    601            *         HPRE[3:0] bits to ensure that HCLK not exceed the maximum allowed frequency
    602            *         (for more details refer to section above "Initialization/de-initialization functions")
    603            * @retval None
    604            */

   \                                 In section .text, align 2, keep-with-next
    605          HAL_StatusTypeDef HAL_RCC_ClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t FLatency)
    606          {
   \                     HAL_RCC_ClockConfig: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    607            uint32_t tickstart = 0;
   \   00000006   0x2600             MOVS     R6,#+0
    608           
    609            /* Check the parameters */
    610            assert_param(IS_RCC_CLOCKTYPE(RCC_ClkInitStruct->ClockType));
    611            assert_param(IS_FLASH_LATENCY(FLatency));
    612           
    613            /* To correctly read data from FLASH memory, the number of wait states (LATENCY) 
    614               must be correctly programmed according to the frequency of the CPU clock 
    615               (HCLK) and the supply voltage of the device. */
    616            
    617            /* Increasing the CPU frequency */
    618            if(FLatency > (FLASH->ACR & FLASH_ACR_LATENCY))
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable12_12  ;; 0x40023c00
   \   0000000C   0x6800             LDR      R0,[R0, #+0]
   \   0000000E   0xF010 0x000F      ANDS     R0,R0,#0xF
   \   00000012   0x42A8             CMP      R0,R5
   \   00000014   0xF080 0x8083      BCS.W    ??HAL_RCC_ClockConfig_0
    619            {    
    620              /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    621              __HAL_FLASH_SET_LATENCY(FLatency);
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable12_12  ;; 0x40023c00
   \   0000001C   0x6800             LDR      R0,[R0, #+0]
   \   0000001E   0x0900             LSRS     R0,R0,#+4
   \   00000020   0x0100             LSLS     R0,R0,#+4
   \   00000022   0x4328             ORRS     R0,R5,R0
   \   00000024   0x.... 0x....      LDR.W    R1,??DataTable12_12  ;; 0x40023c00
   \   00000028   0x6008             STR      R0,[R1, #+0]
    622              
    623              /* Check that the new number of wait states is taken into account to access the Flash
    624              memory by reading the FLASH_ACR register */
    625              if((FLASH->ACR & FLASH_ACR_LATENCY) != FLatency)
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable12_12  ;; 0x40023c00
   \   0000002E   0x6800             LDR      R0,[R0, #+0]
   \   00000030   0xF010 0x000F      ANDS     R0,R0,#0xF
   \   00000034   0x42A8             CMP      R0,R5
   \   00000036   0xD001             BEQ.N    ??HAL_RCC_ClockConfig_1
    626              {
    627                return HAL_ERROR;
   \   00000038   0x2001             MOVS     R0,#+1
   \   0000003A   0xE10B             B.N      ??HAL_RCC_ClockConfig_2
    628              }
    629          
    630              /*-------------------------- HCLK Configuration --------------------------*/
    631              if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
   \                     ??HAL_RCC_ClockConfig_1: (+1)
   \   0000003C   0x7820             LDRB     R0,[R4, #+0]
   \   0000003E   0x0780             LSLS     R0,R0,#+30
   \   00000040   0xD509             BPL.N    ??HAL_RCC_ClockConfig_3
    632              {
    633                assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
    634                MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
   \   00000042   0x.... 0x....      LDR.W    R0,??DataTable12_1  ;; 0x40023808
   \   00000046   0x6800             LDR      R0,[R0, #+0]
   \   00000048   0xF030 0x00F0      BICS     R0,R0,#0xF0
   \   0000004C   0x68A1             LDR      R1,[R4, #+8]
   \   0000004E   0x4308             ORRS     R0,R1,R0
   \   00000050   0x.... 0x....      LDR.W    R1,??DataTable12_1  ;; 0x40023808
   \   00000054   0x6008             STR      R0,[R1, #+0]
    635              }
    636          
    637              /*------------------------- SYSCLK Configuration ---------------------------*/ 
    638              if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
   \                     ??HAL_RCC_ClockConfig_3: (+1)
   \   00000056   0x7820             LDRB     R0,[R4, #+0]
   \   00000058   0x07C0             LSLS     R0,R0,#+31
   \   0000005A   0xF140 0x80DF      BPL.W    ??HAL_RCC_ClockConfig_4
    639              {    
    640                assert_param(IS_RCC_SYSCLKSOURCE(RCC_ClkInitStruct->SYSCLKSource));
    641                
    642                /* HSE is selected as System Clock Source */
    643                if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
   \   0000005E   0x6860             LDR      R0,[R4, #+4]
   \   00000060   0x2801             CMP      R0,#+1
   \   00000062   0xD106             BNE.N    ??HAL_RCC_ClockConfig_5
    644                {
    645                  /* Check the HSE ready flag */  
    646                  if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
   \   00000064   0x.... 0x....      LDR.W    R0,??DataTable12  ;; 0x40023800
   \   00000068   0x6800             LDR      R0,[R0, #+0]
   \   0000006A   0x0380             LSLS     R0,R0,#+14
   \   0000006C   0xD412             BMI.N    ??HAL_RCC_ClockConfig_6
    647                  {
    648                    return HAL_ERROR;
   \   0000006E   0x2001             MOVS     R0,#+1
   \   00000070   0xE0F0             B.N      ??HAL_RCC_ClockConfig_2
    649                  }
    650                }
    651                /* PLL is selected as System Clock Source */
    652                else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
   \                     ??HAL_RCC_ClockConfig_5: (+1)
   \   00000072   0x6860             LDR      R0,[R4, #+4]
   \   00000074   0x2802             CMP      R0,#+2
   \   00000076   0xD106             BNE.N    ??HAL_RCC_ClockConfig_7
    653                {
    654                  /* Check the PLL ready flag */  
    655                  if(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
   \   00000078   0x.... 0x....      LDR.W    R0,??DataTable12  ;; 0x40023800
   \   0000007C   0x6800             LDR      R0,[R0, #+0]
   \   0000007E   0x0180             LSLS     R0,R0,#+6
   \   00000080   0xD408             BMI.N    ??HAL_RCC_ClockConfig_6
    656                  {
    657                    return HAL_ERROR;
   \   00000082   0x2001             MOVS     R0,#+1
   \   00000084   0xE0E6             B.N      ??HAL_RCC_ClockConfig_2
    658                  }
    659                }
    660                /* HSI is selected as System Clock Source */
    661                else
    662                {
    663                  /* Check the HSI ready flag */  
    664                  if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
   \                     ??HAL_RCC_ClockConfig_7: (+1)
   \   00000086   0x.... 0x....      LDR.W    R0,??DataTable12  ;; 0x40023800
   \   0000008A   0x6800             LDR      R0,[R0, #+0]
   \   0000008C   0x0780             LSLS     R0,R0,#+30
   \   0000008E   0xD401             BMI.N    ??HAL_RCC_ClockConfig_6
    665                  {
    666                    return HAL_ERROR;
   \   00000090   0x2001             MOVS     R0,#+1
   \   00000092   0xE0DF             B.N      ??HAL_RCC_ClockConfig_2
    667                  }
    668                }
    669          
    670                __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
   \                     ??HAL_RCC_ClockConfig_6: (+1)
   \   00000094   0x.... 0x....      LDR.W    R0,??DataTable12_1  ;; 0x40023808
   \   00000098   0x6800             LDR      R0,[R0, #+0]
   \   0000009A   0x0880             LSRS     R0,R0,#+2
   \   0000009C   0x0080             LSLS     R0,R0,#+2
   \   0000009E   0x6861             LDR      R1,[R4, #+4]
   \   000000A0   0x4308             ORRS     R0,R1,R0
   \   000000A2   0x.... 0x....      LDR.W    R1,??DataTable12_1  ;; 0x40023808
   \   000000A6   0x6008             STR      R0,[R1, #+0]
    671                /* Get Start Tick*/
    672                tickstart = HAL_GetTick();
   \   000000A8   0x.... 0x....      BL       HAL_GetTick
   \   000000AC   0x0006             MOVS     R6,R0
    673                
    674                if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
   \   000000AE   0x6860             LDR      R0,[R4, #+4]
   \   000000B0   0x2801             CMP      R0,#+1
   \   000000B2   0xD110             BNE.N    ??HAL_RCC_ClockConfig_8
    675                {
    676                  while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSE)
   \                     ??HAL_RCC_ClockConfig_9: (+1)
   \   000000B4   0x.... 0x....      LDR.W    R0,??DataTable12_1  ;; 0x40023808
   \   000000B8   0x6800             LDR      R0,[R0, #+0]
   \   000000BA   0xF010 0x000C      ANDS     R0,R0,#0xC
   \   000000BE   0x2804             CMP      R0,#+4
   \   000000C0   0xF000 0x80AC      BEQ.W    ??HAL_RCC_ClockConfig_4
    677                  {
    678                    if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
   \   000000C4   0x.... 0x....      BL       HAL_GetTick
   \   000000C8   0x1B80             SUBS     R0,R0,R6
   \   000000CA   0xF241 0x3189      MOVW     R1,#+5001
   \   000000CE   0x4288             CMP      R0,R1
   \   000000D0   0xD3F0             BCC.N    ??HAL_RCC_ClockConfig_9
    679                    {
    680                      return HAL_TIMEOUT;
   \   000000D2   0x2003             MOVS     R0,#+3
   \   000000D4   0xE0BE             B.N      ??HAL_RCC_ClockConfig_2
    681                    }
    682                  }
    683                }
    684                else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
   \                     ??HAL_RCC_ClockConfig_8: (+1)
   \   000000D6   0x6860             LDR      R0,[R4, #+4]
   \   000000D8   0x2802             CMP      R0,#+2
   \   000000DA   0xD110             BNE.N    ??HAL_RCC_ClockConfig_10
    685                {
    686                  while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
   \                     ??HAL_RCC_ClockConfig_11: (+1)
   \   000000DC   0x.... 0x....      LDR.W    R0,??DataTable12_1  ;; 0x40023808
   \   000000E0   0x6800             LDR      R0,[R0, #+0]
   \   000000E2   0xF010 0x000C      ANDS     R0,R0,#0xC
   \   000000E6   0x2808             CMP      R0,#+8
   \   000000E8   0xF000 0x8098      BEQ.W    ??HAL_RCC_ClockConfig_4
    687                  {
    688                    if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
   \   000000EC   0x.... 0x....      BL       HAL_GetTick
   \   000000F0   0x1B80             SUBS     R0,R0,R6
   \   000000F2   0xF241 0x3189      MOVW     R1,#+5001
   \   000000F6   0x4288             CMP      R0,R1
   \   000000F8   0xD3F0             BCC.N    ??HAL_RCC_ClockConfig_11
    689                    {
    690                      return HAL_TIMEOUT;
   \   000000FA   0x2003             MOVS     R0,#+3
   \   000000FC   0xE0AA             B.N      ??HAL_RCC_ClockConfig_2
    691                    }
    692                  }
    693                }
    694                else
    695                {
    696                  while(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSI)
   \                     ??HAL_RCC_ClockConfig_10: (+1)
   \   000000FE   0x.... 0x....      LDR.W    R0,??DataTable12_1  ;; 0x40023808
   \   00000102   0x6800             LDR      R0,[R0, #+0]
   \   00000104   0xF010 0x0F0C      TST      R0,#0xC
   \   00000108   0xF000 0x8088      BEQ.W    ??HAL_RCC_ClockConfig_4
    697                  {
    698                    if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
   \   0000010C   0x.... 0x....      BL       HAL_GetTick
   \   00000110   0x1B80             SUBS     R0,R0,R6
   \   00000112   0xF241 0x3189      MOVW     R1,#+5001
   \   00000116   0x4288             CMP      R0,R1
   \   00000118   0xD3F1             BCC.N    ??HAL_RCC_ClockConfig_10
    699                    {
    700                      return HAL_TIMEOUT;
   \   0000011A   0x2003             MOVS     R0,#+3
   \   0000011C   0xE09A             B.N      ??HAL_RCC_ClockConfig_2
    701                    }
    702                  }
    703                }
    704              }    
    705            }
    706            /* Decreasing the CPU frequency */
    707            else
    708            {
    709              /*-------------------------- HCLK Configuration --------------------------*/
    710              if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
   \                     ??HAL_RCC_ClockConfig_0: (+1)
   \   0000011E   0x7820             LDRB     R0,[R4, #+0]
   \   00000120   0x0780             LSLS     R0,R0,#+30
   \   00000122   0xD509             BPL.N    ??HAL_RCC_ClockConfig_12
    711              {
    712                assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
    713                MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
   \   00000124   0x.... 0x....      LDR.W    R0,??DataTable12_1  ;; 0x40023808
   \   00000128   0x6800             LDR      R0,[R0, #+0]
   \   0000012A   0xF030 0x00F0      BICS     R0,R0,#0xF0
   \   0000012E   0x68A1             LDR      R1,[R4, #+8]
   \   00000130   0x4308             ORRS     R0,R1,R0
   \   00000132   0x.... 0x....      LDR.W    R1,??DataTable12_1  ;; 0x40023808
   \   00000136   0x6008             STR      R0,[R1, #+0]
    714              }
    715          
    716              /*------------------------- SYSCLK Configuration -------------------------*/
    717              if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
   \                     ??HAL_RCC_ClockConfig_12: (+1)
   \   00000138   0x7820             LDRB     R0,[R4, #+0]
   \   0000013A   0x07C0             LSLS     R0,R0,#+31
   \   0000013C   0xD55C             BPL.N    ??HAL_RCC_ClockConfig_13
    718              {    
    719                assert_param(IS_RCC_SYSCLKSOURCE(RCC_ClkInitStruct->SYSCLKSource));
    720                
    721                /* HSE is selected as System Clock Source */
    722                if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
   \   0000013E   0x6860             LDR      R0,[R4, #+4]
   \   00000140   0x2801             CMP      R0,#+1
   \   00000142   0xD106             BNE.N    ??HAL_RCC_ClockConfig_14
    723                {
    724                  /* Check the HSE ready flag */  
    725                  if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
   \   00000144   0x.... 0x....      LDR.W    R0,??DataTable12  ;; 0x40023800
   \   00000148   0x6800             LDR      R0,[R0, #+0]
   \   0000014A   0x0380             LSLS     R0,R0,#+14
   \   0000014C   0xD412             BMI.N    ??HAL_RCC_ClockConfig_15
    726                  {
    727                    return HAL_ERROR;
   \   0000014E   0x2001             MOVS     R0,#+1
   \   00000150   0xE080             B.N      ??HAL_RCC_ClockConfig_2
    728                  }
    729                }
    730                /* PLL is selected as System Clock Source */
    731                else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
   \                     ??HAL_RCC_ClockConfig_14: (+1)
   \   00000152   0x6860             LDR      R0,[R4, #+4]
   \   00000154   0x2802             CMP      R0,#+2
   \   00000156   0xD106             BNE.N    ??HAL_RCC_ClockConfig_16
    732                {
    733                  /* Check the PLL ready flag */  
    734                  if(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
   \   00000158   0x.... 0x....      LDR.W    R0,??DataTable12  ;; 0x40023800
   \   0000015C   0x6800             LDR      R0,[R0, #+0]
   \   0000015E   0x0180             LSLS     R0,R0,#+6
   \   00000160   0xD408             BMI.N    ??HAL_RCC_ClockConfig_15
    735                  {
    736                    return HAL_ERROR;
   \   00000162   0x2001             MOVS     R0,#+1
   \   00000164   0xE076             B.N      ??HAL_RCC_ClockConfig_2
    737                  }
    738                }
    739                /* HSI is selected as System Clock Source */
    740                else
    741                {
    742                  /* Check the HSI ready flag */  
    743                  if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
   \                     ??HAL_RCC_ClockConfig_16: (+1)
   \   00000166   0x.... 0x....      LDR.W    R0,??DataTable12  ;; 0x40023800
   \   0000016A   0x6800             LDR      R0,[R0, #+0]
   \   0000016C   0x0780             LSLS     R0,R0,#+30
   \   0000016E   0xD401             BMI.N    ??HAL_RCC_ClockConfig_15
    744                  {
    745                    return HAL_ERROR;
   \   00000170   0x2001             MOVS     R0,#+1
   \   00000172   0xE06F             B.N      ??HAL_RCC_ClockConfig_2
    746                  }
    747                }
    748                __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
   \                     ??HAL_RCC_ClockConfig_15: (+1)
   \   00000174   0x.... 0x....      LDR.W    R0,??DataTable12_1  ;; 0x40023808
   \   00000178   0x6800             LDR      R0,[R0, #+0]
   \   0000017A   0x0880             LSRS     R0,R0,#+2
   \   0000017C   0x0080             LSLS     R0,R0,#+2
   \   0000017E   0x6861             LDR      R1,[R4, #+4]
   \   00000180   0x4308             ORRS     R0,R1,R0
   \   00000182   0x.... 0x....      LDR.W    R1,??DataTable12_1  ;; 0x40023808
   \   00000186   0x6008             STR      R0,[R1, #+0]
    749                /* Get Start Tick*/
    750                tickstart = HAL_GetTick();
   \   00000188   0x.... 0x....      BL       HAL_GetTick
   \   0000018C   0x0006             MOVS     R6,R0
    751                
    752                if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
   \   0000018E   0x6860             LDR      R0,[R4, #+4]
   \   00000190   0x2801             CMP      R0,#+1
   \   00000192   0xD10F             BNE.N    ??HAL_RCC_ClockConfig_17
    753                {
    754                  while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSE)
   \                     ??HAL_RCC_ClockConfig_18: (+1)
   \   00000194   0x.... 0x....      LDR.W    R0,??DataTable12_1  ;; 0x40023808
   \   00000198   0x6800             LDR      R0,[R0, #+0]
   \   0000019A   0xF010 0x000C      ANDS     R0,R0,#0xC
   \   0000019E   0x2804             CMP      R0,#+4
   \   000001A0   0xD02A             BEQ.N    ??HAL_RCC_ClockConfig_13
    755                  {
    756                    if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
   \   000001A2   0x.... 0x....      BL       HAL_GetTick
   \   000001A6   0x1B80             SUBS     R0,R0,R6
   \   000001A8   0xF241 0x3189      MOVW     R1,#+5001
   \   000001AC   0x4288             CMP      R0,R1
   \   000001AE   0xD3F1             BCC.N    ??HAL_RCC_ClockConfig_18
    757                    {
    758                      return HAL_TIMEOUT;
   \   000001B0   0x2003             MOVS     R0,#+3
   \   000001B2   0xE04F             B.N      ??HAL_RCC_ClockConfig_2
    759                    } 
    760                  }
    761                }
    762                else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
   \                     ??HAL_RCC_ClockConfig_17: (+1)
   \   000001B4   0x6860             LDR      R0,[R4, #+4]
   \   000001B6   0x2802             CMP      R0,#+2
   \   000001B8   0xD10F             BNE.N    ??HAL_RCC_ClockConfig_19
    763                {
    764                  while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
   \                     ??HAL_RCC_ClockConfig_20: (+1)
   \   000001BA   0x.... 0x....      LDR.W    R0,??DataTable12_1  ;; 0x40023808
   \   000001BE   0x6800             LDR      R0,[R0, #+0]
   \   000001C0   0xF010 0x000C      ANDS     R0,R0,#0xC
   \   000001C4   0x2808             CMP      R0,#+8
   \   000001C6   0xD017             BEQ.N    ??HAL_RCC_ClockConfig_13
    765                  {
    766                    if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
   \   000001C8   0x.... 0x....      BL       HAL_GetTick
   \   000001CC   0x1B80             SUBS     R0,R0,R6
   \   000001CE   0xF241 0x3189      MOVW     R1,#+5001
   \   000001D2   0x4288             CMP      R0,R1
   \   000001D4   0xD3F1             BCC.N    ??HAL_RCC_ClockConfig_20
    767                    {
    768                      return HAL_TIMEOUT;
   \   000001D6   0x2003             MOVS     R0,#+3
   \   000001D8   0xE03C             B.N      ??HAL_RCC_ClockConfig_2
    769                    } 
    770                  }
    771                }
    772                else
    773                {
    774                  while(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSI)
   \                     ??HAL_RCC_ClockConfig_19: (+1)
   \   000001DA   0x.... 0x....      LDR.W    R0,??DataTable12_1  ;; 0x40023808
   \   000001DE   0x6800             LDR      R0,[R0, #+0]
   \   000001E0   0xF010 0x0F0C      TST      R0,#0xC
   \   000001E4   0xD008             BEQ.N    ??HAL_RCC_ClockConfig_13
    775                  {
    776                    if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
   \   000001E6   0x.... 0x....      BL       HAL_GetTick
   \   000001EA   0x1B80             SUBS     R0,R0,R6
   \   000001EC   0xF241 0x3189      MOVW     R1,#+5001
   \   000001F0   0x4288             CMP      R0,R1
   \   000001F2   0xD3F2             BCC.N    ??HAL_RCC_ClockConfig_19
    777                    {
    778                      return HAL_TIMEOUT;
   \   000001F4   0x2003             MOVS     R0,#+3
   \   000001F6   0xE02D             B.N      ??HAL_RCC_ClockConfig_2
    779                    }
    780                  }
    781                }
    782              }
    783              
    784              /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    785              __HAL_FLASH_SET_LATENCY(FLatency);
   \                     ??HAL_RCC_ClockConfig_13: (+1)
   \   000001F8   0x.... 0x....      LDR.W    R0,??DataTable12_12  ;; 0x40023c00
   \   000001FC   0x6800             LDR      R0,[R0, #+0]
   \   000001FE   0x0900             LSRS     R0,R0,#+4
   \   00000200   0x0100             LSLS     R0,R0,#+4
   \   00000202   0x4328             ORRS     R0,R5,R0
   \   00000204   0x.... 0x....      LDR.W    R1,??DataTable12_12  ;; 0x40023c00
   \   00000208   0x6008             STR      R0,[R1, #+0]
    786              
    787              /* Check that the new number of wait states is taken into account to access the Flash
    788              memory by reading the FLASH_ACR register */
    789              if((FLASH->ACR & FLASH_ACR_LATENCY) != FLatency)
   \   0000020A   0x.... 0x....      LDR.W    R0,??DataTable12_12  ;; 0x40023c00
   \   0000020E   0x6800             LDR      R0,[R0, #+0]
   \   00000210   0xF010 0x000F      ANDS     R0,R0,#0xF
   \   00000214   0x42A8             CMP      R0,R5
   \   00000216   0xD001             BEQ.N    ??HAL_RCC_ClockConfig_4
    790              {
    791                return HAL_ERROR;
   \   00000218   0x2001             MOVS     R0,#+1
   \   0000021A   0xE01B             B.N      ??HAL_RCC_ClockConfig_2
    792              }
    793           }
    794          
    795            /*-------------------------- PCLK1 Configuration ---------------------------*/ 
    796            if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
   \                     ??HAL_RCC_ClockConfig_4: (+1)
   \   0000021C   0x7820             LDRB     R0,[R4, #+0]
   \   0000021E   0x0740             LSLS     R0,R0,#+29
   \   00000220   0xD508             BPL.N    ??HAL_RCC_ClockConfig_21
    797            {
    798              assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB1CLKDivider));
    799              MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_ClkInitStruct->APB1CLKDivider);
   \   00000222   0x.... 0x....      LDR.W    R0,??DataTable12_1  ;; 0x40023808
   \   00000226   0x6800             LDR      R0,[R0, #+0]
   \   00000228   0xF430 0x50E0      BICS     R0,R0,#0x1C00
   \   0000022C   0x68E1             LDR      R1,[R4, #+12]
   \   0000022E   0x4308             ORRS     R0,R1,R0
   \   00000230   0x....             LDR.N    R1,??DataTable12_1  ;; 0x40023808
   \   00000232   0x6008             STR      R0,[R1, #+0]
    800            }
    801            
    802            /*-------------------------- PCLK2 Configuration ---------------------------*/ 
    803            if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
   \                     ??HAL_RCC_ClockConfig_21: (+1)
   \   00000234   0x7820             LDRB     R0,[R4, #+0]
   \   00000236   0x0700             LSLS     R0,R0,#+28
   \   00000238   0xD508             BPL.N    ??HAL_RCC_ClockConfig_22
    804            {
    805              assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB2CLKDivider));
    806              MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, ((RCC_ClkInitStruct->APB2CLKDivider) << 3));
   \   0000023A   0x....             LDR.N    R0,??DataTable12_1  ;; 0x40023808
   \   0000023C   0x6800             LDR      R0,[R0, #+0]
   \   0000023E   0xF430 0x4060      BICS     R0,R0,#0xE000
   \   00000242   0x6921             LDR      R1,[R4, #+16]
   \   00000244   0xEA50 0x00C1      ORRS     R0,R0,R1, LSL #+3
   \   00000248   0x....             LDR.N    R1,??DataTable12_1  ;; 0x40023808
   \   0000024A   0x6008             STR      R0,[R1, #+0]
    807            }
    808          
    809            /* Configure the source of time base considering new system clocks settings*/
    810            HAL_InitTick (TICK_INT_PRIORITY);//TICK_INT_PRIORITY
   \                     ??HAL_RCC_ClockConfig_22: (+1)
   \   0000024C   0x2007             MOVS     R0,#+7
   \   0000024E   0x.... 0x....      BL       HAL_InitTick
    811            
    812            return HAL_OK;
   \   00000252   0x2000             MOVS     R0,#+0
   \                     ??HAL_RCC_ClockConfig_2: (+1)
   \   00000254   0xBD70             POP      {R4-R6,PC}       ;; return
    813          }
    814          
    815          /**
    816            * @}
    817            */
    818          
    819          /** @defgroup RCC_Exported_Functions_Group2 Peripheral Control functions 
    820            *  @brief   RCC clocks control functions 
    821            *
    822            @verbatim   
    823            ===============================================================================
    824                            ##### Peripheral Control functions #####
    825            ===============================================================================  
    826              [..]
    827              This subsection provides a set of functions allowing to control the RCC Clocks 
    828              frequencies.
    829                
    830          @endverbatim
    831            * @{
    832            */
    833          
    834          /**
    835            * @brief  Selects the clock source to output on MCO1 pin(PA8) or on MCO2 pin(PC9).
    836            * @note   PA8/PC9 should be configured in alternate function mode.
    837            * @param  RCC_MCOx: specifies the output direction for the clock source.
    838            *          This parameter can be one of the following values:
    839            *            @arg RCC_MCO1: Clock source to output on MCO1 pin(PA8).
    840            *            @arg RCC_MCO2: Clock source to output on MCO2 pin(PC9).
    841            * @param  RCC_MCOSource: specifies the clock source to output.
    842            *          This parameter can be one of the following values:
    843            *            @arg RCC_MCO1SOURCE_HSI: HSI clock selected as MCO1 source
    844            *            @arg RCC_MCO1SOURCE_LSE: LSE clock selected as MCO1 source
    845            *            @arg RCC_MCO1SOURCE_HSE: HSE clock selected as MCO1 source
    846            *            @arg RCC_MCO1SOURCE_PLLCLK: main PLL clock selected as MCO1 source
    847            *            @arg RCC_MCO2SOURCE_SYSCLK: System clock (SYSCLK) selected as MCO2 source
    848            *            @arg RCC_MCO2SOURCE_PLLI2SCLK: PLLI2S clock selected as MCO2 source
    849            *            @arg RCC_MCO2SOURCE_HSE: HSE clock selected as MCO2 source
    850            *            @arg RCC_MCO2SOURCE_PLLCLK: main PLL clock selected as MCO2 source
    851            * @param  RCC_MCODiv: specifies the MCOx prescaler.
    852            *          This parameter can be one of the following values:
    853            *            @arg RCC_MCODIV_1: no division applied to MCOx clock
    854            *            @arg RCC_MCODIV_2: division by 2 applied to MCOx clock
    855            *            @arg RCC_MCODIV_3: division by 3 applied to MCOx clock
    856            *            @arg RCC_MCODIV_4: division by 4 applied to MCOx clock
    857            *            @arg RCC_MCODIV_5: division by 5 applied to MCOx clock
    858            * @retval None
    859            */

   \                                 In section .text, align 2, keep-with-next
    860          void HAL_RCC_MCOConfig(uint32_t RCC_MCOx, uint32_t RCC_MCOSource, uint32_t RCC_MCODiv)
    861          {
   \                     HAL_RCC_MCOConfig: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB086             SUB      SP,SP,#+24
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
    862            GPIO_InitTypeDef GPIO_InitStruct;
    863            /* Check the parameters */
    864            assert_param(IS_RCC_MCO(RCC_MCOx));
    865            assert_param(IS_RCC_MCODIV(RCC_MCODiv));
    866            /* RCC_MCO1 */
    867            if(RCC_MCOx == RCC_MCO1)
   \   0000000A   0x2C00             CMP      R4,#+0
   \   0000000C   0xD123             BNE.N    ??HAL_RCC_MCOConfig_0
    868            {
    869              assert_param(IS_RCC_MCO1SOURCE(RCC_MCOSource));
    870              
    871              /* MCO1 Clock Enable */
    872              MCO1_CLK_ENABLE();
   \   0000000E   0x....             LDR.N    R0,??DataTable12_13  ;; 0x40023830
   \   00000010   0x6800             LDR      R0,[R0, #+0]
   \   00000012   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000016   0x....             LDR.N    R1,??DataTable12_13  ;; 0x40023830
   \   00000018   0x6008             STR      R0,[R1, #+0]
   \   0000001A   0x....             LDR.N    R0,??DataTable12_13  ;; 0x40023830
   \   0000001C   0x6800             LDR      R0,[R0, #+0]
   \   0000001E   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   00000022   0x9000             STR      R0,[SP, #+0]
   \   00000024   0x9800             LDR      R0,[SP, #+0]
    873              
    874              /* Configure the MCO1 pin in alternate function mode */    
    875              GPIO_InitStruct.Pin = MCO1_PIN;
   \   00000026   0xF44F 0x7080      MOV      R0,#+256
   \   0000002A   0x9001             STR      R0,[SP, #+4]
    876              GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
   \   0000002C   0x2002             MOVS     R0,#+2
   \   0000002E   0x9002             STR      R0,[SP, #+8]
    877              GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
   \   00000030   0x2003             MOVS     R0,#+3
   \   00000032   0x9004             STR      R0,[SP, #+16]
    878              GPIO_InitStruct.Pull = GPIO_NOPULL;
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0x9003             STR      R0,[SP, #+12]
    879              GPIO_InitStruct.Alternate = GPIO_AF0_MCO;
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0x9005             STR      R0,[SP, #+20]
    880              HAL_GPIO_Init(MCO1_GPIO_PORT, &GPIO_InitStruct);
   \   0000003C   0xA901             ADD      R1,SP,#+4
   \   0000003E   0x....             LDR.N    R0,??DataTable12_14  ;; 0x40020000
   \   00000040   0x.... 0x....      BL       HAL_GPIO_Init
    881              
    882              /* Mask MCO1 and MCO1PRE[2:0] bits then Select MCO1 clock source and prescaler */
    883              MODIFY_REG(RCC->CFGR, (RCC_CFGR_MCO1 | RCC_CFGR_MCO1PRE), (RCC_MCOSource | RCC_MCODiv));
   \   00000044   0x....             LDR.N    R0,??DataTable12_1  ;; 0x40023808
   \   00000046   0x6800             LDR      R0,[R0, #+0]
   \   00000048   0xF030 0x60EC      BICS     R0,R0,#0x7600000
   \   0000004C   0x4328             ORRS     R0,R5,R0
   \   0000004E   0x4330             ORRS     R0,R6,R0
   \   00000050   0x....             LDR.N    R1,??DataTable12_1  ;; 0x40023808
   \   00000052   0x6008             STR      R0,[R1, #+0]
   \   00000054   0xE023             B.N      ??HAL_RCC_MCOConfig_1
    884            }
    885            else
    886            {
    887              assert_param(IS_RCC_MCO2SOURCE(RCC_MCOSource));
    888              
    889              /* MCO2 Clock Enable */
    890              MCO2_CLK_ENABLE();
   \                     ??HAL_RCC_MCOConfig_0: (+1)
   \   00000056   0x....             LDR.N    R0,??DataTable12_13  ;; 0x40023830
   \   00000058   0x6800             LDR      R0,[R0, #+0]
   \   0000005A   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   0000005E   0x....             LDR.N    R1,??DataTable12_13  ;; 0x40023830
   \   00000060   0x6008             STR      R0,[R1, #+0]
   \   00000062   0x....             LDR.N    R0,??DataTable12_13  ;; 0x40023830
   \   00000064   0x6800             LDR      R0,[R0, #+0]
   \   00000066   0xF010 0x0004      ANDS     R0,R0,#0x4
   \   0000006A   0x9000             STR      R0,[SP, #+0]
   \   0000006C   0x9800             LDR      R0,[SP, #+0]
    891              
    892              /* Configure the MCO2 pin in alternate function mode */
    893              GPIO_InitStruct.Pin = MCO2_PIN;
   \   0000006E   0xF44F 0x7000      MOV      R0,#+512
   \   00000072   0x9001             STR      R0,[SP, #+4]
    894              GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
   \   00000074   0x2002             MOVS     R0,#+2
   \   00000076   0x9002             STR      R0,[SP, #+8]
    895              GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
   \   00000078   0x2003             MOVS     R0,#+3
   \   0000007A   0x9004             STR      R0,[SP, #+16]
    896              GPIO_InitStruct.Pull = GPIO_NOPULL;
   \   0000007C   0x2000             MOVS     R0,#+0
   \   0000007E   0x9003             STR      R0,[SP, #+12]
    897              GPIO_InitStruct.Alternate = GPIO_AF0_MCO;
   \   00000080   0x2000             MOVS     R0,#+0
   \   00000082   0x9005             STR      R0,[SP, #+20]
    898              HAL_GPIO_Init(MCO2_GPIO_PORT, &GPIO_InitStruct);
   \   00000084   0xA901             ADD      R1,SP,#+4
   \   00000086   0x....             LDR.N    R0,??DataTable12_15  ;; 0x40020800
   \   00000088   0x.... 0x....      BL       HAL_GPIO_Init
    899              
    900              /* Mask MCO2 and MCO2PRE[2:0] bits then Select MCO2 clock source and prescaler */
    901              MODIFY_REG(RCC->CFGR, (RCC_CFGR_MCO2 | RCC_CFGR_MCO2PRE), (RCC_MCOSource | (RCC_MCODiv << 3)));
   \   0000008C   0x....             LDR.N    R0,??DataTable12_1  ;; 0x40023808
   \   0000008E   0x6800             LDR      R0,[R0, #+0]
   \   00000090   0x0140             LSLS     R0,R0,#+5        ;; ZeroExtS R0,R0,#+5,#+5
   \   00000092   0x0940             LSRS     R0,R0,#+5
   \   00000094   0x4328             ORRS     R0,R5,R0
   \   00000096   0xEA50 0x00C6      ORRS     R0,R0,R6, LSL #+3
   \   0000009A   0x....             LDR.N    R1,??DataTable12_1  ;; 0x40023808
   \   0000009C   0x6008             STR      R0,[R1, #+0]
    902            }
    903          }
   \                     ??HAL_RCC_MCOConfig_1: (+1)
   \   0000009E   0xB006             ADD      SP,SP,#+24
   \   000000A0   0xBD70             POP      {R4-R6,PC}       ;; return
    904          
    905          /**
    906            * @brief  Enables the Clock Security System.
    907            * @note   If a failure is detected on the HSE oscillator clock, this oscillator
    908            *         is automatically disabled and an interrupt is generated to inform the
    909            *         software about the failure (Clock Security System Interrupt, CSSI),
    910            *         allowing the MCU to perform rescue operations. The CSSI is linked to 
    911            *         the Cortex-M7 NMI (Non-Maskable Interrupt) exception vector.  
    912            * @retval None
    913            */

   \                                 In section .text, align 2, keep-with-next
    914          void HAL_RCC_EnableCSS(void)
    915          {
    916            SET_BIT(RCC->CR, RCC_CR_CSSON);
   \                     HAL_RCC_EnableCSS: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable12  ;; 0x40023800
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0xF450 0x2000      ORRS     R0,R0,#0x80000
   \   00000008   0x....             LDR.N    R1,??DataTable12  ;; 0x40023800
   \   0000000A   0x6008             STR      R0,[R1, #+0]
    917          }
   \   0000000C   0x4770             BX       LR               ;; return
    918          
    919          /**
    920            * @brief  Disables the Clock Security System.
    921            * @retval None
    922            */

   \                                 In section .text, align 2, keep-with-next
    923          void HAL_RCC_DisableCSS(void)
    924          {
    925            CLEAR_BIT(RCC->CR, RCC_CR_CSSON);
   \                     HAL_RCC_DisableCSS: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable12  ;; 0x40023800
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0xF430 0x2000      BICS     R0,R0,#0x80000
   \   00000008   0x....             LDR.N    R1,??DataTable12  ;; 0x40023800
   \   0000000A   0x6008             STR      R0,[R1, #+0]
    926          }
   \   0000000C   0x4770             BX       LR               ;; return
    927          
    928          /**
    929            * @brief  Returns the SYSCLK frequency
    930            *        
    931            * @note   The system frequency computed by this function is not the real 
    932            *         frequency in the chip. It is calculated based on the predefined 
    933            *         constant and the selected clock source:
    934            * @note     If SYSCLK source is HSI, function returns values based on HSI_VALUE(*)
    935            * @note     If SYSCLK source is HSE, function returns values based on HSE_VALUE(**)
    936            * @note     If SYSCLK source is PLL, function returns values based on HSE_VALUE(**) 
    937            *           or HSI_VALUE(*) multiplied/divided by the PLL factors.         
    938            * @note     (*) HSI_VALUE is a constant defined in stm32f7xx_hal_conf.h file (default value
    939            *               16 MHz) but the real value may vary depending on the variations
    940            *               in voltage and temperature.
    941            * @note     (**) HSE_VALUE is a constant defined in stm32f7xx_hal_conf.h file (default value
    942            *                25 MHz), user has to ensure that HSE_VALUE is same as the real
    943            *                frequency of the crystal used. Otherwise, this function may
    944            *                have wrong result.
    945            *                  
    946            * @note   The result of this function could be not correct when using fractional
    947            *         value for HSE crystal.
    948            *           
    949            * @note   This function can be used by the user application to compute the 
    950            *         baudrate for the communication peripherals or configure other parameters.
    951            *           
    952            * @note   Each time SYSCLK changes, this function must be called to update the
    953            *         right SYSCLK value. Otherwise, any configuration based on this function will be incorrect.
    954            *         
    955            *               
    956            * @retval SYSCLK frequency
    957            */

   \                                 In section .text, align 2, keep-with-next
    958          uint32_t HAL_RCC_GetSysClockFreq(void)
    959          {
   \                     HAL_RCC_GetSysClockFreq: (+1)
   \   00000000   0xB470             PUSH     {R4-R6}
    960            uint32_t pllm = 0, pllvco = 0, pllp = 0;
   \   00000002   0x2100             MOVS     R1,#+0
   \   00000004   0x2200             MOVS     R2,#+0
   \   00000006   0x2300             MOVS     R3,#+0
    961            uint32_t sysclockfreq = 0;
   \   00000008   0x2000             MOVS     R0,#+0
    962          
    963            /* Get SYSCLK source -------------------------------------------------------*/
    964            switch (RCC->CFGR & RCC_CFGR_SWS)
   \   0000000A   0x....             LDR.N    R4,??DataTable12_1  ;; 0x40023808
   \   0000000C   0x6824             LDR      R4,[R4, #+0]
   \   0000000E   0xF014 0x040C      ANDS     R4,R4,#0xC
   \   00000012   0x2C00             CMP      R4,#+0
   \   00000014   0xD004             BEQ.N    ??HAL_RCC_GetSysClockFreq_0
   \   00000016   0x2C04             CMP      R4,#+4
   \   00000018   0xD005             BEQ.N    ??HAL_RCC_GetSysClockFreq_1
   \   0000001A   0x2C08             CMP      R4,#+8
   \   0000001C   0xD006             BEQ.N    ??HAL_RCC_GetSysClockFreq_2
   \   0000001E   0xE03D             B.N      ??HAL_RCC_GetSysClockFreq_3
    965            {
    966              case RCC_SYSCLKSOURCE_STATUS_HSI:  /* HSI used as system clock source */
    967              {
    968                sysclockfreq = HSI_VALUE;
   \                     ??HAL_RCC_GetSysClockFreq_0: (+1)
   \   00000020   0x....             LDR.N    R4,??DataTable12_16  ;; 0xf42400
   \   00000022   0x0020             MOVS     R0,R4
    969                 break;
   \   00000024   0xE03C             B.N      ??HAL_RCC_GetSysClockFreq_4
    970              }
    971              case RCC_SYSCLKSOURCE_STATUS_HSE:  /* HSE used as system clock  source */
    972              {
    973                sysclockfreq = HSE_VALUE;
   \                     ??HAL_RCC_GetSysClockFreq_1: (+1)
   \   00000026   0x....             LDR.N    R4,??DataTable12_17  ;; 0x17d7840
   \   00000028   0x0020             MOVS     R0,R4
    974                break;
   \   0000002A   0xE039             B.N      ??HAL_RCC_GetSysClockFreq_4
    975              }
    976              case RCC_SYSCLKSOURCE_STATUS_PLLCLK:  /* PLL used as system clock  source */
    977              {
    978                /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLLM) * PLLN
    979                SYSCLK = PLL_VCO / PLLP */
    980                pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
   \                     ??HAL_RCC_GetSysClockFreq_2: (+1)
   \   0000002C   0x....             LDR.N    R4,??DataTable12_3  ;; 0x40023804
   \   0000002E   0x6824             LDR      R4,[R4, #+0]
   \   00000030   0xF014 0x043F      ANDS     R4,R4,#0x3F
   \   00000034   0x0021             MOVS     R1,R4
    981                if (__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLCFGR_PLLSRC_HSI)
   \   00000036   0x....             LDR.N    R4,??DataTable12_3  ;; 0x40023804
   \   00000038   0x6824             LDR      R4,[R4, #+0]
   \   0000003A   0x0264             LSLS     R4,R4,#+9
   \   0000003C   0xD50F             BPL.N    ??HAL_RCC_GetSysClockFreq_5
    982                {
    983                  /* HSE used as PLL clock source */
    984                  pllvco = ((HSE_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> POSITION_VAL(RCC_PLLCFGR_PLLN)));
   \   0000003E   0x....             LDR.N    R4,??DataTable12_3  ;; 0x40023804
   \   00000040   0x6824             LDR      R4,[R4, #+0]
   \   00000042   0x....             LDR.N    R5,??DataTable12_17  ;; 0x17d7840
   \   00000044   0xFBB5 0xF5F1      UDIV     R5,R5,R1
   \   00000048   0xF647 0x76C0      MOVW     R6,#+32704
   \   0000004C   0x4034             ANDS     R4,R6,R4
   \   0000004E   0x....             LDR.N    R6,??DataTable12_11  ;; 0x3fe0000
   \   00000050   0xFAB6 0xF686      CLZ      R6,R6
   \   00000054   0x40F4             LSRS     R4,R4,R6
   \   00000056   0xFB04 0xF405      MUL      R4,R4,R5
   \   0000005A   0x0022             MOVS     R2,R4
   \   0000005C   0xE00E             B.N      ??HAL_RCC_GetSysClockFreq_6
    985                }
    986                else
    987                {
    988                  /* HSI used as PLL clock source */
    989                  pllvco = ((HSI_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> POSITION_VAL(RCC_PLLCFGR_PLLN)));    
   \                     ??HAL_RCC_GetSysClockFreq_5: (+1)
   \   0000005E   0x....             LDR.N    R4,??DataTable12_3  ;; 0x40023804
   \   00000060   0x6824             LDR      R4,[R4, #+0]
   \   00000062   0x....             LDR.N    R5,??DataTable12_16  ;; 0xf42400
   \   00000064   0xFBB5 0xF5F1      UDIV     R5,R5,R1
   \   00000068   0xF647 0x76C0      MOVW     R6,#+32704
   \   0000006C   0x4034             ANDS     R4,R6,R4
   \   0000006E   0x....             LDR.N    R6,??DataTable12_11  ;; 0x3fe0000
   \   00000070   0xFAB6 0xF686      CLZ      R6,R6
   \   00000074   0x40F4             LSRS     R4,R4,R6
   \   00000076   0xFB04 0xF405      MUL      R4,R4,R5
   \   0000007A   0x0022             MOVS     R2,R4
    990                }
    991                pllp = ((((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >> POSITION_VAL(RCC_PLLCFGR_PLLP)) + 1 ) *2);
   \                     ??HAL_RCC_GetSysClockFreq_6: (+1)
   \   0000007C   0x....             LDR.N    R4,??DataTable12_3  ;; 0x40023804
   \   0000007E   0x6824             LDR      R4,[R4, #+0]
   \   00000080   0xF414 0x3440      ANDS     R4,R4,#0x30000
   \   00000084   0xF44F 0x4540      MOV      R5,#+49152
   \   00000088   0xFAB5 0xF585      CLZ      R5,R5
   \   0000008C   0x40EC             LSRS     R4,R4,R5
   \   0000008E   0x1C64             ADDS     R4,R4,#+1
   \   00000090   0x0064             LSLS     R4,R4,#+1
   \   00000092   0x0023             MOVS     R3,R4
    992                
    993                sysclockfreq = pllvco/pllp;
   \   00000094   0xFBB2 0xF4F3      UDIV     R4,R2,R3
   \   00000098   0x0020             MOVS     R0,R4
    994                break;
   \   0000009A   0xE001             B.N      ??HAL_RCC_GetSysClockFreq_4
    995              }
    996              default:
    997              {
    998                sysclockfreq = HSI_VALUE;
   \                     ??HAL_RCC_GetSysClockFreq_3: (+1)
   \   0000009C   0x....             LDR.N    R4,??DataTable12_16  ;; 0xf42400
   \   0000009E   0x0020             MOVS     R0,R4
    999                break;
   1000              }
   1001            }
   1002            return sysclockfreq;
   \                     ??HAL_RCC_GetSysClockFreq_4: (+1)
   \   000000A0   0xBC70             POP      {R4-R6}
   \   000000A2   0x4770             BX       LR               ;; return
   1003          }
   1004          
   1005          /**
   1006            * @brief  Returns the HCLK frequency     
   1007            * @note   Each time HCLK changes, this function must be called to update the
   1008            *         right HCLK value. Otherwise, any configuration based on this function will be incorrect.
   1009            * 
   1010            * @note   The SystemCoreClock CMSIS variable is used to store System Clock Frequency 
   1011            *         and updated within this function
   1012            * @retval HCLK frequency
   1013            */

   \                                 In section .text, align 2, keep-with-next
   1014          uint32_t HAL_RCC_GetHCLKFreq(void)
   1015          {
   \                     HAL_RCC_GetHCLKFreq: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1016            SystemCoreClock = HAL_RCC_GetSysClockFreq() >> APBAHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE)>> POSITION_VAL(RCC_CFGR_HPRE)];
   \   00000002   0x.... 0x....      BL       HAL_RCC_GetSysClockFreq
   \   00000006   0x....             LDR.N    R1,??DataTable12_1  ;; 0x40023808
   \   00000008   0x6809             LDR      R1,[R1, #+0]
   \   0000000A   0xF05F 0x6270      MOVS     R2,#+251658240
   \   0000000E   0xFAB2 0xF282      CLZ      R2,R2
   \   00000012   0x....             LDR.N    R3,??DataTable12_18
   \   00000014   0xF011 0x01F0      ANDS     R1,R1,#0xF0
   \   00000018   0x40D1             LSRS     R1,R1,R2
   \   0000001A   0x5CC9             LDRB     R1,[R1, R3]
   \   0000001C   0x40C8             LSRS     R0,R0,R1
   \   0000001E   0x....             LDR.N    R1,??DataTable12_19
   \   00000020   0x6008             STR      R0,[R1, #+0]
   1017            return SystemCoreClock;
   \   00000022   0x....             LDR.N    R0,??DataTable12_19
   \   00000024   0x6800             LDR      R0,[R0, #+0]
   \   00000026   0xBD02             POP      {R1,PC}          ;; return
   1018          }
   1019          
   1020          /**
   1021            * @brief  Returns the PCLK1 frequency     
   1022            * @note   Each time PCLK1 changes, this function must be called to update the
   1023            *         right PCLK1 value. Otherwise, any configuration based on this function will be incorrect.
   1024            * @retval PCLK1 frequency
   1025            */

   \                                 In section .text, align 2, keep-with-next
   1026          uint32_t HAL_RCC_GetPCLK1Freq(void)
   1027          {  
   \                     HAL_RCC_GetPCLK1Freq: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1028            /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
   1029            return (HAL_RCC_GetHCLKFreq() >> APBAHBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE1)>> POSITION_VAL(RCC_CFGR_PPRE1)]);
   \   00000002   0x.... 0x....      BL       HAL_RCC_GetHCLKFreq
   \   00000006   0x....             LDR.N    R1,??DataTable12_1  ;; 0x40023808
   \   00000008   0x6809             LDR      R1,[R1, #+0]
   \   0000000A   0xF45F 0x1260      MOVS     R2,#+3670016
   \   0000000E   0xFAB2 0xF282      CLZ      R2,R2
   \   00000012   0x....             LDR.N    R3,??DataTable12_18
   \   00000014   0xF411 0x51E0      ANDS     R1,R1,#0x1C00
   \   00000018   0x40D1             LSRS     R1,R1,R2
   \   0000001A   0x5CC9             LDRB     R1,[R1, R3]
   \   0000001C   0x40C8             LSRS     R0,R0,R1
   \   0000001E   0xBD02             POP      {R1,PC}          ;; return
   1030          }
   1031          
   1032          /**
   1033            * @brief  Returns the PCLK2 frequency     
   1034            * @note   Each time PCLK2 changes, this function must be called to update the
   1035            *         right PCLK2 value. Otherwise, any configuration based on this function will be incorrect.
   1036            * @retval PCLK2 frequency
   1037            */

   \                                 In section .text, align 2, keep-with-next
   1038          uint32_t HAL_RCC_GetPCLK2Freq(void)
   1039          {
   \                     HAL_RCC_GetPCLK2Freq: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1040            /* Get HCLK source and Compute PCLK2 frequency ---------------------------*/
   1041            return (HAL_RCC_GetHCLKFreq()>> APBAHBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE2)>> POSITION_VAL(RCC_CFGR_PPRE2)]);
   \   00000002   0x.... 0x....      BL       HAL_RCC_GetHCLKFreq
   \   00000006   0x....             LDR.N    R1,??DataTable12_1  ;; 0x40023808
   \   00000008   0x6809             LDR      R1,[R1, #+0]
   \   0000000A   0xF45F 0x22E0      MOVS     R2,#+458752
   \   0000000E   0xFAB2 0xF282      CLZ      R2,R2
   \   00000012   0x....             LDR.N    R3,??DataTable12_18
   \   00000014   0xF411 0x4160      ANDS     R1,R1,#0xE000
   \   00000018   0x40D1             LSRS     R1,R1,R2
   \   0000001A   0x5CC9             LDRB     R1,[R1, R3]
   \   0000001C   0x40C8             LSRS     R0,R0,R1
   \   0000001E   0xBD02             POP      {R1,PC}          ;; return
   1042          } 
   1043          
   1044          /**
   1045            * @brief  Configures the RCC_OscInitStruct according to the internal 
   1046            * RCC configuration registers.
   1047            * @param  RCC_OscInitStruct: pointer to an RCC_OscInitTypeDef structure that 
   1048            * will be configured.
   1049            * @retval None
   1050            */

   \                                 In section .text, align 2, keep-with-next
   1051          void HAL_RCC_GetOscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
   1052          {
   1053            /* Set all possible values for the Oscillator type parameter ---------------*/
   1054            RCC_OscInitStruct->OscillatorType = RCC_OSCILLATORTYPE_HSE | RCC_OSCILLATORTYPE_HSI | RCC_OSCILLATORTYPE_LSE | RCC_OSCILLATORTYPE_LSI;
   \                     HAL_RCC_GetOscConfig: (+1)
   \   00000000   0x210F             MOVS     R1,#+15
   \   00000002   0x6001             STR      R1,[R0, #+0]
   1055            
   1056            /* Get the HSE configuration -----------------------------------------------*/
   1057            if((RCC->CR &RCC_CR_HSEBYP) == RCC_CR_HSEBYP)
   \   00000004   0x....             LDR.N    R1,??DataTable12  ;; 0x40023800
   \   00000006   0x6809             LDR      R1,[R1, #+0]
   \   00000008   0x0349             LSLS     R1,R1,#+13
   \   0000000A   0xD503             BPL.N    ??HAL_RCC_GetOscConfig_0
   1058            {
   1059              RCC_OscInitStruct->HSEState = RCC_HSE_BYPASS;
   \   0000000C   0xF45F 0x21A0      MOVS     R1,#+327680
   \   00000010   0x6041             STR      R1,[R0, #+4]
   \   00000012   0xE009             B.N      ??HAL_RCC_GetOscConfig_1
   1060            }
   1061            else if((RCC->CR &RCC_CR_HSEON) == RCC_CR_HSEON)
   \                     ??HAL_RCC_GetOscConfig_0: (+1)
   \   00000014   0x....             LDR.N    R1,??DataTable12  ;; 0x40023800
   \   00000016   0x6809             LDR      R1,[R1, #+0]
   \   00000018   0x03C9             LSLS     R1,R1,#+15
   \   0000001A   0xD503             BPL.N    ??HAL_RCC_GetOscConfig_2
   1062            {
   1063              RCC_OscInitStruct->HSEState = RCC_HSE_ON;
   \   0000001C   0xF45F 0x3180      MOVS     R1,#+65536
   \   00000020   0x6041             STR      R1,[R0, #+4]
   \   00000022   0xE001             B.N      ??HAL_RCC_GetOscConfig_1
   1064            }
   1065            else
   1066            {
   1067              RCC_OscInitStruct->HSEState = RCC_HSE_OFF;
   \                     ??HAL_RCC_GetOscConfig_2: (+1)
   \   00000024   0x2100             MOVS     R1,#+0
   \   00000026   0x6041             STR      R1,[R0, #+4]
   1068            }
   1069            
   1070            /* Get the HSI configuration -----------------------------------------------*/
   1071            if((RCC->CR &RCC_CR_HSION) == RCC_CR_HSION)
   \                     ??HAL_RCC_GetOscConfig_1: (+1)
   \   00000028   0x....             LDR.N    R1,??DataTable12  ;; 0x40023800
   \   0000002A   0x6809             LDR      R1,[R1, #+0]
   \   0000002C   0x07C9             LSLS     R1,R1,#+31
   \   0000002E   0xD502             BPL.N    ??HAL_RCC_GetOscConfig_3
   1072            {
   1073              RCC_OscInitStruct->HSIState = RCC_HSI_ON;
   \   00000030   0x2101             MOVS     R1,#+1
   \   00000032   0x60C1             STR      R1,[R0, #+12]
   \   00000034   0xE001             B.N      ??HAL_RCC_GetOscConfig_4
   1074            }
   1075            else
   1076            {
   1077              RCC_OscInitStruct->HSIState = RCC_HSI_OFF;
   \                     ??HAL_RCC_GetOscConfig_3: (+1)
   \   00000036   0x2100             MOVS     R1,#+0
   \   00000038   0x60C1             STR      R1,[R0, #+12]
   1078            }
   1079            
   1080            RCC_OscInitStruct->HSICalibrationValue = (uint32_t)((RCC->CR &RCC_CR_HSITRIM) >> POSITION_VAL(RCC_CR_HSITRIM));
   \                     ??HAL_RCC_GetOscConfig_4: (+1)
   \   0000003A   0x....             LDR.N    R1,??DataTable12  ;; 0x40023800
   \   0000003C   0x6809             LDR      R1,[R1, #+0]
   \   0000003E   0xF011 0x01F8      ANDS     R1,R1,#0xF8
   \   00000042   0xF05F 0x52F8      MOVS     R2,#+520093696
   \   00000046   0xFAB2 0xF282      CLZ      R2,R2
   \   0000004A   0x40D1             LSRS     R1,R1,R2
   \   0000004C   0x6101             STR      R1,[R0, #+16]
   1081            
   1082            /* Get the LSE configuration -----------------------------------------------*/
   1083            if((RCC->BDCR &RCC_BDCR_LSEBYP) == RCC_BDCR_LSEBYP)
   \   0000004E   0x....             LDR.N    R1,??DataTable12_10  ;; 0x40023870
   \   00000050   0x6809             LDR      R1,[R1, #+0]
   \   00000052   0x0749             LSLS     R1,R1,#+29
   \   00000054   0xD502             BPL.N    ??HAL_RCC_GetOscConfig_5
   1084            {
   1085              RCC_OscInitStruct->LSEState = RCC_LSE_BYPASS;
   \   00000056   0x2105             MOVS     R1,#+5
   \   00000058   0x6081             STR      R1,[R0, #+8]
   \   0000005A   0xE008             B.N      ??HAL_RCC_GetOscConfig_6
   1086            }
   1087            else if((RCC->BDCR &RCC_BDCR_LSEON) == RCC_BDCR_LSEON)
   \                     ??HAL_RCC_GetOscConfig_5: (+1)
   \   0000005C   0x....             LDR.N    R1,??DataTable12_10  ;; 0x40023870
   \   0000005E   0x6809             LDR      R1,[R1, #+0]
   \   00000060   0x07C9             LSLS     R1,R1,#+31
   \   00000062   0xD502             BPL.N    ??HAL_RCC_GetOscConfig_7
   1088            {
   1089              RCC_OscInitStruct->LSEState = RCC_LSE_ON;
   \   00000064   0x2101             MOVS     R1,#+1
   \   00000066   0x6081             STR      R1,[R0, #+8]
   \   00000068   0xE001             B.N      ??HAL_RCC_GetOscConfig_6
   1090            }
   1091            else
   1092            {
   1093              RCC_OscInitStruct->LSEState = RCC_LSE_OFF;
   \                     ??HAL_RCC_GetOscConfig_7: (+1)
   \   0000006A   0x2100             MOVS     R1,#+0
   \   0000006C   0x6081             STR      R1,[R0, #+8]
   1094            }
   1095            
   1096            /* Get the LSI configuration -----------------------------------------------*/
   1097            if((RCC->CSR &RCC_CSR_LSION) == RCC_CSR_LSION)
   \                     ??HAL_RCC_GetOscConfig_6: (+1)
   \   0000006E   0x....             LDR.N    R1,??DataTable12_7  ;; 0x40023874
   \   00000070   0x6809             LDR      R1,[R1, #+0]
   \   00000072   0x07C9             LSLS     R1,R1,#+31
   \   00000074   0xD502             BPL.N    ??HAL_RCC_GetOscConfig_8
   1098            {
   1099              RCC_OscInitStruct->LSIState = RCC_LSI_ON;
   \   00000076   0x2101             MOVS     R1,#+1
   \   00000078   0x6141             STR      R1,[R0, #+20]
   \   0000007A   0xE001             B.N      ??HAL_RCC_GetOscConfig_9
   1100            }
   1101            else
   1102            {
   1103              RCC_OscInitStruct->LSIState = RCC_LSI_OFF;
   \                     ??HAL_RCC_GetOscConfig_8: (+1)
   \   0000007C   0x2100             MOVS     R1,#+0
   \   0000007E   0x6141             STR      R1,[R0, #+20]
   1104            }
   1105            
   1106            /* Get the PLL configuration -----------------------------------------------*/
   1107            if((RCC->CR &RCC_CR_PLLON) == RCC_CR_PLLON)
   \                     ??HAL_RCC_GetOscConfig_9: (+1)
   \   00000080   0x....             LDR.N    R1,??DataTable12  ;; 0x40023800
   \   00000082   0x6809             LDR      R1,[R1, #+0]
   \   00000084   0x01C9             LSLS     R1,R1,#+7
   \   00000086   0xD502             BPL.N    ??HAL_RCC_GetOscConfig_10
   1108            {
   1109              RCC_OscInitStruct->PLL.PLLState = RCC_PLL_ON;
   \   00000088   0x2102             MOVS     R1,#+2
   \   0000008A   0x6181             STR      R1,[R0, #+24]
   \   0000008C   0xE001             B.N      ??HAL_RCC_GetOscConfig_11
   1110            }
   1111            else
   1112            {
   1113              RCC_OscInitStruct->PLL.PLLState = RCC_PLL_OFF;
   \                     ??HAL_RCC_GetOscConfig_10: (+1)
   \   0000008E   0x2101             MOVS     R1,#+1
   \   00000090   0x6181             STR      R1,[R0, #+24]
   1114            }
   1115            RCC_OscInitStruct->PLL.PLLSource = (uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC);
   \                     ??HAL_RCC_GetOscConfig_11: (+1)
   \   00000092   0x....             LDR.N    R1,??DataTable12_3  ;; 0x40023804
   \   00000094   0x6809             LDR      R1,[R1, #+0]
   \   00000096   0xF411 0x0180      ANDS     R1,R1,#0x400000
   \   0000009A   0x61C1             STR      R1,[R0, #+28]
   1116            RCC_OscInitStruct->PLL.PLLM = (uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLM);
   \   0000009C   0x....             LDR.N    R1,??DataTable12_3  ;; 0x40023804
   \   0000009E   0x6809             LDR      R1,[R1, #+0]
   \   000000A0   0xF011 0x013F      ANDS     R1,R1,#0x3F
   \   000000A4   0x6201             STR      R1,[R0, #+32]
   1117            RCC_OscInitStruct->PLL.PLLN = (uint32_t)((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> POSITION_VAL(RCC_PLLCFGR_PLLN));
   \   000000A6   0x....             LDR.N    R1,??DataTable12_3  ;; 0x40023804
   \   000000A8   0x6809             LDR      R1,[R1, #+0]
   \   000000AA   0xF647 0x72C0      MOVW     R2,#+32704
   \   000000AE   0x4011             ANDS     R1,R2,R1
   \   000000B0   0x....             LDR.N    R2,??DataTable12_11  ;; 0x3fe0000
   \   000000B2   0xFAB2 0xF282      CLZ      R2,R2
   \   000000B6   0x40D1             LSRS     R1,R1,R2
   \   000000B8   0x6241             STR      R1,[R0, #+36]
   1118            RCC_OscInitStruct->PLL.PLLP = (uint32_t)((((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) + RCC_PLLCFGR_PLLP_0) << 1) >> POSITION_VAL(RCC_PLLCFGR_PLLP));
   \   000000BA   0x....             LDR.N    R1,??DataTable12_3  ;; 0x40023804
   \   000000BC   0x6809             LDR      R1,[R1, #+0]
   \   000000BE   0xF411 0x3140      ANDS     R1,R1,#0x30000
   \   000000C2   0xF511 0x3180      ADDS     R1,R1,#+65536
   \   000000C6   0x0049             LSLS     R1,R1,#+1
   \   000000C8   0xF44F 0x4240      MOV      R2,#+49152
   \   000000CC   0xFAB2 0xF282      CLZ      R2,R2
   \   000000D0   0x40D1             LSRS     R1,R1,R2
   \   000000D2   0x6281             STR      R1,[R0, #+40]
   1119            RCC_OscInitStruct->PLL.PLLQ = (uint32_t)((RCC->PLLCFGR & RCC_PLLCFGR_PLLQ) >> POSITION_VAL(RCC_PLLCFGR_PLLQ));
   \   000000D4   0x....             LDR.N    R1,??DataTable12_3  ;; 0x40023804
   \   000000D6   0x6809             LDR      R1,[R1, #+0]
   \   000000D8   0xF011 0x6170      ANDS     R1,R1,#0xF000000
   \   000000DC   0x22F0             MOVS     R2,#+240
   \   000000DE   0xFAB2 0xF282      CLZ      R2,R2
   \   000000E2   0x40D1             LSRS     R1,R1,R2
   \   000000E4   0x62C1             STR      R1,[R0, #+44]
   1120          }
   \   000000E6   0x4770             BX       LR               ;; return
   1121          
   1122          /**
   1123            * @brief  Configures the RCC_ClkInitStruct according to the internal 
   1124            * RCC configuration registers.
   1125            * @param  RCC_ClkInitStruct: pointer to an RCC_ClkInitTypeDef structure that 
   1126            * will be configured.
   1127            * @param  pFLatency: Pointer on the Flash Latency.
   1128            * @retval None
   1129            */

   \                                 In section .text, align 2, keep-with-next
   1130          void HAL_RCC_GetClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t *pFLatency)
   1131          {
   1132            /* Set all possible values for the Clock type parameter --------------------*/
   1133            RCC_ClkInitStruct->ClockType = RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2;
   \                     HAL_RCC_GetClockConfig: (+1)
   \   00000000   0x220F             MOVS     R2,#+15
   \   00000002   0x6002             STR      R2,[R0, #+0]
   1134             
   1135            /* Get the SYSCLK configuration --------------------------------------------*/ 
   1136            RCC_ClkInitStruct->SYSCLKSource = (uint32_t)(RCC->CFGR & RCC_CFGR_SW);
   \   00000004   0x....             LDR.N    R2,??DataTable12_1  ;; 0x40023808
   \   00000006   0x6812             LDR      R2,[R2, #+0]
   \   00000008   0xF012 0x0203      ANDS     R2,R2,#0x3
   \   0000000C   0x6042             STR      R2,[R0, #+4]
   1137            
   1138            /* Get the HCLK configuration ----------------------------------------------*/ 
   1139            RCC_ClkInitStruct->AHBCLKDivider = (uint32_t)(RCC->CFGR & RCC_CFGR_HPRE); 
   \   0000000E   0x....             LDR.N    R2,??DataTable12_1  ;; 0x40023808
   \   00000010   0x6812             LDR      R2,[R2, #+0]
   \   00000012   0xF012 0x02F0      ANDS     R2,R2,#0xF0
   \   00000016   0x6082             STR      R2,[R0, #+8]
   1140            
   1141            /* Get the APB1 configuration ----------------------------------------------*/ 
   1142            RCC_ClkInitStruct->APB1CLKDivider = (uint32_t)(RCC->CFGR & RCC_CFGR_PPRE1);   
   \   00000018   0x....             LDR.N    R2,??DataTable12_1  ;; 0x40023808
   \   0000001A   0x6812             LDR      R2,[R2, #+0]
   \   0000001C   0xF412 0x52E0      ANDS     R2,R2,#0x1C00
   \   00000020   0x60C2             STR      R2,[R0, #+12]
   1143            
   1144            /* Get the APB2 configuration ----------------------------------------------*/ 
   1145            RCC_ClkInitStruct->APB2CLKDivider = (uint32_t)((RCC->CFGR & RCC_CFGR_PPRE2) >> 3);
   \   00000022   0x....             LDR.N    R2,??DataTable12_1  ;; 0x40023808
   \   00000024   0x6812             LDR      R2,[R2, #+0]
   \   00000026   0x08D2             LSRS     R2,R2,#+3
   \   00000028   0xF412 0x52E0      ANDS     R2,R2,#0x1C00
   \   0000002C   0x6102             STR      R2,[R0, #+16]
   1146            
   1147            /* Get the Flash Wait State (Latency) configuration ------------------------*/   
   1148            *pFLatency = (uint32_t)(FLASH->ACR & FLASH_ACR_LATENCY); 
   \   0000002E   0x....             LDR.N    R2,??DataTable12_12  ;; 0x40023c00
   \   00000030   0x6812             LDR      R2,[R2, #+0]
   \   00000032   0xF012 0x020F      ANDS     R2,R2,#0xF
   \   00000036   0x600A             STR      R2,[R1, #+0]
   1149          }
   \   00000038   0x4770             BX       LR               ;; return
   1150          
   1151          /**
   1152            * @brief This function handles the RCC CSS interrupt request.
   1153            * @note This API should be called under the NMI_Handler().
   1154            * @retval None
   1155            */

   \                                 In section .text, align 2, keep-with-next
   1156          void HAL_RCC_NMI_IRQHandler(void)
   1157          {
   \                     HAL_RCC_NMI_IRQHandler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1158            /* Check RCC CSSF flag  */
   1159            if(__HAL_RCC_GET_IT(RCC_IT_CSS))
   \   00000002   0x....             LDR.N    R0,??DataTable12_6  ;; 0x4002380c
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x0600             LSLS     R0,R0,#+24
   \   00000008   0xD504             BPL.N    ??HAL_RCC_NMI_IRQHandler_0
   1160            {
   1161              /* RCC Clock Security System interrupt user callback */
   1162              HAL_RCC_CSSCallback();
   \   0000000A   0x.... 0x....      BL       HAL_RCC_CSSCallback
   1163          
   1164              /* Clear RCC CSS pending bit */
   1165              __HAL_RCC_CLEAR_IT(RCC_IT_CSS);
   \   0000000E   0x2080             MOVS     R0,#+128
   \   00000010   0x....             LDR.N    R1,??DataTable12_20  ;; 0x4002380e
   \   00000012   0x7008             STRB     R0,[R1, #+0]
   1166            }
   1167          }
   \                     ??HAL_RCC_NMI_IRQHandler_0: (+1)
   \   00000014   0xBD01             POP      {R0,PC}          ;; return
   1168          
   1169          /**
   1170            * @brief  RCC Clock Security System interrupt callback
   1171            * @retval None
   1172            */

   \                                 In section .text, align 2, keep-with-next
   1173          __weak void HAL_RCC_CSSCallback(void)
   1174          {
   1175            /* NOTE : This function Should not be modified, when the callback is needed,
   1176                      the HAL_RCC_CSSCallback could be implemented in the user file
   1177             */ 
   1178          }
   \                     HAL_RCC_CSSCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12:
   \   00000000   0x40023800         DC32     0x40023800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_1:
   \   00000000   0x40023808         DC32     0x40023808

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_2:
   \   00000000   0xFAF6FFFF         DC32     0xfaf6ffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_3:
   \   00000000   0x40023804         DC32     0x40023804

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_4:
   \   00000000   0x04003010         DC32     0x4003010

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_5:
   \   00000000   0x40023884         DC32     0x40023884

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_6:
   \   00000000   0x4002380C         DC32     0x4002380c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_7:
   \   00000000   0x40023874         DC32     0x40023874

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_8:
   \   00000000   0x40023840         DC32     0x40023840

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_9:
   \   00000000   0x40007000         DC32     0x40007000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_10:
   \   00000000   0x40023870         DC32     0x40023870

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_11:
   \   00000000   0x03FE0000         DC32     0x3fe0000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_12:
   \   00000000   0x40023C00         DC32     0x40023c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_13:
   \   00000000   0x40023830         DC32     0x40023830

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_14:
   \   00000000   0x40020000         DC32     0x40020000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_15:
   \   00000000   0x40020800         DC32     0x40020800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_16:
   \   00000000   0x00F42400         DC32     0xf42400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_17:
   \   00000000   0x017D7840         DC32     0x17d7840

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_18:
   \   00000000   0x........         DC32     APBAHBPrescTable

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_19:
   \   00000000   0x........         DC32     SystemCoreClock

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_20:
   \   00000000   0x4002380E         DC32     0x4002380e
   1179          
   1180          /**
   1181            * @}
   1182            */
   1183          
   1184          /**
   1185            * @}
   1186            */
   1187          
   1188          #endif /* HAL_RCC_MODULE_ENABLED */
   1189          /**
   1190            * @}
   1191            */
   1192          
   1193          /**
   1194            * @}
   1195            */
   1196          
   1197          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   HAL_RCC_CSSCallback
      16   HAL_RCC_ClockConfig
        16   -> HAL_GetTick
        16   -> HAL_InitTick
       0   HAL_RCC_DeInit
       0   HAL_RCC_DisableCSS
       0   HAL_RCC_EnableCSS
       0   HAL_RCC_GetClockConfig
       8   HAL_RCC_GetHCLKFreq
         8   -> HAL_RCC_GetSysClockFreq
       0   HAL_RCC_GetOscConfig
       8   HAL_RCC_GetPCLK1Freq
         8   -> HAL_RCC_GetHCLKFreq
       8   HAL_RCC_GetPCLK2Freq
         8   -> HAL_RCC_GetHCLKFreq
      12   HAL_RCC_GetSysClockFreq
      40   HAL_RCC_MCOConfig
        40   -> HAL_GPIO_Init
       8   HAL_RCC_NMI_IRQHandler
         8   -> HAL_RCC_CSSCallback
      24   HAL_RCC_OscConfig
        24   -> HAL_GetTick


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable12
       4  ??DataTable12_1
       4  ??DataTable12_10
       4  ??DataTable12_11
       4  ??DataTable12_12
       4  ??DataTable12_13
       4  ??DataTable12_14
       4  ??DataTable12_15
       4  ??DataTable12_16
       4  ??DataTable12_17
       4  ??DataTable12_18
       4  ??DataTable12_19
       4  ??DataTable12_2
       4  ??DataTable12_20
       4  ??DataTable12_3
       4  ??DataTable12_4
       4  ??DataTable12_5
       4  ??DataTable12_6
       4  ??DataTable12_7
       4  ??DataTable12_8
       4  ??DataTable12_9
      16  APBAHBPrescTable
       2  HAL_RCC_CSSCallback
     598  HAL_RCC_ClockConfig
     122  HAL_RCC_DeInit
      14  HAL_RCC_DisableCSS
      14  HAL_RCC_EnableCSS
      58  HAL_RCC_GetClockConfig
      40  HAL_RCC_GetHCLKFreq
     232  HAL_RCC_GetOscConfig
      32  HAL_RCC_GetPCLK1Freq
      32  HAL_RCC_GetPCLK2Freq
     164  HAL_RCC_GetSysClockFreq
     162  HAL_RCC_MCOConfig
      22  HAL_RCC_NMI_IRQHandler
    1304  HAL_RCC_OscConfig

 
    16 bytes in section .rodata
 2 880 bytes in section .text
 
 2 880 bytes of CODE  memory
    16 bytes of CONST memory

Errors: none
Warnings: none
