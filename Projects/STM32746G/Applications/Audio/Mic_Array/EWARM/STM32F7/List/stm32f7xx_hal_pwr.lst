###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.2.10312/W32 for ARM       23/Feb/2016  17:00:03
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_pwr.c
#    Command line =  
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_pwr.c
#        -D USE_HAL_DRIVER -D STM32F746xx -D USE_STM32746G_DISCO -D
#        USE_IOEXPANDER -D USE_USB_FS -lC
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
#        -lA
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
#        -o
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M7 -e --fpu=VFPv5_sp --dlib_config "D:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.3\arm\INC\c\DLib_Config_Full.h"
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\CMSIS\Device\ST\STM32F7xx\Include\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\STM32F7xx_HAL_Driver\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\STM32746G-Discovery\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\Components\Common\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Log\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Fonts\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\CPU\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_Device_Library\Core\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Core\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Class\MSC\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\drivers\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_Audio\Addons\PDM\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_Device_Library\Class\AUDIO\Inc\
#        -On --use_c++_inline --require_prototypes -I "D:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.3\arm\CMSIS\Include\" -D
#        ARM_MATH_CM7
#    List file    =  
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List\stm32f7xx_hal_pwr.lst
#    Object file  =  
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj\stm32f7xx_hal_pwr.o
#
###############################################################################

D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_pwr.c
      1          /**
                   ^
Warning[Pa050]: non-native end of line sequence detected (this diagnostic is
          only issued once)
      2            ******************************************************************************
      3            * @file    stm32f7xx_hal_pwr.c
      4            * @author  MCD Application Team
      5            * @version V1.0.1
      6            * @date    25-June-2015
      7            * @brief   PWR HAL module driver.
      8            *          This file provides firmware functions to manage the following 
      9            *          functionalities of the Power Controller (PWR) peripheral:
     10            *           + Initialization and de-initialization functions
     11            *           + Peripheral Control functions 
     12            *         
     13            ******************************************************************************
     14            * @attention
     15            *
     16            * <h2><center>&copy; COPYRIGHT(c) 2015 STMicroelectronics</center></h2>
     17            *
     18            * Redistribution and use in source and binary forms, with or without modification,
     19            * are permitted provided that the following conditions are met:
     20            *   1. Redistributions of source code must retain the above copyright notice,
     21            *      this list of conditions and the following disclaimer.
     22            *   2. Redistributions in binary form must reproduce the above copyright notice,
     23            *      this list of conditions and the following disclaimer in the documentation
     24            *      and/or other materials provided with the distribution.
     25            *   3. Neither the name of STMicroelectronics nor the names of its contributors
     26            *      may be used to endorse or promote products derived from this software
     27            *      without specific prior written permission.
     28            *
     29            * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
     30            * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     31            * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     32            * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
     33            * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
     34            * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
     35            * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
     36            * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
     37            * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
     38            * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     39            *
     40            ******************************************************************************
     41            */ 
     42          
     43          /* Includes ------------------------------------------------------------------*/
     44          #include "stm32f7xx_hal.h"
     45          
     46          /** @addtogroup STM32F7xx_HAL_Driver
     47            * @{
     48            */
     49          
     50          /** @defgroup PWR PWR
     51            * @brief PWR HAL module driver
     52            * @{
     53            */
     54          
     55          #ifdef HAL_PWR_MODULE_ENABLED
     56          
     57          /* Private typedef -----------------------------------------------------------*/
     58          /* Private define ------------------------------------------------------------*/
     59          /** @addtogroup PWR_Private_Constants
     60            * @{
     61            */
     62          	
     63          /** @defgroup PWR_PVD_Mode_Mask PWR PVD Mode Mask
     64            * @{
     65            */     
     66          #define PVD_MODE_IT               ((uint32_t)0x00010000)
     67          #define PVD_MODE_EVT              ((uint32_t)0x00020000)
     68          #define PVD_RISING_EDGE           ((uint32_t)0x00000001)
     69          #define PVD_FALLING_EDGE          ((uint32_t)0x00000002)
     70          /**
     71            * @}
     72            */
     73          
     74          /** @defgroup PWR_ENABLE_WUP_Mask PWR Enable WUP Mask
     75            * @{
     76            */  
     77          #define  PWR_EWUP_MASK                          ((uint32_t)0x00003F00)
     78          /**
     79            * @}
     80            */
     81          
     82          /**
     83            * @}
     84            */
     85          /* Private macro -------------------------------------------------------------*/
     86          /* Private variables ---------------------------------------------------------*/
     87          /* Private function prototypes -----------------------------------------------*/
     88          /* Private functions ---------------------------------------------------------*/
     89          
     90          /** @defgroup PWR_Exported_Functions PWR Exported Functions
     91            * @{
     92            */
     93          
     94          /** @defgroup PWR_Exported_Functions_Group1 Initialization and de-initialization functions 
     95            *  @brief    Initialization and de-initialization functions
     96            *
     97          @verbatim
     98           ===============================================================================
     99                        ##### Initialization and de-initialization functions #####
    100           ===============================================================================
    101              [..]
    102                After reset, the backup domain (RTC registers, RTC backup data 
    103                registers and backup SRAM) is protected against possible unwanted 
    104                write accesses. 
    105                To enable access to the RTC Domain and RTC registers, proceed as follows:
    106                  (+) Enable the Power Controller (PWR) APB1 interface clock using the
    107                      __HAL_RCC_PWR_CLK_ENABLE() macro.
    108                  (+) Enable access to RTC domain using the HAL_PWR_EnableBkUpAccess() function.
    109           
    110          @endverbatim
    111            * @{
    112            */
    113          
    114          /**
    115            * @brief Deinitializes the HAL PWR peripheral registers to their default reset values.
    116            * @retval None
    117            */

   \                                 In section .text, align 2, keep-with-next
    118          void HAL_PWR_DeInit(void)
    119          {
    120            __HAL_RCC_PWR_FORCE_RESET();
   \                     HAL_PWR_DeInit: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable15  ;; 0x40023820
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0xF050 0x5080      ORRS     R0,R0,#0x10000000
   \   00000008   0x....             LDR.N    R1,??DataTable15  ;; 0x40023820
   \   0000000A   0x6008             STR      R0,[R1, #+0]
    121            __HAL_RCC_PWR_RELEASE_RESET();
   \   0000000C   0x....             LDR.N    R0,??DataTable15  ;; 0x40023820
   \   0000000E   0x6800             LDR      R0,[R0, #+0]
   \   00000010   0xF030 0x5080      BICS     R0,R0,#0x10000000
   \   00000014   0x....             LDR.N    R1,??DataTable15  ;; 0x40023820
   \   00000016   0x6008             STR      R0,[R1, #+0]
    122          }
   \   00000018   0x4770             BX       LR               ;; return
    123          
    124          /**
    125            * @brief Enables access to the backup domain (RTC registers, RTC 
    126            *         backup data registers and backup SRAM).
    127            * @note If the HSE divided by 2, 3, ..31 is used as the RTC clock, the 
    128            *         Backup Domain Access should be kept enabled.
    129            * @retval None
    130            */

   \                                 In section .text, align 2, keep-with-next
    131          void HAL_PWR_EnableBkUpAccess(void)
    132          {
    133            /* Enable access to RTC and backup registers */
    134            SET_BIT(PWR->CR1, PWR_CR1_DBP);
   \                     HAL_PWR_EnableBkUpAccess: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable15_1  ;; 0x40007000
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0xF450 0x7080      ORRS     R0,R0,#0x100
   \   00000008   0x....             LDR.N    R1,??DataTable15_1  ;; 0x40007000
   \   0000000A   0x6008             STR      R0,[R1, #+0]
    135          }
   \   0000000C   0x4770             BX       LR               ;; return
    136          
    137          /**
    138            * @brief Disables access to the backup domain (RTC registers, RTC 
    139            *         backup data registers and backup SRAM).
    140            * @note If the HSE divided by 2, 3, ..31 is used as the RTC clock, the 
    141            *         Backup Domain Access should be kept enabled.
    142            * @retval None
    143            */

   \                                 In section .text, align 2, keep-with-next
    144          void HAL_PWR_DisableBkUpAccess(void)
    145          {
    146            /* Disable access to RTC and backup registers */
    147          	CLEAR_BIT(PWR->CR1, PWR_CR1_DBP);
   \                     HAL_PWR_DisableBkUpAccess: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable15_1  ;; 0x40007000
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0xF430 0x7080      BICS     R0,R0,#0x100
   \   00000008   0x....             LDR.N    R1,??DataTable15_1  ;; 0x40007000
   \   0000000A   0x6008             STR      R0,[R1, #+0]
    148          }
   \   0000000C   0x4770             BX       LR               ;; return
    149          
    150          /**
    151            * @}
    152            */
    153          
    154          /** @defgroup PWR_Exported_Functions_Group2 Peripheral Control functions 
    155            *  @brief Low Power modes configuration functions 
    156            *
    157          @verbatim
    158          
    159           ===============================================================================
    160                           ##### Peripheral Control functions #####
    161           ===============================================================================
    162               
    163              *** PVD configuration ***
    164              =========================
    165              [..]
    166                (+) The PVD is used to monitor the VDD power supply by comparing it to a 
    167                    threshold selected by the PVD Level (PLS[2:0] bits in the PWR_CR).
    168                (+) A PVDO flag is available to indicate if VDD/VDDA is higher or lower 
    169                    than the PVD threshold. This event is internally connected to the EXTI 
    170                    line16 and can generate an interrupt if enabled. This is done through
    171                    __HAL_PWR_PVD_EXTI_ENABLE_IT() macro.
    172                (+) The PVD is stopped in Standby mode.
    173          
    174              *** Wake-up pin configuration ***
    175              ================================
    176              [..]
    177                (+) Wake-up pin is used to wake up the system from Standby mode. This pin is 
    178                    forced in input pull-down configuration and is active on rising edges.
    179                (+) There are to 6 Wake-up pin in the STM32F7 devices family
    180          
    181              *** Low Power modes configuration ***
    182              =====================================
    183              [..]
    184                The devices feature 3 low-power modes:
    185                (+) Sleep mode: Cortex-M7 core stopped, peripherals kept running.
    186                (+) Stop mode: all clocks are stopped, regulator running, regulator 
    187                    in low power mode
    188                (+) Standby mode: 1.2V domain powered off.
    189             
    190             *** Sleep mode ***
    191             ==================
    192              [..]
    193                (+) Entry:
    194                  The Sleep mode is entered by using the HAL_PWR_EnterSLEEPMode(PWR_MAINREGULATOR_ON, PWR_SLEEPENTRY_WFI)
    195                        functions with
    196                    (++) PWR_SLEEPENTRY_WFI: enter SLEEP mode with WFI instruction
    197                    (++) PWR_SLEEPENTRY_WFE: enter SLEEP mode with WFE instruction
    198                
    199                -@@- The Regulator parameter is not used for the STM32F7 family 
    200                        and is kept as parameter just to maintain compatibility with the 
    201                        lower power families (STM32L).
    202                (+) Exit:
    203                  Any peripheral interrupt acknowledged by the nested vectored interrupt 
    204                        controller (NVIC) can wake up the device from Sleep mode.
    205          
    206             *** Stop mode ***
    207             =================
    208              [..]
    209                In Stop mode, all clocks in the 1.2V domain are stopped, the PLL, the HSI,
    210                and the HSE RC oscillators are disabled. Internal SRAM and register contents 
    211                are preserved.
    212                The voltage regulator can be configured either in normal or low-power mode.
    213                To minimize the consumption In Stop mode, FLASH can be powered off before 
    214                entering the Stop mode using the HAL_PWREx_EnableFlashPowerDown() function.
    215                It can be switched on again by software after exiting the Stop mode using
    216                the HAL_PWREx_DisableFlashPowerDown() function. 
    217          
    218                (+) Entry:
    219                   The Stop mode is entered using the HAL_PWR_EnterSTOPMode(PWR_MAINREGULATOR_ON) 
    220                       function with:
    221                    (++) Main regulator ON.
    222                    (++) Low Power regulator ON.
    223                (+) Exit:
    224                  Any EXTI Line (Internal or External) configured in Interrupt/Event mode.
    225          
    226             *** Standby mode ***
    227             ====================
    228              [..]
    229              (+)
    230                The Standby mode allows to achieve the lowest power consumption. It is based 
    231                on the Cortex-M7 deep sleep mode, with the voltage regulator disabled. 
    232                The 1.2V domain is consequently powered off. The PLL, the HSI oscillator and 
    233                the HSE oscillator are also switched off. SRAM and register contents are lost 
    234                except for the RTC registers, RTC backup registers, backup SRAM and Standby 
    235                circuitry.
    236             
    237                The voltage regulator is OFF.
    238                
    239                (++) Entry:
    240                  (+++) The Standby mode is entered using the HAL_PWR_EnterSTANDBYMode() function.
    241                (++) Exit:
    242                  (+++) WKUP pin rising or falling edge, RTC alarm (Alarm A and Alarm B), RTC
    243                       wakeup, tamper event, time stamp event, external reset in NRST pin, IWDG reset.
    244          
    245             *** Auto-wakeup (AWU) from low-power mode ***
    246             =============================================
    247              [..]
    248              
    249               (+) The MCU can be woken up from low-power mode by an RTC Alarm event, an RTC 
    250                Wakeup event, a tamper event or a time-stamp event, without depending on 
    251                an external interrupt (Auto-wakeup mode).
    252          
    253                (+) RTC auto-wakeup (AWU) from the Stop and Standby modes
    254                 
    255                  (++) To wake up from the Stop mode with an RTC alarm event, it is necessary to 
    256                        configure the RTC to generate the RTC alarm using the HAL_RTC_SetAlarm_IT() function.
    257          
    258                  (++) To wake up from the Stop mode with an RTC Tamper or time stamp event, it 
    259                       is necessary to configure the RTC to detect the tamper or time stamp event using the
    260                          HAL_RTCEx_SetTimeStamp_IT() or HAL_RTCEx_SetTamper_IT() functions.
    261                            
    262                  (++) To wake up from the Stop mode with an RTC WakeUp event, it is necessary to
    263                        configure the RTC to generate the RTC WakeUp event using the HAL_RTCEx_SetWakeUpTimer_IT() function.
    264          
    265          @endverbatim
    266            * @{
    267            */
    268          
    269          /**
    270            * @brief Configures the voltage threshold detected by the Power Voltage Detector(PVD).
    271            * @param sConfigPVD: pointer to an PWR_PVDTypeDef structure that contains the configuration
    272            *        information for the PVD.
    273            * @note Refer to the electrical characteristics of your device datasheet for
    274            *         more details about the voltage threshold corresponding to each 
    275            *         detection level.
    276            * @retval None
    277            */

   \                                 In section .text, align 2, keep-with-next
    278          void HAL_PWR_ConfigPVD(PWR_PVDTypeDef *sConfigPVD)
    279          {
    280            /* Check the parameters */
    281            assert_param(IS_PWR_PVD_LEVEL(sConfigPVD->PVDLevel));
    282            assert_param(IS_PWR_PVD_MODE(sConfigPVD->Mode));
    283            
    284            /* Set PLS[7:5] bits according to PVDLevel value */
    285            MODIFY_REG(PWR->CR1, PWR_CR1_PLS, sConfigPVD->PVDLevel);
   \                     HAL_PWR_ConfigPVD: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable15_1  ;; 0x40007000
   \   00000002   0x6809             LDR      R1,[R1, #+0]
   \   00000004   0xF031 0x01E0      BICS     R1,R1,#0xE0
   \   00000008   0x6802             LDR      R2,[R0, #+0]
   \   0000000A   0x4311             ORRS     R1,R2,R1
   \   0000000C   0x....             LDR.N    R2,??DataTable15_1  ;; 0x40007000
   \   0000000E   0x6011             STR      R1,[R2, #+0]
    286            
    287            /* Clear any previous config. Keep it clear if no event or IT mode is selected */
    288            __HAL_PWR_PVD_EXTI_DISABLE_EVENT();
   \   00000010   0x....             LDR.N    R1,??DataTable15_2  ;; 0x40013c04
   \   00000012   0x6809             LDR      R1,[R1, #+0]
   \   00000014   0xF431 0x3180      BICS     R1,R1,#0x10000
   \   00000018   0x....             LDR.N    R2,??DataTable15_2  ;; 0x40013c04
   \   0000001A   0x6011             STR      R1,[R2, #+0]
    289            __HAL_PWR_PVD_EXTI_DISABLE_IT();
   \   0000001C   0x....             LDR.N    R1,??DataTable15_3  ;; 0x40013c00
   \   0000001E   0x6809             LDR      R1,[R1, #+0]
   \   00000020   0xF431 0x3180      BICS     R1,R1,#0x10000
   \   00000024   0x....             LDR.N    R2,??DataTable15_3  ;; 0x40013c00
   \   00000026   0x6011             STR      R1,[R2, #+0]
    290            __HAL_PWR_PVD_EXTI_DISABLE_RISING_EDGE();
   \   00000028   0x....             LDR.N    R1,??DataTable15_4  ;; 0x40013c08
   \   0000002A   0x6809             LDR      R1,[R1, #+0]
   \   0000002C   0xF431 0x3180      BICS     R1,R1,#0x10000
   \   00000030   0x....             LDR.N    R2,??DataTable15_4  ;; 0x40013c08
   \   00000032   0x6011             STR      R1,[R2, #+0]
    291            __HAL_PWR_PVD_EXTI_DISABLE_FALLING_EDGE(); 
   \   00000034   0x....             LDR.N    R1,??DataTable15_5  ;; 0x40013c0c
   \   00000036   0x6809             LDR      R1,[R1, #+0]
   \   00000038   0xF431 0x3180      BICS     R1,R1,#0x10000
   \   0000003C   0x....             LDR.N    R2,??DataTable15_5  ;; 0x40013c0c
   \   0000003E   0x6011             STR      R1,[R2, #+0]
    292          
    293            /* Configure interrupt mode */
    294            if((sConfigPVD->Mode & PVD_MODE_IT) == PVD_MODE_IT)
   \   00000040   0x6841             LDR      R1,[R0, #+4]
   \   00000042   0x03C9             LSLS     R1,R1,#+15
   \   00000044   0xD505             BPL.N    ??HAL_PWR_ConfigPVD_0
    295            {
    296              __HAL_PWR_PVD_EXTI_ENABLE_IT();
   \   00000046   0x....             LDR.N    R1,??DataTable15_3  ;; 0x40013c00
   \   00000048   0x6809             LDR      R1,[R1, #+0]
   \   0000004A   0xF451 0x3180      ORRS     R1,R1,#0x10000
   \   0000004E   0x....             LDR.N    R2,??DataTable15_3  ;; 0x40013c00
   \   00000050   0x6011             STR      R1,[R2, #+0]
    297            }
    298            
    299            /* Configure event mode */
    300            if((sConfigPVD->Mode & PVD_MODE_EVT) == PVD_MODE_EVT)
   \                     ??HAL_PWR_ConfigPVD_0: (+1)
   \   00000052   0x6841             LDR      R1,[R0, #+4]
   \   00000054   0x0389             LSLS     R1,R1,#+14
   \   00000056   0xD505             BPL.N    ??HAL_PWR_ConfigPVD_1
    301            {
    302              __HAL_PWR_PVD_EXTI_ENABLE_EVENT();
   \   00000058   0x....             LDR.N    R1,??DataTable15_2  ;; 0x40013c04
   \   0000005A   0x6809             LDR      R1,[R1, #+0]
   \   0000005C   0xF451 0x3180      ORRS     R1,R1,#0x10000
   \   00000060   0x....             LDR.N    R2,??DataTable15_2  ;; 0x40013c04
   \   00000062   0x6011             STR      R1,[R2, #+0]
    303            }
    304            
    305            /* Configure the edge */
    306            if((sConfigPVD->Mode & PVD_RISING_EDGE) == PVD_RISING_EDGE)
   \                     ??HAL_PWR_ConfigPVD_1: (+1)
   \   00000064   0x7901             LDRB     R1,[R0, #+4]
   \   00000066   0x07C9             LSLS     R1,R1,#+31
   \   00000068   0xD505             BPL.N    ??HAL_PWR_ConfigPVD_2
    307            {
    308              __HAL_PWR_PVD_EXTI_ENABLE_RISING_EDGE();
   \   0000006A   0x....             LDR.N    R1,??DataTable15_4  ;; 0x40013c08
   \   0000006C   0x6809             LDR      R1,[R1, #+0]
   \   0000006E   0xF451 0x3180      ORRS     R1,R1,#0x10000
   \   00000072   0x....             LDR.N    R2,??DataTable15_4  ;; 0x40013c08
   \   00000074   0x6011             STR      R1,[R2, #+0]
    309            }
    310            
    311            if((sConfigPVD->Mode & PVD_FALLING_EDGE) == PVD_FALLING_EDGE)
   \                     ??HAL_PWR_ConfigPVD_2: (+1)
   \   00000076   0x7901             LDRB     R1,[R0, #+4]
   \   00000078   0x0789             LSLS     R1,R1,#+30
   \   0000007A   0xD505             BPL.N    ??HAL_PWR_ConfigPVD_3
    312            {
    313              __HAL_PWR_PVD_EXTI_ENABLE_FALLING_EDGE();
   \   0000007C   0x....             LDR.N    R1,??DataTable15_5  ;; 0x40013c0c
   \   0000007E   0x6809             LDR      R1,[R1, #+0]
   \   00000080   0xF451 0x3180      ORRS     R1,R1,#0x10000
   \   00000084   0x....             LDR.N    R2,??DataTable15_5  ;; 0x40013c0c
   \   00000086   0x6011             STR      R1,[R2, #+0]
    314            }
    315          }
   \                     ??HAL_PWR_ConfigPVD_3: (+1)
   \   00000088   0x4770             BX       LR               ;; return
    316          
    317          /**
    318            * @brief Enables the Power Voltage Detector(PVD).
    319            * @retval None
    320            */

   \                                 In section .text, align 2, keep-with-next
    321          void HAL_PWR_EnablePVD(void)
    322          {
    323            /* Enable the power voltage detector */
    324          	SET_BIT(PWR->CR1, PWR_CR1_PVDE);
   \                     HAL_PWR_EnablePVD: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable15_1  ;; 0x40007000
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0xF050 0x0010      ORRS     R0,R0,#0x10
   \   00000008   0x....             LDR.N    R1,??DataTable15_1  ;; 0x40007000
   \   0000000A   0x6008             STR      R0,[R1, #+0]
    325          }
   \   0000000C   0x4770             BX       LR               ;; return
    326          
    327          /**
    328            * @brief Disables the Power Voltage Detector(PVD).
    329            * @retval None
    330            */

   \                                 In section .text, align 2, keep-with-next
    331          void HAL_PWR_DisablePVD(void)
    332          {
    333            /* Disable the power voltage detector */
    334          	CLEAR_BIT(PWR->CR1, PWR_CR1_PVDE);
   \                     HAL_PWR_DisablePVD: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable15_1  ;; 0x40007000
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0xF030 0x0010      BICS     R0,R0,#0x10
   \   00000008   0x....             LDR.N    R1,??DataTable15_1  ;; 0x40007000
   \   0000000A   0x6008             STR      R0,[R1, #+0]
    335          }
   \   0000000C   0x4770             BX       LR               ;; return
    336          
    337          /**
    338            * @brief Enable the WakeUp PINx functionality.
    339            * @param WakeUpPinPolarity: Specifies which Wake-Up pin to enable.
    340            *         This parameter can be one of the following legacy values, which sets the default polarity: 
    341            *         detection on high level (rising edge):
    342            *           @arg PWR_WAKEUP_PIN1, PWR_WAKEUP_PIN2, PWR_WAKEUP_PIN3, PWR_WAKEUP_PIN4, PWR_WAKEUP_PIN5, PWR_WAKEUP_PIN6 
    343            *         or one of the following value where the user can explicitly states the enabled pin and
    344            *         the chosen polarity  
    345            *           @arg PWR_WAKEUP_PIN1_HIGH or PWR_WAKEUP_PIN1_LOW 
    346            *           @arg PWR_WAKEUP_PIN2_HIGH or PWR_WAKEUP_PIN2_LOW 
    347            *           @arg PWR_WAKEUP_PIN3_HIGH or PWR_WAKEUP_PIN3_LOW 
    348            *           @arg PWR_WAKEUP_PIN4_HIGH or PWR_WAKEUP_PIN4_LOW
    349            *           @arg PWR_WAKEUP_PIN5_HIGH or PWR_WAKEUP_PIN5_LOW 
    350            *           @arg PWR_WAKEUP_PIN6_HIGH or PWR_WAKEUP_PIN6_LOW 
    351            * @note  PWR_WAKEUP_PINx and PWR_WAKEUP_PINx_HIGH are equivalent.               
    352            * @retval None
    353            */

   \                                 In section .text, align 2, keep-with-next
    354          void HAL_PWR_EnableWakeUpPin(uint32_t WakeUpPinPolarity)
    355          {
    356            assert_param(IS_PWR_WAKEUP_PIN(WakeUpPinPolarity));
    357            
    358            /* Enable wake-up pin */
    359            SET_BIT(PWR->CSR2, (PWR_EWUP_MASK & WakeUpPinPolarity));
   \                     HAL_PWR_EnableWakeUpPin: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable15_6  ;; 0x4000700c
   \   00000002   0x6809             LDR      R1,[R1, #+0]
   \   00000004   0xF410 0x527C      ANDS     R2,R0,#0x3F00
   \   00000008   0x4311             ORRS     R1,R2,R1
   \   0000000A   0x....             LDR.N    R2,??DataTable15_6  ;; 0x4000700c
   \   0000000C   0x6011             STR      R1,[R2, #+0]
    360          	
    361            /* Specifies the Wake-Up pin polarity for the event detection
    362              (rising or falling edge) */
    363            MODIFY_REG(PWR->CR2, (PWR_EWUP_MASK & WakeUpPinPolarity), (WakeUpPinPolarity >> 0x06));
   \   0000000E   0x....             LDR.N    R1,??DataTable15_7  ;; 0x40007008
   \   00000010   0x6809             LDR      R1,[R1, #+0]
   \   00000012   0xF410 0x527C      ANDS     R2,R0,#0x3F00
   \   00000016   0x4391             BICS     R1,R1,R2
   \   00000018   0xEA51 0x1190      ORRS     R1,R1,R0, LSR #+6
   \   0000001C   0x....             LDR.N    R2,??DataTable15_7  ;; 0x40007008
   \   0000001E   0x6011             STR      R1,[R2, #+0]
    364          }
   \   00000020   0x4770             BX       LR               ;; return
    365          
    366          /**
    367            * @brief Disables the WakeUp PINx functionality.
    368            * @param WakeUpPinx: Specifies the Power Wake-Up pin to disable.
    369            *         This parameter can be one of the following values:
    370            *           @arg PWR_WAKEUP_PIN1
    371            *           @arg PWR_WAKEUP_PIN2
    372            *           @arg PWR_WAKEUP_PIN3
    373            *           @arg PWR_WAKEUP_PIN4
    374            *           @arg PWR_WAKEUP_PIN5
    375            *           @arg PWR_WAKEUP_PIN6 
    376            * @retval None
    377            */

   \                                 In section .text, align 2, keep-with-next
    378          void HAL_PWR_DisableWakeUpPin(uint32_t WakeUpPinx)
    379          {
    380            assert_param(IS_PWR_WAKEUP_PIN(WakeUpPinx));
    381          
    382            CLEAR_BIT(PWR->CSR2, WakeUpPinx);
   \                     HAL_PWR_DisableWakeUpPin: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable15_6  ;; 0x4000700c
   \   00000002   0x6809             LDR      R1,[R1, #+0]
   \   00000004   0x4381             BICS     R1,R1,R0
   \   00000006   0x....             LDR.N    R2,??DataTable15_6  ;; 0x4000700c
   \   00000008   0x6011             STR      R1,[R2, #+0]
    383          }
   \   0000000A   0x4770             BX       LR               ;; return
    384            
    385          /**
    386            * @brief Enters Sleep mode.
    387            *   
    388            * @note In Sleep mode, all I/O pins keep the same state as in Run mode.
    389            * 
    390            * @note In Sleep mode, the systick is stopped to avoid exit from this mode with
    391            *       systick interrupt when used as time base for Timeout 
    392            *                
    393            * @param Regulator: Specifies the regulator state in SLEEP mode.
    394            *            This parameter can be one of the following values:
    395            *            @arg PWR_MAINREGULATOR_ON: SLEEP mode with regulator ON
    396            *            @arg PWR_LOWPOWERREGULATOR_ON: SLEEP mode with low power regulator ON
    397            * @note This parameter is not used for the STM32F7 family and is kept as parameter
    398            *       just to maintain compatibility with the lower power families.
    399            * @param SLEEPEntry: Specifies if SLEEP mode in entered with WFI or WFE instruction.
    400            *          This parameter can be one of the following values:
    401            *            @arg PWR_SLEEPENTRY_WFI: enter SLEEP mode with WFI instruction
    402            *            @arg PWR_SLEEPENTRY_WFE: enter SLEEP mode with WFE instruction
    403            * @retval None
    404            */

   \                                 In section .text, align 2, keep-with-next
    405          void HAL_PWR_EnterSLEEPMode(uint32_t Regulator, uint8_t SLEEPEntry)
    406          {
    407            /* Check the parameters */
    408            assert_param(IS_PWR_REGULATOR(Regulator));
    409            assert_param(IS_PWR_SLEEP_ENTRY(SLEEPEntry));
    410          
    411            /* Clear SLEEPDEEP bit of Cortex System Control Register */
    412            CLEAR_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));
   \                     HAL_PWR_EnterSLEEPMode: (+1)
   \   00000000   0x....             LDR.N    R2,??DataTable15_8  ;; 0xe000ed10
   \   00000002   0x6812             LDR      R2,[R2, #+0]
   \   00000004   0xF032 0x0204      BICS     R2,R2,#0x4
   \   00000008   0x....             LDR.N    R3,??DataTable15_8  ;; 0xe000ed10
   \   0000000A   0x601A             STR      R2,[R3, #+0]
    413          
    414            /* Select SLEEP mode entry -------------------------------------------------*/
    415            if(SLEEPEntry == PWR_SLEEPENTRY_WFI)
   \   0000000C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000E   0x2901             CMP      R1,#+1
   \   00000010   0xD101             BNE.N    ??HAL_PWR_EnterSLEEPMode_0
    416            {   
    417              /* Request Wait For Interrupt */
    418              __WFI();
   \   00000012   0xBF30             WFI      
   \   00000014   0xE002             B.N      ??HAL_PWR_EnterSLEEPMode_1
    419            }
    420            else
    421            {
    422              /* Request Wait For Event */
    423              __SEV();
   \                     ??HAL_PWR_EnterSLEEPMode_0: (+1)
   \   00000016   0xBF40             SEV      
    424              __WFE();
   \   00000018   0xBF20             WFE      
    425              __WFE();
   \   0000001A   0xBF20             WFE      
    426            }
    427          }
   \                     ??HAL_PWR_EnterSLEEPMode_1: (+1)
   \   0000001C   0x4770             BX       LR               ;; return
    428          
    429          /**
    430            * @brief Enters Stop mode. 
    431            * @note In Stop mode, all I/O pins keep the same state as in Run mode.
    432            * @note When exiting Stop mode by issuing an interrupt or a wakeup event, 
    433            *         the HSI RC oscillator is selected as system clock.
    434            * @note When the voltage regulator operates in low power mode, an additional 
    435            *         startup delay is incurred when waking up from Stop mode. 
    436            *         By keeping the internal regulator ON during Stop mode, the consumption 
    437            *         is higher although the startup time is reduced.    
    438            * @param Regulator: Specifies the regulator state in Stop mode.
    439            *          This parameter can be one of the following values:
    440            *            @arg PWR_MAINREGULATOR_ON: Stop mode with regulator ON
    441            *            @arg PWR_LOWPOWERREGULATOR_ON: Stop mode with low power regulator ON
    442            * @param STOPEntry: Specifies if Stop mode in entered with WFI or WFE instruction.
    443            *          This parameter can be one of the following values:
    444            *            @arg PWR_STOPENTRY_WFI: Enter Stop mode with WFI instruction
    445            *            @arg PWR_STOPENTRY_WFE: Enter Stop mode with WFE instruction
    446            * @retval None
    447            */

   \                                 In section .text, align 2, keep-with-next
    448          void HAL_PWR_EnterSTOPMode(uint32_t Regulator, uint8_t STOPEntry)
    449          {
   \                     HAL_PWR_EnterSTOPMode: (+1)
   \   00000000   0xB410             PUSH     {R4}
    450            uint32_t tmpreg = 0;
   \   00000002   0x2200             MOVS     R2,#+0
    451            
    452            /* Check the parameters */
    453            assert_param(IS_PWR_REGULATOR(Regulator));
    454            assert_param(IS_PWR_STOP_ENTRY(STOPEntry));
    455            
    456            /* Select the regulator state in Stop mode ---------------------------------*/
    457            tmpreg = PWR->CR1;
   \   00000004   0x....             LDR.N    R3,??DataTable15_1  ;; 0x40007000
   \   00000006   0x681B             LDR      R3,[R3, #+0]
   \   00000008   0x001A             MOVS     R2,R3
    458            /* Clear PDDS and LPDS bits */
    459            tmpreg &= (uint32_t)~(PWR_CR1_PDDS | PWR_CR1_LPDS);
   \   0000000A   0x0892             LSRS     R2,R2,#+2
   \   0000000C   0x0092             LSLS     R2,R2,#+2
    460            
    461            /* Set LPDS, MRLVDS and LPLVDS bits according to Regulator value */
    462            tmpreg |= Regulator;
   \   0000000E   0x4302             ORRS     R2,R0,R2
    463            
    464            /* Store the new value */
    465            PWR->CR1 = tmpreg;
   \   00000010   0x....             LDR.N    R3,??DataTable15_1  ;; 0x40007000
   \   00000012   0x601A             STR      R2,[R3, #+0]
    466            
    467            /* Set SLEEPDEEP bit of Cortex System Control Register */
    468            SCB->SCR |= SCB_SCR_SLEEPDEEP_Msk;
   \   00000014   0x....             LDR.N    R3,??DataTable15_8  ;; 0xe000ed10
   \   00000016   0x681B             LDR      R3,[R3, #+0]
   \   00000018   0xF053 0x0304      ORRS     R3,R3,#0x4
   \   0000001C   0x....             LDR.N    R4,??DataTable15_8  ;; 0xe000ed10
   \   0000001E   0x6023             STR      R3,[R4, #+0]
    469            
    470            /* Select Stop mode entry --------------------------------------------------*/
    471            if(STOPEntry == PWR_STOPENTRY_WFI)
   \   00000020   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000022   0x2901             CMP      R1,#+1
   \   00000024   0xD101             BNE.N    ??HAL_PWR_EnterSTOPMode_0
    472            {   
    473              /* Request Wait For Interrupt */
    474              __WFI();
   \   00000026   0xBF30             WFI      
   \   00000028   0xE002             B.N      ??HAL_PWR_EnterSTOPMode_1
    475            }
    476            else
    477            {
    478              /* Request Wait For Event */
    479              __SEV();
   \                     ??HAL_PWR_EnterSTOPMode_0: (+1)
   \   0000002A   0xBF40             SEV      
    480              __WFE();
   \   0000002C   0xBF20             WFE      
    481              __WFE();
   \   0000002E   0xBF20             WFE      
    482            }
    483            /* Reset SLEEPDEEP bit of Cortex System Control Register */
    484            SCB->SCR &= (uint32_t)~((uint32_t)SCB_SCR_SLEEPDEEP_Msk);  
   \                     ??HAL_PWR_EnterSTOPMode_1: (+1)
   \   00000030   0x....             LDR.N    R3,??DataTable15_8  ;; 0xe000ed10
   \   00000032   0x681B             LDR      R3,[R3, #+0]
   \   00000034   0xF033 0x0304      BICS     R3,R3,#0x4
   \   00000038   0x....             LDR.N    R4,??DataTable15_8  ;; 0xe000ed10
   \   0000003A   0x6023             STR      R3,[R4, #+0]
    485          }
   \   0000003C   0xBC10             POP      {R4}
   \   0000003E   0x4770             BX       LR               ;; return
    486          
    487          /**
    488            * @brief Enters Standby mode.
    489            * @note In Standby mode, all I/O pins are high impedance except for:
    490            *          - Reset pad (still available) 
    491            *          - RTC_AF1 pin (PC13) if configured for tamper, time-stamp, RTC 
    492            *            Alarm out, or RTC clock calibration out.
    493            *          - RTC_AF2 pin (PI8) if configured for tamper or time-stamp.  
    494            *          - WKUP pins if enabled.       
    495            * @retval None
    496            */

   \                                 In section .text, align 2, keep-with-next
    497          void HAL_PWR_EnterSTANDBYMode(void)
    498          {
    499            /* Select Standby mode */
    500            PWR->CR1 |= PWR_CR1_PDDS;
   \                     HAL_PWR_EnterSTANDBYMode: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable15_1  ;; 0x40007000
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   00000008   0x....             LDR.N    R1,??DataTable15_1  ;; 0x40007000
   \   0000000A   0x6008             STR      R0,[R1, #+0]
    501            
    502            /* Set SLEEPDEEP bit of Cortex System Control Register */
    503            SCB->SCR |= SCB_SCR_SLEEPDEEP_Msk;
   \   0000000C   0x....             LDR.N    R0,??DataTable15_8  ;; 0xe000ed10
   \   0000000E   0x6800             LDR      R0,[R0, #+0]
   \   00000010   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   00000014   0x....             LDR.N    R1,??DataTable15_8  ;; 0xe000ed10
   \   00000016   0x6008             STR      R0,[R1, #+0]
    504            
    505            /* This option is used to ensure that store operations are completed */
    506          #if defined ( __CC_ARM)
    507            __force_stores();
    508          #endif
    509            /* Request Wait For Interrupt */
    510            __WFI();
   \   00000018   0xBF30             WFI      
    511          }
   \   0000001A   0x4770             BX       LR               ;; return
    512          
    513          /**
    514            * @brief This function handles the PWR PVD interrupt request.
    515            * @note This API should be called under the PVD_IRQHandler().
    516            * @retval None
    517            */

   \                                 In section .text, align 2, keep-with-next
    518          void HAL_PWR_PVD_IRQHandler(void)
    519          {
   \                     HAL_PWR_PVD_IRQHandler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    520            /* Check PWR Exti flag */
    521            if(__HAL_PWR_PVD_EXTI_GET_FLAG() != RESET)
   \   00000002   0x....             LDR.N    R0,??DataTable15_9  ;; 0x40013c14
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x03C0             LSLS     R0,R0,#+15
   \   00000008   0xD505             BPL.N    ??HAL_PWR_PVD_IRQHandler_0
    522            {
    523              /* PWR PVD interrupt user callback */
    524              HAL_PWR_PVDCallback();
   \   0000000A   0x.... 0x....      BL       HAL_PWR_PVDCallback
    525              
    526              /* Clear PWR Exti pending bit */
    527              __HAL_PWR_PVD_EXTI_CLEAR_FLAG();
   \   0000000E   0xF45F 0x3080      MOVS     R0,#+65536
   \   00000012   0x....             LDR.N    R1,??DataTable15_9  ;; 0x40013c14
   \   00000014   0x6008             STR      R0,[R1, #+0]
    528            }
    529          }
   \                     ??HAL_PWR_PVD_IRQHandler_0: (+1)
   \   00000016   0xBD01             POP      {R0,PC}          ;; return
    530          
    531          /**
    532            * @brief  PWR PVD interrupt callback
    533            * @retval None
    534            */

   \                                 In section .text, align 2, keep-with-next
    535          __weak void HAL_PWR_PVDCallback(void)
    536          {
    537            /* NOTE : This function Should not be modified, when the callback is needed,
    538                      the HAL_PWR_PVDCallback could be implemented in the user file
    539             */ 
    540          }
   \                     HAL_PWR_PVDCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    541          
    542          /**
    543            * @brief Indicates Sleep-On-Exit when returning from Handler mode to Thread mode. 
    544            * @note Set SLEEPONEXIT bit of SCR register. When this bit is set, the processor 
    545            *       re-enters SLEEP mode when an interruption handling is over.
    546            *       Setting this bit is useful when the processor is expected to run only on
    547            *       interruptions handling.         
    548            * @retval None
    549            */

   \                                 In section .text, align 2, keep-with-next
    550          void HAL_PWR_EnableSleepOnExit(void)
    551          {
    552            /* Set SLEEPONEXIT bit of Cortex System Control Register */
    553            SET_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPONEXIT_Msk));
   \                     HAL_PWR_EnableSleepOnExit: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable15_8  ;; 0xe000ed10
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   00000008   0x....             LDR.N    R1,??DataTable15_8  ;; 0xe000ed10
   \   0000000A   0x6008             STR      R0,[R1, #+0]
    554          }
   \   0000000C   0x4770             BX       LR               ;; return
    555          
    556          /**
    557            * @brief Disables Sleep-On-Exit feature when returning from Handler mode to Thread mode. 
    558            * @note Clears SLEEPONEXIT bit of SCR register. When this bit is set, the processor 
    559            *       re-enters SLEEP mode when an interruption handling is over.          
    560            * @retval None
    561            */

   \                                 In section .text, align 2, keep-with-next
    562          void HAL_PWR_DisableSleepOnExit(void)
    563          {
    564            /* Clear SLEEPONEXIT bit of Cortex System Control Register */
    565            CLEAR_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPONEXIT_Msk));
   \                     HAL_PWR_DisableSleepOnExit: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable15_8  ;; 0xe000ed10
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0xF030 0x0002      BICS     R0,R0,#0x2
   \   00000008   0x....             LDR.N    R1,??DataTable15_8  ;; 0xe000ed10
   \   0000000A   0x6008             STR      R0,[R1, #+0]
    566          }
   \   0000000C   0x4770             BX       LR               ;; return
    567          
    568          /**
    569            * @brief Enables CORTEX M4 SEVONPEND bit. 
    570            * @note Sets SEVONPEND bit of SCR register. When this bit is set, this causes 
    571            *       WFE to wake up when an interrupt moves from inactive to pended.
    572            * @retval None
    573            */

   \                                 In section .text, align 2, keep-with-next
    574          void HAL_PWR_EnableSEVOnPend(void)
    575          {
    576            /* Set SEVONPEND bit of Cortex System Control Register */
    577            SET_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SEVONPEND_Msk));
   \                     HAL_PWR_EnableSEVOnPend: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable15_8  ;; 0xe000ed10
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0xF050 0x0010      ORRS     R0,R0,#0x10
   \   00000008   0x....             LDR.N    R1,??DataTable15_8  ;; 0xe000ed10
   \   0000000A   0x6008             STR      R0,[R1, #+0]
    578          }
   \   0000000C   0x4770             BX       LR               ;; return
    579          
    580          /**
    581            * @brief Disables CORTEX M4 SEVONPEND bit. 
    582            * @note Clears SEVONPEND bit of SCR register. When this bit is set, this causes 
    583            *       WFE to wake up when an interrupt moves from inactive to pended.         
    584            * @retval None
    585            */

   \                                 In section .text, align 2, keep-with-next
    586          void HAL_PWR_DisableSEVOnPend(void)
    587          {
    588            /* Clear SEVONPEND bit of Cortex System Control Register */
    589            CLEAR_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SEVONPEND_Msk));
   \                     HAL_PWR_DisableSEVOnPend: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable15_8  ;; 0xe000ed10
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0xF030 0x0010      BICS     R0,R0,#0x10
   \   00000008   0x....             LDR.N    R1,??DataTable15_8  ;; 0xe000ed10
   \   0000000A   0x6008             STR      R0,[R1, #+0]
    590          }
   \   0000000C   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15:
   \   00000000   0x40023820         DC32     0x40023820

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_1:
   \   00000000   0x40007000         DC32     0x40007000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_2:
   \   00000000   0x40013C04         DC32     0x40013c04

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_3:
   \   00000000   0x40013C00         DC32     0x40013c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_4:
   \   00000000   0x40013C08         DC32     0x40013c08

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_5:
   \   00000000   0x40013C0C         DC32     0x40013c0c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_6:
   \   00000000   0x4000700C         DC32     0x4000700c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_7:
   \   00000000   0x40007008         DC32     0x40007008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_8:
   \   00000000   0xE000ED10         DC32     0xe000ed10

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_9:
   \   00000000   0x40013C14         DC32     0x40013c14
    591          
    592          /**
    593            * @}
    594            */
    595            
    596          /**
    597            * @}
    598            */
    599          
    600          #endif /* HAL_PWR_MODULE_ENABLED */
    601          /**
    602            * @}
    603            */
    604          
    605          /**
    606            * @}
    607            */
    608          
    609          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   HAL_PWR_ConfigPVD
       0   HAL_PWR_DeInit
       0   HAL_PWR_DisableBkUpAccess
       0   HAL_PWR_DisablePVD
       0   HAL_PWR_DisableSEVOnPend
       0   HAL_PWR_DisableSleepOnExit
       0   HAL_PWR_DisableWakeUpPin
       0   HAL_PWR_EnableBkUpAccess
       0   HAL_PWR_EnablePVD
       0   HAL_PWR_EnableSEVOnPend
       0   HAL_PWR_EnableSleepOnExit
       0   HAL_PWR_EnableWakeUpPin
       0   HAL_PWR_EnterSLEEPMode
       0   HAL_PWR_EnterSTANDBYMode
       4   HAL_PWR_EnterSTOPMode
       0   HAL_PWR_PVDCallback
       8   HAL_PWR_PVD_IRQHandler
         8   -> HAL_PWR_PVDCallback


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable15
       4  ??DataTable15_1
       4  ??DataTable15_2
       4  ??DataTable15_3
       4  ??DataTable15_4
       4  ??DataTable15_5
       4  ??DataTable15_6
       4  ??DataTable15_7
       4  ??DataTable15_8
       4  ??DataTable15_9
     138  HAL_PWR_ConfigPVD
      26  HAL_PWR_DeInit
      14  HAL_PWR_DisableBkUpAccess
      14  HAL_PWR_DisablePVD
      14  HAL_PWR_DisableSEVOnPend
      14  HAL_PWR_DisableSleepOnExit
      12  HAL_PWR_DisableWakeUpPin
      14  HAL_PWR_EnableBkUpAccess
      14  HAL_PWR_EnablePVD
      14  HAL_PWR_EnableSEVOnPend
      14  HAL_PWR_EnableSleepOnExit
      34  HAL_PWR_EnableWakeUpPin
      30  HAL_PWR_EnterSLEEPMode
      28  HAL_PWR_EnterSTANDBYMode
      64  HAL_PWR_EnterSTOPMode
       2  HAL_PWR_PVDCallback
      24  HAL_PWR_PVD_IRQHandler

 
 510 bytes in section .text
 
 510 bytes of CODE memory

Errors: none
Warnings: 1
